{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012045000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1058148, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE449.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE449.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x12\\x06'", "DS1TRBAL": "b'\\x95H'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x035\\x00\\x0e\\x037\\x00\\x02\\x00\\x13'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"@@BOOK@@": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\\x17O\\x01\\x00\\x17\\x7f\\t6\\x00\\xdd\\x006\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2000-06-25T09:36:00", "lines": 221, "newlines": 54, "modlines": 0, "user": "KEM00"}, "text": "                     WHAT DOCUMENTATION YOU GET\n\nThe Amdahl BookManager BookServer Front-end provides a means to search\na \"catalog\" of all book titles and publication numbers kept in MVS\nBookManager Sequential Data Sets and link directly to the Book or\nBookShelf containing the Book.  While obviously dependent on the title\nof the Book, it eliminates the User having to know which BookShelf\ncontains the Book he or she is looking for.  It supports only Books and\nBookShelves kept in MVS sequential Data Sets, not anything kept in an\nHFS.\n\nThis data Set contains a subset(*) of the Amdahl BookManager Management\nUtilities.  What is included are those pieces needed to run the\nBookServer Front-end.\n\nList of provided members:\n\nBKMGRCPS - Assembler Macro\nBKMGRHST - Assembler Macro\nBKMGRINF - Assembler Macro\nBKMGRLOC - Assembler Macro\n\nBOOKMGRX - BookServer Front-end CGI (WebServer) REXX EXEC\n\nBKMGRLPA - USERMOD to create LPA resident BookSERVER Load Module\n\nBOOKCSA  - Started Task JCL to run CCCBKACE (Search Data CSA Load)\nBOOKSACE - JCL to run CCCBKACE (Search Data CSA Load)\nBOOKSEXT - JCL to build search data from BookShelf List(s) (QLSHELF)\nREXXCOMP - JCL to compile the REXX Exec and copy it to an HFS\n\nCCCBKACE - Assembler Source - Load Search Data into CSA\nCCCBKCPS - Assembler Source - Cell Pool Subroutine\nCCCBKDAT - Assembler Source - Data Variable Table\nCCCBKDEF - Assembler Source - Data Table Lookup Subroutine\nCCCBKDSN - Assembler Source - Data Set Name Generator Subroutine\nCCCBKEXT - Assembler Source - Build Book/BookShelf Extract Data Set\nCCCBKLOC - Assembler Source - Determine location of all Bkmgr Data Sets\nCCCBKPUB - Assembler Source - Format Pub Number Subroutine\nCCCBKSRV - Assembler Source - Search Program called by REXX EXEC\nCCCLOCAT - Assembler Source - LOCATE TSO Command - bonus\n\nI assume that you're capable of assembling programs, so I'm not\nincluding sample assembly JCL.  Each program is linked by itself.\nMACLIB and MODGEN are needed along with the Macros supplied above.\n\nCCCBKCPS, CCCBKDAT, CCCBKDEF, CCCBKDSN, CCCBKPUB, and CCCBKSRV are\nre-entrant and RMODE ANY. (So is CCCLOCAT, but it's included as a bonus\nand is not really needed.)  CCCBKACE, CCCBKEXT, and CCCBKLOC are \"main\"\nprograms that are NOT re-rentrant and are RMODE 24 (AMODE 31).\n\nAssemble and Link all the programs into a \"BookManager Utility\" Load\nLibrary.  CCCBKEXT is unauthorized and can run from it.  CCCBKACE is\nAUTHORIZED, so it (and CCCBKCPS which it loads as a subroutine) need\nto be placed in an authorized library (that end-users should not have\naccess to).  CCCBKSRV should be placed in the LinkList or LPAList, as\nit is used by the CGI REXX Exec.\n\nBOOKMGRX is a REXX Exec that will require installation specific\ncustomization (unless you like to see some missing GIFs and bad links).\nIt (or a complied version of it) needs to end up in a HFS that will be\nmapped in directives in the WebServer HTTPD.CONF file.\n\n\nBefore going any farther....\n\nThis BookServer Front-end builds an ECSA Resident Catalog which is\nanchored using the time-honored technique of using a SubSystem Control\nTable (SSCT).  The default name of this SubSystem is \"BKSV\".  This value\nis EQUated in the BKMGRCSA Macro (Label BKASSNAM).  If you want a\ndifferent SubSystem Name, change this equate and reassemble CCCBKACE and\nCCCBKSRV.\n\nThere is no attempt made to create the \"BKSV\" SubSystem Control Table\ndynamically if it doesn't exist.  You will need to update the IEFSSNxx\nPARMLIB Member and then either re-IPL or use the SETSSI Command to\ncreate it.\n\nIf you don't like this anchor technique and want to change it, go ahead.\n\n\nBuilding the Book Catalog Data Set\n\nThe CCCBKEXT program uses the MVS BookManager \"Master\" BookShelf List\nData Set (specified by the QLSHELF setting in EOXVOPTS REXX Exec) to\nconstruct the Book and BookShelf Catalog.  The BookShelf List Data Set\nName is specified as a parameter in the JCL used to execute CCCBKEXT.\nThe output Data Set is VB,259.  Sample JCL is provided in the BOOKSEXT\nmember.  Note that the output needs to be sorted in order to be\nproperly searchable.\n\nThe sample job is two steps.  The extract is to a temporary Data Set.\nThe sort of this temporary Data Set is output to a permanent extract\nData Set which will be used to create the in storage copy.\n\n\nBuilding the In Storage Catalog\n\nThe CCCBKACE program use the Book Catalog Data Set to create a Common\nStorage copy of the Book Catalog (in Key 1 Storage) and anchor it in\nthe chosen SSCT.  This eliminates the I/O associated with reading the\nCatalog Data Set (which in our case is 5 cylinders) for each and every\nsearch.\n\nThis program, which is authorized since it needs to obtain CSA, can be\nrun as either a Batch Job or Started Task.  A sample of each is\nprovided.  We runs it as a Started Task specified in our COMMND00\nPARMLIB member, so it runs at every IPL on every System.  In addition,\nit can be run at any time to refresh the in storage Book Catalog\nwhenever updates have been made to the BookManager BookShelf List and\nthe Catalog Data Set rebuilt.  If a previous in storage Book Catalog\nexists, the old one is freed and the new one built, so there should be\nno lost CSA.\n\n\nBookServer CGI REXX Exec\n\nThe BOOKMGRX REXX Exec and the CCCBKSRV program are the heart of the\nBookServer Front-end. The REXX Exec (raw or compiled) must be placed\ninto an installation HFS directory that is mapped by an \"Exec\"\ndirective in the BookServer's HTTPD.CONF file (more on that later).\nThe sample REXX Compile job shows how to place the compiled REXX\nExec (CEXEC) into the chosen HFS.  Whatever name is chosen for the\nfile in the HFS (compiled or not) will be part of the URL to invoke it\n(and like everything in UNIX is CaSe SeNsItIvE).\n\nThis REXX Exec will need customization for your installation, as it\nhas a whole lot of Amdahl specific GIFs and links.  They are \"fairly\"\nisolated, but it's your responsibility to find and fix 'em.  Also,\nthe BookServer URLs are different based on the level of the BookServer\nyou are running and whether or not you have moved the BookServer CGI\nLoad Module (bookmgr.exe) into LPA (as described in my SHARE\npresentation and included as a Local Mod).  This, too, will have to\nbe changed.\n\nThe CCCBKSRV program is invoked by the REXX Exec to perform the actual\nsearch of the in storage Book Catalog and return the results in a pool\nof REXX stem variables.  Because this program is invoked using the\n\"address LINKMVS\" REXX statement, it needs to be available to whatever\nAddress Space the REXX Exec runs in.  The easiest way to accomplish\nthis is to place it in a Link List Data Set or (since it's re-entrant\nand RMODE ANY) an LPA List Data Set.  This program is unauthorized\nand needs no special attributes.\n\n\nHTTPD.CONF Updates\n\nSo, you've assembled the programs, stashed the REXX Exec, and created\nthe in storage Book Catalog.  Now you need to get the BookServer\nWebServer to invoke the REXX Exec CGI.  To do this, you need to add\ndirectives to the HTTPD.CONF (or whatever you've called it) file that\nis used by the BookServer's WebServer.\n\nYou've already had to add \"Pass\" and \"Exec\" directives to this file\nfor the BookServer itself, so you (or at least someone in your\ninstallation) are somewhat familiar with this process.  For purposes\nof the samples provided below, let's assume the following:\n\n     The main BookServer Front-end Directory is: '/BookServer'\n     The CGI BookServer Front-end Directory is: '/BookServer/cgi'\n     BookManager Data Sets all start with 'CCCPUBS.' (needed for PDFs)\n     The URL \"code\" for the Front-end CGI is: '/bookmanager-cgi'\n     The URL \"code\" for the Front-end files is: '/bookmanager'\n     The REXX Exec HFS file name is: 'bookmanager'\n\n(Again, note the UNIX is very case sensitive.)\n\nSo stick the following two lines in the HTTPD.CONF after the lines\nthat were inserted for the IBM BookServer:\n\nExec            /bookmanager-cgi/*   /BookServer/cgi/*\nPass            /bookmanager/*   /BookServer/*\n\nSo given all of the above, a URL of:\n\nhttp://your.mvs.domain.name:portnumber/bookmanager-cgi/bookmanager/\n\nwill bring up the BookServer Front-end, from which everything else is\nself-explanatory (yah, right!). The trailing slash in the URL is\nrequired for some browsers and not for others, but it doesn't hurt to\nalways code it.\n\nAssuming that the User has the Adobe Acrobat Plug-in in his or her\nbrowser, and that you have uploaded BOOK PDF files to MVS (as binary\nfiles into any suitable VB format Data Set) using the same Data Set Name\nas the BookManager Book with 'PDF' instead of 'BOOK' as the lowest\nlevel qualifier, the BookServer Front-end is capable of allowing the\nUser to view the PDF file for a Book which has been located via the\nsearch.\n\nTo be able to view these PDF files, you need to have a couple of\n\"Service\" Directives in the HTTPD.CONF File.  Find where IBM stuck the\nsample commented out \"mvsds.so\" Service Statement and add the following\ntwo statements:\n\nService /bookmanager-pdf/'cccpubs.*      (continued on next line)\n/usr/lpp/internet/bin/mvsds.so:mvsdsGet/'cccpubs.*\nService /bookmanager-pdf/'CCCPUBS.*      (continued on next line)\n/usr/lpp/internet/bin/mvsds.so:mvsdsGet/'CCCPUBS.*\n\n\nDisclaimer\n\nAs usual, Amdahl Corporation (and I) take no responsibility for how\nwell this works in your environment and any problems it might cause.\nSuffice it to say, it does work, as our Users use it regularly.  (I\nalso think that it is a good introduction to CGI programming in REXX\nwith the IBM WebServer.)\n\nFeel free to contact me with questions, problems, and suggestions, but\nplease keep in mind that I do have other things to do.\n\n\nKeith E. Moe\nAmdahl Corporation\n1250 E. Arques Ave\nM/S 383\nSunnyvale, Ca  94088-3470\n(408) 746-6386\nKeith_Moe@notes.amdahl.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE449": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x00\\x17O\\x01\\x00\\x17\\x7f\\tY\\x00\\xfe\\x006\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2000-06-25T09:59:00", "lines": 254, "newlines": 54, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 449 is from Keith Moe of Amdahl, and contains their       *   FILE 449\n//*           Bookmanager front end package.                        *   FILE 449\n//*                                                                 *   FILE 449\n//*     Keith E. Moe                                                *   FILE 449\n//*     Amdahl Corporation                                          *   FILE 449\n//*     1250 E. Arques Ave                                          *   FILE 449\n//*     M/S 383                                                     *   FILE 449\n//*     Sunnyvale, Ca  94088-3470                                   *   FILE 449\n//*     (408) 746-6386                                              *   FILE 449\n//*     Keith_Moe@notes.amdahl.com                                  *   FILE 449\n//*                                                                 *   FILE 449\n//*     Disclaimer                                                  *   FILE 449\n//*                                                                 *   FILE 449\n//*     As usual, Amdahl Corporation (and I) take no                *   FILE 449\n//*     responsibility for how well this works in your              *   FILE 449\n//*     environment and any problems it might cause.  Suffice       *   FILE 449\n//*     it to say, it does work, as our Users use it regularly.     *   FILE 449\n//*     (I also think that it is a good introduction to CGI         *   FILE 449\n//*     programming in REXX with the IBM WebServer.)                *   FILE 449\n//*                                                                 *   FILE 449\n//*        Detailed documentation of this package follows:          *   FILE 449\n//*                                                                 *   FILE 449\n//*     The Amdahl BookManager BookServer Front-end provides a      *   FILE 449\n//*     means to search a \"catalog\" of all book titles and          *   FILE 449\n//*     publication numbers kept in MVS BookManager Sequential      *   FILE 449\n//*     Data Sets and link directly to the Book or BookShelf        *   FILE 449\n//*     containing the Book.  While obviously dependent on the      *   FILE 449\n//*     title of the Book, it eliminates the User having to know    *   FILE 449\n//*     which BookShelf contains the Book he or she is looking      *   FILE 449\n//*     for.  It supports only Books and BookShelves kept in MVS    *   FILE 449\n//*     sequential Data Sets, not anything kept in an HFS.          *   FILE 449\n//*                                                                 *   FILE 449\n//*     This data Set contains a subset(*) of the Amdahl            *   FILE 449\n//*     BookManager Management Utilities.  What is included are     *   FILE 449\n//*     those pieces needed to run the BookServer Front-end.        *   FILE 449\n//*                                                                 *   FILE 449\n//*     List of provided members:                                   *   FILE 449\n//*                                                                 *   FILE 449\n//*     BKMGRCPS - Assembler Macro                                  *   FILE 449\n//*     BKMGRHST - Assembler Macro                                  *   FILE 449\n//*     BKMGRINF - Assembler Macro                                  *   FILE 449\n//*     BKMGRLOC - Assembler Macro                                  *   FILE 449\n//*                                                                 *   FILE 449\n//*     BOOKMGRX - BookServer Front-end CGI (WebServer) REXX        *   FILE 449\n//*                EXEC                                             *   FILE 449\n//*                                                                 *   FILE 449\n//*     BKMGRLPA - USERMOD to create LPA resident BookSERVER        *   FILE 449\n//*                Load Module                                      *   FILE 449\n//*                                                                 *   FILE 449\n//*     BOOKCSA  - Started Task JCL to run CCCBKACE (Search Data    *   FILE 449\n//*                CSA Load)                                        *   FILE 449\n//*     BOOKSACE - JCL to run CCCBKACE (Search Data CSA Load)       *   FILE 449\n//*     BOOKSEXT - JCL to build search data from BookShelf          *   FILE 449\n//*                List(s) (QLSHELF)                                *   FILE 449\n//*     REXXCOMP - JCL to compile the REXX Exec and copy it to      *   FILE 449\n//*                an HFS                                           *   FILE 449\n//*                                                                 *   FILE 449\n//*     CCCBKACE - Assembler Source - Load Search Data into CSA     *   FILE 449\n//*     CCCBKCPS - Assembler Source - Cell Pool Subroutine          *   FILE 449\n//*     CCCBKDAT - Assembler Source - Data Variable Table           *   FILE 449\n//*     CCCBKDEF - Assembler Source - Data Table Lookup             *   FILE 449\n//*                Subroutine                                       *   FILE 449\n//*     CCCBKDSN - Assembler Source - Data Set Name Generator       *   FILE 449\n//*                Subroutine                                       *   FILE 449\n//*     CCCBKEXT - Assembler Source - Build Book/BookShelf          *   FILE 449\n//*                Extract Data Set                                 *   FILE 449\n//*     CCCBKLOC - Assembler Source - Determine location of all     *   FILE 449\n//*                Bkmgr Data Sets                                  *   FILE 449\n//*     CCCBKPUB - Assembler Source - Format Pub Number             *   FILE 449\n//*                Subroutine                                       *   FILE 449\n//*     CCCBKSRV - Assembler Source - Search Program called by      *   FILE 449\n//*                REXX EXEC                                        *   FILE 449\n//*     CCCLOCAT - Assembler Source - LOCATE TSO Command - bonus    *   FILE 449\n//*                                                                 *   FILE 449\n//*     I assume that you're capable of assembling programs, so     *   FILE 449\n//*     I'm not including sample assembly JCL.  Each program is     *   FILE 449\n//*     linked by itself.  MACLIB and MODGEN are needed along       *   FILE 449\n//*     with the Macros supplied above.                             *   FILE 449\n//*                                                                 *   FILE 449\n//*     CCCBKCPS, CCCBKDAT, CCCBKDEF, CCCBKDSN, CCCBKPUB, and       *   FILE 449\n//*     CCCBKSRV are re-entrant and RMODE ANY. (So is CCCLOCAT,     *   FILE 449\n//*     but it's included as a bonus and is not really needed.)     *   FILE 449\n//*     CCCBKACE, CCCBKEXT, and CCCBKLOC are \"main\" programs        *   FILE 449\n//*     that are NOT re-rentrant and are RMODE 24 (AMODE 31).       *   FILE 449\n//*                                                                 *   FILE 449\n//*     Assemble and Link all the programs into a \"BookManager      *   FILE 449\n//*     Utility\" Load Library.  CCCBKEXT is unauthorized and can    *   FILE 449\n//*     run from it.  CCCBKACE is AUTHORIZED, so it (and            *   FILE 449\n//*     CCCBKCPS which it loads as a subroutine) need to be         *   FILE 449\n//*     placed in an authorized library (that end-users should      *   FILE 449\n//*     not have access to).  CCCBKSRV should be placed in the      *   FILE 449\n//*     LinkList or LPAList, as it is used by the CGI REXX Exec.    *   FILE 449\n//*                                                                 *   FILE 449\n//*     BOOKMGRX is a REXX Exec that will require installation      *   FILE 449\n//*     specific customization (unless you like to see some         *   FILE 449\n//*     missing GIFs and bad links).  It (or a complied version     *   FILE 449\n//*     of it) needs to end up in a HFS that will be mapped in      *   FILE 449\n//*     directives in the WebServer HTTPD.CONF file.                *   FILE 449\n//*                                                                 *   FILE 449\n//*     Before going any farther....                                *   FILE 449\n//*                                                                 *   FILE 449\n//*     This BookServer Front-end builds an ECSA Resident Catalog   *   FILE 449\n//*     which is anchored using the time-honored technique of       *   FILE 449\n//*     using a SubSystem Control Table (SSCT).  The default name   *   FILE 449\n//*     of this SubSystem is \"BKSV\".  This value is EQUated in      *   FILE 449\n//*     the BKMGRCSA Macro (Label BKASSNAM).  If you want a         *   FILE 449\n//*     different SubSystem Name, change this equate and            *   FILE 449\n//*     reassemble CCCBKACE and CCCBKSRV.                           *   FILE 449\n//*                                                                 *   FILE 449\n//*     There is no attempt made to create the \"BKSV\" SubSystem     *   FILE 449\n//*     Control Table dynamically if it doesn't exist.  You will    *   FILE 449\n//*     need to update the IEFSSNxx PARMLIB Member and then         *   FILE 449\n//*     either re-IPL or use the SETSSI Command to create it.       *   FILE 449\n//*                                                                 *   FILE 449\n//*     If you don't like this anchor technique and want to         *   FILE 449\n//*     change it, go ahead.                                        *   FILE 449\n//*                                                                 *   FILE 449\n//*     Building the Book Catalog Data Set                          *   FILE 449\n//*                                                                 *   FILE 449\n//*     The CCCBKEXT program uses the MVS BookManager \"Master\"      *   FILE 449\n//*     BookShelf List Data Set (specified by the QLSHELF           *   FILE 449\n//*     setting in EOXVOPTS REXX Exec) to construct the Book and    *   FILE 449\n//*     BookShelf Catalog.  The BookShelf List Data Set Name is     *   FILE 449\n//*     specified as a parameter in the JCL used to execute         *   FILE 449\n//*     CCCBKEXT.  The output Data Set is VB,259.  Sample JCL is    *   FILE 449\n//*     provided in the BOOKSEXT member.  Note that the output      *   FILE 449\n//*     needs to be sorted in order to be properly searchable.      *   FILE 449\n//*                                                                 *   FILE 449\n//*     The sample job is two steps.  The extract is to a           *   FILE 449\n//*     temporary Data Set.  The sort of this temporary Data Set    *   FILE 449\n//*     is output to a permanent extract Data Set which will be     *   FILE 449\n//*     used to create the in storage copy.                         *   FILE 449\n//*                                                                 *   FILE 449\n//*     Building the In Storage Catalog                             *   FILE 449\n//*                                                                 *   FILE 449\n//*     The CCCBKACE program use the Book Catalog Data Set to       *   FILE 449\n//*     create a Common Storage copy of the Book Catalog (in Key    *   FILE 449\n//*     1 Storage) and anchor it in the chosen SSCT.  This          *   FILE 449\n//*     eliminates the I/O associated with reading the Catalog      *   FILE 449\n//*     Data Set (which in our case is 5 cylinders) for each and    *   FILE 449\n//*     every search.                                               *   FILE 449\n//*                                                                 *   FILE 449\n//*     This program, which is authorized since it needs to         *   FILE 449\n//*     obtain CSA, can be run as either a Batch Job or Started     *   FILE 449\n//*     Task.  A sample of each is provided.  We runs it as a       *   FILE 449\n//*     Started Task specified in our COMMND00 PARMLIB member,      *   FILE 449\n//*     so it runs at every IPL on every System.  In addition,      *   FILE 449\n//*     it can be run at any time to refresh the in storage Book    *   FILE 449\n//*     Catalog whenever updates have been made to the              *   FILE 449\n//*     BookManager BookShelf List and the Catalog Data Set         *   FILE 449\n//*     rebuilt.  If a previous in storage Book Catalog exists,     *   FILE 449\n//*     the old one is freed and the new one built, so there        *   FILE 449\n//*     should be no lost CSA.                                      *   FILE 449\n//*                                                                 *   FILE 449\n//*     BookServer CGI REXX Exec                                    *   FILE 449\n//*                                                                 *   FILE 449\n//*     The BOOKMGRX REXX Exec and the CCCBKSRV program are the     *   FILE 449\n//*     heart of the BookServer Front-end. The REXX Exec (raw or    *   FILE 449\n//*     compiled) must be placed into an installation HFS           *   FILE 449\n//*     directory that is mapped by an \"Exec\" directive in the      *   FILE 449\n//*     BookServer's HTTPD.CONF file (more on that later).  The     *   FILE 449\n//*     sample REXX Compile job shows how to place the compiled     *   FILE 449\n//*     REXX Exec (CEXEC) into the chosen HFS.  Whatever name is    *   FILE 449\n//*     chosen for the file in the HFS (compiled or not) will be    *   FILE 449\n//*     part of the URL to invoke it (and like everything in        *   FILE 449\n//*     UNIX is CaSe SeNsItIvE).                                    *   FILE 449\n//*                                                                 *   FILE 449\n//*     This REXX Exec will need customization for your             *   FILE 449\n//*     installation, as it has a whole lot of Amdahl specific      *   FILE 449\n//*     GIFs and links.  They are \"fairly\" isolated, but it's       *   FILE 449\n//*     your responsibility to find and fix 'em.  Also, the         *   FILE 449\n//*     BookServer URLs are different based on the level of the     *   FILE 449\n//*     BookServer you are running and whether or not you have      *   FILE 449\n//*     moved the BookServer CGI Load Module (bookmgr.exe) into     *   FILE 449\n//*     LPA (as described in my SHARE presentation and included     *   FILE 449\n//*     as a Local Mod).  This, too, will have to be changed.       *   FILE 449\n//*                                                                 *   FILE 449\n//*     The CCCBKSRV program is invoked by the REXX Exec to         *   FILE 449\n//*     perform the actual search of the in storage Book Catalog    *   FILE 449\n//*     and return the results in a pool of REXX stem variables.    *   FILE 449\n//*     Because this program is invoked using the \"address          *   FILE 449\n//*     LINKMVS\" REXX statement, it needs to be available to        *   FILE 449\n//*     whatever Address Space the REXX Exec runs in.  The          *   FILE 449\n//*     easiest way to accomplish this is to place it in a Link     *   FILE 449\n//*     List Data Set or (since it's re-entrant and RMODE ANY)      *   FILE 449\n//*     an LPA List Data Set.  This program is unauthorized and     *   FILE 449\n//*     needs no special attributes.                                *   FILE 449\n//*                                                                 *   FILE 449\n//*     HTTPD.CONF Updates                                          *   FILE 449\n//*                                                                 *   FILE 449\n//*     So, you've assembled the programs, stashed the REXX         *   FILE 449\n//*     Exec, and created the in storage Book Catalog.  Now you     *   FILE 449\n//*     need to get the BookServer WebServer to invoke the REXX     *   FILE 449\n//*     Exec CGI.  To do this, you need to add directives to the    *   FILE 449\n//*     HTTPD.CONF (or whatever you've called it) file that is      *   FILE 449\n//*     used by the BookServer's WebServer.                         *   FILE 449\n//*                                                                 *   FILE 449\n//*     You've already had to add \"Pass\" and \"Exec\" directives      *   FILE 449\n//*     to this file for the BookServer itself, so you (or at       *   FILE 449\n//*     least someone in your installation) are somewhat            *   FILE 449\n//*     familiar with this process.  For purposes of the samples    *   FILE 449\n//*     provided below, let's assume the following:                 *   FILE 449\n//*                                                                 *   FILE 449\n//*          The main BookServer Front-end Directory is:            *   FILE 449\n//*               '/BookServer'                                     *   FILE 449\n//*          The CGI BookServer Front-end Directory is:             *   FILE 449\n//*               '/BookServer/cgi'                                 *   FILE 449\n//*          BookManager Data Sets all start with 'CCCPUBS.'        *   FILE 449\n//*               (needed for PDFs)                                 *   FILE 449\n//*          The URL \"code\" for the Front-end CGI is:               *   FILE 449\n//*               '/bookmanager-cgi'                                *   FILE 449\n//*          The URL \"code\" for the Front-end files is:             *   FILE 449\n//*               '/bookmanager'                                    *   FILE 449\n//*          The REXX Exec HFS file name is:                        *   FILE 449\n//*               'bookmanager'                                     *   FILE 449\n//*                                                                 *   FILE 449\n//*     (Again, note the UNIX is very case sensitive.)              *   FILE 449\n//*                                                                 *   FILE 449\n//*     So stick the following two lines in the HTTPD.CONF after    *   FILE 449\n//*     the lines that were inserted for the IBM BookServer:        *   FILE 449\n//*                                                                 *   FILE 449\n//*     Exec       /bookmanager-cgi/*   /BookServer/cgi/*           *   FILE 449\n//*     Pass       /bookmanager/*   /BookServer/*                   *   FILE 449\n//*                                                                 *   FILE 449\n//*     So given all of the above, a URL of:                        *   FILE 449\n//*                                                                 *   FILE 449\n//* http://your.mvs.domain.name:portnumber/  (continued next line)  *   FILE 449\n//*    bookmanager-cgi/bookmanager/                                 *   FILE 449\n//*                                                                 *   FILE 449\n//*     will bring up the BookServer Front-end, from which          *   FILE 449\n//*     everything else is self-explanatory (yeah, right!).  The    *   FILE 449\n//*     trailing slash in the URL is required for some browsers     *   FILE 449\n//*     and not for others, but it doesn't hurt to always code      *   FILE 449\n//*     it.                                                         *   FILE 449\n//*                                                                 *   FILE 449\n//*     Assuming that the User has the Adobe Acrobat Plug-in in     *   FILE 449\n//*     his or her browser, and that you have uploaded BOOK PDF     *   FILE 449\n//*     files to MVS (as binary files into any suitable VB          *   FILE 449\n//*     format Data Set) using the same Data Set Name as the        *   FILE 449\n//*     BookManager Book with 'PDF' instead of 'BOOK' as the        *   FILE 449\n//*     lowest level qualifier, the BookServer Front-end is         *   FILE 449\n//*     capable of allowing the User to view the PDF file for a     *   FILE 449\n//*     Book which has been located via the search.                 *   FILE 449\n//*                                                                 *   FILE 449\n//*     To be able to view these PDF files, you need to have a      *   FILE 449\n//*     couple of \"Service\" Directives in the HTTPD.CONF File.      *   FILE 449\n//*     Find where IBM stuck the sample commented out \"mvsds.so\"    *   FILE 449\n//*     Service Statement and add the following two statements:     *   FILE 449\n//*                                                                 *   FILE 449\n//*  Service /bookmanager-pdf/'cccpubs.*  (continued on next line)  *   FILE 449\n//*  /usr/lpp/internet/bin/mvsds.so:mvsdsGet/'cccpubs.*             *   FILE 449\n//*  Service /bookmanager-pdf/'CCCPUBS.*  (continued on next line)  *   FILE 449\n//*  /usr/lpp/internet/bin/mvsds.so:mvsdsGet/'CCCPUBS.*             *   FILE 449\n//*                                                                 *   FILE 449\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BKMGRCPS": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x00\\x00\\x99!O\\x00\\x99'?\\x17G\\x009\\x005\\x00\\x0e\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1999-08-02T00:00:00", "modifydate": "1999-09-30T17:47:00", "lines": 57, "newlines": 53, "modlines": 14, "user": "KEM00"}, "text": "         MACRO\n&LABEL   BKMGRCPS &TYPE=GEN,&ID=,&SP=,&SIZE=64,&LOC=BELOW\n.*\n         AIF   ('&TYPE' EQ 'DSECT').DSECT\n.*\n         LCLC  &TEMP\n&TEMP    SETC  '0'\n         AIF   ('&LOC' NE 'ANY').GENCPS\n&TEMP    SETC  '128'\n.GENCPS  ANOP\n&LABEL   DS    0F\n         DC    CL3'&ID'            USER IDENTIFIER\n         DC    AL1(&SP+&TEMP)      STORAGE SUBPOOL AND LOC\n         DC    A(&SIZE*1024)       SIZE OF POOL BLOCK\n         DC    A(*-*)              ADDRESS OF FIRST BLOCK\n*\n         MEXIT\n*\n.DSECT   ANOP\n         TITLE 'BOOKMANAGER STORAGE CELL POOL SERVICES MAPPING DSECTS'\n***********************************************************************\n*                                                                     *\n*        MAPPING DSECTS FOR THE BOOKMANAGER CELL POOL SERVICES        *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\nBKCDSECT DSECT\n*\nBKCUSRID DS    CL3                 USER IDENTIFIER\nBKCSPID  DS    XL1                 STORAGE SUBPOOL\nBKCABOVE EQU   128                 SP > 128 INDICATES LOC=ANY\n*\nBKCSIZE  DS    F                   SIZE OF CELL POOL BLOCKS\n*\nBKCSTART DS    F                   START OF CELL POOL DATA AREA\n*\nBKCLNGTH EQU   *-BKCDSECT          LENGTH OF CELL POOL USER BLOCK\n*\nBKDDSECT DSECT\n*\nBKDBLKID DS    CL4                 STORAGE EYECATCHER\nBKDIDEQU EQU   C'BKDB'\n*\nBKDNEXT  DS    A                   ADDRESS OF NEXT BLOCK\n*\nBKDADDR  DS    A                   ADDRESS OF NEXT FREE SPACE\nBKDFREE  DS    F                   AMOUNT OF REMAINING FREE SPACE\n*\nBKDDATA  DS    0D                  START OF ACTUAL DATA AREA\n*\nBKDLNGTH EQU   *-BKDDSECT          LENGTH OF CELL POOL HEADER BLOCK\n*\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BKMGRCSA": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00\\x00\\x00\\x99'?\\x00\\x99'O\\x154\\x00O\\x00G\\x00\\x15\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "1999-09-30T00:00:00", "modifydate": "1999-10-01T15:34:00", "lines": 79, "newlines": 71, "modlines": 21, "user": "KEM00"}, "text": "         MACRO\n&NONE    BKMGRCSA\n.*\n         TITLE 'BOOKMANAGER COMMON STORAGE AREA MAPPING DSECTS'\n***********************************************************************\n*                                                                     *\n*        MAPPING DSECTS FOR THE BOOKMANAGER COMMON STORAGE BLOCKS     *\n*                                                                     *\n***********************************************************************\n*\nBKADSECT DSECT\n*\nBKABLKID DS    CL4                 STORAGE EYE CATCHER\nBKAIDEQU EQU   C'BKAA'             EYE CATCHER VALUE\n*\nBKASUBPL DS    AL1                 STORAGE SUBPOOL\nBKASPLID EQU   241                 STORAGE SUBPOOL\nBKAKEYID EQU   1                   STORAGE KEY USED FOR ALL BLOCKS\nBKASSNAM EQU   C'BKSV'             NAME OF SUBSYSTEM ANCHOR\n*\nBKALEVEL DS    AL1                 CONTROL BLOCK LEVEL\nBKAVERSN EQU   0                   CURRENT VERSION\n*\nBKALENG  DS    H                   LENGTH OF CONTROL BLOCK\n*\nBKABDATE DS    PL4                 DATE OF ANCHOR BLOCK BUILD\nBKABTIME DS    PL4                 TIME OF ANCHOR BLOCK BUILD\n*\nBKAANCHR DS    0A                  ANCHOR ADDRESSES\nBKABKSEX DS    A                   ADDRESS OF BOOKSHELF EXTRACT\nBKABOOEX DS    A                   ADDRESS OF BOOK EXTRACT\n*\n         DS    12F                 RESERVED FOR FUTURE USE\nBKAANUMB EQU   (*-BKAANCHR)/4      NUMBER OF ANCHOR WORDS\n*\nBKAQNAME DS    CL8                 ENQUEUE NAME TO SERIALIZE ACCESS\nBKARNAME DS    CL16                ENQUEUE NAME TO SERIALIZE ACCESS\n*\n         DS    0D\nBKALNGTH EQU   *-BKADSECT          LENGTH OF ANCHOR BLOCK\n*\nBKEDSECT DSECT\n*\nBKEBLKID DS    CL4                 STORAGE EYECATCHER\nBKEIDEQU EQU   C'BKEX'\n*\nBKESUBPL DS    AL1                 STORAGE SUBPOOL\nBKESPLID EQU   241                 STORAGE SUBPOOL\n*\nBKELEVEL DS    AL1                 CONTROL BLOCK LEVEL\nBKEVERSN EQU   0                   CURRENT VERSION\n*\nBKEFLAG1 DS    X                   STATUS FLAG\nBKE1NCHN EQU   X'80'               DATA NOT CHAINED VIA FIRST/LAST\nBKE1NSRT EQU   X'40'               DATA IS NOT SORTED\n*\nBKETYPE  DS    C                   TYPE OF EXTRACT\nBKETYPES EQU   C'S'                BOOKSHELF DATA\nBKETYPEB EQU   C'B'                BOOK DATA\n*\nBKELENG  DS    F                   LENGTH OF AREA\n*\nBKENUMBR DS    F                   TOTAL NUMBER OF ENRTIES\nBKEUNQUE DS    F                   NUMBER UNIQUE OF ENRTIES\n*\nBKEFIRST DS    A                   ADDRESS OF FIRST ENTRY\nBKELAST  DS    A                   ADDRESS OF LAST ENTRY\n*\nBKESTART DS    0D                  START OF ACTUAL DATA\n*\nBKELNGTH EQU   *-BKEDSECT          LENGTH OF STORAGE HEADER\n*\nBKEENTRY DSECT                     START OF FIRST ENTRY AREA\nBKEENEXT DS    A                   ADDRESS OF NEXT ENTRY\nBKEEPREV DS    A                   ADDRESS OF PREVIOUS ENTRY\nBKEEDATA DS    0D                  ACTUAL DATA\nBKEELNTH EQU   *-BKEENTRY          LENGTH OF ENTRY HEADER\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BKMGRHST": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x94\\x03\\x1f\\x145\\x00B\\x00B\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1994-01-31T14:35:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "KEM00"}, "text": "         MACRO\n&LABEL   BKMGRHST &IGNORE\n.*\n         TITLE 'BOOKMANAGER HISTORY DATA SET MAPPING DSECT'\n***********************************************************************\n*                                                                     *\n*        MAPPING DSECT FOR THE BOOKMANAGER HISTORY RECORD             *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\nBKHDSECT DSECT\nBKHRDW   DS    0F                  RECORD RDW\nBKHLENG  DS    H                   RECORD LENGTH\nBKHFLAG1 DS    0X                  UPDATE FLAGS (NOT KEPT IN RECORD)\nBKH1USED EQU   X'80'               BOOK HAS BEEN USED\nBKH1UPDT EQU   X'40'               BOOK HAS BEEN UPDATED\nBKH1NEW  EQU   X'20'               BOOK HAS BEEN ADDED THIS TIME\nBKH1DEL  EQU   X'10'               BOOK IS TO BE DELETED THIS TIME\n*\nBKHRDW2  DS    H\n*\nBKHNAME  DS    CL8                 BOOK/SHELF/INDEX NAME\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHTYPE  DS    CL8                 TYPE - BOOK, BKSHELF, BKINDEX\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHBKDTE DS    CL10                BOOK DATE\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHBKTIM DS    CL8                 BOOK TIME\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHUPDTE DS    CL10                LAST RECORD UPDATE DATE\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHSTAT  DS    CL8                 CURRENT STATUS\n*              ACTIVE\n*              INACTIVE\n*              MISSING\n*              ARCHIVED\n*              OBSOLETE\n*              UNWANTED\n*              NEW\n*              UNKNOWN\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHCKIT  DS    0CL12               COLLECTION KIT PUBLICATION ID\nBKHCKITP DS    CL4                 C-KIT PUBLICATION PREFIX\n         DS    C                   DASH\nBKHCKITN DS    CL4                 C-KIT PUBLICATION NUMBER\n         DS    C                   DASH\nBKHCKITL DS    CL2                 C-KIT REVISION LEVEL\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHPUBNO DS    0CL12               BOOK PUBLICATION ID\nBKHPUBNP DS    CL4                 BOOK PUBLICATION PREFIX\n         DS    C                   DASH\nBKHPUBNN DS    CL4                 BOOK PUBLICATION NUMBER\n         DS    C                   DASH\nBKHPUBNL DS    CL2                 BOOK REVISION LEVEL\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKHDSNME DS    CL44                BOOK/BKSHELF/BKINDEX DATA SET NAME\nBKHDSNXX DS    CL2                 FILLER FOR HUMAN READABILITY\nBKHTITLE DS    0C                  BOOK/BKSHELF/BKINDEX TITLE\n*\nBKHEND   EQU   *\nBKHLNGTH EQU   *-BKHDSECT          LENGTH OF HISTORY RECORD (MINIMUM)\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BKMGRINF": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x99'?\\x13\\x10\\x00:\\x008\\x00\\x02\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1999-09-30T13:10:00", "lines": 58, "newlines": 56, "modlines": 2, "user": "KEM00"}, "text": "         MACRO\n&LABEL   BKMGRINF &IGNORE\n.*\n         TITLE 'BOOKMANAGER INFORMATION DATA SET MAPPING DSECT'\n***********************************************************************\n*                                                                     *\n*        MAPPING DSECT FOR THE BOOKMANAGER INFORMATION RECORD         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\nBKNDSECT DSECT\nBKNRDW   DS    0F                  RECORD RDW\nBKNLENG  DS    H                   RECORD LENGTH\nBKNRDW2  DS    H\n*\nBKNNAME  DS    CL8                 BOOK/SHELF/INDEX NAME\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNTYPE  DS    CL8                 TYPE - BOOK, BKSHELF, BKINDEX\nBKNMATCH EQU   BKNNAME,*-BKNNAME   SPECIAL COMPARE FIELD FOR SORTING\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNBKDTE DS    CL10                BOOK BUILD DATE\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNBKTIM DS    CL8                 BOOK BUILD TIME\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNSTAT  DS    CL8                 CURRENT STATUS\n*              ACTIVE\n*              MISSING\n*              ARCHIVED\n*              MISMATCH (BOOKSHELF ONLY)\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNCKIT  DS    0CL12               COLLECTION KIT PUBLICATION ID\nBKNCKITP DS    CL4                 C-KIT PUBLICATION PREFIX\n         DS    C                   DASH\nBKNCKITN DS    CL4                 C-KIT PUBLICATION NUMBER\n         DS    C                   DASH\nBKNCKITL DS    CL2                 C-KIT REVISION LEVEL\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNPUBNO DS    0CL12               BOOK PUBLICATION ID\nBKNPUBNP DS    CL4                 BOOK PUBLICATION PREFIX\n         DS    C                   DASH\nBKNPUBNN DS    CL4                 BOOK PUBLICATION NUMBER\n         DS    C                   DASH\nBKNPUBNL DS    CL2                 BOOK REVISION LEVEL\nBKNPUBNS EQU   BKNPUBNO+1,L'BKNPUBNO-1  FIELD FOR SORTING\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNBKSID DS    CL8                 BOOKSHELF NAME\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNDSNME DS    CL44                BOOK/BKSHELF/BKINDEX DATA SET NAME\n         DS    C                   FILLER FOR HUMAN READABILITY\nBKNTITLE DS    0C                  BOOK/BKSHELF/BKINDEX TITLE\n*\nBKNEND   EQU   *\nBKNLNGTH EQU   *-BKNDSECT          LENGTH OF UPDATE RECORD (MINIMUM)\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BKMGRLOC": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x94\\x03\\x1f\\x145\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1994-01-31T14:35:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "KEM00"}, "text": "         MACRO\n&LABEL   BKMGRLOC &IGNORE\n.*\n         TITLE 'BOOKMANAGER CATALOG LOCATE DATA SET MAPPING DSECT'\n***********************************************************************\n*                                                                     *\n*        MAPPING DSECT FOR THE BOOKMANAGER CATALOG LOCATE RECORD      *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\nBKLDSECT DSECT\n*\nBKLTYPE  DS    CL1                 TYPE OF DATA SET\n         DS    C                   FILLER FOR HUMAN READABILITY\n*\nBKLDSNME DS    CL44                FULL DATA SET NAME\n         DS    C                   FILLER FOR HUMAN READABILITY\n*\nBKLDSNHL DS    CL8                 DATA SET NAME HIGH LEVEL QUALIFIER\n         DS    C                   FILLER FOR HUMAN READABILITY\n*\nBKLDSNLL DS    CL8                 DATA SET NAME LOW LEVEL QUALIFIER\n*\nBKLEND   EQU   *\nBKLLNGTH EQU   *-BKLDSECT          LENGTH OF CATALOG LOCATE RECORD\n*\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BKMGRLPA": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17_\\x01\\x00\\x17_\\x15I\\x00H\\x00H\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-23T00:00:00", "modifydate": "2000-06-23T15:49:00", "lines": 72, "newlines": 72, "modlines": 0, "user": "KEM00"}, "text": "++ USERMOD (#W00462)  REWORK(0002170) .\n++ VER   (Z038)  FMID (HBKQ220)\n         /*\n\n         This User Modification does the following:\n\n               Creates an HFS Load Module, EPHBOOKD, with an alias\n               of \"../booksrvr\" in the /usr/lpp/booksrv/cgi-bin/IBM\n               directory with the \"sticky bit\" on.\n\n               Creates the EPHBOOKX Load Module, with alias BOOKSRVR,\n               in Load Module PDS SEPHLMOD.\n\n               Supplies the source for Module EPHOEDUM, which is used\n               to build the EPHBOOKD HFS Load Module and to cause\n               SMP/E to build the EPHBOOKX PDS Load Module.\n\n         The new Target PDS, SEPHLMOD, should be placed on the\n         Link List or LPA List (LPA preferred, as everything is\n         RMODE ANY).\n\n                                                                   */ .\n++ JCLIN CALLLIBS .\n//EPHBOOKS JOB\n//*      Define the EPHBOOKD/booksrvr sticky bit HFS Load Module\n//STEP1A EXEC  PGM=IEWBLINK,\n//             PARM='NCAL,LET,RENT,AMODE=31,RMODE=ANY,CASE(MIXED)'\n//SYSLMOD DD   PATH='/usr/lpp/booksrv/cgi-bin/IBM/'\n//*LIBRARYDD=SEPHLOAD\n//SYSLIN DD    *\n         SETOPT PARM(PATHMODE(1,7,5,5))\n         INCLUDE AEPHLOAD(EPHOEDUM)\n         ALIAS '../booksrvr'\n         NAME  EPHBOOKD(R)\n/*\n//*      Define the EPHBOOKX/BOOKSRVR PDS Load Module\n//STEP1B EXEC  PGM=IEWBLINK,\n//             PARM='CALL,LET,RENT,AMODE=31,RMODE=ANY'\n//SYSLIB DD    DSN=C370.V2R2M0.SCEELKED,DISP=SHR\n//SYSLMOD DD   DISP=SHR,DSN=SYS1.SEPHLMOD\n//SYSLIN DD    *\n         ORDER CEESTART\n         ENTRY CEESTART\n         INCLUDE AEPHLOAD(EPHBOOKS)\n         INCLUDE AEPHLOAD(EPHOEDUM)\n         ALIAS BOOKSRVR\n         NAME  EPHBOOKX(R)\n/*\n//*      Provide the JCLIN for the relocation of EPHBOOKR\n//STEP2  EXEC  PGM=IEWL,REGION=6M,\n//             PARM='RENT,LIST,MAP,RMODE=ANY,AMODE=31,LET,XREF,CALL'\n//SYSLIB DD    DISP=SHR,DSN=CEE.SCEELKED\n//SYSLMOD DD   DISP=SHR,DSN=SYS1.SEPHLMOD\n//SYSLIN DD    *\n         ORDER CEESTART\n         ENTRY CEESTART\n         INCLUDE AEPHLOAD(EPHBOOKR)\n         NAME  EPHBOOKR(R)\n/*\n++ SRC   (EPHOEDUM)  DISTLIB (AEPHSAMP) .\nOEDUM    TITLE 'Dummy HFS Module for BookManager BookServer'\nEPHOEDUM CSECT\nEPHOEDUM AMODE 31\nEPHOEDUM RMODE ANY\n*\n         DC    H'0'\n*\n         DC    C'This file is not executable. '\n         DC    C'MVS loads the actual program from the partitioned '\n         DC    C'data set because the sticky bit is on.'\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BOOKCSA": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17_\\x01\\x00\\x17_\\x15 \\x00\\x08\\x00\\x08\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-23T00:00:00", "modifydate": "2000-06-23T15:20:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "KEM00"}, "text": "//IEFPROC EXEC PGM=CCCBKACE,\n//             REGION=32M,\n//             ACCT=(7531KEM,TSG,KEM00,Y),\n//             TIME=(,10)\n//STEPLIB DD   DSN=AMDA.AUTHLIB,DISP=SHR\n//INFOFILE DD  DSN=CCCPUBS.INFO.BOOKS.EXTRACT,DISP=SHR\n//SYSUDUMP DD  SYSOUT=$\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BOOKMGRX": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17O\\x01\\x00\\x17O\\x16\\x18\\x03o\\x03o\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-22T00:00:00", "modifydate": "2000-06-22T16:18:00", "lines": 879, "newlines": 879, "modlines": 0, "user": "KEM00"}, "text": "/* REXX */\nenv.date = date()\nenv.time = time()\n\nbegintime = time('E')\n\nparse arg upper parmfield\n\nparse source source.tso source.mode source.command,\n  source.dd source.file source.exec,\n  source.cmdenv source.addrspace source.token\n\n/* Set key CGI information */\ncgi.execlevel = '2000/02/15-00'\ncgi.construction = 0\ncgi.ssi = 0\ncgi.compiled = 1\ncgi.sitename = 'Amdahl Corporate Computer Center'\ncgi.titletext = cgi.sitename' Web BookManager'\ncgi.bkmgrguru = 'Keith_Moe@notes.amdahl.com'\ncgi.mailsubject = 'BookManager BookServer'\n\n/* Put whichever one last for the level of the BookServer */\ncgi.booksrv = '2.2.0'\ncgi.booksrv = '2.2.0x'\n\n/* BookManager Statistics */\nfunction = 'BKSC'\naddress LINKMVS 'CCCBKSRV function'\nbook.shelfcount = rc\nfunction = 'BOOC'\naddress LINKMVS 'CCCBKSRV function'\nbook.total = rc\n\n/* BookManager Sequential Data Sets */\nbook.msgshelf = 'CCCPUBS.AMDAHL.@@MSGS@@.BKSHELF'\n\n/* Define the URL prefixes for ease of altering */\nurl.booksrvcgibase = '/bookmgr-cgi/'\nurl.booksrvcgicmd = 'bookmgr.cmd'\nurl.booksrvcgiexe = 'bookmgr.exe'\nurl.booksrvcgilpa = 'booksrvr'\nurl.books = '/BOOKS/'\nurl.noframes = '/NOFRAMES/'\nurl.bookshelves = '/Shelves'\nurl.booklibrary = '/library'\nurl.bookabout = '/About'\nurl.bookcases = '/Cases'\nurl.booktoc = '/CCONTENTS'\nurl.bookhelp = '/help/library'\n\nselect\n  when cgi.booksrv = '2.2.0' then\n    url.booksrvcgi = url.booksrvcgibase||url.booksrvcgiexe\n  when cgi.booksrv = '2.2.0x' then\n    url.booksrvcgi = url.booksrvcgibase||url.booksrvcgilpa\n  otherwise\n    url.booksrvcgi = url.booksrvcgibase||url.booksrvcgicmd\nend\n\nurl.booksrv = '/bookmgr'\nurl.bookpdf = '/bookmanager-pdf'\nurl.mvsimage = '/os390web/images'\nurl.wwwccc = 'http://www.ccc.amdahl.com'\n\n/* Define the Search Limits */\nhit.limit = 50\nhit.start = 1\nhit.end = 0\nhit.next = 0\n\n/* Define the Processing Mode */\nquery.debug = 0\nquery.method = 'POST'\n\n/* Define common html verbs */\nhtml.center = '<center>'\nhtml.ecenter = '</center>'\nhtml.br = '<br>'\nhtml.p = '<p>'\nhtml.apost = \"'\"\n\n/* Archived Data Set display characteristics */\narchive.word = 'underlined'\narchive.word = 'RED'\narchive.colorcode = 'ff0000'\n\nif archive.word = 'underlined' then\n  do\n    archive.front = '<u>'\n    archive.back = '</u>'\n  end\nelse\n  do\n    archive.front = '<font color=\"'archive.colorcode'\">'\n    archive.back = '</font>'\n  end\n\n/* Extract information from the environmental variables */\ndo i = 1 to __environment.0\n  parse var __environment.i keyword'='value\n  envvar.keyword = value\nend\n\nquery.pathinfo = envvar.PATH_INFO\nenv.scriptname = envvar.SCRIPT_NAME\nenv.server = envvar.SERVER_SOFTWARE\nenv.serverlevel = '******'\nenv.browser = envvar.HTTP_USER_AGENT\n\nif envvar.REQUEST_METHOD <> 'POST' then\n  do\n    query.string = envvar.QUERY_STRING\n  end\nelse\n  do\n    len = envvar.CONTENT_LENGTH\n    if len = '' then\n      len = 0\n    address syscall 'read 0 query.string' len\n  end\n\nenv.domino = 0\ni = index(env.server,'/')\nif i <> 0 then\n  env.serverlevel = substr(env.server,i+1)\n\nif index(env.server,'Domino') > 0 then\n  env.domino = 1\nif env.serverlevel > 'V5' then\n  env.domino = 1\n\nenv.pdf = 0\nif env.domino then\n  do\n    env.pdf = 1\n  end\n\n/* Unfortunately, there is no way to determine compiled dynamically */\nif cgi.compiled then\n  cgi.execlevel = cgi.execlevel '(compiled)'\n\n/* Get the MVS System Level */\nos390.sysopsys = MVSVAR('SYSOPSYS')\nos390.sysname = MVSVAR('SYSNAME')\nparse var os390.sysopsys os390.name os390.release .\nos390.level = os390.name os390.release\n\n/* Initialize key variables */\nquery.function = ''\nquery.pathdata = ''\nquery.data = ''\nquery.arguments = ''\nquery.request = ''\nquery.resume = ''\nquery.details = 0\nquery.help = 0\nquery.noframes = 0\n\ntableheading = 0\nhit.books = 0\nhit.archived = 0\npdf.books = 0\npdf.archived = 0\nbooktable.searcharguments = ''\nbooktable.searchhits = 0\nbooktable.searchreturn = 0\n\n/* Parse the input data */\nif query.pathinfo <> '' then\n  do\n    parse upper var query.pathinfo '/'query.function'/'query.pathdata\n    query.function = strip(query.function)\n    query.pathdata = strip(query.pathdata)\n  end\n\nif substr(query.function,1,1) = '*' then\n  do\n    query.debug = 1\n    query.function = substr(query.function,2)\n  end\n\nif query.function = 'DEBUG' then\n  do\n    query.debug = 1\n    query.function = ''\n  end\n\nif query.function = 'HELP' then\n  do\n    query.help = 1\n    query.function = ''\n  end\n\nquery.action = 'find'\n\n/* Parse the forms query data */\nqueryscan = translate(query.string)\nif queryscan <> '' then\n  do i = 1 to 100 until queryscan = ''\n    parse var queryscan queryparm'&'queryscan\n    parse var queryparm queryverb'='queryoperand\n    queryoperand = strip(queryoperand)\n    select\n      when queryverb = 'SUBMIT' then\n        query.request = queryoperand\n      when queryverb = 'DATA' then\n        query.data = queryoperand\n      when queryverb = 'RESUME' then\n        query.resume = queryoperand\n      when queryverb = 'DETAILS' then\n        query.details = 1\n      when queryverb = 'NOFRAMES' then\n        do\n          query.noframes = 1\n          url.books = url.noframes\n        end\n      when queryverb = 'DEBUG' then\n        do\n          if queryoperand = 'YES' then\n            query.debug = 1\n          if queryoperand = 'NO' then\n            query.debug = 0\n        end\n      otherwise\n        nop\n    end\n  end\n\n/* Set the Forms debug value */\nif query.debug then\n  query.debugform = 'YES'\nelse\n  query.debugform = 'NO'\n\n/* Determine the hit range to display */\nif query.resume <> '' then\n  hit.start = query.resume\nhit.end = hit.start + hit.limit - 1\nhit.next = hit.end + 1\n\n/* Begin creating the output */\nif query.request = 'FIND' then\n  do\n    cgi.titletext = cgi.titletext 'Search Results'\n    if query.resume <> '' then\n      cgi.titletext = cgi.titletext '(continued)'\n  end\nelse\n  if query.help then\n    cgi.titletext = cgi.titletext 'Hints, Tips, and Information'\n  else\n    cgi.titletext = cgi.titletext 'Entry Page'\n\ncall htmlheader\n\ncall issheader\n\nif query.debug then\n  call debugdump\n\n/* For a Help request, just display information */\nif query.help then\n  do\n    call helpinfo\n    signal footing\n  end\n\n/* For a non-search, simply display the search field and links */\nif query.request <> 'FIND' then\n  do\n    call searchblock\n    call msgblock\n    call linkblock\n    signal footing\n  end\n\nif query.data = '' then\n  signal wrapup\n\nfunction = 'SRCH'\nstemprefix = 'BOOKTABLE.'\naddress LINKMVS,\n  'CCCBKSRV function stemprefix query.data hit.start hit.end'\nif rc <> 0 then\n  signal wrapup\n\nquery.arguments = booktable.searcharguments\nif booktable.searchhits = 0 then\n  signal wrapup\n\n/* Main Book scan and table build */\nj = 1\ndo i = 1 to booktable.searchreturn\n\n  parse var booktable.j bookname bookpubno bookdate booktime,\n    bookdsn bookvol bookshelf bookshelfdsn,\n    bookpdfdsn bookpdfvol booktitle\n\n  hit.books = hit.books + 1\n\n  ibks = 1\n  bookshelfx.1 = bookshelf\n  bookshelfdsnx.1 = bookshelfdsn\n\n  if j < booktable.0 then\n    do until j = booktable.0\n      j = j + 1\n      parse var booktable.j nextname . . . . . nextshelf nextshelfdsn .\n      if bookname <> nextname then\n        leave\n      ibks = ibks + 1\n      bookshelfx.ibks = nextshelf\n      bookshelfdsnx.ibks = nextshelfdsn\n    end\n\n  if \u00actableheading then\n    do\n      tableheading = 1\n      call resultsinstructions\n      say html.p'<table border cellspacing=0 cellpadding=6>'\n      if query.debug then\n        say '<th>Record'html.br'Number</th>'\n      say '<th>Publication'html.br'Number</th>'\n      say '<th>Book'html.br'Name</th>'\n      if env.pdf then\n      /*say '<th>PDF'html.br'Avail</th>'*/\n        say '<th>PDF</th>'\n      if query.details then\n        say '<th>Book'html.br'Date & Time</th>'\n      say '<th>BookShelf'html.br'Name(s)</th>'\n      say '<th>Book Title</th>'\n    end\n\n  say '<tr>'\n  if query.debug then\n    say '<td valign=top>'i'</td>'\n\n  say '<td valign=top>',\n    '<a href=\"'url.booksrvcgi||url.books||bookdsn'/CCONTENTS\">',\n    bookpubno'</a></td>'\n\n  if substr(bookvol,1,6) = 'MIGRAT' then\n    do\n      hit.archived = hit.archived + 1\n      say '<td valign=top>'archive.front bookname archive.back'</td>'\n    end\n  else\n    say '<td valign=top>'bookname'</td>'\n\n  if env.pdf then\n    do\n      if substr(bookpdfvol,1,1) <> '*' then\n        do\n          pdf.books = pdf.books + 1\n          bookpdfdsn = \"'\"bookpdfdsn\"'\"\n          say '<td valign=top><a href=\"'url.bookpdf'/'bookpdfdsn'\">'\n          if substr(bookpdfvol,1,6) = 'MIGRAT' then\n            do\n              pdf.archived = pdf.archived + 1\n              say archive.front'YES'archive.back'</a></td>'\n            end\n          else\n            say 'YES</a></td>'\n        end\n      else\n        say '<td valign=top>NO</td>'\n    end\n  if query.details then\n    do\n      say '<td valign=top>'bookdate booktime'</td>'\n    end\n\n  say '<td valign=top>'\n  do k = 1 to ibks\n    say '<a href=\"'url.booksrvcgi'/Shelves/'bookshelfdsnx.k'\">',\n      bookshelfx.k'</a>'html.br\n  end\n  say '</td>'\n\n  say '<td valign=top>'booktitle'</td>'\nend\n\n/* After search wrap-up */\nwrapup:\nselect\n  when booktable.searchhits = 1 then\n    do\n      if hit.archived <> 0 then\n        arc = ' and it is archived.'\n      else\n        arc = '.'\n      say '<caption align=top>'\n      say 'There was only 1 match for this search request'arc\n      say '</caption>'\n    end\n\n  when booktable.searchhits > 1 then\n    do\n      say '<caption align=top>'\n      hittop = hit.start + booktable.searchreturn - 1\n      say 'These are hits 'hit.start' through 'hittop,\n        'out of 'booktable.searchhits' matches in 'book.total' books.'\n      if booktable.searchreturn = hit.archived then\n        hit.archived = 'All'\n      if hit.archived = 1 then\n        arc = 'is'\n      else\n        arc = 'are'\n      say archive.front hit.archived archive.back,\n        'of these hits 'arc' archived.'\n      if env.pdf then\n        select\n          when pdf.books = 0 then\n            say html.br,\n              'There are no PDF Book Files available for these books.'\n          when pdf.books = 1 then\n            do\n              if pdf.archived = 1 then\n                arc = ' and it is archived.'\n              else\n                arc = '.'\n              say html.br'There is 1 PDF Book File available'arc\n            end\n          otherwise\n            do\n              say html.br'There are 'pdf.books' PDF Files available.'\n              if pdf.archived = 1 then\n                arc = 'is'\n              else\n                arc = 'are'\n              say archive.front pdf.archived archive.back,\n                'of the PDF Book Files 'arc' archived.'\n            end\n        end\n      say '</caption>'\n    end\n\n  otherwise\n    do\n      say '<hr><h2 align=center>No matches on search criteria</h2>'\n    end\n\nend\n\nif tableheading then\n  say '</table>'html.p\n\nif booktable.searchhits > hit.end then\n  do\n    hitmore = min(hit.limit,booktable.searchhits - hit.end)\n    say html.center,\n      'Please refine your criteria to reduce the number of hits',\n      'or for the next 'hitmore' matches, click'\n    say '<a href=\"'env.scriptname'/'query.action'?'\n    say 'data='query.data'&debug='query.debugform\n    say '&submit='query.request'&resume='hit.next\n    if query.details then\n      say '&details=on'\n    if query.noframes then\n      say '&noframes=on'\n    say '\"<b>here</b></a>.'html.ecenter html.p\n  end\n\ncall searchblock\ncall msgblock\ncall linkblock\n\nsignal footing\n\n/* End of page processing */\nfooting:\nsay '<hr>'\nsay '</body>'\n\ncall processfooter\n\ncall issfooter\n\nsay '</html>'\nexit 0\n\n/* Display the Search Input Form */\nsearchblock: procedure expose query. url. html. env.\n  say html.center'Click here for:&nbsp;&nbsp;&nbsp;'\n  say '<a href=\"'env.scriptname'/help#introduction\">',\n    'BookServer Overview</a>&nbsp;&nbsp;&nbsp;'\n  say '<a href=\"'env.scriptname'/help#hints\">',\n    'Usage Hints and Tips</a>&nbsp;&nbsp;&nbsp;'\n  say '<a href=\"'env.scriptname'/help#changes\">',\n    'Recent Changes</a>&nbsp;&nbsp;&nbsp;'\n  say '<a href=\"'env.scriptname'/help#problems\">',\n    'Problem Reporting Procedures</a>'html.ecenter\n\n  say '<hr><h2 align=center>'\n  if query.request = 'FIND' then\n    say 'Enter or Change Search Criteria</h2>'\n  else\n    say 'Search Book Titles and Document Numbers</h2>'\n  say '<form ACTION=\"'query.action'\" METHOD=\"'query.method'\">'\n  say '<input type=\"hidden\" name=\"debug\" value=\"'query.debugform'\">'\n  say html.center'<table border=0>'\n  say '<tr><td> </td><td>Find Books with Titles or',\n    'Document Numbers containing (NOT case sensitive):</td>'\n  say '<tr><td><img src=\"'url.booksrv'/search.gif\" alt=\"Find\"></td>'\n  say '<td><input type=\"text\" name=\"data\"',\n    'value=\"'query.arguments'\"size=60 maxlength=64></td>'\n  say '<td><input type=\"submit\" name=\"submit\" value=\"Find\"></td>'\n\n  say '<tr><td> </td>'\n  checked = ''\n  if query.details then\n    checked = 'checked'\n  say '<td><input type=\"checkbox\" name=\"details\"' checked'>',\n    'Display Book Build Date & Time'\n  checked = ''\n  if query.noframes then\n    checked = 'checked'\n  say html.br'<input type=\"checkbox\" name=\"noframes\"' checked'>',\n    'Disable use of FRAMES in Book Display'\n  say '</td></table>'html.ecenter'</form>'\nreturn\n\n/* Display the Link to Search Messages */\nmsgblock: procedure expose url. html. book.\n  say '<h2 align=center>OR'html.br,\n    'Search the Messages and Codes BookShelf</h2>'\n  say '<form action=\"'url.booksrvcgi'/Shelves/'book.msgshelf'\"',\n    'method=\"get\">'\n  say html.center'<table border=0>'\n  say '<tr><td><img src=\"'url.booksrv'/search.gif\" alt=\"Search\"></td>'\n  say '<td><input type=\"text\" name=\"searchRequest\" value=\"\"',\n    'size=60 maxlength=64></td>'\n  say '<td><input type=\"submit\" name=\"SEARCH\" value=\"Search\"></td>'\n  say '<tr><td> </td>'\n  say '</table>'html.ecenter'</form>'\n\n  say '<h2 align=center>OR</h2>'\n  say '<a href=\"'url.booksrvcgi'/Shelves/'book.msgshelf'\">'\n  say html.center'<font size=+2>',\n    'Display the complete Messages and Codes BookShelf</a>'\n  say '</font>'html.ecenter\nreturn\n\n/* Display the BookServer Links */\nlinkblock: procedure expose url. html. book.\n  say html.center\n  say '<h2 align=center>OR'html.br,\n    'Use one of these to enter the BookServer</h2>'\n\n  say '<table border=0 cellspacing=0 cellpadding=6>'\n  say '<tr><td><a href=\"'url.booksrvcgi'/library\">'\n  say html.center'<img src=\"'url.booksrv'/libicon2.gif\"',\n    'border=0 alt=\"BookServer\">'html.br\n  say 'The IBM BookManager BookServer</a>'\n  say html.br'Main Entry Point'html.ecenter'</td>'\n  say '<td><a href=\"'url.booksrvcgi'/Cases\">'\n  say html.center'<img src=\"'url.booksrv'/bookcase.gif\"',\n    'border=0 alt=\"BookCases\">'html.br\n  say 'BookServer BookCases</a>'html.br\n  say '(currently not very useful)'html.ecenter'</td>'\n  say '<tr><td><a href=\"'url.booksrvcgi'/Shelves\">'\n  say html.center'<img src=\"'url.booksrv'/bookshf.gif\"',\n    'border=0 alt=\"BookShelves\">'html.br\n  say 'BookServer BookShelves</a>'html.br,\n    '('book.shelfcount')'html.ecenter'</td>'\n  say '<td><a href=\"'url.booksrvcgi'/help/library\">'\n  say html.center'<img src=\"'url.booksrv'/help.gif\"',\n    'border=0 alt=\"BookServer Help\">'html.br\n  say 'BookServer'html.br'Help</a>'html.ecenter'</td>'\n  say '</table>'html.ecenter\nreturn\n\n/* Display the Under Construction Block */\nunderconstruction: procedure expose url. html.\n  say html.center\n  say '<img src=\"'url.booksrv'/construc.gif\" align=middle',\n    'alt=\"Under Construction\">'\n  say html.br'When this appears, it means that there have been'\n  say 'recent changes.  Hopefully, they will be error free.'\n  say 'But if they aren'html.apost't, let us know.'\n  say 'Please use the <b>e-mail</b> link near the bottom of this page.'\n  say html.ecenter html.p\nreturn\n\n/* Display the Help Information */\nhelpinfo: procedure expose url. html. book. hit. env.\n\n  say html.center'<a href=\"#hints\">',\n    'Usage Hints and Tips</a>'html.ecenter\n  say html.center'<a href=\"#changes\">',\n    'Recent Changes</a>'html.ecenter\n  say html.center'<a href=\"#problems\">',\n    'Problem Reporting Procedures</a>'html.ecenter\n\n  say '<hr><h2 align=center><a name=\"introduction\">'\n  say 'Introduction to the IBM BookServer</a></h2>'\n\n  say 'The IBM BookServer is an alternative to the MVS/TSO based'\n  say 'BookManager Read method of accessing the large collection'\n  say 'of online publications stored on the MainFrames in the'\n  say 'Corporate Computer Center.  Just as the MVS/TSO BookManager'\n  say 'Read uses an existing tool (ISPF) to perform the display of'\n  say 'output, the BookServer also uses an existing tool (The Web'\n  say 'Browser) as its method of access and display.',\n    'This means that no special'\n  say 'programs or files are needed.  By virtue of you reading this,'\n  say 'it can be assummed that you have a Web Browser!'\n\n  say html.p'The BookServer accesses the exact same set of Books and'\n  say 'BookShelves that the MVS/TSO BookManager Read accesses.'\n  say 'The use of Web access instead of TSO provides capabilities'\n  say 'that are not available in a 3270/TSO/ISPF environment.  Some'\n  say 'of these are:<ul>'\n  say '<li>No need to log on with a User ID and Password'\n  say '<li>Graphics in Books are displayed inline'\n  say '<li>Easier navigation through Books and BookShelves'\n  say '</ul>'\n\n  say html.p'There are two basic ways to use the IBM BookServer.'\n  say 'The first (and original) way is to display the List of'\n  say 'BookShelves ('book.shelfcount'), scroll through it, and select'\n  say 'the BookShelf containing the Book(s) you are interesting in.'\n  say 'You can then perform a search on the BookShelf (much like'\n  say 'the MVS/TSO environment) or select a specific Book.  While'\n  say 'this way is no worse than the MVS/TSO environment, it depends'\n  say 'on you having a good idea of which BookShelves the Book(s) you'\n  say 'are looking for are located in.'\n  say 'Hence, enter the second method.'\n\n  say html.p'The second way makes use of a Data Base that CCC had been'\n  say 'utilizing to produce the TSO Browseable list of all Books that'\n  say 'are online in BookManager.',\n    'By CCC providing a search process against'\n  say 'this Data Base, you are able to search for specific Books by'\n  say 'Publication Number or words in the Book Titles.  In addition,'\n  say 'a direct search of the Messages and Codes BookShelf is provided'\n  say 'to simplify searching on messages.'\n\n  say '<hr><h2 align=center><a name=\"hints\">'\n  say 'Usage Hints and Tips</a></h2>'\n  say 'When searching on Publication Numbers or Book Titles, keep'\n  say 'the following in mind:<ul>'\n  say '<li>All search arguments are <b>NOT</b> case sensitive.'\n  say '<li>Avoid including the \"dash number\" when specifying'\n  say 'Publication Numbers, as paper and online publishing schedules'\n  say 'seldom correspond.'\n  say '<li>A maximum of 'hit.limit' search hits will be displayed.'\n  say 'Although you have the ability to request the second 'hit.limit','\n  say 'the third 'hit.limit', etc., you should consider refining the'\n  say 'search parameters if you receive too many matches.'\n  say '<li>The \"Display Book Build Date & Time\"'\n  say 'checkbox allows you to see when the BookManager Book was built'\n  say 'by the supplier.  It <b>may not</b> correspond to the date the'\n  say 'corresponding HardCopy document was published, as many Books'\n  say 'have multiple SoftCopy revisions without a HardCopy revision.'\n  if env.pdf then\n    do\n      say '<li>The \"Display PDF File availability\"'\n      say 'checkbox allows you to see if the SoftCopy Books have'\n      say 'corresponding PDF Files which can be browsed and/or printed'\n      say 'with your Web Browser (Adobe Acrobat Plug-in required).'\n      say 'Requesting PDF File information will <b>elongate</b> the'\n      say 'search time, so don'html.apost't request PDF information'\n      say 'if you don'html.apost't need it.'\n    end\n  say '<li>The \"Disable use of FRAMES in Book Display\"'\n  say 'checkbox allows you to see a Book as a full frame in your'\n  say 'Browser, rather than in three frames.  While the use of frames'\n  say 'provides for enhanced Book navigation, it requires the use of'\n  say 'JavaScript and can be a performance problem on slower machines.'\n  say '</ul>'\n\n  say '<hr><h2 align=center><a name=\"changes\">'\n  say 'Recent Changes</a></h2>'\n  say 'Changes made to the Amdahl BookServer Front-End are:<ul>'\n  say '<li>Rewritten to improve performance.'\n  if env.pdf then\n    say '<li>PDF Book information is always displayed.'\n  say '<li>Support for the IBM BookServer Release 2.2.0.'\n  say '<li>Ability to disable frames (temporary bypass).'\n  say '</ul>'\n  say 'Changes made to the IBM BookServer are:<ul>'\n  say '<li>BookServer Release 2.2.0.'\n  say '<li>The URL for the BookServer has changed.'\n  say 'The portion of the URL that was \"'url.booksrvcgicmd'\"',\n    'has been changed to \"'url.booksrvcgilpa'\".'\n  say '<li>By default, Books are now displayed using frames:'\n  say 'An Icon Frame; A Table of Contents Frame; and the Topic Frame.'\n  say 'The use of frames requires a Browser that supports JavaScript.'\n  say '</ul>'\n\n  say '<hr><h2 align=center><a name=\"problems\">'\n  say 'Problem Reporting</a></h2>'\n  say 'Like anything, try as we might, neither the IBM BookServer'\n  say 'nor the search \"Front-End\" are likely to be error free.'\n  say 'To that end, we need to remind you of several things:<ul>'\n  say '<li>We aren'html.apost't likely to fix bugs we',\n    'don'html.apost't know about.'\n  say '<li>We can'html.apost't fix bugs in the IBM BookServer (but we'\n  say '<b>can</b> report them to IBM).'\n  say '<li>We can'html.apost't fix a broken Book (but we <b>can</b>'\n  say 'report it to the supplier).'\n  say '<li>We are <b>not</b> responsible for the publication and/or'\n  say 'availability cycles of Online Books.  We upload what we receive.'\n  say '<li>We <b>are</b> responsible for the search \"Front-End\" and'\n  say 'much appreciate feedback on problems and suggestions.'\n  say '</ul>'\n\n  say html.p'That said, problem reporting and feedback can be best'\n  say 'accomplished by using the contact address'\n  say 'at the end of each Front-End page.  Although the IBM'\n  say 'BookServer pages are built by the IBM BookServer product,'\n  say 'they now have contact information on them.'\n\n  say html.p'In reporting a problem, it is important to provide'\n  say 'information that we can use to recreate the problem and'\n  say 'determine if we can fix it or report it to the vendor.'\n  say 'The BookServer will display a whole bunch of diagnostic'\n  say 'information when it encounters an error, but it unfortunately'\n  say 'does not bother to contain important information like:<ul>'\n  say '<li>The Book Name (the funny name like IEA1AB01, not the title'\n  say 'or Publication Number).'\n  say '<li>Which BookShelf it was on (if accessing from a BookShelf).'\n  say '<li>The Topic Number that was being requested or displayed.'\n  say '<li>The search arguments used if a search was used.'\n  say '</ul>'\n  say 'So when reporting a problem while you are within the IBM'\n  say 'BookServer (at the Book or BookShelf level), make sure that'\n  say 'you provide any of the applicable above information.'\n  say 'If you are reporting a problem with the search Front-End,'\n  say 'the search arguments are perhaps the most important item.'\n\nreturn\n\n/* Display the Instructions for the Search Results */\nresultsinstructions: procedure expose archive. html. query.\n  say '<hr><h2 align=center>Search Results</h2>'\n  if query.resume <> '' then\n    return\n  say 'Click on <b>Publication Number</b> to go to the Table of'\n  say 'Contents for the Book.  If the <b>Book Name</b>',\n    'or <b>PDF </b> column is'\n  say archive.front||archive.word||archive.back','\n  say 'the Book or PDF Data Set has been archived by HSM and there'\n  say 'will be a delay while it is recalled from tape.'\n  say 'The <b>BookShelf Name(s)</b> that a Book is contained'\n  say 'in are provided to allow easy access to related Books.'\n  say 'Note that many Books appear in more than ONE BookShelf.'\n  if query.details then\n    do\n      say 'The <b>Book Date & Time</b>'\n      say 'are when the SoftCopy Book was built and may'\n      say '<b>not</b> correspond to a hardcopy publication date.'\n    end\n  say 'PDF Book Files are accessible only if the'\n  say 'Adobe Acrobat Reader in installed and available'\n  say 'as a Plug-in on your Web Browser.'\nreturn\n\n/* Create the beginning of the html output */\nhtmlheader: procedure expose cgi.\n  if cgi.ssi then\n    say 'Content-type: text/x-ssi-html'\n  else\n    say 'Content-type: text/html'\n  say\n  say '<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">'\n  say '<html>'\n  say '<head>'\n  say '<title>'cgi.titletext'</title>'\n  say '</head>'\n  say '<body>'\nreturn\n\n/* Display the processing footer */\nprocessfooter: procedure expose env. os390. url. html. cgi.\n  elapsed = time('R')\n  elapsed = substr(elapsed,1,5)\n  address syscall 'times cputime.'\n  cpuused = (cputime.1 + cputime.2) / 100\n\n  say '<font size=-1>'\n  say 'This request started on 'env.date' at 'env.time,\n    'and took <font color=\"0000ff\">'elapsed'</font> elapsed seconds',\n    'and <font color=\"0000ff\">'cpuused'</font> CPU seconds, using the',\n    env.server' on 'os390.level' on the',\n    cgi.sitename' System 'os390.sysname'.'\n  say '</font>'\n\n  say html.p html.center'<img src=\"'url.mvsimage'/amdahl_s.gif\"',\n    'alt=\"AMDAHL logo\">'html.ecenter\n\n  if cgi.construction then\n    call underconstruction\n\n  say html.center html.p '<font size=-1><b>'\n  say 'If you have any questions or comments about this page,',\n    'please contact the</b>'\n  say '<a href=\"mailto:'cgi.bkmgrguru'?subject='cgi.mailsubject,\n    cgi.execlevel os390.sysname'\">'\n  say '<i>BookManager Guru</i></a></font>'\n\n  say html.br'<font size=-1>CGI Exec Level:</font>',\n    '<font size=-1 color=\"#d2691e\">'cgi.execlevel'</font>'\n  say '<a href=\"mailto:'cgi.bkmgrguru'?subject='cgi.mailsubject,\n    cgi.execlevel os390.sysname'\">'\n  say html.br'<img src=\"'url.mvsimage'/mail.gif\" alt=\"Mail\"></a>'\n  say html.ecenter\nreturn\n\n/* Display the ISS Header */\nissheader: procedure expose url. html.\n  say html.center,\n    '<a href=\"'url.wwwccc'/cgi-bin/imagemap/intranet/home.map\">'\n  say '<img border=0 src=\"'url.mvsimage'/isslogo.gif\"'\n  say 'alt=\"Information Systems and Services (imagemap)\"'\n  say 'width=617 height=96 ismap></a>'html.ecenter html.p\nreturn\n\n/* Display the ISS Footer */\nissfooter: procedure expose url. html.\n  say html.p html.center,\n    '<a href=\"'url.wwwccc'/cgi-bin/imagemap/intranet/xfoot.map\">'\n  say '<img src=\"'url.mvsimage'/xfooter.gif\"',\n    'alt=\"Navigation bar (imagemap)\"'\n  say 'border=0 height=20 width=537 ismap></a>'\n  say html.p'<font size=-1>',\n    '<a href=\"'url.wwwccc'/intranet/map.html\">Map</a> |'\n  say '<a href=\"'url.wwwccc'/WWW/ogma.html\">White Pages</a> |'\n  say '<a href=\"'url.wwwccc'/yellowpages/\">Yellow Pages</a> |'\n  say '<a href=\"http://search.amdahl.com/search/\">Search</a> |'\n  say '<a href=\"'url.wwwccc'/intranet/\">Amdahl Global Access</a> |'\n  say '<a href=\"'url.wwwccc'/intranet/feedback.htm\">Feedback</a>',\n    html.br\n  say '<a href=\"'url.wwwccc'/intranet/downloads.htm\">Downloads</a> |'\n  say '<a href=\"'url.wwwccc'/amdahl.online/\">Amdahl Online</a> |'\n  say '<a href=\"http://www.amdahl.com\">External Home</a> |'\n  say '<a href=\"http://ldap.amdahl.com/ds/phone\">Phone Book</a> |'\n  say '<a href=\"'url.wwwccc'/field/field1.htm\">Field Info</a> |'\n  say '<a href=\"'url.wwwccc'/intranet/tools.html\">Tools</a>'html.br\n  say '<a href=\"'url.wwwccc'/ags/\">Amdahl Global Services</a> |'\n  say '<a href=\"'url.wwwccc'/pss/\">Product Support Services</a> |'\n  say '<a href=\"'url.wwwccc'/intranet/news.html\">',\n    'News & Events</a>'html.br\n  say '<a href=\"'url.wwwccc'/intranet/servorg.html\">',\n    'Internal Service Organizations</a> |'\n  say '<a href=\"'url.wwwccc'/intranet/corpinfo.html\">',\n    'Corporate Info</a>'html.br\n  say '<a href=\"'url.wwwccc'/WWW/copyright.html\">Copyright</a>'\n  say '</font>'html.ecenter\nreturn\n\n/* Dump a bunch of variables for debugging purposes */\ndebugdump: procedure expose query. __environment. source. html.\n  say html.p'Source Information:',\n    source.tso source.mode source.command,\n    source.dd source.file source.exec,\n    source.cmdenv source.addrspace source.token\n\n  say html.p'Path Data is 'query.pathinfo html.br\n  say 'Function is 'query.function,\n    'and the data object is 'query.pathdata html.br\n  say 'The Query String is 'query.string html.br\n  say 'The Query Data Verb is DATA',\n    'and the Query Data is 'query.data html.br\n  say 'The Query Request Verb is SUBMIT',\n    'and the Query Request is 'query.request html.br\n  say 'The Query Resume Verb is RESUME',\n    'and the Query Resume is 'query.resume html.br\n\n  say html.p'Environmental variables:'html.br\n  do i = 1 to __environment.0\n    say '__environment.'i' is '__environment.i html.br\n  end\n  say html.p\n\nreturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BOOKSACE": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x00\\x00\\x99'?\\x00\\x99'\\x9f\\x15E\\x00\\x0b\\x00\\n\\x00\\x05\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1999-09-30T00:00:00", "modifydate": "1999-10-06T15:45:00", "lines": 11, "newlines": 10, "modlines": 5, "user": "KEM00"}, "text": "//BOOKSACE JOB (*),'BOOKMANAGER PROCESS',\n//             MSGCLASS=Y,MSGLEVEL=(1,1),NOTIFY=$,CLASS=0\n/*ROUTE  XEQ   CCCMVS3\n//*\n//EXTRACT EXEC PGM=CCCBKACE,\n//             REGION=32M,\n//             TIME=1\n//STEPLIB DD   DSN=AMDA.AUTHLIB,DISP=SHR\n//INFOFILE DD  DSN=CCCPUBS.INFO.BOOKS.EXTRACT,DISP=SHR\n//SYSUDUMP DD  SYSOUT=$\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BOOKSEXT": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x981O\\x01\\x00\\x17_\\x15\\x19\\x00\\x18\\x00\\x0b\\x00\\x15\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-11-10T00:00:00", "modifydate": "2000-06-23T15:19:00", "lines": 24, "newlines": 11, "modlines": 21, "user": "KEM00"}, "text": "//BOOKSEXT JOB (*),'BOOKMANAGER PROCESS',\n//             MSGCLASS=Y,MSGLEVEL=(1,1),NOTIFY=$,CLASS=0\n//*\n//EXTRACT EXEC PGM=CCCBKEXT,\n//             REGION=8M,\n//             TIME=4,\n//             PARM='ACTIVE,CCCPUBS.MASTER.BKLSHELF'\n//STEPLIB DD   DSN=CCCINSTL.BKMGR.LOAD,DISP=SHR\n//SYSUDUMP DD  SYSOUT=$\n//INFOFILE DD  DSN=&&EXTRACT,DISP=(NEW,PASS),\n//             UNIT=SYSVIO,SPACE=(CYL,(5,1)),\n//             BLKSIZE=6160\n//*\n//EXTRSORT EXEC PGM=SORT,\n//             REGION=8M,TIME=(,30)\n//SYSOUT DD    SYSOUT=*\n//SORTIN DD    DSN=&&EXTRACT,DISP=(OLD,PASS)\n//SORTOUT DD   DSN=CCCPUBS.INFO.BOOKS.EXTRACT,DISP=OLD\n//SORTWK01 DD  UNIT=SYSDA,SPACE=(CYL,5)\n//SORTWK02 DD  UNIT=SYSDA,SPACE=(CYL,5)\n//SORTWK03 DD  UNIT=SYSDA,SPACE=(CYL,5)\n//SYSIN  DD    *\n         SORT  FIELDS=(5,17,CH,A),SIZE=E20000\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCCBKACE": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00\\x00\\x00\\x99'?\\x00\\x99(_\\x14\\x14\\x02Y\\x01\\xfe\\x02Y\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-09-30T00:00:00", "modifydate": "1999-10-12T14:14:00", "lines": 601, "newlines": 510, "modlines": 601, "user": "KEM00"}, "text": "BKACE    TITLE 'BOOKMANAGER COMMON STORAGE ANCHOR BUILD'\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER COMMON STORAGE ANCHOR BUILD PROGRAM              *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\n         PUNCH '         PAGE  CCCBKACE'  MAKE DEBUGGING EASIER\n         PUNCH '         SETCODE AC(1)'   THIS PROGRAM IS AUTHORIZED\n*\nCCCBKACE CSECT\nCCCBKACE AMODE 31\nCCCBKACE RMODE 24\n*\n         USING CCCBKACE,R15        INITIAL BASE REGISTER\n         B     AROUNDID\n         DC    CL8'CCCBKACE'       MODULE ID\n         DC    CL8'V 1.1.0'        MODULE LEVEL\n         DC    CL8'&SYSDATC'\n         DC    CL8' &SYSTIME'\n*\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             SET THE BASE REGISTER\n         DROP  R15\n         USING CCCBKACE,R12\n*\n         L     R14,=A(SAVEAREA)    POINT AT NEW SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACK CHAIN\n         LR    R13,R14             SET NEW SAVE AREA\n*        USING SAVEAREA,R13        PROVIDE ADDITIONAL ADDRESSABILITY\n*\n         LR    R2,R1               SAVE THE PARM FIELD ADDRESS\n*\n         MODESET MODE=SUP          GET INTO SUPERVISOR STATE\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        LOAD THE CELL POOL SUBROUTINE                                *\n*                                                                     *\n***********************************************************************\n*\n         LOAD  EPLOC=CPSNAME,ERRET=LOADERR0 LOAD THE CELL POOL ROUTINE\n         ST    R0,CPSADDR\n*\n***********************************************************************\n*                                                                     *\n*        CHECK FOR PARM=FREE TO FREE EXISTING CSA BLOCKS              *\n*                                                                     *\n***********************************************************************\n*\n         L     R2,0(,R2)           LOAD THE ACTUAL PARM ADDRESS\n         LH    R3,0(,R2)           GET THE LENGTH\n         LTR   R3,R3               TEST FOR NO PARM\n         BZ    NOPARM              BRANCH IF NONE\n*\n         CH    R3,=H'4'            CHECK THE LENGTH\n         BNE   PARMINVL            INVALID IF NOT EXACTLY FOUR\n         CLC   2(4,R2),=C'FREE'    CHECK FOR FREE\n         BNE   PARMINVL            ERROR IF NOT\n*\n         MVI   FREECSA,X'FF'       SET THE FREE ONLY FLAG\n         B     FINDSSCT            GO FIND THE SSCT\n*\nNOPARM   DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FIND THE COMMON STORAGE ARCHOR                               *\n*                                                                     *\n***********************************************************************\n*\nFINDSSCT DS    0H\n         L     R3,CVTPTR           LOAD THE CVT ADDRESS\n         USING CVT,R3\n         L     R3,CVTJESCT         LOAD THE JESCT ADDRESS\n         USING JESCT,R3\n         L     R3,JESSSCT          LOAD THE FIRST SSCT ADDRESS\n         USING SSCT,R3\n*\nFINDSCTL DS    0H\n         CLC   SSCTSNAM,=A(BKASSNAM)    CHECK FOR OUR SUBSYSTEM NAME\n         BE    FINDSCTF            BRANCH IF FOUND\n         ICM   R3,15,SSCTSCTA      GET NEXT SSCT\n         BNZ   FINDSCTL            BRANCH IF THERE'S MORE\n         B     INVLSSCT            ERROR IF NOT FOUND\n*\nFINDSCTF DS    0H\n         ST    R3,SAVESSCT         SAVE IT FOR LATER\n*\n         CLI   FREECSA,X'FF'       IS THIS A FREE ONLY\n         BNE   OPENINFO\n         ICM   R2,15,SSCTSUSE      GET THE CURRENT ANCHOR ENVIRONMENT\n         BZ    INVLSSCT            BRANCH IF NONE\n*\n         MODESET EXTKEY=ZERO\n*\n         SLR   R0,R0               CLEAR FOR STORE\n         ST    R0,SSCTSUSE         ZERO THIS FIELD\n*\n         USING BKADSECT,R2\n         LA    R4,BKAANCHR         POINT AT FIRST ANCHOR WORD\n         LA    R5,BKAANUMB         GET NUMBER OF ANCHOR WORDS\n*\nFINDFREE DS    0H\n         ICM   R1,15,0(R4)         LOAD THE ANCHOR WORD\n         BZ    FINDFREN            IF ZERO, NOTHING TO FREE\n*\n         USING BKEDSECT,R1\n         L     R0,BKELENG          LOAD THE LENGTH\n         IC    R15,BKESUBPL        GET THE SUBPOOL\n         DROP  R1\n*\n         FREEMAIN RU,A=(1),LV=(0),SP=(15),KEY=BKAKEYID\n*\nFINDFREN DS    0H\n         LA    R4,4(,R4)           INCREMENT TO NEXT ANCHOR WORD\n         BCT   R5,FINDFREE         LOOP THROUGH EACH EXTRACT BLOCK\n*\n         LH    R0,BKALENG          LOAD THE ANCHOR LENGTH\n         IC    R15,BKASUBPL        GET THE SUBPOOL\n*\n         FREEMAIN RU,A=(R2),LV=(0),SP=(15),KEY=BKAKEYID\n*\n         DROP  R2,R3\n*\n         MODESET KEY=NZERO\n*\n         B     ALLDONE             AND LEAVE THIS PLACE\n*\n***********************************************************************\n*                                                                     *\n*        OPEN THE INPUT INFORMATION DATA SET                          *\n*                                                                     *\n***********************************************************************\n*\nOPENINFO DS    0H\n         OPEN  (INFOFILE,(INPUT))  OPEN THE INFO FILE\n         LTR   R15,R15             TEST FOR ANY OPEN ERRORS\n         BNZ   INFOPENE            BAD IF ANY ERRORS\n*\nINFOREAD DS    0H\n         GET   INFOFILE            READ ONE INFORMATION RECORD\n         LR    R2,R1               COPY THIS ADDRESS\n         USING BKNDSECT,R2         ESTABLISH EXTRACT AREA MAPPING\n*\n         LA    R0,1                LOAD A 1\n         A     R0,INFOCNT          ADD THE PREVIOUS COUNT\n         ST    R0,INFOCNT          STORE THE UPDATED COUNT\n*\n         CLI   BKNNAME,C'*'        CHECK FOR COMMENT RECORD\n         BE    INFOREAD            LOOP IF COMMENT\n         CLC   BKNTYPE,=CL8'BKINDEX'    IS THIS A BOOKSHELF INDEX\n         BE    INFOREAD            SKIP IT IF SO\n*\n         LA    R0,4+7              PREFIX PLUS ROUND FACTOR\n         AH    R0,BKNLENG          ADD THE RECORD LENGTH\n         SRL   R0,3                DIVIDE BY 8\n         SLL   R0,3                MULTIPLY BY 8\n*\n         LA    R1,EXTBLOCK         POINT AT EXTRACT BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDR\n         BASSM R14,R15             GET THE STORAGE\n         LR    R3,R15              COPY STORAGE ADDRESS\n*\n         XC    0(4,R3),0(R3)       CLEAR THE CHAIN POINTER\n         LA    R0,4(,R3)           POINT AT DATA AREA\n*\n         LH    R1,BKNLENG          LOAD THE RDW LENGTH\n         LA    R14,BKNRDW          POINT AT ACTUAL RECORD\n         LR    R15,R1              DUPLICATE THE LENGTH\n         MVCL  R0,R14              COPY THE RECORD\n*\n         LA    R0,1                LOAD A ONE\n         LH    R15,BKNLENG         LOAD THE RDW LENGTH\n         LA    R15,7(,R15)         ADD FOR ROUNDING\n         SRL   R15,3               DIVIDE BY EIGHT\n         SLL   R15,3               MULTIPLY BY EITH\n*\n         CLC   BKNTYPE,=CL8'BOOK'  CHECK RECORD TYPE\n         BE    INFOBOOK            BRANCH IF IT'S A BOOK\n*\n         A     R0,INFOCNTS         ADD PREVIOUS SHELF COUNT\n         ST    R0,INFOCNTS         STORE UPDATED COUNT\n*\n         A     R15,INFOSIZS        ADD PREVIOUS SIZE\n         ST    R15,INFOSIZS        STORE UPDATED SIZE\n*\n         LA    R15,INFOTBLS        POINT AT BOOKSHELF CHAIN\n         LA    R14,INFOLSTS        POINT AT LAST BOOKSHELF\n         LA    R1,INFODUPS         POINT AT DUP COUNTER\n         B     INFOCHNC            GO TO COMMON CHAIN CODE\n*\nINFOBOOK DS    0H\n         A     R0,INFOCNTB         ADD PREVIOUS BOOK COUNT\n         ST    R0,INFOCNTB         STORE UPDATED COUNT\n*\n         A     R15,INFOSIZB        ADD PREVIOUS SIZE\n         ST    R15,INFOSIZB        STORE UPDATED SIZE\n*\n         LA    R15,INFOTBLB        POINT AT BOOK CHAIN\n         LA    R14,INFOLSTB        POINT AT LAST BOOK\n         LA    R1,INFODUPB         POINT AT DUP COUNTER\n*\nINFOCHNC DS    0H\n         ICM   R0,15,0(R15)        IS THIS THE FIRST TIME\n         BNZ   INFOADD             IF NOT, GO ADD IT\n*\n         ST    R3,0(,R15)          STORE AS FIRST RECORD\n         ST    R3,0(,R14)          STIRE AS LAST RECORD\n*\n         B     INFOREAD            AND GO GET THE NEXT RECORD\n*\nINFOADD  DS    0H\n         L     R15,0(,R14)         LOAD THE LAST RECORD ADDRESS\n         ST    R3,0(,R14)          SET THE NEW LAST RECORD\n         ST    R3,0(,R15)          CHAIN THE OLD TO THE NEW\n*\n         CLC   BKNNAME,BKNNAME-BKNDSECT+4(R15) COMPARE KEYS\n         BNE   INFOREAD            IF NOT A DUP, READ NEXT\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,0(,R1)           ADD PREVIOUS DUP COUNT\n         ST    R0,0(,R1)           UPDATE DUPLICATE COUNT\n         B     INFOREAD            AND READ ANOTHER RECORD\n*\n         DROP  R2\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CLOSE THE INFORMATION FILE                                   *\n*                                                                     *\n***********************************************************************\n*\nINFOEOD  DS    0H\n         CLOSE (INFOFILE)          CLOSE THE OUTPUT FILE\n         FREEPOOL INFOFILE         FREE THE BUFFER POOL\n*\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT THE PERMANENT TABLE ANCHOR BLOCK                   *\n*                                                                     *\n***********************************************************************\n*\n         MODESET EXTKEY=ZERO\n*\n         LA    R0,BKALNGTH\n         LA    R15,BKASPLID\n         GETMAIN RU,LV=(0),SP=BKASPLID,KEY=BKAKEYID,LOC=ANY\n         LR    R2,R1               COPY THIS FOR USE\n         ST    R2,SAVEBKA          AND SAVE IT FOR LATER\n         USING BKADSECT,R2\n*\n         XC    BKADSECT(BKALNGTH),BKADSECT CLEAR THE AREA\n         MVC   BKABLKID,=A(BKAIDEQU)    SET CONTROL BLOCK ID\n         MVI   BKASUBPL,BKASPLID   SET SUBPOOL ID\n         MVI   BKALEVEL,BKAVERSN   SET THE CONTROL BLOCK VERSION\n         LA    R0,BKALNGTH         GET THE LENGTH\n         STH   R0,BKALENG          STORE THE LENGTH\n*\n         TIME  DEC                 GET CURRENT TIME AMD DATE\n         ST    R0,BKABTIME         STORE THE TIME\n         ST    R1,BKABDATE         STORE THE DATE\n         AP    BKABDATE,=P'1900000'     GET THE REAL DATE\n*\n         MVC   BKAQNAME,=C'BOOKSRVR'    SET ENQUEUE QNAME\n         MVC   BKARNAME,=CL16'COMMON.STORAGE' SET THE RNAME\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD THE PERMANENT BOOKSHELF EXTRACT TABLE                  *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,BKELNGTH         LENGTH OF ENTRY HEADER\n         L     R1,INFOCNTS         NUMBER OF BOOKSHELF ENTRIES\n         MH    R1,=Y(BKEELNTH)     GET ENTRY HEADER SPACE\n         AR    R0,R1               ADD TO SPACE NEEDED\n         A     R0,INFOSIZS         ADD BOOK STORAGE NEEDED\n         LR    R4,R0               SAVE THIS AREA SIZE\n*\n         GETMAIN RU,LV=(0),SP=BKESPLID,LOC=ANY,BNDRY=PAGE,KEY=BKAKEYID\n*\n         LR    R3,R1               COPY FOR PERMANENT USE\n         USING BKEDSECT,R3\n         ST    R3,BKABKSEX         STORE BOOKSHELF EXTRACT ADDRESS\n*\n         LR    R0,R3               COPY FOR CLEAR\n         LR    R1,R4               COPY LENGTH\n         SLR   R15,R15             CLEAR FOR MVCL PADDING\n         MVCL  R0,R14              CLEAR THE AREA\n*\n         MVC   BKEBLKID,=A(BKEIDEQU)    SET THE EYE CATCHER\n         MVI   BKESUBPL,BKESPLID   SET THE SUBPOOL\n         MVI   BKELEVEL,BKEVERSN   SET THE CONTROL BLOCK LEVEL\n         ST    R4,BKELENG          COPY THE SAVED AREA SIZE\n         MVI   BKETYPE,BKETYPES    INDICATE BOOKSHELF EXTRACT\n*\n         LA    R4,BKESTART         POINT AT FIRST ENTRY\n         USING BKEENTRY,R4\n*\n         L     R0,INFOCNTS         LOAD NUMBER OF ENTRIES\n         ST    R0,BKENUMBR         STORE NUMBER OF ENTRIES\n         S     R0,INFODUPS         SUBTRACT NUMBER OF DUPS\n         ST    R0,BKEUNQUE         STURE NUMBER OF UNIQUE ENTRIES\n*\n         ST    R4,BKEFIRST         SET ADDRESS OF FIRST ENTRY\n         ST    R4,BKELAST          SET ADDRESS OF LAST ENTRY\n*\n         L     R5,INFOTBLS         POINT AT FIRST RECORD\n*\nBKSTLOOP DS    0H\n         LH    R1,4(,R5)           LOAD THE LENGTH FOR THE MOVE\n         LR    R15,R1              COPY IT\n         LA    R0,BKEEDATA         POINT AT RECEIVING AREA\n         LA    R14,4(,R5)          POINT AT THE SAVED RECORD\n         MVCL  R0,R14              COPY THE RECORD TO EXTRACT AREA\n*\n         L     R1,BKELAST          GET LAST RECORD\n         ST    R1,BKEEPREV         SET THE BACK POINTER\n         ST    R4,BKEENEXT-BKEENTRY(,R1)\n         ST    R4,BKELAST          SET THE NEW LAST RECORD\n*\n         LA    R0,BKEELNTH+7       PREFIX PLUS ROUNDING\n         AH    R0,4(,R5)           ADD THE RDW\n         SRL   R0,3                DIVIDE BY EIGHT\n         SLL   R0,3                MULTIPLY BY EIGHT\n         AR    R4,R0               GET NEXT SLOT IN EXTRACT TABLE\n*\n         ICM   R5,15,0(R5)         GET NEXT SAVED ADDRESS\n         BNZ   BKSTLOOP            LOOP IF WE HAVE MORE\n*\n         L     R4,BKEFIRST         POINT AT FIRST ENTRY\n         ST    R5,BKEEPREV         ZERO BACK POINTER\n         L     R4,BKELAST          POINT AT LASTE ENTRY\n         ST    R5,BKEENEXT         ZERO FORWARD POINTER\n*\n         DROP  R3,R4\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD THE PERMANENT BOOK EXTRACT TABLE                       *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,BKELNGTH         LENGTH OF ENTRY HEADER\n         L     R1,INFOCNTB         NUMBER OF BOOK ENTRIES\n         MH    R1,=Y(BKEELNTH)     GET ENTRY HEADER SPACE\n         AR    R0,R1               ADD TO SPACE NEEDED\n         A     R0,INFOSIZB         ADD BOOK STORAGE NEEDED\n         LR    R4,R0               SAVE THIS AREA SIZE\n*\n         GETMAIN RU,LV=(0),SP=BKESPLID,LOC=ANY,BNDRY=PAGE,KEY=BKAKEYID\n*\n         LR    R3,R1               COPY FOR PERMANENT USE\n         USING BKEDSECT,R3\n         ST    R3,BKABOOEX         STORE BOOKSHELF EXTRACT ADDRESS\n*\n         LR    R0,R3               COPY FOR CLEAR\n         LR    R1,R4               COPY LENGTH\n         SLR   R15,R15             CLEAR FOR MVCL PADDING\n         MVCL  R0,R14              CLEAR THE AREA\n*\n         MVC   BKEBLKID,=A(BKEIDEQU)    SET THE EYE CATCHER\n         MVI   BKESUBPL,BKESPLID   SET THE SUBPOOL\n         MVI   BKELEVEL,BKEVERSN   SET THE CONTROL BLOCK LEVEL\n         ST    R4,BKELENG          COPY THE SAVED AREA SIZE\n         MVI   BKETYPE,BKETYPEB    INDICATE BOOK EXTRACT\n*\n         LA    R4,BKESTART         POINT AT FIRST ENTRY\n         USING BKEENTRY,R4\n*\n         L     R0,INFOCNTB         LOAD NUMBER OF ENTRIES\n         ST    R0,BKENUMBR         STORE NUMBER OF ENTRIES\n         S     R0,INFODUPB         SUBTRACT NUMBER OF DUPS\n         ST    R0,BKEUNQUE         STURE NUMBER OF UNIQUE ENTRIES\n*\n         ST    R4,BKEFIRST         SET ADDRESS OF FIRST ENTRY\n         ST    R4,BKELAST          SET ADDRESS OF LAST ENTRY\n*\n         L     R5,INFOTBLB         POINT AT FIRST RECORD\n*\nBOOTLOOP DS    0H\n         LH    R1,4(,R5)           LOAD THE LENGTH FOR THE MOVE\n         LR    R15,R1              COPY IT\n         LA    R0,BKEEDATA         POINT AT RECEIVING AREA\n         LA    R14,4(,R5)          POINT AT THE SAVED RECORD\n         MVCL  R0,R14              COPY THE RECORD TO EXTRACT AREA\n*\n         L     R1,BKELAST          GET LAST RECORD\n         ST    R1,BKEEPREV         SET THE BACK POINTER\n         ST    R4,BKEENEXT-BKEENTRY(,R1)\n         ST    R4,BKELAST          SET THE NEW LAST RECORD\n*\n         LA    R0,BKEELNTH+7       PREFIX PLUS ROUNDING\n         AH    R0,4(,R5)           ADD THE RDW\n         SRL   R0,3                DIVIDE BY EIGHT\n         SLL   R0,3                MULTIPLY BY EIGHT\n         AR    R4,R0               GET NEXT SLOT IN EXTRACT TABLE\n*\n         ICM   R5,15,0(R5)         GET NEXT SAVED ADDRESS\n         BNZ   BOOTLOOP            LOOP IF WE HAVE MORE\n*\n         L     R4,BKEFIRST         POINT AT FIRST ENTRY\n         ST    R5,BKEEPREV         ZERO BACK POINTER\n         L     R4,BKELAST          POINT AT LASTE ENTRY\n         ST    R5,BKEENEXT         ZERO FORWARD POINTER\n*\n         DROP  R3,R4\n*\n         DROP  R2                  DROP THE NEW ANCHOR BLOCK FOR NOW\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FREE THE PREVIOUS COMMON AREA IF IT EXISTS                   *\n*                                                                     *\n***********************************************************************\n*\n         L     R3,SAVESSCT         LOAD THE SAVED SSCT ADDRESS\n         USING SSCT,R3\n*\n         ICM   R2,15,SSCTSUSE      GET THE CURRENT ANCHOR ENVIRONMENT\n         BZ    BILDANEW            BRANCH IF NONE\n*\n         SLR   R0,R0               CLEAR FOR STORE\n         ST    R0,SSCTSUSE         ZERO THIS FIELD\n*\n         USING BKADSECT,R2\n         LA    R4,BKAANCHR         POINT AT FIRST ANCHOR WORD\n         LA    R5,BKAANUMB         GET NUMBER OF ANCHOR WORDS\n*\nBILDFREE DS    0H\n         ICM   R1,15,0(R4)         LOAD THE ANCHOR WORD\n         BZ    BILDFREN            IF ZERO, NOTHING TO FREE\n*\n         USING BKEDSECT,R1\n         L     R0,BKELENG          LOAD THE LENGTH\n         IC    R15,BKESUBPL        GET THE SUBPOOL\n         DROP  R1\n*\n         FREEMAIN RU,A=(1),LV=(0),SP=(15),KEY=BKAKEYID\n*\nBILDFREN DS    0H\n         LA    R4,4(,R4)           INCREMENT TO NEXT ANCHOR WORD\n         BCT   R5,BILDFREE         LOOP THROUGH EACH EXTRACT BLOCK\n*\n         LH    R0,BKALENG          LOAD THE ANCHOR LENGTH\n         IC    R15,BKASUBPL        GET THE SUBPOOL\n*\n         FREEMAIN RU,A=(R2),LV=(0),SP=(15),KEY=BKAKEYID\n*\n         DROP  R2\n*\nBILDANEW DS    0H\n         L     R1,SAVEBKA\n         ST    R1,SSCTSUSE         POINT TO THE NEW ANCHOR AREA\n*\n         DROP  R3\n*\n         MODESET KEY=NZERO         GET BACK TO NORMAL KEY\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FREE THE ACCUMULATED EXTRACT DATA                            *\n*                                                                     *\n***********************************************************************\n*\n         SLR   R0,R0               INDICATE FREE\n         LA    R1,EXTBLOCK         POINT AT EXTRACT BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDR\n         BASSM R14,R15             GET THE STORAGE\n         LR    R1,R15              COPY STORAGE ADDRESS\n*\n***********************************************************************\n*                                                                     *\n*        DELETE ALL THE SUBROUTINES                                   *\n*                                                                     *\n***********************************************************************\n*\nALLDONE  DS    0H\n         DELETE EPLOC=CPSNAME      DELETE THE CELL POOL SUBROUTINE\n*\n***********************************************************************\n*                                                                     *\n*        RETURN TO CALLER                                             *\n*                                                                     *\n***********************************************************************\n*\n         L     R13,4(,R13)         UNCHAIN THE SAVE AREA\n         L     R15,RETCODE         LOAD THE RETURN CODE\n         L     R14,12(,R13)        LOAD THE RETURN ADDRESS\n         LM    R0,R12,20(R13)      RELOAD THE REGISTERS\n         BR    R14                 RETURN TO CALLER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        VARIOUS ABEND ROUTINES                                       *\n*                                                                     *\n***********************************************************************\n*\nPARMINVL DS    0H\n         ABEND 10,DUMP\n*\nINFOPENE DS    0H\n         ABEND 60,DUMP\n*\nLOADERR0 DS    0H\n         ABEND 75,DUMP\n*\nINVLSSCT DS    0H\n         WTO   'CCCBKACE COMMON ANCHOR SSCT NOT FOUND',ROUTCDE=11\n         LA    R15,16\n         ST    R15,RETCODE         SET THE RETURN CODE\n         B     ALLDONE\n*\n         EJECT\nLITERALS LTORG ,\n*\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\nSAVEAREA DC    9D'0'               REGISTER SAVE AREA\n*\nDOUBLE   DS    D                   DOUBLE WORD WORK AREA\n*\nRETCODE  DC    F'0'                RETURN CODE\n*\nINFOCNT  DC    F'0'                COUNT OF EXTRACT RECORDS READ\n*\nINFOTBLS DC    A(0)                ADDRESS OF FIRST EXTRACT SHELF\nINFOLSTS DC    A(0)                ADDRESS OF LAST EXTRACT SHELF\nINFOSIZS DC    F'0'                SIZE OF SHELF RECORDS\nINFOCNTS DC    F'0'                COUNT OF BOOKSHELF RECORDS\nINFODUPS DC    F'0'                COUNT OF DUPLICATE NAMES\n*\nINFOTBLB DC    A(0)                ADDRESS OF FIRST EXTRACT BOOK\nINFOLSTB DC    A(0)                ADDRESS OF LAST EXTRACT BOOK\nINFOSIZB DC    F'0'                SIZE OF BOOK RECORDS\nINFOCNTB DC    F'0'                COUNT OF BOOK RECORDS\nINFODUPB DC    F'0'                COUNT OF DUPLICATE NAMES\n*\nSAVEBKA  DC    A(0)                ADDRESS OF NEW COMMON ANCHOR\nSAVESSCT DS    A                   ADDRESS OF THE SSCT\n*\nCPSNAME  DC    CL8'CCCBKCPS'       CELL POOL ROUTINE NAME\nCPSADDR  DC    A(0)                CELL POOL SUBROUTINE ADDRESS\n*\nFREECSA  DC    X'00'               X'FF' IF CSA FREE ONLY\n*\nEXTBLOCK BKMGRCPS ID=BOO,SP=66,SIZE=4096,LOC=ANY\n*\nINFOFILE DCB   DSORG=PS,                                               X\n               DDNAME=INFOFILE,                                        X\n               MACRF=GL,                                               X\n               EODAD=INFOEOD,                                          X\n               RECFM=VB\n*\n         EJECT\n*\n         PUSH  PRINT\n         PRINT NOGEN\n*\n         CVT   DSECT=YES\n*\n         IEFJESCT\n*\n         IEFJSCVT\n*\n         DCBD  DSORG=PS,DEVD=DA\n*\n         BKMGRINF\n*\n         BKMGRCSA\n*\n         POP   PRINT\n*\n         END   CCCBKACE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCCBKCPS": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x99!O\\x00\\x99'?\\x17G\\x00\\xa5\\x00\\x9e\\x00\\x14\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-08-02T00:00:00", "modifydate": "1999-09-30T17:47:00", "lines": 165, "newlines": 158, "modlines": 20, "user": "KEM00"}, "text": "BKCPS    TITLE 'BOOKMANAGER CELL POOL SERVICES'\n***********************************************************************\n*                                                                     *\n*        CCCBKCPS                                                     *\n*                                                                     *\n*        THIS PROGRAM WILL ESTABLISH, MAINTAIN, AND FREE LARGE        *\n*        BLOCKS OF STORAGE WHICH CAN BE OBTAINED IN SMALLER PIECES.   *\n*                                                                     *\n*        INPUT  - REGISTER 1 - ADDRESS OF CELL POOL BLOCK ID          *\n*                 REGISTER 0 - LENGTH OF CELL TO OBTAIN - IF ZERO,    *\n*                 ALL STORAGE IS FREED.                               *\n*                                                                     *\n*        OUTPUT - ADDRESS OF RETURNED STORAGE IN REGISTER 15.         *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, AMODE 31, RMODE ANY,    *\n*                     UNAUTHORIZED                                    *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\nCCCBKCPS CSECT\nCCCBKCPS AMODE 31\nCCCBKCPS RMODE ANY\n*\n         USING CCCBKCPS,R15\n         B     AROUNDID\n         DROP  R15\n*\n         DC    CL8'CCCBKCPS'\n         DC    CL8'V 1.1.1'\n         DC    CL8'&SYSDATC'\n         DC    CL8' &SYSTIME'\n*\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n*\n         LR    R12,R15             LOAD REGISTER 12 WITH ENTRY\n         USING CCCBKCPS,R12        ESTABLISH ADDRESSABILITY\n*\n         LR    R8,R1               LOAD REGISTER 8 WITH USER HEADER\n         USING BKCDSECT,R8\n*\n         LR    R7,R0               SAVE THE USER REQUEST LENGTH\n*\n         ICM   R9,15,BKCSTART      LOAD THE FIRST BLOCK ADDRESS\n         BNZ   HAVE1ST             BRANCH IF WE HAVE IT\n*\n         BAL   R14,INITBLK         INITIALIZE BLOCK HEADER\n         ST    R1,BKCSTART         INITIALIZE USER HEADER\n         LR    R9,R1               COPY ADDRESS\n*\n         USING BKDDSECT,R9\nHAVE1ST  DS    0H\n         LTR   R7,R7               IS THIS A FREE REQUEST\n         BZ    DOFREEIT            BRANCH IF SO\n*\n         LA    R0,BKDLNGTH(,R7)    GET FULL SIZE\n         C     R0,BKCSIZE          CHECK IF TOO BIG\n         BNH   FREELOOP            BRANCH IF OK\n         DC    H'0'                DO THE DIRTY\n*\nFREELOOP DS    0H\n         C     R7,BKDFREE          CHECK FREE SPACE\n         BNH   HAVEFREE            BRANCH IF IT WILL FIT\n*\n         ICM   R1,15,BKDNEXT       GET NEXT BLOCK\n         BZ    NEEDNEW             BRANCH IF NONE\n*\n         LR    R9,R1               GET THE NEXT BLOCK\n         B     FREELOOP            AND CHECK THE NEXT ONE\n*\nNEEDNEW  DS    0H\n         BAL   R14,INITBLK         GET ANOTHER BLOCK\n*\n         ST    R1,BKDNEXT          CHAIN IT ON\n         LR    R9,R1               AND MAKE THIS THE CURRENT BLOCK\n*\nHAVEFREE DS    0H\n         L     R2,BKDADDR          GET ADDRESS OF AREA TO BE RETURNED\n         LA    R0,0(R7,R2)         GET ADDRESS OF NEW FREE OFFSET\n         ST    R0,BKDADDR          STORE UPDATED ADDRESS\n*\n         L     R0,BKDFREE          LOAD FREE AREA AVAILABLE\n         SR    R0,R7               SUBTRACT AREA WANTED\n         ST    R0,BKDFREE          STORE REMAINING FREE AREA\n         B     RETURN              AND LEAVE\n*\nDOFREEIT DS    0H\n         LR    R1,R9               COPY AREA TO BE FREED\n         L     R0,BKCSIZE          LOAD THE SIZE OF THE BLOCK\n         IC    R15,BKCSPID         LOAD THE SUBPOOL ID\n         N     R15,=X'0000007F'    CLEAR LOC FLAG\n         L     R9,BKDNEXT          LOAD THE NEXT BLOCK ADDRESS\n*\n         FREEMAIN RU,LV=(0),SP=(15),A=(1) FREE THE STORAGE\n*\n         LTR   R9,R9               DO WE HAVE ANOTHER\n         BNZ   DOFREEIT            LOOP IF WE DO\n*\n         SLR   R2,R2               SET THE RETURN ADDRESS\n         ST    R2,BKCSTART         RESET STARTING ADDRESS\n         B     RETURN              AND RETURN\n*\n         DROP  R9\n*\nRETURN   DS    0H\n         LR    R15,R2              SET THE RETURN AREA ADDRESS\n         L     R14,12(,R13)        LOAD REGISTER 14 WITH RETURN\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\n*\nINITBLK  DS    0H\n         L     R0,BKCSIZE          LOAD THE BLOCK SIZE\n         IC    R15,BKCSPID         INSERT THE CELL POOL SIZE\n         N     R15,=X'0000007F'    CLEAR LOC FLAG\n*\n         TM    BKCSPID,BKCABOVE    CHECK FOR LOC=ANY\n         BO    GETLOCAN\n*\n         GETMAIN RU,SP=(15),LV=(0),LOC=(BELOW,ANY)\n         B     GETSETUP\n*\nGETLOCAN DS    0H\n         GETMAIN RU,SP=(15),LV=(0),LOC=ANY\n*\n         USING BKDDSECT,R1\nGETSETUP DS    0H\n         MVC   BKDBLKID,=A(BKDIDEQU)    SET THE EYECATCHER\n         XC    BKDNEXT,BKDNEXT     MAKE SURE NEXT POINTER IS ZERO\n         LA    R15,BKDDATA         POINT AT START OF DATA AREA\n         ST    R15,BKDADDR         INITIALIZE START OF FREE AREA\n*\n         L     R15,BKCSIZE         GET SIZE OF AREA\n         SH    R15,=Y(BKDLNGTH)    SUBTRACT HEADER\n         ST    R15,BKDFREE         STORE FREE SPACE SIZE\n*\n         BR    R14\n*\n         DROP  R1\n*\n         EJECT\nLITERALS LTORG ,\n*\nPATCH    DC    0D'0',32S(*)\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         BKMGRCPS TYPE=DSECT\n*\n         END   CCCBKCPS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCCBKDAT": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01O\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x99\\x04?\\x16T\\x01\\xa2\\x00\\xca\\x00\\xe7\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.79", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1999-02-12T16:54:00", "lines": 418, "newlines": 202, "modlines": 231, "user": "KEM00"}, "text": "BKDAT    TITLE 'BOOKMANAGER DEFINITION TABLE'\n***********************************************************************\n*                                                                     *\n*        CCCBKDAT                                                     *\n*                                                                     *\n*        THIS PROGRAM IS A NON-EXECUTABLE TABLE CONTAINING ALL        *\n*        OF THE BOOKMANAGER DEFINITION NAMES AND THE VALUE            *\n*        CORRESPONDING TO THEM.  IT IS USE BY THE TSO COMMAND,        *\n*        CCCBKDEF, TO RETURN THESE VALUES AS CLIST/REXX VARIABLES.    *\n*                                                                     *\n*        THIS TABLE CAN ALSO BE LOADED AND USED DIRECTLY BY ANY       *\n*        OTHER BOOKMANAGER UTILITY PROGRAM TO EXTRACT THE DATA        *\n*        NEEDED TO PERFORMS ITS' FUNCTIONS.                           *\n*                                                                     *\n*        INPUT - NONE                                                 *\n*                                                                     *\n*        OUTPUT - NONE                                                *\n*                                                                     *\n*        EACH VARIABLE DEFINITION CONSISTS OF A 16 BYTE DEFINITION    *\n*        KEY FOLLOWED BY A 64 CHARACTER VALUE.  BOTH ARE PADDED       *\n*        WITH BLANKS.  THE FIRST ENTRY SHOULD BE SKIPPED, AS IT       *\n*        IS SIMPLY MODULE DEFINITION INFORMATION.                     *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, AMODE 31, RMODE ANY,    *\n*                     UNAUTHORIZED, DATA TABLE                        *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n         LCLC  &USMLVL\n&USMLVL  SETC  '50'                SET THE UNIVERSAL SALES MANUAL LEVEL\n*\nCCCBKDAT CSECT\nCCCBKDAT AMODE 31\nCCCBKDAT RMODE ANY\n*\n         DC    CL16'CCCBKDAT'\n         DC    CL64'V 1.1.7 &SYSDATE &SYSTIME'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER DATA SET HIGH LEVEL INDEX                        *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'HLI'\n         DC    CL64'CCCPUBS'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER DATA SET SECOND LEVEL INDEX                      *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'CD2ND'\n         DC    CL64'CDROM'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER DATA SET SECOND LEVEL INDEX (FOR TAPE DATA SETS) *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'TAPE2ND'\n         DC    CL64'TAPE'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER MASTER (PUBLIC) BOOKSHELF LIST DATA SET NAME     *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'MASTER'\n         DC    CL64'CCCPUBS.MASTER.BKLSHELF'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER ALLOCATION SMS MODE (ON OR OFF)                  *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SMSMODE'\n         DC    CL64'ON'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOKSHELF DATA SET STORAGE VOLUME                *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SHELFVOL'\n         DC    CL64'CCBKM1'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOKSHELF DATA SET SMS STORAGE CLASS             *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SHELFSC'\n         DC    CL64'BKMGRPRI'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOKSHELF DATA SET SMS MANAGEMENT CLASS          *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SHELFMC'\n         DC    CL64'BKMGRMAJ'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOKSHELF INDEX DATA SET STORAGE VOLUME          *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'INDEXVOL'\n         DC    CL64'CCBKM1'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOKSHELF INDEX DATA SET SMS STORAGE CLASS       *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'INDEXSC'\n         DC    CL64'BKMGRPRI'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOKSHELF INDEX DATA SET SMS MANAGEMENT CLASS    *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'INDEXMC'\n         DC    CL64'BKMGRMAJ'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER ALTERNATE BOOKSHELF INDEX DATA SET STORAGE VOLUME*\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'INDEXALTVOL'\n         DC    CL64'CCBKM2'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER PRIMARY STORAGE CLASS                            *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SCPRIMARY'\n         DC    CL64'BKMGRPRI'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER SECONDARY STORAGE CLASS                          *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SCSECONDARY'\n         DC    CL64'BKMGRALT'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOK DATA SET STORAGE VOLUME                     *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'BOOKVOL'\n         DC    CL64'CCBKM2'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOK DATA SET PRIMARY SMS STORAGE CLASS          *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'BOOKSC'\n         DC    CL64'BKMGRPRI'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOK DATA SET PRIMARY SMS MANAGEMENT CLASS       *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'BOOKMC'\n         DC    CL64'BKMGRMAJ'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOK DATA SET SECONDARY SMS STORAGE CLASS        *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'BOOKSCSECONDARY'\n         DC    CL64'BKMGRALT'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER BOOK DATA SET SECONDARY SMS MANAGEMENT CLASS     *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'BOOKMCSECONDARY'\n         DC    CL64'BKMGRMIN'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER ALTERNATE BOOK DATA SET STORAGE VOLUME           *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'BOOKALTVOL'\n         DC    CL64'CCBKM1'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER PDF DATA SET STORAGE VOLUME                      *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'PDFVOL'\n         DC    CL64'CCBKM2'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER PDF DATA SET PRIMARY SMS STORAGE CLASS           *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'PDFSC'\n         DC    CL64'BKMGRALT'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER PDF DATA SET PRIMARY SMS MANAGEMENT CLASS        *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'PDFMC'\n         DC    CL64'BKMGRMIN'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER PDF DATA SET SECONDARY SMS STORAGE CLASS         *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'PDFSCSECONDARY'\n         DC    CL64'BKMGRALT'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER PDF DATA SET SECONDARY SMS MANAGEMENT CLASS      *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'PDFMCSECONDARY'\n         DC    CL64'BKMGRMIN'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER ALTERNATE PDF DATA SET STORAGE VOLUME            *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'PDFALTVOL'\n         DC    CL64'CCBKM1'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER SPILL STORAGE VOLUME                             *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SPILLVOLUME'\n         DC    CL64'CCIPL2'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER TEMPORARY BOOK DATA SET NAME                     *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'TEMPBOOK'\n         DC    CL64'CCCPUBS.TEMP.IBMFILE'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER TEMPORARY BOOKSHELF INDEX DATA SET NAME          *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'TEMPINDEX'\n         DC    CL64'CCCPUBS.TEMP.IBMFILE'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER TEMPORARY BOOKSHELF DATA SET NAME                *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'TEMPSHELF'\n         DC    CL64'CCCPUBS.TEMP.BKSHELF'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER TEMPORARY BOOK DATA SET NAME                     *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'TEMPPDF'\n         DC    CL64'CCCPUBS.TEMP.PDFFILE'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER TEMPORARY SENDLIST DATA SET NAME                 *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'SENDLIST'\n         DC    CL64'CCCPUBS.TEMP.SENDLIST'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER INFORMATION HISTORY DATA SET NAME                *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'HISTORY'\n         DC    CL64'CCCPUBS.INFO.HISTORY'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER INFORMATION BOOK LIST DATA SET NAME              *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'BOOKLIST'\n         DC    CL64'CCCPUBS.INFO.BOOKS.LIST'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER INFORMATION READ ME DATA SET NAME                *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'README'\n         DC    CL64'CCCPUBS.INFO.README.DATA'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER FTP LOG DATA SET NAME                            *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'LOGDATASET'\n         DC    CL64'CCCPUBS.INFO.LOG'\n*\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER MESSAGES BOOKSHELF NAME                          *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'MSGSSHELF'\n         DC    CL64'@@MSGS@@'\n*\n***********************************************************************\n*                                                                     *\n*        FTP HOST NAME                                                *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'FTPHOST'\n         DC    CL64'KEM00-PC1'\n*\n***********************************************************************\n*                                                                     *\n*        FTP USER ID                                                  *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'FTPUSERID'\n         DC    CL64'BOOKMGR'\n*\n***********************************************************************\n*                                                                     *\n*        FTP USER PASSWORD                                            *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'FTPPASSWORD'\n         DC    CL64'UPLOAD'\n*\n***********************************************************************\n*                                                                     *\n*        FTP CDROM DRIVE LETTER                                       *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'FTPCDROM'\n         DC    CL64'M:'\n*\n***********************************************************************\n*                                                                     *\n*        UNIVERSAL SALES MANUAL LEVEL                                 *\n*                                                                     *\n***********************************************************************\n*\n         DC    CL16'USMLEVEL'\n         DC    CL64'&USMLVL'\n*\n         END   CCCBKDAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCCBKDEF": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x99!_\\x11R\\x02C\\x02\\x10\\x00P\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1999-08-03T11:52:00", "lines": 579, "newlines": 528, "modlines": 80, "user": "KEM00"}, "text": "BKDEF    TITLE 'TSO COMMAND TO RETURN BOOKMANAGER DEFINITION DATA'\n***********************************************************************\n*                                                                     *\n*        CCCBKDEF                                                     *\n*                                                                     *\n*        THIS PROGRAM IS A TSO COMMAND OR PROGRAM THAT IS DESIGNED    *\n*        TO RUN IN A CLIST OR REXX EXEC ONLY.  IT WILL RETURN A       *\n*        BOOKMANAGER DEFINITION VALUE IN A SPECIFIED CLIST/REXX       *\n*        VARIABLE NAME.                                               *\n*                                                                     *\n*        INPUT(1) TSO COMMAND PARAMETER LIST WITH TWO POSITIONAL      *\n*                 PARAMETERS - THE DEFINITION NAME AND THE            *\n*                 CLIST/REXX VARIABLE NAME.                           *\n*                                                                     *\n*        INPUT(2) CALLED PROGRAM PARAMETER LIST CONSISTING OF THE     *\n*                 DEFINITION KEY AND THE CLIST/REXX VARIABLE NAME     *\n*                 SEPARATED BY A COMMA.                               *\n*                                                                     *\n*        INPUT(3) TWO WORD PARAMETER LIST WITH THE FIRST WORD         *\n*                 BEING THE ADDRESS OF THE 16 CHARACTER DEFINITION    *\n*                 KEY (PADDED WITH BLANKS) AND THE SECOND WORD        *\n*                 BEING THE ADDRESS OF THE 64 BYTE RETURN AREA.       *\n*                                                                     *\n*        NOTE -   IN ORDER FOR THE PROGRAM TO DETECT THE VARIOUS      *\n*                 TYPES OF PARAMETER LIST, IT IS REQUIRED THAT THE    *\n*                 LAST PARAMETER BE FLAGGED WITH THE HIGH ORDER       *\n*                 BIT ON.                                             *\n*                                                                     *\n*        OUTPUT - SPECIFIED VALIABLE NAME SET TO THE APPROPRIATE      *\n*                 BOOKMANAGER VALUE OR RETURN CODE 4 IF THE           *\n*                 FIRST PARAMETER DOES NOT DEFINE A VALID             *\n*                 BOOKMANAGER DEFINITION VALUE.                       *\n*                                                                     *\n*                 FOR THE CASE WHERE CLIST/REXX VARIABLES ARE BEING   *\n*                 RETURNED, PASSING A DEFINITION NAME OF \"ALL\" WILL   *\n*                 CAUSE EVERY DEFINITION TO BE RETURNED AS            *\n*                 CLIST/REXX VARIABLES, USING THE DEFINITION NAME     *\n*                 AS THE CLIST/REXX VARIABLE NAME.                    *\n*                                                                     *\n*                 RETURN CODE 0 - VALID DEFINITION - VARIABLE SET     *\n*                 RETURN CODE 4 - INVALID DEFINITION VALUE            *\n*                 RETURN CODE 8 - NOT WITHIN A CLIST                  *\n*                 RETURN CODE 12 - SERIOUS ERROR IN PROGRAM           *\n*                 RETURN CODE 16 - UNABLE TO LOCATE DATA MODULE       *\n*                                                                     *\n*        THIS PROGRAM LOADS A DATA MODULE, CCCBKDAT, TO OBTAIN        *\n*        THE VALID DEFINITION KEYS AND THE CORRESPONDING DATA         *\n*        VALUES.                                                      *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, AMODE 31, RMODE ANY,    *\n*                     UNAUTHORIZED                                    *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\nCCCBKDEF CSECT\nCCCBKDEF AMODE 31\nCCCBKDEF RMODE ANY\n*\n         USING CCCBKDEF,R15\n         B     AROUNDID\n         DC    CL8'CCCBKDEF'\n         DC    CL8'V 1.2.1'\n         DC    CL8'&SYSDATE'\n         DC    CL8' &SYSTIME'\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n*\n         LR    R12,R15             LOAD REGISTER 12 WITH ENTRY\n         DROP  R15\n         USING CCCBKDEF,R12        ESTABLISH ADDRESSABILITY\n*\n         LR    R8,R1               LOAD REGISTER 8 TO PRESERVE PARMADDR\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         GETMAIN RU,LV=(0),LOC=(BELOW,ANY)\n         LR    R14,R1              COPY FOR THE MOVE LONG\n         LA    R15,WORKLENG        GET THE LENGTH\n         SLR   R3,R3\n         MVCL  R14,R2              CLEAR THE AREA\n*\n         ST    R13,4(,R1)          STORE ADDRESS OF PREVIOUS\n*\n         ST    R1,8(,R13)          STORE ADDRESS OF CURRENT\n*\n         LR    R13,R1              LOAD REGISTER 13 WITH SAVEAREA\n*\n         USING WORKAREA,R13        ESTABLISH ADDRESSABILITY\n*\n         MVI   MODEFLAG,0          INITIALIZE THE MODE FLAG\n*\n         MVI   VARINAME,C' '       BLANK OUT THE VARIABLE NAME BUF\n         MVC   VARINAME+1(L'VARINAME-1),VARINAME\n*\n         MVI   DEFNAME,C' '        BLANK OUT THE DEFINITION BUFFER\n         MVC   DEFNAME+1(L'DEFNAME-1),DEFNAME\n*\n         MVI   DATAFLD,C' '        PRE-BLANK OUT THE\n         MVC   DATAFLD+1(L'DATAFLD-1),DATAFLD RETURN DATA FIELD\n*\n         XC    RETCODE,RETCODE     ASSUME GOOD RETURN CODE\n*\n         TM    0(R8),X'80'         TEST FOR ONE WORD PARM LIST\n         BO    CALLPARM            IF SO, THIS IS A CALLED PARAMETER\n         TM    4(R8),X'80'         TEST FOR A TWO WORD PARAMETER LIST\n         BO    PGMPARM             IF SO, THIS IS A PROGRAM PARM\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARAMETER LIST                                   *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\nCMDPARM  DS    0H\n         OI    MODEFLAG,MODECMD    INDICATE WE HAVE A TSO CPPL\n*\n         USING CPPL,R8             ESTABLISH ADDRESSABILITY TO CPPL\n*\n         LA    R4,PPLSECT          LOAD ADDRESS OF PARSE PARAMETER\n         USING PPL,R4              ESTABLISH ADDRESSABILITY TO PPL\n*\n         L     R1,CPPLUPT          LOAD POINTER TO USER PROFILE\n         L     R2,CPPLECT          LOAD POINTER TO ENVIRONMENT\n*                                  CONTROL TABLE FROM CPPL\n         SLR   R3,R3               ZERO REGISTER 3\n         ST    R3,ECB              STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB              LOAD ADDRESS OF ECB\n         STM   R1,R3,PPLSECT       STORE ADDRESS OF UPT, ECT, AND\n*                                  ECB IN PPL\n         MVC   PPLPCL,PCLADDR      MOVE POINTER TO PARAMETER\n*                                  CONTROL LIST INTO PPL\n         LA    R2,PARSBACK         LOAD ADDRESS OF FULLWORD TO\n*                                  CONTAIN ADDRESS OF PDE RETURNED\n*                                  BY PARS\n         ST    R2,PPLANS           STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    MOVE POINTER TO COMMAND BUFFER\n*                                  INTO PPL\n         LA    R2,PPLUWA           LOAD ADDRESS OF USER WORK AREA\n         ST    R2,PPLUWA           STORE ADDRESS IN PPL\n         DROP  R4,R8               DROP ADDRESSABILITY\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT) CALL PARSE\n         LTR   R15,R15             SEE IF RETURN CODE IS ZERO\n         BNZ   BADPARSE            NO, BAD NEWS\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND PROCESS THE PARAMETERS                                *\n*                                                                     *\n***********************************************************************\n*\n         L     R9,PARSBACK         LOAD POINTER TO PARSE ANSWER\n         USING IKJPARMD,R9         ESTABLISH ADDRESSABILITY TO PDL\n*\n         LA    R6,DEFINIT          LOAD POINTER TO DEFINITION PDE\n         L     R5,0(R6)            LOAD POINTER TO DEFINITION DATA\n         LH    R4,4(R6)            LOAD LENGTH OF DEFINITION\n         BCTR  R4,0                DECREMENT LENGTH FOR EXECUTE OF MVC\n*\n         EX    R4,PARSDEF          MOVE IN THE DEFINITION\n*\n         LA    R6,VARIABLE         LOAD POINTER TO VARIABLE PDE\n         L     R5,0(R6)            LOAD POINTER TO VARIABLE DATA\n         LH    R4,4(R6)            LOAD LENGTH OF VARIABLE\n         ST    R4,NAMELENG         SAVE THIS LENGTH FOR SERVICE\n         BCTR  R4,0                DECREMENT LENGTH FOR EXECUTE OF MVS\n*\n         EX    R4,PARSVARI         MOVE IN THE VARIBALE NAME\n*\n         DROP  R9                  DROP ADDRESSABILITY TO PDL\n*\n         CLC   DEFNAME(4),=C'ALL ' CHECK FOR EVERYTHING WANTED\n         BNE   *+8                 BRANCH IF NOT\n         OI    MODEFLAG,MODEALL    INDICATE EVERYTHING WANTED\n*\n         B     LOOKUP              AND GO DECODE THE REQUEST\n*\nPARSDEF  MVC   DEFNAME(*-*),0(R5)  *** EXECUTE ONLY ***\nPARSVARI MVC   VARINAME(*-*),0(R5) *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROGRAM HAS BEEN INVOKED WITH A ONE WORD PARAMETER LIST      *\n*        IN THE FORMAT OF THE CALL/JCL PARAMETER.  SCAN FOR THE       *\n*        DEFINITION KEY AND RETURN VARIABLE NAME.                     *\n*                                                                     *\n***********************************************************************\n*\nCALLPARM DS    0H\n         OI    MODEFLAG,MODECALL   INDICATE WE HAVE A CALL PROGRAM PARM\n*\n         L     R2,0(,R8)           LOAD THE ADDRESS OF THE PARM STRING\n         LH    R3,0(,R2)           LOAD THE STRING LENGTH\n         LA    R2,2(,R2)           POINT AT ACTUAL FIRST CHARACTER\n*\n         CH    R3,=H'3'            CHECK MINIMUM LENGTH\n         BL    BADPARM             RETURN BAD NEWS IF TOO SMALL\n*\n         LR    R1,R2               SET SCAN POINTER\n*\nCALLLP1  DS    0H\n         CLI   0(R1),C','          LOOK FOR DELIMITER\n         BE    CALLCOMA            BRANCH WHEN FOUND\n         LA    R1,1(,R1)           INCREMENT SCAN POINTER\n         BCT   R3,CALLLP1          LOOP LOOKING FOR COMMA\n         B     BADPARM             IF NO COMMA, BAD NEWS\n*\nCALLCOMA DS    0H\n         LR    R15,R1              COPY FOR LENGTH CALCULATION\n         SR    R15,R2              CALCULATE LENGTH\n         BNH   BADPARM             LENGTH SHOULD BE POSITIVE\n         CH    R15,=Y(L'DEFNAME)   CHECK MAXIMUM LENGTH\n         BH    BADPARM             ERROR IF TOO BIG\n*\n         BCTR  R15,0               DECREMENT FOR MVC INSTRUCTION\n         EX    R15,CALLDEF         MOVE THE DEFINITION KEY\n*\n         LA    R1,1(,R1)           INCREMENT PAST THE COMMA\n         BCT   R3,*+8              DECREMENT THE COMMA\n         B     BADPARM             ERROR IF COMMA THE LAST THING\n*\n         CH    R3,=Y(L'VARINAME)   CHECK REMAINING LENGTH\n         BH    BADPARM             ERROR IF TOO BIG\n         ST    R3,NAMELENG         SAVE THIS LENGTH FOR SERVICE\n*\n         BCTR  R3,0                DECREMENT THE LENGTH FOR MVC\n         EX    R3,CALLVARI         MOVE THE VARIABLE NAME\n*\n         EX    R3,CALLTRT          SCAN FOR VALID CHARACTERS\n         BNZ   BADPARM             ERROR IF ANY BAD ONES\n*\n         CLI   VARINAME,C'0'       MAKE SURE THAT FIRST CHARACTER IS\n         BNL   BADPARM             NOT NUMERIC\n*\n         CLC   DEFNAME(4),=C'ALL ' CHECK FOR EVERYTHING WANTED\n         BNE   *+8                 BRANCH IF NOT\n         OI    MODEFLAG,MODEALL    INDICATE EVERYTHING WANTED\n*\n         B     LOOKUP              AND GO DECODE THE REQUEST\n*\nCALLDEF  MVC   DEFNAME(*-*),0(R2)  *** EXECUTE ONLY ***\nCALLVARI MVC   VARINAME(*-*),0(R1) *** EXECUTE ONLY ***\nCALLTRT  TRT   VARINAME(*-*),ALPHANUM   *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROGRAM HAS BEEN INVOKED WITH A TWO WORD PARAMETER LIST      *\n*        EXTRACT DEFINITION KEY NAME AND SAVE THE RETURN DATA         *\n*        ADDRESS.                                                     *\n*                                                                     *\n***********************************************************************\n*\nPGMPARM  DS    0H\n         OI    MODEFLAG,MODEPGM    INDICATE WE HAVE AN INTERNAL PROGRAM\n*\n         L     R1,0(,R8)           LOAD THE ADDRESS OF THE DEF KEY\n         MVC   DEFNAME,0(R1)       COPY THE DEFINITION KEY\n*\n         L     R1,4(,R8)           LOAD THE RETURN DATA ADDRESS\n         ST    R1,DATARETA         STORE THE RETURN DATA ADDRESS\n*\n         B     LOOKUP              AND GO DECODE THE REQUEST\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        LOOK UP DEFINITION NAME IN TABLE                             *\n*                                                                     *\n***********************************************************************\n*\nLOOKUP   DS    0H\n         LOAD  EPLOC=DATMODUL,ERRET=NODATA\n         OI    MODEFLAG,MODELOAD   INDICATE DATA MODULE LOADED\n*\n         LR    R10,R0              COPY THE ENTRY POINT\n         LR    R9,R1               COPY THE LENGTH\n         SLL   R9,3                CALCULATE MODULE'S ACTUAL LENGTH\n*\n         LA    R10,80(,R10)        BUMP PAST THE IDENTIFICATION ENTRY\n         SH    R9,=H'80'           ADJUST FOR THE IDENTIFICATION ENTRY\n*\nDEFLOOP  DS    0H\n         TM    MODEFLAG,MODEALL    CHECK FOR ALL VARIABLES (TSO/CALL)\n         BO    DEFFOUND            GO CREATE VARIABLE\n*\n         CLC   DEFNAME,0(R10)      MATCH THE NAME FIELD\n         BNE   DEFNEXT             BRANCH IF NO MATCH\n*\nDEFFOUND DS    0H\n         MVC   DATAFLD,16(R10)     COPY THE DATA VALUE\n*\n         TM    MODEFLAG,MODEALL    ARE WE IN ALL MODE\n         BZ    CRE8VARI            BRANCH IF NOT\n*\n         MVC   VARINAME(16),0(R10) COPY THE DATA NAME\n         MVI   VARINAME+16,C' '    BLANK THE REMAINDER\n         MVC   VARINAME+17(L'VARINAME-17),VARINAME+16\n*\n         LA    R1,VARINAME+15      SET TO LAST POSSIBLE CHARACTER\n         LA    R0,16               SET MAXIMUM LENGTH\n*\nDEFVARIL DS    0H\n         CLI   0(R1),C' '          DO WE HAVE A BLANK\n         BNE   DEFVARIF            BRANCH IF WE DON'T\n         BCTR  R1,0                DECREMENT ONE\n         BCT   R0,DEFVARIL         LOOP THROUGH THE VARIABLE NAME\n         DC    H'0'                DON'T EVEN THINK ABOUT IT!\n*\nDEFVARIF DS    0H\n         ST    R0,NAMELENG         STORE THE VARIBALE NAME LENGTH\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT THE PARAMETER LIST FOR IKJCT441                    *\n*                                                                     *\n***********************************************************************\n*\nCRE8VARI DS    0H\n         TM    MODEFLAG,MODEPGM    IS THIS A PROGRAM TO RETURN DATA TO\n         BZ    GODOVARI            IF NOT, GO CREATE THE VARIABLE\n*\n         L     R15,DATARETA        LOAD THE RETURN DATA ADDRESS\n         MVC   0(L'DATAFLD,R15),DATAFLD COPY THE RETURN DATA\n         B     RETURN\n*\nGODOVARI DS    0H\n         L     R3,CVTPTR           FIND CVT\n         USING CVTMAP,R3\n*\n         L     R3,CVTTVT           FIND THE TSVT\n         USING TSVT,R3\n*\n         LA    R0,TSVEUPDT\n         ST    R0,ENTRYCDE\n         LA    R0,ENTRYCDE\n         ST    R0,CT441PRM+0\n*\n         LA    R0,VARINAME\n         ST    R0,NAMEADDR\n         LA    R0,NAMEADDR\n         ST    R0,CT441PRM+4\n*\n         LA    R0,NAMELENG\n         ST    R0,CT441PRM+8\n*\n         LA    R0,DATAADDR\n         ST    R0,CT441PRM+12\n*\n         LA    R0,DATALENG\n         ST    R0,CT441PRM+16\n*\n         LA    R0,TOKENPRM\n         ST    R0,CT441PRM+20\n         OI    CT441PRM+20,X'80'\n*\n         LA    R1,DATAFLD\n         ST    R1,DATAADDR\n*\n         LA    R0,L'DATAFLD        LOAD LENGTH OF DATA AREA\n         AR    R1,R0               POINT PAST END OF STRING\n*\nCALCLOOP BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BH    CALCSTOR\n         BCT   R0,CALCLOOP\n*\n         LA    R0,1\n*\nCALCSTOR DS    0H\n         ST    R0,DATALENG\n*\n         LA    R1,CT441PRM         POINT AT PARM LIST\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BALR  R14,R15             GO CALL VARIABLE ROUTINE\n*\n         DROP  R3                  DONE WITH TSVT\n*\n         LTR   R15,R15             TEST IF RETURN WAS GOOD\n         BNZ   NOTCLIST            ASSUME WE AREN'T IN CLIST IF BAD\n*\n         TM    MODEFLAG,MODEALL    ARE WE IN ALL MODE\n         BZ    RETURN              IF NOTE, WE ARE DONE\n*\nDEFNEXT  DS    0H\n         LA    R10,80(,R10)        INCREMENT TO NEXT ENTRY\n         SH    R9,=H'80'           DECREMENT THE LENGTH\n         BP    DEFLOOP             LOOP IF MORE LEFT\n*\n         TM    MODEFLAG,MODEALL    ARE WE IN ALL MODE\n         BO    RETURN              IF SO, THIS IS OK\n         B     NOTFOUND            ERROR - DEFINITION KEY NOT FOUND\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ERROR CONDITIONS                                             *\n*                                                                     *\n***********************************************************************\n*\nNOTFOUND DS    0H\n         LA    R0,4                SET UNKNOWN DEFINITION KEY\n         ST    R0,RETCODE\n         B     RETURN\n*\nNOTCLIST DS    0H\n         LA    R0,8                SET WE AREN'T IN A CLIST ENV\n         ST    R0,RETCODE\n         B     RETURN\n*\nBADPARM  DS    0H\nBADPARSE LA    R0,12               SET SERIOUS ERROR\n         ST    R0,RETCODE\n         B     RETURN\n*\nNODATA   DS    0H\n         LA    R0,16               SET NO DATA MODULE FOUND\n         ST    R0,RETCODE\n         B     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARSE,                            *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         TM    MODEFLAG,MODELOAD   WAS THE DATA MODULE LOADED\n         BZ    NOTLOADD            BRANCH IF NOT\n         DELETE EPLOC=DATMODUL     CLEAN UP MODULE\n*\nNOTLOADD DS    0H\n         TM    MODEFLAG,MODECMD    IS THIS A TSO COMMAND\n         BZ    NOPARSEF            BRANCH IF NOT\n         IKJRLSA PARSBACK          RELEASE AREAS GETMAINED BY PARSE\n*\nNOPARSEF DS    0H\n         L     R2,RETCODE          LOAD THE RETURN CODE\n*\n         LR    R1,R13              LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)         RELOAD ADDRESS OF PREVIOUS SAVE\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN RU,LV=(0),A=(1)  FREE GETMAINED AREA\n*\n         LR    R15,R2              SET THE RETURN CODE\n         L     R14,12(,R13)        LOAD REGISTER 14 WITH RETURN\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\n*\n         EJECT\nPATCH    DC    0D'0',32S(*)\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\nDATMODUL DC    CL8'CCCBKDAT'       DATA DEFINITION MODULE NAME\n*\nLITERALS LTORG ,\n*\nPCLADDR  DC    V(PARMTAB)\n*\nALPHANUM DC    256X'FF'            ALPHANUMERIC TEST TABLE\n         ORG   ALPHANUM+C'$'\n         DC    X'00'\n         ORG   ALPHANUM+C'#'\n         DC    X'00'\n         ORG   ALPHANUM+C'@'\n         DC    X'00'\n         ORG   ALPHANUM+C'A'\n         DC    9X'00'\n         ORG   ALPHANUM+C'J'\n         DC    9X'00'\n         ORG   ALPHANUM+C'S'\n         DC    8X'00'\n         ORG   ALPHANUM+C'0'\n         DC    10X'00'\n         ORG   ,\n*\n         EJECT\n************************ PARS PARAMETER LIST **************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nPARMTAB  AMODE 31\nPARMTAB  RMODE ANY\n*\nDEFINIT  IKJIDENT 'DEFINITION',UPPERCASE,                              X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,MAXLNTH=16,               X\n               PROMPT='DEFINITION VALUE',                              X\n               HELP='BOOKMANAGER VARIABLE DEFINITION CODE'\n*\nVARIABLE IKJIDENT 'VARIBALE',UPPERCASE,                                X\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=32,                  X\n               PROMPT='VARIABLE NAME',                                 X\n               HELP='REXX/CLIST VARIABLE NAME'\n         IKJENDP\n*\n         EJECT\n************************ DSECTS (MAPPING MACROS) **********************\n         PRINT NOGEN\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n*\n         IKJPPL\nPPLLEN   EQU   *-PPL\n*\n         CVT   DSECT=YES\n*\n         IKJTSVT\n*\n*\n         PRINT GEN\n*\nWORKAREA DSECT\nSAVEAREA DS    9D\nRETCODE  DS    F\n*\n         DS    0D\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\n*\nECB      DS    F\nPARSBACK DS    F\n*\nCT441PRM DS    6F\n*\nENTRYCDE DS    F\nNAMEADDR DS    A                        ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                        LENGTH OF VARIABLE NAME\nDATAADDR DS    A                        ADDRESS OF VARIABLE DATA\nDATALENG DS    F                        LENGTH OF DATA\nTOKENPRM DS    F\n*\nVARINAME DS    CL32                     VARIABLE NAME FIELD\n*\nDATAFLD  DS    CL64                     RETURNED DATA FIELD\n*\nDEFNAME  DS    CL16                     REQUESTED DEFINITION NAME\n*\nDATARETA DS    A                        ADDRESS OF THE RETURN DATA\n*\nMODEFLAG DS    X                        PROGRAM MODE\nMODECMD  EQU   X'80'                    INVOKED AS A TSO COMMAND\nMODECALL EQU   X'40'                    INVOKED AS A CALLED PROGRAM\nMODEPGM  EQU   X'20'                    INVOKED AS AN INTERNAL CALL\nMODEALL  EQU   X'02'                    ALL VARIABLES WANTED (CALL/TSO)\nMODELOAD EQU   X'01'                    DATA MODULE HAS BEEN LOADED\n*\n         DS    0D\nWORKLENG EQU   *-WORKAREA\n*\n         END   CCCBKDEF\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCCBKDSN": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x99!_\\x11R\\x03\\x85\\x02\\xcc\\x00\\xd3\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1999-08-03T11:52:00", "lines": 901, "newlines": 716, "modlines": 211, "user": "KEM00"}, "text": "BKDSN    TITLE 'TSO COMMAND TO RETURN BOOKMANAGER DATA SET NAME'\n***********************************************************************\n*                                                                     *\n*        CCCBKDSN                                                     *\n*                                                                     *\n*        THIS PROGRAM IS A TSO COMMAND OR PROGRAM THAT IS DESIGNED    *\n*        TO RUN IN A CLIST OR REXX EXEC OR CALLED INTERNALLY.  IT     *\n*        WILL TAKE A A BOOKMANAGER NAME AND TYPE AND CONVERT THEN     *\n*        TO A FULLY QUALIFIED DATA SET NAME.  THE DATA IS             *\n*        RETURNED IN EITHER CLIST VARIABLES OR IN AN AREA POINTED     *\n*        TO BY THE PARAMETER LIST.                                    *\n*                                                                     *\n*        INPUT(1) TSO COMMAND PARAMETER LIST WITH THREE POSITIONAL    *\n*                 PARAMETERS - THE BOOKMANAGER NAME, THE              *\n*                 BOOKMANAGER TYPE, AND THE NAME OF THE RETURN        *\n*                 CLIST/REXX VARIABLE.                                *\n*                                                                     *\n*        INPUT(2) CALLED PROGRAM PARAMETER LIST CONSISTING OF THE     *\n*                 BOOKMANAGER NAME, BOOKMANAGER TYPE, AND THE         *\n*                 CLIST/REXX VARIABLE NAME SEPARATED BY COMMAS.       *\n*                                                                     *\n*        INPUT(3) THREE WORD PARAMETER LIST WITH THE FIRST WORD       *\n*                 BEING THE ADDRESS OF THE 8 CHARACTER BOOKMANAGER    *\n*                 NAME (PADDED WITH BLANKS), THE SECOND WORD BEING    *\n*                 THE ADDRESS OF THE 8 CHARACTER BOOKMANAGER TYPE,    *\n*                 AND THE THIRD WORD THE ADDRESS OF THE 44 BYTE       *\n*                 DATA SET NAME RETURN AREA.                          *\n*                                                                     *\n*        NOTE -   IN ORDER FOR THE PROGRAM TO DETECT THE VARIOUS      *\n*                 TYPES OF PARAMETER LIST, IT IS REQUIRED THAT THE    *\n*                 LAST PARAMETER BE FLAGGED WITH THE HIGH ORDER       *\n*                 BIT ON.                                             *\n*                                                                     *\n*        OUTPUT - SPECIFIED VALIABLE NAME OR AREA SET TO THE          *\n*                 BOOKMANAGER DATA SET NAME.                          *\n*                                                                     *\n*                 RETURN CODE 0 - VALID DATA SET - VARIABLE SET       *\n*                 RETURN CODE 8 - NOT WITHIN A CLIST                  *\n*                 RETURN CODE 12 - SERIOUS ERROR IN PROGRAM           *\n*                 RETURN CODE 16 - UNABLE TO LOCATE DEFINITION MODULE *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, AMODE 31, RMODE ANY,    *\n*                     UNAUTHORIZED                                    *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\nCCCBKDSN CSECT\nCCCBKDSN AMODE 31\nCCCBKDSN RMODE ANY\n*\n         USING CCCBKDSN,R15\n         B     AROUNDID\n         DC    CL8'CCCBKDSN'\n         DC    CL8'V 1.1.0'\n         DC    CL8'&SYSDATE'\n         DC    CL8' &SYSTIME'\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n*\n         LR    R12,R15             LOAD REGISTER 12 WITH ENTRY\n         DROP  R15\n         USING CCCBKDSN,R12        ESTABLISH ADDRESSABILITY\n*\n         LR    R8,R1               LOAD REGISTER 8 TO PRESERVE PARMADDR\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         GETMAIN RU,LV=(0),LOC=(BELOW,ANY)\n         LR    R14,R1              COPY FOR THE MOVE LONG\n         LA    R15,WORKLENG        GET THE LENGTH\n         SLR   R3,R3\n         MVCL  R14,R2              CLEAR THE AREA\n*\n         ST    R13,4(,R1)          STORE ADDRESS OF PREVIOUS\n*\n         ST    R1,8(,R13)          STORE ADDRESS OF CURRENT\n*\n         LR    R13,R1              LOAD REGISTER 13 WITH SAVEAREA\n*\n         USING WORKAREA,R13        ESTABLISH ADDRESSABILITY\n*\n         MVI   MODEFLAG,0          INITIALIZE THE MODE FLAG\n*\n         MVI   VARINAME,C' '       BLANK OUT THE VARIABLE NAME BUF\n         MVC   VARINAME+1(L'VARINAME-1),VARINAME\n*\n         MVI   BOOKNAME,C' '       PRE-BLANK OUT THE\n         MVC   BOOKNAME+1(L'BOOKNAME-1),BOOKNAME INPUT BOOKNAME\n*\n         MVI   BOOKTYPE,C' '       PRE-BLANK OUT THE\n         MVC   BOOKTYPE+1(L'BOOKTYPE-1),BOOKTYPE INPUT BOOK TYPE\n*\n         MVI   DATASETO,C' '       PRE-BLANK OUT THE\n         MVC   DATASETO+1(L'DATASETO-1),DATASETO RETURN DATA FIELD\n         MVI   DATASETX,X'FF'      SET A ONE TOO MANY FLAG\n*\n         MVC   USMVALUE,=CL8'NONE' INITIALIZE THE USM VALUE\n*\n         XC    RETCODE,RETCODE     ASSUME GOOD RETURN CODE\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        LOAD THE DEFINITION SUBROUTINE ADDRESS AND EXTRACT THE       *\n*        HIGH LEVEL AND SECOND LEVEL INDEX NAMES.                     *\n*                                                                     *\n***********************************************************************\n*\n         LOAD  EPLOC=DEFMODUL,ERRET=NODATA\n         ST    R0,DEFADDR          STORE THE DEFINE MODULE ADDRESS\n*\n         LA    R0,DATARETD         POINT AT RETURN DATA AREA\n         ST    R0,DEFPARMS+4       STORE IN PARM LIST\n         OI    DEFPARMS+4,X'80'    INDICATE END OF PARM LIST\n*\n         LA    R0,HLICODE          POINT AT HIGH LEVEL INDEX CODE WORD\n         ST    R0,DEFPARMS+0       STORE IN PARM LIST\n*\n         LA    R1,DEFPARMS         POINT AT PARAMETER LIST\n         L     R15,DEFADDR         LOAD THE DEFINITION ROUTINE ADDRESS\n         BASSM R14,R15             CALL THE DEFINITION MODULE\n*\n         LTR   R15,R15             CHECK IF HLI WAS SUCCESSFUL\n         BNZ   NODATA              THIS IS NOT VERY GOOD\n*\n         MVC   HLIVALUE,DATARETD   COPY THE RETURNED LEVEL\n*\n         LA    R0,SECCODE          POINT AT 2ND LEVEL INDEX CODE WORD\n         ST    R0,DEFPARMS+0       STORE IN PARM LIST\n*\n         LA    R1,DEFPARMS         POINT AT PARAMETER LIST\n         L     R15,DEFADDR         LOAD THE DEFINITION ROUTINE ADDRESS\n         BASSM R14,R15             CALL THE DEFINITION MODULE\n*\n         LTR   R15,R15             CHECK IF 2ND WAS SUCCESSFUL\n         BNZ   NODATA              THIS IS NOT VERY GOOD\n*\n         MVC   SECVALUE,DATARETD   COPY THE RETURNED LEVEL\n*\n         TM    0(R8),X'80'         TEST FOR ONE WORD PARM LIST\n         BO    CALLPARM            IF SO, THIS IS A CALLED PARAMETER\n         TM    8(R8),X'80'         TEST FOR A THREE WORD PARAMETER LIST\n         BO    PGMPARM             IF SO, THIS IS A PROGRAM PARM\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARAMETER LIST                                   *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\nCMDPARM  DS    0H\n         OI    MODEFLAG,MODECMD    INDICATE WE HAVE A TSO CPPL\n*\n         USING CPPL,R8             ESTABLISH ADDRESSABILITY TO CPPL\n*\n         LA    R4,PPLSECT          LOAD ADDRESS OF PARSE PARAMETER\n         USING PPL,R4              ESTABLISH ADDRESSABILITY TO PPL\n*\n         L     R1,CPPLUPT          LOAD POINTER TO USER PROFILE\n         L     R2,CPPLECT          LOAD POINTER TO ENVIRONMENT\n*                                  CONTROL TABLE FROM CPPL\n         SLR   R3,R3               ZERO REGISTER 3\n         ST    R3,ECB              STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB              LOAD ADDRESS OF ECB\n         STM   R1,R3,PPLSECT       STORE ADDRESS OF UPT, ECT, AND\n*                                  ECB IN PPL\n         MVC   PPLPCL,PCLADDR      MOVE POINTER TO PARAMETER\n*                                  CONTROL LIST INTO PPL\n         LA    R2,PARSBACK         LOAD ADDRESS OF FULLWORD TO\n*                                  CONTAIN ADDRESS OF PDE RETURNED\n*                                  BY PARS\n         ST    R2,PPLANS           STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    MOVE POINTER TO COMMAND BUFFER\n*                                  INTO PPL\n         LA    R2,PPLUWA           LOAD ADDRESS OF USER WORK AREA\n         ST    R2,PPLUWA           STORE ADDRESS IN PPL\n         DROP  R4,R8               DROP ADDRESSABILITY\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)\n         LTR   R15,R15             SEE IF RETURN CODE IS ZERO\n         BNZ   BADPARSE            NO, BAD NEWS\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND PROCESS THE PARAMETERS                                *\n*                                                                     *\n***********************************************************************\n*\n         L     R9,PARSBACK         LOAD POINTER TO PARSE ANSWER\n         USING IKJPARMD,R9         ESTABLISH ADDRESSABILITY TO PDL\n*\n         LA    R6,NAMEINPT         LOAD POINTER TO BOOKNAME PDE\n         L     R5,0(R6)            LOAD POINTER TO BOOKNAME DATA\n         LH    R4,4(R6)            LOAD LENGTH OF BOOKNAME DATA\n         BCTR  R4,0                DECREMENT LENGTH FOR EXECUTE OF MVC\n*\n         EX    R4,PARSNAME         MOVE IN THE BOOK NAME\n*\n         LA    R6,TYPEINPT         LOAD POINTER TO BOOKTYPE PDE\n         L     R5,0(R6)            LOAD POINTER TO BOOKTYPE DATA\n         LH    R4,4(R6)            LOAD LENGTH OF BOOKTYPE DATA\n         BCTR  R4,0                DECREMENT LENGTH FOR EXECUTE OF MVC\n*\n         EX    R4,PARSTYPE         MOVE IN THE BOOK TYPE\n*\n         LA    R6,VARIABLE         LOAD POINTER TO VARIABLE PDE\n         L     R5,0(R6)            LOAD POINTER TO VARIABLE DATA\n         LH    R4,4(R6)            LOAD LENGTH OF VARIABLE\n         ST    R4,NAMELENG         SAVE THIS LENGTH FOR SERVICE\n         BCTR  R4,0                DECREMENT LENGTH FOR EXECUTE OF MVC\n*\n         EX    R4,PARSVARI         MOVE IN THE VARIABLE NAME\n*\n         DROP  R9                  DROP ADDRESSABILITY TO PDL\n*\n         B     GETUSMLV            AND GO DECODE THE REQUEST\n*\nPARSNAME MVC   BOOKNAME(*-*),0(R5) *** EXECUTE ONLY ***\nPARSTYPE MVC   BOOKTYPE(*-*),0(R5) *** EXECUTE ONLY ***\nPARSVARI MVC   VARINAME(*-*),0(R5) *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROGRAM HAS BEEN INVOKED WITH A ONE WORD PARAMETER LIST      *\n*        IN THE FORMAT OF THE CALL/JCL PARAMETER.  SCAN FOR THE       *\n*        PUBLICATION NUMBER AND RETURN VARIABLE NAME.                 *\n*                                                                     *\n***********************************************************************\n*\nCALLPARM DS    0H\n         OI    MODEFLAG,MODECALL   INDICATE WE HAVE A CALL PROGRAM PARM\n*\n         L     R2,0(,R8)           LOAD THE ADDRESS OF THE PARM STRING\n         LH    R3,0(,R2)           LOAD THE STRING LENGTH\n         LA    R2,2(,R2)           POINT AT ACTUAL FIRST CHARACTER\n*\n         CH    R3,=H'5'            CHECK MINIMUM LENGTH\n         BL    BADPARM             RETURN BAD NEWS IF TOO SMALL\n*\n         LR    R1,R2               SET SCAN POINTER\n*\nCALLLP1  DS    0H\n         CLI   0(R1),C','          LOOK FOR DELIMITER\n         BE    CALLCOM1            BRANCH WHEN FOUND\n         LA    R1,1(,R1)           INCREMENT SCAN POINTER\n         BCT   R3,CALLLP1          LOOP LOOKING FOR COMMA\n         B     BADPARM             IF NOT COMMA, BAD NEWS\n*\nCALLCOM1 DS    0H\n         LR    R15,R1              COPY FOR LENGTH CALCULATION\n         SR    R15,R2              CALCULATE LENGTH\n         BNH   BADPARM             ERROR IF NOT POSITIVE\n         CH    R15,=Y(L'BOOKNAME)  CHECK MAXIMUM LENGTH\n         BH    BADPARM             ERROR IF TOO BIG\n*\n         BCTR  R15,0               DECREMENT FOR MVC INSTRUCTION\n         EX    R15,CALLNAME        MOVE THE BOOK NAME\n*\n         LA    R1,1(,R1)           INCREMENT PAST THE COMMA\n         BCT   R3,*+8              DECREMENT THE COMMA\n         B     BADPARM             ERROR IF COMMA THE LAST THING\n*\n         CH    R3,=H'3'            CHECK REMAINING MINIMUM LENGTH\n         BL    BADPARM             RETURN BAD NEWS IF TOO SMALL\n*\n         LR    R2,R1               SAVE SCAN POINTER\n*\nCALLLP2  DS    0H\n         CLI   0(R1),C','          LOOK FOR DELIMITER\n         BE    CALLCOM2            BRANCH WHEN FOUND\n         LA    R1,1(,R1)           INCREMENT SCAN POINTER\n         BCT   R3,CALLLP2          LOOP LOOKING FOR COMMA\n         B     BADPARM             IF NO COMMA, BAD NEWS\n*\nCALLCOM2 DS    0H\n         LR    R15,R1              COPY FOR LENGTH CALCULATION\n         SR    R15,R2              CALCULATE LENGTH\n         BNH   BADPARM             ERROR IF NOT POSITIVE\n         CH    R15,=Y(L'BOOKTYPE)  CHECK MAXIMUM LENGTH\n         BH    BADPARM             ERROR IF TOO BIG\n*\n         BCTR  R15,0               DECREMENT FOR MVC INSTRUCTION\n         EX    R15,CALLTYPE        MOVE THE BOOK TYPE\n*\n         LA    R1,1(,R1)           INCREMENT PAST THE COMMA\n         BCT   R3,*+8              DECREMENT THE COMMA\n         B     BADPARM             ERROR IF COMMA THE LAST THING\n*\n         CH    R3,=Y(L'VARINAME)   CHECK REMAINING LENGTH\n         BH    BADPARM             ERROR IF TOO BIG\n         ST    R3,NAMELENG         SAVE THIS LENGTH FOR SERVICE\n*\n         BCTR  R3,0                DECREMENT THE LENGTH FOR MVC\n         EX    R3,CALLVARI         MOVE THE VARIABLE NAME\n*\n         EX    R3,CALLTRT          SCAN FOR VALID CHARACTERS\n         BNZ   BADPARM             ERROR ID ANY BAD ONES\n*\n         CLI   VARINAME,C'0'       MAKE SURE THAT FIRST CHARACTER IS\n         BNL   BADPARM             NOT NUMERIC\n*\n         B     GETUSMLV            AND GO DECODE THE REQUEST\n*\nCALLNAME MVC   BOOKNAME(*-*),0(R2) *** EXECUTE ONLY ***\nCALLTYPE MVC   BOOKTYPE(*-*),0(R2) *** EXECUTE ONLY ***\nCALLVARI MVC   VARINAME(*-*),0(R1) *** EXECUTE ONLY ***\nCALLTRT  TRT   VARINAME(*-*),ALPHANUM   *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROGRAM HAS BEEN INVOKED WITH A THREE WORD PARAMETER LIST    *\n*        EXTRACT BOOK NAME AND TYPE AND SAVE THE RETURN DATA          *\n*        ADDRESS.                                                     *\n*                                                                     *\n***********************************************************************\n*\nPGMPARM  DS    0H\n         OI    MODEFLAG,MODEPGM    INDICATE WE HAVE AN INTERNAL PROGRAM\n*\n         L     R1,0(,R8)           LOAD THE ADDRESS OF THE BOOKNAME\n         MVC   BOOKNAME,0(R1)      COPY THE BOOKNAME\n*\n         L     R1,4(,R8)           LOAD THE ADDRESS OF THE BOOKTYPE\n         MVC   BOOKTYPE,0(R1)      COPY THE BOOKTYPE\n*\n         L     R1,8(,R8)           LOAD THE RETURN DATA ADDRESS\n         ST    R1,DATARETA         STORE THE RETURN DATA ADDRESS\n*\n         B     GETUSMLV            AND GO DECODE THE REQUEST\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DETERMINE IF THE BOOK IS PART OF THE UNIVERSAL SALES         *\n*        MANUAL SET.                                                  *\n*                                                                     *\n***********************************************************************\n*\nGETUSMLV DS    0H\n         CLC   BOOKTYPE,=CL8'BOOK' CHECK IF THIS IS A BOOK TYPE DSN\n         BE    GETUSMBK            BRANCH IF SO\n         CLC   BOOKTYPE,=CL8'BKSHELF'   CHECK FOR BOOKSHELF\n         BE    GETUSMIS            BRANCH IF SO\n         CLC   BOOKTYPE,=CL8'BKINDEX'   CHECK FOR BOOKSHELF INDEX\n         BE    GETUSMIS            BRANCH IF SO\n*\n         B     NOTUSMBK            IT'S NONE OF THESE\n*\n***********************************************************************\n*                                                                     *\n*        CHECK BOOKSHELF AND BOOKSHELF INDEX NAMES.  THESE MUST       *\n*        BE EXACT.                                                    *\n*                                                                     *\n***********************************************************************\n*\nGETUSMIS DS    0H\n         CLC   BOOKNAME,=CL8'HARDWARE'  CHECK FOR USM HARDWARE SHELF\n         BE    SETUSMHW            IF SO, GO SET IT\n         CLC   BOOKNAME,=CL8'WDNHARDW'  CHECK FOR USM WITHDRAWN HDW\n         BE    SETUSMHW            IF SO, GO SET IT\n         CLC   BOOKNAME,=CL8'SOFTWARE'  CHECK FOR USM SOFTWARE SHELF\n         BE    SETUSMSW            IF SO, GO SET IT\n         CLC   BOOKNAME,=CL8'WDNSOFTW'  CHECK FOR USM WITHDRAWN SFTW\n         BE    SETUSMSW            IF SO, GO SET IT\n         CLC   BOOKNAME,=CL8'PRICES'    CHECK FOR USM PRICES SHELF\n         BE    SETUSMPR            IF SO, GO SET IT\n*\n         B     NOTUSMBK            NONE OF THE ABOVE\n*\n***********************************************************************\n*                                                                     *\n*        CHECK BOOK NAMES.  THESE CONSIST OF KNOWN PREFIXES AND       *\n*        SUFFIXES OF KNOWN PATTERNS.                                  *\n*                                                                     *\n***********************************************************************\n*\nGETUSMBK DS    0H\n         CLC   BOOKNAME(5),=C'PRICE'    CHECK FOR THE USM PRICES MANUAL\n         BE    SETUSMPR            IF SO, GO SET IT\n*\n         CLC   BOOKNAME(2),=C'HW'  CHECK FOR THE USM HARDWARE MANUALS\n         BE    GETUSMHW            BRANCH IF SO\n         CLC   BOOKNAME(2),=C'SW'  CHECK FOR THE USM SOFTWARE MANUALS\n         BE    GETUSMSW            BRANCH IF SO\n         CLC   BOOKNAME(5),=C'WDNHW'    CHECK FOR USM WITHDRAWN HDW\n         BE    GETUSMWH            BRANCH IF SO\n         CLC   BOOKNAME(5),=C'WDNSW'    CHECK FOR USM WITHDRAWN SFTW\n         BE    GETUSMWS            BRANCH IF SO\n*\n         CLI   BOOKNAME,C'M'       CHECK FOR NEW HARDWARE MANUALS\n         BE    GETUSMHM            BRANCH IF SO\n         CLI   BOOKNAME,C'P'       CHECK FOR NEW SOFTWARE MANUALS\n         BE    GETUSMSP            BRANCH IF SO\n         CLI   BOOKNAME,C'S'       CHECK FOR NEW SOFTWARE MANUALS\n         BE    GETUSMSS            BRANCH IF SO\n*\n         B     NOTUSMBK            NOT A USM BOOK\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ORIGINAL USM HARDWARE BOOKS.                                 *\n*                                                                     *\n*        HW###, WHERE ### MUST BE NUMERIC, EXACTLY 5 CHARACTERS LONG  *\n*                                                                     *\n***********************************************************************\n*\nGETUSMHW DS    0H\n         TM    BOOKNAME+2,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+3,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+4,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         CLI   BOOKNAME+5,C' '     AND CHECK FOR EXACTLY 5 LONG\n         BNE   NOTUSMBK            IF NOT, IT'S NOT A USMER\n         B     SETUSMHW            SO SET USM\n*\n***********************************************************************\n*                                                                     *\n*        NEW (BUT HARDLY IMPROVED) USM HARDWARE MANUALS.              *\n*                                                                     *\n*        M##%%***, WHERE ## MUST BE NUMERIC AND *** OPTIONAL          *\n*                                                                     *\n***********************************************************************\n*\nGETUSMHM DS    0H\n         TM    BOOKNAME+1,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+2,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         B     SETUSMHW            SO SET USM\n*\n***********************************************************************\n*                                                                     *\n*        WITHDRAWN USM HARDWARE BOOKS.                                *\n*                                                                     *\n*        WDNHW###, WHERE ### MUST BE NUMERIC                          *\n*                                                                     *\n***********************************************************************\n*\nGETUSMWH DS    0H\n         TM    BOOKNAME+5,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+6,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+7,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         B     SETUSMHW            SO SET USM\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ORIGINAL USM SOFTWARE BOOKS.                                 *\n*                                                                     *\n*        SW###, WHERE ### MUST BE NUMERIC, EXACTLY 5 CHARACTERS LONG  *\n*                                                                     *\n***********************************************************************\n*\nGETUSMSW DS    0H\n         TM    BOOKNAME+2,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+3,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+4,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         CLI   BOOKNAME+5,C' '     AND CHECK FOR EXACTLY 5 LONG\n         BNE   NOTUSMBK            IF NOT, IT'S NOT A USMER\n         B     SETUSMSW            SO SET USM\n*\n***********************************************************************\n*                                                                     *\n*        NEW (BUT HARDLY IMPROVED) USM SOFTWARE MANUALS.              *\n*                                                                     *\n*        P##%%***, WHERE ## MUST BE NUMERIC AND *** OPTIONAL          *\n*        OR                                                           *\n*        S##%%***, WHERE ## MUST BE NUMERIC AND *** OPTIONAL          *\n*                                                                     *\n***********************************************************************\n*\nGETUSMSP DS    0H\nGETUSMSS DS    0H\n         TM    BOOKNAME+1,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+2,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         B     SETUSMSW            SO SET USM\n*\n***********************************************************************\n*                                                                     *\n*        WITHDRAWN USM SOFTWARE BOOKS.                                *\n*                                                                     *\n*        WDNSW###, WHERE ### MUST BE NUMERIC                          *\n*                                                                     *\n***********************************************************************\n*\nGETUSMWS DS    0H\n         TM    BOOKNAME+5,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+6,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         TM    BOOKNAME+7,X'F0'    TEST FOR A NUMERIC\n         BNO   NOTUSMBK            IF NOT, IT'S BAD\n         B     SETUSMSW            SO SET USM\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THE BOOK/BOOKSHELF/INDEX HAS BEEN IDENTIFIED AS A            *\n*        USM DATA SET.                                                *\n*                                                                     *\n***********************************************************************\n*\nSETUSMHW DS    0H\n         MVC   USMPREFX,USMPFXHW   SET THE USM HARDWARE PREFIX NAME\n         B     SETUSMBK            AND DO THE USM THING\n*\nSETUSMSW DS    0H\n         MVC   USMPREFX,USMPFXSW   SET THE USM SOFTWARE PREFIX NAME\n         B     SETUSMBK            AND DO THE USM THING\n*\nSETUSMPR DS    0H\n         MVC   USMPREFX,USMPFXPR   SET THE USM PRICES PREFIX NAME\n         B     SETUSMBK            AND DO THE USM THING\n*\nSETUSMBK DS    0H\n         OI    MODEFLAG,MODEUSM    INDICATE THAT THIS IS A USM BOOK\n*\n         LA    R0,USMCODE          POINT AT USMLEVEL CODE WORD\n         ST    R0,DEFPARMS+0       STORE IN PARM LIST\n*\n         LA    R1,DEFPARMS         POINT AT PARAMETER LIST\n         L     R15,DEFADDR         LOAD THE DEFINITION ROUTINE ADDRESS\n         BASSM R14,R15             CALL THE DEFINITION MODULE\n*\n         LTR   R15,R15             CHECK IF USMLEVEL WAS SUCCESSFUL\n         BNZ   NODATA              THIS IS NOT VERY GOOD\n*\n         MVC   USMVALUE,DATARETD   COPY THE RETURNED LEVEL\n*\nNOTUSMBK DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SCAN THE BOOK/INDEX/SHELF NAME FOR INVALID CHARACTERS        *\n*        AND REPLACE THEM WITH @.                                     *\n*                                                                     *\n***********************************************************************\n*\n         TR    BOOKNAME,REPLCECH    REPLACE BAD CHARACTERS\n*\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT THE DATA SET NAME FROM THE OBTAINED AND            *\n*        PASSED INFORMATION.                                          *\n*                                                                     *\n***********************************************************************\n*\n         MVC   DATASETO(L'HLIVALUE),HLIVALUE COPY THE HIGH LEVEL INDEX\n*\n         TRT   DATASETO(L'DATASETO+1),BLANKTRT SCAN FOR BLANK\n         CLI   0(R1),C' '           IS THIS REALLY A BLANK\n         BNE   BADDSN               THIS ISN'T VERY GOOD!\n*\n         MVI   0(R1),C'.'           SET THE DELIMITER\n*\n         MVC   1(L'SECVALUE,R1),SECVALUE COPY THE SECOND LEVEL INDEX\n*\n         TRT   DATASETO(L'DATASETO+1),BLANKTRT SCAN FOR BLANK\n         CLI   0(R1),C' '           IS THIS REALLY A BLANK\n         BNE   BADDSN               THIS ISN'T VERY GOOD!\n*\n         MVI   0(R1),C'.'           SET THE DELIMITER\n*\n         TM    MODEFLAG,MODEUSM     CHECK FOR THIS BEING A USM DATA SET\n         BZ    NOUSMBK              BRANCH IF NOT\n*\n         MVC   1(L'USMPREFX,R1),USMPREFX COPY THE USM PREFIX VALUE\n         MVC   1+L'USMPREFX(2,R1),USMVALUE COPY THE USM LEVEL\n*\n         TRT   DATASETO(L'DATASETO+1),BLANKTRT SCAN FOR BLANK\n         CLI   0(R1),C' '           IS THIS REALLY A BLANK\n         BNE   BADDSN               THIS ISN'T VERY GOOD!\n*\n         MVI   0(R1),C'.'           SET THE DELIMITER\n*\nNOUSMBK  DS    0H\n         MVC   1(L'BOOKNAME,R1),BOOKNAME COPY THE BOOK NAME FIELD\n*\n         TRT   DATASETO(L'DATASETO+1),BLANKTRT SCAN FOR BLANK\n         CLI   0(R1),C' '           IS THIS REALLY A BLANK\n         BNE   BADDSN               THIS ISN'T VERY GOOD!\n*\n         MVI   0(R1),C'.'           SET THE DELIMITER\n*\n         MVC   1(L'BOOKTYPE,R1),BOOKTYPE COPY THE BOOK TYPE FIELD\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT THE PARAMETER LIST FOR IKJCT441                    *\n*                                                                     *\n***********************************************************************\n*\nCRE8VARI DS    0H\n         TM    MODEFLAG,MODEPGM    IS THIS A PROGRAM TO RETURN DATA TO\n         BZ    GODOVARI            IF NOT, GO CREATE THE VARIABLE\n*\n         L     R15,DATARETA        LOAD THE RETURN DATA ADDRESS\n         MVC   0(L'DATASETO,R15),DATASETO COPY THE RETURN DATA\n         B     ALLDONE\n*\nGODOVARI DS    0H\n         L     R3,CVTPTR           FIND CVT\n         USING CVTMAP,R3\n*\n         L     R3,CVTTVT           FIND THE TSVT\n         USING TSVT,R3\n*\n         LA    R0,TSVEUPDT\n         ST    R0,ENTRYCDE\n         LA    R0,ENTRYCDE\n         ST    R0,CT441PRM+0\n*\n         LA    R0,VARINAME\n         ST    R0,NAMEADDR\n         LA    R0,NAMEADDR\n         ST    R0,CT441PRM+4\n*\n         LA    R0,NAMELENG\n         ST    R0,CT441PRM+8\n*\n         LA    R0,DATAADDR\n         ST    R0,CT441PRM+12\n*\n         LA    R0,DATALENG\n         ST    R0,CT441PRM+16\n*\n         LA    R0,TOKENPRM\n         ST    R0,CT441PRM+20\n         OI    CT441PRM+20,X'80'\n*\n         LA    R1,DATASETO\n         ST    R1,DATAADDR\n*\n         LA    R0,L'DATASETO       LOAD LENGTH OF DATA\n         AR    R1,R0               POINT PAST END OF STRING\n*\nCALCLOOP BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BH    CALCSTOR\n         BCT   R0,CALCLOOP\n*\n         LA    R0,1\n*\nCALCSTOR DS    0H\n         ST    R0,DATALENG         STORE DATA LENGTH\n*\n         LA    R1,CT441PRM         POINT AT PARM LIST\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BALR  R14,R15             GO CALL VARIABLE ROUTINE\n*\n         LTR   R15,R15             TEST IF RETURN WAS GOOD\n         BNZ   NOTCLIST            ASSUME WE AREN'T IN CLIST IF BAD\n*\nALLDONE  DS    0H\n         B     RETURN\n*\n         DROP  R3                  DONE WITH TSVT\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ERROR CONDITIONS                                             *\n*                                                                     *\n***********************************************************************\n*\nNOTCLIST LA    R0,8                SET WE AREN'T IN A CLIST ENV\n         ST    R0,RETCODE\n         B     RETURN\n*\nBADPARM  DS    0H\nBADDSN   DS    0H\nBADPARSE LA    R0,12               SET SERIOUS ERROR\n         ST    R0,RETCODE\n         B     RETURN\n*\nNODATA   LA    R0,16               SET NO DATA MODULE FOUND\n         ST    R0,RETCODE\n         B     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARSE,                            *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         TM    MODEFLAG,MODECMD    IS THIS A TSO COMMAND\n         BZ    NOPARSEF            BRANCH IF NOT\n         IKJRLSA PARSBACK          RELEASE AREAS GETMAINED BY PARSE\n*\nNOPARSEF DS    0H\n         DELETE EPLOC=DEFMODUL     DELETE THE DEFINITION MODULE\n*\n         L     R2,RETCODE          LOAD THE RETURN CODE\n*\n         LR    R1,R13              LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)         RELOAD ADDRESS OF PREVIOUS SAVE\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN RU,LV=(0),A=(1)  FREE GETMAINED AREA\n*\n         LR    R15,R2              SET THE RETURN CODE\n         L     R14,12(,R13)        LOAD REGISTER 14 WITH RETURN\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\n*\n         EJECT\nPATCH    DC    0D'0',32S(*)\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\nDEFMODUL DC    CL8'CCCBKDEF'       DATA INFORMATION PROGRAM\n*\nUSMCODE  DC    CL16'USMLEVEL'      USM LEVEL CODE WORD\nHLICODE  DC    CL16'HLI'           HIGH LEVEL INDEX CODE WORD\nSECCODE  DC    CL16'CD2ND'         2ND LEVEL INDEX CODE WORD\n*\n*        NOTE:  THE USMPFX.. FIELDS AND USMPREFX MUST ALL BE\n*        THE SAME LENGTH AND NOT EXCEED SIX CHARACTERS.\n*\nUSMPFXHW DC    C'USMHW'            USM HARDWARE PREFIX\nUSMPFXSW DC    C'USMSW'            USM SOFTWARE PREFIX\nUSMPFXPR DC    C'USMPR'            USM PRICES PREFIX\n*\nLITERALS LTORG ,\n*\nPCLADDR  DC    V(PARMTAB)\n*\nALPHANUM DC    256X'FF'            ALPHANUMERIC TEST TABLE\n         ORG   ALPHANUM+C'$'\n         DC    X'00'\n         ORG   ALPHANUM+C'#'\n         DC    X'00'\n         ORG   ALPHANUM+C'@'\n         DC    X'00'\n         ORG   ALPHANUM+C'A'\n         DC    9X'00'\n         ORG   ALPHANUM+C'J'\n         DC    9X'00'\n         ORG   ALPHANUM+C'S'\n         DC    8X'00'\n         ORG   ALPHANUM+C'0'\n         DC    10X'00'\n         ORG   ,\n*\nBLANKTRT DC    256X'00'            LOCATE BLANK TRT TABLE\n         ORG   BLANKTRT+C' '\n         DC    X'FF'               FLAG THE BLANK\n         ORG   BLANKTRT+X'FF'\n         DC    X'FF'               FLAG THE ENDING DELIMITER\n         ORG   ,\n*\nREPLCECH DC    256C'@'             ALL BAD CHARACTERS\n         ORG   REPLCECH+C' '       BLANK IS GOOD\n         DC    C' '\n         ORG   REPLCECH+C'$'       $ IS GOOD\n         DC    C'$'\n         ORG   REPLCECH+C'#'       # IS GOOD\n         DC    C'#'\n         ORG   REPLCECH+C'@'       @ IS GOOD\n         DC    C'@'\n         ORG   REPLCECH+C'A'       ALPHABET IS GOOD\n         DC    C'ABCDEFGHI'\n         ORG   REPLCECH+C'J'       ALPHABET IS GOOD\n         DC    C'JKLMNOPQR'\n         ORG   REPLCECH+C'S'       ALPHABET IS GOOD\n         DC    C'STUVWXYZ'\n         ORG   REPLCECH+C'0'       NUMBERS ARE GOOD\n         DC    C'0123456789'\n*\n         EJECT\n************************ PARS PARAMETER LIST **************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nPARMTAB  AMODE 31\nPARMTAB  RMODE ANY\n*\nNAMEINPT IKJIDENT 'BOOKNAME',UPPERCASE,                                X\n               FIRST=ALPHA,OTHER=ANY,MAXLNTH=8,                        X\n               PROMPT='BOOK NAME',                                     X\n               HELP='BOOKMANAGER DATA SET NAME'\n*\nTYPEINPT IKJIDENT 'BOOKTYPE',UPPERCASE,                                X\n               FIRST=ALPHA,OTHER=ANY,MAXLNTH=8,                        X\n               PROMPT='BOOK TYPE',                                     X\n               HELP='BOOKMANAGER DATA SET TYPE'\n*\nVARIABLE IKJIDENT 'VARIABLE',UPPERCASE,                                X\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=32,                  X\n               PROMPT='VARIABLE NAME',                                 X\n               HELP='REXX/CLIST VARIABLE NAME'\n         IKJENDP\n*\n         EJECT\n************************ DSECTS (MAPPING MACROS) **********************\n         PRINT NOGEN\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n*\n         IKJPPL\nPPLLEN   EQU   *-PPL\n*\n         CVT   DSECT=YES\n*\n         IKJTSVT\n*\n*\n         PRINT GEN\n*\nWORKAREA DSECT\nSAVEAREA DS    9D\nRETCODE  DS    F\n*\n         DS    0D\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\n*\nECB      DS    F\nPARSBACK DS    F\n*\nCT441PRM DS    6F\n*\nENTRYCDE DS    F\nNAMEADDR DS    A                   ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                   LENGTH OF VARIABLE NAME\nDATAADDR DS    A                   ADDRESS OF VARIABLE DATA\nDATALENG DS    F                   LENGTH OF DATA\nTOKENPRM DS    F\n*\nVARINAME DS    CL32                VARIABLE NAME FIELD\n*\nBOOKNAME DS    CL8                 INPUT PUBLICATION NUMBER\nBOOKTYPE DS    CL8                 INPUT PUBLICATION NUMBER\nDATASETO DS    CL44                RETURNED DATA FIELD\nDATASETX DS    C                   INDICATION WE HAVE GONE TOO FAR\n*\nHLIVALUE DS    CL8                 HIGH LEVEL INDEX VALUE\nSECVALUE DS    CL8                 SECOND LEVEL INDEX VALUE\nUSMVALUE DS    CL8                 VALUE FOR THE USM FIELD\n*\nUSMPREFX DS    CL5                 USM PREFIX SET\n*\nDEFADDR  DS    A                   DATA INFORMATION PROGRAM ADDRESS\n*\nDATARETA DS    A                   ADDRESS OF THE RETURN DATA\n*\nDEFPARMS DS    2A                  PARM LIST FOR DEFINITION MODULE\n*\nDATARETD DS    CL64                RETURNED DATA FROM DEFINITION SUB\n*\nMODEFLAG DS    X                   PROGRAM MODE\nMODECMD  EQU   X'80'               INVOKED AS A TSO COMMAND\nMODECALL EQU   X'40'               INVOKED AS A CALLED PROGRAM\nMODEPGM  EQU   X'20'               INVOKED AS AN INTERNAL CALL\nMODEUSM  EQU   X'01'               PUBLICATION IS PART OF THE USM\n*\n         DS    0D\nWORKLENG EQU   *-WORKAREA\n*\n         END   CCCBKDSN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCCBKEXT": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x97#\\x0f\\x01\\x00\\x04\\x7f\\tV\\x07\\x8e\\x076\\x00\\xd0\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1997-08-18T00:00:00", "modifydate": "2000-02-16T09:56:00", "lines": 1934, "newlines": 1846, "modlines": 208, "user": "KEM00"}, "text": "BKEXT    TITLE 'BOOKMANAGER INFORMATION DATA EXTRACT PROGRAM'\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER INFORMATION DATA EXTRACT PROGRAM                 *\n*                                                                     *\n*        PARAMETERS                                                   *\n*                                                                     *\n*        ACTIVE,BOOKSHELFLISTS                                        *\n*        VOLUME,BOOKSHELFLISTS                                        *\n*                                                                     *\n*        THE PARM FIELD IS A LIST OF ONE OR MORE BOOKMANAGER          *\n*        BOOKSHELF LIST DATA SETS, FULLY QUALIFIED WITHOUT            *\n*        APOSTROPHES.                                                 *\n*                                                                     *\n*        INFO,BOOKSHELFPDS                                            *\n*                                                                     *\n*        THE PARM FIELD IS A SINGLE PDS DATA SET NAME WHICH           *\n*        CONTAINS ONE OR MORE BOOKSHELVES AS MEMBERS.  THE DATA       *\n*        SET NAME IS FULLY QUALIFIED WITHOUT APOSTROPHES.             *\n*                                                                     *\n***********************************************************************\n*\n         PUNCH '         PAGE  CCCBKEXT'  MAKE DEBUGGING EASIER\n*\nCCCBKEXT CSECT\nCCCBKEXT AMODE 31\nCCCBKEXT RMODE 24\n*\n         USING CCCBKEXT,R15        INITIAL BASE REGISTER\n         B     AROUNDID\n         DC    CL8'CCCBKEXT'       MODULE ID\n         DC    CL8'V 1.5.1'        MODULE LEVEL\n         DC    CL8'&SYSDATC'\n         DC    CL8' &SYSTIME'\n*\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             SET THE BASE REGISTER\n         LA    R11,2048            PREP THE SECOND\n         LA    R11,2048(R11,R12)    BASE REGISTER\n         DROP  R15\n         USING CCCBKEXT,R12,R11\n*\n         L     R14,=A(SAVEAREA)    POINT AT NEW SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACK CHAIN\n         LR    R13,R14             SET NEW SAVE AREA\n         USING SAVEAREA,R13        PROVIDE ADDITIONAL ADDRESSABILITY\n*\n         LR    R2,R1               SAVE THE PARM FIELD ADDRESS\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        LOAD THE CELL POOL SUBROUTINE                                *\n*                                                                     *\n***********************************************************************\n*\n         LOAD  EPLOC=CPSNAME,ERRET=LOADERR0 LOAD THE CELL POOL ROUTINE\n         ST    R0,CPSADDR\n*\n***********************************************************************\n*                                                                     *\n*        EXTRACT THE PARM FIELD TO CREATE THE INITIAL LIST            *\n*        OF BOOKSHELF LIST DATA SET NAMES.                            *\n*                                                                     *\n***********************************************************************\n*\n         L     R2,0(,R2)           LOAD FIRST PARM ADDRESS\n         LH    R3,0(,R2)           LOAD THE PARM LENGTH\n         LTR   R3,R3               TEST THE PARM LENGTH\n         BZ    PARMINVL            IF NONE, PARM IS INVALID\n         LA    R2,2(,R2)           INCREMENT PAST THE LENGTH FIELD\n*\n         CH    R3,=H'6'            CHECK MINIMUM LENGTH THAT'S VALID\n         BL    PARMINVL            ERROR IF TOO SMALL\n         CLC   0(5,R2),=C'INFO,'   IS THE PARM INFO\n         BNE   PARMNINF            BRANCH IF NOT\n*\n         OI    PROCFLAG,PROCINFO   INDICATE INFO PROCESSING\n         LA    R2,5(,R2)           INCREMENT PAST THE INFO PARM\n         SH    R3,=H'5'            DECREMENT THE LENGTH LEFT\n*\n         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME AREA\n         LA    R1,DSNHOLD          POINT AT START OF DSN\n         LA    R15,DSNHOLD+44      POINT AT END OF DSN\n*\nPARMINFM DS    0H\n         CR    R1,R15              HAVE WE GONE TOO FAR\n         BE    PARMERR1            BAD NEWS IF WE HAVE\n*\n         MVC   0(1,R1),0(R2)       MOVE ONE DSNAME CHARACTER\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHARACTER\n         LA    R2,1(,R2)           INCREMENT TO NEXT CHARACTER\n         BCT   R3,PARMINFM         GO MOVE THE NEXT CHARACTER\n*\n         B     PARMDONE            AND WE HAVE ONLY ONE DATA SET NAME\n*\nPARMNINF DS    0H\n         CH    R3,=H'8'            CHECK THIS MINIMUM LENGTH\n         BL    PARMINVL            STILL BAD ....\n         CLC   0(7,R2),=C'ACTIVE,' CHECK FOR ACTIVE DATA SETS\n         BE    PARMACTV            BRANCH IF ACTIVE\n         CLC   0(7,R2),=C'VOLUME,' CHECK FOR ALTERNATE ACTIVE\n         BNE   PARMNACT            BRANCH IF NOT ACTIVE\n*\n         OI    PROCFLAG,PROCVOL    INDICATE VOLUME PROCESSING AS WELL\n*\nPARMACTV DS    0H\n         OI    PROCFLAG,PROCACTV   INDICATE ACTIVE PROCESSING\n         LA    R2,7(,R2)           INCREMENT PAST THE ACTIVE PARM\n         SH    R3,=H'7'            DECREMENT THE LENGTH LEFT\n*\nPARMACTL DS    0H\n         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME AREA\n         LA    R1,DSNHOLD          POINT AT START OF DSN\n         LA    R15,DSNHOLD+44      POINT AT END OF DSN\n*\nPARMACTM DS    0H\n         CLI   0(R2),C','          IS THIS A DELIMITER\n         BE    PARMACTE            IF SO, THIS IS THE END OF THE DSN\n         CR    R1,R15              HAVE WE GONE TOO FAR\n         BE    PARMERR1            BAD NEWS IF WE HAVE\n*\n         MVC   0(1,R1),0(R2)       MOVE ONE DSNAME CHARACTER\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHARACTER\n         LA    R2,1(,R2)           INCREMENT TO NEXT CHARACTER\n         BCT   R3,PARMACTM         GO MOVE THE NEXT CHARACTER\n*\nPARMACTE DS    0H\n         LA    R0,48               SIZE OF STORAGE\n         LA    R1,BKLBLOCK         POINT AT CELL POOL BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET STORAGE BLOCK\n         LR    R1,R15              COPY ADDRESS\n         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER\n         MVC   4(44,R1),DSNHOLD    COPY THE DATA SET NAME\n*\n         LA    R15,BKLFIRST        POINT AT FIRST ANCHOR WORD\n*\nPARMADDL DS    0H\n         ICM   R14,15,0(R15)       LOAD THE CHAIN POINTER\n         BZ    PARMADDC            BRANCH IF WE'RE AT THE END\n         LR    R15,R14             CHAIN AWAY\n         B     PARMADDL            AND CONTINUE LOOKING\n*\nPARMADDC DS    0H\n         ST    R1,0(,R15)          ADD TO THE DATA SET NAME CHAIN\n*\n         LA    R0,1                LOAD 1\n         A     R0,BKLCOUNT         ADD OLD COUNT\n         ST    R0,BKLCOUNT         STORE NEW COUNT\n*\n         LTR   R3,R3               DID WE REACH THE END\n         BZ    PARMDONE            BRANCH IF SO\n         LA    R2,1(,R2)           SKIP THE COMMA\n         BCT   R3,PARMACTL         AND LOOP THROUGH THE PARM\n*\n         B     PARMDONE            AND WE BE DONE\n*\nPARMNACT DS    0H\n         B     PARMINVL            NOT A NICE THING TO HAPPEN\n*\nPARMDONE DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        LOAD THE PUBLICATION NUMBER ROUTINE                          *\n*                                                                     *\n***********************************************************************\n*\n         LOAD  EPLOC=PUBNONAM,ERRET=LOADERR1 LOAD PUB NUMBER SUBROUTINE\n         ST    R0,PUBNOADR\n*\n***********************************************************************\n*                                                                     *\n*        LOAD THE DATA SET NAME ROUTINE                               *\n*                                                                     *\n***********************************************************************\n*\n         LOAD  EPLOC=DSNSUB,ERRET=LOADERR2 LOAD DATA SET NAME SUBR\n         ST    R0,DSNADDR\n*\n***********************************************************************\n*                                                                     *\n*        LOAD THE DATA TABLE                                          *\n*                                                                     *\n***********************************************************************\n*\n         LOAD  EPLOC=DATTBL,ERRET=LOADERR3 LOAD DATA TABLE\n*\n***********************************************************************\n*                                                                     *\n*        LOAD THE DEFINITION ROUTINE                                  *\n*                                                                     *\n***********************************************************************\n*\n         LOAD  EPLOC=DEFSUB,ERRET=LOADERR4 LOAD DATA TABLE\n*\n*\n***********************************************************************\n*                                                                     *\n*        GET THE CURRENT DATE IN YYYY/MM/DD FORMAT.                   *\n*                                                                     *\n***********************************************************************\n*\n         TIME  DEC\n         ST    R1,THEDATE          STORE TODAY'S DATE\n         AP    THEDATE,=P'1900000' CORRECT THE CENTURY\n*\n         TM    THEDATE+1,X'01'     TEST FOR ODD YEAR\n         BO    DONTLEAP            BRANCH IF SO\n         TM    THEDATE+1,X'12'     TEST FOR FOR MULTIPLE OF 4\n         BM    DONTLEAP            BRANCH IF NOT\n         AP    DAYSFEB,=P'1'       ADJUST THE CALENDAR\n*\nDONTLEAP DS    0H\n         UNPK  DOUBLE(5),THEDATE(3)     GET THE CHARACTER YEAR\n         MVC   TODAYYYY,DOUBLE     CAPTURE THE YEAR\n         XC    THEDATE(2),THEDATE  KILL THE YEAR\n*\n         LA    R14,DAYSOOL         POINT AT LIST OF MONTHS\n         LA    R15,1               COUNT THE MONTHS\n*\nMONTHLP  DS    0H\n         SP    THEDATE,0(L'DAYSOOL,R14) DECREMENT THE DAYS\n         BNP   MONTHGOT            BRANCH WHEN ZERO OR NEGATIVE\n         LA    R15,1(,R15)         INCREMENT THE MONTH\n         LA    R14,L'DAYSOOL(,R14) INCREMENT THE MONTH POINTER\n         B     MONTHLP             AND TRY AGAIN\n*\nMONTHGOT DS    0H\n         AP    THEDATE,0(L'DAYSOOL,R14) PUT THIS MONTH'S DAYS BACK\n         OI    THEDATE+3,X'0F'     FIX THE DAY SIGN\n         UNPK  TODAYDD,THEDATE+2(2)     STORE THE DAYS OF OUR MONTHS\n         CVD   R15,DOUBLE          GET THE MONTH NUMBER OR SOMETHING\n         OI    DOUBLE+7,X'0F'      FIX THE MONTH SIGN\n         UNPK  TODAYMM,DOUBLE+6(2) STORE THE MONTH OF OUR YEARS\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        IF WE ARE IN INFORMATION MODE, ALLOCATE THE BOOKSHELF        *\n*        PDS AND EXTRACT ALL OF THE MEMBER NAMES.                     *\n*                                                                     *\n***********************************************************************\n*\n         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE\n         BZ    NOINFOML            BRANCH IF NOT\n*\n         LA    R1,DSNHOLD          POINT AT DATA SET NAME\n         BAL   R8,ALLOCDSN         ALLOCATE THE BOOKSHELF PDS\n*\n         LTR   R1,R1               DO WE HAVE A DDNAME RETURNED\n         BZ    BKSPALOC            IF NOT, WE HAVE A BIG PROBLEM\n*\n         MVC   DCBDDNAM-IHADCB+BKSDIRCT,0(R1) COPY THE DDNAME\n         MVC   DCBDDNAM-IHADCB+BKSHELF,0(R1) COPY THE DDNAME\n*\n         OPEN  (BKSDIRCT,(INPUT))  OPEN THE BOOKSHELF PDS\n         LTR   R15,R15             TEST FOR ANY OPEN ERRORS\n         BNZ   BKSPDSER            BAD IF ANY ERRORS\n*\n         LA    R4,BKSFIRST         POINT AT FIRST CHAIN POINTER\n*\nPDSDREAD DS    0H\n         GET   BKSDIRCT            READ ONE DIRECTORY BLOCK\n         LR    R2,R1               COPY THIS BLOCK ADDRESS\n*\n         LH    R3,0(,R2)           LOAD THE USED SPACE\n         LTR   R3,R3               IS IT USED AT ALL\n         BZ    PDSDREAD            SKIP BLOCK IF NOT\n         LA    R2,2(,R2)           INCREMENT TO FIRST ENTRY\n         SH    R3,=H'2'            SUBTRACT OVERHEAD\n         BNP   PDSDREAD            GO READ ANOTHER BLOCK IF EMPTY\n*\nPDSDMEML DS    0H\n         CLC   0(8,R2),=8X'FF'     ARE WE AT THE END\n         BE    BKSEODIR            IF SO, PRETEND END OF DATA\n*\n         TM    11(R2),X'80'        IS THIS AN ALIAS MEMBER\n         BO    PDSDMEMN            SKIP IT IF SO\n*\n         LA    R0,16               SIZE OF STORAGE\n         LA    R1,MEMBLOCK         POINT AT CELL POOL BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET STORAGE BLOCK\n         LR    R1,R15              COPY ADDRESS\n         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER\n         MVC   4(8,R1),0(R2)       COPY THE MEMBER NAME\n*\n         ST    R1,0(,R4)           CHAIN ONTO THE PREVIOUS MEMBER NAME\n         LR    R4,R1               UPDATE THE CURRENT CHAIN POINTER\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,BKSCOUNT         ADD PREVIOUS COUNT\n         ST    R0,BKSCOUNT         STORE UPDATED COUNT\n*\nPDSDMEMN DS    0H\n         IC    R15,11(,R2)         LOAD THE DATA COUNT\n         N     R15,=X'0000007F'    CLEAR THE ALIAS BIT (IF ANY)\n         LA    R15,12(,R15)        DOUBLE IT AND ADD OVERHEAD\n*\n         AR    R2,R15              INCREMENT TO NEXT MEMBER NAME\n         SR    R3,R15              DECREMENT LENGTH LEFT\n         BP    PDSDMEML            GO GET NEXT MEMBER IF MORE LEFT\n         B     PDSDREAD            GO GET NEXT DIRECTORY BLOCK IF NOT\n*\nBKSEODIR DS    0H\n         CLOSE (BKSDIRCT)          CLOSE THE DIRECTORY READER\n         FREEPOOL BKSDIRCT         FREE THE BUFFER STORAGE\n*\n         RDJFCB (BKSHELF)          READ THE JFCB FOR THE BOOKSHELF PDS\n*\n         OI    JFCBTSDM-JFCB+BKSJFCB,JFCNWRIT INDICATE NO WRITE BACK\n         OI    JFCBIND1-JFCB+BKSJFCB,JFCPDS INDICATE PDS MEMBER\n*\nNOINFOML DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SCAN THE BOOKSHELF LIST DATA SET NAMES AND BUILD A LIST      *\n*        OF ALL UNIQUE BOOKSHELVES.                                   *\n*                                                                     *\n***********************************************************************\n*\n         TM    PROCFLAG,PROCINFO   TEST IF WE ARE IN INFORMATION MODE\n         BO    BKLISTND            IF SO, DON'T PROCESS BOOKSHELF LIST\n*\n         L     R2,BKLFIRST         POINT AT FIRST BOOKSHELF LIST\n*\nBKLLOOP1 DS    0H\n         CLI   4(R2),C'*'          HAS THE DATA SET BEEN EXCLUDED\n         BE    BKLNEXT             IF SO, SKIP IT\n*\n         LA    R1,4(,R2)           POINT AT DATA SET NAME\n         BAL   R8,ALLOCDSN         ALLOCATE THE BOOKSHELF\n*\n         LTR   R1,R1               DO WE HAVE A DDNAME RETURNED\n         BZ    BKLALOCE            IF NOT, ALLOCATION FAILED\n*\n         MVC   DCBDDNAM-IHADCB+BKLSHELF,0(R1) COPY THE DDNAME\n*\n         OPEN  (BKLSHELF,(INPUT))  OPEN THE BOOKSHELF LIST\n         LTR   R15,R15             TEST FOR ANY OPEN ERRORS\n         BNZ   BKLOPENE            BAD IF ANY ERRORS\n*\n***********************************************************************\n*                                                                     *\n*        MAIN READ LOOP FOR SCANNING ONE BOOKSHELF LIST               *\n*                                                                     *\n***********************************************************************\n*\nBKLREAD1 DS    0H\n         GET   BKLSHELF            READ ONE BOOKSHELF LIST RECORD\n         LA    R3,4(,R1)           COPY THE RECORD ADDRESS\n         LH    R4,0(,R1)           LOAD THE RECORD LENGTH\n         SH    R4,=H'4'            ELIMINATE THE RDW\n         BZ    BKLREAD1            SKIP A NULL RECORD\n*\n         CLI   0(R3),C'*'          CHECK FOR A COMMENT STATEMENT\n         BE    BKLREAD1            SKIP IT IF SO\n*\nBKLEADBL DS    0H\n         CLI   0(R3),C' '          SKIP ANY LEADING BLANKS\n         BNE   BKLSCANV            GO SCAN FOR VERB WHEN PASSED\n         LA    R3,1(,R3)           INCREMENT POINTER\n         BCT   R4,BKLEADBL         CONTINUE SCAN FOR BLANKS\n         B     BKLREAD1            SKIP THIS RECORD IF NULL\n*\nBKLSCANV DS    0H\n         LR    R15,R3              COPY STARTING ADDRESS\n*\nBKLSCAN1 DS    0H\n         CLI   0(R15),C' '         SCAN UNTIL WE FIND A BLANK\n         BE    BKLVERB\n         LA    R15,1(,R15)         POINT TO NEXT CHARACTER\n         BCT   R4,BKLSCAN1         SCAN THROUGH THE STRING\n         B     BKLREAD1            REACH THE END HERE AND WE FORGET IT\n*\n***********************************************************************\n*                                                                     *\n*        EXTRACT THE BOOKSHELF LIST VERB                              *\n*                                                                     *\n*        ALL WE ARE INTERESTED IN ARE \"SHELF\", \"INCLUDE\", AND         *\n*        \"XINCLUDE\".                                                  *\n*                                                                     *\n***********************************************************************\n*\nBKLVERB  LR    R14,R15             COPY BLANK ADDRESS\n         SR    R14,R3              GET LENGTH OF VERB\n         BCTR  R14,0               DECREMENT FOR OC\n         EX    R14,BKLOCVRB        UPPER CASE THE VERB\n         LA    R14,1(,R14)         RESTORE THE LENGTH\n*\n         CH    R14,=H'5'           CHECK THE LENGTH FOR 5\n         BL    BKLREAD1            SKIP IF TOO LOW\n         BH    BKLVERB1            BRANCH IF TOO HIGH\n*\n         CLC   0(5,R3),=C'SHELF'   IS THIS A SHELF STATEMENT\n         BNE   BKLREAD1            SHIP IT IF NOT\n         MVI   VERBTYPE,C'S'       SET THE VERB TYPE\n         B     BKLVERBN            AND WE ARE DONE WITH THE VERB\n*\nBKLVERB1 DS    0H\n         CH    R14,=H'7'           CHECK FOR LENGTH OF 7\n         BL    BKLREAD1            SKIP IT IF TOO LOW\n         BH    BKLVERB2            BRANCH IF TOO HIGH\n*\n         CLC   0(7,R3),=C'INCLUDE' CHECK FOR INCLUDE\n         BNE   BKLREAD1            WE AREN'T INTERESTED IN ANY OTHERS\n         MVI   VERBTYPE,C'I'       SET THE VERB TYPE\n         B     BKLVERBN            AND CONTINUE ON\n*\nBKLVERB2 DS    0H\n         CH    R14,=H'8'           CHECK FOR LENGTH OF 8\n         BNE   BKLREAD1            SKIP IF NOT 8\n*\n         CLC   0(8,R3),=C'XINCLUDE'     CHECK FOR INCLUDE\n         BNE   BKLREAD1            WE AREN'T INTERESTED IN ANY OTHERS\n         MVI   VERBTYPE,C'X'       SET THE VERB TYPE\n         B     BKLVERBN            AND CONTINUE ON\n*\nBKLVERBN DS    0H\n         LTR   R4,R4               IS THERE ANYTHING LEFT\n         BZ    BKLREAD1            FORGET RECORD IF NOT\n*\n***********************************************************************\n*                                                                     *\n*        NOW THAT WE HAVE AN INTERESTING VERB, EXTRACT THE DATA       *\n*        SET NAME.  FOR \"INCLUDE\" AND \"XINCLUDE\", THE DATA SET        *\n*        NAME IS THE FIRST PARAMETER.  FOR \"SHELF\", IT IS THE         *\n*        SECOND PARAMETER AND THE FIRST PARAMETER IS THE BOOKSHELF    *\n*        NAME DISPLAYED BY BOOKMANAGER, WHICH WE AREN'T INTERESTED    *\n*        IN (AT THIS TIME).                                           *\n*                                                                     *\n***********************************************************************\n*\nBKLPARM0 DS    0H\n         CLI   0(R15),C' '         NOW LET'S FIND ANOTHER NON-BLANK\n         BNE   BKLPARM1            BRANCH WHEN WE GET IT\n         LA    R15,1(,R15)         INCREMENT POINTER\n         BCT   R4,BKLPARM0         SCAN THROUGH THE STATEMENT\n         B     BKLREAD1            SKIP STATEMENT IF NO PARMS\n*\nBKLPARM1 DS    0H\n         LR    R3,R15              SAVE THIS PARM STARTING ADDRESS\n*\nBKLPARM2 DS    0H\n         CLI   0(R15),C' '         NOW WE LOOK FOR A BLANK\n         BE    BKLPARM3            BRANCH WHEN WE FIND ONE\n         LA    R15,1(,R15)         INCREMENT POINTER\n         BCT   R4,BKLPARM2         LOOP THROUGH THIS PARAMETER\n*\nBKLPARM3 DS    0H\n         LR    R14,R15             COPY THE ENDING ADDRESS\n         SR    R14,R3              CALCULATE THE LENGTH\n*\n         CH    R14,=H'44'          CHECK FOR MAXIMUM LENGTH\n         BH    BKLREAD1            SKIP THE RECORD IF TOO BIG\n*\n         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME HOLDER\n         BCTR  R14,0               DECREMENT FOR THE MVC\n         EX    R14,BKLMVCP1        MOVE THE FIRST PARAMETER\n*\n         CLI   VERBTYPE,C'S'       IS THIS A SHELF VERB\n         BNE   BKLHVDSN            IF NOT, WE HAVE\n*\n         CH    R14,=H'7'           CHECK IF THIS IS A VALID BKSNAME\n         BH    BKLREAD1            SKIP IT IF NOT\n*\n         MVC   BKSHOLD,DSNHOLD     COPY THE SHELF NAME\n         OC    BKSHOLD,BLANKS      UPPER CASE IT JUST IN CASE\n*\n         LTR   R4,R4               DO WE HAVE ANYTHING LEFT\n         BZ    BKLREAD1            SKIP STATEMENT IF NOT\n*\nBKLPARM4 DS    0H\n         CLI   0(R15),C' '         NOW LET'S FIND ANOTHER NON-BLANK\n         BNE   BKLPARM5            BRANCH WHEN WE GET IT\n         LA    R15,1(,R15)         INCREMENT POINTER\n         BCT   R4,BKLPARM4         SCAN THROUGH THE STATEMENT\n         B     BKLREAD1            SKIP STATEMENT IF NO PARMS\n*\nBKLPARM5 DS    0H\n         LR    R3,R15              SAVE THIS PARM STARTING ADDRESS\n*\nBKLPARM6 DS    0H\n         CLI   0(R15),C' '         NOW WE LOOK FOR A BLANK\n         BE    BKLPARM7            BRANCH WHEN WE FIND ONE\n         LA    R15,1(,R15)         INCREMENT POINTER\n         BCT   R4,BKLPARM6         LOOP THROUGH THIS PARAMETER\n*\nBKLPARM7 DS    0H\n         LR    R14,R15             COPY THE ENDING ADDRESS\n         SR    R14,R3              CALCULATE THE LENGTH\n*\n         CH    R14,=H'44'          CHECK FOR MAXIMUM LENGTH\n         BH    BKLREAD1            SKIP THE RECORD IF TOO BIG\n*\n         MVC   DSNHOLD,BLANKS      BLANK THE DATA SET NAME HOLDER\n         BCTR  R14,0               DECREMENT FOR THE MVC\n         EX    R14,BKLMVCP1        MOVE THE FIRST PARAMETER\n*\nBKLHVDSN DS    0H\n         OC    DSNHOLD,BLANKS      UPPER CASE THE DATA SET NAME\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FOR \"XINCLUDE\", WE FIND THE DATA SET NAME IN THE CURRENT     *\n*        BOOKSHELF LIST DATA SET NAME LIST AND SPLAT IT OUT TO        *\n*        CAUSE IT TO BE IGNORED.  NO ERROR IS NOTED IF THE            *\n*        BOOKSHELF LIST DATA SET NAME IS NOT FOUND.                   *\n*                                                                     *\n***********************************************************************\n*\n         CLI   VERBTYPE,C'X'       IS THIS AN EXCLUDE FUNCTION\n         BNE   BKLNOTEX            BRANCH IF NOT\n*\n         L     R15,0(,R2)          LOOK FORWARD ON THE BOOKSHELF LIST\nBKLEXCLL LTR   R15,R15             DO WE HAVE ANY BOOKSHELF LISTS LEFT?\n         BZ    BKLREAD1            IF NOT, SKIP FURTHER PROCESSING\n*\n         CLC   DSNHOLD,4(R15)      MATCH DSNAMES\n         BE    BKLEXCLD            IF MATCH, GO EXCLUDE IT\n         L     R15,0(,R15)         GET THE NEXT BOOKSHELF LIST ENTRY\n         B     BKLEXCLL            AND TRY AGAIN\n*\nBKLEXCLD DS    0H\n         MVI   4(R15),C'*'         EXCLUDE THIS DATA SET\n         B     BKLREAD1            AND GET THE NEXT RECORD\n*\n***********************************************************************\n*                                                                     *\n*        FOR \"INCLUDE\", WE ADD THE DATA SET NAME TO THE BOOKSHELF     *\n*        LIST DATA SET NAME LIST, PROVIDED IT ISN'T ALREADY THERE.    *\n*                                                                     *\n***********************************************************************\n*\nBKLNOTEX DS    0H\n         CLI   VERBTYPE,C'I'       IS THIS AN INCLUDER\n         BNE   BKLNOTIN            BRANCH IF NOT\n*\n         L     R3,BKLFIRST         POINT AT FIRST BOOKSHELF LIST\n*\nBKLINCLL DS    0H\n         CLC   DSNHOLD,4(R3)       DO WE ALREAD HAVE THE BOOKSHELF LIST\n         BE    BKLREAD1            IF SO, SKIP ADDING IT\n*\n         ICM   R15,15,0(R3)        CHAIN TO NEXT BOOKSHELF LIST\n         BZ    BKLINCLA            IF AT THE END, GO ADD IT\n         LR    R3,R15              COPY ADDRESS\n         B     BKLINCLL            AND CHECK NEXT BOOKSHELF LIST\n*\nBKLINCLA DS    0H\n         LA    R0,48               SIZE OF STORAGE\n         LA    R1,BKLBLOCK         POINT AT CELL POOL BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET STORAGE BLOCK\n         LR    R1,R15              COPY ADDRESS\n         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER\n         MVC   4(44,R1),DSNHOLD    COPY THE DATA SET NAME\n*\n         ST    R1,0(,R3)           ADD ON TO BOOKSHELF LIST CHAIN\n*\n         LA    R0,1                LOAD 1\n         A     R0,BKLCOUNT         ADD OLD COUNT\n         ST    R0,BKLCOUNT         STORE NEW COUNT\n*\n         B     BKLREAD1            AND GO READ NEXT RECORD\n*\n***********************************************************************\n*                                                                     *\n*        FOR \"SHELF\", WE ADD THE DATA SET NAME TO THE BOOKSHELF       *\n*        DATA SET NAME LIST, PROVIDED IT ISN'T ALREADY THERE.         *\n*                                                                     *\n***********************************************************************\n*\nBKLNOTIN DS    0H                  IT MUST BE A BOOKSHELF DATA SET\n         LA    R3,BKSFIRST         POINT AT BOOKSHELF DSNAME ANCHOR\n*\nBKLBKSLP DS    0H\n         ICM   R15,15,0(R3)        GET NEXT BOOKSHELF DSNAME\n         BZ    BKLBKSND            IF ZERO, WE ARE AT THE END\n*\n         CLC   DSNHOLD,4(R15)      MATCH THE BOOKSHELF DSNAMES\n         BE    BKLREAD1            IF WE ALREADY HAVE IT, SKIP IT\n*\n         LR    R3,R15              COPY THE ADDRESS FOR CHAINING\n         B     BKLBKSLP            AND GO CHECK THE NEXT ONE\n*\nBKLBKSND DS    0H\n         LA    R0,56               SIZE OF STORAGE\n         LA    R1,BKSBLOCK         POINT AT CELL POOL BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET STORAGE BLOCK\n         LR    R1,R15              COPY ADDRESS\n         XC    0(4,R1),0(R1)       CLEAR THE CHAIN POINTER\n         MVC   4(44,R1),DSNHOLD    COPY THE DATA SET NAME\n         MVC   48(8,R1),BKSHOLD    COPY THE BOOKSHELF NAME\n*\n         ST    R1,0(,R3)           ADD ON TO BOOKSHELF LIST CHAIN\n*\n         LA    R0,1                LOAD 1\n         A     R0,BKSCOUNT         ADD OLD COUNT\n         ST    R0,BKSCOUNT         STORE NEW COUNT\n*\n         B     BKLREAD1            AND GO READ NEXT RECORD\n*\nBKLMVCP1 MVC   DSNHOLD(*-*),0(R3)  *** EXECUTE ONLY ***\nBKLOCVRB OC    0(*-*,R3),BLANKS    *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        END OF DATA FOR A BOOKSHELF LIST DATA SET                    *\n*                                                                     *\n***********************************************************************\n*\nBKLEOD   DS    0H\n         CLOSE (BKLSHELF,FREE)     CLOSE AND FREE THIS BOOKSHELF LIST\n         FREEPOOL BKLSHELF         FREE THE BUFFER POOL\n*\nBKLNEXT  DS    0H\n         ICM   R2,15,0(R2)         CHAIN TO THE NEXT BOOKSHELF LIST\n         BNZ   BKLLOOP1            LOOP IF WE AREN'T DONE\n*\nBKLISTND DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        OPEN THE OUTPUT INFORMATION DATA SET                         *\n*                                                                     *\n***********************************************************************\n*\n         OPEN  (INFOFILE,(OUTPUT)) OPEN THE OUTPUT FILE\n         LTR   R15,R15             TEST FOR ANY OPEN ERRORS\n         BNZ   INFOPENE            BAD IF ANY ERRORS\n*\n***********************************************************************\n*                                                                     *\n*        SCAN EACH BOOKSHELF DATA SET TO EXTRACT THE DETAILED         *\n*        BOOK, BOOKSHELF, AND BOOKSHELF INDEX INFORMATION.            *\n*                                                                     *\n***********************************************************************\n*\n         L     R2,BKSFIRST         POINT AT FIRST BOOKSHELF DATA SET\n*\nBKSLOOP1 DS    0H\n         MVC   BKSID,ALLSTARS      INITIAL ALL\n         MVC   BKINAME,ALLSTARS     OF THE\n         MVC   BKSTITLL,=H'8'        VARIOUS\n         MVC   BKSTITLE(8),ALLSTARS   DATA\n         MVC   BKSBDATE,STARDATE       FIELDS\n         MVC   BKSBTIME,STARTIME        THAT WE\n         MVC   BKIBDATE,STARDATE         COLLECT\n         MVC   BKIBTIME,STARTIME          FOR EVERY\n         MVC   BKIDSN,ALLSTARS             BOOKSHELF\n         MVC   BKSDSN,ALLSTARS              *\n         MVC   BKSLNAME,ALLSTARS             *\n*\n         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE\n         BO    BKSINFO1            IF SO, GO DO THE MEMBER THING\n*\n         MVC   BKSDSN,4(R2)        SAVE THE BOOKSHELF DSNAME\n         MVC   BKSLNAME,48(R2)     SAVE THE BOOKSHELF LIST SHELF NAME\n*\n         LA    R15,BKSDSN+36       POINT AT LAST POSSSIBLE \".BKSHELF\"\n         LA    R0,37               MAXIMUM LENGTH TO SCAN\n*\nBKSSCAN1 DS    0H\n         CLC   0(8,R15),=C'.BKSHELF'    FIND END OF DATA SET NAME\n         BE    BKSSHLF1            BRANCH IF FOUND\n         BCTR  R15,0               SET BACKWARDS IN THE DATA SET NAME\n         BCT   R0,BKSSCAN1         SCAN THE DATA SET NAME\n         B     BKSNEXT             IF THIS ISN'T A BOOKSHELF, SKIP IT\n*\nBKSSHLF1 DS    0H\n         LR    R14,R15             SAVE THIS POSITION\nBKSSHLF2 DS    0H\n         BCTR  R15,0               BACK UP ONE MORE\n         CLI   0(R15),C'.'         LOOK FOR PREVIOUS PERIOD\n         BE    BKSSHLF3            BRANCH WHEN FOUND\n         BCT   R0,BKSSHLF2         BACKTRACK THROUGH THE DATA SET NAME\n         B     BKSNEXT             IF WE RUN OUT, CONSIDER IT INVALID\n*\nBKSSHLF3 DS    0H\n         CLC   0(4,R15),=C'.LVL'   DETERMINE IF THIS IS JUST THE\n         BNE   BKSSHLFN            LVL** QUALIFIER\n         TM    4(R15),X'F0'        CHECK FOR NUMERIC\n         BNO   BKSSHLFN            IF NOT, NOT LVL**\n         TM    5(R15),X'F0'        CHECK FOR NUMERIC\n         BNO   BKSSHLFN            IF NOT, NOT LVL**\n         CLI   6(R15),C'.'         CHECK FOR EXACTLY 2 PLACES AFTER LVL\n         BNE   BKSSHLFN            IF NOT, NOT LVL**\n*\n         B     BKSSHLF1            LET'S GO BACK ONE MORE QUALIFIER\n*\nBKSSHLFN DS    0H\n         SR    R14,R15             CALCULATE LENGTH OF BOOKSHELF NAME\n         BCTR  R14,0               SUBTRACT 1 TO GET TRUE LENGTH\n         BCTR  R14,0               SUBTRACT 1 MORE FOR MVS INSTRUCTION\n*\n         MVC   BKSNAME,BLANKS      PRE BLANK THE FIELD\n         EX    R14,BKSMVCID        MOVE THE BOOKSHELF NAME FROM DSN\n*\n         LA    R1,4(,R2)           POINT AT DATA SET NAME\n         BAL   R8,ALLOCDSN         ALLOCATE THE BOOKSHELF\n*\n         LTR   R1,R1               DO WE HAVE A DDNAME RETURNED\n         BZ    BKSALOCE            IF NOT, WE CAN'T ALLOCATE - IS BAD\n*\n         MVC   DCBDDNAM-IHADCB+BKSHELF,0(R1) COPY THE DDNAME\n*\n         OPEN  (BKSHELF,(INPUT))   OPEN THE BOOKSHELF DATA SET\n         LTR   R15,R15             TEST FOR ANY OPEN ERRORS\n         BNZ   BKSOPENE            BAD IF ANY ERRORS\n*\n         B     BKSREAD1            GO PROCESS THIS BOOKSHELF DATA SET\n*\nBKSMVCID MVC   BKSNAME(*-*),1(R15) *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        OPEN THE BOOKSHELF DATA SET TO THE CURRENT MEMBER NAME       *\n*                                                                     *\n***********************************************************************\n*\nBKSINFO1 DS    0H\n         MVC   JFCBELNM-JFCB+BKSJFCB,4(R2) COPY THE MEMBER NAME\n*\n         MVC   BKSNAME,4(R2)       SET THE CURRENT BOOKSHELF NAME\n*\n         OPEN  (BKSHELF,(INPUT)),TYPE=J OPEN THE SPECIFIC PDS MEMBER\n         LTR   R15,R15             TEST FOR ANY OPEN ERRORS\n         BNZ   BKSOPENE            BAD IF ANY ERRORS\n*\n         B     BKSREAD1            AND GO SCAN THIS MEMBER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        MAIN READ LOOP FOR SCANNING ONE BOOKSHELF DATA SET           *\n*                                                                     *\n***********************************************************************\n*\nBKSREAD1 DS    0H\n         BAL   R8,BKSBKSRD         READ ONE BOOKSHELF LIST RECORD\n         LTR   R1,R1               DID WE HIT END OF DATA\n         BZ    BKSISBAD            THIS IS AN INVALID BOOKSHELF\n*\n         LR    R3,R1               SAVE THE RECORD ADDRESS\n         LR    R4,R0               SAVE THE RECORD LENGTH\n*\n         CLC   0(2,R1),=C'SH'      CHECK FOR FIRST BOOK HEADER\n         BE    BKSHDEND            IF SO, WE ARE DONE COLLECTING HEADER\n*\n***********************************************************************\n*                                                                     *\n*        COLLECT BOOKSHELF HEADER INFORMATION                         *\n*                                                                     *\n***********************************************************************\n*\n         BAL   R8,BKSEQUAL         SCAN FOR AN EQUAL SIGN\n         LTR   R15,R15             DID WE FIND ONE\n         BZ    BKSREAD1            SKIP THIS RECORD IF NOT FOUND\n*\n         LR    R14,R15             COPY THE EQUAL SIGN ADDRESS\n         SR    R14,R1              CALCULATE LENGTH OF KEYWORD\n*\n         CH    R14,=H'7'           CHECK LENGTH\n         BNE   BKSNBKSH            BRANCH IF IT CAN'T BE\n         CLC   0(7,R1),=C'BKSHELF' IS THIS BKSHELF=\n         BNE   BKSNBKSH            BRANCH IF IT ISN'T\n*\n         MVC   BKSID,BLANKS        BLANK IT OUT\n         SH    R0,=H'9'            CALCULATE LENGTH FOR MVC\n         LR    R14,R0              MOVE FOR USE BY EXECUTE\n         EX    R14,BKSMVCNM        MOVE THE BOOKSHELF NAME\n*\n         B     BKSREAD1            GO GET THE NEXT RECORD\n*\nBKSMVCNM MVC   BKSID(*-*),1(R15) *** EXECUTE ONLY ***\n*\nBKSNBKSH DS    0H\n         CH    R14,=H'8'           CHECK LENGTH\n         BNE   BKSNBKST            BRANCH IF IT CAN'T BE\n         CLC   0(8,R1),=C'BKSTITLE'     IS THIS BKSTITLE=\n         BNE   BKSNBKST            BRANCH IF IT ISN'T\n*\n         SH    R0,=H'9'            CALCULATE LENGTH OF TITLE\n         BNP   BKSREAD1            SKIP THIS IF TITLE IS NULL\n*\nBKSTITBL DS    0H\n         CLI   1(R15),C' '         DO WE HAVE A LEADING BLANK\n         BNE   BKSTITNB            BRANCH IF NOT\n         LA    R15,1(,R15)         INCREMENT PAST ANY LEADING BLANKS\n         BCT   R0,BKSTITBL         LOOP THROUGH LEADING BLANKS\n         B     BKSREAD1            TITLE IS ALL BLANKS\n*\nBKSTITNB DS    0H\n         LR    R14,R0              MOVE FOR USE BY EXECUTE\n         CH    R14,=Y(L'BKSTITLE)  CHECK FOR MAXIMUM LENGTH\n         BNH   *+10                BRANCH IF WITHIN SPEC\n         LA    R14,L'BKSTITLE      LOAD THE MAXIMUM LENGTH\n         LR    R0,R14              COPY THIS LENGTH\n*\n         BCTR  R14,0               DECREMENT FOR USE BY MVC\n         EX    R14,BKSMVCBT        MOVE THE BOOKSHELF TITLE\n         STH   R0,BKSTITLL         STORE THE TITLE LENGTH\n*\n         B     BKSREAD1            GO GET THE NEXT RECORD\n*\nBKSMVCBT MVC   BKSTITLE(*-*),1(R15)     *** EXECUTE ONLY ***\n*\nBKSNBKST DS    0H\n         CH    R14,=H'8'           CHECK LENGTH\n         BNE   BKSNBKIN            BRANCH IF IT CAN'T BE\n         CLC   0(8,R1),=C'BKSINDEX'     IS THIS BKSINDEX=\n         BNE   BKSNBKIN            BRANCH IF IT ISN'T\n*\n         MVC   BKINAME,BLANKS      BLANK IT OUT\n         SH    R0,=H'10'           CALCULATE LENGTH FOR MVC\n         BL    BKSREAD1            IF IT GOES NEGATIVE, THERE IS NONE\n         LR    R14,R0              MOVE FOR USE BY EXECUTE\n         EX    R14,BKSMVCIN        MOVE THE BOOKSHELF INDEX NAME\n*\n         B     BKSREAD1            GO GET THE NEXT RECORD\n*\nBKSMVCIN MVC   BKINAME(*-*),1(R15) *** EXECUTE ONLY ***\n*\nBKSNBKIN DS    0H\n         CH    R14,=H'8'           CHECK LENGTH\n         BNE   BKSNBKDI            BRANCH IF IT CAN'T BE\n         CLC   0(8,R1),=C'BKSIMDSN'     IS THIS BKSIMDSN=\n         BNE   BKSNBKDI            BRANCH IF IT ISN'T\n*\n         MVC   BKIDSN,BLANKS       BLANK IT OUT\n         SH    R0,=H'10'           CALCULATE LENGTH FOR MVC\n         LR    R14,R0              MOVE FOR USE BY EXECUTE\n         EX    R14,BKSMVCDI        MOVE THE BOOKSHELF INDEX DSNAME\n*\n         B     BKSREAD1            GO GET THE NEXT RECORD\n*\nBKSMVCDI MVC   BKIDSN(*-*),1(R15)  *** EXECUTE ONLY ***\n*\nBKSNBKDI DS    0H\n         CH    R14,=H'11'          CHECK LENGTH\n         BNE   BKSNBKSD            BRANCH IF IT CAN'T BE\n         CLC   0(11,R1),=C'BKSDATETIME'  IS THIS BKSDATETIME=\n         BNE   BKSNBKSD            BRANCH IF IT ISN'T\n*\n         LA    R14,0(R3,R4)        ADD REC ADDR & LENGTH\n         LA    R1,BKSBDATE         POINT AT DATE FIELD\n         LA    R0,BKSBTIME         POINT AT TIME FIELD\n         BAL   R8,BKSMVDTE         GO CONVERT THE DATE AND TIME\n*\n         B     BKSREAD1            GO GET THE NEXT RECORD\n*\nBKSNBKSD DS    0H\n         CH    R14,=H'11'          CHECK LENGTH\n         BNE   BKSNBKID            BRANCH IF IT CAN'T BE\n         CLC   0(11,R1),=C'BKIDATETIME'  IS THIS BKIDATETIME=\n         BNE   BKSNBKID            BRANCH IF IT ISN'T\n*\n         LA    R14,0(R3,R4)        ADD REC ADDR & LENGTH\n         LA    R1,BKIBDATE         POINT AT DATE FIELD\n         LA    R0,BKIBTIME         POINT AT TIME FIELD\n         BAL   R8,BKSMVDTE         GO CONVERT THE DATE AND TIME\n*\n         B     BKSREAD1            GO GET THE NEXT RECORD\n*\nBKSNBKID DS    0H\n         B     BKSREAD1            GO GET THE NEXT RECORD\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THE FIRST BOOK HEADER RECORD (SH) HAS BEEN READ, SO          *\n*        CONSTRUCT THE RECORDS FOR THE BOOKSHELF AND INDEX.           *\n*                                                                     *\n***********************************************************************\n*\nBKSHDEND DS    0H\n         CLI   BKSDSN,C'*'         DO WE HAVE A DATA SET NAME\n         BH    BKSHHDSN            BRANCH IF WE DO\n*\n         MVC   DSNNAME,BKSNAME     BOOKSHELF NAME (GENERIC)\n         MVC   DSNTYPE,=CL8'BKSHELF'\n         LA    R1,DSNPARMS         POINT AT THE PARM LIST\n         L     R15,DSNADDR         LOAD THE SUBROUTINE ADDRESS\n         BASSM R14,R15             GO CONVERT THE DATA SET NAME\n*\n         LTR   R15,R15             TEST FOR SUCCESSFUL CONVERSION\n         BNZ   BADDSN              BRANCH IF NO GOOD\n*\n         MVC   BKSDSN,DSNDSN       COPY RETURNED DATA SET NAME\n*\nBKSHHDSN DS    0H\n         LA    R1,BKSDSN           POINT AT BOOKSHELF DATA SET NAME\n         BAL   R8,INFOSTAT         GO DETERMINE THE BOOKSHELF DS STATUS\n*\n         BAL   R8,INFOINIT         INITIALIZE THE ACTIVE RECORD\n*\n         USING BKNDSECT,INFOWORK   ESTABLISH EXTRACT AREA MAPPING\n*\n         MVC   BKNNAME,BKSNAME     COPY THE GENERIC BOOKSHELF NAME\n         MVC   BKNTYPE,=CL8'BKSHELF'    SET THAT THIS IS A BOOKSHELF\n*\n         MVC   BKNBKDTE,BKSBDATE   COPY THE BOOKSHELF BUILD DATE\n         MVC   BKNBKTIM,BKSBTIME   COPY THE BOOKSHELF BUILD TIME\n*\n         MVC   BKNSTAT,0(R1)       COPY STATUS RETURNED EARLIER\n*\n         MVC   BKNBKSID,BKSID      COPY THE BOOKSHELF NAME (ESOTERIC)\n*\n         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE\n         BO    BKSHNMIS            IF SO, DON'T SCREW WITH THE STATUS\n*\n         CLC   BKSID,BKSLNAME      CHECK THE INTERNAL TO EXTERNAL NAME\n         BE    BKSHNMIS            BRANCH IF IT MATCHES\n         MVC   BKNSTAT,=C'MISMATCH'     INDICATE A NAME MISMATCH\nBKSHNMIS DS    0H\n*\n         MVC   BKNDSNME,BKSDSN     COPY THE BOOKSHELF DATA SET NAME\n*\n         LA    R1,BKSTITLL         POINT AT BOOKSHELF TITLE\n         BAL   R8,INFOTITL         GO COPY THE TITLE\n*\n         BAL   R8,INFOWRIT         WRITE OUT THE ACTIVE RECORD\n*\n         CLI   BKINAME,C' '        IS THE INDEX NAME NULL\n         BNE   *+10                BRANCH IF NOT\n         MVC   BKINAME,BKSNAME     COPY THE BOOKSHELF NAME IF NULL\n*\n         CLI   BKIDSN,C'*'         DO WE HAVE A DATA SET NAME\n         BH    BKSIHDSN            BRANCH IF WE DO\n*\n         MVC   DSNNAME,BKINAME     BOOKSHELF INDEX NAME\n         MVC   DSNTYPE,=CL8'BKINDEX'\n         LA    R1,DSNPARMS         POINT AT THE PARM LIST\n         L     R15,DSNADDR         LOAD THE SUBROUTINE ADDRESS\n         BASSM R14,R15             GO CONVERT THE DATA SET NAME\n*\n         LTR   R15,R15             TEST FOR SUCCESSFUL CONVERSION\n         BNZ   BADDSN              BRANCH IF NO GOOD\n*\n         MVC   BKIDSN,DSNDSN       COPY RETURNED DATA SET NAME\n*\nBKSIHDSN DS    0H\n         LA    R1,BKIDSN           POINT AT BOOKSHELF INDEX DSN\n         BAL   R8,INFOSTAT         GO DETERMINE THE BOOKSHELF INDEX ST\n*\n         BAL   R8,INFOINIT         INITIALIZE THE ACTIVE RECORD\n*\n         MVC   BKNNAME,BKINAME     COPY THE BOOKSHELF INDEX NAME\n         MVC   BKNTYPE,=CL8'BKINDEX'    SET THAT THIS IS AN INDEX\n*\n         MVC   BKNBKDTE,BKIBDATE   COPY THE BOOKSHELF INDEX BUILD DATE\n         MVC   BKNBKTIM,BKIBTIME   COPY THE BOOKSHELF INDEX BUILD TIME\n*\n         MVC   BKNSTAT,0(R1)       COPY STATUS RETURNED EARLIER\n*\n         MVC   BKNBKSID,BKSID      COPY THE BOOKSHELF NAME (ESOTERIC)\n*\n         MVC   BKNDSNME,BKIDSN     COPY THE BOOKSHELF INDEX DS NAME\n*\n         LA    R1,BKSTITLL         POINT AT BOOKSHELF TITLE\n         BAL   R8,INFOTITL         GO COPY THE TITLE\n*\n         BAL   R8,INFOWRIT         WRITE OUT THE ACTIVE RECORD\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        NOW LOOP THROUGH THE VARIOUS BOOK INFORMATION RECORDS.       *\n*        AN OUTPUT RECORD IS BUILT WHEN A NEW BOOK HEADER (OR         *\n*        END OF DATA) IS ENCOUNTERED.                                 *\n*                                                                     *\n***********************************************************************\n*\nBKSBOOKI DS    0H\n         MVC   BOOKSH,ALLSTARS     INITIALIZE ALL\n         MVC   BOOKNAME,ALLSTARS    OF THE\n         MVC   BOOKTTLL,=H'8'        VARIOUS\n         MVC   BOOKTITL(8),ALLSTARS   DATA\n         MVC   BOOKDATE,STARDATE       FIELDS\n         MVC   BOOKTIME,STARTIME        THAT A\n         MVC   BOOKDSN,ALLSTARS          BOOK HAS\n*\nBKSBOOKL DS    0H\n         CLC   0(2,R3),=C'SH'      IS THIS THE BOOK HEADER (PUB NUMBER)\n         BNE   BKSBNSH             BRANCH IF NOT\n*\n         LR    R15,R4              COPY THE LENGTH\n         SH    R15,=H'3'           SUBTRACT THE HEADER LENGTH AND 1\n         CH    R15,=Y(L'PUBNOIN-1) CHECK FOR MAXIMUM LENGTH VIOLATION\n         BNH   *+8                 BRANCH IF NOT\n         LA    R15,L'PUBNOIN-1     SET MAXIMUM MOVE LENGTH\n         MVC   PUBNOIN,BLANKS      BLANK OUT THE PUB NUMBER FIELD\n         EX    R15,BKSPUBNO        COPY THE PUBLICATION NUMBER\n*\n         LA    R1,PUBNOPRM         POINT AT PARAMETER LIST\n         L     R15,PUBNOADR        LOAD SUBROUTINE ADDRESS\n         BASSM R14,R15             GO CONVERT THE PUB NUMBER\n*\n         MVC   BOOKSH,PUBNOOUT     COPY THE (REFORMATED) PUBLICATION NO\n         B     BKSBOOKN            AND GO GET THE NEXT RECORD\n*\nBKSPUBNO MVC   PUBNOIN(*-*),2(R3)  *** EXECUTE ONLY ***\n*\nBKSBNSH  DS    0H\n         CLC   0(2,R3),=C'ST'      IS THIS THE BOOK TITLE\n         BNE   BKSBNST             BRANCH IF NOT\n*\n         XC    BOOKTTLL,BOOKTTLL   ZERO THE TITLE LENGTH (NULL TITLE)\n*\n         LA    R1,2(,R3)           POINT TO POSSIBLE TITLE BEGINNING\n         LR    R14,R4              COPY THE LENGTH\n         SH    R14,=H'2'           ADJUST FOR THE ST\n         BNP   BKSBOOKN            IF NO TITLE, GO GET NEXT RECORD\n*\nBKSBTITL DS    0H\n         CLI   0(R1),C' '          SCAN FOR FIRST NON BLANK IN TITLE\n         BNE   BKSBTITB            BRANCH WHEN FOUND\n         LA    R1,1(,R1)           INCREMENT TO NEXT TITLE CHARACTER\n         BCT   R14,BKSBTITL        LOOP THROUGH THE TITLE HEADER\n         B     BKSBOOKN            NULL TITLE\n*\nBKSBTITB DS    0H\n         CH    R14,=Y(L'BOOKTITL)  CHECK FOR MAXIMUM LENGTH\n         BNH   *+8                 BRANCH IF WITHIN SPEC\n         LA    R14,L'BOOKTITL      LOAD THE MAXIMUM LENGTH\n*\n         STH   R14,BOOKTTLL        STORE THE TITLE LENGTH\n         BCTR  R14,0               DECREMENT FOR MVC\n         EX    R14,BKSBTITM        MOVE THE TITLE TO SAVE IT\n         B     BKSBOOKN            AND GO GET THE NEXT RECORD\n*\nBKSBTITM MVC   BOOKTITL(*-*),0(R1) *** EXECUTE ONLY ***\n*\nBKSBNST  DS    0H\n         BAL   R8,BKSEQUAL         SCAN FOR AN EQUAL SIGN\n         LTR   R15,R15             DID WE FIND ONE\n         BZ    BKSBOOKN            SKIP THIS RECORD IF NOT FOUND\n*\n         LR    R14,R15             COPY THE EQUAL SIGN ADDRESS\n         SR    R14,R1              CALCULATE LENGTH OF KEYWORD\n*\n         CH    R14,=H'6'           CHECK LENGTH\n         BNE   BKSBNBOO            BRANCH IF IT CAN'T BE\n         CLC   0(6,R1),=C'BKNAME'  IS THIS BKNAME=\n         BNE   BKSBNBOO            BRANCH IF IT ISN'T\n*\n         MVC   BOOKNAME,BLANKS     BLANK IT OUT\n         SH    R0,=H'8'            CALCULATE LENGTH FOR MVC\n         LR    R14,R0              MOVE FOR USE BY EXECUTE\n         EX    R14,BKSMVCBO        MOVE THE BOOK NAME\n*\n         B     BKSBOOKN            GO GET THE NEXT RECORD\n*\nBKSMVCBO MVC   BOOKNAME(*-*),1(R15)     *** EXECUTE ONLY ***\n*\nBKSBNBOO DS    0H\n         CH    R14,=H'6'           CHECK LENGTH\n         BNE   BKSBNDSN            BRANCH IF IT CAN'T BE\n         CLC   0(6,R1),=C'BKMDSN'  IS THIS BKMDSN=\n         BNE   BKSBNDSN            BRANCH IF IT ISN'T\n*\n         MVC   BOOKDSN,BLANKS      BLANK IT OUT\n         SH    R0,=H'8'            CALCULATE LENGTH FOR MVC\n         LR    R14,R0              MOVE FOR USE BY EXECUTE\n         EX    R14,BKSMVCBD        MOVE THE BOOK NAME\n*\n         B     BKSBOOKN            GO GET THE NEXT RECORD\n*\nBKSMVCBD MVC   BOOKDSN(*-*),1(R15) *** EXECUTE ONLY ***\n*\nBKSBNDSN DS    0H\n         CH    R14,=H'10'          CHECK LENGTH\n         BNE   BKSBNDTT            BRANCH IF IT CAN'T BE\n         CLC   0(10,R1),=C'BKDATETIME'  IS THIS BKDATETIME=\n         BNE   BKSBNDTT            BRANCH IF IT ISN'T\n*\n         LA    R14,0(R3,R4)        ADD REC ADDR & LENGTH\n         LA    R1,BOOKDATE         POINT AT DATE FIELD\n         LA    R0,BOOKTIME         POINT AT TIME FIELD\n         BAL   R8,BKSMVDTE         GO CONVERT THE DATE AND TIME\n*\n         B     BKSBOOKN            GO GET THE NEXT RECORD\n*\nBKSBNDTT DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        READ THE NEXT BOOK SPECIFIC RECORD AND BUILD AN OUTPUT       *\n*        RECORD IF THE NEXT BOOK HEADER OR END OF DATA IS REACHED.    *\n*                                                                     *\n***********************************************************************\n*\nBKSBOOKN DS    0H\n         BAL   R8,BKSBKSRD         READ ONE BOOKSHELF LIST RECORD\n         LTR   R3,R1               DID WE HIT END OF DATA\n         LR    R4,R0               COPY THE LENGTH\n         BZ    BKSBOOKB            IF SO, GO BUILD THE LAST RECORD\n*\n         CLC   0(2,R1),=C'SH'      CHECK FOR FIRST BOOK HEADER\n         BNE   BKSBOOKL            IF NOT, CONTINUE COLLECTION\n*\nBKSBOOKB DS    0H\n         CLI   BOOKDSN,C'*'        DO WE HAVE A DATA SET NAME\n         BH    BKSBHDSN            BRANCH IF WE DO\n*\n         MVC   DSNNAME,BOOKNAME    BOOK NAME\n         MVC   DSNTYPE,=CL8'BOOK'\n         LA    R1,DSNPARMS         POINT AT THE PARM LIST\n         L     R15,DSNADDR         LOAD THE SUBROUTINE ADDRESS\n         BASSM R14,R15             GO CONVERT THE DATA SET NAME\n*\n         LTR   R15,R15             TEST FOR SUCCESSFUL CONVERSION\n         BNZ   BADDSN              BRANCH IF NO GOOD\n*\n         MVC   BOOKDSN,DSNDSN      COPY RETURNED DATA SET NAME\n*\nBKSBHDSN DS    0H\n         LA    R1,BOOKDSN          POINT AT BOOK DATA SET NAME\n         BAL   R8,INFOSTAT         GO DETERMINE THE BOOK DATA SET STAT\n*\n         BAL   R8,INFOINIT         INITIALIZE THE ACTIVE RECORD\n*\n         MVC   BKNNAME,BOOKNAME    COPY THE GENERIC BOOK NAME\n         MVC   BKNTYPE,=CL8'BOOK'  SET THAT THIS IS A BOOK\n*\n         MVC   BKNBKDTE,BOOKDATE   COPY THE BOOK BUILD DATE\n         MVC   BKNBKTIM,BOOKTIME   COPY THE BOOK BUILD TIME\n*\n         MVC   BKNSTAT,0(R1)       COPY STATUS RETURNED EARLIER\n*\n         MVC   BKNPUBNO,BOOKSH     COPY THE PUBLICATION NUMBER\n*\n         MVC   BKNBKSID,BKSID      COPY THE BOOKSHELF NAME (ESOTERIC)\n*\n         MVC   BKNDSNME,BOOKDSN    COPY THE BOOK DATA SET NAME\n*\n         LA    R1,BKNDSNME         POINT AT BOOK DATA SET NAME\n         BAL   R8,GETUSMLV         DETERMINE IF THIS BOOK IS A USM BOOK\n         LTR   R1,R1               TEST IF IT IS\n         BZ    BKSNUSMB            BRANCH IF NOT\n*\n         MVC   BKNPUBNO+10(2),0(R1)     COPY THE RETURNED USM LEVEL\n*\nBKSNUSMB DS    0H\n*\n         LA    R1,BOOKTTLL         POINT AT BOOK TITLE\n         BAL   R8,INFOTITL         GO COPY THE TITLE\n*\n         BAL   R8,INFOWRIT         WRITE OUT THE ACTIVE RECORD\n*\n         LTR   R3,R3               DID WE REACH END OF DATA\n         BNZ   BKSBOOKI            GO INITIALIZE A NEW BOOK\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        END OF BOOKSHELF DATA SET                                    *\n*                                                                     *\n***********************************************************************\n*\n         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE\n         BO    BKSNEXTI            BRANCH IF SO\n*\n         CLOSE (BKSHELF,FREE)      CLOSE AND FREE THIS BOOKSHELF\n         FREEPOOL BKSHELF          FREE THE BUFFER POOL\n*\nBKSNEXT  DS    0H\n*        LR    R1,R2               COPY THE BOOKSHELF DATA SET FOR FREE\n         L     R2,0(,R2)           CHAIN TO THE NEXT BOOKSHELF DATA SET\n         LTR   R2,R2               DO WE HAVE ANOTHER BOOKSHELF DATASET\n         BNZ   BKSLOOP1            LOOP IF WE AREN'T DONE\n*\n         SLR   R0,R0               INDICATE FREE\n         LA    R1,BKSBLOCK         POINT AT CELL POOL BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET STORAGE BLOCK\n         ST    R0,BKSFIRST         ZERO FOR POSTERITY\n*\n         B     ALLDONE             AND WE ARE THROUGH\n*\nBKSNEXTI DS    0H\n         L     R2,0(,R2)           CHAIN TO THE NEXT MEMBER\n         LTR   R2,R2               DO WE HAVE ANOTHER MEMBER\n         BZ    BKSINFOZ            BRANCH IF NOT\n*\n         CLOSE (BKSHELF)           CLOSE THE CURRENT MEMBER INPUT\n*\n         B     BKSLOOP1            AND GO PROCESS THE NEXT MEMBER\n*\nBKSINFOZ DS    0H\n         CLOSE (BKSHELF,FREE)      CLOSE AND FREE THE DATA SET\n         FREEPOOL BKSHELF          FREE THE BUFFER POOL\n*\n         SLR   R0,R0               INDICATE FREE\n         LA    R1,MEMBLOCK         POINT AT CELL POOL BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET STORAGE BLOCK\n         ST    R0,BKSFIRST         ZERO FOR POSTERITY\n*\n         B     ALLDONE             AND WE ARE THROUGH\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CLOSE THE OUTPUT INFORMATION FILE                            *\n*                                                                     *\n***********************************************************************\n*\nALLDONE  DS    0H\n         CLOSE (INFOFILE)          CLOSE THE OUTPUT FILE\n         FREEPOOL INFOFILE         FREE THE BUFFER POOL\n*\n***********************************************************************\n*                                                                     *\n*        FREE THE BOOKSHELF LIST DATA SET NAME LIST                   *\n*                                                                     *\n***********************************************************************\n*\n         SLR   R0,R0               INDOCATE FREE\n         LA    R1,BKLBLOCK         POINT AT CELL POOL BLOCK\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET STORAGE BLOCK\n         ST    R0,BKLFIRST         ZERO FOR POSTERITY\n*\n***********************************************************************\n*                                                                     *\n*        DELETE ALL THE SUBROUTINES                                   *\n*                                                                     *\n***********************************************************************\n*\n         DELETE EPLOC=CPSNAME      DELETE THE CELL POOL SUBROUTINE\n*\n         DELETE EPLOC=PUBNONAM     DELETE THE PUB NUMBER SUBROUTINE\n*\n         DELETE EPLOC=DSNSUB       DELETE THE DATA SET NAME SUBROUTINE\n*\n         DELETE EPLOC=DATTBL       DELETE THE DATA TABLE\n*\n         DELETE EPLOC=DEFSUB       DELETE THE DEFINITION ROUTINE\n*\n***********************************************************************\n*                                                                     *\n*        RETURN TO CALLER                                             *\n*                                                                     *\n***********************************************************************\n*\n         L     R13,4(,R13)         UNCHAIN THE SAVE AREA\n         LM    R14,R12,12(R13)     RELOAD THE REGISTERS\n         SLR   R15,R15             SET THE RETURN CODE\n         BR    R14                 RETURN TO CALLER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DYNAMIC ALLOCATION SUBROUTINE                                *\n*                                                                     *\n*        ON ENTRY, REGISTER 1 POINTS TO THE 44 CHARACTER DATA         *\n*        SET NAME.  THE DATA SET MUST EXIST.                          *\n*                                                                     *\n*        ON EXIT, R1 POINTS TO THE DDNAME IF THE ALLOCATION IS        *\n*        SUCCESSFUL.  OTHERWISE, R1 WILL BE ZERO.                     *\n*                                                                     *\n***********************************************************************\n*\nALLOCDSN DS    0H\n         MVC   DYNDSN,0(R1)        COPY THE DATA SET NAME\n*\n         LA    R1,DYNPTR           POINT AT DYNAMIC ALLOC PARM LIST\n         DYNALLOC ,                ISSUE THE DYNAMIC ALLOCATION\n*\n         SLR   R1,R1               INDICATE ALLOCATION FAILURE\n         LTR   R15,R15             DID WE HAVE ANY ERROR\n         BNZR  R8                  RETURN IF ANY ERROR\n*\n         LA    R0,1                LOAD 1\n         A     R0,DYNCOUNT         ADD OLD COUNT\n         ST    R0,DYNCOUNT         STORE NEW COUNT\n*\n         LA    R1,DYNDDNAM         POINT AT RETURN DDNAME\n         BR    R8                  RETURN TO CALLER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SUBROUTINE TO READ THE NEXT VALID RECORD IN A                *\n*        BOOKSHELF DATA SET.                                          *\n*                                                                     *\n*        ON RETURN, REGISTER 1 POINTS TO THE FIRST DATA BYTE          *\n*        AFTER THE RDW AND REGISTER 0 CONTAINS THE LENGTH.            *\n*                                                                     *\n*        AT END OF DATA, BOTH REG 1 AND REG 0 WILL BE ZERO.           *\n*                                                                     *\n***********************************************************************\n*\nBKSBKSRD DS    0H\n         GET   BKSHELF             READ ONE BOOKSHELF LIST RECORD\n         LA    R0,1                LOAD 1\n         A     R0,BOOKCNT          ADD PREVIOUS RECORD COUNT\n         ST    R0,BOOKCNT          STORE UPDATED COUNT\n*\n         LH    R0,0(,R1)           LOAD THE RECORD LENGTH\n         SH    R0,=H'4'            ELIMINATE THE RDW\n         BZ    BKSBKSRD            SKIP A NULL RECORD\n         LA    R1,4(,R1)           COPY THE RECORD ADDRESS\n*\n         LR    R15,R0              COPY THE LENGTH\n         AR    R15,R1              POINT PAST THE RECORD\n*\nBKSBLOOP DS    0H\n         BCTR  R15,0               DECREMENT TO PREVIOUS CHARACTER\n         CLI   0(R15),C' '         SCAN FOR TRAILING BLANKS\n         BNE   BKSBLNOT            BRANCH WHEN NON BLANK FOUND\n         BCT   R0,BKSBLOOP         LOOP THROUGH TRAILING BLANKS\n         B     BKSBKSRD            SKIP A TOTALLY BLANK RECORD\n*\nBKSBLNOT DS    0H\n         CLI   0(R1),C' '          NOW CHECK FOR A LEADING BLANK\n         BNE   BKSBLEAD            BRANCH IF NOT A LEADING BLANK\n         LA    R1,1(,R1)           INCREMENT PAST THE LEADING BLANK\n         BCT   R0,BKSBLNOT         LOOP THROUGH LEADING BLANKS\n*\nBKSBLEAD DS    0H\n         CLI   0(R1),C'*'          CHECK FOR A COMMENT STATEMENT\n         BE    BKSBKSRD            SKIP IT IF SO\n*\n         BR    R8                  RETURN TO CALLER\n*\nBKSEOD   DS    0H\n         SLR   R1,R1               INDICATE END OF DATA\n         SLR   R0,R0\n         BR    R8\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SCAN FOR AN EQUAL SIGN                                       *\n*                                                                     *\n*        THE STRING POINTED TO BY REGISTER 1 WITH LENGTH IN           *\n*        REGISTER 0 IS SCANNED FOR AN EQUAL SIGN.  THE ADDRESS        *\n*        OF THE EQUAL SIGN IS RETURNED IN REGISTER 15.  IF NO         *\n*        EQUAL SIGN IS FOUND, REGISTER 15 WILL BE ZERO.               *\n*                                                                     *\n***********************************************************************\n*\nBKSEQUAL DS    0H\n         LR    R15,R1              COPY THE STARTING ADDRESS\n         LR    R14,R0              COPY THE LENGTH\n*\nBKSEQSCN CLI   0(R15),C'='         LOOK FOR AN EQUAL SIGN\n         BER   R8                  RETURN IF EQUAL SIGN FOUND\n*\n         LA    R15,1(,R15)         INCREMENT TO NEXT CHARACTER\n         BCT   R14,BKSEQSCN        SCAN THE STRING\n*\n         SLR   R15,R15             INDICATE NO EQUAL SIGN\n         BR    R8                  RETURN TO CALLER\n*\n***********************************************************************\n*                                                                     *\n*        EXTRACT AND REFORMAT THE BOOKSHELF DATE/TIME FIELD           *\n*                                                                     *\n*        REGISTER 1 POINTS TO THE 10 BYTE TARGET FOR THE DATE.        *\n*        REGISTER 0 POINTS TO THE 8 BYTE TARGET FOR THE TIME.         *\n*        REGISTER 15 POINTS TO 1 BYTE IN FRONT OF THE BOOKMANAGER     *\n*        DATE/TIME FIELD.  REGISTER 14 POINT AT THE BYTE              *\n*        FOLLOWING THE DATE/TIME FIELD.                               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*\nBKSMVDTE DS    0H\n         CLC   1(8,R15),=C'00000000'    CHECK FOR NO DATE/TIME AVAIL\n         BNE   BKSMVDOK            BRANCH IF OK\n         MVC   0(10,R1),=C'0000/00/00'  SET A NULL DATE\n         LR    R1,R0               COPY THE TIME ADDRESS\n         MVC   0(8,R1),=C'00:00:00'     SET A NULL TIME\n         BR    R8                  RETURN WITH A NULL DATE/TIME\n*\nBKSMVDOK DS    0H\n         MVC   0(10,R1),=C'0000/00/00'  INITIALIZE THE DATE FIELD\n*\n         MVC   5(2,R1),1(R15)      COPY THE MM, ASSUMING MM\n         CLI   2(R15),C'/'         CHECK FOR ONE DIGIT MONTH (UGH!)\n         BNE   BKSMVMOK            BRANCH IF MONTH OK\n*\n         MVI   5(R1),C'0'          SET THE LEADING ZERO\n         MVC   6(1,R1),1(R15)      COPY THE M\n         BCTR  R15,0               BACK UP ONE TO COMPENSATE\n*\nBKSMVMOK DS    0H\n         LA    R15,3(,R15)         INCREMENT TO SLASH BETWEEN MM & DD\n*\n         MVC   8(2,R1),1(R15)      COPY THE DD, ASSUMING DD\n         CLI   2(R15),C'/'         CHECK FOR ONE DIGIT DAY (UGH!)\n         BNE   BKSMVYOK            BRANCH IF DAY OK\n*\n         MVI   5(R1),C'0'          SET THE LEADING ZERO\n         MVC   6(1,R1),1(R15)      COPY THE D\n         BCTR  R15,0               BACK UP ONE TO COMPENSATE\n*\nBKSMVYOK DS    0H\n         LA    R15,3(,R15)         INCREMENT TO SLASH BETWEEN DD & YY\n*\n         MVC   2(2,R1),1(R15)      COPY THE YY\n         MVC   0(2,R1),OCENTURY    SEED THE CENTURY AS OLD\n         CLC   2(2,R1),WCENTURY    CHECK WINDOWING\n         BH    *+10                BRANCH IF HIGH\n         MVC   0(2,R1),NCENTURY    SET THE NEW CENTURY\n*\n         LA    R15,4(,R15)         INCREMENT THE DATE/TIME POINTER\n*\n         LR    R1,R0               COPY THE TIME ADDRESS\n         MVC   0(8,R1),=C'00:00:00'     INITIALIZE THE TIME FIELD\n*\n         CR    R14,R15             MATCH AGAINST END OF THE DATE/TIME\n         BNHR  R8                  RETURN IF NO TIME\n*\n         MVC   0(8,R1),0(R15)      COPY THE HH:MM:SS\n         BR    R8                  RETURN\n*\n***********************************************************************\n*                                                                     *\n*        INITIALIZE THE OUTPUT RECORD IN THE WORK AREA                *\n*                                                                     *\n***********************************************************************\n*\nINFOINIT DS    0H\n         LA    R0,BKNLNGTH         LOAD THE BASE LENGTH\n         STH   R0,BKNLENG          STORE IN THE RDW LENGTH\n         MVI   BKNNAME,C' '        BLANK OUT THE\n         MVC   BKNNAME+1(BKNLNGTH-5),BKNNAME BASE RECORD AREA\n*\n         MVC   BKNBKDTE,STARDATE   INITIALIZE THE BOOK BUILD DATE\n         MVC   BKNBKTIM,STARTIME   INITIALIZE THE BOOK BUILD TIME\n*\n         MVC   BKNSTAT,ALLSTARS    INITIALIZE THE BOOK STATUS\n*\n         MVC   BKNCKIT,STARPUBN    INITIALIZE THE COLLECTION KIT ID\n         MVC   BKNPUBNO,STARPUBN   INITIALIZE THE PUBLICATION NUMBER\n*\n         MVC   BKNBKSID,ALLSTARS   INITIALIZE THE BOOKSHELF ID\n         MVC   BKNDSNME,ALLSTARS   INITIALIZE THE DATA SET NAME\n*\n         MVC   BKNTITLE(8),ALLSTARS     INITIALIZE THE TITLE\n*\n         BR    R8                  RETURN TO CALLER\n*\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT THE TITLE                                          *\n*                                                                     *\n*        REGISTER 1 POINTS TO THE HALFWORD LENGTH OF THE TITLE        *\n*        IMMEDIATELY FOLLOWED BY THE TITLE.  THE RECORD CONTAINED     *\n*        IN THE RECORD WORK AREA IS UPDATED.                          *\n*                                                                     *\n***********************************************************************\n*\nINFOTITL DS    0H\n         LH    R0,0(,R1)           LOAD THE TITLE LENGTH\n         LTR   R0,R0               TEST IF THE TITLE EVEN EXISTS\n         BNZ   INFOTITG            BRANCH IF TITLE PRESENT\n*\n         LA    R1,NOTITLEL         POINT AT NO TITLE LENGTH\n         LH    R0,NOTITLEL         LOAD THE NO TITLE LENGTH\n*\nINFOTITG DS    0H\n         LA    R14,1(,R1)          GET THE POINTER TO THE LAST\n         AR    R14,R0               CHARACTER IN THE TITLE\n*\nINFOTITB DS    0H\n         CLI   0(R14),C' '         CHECK FOR A TRAILING BLANK\n         BNE   INFOTITZ            BRANCH IF NOT\n         BCTR  R14,0               BACK UP ONE CHARACTER\n         BCT   R0,INFOTITB         LOOP THROUGH THE END OF THE TITLE\n*\n         LA    R1,NOTITLEL         POINT AT NO TITLE LENGTH\n         LH    R0,NOTITLEL         LOAD THE NO TITLE LENGTH\n*\nINFOTITZ DS    0H\n         LR    R14,R0              COPY THE TITLE LENGTH\n         CH    R14,=Y(L'INFOWORK-BKNLNGTH)  CHECK IF TOO BIG\n         BNH   *+8                 BRANCH IF OK\n         LA    R14,L'INFOWORK-BKNLNGTH  SET MAX LENGTH\n*\n         LH    R0,BKNLENG          LOAD THE EXISTING RECORD LENGTH\n         AR    R0,R14              ADD THE TITLE LENGTH\n         STH   R0,BKNLENG          STORE IN THE RDW LENGTH\n         CH    R0,=Y(L'INFOWORK)   CHECK MAXIMUM LENGTH\n         BNH   *+6                 BRANCH IF OK\n         DC    H'0'                BLOW UP FOR NOW....\n*\n         BCTR  R14,0               DECREMENT LENGTH FOR MVC\n         EX    R14,INFOTITM        MOVE THE TITLE\n*\n         BR    R8                  RETURN TO CALLER\n*\nINFOTITM MVC   BKNTITLE(*-*),2(R1) *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DETERMINE STATUS OF DATA SET NAME                            *\n*                                                                     *\n*        REGISTER 1 POINTS TO THE DATA SET NAME TO DETERMINE THE      *\n*        STATUS OF.  ON RETURN, REGISTER 1 POINTS TO THE 8 CHARACTER  *\n*        DATA SET NAME STATUS:                                        *\n*                                                                     *\n*        ACTIVE   - DATA SET IS CATALOGUED                            *\n*        ARCHIVED - DATA SET HAS BEEN ARCHIVED                        *\n*        MISSING  - DATA SET IS NOT CATALOGUED AND NOT ARCHIVED       *\n*                                                                     *\n***********************************************************************\n*\nINFOSTAT DS    0H\n         TM    PROCFLAG,PROCINFO   ARE WE IN INFORMATION MODE\n         BZ    INFOSTAI            BRANCH IF NOT\n         LA    R1,ALLSTARS         ALWAYS SET ******** FOR INFORMATION\n         BR    R8                  AND RETURN\n*\nINFOSTAI DS    0H\n         CLI   0(R1),C'*'          DO WE HAVE NO DATA SET NAME\n         BNE   INFOSTNS            BRANCH IF IT'S NOT\n         LA    R1,=CL8'NOTAVAIL'   INDICATE WE DON'T HAVE IT AT ALL\n         BR    R8                  AND RETURN\n*\nINFOSTNS DS    0H\n         MVC   LOCDSN,0(R1)        COPY THE DATA SET NAME\n*\n         LOCATE CAMLST             DO THE LOCATE\n*\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   INFOSNCT            BRANCH IF NOT FOUND IN CATALOG\n*\n         TM    PROCFLAG,PROCVOL    IS VOLUME INFO WANTED\n         BZ    INFOSTNV            BRANCH IF NOT\n         MVC   LOCVOLSQ,=C'  '     BLANK OUT SEQUENCE NUMBER\n         LA    R1,LOCVOLSR         POINT AT VOLUME SERIAL NUMBER\n         BR    R8                  RETURN TO CALLER\n*\nINFOSTNV DS    0H\n         LA    R1,=CL8'ARCHIVED'   INDICATE THE DATA SET IS ARCHIVED\n         CLC   LOCVOLSR,=C'MIGRAT' CHECK FOR HSM ARCHIVE VOL SER\n         BER   R8                  RETURN IF SO\n*\n         LA    R1,=CL8'ACTIVE'     ASSUME WE FOUND IT\n         BR    R8                  RETURN IF WE HAVE A REAL DATA SET\n*\nINFOSNCT DS    0H\n         LA    R1,=CL8'MISSING'    INDICATE WE CAN'T FIND THIS ANYWHERE\n         BR    R8                  AND RETURN TO CALLER\n*\n***********************************************************************\n*                                                                     *\n*        DETERMINE THE USM LEVEL OF A BOOK DATA SET                   *\n*                                                                     *\n*        THE DATA SET NAME POINTED TO BY REGISTER 1 IS SCANNED        *\n*        FOR STRINGS THAT INDICATE THAT THE BOOK IS FROM THE          *\n*        UNIVERSAL SALES MANUAL.  IF SO, REGISTER 1 WILL BE           *\n*        RETURNED POINTING TO THE TWO CHARACTER USM BOOK LEVEL.       *\n*                                                                     *\n*        IF THE BOOK IS NOT A UNIVERSAL SALES MANUAL BOOK,            *\n*        REGISTER 1 WILL BE ZERO.                                     *\n*                                                                     *\n***********************************************************************\n*\nGETUSMLV DS    0H\n         LA    R0,44               LENGTH OF THE DATA SET NAME\n*\nGETUSMLP DS    0H\n         CLI   0(R1),C' '          ARE WE AT THE END OF THE DATA SET\n         BE    GETUSMZR            RETURN IF SO\n*\n         CLI   0(R1),C'.'          CHECK FOR A DELIMITER\n         BNE   GETUSMNX            GO TO NEXT STRING IF NOT\n*\n         CLC   1(3,R1),=C'LVL'     CHECK FOR OLD NAME FORMAT\n         BNE   GETUSMNL            BRANCH IF NOT\n         CLI   6(R1),C'.'          CHECK ENDING DELIMITER\n         BNE   GETUSMNX            BRANCH IF NOT - CAN'T BE USM (YET)\n*\n         LA    R1,4(,R1)           POINT AT USM LEVEL NUMBER\n         BR    R8                  RETURN IF USM LEVEL FOUND\n*\nGETUSMNL DS    0H\n         CLC   1(3,R1),=C'USM'     CHECK FOR NEW NAME FORMAT\n         BNE   GETUSMNU            BRANCH IF NOT\n*\n         CLC   4(2,R1),=C'HW'      CHECK FOR HARDWARE\n         BE    GETUSMNH            BRANCH IF SO\n         CLC   4(2,R1),=C'SW'      CHECK FOR SORTWARE\n         BE    GETUSMNS            BRANCH IF SO\n         CLC   4(2,R1),=C'PR'      CHECK FOR PRICES\n         BE    GETUSMNP            BRANCH IF SO\n*\n         B     GETUSMNU            CAN'T BE USM BOOK\n*\nGETUSMNH DS    0H\nGETUSMNS DS    0H\nGETUSMNP DS    0H\n         LA    R1,6(,R1)           POINT AT USM BOOK LEVEL\n         BR    R8                  RETURN TO CALLER WITH USM LEVEL\n*\nGETUSMNU DS    0H\n*\nGETUSMNX DS    0H\n         LA    R1,1(,R1)           INCREMENT TO NEXT DATA SET NAME CHAR\n         BCT   R0,GETUSMLP         LOOP THROUGH THE DATA SET NAME\n*\nGETUSMZR DS    0H\n         SLR   R1,R1               INDICATE IT'S NOT A USM BOOK\n         BR    R8                  RETURN TO CALLER\n*\n***********************************************************************\n*                                                                     *\n*        WRITE OUT THE ACTIVE RECORD                                  *\n*                                                                     *\n***********************************************************************\n*\nINFOWRIT DS    0H\n         LA    R0,1                LOAD A 1\n         A     R0,INFOCNT          ADD THE PREVIOUS COUNT\n         ST    R0,INFOCNT          STORE THE UPDATED COUNT\n*\n         PUT   INFOFILE,INFOWORK   WRITE OUT THE NEWLY BUILT RECORD\n*\n         BR    R8                  RETURN TO CALLER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        VARIOUS ABEND ROUTINES                                       *\n*                                                                     *\n***********************************************************************\n*\nPARMINVL DS    0H\n         ABEND 10,DUMP\n*\nPARMERR1 DS    0H\n         ABEND 20,DUMP\n*\nBKLALOCE DS    0H\n         ABEND 30,DUMP\n*\nBKLOPENE DS    0H\n         ABEND 35,DUMP\n*\nBKSALOCE DS    0H\n         ABEND 40,DUMP\n*\nBKSOPENE DS    0H\n         ABEND 45,DUMP\n*\nBKSPALOC DS    0H\n         ABEND 50,DUMP\n*\nBKSPDSER DS    0H\n         ABEND 55,DUMP\n*\nINFOPENE DS    0H\n         ABEND 60,DUMP\n*\nBKSISBAD DS    0H\n         ABEND 70,DUMP\n*\nLOADERR0 DS    0H\n         ABEND 75,DUMP\n*\nLOADERR1 DS    0H\n         ABEND 80,DUMP\n*\nLOADERR2 DS    0H\n         ABEND 90,DUMP\n*\nLOADERR3 DS    0H\n         ABEND 95,DUMP\n*\nLOADERR4 DS    0H\n         ABEND 97,DUMP\n*\nBADDSN   DS    0H\n         ABEND 100,DUMP\n*\n         EJECT\nLITERALS LTORG ,\n*\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\nCCCBKEXD CSECT\nCCCBKEXD AMODE 24\nCCCBKEXD RMODE 24\n*\nSAVEAREA DC    9D'0'               REGISTER SAVE AREA\n*\nDOUBLE   DS    D                   DOUBLE WORD WORK AREA\n*\nBKLFIRST DC    A(0)                ADDRESS OF FIRST BOOKSHELF LIST DSN\nBKLCOUNT DC    F'0'                COUNT OF BOOKSHELF LIST DATA SETS\n*\nBKSFIRST DC    A(0)                ADDRESS OF FIRST BOOKSHELF DSNAME\nBKSCOUNT DC    F'0'                COUNT OF BOOKSHELF DATA SETS\n*\nBOOKCNT  DC    F'0'                COUNT OF BOOKSHELF RECORDS READ\n*\nINFOCNT  DC    F'0'                COUNT OF EXTRACT RECORDS CREATED\n*\nDYNCOUNT DC    F'0'                COUNT OF DYNAMIC ALLOCATIONS\n*\nDSNHOLD  DS    CL44                AREA TO HOLD THE DATA SET NAME\nBKSHOLD  DS    CL8                 AREA TO HOLD THE BOOKSHELF NAME\n*\nCPSNAME  DC    CL8'CCCBKCPS'       CELL POOL ROUTINE NAME\nCPSADDR  DC    A(0)                CELL POOL SUBROUTINE ADDRESS\n*\nBKLBLOCK BKMGRCPS ID=BKL,SP=22,SIZE=16\n*\nMEMBLOCK BKMGRCPS ID=MEM,SP=44,SIZE=4\n*\nBKSBLOCK BKMGRCPS ID=BKS,SP=33,SIZE=128\n*\nDSNSUB   DC    CL8'CCCBKDSN'       DATA SET NAME SUBROUTINE NAME\nDSNADDR  DC    A(0)                DATA SET NAME SUBROUTINE ADDRESS\n*\nDATTBL   DC    CL8'CCCBKDAT'       DATA TABLE MODULE\nDEFSUB   DC    CL8'CCCBKDEF'       DEFINITION SUBROUTINE\n*\nDSNPARMS DS    0A\n         DC    A(DSNNAME)          NAME OF BOOK\n         DC    A(DSNTYPE)          TYPE OF BOOK\n         DC    X'80',AL3(DSNDSN)   RETURNED DATA SET NAME\n*\nDSNNAME  DS    CL8                 NAME OF BOOK\nDSNTYPE  DS    CL8                 TYPE OF BOOK\nDSNDSN   DS    CL44                RETURNED DATA SET NAME\n*\nTODAY    DS    0CL10               TODAY'S DATE FOR UPDATING\nTODAYYYY DS    C'YYYY'             THE YEAR\n         DC    C'/'\nTODAYMM  DS    C'MM'               THE MONTH\n         DC    C'/'\nTODAYDD  DS    C'DD'               THE DAY\n*\nTHEDATE  DS    0F,PL4              THE DATE FROM THE TIME MACRO\n*\nDAYSOOL  DC    PL2'31,28,31,30,31,30,31,31,30,31,30,31'\nDAYSFEB  EQU   DAYSOOL+L'DAYSOOL\n*\nVERBTYPE DS    C                   TYPE OF BOOKSHELF LIST VERB\n*\nPROCFLAG DC    X'00'               TYPE OF BOOKSHELF PROCESSING\nPROCACTV EQU   X'80'               ACTIVE BOOKSHELF PROCESSING\nPROCINFO EQU   X'40'               INFORMATION BOOKSHELF PROCESSING\nPROCVOL  EQU   X'20'               VOLUME INFORMATION WANTED\n*\n         DS    0D\nBKSNAME  DS    CL8                 BOOKSHELF NAME ID (FROM DATA SET)\nBKSID    DS    CL8                 BOOKSHELF NAME (FROM BKSHELF=)\nBKINAME  DS    CL8                 BOOKSHELF NAME (FROM BKSINDEX=)\nBKSTITLL DS    H                   BOOKSHELF TITLE LENGTH\nBKSTITLE DS    CL256               BOOKSHELF TITLE (FROM BKSTITLE=)\nBKSBDATE DS    CL10                BOOKSHELF DATE (FROM BKSDATETIME=)\nBKSBTIME DS    CL8                 BOOKSHELF TIME (FROM BKSDATETIME=)\nBKIBDATE DS    CL10                BKSHELFINDX DATE (FROM BKSDATETIME=)\nBKIBTIME DS    CL8                 BKSHELFINDX TIME (FROM BKSDATETIME=)\nBKSDSN   DS    CL44                BOOKSHELF DATA SET NAME\nBKSLNAME DS    CL8                 BOOKSHELF NAME FROM BOOKSHELF LIST\nBKIDSN   DS    CL44                BOOKSHELF INDEX DSN (FROM BKSIMDSN=)\n*\n         DS    0D\nBOOKSH   DS    CL12                BOOK PUBLICATION NUMBER (FROM SH)\nBOOKNAME DS    CL8                 BOOK NAME (FROM BKNAME=)\nBOOKTTLL DS    H                   BOOK TITLE LENGTH\nBOOKTITL DS    CL256               BOOK TITLE (FROM ST)\nBOOKDSN  DS    CL44                BOOK DATA SET NAME (FROM BKMDSN=)\nBOOKDATE DS    CL10                BOOK BUILD DATE (FROM BKDATETIME=)\nBOOKTIME DS    CL8                 BOOK BUILT TIME (FROM BKDATETIME=)\n*\n         DS    0D\nBLANKS   DC    CL256' '            AREA FOR BLANKING AND UPPERCASING\nALLSTARS DC    44C'*'              FILLER FOR UNDEFINED FIELDS\nSTARDATE DC    C'****/**/**'       FILLER FOR UNDEFINED DATE\nSTARTIME DC    C'**:**:**'         FILLER FOR UNDEFINED TIME\nSTARPUBN DC    C'****-****-**'     FILLER FOR UNDEFINED PUB NUMBER\n*\nNOTITLEL DC    Y(L'NOTITLE)        LENGTH OF NO TITLE STRING\nNOTITLE  DC    C'(No Title Found)' NO TITLE FOUND STRING\n*\nOCENTURY DC    C'19'               DEFINE THE CURRENT CENTURY FOR DATES\nNCENTURY DC    C'20'               DEFINE THE CURRENT CENTURY FOR DATES\nWCENTURY DC    C'80'               DATE WINDOW (UGH!)\n*\nPUBNOOUT DS    CL12                WORKING PUBLICATION NUMBER\nPUBNOIN  DS    CL12                EXTRACTED PUBLICATION NUMBER\n*\nPUBNONAM DC    CL8'CCCBKPUB'       PUBLICATION NUMBER SUBROUTINE NAME\nPUBNOADR DC    A(0)                PUBLICATION NUMBER SUBROUTINE ADDR\n*\nPUBNOPRM DC    A(PUBNOIN),X'80',AL3(PUBNOOUT)\n*\nCAMLST   CAMLST NAME,LOCDSN,,LOCWORK\n*\n         DS    0D\nLOCDSN   DS    CL44\n*\n         DS    0D\nLOCWORK  DS    CL265\n         ORG   LOCWORK\nLOCCOUNT DS    H\nLOCDEVT  DS    XL4\nLOCVOLSR DS    CL6\nLOCVOLSQ DS    H\n         ORG   ,\n*\nDYNPTR   DC    0F'0',X'80',AL3(DYNBLOCK) DYNAMIC ALLOC BLOCK POINTER\n*\nDYNBLOCK DS    0F\n         DC    AL1(20),AL1(S99VRBAL)    LENGTH AND ALLOC VERB\n         DC    H'0',H'0',H'0'      FLAGS, ERROR, INFO\n         DC    A(DYNTEXTP)         TEXT UNIT POINTERS\n         DC    A(0)                EXTENSION POINTER\n         DC    XL4'00'             MORE FLAGS\n*\nDYNTEXTP DS    0A\n         DC    A(DYNDSNTX)         DATA SET NAME\n         DC    A(DYNSHRTX)         DISP=SHR\n         DC    X'80',AL3(DYNRDDTX) RETURN DDNAME\n*\n         DS    0F\nDYNDSNTX DC    Y(DALDSNAM)         DATA SET NAME\n         DC    H'1'\n         DC    H'44'\nDYNDSN   DS    CL44                DATA SET NAME\n*\n         DS    0F\nDYNSHRTX DC    Y(DALSTATS)         DISPOSITION\n         DC    H'1'\n         DC    H'1'\n         DC    AL1(8)              DISP=SHR\n*\n         DS    0F\nDYNRDDTX DC    Y(DALRTDDN)         RETURN DDNAME\n         DC    H'1'\n         DC    H'8'\nDYNDDNAM DS    CL8                 RETURN DDNAME\n*\n         DS    0D\nINFOWORK DS    CL259               RECORD BUILD WORK AREA\n*\n         EJECT\n         PUSH  PRINT\n         PRINT NOGEN\n*\nBKLSHELF DCB   DSORG=PS,                                               X\n               DDNAME=********,                                        X\n               MACRF=GL,                                               X\n               RECFM=VB,                                               X\n               EODAD=BKLEOD\n*\nBKSDIRCT DCB   DSORG=PS,                                               X\n               DDNAME=********,                                        X\n               MACRF=GL,                                               X\n               RECFM=FB,                                               X\n               LRECL=256,                                              X\n               BLKSIZE=256,                                            X\n               EODAD=BKSEODIR\n*\nBKSHELF  DCB   DSORG=PS,                                               X\n               DDNAME=********,                                        X\n               MACRF=GL,                                               X\n               EXLST=BKSEXLST,                                         X\n               RECFM=VB,                                               X\n               EODAD=BKSEOD\n*\nBKSEXLST DC    0F'0',X'87',AL3(BKSJFCB)\n*\nBKSJFCB  DS    CL176\n*\nINFOFILE DCB   DSORG=PS,                                               X\n               DDNAME=INFOFILE,                                        X\n               MACRF=PM,                                               X\n               RECFM=VB\n*\n         POP   PRINT\n*\nCCCBKEXL EQU   *-CCCBKEXD          LENGTH OF DATA AREA\n*\n         EJECT\n*\n         PUSH  PRINT\n         PRINT NOGEN\n*\n         DCBD  DSORG=PS,DEVD=DA\n*\n         IEFZB4D0\n*\n         IEFZB4D2\n*\nJFCB     DSECT\n         IEFJFCBN\n*\n         BKMGRINF\n*\n         POP   PRINT\n*\n         END   CCCBKEXT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCCBKLOC": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x99!_\\x11S\\x01\\xcf\\x01\\xca\\x00\\x0c\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1999-08-03T11:53:00", "lines": 463, "newlines": 458, "modlines": 12, "user": "KEM00"}, "text": "BKLOC    TITLE 'BOOKMANAGER CATALOG LOCATE PROGRAM'\n***********************************************************************\n*                                                                     *\n*        BOOKMANAGER CATALOG LOCATE PROGRAM                           *\n*                                                                     *\n*        PARAMETERS                                                   *\n*                                                                     *\n*        HLI,HLI,HLI,....                                             *\n*                                                                     *\n*        THE PARM FIELD IS A LIST OF ONE TO A MAXIMUM OF 16           *\n*        DATA SET HIGH LEVEL INDICES.                                 *\n*                                                                     *\n*        OUTPUT                                                       *\n*                                                                     *\n*        DDNAME CATFILE POINTS TO A SEQUENTIAL DATA SET THAT WILL     *\n*        CONTAIN THE LIST OF LOCATED DATA SET NAMES.  THIS LIST       *\n*        WILL BE IN ALPHABETICAL ORDER, ASSUMING THAT THERE IS        *\n*        NO DUPLICATION OF DATA SET NAMES IN THE HIGH LEVEL           *\n*        INDEX LIST PASSED TO THIS PROGRAM.                           *\n*                                                                     *\n***********************************************************************\n*\n         PUNCH '         PAGE  CCCBKLOC'  MAKE DEBUGGING EASIER\n*\nCCCBKLOC CSECT\nCCCBKLOC AMODE 24\nCCCBKLOC RMODE 24\n*\n         USING CCCBKLOC,R15        INITIAL BASE REGISTER\n         B     AROUNDID\n         DC    CL8'CCCBKLOC'       MODULE ID\n         DC    CL8'V 1.1.1'        MODULE LEVEL\n         DC    CL8'&SYSDATE'\n         DC    CL8' &SYSTIME'\n*\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             SET THE BASE REGISTER\n         DROP  R15\n         USING CCCBKLOC,R12\n*\n         L     R14,=A(SAVEAREA)    POINT AT NEW SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACK CHAIN\n         LR    R13,R14             SET NEW SAVE AREA\n         USING SAVEAREA,R13        PROVIDE ADDITIONAL ADDRESSABILITY\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        EXTRACT THE PARM FIELD TO CREATE THE INITIAL LIST            *\n*        OF HIGH LEVEL INDICES.                                       *\n*                                                                     *\n***********************************************************************\n*\n         L     R2,0(,R1)           LOAD FIRST PARM ADDRESS\n         LH    R3,0(,R2)           LOAD THE PARM LENGTH\n         LTR   R3,R3               TEST THE PARM LENGTH\n         BZ    PARMINVL            IF NONE, PARM IS INVALID\n         LA    R2,2(,R2)           INCREMENT PAST THE LENGTH FIELD\n*\n         LA    R4,HLQTABLE         POINT AT FIRST ENTRY\n*\nPARMHLQL DS    0H\n         MVC   PARMHOLD,BLANKS     BLANK THE DATA SET NAME AREA\n         LA    R1,PARMHOLD         POINT AT START OF DSN\n         LA    R15,PARMHOLD+8      POINT AT END OF VALID HLQ LENGTH\n*\nPARMHLQM DS    0H\n         CLI   0(R2),C','          IS THIS A DELIMITER\n         BE    PARMHLQE            IF SO, THIS IS THE END OF THE DSN\n         CR    R1,R15              HAVE WE GONE TOO FAR\n         BE    PARMERR1            BAD NEWS IF WE HAVE\n*\n         MVC   0(1,R1),0(R2)       MOVE ONE DSNAME CHARACTER\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHARACTER\n         LA    R2,1(,R2)           INCREMENT TO NEXT CHARACTER\n         BCT   R3,PARMHLQM         GO MOVE THE NEXT CHARACTER\n*\nPARMHLQE DS    0H\n         MVC   0(L'HLQTABLE,R4),PARMHOLD COPY THE HIGH LEVEL INDEX\n         LA    R4,L'HLQTABLE(,R4)  INCREMENT TO NEXT TABLE ENTRY\n*\n         LA    R0,1                LOAD A 1\n         A     R0,HLQCOUNT         ADD THE OLD COUNT\n         ST    R0,HLQCOUNT         STORE THE NEW COUNT\n*\n         LTR   R3,R3               DID WE REACH THE END\n         BZ    PARMDONE            BRANCH IF SO\n*\n         C     R0,=A(HLQMAX)       HAVE WE REACHED THE MAX NUMBER OF EM\n         BNL   PARMERR2            FI SO, BLOW\n*\n         LA    R2,1(,R2)           SKIP THE COMMA\n         BCT   R3,PARMHLQL         AND LOOP THROUGH THE PARM\n*\nPARMDONE DS    0H\n*\n***********************************************************************\n*                                                                     *\n*        GETMAIN THE INITIAL CATALOG WORK AREA                        *\n*                                                                     *\n***********************************************************************\n*\n         L     R0,=A(16*1024)      LOAD 16K WORTH\n         ST    R0,LOCWORKS         SAVE THIS SIZE\n*\n         GETMAIN RU,LV=(0),SP=99,LOC=(BELOW,ANY)\n         ST    R1,LOCWORKA         SAVE THIS ADDRESS\n         L     R0,LOCWORKS         LOAD THE FULL SIZE\n         SH    R0,=H'8'            SUBTRACT HEADER SPACE\n         ST    R0,0(,R1)           STORE THE USABLE LENGTH\n         XC    4(4,R1),4(R1)       ZERO THE RETURN LENGTH\n*\n         LA    R0,1                LOAD A 1\n         A     R0,GETMCNT          ADD PREVIOUS GETMAIN COUNT\n         ST    R0,GETMCNT          STORE NEW GETMAIN COUNT\n*\n***********************************************************************\n*                                                                     *\n*        OPEN THE CATALOG OUTPUT FILE                                 *\n*                                                                     *\n***********************************************************************\n*\n         OPEN  (CATFILE,(OUTPUT))\n         LTR   R15,R15             WAS THIS SUCCESSFUL\n         BNZ   CATOPENE            IF NOT, ABORT\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SCAN THE LIST OF HIGH LEVEL INDICES TO FIND THE LOWEST       *\n*        ONE ALPHABETICALLY.                                          *\n*                                                                     *\n***********************************************************************\n*\nMAINLOOP DS    0H\n         MVC   LOCDSN,BLANKS       CLEAR OUT THE AREA\n         MVI   LOCDSN,X'FF'        SET HIGH VALUES\n*\n         LA    R1,HLQTABLE         POINT AT FIRST HIGH LEVEL QUALIFIER\n         L     R0,HLQCOUNT         LOAD HOW MANY WE HAVE\n         SLR   R2,R2               INDICATE WE HAVEN'T FOUND ONE\n*\nHLQLOOP1 DS    0H\n         CLC   0(L'HLQTABLE,R1),BLANKS  IS THIS A BLANK ENTRY\n         BE    HLQNEXT1            IF SO, SKIP IT\n*\n         CLC   0(L'HLQTABLE,R1),LOCDSN  LOCATE THE LOWEST ENTRY\n         BNL   HLQNEXT1            BRANCH IF NOT LOWER\n*\n         MVC   LOCDSN(L'HLQTABLE),0(R1) COPY THE HIGH LEVEL INDEX\n         LR    R2,R1               SAVE THE ADDRESS OF THE ONE WE FOUND\n*\nHLQNEXT1 DS    0H\n         LA    R1,L'HLQTABLE(,R1)  INCREMENT TO NEXT ENTRY\n         BCT   R0,HLQLOOP1         LOOP THROUGH THE HIGH LEVEL TABLE\n*\n         LTR   R2,R2               DID WE FIND ONE\n         BZ    ALLDONE             IF NOT, WE ARE ALL DONE\n*\n         MVC   0(L'HLQTABLE,R2),BLANKS  NULLIFY THIS ENTRY\n*\n         LA    R1,LOCDSN           POINT AT FIRST CHARACTER\n         LA    R15,1               COUNT AT LEAST ONE CHARACTER\n*\nHLQLENGL DS    0H\n         CLI   0(R1),C' '          CHECK FOR THE TRAILING BLANK\n         BE    HLQLENGG            BRANCH WHEN FOUND\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHARACTER\n         LA    R15,1(,R15)         INCREMENT THE LENGTH\n         B     HLQLENGL            AND LOOP THROUGH THE HIGH LEVEL IND\n*\nHLQLENGG DS    0H\n         MVI   0(R1),C'.'          ADD A PERIOD\n         STC   R15,LOCLENG         STORE THE LENGTH (INCLUDING PERIOD)\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PERFORM THE GENERIC SUPERLOCATE FOR THIS HIGH LEVEL INDEX    *\n*                                                                     *\n***********************************************************************\n*\nLOCLOOP1 DS    0H\n         L     R0,LOCWORKA         LOAD THE WORK AREA ADDRESS\n         ST    R0,LOCWORK          INITIALIZE IN THE LOCATE PARM LIST\n*\n         LOCATE LOCPARM            ISSUE THE LOCATE SVC\n*\n         LTR   R15,R15             WAS IT COMPLETELY SUCCESSFUL\n         BZ    LOCGOOD             BRANCH IF SO\n*\n         CH    R15,=H'40'          CHECK THE \"LENGTH\" RETURN CODE\n         BL    LOCBAD1             ERROR IF LOWER\n         CH    R15,=H'44'          CHECK THE OTHER \"LENGTH\" RETURN CODE\n         BH    LOCBAD2             ERROR IF HIGHER\n*\n***********************************************************************\n*                                                                     *\n*        WORK AREA IS TOO SMALL.  DOUBLE IT UNTIL IT IS BIGGER THAN   *\n*        THE INDICATE REQUIRED AMOUNT OF DATA.                        *\n*                                                                     *\n***********************************************************************\n*\n         L     R1,LOCWORKA         LOAD THE LOCATE AREA ADDRESS\n         L     R0,LOCWORKS         LOAD THE CURRENT SIZE\n*\n         L     R2,4(,R1)           LOAD THE REQUIRED SIZE\n*\n         FREEMAIN RU,LV=(0),A=(1),SP=99 FREE THE OLD AREA\n*\nSIZELOOP DS    0H\n         L     R0,LOCWORKS         LOAD THE CURRENT SIZE\n         AR    R0,R0               DOUBLE IT\n         ST    R0,LOCWORKS         STORE THE NEW SIZE\n*\n         CR    R0,R2               COMPARE AGAINST MAXIMUM\n         BL    SIZELOOP            LOOP IF TOO SMALL STILL\n*\n         GETMAIN RU,LV=(0),SP=99,LOC=(BELOW,ANY)\n         ST    R1,LOCWORKA         SAVE THIS ADDRESS\n         L     R0,LOCWORKS         LOAD THE FULL SIZE\n         SH    R0,=H'8'            SUBTRACT HEADER SPACE\n         ST    R0,0(,R1)           STORE THE USABLE LENGTH\n         XC    4(4,R1),4(R1)       ZERO THE RETURN LENGTH\n*\n         LA    R0,1                LOAD A 1\n         A     R0,GETMCNT          ADD PREVIOUS GETMAIN COUNT\n         ST    R0,GETMCNT          STORE NEW GETMAIN COUNT\n*\n         B     LOCLOOP1            AND GO RETRY THE LOCATE\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        NOW THAT A SUCCESSFUL LOCATE HAS BEEN PERFORMED,             *\n*        RUN THROUGH THE RETURNED DATA AND EXTRACT EACH DATA          *\n*        SET, HIGH LEVEL INDEX, AND LOW LEVEL INDEX.                  *\n*                                                                     *\n*        NOTE:  THE REASON THAT THE HIGH LEVEL INDEX IS EXTRACTED     *\n*        EACH TIME IS THAT THE SPECIFIED HIGH LEVEL INDEX MAY         *\n*        RETURN AN ALIASED DATA SET WHICH IN TURN IS ACTUALLY         *\n*        NAMED UNDER A DIFFERENT HIGH LEVEL INDEX.  STRANGE, BUT      *\n*        POSSIBLE.                                                    *\n*                                                                     *\n***********************************************************************\n*\nLOCGOOD  DS    0H\n         L     R2,LOCWORKA         POINT AT START OF LOCATE WORK AREA\n         L     R3,4(,R2)           LOAD THE RETURNED DATA SIZE\n*\n         LA    R2,8(,R2)           INCREMENT PAST THE WORK AREA HEADER\n         SH    R3,=H'8'            DECREMENT FOR HEADER LENGTH\n         BNH   MAINLOOP            IF NO DATA RETURNED, WE ARE DONE\n*\n         LA    R4,CATRECRD         POINT AT RECORD BUILD AREA\n         USING BKLDSECT,R4\n*\nDSNBUILD DS    0H\n         MVC   BKLDSECT(BKLLNGTH),BLANKS CLEAR THE ENTIRE RECORD\n*\n         MVC   BKLTYPE,0(R2)       COPY THE DATA SET TYPE\n         MVC   BKLDSNME,1(R2)      COPY THE DATA SET NAME\n*\n         LA    R1,BKLDSNME         POINT AT START OF DATA SET NAME\n         LA    R14,BKLDSNHL        POINT AT HIGH LEVEL QUALIFIER\n         LA    R15,8               MAXIMUM LENGTH\n*\nDSNHLQLP DS    0H\n         MVC   0(1,R14),0(R1)      COPY ONE CHARACTER\n         LA    R1,1(,R1)           INCREMENT ARROW\n         LA    R14,1(,R14)         INCREMENT TARGET\n         CLI   0(R1),C'.'          LOOP FOR DELIMITER\n         BE    *+8                 BRANCH WHEN FOUND\n         BCT   R15,DSNHLQLP        LOOP THROUGH THE FIRST 8 CHARACTERS\n*\n         LA    R1,BKLDSNME+L'BKLDSNME   POINT PAST LAST CHARACTER\n         LA    R0,BKLDSNME         POINT AT FIRST CHARACTER\n*\nDSNLLQL1 DS    0H\n         BCTR  R1,0                BACK UP ONE CHARACTER\n         CLI   0(R1),C'.'          LOOK FOR THE LAST DELIMITER\n         BE    DSNLLQL2            BRANCH WHEN FOUND\n         CR    R1,R0               ARE WE BACK AT THE BEGINNING\n         BH    DSNLLQL1            BRANCH IF WE AREN'T\n*\n         MVC   BKLDSNLL,=8C'?'     INDICATE NO KNOW LLQ\n         B     DSNLLQNO            AND SKIP THE REST\n*\nDSNLLQL2 DS    0H\n         LA    R15,8               AGAIN WE SET THE MAXIMUM\n         LA    R14,BKLDSNLL        POINT AT LOW LEVEL QUALIFIER FIELD\n*\nDSNLLQL3 DS    0H\n         MVC   0(1,R14),1(R1)      COPY ONE CHARACTER\n         LA    R14,1(,R14)         INCREMENT TARGET\n         LA    R1,1(,R1)           INCREMENT ARROW\n         CLI   0(R1),C' '          CHECK FOR END\n         BE    *+8                 BRANCH WHEN THERE\n         BCT   R15,DSNLLQL3        LOOP THROUGH THE LOW LEVEL QUALIFIER\n*\nDSNLLQNO DS    0H\n         PUT   CATFILE,BKLDSECT    WRITE OUT THE CATALOG RECORD\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,DSNCOUNT         ADD PREVIOUS COUNT\n         ST    R0,DSNCOUNT         STORE UPDATED COUNT\n*\n         LA    R2,45(,R2)          INCREMENT TO NEXT RETURNED FIELD\n         SH    R3,=H'45'           DECREMENT LENGTH\n         BP    DSNBUILD            LOOP IF MORE DATA LEFT\n*\n         DROP  R4\n*\n         B     MAINLOOP            AND GO GET THE NEXT HIGH LEVEL QUAL\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CLOSE THE OUTPUT CATALOG DATA FILE                           *\n*                                                                     *\n***********************************************************************\n*\nALLDONE  DS    0H\n         CLOSE (CATFILE)           CLOSE THE OUTPUT FILE\n         FREEPOOL CATFILE          FREE THE BUFFER POOL\n*\n***********************************************************************\n*                                                                     *\n*        FREE THE LOCATE WORK AREA                                    *\n*                                                                     *\n***********************************************************************\n*\n         ICM   R1,15,LOCWORKA      LOAD THE WORK AREA ADDRESS\n         BZ    NOLOCFRE            BRANCH IF NONE\n*\n         L     R0,LOCWORKS         LOAD THE SIZE TO FREE\n         FREEMAIN RU,A=(1),LV=(0),SP=99 FREE THE LOCATE WORK AREA\n*\n*\nNOLOCFRE DS    0H\n*\n***********************************************************************\n*                                                                     *\n*        RETURN TO CALLER                                             *\n*                                                                     *\n***********************************************************************\n*\n         L     R13,4(,R13)         UNCHAIN THE SAVE AREA\n         LM    R14,R12,12(R13)     RELOAD THE REGISTERS\n         SLR   R15,R15             SET THE RETURN CODE\n         BR    R14                 RETURN TO CALLER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        VARIOUS ABEND ROUTINES                                       *\n*                                                                     *\n***********************************************************************\n*\nPARMINVL DS    0H\n         ABEND 10,DUMP\n*\nPARMERR1 DS    0H\n         ABEND 20,DUMP\n*\nPARMERR2 DS    0H\n         ABEND 30,DUMP\n*\nCATOPENE DS    0H\n         ABEND 40,DUMP\n*\nLOCBAD1  DS    0H\n         ABEND 50,DUMP\n*\nLOCBAD2  DS    0H\n         ABEND 60,DUMP\n*\n         EJECT\nLITERALS LTORG ,\n*\n         EJECT\nCCCBKLOD CSECT\nCCCBKLOD AMODE 24\nCCCBKLOD RMODE 24\n*\nSAVEAREA DC    9D'0'               REGISTER SAVE AREA\n*\nDOUBLE   DS    D                   DOUBLE WORD WORK AREA\n*\nHLQCOUNT DC    F'0'                COUNT OF HIGH LEVEL QUALIFIERS\nHLQTABLE DC    16CL8' '            HIGH LEVEL QUALIFIER TABLE\nHLQMAX   EQU   (*-HLQTABLE)/L'HLQTABLE  SET COUNT OF HIGH LEVEL INDICES\n*\nDSNCOUNT DC    F'0'                COUNT OF DATA SETS LOCATED\n*\nPARMHOLD DS    CL16                AREA TO HOLD THE PARM HIGH LEVEL Q\n*\nGETMCNT  DC    F'0'                COUNT OF WORK AREA GETMAINS\nLOCWORKA DC    A(0)                ADDRESS OF LOCATE WORK AREA\nLOCWORKS DC    F'0'                SIZE OF LOCATE WORK AREA\n*\n         DS    0D\nBLANKS   DC    CL128' '            AREA FOR BLANKING AND UPPERCASING\n*\nLOCPARM  DC    0D'0'\n         DC    B'00000101'\n         DC    B'00000000'\n         DC    B'00010001'\n         DC    B'00000000'\n         DC    A(LOCLENG)\n         DC    A(0)\nLOCWORK  DC    A(*-*)\n         DC    B'00000100'\n         DC    B'00000000'\n         DC    C'A'\n         DC    AL1(0)\n         DC    A(0)\n         DC    H'0'\n         DC    B'00000000'\n         DC    X'00'\n         DC    A(0)\n         DC    A(0)\n*\n         DS    0D\nLOCLENG  DS    AL1\nLOCDSN   DS    CL44\n*\n         DS    0D\nCATRECRD DS    CL(BKLLNGTH)        RECORD BUILD WORK AREA\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n         EJECT\n         PRINT NOGEN\n*\nCATFILE  DCB   DSORG=PS,                                               X\n               DDNAME=CATFILE,                                         X\n               MACRF=PM,                                               X\n               RECFM=FB,                                               X\n               LRECL=BKLLNGTH\n*\n         PRINT GEN\n*\n         BKMGRLOC\n*\n         END   CCCBKLOC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCCBKPUB": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x94\\x03\\x1f\\x00\\x95&_\\x15$\\x03\\x0f\\x02\\x8d\\x00\\xab\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1994-01-31T00:00:00", "modifydate": "1995-09-22T15:24:00", "lines": 783, "newlines": 653, "modlines": 171, "user": "KEM00"}, "text": "BKPUB    TITLE 'TSO COMMAND TO RETURN PROPER PUBLICATION NUMBER'\n***********************************************************************\n*                                                                     *\n*        CCCBKPUB                                                     *\n*                                                                     *\n*        THIS PROGRAM IS A TSO COMMAND OR PROGRAM THAT IS DESIGNED    *\n*        TO RUN IN A CLIST OR REXX EXEC OR CALLED INTERNALLY.  IT     *\n*        WILL TAKE AN IBM PUBLICATION NUMBER AND CONVERT IT TO        *\n*        A UNIFORM 12 CHARACTER FORMAT OF XXNN-NNNN-NN.  THE          *\n*        DATA IS RETURNED IN EITHER CLIST VARIABLES OR IN AN          *\n*        AREA POINTED TO BY THE PARAMETER LIST.                       *\n*                                                                     *\n*        INPUT(1) TSO COMMAND PARAMETER LIST WITH TWO POSITIONAL      *\n*                 PARAMETERS - THE ORIGINAL PUBLICATION NUMBER        *\n*                 CHARACTER STRING AND THE NAME OF THE RETURN         *\n*                 CLIST/REXX VARIABLE.                                *\n*                                                                     *\n*        INPUT(2) CALLED PROGRAM PARAMETER LIST CONSISTING OF THE     *\n*                 PUBLICATION NUMBER AND THE CLIST/REXX VARIABLE      *\n*                 NAME SEPARATED BY A COMMA.                          *\n*                                                                     *\n*        INPUT(3) TWO WORD PARAMETER LIST WITH THE FIRST WORD         *\n*                 BEING THE ADDRESS OF THE 12 CHARACTER PUBLICATION   *\n*                 NUMBER (PADDED WITH BLANKS) AND THE SECOND WORD     *\n*                 BEING THE ADDRESS OF THE 12 BYTE RETURN AREA.       *\n*                                                                     *\n*        NOTE -   IN ORDER FOR THE PROGRAM TO DETECT THE VARIOUS      *\n*                 TYPES OF PARAMETER LIST, IT IS REQUIRED THAT THE    *\n*                 LAST PARAMETER BE FLAGGED WITH THE HIGH ORDER       *\n*                 BIT ON.                                             *\n*                                                                     *\n*        OUTPUT - SPECIFIED VARIABLE NAME SET TO THE APPROPRIATE      *\n*                 PUBLICATION NUMBER OR SET TO \"*999\" FOLLOWED        *\n*                 BY 8 CHARACTERS OF THE PUBLICATION NUMBER IF        *\n*                 IT CANNOT BE CONVERTED.                             *\n*                                                                     *\n*                 RETURN CODE 0 - VALID PUBLICATION - VARIABLE SET    *\n*                 RETURN CODE 4 - INVALID PUBLICATION VALUE           *\n*                 RETURN CODE 8 - NOT WITHIN A CLIST                  *\n*                 RETURN CODE 12 - SERIOUS ERROR IN PROGRAM           *\n*                 RETURN CODE 16 - UNABLE TO LOCATE DEFINITION MODULE *\n*                                                                     *\n*        IF THE PROGRAM DETECTS THAT THE PUBLICATION NUMBER IS A      *\n*        UNIVERSAL SALES MANUAL PUBLICATION, IT WILL INVOKE           *\n*        CCCBKDEF TO OBTAIN THE CURRENT USM LEVEL.                    *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, AMODE 31, RMODE ANY,    *\n*                     UNAUTHORIZED                                    *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\nCCCBKPUB CSECT\nCCCBKPUB AMODE 31\nCCCBKPUB RMODE ANY\n*\n         USING CCCBKPUB,R15\n         B     AROUNDID\n         DC    AL1(33)\n         DC    CL8'CCCBKPUB'\n         DC    CL8'V 1.1.0'\n         DC    CL8'&SYSDATE'\n         DC    CL8' &SYSTIME'\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n*\n         LR    R12,R15             LOAD REGISTER 12 WITH ENTRY\n         DROP  R15\n         USING CCCBKPUB,R12        ESTABLISH ADDRESSABILITY\n*\n         LR    R8,R1               LOAD REGISTER 8 TO PRESERVE PARMADDR\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         GETMAIN RU,LV=(0),LOC=(BELOW,ANY)\n         LR    R14,R1              COPY FOR THE MOVE LONG\n         LA    R15,WORKLENG        GET THE LENGTH\n         SLR   R3,R3\n         MVCL  R14,R2              CLEAR THE AREA\n*\n         ST    R13,4(,R1)          STORE ADDRESS OF PREVIOUS\n*\n         ST    R1,8(,R13)          STORE ADDRESS OF CURRENT\n*\n         LR    R13,R1              LOAD REGISTER 13 WITH SAVEAREA\n*\n         USING WORKAREA,R13        ESTABLISH ADDRESSABILITY\n*\n         MVI   MODEFLAG,0          INITIALIZE THE MODE FLAG\n*\n         MVI   VARINAME,C' '       BLANK OUT THE VARIBALE NAME BUF\n         MVC   VARINAME+1(L'VARINAME-1),VARINAME\n*\n         MVI   PUBNOIN,C' '        PRE-BLANK OUT THE\n         MVC   PUBNOIN+1(L'PUBNOIN-1),PUBNOIN INPUT PUB NUMBER\n*\n         MVI   PUBNOOUT,C' '       PRE-BLANK OUT THE\n         MVC   PUBNOOUT+1(L'PUBNOOUT-1),PUBNOOUT RETURN DATA FIELD\n*\n         XC    RETCODE,RETCODE     ASSUME GOOD RETURN CODE\n*\n         TM    0(R8),X'80'         TEST FOR ONE WORD PARM LIST\n         BO    CALLPARM            IF SO, THIS IS A CALLED PARAMETER\n         TM    4(R8),X'80'         TEST FOR A TWO WORD PARAMETER LIST\n         BO    PGMPARM             IF SO, THIS IS A PROGRAM PARM\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARAMETER LIST                                   *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\nCMDPARM  DS    0H\n         OI    MODEFLAG,MODECMD    INDICATE WE HAVE A TSO CPPL\n*\n         USING CPPL,R8             ESTABLISH ADDRESSABILITY TO CPPL\n*\n         LA    R4,PPLSECT          LOAD ADDRESS OF PARSE PARAMETER\n         USING PPL,R4              ESTABLISH ADDRESSABILITY TO PPL\n*\n         L     R1,CPPLUPT          LOAD POINTER TO USER PROFILE\n         L     R2,CPPLECT          LOAD POINTER TO ENVIRONMENT\n*                                  CONTROL TABLE FROM CPPL\n         SLR   R3,R3               ZERO REGISTER 3\n         ST    R3,ECB              STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB              LOAD ADDRESS OF ECB\n         STM   R1,R3,PPLSECT       STORE ADDRESS OF UPT, ECT, AND\n*                                  ECB IN PPL\n         MVC   PPLPCL,PCLADDR      MOVE POINTER TO PARAMETER\n*                                  CONTROL LIST INTO PPL\n         LA    R2,PARSBACK         LOAD ADDRESS OF FULLWORD TO\n*                                  CONTAIN ADDRESS OF PDE RETURNED\n*                                  BY PARSE\n         ST    R2,PPLANS           STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF    MOVE POINTER TO COMMAND BUFFER\n*                                  INTO PPL\n         LA    R2,PPLUWA           LOAD ADDRESS OF USER WORK AREA\n         ST    R2,PPLUWA           STORE ADDRESS IN PPL\n         DROP  R4,R8               DROP ADDRESSABILITY\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*        HANDLE ALL ERROR CODES RETURNED BY PARSE                     *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)\n*                                  CALL PARS TO PARSE COMMAND\n         LTR   R15,R15             SEE IF RETURN CODE IS ZERO\n         BNZ   BADPARSE            NO, BAD NEWS\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND PROCESS THE PARAMETERS                                *\n*                                                                     *\n***********************************************************************\n*\n         L     R9,PARSBACK         LOAD POINTER TO PARSE ANSWER\n         USING IKJPARMD,R9         ESTABLISH ADDRESSABILITY TO PDL\n*\n         LA    R6,PUBINPUT         LOAD POINTER TO PUB NUMBER PDE\n         L     R5,0(R6)            LOAD POINTER TO PUB NUMBER DATA\n         LH    R4,4(R6)            LOAD LENGTH OF PUB NUMBER DATA\n         BCTR  R4,0                DECREMENT LENGTH FOR EXECUTE OF MVC\n*\n         EX    R4,PARSPUB          MOVE IN THE PUBLICATION NUMBER\n*\n         LA    R6,VARIABLE         LOAD POINTER TO VARIABLE PDE\n         L     R5,0(R6)            LOAD POINTER TO VARIABLE DATA\n         LH    R4,4(R6)            LOAD LENGTH OF VARIABLE\n         ST    R4,NAMELENG         SAVE THIS LENGTH FOR SERVICE\n         BCTR  R4,0                DECREMENT LENGTH FOR EXECUTE OF MVC\n*\n         EX    R4,PARSVARI         MOVE IN THE VARIBALE NAME\n*\n         DROP  R9                  DROP ADDRESSABILITY TO PDL\n*\n         B     GETPUBNO            AND GO DECODE THE REQUEST\n*\nPARSPUB  MVC   PUBNOIN(*-*),0(R5)  *** EXECUTE ONLY ***\nPARSVARI MVC   VARINAME(*-*),0(R5) *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROGRAM HAS BEEN INVOKED WITH A ONE WORD PARAMETER LIST      *\n*        IN THE FORMAT OF THE CALL/JCL PARAMETER.  SCAN FOR THE       *\n*        PUBLICATION NUMBER AND RETURN VARIABLE NAME.                 *\n*                                                                     *\n***********************************************************************\n*\nCALLPARM DS    0H\n         OI    MODEFLAG,MODECALL   INDICATE WE HAVE A CALL PROGRAM PARM\n*\n         L     R2,0(,R8)           LOAD THE ADDRESS OF THE PARM STRING\n         LH    R3,0(,R2)           LOAD THE STRING LENGTH\n         LA    R2,2(,R2)           POINT AT ACTUAL FIRST CHARACTER\n*\n         CH    R3,=H'3'            CHECK MINIMUM LENGTH\n         BL    BADPARM             RETURN BAD NEWS IF TOO SMALL\n*\n         LR    R1,R2               SET SCAN POINTER\n*\nCALLLP1  DS    0H\n         CLI   0(R1),C','          LOOK FOR DELIMITER\n         BE    CALLCOMA            BRANCH WHEN FOUND\n         LA    R1,1(,R1)           INCREMENT SCAN POINTER\n         BCT   R3,CALLLP1          LOOP LOOKING FOR COMMA\n         B     BADPARM             IF NOT COMMA, BAD NEWS\n*\nCALLCOMA DS    0H\n         LR    R15,R1              COPY FOR LENGTH CALCULATION\n         SR    R15,R2              CALCULATE LENGTH\n         BNH   BADPARM             NOT GOOD IF ZERO (OR LESS!)\n         CH    R15,=Y(L'PUBNOIN)   CHECK MAXIMUM LENGTH\n         BH    BADPARM             ERROR IF TOO BIG\n*\n         BCTR  R15,0               DECREMENT FOR MVC INSTRUCTION\n         EX    R15,CALLPUB         MOVE THE PUBLICATION NUMBER\n*\n         LA    R1,1(,R1)           INCREMENT PAST THE COMMA\n         BCT   R3,*+8              DECREMENT THE COMMA\n         B     BADPARM             ERROR IF COMMA THE LAST THING\n*\n         CH    R3,=Y(L'VARINAME)   CHECK REMAINING LENGTH\n         BH    BADPARM             ERROR IF TOO BIG\n         ST    R3,NAMELENG         SAVE THIS LENGTH FOR SERVICE\n*\n         BCTR  R3,0                DECREMENT THE LENGTH FOR MVC\n         EX    R3,CALLVARI         MOVE THE VARIABLE NAME\n*\n         EX    R3,CALLTRT          SCAN FOR VALID CHARACTERS\n         BNZ   BADPARM             ERROR ID ANY BAD ONES\n*\n         CLI   VARINAME,C'0'       MAKE SURE THAT FIRST CHARACTER IS\n         BNL   BADPARM             NOT NUMERIC\n*\n         B     GETPUBNO            AND GO DECODE THE REQUEST\n*\nCALLPUB  MVC   PUBNOIN(*-*),0(R2)  *** EXECUTE ONLY ***\nCALLVARI MVC   VARINAME(*-*),0(R1) *** EXECUTE ONLY ***\nCALLTRT  TRT   VARINAME(*-*),ALPHANUM   *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROGRAM HAS BEEN INVOKED WITH A TWO WORD PARAMETER LIST      *\n*        EXTRACT PUBLICATION NUMBER AND SAVE THE RETURN DATA          *\n*        ADDRESS.                                                     *\n*                                                                     *\n***********************************************************************\n*\nPGMPARM  DS    0H\n         OI    MODEFLAG,MODEPGM    INDICATE WE HAVE AN INTERNAL PROGRAM\n*\n         L     R1,0(,R8)           LOAD THE ADDRESS OF THE DEF KEY\n         MVC   PUBNOIN,0(R1)       COPY THE PUBLICATION NUMBER\n*\n         L     R1,4(,R8)           LOAD THE RETURN DATA ADDRESS\n         ST    R1,DATARETA         STORE THE RETURN DATA ADDRESS\n*\n         B     GETPUBNO            AND GO DECODE THE REQUEST\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT A PUBLICATION NUMBER                               *\n*                                                                     *\n***********************************************************************\n*\nGETPUBNO DS    0H\n         LA    R14,12              LOAD MAXIMUM LENGTH\n         LA    R15,PUBNOIN+L'PUBNOIN-1  POINT AT LAST CHARACTER\n*\nGETPUBLN CLI   0(R15),C' '         LOOK FOR THE BLANK\n         BNE   GOTPUBLN            BRANCH IF NON BLANK\n         BCTR  R15,0               BACK UP ONE CHARACTER\n         BCT   R14,GETPUBLN        LOOP TO CALCULATE THE LENGTH\n*\nGOTPUBLN DS    0H\n         LR    R0,R14              SAVE THE LENGTH\n         SLL   R14,2               MULTIPLE LENGTH BY 4\n*\n         B     GETPUBTB(R14)       BRANCH BASED ON THE PUB NUMBER LENG\nGETPUBTB DS    0H\n         B     GETPUB00            ZERO LENGTH\n         B     GETPUB01            LENGTH 1\n         B     GETPUB02            LENGTH 2\n         B     GETPUB03            LENGTH 3\n         B     GETPUB04            LENGTH 4\n         B     GETPUB05            LENGTH 5\n         B     GETPUB06            LENGTH 6\n         B     GETPUB07            LENGTH 7\n         B     GETPUB08            LENGTH 8\n         B     GETPUB09            LENGTH 9\n         B     GETPUB10            LENGTH 10\n         B     GETPUB11            LENGTH 11\n         B     GETPUB12            LENGTH 12\n*\nGETPUB12 DS    0H\n         MVC   PUBNOOUT,PUBNOIN    SET THE FULL PUBLICATION NUMBER\n*\n         OI    MODEFLAG,MODEWELL   INDICATE WELL-FORMED PUB NUMBER\n*\n         B     GOTPUBNO            CONTINUE\n*\nGETPUB11 DS    0H\n         MVC   PUBNOOUT(10),PUBNOIN     SET THE PUBLICATION NUMBER\n         MVI   PUBNOOUT+10,C'0'    ZERO PAD THE REVISION LEVEL\n         MVC   PUBNOOUT+11(1),PUBNOIN+10 MOVE THE REVISION LEVEL\n*\n         OI    MODEFLAG,MODEWELL   INDICATE WELL-FORMED PUB NUMBER\n*\n         B     GOTPUBNO            CONTINUE\n*\nGETPUB10 DS    0H\n         MVC   PUBNOOUT(10),PUBNOIN     SET THE PUBLICATION NUMBER\n         MVC   PUBNOOUT+10(2),=C'00'    ZERO THE REVISION LEVEL\n*\n         B     GOTPUBNO            CONTINUE\n*\nGETPUB09 DS    0H\n         MVC   PUBNOOUT(9),PUBNOIN      SET THE PUBLICATION NUMBER\n         MVC   PUBNOOUT+9(3),=C'-00'    ZERO THE REVISION LEVEL\n*\n         B     GOTPUBNO            CONTINUE\n*\nGETPUB08 DS    0H\n         CLC   PUBNOIN(5),=C'WDNHW'     CHECK FOR USM WITHDRAWN HDW\n         BE    GETPUBWH            BRANCH IF SO\n         CLC   PUBNOIN(5),=C'WDNSW'     CHECK FOR USM WITHDRAWN SOFTW\n         BE    GETPUBWS            BRANCH IF SO\n         CLC   PUBNOIN(5),=C'PRICE'     CHECK FOR THE USM PRICES MANUAL\n         BE    GETPUBPR            BRANCH IF SO\n*\n         CLI   PUBNOIN,C'M'        CHECK FOR NEW HARDWARE MANUALS\n         BE    GETPUBHM            BRANCH IF SO\n         CLI   PUBNOIN,C'P'        CHECK FOR NEW SOFTWARE MANUALS\n         BE    GETPUBSP            BRANCH IF SO\n         CLI   PUBNOIN,C'S'        CHECK FOR NEW SOFTWARE MANUALS\n         BE    GETPUBSS            BRANCH IF SO\n*\n         B     GETPUBXX            IF NOT, GO TO GENERAL BAD ROUTINE\n*\nGETPUB07 DS    0H\n         CLC   PUBNOIN(5),=C'WDNHW'     CHECK FOR USM WITHDRAWN HDW\n         BE    GETPUBWH            BRANCH IF SO\n         CLC   PUBNOIN(5),=C'WDNSW'     CHECK FOR USM WITHDRAWN SOFTW\n         BE    GETPUBWS            BRANCH IF SO\n         CLC   PUBNOIN(5),=C'PRICE'     CHECK FOR THE USM PRICES MANUAL\n         BE    GETPUBPR            BRANCH IF SO\n*\n         B     GETPUBXX            IF NOT, GO TO GENERAL BAD ROUTINE\n*\nGETPUB05 DS    0H\n         CLC   PUBNOIN(2),=C'HW'   CHECK FOR THE USM HARDWARE MANUALS\n         BE    GETPUBHW            BRANCH IF SO\n         CLC   PUBNOIN(2),=C'SW'   CHECK FOR THE USM SOFTWARE MANUALS\n         BE    GETPUBSW            BRANCH IF SO\n*\n         CLI   PUBNOIN,C'M'        CHECK FOR NEW HARDWARE MANUALS\n         BE    GETPUBHM            BRANCH IF SO\n         CLI   PUBNOIN,C'P'        CHECK FOR NEW SOFTWARE MANUALS\n         BE    GETPUBSP            BRANCH IF SO\n         CLI   PUBNOIN,C'S'        CHECK FOR NEW SOFTWARE MANUALS\n         BE    GETPUBSS            BRANCH IF SO\n*\n         B     GETPUBXX            IF NOT, GO TO GENERAL BAD ROUTINE\n*\nGETPUB00 DS    0H\n         LA    R0,1                INDICATE A LENGTH OF ONE\n*\nGETPUB06 DS    0H\n*\nGETPUB04 DS    0H\n*\nGETPUB03 DS    0H\n*\nGETPUB02 DS    0H\n*\nGETPUB01 DS    0H\n         B     GETPUBXX            GO TO THE BAD BOOK ROUTINE\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        UNIVERSAL SALE MANUAL PRICES BOOKS                           *\n*                                                                     *\n***********************************************************************\n*\nGETPUBPR DS    0H\n         OI    MODEFLAG,MODEUSM    INDICATE THAT THIS IS A USM BOOK\n*\n         MVC   PUBNOOUT(L'USMPREFX),USMPREFX MOVE IN THE USM PREFIX\n         MVC   PUBNOOUT+L'USMPREFX(2),PUBNOIN  MOVE IN TWO CHARACTERS\n         MVC   PUBNOOUT+L'USMPREFX+2(2),PUBNOIN+5 MOVE IN TWO MOVE\n*\n         CLI   PUBNOIN+7,C' '      CHECK FOR 8 CHARACTER PRICE MANUAL\n         BE    GOTPUBNO            BRANCH IF SO\n         MVC   PUBNOOUT+L'USMPREFX+3(1),PUBNOIN+7 MOVE IN LAST DIGIT\n*\n         B     GOTPUBNO\n*\n***********************************************************************\n*                                                                     *\n*        UNIVERSAL SALE MANUAL WITHDRAWN HARDWARE/SOFTWARE BOOKS      *\n*                                                                     *\n***********************************************************************\n*\nGETPUBWH DS    0H\nGETPUBWS DS    0H\n         TM    PUBNOIN+5,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n         TM    PUBNOIN+6,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n         TM    PUBNOIN+7,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n*\n         OI    MODEFLAG,MODEUSM    INDICATE THAT THIS IS A USM BOOK\n*\n         MVC   PUBNOOUT(L'USMPREFX),USMPREFX SET THE USM PREFIX\n         MVC   PUBNOOUT+L'USMPREFX(1),PUBNOIN COPY THE \"W\" OF WDN\n         MVC   PUBNOOUT+L'USMPREFX+1(1),PUBNOIN+3 COPY THE \"S\" OR \"H\"\n         MVC   PUBNOOUT+L'USMPREFX+2(2),PUBNOIN+6 COPY THE NUMBER\n*\n         B     GOTPUBNO            CONTINUE\n*\n***********************************************************************\n*                                                                     *\n*        UNIVERSAL SALE MANUAL ORIGINAL HARDWARE/SOFTWARE BOOKS       *\n*                                                                     *\n***********************************************************************\n*\nGETPUBHW DS    0H\nGETPUBSW DS    0H\n         TM    PUBNOIN+2,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n         TM    PUBNOIN+3,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n         TM    PUBNOIN+4,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n*\n         OI    MODEFLAG,MODEUSM    INDICATE THAT THIS IS A USM BOOK\n*\n         MVC   PUBNOOUT(L'USMPREFX),USMPREFX SET THE USM PREFIX\n         MVC   PUBNOOUT+L'USMPREFX(2),PUBNOIN COPY THE \"HW\" OR \"SW\"\n         MVC   PUBNOOUT+L'USMPREFX+2(2),PUBNOIN+3 COPY THE NUMBER\n*\n         B     GOTPUBNO            CONTINUE\n*\n***********************************************************************\n*                                                                     *\n*        UNIVERSAL SALE MANUAL NEW HARDWARE/SOFTWARE BOOKS            *\n*                                                                     *\n***********************************************************************\n*\nGETPUBHM DS    0H\n         TM    PUBNOIN+1,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n         TM    PUBNOIN+2,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n*\n         B     GETPUBUS            SO SET USM\n*\nGETPUBSP DS    0H\nGETPUBSS DS    0H\n         TM    PUBNOIN+1,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n         TM    PUBNOIN+2,X'F0'     TEST FOR A NUMERIC\n         BNO   GETPUBXX            IF NOT, IT'S BAD\n*\n         B     GETPUBUS            SO SET USM\n*\nGETPUBUS DS    0H\n         OI    MODEFLAG,MODEUSM    INDICATE THAT THIS IS A USM BOOK\n*\n         MVC   PUBNOOUT(L'USMPREFX),USMPREFX SET THE USM PREFIX\n         MVC   PUBNOOUT+3(1),PUBNOIN    COPY THE M/P/S\n         MVC   PUBNOOUT+L'USMPREFX(4),PUBNOIN+1 COPY IN THE ###%\n*\n         B     GOTPUBNO\n*\n***********************************************************************\n*                                                                     *\n*        THIS IS WHERE WE END UP IF WE CAN'T MAKE SENSE OF THE        *\n*        PUBLICATION NUMBER WE'VE FOUND.                              *\n*                                                                     *\n***********************************************************************\n*\nGETPUBXX DS    0H\n         MVC   PUBNOOUT(L'INVPREFX),INVPREFX SET INVALID PREFIX\n         LR    R14,R0              COPY THE LENGTH AGAIN\n         BCTR  R14,0               DECREMENT FOR THE MVC\n         EX    R14,GETPUBNV        MOVE THE PUBLICATION NUMBER\n         B     GOTPUBNO            CONTINUE\n*\nGETPUBNV MVC   PUBNOOUT+L'INVPREFX(*-*),PUBNOIN  *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DETERMINE THE UNIVERSAL SALES MANUAL LEVEL (IF NEEDED)       *\n*                                                                     *\n***********************************************************************\n*\nGOTPUBNO DS    0H\n         TM    MODEFLAG,MODEUSM    IS THIS A UNIVERSAL SALES MANUAL PUB\n         BZ    NOUSM               BRANCH IF NOT\n*\n         TM    MODEFLAG,MODEWELL   DOES IT ALREADY HAVE A SUFFIX\n         BO    NOUSM               BRANCH IF SO, DON'T OVERLAY\n*\n         LA    R0,USMCODE          POINT AT USMLEVEL CODE WORD\n         ST    R0,DEFPARMS+0       STORE IN PARM LIST\n         LA    R0,USMLEVEL         POINT AT RETURN DATA AREA\n         ST    R0,DEFPARMS+4       STORE IN PARM LIST\n         OI    DEFPARMS+4,X'80'    INDICATE END OF PARM LIST\n*\n         LOAD  EPLOC=DEFMODUL,ERRET=NODATA\n*\n         LR    R15,R0              COPY THE ENTRY POINT\n         LA    R1,DEFPARMS         POINT AT PARAMETER LIST\n         BASSM R14,R15             CALL THE DEFINITION MODULE\n*\n         LR    R3,R15              SAVE THE RETURN CODE\n         DELETE EPLOC=DEFMODUL     DELETE THE DEFINITION MODULE\n*\n         LTR   R3,R3               CHECK IF USMLEVEL WAS SUCCESSFUL\n         BNZ   NODATA              THIS IS NOT VERY GOOD\n*\n         MVI   PUBNOOUT+L'USMPREFX+4,C'-' SET THE DELIMITER\n         MVC   PUBNOOUT+L'USMPREFX+5(2),USMLEVEL COPY THE RETURNED LVL\n*\nNOUSM    DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT THE PARAMETER LIST FOR IKJCT441                    *\n*                                                                     *\n***********************************************************************\n*\nCRE8VARI DS    0H\n         TM    MODEFLAG,MODEPGM    IS THIS A PROGRAM TO RETURN DATA TO\n         BZ    GODOVARI            IF NOT, GO CREATE THE VARIABLE\n*\n         L     R15,DATARETA        LOAD THE RETURN DATA ADDRESS\n         MVC   0(L'PUBNOOUT,R15),PUBNOOUT COPY THE RETURN DATA\n         B     ALLDONE\n*\nGODOVARI DS    0H\n         L     R3,CVTPTR           FIND CVT\n         USING CVTMAP,R3\n*\n         L     R3,CVTTVT           FIND THE TSVT\n         USING TSVT,R3\n*\n         LA    R0,TSVEUPDT\n         ST    R0,ENTRYCDE\n         LA    R0,ENTRYCDE\n         ST    R0,CT441PRM+0\n*\n         LA    R0,VARINAME\n         ST    R0,NAMEADDR\n         LA    R0,NAMEADDR\n         ST    R0,CT441PRM+4\n*\n         LA    R0,NAMELENG\n         ST    R0,CT441PRM+8\n*\n         LA    R0,DATAADDR\n         ST    R0,CT441PRM+12\n*\n         LA    R0,DATALENG\n         ST    R0,CT441PRM+16\n*\n         LA    R0,TOKENPRM\n         ST    R0,CT441PRM+20\n         OI    CT441PRM+20,X'80'\n*\n         LA    R1,PUBNOOUT\n         ST    R1,DATAADDR\n*\n         LA    R0,L'PUBNOOUT       LOAD OUTPUT DATA LENGTH\n         AR    R1,R0               POINT PAST END OF STRING\n*\nCALCLOOP BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BH    CALCSTOR\n         BCT   R0,CALCLOOP\n*\n         LA    R0,1\n*\nCALCSTOR DS    0H\n         ST    R0,DATALENG\n*\n         LA    R1,CT441PRM         POINT AT PARM LIST\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BALR  R14,R15             GO CALL VARIABLE ROUTINE\n*\n         LTR   R15,R15             TEST IF RETURN WAS GOOD\n         BNZ   NOTCLIST            ASSUME WE AREN'T IN CLIST IF BAD\n*\nALLDONE  DS    0H\n         B     RETURN\n*\n         DROP  R3                  DONE WITH TSVT\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ERROR CONDITIONS                                             *\n*                                                                     *\n***********************************************************************\n*\nNOTCLIST LA    R0,8                SET WE AREN'T IN A CLIST ENV\n         ST    R0,RETCODE\n         B     RETURN\n*\nBADPARM  DS    0H\nBADPARSE LA    R0,12               SET SERIOUS ERROR\n         ST    R0,RETCODE\n         B     RETURN\n*\nNODATA   LA    R0,16               SET NO DATA MODULE FOUND\n         ST    R0,RETCODE\n         B     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARSE,                            *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         TM    MODEFLAG,MODECMD    IS THIS A TSO COMMAND\n         BZ    NOPARSEF            BRANCH IF NOT\n         IKJRLSA PARSBACK          RELEASE AREAS GETMAINED BY PARS\n*\nNOPARSEF DS    0H\n         L     R2,RETCODE          LOAD THE RETURN CODE\n*\n         LR    R1,R13              LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)         RELOAD ADDRESS OF PREVIOUS SAVE\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN RU,LV=(0),A=(1)  FREE GETMAINED AREA\n*\n         LR    R15,R2              SET THE RETURN CODE\n         L     R14,12(,R13)        LOAD REGISTER 14 WITH RETURN\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\n*\n         EJECT\nPATCH    DC    0D'0',32S(*)\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\nDEFMODUL DC    CL8'CCCBKDEF'       DATA INFORMATION PROGRAM\n*\nUSMCODE  DC    CL16'USMLEVEL'      USM LEVEL CODE WORD\n*\nUSMPREFX DC    C'ZUSM-'            USM PREFIX\n*\nINVPREFX DC    C'*999'             INVALID NUMBER PREFIX\n*\nLITERALS LTORG ,\n*\nPCLADDR  DC    V(PARMTAB)\n*\nALPHANUM DC    256X'FF'            ALPHANUMERIC TEST TABLE\n         ORG   ALPHANUM+C'$'\n         DC    X'00'\n         ORG   ALPHANUM+C'#'\n         DC    X'00'\n         ORG   ALPHANUM+C'@'\n         DC    X'00'\n         ORG   ALPHANUM+C'A'\n         DC    9X'00'\n         ORG   ALPHANUM+C'J'\n         DC    9X'00'\n         ORG   ALPHANUM+C'S'\n         DC    8X'00'\n         ORG   ALPHANUM+C'0'\n         DC    10X'00'\n         ORG   ,\n*\n         EJECT\n************************ PARS PARAMETER LIST **************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nPARMTAB  AMODE 31\nPARMTAB  RMODE ANY\n*\nPUBINPUT IKJIDENT 'PUBNUMBER',UPPERCASE,                               X\n               FIRST=ALPHA,OTHER=ANY,MAXLNTH=12,                       X\n               PROMPT='PUBLICATION NUMBER',                            X\n               HELP='IBM PUBLICATION NUMBER'\n*\nVARIABLE IKJIDENT 'VARIABLE',UPPERCASE,                                X\n               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=32,                  X\n               PROMPT='VARIABLE NAME',                                 X\n               HELP='REXX/CLIST VARIABLE NAME'\n         IKJENDP\n*\n         EJECT\n************************ DSECTS (MAPPING MACROS) **********************\n         PRINT NOGEN\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n*\n         IKJPPL\nPPLLEN   EQU   *-PPL\n*\n         CVT   DSECT=YES\n*\n         IKJTSVT\n*\n*\n         PRINT GEN\n*\nWORKAREA DSECT\nSAVEAREA DS    9D\nRETCODE  DS    F\n*\n         DS    0D\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\n*\nECB      DS    F\nPARSBACK DS    F\n*\nCT441PRM DS    6F\n*\nENTRYCDE DS    F\nNAMEADDR DS    A                   ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                   LENGTH OF VARIABLE NAME\nDATAADDR DS    A                   ADDRESS OF VARIABLE DATA\nDATALENG DS    F                   LENGTH OF DATA\nTOKENPRM DS    F\n*\nVARINAME DS    CL32                VARIABLE NAME FIELD\n*\nPUBNOIN  DS    CL12                INPUT PUBLICATION NUMBER\nPUBNOOUT DS    CL12                RETURNED DATA FIELD\n*\nDATARETA DS    A                   ADDRESS OF THE RETURN DATA\n*\nDEFPARMS DS    2A                  PARM LIST FOR DEFINITION MODULE\n*\nUSMLEVEL DS    CL64                RETURNED DATA FROM DEFINITION SUB\n*\nMODEFLAG DS    X                   PROGRAM MODE\nMODECMD  EQU   X'80'               INVOKED AS A TSO COMMAND\nMODECALL EQU   X'40'               INVOKED AS A CALLED PROGRAM\nMODEPGM  EQU   X'20'               INVOKED AS AN INTERNAL CALL\nMODEWELL EQU   X'02'               WELL FORMED PUB NUMBER\nMODEUSM  EQU   X'01'               PUBLICATION IS PART OF THE USM\n*\n         DS    0D\nWORKLENG EQU   *-WORKAREA\n*\n         END   CCCBKPUB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCCBKSRV": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00\\x00\\x00\\x99'O\\x00\\x99(\\x0f\\x171\\x06L\\x00\\xa7\\x05\\xef\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-10-01T00:00:00", "modifydate": "1999-10-07T17:31:00", "lines": 1612, "newlines": 167, "modlines": 1519, "user": "KEM00"}, "text": "BKSRV    TITLE 'BOOKSERVER FRONT-END SERVICE PROGRAM'\n***********************************************************************\n*                                                                     *\n*        CCCBKSRV                                                     *\n*                                                                     *\n*        THIS PROGRAM IS DESIGNED TO BE INVOKED FROM REXX VIA THE     *\n*        \"LINKMVS\" FACILITY.  IT WILL PERFORM A VARIETY OF FUNCTIONS  *\n*        BASED ON THE PARAMETERS PASSED TO IT.                        *\n*                                                                     *\n*        PARAMETERS ARE PASSED IN THE REXX LINKMVS FORMAT. EACH       *\n*        ONE CONSISTS OF A HALFWORD LENGTH FOLLOWED BY THE            *\n*        PARAMETER IN CHARACTER FORMAT.                               *\n*                                                                     *\n*        PARAMETER 1: FUNCTION                                        *\n*              'BKSC' - COUNT OF BOOKSHELVES                          *\n*              'BOOC' - COUNT OF UNIQUE BOOKS                         *\n*              'SRCH' - SEARCH BOOKS                                  *\n*                                                                     *\n*        PARAMETER 2: RETURN VARIABLE STEM PREFIX                     *\n*                                                                     *\n*        PARAMETER 3: SEARCH ARGUMENTS                                *\n*                                                                     *\n*        PARAMETER 4: STARTING HIT NUMBER                             *\n*                                                                     *\n*        PARAMETER 5: ENDING HIT NUMBER                               *\n*                                                                     *\n*        RETURNED DATA:                                               *\n*              FOR THE 'BKSC' AND 'BOOC' FUNCTIONS, THE RETURN        *\n*              CODE IS THE REQUESTED NUMBER.                          *\n*              FOR THE 'SRCH' FUNCTION, A NON-ZERO RETURN CODE        *\n*              INDICATES AN ERROR AND NOTHING ELSE IS RETURNED.       *\n*              WITH A ZERO RETURN CODE FROM THE 'SRCH' FUNCTION,      *\n*              A SERIES OF REXX VARIABLES ARE CREATED USING THE       *\n*              STEM PREFIX PASSED TO THIS PROGRAM.  THESE ARE:        *\n*                                                                     *\n*              STEM.SEARCHARGUMENTS                                   *\n*                   THIS STRING CONTAINS THE SEARCH ARGUMENTS         *\n*                   REFORMATED TO BE AN UPPER CASE VERSION OF         *\n*                   WHAT THE USER ENTERED (%XX TRANSLATED, +'S        *\n*                   CONVERTED TO BLANKS).                             *\n*                                                                     *\n*              STEM.SEARCHHITS                                        *\n*                   THIS IS THE TOTAL NUMBER OF UNIQUE BOOK HITS      *\n*                   THAT HAVE BEEN FOUND, REGARDLESS OF THE           *\n*                   ACTUAL NUMBER BEING RETURNED.                     *\n*                                                                     *\n*              STEM.SEARCHRETURN                                      *\n*                   THIS IS THE COUNT OF UNIQUE BOOK HITS BEING       *\n*                   RETURNED, I.E., THE NUMBER OF UNIQUE BOOK         *\n*                   HITS BEING RETURNED IN THE STEM.I VARIABLES.      *\n*                   IN THE ABSENSE OF THE HIT LIMITS, THIS WOULD BE   *\n*                   THE SAME AS STEM.SEARCHHITS.                      *\n*                                                                     *\n*              STEM.0                                                 *\n*                   THIS IS THE COUNT OF \"STEM.I\" VARIABLES           *\n*                   BEING RETURNED.                                   *\n*                                                                     *\n*              STEM.I (I = 1 TO STEM.0)                               *\n*                   ONE OF THESE VARIABLES IS RETURNED FOR EACH       *\n*                   BOOK SEARCH MATCH RETURNED.  THIS INCLUDES        *\n*                   DUPLICATE HITS FOR BOOKS THAT ARE LOCATED IN      *\n*                   MORE THAN ONE BOOKSHELF.                          *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, AMODE 31, RMODE ANY,    *\n*                     UNAUTHORIZED                                    *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\n         PUNCH '         PAGE  CCCBKSRV'  MAKE DEBUGGING EASIER\n*\nCCCBKSRV CSECT\nCCCBKSRV AMODE 31\nCCCBKSRV RMODE ANY\n*\n         USING CCCBKSRV,R15\n         B     AROUNDID\n         DC    CL8'CCCBKSRV'\n         DC    CL8' V1.1.1'\n         DC    CL8'&SYSDATC'\n         DC    CL8' &SYSTIME'\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n*\n         LR    R12,R15             LOAD REGISTER 12 WITH ENTRY\n         DROP  R15\n         USING CCCBKSRV,R12        ESTABLISH ADDRESSABILITY\n*\n         LR    R8,R1               LOAD REGISTER 8 TO PRESERVE PARMADDR\n*\n         L     R2,=F'-1'           LOAD NEGATIVE RETURN CODE\n         L     R15,CVTPTR          GET THE CVT\n         USING CVT,R15\n         L     R15,CVTJESCT        GET THE JES CONTROL TABLE\n         USING JESCT,R15\n         L     R15,JESSSCT         LOAD THE FIRST SSCT ADDRESS\n         USING SSCT,R15\n*\nFINDSSCT DS    0H\n         CLC   SSCTSNAM,=A(BKASSNAM)    LOOK FOR OUR SUBSYSTEM\n         BE    FOUNDSCT            BRANCH IF SO\n         ICM   R15,15,SSCTSCTA     GET THE NEXT SSCT\n         BNZ   FINDSSCT            AND LOOP\n         B     QUIKEXIT            ERROR IF WE CAN'T FIND OUT SSCT\n*\nFOUNDSCT DS    0H\n         ICM   R10,15,SSCTSUSE     LOAD THE ANCHOR BLOCK POINTER\n         BZ    QUIKEXIT            LEAVE IF IT'S NOT THERE\n*\n         DROP  R15\n         USING BKADSECT,R10\n*\n         CLC   BKABLKID,=A(BKAIDEQU)    CHECK IF IT'S THE REAL THING\n         BNE   QUIKEXIT            AND LEAVE IF WE DON'T HAVE IT\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CHECK FOR QUICK FUNCTIONS THAT DON'T REQUIRE GETTING         *\n*        A SAVE AREA AND SO ON.                                       *\n*                                                                     *\n***********************************************************************\n*\n         L     R1,0(,R8)           GET THE FIRST PARAMETER PASSED\n         LH    R0,0(,R1)           LOAD THE PARAMETER LENGTH\n         CH    R0,=H'4'            THIS PARAMETER MUST BE FOUR (ALWAYS)\n         BNE   QUIKEXIT            LEAVE QUICKLY IF NOT\n*\n         ICM   R7,15,2(R1)         LOAD FUNCTION CODE\n         O     R7,BLANKS           MAKE SURE IT IS UPPER CASE\n*\n         CLM   R7,15,=C'BKSC'      IS THIS THE BOOKSHELF COUNT REQUEST\n         BNE   NOTBKSC             BRANCH IF NOT\n*\n         L     R9,BKABKSEX         LOAD THE BOOKSHELF BLOCK ADDRESS\n         USING BKEDSECT,R9\n*\n         L     R2,BKEUNQUE         LOAD THE UNIQUE COUNT OF BOOKSHELVES\n         B     QUIKEXIT            AND LEAVE WITH THIS AS RETURN CODE\n*\n         DROP  R9\n*\nNOTBKSC  DS    0H\n         CLM   R7,15,=C'BOOC'      IS THIS THE BOOK COUNT REQUEST\n         BNE   NOTBOOC             BRANCH IF NOT\n*\n         L     R9,BKABOOEX         LOAD THE BOOKSHELF BLOCK ADDRESS\n         USING BKEDSECT,R9\n*\n         L     R2,BKEUNQUE         LOAD THE UNIQUE COUNT OF BOOKSHELVES\n         B     QUIKEXIT            AND LEAVE WITH THIS AS RETURN CODE\n*\n         DROP  R9\n*\nNOTBOOC  DS    0H\n         CLM   R7,15,=C'SRCH'      CHECK FOR THE REMAINING FUNCTION\n         BNE   QUIKEXIT            LEAVE IF NOT\n*\n         TM    0(R8),X'80'         TEST FOR ONLY ONE ARGUMENT\n         BO    QUIKEXIT            ERROR IF SO, DO QUICK RETURN\n         TM    4(R8),X'80'         TEST FOR ONLY TWO ARGUMENTS\n         BO    QUIKEXIT            ERROR IF SO, DO QUICK RETURN\n*\n         EJECT\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         GETMAIN RU,LV=(0),LOC=ANY\n         LR    R14,R1              COPY FOR THE MOVE LONG\n         LA    R15,WORKLENG        GET THE LENGTH\n         SLR   R3,R3\n         MVCL  R14,R2              CLEAR THE AREA\n*\n         ST    R13,4(,R1)          STORE ADDRESS OF PREVIOUS\n*\n         ST    R1,8(,R13)          STORE ADDRESS OF CURRENT\n*\n         LR    R13,R1              LOAD REGISTER 13 WITH SAVEAREA\n*\n         USING WORKAREA,R13        ESTABLISH ADDRESSABILITY\n*\n***********************************************************************\n*                                                                     *\n*        INITIALIZE THE BASE WORK AREA                                *\n*                                                                     *\n***********************************************************************\n*\n         STCM  R7,15,FUNCCODE      SAVE THE FUNCTION CODE\n         ST    R2,RETCODE          ASSUME BAD RETURN CODE\n*\n         MVC   HITBLOCK(HITBLOCL),HITMODEL SET UP THE HIT POOL\n         MVC   SRCBLOCK(SRCBLOCL),SRCMODEL SET UP THE SEARCH POOL\n*\n         LOAD  EPLOC=CPSNAME,ERRET=RETURN LOAD THE CELL POOL ROUTINE\n         ST    R0,CPSADDR          SAVE THIS ADDRESS\n*\n         LOAD  EPLOC=EXCOMID       GET ADDRESS OF IRXEXCOM\n         ST    R0,AIRXEXCM         STORE FOR LATER\n*\n         LOAD  EPLOC=BPXWRNAM      GET ADDRESS OF BPX1WRT\n         ST    R0,BPXWRITE         STORE FOR LATER\n*\n         LA    R1,EXCOMID          POINT TO IRXEXCOM ID\n         ST    R1,AEXCOMP1         STORE IN PARM LIST\n         LA    R1,ZERO             POINT TO FULLWORD ZERO\n         ST    R1,AEXCOMP2         STORE IN PARM LIST\n         ST    R1,AEXCOMP3         STORE IN PARM LIST\n         ST    R1,AEXCOMP4         STORE IN PARM LIST (SHVBLOCK)\n         ST    R1,AEXCOMP5         STORE IN PARM LIST\n         LA    R1,EXCOMRC          POINT TO RETURN CODE\n         ST    R1,AEXCOMP6         STORE IN PARM LIST\n         OI    AEXCOMP6,X'80'      INDICATE END OF LIST\n*\n         LA    R1,OUTFILED         POINT AT FILE DESCRIPTOR\n         ST    R1,BPXWRFD          STORE IN PARAMETER LIST\n         LA    R0,STDOUT_FILENO    GET STANDARD OUT FILE NUMBER\n         ST    R0,OUTFILED         STORE THE FILE NUMBER\n*\n         LA    R1,OUTBUFAD         POINT AT BUFFER ADDRESS ADDRESS\n         ST    R1,BPXWRBUF         STORE IN PARAMETER LIST\n         LA    R0,OUTBUFFR         GET OUTPUT BUFFER ADDRESS\n         ST    R0,OUTBUFAD         STURE THE BUFFER ADDRESS\n*\n         LA    R1,ZERO             POINT AT A ZERO\n         ST    R1,BPXWRALT         STORE THE ALTER ADDRESS\n*\n         LA    R1,OUTBUFLN         POINT AT BUFFER LENGTH\n         ST    R1,BPXWRBFL         STORE IN PARAMETER LIST\n*\n         LA    R1,OUTBUFRV         POINT AT RETURN VALUE WORD\n         ST    R1,BPXWRRVL         STORE IN PARAMETER LIST\n         LA    R1,OUTRETCD         POINT AT RETURN CODE WORD\n         ST    R1,BPXWRRET         STORE IN PARAMETER LIST\n         LA    R1,OUTRSNCD         POINT AT REASON CODE\n         ST    R1,BPXWRRSN         STORE IN PARAMETER LIST\n*\n         OI    BPXWRLST,X'80'      FLAG LAST PARAMETER\n*\n         LA    R0,1                SET DEFAULT STARTING HIT NUMBER\n         ST    R0,HITMIN           SET THIS\n         MVC   HITMAX,=F'16777215' SET DEFAULT MAXIMUM HIT NUMBER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        REQUEST THAT THE COMMON STORAGE TABLES BE LOADED INTO        *\n*        MEMORY TO MINIMIZE PAGE FAULTING WHEN SEARCHING THE          *\n*        RESIDENT BOOK TABLES.                                        *\n*                                                                     *\n***********************************************************************\n*\n         LA    R7,BKAANCHR         POINT AT FIRST ANCHOR WORD\n         LA    R6,BKAANUMB         GET NUMBER OF ANCHOR WORDS\n*\nPGSERLP  DS    0H\n         ICM   R1,15,0(R7)         GET THE ANCHOR WORD\n         BZ    PGSERNXT            BRANCH IF ZERO\n         USING BKEDSECT,R1\n*\n         L     R15,BKELENG         LOAD THE LENGTH OF THE AREA\n         BCTR  R15,0               BACK UP ONE\n         AR    R15,R1              ADD THE STARTING ADDRESS\n         DROP  R1\n*\n         PGSER R,LOAD,A=(1),EA=(15)     REQUEST THE PAGES IN\n*\nPGSERNXT DS    0H\n         LA    R7,4(,R7)           INCREMENT TO NEXT ARCHOR WORD\n         BCT   R6,PGSERLP          AND LOOP THROUGH THE ANCHORS\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        EXTRACT THE REMAINING PROGRAM PARAMETERS                     *\n*                                                                     *\n***********************************************************************\n*\n         L     R1,4(,R8)           GET THE SECOND PARAMETER (STEM)\n         LH    R15,0(,R1)          LOAD THE PARAMETER LENGTH\n         LTR   R15,R15             CHECK FOR NON-NULL\n         BZ    PARMERR2            RETURN IN ERROR IF NULL\n         CH    R15,=Y(L'STEMPREF)  CHECK MAXIMUM LENGTH\n         BH    PARMERR2            THIS IS ALSO NOT GOOD\n*\n         MVC   STEMPREF,BLANKS     BLANK OUT STEM VARIABLE NAME\n         STH   R15,STEMPREL        STORE THE STEM PREFIX LENGTH\n         BCTR  R15,0               DECREMENT FOR OC\n         EX    R15,STEMOCOC        MOVE THE STEM AND UPPER CASE IT\n*\n         LA    R15,STEMPREF(R15)   POINT AT LAST CHARACTER\n         CLI   0(R15),C'.'         CHECK FOR DELIMITER\n         BNE   PARMERR2            ERROR IF NO PERIOD\n*\n         L     R1,8(,R8)           GET THE THIRD PARAMETER (SRC ARGS)\n         LH    R15,0(,R1)          LOAD THE PARAMETER LENGTH\n         LTR   R15,R15             CHECK FOR NON-NULL\n         BZ    PARMERR3            RETURN IN ERROR IF NULL\n         CH    R15,=Y(L'SRCHARGS)  CHECK MAXIMUM LENGTH\n         BH    PARMERR3            THIS IS ALSO NOT GOOD\n*\n         MVC   SRCHARGS,BLANKS     BLANK OUT RAW SEARCH ARGUMENTS\n         STH   R15,SRCHARGL        STORE THE ARGUMENT LENGTH\n         BCTR  R15,0               DECREMENT FOR OC\n         EX    R15,ARGSOCOC        MOVE THE STEM AND UPPER CASE IT\n*\n         CLI   SRCHARGS,C' '       MAKE SURE THAT IT ISN'T BLANK\n         BE    PARMERR3            ERROR IF SO\n*\n         TM    8(R8),X'80'         TEST FOR ONLY THREE PARMS\n         BO    PARMDONE            IF SO, NO HIT LIMITS\n         TM    12(R8),X'80'        TEST FOR ONLY FOUR PARAMETERS\n         BO    PARMERR4            ERROR - MUST HAVE BOTH PARM 4 AND 5\n*\n         L     R1,12(,R8)          LOAD THE HIT MIN PARAMETER\n         LH    R15,0(,R1)          LOAD THE LENGTH OF THE HIT MIN\n         LTR   R15,R15             TEST FOR NULL\n         BZ    PARMERR4            ERROR IF NULL\n         CH    R15,=H'8'           CHECK AGAINST LOGICAL MAXIMIM\n         BH    PARMERR4            ERROR IF TOO LARGE\n*\n         BCTR  R15,0               DECREMENT FOR VARIOUS INSTRUCTIONS\n         EX    R15,HITMMVC1        COPY THE PARM TO THE WORK AREA\n         EX    R15,HITMNCNC        CLEAR OUT THE NUMERICS\n         EX    R15,HITMCLC1        CHECK THE ZONE FIELDS\n         BNE   PARMERR4            ERROR IF NOT NUMERIC\n*\n         EX    R15,HITMPACK        PACK THE PARAMETER\n         CVB   R0,DOUBLE           MAKE THIS BINARY\n         ST    R0,HITMIN           AND SET THE MIN VALUE\n*\n         L     R1,16(,R8)          LOAD THE HIT MAX PARAMETER\n         LH    R15,0(,R1)          LOAD THE LENGTH OF THE HIT MAX\n         LTR   R15,R15             TEST FOR NULL\n         BZ    PARMERR4            ERROR IF NULL\n         CH    R15,=H'8'           CHECK AGAINST LOGICAL MAXIMIM\n         BH    PARMERR4            ERROR IF TOO LARGE\n*\n         BCTR  R15,0               DECREMENT FOR VARIOUS INSTRUCTIONS\n         EX    R15,HITMMVC1        COPY THE PARM TO THE WORK AREA\n         EX    R15,HITMNCNC        CLEAR OUT THE NUMERICS\n         EX    R15,HITMCLC1        CHECK THE ZONE FIELDS\n         BNE   PARMERR4            ERROR IF NOT NUMERIC\n*\n         EX    R15,HITMPACK        PACK THE PARAMETER\n         CVB   R0,DOUBLE           MAKE THIS BINARY\n         ST    R0,HITMAX           AND SET THE MAX VALUE\n*\n         B     PARMDONE            AND WE ARE DONE ANALYZING PARMS\n*\nSTEMOCOC OC    STEMPREF(*-*),2(R1) *** EXECUTE ONLY ***\n*\nARGSOCOC OC    SRCHARGS(*-*),2(R1) *** EXECUTE ONLY ***\n*\nHITMMVC1 MVC   DOUBLE(*-*),2(R1)   *** EXECUTE ONLY ***\nHITMNCNC NC    DOUBLE(*-*),=8C'0'  *** EXECUTE ONLY ***\nHITMCLC1 CLC   DOUBLE(*-*),=8C'0'  *** EXECUTE ONLY ***\nHITMPACK PACK  DOUBLE,2(*-*,R1)    *** EXECUTE ONLY ***\n*\nPARMDONE DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*           DECODE THE SEARCH ARGUMENTS, CONVERTING THE %XX TO        *\n*           THE APPROPRIATE CHARACTERS AND SEPARATING THEM AT         *\n*           EACH +.                                                   *\n*                                                                     *\n***********************************************************************\n*\n         LH    R2,SRCHARGL         LOAD THE TOTAL ARGUMENT LENGTH\n         LA    R3,SRCHARGS         POINT AT FIRST CHARACTER\n*\nSPLTLOOP DS    0H\n         LTR   R2,R2               DO WE HAVE ANY SEARCH ARGUMENTS LEFT\n         BZ    SPLTDONE            BRANCH IF NOT\n         CLI   0(R3),C'+'          DOES IT START WITH A +\n         BE    PARMER10            NOT GOOD IF IT DOES\n*\n         LA    R0,SABLNGTH         GET A SEARCH ARGUMENT BLOCK\n         LA    R1,SRCBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A SEARCH ARGUMENT BLOCK\n*\n         LR    R4,R15              COPY THE ADDRESS\n         USING SABDSECT,R4\n         SLR   R5,R5               INITIALIZE SPLIT ARGUMENT LENGTH\n         ST    R5,SABNEXT          ZERO THE CHAIN POINTER\n         STH   R5,SABLENG          ZERO THE DATA LENGTH\n         MVC   SABDATA,BLANKS      PRE-BLANK SEARCH ARGUMENT\n*\n         LA    R6,SABDATA          POINT AT START OF SPLIT ARGUMENT\n*\nSPLTCHAR DS    0H\n         CH    R5,=Y(L'SABDATA)    IS THIS ARGUMENT TOO LONG\n         BNL   SPLTERR1\n         CLI   0(R3),C'%'          CHECK FOR SPECIAL TRANSLATION\n         BE    SPLTTRAN            BRANCH IF SO\n*\n         MVC   0(1,R6),0(R3)       COPY THE ONE CHARACTER\n         LA    R6,1(,R6)           INCREMENT SPLIT TARGET\n         LA    R5,1(,R5)           INCREMENT SPLIT LENGTH\n         B     SPLTNEXT            AND GO INCREMENT THE SOURCE\n*\nSPLTTRAN DS    0H\n         CH    R2,=H'3'            WE BETTER HAVE AT LEAST 3 CHARS\n         BL    SPLTERR2            ERROR IF NOT\n*\n         CLI   1(R3),C'2'          CHECK LOW VALUE\n         BL    SPLTERR3            ERROR IF TOO LOW\n         CLI   1(R3),C'7'          CHECK HIGH VALUE\n         BH    SPLTERR3            ALSO AN ERROR\n*\n         SLR   R15,R15             CLEAR FOR INSERT\n         NI    1(R3),X'0F'         CLEAR THE ZONE\n         IC    R15,1(,R3)          LOAD THE CHARACTER\n         SLL   R15,2               MULTIPLY IT BY 4\n         LA    R15,SPECTBLI-8(R15) POINT AT SPECIAL CHARACTER INDEX\n         LH    R1,0(,R15)          LOAD THE OFFSET\n         LA    R1,SPECTBLS(R1)     GET THE ACTUAL TABLE START\n         LH    R0,2(,R15)          GET THE NUMBER OF ENTRIES\n*\nSPLTSPCL DS    0H\n         CLC   0(1,R1),2(R3)       COMPARE HEX STRING\n         BE    SPLTSPCF            BRANCH IF FOUND\n         LA    R1,L'SPECTBL2(,R1)  INCREMENT CHARACTER TABLE\n         BCT   R0,SPLTSPCL         LOOP THROUGH THE TABLE\n         B     SPLTERR3            ERROR IF NOT IN TABLE\n*\nSPLTSPCF DS    0H\n         MVC   0(1,R6),1(R1)       MOVE SPECIAL CHARACTER\n         LA    R6,1(,R6)           INCREMENT TARGET\n         LA    R5,1(,R5)           INCREMENT TARGET LENGTH\n         LA    R3,2(,R3)           INCREMENT PAST 2/3 OF SOURCE\n         BCTR  R2,0                DECREMENT PAST 2/3\n         BCTR  R2,0                 OF SOURCE LENGTH\n*\nSPLTNEXT DS    0H\n         LA    R3,1(,R3)           INCREMENT THE SOURCE POINTER\n         BCT   R2,*+8              DECREMENT LENGTH\n         B     SPLTLAST            WE ARE DONE HERE\n*\n         CLI   0(R3),C'+'          CHECK FOR SEPARATOR\n         BNE   SPLTCHAR            LOOP TO NEXT CHARACTER\n*\nSPLTLAST DS    0H\n         STH   R5,SABLENG          STORE THE LENGTH\n         DROP  R4\n*\n         LA    R1,SRCHAIN          POINT AT SEARCH ARGUMENT CHAIN\n         USING SABDSECT,R1\n*\nSPLTCHN1 DS    0H\n         ICM   R15,15,SABNEXT      TEST IF THERE'S A CHAIN POINTER\n         BZ    SPLTADD1            BRANCH IF AT THE END\n         LR    R1,R15              CHAIN TO NEXT BLOCK\n         B     SPLTCHN1            AND LOOP\n*\nSPLTADD1 DS    0H\n         ST    R4,SABNEXT          CHAIN ON\n         DROP  R1\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,SRCHNUM          ADD PREVIOUS COUNT\n         ST    R0,SRCHNUM          STORE UPDATED COUNT\n*\n         LTR   R2,R2               TEST FOR NOTHING LEFT\n         BZ    SPLTDONE            IF SO, WE ARE DONE\n*\n         LA    R3,1(,R3)           INCREMENT PAST THE + SIGN\n         BCT   R2,SPLTLOOP         DECREMENT SOURCE LENGTH AND LOOP\n         B     SPLTERR4            ERROR IF IT ENDS IN A PLUS SIGN\n*\nSPLTDONE DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD THE FIRST HIT BLOCK TO CONTAIN THE NUMBER OF HITS      *\n*        (I.E., STEM.0)                                               *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,BHBLNGTH         GET A BOOK HIT BLOCK\n         LA    R1,HITBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A SEARCH ARGUMENT BLOCK\n*\n         LA    R0,1                GET A ONE\n         STH   R0,SUFXLENG         STORE THIS LENGTH\n         MVC   SUFXDATA,BLANKS     BLANK FOR POSTERITY\n         MVI   SUFXDATA,C'0'       THIS ONE IS EACH\n*\n         LA    R0,SUFXLENG         POINT AT SUFFIX\n         LR    R1,R15              COPY STORAGE ADDRESS\n         BAL   R14,INITBHB         GO INITIALIZE IT\n         ST    R1,HITCHAIN         STORE FIRST BLOCK ADDRESS\n         ST    R1,HITLAST          STORE LAST BLOCK ADDRESS\n         ST    R1,AEXCOMP4         AND FIRST SHV BLOCK POINTER\n*\n***********************************************************************\n*                                                                     *\n*        BUILD THE SEARCH ARGUMENT RETURN BLOCK                       *\n*        (I.E., STEM.SEARCHARUGMENTS)                                 *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,BHBLNGTH         GET A BOOK HIT BLOCK\n         LA    R1,HITBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A BOOK HOT BLOCK\n*\n         LA    R0,SRCHARGN         POINT AT THE SEARCH ARGUMENT SUFFIX\n         LR    R1,R15              COPY THIS ADDRESS\n         BAL   R14,INITBHB         GO INITIALIZE IT\n*\n         L     R15,HITLAST         LOAD PREVIOUS LAST RECORD\n         ST    R1,0(,R15)          CHAIN THIS ONE ON TO PREVIOUS\n         ST    R1,HITLAST          MAKE THIS THE NEW LAST ONE\n*\n         LR    R2,R1\n         USING BHBDSECT,R2\n         USING SHVBLOCK,BHBSHV\n*\n         L     R15,SRCHAIN         POINT AT FIRST SERACH ARGUMENT\n         USING SABDSECT,R15\n*\n         LA    R3,BHBBKRET         POINT AT START OF VARIABLE DATA AREA\n         L     R0,SRCHNUM          SEED THE LENGTH AS THE NUMBER OF\n         BCTR  R0,0                 ARGUMENTS MINUS ONE (BLANKS)\n*\nRETSRCHL DS    0H\n         LH    R14,SABLENG         LOAD THE SEARCH ARGUMENT LENGTH\n         AR    R0,R14              ADD THIS LENGTH\n*\n         BCTR  R14,0               DECREMENT FOR MVC\n         EX    R14,RETSMVCS        MOVE THIS SEARCH ARGUMENT\n         LA    R3,1(R14,R3)        POINT PAST THE ARGUMENT\n         MVI   0(R3),C' '          MOVE IN A BLANK\n         LA    R3,1(,R3)           INCREMENT PAST THE BLANK\n*\n         ICM   R15,15,SABNEXT      GET NEXT ARGUMENT\n         BNZ   RETSRCHL            AND LOOP THROUGH THE ARGUMENTS\n*\n         ST    R0,SHVVALL          STORE THE DATA LENGTH\n         B     RETSRCHD            AND SKIP EXDCUTED INSTRUCTION\n*\nRETSMVCS MVC   0(*-*,R3),SABDATA   *** EXECUTE ONLY ***\n*\n         DROP  R2,R15\n*\nRETSRCHD DS    0H\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        NOW BEGIN THE ARDUOUS TASK OF SEARCHING THE IN STORAGE       *\n*        COPY OF THE BOOK EXTRACT.                                    *\n*                                                                     *\n***********************************************************************\n*\n         L     R9,BKABOOEX         LOAD THE BOOK EXTRACT TABLE ADDRESS\n         USING BKEDSECT,R9\n*\n         L     R8,BKENUMBR         LOAD TOTAL NUMBER OF ENTRIES\n         L     R9,BKEFIRST         POINT AT FIRST ENTRY\n         USING BKEENTRY,R9\n         USING BKNDSECT,BKEEDATA\n*\n***********************************************************************\n*                                                                     *\n*        BUILD THE SEARCH DATA FROM THE PUBLICATION NUMBER AND        *\n*        THE BOOK TITLE (UPPER-CASED).                                *\n*                                                                     *\n***********************************************************************\n*\nSRCHLOOP DS    0H\n         MVC   SRCHBKNM,BKNNAME    GET THE CURRENT BOOK NAME\n*\n         MVC   SRCHDATA,BLANKS     BLANK THE SEARCH DATA WORK AREA\n         MVC   SRCHDATA(L'BKNPUBNO),BKNPUBNO COPY THE PUB NUMBER\n*\n         LH    R3,BKNLENG          LOAD THE RECORD LENGTH\n         SH    R3,=Y(BKNTITLE-BKNRDW+1) GET TITLE LENGTH MINUS ONE\n         EX    R3,SRCHOCTT         COPY AND UPPER CASE THE TITLE\n         LA    R3,L'BKNPUBNO+1(,R3)     GET LENGTH - 1 TO SEARCH\n         LA    R14,SRCHDATA(R3)    POINT AT LAST BYTE OF SEARCH DATA\n         ST    R14,SRCHDEND        SAVE THIS\n         STH   R3,SRCHDLNG         AND SAVE IT\n*\n***********************************************************************\n*                                                                     *\n*        RUN THE SEARCH ARGUMENT CHAIN.  A MATCH IS REQUIRED ON       *\n*        EVERY SEARCH ARGUMENT OR THE BOOK IS REJECTED.               *\n*                                                                     *\n***********************************************************************\n*\n         L     R15,SRCHAIN         POINT AT FIRST SEARCH ARGUMENT\n         USING SABDSECT,R15\n*\nSRCHSTRT DS    0H\n         XC    SRCHTRTT,SRCHTRTT   CLEAR THE TRT TABLE\n         SLR   R14,R14\n         IC    R14,SABDATA         LOAD FIRST ARGUMENT CHARACTER\n         STC   R14,SRCHTRTT(R14)   STORE THIS IN THE TRT TABLE\n*\n         LA    R1,SRCHDATA         SET UP FOR START OF SCAN\n         LH    R14,SABLENG         LOAD SEARCH ARGUMENT LENGTH\n         BCTR  R14,0               DECREMENT FOR CLC\n         LH    R3,SRCHDLNG         LOAD THE SEARCH STRING LENGTH\n*\nSRCHSCN1 DS    0H\n         EX    R3,SRCHTRT1         LOOK FOR A MATCHING CHARACTER\n         BZ    SRCHNXT1            IF NO HITS, GET NEXT SEACH ARGUMENT\n*\n         EX    R14,SRCHCLC1        SEE IF THE ENTIRE ARGUMENT MATCHES\n         BE    SRCHHIT1            BRANCH IF WE HAVE A MATCH\n*\n         LA    R1,1(,R1)           INCREMENT SEARCH DATA POINTER\n         L     R3,SRCHDEND         GET LAST BYTE ADDRESS\n         SR    R3,R1               CALCULATE NEW LENGTH\n         BH    SRCHSCN1            AND TRY AGAIN IF WE HAVE SOME LEFT\n*\n***********************************************************************\n*                                                                     *\n*        THE SEARCH ARGUMENT WAS NOT FOUND IN THE SEARCH DATA,        *\n*        SO GO TO THE NEXT BOOK.                                      *\n*                                                                     *\n***********************************************************************\n*\nSRCHNXT1 DS    0H\n         ICM   R9,15,BKEENEXT      NO MATCH - GET NEXT BOOK\n         BZ    SRCHDONE            IF NO MORE, WE BE DONE\n*\n         CLC   SRCHBKNM,BKNNAME    IS THIS THE SAME BOOK\n         BNE   SRCHLOOP            IF NOT, GO TRY AGAIN\n         B     SRCHNXT1            IF SO, SKIP THIS BOOK\n*\nSRCHCLC1 CLC   SABDATA(*-*),0(R1)  *** EXECUTE ONLY ***\nSRCHTRT1 TRT   0(*-*,R1),SRCHTRTT  *** EXECUTE ONLY ***\nSRCHOCTT OC    SRCHDATA+L'BKNPUBNO+1(*-*),BKNTITLE *** EXECUTE ONLY ***\n*\n***********************************************************************\n*                                                                     *\n*        A MATCH WAS MADE BETWEEN THE CURRENT SEARCH ARGUMENT AND     *\n*        THE EXTRACTED BOOK SEARCH DATA.  GET THE NEXT SEARCH         *\n*        ARGUMENT.                                                    *\n*                                                                     *\n***********************************************************************\n*\nSRCHHIT1 DS    0H\n         ICM   R15,15,SABNEXT      GET NEXT SEARCH AGRUMENT\n         BNZ   SRCHSTRT            AND LOOP IF WE HAVE MORE\n*\n         DROP  R15                 DONE WITH THE SEARCH DATA BLOCK\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        EVERY SEARCH ARGUMENT WAS FOUND IN THE SEARCH DATA, SO       *\n*        THIS BOOK IS A HIT.  NOW WE WILL BUILD A RETURN DATA         *\n*        VARIABLE.                                                    *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,HITCOUNT         ADD PREVIOUS HIT COUNT\n         ST    R0,HITCOUNT         UPDATE THIS COUNT\n*\n         CLC   HITCOUNT,HITMIN     CHECK AGAINST MINIMUM\n         BL    SRCHNXT2            SKIP RETURN IF TOO LOW\n         CLC   HITCOUNT,HITMAX     CHECK AGAINST MAXIMUM\n         BH    SRCHNXT2            SKIP RETURN IF TOO HIGH\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,RETNUM           ADD PREVIOUS HIT COUNT\n         ST    R0,RETNUM           STORE THE UPDATED COUNT\n*\n         BAL   R14,BUILDSUF        BUILD THE VARIABLE SUFFIX\n*\n         LA    R0,BHBLNGTH         GET A BOOK HIT BLOCK\n         LA    R1,HITBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A BOOK HIT BLOCK\n*\n         LA    R0,SUFXLENG         POINT AT VARIABLE SUFFIX\n         LR    R1,R15              COPY THIS ADDRESS\n         BAL   R14,INITBHB         GO INITIALIZE IT\n*\n         LR    R3,R1               COPY THE BOOK HIT BLOCK ADDRESS\n         USING BHBDSECT,R3\n         USING SHVBLOCK,BHBSHV\n*\n         L     R15,HITLAST         GET LAST RECORD ADDRESS\n         ST    R3,0(,R15)          CHAIN NEW RECORD ONTO OLD\n         ST    R3,HITLAST          AND UPDATE THE LAST POINTER\n*\n         MVC   BHBBKNAM,BKNNAME    COPY THE BOOK NAME\n         TRT   BHBBKRET(BHBBKLEN),BLANKTRT   FIND THE FIRST BLANK\n         LA    R4,1(,R1)           POINT AT FIRST AVAILABLE SPACE\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,HITRETN          ADD PREVIOUS RETURNED COUNT\n         ST    R0,HITRETN          UPDATE THIS COUNT\n*\n         MVC   0(L'BHBBKPUB,R4),BKNPUBNO   COPY THE PUBLICATION NUMBER\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         MVC   0(L'BHBBKDTE,R4),BKNBKDTE   COPY THE BOOK BUILD DATE\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         MVC   0(L'BHBBKTIM,R4),BKNBKTIM   COPY THE BOOK BUILD TIME\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         MVC   0(L'BHBBKDSN,R4),BKNDSNME   COPY THE DATA SET NAME\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         LA    R1,BKNDSNME         POINT AT THE DATA SET NAME\n         BAL   R14,LOCATVOL        GO GET THE VOL SER INFO\n         MVC   0(L'BHBBKVOL,R4),0(R15)     COPY THE RETURNED DATA\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         MVC   0(L'BHBBKSHF,R4),BKNBKSID   COPY THE BOOKSHELF NAME\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         LA    R1,BKNBKSID         POINT AT BOOKSHELF NAME\n         BAL   R14,LKUPBKS         GO FIND THE BOOKSHELF DATA SET NAME\n         MVC   0(L'BHBBKSHD,R4),0(R15) COPY THE BOOKSHELF DATA SET NAME\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         LA    R0,BKNPUBNO         POINT AT PUBLICATION NUMBER\n         LA    R1,BKNDSNME         POINT AT ORIGINAL DATA SET NAME\n         BAL   R14,FINDPDFN        GO FIND IT\n*\n         MVC   0(L'BHBBKPDF,R4),0(R1)   COPY THE RETURNED DATA SET NAME\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         MVC   0(L'BHBBKPDV,R4),0(R15)  COPY THIS RETURNED DATA\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         LH    R15,BKNRDW          LOAD THE RECORD LENGTH\n         SH    R15,=Y(BKNTITLE-BKNRDW+1) GET TITLE LENGTH MINUS 1\n         EX    R15,SRCHMVCT        COPY THE TITLE\n*\n         LA    R4,1(R4,R15)        POINT PAST THE TITLE\n*\n         LA    R15,BHBBKRET        GET START OF RETURNED DATA\n         SR    R4,R15              CALCULATE RETURNED LENGTH\n         ST    R4,SHVVALL          STORE THIS LENGTH\n*\n         B     SRCHDUP1            AND GO LOOK FOR DUPLICATES\n*\n         DROP  R3\n*\nSRCHMVCT MVC   0(*-*,R4),BKNTITLE  *** EXECUTE ONLY ***\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BOOK HIT IS OUTSIDE THE HIT RANGE, SO WE WANT TO SKIP IT     *\n*        (AND ALL DUPLICATE HITS AS WELL).                            *\n*                                                                     *\n***********************************************************************\n*\nSRCHNXT2 DS    0H\n         ICM   R9,15,BKEENEXT      NO MATCH - GET NEXT BOOK\n         BZ    SRCHDONE            IF NO MORE, WE BE DONE\n*\n         CLC   SRCHBKNM,BKNNAME    IS THIS THE SAME BOOK\n         BNE   SRCHLOOP            IF NOT, GO TRY AGAIN\n         B     SRCHNXT2            IF SO, SKIP THIS BOOK\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        HAVING BUILT A RETURN BLOCK FOR THE MATCH, WE NOW LOOK       *\n*        TO SEE IF THERE ARE ANY MORE MATCHES FOR THE SAME BOOK       *\n*        ON ADDITIONAL BOOKSHELVES.  IF SO, WE BUILD \"STRIPPED DOWN\"  *\n*        RETURN RECORDS.                                              *\n*                                                                     *\n***********************************************************************\n*\nSRCHDUP1 DS    0H\n         ICM   R9,15,BKEENEXT      NO MATCH - GET NEXT BOOK\n         BZ    SRCHDONE            IF NO MORE, WE BE DONE\n*\n         CLC   SRCHBKNM,BKNNAME    IS THIS THE SAME BOOK\n         BNE   SRCHLOOP            IF NOT, GO TRY AGAIN\n*\n         LA    R0,1                LOAD A ONE\n         A     R0,RETNUM           ADD PREVIOUS HIT COUNT\n         ST    R0,RETNUM           STORE THE UPDATED COUNT\n*\n         BAL   R14,BUILDSUF        BUILD THE VARIABLE SUFFIX\n*\n         LA    R0,BHBLNGTH         GET A BOOK HIT BLOCK\n         LA    R1,HITBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A BOOK HIT BLOCK\n*\n         LA    R0,SUFXLENG         POINT AT VARIABLE SUFFIX\n         LR    R1,R15              COPY THIS ADDRESS\n         BAL   R14,INITBHB         GO INITIALIZE IT\n*\n         LR    R3,R1               COPY THE BOOK HIT BLOCK ADDRESS\n         USING BHBDSECT,R3\n         USING SHVBLOCK,BHBSHV\n*\n         L     R15,HITLAST         GET LAST RECORD ADDRESS\n         ST    R3,0(,R15)          CHAIN NEW RECORD ONTO OLD\n         ST    R3,HITLAST          AND UPDATE THE LAST POINTER\n*\n         MVC   BHBBKNAM,BKNNAME    COPY THE BOOK NAME\n         TRT   BHBBKRET(BHBBKLEN),BLANKTRT   FIND THE FIRST BLANK\n         LA    R4,1(,R1)           POINT AT FIRST AVAILABLE SPACE\n*\n         MVI   0(R4),C'*'          PUBLICATION NUMBER PLACEHOLDER\n         LA    R4,2(,R4)           INCREMENT TO NEXT FIELD\n*\n         MVI   0(R4),C'*'          BOOK BUILD DATE PLACEHOLDER\n         LA    R4,2(,R4)           INCREMENT TO NEXT FIELD\n*\n         MVI   0(R4),C'*'          BOOK BUILD TIME PLACEHOLDER\n         LA    R4,2(,R4)           INCREMENT TO NEXT FIELD\n*\n         MVI   0(R4),C'*'          BOOK DATA SET NAME PLACEHOLDER\n         LA    R4,2(,R4)           INCREMENT TO NEXT FIELD\n*\n         MVI   0(R4),C'*'          BOOK DATA SET VOL SER PLACEHOLDER\n         LA    R4,2(,R4)           INCREMENT TO NEXT FIELD\n*\n         MVC   0(L'BHBBKSHF,R4),BKNBKSID   COPY THE BOOKSHELF NAME\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         LA    R1,BKNBKSID         POINT AT BOOKSHELF NAME\n         BAL   R14,LKUPBKS         GO FIND THE BOOKSHELF DATA SET NAME\n         MVC   0(L'BHBBKSHD,R4),0(R15) COPY THE BOOKSHELF DATA SET NAME\n         TRT   0(BHBBKLEN,R4),BLANKTRT FIND THE NEXT BLANK\n         LA    R4,1(,R1)           SAVE AND INCREMENT NEXT FIELD\n*\n         MVI   0(R4),C'*'          PDF DATA SET NAME PLACEHOLDER\n         LA    R4,2(,R4)           INCREMENT TO NEXT FIELD\n*\n         MVI   0(R4),C'*'          PDF DATA SET VOL SER PLACEHOLDER\n         LA    R4,2(,R4)           INCREMENT TO NEXT FIELD\n*\n         MVI   0(R4),C'*'          TITLE PLACEHOLDER\n         LA    R4,1(,R4)           INCREMENT TO END OF DATA\n*\n         LA    R15,BHBBKRET        GET START OF RETURNED DATA\n         SR    R4,R15              CALCULATE RETURNED LENGTH\n         ST    R4,SHVVALL          STORE THIS LENGTH\n*\n         B     SRCHDUP1            GO LOOK FOR MORE DUP HITS\n*\n         DROP  R3\n*\n         DROP  R9                  DONE WITH THE IN STORAGE BOOK BLOCK\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD THE ACTUAL NUMBER OF SEARCH MATCHES                    *\n*        (I.E., STEM.SEARCHHITS)                                      *\n*                                                                     *\n***********************************************************************\n*\nSRCHDONE DS    0H\n         LA    R0,BHBLNGTH         GET A BOOK HIT BLOCK\n         LA    R1,HITBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A SEARCH ARGUMENT BLOCK\n*\n         LA    R0,SRCHHITN         POINT AT THE SEARCH HIT SUFFIX\n         LR    R1,R15              COPY THE ADDRESS\n         BAL   R14,INITBHB         GO INITIALIZE IT\n*\n         L     R15,HITLAST         LOAD PREVIOUS LAST RECORD\n         ST    R1,0(R15)           CHAIN THIS ONE ON TO REPVIOUS\n         ST    R1,HITLAST          MAKE THIS THE NEW LAST ONE\n*\n         LR    R2,R1\n         USING BHBDSECT,R2\n         USING SHVBLOCK,BHBSHV\n*\n         L     R0,HITCOUNT         LOAD THE NUMBER OF UNIQUE MATCHES\n         BAL   R14,BUILDSUF        GO CREATE IT LIKE A SUFFIX\n         MVC   BHBBKRET(L'SUFXDATA),SUFXDATA  COPY THE ENTIRE DATA\n         LH    R0,SUFXLENG         LOAD THE LENGTH\n         ST    R0,SHVVALL          AND STORE THE LENGTH\n*\n         DROP  R2\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD THE ACTUAL NUMBER OF SEARCH HITS RETURNED              *\n*        (I.E., STEM.SEARCHRETURN)                                    *\n*                                                                     *\n***********************************************************************\n*\n         LA    R0,BHBLNGTH         GET A BOOK HIT BLOCK\n         LA    R1,HITBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A SEARCH ARGUMENT BLOCK\n*\n         LA    R0,SRCHRETN         POINT AT THE SEARCH HIT SUFFIX\n         LR    R1,R15              COPY THE ADDRESS\n         BAL   R14,INITBHB         GO INITIALIZE IT\n*\n         L     R15,HITLAST         LOAD PREVIOUS LAST RECORD\n         ST    R1,0(R15)           CHAIN THIS ONE ON TO REPVIOUS\n         ST    R1,HITLAST          MAKE THIS THE NEW LAST ONE\n*\n         LR    R2,R1\n         USING BHBDSECT,R2\n         USING SHVBLOCK,BHBSHV\n*\n         L     R0,HITRETN          LOAD THE NUMBER OF UNIQUE MATCHES\n         BAL   R14,BUILDSUF        GO CREATE IT LIKE A SUFFIX\n         MVC   BHBBKRET(L'SUFXDATA),SUFXDATA  COPY THE ENTIRE DATA\n         LH    R0,SUFXLENG         LOAD THE LENGTH\n         ST    R0,SHVVALL          AND STORE THE LENGTH\n*\n         DROP  R2\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        GET THE NUMBER OF RETURNED HITS AND UPDATE THE STEM.0        *\n*                                                                     *\n***********************************************************************\n*\n         L     R2,HITCHAIN         POINT AT FIRST HIT BLOCK\n         USING BHBDSECT,R2\n         USING SHVBLOCK,BHBSHV\n*\n         L     R0,RETNUM           LOAD THE NUMBER OF HITS\n         BAL   R14,BUILDSUF        GO CREATE IT LIKE A SUFFIX\n         MVC   BHBBKRET(L'SUFXDATA),SUFXDATA  COPY THE ENTIRE DATA\n         LH    R0,SUFXLENG         LOAD THE LENGTH\n         ST    R0,SHVVALL          AND STORE THE LENGTH\n*\n         DROP  R2\n*\n***********************************************************************\n*                                                                     *\n*        CALL REXX TO HAVE ALL OF THE COLLECTED VARIABLES CREATED     *\n*                                                                     *\n***********************************************************************\n*\n         LA    R1,EXCOMPRM         POINT TO THE PARM LIST\n         L     R15,AIRXEXCM        LOAD ADDRESS OF ROUTINE\n         BALR  R14,R15             CALL IT\n*\n         ST    R15,RETCODE         SET THE EXCOM RETURN CODE\n*\n         MVC   OUTBUFFR(HTMLCOML),HTMLCOMM\n         LA    R0,HTMLCOML         GET LENGTH OF COMMENT\n         ST    R0,OUTBUFLN         STORE THE LENGTH\n*\n         LA    R1,BPXWRPRM         POINT AT PARAMETER LIST\n         L     R15,BPXWRITE        LOAD WRITE ROUTINE ADDRESS\n         BALR  R14,R15             CALL WRITE ROUTINE\n*\nSLIPTRAP NOP   0                   PLACE TO SETP SLIP TRAP\n*\n         B     RETURN              AND LEAVE\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ERROR CONTITIONS - SET RETURN CODE VALUE FOR                 *\n*        FEEDBACK TO PROGRAM                                          *\n*                                                                     *\n***********************************************************************\n*\nPARMERR2 DS    0H\n         LA    R0,2                INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\nPARMERR3 DS    0H\n         LA    R0,3                INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\nPARMERR4 DS    0H\n         LA    R0,4                INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\nPARMER10 DS    0H\n         LA    R0,10               INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\nSPLTERR1 DS    0H\n         LA    R0,11               INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\nSPLTERR2 DS    0H\n         LA    R0,12               INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\nSPLTERR3 DS    0H\n         LA    R0,13               INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\nSPLTERR4 DS    0H\n         LA    R0,14               INDICATE ERROR\n         ST    R0,RETCODE          STORE THE ERROR\n         B     RETURN              AND RETURN\n*\n***********************************************************************\n*                                                                     *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         SLR   R0,R0               INDICATE FREEING OF THE SAB'S\n         LA    R1,SRCBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A SEARCH ARGUMENT BLOCK\n*\n         SLR   R0,R0               INDICATE FREEING OF THE BHB'S\n         LA    R1,HITBLOCK         POINT AT CELL POOL HEADER\n         L     R15,CPSADDR         LOAD CELL POOL ROUTINE ADDRESS\n         BASSM R14,R15             GET A SEARCH ARGUMENT BLOCK\n*\n         DELETE EPLOC=BPXWRNAM     DELETE BPX1WRT FROM STORAGE\n*\n         DELETE EPLOC=EXCOMID      DELETE IRXEXCOM FROM STORAGE\n*\n         DELETE EPLOC=CPSNAME      DELETE THE CELL POOL ROUTINE\n*\n         L     R2,RETCODE          LOAD THE RETURN CODE\n*\n         LR    R1,R13              LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)         RELOAD ADDRESS OF PREVIOUS SAVE\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN RU,LV=(0),A=(1)  FREE GETMAINED AREA\n*\nQUIKEXIT DS    0H\n         LR    R15,R2              SET THE RETURN CODE\n         L     R14,12(,R13)        LOAD REGISTER 14 WITH RETURN\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BSM   0,R14               RETURN\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        INITIALIZE A BOOK HIT BLOCK                                  *\n*                                                                     *\n*        REG 1 POINTS TO THE BLOCK TO BE INITALIZED                   *\n*        REG 0 POINTS TO THE SUFFIX OF THE CARIABLE NAME              *\n*                                                                     *\n***********************************************************************\n*\nINITBHB  DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n         LR    R2,R1               COPY THE BOOK HIT BLOCK ADDR\n         LR    R3,R0               SAVE THE VARIABLE SUFFIX POINTER\n         USING BHBDSECT,R2\n         USING SHVBLOCK,BHBSHV\n*\n         XC    BHBSHV,BHBSHV       CLEAR THE REXX SHV\n         MVI   SHVCODE,SHVSTORE    SET VARIABLE STORE\n         MVC   BHBVARN,BLANKS      CLEAR THE VARIABLE NAME FIELD\n         MVC   BHBBKRET(BHBBKLEN),BLANKS BLANK THE BASE RETURN DATA\n         MVC   BHBBKTTL,BLANKS     BLANK THE BOOK TITLE\n*\n         LA    R0,BHBBKRET         POINT AT START OF DATA\n         ST    R0,SHVVALA          STORE THE DATA ADDRESS\n*\n         LH    R15,STEMPREL        LOAD THE STEM PREFIX LENGTH\n         BCTR  R15,0               DECREMENT FOR MVC\n         EX    R15,INITVARN        MVC THE STEM PREFIX\n         LA    R15,BHBVARN+1(R15)  POINT PAST THE STEM PREFIX\n*\n         LH    R14,0(,R3)          LOAD THE SUFFIX LENGTH\n         BCTR  R14,0               DECREMENT FOR MVC\n         EX    R14,INITVARS        MOVE THE SUFFIX DATA\n         LA    R0,BHBVARN          POINT AT START OF VARIABLE NAME\n         ST    R0,SHVNAMA          STORE THE VARIABLE NAME ADDRESS\n         LH    R0,STEMPREL         LOAD THE PREFIX LENGTH\n         AH    R0,0(,R3)           ADD THE SUFFIX LENGTH\n         ST    R0,SHVNAML          STORE THE VARIABLE NAME LENGTH\n*\n         LM    R14,R12,12(R13)     RESTORE THE REGISTERS\n         BR    R14                 RETURN TO CALLER\n*\nINITVARN MVC   BHBVARN(*-*),STEMPREF    *** EXECUTE ONLY ***\n*\nINITVARS MVC   0(*-*,R15),2(R3)    *** EXECUTE ONLY ***\n*\n         DROP  R2\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CREATE A NUMERIC SUFFIX                                      *\n*                                                                     *\n*        REG 0 CONTAINS A BINARY VALUE THAT WILL BE CONVERTED TO      *\n*        CHARACTER AND USED TO BUILD A SUFFIX FIELD.                  *\n*                                                                     *\n***********************************************************************\n*\nBUILDSUF DS    0H\n         STM   R14,R1,12(R13)      SAVE REGISTERS\n         CVD   R0,DOUBLE           FIRST, CONVERT TO PACKED DECIMAL\n         MVC   GENLWORK(9),=X'402020202020212040'\n         LA    R1,GENLWORK+7       POINT AT WHERE ZERO WOULD BE\n         EDMK  GENLWORK(9),DOUBLE+4     ALLOW FOR 9,999,999 HITS\n*\n         MVC   SUFXDATA,BLANKS     BLANK FOR GOOD MEASURE\n         LA    R15,SUFXDATA        POINT AT TARGET AREA\n*\nBUILDSUL DS    0H\n         MVC   0(1,R15),0(R1)      COPY ONE CHARACTER\n         LA    R15,1(,R15)         INCREMENT SUFFIX AREA\n         LA    R1,1(,R1)           INCREMENT EDITED NUMBER POINTER\n         CLI   0(R1),C' '          CHECK FOR END OF THE NUMBER\n         BNE   BUILDSUL            LOOP IF NOT AT THE END\n*\n         LA    R1,SUFXDATA         POINT AT START OF DATA\n         SR    R15,R1              GET LENGTH OF THE SUFFIX\n         STH   R15,SUFXLENG        STORE THE SUFFIX LENGTH\n*\n         LM    R14,R1,12(R13)      RESTORE SAVED REGISTERS\n         BR    R14\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        FIND THE BOOKSHELF NAME AND RETURN THE BOOKSHELF DATA        *\n*        SET NAME.                                                    *\n*                                                                     *\n*        REGISTER 1 POINTS TO THE BOOKSHELF NAME                      *\n*        REGISTER 15 ON RETURN POINTS TO THE BOOKSHELF DATA SET NAME  *\n*                                                                     *\n***********************************************************************\n*\nLKUPBKS  DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n*\n         L     R9,BKABKSEX         LOAD BOOKSHELF EXTRACT TABLE\n         USING BKEDSECT,R9\n*\n         L     R9,BKEFIRST         POINT AT FIRST ENTRY\n         USING BKEENTRY,R9\n         USING BKNDSECT,BKEEDATA\n*\nLKUPBKSL DS    0H\n         CLC   BKNBKSID,0(R1)      MATCH NAMES\n         BE    LKUPBKSF            BRANCH IF FOUND\n         ICM   R9,15,BKEENEXT      LOAD THE NEXT ADDRESS\n         BNZ   LKUPBKSL            LOOP IF NOT AT THE END\n*\n         LA    R15,=CL44'BOOKSHELF.DATA.SET.NOT.FOUND'\n         B     LKUPBKSX            AND RETURN\n*\nLKUPBKSF DS    0H\n         LA    R15,BKNDSNME        POINT AT DATA SET NAME\n*\nLKUPBKSX DS    0H\n         ST    R15,16(,R13)        STORE RETURN DATA SET NAME\n         LM    R14,R12,12(R13)     RESTORE THE REGISTERS\n         BR    R14\n*\n         DROP  R9\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        LOCATE A DATA SET NAME                                       *\n*                                                                     *\n*        REGISTER 1 POINTS TO THE DATA SET NAME ON ENTRY              *\n*                                                                     *\n*        ON RETURN, REGISTER 15 POINTS TO A SEVEN BYTE AREA,          *\n*        CONTAINING THE VOLUME SERIAL NUMBER FOLLOWED BY THE          *\n*        MIGRATION LEVEL, 0 (REAL DASD), 1 (DASD MIGRATION),          *\n*        2 (TAPE MIGRATION), OR 3 (DATA SET NOT FOULD).               *\n*                                                                     *\n***********************************************************************\n*\nLOCATVOL DS    0H\n         MVC   CAMLST(CAMLSTML),CAMLSTMD    COPY CAMLIST MODEL\n         ST    R1,CAMLST+4         STORE DSNAME ADDR IN CAMLST\n         LA    R15,CAMLSTWK        POINT AT LOCATE WORK AREA\n         ST    R15,CAMLST+12       STORE IN CAMLST\n*\n         LOCATE CAMLST             DO THE LOCATE\n         LTR   R15,R15             TEST RETURN CODE\n         BNZ   LOCATNOT            IF NON-ZERO ASSUME NOT CATALOGED\n*\n         LA    R15,CAMLSTVL        POINT AT VOLUME SERIAL NUMBER\n         MVI   CAMLSTMG,C'0'       ASSUME CATALOGUED TO DASD\n*\n         CLC   CAMLSTVL,=C'MIGRAT' CHECK FOR HSM ARCHIVE\n         BNE   LOCATRET            RETURN IF NOT\n*\n         MVI   CAMLSTMG,C'2'       ASSUME TAPE ARCHIVE\n         TM    CAMLSTD3,UCB3TAPE   CHECK THIS ASSUMPTION\n         BO    LOCATRET            BRANCH IF THIS IS TRUE\n         MVI   CAMLSTMG,C'1'       SET DASD MIGRATION LEVEL\n         B     LOCATRET            AND RETURN\n*\nLOCATNOT DS    0H\n         LA    R15,=C'******3'     POINT AT NOT FOUND\n*\nLOCATRET DS    0H\n         BR    R14                 RETURN TO CALLER\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DETERMINE THE PDF DATA SET NAME                              *\n*                                                                     *\n*        REGISTER 1 POINTS TO THE DATA SET NAME ON ENTRY              *\n*        REGISTER 0 IS ZERO FOR A CONVENTION PDF DATA SET NAME        *\n*        REGISTER 0 POINTS TO THE 12 CHARACTER PUB NUMBER FOR         *\n*        THE ALTERNAME PDF DATA SET NAME CASE                         *\n*                                                                     *\n*        ON RETURN, REGISTER 1 POINTS TO THE PDF DATA SET NAME        *\n*        AND REGISTER 15 POINTS TO THE VOLSER/MIGRATE LEVEL.          *\n*                                                                     *\n***********************************************************************\n*\nFINDPDFN DS    0H\n         STM   R14,R12,12(R13)     SAVE THE REGISTERS\n         LR    R3,R0               SAVE THE PUBNO POINTER\n*\n         MVC   PDFDSN,0(R1)        COPY THE DATA SET NAME\n*\n         LA    R1,PDFDSN+L'PDFDSN  ASSUME IT'S THE FULL LENGTH\n         TRT   PDFDSN,BLANKTRT     SCAN FOR THE END OF THE DSN\n*\n         SH    R1,=H'5'            DECREMENT FOR THE \".BOOK\"\n         MVC   0(5,R1),=C'.PDF '   CONVERT TO A PDF NAME\n         LR    R2,R1               SAVE FOR ALTERNATE CASE\n*\n         LA    R1,PDFDSN           POINT AT PDF DATA SET NAME\n         BAL   R14,LOCATVOL        SEE IF IT EXISTS\n         CLI   0(R15),C'*'         CHECK THE RETURN VOLUME\n         BNE   FINDPDFX            EXIT IF PDF DATA SET FOUND\n*\n         LTR   R0,R0               IS THIS AN ALTERNAME REQUEST\n         BZ    FINDPDFX            EXIT IF NOT\n*\n         LA    R1,PDFDSN           POINT AT START OF NAME\nFINDPDFL DS    0H\n         BCTR  R2,0                BACK UP ONE\n         CR    R2,R1               MAKE SURE WE DON'T LOOP TOO FAR\n         BNH   FINDPDFB            BAD NEWS IF WE CAN'T FIND A PERIOD\n         CLI   0(R2),C'.'          FIND THE PREVIOUS PERIOD\n         BNE   FINDPDFL\n*\n         MVC   1(4,R2),0(R3)       COPY THE FIRST 4 CHARS OF PUB NO\n         MVC   5(4,R2),5(R3)       COPY CHARS 6-9 OF PUB NO\n         MVC   9(5,R2),=C'.PDF '   COPY THE PDF SUFFIX\n*\n         LA    R1,PDFDSN           POINT AT PDF DATA SET NAME\n         BAL   R14,LOCATVOL        SEE IF IT EXISTS\n         CLI   0(R15),C'*'         CHECK THE RETURN VOLUME\n         BNE   FINDPDFX            EXIT IF PDF DATA SET FOUND\n*\nFINDPDFB DS    0H\n         MVC   PDFDSN,BLANKS       BLANK OUT THE NAME\n         MVC   PDFDSN(5),=C'NONE ' AND INDICATE WE DON'T HAVE ONE\n*\nFINDPDFX DS    0H\n         LA    R1,PDFDSN           POINT AT PDF DATA SET NAME\n         ST    R1,24(,R13)         RETURN DATA SET NAME\n         ST    R15,16(,R13)        RETURN VOLUME SERIAL NUMBER\n*\n         LM    R14,R12,12(R13)     RESTORE THE REGISTERS\n         BR    R14\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n*\n         DS    0D\n         DS    CL7                 PADDING FOR ALIGNMENT\nNULLVALU DS    0CL44               DEFINE A NULL VALUE\n         DC    C'*'\nBLANKS   DC    CL256' '            BLANKS FOR BLANKING AND UPPERCASING\n*\nEXCOMID  DC    CL8'IRXEXCOM'       IRXEXCOM ID\n*\nCPSNAME  DC    CL8'CCCBKCPS'       CELL POOL SUBROUTINE NAME\n*\nBPXWRNAM DC    CL8'BPX1WRT'        USS WRITE ROUTINE ADDRESS\n*\nZERO     DC    F'0'                A WORD OF ZEROS\n*\nHITMODEL BKMGRCPS ID=HIT,SP=10,SIZE=100,LOC=ANY\nSRCMODEL BKMGRCPS ID=SRC,SP=20,SIZE=4,LOC=ANY\n*\nSPECTBLI DS    0F\n         DC    Y(SPECTBL2-SPECTBLS),Y(SPECTB2N)\n         DC    Y(SPECTBL3-SPECTBLS),Y(SPECTB3N)\n         DC    Y(SPECTBL4-SPECTBLS),Y(SPECTB4N)\n         DC    Y(SPECTBL5-SPECTBLS),Y(SPECTB5N)\n         DC    Y(SPECTBL6-SPECTBLS),Y(SPECTB6N)\n         DC    Y(SPECTBL7-SPECTBLS),Y(SPECTB7N)\n*\nSPECTBLS DS    0H\nSPECTBL2 DS    0CL2\n         DC    C'0',C' '\n         DC    C'1',C'!'\n         DC    C'2',C'\"'\n         DC    C'3',C'#'\n         DC    C'4',C'$'\n         DC    C'5',C'%'\n         DC    C'6',C'&&'\n         DC    C'7',C''''\n         DC    C'8',C'('\n         DC    C'9',C')'\n         DC    C'A',C'*'\n         DC    C'B',C'+'\n         DC    C'C',C','\n         DC    C'D',C'-'\n         DC    C'E',C'.'\n         DC    C'F',C'/'\nSPECTB2N EQU   (*-SPECTBL2)/L'SPECTBL2\n*\nSPECTBL3 DS    0CL2\n         DC    C'A',C':'\n         DC    C'B',C';'\n         DC    C'C',C'<'\n         DC    C'D',C'='\n         DC    C'E',C'>'\n         DC    C'F',C'?'\nSPECTB3N EQU   (*-SPECTBL3)/L'SPECTBL3\n*\nSPECTBL4 DS    0CL2\n         DC    C'0',C'@'\nSPECTB4N EQU   (*-SPECTBL4)/L'SPECTBL4\n*\nSPECTBL5 DS    0CL2\n         DC    C'B',X'AD'         LEFT BRACKET\n         DC    C'C',C'\\'\n         DC    C'D',X'BD'         RIGHT BRACKET\n         DC    C'E',C'\u00ac'\n         DC    C'F',C'_'\nSPECTB5N EQU   (*-SPECTBL5)/L'SPECTBL5\n*\nSPECTBL6 DS    0CL2\n         DC    C'0',C'`'\nSPECTB6N EQU   (*-SPECTBL6)/L'SPECTBL6\n*\nSPECTBL7 DS    0CL2\n         DC    C'B',C'{'\n         DC    C'C',C'|'\n         DC    C'D',C'}'\n         DC    C'E',C'~'\n         DC    C'F',C'?'\nSPECTB7N EQU   (*-SPECTBL7)/L'SPECTBL7\n*\nSRCHARGN DC    Y(L'SRCHARGA)\nSRCHARGA DC    C'SEARCHARGUMENTS'\n*\nSRCHHITN DC    Y(L'SRCHHITA)\nSRCHHITA DC    C'SEARCHHITS'\n*\nSRCHRETN DC    Y(L'SRCHRETA)\nSRCHRETA DC    C'SEARCHRETURN'\n*\nBLANKTRT DC    XL256'00'           TABLE FOR LOCATING BLANKS\n         ORG   BLANKTRT+C' '\n         DC    X'FF'\n         ORG   ,\n*\nHTMLCOMM DC    C'<!-- CCCBKSRV -->'\n         DC    X'15'\nHTMLCOML EQU   *-HTMLCOMM\n*\nCAMLSTMD CAMLST NAME,*-*,,*-*      MODEL CAMLST\nCAMLSTML EQU   *-CAMLSTMD\n*\nPATCH    DC    0D'0',32S(*)\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\nLITERALS LTORG ,\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        DYNAMIC WORK AREA                                            *\n*                                                                     *\n***********************************************************************\n*\nWORKAREA DSECT\nSAVEAREA DS    9D\n*\nDOUBLE   DS    D                   DOUBLE WORD WORK AREA\n*\nRETCODE  DS    F\nFUNCCODE DS    CL4                 FUNCTION CODE\n*\nHITBLOCK BKMGRCPS ID=XXX,SP=0,SIZE=0\nHITBLOCL EQU   *-HITBLOCK\n*\nSRCBLOCK BKMGRCPS ID=XXX,SP=0,SIZE=0\nSRCBLOCL EQU   *-SRCBLOCK\n*\nAIRXEXCM DS    A(*-*)              ADDRESS OF REXX VARIABLE ROUTINE\n*\nCPSADDR  DS    A(*-*)              ADDRESS OF CELL POOL ROUTINE\n*\nBPXWRITE DS    A(*-*)              ADDRESS OF BPX1WRT\n*\nEXCOMPRM DS    0F                  PARM LIST FOR IRXEXCOM\nAEXCOMP1 DS    F                      ---> IRXEXCOM ID\nAEXCOMP2 DS    F                      ---> 0\nAEXCOMP3 DS    F                      ---> 0\nAEXCOMP4 DS    F                      ---> SHVBLOCK\nAEXCOMP5 DS    F                      ---> ENVBLOCK\nAEXCOMP6 DS    F                      ---> RETURN CODE\n*\nEXCOMRC  DS    F                   RETURN CODE FROM IRXEXCOM\n*\nSTEMPREL DS    H                   LENGTH OF STEM VARIABLE PREFIX\nSTEMPREF DS    CL32                STEM VARIABLE PREFIX\n*\nSUFXLENG DS    H                   SUFFIX LENGTH\nSUFXDATA DS    CL16                SUFFIX VARIABLE NAME\n*\nRETNUM   DS    F                   NUMBER OF RECORDS RETURNED\nHITCOUNT DS    F                   NUMBER OF UNIQUE HITS\nHITRETN  DS    F                   NUMBER OF UNIQUE HITS RETURNED\n*\nHITCHAIN DS    A                   ADDRESS OF FIRST HIT BLOCK\nHITLAST  DS    A                   ADDRESS OF LAST HIT BLOCK\n*\nSRCHBKNM DS    CL8                 LAST BOOK NAME (FOR SEARCHING)\n*\nHITMIN   DS    F                   MINIMUM HIT NUMBER RETURNED\nHITMAX   DS    F                   MAXIMUM HIT NUMBER RETURNED\n*\nSRCHNUM  DS    F                   NUMBER OF SEARCH ARGUMENTS\nSRCHAIN  DS    A                   CHAIN OF SEARCH ARGUMENTS\n*\nBPXWRPRM DS    0F                  BPX1WRT PARAMETER LIST\nBPXWRFD  DS    A                   FILE DESCRIPTION POINTER\nBPXWRBUF DS    A                   BUFFER ADDRESS ADDRESS\nBPXWRALT DS    A                   ALET ADDRESS\nBPXWRBFL DS    A                   BUFFER LENGTH ADDRESS\nBPXWRRVL DS    A                   WRITE LENGTH RETURN ADDRESS\nBPXWRRET DS    A                   RETURN CODE ADDRESS\nBPXWRRSN DS    A                   REASON CODE ADDRESS\nBPXWRLST EQU   *-4,1               LAST PARAMETER\n*\nOUTFILED DS    F                   FILE DESCRIPTION NUMBER\nOUTBUFAD DS    A                   BUFFER ADDRESS\nOUTBUFLN DS    F                   BUFFER LENGTH\nOUTBUFRV DS    F                   WRITE COUNT RETURN VALUE\nOUTRETCD DS    F                   RETURN CODE\nOUTRSNCD DS    F                   REASON CODE\n*\n         DS    0D\nOUTBUFFR DS    CL256               OUTPUT BUFFER\n*\n         DS    0D\nGENLWORK DS    XL1024              GENERAL WORK AREA\n*\n         ORG   GENLWORK\nSRCHARGL DS    H                   LENGTH OF SEARCH ARGUMENTS\nSRCHARGS DS    CL256               SAVE AREA FOR RAW SEARCH ARGUMENTS\n*\n         ORG   GENLWORK\nSRCHDEND DS    A                   ADDRESS OF LAST BYTE TO SEARCH\nSRCHDLNG DS    H                   LENGTH OF DATA TO SEARCH\nSRCHDATA DS    CL256               AREA TO MOVE BOOK SEARCH DATA\nSRCHTRTT DS    XL256               SEARCH TRT TABLE\n*\n         ORG   GENLWORK\nCAMLST   CAMLST NAME,*-*,,*-*\n*\nPDFDSN   DS    CL44                AREA TO BUILD PDF DATA SET NAME\n*\n         DS    0D\nCAMLSTWK DS    CL265\n         ORG   CAMLSTWK\nCAMLSTCT DS    H\nCAMLSTDV DS    XL4\nCAMLSTD3 EQU   CAMLSTDV+2,1\nCAMLSTVL DS    CL6\nCAMLSTMG DS    0C\nCAMLSTSQ DS    H\n*\n         ORG   ,                   GET MAXIMUM LENGTH\n*\n         DS    0D\nWORKLENG EQU   *-WORKAREA\n*\n***********************************************************************\n*                                                                     *\n*        AREA FOR EACH RETURNED VARIABLE                              *\n*                                                                     *\n***********************************************************************\n*\nBHBDSECT DSECT ,                   BOOK HIT BLOCK\nBHBSHV   DS    CL(SHVBLEN)         REXX SHARED VARIABLE BLOCK\n*\nBHBVARN  DS    CL48                VARIABLE NAME\n*\n***********************************************************************\n*                                                                     *\n*        WHILE EACH RETURNED FIELD IS UNIQUELY DEFINED, THE ACTUAL    *\n*        RETURNED DATA IS COMPRESSED WITH ONLY A SINGLE BLANK         *\n*        BETWEEN EACH DATA ITEM.  THE DEFINITION OF EACH FIELD        *\n*        IS TO INSURE THE MAXIMUM SPACE IS AVAILABLE.                 *\n*                                                                     *\n*        ANY RETURNED FIELD WITH IS ALL BLANK MUST BE REPLACED WITH   *\n*        A NON-BLANK VALUE SINCE EVERYTHING IS COMPRESSED.            *\n*                                                                     *\n*        ON A SECONDARY HIT RECORD, THE FIELDS MARKED BY \"*\" ARE      *\n*        SIMPLY RETURNED AS \"*\" TO SAVE OVERHEAD.                     *\n*                                                                     *\n***********************************************************************\n*\nBHBBKRET DS    0C                  RETURNED VARIABLE DATA\nBHBBKNAM DS    CL8                 BOOK NAME\n         DS    C\nBHBBKPUB DS    CL12               *BOOK PUBLICATION NUMBER\n         DS    C\nBHBBKDTE DS    CL10               *BOOK BUILD DATE\n         DS    C\nBHBBKTIM DS    CL8                *BOOK BUILD TIME\n         DS    C\nBHBBKDSN DS    CL44               *BOOK DATA SET NAME\n         DS    C\nBHBBKVOL DS    CL7                *BOOK DATA SET VOL SER/MIGRATE LEVEL\n         DS    C\nBHBBKSHF DS    CL8                 BOOKSHELF NAME\n         DS    C\nBHBBKSHD DS    CL44                BOOKSHELF DATA SET NAME\n         DS    C\nBHBBKPDF DS    CL44               *BOOK PDF DATA SET NAME\n         DS    C\nBHBBKPDV DS    CL7                *PDF DATA SET VOLUME/MIGRATE LEVEL\n         DS    C\nBHBBKLEN EQU   *-BHBBKRET          LENGTH OF RETURN DATA MINUS TITLE\nBHBBKTTL DS    CL200              *BOOK TITLE\n*\n         DS    0D\nBHBLNGTH EQU   *-BHBDSECT          LENGTH OF BOOK HIT BLOCK\n*\nSABDSECT DSECT ,                   SEARCH ARGUMENT DSECT\nSABNEXT  DS    A                   ADDRESS OF NEXT SEARCH ARGUMENT\nSABLENG  DS    H                   LENGTH OF THIS SEARCH ARGUMENT\nSABDATA  DS    CL64                SEARCH ARGUMENT DATA\n         DS    0D\nSABLNGTH EQU   *-SABDSECT          LENGTH OF SEARCH ARGUMENT BLOCK\n*\n         PUSH  PRINT\n         PRINT NOGEN\n         CVT   DSECT=YES\n*\n*        IHAPVT\n*\n         IEFJESCT\n*\n         IEFJSCVT\n*\n         IEFUCBOB\n*\n         IRXSHVB                   REXX SHARED VARIABLE BLOCK\n*\n         BPXYCONS                  OPENEDITION DEFINITIONS\n*\n         BKMGRCSA\n*\n         BKMGRINF\n*\n         POP   PRINT\n*\n         END   CCCBKSRV\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCCLOCAT": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x982/\\x00\\x982/\\x15\\x02\\x01\\xca\\x01\\xca\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-11-18T00:00:00", "modifydate": "1998-11-18T15:02:00", "lines": 458, "newlines": 458, "modlines": 0, "user": "KEM00"}, "text": "LOCATE   TITLE 'TSO COMMAND TO LOCATE DATA SET AND RETURN VOLUME INFO'\n***********************************************************************\n*                                                                     *\n*        CCCLOCAT (ALIAS LOCATE)                                      *\n*                                                                     *\n*        THIS PROGRAM IS A TSO COMMAND THAT IS DESIGNED TO            *\n*        RUN IN A CLIST OR REXX EXEC ONLY.  IT WILL DETERMINE         *\n*        IF THE DATA SET NAME PASSED IN THE PARAMETER LIST IS         *\n*        CATALOGUED AND, IF SO, WILL RETURN THE DATA SET'S            *\n*        VOLUME AND DEVICE TYPE INFORMATION IN CLIST/REXX             *\n*        VARIABLES.                                                   *\n*                                                                     *\n*        THIS PROGRAM CAN ALSO RUN AS A NORMAL MVS CALLED PROGRAM.    *\n*        IN THIS MODE, THE ONLY RETURN IS THE RETURN CODE AND         *\n*        ARE DIFFERENT FROM THE TSO COMMAND RETURN CODES,             *\n*        INDICATING IF THE DATA SET EXISTS AND IF IT IS ARCHIVED.     *\n*                                                                     *\n*        INPUT - TSO COMMAND PARAMETER LIST WITH ONE POSITIONAL       *\n*                PARAMETER - THE DATA SET NAME.                       *\n*                                                                     *\n*        OUTPUT - TWO CLIST/REXX VARIABLES AND A RETURN CODE          *\n*                 (&)DATASETVOLUME - VOLUME SERIAL NUMBER             *\n*                 (&)DATASETDEVICE - DEVICE TYPE (GENERIC)            *\n*                                                                     *\n*        TSO COMMAND RETURN CODES                                     *\n*                                                                     *\n*                 RETURN CODE 0 - DATA SET EXISTS - VARIABLES SET     *\n*                 RETURN CODE 4 - DATA SET NOT CATALOGUED             *\n*                 RETURN CODE 8 - UNABLE TO CREATE VARIABLES          *\n*                 RETURN CODE 12 - SERIOUS ERROR IN PROGRAM           *\n*                                                                     *\n*        CALLED PROGRAM RETURN CODES                                  *\n*                                                                     *\n*                 RETURN CODE 0 - DATA SET EXISTS                     *\n*                 RETURN CODE 4 - DATA SET NOT CATALOGUED             *\n*                 RETURN CODE 8 - DATA SET ARCHIVED TO DASD           *\n*                 RETURN CODE 12 - DATA SET ARCHIVED TO TAPE          *\n*                                                                     *\n*        ATTRIBUTES - REENTRANT, REFRESHABLE, AMODE 31, RMODE ANY,    *\n*                     UNAUTHORIZED                                    *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         PUNCH '         ALIAS LOCATE'\n*\nCCCLOCAT CSECT\nCCCLOCAT AMODE 31\nCCCLOCAT RMODE ANY\n*\n         USING CCCLOCAT,R15\n         B     AROUNDID\n         DC    AL1(33)\n         DC    CL8'CCCLOCAT'\n         DC    CL8'V 1.2.0'\n         DC    CL8'&SYSDATE'\n         DC    CL8' &SYSTIME'\nAROUNDID DS    0H\n         STM   R14,R12,12(R13)         SAVE THE REGISTERS\n*\n         LR    R12,R15                 LOAD REGISTER 12 WITH ENTRY\n         DROP  R15\n         USING CCCLOCAT,R12            ESTABLIST ADDRESSABILITY\n*\n         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*\n         LA    R0,WORKLENG             LOAD LENGTH OF GETMAINED AREA\n         GETMAIN RU,LV=(0),LOC=(BELOW,ANY)\n         LR    R14,R1                  COPY FOR THE MOVE LONG\n         LA    R15,WORKLENG            GET THE LENGTH\n         SLR   R3,R3\n         MVCL  R14,R2                  CLEAR THE AREA\n*\n         ST    R13,4(,R1)              STORE ADDRESS OF PREVIOUS\n*\n         ST    R1,8(,R13)              STORE ADDRESS OF CURRENT\n*\n         LR    R13,R1                  LOAD REGISTER 13 WITH SAVEAREA\n*\n         USING WORKAREA,R13            ESTABLISH ADDRESSABILITY\n*\n         TM    0(R8),X'80'             TEST FOR ONE PARAMETER\n         BZ    CMDPARM                 BRANCH IF NOT, IT'S TSO\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        EXTRACT THE DATA SET NAME FROM THE CALLED PARAMETER          *\n*                                                                     *\n***********************************************************************\n*\n         L     R5,0(R8)                LOAD POINTER TO DSNAME\n         LH    R4,0(,R5)               LOAD LENGTH OF DSNAME\n         LA    R5,2(,R5)               POINT TO ACTUAL DATA SET NAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         MVI   NAMEFLD,C' '            BLANK OUT THE DSNAME BUFFER\n         MVC   NAMEFLD+1(43),NAMEFLD   FINISH BLANKING OUT THE BUFFER\n         EX    R4,MOVEDSN              MOVE IN THE DSNAME\n*\n         B     LOCATEIT                AND GO LOCATE THE DATA SET\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARAMETER LIST                                   *\n*        INITIALIZE OUTPUT DATA CONTROL BLOCKS IN WORKAREA            *\n*                                                                     *\n***********************************************************************\n*\n         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL\n*\nCMDPARM  DS    0H\n         LA    R4,PPLSECT              LOAD ADDRESS OF PARSE PARAMETER\n         USING PPL,R4                  ESTABLISH ADDRESSABILITY TO PPL\n*\n         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE\n         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT\n*                                      CONTROL TABLE FROM CPPL\n         SLR   R3,R3                   ZERO REGISTER 3\n         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB                  LOAD ADDRESS OF ECB\n         STM   R1,R3,PPLSECT           STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN PPL\n         MVC   PPLPCL,PCLADDR          MOVE POINTER TO PARAMETER\n*                                      CONTROL LIST INTO PPL\n         LA    R2,PARSBACK             LOAD ADDRESS OF FULLWORD TO\n*                                      CONTAIN ADDRESS OF PDE RETURNED\n*                                      BY PARS\n         ST    R2,PPLANS               STORE POINTER TO RETURN ADDRESS\n         MVC   PPLCBUF,CPPLCBUF        MOVE POINTER TO COMMAND BUFFER\n*                                      INTO PPL\n         LA    R2,PPLUWA               LOAD ADDRESS OF USER WORK AREA\n         ST    R2,PPLUWA               STORE ADDRESS IN PPL\n         DROP  R4,R8                   DROP ADDRESSABILITY\n*\n***********************************************************************\n*                                                                     *\n*        CALLTSSR TO PARSE (ENTRY NAME IKJPARS)                       *\n*        ON RETURN PARSBACK -> PDL                                    *\n*        HANDLE ALL ERROR CODES RETURNED BY PARS                      *\n*        IF NECESSARY CALL GENERAL FAIL SERVICE ROUTINE               *\n*                                                                     *\n***********************************************************************\n*\n         CALLTSSR  EP=IKJPARS,MF=(E,PPLSECT)\n*                                      CALL PARS TO PARSE COMMAND\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BNZ   BADPARSE                NO, BAD NEWS\n*\n***********************************************************************\n*                                                                     *\n*        SET UP ADDRESSABILITY TO PDL                                 *\n*           AND LOAD REGISTER 6 WITH ADDRESS OF DSNAME PDE            *\n*                                                                     *\n***********************************************************************\n*\n         L     R9,PARSBACK             LOAD POINTER TO PARS ANSWER\n         USING IKJPARMD,R9             ESTABLISH ADDRESSABILITY TO PDL\n         LA    R6,DSNAME               LOAD POINTER TO DSNAME\n         DROP  R9                      DROP ADDRESSABILITY TO PDL\n*\n         L     R5,0(R6)                LOAD POINTER TO DSNAME\n         LH    R4,4(R6)                LOAD LENGTH OF DSNAME\n         BCTR  R4,0                    DECREMENT LENGTH FOR EXECUTE OF\n*                                      MOVE\n         MVI   NAMEFLD,C' '            BLANK OUT THE DSNAME BUFFER\n         MVC   NAMEFLD+1(43),NAMEFLD   FINISH BLANKING OUT THE BUFFER\n         EX    R4,MOVEDSN              MOVE IN THE DSNAME\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        LOCATE THE DATA SET                                          *\n*                                                                     *\n***********************************************************************\n*\nLOCATEIT DS    0H\n         MVC   CAMLST(CAMLSTML),CAMLSTMD    COPY CAMLIST MODEL\n         LA    R1,NAMEFLD              POINT AT NAME FIELD\n         ST    R1,CAMLST+4             STORE IN CAMLST\n         LA    R1,LOCWORK              POINT AT LOCATE WORK AREA\n         ST    R1,CAMLST+12            STORE IN CAMLST\n*\n         LOCATE CAMLST                 DO THE LOCATE\n         LTR   R15,R15                 TEST RETURN CODE\n         BNZ   NOTCAT                  IF NON-ZERO ASSUME NOT CATALOGED\n*\n         EDTINFO RTNUNIT,DEVTYPE=LOCDEVT,OUTUNIT=DEVNAME,              X\n               MF=(E,EDTINFOP,COMPLETE)\n*\n         LTR   R15,R15\n         BZ    GOTDEVN\n         MVC   DEVNAME,=CL8'UNKNOWN'\n*\nGOTDEVN  DS    0H\n*\n         TM    0(R8),X'80'         CHECK THE PARM LIST FORMAT\n         BZ    TSOVARS             GO RETURN THE TSO VARIABLES\n*\n         XC    RETCODE,RETCODE     CLEAR THE RETURN CODE\n         CLC   LOCVOLSR,=C'MIGRAT' CHECK FOR MIGRATED VOLUME\n         BNE   RETURN              LEAVE IF NOT MIGRATED RETURN CODE\n*\n         TM    LOCDEVT+2,X'80'     TEST FOR TAPE DEVICE\n         BO    ARCHTAPE            IF SO, RETURN TAPE ARCHIVE\n         B     ARCHDASD            IF NOT, RETURN DASD ARCHIVE\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTRUCT THE PARAMETER LIST FOR IKJCT441                    *\n*                                                                     *\n***********************************************************************\n*\nTSOVARS  DS    0H\n         L     R3,CVTPTR           FIND CVT\n         USING CVTMAP,R3\n*\n         L     R3,CVTTVT           FIND THE TSVT\n         USING TSVT,R3\n*\n         LA    R0,TSVEUPDT\n         ST    R0,ENTRYCDE\n         LA    R0,ENTRYCDE\n         ST    R0,CT441PRM+0\n*\n         LA    R0,VARINAME\n         ST    R0,NAMEADDR\n         LA    R0,NAMEADDR\n         ST    R0,CT441PRM+4\n*\n         LA    R0,NAMELENG\n         ST    R0,CT441PRM+8\n*\n         LA    R0,DATAADDR\n         ST    R0,CT441PRM+12\n*\n         LA    R0,DATALENG\n         ST    R0,CT441PRM+16\n*\n         LA    R0,TOKENPRM\n         ST    R0,CT441PRM+20\n         OI    CT441PRM+20,X'80'\n*\n         MVC   VARINAME(13),=C'DATASETVOLUME'\n*\n         LA    R15,13\n         LA    R1,LOCVOLSR\n         LA    R0,L'LOCVOLSR\n*\n         BAL   R14,TSOVARSV        GO CALL VARIABLE ROUTINE\n         LTR   R15,R15             TEST IF RETURN WAS GOOD\n         BNZ   NOTCLIST            ASSUME WE AREN'T IN CLIST IF BAD\n*\n         MVC   VARINAME(13),=C'DATASETDEVICE'\n*\n         LA    R15,13\n         LA    R1,DEVNAME\n         LA    R0,L'DEVNAME\n*\n         BAL   R14,TSOVARSV        GO CALL VARIABLE ROUTINE\n         LTR   R15,R15             TEST IF RETURN WAS GOOD\n         BNZ   NOTCLIST            ASSUME WE AREN'T IN CLIST IF BAD\n*\nALLDONE  XC    RETCODE,RETCODE         INDICATE GOOD END\n         B     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        SUBROUTINE TO CALL TSO VARIABLE SERVICES                     *\n*                                                                     *\n*        ON ENTRY, R1 POINTS TO DATA AREA                             *\n*                  R0 CONTAINS DATA LENGTH (MAXIMUM)                  *\n*                  R15 CONTAINS VARIABLE NAME LENGTH                  *\n*                  VARINAME CONTAINS VARIABLE NAME                    *\n*                  R14 IS RETURN ADDRESS                              *\n*                                                                     *\n*        A BRANCH IS MADE TO THE TSO VARIABLE ROUTINE, WHICH          *\n*        RETURNS TO THE CALLER VIA R14.                               *\n*                                                                     *\n***********************************************************************\n*\nTSOVARSV DS    0H\n         ST    R15,NAMELENG\n         ST    R1,DATAADDR\n*\n         AR    R1,R0               POINT PAST END OF STRING\n*\nCALCLOOP BCTR  R1,0                BACK UP TO THE PREVIOUS CHARACTER\n         CLI   0(R1),C' '\n         BH    CALCSTOR\n         BCT   R0,CALCLOOP\n*\n         LA    R0,1\n*\nCALCSTOR DS    0H\n         ST    R0,DATALENG\n*\n         LA    R1,CT441PRM         POINT AT PARM LIST\n         L     R15,TSVTVACC        LOAD THE VARIABLE ACCESS RTN\n         BR    R15                 CALL IT (WITH RETURN TO CALLER)\n*\n         DROP  R3                  DONE WITH TSVT\n*\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ERROR CONDITIONS                                             *\n*                                                                     *\n***********************************************************************\n*\nNOTCAT   LA    R0,4                    SET DATA SET NOT CATALOGUED\n         ST    R0,RETCODE\n         B     RETURN\n*\nARCHDASD DS    0H\nNOTCLIST LA    R0,8                    SET WE AREN'T IN A CLIST ENV\n         ST    R0,RETCODE\n         B     RETURN\n*\nARCHTAPE DS    0H\nBADPARSE LA    R0,12                   SET SERIOUS ERROR\n         ST    R0,RETCODE\n         B     RETURN\n*\n***********************************************************************\n*                                                                     *\n*        CLEANUP AREAS GETMAINED BY PARSE,                            *\n*           SET RETURN CODE, RESTORE REGISTERS AND                    *\n*           RETURN TO CALLER                                          *\n*                                                                     *\n***********************************************************************\n*\nRETURN   DS    0H\n         TM    0(R8),X'80'         CHECK THE PARM LIST FORMAT\n         BO    RETURN2             SKIP FREE PARSE DATA\n*\n         IKJRLSA PARSBACK          RELEASE AREAS GETMAINED BY PARS\n*\nRETURN2  DS    0H\n         L     R2,RETCODE          LOAD THE RETURN CODE\n*\n         LR    R1,R13              LOAD ADDRESS OF GETMAINED AREA\n         L     R13,4(,R13)         RELOAD ADDRESS OF PREVIOUS SAVE\n*\n         LA    R0,WORKLENG         LOAD LENGTH OF GETMAINED AREA\n         FREEMAIN RU,LV=(0),A=(1)  FREE GETMINED AREA\n*\n         LR    R15,R2              SET THE RETURN CODE\n         L     R14,12(,R13)        LOAD REGISTER 14 WITH RETURN\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BR    R14                 RETURN\n*\n******************** INSTRUCTIONS TO BE EXECUTED **********************\n*\nMOVEDSN  MVC   NAMEFLD(0),0(R5)\n*\n***************************** CONSTANTS *******************************\n*\n         EJECT\nCAMLSTMD CAMLST NAME,*-*,,*-*\nCAMLSTML EQU   *-CAMLSTMD\n*\nPATCH    DC    0D'0',32S(*)\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\nLITERALS LTORG ,\n*\nPCLADDR  DC    V(PARMTAB)\n*\n         EJECT\n************************ PARSE PARAMETER LIST *************************\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nPARMTAB  AMODE 31\nPARMTAB  RMODE ANY\n*\nDSNAME   IKJPOSIT  DSNAME,USID,                                        X\n               PROMPT='DSNAME',                                        X\n               HELP='DATA SET NAME'\n         IKJENDP\n*\n         EJECT\n************************ DSECTS (MAPPING MACROS) **********************\n         PRINT NOGEN\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n*\n         IKJPPL\nPPLLEN   EQU   *-PPL\n*\n         CVT   DSECT=YES\n*\n         IKJTSVT\n*\n*\n         PRINT GEN\n*\nWORKAREA DSECT\nSAVEAREA DS    9D\nRETCODE  DS    F\n*\nCAMLST   CAMLST NAME,*-*,,*-*\n*\n         DS    0D\nNAMEFLD  DS    CL44\n         DS    0D\nLOCWORK  DS    CL265\n         ORG   LOCWORK\nLOCCOUNT DS    H\nLOCDEVT  DS    XL4\nLOCVOLSR DS    CL6\nLOCVOLSQ DS    H\n         ORG   ,\n*\nPPLSECT  DS    0F\n         ORG   PPLSECT+PPLLEN\n*\nECB      DS    F\nPARSBACK DS    F\n*\n         EDTINFO MF=(L,EDTINFOP)\n*\nDEVNAME  DS    CL8\n*\nCT441PRM DS    6F\n*\nENTRYCDE DS    F\nNAMEADDR DS    A                        ADDRESS OF VARIABLE NAME\nNAMELENG DS    F                        LENGTH OF VARIABLE NAME\nDATAADDR DS    A                        ADDRESS OF VARIABLE DATA\nDATALENG DS    F                        LENGTH OF DATA\nTOKENPRM DS    F\n*\nVARINAME DS    CL32                     VARIABLE NAME FIELD\n*\n         DS    0D\nWORKLENG EQU   *-WORKAREA\n*\n         END   CCCLOCAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REXXCOMP": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17_\\x01\\x00\\x17_\\x155\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xc5\\xd4\\xf0\\xf0@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-23T00:00:00", "modifydate": "2000-06-23T15:35:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "KEM00"}, "text": "//BOOKMGRX JOB (*),'COMPILE BOOKMANAGER',MSGCLASS=Y,\n//             TIME=(,10),REGION=8M,NOTIFY=$\n//*\n/*ROUTE  XEQ   CCCMVS3\n/*JOBPARM      S=EE47\n//*LOGONID     #OPENMVS\n//REXX    EXEC PGM=REXXCOMP,PARM='XREF'\n//SYSPRINT  DD SYSOUT=*\n//SYSTERM   DD SYSOUT=*\n//SYSCEXEC  DD DSN=&&CEXEC,DISP=(MOD,PASS),UNIT=SYSVIO,\n//             SPACE=(800,(800,100))\n//SYSIN  DD    DSN=TSG00.REXX.OESRC(BOOKMGRX),DISP=SHR\n//*\n//OCOPY   EXEC PGM=IKJEFT01,\n//             COND=(5,LT,REXX)\n//SYSTSPRT  DD SYSOUT=*\n//IN        DD DSN=&&CEXEC,DISP=(OLD,DELETE)\n//OUT       DD PATH='/BookServer/cgi/bookmanager',\n//             PATHDISP=(KEEP,DELETE),PATHOPTS=(ORDWR,OCREAT),\n//             PATHMODE=(SIRUSR,SIWUSR,SIXUSR)\n//SYSTSIN   DD *\n         OCOPY INDD(IN) OUTDD(OUT) BINARY\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT449/FILE449.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT449", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}