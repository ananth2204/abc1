//SCOTTT JOB 'IKJEFLD',CLASS=A,MSGCLASS=X,NOTIFY=SCOTT
//*
//*     NAME:     SYS2.USERMODS(IKJEFLD )
//*     PURPOSE:  TO ASSEMBLE THE TSO LOGON EXIT
//*
//*
//S1   EXEC  ASMFCL
//*++ USERMOD(ABBW019) /* ADD TSO LOGON USEREXIT - IKJEFLD:
//*
//*           THIS MODIFICATION ADDS THE TSO LOGON EXIT WHICH WILL
//*           ENCRYPT THE PASSWORD THAT THE USER SPECIFIED IN THE
//*           LOGON COMMAND. THIS SOLVES THE SYS1.UADS SECURITY
//*           PROBLEM. NOTE: YOU MUST RUN UCLIN TO ADD MODULE IKJEFLD
//*           TO THE CDS BEFORE APPLYING THIS MOD (IKJEFLD IS NOT
//*           REFERENCED IN THE VINILLA SYSGEN STAGE2).
//*
//*           UCLIN CDS .
//*           ADD MOD(IKJEFLD) LMOD(IKJEFLA) DISTLIB(AOST4) .
//*           ENDUCL .
//*                                                                 */ .
//*++ VER(Z038) FMID(EBB1102) .
//*++ SRC(IKJEFLD) DISTLIB(ASRCLIB) .
//ASM.SYSIN  DD  *
         TITLE 'IKJEFLD - WDSC TSO LOGON PRE PROMPT EXIT'
         PRINT  NOGEN
IKJEFLD  CSECT
*
*
*                 ** ENTRY PARAMETER LIST **
*
* REG 1 POINTS TO A 16 WORD PARM LIST. THE PARMS ARE OF TWO TYPES -
*
*    1) STANDARD OS - PARM WORD POINTS TO DATA
*
*    2) PLI STRING DOPE VECTOR - PARM WORD POINTS TO TWO WORDS, FIRST
*                                OF WHICH POINTS TO DATA, SECOND OF
*                                WHICH IS MAX AND ACTUAL LENGTH OF
*                                THE DATA.
*
*  THE 16 WORD PARM LIST CONTAINS -
*
*  WORD   TYPE  I/O  PARAMETER * SEE TSO GUIDE 'LOGON PREPROMPT EXIT' *
*
*    1     SDV   X   CONTROL SWITCHES
*    2     SDV   X   TERMINAL INPUT LINE
*    3     SDV       USERID
*    4     SDV       PASSWORD
*    5     SDV       ACCOUNT
*    6     SDV       PROCEDURE
*    7     OS        REGION SIZE
*    8     SDV       JCL FOR LOGON
*    9     SDV       PSCB ACCTG STRING
*   10     SDV       PSCBATR1 VALUE
*   11     SDV       PSCBATR2 VALUE
*   12     SDV       PSCBGPNM VALUE
*   13     SDV       UPT  (THE TABLE, NOT ITS ADDRESS)
*   14     SDV       ECT  (THE TABLE, NOT ITS ADDRESS)
*   15     OS   X    ADDR OF ECB
*   16     OS   X    ADDR OF COMP CODE
*   17     OS        PERFORMANCE GROUP
*
*        X - CONTAINS SPECIFIED DATA AT ENTRY.  OTHERS USED TO SUPPLY
*            DATA TO LOGON PROCESSOR AT RETURN.
*
*              **  IKJEFA51(READ) AND IKJEFA52(WRITE) CALL LIST  **
*
* REG 1 POINTS TO 6 WORD STANDARD OS PARM LIST
*
* DISP  FIELD      SIZE    DESCRIPTION
*
*   0   ACIOFLGS  1 BYTE   BIT 0 0 = READ ALL MEMBER BLOCDS FOR UID
*                                1 = READ ONLY ONE PHYSICAL BLOCK
*                          BIT 1 0 = WORD 2 POINTS TO MEMBER NAME
*                                1 = WORD 2 POINTS TO BLDL LIST
*                          BIT 2 0 = WORD 3 NOT PERTINENT
*                                1 = WORD 3 POINTS TO DIR WORK AREA
*                          BIT 3 0 = OBTAIN CORE FOR EXISTING TREE ONLY
*                                1 = OBTAIN CORE FOR ONE EXTRA BLOCK
*                          BIT 4 0 = WRITE NOT REQUESTED
*                                1 = WRITE REQUESTED
*                          BIT 5 0 = READ DIR AND ALL MEMBER BLOCKS
*                                1 = READ DIRECTORY (INTO DIR WORK AREA
*                                    SPECIFIED BY WORD 3) ONLY.
*                          BIT 6 RESERVED
*                          BIT 7 RESERVED
*   1   ACIODCBA  3 BYTES  UADS DCB ADDR (OF BPAM DCB OPENED UPDAT)
*   4   ACIOMPTR  4 BYTES  MEMBER NAME/BLDL ADDRESS
*   8   ACIODRCT  4 BYTES  DIR WORK AREA ADDR.  MUST BE SAME ADDR AS
*                          THAT SPECIFIED IN ACIODCBA.  DIR WORK AREA
*                          MUST BE 256 BYTES IMMEDIATELY FOLLOWING THE
*                          88 BYTE BPAM DCB ( (IN OTER WORDS A 344
*                          BYTE AREA).
*  12   ACIOLINK  4 BYTES  IKJEFA51'S BLDL ENTRY ADDRESS.  SET TO ZERO
*                          BEFORE FIRST CALL AND NOT TOUCHED THEREAFTER
*  16   ACIONMBR  1 BYTE   NUMBER OF MEMBERS READ OR WRITTEN. NOT USED.
*  17   ACIOBUFR  3 BYTES  I/O BUFFER ADDR.  ADDR OF TREE AFTER READ.
*  20   ACIOMSGN  1 BYTE   CALLERS MSG NUMBER FOR SYSNAD. NOT USED.
*  21   ACIOPUTL  3 BYTES  ACCT PARM LIST FOR SYNAD.  NOT USED.
*
*
*              **  GENERAL INFORMATION  **
*
* 1. USER MUST LOGON WITH FORM 'LOGON UID/PASS ACCT(YNNNNNNNN)'
*
* 2. IKJEFA51 LABEL IKJASYND MUST BE NO-OPED (BR 14)
*
* 3. IKJEFLD IS REENTRANT AND ASSEMBLES WITH STANDARD SYS1.MACLIB
*
* 4. LINK IKJEFLD, IKJEFA51, IKJEFA52 TOGETHER WITH A NAME OF
*    IKJEFLD, ENTRY POINT OF IKJEFLD, AND ATTRIBUTE OF RENT.
*
*
*              **  GENERAL FLOW  **
*
*  1. GETMAIN DYNAMIC CORE FROM SP 0 FOR WORK SPACE.  USE DSECT 'WORK'
*     TO REFERENCE THE GOTTEN CORE.
*
*  2. OPEN (UPDAT) THE BPAM DCB FOR SYS1.UADS (DD SYSUADS).
*
*  3. DISENTANGLE THE PLS STRING DOPE VECTORS, FINDING THE ADDRESS AND
*     LENGTH OF THE TERMINAL USERS INPUT LINE.  POINT REG 8 AT THE
*     'L' IN LOGON (3270'S INSERT 3 BLANKS IN FRONT OF 'L').
*
*  4. VALIDATE THE INPUT LINE (MUST BE UID/PASS), DETERMINING THE
*     LENGTH OF THE USERID AND THE LOCATION OF THE PASSWORD.
*
*  5. CALL IKJEFA51 TO ATTEMPT TO READ THIS USERID'S TREE.  RETURN TO
*     MAINLINE IF SUCCESSFUL.  IF UID NOT FOUND, ISSUE
*     'INVALID USERID' MSG AND TERMINATE THE LOGON ATTEMPT.
*
*  6. VALIDATE THE ACCOUNTING DATA (DPAP) IN THE INPUT LINE.
*     IF VALID, MOVE THE DPAP TO UADS FOR THIS SESSION'S
*     CHARGES.  IF INVALID, SEND 'INVALID DPAP' MESSAGE AND
*     TERMINATE THE LOGON ATTEMPT.
*
*  7. ENCODE THE PASSWORD IN THE INPUT LINE (TO ALLOW COMPARE WITH
*     UADS PASSWORD(S)).  FIND THE FIRST PASSWORD IN THE UADS TREE
*     STRUCTURE.  IF THE LAST (6TH) BYTE IS 'F0' GO TO 7.  IF THE
*     INPUT PASSWORD MATCHES (6 DIGIT COMPARE) ONE OF THE PASSWORDS IN
*     THE TREE, REPLACE THE ORIGINAL PASSWORD IN THE INPUT LINE WITH
*     THE ENCODED PASSWORD AND EXIT TO NORMAL LOGON.  IF NO MATCH
*     EXISTS SEND 'INVALID PASSWORD' MSG AND TERMINATE THE LOGON.
*
*  8. X'F0' IN THE 6TH BYTE OF THE UADS PASSWORD MEANS THAT THE USER
*     MUST OBTAIN A NEW PASSWORD TO SUCCESSFULLY LOGON IN THIS PERIOD.
*     TO OBTAIN THE NEW PASSWORD HE MUST HAVE CORRECTLY ENTERED HIS
*     'OLD' PASSWORD AND MUST NOW RESPOND WITH THE CURRENT 6 DIGIT
*     NUMERIC AUTHORIZATION NUMBER.
*
*  9. SEND 'ENTER AUTHORIZATION NUMBER' MESSAGE AND HANG A READ ON
*     THE TERMINAL FOR HIS RESPONSE.  ENCODE THE RESPONSE, READ
*     $AUTHOR'S UADS TREE AND COMPARE THE USERS RESPONSE TO $AUTHOR'S
*     PASSWORD.  IF THE TWO ARE NOT EQUAL, TERMINATE
*     THE LOGON ATTEMPT.  IF EQUAL, GEN A NEW PASSWORD, SHOW IT TO THE
*     USER, ENCODE THE NEW PASSWORD AND PUT IT IN UADS AND THE INPUT
*     LINE.
*
* 10. REWRITE UADS, BOTH TO UPDATE THE NEW PASSWORD AND TO FREE
*     THE CORE OBTAINED FOR THE TREE.
*
* *NOTE* EACH SUCCESSFUL 'READ' BY IKJEFA51 OBTAINS DYNAMIC CORE IN
*        WHICH TO PLACE THE UADS TREE.  THIS CORE MUST BE FREED BY
*        IKJEFA52 BEFORE WE EXIT.  WE MAY OR MAY NOT NEED TO REWRITE
*        THE UADS TREE SO THE SWITCH 'FREESW' IS USED TO DETERMINE
*        WHETHER A FREE-CORE-ONLY OR A FREE-CORE-AND-REWRITE CALL WILL
*        BE MADE TO IKJEFA52.  SEE PARM BITS FOR FURTHER DETAILS.
*
         EJECT
*
*              **  UADS BLOCKS DEFINITION  **
*              ( EXTRACTED FROM IKJEFA42)
*
**/* *
**/* *                     H E A D E R   B L O C K                    *
**/* *                                                                *
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                                                                *
**/* *               I---------------------I---------------------I    *
**/* *          0    I UADSBLNG            I UADSFSQP            I    *
**/* *               I---------------------I---------------------I    *
**/* *          4    I UADSUSER                                  I    *
**/* *               I                                           I    *
**/* *               I                                           I    *
**/* *               I----------I----------I---------------------I    *
**/* *          12   I UADSBN01 I UADSBN02 I UADSMAXC            I    *
**/* *               I----------I----------I---------------------I    *
**/* *          16   I UADSATTR                                  I    *
**/* *               I-------------------------------------------I    *
**/* *          20   I UADSUPTP                                  I    *
**/* *               I-------------------------------------------I    *
**/* *          24   I UADSPWD1                                  I    *
**/* *               I-------------------------------------------I    *
**/* *                                                                *
**
**
**DECLARE
**  1 DHED     BASED(HEDBPTR),
**
**
**   2 UADSMHDR CHAR(14)  BDY(WORD),
**                                    /* COMMON HEADER AREA           *
**    3 UADSBLNG PTR(15)  BDY(BYTE),
**                                    /* BLOCK LENGTH                 *
**    3 UADSFSQP PTR(15)  BDY(BYTE),
**                                    /* OFFSET TO INITIAL FSQE (FREE *
**/*                                    ..SPACE QUEUE ELEMENT)        *
**    3 UADSUSER CHAR(8),             /* USERID                       *
**     4 UADSUSID CHAR(7),            /* USERID                       *
**     4 UADSIND1 PTR(8),             /* RESERVED                     *
**    3 UADSBN01 PTR(8),              /* RESERVED                     *
**    3 UADSBN02 CHAR(1),             /* FLAGS                        *
**     4 UADSNUSP  BIT(1),            /*..NO NON-USABLE SPACE         *
**/*                                    ..1 -- ONLY NON-USABLE SPACE  *
**/*                                    .......EXISTS IN THIS BLOCK   *
**     4 *         BIT(1),            /* RESERVED                     *
**     4 *         BIT(1),            /* RESERVED                     *
**     4 *         BIT(1),            /* RESERVED                     *
**     4 *         BIT(1),            /* RESERVED                     *
**     4 *         BIT(1),            /* RESERVED                     *
**     4 *         BIT(1),            /* RESERVED                     *
**     4 *         BIT(1),            /* RESERVED                     *
**   2 UADSMAXC PTR(16)  BDY(BYTE),
**                                    /* MAXIMUM CORE SIZE ALLOTTABLE *
**/*                                    ..TO THIS USER                *
**   2 UADSATTR CHAR(4),              /* SYSTEM ATTRIBUTES OF USERID  *
**    3 UADSIBMT CHAR(2),             /* IBM FLAG AREA                *
**     4 *        CHAR(1),            /* FIRST BYTE OF FLAGS          *
**      5 USATR00  BIT(1),            /* ..0 -- NO OPERATOR
**                                       CAPABILITY                   *
**/*                                    ..1 -- OPERATOR CAPABILITY    *
**      5 USATR01  BIT(1),            /* ..0 -- NO ACCOUNT CAPABILITY *
**/*                                    ..1 -- ACCOUNT CAPABILITY     *
**      5 USATR02  BIT(1),            /* ..0 -- NO JCL CAPABILITY     *
**/*                                    ..1 -- JCL CAPABILITY         *
**/*                                    FLAGS 3 THROUGH 15 ARE        *
**/*                                    ..RESERVED FOR IBM USE        *
**      5 *        BIT(1),            /* RESERVED                     *
**      5 *        BIT(1),            /* RESERVED                     *
**      5 *        BIT(1),            /* RESERVED                     *
**      5 *        BIT(1),            /* RESERVED                     *
**      5 *        BIT(1),            /* RESERVED                     *
**     4 *        CHAR(1),            /* SECOND BYTE OF FLAGS, 8 --
**                                       15                           *
**
**    3 UADSINST CHAR(2),             /* RESERVED                     *
**/*                                    FLAGS 16 THROUGH 31 ARE       *
**/*                                    ..RESERVED FOR INSTALLATION   *
**/*                                    ..USE                         *
**     4 *        CHAR(1),            /* THIRD BYTE OF FLAGS, 16 --
**                                       23                           *
**     4 *        CHAR(1),            /* FOURTH BYTE OF FLAGS         *
**   2 UADSUPTP PTR(31),              /* OFFSET TO CURRENT UPT        *
**   2 UADSPWD1 PTR(31);              /* OFFSET TO 1ST PASSWD OFFSET  *
**
**
**
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *            P A S S W O R D   O F F S E T   B L O C K           *
**/* *                                                                *
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                                                                *
**/* *               I----------I--------------------------------I    *
**/* *          0    I UADSPFLG I UADSPNEX                       I    *
**/* *               I----------I--------------------------------I    *
**/* *          4    I UADSPSUB                                  I    *
**/* *               I-------------------------------------------I    *
**/* *          8    I UADSPDAT                                  I    *
**/* *               I-------------------------------------------I    *
**/* *                                                                *
**
**
**DECLARE
**  1 DPOB     BASED(DPOBPTR),
**
**   2 UADSPFLG CHAR(1),              /* PASSWORD BLOCK INDICATORS    *
**    3 PFLG01   BIT(1),              /* ..0 -- CONTINUE CHAINING     *
**/*                                    ..1 -- LAST PASSWORD FOR THIS *
**/*                                    .......USERID                 *
**/*                                    ..FLAGS 1 THRU 7 ARE RESERVED *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**   2 UADSPNEX PTR(24)  BDY(BYTE),
**                                    /* OFFSET TO NEXT PASSWD OFFSET *
**/*                                    ..BLOCK                       *
**   2 UADSPSUB PTR(31),              /* OFFSET TO ASSOCIATED ACCOUNT *
**/*                                    ..NUMBER OFFSET BLOCK         *
**   2 UADSPDAT PTR(31);              /* OFFSET TO PASSWORD DATA
**                                       BLOCK                        *
**
**
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                   A C C O U N T   N U M B E R                  *
**/* *                     O F F S E T   B L O C K                    *
**/* *                                                                *
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                                                                *
**/* *               I----------I--------------------------------I    *
**/* *          0    I UADSAFLG I UADSANEX                       I    *
**/* *               I----------I--------------------------------I    *
**/* *          4    I UADSASUB                                  I    *
**/* *               I-------------------------------------------I    *
**/* *          8    I UADSADAT                                  I    *
**/* *               I-------------------------------------------I    *
**/* *                                                                *
**
**
**DECLARE
**  1 DNOB     BASED(DNOBPTR),
**
**   2 UADSAFLG CHAR(1),              /* ACCOUNT NUMBER OFFSET BLOCK  *
**/*                                    ..INDICATORS                  *
**    3 AFLG01   BIT(1),              /* ..0 -- CONTINUE CHAINING     *
**/*                                    ..1 -- LAST ACCOUNT NUMBER FO *
**/*                                    .......THIS PASSWORD CHAIN    *
**/*                                    .. FLAGS 1 THRU 7 ARE RESERVE *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**   2 UADSANEX PTR(24)  BDY(BYTE),
**                                    /* OFFSET TO NEXT ACCOUNT
**                                       NUMBER                       *
**/*                                    ..OFFSET BLOCK                *
**   2 UADSASUB PTR(31),              /* OFFSET TO ASSOCIATED
**                                       PROCNAME                     *
**/*                                    ..OFFSET BLOCK                *
**   2 UADSADAT PTR(31);              /* OFFSET TO ACCOUNT NUMBER
**                                       DATA                         *
**/*                                    ..BLOCK                       *
**
**
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                   P R O C E D U R E   N A M E                  *
**/* *                     O F F S E T   B L O C K                    *
**/* *                                                                *
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                                                                *
**/* *               I----------I--------------------------------I    *
**/* *          0    I UADSRFLG I UADSRNEX                       I    *
**/* *               I----------I--------------------------------I    *
**/* *          4    I UADSRSUB                                  I    *
**/* *               I-------------------------------------------I    *
**/* *          8    I UADSRDAT                                  I    *
**/* *               I-------------------------------------------I    *
**/* *                                                                *
**
**
**DECLARE
**  1 DROB     BASED(DROBPTR),
**
**   2 UADSRFLG CHAR(1),              /* PROCNAME OFFSET BLOCK        *
**/*                                    ..INDICATORS                  *
**    3 FLGR01   BIT(1),              /* ..0 -- CONTINUE CHAINING     *
**/*                                    ..1 -- LAST PROCNAME FOR THIS *
**/*                                    .......ACCOUNT NUMBER         *
**/*                                    ..FLAGS 1 THRU 7 ARE RESERVED *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**    3 *        BIT(1),              /* RESERVED                     *
**   2 UADSRNEX PTR(24)  BDY(BYTE),
**                                    /* OFFSET TO NEXT PROCNAME      *
**/*                                    ..OFFSET BLOCK                *
**   2 UADSRSUB PTR(31),              /* RESERVED BY ACCOUNT          *
**   2 UADSRDAT PTR(31);              /* OFFSET TO PROCNAME DATA
**                                       BLOCK                        *
**
**
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *              P A S S W O R D   D A T A   B L O C K             *
**/* *                                                                *
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                                                                *
**/* *               I----------I--------------------------------I    *
**/* *          0    I UADSPCTR I UADSPRES                       I    *
**/* *               I----------I--------------------------------I    *
**/* *          4    I UADSPPWD                                  I    *
**/* *               I                                           I    *
**/* *          8    I                                           I    *
**/* *               I-------------------------------------------I    *
**/* *                                                                *
**
**
**DECLARE
**  1 DPOBD    BASED(UADSPPTR),
**
**   2 UADSPCTR PTR(8),               /* COUNT OF REFERENCES TO THIS  *
**/*                                    ..DATA BLOCK                  *
**   2 UADSPRES CHAR(3),              /* RESERVED FOR ACCOUNT         *
**   2 UADSPPWD CHAR(8);              /* PASSWORD                     *
**
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                   A C C O U N T   N U M B E R                  *
**/* *                      D A T A     B L O C K                     *
**/* *                                                                *
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                                                                *
**/* *               I----------I--------------------------------I    *
**/* *          0    I UADSACTR I UADSARES                       I    *
**/* *               I----------I--------------------------------I    *
**/* *          4    I UADSADRF (40 BYTES)                       I    *
**/* *               I                                           I    *
**/* *               I                                           I    *
**/* *               I                                           I    *
**/* *               I----------I--------------------------------I    *
**/* *          44   I UADSALEN I UADSANUM (MAX OF 40 BYTES)     I    *
**/* *               I----------I                                I    *
**/* *               I                                           I    *
**/* *               I                                           I    *
**/* *               I                                           I    *
**/* *               =                                           =    *
**/* *               I                                           I    *
**/* *               I-------------------------------------------I    *
**/* *                                                                *
**
**
**DECLARE
**  1 DNOBD    BASED(UADSAPTR),
**
**   2 UADSACTR PTR(8),               /* COUNT OF REFERENCES TO THIS  *
**/*                                    ..DATA BLOCK                  *
**   2 UADSARES CHAR(3),              /* RESERVED FOR ACCOUNT         *
**   2 UADSADRF CHAR(40),             /* DRIVER DATA FIELD            *
**   2 UADSALEN PTR(8),               /* LENGTH OF FOLLOWING ACCOUNT  *
**/*                                    ..NUMBER DATA FIELD           *
**   2 UADSANUM CHAR(40);             /* ACCT NMBR DATA FIELD         *
**
**
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                   P R O C E D U R E   N A M E                  *
**/* *                      D A T A     B L O C K                     *
**/* *                                                                *
**/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *
**/* *                                                                *
**/* *                                                                *
**/* *               I----------I--------------------------------I    *
**/* *          0    I UADSRCTR I UADSRRES                       I    *
**/* *               I----------I--------------------------------I    *
**/* *          4    I UADSRNAM                                  I    *
**/* *               I                                           I    *
**/* *               I                                           I    *
**/* *               I----------I----------I---------------------I    *
**/* *          12   I UADSRNDS I UADSRRS2 I UADSRSIZ            I    *
**/* *               I----------I----------I---------------------I    *
**/* *          16   I UADSUNAM                                  I    *
**/* *               I                                           I    *
**/* *               I                                           I    *
**/* *               I-------------------------------------------I    *
**/* *                                                                *
**
**
**  1 DROBD  BASED(UADSPTR),
**
**   2 UADSRCTR PRT(8),       /* COUNT OF REFERENCES TO THIS
**/*                             DATA BLOCK
**   2 UADSRRES CHAR(3),      /* RESERVED FOR ACCOUNT
**   2 UADSRNAM CHAR(8),      /* LOGON PROCEDURE NAME
**   2 UADSRNDS CHAR(1)       /* RESERVED
**   2 UADSRRS2 CHAR(1)       /* RESERVED
**   2 UADSRSIZ PTR(16) BDY(BYTE),
**                            /* REGION SIZE SPECIFIED IN THE
**/*                             ..NAMED PROCEDURE
**   2 UADSUNAM CHAR(8)       /* ESOTERIC GROUP UNIT NAME
**
**
         EJECT
*                                          *
*  OS LINKAGE + REGISTER EQUATES AND USAGE *
*                                          *
R0       EQU   0    OS MACRO
R1       EQU   1    OS MACRO/LINKAGE
R2       EQU   2    WORK
R3       EQU   3    WORK
R4       EQU   4    WORK
R5       EQU   5    WORK
R6       EQU   6    WORK
R7       EQU   7    ADDR OF INPUT LINE
R8       EQU   8    ADDR OF ENTRY PARM LIST
R9       EQU   9    2ND BASE
R10      EQU   10   BASE
R11      EQU   11   DSECT BASE FOR GETMAIN WORK AREA
R12      EQU   12   INTERNAL BAL ONLY
R13      EQU   13   OS LINKAGE
R14      EQU   14   OS MACRO/LINKAGE
R15      EQU   15   OS MACRO/LINKAGE
         SAVE  (14,12)
         BALR  R10,0
         USING *,R10
         USING *+4096,R9
         LA    R9,4095(,R10)
         LA    R9,1(,R9)
*
* ISSUE UNCONDITIONAL GETMAIN FOR WORK SPACE
*
         LR    R8,R1   * SAVE REG 1 *
         GETMAIN R,LV=WORKLEN
* SET UP A BASE FOR THE GOTTEN CORE AND FINISH LINKAGE
         LR    R11,R1
         USING WORK,R11       REG 11 IS BASE FOR WORKAREA DSECT
         ST    R13,SAV+4
         LA    R14,SAV
         ST    R14,8(R13)
         LR    R13,R14
* INITIALIZE SWITCHES IN GOTTEN CORE
         MVI   FREESW,X'00'
         MVI   PROCSW,X'00'
* OPEN THE BPAM DCB
         MVC   UADSDCB(88),XUADSDCB     MOVE SKELETON DCB TO DSECT
         LA    R1,UADSDCB
         ST    R1,OPENUL      SET UP OPEN LIST
         MVI   OPENUL,X'84'   UPDAT PARM + END OF LIST BIT
         LA    R1,OPENUL
         SVC   19             OPEN
*
* GET ADDR OF INPUT LINE AND FIND 'LOGON' IN THE LINE - HE MAY
* HAVE ENTERED SOME BLANKS BEFORE THE WORD 'LOGON'
*
         L     R2,4(,R8)      ADDR OF SDV FOR INPUT LINE
         L     R7,0(,R2)      ADDR OF INPUT LINE
         LH    R3,6(,R2)      LEN OF INPUT LINE
         ST    R7,ADDRINPT    SAVE ADDR
         STH   R3,LINPUT      SAVE LENGTH
* CONVERT ALL LOWERCASE IN INPUT TO UPPERCASE
         LTR   R3,R3          CHECK IF ZERO
         BZ    INPINV         IT IS ZERO - ERROR
         BCTR  R3,0
         EX    R3,TRANLC
         LA    R4,0(R3,R7)    R4 = ADDR OF LAST BYTE - 1
ILOOP    DS    0H
         CLI   0(R7),C'$'     FIRST CHAR OF USERID?
         BE    IEXIT          GO IF YES
         LA    R7,1(,R7)      POINT TO NEXT BYTE
         CR    R7,R4          END OF THE LINE
         BNL   INPINV         ERROR IF END
         B     ILOOP
TRANLC   TR    0(0,R7),XLOWCASE
IEXIT    DS    0H
*
*  VALIDATE THE INPUT LINE. MUST BE IN FORM UID/PASSWORD.
*
         LA    R3,0(,R7)      R3 = FIRST CHAR OF UID
         LA    R4,8(,R3)      R4 = LAST (MAX) CHAR +1
         SR    R5,R5
         CLI   0(R3),C'/'     IS FIRST CHAR A SLASH
         BE    UIDINV
VLOOP    DS    0H
         LA    R5,1(,R5)      INC LEN CTR
         LA    R3,1(,R3)      NEXT CHAR OF UID
         CLI   0(R3),C'/'     IS IT THE DELIMITER
         BE    VSET           GO IF YES
         CR    R3,R4          IS UID GRTR THAN 8
         BNL   UIDINV         GO IF GRTR
         B     VLOOP
VSET     DS    0H
         STH   R5,LUID        SAVE LEN OF USERID
         LA    R3,1(,R3)
         ST    R3,ADDPASS     SAVE ADDR OF PASSWORD
*
*  FIND THE DPAP IN THE INPUT LINE
*
         LH    R5,LINPUT      R5 = LEN OF INPUT LINE
         LR    R6,R7          R6 = ADDR OF INPUT LINE
         LA    R5,0(R5,R6)    R5 = ADDR OF END OF INPUT LINE
         SH    R5,=H'7'       ADJUST TO MIN POSSIBLE WITH VALID DPAP
DLOOP    DS    0H
         CLC   0(5,R6),=C'ACCT('  ACCT NO KEYWORD
         BE    DTRAN          GO IF YES
         LA    R6,1(,R6)      NEXT CHAR
         CR    R6,R5          STILL POSSIBLE TO HAVE SPECIFIED DPAP
         BL    DLOOP          GO IF YES
         XR    R6,R6          IF NO DPAP, ZERO R6 TO INDICATE
         B     MAINTEST       AND SKIP CHECK OF DPAP
*  IF NO DPAP, CHECK FOR RECONNECT
*        LA    R5,3(R5)       PT TO END OF INPUT LINE - 4
*        LR    R6,R7          PT TO START OF INPUT LINE
* RLOOP  DS    0H
*        CLC   0(5,R6),=C'RECON'
*        BE    MAINTEST       SKIP DPAP CHECK
*        LA    R6,1(R6)
*        CR    R6,R5
*        BL    RLOOP
*        B     DPAPINV
DTRAN    DS    0H
         LA    R6,5(,R6)      SKIP OVER ACCT(
         TM    0(R6),X'F0'    IS FIRST CHAR NUMERIC
         BO    DPAPINV        GO IF NUMERIC - EXPECT 'Y'
         TRT   1(8,R6),XDPAP  IS IT NUMERIC
         BNE   DPAPINV        GO IF NOT
*        CLI   9(R6),C'/'     DELIMITER BETWEEN DPAP AND TERM ID
*        BNE   TIDINV         GO IF NOT
*        CLI   13(R6),C')'    CLOSE PAREN AFTER TID
*        BNE   TIDINV         GO IF NOT
MAINTEST DS    0H
         LR    R3,R10
         LA    R4,6
         SR    R3,R4
         LH    R4,0(,R3)
         SRL   R4,4
         LA    R4,97(,R4)
         STC   R4,MWORK+2
         BCTR  R4,0
         STC   R4,MWORK+1
         LH    R5,2(,R3)
         NR    R4,R5
         LA    R4,64(R4)
         STC   R4,MWORK
         L     R3,ADDPASS
         MVI   MAINTSW,X'00'
         CLC   0(3,R3),MWORK  DOES HE WANT MAINT MODE FIRST
         BNE   READ
         MVI   MAINTSW,X'FF'
         MVC   0(6,R3),3(R3)
         MVC   6(3,R3),=C'   '
READ      DS    0H
*
*  READ THIS TREE
*
         BAL   R12,READUADS   RETURN ONLY FROM SUCCESSFUL READ
*
*  LOCATE THE FIRST PASSWORD BLOCK
*
         SR    R3,R3
         ICM   R3,7,ACIOBUFR  ADDR OF TREE HEADER BLOCK
         CLI   MAINTSW,X'FF'  MAINT MODE?
         BNE   SKPCHK
         TM    16(R3),X'40'   ACCOUNT?
         BO    SKPCHK
         B     PASSINV        NO, FAIL LOGON
SKPCHK   EQU   *
         L     R2,24(,R3)     OFFSET TO FIRST PASSWORD BLOCK
*  ENCODE THE INPUT PASSWORD
         L     R5,ADDPASS
         MVC   UPASS,0(R5)    INPUT PASSWORD TO WORK
         BAL   R12,ENCPASS    ENCODE THE PASSWORD
PASSLOOP DS    0H
         LA    R2,0(R2,R3)    R2 = ADDR OF FIRST PASSWORD BLOCK
         L     R7,4(,R2)      OFFSET TO ACCOUNT OFFSET BLOCK
         L     R4,8(,R2)      OFFSET TO PASSWORD DATA
         LA    R4,0(R4,R3)    R4 = ADDR OF PASSWORD DATA
*                             THE PASSWORD WE GET FROM ENCPASS.
*  TEST THE NEW FLAG IN THE UADS PASSWORD
         CLI   9(R4),X'F0'    IS THE NEW FLAG SET
         BE    TESTNEW        GO IF SET
*  COMPARE THE INPUT PASSWORD TO THIS UADS PASSWORD
         CLC   EPASS,4(R4)    ARE INPUT AND UADS PASSWORDS EQUAL
         BE    TESTDPAP       GO IF YES
*  NO MATCH YET - TEST FOR ANOTHER PASSWORD BLOCK FOR THIS USER
TESTNEXT DS    0H
         TM    0(R2),X'80'    IS THIS THE LAST PASSWORD FOR THIS USER
         BO    PASSINV        ERROR IF YES - NO EQUAL FOUND
         L     R2,0(,R2)      POINT TO NEXT PASSWORD BLOCK
         L     R7,4(,R2)      OFFSET TO ACCOUNT OFFSET BLOCK
         B     PASSLOOP       GO TEST NEXT
*
*  NEW FLAG SET - COMPARE FIRST FIVE DIGITS
*
TESTNEW  DS    0H   BY POINTS TO PASSWORD DATA BLOCK
         CLC   EPASS(5),4(R4) 1ST 5 CHARS OF INPUT = UADS
         BE    NEWPASS
         MVC   EWORK(6),EPASS  SAVE ENCODED PSWD
         BAL   R12,OENCPASS    USE OLD ENCODING ROUTINE
         CLC   EPASS(5),4(R4) 1ST 5 CHARS OF INPUT = UADS
         BE    NEWPASS
         MVC   EPASS(6),EWORK  RESTORE - NOT OLD PSWD
         B     TESTNEXT
*
*  PROMPT USER FOR CURRENT AUTHORIZATION NUMBER
*
NEWPASS  EQU   *
         TPUT  MSG5,32   SEWD 'ENTER AUTHORIZATION NUMBER'
         LA    R0,136   SET PARMS
         LA    R1,GETBUF   SET PARMS
         ICM   R1,8,=X'80'  SET OPTIONS BYTE
         SVC   93   TGET
         MVC   UPASS,GETBUF   INPUT AUTHNO TO WORK
         TR    UPASS,XLOWCASE TRANSLATE TO UPPERCASE
         BAL   R12,ENCPASS    ENCODE IT
         BAL   R12,READAUTH   GET $AUTHOR'S PASSWORD
*  DID HE CORRECTLY ENTER THE CURRENT AUTH NO ($AUTHOR'S PASSWORD)
         CLC   EPASS,UPASS    IS ENCODED AUTHNO EQUAL TO IT
         BNE   AUTHINV        ERROR IF NOT
*  GEN THE NEW PASSWORD
         BAL   R12,GENPASS
*  SHOW USER THE NEW PASSWORD
         MVC   MSG6(21),=C'YOUR NEW PASSWORD IS '
         MVC   MSG6+21(6),UPASS
         LA    R1,MSG6   SET PARMS
         LA    R0,27     SET PARMS
         SVC   93    TPUT
*  ENCODE THE PASSWORD AND PUT IT BACK OUT IN UADS
         BAL   R12,ENCPASS
         MVC   4(6,R4),EPASS  MOVE PASS INTO PASSWD DATA BLOCK
*  PUT THE NEW PASSWORD IN THE INPUT LINE
         L     R2,ADDPASS     ADDR OF PASSWORD IN INPUT LINE
         MVC   0(6,R2),EPASS  MOVE TO INPUT LINE
*
*  LOCATE THE ACCOUNT DATA BLOCK AND MOVE IN THE INPUT DPAP
*
TESTDPAP DS    0H
         LA    R2,0(R7,R3)    R2 = ADDR OF ACCOUNT OFFSET BLOCK
         L     R2,8(,R2)      OFFSET TO ACCOUNT DATA BLOCK
         LA    R2,0(R2,R3)    ADDR OF ACCOUNT DATA BLOCK
         LTR   R6,R6          DPAP SPECIFIED?
         BZ    SKIPDPAP       NO, DON'T MOVE
         MVC   45(9,R2),0(R6) MOVE IN INPUT DPAP
*  BLANK ACCT FIELD IN INPUT LINE
         L     R5,ADDRINPT    GET ADDR OF INPUT LINE
         AH    R5,LINPUT      GET ADDR OF END OF INPUT LINE
         SH    R6,=H'5'       GET ADDR OF 'ACCT('
         MVC   0(14,R6),=C'              '  CLEAR 'ACCT(YXXXXXXXX'
         LA    R6,13(,R6)     POINT PAST CLEARED AREA
BLNKLOOP LA    R6,1(,R6)      INCREMENT
         CR    R6,R5          END OF LINE?
         BNL   SKIPDPAP       YES,DONE
         CLI   0(R6),C')'     END OF ACCT PARM?
         BNE   BLNK
         XR    R5,R5          YES, ZERO R5 TO INDICATE
BLNK     MVI   0(R6),C' '     BLANK CHARACTER
         LTR   R5,R5          DONE?
         BNZ   BLNKLOOP       NO, CONTINUE
SKIPDPAP EQU   *
         MVI   44(R2),X'12'   LENGTH = 18
*
*  GET TERMINAL ID AND INSERT AFTER DPAP IN UADS
*
         MVI   54(R2),C'/'    PUT SLASH AFTER DPAP
*                             SET UP PARM LIST FOR SVC 233
         LA    R6,55(,R2)     GET ADDRESS OF OUTPUT AREA
         ST    R6,S233PARM+4
         LA    R6,0           ZERO ASCB ADDRESS TO USE THIS ONE
         ST    R6,S233PARM
         LA    R1,S233PARM
         SVC   233            GET TERMINAL ID AND PUT IN UADS
SAVEDPAP MVC   DPAPSAV(18),45(R2) SAVE DPAP & TERMINAL ID
*
*  IF USER HAS MULTIPLE PROCS AND DOES NOT SPECIFY ONE, USE FIRST
*
         L     R6,ADDPASS     GET ADDR OF PASSWORD
         LA    R6,7(,R6)      GO PAST PASSWORD
         LH    R5,LINPUT      GET LENGTH OF INPUT LINE
         SH    R5,LUID
         SH    R5,=H'12'
         LA    R5,0(R5,R6)    R5 = ADDR OF END OF INPUT LINE - 5
*  CHECK - DID USER SPECIFY PROC?
         LA    R2,0(R7,R3)    ADDR OF ACCT OFFSET BLOCK
         L     R2,4(,R2)      OFFSET OF PROC OFFSET BLOCK
         LA    R2,0(R2,R3)    ADDR OF PROC OFFSET BLOCK
         TM    0(R2),X'80'    1ST BYTE ON ==> ONLY ONE PROC
         BO    PROCLOPA
PROCLOOP EQU   *
         CR    R6,R5          END OF LINE?
         BH    PROCCHK        YES,STOP LOOKING
         CLC   0(3,R6),=C'PR('    SPECIFIED 'PR'
         BE    PROCLOP1
         CLC   0(4,R6),=C'PROC'    SPECIFIED 'PROC' OR 'PROCEDURE'
         BE    PROCLOP1
         CLC   0(2,R6),=C'S('     SPECIFIED 'S('    FOR SIZE
         BE    PROCLOP2
         CLC   0(3,R6),=C'SI('    SPECIFIED 'SI('   FOR SIZE
         BE    PROCLOP2
         CLC   0(4,R6),=C'SIZ('   SPECIFIED 'SIZ('  FOR SIZE
         BE    PROCLOP2
         CLC   0(5,R6),=C'SIZE('  SPECIFIED 'SIZE(' FOR SIZE
         BE    PROCLOP2
         LA    R6,1(R6)
         B     PROCLOOP
PROCLOPA DS    0H
         MVI   PROCSW,X'01'       TURN ON SWITCH TO SAY PROC SPECIFIED
         B     PROCLOOP           GO BACK AND LOOK FOR SIZE OPERAND
PROCLOP1 DS    0H
         MVI   PROCSW,X'01'       TURN ON SWITCH TO SAY PROC SPECIFIED
         LA    R6,1(R6)           BUMP POINTER BY ONE
         B     PROCLOOP           GO BACK AND LOOK FOR SIZE OPERAND
*  IF USER SPECIFIED A SIZE OPTION WANT TO MAKE SURE MAXIMUM IS NOT
*  GREATER THAN 999. IF IT IS, GIVE HIM 960K.
PROCLOP2 DS    0H
         CLI   1(R6),C'('         IS NEXT BYTE A LEFT PAREN?
         BE    PROCLOP3           ..YES, GO CHECK SIZE VALUE
         LA    R6,1(R6)           BUMP POINTER UP ONE BYTE
         B     PROCLOP2           KEEP LOOPING TILL FIND LEFT PAREN
PROCLOP3 DS    0H
         LA    R6,2(R6)           SET R6 PTR TO SIZE DATA
         SR    R7,R7              CLEAR R7 TO USE AS COUNTER
         LR    R1,R6              R1 SAVES BEGINNING OF SIZE VALUE
PROCLOP4 DS    0H
         CR    R6,R5              END OF DATA LINE?
         BH    SIZEDONE           ..YES, MEANS AM DONE LOOKING
         CLI   0(R6),C'0'         IS BYTE NUMERIC
         BL    SIZEDONE           ..NO, MEANS AM DONE LOOKING
         LA    R6,1(R6)           BUMP PTR TO DATA BY 1
         LA    R7,1(R7)           BUMP CTR OF NUMBER OF DIGITS
         B     PROCLOP4           CONTINUE LOOPING
SIZEDONE DS    0H
         LR    R6,R1              RESTORE POINTER TO DATA
         CH    R7,=H'03'          IS SIZE GREATER 999?
         BNH   PROCCHKA           ..NO, SIZE PARAMETER IS OK
         SH    R7,=H'04'          SET # OF ZEROES TO MOVE IN
         EX    R7,SIZEMOVE        MOVE IN LEADING ZEROES
         AR    R6,R7              ADD IN # ZEROES MOVED
         LA    R6,1(R6)           BUMP PTR BY 1 BECAUSE OF EXEC
         MVC   0(3,R6),=C'960'    MOVE IN MAX SIZE OF 960K
         B     PROCCHKA           CONTINUE ON
SIZEMOVE MVC   0(0,R6),=C'000000' MOVE IN LEADING ZEROES
PROCCHKA DS    0H
         CLI   PROCSW,X'01'       HAVE WE ALREDY FOUND A PROC
         BE    PROCSKIP           ..YES, SKIP THIS NEXT MESS
         B     PROCLOOP           ..NO, GO BACK AND KEEP LOOKING
PROCCHK  DS    0H
         CLI   PROCSW,X'01'       DID USER SPECIFY A LOGON PROC
         BE    PROCSKIP           ..YES, SKIP THIS NEXT MESS
PRCLPEND EQU   *
*  IF USER DID NOT SPECIFY PROC, GET 1ST PROCNAME AND SET
*  DON'T-PROMPT BIT TO FORCE LOGON PROCESSOR TO USE IT
*  MUST MOVE IN UID, PSWD, ACCT INFO, SIZE, AND PERF GP TOO
         L     R2,8(,R2)      OFFSET TO PROC DATA BLOCK
         LA    R2,0(R2,R3)    ADDR OF PROC BLOCK
*
         L     R7,ADDRINPT    LOAD LOGON INPUT ADDRESS
         AH    R7,LINPUT      ADD LENGTH OF INPUT
         MVC   0(13,R7),=C' PR(        )' MOVE IN PROC OPTION
         MVC   4(8,R7),4(R2)  MOVE IN PROCNAME
         LH    R7,LINPUT      LOAD LENGTH OF INPUT
         AH    R7,=H'13'      ADD LENGHT OF NEW INPUT
         STH   R7,LINPUT      STORE AWAY LENGHT OF INPUT
         L     R6,4(,R8)      ADDR OD SDV FOR INPUT LINE
         MVC   6(2,R6),LINPUT STORE NEW LENGHT OF INPUT
PROCSKIP EQU   *
*
*  REWRITE UADS FOR FREEMAIN AND PUT ENCODED PASSWORD INTO INPUT LINE
*
LOADPASS DS    0H
         BAL   R12,WRITUADS   REWRITE THE TREE
         L     R5,ADDPASS
         MVC   0(6,R5),EPASS  MOVE PASS INTO INPUT LINE
         B     CLOSDCB
*
*  INVALID PASSWORD
*
PASSINV  DS    0H
         TPUT  MSG3,24   SEND 'INVALID PASSWORD'
         B     INPINV
*
*  INVALID DPAP
*
DPAPINV  DS    0H
         TPUT  MSG7,28   SEND 'INVALID OR NO DPAP SPECIFIED'
         B     INPINV
*
*  INVALID AUTHORIZATION NUMBER
*
AUTHINV  DS    0H
         TPUT  MSG4,32   SEND 'INVALID AUTHORIZATION NUMBER'
         B     INPINV
*
*  INVALID USERID
*
UIDINV   DS    0H
         TPUT  MSG2,24   SEND 'INVALID USERID'
         B     INPINV
*
*  INVALID TERMINAL ID
*
TIDINV   DS    0H
         TPUT  MSG8,32
         B     INPINV
*                                   *
*  INPUT FORMAT INVALID - SEND MSG  *
*                                   *
INPINV   DS    0H
         TPUT  MSG1,43
*
*  SET 'CANCEL' BIT TO FORCE LOGOFF  *
*                                   *
FORCEOFF DS    0H
         L     R2,0(,R8)      ADDR OF SDV FOR CONTROL SWITCHES
         L     R3,0(,R2)      ADDR OF CONTROL SWITCHES
         OI    0(R3),X'10'    SET CANCEL BIT
         MVI   MAINTSW,X'00'  TURN OFF MAINT SW
* CLOSE THE BPAM DCB
CLOSDCB  DS    0H
         CLI   MAINTSW,X'FF'  MAINTENANCE MODE FIRST?
         BE    MAINT
CLOSDCB2 DS    0H
         LA    R1,UADSDCB
         ST    R1,OPENUL      SET UP LIST FOR CLOSE
         MVI   OPENUL,X'80'   SET PARM = CLOSE + END OF LIST BIT
         LA    R1,OPENUL
         SVC   20             CLOSE
         TM    FREESW,X'FF'   DO WE NEED TO FREE IKJEFA51'S BUFFERS
         BNO   SKIPFREE       GO IF NOT
         BAL   R12,FREEWRIT   CALL IKJEFA52 FOR FREE ONLY
SKIPFREE DS    0H
FREE     DS    0H
*                              *
*  FREE GOTTEN CORE AND RETURN *
*                              *
         LA    R0,WORKLEN
         L     R13,SAV+4
         FREEMAIN R,LV=(0),A=(11)
         RETURN (14,12)
         EJECT
*                                          *
*        READ A TREE USING IKJEFA51        *
*                                          *
READUADS DS    0H
* BUILD THE READ PARM LIST
         LA    R2,UADSDCB
         ST    R2,ACIOFLGS              LOAD DCB ADDR
         MVC   ACIOFLGS(1),REDFLGS      SET FLAGS FOR TREE READ
         LA    R2,DIRNAME
         ST    R2,ACIOMPTR              LOAD ADDR OF UID
         MVI   DIRNAME,C' '
         MVC   DIRNAME+1(7),DIRNAME
         LH    R2,LUID        LEN OF UID IN INPUT LINE
         BCTR  R2,0
         EX    R2,RDMVC
*  SET X'F0' AFTER LAST CHAR OF UID IN WORK AREA  *
         LA    R2,DIRNAME     1ST CHAR
         LA    R3,DIRNAME+7   LAST CHAR
RULOOP   DS    0H
         CLI   0(R2),C' '     IS THIS CHAR BLANK
         BE    RUSET          GO IF YES
         CR    R2,R3          ALL 8 NON-BLANK
         BNL   UIDINV        8 CHAR UID - NFG EXIT WITH ERROR
         LA    R2,1(,R2)      NEXT CHAR
         B     RULOOP
RUSET    DS    0H
         MVI   0(R2),X'F0'    SET 'F0' AFTER UID
*  FINISH PARM LIST
         LA    R2,UADSDCB
         ST    R2,ACIODRCT              LOAD ADDR OF DIR READ WORK AREA
         LA    R2,0
         ST    R2,ACIOLINK              ZERO NOT USED
         ST    R2,ACIOMSGN              ZERO NOT USED
         ST    R2,ACIONMBR
         LA    R1,ACIOPARM              ADDR OF READ PARM LIST
         L     R15,=V(IKJEFA51)
* CALL IKJEFA51
         BALR  R14,R15
* TEST RETURN CODE
         LTR   R15,R15
         BZ    READEXIT                 EXIT IF SUCCESSFUL
         CH    R15,=H'4'                WAS IT MEMBER NOT FOUND
         BE    UIDINV
         MVI   GETBUF+8,C'1'   SET MSG ID FOR THIS ERROR
         B     ERROPT
READEXIT DS    0H
         MVI   FREESW,X'FF'   SET MUST-FREE-BUFFERS SWITCH
         BR    R12
RDMVC    MVC   DIRNAME(0),0(R7)  MOVE UID FROM INPUT LINE
         EJECT
*                                *
*  REWRITE A TREE USING IKJEFA52 *
*                                *
WRITUADS DS    0H
*  ASSUME THE BPAM DCB TO HAVE BEEN OPENED BY READUADS
*
*  MODIFY THE READ PARM LIST TO WRITE
         MVC   ACIOFLGS(1),WRTFLGS
*  SET R1 TO PARMLIST AND CALL
FREEWRIT DS    0H
         LA    R1,ACIOPARM
         L     R15,=V(IKJEFA52)
         BALR  R14,R15
*  TEST RETURN CODE AND DELETE
         LTR   R15,R15
         BNZ   WRABE
         MVI   FREESW,X'00'   RESET MUST-FREE-BUFFERS SWITCH
         BR    R12
WRABE    DS    0H
         MVI   GETBUF+8,C'2'    SET MSG ID FOR THIS ERROR
         B     ERROPT
         EJECT
*                                                      *
*        GENERATE A SIX DIGIT NUMERIC PASSWORD         *
*                                                      *
//LKED.SYSLMOD DD  DSN=SYS1.LINKLIB(IKJEFLD),DISP=SHR
