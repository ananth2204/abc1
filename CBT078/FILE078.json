{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011201000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 881790, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE078.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE078.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0f\\n'", "DS1TRBAL": "b'P|'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\x81\\x00\\x0c\\x00\\x82\\x00\\x0c\\x00\\x10'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x93)/\\x01\\x00)\\x9f\\x113\\x00E\\x00\\n\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1993-10-19T00:00:00", "modifydate": "2000-10-25T11:33:00", "lines": 69, "newlines": 10, "modlines": 0, "user": "WSBG"}, "text": " Short doc.\n     I have repackaged the EDITMAC.ZIP file from the SHARE 81\n diskettes' ISPF subdirectory.  Also included is the EDITALL.ZIP\n file.  I have to make a few remarks concerning their upload to\n the mainframe.\n\n     Under DOS files, the three-character suffix was the indicator\n of the type of member we had:  e.g. PAN for panels, REX for REXX,\n CLI for clists, etc.  Upon upload to a partitioned dataset under\n MVS, I organized these into IEBUPDTE (or PDSLOAD - see files 035\n and 093) format unloaded pds'es.  In other words, in this file\n there is a member called REXX.  This should be loaded into a pds\n full of REXX execs.  The member called CLISTS should be loaded into\n a CLIST library.  PANELS should be loaded into a panel library.\n MESSAGES should be loaded into a message library.  SKELETNS should\n be loaded into a skeleton library.  If you use the PDSLOAD program\n instead of IEBUPDTE, you'll get ISPF statistics for all the members.\n\n     For your convenience, I have provided sample jobs, #EBUPDTE and\n#PDSLOAD to load a pds from the IEBUPDTE-format sequential members.\nPDSLOAD is the preferred method.  You can find its load module on\nfile 035 of this tape, and its source on file 093.  PDSLOAD changes\nthe >< strings to ./ before reloading, and it re-stows ISPF statistics.\n\n     Because of my emulation software, I had to globally change x'53'\n to x'5F' wherever it occured, and wherever it made sense.  I hope I\n was right.\n\n     The member called MVS is a BASIC program that is meant to be run\n on a PC, so it will have to be downloaded again.  Some of the lines\n are longer than the lrecl of 80 on this pds, and they have been folded\n after column 80.  Of course, do not renumber this member.  You will be\n able to recognize, probably, which lines have been folded and how that\n was done.  You'll have to set it back again.\n\n     The EDITALL macro comes from Lionel Dyck.  All the other material\n comes from John Kalinich.\n\n         John Kalinich\n         USA Logistics Systems\n          Support Center\n         AMSEL-SE-BSD-LS-TD, Room 7.103\n         1222 Spruce Street\n         St. Louis, MO.  63103-2834\n\n         INTERNET:  kalinichj@primary.net\n                    jkalinic@csc.com\n         PHONE:  (314) 331-4521\n         FAX:    (314) 331-4520\n\n         Lionel B. Dyck\n         Kaiser Permanente\n         25 N. Via Monte\n         Walnut Creek, CA  94598\n\n         INTERNET:  lionel.dyck@ncal.kaiperm.org\n         PHONE:  (925) 926-5332\n\n     Any questions about the CBT Tape version of this stuff, if\n those guys can't help you, please call:\n\n         Sam Golob\n         P.O. Box 906\n         Tallman, NY  10982-0906\n\n\n         INTERNET:  sbgolob@attglobal.net OR\n                    sbgolob@aol.com\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CHANGLG": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01$\\x00\\x00\\x00\\x93)\\x1f\\x00\\x98\\x19\\x7f\\x08'\\x01-\\x00\\x80\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@\"", "ispf": {"version": "01.36", "flags": 0, "createdate": "1993-10-18T00:00:00", "modifydate": "1998-07-16T08:27:00", "lines": 301, "newlines": 128, "modlines": 0, "user": "DOC"}, "text": "\n\nDATE      DESCRIPTION OF CHANGE\n\n**-**-**  Miscellaneous fixes.  Check the file dates to see what has\n          changed or run a compare against your last version of the SHARE\n          Software Exchange diskettes (CD-ROM).\n\n07-16-98  Update to DVOL clist dialog to display 4digit UCB addresses and\n          large track capacity device (3390 mod 9) information from the\n          new version of the DVOL command (CBT MVS tape, File 296).\n\n05-08-97  PDSFTP - REXX dialog to automate PDS member file transfers.\n          If a local PDS is entered on the pop-up, a member list will be\n          displayed for you to select the members to be batch transferred.\n          This was developed for source file transfers from MVS to a PC.\n          If a local DSN is not entered, then FTP will be invoked in it's\n          normal interactive mode.  All pop-up fields are VPUT to the profile\n          which makes for a no-brainer on return trips to the pop-up.\n\n05-08-97  IDCAMS edit macro - Execute IDCAMS commands in edit.  This is like\n          the 'exec' function in 3.2.V(sam).  If you want to save your\n          generated commands from 3.2.V, you can use this edit macro to\n          execute them later.\n\n02-25-97  CLONEID - REXX exec to \"decompile\" a logonid record into INSERT\n          format for cloning purposes.  Useful when you want to clone new\n          STC lids and wish to copy field values (e.g., NAME and PHONE) which\n          are not copied via INSERT USING(...).  Use in conjunction with\n          RUNACF edit macro when editing the clone VIO dataset.\n\n02-07-97  LIBDIR - REXX exec to display a CA-Librarian index list.  Output is\n          in same format as PDSDIR.\n\n01-16-97  PROFSET edit macro - Mass change all edit profiles for an ISPF\n          application.  For example, you like to live dangerously and want\n          RECOVERY OFF NOWARN set permanently for all qualifiers in application\n          edit profiles (in addition to ISR, like IOF/ISF which get used when\n          you nest EDIT and VIEW).  Just create a short edit macro with the\n          commands to set profile values, and enter \"PROFSET shortmac\" when\n          editing in the application.  ZDEFAULT profile is not affected.\n\n09-20-96  ACFCOMP edit macro - Compile the rule that is in edit and issue a\n          \"F ACF2,RELOAD(rule)\" operator command if editing a resident access\n          rule or \"F ACF2,REBUILD(directory)\" operator command if editing a\n          resource rule and the directory is resident.\n\n          TESTACF edit macro - Test ACF2 rules based on DSN= values in JCL.\n          Using IOF, submit a job with TYPRUN=SCAN and then select your JCL\n          sysout.  Enter EDIT when browsing the JCL then invoke TESTACF\n          to test a chunk of JCL (pronounced JAY-CIL).  The symbolics have\n          already been resolved and TESTACF ignores &variables in the DSN=\n          parameter.  If you have SDSF, submit a job with TYPRUN=SCAN and\n          invoke ISPF Edit with the \"SE\" action character on the JCL before\n          invoking TESTACF.\n\n04-08-96  ACFTRAP edit macro - Queue ACF subcommands and trap the output\n          of the ACF command processor in =NOTE= or data lines.\n\n          RUNACF edit macro - Issue ACF subcommands currently being edited.\n          This macro works good when LIKE(...) masking can not provide the\n          proper grouping for mass changes or you want to keep a set of\n          \"canned\" ACF subcommands around for those changes that you would\n          normally have to go to the book for to remember.  Also provides\n          an audit trail if you return the output as data lines.  If the ACF\n          command has to prompt the terminal (e.g., ACF67046 MULTIPLE\n          RECORDS MAY BE DELETED - ENTER Y TO DELETE OR N TO CANCEL) for\n          more information, RUNACF will go into a loop and you will have\n          to attention (PA1) interrupt in order to halt execution.\n\n03-21-96  ASA2PC edit macro - Convert ASA printer control characters to\n          ASCII control characters.  This is handy to run just before\n          downloading a print file (via FTP \"ascii\" mode) for inclusion into\n          a word processing document.  Page breaks and line spacing are\n          maintained.\n\n02-01-96  Update to EOL edit macro.  This version backtabs 10 characters at\n          at time looking for non blanks, then goes into the backspace 1 mode\n          in order to find the true End-Of-Line.  Loop time is reduced.\n\n11-21-95  GETxxxx - More REXX sub-functions to 1) get ACF2 release id,\n          2) get ACF2 userid string, 3) get connect group name, and\n          4) get user name.\n\n07-14-95  LOGLIST - Clist dialog to specify print delivery instructions\n          for the ISPF list and log SYSOUT datasets.  This is a two step\n          process.  First, a temporary exec named @LOGLIST is created in the\n          ISPFILE dataset.  The exec defines a dynamic output descriptor named\n          LOGLIST which is used on the OUTDES parameter of ALLOCATE for ISPLIST\n          and ISPLOG.  Second, code must be inserted into a TSO start-up clist\n          to test for the presence of @LOGLIST and execute the exec.\n\n06-07-95  Update to SYSLOG clist dialog.  This version allows you to display\n          the archived IOF SLAM memos by day of week (MON-SUN), or \"ALL\" for\n          all SLAM memos on the JES2 spool.  The ISPF SYSLOG command can be\n          invoked with a day of week parameter, such as \"SYSLOG SUN\" to bypass\n          the normal panel prompt.\n\n05-12-95  Update to ISPF panel TRIJOBS to pass the IOF jump.  For example,\n          the ISPF JOBS command \"JOBS C.2.1\" can be used to jump into the JES2\n          JOB LOG of the 2nd CICS job.\n\n12-13-94  Update to BROWSE4 edit macro in support of ISPF 4.1 View.\n          BROWSE4 (formerly known as BROWSE) had to be renamed because\n          BROWSE is now a valid command when in Edit.  Also, the ZVIEW\n          variable is examined to determine which browser to invoke\n          (i.e., Browse or View).  You may want to create 2 separate macros\n          (e.g., VIEW4 and BROWSE4) instead of using ZVIEW to pick the\n          browser.\n\n          Update to SYSLOG and EB dialogs in support of ISPF 4.1 View.\n          Browse is faster to invoke than View, but edit macros (such as\n          FX) and the HILITE command (with Highlight FIND strings on) can\n          be used in view mode.\n\n10-31-94  PDSDIR - REXX exec to deblock a PDS directory without using TSO\n          or ISPF commands.  Useful if you need to grab the PDS member name\n          and do something with it.\n\n10-26-94  Update to SYSLOG clist dialog.  This version allows you to display\n          the \"active\" SYSLOG with either SDSF or IOF.  IOF is handy if you\n          need to use the FIND ALL command.\n\n10-05-94  Update to FX edit macro.  Now other FIND parameters such as WORD,\n          SUFFIX, PREFIX, and a label-range can be entered.  Examples:\n\n                FX 'FIX' 1 40 SUFFIX .A .B\n                FX 'SUF' 1 40 PREFIX .A .B\n                FX 'THE' WORD\n                FX 'THE' .ZFIRST .ZLAST\n\n07-05-94  Update to EOL edit macro.  By pressing the EOL PF key repeatedly,\n          you can jump to end of line (EOL) on successive lines.  The jumping\n          action now works across eXcluded line blocks thanks to a modification\n          by David McRitchie from Hoeschst Celanese Corp.\n\n05-18-94  WEAVE edit macro - Interlace data from CUT table into a range of\n          lines.  This is useful when you are building control cards\n          (e.g., IDCAMS) from a list of saved information (e.g., TSOTRAP or\n          PDS Output Log) and you need continuation cards or other commands\n          after every line.\n\n03-16-94  Update to RUN macro.  Now you can mark a section of commands with\n          the Cn/CC line commands if you just want to EXECute a portion of\n          a clist or REXX exec.  An attempt is made to recognize which type\n          of command procedure you are editing in order to pass the right\n          operand (CLIST/EXEC) on the TSO EXEC command.\n\n01-21-94  RESETID - REXX exec to reduce the ACF2 password violation count\n          by one.  A check is made for TSO OPERator authority before passing\n          the MODIFY command to SDSF.  Handy for SYSPROGs (with TSO and SDSF\n          operator command authority) to help out their fellow users when the\n          ADP security officer is out-of-pocket.\n\n01-12-94  Update to JC and JCI edit macros.  A JCLLIB is now generated\n          instead of a PROCLIB statement.  Also, a default OUTPUT JCL\n          statement is generated from information in the \"scroll-able\"\n          portion of the panel.\n\n12-28-93  Addition of DOS batch files, UPLOAD and IEBUPDTE.  Used to combine\n          the ISPF PANELS, SKELETONS, MESSAGES, CLISTS, and REXX EXECS, into\n          IEBUPDTE sysin files with ./ ADD NAME= header cards in front of\n          each member.  Kind of like the mainframe program OFFLOAD does with\n          a PDS.  The only glitch here is that the DOS file extension is part\n          of the name.  No problem, blow it away with the ISPF editor before\n          the JCL (pronounced JAY-CIL) wrap and submit.  Takes the pain out of\n          uploading 70+ files and then trying to copy them into PDS's.\n\n11-23-93  Update to PLUG edit macro.  PLUG now supports label pairs or the\n          On/OO line commands to define a range of lines.  Labels are useful\n          when making multiple plugs to a block of code.  All system and user\n          labels can be used.\n\n08-05-93  Update to EOL edit macro.  By pressing the EOL PF key repeatedly,\n          you can jump to end of line (EOL) on successive lines.  The\n          macro checks to see if the cursor is already at EOL (most likely\n          from the previous EOL PF key action).  If it is, then it jumps to\n          EOL on next line.  The jumping action does not work across\n          eXcluded line blocks greater than 1 line.\n\n07-16-93  EOL edit macro - Set cursor at end of current screen line.\n          This works like most PC editors do when you press the \"End\"\n          scroll key.  Handy when \"adding-on\" to JCL or text.  At the\n          last SHARE, someone asked if there was a way to do this and\n          the answer was no.  Assign EOL to a PF key to make this work.\n          I personally use the easy-to-find but seldomly-used PF1 for\n          this assignment.\n\n06-23-93  Update to EB clist dialog.  This version invokes Librarian ELIPS\n          EDIT and BROWSE instead of the older LIBEDIT and LIBROWSE.  If\n          member name is a wildcard pattern or null, then an ELIPS LIST\n          command is generated.\n\n06-14-93  Update to BROWSE edit macro.  If the member to be browsed does\n          not exist, then it is assumed to be a 2nd level DSN qualifier.\n\n05-21-93  FX and PLUG edit macros - REXX versions for SPF/PC Version 3.0.\n\n05-11-93  Removal of COLS edit macro.  I found out that :COLS in a PF key\n          definition is all you have to specify.  The cursor stays put and\n          you get the columns line above the cursor.\n\n03-24-93  GETxxxxx - REXX sub-functions to extract various items out of MVS\n          control blocks for subsequent display on an action bar panel (see\n          INFO.ABC for examples).  This code was derived from Joe Millar and\n          Paul Waterhouse's Rexx examples on the NaSCOM bulletin board and\n          the SHOW.ZIP file on the SHARE Software Exchange from Rockwell\n          International.  SHOW extracts more information from control blocks\n          and is written in assembler.\n\n02-24-93  Converted the SORTWORK dialog from clist to REXX.  Solved some\n          arithmetic overflow problems and used SyncSort Release 3.2\n          intermediate disk space formula.\n\n 1-08-93  EB - Clist dialog to invoke either ISPF EDIT/BROWSE, Librarian\n          Edit/Browse, or the PDS command (PDS, CBT File 182) on a\n          menu of 19 datasets.  Invoked with the ISPF EBrowse command.\n\n12-29-92  DVOL - Clist dialog that front-ends the DVOL command (located on\n          CBT mods tape, File 296) to display DASD free space stats in an\n          ISPF table.  Invoked with the ISPF SPACE command.  When using the\n          SHORT display option, you can SORT table by volser or total free\n          tracks.  Primary sort key is always device type.\n\n12-18-92  COMPUTE - REXX dialog to calculate Rexx arithmetic expressions.\n          Invoked with ISPF CALC command.  Uses a pop-up window to prompt\n          if no expression is given with command.  A TSO Times (tm) $250\n          contest winner.\n\n12-18-29  MVS basica program - Pseudo-display of the ISPF Primary Option Menu.\n          Use PF3 to exit.  Easy to customize to your own primary menu design\n          with the help of any BASIC manual.  Useful when fielding those long-\n          winded telephone calls or when you are taking a trip down the hall\n          and don't want to (or can't) keep pressing the Enter key to stay\n          logged on.  Writes a CR to the COM1 (9600 baud) port every 15 seconds\n          or so.  Invoke from your communications program break or shell option.\n          If security is a problem with this, then don't use it or restrict it\n          to the all-knowing and all-powerful SYSPROG populus.\n\n12-14-92  UNX edit macro - Show the first n line(s) from each X-cluded block.\n          Comes in handy as a companion macro to 'FX' and 'FXC' to see\n          continuation lines.\n\n11-30-92  Update to COLS edit macro to restore the cursor position to\n          where is was before the PF key (cols;:cols;cols setcsrp) was\n          pressed.\n\n11-23-92  Add ISPF panel TRIJOBS to display \"key\" jobs with either IOF\n          or SDSF.  Invoked with ISPF JOBS command.  Easily modified\n          to your local naming conventions.\n\n11-05-92  BROWSE edit macro - Another version of browse while in edit.\n          This one can be invoked 3 different ways and supports member\n          name patterns.\n\n11-03-92  Add ISPF tutorial panel TRIMACS which can be invoked by the\n          ISPF command MACROS for edit macro help.\n\n10-06-92  Update to DSK33XX clist to calculate total volumes based on\n          double density 3380 and 3390 models.\n\n 9-09-92  PLUG edit macro - Plug data into edit buffer at a given column.\n          This is handy when you have a need to plug a prefix (e.g., a\n          command) or suffix (e.g., a terminator) on a number of data lines.\n          Before PLUG this usually involved inserting a temporary data\n          line and then using the M(ove) and O(verlay) line commands.\n          PLUG works similar to the Rexx OVERLAY function in that it\n          replaces characters regardless of the their value.\n\n 9-09-92  Removal of CONT edit macro.  Use \"PLUG X 72\" instead.\n\n 6-26-92  TRAPCMD - REXX dialog to trap TSO/REXX command line output and\n          display in an ISPF table.  Especially useful to invoke REXX code\n          that produces mucho output with the non-scrollable SAY verb.\n          Output display is limited to 80 bytes.\n\n 5-19-92  Add OTHER PARAMETERS fields to Job Card Macro panel in order\n          to allow users to enter whatever additional JOB card parameters\n          they need which are not defined in the panel.  Code as you\n          would on the JOB statement (trailing commas will be plugged in\n          if missing).\n\n 4-30-92  FXC edit macro - FIND ALL after EXCLUDE ALL on the word at the\n          cursor position.  Put in a PF key for one-key operation.\n\n 4-29-92  Update to FX edit macro to accept picture, hex, character, and\n          text strings as arguments.  Also, &variables as arguments need\n          only 1 ampersand coded instead of 2.\n\n 3-23-92  COLS edit macro - Display columns line above cursor position.\n          Have to put in PF key (cols;:cols) to make work.\n\n 2-12-92  Add PERCENT USED PER TRACK field to disk space calculation\n          panel.  Updated panel edits on block size and key length.\n\n11-01-91  MEMLIST edit macro - Display member list in =MSG> and =NOTE=\n          lines.\n\n 9-23-91  Update to SUPERC clist to strip off (*) from OTHER DSNAME field\n          value if entered on panel.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$README": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01/\\x00\\x00\\x00\\x93)\\x1f\\x00\\x99\\x07\\x0f\\x07U\\x00\\x98\\x00m\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@'", "ispf": {"version": "01.47", "flags": 0, "createdate": "1993-10-18T00:00:00", "modifydate": "1999-03-11T07:55:00", "lines": 152, "newlines": 109, "modlines": 0, "user": "DOC"}, "text": " ISPF Edit Macros & Dialogs\n July 16, 1998\n\n John Kalinich\n USA Logistics Systems\n  Support Center\n AMSEL-SE-BSD-LS-TD, Room 7.103\n 1222 Spruce Street\n St. Louis, MO.  63103-2834\n\n 314-331-4521\n 314-331-4520 (FAX)\n\n SHARE Installation Code:  ALM\n Internet mailbox:  kalinichj@lssc.army.mil  OR\n                    kalinichj@st-louis-exch01.army.mil\n\n .----------------------------------------------------------------.\n | Feel free to call if you have any problems with this code.     |\n | If you can't reach me by phone, then send me an e-mail or fax. |\n '----------------------------------------------------------------'\n\n\nFile     Ext    Description\n\n$CHANGE  LOG    Changes to macros/dialogs since SHARE 78\n$INSTALL ME     An attempt at install instructions\n$READ    ME     What you are reading\n$WARRAN  TEE    The standard \"mods\" disclaimer\n#ACFCOMP PAN    Tutorial panel for ACFCOMP macro\n#ACFTRAP PAN    Tutorial panel for ACFTRAP macro\n#ASA2PC  PAN    Tutorial panel for ASA2PC macro\n#BROWSE4 PAN    Tutorial panel for BROWSE4 macro\n#EOL     PAN    Tutorial panel for EOL macro\n#FX      PAN    Tutorial panel for FX macro\n#FXC     PAN    Tutorial panel for FXC macro\n#GO      PAN    Tutorial panel for GO macro\n#JC      PAN    Tutorial panel for JC macro\n#LISTDSI PAN    Tutorial panel for LISTDSI macro\n#MEMLIST PAN    Tutorial panel for MEMLIST macro\n#OPER    PAN    Tutorial panel for OPER macro\n#PLUG    PAN    Tutorial panel for PLUG macro\n#PROFSET PAN    Tutorial panel for PROFSET macro\n#RUN     PAN    Tutorial panel for RUN macro\n#RUNACF  PAN    Tutorial panel for RUNACF macro\n#SHOWCUT PAN    Tutorial panel for SHOWCUT macro\n#TESTACF PAN    Tutorial panel for TESTACF macro\n#UNX     PAN    Tutorial panel for UNX macro\n#WEAVE   PAN    Tutorial panel for WEAVE macro\nACFCOMP  REX    ACFCOMP macro - Compile the ACF2 rule currently being edited\nACFTRAP  REX    ACFTRAP macro - Queue ACF subcommands and trap output\nASA2PC   REX    ASA2PC macro - Convert ASA printer control to ASCII code\nBROWSE4  CLI    BROWSE4 macro - Invoke ISPF Browse/View while in edit\nBROWZE   CLI    CLIST dialog to browse data sets (for ISPF command table usage)\nCALCP    PAN    Pop-up window used in CALC command/COMPUTE dialog\nCEILING  REX    REXX function to find smallest integer >= argument\nCLONEID  REX    REXX dialog to decomp a logonid into INSERT format for cloning\nCOMPUTE  REX    REXX dialog to calculate Rexx arithmetic expressions\nDSK33XX  CLI    CLIST dialog for disk space calculation (3350/3380/3390)\nDSK33XX  PAN    ISPF panel for disk space calculation (3350/3380/3390)\nDVOL     CLI    CLIST dialog to display disk free space stats from DVOL command\nDVOL     PAN    ISPF panel for DVOL dialog\nDVOLTBLH PAN    Tutorial panel for DVOL table display (short)\nDVOLTBLL PAN    ISPF panel used by DVOL table display (long)\nDVOLTBLS PAN    ISPF panel used by DVOL table display (short)\nEB       CLI    CLIST dialog to Edit/Browse by the numbers from a menu of DSNs\nEBH01A   PAN    Tutorial panel for Edit/Browse menu\nEBH01B   PAN    Turorial panel for Edit/Browse set default modes and libraries\nEB00     MSG    ISPF messages for Edit/Browse dialog\nEB01A    PAN    ISPF panel for Edit/Browse menu\nEB01B    PAN    ISPF panel for Edit/Browse set default modes and libraries\nEDET     CLI    CLIST dialog to edit data sets (for ISPF command table usage)\nEOL      REX    EOL macro - Set cursor at end of current screen line\nFLOOR    REX    REXX function to find largest integer <= argument\nFX       CLI    FX macro  - FIND 'str' ALL after EXCLUDE ALL\nFX       SPF    FX macro  - REXX version for SPF/PC Version 3.0\nFXC      CLI    FXC macro - FIND 'str @ cursor' ALL after EXCLUDE ALL\nGETACCT  REX    REXX sub-function to get accounting info from ACT\nGETACF2  REX    REXX sub-function to get ACF2 release identifier from ACCVT\nGETATTR  REX    REXX sub-function to get TSO user attributes from PSCB\nGETCIB   REX    REXX sub-function to get command verb code from 1st CIB\nGETCPUM  REX    REXX sub-function to get CPU model from CVT prefix\nGETDEST  REX    REXX sub-function to get TSO SYSOUT destination from PSCB\nGETDFPL  REX    REXX sub-function to get DFP level from DFA\nGETGRPN  REX    REXX sub-function to get group connect name from ACEE\nGETIPLD  REX    REXX sub-function to get IPL date from SMCA\nGETIPLT  REX    REXX sub-function to get IPL time from SMCA\nGETJES2  REX    REXX sub-function to get JES2 product name from HASPSSSM\nGETJOBID REX    REXX sub-function to get JES2 job id from SSIB\nGETLPAR  REX    REXX sub-function to get LPAR mode from SCCB\nGETNAME  REX    REXX sub-function to get user name from ACEE\nGETPLEX  REX    REXX sub-function to get SYSPLEX name from ECVT\nGETPRGNM REX    REXX sub-function to get programmer name from ACT\nGETREALM REX    REXX sub-function to get real memory size at IPL\nGETREGK  REX    REXX sub-function to get region size from LDA\nGETSCPN  REX    REXX sub-function to get MVS SCP name from CVT prefix\nGETSMFID REX    REXX sub-function to get smfid from SMCA\nGETSMS   REX    REXX sub-function to get SMS status from JESCTEXT\nGETSWA   REX    REXX sub-function to get location of SWA from JCT\nGETTRID  REX    REXX sub-function to get terminal id from ACEE\nGETUID   REX    REXX sub-function to get ACF2 userid string\nGO       CLI    GO macro - SUBMIT job then invoke IOF\nIDCAMS   REX    IDCAMS macro - execute IDCAMS commands (like =3.2.V 'exec')\nIEBUPDTE BAT    DOS batch file #2 to consolidate members for upload to MVS\nINFO     ABC    Action bar choice panel code to display system information\nISFP     CLI    World's shortest CLIST\nISFPANEL PAN    SDSF panel modifications for OPER macro\nISPCMDS  TBL    ISPF commands to be added to ISPCMDS for dialog invocation\nISR@PRIM PAN    ISPF Primary Option Menu (Version 3.3)\nISRUTIL  PAN    ISPF (Version 2.3) utility panel modifications for =3.14B\nISRZ00   MSG    ISPF messages ISRZ000W and ISRZ001W displayed in windows\nJC       CLI    JC macro - JOB card generator\nJC       PAN    ISPF panel used by JC and JCI macros\nJCI      CLI    JCI macro - JOB card generator (for use after file tailoring)\nLIBDIR   REX    REXX exec to display a CA-Librarian index\nLISTDSI  CLI    LISTDSI macro - List dataset info in OPT32 format\nLOGLIST  CLI    CLIST dialog to define output descriptors for ISPLOG/ISPLIST\nLOGLIST  JCL    ISPF skeleton used by LOGLIST dialog\nLOGLIST  PAN    ISPF panel used by LOGLIST dialog\nMEMLIST  CLI    MEMLIST macro - Display member list of PDS on =NOTE= lines\nMVS      BAS    MVS basica program - Pseudo-display of ISPF Primary Option Menu\nNOWARN   REX    REXX exec that issues RECOVERY OFF NOWARN (used with PROFSET)\nOPER     CLI    OPER macro - Issued canned operator commands via SDSF\nPDSDIR   REX    REXX exec to display a PDS directory\nPDSFTP   PAN    ISPF pop-up panel used by PDSFTP dialog\nPDSFTP   REX    REXX dialog to automate PDS member FTP's\nPDSFTPLM PAN    ISPF member list panel used by PDSFTP\nPDSFTPT  PAN    Tutorial panel for PDSFTP\nPLUG     REX    PLUG macro - Plug data into a range of lines at a given column\nPLUG     SPF    PLUG macro - REXX version for SPF/PC Version 3.0\nPROFSET  REX    PROFSET macro - Mass change all edit profiles for an applid\nRESETID  REX    REXX exec to reduce ACF2 password violation count by 1\nRUN      CLI    RUN macro - EXECute the CLIST/EXEC that is being edited\nRUNACF   REX    RUNACF macro - Issue ACF subcommands currently being edited\nSHOWCUT  CLI    SHOWCUT macro - Browse the ISPF CUT table(s) - PDS 8.5 CUT\nSHOWCUTP PAN    ISPF panel used by SHOWCUT table display\nSORTWORK PAN    ISPF panel used by SORTWORK dialog\nSORTWORK REX    REXX dialog to calculate SYNCSORT sortwork space\nSTARTUP  CLI    CLIST code run during TSO start-up to execute @LOGLIST\nSUPERC   CLI    CLIST dialog for SEARCH-FOR batch job (OPT314B)\nSUPERC   JCL    ISPF skeleton JCL to invoke SUPERC program in batch\nSYSLOG   CLI    CLIST dialog for browsing of current or previous SYSLOG\nSYSLOG   PAN    ISPF panel used by SYSLOG dialog\nTESTACF  REX    TESTACF macro - Test ACF2 rules based on DSN= values in JCL\nTRAPCMD  REX    REXX dialog to trap TSO/REXX output and display in ISPF table\nTRAPTBL  PAN    ISPF panel used by TRAPCMD table display\nTRICMDS  PAN    Tutorial panel for ISPF command help\nTRIJOBS  PAN    ISPF panel used to display key jobs with SDSF or IOF\nTRIMACS  PAN    Tutorial panel for edit macro help\nUNX      CLI    UNX macro - Show the first n line(s) from each X-cluded block\nUPLOAD   BAT    DOS batch file #1 to consolidate members for upload to MVS\nWEAVE    REX    WEAVE macro - Interlace CUT table into a range of lines\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$WARRANT": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x93)\\x1f\\x00\\x95'\\x8f\\x11\\x01\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc4\\xd6\\xc3@@@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-10-18T00:00:00", "modifydate": "1995-10-05T11:01:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "DOC"}, "text": "\n      LLL              SSSSSSSSS     SSSSSSSSS           CCCCCCCC\n      LLL             SSSSSSSSS     SSSSSSSSS          CCCCCCCCCCC\n      LLL            SSS           SSS                CCC      CC\n      LLL             SSS           SSS              CCC\n      LLL               SSS           SSS           CCC\n      LLL                 SSS           SSS        CCC\n      LLL                   SSS           SSS     CCC\n      LLL                    SSS           SSS   CCC      CC\n      LLLLLLLLLLLL  SSS    SSSS   SSS    SSSS    CCCCCCCCCC\n      LLLLLLLLLLLL  SSSSSSSSSS    SSSSSSSSSS     CCCCCCCC\n\n\n\n                        D I S C L A I M E R\n\n\n The dialogs and macros on this disk have been used successfully and\n to the best of our knowledge they are operational, however the only\n warranty made to the accuracy of the programs or related material is\n that they will function almost always correctly 98.9% of the time,\n which is 1% better than Rush Limbaugh.\n\n No responsibility is assumed for any modification directly or\n indirectly caused by the use of these dialogs.  It is the users\n responsibility to evaluate the usefulness of the material supplied.\n\n We do not guarantee to keep any material provided up to date nor do we\n guarantee to provide any corrections or extensions described by the\n user or corrections or extensions made in the future.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#EBUPDTE": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x00\\x00\\x83\\x01/\\x00\\x930\\x8f\\x072\\x00\\n\\x00\\n\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1983-01-12T00:00:00", "modifydate": "1993-11-04T07:32:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGCSCU  JOB (A006,SYTM,99,99),SAM-GOLOB,\n//             CLASS=S,MSGCLASS=V,NOTIFY=&SYSUID\n//*********************************************************//\n//* IEBUPDTE EXECUTION TO LOAD A NEW PDS FROM SEQUENTIAL  *//\n//*     YOU HAVE TO MAKE SURE >< IS CHANGED TO ./ FIRST   *//\n//*********************************************************//\n//USTEP    EXEC  PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DSN=THIS.SEQ.MEMBER,DISP=SHR\n//SYSUT2   DD  DSN=THE OUTPUT.PDS,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#PDSLOAD": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x00\\x00\\x85\"\\x7f\\x00\\x930\\x8f\\x073\\x00\\r\\x00\\r\\x00\\x00\\xd9\\xe4\\xd5\\xd1\\xc3\\xd3@@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "1985-08-15T00:00:00", "modifydate": "1993-11-04T07:33:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "RUNJCL"}, "text": "//SBGCSCX  JOB (A006,SYTM,99,99),S-GOLOB,\n//             CLASS=S,MSGCLASS=V,NOTIFY=&SYSUID\n//******************************************************************//\n//*   PDSLOAD  EXECUTION  -  LOAD PDS FROM IEBUPDTE SYSIN CARD D.S.*//\n//******************************************************************//\n//*\n//S01UPDTE EXEC  PGM=PDSLOAD,PARM='UPDTE(><)'\n//STEPLIB  DD  DSN=SBGCSC.A.LOAD,\n//             DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=THIS.SEQ.MEMBER,DISP=SHR\n//SYSUT2   DD  DSN=THE.OUTPUT.PDS,DISP=SHR\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@INFO": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x93)/\\x00\\x94%/\\x07&\\x00z\\x00z\\x00\\x00\\xc1\\xc2\\xc3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1993-10-19T00:00:00", "modifydate": "1994-09-09T07:26:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "ABC"}, "text": "\n\nSample action bar choice and )INIT code for the display of system information\nderived from a \"FIRST\" Rexx exec (%ADINIT) before ISR@PRIM is displayed.  I am\nusing the GETxxxxx Rexx sub-functions and some SYSVARs in %ADINIT to set the\nvariables before VPUTing to the shared pool (so they are available when the\nPrimary Option Menu is finally displayed).  Notice that there are no ACTION\ncommands associated with the pull down choices because this is for display\npurposes only.  If performance is a problem with all the GET's in your\n\"FIRST\" exec, then extract all the control block chasing code from each GET\nand hard code it in the \"FIRST\" exec or compile the GET's if you have a Rexx\ncompiler.\n\n\n\n\n\n\n\n\n\n\n\n\n EDIT ---- AD.ISPPLIB(ISR@PRIM) - 03.97 ----------------------- COLUMNS 001 072\n COMMAND ===>                                                  SCROLL ===> CSR\n ****** ***************************** TOP OF DATA ******************************\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -    90 LINE(S) NOT DISPLAYED\n 000091 )ABC ABCTEXT('Info')\n 000092   PDC PDCTEXT('Sysid:      &SYSID')\n 000093   PDC PDCTEXT('CPU Model:  &CPUMDL')\n 000094   PDC PDCTEXT('Real:       &REALSTOR')\n 000095   PDC PDCTEXT('IPL Date:   &IPLDATE')\n 000096   PDC PDCTEXT('IPL Time:   &IPLTIME')\n 000097   PDC PDCTEXT('MVS:        &SCPNAME')\n 000098   PDC PDCTEXT('JES2:       &JESLEVEL')\n 000099   PDC PDCTEXT('TSO/E:      &TSOE')\n 000100   PDC PDCTEXT('ISPF:       &ZPDFREL')\n 000101   PDC PDCTEXT('DFP:        &DFPLEVEL')\n 000102   PDC PDCTEXT('SMS:        &SMSSTAT')\n 000103   PDC PDCTEXT('Proc:       &LOGPROC')\n 000104   PDC PDCTEXT('Region:     &REGION')\n 000105   PDC PDCTEXT('Jobid:      &JESJOBID')\n 000106   PDC PDCTEXT('Termid:     &TERMID')\n 000107 )ABCINIT ABCTEXT('Info')\n 000108   .ZVARS = 'ZPDC'\n 000109   &ZPDC = ''\n 000110 )ABCPROC ABCTEXT('Info')\n 000111   VER (&ZPDC,RANGE,1,20)\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -    24 LINE(S) NOT DISPLAYED\n 000136 )INIT\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  6 LINE(S) NOT DISPLAYED\n 000143   IF (&ZPDFINIT = YES)    /* Code from Rockwell International */\n 000144     IF (&Z$SAVE \u00ac= &Z)    /*   \"    \"     \"           \"       */\n 000145       &ZCMD   = &Z$SAVE   /*   \"    \"     \"           \"       */\n 000146       .RESP     = ENTER   /*   \"    \"     \"           \"       */\n 000147       &Z$SAVE = &Z        /*   \"    \"     \"           \"       */\n 000148   IF (&ZPDFINIT = &Z)     /*   \"    \"     \"           \"       */\n 000149     &Z$SAVE   = &ZCMD     /*   \"    \"     \"           \"       */\n 000150     &ZCMD     = 'FIRST'   /*   \"    \"     \"           \"       */\n 000151     .RESP     = ENTER     /*   \"    \"     \"           \"       */\n 000152     &ZPDFINIT = YES       /*   \"    \"     \"           \"       */\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  5 LINE(S) NOT DISPLAYED\n 000158 )PROC\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 19 LINE(S) NOT DISPLAYED\n 000178             FIRST,'CMD(%ADINIT)'\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 16 LINE(S) NOT DISPLAYED\n ****** **************************** BOTTOM OF DATA ****************************\n\n\n EDIT ---- AD.CLIST(ADINIT) - 01.31 --------------------------- COLUMNS 001 072\n COMMAND ===>                                                  SCROLL ===> CSR\n ****** ***************************** TOP OF DATA ******************************\n 000001 /* REXX */\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  1 LINE(S) NOT DISPLAYED\n 000003 sysid    = GETSMFID()        /* SMF system id                   */\n 000004 scpname  = GETSCPN()         /* MVS product name                */\n 000005 ipldate  = GETIPLD()         /* IPL date                        */\n 000006 ipltime  = GETIPLT()         /* IPL time                        */\n 000007 dfplevel = GETDFPL()         /* DFP level                       */\n 000008 termid   = GETTRID()         /* Terminal id                     */\n 000009 cpumdl   = GETCPUM()         /* CPU model                       */\n 000010 realstor = GETREALM()'M'     /* Real memory                     */\n 000011 region   = GETREGK()'K'      /* Region                          */\n 000012 smsstat  = GETSMS()          /* SMS status                      */\n 000013 jesjobid = GETJOBID()        /* JES2 job id                     */\n 000014 jeslevel = GETJES2()         /* JES2 product name               */\n 000015 logproc  = SYSVAR(\"SYSPROC\") /* Logon proc                      */\n 000016 tsoe = SUBSTR(SYSVAR(\"SYSTSOE\"),1,1)'.'\u00a6\u00a6, /* TSO/E version     */\n 000017        SUBSTR(SYSVAR(\"SYSTSOE\"),3,1)'.'\u00a6\u00a6, /* TSO/E release     */\n 000018        SUBSTR(SYSVAR(\"SYSTSOE\"),4,1)       /* TSO/E mod level   */\n 000019 ADDRESS ISPEXEC\n 000020 \"ISPEXEC VPUT (SYSID SCPNAME IPLDATE IPLTIME DFPLEVEL TERMID\",\n 000021               \"CPUMDL REALSTOR REGION SMSSTAT JESJOBID JESLEVEL\",\n 000022               \"LOGPROC TSOE) SHARED\"\n - - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 36 LINE(S) NOT DISPLAYED\n ****** **************************** BOTTOM OF DATA ****************************\n\n\n   System  Spool  DBMS  Calendar  Help  Info                 PIE session:  1\n ------------------------------------ .-----------------------------. ----------\n                        ISPF/PDF 3.3  \u00a6 __ 1. Sysid:      A1VS      \u00a6\n OPTION  ===>                         \u00a6    2. CPU Model:  5890      \u00a6\n                                      \u00a6    3. Real:       102M      \u00a6 - TRIDJK\n    0  ISPF PARMS  - Specify terminal \u00a6    4. IPL Date:   94.244    \u00a6 - $LOGDED\n    1  BROWSE      - Display source d \u00a6    5. IPL Time:   20.12.48  \u00a6 - 07:23\n    2  EDIT        - Create or change \u00a6    6. MVS:        SP 4.3.0  \u00a6 - 94.252\n    3  UTILITIES   - Perform utility  \u00a6    7. JES2:       SP 4.3.0  \u00a6 - SP 4.3.0\n    6  COMMAND     - Enter TSO comman \u00a6    8. TSO/E:      2.4.0     \u00a6 - 2.4.0\n    7  DIALOG TEST - Perform dialog t \u00a6    9. ISPF:       PDF 3.3   \u00a6 - A1VS\n    D  XDC         - Interactive debu \u00a6   10. DFP:        3.3.1     \u00a6\n    E  EDIT/BROWSE - Edit/Browse by t \u00a6   11. SMS:        OFF       \u00a6 s\n    L  LIBRARIAN   - ADR/The Libraria \u00a6   12. Proc:       $LOGDED   \u00a6\n    M  MENU        - Information Tech \u00a6   13. Region:     3072K     \u00a6 nu\n    O  OUTPUT      - Output display u \u00a6   14. Jobid:      TSU21386  \u00a6\n    P  PDS         - Invoke the PDS c \u00a6   15. Termid:     VSMWD077  \u00a6\n    T  TUTORIAL    - Display informat '-----------------------------'\n    W  WHAT'S NEW  - Historical review of AMXSI-TRI ISPF/PDF extensions\n    X  EXIT        - Terminate ISPF using log and list defaults\n\n Enter END command to terminate ISPF.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLISTS": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x10/\\x00\\x99\\x10/\\t)\\x06\\x81\\x06\\x81\\x00\\x00\\xc3\\xd3\\xc9@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-04-12T00:00:00", "modifydate": "1999-04-12T09:29:00", "lines": 1665, "newlines": 1665, "modlines": 0, "user": "CLI"}, "text": "./ ADD NAME=BROWSE4  0137-89305-94340-0940-00048-00003-00000-CLIST\nISREDIT MACRO (DSNAME)\nCONTROL NOMSG MAIN NOLIST NOCONLIST NOSYMLIST\nIF &STR(&DSNAME) = ? THEN +\n  DO\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(#BROWSE4)\n    EXIT\n  END\nIF &STR(&DSNAME) \u00ac= &STR() THEN -\n  DO\n    ISREDIT (EDITDSN) = DATASET\n    SET &RPAREN = &NRSTR())\n    /*  DATASET NAME? */\n    IF &SYSINDEX(&RPAREN,&STR(&DSNAME),1) < 1 AND -\n       &SYSINDEX(&STR('),&STR(&DSNAME),1) < 1 AND -\n       &SYSINDEX(&STR(.),&STR(&DSNAME),1) < 1 THEN -\n      DO\n        /*  MEMBER NAME OR PATTERN? */\n        IF &STR(&SYSDSN('&EDITDSN(&DSNAME)')) = &STR(OK) OR -\n           &SYSINDEX(&STR(*),&STR(&DSNAME),1) > 0 THEN -\n          SET DSNAME = &STR('&EDITDSN(&DSNAME)')\n      END\n    IF &SUBSTR(1,&STR(&DSNAME)) = ' -\n      THEN -\n        SET DSNS = &SUBSTR(2:&LENGTH(&STR(&DSNAME))-1,&STR(&DSNAME))\n      ELSE -\n        SET DSNS = &STR(&SYSUID..&DSNAME)\n    ISPEXEC VGET (ZVIEW) PROFILE\n    IF &ZVIEW = &STR(YES) THEN -\n      SET &VIEWM = &STR(VIEW)\n    ELSE -\n      SET &VIEWM = &STR(BROWSE)\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC &VIEWM DATASET('&DSNS')\n    SET &BROWCC = &LASTCC\n    IF &BROWCC > 4 THEN -\n      DO\n        SET &ZEDSMSG = &STR(DSN OR MEMBER NOT FOUND)\n        SET &ZEDLMSG = &STR(DATASET '&DSNS' NOT FOUND)\n        ISPEXEC SETMSG MSG(ISRZ001W)\n      END\n    ISPEXEC CONTROL ERRORS CANCEL\n  END\nELSE -\n  DO\n    ISPEXEC SELECT PGM(ISRBRO) PARM(ISRBRO01)\n  END\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO INVOKE BROWSE WHILST IN EDIT           */\n./ ADD NAME=BROWZE   0110-91365-97122-0814-00014-00009-00000-CLIST\nPROC 0 DEBUG MODE(BROWSE) DATASET() PANEL(ISRBROBA)\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT ASIS\nELSE -\n  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST ASIS\nIF &MODE = &STR(VIEW) && -\n  &PANEL = &STR(ISRBROBA) THEN -\n  SET &PANEL = &STR(ISREDDE2)\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC &MODE DATASET('&DATASET') PANEL(&PANEL)\nISPEXEC CONTROL ERRORS CANCEL\nEND\n/* J.KALINICH, X4521 */\n/* CLIST TO INVOKE VIEW/BROWSE WITH OPTIONAL CUSTOM PANEL      */\n./ ADD NAME=DSK33XX  0112-90267-93008-0910-00236-00107-00000-CLIST\nPROC 0 DEBUG\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT\nELSE -\n  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\nPANEL: +\nISPEXEC DISPLAY PANEL(DSK33XX)\nIF &LASTCC = 8 THEN EXIT\nCALC3350: +\nIF &DLEN > 19069 THEN -\n  DO\n    SET &UTRK5 = 0\n    SET &PTRK5 = 0\n    SET &WTRK5 = 0\n    SET &BTRK5 = 0\n    SET &BCYL5 = 0\n    SET &TTRK5 = 0\n    SET &TCYL5 = 0\n    SET &TVOL5 = 0\n    GOTO CALC3380\n  END\nIF &KLEN = 0 OR &LENGTH(&KLEN) = 0 -\n  THEN -\n    DO\n      SET C = 185\n    END\n  ELSE -\n    DO\n      SET C = 267\n    END\nSET BTRK5 = 19254 / (&C + &KLEN + &DLEN)\nIF &NUMREC < &BTRK5 -\n  THEN -\n    SET UTRK5 = &DLEN * &NUMREC\n  ELSE -\n    SET UTRK5 = &DLEN * &BTRK5\nSET WTRK5 = 19069 - &UTRK5\nSET BCYL5 = 30 * &BTRK5\nSET TTRK5 = &NUMREC // &BTRK5\nIF &TTRK5 = 0 -\n  THEN -\n    SET TTRK5 = &NUMREC / &BTRK5\n  ELSE -\n    SET TTRK5 = (&NUMREC / &BTRK5) + 1\nSET TCYL5 = &TTRK5 // 30\nIF &TCYL5 = 0 -\n  THEN -\n    SET TCYL5 = &TTRK5 / 30\n  ELSE -\n    SET TCYL5 = (&TTRK5 / 30) + 1\n/* SINGLE DENSITY */\nSET TVOL5 = &TCYL5 // 555\nIF &TVOL5 = 0 -\n  THEN -\n    SET TVOL5 = &TCYL5 / 555\n  ELSE -\n    SET TVOL5 = (&TCYL5 / 555) + 1\nSET PTRK5 = (&UTRK5 * 1000) / 19069\nIF &PTRK5 > 999 THEN -\n  DO\n    SET PTRK5 = &SUBSTR(1:3,&PTRK5)&STR(.)&SUBSTR(4:4,&PTRK5)\n    GOTO CALC3380\n  END\nIF &PTRK5 > 99 THEN -\n  DO\n    SET PTRK5 = &SUBSTR(1:2,&PTRK5)&STR(.)&SUBSTR(3:3,&PTRK5)\n    GOTO CALC3380\n  END\nIF &PTRK5 > 9 THEN -\n  DO\n    SET PTRK5 = &SUBSTR(1:1,&PTRK5)&STR(.)&SUBSTR(2:2,&PTRK5)\n    GOTO CALC3380\n  END\nSET PTRK5 = &STR(.)&SUBSTR(1:1,&PTRK5)\nCALC3380: +\nIF &DLEN > 47476 THEN -\n  DO\n    SET &UTRK8 = 0\n    SET &PTRK8 = 0\n    SET &WTRK8 = 0\n    SET &BTRK8 = 0\n    SET &BCYL8 = 0\n    SET &TTRK8 = 0\n    SET &TCYL8 = 0\n    SET &TVOL8 = 0\n    GOTO CALC3390\n  END\nIF &KLEN = 0 OR &LENGTH(&KLEN) = 0 -\n  THEN -\n    DO\n      SET C = 15\n      SET K = 0\n    END\n  ELSE -\n    DO\n      SET C = 22\n      SET K = (&KLEN + 12) // 32\n      IF &K = 0 -\n        THEN -\n          SET K = (&KLEN + 12) / 32\n        ELSE -\n          SET K = ((&KLEN + 12) / 32) + 1\n    END\nSET D = (&DLEN + 12) // 32\nIF &D = 0 -\n  THEN -\n    SET D = (&DLEN + 12) / 32\n  ELSE -\n    SET D = ((&DLEN + 12) / 32) + 1\nSET BTRK8 = 1499 / (&C + &K + &D)\nIF &NUMREC < &BTRK8 -\n  THEN -\n    SET UTRK8 = &DLEN * &NUMREC\n  ELSE -\n    SET UTRK8 = &DLEN * &BTRK8\nSET WTRK8 = 47476 - &UTRK8\nSET BCYL8 = 15 * &BTRK8\nSET TTRK8 = &NUMREC // &BTRK8\nIF &TTRK8 = 0 -\n  THEN -\n    SET TTRK8 = &NUMREC / &BTRK8\n  ELSE -\n    SET TTRK8 = (&NUMREC / &BTRK8) + 1\nSET TCYL8 = &TTRK8 // 15\nIF &TCYL8 = 0 -\n  THEN -\n    SET TCYL8 = &TTRK8 / 15\n  ELSE -\n    SET TCYL8 = (&TTRK8 / 15) + 1\n/* DOUBLE DENSITY */\nSET TVOL8 = &TCYL8 // 1770\nIF &TVOL8 = 0 -\n  THEN -\n    SET TVOL8 = &TCYL8 / 1770\n  ELSE -\n    SET TVOL8 = (&TCYL8 / 1770) + 1\nSET PTRK8 = (&UTRK8 * 1000) / 47476\nIF &PTRK8 > 999 THEN -\n  DO\n    SET PTRK8 = &SUBSTR(1:3,&PTRK8)&STR(.)&SUBSTR(4:4,&PTRK8)\n    GOTO CALC3390\n  END\nIF &PTRK8 > 99 THEN -\n  DO\n    SET PTRK8 = &SUBSTR(1:2,&PTRK8)&STR(.)&SUBSTR(3:3,&PTRK8)\n    GOTO CALC3390\n  END\nIF &PTRK8 > 9 THEN -\n  DO\n    SET PTRK8 = &SUBSTR(1:1,&PTRK8)&STR(.)&SUBSTR(2:2,&PTRK8)\n    GOTO CALC3390\n  END\nSET PTRK8 = &STR(.)&SUBSTR(1:1,&PTRK8)\nCALC3390: +\nIF &KLEN = 0 OR &LENGTH(&KLEN) = 0 -\n  THEN -\n    DO\n      SET C = 19\n      SET K = 0\n    END\n  ELSE -\n    DO\n      SET C = 28\n      SET KN = (&KLEN + 6) // 232\n      IF &KN = 0 -\n        THEN -\n          SET KN = (&KLEN + 6) / 232\n        ELSE -\n          SET KN = ((&KLEN + 6) / 232) + 1\n      SET K = (&KLEN + (&KN * 6) + 6) // 34\n      IF &K = 0 -\n        THEN -\n          SET K = (&KLEN + (&KN * 6) + 6) / 34\n        ELSE -\n          SET K = ((&KLEN + (&KN * 6) + 6) / 34) + 1\n    END\nSET DN = (&DLEN + 6) // 232\nIF &DN = 0 -\n  THEN -\n    SET DN = (&DLEN + 6) / 232\n  ELSE -\n    SET DN = ((&DLEN + 6) / 232) + 1\nSET D = (&DLEN + (&DN * 6) + 6) // 34\nIF &D = 0 -\n  THEN -\n    SET D = (&DLEN + (&DN * 6) + 6) / 34\n  ELSE -\n    SET D = ((&DLEN + (&DN * 6) + 6) / 34) + 1\nSET BTRK9 = 1729 / (&C + &K + &D)\nIF &NUMREC < &BTRK9 -\n  THEN -\n    SET UTRK9 = &DLEN * &NUMREC\n  ELSE -\n    SET UTRK9 = &DLEN * &BTRK9\nSET WTRK9 = 56664 - &UTRK9\nSET BCYL9 = 15 * &BTRK9\nSET TTRK9 = &NUMREC // &BTRK9\nIF &TTRK9 = 0 -\n  THEN -\n    SET TTRK9 = &NUMREC / &BTRK9\n  ELSE -\n    SET TTRK9 = (&NUMREC / &BTRK9) + 1\nSET TCYL9 = &TTRK9 // 15\nIF &TCYL9 = 0 -\n  THEN -\n    SET TCYL9 = &TTRK9 / 15\n  ELSE -\n    SET TCYL9 = (&TTRK9 / 15) + 1\n/* DOUBLE DENSITY */\nSET TVOL9 = &TCYL9 // 2226\nIF &TVOL9 = 0 -\n  THEN -\n    SET TVOL9 = &TCYL9 / 2226\n  ELSE -\n    SET TVOL9 = (&TCYL9 / 2226) + 1\nSET PTRK9 = (&UTRK9 * 1000) / 56664\nIF &PTRK9 > 999 THEN -\n  DO\n    SET PTRK9 = &SUBSTR(1:3,&PTRK9)&STR(.)&SUBSTR(4:4,&PTRK9)\n    GOTO PANEL\n  END\nIF &PTRK9 > 99 THEN -\n  DO\n    SET PTRK9 = &SUBSTR(1:2,&PTRK9)&STR(.)&SUBSTR(3:3,&PTRK9)\n    GOTO PANEL\n  END\nIF &PTRK9 > 9 THEN -\n  DO\n    SET PTRK9 = &SUBSTR(1:1,&PTRK9)&STR(.)&SUBSTR(2:2,&PTRK9)\n    GOTO PANEL\n  END\nSET PTRK9 = &STR(.)&SUBSTR(1:1,&PTRK9)\nGOTO PANEL\nEND\n/* J.KALINICH/M. RESCHKE, X4521 */\n/* CLIST TO COMPUTE 3350/3380/3390 SPACE CALCULATIONS            */\n./ ADD NAME=DVOL     0160-88230-98197-0734-00132-00111-00000-CLIST\nPROC 0 DEBUG\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT ASIS\nELSE -\n  CONTROL MSG NOFLUSH NOLIST NOCONLIST NOSYMLIST ASIS\nPANEL: +\nISPEXEC DISPLAY PANEL(DVOL)\nIF &LASTCC = 8 THEN EXIT\nCREATE: +\nISPEXEC TBCREATE DVOL NAMES(DVOLSER DVOLF1 DVOLUNIT DVOLF2 +\n  DVOLTOT DVOLF3 DVOLLINE) NOWRITE REPLACE\nIF &LASTCC > 4 THEN -\n  DO\n    WRITE TBCREATE FAILED\n    EXIT\n  END\n\nSET LINELIM = 2000\nSET SYSOUTTRAP = &LINELIM\nCONTROL NOPROMPT\nDVOL (&DSER1 &DSER2 &DSER3 &DSER4 &DSER5 +\n      &DSER6 &DSER7 &DSER8 &DSER9 &DSER10) &DTYPE\n\nSET MAXLINE = &SYSOUTLINE\nIF &DTYPE = &STR(SHORT) THEN -\n  SET NUM = 3\nELSE -\n  SET NUM = 1\nDO WHILE &NUM \u00ac> &MAXLINE AND &NUM \u00ac> &LINELIM\n  SET SYSSCAN = 0\n  SET HVAL1 = &SYSOUTLINE\n  SET SYSSCAN = 1\n  SET HVAL2 = &HVAL1&NUM\n  SET SYSSCAN = 16\n  SET &DVOLSER  = &SUBSTR(1:6,&STR(&HVAL2))\n  SET &DVOLF1   = &SUBSTR(8:11,&STR(&HVAL2))\n  SET &DVOLUNIT = &SUBSTR(13:18,&STR(&HVAL2))\n  SET &DVOLF2   = &SUBSTR(20:39,&STR(&HVAL2))\n  SET &DVOLTOT  = &SUBSTR(41:46,&STR(&HVAL2))\n  SET &DVOLF3   = &SUBSTR(48:80,&STR(&HVAL2))\n  SET &DVOLLINE = &SUBSTR(1:80,&STR(&HVAL2))\n  IF &SUBSTR(1:16,&STR(&HVAL2)) = &STR(SERIAL  --UNIT--) OR -\n     &SUBSTR(1:16,&STR(&HVAL2)) = &STR(       ADDR TYPE) OR -\n     &SUBSTR(1:25,&STR(&HVAL2)) = &STR( ) THEN -\n    GOTO SKIPHDRS\n  ISPEXEC TBADD DVOL\n  IF &LASTCC NE 0 THEN -\n    DO\n      WRITE TBADD FAILED\n    END\n  SKIPHDRS: +\n  SET NUM = &NUM + 1\nEND\n\nSORT: +\nIF &DTYPE = &STR(SHORT) THEN -\n  DO\n    ISPEXEC TBSORT DVOL FIELDS(DVOLUNIT,C,D,DVOLSER,C,A)\n    SET &KEY2 = &STR(SortK1) /* PRIMARY SORT KEY */\n    SET &KEY1 = &STR(SortK2) /* SECONDARY SORT KEY */\n    SET &KEY3 = &STR( )\n  END\nISPEXEC TBTOP  DVOL\nDISPLAY: +\nSET CSSR = 1\nSET RC   = 0\nDO WHILE &RC < 8\n  ISPEXEC TBDISPL DVOL  PANEL(DVOLTBL&SUBSTR(1:1,&DTYPE)) +\n    CURSOR(ZCMD) CSRROW(&CSSR)\n  SET RC = &LASTCC\n  IF &LENGTH(&STR(&ZCMD)) > 2 THEN -\n    IF &SUBSTR(1:2,&ZCMD) = &STR(F ) OR -\n       &SUBSTR(1:2,&ZCMD) = &STR(L ) THEN -\n      IF &DTYPE = &STR(SHORT) THEN -\n        DO\n            DO\n              ISPEXEC TBVCLEAR DVOL\n              SET DVOLSER = &SUBSTR(3:&LENGTH(&STR(&ZCMD)),&STR(&ZCMD))+\n                            &STR(*)\n              ISPEXEC TBTOP  DVOL\n              ISPEXEC TBSARG DVOL\n              ISPEXEC TBSCAN DVOL\n              ISPEXEC TBQUERY DVOL POSITION(CSSR)\n            END\n        END\n  IF &LENGTH(&STR(&ZCMD)) > 5 THEN -\n    IF &SUBSTR(1:5,&ZCMD) = &STR(SORT) THEN -\n      IF &DTYPE = &STR(SHORT) THEN -\n        DO\n          SET &SORTKEY = DVOLSER\n          SET &SORTSEQ = A\n          IF &SUBSTR(6:6,&ZCMD) = &STR(S) THEN -\n            DO\n              SET &SORTKEY = DVOLSER\n              SET &SORTSEQ = A\n              SET &KEY2 = &STR(SortK1) /* PRIMARY SORT KEY */\n              SET &KEY1 = &STR(SortK2) /* SECONDARY SORT KEY */\n              SET &KEY3 = &STR( )\n            END\n          IF &SUBSTR(6:6,&ZCMD) = &STR(T) THEN -\n            DO\n              SET &SORTKEY = DVOLTOT\n              SET &SORTSEQ = D\n              SET &KEY2 = &STR(SortK1) /* PRIMARY SORT KEY */\n              SET &KEY1 = &STR( )\n              SET &KEY3 = &STR(SortK2) /* SECONDARY SORT KEY */\n            END\n          ISPEXEC TBSORT DVOL +\n            FIELDS(DVOLUNIT,C,D,&SORTKEY,C,&SORTSEQ)\n          ISPEXEC TBTOP  DVOL\n        END\n  IF &LENGTH(&STR(&ZCMD)) = 4 THEN -\n    IF &SUBSTR(1:4,&ZCMD) = &STR(SORT) THEN -\n      IF &DTYPE = &STR(SHORT) THEN -\n        DO\n          SET &KEY2 = &STR(SortK1) /* PRIMARY SORT KEY */\n          SET &KEY1 = &STR(SortK2) /* SECONDARY SORT KEY */\n          SET &KEY3 = &STR( )\n          ISPEXEC TBSORT DVOL +\n            FIELDS(DVOLUNIT,C,D,DVOLSER,C,A)\n          ISPEXEC TBTOP  DVOL\n        END\nEND\nIF &RC = 8 THEN -\n  DO\n    ISPEXEC TBCLOSE DVOL\n    GOTO PANEL\n  END\nGOTO DISPLAY\n/* J. KALINICH, X4521 */\n/* CLIST TO DISPLAY DISK FREE SPACE USING DVOL (CBT FILE 296) */\n/* REQUIRES AUG. 1997 VERSION OF DVOL COMMAND FROM BRUCE LELAND */\n./ ADD NAME=EB       0124-93174-99090-0722-00173-00168-00000-CLIST\nPROC 0 DEBUG\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT\nELSE -\n  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\nISPEXEC VGET (EB1  EB2  EB3  EB4  EB5  EB6  EB7  EB8  EB9  EB10 +\n              EB11 EB12 EB13 EB14 EB15 EB16 EB17 EB18 EB19 +\n              EM1  EM2  EM3  EM4  EM5  EM6  EM7  EM8  EM9  EM10 +\n              EM11 EM12 EM13 EM14 EM15 EM16 EM17 EM18 EM19) PROFILE\nISPEXEC VGET ZTRAIL\nIF &LENGTH(&STR(&ZTRAIL)) > 0 THEN -\n  DO\n    ISPEXEC  CONTROL NONDISPL ENTER\n    SET PDS = &STR(&ZTRAIL)\n  END\nPANEL: +\nISPEXEC DISPLAY PANEL(EB01A) MSG(&MSGID)\nIF &LASTCC > 0 THEN EXIT\nSET MSGID = &STR()\nIF &PDS = 0 THEN -\n  DO\n    SET INDX = 1\n    DO WHILE &INDX < 20\n      SET HOLD = &&EB&INDX\n      SET EO&INDX = &HOLD\n      SET INDX = &INDX + 1\n    END\n    ISPEXEC DISPLAY PANEL(EB01B)\n    SET HOLDCC = &LASTCC\n    IF &HOLDCC = 0 THEN -\n      DO\n        SET INDX = 1\n        DO WHILE &INDX < 20\n          SET OLD = &&EO&INDX\n          SET NEW = &&EB&INDX\n          IF &LENGTH(&NEW) > 0 AND &OLD \u00ac= &NEW THEN -\n            DO\n              ALLOC DA(&NEW) SHR\n              IF &LASTCC = 0 THEN -\n                DO\n                  FREE DA(&NEW)\n                  SET EO&INDX = &NEW\n                END\n              ELSE -\n                DO\n                  ISPEXEC DISPLAY PANEL(EB01B) MSG(EB005) +\n                     CURSOR(EB&INDX)\n                  SET HOLDCC = &LASTCC\n                  IF &HOLDCC > 0 THEN -\n                    DO\n                      SET INDXB = 1\n                      DO WHILE &INDXB < 20\n                        SET HOLD = &&EO&INDXB\n                        SET EB&INDXB = &HOLD\n                        SET INDXB = &INDXB + 1\n                      END\n                      SET INDX = 20\n                    END\n                  ELSE -\n                    SET INDX = 0\n                END\n            END\n          SET INDX = &INDX + 1\n        END\n        IF &HOLDCC = 0 THEN -\n          DO\n            ISPEXEC VPUT (EB1 EB2 EB3 EB4 EB5 EB6 EB7 EB8 EB9 EB10 +\n                EB11 EB12 EB13 EB14 EB15 EB16 EB17 EB18 EB19 +\n                EM1  EM2  EM3  EM4  EM5  EM6  EM7  EM8  EM9  EM10 +\n                EM11 EM12 EM13 EM14 EM15 EM16 EM17 EM18 EM19) PROFILE\n            SET MSGID = &STR(EB004)\n          END\n      END\n  END\nELSE -\n  IF &PDS = 20 OR &LENGTH(&DSNAME) = 0 THEN -\n    ISPEXEC SELECT PGM(ISREDIT)\n  ELSE -\n    DO\n      IF &STR(&MODE) = E OR -\n         &STR(&MODE) = B OR -\n         &STR(&MODE) = V THEN -\n        DO\n          IF &STR(&MODE) = B THEN -\n            SET MODE = BROWSE\n          IF &STR(&MODE) = E THEN -\n            SET MODE = EDIT\n          IF &STR(&MODE) = V THEN -\n            SET MODE = VIEW\n          ISPEXEC CONTROL ERRORS RETURN\n          IF &STR(&MEMBER) = &STR() THEN -\n            ISPEXEC &MODE DATASET(&DSNAME)\n          ELSE -\n            DO\n              IF &SUBSTR(1:1,&DSNAME) = &STR(') THEN -\n                DO\n                  SET DSNAME = &SUBSTR(2:&LENGTH(&DSNAME)-1,&DSNAME)\n                  ISPEXEC &MODE DATASET('&DSNAME(&STR(&MEMBER))')\n                END\n              ELSE -\n                ISPEXEC &MODE DATASET(&DSNAME(&STR(&MEMBER)))\n            END\n          SET HOLDCC = &LASTCC\n          ISPEXEC CONTROL ERRORS CANCEL\n          IF &HOLDCC = 14 AND &MODE = &STR(BROWSE) THEN -\n            SET MSGID = &STR(EB001)\n          IF &HOLDCC = 14 AND &MODE = &STR(VIEW) THEN -\n            SET MSGID = &STR(EB001)\n          IF &HOLDCC = 14 AND &MODE = &STR(EDIT) THEN -\n            SET MSGID = &STR(EB006)\n          IF &HOLDCC = 16 THEN -\n            SET MSGID = &STR(EB007)\n          IF &HOLDCC = 20 THEN -\n            SET MSGID = &STR(EB008)\n        END\n      ELSE -\n        DO\n          IF &STR(&MODE) = &STR(LE) THEN -\n            DO\n              IF &SYSINDEX(&STR(*),&STR(&MEMBER),1) > 0 OR +\n                &STR(&MEMBER) = &STR() THEN -\n                SET &CMD = &STR(LIST)\n              ELSE -\n                SET &CMD = &STR(EDIT)\n              IF &STR(&MEMBER) = &STR() THEN-\n                SET &MEMBER = &STR(*)\n              ISPEXEC SELECT PGM(ELIPS) +\n                NEWAPPL(LIB@) +\n                NEWPOOL +\n                PARM( +\n                     CMD('&CMD &MEMBER') +\n                     DSN(&DSNAME) +\n                     )\n            END\n          IF &STR(&MODE) = &STR(LB) THEN -\n            DO\n              IF &SYSINDEX(&STR(*),&STR(&MEMBER),1) > 0 OR +\n                &STR(&MEMBER) = &STR() THEN -\n                SET &CMD = &STR(LIST)\n              ELSE -\n                SET &CMD = &STR(BROWSE)\n              IF &STR(&MEMBER) = &STR() THEN-\n                SET &MEMBER = &STR(*)\n              ISPEXEC SELECT PGM(ELIPS) +\n                NEWAPPL(LIB@) +\n                NEWPOOL +\n                PARM( +\n                     CMD('&CMD &MEMBER') +\n                     DSN(&DSNAME) +\n                     )\n            END\n          IF &STR(&MODE) = &STR(PDS) THEN -\n            DO\n              IF &STR(&MEMBER) = &STR() THEN -\n                ISPEXEC SELECT PGM(PDS85) PARM(PDS85 &DSNAME +\n                                               MEMLIST :)\n              ELSE -\n                ISPEXEC SELECT PGM(PDS85) PARM(PDS85 &DSNAME +\n                                               MEMLIST &MEMBER)\n            END\n        END\n    END\nGOTO PANEL\nEXIT CODE(0)\n/* J. KALINICH/M. RESCHKE, X4521                                     */\n/* CLIST TO EDIT/BROWSE A MENU OF LIBRARIES                          */\n/*                                                                   */\n/* CLIST FUNCTIONS:                                                  */\n/*                                                                   */\n/* 1.  ISPF EDIT/BROWSE/VIEW FOR PDS AND SEQUENTIAL DATASETS         */\n/* 2.  LIBRARIAN ELIPS EDIT/BROWSE FOR LIBRARIAN DATASETS            */\n/* 3.  PDS 8.5 FUNCTIONS FOR PDS AND SEQUENTIAL DATASETS             */\n/*                                                                   */\n./ ADD NAME=EDET     0106-92091-95019-1234-00011-00009-00000-CLIST\nPROC 0 DEBUG DATASET() PANEL(ISREDDE2) MACRO()\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT ASIS\nELSE -\n  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST ASIS\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC EDIT DATASET('&DATASET') PANEL(&PANEL) MACRO(&MACRO)\nISPEXEC CONTROL ERRORS CANCEL\nEND\n/* J.KALINICH, X4521 */\n/* CLIST TO INVOKE EDIT WITH OPTIONAL CUSTOM EDIT PANEL AND MACRO */\n./ ADD NAME=FX       0104-94279-97216-1255-00115-00111-00000-CLIST\nISREDIT MACRO (FXSTRING COL1 COL2 OTHER)\n/*--------------------------------------------------------------------*/\n/*     FX EDIT MACRO - FIND ALL 'STRING' (AFTER EXCLUDE ALL LINES)    */\n/*--------------------------------------------------------------------*/\n/*    5 OCT 94 - SUPPORT ' AND \" AS STRING DELIMITERS                 */\n/*               SUPPORT OTHER FIND PARAMETERS:                       */\n/*                 1.  LABEL-RANGE                                    */\n/*                 2.  PREFIX, SUFFIX, AND WORD                       */\n/*               ISSUE MESSAGE ON SYNTAX/SEVERE ERROR                 */\n/*   20 MAY 93 - ZERO SUPPRESS &FINDS, &LEFT, AND &RIGHT VARIABLES    */\n/*   21 APR 92 - SUPPORT (P)ICTURE, HE(X), (T)EXT, AND (C)HARACTER    */\n/*               STRING ARGUMENTS                                     */\n/*    9 MAR 92 - SUPPORT CLIST &VARIABLES AS STRING ARGUMENTS         */\n/*    1 OCT 91 - SUPPORT FIRST/LAST COLUMNS AS PARAMETERS             */\n/*               SUPPORT SEQUENCE NUMBERS AS SEARCHABLE DATA          */\n/*--------------------------------------------------------------------*/\nCONTROL NOFLUSH NOMSG NOLIST NOCONLIST NOSYMLIST\nIF &NRSTR(&FXSTRING) = &STR() THEN -\n  DO\n    SET &ZEDSMSG = &STR(ENTER FIND STRING)\n    SET &ZEDLMSG = &STR(FX REQUIRES A STRING AS AN ARGUMENT)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n  END\nIF &LENGTH(&NRSTR(&FXSTRING)) = 1 THEN -\n  DO\n    /* WRAP IN QUOTES SO &SUBSTR(1:2,... DOES NOT BOMB */\n    SET &FXSTRING = &NRSTR('&FXSTRING')\n  END\nIF &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(C') OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(P') OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(T') OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(X') OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(C\") OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(P\") OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(T\") OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR(X\") OR -\n   &SUBSTR(1:1,&NRSTR(&FXSTRING)) = &STR(')  OR -\n   &SUBSTR(1:1,&NRSTR(&FXSTRING)) = &STR(\")  THEN -\n  SET &QUOTE = &STR()\nELSE -\n  SET &QUOTE = &STR(')\nISREDIT (STAT,VALUE) = NUMBER  /* SAVE NUMBER SETTING */\nISREDIT NUMBER OFF             /* SEARCH SEQUENCE NUMBERS ON 'FIND' */\nSET SCAN = ON\nIF &SUBSTR(1:1,&NRSTR(&FXSTRING)) = &STR(&&) OR -\n   &SUBSTR(1:2,&NRSTR(&FXSTRING)) = &STR('&&) THEN -\n  DO\n    SET &SCAN = OFF\n    SET &FXSTRING = &NRSTR(&SUBSTR(1:&LENGTH(&NRSTR(&FXSTRING)),+\n                    &NRSTR(&FXSTRING)))\n  END\nISREDIT EXCLUDE ALL\nISPEXEC CONTROL ERRORS RETURN\nISREDIT SCAN &SCAN\n/*--------------------------------------------------------------------*/\nISREDIT FIND ALL &FXSTRING &COL1 &COL2 &OTHER\n/*--------------------------------------------------------------------*/\nSET &FINDCC = &LASTCC\nIF &FINDCC > 4 THEN -\n  DO\n    SET &ZEDSMSG = &STR(PARAMETER NOT RECOGNIZED)\n    SET &ZEDLMSG = &STR(CHECK FOR MISSPELLED KEYWORDS OR +\n                        TOO MANY BOUNDS OR RANGE PARAMETERS.)\n    ISPEXEC SETMSG MSG(ISRZ000)\n    ISREDIT RESET EXCLUDED\n    ISREDIT NUMBER = (STAT,VALUE)  /* RESTORE NUMBER SETTING */\n    EXIT CODE(1)                   /* RETURN CURSOR TO COMMAND LINE */\n  END\nISREDIT (FINDS) = FIND_COUNTS\nISREDIT (LEFT,RIGHT) = BOUNDS\nIF &COL1 = &STR() AND -\n   &COL2 = &STR() THEN GOTO NOCOLS\nIF &COL1 \u00ac= &STR() AND -\n   &DATATYPE(&COL1) = &STR(NUM) THEN -\n  SET &LEFT = &COL1\nIF &COL2 \u00ac= &STR() AND -\n   &DATATYPE(&COL2) = &STR(NUM) THEN -\n  SET &RIGHT = &COL2\nELSE -\n  DO\n    IF &DATATYPE(&COL1) = &STR(NUM) AND -\n       &DATATYPE(&COL2) \u00ac= &STR(NUM) THEN -\n      DO\n        SET &RIGHT = &LEFT + &LENGTH(&NRSTR(&FXSTRING)) - 1\n        IF &SUBSTR(1:1,&NRSTR(&FXSTRING)) = &STR(')  OR -\n           &SUBSTR(1:1,&NRSTR(&FXSTRING)) = &STR(\")  THEN -\n          SET &RIGHT = &RIGHT - 2\n      END\n  END\nNOCOLS: +\nSET &FINDS = &FINDS\nSET &LEFT  = &LEFT\nSET &RIGHT = &RIGHT\nIF &FINDCC > 0 THEN -\n  DO\n    SET &ZEDSMSG = &STR(NO CHARS &QUOTE&FXSTRING&QUOTE FOUND)\n    SET &ZEDLMSG = &STR(CHARS &QUOTE&FXSTRING&QUOTE - NOT FOUND +\n                        ON ANY LINES +\n                        (COLS &LEFT TO &RIGHT).)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    ISREDIT RESET EXCLUDED\n  END\nELSE -\n  DO\n    SET &ZEDSMSG = &STR(&FINDS CHARS &QUOTE&FXSTRING&QUOTE)\n    SET &ZEDLMSG = &STR(CHARS &QUOTE&FXSTRING&QUOTE FOUND +\n                        &FINDS TIMES +\n                        WITHIN COLUMNS &LEFT TO &RIGHT.)\n    ISPEXEC SETMSG MSG(ISRZ000)\n  END\nISREDIT NUMBER = (STAT,VALUE)  /* RESTORE NUMBER SETTING */\nEXIT CODE(1)                   /* RETURN CURSOR TO COMMAND LINE */\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO DO FIND ALL AFTER EXCLUDE ALL */\n./ ADD NAME=FXC      0136-90332-93313-0804-00088-00065-00000-CLIST\nISREDIT MACRO\n/*                                                                 */\n/* FXC EDIT MACRO - FIND ALL IN EXCLUDED LINES (INCL SEQ NUMBERS)  */\n/*                  USING THE 'STRING' THE CURSOR IS SITTING ON    */\n/*                                                                 */\n/*   20 MAY 93 - ZERO SUPPRESS &FINDS, &LEFT, AND &RIGHT VARIABLES */\n/*                                                                 */\nCONTROL NOFLUSH NOMSG NOLIST NOCONLIST NOSYMLIST\nISREDIT (LINE) = LINE .ZCSR\nISREDIT (END)  = LRECL\nISREDIT (CL,CC) = CURSOR\nIF &CC = 0 OR -\n   &CC > &END THEN -\n  DO\n    SET &ZEDSMSG = &STR(PUT CURSOR ON A STRING)\n    SET &ZEDLMSG = &STR(FXC NEEDS THE CURSOR IN THE DATA AREA)\n    ISPEXEC SETMSG MSG(ISRZ001W)\n    IF &CC > &END THEN -\n      SET &CC = 0\n    ISREDIT CURSOR = (CL,CC)\n    EXIT CODE(0)\n  END\n/* STRING DELIMITERS BELOW - MODIFY AS APPROPRIATE  */\nSET &DELIM = &NRSTR(~`!@#$%\u00ac()-_=+|\u00a2{\u00dd\u00a8};:\"'<,>?/ )\n/* EBCDIC HEX ----> A757756545667444CABD5777466664  */\n/*  VALUES          19ACBBCFDD0DEEFA0DD0EAFDCBEF10  */\n/*                                                  */\n/* IN ORDER TO RECONSTRUCT AFTER AN ASCII -> EBCDIC */\n/* CODE TRANSLATION DURING FILE TRANSFER.           */\n\nSET &START = 1\nDO &I = &CC TO &START BY -1\n  IF &SYSINDEX(&SUBSTR(&I,&NRSTR(&LINE)),&NRSTR(&DELIM),1) > 0 THEN -\n    SET &START = &I + 1\nEND\n\nDO &I = &CC TO &END\n  IF &SYSINDEX(&SUBSTR(&I,&NRSTR(&LINE)),&NRSTR(&DELIM),1) > 0 THEN -\n    SET &END = &I - 1\nEND\n\nIF &START > &END THEN -\n  DO\n    SET &ZEDSMSG = &STR(PUT CURSOR ON A STRING)\n    SET &ZEDLMSG = &STR(FXC NEEDS THE CURSOR ON A NON-DELIMITER)\n    ISPEXEC SETMSG MSG(ISRZ001W)\n    ISREDIT CURSOR = (CL,CC)\n    EXIT CODE(0)\n  END\n\nSET &FXSTRING = &NRSTR(&SUBSTR(&START:&END,&NRSTR(&LINE)))\n\nISREDIT (STAT,VALUE) = NUMBER  /* SAVE NUMBER SETTING */\nISREDIT NUMBER OFF             /* SEARCH SEQUENCE NUMBERS ON 'FIND' */\nSET &SCAN = ON\nIF &STR(&SUBSTR(1:1,&STR(&FXSTRING))) = &STR(&&) THEN -\n  SET &SCAN = OFF\nISREDIT EXCLUDE ALL\nISPEXEC CONTROL ERRORS RETURN\nISREDIT SCAN &SCAN\nISREDIT FIND ALL '&FXSTRING'\nSET &FINDCC = &LASTCC\nISREDIT (FINDS) = FIND_COUNTS\nISREDIT (LEFT,RIGHT) = BOUNDS\nSET &FINDS = &FINDS\nSET &LEFT  = &LEFT\nSET &RIGHT = &RIGHT\nIF &FINDCC > 0 -\n  THEN -\n    DO\n      SET &ZEDSMSG = &STR(NO CHARS '&FXSTRING' FOUND)\n      SET &ZEDLMSG = &STR(CHARS '&FXSTRING' - NOT FOUND ON ANY LINES +\n                          (COLS &LEFT TO &RIGHT).)\n      ISPEXEC SETMSG MSG(ISRZ001W)\n      ISREDIT RESET EXCLUDED\n    END\n  ELSE -\n    DO\n      SET &ZEDSMSG = &STR(&FINDS CHARS '&FXSTRING')\n      SET &ZEDLMSG = &STR(CHARS '&FXSTRING' FOUND &FINDS TIMES +\n                          WITHIN COLUMNS &LEFT TO &RIGHT.)\n      ISPEXEC SETMSG MSG(ISRZ000W)\n    END\nISREDIT NUMBER = (STAT,VALUE)  /* RESTORE NUMBER SETTING */\nEXIT CODE(1)                   /* RETURN CURSOR TO COMMAND LINE */\nEND\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO DO FIND ALL FROM EXCLUDED LINES ON WORD AT CURSOR */\n./ ADD NAME=GO       0125-90310-97072-1004-00005-00008-00000-CLIST\nISREDIT MACRO\nISREDIT SUBMIT\nISPEXEC SELECT PGM(IOFSPF) NEWAPPL(IOF) PASSLIB\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO SUBMIT JOB AND INVOKE IOF */\n./ ADD NAME=ISFP     0110-89241-99007-1339-00003-00001-00000-CLIST\nPDF\n/* J. KALINICH, X4521 */\n/* FOR THOSE OF USE WHO CAN'T SPELL */\n./ ADD NAME=JC       0131-89275-94012-1359-00139-00086-00000-CLIST\nISREDIT MACRO (JCCLASS)\n/**********************************************************************/\n/*    JOB CARD MACRO:                                                 */\n/*                                                                    */\n/*    IF INVOKED WITH A JOB CLASS PARAMETER (E.G., \"JC B\"), THEN      */\n/*    THE PANEL WILL NOT BE DISPLAYED AND THE JOB CARD WILL BE BUILT  */\n/*    WITH THE PROFILE VARIABLES THAT HAVE BEEN SAVED.                */\n/*                                                                    */\n/**********************************************************************/\nCONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\nIF &STR(&JCCLASS) \u00ac= &Z THEN -\n  DO\n    ISPEXEC CONTROL NONDISPL ENTER\n    ISPEXEC DISPLAY PANEL(JC)\n    IF &LASTCC > 0 THEN -\n      EXIT\n  END\nELSE -\n  DO\n    ISPEXEC DISPLAY PANEL(JC)\n    IF &LASTCC > 0 THEN -\n      EXIT\n  END\nIF &STR(&JCPROC) \u00ac= &Z THEN -\n  DO\n    IF &SUBSTR(1,&STR(&JCPROC)) = ' THEN -\n      SET JCPROC = &SUBSTR(2:&LENGTH(&STR(&JCPROC))-1,&STR(&JCPROC))\n    ELSE -\n      SET JCPROC = &STR(&SYSUID..&STR(&JCPROC))\n  END\nIF &STR(&JCOTHER1) \u00ac= &Z THEN -\n  DO\n    IF &SUBSTR(&LENGTH(&STR(&JCOTHER1)),&STR(&JCOTHER1)) \u00ac= &STR(,) -\n      THEN -\n        SET JCOTHER1 = &STR(&JCOTHER1)&STR(,)\n  END\nIF &STR(&JCOTHER2) \u00ac= &Z THEN -\n  DO\n    IF &SUBSTR(&LENGTH(&STR(&JCOTHER2)),&STR(&JCOTHER2)) \u00ac= &STR(,) -\n      THEN -\n        SET JCOTHER2 = &STR(&JCOTHER2)&STR(,)\n  END\nIF &STR(&JCOTHER3) \u00ac= &Z THEN -\n  DO\n    IF &SUBSTR(&LENGTH(&STR(&JCOTHER3)),&STR(&JCOTHER3)) \u00ac= &STR(,) -\n      THEN -\n        SET JCOTHER3 = &STR(&JCOTHER3)&STR(,)\n  END\nSET JOB1  = &STR(//&JCPRE.&JCSU JOB (&JCACC),'&JCNAME',)\nSET JOBO1 = &STR(//             &JCOTHER1)\nSET JOBO2 = &STR(//             &JCOTHER2)\nSET JOBO3 = &STR(//             &JCOTHER3)\nSET JOB2  = &STR(//             CLASS=&JCCLASS,)\nSET JOB3  = &STR(//             TIME=(&JCTIME),)\nSET JOB4  = &STR(//             NOTIFY=&JCNOTIFY,)\nSET JOB5  = &STR(//             MSGCLASS=&JCMC)\nSET JOB6  = &STR(&STR(/*)JOBPARM R=&JCRM,T=9999,L=9999)\nSET JOB7  = &STR(&STR(/*)ROUTE XEQ   &JCJXEQ)\nSET JOB8  = &STR(&STR(/*)ROUTE PRINT &JCJPRT)\nSET JOB9  = &STR(//JCL      JCLLIB  ORDER=&JCPROC)\nSET JOB10 = &STR(//JOB      OUTPUT  NAME='&JCNAME',)\nSET JOB11 = &STR(//             TITLE='&JCTITLE',)\nSET JOB12 = &STR(//             DEPT='&JCDEPT',)\nSET JOB13 = &STR(//             BUILDING='&JCBLDG',)\nSET JOB14 = &STR(//             ADDRESS=('&JCADDR1',\nSET JOB15 = &STR(//             '&JCADDR2',)\nSET JOB16 = &STR(//             '&JCADDR3',)\nSET JOB17 = &STR(//             '&JCADDR4'))&STR(,)\nSET JOB18 = &STR(//             JESDS=ALL,)\nSET JOB19 = &STR(//             DEFAULT=YES)\nISREDIT (TOP,BOT) = DISPLAY_LINES\nIF &TOP = 1 THEN                           /* IS THERE A LINE 1? */ -\n  DO                                       /* YES */\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB19\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB18\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB17\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB16\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB15\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB14\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB13\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB12\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB11\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB10\"\n    IF &STR(&JCPROC) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOB9\"\n    IF &STR(&JCJPRT) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOB8\"\n    IF &STR(&JCJXEQ) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOB7\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB6\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB5\"\n    IF &STR(&JCNOTIFY) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOB4\"\n    IF &STR(&JCTIME) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOB3\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB2\"\n    IF &STR(&JCOTHER3) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOBO3\"\n    IF &STR(&JCOTHER2) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOBO2\"\n    IF &STR(&JCOTHER1) \u00ac= &Z THEN -\n      ISREDIT LINE_BEFORE .ZFIRST = \"&JOBO1\"\n    ISREDIT LINE_BEFORE .ZFIRST = \"&JOB1\"\n  END\nELSE                                       /* NO, THEN NEW MEMBER */ -\n  DO\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB1\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB19\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB18\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB17\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB16\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB15\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB14\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB13\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB12\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB11\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB10\"\n    IF &STR(&JCPROC) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOB9\"\n    IF &STR(&JCJPRT) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOB8\"\n    IF &STR(&JCJXEQ) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOB7\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB6\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB5\"\n    IF &STR(&JCNOTIFY) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOB4\"\n    IF &STR(&JCTIME) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOB3\"\n    ISREDIT LINE_AFTER .ZFIRST = \"&JOB2\"\n    IF &STR(&JCOTHER3) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOBO3\"\n    IF &STR(&JCOTHER2) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOBO2\"\n    IF &STR(&JCOTHER1) \u00ac= &Z THEN -\n      ISREDIT LINE_AFTER .ZFIRST = \"&JOBO1\"\n  END\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO BUILD JOBCARD SEQUENCE */\n./ ADD NAME=JCI      0122-89275-94012-1359-00110-00072-00000-CLIST\nISREDIT MACRO (JCCLASS)\n/**********************************************************************/\n/*    JOB CARD INITIAL MACRO:                                         */\n/*                                                                    */\n/*    USE AS AN INITIAL MACRO TO BUILD A JOB CARD AFTER FILE          */\n/*    TAILORING HAS CREATED ALL THE OTHER JCL.                        */\n/*                                                                    */\n/*    THE PANEL WILL BE DISPLAYED AND THE JOB CARD WILL BE BUILT      */\n/*    WITH THE PROFILE VARIABLES THAT HAVE BEEN SAVED.                */\n/*                                                                    */\n/**********************************************************************/\nCONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\nIF &STR(&JCCLASS) \u00ac= &Z THEN -\n  DO\n    ISPEXEC CONTROL NONDISPL ENTER\n    ISPEXEC DISPLAY PANEL(JC)\n    IF &LASTCC > 0 THEN -\n      EXIT\n  END\nELSE -\n  DO\n    ISPEXEC DISPLAY PANEL(JC)\n    IF &LASTCC > 0 THEN -\n      EXIT\n  END\nIF &STR(&JCPROC) \u00ac= &Z -\n  THEN -\n    DO\n      IF &SUBSTR(1,&STR(&JCPROC)) = ' THEN -\n        SET JCPROC = &SUBSTR(2:&LENGTH(&STR(&JCPROC))-1,&STR(&JCPROC))\n      ELSE -\n        SET JCPROC = &STR(&SYSUID..&STR(&JCPROC))\n    END\nIF &STR(&JCOTHER1) \u00ac= &Z THEN -\n  DO\n    IF &SUBSTR(&LENGTH(&STR(&JCOTHER1)),&STR(&JCOTHER1)) \u00ac= &STR(,) -\n      THEN -\n        SET JCOTHER1 = &STR(&JCOTHER1)&STR(,)\n  END\nIF &STR(&JCOTHER2) \u00ac= &Z THEN -\n  DO\n    IF &SUBSTR(&LENGTH(&STR(&JCOTHER2)),&STR(&JCOTHER2)) \u00ac= &STR(,) -\n      THEN -\n        SET JCOTHER2 = &STR(&JCOTHER2)&STR(,)\n  END\nIF &STR(&JCOTHER3) \u00ac= &Z  THEN -\n  DO\n    IF &SUBSTR(&LENGTH(&STR(&JCOTHER3)),&STR(&JCOTHER3)) \u00ac= &STR(,) -\n      THEN -\n        SET JCOTHER3 = &STR(&JCOTHER3)&STR(,)\n  END\nSET JOB1  = &STR(//&JCPRE.&JCSU JOB (&JCACC),'&JCNAME',)\nSET JOBO1 = &STR(//             &JCOTHER1)\nSET JOBO2 = &STR(//             &JCOTHER2)\nSET JOBO3 = &STR(//             &JCOTHER3)\nSET JOB2  = &STR(//             CLASS=&JCCLASS,)\nSET JOB3  = &STR(//             TIME=(&JCTIME),)\nSET JOB4  = &STR(//             NOTIFY=&JCNOTIFY,)\nSET JOB5  = &STR(//             MSGCLASS=&JCMC)\nSET JOB6  = &STR(&STR(/*)JOBPARM R=&JCRM,T=9999,L=9999)\nSET JOB7  = &STR(&STR(/*)ROUTE XEQ   &JCJXEQ)\nSET JOB8  = &STR(&STR(/*)ROUTE PRINT &JCJPRT)\nSET JOB9  = &STR(//JCL      JCLLIB  ORDER=&JCPROC)\nSET JOB10 = &STR(//JOB      OUTPUT  NAME='&JCNAME',)\nSET JOB11 = &STR(//             TITLE='&JCTITLE',)\nSET JOB12 = &STR(//             DEPT='&JCDEPT',)\nSET JOB13 = &STR(//             BUILDING='&JCBLDG',)\nSET JOB14 = &STR(//             ADDRESS=('&JCADDR1',\nSET JOB15 = &STR(//             '&JCADDR2',)\nSET JOB16 = &STR(//             '&JCADDR3',)\nSET JOB17 = &STR(//             '&JCADDR4'))&STR(,)\nSET JOB18 = &STR(//             JESDS=ALL,)\nSET JOB19 = &STR(//             DEFAULT=YES)\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB19\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB18\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB17\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB16\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB15\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB14\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB13\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB12\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB11\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB10\"\n/* CHECK FOR EXISTING JCLLIB IN SKELETON JCL */\nISREDIT FIND FIRST \" JCLLIB \"\nIF &LASTCC \u00ac= 0 && &STR(&JCPROC) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOB9\"\nISREDIT CURSOR = 1 1\nIF &STR(&JCJPRT) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOB8\"\nIF &STR(&JCJXEQ) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOB7\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB6\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB5\"\nIF &STR(&JCNOTIFY) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOB4\"\nIF &STR(&JCTIME) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOB3\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB2\"\nIF &STR(&JCOTHER3) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOBO3\"\nIF &STR(&JCOTHER2) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOBO2\"\nIF &STR(&JCOTHER1) \u00ac= &Z THEN -\n  ISREDIT LINE_BEFORE .ZFIRST = \"&JOBO1\"\nISREDIT LINE_BEFORE .ZFIRST = \"&JOB1\"\n/* RETURN CURSOR TO COMMAND LINE */\nEXIT CODE(1)\n/* J. KALINICH, X4521 */\n/* INITIAL EDIT MACRO TO BUILD JOBCARD SEQUENCE FOR JCL SKELETONS */\n./ ADD NAME=LISTDSI  0119-89306-98188-1424-00051-00031-00000-CLIST\nISREDIT MACRO (DSNAME)\nCONTROL NOMSG MAIN NOLIST NOCONLIST NOSYMLIST ASIS\nIF &DSNAME \u00ac= &STR() THEN -\n  DO\n    IF &SUBSTR(1,&DSNAME) = ' THEN -\n      SET DSNS = &SUBSTR(2:&LENGTH(&DSNAME)-1,&DSNAME)\n    ELSE -\n      SET DSNS = &STR(&SYSUID..&DSNAME)\n  END\nELSE -\n  DO\n    ISREDIT (DSNS) = DATASET\n  END\nLISTDSI '&DSNS' DIRECTORY NORECALL\nSET &LISTCC = &LASTCC\nIF &LISTCC > 0 THEN -\n  DO\n      SET &SYSREASON= &SYSREASON\n      SET &ZEDSMSG = &STR(RC = &LISTCC-&SYSREASON)\n      SET &ZEDLMSG = &STR(&SYSMSGLVL2)\n      ISPEXEC SETMSG MSG(ISRZ001)\n      EXIT CODE(&LISTCC)\n  END\nSET &DSNS    = &STR(&SYSDSNAME)\nSET &ZALVOL  = &STR(&SYSVOLUME)\nSET &DEVT    = &STR(&SYSUNIT)\nSET &DSORG   = &STR(&SYSDSORG)\nSET &ZALRF   = &STR(&SYSRECFM)\nSET &ZALLREC = &STR(&SYSLRECL)\nSET &ZALBLK  = &STR(&SYSBLKSIZE)\nSET &TOTA    = &STR(&SYSALLOC)\nSET &TOTU    = &STR(&SYSUSED)\nSET &ZAL1EX  = &STR(&SYSPRIMARY)\nSET &ZAL2EX  = &STR(&SYSSECONDS)\nSET &ZALSPC  = &STR(&SYSUNITS)\nSET &EXTA    = &STR(&SYSEXTENTS)\nSET &CRDT    = &STR(&SYSCREATE)\nIF &SYSEXDATE = 0 THEN -\n  SET &EXDATE  = &STR(***None***)\nELSE -\n  SET &EXDATE  = &STR(&SYSEXDATE)\nSET &ZALDIR  = &STR(&SYSADIRBLK)\nSET &DIRU    = &STR(&SYSUDIRBLK)\nSET &NRMEM   = &STR(&SYSMEMBERS)\nSET &EXTU    = &STR(N/A)\nISPEXEC ADDPOP\nISPEXEC DISPLAY PANEL(ISRUAIPO)\nISPEXEC REMPOP\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO LISTDSI AND DISPLAY INFO WITH =3.2 PANEL */\n./ ADD NAME=LOGLIST  0102-96026-96029-1012-00029-00027-00000-CLIST\nPROC 0 DEBUG\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT ASIS\nELSE -\n  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST ASIS\nIF &SYSISPF = &STR(NOT ACTIVE) THEN -\n  DO\n    ISPSTART CMD(%LOGLIST) NEWAPPL(ISR)\n    EXIT\n  END\nDO WHILE &DISPCC < 8\n  ISPEXEC DISPLAY PANEL(LOGLIST)\n  SET &DISPCC = &LASTCC\n  IF &SYSINDEX(&STR(can),&ZCMD,1) > 0 OR -\n     &SYSINDEX(&STR(CAN),&ZCMD,1) > 0 THEN -\n    EXIT CODE(12)\nEND\nISPEXEC FTOPEN\nISPEXEC FTINCL LOGLIST\nISPEXEC FTCLOSE NAME(@LOGLIST)\nIF &LASTCC = 0 THEN -\n  DO\n    SET ZEDSMSG = &STR(@LOGLIST UPDATED)\n    SET ZEDLMSG = &STR(REXX EXEC \"@LOGLIST\" UPDATED IN ISPFILE)\n    ISPEXEC SETMSG MSG(ISRZ001)\n  END\nEXIT CODE(0)\n/* J.KALINICH, X4521 */\n/* CLIST TO UPDATE \"@LOGLIST\" REXX EXEC IN THE ISPFILE DATASET    */\n./ ADD NAME=MEMLIST  0107-91301-95278-0659-00087-00103-00000-CLIST\nISREDIT MACRO (FROM,TO)\nCONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\nISREDIT (WORKDSN) = DATASET\nISREDIT (XLINE) = DISPLAY_LINES\nIF &STR(&XLINE) = &STR() THEN -\n  DO\n    SET ZEDSMSG = &STR(EMPTY DATASET)\n    SET ZEDLMSG = &STR(ML COMMAND NOT VALID FOR EMPTY DATASET)\n    ISPEXEC SETMSG MSG(ISRZ001W)\n    EXIT CODE(4)\n  END\nSET &MAX = 1\nSET &Z9 = Z9999999\nIF &FROM = ? THEN DO\n  ISPEXEC DISPLAY PANEL(#MEMLIST)\n  EXIT\nEND\nIF &TO = THEN SET &TO = &Z9\nIF &FROM = THEN -\n  SET &RT = &STR()\nELSE -\n  SET &RT = &STR(FROM &FROM TO &TO)\nSET &TARGET1 = &FROM\nSET T1 = &LENGTH(&TARGET1)\nIF &FROM =  THEN SET &T1 = 8\nSET &TARGET2 = &TO\nSET T2 = &LENGTH(&TARGET2)\nSET PDSDSN = &WORKDSN\n/* INITIALIZE DATASET */\nISPEXEC  LMINIT DATAID(PDSID) DATASET('&PDSDSN') +\n                ENQ(SHRW)                        +\n                ORG(PDSORG)\nSET LMRC = &LASTCC\nIF &LMRC \u00ac= 0 THEN +\n   DO\n     SET ZEDSMSG = &STR(LMINIT FAILED - RETURN CODE &LMRC)\n     SET ZEDLMSG = &STR(DATA SET IS NOT ALLOCATED OR NOT PARTITIONED)\n     ISPEXEC SETMSG MSG(ISRZ001W)\n     EXIT CODE(8)\n   END\n/* OPEN DATA SET */\nISPEXEC LMOPEN DATAID(&PDSID) OPTION(INPUT)\nSET LMRC = &LASTCC\nDO WHILE (&LMRC = 0)\n  /* BUILD MEMBER LIST AND RETURN NEXT MEMBER */\n  ISPEXEC LMMLIST DATAID(&PDSID) -\n    OPTION(LIST) MEMBER(MEMBER) -\n    STATS(NO)\n  SET LMRC = &LASTCC\n  IF &LMRC = 0 THEN /* NOT END OF MEMBER LIST */ +\n    DO\n      IF &SUBSTR(1:&T1,&MEMBER) GE &TARGET1 AND +\n         &SUBSTR(1:&T2,&MEMBER) LE &TARGET2  THEN -\n        DO\n          SET &X = &STR(&&L&MAX)\n          IF &LENGTH(&STR(&X)) > 60 THEN -\n            DO\n              SET &MAX = &MAX + 1\n              SET &L&MAX = &STR()\n              SET &X = &STR(&&L&MAX)\n            END\n          SET &X = &STR(&X)&STR(&MEMBER  )\n          SET &L&MAX = &STR(&X)\n        END\n    END\nEND\nISREDIT LINE_AFTER &XLINE = NOTELINE ' '\n/* SEND OUT IN REVERSE ORDER */\nSET I = &MAX\nDO WHILE (&I > 0)\n  SET X = &STR(&&L&I)\n  ISREDIT LINE_AFTER &XLINE = NOTELINE '&X'\n  SET I = &I - 1\nEND\nISREDIT LINE_AFTER &XLINE = +\n    MSGLINE 'MEMLIST:  &RT'\nISREDIT LINE_AFTER &XLINE = NOTELINE ' '\n/* FREE MEMBER LIST */\nISPEXEC LMMLIST DATAID(&PDSID) OPTION(FREE)\n/* CLOSE DATA SET */\nISPEXEC LMCLOSE DATAID(&PDSID)\n/* FREE DATA ID */\nISPEXEC LMFREE  DATAID(&PDSID)\nEXIT CODE(0)\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO DISPLAY A PDS MEMBER LIST                          */\n/* LSSC MODIFICATION TO CBT FILE 095 - USE =NOTE= INSTEAD OF WRITE  */\n./ ADD NAME=OPER     0128-91087-94062-1314-00044-00038-00000-CLIST\nISREDIT MACRO (PARM) NOPROCESS\n/* SDSF OPERATOR COMMANDS ARE LIMITED TO 42 BYTES */\n/* (ISFPANEL INPUT SIZE)                          */\nCONTROL NOFLUSH NOMSG NOLIST NOCONLIST NOSYMLIST ASIS\nIF &PARM = HELP OR   +\n   &PARM = ?    THEN +\n  DO\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(#OPER)\n    EXIT\n  END\n/* PROCESS LINE COMMANDS, CHECK IF \"C\" WAS SPECIFIED */\nISPEXEC CONTROL ERRORS RETURN\nISREDIT PROCESS RANGE C\nIF &LASTCC > 0 THEN +\n  DO\n    SET ZEDSMSG = &STR(ENTER \"C\" LINE CMD)\n    SET ZEDLMSG = &STR(SDSF OPER REQUIRES A \"Cn\" OR \"CC\" LINE COMMAND)\n    ISPEXEC SETMSG MSG(ISRZ001W)\n    EXIT CODE(12)\n  END\nISREDIT (LINE1) = LINENUM .ZFRANGE   /* FIRST LINE IN RANGE */\nISREDIT (LINE2) = LINENUM .ZLRANGE   /* LAST LINE IN RANGE  */\n/*                                                          */\n/*  )INIT SECTION OF PANEL ISFPANEL HAS BEEN MODIFIED TO    */\n/*  ISSUE .RESP=END IF &SDSFOPER HAS BEEN SET TO 'END'      */\n/*  BY THIS EDIT MACRO.  CAUSES SDSF PANEL NOT TO DISPLAY   */\n/*  AFTER EACH OPERATOR COMMAND HAS BEEN ISSUED.            */\n/*                                                          */\nSET &SDSFOPER = &STR(END)\nISPEXEC VPUT (SDSFOPER) SHARED\n/* PASS THE COMMAND LINES TO SDSF */\nSET I = &LINE1\nDO WHILE &I <= &LINE2\n  ISREDIT (SDSFCMD) = LINE &I\n  /* IF NO '/' IN COLUMN 1, THEN ADD ONE FOR SDSF */\n  IF &SUBSTR(1:1,&SDSFCMD) \u00ac= &STR(/) THEN -\n    SET &SDSFCMD = &STR(/)&STR(&SDSFCMD)\n  ISPEXEC SELECT PGM(ISFISP) PARM(&STR(&SDSFCMD))\n  /* LEAVE OUT NEWAPPL(ISF) OR SDSFOPER VARIABLE NOT PASSED */\n  SET I = &I + 1\nEND\nEXIT CODE(1)  /* RETURN CURSOR TO COMMAND LINE */\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO PASS MVS/JES2 OPERATOR COMMANDS TO SDSF */\n./ ADD NAME=RUN      0168-90310-96047-0737-00078-00008-00000-CLIST\nISREDIT MACRO (PARM) NOPROCESS\nCONTROL NOMSG NOLIST NOCONLIST NOSYMLIST ASIS\nISPEXEC CONTROL DISPLAY LINE START(23)\nISREDIT (DSN) =  DATASET\n\n/* CHECK DSNAME EXTENSION FOR CLIST/EXEC TYPE        */\nIF &SUBSTR(&LENGTH(&STR(&DSN))-4:+\n  &LENGTH(&STR(&DSN)),&STR(&DSN)) = &STR(.EXEC) THEN -\n    SET &TYPE = &STR(EXEC)\nIF &SUBSTR(&LENGTH(&STR(&DSN))-4:+\n  &LENGTH(&STR(&DSN)),&STR(&DSN)) = &STR(.REXX) THEN -\n    SET &TYPE = &STR(EXEC)\nIF &SUBSTR(&LENGTH(&STR(&DSN))-5:+\n  &LENGTH(&STR(&DSN)),&STR(&DSN)) = &STR(.CLIST) THEN -\n    SET &TYPE = &STR(CLIST)\n\nISREDIT (LINE1) = LINE 1\n\n/* CHECK FOR \"//\" TO SEE IF THEY MEANT \"GO\"          */\nIF &SUBSTR(1:2,&STR(&LINE1)) = &STR(//) THEN -\n  DO\n    ISREDIT SUBMIT\n    ISPEXEC SELECT PGM(IOFSPF) NEWAPPL(IOF) PASSLIB\n    EXIT CODE(4)\n  END\n\n/* CHECK LINE 1 FOR REXX IDENTIFIER                  */\nIF &SYSINDEX(&STR(REXX),&STR(&LINE1),3) > 0 OR -\n   &SYSINDEX(&STR(Rexx),&STR(&LINE1),3) > 0 OR -\n   &SYSINDEX(&STR(rexx),&STR(&LINE1),3) > 0 THEN -\n  SET &TYPE = &STR(EXEC)\n\n/* PROCESS LINE COMMANDS, CHECK IF \"C\" WAS SPECIFIED */\nISPEXEC CONTROL ERRORS RETURN\nISREDIT PROCESS RANGE C\nIF &LASTCC > 0 THEN -\n  ISREDIT (MEM) =  MEMBER\nELSE -\n  DO\n    ISREDIT (MEM) =  MEMBER\n    IF &STR(&MEM) = &STR() THEN -\n      DO\n        SET ZEDSMSG = &STR(DSORG=PS)\n        SET ZEDLMSG = &STR(CAN NOT BUILD A PDS MEMBER)\n        ISPEXEC SETMSG MSG(ISRZ001W)\n        EXIT CODE(12)\n      END\n    IF &LENGTH(&SYSUID) > 6 THEN -\n      SET &UID = &SUBSTR(1:6,&SYSUID)\n    ELSE -\n      SET &UID = &STR(&SYSUID)\n    ISREDIT REPLACE @&UID.@ .ZFRANGE .ZLRANGE\n    SET MEM = &STR(@&UID.@)\n  END\n\nIF &STR(&PARM) = &STR() THEN -\n  DO\n    IF &STR(&MEM) = &STR() THEN -\n      EXEC '&DSN' &TYPE\n    ELSE -\n      EXEC '&DSN.(&MEM)' &TYPE\n  END\nELSE -\n  DO\n    IF &STR(&MEM) = &STR() THEN -\n      EXEC '&DSN' '&PARM' &TYPE\n    ELSE -\n      EXEC '&DSN.(&MEM)' '&PARM' &TYPE\n  END\n\nSET &RC = &LASTCC\nSET ZEDSMSG = &STR(&TYPE ENDED)\nSET ZEDLMSG = &STR(&TYPE '&MEM' ENDED WITH RETURN CODE &RC)\nISPEXEC SETMSG MSG(ISRZ001W)\n\nEXIT CODE(1)                   /* RETURN CURSOR TO COMMAND LINE */\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO 'EXECute' THE CLIST CURRENTLY BEING EDITED  */\n./ ADD NAME=SHOWCUT  0120-90282-98168-0749-00023-00015-00000-CLIST\nISREDIT MACRO (PARM) NOPROCESS\nCONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\nISPEXEC VGET (CUTNAME) PROFILE\nSET CT = &CUTNAME\nIF &LENGTH(&STR(&PARM)) > 0 THEN -\n  SET CT = &PARM\nSET CUTPST = CUTPST&CT\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBOPEN &CUTPST NOWRITE SHARE\nIF &LASTCC \u00ac= 0 THEN -\n  DO\n    SET ZEDSMSG = &STR(CUT TABLE NOT FOUND)\n    SET ZEDLMSG = &STR(CUT TABLE '&CT' DOES NOT EXIST)\n    ISPEXEC SETMSG MSG(ISRZ001)\n    EXIT CODE(12)\n  END\nISPEXEC TBTOP  &CUTPST\nDO WHILE &RC < 8\n  ISPEXEC TBDISPL &CUTPST PANEL(SHOWCUTP)\n  SET RC = &LASTCC\nEND\n/* J. KALINICH, X4521 */\n/* MACRO TO DISPLAY THE PDS 8.5 CUT (EDIT) TABLES       */\n./ ADD NAME=STARTUP  0102-95195-95212-0957-00033-00028-00000-CLIST\nPROC  0\nCONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\n\nIF &STR(&SYSDSN(ISPPROF)) = &STR(OK) THEN -\n  ALLOC F(ISPPROF) DA(ISPPROF) SHR REUSE\nELSE -\n  DO\n    ALLOC F(ISPPROF) DA(ISPPROF) TRACKS SP(5 5) -\n      DIR(5) NEW CATALOG UNIT(PERM) -\n      RECFM(F B) LRECL(80) BLKSIZE(6240)\n  END\n\nIF &STR(&SYSDSN(GEN.CNTL)) = &STR(OK) THEN -\n  ALLOC F(ISPFILE) DA(GEN.CNTL) SHR REUSE\nELSE -\n  DO\n    ALLOC F(ISPFILE) DA(GEN.CNTL) TRACKS SP(5 5) -\n      DIR(5) NEW CATALOG UNIT(PERM) -\n      RECFM(F B) LRECL(80) BLKSIZE(6240)\n  END\n\nIF &STR(&SYSDSN(GEN.CNTL(@LOGLIST))) = &STR(OK) THEN -\n  EXEC '&SYSUID..GEN.CNTL(@LOGLIST)' EXEC\nELSE -\n  DO\n    ALLOC F(ISPLIST) SYSOUT(R) HOLD -\n      LRECL(121) BLKSIZE(1210) RECFM(F B A)\n    ALLOC F(ISPLOG)  SYSOUT(R) HOLD -\n      LRECL(125) BLKSIZE(129) RECFM(V A)\n  END\n\n/* ISPF PROFILE, FILE TAILORING, LOG, LIST ALLOCATION     */\n/* OPERATING SYSTEMS BRANCH 7/14/95                       */\n./ ADD NAME=SUPERC   0105-91143-92358-0831-00096-00089-00000-CLIST\nPROC 0 DEBUG\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT\nELSE -\n  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\nPANEL: +\nISPEXEC DISPLAY PANEL(ISRSFSPR)\nIF &LASTCC = 8 THEN EXIT\nIF &STR(&ZSSFNDSN) = &STR() THEN -\n  SET &NEWDD = &ZSSFNPRJ..&ZSSFNGR1..&ZSSFNTYP\nELSE -\n  DO\n    IF &SUBSTR(1,&ZSSFNDSN) = &STR(') THEN -\n      SET &NEWDD = &STR(&ZSSFNDSN)\n    ELSE -\n      SET &NEWDD = &STR(&SYSUID..&ZSSFNDSN)\n    /* STRIP OUT (*) IF ENTERED WITH OTHER DSNAME               */\n    IF &SUBSTR(&LENGTH(&STR(&NEWDD))-3:+\n       &LENGTH(&STR(&NEWDD)),&STR(&NEWDD)) = &STR((*)') THEN -\n      SET &NEWDD = &SUBSTR(2:&LENGTH(&STR(&NEWDD))-4,&STR(&NEWDD))\n    IF &SUBSTR(&LENGTH(&STR(&NEWDD))-2:+\n       &LENGTH(&STR(&NEWDD)),&STR(&NEWDD)) = &STR((*)) THEN -\n      SET &NEWDD = &SUBSTR(1:&LENGTH(&STR(&NEWDD))-3,&STR(&NEWDD))\n  END\nIF &ZSSFNVOL = &STR() THEN -\n  SET &NEWVOL = &STR()\nELSE -\n  SET &NEWVOL = &STR(,VOL=SER=&ZSSFNVOL,UNIT=SYSALLDA)\nIF &ZSSFMULT = &STR(YES) THEN -\n  DO\n    ISPEXEC DISPLAY PANEL(ISRSFSST)\n    IF &LASTCC = 8 THEN GOTO PANEL\n  END\nSET I = 1\nDO WHILE &I <= 10\n  SET &SRCH&I = &STR()\n  SET &SFS = &&ZSSFS&I\n  IF &STR(&SFS) \u00ac= &STR() THEN -\n    DO\n      IF &SUBSTR(1:1,&STR(&SFS)) \u00ac= &STR(') THEN -\n        DO\n          IF &LENGTH(&STR(&SFS)) > 5 THEN -\n            DO\n              IF &SUBSTR(&LENGTH(&STR(&SFS))-4:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( WORD) THEN -\n                SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-3,&STR(&SFS))\n            END\n          IF &LENGTH(&STR(&SFS)) > 7 THEN -\n            DO\n              IF &SUBSTR(&LENGTH(&STR(&SFS))-6:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( PREFIX) THEN -\n                SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-5,&STR(&SFS))\n            END\n          IF &LENGTH(&STR(&SFS)) > 7 THEN -\n            DO\n              IF &SUBSTR(&LENGTH(&STR(&SFS))-6:+\n                 &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( SUFFIX) THEN -\n                SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-5,&STR(&SFS))\n            END\n          IF &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( C) OR -\n             &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( P) OR -\n             &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( S) OR -\n             &SUBSTR(&LENGTH(&STR(&SFS))-1:+\n                     &LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR( W) THEN -\n            DO\n              SET &SFS = &STR(')+\n                         &SUBSTR(1:&LENGTH(&STR(&SFS))-2,&STR(&SFS))+\n                         &STR(',)+\n                         &SUBSTR(&LENGTH(&STR(&SFS)),&STR(&SFS))\n            END\n          ELSE -\n            SET &SFS = &STR('&STR(&SFS)')\n        END\n      IF &SUBSTR(&LENGTH(&STR(&SFS)),&STR(&SFS)) = &STR(C) THEN -\n        DO\n          SET &SFS = &SUBSTR(1:&LENGTH(&STR(&SFS))-2,&STR(&SFS))\n          SET &SRCH&I = &STR(SRCHFORC)\n        END\n      ELSE -\n        DO\n          SET &SRCH&I = &STR(SRCHFOR)\n        END\n      SET &SFS&I = &STR(&SFS)\n    END\n  SET I = &I + 1\nEND\nISPEXEC FTOPEN\nISPEXEC FTINCL SUPERC\nISPEXEC FTCLOSE NAME(SUPERC)\n/* INVOKE INITIAL JOBCARD MACRO AND PUT USER IN EDIT */\nISPEXEC EDIT DATASET(GEN.CNTL(SUPERC)) MACRO(JCI)\n/* J. KALINICH, X4521 */\n/* CLIST TO CREATE JCL TO RUN OPTION 3.14 SEARCH-FOR IN BATCH     */\n./ ADD NAME=SYSLOG   0130-90291-99067-0829-00074-00012-00000-CLIST\nPROC 0 DEBUG PARM()\nIF &DEBUG = &STR(DEBUG) THEN -\n  CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT\nELSE -\n  CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST ASIS\n/* DAY OF WEEK:  \"ALL\" OR \"MON-SUN\" ENTERED ON SYSLOG COMMAND ? */\nIF &STR(&PARM) = &STR(ALL) THEN -\n  DO\n    ISPEXEC SELECT PGM(IOFSPF) +\n      PARM(.SLAMMEMO GROUP .EXCLUDE WTRID NC 0000 +\n           .RIGHT 90 .SORT PRMODE) +\n      NEWAPPL(IOF) PASSLIB\n      EXIT\n  END\nIF &STR(&PARM) = &STR(MON) OR -\n   &STR(&PARM) = &STR(TUE) OR -\n   &STR(&PARM) = &STR(WED) OR -\n   &STR(&PARM) = &STR(THU) OR -\n   &STR(&PARM) = &STR(FRI) OR -\n   &STR(&PARM) = &STR(SAT) OR -\n   &STR(&PARM) = &STR(SUN) THEN -\n  DO\n    /* WE ARE SAVING 2 WEEKS WORTH OF SLAMMEMOS,     */\n    /* SO \"2 VIEW\" SELECTS THE DAY FROM THE 2ND WEEK */\n    ISPEXEC SELECT PGM(IOFSPF) +\n      PARM(.SLAMMEMO GROUP .EXCLUDE UCS NC &PARM +\n           .RIGHT 90 .2 VIEW .TOP) +\n      NEWAPPL(IOF) PASSLIB\n      EXIT\n  END\nDO WHILE &LOGCC < 8\n  ISPEXEC DISPLAY PANEL(SYSLOG)\n  SET &LOGCC = &LASTCC\n  IF &LOGCC = 8 THEN EXIT\n  IF &STR(&LOGDAY) = &STR(*) THEN -\n    DO\n      IF &STR(&LOGPGM) = &STR(IOF) THEN -\n        DO\n          ISPEXEC CONTROL DISPLAY LOCK\n          SET ZEDSMSG = &STR(USE \"#\" FOR MVS COMMANDS)\n          ISPEXEC DISPLAY MSG(ISRZ001W)\n          ISPEXEC SELECT PGM(IOFSPF) +\n            PARM(.L) NEWAPPL(IOF) PASSLIB\n        END\n      ELSE -\n        DO\n          ISPEXEC CONTROL DISPLAY LOCK\n          SET ZEDSMSG = &STR(USE \"/\" FOR MVS COMMANDS)\n          ISPEXEC DISPLAY MSG(ISRZ001W)\n          ISPEXEC SELECT PGM(ISFISP) PARM('LOG') NEWAPPL(ISF) PASSLIB\n        END\n    END\n  ELSE -\n    DO\n      IF &LOGDAY = &STR(ALL) THEN -\n        DO\n          ISPEXEC SELECT PGM(IOFSPF) +\n            PARM(.SLAMMEMO GROUP .EXCLUDE WTRID NC 0000 +\n                 .RIGHT 90 .SORT PRMODE) +\n            NEWAPPL(IOF) PASSLIB\n        END\n      ELSE -\n        DO\n          /* WE ARE SAVING 2 WEEKS WORTH OF SLAMMEMOS,     */\n          /* SO \"2 VIEW\" SELECTS THE DAY FROM THE 2ND WEEK */\n          ISPEXEC SELECT PGM(IOFSPF) +\n            PARM(.SLAMMEMO GROUP .EXCLUDE UCS NC &LOGDAY +\n                 .RIGHT 90 .2 VIEW .TOP) +\n            NEWAPPL(IOF) PASSLIB\n        END\n    END\nEND\n/* J.KALINICH, X4521 */\n/* CLIST TO VIEW IOF SLAM MEMOS OR CURRENT SYSLOG VIA SDSF OR IOF */\n./ ADD NAME=UNX      0106-92349-93007-1343-00054-00029-00000-CLIST\nISREDIT MACRO (NLINES)\n/*\n/* UNX EDIT MACRO - SHOW FIRST N LINES OF EACH 'X-CLUDED' BLOCK\n/*                  IN THE MEMBER\n/*                  DEFAULT = 1 LINE\n/*\nCONTROL NOFLUSH NOMSG NOLIST NOCONLIST NOSYMLIST\nIF &NLINES = HELP OR -\n   &NLINES = ?  THEN -\n  DO\n    ISPEXEC SELECT PGM(ISPTUTOR) PARM(#UNX)\n    EXIT\n  END\nIF &NLINES = &STR() THEN -\n  SET &NLINES = 1\nISPEXEC CONTROL ERRORS RETURN\nSET &RC  = 0\nSET &LINE = 1\nDO WHILE &RC < 12\n  ISREDIT (XSTATUS) = XSTATUS &LINE\n  SET &RC = &LASTCC\n  IF &RC = 12 THEN -\n    EXIT\n  IF &XSTATUS = &STR(X) THEN -\n    DO\n      SET &XLINES = 0\n      DO WHILE &XLINES < &NLINES\n        ISREDIT (XSTATUS) = XSTATUS &EVAL(&LINE+&XLINES)\n        SET &RC = &LASTCC\n        IF &RC = 12 THEN -\n          EXIT\n        ISREDIT XSTATUS &EVAL(&LINE+&XLINES) = NX\n        SET &RC = &LASTCC\n        IF &RC = 12 THEN -\n          EXIT\n        SET &XLINES = &XLINES + 1\n      END\n      SET &LINE = &LINE + &EVAL(&NLINES)\n      DO WHILE &XSTATUS = &STR(X)\n        ISREDIT (XSTATUS) = XSTATUS &LINE\n        SET &RC = &LASTCC\n        IF &RC = 12 THEN -\n          EXIT\n        SET &LINE = &LINE + 1\n      END\n    END\n  ELSE -\n    SET &LINE = &LINE + 1\nEND\nISREDIT LOCATE 0\nEXIT CODE(1)  /* RETURN CURSOR TO COMMAND LINE */\nEND\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO SHOW FIRST N LINES IN EACH 'X-CLUDED' BLOCK    */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDS": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x93)\\x1f\\x00\\x97\\x05o\\x08X\\x00N\\x00?\\x00\\x00\\xe3\\xc2\\xd3@@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1993-10-18T00:00:00", "modifydate": "1997-02-25T08:58:00", "lines": 78, "newlines": 63, "modlines": 0, "user": "TBL"}, "text": "1.  Add the following commands to the ISPF command table, ISPCMDS:\n\nVERB      T  ACTION\n                DESCRIPTION\n\nCALC      0  SELECT CMD(%COMPUTE &ZPARM)\n                REXX CALCULATOR - TSO TIMES (tm)\nCLONEID   5  SELECT CMD(%CLONEID &ZPARM)\n                DECOMP LOGONID INTO \"INSERT\" FORMAT FOR CLONING\nCOMMANDS  0  SELECT PGM(ISPTUTOR) PARM(TRICMDS)\n                DISPLAY EXPLANATIONS OF LSSC ADDED ISPF COMMANDS\nEBROWSE   2  SELECT CMD(%EB) NEWAPPL(ISR) PASSLIB\n                EDIT/BROWSE BY THE NUMBERS\nJOBS      2  SELECT PANEL(TRIJOBS) OPT(&ZPARM) ADDPOP\n                DISPLAY AMXSI-TRI KEY JOBS\nMACROS    0  SELECT PGM(ISPTUTOR) PARM(TRIMACS)\n                DISPLAY EXPLANATIONS OF LSSC EDIT MACROS\nRESETID   0  SELECT CMD(%RESETID &ZPARM)\n                REDUCE ACF2 PASSWORD VIOLATION COUNT BY 1\nLOGLIST   0  SELECT CMD(%LOGLIST)\n                OUTPUT DESCRIPTOR FOR ISPLOG AND ISPLIST SYSOUT DATASETS\nSPACE     0  SELECT CMD(%DVOL)\n                DISPLAY DASD FREE SPACE STATISTICS\nSYSLOG    0  SELECT CMD(%SYSLOG PARM('&ZPARM'))\n                DISPLAY SYSLOG SLAM MEMOS OR CURRENT SYSLOG\nTRAP      0  SELECT CMD(%TRAPCMD &ZPARM)\n                TRAP TSO COMMAND/REXX EXECS AND DISPLAY IN ISPF TABLE\n\n2.  Other commands that could be added to ISPCMDS:\n\nVERB      T  ACTION\n                DESCRIPTION\n\nCODE      0  SELECT CMD(HELP ABEND OPERAND(S&ZPARM))\n                DISPLAY HELP ON Sxxx ABEND CODE  (ABEND, CBT File 134)\nIOF       0  SELECT PGM(IOFSPF) PARM(&ZPARM.*) NEWAPPL(IOF) PASSLIB\n                JES2 INTERACTIVE OUTPUT FACILITY (c)\nMSG       0  SELECT CMD(SEND &ZPARM)\n                TSO SEND COMMAND\nOFF       0  SELECT PGM(ISPOPI) PARM(OFF) NOFUNC\n                PANELID OFF\nON        0  SELECT PGM(ISPOPI) PARM(ON) NOFUNC\n                PANELID ON\nPRIM      0  SELECT PANEL(ISR@PRIM) NEWAPPL(ISR) OPT(&ZPARM) PASSLIB\n                HOLD AT CURRENT SCREEN AND DISPLAY PRIMARY MENU\nSDSF      0  SELECT PGM(ISFISP) PARM(&ZPARM) NEWAPPL(ISF) PASSLIB\n                JES2 SYSTEM DISPLAY AND SEARCH FACILITY (c)\nISF       0  SELECT PGM(ISFISP) PARM(&ZPARM) NEWAPPL(ISF) PASSLIB\n                MUCH EASIER THAN TYPING IN \"SDSF\"\nTEST      0  SELECT PGM(ISPYXDR) PARM(&ZPARM)\n                INVOKE ISPF 3.3 DIALOG TEST (ISRYXDR in ISPF 2.3)\nUSERIDS   4  SELECT CMD(%BROWZE DATASET(TRCASG.AS7USELG) PANEL(CUSTOM))\n                DISPLAY TSO USERID/NAME LIST\n\n3.  Examples of use:\n\nCOMMAND ===> test;1                Invoke Dialog Test FUNCTIONS\nCOMMAND ===> test;2                Invoke Dialog Test PANELS\nCOMMAND ===> test ISR;3            Invoke Dialog Test VARIABLES (Applid:  ISR)\nCOMMAND ===> test;1;:isr@test      Invoke Dialog Test FUNCTIONS - ISR@TEST panel\nCOMMAND ===> test;2;:trijobs       Invoke Dialog Test PANELS - Display TRIJOBS\nCOMMAND ===> test;3;;l zjdate      Invoke Dialog Test VARIABLES - Locate ZJDATE\nCOMMAND ===> iof                   Invoke IOF for your jobs\nCOMMAND ===> iof .                 Invoke IOF Option Menu\nCOMMAND ===> iof . tri             Invoke IOF for TRI* jobs\nCOMMAND ===> sdsf                  Invoke SDSF Primary Option Menu\nCOMMAND ===> sdsf /s xdccdf        Invoke SDSF and start system task\nCOMMAND ===> sdsf da otsu          Invoke SDSF and display active tso users\nCOMMAND ===> sdsf log              Invoke SDSF and display system log\nCOMMAND ===> prim                  Invoke ISPF Primary Option Menu\nCOMMAND ===> prim 3.4              Invoke ISPF Option 3.4\nCOMMAND ===> code 106-0f           Invoke TSO HELP ABEND on code 106-0F\nCOMMAND ===> msg '1,2,3...' u(*)   Invoke TSO SEND to send message to user\nCOMMAND ===> jo c                  Invoke IOF/SDSF to display CICS jobs\nCOMMAND ===> calc                  Invoke REXX pop-up calculator\nCOMMAND ===> resetid tridjk        Invoke SDSF to reduce ACF2 \"PSWD-VIO\" count\nCOMMAND ===> syslog wed            Invoke IOF to display Wednesday's SLAM memos\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MESSAGES": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x10/\\x00\\x99\\x10/\\t)\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd4\\xe2\\xc7@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-04-12T00:00:00", "modifydate": "1999-04-12T09:29:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "MSG"}, "text": "./ ADD NAME=EB00     0112-89240-95069-0835-00016-00012-00000-MSG\nEB001 '&MEMBER NOT FOUND'           .ALARM = YES\n'MEMBER &MEMBER NOT FOUND IN &DSNAME'\nEB002 'SORRY CHARLIE'\n'THIS DIALOG ONLY WORKS IF YOUR NAME ISN''T CHARLIE'\nEB003 'INVALID VALUE'               .ALARM = YES\n'E = EDIT, B = BROWSE, LE = LIBEDIT, LB = LIBROWSE, PDS = PDS, V = VIEW'\nEB004 'DEFAULTS CHANGED'\n'DEFAULT LIBRARIES AND MODES HAVE BEEN CHANGED'\nEB005 'DATASET NOT FOUND'           .ALARM = YES\n'DATASET NUMBER &INDX DOES NOT EXIST OR IS NOT CATALOGED'\nEB006 '&MEMBER IN USE'              .ALARM = YES\n'MEMBER &MEMBER IS BEING UPDATED BY YOU OR ANOTHER USER'\nEB007 'NO MEMBERS'                  .ALARM = YES\n'NO MEMBERS MATCHED PATTERN OR NO MEMBERS IN PDS'\nEB008 'SEVERE ERROR'                .ALARM = YES\n'RECFM/LRECL OK?  PATTERN OK?  DATASET CATALOGED?  DATASET ARCHIVED?'\n./ ADD NAME=ISRZ00   0100-93312-93312-0653-00008-00008-00000-MSG\n/* Requires ISPF 3.x to use .WINDOW parameter */\n/* Add these to member ISRZ00 in message lib  */\n\nISRZ000W '&ZEDSMSG'  .ALARM = NO   .HELP = ISR2MACR  .WINDOW = NORESP\n'&ZEDLMSG'\n\nISRZ001W '&ZEDSMSG'  .ALARM = YES  .HELP = ISR2MACR  .WINDOW = NORESP\n'&ZEDLMSG'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MVS": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93)\\x1f\\x00\\x94\\x11\\x8f\\x07\\x01\\x00f\\x00c\\x00\\x00\\xc2\\xc1\\xe2@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-10-18T00:00:00", "modifydate": "1994-04-28T07:01:00", "lines": 102, "newlines": 99, "modlines": 0, "user": "BAS"}, "text": "1 REM Many of the lines in this Basic program are folded. You have to\n     unfold them.  It should be obvious how they are folded (at col 80).\n2 ' Le Menu de TRI\n4  DIM NUMDAYS(12):GOSUB 500\n6  KEY OFF:CLS:COLOR 10,0\n8  LOCATE 1,2:PRINT    \"  System  Spool  DBMS  Calendar  Help  Info\n    PIE session:  1    \"\n10 COLOR 2,0:LOCATE 1,62:PRINT \"PIE session:\"\n14 LOCATE 2,2:PRINT    \"--------------------------------------------------------\n-----------------------\"\n16 COLOR 10,0\n20 LOCATE 3,2:PRINT    \"                       ISPF/PDF 3.3 PRIMARY OPTION MENU\n                       \"\n30 LOCATE 4,2:PRINT    \"OPTION  ===>\n                       \"\n40 COLOR 2,0\n50 LOCATE 5,2:PRINT    \"\n    USERID   - TRIDJK  \"\n60 LOCATE 6,2:PRINT    \"   0  ISPF PARMS  - Specify terminal and user parameters\n    PROC     - $LOGDED \"\n70 LOCATE 7,2:PRINT    \"   1  BROWSE      - Display source data or output listin\ngs  TIME     - 00:00   \"\n80 LOCATE 8,2:PRINT    \"   2  EDIT        - Create or change source data\n    JULIAN   - 00.000  \"\n90 LOCATE 9,2:PRINT    \"   3  UTILITIES   - Perform utility functions\n    MVS      - SP 4.3.0\"\n100 LOCATE 10,2:PRINT  \"   6  COMMAND     - Enter TSO command, CLIST, or REXX ex\nec  TSO/E    - 2.4.0   \"\n110 LOCATE 11,2:PRINT  \"   7  DIALOG TEST - Perform dialog testing\n    SYSTEM   - A1VS    \"\n121 LOCATE 12,2:PRINT  \"   D  XDC         - Interactive debugging with XDC\n                       \"\n130 LOCATE 13,2:PRINT  \"   E  EDIT/BROWSE - Edit/Browse by the numbers from a me\nnu of datasets         \"\n140 LOCATE 14,2:PRINT  \"   L  LIBRARIAN   - ADR/The Librarian options menu\n                       \"\n150 LOCATE 15,2:PRINT  \"   M  MENU        - Information Technology (AMXSI-TRI) A\npplication Menu        \"\n160 LOCATE 16,2:PRINT  \"   O  OUTPUT      - Output display utilities (IOF and SD\nSF)                    \"\n170 LOCATE 17,2:PRINT  \"   P  PDS         - Invoke the PDS command processor\n                       \"\n180 LOCATE 18,2:PRINT  \"   T  TUTORIAL    - Display information about ISPF/PDF\n                       \"\n190 LOCATE 19,2:PRINT  \"   W  WHAT'S NEW  - Historical review of AMXSI-TRI ISPF/\nPDF extensions         \"\n200 LOCATE 20,2:PRINT  \"   X  EXIT        - Terminate ISPF using log and list de\nfaults                 \"\n210 LOCATE 21,2:PRINT  \"\n                       \"\n220 LOCATE 22,2:PRINT  \"Enter END command to terminate ISPF.\n                       \";\n225 ' High intensity fields\n230 COLOR 10,0:LOCATE 11,73:PRINT \"A1VS\"\n240 COLOR 10,0:LOCATE 19,15:PRINT \"NEW\"\n250 COLOR 10,0:LOCATE 22,8:PRINT  \"END\";\n260 COLOR 10,0:LOCATE  6,2:PRINT  \"   0\"\n270 COLOR 10,0:LOCATE  7,2:PRINT  \"   1\"\n280 COLOR 10,0:LOCATE  8,2:PRINT  \"   2\"\n290 COLOR 10,0:LOCATE  9,2:PRINT  \"   3\"\n300 COLOR 10,0:LOCATE 10,2:PRINT  \"   6\"\n310 COLOR 10,0:LOCATE 11,2:PRINT  \"   7\"\n321 COLOR 10,0:LOCATE 12,2:PRINT  \"   D\"\n330 COLOR 10,0:LOCATE 13,2:PRINT  \"   E\"\n340 COLOR 10,0:LOCATE 14,2:PRINT  \"   L\"\n350 COLOR 10,0:LOCATE 15,2:PRINT  \"   M\"\n360 COLOR 10,0:LOCATE 16,2:PRINT  \"   O\"\n370 COLOR 10,0:LOCATE 17,2:PRINT  \"   P\"\n380 COLOR 10,0:LOCATE 18,2:PRINT  \"   T\"\n390 COLOR 10,0:LOCATE 19,2:PRINT  \"   W\"\n400 COLOR 10,0:LOCATE 20,2:PRINT  \"   X\"\n410 COLOR 2,0:LOCATE 7,73:PRINT MID$(TIME$,1,5)\n415 COLOR 2,0:LOCATE 8,73:PRINT USING \"##.###\";YY+(NUMDAYS(MM)+DD)/1000\n420 OPEN \"COM1:9600\" FOR OUTPUT AS #1     ' 9600 baud\n425 ' PF3 to exit\n430 KEY OFF:KEY (3) ON:ON KEY (3) GOSUB 490\n440 FOR DELAY=1 TO 30000!     ' Loop for about 15 seconds (on a 386/25mHz box)\n445 LOCATE 4,15               ' put cursor on OPTION  ===> _\n450 NEXT DELAY\n460 PRINT #1,CHR$(13)         ' Carriage return (ENTER key)\n465 ' Almost real-time update of time/date\n467 GOSUB 500\n470 COLOR 2,0:LOCATE 7,73:PRINT MID$(TIME$,1,5)\n475 COLOR 2,0:LOCATE 8,73:PRINT USING \"##.###\";YY+(NUMDAYS(MM)+DD)/1000\n480 GOTO 440\n490 CLS:SYSTEM\n500 ' Julian date subroutine\n510 MM = VAL(MID$(DATE$,1,2))\n520 DD = VAL(MID$(DATE$,4,2))\n530 YY = VAL(MID$(DATE$,9,2))\n535 YYYY = VAL(MID$(DATE$,7,4))\n540 FOR MON = 1 TO 12\n550 READ NUMDAYS(MON)\n560 NEXT MON\n570 ' Test for leap year:  /4 or /400 = leap, /100 = non-leap\n580 IF  (YYYY - INT(YYYY/4)*4)     = 0 THEN LEAP$ = \"Y\"\n590 IF  (YYYY - INT(YYYY/100)*100) = 0 THEN LEAP$ = \"N\"\n600 IF  (YYYY - INT(YYYY/400)*400) = 0 THEN LEAP$ = \"Y\"\n610 IF MM > 2 AND LEAP$ = \"Y\" THEN DD = DD + 1\n620 RESTORE:RETURN\n630 DATA 000,031,059,090,120,151\n640 DATA 181,212,243,273,304,334\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PANELS": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x10/\\x00\\x99\\x10/\\t)\\x08\\x13\\x08\\x13\\x00\\x00\\xd7\\xc1\\xd5@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-04-12T00:00:00", "modifydate": "1999-04-12T09:29:00", "lines": 2067, "newlines": 2067, "modlines": 0, "user": "PAN"}, "text": "./ ADD NAME=#ACFCOMP 0111-89305-96257-1013-00011-00018-00000-PANEL\n%TUTORIAL ---------------- EDIT - 'ACFCOMP' MACRO --------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n The%ACFCOMP+macro will invoke ACF2 and automatically compile and store the\n rule you were editing.  ACF2 displays the complilation process.  If the rule\n is an access rule and is a resident access rule, a \"F ACF2,RELOAD(rule)\"\n operator command is issued.  If the rule is a resource rule and the directory\n is a resident directory, a \"F ACF2,REBUILD(directory)\" operator command is\n issued.  The user is returned to the EDIT display panel.\n\n)END\n./ ADD NAME=#ACFTRAP 0125-89305-96219-0632-00045-00018-00000-PANEL\n)ATTR\n  # AREA(SCRL) EXTEND(ON)\n)BODY\n%TUTORIAL --------------- EDIT - 'ACFTRAP' MACRO ---------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%ACFTRAP+macro is used to queue ACF subcommands for the ACF command\n processor.  A pseudo /%swaydo+/ command prompt of%ACF.+will be displayed\n during the queueing process.  Enter%END+to execute the subcommands.\n\n+Use:\n Type%ACFTRAP {NOTE|DATA}+on the command line.  If%NOTE+is specified, then the\n output will be returned as =NOTE= lines.  If%DATA+is specified, then the\n output will be returned as lines of data.\n#ACFAREA ----------------------------------------------------------------------#\n)AREA ACFAREA\n%EDIT ---- SK4.CMDS(AWS) - 01.09 ------------------------------- COLUMNS 001 072\n%COMMAND ===> acftrap note                                      SCROLL ===> CSR\n\n% ACF.+\n+show mode\n% ACF.+\n+set terse\n% ACF.+\n+list -\n+  if(nosuspend tso) -\n+  like(ttsm-)\n% ACF.+\n+end\n\n%EDIT ---- SK4.CMDS(AWS) - 01.09 ------------------------------- COLUMNS 001 072\n%COMMAND ===>                                                   SCROLL ===> CSR\n%After +***************************** TOP OF DATA ******************************\n%==MSG> ACF INPUT+\n%=NOTE=+show mode\n%=NOTE=+set terse\n%=NOTE=+list -\n%=NOTE=+  if(nosuspend tso) -\n%=NOTE=+  like(ttsm-)\n%==MSG> ACF OUTPUT+\n%=NOTE=+MODE: ACF\n%=NOTE=+\n%=NOTE=+ TTSMX1               AMVSHVYTTSMX1           FIRECALL 1           4892\n%=NOTE=+ TTSMX2               AMVSHVYTTSMX2           FIRECALL 2           4055\n)END\n./ ADD NAME=#ASA2PC  0108-89305-96080-1442-00024-00018-00000-PANEL\n%TUTORIAL ----------------- EDIT - 'ASA2PC' MACRO --------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%ASA2PC+macro is used to convert ANSI-defined printer control characters\n (RECFM=**A) to ASCII control character representations.  Page breaks and\n line spacing are preserved after downloading the print file.\n\n+Use:\n+Type%ASA2PC+on the command line\n+\n%EDIT ---- TRIDJK.IOFSNAP -------------------------------------- COLUMNS 001 072\n%COMMAND ===> asa2pc                                            SCROLL ===> CSR\n+****** ***************************** TOP OF DATA ******************************\n%==MSG>+INFORMATION FOR DATASET: TRIDJK.IOFSNAP\n%=NOTE=+ALLOCATION:  VOL=WORK14  UNIT=3380\n%=NOTE=+ATTRIBUTES:  RECFM=VBA  LRECL=255  BLKSIZE=3600  DSORG=PS\n%=NOTE=+SPACE:       UNITS=TRACK  PRIMARY=1  SECONDARY=20  TOTAL=1  USED=1\n%=NOTE=+DATES:       CREATED 1996/080, LAST REFERENCED 1996/080, EXPIRES 0\n+000001%1+                     J E S 2  J O B  L O G  --  S Y S T E M  A 1 V S\n+000002%0+\n+000003  13.16.22 TSU08975  $HASP373 TRIDJK   STARTED\n+000004  13.16.22 TSU08975  ACF9CCCD USERID TRIDJK   IS ASSIGNED TO THIS JOB\n+000005  13.29.55 TSU08975  CSV003I REQUESTED MODULE ADRRELVL NOT FOUND\n)END\n./ ADD NAME=#BROWSE4 0122-89305-94340-1244-00024-00018-00000-PANEL\n%TUTORIAL ---------------- EDIT - 'BROWSE4' MACRO --------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%BROWSE4+macro allows you to browse another data set without exiting from\n your current edit session.  When the nested browse session is terminated, the\n current edit session is resumed.  The contents of variable ZVIEW determines\n whether browse or view is invoked.  This version of browse is for ISPF\n Version 4.1.\n\n\n+e.g. %COMMAND ===> browse4 abc    + causes browse to be entered for member\n                                     \"ABC\" of the current library.  If member\n                                     \"ABC\" does not exist, then dataset\n                                     \"&ZUSER..ABC\" will be browsed.\n\n+e.g. %COMMAND ===> browse4 'sys1.proclib(jes2)'\n                                   + causes browse to be entered for member\n                                     \"JES2\" in library \"SYS1.PROCLIB\".\n\n+e.g. %COMMAND ===> browse4        + causes View-Entry panel to be displayed.\n\n+e.g. %COMMAND ===> browse4 *prim  + causes member list for pattern \"*PRIM\" to\n                                     be displayed for the current library.\n)END\n./ ADD NAME=#EOL     0120-89305-96095-1331-00028-00018-00000-PANEL\n)ATTR DEFAULT(%+\u00ac)\n       %   TYPE(TEXT) INTENS(HIGH)\n       +   TYPE(TEXT) INTENS(LOW)\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY\n%TUTORIAL ------------------- EDIT - 'EOL' MACRO ---------------------- TUTORIAL\n%COMMAND ===>\u00acZCMD                                                             +\n+\n+The%EOL+macro is used to position the cursor at the end of the current screen\n line (like most PC editors do when you press the \"End\" scroll key).  Yes, it\n takes some interrupts and a PF key definition, but that is the price you have\n to pay for PC-like features on a 3270.  By pressing the EOL PF key repeatedly,\n you can jump to end of line (EOL) on successive lines.\n+\n+Use:\n+Press appropriate PF key (the one assigned to EOL)\n+\n%COMMAND ===> <PFn>            +Assume%cursor+was on word%IN+on line 000020\n%Before+********************** TOP OF DATA *************************************\n 000020 D: %IN+A858SES FIND ALL RECORDS FOR WHICH\n 000021       REC-TY = 'SESC'\n 000022     END FIND                             .--- Cursor is now here\n                                                 |\n%After +********************** TOP OF DATA ***** v *****************************\n 000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH_\n 000021       REC-TY = 'SESC'\n 000022     END FIND\n)END\n./ ADD NAME=#FX      0107-89305-96095-1332-00023-00018-00000-PANEL\n%TUTORIAL -------------------- EDIT - 'FX' MACRO ---------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n\n+The%FX+macro is used to execute a FIND ALL 'string' edit subcommand after\n all lines have been excluded from display.  The resulting display is just\n those lines which contain the 'string'.\n+\n+Use:\n+Type%FX string {startcol} {endcol} {other FIND parameters}+on the command line\n+\n%COMMAND ===> FX 'RECORDS'+\n%Before+********************** TOP OF DATA *************************************\n 000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH\n 000021       REC-TY = 'SESC'\n 000022     END FIND\n 000023 S:  SORT RECORDS IN D BY NSN\n 000024     NEW PAGE\n%After +********************** TOP OF DATA *************************************\n 000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  2 LINE(S) NOT DISPLAYED+\n 000023 S:  SORT RECORDS IN D BY NSN\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  1 LINE(S) NOT DISPLAYED+\n)END\n./ ADD NAME=#FXC     0110-89305-96095-1332-00024-00018-00000-PANEL\n%TUTORIAL ------------------- EDIT - 'FXC' MACRO ---------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+The%FXC+macro is used to execute a FIND ALL 'string' edit subcommand after\n all lines have been excluded from display.  The resulting display is just\n those lines which contain the 'string'.  The 'string' used is the word that\n the%cursor+is on.  Thus, this macro works best if you put it into a PF key.\n+\n+Use:\n+Type%FXC+on the command line or press appropriate PF key\n+\n%COMMAND ===> <PFn>            +Assume%cursor+was on word%RECORDS+\n%Before+********************** TOP OF DATA *************************************\n 000020 D:  IN A858SES FIND ALL%RECORDS+FOR WHICH\n 000021       REC-TY = 'SESC'\n 000022     END FIND\n 000023 S:  SORT RECORDS IN D BY NSN\n 000024     NEW PAGE\n%After +********************** TOP OF DATA *************************************\n 000020 D:  IN A858SES FIND ALL RECORDS FOR WHICH\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  2 LINE(S) NOT DISPLAYED+\n 000023 S:  SORT RECORDS IN D BY NSN\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  1 LINE(S) NOT DISPLAYED+\n)END\n./ ADD NAME=#GO      0110-89305-94362-0639-00007-00018-00000-PANEL\n%TUTORIAL ------------------- EDIT - 'GO' MACRO ----------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%GO+macro is used to submit the current job in edit and then invoke the\n+Interactive Output Facility (IOF).\n+\n)END\n./ ADD NAME=#JC      0111-89305-96095-1332-00024-00018-00000-PANEL\n%TUTORIAL -------------------- EDIT - 'JC' MACRO ---------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%JC+macro is used to build a valid JOB card sequence at the beginning of\n the member currently being edited.  Included in the sequence is a JES2\n /*JOBPARM statement and a default OUTPUT JCL statement.  A JCLLIB statement\n and JES2 /*ROUTE statements can optionally be generated.\n+\n+Use:\n+Type%JC+on the command line\n+\n%EDIT ---- AD.JCL(TSOBATCH) - 01.10 ---------------------------- COLUMNS 001 072\n%COMMAND ===> JC                                                SCROLL ===> CSR\n%After +***************************** TOP OF DATA ******************************\n+000001 //TRIDJKBR JOB (1G70AA1RTRI),'KALINICH, JOHN',\n+000002 //             CLASS=B,\n+000003 //             NOTIFY=TRIDJK,\n+000004 //             MSGCLASS=R\n+000005 /*JOBPARM R=TRI,T=9999,L=9999\n+000006 //JCL      JCLLIB  ORDER=AD.PROCLIB\n+000007 //JOB      OUTPUT  NAME='KALINICH, JOHN',\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  8 LINE(S) NOT DISPLAYED+\n+000016 //             DEFAULT=YES\n)END\n./ ADD NAME=#LISTDSI 0103-89305-92310-0810-00019-00018-00000-PANEL\n%TUTORIAL ----------------- EDIT - 'LISTDSI' MACRO -------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%LISTDSI+macro is used to display information about a dataset in Option 3.2\n format.  The default dataset will be the data set that is being edited.  You\n can display information on another data set by giving the name as a parameter\n to LISTDSI.  For example, LISTDSI 'ALPHA.MJCL' will display information on the\n master jcl library.\n\n\n Information displayed by the LISTDSI command:\n\n  %o+Dataset name\n  %o+Allocation information\n  %o+Dataset attributes\n  %o+Space statistics\n  %o+Date flags\n  %o+PDS Directory information\n)END\n./ ADD NAME=#MEMLIST 0108-91298-93344-1102-00018-00017-00000-PANEL\n%TUTORIAL ---------------- EDIT - 'MEMLIST' MACRO --------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+The%MEMLIST+macro is used to list the members of the current PDS being\n+edited to the screen.  A range may be used. %MEMLIST A L+would list\n+all members starting with \"A\" to include all members starting with \"L\".\n+The range may include up to eight characters on both ends.\n\n+Use:\n+Type%MEMLIST+on the command line\n+\n%COMMAND ===> MEMLIST A L\n%Result:\n+\n%==MSG> MEMLIST:  FROM A TO L\n%=NOTE=+APPLY      APPLYCK   BROWSEIT   LISTPDS1   LISTPDS2   LOOK\n+\n)END\n./ ADD NAME=#OPER    0115-90311-96044-0926-00020-00024-00000-PANEL\n%TUTORIAL ------------------ EDIT - 'OPER' MACRO ---------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n+The%OPER+macro is used to send canned operator commands to SDSF.\n+\n+Use:\n+Type%OPER+on the command line\n+     and use%Cn+or%CC+to identify one or more operator commands\n+\n%EDIT ---- AD.OPERCMDS ----------------------------------------- COLUMNS 001 072\n%COMMAND ===> oper                                              SCROLL ===> CSR\n+****** ***************************** TOP OF DATA ******************************\n%=NOTE=+SDSF OPERATOR COMMANDS ARE LIMITED TO 42 BYTES (ISFPANEL INPUT SIZE)\n%=NOTE=+\n+000001 Operator commands to vary terminals active:\n+000002\n%cc+003 /V NET,ACT,ID=AA9DA474  S. WILLIE\n+000004 /V NET,ACT,ID=AA9DA475  R. PARROT\n%cc+005 /V NET,ACT,ID=AA9DA476  D. QUAIL\n)END\n./ ADD NAME=#PLUG    0118-91298-96044-0925-00028-00022-00000-PANEL\n)ATTR DEFAULT(%@\u00ac)\n       %   TYPE(TEXT) INTENS(HIGH)\n       @   TYPE(TEXT) INTENS(LOW)\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY\n%TUTORIAL ------------------ EDIT - 'PLUG' MACRO  --------------------- TUTORIAL\n%COMMAND ===>\u00acZCMD                                                             @\n@\n@The%PLUG@macro is used to plug data into a range of lines starting at a\n@given column.\n@\n@Use:\n@Type%PLUG string {startcol} {.from .to}@on the command line.  If%.from@and\n@    %.to@labels are not specified, then mark the lines with the%On@range\n@     command.  If column is not specified, the cursor position will be used.\n@                                                  cursor pos. ------.\n@                                                                    |\n%COMMAND ===> plug xdccmd .a .b@                                     |\n%Before@********************** TOP OF DATA ************************* v *********\n%.A@001 AT UXM204.UXM2FMGR+560(FLDBLOCK.FLDNAME!+2,EQ,'MAINT_LV'):R (UXM204A)\n@000002 AT UXM204.UXM2FMGR+58C(FLDBLOCK.FLDNAME!+2,EQ,'MAINT_LV'):R (UXM204B)\n%.B@003 AT UXM204.UXM2FMGR+67C(FLDBLOCK.FLDNAME!+2,EQ,'MAINT_LV'):R (UXM204C)\n@\n%After@*********************** TOP OF DATA *************************************\n%.A@001 AT UXM204.UXM2FMGR+560(FLDBLOCK.FLDNAME!+2,EQ,'MAINT_LV'):R (XDCCMDA)\n@000002 AT UXM204.UXM2FMGR+58C(FLDBLOCK.FLDNAME!+2,EQ,'MAINT_LV'):R (XDCCMDB)\n%.B@003 AT UXM204.UXM2FMGR+67C(FLDBLOCK.FLDNAME!+2,EQ,'MAINT_LV'):R (XDCCMDC)\n)END\n./ ADD NAME=#PROFSET 0135-89305-97016-1320-00069-00018-00000-PANEL\n)ATTR\n  # AREA(SCRL) EXTEND(ON)\n)BODY\n%TUTORIAL ---------------- EDIT - 'PROFSET' MACRO --------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%PROFSET+macro is used to mass change all edit profiles for a given\n ISPF application.  The current xxxEDIT (xxx = applid) table rows are read.\n For each row, a temporary file is allocated with the same low level qualifier,\n record format, and logical record length; then ISPF edit is invoked with\n an initial edit macro to set profile values (e.g., RECOVERY OFF NOWARN).\n\n+Use:\n Type%PROFSET editmacro+on the command line.\n#PROFAREA ---------------------------------------------------------------------#\n)AREA PROFAREA\n%EDIT ---- SYS1.HELP(ME) - 01.01 ------------------------------- COLUMNS 001 072\n%COMMAND ===> profset nowarn                                    SCROLL ===> CSR\n+***************************** Top of Data *************************************\n+000001 * Will somebody please help me?\n%==MSG>\n%==MSG> THE FOLLOWING IS A LIST OF YOUR CURRENT EDIT PROFILES:\n%==MSG>\n%==MSG>    PROFILE  LRECL  RECFM  BNDL  BNDR  FLAGS\n%==MSG>    -------  -----  -----  ----  ----  -----\n%=NOTE=+   ZDEFAULT 0      *      0     0     100000100000000000000000\n%=NOTE=+   HELP     80     F      0     0     010000100101100000010000\n%=NOTE=+   ISPPROF  80     F      0     0     000000100000000000000000\n%=NOTE=+   EXT      239    V      0     0     000000100000000000000000\n%=NOTE=+   CNTL     80     F      0     0     010000100101000000000000\n%=NOTE=+   MACLIB   80     F      0     0     000000100101000000000000\n%=NOTE=+   MODGEN   80     F      0     0     010000100101000000000000\n%=NOTE=+   PDS353   80     F      0     0     010000100000000000000000\n%=NOTE=+   PROCLIB  80     F      0     0     010000000101000000000000\n%=NOTE=+   CAIMAC   80     F      0     0     010000100101000000000000\n%=NOTE=+   OPERCMDS 80     F      0     0     000000100000000000000000\n%=NOTE=+   PARMLIB  80     F      0     0     010000100101000000000000\n%=NOTE=+   PDS      80     F      0     0     010000100000000000000000\n%=NOTE=+   SCOTHORN 239    V      0     0     000000100000000000000000\n%=NOTE=+   LOGONIDS 80     F      0     0     010000100000000000000000\n%=NOTE=+   INSTALIB 80     F      0     0     010000100101000000000000\n%=NOTE=+   TEXTLIB  80     F      0     0     010000100101000000000000\n%=NOTE=+   R0109517 68     V      0     0     000000100000000000000000\n%=NOTE=+   SOURCE   80     F      0     0     010000000101000000000000\n%=NOTE=+   RULES    80     F      0     0     010000100101000000000000\n%=NOTE=+   RULE     80     F      0     0     010000100101000000000000\n%=NOTE=+   R0106830 80     F      0     0     000000100000000000000000\n%=NOTE=+   SCOT     239    V      0     0     000000100000000000000000\n%=NOTE=+   ICL      80     F      0     0     000000100000000000000000\n%=NOTE=+   ISPF     80     F      0     0     000000100000000000000000\n%=NOTE=+   CLIST    80     F      0     0     010000000000100000010000\n%=NOTE=+   ISPPLIB  80     F      0     0     000000100000000000010000\n+**************************** Bottom of Data ***********************************\n\n\n+Intitial edit macro:\n\n%EDIT ---- AD.CLIST(NOWARN) - 01.09 ---------------------------- COLUMNS 001 072\n%COMMAND ===>                                                   SCROLL ===> CSR\n+***************************** Top of Data *************************************\n+000001 /* Rexx */\n+000002 Address ISREDIT\n+000003 \"ISREDIT MACRO\"\n+000004 \"ISREDIT RECOVERY OFF NOWARN\"\n+000005 \"ISREDIT END\"\n+000006 Exit\n+**************************** Bottom of Data ***********************************\n)END\n/* Based on PROFLIST edit macro by Bob Zimmerman, CNA Insurance. */\n./ ADD NAME=#RUN     0113-89305-96044-0925-00022-00018-00000-PANEL\n%TUTORIAL ------------------- EDIT - 'RUN' MACRO ---------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%RUN+macro is used to%EXECute+the CLIST/EXEC that currently is being edited.\n CLIST/EXEC parameters can be specified after the word RUN.  If any parameters\n require quotes, use two for every one.  The edit macro will supply the first\n and last quote marks.  Use%Cn+or%CC+to identify a section of commands if you\n just want to execute a portion of the code.\n\n%EDIT ---- AD.CLIST(JPK) - 01.09 ------------------------------- COLUMNS 001 072\n%COMMAND ===> run                                               SCROLL ===> CSR\n+****** ***************************** TOP OF DATA ******************************\n+000001 PROC 0 DEBUG\n+000002 IF &&DEBUG = &&STR(DEBUG) THEN -\n+000003   CONTROL MSG NOFLUSH LIST CONLIST SYMLIST PROMPT\n+000004 ELSE -\n+000005   CONTROL NOMSG NOFLUSH NOLIST NOCONLIST NOSYMLIST\n%cc+006 PTSSTEP RESET\n+000007 PTSSTEP OVERRIDE DA('AD.CMDLIB')\n+000008 ISPEXEC SELECT PANEL(ISR@TEST) NEWAPPL(ISR)\n%cc+009 PTSSTEP RESET\n)END\n./ ADD NAME=#RUNACF  0122-89305-96096-0648-00061-00018-00000-PANEL\n)ATTR\n  # AREA(SCRL) EXTEND(ON)\n)BODY\n%TUTORIAL ---------------- EDIT - 'RUNACF' MACRO ---------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%RUNACF+macro is used to send ACF subcommands to the ACF command\n processor.\n\n+Use:\n Type%RUNACF {NOTE|DATA}+on the command line and use%Cn+or%CC+to identify\n a section of commands you want to execute.  If%NOTE+is specified, then the\n output will be returned as =NOTE= lines.  If%DATA+is specified, then the\n output will be returned as lines of data.  If no parameter is specified,\n then TSO line mode output will be returned.\n#ACFAREA ----------------------------------------------------------------------#\n)AREA ACFAREA\n%EDIT ---- SK4.CMDS(RUNME) - 01.09 ----------------------------- COLUMNS 001 072\n%COMMAND ===> runacf note                                       SCROLL ===> CSR\n%Before+***************************** TOP OF DATA ******************************\n%cc+001 show mode\n+000002\n+000003 set terse\n+000004 list -\n+000005   if(nosuspend tso) -\n+000006   like(ttsm-)\n+000007\n+000008 compile * store\n+000009 $key(testrule)\n+000010 - uid(*) read(a)\n+000011 end\n+000012\n+000013 set rule\n%cc+014 delete testrule\n%After +***************************** TOP OF DATA ******************************\n+000001 show mode\n+000002\n+000003 set terse\n+000004 list -\n+000005   if(nosuspend tso) -\n+000006   like(ttsm-)\n+000007\n+000008 compile * store\n+000009 $key(testrule)\n+000010 - uid(*) read(a)\n+000011 end\n+000012\n+000013 set rule\n+000014 delete testrule\n%==MSG> ACF OUTPUT+\n%=NOTE=+MODE: ACF\n%=NOTE=+\n%=NOTE=+ TTSMX1               AMVSHVYTTSMX1           FIRECALL 1           4892\n%=NOTE=+ TTSMX2               AMVSHVYTTSMX2           FIRECALL 2           4055\n%=NOTE=+ACF COMPILER ENTERED\n%=NOTE=+\n%=NOTE=+IN ONE OR MORE RULES, THE EXECUTE ACCESS WAS SET TO THE READ ACCESS\n%=NOTE=+TOTAL RECORD LENGTH= 93 BYTES, 2 PERCENT UTILIZED\n%=NOTE=+RULE  TESTRULE STORED\n%=NOTE=+RULE TESTRULE  DELETED\n)END\n./ ADD NAME=#SHOWCUT 0104-89305-90282-1357-00008-00018-00000-PANEL\n%TUTORIAL ---------------- EDIT - 'SHOWCUT' MACRO --------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%SHOWCUT+macro is used to browse the ISPF cut table created by the CUT\n macro.  A CUT table name can be entered as a parameter, otherwise the default\n name is used.\n\n)END\n./ ADD NAME=#TESTACF 0129-89305-96228-0707-00060-00018-00000-PANEL\n)ATTR\n  # AREA(SCRL) EXTEND(ON)\n)BODY\n%TUTORIAL ---------------- EDIT - 'TESTACF' MACRO --------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n\n+The%TESTACF+macro is used to test ACF2 rules based on the DSN= parameter\n values in your JCL.  If the type of access is not specified, then READ access\n is assumed.\n\n+Use:\n Type%TESTACF logonid|UID(uidstring) {NOTE|DATA} {READ|WRITE|ALLOC|EXEC}+\n on the command line and use%Cn+or%CC+to identify a section of JCL you\n want to test.  If%NOTE+is specified, then the output will be returned\n as =NOTE= lines.  If%DATA+is specified, then the output will be returned\n as lines of data.  If no parameter is specified, then TSO line mode\n output will be returned.\n#ACFAREA ----------------------------------------------------------------------#\n)AREA ACFAREA\n%EDIT ---- AD.JCL(TINATINA) - 02.01 ---------------------------- COLUMNS 001 072\n%COMMAND ===> testacf trixtc note                               SCROLL ===> CSR\n%Before+***************************** TOP OF DATA ******************************\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  8 LINE(S) NOT DISPLAYED+\n+%c2+10 //STEPLIB  DD  DSN=AP.KNET50A.LOADLIB,DISP=SHR\n+000011 //JAVA     DD  DSN=AD.CMGR,DISP=SHR\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 25 LINE(S) NOT DISPLAYED+\n%After +***************************** TOP OF DATA ******************************\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  8 LINE(S) NOT DISPLAYED+\n+000010 //STEPLIB  DD  DSN=AP.KNET50A.LOADLIB,DISP=SHR\n%==MSG> ACF TEST OUTPUT+\n%=NOTE=+THE FOLLOWING PARAMETERS ARE IN EFFECT:\n%=NOTE=+ DDN=******     UID=ATRIXM2TRIXTC\n%=NOTE=+ DATE=08/09/96  SOURCE=********\n%=NOTE=+ VOL=           DSN=AP.KNET50A.LOADLIB\n%=NOTE=+ PGM=******     LIB=***.***\n%=NOTE=+ TIME=*****     ACCESS=READ\n%=NOTE=+\n%=NOTE=+ VALIDATED RULE LINE FROM AP\n%=NOTE=+ - UID(*) READ(A) EXEC(A)\n%=NOTE=+\n%=NOTE=+ RESULT: ALLOW\n%=NOTE=+ REASON: ACCESS  =RULE PERMITTING ACCESS MATCHED ENVIRONMENT\n%=NOTE=+\n+000011 //JAVA     DD  DSN=AD.CMGR,DISP=SHR\n%==MSG> ACF TEST OUTPUT+\n%=NOTE=+THE FOLLOWING PARAMETERS ARE IN EFFECT:\n%=NOTE=+ DDN=******     UID=ATRIXM2TRIXTC\n%=NOTE=+ DATE=08/09/96  SOURCE=********\n%=NOTE=+ VOL=           DSN=AD.CMGR\n%=NOTE=+ PGM=******     LIB=***.***\n%=NOTE=+ TIME=*****     ACCESS=READ\n%=NOTE=+\n%=NOTE=+ VALIDATED RULE LINE FROM AD\n%=NOTE=+ CMGR UID(*)\n%=NOTE=+\n%=NOTE=+ RESULT: DENY\n%=NOTE=+ REASON: NOACCESS=RULE PREVENTED ACCESS\n%=NOTE=+\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 25 LINE(S) NOT DISPLAYED+\n)END\n./ ADD NAME=#UNX     0110-89305-96095-1333-00024-00018-00000-PANEL\n%TUTORIAL ------------------- EDIT - 'UNX' MACRO ---------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n\n+The%UNX+macro is used to show the first n line(s) from each block of excluded\n+lines in the member.  If no operand is given, the number of lines shown\n+defaults to 1.\n+\n+Use:\n+Type%UNX {numlines}+on the command line\n+\n%COMMAND ===> UNX 1+\n%Before+********************** TOP OF DATA *************************************\n 000001 //DELETE   EXEC  PGM=IDCAMS,\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 20 LINE(S) NOT DISPLAYED+\n 000022 //ALTER    EXEC  PGM=IDCAMS,\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 12 LINE(S) NOT DISPLAYED+\n%After +********************** TOP OF DATA *************************************\n 000001 //DELETE   EXEC  PGM=IDCAMS,\n 000002 //             COND=(0,LT)\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 19 LINE(S) NOT DISPLAYED+\n 000022 //ALTER    EXEC  PGM=IDCAMS,\n 000023 //             COND=(4,LT)\n%- - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 11 LINE(S) NOT DISPLAYED+\n)END\n./ ADD NAME=#WEAVE   0122-91298-94136-1453-00029-00022-00000-PANEL\n)ATTR DEFAULT(%@\u00ac)\n       %   TYPE(TEXT) INTENS(HIGH)\n       @   TYPE(TEXT) INTENS(LOW)\n       \u00ac   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n)BODY\n%TUTORIAL ----------------- EDIT - 'WEAVE' MACRO  --------------------- TUTORIAL\n%COMMAND ===>\u00acZCMD                                                             @\n@\n@The%WEAVE@macro is used to interlace data from the CUT table into a range\n@of lines.\n@\n@Use:\n@Type%WEAVE {.from .to} {cuttable}@on the command line.  If%.from@and%.to@labels\n@     are not specified, then mark the lines with the%On@range command.\n@\n%COMMAND ===> weave .a .b@\n%Before@********************** TOP OF DATA *************************************\n%.A@001 KB CREATE PAYROLL  .01 TRIDJK\n@000002 KB CREATE LOANS    .01 TRIDJK\n%.B@003 KB CREATE FLIGHTS  .01 TRIDJK\n@\n%After@*********************** TOP OF DATA *************************************\n%.A@001 KB CREATE PAYROLL  .01 TRIDJK\n@000002 CLEAR                            <--- from CUT table\n@000003 KB CREATE LOANS    .01 TRIDJK\n@000004 CLEAR                            <--- from CUT table\n%.B@005 KB CREATE FLIGHTS  .01 TRIDJK\n@000006 CLEAR                            <--- from CUT table\n)END\n./ ADD NAME=CALCP    0158-91268-93201-0727-00009-00022-00000-PANEL\n)BODY WINDOW(76,3)\n%===>_XPRESHUN                                                             +\n+\n+\n)PROC\n&zedsmsg = 'Enter Expression'\n&zedlmsg = 'Enter REXX arithmetic expression for evaluation'\nVER (&XPRESHUN,NB,MSG=ISRZ001W)\n)END\n./ ADD NAME=DSK33XX  0110-90267-92280-0709-00030-00025-00000-PANEL\n)ATTR\n  \u00ac   TYPE(OUTPUT)  INTENS(HIGH)\n)BODY\n%-------------------------- DISK SPACE CALCULATION -----------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+ENTER SPACE INFORMATION:\n    BLOCK SIZE      %===>_DLEN +\n    NUMBER OF BLOCKS%===>_NUMREC    +\n    KEY LENGTH      %===>_Z  +          (blank if no key)\n\n                                  IBM             IBM             IBM\n+CALCULATION RESULTS:             3350            3380            3390\n    USED BYTES PER TRACK    %===>\u00acUTRK5+         \u00acUTRK8+         \u00acUTRK9+\n    PERCENT USED PER TRACK  %===>\u00acPTRK5+         \u00acPTRK8+         \u00acPTRK9+\n    WASTED BYTES PER TRACK  %===>\u00acWTRK5+         \u00acWTRK8+         \u00acWTRK9+\n    BLOCKS PER TRACK        %===>\u00acBTRK5+         \u00acBTRK8+         \u00acBTRK9+\n    BLOCKS PER CYLINDER     %===>\u00acBCYL5+         \u00acBCYL8+         \u00acBCYL9+\n    TOTAL TRACKS REQUIRED   %===>\u00acTTRK5       +  \u00acTTRK8       +  \u00acTTRK9       +\n    TOTAL CYLINDERS REQUIRED%===>\u00acTCYL5       +  \u00acTCYL8       +  \u00acTCYL9       +\n    TOTAL VOLUMES REQUIRED  %===>\u00acTVOL5       +  \u00acTVOL8       +  \u00acTVOL9       +\n                                 (555 cyls)      (1770 cyls)     (2226 cyls)\n                                 %1x+density     %2x+density     %2x+density\n)INIT\n.ZVARS = '(KLEN)'\n)PROC\nVER (&DLEN,NB,RANGE,0,56664)\nVER (&NUMREC,NB,RANGE,1,2147483647)\nVER (&KLEN,RANGE,0,255)\n)END\n./ ADD NAME=DVOL     0101-94119-98197-0731-00033-00022-00000-PANEL\n%-------------------------- DISPLAY DISK FREE SPACE ----------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+   VOLSER %===>_DSER1 +           (A partial volser may be entered)\n+          %===>_DSER2 +           (Optional)\n+          %===>_DSER3 +           (Optional)\n+          %===>_DSER4 +           (Optional)\n+          %===>_DSER5 +           (Optional)\n+          %===>_DSER6 +           (Optional)\n+          %===>_DSER7 +           (Optional)\n+          %===>_DSER8 +           (Optional)\n+          %===>_DSER9 +           (Optional)\n+          %===>_DSER10+           (Optional)\n+\n+   DISPLAY%===>_DTYPE+            (SHORT or LONG display request)\n)INIT\n.CURSOR = DSER1\n&DTYPE = SHORT\n)PROC\nVER(&DSER1,NB)\nVER(&DSER2,NAME)\nVER(&DSER3,NAME)\nVER(&DSER4,NAME)\nVER(&DSER5,NAME)\nVER(&DSER6,NAME)\nVER(&DSER7,NAME)\nVER(&DSER8,NAME)\nVER(&DSER9,NAME)\nVER(&DSER10,NAME)\nVER(&DTYPE,LIST,SHORT,LONG)\nVPUT (DSER1 DSER2 DSER3 DSER4 DSER5) PROFILE\nVPUT (DSER6 DSER7 DSER8 DSER9 DSER10) PROFILE\n)END\n./ ADD NAME=DVOLTBLH 0130-91101-98196-0943-00027-00017-00000-PANEL\n)ATTR DEFAULT(%#_)\n    ! TYPE(TEXT) INTENS(HIGH) COLOR(TURQ)\n    @ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n    \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(GREEN)\n)BODY\n%TUTORIAL ----------------- DISPLAY DISK FREE SPACE ------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT #\n#\n This option displays DASD free space statistics for a range of disk volumes.\n\n Volumes can be located with the the%F#and%L#commands.  At the command line,\n enter%F#volser or%L#volser:\n\n            %L WORK   #(Position to volsers starting with WORK)\n            %F WORK15 #(Position to volser WORK15)\n\n The table can be sorted by volume serial or total tracks.  At the command line,\n enter%SORT#keyname, where keyname is%SERIAL#or%TOTAL.# The primary sort key\n will always be UNIT TYPE (in descending sequence:  3390M2, 3380D, 3380, etc).\n\n%SERIAL  --UNIT--   ATTRIBUTES VSAM AVAIL -----TOTALS----- LARGEST-EXTENT 5 EXTS\n%       ADDR TYPE   MOUNT/USE      DSCBS TRACKS  EXT  CYL  CYL+TR  TRACKS TRACKS\n!WORK15#0987@3390M2#RESDNT/STOR      836\u00ac 19550#  45 1286  647+12   9717  18288\n!WORK16#0997@3390M2#RESDNT/STOR      831\u00ac   293#  38    8    8+ 0    120    167\n!WORK17#0907@3390M2#RESDNT/STOR      849\u00ac 19813#  39 1308  587+13   8818  19239\n+****************************** Bottom of data  ********************************\n)END\n./ ADD NAME=DVOLTBLL 0121-91101-98176-1455-00017-00017-00000-PANEL\n)ATTR DEFAULT(%@_)\n%   TYPE(TEXT) INTENS(HIGH)\n@   TYPE(TEXT) INTENS(LOW)\n_   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n!   TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(ASIS)\n)BODY\n%-------------------------- DISPLAY DISK FREE SPACE ----------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT @\n%\n)MODEL\n!Z\n)INIT\n.CURSOR = ZCMD\n.ZVARS = '(DVOLLINE)'\n&AMT=CSR\n)PROC\n)END\n./ ADD NAME=DVOLTBLS 0136-91101-98196-0931-00028-00017-00000-PANEL\n)ATTR DEFAULT(%@_)\n%   TYPE(TEXT) INTENS(HIGH)\n@   TYPE(TEXT) INTENS(LOW)\n_   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n!   TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(ASIS)\n)BODY\n%-------------------------- DISPLAY DISK FREE SPACE ----------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT @\n%\n!Z     @    !Z     @                    !Z     @\n%SERIAL  --UNIT--   ATTRIBUTES VSAM AVAIL -----TOTALS----- LARGEST-EXTENT 5 EXTS\n%       ADDR TYPE   MOUNT/USE      DSCBS TRACKS  EXT  CYL  CYL+TR  TRACKS TRACKS\n)MODEL\n!Z     !Z   !Z     !Z                   !Z     !Z\n)INIT\n.HELP = DVOLTBLH\n.CURSOR = ZCMD\n.ZVARS = '(KEY1 KEY2 KEY3 DVOLSER DVOLF1 DVOLUNIT +\n           DVOLF2 DVOLTOT DVOLF3)'\n&AMT=CSR\n.ATTR(KEY1)      = 'INTENS(HIGH) COLOR(RED)'\n.ATTR(KEY2)      = 'INTENS(HIGH) COLOR(RED)'\n.ATTR(KEY3)      = 'INTENS(HIGH) COLOR(RED)'\n.ATTR(DVOLSER)   = 'INTENS(HIGH) COLOR(TURQ)'\n.ATTR(DVOLUNIT)  = 'INTENS(HIGH) COLOR(YELLOW)'\n.ATTR(DVOLTOT)   = 'INTENS(HIGH) COLOR(GREEN)'\n)PROC\n)END\n./ ADD NAME=EBH01A   0106-89296-92329-0651-00026-00028-00000-PANEL\n%TUTORIAL -------------------  EDIT/BROWSE MENU  ---------------------- TUTORIAL\n%COMMAND ===>_ZCMD                                                             +\n+\n    This panel allows you to%EDIT+or%BROWSE+datasets by the numbers.\n    When you edit more than one dataset (partitioned, sequential, or\n    LIBRARIAN) a session, the menu of datasets eliminates typing and typos.\n\n    Specify the number of the PDS, and member you want to EDIT/BROWSE:\n\n   +PDS NUMBER   %===>+     (0 to change defaults, 20 for edit entry panel)\n   +MEMBER       %===>+     (Blank or pattern for member selection list)\n   +BROWSE MARKER%===>+     (ON to display%>+browse marker)\n\n    If you have not defined your default libraries and their modes or\n    want to change them, select PDS number 0.\n\n    A dataset and member can be express selected from another ISPF panel if\n    you know the dataset number and member name without looking at the menu.\n\n    For example: %=E.1+to select dataset number 1 or\n                 %=E.1.M204*+to select dataset number 1, members M204....\n)INIT\n&ZHTOP = EBH01A\n)PROC\n &CONT = EBH01B\n)END\n./ ADD NAME=EBH01B   0154-86053-99090-0659-00023-00029-00000-PANEL\n)BODY DEFAULT(%+\u00ac)\n%TUTORIAL -------------  SET DEFAULT MODES AND LIBRARIES  ------------- TUTORIAL\n%COMMAND ===>\u00acZCMD                                                             +\n+\n  Enter the mode (%E+for edit,%B+for browse,%LE+for ELIPS edit,%LB+for ELIPS\n  browse,%PDS+for pds85,%V+for view) and library name below.\n\n  + PDS  MODE LIBRARY                     PDS  MODE LIBRARY\n\n   %  1  le__ 'source.s2k'_______________% 11  b___ 'sys1.parmlib'_____________+\n   %  2  b___ 'tridjk.clist'_____________% 12  v___ 'sys1.proclib'_____________+\n   %  3  pds_ 'ad.ispplib'_______________% 13  pds_ 'sys1.lpalib'______________+\n   %  4  pds_ 'ad.ispmlib'_______________% 14  pds_ 'ad.xdc.samplib'___________+\n   %  5  pds_ 'ad.ispslib'_______________% 15  pds_ 'ad.xdc.install'___________+\n   %  6  pds_ 'ad.tlib'__________________% 16  pds_ 'nomad.schema.data'________+\n   %  7  pds_ 'ad.cbtmods.ver329'________% 17  lb__ 'source.alpha1'____________+\n   %  8  e___ 'tridjk.gen.cntl'__________% 18  lb__ 'source.alpha2'____________+\n   %  9  pds_ 'ad.proclib'_______________% 19  lb__ 'source.mvs'_______________+\n   % 10  v___ 's2k.parms'________________+\n\n+   Press%ENTER+key to process changes.\n+   Enter%END+command or press%PF3+to exit.\n)END\n./ ADD NAME=EB01A    0127-88063-95069-0638-00143-00078-00000-PANEL\n)ATTR\n  \u00ac   TYPE(OUTPUT)  INTENS(LOW) CAPS(ON)\n  !   TYPE(OUTPUT)  INTENS(HIGH) CAPS(ON)\n)BODY\n%----------------------------  EDIT/BROWSE MENU  -------------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+ISPF LIBRARY:\n   +PDS NUMBER   %===>_Z +\n   +MEMBER       %===>_MEMBER  +    (Blank or pattern for member selection list)\n   +BROWSE MARKER%===>_BRM+         (ON or OFF)\n\n + PDS  LIBRARY                          PDS  LIBRARY\n\n    %0 +Change defaults below\n\n  !Z+1 \u00acEB1                            !Z+11 \u00acEB11\n  !Z+2 \u00acEB2                            !Z+12 \u00acEB12\n  !Z+3 \u00acEB3                            !Z+13 \u00acEB13\n  !Z+4 \u00acEB4                            !Z+14 \u00acEB14\n  !Z+5 \u00acEB5                            !Z+15 \u00acEB15\n  !Z+6 \u00acEB6                            !Z+16 \u00acEB16\n  !Z+7 \u00acEB7                            !Z+17 \u00acEB17\n  !Z+8 \u00acEB8                            !Z+18 \u00acEB18\n  !Z+9 \u00acEB9                            !Z+19 \u00acEB19\n !Z+10 \u00acEB10                           %  20  Edit+- Entry Panel\n\n)INIT\n  .ZVARS  = '(PDS +\n              EF1 EF11 EF2 EF12 EF3 EF13 EF4 EF14 EF5 EF15 +\n              EF6 EF16 EF7 EF17 EF8 EF18 EF9 EF19 EF10)'\n  .CURSOR = PDS\n  .HELP   = EBH01A\n  &EF1  = ' '\n  &EF2  = ' '\n  &EF3  = ' '\n  &EF4  = ' '\n  &EF5  = ' '\n  &EF6  = ' '\n  &EF7  = ' '\n  &EF8  = ' '\n  &EF9  = ' '\n  &EF10 = ' '\n  &EF11 = ' '\n  &EF12 = ' '\n  &EF13 = ' '\n  &EF14 = ' '\n  &EF15 = ' '\n  &EF16 = ' '\n  &EF17 = ' '\n  &EF18 = ' '\n  &EF19 = ' '\n  IF (&BRM = &Z)\n    &BRM  = 'OFF'\n  &PDS = TRUNC(&PDS,'.')\n  IF (.TRAIL \u00ac= &Z)\n    &MEMBER = .TRAIL\n  IF (&BRM = 'ON')\n    IF (&EM1 = 'B','LB','V')\n      &EF1 = '>'\n    IF (&EM2 = 'B','LB','V')\n      &EF2 = '>'\n    IF (&EM3 = 'B','LB','V')\n      &EF3 = '>'\n    IF (&EM4 = 'B','LB','V')\n      &EF4 = '>'\n    IF (&EM5 = 'B','LB','V')\n      &EF5 = '>'\n    IF (&EM6 = 'B','LB','V')\n      &EF6 = '>'\n    IF (&EM7 = 'B','LB','V')\n      &EF7 = '>'\n    IF (&EM8 = 'B','LB','V')\n      &EF8 = '>'\n    IF (&EM9 = 'B','LB','V')\n      &EF9 = '>'\n    IF (&EM10 = 'B','LB','V')\n      &EF10 = '>'\n    IF (&EM11 = 'B','LB','V')\n      &EF11 = '>'\n    IF (&EM12 = 'B','LB','V')\n      &EF12 = '>'\n    IF (&EM13 = 'B','LB','V')\n      &EF13 = '>'\n    IF (&EM14 = 'B','LB','V')\n      &EF14 = '>'\n    IF (&EM15 = 'B','LB','V')\n      &EF15 = '>'\n    IF (&EM16 = 'B','LB','V')\n      &EF16 = '>'\n    IF (&EM17 = 'B','LB','V')\n      &EF17 = '>'\n    IF (&EM18 = 'B','LB','V')\n      &EF18 = '>'\n    IF (&EM19 = 'B','LB','V')\n      &EF19 = '>'\n)PROC\nVER(&PDS,NB,RANGE,0,20)\nVER(&BRM,LIST,ON,OFF)\n&DSNAME = TRANS(&PDS\n           0,' '\n           1,'&EB1'\n           2,'&EB2'\n           3,'&EB3'\n           4,'&EB4'\n           5,'&EB5'\n           6,'&EB6'\n           7,'&EB7'\n           8,'&EB8'\n           9,'&EB9'\n          10,'&EB10'\n          11,'&EB11'\n          12,'&EB12'\n          13,'&EB13'\n          14,'&EB14'\n          15,'&EB15'\n          16,'&EB16'\n          17,'&EB17'\n          18,'&EB18'\n          19,'&EB19')\n&MODE = TRANS(&PDS\n           0,' '\n           1,'&EM1'\n           2,'&EM2'\n           3,'&EM3'\n           4,'&EM4'\n           5,'&EM5'\n           6,'&EM6'\n           7,'&EM7'\n           8,'&EM8'\n           9,'&EM9'\n          10,'&EM10'\n          11,'&EM11'\n          12,'&EM12'\n          13,'&EM13'\n          14,'&EM14'\n          15,'&EM15'\n          16,'&EM16'\n          17,'&EM17'\n          18,'&EM18'\n          19,'&EM19')\nVPUT (BRM) PROFILE\n)END\n./ ADD NAME=EB01B    0126-86053-94341-0747-00145-00044-00000-PANEL\n)ATTR\n  \u00ac   TYPE(OUTPUT)  INTENS(LOW) CAPS(ON)\n  #   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD(_)\n)BODY\n%----------------------  SET DEFAULT MODES AND LIBRARIES  ----------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+  ADD, CHANGE, or DELETE entries below:\n\n+    (MODE is E for edit, B for browse, LE for ELIPS edit, LB for ELIPS browse,\n+     PDS for pds84, and V for view)\n\n + PDS  MODE LIBRARY                          PDS  MODE LIBRARY\n\n  %  1 #EM1 _EB1                             % 11 #EM11_EB11                   +\n  %  2 #EM2 _EB2                             % 12 #EM12_EB12                   +\n  %  3 #EM3 _EB3                             % 13 #EM13_EB13                   +\n  %  4 #EM4 _EB4                             % 14 #EM14_EB14                   +\n  %  5 #EM5 _EB5                             % 15 #EM15_EB15                   +\n  %  6 #EM6 _EB6                             % 16 #EM16_EB16                   +\n  %  7 #EM7 _EB7                             % 17 #EM17_EB17                   +\n  %  8 #EM8 _EB8                             % 18 #EM18_EB18                   +\n  %  9 #EM9 _EB9                             % 19 #EM19_EB19                   +\n  % 10 #EM10_EB10                            +\n\n+  Press%ENTER+key to process changes.\n+  Enter%END+command or press%PF3+to exit.\n)INIT\n.HELP = EBH01B\n)PROC\n  VER(&EM1,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB1,DSNAME)\n  IF (&EM1 \u00ac= &Z)\n    VER(&EB1,NONBLANK)\n  IF (&EB1 \u00ac= &Z)\n    VER(&EM1,NONBLANK)\n  VER(&EM2,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB2,DSNAME)\n  IF (&EM2 \u00ac= &Z)\n    VER(&EB2,NONBLANK)\n  IF (&EB2 \u00ac= &Z)\n    VER(&EM2,NONBLANK)\n  VER(&EM3,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB3,DSNAME)\n  IF (&EM3 \u00ac= &Z)\n    VER(&EB3,NONBLANK)\n  IF (&EB3 \u00ac= &Z)\n    VER(&EM3,NONBLANK)\n  VER(&EM4,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB4,DSNAME)\n  IF (&EM4 \u00ac= &Z)\n    VER(&EB4,NONBLANK)\n  IF (&EB4 \u00ac= &Z)\n    VER(&EM4,NONBLANK)\n  VER(&EM5,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB5,DSNAME)\n  IF (&EM5 \u00ac= &Z)\n    VER(&EB5,NONBLANK)\n  IF (&EB5 \u00ac= &Z)\n    VER(&EM5,NONBLANK)\n  VER(&EM6,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB6,DSNAME)\n  IF (&EM6 \u00ac= &Z)\n    VER(&EB6,NONBLANK)\n  IF (&EB6 \u00ac= &Z)\n    VER(&EM6,NONBLANK)\n  VER(&EM7,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB7,DSNAME)\n  IF (&EM7 \u00ac= &Z)\n    VER(&EB7,NONBLANK)\n  IF (&EB7 \u00ac= &Z)\n    VER(&EM7,NONBLANK)\n  VER(&EM8,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB8,DSNAME)\n  IF (&EM8 \u00ac= &Z)\n    VER(&EB8,NONBLANK)\n  IF (&EB8 \u00ac= &Z)\n    VER(&EM8,NONBLANK)\n  VER(&EM9,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB9,DSNAME)\n  IF (&EM9 \u00ac= &Z)\n    VER(&EB9,NONBLANK)\n  IF (&EB9 \u00ac= &Z)\n    VER(&EM9,NONBLANK)\n  VER(&EM10,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB10,DSNAME)\n  IF (&EM10 \u00ac= &Z)\n    VER(&EB10,NONBLANK)\n  IF (&EB10 \u00ac= &Z)\n    VER(&EM10,NONBLANK)\n  VER(&EM11,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB11,DSNAME)\n  IF (&EM11 \u00ac= &Z)\n    VER(&EB11,NONBLANK)\n  IF (&EB11 \u00ac= &Z)\n    VER(&EM11,NONBLANK)\n  VER(&EM12,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB12,DSNAME)\n  IF (&EM12 \u00ac= &Z)\n    VER(&EB12,NONBLANK)\n  IF (&EB12 \u00ac= &Z)\n    VER(&EM12,NONBLANK)\n  VER(&EM13,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB13,DSNAME)\n  IF (&EM13 \u00ac= &Z)\n    VER(&EB13,NONBLANK)\n  IF (&EB13 \u00ac= &Z)\n    VER(&EM13,NONBLANK)\n  VER(&EM14,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB14,DSNAME)\n  IF (&EM14 \u00ac= &Z)\n    VER(&EB14,NONBLANK)\n  IF (&EB14 \u00ac= &Z)\n    VER(&EM14,NONBLANK)\n  VER(&EM15,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB15,DSNAME)\n  IF (&EM15 \u00ac= &Z)\n    VER(&EB15,NONBLANK)\n  IF (&EB15 \u00ac= &Z)\n    VER(&EM15,NONBLANK)\n  VER(&EM16,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB16,DSNAME)\n  IF (&EM16 \u00ac= &Z)\n    VER(&EB16,NONBLANK)\n  IF (&EB16 \u00ac= &Z)\n    VER(&EM16,NONBLANK)\n  VER(&EM17,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB17,DSNAME)\n  IF (&EM17 \u00ac= &Z)\n    VER(&EB17,NONBLANK)\n  IF (&EB17 \u00ac= &Z)\n    VER(&EM17,NONBLANK)\n  VER(&EM18,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB18,DSNAME)\n  IF (&EM18 \u00ac= &Z)\n    VER(&EB18,NONBLANK)\n  IF (&EB18 \u00ac= &Z)\n    VER(&EM18,NONBLANK)\n  VER(&EM19,LIST,E,B,LE,LB,PDS,V,MSG=EB003)\n  VER(&EB19,DSNAME)\n  IF (&EM19 \u00ac= &Z)\n    VER(&EB19,NONBLANK)\n  IF (&EB19 \u00ac= &Z)\n    VER(&EM19,NONBLANK)\n)END\n./ ADD NAME=ISFPANEL 0101-93312-96045-0908-00009-00009-00000-PANEL\n/******************************************************/\n/* Insert at the end of the )INIT section of panel    */\n/* ISFPANEL or ISFPCU41 (SDSF 1.5 and ISPF 4.1)       */\n/******************************************************/\n/* Generate end key response if OPER edit macro call  */\n/******************************************************/\nVGET (SDSFOPER) ASIS\nIF (&SDSFOPER = 'END')\n  .RESP=END\n./ ADD NAME=ISR@PRIM 0103-95019-95278-0810-00199-00199-00000-PANEL\n)ATTR\n  \u00ac  TYPE(AB) FORMAT(MIX)\n)ABC ABCTEXT('System')\n  PDC PDCTEXT('MVS system information...')\n  ACTION RUN(MVS)\n  PDC PDCTEXT('TSO dataset allocations...')\n  ACTION RUN(LA)\n  PDC PDCTEXT('DASD space calculations...')\n  ACTION RUN(DISK)\n  PDC PDCTEXT('Active TSO users...')\n  ACTION RUN(TSU)\n  PDC PDCTEXT('Resolve Plus monitor...')\n  ACTION RUN(RESOLVE)\n  PDC PDCTEXT('Omegamon monitor...')\n  ACTION RUN(OMEGAMON)\n  PDC PDCTEXT('RMF monitor...')\n  ACTION RUN(RMF)\n  PDC PDCTEXT('Info/MVS...')\n  ACTION RUN(INFOMVS)\n  PDC PDCTEXT('Non-CUA Primary Option Menu...')\n  ACTION RUN(XPRIM)\n  PDC PDCTEXT('Exit ISPF...')\n  ACTION RUN(END)\n)ABCINIT ABCTEXT('System')\n  .ZVARS = 'ZPDC'\n  &ZPDC = ''\n)ABCPROC ABCTEXT('System')\n  VER (&ZPDC,RANGE,1,20)\n)ABC ABCTEXT('Spool')\n  PDC PDCTEXT('Data Technologies key jobs...')\n  ACTION RUN(JOBS)\n  PDC PDCTEXT('Input output facility (IOF)...')\n  ACTION RUN(IOFM)\n  PDC PDCTEXT('System display and search facility (SDSF)...')\n  ACTION RUN(SDSF)\n  PDC PDCTEXT('Previous or current SYSLOG dataset...')\n  ACTION RUN(SYSLOG)\n)ABCINIT ABCTEXT('Spool')\n  .ZVARS = 'ZPDC'\n  &ZPDC = ''\n)ABCPROC ABCTEXT('Spool')\n  VER (&ZPDC,RANGE,1,20)\n)ABC ABCTEXT('DBMS')\n  PDC PDCTEXT('Model 204...')\n  ACTION RUN(M204)\n  PDC PDCTEXT('Nomad...')\n  ACTION RUN(NOMAD)\n  PDC PDCTEXT('System 2000...')\n  ACTION RUN(S2K)\n  PDC PDCTEXT('VSAM...')\n  ACTION RUN(VSAM)\n  PDC PDCTEXT('DB2...')\n  ACTION RUN(DB2I)\n  PDC PDCTEXT('Datacom/DB...')\n)ABCINIT ABCTEXT('DBMS')\n  .ZVARS = 'ZPDC'\n  &ZPDC = ''\n)ABCPROC ABCTEXT('DBMS')\n  VER (&ZPDC,RANGE,1,20)\n)ABC ABCTEXT('Calendar')\n  PDC PDCTEXT('4-month calendar...')\n  ACTION RUN(DATE)\n  PDC PDCTEXT('Monthly calendar...')\n  ACTION RUN(MONTH)\n  PDC PDCTEXT('6/12 month calendar...')\n  ACTION RUN(YEAR)\n)ABCINIT ABCTEXT('Calendar')\n  .ZVARS = 'ZPDC'\n  &ZPDC = ''\n)ABCPROC ABCTEXT('Calendar')\n  VER (&ZPDC,RANGE,1,20)\n)ABC ABCTEXT('Help')\n  PDC PDCTEXT('Menu of the week - Le Restaura...')\n  ACTION RUN(LEMENU)\n  PDC PDCTEXT('LSSC Personnel Locator...')\n  ACTION RUN(PLS)\n  PDC PDCTEXT('LSSC ISPF commands...')\n  ACTION RUN(COMMANDS)\n  PDC PDCTEXT('LSSC Edit macros...')\n  ACTION RUN(MACROS)\n  PDC PDCTEXT('CCSS Magic Flashes...')\n  ACTION RUN(FLASHES)\n  PDC PDCTEXT('MVS/ESA Program Products...')\n  ACTION RUN(PRODUCTS)\n  PDC PDCTEXT('CA-Docview...')\n  ACTION RUN(DOCVIEW)\n  PDC PDCTEXT('PC keyboard map...')\n  ACTION RUN(PCKEYS)\n  PDC PDCTEXT('Changes to Version 3 of ISPF...')\n  ACTION RUN(CHANGES)\n  PDC PDCTEXT('TSO full-screen help...')\n  ACTION RUN(TSOHELP)\n  PDC PDCTEXT('ISPF Tutorial...')\n  ACTION RUN(HELP)\n)ABCINIT ABCTEXT('Help')\n  .ZVARS = 'ZPDC'\n  &ZPDC = ''\n)ABCPROC ABCTEXT('Help')\n  VER (&ZPDC,RANGE,1,20)\n)ABC ABCTEXT('Info')\n  PDC PDCTEXT('Sysid:      &SYSID')\n  PDC PDCTEXT('CPU Model:  &CPUMDL')\n  PDC PDCTEXT('Real:       &REALSTOR')\n  PDC PDCTEXT('IPL Date:   &IPLDATE')\n  PDC PDCTEXT('IPL Time:   &IPLTIME')\n  PDC PDCTEXT('MVS:        &SCPNAME')\n  PDC PDCTEXT('JES2:       &JESLEVEL')\n  PDC PDCTEXT('TSO/E:      &TSOE')\n  PDC PDCTEXT('ISPF:       &ZPDFREL')\n  PDC PDCTEXT('DFP:        &DFPLEVEL')\n  PDC PDCTEXT('SMS:        &SMSSTAT')\n  PDC PDCTEXT('Proc:       &LOGPROC')\n  PDC PDCTEXT('Region:     &REGION')\n  PDC PDCTEXT('Jobid:      &JESJOBID')\n  PDC PDCTEXT('Termid:     &TERMID')\n)ABCINIT ABCTEXT('Info')\n  .ZVARS = 'ZPDC'\n  &ZPDC = ''\n)ABCPROC ABCTEXT('Info')\n  VER (&ZPDC,RANGE,1,20)\n)BODY\n%\u00ac System\u00ac Spool\u00ac DBMS\u00ac Calendar\u00ac Help\u00ac Info+                PIE session: %&PIE\n+-------------------------------------------------------------------------------\n%                       ISPF/&ZPDFREL PRIMARY OPTION MENU\n%OPTION  ===>_ZCMD                                                             +\n%                                                           +USERID   - &ZUSER\n%   0 +ISPF PARMS  - Specify terminal and user parameters   +PROC     - &LOGPROC\n%   1 +BROWSE      - Display source data or output listings +TIME     - &ZTIME\n%   2 +EDIT        - Create or change source data           +JULIAN   - &ZJDATE\n%   3 +UTILITIES   - Perform utility functions              +MVS      - &SCPNAME\n%   6 +COMMAND     - Enter TSO command, CLIST, or REXX exec +TSO/E    - &TSOE\n%   7 +DIALOG TEST - Perform dialog testing                 +SYSTEM   -%&SYSID\n%   D +XDC         - Interactive debugging with XDC\n%   E +EDIT/BROWSE - Edit/Browse by the numbers from a menu of datasets\n%   L +LIBRARIAN   - ADR/The Librarian options menu\n%   M +MENU        - Data Technologies Application Menu\n%   O +OUTPUT      - Output display utilities (IOF and SDSF)\n%   P +PDS         - Invoke the PDS command processor\n%   T +TUTORIAL    - Display information about ISPF/PDF\n%   W +WHAT'S%NEW+ - Historical review of Data Technologies ISPF/PDF mods\n%   X +EXIT        - Terminate ISPF using log and list defaults\n%\n+Enter%END+command to terminate ISPF.\n%\n)INIT\n  .HELP = ISR00003\n  &ZPRIM = YES        /* ALWAYS A PRIMARY OPTION MENU      */\n  &ZHTOP = ISR00003   /* TUTORIAL TABLE OF CONTENTS        */\n  &ZHINDEX = ISR91000 /* TUTORIAL INDEX - 1ST PAGE         */\n  VPUT (ZHTOP,ZHINDEX) PROFILE\n\n  IF (&ZPDFINIT = YES)\n    IF (&Z$SAVE \u00ac= &Z)\n      &ZCMD   = &Z$SAVE\n      .RESP     = ENTER\n      &Z$SAVE = &Z\n  IF (&ZPDFINIT = &Z)\n    &Z$SAVE   = &ZCMD\n    &ZCMD     = 'FIRST'\n    .RESP     = ENTER\n    &ZPDFINIT = YES\n\n)PROC\n  &ZDUM = TRUNC(&ZCMD,'.')\n  &ZTRAIL = .TRAIL\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                0,'PANEL(ISPOPTA)'\n                1,'PGM(ISRBRO) PARM(ISRBRO01)'\n                2,'PGM(ISREDIT) PARM(P,ISREDM01)'\n                3,'PANEL(ISRUTIL)'\n                4,'PANEL(ISRFPA)'\n                5,'PGM(ISRJB1) PARM(ISRJPA) NOCHECK'\n                6,'PGM(ISRPTC)'\n                7,'PGM(ISPYXDR) PARM(ISR) NOCHECK'\n                8,'PANEL(ISRLPRIM)'\n                9,'PANEL(ISRDIIS)'\n               10,'PGM(ISRSCLM) NOCHECK'\n                B,'PANEL(TRI@CBT)'\n                C,'PGM(ISPTUTOR) PARM(ISR00005)'\n          CHANGES,'PGM(ISPTUTOR) PARM(ISR00005)'\n                D,'PANEL(XDCPANEL) NEWAPPL(XDC) PASSLIB'\n                E,'CMD(%EB) NOCHECK'\n            FIRST,'CMD(%ADINIT)'\n                I,'PGM(IOFSPF) PARM(&ZCMD) NEWAPPL(IOF) NOCHECK PASSLIB'\n                L,'PANEL(LIBRPDF) NEWAPPL(LIB@) PASSLIB'\n               LB,'PGM(LIBRLE00) PARM(B)'\n               LE,'PGM(LIBRLE00)'\n                M,'PANEL(TRI@PRIM)'\n                N,'CMD(%ADN)'\n                O,'PANEL(OUTPUT)'\n                P,'PANEL(PDS@PRIM)'\n                S,'PGM(ISFISP) PARM(&ZTRAIL) NEWAPPL(ISF) NOCHECK PASSLIB'\n                T,'PGM(ISPTUTOR) PARM(ISR00000)'\n                W,'CMD(%ADNEWSPF)'\n                X,'EXIT'\n              ' ',' '\n                *,'?' )\n &ZTRAIL = .TRAIL\n)END\n./ ADD NAME=ISRUTIL  0100-93312-93312-0645-00049-00049-00000-PANEL\n%-------------------------  UTILITY SELECTION MENU  ----------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n%    1 +LIBRARY    - Compress or print data set.  Print index listing.\n+                      Print, rename, delete, or browse members\n%    2 +DATASET    - Allocate, rename, delete, catalog, uncatalog, or\n+                      display information of an entire data set\n%    3 +MOVE/COPY  - Move, copy, or promote members or data sets\n%    4 +DSLIST     - Print or display (to process) list of data set names\n+                      Print or display VTOC information\n%    5 +RESET      - Reset statistics for members of ISPF library\n%    6 +HARDCOPY   - Initiate hardcopy output\n%    8 +OUTLIST    - Display, delete, or print held job output\n%    9 +COMMANDS   - Create/change an application command table\n%   10 +CONVERT    - Convert old format menus/messages to new format\n%   11 +FORMAT     - Format definition for formatted data Edit/Browse\n%   12 +SUPERC     - Compare data sets (Standard dialog)\n%   13 +SUPERCE    - Compare data sets (Extended dialog)\n%   14 +SEARCH-FOR - Search data sets for strings of data\n%   14B+SEARCH-FOR - Search data sets for strings of data (Batch Job)\n)INIT\n  .HELP = ISR30000\n)PROC\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                1,'PGM(ISRUDA) PARM(ISRUDA1)'\n                2,'PGM(ISRUDA) PARM(ISRUDA2)'\n                3,'PGM(ISRUMC)'\n                4,'PGM(ISRUDL) PARM(ISRUDLP)'\n                5,'PGM(ISRURS)'\n                6,'PGM(ISRUHC)'\n                8,'PGM(ISRUOLP)'\n                9,'PANEL(ISPUCMA)'\n               10,'PGM(ISRQCM) PARM(ISRQCMP)'\n               11,'PGM(ISRFMT)'\n               12,'PGM(ISRSSM)'\n               13,'PGM(ISRSEPRM) NOCHECK'\n               14,'PGM(ISRSFM)'\n              14B,'CMD(%SUPERC)'\n              ' ',' '\n                *,'?' )\n  &ZTRAIL = .TRAIL\n)END\n /*                                                                  */\n /* $SEG(ISRUTIL) COMP(SUPERCD) PROD(MVS):                           */\n /* CHANGE ACTIVITY:                                                 */\n /*    PN = REASON    RELEASE   DATE    ORIGIN   COMMENT             */\n /*    --   --------  --------  ------  ------ : ------------------  */\n /*   $L0 =    M230      100386  LUDLOW :                            */\n /*                                                                  */\n./ ADD NAME=JC       0162-86191-98176-1406-00147-00022-00000-PANEL\n)ATTR\n  # AREA(SCRL) EXTEND(ON)\n)BODY\n%-------------------------------- MVS JOB CARD ---------------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+ENTER JOB CARD INFORMATION:\n    JOB NAME PREFIX  %===>_JCPRE +\n    JOB NAME SUFFIX  %===>_Z +\n    JOB CLASS        %===>_Z+\n    JOB TIME         %===>_JCTIME  +            (Optional)\n    JOB MESSAGE CLASS%===>_Z+\n    PROGRAMMER NAME  %===>_JCNAME              +\n    NOTIFY USERID    %===>_JCNOTIFY+            (Optional)\n    ACCOUNTING INFO  %===>_JCACC          +\n    ROOM NUMBER      %===>_JCRM+\n    OTHER PARAMETERS %===>_JCOTHER1                                            +\n                     %===>_JCOTHER2                                            +\n                     %===>_JCOTHER3                                            +\n\n+ENTER OTHER JOB RELATED INFORMATION (OPTIONAL):\n+                                                                  %Up F7 Dn F8\n#RELATED ----------------------------------------------------------------------#\n)AREA RELATED\n    JCLLIB DSNAME    %===>_JCPROC                                      +\n    JES2 XEQ NODE    %===>_JCJXEQ  +\n    JES2 PRINT NODE  %===>_JCJPRT           +\n    JOB OUTPUT TITLE %===>_JCTITLE                                             +\n    JOB OUTPUT DEPT  %===>_JCDEPT                                              +\n    JOB OUTPUT BLDG  %===>_JCBLDG                                              +\n    JOB OUTPUT ADDR  %===>_JCADDR1                                             +\n                     %===>_JCADDR2                                             +\n                     %===>_JCADDR3                                             +\n                     %===>_JCADDR4                                             +\n)INIT\nVGET (JCPRE,JCSU,JCACC,JCNAME,JCNOTIFY,JCMC,JCRM,\n      JCTIME,JCOTHER1,JCOTHER2,JCOTHER3,JCPROC,JCJXEQ,JCJPRT,\n      JCDEPT,JCBLDG,JCADDR1,JCADDR2,JCADDR3,JCADDR4) PROFILE\n.ZVARS = '(JCSU JCCLASS JCMC)'\n.CURSOR = JCSU\nIF (&JCPRE = &Z)\n  &JCPRE = &ZUSER\nIF (&JCMC = &Z)\n  &JCMC = 'R'\nIF (&JCCLASS = &Z)\n  &JCCLASS = 'B'\nIF (&JCDEPT = &Z)\n  &JCDEPT = TRANS(TRUNC(&ZUSER,3)\n              TRI,'DATA TECHNOLOGIES'\n              TRA,'DATA TECHNOLOGIES'\n              TTC,'EXECUTIVE SOFTWARE'\n              TRC,'TECHNICAL SERVICES'\n              TTS,'TECHNICAL SERVICES'\n              QQX,'TEST AND EVALUATION'\n              QRX,'RELEASE MANAGEMENT'\n              CHB,'FINANCIAL MANAGEMENT SYSTEMS'\n              CFB,'FINANCIAL MANAGEMENT SYSTEMS'\n              CFC,'FINANCIAL MANAGEMENT SYSTEMS'\n              CHM,'DEPOT MAINTENANCE MANAGEMENT SYSTEMS'\n              CHQ,'TECHNICAL DATA SYSTEMS'\n              CHC,'TECHNICAL DATA SYSTEMS'\n              CHL,'TECHNICAL DATA SYSTEMS'\n              CLP,'ASSET MANAGEMENT SYSTEMS'\n              CLR,'ASSET MANAGEMENT SYSTEMS'\n              CLD,'REQUIREMENTS MANAGEMENT SYSTEMS'\n              CLE,'REQUIREMENTS MANAGEMENT SYSTEMS'\n              CLF,'PROCUREMENT SECURITY ASSISTANCE'\n              CLG,'PROCUREMENT SECURITY ASSISTANCE'\n              CFP,'PROCUREMENT SECURITY ASSISTANCE'\n              CFR,'PROCUREMENT SECURITY ASSISTANCE'\n              #CR,'LSSC CONTRACTORS'\n              *,'')\n&JCBR = TRANS(TRUNC(&ZUSER,3)\n          TRI,'LS-TD'\n          TRA,'LS-TD'\n          TTC,'LS-TE'\n          TRC,'LS-TT'\n          TTS,'LS-TE'\n          QQX,'LS-TQE'\n          QRX,'LS-TQR'\n          CHB,'LS-BF'\n          CFB,'LS-BF'\n          CFC,'LS-BF'\n          CHM,'LS-BM'\n          CHQ,'LS-BT'\n          CHC,'LS-BT'\n          CHL,'LS-BT'\n          CLP,'LS-BA'\n          CLR,'LS-BA'\n          CLD,'LS-BR'\n          CLE,'LS-BR'\n          CLF,'LS-BP'\n          CLG,'LS-BP'\n          CFP,'LS-BP'\n          CFR,'LS-BP'\n          #CR,'CONTRACTOR'\n          *,'')\n&JCRMNO = TRANS(TRUNC(&ZUSER,3)\n            TRI,'7.103'\n            TRA,'7.103'\n            TRC,'7.105'\n            TTC,'7.105'\n            TTS,'7.103'\n            QQX,'7.204'\n            QRX,'7.105'\n            CHB,'7.300'\n            CFB,'7.300'\n            CFC,'7.300'\n            CHM,'8.103'\n            CHQ,'6.106'\n            CHC,'6.106'\n            CHL,'6.106'\n            CLP,'6.105'\n            CLR,'6.105'\n            CLD,'7.311'\n            CLE,'7.311'\n            CLF,'7.206'\n            CLG,'7.206'\n            CFP,'7.206'\n            CFR,'7.206'\n            #CR,'6.106'\n            *,'')\nIF (&JCBLDG = &Z)\n  &JCBLDG = 'ROBERT A. YOUNG'\nIF (&JCADDR1 = &Z AND\n    &JCADDR2 = &Z AND\n    &JCADDR3 = &Z AND\n    &JCADDR4 = &Z)\n  &JCADDR1 = 'USA LSSC'\n  &JCADDR2 = 'AMSEL-SE-BSD-&JCBR, ROOM &JCRMNO'\n  &JCADDR3 = '1222 SPRUCE STREET'\n  &JCADDR4 = 'ST. LOUIS, MISSOURI  63103-2834'\n)PROC\nVER (&JCPRE,NB)\nVER (&JCSU,NB)\nVER (&JCCLASS,NB)\nVER (&JCMC,NB)\nVER (&JCNAME,NB)\nVER (&JCACC,NB)\nVER (&JCRM,NB)\nVER (&JCPROC,DSNAME)\nVER (&JCJXEQ,NAME)\nVER (&JCJPRT,NAME)\nVPUT (JCPRE,JCSU,JCACC,JCNAME,JCNOTIFY,JCMC,JCRM,\n      JCTIME,JCOTHER1,JCOTHER2,JCOTHER3,JCPROC,JCJXEQ,JCJPRT,\n      JCDEPT,JCBLDG,JCADDR1,JCADDR2,JCADDR3,JCADDR4) PROFILE\n)END\n./ ADD NAME=LOGLIST  0175-98147-98147-0902-00125-00125-00000-PANEL\n)ATTR DEFAULT(%+_)\n       %   TYPE(TEXT) INTENS(HIGH)\n       +   TYPE(TEXT) INTENS(LOW)\n       _   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY\n%---------------------  ISPF LOG/LIST SYSOUT DELIVERY  -------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+ENTER PRINT DELIVERY INSTRUCTIONS:\n    NAME    %===>_LLNAME                                                       +\n    ROOM    %===>_LLROOM                                                       +\n\n    TITLE   %===>_LLTITLE                                                      +\n    BUILDING%===>_LLBLDG                                                       +\n    DEPT.   %===>_LLDEPT                                                       +\n    ADDRESS %===>_LLADDR1                                                      +\n            %===>_LLADDR2                                                      +\n            %===>_LLADDR3                                                      +\n            %===>_LLADDR4                                                      +\n\n+Type a value in each field or blank a field to restore the default value.\n+Press%Enter+to display and save changes.  Use%END key+to save the changes\n+and exit.  Specify%CANCEL+to exit without saving values.\n\n%Note:+ These parameters will take effect during your%next+logon.  The%LOGLIST+\n output descriptor can also be used with the%PRINTDS+command by adding the\n%OUTDES(LOGLIST)+parameter.\n\n)INIT\nIF (&LLTITLE = &Z)\n  &LLTITLE = 'ISPF Log/List'\nIF (&LLBLDG = &Z)\n  &LLBLDG = 'Robert A. Young'\nIF (&LLDEPT = &Z)\n  &LLDEPT = TRANS(TRUNC(&ZUSER,3)\n              TRI,'Data Technologies Division'\n              TRA,'Data Technologies Division'\n              TTC,'Executive Software Division'\n              TRC,'Technical Services Division'\n              TTS,'Technical Services Division'\n              QQX,'Test and Evaluation Branch'\n              QRX,'Release Management Branch'\n              CHB,'Financial Management Systems Division'\n              CFB,'Financial Management Systems Division'\n              CFC,'Financial Management Systems Division'\n              CHM,'Depot Maintenance Management Systems Division'\n              CHQ,'Technical Data Systems Division'\n              CHC,'Technical Data Systems Division'\n              CHL,'Technical Data Systems Division'\n              CLP,'Asset Management Systems Division'\n              CLR,'Asset Management Systems Division'\n              CLD,'Requirements Management Systems Division'\n              CLE,'Requirements Management Systems Division'\n              CLF,'Procurement Security Assistance Division'\n              CLG,'Procurement Security Assistance Division'\n              CFP,'Procurement Security Assistance Division'\n              CFR,'Procurement Security Assistance Division'\n              #CR,'LSSC Contractors'\n              *,'')\n&LLBR = TRANS(TRUNC(&ZUSER,3)\n          TRI,'LS-TD'\n          TRA,'LS-TD'\n          TTC,'LS-TE'\n          TRC,'LS-TT'\n          TTS,'LS-TE'\n          QQX,'LS-TQE'\n          QRX,'LS-TQR'\n          CHB,'LS-BF'\n          CFB,'LS-BF'\n          CFC,'LS-BF'\n          CHM,'LS-BM'\n          CHQ,'LS-BT'\n          CHC,'LS-BT'\n          CHL,'LS-BT'\n          CLP,'LS-BA'\n          CLR,'LS-BA'\n          CLD,'LS-BR'\n          CLE,'LS-BR'\n          CLF,'LS-BP'\n          CLG,'LS-BP'\n          CFP,'LS-BP'\n          CFR,'LS-BP'\n          #CR,'Contractor'\n          *,'')\n&LLRMNO = TRANS(TRUNC(&ZUSER,3)\n            TRI,'7.103'\n            TRA,'7.103'\n            TRC,'7.105'\n            TTC,'7.105'\n            TTS,'7.103'\n            QQX,'7.204'\n            QRX,'7.105'\n            CHB,'7.300'\n            CFB,'7.300'\n            CFC,'7.300'\n            CHM,'8.103'\n            CHQ,'6.106'\n            CHC,'6.106'\n            CHL,'6.106'\n            CLP,'6.105'\n            CLR,'6.105'\n            CLD,'7.311'\n            CLE,'7.311'\n            CLF,'7.206'\n            CLG,'7.206'\n            CFP,'7.206'\n            CFR,'7.206'\n            #CR,'6.106'\n            *,'')\nIF (&LLADDR1 = &Z)\n  &LLADDR1 = 'USA LSSC'\nIF (&LLADDR2 = &Z)\n  &LLADDR2 = 'AMSEL-SE-BSD-&LLBR, Room &LLRMNO'\nIF (&LLADDR3 = &Z)\n  &LLADDR3 = '1222 Spruce Street'\nIF (&LLADDR4 = &Z)\n  &LLADDR4 = 'St. Louis, Missouri  63103-2834'\n)PROC\nVER (&LLNAME,NB)\nVER (&LLROOM,NB)\nIF (&ZCMD = 'can','cancel','CAN','CANCEL')\nELSE\n  VPUT (LLNAME,LLROOM,LLTITLE,LLBLDG,LLDEPT,\n        LLADDR1,LLADDR2,LLADDR3,LLADDR4) PROFILE\n)END\n./ ADD NAME=PDSFTP   0141-89172-98104-1114-00027-00014-00000-PANEL\n)ATTR\n       \u00ac   TYPE(INPUT) INTENS(NON)  CAPS(OFF) JUST(LEFT)\n       $   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n)BODY WINDOW(66,9)\n%COMMAND ===>_ZCMD                               +\n+\n+FTP Command Parameters:\n+   Node     %===>$FTPNODE                                       +\n+   User     %===>$FTPUSER                                       +\n+   Password %===>\u00acFTPPASS                                       +\n+   Directory%===>$FTPDIR                                        +\n+   Local DSN%===>_FTPPINDS                                      +\n+   Tcpip    %===>_FTPTCP+         (KNET or IBM)\n)INIT\n  .CURSOR = FTPNODE\n  .HELP   = PDSFTPT\n  &ZHTOP  = PDSFTPT\n  &ZWINTTL = 'MVS TCP/IP File Transfer Protocol'\n  &ZCMD=' '\n  IF (&FTPTCP = '')\n    &FTPTCP = 'KNET'\n)PROC\n  VER(&FTPNODE,NB)\n  VER(&FTPUSER,NB)\n  VER(&FTPTCP,NB,LIST,KNET,IBM)\n  VPUT (FTPNODE FTPUSER FTPPASS FTPDIR FTPTCP) PROFILE\n)END\n./ ADD NAME=PDSFTPLM 0103-97059-97101-1026-00026-00031-00000-PANEL\n)ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)\n  | AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n  + TYPE(TEXT) INTENS(LOW)\n  \u00da TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) PAD(0)\n 01 TYPE(DATAIN) INTENS(HIGH) CAPS(ON)\n 02 TYPE(DATAOUT) INTENS(LOW)\n 03 TYPE(DATAIN)  INTENS(HIGH) CAPS(ON)\n 04 TYPE(DATAOUT)  INTENS(LOW)\n 05 TYPE(DATAOUT)  INTENS(HIGH)\n 06 TYPE(DATAOUT)  INTENS(LOW)\n)BODY WIDTH(80)\n%Member List -- &ZDSN --------------------------------------%ROW\u00daZMLCR%OF\u00daZMLTR+\n%Command ===>_ZCMD                                            %Scroll ===>_Z   +\n%Commands:      LOCATE, RESET, SELECT, SORT, HELP                              +\n%Line commands: / or S = Put, B = Browse, V = View                             +\n&ZMLCOLS\n|ZDATA ------------------------------------------------------------------------|\n|                                                                              |\n| -----------------------------------------------------------------------------|\n)INIT\n  .ZVARS = 'ZSCML'         /* SCROLL AMT VARIABLE NAME  */\n  .HELP = ISR01130\n)PROC\n  VPUT (ZSCML) PROFILE\n)END\n./ ADD NAME=PDSFTPT  0106-97105-98106-1340-00084-00100-00000-PANEL\n)Panel Keylist(ISPHelp,ISP)\n)Attr Default(%+_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   @ type( input) intens(high) caps(on ) just(left ) pad('_') color(turq)\n   ! type(output) intens(high) caps(off) just(asis ) color(white)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(turq)\n   % type(text) intens(high)\n   + type(text  ) intens(low )\n     skip(on)\n   # area(SCRL) Extend(ON)\n)Body\n+--------------------------%MVS TCP/IP FTP Tutorial+----------------------------\n%Command ===>_zcmd\n%\n+ This ISPF Dialog is designed to use the IBM or Knet TCP/IP File\n+ Transfer Protocol (FTP) for transferring files from the current MVS\n+ system to another TCP/IP enabled system.\n                                                                  %Up F10 Dn F11\n#help -------------------------------------------------------------------------#\n)Area Help\n+\n+ %Fields                   Description\n+ ~                       +\n+ ~Node                   +This is the TCP/IP Name (or IP Address) of the\n+ ~                       +target system that the Local Data Set is to be\n+ ~                       +transferred to.\n+ ~                       +\n+ ~Userid                 +This is your userid that will be used by FTP\n+ ~                       +when it logs into the target host.\n+ ~                       +\n+ ~                       +Note: the userid field is case sensitive to\n+ ~                       +support accessing workstations that allow mixed\n+ ~                       +case userids.\n+ ~                       +\n+ ~Password               +This is the password for the specified Userid of\n+ ~                       +the target host system.  The password is not\n+ ~                       +displayed for security reasons.\n+ ~                       +\n+ ~                       +Note: the password field is case sensitive to\n+ ~                       +support accessing workstations that allow mixed\n+ ~                       +case passwords.\n+ ~                       +\n+ ~Directory              +This is the remote working directory that will be\n+ ~                       +changed to after logging into the target host.\n+ ~                       +\n+ ~Local DSN              +This is the data set name of the data set that\n+ ~                       +is to be transmitted.\n+ ~                       +\n+ ~                       +If a local dataset name is entered on the panel,\n+ ~                       +then PUT subcommands will be generated by the\n+ ~                       +dialog and FTP will be invoked in a batch mode.\n+ ~                       +Otherwise, FTP will be invoked in it's normal\n+ ~                       +interactive mode where any subcommand can be\n+ ~                       +issued.\n+ ~                       +\n+ ~                       +When a PDS dataset name is entered, a member list\n+ ~                       +will be displayed.  Members selected for PUT will\n+ ~                       +have a foreign file name generated in the form of\n+ ~                       +'mbr.llq' where 'mbr' is the PDS member name and\n+ ~                       +'llq' is the 1st 3 characters of the MVS low level\n+ ~                       +qualifier.\n+ ~                       +\n+ ~                       +When a sequential dataset name is entered, the\n+ ~                       +foreign file name will be generated as 'llq'.  If\n+ ~                       +a PDS member name is entered in parenthesis (a\n+ ~                       +sequential file) then the name is generated as\n+ ~                       +'mbr.llq'.  If a wild card '*' character is used\n+ ~                       +as part of the PDS member name, then MPUT will be\n+ ~                       +used and the foreign file names will be the same\n+ ~                       +as the PDS member names.\n+ ~                       +\n+ ~Tcpip                  +This is the flavor of the client MVS TCP/IP that\n+ ~                       +is to be used (Knet or IBM).  The Knet client\n+ ~                       +supports the STRIP command which strips trailing\n+ ~                       +blanks from records before sending them.  This\n+ ~                       +reduces transfer time and files created on the\n+ ~                       +target host require less space.\n+ ~                       +\n)Init\n  .cursor = zcmd\n  &rfind = PFK(RFIND)\n)Proc\n)End\n./ ADD NAME=SHOWCUTP 0104-98168-98168-0822-00012-00012-00000-PANEL\n)ATTR\n @ TYPE(OUTPUT) INTENS(LOW)\n \u00ac TYPE(TEXT) SKIP(ON) INTENS(LOW)\n)BODY\n%BROWSE    Cut Table '&CT' -----------------------------------------------------\n%Command ===>_ZCMD                                          \u00ac%Scroll ===>_ZSCBR+\n+******************************** Top of Data **********************************\n)MODEL\n@CTPT\n)INIT\n)PROC\n)END\n./ ADD NAME=SORTWORK 0101-93055-93055-0933-00032-00031-00000-PANEL\n)ATTR\n  \u00ac   TYPE(OUTPUT)  INTENS(HIGH)\n)BODY\n%--------------------------- SORTWORK CALCULATION ------------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+ENTER SORTWORK INFORMATION:\n    DEVICE TYPE        %===>_DTYP+         (3330, 3350, 3380, or 3390)\n    LOGICAL RECORD SIZE%===>_LRECL+\n    NUMBER OF RECORDS  %===>_NUMREC    +\n    NUMBER OF SORTWORKS%===>_Z +           (Blank defaults to 3)\n\n\n+CALCULATION RESULTS:\n    TRACKS REQ'D PER SORTWORK%===>\u00acTTRKSW      +\n    CYLS   REQ'D PER SORTWORK%===>\u00acTCYLSW      +\n    TOTAL TRACKS REQ'D       %===>\u00acTTRK        +\n    TOTAL CYLS   REQ'D       %===>\u00acTCYL        +\n)INIT\n.ZVARS = '(NUMSW)'\n.CURSOR = DTYP\n)PROC\n IF (&DTYP = &Z)\n   &DTYP = 3330\n VER (&DTYP,LIST,3330,3350,3380,3390)\n VER (&LRECL,NB,RANGE,1,32760)\n VER (&NUMREC,NB,NUM)\n IF (&NUMSW = &Z)\n   &NUMSW = 3\n VER (&NUMSW,RANGE,1,32)\n VPUT (DTYP, LRECL, NUMREC, NUMSW) PROFILE\n)END\n./ ADD NAME=SYSLOG   0130-89240-95103-1420-00024-00035-00000-PANEL\n%------------------------------- BROWSE SYSLOG ---------------------------------\n%COMMAND ===>_ZCMD                                                             +\n%\n+SYSLOG DATASET INFORMATION:\n+   DAY OF WEEK       %===>_Z  +   (\"*\" for active SYSLOG, or\n+                                    MON/TUE/WED/THU/FRI/SAT/SUN/ALL\n+                                    for spooled IOF SLAM memos)\n+\n+   SYSLOG DISPLAY PGM%===>_Z   +  (IOF or SDSF)\n+\n)INIT\n.ZVARS = '(LOGDAY LOGPGM)'\n.CURSOR = LOGDAY\nIF (&LOGPGM = ' ')\n  &LOGPGM = 'IOF'\n)PROC\nVER(&LOGDAY,NB,LIST,*,SUN,MON,TUE,WED,THU,FRI,SAT,ALL)\nVER(&LOGPGM,NB,LIST,IOF,SDSF)\n&ZEDSMSG = 'QUE?'\n&ZEDLMSG = 'SDSF CAN ONLY BROWSE THE ACTIVE SYSLOG'\nIF (&LOGPGM = 'SDSF')\n  VER (&LOGDAY,NB,LIST,*,MSG=ISRZ001)\nVPUT (LOGDAY LOGPGM) PROFILE\n)END\n./ ADD NAME=TRAPTBL  0130-91101-91170-0910-00014-00017-00000-PANEL\n)ATTR\n! TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(ASIS)\n)BODY\n%----------------------- '&TSOCMD' COMMAND OUTPUT ------------------------------\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_AMT +\n%\n)MODEL\n!Z\n)INIT\n.CURSOR = ZCMD\n.ZVARS = '(CMDLINE)'\n&AMT=CSR\n)PROC\n)END\n./ ADD NAME=TRICMDS  0170-89340-98106-1342-00033-00025-00000-PANEL\n)ATTR\n  # AREA(SCRL) EXTEND(ON)\n)BODY\n%TUTORIAL ------------------- ISPF COMMANDS --------------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n+\n+  The following ISPF commands have been implemented by Data Technologies\n+  and are available from the ISPF command line.\n                                                                  %Up F10 Dn F11\n#CMDAREA ----------------------------------------------------------------------#\n)AREA CMDAREA\n    %CALC    +- Invoke calculator:  \"CALC 59902*1.0309\"\n    %CLONE   +- Decomp a logonid record into INSERT format\n    %CODE    +- Display ABEND code reason:  \"CODE 0C7\"\n    %COMMANDS+- Display explanations of LSSC added ISPF commands\n    %EBROWSE +- Edit/Browse by the numbers from a menu of datasets\n    %FTP     +- Invoke FTP dialog (pop-up)\n    %IOF     +- Invoke JES2 Interactive Output Facility (IOF)\n    %ISF     +- Invoke System Display and Search Facility (SDSF)\n    %JOBS    +- Display Data Technologies key jobs\n    %LOGLIST +- Specify ISPF LOG/LIST sysout delivery instructions\n    %MACROS  +- Display explanations of LSSC Edit macros\n    %MSG     +- SEND command:  \"MSG 'TESTING 1,2,3...' U(*)\"\n    %PRIM    +- Hold at current screen and display Primary Option Menu\n    %RESETID +- Reduce ACF2 password violation count to 0\n    %SDSF    +- Invoke System Display and Search Facility (SDSF)\n    %SPACE   +- Display DASD free space statistics\n    %SYSLOG  +- Display previous or current SYSLOG dataset\n    %TEST    +- Invoke ISPF Dialog Test\n    %TRAP    +- Trap TSO command output and display in ISPF table:  \"TRAP LISTC\"\n    %USERIDS +- Display TSO Userid/Name list\n)PROC\n)END\n./ ADD NAME=TRIJOBS  0185-91268-99089-0808-00134-00022-00000-PANEL\n)ATTR\n    $ TYPE(PS)\n)BODY WINDOW(60,21)\n%                       Display Jobs                       +\n%Option ===>_ZCMD                                          +\n+\n   $A+ MAES    - Multiple Aion Execution System\n   $C+ CICS    - Customer Information and Control System\n   $F+ KNET    - Knet/MVS\n   $FF+KNET    - Knet/MVS FTP Servers\n   $K+ KEYPLUS - Keyplus\n   $L+ LOGSHR  - DMR Log and Shared File Update\n   $M+ M204    - Model 204\n   $N+ SQL     - Oracle SQL*Net\n   $O+ ORACLE  - Oracle Server Manager\n   $Q+ CDMR    - Cyclic Data Management Routines\n   $S+ S2K     - System 2000\n   $R+ DRI     - Data Routing Interface\n   $T+ TCPIP   - TCP/IP for MVS\n   $TF+TCPIP   - TCP/IP FTP Servers\n   $U+ USERS   - TSO/CICS Logons\n   $W + WW     - Web3270 Server\n%\n+Spool Display Program%===>_Z   +          (IOF or SDSF)\n)INIT\n.ZVARS = '(SPOOLPGM)'\nIF (&SPOOLPGM = ' ')\n  &SPOOLPGM = 'IOF'\n)PROC\nVER(&SPOOLPGM,NB,LIST,IOF,SDSF)\nIF (&SPOOLPGM = 'IOF')\n  &TEMP = TRUNC(&ZCMD,'.')\n  &JUMP = .TRAIL\n  IF (&JUMP = '')\n    &JUMP = EXTEND\n  &ZSEL = TRANS(TRUNC(&ZCMD,'.')\n          A,'PGM(IOFSPF) PARM(.MAES*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          C,'PGM(IOFSPF) PARM(.CICS*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          F,'PGM(IOFSPF) PARM(.KNET*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n         FF,'PGM(IOFSPF) PARM(.FTPSRV*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          K,'PGM(IOFSPF) PARM(.KEY*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          L,'PGM(IOFSPF) PARM(.++NDM*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          M,'PGM(IOFSPF) PARM(.M204*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          N,'PGM(IOFSPF) PARM(.TNS*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          O,'PGM(IOFSPF) PARM(.ORAM*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          Q,'PGM(IOFSPF) PARM(.++CDMRS.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          R,'PGM(IOFSPF) PARM(.DRI*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          S,'PGM(IOFSPF) PARM(.S2K*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          T,'PGM(IOFSPF) PARM(.TCPIP*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n         TF,'PGM(IOFSPF) PARM(.EZAFT*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          U,'PGM(IOFSPF) PARM(.TSOLOG*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n          W,'PGM(IOFSPF) PARM(.WEB*.&JUMP) +\n             NEWAPPL(IOF) PASSLIB NOCHECK'\n              ' ',' '\n              '*','?')\nIF (&SPOOLPGM = 'SDSF')\n  IF (&ZCMD = '')\n    .MSG = ISPD240   /* Enter option */\n  IF (&ZCMD = 'A','C','D','F','FF','K','L','M','N','O','Q','R','S',\n              'T','TF','U','W')\n  ELSE\n    .MSG = ISPD241   /* Invalid option */\n  IF (&ZCMD = 'A')\n    &ISFPREFX = 'MAES*'\n  IF (&ZCMD = 'C')\n    &ISFPREFX = 'CICS*'\n  IF (&ZCMD = 'F')\n    &ISFPREFX = 'KNET*'\n  IF (&ZCMD = 'FF')\n    &ISFPREFX = 'FTPSRV*'\n  IF (&ZCMD = 'K')\n    &ISFPREFX = 'KEY*'\n  IF (&ZCMD = 'L')\n    &ISFPREFX = '*NDM*'\n  IF (&ZCMD = 'M')\n    &ISFPREFX = 'M204*'\n  IF (&ZCMD = 'N')\n    &ISFPREFX = 'TNS*'\n  IF (&ZCMD = 'O')\n    &ISFPREFX = 'ORAM*'\n  IF (&ZCMD = 'Q')\n    &ISFPREFX = '*CDMRS'\n  IF (&ZCMD = 'R')\n    &ISFPREFX = 'DRI*'\n  IF (&ZCMD = 'S')\n    &ISFPREFX = 'S2K*'\n  IF (&ZCMD = 'T')\n    &ISFPREFX = 'TCPIP*'\n  IF (&ZCMD = 'TF')\n    &ISFPREFX = 'EZAFT*'\n  IF (&ZCMD = 'U')\n    &ISFPREFX = 'TSOLOG*'\n  IF (&ZCMD = 'W')\n    &ISFPREFX = 'WEB*'\n  VPUT (ISFPREFX) ASIS\n  /* Don't use NEWAPPL(ISF) or ISFPREFX will not be passed correctly */\n  IF (&ZCMD = 'U')\n    &ZSEL = 'PGM(ISFISP) PARM(H)' /* Only \"held\" output */\n  ELSE\n    &ZSEL = 'PGM(ISFISP) PARM(DA)'\nVPUT (SPOOLPGM) PROFILE\n)PNTS\nFIELD(ZPS00001) VAR(ZCMD) VAL(A)\nFIELD(ZPS00002) VAR(ZCMD) VAL(C)\nFIELD(ZPS00003) VAR(ZCMD) VAL(F)\nFIELD(ZPS00004) VAR(ZCMD) VAL(FS)\nFIELD(ZPS00005) VAR(ZCMD) VAL(K)\nFIELD(ZPS00006) VAR(ZCMD) VAL(L)\nFIELD(ZPS00007) VAR(ZCMD) VAL(M)\nFIELD(ZPS00008) VAR(ZCMD) VAL(N)\nFIELD(ZPS00009) VAR(ZCMD) VAL(O)\nFIELD(ZPS00010) VAR(ZCMD) VAL(Q)\nFIELD(ZPS00011) VAR(ZCMD) VAL(S)\nFIELD(ZPS00012) VAR(ZCMD) VAL(R)\nFIELD(ZPS00013) VAR(ZCMD) VAL(T)\nFIELD(ZPS00014) VAR(ZCMD) VAL(TS)\nFIELD(ZPS00015) VAR(ZCMD) VAL(U)\nFIELD(ZPS00016) VAR(ZCMD) VAL(W)\n)END\n./ ADD NAME=TRIMACS  0120-93312-98106-1342-00058-00042-00000-PANEL\n)ATTR\n  # AREA(SCRL) EXTEND(ON)\n)BODY\n%TUTORIAL ---------------------- EDIT MACROS -------------------------- TUTORIAL\n%OPTION  ===>_ZCMD                                                             +\n+\n+  The following macros have been implemented by Data Technologies and are\n+  are available when using ISPF Edit.  The macros may be selected by name for a\n+  more detailed explanation:\n                                                                  %Up F10 Dn F11\n#MACAREA ----------------------------------------------------------------------#\n)AREA MACAREA\n    %ACFCOMP +- Compile the ACF2 rule currently being edited\n    %ACFTRAP +- Queue ACF subcommands and trap output\n    %ASA2PC  +- Convert ASA printer control to ASCII code\n    %BROWSE4 +- Invoke ISPF Browse/View while in edit\n    %EOL     +- Set cursor at end of current screen line\n    %FX      +- Find ALL 'string' after EXCLUDE ALL\n    %FXC     +- Find ALL 'string @ cursor' after EXCLUDE ALL\n    %GO      +- Submit job and then invoke IOF\n    %IDCAMS  +- Execute IDCAMS commands currently being edited\n    %JC      +- Build a JOB card sequence at the beginning of a member\n    %LISTDSI +- Display data set information in Option 3.2 format\n    %MEMLIST +  Display member list of the current PDS\n    %OPER    +- Issue canned MVS/JES2 operator commands via SDSF\n    %PLUG    +- Plug data into a range of lines at a given column\n    %PROFSET +- Mass change all edit profiles for an ISPF application\n    %RUN     +- EXECute the CLIST/EXEC currently being edited\n    %RUNACF  +- Issue ACF subcommands currently being edited\n    %SHOWCUT +- Browse the ISPF cut table (PDS 8.4 version)\n    %TESTACF +- Test ACF2 rules based on DSN= values in JCL\n    %UNX     +- Show the first n line(s) from each X-cluded block\n    %WEAVE   +- Interlace data from CUT table into a range of lines\n)INIT\n)PROC\n   &ZSEL = TRANS(&ZCMD\n                ACFCOMP,*#ACFCOMP\n                ACFTRAP,*#ACFTRAP\n                ASA2PC,*#ASA2PC\n                BROWSE4,*#BROWSE4\n                EOL,*#EOL\n                FX,*#FX\n                FXC,*#FXC\n                GO,*#GO\n                JC,*#JC\n                LISTDSI,*#LISTDSI\n                MEMLIST,*#MEMLIST\n                OPER,*#OPER\n                PLUG,*#PLUG\n                PROFSET,*#PROFSET\n                RUN,*#RUN\n                RUNACF,*#RUNACF\n                SHOWCUT,*#SHOWCUT\n                TESTACF,*#TESTACF\n                UNX,*#UNX\n                WEAVE,*#WEAVE\n                )\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXX": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x10/\\x00\\x99\\x10/\\t)\\x0c\\x87\\x0c\\x87\\x00\\x00\\xd9\\xc5\\xe7@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-04-12T00:00:00", "modifydate": "1999-04-12T09:29:00", "lines": 3207, "newlines": 3207, "modlines": 0, "user": "REX"}, "text": "./ ADD NAME=ACFCOMP  0129-95291-98280-1333-00094-00042-00000-REXX\n/* REXX */\nADDRESS ISREDIT\n\"ISREDIT MACRO (PARM)\"\nTRACE\nIF TRANSLATE(parm) = 'HELP' |,\n   parm = '?' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#ACFCOMP)\"\n    EXIT 0\n  END\n\n\"ISREDIT SAVE\"\n\"ISREDIT (MEM) = MEMBER\"\n\"ISREDIT (DS) = DATASET\"\n\nADDRESS TSO\n\"ACFCOMP '\"ds\"(\"mem\")' STORE FORCE\"\n\n/* Resource rule ? */\n\"ISREDIT FIND FIRST 'TYPE('\"\nIF rc = 0 THEN\n  DO\n    \"ISREDIT (LINE) = LINE .ZCSR\"\n     name = 'R'||SUBSTR(line,POS('TYPE(',line)+5,3)\n     show_header = '-- RESIDENT INFOSTORAGE DIRECTORIES --'\n  END\nELSE\n  DO\n    name = mem\n    show_header = '-- RESIDENT ACCESS RULES --'\n  END\n\nQUEUE 'SHOW RESIDENT'\nQUEUE 'END'\nx = OUTTRAP(\"trap.\",\"*\")\nADDRESS TSO\n\"ACF\"\nx= OUTTRAP(\"off\")\n\nshowres = ''\nDO line = 1 to trap.0\n  IF trap.line = show_header THEN\n    DO rar = line+1 to trap.0\n      showres = showres||trap.rar||' '\n      IF trap.rar = '  ' THEN\n        LEAVE line\n    END\nEND\n\nshowres = TRANSLATE(showres,' ',',')   /* Remove commas for WORDPOS */\nIF WORDPOS(name,showres) > 0 THEN\n  DO\n    user_attr = GETATTR()              /* TSO attributes */\n    /* Sysprog? */\n    IF SUBSTR(user_attr,1,4) <> 'OPER' THEN\n      DO\n        zedsmsg = 'Not authorized'\n        zedlmsg = 'You are not authorized to use operator commands'\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n\n    /* Prevent SDSF panel from displaying after operator command */\n    /* with optional mod to panel ISFPANEL or ISFPCU4x           */\n    sdsfoper = 'END'\n    ADDRESS ISPEXEC \"VPUT (SDSFOPER) SHARED\"\n\n    IF WORDPOS('ACCESS',show_header) > 0 THEN\n      DO\n        action = 'RELOAD'\n        resident = 'RESIDENT ACCESS RULE'\n      END\n    ELSE\n      DO\n        /* Remove 'R' from name */\n        name = SUBSTR(name,2)\n        action = 'REBUILD'\n        resident = 'RESIDENT DIRECTORY'\n      END\n\n    /* Leave out NEWAPPL(ISF) or sdsfoper variable not passed */\n    ADDRESS ISPEXEC,\n      \"SELECT PGM(ISFISP) PARM(/F ACF2,\"action\"(\"name\"))\"\n    zedsmsg = 'ACF2 'action' issued'\n    zedlmsg = 'ACF2 'action' issued for 'resident name\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n  END\nEXIT\n\n/* Source:  CBT Mods tape, Michael Botos  042685             */\n/* J. KALINICH, X4521 */\n/* Edit macro to compile the ACF2 rule being edited          */\n/* Issue \"F ACF2,RELOAD(rule)\" or \"F ACF2,REBUILD(dir)\"      */\n/* if rule is in the SHOW RESIDENT list                      */\n./ ADD NAME=ACFTRAP  0166-96068-97113-1411-00070-00040-00000-REXX\n/* REXX */\nTRACE\nADDRESS ISREDIT\n\"ISREDIT MACRO (PARM) NOPROCESS\"\n\nparm = TRANSLATE(parm)\nIF parm = \"HELP\" |,\n   parm = \"?\" THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#ACFTRAP)\"\n    EXIT 0\n  END\n\nline = 1\nDO FOREVER\n  IF RIGHT(STRIP(input,T),1) = \"-\" THEN\n    NOP          /* continuation, don't prompt */\n  ELSE\n    SAY ACF.     /* new subcommand, prompt */\n  PARSE PULL input\n  IF TRANSLATE(input) = \"END\" THEN\n    LEAVE\n  acf_cmds.line = input\n  line = line + 1\nEND\ncommand_count = line - 1\n\nDO line = 1 TO command_count\n  QUEUE acf_cmds.line\nEND\nQUEUE \"END\"\n\nx = OUTTRAP(\"trap.\",\"*\")\nADDRESS TSO\n\"ACF\"\nIF rc > 0 THEN\n  DO\n    zedsmsg = \"rc=\"rc\n    zedlmsg = \"ACF command processor set a return code of \"rc\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n  END\nx= OUTTRAP(\"off\")\n\nIF parm = \"DATA\" |,\n   parm = \"NOTE\" THEN\n  NOP\nELSE\n  parm = \"NOTE\"\n\n\"ISREDIT (TOP) = DISPLAY_LINES\"\nIF rc > 4 THEN\n  top = '0'\n\nDO line = trap.0 TO 1 BY -1\n  acfout = trap.line\n  \"ISREDIT LINE_AFTER \"top\" = \"parm\"LINE (acfout)\"\nEND\n\"ISREDIT LINE_AFTER \"top\" = MSGLINE 'ACF OUTPUT:'\"\nDO line = command_count TO 1 BY -1\n  acfin = acf_cmds.line\n  \"ISREDIT LINE_AFTER \"top\" = NOTELINE (acfin)\"\nEND\n\"ISREDIT LINE_AFTER \"top\" = MSGLINE 'ACF INPUT:'\"\n\n\"ISREDIT LOCATE \"top\n\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO QUEUE ACF SUBCOMMANDS, TRAP OUTPUT FROM ACF,      */\n/*  AND WRITE TO \"=NOTE=\" OR \"DATA\" LINES                          */\n./ ADD NAME=ASA2PC   0120-96068-96082-0630-00044-00040-00000-REXX\n/* REXX */\nTRACE\nADDRESS ISREDIT\n\"ISREDIT MACRO (PARM) NOPROCESS\"\nIF TRANSLATE(parm) = 'HELP' |,\n   parm = '?' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#ASA2PC)\"\n    EXIT 0\n  END\n\"ISREDIT (DSN) = DATASET\"\nrc = LISTDSI(\"'\"dsn\"'\" NORECALL)\nIF sysreason > 0 THEN\n  DO\n    ADDRESS ISPEXEC\n    zedsmsg = 'LISTDSI reason code 'sysreason\n    zedlmsg = 'Look up LISTDSI reason code'\n    \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n    \"ISPEXEC SELECT PGM(QWIKREF1) PARM(T=LISTDSI) NEWAPPL(QWRF)\"\n    EXIT sysreason\n  END\nIF POS('A',sysrecfm) > 0 THEN\n  DO\n    \"ISREDIT CHANGE ALL '1' X'0C' 1\"        /* SKIP TO NEW PAGE */\n/*--\"ISREDIT CHANGE ALL ' ' X'..' 1\"        /* SPACE 1 LINE  */--*/\n    \"ISREDIT CHANGE ALL '0' X'0D25' 1\"      /* SPACE 2 LINES */\n    \"ISREDIT CHANGE ALL '-' X'0D250D25' 1\"  /* SPACE 3 LINES */\n\n    \"ISREDIT EXCLUDE ALL\"\n    \"ISREDIT FIND ALL '+' 1\"                /* SUPPRESS SPACE */\n    \"ISREDIT DELETE ALL NX\"\n    \"ISREDIT RESET EXCLUDED\"\n  END\nELSE\n  DO\n    ADDRESS ISPEXEC\n    zedsmsg = 'No ASA control'\n    zedlmsg = 'Dataset must have ASA print control characters'\n    \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO CONVERT ASA PRINTER CONTROL TO ASCII CODE */\n./ ADD NAME=CEILING  0112-96283-97029-1229-00045-00031-00000-REXX\n/* rexx */\ntrace\nnumeric digits 32\nsay 'ceiling of -0   is 'ceiling(-0)\nsay 'ceiling of  0   is 'ceiling(0)\nsay 'ceiling of -1   is 'ceiling(-1)\nsay 'ceiling of  1   is 'ceiling(1)\nsay 'ceiling of  1.0 is 'ceiling(1.0)\nsay 'ceiling of  1.1 is 'ceiling(1.1)\nsay 'ceiling of  1.2 is 'ceiling(1.2)\nsay 'ceiling of  1.3 is 'ceiling(1.3)\nsay 'ceiling of  1.4 is 'ceiling(1.4)\nsay 'ceiling of  1.5 is 'ceiling(1.5)\nsay 'ceiling of  1.6 is 'ceiling(1.6)\nsay 'ceiling of  1.7 is 'ceiling(1.7)\nsay 'ceiling of  1.8 is 'ceiling(1.8)\nsay 'ceiling of  1.9 is 'ceiling(1.9)\nsay 'ceiling of -1.0 is 'ceiling(-1.0)\nsay 'ceiling of -1.1 is 'ceiling(-1.1)\nsay 'ceiling of -1.2 is 'ceiling(-1.2)\nsay 'ceiling of -1.3 is 'ceiling(-1.3)\nsay 'ceiling of -1.4 is 'ceiling(-1.4)\nsay 'ceiling of -1.5 is 'ceiling(-1.5)\nsay 'ceiling of -1.6 is 'ceiling(-1.6)\nsay 'ceiling of -1.7 is 'ceiling(-1.7)\nsay 'ceiling of -1.8 is 'ceiling(-1.8)\nsay 'ceiling of -1.9 is 'ceiling(-1.9)\nsay 'ceiling of -2.0 is 'ceiling(-2.0)\nsay 'ceiling of -2.1 is 'ceiling(-2.1)\nsay 'ceiling of -2.5456789 is 'ceiling(-2.5456789)\nsay 'ceiling of -2.0000000054567899 is 'ceiling(-2.0000000054567899)\nsay 'ceiling of +2.0000000054567899 is 'ceiling(+2.0000000054567899)\nsay 'ceiling of -3 is 'ceiling(-3)\nexit\n\nceiling: procedure\n/* rexx      smallest integer greater than or equal       */\nparse arg number\nif number > 0 then\n  if (number - trunc(number)) > 0 then\n    number = number + 1\nreturn trunc(number)\n\n/* J. KALINICH, X4521 */\n/* REXX CEILING FUNCTION - SMALLEST INTEGER GREATER THAN OR EQUAL    */\n./ ADD NAME=CLONEID  0155-95137-98300-0925-00144-00056-00000-REXX\n/* REXX */\nTRACE\n\nADDRESS TSO\n\"NEWSTACK\"\nARG modelid\nQUEUE 'LIST 'modelid\nQUEUE 'END'\nx = OUTTRAP(\"lids.\",\"*\")\n\n\"ACF\"\n\nacfrc = rc\nx= OUTTRAP(\"off\")\n\"DELSTACK\"\n\nIF acfrc > 0 THEN\n  DO\n    zedsmsg = 'ACF LIST rc='acfrc\n    zedlmsg = 'List failure, check for misspelled logonid'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\n\n\"NEWSTACK\"\nDO line = 1 TO lids.0\n  SELECT\n    WHEN SUBSTR(lids.line,1,1) \u00ac= ' ' THEN\n      NOP\n    WHEN SUBSTR(lids.line,2,21) = ' ' THEN\n      DO\n\n        /* Add other sections per the ACFFDR specification */\n\n        IF section = 'PRIVILEGES' |,\n           section = 'TSO' |,\n           section = 'CICS' |,\n           section = 'IMS' |,\n           section = 'M204' |,\n           section = 'IDMS' |,\n           section = 'MUSASS' |,\n           section = 'RESTRICTIONS' |,\n           section = 'DFP' |,\n           section = 'KEYPLUS' THEN\n        CALL lid_fields\n      END\n    WHEN SUBSTR(lids.line,2,8) = SUBSTR(lids.line,30,8) THEN\n      DO\n        logonid = STRIP(SUBSTR(lids.line,2,9))\n        name    = STRIP(SUBSTR(lids.line,47,20))\n        phone   = STRIP(SUBSTR(lids.line,68,12))\n        QUEUE \"INSERT \"logonid\" NAME(\"name\") PHONE(\"phone\") -\"\n        line = line + 1\n        QUEUE \"  \"STRIP(lids.line)\" -\"\n      END\n    WHEN SUBSTR(lids.line,2,14) = 'CANCEL/SUSPEND' THEN\n      DO\n        section = STRIP(SUBSTR(lids.line,2,21))\n        QUEUE \"  SUSPEND -\"\n      END\n    WHEN SUBSTR(lids.line,2,6)  = 'ACCESS' THEN\n      section = STRIP(SUBSTR(lids.line,2,21))\n    WHEN SUBSTR(lids.line,2,8)  = 'PASSWORD' THEN\n      DO\n        section = STRIP(SUBSTR(lids.line,2,21))\n        PARSE VAR lids.line 23 maxdays mindays .\n        lineout = ''\n        IF POS('DAYS',maxdays) > 0 THEN\n          lineout = lineout' '||maxdays\n        IF POS('DAYS',mindays) > 0 THEN\n          lineout = lineout' '||mindays\n        IF lineout \u00ac = '' THEN\n          QUEUE \"  \"STRIP(lineout)\" -\"\n      END\n    WHEN SUBSTR(lids.line,2,10) = 'STATISTICS' THEN\n      section = STRIP(SUBSTR(lids.line,2,21))\n\n    /* Add WHEN code per the ACFFDR specification */\n\n    WHEN SUBSTR(lids.line,2,10) = 'PRIVILEGES' |,\n         SUBSTR(lids.line,2,3)  = 'TSO' |,\n         SUBSTR(lids.line,2,4)  = 'CICS' |,\n         SUBSTR(lids.line,2,3)  = 'IMS' |,\n         SUBSTR(lids.line,2,4)  = 'M204' |,\n         SUBSTR(lids.line,2,4)  = 'IDMS' |,\n         SUBSTR(lids.line,2,6)  = 'MUSASS' |,\n         SUBSTR(lids.line,2,12) = 'RESTRICTIONS' |,\n         SUBSTR(lids.line,2,3)  = 'DFP' |,\n         SUBSTR(lids.line,2,7)  = 'KEYPLUS' THEN\n      DO\n        section = STRIP(SUBSTR(lids.line,2,21))\n        CALL lid_fields\n      END\n    OTHERWISE\n      NOP\n  END\nEND\n\nIF password = 'NO' THEN\n  QUEUE \" \"\nELSE\n  QUEUE \"  PASSWORD(OPENSESAME)\"\n\nADDRESS TSO\n\"ALLOC F(CLONEID) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS\",\n  \"LRECL(80) RECFM(F B) BLKSIZE(0)\"\nQUEUE\n\"EXECIO * DISKW CLONEID (FINIS\"\n\"DELSTACK\"\nADDRESS ISPEXEC\n\"ISPEXEC LMINIT DATAID(ID) DDNAME(CLONEID) ENQ(EXCLU)\"\nIF rc \u00ac= 0 THEN\n  DO\n    SAY LMINIT failed\n    EXIT 12\n  END\n\"ISPEXEC EDIT DATAID(\"id\")\"\n\"ISPEXEC LMFREE DATAID(\"id\")\"\n\nEXIT\n\nlid_fields:\nlidflds = WORDS(SUBSTR(lids.line,23))\nIF section = 'PRIVILEGES' THEN\n  DO\n    IF POS(' STC ',SUBSTR(lids.line,23)) > 0 |,\n       POS(' RESTRICT ',SUBSTR(lids.line,23)) > 0 THEN\n      password = 'NO'\n  END\n\nfields = SUBSTR(lids.line,23)\nlineout = ''\nDO count = 1 TO lidflds BY 5\n  DO x = 1 TO 5\n    y = (count + x)  - 1\n    lineout = lineout' '||word(fields,y)\n  END\n  QUEUE \"  \"STRIP(lineout)\" -\"\n  lineout = ''\nEND\nRETURN\n\n/* J. KALINICH, X4521 */\n/* DECOMP a logonid record into INSERT format for cloning  */\n./ ADD NAME=COMPUTE  0127-92149-97216-1415-00049-00068-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       COMPUTE                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Calculator                                           |\n | Release:    MVS/ESA v3.1.3 and TSO/E v2.1                        |\n | Programmer: Norman Pearl                                         |\n |             TSO Times $250 winner, 1992                          |\n | Abstract:   The result of any valid Rexx expression will be      |\n |             displayed in the ISPF message area.                  |\n | Mods:       If no expression is given as an argument, then a     |\n |             pop-up window is displayed that prompts for input    |\n |             (ISPF mode only).                                    |\n +------------------------------------------------------------------+ */\nTRACE\nNUMERIC DIGITS 20  /* M.F. Cowlishaw */\nARG formula\nIF formula = '' &,\n   SYSVAR('SYSISPF') = 'ACTIVE' THEN\n  DO\n    DO WHILE poprc < 8\n      zwinttl = 'Calculator'\n      ADDRESS ISPEXEC \"ADDPOP ROW(3) COLUMN(1)\"\n      ADDRESS ISPEXEC \"DISPLAY PANEL(CALCP)\"\n      poprc = rc\n      ADDRESS ISPEXEC \"REMPOP\"\n      formula = xpreshun\n      INTERPRET 'result = ' formula\n      zedsmsg = result\n      zedlmsg = formula '===>' result\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    END\n    zedsmsg = ''\n    zedlmsg = ''\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ000)\"\n    EXIT\n  END\nINTERPRET 'result = ' formula\nIF SYSVAR('SYSISPF') = 'ACTIVE' THEN\n  DO\n    zedsmsg = result\n    zedlmsg = formula '===>' result\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n  END\nELSE\n  SAY formula '===>' result\nEXIT\n/* J. KALINICH, X4521 */\n/* EXEC TO COMPUTE EXPRESSIONS (from TSO Times)        */\n./ ADD NAME=EDITALL  0103-93074-93362-1417-00045-00047-00000-REXX\n/* ---------------------  rexx procedure  ---------------------- *\n * Name:      Editall                                            *\n *                                                               *\n * Function:  Run an ISPF Edit Macro against every member of     *\n *            a PDS.                                             *\n *                                                               *\n * Syntax:    %Editall dsname edit-macro                         *\n *                                                               *\n * Author:    Lionel B. Dyck                                     *\n *            Rockwell International                             *\n *            P.O. Box 2515                                      *\n *            Seal Beach, California 90740                       *\n *            (310) 797-1125                                     *\n *            IBMMail:  USROKNTN                                 *\n *            IBMLINK:  ROK2027                                  *\n *                                                               *\n * History:   11/30/90 - created                                 *\n *                                                               *\n * ------------------------------------------------------------- */\n\narg dsn exec\n\nif left(dsn,1) <> \"'\" then do\n   dsn = sysvar(syspref)\".\"dsn\n   end\n   else do\n        dsn = substr(dsn,2,length(dsn)-2)\n        end\n\n\nx = outtrap(\"lm.\",\"*\")\n\n\"LISTD\" \"'\"dsn\"'\" \"MEMBERS\"\n\nx = outtrap(\"off\")\n\ndo i = 1 to lm.0\n   if lm.i = \"--MEMBERS--\" then signal domem\n   end\n\ndomem:  do j = i+1 to lm.0\n        parse value lm.j with mem extra\n        Address ISPEXEC \"EDIT DATASET('\"dsn\"(\"mem\")') MACRO(\"exec\")\"\n        end\n\n./ ADD NAME=EOL      0112-93216-96032-0622-00066-00038-00000-REXX\n/* REXX */\nADDRESS ISREDIT\n\"ISREDIT MACRO (HELP)\"\nTRACE\nIF help = '?' |,\n   TRANSLATE(help) = 'HELP' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#EOL)\"\n    EXIT 1\n  END\n\"ISREDIT (CL,CC) = CURSOR\"\nsave_cc = cc\nCALL find_end\n/* If already at EOL, then jump to next line and go to EOL */\nIF save_cc = cc THEN\n  DO\n    cl = cl + 1\n    CALL find_end\n  END\n\"ISREDIT CURSOR = \" cl cc\nEXIT\nfind_end:\n\"ISREDIT (WIDTH) = DATA_WIDTH\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\"ISREDIT (XSTATUS) = XSTATUS\" cl\nIF rc = 0 THEN\n  IF xstatus = \"X\" THEN\n    DO\n      /* Bypass eXcluded lines */\n      \"ISREDIT FIND P'=' 1 NX\"\n      IF rc > 0 THEN\n        DO\n          zedsmsg = '*BOTTOM OF DATA REACHED*'\n          zedlmsg = 'No more lines to process'\n          ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n          EXIT\n        END\n      \"ISREDIT (CL) = CURSOR\"\n    END\n  ELSE\n    NOP\nELSE\n  DO\n    \"ISREDIT CURSOR = \" cl-1 cc\n    zedsmsg = '*BOTTOM OF DATA REACHED*'\n    zedlmsg = 'No more lines to process'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    EXIT\n  END\n\"ISREDIT (LINE) = LINE \" cl\nDO cc = width to 1 by -10     /* backtab 10 for speed */\n  IF SUBSTR(line,cc,10) /= ' ' THEN\n    LEAVE\nEND\ntab_10 = cc + 10              /* tab forward */\nDO cc = tab_10 to 1 by -1     /* backspace 1 */\n  IF SUBSTR(line,cc,1) /= ' ' THEN\n    LEAVE\nEND\nIF cc = width THEN\n  NOP\nELSE\n  cc = cc + 1\nRETURN\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO SET CURSOR AT END OF CURRENT SCREEN LINE          */\n./ ADD NAME=FLOOR    0110-96283-97029-1226-00045-00031-00000-REXX\n/* rexx */\ntrace\nnumeric digits 32\nsay 'floor of -0   is 'floor(-0)\nsay 'floor of  0   is 'floor(0)\nsay 'floor of -1   is 'floor(-1)\nsay 'floor of  1   is 'floor(1)\nsay 'floor of  1.0 is 'floor(1.0)\nsay 'floor of  1.1 is 'floor(1.1)\nsay 'floor of  1.2 is 'floor(1.2)\nsay 'floor of  1.3 is 'floor(1.3)\nsay 'floor of  1.4 is 'floor(1.4)\nsay 'floor of  1.5 is 'floor(1.5)\nsay 'floor of  1.6 is 'floor(1.6)\nsay 'floor of  1.7 is 'floor(1.7)\nsay 'floor of  1.8 is 'floor(1.8)\nsay 'floor of  1.9 is 'floor(1.9)\nsay 'floor of -1.0 is 'floor(-1.0)\nsay 'floor of -1.1 is 'floor(-1.1)\nsay 'floor of -1.2 is 'floor(-1.2)\nsay 'floor of -1.3 is 'floor(-1.3)\nsay 'floor of -1.4 is 'floor(-1.4)\nsay 'floor of -1.5 is 'floor(-1.5)\nsay 'floor of -1.6 is 'floor(-1.6)\nsay 'floor of -1.7 is 'floor(-1.7)\nsay 'floor of -1.8 is 'floor(-1.8)\nsay 'floor of -1.9 is 'floor(-1.9)\nsay 'floor of -2.0 is 'floor(-2.0)\nsay 'floor of -2.1 is 'floor(-2.1)\nsay 'floor of -2.5456789 is 'floor(-2.5456789)\nsay 'floor of -2.0000000054567899 is 'floor(-2.0000000054567899)\nsay 'floor of +2.0000000054567899 is 'floor(+2.0000000054567899)\nsay 'floor of -3 is 'floor(-3)\nexit\n\nfloor: procedure\n/* rexx      largest integer less than or equal       */\nparse arg number\nif number < 0 then\n  if (abs(number) - abs(trunc(number))) > 0 then\n    number = number - 1\nreturn trunc(number)\n\n/* J. KALINICH, X4521 */\n/* REXX FLOOR FUNCTION - LARGEST INTEGER LESS THAN OR EQUAL         */\n./ ADD NAME=GETACCT  0143-92148-96089-1228-00072-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETACCT                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Get job accounting information                       |\n | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/29/96                                              |\n | Abstract:   A sub-function to return the job account number      |\n |                                                                  |\n | Call Format:  GETACCT()                                          |\n |                                                                  |\n | Logic: Extracts address of TCB (PSATOLD at x'21C')               |\n |        Extracts address of JSCB (TCB+x'B4')                      |\n |        Extracts address of JCT prefix (JSCB+x'104')              |\n |        Addresses the JCT (JCT+x'10')                             |\n |        Addresses the ACT (JCT+x'28')                             |\n |        Extracts ACTACCNT                                         |\n +------------------------------------------------------------------+ */\n/* rexx */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ntcb_ptr = get_ptr(21c,0)\njscb_ptr  = get_ptr(tcb_ptr,'b4')\njct_prefix_ptr  = get_ptr(jscb_ptr,'104')\njct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))\nact_ptr = get_ptr3(jct_ptr,'28')\npgmr = get_data(act_ptr,'18',20)\nacct_len = c2d(get_data(act_ptr,'30',1))\nactaccnt = get_data(act_ptr,'31',acct_len)\nexit actaccnt\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_ptr3: procedure\n    /* +-----------------------------------------+\n       | returns a 3 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,3))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE JOB ACCOUNT NUMBER                */\n./ ADD NAME=GETACF2  0134-92148-95325-0738-00066-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETACF2                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Get the ACF2 release identifier                      |\n | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |\n | Programmer: John Kalinich                                        |\n | Date:       10/17/95                                             |\n | Abstract:   A sub-function to return the ACF2 release id         |\n |             from the ACCVT.                                      |\n |                                                                  |\n | Call Format:  GETACF2()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of JESCT (CVT+x'128')                    |\n |        Extracts address of 1st SSCT (JESCT+x'18')                |\n |        Locates the ACF2 SSCT                                     |\n |        Extracts address of ACCVT (SSCT+x'14')                    |\n |        Extracts ACF2 release identifier (ACCVT+x'4F')            |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\njesct_ptr = get_ptr(cvt_ptr,'128')\nsscvt_ptr = get_ptr(jesct_ptr,'18')\ndo while sscvt_ptr \u00ac= '00000000'\n  ssctsnam = get_data(sscvt_ptr,'8',4)\n  if ssctsnam = 'ACF2' then\n    do\n      ssctsuse_ptr = get_ptr(sscvt_ptr,'14')\n      acf2rel = c2x(get_data(ssctsuse_ptr,'4f',1))\n      leave\n    end\n  sscvt_ptr = get_ptr(sscvt_ptr,'4')\nend\nexit substr(acf2rel,1,1)'.'substr(acf2rel,2,1)\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE ACF2 RELEASE IDENTIFIER           */\n./ ADD NAME=GETATTR  0105-93099-93314-0815-00070-00070-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETATTR                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Get the TSO user attributes                          |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       8/24/93                                              |\n | Abstract:   A sub-function to return the TSO user attributes     |\n |             from the Protected Step Control Block                |\n |                                                                  |\n | Call Format:  GETATTR()                                          |\n |                                                                  |\n | Logic: Extracts address of TCB (PSATOLD at x'21C')               |\n |        Extracts address of JSCB (TCB+x'B4')                      |\n |        Extracts address of PSCB (JSCB+x'108')                    |\n |        Tests PSCBATR1, bit 0 for OPERATOR authority              |\n |        Tests PSCBATR1, bit 1 for ACCOUNT  authority              |\n |        Tests PSCBATR1, bit 2 for SUBMIT   authority              |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ntcb_ptr = get_ptr(21c,0)\njscb_ptr  = get_ptr(tcb_ptr,'b4')\npscb_ptr  = get_ptr(jscb_ptr,'108')\npscbatr1 =  get_data(pscb_ptr,'10',1)\nif bitand(pscbatr1,'80'x) = '80'x then\n  oper = 'OPER  '\nelse\n  oper = 'NOOPER'\nif bitand(pscbatr1,'40'x) = '40'x then\n  account = 'ACCOUNT  '\nelse\n  account = 'NOACCOUNT'\nif bitand(pscbatr1,'20'x) = '20'x then\n  submit = 'SUBMIT  '\nelse\n  submit = 'NOSUBMIT'\ntsoattr = oper||account||submit\nexit tsoattr\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE TSO USER ATTRIBUTES               */\n./ ADD NAME=GETCIB   0150-92148-96276-0623-00092-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETCIB                                               |\n | Type:       REXX exec                                            |\n | Purpose:    Get the command verb code from first CIB             |\n | Release:    MVS/ESA v5.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       09/30/96                                             |\n | Abstract:   A sub-function to return the command verb code from  |\n |             the first command input buffer.                      |\n |                                                                  |\n | Call Format:  GETCIB()                                           |\n |                                                                  |\n | Logic: Extracts address of TCB (PSATOLD at x'21C')               |\n |        Extracts the TIOT (TCB+x'0C')                             |\n |        Extracts the JOBNAME (TIOT+x'0')                          |\n |        Extracts the CVT (at x'10')                               |\n |        Extracts the ASVT (CVT+x'22C')                            |\n |        Extracts the Master ASCB (ASVT+x'210')                    |\n |        Extracts the next ASCB (ASCB+x'4')                        |\n |        Extracts the CSCB (ASCB+x'38')                            |\n |        Run the CSCB chain until JOBNAME equal                    |\n |        Extracts the CSCX (CSCB+x'DC')                            |\n |        Extracts the CIB (CSCX+x'0C')                             |\n |        Extracts CIBVERB                                          |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ntcb_ptr = get_ptr(21c,0)\ntiot_ptr = get_ptr(tcb_ptr,'c')\njobname = get_data(tiot_ptr,'0','8')\ncvt_ptr = get_ptr(10,0)\nasvt_ptr = get_ptr(cvt_ptr,'22c')\nmaster_ascb_ptr = get_ptr(asvt_ptr,'210')\nnext_ascb_ptr = get_ptr(master_ascb_ptr,'4')\ncscb_ptr = get_ptr(next_ascb_ptr,'38')\n\ndo while cscb_ptr \u00ac= '00000000'\n  chkey = get_data(cscb_ptr,'8',8)\n  if chkey = jobname then\n    leave\n  cscb_ptr = get_ptr(cscb_ptr,'0')\nend\n\ncscx_ptr = get_ptr(cscb_ptr,'dc')\ncib_ptr = get_ptr(cscx_ptr,'c')\nif cib_ptr = '00000000' then\n  cib_verb = 'NO CIB'\nelse\n  do\n    cib_verb = get_data(cib_ptr,'4','1')\n    if cib_verb = '04'x then\n      cib_verb = 'START'\n    if cib_verb = '08'x then\n      cib_verb = 'STC COMMUNICATION'\n    if cib_verb = '44'x then\n      cib_verb = 'MODIFY'\n    if cib_verb = '40'x then\n      cib_verb = 'STOP'\n    if cib_verb = '0C'x then\n      cib_verb = 'MOUNT'\n  end\nexit cib_verb\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE COMMAND VERB CODE FROM THE 1ST CIB */\n./ ADD NAME=GETCPUM  0120-92148-93314-0815-00052-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETCPUM                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the CVTMDL of the System you are on          |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to extract the cpu model number from  |\n |             the CVT prefix.                                      |\n |                                                                  |\n | Call Format:  GETCPUM()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Addresses the CVTFIX+250 (CVT-x'6')                       |\n |        Extracts CVTMDL                                           |\n +------------------------------------------------------------------+ */\ntrace\n\ncvt_ptr = get_ptr(10,0)\ncvtmdl_ptr = d2x(x2d(cvt_ptr) - x2d(6))\ncvtmdl = c2x(get_data(cvtmdl_ptr,'0',2))\nexit substr(cvtmdl,1,4)\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE CPU MODEL NUMBER                  */\n./ ADD NAME=GETDEST  0140-92148-95325-0840-00055-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETDEST                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Get the TSO default SYSOUT destination               |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       4/09/93                                              |\n | Abstract:   A sub-function to return the TSO user's default      |\n |             SYSOUT destination                                   |\n |                                                                  |\n | Call Format:  GETDEST()                                          |\n |                                                                  |\n | Logic: Extracts address of TCB (PSATOLD at x'21C')               |\n |        Extracts address of JSCB (TCB+x'B4')                      |\n |        Extracts address of PSCB (JSCB+x'108')                    |\n |        Extracts the PSCBDEST                                     |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ntcb_ptr = get_ptr(21c,0)\njscb_ptr  = get_ptr(tcb_ptr,'b4')\npscb_ptr  = get_ptr(jscb_ptr,'108')\ndest = get_data(pscb_ptr,'28',8)\nexit dest\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE TSO DEFAULT SYSOUT DESTINATION    */\n./ ADD NAME=GETDFPL  0123-93032-98091-0857-00053-00056-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETDFPL                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the DFAREL of the System you are on          |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to extract the DFP level from the     |\n |             Data Facilities Area (DFA).                          |\n |                                                                  |\n | Call Format:  GETDFPL()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of DFA (CVT+x'4C0')                      |\n |        Extracts DFAREL                                           |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\ndfa_ptr = get_ptr(cvt_ptr,'4c0')\ndfarel = c2x(get_data(dfa_ptr,'2',2))\nexit substr(dfarel,1,1)'.'substr(dfarel,2,1)'.'substr(dfarel,3,1)\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE DFP LEVEL                         */\n./ ADD NAME=GETGRPN  0125-92148-95003-0744-00056-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETGRPN                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the ACEEGRPN from the RACF ACEE.             |\n | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |\n | Programmer: John Kalinich                                        |\n | Date:       1/3/95                                               |\n | Abstract:   A sub-function to extract connect group name from    |\n |             the RACF Accessor Environment Element.  The ACEE is  |\n |             not fetch protected.  This function works in ACF2    |\n |             systems.                                             |\n |                                                                  |\n | Call Format:  GETGRPN()                                          |\n |                                                                  |\n | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |\n |        Extracts address of ASXB (ASCB+x'6C')                     |\n |        Extracts address of ACEE (ASXB+x'C8')                     |\n |        Extracts ACEEGRPN                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nascb_ptr = get_ptr(224,0)\nasxb_ptr = get_ptr(ascb_ptr,'6c')\nacee_ptr = get_ptr(asxb_ptr,'c8')\naceegrpn = get_data(acee_ptr,'1e',8)\nexit aceegrpn\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE RACF ACEE CONNECT GROUP NAME              */\n./ ADD NAME=GETIPLD  0121-93032-93314-0816-00053-00056-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETIPLD                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the SMCAIDTE of the System you are on        |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/19/93                                              |\n | Abstract:   A sub-function to extract the IPL date from the      |\n |             System Management Control Area (SMCA).               |\n |                                                                  |\n | Call Format:  GETIPLD()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of SMCA (CVT+x'C4')                      |\n |        Extracts SMCAIDTE                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\nsmca_ptr = get_ptr(cvt_ptr,'c4')\nsmcaidte = c2x(get_data(smca_ptr,'154',4))\nexit substr(smcaidte,3,2)'.'substr(smcaidte,5,3)\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE MVS IPL DATE                      */\n./ ADD NAME=GETIPLT  0131-92363-94118-1259-00057-00003-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETIPLT                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the SMCAITME of the System you are on        |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       8/24/93                                              |\n | Abstract:   A sub-function to extract the IPL time from the      |\n |             System Management Control Area (SMCA).               |\n |                                                                  |\n | Call Format:  GETIPLT()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of SMCA (CVT+x'C4')                      |\n |        Extracts SMCAITME                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\nsmca_ptr = get_ptr(cvt_ptr,'c4')\nsmcaitme = c2x(get_data(smca_ptr,'150',4))\ntotal_seconds = x2d(smcaitme) % 100\nseconds = right((total_seconds // 60),2,'0')\nminutes = right(((total_seconds % 60) // 60),2,'0')\nhours   = right(((total_seconds / 60) % 60),2,'0')\nexit hours'.'minutes'.'seconds\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE MVS IPL TIME                      */\n./ ADD NAME=GETJES2  0128-92148-98132-1333-00057-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETJES2                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Get the JES2 product name                            |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to return the JES2 product name       |\n |             from HASPSSSM.                                       |\n |                                                                  |\n | Call Format:  GETJES2()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of JESCT (CVT+x'128')                    |\n |        Extracts address of 1st SSCT (JESCT+x'18')                |\n |        Extracts address of SSCTSUSE (SSCT+x'14')                 |\n |        Extracts JES2 product name from HASPSSSM+x'C'             |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\njesct_ptr = get_ptr(cvt_ptr,'128')\nsscvt_ptr = get_ptr(jesct_ptr,'18')\nhaspsssm_plus12 = get_ptr(sscvt_ptr,'14')\njeslevel = get_data(haspsssm_plus12,'0',8)\nexit jeslevel\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE JES2 PRODUCT LEVEL                */\n./ ADD NAME=GETJOBID 0127-92148-93314-0816-00055-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETJOBID                                             |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the SSIBJBID from the SSIB.                  |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to extract the job id from the        |\n |             Subsystem Identification Block (SSIB).               |\n |                                                                  |\n | Call Format:  GETJOBID()                                         |\n |                                                                  |\n | Logic: Extracts address of TCB (PSATOLD at x'21C')               |\n |        Extracts address of JSCB (TCB+x'B4')                      |\n |        Extracts address of SSIB (JSCB+x'13C')                    |\n |        Extracts the SSIBJBID                                     |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ntcb_ptr = get_ptr(21c,0)\njscb_ptr  = get_ptr(tcb_ptr,'b4')\nssib_ptr  = get_ptr(jscb_ptr,'13c')\nssibjbid = get_data(ssib_ptr,'c',8)\nexit ssibjbid\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE JES2 JOB ID                       */\n./ ADD NAME=GETLPAR  0128-93032-93314-0816-00057-00056-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETLPAR                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the Logical Partition mode (YES or NO)       |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       8/24/93                                              |\n | Abstract:   A sub-function to extract the LPAR mode from the     |\n |             Service Call Control Block (SCCB).                   |\n |                                                                  |\n | Call Format:  GETLPAR()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of SCCP (CVT+x'340')                     |\n |        Tests SCCBCON1, bit 0 for LPAR configuration              |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\nsccb_ptr = get_ptr(cvt_ptr,'340')\nsccbcon1 = get_data(sccb_ptr,'50',1)\nif bitand(sccbcon1,'80'x) = '80'x then\n  lpar = 'YES'\nelse\n  lpar = 'NO'\nexit lpar\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE LOGICAL PARTITION MODE            */\n./ ADD NAME=GETNAME  0107-95297-96094-1425-00059-00057-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETNAME                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract ACEEUNAM from the RACF ACEE.                 |\n | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |\n | Programmer: John Kalinich                                        |\n | Date:       10/24/95                                             |\n | Abstract:   A sub-function to extract the ACEE user name from    |\n |             the RACF Accessor Environment Element.  The ACEE is  |\n |             not fetch protected.  This function works in ACF2    |\n |             systems.                                             |\n |                                                                  |\n | Call Format:  GETNAME()                                          |\n |                                                                  |\n | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |\n |        Extracts address of ASXB (ASCB+x'6C')                     |\n |        Extracts address of ACEE (ASXB+x'C8')                     |\n |        Extracts address of ACEEUNAM (ACEE+x'64')                 |\n |        Extracts ACEEUNAM                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nascb_ptr = get_ptr(224,0)\nasxb_ptr = get_ptr(ascb_ptr,'6c')\nacee_ptr = get_ptr(asxb_ptr,'c8')\nacee_unam_ptr = get_ptr(acee_ptr,'64')\nunam_len = c2d(get_data(acee_unam_ptr,'0',1))\nuser_name = get_data(acee_unam_ptr,'1',unam_len -1)\nexit user_name\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE RACF ACEE USER NAME                       */\n./ ADD NAME=GETPLEX  0129-92148-96220-1232-00052-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETPLEX                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the sysplex name of the System you are on    |\n | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       4/29/96                                              |\n | Abstract:   A sub-function to extract the sysplex name from      |\n |             the Extended CVT.                                    |\n |                                                                  |\n | Call Format:  GETPLEX()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Addresses the ECVT (CVT+x'8C')                            |\n |        Extracts ECVTSPLX                                         |\n +------------------------------------------------------------------+ */\ntrace\n\ncvt_ptr = get_ptr(10,0)\ncvtecvt_ptr = get_ptr(cvt_ptr,'8c')\necvtsplx = get_data(cvtecvt_ptr,'8',8)\nexit ecvtsplx\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE SYSPLEX NAME                      */\n./ ADD NAME=GETPRGNM 0143-92148-96089-1227-00070-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETPRGNM                                             |\n | Type:       REXX exec                                            |\n | Purpose:    Get programmer name                                  |\n | Release:    MVS/ESA v4.3.0 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/29/96                                              |\n | Abstract:   A sub-function to return the programmer name         |\n |                                                                  |\n | Call Format:  GETPRGNM()                                         |\n |                                                                  |\n | Logic: Extracts address of TCB (PSATOLD at x'21C')               |\n |        Extracts address of JSCB (TCB+x'B4')                      |\n |        Extracts address of JCT prefix (JSCB+x'104')              |\n |        Addresses the JCT (JCT+x'10')                             |\n |        Addresses the ACT (JCT+x'28')                             |\n |        Extracts ACTPRGNM                                         |\n +------------------------------------------------------------------+ */\n/* rexx */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ntcb_ptr = get_ptr(21c,0)\njscb_ptr  = get_ptr(tcb_ptr,'b4')\njct_prefix_ptr  = get_ptr(jscb_ptr,'104')\njct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))\nact_ptr = get_ptr3(jct_ptr,'28')\nactprgnm = get_data(act_ptr,'18',20)\nexit actprgnm\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_ptr3: procedure\n    /* +-----------------------------------------+\n       | returns a 3 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,3))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE PROGRAMMER NAME                   */\n./ ADD NAME=GETREALM 0126-92148-93314-0816-00052-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETREALM                                             |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the CVTRLSTG from the CVT.                   |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to extract the real storage size      |\n |             online at IPL.  Returns value in number of           |\n |             megabytes (M).                                       |\n |                                                                  |\n | Call Format:  GETREALM()                                         |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts CVTRLSTG                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\ncvtrlstg = c2d(get_data(cvt_ptr,'358',4)) / 1024\nexit cvtrlstg\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE REAL STORAGE SIZE                 */\n./ ADD NAME=GETREGK  0126-92148-93314-0817-00054-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETREGK                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the LDAREGRQ from the LDA.                   |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to extract the region size requested  |\n |             from the Local Data Area (LDA).  Returns value in    |\n |             number of kilobytes (K).                             |\n |                                                                  |\n | Call Format:  GETREGK()                                          |\n |                                                                  |\n | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |\n |        Extracts address of LDA  (ASCB+x'30')                     |\n |        Extracts LDAREGRQ                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\nascb_ptr = get_ptr(224,0)\nlda_ptr  = get_ptr(ascb_ptr,'30')\nldaregrq = c2d(get_data(lda_ptr,'cc',4)) / 1024\nexit ldaregrq\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE REGION SIZE (IN K)                */\n./ ADD NAME=GETSCPN  0118-92148-98154-1117-00053-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETSCPN                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the CVTPRODN of the System you are on        |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to extract the system control program |\n |             product name (e.g., SP3.1.3) from the CVT prefix.    |\n |                                                                  |\n | Call Format:  GETSCPN()                                          |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Addresses the CVTFIX+216 (CVT-x'28')                      |\n |        Extracts CVTPRODN                                         |\n +------------------------------------------------------------------+ */\ntrace\n\ncvt_ptr = get_ptr(10,0)\ncvtprod = d2x(x2d(cvt_ptr) - x2d(28))\ncvtprodn = get_data(cvtprod,'0',8)\ncvtprodn = insert(' ',cvtprodn,2)\nexit cvtprodn\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE MVS SCP PRODUCT NAME              */\n./ ADD NAME=GETSMFID 0114-92148-94129-1441-00085-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETSMFID                                             |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the SMCASID of the System you are on         |\n | Release:    MVS/ESA v4.1   and TSO/E v2.1                        |\n | Programmer: Paul S. Waterhouse                                   |\n |             (Code modified from apf list routine put on          |\n |              exchange by Joe Millar)                             |\n | Date:       1/24/92                                              |\n | Abstract:   A sub-function to extract the smfid from the         |\n |             System Management Control Area (SMCA).               |\n |                                                                  |\n | Call Format:  GETSMFID('smf-id')                                 |\n |                                                                  |\n |               When 'smf-id' is null, function returns            |\n |               the SMF-ID.                                        |\n |               When 'smf-id' is four bytes long, a 1 will be      |\n |               returned if current SMF-ID = smf-id or a 0 if      |\n |               not equal.                                         |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of SMCA (CVT+x'C4')                      |\n |        Extracts SMCASID                                          |\n |                                                                  |\n |        If arg is null, return smfid                              |\n |        If arg len = 4 then compare                               |\n |           If equal return 1                                      |\n |           If not equal return 0                                  |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\nparse arg check_id, .\ncvt_ptr = get_ptr(10,0)\nsmca_ptr = get_ptr(cvt_ptr,'c4')\nsmcasid = get_data(smca_ptr,'10',4)\nselect\n  when check_id = \"\" then\n    do\n      exit smcasid\n    end\n  when length(check_id) \u00ac= 4 then\n    do\n      exit -3\n    end\n  otherwise\n    do\n      if check_id =  smcasid then\n        do\n          exit 1\n        end\n    end\nend\n\nexit 0\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE SMF SYSTEM ID (from NaSPA)        */\n./ ADD NAME=GETSMS   0128-92148-96225-1336-00059-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETSMS                                               |\n | Type:       REXX exec                                            |\n | Purpose:    Get the status of SMS (On or Off)                    |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/22/93                                              |\n | Abstract:   A sub-function to return the status of SMS in the    |\n |             system.                                              |\n |                                                                  |\n | Call Format:  GETSMS()                                           |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of JESCT (CVT+x'128')                    |\n |        Extracts address of JESCTEXT (JESCT+x'64')                |\n |        Tests pointer to JESSMSIB                                 |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\njesct_ptr = get_ptr(cvt_ptr,'128')\njesctext_ptr = get_ptr(jesct_ptr,'64')\njessmsib = c2x(get_data(jesctext_ptr,'54',4))\nif x2d(jessmsib) = 0 then\n  smsstat = 'Off'\nelse\n  smsstat = 'On'\nexit smsstat\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE STATUS OF SMS                     */\n./ ADD NAME=GETSWA   0136-92148-97065-0840-00061-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETSWA                                               |\n | Type:       REXX exec                                            |\n | Purpose:    Get the location of SWA (ABOVE or BELOW)             |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       8/24/93                                              |\n | Abstract:   A sub-function to return the status of SWA in the    |\n |             system.                                              |\n |                                                                  |\n | Call Format:  GETSWA()                                           |\n |                                                                  |\n | Logic: Extracts address of TCB (PSATOLD at x'21C')               |\n |        Extracts address of JSCB (TCB+x'B4')                      |\n |        Extracts address of JCT prefix (JSCB+x'104')              |\n |        Addresses the JCT (JCT+x'10')                             |\n |        Tests JCTSTAT2, bit 7 for location of SWA                 |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ntcb_ptr = get_ptr(21c,0)\njscb_ptr  = get_ptr(tcb_ptr,'b4')\njct_prefix_ptr  = get_ptr(jscb_ptr,'104')\njct_ptr = d2x(x2d(jct_prefix_ptr) + x2d(10))\njctstat2 = get_data(jct_ptr,'74',1)\nif bitand(jctstat2,'01'x) = '01'x then\n  jctswaup = 'ABOVE'\nelse\n  jctswaup = 'BELOW'\nexit jctswaup\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE LOCATION OF SWA                   */\n./ ADD NAME=GETTRID  0124-92148-97273-0754-00056-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETTRID                                              |\n | Type:       REXX exec                                            |\n | Purpose:    Extract the ACEETRID from the RACF ACEE.             |\n | Release:    MVS/ESA v4.2.2 and TSO/E v2.4                        |\n | Programmer: John Kalinich                                        |\n | Date:       3/10/93                                              |\n | Abstract:   A sub-function to extract the VTAM terminal id from  |\n |             the RACF Accessor Environment Element.  The ACEE is  |\n |             not fetch protected.  This function works in ACF2    |\n |             systems.                                             |\n |                                                                  |\n | Call Format:  GETTRID()                                          |\n |                                                                  |\n | Logic: Extracts address of ASCB (PSAAOLD at x'224')              |\n |        Extracts address of ASXB (ASCB+x'6C')                     |\n |        Extracts address of ACEE (ASXB+x'C8')                     |\n |        Extracts ACEETRID                                         |\n +------------------------------------------------------------------+ */\ntrace\n\nascb_ptr = get_ptr(224,0)\nasxb_ptr = get_ptr(ascb_ptr,'6c')\nacee_ptr = get_ptr(asxb_ptr,'c8')\naceetrid = get_data(acee_ptr,'40',8)\nexit aceetrid\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE RACF ACEE TERMINAL ID             */\n./ ADD NAME=GETUID   0137-92148-95325-0741-00076-00087-00000-REXX\n/* REXX -\n +------------------------------------------------------------------+\n | Name:       GETUID                                               |\n | Type:       REXX exec                                            |\n | Purpose:    Get the ACF2 userid string                           |\n | Release:    MVS/ESA v4.3 and TSO/E v2.4                          |\n | Programmer: John Kalinich                                        |\n | Date:       11/21/95                                             |\n | Abstract:   A sub-function to return the ACF2 userid string.     |\n |                                                                  |\n | Call Format:  GETUID()                                           |\n |                                                                  |\n | Logic: Extracts address of CVT (at x'10')                        |\n |        Extracts address of JESCT (CVT+x'128')                    |\n |        Extracts address of 1st SSCT (JESCT+x'18')                |\n |        Locates the ACF2 SSCT                                     |\n |        Extracts address of ACCVT (SSCT+x'14')                    |\n |        Extracts address of ACFASVT (ACCVT+x'64')                 |\n |        Extracts address of ASCB (PSAAOLD at x'224')              |\n |        Extracts the ASID (ASCB+x'24')                            |\n |        Extracts address of ACUCB (ACFASVT+(32*ASID)+x'1C')       |\n |        Extracts address of ACUUIDP (ACUCB+x'18')                 |\n |        Extracts the UID string                                   |\n +------------------------------------------------------------------+ */\ntrace\n\nnumeric digits 10          /* Required for 31-bit addresses */\ncvt_ptr = get_ptr(10,0)\njesct_ptr = get_ptr(cvt_ptr,'128')\nsscvt_ptr = get_ptr(jesct_ptr,'18')\ndo while sscvt_ptr \u00ac= '00000000'\n  ssctsnam = get_data(sscvt_ptr,'8',4)\n  if ssctsnam = 'ACF2' then\n    do\n      accvt_ptr = get_ptr(sscvt_ptr,'14')\n      accasvt_ptr = get_ptr(accvt_ptr,'64')\n      ascb_ptr = get_ptr(224,0)\n      asid = c2d(get_data(ascb_ptr,'24',2))\n      accasvt_ptr = d2x(x2d(accasvt_ptr) + (32 * asid))\n      asvucb_ptr = get_ptr(accasvt_ptr,'1c')\n      acuuidp_ptr = get_ptr(asvucb_ptr,'18')\n      uid_string = get_data(acuuidp_ptr,'0',24)\n      leave\n    end\n  sscvt_ptr = get_ptr(sscvt_ptr,'4')\nend\nexit uid_string\n\n/* +-----------------------------------------+\n   | Procedures and functions defined below. |\n   +-----------------------------------------+ */\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n/* J. KALINICH, X4521 */\n/* EXEC TO GET THE ACF2 USERID STRING                */\n./ ADD NAME=IDCAMS   0154-96068-97098-1253-00074-00040-00000-REXX\n/* REXX */\nTRACE\nADDRESS ISREDIT\n\"ISREDIT MACRO (PARM) NOPROCESS\"\n\nparm = TRANSLATE(parm)\nIF parm = 'HELP' |,\n   parm = '?' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#IDCAMS)\"\n    EXIT 0\n  END\n\n/* PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED */\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\"ISREDIT PROCESS RANGE C\"\nIF rc > 0 THEN\n  DO\n    zedsmsg = 'ENTER \"Cn\" LINE CMD'\n    zedlmsg = 'YOU MUST SPECIFY THE \"DATA\" LINES',\n              'TO BE PASSED TO IDCAMS, USING \"Cn\" OR \"CC\"'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    EXIT 12\n  END\n\n\"ISREDIT (FR)  = LINENUM .ZFRANGE\"\n\"ISREDIT (LR)  = LINENUM .ZLRANGE\"\n\n/* SET CURSOR ON FIRST LINE IN RANGE */\n\"ISREDIT CURSOR = .ZFRANGE 1\"\n\nADDRESS TSO\n\"NEWSTACK\"\ni = fr\nDO WHILE i <= lr\n  \"ISREDIT (LINE) = LINE \"i\n  QUEUE line\n  i = i + 1\nEND\nQUEUE\n\nADDRESS TSO\n\"ALLOC F(SYSIN) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS\",\n  \"LRECL(80) RECFM(F)\"\n\"EXECIO * DISKW SYSIN (FINIS\"\n\"DELSTACK\"\n\n\"ALLOC F(SYSPRINT) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS\",\n  \"LRECL(121) RECFM(F B A)\"\n\nADDRESS LINKMVS \"IDCAMS\"\n\nADDRESS ISPEXEC\n\"ISPEXEC LMINIT DATAID(ID) DDNAME(SYSPRINT) ENQ(EXCLU)\"\nIF rc \u00ac= 0 THEN\n  DO\n    SAY LMINIT failed\n    EXIT 12\n  END\n\"ISPEXEC BROWSE DATAID(\"id\")\"\n\"ISPEXEC LMFREE DATAID(\"id\")\"\n\nADDRESS TSO\n\"ALLOC F(SYSPRINT) DA(*) SHR REUSE\"\n\"ALLOC F(SYSIN)    DA(*) SHR REUSE\"\nEXIT\n\n\n/* SET CURSOR ON FIRST LINE IN RANGE */\n\"ISREDIT CURSOR = \"fr 0\n\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO EXECUTE IDCAMS COMMANDS IN EDIT BUFFER         */\n./ ADD NAME=LIBDIR   0168-95137-97038-1246-00075-00056-00000-REXX\n/* REXX */\nTRACE\nARG dsn\ndsn = TRANSLATE(dsn)\n\nIF LENGTH(dsn) = 0 THEN\n  DO\n    zedsmsg = 'No file name'\n    zedlmsg = 'Specify a Librarian master file'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    EXIT 12\n  END\n\nADDRESS TSO\n\"ALLOC F(INDEX) UNIT(VIO) NEW REUSE SPACE(10,10) TRACKS\",\n  \"LRECL(121) RECFM(F B M) BLKSIZE(0)\"\n\"ALLOC F(SYSIN) UNIT(VIO) NEW REUSE SPACE(1,1) TRACKS\",\n  \"LRECL(80) RECFM(F)\"\n\"NEWSTACK\"\nQUEUE '-OPT INDEX'\n\"EXECIO 1 DISKW SYSIN (FINIS\"\n\"DELSTACK\"\n\"ALLOC F(MASTER) DA('\"dsn\"') SHR REUSE\"\n\"ALLOC F(OSJOB) DUMMY REUSE\"\n\"ALLOC F(SYSPRINT) DUMMY REUSE\"\nparm = \"IEX=IEFBR14,NRJS,NJTA\"\nADDRESS LINKMVS \"ADRLIB parm\"\n\nSAY ' Name                VV.MM Created     Changed      Size',\n    ' Init   Mod   ID'\n\"EXECIO * DISKR INDEX (STEM MBR. FINIS\"\nDO line = 1 to mbr.0\n  IF SUBSTR(mbr.line,2,1) = ' ' |,\n     SUBSTR(mbr.line,2,7) = 'RUN NO.' |,\n     SUBSTR(mbr.line,2,13) = 'MODULE   PSWD' |,\n     SUBSTR(mbr.line,2,9) = 'THE TOTAL' THEN\n    NOP\n  ELSE\n    DO\n      name = SUBSTR(mbr.line,2,8)\n      created = SUBSTR(mbr.line,49,8)\n      IF SUBSTR(mbr.line,60,11) = 'NOT UPDATED' THEN\n        DO\n          lastmod = COPIES(' ',8)\n          time = COPIES(' ',5)\n        END\n      ELSE\n        DO\n          lastmod = SUBSTR(mbr.line,59,8)\n          time = SUBSTR(mbr.line,68,2)||':'||SUBSTR(mbr.line,70,2)\n        END\n      size = SUBSTR(mbr.line,77,5)\n      init = size\n      mod = 0\n      id = SUBSTR(mbr.line,107,8)\n      SAY name,\n          '           ',\n          '01.00',\n          created,\n          lastmod,\n          time,\n          FORMAT(size,5),\n          FORMAT(init,5),\n          FORMAT(mod,5),\n          id\n    END\nEND\n\nADDRESS TSO\n\"ALLOC F(SYSPRINT) DA(*) SHR REUSE\"\n\"ALLOC F(SYSIN)    DA(*) SHR REUSE\"\n\"FREE  F(INDEX MASTER OSJOB)\"\nEXIT\n/* J. KALINICH, X4521 */\n/* EXEC TO DISPLAY LIBRARIAN INDEX                                 */\n./ ADD NAME=NOWARN   0114-91345-97016-0636-00008-00037-00000-REXX\n/* REXX */\nADDRESS ISREDIT\n\"ISREDIT MACRO\"\n\"ISREDIT RECOVERY OFF NOWARN\"\n\"ISREDIT END\"\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO ISSUE COMMANDS TO CHANGE PROFILE */\n./ ADD NAME=PDSDIR   0116-96283-98290-0850-00099-00086-00000-REXX\n/*% NOCOMMENT REXX */\nTRACE\n/*  For batch, use the following JCL and comment out the TSO\n    ALLOCATE sequence:\n\n    //REXX     EXEC  PGM=IRXJCL,PARM='name.of.rexx.exec'\n    //SYSEXEC  DD  DSN=your.rexx.library,DISP=SHR\n    //SYSTSPRT DD  SYSOUT=*\n    //SYSTSIN  DD  DUMMY\n    //PDS      DD  DSN=your.pds.name,DISP=SHR,\n    //             DCB=(RECFM=F,DSORG=PS,LRECL=256,BLKSIZE=256)\n\n*/\n\n/*  For TSO, use the following ALLOCATE sequence:   */\n\nARG dsn\nADDRESS TSO\n\"ALLOC F(PDS) DA(\"dsn\") SHR REUSE\",    /* pds directory */\n\"  RECFM(F) DSORG(PS) LRECL(256) BLKSIZE(256)\"\n\n/*-------------------------------------------------------------------*/\n\nmainline:\nSAY ' Name                VV.MM Created   Changed    Size',\n    ' Init   Mod   ID'\n\"EXECIO * DISKR PDS (STEM DIR. FINIS\"  /* read pds directory */\nDO blk = 1 to dir.0\n  usedbytes = C2D(SUBSTR(dir.blk,1,2))\n  index = 3                            /* skip past used bytes */\n  DO WHILE index < usedbytes\n    IF SUBSTR(dir.blk,index,8) = 'FFFFFFFFFFFFFFFF'x THEN\n      LEAVE blk\n    pds2name = SUBSTR(dir.blk,index,8) /* member name */\n    index = index + 11                 /* skip past name and ttr */\n    pds2indc = SUBSTR(dir.blk,index,1)\n    len = BITAND(pds2indc,'1F'x)       /* isolate user data length */\n    userdata = C2D(len) * 2            /* halfwords to bytes */\n    IF userdata = 30 THEN              /* ISPF statistics? */\n      DO\n        vv = c2d(SUBSTR(dir.blk,index+1,1))\n        mm = c2d(SUBSTR(dir.blk,index+2,1))\n        created = p2d(SUBSTR(dir.blk,index+6,3))\n        lastmod = p2d(SUBSTR(dir.blk,index+10,3))\n        time = p2d(SUBSTR(dir.blk,index+13,3))\n        time = SUBSTR(time,1,2)||':'||SUBSTR(time,3,2)\n        size = c2d(SUBSTR(dir.blk,index+15,2))\n        init = c2d(SUBSTR(dir.blk,index+17,2))\n        mod = c2d(SUBSTR(dir.blk,index+19,2))\n        id = SUBSTR(dir.blk,index+21,8)\n        SAY pds2name,\n            '           ',\n            RIGHT(vv,2,0)||'.'||RIGHT(mm,2,0),\n            created,\n            ' ',\n            lastmod,\n            time,\n            FORMAT(size,5),\n            FORMAT(init,5),\n            FORMAT(mod,5),\n            id\n      END\n    ELSE\n      SAY pds2name\n    index = index + userdata + 1       /* skip past user data */\n  END\nEND\nEXIT\n\np2d: procedure\n/* rexx      convert packed decimal to number */\n/* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */\n/* Tel: +49-711-2012-387                                       */\n/* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */\nparse arg number_p\nerg = c2x(number_p)\nsign = right(erg,1)\nnumber = left(erg,length(erg)-1)\nif sign = 'D' then\n   return '-'||number\nelse\n   return number\n\nd2p: procedure\n/* rexx   convert number to packed decimal  */\n/* Michael Pollak, c/o RWG, Raepplenstr. 17, D-70191 Stuttgart */\n/* Tel: +49-711-2012-387                                       */\n/* Fax: +49-711-2012-502        e-mail: daapm@rwg.de           */\narg number\nif datatype(number) \u00ac= 'NUM' then\n   return ''\nif number < 0 then\n   interpret \"number_p = '\"abs(number)\"D'x\"\nelse\n   interpret \"number_p = '\"number\"C'x\"\nreturn number_p\n\n/* J. KALINICH, X4521 */\n/* EXEC TO DEBLOCK PDS DIRECTORY                                      */\n./ ADD NAME=PDSFTP   0156-97059-98169-1000-00218-00132-00000-REXX\n/* ---------------------  Rexx procedure  ---------------------- *\n *                                                               *\n * Name:      PDSFTP                                             *\n *                                                               *\n * Function:  Invoked by the user to display the PDSFTP ISPF     *\n *            pop-up and then use the TCP/IP FTP command to copy *\n *            data sets to and from the remote TCP/IP host.      *\n *                                                               *\n *            If a local dataset name is entered on the panel,   *\n *            then PUT subcommands will be generated by the      *\n *            dialog and FTP will be invoked in a batch mode.    *\n *            Otherwise, FTP will be invoked in it's normal      *\n *            interactive mode where any subcommand can be       *\n *            issued.                                            *\n *                                                               *\n *            When a PDS dataset name is entered, a member list  *\n *            will be displayed.  Members selected for PUT will  *\n *            have a foreign file name generated in the form of  *\n *            'mbr.llq' where 'mbr' is the PDS member name and   *\n *            'llq' is the 1st 3 characters of the MVS low level *\n *            qualifier.                                         *\n *                                                               *\n *            When a sequential dataset name is entered, the     *\n *            foreign file name will be generated as 'llq'.  If  *\n *            a PDS member name is entered in parenthesis (a     *\n *            sequential file) then the name is generated as     *\n *            'mbr.llq'.  If a wild card '*' character is used   *\n *            as part of the PDS member name, then MPUT will be  *\n *            used and the foreign file names will be the same   *\n *            as the PDS member names.                           *\n *                                                               *\n *                                                               *\n * Syntax:    %pdsftp                                            *\n *                                                               *\n * Author:    John P. Kalinich                                   *\n *            USA Logistics Systems Support Center               *\n *            AMSEL-SE-BSD-LS-TD, Room 7.103                     *\n *            1222 Spruce Street                                 *\n *            St. Louis, MO.  63103-2834                         *\n *            314-331-4521                                       *\n *            314-331-4520 (FAX)                                 *\n *            Internet:  kalinich@st-louis-emh2.army.mil         *\n *                                                               *\n * History:                                                      *\n *                                                               *\n *            04/14/97 - Add support for Knet or IBM TCP/IP      *\n *                                                               *\n * Credits:                                                      *\n *            Lionel Dyck's LPRPRINT dialog from the IBM SHARE   *\n *            Software PC was the basis for this code.           *\n * ------------------------------------------------------------- */\n\nTrace\nDo forever\n\n  Address ISPEXEC\n  \"addpop row(5) column(5)\"\n  \"Display Panel(PDSFTP)\"\n  If rc > 3 Then\n     Exit 0\n\n  \"rempop\"\n\n  lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  Address TSO\n  \"Newstack\"\n\n  /* Queue initial commands */\n  Queue ftpuser\n  Queue ftppass\n  Queue 'cd 'ftpdir\n  Queue 'pwd'\n  Queue 'stat'\n  initcmds = 5\n\n  If Translate(ftptcp) = \"KNET\" Then Do\n    Queue \"strip\"\n    Queue \"hash 51200\"\n    initcmds = initcmds + 2\n    End\n\n  Address ISPEXEC\n\n  If ftppinds = \"\" Then Do\n    Call Do_ftp\n    Iterate\n    End\n\n  If pos('*',ftppinds) > 1 Then Do\n    parse value ftppinds with dsn_only \"(\"\n    If left(dsn_only,1) = \"'\" Then\n      dsn_only = dsn_only\"'\"\n    End\n  Else\n    dsn_only = ftppinds\n\n  If sysdsn(dsn_only) <> \"OK\" Then Do\n    zedsmsg = \"Error\"\n    zedlmsg = \"Specified data set does not exist:\" ftppinds\n    \"SETMSG MSG(ISRZ001)\"\n    Call Delete_stack\n    Iterate\n    End\n  Else Do\n    x = listdsi(dsn_only)\n    If pos(\"(\",ftppinds) > 1 Then sysdsorg = \"PS\"\n    Select\n      When sysdsorg = \"PS\" | pos(\"(\",ftppinds) > 1 Then Do\n        If left(ftppinds,1) = \"'\" Then\n          parse value ftppinds with \"'\" w_dsn \"'\"\n        Else\n          w_dsn = sysvar(\"syspref\")\".\"ftppinds\n        If pos(\"(\",w_dsn) > 1 Then Do\n          If pos(\"*\",w_dsn) > 1 Then Do\n            parse value w_dsn with \"(\" member \")\"\n            parse value w_dsn with lcd_name \"(\"\n            Queue \"lcd '\"lcd_name\"'\"\n            If Translate(ftptcp) = \"KNET\" Then\n              Queue \"mput \"member \"(noprompt\"\n            Else\n              Queue \"mput \"member\n            Queue 'quit'\n            End\n          Else Do\n            ext = substr(w_dsn,lastpos('.',w_dsn)+1,3)\n            parse value w_dsn with \"(\" member \")\"\n            put = \"put '\"w_dsn\"'\" member\".\"ext\n            Queue Translate(put,lower_case,upper_case)\n            Queue 'quit'\n            End\n          End\n        Else Do\n          llq = substr(w_dsn,lastpos('.',w_dsn)+1)\n          llq = Translate(llq,'. ','()')\n          put = \"put '\"w_dsn\"'\" llq\n          Queue Translate(put,lower_case,upper_case)\n          Queue 'quit'\n          End\n        Call Do_ftp\n        End\n      When sysdsorg = \"PO\" Then Do\n        Call Do_pds\n        If queued() > initcmds Then Do\n          Queue 'quit'\n          Call Do_ftp\n          End\n        Else Call Delete_stack\n        End\n      Otherwise Nop;\n      End\n    End\nEnd\n\nDo_pds:\n  \"Lminit Dataid(dataid) Dataset(\"ftppinds\") Enq(Shrw)\"\n  \"Lmopen Dataid(\"dataid\") Option(Input)\"\n  \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n    \"Commands(Any) Panel(PDSFTPLM)\"\n  Do while rc == 0\n    Call Process_selection\n    \"Lmmdisp Dataid(\"dataid\") Option(Get)\"\n    If rc == 8 Then\n      \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n        \"Commands(Any) Panel(PDSFTPLM)\"\n  End\n  \"Lmmdisp Dataid(\"dataid\") Option(Free)\"\n  \"Lmclose Dataid(\"dataid\")\"\n  \"Lmfree  Dataid(\"dataid\")\"\n  Return\n\nProcess_selection:\n  If left(ftppinds,1) = \"'\" Then\n    parse value ftppinds with \"'\" w_dsn \"'\"\n  Else\n    w_dsn = sysvar(\"syspref\")\".\"ftppinds\n  zlmember = strip(zlmember)\n  Select\n  When zllcmd = \"/\" | zllcmd = \"S\" Then Do\n    \"Lmmdisp Dataid(\"dataid\") Option(Put) Member(\"zlmember\")\",\n      \"Zludata(*Queued)\"\n    ext = substr(w_dsn,lastpos('.',w_dsn)+1,3)\n    put = \"put '\"w_dsn\"(\"zlmember\")'\" zlmember\".\"ext\n    Queue Translate(put,lower_case,upper_case)\n    End\n  When zllcmd = \"B\" Then Do\n    \"Lmmdisp Dataid(\"dataid\") Option(Put) Member(\"zlmember\")\",\n        \"Zludata(*Browsed)\"\n    \"Browse Dataid(\"dataid\") Member(\"zlmember\")\"\n    End\n  When zllcmd = \"V\" Then Do\n    \"Lmmdisp Dataid(\"dataid\") Option(Put) Member(\"zlmember\")\",\n        \"Zludata(*Viewed)\"\n    \"View Dataid(\"dataid\") Member(\"zlmember\")\"\n    End\n  Otherwise nop;\n  End\n  Return\n\nDo_ftp:\n  Address TSO\n  If Translate(ftptcp) = \"KNET\" Then\n    \"CALL 'AP.KNET50C.CMDLIB(FTP)' '\"ftpnode\"'\"\n  Else\n    \"FTP \"ftpnode\n  Call Delete_stack\n  Return\n\nDelete_stack:\n  Address TSO\n  \"Delstack\"\n  Return\n\n/* J. KALINICH, X4521 */\n/* Rexx dialog to FTP with MVS TCPIP.                         */\n/* Generate FTP PUT commands for PDS members or sequential    */\n/* file if a local DSN is entered on pop-up.                  */\n./ ADD NAME=PLUG     0122-93316-97213-1427-00126-00102-00000-REXX\n/* REXX */\nADDRESS ISREDIT\n\"ISREDIT MACRO (PLUGSTR COL LABEL1 LABEL2) NOPROCESS\"\nTRACE\nIF plugstr = '?' |,\n   TRANSLATE(plugstr) = 'HELP' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#PLUG)\"\n    EXIT 1\n  END\nIF plugstr = '' THEN\n  DO\n    zedsmsg = 'NO PLUG STRING'\n    zedlmsg = 'YOU MUST SPECIFY A PLUG STRING'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    EXIT 12\n  END\n/* SEE IF LABELS WERE USED WITH NO COLUMN SPECIFIED */\nIF SUBSTR(col,1,1) = '.' THEN\n  DO\n    label2 = label1\n    label1 = col\n    col = ''\n  END\n/* IF NO COLUMN SPECIFIED, THEN USE CURSOR POSITION */\nIF col = '' THEN\n  DO\n    \"ISREDIT (END)  = LRECL\"\n    \"ISREDIT (CL,CC) = CURSOR\"\n    IF cc = 0 |,\n       cc > end THEN\n      DO\n        zedsmsg = 'SPECIFY START COLUMN'\n        zedlmsg = 'USE A NUMBER OR CURSOR LOCATION FOR START OF PLUG'\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        EXIT 12\n      END\n    ELSE\n      col = cc\n  END\nELSE\n  IF DATATYPE(col) <> 'NUM' THEN\n    DO\n      zedsmsg = 'START COLUMN NOT NUMERIC'\n      zedlmsg = 'USE A NUMERIC FOR THE START COLUMN NUMBER'\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      EXIT 12\n    END\n/* IF .LABELS WERE SPECIFIED, IGNORE (O) LINE RANGE */\nIF SUBSTR(label1,1,1) = '.' THEN\n  DO\n    label1 = TRANSLATE(label1)\n    label2 = TRANSLATE(label2)\n    ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n    \"ISREDIT (FR)  = LINENUM \"label1\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE LABEL ERROR'\n        zedlmsg = '\"'label1'\" RECOGNIZED AS INVALID',\n                  'OR UNDEFINED LABEL IN PLUG CMD'\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        EXIT 12\n      END\n    \"ISREDIT (LR)  = LINENUM \"label2\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE LABEL ERROR'\n        zedlmsg = '\"'label2'\" RECOGNIZED AS INVALID',\n                  'OR UNDEFINED LABEL IN PLUG CMD'\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        EXIT 12\n      END\n    /* SET CURSOR ON FIRST LINE IN RANGE */\n    \"ISREDIT CURSOR = \"label1 \"1\"\n    labels = 'YES'\n  END\n/* PROCESS LINE COMMANDS, CHECK IF O/C WAS SPECIFIED */\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\"ISREDIT PROCESS RANGE O C\"\nIF rc > 0 &,\n   labels <> 'YES' THEN\n  DO\n    zedsmsg = 'ENTER \"O\" LINE CMD'\n    zedlmsg = 'YOU MUST SPECIFY THE \"DATA\" LINES',\n              'TO BE PLUGGED, USING \"On\" OR \"OO\",',\n              'OR LABELS'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    EXIT 12\n  END\nIF labels <> 'YES' THEN\n  DO\n    \"ISREDIT (FR)  = LINENUM .ZFRANGE\"\n    \"ISREDIT (LR)  = LINENUM .ZLRANGE\"\n    /* SET CURSOR ON FIRST LINE IN RANGE */\n    \"ISREDIT CURSOR = .ZFRANGE 1\"\n  END\n\npluglen = LENGTH(plugstr)\n/* CHECK FOR PLUG STRING DELIMITERS */\nIF SUBSTR(plugstr,1,1) = \"'\" |,\n   SUBSTR(plugstr,1,1) = '\"' THEN\n  pluglen = pluglen - 2\nELSE\n  plugstr = \"'\"plugstr\"'\"\nanychar = COPIES('=',80)\ni = fr\nDO WHILE i <= lr\n  \"ISREDIT CHANGE P'\"SUBSTR(anychar,1,pluglen)\"'\" plugstr col\n  chgcc = rc\n  IF chgcc > 0 THEN\n    DO\n      zedsmsg = \"PLUG FAILED, RC=\"chgcc\n      zedlmsg = \"TARGET LINES \"fr+0\" TO \"lr+0\" AT COLUMN\" col+0\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      EXIT 12\n    END\n  i = i + 1\nEND\nzedsmsg = \"CHARS \"plugstr\" PLUGGED\"\nzedlmsg = \"CHARS \"plugstr\" PLUGGED IN LINES \"fr+0\" TO \"lr+0\" AT COLUMN\" col+0\nADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n/* SET CURSOR ON FIRST LINE IN RANGE */\n\"ISREDIT CURSOR = \"fr col\nEXIT 0\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO PLUG DATA INTO A RANGE OF LINES             */\n./ ADD NAME=PROFSET  0132-91345-97310-0805-00065-00037-00000-REXX\n/* REXX */\nADDRESS ISREDIT\n\"ISREDIT MACRO (PARM)\"\nTRACE\nparm = TRANSLATE(parm)\nIF parm = 'HELP' |,\n   parm = '?' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#PROFSET)\"\n    EXIT 0\n  END\nIF parm = '' THEN\n  DO\n    zedsmsg = \"No parm specified\"\n    zedlmsg = \"Specify an edit macro containing profile settings\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\n\nADDRESS ISPEXEC \"VGET ZAPPLID\"\nprofile = zapplid||EDIT\nADDRESS ISPEXEC \"TBTOP \"profile\nADDRESS ISPEXEC \"TBSKIP \"profile\nskiprc = rc\nprof. = ''\nn = 1\n\nDO WHILE skiprc = 0\n  prof.n = zedptype zedplrcl zedprcfm\n  ADDRESS ISPEXEC \"TBSKIP \"profile\n  skiprc = rc\n  prof.0 = n\n  n = n + 1\nEND\n\nx = MSG('OFF')\nDO n = 1 to prof.0\n  PARSE VAR prof.n ptype plrcl prcfm .\n  IF ptype = 'ZDEFAULT' THEN\n    NOP\n  ELSE\n    DO\n      IF prcfm = 'V' THEN\n        pblks = plrcl + 4\n      ELSE\n        pblks = plrcl\n      /* Allocate temp file with matching low level qualifier,\n         record length, and record format */\n      ADDRESS TSO\n      \"ALLOC F($PROFSET) UNIT(SYSALLDA) NEW REUSE SPACE(1) TRACKS\",\n          \"LRECL(\"plrcl\") RECFM(\"prcfm\") BLKSIZE(\"pblks\")\",\n          \"DA($PROFSET.\"ptype\")\"\n      ADDRESS ISPEXEC \"EDIT DATASET($PROFSET.\"ptype\")\",\n           \"MACRO(\"parm\")\"\n      SAY n\". Edit macro \"parm \"issued for .\"ptype\" edit profile\"\n      \"DELETE $PROFSET.\"ptype\n    END\nEND\n\nEXIT\n\n/* J. Kalinich, x4521 */\n/* Edit macro to issue a set of profile commands for each        */\n/* edit profile (low level qualifier) found in xxxEDIT.          */\n/* Based on PROFLIST edit macro by Bob Zimmerman, CNA Insurance. */\n./ ADD NAME=RESETID  0124-92339-96332-0646-00048-00012-00000-REXX\n/* REXX */\nTRACE\nARG userid\nIF userid = '' THEN\n  EXIT\nIF SUBSTR(userid,1,2) = 'U=' THEN\n  userid = DELSTR(userid,1,2)\nuser_attr = GETATTR()                  /* TSO attributes */\n/* Sysprog? */\nIF SUBSTR(user_attr,1,4) <> 'OPER' THEN\n  DO\n    zedsmsg = 'NOT AUTHORIZED'\n    zedlmsg = 'YOU ARE NOT AUTHORIZED TO USE OPERATOR COMMANDS'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\nuid_string = GETUID()\n/* Security admin? */\nIF SUBSTR(uid_string,6,2)  = 'CF' &,      /* Jobfunc */\n   SUBSTR(uid_string,16,4) = 'ISSO' THEN  /* Group   */\n  DO\n    SAY 'ACF'\n    QUEUE 'SET TERSE'\n    QUEUE 'CHANGE 'userid' PSWD-VIO(0)'\n    QUEUE 'END'\n    ACF\n  END\nELSE\n  DO\n    /* Prevent SDSF panel from displaying after operator command */\n    /* with optional mod to panel ISFPANEL or ISFPCU4x           */\n    sdsfoper = 'END'\n    ADDRESS ISPEXEC \"VPUT (SDSFOPER) SHARED\"\n\n    /* Leave out NEWAPPL(ISF) or sdsfoper variable not passed */\n    ADDRESS ISPEXEC,\n      \"SELECT PGM(ISFISP)\",\n      \"PARM(/F ACF2,RESET(\"userid\"))\"\n  END\n\nzedsmsg = 'ACF2 RESET ISSUED'\nzedlmsg = 'ACF2 RESET ISSUED FOR U='userid\nADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n\nEXIT\n/* J. KALINICH, X4521 */\n/* EXEC TO REDUCE ACF2 PASSWORD VIOLATION COUNT BY 1        */\n/* IF TSO OPERATOR PRIVILEGE OR TO ZERO IF SECURITY ADMIN   */\n./ ADD NAME=RUNACF   0153-96068-97164-0908-00066-00040-00000-REXX\n/* REXX */\nTRACE\nADDRESS ISREDIT\n\"ISREDIT MACRO (PARM) NOPROCESS\"\n\nparm = TRANSLATE(parm)\nIF parm = 'HELP' |,\n   parm = '?' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#RUNACF)\"\n    EXIT 0\n  END\n\n/* PROCESS LINE COMMANDS, CHECK IF C WAS SPECIFIED */\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\"ISREDIT PROCESS RANGE C\"\nIF rc > 0 THEN\n  DO\n    zedsmsg = 'ENTER \"Cn\" LINE CMD'\n    zedlmsg = 'YOU MUST SPECIFY THE \"DATA\" LINES',\n              'TO BE PASSED TO ACF, USING \"Cn\" OR \"CC\"'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\n\n\"ISREDIT (FR)  = LINENUM .ZFRANGE\"\n\"ISREDIT (LR)  = LINENUM .ZLRANGE\"\n\n/* SET CURSOR ON FIRST LINE IN RANGE */\n\"ISREDIT CURSOR = .ZFRANGE 1\"\n\ni = fr\nDO WHILE i <= lr\n  \"ISREDIT (LINE) = LINE \"i\n  QUEUE line\n  i = i + 1\nEND\nQUEUE 'END'  /* terminate continuations, if needed */\nQUEUE 'END'  /* terminate command processor        */\n\nIF parm = 'DATA' |,\n   parm = 'NOTE' THEN\n  DO\n    x = OUTTRAP(\"trap.\",\"*\")\n    ADDRESS TSO\n    \"ACF\"\n    x= OUTTRAP(\"off\")\n\n    DO line = trap.0 TO 1 BY -1\n      acfout = trap.line\n      \"ISREDIT LINE_AFTER \"lr\" = \"parm\"LINE (acfout)\"\n    END\n    \"ISREDIT LINE_AFTER \"lr\" = MSGLINE 'ACF OUTPUT'\"\n  END\nELSE\n  DO\n    ADDRESS TSO\n    \"ACF\"\n  END\n\n/* SET CURSOR ON FIRST LINE IN RANGE */\n\"ISREDIT CURSOR = \"fr 0\n\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO SEND ACF SUBCOMMANDS TO ACF COMMAND PROCESSOR */\n./ ADD NAME=SORTWORK 0113-93055-94118-0714-00059-00068-00000-REXX\n/* REXX */\nPARSE ARG debug .\nIF TRANSLATE(debug) = \"DEBUG\" THEN\n  TRACE RESULTS\nELSE\n  TRACE OFF\ndispcc = 0\nDO WHILE dispcc < 8\n  \"ISPEXEC DISPLAY PANEL(SORTWORK)\"\n  dispcc = rc\n  IF dispcc = 8 THEN EXIT\n  trace i\n  SELECT\n  WHEN dtyp = 3330 THEN\n    DO\n      trkcap = 13030\n      trkcyl = 19\n    END\n  WHEN dtyp = 3350 THEN\n    DO\n      trkcap = 19069\n      trkcyl = 30\n    END\n  WHEN dtyp = 3380 THEN\n    DO\n      trkcap = 47476\n      trkcyl = 15\n    END\n  WHEN dtyp = 3390 THEN\n    DO\n      trkcap = 56664\n      trkcyl = 15\n    END\n  OTHERWISE\n    DO\n      SAY 'Impossible to get here',\n          '(unless panel logic modified) - bye.'\n      EXIT\n    END\n  END\n/* SYNCSORT RELEASE 3.5 (PAGE 11.10) */\nttrk = (numrec * lrecl * 1.3) / trkcap\nIF ((numrec * lrecl * 1.3) // trkcap) \u00ac= 0 THEN\n  ttrk = (ttrk + 1) % 1\ntcyl = ttrk / trkcyl\nIF (ttrk // trkcyl) \u00ac= 0 THEN\n  tcyl = (tcyl + 1) % 1\nttrksw = ttrk / numsw\nIF (ttrk // numsw) \u00ac= 0 THEN\n  ttrksw = (ttrksw + 1) % 1\ntcylsw = tcyl / numsw\nIF (tcyl // numsw) \u00ac= 0 THEN\n  tcylsw = (tcylsw + 1) % 1\n/* RECOMPUTE TOTAL TRACKS AND CYLINDERS AFTER ROUNDING */\nttrk = ttrksw * numsw\ntcyl = tcylsw * numsw\nEND\n/* J.KALINICH, X4521 */\n/* EXEC TO COMPUTE SYNCSORT SORTWORK SPACE CALCULATION          */\n./ ADD NAME=TESTACF  0175-96068-97114-0616-00108-00040-00000-REXX\n/* REXX */\nTRACE\n\"ISREDIT MACRO (LID PARM ACCESS) NOPROCESS\"\n\n\"NEWSTACK\"\nIF LENGTH(lid) = 0 THEN\n  DO\n    zedsmsg = 'LID or UID string missing'\n    zedlmsg = 'A logonid or UID(string) is a required parameter'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n    EXIT 12\n  END\n\nlid =    TRANSLATE(lid)\nparm =   TRANSLATE(parm)\naccess = TRANSLATE(access)\n\nIF lid = 'HELP' |,\n   lid = '?' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#TESTACF)\"\n    EXIT 0\n  END\n\n/* Process line commands, check if C was specified */\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\"ISREDIT PROCESS RANGE C\"\nIF rc > 0 THEN\n  DO\n    zedsmsg = 'Enter \"Cn\" line cmd'\n    zedlmsg = 'You must specify the \"DATA\" lines',\n              'to be tested by ACF, using \"Cn\" or \"CC\"'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\n\n\"ISREDIT (FR)  = LINENUM .ZFRANGE\"\n\"ISREDIT (LR)  = LINENUM .ZLRANGE\"\n\n/* Set cursor on first line in range */\n\"ISREDIT CURSOR = .ZFRANGE 1\"\n\ni = fr\nDO WHILE i <= lr\n  \"ISREDIT (LINE) = LINE \"i\n  IF POS('DSN=',line) > 0 THEN\n    DO\n      PARSE VALUE line WITH \"DSN=\" rule \".\" dsn .\n      PARSE VALUE dsn WITH dsn \",\" rest .\n\n      QUEUE 'DECOMP 'rule         /* Test if rule exists */\n      QUEUE 'END'                 /* Terminate ACF command */\n      x = OUTTRAP(\"trap.\",\"*\")\n      ADDRESS TSO\n     \"ACF\"\n      acfrc = rc\n      x= OUTTRAP(\"off\")\n\n      IF POS('&',rule) > 0 |,     /* Skip symbolics */\n         POS('&',dsn)  > 0 |,     /* Skip symbolics */\n         acfrc > 0 THEN           /* Skip if no rule */\n        NOP\n      ELSE\n        DO\n\n          QUEUE 'TEST 'rule\n          QUEUE 'DSN('dsn') -'\n          IF access = '' THEN\n            access = 'READ'\n          QUEUE 'ACCESS('access') -'\n          IF SUBSTR(lid,1,4) = 'UID(' THEN\n            QUEUE lid\n          ELSE\n            QUEUE 'LID('lid')'\n          QUEUE 'END'       /* Terminate TEST subcommand */\n          QUEUE 'END'       /* Terminate ACF command */\n          IF parm = 'DATA' |,\n             parm = 'NOTE' THEN\n            DO\n              x = OUTTRAP(\"trap.\",\"*\")\n              ADDRESS TSO\n             \"ACF\"\n              x= OUTTRAP(\"off\")\n\n              DO line = trap.0 TO 1 BY -1\n                acfout = trap.line\n                \"ISREDIT LINE_AFTER \"i\" = \"parm\"LINE (acfout)\"\n              END\n              \"ISREDIT LINE_AFTER \"i\" = MSGLINE 'ACF TEST OUTPUT'\"\n            END\n          ELSE\n            DO\n              ADDRESS TSO\n             \"ACF\"\n            END\n        END\n    END\n    i = i + 1\nEND\n\n\n/* Set cursor on first line in range */\n\"ISREDIT CURSOR = \"fr 0\n\n\"DELSTACK\"\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO TEST ACF RULES USING DSNAMES IN JCL        */\n./ ADD NAME=TRAPCMD  0111-92177-94336-0815-00033-00036-00000-REXX\n/* REXX */\nTRACE\nPARSE ARG tsocmd parm\ntsocmd = TRANSLATE(tsocmd)\nADDRESS ISPEXEC\n\"ISPEXEC TBCREATE TRAPTBL NAMES(CMDLINE) NOWRITE REPLACE\"\nIF rc > 4 THEN\n  DO\n    SAY TBCREATE failed\n    EXIT\n  END\ndquayle = outtrap(\"sysoutline.\",\"*\")\nADDRESS TSO\ntsocmd parm\nADDRESS ISPEXEC\nDO i = 1 to sysoutline.0\n  cmdline = sysoutline.i\n  \"ISPEXEC TBADD TRAPTBL\"\n  IF rc <> 0 THEN\n    DO\n      SAY TBADD failed\n    END\nEND\n\"ISPEXEC TBTOP TRAPTBL\"\ntbcc = 0\nDO WHILE tbcc < 8\n  \"ISPEXEC TBDISPL TRAPTBL PANEL(TRAPTBL) CURSOR(ZCMD)\"\n  tbcc = rc\nEND\n\"ISPEXEC TBCLOSE TRAPTBL\"\nEXIT\n/* J. KALINICH, X4521 */\n/* EXEC TO TRAP AND DISPLAY TSO COMMAND OUTPUT IN ISPF TABLE         */\n./ ADD NAME=WEAVE    0144-93316-98168-0729-00108-00102-00000-REXX\n/* REXX */\nADDRESS ISREDIT\n\"ISREDIT MACRO (LABEL1 LABEL2 CUTTBL) NOPROCESS\"\nTRACE\nIF label1 = '?' |,\n   TRANSLATE(label1) = 'HELP' THEN\n  DO\n    ADDRESS ISPEXEC \"DISPLAY PANEL(#WEAVE)\"\n    EXIT 1\n  END\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n/* IF .LABELS WERE SPECIFIED, IGNORE (O) LINE RANGE */\nIF SUBSTR(label1,1,1) = '.' &,\n   SUBSTR(label2,1,1) = '.' THEN\n  DO\n    label1 = TRANSLATE(label1)\n    label2 = TRANSLATE(label2)\n    \"ISREDIT (FR)  = LINENUM \"label1\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE LABEL ERROR'\n        zedlmsg = '\"'label1'\" RECOGNIZED AS INVALID',\n                  'OR UNDEFINED LABEL IN PASTEES CMD'\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    \"ISREDIT (LR)  = LINENUM \"label2\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE LABEL ERROR'\n        zedlmsg = '\"'label2'\" RECOGNIZED AS INVALID',\n                  'OR UNDEFINED LABEL IN PASTEES CMD'\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    /* SET CURSOR ON FIRST LINE IN RANGE */\n    \"ISREDIT CURSOR = \"label1 \"1\"\n    labels = 'YES'\n  END\n/* PROCESS LINE COMMANDS, CHECK IF O/C WAS SPECIFIED */\n\"ISREDIT PROCESS RANGE O C\"\nIF rc > 0 &,\n   labels <> 'YES' THEN\n  DO\n    zedsmsg = 'ENTER \"O\" LINE CMD'\n    zedlmsg = 'YOU MUST SPECIFY THE \"DATA\" LINES',\n              'TO BE INTERLACED, USING \"On\" OR \"OO\",',\n              'OR LABELS'\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\nIF labels <> 'YES' THEN\n  DO\n    \"ISREDIT (FR)  = LINENUM .ZFRANGE\"\n    \"ISREDIT (LR)  = LINENUM .ZLRANGE\"\n    /* SET CURSOR ON FIRST LINE IN RANGE */\n    \"ISREDIT CURSOR = .ZFRANGE 1\"\n  END\nIF cuttbl <> '' THEN\n  ct = TRANSLATE(cuttbl)\nELSE\n  DO\n    ADDRESS ISPEXEC \"VGET (CUTNAME) PROFILE\"\n    ct = cutname\n  END\ncutpst = cutpst||ct\nADDRESS ISPEXEC \"TBOPEN \"cutpst\" NOWRITE SHARE\"\nIF rc <> 0 THEN\n  DO\n    zedsmsg = \"TABLE ERROR\"\n    zedlmsg = \"TBOPEN FAILED FOR CUT TABLE '\"ct\"'\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\nADDRESS ISPEXEC \"TBQUERY \"cutpst\" ROWNUM(\"cutcnt\")\"\nIF cutcnt <= 0 THEN\n  DO\n    zedsmsg = \"USE CUT FIRST\"\n    zedlmsg = \"NO DATA HAS BEEN STORED VIA THE CUT MACRO\"\n    ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\ni = fr\nDO WHILE i <= (((lr - fr) * (cutcnt + 1)) + fr)\n  /* GET EACH CUT LINE FROM THE TABLE AND INTERLACE INTO RANGE */\n  j = cutcnt\n  ADDRESS ISPEXEC \"TBBOTTOM \"cutpst\n  DO WHILE j > 0\n    \"ISREDIT LINE_AFTER \"i\" = DATALINE (CTPT)\"\n    lacecc = rc\n    IF lacecc > 12 THEN\n      DO\n        zedsmsg = \"INTERLACE FAILED, RC=\"lacecc\n        zedlmsg = \"TARGET LINES \"fr+0\" TO \"lr+0\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    ADDRESS ISPEXEC \"TBSKIP \"cutpst\" NUMBER(-1)\"\n    j = j - 1\n  END\n  i = i + (cutcnt + 1)\nEND\nzedsmsg = \"TABLE '\"ct\"' INTERLACED\"\nzedlmsg = \"CUT TABLE '\"ct\"' INTERLACED INTO LINES \"fr+0\" TO \"lr+0\nADDRESS ISPEXEC \"SETMSG MSG(ISRZ001W)\"\nEXIT 0\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO INTERLACE PDS 8.5 CUT TABLE INTO A RANGE OF LINES  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SKELETNS": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x10/\\x00\\x99\\x10/\\t)\\x00Q\\x00Q\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-04-12T00:00:00", "modifydate": "1999-04-12T09:29:00", "lines": 81, "newlines": 81, "modlines": 0, "user": "JCL"}, "text": "./ ADD NAME=LOGLIST  0103-94182-94278-0635-00036-00036-00000-JCL\n)CM\n)CM *****     BUILD REXX EXEC FOR ISPF LOG/LIST SYSOUT   *****\n)CM *****     ALLOCATION USING AN OUTPUT DESCRIPTOR.     *****\n)CM\n)CM *****     EXECUTED IN THE INITIAL LOGON CLIST IF     *****\n)CM *****     PRESENT IN THE ISPFILE LIBRARY AS MEMBER   *****\n)CM *****     \"@LOGLIST\".                                *****\n)CM\n/* REXX */\nTRACE\nlltitle = \"&LLTITLE\"\nllname  = \"&LLNAME\"\nllroom  = \"&LLROOM\"\nllbldg  = \"&LLBLDG\"\nlldept  = \"&LLDEPT\"\nlladdr1 = \"&LLADDR1\"\nlladdr2 = \"&LLADDR2\"\nlladdr3 = \"&LLADDR3\"\nlladdr4 = \"&LLADDR4\"\n\"OUTDES LOGLIST REUSE\",\n  \"TITLE('\"lltitle\"')\",\n  \"NAME('\"llname\"')\",\n  \"ROOM('\"llroom\"')\",\n  \"BUILDING('\"llbldg\"')\",\n  \"DEPT('\"lldept\"')\",\n  \"ADDRESS('\"lladdr1\"',\",\n          \"'\"lladdr2\"',\",\n          \"'\"lladdr3\"',\",\n          \"'\"lladdr4\"')\"\n\"ALLOC F(ISPLOG)  SYSOUT(R) HOLD OUTDES(LOGLIST) REUSE\",\n\"  LRECL(125) BLKSIZE(129)  RECFM(V A)\"\n\"ALLOC F(ISPLIST) SYSOUT(R) HOLD OUTDES(LOGLIST) REUSE\",\n\"  LRECL(121) BLKSIZE(1210) RECFM(F B A)\"\nEXIT\n/* EXEC TO ALLOCATE ISPLOG AND ISPLIST SYSOUT DATA SETS WITH A   */\n/* DYNAMIC OUTPUT DESCRIPTOR                                     */\n./ ADD NAME=SUPERC   0160-89166-91200-0731-00043-00059-00000-JCL\n)CM\n)CM *****     JOB CARD GENERATED ON THE FLY BY JCI MACRO  *****\n)CM\n//*\n//*   JCL FOR BATCH EXECUTION OF SEARCH-FOR (ISPF OPTION 3.14)\n//*\n)CM\n)CM *****     SUPERC WITH SEARCH-FOR OPTION                 *****\n)CM\n//SUPERC   EXEC  PGM=ISRSUPC,PARM=(SRCHCMP,ANYC)\n//NEWDD    DD  DSN=&NEWDD,\n//             DISP=SHR&NEWVOL\n//OUTDD    DD  SYSOUT=*\n)SEL &SFS1 \u00ac= &Z\n&SRCH1 &SFS1\n)ENDSEL\n)SEL &SFS2 \u00ac= &Z\n&SRCH2 &SFS2\n)ENDSEL\n)SEL &SFS3 \u00ac= &Z\n&SRCH3 &SFS3\n)ENDSEL\n)SEL &SFS4 \u00ac= &Z\n&SRCH4 &SFS4\n)ENDSEL\n)SEL &SFS5 \u00ac= &Z\n&SRCH5 &SFS5\n)ENDSEL\n)SEL &SFS6 \u00ac= &Z\n&SRCH6 &SFS6\n)ENDSEL\n)SEL &SFS7 \u00ac= &Z\n&SRCH7 &SFS7\n)ENDSEL\n)SEL &SFS8 \u00ac= &Z\n&SRCH8 &SFS8\n)ENDSEL\n)SEL &SFS9 \u00ac= &Z\n&SRCH9 &SFS9\n)ENDSEL\n)SEL &SFS10 \u00ac= &Z\n&SRCH10 &SFS10\n)ENDSEL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPFPC": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x10/\\x00\\x99\\x10/\\t)\\x00\\xff\\x00\\xff\\x00\\x00\\xe2\\xd7\\xc6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-04-12T00:00:00", "modifydate": "1999-04-12T09:29:00", "lines": 255, "newlines": 255, "modlines": 0, "user": "SPF"}, "text": "./ ADD NAME=FX       0101-93312-95019-1344-00116-00092-00000-SPFPC\n/* SPF/PC Version 3.0 */\n\"ISREDIT MACRO (FXSTRING COL1 COL2 OTHER)\"\n/*--------------------------------------------------------------------*/\n/*     FX Edit Macro - FIND ALL 'string' (after EXCLUDE ALL lines)    */\n/*--------------------------------------------------------------------*/\n/*    5 Oct 94 - Support ' and \" as string delimiters                 */\n/*               Support other FIND parameters:                       */\n/*                 1.  LABEL-RANGE                                    */\n/*                 2.  PREFIX, SUFFIX, AND WORD                       */\n/*               Issue message on syntax/severe error                 */\n/*   20 May 93 - Quoted strings must be entered as:  FX \"'edit mac'\"  */\n/*               in order to pass quotes to the FIND command          */\n/*   14 May 93 - Convert to Rexx for SPF/PC Version 3.0               */\n/*   21 Apr 92 - Support (P)icture, He(X), (T)ext, and (C)haracter    */\n/*               string arguments                                     */\n/*    9 Mar 92 - Support CLIST &variables as string arguments         */\n/*    1 Oct 91 - Support FIRST/LAST columns as parameters             */\n/*               Support sequence numbers as searchable data          */\n/*--------------------------------------------------------------------*/\nTRACE\nIF fxstring = \"\" THEN\n  DO\n    zedsmsg = \"ENTER FIND STRING\"\n    zedlmsg = \"FX REQUIRES A STRING AS AN ARGUMENT\"\n    \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\nIF DATATYPE(fxstring) = \"NUM\" THEN\n  fxstring = \"'\"fxstring\"'\"\nIF SUBSTR(fxstring,1,2) = \"C'\" |,\n   SUBSTR(fxstring,1,2) = \"c'\" |,\n   SUBSTR(fxstring,1,2) = \"P'\" |,\n   SUBSTR(fxstring,1,2) = \"p'\" |,\n   SUBSTR(fxstring,1,2) = \"T'\" |,\n   SUBSTR(fxstring,1,2) = \"t'\" |,\n   SUBSTR(fxstring,1,2) = \"X'\" |,\n   SUBSTR(fxstring,1,2) = \"x'\" |,\n   SUBSTR(fxstring,1,1) = \"'\"  |,\n   SUBSTR(fxstring,1,1) = '\"'     THEN\n  quote = ''\nELSE\n  quote = \"'\"\n\"ISREDIT (STAT,VALUE) = NUMBER\"  /* SAVE NUMBER SETTING */\n\"ISREDIT NUMBER OFF\"             /* SEARCH SEQUENCE NUMBERS ON 'FIND' */\n\"ISREDIT EXCLUDE ALL\"\n\"ISPEXEC CONTROL ERRORS RETURN\"\n/*--------------------------------------------------------------------*/\n\"ISREDIT FIND ALL\" fxstring col1 col2 other\n/*--------------------------------------------------------------------*/\nfindcc = rc\nIF findcc > 4 THEN\n  DO\n    zedsmsg = \"PARAMETER NOT RECOGNIZED\"\n    zedlmsg = \"CHECK FOR MISSPELLED KEYWORDS OR \"||,\n              \"TOO MANY BOUNDS OR RANGE PARAMETERS.\"\n    \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n    \"ISREDIT RESET EXCLUDED\"\n    SIGNAL restore_number\n  END\n\"ISREDIT (FINDS) = FIND_COUNTS\"\n\"ISREDIT (LEFT,RIGHT) = BOUNDS\"\nSELECT\n  WHEN col1 = \"\"  &,\n       col2 = \"\"  THEN\n    NOP\n  OTHERWISE\n    DO\n      IF col1 \u00ac= \"\" &,\n         DATATYPE(col1) = \"NUM\" THEN\n        left = col1\n      IF col2 \u00ac= \"\" &,\n         DATATYPE(col2) = \"NUM\" THEN\n        right = col2\n      IF DATATYPE(col1) = \"NUM\" &,\n         DATATYPE(col2) \u00ac= \"NUM\" THEN\n        DO\n          right = (left + LENGTH(fxstring)) - 1\n          IF SUBSTR(fxstring,1,1) = \"'\" |,\n             SUBSTR(fxstring,1,1) = '\"' THEN\n            right = right - 2\n        END\n    END\nEND\nIF findcc > 0 THEN\n  DO\n    zedsmsg = \"NO CHARS \"quote||fxstring||quote\" FOUND\"\n    zedlmsg = \"CHARS \"quote||fxstring||quote\" - NOT FOUND \"||,\n              \"ON ANY LINES (COLS \"left+0\" TO \"right+0\").\"\n    \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n    \"ISREDIT RESET EXCLUDED\"\n  END\nELSE\n  DO\n    zedsmsg = finds+0\" CHARS \"quote||fxstring||quote\n    zedlmsg = \"CHARS \"quote||fxstring||quote\" FOUND \"||,\n               finds+0\" TIMES WITHIN COLUMNS \"left+0\" TO \"right+0\".\"\n    \"ISPEXEC SETMSG MSG(ISRZ000W)\"\n  END\nrestore_number:\nIF stat = \"OFF\" THEN\n  NOP\nELSE\n  DO\n    PARSE VAR value std cobol display\n    restore = \"\"\n    IF std = \"STD\" THEN\n      restore = restore || \" \" || std\n    IF cobol = \"COBOL\" THEN\n      restore = restore || \" \" || cobol\n    IF display = \"DISPLAY\" THEN\n      restore = restore || \" \" || display\n    \"ISREDIT NUMBER = \"stat restore        /* RESTORE NUMBER SETTING */\n  END\nEXIT\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO DO FIND ALL AFTER EXCLUDE ALL */\n./ ADD NAME=PLUG     0106-93327-95039-0839-00137-00136-00000-SPFPC\n/* SPF/PC Version 3.0 */\n\"ISREDIT MACRO (PLUGSTR COL LABEL1 LABEL2) NOPROCESS\"\nTRACE\nIF plugstr = '' THEN\n  DO\n    zedsmsg = 'NO PLUG STRING'\n    zedlmsg = 'YOU MUST SPECIFY A PLUG STRING'\n    \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\n/* SEE IF LABELS WERE USED WITH NO COLUMN SPECIFIED */\nIF SUBSTR(col,1,1) = '.' THEN\n  DO\n    label2 = label1\n    label1 = col\n    col = ''\n  END\n/* IF NO COLUMN SPECIFIED, THEN USE CURSOR POSITION */\nIF col = '' THEN\n  DO\n    \"ISREDIT (END)  = LRECL\"\n    \"ISREDIT (CL,CC) = CURSOR\"\n    IF cc = 0 |,\n       cc > end THEN\n      DO\n        zedsmsg = 'SPECIFY START COLUMN'\n        zedlmsg = 'USE A NUMBER OR CURSOR LOCATION FOR START OF PLUG'\n        \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    ELSE\n      col = cc\n  END\nELSE\n  IF DATATYPE(col) <> 'NUM' THEN\n    DO\n      zedsmsg = 'START COLUMN NOT NUMERIC'\n      zedlmsg = 'USE A NUMERIC FOR THE START COLUMN NUMBER'\n      \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n      EXIT 12\n    END\n/* IF .LABELS WERE SPECIFIED, IGNORE (O) LINE RANGE */\nIF SUBSTR(label1,1,1) = '.' THEN\n  DO\n    label1 = TRANSLATE(label1)\n    label2 = TRANSLATE(label2)\n    \"ISPEXEC CONTROL ERRORS RETURN\"\n    \"ISREDIT (FR)  = LINENUM \"label1\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE LABEL ERROR'\n        zedlmsg = '\"'label1'\" RECOGNIZED AS INVALID',\n                  'OR UNDEFINED LABEL IN PLUG CMD'\n        \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    \"ISREDIT (LR)  = LINENUM \"label2\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE LABEL ERROR'\n        zedlmsg = '\"'label2'\" RECOGNIZED AS INVALID',\n                  'OR UNDEFINED LABEL IN PLUG CMD'\n        \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    /* SET CURSOR ON FIRST LINE IN RANGE */\n    \"ISREDIT CURSOR = \"label1 \"1\"\n    labels = 'YES'\n  END\n/* PROCESS LINE COMMANDS, CHECK IF O/C WAS SPECIFIED */\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\"ISREDIT PROCESS RANGE O C\"\nIF rc > 0 &,\n   labels <> 'YES' THEN\n  DO\n    zedsmsg = 'ENTER \"O\" LINE CMD'\n    zedlmsg = 'YOU MUST SPECIFY THE \"DATA\" LINES',\n              'TO BE PLUGGED, USING \"On\" OR \"OO\",',\n              'OR LABELS'\n    \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n    EXIT 12\n  END\nIF labels <> 'YES' THEN\n  DO\n    /* .ZFRANGE NOT SET IF ON SPECIAL LINES */\n    \"ISREDIT (FR)  = LINENUM .ZFRANGE\"\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE \"On\" ERROR'\n        zedlmsg = 'YOU MUST NOT SPECIFY \"On\" OR \"OO\"',\n                  'WHICH STARTS ON SPECIAL LINES'\n        \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    /* .ZLRANGE NOT SET IF ON SPECIAL LINES */\n    \"ISREDIT (LR)  = LINENUM .ZLRANGE\"\n    IF rc > 0 THEN\n      DO\n        zedsmsg = 'PROBABLE \"On\" ERROR'\n        zedlmsg = 'YOU MUST NOT SPECIFY \"On\" OR \"OO\"',\n                  'WHICH ENDS ON SPECIAL LINES'\n        \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n        EXIT 12\n      END\n    /* SET CURSOR ON FIRST LINE IN RANGE */\n    \"ISREDIT CURSOR = .ZFRANGE 1\"\n  END\n\npluglen = LENGTH(plugstr)\n/* CHECK FOR PLUG STRING DELIMITERS */\nIF SUBSTR(plugstr,1,1) = \"'\" |,\n   SUBSTR(plugstr,1,1) = '\"' THEN\n  pluglen = pluglen - 2\nELSE\n  plugstr = \"'\"plugstr\"'\"\nanychar = COPIES('=',80)\ni = fr\nDO WHILE i <= lr\n  \"ISREDIT CHANGE P'\"SUBSTR(anychar,1,pluglen)\"'\" plugstr col\n  chgcc = rc\n  IF chgcc > 0 THEN\n    DO\n      zedsmsg = \"PLUG FAILED, RC=\"chgcc\n      zedlmsg = \"TARGET LINES \"fr+0\" TO \"lr+0\" AT COLUMN\" col+0\n      \"ISPEXEC SETMSG MSG(ISRZ001W)\"\n      EXIT 12\n    END\n  i = i + 1\nEND\nzedsmsg = \"CHARS \"plugstr\" PLUGGED\"\nzedlmsg = \"CHARS \"plugstr\" PLUGGED IN LINES \"fr+0\" TO \"lr+0\" AT COLUMN\" col+0\n\"ISPEXEC SETMSG MSG(ISRZ001W)\"\n/* SET CURSOR ON FIRST LINE IN RANGE */\n\"ISREDIT CURSOR = \"fr col\nEXIT 0\n/* J. KALINICH, X4521 */\n/* EDIT MACRO TO PLUG DATA INTO A RANGE OF LINES             */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSURX": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17O\\x00\\x99\\x17O\\x19\\x19\\x00u\\x00u\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-23T00:00:00", "modifydate": "1999-06-23T19:19:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX -\n +------------------------------------------------------------------+\n | Name:       TSURXS                                               |\n | Type:       REXX exec                                            |\n | Purpose:    Display TSO userid from the OUCB                     |\n | Release:    OS/390 2.4                                           |\n | Programmer: John Kalinich                                        |\n | Date:       04/28/99                                             |\n | Abstract:   Display all TSO userids in sorted order              |\n |                                                                  |\n | Call Format:  TSURX                                              |\n |                                                                  |\n | Logic: Extracts the CVT (at x'10')                               |\n |        Extracts the ASVT (CVT+x'22C')                            |\n |        Extracts first available ASVT entry (ASVT+x'20C')         |\n |  .---> Extracts the next ASCB in vector table                    |\n |  |     Extracts the OUCB (ASCB+x'90')                            |\n |  '---- Extracts OUCBUSRD                                         |\n +------------------------------------------------------------------+ */\nArg\nTrace\nNumeric Digits 10\n\ncvt_ptr   = Get_ptr(10,0)\nasvt_ptr  = Get_ptr(cvt_ptr,'22c')\nmax_users = X2d(Get_ptr(asvt_ptr,'204'))           /* Max ASID's     */\nasvt_frst_ptr = D2x(x2d(asvt_ptr) + x2d(20c))      /* ASVTFRST       */\n\n/*  Master Scheduler, ASID=1, ASVT+x'210'     */\n\ncount = 0\nuserid. = ''\nSay 'TSO Users:'\n\nDo max_users\n  asvt_frst_ptr = D2x(X2d(asvt_frst_ptr) + X2d(4)) /* Next ASID      */\n  ascb_ptr = Get_ptr(asvt_frst_ptr,0)\n\n  If Bitand(Left(X2c(ascb_ptr),1),'80'x) = '80'x   /* Available ASID */\n    Then\n      Iterate\n\n  ascb_jbns_ptr = Get_ptr(ascb_ptr,'b0')\n  If ascb_jbns_ptr = '00000000' Then               /* No jobname     */\n    Iterate\n\n  oucb_ptr = Get_ptr(ascb_ptr,'90')\n  oucb_yfl = Get_data(oucb_ptr,'12',1)\n  If Bitand(oucb_yfl,'20'x) <> '20'x Then          /* Not a Logon    */\n    Iterate\n\n  oucb_usrd = Get_data(oucb_ptr,'d0',8)\n  If Left(oucb_usrd,1) = '40'x Then                /* No userid      */\n    Iterate\n\n  count = count + 1\n  userid.count = oucb_usrd\nEnd\n\nCall Sort_Userids\nCall Print_Userids\n\nExit\n\nSort_Userids:  /* Bubble sort */\n  last = count - 1\n  Do x = 1 to last\n    Do y = x to last\n      z = y + 1\n      If userid.x > userid.z Then\n        Do\n          userid.hold = userid.x\n          userid.x = userid.z\n          userid.z = userid.hold\n        End\n    End\n  End\n  Return\n\nPrint_Userids:  /* 8 to a line */\n  line = ''\n  Do x = 1 to count\n    line = line || userid.x\n    If x // 8 = 0 Then\n      Do\n        Say line\n        line = ''\n      End\n  End\n  Say line\n  Return\n\nGet_ptr: Procedure\n  /* +-----------------------------------------+\n     3 returns a 4 byte pointer as hexadecimal 3\n     3 string at address addr+offset.          3\n     3 ADDR and OFFSET must be HEX strings.    3\n     +-----------------------------------------+ */\n  Arg addr, offset\n  temp = D2x(X2d(addr) + X2d(offset))\n  Return C2x(Storage(temp,4))\n  Exit\n\nGet_data: Procedure\n  /* +-----------------------------------------+\n     3 returns LENGTH bytes at ADDR+OFFSET as  3\n     3 an EBCDIC string.                       3\n     3 ADDR and OFFSET must be HEX strings.    3\n     3 LENGTH must be a decimal string.        3\n     +-----------------------------------------+ */\n  Arg addr, offset, length\n  temp = D2x(X2d(addr) + X2d(offset))\n  Return Storage(temp,length)\n  Exit\n\n/* J.Kalinich, x4521 */\n/* Exec to list TSO users (sorted by userid)                        */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT078/FILE078.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT078", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}