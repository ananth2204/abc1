{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012302000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2116296, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE533.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2116296, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2116296, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE533.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\"\\x03'", "DS1TRBAL": "b'\\xb5\\xf4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xef\\x00\\x0b\\x03\\xf2\\x00\\x00\\x00#'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00%\\x01\\x16\\x03o\\x01\\x16\\x03o\\x16\\x19\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-02-05T00:00:00", "modifydate": "2016-02-05T16:19:25", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  533\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE533\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 38 MEMBERS COUNTED; CUMULATIVE SIZE IS 19,608 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/05/16    16:19:25    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$COSBG": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x046_\\x01\\x046_\\x159\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-30T00:00:00", "modifydate": "2004-12-30T15:39:57", "lines": 12, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "Virtual Tape Transportation System (VTTS)\n\nCopyright (c) 2001 - 2005 by Sam Golob\n\nAll rights reserved, except where specific permission\nis given by the copyright holder.\n\nPermission is granted to assemble and run the subset of\nthese materials from the Virtual Tape Transportation\nSystem which are present on the CBT Tape collection,\nbut all rights remain with the copyright holder.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$CHANGE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x01\\x01\\x024/\\x01\\x05 \\x9f\\x10\\x14\\x00\\\\\\x00\\t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2002-12-08T00:00:00", "modifydate": "2005-07-28T10:14:01", "lines": 92, "newlines": 9, "modlines": 0, "user": "SBGOLOB"}, "text": "        VTT2 Package Revision History - after the initial release\n\n  Copyright (c) 2001-2005 by Sam Golob.\n\n  Any commercially sold or restricted components of this system\n    will not be available or distributed with the CBT Tape\n    software collection.  Presence of a component on the CBT\n    Tape collection indicates that the copyright holder allows\n    use by the public, of that component.\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nRevision  01/02/05\n\n  VTT2T2FK  -  This is a new program which creates a FAKETAPE (TM)\n   1.12        image disk file from any tape input.  Similar in\n               function to VTT2DISK, except that the output disk\n               file is in FAKETAPE format instead of AWS format.\n\nRevision  12/30/04\n\n  VTT2DISK  -  Fixed the program logic to be able to create an AWS\n   1.12        tape file with any size chunks, up to 65535 bytes\n               (which is the default).  The chunk size can be changed\n               either at assembly time by changing a global variable,\n               or in SYSIN by using the CHUNKSIZE=nnnnn keyword,\n               starting in column 1.  All data folding is now done\n               by a sub-program called FOLDEM, which is driven by a\n               control block called FLDAREA.  See the code for\n               details.\n\nRevision  07/28/05\n\n  VTT2TAPE  -  Put in ASG enhancement to allow a volser change\n   1.13        through a PARM='TVOL=nwvser', or\n               PARM='TVOL(nwvser)'.  When entering the new volser\n               this way, I put in a check for short volsers (less\n               than 6 characters) and ran the volser from the PARM\n               through a translate table first, to uppercase it\n               and clean it up somewhat.  The volser that is coded\n               in the SYSIN DD card can completely override this,\n               so you still have the freedom to create bizarre\n               volsers if you really want to.  BTW, you do not\n               need to code the new volser in the JCL.  This\n               program does not do a RDJFCB to find out what is in\n               the JCL.\n\nRevision  12/12/04\n\n  VTT2TAPE  -  Fixed the program logic to be able to read an AWS\n   1.12        tape file with \"short chunks\".  Included the UNFOLDEM\n               program to do all data moves from the folded FB-80\n               AWS-format file, to the data buffer.  So this logic\n               has been completely removed from the VTT2TAPE main\n               program.  The UNFOLDEM program is driven by the\n               contents of a control block called UNFAREA.  See the\n               program code itself for further explanation.\n\n  VTT2FK2T  -  This is a new program, modeled after the current\n   1.12        version of VTT2TAPE, which reads a FLEX-ES FAKETAPE\n               file, folded into FB-80 format on any MVS system,\n               and writes a real tape on a real (or virtual) tape\n               drive, from the FAKETAPE file data.\n\nRevision  07/22/03\n\n  VTT2TAPE  -  Added optional SYSIN ddname to be able to change\n   1.10        the volser of the output tape.  Code as follows:\n\n               //SYSIN DD *\n               NEWVOL=volser     (has to start in column 1)\n               /*\n\n  VTT2DISK  -  Added parameter IDRCOFF.  If this is coded, then\n   1.10        VTT2DISK turns off the IDRC indicators in the output\n               AWS tape file.  These are in the VOL1 label, and the\n               HDR2, EOF2, EOV2 labels.\n\nRevision  12/11/02\n\n  VTT2CNVU  -  Changed trailer characters to fill out the FB-80\n   1.1         fixed records, from x'20' to x'00' as per request\n               from Reed Petty, and the discussion of the Hercules\n               forum.\n\nRevision  12/10/02\n\n  VTT2DISK  -  Changed trailer characters to fill out the FB-80\n   1.11        fixed records, from x'20' to x'00' as per request\n               from Reed Petty, and the discussion of the Hercules\n               forum.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$VTT2DOC": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x000\\x01\\x01)\\x8f\\x01\\x046_\\x16\\x07\\x00\\xcc\\x00\\x82\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-10-25T00:00:00", "modifydate": "2004-12-30T16:07:30", "lines": 204, "newlines": 130, "modlines": 0, "user": "SBGOLOB"}, "text": "         Documentation for the VTT2TAPE and VTT2DISK Programs\n\n        (A part of VTTS - \"Virtual Tape Transportation System\")\n\nSam Golob - copyright (c) 2001-2005 by Sam Golob\n\n    The VTTS (Virtual Tape Transportation System) is copyrighted\n    and owned by Sam Golob.  But modules VTT2TAPE and VTT2DISK in\n    their \"free versions\" will be freely usable without charge,\n    even though these programs are the property of Sam Golob,\n    either in source code, object deck, or load module form, or\n    in any format or encoded in any way.\n\n    What are the \"free versions\"?  These are the versions of VTT2TAPE\n    and VTT2DISK that are distributed with the CBT Tape collection.\n\n    The VTT2DISK and VTT2TAPE programs allow an MVS system to move\n    entire tapes to disk, and create tapes from these disk files again.\n\n    The VTT2CNVU program is an MVS program to convert RECFM=VB AWS\n    files into FB-80 format, so they can be read by VTT2TAPE to cut\n    a real tape.\n\n    The VTT2FK2T program is like VTT2TAPE, but it takes a FAKETAPE\n    virtual tape file (from FLEX-ES), which had been folded into FB-80\n    format on any MVS system, and writes a real tape from that data.\n    FTP will fold an external file of this type, like a FAKETAPE file,\n    into an FB-80 format MVS file, if you tell it to, or if you\n    pre-allocate the target file as FB-80 on the MVS system.\n\nSome of the need for the programs:\n\n            AWS Tape format is produced by P/390 and Hercules systems\n            to create disk files, which an MVS system reads and writes,\n            as if they were actual tapes.   Therefore, an MVS system\n            without a tape drive, if it is so equipped to produce\n            \"virtual tapes\" in AWS Tape format, can write to tapes, and\n            read from tapes.  These tapes are really disk files.\n            Another name for these disk files is \"virtual tapes\",\n            because the MVS system looking at these files \"thinks\"\n            that they really are tapes.\n\n            There have existed programs which can read REAL tapes and\n            create virtual tapes from them.  One example is Brandon\n            Hill's AWSUTIL program.  These virtual tapes can be loaded\n            on a Hercules system somewhere and be read as a tape.\n\n            Our program VTT2DISK performs this function also, by\n            reading a REAL tape and producing an FB-80 \"folded\n            AWS-format tape\" as an MVS disk file.  In doing the reading,\n            the VTT2DISK program produces a lot of stats about the tape.\n            The advantage of the VTT2DISK program is that it can be run\n            on a \"big iron\" mainframe-based MVS system that cannot\n            normally produce AWS-format virtual tapes.  VTT2DISK\n            will produce AWS-format \"tape\" disk files on \"real MVS\".\n\n            The main problem is, to also go the other way.\n\n            Suppose you have an MVS system that can't read a tape in\n            AWS format.  Most large MVS systems which are not P/390 or\n            Hercules machines, but they are real MVS machines--big\n            iron--are in this position.  So for them, how do you\n            convert an AWS \"virtual tape\" disk file to some format\n            that the MVS system can convert into a REAL tape?  That\n            is the purpose of the VTT2TAPE program.\n\n            As easy as the concept seems:  Take an AWS format tape, and\n            make it readable to MVS--in practice, there is a large\n            complication, which I hope to explain.\n\n            A large part of describing this problem is the understanding\n            of the rather simple AWS tape format.  Once you understand\n            AWS tape format (as it exists on an OS/2 system or a PC),\n            the difficulty of reading this file on a \"pure MVS system\"\n            will become clear.  I hope that the rest of my explanation\n            will serve to clear up the difficulty.\n\nAWS Tape File on OS/2 or a PC is a Continuous stream of data:\n\n            The essence of the AWS tape format is that on a PC, or on\n            an OS/2 system, the \"tape file\" appears logically, as one\n            continuous stream of data.  For example, a CBT Master Tape,\n            (the SL version that I use), at the time of this writing,\n            is about 331 million bytes long.  On OS/2 or on the PC, this\n            looks like one continuous stream of data that is 331 million\n            bytes long.  For all practical purposes there is no blocking\n            of the data at all.\n\n            That presents a problem on MVS, where just about all data\n            has to be blocked.   On MVS, you must \"fold the data over\"\n            into blocks and records.  For my convenience, I have\n            chosen to fold the AWS tape data as Fixed Blocked LRECL=80\n            card image files.  Such files are conveniently handled on\n            MVS systems and in transmission processes, and you can\n            browse (and even edit) all of the \"tape data\" on TSO.\n            (You can even read the FB-80 \"tape data\" into an internal\n            reader.)\n\n            Then you must un-fold the data, logically.\n\n            My MVS program VTT2TAPE reads in the AWS tape data that was\n            uploaded to MVS from a PC or OS/2 system, and folded into\n            FB-80 card images, and it writes out an actual tape, using\n            EXCP to write the blocks.\n\n            As with the VTT2DISK program, the VTT2TAPE program produces\n            many stats, as it writes the new tape from the disk version\n            of the \"tape\" in FB-80 AWS format.\n\nAWS Tape Format:\n\n            Although a \"tape\" in the AWS Tape format appears\n            continuous, tape files are delimited by means of 6-byte\n            headers.  Each tape block is preceded by a header, and\n            followed by a header.  Also, end-of-file is indicated by\n            a different header.  The end-of-file header roughly\n            corresponds to a tape mark, preceded by the \"write out\"\n            of the last data block.  Every AWS tape file starts out\n            with a header.\n\n            Three two-byte segments comprise the header.\n\n            The first two-byte segment contains the number of bytes in\n            the block to follow (but this is in \"PC format\" with the\n            two bytes reversed).\n\n            This value will be zero for the header that comes after\n            the last block of a file.\n\n            The second two-byte segment contains the number of bytes in\n            the block of data which immediately preceded this header.\n            That value may be zero, and is zero if the header is the\n            first header for a file.  Again, the two-byte value cannot\n            be read as a halfword quantity, unless the bytes are\n            reversed.  This is the backwards PC Intel format for\n            halfwords (which I term BIF, or Backwards Intel Format).\n\n            The third two-byte piece of the header might be more\n            complicated in the future, but right now it is very\n            simple:   X'A000' denotes a block in the beginning or\n            in the middle of a file.  X'4000' denotes an end-of-file.\n\n            A block of data might be broken up into CHUNKS.  Each\n            chunk lies between two headers.  The flag byte in the\n            header preceding the beginning chunk of a block is\n            X'80'.  The flag byte for the middle chunk of a block is\n            X'00'.  The flag byte for the end chunk of a block is\n            X'20'.  If a chunk is an entire block, then its flag\n            byte of the header preceding it, is X'A0' (combined\n            X'80' and X'20') as we have stated before.\n\n            A final tapemark for a tape, therefore, is:\n                 X'000000004000'\n\n            That's all folks.  It's all very simple.  You just have\n            to think about it.\n\nBackwards Intel Halfword Format:\n\n            Halfwords in the AWS headers are in \"Backwards Intel\n            Format\" or \"PC Format\".  For example, the quantity\n            32720, which is a normal block size for Fixed 80-byte\n            LRECL files, is usually represented in a halfword as\n            X'7FD0'.  But in Backwards Intel Format, this is\n            represented as X'D07F'.  (Got it?)\n\nThe Hard Part:\n\n            The hard part of writing VTT2TAPE was:\n\n            1 - Tracking through the 80-byte records and finding\n                all the headers.\n\n            2 - Correctly moving the right number of data bytes,\n                and the right data blocks that are in between the\n                headers, to the correct place in the output buffer\n                that is in the program.\n\n            3 - Once each data block is moved entirely, and\n                correctly, into the output buffer (in the program),\n                putting them out to tape with EXCP is a snap.\n                The number of bytes to move is taken from the\n                \"next byte count\" field in the header that\n                precedes the current block.  This value is checked\n                against the accumulated total of data bytes moved.\n\n            4 - The X'4000'-third-byte headers cause the write of a\n                tape mark.\n\n   The data unfolding from FB-80 file to tape buffer is now done by\n   a completely separate sub-program called UNFOLDEM.  The data\n   folding from tape buffer to FB-80 file is now done by a completely\n   separate sub-program called FOLDEM.  Each of these sub-programs\n   communicates with its caller by means of a control block.  The\n   UNFOLDEM program uses the UNFAREA control block, and the FOLDEM\n   program uses the FLDAREA control block.  The formats of these\n   are included here, as appropriately named members of this pds.\n\nWell folks, that's how it works:\n\n       Sam Golob        email:  sbgolob@attglobal.net\n                                sbgolob@aol.com\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE533": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x16\\x01\\x16\\x03o\\x01\\x16\\x03o\\x16\\x19\\x00\\x9d\\x00\\x9d\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-02-05T00:00:00", "modifydate": "2016-02-05T16:19:16", "lines": 157, "newlines": 157, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 533 is from Sam Golob, and contains the VTT2TAPE and      *   FILE 533\n//*           VTT2DISK programs, in their \"free versions\".          *   FILE 533\n//*                                                                 *   FILE 533\n//*           The programs in this package are part of the          *   FILE 533\n//*           Virtual Tape Transportation System (VTTS), which      *   FILE 533\n//*           is copyrighted (c) 2001 - 2005 by Sam Golob.          *   FILE 533\n//*                                                                 *   FILE 533\n//*           Copyright notices are present in the source and       *   FILE 533\n//*           load modules, but the versions of these programs      *   FILE 533\n//*           that are on the CBT Tape, ARE ALLOWED TO BE RUN       *   FILE 533\n//*           BY ANYONE, because the copyright holder has given     *   FILE 533\n//*           full permission.  The copyright holder retains all    *   FILE 533\n//*           ownership rights to the software.                     *   FILE 533\n//*                                                                 *   FILE 533\n//*           Member M370VTT2 has been added, which contains        *   FILE 533\n//*           a version of VTT2TAPE and VTT2DISK which can be       *   FILE 533\n//*           assembled using the XF assembler (IFOX00).            *   FILE 533\n//*           (This is courtesy of Gerhard Postpischil.)            *   FILE 533\n//*                                                                 *   FILE 533\n//*           Unless otherwise mentioned, AWS-format \"virtual tape\" *   FILE 533\n//*           files on an MVS system, have been folded over into    *   FILE 533\n//*           Fixed Blocked 80-byte record format.  AWS-format      *   FILE 533\n//*           files on other systems are just long strings of data. *   FILE 533\n//*           This can't happen on MVS--all data has to be blocked  *   FILE 533\n//*           on MVS.  So I chose FB-80 blocking for the AWS-format *   FILE 533\n//*           and FAKETAPE (TM) format \"virtual tape\" files on MVS. *   FILE 533\n//*                                                                 *   FILE 533\n//*           The FAKETAPE file format is a published interface     *   FILE 533\n//*           of Fundamental Software Inc. and they say in their    *   FILE 533\n//*           documentation that anyone has permission to use the   *   FILE 533\n//*           format, although Fundamental Software reserves the    *   FILE 533\n//*           right to change the format at any time.               *   FILE 533\n//*                                                                 *   FILE 533\n//*           FAKETAPE (TM) and FLEX-ES (TM) are registered         *   FILE 533\n//*           trademarks of Fundamental Software Inc.               *   FILE 533\n//*                                                                 *   FILE 533\n//*       Program Names:                                            *   FILE 533\n//*                                                                 *   FILE 533\n//*           VTT2TAPE - Program to convert AWS-format tape files   *   FILE 533\n//*                      to real tapes.  Any CHUNKSIZE is           *   FILE 533\n//*                      supported, up to the 65535-byte limit.     *   FILE 533\n//*           VTT2DISK - Program to create an AWS-format virtual    *   FILE 533\n//*                      tape file from a real tape.  Any           *   FILE 533\n//*                      CHUNKSIZE tape can be created.  Default    *   FILE 533\n//*                      chunksize is 65535 but that can be either  *   FILE 533\n//*                      changed at assembly time, or with a SYSIN  *   FILE 533\n//*                      CHUNKSIZE=nnnnn parameter.                 *   FILE 533\n//*           VTT2CNVU - Program to convert a VB-format AWS-format  *   FILE 533\n//*                      tape (such as the one produced by Brandon  *   FILE 533\n//*                      Hill's AWSUTIL program on CBT File 467)    *   FILE 533\n//*                      to FB-80 format on MVS, so that VTT2TAPE   *   FILE 533\n//*                      can be used subsequently to convert the    *   FILE 533\n//*                      data to a real tape.                       *   FILE 533\n//*           VTT2T2FK - Like VTT2DISK, except a real tape is       *   FILE 533\n//*                      converted to a FAKETAPE (TM) format tape.  *   FILE 533\n//*           VTT2FK2T - Like VTT2TAPE, except a FAKETAPE (TM)      *   FILE 533\n//*                      tape image, folded over on MVS into FB-80  *   FILE 533\n//*                      format, is converted into a real tape.     *   FILE 533\n//*                                                                 *   FILE 533\n//*           These programs run on an MVS system, and allow        *   FILE 533\n//*           real tapes to be converted to disk files, and         *   FILE 533\n//*           these disk files, back to real tapes.  These          *   FILE 533\n//*           programs do not require a P/390 or a FLEX-ES (TM)     *   FILE 533\n//*           system.  ANY MVS system will run these programs!      *   FILE 533\n//*                                                                 *   FILE 533\n//*           The VTT2DISK program reads a real tape, and           *   FILE 533\n//*           converts it to an AWS-format \"virtual tape\" file      *   FILE 533\n//*           on an MVS system, folded over into FB-80 format.      *   FILE 533\n//*           VTT2DISK now takes SYSIN input in column 1.           *   FILE 533\n//*           Allowed keywords are:                                 *   FILE 533\n//*                                                                 *   FILE 533\n//*           CHUNKSIZE=nnnn     Default is 65535 if not coded.     *   FILE 533\n//*                              This can be changed with an        *   FILE 533\n//*                              assembler global variable.         *   FILE 533\n//*           NEWVOL=volser   -  Changes the VOLSER on VOL1 label   *   FILE 533\n//*           READ            -  Produces READ only run, no AWSOUT  *   FILE 533\n//*           IDRCOFF         -  Turns off \"data is compressed\"     *   FILE 533\n//*                              \"P\" indicators in the tape labels  *   FILE 533\n//*                                                                 *   FILE 533\n//*           The VTT2TAPE program takes this \"folded over\" FB-80   *   FILE 533\n//*           AWS-format file on an MVS system, and cuts a real     *   FILE 533\n//*           tape from it, on a real tape drive.                   *   FILE 533\n//*                                                                 *   FILE 533\n//*           The VTT2FK2T program does a job similar to the        *   FILE 533\n//*           VTT2TAPE program, except that it takes an FB-80       *   FILE 533\n//*           folded image of a FLEX-ES FAKETAPE, and cuts a        *   FILE 533\n//*           real tape from it, on a real tape drive.  Therefore   *   FILE 533\n//*           a FAKETAPE image produced on a FLEX-ES system can     *   FILE 533\n//*           be uploaded in BINARY to an FB-80 format disk file    *   FILE 533\n//*           ON ANY MVS SYSTEM, and a real tape can be cut from    *   FILE 533\n//*           it.                                                   *   FILE 533\n//*                                                                 *   FILE 533\n//*           And VTT2T2FK creates a FAKETAPE file (folded into     *   FILE 533\n//*           FB-80 format) from a real tape.  If this file is      *   FILE 533\n//*           downloaded to the server machine on which FLEX-ES     *   FILE 533\n//*           is running, FLEX-ES can read this image as though     *   FILE 533\n//*           it were a tape.                                       *   FILE 533\n//*                                                                 *   FILE 533\n//*           The disk files which are in FB-80 folded AWS or       *   FILE 533\n//*           FAKETAPE format, can be FTP'ed back to the PC, OS/2   *   FILE 533\n//*           or LINUX server, and read by a P/390 or FLEX-ES or    *   FILE 533\n//*           HERCULES system as a tape.                            *   FILE 533\n//*                                                                 *   FILE 533\n//*           See member $VTT2DOC for details.                      *   FILE 533\n//*                                                                 *   FILE 533\n//*           VTT2TAPE has now been updated to be able to read      *   FILE 533\n//*           a folded AWS tape file that has its chunk size        *   FILE 533\n//*           smaller than the block size, and to produce a         *   FILE 533\n//*           real output tape from it.  Such AWS-format tapes      *   FILE 533\n//*           are created by FLEX-ES systems and the old (very      *   FILE 533\n//*           very very old) P/390 systems.                         *   FILE 533\n//*                                                                 *   FILE 533\n//*           And VTT2DISK can now produced a \"chunked\" AWS tape    *   FILE 533\n//*           file from a real tape.  FAKETAPE (TM) architecture    *   FILE 533\n//*           does not have provision to produced chunked output    *   FILE 533\n//*           (i.e. the tape blocks being divided into smaller      *   FILE 533\n//*           pieces, and the blocks being pieced together later).  *   FILE 533\n//*                                                                 *   FILE 533\n//*           These programs can now be run with PARM=READ in       *   FILE 533\n//*           the EXEC card, which is a \"READ ONLY\" execution       *   FILE 533\n//*           that produces reports about the input tape, or        *   FILE 533\n//*           disk file.                                            *   FILE 533\n//*                                                                 *   FILE 533\n//*           PARM=READ will read the AWS or tape inputs, and       *   FILE 533\n//*           produce these programs' abundant stats.  If you       *   FILE 533\n//*           want to \"measure a tape\" or an AWS-format tape file   *   FILE 533\n//*           on disk, you can use the PARM=READ facility, which    *   FILE 533\n//*           doesn't open the output file.  VTT2CNVU does not      *   FILE 533\n//*           (yet) support PARM=READ.                              *   FILE 533\n//*                                                                 *   FILE 533\n//*           PARM=IDRCOFF in VTT2DISK, will turn off the IDRC      *   FILE 533\n//*           indicators in VOL1, HDR2, EOF2, and EOV2 labels.      *   FILE 533\n//*                                                                 *   FILE 533\n//*           The contents of this file, are part of VTTS           *   FILE 533\n//*           (Virtual Tape Transportation System), which           *   FILE 533\n//*           is copyrighted by Sam Golob, but the versions         *   FILE 533\n//*           of the VTTS programs which are in the CBT Tape        *   FILE 533\n//*           collection, may be used without charge by anyone,     *   FILE 533\n//*           and the copyright owner grants permission.  Same      *   FILE 533\n//*           for the VTT2FK2T and VTT2T2FK programs.               *   FILE 533\n//*                                                                 *   FILE 533\n//*              Sam Golob  -  email:   sbgolob@attglobal.net       *   FILE 533\n//*                                     sbgolob@cbttape.org         *   FILE 533\n//*                                     sbgolob@aol.com             *   FILE 533\n//*                                                                 *   FILE 533\n//*           I've included a free C program from Leland Lucius,    *   FILE 533\n//*           called strippad.c (member STRIPPAD), which strips     *   FILE 533\n//*           off the padding bytes that VTT2DISK adds to the       *   FILE 533\n//*           last FB-80 record on MVS, if it is short.  It seems   *   FILE 533\n//*           that when you copy the FB-80 AWS-format disk file     *   FILE 533\n//*           back to the PC, Hercules has some problems handling   *   FILE 533\n//*           the padding bytes.  The P/390 doesn't.                *   FILE 533\n//*                                                                 *   FILE 533\n//*              Leland Lucius     email:  llucius@moneygram.com    *   FILE 533\n//*                                        llucius@homerow.net      *   FILE 533\n//*                                        hackules@digicron.com    *   FILE 533\n//*                                                                 *   FILE 533\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLDAREA": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x003\\x01\\x044\\x7f\\x01\\x05\\x00O\"E\\x00\\x0f\\x00\\x0b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-12-12T00:00:00", "modifydate": "2005-01-04T22:45:33", "lines": 15, "newlines": 11, "modlines": 0, "user": "SBGOLOB"}, "text": "FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\n*        copyright (c) 2004-2005 by Sam Golob\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLDDRVR": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01,\\x00\"\\x01\\x042o\\x01\\x046_\\x15\\t\\x01\\x85\\x00\\xb5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.44", "flags": 0, "createdate": "2004-11-21T00:00:00", "modifydate": "2004-12-30T15:09:22", "lines": 389, "newlines": 181, "modlines": 0, "user": "SBGOLOB"}, "text": "FLDDRVR  CSECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  FLDDRVR - Driver program to test the FOLDEM sub-program.         *\n*                                                                   *\n*    Purpose:  To test the ability of the FOLDEM program to fold    *\n*    -------   a block of data from a buffer to an FB-80 file,      *\n*              starting at a given location in the buffer, and      *\n*              beginning the fold, to a given offset into the       *\n*              FB-80 record, for a given number of bytes.  The      *\n*              FLDDRVR program opens a tape file and folds a        *\n*              certain number of bytes from it, into a given        *\n*              location at a given offset into an FB-80 file.       *\n*              PUTs are done, as necessary, into the FB-80 file,    *\n*              until the number of bytes to be moved, is            *\n*              satisfied.                                           *\n*                                                                   *\n*    Method:   The FOLDEM program is set up to operate from a       *\n*    ------    control block, called FLDAREA (the FOLDEM Area       *\n*              Control Block) which is updated by both the driver   *\n*              program and the FOLDEM program.  FLDAREA is passed   *\n*              back and forth between the driver program and the    *\n*              FOLDEM program, and is updated by both programs.     *\n*                                                                   *\n*   FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK           *\n*   *                           ------ ---- ------- -----           *\n*   FLDSCARD DC    F'0'         Start address of 80-byte card       *\n*   FLDECARD DC    F'0'         End address of 80-byte card         *\n*   FLDOFFST DC    F'0'         OFFSET of data in the card          *\n*   FLDBYTES DC    F'0'         Number of bytes to be folded now    *\n*   FLDBYTOT DC    F'0'         Batch total of bytes left to move   *\n*   FLDBYMVD DC    F'0'         Number of bytes folded now          *\n*   FLDBUFFR DC    F'0'         Current data start address          *\n*   FLDBSTRT DC    F'0'         Original start data address         *\n*   FLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records   *\n*   FLDLENTH EQU   *-FLDAREA                                        *\n*                                                                   *\n*    JCL:      The following is sample JCL to run the FLDDRVR       *\n*    ---       program:                                             *\n*                                                                   *\n*   //SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,                            *\n*   //    MSGCLASS=X,NOTIFY=&SYSUID                                 *\n*   //*                                                             *\n*   //FLDTEST  EXEC PGM=FLDDRVR                                     *\n*   //STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD                       *\n*   //AWSOUT    DD  DISP=SHR,DSN=SBGOLOB.CBT468.FILE533(TESTDATA)   *\n*   //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TSTDRV,               *\n*   //          LABEL=(1,NL,EXPDT=98000)                            *\n*   //*         LABEL=(1,BLP,EXPDT=98000)                           *\n*   //SYSPRINT  DD  SYSOUT=*                                        *\n*   //SYSIN     DD  *                                               *\n*   OFFSET=42                                                       *\n*   BYTESM=3000                                                     *\n*   /*                                                              *\n*                                                                   *\n*              The TESTDATA data is \"ruler data\" which measures     *\n*              the number of bytes in an obvious way, a small       *\n*              segment of this data looks like the following:       *\n*                                                                   *\n*     ----+----1----+----2----+----3----+----4----+----5----+----6  *\n*                                                                   *\n*              but it fills the entire 80-byte record and wraps     *\n*              around for several thousand bytes.  You can use      *\n*              it to measure if the correct number of data bytes    *\n*              have been moved, starting from the given offset      *\n*              location.  The illustrated JCL will look at the      *\n*              data in the current card, at an offset of +42 bytes  *\n*              from the beginning of the card, and copy 3000 bytes  *\n*              more out to a buffer, and write the buffer data out  *\n*              to a tape file.  The FOLDEM program will do as       *\n*              many GETs from the card file as needed, to fulfill   *\n*              the 3000 byte requirement.                           *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nFLDDRVR  AMODE 24\nFLDDRVR  RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'FLDDRVR'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING FLDDRVR,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nFLDDRV   DS    0H\n         OPEN  (SYSIN,(INPUT))\n         OPEN  (AWSOUT,(OUTPUT))\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (TAPIN,(INPUT))\n         L     R3,=A(BUFFAREA)      POINT TO BEGINNING OF TAPE BUFFER\n         ST    R3,SVBFAREA          SAVE BUFFAREA LOCATION\n         ST    R3,FLDBUFFR          AND PASS IT TO CALLED PROGRAM\n         ST    R3,FLDBSTRT          AND PASS IT TO CALLED PROGRAM\n         ZAP   FLDOUTCT,=P'0'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCARDREAD DS    0H              CHECK SYSIN FOR KEYWORDS AND PARMS        06356\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *    06357\n*              Insert User Code Here for Keywords                        06358\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *    06359\n         GET   SYSIN,CARDIN                                              06360\n*                                                                        06361\n* -- >>              <-- Intercept any keywords you want in SYSIN -->    06362\n* -- >>              <--    before you start the table scan       -->    06363\n*                                                                        06364\n* ----------------------------------------------------------------- *    06365\n         MVI   CARDWORK,X'40'           CLEAR CARD WORKAREA TO BLANKS    06366\n         MVC   CARDWORK+1(79),CARDWORK                                   06367\n         MVC   CARDWORK(80),CARDIN      MOVE CARD IMAGE TO WORKAREA      06368\n         OC    CARDWORK(80),CARDBLNK    UPPERCASE IT                     06369\n* ----------------------------------------------------------------- *    06370\n*      CARDWORK now contains an uppercased version of CARDIN.            06371\n* ----------------------------------------------------------------- *    06372\n         CLC   =C'OFFSET=',CARDWORK     KEYWORD PRESENT IN THIS CARD?    06373\n         BE    OFFSETMV          PROCESS THIS CARD FOR KEYWORD           06374\n         CLC   =C'BYTESM=',CARDWORK     KEYWORD PRESENT IN THIS CARD?    06373\n         BE    BYTESMVE          PROCESS THIS CARD FOR KEYWORD           06374\nOFFSETMV DS    0H                                                        06423\n         CLI   CARDIN+7,C' '     IS FIRST NUMBER VALUE BLANK?            06424\n         BE    CARDREAD          YES. IGNORE ENTIRE CARD                 06425\n         CLI   CARDIN+7,X'F0'    SMALLER THAN ZERO?                      06426\n         BL    CARDREAD          YES. IGNORE.                            06427\n         CLI   CARDIN+7,X'F9'    BIGGER THAN 9?                          06428\n         BH    CARDREAD          YES. IGNORE.                            06429\n         LA    R15,CARDIN+7      STARTING ADDRESS                        06431\n         LR    R1,R15            LOAD R1 WITH THIS ADDRESS               06432\nOFFSETNM DS    0H                                                        06433\n         LA    R15,1(,R15)       BUMP TO NEXT CHARACTER                  06434\n         C     R15,=A(CARDIN+71) END OF CARD?                            06435\n         BH    OFFSTGNM          YES, GET NUMBER                         06436\n         CLI   0(R15),C' '       BLANK HERE?                             06437\n         BE    OFFSTGNM          YES, GET NUMBER                         06438\n         B     OFFSETNM          NO. STEP UP ONE PLACE                   06439\nOFFSTGNM DS    0H                                                        06440\n         SR    R15,R1            HOW BIG IS THE NUMBER                   06441\n         BCTR  R15,0             LOWER IT FOR EXECUTE                    06442\n         EX    R15,PACKO         COPY THE NUMBER TO WORK AREA            06443\n         CVB   R0,WORKO          CONVERT IT TO BINARY                    06446\n         ST    R0,FLDOFFST       STORE THE VALUE FOR LATER USE           06447\n         B     CARDREAD                                                  06453\nBYTESMVE DS    0H                                                        06423\n         CLI   CARDIN+7,C' '     IS FIRST NUMBER VALUE BLANK?            06424\n         BE    CARDREAD          YES. IGNORE ENTIRE CARD                 06425\n         CLI   CARDIN+7,X'F0'    SMALLER THAN ZERO?                      06426\n         BL    CARDREAD          YES. IGNORE.                            06427\n         CLI   CARDIN+7,X'F9'    BIGGER THAN 9?                          06428\n         BH    CARDREAD          YES. IGNORE.                            06429\n         LA    R15,CARDIN+7      STARTING ADDRESS                        06431\n         LR    R1,R15            LOAD R1 WITH THIS ADDRESS               06432\nBYTESMNM DS    0H                                                        06433\n         LA    R15,1(,R15)       BUMP TO NEXT CHARACTER                  06434\n         C     R15,=A(CARDIN+71) END OF CARD?                            06435\n         BH    BYTESGNM          YES, GET NUMBER                         06436\n         CLI   0(R15),C' '       BLANK HERE?                             06437\n         BE    BYTESGNM          YES, GET NUMBER                         06438\n         B     BYTESMNM          NO. STEP UP ONE PLACE                   06439\nBYTESGNM DS    0H                                                        06440\n         SR    R15,R1            HOW BIG IS THE NUMBER                   06441\n         BCTR  R15,0             LOWER IT FOR EXECUTE                    06442\n         EX    R15,PACKB         COPY THE NUMBER TO WORK AREA            06443\n         CVB   R0,WORKB          CONVERT IT TO BINARY                    06446\n         ST    R0,FLDBYTES       STORE THE VALUE FOR LATER USE           06447\n         ST    R0,FLDBYTOT       STORE THE VALUE FOR LATER USE           06447\n         B     CARDREAD                                                  06453\nPACKO    PACK  WORKO,0(0,1)          <<< EXECUTED >>>                    06758\nPACKB    PACK  WORKB,0(0,1)          <<< EXECUTED >>>                    06758\nWORKO    DC    D'0'                                                      04810\nWORKB    DC    D'0'                                                      04810\n* --------------------------------------------------------- *\nSYSINEND DS    0H                FINISHED GETTING NUMBERS\n         CLOSE SYSIN\n* --------------------------------------------------------- *\n*   GET A TAPE RECORD                                       *\n* --------------------------------------------------------- *\nREADBUFF DS    0H\n         LA    R1,TAPIN           R1=address of current DCB\n         ST    R1,INDCBPT         Put it in IOB\n         MVC   INCCW+6(2),=X'FFFF'      Move length of block - max\n         MVC   INCCW+1(3),SVBFAREA+1    PRIME INPUT CCW\n         MVI   INECB,X'00'        Initialize ECB\n* - - - >\n         EXCP  INIOB              Read a block                           02401\n         WAIT  ECB=INECB          Wait for READ to complete              02402\n         TM    INCSW+4,X'01'      Was a Tape Mark read?                  02403\n         BO    READIN1            Yes, handle it.                        02404\n         CLI   INECB,X'7F'        Did the READ complete normally?        02405\n         BNE   READBERR           No. Report the error.                  02406\n*        LH    R2,INCCW+6         Calculate the READ length              02408\n         XC    FULLWORK,FULLWORK     Clear area completely.              02409\n         MVC   HALFWORK(2),INCCW+6   Original READ length 65535.         02410\n         L     R2,FULLWORK        Load R2 with fullword quantity.        02411\n*        LH    R3,INCSW+6         Get the residual byte count.           02412\n         XC    FULLWORK,FULLWORK     Clear area completely.              02409\n         MVC   HALFWORK(2),INCSW+6   Load lower halfword with count.     02413\n         L     R3,FULLWORK        Load R3 with fullword quantity.        02414\n         SR    R2,R3              Get actual length read.                02415\n         ST    R2,FLDBYTOT        Save quantity in FLDAREA field.        02416\n* - - - >\n         MVC   LINE,LINE-1\n         MVC   LINE+1(8),=C'READ   '\n         L     R1,SVBFAREA        Diagnostic printout of beg of buffer\n         HEX   LINE+10,61,0(R1)\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\nCOPYBACK DS    0H\n         MVC   MAXRC,=F'0'\n         B     MAKEFB80\nREADBERR DS    0H\n         MVC   MAXRC,=F'4'\n         B     RETURN\n* --------------------------------------------------------- *\nMAKEFB80 DS    0H\n* --------------------------------------------------------- *\n*   CALL THE FOLDEM PROGRAM                                 *\n* --------------------------------------------------------- *\n         MVC   FB80IN(80),ZEROCARD   Initialize FB-80 output area to 0s\n         LA    R1,FB80IN             Tell FLDAREA its beginning\n         ST    R1,FLDSCARD\n         A     R1,=F'80'             Add 80 bytes\n         ST    R1,FLDECARD           Tell FLDAREA its end location\n         L     R1,SVBFAREA           Get loc of beginning of buffer\n         ST    R1,FLDBUFFR           Fill both FLDAREA fields\n         ST    R1,FLDBSTRT\n         MVC   LINE+1(8),=C'BEFORE: '   Diagnostic picture before call\n         BAL   R9,FLDIMAGE\n         LA    R1,FLDAREA\n         L     R15,=V(FOLDEM)\n         BALR  R14,R15\n*                                       Copy back FLDAREA from FOLDEM\n         ST    R1,NEWFLDA\n         MVC   FLDAREA(FLDLENTH),0(R1)  Move modified FLDAREA to pgm\n         MVC   LINE+1(8),=C'AFTER : '   Diagnostic picture after call\n         BAL   R9,FLDIMAGE\nAWSOUEND DS    0H\n         MVC   LINE,LINE-1\n         L     R1,SVBFAREA\n         HEX   LINE+1,66,0(R1)\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         PUT   AWSOUT,FB80IN\n         AP    FLDOUTCT,=P'1'           Count of AWSOUT records written\n         MVC   LINE+1(8),=C'ENDPGM: '   Diagnostic picture at end\n         BAL   R9,FLDIMAGE\n* --------------------------------------------------------- *\nREADIN1  DS    0H\n* --------------------------------------------------------- *\nRETURN   DS    0H                RETURN TO THE OPERATING SYSTEM\n         CLOSE AWSOUT\n         CLOSE TAPIN\n         CLOSE SYSPRINT\n         L     R13,4(,R13)\n         MVC   16(4,R13),MAXRC      Load Maximum Return Code\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         BR    R9\n* --------------------------------------------------------- *\n         LTORG\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n* ------\nFB80IN   DS    CL80                 Card image INPUT area\n*\nFF       EQU   X'FF'\nCARDBLNK DC    80C' '\nCARDIN   DC    CL80' '\nCARDWORK DC    CL80' '\nZEROCARD DC    80X'00'\nSAVEBEGD DC    F'0'                 Save beg of buffer data address\nSAVEENDD DC    F'0'                 Save end of buffer data address\nSAVEBEGI DC    F'0'                 Save beg address of card input\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVER8TR DC    F'0'                 Save floating Reg 8 which decreases\nPARMPTR  DC    F'0'\nSAVER10  DC    F'0'\nSVBFAREA DC    F'0'\nSAVEPARM DC    F'0'\nNEWFLDA  DC    F'0'\nFULLWORK DS    0F                                                        05265\n         DC    H'0'                                                      05266\nHALFWORK DC    H'0'                HALFWORD WORK AREA                    05267\n         DC    2F'0'               FILLER                                05268\nMAXRC    DC    F'0'\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nLINE2    DC    CL133' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\nINCCW    DC    X'02',AL3(SVBFAREA),X'2000',X'FFFF'\nINECB    DC    F'0'\nINIOB    DC    X'02000000'\n         DC    A(INECB)\nINCSW    DC    2F'0'\nINCCWPT  DC    A(INCCW)\nINDCBPT  DC    A(TAPIN)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            PADDING\n         ENTRY AWSOUT\nAWSOUT   DCB   DDNAME=AWSOUT,MACRF=PM,EODAD=AWSOUEND,DSORG=PS,LRECL=80\nTAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X 05677\n               EODAD=SYSINEND                                            05678\nBUFFAREA DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FLDDRVR$": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x045\\x1f\\x01\\x045\\x1f\\t\"\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-16T00:00:00", "modifydate": "2004-12-16T09:22:41", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(FLDDRVR)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   FLDDRVR\n SETSSI  CB468533\n NAME    FLDDRVR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FLDDRVR#": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00F\\x01\\x01(\\x9f\\x01\\x045\\x1f\\x10\\x10\\x00\\x11\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2004-12-16T10:10:46", "lines": 17, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//UNFTEST  EXEC PGM=FLDDRVR\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSOUT    DD  DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.FLDDRVR.TEST,\n//          UNIT=SYSALLDA,VOL=SER=WORK01,\n//          DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\n//          SPACE=(TRK,(15,15),RLSE)\n//TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TSTDRV,\n//          LABEL=(1,NL,EXPDT=98000)\n//*         LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\nOFFSET=37\nBYTESM=7643\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FOLDEM": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x08\\x01\\x044\\x7f\\x01\\x046_\\x13\\x00\\x01\\xe1\\x01\\xac\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2004-12-12T00:00:00", "modifydate": "2004-12-30T13:00:08", "lines": 481, "newlines": 428, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'\nFOLDEM   CSECT\n*  ---------------------------------------------------------------  *\n*\n*   AUTHOR:       Sam Golob\n*\n*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,\n*                 subject to express permissions from the author\n*                 to use this software.  This software is part\n*                 of VTTS (Virtual Tape Transportation System).\n*\n*                 Permission is granted by the author for all\n*                 parts of the VTTS package which are distributed\n*                 on the CBT Tape collection, to be used by\n*                 anyone for their own use, but not for resale\n*                 or for reincorporation within commercial code.\n*\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    FOLDEM                                            *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating an      *\n*      AWS-format disk file from a real tape file.  The disk        *\n*      file is data that has been folded over from a buffer,        *\n*      into an FB-80 dataset.                                       *\n*                                                                   *\n*      This program takes buffer data and folds it into FB-80       *\n*      data, starting from a given buffer address, for a given      *\n*      number of bytes.  The data is folded into an 80-byte         *\n*      workarea starting from a given OFFSET address (+0 to +79)    *\n*      into the workarea.  When the workarea has been completely    *\n*      filled and more data is to be written, a PUT is done to      *\n*      write out the data from the 80-byte workarea, and then       *\n*      the workarea is cleared with binary zeros before any         *\n*      additional data is written to it.  An incompletely filled    *\n*      workarea is not written out, and the same is true if the     *\n*      workarea is full but no more data is to be written out.      *\n*      So in that case, the location of the workarea is returned    *\n*      to the caller in field FLDSCARD, and it is the caller's      *\n*      responsibility to do the PUT for the last card.              *\n*                                                                   *\n*  INPUTS and OUTPUTS:                                              *\n*                                                                   *\n*      This program is driven by a control block called FLDAREA,    *\n*      which is updated by both this program and by the caller.     *\n*      See below for more details.                                  *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called AWSOUT, which receives the output       *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do PUTs to AWSOUT, and if necessary, it needs       *\n*      to write messages to SYSPRINT.  Therefore the caller has     *\n*      to provide ENTRY AWSOUT and ENTRY SYSPRINT statements in     *\n*      front of its AWSOUT and SYSPRINT DCBs, respectively.         *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      FLDAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      FLDAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the caller's copy of FLDAREA, and upon return,      *\n*      R1 is pointed to the updated copy of FLDAREA in this         *\n*      subroutine.  So the caller has to copy it back over its      *\n*      own instance of FLDAREA after the return.                    *\n*                                                                   *\n*      The caller does one tape read, or read of data into a        *\n*      buffer.  From the number of bytes read, and possibly from    *\n*      the given chunk size also, the caller will construct an      *\n*      AWS header which will determine how many bytes should be     *\n*      folded into the FB-80 disk dataset.  This AWS header is      *\n*      also folded in by a call to this program, and then the       *\n*      tape data is folded in afterward, for the number of bytes    *\n*      required either by the chunk size or by the block size.      *\n*                                                                   *\n*      This program does one or more PUTs into the FB-80 file,      *\n*      until the request for the number of bytes to be folded,      *\n*      is satisfied.  A PUT is done whenever the FB-80 work area    *\n*      has been filled.  At the end of the fold operation, the new  *\n*      OFFSET into the FB-80 workarea (that has not yet been        *\n*      written out to disk), the number of bytes that have been     *\n*      folded, and the projected start of the next data to be       *\n*      folded, are returned in the fields of the FLDAREA control    *\n*      block.                                                       *\n*                                                                   *\n*      The following is the layout of the FLDAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *\n*      *                         ------ ---- ------- -----          *\n*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *\n*  --> FLDECARD DC    F'0'       End address of 80-byte card        *\n*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *\n*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *\n*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *\n*      FLDBYMVD DC    F'0'       Number of bytes folded now         *\n*  --> FLDBUFFR DC    F'0'       Current data start address         *\n*  --> FLDBSTRT DC    F'0'       Original start data address        *\n*      FLDOUTCT DC    PL7'0'     Number of PUTs for AWSOUT records  *\n*  --> FLDREADF DC    X'00'      This run is \"READ ONLY\"  ?         *\n*      *              X'01'      Yes, read only. (Copied from the   *\n*                                READFLAG byte in the caller.)      *\n*      FLDLENTH EQU   *-FLDAREA                                     *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      FLDBUFFR and FLDOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the input data      *\n*      and output data positions, respectively, that are just       *\n*      after the moved data, to anticipate the next call, so as     *\n*      to be able to move more data.  FLDBSTRT preserves the        *\n*      very beginning address of the input buffer, whereas          *\n*      FLDBUFFR is a place somewhere within the buffer, which       *\n*      is the start from where the new data is expected to be       *\n*      moved.                                                       *\n*                                                                   *\n*      A new field, FLDBYTOT, makes it easier to create chunked     *\n*      AWS-format tape files, when the chunksize is less than       *\n*      the blocksize.  This field originally (after a block is      *\n*      read into the buffer from the tape) contains the number      *\n*      of bytes in the entire block.  After each chunk of data      *\n*      is written, this field gets decremented by the number of     *\n*      bytes in the chunk just written.                             *\n*                                                                   *\n*      Since both the caller and this program do PUT operations     *\n*      to the output FB-80 file, the count of the number of PUTs    *\n*      done, FLDOUTCT, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nFOLDEM   AMODE 24\nFOLDEM   RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'FOLDEM'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING FOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,AWSOUTV            AWSOUT   DCB address in caller\n         ST    R0,AWOUTDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to fold buffer data into an FB-80 file, starting at     *\n*   a given location in the buffer, for a certain number of bytes,  *\n*   and starting at a given OFFSET in the 80-byte workarea to       *\n*   which the buffer data will be written.  When the 80-byte        *\n*   workarea is filled up, a PUT is done to AWSOUT, and the         *\n*   workarea is cleared with binary zeros for more data to be       *\n*   written.                                                        *\n*                                                                   *\n*   Input:   FLDAREA fields are all supplied by the calling         *\n*            program, except for FLDBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            caller's copy of FLDAREA is pointed to by Register 1.  *\n*                                                                   *\n*            The buffer area containing the data to be folded       *\n*            is supplied by the calling program, as well as the     *\n*            number of bytes that is expected to be folded.         *\n*                                                                   *\n*   Output:  Data from the buffer will be moved into the 80-byte    *\n*            workarea until the workarea is filled.  When the       *\n*            workarea is filled, a PUT will be done to AWSOUT,      *\n*            and the workarea is cleared to X'00's to make room     *\n*            for more data, when more data is to be written.        *\n*                                                                   *\n*            Ending OFFSET into the 80-byte workarea, pointing to   *\n*            just after the data which has been moved, is returned  *\n*            in the FLDOFFST field.  Upon return to the caller,     *\n*            the FLDBUFFR field is updated to point to the place    *\n*            in the buffer just after the data which has been       *\n*            moved.  The FLDBSTRT field always should point to the  *\n*            beginning of the data buffer, but this is at the       *\n*            discretion of the calling program.                     *\n*                                                                   *\n*            A count of bytes actually moved from the buffer to     *\n*            the 80-byte workarea (and written out by PUTs to the   *\n*            AWSOUT DD name as is necessary) is calculated by this  *\n*            program and returned in the FLDBYMVD field.  Upon      *\n*            return, the number in the FLDBYMVD field should match  *\n*            the number in the FLDBYTES field.                      *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nFOLDIT   DS    0H\n         L     R1,SAVEPARM          Load address of caller's FLDAREA\n         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA\n         USING FLDBLOCK,R2\n         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours\n* - - - - - - - - - -      Load the buffer quantities\n         L     R7,FLDBUFFR          Initialize start of buffer data\n         L     R8,FLDBYTES          Bytes to be moved\n         AR    R8,R7                Add in start buffer address\n         ST    R8,HYPOENDB          Hypothetical end-of-buffer address\n*                                   which is probably the real\n*                                   end-of-data to be moved.\n* - - - - - - - - - -      Load the card quantities\n         MVC   SAVEBEGC,FLDSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,FLDECARD    Save \"end of card\" address\n         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,FLDSCARD          Point to beginning of card\n         A     R7,FLDOFFST          Add OFFSET to start of output\n         ST    R7,SAVEBEGO          Save where output starts\n         L     R8,SAVEBEGO          Copy beg of output address\n         A     R8,FLDBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n         ST    R8,HYPOENDC          Store hypothetical card end address\n*                                   (This may be way past end of card.)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is to within the current card.        *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.  So we have to do     *\n*              iterations.                                        *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         L     R7,SAVEBEGO          Beginning of CARD data\n         L     R8,HYPOENDC          Hypothetical end of CARD data\n         L     R3,FLDBUFFR          Prime R3 with start of buffer data\n         C     R8,SAVEENDC          Is R8 past the end-of-card?\n         BH    LOOPMORE             Yes. Do multiple moves and PUTs.\nLOOPSHRT DS    0H                   No. Do the one move only.\n         LR    R6,R8                Get byte count to move NOW.\n         SR    R6,R7                Bytes to move from buffer to card\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data from buffer to card.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total bytes moved.\n         ST    R1,FLDBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,FLDBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET -\n         S     R6,FLDSCARD          Subtract beginning of card address\n         ST    R6,FLDOFFST          Store the result as new OFFSET\n* -- >\nLOOPTS50 DS    0H\n*                                   If OFFSET > X'4F', card is complete\n         C     R6,=F'80'            Is the new offset exactly X'50'?\n         BNE   LOOPNT50             No. Then current card not complete.\n*                                   Yes. Then PUT out card and init it.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT001             Yes. Can't PUT to AWSOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT001 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n         XR    R6,R6                Clear R6\n         ST    R6,FLDOFFST          New offset is 0, not X'50'\nLOOPNT50 DS    0H\n* -- >\n         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT\n         S     R1,FLDBYMVD          And subtract bytes already moved\n         ST    R1,FLDBYTOT          To show new total buffer byte count\n*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,FLDBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Test if past end of buffer\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,FLDBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT002             Yes. Then don't produce AWSOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT002 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE CALLER\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of FLDAREA in caller\n         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nFLDBLOCK CSECT\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\nFOLDEM   CSECT\nWORKAREA DS    CL80                 Card image work area\n         DC    CL4' '               Padding\n         DC    C' '\nLINE     DC    CL133' '             Output line\n         DC    C' '\nLINE2    DC    CL133' '             Second output line if needed\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGO DC    F'0'                 Save beg address of card output\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address\nHYPOENDC DC    F'0'                 Hypothetical end address after card\nHYPOENDB DC    F'0'                 Calculated end of buffer address\nSYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB\nAWSOUTV  DC    V(AWSOUT)            Address of AWSOUT DCB\nSYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here\nAWOUTDCB DC    F'0'                 AWSOUT DCB address stored here\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FOLDEM$": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x045\\x0f\\x01\\x045\\x0f\\tU\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-15T00:00:00", "modifydate": "2004-12-15T09:55:53", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   FOLDEM\n SETSSI  CB468533\n NAME    FOLDEM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "M370VTT2": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x16\\x03o\\x01\\x16\\x03o\\x16\\x08\\x14\\x02\\x14\\x02\\x00\\x00\\xc7\\xc5\\xd9\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-02-05T00:00:00", "modifydate": "2016-02-05T16:08:26", "lines": 5122, "newlines": 5122, "modlines": 0, "user": "GERHARD"}, "text": "//TESTVTT2 JOB (Z904,0012),'GERHARD',CLASS=E,MSGCLASS=C,\n//             MSGLEVEL=(1,1),\n//             TIME=2,REGION=4096K\n//*\n//        EXEC PURGEME\n//*\n//       EXEC  ASMXTEST,PARM.G=\n//U.SYSIN  DD  *\n./       ADD   NAME=AMODE\n         MACRO ,\n         AMODE ,\n.*   DUMMY MACRO CREATED TO SUPPORT ASSEMBLY UNDER HERCULES (XF ASM)\n         MEND  ,\n./       ADD   NAME=RMODE\n         MACRO ,\n         RMODE ,\n.*   DUMMY MACRO CREATED TO SUPPORT ASSEMBLY UNDER HERCULES (XF ASM)\n         MEND  ,\n./       ADD   NAME=VTT2TAPE\n   TITLE 'VTT2TAPE -- COPY AWS FORMAT FILE TO A REAL TAPE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE: VTT2TAPE.   Written by Sam Golob                **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to process P390 and FLEX-ES MVS       **\n**            Virtual Tape data in AWS format.  This data   **\n**            is uploaded to an MVS system as an FB-80      **\n**     card-image file.  The receiving MVS system does      **\n**     not have to be able to handle AWS-format virtual     **\n**     tapes, but it can use this program to read the tape  **\n**     data from this folded AWS-format file, and create    **\n**     a real tape from it.                                 **\n**                                                          **\n**     The OS2 or PC AWS-format tape file that was created  **\n**     by the P390 or FLEX-ES system as a virtual tape, is  **\n**     uploaded to the MVS system as an FB-80 card-image    **\n**     file, with its (continuous stream of) data folded    **\n**     over into 80-byte records, that can be blocked on    **\n**     MVS.  This VTT2TAPE program reads the resulting      **\n**     file, and creates a real output tape using EXCP, on  **\n**     a real tape drive, by filling a buffer and writing   **\n**     out its contents to the real tape.                   **\n**                                                          **\n**     This program is designed to also take input from     **\n**     the FB-80 AWS-format output file, which is produced  **\n**     by the VTT2DISK program.  These two programs,        **\n**     VTT2TAPE and VTT2DISK, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     1.  Since all the tape data is folded into 80-byte   **\n**         record segments, these have to be logically      **\n**         strung together, to be able to correctly write   **\n**         the tape data to tape blocks.                    **\n**                                                          **\n**     2.  First, the program has to correctly jump from    **\n**         one AWS header record to the next, and so        **\n**         proceed through all the headers in the entire    **\n**         tape file, not missing any.  Diagnostic output   **\n**         from this process, is written to the optional    **\n**         SYSTRACE ddname, if it is present in the         **\n**         execution JCL (see below).                       **\n**                                                          **\n**         The first header of an AWS-format tape is the    **\n**         first six bytes of the file.  Once you have      **\n**         the first header, you have the number of bytes   **\n**         of data until the next header, and so forth.     **\n**                                                          **\n**         The UNFOLDEM called program unfolds the data     **\n**         from a chunk of data after an AWS header, and    **\n**         strings it out into an output buffer, after      **\n**         which an EXCP operation writes the entire        **\n**         buffer to tape.  If a block of data is from      **\n**         several chunks, the data pieces are all strung   **\n**         out into the output buffer, and then at the      **\n**         end of the block (flag X'20' in the header),     **\n**         all of the buffer data is written out to tape.   **\n**                                                          **\n**     3.  In the process of jumping from one header to     **\n**         another, the program then moves the correct      **\n**         number of data bytes that are in between the     **\n**         headers, into the output buffer, 80-bytes or     **\n**         less, at a time.  This action depends on the     **\n**         type of header that we have.                     **\n**                                                          **\n**           HEADER TYPE       ACTION                       **\n**           ------ ----       ------                       **\n**           X'80'             Initialize buffer address.   **\n**                             Write chunk of data to       **\n**                              the buffer.                 **\n**                                                          **\n**           X'00'             Write another chunk of data  **\n**                              to the end of the previous  **\n**                              chunk in the buffer.        **\n**                                                          **\n**           X'20'             Add the chunk of data to     **\n**                              the buffer.                 **\n**                             Write out the entire buffer. **\n**                             Initialize the start of      **\n**                              buffer address.             **\n**                                                          **\n**           X'A0'             X'80' and X'20' combined.    **\n**                                                          **\n**           X'40'             Write a tape mark.           **\n**                             Finalize the tape file.      **\n**                             Initialize the output buffer **\n**                              location.                   **\n**                                                          **\n**  Note:  If the output tape is too short, VTT2TAPE        **\n**         attempts to recover by issuing an EOV macro,     **\n**         which calls for a mount of a second tape,        **\n**         as a PRIVATE SCRATCH tape.  More data from the   **\n**         AWS file is written out to the second tape.      **\n**                                                          **\n**         However, there is a catch here.  The second      **\n**         tape does not contain additional labels, as      **\n**         DFP would have written.  The second tape         **\n**         continues with the next block of data, after     **\n**         the last block which was successfully written    **\n**         to the first tape.                               **\n**                                                          **\n**         Therefore, in order to subsequently read the     **\n**         second tape, you have to treat both tapes as     **\n**         two-volume BLP, using JCL similar to this,       **\n**         even if the first tape is SL...                  **\n**                                                          **\n**       //TAPOUT    DD  DISP=OLD,UNIT=TAPE,                **\n**       //          VOL=(,RETAIN,SER=(VOL001,VOL002,etc)), **\n**       //          LABEL=(n,BLP,EXPDT=98000)              **\n**                                                          **\n**         where n (for BLP) would be 3m-1 (where m is      **\n**         the SL file number).                             **\n**                                                          **\n**         Sorry for that.  The reason is because this      **\n**         program writes tape blocks using EXCP, and       **\n**         for the second volume, I'd have to manufacture   **\n**         my own tape labels, and I haven't added such     **\n**         an enhancement at this time.  If BSAM or QSAM    **\n**         created a second SL tape, then the extra EOV     **\n**         and VOL and HDR labels are created by DFP.       **\n**         EXCP contains no such provisions, leaving any    **\n**         extra label creation entirely up to the          **\n**         programmer.                                      **\n**                                                          **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**         In order to make sure that the VTT2TAPE program  **\n**         is doing its job properly, it produces a lot of  **\n**         trace data and status data, as it is reading     **\n**         through the folded FB-80 AWS format tape.  In    **\n**         order not to clutter the summary report, most    **\n**         of this data is written to \"Optional DDNAMEs\".   **\n**                                                          **\n**         Optional DDNAMEs don't have to be coded in the   **\n**         JCL.  But if they are coded, they will contain   **\n**         the extra trace data which VTT2TAPE produces.    **\n**                                                          **\n**         The optional DDNAMEs are SYSFILES, SYSTRACE,     **\n**         SYSMOVED, and SYSIN.                             **\n**                                                          **\n**         Full JCL to run the VTT2TAPE program is as       **\n**         follows:                                         **\n**                                                          **\n**         (But you can code PARM=READ, or                  **\n**            PARM='TVOL(volser)'       or                  **\n**            PARM='TVOL=volser'              )             **\n**                                                          **\n**         If you code, PARM='TVOL.....' to override the    **\n**         volser of the new tape, this may be further      **\n**         overridden by the SYSIN card:  NEWVOL=volser.    **\n**                                                          **\n**       //   jobcard                                       **\n**       //AWSREAD  EXEC PGM=VTT2TAPE                       **\n**       //STEPLIB   DD  DISP=SHR,DSN=your.load.library     **\n**       //AWSIN     DD  DISP=SHR,DSN=folded.aws.file,      **\n**                   DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)  **\n**       //TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=TEST01,  **\n**       //          LABEL=(1,BLP,EXPDT=98000)              **\n**       //SYSPRINT  DD  SYSOUT=*                           **\n**       //SYSFILES  DD  SYSOUT=*                           **\n**       //SYSTRACE  DD  SYSOUT=*                           **\n**       //SYSMOVED  DD  SYSOUT=*                           **\n**       //SYSUDUMP  DD  SYSOUT=*                           **\n**       //SYSIN     DD  *                                  **\n**       NEWVOL=PROD01                                      **\n**       /*                                                 **\n**       //                                                 **\n**                                                          **\n**         where you can leave out SYSTRACE, SYSMOVED,      **\n**         and SYSUDUMP, if you want to.  I'd strongly      **\n**         suggest including (at least) SYSFILES, though.   **\n**                                                          **\n**         If you code NEWVOL=volser in a //SYSIN card,     **\n**         starting in column 1, VTT2TAPE will change       **\n**         the VOLSER in every VOL1 label (should only be   **\n**         one of them) on the tape, to the value you       **\n**         specify.                                         **\n**                                                          **\n**         SYSFILES gives you block counts and byte counts  **\n**         for all files read and written.  SYSFILES also   **\n**         differentiates between label files and data      **\n**         files.                                           **\n**                                                          **\n**         SYSTRACE tells you if you are running through    **\n**         all the AWS headers properly.  SYSMOVED tells    **\n**         you how many bytes were moved from each chunk    **\n**         of data between AWS headers.  SYSUDUMP is        **\n**         there to contain the MVS-produced dump, upon     **\n**         any abnormal termination of the program.         **\n**                                                          **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.1 - Correct Operation of data moves from    **\n**       the AWS file to the output buffer, and produce     **\n**       traces to debug this.  SYSMOVED ddname.            **\n**                                                          **\n**    Version 1.2 - Add byte counts and SYSFILES ddname.    **\n**       Fix AWSTAPE emulator problem when writing a        **\n**       tape mark.  OS/2 AWSTAPE emulator cares what       **\n**       the byte count is in CCW+6, even if the opcode     **\n**       is X'1F'.  Made sure the byte count is always 0    **\n**       when doing EXCP with a \"write tape mark\" opcode.   **\n**                                                          **\n**    Version 1.3 - Check for error conditions on output.   **\n**       Put version number and assembly date into headers. **\n**       Put cumulative byte totals in SYSFILES report.     **\n**                                                          **\n**    Version 1.4 - Differentiate between label files and   **\n**       data files.  Different cumulative byte counts for  **\n**       each.                                              **\n**                                                          **\n**    Version 1.5 - Better SYSFILES report upon volume      **\n**       switch, if the first output tape is too short.     **\n**       Pass null SL files.  Don't stop in the middle of   **\n**       them, because of the two tape marks after the      **\n**       HDR2.                                              **\n**                                                          **\n**    Version 1.6 - Block counts for each file and for the  **\n**       entire tape.                                       **\n**                                                          **\n**    Version 1.7 - Allow PARM=READ, just to get stats.     **\n**                                                          **\n**    Version 1.8 - Make file-level stats reporting into    **\n**       a subroutine.                                      **\n**                                                          **\n**    Version 1.9 - Header validation.  If a header is      **\n**       corrupted, the chain of headers will be broken,    **\n**       and we try to detect this and abort the program,   **\n**       before any significant damage is done to the       **\n**       output file.  We try and keep as much valid data   **\n**       as possible in the output tape.  Add return code   **\n**       indication of different error conditions.          **\n**                                                          **\n**    Version 1.9A - Better messages if this header's       **\n**       previous byte value doesn't match the last         **\n**       header's current byte value.  Pinpoint file and    **\n**       block number in error.  Allow 4-byte version       **\n**       number literal, in preparation for 1.10, etc.      **\n**                                                          **\n**    Version 1.10 -   Optional SYSIN dd name which can     **\n**       contain a card:  NEWVOL=volser   starting in       **\n**       column 1, which overrides the output tape's        **\n**       volume serial.                                     **\n**                                                          **\n**    Version 1.11 -   INAREA now addressed indirectly.     **\n**                                                          **\n**    Version 1.12 -   Logic changed to accommodate chunks  **\n**       of data between headers that are shorter than the  **\n**       tape blocks.  Much of the program has been         **\n**       completely rewritten.  Moves of data between AWS   **\n**       headers to the output buffer, are now done only    **\n**       by the UNFOLDEM called program.  The SYSFILES      **\n**       report has been improved.  The SYSMOVED and        **\n**       SYSTRACE reports now reflect the data associated   **\n**       with each header encountered.                      **\n**                                                          **\n**    Version 1.13 -   Put in ASG enhancement to allow a    **\n**       volser change through a PARM='TVOL=nwvser', or     **\n**       PARM='TVOL(nwvser)'.  Put in a check for short     **\n**       volsers (less than 6 characters) and ran the parm  **\n**       for the volser through a translate table first,    **\n**       to uppercase it and clean it up somewhat.  The     **\n**       volser that is coded in the SYSIN DD card can      **\n**       completely override this, so you still have the    **\n**       freedom to create bizarre volsers if you really    **\n**       want to.  BTW, you do not need to code the new     **\n**       volser in the JCL.  This program does not do a     **\n**       RDJFCB to find out what is in the JCL.             **\n**                                                          **\n**                                                          **\n**  RETURN CODES:                                           **\n**                                                          **\n**    RC =  0 :    Normal Operation                         **\n**                                                          **\n**    RC =  4 :    A Private Scratch tape was asked for,    **\n**                 because the end of the first output      **\n**                 tape was reached.                        **\n**                                                          **\n**    RC =  8 :                                             **\n**                                                          **\n**    RC = 12 :    Program operation had to be aborted      **\n**                 because the chain of AWS headers was     **\n**                 broken in the middle, and an invalid     **\n**                 \"AWS header\" was encountered.  The       **\n**                 program writes out all valid tape        **\n**                 blocks, and then stops action, with a    **\n**                 message that indicates the problem,      **\n**                 and the header found to be in error.     **\n**                 The last tape block written, is the      **\n**                 block before the last correct AWS        **\n**                 header.  This condition probably         **\n**                 occurred because an invalid AWS header   **\n**                 \"current length\" made it impossible      **\n**                 to find the next valid AWS header.       **\n**                                                          **\n**                                                          **\n**    Please note that a higher return code will            **\n**    supersede a lower return code, and that multiple      **\n**    error conditions might exist, if there is a nonzero   **\n**    return code higher than 4.  Look at the SYSFILES      **\n**    report, and the other reports, to determine the       **\n**    exact error(s) present.                               **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n.* ---------------------------------------------------------------  *\n.*   This macro is used to display hex values in a printed report.\n.* ---------------------------------------------------------------  *\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n**************************************************************\n         GBLC  &LLEV\n&LLEV    SETC  '1.13'\n**************************************************************\n         EJECT\nVTT2TAPE CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2TAPE AMODE 24\nVTT2TAPE RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2TAPE - AWS FB-80 DISK FILE INPUT TO REAL TAPE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2TAPE,R12,R11,R10,R8\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n         MVC   SVNEWVOL(6),=C'      '    MAKE SVNEWVOL BLANK\n         L     R1,0(,R1)             Get PARM field\n         CLC   =C'TVOL',2(R1)        Is it a Tape volume override?\n         BNE   CHKREAD               No. Then check if \"read only\".\n         MVC   CHKNWVOL(6),7(R1)     Yes. Move chars from PARM=TVOL.\n         TR    CHKNWVOL(6),TRTBLPRT  Translate to clean this up some.\n*\n*  Code to guard against a short volser or leading blanks in the PARM.\n* >> below\n*\n         STM   R2,R5,SAVR2T5         Save 4 registers\n         LA    R3,CHKNWVOL           Load address of source field\n         LA    R4,6                  Load limit of characters moved\n         LA    R5,SVNEWVOL           Load address of target field\n         LR    R2,R5                 Start address of target field\nMVELOOP  DS    0H                    Guard against a short volser.\n         CLI   0(R3),X'00'           Delimiter of hexzeros?\n         BE    MVELEND               Yes, end the move.\n         CLI   0(R3),C' '            Delimiter of blank?\n         BE    MVELEND               Yes, end the move.\n         CLI   0(R3),C')'            Delimiter of close paren?\n         BE    MVELEND               Yes, end the move.\n         MVC   0(1,R5),0(R3)         Move one character over.\n         OI    FLAGNEWV,X'01'        Flag that volser needs change.\n         LA    R3,1(,R3)             Bump source character.\n         LA    R5,1(,R5)             Bump target character.\n         BCT   R4,MVELOOP            Try again if before end.\nMVELEND  DS    0H\n         LM    R2,R5,SAVR2T5         Restore 4 registers\nMOVEEND  DS    0H\n*\n* >> above\n*  Code to guard against a short volser or leading blanks in the PARM.\n*\n* ----- >                            Parm = READ    <--- below\n*    See code for PARM='TVOL=nwvser' which is above, in several places.\n* ----- >\nCHKREAD  CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BNE   COPYTAPE              No. Default is to copy the tape.\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\nCOPYTAPE DS    0H\n* ----- >                            Parm = READ    <--- above\n*\n         L     R15,=V(UNFOLDEM)      UNFOLDEM subprogram\n         ST    R15,SVUNFOLD          Save its entry point\n         L     R0,=A(INAREA)         Address of tape buffer\n         ST    R0,SVINAREA           Store it away for later use.\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n*NEW*    TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         TIME  DEC           OLD AND SLOW                       \\\n         STCM  R0,15,TIME                                       \\\n         OI    TIME+3,X'0F'\n*NEW*    STCM  R1,15,DATE+1                                     \\\n*NEW*    OI    DATE+4,X'0F'\n*NEW*    UNPK  DATED,DATE\n*  INSERTION TO SUPPORT DATE IN MVS 3.8                         \\\n         ST    R1,DB+4       SAVE JULIAN DATE                   \\\n         CLI   DB+4,1        DID USER SUPPLY A CENTURY?         \\\n         BH    HAVECENT      YES                                \\\n         AP    DB+4(4),=P'1900000'  ELSE ADD IT IN              \\\nHAVECENT MVO   DB2,DB+4(2)   ISOLATE THE YEAR                   \\\n         XC    DB(6),DB      ISOLATE THE DAYS                   \\\n         CVB   R1,DB         CONVERT DAYS TO BINARY             \\\n         CVB   R2,DB2        CONVERT YEAR TO BINARY             \\\n         SLR   R0,R0         SET FOR NO LEAP DAY ADJUSTMENT     \\\n*  N.B.: THIS WORKS UNTIL 2099 ONLY                             \\\n         EX    R2,EXISLEAP   TEST FOR MULTIPLE OF FOUR          \\\n         BNZ   NOTALEAP      BRANCH IF NOT A LEAP YEAR          \\\n         CH    R1,=H'60'     ON, BEFORE, OR AFTER LEAP DAY?     \\\n         BL    NOTALEAP      BEFORE; TREAT NORMALLY             \\\n         BH    ONELESS       AFTER; ADJUST DAY                  \\\n         LA    R0,1          SET LEAP DAY ADJUSTMENT            \\\nONELESS  BCTR  R1,0          ONE LESS TO FIX DAYS AFTER LEAP DAY\\\nNOTALEAP LA    R4,DATETABL   GET TABLE OF CUMULATIVE DAYS       \\\n         LR    R5,R4         SAVE                               \\\nFINDMON  CH    R1,2(,R4)     IN THIS MONTH?                     \\\n         BNH   FOUNDMON      YES; PROCESS                       \\\n         LA    R4,2(,R4)     INCREMENT                          \\\n         B     FINDMON       AND TRY AGAIN                      \\\nFOUNDMON SH    R1,0(,R4)     SUBTRACT DAYS IN PRIOR MONTHS      \\\n         AR    R1,R0         ADJUST 1 IF LEAP DAY               \\\n         LA    R4,2(,R4)     FINAGLE TO MAKE MONTH COME OUT RIGHT\n         SR    R4,R5         GET OFFSET TO MONTH                \\\n         SRL   R4,1          GET MONTH (1-12)                   \\\n*  WE NOW HAVE FULL YEAR IN R2, MONTH IN R4, AND DAY IN R1      \\\n         MH    R4,=H'100'    SHIFT FOR EDIT                     \\\n         AR    R4,R1         ADD DAY: MMDD                      \\\n         MH    R4,=H'10000'  SHIFT FOR EDIT                     \\\n         AR    R4,R2         NOW HAVE MMDDYYYY                  \\\n         MH    R4,=H'10'     FINAGLE A LITTLE MORE              \\\n         CVD   R4,DB         MAKE PACKED AND SIGNED             \\\n         UNPK  DATED,DB      CONFORM TO *NEW* CODE              \\\nEXISLEAP TM    =X'03',*-*    MULTIPLE OF FOUR?                  \\\n         SPACE 1                                                \\\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE4+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE5+88(31),HEADDLIT\n         MVC   MESSAGE6+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE4+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE5+61(21),LEVELLIT\n         MVC   MESSAGE6+61(21),LEVELLIT\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants and\n         MVI   FLAGSYST,X'00'        No optional ddnames initially.\n         ZAP   INHDRS,=P'0'          Count number of AWS headers\n         ZAP   INTYPE1,=P'0'         Counts of Header Types\n         ZAP   INTYPE2,=P'0'\n         ZAP   INTYPE3,=P'0'\n         ZAP   INTYPE4,=P'0'\n         ZAP   INTYPE5,=P'0'\n         ZAP   FILCOUNT,=P'0'        Initialize file counter\n         MVC   DBIN(8),=D'0'         Initialize byte counters\n         MVC   LBIN(8),=D'0'\n         MVC   DAIN(8),=D'0'\n         MVC   DAINF(8),=D'0'\n         MVC   LBINF(8),=D'0'\n         MVC   DBINF(8),=D'0'\n         MVC   OURRC,=F'0'\n         MVC   MAXRC,=F'0'\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE DDNAME THERE?\n         BNE   TIOTMOVD       NO\n*DEBUG*  OI    FLAGSYST,X'01'       SHOW PRESENCE OF SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       SHOW PRESENCE OF SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       SHOW PRESENCE OF SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       SHOW PRESENCE OF SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n*---------------------------------------------------------------------*\n* -------------- >>>>>>   Look for new output volume name - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    NONSYSIN             No. Then can't open it.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BNE   SYSINLUP              No. Don't use this card.\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         OI    FLAGNEWV,X'01'             And show a new volser here.\n         B     NONSYSIN\nSYSINEND DS    0H\n         CLOSE SYSIN\nNONSYSIN DS    0H\n* -------------- >>>>>>   Look for new output volume name - ABOVE\n*---------------------------------------------------------------------*\n         OPEN  (AWSIN,(INPUT))\n         OPEN  (SYSPRINT,(OUTPUT))\n         TM    READFLAG,X'01'        Is this run READ ONLY?\n         BO    NOTAPOPN              Yes. Don't OPEN output tape.\n         OPEN  (TAPOUT,(OUTPUT))\nNOTAPOPN DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   NOSYSTRC              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE4\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA4\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSTRACE,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\nNOEXTRA4 DS    0H\n         PUT   SYSTRACE,MESSAGE9\n         PUT   SYSTRACE,MESSAG10\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n         PUT   SYSTRACE,MESSAGE8\n*--->>\nNOSYSTRC DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE5\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA5\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSMOVED,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\nNOEXTRA5 DS    0H\n*--->>\nNOSYSFIL DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSMVD              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE6\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA6\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSFILES,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\nNOEXTRA6 DS    0H\n*--->>\nNOSYSMVD DS    0H\n* ----------------------------------------------------------------- *\n*     Write the top Header Line, with the date and time in it.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA1\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSPRINT,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSPRINT,PRTLINE\nNOEXTRA1 DS    0H\n*--->>\n* ----------------------------------------------------------------- *\n*     Start trying to bop through the AWS headers.  The first 6\n*     bytes of the file, is the first header, so we start there.\n* ----------------------------------------------------------------- *\nLOOPSTRT DS    0H                    START OF PROCESSING\n         LA    R7,INCARD             INITIALIZE BEG OF RECORD\n         ST    R7,SAVEBEGC           AND SAVE THIS SETTING.\n* ---------------------------------------------------------------- *\n         LA    R6,INCAEND            INITIALIZE END OF RECORD\n         ST    R6,SAVEENDC           AND SAVE THIS SETTING.\n         LA    R1,80(,R6)            BOP BY ANOTHER RECORD LENGTH\n         ST    R1,SAVEEN80           AND SAVE WHERE THIS IS.\n* ---------------------------------------------------------------- *\n         GET   AWSIN,INCARD           Do the very first GET to find\n*                                     the first header in the file.\n*                                     The first header lets you find\n*                                     all the other headers.\n         AP    UNFINRCD,=P'1'         Update the control block too\n         MVC   INHEADER(6),0(R7)      Got the first header\n* ---------------------------------------------------------------- *\n*     We come here when we know we're at the beginning of an\n*     AWS header record.\n* ---------------------------------------------------------------- *\nGOTHEADR DS    0H                     Got a header record\n* ---------------------------------------------------------------- *\n         MVC   HDRPREVS(2),HDRPREV    SAVE PREVIOUS BLOCK SIZE\n         MVC   HDRLENGS(2),HDRLENG    SAVE SIZE OF NEXT BLOCK\n* ---------------------------------------------------------------- *\n         AP    INHDRS,=P'1'           Count the number of headers.\n         MVC   HEADER(6),INHEADER     Move header to formatting area.\n*--->\n         ST    R9,SAVER9HV            Save link register\n         BAL   R9,VALIDHDR            Make sure header flags are valid\n         L     R9,SAVER9HV            Restore link register\n         TM    HDRVFLAG,X'01'         Is the header in error?\n         BO    HEADRERR               Yes-report condition and end pgm.\n*--->\n*--->       Format the header by interpreting the length fields,\n*--->       and then print the values for diagnosis if necessary.\n*--->\n*--->       HDRLENG contains the true halfword byte count of data\n*--->               following this header.\n*--->       HDRPREV contains the true halfword byte count of data\n*--->               preceding this header.\n*--->\n*--->       In case fullword versions of these quantities are\n*--->       needed, HDRFULLS and HDRPFULS are supplied too.\n*--->\n         MVC   SAVEHDR(6),HEADER      Save a copy of the current header\n         MVC   HDRFILL(2),=X'0000'    Fill in zeros\n         MVC   HDRPRVF(2),=X'0000'      for\n         MVC   HDRLENFL(2),=X'0000'        fullword values\n         MVC   HDRPRVFL(2),=X'0000'           of halfwords.\n         MVC   HDRLENG+1(1),HDRCURLN     REVERSE\n         MVC   HDRLENG(1),HDRCURLN+1        BYTES\n         MVC   HDRPREV+1(1),HDRPRVLN     REVERSE\n         MVC   HDRPREV(1),HDRPRVLN+1        BYTES\n*\n         MVC   PRTLINE,PRTLINE-1      CLEAR PRINT LINE\n         HEX   PRTLINE+8,6,HEADER     UNFAREA at GOTHEADR time display\n         HEX   PRTLINE+28,4,UNFSCARD                            .\n         HEX   PRTLINE+38,4,UNFECARD                            .\n         HEX   PRTLINE+48,4,UNFOFFST                            .\n         HEX   PRTLINE+58,4,UNFBYTES                            .\n         HEX   PRTLINE+68,4,UNFBYMVD                            .\n         HEX   PRTLINE+78,4,UNFBUFFR                            .\n         HEX   PRTLINE+88,4,UNFBSTRT                            .\n         HEX   PRTLINE+98,7,UNFINRCD                            .\n* ---------------------------------------------------------------- *\n*              DETERMINE THE TYPE OF HEADER YOU HAVE\n*                    AND COUNT HOW MANY OF EACH\n* ---------------------------------------------------------------- *\nKINDAHDR DS    0H\n         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?\n         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK\n         AP    INTYPE3,=P'1'          YES. COUNT THIS TYPE\n         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE\nKCHKBEG  DS    0H\n         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?\n         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.\n         AP    INTYPE1,=P'1'          YES. COUNT THIS TYPE\nKCHKEND  DS    0H\n         TM    HDRFLAG1,X'20'         END OF BLOCK?\n         BNO   KINDAH40               NO. CHECK IF END OF FILE\n         AP    INTYPE2,=P'1'          YES. COUNT THIS TYPE\nKINDAHA0 DS    0H\n         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?\n         BNE   KINDAH40               NO. TEST FOR EOF HEADER.\n         AP    INTYPE5,=P'1'          YES. COUNT IT FOR REPORTING.\n         B     KINDAHEN               AND DON'T TEST MORE BITS.\nKINDAH40 DS    0H\n         TM    HDRFLAG1,X'40'         END OF FILE HEADER?\n         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.\n         AP    INTYPE4,=P'1'          YES. COUNT THIS TYPE\n*\n*     Invalid types were already caught by the VALIDHDR routine.\n*\nKINDAHEN DS    0H\n         HEX   PRTLINE+22,1,HDRFLAG1                            .\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         PUT   SYSTRACE,PRTLINE\nNOSYSTR1 DS    0H\n         CLC   SAVEHDR(6),EOTMARK     IS THE HEADER AN EOT MARK?\n         BNE   NOFIN                  NO. DON'T STOP THE PROGRAM.\n         NI    UNEXFLAG,FF-X'01'      TURN OFF UNIT EXCEPTION FLAG\n         TM    FLAGHDRL,X'01'         YES. BUT TEST IF AFTER HDR 1 OR 2\n         BO    NOFIN                  AFTER HDR1 OR HDR2, DON'T END PGM\n         B     FIN                    OTHERWISE END THE PROGRAM.\nNOFIN    DS    0H\n*------------------------------>  Validate Header Quantities  <-- below\n*\n*   This validation checks if the bytes in the \"previous\" byte count\n*   field match the byte count in the \"forward\" field of the previous\n*   header.  If there is an error, it is reported now.\n*\n         CLC   HDRLENGS(2),HDRPREV    Is Prev Length = Last Current ?\n         BE    HDRVALID               Yes. As it should be.\n         MVC   OUTLINE,OUTLINE-1      No. Corrupted headers.\n         MVC   OUTLINE,ERRMESS6       Write nasty message.\n         MVI   OUTLINE+58,C'P'        Display prev hdr quantity.\n         HEX   OUTLINE+60,2,HDRPREV\n         MVI   OUTLINE+66,C'C'        Display last current hdr amount.\n         HEX   OUTLINE+68,2,HDRLENGS\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'        Set RC = 12\n         CLC   MAXRC,OURRC            Is MAXRC higher?\n         BH    SAXERC02               Yes. Keep it.\n         MVC   MAXRC,OURRC            No.  Raise MAXRC to this one.\nSAXERC02 DS    0H\n         TM    FLAGSYST,X'01'         Write nastygram to SYSTRACE.\n         BZ    NOERRX1\n         PUT   SYSTRACE,OUTLINE\nNOERRX1  DS    0H\n         TM    FLAGSYST,X'02'         Write nastygram to SYSMOVED.\n         BZ    NOERRX2\n         PUT   SYSMOVED,OUTLINE\nNOERRX2  DS    0H\n         TM    FLAGSYST,X'04'         Write nastygram to SYSFILES.\n         BZ    NOERRX4\n         PUT   SYSFILES,OUTLINE\nNOERRX4  DS    0H\n         PUT   SYSPRINT,OUTLINE       Write nastygram to SYSPRINT.\n*\n*       Maybe think of ending the program operation here.\n*       REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE\n*\nHDRVALID DS    0H\n*------------------------------>  Validate Header Quantities  <-- above\n*\n*\n* - - - - - - - >>>>>   End of Header Operations....\n* - - - - - - - >>>>>   Now go move the data afterward.\n* ---------------------------------------------------------------- *\n*     At this point, we will begin moving the data that is after\n*     the first header.  Future OFFSETs will be supplied by the\n*     previous call to the UNFOLDEM program.\n* ---------------------------------------------------------------- *\nLOOKINIT DS    0H                Start looking for the data at the\n*                                beginning of the AWSIN tape file.\n         TM    INITFLAG,X'01'    Not the first time here?\n         BO    LOOKIEND          Bypass initializations.\n         OI    INITFLAG,X'01'    Do this only once for the entire tape.\n         MVC   UNFOFFST,=F'6'    Initialize OFFSET to be just past\n*                                the first header in the file.\n         MVC   UNFBUFFR,UNFBSTRT  Init buffer loc to start of buffer\nLOOKIEND DS    0H\n* ---------------------------------------------------------------- *\nMOVEDATA DS    0H                This is the call to UNFOLDEM.\n*                                We fill in the necessary fields.\n*\n*    UNFOLDEM is only intended to move the data between the AWS\n*    headers.  \"After processing\" is controlled by the flags in\n*    the headers.  After each header is processed, we again point\n*    to the data after the headers (if any) and call UNFOLDEM to\n*    move it.\n*\n         MVC   PREVHDR,SAVEHDR     Copy of last header for action later\n         MVC   UNFSCARD,SAVEBEGC   Beginning address of input card\n         MVC   UNFECARD,SAVEENDC   End address of input card\n         XC    UNFBYTES,UNFBYTES   Zero out fullword bytes to be moved\n         MVC   UNFBYTES+2(2),HDRLENG   And move in halfword value\n         L     R1,SVINAREA         Point to address of buffer\n         ST    R1,UNFBSTRT         Store it in beginning buffer field\n         TM    NOWRTFLG,X'01'      Continue data move in same buffer?\n         BO    MOVEBUFF            Yes. Don't reinitialize in buffer.\n         ST    R1,UNFBUFFR         Store it in current buffer field\nMOVEBUFF DS    0H\n*        MVC   LINE+1(8),=C'BEFCALL '\n*        BAL   R9,UNFIMAGE\n         LA    R1,UNFAREA          Point to UNFAREA control block\n         L     R15,SVUNFOLD        Load entry point of UNFOLDEM pgm\n         BALR  R14,R15             Call the program and move data.\n         MVC   UNFAREA(UNFLENTH),0(R1)  Move modified UNFAREA to pgm\n*        MVC   LINE+1(8),=C'AFTCALL '\n*        BAL   R9,UNFIMAGE\n* -- Test for call of LABELCHK -- >   below\n*   We have just moved the bytes.  Now we check if the file is a label.\n         NI    ISLBLFLG,FF-X'01'   Initially assume it's not a label.\n         L     R1,UNFBYMVD         The number of bytes moved just now.\n         C     R1,=X'00000050'     Was it exactly 80?\n         BNE   NOLBLCHK            No. Assume it can't be a label.\n         L     R1,UNFBSTRT         Grab address of data buffer.\n         MVC   TESTLABL(80),0(R1)  Move 80 bytes to the testing area.\n         BAL   R9,LABELCHK         Test to see if it is a label.\n         TM    ISLBLFLG,X'01'      Is it a label?\n         BZ    NOLBLCHK            No. Assume entire file is not labels\n         OI    FILBLFLG,X'01'      Yes. Turn on label flag at the\n*                                   file level.\nNOLBLCHK DS    0H\n* -- Test for call of LABELCHK -- >   above\n* ---------------------------------------------------------------- *\n         BAL   R9,AFTRMOVE       Housekeeping after the data move.\n*        MVC   LINE+1(8),=C'AFTAFTR '\n*        BAL   R9,UNFIMAGE\n         BAL   R9,CHKHEADR       Get new header ready for handling.\n*        MVC   LINE+1(8),=C'AFTCHKH '\n*        BAL   R9,UNFIMAGE\n         B     GOTHEADR          Assume you've got another header.\n* ---------------------------------------------------------------- *\n*          END OF INPUT AWS DATA                                   *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         BAL   R9,WRITTPMK          WRITE FINAL TAPE MARK\n         B     AGLE                 Finish processing\n* ---------------------------------------------------------------- *\nHEADRERR DS    0H\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS5\n         HEX   OUTLINE+58,6,HEADER\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'    RC = 12 for header error.\n         CLC   MAXRC,OURRC        Is MAXRC higher?\n         BH    SAMERC02           Yes. Keep it.\n         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.\nSAMERC02 DS    0H\n         TM    FLAGSYST,X'01'\n         BZ    NOERR01\n         PUT   SYSTRACE,OUTLINE\nNOERR01  DS    0H\n         TM    FLAGSYST,X'02'\n         BZ    NOERR02\n         PUT   SYSMOVED,OUTLINE\nNOERR02  DS    0H\n         TM    FLAGSYST,X'04'\n         BZ    NOERR04\n         PUT   SYSFILES,OUTLINE\nNOERR04  DS    0H\n         PUT   SYSPRINT,OUTLINE\n* ---------------------------------------------------------------- *\nAGLE     DS    0H                   Print the Summary Report\n         BAL   R9,SUMMREPT\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\n         CLOSE AWSIN\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'4'\n         BNH   NOERRPRT\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRPRT DS    0H\n         PUT   SYSPRINT,OUTLINE\n         CLOSE SYSPRINT\n         TM    READFLAG,X'01'       If READ ONLY, don't CLOSE tape.\n         BO    NOTAPCLS\n         CLOSE TAPOUT\nNOTAPCLS DS    0H\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'0'\n         BE    NOERRFIL\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRFIL DS    0H\n         PUT   SYSFILES,OUTLINE\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         MVC   16(4,R13),MAXRC      Load Maximum Return Code\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H                 Take a picture of the UNFAREA now.\n         HEX   LINE+10,4,UNFSCARD    Starting card address.\n         HEX   LINE+20,4,UNFECARD    Ending card address.\n         HEX   LINE+30,4,UNFOFFST    Offset (starting and ending)\n         HEX   LINE+40,4,UNFBYTES    Number of bytes to be moved.\n         HEX   LINE+50,4,UNFBYMVD    Number of bytes that were moved.\n         HEX   LINE+60,4,UNFBUFFR    Current start location in buffer.\n         HEX   LINE+70,4,UNFBSTRT    Location of beginning of buffer.\n         HEX   LINE+80,7,UNFINRCD    Number of GETs done to AWSIN file.\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1           Clear LINE after PUT.\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nCHKHEADR DS    0H                 Position to the next header\n*                                 The idea is to fill the INHEADER\n*                                 field with the correct value.\n         ST    R9,SAVER9CH        Save BAL register\n         L     R1,UNFOFFST        New offset, returned from UNFOLDEM.\n         C     R1,=F'74'          Bigger or equal to 74?\n         BL    CHKHOFSL           No. Just copy header straight.\nCHKHOFSH DS    0H                 Yes. Need to combine with next card.\n         MVC   INCARDP,INCARD     Copy this card to prev 80 byte area.\n         GET   AWSIN,INCARD       GET another card adjacent to previous\n         AP    UNFINRCD,=P'1'     Update UNFAREA field too.\n         LA    R7,INCARDP         Point to two consecutive cards.\n         A     R7,UNFOFFST        Add the returned offset.\n         MVC   INHEADER(6),0(R7)  Move the new header to staging area.\n         LA    R7,6(,R7)          Bump R7 past the new header.\n         S     R7,=A(INCARD)      Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\n         B     CHKHEND            Finish this processing.\nCHKHOFSL DS    0H\n         LA    R7,INCARD          < 74. Header is in original card.\n         LA    R7,0(R1,R7)        Bump by offset - point to new header\n         MVC   INHEADER(6),0(R7)  And move it to staging area.\n         LA    R7,6(,R7)          Bump R7 past the new header.\n         L     R1,=A(INCARD)      Address of current card\n         SR    R7,R1              Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\nCHKHEND  DS    0H\n         L     R9,SAVER9CH        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nAFTRMOVE DS    0H                 After the move, we act on the\n*                                 information from the previous\n*                                 AWS header.\n         ST    R9,SAVER9AF        Save BAL register\n         NI    NOWRTFLG,FF-X'01'  Turn off flag initially\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nAFTTST40 DS    0H                 X'40' means END-OF-FILE\n*                                 So we finish off the file-level stuff\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   TEST TEST TEST:  CHECK IF THERE CAN BE A VALID X'4x'  -------\n         CLI   PRVHFLGS,X'40'     Is there an end-of-file condition?\n         BNE   AFTTSTA0           No. Do next test.\n         BAL   R9,WRITTPMK        Yes. Write a tape mark.\n         AP    FILCOUNT,=P'1'     Count number of files written.\n         BAL   R9,REPTFILE        Report on this file in SYSFILES.\n         ZAP   BLOCKCNT,=P'0'     Zero block count for next file\n         ZAP   FILEBYTS,=P'0'     Zero bytes moved for next file\n         NI    FILBLFLG,FF-X'01'  Turn off Label File indicator\n         XC    DBINF,DBINF        Zero byte count at file level\n         XC    DAINF,DAINF        Zero data bytes at file level\n         XC    LBINF,LBINF        Zero label bytes at file level\n** - SYSMOVED ->>    Record the number of files written  -  BELOW\n         TM    FLAGSYST,X'02'     Is SYSMOVED here and open?\n         BNO   AFTT40WM           No. Don't attempt a print.\n         MVC   OUTLINE,OUTLINE-1         Clear line.\n         MVC   OUTLINE,MESSAG12          Mark END-OF-FILE in SYSMOVED\n         MVC   OUTLINE+38(9),FILEPAT     Move in edit pattern\n         ED    OUTLINE+38(9),FILCOUNT+3  Tell which file number ended\n         PUT   SYSMOVED,OUTLINE\nAFTT40WM DS    0H\n** - SYSMOVED ->>    Record the number of files written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-40: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND           No more processing after this.\n*\nAFTTSTA0 DS    0H                 X'A0' means beg and end of block\n         CLI   PRVHFLGS,X'A0'     Is chunk equal block?\n         BNE   AFTTST80           No. Test for first chunk in block.\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR\n** ---------- >>\n         XC    BLOKBYTS,BLOKBYTS  Zero bytes moved after write\n         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too\n*        MVC   LINE+1(8),=C'AFT-A0: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTTST80 DS    0H                 X'80' means beginning of block\n         CLI   PRVHFLGS,X'80'     Beginning chunk of bigger block?\n         BNE   AFTTST00           No. Do next test.\n         OI    NOWRTFLG,X'01'     Must move buffer start location up\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT80WM                 No, can't write data to it.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT80WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-80: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTTST00 DS    0H                 X'00' means middle chunk of block\n         CLI   PRVHFLGS,X'00'     Is this a middle chunk?\n         BNE   AFTTST20           No. Try next test.\n         OI    NOWRTFLG,X'01'     Must move buffer start location up\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT00WM                 No, can't write data to it.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT00WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-00: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND           Get out - not X'80' or X'20'\nAFTTST20 DS    0H                 X'20' means last chunk of block\n         CLI   PRVHFLGS,X'20'     Is end-of-block on?\n         BNE   AFTRMERR           No. Must be error. Tested all types.\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR\n*                                 Byte stats accumulated by WRITBUFF\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT20WM                 No, can't write data to it.\n         TM    BWRITFLG,X'01'           Already written MESSAGE3?\n         BO    AFTT20NW                 Yes. Don't repeat info here.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT20NW DS    0H\n         NI    BWRITFLG,FF-X'01'        Write MESSAG11 from here on.\nAFTT20WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n         XC    BLOKBYTS,BLOKBYTS  Zero byte count moved after write.\n         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too\n*        MVC   LINE+1(8),=C'AFT-20: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTRMERR DS    0H                 Code any error handling here.\nAFTRMEND DS    0H\n         L     R9,SAVER9AF        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITBUFF DS    0H\n         ST    R9,SAVER9WR        BAL register save for WRITBUFF\n         TM    READFLAG,X'01'     READ ONLY run?\n         BO    WRITREAD           Yes. Don't do the EXCP.\n         LA    R1,TAPOUT          R1=address of current DCB\n         ST    R1,OUTDCBPT        Put it in IOB\n         MVC   OUTCCW+1(3),UNFBSTRT+1   PRIME OUTPUT CCW\n         MVC   OUTCCW+6(2),BLOKBYTS+2    Move length of block\n         MVI   OUTECB,X'00'       Initialize ECB\n         EXCP  OUTIOB             Write out the buffer\n         WAIT  ECB=OUTECB         Wait for write to complete\n         CLI   OUTECB,X'7F'       Write completed normally?\n         BNE   WRITBERR           No - error\nWRITREAD DS    0H\n         AP    BLOCKCNT,=P'1'     Block count for this file\n         AP    BLOCKTOT,=P'1'     Block count for entire tape\n         MVC   UNFBUFFR,UNFBSTRT  Reset buffer start in UNFAREA\n         B     WRITBUFE           OK\nWRITBERR DS    0H\n* --- >  handle eov on output - below\n         NI    UNEXFLAG,FF-X'01'  Clear bit on unit exception flag\n         TM    OUTCSW+4,X'02'     Unit check?\n         BO    OUTERUC            Yes. Handle it.\n         TM    OUTCSW+4,X'01'     Unit exception on write?\n         BZ    OUTERR1            No. Assume data check.\n         OI    UNEXFLAG,X'01'     Flag that we have unit exception\n         MVC   LINE,LINE-1        Clear output line\n         MVC   LINE(133),OUTUNEX  Set unit exception error message\n         B     OUTERR2\nOUTERUC  MVC   LINE(133),OUTEQC   Set unit check error message\n         B     OUTERR2            Continue\nOUTERR1  DS    0H\n         MVC   LINE(133),OUTDCK   Set data check error message\nOUTERR2  DS    0H\n         ST    R2,SAVER2E         Save Registers\n         ST    R4,SAVER4E\n         ST    R5,SAVER5E\n         L     R2,OUTDCBPT        Load DCB address\n         LH    R4,40(,R2)         R4=TIOT offset\n         L     R5,16              R5=CVT\n         L     R5,0(,R5)          R5=TCB words\n         L     R5,4(,R5)          R5=My TCB\n         L     R5,12(,R5)         R5=TIOT\n         AR    R4,R5              R4=TIOT Entry for this output\n         MVC   LINE+34(6),4(R4)   Move DDNAME to message\n         L     R4,16(,R4)         R4=UCB for this output\n         MVC   LINE+47(4),12(R4)  Move unit address to message\n         MVC   LINE+60(6),36(R4)  Move VOLSER to message\n         L     R2,SAVER2E         Restore Registers\n         L     R4,SAVER4E\n         L     R5,SAVER5E\n         TM    UNEXFLAG,X'01'     Was this a Unit Exception only?\n         BNO   OTHERERR           No. Just go on.\nHANDLEOV DS    0H            If Unit Exception, then ask for new volume\n         PUT   SYSPRINT,LINE      Write message\n         BAL   R9,SUMMREPT        Print summary report before doing EOV\n         TM    READFLAG,X'01'     If Read Only, skip EOV macro.\n         BO    OTHERERR\n         MVC   OURRC,=F'4'        Indicate scratch volumes asked for\n         CLC   MAXRC,OURRC        Is MAXRC higher?\n         BH    SAMERC03           Yes. Keep it.\n         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.\nSAMERC03 DS    0H\n         EOV   TAPOUT\nOTHERERR DS    0H\n* --- >  handle eov on output - above\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS2\n         HEX   OUTLINE+34,4,UNFBYMVD    Print Reg 2\n         HEX   OUTLINE+44,2,HDRLENG     Pring Header Length\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFE                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\nWRITBUFE DS    0H                       Stats for data moved\n** ---------- >>    Record the number of bytes written\n         ST    R2,SAVER2N           Save prev contents of Register 2\n         ST    R3,SAVER3N           Save prev contents of Register 3\n         XR    R2,R2                High order is zero\n         L     R2,BLOKBYTS          Load Current Written Byte Count\n         LA    R3,DBIN              Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBINF             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DAINF             This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,LBINF             Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n** -->   label byte counts and data byte counts  <-- **  above\n         L     R2,SAVER2N           Restore prev contents of Register 2\n         L     R3,SAVER3N           Restore prev contents of Register 3\n** ---------- >>    Record the number of bytes written\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAGE3\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT TOTAL BYTES MOVED\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT PREVIOUS LENGTH\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFX                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\n         OI    BWRITFLG,X'01'           Show you've been here\nWRITBUFX DS    0H\n         L     R9,SAVER9WR          BAL register restore for WRITBUFF\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITTPMK DS    0H               Routine to write a tape mark\n         ST    R9,SAVER9WR      BAL register save for WRITTPMK\n         TM    READFLAG,X'01'   Is this run READ ONLY ?\n         BO    WRITTPME         Yes. Bypass entire routine.\n         LA    R1,TAPOUT        R1=address of current DCB\n         ST    R1,OUTDCBPT      Put it in IOB\n         MVI   OUTCCW,X'1F'     Tape Mark opcode\n         MVC   OUTCCWST(2),OUTCCW+6   Store previous move value\n         MVC   OUTCCW+6(2),X'0000'    Shove zeros into length field\n*                                     so AWSTAPE emulator doesn't barf\n         MVI   OUTECB,X'00'     Initialize ECB\n         EXCP  OUTIOB           Write the tape mark\n         WAIT  ECB=OUTECB       Wait for write to complete\n         CLI   OUTECB,X'7F'     Write completed normally?\n         BNE   WRITTPER         No. Indicate tape mark write error.\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST   Restore bytes moved field in CCW\n         B     WRITTPME         Don't indicate error condition\nWRITTPER DS    0H               Tape mark write error display\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS4\n         HEX   OUTLINE+34,4,OUTECB\n         HEX   OUTLINE+44,8,OUTCSW\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST    Restore byte moved field in CCW\nWRITTPME DS    0H\n         L     R9,SAVER9WR      BAL register restore for WRITTPMK\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  Add Byte Count subroutine\n         ST    R9,SAVER9AD         BAL register save for ADDCOUNT\n         ST    R4,SAVER4N          Save and Restore\n         ST    R5,SAVER5N             Work Registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           Else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         L     R4,SAVER4N          Save and Restore\n         L     R5,SAVER5N             Work Registers\nADDCOUNE DS    0H                  End of routine - Return\n         L     R9,SAVER9AD         BAL register restore for ADDCOUNT\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SU               Save BAL register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---- --- --- --->\n         TM    FLAGNEWV,X'01'\n         BZ    NOCHGVSR\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+3(130),MESSAGE7\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\nNOCHGVSR DS    0H\n* >---- --- --- --->\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),UNFINRCD   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INHDRS     NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE1    BEGINNING OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG04\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE2    MIDDLE OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG05\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE3    END OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE4    END OF TAPE HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG07\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE5    END OF TAPE HEADERS\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDLE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\nNOMIDDLE DS    0H\n*** -------- >>>\nNOSUMM05 DS    0H\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDPR\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\nNOMIDDPR DS    0H\n*** -------- >>>\nSUMMREPE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SU         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LC          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         LA    R1,TESTLABL          Point to 80 bytes to be tested.\n         CLC   =C'VOL1',0(R1)       Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   =C'HDR1',0(R1)       Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   =C'HDR2',0(R1)       This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   =C'EOF1',0(R1)       This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   =C'EOF2',0(R1)       This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   =C'EOV1',0(R1)       This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   =C'EOV2',0(R1)       This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   =C'UHL',0(R1)        This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   =C'UTL',0(R1)        This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  Yes. Don't change the volser.\n         CLI   FLAGNEWV,X'01'            Is the flag on, to change vol?\n         BNE   NOCHGVOL                  No. Don't change it.\n         L     R1,SVINAREA               Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAGE7+28(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\nNOCHGVOL DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         L     R1,SVINAREA               Point to INAREA\n         CLC   4(23,R1),ZERO23      WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\n         OI    FLAGHDRL,X'01'\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         OI    FLAGHDRL,X'01'\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOF2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\n         L     R9,SAVER9LC          Restore BAL register\nLABCHEND BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n         ST    R9,SAVER9RP\n*----------->>\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n*--->                   Block counts first  -  above\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    LBLSMSG0                  Yes. Show labels, not data.\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01A      Tell it's labels written.\n         B     ENDSMSG0\nLBLSMSG0 DS    0H\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01B      Tell it's data written.\nENDSMSG0 DS    0H\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3  Put file count in message\n*--->\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    DISLABLS                  Yes. Do the label treatment.\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Cumulative data bytes written\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),DATDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),LABDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINFH          Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBINH           Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\nREPTFEND DS    0H\n         L     R9,SAVER9RP\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nVALIDHDR DS    0H                     VALIDATE HEADER GOTTEN\n         NI    HDRVFLAG,FF-X'01'      Turn off invalid header flag.\n         CLI   HEADER+4,X'A0'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'80'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'20'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'00'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'40'\n         BE    VALIDHEN               Yes. Header is OK.\n         OI    HDRVFLAG,X'01'         Flag found header as invalid.\nVALIDHEN DS    0H\n         BR    R9\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\nOUTCCW   DC    X'01',AL3(0),X'2000',X'FFFF'     OUTPUT AREA OVERLAID\nOUTECB   DC    F'0'\nOUTIOB   DC    X'02000000'\n         DC    A(OUTECB)\nOUTCSW   DC    2F'0'\nOUTCCWPT DC    A(OUTCCW)\nOUTDCBPT DC    A(TAPOUT)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            PADDING\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY AWSIN\nAWSIN    DCB   DDNAME=AWSIN,MACRF=GM,EODAD=FIN,DSORG=PS,LRECL=80\nTAPOUT   DCB   MACRF=(E),DDNAME=TAPOUT,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X\n               EODAD=SYSINEND\n         DC    CL8' '\nFF       EQU   X'FF'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL6                     BLOCK HEADER\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRFLAG1 DC    X'00'                    FLAGS BYTE 1...\nHDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD\nHDRF1MOR EQU   X'00'                    ...MIDDLE OF RECORD\nHDRF1EOR EQU   X'20'                    ...END OF RECORD\nHDRF1TMK EQU   X'40'                    ...TAPE MARK\nHDRFLAG2 DC    X'00'                    FLAGS BYTE 2\n* ----------------------------------------------------------------- *\n*\nINHEADER DC    XL6'00'\nUNEXFLAG DC    X'00'                    FLAGS BYTE 1...\n         DC    XL80'00'                 PADDING\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'             Byte count in CCW - saved during WTM\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         ORG   HEXSAVE       SAVE A LITTLE STORAGE              \\\nDB       DC    D'0'          DOUBLE-WORD WORK AREA              \\\nDB2      DC    0D'0',PL8'0'  DOUBLE-WORD WORK AREA              \\\n*  TABLE OF DAYS IN PRIOR MONTH                                 \\\nDATETABL DC   H'0,31,59,90,120,151,181,212,243,273,304,334,365' \\\n         EJECT\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nBWRITFLG DC    X'00'    MESSAGE3 was already written flag.\n*              X'01'    Don't have to write SYSMOVED message now.\n* ---------- *\nINITFLAG DC    X'00'    First invocation of UNFOLDEM at beg of tape.\n*              X'01'    After the first invocation of UNFOLDEM.\n* ---------- *\nHDRVFLAG DC    X'00'    HEADER IS VALID IF X'00'\n*              X'01'    HEADER IS INVALID--FILE MUST BE CORRUPTED\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nREADFLAG DC    X'00'               This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nISLBLFLG DC    X'00'               80 BYTE BLOCK IS NOT A LABEL\n*              X'01'         80 BYTE BLOCK IS A LABEL\n* ---------- *\nFILBLFLG DC    X'00'               IS THE FILE A LABEL FILE?\n*              X'01'         THIS FILE IS A LABEL FILE\n* ---------- *\nFLAGHDRL DC    X'00'               HEADER LABEL FLAG\n*              X'01'         EOT HEADER IS FOLLOWING A HEADER LABEL\n* ---------- *\nFLAGSYST DC    X'00'           FLAG TO SHOW IF SYSTRACE DD IS THERE\n*              X'01'         //SYSTRACE DD IS THERE\n*              X'02'         //SYSMOVED DD IS THERE\n*              X'04'         //SYSFILES DD IS THERE\n*              X'08'         //SYSIN    DD IS THERE\n* ---------- *\nFLAGNEWV DC    X'00'           FLAG TO SHOW IF A NEW VOLSER PLUGGED IN\n*              X'01'         SVNEWVOL FIELD HAS BEEN SUBSTITUTED.\n* ---------- *\nNOWRTFLG DC    X'00'           FLAG TO SHOW NOT END OF BLOCK\n*              X'01'           ON - HAVE TO CONTINUE IN SAME BUFFER\n* ---------- *\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n* -------------------------------------------- *\nBLOKBYTS DC    F'0'                Count of bytes for block.\nFILEBYTS DC    F'0'                Count of bytes for file.\n* -------------------------------------------- *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHKNWVOL DC    CL6' '              Raw saved volser before syntax check\nDWORD    DC    D'0'\nSAVR2T5  DC    4F'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nINHDRS   DC    PL7'0'\nINTYPE1  DC    PL7'0'\nINTYPE2  DC    PL7'0'\nINTYPE3  DC    PL7'0'\nINTYPE4  DC    PL7'0'\nINTYPE5  DC    PL7'0'\nFILCOUNT DC    PL7'0'\nFERCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLERRCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL43\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Label Bytes'\nDATDISPL DS    0CL43\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data Bytes '\n*\nSAVEEN80 DS    F         Addresses:  80 bytes past record end\nSAVEENDC DS    F                     Record end location\nSAVEBEGC DS    F                     Record beginning location\nBEGDATA  DS    F                     Where this record's data begins\n*\n* below - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\n* ------                      Move count for bytes in the buffer\nBYTEBFWD DS    0F\nBYTEFILL DC    H'0'\nBYTEMOVE DC    H'0'\n* ------\nSVUNFOLD DC    F'0'           Entry point of UNFOLDEM subprogram\nSVINAREA DS    F\nSAVER2E  DS    F\nSAVER4E  DS    F\nSAVER5E  DS    F\nSAVER2N  DS    F              Has to do with byte counting subroutine\nSAVER3N  DS    F              Has to do with byte counting subroutine\nSAVER4B  DS    F              HEX print register save\nSAVER4N  DS    F              Has to do with byte counting subroutine\nSAVER4Q  DS    F              Has to do with byte counting subroutine\nSAVER5N  DS    F              Has to do with byte counting subroutine\n* --- below                   SAVE BAL REGISTER for each subroutine\nSAVER9HV DS    F              Has to do with Header Validation\nSAVER9AD DS    F              Has to do with ADDCOUNT routine\nSAVER9AF DS    F              Has to do with AFTRMOVE routine\nSAVER9WR DS    F              Has to do with WRITBUFF routine\nSAVER9WT DS    F              Has to do with WRITTPMK routine\nSAVER9CH DS    F              Has to do with CHKHEADR routine\nSAVER9LC DS    F              Has to do with LABELCHK routine\nSAVER9RP DS    F              Has to do with REPTFILE routine\nSAVER9SU DS    F              Has to do with SUMMREPT routine\n* --- above                   SAVE BAL REGISTER for each subroutine\n*\n* above - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\nOURRC    DC    F'0'\nMAXRC    DC    F'0'\nHDRBYTES DS    F\nHDRBSAVE DS    F\nSAVER8C2 DS    F\n         DC    C' '\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    BUFFER OVERFLOW ERROR  '\nERRMESS2 DC    CL133'    TAPE OUTPUT WRITE ERROR'\nERRMESS3 DC    CL133'    OFFSET ERROR           '\nERRMESS4 DC    CL133'    TAPE MARK WRITE ERROR  '\nERRMESS5 DC    CL133' >> AWS HEADER IS INVALID - CORRUPTION AT THIS POI-\n               NT >> '\nERRMESS6 DC    CL133' >> AWS HEADER IS INVALID - PREV BYTES - CURR BYTE-\n               S  >> '\n*\n*  -----------------            Tape Output Error Message Texts\nOUTEQC   DC    C' ********** EQUIPMENT CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\nOUTUNEX  DC    C' *********** TAPE HAS ENDED ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- PRIVATE SCRATCH REQUESTED '\n         DC    37C'*'\nOUTDCK   DC    C' **********      DATA CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2TAPE - AWS TAPE FILE TO ACTUAL TAPE CONVERSIO-\n               N PROGRAM  '\nMESSAGE4 DC    CL133'1VTT2TAPE  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE5 DC    CL133'1VTT2TAPE - AWS TAPE DATA MOVE - TRACE AND ERROR R-\n               EPORT  '\nMESSAGE6 DC    CL133'1VTT2TAPE - AWS TAPE FILE REPORT - MOVE AND WRITE -\n               STATS  '\nMESSAGE8 DS    0CL133\n         DC    CL8' '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'UNFSCARD'\n         DC    CL10'UNFECARD'\n         DC    CL10'UNFOFFST'\n         DC    CL10'UNFBYTES'\n         DC    CL10'UNFBYMVD'\n         DC    CL10'UNFBUFFR'\n         DC    CL10'UNFBSTRT'\n         DC    CL14'UNFINRCD'\n         DC    CL21' '\nMESSAGE9 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS GOTTEN BY THE PROGRAM, IN READING THROUGH A TAPE.'\nMESSAG10 DC    CL133'        THE UNFAREA (UNFOLD AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST GOTTEN.-\n               '\n*  -----------------            Diagnostic Info Message Texts\nMESSAGE2 DC    CL133'  OFFSET SIZE AND LOCATION '\nMESSAGE3 DC    CL133'  NUMBER OF BYTES WRITTEN  '\nMESSAGE7 DC    CL133'  VOLSER OVERRIDDEN TO:    '\nMESSAG11 DC    CL133'  NUMBER OF CHUNK BYTES    '\nMESSAG12 DC    CL133'  -- End of File Marker - File Number'\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS IN:  '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS IN:  '\nPRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS   :  '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS   :  '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS   :  '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS :  '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK :  '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01A DC    CL38'     DATA   WRITTEN FOR FILE:         '\nCTMSG01B DC    CL38'     LABELS WRITTEN FOR FILE:         '\nCTMSG02  DC    CL38'     BYTES  WRITTEN FOR FILE:         '\nCTMSG03  DC    CL38'     TOTAL BYTES   MOVED  FOR TAPE  : '\nCTMSG04  DC    CL38'     TOTAL BYTES  WRITTEN FOR TAPE  : '\nCTMSG05  DC    CL38'     TOTAL BYTES  WRITTEN FOR LABELS: '\nCTMSG06  DC    CL38'     TOTAL BYTES  WRITTEN FOR DATA  : '\nCTMSG07  DC    CL38'     BLOCKS WRITTEN FOR FILE:         '\nCTMSG08  DC    CL38'     TOTAL BLOCKS WRITTEN FOR TAPE  : '\n*\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nPRTLINE  DC    CL133' '\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\n* --- >\nSAVEHDR  DS    0CL6\nSAVCURLN DS    XL2\nSAVPRVLN DS    XL2\nSAVHFLGS DS    X\nSAVHREST DS    X\n* --- >\nPREVHDR  DS    0CL6\nPRVCURLN DS    XL2\nPRVPRVLN DS    XL2\nPRVHFLGS DS    X\nPRVHREST DS    X\n* --- >\nEOTMARK  DC    XL6'000000004000'\nDBINF    DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE\nDBINFH   DC    F'0'\nDBINFL   DC    F'0'\nDBIN     DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL\nDBINH    DC    F'0'\nDBINL    DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nLBINF    DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINFH   DC    F'0'\nLBINFL   DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\nDAINF    DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINFH   DC    F'0'\nDAINFL   DC    F'0'\n         DC    CL8' '\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 Extra fullword for safety\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n*      Uppercase alpha and only allow printable characters.\nTRTBLPRT DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'40D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'4040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\n*\nTESTLABL DC    CL80' '\nGETSYSIN DC    CL80' '\nINCARDP  DC    XL80'00'           Previous card-image read\nINCARD   DC    XL80'00'           Current  card-image read\nINCAEND  EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         IEZIOB DSECT=YES\n         SPACE\n         YREGS\n         END\n./       ADD   NAME=UNFOLDEM\n   TITLE 'UNFOLDEM -- UNFOLD FB-80 DATA INTO A LONG BUFFER'\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    UNFOLDEM                                          *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating a       *\n*      real tape from an AWS-format tape file, which has been       *\n*      folded over into an FB-80 dataset.  The AWS header           *\n*      contains the number of bytes in the next chunk (complete     *\n*      or partial block) of tape data.  Once this quantity is       *\n*      known, and the beginning position of the data has been       *\n*      established (it starts just after the header ends), then     *\n*      the data itself has to be moved into a buffer, in            *\n*      preparation for that data block being written out to a       *\n*      tape.  This program unfolds the correct amount of data,      *\n*      beginning at a known position in the FB-80 file, into        *\n*      the buffer.  The position in the FB-80 file which marks      *\n*      the beginning of the data to be moved, is called the         *\n*      OFFSET into the 80-byte card, and it starts with position    *\n*      +0.                                                          *\n*                                                                   *\n*  INPUTS and OUTPUTS:   Described below.                           *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called AWSIN, which contains its input         *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do GETs from AWSIN, and if necessary, it needs      *\n*      to write messages to SYSPRINT.  The caller has to provide    *\n*      ENTRY AWSIN and ENTRY SYSPRINT statements in front of        *\n*      the AWSIN and SYSPRINT DCBs, respectively.                   *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      UNFAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      UNFAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the UNFAREA.                                        *\n*                                                                   *\n*      The caller does one GET of the FB-80 file, to read an        *\n*      AWS header (that has tape data following it).  Once the      *\n*      AWS header has been read, there should be enough data to     *\n*      supply to the UNFAREA control block, and then this           *\n*      program is called, to complete the move of that tape data    *\n*      to a buffer, and position the FB-80 input just past the      *\n*      data moved, so it should point to the next AWS header.       *\n*                                                                   *\n*      This program does more GETs from the FB-80 input file,       *\n*      until the request for the number of bytes to be moved,       *\n*      is satisfied.                                                *\n*                                                                   *\n*      The following is the layout of the UNFAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      UNFAREA  DS    0F          UNFOLD AREA CONTROL BLOCK         *\n*      *                          ------ ---- ------- -----         *\n*  --> UNFSCARD DC    F'0'        Start address of 80-byte card     *\n*  --> UNFECARD DC    F'0'        End address of 80-byte card       *\n*  --> UNFOFFST DC    F'0'        OFFSET of data to be moved        *\n*  --> UNFBYTES DC    F'0'        Number of bytes to be unfolded    *\n*      UNFBYMVD DC    F'0'        Number of bytes that were moved   *\n*  --> UNFBUFFR DC    F'0'        Current start address in buffer   *\n*  --> UNFBSTRT DC    F'0'        Original start address of buffer  *\n*      UNFINRCD DC    PL7'0'      Number of GETs for AWSIN records  *\n*      UNFLENTH EQU   *-UNFAREA                                     *\n*      *                                                            *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      UNFBUFFR and UNFOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the output data     *\n*      and input data positions, respectively, that are just        *\n*      after the moved data, so as to wait for the next call,       *\n*      to be able to move more data.  UNFBSTRT preserves the        *\n*      very beginning address of the output buffer, whereas         *\n*      UNFBUFFR is a place somewhere within the buffer, which       *\n*      is the start of where the new data is expected to be         *\n*      moved.                                                       *\n*                                                                   *\n*      Since both the caller and this program do GET operations     *\n*      from the input FB-80 file, the count of the number of GETs   *\n*      done, UNFINRCD, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\nUNFOLDEM CSECT ,                                                \\\nUNFOLDEM AMODE 24\nUNFOLDEM RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'UNFOLDEM '\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING UNFOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,AWSINV             AWSIN    DCB address in caller\n         ST    R0,AWSINDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to unfold FB-80 data starting at an OFFSET from the     *\n*   beginning of a card, for a certain number of bytes, to a data   *\n*   buffer area whose beginning address is supplied.  More 80-byte  *\n*   records can be read with the GET macro from the FB-80 file, to  *\n*   fulfill the move request.                                       *\n*                                                                   *\n*   Input:   UNFAREA fields are all supplied by the calling         *\n*            program, except for UNFBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            UNFAREA is pointed to by Register 1.                   *\n*                                                                   *\n*            The initial card image which is supplied by the        *\n*            calling program, already is primed with data to be     *\n*            moved (one card's worth of it).  This card contains    *\n*            the starting point for the data to be moved, at an     *\n*            OFFSET (displacement) from the beginning of the card.  *\n*                                                                   *\n*            The input data also contains the address of an         *\n*            output buffer area, which is the target for the        *\n*            (segmented) data moves.  Data will be strung out       *\n*            into this area, one card (or a partial card) at a      *\n*            time.  The current card which is in the input file,    *\n*            which contains the beginning of the data to be         *\n*            moved, has already been loaded into a card image       *\n*            work area pointed to by the calling program.  The      *\n*            OFFSET into this card is where the data to be moved    *\n*            will start.                                            *\n*                                                                   *\n*            It is the responsibility of the calling program to     *\n*            ensure that this routine has access to all of the      *\n*            buffer storage where the data is supposed to be        *\n*            moved to.                                              *\n*                                                                   *\n*   Output:  Data is moved, for the required number of bytes, to    *\n*            the output buffer area.  When more that one card       *\n*            image's worth of data has to be moved, more cards      *\n*            are obtained with the GET macro, from the input file.  *\n*                                                                   *\n*            Ending OFFSET in the FB-80 input file, pointing to     *\n*            just after the data which was moved, in the final      *\n*            card image gotten, is returned to the UNFOFFST field   *\n*            and reported to the caller, in anticipation of the     *\n*            next call to this routine.                             *\n*                                                                   *\n*            Ending address of data in buffer - one byte after      *\n*            the end of the moved data - is returned in the         *\n*            UNFBUFFR field.  The UNFBSTRT field preserves the      *\n*            address of the beginning of the data buffer.           *\n*                                                                   *\n*            A count of bytes actually moved from the FB-80 file    *\n*            to the output buffer area is reported in the UNFBYMVD  *\n*            field.  This must match the byte count of bytes which  *\n*            needed to be moved initially.  That count had been     *\n*            initially supplied by the calling program in the       *\n*            UNFBYTES field.                                        *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nUNFOLD   DS    0H\n         ST    R1,PARMPTR\n         L     R2,=A(UNFBLOCK)\n         USING UNFBLOCK,R2\n         MVC   UNFAREA(UNFLENTH),0(R1)      Move input block to pgm\n         LA    R2,UNFAREA                   And address it.\n         MVC   SAVEBEGC,UNFSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,UNFECARD    Save \"end of card\" address\n         L     R1,UNFSCARD          Address of card\n         MVC   WORKPREV(80),ZEROCARD   Zero prev work area\n         MVC   WORKCURR(80),0(R1)   Move card image to curr work area\n         MVC   UNFBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,UNFSCARD          Point to beginning of card\n         A     R7,UNFOFFST          Add OFFSET to start of input\n         ST    R7,SAVEBEGI          Save where input starts\n         L     R8,SAVEBEGI          Copy beg of input address\n         A     R8,UNFBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n* - - - - - - - - - - - - - - >>    This may be way past the address\n*             of the end of the FB-80 card.  We will decrease this\n*             address as we move bytes from successive cards to the\n*             data buffer, by 80 bytes at a time, as we GET new cards,\n*             until R8 actually falls within the end-of-card address.\n*             We will then use this address to calculate the new\n*             OFFSET for the next piece of data in the FB-80 file.\n*             The new OFFSET is returned to the caller by modifying\n*             the UNFOFFST field in the control block.\n*\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nLOOPSET  DS    0H                   Start moving data\n         L     R3,UNFBUFFR          Point to beginning of buffer\n         ST    R3,SAVEBEGD          Save location in the program.\n         LR    R4,R3                Point R4 to end of data by adding\n         A     R4,UNFBYTES          the number of bytes to the start.\n         ST    R4,SAVEENDD          Save potential end of data location\n         ST    R8,SAVER8TR          Save R8 for trace.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is within the current card.           *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.                       *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         C     R8,SAVEENDC          Is R8 still past end-of-card?\n         BH    LOOPMORE             Yes. Copy till end and GET.\nLOOPSHRT DS    0H                   The move is short, not past end.\n         LR    R6,R8                No. Get byte count to move NOW.\n         SR    R6,R7                Bytes to move\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data to the buffer.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,UNFBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET - save R8\n         S     R6,UNFSCARD          Subtract beginning of card address\n         ST    R6,UNFOFFST          Store the result as new OFFSET\n*        MVC   LINE+1(8),=C'LSHRT2: '\n*        BAL   R9,UNFIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Test if past end\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,UNFBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card gotten\n         MVC   WORKPREV,WORKCURR    Save card image to previous\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWSINDCB         Point to AWSIN DCB in caller\n         GET   (10),WORKCURR        Get a new card image\n         L     R10,SAVER10          Restore R10\n         AP    UNFINRCD,=P'1'       Increment count of AWSIN rcrds read\n         L     R7,SAVEBEGC          Point to beginning addr of workarea\n         MVC   0(80,R7),WORKCURR    Overlay caller's card image\n*        MVC   LINE+1(8),=C'LMORE2: '\n*        BAL   R9,UNFIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R3),0(R7)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE OPERATING SYSTEM\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of UNFAREA in caller\n         MVC   0(UNFLENTH,R10),UNFAREA    Copy changed UNFAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(UNFBLOCK)  Return address of UNFAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H          Diagnostic Data - State of UNFAREA currently\n*\n         HEX   LINE+10,4,UNFSCARD\n         HEX   LINE+20,4,UNFECARD\n         HEX   LINE+30,4,UNFOFFST\n         HEX   LINE+40,4,UNFBYTES\n         HEX   LINE+50,4,UNFBYMVD\n         HEX   LINE+60,4,UNFBUFFR\n         HEX   LINE+70,4,UNFBSTRT\n         HEX   LINE+80,4,SAVER8TR\n         HEX   LINE+90,7,UNFINRCD\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nUNFBLOCK CSECT\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n*\nUNFOLDEM CSECT\nWORKPREV DS    CL80                 Contiguous previous card image\nWORKCURR DS    CL80                 Card image work area\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nLINE2    DC    CL133' '\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGD DC    F'0'                 Save beg of buffer data address\nSAVEENDD DC    F'0'                 Save end of buffer data address\nSAVEBEGI DC    F'0'                 Save beg address of card input\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVER8TR DC    F'0'                 Save floating Reg 8 which decreases\nSAVEPARM DC    F'0'                 Save CALLER'S UNFAREA ADDRESS\nPARMPTR  DC    F'0'\nSYSPRINV DC    V(SYSPRINT)\nAWSINV   DC    V(AWSIN)\nSYSPRDCB DC    F'0'\nAWSINDCB DC    F'0'\nSAVER10  DC    F'0'\n         SPACE\n         YREGS\n         END\n./       ADD   NAME=VTT2DISK\n   TITLE 'VTT2DISK -- READ A REAL TAPE AND CREATE FB-80 AWS FILE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE:  VTT2DISK.   Written by Sam Golob               **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to read in a tape, and create an      **\n**            MVS disk file in \"folded FB-80 AWS format\".   **\n**                                                          **\n**     The output of this program is intended to be input   **\n**     for the VTT2TAPE program.  These two programs,       **\n**     VTT2DISK and VTT2TAPE, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  OBSERVATION:  Although this program is purely an MVS    **\n**                program, the AWS-format output of this    **\n**     program can be downloaded to other systems where     **\n**     the file can actually be interpreted as an emulated  **\n**     tape.  This is one way of transferring tape data to  **\n**     other MVS systems that can read AWS-format tape      **\n**     files directly, as though they were tapes.           **\n**                                                          **\n**     For example, you can take mainframe-based tapes      **\n**     on real cartridges and create AWS-format tape        **\n**     files that can be read on a FLEX-ES system, a P/390  **\n**     or a Hercules-based MVS system.                      **\n**                                                          **\n**     Arbitrary chunk sizes for the AWS-format tape files  **\n**     are now supported.  If you are reading the output    **\n**     file on a Hercules-based system, you should          **\n**     rename its file name as *.het , because the HET      **\n**     emulator on Hercules recognizes chunked blocks.      **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     Tape data is read into a data buffer in this         **\n**     program.  Each block is read in, and its size        **\n**     is determined.  This size is compared to the         **\n**     chunk size, and a decision is made as to what        **\n**     to do.  An AWS header is made for each chunk.        **\n**     Each AWS header is folded into FB-80 output,         **\n**     and then the data is folded in afterward, until      **\n**     the block, and its associated AWS headers, are       **\n**     all folded in.  Then another tape block is read      **\n**     into the buffer, and the process repeats.            **\n**                                                          **\n**     When the tape file ends, and a tape mark is read     **\n**     in, an X'40' format AWS header is constructed.       **\n**     It is then folded into the FB-80 output dataset,     **\n**     after the last data.                                 **\n**                                                          **\n**     At the end of the tape, an end-of-tape AWS           **\n**     header is appended to the end of the output          **\n**     file and folded in.  The last FB-80 record           **\n**     is completed with hex zeros, if necessary.           **\n**                                                          **\n**     As a controversial measure, a full 80-byte record    **\n**     of hexzeros is appended at the end of the file.      **\n**                                                          **\n**     All of the \"FB-80 folding\" work is now done by the   **\n**     sub-program called FOLDEM.  The FOLDEM program       **\n**     operation is completely controlled by a control      **\n**     block called the FLDAREA control block, which does   **\n**     all of the communication between the main program    **\n**     and the FOLDEM sub-program.  Therefore, monitoring   **\n**     of the folding process is now possible purely by     **\n**     displaying the current status of the FLDAREA         **\n**     fields.  A convenient routine for displaying the     **\n**     status of the FLDAREA fields is the FLDIMAGE         **\n**     routine in either program, which is invoked by:      **\n**                                                          **\n**     BAL   R9,FLDIMAGE                                    **\n**                                                          **\n**     Therefore the fold monitoring displays that used     **\n**     to be in the SYSMOVED DD name, are now obsolete.     **\n**                                                          **\n**     There are two more fields in the FLDAREA control     **\n**     block than in the UNFAREA control block of the       **\n**     UNFOLDEM sub-program that VTT2TAPE uses.  These      **\n**     are:                                                 **\n**                                                          **\n**           FLDBYTOT - bytes left in buffer after the      **\n**                      last chunk of data was folded       **\n**           FLDREADF - propagation of the \"read only\"      **\n**                      flag into the sub-program           **\n**                                                          **\n**     These extra fields are obviously not required by     **\n**     the unfolding process.  The first one is not         **\n**     required because you're doing \"unchunking\" instead   **\n**     of \"chunking\", and you read the existing chunks      **\n**     as they come in; you're not required to create       **\n**     them.  The second one is not required because the    **\n**     main program writes the output (a tape) instead of   **\n**     the sub-program writing the output (an FB-80 file).  **\n**     So in our case, if no output is to be written, the   **\n**     sub-program must know about it.                      **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**     In order to make sure that the VTT2DISK program      **\n**     is doing its job properly, it produces a lot of      **\n**     trace data and status data, as it is creating        **\n**     the folded FB-80 AWS format tape.  In order not      **\n**     to clutter the summary report, most of this          **\n**     data is written to \"Optional DDNAMEs\".  Starting     **\n**     with version 1.12 of this program, most of the       **\n**     trace data now consists of the state of the FLDAREA  **\n**     control block fields at various stages of program    **\n**     execution.                                           **\n**                                                          **\n**     If you have access to the source code (you are       **\n**     reading it), you can introduce an instruction:       **\n**                                                          **\n**           BAL   R9,FLDIMAGE                              **\n**                                                          **\n**     at any point in the program, as long as SYSPRINT     **\n**     is open.  This should produce any diagnostics you    **\n**     may need, because all FLDAREA fields are displayed.  **\n**                                                          **\n**     Optional DDNAMEs don't have to be coded in the       **\n**     JCL.  But if they are coded, they will contain       **\n**     the extra trace data which VTT2DISK produces,        **\n**     and the SYSFILES ddname will contain a detailed      **\n**     \"file by file\" report.                               **\n**                                                          **\n**     The SYSFILES report is very useful if you want       **\n**     to do a \"dry run\", with the READ parameter.  If      **\n**     you want to know the structure of a tape without     **\n**     creating the FB-80 output file, the SYSFILES         **\n**     report will tell you what files are on the tape.     **\n**     It will also give you an indication of how big an    **\n**     FB-80 output file you will need on an MVS disk,      **\n**     to contain all the tape data.  See below for         **\n**     details.                                             **\n**                                                          **\n**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **\n**     and SYSIN.  SYSMOVED is now obsolete, although       **\n**     it will produce a dummy report if it is present      **\n**     in the JCL.                                          **\n**                                                          **\n**     SYSIN data is necessary if optional parameters       **\n**     are to be entered, such as:                          **\n**                                                          **\n**     CHUNKSIZE=nnnn                                       **\n**     NEWVOL=volser                                        **\n**     READ                                                 **\n**     IDRCOFF                                              **\n**                                                          **\n**     SYSIN keywords have to start in column 1.            **\n**                                                          **\n**     Either READ or IDRCOFF can also be entered in the    **\n**     PARM field of the EXEC card in the JCL.              **\n**                                                          **\n**     Full JCL to run the VTT2DISK program is as           **\n**     follows:                                             **\n**                                                          **\n**     //   jobcard                                         **\n**     //AWSREAD  EXEC PGM=VTT2DISK                         **\n**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **\n**     //*AWSOUT   DD  DSN=fb80.folded.aws.file,DISP=SHR    **\n**     //*        .... if the file is preallocated ....     **\n**     //AWSOUT    DD  DSN=fb80.folded.aws.file,            **\n**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **\n**     //          VOL=SER=volxxx,                          **\n**     //          SPACE=(CYL,(mm,nn),RLSE)                 **\n**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **\n**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **\n**     //          LABEL=(1,BLP,EXPDT=98000)                **\n**     //SYSPRINT  DD  SYSOUT=*                             **\n**     //SYSFILES  DD  SYSOUT=*                             **\n**     //SYSTRACE  DD  SYSOUT=*                             **\n**     //SYSUDUMP  DD  SYSOUT=*                             **\n**     //SYSIN     DD  *                                    **\n**     keywords in column 1                                 **\n**     /*                                                   **\n**                                                          **\n**     where you can leave out SYSTRACE and SYSUDUMP        **\n**     if you want to.  I'd strongly suggest including      **\n**     (at least) SYSFILES, though.                         **\n**                                                          **\n**     SYSTRACE takes a picture of the tape buffer at       **\n**     READ time, and takes a picture of the AWS headers    **\n**     and the FLDAREA control block fields at the time     **\n**     the headers are made.  Since the folding is now      **\n**     done by the FOLDEM subprogram, SYSMOVED, which       **\n**     used to track the data folding process, is now       **\n**     not necessary.  Of course SYSUDUMP is there to       **\n**     contain the MVS-produced dump, upon any abnormal     **\n**     termination of the program.                          **\n**                                                          **\n**     SYSFILES gives you block counts and byte counts      **\n**     for all files read and written.                      **\n**                                                          **\n**     In the SYSPRINT report, there is a count of total    **\n**     number of 80-byte records which the program will     **\n**     (or has) put out.  If you are doing a READ only      **\n**     run, and want to allocate an output file which is    **\n**     the right size, you might use this number, together  **\n**     with the BLKnnnn command from File 296 of the CBT    **\n**     Tape, to produce the following result:               **\n**                                                          **\n**     Say, our program produces:                           **\n**                                                          **\n**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **\n**                                                          **\n**     And you want to allocate space on a 3390.  So you    **\n**     would say:                                           **\n**                                                          **\n**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **\n**                                                          **\n**     Which comes up with the result:                      **\n**                                                          **\n** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **\n**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.1 - Make sure program works properly        **\n**       folding the data from the input buffer into FB-80. **\n**                                                          **\n**    Version 1.2 - Level number in the report headings.    **\n**                                                          **\n**    Version 1.3 - Not stopped by null SL tape file.       **\n**                                                          **\n**    Version 1.4 - Byte count and cum byte count report    **\n**       in SYSFILES.  Differentiate between label bytes    **\n**       and data bytes in the reports.                     **\n**                                                          **\n**    Version 1.5 - Block counts for each file and for the  **\n**       entire tape.                                       **\n**                                                          **\n**    Version 1.6 - Fix a reporting problem with block      **\n**       counting.                                          **\n**                                                          **\n**    Version 1.7 - Allow PARM=READ, just to get stats.     **\n**                                                          **\n**    Version 1.8 - Make file-level stats reporting into    **\n**       a subroutine.  Fix a bug in cumulative data byte   **\n**       reporting.                                         **\n**                                                          **\n**    Version 1.9 - End program if error on input tape.     **\n**       If input tape is AWS with bad headers, break the   **\n**       loop upon thinking you have an infinite number of  **\n**       tape marks on input.                               **\n**                                                          **\n**    Version 1.9A - Accommodate 4 character version level. **\n**       Add extra line of ASCII blanks (X'20') to the      **\n**       output, to make Hercules happy, and to detect      **\n**       end-of-tape more easily.                           **\n**                                                          **\n**    Version 1.10 - PARM of IDRCOFF will turn off IDRC     **\n**       indicators in the VOL1, HDR2, EOF2, EOV2 labels.   **\n**                                                          **\n**    Version 1.11 - Last line has hexzeros instead of      **\n**       hex 20 as fillers.  It makes Hercules happier.     **\n**                                                          **\n**    Version 1.12 - Re-architected program to use FOLDEM   **\n**       sub-program for data moves.  The FOLDEM program    **\n**       is driven by the FLDAREA control block, so the     **\n**       trace data consists mostly of the state of the     **\n**       FLDAREA control block fields.  A routine called    **\n**       FLDIMAGE will print all the FLDAREA control block  **\n**       fields on a single SYSPRINT line.                  **\n**                                                          **\n**       Added the possibility of coding program options    **\n**       in the SYSIN DD, which is used if it is present    **\n**       in the JCL.  SYSIN keywords, which must be coded   **\n**       to start in column 1, are currently:               **\n**                                                          **\n**       CHUNKSIZE=nnnn                                     **\n**       NEWVOL=volser                                      **\n**       READ                                               **\n**       IDRCOFF                                            **\n**                                                          **\n**       Added CHUNKSIZE=nnnn SYSIN keyword to allow the    **\n**       creation of \"chunked AWS tape files by this        **\n**       program.  The AWS tape file architecture allows    **\n**       for unlimited tape block sizes, if the blocks      **\n**       are broken into \"chunks\" of 65535 bytes or less,   **\n**       separated by AWS headers.  IBM's original AWS      **\n**       tape standard used to require a maximum chunk      **\n**       size of only 4096 bytes.  In this program, 65535   **\n**       bytes is the default chunk size, but this value    **\n**       can be adjusted at assembly time by setting a      **\n**       global variable.                                   **\n**                                                          **\n**       The NEWVOL=volser keyword in SYSIN, allows you     **\n**       to change the volser in the VOL1 label of the      **\n**       output AWS-format tape file.                       **\n**                                                          **\n**       Now, the READ and IDRCOFF keywords of the EXEC     **\n**       PARM field, can also be coded in SYSIN.  They      **\n**       must begin in column 1.  READ allows a dry run     **\n**       of the program which reads the input tape and      **\n**       reports statistics, but which does not produce     **\n**       an output FB-80 AWS file.                          **\n**                                                          **\n**       IDRCOFF looks in the tape standard labels, if      **\n**       there are any, and turns off any \"P\" indicators    **\n**       which tell MVS that this tape was produced on      **\n**       an IDRC-enabled tape drive.  Since the output      **\n**       FB-80 file is not compressed anyway, one wants     **\n**       the power to read the AWS-format tape file on a    **\n**       logical 3420 or 3480 tape drive, without MVS       **\n**       telling you that \"the tape has compressed files    **\n**       and I can't read it\" on this particular drive.     **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n.* ---------------------------------------------------------------  *\n.*   This macro is used to display hex values in a printed report.  *\n.* ---------------------------------------------------------------  *\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n         GBLC  &DEFCHKC\n         GBLA  &DEFCHNK\n&LLEV    SETC  '1.12'\n* ------------------------------------------------------------------ *\n*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *\n*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *\n* ------------------------------------------------------------------ *\n&DEFCHNK SETA  65535\n&DEFCHKC SETC  '&DEFCHNK'\n         YREGS\n         EJECT\n** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **\nVTT2DISK CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2DISK AMODE 24\nVTT2DISK RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2DISK - REAL TAPE TO FOLDED FB-80 AWS DISK FILE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001-2005 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2DISK,R12,R11,R10,R8,R7\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LA    R7,4095(,R8)\n         LA    R7,1(,R7)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n* ----- >                            Parms          <--- below\n         L     R1,0(R1)              Get PARM field\n         CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BE    COPYREAD              Yes. Turn on indicator.\n         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?\n         BE    COPYIDRF              Yes. Say that.\n         B     COPYTAPE              No. Just go on with processing.\nCOPYREAD DS    0H                    READ only?\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     COPYTAPE\nCOPYIDRF DS    0H                    IDRC indicators off?\n         OI    IDRCFLAG,X'01'        Yes. Turn on flag.\n         B     COPYTAPE\n*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.\nCOPYTAPE DS    0H\n* ----- >                            Parms          <--- above\n*\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n*NEW*    TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         TIME  DEC           OLD AND SLOW                       \\\n         STCM  R0,15,TIME\n         OI    TIME+3,X'0F'\n*NEW*    STCM  R1,15,DATE+1                                     \\\n*NEW*    OI    DATE+4,X'0F'\n*NEW*    UNPK  DATED,DATE\n*  INSERTION TO SUPPORT DATE IN MVS 3.8                         \\\n         ST    R1,DB+4       SAVE JULIAN DATE                   \\\n         CLI   DB+4,1        DID USER SUPPLY A CENTURY?         \\\n         BH    HAVECENT      YES                                \\\n         AP    DB+4(4),=P'1900000'  ELSE ADD IT IN              \\\nHAVECENT MVO   DB2,DB+4(2)   ISOLATE THE YEAR                   \\\n         XC    DB(6),DB      ISOLATE THE DAYS                   \\\n         CVB   R1,DB         CONVERT DAYS TO BINARY             \\\n         CVB   R2,DB2        CONVERT YEAR TO BINARY             \\\n         SLR   R0,R0         SET FOR NO LEAP DAY ADJUSTMENT     \\\n*  N.B.: THIS WORKS UNTIL 2099 ONLY                             \\\n         EX    R2,EXISLEAP   TEST FOR MULTIPLE OF FOUR          \\\n         BNZ   NOTALEAP      BRANCH IF NOT A LEAP YEAR          \\\n         CH    R1,=H'60'     ON, BEFORE, OR AFTER LEAP DAY?     \\\n         BL    NOTALEAP      BEFORE; TREAT NORMALLY             \\\n         BH    ONELESS       AFTER; ADJUST DAY                  \\\n         LA    R0,1          SET LEAP DAY ADJUSTMENT            \\\nONELESS  BCTR  R1,0          ONE LESS TO FIX DAYS AFTER LEAP DAY\\\nNOTALEAP LA    R4,DATETABL   GET TABLE OF CUMULATIVE DAYS       \\\n         LR    R5,R4         SAVE                               \\\nFINDMON  CH    R1,2(,R4)     IN THIS MONTH?                     \\\n         BNH   FOUNDMON      YES; PROCESS                       \\\n         LA    R4,2(,R4)     INCREMENT                          \\\n         B     FINDMON       AND TRY AGAIN                      \\\nFOUNDMON SH    R1,0(,R4)     SUBTRACT DAYS IN PRIOR MONTHS      \\\n         AR    R1,R0         ADJUST 1 IF LEAP DAY               \\\n         LA    R4,2(,R4)     FINAGLE TO MAKE MONTH COME OUT RIGHT\n         SR    R4,R5         GET OFFSET TO MONTH                \\\n         SRL   R4,1          GET MONTH (1-12)                   \\\n*  WE NOW HAVE FULL YEAR IN R2, MONTH IN R4, AND DAY IN R1      \\\n         MH    R4,=H'100'    SHIFT FOR EDIT                     \\\n         AR    R4,R1         ADD DAY: MMDD                      \\\n         MH    R4,=H'10000'  SHIFT FOR EDIT                     \\\n         AR    R4,R2         NOW HAVE MMDDYYYY                  \\\n         MH    R4,=H'10'     FINAGLE A LITTLE MORE              \\\n         CVD   R4,DB         MAKE PACKED AND SIGNED             \\\n         UNPK  DATED,DB      CONFORM TO *NEW* CODE              \\\nEXISLEAP TM    =X'03',*-*    MULTIPLE OF FOUR?                  \\\n         SPACE 1                                                \\\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE3+88(31),HEADDLIT\n         MVC   MESSAGE4+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE2+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE3+61(21),LEVELLIT\n         MVC   MESSAGE4+61(21),LEVELLIT\n***********************************************************************\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants\n         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.\n         MVC   FULLHIGH(2),=X'0000'\n         MVC   CURRBYTE(2),=X'0000'\n         MVC   LASTBYTE(2),=X'0000'\n         MVC   HDRSIZE(4),=F'6'      Set size of header globally.\n         MVC   FLDOFFST(4),=F'0'     Offset is initially zero\n         LA    R1,OUTCARD            Let FOLDEM know about AWSOUT area\n         ST    R1,FLDSCARD           Beginning of card image output\n         ST    R1,SVBEGCRD\n         LA    R1,80(,R1)            Find end of card\n         ST    R1,FLDECARD           And store it away for the duration\n         ST    R1,SVENDCRD\n         L     R1,=A(INAREA)         Get address of input buffer\n         ST    R1,SVBFAREA           And save it away.\n         ST    R1,FLDBUFFR           Prime these fields\n         ST    R1,FLDBSTRT\n         L     R0,=F'&DEFCHNK'       Set default chunk size.\n         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.\n         ZAP   FLDOUTCT,=P'0'        Zero count of AWSOUT records.\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?\n         BNE   TIOTMOVD       NO\n*DEBUG*  OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n* ----------------------------------------------------------------- *\n* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *\n* ----------------------------------------------------------------- *\n*\n         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.\n*\n* ----------------------------------------------------------------- *\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n* - - - ->  Chunk Size Message - - - ->   below\n*    The purpose of this code is to fill MESSAG14 with information.\n         L     R1,CHNKSIZE                  Load binary Chunk Size\n         XC    DWORD,DWORD                  Clear DWORD to zeros.\n         CVD   R1,DWORD                     Convert to decimal.\n         OI    DWORD+7,X'0F'                Make sign readable.\n         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message\n         ED    MESSAG14+28(8),DWORD+4       Edit the number\n         B     AFCHKDSP                     Branch past constant\nCHPATTRN DC    X'4020202020202120'          8 bytes of pattern\nAFCHKDSP DS    0H\n* - - - ->  Chunk Size Message - - - ->   above\n         TM    READFLAG,X'01'        Read Only run?\n         BO    NOAWSOUT              Yes. Don't OPEN AWSOUT.\n         OPEN  (AWSOUT,(OUTPUT))\nNOAWSOUT DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (TAPIN,(INPUT))\n*--->>\n         MVC   MSGLINE1,MSGLINE1-1   Clear optional\n         MVC   MSGLINE2,MSGLINE2-1      message lines\nREADIDRC DS    0H\n         TM    READFLAG,X'01'        READ only run?\n         BZ    IDRCMSG\nREADMSG  DS    0H\n         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'\nIDRCMSG  DS    0H\n         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?\n         BZ    ENDEXMSG\n         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'\nENDEXMSG DS    0H\n*--->>\nTRACERPT DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE      Blank Line\n         PUT   SYSTRACE,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    TRACENOI\n         PUT   SYSTRACE,MSGLINE2     IDRC remove message\nTRACENOI DS    0H\n         PUT   SYSTRACE,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\nTRACDESC DS    0H\n         PUT   SYSTRACE,MESSAGE8\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE5\n         PUT   SYSTRACE,MESSAGE6\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAG11\n         PUT   SYSTRACE,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE7\n*--->>\nMOVEDRPT DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE      Blank Line\n         PUT   SYSMOVED,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    MOVEDNOI\n         PUT   SYSMOVED,MSGLINE2     IDRC remove message\nMOVEDNOI DS    0H\n         PUT   SYSMOVED,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAGE9\n         PUT   SYSMOVED,MESSAG10\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAG11\n         PUT   SYSMOVED,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n*--->>\nFILESRPT DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE      Blank Line\n         PUT   SYSFILES,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    FILESNOI\n         PUT   SYSFILES,MSGLINE2     IDRC remove message\nFILESNOI DS    0H\n         PUT   SYSFILES,MESSAG14\n*--->>\nNOSYSFIL DS    0H\n* ----------------------------------------------------------------- *\n*   Now do the same for SYSPRINT report, which is always there.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         PUT   SYSPRINT,OUTLINE      Blank Line\n         PUT   SYSPRINT,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    PRINTNOI\n         PUT   SYSPRINT,MSGLINE2     IDRC remove message\nPRINTNOI DS    0H\n         PUT   SYSPRINT,MESSAG14\n*--->>\n*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.\n*        BAL   R9,FLDIMAGE\n*--->>\n* ----------------------------------------------------------------- *\nTAPEREAD DS    0H                      READ a new tape block.\n* ----------------------------------------------------------------- *\n*   You come here every time you do a tape READ.\n* ----------------------------------------------------------------- *\n         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks\n         BAL   R9,READBLOK             Read a block of data\n         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?\n         BO    MAINTPMK                Yes. Take appropriate action.\n* --- >\n         L     R1,CURRBFUL             Fullword number of bytes read\n         C     R1,CHNKSIZE             Bigger than chunk size?\n         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.\n         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.\n         NI    BUFINISH,FF-X'01'       Turn \"buffer finished\" flag off\n         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer\n         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved\n         B     AFTRCHNK                Jump over other alternative\nNOCHUNKS DS    0H\n         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.\n         OI    BUFINISH,X'01'          Buffer is finished in one shot.\n         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total\n         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total\n* --- >                                Label check if HDR - below\nAFTRCHNK DS    0H\n         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?\n         BNE   MAINNOTL                No. Can't be a label.\n         BAL   R9,LABELCHK             Check for labels and their kind.\n         TM    ISLBLFLG,X'01'          Is this record a label?\n         BZ    MAINNOTL                No. Bypass flag setting.\n         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?\n         BZ    MAINNOTH                Neither. Check if EOF or EOV.\n         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.\nMAINNOTH DS    0H\n         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?\n         BZ    MAINNOTL                No. Don't turn off flag.\n         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.\nMAINNOTL DS    0H\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW\n** -->              stuff below is only done per READ.\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,CURRBFUL          Load Current READ Byte Count\n         LA    R3,DBOUTF            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUT             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n** -->              stuff above is only done per READ.\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE\n* --- >                                Label check if HDR - above\n**-------------------------------------------------------------------**\nFOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL\n*                                   THE BUFFER IS EXHAUSTED.\n         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields\n         MVC   FLDECARD,SVENDCRD\n         L     R3,=A(INAREA)           Point to the data buffer\n         ST    R3,FLDBUFFR             Initialize\n         ST    R3,FLDBSTRT                 FLDAREA fields\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n*                                      because we'll have to fold the\n*                                      newly manufactured header.\n**-------------------------------------------------------------------**\nFOLDLOOP DS    0H\n         L     R1,FLDBYTOT          Compare bytes remaining to fold\n         C     R1,CHNKSIZE          To the chunk size.\n         BH    FOLDNCHK             If now less than or equal\n         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off\n         OI    BUFINISH,X'01'       And turn \"buffer finished\" flag on\n         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.\nFOLDNCHK DS    0H\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n         BAL   R9,MAKEHEDR             Create a header with READ info\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER               Point to address of this header\n         ST    R3,FLDBUFFR             Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF             And fold it into FB-80.\n         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA\n         MVC   FLDBYMVD,=F'0'          Initialize bytes folded\n         BAL   R9,FOLDBUFF             And fold it into the output.\n         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block\n** ---------- >>    Record the number of bytes folded - below\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,FLDBYMVD          Load Current folded Byte Count\n         LA    R3,DBOUTFM           Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUTM            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOFLDCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2\n** ---------- >>    Record the number of bytes folded - above\n         TM    CHNKFLAG,X'01'          Are we doing chunks?\n         BZ    TAPEREAD                No. Do another tape read.\n         TM    BUFINISH,X'01'          Have we finished this block?\n         BO    TAPEREAD                Yes. Read another block.\n         B     FOLDLOOP                No. Fold more chunks.\n*\nMAINTPMK DS    0H                   Last read was a T.M.\n         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         BAL   R9,MAKEHEDR          Make a header to show EOF.\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header\n         BAL   R9,REPTFILE          Report Block and Byte Counts\n*--->>\n         MVC   DBOUTF(8),=D'0'      Zero File Byte Count\n         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count\n         ZAP   BLOCKCNT,=P'0'       Zero File Block Count\n*--->>\n         B     TAPEREAD             Read in another tape block.\n*\n* ---------------------------------------------------------------- *\n*          END OF INPUT AWS DATA                                   *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         OI    TPMKFLAG,X'01'       Force Tape Mark indication.\n         BAL   R9,MAKEHEDR          Make EOT header\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\nBREAKLUP DS    0H\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk\n         TM    READFLAG,X'01'       READ only?\n         BO    NOPUT01              Yes. No output to AWSOUT.\n         PUT   AWSOUT,OUTCARD       And write out the last buffer.\n         MVC   OUTCARD(80),LASTLINE Add an extra card of hex zeroes\n         PUT   AWSOUT,OUTCARD       And put it out too.\nNOPUT01  DS    0H\n         AP    FLDOUTCT,=P'1'       Count the record PUT out.\n         AP    FLDOUTCT,=P'1'       Count the extra record of blanks\nWRITSUMM DS    0H\n         BAL   R9,SUMMREPT          Print the summary report.\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\nCLOSEMAL DS    0H                   Close em all.....\n         CLOSE TAPIN\n         TM    READFLAG,X'01'       Is this a READ only run?\n         BO    NOAWSCLS             Can't CLOSE what ain't OPEN.\n         CLOSE AWSOUT\nNOAWSCLS DS    0H\n         CLOSE SYSPRINT\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n*\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nSCNSYSIN DS    0H                 Routine to extract info from SYSIN.\n         ST    R9,SAVER9SC\n* -------------- >>>>>>   Look for SYSIN cards            - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    SCNSYSIE             No. Then can't open it. So get out.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BE    SYSNWVOL              Yes. Go process the new volume.\n         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?\n         BE    SYSCHUNK                    Looks that way.....\n         CLC   =C'READ ',GETSYSIN\n         BE    SYSREAD\n         CLC   =C'IDRCOFF ',GETSYSIN\n         BE    SYSIDRCO\n         B     SYSINLUP              Look for another card.\nSYSNWVOL DS    0H\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         B     SYSINLUP\nSYSCHUNK DS    0H\n         CLI   GETSYSIN+10,C' '  Is the first number value blank?\n         BE    SYSINLUP          Yes. Ignore entire card.\n         CLI   GETSYSIN+10,X'F0' Smaller than zero?\n         BL    SYSINLUP          Yes. Get another card.\n         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?\n         BH    SYSINLUP          Yes. Get another card.\n         OI    FLAGCHNK,X'01'    Show chunk size default was changed.\n         LA    R15,GETSYSIN+10   Now get the number that was coded.\n         LR    R1,R15            Load R1 with beginning of the number.\nSYSCHNUM DS    0H\n         LA    R15,1(,R15)       Bump to next character.\n         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?\n         BH    SYSCHGNM          Yes. Go get the number.\n         CLI   0(R15),C' '       Not end of card. But is it a blank?\n         BE    SYSCHGNM          Yes. Then get the number.\n         B     SYSCHNUM          Not a blank yet. Step up one place.\nSYSCHGNM DS    0H\n         SR    R15,R1            How many digits is the number?\n         BCTR  R15,0             Lower it by one for EXECUTE.\n         EX    R15,PACK          Copy the number to work area.\n         CVB   R0,WORKA          Convert it to a binary number.\n         ST    R0,CHNKSIZE       And store the value for later use.\nSYSCHCLG DS    0H\n         B     SYSINLUP          Go look for another card.\nSYSREAD  DS    0H\n         OI    READFLAG,X'01'\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     SYSINLUP\nSYSIDRCO DS    0H\n         OI    IDRCFLAG,X'01'\n         B     SYSINLUP\nSYSINEND DS    0H                No more cards. Close SYSIN DCB.\n         CLOSE SYSIN\n* -------------- >>>>>>   Look for SYSIN cards            - ABOVE\nSCNSYSIE DS    0H\n         L     R9,SAVER9SC\n         BR    R9\n* - - >\nPACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>\nWORKA    DC    D'0'\n* - - >\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*     Routine to read a block of data from the input tape\n*     and save byte counts from it, to make the AWS headers.\n* ----------------------------------------------------------------- *\nREADBLOK DS    0H\n         ST    R9,SAVER9RB        Save BAL register\n         ST    R2,SAVER2R         Store work registers\n         ST    R3,SAVER3R\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Read\n         WAIT  ECB=INECB          Wait for Read\n         TM    INCSW+4,X'01'      Was TM Read?\n         BO    READTPMK           Yes\n         CLI   INECB,X'7F'        Did Read complete normally?\n         BNE   INERR              No -- error\n         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.\n         AP    BLOCKCNT,=P'1'\n         AP    BLOCKTOT,=P'1'\n         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read\n         XC    FULLWORK,FULLWORK   Clear area completely\n         MVC   HALFWORK(2),INCCW+6   Read length\n         L     R2,FULLWORK           Load R2 with full low order\n         MVC   HALFWORK(2),INCSW+6   Residual byte count\n         L     R3,FULLWORK           Load R3 with full low order\n         SR    R2,R3              R2=Actual length read\n         STH   R2,BYTESCOP        Save quantity of bytes copied\n         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block\n         NI    ISLBLFLG,X'FF'-X'01'  Turn off \"IS LABEL\" flag\n         OI    NWBLKFLG,X'01'        Turn on \"new block\" flag\n         B     READNOTM           This READ was not a Tape Mark\n*\nREADTPMK DS    0H                 This READ was a Tape Mark\n         TM    TPMKFLAG,X'01'     Check if there was another TM before\n         BZ    READTFST           No. First one.\n         OI    TPMKFLAG,X'02'     If two in a row, flag that situation\nREADTFST DS    0H\n         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?\n*\n* --- >                           Null SL file is not EOT - below\n         BNO   NOFIN1               Not 2 T.M. in a row. Go on.\n         TM    FLAGHDRL,X'01'       Test if HDR label was last seen\n         BO    NOFIN0               Yes. Must be null SL file.\n         B     FIN                  Otherwise, valid 2 TMs and EOT.\nNOFIN0   DS    0H\n         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.\nNOFIN1   DS    0H\n* --- >                           Null SL file is not EOT - above\n*\n         AP    FILCOUNT,=P'1'     Add 1 to File Count.\n         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.\n         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.\nREADNOTM DS    0H\n* ---->     for the trace            All READ results should come here\n         MVC   LINE,LINE-1           Clear output line\n         MVC   LINE+1(16),READTRMS   Put in Read Trace message\n         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?\n         BZ    ITSABLOC              No. Mark trace as for a block.\n         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.\n         B     ITSATPMK              And go farther.\nITSABLOC DS    0H\n         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block\nITSATPMK DS    0H\n         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ\n         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header\n         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header\n         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag\n         HEX   LINE+40,6,HEADER      Show the Header last constructed\n         HEX   LINE+56,30,INAREA     Show first 20 bytes of Input Area\n         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?\n         BNO   NOREADT1              No. Can't print trace line.\n         PUT   SYSTRACE,LINE\nNOREADT1 DS    0H                    Trace is finished.\n* ---->     for the trace\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R\n         B     READBEND           and exit normally.\n* -----\nINERR    DS    0H                 READ error on input tape\n         MVC   LINE,LINE-1        Clear print line\n         TM    INCSW+4,X'02'      Unit Check?\n         BZ    INERR1             No - Assume Data Check\n         MVC   LINE(133),INEQC    Set Error Message\n         B     INERR2             Continue\nINERR1   MVC   LINE(133),INDCK    Set Error Message\nINERR2   PUT   SYSPRINT,LINE      Write Error Message\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R         Rewind the tape, and exit.\n         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Rewind and Unload\n         WAIT  ECB=INECB          Wait for Rewind and Unload\n         B     WRITSUMM           Write summary of what was done,\n*                                  and get out of the program.\nREADBEND DS    0H\n         L     R9,SAVER9RB        Restore BAL register\n         BR    R9\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nMAKEHEDR DS    0H\n         ST    R9,SAVER9MH\n* ----------------------------------------------------------------- *\n*     We are forming the new header in the field HEADER.\n*     We assume that the TAPEREAD subroutine was executed first.\n*     We assume that the FLDAREA was previously saved to SAVAREA.\n* ----------------------------------------------------------------- *\n         MVC   HEADER(6),=XL6'00'      Start fresh.\n         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header\n         MVC   HDRNSTOR(1),SAVBYTES+3     Reverse\n         MVC   HDRNSTOR+1(1),SAVBYTES+2      bytes\n         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot\nMAKEWHAT DS    0H                      Manufacture the proper hdr flags\n         TM    TPMKFLAG,X'01'          Has a tape mark been read?\n         BO    MAKE40                  First test. Make a X'40' header\n         TM    NWBLKFLG,X'01'          First chunk of current block?\n         BO    MAKE80                  Yes. Turn on X'80' bit.\n         TM    BUFINISH,X'01'          Last chunk of current block?\n         BO    MAKE20                  Yes. Turn on X'20' bit.\n         B     MAKE00                  No. Don't turn on any flag bits.\nMAKE80   DS    0H\n         OI    HDRFLAG1,X'80'          Turn on X'80'\n         B     MAKE20                  And see if X'20' also, or not.\nMAKE00   DS    0H                      No HDRFLAG1 bits to be turned on\n         B     MAKEHDEN                And just get out.\nMAKE20   DS    0H\n         TM    BUFINISH,X'01'          Test again for last chunk.\n         BZ    MAKEHDEN                It isn't, so only X'80' is on.\n         OI    HDRFLAG1,X'20'          It is. So turn on X'20'.\n         B     MAKEHDEN\nMAKE40   DS    0H                      Tape mark has been read.\n         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.\n         MVI   HDRFLAG1,X'40'          HDRFLAG1 has to be X'40'\nMAKEHDEN DS    0H\n         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN\n         AP    OUTHDRS,=P'1'           Count this header we've made.\n*----------------------------------------------------------------- *\n*   Now that we've made a header, we count how many of each type.\n*----------------------------------------------------------------- *\nKINDAHDR DS    0H\n         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?\n         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK\n         AP    OUTTYPE3,=P'1'         YES. COUNT THIS TYPE\n         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE\nKCHKBEG  DS    0H\n         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?\n         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.\n         AP    OUTTYPE1,=P'1'         YES. COUNT THIS TYPE\nKCHKEND  DS    0H\n         TM    HDRFLAG1,X'20'         END OF BLOCK?\n         BNO   KINDAH40               NO. CHECK IF END OF FILE\n         AP    OUTTYPE2,=P'1'         YES. COUNT THIS TYPE\nKINDAHA0 DS    0H\n         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?\n         BNE   KINDAH40               NO. TEST FOR EOF HEADER.\n         AP    OUTTYPE5,=P'1'         YES. COUNT IT FOR REPORTING.\n         B     KINDAHEN               AND DON'T TEST MORE BITS.\nKINDAH40 DS    0H\n         TM    HDRFLAG1,X'40'         END OF FILE HEADER?\n         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.\n         AP    OUTTYPE4,=P'1'         YES. COUNT THIS TYPE\n*\nKINDAHEN DS    0H\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE\n         MVC   OUTLINE+2(4),=C'hdr:'\n         HEX   OUTLINE+8,6,HEADER     FLDAREA at MAKEHEDR time display\n         HEX   OUTLINE+28,4,FLDSCARD                            .\n         HEX   OUTLINE+38,4,FLDECARD                            .\n         HEX   OUTLINE+48,4,FLDOFFST                            .\n         HEX   OUTLINE+58,4,FLDBYTES                            .\n         HEX   OUTLINE+68,4,FLDBYTOT                            .\n         HEX   OUTLINE+78,4,FLDBYMVD                            .\n         HEX   OUTLINE+88,4,FLDBUFFR                            .\n         HEX   OUTLINE+98,4,FLDBSTRT                            .\n         HEX   OUTLINE+108,7,FLDOUTCT                           .\n         HEX   OUTLINE+124,1,FLDREADF\n         HEX   OUTLINE+22,1,HDRFLAG1                            .\n         PUT   SYSTRACE,OUTLINE\nNOSYSTR1 DS    0H\nMAKEHEND DS    0H\n         L     R9,SAVER9MH\n         BR    R9\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*                                                           *\n*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *\n*                                                           *\n*    All FLDAREA field required for call have to be         *\n*    filled in:                                             *\n*                                                           *\n*    FLDSCARD - Initialized to OUTCARD at beg of program    *\n*    FLDECARD - Initialized to OUTCARD+80                   *\n*    FLDOFFST - Initialized to 0, updated by each call      *\n*    FLDBYTES - Set before each call                        *\n*    FLDBYTOT - Set before each call                        *\n*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *\n*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *\n*    FLDBSTRT - Start of input buffer                       *\n*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *\n*    FLDREADF - READFLAG, copied into FLDAREA control blk   *\n*                                                           *\n* --------------------------------------------------------- *\nFOLDBUFF DS    0H\n         ST    R9,SAVER9FB              Save BAL register\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call\n*        BAL   R9,FLDIMAGE\n         LA    R1,FLDAREA\n         L     R15,=V(FOLDEM)           Entry point of FOLDEM program\n         BALR  R14,R15                  Call it.\n*                                       Copy back FLDAREA from FOLDEM\n         ST    R1,NEWFLDA               Save new FLDAREA address\n         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call\n*        BAL   R9,FLDIMAGE\nFOLDBUFE DS    0H\n         L     R9,SAVER9FB              Restore BAL register\n         BR    R9                       Return to caller\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         ST    R9,SAVER9FI\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         L     R9,SAVER9FI\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE\n         ST    R9,SAVER9AD         Save BAL register\n         STM   R4,R5,SAVEADDC      Save work registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         LM    R4,R5,SAVEADDC      Restore work registers\nADDCOUNE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9AD         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LB          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   INAREA(3),=C'UHL'    This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRCV             NO. SKIP ROUTINE.\n         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRCV DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  YES. DON'T CHANGE.\n         LA    R1,INAREA                 Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\n         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.\n         TM    FLAGSYST,X'02'\n         BZ    NCHGMOVD\n         PUT   SYSMOVED,MESSAG13\nNCHGMOVD DS    0H\n         TM    FLAGSYST,X'04'            SYSFILES here?\n         BZ    NCHGFILE                  Nope. Skip a PUT to it.\n         PUT   SYSFILES,MESSAG13         VOLSER overridden message.\n         MVC   OUTLINE,OUTLINE-1         Blank line to separate\n         PUT   SYSFILES,OUTLINE             from the rest of output.\nNCHGFILE DS    0H\nNOCHGVOL DS    0H                        Kludge extra blank like\n         TM    FLAGSYST,X'04'            Is SYSFILES here?\n         BZ    KLUDGE01                  Nope. No PUTs to it.\n         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?\n         BNE   KLUDGE01                  Is overridden, no extra blank.\n         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank\n         PUT   SYSFILES,OUTLINE\nKLUDGE01 DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRH2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRH2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRH2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRF2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRF2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRF2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRV2             NO. SKIP ROUTINE.           \\\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRV2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRV2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\nLABCHEND DS    0H                   Return to caller\n         L     R9,SAVER9LB          Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SR               Save BAL Register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG04\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG05\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE3   MIDDLE OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE4   END OF FILE HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG07\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE5   X'A0' HEADERS - BEG and END\n         PUT   SYSPRINT,OUTLINE\n* >---->                                 Display tape total counts\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTMH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST\n         L     R4,DBOUTML                LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD               AND ADD IT IN\n         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06       Total bytes read for data\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\nNOSUMM05 DS    0H\n* >---->\nSUMMREND DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SR         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n*----------->>\n         ST    R9,SAVER9RF\n*--->                   Block counts first  -  below\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n* >---->\n*--->                   Block counts first  -  above\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG01\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFMH        Bytes folded counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n* >--->\n         TM    ISLBLFLG,X'01'\n         BO    DISLABLS\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Data bytes written cumulative to here\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),DATDISPL\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),LABDISPL\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFH         Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         CLC   DBOUTF(8),DBOUTFM\n         BE    RIGHTBYT\n         MVI   CNTLINE+72,C'*'\nRIGHTBYT DS    0H\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBOUTH          Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\n*----------->>\nREPTFEND DS    0H\n         L     R9,SAVER9RF\n         BR    R9\n         EJECT\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\n*              read,addr of data,flags,64K bytes\nRUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW\n         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW\nINCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW\nINECB    DC    F'0'\nINIOB    DC    X'02000000'\n         DC    A(INECB)\nINCSW    DC    2F'0'\nINCCWPT  DC    A(INCCW)\nINDCBPT  DC    A(TAPIN)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            Padding\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY AWSOUT\nAWSOUT   DCB   DDNAME=AWSOUT,MACRF=PM,DSORG=PS,LRECL=80\nTAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X\n               EODAD=SYSINEND\n         DC    CL8' '\nFF       EQU   X'FF'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL6                     BLOCK HEADER\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRFLAG1 DC    X'00'                    FLAGS BYTE 1...\nHDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD\nHDRF1TMK EQU   X'40'                    ...TAPE MARK\nHDRF1EOR EQU   X'20'                    ...END OF RECORD\nHDRFLAG2 DC    X'00'                    FLAGS BYTE 2\n*\n         DC    XL80'00'                 PADDING\nOUTHEADR DC    XL6'00'\n* ----------------------------------------------------------------- *\n         DC    XL12'00'                 PADDING\nHALFZERO DC    XL2'00'\n         DC    XL12'00'                 PADDING\nHDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF\nHDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF\n         DC    XL12'00'                 PADDING\nBYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nCURRBFUL DS    0F\n         DC    H'0'\nCURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nLASTBFUL DS    0F\n         DC    H'0'\nLASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT\nPARTBFUL DS    0F\n         DC    H'0'\nPARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT\nZEROCARD DC    80X'00'\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nREADFLAG DC    X'00'         This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nNWBLKFLG DC    X'00'         We have just read a new block.\n*              X'01'         Turned off after first chunk write.\n* ---------- *\nIDRCFLAG DC    X'00'         This run is \"IDRC Fix\"  ?\n*              X'01'         Turn off IDRC indicator\n* ---------- *\nFLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED\n*              X'01'          CHUNK SIZE IS NOT BLANK\n* ---------- *\nFLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE\n*              X'01'          //SYSTRACE DD IS THERE\n*              X'02'          //SYSMOVED DD IS THERE\n*              X'04'          //SYSFILES DD IS THERE\n*              X'08'          //SYSIN    DD IS THERE\n* ---------- *\nCHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?\n*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE\n* ---------- *\nBUFINISH DC    X'00'          Have we finished folding entire buffer?\n*              X'01'          Yes. We are now finishing the buffer.\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL\n*              X'00'          DATA IS NOT A LABEL\n*              X'01'          DATA IS A LABEL\n* ---------- *\nTPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark\n*              X'01'          We just read a Tape Mark\n*              X'02'          We previously read a Tape Mark\n* ---------- *\nFLAGHDRL DC    X'00'          Header label flag - Last label was a hdr\n*              X'01'          EOT HEADER is following a HDR1 or HDR2\n* ---------- *\n* -------------------------------------------- *\nFULLWORK DS    0F\nFULLHIGH DC    H'0'\nHALFWORK DC    H'0'                HALFWORD WORK AREA\n         DC    2F'0'               Padding\nFOLDBREG DS    0F                  Fullword - no of bytes to fold\nFOLDHIGH DC    XL2'00'             High order - should be zeros\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDB       DC    D'0'          DOUBLE-WORD WORK AREA              \\\nDB2      DC    0D'0',PL8'0'  DOUBLE-WORD WORK AREA              \\\n*  TABLE OF DAYS IN PRIOR MONTH                                 \\\nDATETABL DC   H'0,31,59,90,120,151,181,212,243,273,304,334,365' \\\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHNKSIZE DC    F'65535'            Default is maximum halfword\nLASTLINE DS    0CL80\nLASTHX00 DC    80X'00'\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nDWORD    DC    D'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nOUTHDRS  DC    PL7'0'\nOUTTYPE1 DC    PL7'0'\nOUTTYPE2 DC    PL7'0'\nOUTTYPE3 DC    PL7'0'\nOUTTYPE4 DC    PL7'0'\nOUTTYPE5 DC    PL7'0'\nFILCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nTPMKCNT  DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL38\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Labels'\nDATDISPL DS    0CL38\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data  '\n*\nSVBEGCRD DS    F\nSVENDCRD DS    F\nSVBFAREA DS    F                Address of input buffer\n*\nSAVER2R  DS    F                Save work regs during tape read.\nSAVER3R  DS    F                Save work regs during tape read.\nSAVER4B  DS    F                Register Save for HEX routine\nSAVER4Q  DS    F                Register Save for byte count reperting\nSAVEFOLD DS    6F               Register Save for FOLDEM routine\nSAVEADDC DS    3F               Register Save for ADDCOUNT routine\nSAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE\nSAVER9AD DS    F                Register Save for ADDCOUNT routine\nSAVER9RB DS    F                Register Save for READBLOK routine\nSAVER9RF DS    F                Register Save for REPTFILE routine\nSAVER9LB DS    F                Register Save for LABELCHK routine\nSAVER9SR DS    F                Register Save for SUMMREPT routine\nSAVER9FB DS    F                Register Save for FOLDBUFF routine\nSAVER9FI DS    F                Register Save for FLDIMAGE routine\nSAVER9SC DS    F                Register Save for SCNSYSIN routine\nSAVER9MH DS    F                Register Save for MAKEHEDR routine\nNEWFLDA  DS    F\nHDRSIZE  DC    F'6'             SIZE OF A HEADER\nSVBEGDAT DS    F\n*  -----------------\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*  -----------------     JFCB if we'll need RDJFCB later - not used now\nJFCB1    DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\n         DC    C' '\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '\nPRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS    : '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '\nCTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '\nCTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '\nCTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '\nCTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '\nCTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '\nCTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '\nCTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2DISK - REAL TAPE TO FB-80 AWS CONVERSION PROG-\n               RAM  '\nMESSAGE2 DC    CL133'1VTT2DISK  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE3 DC    CL133'1VTT2DISK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-\n               R REPORT  '\nMESSAGE4 DC    CL133'1VTT2DISK - TAPE TO AWS FILE REPORT - READ AND FOL-\n               D STATS  '\nMESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-\n               '\nMESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-\n               '\nMESSAGE7 DS    0CL133\n         DC    CL8'  hdr:  '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'FLDSCARD'\n         DC    CL10'FLDECARD'\n         DC    CL10'FLDOFFST'\n         DC    CL10'FLDBYTES'\n         DC    CL10'FLDBYTOT'\n         DC    CL10'FLDBYMVD'\n         DC    CL10'FLDBUFFR'\n         DC    CL10'FLDBSTRT'\n         DC    CL14'FLDINRCD'\n         DC    CL11' '\nMESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-\n                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-\n               DE. '\nMESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2DISK, THE SYSMOV-\n               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-\n                 '\nMESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-\n               EPORT.  BOTH \"TAPE READ\" AND \"FOLD DATA\" ARE AVAILABLE T-\n               HERE.'\nMESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -\n               HAVE SOURCE CODE, THEN UNCOMMENT THE \"BEFCALL-\" AND \"AFT-\n               CALL-\" '\nMESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-\n               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -\n                    '\nMESSAG13 DC    CL133'    VOLSER Overridden to:    '\nMESSAG14 DC    CL133'    Chunk Size is set to:    '\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    OFFSET ERROR           '\nINEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '\n         DC    C'TERMINATED '\n         DC    76C'*'\nINDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '\n         DC    82C'*'\n*  -----------------            Trace Message Texts\nREADTRMS DC    CL16'READ TRACE:     '\nFOLDTRMS DC    CL16'FOLD TRACE:     '\nMHDRTRMS DC    CL16'MAKEHEDR TRACE: '\nOSETTRMS DC    CL16'OFFSET TRACE:   '\nBBLKTRMS DC    CL16'BLOCK TRACE:    '\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nLINE     DC    CL133' '           For error messages\n         DC    C' '\nPRTLINE  DC    CL133' '\n         DC    C' '\nMSGLINE1 DC    CL133' '           For READ only message\n         DC    C' '\nMSGLINE2 DC    CL133' '           For IDRC remove message\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\nSAVEHDR  DC    XL6'000000000000'\nEOTMARK  DC    XL6'000000004000'\n* - - - - >\n*\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\n* - - - - >\n*         Saved Copy of FLDAREA Control Block\n* - - - - >\n*\nSAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nSAVSCARD DC    F'0'         Start address of 80-byte card\nSAVECARD DC    F'0'         End address of 80-byte card\nSAVOFFST DC    F'0'         OFFSET of data in the card\nSAVBYTES DC    F'0'         Number of bytes to be folded now\nSAVBYTOT DC    F'0'         Batch total of bytes left to move\nSAVBYMVD DC    F'0'         Number of bytes folded now\nSAVBUFFR DC    F'0'         Current data start address\nSAVBSTRT DC    F'0'         Original start data address\nSAVOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nSAVREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nSAVLENTH EQU   *-SAVAREA\n*\n* - - - - >\n*    ------------------------ >   Byte Count Save Areas - below\n*\n*                          -- These are doubleword counters --\n*\nDBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ\nDBOUTFH  DC    F'0'\nDBOUTFL  DC    F'0'\nDBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED\nDBOUTFMH DC    F'0'\nDBOUTFML DC    F'0'\nDBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ\nDBOUTH   DC    F'0'\nDBOUTL   DC    F'0'\nDBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED\nDBOUTMH  DC    F'0'\nDBOUTML  DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\n         DC    CL8' '      Extra padding for safety\n*\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n         DC    F'0'               Align, just for the heck of it\nGETSYSIN DC    CL80' '\nOUTCARDP DC    XL80'00'           Previous card-image read\nOUTCARD  DC    XL80'00'           Current  card-image read\nOUTCAEND EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         END\n./       ADD   NAME=FOLDEM\n   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'\n*  ---------------------------------------------------------------  *\n*\n*   AUTHOR:       Sam Golob\n*\n*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,\n*                 subject to express permissions from the author\n*                 to use this software.  This software is part\n*                 of VTTS (Virtual Tape Transportation System).\n*\n*                 Permission is granted by the author for all\n*                 parts of the VTTS package which are distributed\n*                 on the CBT Tape collection, to be used by\n*                 anyone for their own use, but not for resale\n*                 or for reincorporation within commercial code.\n*\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    FOLDEM                                            *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating an      *\n*      AWS-format disk file from a real tape file.  The disk        *\n*      file is data that has been folded over from a buffer,        *\n*      into an FB-80 dataset.                                       *\n*                                                                   *\n*      This program takes buffer data and folds it into FB-80       *\n*      data, starting from a given buffer address, for a given      *\n*      number of bytes.  The data is folded into an 80-byte         *\n*      workarea starting from a given OFFSET address (+0 to +79)    *\n*      into the workarea.  When the workarea has been completely    *\n*      filled and more data is to be written, a PUT is done to      *\n*      write out the data from the 80-byte workarea, and then       *\n*      the workarea is cleared with binary zeros before any         *\n*      additional data is written to it.  An incompletely filled    *\n*      workarea is not written out, and the same is true if the     *\n*      workarea is full but no more data is to be written out.      *\n*      So in that case, the location of the workarea is returned    *\n*      to the caller in field FLDSCARD, and it is the caller's      *\n*      responsibility to do the PUT for the last card.              *\n*                                                                   *\n*  INPUTS and OUTPUTS:                                              *\n*                                                                   *\n*      This program is driven by a control block called FLDAREA,    *\n*      which is updated by both this program and by the caller.     *\n*      See below for more details.                                  *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called AWSOUT, which receives the output       *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do PUTs to AWSOUT, and if necessary, it needs       *\n*      to write messages to SYSPRINT.  Therefore the caller has     *\n*      to provide ENTRY AWSOUT and ENTRY SYSPRINT statements in     *\n*      front of its AWSOUT and SYSPRINT DCBs, respectively.         *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      FLDAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      FLDAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the caller's copy of FLDAREA, and upon return,      *\n*      R1 is pointed to the updated copy of FLDAREA in this         *\n*      subroutine.  So the caller has to copy it back over its      *\n*      own instance of FLDAREA after the return.                    *\n*                                                                   *\n*      The caller does one tape read, or read of data into a        *\n*      buffer.  From the number of bytes read, and possibly from    *\n*      the given chunk size also, the caller will construct an      *\n*      AWS header which will determine how many bytes should be     *\n*      folded into the FB-80 disk dataset.  This AWS header is      *\n*      also folded in by a call to this program, and then the       *\n*      tape data is folded in afterward, for the number of bytes    *\n*      required either by the chunk size or by the block size.      *\n*                                                                   *\n*      This program does one or more PUTs into the FB-80 file,      *\n*      until the request for the number of bytes to be folded,      *\n*      is satisfied.  A PUT is done whenever the FB-80 work area    *\n*      has been filled.  At the end of the fold operation, the new  *\n*      OFFSET into the FB-80 workarea (that has not yet been        *\n*      written out to disk), the number of bytes that have been     *\n*      folded, and the projected start of the next data to be       *\n*      folded, are returned in the fields of the FLDAREA control    *\n*      block.                                                       *\n*                                                                   *\n*      The following is the layout of the FLDAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *\n*      *                         ------ ---- ------- -----          *\n*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *\n*  --> FLDECARD DC    F'0'       End address of 80-byte card        *\n*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *\n*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *\n*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *\n*      FLDBYMVD DC    F'0'       Number of bytes folded now         *\n*  --> FLDBUFFR DC    F'0'       Current data start address         *\n*  --> FLDBSTRT DC    F'0'       Original start data address        *\n*      FLDOUTCT DC    PL7'0'     Number of PUTs for AWSOUT records  *\n*  --> FLDREADF DC    X'00'      This run is \"READ ONLY\"  ?         *\n*      *              X'01'      Yes, read only. (Copied from the   *\n*                                READFLAG byte in the caller.)      *\n*      FLDLENTH EQU   *-FLDAREA                                     *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      FLDBUFFR and FLDOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the input data      *\n*      and output data positions, respectively, that are just       *\n*      after the moved data, to anticipate the next call, so as     *\n*      to be able to move more data.  FLDBSTRT preserves the        *\n*      very beginning address of the input buffer, whereas          *\n*      FLDBUFFR is a place somewhere within the buffer, which       *\n*      is the start from where the new data is expected to be       *\n*      moved.                                                       *\n*                                                                   *\n*      A new field, FLDBYTOT, makes it easier to create chunked     *\n*      AWS-format tape files, when the chunksize is less than       *\n*      the blocksize.  This field originally (after a block is      *\n*      read into the buffer from the tape) contains the number      *\n*      of bytes in the entire block.  After each chunk of data      *\n*      is written, this field gets decremented by the number of     *\n*      bytes in the chunk just written.                             *\n*                                                                   *\n*      Since both the caller and this program do PUT operations     *\n*      to the output FB-80 file, the count of the number of PUTs    *\n*      done, FLDOUTCT, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n.* ---------------------------------------------------------------  *\n.*   This macro is used to display hex values in a printed report.\n.* ---------------------------------------------------------------  *\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\nFOLDEM   CSECT ,                                                \\\n         YREGS\nFOLDEM   AMODE 24\nFOLDEM   RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'FOLDEM'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING FOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,AWSOUTV            AWSOUT   DCB address in caller\n         ST    R0,AWOUTDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to fold buffer data into an FB-80 file, starting at     *\n*   a given location in the buffer, for a certain number of bytes,  *\n*   and starting at a given OFFSET in the 80-byte workarea to       *\n*   which the buffer data will be written.  When the 80-byte        *\n*   workarea is filled up, a PUT is done to AWSOUT, and the         *\n*   workarea is cleared with binary zeros for more data to be       *\n*   written.                                                        *\n*                                                                   *\n*   Input:   FLDAREA fields are all supplied by the calling         *\n*            program, except for FLDBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            caller's copy of FLDAREA is pointed to by Register 1.  *\n*                                                                   *\n*            The buffer area containing the data to be folded       *\n*            is supplied by the calling program, as well as the     *\n*            number of bytes that is expected to be folded.         *\n*                                                                   *\n*   Output:  Data from the buffer will be moved into the 80-byte    *\n*            workarea until the workarea is filled.  When the       *\n*            workarea is filled, a PUT will be done to AWSOUT,      *\n*            and the workarea is cleared to X'00's to make room     *\n*            for more data, when more data is to be written.        *\n*                                                                   *\n*            Ending OFFSET into the 80-byte workarea, pointing to   *\n*            just after the data which has been moved, is returned  *\n*            in the FLDOFFST field.  Upon return to the caller,     *\n*            the FLDBUFFR field is updated to point to the place    *\n*            in the buffer just after the data which has been       *\n*            moved.  The FLDBSTRT field always should point to the  *\n*            beginning of the data buffer, but this is at the       *\n*            discretion of the calling program.                     *\n*                                                                   *\n*            A count of bytes actually moved from the buffer to     *\n*            the 80-byte workarea (and written out by PUTs to the   *\n*            AWSOUT DD name as is necessary) is calculated by this  *\n*            program and returned in the FLDBYMVD field.  Upon      *\n*            return, the number in the FLDBYMVD field should match  *\n*            the number in the FLDBYTES field.                      *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nFOLDIT   DS    0H\n         L     R1,SAVEPARM          Load address of caller's FLDAREA\n         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA\n         USING FLDBLOCK,R2\n         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours\n* - - - - - - - - - -      Load the buffer quantities\n         L     R7,FLDBUFFR          Initialize start of buffer data\n         L     R8,FLDBYTES          Bytes to be moved\n         AR    R8,R7                Add in start buffer address\n         ST    R8,HYPOENDB          Hypothetical end-of-buffer address\n*                                   which is probably the real\n*                                   end-of-data to be moved.\n* - - - - - - - - - -      Load the card quantities\n         MVC   SAVEBEGC,FLDSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,FLDECARD    Save \"end of card\" address\n         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,FLDSCARD          Point to beginning of card\n         A     R7,FLDOFFST          Add OFFSET to start of output\n         ST    R7,SAVEBEGO          Save where output starts\n         L     R8,SAVEBEGO          Copy beg of output address\n         A     R8,FLDBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n         ST    R8,HYPOENDC          Store hypothetical card end address\n*                                   (This may be way past end of card.)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is to within the current card.        *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.  So we have to do     *\n*              iterations.                                        *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         L     R7,SAVEBEGO          Beginning of CARD data\n         L     R8,HYPOENDC          Hypothetical end of CARD data\n         L     R3,FLDBUFFR          Prime R3 with start of buffer data\n         C     R8,SAVEENDC          Is R8 past the end-of-card?\n         BH    LOOPMORE             Yes. Do multiple moves and PUTs.\nLOOPSHRT DS    0H                   No. Do the one move only.\n         LR    R6,R8                Get byte count to move NOW.\n         SR    R6,R7                Bytes to move from buffer to card\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data from buffer to card.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total bytes moved.\n         ST    R1,FLDBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,FLDBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET -\n         S     R6,FLDSCARD          Subtract beginning of card address\n         ST    R6,FLDOFFST          Store the result as new OFFSET\n* -- >\nLOOPTS50 DS    0H\n*                                   If OFFSET > X'4F', card is complete\n         C     R6,=F'80'            Is the new offset exactly X'50'?\n         BNE   LOOPNT50             No. Then current card not complete.\n*                                   Yes. Then PUT out card and init it.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT001             Yes. Can't PUT to AWSOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT001 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n         XR    R6,R6                Clear R6\n         ST    R6,FLDOFFST          New offset is 0, not X'50'\nLOOPNT50 DS    0H\n* -- >\n         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT\n         S     R1,FLDBYMVD          And subtract bytes already moved\n         ST    R1,FLDBYTOT          To show new total buffer byte count\n*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,FLDBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Test if past end of buffer\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,FLDBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT002             Yes. Then don't produce AWSOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT002 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE CALLER\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of FLDAREA in caller\n         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nFLDBLOCK CSECT\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\nFOLDEM   CSECT\nWORKAREA DS    CL80                 Card image work area\n         DC    CL4' '               Padding\n         DC    C' '\nLINE     DC    CL133' '             Output line\n         DC    C' '\nLINE2    DC    CL133' '             Second output line if needed\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGO DC    F'0'                 Save beg address of card output\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address\nHYPOENDC DC    F'0'                 Hypothetical end address after card\nHYPOENDB DC    F'0'                 Calculated end of buffer address\nSYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB\nAWSOUTV  DC    V(AWSOUT)            Address of AWSOUT DCB\nSYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here\nAWOUTDCB DC    F'0'                 AWSOUT DCB address stored here\nSAVER10  DC    F'0'\n         END\n//C.SYSIN  DD  *\n* TESTPGM: VTT2TAPE UNFOLDEM\nTESTPGM: VTT2DISK FOLDEM\n//G.SYSPRINT DD SYSOUT=*\n//G.SYSUDUMP DD SYSOUT=*\n//TAPIN    DD  DISP=OLD,UNIT=480,VOL=SER=EXHDTR,\n//             LABEL=(1,BLP,EXPDT=98000)\n//AWSOUT   DD  DSN=&&DUMP,\n//             DISP=(NEW,PASS),UNIT=SYSDA,\n//             SPACE=(CYL,(30,30),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000)\n//AWSIN    DD  DISP=SHR,DSN=GERHARD.MVS.SZAP.HET\n//TAPOUT   DD  DISP=(,PASS),DSN=&&TEMP,\n//             UNIT=SYSDA,SPACE=(CYL,(1,1))\n//*\n//       EXEC  PGM=PRINTALL,PARM='100,RD'\n//SYSPRINT DD  SYSOUT=*\n//SYSUT2   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSUT1   DD  DISP=(OLD,DELETE),DSN=&&DUMP\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRIPPAD": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x05\\x01\\x0f\\x01\\x05\\x01\\x0f\\x15\\x07\\x00L\\x00L\\x00\\x00\\xe2\\xf1\\xf1\\xf7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-01-10T00:00:00", "modifydate": "2005-01-10T15:07:43", "lines": 76, "newlines": 76, "modlines": 0, "user": "S117"}, "text": "/* Strip VTT padding bytes */\n\n#include <fcntl.h>\n#include <errno.h>\n#include <unistd.h>\n\nint\nmain( int argc, char *argv\u00dd\u00a8 )\n{\n    int fd = -1;\n    int rc = 1;\n    int i;\n    off_t off;\n    char rec\u00dd 80 \u00a8;\n\n    if( argc != 2 )\n    {\n        printf( \"You need to specify a filename\\n\" );\n        goto done;\n    }\n\n    fd = open( argv\u00dd 1 \u00a8, O_RDWR );\n    if( fd == -1 )\n    {\n        printf( \"Couldn't open %s: %s\\n\", argv\u00dd 1 \u00a8, strerror( errno ) );\n        goto done;\n    }\n\n    off = lseek( fd, -80, SEEK_END );\n    if( off == -1 )\n    {\n        printf( \"Error seeking to last record: %s\\n\", strerror( errno ) );\n        goto done;\n    }\n\n    if( read( fd, rec, 80 ) != 80 )\n    {\n        printf( \"Error reading last record: %s\\n\", strerror( errno ) );\n        goto done;\n    }\n\n    if( rec\u00dd 79 \u00a8 != ' ' )\n    {\n        printf( \"File doesn't appear to have any padding\\n\" );\n        goto done;\n    }\n\n    for( i = 79; i >= 0; i-- )\n    {\n        if( rec\u00dd i \u00a8 != ' ' )\n        {\n            break;\n        }\n    }\n\n    i++;\n\n    if( ftruncate( fd, off + i ) == -1 )\n    {\n        printf( \"Error truncating file: %s\\n\", strerror( errno ) );\n        goto done;\n    }\n\n    printf( \"%d padding bytes truncated\\n\", 80 - i );\n\n    rc = 0;\n\ndone:\n\n    if( fd != -1 )\n    {\n        close( fd );\n    }\n\n    return( rc );\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TESTDATA": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x042\\x7f\\x01\\x042\\x8f\\x10%\\x003\\x00\\x06\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-11-22T00:00:00", "modifydate": "2004-11-23T10:25:46", "lines": 51, "newlines": 6, "modlines": 0, "user": "SBGOLOB"}, "text": "----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----100--+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----200--+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----300--+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----4\n00--+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----500--+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----600--+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----700--+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----8\n00--+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----900--+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----1000-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----1100-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----1\n200-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----1300-+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----1400-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----1500-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----1\n600-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----1700-+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----1800-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----1900-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----2\n000-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----2100-+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----2200-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----2300-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----2\n400-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----2500-+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----2600-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----2700-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----2\n800-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----2900-+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----3000-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----3100-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----3\n200-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----3300-+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----3400-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----3500-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----3\n600-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n----+----9----+----3700-+----1----+----2----+----3----+----4----+----5----+----6\n----+----7----+----8----+----9----+----3800-+----1----+----2----+----3----+----4\n----+----5----+----6----+----7----+----8----+----9----+----3900-+----1----+----2\n----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----4\n000-+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNFAREA": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x04\\x01\\x042\\x8f\\x01\\x05\\x00O\"E\\x00\\x0c\\x00\\x0b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-11-23T00:00:00", "modifydate": "2005-01-04T22:45:04", "lines": 12, "newlines": 11, "modlines": 0, "user": "SBGOLOB"}, "text": "UNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\n*        Copyright (c) 2004-2005 by Sam Golob\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UNFDRVR": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00'\\x01\\x042o\\x01\\x044\\x7f\\x100\\x01_\\x00\\xb5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "2004-11-21T00:00:00", "modifydate": "2004-12-12T10:30:27", "lines": 351, "newlines": 181, "modlines": 0, "user": "SBGOLOB"}, "text": "UNFDRVR  CSECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  UNFDRVR - Driver program to test the UNFOLDEM program.           *\n*                                                                   *\n*    Purpose:  To test the ability of the UNFOLDEM program to       *\n*    -------   move a block of data from an FB-80 file, starting    *\n*              at an OFFSET location off the beginning of the       *\n*              record, for a given number of bytes, and to move     *\n*              that amount of data to a data buffer.  Then UNFDRVR  *\n*              opens a tape file and writes the one block of data   *\n*              to a tape.  Its main purpose is to debug the         *\n*              UNFOLDEM program.                                    *\n*                                                                   *\n*    Method:   The UNFOLDEM program is set up to operate from a     *\n*    ------    control block, called UNFAREA (the Unfold Area       *\n*              Control Block) which is updated by both the driver   *\n*              program and the UNFOLDEM program.  This is the       *\n*              UNFAREA control block.  UNFAREA is passed back and   *\n*              forth between the driver program and the UNFOLDEM    *\n*              program, and is updated by both programs.            *\n*                                                                   *\n*     UNFAREA  DS    0F          UNFOLD AREA CONTROL BLOCK          *\n*     *                          ------ ---- ------- -----          *\n*     UNFSCARD DC    F'0'        Start address of 80-byte card      *\n*     UNFECARD DC    F'0'        End address of 80-byte card        *\n*     UNFOFFST DC    F'0'        OFFSET of data to be moved         *\n*     UNFBYTES DC    F'0'        Number of bytes to be unfolded     *\n*     UNFBYMVD DC    F'0'        Number of bytes that were moved    *\n*     UNFBUFFR DC    F'0'        Current start address in buffer    *\n*     UNFBSTRT DC    F'0'        Original start address of buffer   *\n*     UNFINRCD DC    PL7'0'      Number of GETs for AWSIN records   *\n*     UNFLENTH EQU   *-UNFAREA                                      *\n*                                                                   *\n*    JCL:      The following is sample JCL to run the UNFDRVR       *\n*    ---       program:                                             *\n*                                                                   *\n*     //SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,                          *\n*     //    MSGCLASS=X,NOTIFY=&SYSUID                               *\n*     //*                                                           *\n*     //UNFTEST  EXEC PGM=UNFDRVR                                   *\n*     //STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD                     *\n*     //AWSIN     DD  DISP=SHR,DSN=SBGOLOB.CBT468.FILE533(TESTDATA) *\n*     //TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=TSTDRV,             *\n*     //          LABEL=(1,NL,EXPDT=98000)                          *\n*     //*         LABEL=(1,BLP,EXPDT=98000)                         *\n*     //SYSPRINT  DD  SYSOUT=*                                      *\n*     //SYSIN     DD  *                                             *\n*     OFFSET=42                                                     *\n*     BYTESM=3000                                                   *\n*     /*                                                            *\n*                                                                   *\n*              The TESTDATA data is \"ruler data\" which measures     *\n*              the number of bytes in an obvious way, a small       *\n*              segment of this data looks like the following:       *\n*                                                                   *\n*     ----+----1----+----2----+----3----+----4----+----5----+----6  *\n*                                                                   *\n*              but it fills the entire 80-byte record and wraps     *\n*              around for several thousand bytes.  You can use      *\n*              it to measure if the correct number of data bytes    *\n*              have been moved, starting from the given offset      *\n*              location.  The illustrated JCL will look at the      *\n*              data in the current card, at an offset of +42 bytes  *\n*              from the beginning of the card, and copy 3000 bytes  *\n*              more out to a buffer, and write the buffer data out  *\n*              to a tape file.  The UNFOLDEM program will do as     *\n*              many GETs from the card file as needed, to fulfill   *\n*              the 3000 byte requirement.                           *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nUNFDRVR  AMODE 24\nUNFDRVR  RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'UNFDRVR  '\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING UNFDRVR,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nUNFDRV   DS    0H\n         OPEN  (SYSIN,(INPUT))\n         OPEN  (AWSIN,(INPUT))\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (TAPOUT,(OUTPUT))\n         L     R3,=A(BUFFAREA)      POINT TO BEGINNING OF TAPE BUFFER\n         ST    R3,SVBFAREA          SAVE BUFFAREA LOCATION\n         ST    R3,UNFBUFFR          AND PASS IT TO CALLED PROGRAM\n         ST    R3,UNFBSTRT          AND PASS IT TO CALLED PROGRAM\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCARDREAD DS    0H              CHECK SYSIN FOR KEYWORDS AND PARMS        06356\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *    06357\n*              Insert User Code Here for Keywords                        06358\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *    06359\n         GET   SYSIN,CARDIN                                              06360\n*                                                                        06361\n* -- >>              <-- Intercept any keywords you want in SYSIN -->    06362\n* -- >>              <--    before you start the table scan       -->    06363\n*                                                                        06364\n* ----------------------------------------------------------------- *    06365\n         MVI   CARDWORK,X'40'           CLEAR CARD WORKAREA TO BLANKS    06366\n         MVC   CARDWORK+1(79),CARDWORK                                   06367\n         MVC   CARDWORK(80),CARDIN      MOVE CARD IMAGE TO WORKAREA      06368\n         OC    CARDWORK(80),CARDBLNK    UPPERCASE                        06369\n* ----------------------------------------------------------------- *    06370\n*      CARDWORK now contains an uppercased version of CARDIN.            06371\n* ----------------------------------------------------------------- *    06372\n         CLC   =C'OFFSET=',CARDWORK     KEYWORD PRESENT IN THIS CARD?    06373\n         BE    OFFSETMV          PROCESS THIS CARD FOR KEYWORD           06374\n         CLC   =C'BYTESM=',CARDWORK     KEYWORD PRESENT IN THIS CARD?    06373\n         BE    BYTESMVE          PROCESS THIS CARD FOR KEYWORD           06374\nOFFSETMV DS    0H                                                        06423\n         CLI   CARDIN+7,C' '     IS FIRST NUMBER VALUE BLANK?            06424\n         BE    CARDREAD          YES. IGNORE ENTIRE CARD                 06425\n         CLI   CARDIN+7,X'F0'    SMALLER THAN ZERO?                      06426\n         BL    CARDREAD          YES. IGNORE.                            06427\n         CLI   CARDIN+7,X'F9'    BIGGER THAN 9?                          06428\n         BH    CARDREAD          YES. IGNORE.                            06429\n         LA    R15,CARDIN+7      STARTING ADDRESS                        06431\n         LR    R1,R15            LOAD R1 WITH THIS ADDRESS               06432\nOFFSETNM DS    0H                                                        06433\n         LA    R15,1(,R15)       BUMP TO NEXT CHARACTER                  06434\n         C     R15,=A(CARDIN+71) END OF CARD?                            06435\n         BH    OFFSTGNM          YES, GET NUMBER                         06436\n         CLI   0(R15),C' '       BLANK HERE?                             06437\n         BE    OFFSTGNM          YES, GET NUMBER                         06438\n         B     OFFSETNM          NO. STEP UP ONE PLACE                   06439\nOFFSTGNM DS    0H                                                        06440\n         SR    R15,R1            HOW BIG IS THE NUMBER                   06441\n         BCTR  R15,0             LOWER IT FOR EXECUTE                    06442\n         EX    R15,PACKO         COPY THE NUMBER TO WORK AREA            06443\n         CVB   R0,WORKO          CONVERT IT TO BINARY                    06446\n         ST    R0,UNFOFFST       STORE THE VALUE FOR LATER USE           06447\n         B     CARDREAD                                                  06453\nBYTESMVE DS    0H                                                        06423\n         CLI   CARDIN+7,C' '     IS FIRST NUMBER VALUE BLANK?            06424\n         BE    CARDREAD          YES. IGNORE ENTIRE CARD                 06425\n         CLI   CARDIN+7,X'F0'    SMALLER THAN ZERO?                      06426\n         BL    CARDREAD          YES. IGNORE.                            06427\n         CLI   CARDIN+7,X'F9'    BIGGER THAN 9?                          06428\n         BH    CARDREAD          YES. IGNORE.                            06429\n         LA    R15,CARDIN+7      STARTING ADDRESS                        06431\n         LR    R1,R15            LOAD R1 WITH THIS ADDRESS               06432\nBYTESMNM DS    0H                                                        06433\n         LA    R15,1(,R15)       BUMP TO NEXT CHARACTER                  06434\n         C     R15,=A(CARDIN+71) END OF CARD?                            06435\n         BH    BYTESGNM          YES, GET NUMBER                         06436\n         CLI   0(R15),C' '       BLANK HERE?                             06437\n         BE    BYTESGNM          YES, GET NUMBER                         06438\n         B     BYTESMNM          NO. STEP UP ONE PLACE                   06439\nBYTESGNM DS    0H                                                        06440\n         SR    R15,R1            HOW BIG IS THE NUMBER                   06441\n         BCTR  R15,0             LOWER IT FOR EXECUTE                    06442\n         EX    R15,PACKB         COPY THE NUMBER TO WORK AREA            06443\n         CVB   R0,WORKB          CONVERT IT TO BINARY                    06446\n         ST    R0,UNFBYTES       STORE THE VALUE FOR LATER USE           06447\n         B     CARDREAD                                                  06453\nPACKO    PACK  WORKO,0(0,1)          <<< EXECUTED >>>                    06758\nPACKB    PACK  WORKB,0(0,1)          <<< EXECUTED >>>                    06758\nWORKO    DC    D'0'                                                      04810\nWORKB    DC    D'0'                                                      04810\n* --------------------------------------------------------- *\nSYSINEND DS    0H                FINISHED GETTING NUMBERS\n         CLOSE SYSIN\n* --------------------------------------------------------- *\n*                                                           *\n* --------------------------------------------------------- *\n         GET   AWSIN,WORKCURR    GET ONE CARD IMAGE --\n         AP    UNFINRCD,=P'1'    INCREMENT COUNT OF GETs\n*                                   CALLED PROGRAM DOES THE REST....\n         LA    R1,WORKCURR\n         ST    R1,UNFSCARD\n         LA    R1,80(,R1)\n         ST    R1,UNFECARD\n* --------------------------------------------------------- *\n*   CALL THE UNFOLDEM PROGRAM                               *\n* --------------------------------------------------------- *\n         MVC   LINE+1(8),=C'BEFORE: '\n         BAL   R9,UNFIMAGE\n         LA    R1,UNFAREA\n         L     R15,=V(UNFOLDEM)\n         BALR  R14,R15\n         MVC   LINE+1(8),=C'AFTER : '\n         BAL   R9,UNFIMAGE\nAWSINEND DS    0H\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'AFTCALL '\n         L     R1,SVBFAREA\n         HEX   LINE+1,66,0(R1)\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n* --------------------------------------------------------- *\n*   WRITE THE TAPE                                          *\n* --------------------------------------------------------- *\nWRITBUFF DS    0H\n         LA    R1,TAPOUT          R1=address of current DCB\n         ST    R1,OUTDCBPT        Put it in IOB\n         MVC   OUTCCW+6(2),UNFBYMVD+2   Move length of block\n         MVC   OUTCCW+1(3),SVBFAREA+1   PRIME OUTPUT CCW\n         MVI   OUTECB,X'00'       Initialize ECB\n         EXCP  OUTIOB             Write out the buffer\n         WAIT  ECB=OUTECB         Wait for write to complete\n         CLI   OUTECB,X'7F'       Write completed normally?\n         BNE   WRITBERR           No - error\n         MVC   LINE,LINE-1\n         MVC   LINE+1(8),=C'WRITTEN'\n         L     R1,SVBFAREA\n         HEX   LINE+10,61,0(R1)\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\nCOPYBACK DS    0H\n         MVC   MAXRC,=F'0'\n         B     RETURN\nWRITBERR DS    0H\n         MVC   MAXRC,=F'4'\n         B     RETURN\n* --------------------------------------------------------- *\nRETURN   DS    0H                RETURN TO THE OPERATING SYSTEM\n         CLOSE AWSIN\n         CLOSE TAPOUT\n         CLOSE SYSPRINT\n         L     R13,4(,R13)\n         MVC   16(4,R13),MAXRC      Load Maximum Return Code\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H\n         HEX   LINE+10,4,UNFSCARD\n         HEX   LINE+20,4,UNFECARD\n         HEX   LINE+30,4,UNFOFFST\n         HEX   LINE+40,4,UNFBYTES\n         HEX   LINE+50,4,UNFBYMVD\n         HEX   LINE+60,4,UNFBUFFR\n         HEX   LINE+70,4,UNFBSTRT\n         HEX   LINE+80,7,UNFINRCD\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         BR    R9\n* --------------------------------------------------------- *\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Saved start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\nWORKPREV DS    CL80                 Contiguous previous card image\nWORKCURR DS    CL80                 Card image work area\n*\nFF       EQU   X'FF'\nCARDBLNK DC    80C' '\nCARDIN   DC    CL80' '\nCARDWORK DC    CL80' '\nZEROCARD DC    80X'00'\nSAVEBEGD DC    F'0'                 Save beg of buffer data address\nSAVEENDD DC    F'0'                 Save end of buffer data address\nSAVEBEGI DC    F'0'                 Save beg address of card input\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVER8TR DC    F'0'                 Save floating Reg 8 which decreases\nPARMPTR  DC    F'0'\nSAVER10  DC    F'0'\nSVBFAREA DC    F'0'\nSAVEPARM DC    F'0'\nMAXRC    DC    F'0'\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nLINE2    DC    CL133' '\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         LTORG\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\nOUTCCW   DC    X'01',AL3(SVBFAREA),X'2000',X'FFFF'\nOUTECB   DC    F'0'\nOUTIOB   DC    X'02000000'\n         DC    A(OUTECB)\nOUTCSW   DC    2F'0'\nOUTCCWPT DC    A(OUTCCW)\nOUTDCBPT DC    A(TAPOUT)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            PADDING\n         ENTRY AWSIN\nAWSIN    DCB   DDNAME=AWSIN,MACRF=GM,EODAD=AWSINEND,DSORG=PS,LRECL=80\nTAPOUT   DCB   MACRF=(E),DDNAME=TAPOUT,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X 05677\n               EODAD=SYSINEND                                            05678\nBUFFAREA DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNFDRVR$": {"ttr": 3340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x042\\x7f\\x01\\x042\\x7f R\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-11-22T00:00:00", "modifydate": "2004-11-22T20:52:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFDRVR)\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   UNFDRVR\n SETSSI  CB468533\n NAME    UNFDRVR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNFDRVR#": {"ttr": 3342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x03\\x01\\x01(\\x9f\\x01\\x044\\x7f\\x10)\\x00\\x0e\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2004-12-12T10:29:03", "lines": 14, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBT JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//UNFTEST  EXEC PGM=UNFDRVR\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.CBT468.FILE533(TESTDATA)\n//TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=TSTDRV,\n//          LABEL=(1,NL,EXPDT=98000)\n//*         LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\nOFFSET=42\nBYTESM=3000\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNFOLDE$": {"ttr": 3344, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00P\\x01\\x042\\x7f\\x01\\x042\\x7f Q\\x00\\x1c\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-11-22T00:00:00", "modifydate": "2004-11-22T20:51:50", "lines": 28, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,ESD,RLD,BATCH,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,4),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY   UNFOLDEM\n SETSSI  CB468533\n NAME    UNFOLDEM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNFOLDEM": {"ttr": 3346, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00\\x17\\x01\\x042o\\x01\\x05\\x00O\"C\\x01\\xb2\\x00\\xb5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "2004-11-21T00:00:00", "modifydate": "2005-01-04T22:43:17", "lines": 434, "newlines": 181, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'UNFOLDEM -- UNFOLD FB-80 DATA INTO A LONG BUFFER'\nUNFOLDEM CSECT\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*     Copyright  2004 - 2005  by  Sam Golob.  All right reserved,\n*                subject to express permissions from the author\n*                to use this software.  This software is part\n*                of VTTS (Virtual Tape Transportation System).\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    UNFOLDEM                                          *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating a       *\n*      real tape from an AWS-format tape file, which has been       *\n*      folded over into an FB-80 dataset.  The AWS header           *\n*      contains the number of bytes in the next chunk (complete     *\n*      or partial block) of tape data.  Once this quantity is       *\n*      known, and the beginning position of the data has been       *\n*      established (it starts just after the header ends), then     *\n*      the data itself has to be moved into a buffer, in            *\n*      preparation for that data block being written out to a       *\n*      tape.  This program unfolds the correct amount of data,      *\n*      beginning at a known position in the FB-80 file, into        *\n*      the buffer.  The position in the FB-80 file which marks      *\n*      the beginning of the data to be moved, is called the         *\n*      OFFSET into the 80-byte card, and it starts with position    *\n*      +0.                                                          *\n*                                                                   *\n*  INPUTS and OUTPUTS:   Described below.                           *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called AWSIN, which contains its input         *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do GETs from AWSIN, and if necessary, it needs      *\n*      to write messages to SYSPRINT.  The caller has to provide    *\n*      ENTRY AWSIN and ENTRY SYSPRINT statements in front of        *\n*      the AWSIN and SYSPRINT DCBs, respectively.                   *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      UNFAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      UNFAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the UNFAREA.                                        *\n*                                                                   *\n*      The caller does one GET of the FB-80 file, to read an        *\n*      AWS header (that has tape data following it).  Once the      *\n*      AWS header has been read, there should be enough data to     *\n*      supply to the UNFAREA control block, and then this           *\n*      program is called, to complete the move of that tape data    *\n*      to a buffer, and position the FB-80 input just past the      *\n*      data moved, so it should point to the next AWS header.       *\n*                                                                   *\n*      This program does more GETs from the FB-80 input file,       *\n*      until the request for the number of bytes to be moved,       *\n*      is satisfied.                                                *\n*                                                                   *\n*      The following is the layout of the UNFAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      UNFAREA  DS    0F          UNFOLD AREA CONTROL BLOCK         *\n*      *                          ------ ---- ------- -----         *\n*  --> UNFSCARD DC    F'0'        Start address of 80-byte card     *\n*  --> UNFECARD DC    F'0'        End address of 80-byte card       *\n*  --> UNFOFFST DC    F'0'        OFFSET of data to be moved        *\n*  --> UNFBYTES DC    F'0'        Number of bytes to be unfolded    *\n*      UNFBYMVD DC    F'0'        Number of bytes that were moved   *\n*  --> UNFBUFFR DC    F'0'        Current start address in buffer   *\n*  --> UNFBSTRT DC    F'0'        Original start address of buffer  *\n*      UNFINRCD DC    PL7'0'      Number of GETs for AWSIN records  *\n*      UNFLENTH EQU   *-UNFAREA                                     *\n*      *                                                            *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      UNFBUFFR and UNFOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the output data     *\n*      and input data positions, respectively, that are just        *\n*      after the moved data, so as to wait for the next call,       *\n*      to be able to move more data.  UNFBSTRT preserves the        *\n*      very beginning address of the output buffer, whereas         *\n*      UNFBUFFR is a place somewhere within the buffer, which       *\n*      is the start of where the new data is expected to be         *\n*      moved.                                                       *\n*                                                                   *\n*      Since both the caller and this program do GET operations     *\n*      from the input FB-80 file, the count of the number of GETs   *\n*      done, UNFINRCD, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nUNFOLDEM AMODE 24\nUNFOLDEM RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'UNFOLDEM '\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING UNFOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,AWSINV             AWSIN    DCB address in caller\n         ST    R0,AWSINDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to unfold FB-80 data starting at an OFFSET from the     *\n*   beginning of a card, for a certain number of bytes, to a data   *\n*   buffer area whose beginning address is supplied.  More 80-byte  *\n*   records can be read with the GET macro from the FB-80 file, to  *\n*   fulfill the move request.                                       *\n*                                                                   *\n*   Input:   UNFAREA fields are all supplied by the calling         *\n*            program, except for UNFBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            UNFAREA is pointed to by Register 1.                   *\n*                                                                   *\n*            The initial card image which is supplied by the        *\n*            calling program, already is primed with data to be     *\n*            moved (one card's worth of it).  This card contains    *\n*            the starting point for the data to be moved, at an     *\n*            OFFSET (displacement) from the beginning of the card.  *\n*                                                                   *\n*            The input data also contains the address of an         *\n*            output buffer area, which is the target for the        *\n*            (segmented) data moves.  Data will be strung out       *\n*            into this area, one card (or a partial card) at a      *\n*            time.  The current card which is in the input file,    *\n*            which contains the beginning of the data to be         *\n*            moved, has already been loaded into a card image       *\n*            work area pointed to by the calling program.  The      *\n*            OFFSET into this card is where the data to be moved    *\n*            will start.                                            *\n*                                                                   *\n*            It is the responsibility of the calling program to     *\n*            ensure that this routine has access to all of the      *\n*            buffer storage where the data is supposed to be        *\n*            moved to.                                              *\n*                                                                   *\n*   Output:  Data is moved, for the required number of bytes, to    *\n*            the output buffer area.  When more that one card       *\n*            image's worth of data has to be moved, more cards      *\n*            are obtained with the GET macro, from the input file.  *\n*                                                                   *\n*            Ending OFFSET in the FB-80 input file, pointing to     *\n*            just after the data which was moved, in the final      *\n*            card image gotten, is returned to the UNFOFFST field   *\n*            and reported to the caller, in anticipation of the     *\n*            next call to this routine.                             *\n*                                                                   *\n*            Ending address of data in buffer - one byte after      *\n*            the end of the moved data - is returned in the         *\n*            UNFBUFFR field.  The UNFBSTRT field preserves the      *\n*            address of the beginning of the data buffer.           *\n*                                                                   *\n*            A count of bytes actually moved from the FB-80 file    *\n*            to the output buffer area is reported in the UNFBYMVD  *\n*            field.  This must match the byte count of bytes which  *\n*            needed to be moved initially.  That count had been     *\n*            initially supplied by the calling program in the       *\n*            UNFBYTES field.                                        *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nUNFOLD   DS    0H\n         ST    R1,PARMPTR\n         L     R2,=A(UNFBLOCK)\n         USING UNFBLOCK,R2\n         MVC   UNFAREA(UNFLENTH),0(R1)      Move input block to pgm\n         LA    R2,UNFAREA                   And address it.\n         MVC   SAVEBEGC,UNFSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,UNFECARD    Save \"end of card\" address\n         L     R1,UNFSCARD          Address of card\n         MVC   WORKPREV(80),ZEROCARD   Zero prev work area\n         MVC   WORKCURR(80),0(R1)   Move card image to curr work area\n         MVC   UNFBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,UNFSCARD          Point to beginning of card\n         A     R7,UNFOFFST          Add OFFSET to start of input\n         ST    R7,SAVEBEGI          Save where input starts\n         L     R8,SAVEBEGI          Copy beg of input address\n         A     R8,UNFBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n* - - - - - - - - - - - - - - >>    This may be way past the address\n*             of the end of the FB-80 card.  We will decrease this\n*             address as we move bytes from successive cards to the\n*             data buffer, by 80 bytes at a time, as we GET new cards,\n*             until R8 actually falls within the end-of-card address.\n*             We will then use this address to calculate the new\n*             OFFSET for the next piece of data in the FB-80 file.\n*             The new OFFSET is returned to the caller by modifying\n*             the UNFOFFST field in the control block.\n*\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nLOOPSET  DS    0H                   Start moving data\n         L     R3,UNFBUFFR          Point to beginning of buffer\n         ST    R3,SAVEBEGD          Save location in the program.\n         LR    R4,R3                Point R4 to end of data by adding\n         A     R4,UNFBYTES          the number of bytes to the start.\n         ST    R4,SAVEENDD          Save potential end of data location\n         ST    R8,SAVER8TR          Save R8 for trace.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is within the current card.           *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.                       *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         C     R8,SAVEENDC          Is R8 still past end-of-card?\n         BH    LOOPMORE             Yes. Copy till end and GET.\nLOOPSHRT DS    0H                   The move is short, not past end.\n         LR    R6,R8                No. Get byte count to move NOW.\n         SR    R6,R7                Bytes to move\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data to the buffer.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,UNFBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET - save R8\n         S     R6,UNFSCARD          Subtract beginning of card address\n         ST    R6,UNFOFFST          Store the result as new OFFSET\n*        MVC   LINE+1(8),=C'LSHRT2: '\n*        BAL   R9,UNFIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Test if past end\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,UNFBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card gotten\n         MVC   WORKPREV,WORKCURR    Save card image to previous\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWSINDCB         Point to AWSIN DCB in caller\n         GET   (10),WORKCURR        Get a new card image\n         L     R10,SAVER10          Restore R10\n         AP    UNFINRCD,=P'1'       Increment count of AWSIN rcrds read\n         L     R7,SAVEBEGC          Point to beginning addr of workarea\n         MVC   0(80,R7),WORKCURR    Overlay caller's card image\n*        MVC   LINE+1(8),=C'LMORE2: '\n*        BAL   R9,UNFIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R3),0(R7)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE OPERATING SYSTEM\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of UNFAREA in caller\n         MVC   0(UNFLENTH,R10),UNFAREA    Copy changed UNFAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(UNFBLOCK)  Return address of UNFAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H          Diagnostic Data - State of UNFAREA currently\n*\n         HEX   LINE+10,4,UNFSCARD\n         HEX   LINE+20,4,UNFECARD\n         HEX   LINE+30,4,UNFOFFST\n         HEX   LINE+40,4,UNFBYTES\n         HEX   LINE+50,4,UNFBYMVD\n         HEX   LINE+60,4,UNFBUFFR\n         HEX   LINE+70,4,UNFBSTRT\n         HEX   LINE+80,4,SAVER8TR\n         HEX   LINE+90,7,UNFINRCD\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nUNFBLOCK CSECT\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n*\nUNFOLDEM CSECT\nWORKPREV DS    CL80                 Contiguous previous card image\nWORKCURR DS    CL80                 Card image work area\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nLINE2    DC    CL133' '\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGD DC    F'0'                 Save beg of buffer data address\nSAVEENDD DC    F'0'                 Save end of buffer data address\nSAVEBEGI DC    F'0'                 Save beg address of card input\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVER8TR DC    F'0'                 Save floating Reg 8 which decreases\nSAVEPARM DC    F'0'                 Save CALLER'S UNFAREA ADDRESS\nPARMPTR  DC    F'0'\nSYSPRINV DC    V(SYSPRINT)\nAWSINV   DC    V(AWSIN)\nSYSPRDCB DC    F'0'\nAWSINDCB DC    F'0'\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2CNV$": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x010\\x1f\\x01\\x024_\\x10#\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-10-28T00:00:00", "modifydate": "2002-12-11T10:23:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R11.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R11.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2CNVU)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB445533\n SETCODE AC(0)\n NAME VTT2CNVU(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2CNVU": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x009\\x01\\x00%O\\x01\\x05\\x01\\x0f\\x10U\\x039\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2005-01-10T10:55:39", "lines": 825, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2CNVU -- CONVERT VB AWSUTIL OUTPUT TO FB-80 AWS FILE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE: VTT2CNVU.   Written by Sam Golob                **\n**                                                          **\n**       Copyright (c) 2001 - 2005 by Sam Golob             **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to convert an MVS AWS-format tape     **\n**            which was created in VB format by Brandon     **\n**            Hill's AWSUTIL program, to FB-80 format,      **\n**            so it can be read by the VTT2TAPE program.    **\n**            Also works for any VB AWS format file.        **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     1.  AWS Tape data from the VB input is read, one     **\n**         block at a time, using GET LOCATE, and the       **\n**         obtained record is folded over into an FB-80     **\n**         output file, using the FOLDEM routine from the   **\n**         VTT2DISK program.                                **\n**                                                          **\n**     2.  At end-of-data, the last (probably incomplete)   **\n**         FB-80 record in the buffer is filled in with     **\n**         X'20' bytes, and is written out.                 **\n**                                                          **\n**     3.  Brandon Hill's AWSUTIL program sometimes passes  **\n**         end-of-tape, and keeps writing out end-of-tape   **\n**         AWS headers.  This program stops, after seeing   **\n**         five of them in a row, only writing out four.    **\n**                                                          **\n**                                                          **\n**         Full JCL to run the VTT2CNVU program is as       **\n**         follows:                                         **\n**                                                          **\n**       //   jobcard                                       **\n**       //AWSCNVT  EXEC PGM=VTT2CNVU                       **\n**       //STEPLIB   DD  DISP=SHR,DSN=your.load.library     **\n**       //AWSFBOUT  DD  DSN=fb80.folded.aws.file,          **\n**       //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA, **\n**       //          VOL=SER=volxxx,                        **\n**       //          SPACE=(CYL,(mm,nn),RLSE)               **\n**       //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)  **\n**       //AWSVBIN   DD  DISP=SHR,DSN=yourid.vb.aws.file    **\n**       //SYSPRINT  DD  SYSOUT=*                           **\n**       //SYSFILES  DD  SYSOUT=*                           **\n**       //SYSTRACE  DD  SYSOUT=*                           **\n**       //SYSMOVED  DD  SYSOUT=*                           **\n**       //SYSUDUMP  DD  SYSOUT=*                           **\n**                                                          **\n**         where you can leave out SYSTRACE, SYSFILES,      **\n**         SYSMOVED, and SYSUDUMP.                          **\n**                                                          **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.0 - It works.  Converts VB AWS-format tape  **\n**       files to FB-80.  Not too many frills, but has      **\n**       SYSMOVED report.                                   **\n**                                                          **\n**    Version 1.1 - Replace FB-80 fill character from X'20' **\n**       and make it X'00'.                                 **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n&LLEV    SETC  '1.1'\n         YREGS\n         EJECT\nVTT2CNVU CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2CNVU AMODE 24\nVTT2CNVU RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2CNVU - AWS VB TO AWS FB-80 CONVERSION PROGRAM - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001 - 2005 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2CNVU,R12,R11,R10\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n* ----- >                            Parm = READ    <--- below\n         L     R1,0(R1)              Get PARM field\n         CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BNE   COPYTAPE              No. Default is to copy the tape.\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\nCOPYTAPE DS    0H\n* ----- >                            Parm = READ    <--- above\n*\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE3+88(31),HEADDLIT\n         MVC   MESSAGE4+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+62(20),LEVELLIT    Program level and\n         MVC   MESSAGE2+62(20),LEVELLIT      assembly date\n         MVC   MESSAGE3+62(20),LEVELLIT\n         MVC   MESSAGE4+62(20),LEVELLIT\n***********************************************************************\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants\n         MVC   FOLDHIGH(2),=X'0000'\n         MVC   FULLHIGH(2),=X'0000'\n         MVC   CURRBYTE(2),=X'0000'\n         MVC   LASTBYTE(2),=X'0000'\n         MVI   FOLDFLAG,X'00'\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n* ----------------------------------------------------------------- *\nLOOPSTRT DS    0H                    START OF PROCESSING\n         LA    R1,OUTCARD            INITIALIZE BEG OF RECORD\n         ST    R1,SAVEBEGC           AND SAVE THIS SETTING.\n* ---------------------------------------------------------------- *\n         LA    R1,OUTCAEND           INITIALIZE END OF RECORD\n         ST    R1,SAVEENDC           AND SAVE THIS SETTING.\n         LA    R1,80(,R1)            BOP BY ANOTHER RECORD LENGTH\n         ST    R1,SAVEEN80           AND SAVE WHERE THIS IS.\n* ---------------------------------------------------------------- *\n* ----------------------------------------------------------------- *\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n         TM    READFLAG,X'01'        Read Only run?\n         BO    NOAWSOUT              Yes. Don't OPEN AWSFBOUT.\n         OPEN  (AWSFBOUT,(OUTPUT))\nNOAWSOUT DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (AWSVBIN,(INPUT))\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   NOSYSTRC              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE2\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n*--->>\n         TM    READFLAG,X'01'\n         BZ    NOEXTRA2\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSTRACE,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\nNOEXTRA2 DS    0H\n*--->>\nNOSYSTRC DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE3\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\n*--->>\n         TM    READFLAG,X'01'\n         BZ    NOEXTRA3\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSMOVED,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\nNOEXTRA3 DS    0H\n*--->>\nNOSYSFIL DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSMVD              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE4\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\n*--->>\n         TM    READFLAG,X'01'\n         BZ    NOEXTRA4\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSFILES,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE\nNOEXTRA4 DS    0H\n*--->>\nNOSYSMVD DS    0H\n* ----------------------------------------------------------------- *\n*     Write the top Header Line, with the date and time in it.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n*--->>\n         TM    READFLAG,X'01'\n         BZ    NOEXTRA1\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\nNOEXTRA1 DS    0H\n*--->>\n* ----------------------------------------------------------------- *\nINITMORE DS    0H                      Initialize Constants\n         ZAP   INRCDS,=P'0'\n         ZAP   OUTRCDS,=P'0'\n         SPACE 3\nSTARTIT  DS    0H                      Start Main Processing\n         L     R7,SAVEBEGC             Address of Beginning of Card\n         ST    R7,SVBEGDAT             Initial Data Loc at Beg of Card\nMAINLOOP DS    0H\n         BAL   R9,GETDATIN             Read a block of data\n         L     R3,CURBUFAD             Point to the data\n         CLC   0(6,R3),EOTMARK         Do we have an EOT mark (2nd TM)\n         BNE   NOEOTM                  If not, don't change processing\n         AP    EOTCNTR,=P'1'           Yes. Add to EOT counter\n         B     EOTMK                   Only count EOT markers in a row\nNOEOTM   DS    0H\n         ZAP   EOTCNTR,=P'0'           Not EOT mark, set counter to 0\nEOTMK    DS    0H\n         CP    EOTCNTR,=P'5'           Is the counter more than 5?\n         BNL   FIN                     Don't fold the 5th one. End.\n         BAL   R9,FOLDEM               And fold it into the output.\n         B     MAINLOOP                Do another READ of the tape.\n*\n* ---------------------------------------------------------------- *\n*          END OF INPUT AWS DATA                                   *\n* ---------------------------------------------------------------- *\n*\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         L     R7,SVBEGDAT          Point right after eod in buffer\n         MVC   0(80,R7),LASTLINE    Fill rest of buffer with X'00's\n         TM    READFLAG,X'01'\n         BO    NOPUT01\n         PUT   AWSFBOUT,OUTCARD     And write out the last buffer.\nNOPUT01  DS    0H\n         AP    OUTRCDS,=P'1'        Count the record PUT out.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(38),CTMSG02\n         MVC   OUTLINE+35(9),FILEPAT\n         ED    OUTLINE+35(9),INRCDS+3\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(38),CTMSG01\n         MVC   OUTLINE+35(9),FILEPAT\n         ED    OUTLINE+35(9),OUTRCDS+3\n         PUT   SYSPRINT,OUTLINE\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\nCLOSEMAL DS    0H\n         CLOSE AWSVBIN\n         TM    READFLAG,X'01'\n         BO    NOAWSCLS\n         CLOSE AWSFBOUT\nNOAWSCLS DS    0H\n         CLOSE SYSPRINT\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n*\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*     Routine to read a block of data from the input tape\n*     and save byte counts from it, to make the AWS headers.\n* ----------------------------------------------------------------- *\nGETDATIN DS    0H\n         GET   AWSVBIN            Get a record\n         LR    R3,R1              Save address of buffer\n         AP    INRCDS,=P'1'       Count it\n         LH    R2,0(,R3)          Bytes to move, plus 4\n         S     R2,=F'4'           Subtract the 4\n         STH   R2,FOLDBYTS        And save the number\n         LA    R3,4(,R3)          Bump past the RDW to the data\n         ST    R3,CURBUFAD        Store the address of the data itself\nGETDATEN DS    0H\n         BR    R9\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nFOLDEM   DS    0H                General FB-80 Outputting Routine\n*                       Data is folded into 80-byte records and PUT\n*                       to the AWSFBOUT file when the record is\n*                       complete.\n* ----------------------------------------------------------------- *\n*\n*    Inputs:   FOLDBYTS contains halfword number of bytes to fold.\n*              SVBEGDAT points to start address in the card-image\n*                 buffer.  This is 'start of buffer' address plus\n*                 OFFSET.\n*              R3 points to the start address of the data to be folded.\n*                 This is found from the GET LOCATE address that was\n*                 returned for each GET, into Register 1.\n*\n*    At End:   SVBEGDAT points to the start address in the card-image\n*                 buffer, which will be the starting point for the\n*                 next folding operation.\n*              BYTESMVD contains the number of bytes that we just moved\n*                 in carrying out this folding operation.  It should\n*                 match the FOLDBYTS number, which is the number of\n*                 bytes we intended to fold, at the beginning of the\n*                 folding operation.\n*\n* ----------------------------------------------------------------- *\n         STM   R4,R8,SAVEFOLD   Save Registers\nGETOFFST DS    0H\n         L     R1,SAVEBEGC      Point to beginning of the output buffer\n         L     R4,SVBEGDAT      Load register with pointer location.\n         SR    R4,R1            Subtract start to get OFFSET.\n         ST    R4,OFFSET        Store the value of the OFFSET.\n         LA    R1,80            Get quantity of 80 for comparison.\n         C     R1,OFFSET        Is the OFFSET smaller than 80?\n         BL    GETOFERR         No. We've got an error. Print stats.\n         B     GETOFEND         OK. Get out of OFFSET routine.\nGETOFERR DS    0H            Print relevant STATS if there is an error.\n         ST    R1,SAVER1\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS1\n         HEX   OUTLINE+26,4,SAVER1    Should be 80, or X'50'\n         HEX   OUTLINE+36,4,OFFSET    Fullword OFFSET value\n         HEX   OUTLINE+46,4,SVBEGDAT  Address of beginning of data\n         HEX   OUTLINE+56,30,OUTCARD  Print 30 data bytes from OUTCARD\n         PUT   SYSPRINT,OUTLINE\nGETOFEND DS    0H\n* --->\nFOLDSTRT DS    0H                  Initialize fold operation\n         NI    FOLDFLAG,X'FF'-X'01'    Show first time thru fold loop\n         XR    R5,R5               Clear work register for byte totals\n         ST    R5,BYTESMVD         Start with zero\n         MVC   FOLDHIGH(2),HALFZERO    Hi halfword of fullword is zero\n         L     R7,SVBEGDAT             Load start addr in FB-80 buffer\n         L     R8,FOLDBREG         Load fullword bytes to be moved\n         AR    R8,R7               Theoretical location of end of data\n* <-><->   fold trace\n         MVC   LINE,LINE-1\n         MVC   LINE+1(16),FOLDTRMS\n         MVC   LINE+18(2),=C'ST'\n         HEX   LINE+22,4,BYTESMVD\n         HEX   LINE+32,4,FOLDBREG\n         ST    R3,SAVER3F\n         HEX   LINE+42,4,SAVER3F\n         HEX   LINE+52,4,OFFSET\n         HEX   LINE+62,4,SVBEGDAT\n         HEX   LINE+72,4,SAVEBEGC\n         TM    FLAGSYST,X'02'\n         BNO   NOSYSMV1\n         PUT   SYSMOVED,LINE\nNOSYSMV1 DS    0H\n* <-><->   fold trace\n*\nFOLDLOOP DS    0H                  Keep folding until data is done\n         TM    FOLDFLAG,X'01'      After the first time looped?\n         BO    FOLDSBEG            Yes, start from beginning of buffer\n         L     R7,SVBEGDAT         No, start from beginning of data\n         B     FOLDSBGO\nFOLDSBEG DS    0H\n         L     R7,SAVEBEGC         Beginning of buffer address\nFOLDSBGO DS    0H\n         OI    FOLDFLAG,X'01'      Make sure you don't do twice.\n         C     R8,SAVEENDC         Is eod past the end of the card?\n         BL    FOLDFIN             No, finish the partial fold.\n         BE    FOLDEQUL\nFOLDCONT DS    0H                  Fill the card and PUT it out.\n         L     R6,SAVEENDC         End address of card.\n         SR    R6,R7               Subtract beginning address.\n         ST    R6,SAVER6M          Bytes moved this time--store.\n         BCTR  R6,0                One less for EXECUTE.\n         EX    R6,FOLDMOVE         Move a card's worth of data.\n         L     R6,SAVER6M          Restore actual number of bytes.\n         TM    READFLAG,X'01'\n         BO    NOPUT02\n         PUT   AWSFBOUT,OUTCARD\nNOPUT02  DS    0H\n         AP    OUTRCDS,=P'1'       Count the record PUT out.\n         L     R5,BYTESMVD         Get previous bytes moved count.\n         AR    R5,R6               Get running total bytes for block.\n         ST    R5,BYTESMVD         And store it for future reference.\n         S     R8,=F'80'           Decrement R8 by card-image amount.\n         LA    R3,0(R6,R3)         Advance proper number in data bytes\n         B     FOLDLOOP             and continue folding.\nFOLDEQUL DS    0H                  Card just barely fills. PUT it out.\n         LR    R6,R8               End address is equal end-of-card.\n         SR    R6,R7               Subtract beginning address.\n         ST    R6,SAVER6M          Bytes moved this time--store\n         BCTR  R6,0                One less for EXECUTE\n         EX    R6,FOLDMOVE         Move the data to the output buffer.\n         L     R6,SAVER6M          Restore actual number of bytes.\n         TM    READFLAG,X'01'\n         BO    NOPUT03\n         PUT   AWSFBOUT,OUTCARD\nNOPUT03  DS    0H\n         AP    OUTRCDS,=P'1'       Count the record PUT out.\n         L     R5,BYTESMVD         Get previous bytes moved count.\n         AR    R5,R6               Finish total bytes moved for block.\n         ST    R5,BYTESMVD         And store it away for totalling.\n         L     R7,SAVEBEGC         Next start pos at beg of FB-80 buffr\n         ST    R7,SVBEGDAT         And store it for next fold.\n         B     FOLDFINE\nFOLDFIN  DS    0H\n         LR    R6,R8               End address is before end-of-card.\n         SR    R6,R7               Subtract beginning address.\n         ST    R6,SAVER6M          Bytes moved this time--store\n         BCTR  R6,0                One less for EXECUTE\n         EX    R6,FOLDMOVE         Move the data to the output buffer.\n         L     R6,SAVER6M          Restore actual number of bytes.\n         L     R5,BYTESMVD         Get previous bytes moved count.\n         AR    R5,R6               Finish total bytes moved for block.\n         ST    R5,BYTESMVD         And store it away for totalling.\n         LR    R7,R8               Set R7 to \"next write\" location.\n         ST    R7,SVBEGDAT         And store address for next fold.\n         B     FOLDFINE            Finish the fold\nFOLDFINE DS    0H\n* <-><->   fold trace\n         MVC   LINE,LINE-1\n         MVC   LINE+1(16),FOLDTRMS\n         MVC   LINE+18(3),=C'END'\n         HEX   LINE+22,4,BYTESMVD\n         HEX   LINE+32,4,SVBEGDAT\n         TM    FLAGSYST,X'02'\n         BNO   NOSYSMV2\n         PUT   SYSMOVED,LINE\nNOSYSMV2 DS    0H\n* <-><->   fold trace\n* --->\nFOLDFEND DS    0H\n*                                  Add FOLDBYTS and BYTESMVD to totals\n         LM    R4,R8,SAVEFOLD      Restore R4 thru R8 contents.\nFOLDEND  BR    R9                  Return to caller.\nFOLDMOVE MVC   0(*-*,R7),0(R3)      << EXECUTED >>\n         EJECT\n* ----------------------------------------------------------------- *\nAWSFBOUT DCB   DDNAME=AWSFBOUT,MACRF=PM,DSORG=PS,LRECL=80\nAWSVBIN  DCB   MACRF=GL,DDNAME=AWSVBIN,DSORG=PS,RECFM=VB,EODAD=FIN\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\n         DC    CL8' '\nFF       EQU   X'FF'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL6                     BLOCK HEADER\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRFLAG1 DC    X'00'                    FLAGS BYTE 1...\nHDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD\nHDRF1TMK EQU   X'40'                    ...TAPE MARK\nHDRF1EOR EQU   X'20'                    ...END OF RECORD\nHDRFLAG2 DC    X'00'                    FLAGS BYTE 2\n*\n         DC    XL80'00'                 PADDING\nOUTHEADR DC    XL6'00'\n* ----------------------------------------------------------------- *\n         DC    XL12'00'                 PADDING\nHALFZERO DC    XL2'00'\n         DC    XL12'00'                 PADDING\nHDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF\nHDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF\n         DC    XL12'00'                 PADDING\nBYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nCURRBFUL DS    0F\n         DC    H'0'\nCURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nLASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nREADFLAG DC    X'00'         This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nFLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE\n*              X'01'          //SYSTRACE DD IS THERE\n*              X'02'          //SYSMOVED DD IS THERE\n*              X'04'          //SYSFILES DD IS THERE\n* ---------- *\nHDRFLG   DC    X'00'               FLAG TO SHOW KIND OF HEADER\n*              X'01'         BEGINNING OF FILE - 0 PREV, X'A'\n*              X'02'         DATA RECORD - NOT 0 CURR, NOT 0 PREV, X'A'\n*              X'04'         END OF FILE - 0 CURR, NOT 0 PREV, X'4'\n*              X'08'         END OF TAPE - 0 CURR, 0 PREV, X'4'\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL\n*              X'00'          DATA IS NOT A LABEL\n*              X'01'          DATA IS A LABEL\n* ---------- *\nTPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark\n*              X'01'          We just read a Tape Mark\n*              X'02'          We previously read a Tape Mark\n* ---------- *\nFOLDFLAG DC    X'00'          Flag first time thru fold loop = X'00'\n*                             Flag is X'01' after the first time.\n* ---------- *\nFLAGHDRL DC    X'00'          Header label flag - Last label was a hdr\n*              X'01'          EOT HEADER is following a HDR1 or HDR2\n* ---------- *\n* -------------------------------------------- *\nFULLWORK DS    0F\nFULLHIGH DC    H'0'\nHALFWORK DC    H'0'                HALFWORD WORK AREA\n         DC    2F'0'               Padding\nFOLDBREG DS    0F                  Fullword - no of bytes to fold\nFOLDHIGH DC    XL2'00'             High order - should be zeros\nFOLDBYTS DC    XL2'00'             Number of bytes to fold\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCARDBACK DC    CL80' '\nLASTLI20 DS    0CL80\nLASTHX20 DC    80X'20'\nLASTLINE DS    0CL80\nLASTHX00 DC    80X'00'\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nDWORD    DC    D'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nINRCDS   DC    PL7'0'\nOUTRCDS  DC    PL7'0'\nEOTCNTR  DC    PL7'0'\nOUTHDRS  DC    PL7'0'\nOUTTYPE1 DC    PL7'0'\nOUTTYPE2 DC    PL7'0'\nOUTTYPE3 DC    PL7'0'\nOUTTYPE4 DC    PL7'0'\nFILCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nTPMKCNT  DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020202120'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL38\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Labels'\nDATDISPL DS    0CL38\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data  '\n*\nSAVEEN80 DS    F                     80 BYTES PAST RECORD END\nSAVEENDC DS    F                     RECORD END LOCATION\nSAVEBEGC DS    F                     RECORD BEGINNING LOCATION\n*\nSAVER1   DS    F                Save during OFFSET initialization\nSAVER2R  DS    F                Save work regs during tape read.\nSAVER3R  DS    F                Save work regs during tape read.\nSAVER3F  DS    F                Save work regs during FOLD TRACE.\nSAVER4B  DS    F                Register Save for HEX routine\nSAVER4Q  DS    F                Register Save for byte count reperting\nSAVEFOLD DS    6F               Register Save for FOLDEM routine\nSAVEADDC DS    3F               Register Save for ADDCOUNT routine\nSAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE\nBYTESMVD DS    F                Register Save for FOLDEM routine\nSAVER6M  DS    F                Register Save for FOLDEM routine\nSAVER7L  DS    F                Register Save for MAINLOOP routine\nSAVER9F  DS    F                Register Save for FOLDEM routine\nSAVER9K  DS    F                Register Save for FOLDEM routine\nOFFSET   DS    F                Number of bytes past beg of FB-80 buffr\nHDRBYTES DS    F\nHDRBSAVE DS    F\nCURBUFAD DS    F\nSVBEGDAT DS    F\nSVSAVBEG DS    F\nSAVER8C2 DS    F\n*  -----------------\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*  -----------------     JFCB if we'll need RDJFCB later - not used now\nJFCB1    DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\n         DC    C' '\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '\nPRMSG03  DC    CL34'     TOTAL BEGINNING HEADERS    : '\nPRMSG04  DC    CL34'     TOTAL MIDDLE FILE HEADERS  : '\nPRMSG05  DC    CL34'     TOTAL END OF FILE HEADERS  : '\nPRMSG06  DC    CL34'     TOTAL END OF TAPE HEADERS  : '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01  DC    CL38'   RECORDS FOLDED FOR FB OUTPUT:      '\nCTMSG02  DC    CL38'   RECORDS  READ  FOR VB INPUT :      '\nCTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '\nCTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '\nCTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '\nCTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '\nCTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '\nCTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2CNVU - AWS VB TO AWS FB-80 CONVERSION PROGRAM-\n                 '\nMESSAGE2 DC    CL133'1VTT2CNVU - AWS VB TO AWS FB-80 AWS TRACE REPORT '\nMESSAGE3 DC    CL133'1VTT2CNVU - AWS VB TO AWS FB-80 - TRACE AND ERROR -\n               REPORT  '\nMESSAGE4 DC    CL133'1VTT2CNVU - AWS VB TO AWS FB-80 - READ AND FOLD ST-\n               ATS  '\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    OFFSET ERROR           '\nINEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '\n         DC    C'TERMINATED '\n         DC    76C'*'\nINDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '\n         DC    82C'*'\n*  -----------------            Trace Message Texts\nREADTRMS DC    CL16'READ TRACE:     '\nFOLDTRMS DC    CL16'FOLD TRACE:     '\nMHDRTRMS DC    CL16'MAKEHEDR TRACE: '\nOSETTRMS DC    CL16'OFFSET TRACE:   '\nBBLKTRMS DC    CL16'BLOCK TRACE:    '\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nLINE     DC    CL133' '           For error messages\n         DC    C' '\nPRTLINE  DC    CL133' '\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\nSAVEHDR  DC    XL6'000000000000'\nEOTMARK  DC    XL6'000000004000'\n*    ------------------------ >   Byte Count Save Areas - below\n*\n*                          -- These are doubleword counters --\n*\nDBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ\nDBOUTFH  DC    F'0'\nDBOUTFL  DC    F'0'\nDBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED\nDBOUTFMH DC    F'0'\nDBOUTFML DC    F'0'\nDBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ\nDBOUTH   DC    F'0'\nDBOUTL   DC    F'0'\nDBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED\nDBOUTMH  DC    F'0'\nDBOUTML  DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\n         DC    CL8' '      Extra padding for safety\n*\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL20              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL3'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n         DC    F'0'               Align, just for the heck of it\nOUTCARDP DC    XL80'00'           Previous card-image read\nOUTCARD  DC    XL80'00'           Current  card-image read\nOUTCAEND EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2CN1#": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x005\\x01\\x01(\\x9f\\x01\\x014\\x8f\\t\\x18\\x00\\x0f\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2001-12-14T09:18:35", "lines": 15, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//AWSCNVT  EXEC PGM=VTT2CNVU\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSVBIN   DD  DISP=SHR,DSN=SBGOLOB.TST440.AWSIMAGE\n//AWSFBOUT  DD  DISP=SHR,DSN=SBGOLOB.AWSFB80\n//*WSFBOUT  DD  DISP=(NEW,CATLG,DELETE),DSN=SBGOLOB.AWSFB80,\n//*         DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//*         UNIT=SYSALLDA,SPACE=(TRK,(5,5),RLSE)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2DIS$": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x02\\x01\\x010\\x1f\\x01\\x046_\\x13\\x02\\x00\\x1f\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-10-28T00:00:00", "modifydate": "2004-12-30T13:02:02", "lines": 31, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2DISK)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,5),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2DISX(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2DIS#": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0e\\x00'\\x01\\x01(\\x9f\\x01\\x05\\x06\\x1f C\\x00\\x1c\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.14", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2005-03-02T20:43:27", "lines": 28, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Notes:  You can leave all the SYSIN parms out, and\n//*     CHUNKSIZE will default to 65535 (preferred),\n//*     If the new \"virtual tape file\" is Standard Labeled\n//*     (SL) and has a VOLSER, then the new VOLSER will be\n//*     the same as the input tape's VOLSER.\n//*     If the tape was produced originally on a 3490 with\n//*     IDRC compression and is SL, then a virtual 3480 drive\n//*     will not be able to read the tape unless you code\n//*     IDRCOFF, to remove the extra \"P\"s from the tape\n//*     labels, which MVS tape compression introduces.\n//*\n//AWSWRIT  EXEC PGM=VTT2DISK\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSOUT    DD  DISP=SHR,DSN=SBGOLOB.V467MW\n//TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=V467MU,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//SYSIN     DD  *\nIDRCOFF\nCHUNKSIZE=4096\nNEWVOL=V467MT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2DISK": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00 \\x01\\x00%O\\x01\\x05\\x00/\\x138\\t\\x8e\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2005-01-02T13:38:20", "lines": 2446, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2DISK -- READ A REAL TAPE AND CREATE FB-80 AWS FILE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE:  VTT2DISK.   Written by Sam Golob               **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to read in a tape, and create an      **\n**            MVS disk file in \"folded FB-80 AWS format\".   **\n**                                                          **\n**     The output of this program is intended to be input   **\n**     for the VTT2TAPE program.  These two programs,       **\n**     VTT2DISK and VTT2TAPE, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  OBSERVATION:  Although this program is purely an MVS    **\n**                program, the AWS-format output of this    **\n**     program can be downloaded to other systems where     **\n**     the file can actually be interpreted as an emulated  **\n**     tape.  This is one way of transferring tape data to  **\n**     other MVS systems that can read AWS-format tape      **\n**     files directly, as though they were tapes.           **\n**                                                          **\n**     For example, you can take mainframe-based tapes      **\n**     on real cartridges and create AWS-format tape        **\n**     files that can be read on a FLEX-ES system, a P/390  **\n**     or a Hercules-based MVS system.                      **\n**                                                          **\n**     Arbitrary chunk sizes for the AWS-format tape files  **\n**     are now supported.  If you are reading the output    **\n**     file on a Hercules-based system, you should          **\n**     rename its file name as *.het , because the HET      **\n**     emulator on Hercules recognizes chunked blocks.      **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     Tape data is read into a data buffer in this         **\n**     program.  Each block is read in, and its size        **\n**     is determined.  This size is compared to the         **\n**     chunk size, and a decision is made as to what        **\n**     to do.  An AWS header is made for each chunk.        **\n**     Each AWS header is folded into FB-80 output,         **\n**     and then the data is folded in afterward, until      **\n**     the block, and its associated AWS headers, are       **\n**     all folded in.  Then another tape block is read      **\n**     into the buffer, and the process repeats.            **\n**                                                          **\n**     When the tape file ends, and a tape mark is read     **\n**     in, an X'40' format AWS header is constructed.       **\n**     It is then folded into the FB-80 output dataset,     **\n**     after the last data.                                 **\n**                                                          **\n**     At the end of the tape, an end-of-tape AWS           **\n**     header is appended to the end of the output          **\n**     file and folded in.  The last FB-80 record           **\n**     is completed with hex zeros, if necessary.           **\n**                                                          **\n**     As a controversial measure, a full 80-byte record    **\n**     of hexzeros is appended at the end of the file.      **\n**                                                          **\n**     All of the \"FB-80 folding\" work is now done by the   **\n**     sub-program called FOLDEM.  The FOLDEM program       **\n**     operation is completely controlled by a control      **\n**     block called the FLDAREA control block, which does   **\n**     all of the communication between the main program    **\n**     and the FOLDEM sub-program.  Therefore, monitoring   **\n**     of the folding process is now possible purely by     **\n**     displaying the current status of the FLDAREA         **\n**     fields.  A convenient routine for displaying the     **\n**     status of the FLDAREA fields is the FLDIMAGE         **\n**     routine in either program, which is invoked by:      **\n**                                                          **\n**     BAL   R9,FLDIMAGE                                    **\n**                                                          **\n**     Therefore the fold monitoring displays that used     **\n**     to be in the SYSMOVED DD name, are now obsolete.     **\n**                                                          **\n**     There are two more fields in the FLDAREA control     **\n**     block than in the UNFAREA control block of the       **\n**     UNFOLDEM sub-program that VTT2TAPE uses.  These      **\n**     are:                                                 **\n**                                                          **\n**           FLDBYTOT - bytes left in buffer after the      **\n**                      last chunk of data was folded       **\n**           FLDREADF - propagation of the \"read only\"      **\n**                      flag into the sub-program           **\n**                                                          **\n**     These extra fields are obviously not required by     **\n**     the unfolding process.  The first one is not         **\n**     required because you're doing \"unchunking\" instead   **\n**     of \"chunking\", and you read the existing chunks      **\n**     as they come in; you're not required to create       **\n**     them.  The second one is not required because the    **\n**     main program writes the output (a tape) instead of   **\n**     the sub-program writing the output (an FB-80 file).  **\n**     So in our case, if no output is to be written, the   **\n**     sub-program must know about it.                      **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**     In order to make sure that the VTT2DISK program      **\n**     is doing its job properly, it produces a lot of      **\n**     trace data and status data, as it is creating        **\n**     the folded FB-80 AWS format tape.  In order not      **\n**     to clutter the summary report, most of this          **\n**     data is written to \"Optional DDNAMEs\".  Starting     **\n**     with version 1.12 of this program, most of the       **\n**     trace data now consists of the state of the FLDAREA  **\n**     control block fields at various stages of program    **\n**     execution.                                           **\n**                                                          **\n**     If you have access to the source code (you are       **\n**     reading it), you can introduce an instruction:       **\n**                                                          **\n**           BAL   R9,FLDIMAGE                              **\n**                                                          **\n**     at any point in the program, as long as SYSPRINT     **\n**     is open.  This should produce any diagnostics you    **\n**     may need, because all FLDAREA fields are displayed.  **\n**                                                          **\n**     Optional DDNAMEs don't have to be coded in the       **\n**     JCL.  But if they are coded, they will contain       **\n**     the extra trace data which VTT2DISK produces,        **\n**     and the SYSFILES ddname will contain a detailed      **\n**     \"file by file\" report.                               **\n**                                                          **\n**     The SYSFILES report is very useful if you want       **\n**     to do a \"dry run\", with the READ parameter.  If      **\n**     you want to know the structure of a tape without     **\n**     creating the FB-80 output file, the SYSFILES         **\n**     report will tell you what files are on the tape.     **\n**     It will also give you an indication of how big an    **\n**     FB-80 output file you will need on an MVS disk,      **\n**     to contain all the tape data.  See below for         **\n**     details.                                             **\n**                                                          **\n**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **\n**     and SYSIN.  SYSMOVED is now obsolete, although       **\n**     it will produce a dummy report if it is present      **\n**     in the JCL.                                          **\n**                                                          **\n**     SYSIN data is necessary if optional parameters       **\n**     are to be entered, such as:                          **\n**                                                          **\n**     CHUNKSIZE=nnnn                                       **\n**     NEWVOL=volser                                        **\n**     READ                                                 **\n**     IDRCOFF                                              **\n**                                                          **\n**     SYSIN keywords have to start in column 1.            **\n**                                                          **\n**     Either READ or IDRCOFF can also be entered in the    **\n**     PARM field of the EXEC card in the JCL.              **\n**                                                          **\n**     Full JCL to run the VTT2DISK program is as           **\n**     follows:                                             **\n**                                                          **\n**     //   jobcard                                         **\n**     //AWSREAD  EXEC PGM=VTT2DISK                         **\n**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **\n**     //*AWSOUT   DD  DSN=fb80.folded.aws.file,DISP=SHR    **\n**     //*        .... if the file is preallocated ....     **\n**     //AWSOUT    DD  DSN=fb80.folded.aws.file,            **\n**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **\n**     //          VOL=SER=volxxx,                          **\n**     //          SPACE=(CYL,(mm,nn),RLSE)                 **\n**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **\n**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **\n**     //          LABEL=(1,BLP,EXPDT=98000)                **\n**     //SYSPRINT  DD  SYSOUT=*                             **\n**     //SYSFILES  DD  SYSOUT=*                             **\n**     //SYSTRACE  DD  SYSOUT=*                             **\n**     //SYSUDUMP  DD  SYSOUT=*                             **\n**     //SYSIN     DD  *                                    **\n**     keywords in column 1                                 **\n**     /*                                                   **\n**                                                          **\n**     where you can leave out SYSTRACE and SYSUDUMP        **\n**     if you want to.  I'd strongly suggest including      **\n**     (at least) SYSFILES, though.                         **\n**                                                          **\n**     SYSTRACE takes a picture of the tape buffer at       **\n**     READ time, and takes a picture of the AWS headers    **\n**     and the FLDAREA control block fields at the time     **\n**     the headers are made.  Since the folding is now      **\n**     done by the FOLDEM subprogram, SYSMOVED, which       **\n**     used to track the data folding process, is now       **\n**     not necessary.  Of course SYSUDUMP is there to       **\n**     contain the MVS-produced dump, upon any abnormal     **\n**     termination of the program.                          **\n**                                                          **\n**     SYSFILES gives you block counts and byte counts      **\n**     for all files read and written.                      **\n**                                                          **\n**     In the SYSPRINT report, there is a count of total    **\n**     number of 80-byte records which the program will     **\n**     (or has) put out.  If you are doing a READ only      **\n**     run, and want to allocate an output file which is    **\n**     the right size, you might use this number, together  **\n**     with the BLKnnnn command from File 296 of the CBT    **\n**     Tape, to produce the following result:               **\n**                                                          **\n**     Say, our program produces:                           **\n**                                                          **\n**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **\n**                                                          **\n**     And you want to allocate space on a 3390.  So you    **\n**     would say:                                           **\n**                                                          **\n**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **\n**                                                          **\n**     Which comes up with the result:                      **\n**                                                          **\n** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **\n**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.1 - Make sure program works properly        **\n**       folding the data from the input buffer into FB-80. **\n**                                                          **\n**    Version 1.2 - Level number in the report headings.    **\n**                                                          **\n**    Version 1.3 - Not stopped by null SL tape file.       **\n**                                                          **\n**    Version 1.4 - Byte count and cum byte count report    **\n**       in SYSFILES.  Differentiate between label bytes    **\n**       and data bytes in the reports.                     **\n**                                                          **\n**    Version 1.5 - Block counts for each file and for the  **\n**       entire tape.                                       **\n**                                                          **\n**    Version 1.6 - Fix a reporting problem with block      **\n**       counting.                                          **\n**                                                          **\n**    Version 1.7 - Allow PARM=READ, just to get stats.     **\n**                                                          **\n**    Version 1.8 - Make file-level stats reporting into    **\n**       a subroutine.  Fix a bug in cumulative data byte   **\n**       reporting.                                         **\n**                                                          **\n**    Version 1.9 - End program if error on input tape.     **\n**       If input tape is AWS with bad headers, break the   **\n**       loop upon thinking you have an infinite number of  **\n**       tape marks on input.                               **\n**                                                          **\n**    Version 1.9A - Accommodate 4 character version level. **\n**       Add extra line of ASCII blanks (X'20') to the      **\n**       output, to make Hercules happy, and to detect      **\n**       end-of-tape more easily.                           **\n**                                                          **\n**    Version 1.10 - PARM of IDRCOFF will turn off IDRC     **\n**       indicators in the VOL1, HDR2, EOF2, EOV2 labels.   **\n**                                                          **\n**    Version 1.11 - Last line has hexzeros instead of      **\n**       hex 20 as fillers.  It makes Hercules happier.     **\n**                                                          **\n**    Version 1.12 - Re-architected program to use FOLDEM   **\n**       sub-program for data moves.  The FOLDEM program    **\n**       is driven by the FLDAREA control block, so the     **\n**       trace data consists mostly of the state of the     **\n**       FLDAREA control block fields.  A routine called    **\n**       FLDIMAGE will print all the FLDAREA control block  **\n**       fields on a single SYSPRINT line.                  **\n**                                                          **\n**       Added the possibility of coding program options    **\n**       in the SYSIN DD, which is used if it is present    **\n**       in the JCL.  SYSIN keywords, which must be coded   **\n**       to start in column 1, are currently:               **\n**                                                          **\n**       CHUNKSIZE=nnnn                                     **\n**       NEWVOL=volser                                      **\n**       READ                                               **\n**       IDRCOFF                                            **\n**                                                          **\n**       Added CHUNKSIZE=nnnn SYSIN keyword to allow the    **\n**       creation of \"chunked AWS tape files by this        **\n**       program.  The AWS tape file architecture allows    **\n**       for unlimited tape block sizes, if the blocks      **\n**       are broken into \"chunks\" of 65535 bytes or less,   **\n**       separated by AWS headers.  IBM's original AWS      **\n**       tape standard used to require a maximum chunk      **\n**       size of only 4096 bytes.  In this program, 65535   **\n**       bytes is the default chunk size, but this value    **\n**       can be adjusted at assembly time by setting a      **\n**       global variable.                                   **\n**                                                          **\n**       The NEWVOL=volser keyword in SYSIN, allows you     **\n**       to change the volser in the VOL1 label of the      **\n**       output AWS-format tape file.                       **\n**                                                          **\n**       Now, the READ and IDRCOFF keywords of the EXEC     **\n**       PARM field, can also be coded in SYSIN.  They      **\n**       must begin in column 1.  READ allows a dry run     **\n**       of the program which reads the input tape and      **\n**       reports statistics, but which does not produce     **\n**       an output FB-80 AWS file.                          **\n**                                                          **\n**       IDRCOFF looks in the tape standard labels, if      **\n**       there are any, and turns off any \"P\" indicators    **\n**       which tell MVS that this tape was produced on      **\n**       an IDRC-enabled tape drive.  Since the output      **\n**       FB-80 file is not compressed anyway, one wants     **\n**       the power to read the AWS-format tape file on a    **\n**       logical 3420 or 3480 tape drive, without MVS       **\n**       telling you that \"the tape has compressed files    **\n**       and I can't read it\" on this particular drive.     **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.  *\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n         GBLC  &DEFCHKC\n         GBLA  &DEFCHNK\n&LLEV    SETC  '1.12'\n* ------------------------------------------------------------------ *\n*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *\n*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *\n* ------------------------------------------------------------------ *\n&DEFCHNK SETA  65535\n&DEFCHKC SETC  '&DEFCHNK'\n         YREGS\n         EJECT\n** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **\nVTT2DISK CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2DISK AMODE 24\nVTT2DISK RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2DISK - REAL TAPE TO FOLDED FB-80 AWS DISK FILE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001-2005 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2DISK,R12,R11,R10,R8,R7\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LA    R7,4095(,R8)\n         LA    R7,1(,R7)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n* ----- >                            Parms          <--- below\n         L     R1,0(R1)              Get PARM field\n         CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BE    COPYREAD              Yes. Turn on indicator.\n         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?\n         BE    COPYIDRF              Yes. Say that.\n         B     COPYTAPE              No. Just go on with processing.\nCOPYREAD DS    0H                    READ only?\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     COPYTAPE\nCOPYIDRF DS    0H                    IDRC indicators off?\n         OI    IDRCFLAG,X'01'        Yes. Turn on flag.\n         B     COPYTAPE\n*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.\nCOPYTAPE DS    0H\n* ----- >                            Parms          <--- above\n*\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE3+88(31),HEADDLIT\n         MVC   MESSAGE4+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE2+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE3+61(21),LEVELLIT\n         MVC   MESSAGE4+61(21),LEVELLIT\n***********************************************************************\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants\n         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.\n         MVC   FULLHIGH(2),=X'0000'\n         MVC   CURRBYTE(2),=X'0000'\n         MVC   LASTBYTE(2),=X'0000'\n         MVC   HDRSIZE(4),=F'6'      Set size of header globally.\n         MVC   FLDOFFST(4),=F'0'     Offset is initially zero\n         LA    R1,OUTCARD            Let FOLDEM know about AWSOUT area\n         ST    R1,FLDSCARD           Beginning of card image output\n         ST    R1,SVBEGCRD\n         LA    R1,80(,R1)            Find end of card\n         ST    R1,FLDECARD           And store it away for the duration\n         ST    R1,SVENDCRD\n         L     R1,=A(INAREA)         Get address of input buffer\n         ST    R1,SVBFAREA           And save it away.\n         ST    R1,FLDBUFFR           Prime these fields\n         ST    R1,FLDBSTRT\n         L     R0,=F'&DEFCHNK'       Set default chunk size.\n         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.\n         ZAP   FLDOUTCT,=P'0'        Zero count of AWSOUT records.\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n* ----------------------------------------------------------------- *\n* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *\n* ----------------------------------------------------------------- *\n*\n         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.\n*\n* ----------------------------------------------------------------- *\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n* - - - ->  Chunk Size Message - - - ->   below\n*    The purpose of this code is to fill MESSAG14 with information.\n         L     R1,CHNKSIZE                  Load binary Chunk Size\n         XC    DWORD,DWORD                  Clear DWORD to zeros.\n         CVD   R1,DWORD                     Convert to decimal.\n         OI    DWORD+7,X'0F'                Make sign readable.\n         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message\n         ED    MESSAG14+28(8),DWORD+4       Edit the number\n         B     AFCHKDSP                     Branch past constant\nCHPATTRN DC    X'4020202020202120'          8 bytes of pattern\nAFCHKDSP DS    0H\n* - - - ->  Chunk Size Message - - - ->   above\n         TM    READFLAG,X'01'        Read Only run?\n         BO    NOAWSOUT              Yes. Don't OPEN AWSOUT.\n         OPEN  (AWSOUT,(OUTPUT))\nNOAWSOUT DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (TAPIN,(INPUT))\n*--->>\n         MVC   MSGLINE1,MSGLINE1-1   Clear optional\n         MVC   MSGLINE2,MSGLINE2-1      message lines\nREADIDRC DS    0H\n         TM    READFLAG,X'01'        READ only run?\n         BZ    IDRCMSG\nREADMSG  DS    0H\n         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'\nIDRCMSG  DS    0H\n         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?\n         BZ    ENDEXMSG\n         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'\nENDEXMSG DS    0H\n*--->>\nTRACERPT DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE      Blank Line\n         PUT   SYSTRACE,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    TRACENOI\n         PUT   SYSTRACE,MSGLINE2     IDRC remove message\nTRACENOI DS    0H\n         PUT   SYSTRACE,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\nTRACDESC DS    0H\n         PUT   SYSTRACE,MESSAGE8\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE5\n         PUT   SYSTRACE,MESSAGE6\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAG11\n         PUT   SYSTRACE,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE7\n*--->>\nMOVEDRPT DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE      Blank Line\n         PUT   SYSMOVED,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    MOVEDNOI\n         PUT   SYSMOVED,MSGLINE2     IDRC remove message\nMOVEDNOI DS    0H\n         PUT   SYSMOVED,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAGE9\n         PUT   SYSMOVED,MESSAG10\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAG11\n         PUT   SYSMOVED,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n*--->>\nFILESRPT DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE      Blank Line\n         PUT   SYSFILES,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    FILESNOI\n         PUT   SYSFILES,MSGLINE2     IDRC remove message\nFILESNOI DS    0H\n         PUT   SYSFILES,MESSAG14\n*--->>\nNOSYSFIL DS    0H\n* ----------------------------------------------------------------- *\n*   Now do the same for SYSPRINT report, which is always there.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         PUT   SYSPRINT,OUTLINE      Blank Line\n         PUT   SYSPRINT,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    PRINTNOI\n         PUT   SYSPRINT,MSGLINE2     IDRC remove message\nPRINTNOI DS    0H\n         PUT   SYSPRINT,MESSAG14\n*--->>\n*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.\n*        BAL   R9,FLDIMAGE\n*--->>\n* ----------------------------------------------------------------- *\nTAPEREAD DS    0H                      READ a new tape block.\n* ----------------------------------------------------------------- *\n*   You come here every time you do a tape READ.\n* ----------------------------------------------------------------- *\n         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks\n         BAL   R9,READBLOK             Read a block of data\n         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?\n         BO    MAINTPMK                Yes. Take appropriate action.\n* --- >\n         L     R1,CURRBFUL             Fullword number of bytes read\n         C     R1,CHNKSIZE             Bigger than chunk size?\n         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.\n         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.\n         NI    BUFINISH,FF-X'01'       Turn \"buffer finished\" flag off\n         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer\n         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved\n         B     AFTRCHNK                Jump over other alternative\nNOCHUNKS DS    0H\n         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.\n         OI    BUFINISH,X'01'          Buffer is finished in one shot.\n         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total\n         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total\n* --- >                                Label check if HDR - below\nAFTRCHNK DS    0H\n         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?\n         BNE   MAINNOTL                No. Can't be a label.\n         BAL   R9,LABELCHK             Check for labels and their kind.\n         TM    ISLBLFLG,X'01'          Is this record a label?\n         BZ    MAINNOTL                No. Bypass flag setting.\n         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?\n         BZ    MAINNOTH                Neither. Check if EOF or EOV.\n         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.\nMAINNOTH DS    0H\n         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?\n         BZ    MAINNOTL                No. Don't turn off flag.\n         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.\nMAINNOTL DS    0H\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW\n** -->              stuff below is only done per READ.\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,CURRBFUL          Load Current READ Byte Count\n         LA    R3,DBOUTF            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUT             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n** -->              stuff above is only done per READ.\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE\n* --- >                                Label check if HDR - above\n**-------------------------------------------------------------------**\nFOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL\n*                                   THE BUFFER IS EXHAUSTED.\n         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields\n         MVC   FLDECARD,SVENDCRD\n         L     R3,=A(INAREA)           Point to the data buffer\n         ST    R3,FLDBUFFR             Initialize\n         ST    R3,FLDBSTRT                 FLDAREA fields\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n*                                      because we'll have to fold the\n*                                      newly manufactured header.\n**-------------------------------------------------------------------**\nFOLDLOOP DS    0H\n         L     R1,FLDBYTOT          Compare bytes remaining to fold\n         C     R1,CHNKSIZE          To the chunk size.\n         BH    FOLDNCHK             If now less than or equal\n         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off\n         OI    BUFINISH,X'01'       And turn \"buffer finished\" flag on\n         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.\nFOLDNCHK DS    0H\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n         BAL   R9,MAKEHEDR             Create a header with READ info\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER               Point to address of this header\n         ST    R3,FLDBUFFR             Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF             And fold it into FB-80.\n         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA\n         MVC   FLDBYMVD,=F'0'          Initialize bytes folded\n         BAL   R9,FOLDBUFF             And fold it into the output.\n         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block\n** ---------- >>    Record the number of bytes folded - below\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,FLDBYMVD          Load Current folded Byte Count\n         LA    R3,DBOUTFM           Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUTM            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOFLDCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2\n** ---------- >>    Record the number of bytes folded - above\n         TM    CHNKFLAG,X'01'          Are we doing chunks?\n         BZ    TAPEREAD                No. Do another tape read.\n         TM    BUFINISH,X'01'          Have we finished this block?\n         BO    TAPEREAD                Yes. Read another block.\n         B     FOLDLOOP                No. Fold more chunks.\n*\nMAINTPMK DS    0H                   Last read was a T.M.\n         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         BAL   R9,MAKEHEDR          Make a header to show EOF.\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header\n         BAL   R9,REPTFILE          Report Block and Byte Counts\n*--->>\n         MVC   DBOUTF(8),=D'0'      Zero File Byte Count\n         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count\n         ZAP   BLOCKCNT,=P'0'       Zero File Block Count\n*--->>\n         B     TAPEREAD             Read in another tape block.\n*\n* ---------------------------------------------------------------- *\n*          END OF INPUT AWS DATA                                   *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         OI    TPMKFLAG,X'01'       Force Tape Mark indication.\n         BAL   R9,MAKEHEDR          Make EOT header\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\nBREAKLUP DS    0H\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk\n         TM    READFLAG,X'01'       READ only?\n         BO    NOPUT01              Yes. No output to AWSOUT.\n         PUT   AWSOUT,OUTCARD       And write out the last buffer.\n         MVC   OUTCARD(80),LASTLINE Add an extra card of hex zeroes\n         PUT   AWSOUT,OUTCARD       And put it out too.\nNOPUT01  DS    0H\n         AP    FLDOUTCT,=P'1'       Count the record PUT out.\n         AP    FLDOUTCT,=P'1'       Count the extra record of blanks\nWRITSUMM DS    0H\n         BAL   R9,SUMMREPT          Print the summary report.\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\nCLOSEMAL DS    0H                   Close em all.....\n         CLOSE TAPIN\n         TM    READFLAG,X'01'       Is this a READ only run?\n         BO    NOAWSCLS             Can't CLOSE what ain't OPEN.\n         CLOSE AWSOUT\nNOAWSCLS DS    0H\n         CLOSE SYSPRINT\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n*\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nSCNSYSIN DS    0H                 Routine to extract info from SYSIN.\n         ST    R9,SAVER9SC\n* -------------- >>>>>>   Look for SYSIN cards            - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    SCNSYSIE             No. Then can't open it. So get out.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BE    SYSNWVOL              Yes. Go process the new volume.\n         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?\n         BE    SYSCHUNK                    Looks that way.....\n         CLC   =C'READ ',GETSYSIN\n         BE    SYSREAD\n         CLC   =C'IDRCOFF ',GETSYSIN\n         BE    SYSIDRCO\n         B     SYSINLUP              Look for another card.\nSYSNWVOL DS    0H\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         B     SYSINLUP\nSYSCHUNK DS    0H\n         CLI   GETSYSIN+10,C' '  Is the first number value blank?\n         BE    SYSINLUP          Yes. Ignore entire card.\n         CLI   GETSYSIN+10,X'F0' Smaller than zero?\n         BL    SYSINLUP          Yes. Get another card.\n         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?\n         BH    SYSINLUP          Yes. Get another card.\n         OI    FLAGCHNK,X'01'    Show chunk size default was changed.\n         LA    R15,GETSYSIN+10   Now get the number that was coded.\n         LR    R1,R15            Load R1 with beginning of the number.\nSYSCHNUM DS    0H\n         LA    R15,1(,R15)       Bump to next character.\n         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?\n         BH    SYSCHGNM          Yes. Go get the number.\n         CLI   0(R15),C' '       Not end of card. But is it a blank?\n         BE    SYSCHGNM          Yes. Then get the number.\n         B     SYSCHNUM          Not a blank yet. Step up one place.\nSYSCHGNM DS    0H\n         SR    R15,R1            How many digits is the number?\n         BCTR  R15,0             Lower it by one for EXECUTE.\n         EX    R15,PACK          Copy the number to work area.\n         CVB   R0,WORKA          Convert it to a binary number.\n         ST    R0,CHNKSIZE       And store the value for later use.\nSYSCHCLG DS    0H\n         B     SYSINLUP          Go look for another card.\nSYSREAD  DS    0H\n         OI    READFLAG,X'01'\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     SYSINLUP\nSYSIDRCO DS    0H\n         OI    IDRCFLAG,X'01'\n         B     SYSINLUP\nSYSINEND DS    0H                No more cards. Close SYSIN DCB.\n         CLOSE SYSIN\n* -------------- >>>>>>   Look for SYSIN cards            - ABOVE\nSCNSYSIE DS    0H\n         L     R9,SAVER9SC\n         BR    R9\n* - - >\nPACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>\nWORKA    DC    D'0'\n* - - >\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*     Routine to read a block of data from the input tape\n*     and save byte counts from it, to make the AWS headers.\n* ----------------------------------------------------------------- *\nREADBLOK DS    0H\n         ST    R9,SAVER9RB        Save BAL register\n         ST    R2,SAVER2R         Store work registers\n         ST    R3,SAVER3R\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Read\n         WAIT  ECB=INECB          Wait for Read\n         TM    INCSW+4,X'01'      Was TM Read?\n         BO    READTPMK           Yes\n         CLI   INECB,X'7F'        Did Read complete normally?\n         BNE   INERR              No -- error\n         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.\n         AP    BLOCKCNT,=P'1'\n         AP    BLOCKTOT,=P'1'\n         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read\n         XC    FULLWORK,FULLWORK   Clear area completely\n         MVC   HALFWORK(2),INCCW+6   Read length\n         L     R2,FULLWORK           Load R2 with full low order\n         MVC   HALFWORK(2),INCSW+6   Residual byte count\n         L     R3,FULLWORK           Load R3 with full low order\n         SR    R2,R3              R2=Actual length read\n         STH   R2,BYTESCOP        Save quantity of bytes copied\n         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block\n         NI    ISLBLFLG,X'FF'-X'01'  Turn off \"IS LABEL\" flag\n         OI    NWBLKFLG,X'01'        Turn on \"new block\" flag\n         B     READNOTM           This READ was not a Tape Mark\n*\nREADTPMK DS    0H                 This READ was a Tape Mark\n         TM    TPMKFLAG,X'01'     Check if there was another TM before\n         BZ    READTFST           No. First one.\n         OI    TPMKFLAG,X'02'     If two in a row, flag that situation\nREADTFST DS    0H\n         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?\n*\n* --- >                           Null SL file is not EOT - below\n         BNO   NOFIN1               Not 2 T.M. in a row. Go on.\n         TM    FLAGHDRL,X'01'       Test if HDR label was last seen\n         BO    NOFIN0               Yes. Must be null SL file.\n         B     FIN                  Otherwise, valid 2 TMs and EOT.\nNOFIN0   DS    0H\n         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.\nNOFIN1   DS    0H\n* --- >                           Null SL file is not EOT - above\n*\n         AP    FILCOUNT,=P'1'     Add 1 to File Count.\n         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.\n         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.\nREADNOTM DS    0H\n* ---->     for the trace            All READ results should come here\n         MVC   LINE,LINE-1           Clear output line\n         MVC   LINE+1(16),READTRMS   Put in Read Trace message\n         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?\n         BZ    ITSABLOC              No. Mark trace as for a block.\n         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.\n         B     ITSATPMK              And go farther.\nITSABLOC DS    0H\n         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block\nITSATPMK DS    0H\n         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ\n         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header\n         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header\n         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag\n         HEX   LINE+40,6,HEADER      Show the Header last constructed\n         HEX   LINE+56,30,INAREA     Show first 20 bytes of Input Area\n         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?\n         BNO   NOREADT1              No. Can't print trace line.\n         PUT   SYSTRACE,LINE\nNOREADT1 DS    0H                    Trace is finished.\n* ---->     for the trace\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R\n         B     READBEND           and exit normally.\n* -----\nINERR    DS    0H                 READ error on input tape\n         MVC   LINE,LINE-1        Clear print line\n         TM    INCSW+4,X'02'      Unit Check?\n         BZ    INERR1             No - Assume Data Check\n         MVC   LINE(133),INEQC    Set Error Message\n         B     INERR2             Continue\nINERR1   MVC   LINE(133),INDCK    Set Error Message\nINERR2   PUT   SYSPRINT,LINE      Write Error Message\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R         Rewind the tape, and exit.\n         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Rewind and Unload\n         WAIT  ECB=INECB          Wait for Rewind and Unload\n         B     WRITSUMM           Write summary of what was done,\n*                                  and get out of the program.\nREADBEND DS    0H\n         L     R9,SAVER9RB        Restore BAL register\n         BR    R9\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nMAKEHEDR DS    0H\n         ST    R9,SAVER9MH\n* ----------------------------------------------------------------- *\n*     We are forming the new header in the field HEADER.\n*     We assume that the TAPEREAD subroutine was executed first.\n*     We assume that the FLDAREA was previously saved to SAVAREA.\n* ----------------------------------------------------------------- *\n         MVC   HEADER(6),=XL6'00'      Start fresh.\n         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header\n         MVC   HDRNSTOR(1),SAVBYTES+3     Reverse\n         MVC   HDRNSTOR+1(1),SAVBYTES+2      bytes\n         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot\nMAKEWHAT DS    0H                      Manufacture the proper hdr flags\n         TM    TPMKFLAG,X'01'          Has a tape mark been read?\n         BO    MAKE40                  First test. Make a X'40' header\n         TM    NWBLKFLG,X'01'          First chunk of current block?\n         BO    MAKE80                  Yes. Turn on X'80' bit.\n         TM    BUFINISH,X'01'          Last chunk of current block?\n         BO    MAKE20                  Yes. Turn on X'20' bit.\n         B     MAKE00                  No. Don't turn on any flag bits.\nMAKE80   DS    0H\n         OI    HDRFLAG1,X'80'          Turn on X'80'\n         B     MAKE20                  And see if X'20' also, or not.\nMAKE00   DS    0H                      No HDRFLAG1 bits to be turned on\n         B     MAKEHDEN                And just get out.\nMAKE20   DS    0H\n         TM    BUFINISH,X'01'          Test again for last chunk.\n         BZ    MAKEHDEN                It isn't, so only X'80' is on.\n         OI    HDRFLAG1,X'20'          It is. So turn on X'20'.\n         B     MAKEHDEN\nMAKE40   DS    0H                      Tape mark has been read.\n         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.\n         MVI   HDRFLAG1,X'40'          HDRFLAG1 has to be X'40'\nMAKEHDEN DS    0H\n         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN\n         AP    OUTHDRS,=P'1'           Count this header we've made.\n*----------------------------------------------------------------- *\n*   Now that we've made a header, we count how many of each type.\n*----------------------------------------------------------------- *\nKINDAHDR DS    0H\n         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?\n         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK\n         AP    OUTTYPE3,=P'1'         YES. COUNT THIS TYPE\n         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE\nKCHKBEG  DS    0H\n         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?\n         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.\n         AP    OUTTYPE1,=P'1'         YES. COUNT THIS TYPE\nKCHKEND  DS    0H\n         TM    HDRFLAG1,X'20'         END OF BLOCK?\n         BNO   KINDAH40               NO. CHECK IF END OF FILE\n         AP    OUTTYPE2,=P'1'         YES. COUNT THIS TYPE\nKINDAHA0 DS    0H\n         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?\n         BNE   KINDAH40               NO. TEST FOR EOF HEADER.\n         AP    OUTTYPE5,=P'1'         YES. COUNT IT FOR REPORTING.\n         B     KINDAHEN               AND DON'T TEST MORE BITS.\nKINDAH40 DS    0H\n         TM    HDRFLAG1,X'40'         END OF FILE HEADER?\n         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.\n         AP    OUTTYPE4,=P'1'         YES. COUNT THIS TYPE\n*\nKINDAHEN DS    0H\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE\n         MVC   OUTLINE+2(4),=C'hdr:'\n         HEX   OUTLINE+8,6,HEADER     FLDAREA at MAKEHEDR time display\n         HEX   OUTLINE+28,4,FLDSCARD                            .\n         HEX   OUTLINE+38,4,FLDECARD                            .\n         HEX   OUTLINE+48,4,FLDOFFST                            .\n         HEX   OUTLINE+58,4,FLDBYTES                            .\n         HEX   OUTLINE+68,4,FLDBYTOT                            .\n         HEX   OUTLINE+78,4,FLDBYMVD                            .\n         HEX   OUTLINE+88,4,FLDBUFFR                            .\n         HEX   OUTLINE+98,4,FLDBSTRT                            .\n         HEX   OUTLINE+108,7,FLDOUTCT                           .\n         HEX   OUTLINE+124,1,FLDREADF\n         HEX   OUTLINE+22,1,HDRFLAG1                            .\n         PUT   SYSTRACE,OUTLINE\nNOSYSTR1 DS    0H\nMAKEHEND DS    0H\n         L     R9,SAVER9MH\n         BR    R9\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*                                                           *\n*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *\n*                                                           *\n*    All FLDAREA field required for call have to be         *\n*    filled in:                                             *\n*                                                           *\n*    FLDSCARD - Initialized to OUTCARD at beg of program    *\n*    FLDECARD - Initialized to OUTCARD+80                   *\n*    FLDOFFST - Initialized to 0, updated by each call      *\n*    FLDBYTES - Set before each call                        *\n*    FLDBYTOT - Set before each call                        *\n*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *\n*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *\n*    FLDBSTRT - Start of input buffer                       *\n*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *\n*    FLDREADF - READFLAG, copied into FLDAREA control blk   *\n*                                                           *\n* --------------------------------------------------------- *\nFOLDBUFF DS    0H\n         ST    R9,SAVER9FB              Save BAL register\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call\n*        BAL   R9,FLDIMAGE\n         LA    R1,FLDAREA\n         L     R15,=V(FOLDEM)           Entry point of FOLDEM program\n         BALR  R14,R15                  Call it.\n*                                       Copy back FLDAREA from FOLDEM\n         ST    R1,NEWFLDA               Save new FLDAREA address\n         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call\n*        BAL   R9,FLDIMAGE\nFOLDBUFE DS    0H\n         L     R9,SAVER9FB              Restore BAL register\n         BR    R9                       Return to caller\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         ST    R9,SAVER9FI\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         L     R9,SAVER9FI\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE\n         ST    R9,SAVER9AD         Save BAL register\n         STM   R4,R5,SAVEADDC      Save work registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         LM    R4,R5,SAVEADDC      Restore work registers\nADDCOUNE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9AD         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LB          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   INAREA(3),=C'UHL'    This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRCV             NO. SKIP ROUTINE.\n         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRCV DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  YES. DON'T CHANGE.\n         LA    R1,INAREA                 Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\n         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.\n         TM    FLAGSYST,X'02'\n         BZ    NCHGMOVD\n         PUT   SYSMOVED,MESSAG13\nNCHGMOVD DS    0H\n         TM    FLAGSYST,X'04'            SYSFILES here?\n         BZ    NCHGFILE                  Nope. Skip a PUT to it.\n         PUT   SYSFILES,MESSAG13         VOLSER overridden message.\n         MVC   OUTLINE,OUTLINE-1         Blank line to separate\n         PUT   SYSFILES,OUTLINE             from the rest of output.\nNCHGFILE DS    0H\nNOCHGVOL DS    0H                        Kludge extra blank like\n         TM    FLAGSYST,X'04'            Is SYSFILES here?\n         BZ    KLUDGE01                  Nope. No PUTs to it.\n         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?\n         BNE   KLUDGE01                  Is overridden, no extra blank.\n         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank\n         PUT   SYSFILES,OUTLINE\nKLUDGE01 DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRH2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRH2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRH2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRF2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRF2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRF2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRv2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRV2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRV2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\nLABCHEND DS    0H                   Return to caller\n         L     R9,SAVER9LB          Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SR               Save BAL Register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG04\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG05\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE3   MIDDLE OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE4   END OF FILE HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG07\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE5   X'A0' HEADERS - BEG and END\n         PUT   SYSPRINT,OUTLINE\n* >---->                                 Display tape total counts\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTMH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST\n         L     R4,DBOUTML                LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD               AND ADD IT IN\n         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06       Total bytes read for data\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\nNOSUMM05 DS    0H\n* >---->\nSUMMREND DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SR         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n*----------->>\n         ST    R9,SAVER9RF\n*--->                   Block counts first  -  below\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n* >---->\n*--->                   Block counts first  -  above\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG01\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFMH        Bytes folded counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n* >--->\n         TM    ISLBLFLG,X'01'\n         BO    DISLABLS\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Data bytes written cumulative to here\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),DATDISPL\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),LABDISPL\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFH         Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         CLC   DBOUTF(8),DBOUTFM\n         BE    RIGHTBYT\n         MVI   CNTLINE+72,C'*'\nRIGHTBYT DS    0H\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBOUTH          Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\n*----------->>\nREPTFEND DS    0H\n         L     R9,SAVER9RF\n         BR    R9\n         EJECT\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\n*              read,addr of data,flags,64K bytes\nRUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW\n         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW\nINCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW\nINECB    DC    F'0'\nINIOB    DC    X'02000000'\n         DC    A(INECB)\nINCSW    DC    2F'0'\nINCCWPT  DC    A(INCCW)\nINDCBPT  DC    A(TAPIN)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            Padding\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY AWSOUT\nAWSOUT   DCB   DDNAME=AWSOUT,MACRF=PM,DSORG=PS,LRECL=80\nTAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X\n               EODAD=SYSINEND\n         DC    CL8' '\nFF       EQU   X'FF'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL6                     BLOCK HEADER\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRFLAG1 DC    X'00'                    FLAGS BYTE 1...\nHDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD\nHDRF1TMK EQU   X'40'                    ...TAPE MARK\nHDRF1EOR EQU   X'20'                    ...END OF RECORD\nHDRFLAG2 DC    X'00'                    FLAGS BYTE 2\n*\n         DC    XL80'00'                 PADDING\nOUTHEADR DC    XL6'00'\n* ----------------------------------------------------------------- *\n         DC    XL12'00'                 PADDING\nHALFZERO DC    XL2'00'\n         DC    XL12'00'                 PADDING\nHDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF\nHDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF\n         DC    XL12'00'                 PADDING\nBYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nCURRBFUL DS    0F\n         DC    H'0'\nCURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nLASTBFUL DS    0F\n         DC    H'0'\nLASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT\nPARTBFUL DS    0F\n         DC    H'0'\nPARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT\nZEROCARD DC    80X'00'\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nREADFLAG DC    X'00'         This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nNWBLKFLG DC    X'00'         We have just read a new block.\n*              X'01'         Turned off after first chunk write.\n* ---------- *\nIDRCFLAG DC    X'00'         This run is \"IDRC Fix\"  ?\n*              X'01'         Turn off IDRC indicator\n* ---------- *\nFLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED\n*              X'01'          CHUNK SIZE IS NOT BLANK\n* ---------- *\nFLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE\n*              X'01'          //SYSTRACE DD IS THERE\n*              X'02'          //SYSMOVED DD IS THERE\n*              X'04'          //SYSFILES DD IS THERE\n*              X'08'          //SYSIN    DD IS THERE\n* ---------- *\nCHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?\n*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE\n* ---------- *\nBUFINISH DC    X'00'          Have we finished folding entire buffer?\n*              X'01'          Yes. We are now finishing the buffer.\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL\n*              X'00'          DATA IS NOT A LABEL\n*              X'01'          DATA IS A LABEL\n* ---------- *\nTPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark\n*              X'01'          We just read a Tape Mark\n*              X'02'          We previously read a Tape Mark\n* ---------- *\nFLAGHDRL DC    X'00'          Header label flag - Last label was a hdr\n*              X'01'          EOT HEADER is following a HDR1 or HDR2\n* ---------- *\n* -------------------------------------------- *\nFULLWORK DS    0F\nFULLHIGH DC    H'0'\nHALFWORK DC    H'0'                HALFWORD WORK AREA\n         DC    2F'0'               Padding\nFOLDBREG DS    0F                  Fullword - no of bytes to fold\nFOLDHIGH DC    XL2'00'             High order - should be zeros\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHNKSIZE DC    F'65535'            Default is maximum halfword\nLASTLINE DS    0CL80\nLASTHX00 DC    80X'00'\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nDWORD    DC    D'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nOUTHDRS  DC    PL7'0'\nOUTTYPE1 DC    PL7'0'\nOUTTYPE2 DC    PL7'0'\nOUTTYPE3 DC    PL7'0'\nOUTTYPE4 DC    PL7'0'\nOUTTYPE5 DC    PL7'0'\nFILCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nTPMKCNT  DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL38\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Labels'\nDATDISPL DS    0CL38\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data  '\n*\nSVBEGCRD DS    F\nSVENDCRD DS    F\nSVBFAREA DS    F                Address of input buffer\n*\nSAVER2R  DS    F                Save work regs during tape read.\nSAVER3R  DS    F                Save work regs during tape read.\nSAVER4B  DS    F                Register Save for HEX routine\nSAVER4Q  DS    F                Register Save for byte count reperting\nSAVEFOLD DS    6F               Register Save for FOLDEM routine\nSAVEADDC DS    3F               Register Save for ADDCOUNT routine\nSAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE\nSAVER9AD DS    F                Register Save for ADDCOUNT routine\nSAVER9RB DS    F                Register Save for READBLOK routine\nSAVER9RF DS    F                Register Save for REPTFILE routine\nSAVER9LB DS    F                Register Save for LABELCHK routine\nSAVER9SR DS    F                Register Save for SUMMREPT routine\nSAVER9FB DS    F                Register Save for FOLDBUFF routine\nSAVER9FI DS    F                Register Save for FLDIMAGE routine\nSAVER9SC DS    F                Register Save for SCNSYSIN routine\nSAVER9MH DS    F                Register Save for MAKEHEDR routine\nNEWFLDA  DS    F\nHDRSIZE  DC    F'6'             SIZE OF A HEADER\nSVBEGDAT DS    F\n*  -----------------\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*  -----------------     JFCB if we'll need RDJFCB later - not used now\nJFCB1    DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\n         DC    C' '\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '\nPRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS    : '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '\nCTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '\nCTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '\nCTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '\nCTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '\nCTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '\nCTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '\nCTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2DISK - REAL TAPE TO FB-80 AWS CONVERSION PROG-\n               RAM  '\nMESSAGE2 DC    CL133'1VTT2DISK  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE3 DC    CL133'1VTT2DISK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-\n               R REPORT  '\nMESSAGE4 DC    CL133'1VTT2DISK - TAPE TO AWS FILE REPORT - READ AND FOL-\n               D STATS  '\nMESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-\n               '\nMESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-\n               '\nMESSAGE7 DS    0CL133\n         DC    CL8'  hdr:  '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'FLDSCARD'\n         DC    CL10'FLDECARD'\n         DC    CL10'FLDOFFST'\n         DC    CL10'FLDBYTES'\n         DC    CL10'FLDBYTOT'\n         DC    CL10'FLDBYMVD'\n         DC    CL10'FLDBUFFR'\n         DC    CL10'FLDBSTRT'\n         DC    CL14'FLDINRCD'\n         DC    CL11' '\nMESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-\n                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-\n               DE. '\nMESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2DISK, THE SYSMOV-\n               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-\n                 '\nMESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-\n               EPORT.  BOTH \"TAPE READ\" AND \"FOLD DATA\" ARE AVAILABLE T-\n               HERE.'\nMESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -\n               HAVE SOURCE CODE, THEN UNCOMMENT THE \"BEFCALL-\" AND \"AFT-\n               CALL-\" '\nMESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-\n               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -\n                    '\nMESSAG13 DC    CL133'    VOLSER Overridden to:    '\nMESSAG14 DC    CL133'    Chunk Size is set to:    '\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    OFFSET ERROR           '\nINEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '\n         DC    C'TERMINATED '\n         DC    76C'*'\nINDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '\n         DC    82C'*'\n*  -----------------            Trace Message Texts\nREADTRMS DC    CL16'READ TRACE:     '\nFOLDTRMS DC    CL16'FOLD TRACE:     '\nMHDRTRMS DC    CL16'MAKEHEDR TRACE: '\nOSETTRMS DC    CL16'OFFSET TRACE:   '\nBBLKTRMS DC    CL16'BLOCK TRACE:    '\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nLINE     DC    CL133' '           For error messages\n         DC    C' '\nPRTLINE  DC    CL133' '\n         DC    C' '\nMSGLINE1 DC    CL133' '           For READ only message\n         DC    C' '\nMSGLINE2 DC    CL133' '           For IDRC remove message\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\nSAVEHDR  DC    XL6'000000000000'\nEOTMARK  DC    XL6'000000004000'\n* - - - - >\n*\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\n* - - - - >\n*         Saved Copy of FLDAREA Control Block\n* - - - - >\n*\nSAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nSAVSCARD DC    F'0'         Start address of 80-byte card\nSAVECARD DC    F'0'         End address of 80-byte card\nSAVOFFST DC    F'0'         OFFSET of data in the card\nSAVBYTES DC    F'0'         Number of bytes to be folded now\nSAVBYTOT DC    F'0'         Batch total of bytes left to move\nSAVBYMVD DC    F'0'         Number of bytes folded now\nSAVBUFFR DC    F'0'         Current data start address\nSAVBSTRT DC    F'0'         Original start data address\nSAVOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nSAVREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nSAVLENTH EQU   *-SAVAREA\n*\n* - - - - >\n*    ------------------------ >   Byte Count Save Areas - below\n*\n*                          -- These are doubleword counters --\n*\nDBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ\nDBOUTFH  DC    F'0'\nDBOUTFL  DC    F'0'\nDBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED\nDBOUTFMH DC    F'0'\nDBOUTFML DC    F'0'\nDBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ\nDBOUTH   DC    F'0'\nDBOUTL   DC    F'0'\nDBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED\nDBOUTMH  DC    F'0'\nDBOUTML  DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\n         DC    CL8' '      Extra padding for safety\n*\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n         DC    F'0'               Align, just for the heck of it\nGETSYSIN DC    CL80' '\nOUTCARDP DC    XL80'00'           Previous card-image read\nOUTCARD  DC    XL80'00'           Current  card-image read\nOUTCAEND EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         END\n   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'\nFOLDEM   CSECT\n*  ---------------------------------------------------------------  *\n*\n*   AUTHOR:       Sam Golob\n*\n*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,\n*                 subject to express permissions from the author\n*                 to use this software.  This software is part\n*                 of VTTS (Virtual Tape Transportation System).\n*\n*                 Permission is granted by the author for all\n*                 parts of the VTTS package which are distributed\n*                 on the CBT Tape collection, to be used by\n*                 anyone for their own use, but not for resale\n*                 or for reincorporation within commercial code.\n*\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    FOLDEM                                            *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating an      *\n*      AWS-format disk file from a real tape file.  The disk        *\n*      file is data that has been folded over from a buffer,        *\n*      into an FB-80 dataset.                                       *\n*                                                                   *\n*      This program takes buffer data and folds it into FB-80       *\n*      data, starting from a given buffer address, for a given      *\n*      number of bytes.  The data is folded into an 80-byte         *\n*      workarea starting from a given OFFSET address (+0 to +79)    *\n*      into the workarea.  When the workarea has been completely    *\n*      filled and more data is to be written, a PUT is done to      *\n*      write out the data from the 80-byte workarea, and then       *\n*      the workarea is cleared with binary zeros before any         *\n*      additional data is written to it.  An incompletely filled    *\n*      workarea is not written out, and the same is true if the     *\n*      workarea is full but no more data is to be written out.      *\n*      So in that case, the location of the workarea is returned    *\n*      to the caller in field FLDSCARD, and it is the caller's      *\n*      responsibility to do the PUT for the last card.              *\n*                                                                   *\n*  INPUTS and OUTPUTS:                                              *\n*                                                                   *\n*      This program is driven by a control block called FLDAREA,    *\n*      which is updated by both this program and by the caller.     *\n*      See below for more details.                                  *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called AWSOUT, which receives the output       *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do PUTs to AWSOUT, and if necessary, it needs       *\n*      to write messages to SYSPRINT.  Therefore the caller has     *\n*      to provide ENTRY AWSOUT and ENTRY SYSPRINT statements in     *\n*      front of its AWSOUT and SYSPRINT DCBs, respectively.         *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      FLDAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      FLDAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the caller's copy of FLDAREA, and upon return,      *\n*      R1 is pointed to the updated copy of FLDAREA in this         *\n*      subroutine.  So the caller has to copy it back over its      *\n*      own instance of FLDAREA after the return.                    *\n*                                                                   *\n*      The caller does one tape read, or read of data into a        *\n*      buffer.  From the number of bytes read, and possibly from    *\n*      the given chunk size also, the caller will construct an      *\n*      AWS header which will determine how many bytes should be     *\n*      folded into the FB-80 disk dataset.  This AWS header is      *\n*      also folded in by a call to this program, and then the       *\n*      tape data is folded in afterward, for the number of bytes    *\n*      required either by the chunk size or by the block size.      *\n*                                                                   *\n*      This program does one or more PUTs into the FB-80 file,      *\n*      until the request for the number of bytes to be folded,      *\n*      is satisfied.  A PUT is done whenever the FB-80 work area    *\n*      has been filled.  At the end of the fold operation, the new  *\n*      OFFSET into the FB-80 workarea (that has not yet been        *\n*      written out to disk), the number of bytes that have been     *\n*      folded, and the projected start of the next data to be       *\n*      folded, are returned in the fields of the FLDAREA control    *\n*      block.                                                       *\n*                                                                   *\n*      The following is the layout of the FLDAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *\n*      *                         ------ ---- ------- -----          *\n*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *\n*  --> FLDECARD DC    F'0'       End address of 80-byte card        *\n*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *\n*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *\n*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *\n*      FLDBYMVD DC    F'0'       Number of bytes folded now         *\n*  --> FLDBUFFR DC    F'0'       Current data start address         *\n*  --> FLDBSTRT DC    F'0'       Original start data address        *\n*      FLDOUTCT DC    PL7'0'     Number of PUTs for AWSOUT records  *\n*  --> FLDREADF DC    X'00'      This run is \"READ ONLY\"  ?         *\n*      *              X'01'      Yes, read only. (Copied from the   *\n*                                READFLAG byte in the caller.)      *\n*      FLDLENTH EQU   *-FLDAREA                                     *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      FLDBUFFR and FLDOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the input data      *\n*      and output data positions, respectively, that are just       *\n*      after the moved data, to anticipate the next call, so as     *\n*      to be able to move more data.  FLDBSTRT preserves the        *\n*      very beginning address of the input buffer, whereas          *\n*      FLDBUFFR is a place somewhere within the buffer, which       *\n*      is the start from where the new data is expected to be       *\n*      moved.                                                       *\n*                                                                   *\n*      A new field, FLDBYTOT, makes it easier to create chunked     *\n*      AWS-format tape files, when the chunksize is less than       *\n*      the blocksize.  This field originally (after a block is      *\n*      read into the buffer from the tape) contains the number      *\n*      of bytes in the entire block.  After each chunk of data      *\n*      is written, this field gets decremented by the number of     *\n*      bytes in the chunk just written.                             *\n*                                                                   *\n*      Since both the caller and this program do PUT operations     *\n*      to the output FB-80 file, the count of the number of PUTs    *\n*      done, FLDOUTCT, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nFOLDEM   AMODE 24\nFOLDEM   RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'FOLDEM'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING FOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,AWSOUTV            AWSOUT   DCB address in caller\n         ST    R0,AWOUTDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to fold buffer data into an FB-80 file, starting at     *\n*   a given location in the buffer, for a certain number of bytes,  *\n*   and starting at a given OFFSET in the 80-byte workarea to       *\n*   which the buffer data will be written.  When the 80-byte        *\n*   workarea is filled up, a PUT is done to AWSOUT, and the         *\n*   workarea is cleared with binary zeros for more data to be       *\n*   written.                                                        *\n*                                                                   *\n*   Input:   FLDAREA fields are all supplied by the calling         *\n*            program, except for FLDBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            caller's copy of FLDAREA is pointed to by Register 1.  *\n*                                                                   *\n*            The buffer area containing the data to be folded       *\n*            is supplied by the calling program, as well as the     *\n*            number of bytes that is expected to be folded.         *\n*                                                                   *\n*   Output:  Data from the buffer will be moved into the 80-byte    *\n*            workarea until the workarea is filled.  When the       *\n*            workarea is filled, a PUT will be done to AWSOUT,      *\n*            and the workarea is cleared to X'00's to make room     *\n*            for more data, when more data is to be written.        *\n*                                                                   *\n*            Ending OFFSET into the 80-byte workarea, pointing to   *\n*            just after the data which has been moved, is returned  *\n*            in the FLDOFFST field.  Upon return to the caller,     *\n*            the FLDBUFFR field is updated to point to the place    *\n*            in the buffer just after the data which has been       *\n*            moved.  The FLDBSTRT field always should point to the  *\n*            beginning of the data buffer, but this is at the       *\n*            discretion of the calling program.                     *\n*                                                                   *\n*            A count of bytes actually moved from the buffer to     *\n*            the 80-byte workarea (and written out by PUTs to the   *\n*            AWSOUT DD name as is necessary) is calculated by this  *\n*            program and returned in the FLDBYMVD field.  Upon      *\n*            return, the number in the FLDBYMVD field should match  *\n*            the number in the FLDBYTES field.                      *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nFOLDIT   DS    0H\n         L     R1,SAVEPARM          Load address of caller's FLDAREA\n         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA\n         USING FLDBLOCK,R2\n         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours\n* - - - - - - - - - -      Load the buffer quantities\n         L     R7,FLDBUFFR          Initialize start of buffer data\n         L     R8,FLDBYTES          Bytes to be moved\n         AR    R8,R7                Add in start buffer address\n         ST    R8,HYPOENDB          Hypothetical end-of-buffer address\n*                                   which is probably the real\n*                                   end-of-data to be moved.\n* - - - - - - - - - -      Load the card quantities\n         MVC   SAVEBEGC,FLDSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,FLDECARD    Save \"end of card\" address\n         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,FLDSCARD          Point to beginning of card\n         A     R7,FLDOFFST          Add OFFSET to start of output\n         ST    R7,SAVEBEGO          Save where output starts\n         L     R8,SAVEBEGO          Copy beg of output address\n         A     R8,FLDBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n         ST    R8,HYPOENDC          Store hypothetical card end address\n*                                   (This may be way past end of card.)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is to within the current card.        *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.  So we have to do     *\n*              iterations.                                        *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         L     R7,SAVEBEGO          Beginning of CARD data\n         L     R8,HYPOENDC          Hypothetical end of CARD data\n         L     R3,FLDBUFFR          Prime R3 with start of buffer data\n         C     R8,SAVEENDC          Is R8 past the end-of-card?\n         BH    LOOPMORE             Yes. Do multiple moves and PUTs.\nLOOPSHRT DS    0H                   No. Do the one move only.\n         LR    R6,R8                Get byte count to move NOW.\n         SR    R6,R7                Bytes to move from buffer to card\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data from buffer to card.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total bytes moved.\n         ST    R1,FLDBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,FLDBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET -\n         S     R6,FLDSCARD          Subtract beginning of card address\n         ST    R6,FLDOFFST          Store the result as new OFFSET\n* -- >\nLOOPTS50 DS    0H\n*                                   If OFFSET > X'4F', card is complete\n         C     R6,=F'80'            Is the new offset exactly X'50'?\n         BNE   LOOPNT50             No. Then current card not complete.\n*                                   Yes. Then PUT out card and init it.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT001             Yes. Can't PUT to AWSOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT001 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n         XR    R6,R6                Clear R6\n         ST    R6,FLDOFFST          New offset is 0, not X'50'\nLOOPNT50 DS    0H\n* -- >\n         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT\n         S     R1,FLDBYMVD          And subtract bytes already moved\n         ST    R1,FLDBYTOT          To show new total buffer byte count\n*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,FLDBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Test if past end of buffer\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,FLDBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT002             Yes. Then don't produce AWSOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT002 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE CALLER\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of FLDAREA in caller\n         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nFLDBLOCK CSECT\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\nFOLDEM   CSECT\nWORKAREA DS    CL80                 Card image work area\n         DC    CL4' '               Padding\n         DC    C' '\nLINE     DC    CL133' '             Output line\n         DC    C' '\nLINE2    DC    CL133' '             Second output line if needed\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGO DC    F'0'                 Save beg address of card output\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address\nHYPOENDC DC    F'0'                 Hypothetical end address after card\nHYPOENDB DC    F'0'                 Calculated end of buffer address\nSYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB\nAWSOUTV  DC    V(AWSOUT)            Address of AWSOUT DCB\nSYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here\nAWOUTDCB DC    F'0'                 AWSOUT DCB address stored here\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2FK2$": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00B\\x01\\x044?\\x01\\x044?\\x11\\x14\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2004-12-08T00:00:00", "modifydate": "2004-12-08T11:14:42", "lines": 30, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2FK2T)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2FK2T(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2FK2#": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x005\\x01\\x044?\\x01\\x05\\x06\\x1f E\\x00\\x13\\x00\\x0f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2004-12-08T00:00:00", "modifydate": "2005-03-02T20:45:35", "lines": 19, "newlines": 15, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Cut a \"real tape\" from a FLEX-ES Faketape virtual\n//*  tape image, which has been folded over on MVS into\n//*  FB (fixed blocked) LRECL=80 format.\n//*\n//AWSREAD  EXEC PGM=VTT2FK2T PARM=READ\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//FAKEIN    DD  DISP=SHR,DSN=SBGOLOB.V467MU.FAKE\n//TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=V467TV,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSIN     DD  *\nNEWVOL=V467MT\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2FK2T": {"ttr": 5127, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x11\\x01\\x00%O\\x01\\x05\\x00O\"@\\t\\x82\\x07\\x9b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2005-01-04T22:40:11", "lines": 2434, "newlines": 1947, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2FK2T -- COPY FAKETAPE FORMAT FILE TO A REAL TAPE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE: VTT2FK2T.   Written by Sam Golob                **\n**                                                          **\n**       Copyright (c) 2004-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to process FLEX-ES MVS Virtual        **\n**            Tape data in FAKETAPE format. This data is    **\n**            uploaded to an MVS system as an FB-80 card-   **\n**            image file.  The receiving MVS system does    **\n**     not have to be able to handle FAKETAPE-format        **\n**     virtual tapes, but it can use this program to read   **\n**     the tape data from this folded FAKETAPE-format       **\n**     file, and create a real tape from it.                **\n**                                                          **\n**     The FAKETAPE-format tape file that was created       **\n**     by the FLEX-ES system as a virtual tape, is          **\n**     uploaded to the MVS system as an FB-80 card-image    **\n**     file, with its (continuous stream of) data folded    **\n**     over into 80-byte records which can be blocked on    **\n**     MVS.  This VTT2FK2T program reads the resulting      **\n**     file, and creates a real output tape using EXCP, on  **\n**     a real tape drive, by filling a buffer and writing   **\n**     out its contents to the real tape.                   **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     1.  Since all the tape data is folded into 80-byte   **\n**         record segments, these have to be logically      **\n**         strung together, to be able to correctly write   **\n**         the tape data to tape blocks.                    **\n**                                                          **\n**     2.  First, the program has to correctly jump from    **\n**         one FAKETAPE header record to the next, and so   **\n**         proceed through all the headers in the entire    **\n**         tape file, not missing any.  Diagnostic output   **\n**         from this process, is written to the optional    **\n**         SYSTRACE ddname, if it is present in the         **\n**         execution JCL (see below).                       **\n**                                                          **\n**         The first header of a FAKETAPE-format tape is    **\n**         the first 12 bytes of the file.  Once you have   **\n**         the first header, you have the number of bytes   **\n**         of data until the next header, and so forth.     **\n**                                                          **\n**         The UNFOLDEM called program unfolds the data     **\n**         from a chunk of data after an FAKETAPE header,   **\n**         and strings it out into an output buffer, after  **\n**         which an EXCP operation writes the entire        **\n**         buffer to tape.                                  **\n**                                                          **\n**                                                          **\n**  Note:  If the output tape is too short, VTT2FK2T        **\n**         attempts to recover by issuing an EOV macro,     **\n**         which calls for a mount of a second tape,        **\n**         as a PRIVATE SCRATCH tape.  More data from the   **\n**         FAKETAPE file is written out to the second tape. **\n**                                                          **\n**         However, there is a catch here.  The second      **\n**         tape does not contain additional labels, as      **\n**         DFP would have written.  The second tape         **\n**         continues with the next block of data, after     **\n**         the last block which was successfully written    **\n**         to the first tape.                               **\n**                                                          **\n**         Therefore, in order to subsequently read the     **\n**         second tape, you have to treat both tapes as     **\n**         two-volume BLP, using JCL similar to this,       **\n**         even if the first tape is SL...                  **\n**                                                          **\n**       //TAPOUT    DD  DISP=OLD,UNIT=TAPE,                **\n**       //          VOL=(,RETAIN,SER=(VOL001,VOL002,etc)), **\n**       //          LABEL=(n,BLP,EXPDT=98000)              **\n**                                                          **\n**         where n (for BLP) would be 3m-1 (where m is      **\n**         the SL file number).                             **\n**                                                          **\n**         Sorry for that.  The reason is because this      **\n**         program writes tape blocks using EXCP, and       **\n**         for the second volume, I'd have to manufacture   **\n**         my own tape labels, and I haven't added such     **\n**         an enhancement at this time.  If BSAM or QSAM    **\n**         created a second SL tape, then the extra EOV     **\n**         and VOL and HDR labels are created by DFP.       **\n**         EXCP contains no such provisions, leaving any    **\n**         extra label creation entirely up to the          **\n**         programmer.                                      **\n**                                                          **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**         In order to make sure that the VTT2FK2T program  **\n**         is doing its job properly, it produces a lot of  **\n**         trace data and status data, as it is reading     **\n**         through the folded FB-80 FAKETAPE format tape.   **\n**         In order not to clutter the summary report, most **\n**         of this data is written to \"Optional DDNAMEs\".   **\n**                                                          **\n**         Optional DDNAMEs don't have to be coded in the   **\n**         JCL.  But if they are coded, they will contain   **\n**         the extra trace data which VTT2FK2T produces.    **\n**                                                          **\n**         The optional DDNAMEs are SYSFILES, SYSTRACE,     **\n**         SYSMOVED, and SYSIN.                             **\n**                                                          **\n**         Full JCL to run the VTT2FK2T program is as       **\n**         follows:                                         **\n**                                                          **\n**       //   jobcard                                       **\n**       //FAKEREAD EXEC PGM=VTT2FK2T                       **\n**       //STEPLIB   DD  DISP=SHR,DSN=your.load.library     **\n**       //FAKEIN    DD  DISP=SHR,DSN=folded.fkt.file,      **\n**                   DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)  **\n**       //TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=TEST01,  **\n**       //          LABEL=(1,BLP,EXPDT=98000)              **\n**       //SYSPRINT  DD  SYSOUT=*                           **\n**       //SYSFILES  DD  SYSOUT=*                           **\n**       //SYSTRACE  DD  SYSOUT=*                           **\n**       //SYSMOVED  DD  SYSOUT=*                           **\n**       //SYSUDUMP  DD  SYSOUT=*                           **\n**       //SYSIN     DD  *                                  **\n**       NEWVOL=PROD01                                      **\n**       /*                                                 **\n**       //                                                 **\n**                                                          **\n**         where you can leave out SYSTRACE, SYSMOVED,      **\n**         and SYSUDUMP, if you want to.  I'd strongly      **\n**         suggest including (at least) SYSFILES, though.   **\n**                                                          **\n**         If you code NEWVOL=volser in a //SYSIN card,     **\n**         starting in column 1, VTT2FK2T will change       **\n**         the VOLSER in every VOL1 label (should only be   **\n**         one of them) on the tape, to the value you       **\n**         specify.                                         **\n**                                                          **\n**         SYSFILES gives you block counts and byte counts  **\n**         for all files read and written.  SYSFILES also   **\n**         differentiates between label files and data      **\n**         files.                                           **\n**                                                          **\n**         SYSTRACE tells you if you are running through    **\n**         all the FAKETAPE headers properly. SYSMOVED      **\n**         tells you how many bytes were moved from each    **\n**         chunk of data between FAKETAPE headers. SYSUDUMP **\n**         is there to contain the MVS-produced dump, upon  **\n**         any abnormal termination of the program.         **\n**                                                          **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.12 - Adapted from VTT2TAPE program which    **\n**       does a similar job for AWS-format virtual tape     **\n**       files.                                             **\n**                                                          **\n**                                                          **\n**  RETURN CODES:                                           **\n**                                                          **\n**    RC =  0 :    Normal Operation                         **\n**                                                          **\n**    RC =  4 :    A Private Scratch tape was asked for,    **\n**                 because the end of the first output      **\n**                 tape was reached.                        **\n**                                                          **\n**    RC =  8 :                                             **\n**                                                          **\n**    RC = 12 :    Program operation had to be aborted      **\n**                 because the chain of FAKETAPE headers    **\n**                 was broken in the middle, and an invalid **\n**                 \"FAKETAPE header\" was encountered.  The  **\n**                 program writes out all valid tape        **\n**                 blocks, and then stops action, with a    **\n**                 message that indicates the problem, and  **\n**                 the header found to be in error.  The    **\n**                 last tape block written, is the block    **\n**                 before the last correct FAKETAPE header. **\n**                 This condition probably occurred because **\n**                 an invalid FAKETAPE header \"current      **\n**                 length\" made it impossible to find the   **\n**                 next valid FAKETAPE header.              **\n**                                                          **\n**                                                          **\n**    Please note that a higher return code will            **\n**    supersede a lower return code, and that multiple      **\n**    error conditions might exist, if there is a nonzero   **\n**    return code higher than 4.  Look at the SYSFILES      **\n**    report, and the other reports, to determine the       **\n**    exact error(s) present.                               **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n&LLEV    SETC  '1.12'\n         YREGS\n         EJECT\nVTT2FK2T CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2FK2T AMODE 24\nVTT2FK2T RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2FK2T - CUT A REAL TAPE FROM FAKETAPE FB-80 FILE -'\n         DC    C' '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2004 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2FK2T,R12,R11,R10,R8\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n* ----- >                            Parm = READ    <--- below\n         L     R1,0(R1)              Get PARM field\n         CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BNE   COPYTAPE              No. Default is to copy the tape.\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\nCOPYTAPE DS    0H\n* ----- >                            Parm = READ    <--- above\n*\n         L     R15,=V(UNFOLDEM)      UNFOLDEM subprogram\n         ST    R15,SVUNFOLD          Save its entry point\n         L     R0,=A(INAREA)         Address of tape buffer\n         ST    R0,SVINAREA           Store it away for later use.\n         L     R0,=V(TRTCSECT)       SAVE HEX TRANSLATE TABLE POINTER\n         ST    R0,SAVTRTCS           AND STORE IT FOR LATER USE.\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE4+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE5+88(31),HEADDLIT\n         MVC   MESSAGE6+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE4+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE5+61(21),LEVELLIT\n         MVC   MESSAGE6+61(21),LEVELLIT\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants and\n         MVI   FLAGSYST,X'00'        No optional ddnames initially.\n         ZAP   INHDRS,=P'0'          Count number of FAKETAPE headers\n         ZAP   INTYPE1,=P'0'         Counts of Header Types\n         ZAP   INTYPE2,=P'0'\n         ZAP   INTYPE3,=P'0'\n         ZAP   INTYPE4,=P'0'\n         ZAP   INTYPE5,=P'0'\n         ZAP   FILCOUNT,=P'0'        Initialize file counter\n         MVC   DBIN(8),=D'0'         Initialize byte counters\n         MVC   LBIN(8),=D'0'\n         MVC   DAIN(8),=D'0'\n         MVC   DAINF(8),=D'0'\n         MVC   LBINF(8),=D'0'\n         MVC   DBINF(8),=D'0'\n         MVC   OURRC,=F'0'\n         MVC   MAXRC,=F'0'\n         MVC   SVNEWVOL(6),=C'      '    MAKE SVNEWVOL BLANK\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE DDNAME THERE?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       SHOW PRESENCE OF SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       SHOW PRESENCE OF SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       SHOW PRESENCE OF SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       SHOW PRESENCE OF SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n*---------------------------------------------------------------------*\n* -------------- >>>>>>   Look for new output volume name - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    NONSYSIN             No. Then can't open it.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BNE   SYSINLUP              No. Don't use this card.\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         OI    FLAGNEWV,X'01'             And show a new volser here.\n         B     SYSINLUP\nSYSINEND DS    0H\n         CLOSE SYSIN\nNONSYSIN DS    0H\n* -------------- >>>>>>   Look for new output volume name - ABOVE\n*---------------------------------------------------------------------*\n         OPEN  (FAKEIN,(INPUT))\n         OPEN  (SYSPRINT,(OUTPUT))\n         TM    READFLAG,X'01'        Is this run READ ONLY?\n         BO    NOTAPOPN              Yes. Don't OPEN output tape.\n         OPEN  (TAPOUT,(OUTPUT))\nNOTAPOPN DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   NOSYSTRC              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE4\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA4\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSTRACE,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\nNOEXTRA4 DS    0H\n         PUT   SYSTRACE,MESSAGE9\n         PUT   SYSTRACE,MESSAG10\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n         PUT   SYSTRACE,MESSAGE8\n*--->>\nNOSYSTRC DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE5\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA5\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSMOVED,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\nNOEXTRA5 DS    0H\n*--->>\nNOSYSFIL DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSMVD              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE6\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA6\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSFILES,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\nNOEXTRA6 DS    0H\n*--->>\nNOSYSMVD DS    0H\n* ----------------------------------------------------------------- *\n*     Write the top Header Line, with the date and time in it.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA1\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSPRINT,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSPRINT,PRTLINE\nNOEXTRA1 DS    0H\n*--->>\n* ----------------------------------------------------------------- *\n*     Start trying to bop through the FAKETAPE headers. The first 12\n*     bytes of the file, is the first header, so we start there.\n* ----------------------------------------------------------------- *\nLOOPSTRT DS    0H                    START OF PROCESSING\n         LA    R7,INCARD             INITIALIZE BEG OF RECORD\n         ST    R7,SAVEBEGC           AND SAVE THIS SETTING.\n* ---------------------------------------------------------------- *\n         LA    R6,INCAEND            INITIALIZE END OF RECORD\n         ST    R6,SAVEENDC           AND SAVE THIS SETTING.\n         LA    R1,80(,R6)            BOP BY ANOTHER RECORD LENGTH\n         ST    R1,SAVEEN80           AND SAVE WHERE THIS IS.\n* ---------------------------------------------------------------- *\n         GET   FAKEIN,INCARD          Do the very first GET to find\n*                                     the first header in the file.\n*                                     The first header lets you find\n*                                     all the other headers.\n         AP    UNFINRCD,=P'1'         Increment the GET count\n         MVC   INHEADER(12),0(R7)     Got the first header\n         MVC   HDRLENGS(2),=X'0000'   Zero for first compare.\n* ---------------------------------------------------------------- *\n*     We come here when we know we're at the beginning of an\n*     FAKETAPE header record.\n* ---------------------------------------------------------------- *\nGOTHEADR DS    0H                     Got a header record\n* ---------------------------------------------------------------- *\n* -------------  Save data from the previous header  ------------- *\n* ---------------------------------------------------------------- *\n         MVC   HDRPREVS(2),HDRPREV    Save previous bytes moved\n         MVC   HDRLENGS(2),HDRLENG    Save next bytes to be moved\n* ---------------------------------------------------------------- *\n*  New header gotten is in the INHEADER field - must be converted\n* ---------------------------------------------------------------- *\n* -\n         XR    R1,R1                  Make sure R1 is cleared\n         LA    R1,INHEADP             Point R1 to 4 bytes to convert\n         BAL   R9,ASC2HFWD            Convert header field to halfword\n         MVC   HDRPREV(2),0(R1)       And move it to its proper place\n* -\n         XR    R1,R1                  Make sure R1 is cleared\n         LA    R1,INHEADN             Point R1 to 4 bytes to convert\n         BAL   R9,ASC2HFWD            Convert header field to halfword\n         MVC   HDRLENG(2),0(R1)       And move it to its proper place\n* -\n         XR    R1,R1                  Make sure R1 is cleared\n         LA    R1,INHEADC             Point R1 to 4 bytes to convert\n         BAL   R9,ASC2HFWD            Convert header field to halfword\n         MVC   HDRCHEK(2),0(R1)       And move it to its proper place\n* -\n         MVC   HDRCHEKW(2),HDRPREV    Previous bytes to workarea\n         XC    HDRCHEKW(2),HDRLENG    XOR with next bytes\n         CLC   HDRCHEKW(2),HDRCHEK    Compare to value from header\n         BE    GOODHEDR               Equal, everything is good.\n         B     HEADRERR               Not equal. Report error.\nGOODHEDR DS    0H                     Go on processing.\n* ---------------------------------------------------------------- *\n*--->\n         AP    INHDRS,=P'1'           Count the number of good headers.\n*--->\n*--->       Format the header by interpreting the length fields,\n*--->       and then print the values for diagnosis if necessary.\n*--->\n*--->       HDRLENG contains the true halfword byte count of data\n*--->               following this header.\n*--->       HDRPREV contains the true halfword byte count of data\n*--->               preceding this header.\n*--->\n*--->       In case fullword versions of these quantities are\n*--->       needed, HDRFULLS and HDRPFULS are supplied too.\n*--->\n         MVC   HDRFILL(2),=X'0000'    Fill in zeros\n         MVC   HDRPRVF(2),=X'0000'      for\n         MVC   HDRLENFL(2),=X'0000'        fullword values\n         MVC   HDRPRVFL(2),=X'0000'           of halfwords.\n*\n         MVC   PRTLINE,PRTLINE-1      CLEAR PRINT LINE\n         MVC   INHEADWK(12),INHEADER  To workarea to make header\n*                                       displayable.\n         ST    R5,R5TRANSL            Save register.\n         L     R5,SAVTRTCS            Point to translation table CSECT.\n         USING TRTCSECT,R5\n         TR    INHEADWK(12),TRTA2E    Translate to EBCDIC for print.\n         L     R5,R5TRANSL            Restore register.\n         DROP  R5\n         MVC   PRTLINE+8(12),INHEADWK Move EBCDIC header to print line.\n*                                     UNFAREA at GOTHEADR time display\n         HEX   PRTLINE+28,4,UNFSCARD                            .\n         HEX   PRTLINE+38,4,UNFECARD                            .\n         HEX   PRTLINE+48,4,UNFOFFST                            .\n         HEX   PRTLINE+58,4,UNFBYTES                            .\n         HEX   PRTLINE+68,4,UNFBYMVD                            .\n         HEX   PRTLINE+78,4,UNFBUFFR                            .\n         HEX   PRTLINE+88,4,UNFBSTRT                            .\n         HEX   PRTLINE+98,7,UNFINRCD                            .\n* ---------------------------------------------------------------- *\n*            PRINT THE SYSTRACE REPORT LINE IF ASKED FOR\n* ---------------------------------------------------------------- *\nPRTSYSTR DS    0H\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         PUT   SYSTRACE,PRTLINE\nNOSYSTR1 DS    0H\n         CLC   INHEADER(12),EOTMARK   IS THE HEADER AN EOT MARK?\n         BNE   NOFIN                  NO. DON'T STOP THE PROGRAM.\n         AP    INTYPE5,=P'1'          Count double tape marks.\n         NI    UNEXFLAG,FF-X'01'      TURN OFF UNIT EXCEPTION FLAG\n         TM    FLAGHDRL,X'01'         YES. BUT TEST IF AFTER HDR 1 OR 2\n         BO    NOFIN                  AFTER HDR1 OR HDR2, DON'T END PGM\n         B     FIN                    OTHERWISE END THE PROGRAM.\nNOFIN    DS    0H\n*------------------------------>  Validate Header Quantities  <-- below\n*\n*   This validation checks if the bytes in the \"previous\" byte count\n*   field match the byte count in the \"forward\" field of the previous\n*   header.  If there is an error, it is reported now.\n*\n         CLC   HDRLENGS(2),HDRPREV    Is Prev Length = Last Current ?\n         BE    HDRVALID               Yes. As it should be.\n         MVC   OUTLINE,OUTLINE-1      No. Corrupted headers.\n         MVC   OUTLINE,ERRMESS6       Write nasty message.\n         MVI   OUTLINE+58,C'P'        Display prev hdr quantity.\n         HEX   OUTLINE+60,2,HDRPREV\n         MVI   OUTLINE+66,C'C'        Display last current hdr amount.\n         HEX   OUTLINE+68,2,HDRLENGS\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'        Set RC = 12\n         CLC   MAXRC,OURRC            Is MAXRC higher?\n         BH    SAXERC02               Yes. Keep it.\n         MVC   MAXRC,OURRC            No.  Raise MAXRC to this one.\nSAXERC02 DS    0H\n         TM    FLAGSYST,X'01'         Write nastygram to SYSTRACE.\n         BZ    NOERRX1\n         PUT   SYSTRACE,OUTLINE\nNOERRX1  DS    0H\n         TM    FLAGSYST,X'02'         Write nastygram to SYSMOVED.\n         BZ    NOERRX2\n         PUT   SYSMOVED,OUTLINE\nNOERRX2  DS    0H\n         TM    FLAGSYST,X'04'         Write nastygram to SYSFILES.\n         BZ    NOERRX4\n         PUT   SYSFILES,OUTLINE\nNOERRX4  DS    0H\n         PUT   SYSPRINT,OUTLINE       Write nastygram to SYSPRINT.\n         B     AGLE                   End program if bad header.\n*\n*------------------------------>  Validate Header Quantities  <-- above\n*\nHDRVALID DS    0H          Prev Length equals Past Next, then come here\n*\n* - - - - - - - >>>>>   End of Header Operations....\n* - - - - - - - >>>>>   Now go move the data afterward.\n* ---------------------------------------------------------------- *\n*     At this point, we will begin moving the data that is after\n*     the first header.  Future OFFSETs will be supplied by the\n*     previous call to the UNFOLDEM program.\n* ---------------------------------------------------------------- *\nLOOKINIT DS    0H                Start looking for the data at the\n*                                beginning of the FAKEIN tape file.\n         TM    INITFLAG,X'01'    Not the first time here?\n         BO    LOOKIEND          Bypass initializations.\n         OI    INITFLAG,X'01'    Do this only once for the entire tape.\n         MVC   UNFOFFST,=F'12'   Initialize OFFSET to be just past\n*                                the first header in the file.\n         MVC   UNFBUFFR,UNFBSTRT  Init buffer loc to start of buffer\nLOOKIEND DS    0H\n* ---------------------------------------------------------------- *\nMOVEDATA DS    0H                This is the call to UNFOLDEM.\n*                                We fill in the necessary fields.\n*\n*    UNFOLDEM is only intended to move the data between the FAKETAPE\n*    headers.  \"After processing\" is controlled by the fields in\n*    the headers only.  That is because FAKETAPE headers have no\n*    flag bits.  After each header is processed, we again point\n*    to the data after the headers (if any) and call UNFOLDEM to\n*    move it.\n*\n         MVC   UNFSCARD,SAVEBEGC   Beginning address of input card\n         MVC   UNFECARD,SAVEENDC   End address of input card\n         XC    UNFBYTES,UNFBYTES   Zero out fullword bytes to be moved\n         MVC   UNFBYTES+2(2),HDRLENG   And move in halfword value\n         L     R1,SVINAREA         Point to address of buffer\n         ST    R1,UNFBSTRT         Store it in beginning buffer field\n         ST    R1,UNFBUFFR         Store it in current buffer field\nMOVEBUFF DS    0H\n*        MVC   LINE+1(8),=C'BEFCALL '\n*        BAL   R9,UNFIMAGE\n         LA    R1,UNFAREA          Point to UNFAREA control block\n         L     R15,SVUNFOLD        Load entry point of UNFOLDEM pgm\n         BALR  R14,R15             Call the program and move data.\n         MVC   UNFAREA(UNFLENTH),0(R1)  Move modified UNFAREA to pgm\n*        MVC   LINE+1(8),=C'AFTCALL '\n*        BAL   R9,UNFIMAGE\n* -- Test for call of LABELCHK -- >   below\n*   We have just moved the bytes.  Now we check if the file is a label.\n         NI    ISLBLFLG,FF-X'01'   Initially assume it's not a label.\n         L     R1,UNFBYMVD         The number of bytes moved just now.\n         C     R1,=X'00000050'     Was it exactly 80?\n         BNE   NOLBLCHK            No. Assume it can't be a label.\n         L     R1,UNFBSTRT         Grab address of data buffer.\n         MVC   TESTLABL(80),0(R1)  Move 80 bytes to the testing area.\n         BAL   R9,LABELCHK         Test to see if it is a label.\n         TM    ISLBLFLG,X'01'      Is it a label?\n         BZ    NOLBLCHK            No. Assume entire file is not labels\n         OI    FILBLFLG,X'01'      Yes. Turn on label flag at the\n*                                   file level.\nNOLBLCHK DS    0H\n* -- Test for call of LABELCHK -- >   above\n* ---------------------------------------------------------------- *\n         BAL   R9,AFTRMOVE       Housekeeping after the data move.\n*        MVC   LINE+1(8),=C'AFTAFTR '\n*        BAL   R9,UNFIMAGE\n         BAL   R9,CHKHEADR       Get new header ready for handling.\n*        MVC   LINE+1(8),=C'AFTCHKH '\n*        BAL   R9,UNFIMAGE\n         B     GOTHEADR          Assume you've got another header.\n* ---------------------------------------------------------------- *\n*          END OF INPUT FAKETAPE DATA                              *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         BAL   R9,WRITTPMK          WRITE FINAL TAPE MARK\n         B     AGLE                 Finish processing\n* ---------------------------------------------------------------- *\nHEADRERR DS    0H                     Check field is not right\n         MVC   OUTLINE,OUTLINE-1      Clear line.\n         MVC   OUTLINE,ERRMESS5       Move appropriate error message.\n*\n         MVC   INHEADWK(12),INHEADER  Get set to translate to EBCDIC.\n*\n         ST    R5,R5TRANSL            Save register.\n         L     R5,SAVTRTCS            Point to translation table CSECT.\n         USING TRTCSECT,R5\n         TR    INHEADWK(12),TRTA2E    Translate to EBCDIC for print.\n         L     R5,R5TRANSL            Restore register.\n         DROP  R5\n*                                     UNFAREA at GOTHEADR time display\n*\n         MVC   OUTLINE+58(12),INHEADWK  Display EBCDIC repr of header\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'        RC = 12 for header error.\n         CLC   MAXRC,OURRC            Is MAXRC higher?\n         BH    SAMERC02               Yes. Keep it.\n         MVC   MAXRC,OURRC            No.  Raise MAXRC to this one.\nSAMERC02 DS    0H                     Print in SYSTRACE\n         TM    FLAGSYST,X'01'\n         BZ    NOERR01\n         PUT   SYSTRACE,OUTLINE\nNOERR01  DS    0H                     Print in SYSMOVED\n         TM    FLAGSYST,X'02'\n         BZ    NOERR02\n         PUT   SYSMOVED,OUTLINE\nNOERR02  DS    0H                     Print in SYSFILES\n         TM    FLAGSYST,X'04'\n         BZ    NOERR04\n         PUT   SYSFILES,OUTLINE\nNOERR04  DS    0H                     Print in SYSPRINT\n         PUT   SYSPRINT,OUTLINE\n* ---------------------------------------------------------------- *\nAGLE     DS    0H                     Print the Summary Report\n         BAL   R9,SUMMREPT\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\n         CLOSE FAKEIN\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'4'\n         BNH   NOERRPRT\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRPRT DS    0H\n         PUT   SYSPRINT,OUTLINE\n         CLOSE SYSPRINT\n         TM    READFLAG,X'01'       If READ ONLY, don't CLOSE tape.\n         BO    NOTAPCLS\n         CLOSE TAPOUT\nNOTAPCLS DS    0H\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'0'\n         BE    NOERRFIL\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRFIL DS    0H\n         PUT   SYSFILES,OUTLINE\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         MVC   16(4,R13),MAXRC      Load Maximum Return Code\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H                 Take a picture of the UNFAREA now.\n         HEX   LINE+10,4,UNFSCARD    Starting card address.\n         HEX   LINE+20,4,UNFECARD    Ending card address.\n         HEX   LINE+30,4,UNFOFFST    Offset (starting and ending)\n         HEX   LINE+40,4,UNFBYTES    Number of bytes to be moved.\n         HEX   LINE+50,4,UNFBYMVD    Number of bytes that were moved.\n         HEX   LINE+60,4,UNFBUFFR    Current start location in buffer.\n         HEX   LINE+70,4,UNFBSTRT    Location of beginning of buffer.\n         HEX   LINE+80,7,UNFINRCD    Number of GETs done to FAKEIN file\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1           Clear LINE after PUT.\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nCHKHEADR DS    0H                 Position to the next header\n*                                 The idea is to fill the INHEADER\n*                                 field with the correct value.\n         ST    R9,SAVER9CH        Save BAL register\n         L     R1,UNFOFFST        New offset, returned from UNFOLDEM.\n         C     R1,=F'68'          Bigger or equal to 68?\n         BL    CHKHOFSL           No. Just copy header straight.\nCHKHOFSH DS    0H                 Yes. Need to combine with next card.\n         MVC   INCARDP,INCARD     Copy this card to prev 80 byte area.\n         GET   FAKEIN,INCARD      GET another card adjacent to previous\n         AP    UNFINRCD,=P'1'     Count this card gotten.\n         LA    R7,INCARDP         Point to two consecutive cards.\n         A     R7,UNFOFFST        Add the returned offset.\n         MVC   INHEADER(12),0(R7) Move the new header to staging area.\n         LA    R7,12(,R7)         Bump R7 past the new header.\n         S     R7,=A(INCARD)      Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\n         B     CHKHEND            Finish this processing.\nCHKHOFSL DS    0H\n         LA    R7,INCARD          < 68. Header is in original card.\n         LA    R7,0(R1,R7)        Bump by offset - point to new header\n         MVC   INHEADER(12),0(R7) And move it to staging area.\n         LA    R7,12(,R7)         Bump R7 past the new header.\n         L     R1,=A(INCARD)      Address of current card\n         SR    R7,R1              Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\nCHKHEND  DS    0H\n         L     R9,SAVER9CH        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nAFTRMOVE DS    0H                 After the move, we act on the\n*                                 information from the previous\n*                                 FAKETAPE header.\n         ST    R9,SAVER9AF        Save BAL register\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nAFTTST40 DS    0H                 X'40' means END-OF-FILE\n*                                 So we finish off the file-level stuff\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* ------ >>>>>>>  diagnostic  <<<<<<< ------ *\n*        MVC   LINE,LINE-1\n*        MVC   LINE+1(6),=C'Hdrlng'\n*        HEX   LINE+8,2,HDRLENG\n*        PUT   SYSPRINT,LINE\n* ------ >>>>>>>  diagnostic  <<<<<<< ------ *\n         CLC   HDRLENG,=X'0000'   Is there an end-of-file condition?\n         BNE   AFTTSTA0           No. Do next test.\n         BAL   R9,WRITTPMK        Yes. Write a tape mark.\n         AP    INTYPE4,=P'1'      Count end-of-file headers\n         AP    FILCOUNT,=P'1'     Count number of files written.\n         BAL   R9,REPTFILE        Report on this file in SYSFILES.\n         ZAP   BLOCKCNT,=P'0'     Zero block count for next file\n         ZAP   FILEBYTS,=P'0'     Zero bytes moved for next file\n         NI    FILBLFLG,FF-X'01'  Turn off Label File indicator\n         XC    DBINF,DBINF        Zero byte count at file level\n         XC    DAINF,DAINF        Zero data bytes at file level\n         XC    LBINF,LBINF        Zero label bytes at file level\n** - SYSMOVED ->>    Record the number of files written  -  BELOW\n         TM    FLAGSYST,X'02'     Is SYSMOVED here and open?\n         BNO   AFTT40WM           No. Don't attempt a print.\n         MVC   OUTLINE,OUTLINE-1         Clear line.\n         MVC   OUTLINE,MESSAG12          Mark END-OF-FILE in SYSMOVED\n         MVC   OUTLINE+38(9),FILEPAT     Move in edit pattern\n         ED    OUTLINE+38(9),FILCOUNT+3  Tell which file number ended\n         PUT   SYSMOVED,OUTLINE\nAFTT40WM DS    0H\n** - SYSMOVED ->>    Record the number of files written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-40: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND           No more processing after this.\n*\nAFTTSTA0 DS    0H                 X'A0' means beg and end of block\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR\n** ---------- >>\n         XC    BLOKBYTS,BLOKBYTS  Zero bytes moved after write\n         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too\n*        MVC   LINE+1(8),=C'AFT-A0: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTRMERR DS    0H                 Code any error handling here.\nAFTRMEND DS    0H\n         L     R9,SAVER9AF        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITBUFF DS    0H\n         ST    R9,SAVER9WR        BAL register save for WRITBUFF\n         TM    READFLAG,X'01'     READ ONLY run?\n         BO    WRITREAD           Yes. Don't do the EXCP.\n         LA    R1,TAPOUT          R1=address of current DCB\n         ST    R1,OUTDCBPT        Put it in IOB\n         MVC   OUTCCW+1(3),UNFBSTRT+1   PRIME OUTPUT CCW\n         MVC   OUTCCW+6(2),BLOKBYTS+2    Move length of block\n         MVI   OUTECB,X'00'       Initialize ECB\n         EXCP  OUTIOB             Write out the buffer\n         WAIT  ECB=OUTECB         Wait for write to complete\n         CLI   OUTECB,X'7F'       Write completed normally?\n         BNE   WRITBERR           No - error\nWRITREAD DS    0H\n         AP    BLOCKCNT,=P'1'     Block count for this file\n         AP    BLOCKTOT,=P'1'     Block count for entire tape\n         MVC   UNFBUFFR,UNFBSTRT  Reset buffer start in UNFAREA\n         B     WRITBUFE           OK\nWRITBERR DS    0H\n* --- >  handle eov on output - below\n         NI    UNEXFLAG,FF-X'01'  Clear bit on unit exception flag\n         TM    OUTCSW+4,X'02'     Unit check?\n         BO    OUTERUC            Yes. Handle it.\n         TM    OUTCSW+4,X'01'     Unit exception on write?\n         BZ    OUTERR1            No. Assume data check.\n         OI    UNEXFLAG,X'01'     Flag that we have unit exception\n         MVC   LINE,LINE-1        Clear output line\n         MVC   LINE(133),OUTUNEX  Set unit exception error message\n         B     OUTERR2\nOUTERUC  MVC   LINE(133),OUTEQC   Set unit check error message\n         B     OUTERR2            Continue\nOUTERR1  DS    0H\n         MVC   LINE(133),OUTDCK   Set data check error message\nOUTERR2  DS    0H\n         ST    R2,SAVER2E         Save Registers\n         ST    R4,SAVER4E\n         ST    R5,SAVER5E\n         L     R2,OUTDCBPT        Load DCB address\n         LH    R4,40(,R2)         R4=TIOT offset\n         L     R5,16              R5=CVT\n         L     R5,0(,R5)          R5=TCB words\n         L     R5,4(,R5)          R5=My TCB\n         L     R5,12(,R5)         R5=TIOT\n         AR    R4,R5              R4=TIOT Entry for this output\n         MVC   LINE+34(6),4(R4)   Move DDNAME to message\n         L     R4,16(,R4)         R4=UCB for this output\n         MVC   LINE+47(4),12(R4)  Move unit address to message\n         MVC   LINE+60(6),36(R4)  Move VOLSER to message\n         L     R2,SAVER2E         Restore Registers\n         L     R4,SAVER4E\n         L     R5,SAVER5E\n         TM    UNEXFLAG,X'01'     Was this a Unit Exception only?\n         BNO   OTHERERR           No. Just go on.\nHANDLEOV DS    0H            If Unit Exception, then ask for new volume\n         PUT   SYSPRINT,LINE      Write message\n         BAL   R9,SUMMREPT        Print summary report before doing EOV\n         TM    READFLAG,X'01'     If Read Only, skip EOV macro.\n         BO    OTHERERR\n         MVC   OURRC,=F'4'        Indicate scratch volumes asked for\n         CLC   MAXRC,OURRC        Is MAXRC higher?\n         BH    SAMERC03           Yes. Keep it.\n         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.\nSAMERC03 DS    0H\n         EOV   TAPOUT\nOTHERERR DS    0H\n* --- >  handle eov on output - above\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS2\n         HEX   OUTLINE+34,4,UNFBYMVD    Print Reg 2\n         HEX   OUTLINE+44,2,HDRLENG     Print Header Length\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFE                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\nWRITBUFE DS    0H                       Stats for data moved\n** ---------- >>    Record the number of bytes written\n         ST    R2,SAVER2N           Save prev contents of Register 2\n         ST    R3,SAVER3N           Save prev contents of Register 3\n         XR    R2,R2                High order is zero\n         L     R2,BLOKBYTS          Load Current Written Byte Count\n         LA    R3,DBIN              Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBINF             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DAINF             This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,LBINF             Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n** -->   label byte counts and data byte counts  <-- **  above\n         L     R2,SAVER2N           Restore prev contents of Register 2\n         L     R3,SAVER3N           Restore prev contents of Register 3\n** ---------- >>    Record the number of bytes written\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAGE3\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT TOTAL BYTES MOVED\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT PREVIOUS LENGTH\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFX                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\n         OI    BWRITFLG,X'01'           Show you've been here\nWRITBUFX DS    0H\n         L     R9,SAVER9WR          BAL register restore for WRITBUFF\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITTPMK DS    0H               Routine to write a tape mark\n         ST    R9,SAVER9WR      BAL register save for WRITTPMK\n         TM    READFLAG,X'01'   Is this run READ ONLY ?\n         BO    WRITTPME         Yes. Bypass entire routine.\n         LA    R1,TAPOUT        R1=address of current DCB\n         ST    R1,OUTDCBPT      Put it in IOB\n         MVI   OUTCCW,X'1F'     Tape Mark opcode\n         MVC   OUTCCWST(2),OUTCCW+6   Store previous move value\n         MVC   OUTCCW+6(2),X'0000'    Shove zeros into length field\n*                                     so AWSTAPE emulator doesn't barf\n         MVI   OUTECB,X'00'     Initialize ECB\n         EXCP  OUTIOB           Write the tape mark\n         WAIT  ECB=OUTECB       Wait for write to complete\n         CLI   OUTECB,X'7F'     Write completed normally?\n         BNE   WRITTPER         No. Indicate tape mark write error.\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST   Restore bytes moved field in CCW\n         B     WRITTPME         Don't indicate error condition\nWRITTPER DS    0H               Tape mark write error display\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS4\n         HEX   OUTLINE+34,4,OUTECB\n         HEX   OUTLINE+44,8,OUTCSW\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST    Restore byte moved field in CCW\nWRITTPME DS    0H\n         L     R9,SAVER9WR      BAL register restore for WRITTPMK\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  Add Byte Count subroutine\n         ST    R9,SAVER9AD         BAL register save for ADDCOUNT\n         ST    R4,SAVER4N          Save and Restore\n         ST    R5,SAVER5N             Work Registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           Else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         L     R4,SAVER4N          Save and Restore\n         L     R5,SAVER5N             Work Registers\nADDCOUNE DS    0H                  End of routine - Return\n         L     R9,SAVER9AD         BAL register restore for ADDCOUNT\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SU               Save BAL register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---- --- --- --->\n         TM    FLAGNEWV,X'01'\n         BZ    NOCHGVSR\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+3(130),MESSAGE7\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\nNOCHGVSR DS    0H\n* >---- --- --- --->\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(26),=C'FAKETAPE HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),UNFINRCD   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INHDRS     NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE4    END OF FILE HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG07\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE5    END OF TAPE HEADERS\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDLE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\nNOMIDDLE DS    0H\n*** -------- >>>\nNOSUMM05 DS    0H\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDPR\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\nNOMIDDPR DS    0H\n*** -------- >>>\nSUMMREPE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SU         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LC          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         LA    R1,TESTLABL          Point to 80 bytes to be tested.\n         CLC   =C'VOL1',0(R1)       Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   =C'HDR1',0(R1)       Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   =C'HDR2',0(R1)       This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   =C'EOF1',0(R1)       This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   =C'EOF2',0(R1)       This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   =C'EOV1',0(R1)       This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   =C'EOV2',0(R1)       This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   =C'UHL',0(R1)        This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   =C'UTL',0(R1)        This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  YES. DON'T CHANGE.\n         L     R1,SVINAREA               Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAGE7+28(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\nNOCHGVOL DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         L     R1,SVINAREA               Point to INAREA\n         CLC   4(23,R1),ZERO23      WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\n         OI    FLAGHDRL,X'01'\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         OI    FLAGHDRL,X'01'\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOF2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\n         L     R9,SAVER9LC          Restore BAL register\nLABCHEND BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n         ST    R9,SAVER9RP\n*----------->>\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n*--->                   Block counts first  -  above\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    LBLSMSG0                  Yes. Show labels, not data.\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01A      Tell it's labels written.\n         B     ENDSMSG0\nLBLSMSG0 DS    0H\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01B      Tell it's data written.\nENDSMSG0 DS    0H\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3  Put file count in message\n*--->\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    DISLABLS                  Yes. Do the label treatment.\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Cumulative data bytes written\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),DATDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),LABDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINFH          Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBINH           Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\nREPTFEND DS    0H\n         L     R9,SAVER9RP\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nASC2HFWD DS    0H          CONVERT HEADER VALUES INTO BINARY\n*                          -----------------------------------\n*                          Upon entry to this routine, R1\n*                          points to a 4-byte hex number field\n*                          represented in ASCII. These numbers\n*                          X'30' thru X'39' and X'41' thru X'46'\n*                          are translated into X'00' thru X'0F'\n*                          and packed (with an extra X'F0' on\n*                          the end) to convert them to a binary\n*                          halfword after the X'0F' on the end\n*                          is cut off. PACK does not do a check\n*                          for a numeric quantity. It only\n*                          squeezes together the \"numeric\"\n*                          nibbles. R1 is pointed back to the\n*                          resulting true binary halfword.\n*                          -----------------------------------\n         ST    R9,SAVER9A2         Store BAL register.\n         MVI   ASCWORKP,X'F0'      Prime the extra character for PACK\n         MVC   ASCWORK(4),0(R1)\n         ST    R5,R5TRANSL         Save register.\n         L     R5,SAVTRTCS         Point to translation table CSECT.\n         USING TRTCSECT,R5\n         TR    ASCWORK(4),TRTA2B   Translate ASCII into padded BINARY\n         L     R5,R5TRANSL         Restore register.\n         DROP  R5\n         PACK  BINWORK+1(3),ASCWORK(5)  Convert to halfwd + extra zero\n         MVC   HEXWORK(2),BINWORK+1     Pick off halfword only\n         LA    R1,HEXWORK               Point R1 to the result\nGETVALEN DS    0H\n         L     R9,SAVER9A2         Restore BAL register\n         BR    R9\n* - - - - - - - - - - -            Work fields for ASC2HFWD routine\nASCWORK  DS    CL4\nASCWORKP DS    C\nBINWORK  DS    CL4\nHEXWORK  DS    XL2\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\nOUTCCW   DC    X'01',AL3(0),X'2000',X'FFFF'     OUTPUT AREA OVERLAID\nOUTECB   DC    F'0'\nOUTIOB   DC    X'02000000'\n         DC    A(OUTECB)\nOUTCSW   DC    2F'0'\nOUTCCWPT DC    A(OUTCCW)\nOUTDCBPT DC    A(TAPOUT)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            PADDING\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY FAKEIN\nFAKEIN   DCB   DDNAME=FAKEIN,MACRF=GM,EODAD=FIN,DSORG=PS,LRECL=80\nTAPOUT   DCB   MACRF=(E),DDNAME=TAPOUT,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X\n               EODAD=SYSINEND\n         DC    CL8' '\nFF       EQU   X'FF'\n* ----------------------------------------------------------------- *\n*\n*   - - - - - - - -  FAKETAPE BLOCK HEADER  - - - - - - - -\n*\n* ----------------------------------------------------------------- *\n*HEADER   DS    0CL12              FAKETAPE BLOCK HEADER MODEL\n*\n*    We call the number representation in the FAKETAPE header\n*    fields \"ASCII HEX\" representation.  They are 4-byte fields\n*    of printable ASCII numbers, representing a halfword of hex\n*    numbers.\n*\n*    ASCII 4-byte hex numbers are X'30' thru X'39' representing\n*    hex numbers 1 thru 9, and X'41' thru X'46' representing\n*    hex numbers A thru F.  Check field is XOR of the binary\n*    equivalents of the first two ASCII fields, re-translated\n*    into this ASCII HEX format.  Routine ASC2HFWD (ASCII HEX to\n*    Halfword) translates these 4-byte fields into the equivalent\n*    halfword binary quantities, so the rest of the program logic\n*    can calculate using these values.\n*\n*HDRPREVL DC    XL4'30303030'      PREVIOUS BLOCK LENGTH ASCII HEX\n*HDRCURRL DC    XL4'30303030'      CURRENT BLOCK LENGTH ASCII HEX\n*HDRCHECK DC    XL4'30303030'      ASCII HEX OF XOR OF BOTH\n* ----------------------------------------------------------------- *\nINHEADER DS    0CL12             -- Header Input Area --\nINHEADP  DS    CL4                 Bytes in previous block - ASCII Hex\nINHEADN  DS    CL4                 Bytes in next block - ASCII Hex\nINHEADC  DS    CL4                 Check quantity - ASCII Hex of XOR\n*                                --                   --\nINHEADWK DS    CL12            Work area to translate header to EBCDIC.\n* ----------------------------------------------------------------- *\nAWSHEADR DC    XL6'00'\nUNEXFLAG DC    X'00'                    FLAGS BYTE 1...\n         DC    XL80'00'                 PADDING\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nHDRCHEK  DC    XL2'00'             Check field converted to binary\nHDRCHEKW DC    XL2'00'             XOR of HDRLENG and HDRPREV\nOUTCCWST DC    XL2'00'             Byte count in CCW - saved during WTM\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nBWRITFLG DC    X'00'    MESSAGE3 was already written flag.\n*              X'01'    Don't have to write SYSMOVED message now.\n* ---------- *\nINITFLAG DC    X'00'    First invocation of UNFOLDEM at beg of tape.\n*              X'01'    After the first invocation of UNFOLDEM.\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nREADFLAG DC    X'00'               This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nISLBLFLG DC    X'00'               80 BYTE BLOCK IS NOT A LABEL\n*              X'01'         80 BYTE BLOCK IS A LABEL\n* ---------- *\nFILBLFLG DC    X'00'               IS THE FILE A LABEL FILE?\n*              X'01'         THIS FILE IS A LABEL FILE\n* ---------- *\nFLAGHDRL DC    X'00'               HEADER LABEL FLAG\n*              X'01'         EOT HEADER IS FOLLOWING A HEADER LABEL\n* ---------- *\nFLAGSYST DC    X'00'           FLAG TO SHOW IF SYSTRACE DD IS THERE\n*              X'01'         //SYSTRACE DD IS THERE\n*              X'02'         //SYSMOVED DD IS THERE\n*              X'04'         //SYSFILES DD IS THERE\n*              X'08'         //SYSIN    DD IS THERE\n* ---------- *\nFLAGNEWV DC    X'00'           FLAG TO SHOW IF A NEW VOLSER PLUGGED IN\n*              X'01'         SVNEWVOL FIELD HAS BEEN SUBSTITUTED.\n* ---------- *\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for FAKEIN records\nUNFLENTH EQU   *-UNFAREA\n* -------------------------------------------- *\nBLOKBYTS DC    F'0'                Count of bytes for block.\nFILEBYTS DC    F'0'                Count of bytes for file.\n* -------------------------------------------- *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nDWORD    DC    D'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nINHDRS   DC    PL7'0'\nINTYPE1  DC    PL7'0'\nINTYPE2  DC    PL7'0'\nINTYPE3  DC    PL7'0'\nINTYPE4  DC    PL7'0'\nINTYPE5  DC    PL7'0'\nFILCOUNT DC    PL7'0'\nFERCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLERRCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL43\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Label Bytes'\nDATDISPL DS    0CL43\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data Bytes '\n*\nSAVEEN80 DS    F         Addresses:  80 bytes past record end\nSAVEENDC DS    F                     Record end location\nSAVEBEGC DS    F                     Record beginning location\nBEGDATA  DS    F                     Where this record's data begins\n*\n* below - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\n* ------                      Move count for bytes in the buffer\nBYTEBFWD DS    0F\nBYTEFILL DC    H'0'\nBYTEMOVE DC    H'0'\n* ------\nSVUNFOLD DC    F'0'           Entry point of UNFOLDEM subprogram\nSVINAREA DS    F\nSAVTRTCS DS    F\nSAVER2E  DS    F\nSAVER4E  DS    F\nSAVER5E  DS    F\nSAVER2N  DS    F              Has to do with byte counting subroutine\nSAVER3N  DS    F              Has to do with byte counting subroutine\nSAVER4B  DS    F              HEX print register save\nSAVER4N  DS    F              Has to do with byte counting subroutine\nSAVER4Q  DS    F              Has to do with byte counting subroutine\nSAVER5N  DS    F              Has to do with byte counting subroutine\nR5TRANSL DS    F              Has to do with ASC2HFWD subroutine\n* --- below                   SAVE BAL REGISTER for each subroutine\nSAVER9HV DS    F              Has to do with Header Validation\nSAVER9AD DS    F              Has to do with ADDCOUNT routine\nSAVER9AF DS    F              Has to do with AFTRMOVE routine\nSAVER9WR DS    F              Has to do with WRITBUFF routine\nSAVER9WT DS    F              Has to do with WRITTPMK routine\nSAVER9CH DS    F              Has to do with CHKHEADR routine\nSAVER9LC DS    F              Has to do with LABELCHK routine\nSAVER9RP DS    F              Has to do with REPTFILE routine\nSAVER9SU DS    F              Has to do with SUMMREPT routine\nSAVER9A2 DS    F              Has to do with ASC2HFWD routine\n* --- above                   SAVE BAL REGISTER for each subroutine\n*\n* above - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\nOURRC    DC    F'0'\nMAXRC    DC    F'0'\nHDRBYTES DS    F\nHDRBSAVE DS    F\nSAVER8C2 DS    F\n         DC    C' '\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    BUFFER OVERFLOW ERROR  '\nERRMESS2 DC    CL133'    TAPE OUTPUT WRITE ERROR'\nERRMESS3 DC    CL133'    OFFSET ERROR           '\nERRMESS4 DC    CL133'    TAPE MARK WRITE ERROR  '\nERRMESS5 DC    CL133' >> FKT HEADER IS INVALID - CHECK FIELD IS WRONG --\n                  >> '\nERRMESS6 DC    CL133' >> FKT HEADER IS INVALID - PREV BYTES <> CURR BYT-\n               ES >> '\n*\n*  -----------------            Tape Output Error Message Texts\nOUTEQC   DC    C' ********** EQUIPMENT CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\nOUTUNEX  DC    C' *********** TAPE HAS ENDED ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- PRIVATE SCRATCH REQUESTED '\n         DC    37C'*'\nOUTDCK   DC    C' **********      DATA CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2FK2T - FAKE TAPE FILE TO ACTUAL TAPE CONVERSI-\n               ON PROGRAM  '\nMESSAGE4 DC    CL133'1VTT2FK2T  -  FAKE TAPE HEADER TRACE REPORT  '\nMESSAGE5 DC    CL133'1VTT2FK2T - FAKE TAPE DATA MOVE - TRACE AND ERROR -\n               REPORT  '\nMESSAGE6 DC    CL133'1VTT2FK2T - FAKE TAPE FILE REPORT - MOVE AND WRITE-\n                STATS  '\nMESSAGE8 DS    0CL133\n         DC    CL8' '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'UNFSCARD'\n         DC    CL10'UNFECARD'\n         DC    CL10'UNFOFFST'\n         DC    CL10'UNFBYTES'\n         DC    CL10'UNFBYMVD'\n         DC    CL10'UNFBUFFR'\n         DC    CL10'UNFBSTRT'\n         DC    CL14'UNFINRCD'\n         DC    CL21' '\nMESSAGE9 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS GOTTEN BY THE PROGRAM, IN READING THROUGH A TAPE.'\nMESSAG10 DC    CL133'        THE UNFAREA (UNFOLD AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST GOTTEN.-\n               '\n*  -----------------            Diagnostic Info Message Texts\nMESSAGE2 DC    CL133'  OFFSET SIZE AND LOCATION '\nMESSAGE3 DC    CL133'  NUMBER OF BYTES WRITTEN  '\nMESSAGE7 DC    CL133'  VOLSER OVERRIDDEN TO:    '\nMESSAG11 DC    CL133'  NUMBER OF CHUNK BYTES    '\nMESSAG12 DC    CL133'  -- End of File Marker - File Number'\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS IN:  '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS IN:  '\nPRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS   :  '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS   :  '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS   :  '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS :  '\nPRMSG07  DC    CL34'     TOTAL DOUBLE TAPE MARKS   :  '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01A DC    CL38'     DATA   WRITTEN FOR FILE:         '\nCTMSG01B DC    CL38'     LABELS WRITTEN FOR FILE:         '\nCTMSG02  DC    CL38'     BYTES  WRITTEN FOR FILE:         '\nCTMSG03  DC    CL38'     TOTAL BYTES   MOVED  FOR TAPE  : '\nCTMSG04  DC    CL38'     TOTAL BYTES  WRITTEN FOR TAPE  : '\nCTMSG05  DC    CL38'     TOTAL BYTES  WRITTEN FOR LABELS: '\nCTMSG06  DC    CL38'     TOTAL BYTES  WRITTEN FOR DATA  : '\nCTMSG07  DC    CL38'     BLOCKS WRITTEN FOR FILE:         '\nCTMSG08  DC    CL38'     TOTAL BLOCKS WRITTEN FOR TAPE  : '\n*\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nPRTLINE  DC    CL133' '\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\n* --- >\nPRVHFLGS DS    X\n* --- >\nEOTMARK  DC    XL12'303030303030303030303030'\nDBINF    DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE\nDBINFH   DC    F'0'\nDBINFL   DC    F'0'\nDBIN     DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL\nDBINH    DC    F'0'\nDBINL    DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nLBINF    DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINFH   DC    F'0'\nLBINFL   DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\nDAINF    DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINFH   DC    F'0'\nDAINFL   DC    F'0'\n         DC    CL8' '\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 Extra fullword for safety\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\nTESTLABL DC    CL80' '\nGETSYSIN DC    CL80' '\nINCARDP  DC    XL80'00'           Previous card-image read\nINCARD   DC    XL80'00'           Current  card-image read\nINCAEND  EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         IEZIOB DSECT=YES\nTRTCSECT CSECT\n* ------------------------------------------------------------------- *\n*   You have to make sure to keep the TRTDSECT that is in LABELCHK    *\n*   (and possibly other places) in synchronization with this CSECT.   *\n* ------------------------------------------------------------------- *\nTRTBL0   DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40818283848586878889404040404040'\n         DC    XL16'40919293949596979899404040404040'\n         DC    XL16'4040A2A3A4A5A6A7A8A9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\nTRTBL1   DS    0D\n         DC    XL16'F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0'\n         DC    XL16'F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1F1'\n         DC    XL16'F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2F2'\n         DC    XL16'F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3'\n         DC    XL16'F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4'\n         DC    XL16'F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5F5'\n         DC    XL16'F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6F6'\n         DC    XL16'F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7F7'\n         DC    XL16'F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8F8'\n         DC    XL16'F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9F9'\n         DC    XL16'C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1C1'\n         DC    XL16'C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2C2'\n         DC    XL16'C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3C3'\n         DC    XL16'C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4C4'\n         DC    XL16'C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5C5'\n         DC    XL16'C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6C6'\nTRTBL2   DS    0D\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\nTRTE2A   DS    0D\n         DC    XL16'000102030405060708090A0B0C0D0E0F'\n         DC    XL16'101112131415161718191A1B1C1D1E1F'\n         DC    XL16'202122232425262728292A2B2C2D2E2F'\n         DC    XL16'303132333435363738393A3B3C3D3E3F'\n         DC    XL16'20414243444546474849A22E3C282B7C'\n         DC    XL16'2651525354555657585921242A293B5E'\n         DC    XL16'2D2F6263646566676869A62C255F3E3F'\n         DC    XL16'707172737475767778603A2340273D22'\n         DC    XL16'806162636465666768698ABBF0FDFEB1'\n         DC    XL16'906A6B6C6D6E6F7071729ABAE6B8C6A4'\n         DC    XL16'B57E737475767778797AAABFD05BDEAE'\n         DC    XL16'ACA3A5B7A9A7B6BCBDBEBAA8AF5DB4D7'\n         DC    XL16'7B414243444546474849CACBCCCDCECF'\n         DC    XL16'7D4A4B4C4D4E4F505152DADBDCDDDEDF'\n         DC    XL16'5CF7535455565758595AEAEBECEDEEEF'\n         DC    XL16'30313233343536373839FAFBFCFDFEFF'\nTRTA2E   DS    0D\n         DC    XL16'000102030405060708090A0B0C0D0E0F'\n         DC    XL16'101112131415161718191A1B1C1D1E1F'\n         DC    XL16'405A7F7B5B6C507D4D5D5C4E6B604B61'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'\n         DC    XL16'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'\n         DC    XL16'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'\n         DC    XL16'79818283848586878889919293949596'\n         DC    XL16'979899A2A3A4A5A6A7A8A9C04FD0A17F'\n         DC    XL16'808182838485868788898A8B8C8D8E8F'\n         DC    XL16'909192939495969798999A9B9C9D9E9F'\n         DC    XL16'A0A14AB19FB26AB5BBB4AAABB0ADAFBC'\n         DC    XL16'B08FB2B3BEA0B6B39DB99BB8B7B8B9AB'\n         DC    XL16'C0C1C2C3C4C59EC7C8C9CACBCCCDCECF'\n         DC    XL16'ACD1D2D3D4D5D6BFD8D9DADBDCDDAEDF'\n         DC    XL16'E0E1E2E3E4E59CE7E8E9EAEBECEDEEEF'\n         DC    XL16'8CF1F2F3F4F5F6E1F8F9FAFBFC8D8EFF'\nTRTA2B   DS    0D\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00010203040506070809000000000000'\n         DC    XL16'000A0B0C0D0E0F000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\n         DC    XL16'00000000000000000000000000000000'\nTRTASPRT DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'405A7F7B5B6C507D4D5D5C4E6B604B61'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'\n         DC    XL16'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'\n         DC    XL16'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'\n         DC    XL16'40818283848586878889919293949596'\n         DC    XL16'979899A2A3A4A5A6A7A8A94D4F5DA17F'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         EJECT\nVTT2FK2T CSECT\n         END\n   TITLE 'UNFOLDEM -- UNFOLD FB-80 DATA INTO A LONG BUFFER'\nUNFOLDEM CSECT\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    UNFOLDEM                                          *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating a       *\n*      real tape from an FAKETAPE-format tape file, which has been  *\n*      folded over into an FB-80 dataset.  The FAKETAPE header      *\n*      contains the number of bytes in the next chunk (complete     *\n*      or partial block) of tape data.  Once this quantity is       *\n*      known, and the beginning position of the data has been       *\n*      established (it starts just after the header ends), then     *\n*      the data itself has to be moved into a buffer, in            *\n*      preparation for that data block being written out to a       *\n*      tape.  This program unfolds the correct amount of data,      *\n*      beginning at a known position in the FB-80 file, into        *\n*      the buffer.  The position in the FB-80 file which marks      *\n*      the beginning of the data to be moved, is called the         *\n*      OFFSET into the 80-byte card, and it starts with position    *\n*      +0.                                                          *\n*                                                                   *\n*  INPUTS and OUTPUTS:   Described below.                           *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called FAKEIN, which contains its input        *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do GETs from FAKEIN, and if necessary, it needs     *\n*      to write messages to SYSPRINT.  The caller has to provide    *\n*      ENTRY FAKEIN and ENTRY SYSPRINT statements in front of       *\n*      the FAKEIN and SYSPRINT DCBs, respectively.                  *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      UNFAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      UNFAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the UNFAREA.                                        *\n*                                                                   *\n*      The caller does one GET of the FB-80 file, to read an        *\n*      FAKETAPE header (that has tape data following it). Once the  *\n*      FAKETAPE header has been read, there should be enough data   *\n*      to supply to the UNFAREA control block, and then this        *\n*      program is called, to complete the move of that tape data    *\n*      to a buffer, and position the FB-80 input just past the      *\n*      data moved, so it should point to the next FAKETAPE header.  *\n*                                                                   *\n*      This program does more GETs from the FB-80 input file,       *\n*      until the request for the number of bytes to be moved,       *\n*      is satisfied.                                                *\n*                                                                   *\n*      The following is the layout of the UNFAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      UNFAREA  DS    0F          UNFOLD AREA CONTROL BLOCK         *\n*      *                          ------ ---- ------- -----         *\n*  --> UNFSCARD DC    F'0'        Start address of 80-byte card     *\n*  --> UNFECARD DC    F'0'        End address of 80-byte card       *\n*  --> UNFOFFST DC    F'0'        OFFSET of data to be moved        *\n*  --> UNFBYTES DC    F'0'        Number of bytes to be unfolded    *\n*      UNFBYMVD DC    F'0'        Number of bytes that were moved   *\n*  --> UNFBUFFR DC    F'0'        Current start address in buffer   *\n*  --> UNFBSTRT DC    F'0'        Original start address of buffer  *\n*      UNFINRCD DC    PL7'0'      Number of GETs for FAKEIN records *\n*      UNFLENTH EQU   *-UNFAREA                                     *\n*      *                                                            *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      UNFBUFFR and UNFOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the output data     *\n*      and input data positions, respectively, that are just        *\n*      after the moved data, so as to wait for the next call,       *\n*      to be able to move more data.  UNFBSTRT preserves the        *\n*      very beginning address of the output buffer, whereas         *\n*      UNFBUFFR is a place somewhere within the buffer, which       *\n*      is the start of where the new data is expected to be         *\n*      moved.                                                       *\n*                                                                   *\n*      Since both the caller and this program do GET operations     *\n*      from the input FB-80 file, the count of the number of GETs   *\n*      done, UNFINRCD, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nUNFOLDEM AMODE 24\nUNFOLDEM RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'UNFOLDEM '\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING UNFOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,FAKEINV              FAKEIN  DCB address in caller\n         ST    R0,FAKINDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to unfold FB-80 data starting at an OFFSET from the     *\n*   beginning of a card, for a certain number of bytes, to a data   *\n*   buffer area whose beginning address is supplied.  More 80-byte  *\n*   records can be read with the GET macro from the FB-80 file, to  *\n*   fulfill the move request.                                       *\n*                                                                   *\n*   Input:   UNFAREA fields are all supplied by the calling         *\n*            program, except for UNFBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            UNFAREA is pointed to by Register 1.                   *\n*                                                                   *\n*            The initial card image which is supplied by the        *\n*            calling program, already is primed with data to be     *\n*            moved (one card's worth of it).  This card contains    *\n*            the starting point for the data to be moved, at an     *\n*            OFFSET (displacement) from the beginning of the card.  *\n*                                                                   *\n*            The input data also contains the address of an         *\n*            output buffer area, which is the target for the        *\n*            (segmented) data moves.  Data will be strung out       *\n*            into this area, one card (or a partial card) at a      *\n*            time.  The current card which is in the input file,    *\n*            which contains the beginning of the data to be         *\n*            moved, has already been loaded into a card image       *\n*            work area pointed to by the calling program.  The      *\n*            OFFSET into this card is where the data to be moved    *\n*            will start.                                            *\n*                                                                   *\n*            It is the responsibility of the calling program to     *\n*            ensure that this routine has access to all of the      *\n*            buffer storage where the data is supposed to be        *\n*            moved to.                                              *\n*                                                                   *\n*   Output:  Data is moved, for the required number of bytes, to    *\n*            the output buffer area.  When more that one card       *\n*            image's worth of data has to be moved, more cards      *\n*            are obtained with the GET macro, from the input file.  *\n*                                                                   *\n*            Ending OFFSET in the FB-80 input file, pointing to     *\n*            just after the data which was moved, in the final      *\n*            card image gotten, is returned to the UNFOFFST field   *\n*            and reported to the caller, in anticipation of the     *\n*            next call to this routine.                             *\n*                                                                   *\n*            Ending address of data in buffer - one byte after      *\n*            the end of the moved data - is returned in the         *\n*            UNFBUFFR field.  The UNFBSTRT field preserves the      *\n*            address of the beginning of the data buffer.           *\n*                                                                   *\n*            A count of bytes actually moved from the FB-80 file    *\n*            to the output buffer area is reported in the UNFBYMVD  *\n*            field.  This must match the byte count of bytes which  *\n*            needed to be moved initially.  That count had been     *\n*            initially supplied by the calling program in the       *\n*            UNFBYTES field.                                        *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nUNFOLD   DS    0H\n         ST    R1,PARMPTR\n         L     R2,=A(UNFBLOCK)\n         USING UNFBLOCK,R2\n         MVC   UNFAREA(UNFLENTH),0(R1)      Move input block to pgm\n         LA    R2,UNFAREA                   And address it.\n         MVC   SAVEBEGC,UNFSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,UNFECARD    Save \"end of card\" address\n         L     R1,UNFSCARD          Address of card\n         MVC   WORKPREV(80),ZEROCARD   Zero prev work area\n         MVC   WORKCURR(80),0(R1)   Move card image to curr work area\n         MVC   UNFBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,UNFSCARD          Point to beginning of card\n         A     R7,UNFOFFST          Add OFFSET to start of input\n         ST    R7,SAVEBEGI          Save where input starts\n         L     R8,SAVEBEGI          Copy beg of input address\n         A     R8,UNFBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n* - - - - - - - - - - - - - - >>    This may be way past the address\n*             of the end of the FB-80 card.  We will decrease this\n*             address as we move bytes from successive cards to the\n*             data buffer, by 80 bytes at a time, as we GET new cards,\n*             until R8 actually falls within the end-of-card address.\n*             We will then use this address to calculate the new\n*             OFFSET for the next piece of data in the FB-80 file.\n*             The new OFFSET is returned to the caller by modifying\n*             the UNFOFFST field in the control block.\n*\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nLOOPSET  DS    0H                   Start moving data\n         L     R3,UNFBUFFR          Point to beginning of buffer\n         ST    R3,SAVEBEGD          Save location in the program.\n         LR    R4,R3                Point R4 to end of data by adding\n         A     R4,UNFBYTES          the number of bytes to the start.\n         ST    R4,SAVEENDD          Save potential end of data location\n         ST    R8,SAVER8TR          Save R8 for trace.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is within the current card.           *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.                       *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         C     R8,SAVEENDC          Is R8 still past end-of-card?\n         BH    LOOPMORE             Yes. Copy till end and GET.\nLOOPSHRT DS    0H                   The move is short, not past end.\n         LR    R6,R8                No. Get byte count to move NOW.\n         SR    R6,R7                Bytes to move\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data to the buffer.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,UNFBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET - save R8\n         S     R6,UNFSCARD          Subtract beginning of card address\n         ST    R6,UNFOFFST          Store the result as new OFFSET\n*        MVC   LINE+1(8),=C'LSHRT2: '\n*        BAL   R9,UNFIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Test if past end\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,UNFBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card gotten\n         MVC   WORKPREV,WORKCURR    Save card image to previous\n         ST    R10,SAVER10          Save register for safety\n         L     R10,FAKINDCB         Point to FAKEIN DCB in caller\n         GET   (10),WORKCURR        Get a new card image\n         L     R10,SAVER10          Restore R10\n         AP    UNFINRCD,=P'1'       Increment count of FAKEIN rcds read\n         L     R7,SAVEBEGC          Point to beginning addr of workarea\n         MVC   0(80,R7),WORKCURR    Overlay caller's card image\n*        MVC   LINE+1(8),=C'LMORE2: '\n*        BAL   R9,UNFIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R3),0(R7)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE OPERATING SYSTEM\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of UNFAREA in caller\n         MVC   0(UNFLENTH,R10),UNFAREA    Copy changed UNFAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(UNFBLOCK)  Return address of UNFAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H          Diagnostic Data - State of UNFAREA currently\n*\n         HEX   LINE+10,4,UNFSCARD\n         HEX   LINE+20,4,UNFECARD\n         HEX   LINE+30,4,UNFOFFST\n         HEX   LINE+40,4,UNFBYTES\n         HEX   LINE+50,4,UNFBYMVD\n         HEX   LINE+60,4,UNFBUFFR\n         HEX   LINE+70,4,UNFBSTRT\n         HEX   LINE+80,4,SAVER8TR\n         HEX   LINE+90,7,UNFINRCD\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nUNFBLOCK CSECT\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for FAKEIN records\nUNFLENTH EQU   *-UNFAREA\n*\nUNFOLDEM CSECT\nWORKPREV DS    CL80                 Contiguous previous card image\nWORKCURR DS    CL80                 Card image work area\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nLINE2    DC    CL133' '\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGD DC    F'0'                 Save beg of buffer data address\nSAVEENDD DC    F'0'                 Save end of buffer data address\nSAVEBEGI DC    F'0'                 Save beg address of card input\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVER8TR DC    F'0'                 Save floating Reg 8 which decreases\nSAVEPARM DC    F'0'                 Save CALLER'S UNFAREA ADDRESS\nPARMPTR  DC    F'0'\nSYSPRINV DC    V(SYSPRINT)\nFAKEINV  DC    V(FAKEIN)\nSYSPRDCB DC    F'0'\nFAKINDCB DC    F'0'\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2LOAD": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x01\\x05 \\x9f\\x01\\x05 \\x9f\\x10\\x06\\x04!\\x04!\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2005-07-28T00:00:00", "modifydate": "2005-07-28T10:06:00", "lines": 1057, "newlines": 1057, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "VTT2TAP$": {"ttr": 6410, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00X\\x01\\x010\\x1f\\x01\\x043O\\x08\\x19\\x00\\x1e\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-10-28T00:00:00", "modifydate": "2004-11-29T08:19:58", "lines": 30, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2TAPE)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(UNFOLDEM)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2TAPX(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2TAP#": {"ttr": 6412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x006\\x01\\x01(\\x9f\\x01\\x05\\x06\\x1f G\\x00\\x13\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2005-03-02T20:47:36", "lines": 19, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Produce a \"real tape\" on an MVS system, from an AWS virtual\n//*  tape image that has been folded over on MVS DASD, into\n//*  FB, LRECL=80 format.\n//*\n//AWSREAD  EXEC PGM=VTT2TAPE PARM=READ\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.V467TS        <=== FB-80 DISK FILE\n//TAPOUT    DD  DISP=OLD,UNIT=562,VOL=SER=V467TS,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSIN     DD  *\nNEWVOL=V467MT\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2TAP@": {"ttr": 6414, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x004\\x01\\x010\\x1f\\x01\\x024_\\x10#\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-10-28T00:00:00", "modifydate": "2002-12-11T10:23:34", "lines": 29, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R11.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R11.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2TAPE)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(CYL,5),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWLKED,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB440533\n SETCODE AC(0)\n NAME VTT2TAPE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2TAPE": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00Y\\x01\\x00%O\\x01\\x05&o\\x10\\t\\t\\xec\\x07\\x9b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2005-09-23T10:09:59", "lines": 2540, "newlines": 1947, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2TAPE -- COPY AWS FORMAT FILE TO A REAL TAPE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE: VTT2TAPE.   Written by Sam Golob                **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to process P390 and FLEX-ES MVS       **\n**            Virtual Tape data in AWS format.  This data   **\n**            is uploaded to an MVS system as an FB-80      **\n**     card-image file.  The receiving MVS system does      **\n**     not have to be able to handle AWS-format virtual     **\n**     tapes, but it can use this program to read the tape  **\n**     data from this folded AWS-format file, and create    **\n**     a real tape from it.                                 **\n**                                                          **\n**     The OS2 or PC AWS-format tape file that was created  **\n**     by the P390 or FLEX-ES system as a virtual tape, is  **\n**     uploaded to the MVS system as an FB-80 card-image    **\n**     file, with its (continuous stream of) data folded    **\n**     over into 80-byte records, that can be blocked on    **\n**     MVS.  This VTT2TAPE program reads the resulting      **\n**     file, and creates a real output tape using EXCP, on  **\n**     a real tape drive, by filling a buffer and writing   **\n**     out its contents to the real tape.                   **\n**                                                          **\n**     This program is designed to also take input from     **\n**     the FB-80 AWS-format output file, which is produced  **\n**     by the VTT2DISK program.  These two programs,        **\n**     VTT2TAPE and VTT2DISK, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     1.  Since all the tape data is folded into 80-byte   **\n**         record segments, these have to be logically      **\n**         strung together, to be able to correctly write   **\n**         the tape data to tape blocks.                    **\n**                                                          **\n**     2.  First, the program has to correctly jump from    **\n**         one AWS header record to the next, and so        **\n**         proceed through all the headers in the entire    **\n**         tape file, not missing any.  Diagnostic output   **\n**         from this process, is written to the optional    **\n**         SYSTRACE ddname, if it is present in the         **\n**         execution JCL (see below).                       **\n**                                                          **\n**         The first header of an AWS-format tape is the    **\n**         first six bytes of the file.  Once you have      **\n**         the first header, you have the number of bytes   **\n**         of data until the next header, and so forth.     **\n**                                                          **\n**         The UNFOLDEM called program unfolds the data     **\n**         from a chunk of data after an AWS header, and    **\n**         strings it out into an output buffer, after      **\n**         which an EXCP operation writes the entire        **\n**         buffer to tape.  If a block of data is from      **\n**         several chunks, the data pieces are all strung   **\n**         out into the output buffer, and then at the      **\n**         end of the block (flag X'20' in the header),     **\n**         all of the buffer data is written out to tape.   **\n**                                                          **\n**     3.  In the process of jumping from one header to     **\n**         another, the program then moves the correct      **\n**         number of data bytes that are in between the     **\n**         headers, into the output buffer, 80-bytes or     **\n**         less, at a time.  This action depends on the     **\n**         type of header that we have.                     **\n**                                                          **\n**           HEADER TYPE       ACTION                       **\n**           ------ ----       ------                       **\n**           X'80'             Initialize buffer address.   **\n**                             Write chunk of data to       **\n**                              the buffer.                 **\n**                                                          **\n**           X'00'             Write another chunk of data  **\n**                              to the end of the previous  **\n**                              chunk in the buffer.        **\n**                                                          **\n**           X'20'             Add the chunk of data to     **\n**                              the buffer.                 **\n**                             Write out the entire buffer. **\n**                             Initialize the start of      **\n**                              buffer address.             **\n**                                                          **\n**           X'A0'             X'80' and X'20' combined.    **\n**                                                          **\n**           X'40'             Write a tape mark.           **\n**                             Finalize the tape file.      **\n**                             Initialize the output buffer **\n**                              location.                   **\n**                                                          **\n**  Note:  If the output tape is too short, VTT2TAPE        **\n**         attempts to recover by issuing an EOV macro,     **\n**         which calls for a mount of a second tape,        **\n**         as a PRIVATE SCRATCH tape.  More data from the   **\n**         AWS file is written out to the second tape.      **\n**                                                          **\n**         However, there is a catch here.  The second      **\n**         tape does not contain additional labels, as      **\n**         DFP would have written.  The second tape         **\n**         continues with the next block of data, after     **\n**         the last block which was successfully written    **\n**         to the first tape.                               **\n**                                                          **\n**         Therefore, in order to subsequently read the     **\n**         second tape, you have to treat both tapes as     **\n**         two-volume BLP, using JCL similar to this,       **\n**         even if the first tape is SL...                  **\n**                                                          **\n**       //TAPOUT    DD  DISP=OLD,UNIT=TAPE,                **\n**       //          VOL=(,RETAIN,SER=(VOL001,VOL002,etc)), **\n**       //          LABEL=(n,BLP,EXPDT=98000)              **\n**                                                          **\n**         where n (for BLP) would be 3m-1 (where m is      **\n**         the SL file number).                             **\n**                                                          **\n**         Sorry for that.  The reason is because this      **\n**         program writes tape blocks using EXCP, and       **\n**         for the second volume, I'd have to manufacture   **\n**         my own tape labels, and I haven't added such     **\n**         an enhancement at this time.  If BSAM or QSAM    **\n**         created a second SL tape, then the extra EOV     **\n**         and VOL and HDR labels are created by DFP.       **\n**         EXCP contains no such provisions, leaving any    **\n**         extra label creation entirely up to the          **\n**         programmer.                                      **\n**                                                          **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**         In order to make sure that the VTT2TAPE program  **\n**         is doing its job properly, it produces a lot of  **\n**         trace data and status data, as it is reading     **\n**         through the folded FB-80 AWS format tape.  In    **\n**         order not to clutter the summary report, most    **\n**         of this data is written to \"Optional DDNAMEs\".   **\n**                                                          **\n**         Optional DDNAMEs don't have to be coded in the   **\n**         JCL.  But if they are coded, they will contain   **\n**         the extra trace data which VTT2TAPE produces.    **\n**                                                          **\n**         The optional DDNAMEs are SYSFILES, SYSTRACE,     **\n**         SYSMOVED, and SYSIN.                             **\n**                                                          **\n**         Full JCL to run the VTT2TAPE program is as       **\n**         follows:                                         **\n**                                                          **\n**         (But you can code PARM=READ, or                  **\n**            PARM='TVOL(volser)'       or                  **\n**            PARM='TVOL=volser'              )             **\n**                                                          **\n**         If you code, PARM='TVOL.....' to override the    **\n**         volser of the new tape, this may be further      **\n**         overridden by the SYSIN card:  NEWVOL=volser.    **\n**                                                          **\n**       //   jobcard                                       **\n**       //AWSREAD  EXEC PGM=VTT2TAPE                       **\n**       //STEPLIB   DD  DISP=SHR,DSN=your.load.library     **\n**       //AWSIN     DD  DISP=SHR,DSN=folded.aws.file,      **\n**                   DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)  **\n**       //TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=TEST01,  **\n**       //          LABEL=(1,BLP,EXPDT=98000)              **\n**       //SYSPRINT  DD  SYSOUT=*                           **\n**       //SYSFILES  DD  SYSOUT=*                           **\n**       //SYSTRACE  DD  SYSOUT=*                           **\n**       //SYSMOVED  DD  SYSOUT=*                           **\n**       //SYSUDUMP  DD  SYSOUT=*                           **\n**       //SYSIN     DD  *                                  **\n**       NEWVOL=PROD01                                      **\n**       /*                                                 **\n**       //                                                 **\n**                                                          **\n**         where you can leave out SYSTRACE, SYSMOVED,      **\n**         and SYSUDUMP, if you want to.  I'd strongly      **\n**         suggest including (at least) SYSFILES, though.   **\n**                                                          **\n**         If you code NEWVOL=volser in a //SYSIN card,     **\n**         starting in column 1, VTT2TAPE will change       **\n**         the VOLSER in every VOL1 label (should only be   **\n**         one of them) on the tape, to the value you       **\n**         specify.                                         **\n**                                                          **\n**         SYSFILES gives you block counts and byte counts  **\n**         for all files read and written.  SYSFILES also   **\n**         differentiates between label files and data      **\n**         files.                                           **\n**                                                          **\n**         SYSTRACE tells you if you are running through    **\n**         all the AWS headers properly.  SYSMOVED tells    **\n**         you how many bytes were moved from each chunk    **\n**         of data between AWS headers.  SYSUDUMP is        **\n**         there to contain the MVS-produced dump, upon     **\n**         any abnormal termination of the program.         **\n**                                                          **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.1 - Correct Operation of data moves from    **\n**       the AWS file to the output buffer, and produce     **\n**       traces to debug this.  SYSMOVED ddname.            **\n**                                                          **\n**    Version 1.2 - Add byte counts and SYSFILES ddname.    **\n**       Fix AWSTAPE emulator problem when writing a        **\n**       tape mark.  OS/2 AWSTAPE emulator cares what       **\n**       the byte count is in CCW+6, even if the opcode     **\n**       is X'1F'.  Made sure the byte count is always 0    **\n**       when doing EXCP with a \"write tape mark\" opcode.   **\n**                                                          **\n**    Version 1.3 - Check for error conditions on output.   **\n**       Put version number and assembly date into headers. **\n**       Put cumulative byte totals in SYSFILES report.     **\n**                                                          **\n**    Version 1.4 - Differentiate between label files and   **\n**       data files.  Different cumulative byte counts for  **\n**       each.                                              **\n**                                                          **\n**    Version 1.5 - Better SYSFILES report upon volume      **\n**       switch, if the first output tape is too short.     **\n**       Pass null SL files.  Don't stop in the middle of   **\n**       them, because of the two tape marks after the      **\n**       HDR2.                                              **\n**                                                          **\n**    Version 1.6 - Block counts for each file and for the  **\n**       entire tape.                                       **\n**                                                          **\n**    Version 1.7 - Allow PARM=READ, just to get stats.     **\n**                                                          **\n**    Version 1.8 - Make file-level stats reporting into    **\n**       a subroutine.                                      **\n**                                                          **\n**    Version 1.9 - Header validation.  If a header is      **\n**       corrupted, the chain of headers will be broken,    **\n**       and we try to detect this and abort the program,   **\n**       before any significant damage is done to the       **\n**       output file.  We try and keep as much valid data   **\n**       as possible in the output tape.  Add return code   **\n**       indication of different error conditions.          **\n**                                                          **\n**    Version 1.9A - Better messages if this header's       **\n**       previous byte value doesn't match the last         **\n**       header's current byte value.  Pinpoint file and    **\n**       block number in error.  Allow 4-byte version       **\n**       number literal, in preparation for 1.10, etc.      **\n**                                                          **\n**    Version 1.10 -   Optional SYSIN dd name which can     **\n**       contain a card:  NEWVOL=volser   starting in       **\n**       column 1, which overrides the output tape's        **\n**       volume serial.                                     **\n**                                                          **\n**    Version 1.11 -   INAREA now addressed indirectly.     **\n**                                                          **\n**    Version 1.12 -   Logic changed to accommodate chunks  **\n**       of data between headers that are shorter than the  **\n**       tape blocks.  Much of the program has been         **\n**       completely rewritten.  Moves of data between AWS   **\n**       headers to the output buffer, are now done only    **\n**       by the UNFOLDEM called program.  The SYSFILES      **\n**       report has been improved.  The SYSMOVED and        **\n**       SYSTRACE reports now reflect the data associated   **\n**       with each header encountered.                      **\n**                                                          **\n**    Version 1.13 -   Put in ASG enhancement to allow a    **\n**       volser change through a PARM='TVOL=nwvser', or     **\n**       PARM='TVOL(nwvser)'.  Put in a check for short     **\n**       volsers (less than 6 characters) and ran the parm  **\n**       for the volser through a translate table first,    **\n**       to uppercase it and clean it up somewhat.  The     **\n**       volser that is coded in the SYSIN DD card can      **\n**       completely override this, so you still have the    **\n**       freedom to create bizarre volsers if you really    **\n**       want to.  BTW, you do not need to code the new     **\n**       volser in the JCL.  This program does not do a     **\n**       RDJFCB to find out what is in the JCL.             **\n**                                                          **\n**                                                          **\n**  RETURN CODES:                                           **\n**                                                          **\n**    RC =  0 :    Normal Operation                         **\n**                                                          **\n**    RC =  4 :    A Private Scratch tape was asked for,    **\n**                 because the end of the first output      **\n**                 tape was reached.                        **\n**                                                          **\n**    RC =  8 :                                             **\n**                                                          **\n**    RC = 12 :    Program operation had to be aborted      **\n**                 because the chain of AWS headers was     **\n**                 broken in the middle, and an invalid     **\n**                 \"AWS header\" was encountered.  The       **\n**                 program writes out all valid tape        **\n**                 blocks, and then stops action, with a    **\n**                 message that indicates the problem,      **\n**                 and the header found to be in error.     **\n**                 The last tape block written, is the      **\n**                 block before the last correct AWS        **\n**                 header.  This condition probably         **\n**                 occurred because an invalid AWS header   **\n**                 \"current length\" made it impossible      **\n**                 to find the next valid AWS header.       **\n**                                                          **\n**                                                          **\n**    Please note that a higher return code will            **\n**    supersede a lower return code, and that multiple      **\n**    error conditions might exist, if there is a nonzero   **\n**    return code higher than 4.  Look at the SYSFILES      **\n**    report, and the other reports, to determine the       **\n**    exact error(s) present.                               **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n&LLEV    SETC  '1.13'\n         YREGS\n         EJECT\nVTT2TAPE CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2TAPE AMODE 24\nVTT2TAPE RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2TAPE - AWS FB-80 DISK FILE INPUT TO REAL TAPE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2TAPE,R12,R11,R10,R8\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n         MVC   SVNEWVOL(6),=C'      '    MAKE SVNEWVOL BLANK\n         L     R1,0(,R1)             Get PARM field\n         CLC   =C'TVOL',2(R1)        Is it a Tape volume override?\n         BNE   CHKREAD               No. Then check if \"read only\".\n         MVC   CHKNWVOL(6),7(R1)     Yes. Move chars from PARM=TVOL.\n         TR    CHKNWVOL(6),TRTBLPRT  Translate to clean this up some.\n*\n*  Code to guard against a short volser or leading blanks in the PARM.\n* >> below\n*\n         STM   R2,R5,SAVR2T5         Save 4 registers\n         LA    R3,CHKNWVOL           Load address of source field\n         LA    R4,6                  Load limit of characters moved\n         LA    R5,SVNEWVOL           Load address of target field\n         LR    R2,R5                 Start address of target field\nMVELOOP  DS    0H                    Guard against a short volser.\n         CLI   0(R3),X'00'           Delimiter of hexzeros?\n         BE    MVELEND               Yes, end the move.\n         CLI   0(R3),C' '            Delimiter of blank?\n         BE    MVELEND               Yes, end the move.\n         CLI   0(R3),C')'            Delimiter of close paren?\n         BE    MVELEND               Yes, end the move.\n         MVC   0(1,R5),0(R3)         Move one character over.\n         OI    FLAGNEWV,X'01'        Flag that volser needs change.\n         LA    R3,1(,R3)             Bump source character.\n         LA    R5,1(,R5)             Bump target character.\n         BCT   R4,MVELOOP            Try again if before end.\nMVELEND  DS    0H\n         LM    R2,R5,SAVR2T5         Restore 4 registers\nMOVEEND  DS    0H\n*\n* >> above\n*  Code to guard against a short volser or leading blanks in the PARM.\n*\n* ----- >                            Parm = READ    <--- below\n*    See code for PARM='TVOL=nwvser' which is above, in several places.\n* ----- >\nCHKREAD  CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BNE   COPYTAPE              No. Default is to copy the tape.\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\nCOPYTAPE DS    0H\n* ----- >                            Parm = READ    <--- above\n*\n         L     R15,=V(UNFOLDEM)      UNFOLDEM subprogram\n         ST    R15,SVUNFOLD          Save its entry point\n         L     R0,=A(INAREA)         Address of tape buffer\n         ST    R0,SVINAREA           Store it away for later use.\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE4+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE5+88(31),HEADDLIT\n         MVC   MESSAGE6+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE4+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE5+61(21),LEVELLIT\n         MVC   MESSAGE6+61(21),LEVELLIT\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants and\n         MVI   FLAGSYST,X'00'        No optional ddnames initially.\n         ZAP   INHDRS,=P'0'          Count number of AWS headers\n         ZAP   INTYPE1,=P'0'         Counts of Header Types\n         ZAP   INTYPE2,=P'0'\n         ZAP   INTYPE3,=P'0'\n         ZAP   INTYPE4,=P'0'\n         ZAP   INTYPE5,=P'0'\n         ZAP   FILCOUNT,=P'0'        Initialize file counter\n         MVC   DBIN(8),=D'0'         Initialize byte counters\n         MVC   LBIN(8),=D'0'\n         MVC   DAIN(8),=D'0'\n         MVC   DAINF(8),=D'0'\n         MVC   LBINF(8),=D'0'\n         MVC   DBINF(8),=D'0'\n         MVC   OURRC,=F'0'\n         MVC   MAXRC,=F'0'\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE DDNAME THERE?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       SHOW PRESENCE OF SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       SHOW PRESENCE OF SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       SHOW PRESENCE OF SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       SHOW PRESENCE OF SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n*---------------------------------------------------------------------*\n* -------------- >>>>>>   Look for new output volume name - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    NONSYSIN             No. Then can't open it.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BNE   SYSINLUP              No. Don't use this card.\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         OI    FLAGNEWV,X'01'             And show a new volser here.\n         B     NONSYSIN\nSYSINEND DS    0H\n         CLOSE SYSIN\nNONSYSIN DS    0H\n* -------------- >>>>>>   Look for new output volume name - ABOVE\n*---------------------------------------------------------------------*\n         OPEN  (AWSIN,(INPUT))\n         OPEN  (SYSPRINT,(OUTPUT))\n         TM    READFLAG,X'01'        Is this run READ ONLY?\n         BO    NOTAPOPN              Yes. Don't OPEN output tape.\n         OPEN  (TAPOUT,(OUTPUT))\nNOTAPOPN DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   NOSYSTRC              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE4\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA4\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSTRACE,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\nNOEXTRA4 DS    0H\n         PUT   SYSTRACE,MESSAGE9\n         PUT   SYSTRACE,MESSAG10\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSTRACE,PRTLINE\n         PUT   SYSTRACE,MESSAGE8\n*--->>\nNOSYSTRC DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE5\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA5\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSMOVED,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSMOVED,PRTLINE\nNOEXTRA5 DS    0H\n*--->>\nNOSYSFIL DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSMVD              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE6\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA6\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSFILES,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSFILES,PRTLINE\nNOEXTRA6 DS    0H\n*--->>\nNOSYSMVD DS    0H\n* ----------------------------------------------------------------- *\n*     Write the top Header Line, with the date and time in it.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n*--->>\n         TM    READFLAG,X'01'        If READ ONLY, print extra line.\n         BZ    NOEXTRA1\n         MVC   PRTLINE,PRTLINE-1\n         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'\n         PUT   SYSPRINT,PRTLINE\n         MVC   PRTLINE,PRTLINE-1\n         PUT   SYSPRINT,PRTLINE\nNOEXTRA1 DS    0H\n*--->>\n* ----------------------------------------------------------------- *\n*     Start trying to bop through the AWS headers.  The first 6\n*     bytes of the file, is the first header, so we start there.\n* ----------------------------------------------------------------- *\nLOOPSTRT DS    0H                    START OF PROCESSING\n         LA    R7,INCARD             INITIALIZE BEG OF RECORD\n         ST    R7,SAVEBEGC           AND SAVE THIS SETTING.\n* ---------------------------------------------------------------- *\n         LA    R6,INCAEND            INITIALIZE END OF RECORD\n         ST    R6,SAVEENDC           AND SAVE THIS SETTING.\n         LA    R1,80(,R6)            BOP BY ANOTHER RECORD LENGTH\n         ST    R1,SAVEEN80           AND SAVE WHERE THIS IS.\n* ---------------------------------------------------------------- *\n         GET   AWSIN,INCARD           Do the very first GET to find\n*                                     the first header in the file.\n*                                     The first header lets you find\n*                                     all the other headers.\n         AP    UNFINRCD,=P'1'         Update the control block too\n         MVC   INHEADER(6),0(R7)      Got the first header\n* ---------------------------------------------------------------- *\n*     We come here when we know we're at the beginning of an\n*     AWS header record.\n* ---------------------------------------------------------------- *\nGOTHEADR DS    0H                     Got a header record\n* ---------------------------------------------------------------- *\n         MVC   HDRPREVS(2),HDRPREV    SAVE PREVIOUS BLOCK SIZE\n         MVC   HDRLENGS(2),HDRLENG    SAVE SIZE OF NEXT BLOCK\n* ---------------------------------------------------------------- *\n         AP    INHDRS,=P'1'           Count the number of headers.\n         MVC   HEADER(6),INHEADER     Move header to formatting area.\n*--->\n         ST    R9,SAVER9HV            Save link register\n         BAL   R9,VALIDHDR            Make sure header flags are valid\n         L     R9,SAVER9HV            Restore link register\n         TM    HDRVFLAG,X'01'         Is the header in error?\n         BO    HEADRERR               Yes-report condition and end pgm.\n*--->\n*--->       Format the header by interpreting the length fields,\n*--->       and then print the values for diagnosis if necessary.\n*--->\n*--->       HDRLENG contains the true halfword byte count of data\n*--->               following this header.\n*--->       HDRPREV contains the true halfword byte count of data\n*--->               preceding this header.\n*--->\n*--->       In case fullword versions of these quantities are\n*--->       needed, HDRFULLS and HDRPFULS are supplied too.\n*--->\n         MVC   SAVEHDR(6),HEADER      Save a copy of the current header\n         MVC   HDRFILL(2),=X'0000'    Fill in zeros\n         MVC   HDRPRVF(2),=X'0000'      for\n         MVC   HDRLENFL(2),=X'0000'        fullword values\n         MVC   HDRPRVFL(2),=X'0000'           of halfwords.\n         MVC   HDRLENG+1(1),HDRCURLN     REVERSE\n         MVC   HDRLENG(1),HDRCURLN+1        BYTES\n         MVC   HDRPREV+1(1),HDRPRVLN     REVERSE\n         MVC   HDRPREV(1),HDRPRVLN+1        BYTES\n*\n         MVC   PRTLINE,PRTLINE-1      CLEAR PRINT LINE\n         HEX   PRTLINE+8,6,HEADER     UNFAREA at GOTHEADR time display\n         HEX   PRTLINE+28,4,UNFSCARD                            .\n         HEX   PRTLINE+38,4,UNFECARD                            .\n         HEX   PRTLINE+48,4,UNFOFFST                            .\n         HEX   PRTLINE+58,4,UNFBYTES                            .\n         HEX   PRTLINE+68,4,UNFBYMVD                            .\n         HEX   PRTLINE+78,4,UNFBUFFR                            .\n         HEX   PRTLINE+88,4,UNFBSTRT                            .\n         HEX   PRTLINE+98,7,UNFINRCD                            .\n* ---------------------------------------------------------------- *\n*              DETERMINE THE TYPE OF HEADER YOU HAVE\n*                    AND COUNT HOW MANY OF EACH\n* ---------------------------------------------------------------- *\nKINDAHDR DS    0H\n         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?\n         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK\n         AP    INTYPE3,=P'1'          YES. COUNT THIS TYPE\n         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE\nKCHKBEG  DS    0H\n         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?\n         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.\n         AP    INTYPE1,=P'1'          YES. COUNT THIS TYPE\nKCHKEND  DS    0H\n         TM    HDRFLAG1,X'20'         END OF BLOCK?\n         BNO   KINDAH40               NO. CHECK IF END OF FILE\n         AP    INTYPE2,=P'1'          YES. COUNT THIS TYPE\nKINDAHA0 DS    0H\n         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?\n         BNE   KINDAH40               NO. TEST FOR EOF HEADER.\n         AP    INTYPE5,=P'1'          YES. COUNT IT FOR REPORTING.\n         B     KINDAHEN               AND DON'T TEST MORE BITS.\nKINDAH40 DS    0H\n         TM    HDRFLAG1,X'40'         END OF FILE HEADER?\n         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.\n         AP    INTYPE4,=P'1'          YES. COUNT THIS TYPE\n*\n*     Invalid types were already caught by the VALIDHDR routine.\n*\nKINDAHEN DS    0H\n         HEX   PRTLINE+22,1,HDRFLAG1                            .\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         PUT   SYSTRACE,PRTLINE\nNOSYSTR1 DS    0H\n         CLC   SAVEHDR(6),EOTMARK     IS THE HEADER AN EOT MARK?\n         BNE   NOFIN                  NO. DON'T STOP THE PROGRAM.\n         NI    UNEXFLAG,FF-X'01'      TURN OFF UNIT EXCEPTION FLAG\n         TM    FLAGHDRL,X'01'         YES. BUT TEST IF AFTER HDR 1 OR 2\n         BO    NOFIN                  AFTER HDR1 OR HDR2, DON'T END PGM\n         B     FIN                    OTHERWISE END THE PROGRAM.\nNOFIN    DS    0H\n*------------------------------>  Validate Header Quantities  <-- below\n*\n*   This validation checks if the bytes in the \"previous\" byte count\n*   field match the byte count in the \"forward\" field of the previous\n*   header.  If there is an error, it is reported now.\n*\n         CLC   HDRLENGS(2),HDRPREV    Is Prev Length = Last Current ?\n         BE    HDRVALID               Yes. As it should be.\n         MVC   OUTLINE,OUTLINE-1      No. Corrupted headers.\n         MVC   OUTLINE,ERRMESS6       Write nasty message.\n         MVI   OUTLINE+58,C'P'        Display prev hdr quantity.\n         HEX   OUTLINE+60,2,HDRPREV\n         MVI   OUTLINE+66,C'C'        Display last current hdr amount.\n         HEX   OUTLINE+68,2,HDRLENGS\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'        Set RC = 12\n         CLC   MAXRC,OURRC            Is MAXRC higher?\n         BH    SAXERC02               Yes. Keep it.\n         MVC   MAXRC,OURRC            No.  Raise MAXRC to this one.\nSAXERC02 DS    0H\n         TM    FLAGSYST,X'01'         Write nastygram to SYSTRACE.\n         BZ    NOERRX1\n         PUT   SYSTRACE,OUTLINE\nNOERRX1  DS    0H\n         TM    FLAGSYST,X'02'         Write nastygram to SYSMOVED.\n         BZ    NOERRX2\n         PUT   SYSMOVED,OUTLINE\nNOERRX2  DS    0H\n         TM    FLAGSYST,X'04'         Write nastygram to SYSFILES.\n         BZ    NOERRX4\n         PUT   SYSFILES,OUTLINE\nNOERRX4  DS    0H\n         PUT   SYSPRINT,OUTLINE       Write nastygram to SYSPRINT.\n*\n*       Maybe think of ending the program operation here.\n*       REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE\n*\nHDRVALID DS    0H\n*------------------------------>  Validate Header Quantities  <-- above\n*\n*\n* - - - - - - - >>>>>   End of Header Operations....\n* - - - - - - - >>>>>   Now go move the data afterward.\n* ---------------------------------------------------------------- *\n*     At this point, we will begin moving the data that is after\n*     the first header.  Future OFFSETs will be supplied by the\n*     previous call to the UNFOLDEM program.\n* ---------------------------------------------------------------- *\nLOOKINIT DS    0H                Start looking for the data at the\n*                                beginning of the AWSIN tape file.\n         TM    INITFLAG,X'01'    Not the first time here?\n         BO    LOOKIEND          Bypass initializations.\n         OI    INITFLAG,X'01'    Do this only once for the entire tape.\n         MVC   UNFOFFST,=F'6'    Initialize OFFSET to be just past\n*                                the first header in the file.\n         MVC   UNFBUFFR,UNFBSTRT  Init buffer loc to start of buffer\nLOOKIEND DS    0H\n* ---------------------------------------------------------------- *\nMOVEDATA DS    0H                This is the call to UNFOLDEM.\n*                                We fill in the necessary fields.\n*\n*    UNFOLDEM is only intended to move the data between the AWS\n*    headers.  \"After processing\" is controlled by the flags in\n*    the headers.  After each header is processed, we again point\n*    to the data after the headers (if any) and call UNFOLDEM to\n*    move it.\n*\n         MVC   PREVHDR,SAVEHDR     Copy of last header for action later\n         MVC   UNFSCARD,SAVEBEGC   Beginning address of input card\n         MVC   UNFECARD,SAVEENDC   End address of input card\n         XC    UNFBYTES,UNFBYTES   Zero out fullword bytes to be moved\n         MVC   UNFBYTES+2(2),HDRLENG   And move in halfword value\n         L     R1,SVINAREA         Point to address of buffer\n         ST    R1,UNFBSTRT         Store it in beginning buffer field\n         TM    NOWRTFLG,X'01'      Continue data move in same buffer?\n         BO    MOVEBUFF            Yes. Don't reinitialize in buffer.\n         ST    R1,UNFBUFFR         Store it in current buffer field\nMOVEBUFF DS    0H\n*        MVC   LINE+1(8),=C'BEFCALL '\n*        BAL   R9,UNFIMAGE\n         LA    R1,UNFAREA          Point to UNFAREA control block\n         L     R15,SVUNFOLD        Load entry point of UNFOLDEM pgm\n         BALR  R14,R15             Call the program and move data.\n         MVC   UNFAREA(UNFLENTH),0(R1)  Move modified UNFAREA to pgm\n*        MVC   LINE+1(8),=C'AFTCALL '\n*        BAL   R9,UNFIMAGE\n* -- Test for call of LABELCHK -- >   below\n*   We have just moved the bytes.  Now we check if the file is a label.\n         NI    ISLBLFLG,FF-X'01'   Initially assume it's not a label.\n         L     R1,UNFBYMVD         The number of bytes moved just now.\n         C     R1,=X'00000050'     Was it exactly 80?\n         BNE   NOLBLCHK            No. Assume it can't be a label.\n         L     R1,UNFBSTRT         Grab address of data buffer.\n         MVC   TESTLABL(80),0(R1)  Move 80 bytes to the testing area.\n         BAL   R9,LABELCHK         Test to see if it is a label.\n         TM    ISLBLFLG,X'01'      Is it a label?\n         BZ    NOLBLCHK            No. Assume entire file is not labels\n         OI    FILBLFLG,X'01'      Yes. Turn on label flag at the\n*                                   file level.\nNOLBLCHK DS    0H\n* -- Test for call of LABELCHK -- >   above\n* ---------------------------------------------------------------- *\n         BAL   R9,AFTRMOVE       Housekeeping after the data move.\n*        MVC   LINE+1(8),=C'AFTAFTR '\n*        BAL   R9,UNFIMAGE\n         BAL   R9,CHKHEADR       Get new header ready for handling.\n*        MVC   LINE+1(8),=C'AFTCHKH '\n*        BAL   R9,UNFIMAGE\n         B     GOTHEADR          Assume you've got another header.\n* ---------------------------------------------------------------- *\n*          END OF INPUT AWS DATA                                   *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         BAL   R9,WRITTPMK          WRITE FINAL TAPE MARK\n         B     AGLE                 Finish processing\n* ---------------------------------------------------------------- *\nHEADRERR DS    0H\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS5\n         HEX   OUTLINE+58,6,HEADER\n         ZAP   FERCOUNT,FILCOUNT      Get File number in error\n         AP    FERCOUNT,=P'1'         By adding 1 to last valid file\n         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error\n         AP    BLERRCNT,=P'1'         By adding 1 to last valid block\n         MVC   OUTLINE+77(4),=C'File'    Put literal into message\n         MVC   OUTLINE+82(9),FILEPAT     Get file number in error\n         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.\n         MVC   OUTLINE+96(5),=C'Block'   Put literal into message\n         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number\n         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.\n         MVC   OURRC(4),=F'12'    RC = 12 for header error.\n         CLC   MAXRC,OURRC        Is MAXRC higher?\n         BH    SAMERC02           Yes. Keep it.\n         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.\nSAMERC02 DS    0H\n         TM    FLAGSYST,X'01'\n         BZ    NOERR01\n         PUT   SYSTRACE,OUTLINE\nNOERR01  DS    0H\n         TM    FLAGSYST,X'02'\n         BZ    NOERR02\n         PUT   SYSMOVED,OUTLINE\nNOERR02  DS    0H\n         TM    FLAGSYST,X'04'\n         BZ    NOERR04\n         PUT   SYSFILES,OUTLINE\nNOERR04  DS    0H\n         PUT   SYSPRINT,OUTLINE\n* ---------------------------------------------------------------- *\nAGLE     DS    0H                   Print the Summary Report\n         BAL   R9,SUMMREPT\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\n         CLOSE AWSIN\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'4'\n         BNH   NOERRPRT\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRPRT DS    0H\n         PUT   SYSPRINT,OUTLINE\n         CLOSE SYSPRINT\n         TM    READFLAG,X'01'       If READ ONLY, don't CLOSE tape.\n         BO    NOTAPCLS\n         CLOSE TAPOUT\nNOTAPCLS DS    0H\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+6(7),=C'MaxRC ='\n         HEX   OUTLINE+14,1,MAXRC+3\n         CLC   MAXRC(4),=F'0'\n         BE    NOERRFIL\n         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'\n         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'\nNOERRFIL DS    0H\n         PUT   SYSFILES,OUTLINE\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         MVC   16(4,R13),MAXRC      Load Maximum Return Code\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H                 Take a picture of the UNFAREA now.\n         HEX   LINE+10,4,UNFSCARD    Starting card address.\n         HEX   LINE+20,4,UNFECARD    Ending card address.\n         HEX   LINE+30,4,UNFOFFST    Offset (starting and ending)\n         HEX   LINE+40,4,UNFBYTES    Number of bytes to be moved.\n         HEX   LINE+50,4,UNFBYMVD    Number of bytes that were moved.\n         HEX   LINE+60,4,UNFBUFFR    Current start location in buffer.\n         HEX   LINE+70,4,UNFBSTRT    Location of beginning of buffer.\n         HEX   LINE+80,7,UNFINRCD    Number of GETs done to AWSIN file.\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1           Clear LINE after PUT.\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nCHKHEADR DS    0H                 Position to the next header\n*                                 The idea is to fill the INHEADER\n*                                 field with the correct value.\n         ST    R9,SAVER9CH        Save BAL register\n         L     R1,UNFOFFST        New offset, returned from UNFOLDEM.\n         C     R1,=F'74'          Bigger or equal to 74?\n         BL    CHKHOFSL           No. Just copy header straight.\nCHKHOFSH DS    0H                 Yes. Need to combine with next card.\n         MVC   INCARDP,INCARD     Copy this card to prev 80 byte area.\n         GET   AWSIN,INCARD       GET another card adjacent to previous\n         AP    UNFINRCD,=P'1'     Update UNFAREA field too.\n         LA    R7,INCARDP         Point to two consecutive cards.\n         A     R7,UNFOFFST        Add the returned offset.\n         MVC   INHEADER(6),0(R7)  Move the new header to staging area.\n         LA    R7,6(,R7)          Bump R7 past the new header.\n         S     R7,=A(INCARD)      Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\n         B     CHKHEND            Finish this processing.\nCHKHOFSL DS    0H\n         LA    R7,INCARD          < 74. Header is in original card.\n         LA    R7,0(R1,R7)        Bump by offset - point to new header\n         MVC   INHEADER(6),0(R7)  And move it to staging area.\n         LA    R7,6(,R7)          Bump R7 past the new header.\n         L     R1,=A(INCARD)      Address of current card\n         SR    R7,R1              Get new offset for next UNFOLDEM call\n         ST    R7,UNFOFFST        Store it in the UNFAREA control block\nCHKHEND  DS    0H\n         L     R9,SAVER9CH        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nAFTRMOVE DS    0H                 After the move, we act on the\n*                                 information from the previous\n*                                 AWS header.\n         ST    R9,SAVER9AF        Save BAL register\n         NI    NOWRTFLG,FF-X'01'  Turn off flag initially\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nAFTTST40 DS    0H                 X'40' means END-OF-FILE\n*                                 So we finish off the file-level stuff\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*   TEST TEST TEST:  CHECK IF THERE CAN BE A VALID X'4x'  -------\n         CLI   PRVHFLGS,X'40'     Is there an end-of-file condition?\n         BNE   AFTTSTA0           No. Do next test.\n         BAL   R9,WRITTPMK        Yes. Write a tape mark.\n         AP    FILCOUNT,=P'1'     Count number of files written.\n         BAL   R9,REPTFILE        Report on this file in SYSFILES.\n         ZAP   BLOCKCNT,=P'0'     Zero block count for next file\n         ZAP   FILEBYTS,=P'0'     Zero bytes moved for next file\n         NI    FILBLFLG,FF-X'01'  Turn off Label File indicator\n         XC    DBINF,DBINF        Zero byte count at file level\n         XC    DAINF,DAINF        Zero data bytes at file level\n         XC    LBINF,LBINF        Zero label bytes at file level\n** - SYSMOVED ->>    Record the number of files written  -  BELOW\n         TM    FLAGSYST,X'02'     Is SYSMOVED here and open?\n         BNO   AFTT40WM           No. Don't attempt a print.\n         MVC   OUTLINE,OUTLINE-1         Clear line.\n         MVC   OUTLINE,MESSAG12          Mark END-OF-FILE in SYSMOVED\n         MVC   OUTLINE+38(9),FILEPAT     Move in edit pattern\n         ED    OUTLINE+38(9),FILCOUNT+3  Tell which file number ended\n         PUT   SYSMOVED,OUTLINE\nAFTT40WM DS    0H\n** - SYSMOVED ->>    Record the number of files written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-40: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND           No more processing after this.\n*\nAFTTSTA0 DS    0H                 X'A0' means beg and end of block\n         CLI   PRVHFLGS,X'A0'     Is chunk equal block?\n         BNE   AFTTST80           No. Test for first chunk in block.\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR\n** ---------- >>\n         XC    BLOKBYTS,BLOKBYTS  Zero bytes moved after write\n         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too\n*        MVC   LINE+1(8),=C'AFT-A0: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTTST80 DS    0H                 X'80' means beginning of block\n         CLI   PRVHFLGS,X'80'     Beginning chunk of bigger block?\n         BNE   AFTTST00           No. Do next test.\n         OI    NOWRTFLG,X'01'     Must move buffer start location up\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT80WM                 No, can't write data to it.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT80WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-80: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTTST00 DS    0H                 X'00' means middle chunk of block\n         CLI   PRVHFLGS,X'00'     Is this a middle chunk?\n         BNE   AFTTST20           No. Try next test.\n         OI    NOWRTFLG,X'01'     Must move buffer start location up\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT00WM                 No, can't write data to it.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT00WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n*        MVC   LINE+1(8),=C'AFT-00: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND           Get out - not X'80' or X'20'\nAFTTST20 DS    0H                 X'20' means last chunk of block\n         CLI   PRVHFLGS,X'20'     Is end-of-block on?\n         BNE   AFTRMERR           No. Must be error. Tested all types.\n         L     R1,BLOKBYTS        Increment\n         A     R1,UNFBYMVD          total byte count\n         ST    R1,BLOKBYTS            in this block, from chunk bytes.\n         L     R1,FILEBYTS        Increment\n         A     R1,UNFBYMVD          total file bytes\n         ST    R1,FILEBYTS            in this block, from chunk bytes.\n         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR\n*                                 Byte stats accumulated by WRITBUFF\n** ---------- >>    Record the number of bytes written  -  BELOW\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   AFTT20WM                 No, can't write data to it.\n         TM    BWRITFLG,X'01'           Already written MESSAGE3?\n         BO    AFTT20NW                 Yes. Don't repeat info here.\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAG11         Only if chunk less than block\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW\n         PUT   SYSMOVED,OUTLINE\nAFTT20NW DS    0H\n         NI    BWRITFLG,FF-X'01'        Write MESSAG11 from here on.\nAFTT20WM DS    0H\n** ---------- >>    Record the number of bytes written  -  ABOVE\n         XC    BLOKBYTS,BLOKBYTS  Zero byte count moved after write.\n         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too\n*        MVC   LINE+1(8),=C'AFT-20: '\n*        BAL   R9,UNFIMAGE\n         B     AFTRMEND\nAFTRMERR DS    0H                 Code any error handling here.\nAFTRMEND DS    0H\n         L     R9,SAVER9AF        Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITBUFF DS    0H\n         ST    R9,SAVER9WR        BAL register save for WRITBUFF\n         TM    READFLAG,X'01'     READ ONLY run?\n         BO    WRITREAD           Yes. Don't do the EXCP.\n         LA    R1,TAPOUT          R1=address of current DCB\n         ST    R1,OUTDCBPT        Put it in IOB\n         MVC   OUTCCW+1(3),UNFBSTRT+1   PRIME OUTPUT CCW\n         MVC   OUTCCW+6(2),BLOKBYTS+2    Move length of block\n         MVI   OUTECB,X'00'       Initialize ECB\n         EXCP  OUTIOB             Write out the buffer\n         WAIT  ECB=OUTECB         Wait for write to complete\n         CLI   OUTECB,X'7F'       Write completed normally?\n         BNE   WRITBERR           No - error\nWRITREAD DS    0H\n         AP    BLOCKCNT,=P'1'     Block count for this file\n         AP    BLOCKTOT,=P'1'     Block count for entire tape\n         MVC   UNFBUFFR,UNFBSTRT  Reset buffer start in UNFAREA\n         B     WRITBUFE           OK\nWRITBERR DS    0H\n* --- >  handle eov on output - below\n         NI    UNEXFLAG,FF-X'01'  Clear bit on unit exception flag\n         TM    OUTCSW+4,X'02'     Unit check?\n         BO    OUTERUC            Yes. Handle it.\n         TM    OUTCSW+4,X'01'     Unit exception on write?\n         BZ    OUTERR1            No. Assume data check.\n         OI    UNEXFLAG,X'01'     Flag that we have unit exception\n         MVC   LINE,LINE-1        Clear output line\n         MVC   LINE(133),OUTUNEX  Set unit exception error message\n         B     OUTERR2\nOUTERUC  MVC   LINE(133),OUTEQC   Set unit check error message\n         B     OUTERR2            Continue\nOUTERR1  DS    0H\n         MVC   LINE(133),OUTDCK   Set data check error message\nOUTERR2  DS    0H\n         ST    R2,SAVER2E         Save Registers\n         ST    R4,SAVER4E\n         ST    R5,SAVER5E\n         L     R2,OUTDCBPT        Load DCB address\n         LH    R4,40(,R2)         R4=TIOT offset\n         L     R5,16              R5=CVT\n         L     R5,0(,R5)          R5=TCB words\n         L     R5,4(,R5)          R5=My TCB\n         L     R5,12(,R5)         R5=TIOT\n         AR    R4,R5              R4=TIOT Entry for this output\n         MVC   LINE+34(6),4(R4)   Move DDNAME to message\n         L     R4,16(,R4)         R4=UCB for this output\n         MVC   LINE+47(4),12(R4)  Move unit address to message\n         MVC   LINE+60(6),36(R4)  Move VOLSER to message\n         L     R2,SAVER2E         Restore Registers\n         L     R4,SAVER4E\n         L     R5,SAVER5E\n         TM    UNEXFLAG,X'01'     Was this a Unit Exception only?\n         BNO   OTHERERR           No. Just go on.\nHANDLEOV DS    0H            If Unit Exception, then ask for new volume\n         PUT   SYSPRINT,LINE      Write message\n         BAL   R9,SUMMREPT        Print summary report before doing EOV\n         TM    READFLAG,X'01'     If Read Only, skip EOV macro.\n         BO    OTHERERR\n         MVC   OURRC,=F'4'        Indicate scratch volumes asked for\n         CLC   MAXRC,OURRC        Is MAXRC higher?\n         BH    SAMERC03           Yes. Keep it.\n         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.\nSAMERC03 DS    0H\n         EOV   TAPOUT\nOTHERERR DS    0H\n* --- >  handle eov on output - above\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS2\n         HEX   OUTLINE+34,4,UNFBYMVD    Print Reg 2\n         HEX   OUTLINE+44,2,HDRLENG     Pring Header Length\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFE                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\nWRITBUFE DS    0H                       Stats for data moved\n** ---------- >>    Record the number of bytes written\n         ST    R2,SAVER2N           Save prev contents of Register 2\n         ST    R3,SAVER3N           Save prev contents of Register 3\n         XR    R2,R2                High order is zero\n         L     R2,BLOKBYTS          Load Current Written Byte Count\n         LA    R3,DBIN              Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBINF             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DAINF             This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,LBINF             Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n** -->   label byte counts and data byte counts  <-- **  above\n         L     R2,SAVER2N           Restore prev contents of Register 2\n         L     R3,SAVER3N           Restore prev contents of Register 3\n** ---------- >>    Record the number of bytes written\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,MESSAGE3\n         HEX   OUTLINE+34,4,UNFBYMVD    PRINT TOTAL BYTES MOVED\n         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER LENGTH\n         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT PREVIOUS LENGTH\n         TM    FLAGSYST,X'02'           SYSMOVED ddname present?\n         BNO   WRITBUFX                 No, can't write data to it.\n         PUT   SYSMOVED,OUTLINE\n         OI    BWRITFLG,X'01'           Show you've been here\nWRITBUFX DS    0H\n         L     R9,SAVER9WR          BAL register restore for WRITBUFF\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nWRITTPMK DS    0H               Routine to write a tape mark\n         ST    R9,SAVER9WR      BAL register save for WRITTPMK\n         TM    READFLAG,X'01'   Is this run READ ONLY ?\n         BO    WRITTPME         Yes. Bypass entire routine.\n         LA    R1,TAPOUT        R1=address of current DCB\n         ST    R1,OUTDCBPT      Put it in IOB\n         MVI   OUTCCW,X'1F'     Tape Mark opcode\n         MVC   OUTCCWST(2),OUTCCW+6   Store previous move value\n         MVC   OUTCCW+6(2),X'0000'    Shove zeros into length field\n*                                     so AWSTAPE emulator doesn't barf\n         MVI   OUTECB,X'00'     Initialize ECB\n         EXCP  OUTIOB           Write the tape mark\n         WAIT  ECB=OUTECB       Wait for write to complete\n         CLI   OUTECB,X'7F'     Write completed normally?\n         BNE   WRITTPER         No. Indicate tape mark write error.\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST   Restore bytes moved field in CCW\n         B     WRITTPME         Don't indicate error condition\nWRITTPER DS    0H               Tape mark write error display\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE,ERRMESS4\n         HEX   OUTLINE+34,4,OUTECB\n         HEX   OUTLINE+44,8,OUTCSW\n         PUT   SYSPRINT,OUTLINE\n         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE\n         MVC   OUTCCW+6(2),OUTCCWST    Restore byte moved field in CCW\nWRITTPME DS    0H\n         L     R9,SAVER9WR      BAL register restore for WRITTPMK\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  Add Byte Count subroutine\n         ST    R9,SAVER9AD         BAL register save for ADDCOUNT\n         ST    R4,SAVER4N          Save and Restore\n         ST    R5,SAVER5N             Work Registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           Else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         L     R4,SAVER4N          Save and Restore\n         L     R5,SAVER5N             Work Registers\nADDCOUNE DS    0H                  End of routine - Return\n         L     R9,SAVER9AD         BAL register restore for ADDCOUNT\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SU               Save BAL register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---- --- --- --->\n         TM    FLAGNEWV,X'01'\n         BZ    NOCHGVSR\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+3(130),MESSAGE7\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\nNOCHGVSR DS    0H\n* >---- --- --- --->\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),UNFINRCD   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INHDRS     NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE1    BEGINNING OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG04\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE2    MIDDLE OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG05\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE3    END OF RECORD HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE4    END OF TAPE HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG07\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),INTYPE5    END OF TAPE HEADERS\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDLE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSFILES,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSFILES,CNTLINE\nNOMIDDLE DS    0H\n*** -------- >>>\nNOSUMM05 DS    0H\n* >---->\n*** -------- >>>\n         TM    UNEXFLAG,X'01'\n         BZ    NOMIDDPR\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '\n         PUT   SYSPRINT,CNTLINE\n         MVC   CNTLINE,CNTLINE-1\n         PUT   SYSPRINT,CNTLINE\nNOMIDDPR DS    0H\n*** -------- >>>\nSUMMREPE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SU         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LC          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         LA    R1,TESTLABL          Point to 80 bytes to be tested.\n         CLC   =C'VOL1',0(R1)       Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   =C'HDR1',0(R1)       Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   =C'HDR2',0(R1)       This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   =C'EOF1',0(R1)       This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   =C'EOF2',0(R1)       This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   =C'EOV1',0(R1)       This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   =C'EOV2',0(R1)       This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   =C'UHL',0(R1)        This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   =C'UTL',0(R1)        This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  Yes. Don't change the volser.\n         CLI   FLAGNEWV,X'01'            Is the flag on, to change vol?\n         BNE   NOCHGVOL                  No. Don't change it.\n         L     R1,SVINAREA               Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAGE7+28(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\nNOCHGVOL DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         L     R1,SVINAREA               Point to INAREA\n         CLC   4(23,R1),ZERO23      WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\n         OI    FLAGHDRL,X'01'\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         OI    FLAGHDRL,X'01'\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOF2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\nCEOV2    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\n         L     R9,SAVER9LC          Restore BAL register\nLABCHEND BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n         ST    R9,SAVER9RP\n*----------->>\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n*--->                   Block counts first  -  above\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    LBLSMSG0                  Yes. Show labels, not data.\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01A      Tell it's labels written.\n         B     ENDSMSG0\nLBLSMSG0 DS    0H\n         MVC   CNTLINE,CNTLINE-1         Clear line.\n         MVC   CNTLINE(38),CTMSG01B      Tell it's data written.\nENDSMSG0 DS    0H\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3  Put file count in message\n*--->\n         TM    FILBLFLG,X'01'            Is this a label file?\n         BO    DISLABLS                  Yes. Do the label treatment.\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Cumulative data bytes written\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),DATDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINFH          Bytes moved counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),LABDISPL\n         L     R4,SAVER4Q\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBINFH          Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINFL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBINH           Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\nREPTFEND DS    0H\n         L     R9,SAVER9RP\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nVALIDHDR DS    0H                     VALIDATE HEADER GOTTEN\n         NI    HDRVFLAG,FF-X'01'      Turn off invalid header flag.\n         CLI   HEADER+4,X'A0'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'80'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'20'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'00'\n         BE    VALIDHEN               Yes. Header is OK.\n         CLI   HEADER+4,X'40'\n         BE    VALIDHEN               Yes. Header is OK.\n         OI    HDRVFLAG,X'01'         Flag found header as invalid.\nVALIDHEN DS    0H\n         BR    R9\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\nOUTCCW   DC    X'01',AL3(0),X'2000',X'FFFF'     OUTPUT AREA OVERLAID\nOUTECB   DC    F'0'\nOUTIOB   DC    X'02000000'\n         DC    A(OUTECB)\nOUTCSW   DC    2F'0'\nOUTCCWPT DC    A(OUTCCW)\nOUTDCBPT DC    A(TAPOUT)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            PADDING\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY AWSIN\nAWSIN    DCB   DDNAME=AWSIN,MACRF=GM,EODAD=FIN,DSORG=PS,LRECL=80\nTAPOUT   DCB   MACRF=(E),DDNAME=TAPOUT,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X 05677\n               EODAD=SYSINEND                                            05678\n         DC    CL8' '\nFF       EQU   X'FF'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL6                     BLOCK HEADER\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRFLAG1 DC    X'00'                    FLAGS BYTE 1...\nHDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD\nHDRF1MOR EQU   X'00'                    ...MIDDLE OF RECORD\nHDRF1EOR EQU   X'20'                    ...END OF RECORD\nHDRF1TMK EQU   X'40'                    ...TAPE MARK\nHDRFLAG2 DC    X'00'                    FLAGS BYTE 2\n* ----------------------------------------------------------------- *\n*\nINHEADER DC    XL6'00'\nUNEXFLAG DC    X'00'                    FLAGS BYTE 1...\n         DC    XL80'00'                 PADDING\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'             Byte count in CCW - saved during WTM\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nBWRITFLG DC    X'00'    MESSAGE3 was already written flag.\n*              X'01'    Don't have to write SYSMOVED message now.\n* ---------- *\nINITFLAG DC    X'00'    First invocation of UNFOLDEM at beg of tape.\n*              X'01'    After the first invocation of UNFOLDEM.\n* ---------- *\nHDRVFLAG DC    X'00'    HEADER IS VALID IF X'00'\n*              X'01'    HEADER IS INVALID--FILE MUST BE CORRUPTED\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nREADFLAG DC    X'00'               This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nISLBLFLG DC    X'00'               80 BYTE BLOCK IS NOT A LABEL\n*              X'01'         80 BYTE BLOCK IS A LABEL\n* ---------- *\nFILBLFLG DC    X'00'               IS THE FILE A LABEL FILE?\n*              X'01'         THIS FILE IS A LABEL FILE\n* ---------- *\nFLAGHDRL DC    X'00'               HEADER LABEL FLAG\n*              X'01'         EOT HEADER IS FOLLOWING A HEADER LABEL\n* ---------- *\nFLAGSYST DC    X'00'           FLAG TO SHOW IF SYSTRACE DD IS THERE\n*              X'01'         //SYSTRACE DD IS THERE\n*              X'02'         //SYSMOVED DD IS THERE\n*              X'04'         //SYSFILES DD IS THERE\n*              X'08'         //SYSIN    DD IS THERE\n* ---------- *\nFLAGNEWV DC    X'00'           FLAG TO SHOW IF A NEW VOLSER PLUGGED IN\n*              X'01'         SVNEWVOL FIELD HAS BEEN SUBSTITUTED.\n* ---------- *\nNOWRTFLG DC    X'00'           FLAG TO SHOW NOT END OF BLOCK\n*              X'01'           ON - HAVE TO CONTINUE IN SAME BUFFER\n* ---------- *\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n* -------------------------------------------- *\nBLOKBYTS DC    F'0'                Count of bytes for block.\nFILEBYTS DC    F'0'                Count of bytes for file.\n* -------------------------------------------- *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHKNWVOL DC    CL6' '              Raw saved volser before syntax check\nDWORD    DC    D'0'\nSAVR2T5  DC    4F'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nINHDRS   DC    PL7'0'\nINTYPE1  DC    PL7'0'\nINTYPE2  DC    PL7'0'\nINTYPE3  DC    PL7'0'\nINTYPE4  DC    PL7'0'\nINTYPE5  DC    PL7'0'\nFILCOUNT DC    PL7'0'\nFERCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLERRCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL43\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Label Bytes'\nDATDISPL DS    0CL43\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data Bytes '\n*\nSAVEEN80 DS    F         Addresses:  80 bytes past record end\nSAVEENDC DS    F                     Record end location\nSAVEBEGC DS    F                     Record beginning location\nBEGDATA  DS    F                     Where this record's data begins\n*\n* below - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\n* ------                      Move count for bytes in the buffer\nBYTEBFWD DS    0F\nBYTEFILL DC    H'0'\nBYTEMOVE DC    H'0'\n* ------\nSVUNFOLD DC    F'0'           Entry point of UNFOLDEM subprogram\nSVINAREA DS    F\nSAVER2E  DS    F\nSAVER4E  DS    F\nSAVER5E  DS    F\nSAVER2N  DS    F              Has to do with byte counting subroutine\nSAVER3N  DS    F              Has to do with byte counting subroutine\nSAVER4B  DS    F              HEX print register save\nSAVER4N  DS    F              Has to do with byte counting subroutine\nSAVER4Q  DS    F              Has to do with byte counting subroutine\nSAVER5N  DS    F              Has to do with byte counting subroutine\n* --- below                   SAVE BAL REGISTER for each subroutine\nSAVER9HV DS    F              Has to do with Header Validation\nSAVER9AD DS    F              Has to do with ADDCOUNT routine\nSAVER9AF DS    F              Has to do with AFTRMOVE routine\nSAVER9WR DS    F              Has to do with WRITBUFF routine\nSAVER9WT DS    F              Has to do with WRITTPMK routine\nSAVER9CH DS    F              Has to do with CHKHEADR routine\nSAVER9LC DS    F              Has to do with LABELCHK routine\nSAVER9RP DS    F              Has to do with REPTFILE routine\nSAVER9SU DS    F              Has to do with SUMMREPT routine\n* --- above                   SAVE BAL REGISTER for each subroutine\n*\n* above - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *\nOURRC    DC    F'0'\nMAXRC    DC    F'0'\nHDRBYTES DS    F\nHDRBSAVE DS    F\nSAVER8C2 DS    F\n         DC    C' '\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    BUFFER OVERFLOW ERROR  '\nERRMESS2 DC    CL133'    TAPE OUTPUT WRITE ERROR'\nERRMESS3 DC    CL133'    OFFSET ERROR           '\nERRMESS4 DC    CL133'    TAPE MARK WRITE ERROR  '\nERRMESS5 DC    CL133' >> AWS HEADER IS INVALID - CORRUPTION AT THIS POI-\n               NT >> '\nERRMESS6 DC    CL133' >> AWS HEADER IS INVALID - PREV BYTES - CURR BYTE-\n               S  >> '\n*\n*  -----------------            Tape Output Error Message Texts\nOUTEQC   DC    C' ********** EQUIPMENT CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\nOUTUNEX  DC    C' *********** TAPE HAS ENDED ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- PRIVATE SCRATCH REQUESTED '\n         DC    37C'*'\nOUTDCK   DC    C' **********      DATA CHECK ON DD XXXXXX, UNIT '\n         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '\n         DC    40C'*'\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2TAPE - AWS TAPE FILE TO ACTUAL TAPE CONVERSIO-\n               N PROGRAM  '\nMESSAGE4 DC    CL133'1VTT2TAPE  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE5 DC    CL133'1VTT2TAPE - AWS TAPE DATA MOVE - TRACE AND ERROR R-\n               EPORT  '\nMESSAGE6 DC    CL133'1VTT2TAPE - AWS TAPE FILE REPORT - MOVE AND WRITE -\n               STATS  '\nMESSAGE8 DS    0CL133\n         DC    CL8' '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'UNFSCARD'\n         DC    CL10'UNFECARD'\n         DC    CL10'UNFOFFST'\n         DC    CL10'UNFBYTES'\n         DC    CL10'UNFBYMVD'\n         DC    CL10'UNFBUFFR'\n         DC    CL10'UNFBSTRT'\n         DC    CL14'UNFINRCD'\n         DC    CL21' '\nMESSAGE9 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS GOTTEN BY THE PROGRAM, IN READING THROUGH A TAPE.'\nMESSAG10 DC    CL133'        THE UNFAREA (UNFOLD AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST GOTTEN.-\n               '\n*  -----------------            Diagnostic Info Message Texts\nMESSAGE2 DC    CL133'  OFFSET SIZE AND LOCATION '\nMESSAGE3 DC    CL133'  NUMBER OF BYTES WRITTEN  '\nMESSAGE7 DC    CL133'  VOLSER OVERRIDDEN TO:    '\nMESSAG11 DC    CL133'  NUMBER OF CHUNK BYTES    '\nMESSAG12 DC    CL133'  -- End of File Marker - File Number'\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS IN:  '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS IN:  '\nPRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS   :  '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS   :  '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS   :  '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS :  '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK :  '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01A DC    CL38'     DATA   WRITTEN FOR FILE:         '\nCTMSG01B DC    CL38'     LABELS WRITTEN FOR FILE:         '\nCTMSG02  DC    CL38'     BYTES  WRITTEN FOR FILE:         '\nCTMSG03  DC    CL38'     TOTAL BYTES   MOVED  FOR TAPE  : '\nCTMSG04  DC    CL38'     TOTAL BYTES  WRITTEN FOR TAPE  : '\nCTMSG05  DC    CL38'     TOTAL BYTES  WRITTEN FOR LABELS: '\nCTMSG06  DC    CL38'     TOTAL BYTES  WRITTEN FOR DATA  : '\nCTMSG07  DC    CL38'     BLOCKS WRITTEN FOR FILE:         '\nCTMSG08  DC    CL38'     TOTAL BLOCKS WRITTEN FOR TAPE  : '\n*\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nPRTLINE  DC    CL133' '\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\n* --- >\nSAVEHDR  DS    0CL6\nSAVCURLN DS    XL2\nSAVPRVLN DS    XL2\nSAVHFLGS DS    X\nSAVHREST DS    X\n* --- >\nPREVHDR  DS    0CL6\nPRVCURLN DS    XL2\nPRVPRVLN DS    XL2\nPRVHFLGS DS    X\nPRVHREST DS    X\n* --- >\nEOTMARK  DC    XL6'000000004000'\nDBINF    DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE\nDBINFH   DC    F'0'\nDBINFL   DC    F'0'\nDBIN     DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL\nDBINH    DC    F'0'\nDBINL    DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nLBINF    DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINFH   DC    F'0'\nLBINFL   DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\nDAINF    DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINFH   DC    F'0'\nDAINFL   DC    F'0'\n         DC    CL8' '\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 Extra fullword for safety\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n*      Uppercase alpha and only allow printable characters.\nTRTBLPRT DS    0D\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'404040404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040407A7B7C7D7E7F'\n         DC    XL16'40C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'40D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'4040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'40404040404040404040404040404040'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\n*\nTESTLABL DC    CL80' '\nGETSYSIN DC    CL80' '\nINCARDP  DC    XL80'00'           Previous card-image read\nINCARD   DC    XL80'00'           Current  card-image read\nINCAEND  EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         IEZIOB DSECT=YES\n         END\n   TITLE 'UNFOLDEM -- UNFOLD FB-80 DATA INTO A LONG BUFFER'\nUNFOLDEM CSECT\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    UNFOLDEM                                          *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating a       *\n*      real tape from an AWS-format tape file, which has been       *\n*      folded over into an FB-80 dataset.  The AWS header           *\n*      contains the number of bytes in the next chunk (complete     *\n*      or partial block) of tape data.  Once this quantity is       *\n*      known, and the beginning position of the data has been       *\n*      established (it starts just after the header ends), then     *\n*      the data itself has to be moved into a buffer, in            *\n*      preparation for that data block being written out to a       *\n*      tape.  This program unfolds the correct amount of data,      *\n*      beginning at a known position in the FB-80 file, into        *\n*      the buffer.  The position in the FB-80 file which marks      *\n*      the beginning of the data to be moved, is called the         *\n*      OFFSET into the 80-byte card, and it starts with position    *\n*      +0.                                                          *\n*                                                                   *\n*  INPUTS and OUTPUTS:   Described below.                           *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called AWSIN, which contains its input         *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do GETs from AWSIN, and if necessary, it needs      *\n*      to write messages to SYSPRINT.  The caller has to provide    *\n*      ENTRY AWSIN and ENTRY SYSPRINT statements in front of        *\n*      the AWSIN and SYSPRINT DCBs, respectively.                   *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      UNFAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      UNFAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the UNFAREA.                                        *\n*                                                                   *\n*      The caller does one GET of the FB-80 file, to read an        *\n*      AWS header (that has tape data following it).  Once the      *\n*      AWS header has been read, there should be enough data to     *\n*      supply to the UNFAREA control block, and then this           *\n*      program is called, to complete the move of that tape data    *\n*      to a buffer, and position the FB-80 input just past the      *\n*      data moved, so it should point to the next AWS header.       *\n*                                                                   *\n*      This program does more GETs from the FB-80 input file,       *\n*      until the request for the number of bytes to be moved,       *\n*      is satisfied.                                                *\n*                                                                   *\n*      The following is the layout of the UNFAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      UNFAREA  DS    0F          UNFOLD AREA CONTROL BLOCK         *\n*      *                          ------ ---- ------- -----         *\n*  --> UNFSCARD DC    F'0'        Start address of 80-byte card     *\n*  --> UNFECARD DC    F'0'        End address of 80-byte card       *\n*  --> UNFOFFST DC    F'0'        OFFSET of data to be moved        *\n*  --> UNFBYTES DC    F'0'        Number of bytes to be unfolded    *\n*      UNFBYMVD DC    F'0'        Number of bytes that were moved   *\n*  --> UNFBUFFR DC    F'0'        Current start address in buffer   *\n*  --> UNFBSTRT DC    F'0'        Original start address of buffer  *\n*      UNFINRCD DC    PL7'0'      Number of GETs for AWSIN records  *\n*      UNFLENTH EQU   *-UNFAREA                                     *\n*      *                                                            *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      UNFBUFFR and UNFOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the output data     *\n*      and input data positions, respectively, that are just        *\n*      after the moved data, so as to wait for the next call,       *\n*      to be able to move more data.  UNFBSTRT preserves the        *\n*      very beginning address of the output buffer, whereas         *\n*      UNFBUFFR is a place somewhere within the buffer, which       *\n*      is the start of where the new data is expected to be         *\n*      moved.                                                       *\n*                                                                   *\n*      Since both the caller and this program do GET operations     *\n*      from the input FB-80 file, the count of the number of GETs   *\n*      done, UNFINRCD, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nUNFOLDEM AMODE 24\nUNFOLDEM RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'UNFOLDEM '\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING UNFOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,AWSINV             AWSIN    DCB address in caller\n         ST    R0,AWSINDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to unfold FB-80 data starting at an OFFSET from the     *\n*   beginning of a card, for a certain number of bytes, to a data   *\n*   buffer area whose beginning address is supplied.  More 80-byte  *\n*   records can be read with the GET macro from the FB-80 file, to  *\n*   fulfill the move request.                                       *\n*                                                                   *\n*   Input:   UNFAREA fields are all supplied by the calling         *\n*            program, except for UNFBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            UNFAREA is pointed to by Register 1.                   *\n*                                                                   *\n*            The initial card image which is supplied by the        *\n*            calling program, already is primed with data to be     *\n*            moved (one card's worth of it).  This card contains    *\n*            the starting point for the data to be moved, at an     *\n*            OFFSET (displacement) from the beginning of the card.  *\n*                                                                   *\n*            The input data also contains the address of an         *\n*            output buffer area, which is the target for the        *\n*            (segmented) data moves.  Data will be strung out       *\n*            into this area, one card (or a partial card) at a      *\n*            time.  The current card which is in the input file,    *\n*            which contains the beginning of the data to be         *\n*            moved, has already been loaded into a card image       *\n*            work area pointed to by the calling program.  The      *\n*            OFFSET into this card is where the data to be moved    *\n*            will start.                                            *\n*                                                                   *\n*            It is the responsibility of the calling program to     *\n*            ensure that this routine has access to all of the      *\n*            buffer storage where the data is supposed to be        *\n*            moved to.                                              *\n*                                                                   *\n*   Output:  Data is moved, for the required number of bytes, to    *\n*            the output buffer area.  When more that one card       *\n*            image's worth of data has to be moved, more cards      *\n*            are obtained with the GET macro, from the input file.  *\n*                                                                   *\n*            Ending OFFSET in the FB-80 input file, pointing to     *\n*            just after the data which was moved, in the final      *\n*            card image gotten, is returned to the UNFOFFST field   *\n*            and reported to the caller, in anticipation of the     *\n*            next call to this routine.                             *\n*                                                                   *\n*            Ending address of data in buffer - one byte after      *\n*            the end of the moved data - is returned in the         *\n*            UNFBUFFR field.  The UNFBSTRT field preserves the      *\n*            address of the beginning of the data buffer.           *\n*                                                                   *\n*            A count of bytes actually moved from the FB-80 file    *\n*            to the output buffer area is reported in the UNFBYMVD  *\n*            field.  This must match the byte count of bytes which  *\n*            needed to be moved initially.  That count had been     *\n*            initially supplied by the calling program in the       *\n*            UNFBYTES field.                                        *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nUNFOLD   DS    0H\n         ST    R1,PARMPTR\n         L     R2,=A(UNFBLOCK)\n         USING UNFBLOCK,R2\n         MVC   UNFAREA(UNFLENTH),0(R1)      Move input block to pgm\n         LA    R2,UNFAREA                   And address it.\n         MVC   SAVEBEGC,UNFSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,UNFECARD    Save \"end of card\" address\n         L     R1,UNFSCARD          Address of card\n         MVC   WORKPREV(80),ZEROCARD   Zero prev work area\n         MVC   WORKCURR(80),0(R1)   Move card image to curr work area\n         MVC   UNFBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,UNFSCARD          Point to beginning of card\n         A     R7,UNFOFFST          Add OFFSET to start of input\n         ST    R7,SAVEBEGI          Save where input starts\n         L     R8,SAVEBEGI          Copy beg of input address\n         A     R8,UNFBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n* - - - - - - - - - - - - - - >>    This may be way past the address\n*             of the end of the FB-80 card.  We will decrease this\n*             address as we move bytes from successive cards to the\n*             data buffer, by 80 bytes at a time, as we GET new cards,\n*             until R8 actually falls within the end-of-card address.\n*             We will then use this address to calculate the new\n*             OFFSET for the next piece of data in the FB-80 file.\n*             The new OFFSET is returned to the caller by modifying\n*             the UNFOFFST field in the control block.\n*\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nLOOPSET  DS    0H                   Start moving data\n         L     R3,UNFBUFFR          Point to beginning of buffer\n         ST    R3,SAVEBEGD          Save location in the program.\n         LR    R4,R3                Point R4 to end of data by adding\n         A     R4,UNFBYTES          the number of bytes to the start.\n         ST    R4,SAVEENDD          Save potential end of data location\n         ST    R8,SAVER8TR          Save R8 for trace.\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is within the current card.           *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.                       *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         C     R8,SAVEENDC          Is R8 still past end-of-card?\n         BH    LOOPMORE             Yes. Copy till end and GET.\nLOOPSHRT DS    0H                   The move is short, not past end.\n         LR    R6,R8                No. Get byte count to move NOW.\n         SR    R6,R7                Bytes to move\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data to the buffer.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,UNFBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET - save R8\n         S     R6,UNFSCARD          Subtract beginning of card address\n         ST    R6,UNFOFFST          Store the result as new OFFSET\n*        MVC   LINE+1(8),=C'LSHRT2: '\n*        BAL   R9,UNFIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,UNFBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,UNFBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '\n*        BAL   R9,UNFIMAGE\n         CR    R3,R4                Test if past end\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,UNFBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card gotten\n         MVC   WORKPREV,WORKCURR    Save card image to previous\n         ST    R10,SAVER10          Save register for safety\n         L     R10,AWSINDCB         Point to AWSIN DCB in caller\n         GET   (10),WORKCURR        Get a new card image\n         L     R10,SAVER10          Restore R10\n         AP    UNFINRCD,=P'1'       Increment count of AWSIN rcrds read\n         L     R7,SAVEBEGC          Point to beginning addr of workarea\n         MVC   0(80,R7),WORKCURR    Overlay caller's card image\n*        MVC   LINE+1(8),=C'LMORE2: '\n*        BAL   R9,UNFIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R3),0(R7)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 '\n         BAL   R9,UNFIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE OPERATING SYSTEM\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of UNFAREA in caller\n         MVC   0(UNFLENTH,R10),UNFAREA    Copy changed UNFAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(UNFBLOCK)  Return address of UNFAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nUNFIMAGE DS    0H          Diagnostic Data - State of UNFAREA currently\n*\n         HEX   LINE+10,4,UNFSCARD\n         HEX   LINE+20,4,UNFECARD\n         HEX   LINE+30,4,UNFOFFST\n         HEX   LINE+40,4,UNFBYTES\n         HEX   LINE+50,4,UNFBYMVD\n         HEX   LINE+60,4,UNFBUFFR\n         HEX   LINE+70,4,UNFBSTRT\n         HEX   LINE+80,4,SAVER8TR\n         HEX   LINE+90,7,UNFINRCD\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nUNFBLOCK CSECT\nUNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK\n*                                   ------ ---- ------- -----\nUNFSCARD DC    F'0'                 Start address of 80-byte card\nUNFECARD DC    F'0'                 End address of 80-byte card\nUNFOFFST DC    F'0'                 OFFSET of data to be moved\nUNFBYTES DC    F'0'                 Number of bytes to be unfolded\nUNFBYMVD DC    F'0'                 Number of bytes that were moved\nUNFBUFFR DC    F'0'                 Current start address in buffer\nUNFBSTRT DC    F'0'                 Original start address of buffer\nUNFINRCD DC    PL7'0'               Number of GETs for AWSIN records\nUNFLENTH EQU   *-UNFAREA\n*\nUNFOLDEM CSECT\nWORKPREV DS    CL80                 Contiguous previous card image\nWORKCURR DS    CL80                 Card image work area\n         DC    C' '\nLINE     DC    CL133' '\n         DC    C' '\nLINE2    DC    CL133' '\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'00'\nSAVEBEGD DC    F'0'                 Save beg of buffer data address\nSAVEENDD DC    F'0'                 Save end of buffer data address\nSAVEBEGI DC    F'0'                 Save beg address of card input\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVER8TR DC    F'0'                 Save floating Reg 8 which decreases\nSAVEPARM DC    F'0'                 Save CALLER'S UNFAREA ADDRESS\nPARMPTR  DC    F'0'\nSYSPRINV DC    V(SYSPRINT)\nAWSINV   DC    V(AWSIN)\nSYSPRDCB DC    F'0'\nAWSINDCB DC    F'0'\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2TEST": {"ttr": 7683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00(\\x01\\x01(\\x9f\\x01\\x046_\\x16#\\x00\"\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2004-12-30T16:23:28", "lines": 34, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*----------------------------------------------------------*//\n//*  MVS CYCLE TEST FOR VTT2TAPE AND VTT2DISK PROGRAMS       *//\n//*----------------------------------------------------------*//\n//*   DISK FILES SBGOLOB.T439MT AND SBGOLOB.T439MU SHOULD    *//\n//*   COMPARE TO BE IDENTICAL FILES.                         *//\n//*----------------------------------------------------------*//\n//*   USE YOUR OWN TAPE DATA TO RUN THIS TEST IN EITHER      *//\n//*   ORDER - VTT2TAPE FIRST, OR VTT2DISK FIRST.             *//\n//*----------------------------------------------------------*//\n//AWSREAD  EXEC PGM=VTT2TAPE                  /* CUT A REAL TAPE/\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//AWSIN     DD  DISP=SHR,DSN=SBGOLOB.T439MT   /* FB-80 AWS TAPE */\n//TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=T439RT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//*\n//AWSWRIT  EXEC PGM=VTT2DISK                  /* MAKE AN AWS TAPE */\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//TAPIN     DD  DISP=OLD,UNIT=582,VOL=SER=T439RT,\n//          LABEL=(1,BLP,EXPDT=98000)\n//AWSOUT    DD  DSN=SBGOLOB.T439MU,DISP=(NEW,CATLG,DELETE),\n//          UNIT=SYSALLDA,DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//          SPACE=(CYL,(301,10),RLSE),VOL=SER=DATA04\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2T2F$": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00!\\x01\\x010\\x1f\\x01\\x05\\x00/\\t&\\x00 \\x00\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2001-10-28T00:00:00", "modifydate": "2005-01-02T09:26:21", "lines": 32, "newlines": 29, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,\n// PARM=(OBJECT,NODECK,BATCH,NOESD,NORLD,NOXREF,SIZE(MAX-1M,ABOVE))\n//SYSLIB   DD DISP=SHR,DSN=SBGOLOB.R15.MACLIB\n//         DD DISP=SHR,DSN=SBGOLOB.R15.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTT2T2FK)\n//*        DD DISP=SHR,DSN=SBGOLOB.B.ASM(FOLDEM)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(CYL,5),DISP=(,PASS),\n//            DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n ENTRY VTT2T2FK\n SETSSI  CB468533\n SETCODE AC(0)\n NAME VTT2T2FK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTT2T2F#": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x002\\x01\\x01(\\x9f\\x01\\x05\\x06\\x1f Q\\x00\\x17\\x00\\x07\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2005-03-02T20:51:32", "lines": 23, "newlines": 7, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*  Read in a real tape on a real tape drive on any MVS system,\n//*  and produce, on any MVS system, a FLEX-ES Faketape-compatible\n//*  \"virtual tape image\", folded over on MVS into FB, LRECL=80\n//*  format.  The virtual tape image can be exported (via FTP or\n//*  anything else which does that) to a PC disk, and read on a\n//*  FLEX-ES system as a tape.\n//*\n//AWSWRIT  EXEC PGM=VTT2T2FK\n//STEPLIB   DD  DISP=SHR,DSN=SBGOLOB.LOAD\n//FAKEOUT   DD  DISP=SHR,DSN=SBGOLOB.V467FL\n//TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=V467MU,\n//          LABEL=(1,BLP,EXPDT=98000)\n//SYSPRINT  DD  SYSOUT=*\n//SYSFILES  DD  SYSOUT=*\n//SYSTRACE  DD  SYSOUT=*\n//SYSMOVED  DD  SYSOUT=*\n//SYSUDUMP  DD  SYSOUT=*\n//SYSIN     DD  *\nIDRCOFF\nNEWVOL=C467MU\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTT2T2FK": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00X\\x01\\x00%O\\x01\\x05\\x00/\"\\x06\\t\\x82\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2000-09-10T00:00:00", "modifydate": "2005-01-02T22:06:58", "lines": 2434, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "   TITLE 'VTT2T2FK -- READ A REAL TAPE AND CREATE FAKETAPE FILE'\n**************************************************************\n**************************************************************\n**                                                          **\n**                                                          **\n**  MODULE:  VTT2T2FK.   Written by Sam Golob               **\n**                                                          **\n**       Copyright (c) 2001-2005 by Sam Golob               **\n**                                                          **\n**       A component of the:                                **\n**       Virtual Tape Transportation System (VTTS)          **\n**                                                          **\n**  PURPOSE:  Program to read in a tape, and create an      **\n**            MVS disk file in \"folded FB-80 FAKETAPE       **\n**            format\".                                      **\n**                                                          **\n**     The output of this program is intended to be input   **\n**     for the VTT2FK2T program.  These two programs,       **\n**     VTT2T2FK and VTT2FK2T, are designed to work          **\n**     together, as paired and opposite programs.           **\n**                                                          **\n**  OBSERVATION:  Although this program is purely an MVS    **\n**                program, the FAKETAPE output of this      **\n**     program can be downloaded to other systems where     **\n**     the file can actually be interpreted as an emulated  **\n**     tape.  This is one way of transferring tape data to  **\n**     other MVS systems that can read FAKETAPE tape        **\n**     files directly, as though they were tapes.           **\n**                                                          **\n**     For example, you can take mainframe-based tapes      **\n**     on real cartridges and create FAKETAPE-compatible    **\n**     files that can be read on a FLEX-ES system.          **\n**                                                          **\n**     FAKETAPE files do not currently support chunked      **\n**     blocks, but I have preserved the structure of the    **\n**     VTT2DISK program here, so that if chunked blocks     **\n**     will be supported later by FAKETAPE, then it will    **\n**     be relatively easy to put in support for them.  We   **\n**     pretend, in the logic of this program, that there    **\n**     is a maximum chunk size of 65535, so that all 64K    **\n**     blocks will come out with \"chunksize equals          **\n**     blocksize\" treatment.                                **\n**                                                          **\n**  METHOD:                                                 **\n**                                                          **\n**     Tape data is read into a data buffer in this         **\n**     program.  Each block is read in, and its size        **\n**     is determined.  This size is compared to the 65535   **\n**     byte chunk size, and a decision is made as to what   **\n**     to do.  A FAKETAPE header is made for each chunk.    **\n**     Each FAKETAPE header is folded into FB-80 output,    **\n**     and then the data is folded in afterward, until      **\n**     the block, and its associated FAKETAPE header, is    **\n**     folded in.  Then another tape block is read into     **\n**     the buffer, and the process repeats.                 **\n**                                                          **\n**     When the tape file ends, and a tape mark is read     **\n**     in, a FAKETAPE header with \"zero next bytes\" is      **\n**     constructed.  This indicates a tape mark written.    **\n**     That header is then folded into the FB-80 output     **\n**     dataset after the last data.  The first header for   **\n**     the next file, if any, immediately follows.          **\n**                                                          **\n**     At the end of the tape, an end-of-tape FAKETAPE      **\n**     header is appended to the end of the output          **\n**     file and folded in.  The last FB-80 record           **\n**     is completed with X'30's, if necessary.  This may,   **\n**     depending on how many of them there are, signify     **\n**     more tape marks at the end of the FAKETAPE file.     **\n**     Since the last 80-byte record has to be completed    **\n**     with some kind of data, it seemed that X'30's,       **\n**     which are what FLEX-ES itself produces at the end    **\n**     of FAKETAPE files, are the safest things to put      **\n**     there.                                               **\n**                                                          **\n**     This program was adapted from version 1.12 of the    **\n**     VTT2DISK program, which is part of the Virtual       **\n**     Tape Transportation System (VTTS), copyright (c)     **\n**     2001-2005 by Sam Golob.                              **\n**                                                          **\n**     All of the \"FB-80 folding\" work is now done by the   **\n**     sub-program called FOLDEM.  The FOLDEM program       **\n**     operation is completely controlled by a control      **\n**     block called the FLDAREA control block, which does   **\n**     all of the communication between the main program    **\n**     and the FOLDEM sub-program.  Therefore, monitoring   **\n**     of the folding process is now possible purely by     **\n**     displaying the current status of the FLDAREA         **\n**     fields.  A convenient routine for displaying the     **\n**     status of the FLDAREA fields is the FLDIMAGE         **\n**     routine in either program, which is invoked by:      **\n**                                                          **\n**     BAL   R9,FLDIMAGE                                    **\n**                                                          **\n**     Therefore the fold monitoring displays that used     **\n**     to be in the SYSMOVED DD name, are now obsolete.     **\n**                                                          **\n**     There are two more fields in the FLDAREA control     **\n**     block than in the UNFAREA control block of the       **\n**     UNFOLDEM sub-program that VTT2FK2T uses.  These      **\n**     are:                                                 **\n**                                                          **\n**           FLDBYTOT - bytes left in buffer after the      **\n**                      last chunk of data was folded       **\n**           FLDREADF - propagation of the \"read only\"      **\n**                      flag into the sub-program           **\n**                                                          **\n**     These extra fields are obviously not required by     **\n**     the unfolding process.  The first one is not         **\n**     required because you're doing \"unchunking\" instead   **\n**     of \"chunking\", and you read the existing chunks      **\n**     as they come in; you're not required to create       **\n**     them.  The second one is not required because the    **\n**     main program writes the output (a tape) instead of   **\n**     the sub-program writing the output (an FB-80 file).  **\n**     So in our case, in a READ only situation, the        **\n**     sub-program must know when to NOT produce FAKEOUT    **\n**     output.                                              **\n**                                                          **\n**  OPTIONAL DDNAMES:                                       **\n**                                                          **\n**     In order to make sure that the VTT2T2FK program      **\n**     is doing its job properly, it produces a lot of      **\n**     trace data and status data, as it is creating        **\n**     the folded FB-80 FAKETAPE format tape.  In order     **\n**     not to clutter the summary report, most of this      **\n**     data is written to \"Optional DDNAMEs\".  Starting     **\n**     with version 1.12 of this program, most of the       **\n**     trace data now consists of the state of the FLDAREA  **\n**     control block fields at various stages of program    **\n**     execution.                                           **\n**                                                          **\n**     If you have access to the source code (you are       **\n**     reading it), you can introduce an instruction:       **\n**                                                          **\n**           BAL   R9,FLDIMAGE                              **\n**                                                          **\n**     at any point in the program, as long as SYSPRINT     **\n**     is open.  This should produce any diagnostics you    **\n**     may need, because all FLDAREA fields are displayed.  **\n**                                                          **\n**     Optional DDNAMEs don't have to be coded in the       **\n**     JCL.  But if they are coded, they will contain       **\n**     the extra trace data which VTT2T2FK produces,        **\n**     and the SYSFILES ddname will contain a detailed      **\n**     \"file by file\" report.                               **\n**                                                          **\n**     The SYSFILES report is very useful if you want       **\n**     to do a \"dry run\", with the READ parameter.  If      **\n**     you want to know the structure of a tape without     **\n**     creating the FB-80 output file, the SYSFILES         **\n**     report will tell you what files are on the tape.     **\n**     It will also give you an indication of how big an    **\n**     FB-80 output file you will need on an MVS disk,      **\n**     to contain all the tape data.  See below for         **\n**     details.                                             **\n**                                                          **\n**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **\n**     and SYSIN.  SYSMOVED is now obsolete, although       **\n**     it will produce a dummy report if it is present      **\n**     in the JCL.                                          **\n**                                                          **\n**     SYSIN data is necessary if optional parameters       **\n**     are to be entered, such as:                          **\n**                                                          **\n**     NEWVOL=volser                                        **\n**     READ                                                 **\n**     IDRCOFF                                              **\n**                                                          **\n**     SYSIN keywords have to start in column 1.            **\n**                                                          **\n**     Either READ or IDRCOFF can also be entered in the    **\n**     PARM field of the EXEC card in the JCL.              **\n**                                                          **\n**     Full JCL to run the VTT2T2FK program is as           **\n**     follows:                                             **\n**                                                          **\n**     //   jobcard                                         **\n**     //TAPEREAD EXEC PGM=VTT2T2FK                         **\n**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **\n**     //FAKEOUT   DD  DSN=fb80.folded.faketape,            **\n**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **\n**     //          VOL=SER=volxxx,                          **\n**     //          SPACE=(CYL,(mm,nn),RLSE)                 **\n**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **\n**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **\n**     //          LABEL=(1,BLP,EXPDT=98000)                **\n**     //SYSPRINT  DD  SYSOUT=*                             **\n**     //SYSFILES  DD  SYSOUT=*                             **\n**     //SYSTRACE  DD  SYSOUT=*                             **\n**     //SYSUDUMP  DD  SYSOUT=*                             **\n**     //SYSIN     DD  *                                    **\n**     keywords in column 1                                 **\n**     /*                                                   **\n**                                                          **\n**     where you can leave out SYSTRACE and SYSUDUMP        **\n**     if you want to.  I'd strongly suggest including      **\n**     (at least) SYSFILES, though.                         **\n**                                                          **\n**     SYSTRACE takes a picture of the tape buffer at       **\n**     READ time, and takes a picture of the AWS headers    **\n**     and the FLDAREA control block fields at the time     **\n**     the headers are made.  Since the folding is now      **\n**     done by the FOLDEM subprogram, SYSMOVED, which       **\n**     used to track the data folding process, is now       **\n**     not necessary.  Of course SYSUDUMP is there to       **\n**     contain the MVS-produced dump, upon any abnormal     **\n**     termination of the program.                          **\n**                                                          **\n**     SYSFILES gives you block counts and byte counts      **\n**     for all files read and written.                      **\n**                                                          **\n**     In the SYSPRINT report, there is a count of total    **\n**     number of 80-byte records which the program will     **\n**     (or has) put out.  If you are doing a READ only      **\n**     run, and want to allocate an output file which is    **\n**     the right size, you might use this number, together  **\n**     with the BLKnnnn command from File 296 of the CBT    **\n**     Tape, to produce the following result:               **\n**                                                          **\n**     Say, our program produces:                           **\n**                                                          **\n**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **\n**                                                          **\n**     And you want to allocate space on a 3390.  So you    **\n**     would say:                                           **\n**                                                          **\n**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **\n**                                                          **\n**     Which comes up with the result:                      **\n**                                                          **\n** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **\n**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **\n**                                                          **\n**  CHANGE LOG:                                             **\n**                                                          **\n**    Version 1.12 - Re-architected program to use FOLDEM   **\n**       sub-program for data moves.  The FOLDEM program    **\n**       is driven by the FLDAREA control block, so the     **\n**       trace data consists mostly of the state of the     **\n**       FLDAREA control block fields.  A routine called    **\n**       FLDIMAGE will print all the FLDAREA control block  **\n**       fields on a single SYSPRINT line.                  **\n**                                                          **\n**       Added the possibility of coding program options    **\n**       in the SYSIN DD, which is used if it is present    **\n**       in the JCL.  SYSIN keywords, which must be coded   **\n**       to start in column 1, are currently:               **\n**                                                          **\n**       NEWVOL=volser                                      **\n**       READ                                               **\n**       IDRCOFF                                            **\n**                                                          **\n**       This program was adapted from Version 1.12 of      **\n**       the VTT2DISK program, so its initial version       **\n**       is also called Version 1.12.                       **\n**                                                          **\n**       The NEWVOL=volser keyword in SYSIN, allows you     **\n**       to change the volser in the VOL1 label of the      **\n**       output FAKETAPE tape file.                         **\n**                                                          **\n**       Now, the READ and IDRCOFF keywords of the EXEC     **\n**       PARM field, can also be coded in SYSIN.  They      **\n**       must begin in column 1.  READ allows a dry run     **\n**       of the program which reads the input tape and      **\n**       reports statistics, but which does not produce     **\n**       an output FB-80 AWS file.                          **\n**                                                          **\n**       IDRCOFF looks in the tape standard labels, if      **\n**       there are any, and turns off any \"P\" indicators    **\n**       which tell MVS that this tape was produced on      **\n**       an IDRC-enabled tape drive.  Since the output      **\n**       FB-80 file is not compressed anyway, one wants     **\n**       the power to read the FAKETAPE tape file on a      **\n**       logical 3420 or 3480 tape drive, without MVS       **\n**       telling you that \"the tape has compressed files    **\n**       and I can't read it\" on this particular drive.     **\n**                                                          **\n**                                                          **\n**************************************************************\n         EJECT\n**************************************************************\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.  *\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER4B\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER4B\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n**************************************************************\n         GBLC  &LLEV\n         GBLC  &DEFCHKC\n         GBLA  &DEFCHNK\n&LLEV    SETC  '1.12'\n* ------------------------------------------------------------------ *\n*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *\n*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *\n* ------------------------------------------------------------------ *\n*   FAKETAPE does not support chunking of blocks, but if the         *\n*   chunk size is set to the largest possible value for a 64K        *\n*   block size limit, all chunksizes will equal the block sizes.     *\n* ------------------------------------------------------------------ *\n&DEFCHNK SETA  65535\n&DEFCHKC SETC  '&DEFCHNK'\n         YREGS\n         EJECT\n** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **\nVTT2T2FK CSECT\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\nVTT2T2FK AMODE 24\nVTT2T2FK RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'VTT2T2FK - REAL TAPE TO FOLDED FAKETAPE DISK FILE - '\n         DC    C'LEVEL '\nSYSLEV   DC    C'&LLEV'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME ',C'--- '\n         DC    C'Copyright (c) 2001-2005 by Sam Golob '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING VTT2T2FK,R12,R11,R10,R8,R7\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LA    R10,4095(,R11)\n         LA    R10,1(,R10)\n         LA    R8,4095(,R10)\n         LA    R8,1(,R8)\n         LA    R7,4095(,R8)\n         LA    R7,1(,R7)\n         LR    R1,R5                 RESTORE PARM POINTER\n*\n* ----- >                            Parms          <--- below\n         L     R1,0(R1)              Get PARM field\n         CLC   =C'READ',2(R1)        Is it \"READ\" only?\n         BE    COPYREAD              Yes. Turn on indicator.\n         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?\n         BE    COPYIDRF              Yes. Say that.\n         B     COPYTAPE              No. Just go on with processing.\nCOPYREAD DS    0H                    READ only?\n         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     COPYTAPE\nCOPYIDRF DS    0H                    IDRC indicators off?\n         OI    IDRCFLAG,X'01'        Yes. Turn on flag.\n         B     COPYTAPE\n*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.\nCOPYTAPE DS    0H\n* ----- >                            Parms          <--- above\n*\n***********************************************************************\n* GET SYSTEM DATE AND TIME - A standard way to get date and time      *\n***********************************************************************\n         STM   R14,R2,SAVE1402\n         TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY\n         OI    DATE+4,X'0F'\n         UNPK  DATED,DATE\n         OI    TIME+3,X'0F'\n         UNPK  TIMED,TIME\n*                          FILL HEADDATE AREA WITH INFO TO REUSE\n         MVC   HEADDATE(2),DATED\n         MVI   HEADDATE+2,C'/'\n         MVC   HEADDATE+3(2),DATED+2\n         MVI   HEADDATE+5,C'/'\n         MVC   HEADDATE+6(4),DATED+4\n         MVC   HEADDATE+12(2),TIMED\n         MVI   HEADDATE+14,C':'\n         MVC   HEADDATE+15(2),TIMED+2\n         MVI   HEADDATE+17,C':'\n         MVC   HEADDATE+18(2),TIMED+4\n         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time\n         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.\n         MVC   MESSAGE3+88(31),HEADDLIT\n         MVC   MESSAGE4+88(31),HEADDLIT\n         LM    R14,R2,SAVE1402\n***********************************************************************\n         MVC   LEVDATE(8),SYSDAT\n***********************************************************************\n         MVC   MESSAGE1+61(21),LEVELLIT    Program level and\n         MVC   MESSAGE2+61(21),LEVELLIT      assembly date\n         MVC   MESSAGE3+61(21),LEVELLIT\n         MVC   MESSAGE4+61(21),LEVELLIT\n***********************************************************************\n* ----------------------------------------------------------------- *\nINITEM   DS    0H                    Initialize some constants\n         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.\n         MVC   FULLHIGH(2),=X'0000'\n         MVC   CURRBYTE(2),=X'0000'\n         MVC   LASTBYTE(2),=X'0000'\n         MVC   HDRSIZE(4),=F'12'     Set size of header globally.\n         MVC   FLDOFFST(4),=F'0'     Offset is initially zero\n         LA    R1,OUTCARD            Let FOLDEM know about FAKEOUT area\n         ST    R1,FLDSCARD           Beginning of card image output\n         ST    R1,SVBEGCRD\n         LA    R1,80(,R1)            Find end of card\n         ST    R1,FLDECARD           And store it away for the duration\n         ST    R1,SVENDCRD\n         L     R1,=A(INAREA)         Get address of input buffer\n         ST    R1,SVBFAREA           And save it away.\n         ST    R1,FLDBUFFR           Prime these fields\n         ST    R1,FLDBSTRT\n         L     R0,=F'&DEFCHNK'       Set default chunk size.\n         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.\n         ZAP   FLDOUTCT,=P'0'        Zero count of FAKEOUT records.\n* ----------------------------------------------------------------- *\nTIOTSCAN DS    0H             Determine the presence of Optional\n*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES\n* ----->                      and open them if there is JCL for them.\n* ----------------------------------------------------------------- *\n         L     R5,16          R5=CVT\n         L     R5,0(,R5)      R5=TCB WORDS\n         L     R5,4(,R5)      R5=MY TCB\n         L     R5,12(,R5)     R5=TIOT\n         LA    R5,24(,R5)     R5=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?\n         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES\n         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?\n         BNE   TIOTMOVD       NO\n         OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD\n         B     TIOTNEXT       CONTINUE\nTIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?\n         BNE   TIOTFILE\n         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD\n         B     TIOTNEXT\nTIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?\n         BNE   TIOTSYSN\n         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD\n         B     TIOTNEXT\nTIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?\n         BNE   TIOTNEXT\n         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD\n         B     TIOTNEXT\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY\n         AR    R5,R3          R5=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\nTIOTSEND DS    0H\n* ----------------------------------------------------------------- *\n* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *\n* ----------------------------------------------------------------- *\n*\n         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.\n*\n* ----------------------------------------------------------------- *\n***********************************************************************\n*    Now OPEN the files and start the processing.\n***********************************************************************\n* - - - ->  Chunk Size Message - - - ->   below\n*    The purpose of this code is to fill MESSAG14 with information.\n         L     R1,CHNKSIZE                  Load binary Chunk Size\n         XC    DWORD,DWORD                  Clear DWORD to zeros.\n         CVD   R1,DWORD                     Convert to decimal.\n         OI    DWORD+7,X'0F'                Make sign readable.\n         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message\n         ED    MESSAG14+28(8),DWORD+4       Edit the number\n         B     AFCHKDSP                     Branch past constant\nCHPATTRN DC    X'4020202020202120'          8 bytes of pattern\nAFCHKDSP DS    0H\n* - - - ->  Chunk Size Message - - - ->   above\n         TM    READFLAG,X'01'        Read Only run?\n         BO    NOFAKOUT              Yes. Don't OPEN FAKEOUT.\n         OPEN  (FAKEOUT,(OUTPUT))\nNOFAKOUT DS    0H\n         OPEN  (SYSPRINT,(OUTPUT))\n         OPEN  (TAPIN,(INPUT))\n*--->>\n         MVC   MSGLINE1,MSGLINE1-1   Clear optional\n         MVC   MSGLINE2,MSGLINE2-1      message lines\nREADIDRC DS    0H\n         TM    READFLAG,X'01'        READ only run?\n         BZ    IDRCMSG\nREADMSG  DS    0H\n         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'\nIDRCMSG  DS    0H\n         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?\n         BZ    ENDEXMSG\n         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'\nENDEXMSG DS    0H\n*--->>\nTRACERPT DS    0H\n         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?\n         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSTRACE,(OUTPUT))\n         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE      Blank Line\n         PUT   SYSTRACE,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    TRACENOI\n         PUT   SYSTRACE,MSGLINE2     IDRC remove message\nTRACENOI DS    0H\n*        PUT   SYSTRACE,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\nTRACDESC DS    0H\n         PUT   SYSTRACE,MESSAGE8\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE5\n         PUT   SYSTRACE,MESSAGE6\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAG11\n         PUT   SYSTRACE,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSTRACE,OUTLINE\n         PUT   SYSTRACE,MESSAGE7\n*--->>\nMOVEDRPT DS    0H\n         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?\n         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSMOVED,(OUTPUT))\n         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE      Blank Line\n         PUT   SYSMOVED,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    MOVEDNOI\n         PUT   SYSMOVED,MSGLINE2     IDRC remove message\nMOVEDNOI DS    0H\n*        PUT   SYSMOVED,MESSAG14\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAGE9\n         PUT   SYSMOVED,MESSAG10\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n         PUT   SYSMOVED,MESSAG11\n         PUT   SYSMOVED,MESSAG12\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSMOVED,OUTLINE\n*--->>\nFILESRPT DS    0H\n         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?\n         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.\n         OPEN  (SYSFILES,(OUTPUT))\n         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSFILES,OUTLINE      Blank Line\n         PUT   SYSFILES,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    FILESNOI\n         PUT   SYSFILES,MSGLINE2     IDRC remove message\nFILESNOI DS    0H\n*        PUT   SYSFILES,MESSAG14\n*--->>\nNOSYSFIL DS    0H\n* ----------------------------------------------------------------- *\n*   Now do the same for SYSPRINT report, which is always there.\n* ----------------------------------------------------------------- *\n         PUT   SYSPRINT,MESSAGE1\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         PUT   SYSPRINT,OUTLINE      Blank Line\n         PUT   SYSPRINT,MSGLINE1     Read Only message or blank\n         TM    IDRCFLAG,X'01'\n         BZ    PRINTNOI\n         PUT   SYSPRINT,MSGLINE2     IDRC remove message\nPRINTNOI DS    0H\n*        PUT   SYSPRINT,MESSAG14\n*--->>\n*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.\n*        BAL   R9,FLDIMAGE\n*--->>\n* ----------------------------------------------------------------- *\nTAPEREAD DS    0H                      READ a new tape block.\n* ----------------------------------------------------------------- *\n*   You come here every time you do a tape READ.\n* ----------------------------------------------------------------- *\n         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks\n         BAL   R9,READBLOK             Read a block of data\n         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?\n         BO    MAINTPMK                Yes. Take appropriate action.\n* --- >\n         L     R1,CURRBFUL             Fullword number of bytes read\n         C     R1,CHNKSIZE             Bigger than chunk size?\n         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.\n         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.\n         NI    BUFINISH,FF-X'01'       Turn \"buffer finished\" flag off\n         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer\n         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved\n         B     AFTRCHNK                Jump over other alternative\nNOCHUNKS DS    0H\n         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.\n         OI    BUFINISH,X'01'          Buffer is finished in one shot.\n         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total\n         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total\n* --- >                                Label check if HDR - below\nAFTRCHNK DS    0H\n         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?\n         BNE   MAINNOTL                No. Can't be a label.\n         BAL   R9,LABELCHK             Check for labels and their kind.\n         TM    ISLBLFLG,X'01'          Is this record a label?\n         BZ    MAINNOTL                No. Bypass flag setting.\n         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?\n         BZ    MAINNOTH                Neither. Check if EOF or EOV.\n         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.\nMAINNOTH DS    0H\n         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?\n         BZ    MAINNOTL                No. Don't turn off flag.\n         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.\nMAINNOTL DS    0H\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW\n** -->              stuff below is only done per READ.\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,CURRBFUL          Load Current READ Byte Count\n         LA    R3,DBOUTF            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUT             Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n** -->   label byte counts and data byte counts  <-- **  below\n         TM    ISLBLFLG,X'01'       This is a label file?\n         BO    ADLABCNT             If so, go count its bytes\n         LA    R3,DAIN              This is a data file--count bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         B     NOLABCNT             Don't count twice\nADLABCNT DS    0H\n         LA    R3,LBIN              Count the label file's bytes\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOLABCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n** -->              stuff above is only done per READ.\n* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE\n* --- >                                Label check if HDR - above\n**-------------------------------------------------------------------**\nFOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL\n*                                   THE BUFFER IS EXHAUSTED.\n         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields\n         MVC   FLDECARD,SVENDCRD\n         L     R3,=A(INAREA)           Point to the data buffer\n         ST    R3,FLDBUFFR             Initialize\n         ST    R3,FLDBSTRT                 FLDAREA fields\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n*                                      because we'll have to fold the\n*                                      newly manufactured header.\n**-------------------------------------------------------------------**\nFOLDLOOP DS    0H\n         L     R1,FLDBYTOT          Compare bytes remaining to fold\n         C     R1,CHNKSIZE          To the chunk size.\n         BH    FOLDNCHK             If now less than or equal\n         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off\n         OI    BUFINISH,X'01'       And turn \"buffer finished\" flag on\n         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.\nFOLDNCHK DS    0H\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA\n         BAL   R9,MAKEHEDR             Create a header with READ info\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER               Point to address of this header\n         ST    R3,FLDBUFFR             Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF             And fold it into FB-80.\n         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA\n         MVC   FLDBYMVD,=F'0'          Initialize bytes folded\n         BAL   R9,FOLDBUFF             And fold it into the output.\n         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block\n** ---------- >>    Record the number of bytes folded - below\n         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3\n         L     R2,FLDBYMVD          Load Current folded Byte Count\n         LA    R3,DBOUTFM           Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\n         LA    R3,DBOUTM            Point Register to Counter\n         BAL   R9,ADDCOUNT          Increment Doubleword Count\nNOFLDCNT DS    0H\n         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2\n** ---------- >>    Record the number of bytes folded - above\n         TM    CHNKFLAG,X'01'          Are we doing chunks?\n         BZ    TAPEREAD                No. Do another tape read.\n         TM    BUFINISH,X'01'          Have we finished this block?\n         BO    TAPEREAD                Yes. Read another block.\n         B     FOLDLOOP                No. Fold more chunks.\n*\nMAINTPMK DS    0H                   Last read was a T.M.\n         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         BAL   R9,MAKEHEDR          Make a header to show EOF.\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header\n         BAL   R9,REPTFILE          Report Block and Byte Counts\n*--->>\n         MVC   DBOUTF(8),=D'0'      Zero File Byte Count\n         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count\n         ZAP   BLOCKCNT,=P'0'       Zero File Block Count\n*--->>\n         B     TAPEREAD             Read in another tape block.\n*\n* ---------------------------------------------------------------- *\n*          END OF INPUT TAPE DATA                                  *\n* ---------------------------------------------------------------- *\nFIN      DS    0H                   PROGRAM EXIT ROUTINE\n         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk\n         OI    TPMKFLAG,X'01'       Force Tape Mark indication.\n         BAL   R9,MAKEHEDR          Make EOT header\n         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold\n         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold\n         LA    R3,HEADER            Load address of header\n         ST    R3,FLDBUFFR          Store it into FLDAREA fields\n         ST    R3,FLDBSTRT\n         BAL   R9,FOLDBUFF          Fold the header into the output\nBREAKLUP DS    0H\n         MVC   SAVOFFST,FLDOFFST    Offset has to be current\n         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too\n         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk\n         TM    READFLAG,X'01'       READ only?\n         BO    NOPUT01              Yes. No output to FAKEOUT.\n         PUT   FAKEOUT,OUTCARD      And write out the last buffer.\nNOPUT01  DS    0H\n         AP    FLDOUTCT,=P'1'       Count the record PUT out.\nWRITSUMM DS    0H\n         BAL   R9,SUMMREPT          Print the summary report.\n* ---------------------------------------------------------------- *\n*     Close the files that were OPENed\n* ---------------------------------------------------------------- *\nCLOSEMAL DS    0H                   Close em all.....\n         CLOSE TAPIN\n         TM    READFLAG,X'01'       Is this a READ only run?\n         BO    NOFKOCLS             Can't CLOSE what ain't OPEN.\n         CLOSE FAKEOUT\nNOFKOCLS DS    0H\n         CLOSE SYSPRINT\n         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?\n         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSTRACE\nSYSTRNOP DS    0H\n         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?\n         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSMOVED\nSYSFILNO DS    0H\n         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?\n         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.\n         CLOSE SYSFILES\nSYSMVDNO DS    0H\nFIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n         EJECT\n* ----------------------------------------------------------------- *\n* ---       SUBROUTINES                                         --- *\n* ----------------------------------------------------------------- *\n*\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*   Input :  R1 points to 2-byte binary number.  LA    R1,BINNUM\n*   Output:  ASCWORK contains the 4-byte ASCII equivalent.\nASCCNVRT DS    0H\n         ST    R9,SAVER9AC\n         HEX   ASCWORK,2,0(R1)\n         TR    ASCWORK(4),TRASCNUM\nASCCNVRE DS    0H\n         L     R9,SAVER9AC\n         BR    R9\n         DS    CL2\nASCWORK  DS    XL4\n         DS    CL2\nTRASCNUM DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30414243444546303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30303030303030303030303030303030'\n         DC    XL16'30313233343536373839303030303030'\nTRTA2E   DS    0D                                                        05559\n         DC    XL16'000102030405060708090A0B0C0D0E0F'                    05560\n         DC    XL16'101112131415161718191A1B1C1D1E1F'                    05561\n         DC    XL16'405A7F7B5B6C507D4D5D5C4E6B604B61'                    05562\n         DC    XL16'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'                    05563\n         DC    XL16'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'                    05564\n         DC    XL16'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'                    05565\n         DC    XL16'79818283848586878889919293949596'                    05566\n         DC    XL16'979899A2A3A4A5A6A7A8A9C04FD0A17F'                    05567\n         DC    XL16'808182838485868788898A8B8C8D8E8F'                    05568\n         DC    XL16'909192939495969798999A9B9C9D9E9F'                    05569\n         DC    XL16'A0A14AB19FB26AB5BBB4AAABB0ADAFBC'                    05570\n         DC    XL16'B08FB2B3BEA0B6B39DB99BB8B7B8B9AB'                    05571\n         DC    XL16'C0C1C2C3C4C59EC7C8C9CACBCCCDCECF'                    05572\n         DC    XL16'ACD1D2D3D4D5D6BFD8D9DADBDCDDAEDF'                    05573\n         DC    XL16'E0E1E2E3E4E59CE7E8E9EAEBECEDEEEF'                    05574\n         DC    XL16'8CF1F2F3F4F5F6E1F8F9FAFBFC8D8EFF'                    05575\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nSCNSYSIN DS    0H                 Routine to extract info from SYSIN.\n         ST    R9,SAVER9SC\n* -------------- >>>>>>   Look for SYSIN cards            - BELOW\n         TM    FLAGSYST,X'08'       Is SYSIN there?\n         BZ    SCNSYSIE             No. Then can't open it. So get out.\n         OPEN  (SYSIN,(INPUT))\nSYSINLUP DS    0H\n         GET   SYSIN,GETSYSIN\n         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?\n         BE    SYSNWVOL              Yes. Go process the new volume.\n         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?\n         BE    SYSCHUNK                    Looks that way.....\n         CLC   =C'READ ',GETSYSIN\n         BE    SYSREAD\n         CLC   =C'IDRCOFF ',GETSYSIN\n         BE    SYSIDRCO\n         B     SYSINLUP              Look for another card.\nSYSNWVOL DS    0H\n         CLI   GETSYSIN+7,C' '       Is the next letter a blank?\n         BE    SYSINLUP              Yes. Ignore this card.\n         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.\n         B     SYSINLUP\nSYSCHUNK DS    0H\n         CLI   GETSYSIN+10,C' '  Is the first number value blank?\n         BE    SYSINLUP          Yes. Ignore entire card.\n         CLI   GETSYSIN+10,X'F0' Smaller than zero?\n         BL    SYSINLUP          Yes. Get another card.\n         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?\n         BH    SYSINLUP          Yes. Get another card.\n         OI    FLAGCHNK,X'01'    Show chunk size default was changed.\n         LA    R15,GETSYSIN+10   Now get the number that was coded.\n         LR    R1,R15            Load R1 with beginning of the number.\nSYSCHNUM DS    0H\n         LA    R15,1(,R15)       Bump to next character.\n         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?\n         BH    SYSCHGNM          Yes. Go get the number.\n         CLI   0(R15),C' '       Not end of card. But is it a blank?\n         BE    SYSCHGNM          Yes. Then get the number.\n         B     SYSCHNUM          Not a blank yet. Step up one place.\nSYSCHGNM DS    0H\n         SR    R15,R1            How many digits is the number?\n         BCTR  R15,0             Lower it by one for EXECUTE.\n         EX    R15,PACK          Copy the number to work area.\n         CVB   R0,WORKA          Convert it to a binary number.\n         ST    R0,CHNKSIZE       And store the value for later use.\n         L     R0,=F'&DEFCHNK'   >>> Force 65535 chunk size.\n         ST    R0,CHNKSIZE       >>> X'FFFF' is the only possibility.\nSYSCHCLG DS    0H\n         B     SYSINLUP          Go look for another card.\nSYSREAD  DS    0H\n         OI    READFLAG,X'01'\n         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.\n         B     SYSINLUP\nSYSIDRCO DS    0H\n         OI    IDRCFLAG,X'01'\n         B     SYSINLUP\nSYSINEND DS    0H                No more cards. Close SYSIN DCB.\n         CLOSE SYSIN\n* -------------- >>>>>>   Look for SYSIN cards            - ABOVE\nSCNSYSIE DS    0H\n         L     R9,SAVER9SC\n         BR    R9\n* - - >\nPACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>\nWORKA    DC    D'0'\n* - - >\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\n*     Routine to read a block of data from the input tape and\n*     save byte counts from it, to make the FAKETAPE headers.\n* ----------------------------------------------------------------- *\nREADBLOK DS    0H\n         ST    R9,SAVER9RB        Save BAL register\n         ST    R2,SAVER2R         Store work registers\n         ST    R3,SAVER3R\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Read\n         WAIT  ECB=INECB          Wait for Read\n         TM    INCSW+4,X'01'      Was TM Read?\n         BO    READTPMK           Yes\n         CLI   INECB,X'7F'        Did Read complete normally?\n         BNE   INERR              No -- error\n         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.\n         AP    BLOCKCNT,=P'1'\n         AP    BLOCKTOT,=P'1'\n         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read\n         XC    FULLWORK,FULLWORK   Clear area completely\n         MVC   HALFWORK(2),INCCW+6   Read length\n         L     R2,FULLWORK           Load R2 with full low order\n         MVC   HALFWORK(2),INCSW+6   Residual byte count\n         L     R3,FULLWORK           Load R3 with full low order\n         SR    R2,R3              R2=Actual length read\n         STH   R2,BYTESCOP        Save quantity of bytes copied\n         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block\n         NI    ISLBLFLG,X'FF'-X'01'  Turn off \"IS LABEL\" flag\n         OI    NWBLKFLG,X'01'        Turn on \"new block\" flag\n         B     READNOTM           This READ was not a Tape Mark\n*\nREADTPMK DS    0H                 This READ was a Tape Mark\n         TM    TPMKFLAG,X'01'     Check if there was another TM before\n         BZ    READTFST           No. First one.\n         OI    TPMKFLAG,X'02'     If two in a row, flag that situation\nREADTFST DS    0H\n         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?\n*\n* --- >                           Null SL file is not EOT - below\n         BNO   NOFIN1               Not 2 T.M. in a row. Go on.\n         TM    FLAGHDRL,X'01'       Test if HDR label was last seen\n         BO    NOFIN0               Yes. Must be null SL file.\n         B     FIN                  Otherwise, valid 2 TMs and EOT.\nNOFIN0   DS    0H\n         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.\nNOFIN1   DS    0H\n* --- >                           Null SL file is not EOT - above\n*\n         AP    FILCOUNT,=P'1'     Add 1 to File Count.\n         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.\n         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.\nREADNOTM DS    0H\n* ---->     for the trace            All READ results should come here\n         MVC   LINE,LINE-1           Clear output line\n         MVC   LINE+1(16),READTRMS   Put in Read Trace message\n         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?\n         BZ    ITSABLOC              No. Mark trace as for a block.\n         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.\n         B     ITSATPMK              And go farther.\nITSABLOC DS    0H\n         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block\nITSATPMK DS    0H\n         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ\n         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header\n         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header\n         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag\n         HEX   LINE+40,12,HEADER     Show the Header last constructed\n         HEX   LINE+68,30,INAREA     Show first 20 bytes of Input Area\n         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?\n         BNO   NOREADT1              No. Can't print trace line.\n         PUT   SYSTRACE,LINE\nNOREADT1 DS    0H                    Trace is finished.\n* ---->     for the trace\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R\n         B     READBEND           and exit normally.\n* -----\nINERR    DS    0H                 READ error on input tape\n         MVC   LINE,LINE-1        Clear print line\n         TM    INCSW+4,X'02'      Unit Check?\n         BZ    INERR1             No - Assume Data Check\n         MVC   LINE(133),INEQC    Set Error Message\n         B     INERR2             Continue\nINERR1   MVC   LINE(133),INDCK    Set Error Message\nINERR2   PUT   SYSPRINT,LINE      Write Error Message\n         L     R2,SAVER2R         Restore work registers\n         L     R3,SAVER3R         Rewind the tape, and exit.\n         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload\n         MVC   INECB,=F'0'        Initialize IN's ECB\n         EXCP  INIOB              Rewind and Unload\n         WAIT  ECB=INECB          Wait for Rewind and Unload\n         B     WRITSUMM           Write summary of what was done,\n*                                  and get out of the program.\nREADBEND DS    0H\n         L     R9,SAVER9RB        Restore BAL register\n         BR    R9\n* ----------------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* ----------------------------------------------------------------- *\nMAKEHEDR DS    0H\n         ST    R9,SAVER9MH\n* ----------------------------------------------------------------- *\n*     We are forming the new header in the field HEADER.\n*     We assume that the TAPEREAD subroutine was executed first.\n*     We assume that the FLDAREA was previously saved to SAVAREA.\n* ----------------------------------------------------------------- *\n         MVC   HEADER(12),BLNKHEDR     Start fresh.\n         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header\n         MVC   HDRNSTOR(2),CURRBYTE\n         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot\nMAKEWHAT DS    0H                      Manufacture the proper hdr flags\n         TM    TPMKFLAG,X'01'          Has a tape mark been read?\n         BO    MAKETPMH                First test. Make a X'40' header\n         B     MAKEFAKE\nMAKETPMH DS    0H                      Tape mark has been read.\n         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.\nMAKEFAKE DS    0H\n         MVC   HDRCHKWK(2),HDRPRVLN    Create header check field\n         XC    HDRCHKWK(2),HDRCURLN    XOR prev with curr\n* --                                   Convert quantities to ASCII\n         LA    R1,HDRPRVLN             Previous bytes in binary\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKPRV(4),ASCWORK     Stuff into header field\n         LA    R1,HDRCURLN             Current bytes in binary\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKNXT(4),ASCWORK     Stuff into header field\n         LA    R1,HDRCHKWK             XOR of both of them\n         BAL   R9,ASCCNVRT             Convert to ASCII numbers\n         MVC   HDRFKCHK(4),ASCWORK     Stuff into header field\n* --                                   The header is now created\n         MVC   HEADEREB(12),HEADER     Move copy of header to wkarea\n         TR    HEADEREB(12),TRTA2E     Translate into EBCDIC for print\nMAKEHDEN DS    0H\n         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN\n         AP    OUTHDRS,=P'1'           Count this header we've made.\n*----------------------------------------------------------------- *\n*   Now that we've made a header, we do a display.\n*----------------------------------------------------------------- *\n*\nKINDAHEN DS    0H\n         CLC   HDRFKNXT,=X'30303030'\n         BNE   BLOKHEDR\n         AP    OUTTYPE2,=P'1'\n         B     NOTBLOKH\nBLOKHEDR DS    0H\n         AP    OUTTYPE1,=P'1'\nNOTBLOKH DS    0H\n         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?\n         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION\n         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE\n         MVC   OUTLINE+2(4),=C'hdr:'\n         MVC   OUTLINE+8(12),HEADEREB   EBCDIC REPRESENTATION OF HEADER\n         HEX   OUTLINE+28,4,FLDSCARD                            .\n         HEX   OUTLINE+38,4,FLDECARD                            .\n         HEX   OUTLINE+48,4,FLDOFFST                            .\n         HEX   OUTLINE+58,4,FLDBYTES                            .\n         HEX   OUTLINE+68,4,FLDBYTOT                            .\n         HEX   OUTLINE+78,4,FLDBYMVD                            .\n         HEX   OUTLINE+88,4,FLDBUFFR                            .\n         HEX   OUTLINE+98,4,FLDBSTRT                            .\n         HEX   OUTLINE+108,7,FLDOUTCT                           .\n         HEX   OUTLINE+124,1,FLDREADF\n         PUT   SYSTRACE,OUTLINE\nNOSYSTR1 DS    0H\nMAKEHEND DS    0H\n         L     R9,SAVER9MH\n         BR    R9\n* ----------------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*                                                           *\n*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *\n*                                                           *\n*    All FLDAREA field required for call have to be         *\n*    filled in:                                             *\n*                                                           *\n*    FLDSCARD - Initialized to OUTCARD at beg of program    *\n*    FLDECARD - Initialized to OUTCARD+80                   *\n*    FLDOFFST - Initialized to 0, updated by each call      *\n*    FLDBYTES - Set before each call                        *\n*    FLDBYTOT - Set before each call                        *\n*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *\n*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *\n*    FLDBSTRT - Start of input buffer                       *\n*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *\n*    FLDREADF - READFLAG, copied into FLDAREA control blk   *\n*                                                           *\n* --------------------------------------------------------- *\nFOLDBUFF DS    0H\n         ST    R9,SAVER9FB              Save BAL register\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call\n*        BAL   R9,FLDIMAGE\n         LA    R1,FLDAREA\n         L     R15,=V(FOLDEM)           Entry point of FOLDEM program\n         BALR  R14,R15                  Call it.\n*                                       Copy back FLDAREA from FOLDEM\n         ST    R1,NEWFLDA               Save new FLDAREA address\n         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours\n         MVC   LINE,LINE-1\n*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call\n*        BAL   R9,FLDIMAGE\nFOLDBUFE DS    0H\n         L     R9,SAVER9FB              Restore BAL register\n         BR    R9                       Return to caller\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         ST    R9,SAVER9FI\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         PUT   SYSPRINT,LINE\n         MVC   LINE,LINE-1\n         L     R9,SAVER9FI\n         BR    R9\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\n*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ\n*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED\n* --------------------------------------------------------- *\nADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE\n         ST    R9,SAVER9AD         Save BAL register\n         STM   R4,R5,SAVEADDC      Save work registers\n         L     R4,0(,R3)           Load high order counter\n         L     R5,4(,R3)           Load low order counter\n         AR    R5,R2               Add to byte count\n         BNO   ADDCNOOV            No overflow, then branch\n         LA    R4,1(,R4)           else, overflow to high word\n         X     R5,=X'7FFFFFFF'     Get rid of sign bit\nADDCNOOV DS    0H\n         ST    R4,0(,R3)           Put updated counter in storage\n         ST    R5,4(,R3)           Put updated counter in storage\n         LM    R4,R5,SAVEADDC      Restore work registers\nADDCOUNE DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9AD         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nLABELCHK DS    0H         Check for the presence of tape labels\n*                         and set label flags, accordingly,\n*                         in the LBLFLAG byte.\n*\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n*\n* --------------------------------------------------------- *\n         ST    R9,SAVER9LB          Save BAL register\n         NI    ISLBLFLG,FF-X'01'    Turn off \"Is Label\" flag at start\n         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?\n         BE    CVOL1                Process THE VOL1\n         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?\n         BE    CHDR1                Process HDR1\n         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?\n         BE    CHDR2                Process HDR2\n         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?\n         BE    CEOF1                Process EOF1\n         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?\n         BE    CEOF2                Process EOF2\n         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?\n         BE    CEOV1                Process EOV1\n         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?\n         BE    CEOV2                Process EOV2\n         CLC   INAREA(3),=C'UHL'    This a User Header Label?\n         BE    CUHL                 Process UHL\n         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?\n         BE    CUTL                 Process UTL\n         B     NOTLABEL             80 byte record is not an IBM SL\n*        ------------------------------------------------------ *\nCVOL1    DS    0H                   PROCESS VOL1 LABEL\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRCV             NO. SKIP ROUTINE.\n         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRCV DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE\n         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n* ----- >    CHANGE OUTPUT VOLUME NAME - below\n         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?\n         BE    NOCHGVOL                  YES. DON'T CHANGE.\n         LA    R1,INAREA                 Point to INAREA\n         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.\n         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.\n         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.\n         TM    FLAGSYST,X'02'\n         BZ    NCHGMOVD\n         PUT   SYSMOVED,MESSAG13\nNCHGMOVD DS    0H\n         TM    FLAGSYST,X'04'            SYSFILES here?\n         BZ    NCHGFILE                  Nope. Skip a PUT to it.\n         PUT   SYSFILES,MESSAG13         VOLSER overridden message.\n         MVC   OUTLINE,OUTLINE-1         Blank line to separate\n         PUT   SYSFILES,OUTLINE             from the rest of output.\nNCHGFILE DS    0H\nNOCHGVOL DS    0H                        Kludge extra blank like\n         TM    FLAGSYST,X'04'            Is SYSFILES here?\n         BZ    KLUDGE01                  Nope. No PUTs to it.\n         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?\n         BNE   KLUDGE01                  Is overridden, no extra blank.\n         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank\n         PUT   SYSFILES,OUTLINE\nKLUDGE01 DS    0H\n* ----- >    CHANGE OUTPUT VOLUME NAME - above\n         B     LABCHEND\nCHDR1    DS    0H\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS\n         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.\n         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?\n         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET\n         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE\nCHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCHDR2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRH2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRH2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRH2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE\n         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2\n         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1\n         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOF2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRF2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRF2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRF2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2\n         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV1    DS    0H\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1\n         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCEOV2    DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW\n         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?\n         BZ    CLRIDRv2             NO. SKIP ROUTINE.\n         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?\n         BNE   CLRIDRV2\n         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1\nCLRIDRV2 DS    0H\n* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE\n         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2\n         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *\nCUHL     DS    0H                   HANDLE USER HEADER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\nCUTL     DS    0H                   HANDLE USER TRAILER LABELS\n         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL\n         B     LABCHEND\n*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *\nNOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF \"IS LABEL\" FLAG\nLABCHEND DS    0H                   Return to caller\n         L     R9,SAVER9LB          Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nSUMMREPT DS    0H                        Write Summary Totals\n         ST    R9,SAVER9SR               Save BAL Register\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG01\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG02\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG03\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE(34),PRMSG06\n         MVC   OUTLINE+36(18),EDPAT\n         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS\n         PUT   SYSPRINT,OUTLINE\n* >---->                                 Display tape total counts\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'\n         PUT   SYSPRINT,OUTLINE\n         MVC   OUTLINE,OUTLINE-1\n         PUT   SYSPRINT,OUTLINE\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTMH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST\n         L     R4,DBOUTML                LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD               AND ADD IT IN\n         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM01\n         PUT   SYSFILES,CNTLINE\nNOSUMM01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM02\n         PUT   SYSFILES,CNTLINE\nNOSUMM02 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,LBINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM03\n         PUT   SYSFILES,CNTLINE\nNOSUMM03 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG06       Total bytes read for data\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DAINH\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM04\n         PUT   SYSFILES,CNTLINE\nNOSUMM04 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape\n         MVC   FILEBYTE,BYTESPAT\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKTOT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         PUT   SYSPRINT,CNTLINE\n* >---->\n         TM    FLAGSYST,X'04'\n         BNO   NOSUMM05\n         PUT   SYSFILES,CNTLINE\nNOSUMM05 DS    0H\n* >---->\nSUMMREND DS    0H                  END OF ROUTINE - RETURN\n         L     R9,SAVER9SR         Restore BAL register\n         BR    R9\n* --------------------------------------------------------- *\n*    BAL REGISTER IS R9.\n* --------------------------------------------------------- *\nREPTFILE DS    0H       Routine to write block and byte counts\n*                       for each file in the SYSFILES ddname.\n* --------------------------------------------------------- *\n*----------->>\n         ST    R9,SAVER9RF\n*--->                   Block counts first  -  below\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG07\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   CNTLINE+54(11),BLOKPAT\n         ED    CNTLINE+54(11),BLOCKCNT+2\n         MVC   CNTLINE+65(6),=C'Blocks'\n         MVC   CNTLINE+90(11),BLOKPAT\n         ED    CNTLINE+90(11),BLOCKTOT+2\n         MVC   CNTLINE+102(10),=C'Cum Blocks'\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE00\n         PUT   SYSFILES,CNTLINE\nNOFILE00 DS    0H\n* >---->\n*--->                   Block counts first  -  above\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG01\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFMH        Bytes folded counts for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n         L     R4,SAVER4Q\n* >--->\n         TM    ISLBLFLG,X'01'\n         BO    DISLABLS\n         MVC   DATBYTES,BYTESPAT\n         L     R4,DAINH           Data bytes written cumulative to here\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DAINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),DATDISPL\n         B     DISPDATA\n* >--->\nDISLABLS DS    0H\n         MVC   LABBYTES,BYTESPAT\n         L     R4,LBINH           Label bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,LBINL           LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(38),LABDISPL\n         B     DISPDATA\n* >--->\nDISPDATA DS    0H\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE01\n         PUT   SYSFILES,CNTLINE\nNOFILE01 DS    0H\n* >---->\n         MVC   CNTLINE,CNTLINE-1\n         MVC   CNTLINE(38),CTMSG02\n         MVC   CNTLINE+29(9),FILEPAT\n         ED    CNTLINE+29(9),FILCOUNT+3\n         MVC   FILEBYTE,BYTESPAT\n         ST    R4,SAVER4Q\n         L     R4,DBOUTFH         Bytes written for this file\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+38(32),FILEBYT\n* >--->\n         CLC   DBOUTF(8),DBOUTFM\n         BE    RIGHTBYT\n         MVI   CNTLINE+72,C'*'\nRIGHTBYT DS    0H\n* >--->\n         MVC   CUMBYTES,BYTESPAT\n         L     R4,DBOUTH          Bytes written, cumulative\n         CVD   R4,DWORD\n         ZAP   QWORD,DWORD\n         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST\n         L     R4,DBOUTL          LOAD REG WITH LOW ORDER\n         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED\n         AP    QWORD,DWORD        AND ADD IT IN\n         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE\n         MVC   CNTLINE+74(43),CUMDISPL\n* >--->\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE02\n         PUT   SYSFILES,CNTLINE\nNOFILE02 DS    0H\n         L     R4,SAVER4Q\n         MVC   CNTLINE,CNTLINE-1\n         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?\n         BNO   NOFILE03\n         PUT   SYSFILES,CNTLINE\nNOFILE03 DS    0H\n*----------->>\nREPTFEND DS    0H\n         L     R9,SAVER9RF\n         BR    R9\n         EJECT\n* ----------------------------------------------------------------- *\n*      CCWs and IOB for the EXCP operations.\n* ----------------------------------------------------------------- *\n*              read,addr of data,flags,64K bytes\nRUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW\n         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW\nINCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW\nINECB    DC    F'0'\nINIOB    DC    X'02000000'\n         DC    A(INECB)\nINCSW    DC    2F'0'\nINCCWPT  DC    A(INCCW)\nINDCBPT  DC    A(TAPIN)\n         DC    F'0'\n         DC    X'00010000'\n         DC    XL44'00'            Padding\n         SPACE 3\n* ----------------------------------------------------------------- *\n         ENTRY FAKEOUT\nFAKEOUT  DCB   DDNAME=FAKEOUT,MACRF=PM,DSORG=PS,LRECL=80\nTAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U\n         ENTRY SYSPRINT\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nSYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X\n               EODAD=SYSINEND\n         DC    CL8' '\nFF       EQU   X'FF'\nBLNKHEDR DC    XL12'303030303030303030303030'\n* ----------------------------------------------------------------- *\n*\n* AWSTAPE BLOCK HEADER\n*\n* ----------------------------------------------------------------- *\nHEADER   DS    0CL12                    BLOCK HEADER\nHDRFKPRV DC    XL4'30303030'\nHDRFKNXT DC    XL4'30303030'\nHDRFKCHK DC    XL4'30303030'\n* --- >\nHDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH\nHDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH\nHDRCHKWK DC    XL2'0000'                XOR CHECK WORK AREA\n* --- >\n*\n         DC    XL80'00'                 PADDING\nHEADEREB DS    XL12\n* ----------------------------------------------------------------- *\n         DC    XL12'00'                 PADDING\nHALFZERO DC    XL2'00'\n         DC    XL12'00'                 PADDING\nHDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF\nHDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF\n         DC    XL12'00'                 PADDING\nBYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nCURRBFUL DS    0F\n         DC    H'0'\nCURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\nLASTBFUL DS    0F\n         DC    H'0'\nLASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT\nPARTBFUL DS    0F\n         DC    H'0'\nPARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT\nZEROCARD DC    80X'30'\n* -------------------------------------------- *\n* ---------- *      F L A G S     * ---------- *\n* -------------------------------------------- *\n* ---------- *\nREADFLAG DC    X'00'         This run is \"READ ONLY\"  ?\n*              X'01'         Yes, read only.\n* ---------- *\nNWBLKFLG DC    X'00'         We have just read a new block.\n*              X'01'         Turned off after first chunk write.\n* ---------- *\nIDRCFLAG DC    X'00'         This run is \"IDRC Fix\"  ?\n*              X'01'         Turn off IDRC indicator\n* ---------- *\nFLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED\n*              X'01'          CHUNK SIZE IS NOT BLANK\n* ---------- *\nFLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE\n*              X'01'          //SYSTRACE DD IS THERE\n*              X'02'          //SYSMOVED DD IS THERE\n*              X'04'          //SYSFILES DD IS THERE\n*              X'08'          //SYSIN    DD IS THERE\n* ---------- *\nCHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?\n*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE\n* ---------- *\nBUFINISH DC    X'00'          Have we finished folding entire buffer?\n*              X'01'          Yes. We are now finishing the buffer.\n* ---------- *\nLBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN\n*              X'01'    HDR1 HAS BEEN SEEN\n*              X'02'    HDR2 HAS BEEN SEEN\n*              X'04'    VOL1 HAS BEEN SEEN\n*              X'08'    HDR1 IS FROM AN INITTED TAPE\n*              X'10'    EOF1 HAS BEEN SEEN\n*              X'20'    EOF2 HAS BEEN SEEN\n*              X'40'    EOV1 HAS BEEN SEEN\n*              X'80'    EOV2 HAS BEEN SEEN\n* ---------- *\nISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL\n*              X'00'          DATA IS NOT A LABEL\n*              X'01'          DATA IS A LABEL\n* ---------- *\nTPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark\n*              X'01'          We just read a Tape Mark\n*              X'02'          We previously read a Tape Mark\n* ---------- *\nFLAGHDRL DC    X'00'          Header label flag - Last label was a hdr\n*              X'01'          EOT HEADER is following a HDR1 or HDR2\n* ---------- *\n* -------------------------------------------- *\nFULLWORK DS    0F\nFULLHIGH DC    H'0'\nHALFWORK DC    H'0'                HALFWORD WORK AREA\n         DC    2F'0'               Padding\nFOLDBREG DS    0F                  Fullword - no of bytes to fold\nFOLDHIGH DC    XL2'00'             High order - should be zeros\nHDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD\nHDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED\nHDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVF  DC    XL2'00'\nHDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED\nHDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD\nHDRLENFL DC    XL2'00'\nHDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER\nHDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD\nHDRPRVFL DC    XL2'00'\nHDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER\nOUTCCWST DC    XL2'00'\n         DC    XL2'00'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSVNEWVOL DC    CL6' '              SAVED NEW VOLUME\nCHNKSIZE DC    F'65535'            Default is maximum halfword\nLASTLINE DS    0CL80\nLASTHX00 DC    80X'00'\nHEXSAVE  DS    3F                  SAVE FOR HEX MACRO\nDWORD    DC    D'0'\nQWORD    DS    PL16\nTWO31    DC    P'2147483648'       2 TO THE 31ST\nOUTHDRS  DC    PL7'0'\nOUTTYPE1 DC    PL7'0'\nOUTTYPE2 DC    PL7'0'\nOUTTYPE3 DC    PL7'0'\nOUTTYPE4 DC    PL7'0'\nOUTTYPE5 DC    PL7'0'\nFILCOUNT DC    PL7'0'\nBLOCKCNT DC    PL7'0'\nBLOCKTOT DC    PL7'0'\nTPMKCNT  DC    PL7'0'\nDECVALUE DS    CL8\nFILEPAT  DC    X'402020202020202120'\nBLOKPAT  DC    X'4020202020202020212020'\nEDPAT    DC    X'40206B2020206B2020206B2020206B202120'\nBYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'\nFILEBYT  DS    0CL32\nFILEBYTE DC    C' 9,999,999,999,999,999,999'\n         DC    C' Bytes'\nCUMDISPL DS    0CL43\nCUMBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Total Bytes'\nLABDISPL DS    0CL38\nLABBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Labels'\nDATDISPL DS    0CL38\nDATBYTES DC    C' 9,999,999,999,999,999,999'\n         DC    C'  Cum Data  '\n*\nSVBEGCRD DS    F\nSVENDCRD DS    F\nSVBFAREA DS    F                Address of input buffer\n*\nSAVER2R  DS    F                Save work regs during tape read.\nSAVER3R  DS    F                Save work regs during tape read.\nSAVER4B  DS    F                Register Save for HEX routine\nSAVER4Q  DS    F                Register Save for byte count reperting\nSAVEFOLD DS    6F               Register Save for FOLDEM routine\nSAVEADDC DS    3F               Register Save for ADDCOUNT routine\nSAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE\nSAVER9AD DS    F                Register Save for ADDCOUNT routine\nSAVER9RB DS    F                Register Save for READBLOK routine\nSAVER9RF DS    F                Register Save for REPTFILE routine\nSAVER9LB DS    F                Register Save for LABELCHK routine\nSAVER9SR DS    F                Register Save for SUMMREPT routine\nSAVER9FB DS    F                Register Save for FOLDBUFF routine\nSAVER9FI DS    F                Register Save for FLDIMAGE routine\nSAVER9SC DS    F                Register Save for SCNSYSIN routine\nSAVER9MH DS    F                Register Save for MAKEHEDR routine\nSAVER9AC DS    F                Register Save for ASCCNVRT routine\nNEWFLDA  DS    F\nHDRSIZE  DC    F'12'            SIZE OF A HEADER\nSVBEGDAT DS    F\n*  -----------------\nZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1\n*  -----------------     JFCB if we'll need RDJFCB later - not used now\nJFCB1    DC    X'87'\n         DC    AL3(INFMJFCB)\n         IEFJFCBN LIST=YES\n         DC    C' '\n*\n*  -----------------            Summary Totals Message Texts\nPRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '\nPRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '\nPRMSG03  DC    CL34'     TOTAL BLOCK HEADERS        : '\nPRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '\nPRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '\nPRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '\nPRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '\n*\n*  -----------------            Byte Count Message Texts\nCTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '\nCTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '\nCTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '\nCTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '\nCTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '\nCTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '\nCTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '\nCTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '\n*\n*  -----------------            Header Message Texts\nMESSAGE1 DC    CL133'1VTT2T2FK - REAL TAPE TO FB-80 AWS CONVERSION PROG-\n               RAM  '\nMESSAGE2 DC    CL133'1VTT2T2FK  -  AWS TAPE HEADER TRACE REPORT  '\nMESSAGE3 DC    CL133'1VTT2T2FK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-\n               R REPORT  '\nMESSAGE4 DC    CL133'1VTT2T2FK - TAPE TO AWS FILE REPORT - READ AND FOL-\n               D STATS  '\nMESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -\n               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-\n               '\nMESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-\n               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-\n               '\nMESSAGE7 DS    0CL133\n         DC    CL8'  hdr:  '\n         DC    CL12'HEADER TEXT '\n         DC    CL1' '\n         DC    CL4'TYPE'\n         DC    CL3' '\n         DC    CL10'FLDSCARD'\n         DC    CL10'FLDECARD'\n         DC    CL10'FLDOFFST'\n         DC    CL10'FLDBYTES'\n         DC    CL10'FLDBYTOT'\n         DC    CL10'FLDBYMVD'\n         DC    CL10'FLDBUFFR'\n         DC    CL10'FLDBSTRT'\n         DC    CL14'FLDINRCD'\n         DC    CL11' '\nMESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-\n                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-\n               DE. '\nMESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2T2FK, THE SYSMOV-\n               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-\n                 '\nMESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-\n               EPORT.  BOTH \"TAPE READ\" AND \"FOLD DATA\" ARE AVAILABLE T-\n               HERE.'\nMESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -\n               HAVE SOURCE CODE, THEN UNCOMMENT THE \"BEFCALL-\" AND \"AFT-\n               CALL-\" '\nMESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-\n               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -\n                    '\nMESSAG13 DC    CL133'    VOLSER Overridden to:    '\nMESSAG14 DC    CL133'    Chunk Size is set to:    '\n*  -----------------            Error Message Texts\nERRMESS1 DC    CL133'    OFFSET ERROR           '\nINEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '\n         DC    C'TERMINATED '\n         DC    76C'*'\nINDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '\n         DC    82C'*'\n*  -----------------            Trace Message Texts\nREADTRMS DC    CL16'READ TRACE:     '\nFOLDTRMS DC    CL16'FOLD TRACE:     '\nMHDRTRMS DC    CL16'MAKEHEDR TRACE: '\nOSETTRMS DC    CL16'OFFSET TRACE:   '\nBBLKTRMS DC    CL16'BLOCK TRACE:    '\n*    ------------------------ >   Output Line Buffers  -  below\n         DC    C' '\nCNTLINE  DC    CL133' '\n         DC    C' '\nOUTLINE  DC    CL133' '\n         DC    C' '\nLINE     DC    CL133' '           For error messages\n         DC    C' '\nPRTLINE  DC    CL133' '\n         DC    C' '\nMSGLINE1 DC    CL133' '           For READ only message\n         DC    C' '\nMSGLINE2 DC    CL133' '           For IDRC remove message\n*    ------------------------ >   Output Line Buffers  -  above\n         LTORG\nSAVEHDR  DC    XL6'000000000000'\nEOTMARK  DC    XL12'303030303030303030303030'\n* - - - - >\n*\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\n* - - - - >\n*         Saved Copy of FLDAREA Control Block\n* - - - - >\n*\nSAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nSAVSCARD DC    F'0'         Start address of 80-byte card\nSAVECARD DC    F'0'         End address of 80-byte card\nSAVOFFST DC    F'0'         OFFSET of data in the card\nSAVBYTES DC    F'0'         Number of bytes to be folded now\nSAVBYTOT DC    F'0'         Batch total of bytes left to move\nSAVBYMVD DC    F'0'         Number of bytes folded now\nSAVBUFFR DC    F'0'         Current data start address\nSAVBSTRT DC    F'0'         Original start data address\nSAVOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nSAVREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nSAVLENTH EQU   *-SAVAREA\n*\n* - - - - >\n*    ------------------------ >   Byte Count Save Areas - below\n*\n*                          -- These are doubleword counters --\n*\nDBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ\nDBOUTFH  DC    F'0'\nDBOUTFL  DC    F'0'\nDBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED\nDBOUTFMH DC    F'0'\nDBOUTFML DC    F'0'\nDBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ\nDBOUTH   DC    F'0'\nDBOUTL   DC    F'0'\nDBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED\nDBOUTMH  DC    F'0'\nDBOUTML  DC    F'0'\nLBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES\nLBINH    DC    F'0'\nLBINL    DC    F'0'\nDAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES\nDAINH    DC    F'0'\nDAINL    DC    F'0'\n         DC    CL8' '      Extra padding for safety\n*\n*    ------------------------ >   Constants for Date and Time - below\nSAVE1402 DS    6F                 ONE MORE FOR SAFETY\nTIMED    DS    CL7\nDATED    DS    CL9\nDATETIME DS    4F\n         ORG   DATETIME\nTIME     DS    CL4\n         DS    CL4\nDATE     DS    CL5\n         DS    CL3\nHEADDLIT DS    0CL31              Literal for headings - date and time\n         DC    CL6'Today:'\n         DC    CL2' '\nHEADDATE DC    CL23' '\nLEVELLIT DS    0CL21              Level number display for headings\n         DC    CL6'Level '\nLEVELL   DC    CL4'&LLEV'\n         DC    CL2' ('\nLEVDATE  DC    CL8' '             Assembly date for this program\n         DC    CL1')'\n*    ------------------------ >   Constants for Date and Time - above\n         DC    F'0'               Align, just for the heck of it\nGETSYSIN DC    CL80' '\nOUTCARDP DC    XL80'00'           Previous card-image read\nOUTCARD  DC    XL80'00'           Current  card-image read\nOUTCAEND EQU   *\n         DC    XL80'00'           Room for another card-image\n         DS    0F\n         DC    CL8' '\nINAREA   DS    CL65535            Buffer to hold tape blocks\n         DS    CL800              Padding, so as not to overrun\n*                                 somebody else's storage by mistake.\n         END\n   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'\nFOLDEM   CSECT\n*  ---------------------------------------------------------------  *\n*\n*   AUTHOR:       Sam Golob\n*\n*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,\n*                 subject to express permissions from the author\n*                 to use this software.  This software is part\n*                 of VTTS (Virtual Tape Transportation System).\n*\n*                 Permission is granted by the author for all\n*                 parts of the VTTS package which are distributed\n*                 on the CBT Tape collection, to be used by\n*                 anyone for their own use, but not for resale\n*                 or for reincorporation within commercial code.\n*\n*                           -------------------------------------\n*                           It is probably not necessary to run\n*                           this program in 24-bit mode.  But\n*                           it works when it is run that way.\n*                           -------------------------------------\n*                           We do want old MVS systems to be able\n*                           to run this routine.\n*                           -------------------------------------\n*\n*  ---------------------------------------------------------------  *\n*                                                                   *\n*  SUBROUTINE:    FOLDEM                                            *\n*                                                                   *\n*  DESCRIPTION:                                                     *\n*                                                                   *\n*      This program is the heart of the process of creating an      *\n*      FAKETAPE disk file from a real tape file.    The disk        *\n*      file is data that has been folded over from a buffer,        *\n*      into an FB-80 dataset.                                       *\n*                                                                   *\n*      This program takes buffer data and folds it into FB-80       *\n*      data, starting from a given buffer address, for a given      *\n*      number of bytes.  The data is folded into an 80-byte         *\n*      workarea starting from a given OFFSET address (+0 to +79)    *\n*      into the workarea.  When the workarea has been completely    *\n*      filled and more data is to be written, a PUT is done to      *\n*      write out the data from the 80-byte workarea, and then       *\n*      the workarea is cleared with binary zeros before any         *\n*      additional data is written to it.  An incompletely filled    *\n*      workarea is not written out, and the same is true if the     *\n*      workarea is full but no more data is to be written out.      *\n*      So in that case, the location of the workarea is returned    *\n*      to the caller in field FLDSCARD, and it is the caller's      *\n*      responsibility to do the PUT for the last card.              *\n*                                                                   *\n*  INPUTS and OUTPUTS:                                              *\n*                                                                   *\n*      This program is driven by a control block called FLDAREA,    *\n*      which is updated by both this program and by the caller.     *\n*      See below for more details.                                  *\n*                                                                   *\n*  FILES NEEDED:                                                    *\n*                                                                   *\n*      This program assumes that the caller has opened DCBs for     *\n*      an FB-80 file called FAKEOUT, which receives the output      *\n*      \"virtual tape\" data, and for SYSPRINT.  This program         *\n*      needs to do PUTs to FAKEOUT, and if necessary, it needs      *\n*      to write messages to SYSPRINT.  Therefore the caller has     *\n*      to provide ENTRY FAKEOUT and ENTRY SYSPRINT statements in    *\n*      front of its FAKEOUT and SYSPRINT DCBs, respectively.        *\n*                                                                   *\n*  METHOD OF OPERATION:                                             *\n*                                                                   *\n*      This program operates using a control block, called the      *\n*      FLDAREA, which is passed from the caller and back to the     *\n*      caller.  Both the caller and this program update the         *\n*      FLDAREA.  Upon entry to this program, R1 is expected to      *\n*      point to the caller's copy of FLDAREA, and upon return,      *\n*      R1 is pointed to the updated copy of FLDAREA in this         *\n*      subroutine.  So the caller has to copy it back over its      *\n*      own instance of FLDAREA after the return.                    *\n*                                                                   *\n*      The caller does one tape read, or read of data into a        *\n*      buffer.  From the number of bytes read, the caller will      *\n*      construct a FAKETAPE header which will determine how many    *\n*      bytes should be folded into the FB-80 disk dataset.  This    *\n*      FAKETAPE header is also folded by a call to this program,    *\n*      and then the tape data is folded in afterward, for the       *\n*      number of bytes required by the block size.                  *\n*                                                                   *\n*      This program does one or more PUTs into the FB-80 file,      *\n*      until the request for the number of bytes to be folded,      *\n*      is satisfied.  A PUT is done whenever the FB-80 work area    *\n*      has been filled.  At the end of the fold operation, the new  *\n*      OFFSET into the FB-80 workarea (that has not yet been        *\n*      written out to disk), the number of bytes that have been     *\n*      folded, and the projected start of the next data to be       *\n*      folded, are returned in the fields of the FLDAREA control    *\n*      block.                                                       *\n*                                                                   *\n*      The following is the layout of the FLDAREA.  Fields          *\n*      marked with an arrow must be supplied upon input to this     *\n*      program.                                                     *\n*                                                                   *\n*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *\n*      *                         ------ ---- ------- -----          *\n*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *\n*  --> FLDECARD DC    F'0'       End address of 80-byte card        *\n*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *\n*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *\n*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *\n*      FLDBYMVD DC    F'0'       Number of bytes folded now         *\n*  --> FLDBUFFR DC    F'0'       Current data start address         *\n*  --> FLDBSTRT DC    F'0'       Original start data address        *\n*      FLDOUTCT DC    PL7'0'     Number of PUTs for FAKEOUT records *\n*  --> FLDREADF DC    X'00'      This run is \"READ ONLY\"  ?         *\n*      *              X'01'      Yes, read only. (Copied from the   *\n*                                READFLAG byte in the caller.)      *\n*      FLDLENTH EQU   *-FLDAREA                                     *\n*                                                                   *\n*      The rest of the fields are calculated by this program        *\n*      and returned to the caller.                                  *\n*                                                                   *\n*      FLDBUFFR and FLDOFFST are updated by this program, and       *\n*      upon return to the caller, they point to the input data      *\n*      and output data positions, respectively, that are just       *\n*      after the moved data, to anticipate the next call, so as     *\n*      to be able to move more data.  FLDBSTRT preserves the        *\n*      very beginning address of the input buffer, whereas          *\n*      FLDBUFFR is a place somewhere within the buffer, which       *\n*      is the start from where the new data is expected to be       *\n*      moved.                                                       *\n*                                                                   *\n*      A new field, FLDBYTOT, makes it possible to create           *\n*      chunked blocks, but with FAKETAPE, that doesn't happen,      *\n*      so we have set things up with chunksize always equal 65535   *\n*      so \"chunksize is always equal to blocksize\".  The FLDBYTOT   *\n*      field originally contains the number of bytes in an entire   *\n*      block, and after the entire block has been written, it       *\n*      should be decremented by the number of bytes written, and    *\n*      it would therefore be 0.                                     *\n*                                                                   *\n*      Since both the caller and this program do PUT operations     *\n*      to the output FB-80 file, the count of the number of PUTs    *\n*      done, FLDOUTCT, is updated by BOTH the caller and by this    *\n*      program.                                                     *\n*                                                                   *\n*  ---------------------------------------------------------------  *\n         MACRO\n*  ---------------------------------------------------------------  *\n*    This macro is used to display hex values in a printed report.\n*  ---------------------------------------------------------------  *\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    DS    0H\n         ST    R4,SAVER04\n         STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         L     R4,SAVER04\n         LM    15,1,HEXSAVE\n         MEND\n         SPACE\n         YREGS\nFOLDEM   AMODE 24\nFOLDEM   RMODE 24\n         USING *,R15\n         B     EYECATCH\n         DC    C'--- '            MAKE EYECATCHER VISIBLE\n         DC    C'FOLDEM'\n         DC    C' - '\nSYSDAT   DC    C'&SYSDATE'\n         DC    C'  ',C'&SYSTIME '\nSAVEAREA DC    18F'0'\nEYECATCH DS    0D                    ENSURE ALIGNMENT\n         STM   R14,R12,12(R13)\n         LR    R5,R1                 SAVE PARM POINTER\n         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS\n         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1                NEW SAVE AREA ADDRESS\n         DROP  R15\n* -----                              SET UP BASE REGISTERS\n         USING FOLDEM,R12,R11\n         LR    R12,R15\n         LA    R11,4095(,R12)\n         LA    R11,1(,R11)\n         LR    R1,R5                 RESTORE PARM POINTER\n         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA\n         L     R0,SYSPRINV           SYSPRINT DCB address in caller\n         ST    R0,SYSPRDCB             store for the program's use\n         L     R0,FAKEOUTV           FAKEOUT  DCB address in caller\n         ST    R0,FKOUTDCB             store for the program's use\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                   *\n*   Routine to fold buffer data into an FB-80 file, starting at     *\n*   a given location in the buffer, for a certain number of bytes,  *\n*   and starting at a given OFFSET in the 80-byte workarea to       *\n*   which the buffer data will be written.  When the 80-byte        *\n*   workarea is filled up, a PUT is done to FAKEOUT, and the        *\n*   workarea is cleared with binary zeros for more data to be       *\n*   written.                                                        *\n*                                                                   *\n*   Input:   FLDAREA fields are all supplied by the calling         *\n*            program, except for FLDBYMVD which is calculated       *\n*            by this program and returned to the caller.  The       *\n*            caller's copy of FLDAREA is pointed to by Register 1.  *\n*                                                                   *\n*            The buffer area containing the data to be folded       *\n*            is supplied by the calling program, as well as the     *\n*            number of bytes that is expected to be folded.         *\n*                                                                   *\n*   Output:  Data from the buffer will be moved into the 80-byte    *\n*            workarea until the workarea is filled.  When the       *\n*            workarea is filled, a PUT will be done to FAKEOUT,     *\n*            and the workarea is cleared to X'00's to make room     *\n*            for more data, when more data is to be written.        *\n*                                                                   *\n*            Ending OFFSET into the 80-byte workarea, pointing to   *\n*            just after the data which has been moved, is returned  *\n*            in the FLDOFFST field.  Upon return to the caller,     *\n*            the FLDBUFFR field is updated to point to the place    *\n*            in the buffer just after the data which has been       *\n*            moved.  The FLDBSTRT field always should point to the  *\n*            beginning of the data buffer, but this is at the       *\n*            discretion of the calling program.                     *\n*                                                                   *\n*            A count of bytes actually moved from the buffer to     *\n*            the 80-byte workarea (and written out by PUTs to the   *\n*            FAKEOUT DD name as is necessary) is calculated by this *\n*            program and returned in the FLDBYMVD field.  Upon      *\n*            return, the number in the FLDBYMVD field should match  *\n*            the number in the FLDBYTES field.                      *\n*                                                                   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* <--------- SET UP LOOP TO START MOVING THE DATA ------->\nFOLDIT   DS    0H\n         L     R1,SAVEPARM          Load address of caller's FLDAREA\n         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA\n         USING FLDBLOCK,R2\n         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours\n* - - - - - - - - - -      Load the buffer quantities\n         L     R7,FLDBUFFR          Initialize start of buffer data\n         L     R8,FLDBYTES          Bytes to be moved\n         AR    R8,R7                Add in start buffer address\n         ST    R8,HYPOENDB          Hypothetical end-of-buffer address\n*                                   which is probably the real\n*                                   end-of-data to be moved.\n* - - - - - - - - - -      Load the card quantities\n         MVC   SAVEBEGC,FLDSCARD    Save \"start of card\" address\n         MVC   SAVEENDC,FLDECARD    Save \"end of card\" address\n         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved\n         L     R7,FLDSCARD          Point to beginning of card\n         A     R7,FLDOFFST          Add OFFSET to start of output\n         ST    R7,SAVEBEGO          Save where output starts\n         L     R8,SAVEBEGO          Copy beg of output address\n         A     R8,FLDBYTES          Make hypothetical end address,\n*                                   by adding the bytes to be moved.\n         ST    R8,HYPOENDC          Store hypothetical card end address\n*                                   (This may be way past end of card.)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*  Cases:  1.  Current move is to within the current card.        *\n*              Covered by LOOPSHRT routine.                       *\n*                                                                 *\n*          2.  Current move is past the current card.             *\n*              Covered by LOOPMORE routine.  So we have to do     *\n*              iterations.                                        *\n*                                                                 *\n*        R6 always contains the number of bytes to be moved       *\n*        for this segment.                                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nLOOPINIT DS    0H\n         L     R7,SAVEBEGO          Beginning of CARD data\n         L     R8,HYPOENDC          Hypothetical end of CARD data\n         L     R3,FLDBUFFR          Prime R3 with start of buffer data\n         C     R8,SAVEENDC          Is R8 past the end-of-card?\n         BH    LOOPMORE             Yes. Do multiple moves and PUTs.\nLOOPSHRT DS    0H                   No. Do the one move only.\n         LR    R6,R8                Get byte count to move NOW.\n         SR    R6,R7                Bytes to move from buffer to card\n         C     R6,=F'80'            More than 80?\n         BH    LOOPERR1             Yes. Has to be error, so flag it.\n         BCTR  R6,0                 No. One less for EXECUTE.\n         EX    R6,MOVEBUFF          Move the data from buffer to card.\n         LA    R6,1(,R6)            Restore count of bytes moved\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total bytes moved.\n         ST    R1,FLDBYMVD          Store it away for later.\n         LA    R3,0(R6,R3)          Bop past beginning buffer address.\n*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Not equal to predicted end?\n         BNE   LOOPERR2             Error, so flag it.\n         ST    R3,FLDBUFFR          Return modified new buffer address.\n         LR    R6,R8                Calculate new OFFSET -\n         S     R6,FLDSCARD          Subtract beginning of card address\n         ST    R6,FLDOFFST          Store the result as new OFFSET\n* -- >\nLOOPTS50 DS    0H\n*                                   If OFFSET > X'4F', card is complete\n         C     R6,=F'80'            Is the new offset exactly X'50'?\n         BNE   LOOPNT50             No. Then current card not complete.\n*                                   Yes. Then PUT out card and init it.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT001             Yes. Can't PUT to FAKEOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT001 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n         XR    R6,R6                Clear R6\n         ST    R6,FLDOFFST          New offset is 0, not X'50'\nLOOPNT50 DS    0H\n* -- >\n         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT\n         S     R1,FLDBYMVD          And subtract bytes already moved\n         ST    R1,FLDBYTOT          To show new total buffer byte count\n*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         B     RETURN\n*\nLOOPMORE DS    0H                   Data move if more than one card\n*\n         L     R6,SAVEENDC          We're going past end-of-card\n         SR    R6,R7                Subtract beg address of data\n         C     R6,=F'80'            Still bigger than 80?\n         BH    LOOPERR1             Yes. Has to be error.\n         BCTR  R6,0                 Subtract one for EXECUTE\n         EX    R6,MOVEBUFF          Move data into buffer\n         LA    R6,1(,R6)            Restore byte count\n         L     R1,FLDBYMVD          Increment\n         AR    R1,R6                  total\n         ST    R1,FLDBYMVD              bytes moved\n         LA    R3,0(R6,R3)          Bop past data moved in buffer\n*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R3,HYPOENDB          Test if past end of buffer\n         BH    LOOPERR3             Yes. Has to be an error.\n         ST    R3,FLDBUFFR          Re-point current buffer address.\n         S     R8,=F'80'            -80 bytes because new card PUT out\n         ST    R10,SAVER10          Save register for safety\n         L     R10,FKOUTDCB         Point to FAKEOUT DCB in caller\n         L     R1,FLDSCARD          Load address of card\n         MVC   WORKAREA(80),0(R1)   Move full card image to workarea\n         TM    FLDREADF,X'01'       Is this a READ only run?\n         BO    NOPUT002             Yes. Then don't produce FAKEOUT.\n         PUT   (10),WORKAREA        PUT the card image to output file\nNOPUT002 DS    0H\n         L     R10,SAVER10          Restore R10\n         AP    FLDOUTCT,=P'1'       Count of FAKEOUT records written\n         L     R7,SAVEBEGC          Point to beginning address of card\n         MVC   0(80,R7),ZEROCARD    Initialize card image for next move\n*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **\n*        BAL   R9,FLDIMAGE\n         C     R8,SAVEENDC          Is R8 within the card image end?\n         BH    LOOPMORE             No. Do the LOOPMORE routine.\n         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.\n         SPACE 3\n* ----------------------------------------------------------------- *\nMOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>\n* --------------------------------------------------------- *\nLOOPERR1 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR1 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR2 DS    0H                   Error entry location\n         MVC   LINE,LINE-1             **  Diagnostic  **\n         MVC   LINE+1(9),=C'LOOPERR2 '\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\nLOOPERR3 DS    0H                   Error entry location\n         MVC   LINE,LINE-1\n         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **\n         BAL   R9,FLDIMAGE\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n* --------------------------------------------------------- *\nRETURN   DS    0H                   RETURN TO THE CALLER\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SAVEPARM         Address of FLDAREA in caller\n         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back\n         L     R10,SAVER10          Restore R10\n         L     R13,4(,R13)\n         MVC   16(4,R13),=F'0'      Load Maximum Return Code\n         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n* --------------------------------------------------------- *\n* --------------------------------------------------------- *\n* ---      S U B R O U T I N E S                        --- *\n* --------------------------------------------------------- *\nFLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently\n*\n         HEX   LINE+10,4,FLDSCARD\n         HEX   LINE+20,4,FLDECARD\n         HEX   LINE+30,4,FLDOFFST\n         HEX   LINE+40,4,FLDBYTES\n         HEX   LINE+50,4,FLDBYTOT\n         HEX   LINE+60,4,FLDBYMVD\n         HEX   LINE+70,4,FLDBUFFR\n         HEX   LINE+80,4,FLDBSTRT\n         HEX   LINE+90,7,FLDOUTCT\n         HEX   LINE+106,1,FLDREADF\n         ST    R10,SAVER10          Save register for safety\n         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller\n         PUT   (10),LINE            PUT the print line\n         MVC   LINE,LINE-1\n         L     R10,SAVER10          Restore R10\n         BR    R9\n* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *\nFLDBLOCK CSECT\nFLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK\n*                           ------ ---- ------- -----\nFLDSCARD DC    F'0'         Start address of 80-byte card\nFLDECARD DC    F'0'         End address of 80-byte card\nFLDOFFST DC    F'0'         OFFSET of data in the card\nFLDBYTES DC    F'0'         Number of bytes to be folded now\nFLDBYTOT DC    F'0'         Batch total of bytes left to move\nFLDBYMVD DC    F'0'         Number of bytes folded now\nFLDBUFFR DC    F'0'         Current data start address\nFLDBSTRT DC    F'0'         Original start data address\nFLDOUTCT DC    PL7'0'       Number of PUTs for FAKEOUT records\nFLDREADF DC    X'00'        This run is \"READ ONLY\"  ?\n*              X'01'        Yes, read only.\nFLDLENTH EQU   *-FLDAREA\n*\nFOLDEM   CSECT\nWORKAREA DS    CL80                 Card image work area\n         DC    CL4' '               Padding\n         DC    C' '\nLINE     DC    CL133' '             Output line\n         DC    C' '\nLINE2    DC    CL133' '             Second output line if needed\n*\nFF       EQU   X'FF'\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEX      DS    0H\n         MVC   1(1,R15),0(R1)        Move byte\n         UNPK  0(3,R15),1(2,R15)     Unpack\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)           Increment output pointer\n         LA    R1,1(,R1)             Increment input pointer\n         BCT   R0,HEX                Decrement length, then loop\n         MVI   0(R15),C' '           Blank the trailing byte\n         BR    R4                    Return to caller\nHEXTAB   DC    C'0123456789ABCDEF'   Translate table\n         SPACE\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nHEXSAVE  DS    3F                    Register save for HEX macro\nSAVER04  DS    H                     Register save for HEX macro\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nZEROCARD DC    80X'30'\nSAVEBEGO DC    F'0'                 Save beg address of card output\nSAVEBEGC DC    F'0'                 Save beg address of card\nSAVEENDC DC    F'0'                 Save end address of card\nSAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address\nHYPOENDC DC    F'0'                 Hypothetical end address after card\nHYPOENDB DC    F'0'                 Calculated end of buffer address\nSYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB\nFAKEOUTV DC    V(FAKEOUT)           Address of FAKEOUT DCB\nSYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here\nFKOUTDCB DC    F'0'                 FAKEOUT DCB address stored here\nSAVER10  DC    F'0'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT533/FILE533.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT533", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}