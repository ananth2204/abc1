{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011921000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1469650, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE394.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1469650, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1469650, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE394.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x19\\x06'", "DS1TRBAL": "b'\\x9a\\xfe'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xd4\\x00\\t\\x02\\xd6\\x00\\x04\\x00\\x1a'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x056\\x0f\\x01\\x056\\x0f\\x19$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-12-26T00:00:00", "modifydate": "2005-12-26T19:24:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-470"}, "text": "REGULAR CBT TAPE - VERSION 470    FILE:  394\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT470.FILE394\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 40 MEMBERS COUNTED; CUMULATIVE SIZE IS 13,773 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/26/05    19:24:47    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00S\\x00\\x99%\\x0f\\x01\\x054/\\x11Q\\x00\\x0c\\x00Q\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1999-09-07T00:00:00", "modifydate": "2005-12-08T11:51:53", "lines": 12, "newlines": 81, "modlines": 0, "user": "SYMP118"}, "text": "Please see @INDEX member + comments at the begining of every source\nmodule. Every utility is documented in the source code.\nSome utilities/subroutines have separate documentation member (name\nbeginning with $).\n\nThe original author of all programs in this file is Janek Jakubek,\nexcept of macros SUBENT and SUBRET, which I cannot remember the origin.\nAlso, MXIVSTOR is a modified version of Mark Zelden's REXXSTOR.\n\nI live presently in Toronto, Ontario and can be contacted via eMail:\n\nJan.Jakubek@CGI.COM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00I\\x01\\x01\\x15\\x1f\\x01\\x054/\\x119\\x00[\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2001-05-31T00:00:00", "modifydate": "2005-12-08T11:39:49", "lines": 91, "newlines": 14, "modlines": 0, "user": "SYMP118"}, "text": "              .--------------------------------.\n              |  CBT TAPE - Index of file 394  |\n              |  From: Jan (Janek) Jakubek     |\n              '--------------------------------'\n\nKSDSPACE  VSAM KSDS space use mapping utility (reports on space\n          used by data records, free space, # of index records per\n          IX level, low/high key per control area, unused space\n          due to IX record too short).\n\nKSDSPACO  Older version of KSDSPACE. Should run on unsupported\n          levels of DFSMS (1.2 or less). It does not work with\n          Extended Format/Addressability KSDS.\n\nOFDVBFB   Converts sequential dataset from RECFM=VB to RECFM=FB\n\nLLAUPDTX  Synchronous LLA update routine (using LLACOPY macro).\n          One member per step (specified in PARM) gets refreshed.\n\nLLAUPDTS  Synchronous LLA update routine (using LLACOPY macro).\n          Multiple members (specified in SYSIN) get refreshed.\n\nDEFNVS    Generates IDCAMS DEFINE NONVSAM statements for a DASD\n          volume.\n\nDELNVS    Generates IDCAMS DELETE NSCR statements for a DASD\n          volume.\n\nIEFUSI    A sample, configurable (working in a real production\n          environment) SMF USI exit.\n\nLDAPROBE  LDAP server probe REXX exec.\nLDAPROBJ  JCL (could run as an STC) to run LDAPROBE.\n\nMXIVSTOR  Dispalys virtual storage usage of an address space (REXX\n          exec). Requires/ calls MXI to retrieve foreign address\n          space LDA/ASCB/RAX/RAXMEMLIMIT.  This is essentially a\n          modified Mark Zelden's REXXSTOR, except that input data\n          from a foreign AS are retrieved via MXI.\n\nTI        Displays RMM tape dataset info for an ISPF 3.4 dataset\n          list entry using RMM LISTDATASET subcommand (REXX exec).\n\nTV        Displays RMM tape volume info for an ISPF 3.4\n          dataset list entry using RMM VOLUME subcommand (clist).\n\nMAKENSWP  Makes all address spaces with same name nonswappable.\n          This can be useful for Unix applications (in our case\n          CTG). Does this via MXI MAKE command. This is a REXX\n          exec.\n\nJJDGEN    Janek's data records generation utility. Need a few\n          records for testing of an application ? Try this !\n\nWTOH      Write Message to Operator routine (highlighted\n          messages).\n\n$TABLES   See $TABLES doc member for description of general\n          purpose binary search table processing routines/\n          package.  This may be of interest for application\n          programmers (writing applications in PL/I, COBOL,\n          Assembler).\n\nHALVE     Binary search tables processing subroutine\n\nHLVTD     HALVE related macro: table definition\n\nJJTBGEN   Create table to be searched/ processed by HALVE\n          subroutine.\n\nTBLACCSS  Tables access interface routine for COBOL programs\n          (HALVE related).\n\nKSDSINIT  New KSDS File Initialization Routine\n\nJJPDSD    Deletes all members of a PDS dataset. It is slow/ poor\n          performer with PDS datasets, but it works (better)\n          with PDSE.\n\nOFDASVER Checks if specified address space/s is/are up.\n         If all specified address spaces are up - ends with return\n         code of zero, otherwise ends with return code of 16.\n         Possible use of this program:\n         .Verify if a CICS or DBCOMM/DB region is up in the first\n         step of a job. If yes, continue the job, otherwise\n         terminate it.\n         .Verify if all required STCs are up after IPL or\n         periodically throughout a day. If not - issue a warning\n         message.\n\nMacros    SUBRET, SUBENT, TSTAMP, HLVTD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CPYRGHT": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x025?\\x01\\x025?\\x14\\x18\\x00\\x05\\x00\\x05\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-12-19T00:00:00", "modifydate": "2002-12-19T14:18:05", "lines": 5, "newlines": 5, "modlines": 0, "user": "SYMP118"}, "text": "*\n* \"COPYRIGHT (C) 2002 by Jan (Janek) Jakubek.\n* ALL RIGHTS  RESERVED EXCEPT:  PARTICULAR LICENSE IS GRANTED TO\n* DISTRIBUTE THIS PROGRAM FREE OF CHARGE, BUT IT MUST NOT BE SOLD.\"\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$HALVE": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00U\\x00\\x83\\x01\\x0f\\x01\\x01$\\x9f\\x14&\\x00\\x82\\x00%\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1983-01-10T00:00:00", "modifydate": "2001-09-06T14:26:55", "lines": 130, "newlines": 37, "modlines": 0, "user": "SYMP118"}, "text": "\nGENERALIZED BINARY SEARCH TECHNIQUE TABLES PROCESSING ROUTINE\n-------------------------------------------------------------\n\nSpecifications:\n\nModule name: HALVE\n\nAttributes : REENTERABLE\n\nPrivate macros: HLVTD - generates Table Definition control block\n\nFunction = see below\n\n   The routine can be used to access tables having elements sorted in\na unique key sequence.  HALVE searches a table for specified key and\nreturns the address and position of a table element containing such a\nkey.  It allows adding of new keys to the table (table expansion) so\nthat it can be used for sorting or dynamic creation of sorted tables.\nIf table is specified large enough to accomodate new elements and user\nsupplies key not existing in the table - HALVE positions new key in the\ntable, displaces accordingly the other elements and returns address and\nposition of the new element. User should then initialyse it with\ndata.\n   Table is defined by the control block called TABLE DEFINITION.  User\ncan specify so called COMPARE exit routine, which performs comparison\nof input key with keys of table elements. This exit makes possible\nprocessing of tables with complex key structures and with elements of\nvariable length.\n\nCALL arguments list format:\n\n   CALL HALVE, ( TDEF, INPUT_KEY, IF_FOUND_INDICATOR )\n\n   TDEF        - table definition ( see TDEF DSECT for format )\n   INPUT_KEY   - key to be located in the table\n   INDICATOR   - BIT(1) (PL/I attr)   ='1'B - INPUT_KEY found in the\n                (X'80' in Assembler)          table\n                                      ='0'B - INPUT_KEY not found\n   INPUT-KEY           - input argument\n   IF_FOUND_INDICATOR  - output argument\n   TDEF                - input/output argument\n\nTABLE DEFINITION control block layout:\n\nTDEF     DSECT\nSA       DS    20A              save area for HALVE (reenterability)\nFEA      DS    A                address of the first elem.of table\nLEN      DS    H                length of a table element\nOFFS     DS    H                offset of two adjacent table elements\nKL       DS    F                length of table character key\n         ORG   KL                  or\nCMPRE    DS    A                address of COMPARE exit entry point\nNM       DS    F                max.no.of elements in the table\nNA       DS    F                current no.of active elem.in the table\nEADR     DS    A                located elem.addr. returned by HALVE\nEPOS     DS    F                position in the table of located elem.\n                                or zero if table cannot be expanded\n\nHere is the purpose of particular fields of TDEF:\n.SA - save area for HALVE. It is required because HALVE may call COMPARE\n      exit.\n.FEA - table itself and TDEF do not have to be in contiguous storage.\n      Multiple tasks can access the same table through one TDEF per\n      task (however a table used in multitasking environment should\n      not be expandable nor elements should be modified).\n.LEN - required if table can be expanded to perform displacement of\n      elements.\n.OFFS - required for binary search. Diferentiation between LEN and OFFS\n      makes possible processing of single vectors of multidimensional\n      tables.\n.KL - if key is character, has ascending sequence in the table, is\n      located in front of the table element, its length is <= 256, then\n      COMPARE exit does not have to be provided to process the table.\n      HALVE uses it own compare code during binary search.\n.CMPRE - COMPARE exit address if required. Has to be provided if key\n      does not satisfy the above conditions. Makes posible binary\n      search of a table with variable length elements.\n      KL and CMPRE are the same field. HALVE considers it to be the KL\n      if its binary value is <= 256. Otherwise it treats it as address\n      of COMPARE exit.\n.NM - required if a table is to be expandable. It indicates how much\n      storage has been allocated for the table. If NM = NA, table can\n      not be expanded (no new elements can be added to the table).\n.NA - specifies how many elements there are currently in the table.\n      Tables created by JJTBGEN have always   NM = NA.\n.EADR - address (pointer to) of table element located by HALVE in\n      the table.\n.EPOS - position (element number) of element located by HALVE. It is\n      set to zero if INPUT_KEY has not been found in the table and\n      table cannot be expanded to accomodate the new element (NM=NA).\n      So if INDICATOR is set to OFF (zero) and EPOS is not zero - EADR\n      points to a new element in the table. It is initialyzed with\n      binary zeros by HALVE and has to filled in with data by the caller\n      of HALVE.\n\nHALVE does not perform and validity checks on TDEF fields because it\nwould adversely affect performance of tables access. It is the user's\nresponsibility to ensure validity of TDEF. Program checks or loops are\nlikely to occur if TDEF is not valid. User has also to ensure that\ntable elements are in the right key sequence and that keys are unique.\n\nCOMPARE exit routine.\n--------------------\n   If table's key does not satisfy conditions as in KL field - user has\nto provide his own exit to be used by HALVE. Exit routine has to be\nwritten in ASSEMBLER (performance reasons).  Binary search locates mid\nelement of a table (or current table section) and compares its key with\ninput key provided in the CALL of HALVE. If they are equal - search is\nterminated. If input key is lower than mid element's key, proceeds to\nsearch first part of the table as delimited by the mid element.\nOtherwise search continues within second part of the table. HIGHER,\nEQUAL, LOWER terms reflect relative order of keys in the table, their\nrelative location within the table. Interface to the COMPARE exit is\nthe following (on input):\n  R13 - save area address\n  R14 - return address\n  R15 - entry point address\n  R5  - input key address (key presented to HALVE)\n  R11 - table mid element address\nOn output R15 must have one of the return codes:\n  0  if keys are equal\n  4  if input key is HIGHER than mid element's key\n  8  if input key is LOWER  than mid element's key\nContents of any other register than R15 can not be modified by the\nexit (if necessary, registers have to be saved and restored).\n\n\nWritten by: Janek JAKUBEK, OGL\n            March-April 1986\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$JJDGEN": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00E\\x00\\x84\\x11\\x8f\\x01\\x01$\\x9f\\x14(\\x00\\x95\\x00\\x8d\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1984-04-27T00:00:00", "modifydate": "2001-09-06T14:28:45", "lines": 149, "newlines": 141, "modlines": 0, "user": "SYMP118"}, "text": "\nTest Data Generation Routine\n----------------------------\n\nSpecifications  :\n\nModule name     : JJDGEN\n\nAttributes      : NONE\n\nLoad library    : SYS1.UTIL.LINKLIB\n\nStatus          : TEST  ( this utility is still under development )\n\nPrivate macros  : SUBENT - entry into internal subroutine\n                  SUBRET - exit from an internal subroutine\n\nFunction = see below\n\n    This routine generates test data for program testing purposes.\n Output file can have F,V,U record formats. RECFM, LRECL and BLKSIZE\n have to be specified in JCL for output file.  Input is on 80 bytes\n records and data are specified in assembler constants like format.\n Record data can be specified in columns 1 to 71. Col 72 is reserved for\n record continuation mark. If col 72 is different from blank it means\n that record definition is continued on next input card. If length of\n specified data is less than LRECL ( in case of F type records ) ,\n missing part is padded with blanks or pad character specified in PARM.\n If alignment takes place within a record (for type H,F,E,D,L consts),\n non used bytes are padded also with pad character.  Input record which\n does not have continuation mark is considered as the last source of\n data for one output record. Next input record after it is considered as\n begining of next output record specification.\n\n The following type of constants can be specified while defining\n a data record:\n              C - character\n              X - hexadecimal\n              P - packed decimal\n              Z - zoned decimal ( signed )\n              H - binary halfword ( signed )\n              F - binary fullword ( signed )\n              A - binary, unsigned\n              L - extended floating point\n              D - long floating point\n              E - short floating point\n\n Constant specification consists of four subfields:\n\n Duplication Factor, Type, Modifiers, Nominal Value(s).\n\n Detailed description of the constant subfields can be found in\n Assembler Language manual.\n\n Nominal Value(s) are enclosed in quotes (C,X,P,Z,H,F,E,D,L type consts)\n or in parenthesis (A type constants).\n\n    Duplication Factor and Modifiers like in assembler constants are\n optional. The only allowed Modifier from Assembler Language is LENGTH.\n Unlike in Assembler LENGTH is not permitted in H,F,E,D,L type consts.\n Lenght modifier for type A constants has to be in 1 to 4 range , for\n type Z from 1 to 15, for type P from 1 to 8.\n Multiple Nominal Values are permitted only in X,P,Z,H,F,A,E,D,L type of\n constants ( Multiple Nominal Values are separated by a comma ). SCALE\n and EXPONENT Modifiers are not permited. Numeric values have to be\n coded as decimal self defining terms. No expressions are allowed.\n Numeric constants can have up to 15 digits specified ( significant\n digits in case of E,D,L constants). Bit-length specification is not\n allowed.  Rules of padding and truncation of constants and of implicit\n length are the same as in Assembler Language.\n    In addition to LENGTH Modifier, OFFSET Modifier ( \"O\" ) - not known\n in Assembler, can be specified. If present - it indicates offset in\n generated record at which this constant should start.  This can make\n easier creation of records which contain only data used by the tested\n program. Sample constant specification with OFFSET Modifier is:\n XL13O55'0123456789ABCDEF'   - length of this data is 13 bytes and they\n will be put at offset 55 in output record.  Overlaying of earlier\n specified data through OFFSET specification is permitted but it does\n not change Available Byte Count (ABC) in output record unless offset\n of last byte of this constant is greater than ABC. ABC is an offset of\n next byte in output record past last specified constant. It points to\n first byte in not yet defined part of the record.  If offset is\n greater than ABC - undefined part of the record will be filled with\n pad character and ABC will be changed to point to the next byte after\n specified constant.\n    Constants on input record are separated by one or more blanks.\n Specification of a constant can be continued on the next input record\n starting in column 1.\n    Specification of constants can be intermixed with comments for\n documentation purposes. Comment specification begins with \"/*\" and ends\n with \"*/\"   e.g.  /* THIS IS COMMENT */  .  Input record can contain\n comment(s) only.\n    In case of V and U type of output records length of every generated\n record is equal to last value of \"ABC\".\n\n INPUT to the routine:\n\n      . SYSIN  - Input data\n\n OUTPUT:\n\n      . SYSUT1   - Output file. DCB (RECFM,LRECL,BLKSIZE) has to\n                   be specified in JCL.\n      . SYSPRINT - messages and printout of input data\n\n PARM format:\n\n      PAD=C|X\"nn\",ALIGN  ,LINECNT=nn\n                  NOALIGN\n\n \"PAD\" specifies padding character either in character or hexadecimal\n format. Padding takes place if length of specified data is less than\n LRECL for F type records or if Offset Modifiers are used causing parts\n of the record to be left undefined.  Default is blank ( X'40' ).\n\n \"ALIGN\" and \"NOALIGN\" are mutually exclusive parms and specify if H,F,E\n D,L type constants are to be aligned on the proper boundaries. JJDGEN\n assumes that generated record begins on a doubleword boundary. Default\n is \"NOALIGN\".  If alignment takes place - unused bytes are padded with\n \"PAD\" character.\n\n \"LINECNT\" specifies page line count for SYSPRINT. Default is 64.\n Specification of a large value will eliminate paging at all.\n\nSample JCL to run the program :\n\n//TDGEN     EXEC PGM=JJDGEN,PARM='PAD=X\"00\",NOALIGN'\n//STEPLIB     DD DSN=SYS1.UTIL.LINKLIB,DISP=SHR\n//SYSUT1      DD UNIT=DISK,SPACE=(TRK,(1,1)),DSN=&&TEST.DATA.FILE,\n//               DCB=(RECFM=FB,LRECL=100,BLKSIZE=4000),DISP=(,PASS)\n//SYSPRINT    DD SYSOUT=*\n//SYSIN       DD *\nCL8'KEY1' PL4'-286.45' 5X'18' 10C'XXX' H'28' F'123456'     AL1(5)\nCL8'KEY2' PL4'+286.45' 5X'19' 10C'YYY' H'15' F'234567'     AL1(6)\nCL8'KEY3' PL4'135.24'    5X'1A' 10C'ZZZ' H'10' F'-345678'  AL2(6)\nCL8'KEY4' PL4'200.00'    5X'1B' 10C'AAA' H'9'  F'+4567890' AL3(6)\nCL8'KEY5' PL4'1000'      5X'28' 10C'BBB' H'50' F'1'        A(6)\nCL8'KEY6' PL4'-2000'     5X'38' 10C'CCC' H'99' F'2'        AL1(255)\nCL8'KEY7' PL4'-1000'     D'1.12345E-10' E'583E5' L'0.1' ZL5'-1'\n8X'FF' /* END-OF-FILE RECORD */                            AL1O55(111)\n\n\nWritten by: Janek JAKUBEK, OGL\n                 July-August 1983\n\nChange activity:\n       Nov-Dec 1984: Type E, D and L constants added.\n       Dec.    1984: Type Z constant added.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$JJTBGEN": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x004\\x00\\x86\\x07?\\x01\\x01$\\x9f\\x14\\x18\\x00\\x8f\\x00\\x86\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-14T00:00:00", "modifydate": "2001-09-06T14:18:34", "lines": 143, "newlines": 134, "modlines": 0, "user": "SYMP118"}, "text": "\nCREATE A TABLE IN THE LOAD MODULE FORMAT ROUTINE\n------------------------------------------------\n\nSpecifications:\n\nModule name: JJTBGEN\n\nAttributes : NONE\n\nPrivate macros : SUBENT - entry into an internal subroutine\n                 SUBRET - exit from an internal subroutine\n\nFunction = see below\n\n   This routine creates a table which can be processed by HALVE\nbinary search subroutine. Resulting table, after assembly an link\nedit, has a load module format.\n\n INPUT to the routine:\n\n   . SYSIN    - control data set (control stmts defining the table)\n   . TBLIN    - sequential file from which table will be created. One\n                record is converted into one table element. Table\n                elements are put in the same sequence as records in\n                TBLIN.\n\n OUTPUT:\n\n   . SYSUT1   - Output file. Contains 80 bytes records with an\n                assembler CSECT and constants containing description\n                of the table and table elements. It has to be then\n                assembled and linkedited.\n   . SYSPRINT - message data set\n\nCompiled and link-edited table can be loaded into storage using\nLOAD macro or any high level language equivalent and then accessed\nusing HALVE table binary search subroutine. The LOAD macro issued for\na table returns address of TABLE DEFINITION control block (it is\nin front of the CSECT). Table itself follows the TDEF.\n\n\nSYSIN control statements:\n\n SYNTAX: can be specified in columns 1 to 72. No continuation is\n allowed. Control stmt consists of a keyword separated by one or\n more blanks from an operand. The following control stmts can be\n specified:\n\n .NAME - optional, specifies a name of the table CSECT. It is\n   recommended that CSECT name is the same as load module name. If they\n   are different - CSECT name has to be the entry point of the load\n   module.\n\n .EXTRACT - optional, specifies data to be extracted from one input\n   record to create one table element. Operand consists of pairs of\n   numbers being respectively POSITION and LENGTH of the data to be\n   extracted. More then one EXTRACT stmt can be specified. Table\n   element is assembled from data specified in all EXTRACT stmts\n   in the same sequence as specified in SYSIN. If no EXTRACT is\n   specified - one TBLIN record is converted into one table element.\n   If TBLIN contains V or U format records - EXTRACT has to be\n   specified because table elements have to be of equal length.\n\n .KEYLEN - length of the key of the table element. It can be\n   specified if key is located in the front of the table element and\n   table is sorted in character ascending sequence. If specified,\n   JJTBGEN checks if input file is correctly sorted. KEYLEN is\n   mutually exclusive with COMPARE stmt. Either KEYLEN or\n   COMPARE has to be specified. Length of the key has to be:\n   1 <= KEYLEN <= 256.\n\n .COMPARE - entry point name of a COMPARE exit routine to be used by\n   the HALVE subroutine. If table's key does not satisfy conditions as\n   stated in KEYLEN discussion above - user has to provide his own\n   exit to be used by HALVE. Exit routine has to be written in\n   ASSEMBLER and linkedited with the table as one load module. Such\n   exit makes possible creation of tables with variable length\n   elements which can be processed using binary search technique.\n   Binary search locates mid element of a table (or current table\n   section) and compares its key with input key provided in the CALL\n   of HALVE. If they are equal - search is terminated. If input key\n   is lower  than mid element's key, proceeds to search first part\n   of the table as delimited by the mid element. Otherwise search\n   continues within second part of the table. HIGHER, EQUAL,\n   LOWER terms reflect relative order of keys in the table. Their\n   relative location within the table. Interface to the COMPARE exit\n   is the following (on input):\n     R13 - save area address\n     R14 - return address\n     R15 - entry point address\n     R5  - input key address (key presented to HALVE)\n     R11 - table mid element address\n   On output R15 must have one of the return codes:\n     0  if keys are equal\n     4  if input key is HIGHER than mid element's key\n     8  if input key is LOWER  than mid element's key\n   Contents of any other register than R15 can not be modified by the\n   exit.\n\nFormat of SYSIN control statements:\n\n   NAME name         - name of the table CSECT\n   KEYLEN value      - length of the key\n   COMPARE name      - entry point name of COMPARE exit\n   EXTRACT (p1,l1),(p2,p2),(p3,l3),.....\n                     - pn, ln  are position of data in the TBLIN\n                       record and length of data respectively.\n                       If there is no enough of room on the SYSIN\n                       record to specify all data to be included in\n                       a table element - another EXTRACT stmt should\n                       be specified in the next SYSIN record.\n\nControl stmts can be specified in any sequence in the SYSIN (however\nEXTRACT sequence determines the contents of a table element).\n\nSample JCL to run the program :\n\n//TBGEN   EXEC PGM=JJTBGEN\n//STEPLIB   DD DSN=SYS1.UTIL.LINKLIB,DISP=SHR\n//TBLIN     DD DSN=OGL.TABLE(TBLXYZ),DISP=SHR\n//TBOUT     DD UNIT=VIO,DSN=&&TABLE,SPACE=(4080,(10,10)),\n//             DISP=(,PASS),DCB=BLKSIZE=4080\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\nNAME TBLXYZ\nEXTRACT (1,50),(61,20)\nEXTRACT (51,10)\nKEYLEN 12\n/*\n//        EXEC ASMFCL\n//ASM.SYSIN DD DSN=&&TABLE,DISP=(OLD,DELETE)\n//LKED.SYSLMOD DD DSN=SYS2.TBLINK(TBLXYZ),DISP=SHR\n\nEnd of the sample JCL\n\n\nWritten by: Janek JAKUBEK, OGL\n               March     1986\n\nChange activity:\n       NONE\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$KSDSINI": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00@\\x00\\x85\\x11o\\x01\\x01$\\x9f\\x14)\\x00>\\x001\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1985-04-26T00:00:00", "modifydate": "2001-09-06T14:29:40", "lines": 62, "newlines": 49, "modlines": 0, "user": "SYMP118"}, "text": "\nKSDS File Initialization Routine\n--------------------------------\n\nSpecifications:\n\nModule name: KSDSINIT\n\nAttributes : STANDARD\n\nFunction = see below\n\n   The routine initialyzes a newly defined VSAM KSDS file through the\nfollowing sequence of operations:\n .OPEN for output sequential processing\n .LOAD a dummy record (record, including key, is filled with blanks)\n .CLOSE the file\n .Re-OPEN the file for direct processing\n .DELETE the dummy record (GET for update and ERASE)\n .CLOSE the file\nIf the input file was previously loaded with a dummy (all blanks)\nrecord - such a record will also be deleted.\nAfter the run of this program - VSAM KSDS file can be opened for\nINPUT/OUTPUT processing by an application program.\nDDNAME of input KSDS data set is KSDS. Error messages are issued to\nSYSPRINT file.\n   When input KSDS cluster has AIXs with UPGRADE attribute,\nthe following procedure has to be followed to initialyze base cluster\nand paths:\n 1.DEFINE base cluster\n 2.LOAD base cluster with a dummy record (all blanks including key)\n   (you can use DATAGEN utility to generate a dummy record and IDCAMS'\n   REPRO to load the cluster).\n 3.DEFINE all UPGRADE AIXs\n 4.DEFINE all PATHs\n 5.BUILD all AIXs\n 6.Run KSDSINIT with base cluster as input KSDS file\n\nReturn codes from the program:\n\n    0 - Normal successful completion.\n   16 - Error. Check messages in SYSPRINT and/or system log.\n\n\n\nThe following JCL procedure has been cataloged to run this program :\n\n   //KSDSINIT PROC\n   //KSDSINIT EXEC PGM=KSDSINIT\n   //STEPLIB    DD DSN=SYS1.UTIL.LINKLIB,DISP=SHR\n   //KSDS       DD DSN=&KSDS,DISP=OLD\n   //SYSPRINT   DD SYSOUT=*\n\n   \"KSDS\" file has to be previously defined in \"CAT\" catalogue using\n   IDCAMS.\n\nWritten by: Janek JAKUBEK, OGL\n              April 1985\n\nChange activity:\n                  NONE\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$TABLES": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00W\\x00\\x86\\x08O\\x01\\x01$\\x9f\\x141\\x000\\x00-\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1986-03-25T00:00:00", "modifydate": "2001-09-06T14:31:57", "lines": 48, "newlines": 45, "modlines": 0, "user": "SYMP118"}, "text": "\nTABLES HANDLING SUBROUTINS\n--------------------------\n\n   In every data processing installation there are very small data sets\nwhich are frequently used and application programs access them as\ntables rather than access method files to improve performance and\nsimplify programs logic.  Very often such data are kept as members of\ntext libraries or card decks and manualy updated. Sometimes they are\neven hard coded in the application programs. Common practice of using\nsuch data tables is: - program using a table defines the file, in its\ninitialization logic reads the file and creates an in-storage table.\nMain logic of the program accesses the in-storage table, usually\nthrough a sequential search.\n   Subroutines and a utility have been developed to facilitate\nprocessing of tables. The following has been developed and are\navailable for use:\n\nHALVE     - generalized binary search tables processing subroutine\nHLVTD     - Assembler macro, generates TABLE DEFINITION control block\nTBLACCSS  - tables access interface subroutine for COBOL programs\nJJTBGEN   - utility, converts a file into a table in the load module\n            format\n\nThe purpose of HALVE subroutine and accompaning JJTBGEN utility is to\nimprove performance of accessing the tables. Also the programming\neffort can likely be reduced and programs maintain-ability improved.\nPerformance improvement comes from the fact that HALVE employs a very\nefficient binary search to retrieve a table element.  JJTBGEN in turn\nconverts a file into a table in the load module format.  As the result\nthe programming effort of initialization of a table is reduced to a\nsimple LOAD of the table into storage. Farther gains can be realized by\nsetting up standard definitions of all existing tables in either macro\nor copy-book libraries.\nTables created by JJTBGEN can essentialy be used in the single task\nenvironment (only one task at a time can use the table). The reason\nfor that is that HALVE modifies TABLE DEFINITION control block (see\nHALVE writeup). However, TABLE DEFINITION can be copied into a task\nacquired storage and thus overcoming the limitation.\nHALVE and TABLE DEFINITION have been designed to be used in either\nASSEMBLER or PL/1 programs (TABLE DEFINITION has address (pointer) type\nconstants). COBOL programs can access such tables through TBLACCSS\ninterface subroutine. Refer to individual routines writeups for farther\ninformation.\n\n\nWritten by: Janek JAKUBEK, OGL\n            March-April 1986\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$TBLACCS": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00R\\x00\\x86\\t\\x0f\\x01\\x01$\\x9f\\x145\\x00^\\x007\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-03-31T00:00:00", "modifydate": "2001-09-06T14:35:52", "lines": 94, "newlines": 55, "modlines": 0, "user": "SYMP118"}, "text": "\nTables Access Interface Routine for COBOL Programs\n--------------------------------------------------\n\nSpecifications:\n\nModule name: TBLACCSS\n\nFunction = see below\n\n    The subroutine allows accessing of tables created by JJTBGEN\n utility in COBOL application programs. It loads a table into storage\n and accesses its elements using HALVE binary search subroutine.\n Refer to JJTBGEN and HALVE writeups for more information about\n the tables. HALVE subroutine cannot be used directly in a COBOL\n program because it uses address (pointer) type variables not available\n in COBOL (*1).\n\nCALL statement format (in COBOL):\n\n CALL 'TBLACCSS' USING TABLE-NAME TABLE-ELEM ACCESS-TYPE RET-CODE.\n\n TABLE-NAME  - Group data item. Contains name of a table (load module\n               name) plus two fields reserved for TBLACCSS use only\n               (see sample below).\n TABLE-ELEM  - Group data item. On output it contains the requested\n               element of a table (if found). On input it has to have\n               the key of an element to be looked for.\n ACCESS-TYPE - one byte character defining type of request:\n               G - get table element.\n               I - insert. TABLE-ELEM has to contain element to be\n                   inserted (added to) into the table.\n               R - replace. TABLE-ELEM has to contain a replacement\n                   of a table element.\n RET-CODE    - PIC 9(9) COMP (4 bytes binary) elementary data item.\n               On output it contains a return code depending on\n               ACCESS-TYPE:\n               for G : 0 - requested element found in the table and\n                           returned to the caller.\n                       4 - requested element not found in the table.\n               for I : 0 - requested element inserted into the table.\n                       4 - element with specified key already exists\n                           in the table.\n                       8 - table already full. No new elements can be\n                           added.\n               for R : 0 - requested element found in the table and\n                           replaced.\n                       4 - requested element not found in the table and\n                           therefore could not be replaced.\n               If ACCESS-TYPE does not specify any of the above -\n               RET-CODE = 16 is returned and table isn't accessed at\n               all.\n\nSample coding in COBOL:\n\n...\n01 TABLE-NAME.\n   02 NAME           PIC X(8)  VALUE \"STORETBL\".\n   02 TABLE-POINTER  PIC 9(9)  COMP VALUE ZERO.\n   02 HALVE-POINTER  PIC 9(9)  COMP VALUE ZERO.\n...\n01 TABLE-ELEM.\n   02 STORE-NUMBER   PIC X(3).\n   02 STORE-CODE     PIC X.\n   02 STORE-NAME     PIC X(20).\n...\n77 ACCESS-TYPE       PIC X.\n77 RET-CODE          PIC 9(9)  COMP.\n...\nMOVE \"G\" TO ACCESS-TYPE.\nMOVE STORE-NUMBER OF ORDER-RECORD  TO  STORE-NUMBER OF TABLE-ELEM.\nCALL \"TBLACCSS\" USING TABLE-NAME TABLE-ELEM ACCESS-TYPE RET-CODE.\nIF RET-CODE IS NOT ZERO ...........\n...\n\nEnd of sample.\n\nAny data names can be chosen by the programmer. For standardization\npurposes it is recomended that TABLE-NAME and TABLE-ELEM are predefined\nas copybooks for each table in the installation.  TABLE-POINTER and\nHALVE-POINTER are reserved for TBLACCSS use only. It stores there the\naddresses of the table and HALVE which are loaded into storage during\nfirst call. TBLACCSS can be called with first argument (TABLE-NAME)\nonly. TBLACCSS understands such a call as a request to either LOAD or\nDELETE from storage the table and HALVE subroutine. If TABLE-POINTER\nis zero during such a call - table and HALVE are loaded into storage\nand their addresses saved, otherwise they are deleted from storage\nand TABLE-POINTER and HALVE-POINTER initialyzed to zero.\n\n\nWritten by: Janek JAKUBEK, OGL\n            March-April 1986\n\n(*1) - This may no longer be true with newer than OS/VS COBOL compilers.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$WTOH": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00%\\x00\\x85\\x03o\\x01\\x01$\\x9f\\x146\\x004\\x003\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1985-02-05T00:00:00", "modifydate": "2001-09-06T14:36:25", "lines": 52, "newlines": 51, "modlines": 0, "user": "SYMP118"}, "text": "Write Message to Operator routine ( highlighted messages )\n----------------------------------------------------------\n\nModule name: WTOH\n\nAttributes : REUSABLE\n\nFunction = see below\n\n    This routine writes message(s) to the operator. Message is\n highlighted and will stay on the console's screen until deleted by\n the operator. The program is intended to be used to inform\n operators about an important condition requiring their immediate\n attention.\n    Message text can be passed either in PARM field or in SYSIN file.\n SYSIN file has to have 80 bytes records. Contents of columns 1-72 of\n each SYSIN record is written as separate \"WTO\" message. The routine\n will display up to max of 10 records from SYSIN in order to avoid\n flooding of the operator console with messages from problem programs.\n Both PARM and SYSIN inputs are optional. If both are specified - text\n from PARM will be displayed as the first message.\n\n   Each WTO message has job name prefixed to it.\n\n   This routine can be either invoked from JCL or dynamically through\n means of LINK or LOAD/CALL macros. Call format is the following :\n\n  CALL WTOH,(parm {,ddname}),VL\n\n       \"parm\" argument has to have the same format as OS operating\n              system standard.\n       \"ddname\" argument is optional and user can specify in it\n              ddname of SYSIN message input file. Specifying blank\n              \"ddname\" prevents WTOH from processing message file\n              at all.\n\nSample execution from JCL :\n\n  //WTOH   PROC\n  //WTOH   EXEC PGM=WTOH,PARM='&MSG.'\n  //       PEND\n  //       EXEC WTOH,MSG='UPDATE OF \"PRODUCE\" MASTER FILE FAILED'\n  //SYSIN    DD *\n  IDENTIFY AND CORRECT THE ERRORS AND DO THE RERUN PROCEDURE\n  /*\n\nWritten by: Janek JAKUBEK, OGL\n            February  1985\n\nChange activity:\n                NONE\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE394": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x056\\x0f\\x01\\x056\\x0f\\x19$\\x00m\\x00m\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-12-26T00:00:00", "modifydate": "2005-12-26T19:24:00", "lines": 109, "newlines": 109, "modlines": 0, "user": "CBT-470"}, "text": "//***FILE 394 is from Jan Jakubek of Toronto, Ontario, Canada.        * FILE 394\n//*                                                                   * FILE 394\n//*               .--------------------------------.                  * FILE 394\n//*               |  CBT TAPE - Index of file 394  |                  * FILE 394\n//*               |  From: Jan (Janek) Jakubek     |                  * FILE 394\n//*               '--------------------------------'                  * FILE 394\n//*                                                                   * FILE 394\n//*    KSDSPACE  VSAM KSDS space use mapping utility (reports on      * FILE 394\n//*              space used by data records, free space, # of index   * FILE 394\n//*              records per IX level, low/high key per control       * FILE 394\n//*              area, unused space due to IX record too short).      * FILE 394\n//*                                                                   * FILE 394\n//*    KSDSPACO  Older version of KSDSPACE. Should run on             * FILE 394\n//*              unsupported levels of DFSMS (1.2 or less). It does   * FILE 394\n//*              not work with Extended Format/Addressability KSDS.   * FILE 394\n//*                                                                   * FILE 394\n//*    OFDVBFB   Converts sequential dataset from RECFM=VB to         * FILE 394\n//*              RECFM=FB                                             * FILE 394\n//*                                                                   * FILE 394\n//*    LLAUPDTX  Synchronous LLA update routine (using LLACOPY        * FILE 394\n//*              macro).  One member per step (specified in PARM)     * FILE 394\n//*              gets refreshed.                                      * FILE 394\n//*                                                                   * FILE 394\n//*    LLAUPDTS  Synchronous LLA update routine (using LLACOPY        * FILE 394\n//*              macro).  Multiple members (specified in SYSIN) get   * FILE 394\n//*              refreshed.                                           * FILE 394\n//*                                                                   * FILE 394\n//*    DEFNVS    Generates IDCAMS DEFINE NONVSAM statements for a     * FILE 394\n//*              DASD volume.                                         * FILE 394\n//*                                                                   * FILE 394\n//*    DELNVS    Generates IDCAMS DELETE NSCR statements for a        * FILE 394\n//*              DASD volume.                                         * FILE 394\n//*                                                                   * FILE 394\n//*    IEFUSI    A sample, configurable (working in a real            * FILE 394\n//*              production environment) SMF USI exit.                * FILE 394\n//*                                                                   * FILE 394\n//*    LDAPROBE  LDAP server probe REXX exec.                         * FILE 394\n//*    LDAPROBJ  JCL (could run as an STC) to run LDAPROBE.           * FILE 394\n//*                                                                   * FILE 394\n//*    MXIVSTOR  Dispalys virtual storage usage of an address         * FILE 394\n//*              space (REXX exec). Requires/ calls MXI to retrieve   * FILE 394\n//*              foreign address space LDA/ASCB/RAX/RAXMEMLIMIT.      * FILE 394\n//*              This is essentially a modified Mark Zelden's         * FILE 394\n//*              REXXSTOR, except that input data from a foreign AS   * FILE 394\n//*              are retrieved via MXI.                               * FILE 394\n//*                                                                   * FILE 394\n//*    TI        Displays RMM tape dataset info for an ISPF 3.4       * FILE 394\n//*              dataset list entry using RMM LISTDATASET             * FILE 394\n//*              subcommand (REXX exec).                              * FILE 394\n//*                                                                   * FILE 394\n//*    TV        Displays RMM tape volume info for an ISPF 3.4        * FILE 394\n//*              dataset list entry using RMM VOLUME subcommand       * FILE 394\n//*              (clist).                                             * FILE 394\n//*                                                                   * FILE 394\n//*    MAKENSWP  Makes all address spaces with same name              * FILE 394\n//*              nonswappable.  This can be useful for Unix           * FILE 394\n//*              applications (in our case CTG). Does this via MXI    * FILE 394\n//*              MAKE command. This is a REXX exec.                   * FILE 394\n//*                                                                   * FILE 394\n//*    JJDGEN    Janek's data records generation utility. Need a      * FILE 394\n//*              few records for testing of an application ? Try      * FILE 394\n//*              this !                                               * FILE 394\n//*                                                                   * FILE 394\n//*    WTOH      Write Message to Operator routine (highlighted       * FILE 394\n//*              messages).                                           * FILE 394\n//*                                                                   * FILE 394\n//*    $TABLES   See $TABLES doc member for description of general    * FILE 394\n//*              purpose binary search table processing routines/     * FILE 394\n//*              package.  This may be of interest for application    * FILE 394\n//*              programmers (writing applications in PL/I, COBOL,    * FILE 394\n//*              Assembler).                                          * FILE 394\n//*                                                                   * FILE 394\n//*    HALVE     Binary search tables processing subroutine           * FILE 394\n//*                                                                   * FILE 394\n//*    HLVTD     HALVE related macro: table definition                * FILE 394\n//*                                                                   * FILE 394\n//*    JJTBGEN   Create table to be searched/ processed by HALVE      * FILE 394\n//*              subroutine.                                          * FILE 394\n//*                                                                   * FILE 394\n//*    TBLACCSS  Tables access interface routine for COBOL programs   * FILE 394\n//*              (HALVE related).                                     * FILE 394\n//*                                                                   * FILE 394\n//*    KSDSINIT  New KSDS File Initialization Routine                 * FILE 394\n//*                                                                   * FILE 394\n//*    JJPDSD    Deletes all members of a PDS dataset. It is slow/    * FILE 394\n//*              poor performer with PDS datasets, but it works       * FILE 394\n//*              (better) with PDSE.                                  * FILE 394\n//*                                                                   * FILE 394\n//*    OFDASVER  Checks if specified address space/s is/are up.  If   * FILE 394\n//*              all specified address spaces are up - ends with      * FILE 394\n//*              return code of zero, otherwise ends with return      * FILE 394\n//*              code of 16.                                          * FILE 394\n//*                                                                   * FILE 394\n//*              Possible use of this program:                        * FILE 394\n//*              .Verify if a CICS or DBCOMM/DB region is up in the   * FILE 394\n//*              first step of a job. If yes, continue the job,       * FILE 394\n//*              otherwise terminate it.                              * FILE 394\n//*                                                                   * FILE 394\n//*              .Verify if all required STCs are up after IPL or     * FILE 394\n//*              periodically throughout a day. If not - issue a      * FILE 394\n//*              warning message.                                     * FILE 394\n//*                                                                   * FILE 394\n//*    Macros    SUBRET, SUBENT, TSTAMP, HLVTD                        * FILE 394\n//*                                                                   * FILE 394\n//*             Jan (Janek) Jakubek                                   * FILE 394\n//*                                                                   * FILE 394\n//*             Tel  :     416-255-8807      (Canada)                 * FILE 394\n//*             Email:     Jan.Jakubek@CGI.COM                        * FILE 394\n//*                                                                   * FILE 394\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CPYRGHTC": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x025?\\x01\\x025?\\x14!\\x00\\x06\\x00\\x06\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-19T00:00:00", "modifydate": "2002-12-19T14:21:34", "lines": 6, "newlines": 6, "modlines": 0, "user": "SYMP118"}, "text": "*\n DC C'\"COPYRIGHT (C) 2002 by Jan (Janek) Jakubek. '\n DC C'ALL RIGHTS  RESERVED EXCEPT:  PARTICULAR LICENSE IS GRANTED TO '\n DC C'DISTRIBUTE THIS PROGRAM FREE OF CHARGE, '\n DC C'BUT IT MUST NOT BE SOLD.\"'\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFNVS": {"ttr": 786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x08\\x00\\x834\\x9f\\x01\\x025/\\x15\\x18\\x00\\xee\\x00\\xe5\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1983-12-15T00:00:00", "modifydate": "2002-12-18T15:18:08", "lines": 238, "newlines": 229, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....YOUR JOBCARD......\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DISP=SHR,DSN=???????.CBT.F394\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=VIO,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=VIO,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'DASD DATA SETS CATALOG ROUTINE'\n* DASD DATA SETS CATALOG ROUTINE'\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: DEFNVS\n*\n* ATTRIBUTES : NONE\n*\n* PRIVATE MACROS : \"SUBENT\" - ENTRY INTO INTERNAL SUBROUTINE\n*                  \"SUBRET\" - EXIT FROM AN INTERNAL SUBROUTINE\n*                  \"TSTAMP\" - TIME STAMP ( COMPILATION DATE AND TIME )\n*\n* ATTENTION: SYS1.AMODGEN HAS TO BE CONCATENATED TO ASSEMBLER SYSLIB\n*\n* FUNCTION = SEE BELOW\n*\n*       THIS ROUTINE READS VTOC OF A DASD VOLUME AND CREATES IDCAMS\n*    \"DEFINE NONVSAM\" CONTROL STATEMENTS. ITS PURPOSE IS TO CATALOG\n*    AUTOMATICALLY ALL NON VSAM DATA SETS.\n*\n*    INPUT TO THE ROUTINE:\n*\n*         . DASDVOL- INPUT DASD VOLUME ( ITS VTOC )\n*\n*    OUTPUT:\n*\n*         . SYSUT1 - 80 BYTES SEQUENTIAL FILE WITH \"DEFINE NVSAM\" STMTS\n*\n*\n* THE FOLLOWING JCL MAY BE USED TO EXECUTE THIS PROGRAM :\n*\n* //LIST    EXEC PGM=DEFNVS,PARM=&DEVT\n* //DASDVOL   DD UNIT=&DEVT,VOL=SER=&VOLSER,DISP=OLD\n* //SYSUT1    DD UNIT=DISK,SPACE=(TRK,(2,2)),DISP=(,PASS),DSN=&&DEFNVS,\n* //             DCB=BLKSIZE=3200\n* //CATLG   EXEC PGM=IDCAMS\n* //STEPCAT   DD DSN=......,DISP=SHR  CATALOG NAME\n* //SYSPRINT  DD SYSOUT=*\n* //SYSIN     DD DSN=&&DEFNVS,DISP=(OLD,DELETE)\n*\n*\n* WRITTEN BY: JANEK JAKUBEK, OGL\n*               DECEMBER 1983\n*\n* CHANGE ACTIVITY:\n*                 NONE\n*\n         SPACE\nDEFNVS1  CSECT                    CSECT NAME\n         DC    C'DEFNVS ',AL1(7)\n         TSTAMP\n         PRINT NOGEN\nDEFNVS   SAVE  (14,12)            SAVE REGISTERS\n         USING DEFNVS,R15\n         ENTRY DEFNVS             ENTRY POINT\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\nWRKR1    EQU   R2                 WORK REGISTER 1\nRDEB     EQU   R3                 DEB ADDRESS\nBUFLSTR  EQU   R4                 BUFFER LIST ADDRESS\n         SPACE\n         L     R1,0(0,R1)         PARM FIELD ADDRESS\n         ST    R1,PARMA           SAVE PARM ADDRESS\n         L     R0,DSAS            DSA SIZE\n         GETMAIN R,LV=(0)         GET STORAGE FOR DSA\n         USING DSA,R1\n         ST    R13,SA+4           CHAIN\n         ST    R1,8(R13)          SAVE AREAS\n         LR    R13,R1             CURRENT SAVE AREA\n         DROP  R1\n         USING DSA,R13            DSA ADDRESSABILITY\n         DROP  R15\n         BALR  R12,0              SETUP PROGRAM ADDRESSABILITY\n         USING *,R12\n         SPACE\n*  OPEN VTOC DATA SET\n         SPACE\n         LA    R0,JFCBA           ADDRESS OF AREA FOR JFCB\n         ST    R0,JFCBEXL         INTO EXIT LIST\n         MVI   JFCBEXL,X'87'      LAST AND ONLY ENTRY IN EXLST\n         RDJFCB (VTOC)            READ DASDVOL DD JFCB INTO STORAGE\n         MVI   JFCBA,X'04'        FORMAT-4 DSCB ( VTOC ) DSNAME\n         MVC   JFCBA+1(43),JFCBA\n         OPEN  (VTOC),TYPE=J\n         L     RDEB,VTOC+44       LOAD DEB ADDRESS FROM OPENED DCB\n         OPEN  (OUTF,(OUTPUT))    OPEN WORK FILE\n         SPACE\n* INITIALYZE NON-VARIABLE FIELDS IN OUTPUT RECORD + OTHERS\n         MVC   VOLSER,JFCBA+118   VOLSER OF PROCESSED PACK\n         L     R1,PARMA           PARM ADDRESS\n         MVC   DEVT,2(R1)         INITIALYZE DEVICE TYPE ( UNIT )\n         SPACE\n         LA    BUFLSTR,BUFLIST    BUFFER LIST ADDRESS\n         XC    BUFLIST(BFLHLN+BFLELN),BUFLIST INITIALYZE BUFFER LIST\n         MVI   BFLHNOE,1          NUMBER OF ENTRIES IN BUFFER LIST\n         MVI   BFLHFL,BFLHDSCB    SCBS ARE TO BE READ WITH BUFFER LIST\n         MVI   BFLELTH,140        DSCB BUFFER LENGTH\n         LA    R0,DSCB            DSCB BUFFER ADDRESS\n         ST    R0,BFLEBUF         PUT IT INTO BUFFER LIST\n         SPACE\n*  READ VTOC ENTRIES ( FORMAT 1 OR 4 DSCBS ) LOOP\n         SPACE\nVTOCRDL  DS    0H\n         SPACE\n* ISSUE CVAFSEQ MACRO\n         SPACE\nCVAL     CVAFSEQ ACCESS=GT,                                            +\n               BUFLIST=(BUFLSTR),                                      +\n               DEB=(RDEB)\n         LTR   R15,R15            END OF VTOC ( IF NON ZERO RC )......?\n         BNZ   EOVTOC             YES, END-OF-VTOC     --------------->\n         CLI   DS1FMTID,C'1'      FORMAT 1 DSCB        ...............?\n         BNE   VTOCRDL            NO, READ NEXT VTOC ENTRY ( DSCB )--->\n         CLC   DS1DSORG,=X'0008'  VSAM DATA SET OR DATA SPACE.........?\n         BE    VTOCRDL            YES, NO CATALOGING REQUIRED--------->\n         SPACE\n* CREATE OUTPUT RECORD\n         SPACE\n         MVI   DSNAME,X'40'       INITIALYZE DSNAME TO BLANKS\n         MVC   DSNAME+1,DSNAME\n         MVC   DSNAME,DS1DSNAM    DATA SET NAME\n         LA    WRKR1,DSNAME+1     CLOSING PARENTHESIS\nCLOSP    CLI   0(WRKR1),X'40'     END OF DSNAME.......................?\n         BE    CLOSP1             YES          ----------------------->\n         LA    WRKR1,1(0,WRKR1)   NO, NEXT CHAR ADDRESS\n         B     CLOSP              CHECK NEXT CHARACTER OF DSNAME------>\nCLOSP1   MVI   0(WRKR1),C')'      MOVE CLOSING PARENTHESIS INT DEFINE\n         MVI   1(WRKR1),C')'      MOVE CLOSING PARENTHESIS INT DEFINE\n         SPACE\n         PUT   OUTF,OUTREC        PUT RECORD INTO WORK FILE\n         B     VTOCRDL            READ NEXT VTOC ENTRY\n         SPACE\nEOVTOC   DS    0H                 END OF VTOC\n         CLOSE (OUTF,,VTOC) CLOSE ALL FILES\n         SPACE\nRET0     XR    R15,R15            RC=0\nRET      L     R0,DSAS            DSASIZE\n         LR    R1,R13             DSA ADDRESS\n         L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         FREEMAIN R,LV=(0),A=(1)  FREEMAIN DSA\n         RETURN (14,12),RC=(15)\n         SPACE\nPARMA    DS    F                  PARM FIELD ADDRESS\nDSAS     DC    A(DSAE-DSA)        DSA SIZE\n         PRINT NOGEN\n         SPACE\n*  INPUT FILE\n         SPACE\nVTOC     DCB   DSORG=PS,MACRF=R,DDNAME=DASDVOL,KEYLEN=44,EXLST=JFCBEXL\n         SPACE\nJFCBEXL  DS    F                  EXLST FOR JFCB READING\n         SPACE\n*  OUTPUT FILE\n         SPACE\nOUTF     DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSUT1,RECFM=FB,             +\n               LRECL=80\n         SPACE\nOUTREC   DS    0CL80              OUTPUT RECORD LAYOUT\n         DC    CL17' DEF NVSAM (DEVT('\nDEVT     DC    CL4' '             DEVICE TYPE\n         DC    CL6') VOL('\nVOLSER   DC    CL6' '             VOLUME SERIAL NUMBER\n         DC    CL7') NAME('\nDSNAME   DC    CL44' '            DATA SET NAME\n         DC    CL10' '\n         LTORG\n         SPACE\n*  DYNAMIC STORAGE AREA\nDSA      DSECT\nSA       DS    18F                SAVE AREA\nJFCBA    DS    CL176              JFCB ( FOR OPEN TYPE=J OF VTOC FILE )\n         SPACE\nDSCB     DS    CL140              DSCB BUFFER\n         ORG   DSCB\n         PRINT GEN\n         IECSDSL1 (1)             FORMAT 1 DSCB MACRO\n         ORG\n         SPACE\nBUFLIST  ICVAFBFL DSECT=NO\n         PRINT NOGEN\nDSAE     EQU   *                  DSA END\n         SPACE\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         END   DEFNVS\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.LOADLIB....\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME DEFNVS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELNVS": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00&\\x00\\x835\\x0f\\x01\\x025/\\x15\\x18\\x00\\xdc\\x00\\xcc\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1983-12-16T00:00:00", "modifydate": "2002-12-18T15:18:26", "lines": 220, "newlines": 204, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....YOUR JOBCARD......\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DISP=SHR,DSN=???????.CBT.F394\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=VIO,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=VIO,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'DASD DATA SETS UNCATALOG ROUTINE'\n* DASD DATA SETS UNCATALOG ROUTINE'\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: DELNVS\n*\n* ATTRIBUTES : NONE\n*\n* PRIVATE MACROS : \"SUBENT\" - ENTRY INTO INTERNAL SUBROUTINE\n*                  \"SUBRET\" - EXIT FROM AN INTERNAL SUBROUTINE\n*                  \"TSTAMP\" - TIME STAMP ( COMPILATION DATE AND TIME )\n*\n* ATTENTION: SYS1.AMODGEN HAS TO BE CONCATENATED TO ASSEMBLER SYSLIB\n*\n* FUNCTION = SEE BELOW\n*\n*       THIS ROUTINE READS VTOC OF A DASD VOLUME AND CREATES IDCAMS\n*    \"DELETE DSNAME\" CONTROL STATEMENTS. ITS PURPOSE IS TO UNCATALOG\n*    AUTOMATICALLY ALL NON VSAM DATA SETS ON A DASD VOLUME.\n*\n*    INPUT TO THE ROUTINE:\n*\n*         . DASDVOL- INPUT DASD VOLUME ( ITS VTOC )\n*\n*    OUTPUT:\n*\n*         . SYSUT1 - 80 BYTES SEQUENTIAL FILE WITH \"DELETE DSN\" STMTS\n*\n*\n* THE FOLLOWING JCL MAY BE USED TO EXECUTE THIS PROGRAM :\n*\n* //LIST    EXEC PGM=DELNVS\n* //DASDVOL   DD UNIT=&DEVT,VOL=SER=&VOLSER,DISP=OLD\n* //SYSUT1    DD UNIT=DISK,SPACE=(TRK,(2,2)),DISP=(,PASS),DSN=&&DELDSN,\n* //             DCB=BLKSIZE=3200\n* //CATLG   EXEC PGM=IDCAMS\n* //STEPCAT   DD DSN=......,DISP=SHR  CATALOG NAME\n* //SYSPRINT  DD SYSOUT=*\n* //SYSIN     DD DSN=&&DELDSN,DISP=(OLD,DELETE)\n*\n*\n* WRITTEN BY: JANEK JAKUBEK, OGL\n*               DECEMBER 1983\n*\n* CHANGE ACTIVITY:\n*                 NONE\n*\n         SPACE\nDELNVS1 CSECT                     CSECT NAME\n         DC    C'DELNVS ',AL1(7)\n         TSTAMP\n         PRINT NOGEN\nDELNVS   SAVE  (14,12)            SAVE REGISTERS\n         USING DELNVS,R15\n         ENTRY DELNVS             ENTRY POINT\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\nWRKR1    EQU   R2                 WORK REGISTER 1\nRDEB     EQU   R3                 DEB ADDRESS\nBUFLSTR  EQU   R4                 BUFFER LIST ADDRESS\n         SPACE\n         L     R0,DSAS            DSA SIZE\n         GETMAIN R,LV=(0)         GET STORAGE FOR DSA\n         USING DSA,R1\n         ST    R13,SA+4           CHAIN\n         ST    R1,8(R13)          SAVE AREAS\n         LR    R13,R1             CURRENT SAVE AREA\n         DROP  R1\n         USING DSA,R13            DSA ADDRESSABILITY\n         DROP  R15\n         BALR  R12,0              SETUP PROGRAM ADDRESSABILITY\n         USING *,R12\n         SPACE\n*  OPEN VTOC DATA SET\n         SPACE\n         LA    R0,JFCBA           ADDRESS OF AREA FOR JFCB\n         ST    R0,JFCBEXL         INTO EXIT LIST\n         MVI   JFCBEXL,X'87'      LAST AND ONLY ENTRY IN EXLST\n         RDJFCB (VTOC)            READ DASDVOL DD JFCB INTO STORAGE\n         MVI   JFCBA,X'04'        FORMAT-4 DSCB ( VTOC ) DSNAME\n         MVC   JFCBA+1(43),JFCBA\n         OPEN  (VTOC),TYPE=J\n         L     RDEB,VTOC+44       LOAD DEB ADDRESS FROM OPENED DCB\n         OPEN  (OUTF,(OUTPUT))    OPEN WORK FILE\n         SPACE\n* INITIALYZE NON-VARIABLE FIELDS IN OUTPUT RECORD + OTHERS\n         SPACE\n         LA    BUFLSTR,BUFLIST    BUFFER LIST ADDRESS\n         XC    BUFLIST(BFLHLN+BFLELN),BUFLIST INITIALYZE BUFFER LIST\n         MVI   BFLHNOE,1          NUMBER OF ENTRIES IN BUFFER LIST\n         MVI   BFLHFL,BFLHDSCB    SCBS ARE TO BE READ WITH BUFFER LIST\n         MVI   BFLELTH,140        DSCB BUFFER LENGTH\n         LA    R0,DSCB            DSCB BUFFER ADDRESS\n         ST    R0,BFLEBUF         PUT IT INTO BUFFER LIST\n         SPACE\n*  READ VTOC ENTRIES ( FORMAT 1 OR 4 DSCBS ) LOOP\n         SPACE\nVTOCRDL  DS    0H\n         SPACE\n* ISSUE CVAFSEQ MACRO\n         SPACE\nCVAL     CVAFSEQ ACCESS=GT,                                            +\n               BUFLIST=(BUFLSTR),                                      +\n               DEB=(RDEB)\n         LTR   R15,R15            END OF VTOC ( IF NON ZERO RC )......?\n         BNZ   EOVTOC             YES, END-OF-VTOC     --------------->\n         CLI   DS1FMTID,C'1'      FORMAT 1 DSCB        ...............?\n         BNE   VTOCRDL            NO, READ NEXT VTOC ENTRY ( DSCB )--->\n         CLC   DS1DSORG,=X'0008'  VSAM DATA SET OR DATA SPACE.........?\n         BE    VTOCRDL            YES, NO CATALOGING REQUIRED--------->\n         SPACE\n* CREATE OUTPUT RECORD\n         SPACE\n         MVI   DSNAME,X'40'       INITIALYZE DSNAME TO BLANKS\n         MVC   DSNAME+1,DSNAME\n         MVC   DSNAME,DS1DSNAM    DATA SET NAME\n         PUT   OUTF,OUTREC        PUT RECORD INTO WORK FILE\n         B     VTOCRDL            READ NEXT VTOC ENTRY\n         SPACE\nEOVTOC   DS    0H                 END OF VTOC\n         CLOSE (OUTF,,VTOC) CLOSE ALL FILES\n         SPACE\nRET0     XR    R15,R15            RC=0\nRET      L     R0,DSAS            DSASIZE\n         LR    R1,R13             DSA ADDRESS\n         L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         FREEMAIN R,LV=(0),A=(1)  FREEMAIN DSA\n         RETURN (14,12),RC=(15)\n         SPACE\nDSAS     DC    A(DSAE-DSA)        DSA SIZE\n         PRINT NOGEN\n         SPACE\n*  INPUT FILE\n         SPACE\nVTOC     DCB   DSORG=PS,MACRF=R,DDNAME=DASDVOL,KEYLEN=44,EXLST=JFCBEXL\n         SPACE\nJFCBEXL  DS    F                  EXLST FOR JFCB READING\n         SPACE\n*  OUTPUT FILE\n         SPACE\nOUTF     DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSUT1,RECFM=FB,             +\n               LRECL=80\n         SPACE\nOUTREC   DS    0CL80              OUTPUT RECORD LAYOUT\n         DC    CL5' DEL '\nDSNAME   DC    CL44' '            DATA SET NAME\n         DC    CL31' NVSAM NSCR CAT(SYSCAT)'\n         LTORG\n         SPACE\n*  DYNAMIC STORAGE AREA\nDSA      DSECT\nSA       DS    18F                SAVE AREA\nJFCBA    DS    CL176              JFCB ( FOR OPEN TYPE=J OF VTOC FILE )\n         SPACE\nDSCB     DS    CL140              DSCB BUFFER\n         ORG   DSCB\n         PRINT GEN\n         IECSDSL1 (1)             FORMAT 1 DSCB MACRO\n         ORG\n         SPACE\nBUFLIST  ICVAFBFL DSECT=NO\n         PRINT NOGEN\nDSAE     EQU   *                  DSA END\n         SPACE\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n         END   DELNVS\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.LOADLIB....\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME DELNVS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HALVE": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00V\\x00\\x90)\\x8f\\x01\\x025/\\x15\\x16\\x01\\x0c\\x01\\x08\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1990-10-25T00:00:00", "modifydate": "2002-12-18T15:16:56", "lines": 268, "newlines": 264, "modlines": 0, "user": "SYMP118"}, "text": "         TITLE 'HALVE - BINARY SEARCH TABLES PROCESSING ROUTINE'\n* GENERALIZED BINARY SEARCH TECHNIQUE TABLES PROCESSING ROUTINE\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: HALVE\n*\n* FUNCTION = SEE BELOW\n*\n*       THE ROUTINE SEARCHES A TABLE FOR SPECIFIED KEY AND RETURNS\n*    THE ADDRESS AND POSITION OF TABLE ELEMENT CONTAINING SUCH A KEY.\n*    IT PERMITS ADDING OF NEW KEYS TO THE TABLE (TABLE EXPANTION)\n*    SO THAT IT CAN BE USED FOR SORTING OR DYNAMIC CREATION OF SORTED\n*    TABLES.\n*    IF TABLE IS SPECIFIED LARGE ENOUGH TO ENCOMPASS NEW ELEMENTS\n*    AND USER SUPPLIES KEY NOT BEING IN THE TABLE - HALVE POSITIONS\n*    NEW KEY IN THE TABLE,DISPLACES ACCORDINGLY THE OTHER ELEMENTS\n*    AND RETURNS ADDRESS AND POSITION OF THE NEW ELEMENT. USER SHOULD\n*    FILL IT THEN WITH DATA.\n*       TABLE IS DEFINED BY CONTROL BLOCK CALLED \"TABLE DEFINITION\".\n*    USER CAN SPECIFY SO CALLED \"COMPARE\" EXIT ROUTINE,WHICH PERFORMS\n*    COMPARISON OF INPUT KEY WITH KEYS OF TABLE ELEMENTS. THIS EXIT\n*    MAKES POSSIBLE PROCESSING OF TABLES WITH COMPLEX KEY STRUCTURE\n*    AND WITH ELEMENTS OF VARIABLE LENGTH.\n*\n* CALL ARGUMENTS LIST FORMAT:\n*\n*    CALL HALVE, ( TDEF, INPUT_KEY, IF_FOUND_INDICATOR )\n*\n*    TDEF        - TABLE DEFINITION ( SEE TDEF DSECT FOR FORMAT )\n*    INPUT_KEY   - KEY TO BE LOCATED IN THE \"TABLE\"\n*    INDICATOR   - BIT(1) (PL/I ATTR)   ='1'B - INPUT_KEY FOUND IN THE\n*                                               \"TABLE\"\n*                                       ='0'B - INPUT_KEY NOT FOUND\n*    INPUT-KEY           - INPUT ARGUMENT\n*    IF_FOUND_INDICATOR  - OUTPUT ARGUMENT\n*    TDEF                - INPUT/OUTPUT ARGUMENT\n*\n* REGISTERS USAGE :\n*\n*    PB   - BASE REGISTER\n*    FE   - CURRENT SECTION OF TABLE FIRST ELEMENT ADDRESS\n*    ME   - CURRENT SECTION OF TABLE MID ELEMENT ADDRESS\n*    ME-1 - WORK REG. ASSOCIATED WITH \"ME\" (FOR DIVIDE & MULTIPLY)\n*    LE   - CURRENT SECTION OF TABLE LAST ELEMENT ADDRESS\n*    CMPA - \"COMPARE\" SUBROUTINE ENTRY POINT ADDRESS\n*    PLA  - PARAMETER LIST ADDRESS\n*    IK   - INPUT KEY ADDRESS\n*    CKL  - CHARACTER KEY LENGTH-1\n*    OFF  - TABLE ELEMENTS OFFSET\n*    R13  - TABLE DEFINITION ADDRESS ( = SAVE AREA ADDRESS )\n*\n*  Written by: Janek JAKUBEK, OGL\n*           March-April 1986\n*\n         SPACE 2\nHALVE1   CSECT                    CSECT NAME\n         DC    C'HALVE',AL1(5)\nHALVE    SAVE  (14,12)            SAVE REGISTERS\n         ENTRY HALVE              ENTRY POINT\n         SPACE\n*   REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\nME       EQU   R11\n* ME-1   EQU   R10\nPB       EQU   R9\nFE       EQU   R8\nLE       EQU   R7\nCMPA     EQU   R6\nIK       EQU   R5\nCKL      EQU   R4\nOFF      EQU   R3\nPLA      EQU   R1\n         SPACE\nKEYFF    EQU   X'80'              KEY FOUND ( IN THE TABLE ) FLAG\n         SPACE\n         BALR  PB,0               SET BASE REGISTER\n         USING *,PB\n         USING PARMLST,PLA        PARAMETERS LIST ADDRESSABILITY\n         L     ME-1,TDEFA         TABLE DEFINITION ADDRESS\n         ST    R13,4(ME-1)        CHAIN\n         ST    ME-1,8(R13)        SAVE AREAS\n         MVC   72(8,ME-1),72(R13) SAVE PL/I SLOTS\n         LR    R13,ME-1           CURRENT SAVE AREA\n         USING TDEF,R13           TDEF ADDRESSABILITY\n         SPACE\n*---------------------------------------------------------------------*\n*   SET UP OF \"COMPARE\" ROUTINE ADDRESS                               *\n*---------------------------------------------------------------------*\n         SPACE\n         L     CMPA,KL            CHAR. KEY LENGTH OR PL/I ENTRY ADDR.?\n         LA    CMPA,0(0,CMPA)     CLEAN HIGH ORDER BYTE\n         CH    CMPA,=H'256'       ....................................?\n         BNH   KEYLEN             KEY LENGTH, STANDARD COMPARE CODE--->X\n                                  WILL BE USED\n         L     CMPA,0(0,CMPA)     EXTERNAL \"COMPARE\" ROUTINE ADDRESS\n         B     HSEQ1                                              ---->\nKEYLEN   LR    CKL,CMPA\n         BCTR  CKL,0              KEY LENGTH - 1\n         LA    CMPA,COMPARE       DEFAULT \"COMPARE\" ROUTINE ADDRESS\nHSEQ1    EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n*  DETERMINATION OF ADDRESSES OF FIRST & LAST+1 ELEMENT OF THE TABLE  *\n*---------------------------------------------------------------------*\n         SPACE\n         L     FE,FEA             FIRST ELEMENT ADDRESS\n         LA    FE,0(0,FE)         CLEAR HIGH ORDER BYTE\n         L     LE,NA              CURRENT NUMBER OF ELEMENTS IN TABLE\n         MH    LE,OFFS            TABLE LENGTH\n         AR    LE,FE              LAST ELEMENT+1 ADDRESS\n         LH    OFF,OFFS           TABLE ELEMENTS OFFSET\n         L     IK,IKA             INPUT_KEY ADDRESS\n         LR    ME,LE              INITIALYZE \"ME\" IF TABLE EMPTY\n         CR    FE,LE              TABLE EMPTY ( NA=0 ) ...............?\n         BE    NOTFOUND           YES,BYPASS TABLE SEARCH PHASE.......>\n         SPACE\n*---------------------------------------------------------------------*\n*   MAIN  TABLE  PROCESSING  ( BINARY DIVISION & SEARCH ) LOGIC       *\n*---------------------------------------------------------------------*\n         SPACE\nHLOOP    LR    ME,LE\n         SR    ME,FE              CURRENT SECTION OF TABLE LENGTH\n         XR    ME-1,ME-1          SET EVEN REG. TO ZERO\n         DR    ME-1,OFF           LENGTH / OFFSET = NO. OF ELEMENTS\n         SRL   ME,1               NO. OF ELEMENTS IN THE SECTION / 2\n         MR    ME-1,OFF           MID ELEMENT OFFSET\n         AR    ME,FE              MID ELEMENT ADDRESS\n         ST    ME,EADR            STORE MID ELEMENT ADDRESS IN TDEF====\n         LR    R15,CMPA           \"COMPARE\" ENTRY POINT ADDRESS\n         BALR  R14,R15            ----->  CALL \"COMPARE\" EXIT\n         B     *+4(R15)           TAKE DECISION ACCODRING TO RET.CODE->\n         B     EQUAL              INPUT_KEY = KEY IN MID ELEMENT------>\n         B     HIGHT              INPUT_KEY > KEY IN MID ELEMENT------>\n         SPACE\nLESST    DS    0H                 INPUT_KEY < KEY IN MID ELEMENT\n         CR    ME,FE              FIRST ELEMENT = LAST................?\n         BE    NOTFOUND           YES,GO TO NEXT PHASE---------------->\n         LR    LE,ME              NO, PROCESS NEXT SECTION OF THE TABLE\n         B     HLOOP                                  ---------------->\n         SPACE\nHIGHT    DS    0H                 INPUT_KEY > KEY IN THE MID ELEMENT\n         AR    ME,OFF             ADDR. OF NEXT ELEMENT AFTER MID\n         CR    ME,LE              TABLE FULLY SEARCHED................?\n         BE    NOTFOUND           YES, GOTO NEXT PHASE---------------->\n         LR    FE,ME              NO, PROCESS NEXT SECTION OF THE TABLE\n         B     HLOOP                                  ---------------->\n         SPACE\nEQUAL    DS    0H                 INPUT_KEY FOUND IN THE TABLE\n         L     R15,IFFA           IF_FOUND_FLAG ADDRESS\n         OI    0(R15),KEYFF       SET KEY FOUND FLAG  ================\n         BAL   R14,SETEPOS        -------> SET-UP ELEMENT POSITION     X\n                                           WITHIN THE TABLE\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\nRETURN   DS    0H\n         L     R13,4(0,R13)       RESTORE OLD SAVE AREA ADDRESS\n         RETURN (14,12)           <-----------------------------------\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\nCOMPARE  DS    0H                 DEFAULT \"COMPARE\" EXIT ROUTINE\n         EX    CKL,CLCKEY         COMPARE CHARACTER KEYS\n         BH    HIGHT              ---------->\n         BL    LESST              ---------->\n         BE    EQUAL              ---------->\n         SPACE\nCLCKEY   CLC   0(1,IK),0(ME)      CHARACTER KEYS COMPARISON...........?\n         SPACE 2\n*---------------------------------------------------------------------*\n*  INPUT KEY NOT FOUND IN THE TABLE                                   *\n*  IF  NA < NM  TABLE WILL BE EXPANDED                                *\n*---------------------------------------------------------------------*\n         SPACE\nNOTFOUND DS    0H                 TABLE EXPANTION PHASE OR TERMINATION\n         L     R15,IFFA           IF_FOUND_FLAG ADDRESS\n         NI    0(R15),X'FF'-KEYFF SET OFF KEY FOUND FLAG===============\n         ST    ME,EADR            LOCATED ELEMENT ADDRESS (ELEMENT TO BE\n                                  INSERTED BY THE USER) ===============\n         L     R6,NA              CURRENT NO. OF ELEMENTS IN THE TABLE\n         C     R6,NM              TABLE TO BE EXPANDED................?\n         BL    EXPND              YES--------------------------------->\n         XC    EPOS,EPOS          TABLE CANNOT BE EXPANDED MARK========\n         B     RETURN             ------------------------------------>\n         SPACE\n*---------------------------------------------------------------------*\n*  TABLE EXPANTION ( SORTING ) IN EXPECTATION OF USER UPDATE          *\n*---------------------------------------------------------------------*\n         SPACE\nEXPND    DS    0H\n         BAL   R14,SETEPOS        ------->SET LOCATED ELEMENT POSITION\n         LA    R6,1(0,R6)         CURRENT NO. OF ELEMENTS + 1\n         ST    R6,NA              STORE IN TDEF=======================\n         BCTR  R6,0               - 1\n         L     FE,FEA             FIRST ELEMENT ADDRESS\n         LA    FE,0(0,FE)         CLEAR HIGH ORDER BYTE\n         MH    R6,OFFS            NO. OF ELEMENTS * OFFSET = OFFSET OF X\n                                  TABLE'S LAST ELEMENT\n         AR    R6,FE              LAST ELEMENT ADDRESS\n         LR    R4,R6              LAST ELEMENT ADDRESS\n         CR    ME,R6              LOC.ELEM.ADDR<LAST ELEM.ADDR........?\n         BNL   EXPEX              NO,TABLE MOVEMENT NOT REQUIRED------>\n         SPACE\n*---------------------------------------------------------------------*\n*  ELEMENTS DISPLACEMENT ( SORTING ) LOOP                             *\n*---------------------------------------------------------------------*\n         SPACE\nEXPLP    SR    R4,OFF             ELEMENT-1 ADDRESS\n         LH    R7,LEN             ELEMENT LENGTH\n         LR    R5,R7              ELEMENT LENGTH\n         MVCL  R6,R4              ELEM.-1 INTO--->NEXT ELEMENT MOVE\n         SR    R4,OFF             INITIAL ADDRESS (BEFORE MVCL)\n         LR    R6,R4              NEXT PAIR OF ELEMENTS\n         CR    R4,ME              LOCATED ELEMENT ALREADY MOVED.......?\n         BH    EXPLP              NO,PROCEED WITH NEXT ELEM. MOVE----->\n         SPACE\n*---------------------------------------------------------------------*\n*  INITIALIZATION OF LOCATED ELEMENT WITH BINARY ZEROS                *\n*---------------------------------------------------------------------*\n         SPACE\nEXPEX    XR    R4,R4\n         LH    R7,LEN             ELEMENT LENGTH\n         XR    R5,R5              PAD = X'00'\n         MVCL  R6,R4              PROPAGATE BINARY ZEROS===============\n         B     RETURN\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\nSETEPOS  DS    0H                 DETERMINATION OF LOCATED ELEMENT     X\n                                  POSITION WITHIN THE TABLE\n         LR    R5,ME              LOCATED ELEMENT ADDRESS\n         L     R4,FEA             FIRST ELEMENT ADDRESS\n         LA    R4,0(0,R4)         CLEAR HIGH ORDER BYTE\n         SR    R5,R4              LOCATED ELEM.OFFSET(FROM BEGINING)\n         BZ    SETEPOS1           THIS IS FIRST ELEMENT IN THE TABLE-->\n         XR    R4,R4              ZERO R4\n         DR    R4,OFF             ELEMENT'S POSITION - 1\nSETEPOS1 LA    R5,1(0,R5)\n         ST    R5,EPOS            STORE ELEM. POSITION INTO TDEF=======\n         BR    R14                <-------RETURN TO CALLER\n         SPACE\n         LTORG\n         SPACE 2\nTDEF     HLVTD DSECT              PROCESSED TABLE DEFINITION\n         SPACE 2\nPARMLST  DSECT                    INPUT PARAMETERS' ADDRESS LIST\nTDEFA    DS    A                  TABLE DEFINITION ADDRESS\nIKA      DS    A                  INPUT KEY ADDRESS\nIFFA     DS    A                  IF FOUND FLAG ADDRESS\n         SPACE\n         END   HALVE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HLVTD": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x901/\\x00\\x901/\\x15W\\x00[\\x00[\\x00\\x00\\xd7\\xd9\\xf2\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-11-08T00:00:00", "modifydate": "1990-11-08T15:57:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "PR2487"}, "text": "         MACRO\n&NAME    HLVTD &DSECT,            IF='DSECT' DSECT WILL BE GENERATED   +\n               &PREF=,            FIELDS NAMES PREFIX                  +\n               &SUFF=,            FIELDS NAMES SUFFIX                  +\n               &LEN=,             TABLE ELEMENT LENGTH                 +\n               &OFFS=,            TABLE ELEMENTS OFFSET                +\n               &KL=*,             CHARACTER KEY LENGTH                 +\n               &CMPRE=*,          COMPARE EXIT ROUTINE ADDRESS         +\n               &NM=,              MAX NO. OF ELEMENTS IN THE TABLE     +\n               &NA=               CURRENT NO. OF ELEMENTS IN THE TABLE\n         AIF   ('&PREF' NE '' AND '&SUFF' NE '').PREFSUF\n         AIF   (K'&PREF GT 3 OR K'&SUFF GT 3).LPRESUF\n         AIF   ('&KL' NE '*' AND '&CMPRE' NE '*').KLMPREX\n         AIF   ('&DSECT' NE 'DSECT').NODSECT\n&NAME    DSECT                    TABLE DEFINITION FOR \"HALVE\" SUBROUT.\n         AGO   .NODS\n.NODSECT ANOP\n&NAME    DS    0F                 TABLE DEFINITION FOR \"HALVE\" SUBROUT.\n.NODS    ANOP\n         LCLC  &LABEL\n&LABEL   SETC  '&PREF.SA&SUFF'\n&LABEL   DS    20A                SAVE AREA FOR HALVE (REENTRANCE)\n&LABEL   SETC  '&PREF.FEA&SUFF'\n&LABEL   DS    A                  TABLE ( FIRST ELEMENT ) ADDRESS\n&LABEL   SETC  '&PREF.LEN&SUFF'\n         AIF   ('&LEN' NE '').ILEN\n&LABEL   DS    H                  TABLE ELEMENT LENGTH\n         AGO   .OFF\n.ILEN    ANOP\n&LABEL   DC    AL2(&LEN)          TABLE ELEMENT LENGTH\n.OFF     ANOP\n&LABEL   SETC  '&PREF.OFFS&SUFF'\n         AIF   ('&OFFS' NE '' OR '&LEN' NE '').IOFF\n&LABEL   DS    H                  OFFSET OF TWO ADJACENT ELEM.OF TABLE\n         AGO   .LCMPRE\n.IOFF    AIF   ('&OFFS' EQ '').IOFF1\n&LABEL   DC    AL2(&OFFS)        OFFSET OF TWO ADJACENT ELEM.OF TABLE\n         AGO   .LCMPRE\n.IOFF1   ANOP\n&LABEL   DC    AL2(&LEN)          OFFSET OF TWO ADJACENT ELEM.OF TABLE\n.LCMPRE  ANOP\n         AIF   ('&CMPRE' NE '*').CMPRE\n&LABEL   SETC  '&PREF.KL&SUFF'    NO COMPARE EXIT SPECIFIED\n         AIF   ('&KL' NE '' AND '&KL' NE '*').IKL\n&LABEL   DS    F                  CHARACTER KEY LENGTH\n         AGO   .NM\n.IKL     ANOP\n&LABEL   DC    A(&KL)             CHARACTER KEY LENGTH\n         AGO   .NM\n.CMPRE   ANOP\n&LABEL   SETC  '&PREF.CMPRE&SUFF'\n         AIF   ('&CMPRE' NE '').ICMPRE\n&LABEL   DS    A                  ADDRESS OF ADDRESS OF ENTRY POINT OF +\n                                  COMPARE EXIT ROUTINE\n         AGO   .NM\n.ICMPRE  ANOP\n&LABEL   DC    A(&CMPRE)          ADDRESS OF ADDRESS OF ENTRY POINT OF +\n                                  COMPARE EXIT ROUTINE\n.NM      ANOP\n&LABEL   SETC  '&PREF.NM&SUFF'\n         AIF   ('&NM' NE '').INM  INITIAL VALUE SPECIFIED FOR NM\n&LABEL   DS    F                  MAX. NO. OF ELEMENTS IN THE TABLE\n         AGO   .NA\n.INM     ANOP\n&LABEL   DC    A(&NM)             MAX. NO. OF ELEMENTS IN THE TABLE\n.NA      ANOP\n&LABEL   SETC  '&PREF.NA&SUFF'\n         AIF   ('&NA' NE '' OR '&NM' NE '').INA\n&LABEL   DS    F                  CURRENT NO. OF ACTIVE ELEM.IN TABLE\n         AGO   .EADR\n.INA     AIF   ('&NA' NE '').INA1 NA SECIFIED\n&LABEL   DC    A(&NM)             CURRENT NO. OF ACTIVE ELEM.IN TABLE\n         AGO   .EADR\n.INA1    ANOP\n&LABEL   DC    A(&NA)             CURRENT NO. OF ACTIVE ELEM.IN TABLE\n.EADR    ANOP\n&LABEL   SETC  '&PREF.EADR&SUFF'\n&LABEL   DS    A                  LOCATED ELEM.ADDR.RETURNED BY HALVE\n&LABEL   SETC  '&PREF.EPOS&SUFF'\n&LABEL   DS    F                  POSITION IN THE TABLE OF LOCATED ELEM.\n                                  OR ZERO IF TABLE CANNOT BE EXPANED\n         AGO   .END\n.PREFSUF MNOTE 8,'***** HLVTD ** \"PREF\" AND \"SUFF\" ARE MUTUALLY EXCLUSI+\n               VE OPERANDS. DO NOT SPECIFY THEM BOTH AT THE SAME TIME'\n         AGO   .END\n.LPRESUF MNOTE 8,'***** HLVTD ** LENGTH OF \"PREF\" AND \"SUFF\" CANNOT EXC+\n               EED 3 CHARACTERS'\n         AGO   .END\n.KLMPREX MNOTE 8,'***** HLVTD ** \"KL\" AND \"CMPRE\" ARE MUTUALLY EXCLUSIV+\n               E OPERANDS. DO NOT SPECIFY THEM BOTH AT THE SAME TIME'\n.END     MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFUSI": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00@\\x01\\x03(?\\x01\\x033\\x1f\\x103\\x01\\xa1\\x01<\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2003-10-10T00:00:00", "modifydate": "2003-11-27T10:33:40", "lines": 417, "newlines": 316, "modlines": 0, "user": "SYMP118"}, "text": "//name..   JOB ............\n//*\n//PROCS JCLLIB ORDER=(&hlq..ASM.SASMSAM1)\n//*\n//ASMUJI  EXEC ASMACL,\n//             PARM.C='RENT,OBJECT,NODECK',\n//             PARM.L='RENT,REUS,XREF,LIST,NCAL'\n//C.SYSLIB DD  DISP=SHR,DSN=&hlq..MACLIB\n//         DD  DISP=SHR,DSN=&hlq..MODGEN\n//C.SYSIN  DD  *\n&CSECTN  SETC  'IEFUSI02'\n         TITLE 'IEFUSI02 - SMF Step Initialization Installation Exit'\n&CSECTN  CSECT\n&CSECTN  AMODE 31\n&CSECTN  RMODE ANY\n***********************************************************************\n* Change log:                                                         *\n* Oct. 31/2003 JJ:\n* The IEFUSI exit has been redesigned.\n* The main reason for the update is an error in the current coding:\n* If REGION=0K or 0M is specified - the region limit below the line\n* was set to 5MiB and region size set to 5MiB-64KiB.\n* This resulted in some SMPE job failures (due to insufficient region\n* below). Also, if REGION>16M is requested, region below was set to\n* private size below (LDASIZA). This occassionally causes \"End of\n* Memory\" abends due to insufficient LSQA/SWA.\n*\n* Here is the current processing of the exit:\n*\n* For the region below 16M:\n* Max region limit allowed is = LDASIZA-CUSHIONB\n* If region requested + 64K < MINBELOW set region limit to MINBELOW\n* If region requested + 64K > MAXBELOW set region limit to MAXBELOW\n* Region below = region limit below - cushion for variable getmain\n*                protection (= MVS default = 64K)\n*\n* For the region above 16M:\n* Max region limit allowed is = LDAESIZA-CUSHIONA\n* Region size  = region requested\n* Region limit = region requested + cushion for variable getmain\n*                protection (1M at this time, MVS default is 0K)\n*\n* Other changes:\n* 1. Set VSMFLAGW bit 1 to ON. This means that if region requested\n*    + 64K is > MAXBELOW and <= 16M - the job will not abend.\n*    This in effect frees a user from knowing what the MAXBELOW in\n*    his/her environment/image is. If a user codes REGION > MAXBELOW\n*    and <= 16M - he/she will always get MAXBELOW, and not an abend.\n* 2. Apply the exit changes to all subsystems except OMVS (it was\n*    JES2 only).\n* 3. Use LDA rather than GDA to get below 16MB private area size      *\n*    (LDASIZA and LDAESIZA, on advise from IBM-MAIN).                 *\n* 4. Use subsystem name pointed by EXTASSN (8th word of exit PARM list*\n*    ) instead of the one in OUCBSUBN field (use data provided for    *\n*    the exit instead of chasing the control blocks).                 *\n* 5. Replaced GET/FREEMAIN macros by STORAGE.                         *\n*                                                                     *\n***********************************************************************\n**                                                                   **\n** IEFUSI: SMF Step Initialization Installation Exit         CGI MDC **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n**                                                                   **\n** Function:                                                         **\n**                                                                   **\n**    IEFUSI receives control from the initiator before each job     **\n**    step is started (prior to allocation).                         **\n**                                                                   **\n**    This exit is used to control the installation limits for       **\n**    region, GETMAIN, and data spaces.                              **\n**                                                                   **\n**    Following installation values are defined/set in this exit     **\n**    and should be tailored to installation's need:                 **\n**                                                                   **\n**    . CUSHIONB: cushion below 16M for LSQA/SWA/RTM/auth.subpools.  **\n**    . CUSHIONA: cushion above 16M for LSQA/SWA/RTM/auth.subpools.  **\n**    . MINBELOW: Minimum region limit below 16M   (=5M+64K)         **\n**    . MINABOVE: unchanged (MVS default used).                      **\n**    . MAXBELOW  = LDASIZA-CUSHIONB (cushion below for LSQA/RTM)  JJ**\n**    . MAXABOVE  = LDAESIZA-CUSHIONA (cushion above for LSQA/RTM) JJ**\n**                                                                   **\n** Operation:                                                        **\n**                                                                   **\n** 1.Control region size below 16M.                                  **\n**                                                                   **\n**  Max region limit allowed is = LDASIZA-CUSHIONB\n**  If region requested + 64K < MINBELOW set region limit to MINBELOW\n**  If region requested + 64K > MAXBELOW set region limit to MAXBELOW\n**  Region below = region limit below - cushion for variable getmain\n**                 protection (= MVS default = 64K)\n**\n**                                                                   **\n** 2.Control region size above 16M.                                  **\n**                                                                   **\n**  Max region limit allowed is = LDAESIZA-CUSHIONA\n**  Region size  = region requested\n**  Region limit = region requested + cushion for variable getmain\n**                 protection (1M at this time, MVS default is 0K)\n**                                                                   **\n**  Sets VSMFLAGW bit 1 to ON. This means that if region requested   **\n**  + 64K is > MAXBELOW and <= 16M - the job will not abend.         **\n**  This in effect frees a user from knowing what the MAXBELOW in    **\n**  his/her environment/image is. If a user codes REGION > MAXBELOW  **\n**  and <= 16M - he/she will always get MAXBELOW.                    **\n**                                                                   **\n**                                                                   **\n** Recovery-operation:                                               **\n**                                                                   **\n**    An ESTAE is set up by the calling module IEFSMFIE.             **\n**                                                                   **\n** Register-Conventions:                                             **\n**    Register      13 - Save area provided by caller. (No own save  **\n**                       area is required by this sample exit).      **\n**    Register      12 - Module base.                                **\n**    Register      11 - Job Management Record JMR.                  **\n**    Register       8 - Exit parameter list.                        **\n**    Register       7 - VSM parameter area (VSMPARM).               **\n**    Register       6 - RSM parameter area (RSMPARM).               **\n**                                                                   **\n** Attributes:                                                       **\n**    State:         Supervisor                                      **\n**    Key:           0                                               **\n**    Mode:          Task                                            **\n**    Amode:         31                                              **\n**    Rmode:         Any                                             **\n**    Type:          Reentrant                                       **\n**    Serialization: Enabled / Unlocked                              **\n**    ASC Mode:      Primary (HASID=PASID=SASID)                     **\n**                                                                   **\n** Entry-Registers:                                                  **\n**    Register       0 - Irrelevant                                  **\n**    Register       1 - Address of the parameter list (EXTPARM)     **\n**    Registers   2-12 - Irrelevant                                  **\n**    Register      13 - Address of standard 72 byte                 **\n**                       save area                                   **\n**    Register      14 - Return address                              **\n**    Register      15 - Entry address of IEFUSI                     **\n**                                                                   **\n** Input:                                                            **\n**    Register one points to the following list of addresses:        **\n**    1. Address of the common exit parameter area mapped by IEFJMR. **\n**    2. Address of an eight-byte area containing the job step name. **\n**    3. Address of an eight-byte area containing the program name   **\n**       from the EXEC statement.                                    **\n**    4. Address of an area containing the accounting information of **\n**       the EXEC statement. The first byte of the accounting infor- **\n**       mation contains the number of following accounting fields.  **\n**       Each entry for an accounting field contains the length of   **\n**       the field (one-byte, binary) followed by the field. A zero  **\n**       in the length byte indicates an omitted field.              **\n**    5. Address of the VSM parameter area that IEFUSI can use to    **\n**       communicate the region and GETMAIN limits below and above   **\n**       the 16 mega-byte line to VSM.                               **\n**    6. Address of the SRM information fullword. The first bit in   **\n**       the first byte of this fullword indicates a V=R job.        **\n**    7. Address of the RSM parameter area containing default and    **\n**       limiting values for data spaces.                            **\n**                                                                   **\n** Output:                                                           **\n**                                                                   **\n**    . A return code indicating if job processing should continue   **\n**      or should be cancelled.                                      **\n**                                                                   **\n**    . Updated VSM parameter area.                                  **\n**                                                                   **\n**    . Updated RSM parameter area.                                  **\n**                                                                   **\n** Exit-Registers:                                                   **\n**    Registers   0-14 - Restored to contents at entry               **\n**    Register      15 - Return code                                 **\n**                                                                   **\n** Return-Codes:                                                     **\n**    0 - Job processing should continue.                            **\n**    4 - Job processing should be cancelled.                        **\n**                                                                   **\n**                                                                   **\n** Control-Blocks:                                                   **\n**                                                                   **\n**    Common Name/Use  Macro ID  Full Name                           **\n**    ---------------  --------  ---------                           **\n**    ASCB       R     IHAASCB   Address Space Control Block.        **\n**    CVT        R     CVT       Communication Vector Table.         **\n**    LDA        R     IHALDA    VSM Local Data Area.                **\n**    JMR        R     IEFJMR    Job's Job Management Record.        **\n**    PSA        R     IHAPSA    Prefixed Save Area.                 **\n**                                                                   **\n**    (C=Create, R=Read, W=Write, D=Delete)                          **\n**                                                                   **\n** Macros-Executable:                                                **\n**    SAVE                                                           **\n**                                                                   **\n***********************************************************************\n***********************************************************************\n         SAVE  (14,12),,&CSECTN*&SYSDATE*&SYSTIME\n         LR    R12,R15\n         LR    R8,R1               Load address of parameter list.\n         USING &CSECTN,R12\n         L     R0,=A(GETMAINL)\n         STORAGE OBTAIN,LENGTH=(0),LOC=ANY\n         ST    R1,8(,R13)              CHAIN SAVE AREAS\n         ST    R13,4(,R1)\n         LR    R13,R1\n         USING SAVEAREA,R13            ESTABLISH ADDRESSABILITY\n         USING EXTPARM,R8          Set parameter list addressability.\n         L     R11,EXTAEPA         Load address of exit parameter area.\n         USING JMR,R11             Map SMF exit parameter area to JMR.\n***********************************************************************\n* Handle region / GETMAIN limits.                                     *\n***********************************************************************\n         ICM   R7,15,EXTAVSMP      Fetch pointer to VSM parameter list.\n         USING VSMPARM,R7          VSM parameter list addressability.\n         BZ    RETURN              Bypass if not provided.\n         ICM   R1,15,EXTASRMI      Fetch pointer to SRM info. word.\n         BZ    RETURN              Bypass if not provided.\n         TM    0(R1),X'80'         V=R job ?\n         BO    RETURN              Bypass if V=R job.\n         L     R5,EXTASSN          Address of the subsytem name\n         CLC   OMVS,0(R5)          Is it OMVS?\n         BE    RETURN              Yes, quick return\n*\nSETRL    OI    VSMFLAGW,X'C0'      Set flags \"use IEFUSI limits\", +\n*                          do not check to see if the requested region\n*                          fits into the available space below 16\n*                          megabytes.\n*\n* At entry to the exit the initial LDA settings are:\n*\n* LDALIMIT = LDAVVRG = LDASIZA - 64K\n* LDAELIM  = LDAEVVRG = 32Mb\n* (as per MVS Installation Exits, IEFUSI, not verified by JJ)\n*\n* We will look at/ set region size below 16M\n*\n* For the region below 16M:\n*\n* Max region limit allowed is = LDASIZA-CUSHIONB\n* If region requested + 64K < MINBELOW set region limit to MINBELOW\n* If region requested + 64K > MAXBELOW set region limit to MAXBELOW\n* Region below = region limit below - cushion for variable getmain\n*                protection (= MVS default = 64K)\n*\n         L     R1,PSAAOLD-PSA      LOAD ASCB POINTER\n         L     R1,ASCBLDA-ASCB(,R1)   LOAD LDA ADDRESS\n         USING LDA,R1              LDA addressability\n         L     REGBELOW,LDASIZA    < 16M V=V REGION HIGH  VALUE\n         S     REGBELOW,CUSHIONB   - cushion below (for LSQA/RTM etc)\n*                                  = MAXBELOW (max region limit below)\n         ICM   REGRQ,15,VSMREGRQ   Fetch requested region size.\n         BNZ   REGRQNZ             REGION \u00ac= 0K/0M requested---------->\n* REGION=0K/0M requested. Limit region below 16M to MAXBELOW\nSETREGB  ST    REGBELOW,VSMRLIMB   Set REGION limit below 16Mb.\n         S     REGBELOW,VGMCUSHB   - variable getmain cushion below\n         ST    REGBELOW,VSMRSIZB   Set REGION size  below 16Mb.\n         B     ABOVE               Set limits above------------------->\nREGRQNZ  A     REGRQ,VGMCUSHB      Region requested + variable getmain\n*                                  protection increment\n         CR    REGRQ,REGBELOW      Region requested > MAXBELOW ?\n         BH    SETREGB             Yes, limit region < 16M to MAXBELOW\n         C     REGRQ,MINBELOW      Region < installation minimum ?\n         BNL   ABOVE               No, got to above 16M region setup\n         L     REGBELOW,MINBELOW   Set REGION Limit below 16Mb to\n*                                   MINBELOW\n         B     SETREGB             set region below to MINBELOW------->\n*\n* For the region above 16M:\n* Max region limit allowed is = LDAESIZA-CUSHIONA\n* Region size  = region requested\n* Region limit = region requested + cushion for variable getmain\n*                protection (1M at this time, MVS default is 0K)\n*\nABOVE    DS    0H\n         ICM   REGRQ,15,VSMREGRQ   Re-load requested region size.\n         BNZ   ABOVENZ             REGION \u00ac= 0K/0M requested---------->\n         L     REGRQ,LDAESIZA      Load into REGRQ private above size\nABOVENZ  C     REGRQ,MINABOVE      Region requested < 32M ............?\n         BNL   ABOVENZ1            No, keep the value requested------->\n         L     REGRQ,MINABOVE      Set Region requested to MINABOVE\n*                                  (= MVS default = 32M)\nABOVENZ1 A     REGRQ,VGMCUSHA      region requested + cushion for\n*                                  variable getmain protection\n         L     REGABOVE,LDAESIZA   Private area above\n         S     REGABOVE,CUSHIONA   - cushion above (for LSQA/RTM etc)\n*                                  = MAXABOVE\n         CR    REGRQ,REGABOVE      compare with requested\n         BNL   SETREGA             REGRQ >= MAXABOVE .................?\n*                                  yes, make REGABOVE=MAXABOVE ------->\n         LR    REGABOVE,REGRQ      REGRQ <  MAXABOVE\n*                                  make REGABOVE=REGRQ\nSETREGA  ST    REGABOVE,VSMRLIMA   Set REGION limit above 16Mb.\n         S     REGABOVE,VGMCUSHA   - variable getmain cushion above\n         ST    REGABOVE,VSMRSIZA   Set REGION size  above 16Mb.\n* We are done, fall through to RETURN\n         DROP  R1\n***********************************************************************\n*                                                                     *\n* Return to calling PROGRAM.                                          *\n*                                                                     *\n***********************************************************************\nRETURN   EQU   *\n         LR    R1,R13                  POINT AT GETMAINED AREA\n         L     R13,4(,R13)             POINT AT OLD SAVE AREA\n         L     R0,=A(GETMAINL)\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         LM    R14,R12,12(R13)     Restore registers at entry.\n         SR    R15,R15             Set zero return code.\n         BSM   0,14                Return to caller in its mode.\n         LTORG\nCUSHIONA DC    A(16*1024*1024)    16M cushion above 16M for LSQA/SWA\nCUSHIONB DC    A(512*1024)        512K cushion below 16M for LSQA/SWA\n* 512K cushion below was selected after reviewing IBM-MAIN archive\n* discussions on IEFUSI.\nVGMCB    EQU   64*1024             64K variable getmain cushion below\nVGMCUSHB DC    A(VGMCB)            64K variable getmain cushion below\n* VGMCUSHB is used to protect the region below from a variable\n* getmain that would allocate all region below and than cause\n* subsequently some other abend. 64K is the MVS default.\nVGMCUSHA DC    A(1024*1024)         1M variable getmain cushion above\n*                                 ( 0K is the current MVS default )\nMINBRS   EQU   5*1024*1024        MINBELOW region size\nMINBELOW DC    A(MINBRS+VGMCB)    MINBELOW region limit\nMINABOVE DC    A(32*1024*1024)    MINABOVE = 32M (MVS default)\nOMVS     DC    CL4'OMVS'          OMVS Subsystem name\n         SPACE\nGETMAIND DSECT\nSAVEAREA DS    18F\n*\n*  PUT OTHER DATA AREAS HERE (NOT CONSTANTS)\n*\nGETMAINL EQU   *-GETMAIND\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nREGRQ    EQU   R0     LDAREGRQ = VSMREGRQ (region requested)\nREGABOVE EQU   R4     LDAESIZA - CUSHIONA (cushion above for LSQA/SWA)\nREGBELOW EQU   R3     Work register for setting up REGION below\n***********************************************************************\n* Definition of IEFUSI installation exit parameter list.              *\n***********************************************************************\nEXTPARM  DSECT        Word#        Pointed to by register one.\nEXTAEPA  DS    A        1          Address of SMF exit parameter area.\nEXTASTPN DS    A        2          Pointer to step name.\nEXTAPGM  DS    A        3          Pointer to program name.\nEXTASACI DS    A        4          Pointer to step accounting info.\nEXTAVSMP DS    A        5          Pointer to VSM parm. list (VSMPARM).\nEXTASRMI DS    A        6          Pointer to SRM info. fullword.\nEXTARSMP DS    A        7          Pointer to RSM parm. list (RSMPARM).\nEXTASSN  DS    A        8          Addr - Subsystem name\nEXTAMLIM DS    A        9          Addr - MVS MEMLIMIT values\n* (Word 9 above is provided only in Archlevel=2 and z/OS 1.2 or above)\n* (Word 9 pointed area is mapped by SYS1.MODGEN(IARRAX)              )\n***********************************************************************\n* Definition of Virtual Storage Management Parameter List (VSMPARM).  *\n***********************************************************************\nVSMPARM  DSECT        Word#        Pointed to by EXTAVSMP.\nVSMFLAGW DS    F        1          VSM flag word\nVSMREGRQ DS    F        2          Region size requested.\nVSMRLIMB DS    F        3          REGION  limit below 16Mb.\nVSMRSIZB DS    F        4          Region  size  below 16Mb.\nVSMRLIMA DS    F        5          REGION  limit above 16Mb.\nVSMRSIZA DS    F        6          Region  size  above 16Mb.\n***********************************************************************\n* Definition of Real Storage Management Parameter List (RSMPARM).     *\n***********************************************************************\nRSMPARM  DSECT                     Pointed to by EXTARSMP.\nRSMDFSIZ DS    F                   Default data space size in 4Kb.\n*                                  System default: 239 blocks (956Kb).\nRSMMXSIZ DS    F                   Maximum combined size for all\n*                                  user key data spaces owned\n*                                  within an Address Space.\n*                                  System default: 256Mb.\nRSMMXNUM DS    F                   Maximum number of user key\n*                                  data spaces that may exist at any\n*                                  given time for an Address Space.\n*                                  System default: 256\n***********************************************************************\n* DSECT for Communication Vector Table (CVT).                         *\n***********************************************************************\n         CVT   DSECT=YES,PREFIX=YES,LIST=YES\n***********************************************************************\n* DSECT for Address Space Control Block (ASCB).                       *\n***********************************************************************\n         IHAASCB\n***********************************************************************\n* DSECT for Prefixed Save Area (PSA).                                 *\n***********************************************************************\n         IHAPSA\n***********************************************************************\n* DSECT for VSM Local Data Area (LDA).                                *\n***********************************************************************\n         IHALDA\n***********************************************************************\n* DSECT for job's SMF Job Management Record (JMR).                    *\n***********************************************************************\n         IEFJMR\n         END   &CSECTN\n/*\n//L.SYSLMOD DD DISP=SHR,DSN=&hlq..MVS.EXITLOAD\n//L.SYSIN  DD  *\n      MODE AMODE(31),RMODE(ANY)\n      ENTRY IEFUSI02\n      NAME  IEFUSI02(R)\n/*\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JJDGEN": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00&\\x00\\x90)\\x8f\\x01\\x025/\\x15 \\n@\\n'\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1990-10-25T00:00:00", "modifydate": "2002-12-18T15:20:26", "lines": 2624, "newlines": 2599, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....YOUR JOBCARD......\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//         DD DISP=SHR,DSN=CBT.FILE394.PDS PRIVATE MACROS FROM CBT394\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=VIO,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=VIO,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'TEST DATA GENERATION ROUTINE'\n* TEST DATA GENERATION ROUTINE\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: JJDGEN\n*\n* ATTRIBUTES : NONE\n*\n* PRIVATE MACROS : \"SUBENT\" - ENTRY INTO INTERNAL SUBROUTINE\n*                  \"SUBRET\" - EXIT FROM AN INTERNAL SUBROUTINE\n*\n* FUNCTION = SEE BELOW\n*\n*       THIS ROUTINE GENERATES TEST DATA FOR PROGRAM TESTING PURPOSES.\n*    OUTPUT FILE CAN HAVE F,V,U RECORD FORMATS. RECFM, LRECL AND\n*    BLKSIZE HAVE TO BE SPECIFIED IN JCL FOR OUTPUT FILE.\n*    INPUT IS ON 80 BYTES RECORDS AND DATA ARE SPECIFIED IN ASSEMBLER\n*    CONSTANTS LIKE FORMAT. RECORD DATA CAN BE SPECIFIED IN COLUMNS\n*    1 TO 71. COL 72 IS RESERVED FOR RECORD CONTINUATION MARK. IF COL\n*    72 IS DEFERENT FROM BLANK IT MEANS THAT RECORD DEFINITION IS\n*    CONTINUED ON NEXT INPUT CARD. IF LENGTH OF SPECIFIED DATA IS LESS\n*    THAN LRECL ( IN CASE OF F TYPE RECORDS ) , MISSING PART IS PADDED\n*    WITH BLANKS OR PAD CHARACTER SPECIFIED IN PARM. IF ALIGNMENT TAKE\n*    PLACE WITHIN A RECORD (FOR TYPE H,F,E,D OR L CONSTANTS), NON USED\n*    BYTES ARE PADDED ALSO WITH PAD CHARACTER.\n*    INPUT RECORD WHICH DOES NOT HAVE CONTINUATION MARK IS CONSIDERED\n*    AS THE LAST SOURCE OF DATA FOR ONE OUTPUT RECORD. NEXT INPUT\n*    RECORD AFTER IT IS CONSIDERED AS BEGINING OF NEXT OUTPUT RECORD\n*    SPECIFICATION.\n*    THE FOLLOWING TYPE OF CONSTANTS MAY BE SPECIFIED WHILE DEFINING\n*    A DATA RECORD:\n*                 C - CHARACTER\n*                 X - HEXADECIMAL\n*                 P - PACKED DECIMAL\n*                 Z - ZONED DECIMAL ( SIGNED )\n*                 H - BINARY HALFWORD ( SIGNED )\n*                 F - BINARY FULLWORD ( SIGNED )\n*                 A - BINARY, UNSIGNED\n*                 E - SHORT FLOATING POINT\n*                 D - LONG  FLOATING POINT\n*                 L - EXTENDED  FLOATING POINT\n*\n*    CONSTANT SPECIFICATION CONSISTS OF FOUR SUBFIELDS:\n*\n*    DUPLICATION FACTOR, TYPE, MODIFIERS, NOMINAL VALUE(S).\n*\n*    DETAILED DESCRIPTION OF THE CONSTANT SUBFIELDS MAY BE FOUND IN\n*    ASSEMBLER LANGUAGE MANUAL.\n*\n*    NOMINAL VALUE(S) ARE ENCLOSED IN QUOTES (C,X,P,Z,H,F,E,D,L TYPE\n*    CONSTANTS) OR IN PARENTHESIS (A TYPE CONSTANTS).\n*\n*       DUPLICATION FACTOR AND MODIFIERS LIKE IN ASSEMBLER CONSTANTS\n*    ARE OPTIONAL. THE ONLY ALLOWED MODIFIER FROM ASSEMBLER LANGUAGE IS\n*    LENGTH. UNLIKE IN ASSEMBLER LENGTH IS NOT PERMITTED IN H AND F\n*    TYPE CONSTANTS. LENGTH MODIFIER FOR TYPE \"A\" CONSTANTS HAS TO BE\n*    IN 1 TO 4 RANGE, FOR TYPE \"P\" FROM 1 TO 8, FOR TYPE \"Z\" FROM 1 TO\n*    15.\n*    MULTIPLE NOMINAL VALUES ARE NOT PERMITTED ONLY IN\n*    \"C\" TYPE OF CONSTANTS ( MULTIPLE NOMINAL VALUES ARE SEPARATED BY\n*    A COMMA ). SCALE AND EXPONENT MODIFIERS ARE NOT PERMITTED.\n*    NUMERIC VALUES HAVE TO BE CODED AS DECIMAL SELF DEFINING TERMS.\n*    NO EXPRESSIONS ARE ALLOWED. NUMERIC CONSTANTS CAN HAVE ONLY UP TO\n*    15 DIGITS SPECIFIED (SIGNIFICANT DIGITS FOR FLOATING POINT CONSTS)\n*    BIT-LENGTH SPECIFICATION IS NOT ALLOWED.\n*    RULES OF PADDING AND TRUNCATION OF CONSTANTS AND OF IMPLICIT\n*    LENGTH ARE THE SAME AS IN ASSEMBLER LANGUAGE.\n*       IN ADDITION TO LENGTH MODIFIER, OFFSET MODIFIER ( \"O\" ) - NOT\n*    KNOWN IN ASSEMBLER, CAN BE SPECIFIED. IF PRESENT - IT INDICATES\n*    OFFSET IN GENERATED RECORD AT WHICH THIS CONSTANT SHOULD START.\n*    THIS MAY MAKE EASIER CREATION OF RECORDS WHICH CONTAIN ONLY DATA\n*    USED BY TESTED PROGRAM. SAMPLE CONSTANT SPECIFICATION WITH OFFSET\n*    MODIFIER IS:    XL13O55'0123456789ABCDEF'   - LENGTH OF THIS DATA\n*    IS 13 BYTES AN THEY WILL BE PUT AT OFFSET 55 IN OUTPUT RECORD.\n*    OVERLAYING OF EARLIER SPECIFIED DATA THROUGH OFFSET SPECIFICATION\n*    IS PERMITTED BUT IT DOES NOT CHANGE AVAILABLE BYTE COUNT (\"ABC\")\n*    IN OUTPUT RECORD UNLESS OFFSET OF LAST BYTE OF THIS CONSTANT IS\n*    GREATER THAN \"ABC\". \"ABC\" IS OFFSET OF NEXT BYTE IN OUTPUT\n*    RECORD PAST LAST SPECIFIED CONSTANT. IT POINTS TO FIRST BYTE IN\n*    NOT YET DEFINED PART OF THE RECORD.\n*    IF OFFSET IS GREATER THAN \"ABC\" - UNDEFINED PART OF RECORD WILL BE\n*    FILLED WITH PAD CHARACTER AND \"ABC\" WILL BE CHANGED ACCORDINGLY.\n*       CONSTANTS ON INPUT RECORD ARE SEPARATED BY ONE OR MORE BLANKS.\n*    SPECIFICATION OF A CONSTANT MAY BE CONTINUED ON THE NEXT INPUT\n*    RECORD STARTING IN COLUMN 1.\n*       SPECIFICATION OF CONSTANTS MAY BE INTERMIXED WITH COMMENTS FOR\n*    DOCUMENTATION PURPOSES. COMMENT SPECIFICATION BEGINS WITH \"/*\" AND\n*    ENDS WITH \"*/\"   E.G.  /* THIS IS COMMENT */  .\n*    INPUT RECORD MAY CONTAIN COMMENT(S) ONLY.\n*       IN CASE OF V AND U TYPE OF OUTPUT RECORDS LENGTH OF EVERY\n*    GENERATED RECORD IS EQUAL TO LAST VALUE OF \"ABC\".\n*\n*    INPUT TO THE ROUTINE:\n*\n*         . SYSIN  - INPUT DATA\n*\n*    OUTPUT:\n*\n*         . SYSUT1   - OUTPUT FILE. DCB (RECFM,LRECL,BLKSIZE) HAS TO\n*                      BE SPECIFIED IN JCL.\n*         . SYSPRINT - MESSAGES AND PRINTOUT OF INPUT DATA\n*\n*    PARM FORMAT:\n*\n*         PAD=C|X\"NN\",ALIGN  ,LINECNT=NN\n*                     NOALIGN\n*\n*    \"PAD\" SPECIFIES PADDING CHARCTER EITHER IN CHARACTER OR HEXADEC.\n*     FORMAT. PADDING TAKES PLACE IF LENGTH OF SPECIFIED DATA IS LESS\n*     THAN LRECL OF F TYPE RECORDS AND IF OFFSET MODIFIERS ARE USED\n*     CAUSING PARTS OF THE RECORD TO BE LEFT UNDEFINED.\n*     DEFAULT IS BLANK ( X'40' ).\n*\n*    \"ALIGN\" AND \"NOALIGN\" ARE MUTUALLY EXCLUSIVE PARMS AND SPECIFY\n*    IF H,F,E,D AND L TYPE CONSTANTS ARE TO BE ALIGNED ON THE PROPER\n*    BOUNDARIES. JJDGEN ASSUMES THAT GENERATED RECORD BEGINS ON\n*    A DOUBLEWORD BOUNDARY. DEFAULT IS \"NOALIGN\".\n*    IF ALIGNMENT TAKES PLACE UNUSED BYTES ARE PADDED WITH \"PAD\"\n*    CHARACTER.\n*\n*    \"LINECNT\" SPECIFIES PAGE LINE COUNT FOR SYSPRINT. DEFAULT IS 64.\n*    SPECIFICATION OF LARGE VALUE WILL ELIMINATE PAGING ALLTOGETHER.\n*\n* SAMPLE JCL TO RUN THE PROGRAM :\n*\n* //TDGEN   EXEC PGM=JJDGEN,PARM='PAD=X''00'',NOALIGN'\n* //SYSUT1    DD UNIT=DISK,SPACE=(TRK,(1,1)),DSN=&&TEST.DATA.FILE,\n* //             DCB=(RECFM=FB,LRECL=100,BLKSIZE=4000),DISP=(,PASS)\n* //SYSPRINT  DD SYSOUT=*\n* //SYSIN     DD *\n* CL8'KEY1' PL4'-286.45' 5X'18' 10C'XXX' H'28' F'123456'   AL1(5)\n* CL8'KEY2' PL4'+286.45' 5X'19' 10C'YYY' H'15' F'234567'   AL1(6)\n* CL8'KEY3' PL4'135.24'  5X'1A' 10C'ZZZ' H'10' F'-345678'  AL2(6)\n* CL8'KEY4' PL4'200.00'  5X'1B' 10C'AAA' H'9'  F'+4567890' AL3(6)\n* CL8'KEY5' PL4'1000'    5X'28' 10C'BBB' H'50' F'1'        A(6)\n* CL8'KEY6' PL4'-2000'   5X'38' 10C'CCC' H'99' F'2'        AL1(255)\n* 8X'FF' /* END-OF-FILE RECORD */                          AL1O55(111)\n*\n*\n* WRITTEN BY: JANEK JAKUBEK, OGL\n*                JULY-AUGUST 1983\n*\n* CHANGE ACTIVITY:\n*        NOV-DEC  1984: FLOATING POINT TYPE \"E\", \"D\" AND \"L\"\n*                       TYPE CONSTANTS ADDED.\n*        DECEMBER 1984: TYPE \"Z\" ( ZONED DECIMAL ) CONSTANT ADDED\n*\n*        OCTOBER  1985: ERROR FIXED - ERROR SIGNALED WHEN ENDING\n*                       QUOTE SPECIFIED IN COLUMN 71 FOR TYPE \"C\"\n*                       CONSTANT.\n         SPACE\n         MACRO\n&LAB     ERMSG &MSGT\n         LCLC  &MSGNO             MESSAGE NUMBER\n&MSGNO   SETC  'MSG'.'&SYSNDX'\n&LAB     DC    AL1(L'&MSGNO-1)    MESSAGE LENGTH - 1\n&MSGNO   DC    C&MSGT\n         MEND\n         SPACE\nJJDGEN1  CSECT                    CSECT NAME\n         DC    C'JJDGEN ',AL1(7)\n         TSTAMP\n         PRINT NOGEN\nJJDGEN   SAVE  (14,12)            SAVE REGISTERS\n         USING JJDGEN,R15\n         ENTRY JJDGEN             ENTRY POINT\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n* R0,R1,R2,R3,R14,R15 - WORK REGISTERS\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\nWRKR1    EQU   R2                 WORK REGISTER 1\n         SPACE\n         L     R1,0(0,R1)         PARM FIELD ADDRESS\n         ST    R1,PARMA           SAVE PARM ADDRESS\n         L     R0,DSAS            DSA SIZE\n         GETMAIN R,LV=(0)         GET STORAGE FOR DSA\n         USING DSA,R1\n         ST    R13,SA+4           CHAIN\n         ST    R1,8(R13)          SAVE AREAS\n         LR    R13,R1             CURRENT SAVE AREA\n         DROP  R1\n         USING DSA,R13            DSA ADDRESSABILITY\n         DROP  R15\n         BALR  R12,0              SETUP PROGRAM ADDRESSABILITY\n         USING *,R12,R11,R10\n         LA    R11,2048(0,R12)    SECOND BASE REGISTER\n         LA    R11,2048(0,R11)\n         LA    R10,2048(0,R11)    THIRD  BASE REGISTER\n         LA    R10,2048(0,R10)\n         BAL   R14,INIT           INITIALIZATION\n         SPACE\n*  OPEN MESSAGE FILE ( PRINT )\n         SPACE\n         OPEN  (PRINT,(OUTPUT))\n         TM    PRINT+48,DCBOFOPN  OPEN SUCCESSFUL        .............?\n         BNO   PRTOPNER           NO, OPEN ERROR         ------------->\n         SPACE\n         BAL   R14,PARMPROC       PARM FIELD PROCESSING\n         SPACE\n*  OPEN INPUT FILE ( TEST DATA DEFINITION )\n         SPACE\n         OPEN  (SYSIN,(INPUT))\n         TM    SYSIN+48,DCBOFOPN  OPEN SUCCESSFUL        .............?\n         BNO   SINOPNER           NO, OPEN ERROR         ------------->\n         SPACE\n*  OPEN OUTPUT FILE ( RESULTING TEST DATA )\n         SPACE\n         OPEN  (OUTF,(OUTPUT))\n         TM    OUTF+48,DCBOFOPN   OPEN SUCCESSFUL        .............?\n         BNO   OUTOPNER           NO, OPEN ERROR         ------------->\n*  CHECK IF VALID RECORD FORMAT\n         TM    OUTF+36,DCBRECU    UNDEFINED              .............?\n         BO    OUTRFMU            YES, O.K.              ------------->\n         TM    OUTF+36,DCBRECF    FIXED LENGTH           .............?\n         BO    OUTRFMF            YES, O.K.              ------------->\n         TM    OUTF+36,DCBRECV    VARIABLE               .............?\n         BNO   INVRECFM           NO, INVALID RECORD FORMAT----------->\n         TM    OUTF+36,DCBRECSB   VARIABLE SPANNED RECORDS............?\n         BO    INVRECFM           YES, INVALID RECORD FORMAT---------->\n         OI    FLAGS,RECFMV       RECFM=V SPECIFIED FOR SYSUT1\n         MVC   LRECL,OUTF+82      MAX RECORD LENGTH = LRECL\n         B     START\nOUTRFMF  OI    FLAGS,RECFMF       RECFM=F SPECIFIED FOR SYSUT1\n         MVC   LRECL,OUTF+82      RECORD LENGTH = LRECL\n         B     START\nOUTRFMU  OI    FLAGS,RECFMU       RECFM=U SPECIFIED FOR SYSUT1\n         MVC   LRECL,OUTF+62      MAX RECORD LENGTH = BLKSIZE\n         B     START\n         SPACE\nSTART    DS    0H                 START OF PROCESSING OF INPUT DATA\nPROCESOR DS    0H                 PROCESS ONE OUTPUT RECORD\n         BAL   R14,INITOR         INITIALIZATION FOR NEW OUTPUT RECORD\n         BAL   R14,PROCIND        PROCESSING OF INPUT DATA\n         BAL   R14,WRITEOR        WRITE OUTPUT RECORD\n         B     PROCESOR           PROCESS NEXT OUTPUT RECORD\n         SPACE\nEOF      DS    0H                 END OF INPUT FILE\n         TM    FLAGS2,CONTEXP     WAS CONTINUATION EXPECTED...........?\n         BO    EOFCEXP            YES, PRINT ERROR MSG     ----------->\n         BAL   R14,WRITEOR        NO, WRITE LAST OUTPUT RECORD\n         B     EOP                PRINT EOP MESSAGE        ----------->\nEOFCEXP  LA    R1,EXPCNRM         EXPECTED CONTINUATION NOT REC. MSG\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         SPACE\n*  END OF PROCESSING\n         SPACE\nEOP      BAL   R14,EOPMSG         END OF PROCESSING MESSAGE\n         BAL   R14,CLOSE          CLOSE REWIND TAPE\n         CLOSE (PRINT)            CLOSE REPORT FILE\n         SPACE\nRET0     XR    R15,R15            RC=0\nRET      L     R0,DSAS            DSASIZE\n         LR    R1,R13             DSA ADDRESS\n         L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         FREEMAIN R,LV=(0),A=(1)  FREEMAIN DSA\n         RETURN (14,12),RC=(15)\n         SPACE\nDSAS     DC    A(DSAE-DSA)        DSA SIZE\nPARMA    DS    A                  ADDRESS OF PARM FIELD\nTIOTA    DS    A                  ADDRESS OF TIOT\n         SPACE\nRC16     LA    R15,16             RC FROM SAVE = 16\n         B     RET                RETURN\n         SPACE 2\nSINOPNER DS    0H                 SYSIN OPEN ERROR\n         MVC   MSGREC1(L'SINOPNEM),SINOPNEM\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     RC16               TERMINATE WITH RC=16\n         SPACE 2\nOUTOPNER DS    0H                 SYSUT1 OPEN ERROR\n         MVC   MSGREC1(L'OUTOPNEM),OUTOPNEM\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     RC16               TERMINATE WITH RC=16\n         SPACE 2\nPRTOPNER DS    0H                 PRINT DCB OPEN ERROR\n         MVC   PRTOPNEM+4(8),JOBNAME JOB NAME INTO MESSAGE TEXT\n         WTO   MF=(E,PRTOPNEM)    WTO   ERROR MESSAGE\n         B     RC16               RETURN CODE = 16\n         SPACE 2\nINVRECFM DS    0H                 SYSUT1 INVALID RECORD FORMAT\n         MVC   MSGREC1(L'INVRFMM),INVRFMM\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     RC16               TERMINATE WITH RC=16\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*  MAJOR PROCESSING OF INPUT RECORDS DATA ( ONE OUTPUT RECORD )       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nPROCIND  SUBENT\nDUPFL    EQU   R4                 LENGTH OF DUPLICATION FACTOR\nDUPFA    EQU   R5                 ADDR.OF DUP. FACTOR DIGIT IN OUTWA\nOFFSL    EQU   R4                 LENGTH OF OFFSET MODIFIER\nOFFSA    EQU   R5                 ADDR.OF OFFSET MODIF. DIGIT IN OUTWA\nLENML    EQU   R4                 LENGTH OF LENGTH MODIFIER\nLENMA    EQU   R5                 ADDR.OF LENGTH MODIF. DIGIT IN OUTWA\nCVALL    EQU   R4                 LENGTH OF CONSTANT'S VALUE\nCVALA    EQU   R5                 ADDR.OF CONST.VALUE CHAR.IN OUTWA\nSCANADR  EQU   R6                 CURRENTLY SCANNED CHARACTER ADDRESS\nSCANLEN  EQU   R7                 LENGTH OF CURRENTLY SCANNED STRING\nABC      EQU   R8                 AVAILABLE BYTE COUNT IN OUTPUT RECORD\n         BAL   R14,GETNREC        GET FIRST INPUT RECORD\n*  SEARCH EITHER : START OF COMMENT OR\n*                  DUPLICATION FACTOR OR\n*                  TYPE OF CONSTANT\nPIDCDT   BAL   R14,NEWCNSTI       INITIALYZATION FOR A NEW CONSTANT\n         LR    R1,SCANLEN         SCAN STRING LENGTH\n         BCTR  R1,0               SCAN STRING LENGTH - 1\n         EX    R1,TRTSCAN         EXECUTE TRANSLATE AND TEST\n         BC    8,PIDNMC           NO MORE CONSTANTS OR COMMENTS ON THIS\n*                                 RECORD\n         LA    SCANADR,0(0,R1)    FOUND CHARACTER ADDRESS\n         LA    SCANLEN,REC80+71\n         SR    SCANLEN,SCANADR    LEFT UNSCANNED STRING LENGTH\n         STC   R2,FUNBYTE         FUNCTION BYTE\n         CLI   FUNBYTE,INVCHC     INVALID CHARACTER FOUND.............?\n         BE    PID1INVC           YES, ERROR             ------------->\n         OI    FLAGS1,CONPINP     CONSTANT PROCESSING IN PROGRESS FLAG\n         LA    R0,72              COLUMN OF CURRENTLY PROCESSED CONST.\n         SR    R0,SCANLEN\n         ST    R0,CCCOL           SAVE CURRENT CONST.COLUMN\n         MVC   CCIRECN,IRECNT     CURRENT CONSTANT RECORD NUMBER\n         MVI   TRT+X'40',INVCHC   BLANK WILL NOT BE IGNORED FROM NOW\n         CLI   FUNBYTE,NUMERIC    NUMERIC FOUND          .............?\n         BE    PIDUPFE            DUPLICATION FACTOR     ------------->\n         CLI   FUNBYTE,SLASH      POSSIBLE START OF COMMENT...........?\n         BE    PIDCOMMP           YES, MAY BE START OF COMMENT ------->\n         B     PIDTYPEF           TYPE SUBFIELD FOUND    ------------->\n* PROBABLY START OF DUPLICATION FACTOR SPECIFICATION\nPIDUPFE  MVI   TRT+X'40',INVCHC   BLANKS NOW INVALID\n         MVI   TRT+C'/',INVCHC    START OF COMMENT INVALID\nPIDUPF   MVC   0(1,DUPFA),0(SCANADR) MOVE FIRST DIGIT OF DUPLICATION\n*                                 FACTOR INTO OUTPUT FIELD\n         LA    DUPFL,1(0,DUPFL)   DUPLICATION FACTOR LENGTH + 1\n         LA    DUPFA,1(0,DUPFA)   ADDRESS OF NEXT DUPLICATION CHARACTER\n         LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT............?\n         BNP   PIDUPFC            NO, CHECK IF CONTINUED ON NEXT CARD->\nPIDUPF0  EX    R0,TRTSCAN         ONLY ONE CHAR IS SCANNED\n         STC   R2,FUNBYTE         FUNCTION BYTE\n         CLI   FUNBYTE,NUMERIC    NUMERIC CHARACTER    ...............?\n         BE    PIDUPF             YES, O.K., CONTINUE  --------------->\n         CLI   FUNBYTE,INVCHC     INVALID CHARACTER    ...............?\n         BE    PID2INVC           YES, INVALID CHAR WITHIN DUPF------->\n*  FUNCTION BYTE AFTER DUPLICATION CHARACTER FOUND\n         CH    DUPFL,=H'5'        DUP FACTOR HAS MORE THAN 5 DIGITS...?\n         BH    PIDUPFLE           YES, DUP FACTOR LENGTH ERROR-------->\n         MVI   VALSIGN,C'+'       POSITIVE VALUE\n         BAL   R14,CONVB          CONVERT DECIMAL CONSTANT TO BINARY\n         C     DUPFL,=F'32768'    MAX VALUE OF DUPLICATION FACTOR EXC.?\n         BH    PIDUPFLE           YES, DUP FACTOR LENGTH ERROR........?\n         ST    DUPFL,DUPF         SAVE DUPLICATION FACTOR VALUE\n         OI    FLAGS1,DUPFP       DUPLICATION FACTOR PRESENT FLAG\n         SPACE\n*  TYPE SUBFIELD FOUND\n         SPACE\nPIDTYPEF DS    0H                 TYPE SUBFIELD FOUND\n         MVI   TRT+X'40',INVCHC   BLANKS NOW INVALID\n         MVI   TRT+C'/',INVCHC    START OF COMMENT INVALID\n         MVI   TRT+C'A',INVCHC    TYPE FILED INVALID ANY MORE\n         MVI   TRT+C'C',INVCHC\n         MVI   TRT+C'F',INVCHC\n         MVI   TRT+C'H',INVCHC\n         MVI   TRT+C'P',INVCHC\n         MVI   TRT+C'X',INVCHC\n         MVI   TRT+C'E',INVCHC\n         MVI   TRT+C'D',INVCHC\n         MVI   TRT+C'Z',INVCHC\n         MVC   TYPE,FUNBYTE       SAVE TYPE CODE\n         CLI   TYPE,TYPEA         TYPE = A             ...............?\n         BE    PIDTFA             YES                  --------------->\n         MVI   TYPEVLD,C''''      VALUE LEFT DELEIMITER\n         MVI   TYPEVRD,C''''      VALUE RIGHT DELIMITER\n         B     PIDTF0             BRANCH AROUND\nPIDTFA   MVI   TYPEVLD,C'('       VALUE LEFT DELEIMITER\n         MVI   TYPEVRD,C')'       VALUE RIGHT DELIMITER\nPIDTF0   LA    SCANADR,1(0,SCANADR) NEXT SCAN CHARACTER ADDRESS\n         SH    SCANLEN,=H'1'      LENGTH OF SCAN STRING - 1\n         BNP   PIDTFC             CHECK IF CONSTANT CONTINUED ON NEXT R\nPIDTF1   CLC   0(1,SCANADR),TYPEVLD VALUE LEFT DELIMITER..............?\n         BE    PIDVLD             YES, VALUE LEFT DELIMITER FOUND----->\n         CLI   0(SCANADR),C'O'    OFFSET MODIFIER       ..............?\n         BE    PIDOFFM            YES, OFFSET MODIFIER SPECIFIED------>\n         CLI   0(SCANADR),C'L'    LENGTH MODIFIER       ..............?\n         BE    PIDLENM            YES, LENGTH MODIFIER SPECIFIED------>\n         B     PID3INVC           INVALID CHARACTER AFTER TYPE FIELD-->\n         SPACE\n*  PROCESSING OF OFFSET MODIFIER\n         SPACE\nPIDOFFM  TM    FLAGS1,OFFSP       OFFSET MODIFIER ALREADY SPECIFIED..?\n         BO    PIDOFFME           YES,ERROR,DUPLICATE SPECIFICATION-->\n         SR    OFFSL,OFFSL        OFFSET STRIN LENGTH = 0 INITIALLY\n         L     OFFSA,OUTRWAA      WORK AREA ADDRESS FOR OFFSET STRING\nPIDOFFM1 LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      LENGHT OF SCAN STRING\n         BNP   PIDOFFMC           CONTINUATION EXPECTED AT THIS POINT->\nPIDOFMC1 EX    R0,TRTSCAN         ONLY ONE CHARACTER IS CHECKED\n         STC   R2,FUNBYTE         FUNCTION BYTE\n         CLI   FUNBYTE,NUMERIC    NUMERIC CHARACTER      .............?\n         BNE   PIDOFFMX           NO, END OF OFFSET MODIFIER---------->\n         MVC   0(1,OFFSA),0(SCANADR) MOVE OFFSET DIGIT INTO OUT FIELD\n         LA    OFFSL,1(0,OFFSL)   LENGTH OF OFFSET STRING + 1\n         LA    OFFSA,1(0,OFFSA)   ADDRESS OF NEXT OUT.OFFS.CHAR.\n         B     PIDOFFM1           CHECK NEXT OFFSET CHAR ------------->\nPIDOFFMX LTR   OFFSL,OFFSL        OFFSET LENGTH > 0      .............?\n         BNP   PIDOFFME           NO, OFFSL = 0, ERROR   ------------->\n         CH    OFFSL,=H'5'        OFFSET LENGTH MORE THAN 5 DIGITS....?\n         BH    PIDOFFME           YES, ERROR             ------------->\n         MVI   VALSIGN,C'+'       POSITIVE VALUE\n         BAL   R14,CONVB          CONVERT OFFSET TO BINARY\n         CH    OFFSL,=H'32767'    GREATER THAN MAX OFFSET VALUE.......?\n         BH    PIDOFFME           YES, ERROR             ------------->\n         TM    FLAGS,RECFMV       VARIABLE OUTREC FORMAT .............?\n         BNO   PIDOFMXX           NO                     ------------->\n         CH    OFFSL,=H'4'        OFFSET LENGTH > RDW    .............?\n         BL    PIDOFFME           NO, OVERALY OF RDW     ------------->\n*  SPECIFICATION OF OFFSET IS O.K.\nPIDOFMXX STH   OFFSL,OFFSET       SAVE OFFSET VALUE\n         OI    FLAGS1,OFFSP       OFFSET PRESENT FLAG\n         B     PIDTF1             PROCESS NEXT SUBFIELD  ------------->\n*  CONTINUATION OF OFFSET SPECIF. EXPECTED ON NEXT RECORD\nPIDOFFMC LA    R14,PIDOFMC1       RETURN ADDRESS\n         B     PIDCCONT           CONSTANT CONTINUATION ON NEXT IREC-->\n*  TYPE SUBFIELD WAS THE LAST CHARACTER ON THIS INPUT RECORD\nPIDTFC   LA    R14,PIDTF1         RETURN ADDRESS (NEXT SUBFIELD PROC.)\n         B     PIDCCONT           CONSTANT CONTINUATION ON NEXT IREC-->\n*  DUPLICATION FACTOR IS EXPECTED TO BE CONTINUED ON NEXT INPUT RECORD\nPIDUPFC  LA    R14,PIDUPF0        RETURN ADDRESS (NEXT DUPF.CHAR PROC.)\n         B     PIDCCONT           CONSTANT CONTINUATION ON NEXT IREC-->\n         SPACE\n*  ERROR IN OFFSET MODIFIER SPECIFICATION\nPIDOFFME LA    R1,OFFSMERM        OFFSET MODIFIER ERROR MESSAGE ADDRESS\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n*  DUPLICATION FACTOR LENGTH ERROR\nPIDUPFLE LA    R1,DUPFLERM        DUPLICATION FACTOR LENGTH ERR.MSG.ADR\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n*  INVALID CHARACTER FOUND\nPID1INVC DS    0H\nPID2INVC DS    0H\nPID3INVC DS    0H\n         BAL   R14,INVCPROC       CHECK IF CONSECUTIVE OCCURENCE\n         LA    R1,INVCHARM        INVALID CHARACTER MESSAGE\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n*  PROCESSING OF LENGTH MODIFIER\n         SPACE\nPIDLENM  TM    FLAGS1,LENMP       LENGTH MODIFIER ALREADY SPECIFIED..?\n         BO    PIDLENME           YES,ERROR,DUPLICATE SPECIFICATION-->\n         SR    LENML,LENML        LENGTH STRIN LENGTH = 0 INITIALLY\n         L     LENMA,OUTRWAA      WORK AREA ADDRESS FOR LENGTH STRING\nPIDLENM1 LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      LENGHT OF SCAN STRING\n         BNP   PIDLENMC           CONTINUATION EXPECTED AT THIS POINT->\nPIDLNMC1 EX    R0,TRTSCAN         ONLY ONE CHARACTER IS CHECKED\n         STC   R2,FUNBYTE         FUNCTION BYTE\n         CLI   FUNBYTE,NUMERIC    NUMERIC CHARACTER      .............?\n         BNE   PIDLENMX           NO, END OF LENGTH MODIFIER---------->\n         MVC   0(1,LENMA),0(SCANADR) MOVE LENGTH DIGIT INTO OUT FIELD\n         LA    LENML,1(0,LENML)   LENGTH OF LENGTH STRING + 1\n         LA    LENMA,1(0,LENMA)   ADDRESS OF NEXT OUT.LENM.CHAR.\n         B     PIDLENM1           CHECK NEXT LENGTH CHAR ------------->\nPIDLENMX LTR   LENML,LENML        LENGTH LENGTH > 0      .............?\n         BNP   PIDLENME           NO, LENML = 0, ERROR   ------------->\n         CH    LENML,=H'5'        LENGTH LENGTH MORE THAN 5 DIGITS....?\n         BH    PIDLENME           YES, ERROR             ------------->\n         MVI   VALSIGN,C'+'       POSITIVE VALUE\n         BAL   R14,CONVB          CONVERT LENGTH TO BINARY\n         C     LENML,=F'32768'    GREATER THAN MAX LENGTH VALUE.......?\n         BH    PIDLENME           YES, ERROR             ------------->\n         CH    LENML,=H'0'        = 0                    .............?\n         BE    PIDLENME           YES, ERROR             ------------->\n         CLI   TYPE,TYPEF         TYPE \"F\" CONSTANT      .............?\n         BE    PIDLENME           YES, ERROR, LEN.MODIF.NOT ALLOWED--->\n         CLI   TYPE,TYPEH         TYPE \"H\" CONSTANT      .............?\n         BE    PIDLENME           YES, ERROR, LEN.MODIF.NOT ALLOWED--->\n         CLI   TYPE,TYPEE         TYPE \"E\" CONSTANT      .............?\n         BE    PIDLENME           YES, ERROR, LEN.MODIF.NOT ALLOWED--->\n         CLI   TYPE,TYPED         TYPE \"D\" CONSTANT      .............?\n         BE    PIDLENME           YES, ERROR, LEN.MODIF.NOT ALLOWED--->\n         CLI   TYPE,TYPEL         TYPE \"L\" CONSTANT      .............?\n         BE    PIDLENME           YES, ERROR, LEN.MODIF.NOT ALLOWED--->\n         CLI   TYPE,TYPEA         TYPE \"A\" CONSTANT      .............?\n         BNE   PIDLNMXP           NO, CHECK IF TYPE \"P\"  ------------->\n         CH    LENML,=H'4'        YES,TYPE \"A\", IS <= 4  .............?\n         BH    PIDLENME           NO, ERROR, TOO LONG    ------------->\nPIDLNMXP CLI   TYPE,TYPEP         TYPE \"P\" CONSTANT      .............?\n         BNE   PIDLNMXZ           NO, CHECK IF TYPE \"Z\"  ------------->\n         CH    LENML,=H'8'        YES, TYPE \"P\", IS <= 8 .............?\n         BH    PIDLENME           NO, TO LARGE VALUE, ERROR----------->\nPIDLNMXZ CLI   TYPE,TYPEZ         TYPE \"Z\" CONSTANT      .............?\n         BNE   PIDLNMXX           NO, EVERYTHING IS O.K. ------------->\n         CH    LENML,=H'15'       YES, TYPE \"Z\", IS <= 15.............?\n         BH    PIDLENME           NO, TO LARGE VALUE, ERROR----------->\n*  SPECIFICATION OF LENGTH IS O.K.\nPIDLNMXX ST    LENML,LENGTHM      SAVE LENGTH VALUE\n         OI    FLAGS1,LENMP       LENGTH PRESENT FLAG\n         B     PIDTF1             PROCESS NEXT SUBFIELD  ------------->\n*  CONTINUATION OF LENGTH SPECIF. EXPECTED ON NEXT RECORD\nPIDLENMC LA    R14,PIDLNMC1       RETURN ADDRESS\n         B     PIDCCONT           CONSTANT CONTINUATION ON NEXT IREC-->\n         SPACE\n*  ERROR IN LENGTH MODIFIER SPECIFICATION\nPIDLENME LA    R1,LENMERM         LENGTH MODIFIER ERROR MESSAGE ADDRESS\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n*  MAY BE START OF COMMENT SPECIFICATION\n         SPACE\nPIDCOMMP DS    0H\n         LA    SCANADR,1(0,SCANADR) NEXT CHAR ADDRESS\n         SH    SCANLEN,=H'1'      SCAN STRING LENGTH - 1\n         BNP   PIDCMLDC           COMMENT LEFT DELIMITER CONTINUATION\nPIDCMLD0 CLI   0(SCANADR),C'*'    LEFT DELIMITER         .............?\n         BNE   PID1INVC           NO, INVALID CHARACTERS ------------->\n*   SEARCH FOR COMMENT RIGHT DELIMITER\nPIDCMRD0 LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      SCAN STRING LENGTH - 1\n         BNP   PIDCRDC1           RIGHT DELIM.IS CONTINUED ON NEXT REC.\nPIDCMRD1 CLI   0(SCANADR),C'*'    POSSIBLY RIGHT DELIMITER............?\n         BNE   PIDCMRD0           NO,CHECK NEXT CHARACTER ------------>\n         LA    SCANADR,1(0,SCANADR) NEXT ( SLASH ? ) CHAR ADDRESS\n         SH    SCANLEN,=H'1'      IS THERE ANY CHAR LEFT ON THIS IREC.?\n         BNP   PIDCRDC2           NO, SLASH MAY BE ON NEXT INPUT REC-->\nPIDCMRD2 CLI   0(SCANADR),C'/'    END OF RIGTH DELIMITER  ............?\n         BNE   PIDCMRD1           NO, LOOK FOR ASTERISK   ------------>\n*   END OF COMMENT RIGHT DELIMITER FOUND\n*!!!!!!!!!!!MAKE PROVISION FOR ONE BLANK SEPARATOR????????????????????\n*!!!!!!!!!!!     DOWN HERE                        ????????????????????\nPIDNEXTC LA    SCANADR,1(0,SCANADR) NEXT CHAR ADDRESS\n         SH    SCANLEN,=H'1'      IS THERE ANY CHAR LEFT ON THIS IREC.?\n         BP    PIDCDT             YES, LOOK NEXT COMMENT OR CONSTANT\n         B     PIDNMC             NO, END OF THIS INPUT RECORD\n*  CONTINUATION OF COMMENT LEFT DELIMITER ON NEXT INPUT REC\nPIDCMLDC LA    R14,PIDCMLD0       RETURN ADDRESS\n         B     PIDCCONT           COMMENT CONTINUATION ON NEXT IREC--->\n*  CONTINUATION OF COMMENT RIGHT DELIMITER ON NEXT INPUT RECORD\n*  ( SEARCH FOR LEADING ASTERISK )\nPIDCRDC1 LA    R14,PIDCMRD1       RETURN ADDRESS\n         B     PIDCCONT           COMMENT CONTINUATION ON NEXT IREC--->\n*  CONTINUATION OF COMMENT RIGHT DELIMITER ON NEXT INPUT RECORD\n*  ( SEARCH FOR ENDING SLASH )\nPIDCRDC2 LA    R14,PIDCMRD2       RETURN ADDRESS\n         B     PIDCCONT           COMMENT CONTINUATION ON NEXT IREC--->\n         SPACE\n*---------------------------------------------------------------------*\n*  PROCESSING OF A CONSTANT VALUE ( EXTRACT ETC )                     *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVLD   DS    0H                 VALUE LEFT DELIMITER IDENTIFIED\n         NI    FLAGS2,X'FF'-INVCHAR AT THIS POINT PREVIOUS INVALID\n*                                 CHARACTER MAY BE DISREGARDED\n         TM    FLAGS1,OFFSP       OFFSET OF THIS CONSTANT SPECIF......?\n         BNO   PIDVLD1            NO, OFFSET EQUAL TO ABC ------------>\n         MVC   OUTOFFS,OFFSET     FIRST CONST.OFFSET SPECIF.EXPLICITLY\n         B     PIDVTS0            CONTINUE                ------------>\nPIDVLD1  STH   ABC,OUTOFFS        OUTPUT OFFSET = AVAILABLE BYTE COUNT\nPIDVTS0  SR    R15,R15            ZERO R15\n         IC    R15,TYPE           CONSTANT TYPE\n         MVC   NVCNT,=H'1'        NOMINAL VALUE COUNT ( FIRST )\n         B     PIDVTS-TYPEA(R15)  CONSTANT TYPE SELECTION\nPIDVTS   B     PIDVTA             TYPE A CONSTANT\n         B     PIDVTC             TYPE C CONSTANT\n         B     PIDVTF             TYPE F CONSTANT\n         B     PIDVTH             TYPE H CONSTANT\n         B     PIDVTP             TYPE P CONSTANT\n         B     PIDVTX             TYPE X CONSTANT\n         B     PIDVTE             TYPE E CONSTANT\n         B     PIDVTD             TYPE D CONSTANT\n         B     PIDVTL             TYPE L CONSTANT\n         B     PIDVTZ             TYPE Z CONSTANT\n         SPACE\n*---------------------------------------------------------------------*\n*  \"A\" TYPE CONSTANT PROCESSING                                       *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTA   DS    0H                 TYPE = A CONSTANT PROCESSING\n         TM    FLAGS1,LENMP       LENGTH MODIFIER SPECIFIED...........?\n         BO    PIDVTAE1           YES, DO NOT PROCESS DEFAULT--------->\n         MVC   LENGTHM,=F'4'      DEFAULT LENGTH MODIFIER ............?\nPIDVTAE1 MVC   OUTCSOFF,OUTOFFS   OFFSET OF FIRST NOMINAL VALUE\nPIDVTAN  DS    0H                 TYPE = P CONSTANT NOMINAL VALUE PROC.\n         BAL   R14,CNVINIT        INIT OF PROCESSING FOR CONST VALUE\nPIDVTA0  LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   PIDVTAC1           NO, CHECK CONTINUATION  ------------>\nPIDVTA1  EX    R0,TRTSCAN         FIND OUT WHAT CHARACTER\n         SLL   R2,24              STRIP 3 H/O BYTES\n         SRL   R2,24              TO GET FUNCTION BYTE VALUE\n         B     PIDVTACS-INVCHC(R2) BR TO CHARACTER SELECTION BR TABLE\nPIDVTACS B     FPVALPIC           INVALID CHARACTER       ------------>\n         B     PIDVTA1O           DECIMAL DIGIT           ------------>\n         B     PIDVTAX            RIGHT DELIMITER         ------------>\n         B     PIDVTAK            COMMA                   ------------>\n         SPACE\nPIDVTA1O MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         B     PIDVTA0            CHECK NEXT CHARACTER    ------------>\nPIDVTAK  DS    0H                 COMMA, MULTIPLE VALUES SPECIFIED\n         BAL   R14,BINVALP        BINARY NOMINAL VALUE PROCESSING\n         B     PIDVTAN            NEXT NOMINAL VALUE PROCESSING\n* END OF BINARY UNSIGNED CONSTANT FOUND\nPIDVTAX  BAL   R14,BINVALP        PROCESS LAST NOMINAL VALUE\n         BAL   R14,DUPFPROC       PROCESS DUPLICATION FACTOR IF SPECIF\n         B     PIDNEXTC           PROCESSING OF THE NEXT CONSTANT\n*  CONTINUATION OF PACKED DECIMAL CONSTANT ON NEXT INPUT RECORD\nPIDVTAC1 LA    R14,PIDVTA1        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n         SPACE\n* PROCESSING OF BINARY UNSIGNED CONSTANT NOMINAL VALUE ( TYPE A )\nBINVALP  SUBENT\n         LTR   CVALL,CVALL        IS VALUE LENGTH > 0    .............?\n         BNP   BINVALL0           NO, LENGTH = 0         ------------->\n         CH    CVALL,=H'15'       IS CONSTANT'S LENGTH <= 15 DIGITS...?\n         BH    BINVALL1           NO, MAX LENGTH EXCEEDED------------->\n         MVI   VALSIGN,C'+'       ALWAYS POSITIVE VALUE\n         BAL   R14,CONVB          CONVERT NOMINAL VALUE TO BINARY\n         ST    CVALL,D            SAVE VALUE IN \"D\"\n         L     R15,LENGTHM        LENGTH MODIFIER\n         L     R1,=F'4'           DEFAULT LENGTHM\n         CR    R1,R15             DEFAULT LENGTH          ............?\n         BE    BINVPDL            YES, DO NOT CHECK VALUE ------------>\n         SR    R1,R15             DEF.LENM-LENGTHM\n         BCTR  R1,0               NO.OF FREE LEADING BYTES - 1\n         EX    R1,CLCBINVL        IS BINARY VALUE WITHIN LIMITS.......?\n         BNE   BINMVEX            MAXIMUM VALUE EXCEEDED-------------->\n         L     R1,=F'4'           RELOAD DEFAULT\nBINVPDL  LH    R0,OUTOFFS        OUTPUT OFFSET\n         LR    R14,R0\n         A     R14,OUTRA          LOCATION IN OUTREC\n         AR    R0,R15             OFFSET + LENGTH OF CONSTANT\n         CH    R0,LRECL           LRECL EXCEEDED          ............?\n         BH    BINVLEXC           YES, LRECL EXCEEDED     ------------>\n         STH   R0,OUTOFFS         NEW OUTPUT OFFSET\n         CR    R0,ABC             IS GREATER THAN \"ABC\"   ............?\n         BNH   BINVPM             NO, SKIP AROUND CHANGE  ------------>\n         LR    ABC,R0             YES, CHANGE \"ABC\" TO HIGHER VALUE...?\nBINVPM   SR    R1,R15             4 - LENGTHM\n         LA    R1,D(R1)           ADDR.OF FIRST BYTE OF CONSTANT\n         BCTR  R15,0              LENGTHM - 1\n         EX    R15,MVCBINVL       MOVE BINARY VALUE INTO OUTPUT RECORD=\nBINVALPR SUBRET BINVALP           RETURN\nCLCBINVL CLC   D(1),=10X'00'      IS BINARY CONSTANT WITHIN LIMITS....?\nMVCBINVL MVC   0(1,R14),0(R1)     MOVE TYPE A CONST.INTO OUTREC========\n         SPACE\n*  TYPE \"A\" CONSTANT NOMINAL VALUE LENGTH = 0 CHARACTERS\nBINVALL0 DS    0H\n         LA    R1,DECVLL0M        MESSAGE ADDRESS\nBINVALER BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     BINVALPR           RETURN FROM NOMINAL VALUE PROCESSING\n         SPACE\n*   CONSTANT NOMINAL VALUE MEX. LENGTH EXCEEDED\nBINVALL1 DS    0H\n         LA    R1,DECVLLMM        MESSAGE ADDRESS\n         B     BINVALER           PRINT ERROR MESSAGE\n         SPACE\n*   CONSTANT NOMINAL VALUE OUT OF ALLOWABLE RANGE\nBINMVEX  DS    0H                 MAXIMUM VALUE EXCEEDED\n         LA    R1,VALOORM         MESSAGE ADDRESS\n         B     BINVALER           PRINT ERROR MESSAGE\n         SPACE\n*   LRECL EXCEEDED FOR TYPE \"A\" CONSTANT\nBINVLEXC DS    0H\n         TM    FLAGS2,LRECLEX     MESSAGE ALREADY PRINTED.............?\n         BO    BINVALPR           YES, RETURN FROM FIX.VALUE PROC----->\n         OI    FLAGS2,LRECLEX     SET THIS MSG PRINTED ALREADY FLAG\n         LA    R1,LRECEXCM        MESSAGE ADDRESS\n         B     BINVALPR           PRINT ERROR MESSAGE\n         SPACE\n*---------------------------------------------------------------------*\n*  \"F\" TYPE CONSTANT PROCESSING                                       *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTF   DS    0H                 TYPE = F CONSTANT PROCESSING\n         MVC   FPNVL,=H'15'       MAX.NOMIMAL VALUE LENGTH\n         MVC   FPMAXV,=X'7FFFFFFF' MAXIMUM VALUE\n         MVC   FPMINV,=X'80000000' MINIMUM VALUE\nPIDVTF1  EQU   *\n         BAL   R14,FPVALP         FIXED POINT VALUE PROCESSING\n         BAL   R14,DUPFPROC       PROCESS DUPLICATION FACTOR IF SPECIF\n         B     PIDNEXTC           PROCESSING OF NEXT CONSTANT\n         SPACE\n*---------------------------------------------------------------------*\n*  \"H\" TYPE CONSTANT PROCESSING                                       *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTH   DS    0H                 TYPE = H CONSTANT PROCESSING\n         MVC   FPNVL,=H'5'        MAX.NOMIMAL VALUE LENGTH\n         MVC   FPMAXV,=X'00007FFF' MAXIMUM VALUE\n         MVC   FPMINV,=X'FFFF8000' MINIMUM VALUE\n         B     PIDVTF1            CONTINUE              -------------->\n         SPACE\n*---------------------------------------------------------------------*\n*  CHARACTER TYPE CONSTANT PROCESSING                                 *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTC   DS    0H                 TYPE = C CONSTANT PROCESSING\n         BAL   R14,CNVINIT        INIT OF PROCESSING FOR CONST VALUE\n         TM    FLAGS1,LENMP       LENGTH MODIFIER SPECIFIED...........?\n         BNO   PIDVTC0            NO, DO NOT INITIALYZE OURWA\n* LENGTH MODIF. SPECIFIED - INITIALYZE WORK AREA WITH BLANKS\n         L     R1,LENGTHM         LENGTH MODIFIER VALUE\n         L     R0,OUTRWAA         WORK AREA ADDRESS\n         IC    R15,=X'40'         PAD CHARACTER ( BLANK )\n         SLL   R15,24             SHIFT IT INTO BIT POSITION 0-7\n         MVCL  R0,R14             INITIALYZE WORK AREA WITH BLANKS\nPIDVTC0  LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   PIDVTCC1           NO, CHECK CONTINUATION  ------------>\nPIDVTC1  CLC   0(1,SCANADR),TYPEVRD   RIGHT DELIMITER     ............?\n         BE    PIDVTCR1           PROBABLY RIGHT DELIMITER------------>\nPIDVTC1O MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         B     PIDVTC0            CHECK NEXT CHARACTER    ------------>\nPIDVTCR1 LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   PIDVTCC2           NO, CHECK CONTINUATION  ------------>\nPIDVTC2  CLC   0(1,SCANADR),TYPEVRD   TWO CONSECUTIVE DELIMITERS......?\n* TWO CONSECUTIVE RIGHT DELIMITERS GIVE ONE CHARACTER\n         BE    PIDVTC1O           MOVE ONE DELIMITER TO OUTPUT\n         BCTR  SCANADR,0          NO, PREVIOUS CHAR ADDRESS\n         LA    SCANLEN,1(,SCANLEN) NO OF CHARS LEFT ON THE CARD\n* END OF CHARACTER CONSTANT FOUND\nPIDVTCX  DS    0H\n         TM    FLAGS1,LENMP       LENGTH MODIFIER SPECIFIED...........?\n         BNO   PIDVTCX0           NO, DEFAULT LENGTH       ----------->\n         C     CVALL,LENGTHM      IS DEFAULT LENGTH <= LENGTH MODIF...?\n         BH    CVALELE            NO, ERROR, TOO LONG CONST. SPECIF--->\n         L     CVALL,LENGTHM      EXPLICIT LENGTH WILL BE TAKEN\nPIDVTCX0 LA    R15,1              DEFAULT DUPLICATION FACTOR\n         TM    FLAGS1,DUPFP       DUPLICATION FACTOR WAS SPECIFIED....?\n         BNO   PIDVTCX1           NO, TAKE DEFAULT        ------------>\n         L     R15,DUPF           YES, VALUE OF DUPLICATION FACTOR\nPIDVTCX1 LH    R1,OUTOFFS         OUTPUT OFFSET\n         LR    R0,R1\n         AR    R1,CVALL           OFFSET + CHAR.STRING LENGTH = RECL\n         CH    R1,LRECL           LRECL EXCEEDED          ............?\n         BH    LRECLEXC           YES, LRECL EXCEEDED     ------------>\n         STH   R1,OUTOFFS         NEW OUTPUT OFFSET\n         CR    R1,ABC             IS GREATER THAN \"ABC\"   ............?\n         BNH   PIDVTCX2           NO, SKIP AROUND CHANGE  ------------>\n         LR    ABC,R1             YES, CHANGE \"ABC\" TO HIGHER VALUE...?\nPIDVTCX2 A     R0,OUTRA           OUTOFFS + OUT.REC.ADDR = OUT MVCL ADR\n         LR    R1,CVALL           MOVED CHAR STRING LENGTH\n         L     R2,OUTRWAA         MOVED ( INPUT ) STRING ADDRESS\n         LR    R3,CVALL           MOVED STRING LENGTH\n         MVCL  R0,R2              MOVE CHAR.CONST.VALUE INTO OUT.REC.\n         BCT   R15,PIDVTCX1       REPEAT MOVEMENT DUPF TIMES---------->\n         B     PIDNEXTC           PROCESSING OF NEXT CONSTANT\n*  CONTINUATION OF CHARACTER CONSTANT ON NEXT INPUT RECORD\nPIDVTCC1 LA    R14,PIDVTC1        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n*  CONTINUATION OF CHARACTER CONSTANT (RIGHT DELIM.FOUND IN COL 71)\nPIDVTCC2 CLI   0(SCANADR),X'40'   IS RECORD TO BE CONTINUED...........?\n         BNE   PIDVTCC3           YES, READ NEXT INPUT RECORD--------->\n         BCTR  SCANADR,0          NO, PREVIOUS CHAR ADDRESS\n         LA    SCANLEN,1(,SCANLEN) NO.OF CHARS LEFT ON THE CARD\n         B     PIDVTCX            END OF CONSTANT PROCESSING---------->\nPIDVTCC3 LA    R14,PIDVTC2        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n         SPACE\n*  LRECL EXCEEDED BY LAST PROCESSED CONSTANT\nLRECLEXC TM    FLAGS2,LRECLEX     MESSAGE ALREADY PRINTED.............?\n         BO    PIDNEXTC           YES, PROCESS NEXT CONSTANT---------->\n         OI    FLAGS2,LRECLEX     SET THIS MSG PRINTED ALREADY FLAG\n         LA    R1,LRECEXCM        LRECL EXCEEDED MESSAGE TEXT ADDRESS\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n*  CHARACTER CONSTANT EXPLICIT LENGTH > LENGTH MODIFIER\nCVALELE  DS    0H\n         LA    R1,VALELEM         MESSAGE ADDRESS\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         L     CVALL,LENGTHM      VALUE WILL BE TRUNCATED TO EXPLICIT\n         B     PIDVTCX0           LENGTH                 ------------->\n         SPACE\n*---------------------------------------------------------------------*\n*  PACKED DECIMAL CONSTANT PROCESSING                                 *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTP   DS    0H                 TYPE = P CONSTANT PROCESSING\n         MVC   OUTCSOFF,OUTOFFS   OFFSET OF FIRST NOMINAL VALUE\nPIDVTPN  DS    0H                 TYPE = P CONSTANT NOMINAL VALUE PROC.\n         BAL   R14,CNVINIT        INIT OF PROCESSING FOR CONST VALUE\nPIDVTP0  LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   PIDVTPC1           NO, CHECK CONTINUATION  ------------>\nPIDVTP1  EX    R0,TRTSCAN         FIND OUT WHAT CHARACTER\n         SLL   R2,24              STRIP 3 H/O BYTES\n         SRL   R2,24              TO GET FUNCTION BYTE VALUE\n         B     PIDVTPCS-INVCHC(R2) BR TO CHARACTER SELECTION BR TABLE\nPIDVTPCS B     PIDVTPIC           INVALID CHARACTER       ------------>\n         B     PIDVTP1O           DECIMAL DIGIT           ------------>\n         B     PIDVTPS            DECIMAL SIGN            ------------>\n         B     PIDVTPP            DECIMAL POINT           ------------>\n         B     PIDVTPK            COMMA                   ------------>\n         B     PIDVTPX            RIGHT DELIMITER         ------------>\n         SPACE\nPIDVTP1O MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTP0            CHECK NEXT CHARACTER    ------------>\nPIDVTPS  MVC   VALSIGN,0(SCANADR) SIGN OF THE VALUE\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTP0            CHECK NEXT CHARACTER    ------------>\nPIDVTPP  MVI   TRT+C'.',INVCHC    DECIMAL POINT IS NO LONGER VALID CHAR\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTP0            CHECK NEXT CHARACTER    ------------>\nPIDVTPK  DS    0H                 COMMA, MULTIPLE VALUES SPECIFIED\n         BAL   R14,DECVALP        DECIMAL NOMINAL VALUE PROCESSING\n         B     PIDVTPN            NEXT NOMINAL VALUE PROCESSING\n* END OF PACKED DECIMAL CONSTANT FOUND\nPIDVTPX  BAL   R14,DECVALP        PROCESS LAST NOMINAL VALUE\n         BAL   R14,DUPFPROC       PROCESS DUPLICATION FACTOR IF SPECIF\n         B     PIDNEXTC           PROCESSING OF THE NEXT CONSTANT\n*  CONTINUATION OF PACKED DECIMAL CONSTANT ON NEXT INPUT RECORD\nPIDVTPC1 LA    R14,PIDVTP1        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n         SPACE\n*  INVALID CHARACTER IN PACKED DECIMAL CONSTANT VALUE\nPIDVTPIC DS    0H\n         BAL   R14,INVCPROC       CHECK IF CONSECUTIVE OCCURENCE\n         LA    R1,INVCHARM        INVALID CHARACTER MESSAGE\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n* PACKED DECIMAL CONSTANT NOMINAL VALUE PROCESSING\n         SPACE\nDECVALP  SUBENT\n         LTR   CVALL,CVALL        IS VALUE LENGTH > 0    .............?\n         BNP   DECVALL0           NO, LENGTH = 0         ------------->\n         CH    CVALL,=H'15'       IS CONSTANT'S LENGTH <= 15 DIGITS...?\n         BH    DECVALL1           NO, MAX LENGTH EXCEEDED------------->\n         BAL   R14,CONVDEC        CONVERT NOMINAL VALUE TO DECIMAL\n*                                 CVALL CONTAINS LENGTH OF SIGNIFICANT\n*                                 BYTES IN WORK FIELD \"D\"\n         TM    FLAGS1,LENMP       LENGTH MODIFIER SPECIFIED...........?\n         BNO   DECVALDL           NO, DEFAULT LENGTH       ----------->\n         C     CVALL,LENGTHM      IS DEFAULT LENGTH <= LENGTH MODIF...?\n         BH    DECVALL2           NO, ERROR, TOO LARGE VALUE SPECIF--->\n         L     CVALL,LENGTHM      EXPLICIT LENGTH WILL BE TAKEN\nDECVALDL EQU   *\n         LH    R1,OUTOFFS         OUTPUT OFFSET\n         LR    R14,R1\n         AR    R1,CVALL           OFFSET + CHAR.STRING LENGTH = RECL\n         CH    R1,LRECL           LRECL EXCEEDED          ............?\n         BH    DECVLEXC           YES, LRECL EXCEEDED     ------------>\n         STH   R1,OUTOFFS         NEW OUTPUT OFFSET\n         CR    R1,ABC             IS GREATER THAN \"ABC\"   ............?\n         BNH   DECVAL1            NO, SKIP AROUND CHANGE  ------------>\n         LR    ABC,R1             YES, CHANGE \"ABC\" TO HIGHER VALUE...?\nDECVAL1  A     R14,OUTRA          OUTOFFS + OUT.REC.ADDR = OUT MVC ADR\n         LA    R2,8               LENGTH OF \"D\" FIELD\n         SR    R2,CVALL           NO.OF LEEDING BYTES FROM \"D\" TO BE\n*                                 IGNORED\n         LA    R2,D(R2)           ADDRESS OF FIRST BYTE FROM \"D\" TO BE\n*                                 MOVED\n         BCTR  CVALL,0            NO.OF MOVED BYTES - 1\n         EX    CVALL,MVCDECV      MOVE PACKED DECIMAL VALUE INTO OUTREC\nDECVALR  SUBRET DECVALP           RETURN TO CALLER\nMVCDECV  MVC   0(1,R14),0(R2)     MOVE PACKED DEC.VALUE TO OUTPUT REC\n         SPACE\n*  TYPE \"P\" CONSTANT NOMINAL VALUE LENGTH = 0 CHARACTERS\nDECVALL0 DS    0H\n         LA    R1,DECVLL0M        MESSAGE ADDRESS\nDECVALER BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     DECVALR            RETURN FROM DECIMAL VALUE PROC.\n         SPACE\n*  TYPE \"P\" CONSTANT NOMINAL VALUE LENGTH > 15 CHARACTERS\nDECVALL1 DS    0H\n         LA    R1,DECVLLMM        MESSAGE ADDRESS\n         B     DECVALER           PRINT ERROR MESSAGE\n         SPACE\n*  TYPE \"P\" CONSTANT NOMINAL VALUE IMPLICIT LENGTH > LENGTH MODIFIER\nDECVALL2 DS    0H\n         LA    R1,VALELEM         MESSAGE ADDRESS\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         L     CVALL,LENGTHM      VALUE WILL BE TRUNCATED TO EXPLICIT\n         B     DECVALDL           LENGTH                 ------------->\n         SPACE\n*  TYPE \"P\" CONSTANT - LRECL EXCEEDED\nDECVLEXC DS    0H\n         TM    FLAGS2,LRECLEX     MESSAGE ALREADY PRINTED.............?\n         BO    DECVALR            YES, RETURN FROM DEC.VALUE PROC----->\n         OI    FLAGS2,LRECLEX     SET THIS MSG PRINTED ALREADY FLAG\n         LA    R1,LRECEXCM        MESSAGE ADDRESS\n         B     DECVALER           PRINT ERROR MESSAGE\n         SPACE\n*---------------------------------------------------------------------*\n*  ZONED  DECIMAL CONSTANT PROCESSING                                 *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTZ   DS    0H                 TYPE = Z CONSTANT PROCESSING\n         MVC   OUTCSOFF,OUTOFFS   OFFSET OF FIRST NOMINAL VALUE\nPIDVTZN  DS    0H                 TYPE = Z CONSTANT NOMINAL VALUE PROC.\n         BAL   R14,CNVINIT        INIT OF PROCESSING FOR CONST VALUE\nPIDVTZ0  LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   PIDVTZC1           NO, CHECK CONTINUATION  ------------>\nPIDVTZ1  EX    R0,TRTSCAN         FIND OUT WHAT CHARACTER\n         SLL   R2,24              STRIP 3 H/O BYTES\n         SRL   R2,24              TO GET FUNCTION BYTE VALUE\n         B     PIDVTZCS-INVCHC(R2) BR TO CHARACTER SELECTION BR TABLE\nPIDVTZCS B     PIDVTZIC           INVALID CHARACTER       ------------>\n         B     PIDVTZ1O           DECIMAL DIGIT           ------------>\n         B     PIDVTZS            DECIMAL SIGN            ------------>\n         B     PIDVTZP            DECIMAL POINT           ------------>\n         B     PIDVTZK            COMMA                   ------------>\n         B     PIDVTZX            RIGHT DELIMITER         ------------>\n         SPACE\nPIDVTZ1O MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTZ0            CHECK NEXT CHARACTER    ------------>\nPIDVTZS  MVC   VALSIGN,0(SCANADR) SIGN OF THE VALUE\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTZ0            CHECK NEXT CHARACTER    ------------>\nPIDVTZP  MVI   TRT+C'.',INVCHC    DECIMAL POINT IS NO LONGER VALID CHAR\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTZ0            CHECK NEXT CHARACTER    ------------>\nPIDVTZK  DS    0H                 COMMA, MULTIPLE VALUES SPECIFIED\n         BAL   R14,ZONVALP        ZONED   NOMINAL VALUE PROCESSING\n         B     PIDVTZN            NEXT NOMINAL VALUE PROCESSING\n* END OF ZONED  DECIMAL CONSTANT FOUND\nPIDVTZX  BAL   R14,ZONVALP        PROCESS LAST NOMINAL VALUE\n         BAL   R14,DUPFPROC       PROCESS DUPLICATION FACTOR IF SPECIF\n         B     PIDNEXTC           PROCESSING OF THE NEXT CONSTANT\n*  CONTINUATION OF ZONED DECIMAL CONSTANT ON NEXT INPUT RECORD\nPIDVTZC1 LA    R14,PIDVTZ1        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n         SPACE\n*  INVALID CHARACTER IN ZONED  DECIMAL CONSTANT VALUE\nPIDVTZIC DS    0H\n         BAL   R14,INVCPROC       CHECK IF CONSECUTIVE OCCURENCE\n         LA    R1,INVCHARM        INVALID CHARACTER MESSAGE\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n* ZONED  DECIMAL CONSTANT NOMINAL VALUE PROCESSING\n         SPACE\nZONVALP  SUBENT\n         LTR   CVALL,CVALL        IS VALUE LENGTH > 0    .............?\n         BNP   ZONVALL0           NO, LENGTH = 0         ------------->\n         CH    CVALL,=H'15'       IS CONSTANT'S LENGTH <= 15 DIGITS...?\n         BH    ZONVALL1           NO, MAX LENGTH EXCEEDED------------->\n         STH   CVALL,EDSGD        SAVE NUMBER OF SPECIFIED DIGITS\n         BAL   R14,CONVDEC        CONVERT NOMINAL VALUE TO DECIMAL\n         LH    CVALL,EDSGD        RESTORE NUMBER OF SPECIFIED DIGITS\n         UNPK  ZONED,D            UNPACK VALUE TO ZONED FORMAT\n         TM    FLAGS1,LENMP       LENGTH MODIFIER SPECIFIED...........?\n         BNO   ZONVALDL           NO, DEFAULT LENGTH       ----------->\n         L     CVALL,LENGTHM      YES, EXPLICIT LENGTH WILL BE TAKEN\nZONVALDL EQU   *\n         LH    R1,OUTOFFS         OUTPUT OFFSET\n         LR    R14,R1\n         AR    R1,CVALL           OFFSET + CHAR.STRING LENGTH = RECL\n         CH    R1,LRECL           LRECL EXCEEDED          ............?\n         BH    ZONVLEXC           YES, LRECL EXCEEDED     ------------>\n         STH   R1,OUTOFFS         NEW OUTPUT OFFSET\n         CR    R1,ABC             IS GREATER THAN \"ABC\"   ............?\n         BNH   ZONVAL1            NO, SKIP AROUND CHANGE  ------------>\n         LR    ABC,R1             YES, CHANGE \"ABC\" TO HIGHER VALUE...?\nZONVAL1  A     R14,OUTRA          OUTOFFS + OUT.REC.ADDR = OUT MVC ADR\n         LA    R2,15              LENGTH OF \"ZONED\" FIELD\n         SR    R2,CVALL           NO.OF LEEDING BYTES FROM \"ZONED\"\n*                                 TO BE IGNORED\n         BZ    ZONVAL2            THERE IS NO TRUNCATION ( R2=0 )\n         BCTR  R2,0               NO OF IGNORED BYTES - 1\n         EX    R2,CLCZONT         ARE NON ZERO DIGITS TRUNCATED.......?\n         BNE   ZONVALL2           YES, PRINT WARNING MESSAGE---------->\nZONVAL11 LA    R2,1(0,R2)         NO, RESTORE VALUE OF R2\nZONVAL2  LA    R2,ZONED(R2)       ADDRESS OF FIRST BYTE FROM \"ZONED\"\n*                                 TO BE MOVED\n         BCTR  CVALL,0            NO.OF MOVED BYTES - 1\n         EX    CVALL,MVCZONV      MOVE ZONED  DECIMAL VALUE INTO OUTREC\nZONVALR  DS     0H\n         SUBRET ZONVALP           RETURN TO CALLER\nMVCZONV  MVC   0(1,R14),0(R2)     MOVE ZONED  DEC.VALUE TO OUTPUT REC\nCLCZONT  CLC   ZONED(1),=C'00000000000000' CHECK IF TRUNCATION TOOK\n*                                          PLACE\n         SPACE\n*  TYPE \"Z\" CONSTANT NOMINAL VALUE LENGTH = 0 CHARACTERS\nZONVALL0 DS    0H\n         LA    R1,DECVLL0M        MESSAGE ADDRESS\nZONVALER BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     ZONVALR            RETURN FROM ZONED VALUE PROC.\n         SPACE\n*  TYPE \"Z\" CONSTANT NOMINAL VALUE LENGTH > 15 CHARACTERS\nZONVALL1 DS    0H\n         LA    R1,DECVLLMM        MESSAGE ADDRESS\n         B     ZONVALER           PRINT ERROR MESSAGE\n         SPACE\n*  TYPE \"Z\" CONSTANT NOMINAL VALUE IMPLICIT LENGTH > LENGTH MODIFIER\nZONVALL2 DS    0H\n         ST    R2,EDE             SAVE VALUE OF R2\n         ST    R14,EDD            SAVE R14\n         LA    R1,VALELEM         MESSAGE ADDRESS\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         L     R2,EDE             RESTORE VALUE OF R2\n         L     R14,EDD            RESTORE R14\n         B     ZONVAL11           CONTINUE               ------------->\n         SPACE\n*  TYPE \"Z\" CONSTANT - LRECL EXCEEDED\nZONVLEXC DS    0H\n         TM    FLAGS2,LRECLEX     MESSAGE ALREADY PRINTED.............?\n         BO    ZONVALR            YES, RETURN FROM DEC.VALUE PROC----->\n         OI    FLAGS2,LRECLEX     SET THIS MSG PRINTED ALREADY FLAG\n         LA    R1,LRECEXCM        MESSAGE ADDRESS\n         B     ZONVALER           PRINT ERROR MESSAGE\n         SPACE\n*---------------------------------------------------------------------*\n*  FIXED POINT ( BINARY ) VALUE PROCESSING ( TYPE \"F\" AND \"H\" )       *\n*---------------------------------------------------------------------*\n         SPACE\nFPVALP   SUBENT\n         TM    FLAGS1,OFFSP       ALIGNMENT HAS TO BE PERFORMED.......?\n         BO    FPVALPN0           NO, OUTOFFS WILL NOT BE CHANGED----->\n         TM    PARMFLGS,ALIGN     ALIGNMENT HAS TO BE PERFORMED.......?\n         BNO   FPVALPN0           NO, OUTOFFS WILL NOT BE CHANGED----->\n         TM    OUTOFFS+1,BIT6+BIT7 IS ALREADY ON FULLWORD BOUNDARY....?\n         BZ    FPVALPN0           YES, ALREADY ALIGNED    ------------>\n         LH    R1,OUTOFFS         OUTPUT OFFSET\n         CLI   TYPE,TYPEF         TYPE \"F\" CONSTANT       ............?\n         BNE   FPVPH              NO, TYPE \"H\"            ------------>\n* TYPE \"F\" CONSTANT\n         TM    OUTOFFS+1,BIT6+BIT7 ALL LAST TWO BITS ON   ............?\n         BO    FPVALGN1           YES, ADD 1 TO OUTOFFS   ------------>\n         TM    OUTOFFS+1,BIT6     BIT6 ON                 ............?\n         BO    FPVALGN2           YES, ADD 2 TO OUTOFFS   ------------>\n         LA    R1,3(0,R1)         NO, ADD 3\n         B     FPVALGNX           EXIT FROM ALIGNMENT     ------------>\nFPVALGN2 LA    R1,2(0,R1)         ADD 2 TO OUTOFFS\n         B     FPVALGNX           EXIT FROM ALIGNMENT     ------------>\n         SPACE\n*---------------------------------------------------------------------*\n* TYPE \"H\" CONSTANT                                                   *\n*---------------------------------------------------------------------*\n         SPACE\nFPVPH    TM    OUTOFFS+1,BIT7     REQUIRES ALIGNMENT      ............?\n         BZ    FPVALPN0           NO                      ------------>\nFPVALGN1 LA    R1,1(0,R1)         YES, ADD 1 TO OUTOFFS\nFPVALGNX STH   R1,OUTOFFS         SAVE NEW OUTPUT OFFSET\nFPVALPN0 MVC   OUTCSOFF,OUTOFFS   OFFSET OF FIRST NOMINAL VALUE\nFPVALPN  DS    0H                 TYPE = P CONSTANT NOMINAL VALUE PROC.\n         BAL   R14,CNVINIT        INIT OF PROCESSING FOR CONST VALUE\nFPVALP0  LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   FPVALPC1           NO, CHECK CONTINUATION  ------------>\nFPVALP1  EX    R0,TRTSCAN         FIND OUT WHAT CHARACTER\n         SLL   R2,24              STRIP 3 H/O BYTES\n         SRL   R2,24              TO GET FUNCTION BYTE VALUE\n         B     FPVALPCS-INVCHC(R2) BR TO CHARACTER SELECTION BR TABLE\nFPVALPCS B     FPVALPIC           INVALID CHARACTER       ------------>\n         B     FPVALP1O           DECIMAL DIGIT           ------------>\n         B     FPVALPS            DECIMAL SIGN            ------------>\n         B     FPVALPP            DECIMAL POINT           ------------>\n         B     FPVALPK            COMMA                   ------------>\n         B     FPVALPX            RIGHT DELIMITER         ------------>\n         SPACE\nFPVALP1O MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     FPVALP0            CHECK NEXT CHARACTER    ------------>\nFPVALPS  MVC   VALSIGN,0(SCANADR) SIGN OF THE VALUE\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     FPVALP0            CHECK NEXT CHARACTER    ------------>\nFPVALPP  MVI   TRT+C'.',INVCHC    DECIMAL POINT IS NO LONGER VALID CHAR\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     FPVALP0            CHECK NEXT CHARACTER    ------------>\nFPVALPK  DS    0H                 COMMA, MULTIPLE VALUES SPECIFIED\n         BAL   R14,FPNVP          NOMINAL VALUE PROCESSING\n         B     FPVALPN            NEXT NOMINAL VALUE PROCESSING\n* END OF FIXED POINT CONSTANT FOUND\nFPVALPX  BAL   R14,FPNVP          PROCESS LAST NOMINAL VALUE\n         B     FPVALPR            RETURN\n*  CONTINUATION OF FIXED POINT CONSTANT ON NEXT INPUT RECORD\nFPVALPC1 LA    R14,FPVALP1        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n         SPACE\n*  INVALID CHARACTER IN FIXED POINT CONSTANT VALUE\nFPVALPIC DS    0H\n         BAL   R14,INVCPROC       CHECK IF CONSECUTIVE OCCURENCE\n         LA    R1,INVCHARM        INVALID CHARACTER MESSAGE\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n*  TYPE \"F\" OR \"H\" CONSTANT NOMINAL VALUE LENGTH = 0 CHARACTERS\nFPVALL0  DS    0H\n         LA    R1,DECVLL0M        MESSAGE ADDRESS\nFPVALER  BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     FPVALPR            RETURN FROM FIX.POINT VALUE PROC.\n         SPACE\n*   CONSTANT NOMINAL VALUE MEX. LENGTH EXCEEDED\nFPVALL1  DS    0H\n         LA    R1,DECVLLMM        MESSAGE ADDRESS\n         B     FPVALER            PRINT ERROR MESSAGE\n         SPACE\n*   CONSTANT NOMINAL VALUE OUT OF ALLOWABLE RANGE\nFPMAXVEX DS    0H\nFPMINVEX DS    0H\n         LA    R1,VALOORM         MESSAGE ADDRESS\n         B     FPVALER            PRINT ERROR MESSAGE\n         SPACE\n*   LRECL EXCEEDED FOR TYPE \"F\" OR \"H\" CONSTANT\nFPVLEXC  DS    0H\n         TM    FLAGS2,LRECLEX     MESSAGE ALREADY PRINTED.............?\n         BO    FPVALPR            YES, RETURN FROM FIX.VALUE PROC----->\n         OI    FLAGS2,LRECLEX     SET THIS MSG PRINTED ALREADY FLAG\n         LA    R1,LRECEXCM        MESSAGE ADDRESS\n         B     FPVALER            PRINT ERROR MESSAGE\n         SPACE\n*---------------------------------------------------------------------*\n*  FLOATING POINT CONSTANTS (TYPE=E OR D) PROCESSING                  *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTE   DS    0H                 TYPE = E CONSTANT PROCESSING\nPIDVTD   DS    0H                 TYPE = D CONSTANT PROCESSING\nPIDVTL   DS    0H                 TYPE = L CONSTANT PROCESSING\n         BAL   R14,EDALIGN        ALIGNMENT PROCESSING\n         MVC   OUTCSOFF,OUTOFFS   OFFSET OF FIRST NOMINAL VALUE\nPIDVTDN  DS    0H                 TYPE = D CONSTANT NOMINAL VALUE PROC.\n         XC    EDD(EDCEND-EDD),EDD INITIALYSE CONSTANTS\n         BAL   R14,CNVINIT        INIT OF PROCESSING FOR CONST VALUE\nPIDVTD0  LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   PIDVTDC1           NO, CHECK CONTINUATION  ------------>\nPIDVTD1  EX    R0,TRTSCAN         FIND OUT WHAT CHARACTER\n         SLL   R2,24              STRIP 3 H/O BYTES\n         SRL   R2,24              TO GET FUNCTION BYTE VALUE\n         B     PIDVTDCS-INVCHC(R2) BR TO CHARACTER SELECTION BR TABLE\nPIDVTDCS B     PIDVTDIC           INVALID CHARACTER       ------------>\n         B     PIDVTDD            DECIMAL DIGIT           ------------>\n         B     PIDVTDS            DECIMAL SIGN            ------------>\n         B     PIDVTDP            DECIMAL POINT           ------------>\n         B     PIDVTDK            COMMA                   ------------>\n         B     PIDVTDX            RIGHT DELIMITER         ------------>\n         B     PIDVTDE            EXPONENT                ------------>\n         SPACE\nPIDVTDD  DS    0H                 DECIMAL DIGIT\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         TM    EDFLAGS,EDEF       EXPONENT PROCESSING.................?\n         BO    PIDVTDED           YES, DIGIT OF THE EXPONENT---------->\n         TM    EDFLAGS,EDSDF      SIGNIFICANT DIGIT ALREADY FOUND.....?\n         BO    PIDVTDDO           YES, MOVE DIGIT TO OUTPUT----------->\n         CLI   0(SCANADR),C'0'    IS IT ZERO DIGIT....................?\n         BNE   PIDVTDDO           NO, THIS IS FIRST SIGNFICANT DIGIT-->\n         TM    EDFLAGS,EDDPF      DECIMAL POINT ALREADY FOUND.........?\n         BNO   PIDVTD0            NO, IGNORE THIS ZERO---------------->\n         LH    R0,ED10            YES, LOAD POWER OF 10\n         SH    R0,=H'1'           SUBTRACT 1 FROM IT\n         STH   R0,ED10            STORE POWER OF 10\n         B     PIDVTD0            CHECK NEXT CHARACTER    ------------>\nPIDVTDDO MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         OI    EDFLAGS,EDSDF      SIGNIFICANT DIGIT ALREADY FOUND\n         TM    EDFLAGS,EDDPF      DECIMAL POINT ALREADY FOUND.........?\n         BNO   PIDVTDD2           NO, ADD ONE TO POWER OF 10---------->\n         B     PIDVTD0            CHECK NEXT CHARACTER    ------------>\nPIDVTDD2 LH    R0,ED10            LOAD POWER OF 10\n         AH    R0,=H'1'           ADD 1 TO IT\n         STH   R0,ED10            STORE IT\n         B     PIDVTD0            CHECK NEXT CHARACTER    ------------>\n         SPACE\nPIDVTDS  MVC   VALSIGN,0(SCANADR) SIGN OF THE VALUE\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTD0            CHECK NEXT CHARACTER    ------------>\n         SPACE\nPIDVTDP  OI    EDFLAGS,EDDPF      DECIMAL POINT FOUND\n         MVI   TRT+C'.',INVCHC    DECIMAL POINT IS NO LONGER VALID CHAR\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         B     PIDVTD0            CHECK NEXT CHARACTER    ------------>\n         SPACE\nPIDVTDE  OI    EDFLAGS,EDEF       EXPONENT FOUND\n         BAL   R14,EDCONV         CONVERT CHAR STRING TO FP NUMBER\n         BAL   R14,CNVINITN       INIT AS FOR NUMERICS\n         SR    CVALL,CVALL        CONSTANT VALUE LENGTH = 0\n         L     CVALA,OUTRWAA      OUTPUT ADDRESS VALUE\n         MVI   TRT+C'.',INVCHC    DECIMAL POINT IS NOT A VALID CHAR\n         MVI   TRT+C'E',INVCHC    EXPONENT IS NOT LONGER VALID\n         B     PIDVTD0            CHECK NEXT CHARACTER    ------------>\n         SPACE\nPIDVTDED DS    0H                 DECIMAL DIGIT OF EXPONENT\n         MVI   TRT+C'+',INVCHC    DECIMAL SIGN IS NO LONGER\n         MVI   TRT+C'-',INVCHC    A VALID CHARACTER\n         MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         B     PIDVTD0            CHECK NEXT CHARACTER    ------------>\n         SPACE\nPIDVTDK  DS    0H                 COMMA, MULTIPLE VALUES SPECIFIED\n         BAL   R14,EDVALP         FLOATING POINT NOMINAL VALUE PROC.\n         B     PIDVTDN            NEXT NOMINAL VALUE PROCESSING\n         SPACE\n* END OF FLOATING POINT CONSTANT FOUND\nPIDVTDX  BAL   R14,EDVALP         PROCESS LAST NOMINAL VALUE\n         BAL   R14,DUPFPROC       PROCESS DUPLICATION FACTOR IF SPECIF\n         B     PIDNEXTC           PROCESSING OF THE NEXT CONSTANT\n         SPACE\n*  CONTINUATION OF FLOATING POINT CONSTANT ON NEXT INPUT RECORD\nPIDVTDC1 LA    R14,PIDVTD1        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n         SPACE\n*  INVALID CHARACTER IN FLOATING POINT CONSTANT VALUE\nPIDVTDIC DS    0H\n         BAL   R14,INVCPROC       CHECK IF CONSECUTIVE OCCURENCE\n         LA    R1,INVCHARM        INVALID CHARACTER MESSAGE\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n*---------------------------------------------------------------------*\n*  CONVERTS CHAR. STRING INTO FLOATING POINT NUMBER                   *\n*  TO INCREASE PRECITION OF RESULT - FP OPERATIONS ARE PERFORMED ON   *\n*  EXTENDED OPERANDS AND THEN RESULT IS ROUNDED                       *\n*---------------------------------------------------------------------*\n         SPACE\nEDCONV   SUBENT\n         OI    EDFLAGS,EDFPC      THIS ROUTINE WAS CALLED FLAG\n         LTR   CVALL,CVALL        IS VALUE LENGTH > 0    .............?\n         BNP   EDCONVL0           NO, LENGTH = 0         ------------->\n         CH    CVALL,=H'15'       IS CONSTANT'S LENGTH <= 15 DIGITS...?\n         BH    EDCONVL1           NO, MAX LENGTH EXCEEDED------------->\n         MVC   EDSIGN,VALSIGN     SAVE FP NUMBER SIGN\n         MVI   VALSIGN,C'+'       FORCE CONVERSION OF POSITIVE NUMBER\n         STH   CVALL,EDSGD        SAVE NUMBER OF SIGNIFICANT DIGITS\n         BAL   R14,CONVDEC        CONVERT IT TO DECIMAL\n         SDR   R0,R0              ZERO IN FP REGISTER 0\n         SDR   R2,R2              ZERO IN FP REGISTER 2\n         LD    R4,MAXBINFP        MAX.BINARY NUMBER IN FP REG. 4\n         SDR   R6,R6              ZERO IN FP REGISTER 6\nEDCONVC  CP    D,MAXBIN           GREATER THAN MAX.BINARY NUMBER......?\n         BH    EDCONVME           YES, DO STEP BY STEP CONV----------->\n         XC    EDD,EDD            CLEAR EDD\n         XC    EDDL,EDDL          CLEAR EDDL\n         XR    R0,R0              CLEAR REGISTER 0\n         LA    R2,64+8            CHARACTERISTIC + MAX.NO.OF HEX.DIGITS\n         CVB   R1,D               CONVERT TO BINARY\nEDCONVC1 SLDL  R0,4               SHIF ONE HEX.DIGIT TO THE LEFT\n         LTR   R0,R0              H/O DIGIT SHIFTED FROM R1 TO R0.....?\n         BNZ   EDCONVC2           YES, FIRST DIGIT LOCATED------------>\n         BCTR  R2,0               NO, SUBTRACT ONE FROM CHARACTERISTIC\n         B     EDCONVC1           SEARCH FOR FIRST HEX.DIGIT---------->\nEDCONVC2 SRDL  R0,4               SHIFT BACK FIRST HEX.DIGIT TO R1\n         ST    R1,EDD+1           STORE HEX DIGITS IN EDD\n         STC   R2,EDD             STORE CHARACTERISTIC IN EDD\n         CLI   EDSIGN,C'-'        NEGATIVE NUMBER.....................?\n         BNE   EDCONVC3           NO, POSITIVE------------------------>\n         OI    EDD,X'80'          YES, INSERT NEGATIVE SIGN\nEDCONVC3 SDR   R6,R6              CLEAR R6\n         LD    R4,EDD             LOAD EDD INTO R4\n         AXR   R0,R4              ADD VALUE FROM R0\n         STD   R0,EDD             PUT IT BACK INTO EDD  (H/O PART)\n         STD   R2,EDDL            PUT IT BACK INTO EDDL (L/O PART)\nEDCONVEX DS    0H                 RETURN TO CALLER\n         SUBRET EDCONV            RETURN TO CALLER\n         SPACE\nEDCONVME AXR   R0,R4              NUMBER IS > THAN MAX.4 BYTES BINARY\n         SP    D,MAXBIN           SUBTRACT 2147483647 FROM D\n         B     EDCONVC            PROCEED WITH CONVERSION------------->\n         SPACE\nEDCONVL0 XC    EDD,EDD            THIS NUMBER IS 0 ( TRUE ZERO )\n         OI    EDFLAGS,EDFP0      SET 0 NUMBER FLAG(TO SKIP PROCESSING\n*                                 OF EXPONENT)\n         B     EDCONVEX           RETURN FROM SUBROUTINE\n         SPACE\nEDCONVL1 DS    0H                 LENGTH OF CHAR.STRING > 15 DEC.DIGITS\n         LA    R1,DECVLLMM        NUMBER OF SIGNIFICANT DEC.DIG.>15\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     EDCONVL0           THIS NUBER WILL BE SUBSTITUTED BY 0\n         SPACE\n* PROCESSING OF A FLOATING POINT NOMINAL VALUE\nEDVALP   SUBENT\n         TM    EDFLAGS,EDFPC      NUMBER ALREADY CONVERTED............?\n         BO    EDVALP1            YES, PROCESS EXPONENT--------------->\n         BAL   R14,EDCONV         CONVERT CHAR.STRING TO FP NUMBER\n         B     EDVALP2            BYPASS EXPONENT PROCESSING---------->\nEDVALP1  BAL   R14,EDEXPP         YES, PROCESS EXPONENT\nEDVALP2  TM    EDFLAGS,EDFP0      IS THIS A ZERO .....................?\n         BO    EDVALPN            YES, PROCESS NOMINAL VALUE---------->\n*        CHECK IF SPECIFIED NUMBER IS WITHIN ALLOWABLE MAGNITUDE\n         LH    R1,EDEXP           VALUE OF EXPONENT\n         AH    R1,ED10            + POWER OF 10\n         SH    R1,EDSGD           - NUMBER OF SIGNIFICANT DIGITS\n         CH    R1,=H'-80'         LOWER RANGE\n         BL    EDVALPME           LOWER RANGE OF MAGNITUDE EXCEEDED--->\n         CH    R1,=H'+76'         UPPER RANGE\n         BH    EDVALPME           UPPER RANGE OF MAGNITUDE EXCEEDED--->\n*        MULTIPLY/DIVIDE THE NUMBER BY POWER OF 10\n         LD    R0,EDD             LOAD THE NUMBER (H/O PART)\n         LD    R2,EDDL            LOAD THE NUMBER (L/O PART)\n         SDR   R6,R6              CLEAR FP REG. 6\n         LTR   R1,R1              IS VALUE OF POWER OF 10 EQUAL 0.....?\n         BZ    EDVALP1E           YES, PROCESS NOMINAL VALUE---------->\n         BM    EDVALP3            LESS THAN 0, DIVIDE BY 10----------->\n         LD    R4,=D'10'          GREATER THAN 0, MULTIPLY BY 10\n         B     EDVALP10           GO TO MULTIPLY LOOP----------------->\nEDVALP3  LD    R4,ONETENTH        LESS THAN 0, DIVIDE BY 10\n         LD    R6,ONETENTH+8      L/O PART OF ONE TENTH IN EXT.FORMAT\nEDVALP10 LTR   R1,R1              IS VALUE OF POWER OF 10 EQUAL 0.....?\n         BZ    EDVALP1E           YES, PROCESS NOMINAL VALUE---------->\n         BM    EDVALP1D           LESS THAN 0, DIVIDE----------------->\n         MXR   R0,R4              GERATER THAN 0, MULTIPLY BY 10\n         BCTR  R1,0               POWER OF 10 - 1\n         B     EDVALP10           PROCEED WITH POWER OF 10------------>\nEDVALP1D MXR   R0,R4              LESS THAN 0, DIVIDE BY 10\n         AH    R1,=H'1'           POWER OF 10 + 1\n         B     EDVALP10           PROCEED WITH POWER OF 10------------>\nEDVALP1E STD   R0,EDD             NOMINAL VALUE (H/O PART)\n         STD   R2,EDDL            NOMINAL VALUE (L/O PART)\n         SPACE\nEDVALPN  DS    0H                 PROCESSING OF NOMINAL VALUE\n         LD    R0,EDD             NOMINAL VALUE (H/O PART)\n         LD    R2,EDDL            NOMINAL VALUE (L/O PART)\n         LRDR  R4,R0              ROUND EXTENDED INTO DOUBLE\n         CLI   TYPE,TYPEE         TYPE \"E\" CONSTANT      .............?\n         BE    EDVALPE            YES, TYPE \"E\"          ------------->\n         CLI   TYPE,TYPEL         TYPE \"L\" CONSTANT      .............?\n         BE    EDVALPL            YES, TYPE \"L\"          ------------->\n*  TYPE \"D\" CONSTANT\n         LA    R0,8               FULLWORD LENGTH\n         STD   R4,EDD             STORE IT IN EDD\nEDVALPDE LH    R1,OUTOFFS         OUTPUT OFFSET\n         LR    R14,R1             SAVE IT IN R14\n         A     R14,OUTRA          LOCATION IN OUTREC\n         AR    R1,R0              OFFSET + LENGTH OF CONSTANT\n         CH    R1,LRECL           LRECL EXCEEDED          ............?\n         BH    EDVLEXC            YES, LRECL EXCEEDED     ------------>\n         STH   R1,OUTOFFS         NEW OUTPUT OFFSET\n         CR    R1,ABC             IS GREATER THAN \"ABC\"   ............?\n         BNH   EDNVPM             NO, SKIP AROUND CHANGE  ------------>\n         LR    ABC,R1             YES, CHANGE \"ABC\" TO HIGHER VALUE...?\nEDNVPM   CLI   TYPE,TYPED         TYPE \"D\" CONSTANT       ............?\n         BE    EDNVPDM            YES, TYPE \"D\"           ------------>\n         CLI   TYPE,TYPEE         TYPE \"E\" CONSTANT       ............?\n         BE    EDNVPEM            YES, TYPE \"E\"           ------------>\n         MVC   0(16,R14),EDD      NO, TYPE \"L\",  MOVE IT TO OUTREC=====\n         B     EDVALPR            RETURN\nEDNVPDM  MVC   0(8,R14),EDD       TYPE \"D\",      MOVE IT TO OUTREC=====\n         B     EDVALPR            RETURN\nEDNVPEM  MVC   0(4,R14),EDE       MOVE FP \"E\"   TO OUTREC==============\n         B     EDVALPR            RETURN\nEDVALPE  LA    R0,4               TYPE \"E\" CONST.LENGTH\n         LRER  R0,R4              LOAD ROUNDED LONG TO SHORT\n         STE   R0,EDE             STORE SHORT FP NUMBER\n         B     EDVALPDE           CONTINUE ( MOVE E INTO OUTREC )----->\nEDVALPL  LA    R0,16              TYPE \"L\" CONST.LENGTH\n         B     EDVALPDE           CONTINUE ( MOVE L INTO OUTREC )----->\n         SPACE\n*   LRECL EXCEEDED FOR TYPE \"L\", \"D\" OR \"E\" CONSTANT\nEDVLEXC  DS    0H\n         TM    FLAGS2,LRECLEX     MESSAGE ALREADY PRINTED.............?\n         BO    EDVALPR            YES, RETURN FROM FP VALUE PROC------>\n         OI    FLAGS2,LRECLEX     SET THIS MSG PRINTED ALREADY FLAG\n         LA    R1,LRECEXCM        MESSAGE ADDRESS\nEDVALPER BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     EDVALPR            YES, RETURN FROM FP VALUE PROC------>\n*   MAGNITUDE OF \"L\", \"D\" OR \"E\" CONSTANT EXCEEDED\nEDVALPME LA    R1,VALOORM         MESSAGE ADDRESS\n         B     EDVALPER           PRINT ERROR MESSAGE\n         SPACE\nEDVALPR  DS    0H\n         SUBRET EDVALP            RETURN\n         SPACE\n* PROCESSING OF EXPONENT OF \"L\", \"D\" OR \"E\" TYPE CONSTANT\nEDEXPP   SUBENT\n         LTR   CVALL,CVALL        IS VALUE LENGTH > 0    .............?\n         BNP   EDEXPL0            NO, LENGTH = 0         ------------->\n         CH    CVALL,=H'3'        LENGTH OF EXPONENT VALUE > 3........?\n         BH    EDEXPL1            YES, MAX LENGTH EXCEEDED------------>\n         BAL   R14,CONVB          CONVERT EXPONENT TO BINARY\n         STH   CVALL,EDEXP        SAVE VALUE OF EXPONENT\nEDEXPPR  SUBRET EDEXPP            RETURN TO CALLER\n*   VALUE OF EXPONENT NOT SPECIFIED MESSAGE\nEDEXPL0  LA    R1,EDEXPVNS        EXPONENT NOT SPECIFIED MSG ADDRESS\nEDEXPL0M BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     EDEXPPR            RETURN FROM EDEXPP PROC------------->\n*   LENGTH OF EXPONENT > 3 DECIMAL DIGITS\nEDEXPL1  LA    R1,EDEXPLEX        MESSAGE ADDRESS\n         B     EDEXPL0M           PRINT ERROR MESSAGE\n         SPACE\n*   ALIGNMENT OF \"L\", \"D\" AND \"E\" TYPE CONSTANTS\nEDALIGN  SUBENT\n         TM    FLAGS1,OFFSP       ALIGNMENT HAS TO BE PERFORMED.......?\n         BO    EDALIGNR           NO, OUTOFFS WILL NOT BE CHANGED----->\n         TM    PARMFLGS,ALIGN     ALIGNMENT HAS TO BE PERFORMED.......?\n         BNO   EDALIGNR           NO, OUTOFFS WILL NOT BE CHANGED----->\n         LH    R1,OUTOFFS         OUTPUT OFFSET\n         TM    OUTOFFS+1,BIT6+BIT7 IS ALREADY ON FULLWORD BOUNDARY....?\n         BZ    EDALIGND           YES, CHECK DOUBLEWORD   ------------>\n         TM    OUTOFFS+1,BIT6+BIT7 ALL LAST TWO BITS ON   ............?\n         BO    EDALIGN1           YES, ADD 1 TO OUTOFFS   ------------>\n         TM    OUTOFFS+1,BIT6     BIT6 ON                 ............?\n         BO    EDALIGN2           YES, ADD 2 TO OUTOFFS   ------------>\n         LA    R1,3(0,R1)         NO, ADD 3\n         B     EDALIGND           CHECK IF DOUBLEWORD     ------------>\nEDALIGN1 LA    R1,1(0,R1)         ADD 1 TO OUTOFFS\n         B     EDALIGND           CHECK IF DOUBLEWORD     ------------>\nEDALIGN2 LA    R1,2(0,R1)         ADD 2 TO OUTOFFS\n         B     EDALIGND           CHECK IF DOUBLEWORD     ------------>\nEDALIGND CLI   TYPE,TYPEE         TYPE \"E\" CONSTANT       ............?\n         BE    EDALIGNE           YES, EXIT FROM ALIGNMENT------------>\n* TYPE \"L\" OR \"D\" CONSTANT ALIGNMENT\n         TM    OUTOFFS+1,BIT5     BIT5 ON                 ............?\n         BNO   EDALIGNE           NO, ALREADY ALIGNED     ------------>\n         LA    R1,4(0,R1)         YES, ADD 4 TO OUTOFFS   ------------>\nEDALIGNE STH   R1,OUTOFFS         STORE ALIGNED OFFSET\nEDALIGNR SUBRET EDALIGN\n         SPACE 2\n* PROCESSING OF A FIXED POINT NOMINAL VALUE\nFPNVP    SUBENT\n         LTR   CVALL,CVALL        IS VALUE LENGTH > 0    .............?\n         BNP   FPVALL0            NO, LENGTH = 0         ------------->\n         CH    CVALL,FPNVL        IS CONSTANT'S LENGTH <= MAX.........?\n         BH    FPVALL1            NO, MAX LENGTH EXCEEDED------------->\n         BAL   R14,CONVB          CONVERT NOMINAL VALUE TO BINARY\n         C     CVALL,FPMAXV       IS LESS OR EQUAL TO MAX.VALUE.......?\n         BH    FPMAXVEX           NO, MAX.VALUE EXCEEDED ------------->\n         C     CVALL,FPMINV       ISGREATER OR EQUAL TO MIN.VALUE.....?\n         BL    FPMINVEX           NO, MIN.VALUE EXCEEDED ------------->\n         ST    CVALL,D            SAVE VALUE IN \"D\"\n         CLI   TYPE,TYPEF         TYPE \"F\" CONSTANT      .............?\n         BNE   FPNVPH             NO, TYPE \"H\"           ------------->\n*  TYPE \"F\" CONSTANT\n         LA    R0,4               FULLWORD LENGTH\nFPNVPFH  LH    R1,OUTOFFS         OUTPUT OFFSET\n         LR    R14,R1\n         A     R14,OUTRA          LOCATION IN OUTREC\n         AR    R1,R0              OFFSET + LENGTH OF CONSTANT\n         CH    R1,LRECL           LRECL EXCEEDED          ............?\n         BH    FPVLEXC            YES, LRECL EXCEEDED     ------------>\n         STH   R1,OUTOFFS         NEW OUTPUT OFFSET\n         CR    R1,ABC             IS GREATER THAN \"ABC\"   ............?\n         BNH   FPNVPM             NO, SKIP AROUND CHANGE  ------------>\n         LR    ABC,R1             YES, CHANGE \"ABC\" TO HIGHER VALUE...?\nFPNVPM   CLI   TYPE,TYPEF         TYPE \"F\" CONSTANT       ............?\n         BNE   FPNVPHM            NO, TYPE \"H\"            ------------>\n         MVC   0(4,R14),D         YES, TYPE \"F\", MOVE IT TO OUTREC=====\n         B     FPNVPR             RETURN\nFPNVPHM  MVC   0(2,R14),D+2       MOVE HALFWORD TO OUTREC==============\n         B     FPNVPR             RETURN\nFPNVPH   LA    R0,2               HALFWORD LENGTH\n         B     FPNVPFH            CONTINUE ( MOVE H INTO OUTREC )----->\nFPNVPR   SUBRET FPNVP             RETURN\n         SPACE\nFPVALPR  SUBRET FPVALP            RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*  \"X\" TYPE CONSTANT PROCESSING                                       *\n*---------------------------------------------------------------------*\n         SPACE\nPIDVTX   DS    0H                 TYPE = X CONSTANT PROCESSING\n         MVC   OUTCSOFF,OUTOFFS   OFFSET OF FIRST NOMINAL VALUE\nPIDVTXN  DS    0H                 TYPE = X CONSTANT NOMINAL VALUE PROC.\n         BAL   R14,CNVINIT        INIT OF PROCESSING FOR CONST VALUE\nPIDVTX0  LA    SCANADR,1(0,SCANADR) NEXT SCAN CHAR ADDRESS\n         SH    SCANLEN,=H'1'      ARE THERE ANY CHARS LEFT ON THIS REC?\n         BNP   PIDVTXC1           NO, CHECK CONTINUATION  ------------>\nPIDVTX1  EX    R0,TRTSCAN         FIND OUT WHAT CHARACTER\n         SLL   R2,24              STRIP 3 H/O BYTES\n         SRL   R2,24              TO GET FUNCTION BYTE VALUE\n         B     PIDVTXCS-INVCHC(R2) BR TO CHARACTER SELECTION BR TABLE\nPIDVTXCS B     PIDVTXIC           INVALID CHARACTER       ------------>\n         B     PIDVTX1O           HEXADECIMAL DIGIT       ------------>\n         B     PIDVTXK            COMMA                   ------------>\n         B     PIDVTXX            RIGHT DELIMITER         ------------>\n         SPACE\nPIDVTX1O MVC   0(1,CVALA),0(SCANADR) MOVE VALUE CHARACTER INTO OUTPUT\n         LA    CVALA,1(0,CVALA)   NEXT OUTPUT CHAR ADDRESS\n         LA    CVALL,1(0,CVALL)   LENGTH OF NOMINAL VALUE STRING\n         B     PIDVTX0            CHECK NEXT CHARACTER    ------------>\nPIDVTXK  DS    0H                 COMMA, MULTIPLE VALUES SPECIFIED\n         BAL   R14,HEXVALP        HEXA NOMINAL VALUE PROCESSING\n         B     PIDVTXN            NEXT NOMINAL VALUE PROCESSING\n* END OF HEXADECIMAL CONSTANT FOUND\nPIDVTXX  BAL   R14,HEXVALP        PROCESS LAST NOMINAL VALUE\n         BAL   R14,DUPFPROC       PROCESS DUPLICATION FACTOR IF SPECIF\n         B     PIDNEXTC           PROCESSING OF THE NEXT CONSTANT\n*  CONTINUATION OF HEXADECIMAL CONSTANT ON NEXT INPUT RECORD\nPIDVTXC1 LA    R14,PIDVTX1        RETURN ADDRESS\n         B     PIDCCONT           SEARCH FOR RIGHT DELIMITER CONT----->\n         SPACE\n*  INVALID CHARACTER IN HEXADECIMAL CONSTANT VALUE\nPIDVTXIC DS    0H\n         BAL   R14,INVCPROC       CHECK IF CONSECUTIVE OCCURENCE\n         LA    R1,INVCHARM        INVALID CHARACTER MESSAGE\n         B     PIDCNSTE           CONSTANT SPECIFICATION ERROR-------->\n         SPACE\n* HEXADECIMAL CONSTANT NOMINAL VALUE PROCESSING\n         SPACE\nHEXVALP  SUBENT\n         LTR   CVALL,CVALL        IS VALUE LENGTH > 0    .............?\n         BNP   HEXVALL0           NO, LENGTH = 0         ------------->\n         BAL   R14,CONVHEX        CONVERT HEXADECIMAL TEXT\n*                                 CVALL WILL CONTAIN RESULTING STRING\n*                                 LENGTH\n         TM    FLAGS1,LENMP       LENGTH MODIFIER SPECIFIED...........?\n         BNO   HEXVALDL           NO, DEFAULT LENGTH       ----------->\n         C     CVALL,LENGTHM      IS DEFAULT LENGTH <= LENGTH MODIF...?\n         BH    HEXVALL2           NO, ERROR, TOO LARGE VALUE SPECIF--->\n         BE    HEXVALDL           DEFAULT LENGTH = LENGTH MODIFIER---->\n*        LENGTH MODIFIER > DEFAULT LENGTH - LEADING ZEROS ARE REQUIRED\n         L     R1,OUTRWAA         WORK AREA ADDRESS\n         LR    R15,R1\n         A     R1,LENGTHM         + LENGTH MODIFIER\n         BCTR  R1,0               - 1 = LAST BYTE ADDRESS (OUTPUT)\n         AR    R15,CVALL          + DEFAULT LENGTH\n         BCTR  R15,0              - 1 = LAST BYTE ADDRESS (INPUT)\n         LR    R14,CVALL          DEFAULT LENGTH\nHEXVALP1 MVC   0(1,R1),0(R15)     SHIFT RESULT INTO RIGHT\n         BCTR  R1,0               OUTPUT ADDRESS - 1\n         BCTR  R15,0              INPUT  ADDRESS - 1\n         BCT   R14,HEXVALP1       MOVE NEXT CHARACTER\n         L     R14,LENGTHM        LENGTH MODIFIER\n         SR    R14,CVALL          - DEFAULT LENGTH=NO.OF LEADING ZEROS\nHEXVALP2 MVI   0(R1),X'00'        PUT LEADING ZEROS\n         BCTR  R1,0               OUTPUT ADDRESS - 1\n         BCT   R14,HEXVALP2       NEXT LEADING ZERO\n         L     CVALL,LENGTHM      EXPLICIT LENGTH WILL BE TAKEN\nHEXVALDL EQU   *\n         LH    R1,OUTOFFS         OUTPUT OFFSET\n         LR    R14,R1\n         AR    R1,CVALL           OFFSET + CHAR.STRING LENGTH = RECL\n         CH    R1,LRECL           LRECL EXCEEDED          ............?\n         BH    HEXVLEXC           YES, LRECL EXCEEDED     ------------>\n         STH   R1,OUTOFFS         NEW OUTPUT OFFSET\n         CR    R1,ABC             IS GREATER THAN \"ABC\"   ............?\n         BNH   HEXVAL1            NO, SKIP AROUND CHANGE  ------------>\n         LR    ABC,R1             YES, CHANGE \"ABC\" TO HIGHER VALUE...?\nHEXVAL1  A     R14,OUTRA          OUTOFFS + OUT.REC.ADDR = OUT MVC ADR\n         LR    R15,CVALL          LENGTH OF RESULTING VALUE OF HEX.CNST\n         L     R0,OUTRWAA         HEX.CONSTANT VALUE ADDRESS\n         LR    R1,CVALL           LENGTH OF MOVED STRING\n         MVCL  R14,R0             MOVE HEXADECIMAL VALUE INTO OUTREC\nHEXVALR  SUBRET HEXVALP           RETURN TO CALLER\n         SPACE\n*  TYPE \"X\" CONSTANT NOMINAL VALUE LENGTH = 0 CHARACTERS\nHEXVALL0 DS    0H\n         LA    R1,DECVLL0M        MESSAGE ADDRESS\nHEXVALER BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     HEXVALR            RETURN FROM DECIMAL VALUE PROC.\n         SPACE\n*  TYPE \"X\" CONSTANT NOMINAL VALUE IMPLICIT LENGTH > LENGTH MODIFIER\nHEXVALL2 DS    0H\n         LA    R1,VALELEM         MESSAGE ADDRESS\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         L     R0,OUTRWAA         OUTPUT ADDRESS\n         L     R1,LENGTHM         EXPLICIT LENGTH\n         LR    R14,R0             WORK AREA ADDRESS\n         LR    R15,CVALL          IMPLICIT LENGTH\n         S     R15,LENGTHM        CVALL-LENGTHM=NO.OF LEADING TRUC.CHAR\n         AR    R14,R15            INPUT ADDRESS\n         LR    R15,R1             LENGTH OF MOVED STRING\n         MVCL  R0,R14             MOVE AND TRUNCATE LEADING CHARS\n         L     CVALL,LENGTHM      VALUE WILL BE TRUNCATED TO EXPLICIT\n         B     HEXVALDL           LENGTH                 ------------->\n         SPACE\n*  TYPE \"X\" CONSTANT - LRECL EXCEEDED\nHEXVLEXC DS    0H\n         TM    FLAGS2,LRECLEX     MESSAGE ALREADY PRINTED.............?\n         BO    HEXVALR            YES, RETURN FROM DEC.VALUE PROC----->\n         OI    FLAGS2,LRECLEX     SET THIS MSG PRINTED ALREADY FLAG\n         LA    R1,LRECEXCM        MESSAGE ADDRESS\n         B     HEXVALER           PRINT ERROR MESSAGE\n         SPACE\n* PROCESSING OF DUPLICATION FACTOR ON OUTPUT\n         SPACE\nDUPFPROC SUBENT\n         TM    FLAGS1,DUPFP       DUPLICATION FACTOR SPECIFIED........?\n         BNOR  R14                NO, RETURN              ------------>\n         L     R15,DUPF           VALUE OF DUPLICATION FACTOR\n         CH    R15,=H'1'          IS GRAETER THAN 1       ............?\n         BNHR  R14                NO, RETURN              ------------>\n         BCTR  R15,0              DUP.FACTOR - 1\n         LH    R14,OUTOFFS        AVAILABLE OUTPUT OFFSET\n         SH    R14,OUTCSOFF       - START OF CONST.OFFSET=CONST.LENGTH\nDUPFP1   LR    R1,R14             LENGTH OF MOVED STRING\n         LH    R0,OUTOFFS         AVAILABLE OFFSET\n         AR    R0,R1              LENGTH OF FILLED PART OF OUTREC\n         CH    R0,LRECL           IS RECL O.K.            ............?\n         BH    LRECLEXC           NO, LRECL EXCEEDED      ------------>\n         STH   R0,OUTOFFS         NEXT AVAILABLE OFFSET IN OUT.REC\n         CR    R0,ABC             GREATER THAN \"ABC\"      ............?\n         BNH   DUPFP2             NO, DO NOT CHANGE \"ABC\" ------------>\n         LR    ABC,R0             YES, CHANGE \"ABC\"\nDUPFP2   SR    R0,R1              CURRENT AVAILABLE OFFSET\n         A     R0,OUTRA           AVAILABLE ADDRESS IN OUTREC\n         LH    R2,OUTCSOFF        OFFSET OF BEGINNING OF THE CONST.\n         A     R2,OUTRA           CONST.ADDRESS IN OUTREC\n         LR    R3,R1              CONSTANT LENGTH\n         MVCL  R0,R2              DUPLICATE CONSTANT IN OUTREC\n         BCT   R15,DUPFP1         REPEAT DUPLICATION IF REQUIRED\n         SUBRET DUPFPROC          RETURN TO CALLER\n         SPACE\n*  NO MORE CONSTANTS OR COMMENTS ON THIS INPUT RECORD\nPIDNMC   BAL   R14,PRNTCIR        PRINT CURRENT INPUT RECORD\n         CLI   REC80+71,X'40'     IS RECORD CONTINUATION MARK PRESENT.?\n         BE    PROCINDR           NO, RETURN, ONE OUT RECORD PROCESSED\n         OI    FLAGS1,CEXPCT      CONTINUATION OF OUT.REC. EXPECTED\n         BAL   R14,GETNREC        READ NEXT INPUT RECORD\n         B     PIDCDT             PROCESS NEXT CONSTANT FROM INPUT\nPROCINDR SUBRET PROCIND           RETURN\nTRTSCAN  TRT   0(1,SCANADR),TRT   TRT TO IDENTIFY NEXT CHAR OF P CONST\n         SPACE\nINVCHC   EQU   4                  INVALIDE CHARACTER CODE\nNUMERIC  EQU   INVCHC+4           NUMERIC CODE\nHEXDC    EQU   NUMERIC            HEXADECIMAL DIGIT CODE\nLDLMC    EQU   HEXDC+4            LEFT DELIMITER CODE\nRDLMC    EQU   LDLMC+4            RIGHT DELIMITER CODE\nSLASH    EQU   RDLMC+4            SLASH CODE\nTYPEA    EQU   SLASH+4            TYPE A FIELD CODE\nTYPEC    EQU   TYPEA+4            TYPE C FIELD CODE\nTYPEF    EQU   TYPEC+4            TYPE F FIELD CODE\nTYPEH    EQU   TYPEF+4            TYPE H FIELD CODE\nTYPEP    EQU   TYPEH+4            TYPE P FIELD CODE\nTYPEX    EQU   TYPEP+4            TYPE X FIELD CODE\nTYPEE    EQU   TYPEX+4            TYPE E FIELD CODE\nTYPED    EQU   TYPEE+4            TYPE D FIELD CODE\nTYPEL    EQU   TYPED+4            TYPE L FIELD CODE\nTYPEZ    EQU   TYPEL+4            TYPE Z FIELD CODE\n         SPACE\n*---------------------------------------------------------------------*\n*  CONVERTS VALUE OF LENGTH OR OFFSET MODIFIERS OR DUPL.FACTOR        *\n*  TO BINARY.                                                         *\n*---------------------------------------------------------------------*\n         SPACE\nCONVB    SUBENT\n         BAL   R14,CONVDEC        CONVERT IT TO DECIMAL\n         CP    D,MAXBIN           MAX.BINARY NUMBER EXCEEDED..........?\n         BH    CONVBER            YES, ERROR              ------------>\n         CP    D,=P'-2147483648'  MIN.BINARY NUMBER EXCEEDED..........?\n         BL    CONVBER            YES, ERROR              ------------>\n         CVB   CVALL,D            CONVERT TO BINARY\nCONVBR   SUBRET CONVB             RETURN TO CALLER\nCONVBER  LA    R1,VALOORM         BINARY NUMBER OUT OF RANGE MESSAGE\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         SR    CVALL,CVALL        ZERO INTO VALUE REGISTER\n         B     CONVBR             RETURN                  ------------>\n         SPACE\n*---------------------------------------------------------------------*\n*  CONVERTS NOMINAL VALUE TO PACKED DECIMAL                           *\n*  VALUE TO BE CONVERTED IS IN OUTRWA FIELD, ITS LENGTH IS IN CVALL   *\n*  RESULT WILL BE IN FIELD \"D\" AND CVALL WILL CONTAIN LENGTH OF       *\n*  SIGNIFICANT BYTES IN \"D\" FIELD.                                    *\n*---------------------------------------------------------------------*\n         SPACE\nCONVDEC  SUBENT\n         SR    CVALA,CVALL        ADDRESS OF VALUE STRING\n         BCTR  CVALL,0            VALUE STRING LENGTH - 1\n         EX    CVALL,PACKDECV     PACK DECIMAL VALUE\n         CLI   VALSIGN,C'+'       POSITIVE VALUE          ............?\n         BE    CONVDEC1           YES, GOTO IMPLICIT LENGTH CHECK----->\n         NI    D+7,X'F0'          NO, NEGATIVE VALUE, STRIP PLUS SIGN\n         OI    D+7,X'0D'          MINUS SIGN\nCONVDEC1 LA    CVALL,8            NUMBER OF SIGNIFICANT DIGITS\n         LA    R14,D              FIRST CHAR. ADDRESS\nCONVDEC2 CLI   0(R14),X'00'       NON SIGNIFICANT DIGITS..............?\n         BNE   CONVDECR           NO, SIGNIFICANT, RETURN------------->\n         LA    R14,1(0,R14)       NEXT CHAR ADDRESS\n         BCT   CVALL,CONVDEC2     NO OF CHARS - 1, GOTO CHECK NEXT---->\nCONVDECR SUBRET CONVDEC           RETURN TO CALLER\nPACKDECV PACK  D,0(1,CVALA)       PACK DECIMAL VALUE\n         SPACE\n*---------------------------------------------------------------------*\n*  CONVERTS HEXADECIMAL NOMINAL VALUE INTO CHARACTER FORMAT.          *\n*  VALUE TO BE CONVERTED IS IN OUTRWA FIELD, ITS LENGTH IS IN CVALL.  *\n*  RESULT WILL BE ALSO IN OUTRWA AND LENGTH IN CVALL.                 *\n*---------------------------------------------------------------------*\n         SPACE\nCONVHEX  SUBENT\n         L     R1,OUTRWAA         WORK AREA ADDRESS\n         STC   CVALL,CHAR6        LAST BYTE OF CVALL\n         TM    CHAR6,BIT7         EVEN NUMBER OF HEXADECIMAL DIGITS...?\n         BNO   CONVHEX2           YES, DO CONVERSION   --------------->\n*                                 NO, INSERT ONE LEADING ZERO\n         AR    R1,CVALL           + LENGTH = OUTPUT ADDRESS\n         LR    R14,R1\n         BCTR  R14,0              - 1 = INPUT ADDRESS\n         LR    R15,CVALL          LENGTH OF INPUT HEX STRING\nCONVHEX1 MVC   0(1,R1),0(R14)     SHIFT RESULT INTO RIGHT\n         BCTR  R1,0               OUTPUT ADDRESS - 1\n         BCTR  R14,0              INPUT  ADDRESS - 1\n         BCT   R15,CONVHEX1       MOVE NEXT CHARACTER\n         LA    CVALL,1(0,CVALL)   LENGTH + 1\n         MVI   0(R1),C'0'         PUT LEADING ZERO\nCONVHEX2 SRL   CVALL,1            LENGTH OF RESULT ( INPUT LENGTH / 2 )\n         LR    R14,CVALL\n         LR    R15,R1             INPUT ADDRESS\n         MVC   TRTAB+C'0'(10),=X'00010203040506070809'\n         MVC   TRTAB+C'A'(6),=X'0A0B0C0D0E0F'\nCONVHEXP TR    0(2,R1),TRTAB      TRANSLATE TWO BYTES INTO HEX.ZONED\n         IC    R0,0(0,R1)         FIRST CHARACTER FROM TWO CONSECUTIVE\n         SLL   R0,4               SHIFT NUMERIC 4 BITS TO THE LEFT\n         STC   R0,0(0,R15)        STORE IT BACK INTO OUTPUT\n         OC    0(1,R15),1(R1)     COMBINE IT WITH NUM.OF THE NEXT CHAR.\n         LA    R1,2(0,R1)         NEXT TWO INPUT CHARACTERS ADDRESS\n         LA    R15,1(0,R15)       NEXT OUTPUT CHARACTER ADDRESS\n         BCT   R14,CONVHEXP       CONVERT NEXT TWO HEX DIGITS INTO BYTE\nCONVHEXR SUBRET CONVHEX           RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*  CHECK IF CONSECUTIVE OCCURENCE OF INVALID CHARACTER ON INPUT REC   *\n*---------------------------------------------------------------------*\n         SPACE\nINVCPROC DS    0H\n         TM    FLAGS2,INVCHAR     CHECK IF CONSECUTIVE OCCURENCE\n         BO    PIDNEXTC           YES, DO NOT PRINT ERROR MSG\n         OI    FLAGS2,INVCHAR     INVALID CHAR MESSAGE PRINTED FLAG\n         BR    R14\n         SPACE\n*---------------------------------------------------------------------*\n*  CONTINUATION OF CONSTANT EXPECTED ON NEXT INPUT RECORD             *\n*---------------------------------------------------------------------*\n         SPACE\nPIDCCONT SUBENT\n         CLI   REC80+71,X'40'     IS RECORD CONTINUATION MARK PRESENT.?\n         BE    PIDMCSC            NO, MISSING CONSTANT SPECIF.CONTINU->\n         BAL   R14,PRNTCIR        PRINT CURRENT INPUT RECORD\n         OI    FLAGS2,CONTEXP     CONTINUATION EXPECTED FLAG\n         BAL   R14,GETNREC        READ NEXT INPUT RECORD\n         NI    FLAGS2,X'FF'-CONTEXP CONTINUATION RECEIVED\n         SUBRET PIDCCONT          RETURN TO CONSTANT PROCESSING\n         SPACE 2\n*---------------------------------------------------------------------*\n*   MISSING CONSTANT CONTINUATION ERROR MSG                           *\n*---------------------------------------------------------------------*\nPIDMCSC  LA    R1,MCSCM           MISSING CONSTANT CONTINUATION MSG\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     PROCESOR           PROCESS NEXT OUTPUT RECORD\n         SPACE 2\n*---------------------------------------------------------------------*\n*   CONSTANT SPECIFICATION ERROR ( R1 CONTAINS ERROR MSG. ADDRESS )   *\n*---------------------------------------------------------------------*\nPIDCNSTE DS    0H\n         OI    FLAGS2,INVCHAR     TO PREVENT INVALID CHARACTER MESSAGE\n         BAL   R14,ERMSGP         PRINT ERROR MESSAGE\n         B     PIDNEXTC           PROCESS NEXT CONSTANT\n         SPACE 2\n*---------------------------------------------------------------------*\n*  INITIALYZE PROCESSING OF A NEW OUTPUT RECORD                       *\n*---------------------------------------------------------------------*\n         SPACE\nINITOR   SUBENT\n* INITIALYZE OUTPUT RECORD AREA WITH PAD CHARACTER\n         LA    R0,OUTR            ADDRESS OF OUTPUT RECORD\n         LH    R1,LRECL           LENGTH OF OUTPUT RECORD\n         SR    R14,R14            SECOND OPERAND FOR MVCL\n         IC    R15,PADCHAR        PAD CHARACTER\n         SLL   R15,24             SHIFT IT INTO BIT POS. 0-7\n         MVCL  R0,R14             MOVE PAD CHAR INTO OUTPUT RECORD\n         SR    ABC,ABC            AVAILABEL BYTE COUNT = 0\n         TM    FLAGS,RECFMV       VARIABLE RECORD FORMAT .............?\n         BNO   INITORET           NO                     ------------->\n         LA    ABC,4               YES, ABC = 4\nINITORET SUBRET INITOR\n         SPACE 2\n*---------------------------------------------------------------------*\n*  INITIALYZE PROCESSING OF A NEW NOMINAL VALUE OF A CONSTANT         *\n*---------------------------------------------------------------------*\n         SPACE\nCNVINIT  SUBENT\n         NI    FLAGS1,X'FF'-OFFSP TURN OFF OFFSET SPECIFIED FLAG\n         TM    PRNTFLGS,PRNTOFF   OFFSET OF FIRST CONSTANT ALREADY\n*                                 KNOWN...............................?\n         BO    CNVINIT1           YES, DO NOT CHANGE      ------------>\n         MVC   PRNTOFFS,OUTOFFS   OFFSET OF FIRST CONSTANT ON THIS CARD\n         OI    PRNTFLGS,PRNTOFF   SET PRINT OFFSET FLAG\nCNVINIT1 SR    CVALL,CVALL        CONSTANT VALUE LENGTH = 0\n         L     CVALA,OUTRWAA      OUTPUT ADDRESS VALUE\n         MVI   FLAGS2,X'00'       INITIALYZE FLAGS\n         MVI   TRT,INVCHC         INVALID CHARACTER\n         MVC   TRT+1(L'TRT-1),TRT INIT TRT WITH INV.CHAR.CODE\n         SR    R15,R15            ZERO R15\n         IC    R15,TYPE           CONSTANT TYPE\n         B     CNVITS-TYPEA(R15)  CONSTANT TYPE SELECTION\nCNVITS   B     CNVITA             TYPE A CONSTANT\n         B     CNVITC             TYPE C CONSTANT\n         B     CNVITF             TYPE F CONSTANT\n         B     CNVITH             TYPE H CONSTANT\n         B     CNVITP             TYPE P CONSTANT\n         B     CNVITX             TYPE X CONSTANT\n         B     CNVITE             TYPE E CONSTANT\n         B     CNVITD             TYPE D CONSTANT\n         B     CNVITL             TYPE L CONSTANT\n         B     CNVITZ             TYPE Z CONSTANT\n*  FIXED POINT CONSTANT\nCNVITF   EQU   *\nCNVITH   EQU   *\nCNVITP   EQU   *\nCNVITZ   EQU   *\n         BAL   R14,CNVINITN       INITIALISATION FOR NUMERICS\n         B     CNVINITR           RETURN\nCNVITX   EQU   *\n         MVC   TRT+C'A'(6),=6AL1(HEXDC) HEXADECIMAL DIGITS\n         MVC   TRT+C'0'(10),=10AL1(HEXDC) DECIMAL DIGIT\n         MVI   TRT+C',',HEXDC+4   COMMA (NOMINAL VALUE DELIMITER)\n         MVI   TRT+C'''',HEXDC+8    RIGHT VALUE DELIMITER\n         B     CNVINITR           RETURN\n*  FLOATING POINT CONSTANTS\nCNVITE   EQU   *\nCNVITD   EQU   *\nCNVITL   EQU   *\n         BAL   R14,CNVINITN       INITIALISATION FOR NUMERICS\n         MVI   TRT+C'E',NUMERIC+20 EXPONENT SPECIFICATION\n         B     CNVINITR           RETURN\nCNVITA   EQU   *\n         MVC   TRT+C'0'(10),=10AL1(NUMERIC) DECIMAL DIGIT\n         MVI   TRT+C')',NUMERIC+4  RIGHT VALUE DELIMITER\n         MVI   TRT+C',',NUMERIC+8  COMMA (NOMINAL VALUE DELIMITER)\nCNVITC   EQU   *\nCNVINITR SUBRET CNVINIT           RETURN\n         SPACE\nCNVINITN DS    0H                 INITIALISATION OF TRT FOR NUMERICS\n         MVI   VALSIGN,C'+'       DIFAULT SIGN OF A FIXED POINT CONST\n         MVC   TRT+C'0'(10),=10AL1(NUMERIC) DECIMAL DIGIT\n         MVI   TRT+C'+',NUMERIC+4 DECIMAL SIGN\n         MVI   TRT+C'-',NUMERIC+4 DECIMAL SIGN\n         MVI   TRT+C'.',NUMERIC+8 DECIMAL POINT\n         MVI   TRT+C',',NUMERIC+12 COMMA (NOMINAL VALUE DELIMITER)\n         MVI   TRT+C'''',NUMERIC+16 RIGHT VALUE DELIMITER\n         BR    R14                RETURN\n         SPACE 2\n*---------------------------------------------------------------------*\n*  INITIALYZE PROCESSING OF A NEW CONSTANT ON INPUT RECORD            *\n*---------------------------------------------------------------------*\n         SPACE\nNEWCNSTI SUBENT\n         MVI   TRT,INVCHC         INIT TRT TABLE\n         MVC   TRT+1(L'TRT-1),TRT\n         MVI   TRT+X'40',X'00'    IGNORE BLANKS\n         MVI   TRT+C'/',SLASH     START OF COMMENT\n         MVC   TRT+C'0'(10),=10AL1(NUMERIC) PROCESS NUMERICS (DUP.FACT)\n         MVI   TRT+C'A',TYPEA     PROCESS TYPE FILED\n         MVI   TRT+C'C',TYPEC     PROCESS TYPE FILED\n         MVI   TRT+C'F',TYPEF     PROCESS TYPE FILED\n         MVI   TRT+C'H',TYPEH     PROCESS TYPE FILED\n         MVI   TRT+C'P',TYPEP     PROCESS TYPE FILED\n         MVI   TRT+C'X',TYPEX     PROCESS TYPE FILED\n         MVI   TRT+C'E',TYPEE     PROCESS TYPE FILED\n         MVI   TRT+C'D',TYPED     PROCESS TYPE FILED\n         MVI   TRT+C'L',TYPEL     PROCESS TYPE FILED\n         MVI   TRT+C'Z',TYPEZ     PROCESS TYPE FILED\n         XR    DUPFL,DUPFL        DUPLICATION FACTOR LENGTH = 0\n         L     DUPFA,OUTRWAA      WORK AREA ADDRESS FOR DUP.FACTOR\n         MVI   FLAGS1,SEARCHNC    SEARCH FOR A NEW CONSTANT FLAG\n         SUBRET NEWCNSTI          RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*  WRITE OUTPUT RECORD SUBROUTINE                                     *\n*---------------------------------------------------------------------*\n         SPACE\nWRITEOR  SUBENT\n         LTR   ABC,ABC            AVAILABEL BYTE COUNT = 0 ...........?\n         BZR   R14                YES, NO RECORD HES BEEN GENERATED--->\n         TM    FLAGS,RECFMV       VARIABLE RECORD FORMAT .............?\n         BO    WRITEORV           YES                    ------------->\n         TM    FLAGS,RECFMF       FIXED LENGTH RECORD    .............?\n         BO    WRITEORF           YES                    ------------->\n*   UNDEFINED RECORD FORMAT\n         STH   ABC,OUTF+82        LENGTH OF WRITTEN RECORD INTO DCB\nWRITEORF L     R0,OUTRA           OUTPUT RECORD ADDRESS\n         PUT   OUTF,(0)           PUT OUTPUT RECORD\n         LA    R0,1               NUMBER OUF OUTPUT RECORDS + 1\n         A     R0,OUTRCNT\n         ST    R0,OUTRCNT         NEW OUTPUT RECORD COUNT\n         SUBRET WRITEOR           RETURN\n*   VARIABLE LENGTH RECORDS\nWRITEORV CH    ABC,=H'4'          AVAILABLE BYTE COUNT > 4 ( RDW )....?\n         BNHR  R14                NO, NO RECORD HAS BEEN GENERATED---->\n         L     R1,OUTRA           OUTPUT RECORD ADDRESS\n         XC    0(4,R1),0(R1)      CLEAR RDW\n         STH   ABC,0(0,R1)        THIS RECORD LENGTH\n         B     WRITEORF           PUT RECORD               ----------->\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*  PARM FIELD PROCESSING ROUTINE                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nPARMAR   EQU   R4                 PARM ADDRESS REGISTER\nPARMLR   EQU   R5                 PARM LENGTH REGISTER\nPARMLSA  EQU   R6                 PARM LEFT SIDE ADDRESS\nPARMLSL  EQU   R7                 PARM LEFT SIDE LENGTH\nPARMRSA  EQU   R8                 PARM RIGHT SIDE ADDRESS\nPARMRSL  EQU   R9                 PARM RIGHT SIDE LENGTH\n         SPACE\nPARMPROC SUBENT\n         MVI   PARMFLGS,X'00'     INIT PARM PROCESSING FLAGS\n         L     PARMAR,PARMA       PARM ADDRESS\n         USING PARML,PARMAR\n         MVC   HALF,PARMLEN       PARM LENGTH INTO WORK HALFWORD\n         LH    PARMLR,HALF        PARM LENGTH\n         LA    PARMAR,PARMT       PARM TEXT ADDRESS\n         DROP  PARMAR\n         LTR   PARMLR,PARMLR      ARE THERE ANY PARMS SPECIFIED.......?\n         BZ    PARMDEF0           NO, TAKE STANDARD DEFAULTS---------->\nPARMLRP  BAL   R14,PARMELR        EXTRACT LEFT AND RIGHT SIDE OF PARM\n         BAL   R14,PARMSKW        SEARCH FOR KEYWORDS\n         B     PARMKWBT(R15)      KEYWORDS BRANCH TABLE\nPARMKWBT B     KWINVLD            INVALID KEYWORD\n         B     KWPAD              \"PAD\" KEYWORD\n         B     KWALIGN            \"ALIGN\" KEYWORD\n         B     KWNOALIG           \"NOALIGN\" KEYWORD\n         B     KWLNECNT           \"LINECNT\" KEYWORD\n         SPACE\nKWPAD    DS    0H                 \"PAD\" SPECIFIED\n         LTR   PARMRSL,PARMRSL    IS THERE RIGHT SIDE SPECIFIED.......?\n         BZ    PARMERR            NO, ERROR               ------------>\n         CH    PARMRSL,=H'1'      RIGHT SIDE LENGTH = 1   ............?\n         BE    PADCHARS           YES, PAD CHARACTER SPECIFIED-------->\n         CH    PARMRSL,=H'5'      PAD=X\"NN\" MAY BE SPECIFIED..........?\n         BNE   PARMERR            NO, ERROR               ------------>\n         CLC   0(2,PARMRSA),=C'X\"' PAD=X\"NN\" MAY BE SPECIFIED.........?\n         BNE   PARMERR            NO, ERROR               ------------>\n         CLI   4(PARMRSA),C'\"'    PAD=X\"NN\" MAY BE SPECIFIED..........?\n         BNE   PARMERR            NO, ERROR               ------------>\n         MVI   TRT,INVCHC         INVALID CHARACTER\n         MVC   TRT+1(L'TRT-1),TRT INIT TRT WITH INV.CHAR.CODE\n         MVC   TRT+C'A'(6),=10X'00' HEXADECIMAL DIGITS\n         MVC   TRT+C'0'(10),=10X'00' HEXADECIMAL DIGITS\n         TRT   2(2,PARMRSA),TRT   CHECK FOR NON HEX DIGITS............?\n         BNZ   PARMERR            NON HEXADECIMAL CHARS SPECIFIED----->\n         L     R14,OUTRWAA        WORK AREA ADDRESS\n         MVC   0(2,R14),2(PARMRSA) MOVE TWO HEX DIGITS INTO WORK AREA\n         LA    CVALL,2            LENGTH OF HEXADECIMAL STRING\n         BAL   R14,CONVHEX        CONVERT IT TO CHARACTER\n         L     R14,OUTRWAA       WORK AREA ADDRESS\n         MVC   PADCHAR,0(R14)     SAVE PAD CHARACTER\n         B     PARMPEX            EXIT                    ------------>\nPADCHARS MVC   PADCHAR,0(PARMRSA) MOVE PAD CHARACTER\n         B     PARMPEX            EXIT                    ------------>\n         SPACE\nKWALIGN  DS    0H                 \"ALIGN\" SPECIFIED\n         LTR   PARMRSL,PARMRSL    IS THERE RIGHT SIDE SPECIFIED.......?\n         BNZ   PARMERR            YES,ERROR               ------------>\n         OI    PARMFLGS,ALIGN     \"ALIGNMENT\" IN OUTPUT RECORD REQUIRED\n         B     PARMPEX            EXIT                    ------------>\n         SPACE\nKWNOALIG DS    0H                 \"NOALIGN\" SPECIFIED\n         LTR   PARMRSL,PARMRSL    IS THERE RIGHT SIDE SPECIFIED.......?\n         BNZ   PARMERR            YES,ERROR               ------------>\n         NI    PARMFLGS,X'FF'-ALIGN \"NOALIGN\" IN OUTPUT RECORD REQUIRED\n         B     PARMPEX            EXIT                    ------------>\n         SPACE\nKWLNECNT DS    0H                 \"LINECNT\" SPECIFIED\n         LTR   PARMRSL,PARMRSL    IS THERE RIGHT SIDE SPECIFIED.......?\n         BZ    PARMERR            NO, ERROR               ------------>\n         BAL   R14,KWRSCVB        CONVERT KEYWORD RIGHT SIDE TO BINARY\n         MVC   LINECNTL,FULLW     LINE COUNT LIMIT\n         CLC   LINECNTL,=F'48'    LESS THAN MINIMUM SPECIFIED.........?\n         BNL   KWLNEC1            NO                      ------------>\n         MVC   LINECNTL,=F'64'    YES, DEFAULT TAKEN\nKWLNEC1  MVC   LINECNT,LINECNTL   FORCE FIRST NEW PAGE\n         B     PARMPEX            EXIT                    ------------>\n         SPACE\nKWINVLD  DS    0H                 INVALID KEYWORD SPECIFIED (IGNORED)\n         B     PARMERR            PARMS IN ERROR\nPARMPEX  LTR   PARMLR,PARMLR      ARE THERE ANY PARMS LEFT............?\n         BP    PARMLRP            YES,CHECK NEXT PARMS    ------------>\n         B     PARMRET            RETURN                  ------------>\nPARMERR  BAL   R14,PARMERRM       PARM ERROR MESSAGE\nPARMDEF0 MVI   PARMFLGS,X'00'\nPARMRET  SUBRET PARMPROC          RETURN TO CALLER\n         SPACE 3\n*  EXTRACT LEFT  ( KEYWORD ) AND RIGHT ( VALUE ) SIDE OF A PARM\n         SPACE\nPARMELR  SUBENT\n         XR    PARMRSL,PARMRSL    RIGHT SIDE LENGTH = 0\n         XR    PARMLSL,PARMLSL    LEFT SIDE LENGTH = 0\n         SPACE\n*  EXTRACT LEFT SIDE ( KEYWORD )\n         SPACE\n*  SEARCH FOR FIRST CHARACTER OF LEFT SIDE\n         SPACE\nPARMELR0 CLI   0(PARMAR),X'40'    BLANK                    ...........?\n         BE    PARMELN            YES, CHECK NEXT CHARACTER----------->\n         CLI   0(PARMAR),C','     COMMA                    ...........?\n         BE    PARMELN            YES, BYPASS AND CHECK NEXT---------->\nPARMEL   LR    PARMLSA,PARMAR     LEFT SIDE ADDRESS\nPARMEL1  LA    PARMAR,1(0,PARMAR) NEXT CHARACTER ADDRESS\n         LA    PARMLSL,1(0,PARMLSL) LEFT SIDE LENGTH + 1\n         SH    PARMLR,=H'1'       LENGTH - 1\n         BNP   PARMELRT           EXIT IF = 0             ------------>\n         CLI   0(PARMAR),X'40'    BLANK                   ............?\n         BE    PARMELB            YES, END OF LEFT SIDE   ------------>\n         CLI   0(PARMAR),C'='     EQUAL SIGN              ............?\n         BE    PARMELE            YES, EQAL SIGN SPECIFIED------------>\n         CLI   0(PARMAR),C','     COMMA SPECIFIED         ............?\n         BNE   PARMEL1            NO, NCHECK NEXT CHARACTER OF LEFT--->\nPARMELC  SH    PARMLR,=H'1'       PARM LENGTH - 1\n         LA    PARMAR,1(0,PARMAR) NEXT CHAR ADDRESS\n         B     PARMELRT           RETURN\nPARMELN  LA    PARMAR,1(0,PARMAR) NEXT CHAR ADDRESS\n         SH    PARMLR,=H'1'       CHECK NEXT CHARACTER OF LEFT SIDE\n         BNP   PARMPEX            THERE IS NO LEFT SIDE AT ALL\n         B     PARMELR0           SEARCH FOR FIRST CHAR OF LEFT SIDE\nPARMELB  DS    0H                 KEWORD TERMINATED BY BLANK\n* SEARCH FOR EQUAL SIGN\n         LA    PARMAR,1(0,PARMAR) NEXT CHAR ADDRESS\n         SH    PARMLR,=H'1'       PARM LENGTH - 1\n         BNP   PARMELRT           = 0, NO RIGHT SIDE SPECIFIED-------->\n         CLI   0(PARMAR),C'='     EQUAL SIGN              ............?\n         BE    PARMELE            YES, EXTRACT RIGHT SIDE ------------>\n         CLI   0(PARMAR),X'40'    BLANK                   ............?\n         BE    PARMELB            YES, BYPASS             ------------>\n         CLI   0(PARMAR),C','     COMMA                   ............?\n         BE    PARMELC            YES, THERE IS NO RIGHT SIDE--------->\n         B     PARMELRT           NO, START OF NEXT PARM SPECIF------->\n* EQUAL SIGN FOUND, EXTRACT RIGHT SIDE\nPARMELE  LA    PARMAR,1(0,PARMAR) NEXT CHAR ADDRESS\n         SH    PARMLR,=H'1'       LEFT PARM LENGTH - 1\n         BNP   PARMERR            = 0, ERROR,LEFT SIDE VALUE NOT SPEC->\n         CLI   0(PARMAR),X'40'    BLANK                   ............?\n         BE    PARMELE            YES, BYPASS             ------------>\n         CLI   0(PARMAR),C','     COMMA                   ............?\n         BE    PARMERR            YES, RIGHT SIDE VALUE NOT SPECIF---->\n         LR    PARMRSA,PARMAR     RIGHT SIDE ADDRESS\nPARMER   DS    0H                 EXTRACT RIGHT SIDE\n         LA    PARMAR,1(0,PARMAR) NEXT CHAR ADDRESS\n         LA    PARMRSL,1(0,PARMRSL) RIGHT SIDE ( VALUE ) LENGTH + 1\n         CH    PARMRSL,=H'15'     RIGHT SIDE LENGTH > 15  ............?\n         BH    PARMERR            YES, ERROR              ------------>\n         SH    PARMLR,=H'1'       LEFT PARM LENGTH - 1\n         BNP   PARMELRT           = 0, RETURN             ------------>\n         CLI   0(PARMAR),X'40'    BLANK                   ............?\n         BE    PARMERE            YES, END OF RIGHT SIDE  ------------>\n         CLI   0(PARMAR),C','     COMMA                   ............?\n         BNE   PARMER             NO, CHECK NEXT CHAR OF RIGHT SIDE--->\nPARMERE  LA    PARMAR,1(0,PARMAR) NEXT PARM CHAR ADDRESS\n         SH    PARMLR,=H'1'       LEFT PARM LENGTH\nPARMELRT SUBRET PARMELR\n         SPACE\n*  SEARCH FOR SPECIFIED KEYWORD IN THE TABLE OF KEYWORDS\n         SPACE\nPARMSKW  SUBENT\n         LA    R14,PARMKWT        PARM KEYWORDS TABLE ADDRESS\n         USING KWTE,R14           KEYWORD ENTRY FORMAT ADDRESSABILITY\n         XR    R15,R15\nPARMSKWL IC    R15,KWLEN          KEYWORD LENGTH\n         LTR   R15,R15            KEYWORD LENGTH = 0 (UNKNOWN KEYW)...?\n         BZ    PARMSKWR           YES, RETURN\n         CR    R15,PARMLSL        KEWORDS LENGTHS ARE EQUAL ..........?\n         BNE   PARMSKWN           NO, CHECK NEXT            ---------->\n         BCTR  R15,0              KEYWORD LENGTH - 1\n         EX    R15,PARMKCLC       COMPARE KEYWORDS          ..........?\n         LA    R15,1(0,R15)       KEYWORD LENGTH\n         BNE   PARMSKWN           NON EQUAL, CHECK NEXT     ---------->\n         TM    KWFLAGS,KWSPC      WAS KEYWORD SPECIFIED ALREADY.......?\n         BO    PARMERR            YES, ERROR, DUPLICATE SPECIFICATION->\n         OI    KWFLAGS,KWSPC      THIS KEYWORD WAS SPECIFIED ALREADY\n         IC    R15,KWCODE         KEWORD FOUND IN THE TABLE\nPARMSKWR SUBRET PARMSKW           RETURN                    ---------->\nPARMSKWN LA    R14,3(R15,R14)     NEXT KEYWORD ENTRY ADDRESS\n         B     PARMSKWL           CHECK NEXT KEYWORD FROM THE TABLE--->\n         SPACE\nPARMKCLC CLC   0(1,PARMLSA),KWORD COMPARE KEYWORDS\n         DROP  R14\nPARMKWT  DS    0CL1               PARM KEYWORDS TABLE\n         DC    AL1(3),AL1(4),AL1(0),C'PAD'\n         DC    AL1(5),AL1(8),AL1(0),C'ALIGN'\n         DC    AL1(7),AL1(12),AL1(0),C'NOALIGN'\n         DC    AL1(7),AL1(16),AL1(0),C'LINECNT'\n         DC    AL1(0)             LAST DUMMY ENTRY\n         SPACE\n*  CONVERT RIGHT SIDE OF A PARM TO BINARY\nKWRSCVB  DS    0H                 CONVERT PARM VALUE TO BINARY\n         MVI   TRT,X'FF'          SETUP TRT TABLE TO CHECK NUMERICS\n         MVC   TRT+1(L'TRT-1),TRT\n         MVC   TRT+C'0'(10),=XL10'00' NUMERICS\n         LR    R15,PARMRSL        RIGHT SIDE LENGTH\n         BCTR  R15,0              - 1\n         EX    R15,PARMRSCN       CHECK NUMERIC IN RIGHT SIDE\n         BNZ   PARMERR            NON NUMERIC FOUND, ERROR\n         EX    R15,KWRSPACK       PACK\n         CVB   R15,D              CONVERT RIGHT SIDE VALUE TO BINARY\n         ST    R15,FULLW          STORE IN WORK FIELD\n         BR    R14                RETURN\nPARMRSCN TRT   0(1,PARMRSA),TRT   CHECK FOR NUMERICS TRT\nKWRSPACK PACK  D,0(1,PARMRSA)     PACK PARM RIGHT SIDE VALUE\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT CURRENT INPUT RECORD                                         *\n*---------------------------------------------------------------------*\n         SPACE\nPRNTCIR  SUBENT\n         TM    PRNTFLGS,CURECPF   PRINTED ALREADY       ..............?\n         BO    PRNTCIRX           YES, EXIT             -------------->\n         MVI   CIR,X'40'          BLANK CIR\n         MVC   CIR+1(L'CIR-1),CIR\n         L     R0,IRECNT          INPUT RECORD COUNT\n         CVD   R0,D               CONVERT TO DECIMAL\n         MVC   CIRNO,=X'402020202120' EDIT MASK\n         ED    CIRNO,D+5          EDIT IRECNT\n         XR    R1,R1              BEGINING OF OUTREC OFFSET ( = 0 )\n         TM    FLAGS,RECFMV       VARIABLE RECORD FORMAT..............?\n         BNO   PRNTCIR0           NO, BEGINNING IS AT OFFSET 0-------->\n         LA    R1,4(0,R1)         YES, BEGINNING AT OFFSET 4\nPRNTCIR0 CH    R1,PRNTOFFS        FIRST CONSTANT OFFSET ..............?\n         BNE   PRNTCIR1           NO, IT IS NOT BEGINING OF NEW REC--->\n         L     R0,OUTRCNT         OUTPUT RECORD COUNT\n         AH    R0,=H'1'           + 1\n         C     R0,LOUTRCNT        = LAST PRINTED OUTRCNT..............?\n         BE    PRNTCIR1           YES, THIS OUTREC NO. ALREADY PRINTED>\n         ST    R0,LOUTRCNT        LAST PRINTED OUTREC NUMBER\n         CVD   R0,D               CONVERT TO DECIMAL\n         MVC   CIRNOO,=X'402020202120' EDIT MASK\n         ED    CIRNOO,D+5          EDIT IRECNT\nPRNTCIR1 TM    PRNTFLGS,PRNTOFF   OFFSET OF FIRST CONST.HAS TO BE PRNT?\n         BNO   PRNTCIRP           NO, CONTINUE          -------------->\n         LH    R0,PRNTOFFS        FIRST CONSTANT OFFSET IN OUTREC\n         CVD   R0,D               CONVERT TO DECIMAL\n         MVC   CIROFF,=X'402020202120' EDIT MASK\n         ED    CIROFF,D+5         EDIT OFFSET\nPRNTCIRP MVC   CIRT,REC80         INPUT RECORD\n         MVC   MSGREC1,CIR        MOVE PRINT TEXT INTO MESSAGE AREA\n         BAL   R14,PRNTMSG        PRINT IT\nPRNTCIRX OI    PRNTFLGS,CURECPF   CURREN RECORD PRINTED FLAG\n         NI    PRNTFLGS,X'FF'-PRNTOFF OFFSET NOT KNOWN\n         SUBRET PRNTCIR           EXIT\n         SPACE\n*---------------------------------------------------------------------*\n*  GET NEXT INPUT RECORD                                              *\n*---------------------------------------------------------------------*\n         SPACE\nGETNREC  SUBENT\n         GET   SYSIN,REC80        GET RECORD INTO SCAN AREA\n         NI    FLAGS1,X'FF'-CEXPCT SET OFF CONTINUATION EXPECTED FLAG\n         LA    R0,1\n         A     R0,IRECNT          INPUT RECORD COUNT\n         ST    R0,IRECNT\n         LA    SCANADR,REC80      SCAN STRING ADDRESS\n         LA    SCANLEN,71         SCAN STRING LENGTH\n         NI    PRNTFLGS,X'FF'-CURECPF SET OFF CURRENT INPUT RECORD\n*                                     PRINTED FLAG\n         SUBRET GETNREC           EXIT\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT ERROR MESSAGE                                                *\n*---------------------------------------------------------------------*\n         SPACE\nERMSGP   SUBENT\n         MVC   EMLMSGT(L'EMLMSGT),EMLMSGT-1 BLANK MESSAGE TEXT AREA\n         SR    R14,R14\n         IC    R14,0(0,R1)        MESSAGE TEXT LENGTH - 1\n         LA    R0,L'EMLMSGT-1     LENGTH OF MESSAGE AREA - 1\n         CR    R14,R0             IS MESSAGE TEXT LEN > MSG AREA LEN..?\n         BNH   ERMSGPM            NO, MOVE IT           -------------->\n         LR    R14,R0             YES, CUT OFF PART OF MSG TEXT\nERMSGPM  EX    R14,MVCMSGT        MOVE MESSAGE TEXT INTO RECORD\n         L     R0,IRECNT          CURRENT INPUT RECORD NUMBER\n         BAL   R14,CONVHC         CONVERT HALFWORD TO CHARACTERS\n         MVC   EMLIRN,CHAR6+1     MOVE IT INTO MSG LINE\n         LR    R0,SCANADR         CURRENT SCAN CHAR ADDRESS\n         LA    R14,REC80          BEGINNING OF SCAN AREA\n         SR    R0,R14             SCAN OFFSET\n         AH    R0,=H'1'           SCAN COLUMN\n         BAL   R14,CONVHC         CONVERT HALFWORD TO CHARACTERS\n         MVC   EMLSCN,CHAR6+4     MOVE IT INTO MSG LINE\n         L     R0,CCIRECN         CURRENT CONSTANT RECORD NUMBER\n         BAL   R14,CONVHC         CONVERT HALFWORD TO CHARACTERS\n         MVC   EMLCRN,CHAR6+1     MOVE IT INTO MSG LINE\n         L     R0,CCCOL           CURRENT CONSTANT VALUE REC.NO.\n         BAL   R14,CONVHC         CONVERT HALFWORD TO CHARACTERS\n         MVC   EMLCCN,CHAR6+4     MOVE IT INTO MSG LINE\n         BAL   R14,PRNTCIR        PRINT CURRENT INPUT REC.IF NOT PRNTED\n         MVC   MSGREC1,ERMSGL\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         SUBRET ERMSGP\nMVCMSGT  MVC   EMLMSGT(1),1(R1)   MOVE MSG TEXT INTO LINE\n         SPACE\nERMSGL   DS    0CL133             ERROR MESSAGE LINE\n         DC    C' ***********'\nEMLIRN   DS    CL5                ERROR INPUT REC NUMBER\n         DC    C','\nEMLSCN   DS    CL2                LAST SCAN COLUMN NUMBER\n         DC    C' '\nEMLCRN   DS    CL5                BEGINING OF CONSTANT REC.NO.\n         DC    C','\nEMLCCN   DS    CL2                BEGINING OF CONSTANT COL.NO.\n         DC    C' '\nEMLMSGT  DC    CL(L'ERMSGL-(*-ERMSGL))' '\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT MSG LINE                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nPRNTMSG  SUBENT\nPRNTMSGE CLI   MSGREC1,X'40'      NO SPACING               ...........?\n         BE    PRNTMSG1           YES                      ----------->\n         CLI   MSGREC1,C'+'       IN THE SAME LINE         ...........?\n         BE    PRNTMSG0           YES                      ----------->\n         CLI   MSGREC1,C'0'       ONE BLANK LINE           ...........?\n         BE    PRNTMSG2           YES                      ----------->\n         CLI   MSGREC1,C'-'       TWO BLANK LINES          ...........?\n         BE    PRNTMSG3           YES                      ----------->\n         MVI   MSGREC1,C'-'       INVALID CONTROL CHAR SECIF., CHANGE\n         B     PRNTMSGE           CHECK AGAIN              ----------->\nPRNTMSG0 SR    R0,R0              IN THE SAME LINE PRINTING\n         B     PRNTMSGL           CHECK IF FITS INTO THE PAGE--------->\nPRNTMSG1 LA    R0,1               IN THE NEXT LINE PRINTING\n         B     PRNTMSGL           CHECK IF FITS INTO THE PAGE--------->\nPRNTMSG2 LA    R0,2               ONE BLANK LINE BEFORE\n         B     PRNTMSGL           CHECK IF FITS INTO THE PAGE--------->\nPRNTMSG3 LA    R0,3               TWO BLANK LINES BEFORE\nPRNTMSGL A     R0,LINECNT         CHECK IF FITS INTO THE PAGE\n         C     R0,LINECNTL        LINE COUNT LIMIT EXCEEDED...........?\n         BH    PRNTMSGP           YES, NEW PAGE            ----------->\n         ST    R0,LINECNT         NO, NEW LINE COUNT\n         PUT   PRINT,MSGREC1      NO, PRINT MESSAGE\n         MVI   MSGREC1,X'40'      CLEAR MSGREC1\n         MVC   MSGREC1+1(L'MSGREC1-1),MSGREC1\n         SUBRET PRNTMSG\nPRNTMSGP BAL   R14,NEWPAGE        NEW PAGE\n         MVI   MSGREC1,X'40'      NO SPACING REQUIRED AFTER NEW PAGE\n         B     PRNTMSGE           PRINT MESSAGE AFTER NEW PAGE\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT NEW PAGE HEADER                                              *\n*---------------------------------------------------------------------*\n         SPACE\nNEWPAGE  SUBENT\n         LH    R1,PAGENO          CURRENT PAGE NUMBER\n         CVD   R1,D               CONVERT TO DECIMAL\n         LA    R1,1(0,R1)         NEXT PAGE NUMBER\n         STH   R1,PAGENO\n         MVC   HPAGENO,=X'402020202120' EDIT MASK\n         ED    HPAGENO,D+5        EDIT PAGE NUMBER\n         PUT   PRINT,HEADLNE1\n         LA    R0,3               LINE COUNT =3\n         ST    R0,LINECNT\n         MVI   MSGREC,X'40'\n         MVC   MSGREC+1(L'MSGREC-1),MSGREC\n         PUT   PRINT,HEADLNE2     HEAD LINE 2\n         PUT   PRINT,MSGREC       ONE BLANK LINE\n         SUBRET NEWPAGE\n         SPACE\nHEADLNE1 DS    0CL133             HEADLINE NUMBER 1\n         DC    CL13'1OUT.REC'\n         DC    CL78'JJDGEN - TEST DATA GENERATION UTILITY'\n         DC    CL17'INPUT    OUTPUT'\nHDATE    DC    CL9' '\n         DC    C'      PAGE'\nHPAGENO  DS    CL6                PAGE NUMBER\n         SPACE\nHEADLNE2 DS    0CL133             HEAD LINE NUMBER 2\n         DC    C' '               CONTROL CHARACTER\n         DC    C'OFFSET'          FIRST CONSTANT OFFSET IN OUTREC\n         DC    C'  '              GAP\n         DC    CL80'----+----1----+----2----+----3----+----4----+----5-C\n               ---+----6----+----7--'\n         DC    C'  '              GAP\n         DC    C'REC.NO   REC.NO' INPUT AND OUTPUT RECORD NUMBER\n         DC    CL(L'HEADLNE2-(*-HEADLNE2))' '\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT 1 BLANK LINE                                                 *\n*---------------------------------------------------------------------*\n         SPACE\nBLANKLNE SUBENT\n         BAL   R14,LNECNTP1       LINE COUNT + 1\n         CLC   LINECNT,LINECNTL   WILL FIT INTO THIS PAGE.............?\n         BH    BLNKLNPG           NO,  PRINT NEW PAGE HEADER---------->\n         MVI   MSGREC,X'40'\n         MVC   MSGREC+1(L'MSGREC-1),MSGREC\n         PUT   PRINT,MSGREC\nBLNKLRET SUBRET BLANKLNE          RETURN TO CALLER\nBLNKLNPG BAL   R14,NEWPAGE        NEW PAGE\n         B     BLNKLRET           RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*  LINE COUNT + 1                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nLNECNTP1 DS    0H                 LINE COUNT + 1\n         LA    R0,1               LINE COUNT + 1\n         A     R0,LINECNT\n         ST    R0,LINECNT\n         BR    R14                RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* CONVERT A HALFWORD TO CHARACTER FORMAT ( HALFW VALUE IS IN R0 )     *\n*---------------------------------------------------------------------*\n         SPACE\nCONVHC   DS    0H                 CONVERT HALFWORD TO CHARACTER FORMAT\n         CVD   R0,D               CONVERT TO DECIMAL\n         MVC   CHAR6,=X'402020202120'  EDIT MASK INTO WORK FIELD\n         ED    CHAR6,D+5          EDIT INTO CHARACTER FORMAT\n         BR    R14                RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*  INITIALISATION OF PROGRAM ( SOME CONSTANTS )                       *\n*---------------------------------------------------------------------*\n         SPACE\nINIT     DS    0H\n         MVC   LINECNT,=F'64'     FORCE NEW PAGE AT THE BEGINING\n         MVC   LINECNTL,=F'64'    DEFAULT PAGE LINE COUNT\n         MVC   PAGENO,=H'1'       FIRST PAGE NUMBER\n         MVI   PARMFLGS,X'00'     DEFAULT PARM\n         MVI   FLAGS,X'00'        INIT OF FLAGS\n         MVI   PADCHAR,X'40'      DEFAULT PAD CHARACTER\n         SR    R0,R0\n         ST    R0,IRECNT          COUNTERS TO ZERO\n         ST    R0,OUTRCNT         COUNTERS TO ZERO\n         ST    R0,LOUTRCNT\n         LA    R0,DSA             DSA ADDRESS\n         A     R0,OUTRA           OUTPUT RECORD ADDRESS\n         ST    R0,OUTRA\n         LA    R0,DSA             DSA ADDRESS\n         A     R0,OUTRWAA         OUTPUT RECORD WORK AREA ADDRESS\n         ST    R0,OUTRWAA\n         SPACE\n         EXTRACT TIOTA,FIELDS=TIOT EXTRACT TO GET JOBNAME\n         L     R1,TIOTA           TIOT ADDRESS\n         MVC   JOBNAME,0(R1)      SAVE JOB NAME\n         BR    R14                RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*     DCB EXIT FOR PRINT FILE ( SETS UP DEFAULT BLKSIZE )             *\n*---------------------------------------------------------------------*\n         SPACE\nPRTDCBEX DS    0H                 EXIT IF BLKSIZE NOT SPECIFIED        +\n                                  MSG DATA SET\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         LH    R2,DCBBLKSI        LOAD BLKSIZE\n         LTR   R2,R2              BLKSIZE=0 ..........................?\n         BNZR  R14                NO,RETURN <----------------\n         MVC   DCBBLKSI,DCBLRECL  BLKSIZE=LRECL========================\n         BR    R14                RETURN    <----------------\n         DROP  R1\n         SPACE\nCLOSE    DS    0H                 FINAL CLOSE OF FILES\n         CLOSE (PRINT,,SYSIN,,OUTF)\n         BR    R14                RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*  END OF PROCESSING MESSAGE                                          *\n*---------------------------------------------------------------------*\n         SPACE\nEOPMSG   SUBENT\n         MVC   EOPRECN1,=XL10'40202020202020202120'\n         L     R0,IRECNT          INPUT RECORD COUNT\n         CVD   R0,D               CONVERT TO DECIMAL\n         ED    EOPRECN1,D+3       EDIT INPUT RECORD COUNT\n         MVC   MSGREC1(L'EOPMSG1),EOPMSG1 MSG TEXT INTO PRINT LINE\n         BAL   R14,PRNTMSG        PRINT INPUT RECORD COUNT MESSAGE\n         MVC   EOPRECN2,=XL10'40202020202020202120'\n         L     R0,OUTRCNT         OUTPUT RECORD COUNT\n         CVD   R0,D               CONVERT TO DECIMAL\n         ED    EOPRECN2,D+3       EDIT OUTPUT RECORD COUNT\n         MVC   MSGREC1(L'EOPMSG2),EOPMSG2 MSG TEXT INTO PRINT LINE\n         BAL   R14,PRNTMSG        PRINT OUTPUT RECORD COUNT MESSAGE\n         MVC   MSGREC1(L'EOPMSGT),EOPMSGT MESSAGE TEXT INTO MESSAGE REC\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         SUBRET EOPMSG            RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*  ERRONOUS PARMS SPECIFIED MESSAGE                                   *\n*---------------------------------------------------------------------*\n         SPACE\nPARMERRM SUBENT\n         MVI   MSGREC1,X'40'      BLANK MSGREC1\n         MVC   MSGREC1+1(L'MSGREC1-1),MSGREC1\n         L     R1,PARMA           PARMS ADDRESS\n         USING PARML,R1\n         MVC   HALF,PARMLEN\n         LH    R15,HALF           PARMS LENGTH\n         BCTR  R15,0              PARMS LENGTH - 1\n         EX    R15,MVCPARMS       MOVE PARMS INTO MESSAGE LINE\n         MVC   MSGREC1+(132-L'PRMERRMT)(L'PRMERRMT),PRMERRMT\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         BAL   R14,BLANKLNE       BLANK LINE AFTER MESSAGE\n         SUBRET PARMERRM          RETURN\nMVCPARMS MVC   MSGREC1+1(1),PARMT MOVE PARMS INTO MESSAGE LINE\n         DROP  R1\n         SPACE\n*  MESSAGE DATA SET\n         SPACE\nPRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,            +\n               LRECL=133,EXLST=PRTEXLST\n         SPACE\n*  INPUT FILE\n         SPACE\nSYSIN    DCB   DSORG=PS,MACRF=(GM),DDNAME=SYSIN,                       +\n               RECFM=FB,LRECL=80,EODAD=EOF\n         SPACE\n*  OUTPUT FILE\n         SPACE\nOUTF     DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSUT1\n         SPACE\nPRTEXLST DS    0F                 PRINT DCB EXLST\n         DC    X'85',AL3(PRTDCBEX) EXIT FOR BLKSIZE NOT SPECIFIED\n         SPACE\nEOPMSG1  DS    0CL74                  END OF PROCESSING MESSAGE 1\n         DC    C'-JJDGEN - NUMBER OF RECORDS READ FROM SYSIN FILE      +\n                       : '\nEOPRECN1 DC    XL10'40202020202020202120'\nEOPMSG1E EQU   *\n         SPACE\nEOPMSG2  DS    0CL74                  END OF PROCESSING MESSAGE 2\n         DC    C'0JJDGEN - NUMBER OF RECORDS WRITTEN ( GENERATED ) INTO+\n                SYSUT1 : '\nEOPRECN2 DC    XL10'40202020202020202120'\nEOPMSG2E EQU   *\n         SPACE\nEOPMSGT  DC    C'-JJDGEN     E N D    O F    P R O C E S S I N G'\nSINOPNEM DC    C'-JJDGEN     SYSIN DCB COULD NOT BE OPENED. PROCESSING +\n               TERMINATED, RC = 16'\nOUTOPNEM DC    C'-JJDGEN     SYSUT1 DCB COULD NOT BE OPENED. PROCESSING+\n                TERMINATED, RC = 16'\nINVRFMM  DC    C'-JJDGEN     SYSUT1 HAS INVALID RECORD FORMAT SPECIFIED+\n               , PROCESSING TERMINATED, RC = 16'\nPRMERRMT DC    C'PARM  SPECIFICATION ERROR,  PARMS IGNORED'\nPRTOPNEM WTO   'JOBNAME , JJDGEN  SYSPRINT DCB COULD NOT BE OPENED. PRO+\n               CESSING TERMINATED',MF=L\n         SPACE\nDECVLLMM ERMSG 'NUMERIC CONSTANT NOMINAL VALUE LENGTH IS GREATER THAN 1+\n               5 CHARACTERS'\nVALOORM  ERMSG 'BINARY CONSTANT VALUE IS OUT OF RANGE ( EITHER MIN. OR +\n               MAX. )'\nDECVLL0M ERMSG 'CONSTANT NOMINAL VALUE IS NOT SPECIFIED'\nEXPCNRM  ERMSG 'EXPECTED CONTINUATION NOT RECEIVED'\nOFFSMERM ERMSG 'OFFSET MODIFIER SPECIFICATION ERROR'\nDUPFLERM ERMSG 'DUPLICATION FACTOR SPECIFICATION ERROR'\nINVCHARM ERMSG 'INVALID CHARACTER FOUND'\nLENMERM  ERMSG 'LENGTH MODIFIER SPECIFICATION ERROR'\nLRECEXCM ERMSG 'LRECL OF OUTPUT RECORD EXCEEDED'\nVALELEM  ERMSG 'SPECIFIED CONSTANT LENGTH IS GREATER THAN LENGTH MODIFI+\n               ER'\nEDEXPVNS ERMSG 'FLOATING POINT EXPONENT VALUE NOT SPECIFIED'\nEDEXPLEX ERMSG 'MORE THAN 3 DIGITS EXPONENT NOT ALLOWED'\nMCSCM    ERMSG 'CONSTANT SPECIFICATION CONTINUATION IS MISSING'\n         SPACE\n         PRINT DATA\nMAXBIN   DC    P'2147483647'      MAX.BINARY NUMBER EXCEEDED\nMAXBINFP DC    D'2147483647'      MAX.BINARY NUMBER IN FP FORMAT\nONETENTH DC    L'0.1'             ONE TENTH IN EXTENDED FP FORMAT\n         PRINT NODATA\n         SPACE\nOUTRA    DC    A(OUTR-DSA)        OUTPUT RECORD ADDRESS\nOUTRWAA  DC    A(OUTRWA-DSA)      OUTPUT RECORD WORK AREA ADDRESS\n         LTORG\n         SPACE\n*  DYNAMIC STORAGE AREA\nDSA      DSECT\nSA       DS    18F                SAVE AREA\nFULLW    DS    F                  WORK FULLWORD\nLINECNT  DS    F                  PAGE LINE COUNT\nLINECNTL DS    F                  PAGE LINE COUNT LIMIT\nIRECNT   DS    F                  INPUT RECORD COUNT\nOUTRCNT  DS    F                  OUTPUT RECORD COUNT\nLOUTRCNT DS    F                  LAST PRINTED OUTREC COUNT\nCCCOL    DS    F                  CURRENT CONST. STAR COLUMN\nCCIRECN  DS    F                  CURRENT CONSTANT RECORD NUMBER\nDUPF     DS    F                  DUPLICATION FACTOR VALUE\nLENGTHM  DS    F                  LENGTH MODIFIER VALUE\nFPMAXV   DS    F                  MAX.VALUE OF FIX.POINT (BINARY) CONST\nFPMINV   DS    F                  MIN.VALUE OF \"F\" OR \"H\" TYPE CONST.\nFPNVL    DS    H                  MAX LENGTH (DEC.DIGITS) OF FP VALUE\nPAGENO   DS    H                  SYSPRINT PAGE NUMBER\nHALF     DS    H                  WORK HALFWORD\nLRECL    DS    H                  LRECL SPECIFIED FOR SYSUT1\nOFFSET   DS    H                  CURRENT CONSTANT SPECIF. OFFSET\nPRNTOFFS DS    H                  FIRST CONST.OFFSET ON THIS IN.REC.\nOUTOFFS  DS    H                  AVAILABLE OFFSET IN OUTPUT RECORD\nNVCNT    DS    H                  NOMINAL VALUE COUNT\nOUTCSOFF DS    H                  IN OUTREC - LAST CONST. START OFFSET\nTRT      DS    CL256              TRANSLATE AND TEST TABLE\nTRTAB    DS    CL256              TRANSLATE TABLE\nJOBNAME  DS    CL8                JOB NAME\nCHAR6    DS    CL6                WORK FIELD\nMSGREC   DS    CL133              MESSAGE RECORD\nMSGREC1  DS    CL133              MESSAGE RECORD\nREC80    DS    CL80               INPUT RECORD AREA\n         SPACE\nEDD      DS    D                  VALUE OF FP NUM. IN FP REPRESENTATION\nEDDL     DS    D                  LOW ORDER PART OF EXTENDED NUMBER\nEDE      DS    E                  VALUE OF SHORT (TYPE=E) FP NUM.\nED10     DS    H                  POWER OF 10 THAT NUMBER HAS TO BE\n*                                 MULTIPLIED BY\nEDEXP    DS    H                  VALUE OF THE FLOATING POINT EXPONENT\nEDSGD    DS    H                  NUMBER OF SIGNIFICANT DIGITS\nEDFLAGS  DS    XL1                FLAGS\nEDSDF    EQU   BIT0               FIRST SIGNIFICANT DIGIT FOUND\nEDDPF    EQU   BIT1               DECIMAL POINT FOUND\nEDEF     EQU   BIT2               EXPONENT FOUND\nEDFPC    EQU   BIT3               SUBROUTINE EDCONV ALREADY EXECUTED\nEDFP0    EQU   BIT4               THE FP NUMBER = 0\nEDSIGN   DS    CL1                SIGN OF FP NUMBER\nEDCEND   EQU   *                  END OF ED CONSTANTS\n         SPACE\nCIR      DS    0CL133             CURRENT INPUT RECORD FOR OUTPUT\n         DC    C' '               CONTROL CHARACTER\nCIROFF   DC    X'402020202120'    FIRST CONSTANT OFFSET IN OUTREC\n         DC    C'  '              GAP\nCIRT     DS    CL80               RECORD ITSELF\n         DC    C'  '              GAP\nCIRNO    DC    X'402020202120'    INPUT RECORD NUMBER\n         DC    C'  '              GAP\nCIRNOO   DC    X'402020202120'    OUTPUT RECORD NUMBER\n         DC    CL(L'CIR-(*-CIR))' ' END, EMPTY PART\n         SPACE\nPADCHAR  DC    X'40'              PAD CHARACTER\nFUNBYTE  DS    XL1                FUNCTION BYTE FROM TRANSLATE AND TEST\nTYPE     DS    XL1                FIELD TYPE CODE\nTYPEVLD  DS    XL1                CONST.VALUE LEFT DELIMITER\nTYPEVRD  DS    XL1                CONST.VALUE RIGHT DELIMITER\nVALSIGN  DS    CL1                NUMERIC VALUE SIGN\n         SPACE\nFLAGS    DC    X'00'              FLAGS\nRECFMF   EQU   BIT0               SYSUT1 RECFM=F SPECIFIED\nRECFMV   EQU   BIT1               SYSUT1 RECFM=V SPECIFIED\nRECFMU   EQU   BIT2               SYSUT1 RECFM=U SPECIFIED\n         SPACE\nPARMFLGS DC    X'00'              PARM FLAGS\nALIGN    EQU   BIT0               H,F TYPE CONSTANTS ALIGNMENT REQUIRED\n         SPACE\nFLAGS1   DC    X'00'              FLAGS ( OPERATIONAL )\nSEARCHNC EQU   BIT0               SEARCH FOR A NEW CONSTANT FLAG\nCONPINP  EQU   BIT1               CONSTANT PROCESSING IS IN PROGRESS\n*                                 IN PROGRESS\nCHARVPP  EQU   BIT2               CHARACTER VALUE PROCESSING IS IN\nDUPFP    EQU   BIT3               DUPLICATION FACTOR PRESENT FLAG\nOFFSP    EQU   BIT4               OFFSET SPECIFICATION PRESENT FLAG\nLENMP    EQU   BIT5               LENGTH SPECIFICATION PRESENT FLAG\nCEXPCT   EQU   BIT6               CONTINUATION OF OUT.REC.EXPECTED FLAG\n*                                 ( IN CASE OF END-OFF-FILE CONDITION )\n         SPACE\nFLAGS2   DC    X'00'              FLAGS ( OPERATIONAL )\nINVCHAR  EQU   BIT0               INVALID CHAR MESSAGE PRINTED FLAG\nLRECLEX  EQU   BIT1               OUTPUT LRECL EXCEEDED\nCONTEXP  EQU   BIT2               CONTINUATION EXPECTED FLAG\n         SPACE\nPRNTFLGS DC    X'00'              PRINTING FLAGS\nCURECPF  EQU   BIT0               CURRENT INPUT RECORD PRINTED FLAG\nPRNTOFF  EQU   BIT1               CURRENT IN.REC.FIRST CONST.OFFSET\n*                                 HAS TO BE PRINTED\n         SPACE\nZONED    DS    ZL15               ZONED WORK FIELD\nD        DS    D                  WORK DOUBLEWORD\nOUTR     DS    CL32768            OUTPUT RECORD AREA\nOUTRWA   DS    CL32768            WORK AREA INTO WHICH INPUT CONSTANTS\n         DS    CL32768            ARE MOVED BY PARSE ROUTINE\nDSAE     EQU   *                  DSA END\n         SPACE 2\n*  PARM FIELD FORMAT\nPARML    DSECT\nPARMLEN  DS    AL2                LENGTH OF PARM TEXT\nPARMT    DS    CL100              PARM TEXT\n         SPACE\n         DCBD  DSORG=PS\n         SPACE 2\n*  PARM KEYWORD TABLE ENTRY FORMAT\nKWTE     DSECT\nKWLEN    DS    XL1                KEYWORD LENGTH\nKWCODE   DS    XL1                KEYWORD CODE\nKWFLAGS  DS    XL1                KEYWORD FLAGS\nKWSPC    EQU   BIT0               KEYWORD ALREADY SPECIFIED FLAG\nKWORD    DS    CL30               KEYWORD ITSELF\n         END   JJDGEN\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.LOADLIB....\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME JJDGEN(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JJPDSD": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\"\\x00\\x83\\x16\\x1f\\x01\\x025/\\x156\\x00\\xf1\\x00\\xb9\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1983-06-10T00:00:00", "modifydate": "2002-12-18T15:36:22", "lines": 241, "newlines": 185, "modlines": 0, "user": "SYMP118"}, "text": "//.......  JOB ......YOUR JOB CARD\n//*\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=VIO,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=VIO,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'DELETE ALL MEMBERS OF A PDS DATA SET'\n* DELETE PDS MEMBERS ROUTINE\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: JJPDSD\n*\n* FUNCTION = SEE BELOW\n*\n*          THIS ROUTINE CAN DELETE ALL MEMBERS FROM A PDS LIBRARY.\n*       IT MAY BE HELPFUL IN MAINTAINING SOURCE, OBJECT, LOAD, JCL\n*       LIBRARIES. CHANGED MEMBERS CAN BE DELETED FROM TARGET LIBRARY,\n*       THEN TARGET LIBRARY CAN BE COMPRESSED AND THEN NEW MEMBERS\n*       COPIED INTO IT. THIS USED TO BE USED IN AN IN HOUSE CHANGE\n*       MANAGEMENT WHERE UPDATED MEMBERS WERE PLACED IN STAGING\n*       PDS'ES. THIS IS BECAUSE \"PDS\" AND \"PDSD\" DD'S CAN BE\n*       DIFFERENT DATASETS (IF THEY ARE THE SAME - ALL MEMBERS\n*       WILL BE DELETED).\n*          THE PROGRAM WORKS AGAINST PDSE DATASETS AS WELL (\n*       APPARENTLY FASTER THAN AGAINST A PDS).\n*\n*    INPUT TO THE ROUTINE:\n*\n*         . PDS    - TARGET PDS LIBRARY\n*         . PDSD   - DDNAME FOR DIRECTORY PROCESSING\n*                    MEMBER NAMES FROM THIS DIRECTORY ARE WRITTEN INTO\n*                    SYSUT1 AND THEN DELETED FROM PDS.\n*\n*    INPUT - OUTPUT      :\n*\n*         . SYSUT1 - WORK DATA SET, MEMBER NAMES TO BE DELETED\n*\n* WRITTEN BY: JANEK JAKUBEK, OGL\n*         JUNE  1983\n*\n* A SAMPLE JCL PROC CAN BE SET UP TO RUN THE PROGRAM :\n* //PDSDEL   PROC DISP=OLD                                                000300\n* //*---------------------------------------------------------------***   000400\n* //*&  DELETES ALL MEMBERS FROM A PDS DATA SET                     ***   000410\n* //*---------------------------------------------------------------***   000500\n* //PDSDEL  EXEC PGM=JJPDSD\n* //STEPLIB   DD DSN=...,DISP=SHR\n* //PDS       DD DSN=&PDS,DISP=SHR\n* //PDSD      DD DSN=&PDS,DISP=SHR\n* //SYSUT1    DD UNIT=SYSDA,SPACE=(TRK,(1,1))\n* //*---------------------------------------------------------------***   000400\n* //*&  COMPRESS DELETED PDS TO RECLAIM RELEASED SPACE              ***   000300\n* //*&  COMPRESS STEP IS NOT REQUIRED FOR PDSE                      ***   000300\n* //*---------------------------------------------------------------***   000400\n* //CMPRSS  EXEC PGM=IEBCOPY                                              000400\n* //SYSPRINT  DD SYSOUT=*                                                 000500\n* //INOUT     DD DSN=&PDS,DISP=&DISP                                      000600\n* //SYSUT3    DD  SPACE=(CYL,(1,1),,CONTIG),UNIT=SYSDA                    000700\n* //SYSUT4    DD  SPACE=(CYL,(1,1),,CONTIG),UNIT=(SYSDA,SEP=SYSUT3)       000800\n* //SYSIN     DD  DSN=.....PARMLIB(CMPRS),DISP=SHR                        000900\n*\n* CHANGE ACTIVITY:\n*                 NONE\n*\n         PRINT NOGEN\nJJPDSD1  CSECT                    CSECT NAME\nJJPDSD1  AMODE 24\nJJPDSD1  RMODE 24\n         DC    C'JJPDSD ',AL1(7)\nJJPDSD   SAVE  (14,12)            SAVE REGISTERS\n         USING JJPDSD,R15\n         ENTRY JJPDSD             ENTRY POINT\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\nEDBA     EQU   R11                END OF DIRECTORY BLOCK ADDRESS\nDIREAR   EQU   R9                 DIRECTORY ENTRY ADDRESS\nWRKR1    EQU   R8                 WORK REGISTER 1\nDCBOFOPN EQU   X'10'              DCB OPENED FLAG\n         SPACE\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   WRKR1,SAE          SAVE AREA ADDRESS\n         DROP  R15\nSA       DS    18F                SAVE AREA\n         USING SA,WRKR1\nSAE      ST    R13,SA+4           CHAIN\n         ST    WRKR1,8(R13)       SAVE AREAS\n         LR    R13,WRKR1          CURRENT SAVE AREA\n         DROP  WRKR1\n         USING SA,R13             PROGRAM BASE REGISTER\n         USING DIRE,DIREAR        DIRECTORY ENTRY ADDRESSABILITY\n         SPACE\n*  OPEN DIRECTORY ( PDSD )\n         SPACE\n         OPEN  (PDSD,(INPUT))\n         TM    PDSD+48,DCBOFOPN   OPEN SUCCESSFUL        .............?\n         BNO   PDSDOPNE           NO, OPEN ERROR         ------------->\n         SPACE\n*  OPEN PDS INPUT DATA SET\n         SPACE\n         OPEN  (PDS,(UPDAT))\n         TM    PDS+48,DCBOFOPN    OPEN SUCCESSFUL        .............?\n         BNO   PDSOPNER           NO, OPEN ERROR         ------------->\n*  OPEN WORK FILE ( SYSUT1 )\n         SPACE\n         OPEN  (WRK,(OUTPUT))\n         TM    WRK+48,DCBOFOPN    OPEN SUCCESSFUL        .............?\n         BNO   OUTOPNER           NO, OPEN ERROR         ------------->\n         SPACE\n*  READ DIRECTORY BLOCK\n         SPACE\nREADDB   GET   PDSD,DIRB          READ DIRECTORY BLOCK\n         LH    EDBA,DIRB          NO. OF ACTIVE DIRECTORY BYTES\n         LA    EDBA,DIRB(EDBA)    END OF DIRECTORY BLOCK ADDRESS\n         LA    DIREAR,DIRB+2      FIRST ENTRY ADDRESS\n         SPACE\nMBRPROC  DS    0H                 MEMBER PROCESSING\n         CLC   MNAME,DIRENDC      END OF DIRECTORY....................?\n         BE    EODIR              YES, END OF INPUT DIRECTORY--------->\n         MVC   MBRNAME,MNAME      MEMBER NAME INTO WORK RECORD\n         PUT   WRK,MBRNAME        WRITE RECORD WITH MEMBER NAME\n         SPACE\n         XR    WRKR1,WRKR1       DETERMINATION OF CURRENT DIR ENTRY LEN\n         IC    WRKR1,NH           NO OF USER DATA HALFWORDS\n         SLL   WRKR1,27           LOOSE ALIAS AND NO.OF TTRS DATA\n         SRL   WRKR1,26           NO.OF HALFWORDS * 2 = NO.OF BYTES\n         LA    DIREAR,DIRE+12(WRKR1) NEXT DIR ENTRY ADDRESS\n         CR    DIREAR,EDBA        END OF DIRECTORY BLOCK ALREADY......?\n         BL    MBRPROC            NO, PROCESS NEXT DIR ENTRY---------->\n         B     READDB             YES, READ NEXT DIR BLOCK\n         SPACE\nEODIR    DS    0H                 END OF INPUT DIRECTORY\n         CLOSE (PDSD,,WRK)\n         OPEN  (WRK,(INPUT))      OPEN WORK FILE AS INPUT\nREADMN   GET   WRK,MBRNAME        GET MEMBER NAME\n         STOW  PDS,MBRNAME,D\n         B     READMN\nEOFWRK   DS    0H                 END OF WORK FILE\nCLOSE    CLOSE (PDS,,WRK)         CLOSE FILES AND TERMINATE\n         SPACE\nRET0     XR    R15,R15            RC=0\nRET      L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)\n         SPACE\nRC16     LA    R15,16             RC FROM SAVE = 16\n         B     RET                RETURN\n         SPACE\nPDSDOPNE DS    0H                 PDSD DCB OPEN ERROR\n         LA    R1,PDSDOEMA\n         B     WTO                WRITE MESSAGE TO OPERATOR\n         SPACE\nPDSOPNER DS    0H                 PDS DCB OPEN ERROR\n         LA    R1,PDSOEMA\n         B     WTO                WRITE MESSAGE TO OPERATOR\n         SPACE\nOUTOPNER DS    0H                 OUT DCB OPEN ERROR\n         LA    R1,OUTOEMA\nWTO      LINK  EP=WTO             WRITE ERROR MESSAGE\n         B     RC16               RETURN CODE = 16\n         SPACE\n         LTORG\n         DS    0F\nDIRB     DS    CL256              DIRECTORY BLOCK\nPDSDOEMA DC    X'80',AL3(PDSDOEM) ERROR MESSAGE ADDRESS\nPDSOEMA  DC    X'80',AL3(PDSOEM)  ERROR MESSAGE ADDRESS\nOUTOEMA  DC    X'80',AL3(OUTOEM)  ERROR MESSAGE ADDRESS\nPDSDOEM  DC    AL2(PDSDOEME-PDSDOEM-2),C'INPUT PDS DATA SET DIRECTORY C+\n               ANNOT BE OPEN'\nPDSDOEME EQU   *\nPDSOEM   DC    AL2(PDSOEME-PDSOEM-2),C'INPUT PDS DATA SET CANNOT BE OPE+\n               N'\nPDSOEME  EQU   *\nOUTOEM   DC    AL2(OUTOEME-OUTOEM-2),C'OUTPUT ( DDNAME = SYSUT1 ) DATA +\n               SET CANNOT BE OPEN'\nOUTOEME  EQU   *\nDIRENDC  DC    8X'FF'             LAST DIRECTORY ENTRY CHARACTERS\nMBRNAME  DS    CL8                MEMBER NAME RECORD\n         SPACE\n*  PDS DATA SET - PDS\nPDS      DCB   DEVD=DA,DSORG=PO,MACRF=(R,W),DDNAME=PDS\n*  PDS DATA SET - DIRECTORY\nPDSD     DCB   DEVD=DA,DSORG=PS,MACRF=GM,DDNAME=PDSD,RECFM=FB,         +\n               LRECL=256,BLKSIZE=256\n*  OUTPUT WORK DATA SET\nWRK      DCB   DSORG=PS,MACRF=(GM,PM),DDNAME=SYSUT1,RECFM=FB,LRECL=8,  +\n               BLKSIZE=800,EODAD=EOFWRK\n         SPACE 2\n*  DIRECTORY (PDS FILE) ENTRY FORMAT\nDIRE     DSECT\nDIREL    EQU   42                 PDS DIRECTORY ENTRY LENGTH\nMNAME    DS    CL8                MEMBER NAME\nTTR      DS    CL3                FIRST RECORD TTR\nNH       DS    XL1                NO. OF HALFWORDS OF USER DATA\nUSERD    DS    0CL30              MAX DIRECTORY USER DATA\n         END   JJPDSD\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.LOADLIB....\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME JJPDSD(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JJTBGEN": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x00\\x90)\\x8f\\x01\\x01$\\x9f\\x14F\\x05\\t\\x05\\t\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-10-25T00:00:00", "modifydate": "2001-09-06T14:46:13", "lines": 1289, "newlines": 1289, "modlines": 0, "user": "SYMP118"}, "text": "         TITLE 'CREATE TABLE FOR PROCESSING BY \"HALVE\" SUBROUTINE'\n* LOAD MODULE FORMAT TABLE CREATION ROUTINE\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: JJTBGEN\n*\n* ATTRIBUTES : NONE\n*\n* PRIVATE MACROS : \"SUBENT\" - ENTRY INTO INTERNAL SUBROUTINE\n*                  \"SUBRET\" - EXIT FROM AN INTERNAL SUBROUTINE\n*\n* FUNCTION = SEE BELOW\n*\n*    THIS ROUTINE CREATES A TABLE WHICH CAN BE PROCESSED BY \"HALVE\"\n* BINARY SEARCH SUBROUTINE.\n*\n*  INPUT TO THE ROUTINE:\n*\n*    . SYSIN    - CONTROL DATA SET (CONTROL STMTS DEFINING THE TABLE)\n*    . TBLIN    - SEQUENTIAL FILE FROM WHICH TABLE WILL BE CREATED. ONE\n*                 RECORD WILL BE CONVERTED TO ONE TABLE ELEMENT. TABLE\n*                 ELEMENTS ARE IN THE SAME SEQUENCE AS RECORDS IN\n*                 IN TBLIN.\n*\n*  OUTPUT:\n*\n*    . SYSUT1   - OUTPUT FILE. CONTAINS 80 BYTES RECORDS WITH AN\n*                 ASSEMBLER CSECT AND CONSTANTS CONTAINING DESCRIPTION\n*                 OF THE TABLE AND TABLE ELEMENTS. IT HAS TO BE THEN\n*                 COMPILED AND LINKEDITED.\n*    . SYSPRINT - MESSAGE DATA SET\n*\n* COMPILED AND LINKEDITED TABLE CAN BE LOADED INTO STORAGE USING\n* \"LOAD\" MACRO OR ANY HIGH LEVEL LANGUAGE EQUIVALENT AND THEN ACCESSED\n* USING \"HALVE\" TABLE BINARY SEARCH SUBROUTINE.\n*\n*\n* SYSIN CONTROL STATEMENTS:\n*\n*  SYNTAX: CAN BE SPECIFIED IN COLOMNS 1 TO 72. NO CONTINUATION IS\n*  ALLOWED. CONTROL STMT CONSISTS OF A KEYWORD SEPARATED BY ONE OR\n*  MORE BLANKS FROM AN OPERAND. THE FOLLOWING CONTROL STMTS CAN BE\n*  SPECIFIED:\n*\n*  .\"NAME\" - OPTIONAL, SPECIFIES NAME OF THE TABLE CSECT.\n*\n*  .\"EXTRACT\" - OPTIONAL, SPECIFIES DATA TO BE EXTRACTED FROM ONE INPUT\n*    RECORD TO CREATE ONE TABLE ELEMENT. OPERAND CONSISTS OF PAIRS OF\n*    NUMBERS BEING RESPECTIVELY POSITION AND LENGTH OF DATA TO BE\n*    EXTRACTED. MORE THEN ON \"EXTRACT\" STMT CAN BE SPECIFIED. TABLE\n*    ELEMENT IS ASSEMBLED FROM DATA SPECIFIED IN ALL \"EXTRACT\" STMTS\n*    IN THE SAME SEQUENCE AS SPECIFIED IN SYSIN. IF NO \"EXTRACT\" IS\n*    SPECIFIED - ONE TBLIN RECORD IS CONVERTED INTO ONE TABLE ELEMENT.\n*    IF TBLIN CONTAINS \"V\" OR \"U\" FORMAT RECORDS - \"EXTRACT\" HAS TO BE\n*    SPECIFIED BECAUSE TABLE ELEMENTS HAVE TO BE OF EQUAL LENGTH.\n*\n*  .\"KEYLEN\" - LENGTH OF THE KEY OF THE TABLE ELEMENT. IT CAN BE\n*    SPECIFIED IF KEY IS LOCATED IN THE FRONT OF THE TABLE ELEMENT AND\n*    TABLE IS SORTED IN CHARACTER ASCENDING SEQUENCE. IF SPECIFIED,\n*    JJTBGEN  CHECKS IF INPUT FILE IS CORRECTLY SORTED. \"KEYLEN\" IS\n*    MUTUALLY EXCLUSIVE WITH \"COMPARE\" STMT. EITHER \"KEYLEN\" OR\n*    \"COMPARE\" HAS TO BE SPECIFIED. LENGTH OF THE KEY HAS TO BE:\n*    1 <= \"KEYLEN\" <= 256.\n*\n*  .\"COMPARE\" - ENTRY POINT NAME OF COMPARE EXIT ROUTINE TO BE USED BY\n*    \"HALVE\" SUBROUTINE. IF TABLE'S KEY DOES NOT SATISFY CONDITIONS\n*    AS STATED IN \"KEYLEN\" DISCUSSION ABOVE - USER HAS TO PROVIDE HIS\n*    OWN EXIT TO BE USED BY \"HALVE\". EXIT ROUTINE HAS TO BE WRITTEN IN\n*    ASSEMBLER AND LINKEDITED WITH THE TABLE AS ONE LOAD MODULE. SUCH\n*    EXIT MAKES POSSIBLE CREATION OF TABLES WITH VARIABLE LENGTH\n*    ELEMENTS WHICH CAN BE ACCESSED USING BINARY SEARCH TECHNIQUE.\n*    BINARY SEARCH LOCATES MID ELEMENT OF A TABLE (OR CURRENT TABLE\n*    SEGMENT) AND COMPARES ITS KEY WITH INPUT KEY PROVIDED IN THE CALL\n*    OF \"HALVE\". IF THEY ARE EQUAL - SEARCH IS TERMINATED. IF INPUT KEY\n*    IS LOWER  THAN MID ELEMENT'S KEY, PROCEEDS TO SEARCH FIRST PART\n*    OF THE TABLE AS DELIMITED BY THE MID ELEMENT. OTHERWISE SEARCH\n*    CONTINUES WITHIN SECOND PART OF THE TABLE. \"HIGHER\", \"EQUAL\",\n*    \"LOWER\" TERMS REFLECT RELATIVE ORDER OF KEYS IN THE TABLE. THEIR\n*    RELATIVE LOCATION WITHIN THE TABLE. INTERFACE TO THE COMPARE EXIT\n*    IS THE FOLLOWING (ON INPUT):\n*      R13 - SAVE AREA ADDRESS\n*      R14 - RETURN ADDRESS\n*      R15 - ENTRY POINT ADDRESS\n*      R5  - INPUT KEY ADDRESS (KEY PRESENTED TO \"HALVE\")\n*      R11 - TABLE MID ELEMENT ADDRESS\n*    ON OUTPUT R15 HAS TO CONTAIN ONE OF THE RETURN CODES:\n*      0  IF KEYS ARE EQUAL\n*      4  IF INPUT KEY IS HIGHER THAN MID ELEMENT'S KEY\n*      8  IF INPUT KEY IS LOWER  THAN MID ELEMENT'S KEY\n*    CONTENTS OF ANY OTHER REGISTER THAN R15 CAN NOT BE MODIFIED BY THE\n*    EXIT.\n*\n* FORMAT OF SYSIN CONTROL STATEMENTS:\n*\n*    NAME name         - NAME OF THE TABLE CSECT\n*    KEYLEN value      - LENGTH OF THE KEY\n*    COMPARE name      - ENTRY POINT NAME OF COMPARE EXIT\n*    EXTRACT (p1,l1),(p2,p2),(p3,l3),.....\n*                      - pn, ln  ARE POSITION OF DATA IN THE TBLIN\n*                        RECORD AND LENGTH OF DATA RESPECTIVELY.\n*                        IF THERE IS NO ENOUGH OF ROOM ON THE SYSIN\n*                        RECORD TO SPECIFY ALL DATA TO BE INCLUDED IN\n*                        A TABLE ELEMENT - ANOTHER EXTRACT STMT SHOULD\n*                        BE SPECIFIED IN THE NEXT SYSIN RECORD.\n*\n* CONTROL STMTS CAN BE SPECIFIED IN ANY SEQUENCE IN THE SYSIN.\n*\n* SAMPLE JCL TO RUN THE PROGRAM :\n*\n* //TBGEN   EXEC PGM=JJTBGEN\n* //STEPLIB   DD DSN=SYS1.UTIL.LINKLIB,DISP=SHR\n* //TBLIN     DD DSN=OGL.TABLE(TBLXYZ),DISP=SHR\n* //TBOUT     DD UNIT=VIO,DSN=&&TABLE,SPACE=(4080,(10,10)),\n* //             DISP=(,PASS),DCB=BLKSIZE=4080\n* //SYSPRINT  DD SYSOUT=*\n* //SYSIN     DD *\n* NAME TBLXYZ\n* EXTRACT (1,50),(60,20)\n* KEYLEN 12\n* /*\n* //        EXEC ASMFCL\n* //ASM.SYSIN DD DSN=&&TABLE,DISP=(OLD,DELETE)\n* //LKED.SYSLMOD DD DSN=SYS2.TBLINK(TBLXYZ),DISP=SHR\n*\n* END OF THE SAMPLE JCL\n*\n* WRITTEN BY: JOHN JAKUBEK, OGL\n*                MARCH     1986\n*\n* CHANGE ACTIVITY:\n*        NONE\n*\n         SPACE\n         MACRO\n&LAB     SUBENT\n.* \"SUBENT\" MACRO IS USED AT ENTRY TO AN INTERNAL SUBROUTINE\n.* LINK REGISTER HAS TO BE ALWAYS R14.\n.* IT SHOULD BE USED WHENEVER R14 IS CHANGED BY SUBROUTINE.\n.*\n.* EXAMPLE:\n.*          ...\n.*          BAL   R14,SUBRNAME\n.*          ...\n.* SUBRNAME SUBENT\n.*          ...             SUBROUTINE'S CODE\n.*          SUBRET SUBRNAME\n.*\n&LAB     DS    0F\n         B     *+16               AROUND EYE CATCHER AND R14 SAVE\n         DC    CL8'&LAB'          EYE CATCHER\n         DC    F'0'               R14 SAVE\n         ST    R14,*-4            STORE R14\n         MEND\n         MACRO\n&LAB1    SUBRET &LAB\n.* \"SUBRET\" MACRO IS USED AT EXIT FROM AN INTERNAL SUBROUTINE.\n.* IT IS INTENDED TO BE USED JOINTLY WITH \"SUBENT\" MACRO\n&LAB1    L     R14,&LAB+12              RESTORE R14\n         BR    R14                      RETURN\n         MEND\n         SPACE\nOFDTBGN1 CSECT                   CSECT NAME\n         DC    C'JJTBGEN  ',AL1(8) DUMP EYE CATCHER\n         TSTAMP\n         PRINT NOGEN\nJJTBGEN  SAVE  (14,12)            SAVE REGISTERS\n         USING JJTBGEN ,R15\n         ENTRY JJTBGEN            ENTRY POINT\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n* R0,R1,R2,R3,R14,R15 - WORK REGISTERS\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\n*--------I N I T I A L I Z A T I O N----------------------------------*\n         SPACE\n         DROP  R15\n         BALR  R12,0              SETUP PROGRAM ADDRESSABILITY\n         USING *,R12,R11\n         LA    R11,2048(,R12)     SECOND BASE REGISTER\n         LA    R11,2048(,R11)\n         L     R0,DSAS            DSA SIZE\n         GETMAIN R,LV=(0)         GET STORAGE FOR DSA\n         USING DSA,R1\n         ST    R13,SA+4           CHAIN\n         ST    R1,8(R13)          SAVE AREAS\n         LR    R13,R1             CURRENT SAVE AREA\n         DROP  R1\n         USING DSA,R13            DSA ADDRESSABILITY\n         SPACE\n         BAL   R14,INIT           INITIALIZATION\n         SPACE\n*--------M A I N L I N E----------------------------------------------*\n         SPACE\n*  OPEN MESSAGE FILE ( PRINT )\n         SPACE\n         OPEN  (PRINT,(OUTPUT))\n         TM    PRINT+48,DCBOFOPN  OPEN SUCCESSFUL        .............?\n         BNO   PRTOPNER           NO, OPEN ERROR         ------------->\n         BAL   R14,TBLINOP        OPEN TBLIN FILE\n         LTR   R15,R15            TABLE INPUT FILE O.K................?\n         BNZ   EOPERR             NO, TERMINATE WITH ERROR MSG-------->\n         SPACE\n*  OPEN SYSIN FILE ( TABLE DEFINITION )\n         OPEN  (SYSIN,(INPUT))\n         TM    SYSIN+48,DCBOFOPN  OPEN SUCCESSFUL        .............?\n         BNO   SINOPNER           NO, OPEN ERROR         ------------->\n         BAL   R14,TBLDEFP        PROCESS DEFINITION OF THE TABLE\n         LTR   R15,R15            DEFINITION OF THE TABLE O.K.........?\n         BNZ   EOPERR             NO, TERMINATE WITH ERROR MSG-------->\n         SPACE\n*  OPEN OUTPUT FILE ( 80 BYTES RECORDS, TABLE CSECT )\n         SPACE\n         OPEN  (TBLOUT,(OUTPUT))\n         TM    TBLOUT+48,DCBOFOPN OPEN SUCCESSFUL        .............?\n         BNO   OUTOPNER           NO, OPEN ERROR         ------------->\n         BAL   R14,TBLHDRP        WRITE OUT TABLE HEADER(CSECT+TDEF)\n         SPACE\n*  READ TBLIN AND WRITE OUT TABLE ELEMENTS\n         SPACE\n         BAL   R14,TBLPROC\n         LTR   R15,R15            NO PROBLEMS WITH TABLE CREATION.....?\n         BNZ   EOPERR             ERROR, TERMINATION WITH MSG--------->\n         BAL   R14,TBLEND         WRITE TABLE END LABEL AND STMT\n         B     EOP                NORMAL END OF PROCESSING\n         SPACE\n*--------T E R M I N A T I O N----------------------------------------*\n         SPACE\nEOP      BAL   R14,EOPMSG         END OF PROCESSING MESSAGE\n         BAL   R14,CLOSE          CLOSE THE FILES\n         SPACE\nRET0     XR    R15,R15            RC=0\nRET      L     R0,DSAS            DSASIZE\n         LR    R1,R13             DSA ADDRESS\n         L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         LR    R2,R15           SAVE RETURN CODE (FREEMAIN CHANGES R15)\n         FREEMAIN R,LV=(0),A=(1)  FREEMAIN DSA\n         LR    R15,R2             RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)\n         SPACE\nEOPERR   BAL   R14,EOPERM         TERMINATION WITH ERROR MESSAGE\n         BAL   R14,CLOSE          CLOSE THE FILES\n         B     RC16               RC = 16\n         SPACE\nRC16     LA    R15,16             RC FROM SAVE = 16\n         B     RET                RETURN\n         SPACE 2\nSINOPNER DS    0H                 SYSIN OPEN ERROR\n         MVC   MSGREC1(L'SINOPNEM),SINOPNEM\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     RC16               TERMINATE WITH RC=16\n         SPACE 2\nOUTOPNER DS    0H                 SYSUT1 OPEN ERROR\n         MVC   MSGREC1(L'OUTOPNEM),OUTOPNEM\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     RC16               TERMINATE WITH RC=16\n         SPACE 2\nPRTOPNER DS    0H                 PRINT DCB OPEN ERROR\n         MVC   PRTOPNEM+4(8),JOBNAME JOB NAME INTO MESSAGE TEXT\n         WTO   MF=(E,PRTOPNEM)    WTO   ERROR MESSAGE\n         B     RC16               RETURN CODE = 16\n         SPACE\n*--------S U B R O U T I N E S----------------------------------------*\n         SPACE\n*  OPEN TBLIN FILE ( TABLE CONTENTS INPUT )\nTBLINOP  SUBENT\n         OPEN  (TBLIN,(INPUT))\n         TM    TBLIN+48,DCBOFOPN  OPEN SUCCESSFUL        .............?\n         BNO   INOPNER            NO, OPEN ERROR         ------------->\n*  CHECK IF VALID RECORD FORMAT\n         TM    TBLIN+36,DCBRECU   UNDEFINED              .............?\n         BO    OUTRFMU            YES, O.K.              ------------->\n         TM    TBLIN+36,DCBRECF   FIXED LENGTH           .............?\n         BO    OUTRFMF            YES, O.K.              ------------->\n         TM    TBLIN+36,DCBRECV   VARIABLE               .............?\n         BNO   INVRECFM           NO, INVALID RECORD FORMAT----------->\n         TM    TBLIN+36,DCBRECSB  VARIABLE SPANNED RECORDS............?\n         BNO   OUTRFMV            NO, CONTINUE------------------------>\n         CLOSE (TBLIN)            YES, CLOSE TBLIN TO CHANGE BFTEK\n         OI    TBLIN+32,DCBBFTA   BFTEK=A FOR SPANNED RECORDS\n         OPEN  (TBLIN,(INPUT))    REOPEN THE FILE AFTER CHANGE OF BFTEK\nOUTRFMV  OI    FLAGS,RECFMV       RECFM=V SPECIFIED FOR SYSUT1\n         B     TBLINOP0           NORMAL RETURN----------------------->\nOUTRFMF  OI    FLAGS,RECFMF       RECFM=F SPECIFIED FOR SYSUT1\n         MVC   LRECL,TBLIN+82     RECORD LENGTH = LRECL\n         B     TBLINOP0           NORMAL RETURN----------------------->\nOUTRFMU  OI    FLAGS,RECFMU       RECFM=U SPECIFIED FOR SYSUT1\nTBLINOP0 SR    R15,R15            NORMAL RETURN (RC=0)\nTBLINOPR SUBRET TBLINOP\n         SPACE\nINVRECFM DS    0H                 TBLIN INVALID RECORD FORMAT\n         MVC   MSGREC1(L'INVRFMM),INVRFMM\n         BAL   R14,PRNTMSG        PRINT MESSAGE\nTBLINOPE LA    R15,16             TERMINATE WITH RC=16\n         B     TBLINOPR\n         SPACE\nINOPNER  DS    0H                 TBLIN  OPEN ERROR\n         MVC   MSGREC1(L'INOPNEM),INOPNEM\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     TBLINOPE           TERMINATE WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\n*  WRITE OUT TABLE HEADER (CSECT + TABLE DEFINITION FIELDS)\nTBLHDRP  SUBENT\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n         MVC   R80(8),CSECTNM     CSECT NAME TO OUTPUT RECORD\n         MVC   R80+9(5),=C'CSECT'\n         PUT   TBLOUT,R80         WRITE RECORD WITH CSECT\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         MVC   R80(L'SAREC),SAREC SAVE AREA RECORD\n         PUT   TBLOUT,R80         WRITE RECORD WITH SAVE AREA\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         MVC   R80(L'FEAREC),FEAREC FIRST ENTRY (TABLE) ADDRESS RECORD\n         PUT   TBLOUT,R80         WRITE RECORD\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         LH    R0,TBLELEN         LENGTH OF THE TABLE ELEMENT\n         CVD   R0,D               CONVERT TO DECIMAL\n         UNPK  WRK15,D            UNPACK IT\n         OI    WRK15+14,X'F0'     INSERT ZONE\n         MVC   LEN,WRK15+10       MOVE ELEMENT LENGTH INTO DC LINE\n         MVC   R80(LENRECE-LENREC),LENREC TABLE ELEMENT LENGTH RECORD\n         PUT   TBLOUT,R80         WRITE RECORD\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         MVC   OFFS,LEN           OFFSET IS THE SAME AS ELEMENT LENGTH\n         MVC   R80(OFFRECE-OFFREC),OFFREC TABLE ELEMENTS OFFSET RECORD\n         PUT   TBLOUT,R80         WRITE RECORD\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n         MVC   R80(KLRECE-KLREC),KLREC TABLE KEY LENGTH OR COMPARE\n*                                      EXIT ADDRESS\n         PUT   TBLOUT,R80         WRITE RECORD\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         MVC   NMLEN,LEN          MOVE ELEMENT LENGTH INTO FORMULA\n         MVC   R80(NMRECE-NMREC),NMREC MAX.NO.OF ELEMENTS IN THE TABLE\n         PUT   TBLOUT,R80         WRITE RECORD\n         PUT   TBLOUT,R80         MAX.NO. IS THE SAME AS CURRENT NO.\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         MVC   R80(L'EAEPREC),EAEPREC ELEMENT ADDRESS/POSITION\n         PUT   TBLOUT,R80         WRITE TWO FULLWORD FIELDS\n         PUT   TBLOUT,R80\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         MVC   R80(L'FIRSTE),FIRSTE FIRST ELEMENT LABEL\n         PUT   TBLOUT,R80         WRITE RECORD\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n         SUBRET TBLHDRP           RETURN FROM SUBROUTINE\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\n*  TERMINATE TABLE PROCESSING (WRITE TBLEND LABEL AND CSECT END)\nTBLEND   SUBENT\n         MVC   R80(L'TBLENDL),TBLENDL END OF TABLE LABEL\n         PUT   TBLOUT,R80         WRITE RECORD\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n*\n         MVC   R80(L'CSEND),CSEND CSECT END\n         PUT   TBLOUT,R80         WRITE RECORD\n         BAL   R14,BLANKR80       BLANK OUTPUT RECORD\n         SUBRET TBLEND            RETURN FROM SUBROUTINE\n         SPACE\n* TABLE DEFINITION FIELDS\nSAREC    DC    C' DS 20A'         TBDEF SAVE AREA\nFEAREC   DC    C' DC A(FIRSTE)'   TBDEF FIRST ENTRY ADDRESS\nLENREC   DC    C' DC AL2('        TBDEF ELEMENT LENGTH\nLEN      DS    CL5                TABLE ELEMENT LENGTH\n         DC    C')'               CLOSING PARENTHESIS\nLENRECE  EQU   *\nOFFREC   DC    C' DC AL2('       TBDEF ELEMENTS OFFSET\nOFFS     DS    CL5                TABLE ELEMENTS OFFSET\n         DC    C')'               CLOSING PARENTHESIS\nOFFRECE  EQU   *\nKLREC    DC    C' DC '            LENGTH OF THE KEY OR COMPARE EXIT\nKLORCOMP DC    C'A('              A IS REPLACED BY V FOR COMPARE EXIT\nKL       DS    CL8                KEY LENGTH OR COMPARE NAME\n         DC    C') '              CLOSING PARENTHESIS\nKLRECE   EQU   *\nNMREC    DC    C' DC '            MAX.NO OF ELEMENTS IN THE TABLE\n         DC    C'A((TBLEND-FIRSTE)/'\nNMLEN    DS    CL5                LENGTH OF ONE TABLE ELEMENT\n         DC    C')'               CLOSING PARENTHESIS\nNMRECE   EQU   *\nEAEPREC  DC    C' DS A'           ELEMENT ADDRESS/POSITION FIELDS\nFIRSTE   DC    C'FIRSTE EQU *'    FIRST ELEMENT LABEL\nTBLENDL  DC    C'TBLEND EQU *'    END OF TABLE LABEL\nCSEND    DC    C' END'            CSECT END STMT\n         SPACE\n* BLANK R80 FIELD (OUTPUT RECORD FIELD)\nBLANKR80 MVI   R80,C' '\n         MVC   R80+1(L'R80-1),R80\n         BR    R14                RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*                                                                     *\n*  PROCESS SYSIN INPUT (TABLE DEFINITION)                             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nKWADDR   EQU   R4                 ADDRESS OF A KEYWORD\nKWLENR   EQU   R5                 LENGTH OF A KEYWORD\nOPADDR   EQU   R6                 ADDRESS OF OPERAND FIELD\nOPLEN    EQU   R7                 LENGTH OF OPERAND FIELD\n         SPACE\nTBLDEFP  SUBENT\n         MVI   TBLDEFLG,X'00'     INITIALYZE FLAGS\n         MVC   CSECTNM,=CL8'TBLDEF' DEFAULT CSECT NAME\n         XC    NOEXTP,NOEXTP      NO.OF EXTRACT PAIRS = ZERO\n         XC    SINRCNT,SINRCNT    SYSIN RECORD COUNT =  ZERO\n         MVI   MSGREC1,X'40'      CLEAR MSGREC1\n         MVC   MSGREC1+1(L'MSGREC1-1),MSGREC1\nGETSYSIN GET   SYSIN,R80          READ SYSIN RECORD\n         L     R1,SINRCNT         SYSIN RECORD COUNT\n         LA    R1,1(,R1)          + 1\n         ST    R1,SINRCNT         SAVE IT\n         BAL   R14,EXTKWRD        EXTRACT A KEYWORD AND OPERAND\n         BAL   R14,SRCHKWD        SEARCH FOR KEYWORDS\n         B     KWDBT(R15)         KEYWORDS BRANCH TABLE\nKWDBT    B     KWINVLD            INVALID KEYWORD\n         B     KWNAME             \"NAME\" KEYWORD\n         B     KWKEYLEN           \"KEYLEN\" KEYWORD\n         B     KWCOMPAR           \"COMPARE\" KEYWORD\n         B     KWEXTRAK           \"EXTRACT\" KEYWORD\n         SPACE\nKWINVLD  DS    0H                 INVALID STMT KEYWORD SPECIFIED\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         MVC   MSGREC1+1(L'INVSTMTM),INVSTMTM  MOVE MSG TEXT INTO LNE\n         B     SYSINERR           PRINT ERROR MESSAGE     ------------>\n         SPACE\n* \"NAME\" STMT\nKWNAME   DS    0H                 TABLE CSECT NAME SPECIFIED\n         TM    TBLDEFLG,NAMESPEC  NAME ALREADY SPECIFIED..............?\n         BO    DUPSTMT            DUPLICATE NAME STMT    ------------->\n         LTR   OPLEN,OPLEN        IS THERE NAME SPECIFIED.............?\n         BZ    NAMEMIS            NO, NAME MISSING       ------------->\n         CH    OPLEN,=H'8'        NAME LENGTH <= 8       .............?\n         BH    NAMELENE           NO, CSECT NAME TOO LONG------------->\n         MVI   CSECTNM,C' '       BLANK CSECT NAME FIELD\n         MVC   CSECTNM+1(L'CSECTNM-1),CSECTNM\n         BCTR  OPLEN,0            LENGTH OF NAME -1\n         EX    OPLEN,MVCSNME      MOVE CSECT NAME INTO FIELD---------->\n         OI    TBLDEFLG,NAMESPEC  NAME ALREADY SPECIFIED FLAG\nKWPROCEX BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         B     GETSYSIN           READ NEXT SYSIN RECORD-------------->\nMVCSNME  MVC   CSECTNM(1),0(OPADDR) MOVE CSECT NAME\n         SPACE\nDUPSTMT  DS    0H                 DUPLICATE STMT ERROR MSG\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         MVC   MSGREC1+1(L'DUPSTMTM),DUPSTMTM MOVE MSG TEXT INTO LNE\nSYSINERR OI    TBLDEFLG,SYSINERF  ERROR IN SYSIN FLAG\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     GETSYSIN           GET NEXT INPUT RECORD\n         SPACE\nOPERMIS  DS    0H                 MISSING OPERAND MESSAGE\nNAMEMIS  DS    0H                 NAME MISSING IN \"NAME\" STMT\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         MVC   MSGREC1+1(L'OPERMISM),OPERMISM MOVE MSG TEXT INTO LNE\n         B     SYSINERR           PRINT ERROR MESSAGE     ------------>\n         SPACE\nNAMELENE DS    0H                 CSECT NAME > 8 CHARACTERS\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         MVC   MSGREC1+1(L'NAMELENM),NAMELENM MOVE MSG TEXT INTO LNE\n         B     SYSINERR           PRINT ERROR MESSAGE     ------------>\n         SPACE\n* PRINT SYSIN RECORD\nPRINTSIR SUBENT\n         MVC   MSGREC1+1(L'R80),R80 MOVE SYSIN RECORD INTO MSG LINE\n         BAL   R14,PRNTMSG        PRINT SYSIN RECORD      ------------>\n         SUBRET PRINTSIR          RETURN                  ------------>\n         SPACE\n* \"COMPARE\" STMT\nKWCOMPAR DS    0H                 COMPARE EXIT NAME SPECIFIED\n         TM    TBLDEFLG,KEYLSPEC  \"KEYLEN\" SPECIFIED PREVIOUSLY.......?\n         BO    COMPKLEX           YES, KEYLEN AND COMPARE ARE EXCLUSIVE\n         TM    TBLDEFLG,COMPSPEC  \"COMPARE\" ALREADY SPECIFIED.........?\n         BO    DUPSTMT            DUPLICATE NAME STMT    ------------->\n         LTR   OPLEN,OPLEN        IS THERE NAME SPECIFIED.............?\n         BZ    NAMEMIS            NO, NAME MISSING       ------------->\n         CH    OPLEN,=H'8'        NAME LENGTH <= 8       .............?\n         BH    NAMELENE           NO, CSECT NAME TOO LONG------------->\n         MVI   KLORCOMP,C'V'      INSERT EXTERNAL REFERENCE CONSTANT\n         MVI   KL,C' '            BLANK EXIT NAME FIELD\n         MVC   KL+1(L'KL-1),KL\n         LA    R1,KL(OPLEN)       ADDRESS OF FIRST CHARACTER AFTER NAME\n         BCTR  OPLEN,0            LENGTH OF NAME -1\n         EX    OPLEN,MVCEXNME     MOVE EXIT  NAME INTO FIELD---------->\n         MVC   0(2,R1),=C') '     INSERT ) AFTER EXIT NAME\n         OI    TBLDEFLG,COMPSPEC  NAME ALREADY SPECIFIED FLAG\n         B     KWPROCEX           PRINT SYSIN RECORD      ------------>\nMVCEXNME MVC   KL(1),0(OPADDR)    MOVE EXIT  NAME\n         SPACE\nCOMPKLEX DS    0H                 \"KEYLEN\" AND \"COMPARE\" ARE MUTUALLY\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         MVC   MSGREC1+1(L'COMPKLMX),COMPKLMX MOVE MSG TEXT INTO LNE\n         B     SYSINERR           PRINT ERROR MESSAGE     ------------>\n         SPACE\nKWKEYLEN DS    0H                 KEYLEN SPECIFIED\n         TM    TBLDEFLG,COMPSPEC  \"COMPARE\" SPECIFIED PREVIOUSLY......?\n         BO    COMPKLEX           YES, KEYLEN AND COMPARE ARE EXCLUSIVE\n         TM    TBLDEFLG,KEYLSPEC  \"KEYLEN\" ALREADY SPECIFIED..........?\n         BO    DUPSTMT            DUPLICATE NAME STMT    ------------->\n         LTR   OPLEN,OPLEN        OPERAND IS SPECIFIED................?\n         BZ    OPERMIS            NO, OPERAND MISSING    ------------->\n         CH    OPLEN,=H'15'       OPERAND LENGTH > 15    .............?\n         BH    INVKEYL            YES, INVALID KEYLEN MESSAGE--------->\n* CHECK IF NUMERICS SPECIFIED IN KEYLEN\n         MVI   TRT,X'FF'          ONLY NUMERICS ARE VALID\n         MVC   TRT+1(L'TRT-1),TRT\n         MVC   TRT+C'0'(10),=10X'00' NUMERIC CHARACTERS\n         BCTR  OPLEN,0            LENGTH OF OPERAND - 1\n         EX    OPLEN,NUMOPER      NUMERIC ONLY SPECIFIED..............?\n         BNZ   INVKEYL            NO, INVALID KEYLEN SPECIFIED-------->\n         EX    OPLEN,NUMPACK      PACK THE KEYLEN\n         CP    D,=P'256'          IS KEYLEN > 256.....................?\n         BH    INVKEYL            YES, KEYLEN IS INVALID-------------->\n         CVB   R0,D               CONVERT KEYLEN TO BINARY\n         STH   R0,KEYLEN          SAVE IT\n         UNPK  WRK15,D            UNPACK KEYLEN INTO 15 BYTES WRK FIELD\n         OI    WRK15+14,X'F0'     INSETR ZONE INTO DECIMAL SIGN\n         MVI   KLORCOMP,C'A'      INSERT ADDRESS CONSTAND CHARACTER\n         MVC   KL,WRK15+7         MOVE KEYLEN INTO OUTPUT RECORD\n         MVC   KL+8(2),=C') '     INSERT ) AFTER KEYLEN NUMERIC\n         OI    TBLDEFLG,KEYLSPEC  KEYLEN ALREADY SPECIFIED FLAG\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         B     GETSYSIN           READ NEXT SYSIN RECORD-------------->\nNUMOPER  TRT   0(1,OPADDR),TRT    CHECK FOR NUMERICS IN OPERAND\nNUMPACK  PACK  D,0(1,OPADDR)      PACK THE KEYLEN OPERAND\n         SPACE\nINVKEYL  DS    0H                 INVALID KEYLEN SPECIFIED MESSAGE\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         MVC   MSGREC1+1(L'INVKEYLM),INVKEYLM MOVE MSG TEXT INTO LNE\n         B     SYSINERR           PRINT ERROR MESSAGE     ------------>\n         SPACE\n* \"EXTRACT\" STMT\nKWEXTRAK DS    0H                 EXTRACT STMT PROCESSING\n         LTR   OPLEN,OPLEN        IS OPERAND SPECIFIED................?\n         BZ    OPERMIS            NO, OPERAND MISSING    ------------->\nKWEXTLP  CLI   0(OPADDR),C'('     LEFT PARENTHESIS....................?\n         BNE   EXOSYNER           EXTRACT OPERAND SYNTAX ERROR-------->\n         LA    OPADDR,1(,OPADDR)  NEXT CHARACTER ADDRESS\n         SH    OPLEN,=H'1'        NUMBER OF LEFT CHARACTERS\n         BNP   EXOSYNER           INCOMPLETE OPERAND------------------>\n* PROCESSING OF EXTRACT POSITION VALUE\n         MVI   TRT,X'FF'          ONLY NUMERICS ARE VALID\n         MVC   TRT+1(L'TRT-1),TRT\n         MVC   TRT+C'0'(10),=10X'00' NUMERIC CHARACTERS\n         LR    R1,OPLEN           OPERAND LENGTH INTO R1\n         BCTR  R1,0               LENGTH OF OPERAND - 1\n         EX    R1,TRTNUME         SEARCH FOR NONNUMERIC\n         BC    8,EXOSYNER         NUMERICS UNTIL THE END OF OPERAND--->\n         BC    2,EXOSYNER         NONNUMERIC FOUND AT OPERAND END----->\n         CLI   0(R1),C','         IS FOUND DELIMITER A COMMA..........?\n         BNE   EXOSYNER           NO, INVALID DELIMITER--------------->\n         LA    R1,0(,R1)          CLEAR H/O BYTE\n         LR    R15,R1             SAVE COMMA ADDRESS IN R15\n         SR    R1,OPADDR          LENGTH OF POSITION VALUE\n         BNP   EXOSYNER           COMMA RIGHT AFTER PARENTHESIS------->\n*                                 POSITION VALUE NOT SPECIFIED\n         CH    R1,=H'15'          POSITION HAVE MORE THAN 15 DIGITS...?\n         BH    EXOSYNER           YES, ERROR-------------------------->\n         SR    OPLEN,R1           OPERAND LENGTH AFTER POSITION VALUE\n         BAL   R14,CONVEXB        CONVERT EXTRACT VALUE TO BINARY\n         CH    R1,TBLIN+82        IS POSITION WITHIN LOGICAL RECORD...?\n         BH    EXFRNGE            NO, EXTRACT FIELD RANGE ERROR------->\n         TM    FLAGS,RECFMV       TBLIN HAS VARIABLE RECORDS..........?\n         BNO   KWEXTLP1           NO, CONTINUE------------------------>\n         CH    R1,=H'5'           IS POSITION OUTSIDE OF RDW..........?\n         BL    EXFRNGE            NO, RDW SHOULD NOT BE EXTRACTED----->\nKWEXTLP1 LH    R14,NOEXTP         NO.OF EXTRACT PAIRS IN THE TABLE\n         CH    R14,MAXEXTP        IS EXTRACT TABLE ALREADY FULL.......?\n         BNL   EXTBLMAX           YES, FULL , PRINT ERROR MESSAGE----->\n         SLL   R14,2              * 4 = OFFSET OF NEXT AVAILABLE ENTRY\n         STH   R1,EXTBL(R14)      STORE POSITION IN EXTRACT PAIRS TABLE\n* PROCESSING OF EXTRACT FIELD LENGTH VALUE\n         LA    OPADDR,1(,R15)     ADDRESS OF CHARACTER AFTER COMMA\n         SH    OPLEN,=H'1'        LENGTH OF OPERAND AFTER COMMA\n         BNP   EXOSYNER           ERROR, NOTHING AFTER COMMA---------->\n         LR    R1,OPLEN           OPERAND LENGTH INTO R1\n         BCTR  R1,0               LENGTH OF OPERAND - 1\n         EX    R1,TRTNUME         SEARCH FOR NONNUMERIC\n         BC    8,EXOSYNER         NUMERICS UNTIL THE END OF OPERAND--->\n         CLI   0(R1),C')'         CLOSING PATENTHESIS.................?\n         BNE   EXOSYNER           NO, INVALID DELIMITER--------------->\n         LA    R1,0(,R1)          CLEAR H/O BYTE\n         LR    R15,R1             SAVE ) ADDRESS IN R15\n         SR    R1,OPADDR          LENGTH OF FIELD LENGTH VALUE\n         BNP   EXOSYNER           ) IS  RIGHT AFTER THE COMMA--------->\n*                                 POSITION VALUE NOT SPECIFIED\n         CH    R1,=H'15'          LENGTH HAS MORE THAN 15 DIGITS......?\n         BH    EXOSYNER           YES, ERROR-------------------------->\n         SR    OPLEN,R1           OPERAND LENGTH AFTER LENGTH VALUE\n         BAL   R14,CONVEXB        CONVERT EXTRACT VALUE TO BINARY\n         LH    R14,NOEXTP         NO.OF EXTRACT PAIRS IN THE TABLE\n         SLL   R14,2              * 4 = OFFSET OF NEXT AVAILABLE ENTRY\n         LH    R0,EXTBL(R14)      LOAD POSITION VALUE\n         BCTR  R0,0               POSITION - 1\n         AR    R0,R1              + FIELD LENGTH\n         CH    R0,TBLIN+82        IS FIELD WITHIN LOGICAL RECORD......?\n         BH    EXFRNGE            NO, EXTRQCT FIELD RANGE ERROR------->\n         STH   R1,EXTBL+2(R14)    STORE LENGTH OF EXTRACT FLD IN TBL\n         AH    R1,TBLELEN         TOTAL LENGTH OF A TABLE ELEMENT\n         STH   R1,TBLELEN         UPDATE\n         LH    R14,NOEXTP         NUMBER OF EXTRACT PAIRS\n         LA    R14,1(,R14)        + 1\n         STH   R14,NOEXTP         UPDATE NO.OF EXTRACT PAIRS PROCESSED\n         SPACE\n* CHECK IF NEXT EXTRACT FIELD IS SPECIFIED\n         LA    OPADDR,1(,R15)     ADDRESS OF CHARACTER AFTER )\n         SH    OPLEN,=H'1'        LENGTH OF OPERAND AFTER )\n         BNP   KWPROCEX           END OF EXTRACT STMT OPERAND--------->\n         CLI   0(OPADDR),C','     IS COMMA SPEC AFTER ) ..............?\n         BNE   EXOSYNER           NO, SYNTAX ERROR ------------------->\n         LA    OPADDR,1(,OPADDR)  ADDRESS OF CHARACTER AFTER COMMA\n         SH    OPLEN,=H'1'        LENGTH OF OPERAND AFTER COMMA\n         BNP   EXOSYNER           CONTINUATION INDICATED, NOT SPEC---->\n         B     KWEXTLP            CHECK IF LEFT PARENTHESIS----------->\n         SPACE\nTRTNUME  TRT   0(1,OPADDR),TRT\n         SPACE\nEXOSYNER DS    0H                 EXTRACT OPERAND SYNTAX ERROR\n         BAL   R14,PRNTSIRU       PRINT SYSIN RECORD AND UNDERLINE---->\n         MVC   MSGREC1+1(L'SYNTERM),SYNTERM  MOVE MSG TEXT INTO LNE\n         B     SYSINERR\n         SPACE\nPOSLEN0  DS    0H                 POSITION/LENGTH = 0 SPECIFIED\n         BAL   R14,PRNTSIRU       PRINT SYSIN RECORD AND UNDERLINE---->\n         MVC   MSGREC1+1(L'POSLEN0M),POSLEN0M  MOVE MSG TEXT INTO LNE\n         B     SYSINERR\n         SPACE\nEXFRNGE  DS    0H                 EXTRACT FIELD RANGE ERROR\n         BAL   R14,PRNTSIRU       PRINT SYSIN RECORD AND UNDERLINE---->\n         MVC   MSGREC1+1(L'EXFRNGEM),EXFRNGEM  MOVE MSG TEXT INTO LNE\n         B     SYSINERR\n         SPACE\nEXTBLMAX DS    0H                 EXTRACT FIELDS TABLE IS FULL\n         BAL   R14,PRNTSIRU       PRINT SYSIN RECORD AND UNDERLINE---->\n         MVC   MSGREC1+1(L'EXTBLFM),EXTBLFM  MOVE MSG TEXT INTO LNE\n         B     SYSINERR\n         SPACE\n* PRINT SYSIN RECORD AND UNDERLINE ASTERISKS\nPRNTSIRU SUBENT\n         BAL   R14,PRINTSIR       PRINT SYSIN RECORD      ------------>\n         MVI   R80,C' '           BLANK INPUT RECORD\n         MVC   R80+1(L'R80-1),R80\n         MVI   0(OPADDR),C'*'     UNDERLINE ERROR AREA WITH ASTERISKS\n         EX    OPLEN,MVCASTR\n         BAL   R14,PRINTSIR       PRINT UNDERLINE LINE    ------------>\n         SUBRET PRNTSIRU\n         SPACE\nMVCASTR  MVC   1(1,OPADDR),0(OPADDR)  UNDERLINE ASTERISKS\n         SPACE\n*---------------------------------------------------------------------*\n*  CONVERT EXTRACT FIELD POSITION/LENGTH TO BINARY                    *\n*  INPUT:  OPADDR - VALUE ADDRESS                                     *\n*          R1     - LENGTH OF THE VALUE                               *\n*  OUTPUT: R1 - VALUE IN BINARY                                       *\n*---------------------------------------------------------------------*\n         SPACE\nCONVEXB  DS    0H\n         BCTR  R1,0               VALUE STRING LENGTH - 1\n         EX    R1,PACKDECV        PACK DECIMAL VALUE\n         CVB   R1,D               CONVERT IT TO BINARY\n         LTR   R1,R1              IS SPECIFIED POSITION/LENGTH = 0 ...?\n         BZ    POSLEN0            YES, PRINT ERROR MESSAGE------------>\n         BR    R14                RETURN------------------------------>\nPACKDECV PACK  D,0(1,OPADDR)      PACK DECIMAL VALUE\n         SPACE\n*---------------------------------------------------------------------*\n*  SEARCH FOR SPECIFIED KEYWORD IN THE TABLE OF KEYWORDS              *\n*---------------------------------------------------------------------*\n         SPACE\nSRCHKWD  SUBENT\n         LA    R14,STMTKWT        STMT KEYWORDS TABLE ADDRESS\n         USING KWTE,R14           KEYWORD ENTRY FORMAT ADDRESSABILITY\n         XR    R15,R15\nSTMTSKWL IC    R15,KWLEN          KEYWORD LENGTH\n         LTR   R15,R15            KEYWORD LENGTH = 0 (UNKNOWN KEYW)...?\n         BZ    STMTSKWR           YES, RETURN\n         CR    R15,KWLENR         KEWORDS LENGTHS ARE EQUAL ..........?\n         BNE   STMTSKWN           NO, CHECK NEXT            ---------->\n         BCTR  R15,0              KEYWORD LENGTH - 1\n         EX    R15,STMTKCLC       COMPARE KEYWORDS          ..........?\n         LA    R15,1(0,R15)       KEYWORD LENGTH\n         BNE   STMTSKWN           NON EQUAL, CHECK NEXT     ---------->\n         IC    R15,KWCODE         KEWORD FOUND IN THE TABLE\nSTMTSKWR SUBRET SRCHKWD           RETURN                    ---------->\nSTMTSKWN LA    R14,3(R15,R14)     NEXT KEYWORD ENTRY ADDRESS\n         B     STMTSKWL           CHECK NEXT KEYWORD FROM THE TABLE--->\n         SPACE\nSTMTKCLC CLC   0(1,KWADDR),KWORD  COMPARE KEYWORDS\n         DROP  R14\nSTMTKWT  DS    0CL1               STATEMENT KEYWORDS TABLE\n         DC    AL1(4),AL1(4),AL1(0),C'NAME'\n         DC    AL1(6),AL1(8),AL1(0),C'KEYLEN'\n         DC    AL1(7),AL1(12),AL1(0),C'COMPARE'\n         DC    AL1(7),AL1(16),AL1(0),C'EXTRACT'\n         DC    AL1(0)             LAST DUMMY ENTRY\n         SPACE\n*---------------------------------------------------------------------*\n*  EXTRACT STMT KEYWORD AND OPERAND FROM SYSIN CONTROL RECORD         *\n*---------------------------------------------------------------------*\n         SPACE\nEXTKWRD  SUBENT\n         LA    KWADDR,R80         SYSIN RECORD ADDRESS\n         LR    OPADDR,KWADDR\n         XR    KWLENR,KWLENR      = 0\n         XR    OPLEN,OPLEN        = 0\n         LA    R2,72              FIRST 72 BYTES CAN BE USED ONLY\nEXTKWRD1 CLI   0(KWADDR),C' '     START OF KEYWORD....................?\n         BNE   EXTKWRDF           YES, NONBLANK CHARACTER------------->\n         LA    KWADDR,1(,KWADDR)  NEXT CHARACTER ADDRESS\n         BCT   R2,EXTKWRD1        CHECK NEXT CHARACTER---------------->\n         B     KWINVLD            BLANK SYSIN RECORD, ERROR MESSAGE--->\nEXTKWRDF LR    OPADDR,KWADDR      ADDRESS OF FIRST CHAR OF KEYWORD\nEXTKWRD2 CLI   0(OPADDR),C' '     END OF STMT KEYWORD.................?\n         BE    EXTKWRDO           YES, SEARCH FOR OPERAND------------->\n         LA    KWLENR,1(,KWLENR)  LENGTH OF KEYWORD + 1\n         LA    OPADDR,1(,OPADDR)  NEXT CHARACTER ADDRESS\n         BCT   R2,EXTKWRD2        CHECK NEXT CHARACTER---------------->\n         B     EXTKWRDR           COL 73, NO OPERAND SPEC, RETURN----->\nEXTKWRDO CLI   0(OPADDR),C' '     START OF OPERAND....................?\n         BNE   EXTKWOF            YES, NONBLANK CHARACTER------------->\n         LA    OPADDR,1(,OPADDR)  NEXT CHARACTER ADDRESS\n         BCT   R2,EXTKWRDO        CHECK NEXT CHARACTER---------------->\n         B     EXTKWRDR           COL 73, NO OPERAND SPEC, RETURN----->\nEXTKWOF  LR    R1,OPADDR          ADDRESS OF FIRST CHAR OF OPERAND\nEXTKWOF1 CLI   0(R1),C' '         END OF OPERAND......................?\n         BE    EXTKWRDR           YES, RETURN FROM SUBROUTINE--------->\n         LA    OPLEN,1(,OPLEN)    LENGTH OF OPERAND + 1\n         LA    R1,1(,R1)          NEXT CHARACTER ADDRESS\n         BCT   R2,EXTKWOF1        CHECK NEXT CHARACTER---------------->\nEXTKWRDR SUBRET EXTKWRD           RETURN FROM SUBROUTINE\n         SPACE\n* SYSIN END-OF-FILE PROCESSING\nEOFSIN   DS    0H                 SYSIN END-OF-FILE\n         OC    SINRCNT,SINRCNT    WAS THERE ANY RECORDS IN SYSIN......?\n         BZ    SINEMPTY           NO, EMPTY SYSIN FILE---------------->\n         TM    TBLDEFLG,SYSINERF  ANY ERROR IN SYSIN STMT.............?\n         BO    TBLDFPER           YES, RETURN WITH ERROR CC----------->\n         TM    TBLDEFLG,COMPSPEC+KEYLSPEC EITHER COMPARE OR KEYLEN REQ?\n         BZ    TBLNDEF            NEITHER SPECIFIED, ERROR MSG-------->\n* \"EXTRACT\" IS REQUIRED FOR \"V\" OR \"U\" TBLIN RECFM\n         TM    FLAGS,RECFMF       FIXED FORMAT TBLIN RECORDS..........?\n         BO    TBLDFPFR           YES, TABLE IS CORRECTLY DEFINED----->\n         OC    NOEXTP,NOEXTP      WAS \"EXTRACT\" SPECIFIED.............?\n         BNZ   TBLDFPR0           YES, TABLE IS CORRECTLY DEFINED----->\n* \"EXTRACT\" NOT SPECIFIED FOR \"V\" OR \"U\" RECFM, ERROR\n         MVC   MSGREC1(L'EXTREQM),EXTREQM  MOVE MSG TEXT INTO LNE\nEOFSINER BAL   R14,PRNTMSG        PRINT MESSAGE\nTBLDFPER LA    R15,16             ERROR RETURN CODE\n         B     TBLDFPR            RETURN------------------------------>\n* SYSIN FILE IS EMPTY MESSAGE\nSINEMPTY MVC   MSGREC1(L'SINEMPM),SINEMPM  MOVE MSG TEXT INTO LNE\n         B     EOFSINER           PRINT ERROR MSG AND SET ERROR RC---->\n* TABLE NOT DEFINED PROPERLY (BOTH COMPARE AND KEYLEN NOT SPEC)\nTBLNDEF  MVC   MSGREC1(L'TBLNDEFM),TBLNDEFM  MOVE MSG TEXT INTO LNE\n         B     EOFSINER           PRINT ERROR MSG AND SET ERROR RC---->\n* KEYLEN > TBLELEN ERROR MESSAGE\nKEYLENER MVC   MSGREC1(L'KEYLENEM),KEYLENEM  MOVE MSG TEXT INTO LNE\n         B     EOFSINER           PRINT ERROR MSG AND SET ERROR RC---->\n* FIXED LENGTH RECORDS IN TBLIN  FILE\nTBLDFPFR OC    NOEXTP,NOEXTP      WAS \"EXTRACT\" SPECIFIED.............?\n         BNZ   TBLDFPR0           YES, TABLE IS CORRECTLY DEFINED----->\n         MVC   NOEXTP,=H'1'       NO, DEFAULT TO FULL RECORD EXTRACT\n         MVC   EXTBL(2),=H'1'     DEFAULT POSITION\n         MVC   EXTBL+2(2),TBLIN+82  DEFAULT FIELD LENGTH = LRECL\n         MVC   TBLELEN,TBLIN+82   LENGTH OF A TABLE ELEMENT = LRECL\nTBLDFPR0 DS    0H               CHECK IF KEYLEN <= TABLE ELEMENT LENGTH\n         TM    TBLDEFLG,KEYLSPEC  KEYLEN SPECIFIED....................?\n         BNO   TBLDFPRZ           NO, BYPASS CHECK-------------------->\n         CLC   KEYLEN,TBLELEN                        .................?\n         BH    KEYLENER           ERROR, KEYLEN > TBLELEN------------->\nTBLDFPRZ SR    R15,R15            NORMAL RETURN FROM SYSIN PROC,RC=0\nTBLDFPR  SUBRET TBLDEFP           RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*  CREATE THE TABLE:                                                  *\n*       - READ TBLIN RECORD                                           *\n*       - EXTRACT REQUESTED FIELDS                                    *\n*       - WRITE IT OUT AS AN ASSEMBLER CONSTANT                       *\n*---------------------------------------------------------------------*\n         SPACE\nIRECL    EQU   R4                 INPUT RECORD LENGTH\nIRECADDR EQU   R5                 INPUT RECORD ADDRESS\n         SPACE\nTBLPROC  SUBENT\nGETBLIN0 BAL   R14,GETBLIN        GET TBLIN RECORD\n         BAL   R14,EXTBLIN        EXTRACT REQUESTED FIELDS\n         LTR   R15,R15            NO ERROR IN EXTRACT.................?\n         BNZ   TBLPROCR           ERROR, EXTRACT NOT WITHIN LRECL----->\n         BAL   R14,TBLEOUT        WRITE OUT TABLE ELEMENT\n*        CHECK IF TBLIN IS SORTED CORRECTLY\n         TM    TBLDEFLG,KEYLSPEC  KEYLEN HAS BEEN SPECIFIED...........?\n         BNO   GETBLIN0           NO, GET NEXT INPUT RECORD----------->\n         CLC   IRECNT,=F'1'       IS IT THE FIRST RECORD OF TBLIN.....?\n         BE    GETBLINE           YES, DO NOT CHECK THE SEQUENCE------>\n         LH    R1,KEYLEN          NOT FIRST RECORD, SEQUENCE CHECK\n         BCTR  R1,0               KEYLEN - 1\n         EX    R1,CLCKEYS         COMPARE CURRENT AND PREVIOUS KEY....?\n         BNH   SEQERROR           NO, TBLIN SEQUENCE ERROR------------>\nGETBLINE MVC   PREVKEY,CURRKEY    RIGHT SEQUENCE, PREVIOUS=CURRENT KEY\n         B     GETBLIN0           GET NEXT INPUT RECORD\nSEQERROR TM    FLAGS,SEQERRF      SEQUENCE ERROR MSG ALREADY PRINTED..?\n         BO    GETBLIN0           YES, CONTINUE (NORMAL RETURN CODE)\n         OI    FLAGS,SEQERRF      FLAG SEQUENCE ERROR\n         L     R0,IRECNT          INPUT RECORD COUNT\n         CVD   R0,D               CONVERT TO DECIMAL\n         ED    SEQRCNT,D          EDIT INTO MESSAGE LINE\n*        PRINT SEQUENCE ERROR MESSAGE\n         MVC   MSGREC1(SEQERRLE-SEQERRL),SEQERRL  RECORD COUNT MSG\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         B     GETBLINE\nTBLPROCR SUBRET TBLPROC           RETURN\n         SPACE\nCLCKEYS  CLC   CURRKEY(1),PREVKEY COMPARE KEYS TARGET\nSEQERRL  DC    C'0***W A R N I N G*** TBLIN  RECORD OUT OF SEQENCE OR D+\n               UPLICATE KEY, REC.NO='\nSEQRCNT  DC    X'40202020202020202020202020202120'\nSEQERRLE EQU   *\n         SPACE\n* TBLIN END-OF-FILE\nEOFTBLI  DS    0H\n         OC    IRECNT,IRECNT      WERE THERE ANY RECORDS IN TBLIN.....?\n         BZ    TBLIEMP            NO, EMPTY TBLIN FILE---------------->\n         L     R0,IRECNT          INPUT RECORD COUNT\n         CVD   R0,D               CONVERT TO DECIMAL\n         ED    IRECNTM,D          EDIT INTO MESSAGE LINE\n*        PRINT RECORD COUNT MSG\n         MVC   MSGREC1(TRLINE1E-TRLINE1),TRLINE1  RECORD COUNT MSG\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         L     R0,TBLSIZE         TABLE SIZE IN BYTES\n         CVD   R0,D               CONVERT TO DECIMAL\n         ED    TBLSIZM,D          EDIT INTO MESSAGE LINE\n*        PRINT TABLE SIZE MSG\n         MVC   MSGREC1(TRLINE2E-TRLINE2),TRLINE2  TABLE SIZE MSG\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         SR    R15,R15            NORMAL RETURN FROM TBLPROC (RC=0)\n         B     TBLPROCR           RETURN FROM TBLPROC----------------->\n         SPACE\nTBLIEMP  MVC   MSGREC1(L'TBLIEMPM),TBLIEMPM  EMPTY TBLIN MESSAGE\n         BAL   R14,PRNTMSG        PRINT ERROR MESSAGE\n         LA    R15,16             ERROR RETURN CODE\n         B     TBLPROCR           RETURN FROM TBLPROC----------------->\n         SPACE\nTRLINE1  DC    C'0NUMBER OF TBLIN RECORDS/TABLE ELEMENTS :'\nIRECNTM  DC    X'40202020202020202020202020202120'\nTRLINE1E EQU   *\nTRLINE2  DC    C'0TABLE SIZE IS'\nTBLSIZM  DC    X'40202020202020202020202020202120'\n         DC    C' BYTES  PLUS  LENGTH OF THE TABLE HEADER'\nTRLINE2E EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\n* GET TBLIN RECORD SUBROUTINE\nGETBLIN  SUBENT\n         GET   TBLIN              GET LOCATE MODE\n         LR    IRECADDR,R1        RECORD ADDRESS\n         L     R1,IRECNT          TBLIN RECORD COUNT\n         LA    R1,1(,R1)          + 1\n         ST    R1,IRECNT          UPDATE RECORD COUNT\n         TM    FLAGS,RECFMV       VARIABLE LENGTH RECORDS.............?\n         BO    GETBLINV           YES, TAKE RECL FROM RDW------------->\n         LH    IRECL,TBLIN+82     NO, F OR U, RECL FROM DCBLRECL\n         B     GETBLINR           RETURN                 ------------->\nGETBLINV LH    IRECL,0(IRECADDR)  RECFMV, LOAD RECL FROM RDW\nGETBLINR SUBRET GETBLIN           RETURN                 ------------->\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\n* EXTRACT FIELDS OF TABLE ELEMENT FROM TBLIN RECORD\nEXTOCA   EQU   R6                 OUTPUT AVAILABLE CHARACTER ADDRESS\nEXTOLEN  EQU   R7                 EXTRACTED OUTPUT LENGTH\nKEYLREG  EQU   R8                 KEY LENGTH REG TO EXTRACT KEY\nKEYOCA   EQU   R14                KEY OUTPUT CHARACTER ADDRESS\nEXTBLIN  SUBENT\n         XR    EXTOLEN,EXTOLEN    LENGTH OF EXTRACTED OUTPUT\n         LA    EXTOCA,EXTWRK      ADDRESS OF WORK FIELD FOR EXTRACT\n         LH    R3,NOEXTP          NO.OF EXTRACT FIELDS\n         LA    R2,EXTBL           EXTRACT PAIRS TABLE ADDRESS\n         USING EXTFLDD,R2         ADDRESSABILITY OF EXTRACT FIELD DESC\n         LH    KEYLREG,KEYLEN     LENGTH OF KEY (IF SPECIFIED)\n         LA    KEYOCA,CURRKEY     CURRENT KEY ADDRESS\nEXTBLP   DS    0H                 EXTRACT FIELDS PROCESSING LOOP\n*        CHECK IF FIELD IS WITHIN LOGICAL RECORD\n         LH    R1,EXTFLDP         FIELD POSITION WITHIN RECORD\n         BCTR  R1,0               - 1\n         LR    R0,R1\n         AH    R0,EXTFLDL         + FIELD LENGTH\n         CR    R0,IRECL           IS IT > LRECL.......................?\n         BH    EXTBLRE            EXTRACT OUT OF LRECL RANGE ERROR---->\n         LA    R1,0(R1,IRECADDR)  ADDRESS OF FIRST CHAR OF EXTRACT FLD\n         LH    R15,EXTFLDL        EXTRACT FIELD LENGTH\n*        MOVE TABLE ELEMENT KEY (IF SPECIFIED) INTO CURRKEY FIELD\nEXTBLFML TM    TBLDEFLG,KEYLSPEC  WAS KEYLEN SPECIFIED................?\n         BNO   EXTBLFM1           NO, BYPASS KEY EXTRACTION----------->\n         LTR   KEYLREG,KEYLREG    WAS THE KEY ALREADY EXTRACTED.......?\n         BNP   EXTBLFM1           YES,BYPASS KEY EXTRACTION CODE------>\n         MVC   0(1,KEYOCA),0(R1)  MOVE CHARACTER INTO CURRKEY AREA\n         LA    KEYOCA,1(,KEYOCA)  NEXT AVAILABLE BYTE ADDRESS\n         BCTR  KEYLREG,0          LENGTH OF EXTRACTED KEY - 1\n*        MOVE EXTRACT FIELD INTO WORK AREA,DOUBLE QUOTES AND AMPERSANDS\nEXTBLFM1 MVC   0(1,EXTOCA),0(R1)  MOVE CHARACTER INTO OUTPUT WRK AREA\n         LA    EXTOCA,1(,EXTOCA)  NEXT AVAILABLE BYTE ADDRESS\n         LA    EXTOLEN,1(,EXTOLEN) LENGTH OF OUTPUT STRING + 1\n         CLI   0(R1),C''''        IS IT A QUOTE.......................?\n         BE    EXTBLFMD           YES, MAKE IT DOUBLE IN WORK AREA---->\n         CLI   0(R1),C'&&'        IS IT AN AMPERSAND..................?\n         BNE   EXTBLFME           NO, END OF LOOP LABEL--------------->\nEXTBLFMD MVC   0(1,EXTOCA),0(R1)  MOVE SECOND QUOTE OR AMPERSAND\n         LA    EXTOCA,1(,EXTOCA)  NEXT AVAILABLE BYTE ADDRESS\n         LA    EXTOLEN,1(,EXTOLEN) LENGTH OF OUTPUT STRING + 1\nEXTBLFME LA    R1,1(,R1)          NEXT CHAR OF EXTRACT FIELD ADDR\n         BCT   R15,EXTBLFML       LENGTH OF FIELD - 1 AND REPEAT OR EX\n         SPACE\n         LA    R2,4(,R2)          NEXT EXTRACT FIELD DESCRIPTION ADDR\n         BCT   R3,EXTBLP          EXTRACT NEXT FIELD IF THERE IS ANY\n         SR    R15,R15            NORMAL RETURN CODE\n         L     R0,TBLSIZE         TABLE SIZE IN BYTES\n         AH    R0,TBLELEN         + LENGTH OF A TABLE ELEMENT\n         ST    R0,TBLSIZE         UPDATE TABLE SIZE\nEXTBLINR SUBRET EXTBLIN           RETURN\n         SPACE\n* EXTRACT OUT OF LRECL RANGE ERROR\nEXTBLRE  DS    0H                 EXTRACT OUT OF LRECL RANGE ERROR\n         L     R0,IRECNT          INPUT RECORD COUNT\n         CVD   R0,D               CONVERT TO DECIMAL\n         ED    IRECNTE,D+4        EDIT INTO MESSAGE LINE\n         CVD   IRECL,D            CONVERT LRECL TO DECIMAL\n         ED    LRECLE,D+5         EDIT INTO MESSAGE LINE\n*        PRINT ERROR MSG\n         MVC   MSGREC1(EXTERRLE-EXTERRL),EXTERRL  ERROR MSG\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         LA    R15,16             ERROR RETURN CODE\n         B     EXTBLINR           RETURN------------------------------>\n         SPACE\nEXTERRL  DC    C'0EXTRACT FIELD NOT WITHIN LRECL, TBLIN REC.NO.'\nIRECNTE  DC    X'4020202020202120'\n         DC    C'  LRECL='\nLRECLE   DC    X'402020202120'\nEXTERRLE EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n         SPACE\n* WRITE OUT TABLE ELEMENT (ASSEMBLER DC CONSTANT)\nDCSEGL   EQU   56                 NO.OF CHARACTERS IN COLS 16-71\nTBLEOUT  SUBENT\n         BAL   R14,BLANKR80       BLANK R80 RECORD\n         MVC   R80+9(6),=C'DC  C'''  DC OPCODE IN FIRST RECORD\n         LA    R2,DCSEGL          NO.OF CHARS AVAILABLE IN COLS 16-72\n         LA    EXTOCA,EXTWRK      ADDRESS OF TABLE ELEMENT CHAR.STRNG\nTBLEOUTL CR    EXTOLEN,R2         LESS THEN 72-15=57 CHARS LEFT.......?\n         BL    TBLEOUTE           YES, LAST SEGMENT OF DC CONSTANT---->\n         MVC   R80+15(DCSEGL),0(EXTOCA) MOVE DC SEGMENT INTO R80\n         MVI   R80+71,C'+'        CONTINUATION MARK\n         PUT   TBLOUT,R80         PUT OUT TBLOUT RECORD\n         BAL   R14,BLANKR80       BLANK R80 RECORD\n         LA    EXTOCA,DCSEGL(,EXTOCA)  ADDRESS OF NEXT SEGMENT\n         SR    EXTOLEN,R2         LENGTH OF LEFT CHAR. STRING\n         B     TBLEOUTL           CONTINUE THE CYCLE------------------>\nTBLEOUTE LA    R1,R80+15(EXTOLEN) ADDRESS LAST DC SEGMENT ENDING QUOTE\n         SH    EXTOLEN,=H'1'      ARE THERE ANY CHARS LEFT............?\n         BM    TBLEOUTQ           NO, JUST ENDING QUOTE IN COL 16 REQ->\n         EX    EXTOLEN,MVCLDCS    MOVE LAST DC SEGMENT INTO R80\nTBLEOUTQ MVI   0(R1),C''''        MOVE ENDING QUOTE\n         PUT   TBLOUT,R80         PUT OUT TBLOUT RECORD (LAST DC SEG)\n         BAL   R14,BLANKR80       BLANK R80 RECORD\n         SUBRET TBLEOUT           RETURN\nMVCLDCS  MVC   R80+15(1),0(EXTOCA) MOVE LAST DC SEG.INTO R80\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT MSG LINE                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nPRNTMSG  SUBENT\n         CLI   MSGREC1+1,C'*'     ERROR MSG.......TEST ONLY...........?\n         BNE   PRNTMSGE           YES-------------TEST ONLY----------->\n*        BAL   R14,SNAPRNT        PRINT DATA******TEST ONLY************\nPRNTMSGE CLI   MSGREC1,X'40'      NO SPACING               ...........?\n         BE    PRNTMSG1           YES                      ----------->\n         CLI   MSGREC1,C'+'       IN THE SAME LINE         ...........?\n         BE    PRNTMSG0           YES                      ----------->\n         CLI   MSGREC1,C'0'       ONE BLANK LINE           ...........?\n         BE    PRNTMSG2           YES                      ----------->\n         CLI   MSGREC1,C'-'       TWO BLANK LINES          ...........?\n         BE    PRNTMSG3           YES                      ----------->\n         MVI   MSGREC1,C'-'       INVALID CONTROL CHAR SECIF., CHANGE\n         B     PRNTMSGE           CHECK AGAIN              ----------->\nPRNTMSG0 SR    R0,R0              IN THE SAME LINE PRINTING\n         B     PRNTMSGL           CHECK IF FITS INTO THE PAGE--------->\nPRNTMSG1 LA    R0,1               IN THE NEXT LINE PRINTING\n         B     PRNTMSGL           CHECK IF FITS INTO THE PAGE--------->\nPRNTMSG2 LA    R0,2               ONE BLANK LINE BEFORE\n         B     PRNTMSGL           CHECK IF FITS INTO THE PAGE--------->\nPRNTMSG3 LA    R0,3               TWO BLANK LINES BEFORE\nPRNTMSGL A     R0,LINECNT         CHECK IF FITS INTO THE PAGE\n         C     R0,LINECNTL        LINE COUNT LIMIT EXCEEDED...........?\n         BH    PRNTMSGP           YES, NEW PAGE            ----------->\n         ST    R0,LINECNT         NO, NEW LINE COUNT\n         PUT   PRINT,MSGREC1      NO, PRINT MESSAGE\n         MVI   MSGREC1,X'40'      CLEAR MSGREC1\n         MVC   MSGREC1+1(L'MSGREC1-1),MSGREC1\n         SUBRET PRNTMSG\nPRNTMSGP BAL   R14,NEWPAGE        NEW PAGE\n         MVI   MSGREC1,X'40'      NO SPACING REQUIRED AFTER NEW PAGE\n         B     PRNTMSGE           PRINT MESSAGE AFTER NEW PAGE\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT NEW PAGE HEADER                                              *\n*---------------------------------------------------------------------*\n         SPACE\nNEWPAGE  SUBENT\n         LH    R1,PAGENO          CURRENT PAGE NUMBER\n         CVD   R1,D               CONVERT TO DECIMAL\n         LA    R1,1(0,R1)         NEXT PAGE NUMBER\n         STH   R1,PAGENO\n         MVC   HPAGENO,=X'402020202120' EDIT MASK\n         ED    HPAGENO,D+5        EDIT PAGE NUMBER\n         TIME\n         ST    R1,FULLW           DATE IN 00YYDDDF FORMAT\n         MVC   HDATE,=X'4020204B202020'\n         ED    HDATE,FULLW+1      EDIT DATE INTO HEADER LINE\n         PUT   PRINT,HEADLNE1\n         LA    R0,2               LINE COUNT = 2\n         ST    R0,LINECNT\n         MVI   MSGREC,X'40'\n         MVC   MSGREC+1(L'MSGREC-1),MSGREC\n         PUT   PRINT,MSGREC       ONE BLANK LINE\n         SUBRET NEWPAGE\n         SPACE\nHEADLNE1 DS    0CL133             HEADLINE NUMBER 1\n         DC    CL110'1JJTBGEN  - LIST OF SYSIN CONTROL STATEMENTS'\nHDATE    DC    CL7' '\n         DC    C'      PAGE'\nHPAGENO  DS    CL6                PAGE NUMBER\n         SPACE\n*---------------------------------------------------------------------*\n*  PRINT 1 BLANK LINE                                                 *\n*---------------------------------------------------------------------*\n         SPACE\nBLANKLNE SUBENT\n         BAL   R14,LNECNTP1       LINE COUNT + 1\n         CLC   LINECNT,LINECNTL   WILL FIT INTO THIS PAGE.............?\n         BH    BLNKLNPG           NO,  PRINT NEW PAGE HEADER---------->\n         MVI   MSGREC,X'40'\n         MVC   MSGREC+1(L'MSGREC-1),MSGREC\n         PUT   PRINT,MSGREC\nBLNKLRET SUBRET BLANKLNE          RETURN TO CALLER\nBLNKLNPG BAL   R14,NEWPAGE        NEW PAGE\n         B     BLNKLRET           RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*  LINE COUNT + 1                                                     *\n*---------------------------------------------------------------------*\n         SPACE\nLNECNTP1 DS    0H                 LINE COUNT + 1\n         LA    R0,1               LINE COUNT + 1\n         A     R0,LINECNT\n         ST    R0,LINECNT\n         BR    R14                RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*  INITIALISATION OF PROGRAM ( SOME CONSTANTS )                       *\n*---------------------------------------------------------------------*\n         SPACE\nINIT     DS    0H\n         MVC   LINECNT,=F'64'     FORCE NEW PAGE AT THE BEGINING\n         MVC   LINECNTL,=F'64'    DEFAULT PAGE LINE COUNT\n         MVC   PAGENO,=H'1'       FIRST PAGE NUMBER\n         MVI   FLAGS,X'00'        INIT OF FLAGS\n         SR    R0,R0\n         ST    R0,IRECNT          COUNTERS TO ZERO\n         ST    R0,TBLSIZE         COUNTERS TO ZERO\n         STH   R0,TBLELEN         COUNTERS TO ZERO\n         SPACE\n         EXTRACT TIOTA,FIELDS=TIOT EXTRACT TO GET JOBNAME\n         L     R1,TIOTA           TIOT ADDRESS\n         MVC   JOBNAME,0(R1)      SAVE JOB NAME\n         BR    R14                RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*     DCB EXIT FOR PRINT FILE ( SETS UP DEFAULT BLKSIZE )             *\n*---------------------------------------------------------------------*\n         SPACE\nPRTDCBEX DS    0H                 EXIT IF BLKSIZE NOT SPECIFIED        +\n                                  MSG DATA SET\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         LH    R2,DCBBLKSI        LOAD BLKSIZE\n         LTR   R2,R2              BLKSIZE=0 ..........................?\n         BNZR  R14                NO,RETURN <----------------\n         MVC   DCBBLKSI,DCBLRECL  BLKSIZE=LRECL========================\n         BR    R14                RETURN    <----------------\n         DROP  R1\n         SPACE\n*---------------------------------------------------------------------*\n*     DCB EXIT FOR TBLOUT FILE ( SETS UP DEFAULT BLKSIZE )            *\n*---------------------------------------------------------------------*\n         SPACE\nTBLDCBEX DS    0H                 EXIT IF BLKSIZE NOT SPECIFIED        +\n                                  TBLOUT DATA SET\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         LH    R2,DCBBLKSI        LOAD BLKSIZE\n         LTR   R2,R2              BLKSIZE=0 ..........................?\n         BNZR  R14                NO,RETURN <----------------\n         MVC   DCBBLKSI,=AL2(800) BLKSIZE=800  ========================\n         BR    R14                RETURN    <----------------\n         DROP  R1\n         SPACE\nCLOSE    DS    0H                 FINAL CLOSE OF FILES\n         CLOSE (PRINT,,SYSIN,,TBLOUT,,TBLIN)\n         BR    R14                RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n*  END OF PROCESSING MESSAGE                                          *\n*---------------------------------------------------------------------*\n         SPACE\nEOPMSG   SUBENT\n         MVC   MSGREC1(L'EOPMSGT),EOPMSGT MESSAGE TEXT INTO MESSAGE REC\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         SUBRET EOPMSG            RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*  END OF PROCESSING WITH ERROR MESSAGE                               *\n*---------------------------------------------------------------------*\n         SPACE\nEOPERM   SUBENT\n         MVC   MSGREC1(L'EOPERMS),EOPERMS MESSAGE TEXT INTO MESSAGE REC\n         BAL   R14,PRNTMSG        PRINT MESSAGE\n         SUBRET EOPERM            RETURN\n         SPACE\n*--------D C B S,  C O N S T A N T S,  D A T A,  M S G S--------------*\n         SPACE\n*  MESSAGE DATA SET\n         SPACE\nPRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,            +\n               LRECL=133,EXLST=PRTEXLST\n         SPACE\n*  TABLE DEFINITION INPUT FILE (CONTROL STMTS)\n         SPACE\nSYSIN    DCB   DSORG=PS,MACRF=(GM),DDNAME=SYSIN,                       +\n               RECFM=FB,LRECL=80,EODAD=EOFSIN\n         SPACE\n*  INPUT FILE (TABLE CONTENTS)\n         SPACE\nTBLIN    DCB   DSORG=PS,MACRF=(GL),DDNAME=TBLIN,EODAD=EOFTBLI\n         SPACE\n*  OUTPUT FILE\n         SPACE\nTBLOUT   DCB   DSORG=PS,MACRF=(PM),DDNAME=TBLOUT,RECFM=FB,LRECL=80,    +\n               EXLST=TBLEXLST\n         SPACE\nTBLEXLST DS    0F                 TBLOUT DCB EXLST\n         DC    X'85',AL3(TBLDCBEX) EXIT FOR BLKSIZE NOT SPECIFIED\n         SPACE\nPRTEXLST DS    0F                 PRINT DCB EXLST\n         DC    X'85',AL3(PRTDCBEX) EXIT FOR BLKSIZE NOT SPECIFIED\n         SPACE\nEOPMSGT  DC    C'-JJTBGEN      E N D    O F    P R O C E S S I N G'\nEOPERMS  DC    C'-JJTBGEN      T E R M I N A T E D    D U E    T O    P+\n                R E V I O U S    E R R O R'\nSINOPNEM DC    C'-JJTBGEN    SYSIN DCB COULD NOT BE OPENED. PROCESSING +\n               TERMINATED, RC = 16'\nOUTOPNEM DC    C'-JJTBGEN    TBLOUT DCB COULD NOT BE OPENED. PROCESSING+\n                TERMINATED, RC = 16'\nINOPNEM  DC    C'-JJTBGEN    TBLIN  DCB COULD NOT BE OPENED. PROCESSING+\n                TERMINATED, RC = 16'\nINVRFMM  DC    C'-JJTBGEN    TBLIN  HAS AN INVALID RECORD FORMAT SPECIF+\n               IED, PROCESSING TERMINATED, RC = 16'\nPRTOPNEM WTO   'JOBNAME , JJTBGEN   SYSPRINT DCB COULD NOT BE OPENED. P+\n               ROCESSING TERMINATED',MF=L\n         SPACE\nDUPSTMTM DC    C'***** E R R O R ***** DUPLICATE STATEMENT'\nOPERMISM DC    C'***** E R R O R ***** MISSING OPERAND IN THE ABOVE STA+\n               TEMENT'\nNAMELENM DC    C'***** E R R O R ***** CSECT/EXIT NAME LENGTH IS GREATE+\n               R THAN 8 CHARACTERS'\nCOMPKLMX DC    C'***** E R R O R ***** COMPARE AND KEYLEN ARE MUTUALLY +\n               EXCLUSIVE STMTS'\nINVKEYLM DC    C'***** E R R O R ***** SPECIFIED KEYLEN IS INVALID'\nINVSTMTM DC    C'***** E R R O R ***** UNRECOGNIZED STATEMENT SPECIFIED+\n               '\nSYNTERM  DC    C'***** E R R O R ***** EXTRACT STMT, SYNTAX ERROR'\nEXFRNGEM DC    C'***** E R R O R ***** EXTRACT FIELD NOT WITHIN TBLIN''+\n               S LRECL'\nPOSLEN0M DC    C'***** E R R O R ***** EXTRACT POSITION/LENGTH = ZERO I+\n               S NOT ALLOWED'\nEXTBLFM  DC    C'***** E R R O R ***** ONLY UP TO 200 EXTRACT FIELDS CA+\n               N BE SPECIFIED'\nEXTREQM  DC    C'0***** E R R O R ***** EXTRACT STATEMENT IS REQUIRED I+\n               F TBLIN   RECFM = V OR U'\nTBLNDEFM DC    C'0***** E R R O R ***** EITHER KEYLEN OR COMPARE STMT I+\n               S REQUIRED TO DEFINE THE TABLE'\nSINEMPM  DC    C'0***** E R R O R ***** SYSIN CONTROL FILE IS EMPTY'\nTBLIEMPM DC    C'0***** E R R O R ***** TBLIN  FILE IS EMPTY'\nKEYLENEM DC    C'0***** E R R O R ***** KEYLEN IS GREATER THAN TABLE EL+\n               EMENT LENGTH'\n         SPACE\nDSAS     DC    A(DSAE-DSA)        DSA SIZE\nTIOTA    DS    A                  ADDRESS OF TIOT\nMAXEXTP  DC    H'200'             MAX.NO.OF EXTRACT PAIRS THAT CAN BE\n*                                 SPECIFIED IN EXTRACT STMTS\n         LTORG\n         SPACE\n*  DYNAMIC STORAGE AREA\nDSA      DSECT\nSA       DS    18F                SAVE AREA\nR80      DS    CL80               80 BYTES OUTPUT RECORD\nCSECTNM  DS    CL8                TABLE CSECT NAME\nSINRCNT  DS    F                  SYSIN FILE RECORD COUNT\nLINECNT  DS    F                  PAGE LINE COUNT\nLINECNTL DS    F                  PAGE LINE COUNT LIMIT\nIRECNT   DS    F                  INPUT RECORD COUNT\nTBLSIZE  DS    F                  SIZE OF THE TABLE IN BYTES\nPAGENO   DS    H                  SYSPRINT PAGE NUMBER\nLRECL    DS    H                  LRECL SPECIFIED FOR SYSUT1\nTBLELEN  DS    H                  LENGTH OF THE TABLE ELEMENT\nKEYLEN   DS    H                  LENGTH OF THE KEY IF SPECIFIED\nTRT      DS    CL256              TRANSLATE AND TEST TABLE\nJOBNAME  DS    CL8                JOB NAME\nMSGREC   DS    CL133              MESSAGE RECORD\nMSGREC1  DS    CL133              MESSAGE RECORD\n         SPACE\nFLAGS    DC    X'00'              FLAGS\nRECFMF   EQU   BIT0               SYSUT1 RECFM=F SPECIFIED\nRECFMV   EQU   BIT1               SYSUT1 RECFM=V SPECIFIED\nRECFMU   EQU   BIT2               SYSUT1 RECFM=U SPECIFIED\nSEQERRF  EQU   BIT7               TBLIN SEQUENCE ERROR FLAG\n         SPACE\nTBLDEFLG DC    X'00'              TABLE DEFINITION FLAGS\nNAMESPEC EQU   BIT0               CSECT NAME ALREADY SPECIFIED FLAG\nCOMPSPEC EQU   BIT1               COMPARE EXIT ALREADY SPECIFIED FLAG\nKEYLSPEC EQU   BIT2               KEYLEN ALREADY SPECIFIED FLAG\nSYSINERF EQU   BIT7               ERROR IN SYSIN STMT\n         SPACE\nZONED    DS    ZL15               ZONED WORK FIELD\nWRK15    EQU   ZONED\nD        DS    D                  WORK DOUBLEWORD\nFULLW    DS    F                  WORK FULLWORD\nNOEXTP   DS    H                  NO.OF EXTRACT PAIRS PSECIFIED\nEXTBL    DS    200F               EXTRACT TABLE (TWO HALFWORDS:\nCURRKEY  DS    CL256              CURRENT TABLE ELEMENT KEY\nPREVKEY  DS    CL256              PREVIOUS TABLE ELEMENT KEY\nEXTWRK   DS    32CL1024           EXTRACT WORK AREA (32K)\nDSAE     EQU   *                  DSA END\n         SPACE\n         DCBD  DSORG=PS\n         SPACE 2\n*  EXTRACT FIELD DESCRIPTION DSECT\nEXTFLDD  DSECT\nEXTFLDP  DS    H                  EXTRACT FIELD POSITION WITHIN LREC\nEXTFLDL  DS    H                  LENGTH OF EXTRACT FIELD\n         SPACE 2\n*  STMT KEYWORD TABLE ENTRY FORMAT\nKWTE     DSECT\nKWLEN    DS    XL1                KEYWORD LENGTH\nKWCODE   DS    XL1                KEYWORD CODE\nKWFLAGS  DS    XL1                KEYWORD FLAGS\n* FLAGS ARE NOT USED IN THIS PROGRAM\nKWORD    DS    CL30               KEYWORD ITSELF\n         END   JJTBGEN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KSDSINIT": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00T\\x00\\x85\\x11O\\x01\\x01$\\x9f\\x14Y\\x01\\xbf\\x00Y\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1985-04-24T00:00:00", "modifydate": "2001-09-06T14:59:54", "lines": 447, "newlines": 89, "modlines": 0, "user": "SYMP118"}, "text": "         TITLE 'KSDS FILE INITIALIZATION ROUTINE'\n* KSDS FILE INITIALIZATION ROUTINE'\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: KSDSINIT\n*\n* ATTRIBUTES : STANDARD\n*\n* FUNCTION = SEE BELOW\n*\n*     THIS ROUTINE INITIALYZES A NEWLY DEFINED VSAM KSDS FILE THROUGH\n*  THE FOLLOWING SEQUENCE OF OPERATIONS:\n*  .OPEN FOR OUTPUT SEQ PROCESSING\n*  .LOAD A DUMMY RECORD\n*  .CLOSE THE FILE\n*  .RE-OPEN THE FILE FOR DIRECT PROCESSING\n*  .DELETE DUMMY RECORD\n*  .CLOSE THE FILE\n*  AFTER THE RUN OF THIS PROGRAM VSAM KSDS FILE CAN BE OPENED FOR\n*  INPUT/OUTPUT PROCESSING BY AN APPLICATION PROGRAM.\n*  IF INPUT KSDS FILE WAS PREVIOUSLY LOADED WITH A DUMMY RECORD\n*  (ALL BLANKS RECORD) - SUCH A RECORD WILL ALSO BE DELETED.\n*\n*\n*\n*\n* RETURN CODES FROM THE PROGRAM:\n*     0 - NORMAL SUCCESSFUL COMPLETION\n*    16 - ERROR. CHECK MESSAGES IN SYSPRINT AND/OR SYSTEM LOG.\n*\n*\n*    THE FOLLOWING JCL PROCEDURE HAS BEEN CATALOGED AND MAY BE INVOKED\n*    TO RUN THIS PROGRAM:\n*\n*        //KSDSINIT PROC CAT='SYS2.ICFUCAT'\n*        //KSDSINIT EXEC PGM=KSDSINIT\n*        //STEPLIB    DD DSN=SYS1.UTIL.LINKLIB,DISP=SHR\n*        //STEPCAT    DD DSN=&CAT,DISP=SHR\n*        //KSDS       DD DSN=&KSDS,DISP=OLD\n*        //SYSPRINT   DD SYSOUT=*           MESSAGE FILE\n*\n*    \"KSDS\" FILE HAS TO BE PREVIOUSLY DEFINED IN \"CAT\" CATALOG USING\n*    IDCAMS.\n*\n* WRITTEN BY:\n*            JAN (JANEK) JAKUBEK\n*\n* CHANGE ACTIVITY:\n*        MARCH 27/89, JJ, ADDED A CHECK IF INPUT KSDS FILE IS EMPTY.\n*              FOR NON-EMPTY FILE AN ERROR MESSAGE WILL BE ISSUED\n*              AND PROGRAM WILL TERMINATE (A ONE RECORD IS ALLOWED\n*              IN ORDER TO BE ABLE TO CREATE AN EMPTY ALTERNATE\n*              INDEX).\n*\n         PRINT NOGEN\nKSDSINIT CSECT                    CSECT NAME\n         USING KSDSINIT,R15\n         SAVE  (14,12)            SAVE REGISTERS\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   R2,SAE             SAVE AREA ADDRESS\nSA       DS    18F                SAVE AREA\n         USING SA,R2\nSAE      ST    R13,SA+4           CHAIN\n         ST    R2,8(R13)          SAVE AREAS\n         LR    R13,R2             CURRENT SAVE AREA\n         DROP  R2\n         USING SA,R13             PROGRAM BASE REGISTER\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\nTCHR     EQU   R2                 HEX TRANSLATED CHARACTER REGISTER\nHEXLEN   EQU   R3                 CONVHEX INPUT FIELD LENGTH\nMSGADDR  EQU   R5                 ERROR MESSAGE ADDRESS\nRECBAR   EQU   R6                 DUMMY RECORD AREA ADDRESS\nLNKREG1  EQU   R9                 LINK REGISTER\nHEXOUTAR EQU   R14                CONVHEX OUTPUT FIELD ADDRESS\nHEXINAR  EQU   R15                CONVHEX INPUT FIELD ADDRESS\n         SPACE\n* OFFSETS OF VARIOUS FIELDS IN THE VSAM CONTROL BLOCKS\nAMBLQ    EQU   23                 QUALIFIER           (IN AMBL)\nAMBLKSDS EQU   X'04'              CLUSTER OPEND AS KSDS FLAG (AMBLQ)\nAMBLDTA  EQU   52                 POINTER TO DATA AMB (IN AMBL)\nAMBDSB   EQU   20                 ADDRESS OF THE AMDSB (IN AMB)\nAMDNLR   EQU   60                 NUMBER OF LOGICAL RECORDS (IN AMDSB)\n         SPACE\n         OPEN  (VSAMF)\n         LTR   R15,R15            OPEN OK.............................?\n         BNZ   OPENERR            NO, OPEN ERROR---------------------->\n*  CHECK IF IT IS A KSDS FILE\n         L     R2,ACBAMBL         AMB LIST ADDRESS\n         TM    AMBLQ(R2),AMBLKSDS IS IT A KSDS CLUSTER................?\n         BZ    NOTKSDS            NO, IT IS NOT A KSDS FILE----------->\n*  CHECK IF KSDS IS ALREADY LOADED\n         L     R2,AMBLDTA(,R2)    DATA COMPONENT AMB ADDRESS\n         L     R2,AMBDSB(,R2)     DATA COMPONENT AMDSB ADDRESS\n         L     R15,AMDNLR(R2)     NUMBER OF LOGICAL DATA RECORDS\n         CH    R15,=H'1'          MORE THAN ONE RECORD IN THE DATA SET?\n         BH    NOEMPTY            YES, A NON-EMPTY DATA SET----------->\n         SHOWCB ACB=VSAMF,AREA=DISPLAY,LENGTH=12,                      +\n               FIELDS=(LRECL,RKP,KEYLEN)\n         LTR   R15,R15            SHOWCB OK...........................?\n         BNZ   SHOWCBER           NO, SHOWCB ERROR-------------------->\n         L     R0,LRECL           RECORD LENGTH\n         GETMAIN R,LV=(0)         GET STORAGE FOR DUMMY RECORD\n         LR    RECBAR,R1          RECORD ADDRESS\n*  INIT DUMMY RECORD WITH BLANKS\n         LR    R0,R1              RECORD ADDRESS\n         L     R1,LRECL           RECORD LENGTH\n         SLR   R2,R2              ANY ADDRESS\n         IC    R3,=X'40'          PAD CHARACTER (BLANK)\n         SLL   R3,24              SHIFT IT TO BIT POSITIONS 0-7\n         MVCL  R0,R2              INITIALYZE RECORD WITH PAD CHARACTER\n         L     R2,LRECL           RECORD LENGTH\n         MODCB RPL=VSAMRPL,       MOVE RECLEN AND AREA ADDRESS INTO RPL+\n               RECLEN=(R2),       RECORD LENGTH                        +\n               AREA=(RECBAR)      RECORD ADDRESS\n         LTR   R15,R15            MODIFICATION OK.....................?\n         BNZ   MODCBER            NO, FAILED-------------------------->\n         PUT   RPL=VSAMRPL        LOAD ONE DUMMY RECORD\n         LTR   R15,R15            LOAD OK.............................?\n         BNZ   ERROR              NO, PUT DUMMY RECORD FAILED--------->\nCLOSE1   CLOSE (VSAMF)            CLOSE THE FILE\n         LTR   R15,R15            CLOSE OK............................?\n         BNZ   OPENERR            NO, CLOSE ERROR--------------------->\n         SPACE\n         MODCB ACB=VSAMF,         MODIFY ACB TO INDICATE DIRECT KEYED  +\n               MACRF=(DIR)        PROCESSING\n         LTR   R15,R15            MODIFICATION OK.....................?\n         BNZ   MODCBER            NO, FAILED-------------------------->\n         OPEN  (VSAMF)            RE-OPEN IT\n         LTR   R15,R15            OPEN OK.............................?\n         BNZ   OPENERR            NO, OPEN ERROR---------------------->\n         L     R2,LRECL           MAX RECORD LENGTH\n         LR    R3,RECBAR          RECORD ADDRESS\n         A     R3,RKP             + RKP = KEY ADDRESS\n         MODCB RPL=VSAMRPL,       MODIFY RPL TO INDICATE DIRECT KEYED  +\n               AREALEN=(R2),      LENGTH OF INPUT  AREA         UPDATE +\n               ARG=(R3),          ADDRESS OF KEY                       +\n               OPTCD=(DIR,UPD)\n         LTR   R15,R15            MODIFICATION OK.....................?\n         BNZ   MODCBER            NO, FAILED-------------------------->\n         GET   RPL=VSAMRPL        GET DUMMY RECORD FOR UPDATE\n         LTR   R15,R15            GET FOR UPDATE OK...................?\n         BNZ   ERROR              NO, ERROR--------------------------->\n         ERASE RPL=VSAMRPL        DELETE DUMMY RECORD\n         LTR   R15,R15            DELETE OF DUMMY RECORD OK...........?\n         BNZ   ERROR              NO, ERROR--------------------------->\n         CLOSE (VSAMF)            CLOSE THE FILE\n         LTR   R15,R15            CLOSE OK............................?\n         BNZ   OPENERR            NO, CLOSE ERROR--------------------->\n         SPACE\nRC0      SR    R15,R15            RC = 0 ( NORMAL COMPLETION )\n         SPACE\nRETURN   LR    R2,R15             SAVE RETURN CODE\n         L     R0,LRECL           LENGTH AND ADDRESS OF STORAGE\n         LR    R1,RECBAR          TO BE FREED ( RECORD AREA )\n         FREEMAIN R,LV=(0),A=(1)  FREE STORAGE FOR DUMMY RECORD\n         LR    R15,R2             RESTORE RETURN CODE\n         L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)   RETURN\n         SPACE\nRC16     DS    0H                 RC = 16 ( ERROR )\n         CLOSE (MSGFILE)          CLOSE ERROR MESSAGE FILE\n         LA    R15,16             RC = 16 ( ERROR )\n         B     RETURN\n         SPACE\n*---------------------------------------------------------------------*\n* OPEN/CLOSE ERROR ROUTINE                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nOPENERR  DS    0H                 OPEN/CLOSE ERROR ROUTINE\n         ST    R15,ACBERROR       SAVE RC FROM R15\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,OCR15     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SHOWCB ACB=VSAMF,AREA=ACBERROR,LENGTH=4,                      +\n               FIELDS=(ERROR)     GET ERROR FIELD FROM ACB\n         LTR   R15,R15            SHOWCB OK...........................?\n         BNZ   SHOWCBER           NO, SHOWCB ERROR-------------------->\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,ACBERF    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX   CONVERT ACB ERROR FIELD TO HEXADECIMAL\n         LA    MSGADDR,OPECLOEM   OPEN/CLOSE ERROR MESSAGE ADDRESS\n         BAL   LNKREG1,PRNTMSG    PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* PUT/GET/ERASE (VSAM REQUEST) ERROR ROUTINE                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nERROR    DS    0H                 VSAM REQUEST ERROR (GET OR PUT)\n         ST    R15,ACBERROR       SAVE RC FROM R15\n         SHOWCB RPL=VSAMRPL,AREA=FTNCD,LENGTH=8,                       +\n               FIELDS=(FTNCD,FDBK)  GET FTNCD AND FDBK FIELD FROM RPL\n         LTR   R15,R15            SHOWCB OK...........................?\n         BNZ   SHOWCBER           NO, SHOWCB ERROR-------------------->\n         CLI   RPLREQ,RPLGET      GET REQUEST.........................?\n         BE    ERRORGET           YES, GET REQUEST ERROR-------------->\n         CLI   RPLREQ,RPLPUT      PUT REQUEST.........................?\n         BE    ERRORPUT           YES, PUT REQUEST ERROR-------------->\n         CLI   RPLREQ,RPLERASE    ERASE REQUEST.......................?\n         BE    ERRORERS           YES, ERASE REQUEST ERROR------------>\n         MVC   REQTYPE,=CL5'*****' NO, UNEXPECTED REQUEST TYPE\n         B     ERROR1             CONTINUE EDITING OF THE MESSAGE----->\nERRORGET MVC   REQTYPE,=CL5'GET'  GET REQUEST\n         B     ERROR1             CONTINUE EDITING OF THE MESSAGE----->\nERRORPUT MVC   REQTYPE,=CL5'PUT'  PUT REQUEST\n         B     ERROR1             CONTINUE EDITING OF THE MESSAGE----->\nERRORERS MVC   REQTYPE,=CL5'ERASE' PUT REQUEST\nERROR1   LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,FTNCD      INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQFTNCD  OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'FTNCD     LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT FTNCD TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,FDBK       INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQFDBK   OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'FDBK      LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT FDBK  TO HEXADECIMAL\n         LA    MSGADDR,REQERRM    VSAM REQUEST ERROR MESSAGE ADDRESS\n         BAL   LNKREG1,PRNTMSG    PRINT ERROR MESSAGE\n*       CHECK IF DUMMY RECORD ALREADY EXISTS\n         CLI   RPLREQ,RPLPUT      PUT REQUEST.........................?\n         BNE   RC16               NO, TERMINATE THE PROGRAM----------->\n         CLC   ACBERROR,=F'8'     R15 = 8.............................?\n         BNE   RC16               NO, NOT A DUMMY RECORD IN THE FILE-->\n         CLC   FDBK,=F'8'         DUPLICATE RECORD CONDITION..........?\n         BNE   RC16               NO, NOT AN EXISTING DUMMY RECORD---->\n         LA    MSGADDR,DUPRECM    DUMMY RECORD ALREADY IN THE FILE\n         BAL   LNKREG1,PRNTMSG    PRINT MESSAGE\n         B     CLOSE1             DELETE EXISTING DUMMY RECORD\n         SPACE\n*---------------------------------------------------------------------*\n* SHOWCB ERROR ROUTINE                                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSHOWCBER DS    0H                 SHOWCB MACRO ERROR\n         STM   R15,R0,ACBERROR    SAVE R15 AND R0 (ERROR CODE)\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,SCBR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,ACBERROR+4 INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,SCBR0     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT ERROR CODE TO HEXADECIMAL\n         SPACE\n         LA    MSGADDR,SCBERRM    SHOWCB ERROR MESSAGE ADDRESS\n         BAL   LNKREG1,PRNTMSG    PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* MODCB ERROR ROUTINE                                                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMODCBER  DS    0H                 MODCB MACRO ERROR\n         STM   R15,R0,ACBERROR    SAVE R15 AND R0 (ERROR CODE)\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,MCBR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,ACBERROR+4 INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,MCBR0     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT ERROR CODE TO HEXADECIMAL\n         SPACE\n         LA    MSGADDR,MCBERRM    SHOWCB ERROR MESSAGE ADDRESS\n         BAL   LNKREG1,PRNTMSG    PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* INPUT FILE IS NOT A KSDS                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOTKSDS  LA    MSGADDR,NKSDSEM    NON-KSDS DATA SET ON INPUT\n         BAL   LNKREG1,PRNTMSG    PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* INPUT FILE IS NOT EMPTY (ALREADY LOADED)                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOEMPTY  LA    MSGADDR,NEMPTEM    NON-EMPTY DATA SET ON INPUT\n         BAL   LNKREG1,PRNTMSG    PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* MESSAGE PRINT ROUTINE                                               *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRNTMSG  DS    0H                 PRINT ERROR MESSAGE ROUTINE\n         TM    MSGFILE+48,DCBOFOPN  IS MESSAGE FILE OPENED............?\n         BO    PRNTMSG1           YES, ALREADY OPENED    ------------->\n         OPEN  (MSGFILE,(OUTPUT))\n         TM    MSGFILE+48,DCBOFOPN    OPEN SUCCESSFUL    .............?\n         BNO   MSGOPNER           NO, OPEN ERROR         ------------->\nPRNTMSG1 SLR   R1,R1              CLEAR R1\n         IC    R1,0(MSGADDR)      MESSAGE TEXT LENGTH\n         CH    R1,=AL2(L'MSGTXT)  WILL FIT INTO MSGTXT FIELD..........?\n         BNH   PRNTMSG2           YES, OK----------------------------->\n         LH    R1,=AL2(L'MSGTXT)  NO, PRINT ONLY PART OF MESSAGE TEXT\nPRNTMSG2 BCTR  R1,0               MESSAGE TEXT LENGTH - 1\n         EX    R1,MVCMSG          MOVE MESSAGE TEXT INTO LINE\n         PUT   MSGFILE,MSGREC     PRINT MESSAGE\n         MVI   MSGTXT,X'40'       BLANK MESSAGE RECORD\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT\n         BR    LNKREG1\nMVCMSG   MVC   MSGTXT(1),1(MSGADDR)  MOVE MESSAGE TEXT INTO MSG LINE\n         SPACE\n*---------------------------------------------------------------------*\n*   TRANSLATION OF ERROR CODES INTO HEXADECIMAL SUBROUTINE            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* HEXINAR  - INPUT FIELD ADDRESS\n* HEXOUTAR - OUTPUT FIELD ADDRESS\n* HEXLEN   - INPUT FIELD LENGTH\n         SPACE\nCONVHEX  DS    0H\n         IC    TCHR,0(0,HEXINAR)  TRANSLATED CHARACTER\n         SLL   TCHR,24            EXTRACT H/O HEX DIGIT\n         SRL   TCHR,28\n         LA    TCHR,HEXCH(TCHR)   HEX DIGIT ADDRESS\n         MVC   0(1,HEXOUTAR),0(TCHR) MOVE HEX DIGIT INTO OUTPUT STRING\n         IC    TCHR,0(0,HEXINAR)  TRANSLATED CHARACTER\n         SLL   TCHR,28            EXTRACT L/O HEX DIGIT\n         SRL   TCHR,28\n         LA    TCHR,HEXCH(TCHR)   HEX DIGIT ADDRESS\n         MVC   1(1,HEXOUTAR),0(TCHR) MOVE HEX DIGIT INTO OUTPUT STRING\n         LA    HEXINAR,1(0,HEXINAR) NEXT TRANSLATED CHAR ADDRESS\n         LA    HEXOUTAR,2(0,HEXOUTAR) NEXT OUTPUT ADDRESS\n         BCT   HEXLEN,CONVHEX     TRANSLATE NEXT CHARACTER\n         BR    LNKREG1            RETURN TO CALLER\n         SPACE\nHEXCH    DC    C'0123456789ABCDEF' HEXADECIMAL CHARACTERS\n         SPACE\n*/////////////////////////////////////////////////////////////////////*\n*        THE FOLLOWING FULLWORDS ARE LOCATION DEPENDENT               *\nDISPLAY  DS    0F                 FIELDS OBTAINED BY SHOWCB           *\nLRECL    DS    F                  MAX. LRECL                          *\nRKP      DS    F                  RELATIVE KEY POSITION               *\nKEYLEN   DS    F                  KEY LENGTH                          *\nACBERROR DS    F                  ACB ERROR FIELD                     *\nFTNCD    DS    F                  RPL FUNCTION CODE                   *\nFDBK     DS    F                  RPL FEEDBACK FIELD                  *\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n         IFGACB DSECT=NO,AM=VSAM       ACB LAYOUT\n         ORG   IFGACB\nVSAMF    ACB   AM=VSAM,DDNAME=KSDS,MACRF=(OUT)\n         SPACE\n         IFGRPL DSECT=NO,AM=VSAM       RPL LAYOUT\n         ORG   IFGRPL\nVSAMRPL  RPL   ACB=VSAMF,OPTCD=(SEQ)   LOAD RPL\n         SPACE\n*  MESSAGE SEQL DATA SET\nMSGFILE  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FB,             +\n               LRECL=132,EXLST=MSGEXLST\n         SPACE\nMSGEXLST DS    0F\n         DC    X'85',AL3(MSGDCBEX) EXIT FOR BLKSIZE NOT SPECIFIED\n         SPACE\nMSGOPNER DS    0H                 MSG DCB OPEN ERROR\n         WTL   'KSDSINIT  - SYSPRINT DATA SET CANNOT BE OPENED'\n         B     RC16\n         SPACE\nMSGDCBEX DS    0H                 EXIT IF BLKSIZE NOT SPECIFIED        +\n                                  MSG DATA SET\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         LH    R2,DCBBLKSI        LOAD BLKSIZE\n         LTR   R2,R2              BLKSIZE=0 ..........................?\n         BNZR  R14                NO,RETURN <----------------\n         MVC   DCBBLKSI,DCBLRECL  BLKSIZE=LRECL========================\n         BR    R14                RETURN    <----------------\n         DROP  R1\n         SPACE\nOPECLOEM DC    AL1(OPECLOME-OPECLOEM-1) OPEN/CLOSE ERROR MESSAGE\n         DC    C'OPEN/CLOSE ERROR  R15='\nOCR15    DS    CL8                RC CODE IN R15\n         DC    C' ACB ERROR FIELD='\nACBERF   DS    CL8                ACB ERROR FILED\nOPECLOME EQU   *\n         SPACE\nREQERRM  DC    AL1(REQERRME-REQERRM-1) GET | PUT | ERASE ERROR MSG\n         DC    C'VSAM '\nREQTYPE  DC    CL5' '             REQUEST TYPE\n         DC    C' REQUEST ERROR  R15='\nREQR15   DS    CL8                RC CODE IN R15\n         DC    C' FTNCD='\nREQFTNCD DS    CL8                REQUEST FUNCTION CODE\n         DC    C' FDBK='\nREQFDBK  DS    CL8                REQUEST FEEDBACK FIELD\nREQERRME EQU   *\n         SPACE\nSCBERRM  DC    AL1(SCBERRME-SCBERRM-1) SHOWCB MACRO ERROR\n         DC    C'SHOWCB MACRO ERROR  R15='\nSCBR15   DS    CL8                RC CODE IN R15\n         DC    C' R0='\nSCBR0    DS    CL8                REQUEST FUNCTION CODE\nSCBERRME EQU   *\n         SPACE\nMCBERRM  DC    AL1(MCBERRME-MCBERRM-1) MODCB MACRO ERROR MSG\n         DC    C'MODECB MACRO ERROR  R15='\nMCBR15   DS    CL8                RC CODE IN R15\n         DC    C' R0='\nMCBR0    DS    CL8                REQUEST FUNCTION CODE\nMCBERRME EQU   *\n         SPACE\nNKSDSEM  DC    AL1(NKSDSEME-NKSDSEM-1) NOT KSDS FILE ERROR MESSAGE\n         DC    C'NON-KSDS DATA SET IS NOT ALLOWED AS INPUT TO THIS PROG+\n               RAM'\nNKSDSEME EQU   *\n         SPACE\nNEMPTEM  DC    AL1(NEMPTEME-NEMPTEM-1) NOT-EMPTY FILE ERROR MESSAGE\n         DC    C'INPUT DATA SET IS NOT A NEWLY DEFINED, EMPTY KSDS CLUS+\n               TER'\nNEMPTEME EQU   *\n         SPACE\nDUPRECM  DC    AL1(DUPRECME-DUPRECM-1) DUMMY RECORD ALREADY IN THE FILE\n         DC    C'LOAD OF DUMMY RECORD FAILED. RECORD ALREADY EXISTS IN +\n               THE FILE'\nDUPRECME EQU   *\n         SPACE\nMSGREC   DS    0CL132             MESSAGE RECORD\n         DC    CL10'KSDSINIT'     PROGRAM ID\nMSGTXT   DC    CL122' '           MESSAGE TEXT\n         LTORG\n         SPACE\n         DCBD  DSORG=PS\n         SPACE\n         END   KSDSINIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KSDSPACE": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00D\\x00\\x993\\x7f\\x01\\x04)_\\x16\\x07\\np\\x07I\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1999-12-03T00:00:00", "modifydate": "2004-10-21T16:07:44", "lines": 2672, "newlines": 1865, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....your jobcard......\n//*\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,NOALIGN,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'KSDS FILE SPACE DISTRIBUTION ANALYSIS ROUTINE'\n*\n* \"COPYRIGHT (C) 2002 by Jan (Janek) Jakubek.\n* ALL RIGHTS  RESERVED EXCEPT:  PARTICULAR LICENSE IS GRANTED TO\n* DISTRIBUTE THIS PROGRAM FREE OF CHARGE, BUT IT MUST NOT BE SOLD.\"\n*\n* KSDS FILE SPACE DISTRIBUTION ANALYSIS ROUTINE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* THIS VERSION DOES A SEQUENTIAL PROCESSING OF THE DATA COMPONENT     *\n* RESULTING IN BETTER PERFORMANCE (VSAM BUFFER READ AHEAD) IF EXTRA   *\n* DATA BUFFERS ARE SPECIFIED.                                         *\n*                                                                     *\n* This version has been tested on OS/390 2.10. I assume it should work*\n* with DFSMS 1.3 and up, although I do not have older versions of     *\n* DFSMS to test under.                                                *\n* If you are running DFSMS 1.2 or older version of DFP (unsupported) -*\n* you may want to use the previous version of this program: KSDSPACO  *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME:       KSDSPACE\n*\n* ATTRIBUTES :       STANDARD (NOT AUTHORIZED) *** SEE NOTE #1 ***\n*                    RMODE 24\n*                    AMODE 24\n*\n* ASSEMBLER OPTIONS: NOALIGN\n*\n* Notes:\n* 1. If KSDSPACE is linkedited with AC=1 into an APF authorized\n*    LOADLIB - it can process BCS of an ICF catalog as well.\n*    RACF ALTER authority to the catalog is also required in order\n*    to open it as a dataset.\n*\n* FUNCTION = SEE BELOW\n*\n*     THE PURPOSE OF THIS ROUTINE IT TO READ THE INDEX (SEQUENCE SET\n*  ONLY) AND DATA COMPONENTS OF A KSDS CLUSTER AND PRODUCE SPACE\n*  UTILIZATION REPORTS FOR:\n*  .EACH CONTROL AREA (DATA COMPONENT ONLY)\n*  .INDEX COMPONENT\n*  .THE WHOLE DATA COMPONENT\n*  TWO REPORTS ARE PRINTED: ONE WITH NUMERIC VALUES (TABLE LIKE FORMAT)\n*  AND ANOTHER WHERE SPACE DISTRIBUTION IS PRESENTED IN A GRAPHICAL\n*  FORMAT: A LINE IS PRINTED FOR EACH CONTROL AREA. IT REPRESENTS\n*  100% OF THE SPACE. DIFFERENT CHARACTERS REPRESENT BREAKDOWN OF\n*  THAT SPACE INTO THE FOLLOWING COMPONENTS:\n*\n*  * - SPACE OCCUPIED BY DATA RECORDS.\n*  - - UNUSED CONTROL INTERVALS RESULTING FROM CA FREE SPACE\n*      SPECIFICATION AND/OR CA SPLITS (OR RECORD DELETES).\n*  X - UNUSED SPACE IN CONTROL INTERVALS CONTAINING DATA RECORDS\n*      RESULTING FROM CI FREE SPACE SPECIFICATION AND/OR CI SPLITS\n*      (OR RECORD DELETES).\n*  + - UNUSED CONTROL INTERVALS RESULTING FROM LACK OF SPACE IN THE\n*      INDEX CI (INDICATION THAT INDEX CI size IS TOO SMALL).\n*      THIS IS AN ESTIMATE ONLY - NOT A PRECISE VALUE AND IT CAN ONLY\n*      SHOW UP WHEN A CA IS FULLY LOADED (NO CA FREE SPACE).\n*      Usually it is an undrestimate.\n*\n*  \"-\", \"+\" WILL NEVER BE SHOWN FOR AN INDEX COMPONENT. ALSO, \"X\"\n*  HAS A DIFFERENT MEANING: EITHER INDEX CI IS TWO LARGE OR IT RESULTS\n*  FROM \"-\" TYPE FREE SPACE IN THE DATA COMPONENT.\n*\n*  THE REPORTS CAN BE USEFUL FOR TUNNING OF A KSDS FILE: CI SIZE\n*  SELECTION (BOTH INDEX AND DATA COMPONENTS), FREE SPACE\n*  SPECIFICATION, CA SIZE SPECIFICATION, AND TO MAKE A DECISION TO\n*  REORGANIZE A FILE.\n*\n*\n*\n*\n* RETURN CODES FROM THE PROGRAM:\n*     0 - NORMAL SUCCESSFUL COMPLETION\n*    16 - ERROR. CHECK MESSAGES IN SYSPRINT AND/OR SYSTEM LOG.\n*\n*\n*    THE FOLLOWING JCL PROCEDURE CAN BE CATALOGED & INVOKED\n*    TO RUN THIS PROGRAM:\n*\n*        //KSDSPACE PROC DISP=SHR,RPTT='SYSOUT=*',RPTG='SYSOUT=*',\n*        //              LHKR='SYSOUT=*'\n*        //KSDSPACE EXEC PGM=KSDSPACE\n*        //STEPLIB    DD DSN=SYS1.UTIL.LINKLIB,DISP=SHR\n*        //KSDS       DD DSN=&KSDS,DISP=&DISP\n*        //SYSPRINT   DD SYSOUT=*           Diagnostic MESSAGE FILE\n*        //RPTT       DD &RPTT              TABLE FORMAT REPORT\n*        //RPTG       DD &RPTG              GRAPHICAL FORMAT REPORT\n*        //LHKR       DD &LHKR              Low/High key     REPORT\n*    (LHKR can be written to a DASD data set for viewing/editing,\n*     particulary if the key is non-printable/binary/numeric).\n*\n*    \"KSDS\" SYMBOLIC PARAMETER HAS TO SPECIFY THE NAME OF THE KSDS\n*    CLUSTER.\n*    A REPORT CAN BE SUPRESSED BY SPECIFYING RPTT/RPTG/LHKR=DUMMY.\n*\n* WRITTEN BY:\n*            Jan (Janek) Jakubek\n*     TEL  : 416-255-8807 (Canada, Ontario)\n*     EMAIL: Jan.Jakubek@CGI.COM\n*\n* Date first version written: MARCH-APRIL 1989\n*\n* Known restrictions:\n* 1. Since the program uses Control Interval Access (OPTCD=CNV) -\n*    RLS and compressed datasets are not supported.\n*\n* KNOWN PROBLEMS, NOT YET FIXED:\n* 1. None known to me (JJ)\n*\n* FUTURE ENHANCEMENTS IDEAS (in no particular order):\n* 1. KEY-RANGE DATASET SUPPORT (LOW PRIORITY, SUPPORT FOR KEY-RANGE\n*    will BE REMOVED FROM VSAM IN THE FUTURE).\n* 2. The current Index Record Short free space is an estimate only.\n*    If you see any CA with this - it is a sure sign that there is\n*    a problem. However there may be a problem and yet KSDSPACE\n*    will report the free CIs as CA FREESPACE.\n*    I'm thinking on improving the estimate (and avoid rising false\n*    alarms), however I wish I could find out how VSAM does it\n*    (decides that it cannot address more CIs in a CA, given a free\n*     space in an Index Sequence Set CI).\n* 3. This may not be a problem, however: I get the first SS IX record\n*    from AMDSSRBA in AMDSB (OCO only CB). I know that AMDSSRBA is\n*    expressed in bytes for IMBED index KSDS. I do not know if this\n*    always is the case however (like for EF/EA datasets).\n*    In all other KSDS examples available to me (not IMBED IX) - the\n*    first SS record is always the first CI in the index component\n*    so its RBA is always zero. Apparently VSAM doesn't build the\n*    2nd level index until there are at least 2 sequence set records,\n*    meaning at least two data CAs containing data. Thus the 1st index\n*    record in a non-imbedded cluster will aways be the first sequence\n*    set record, hence RBA 0. For RBA=0 it is impossible to discern\n*    if AMDSSRBA represents bytes or relative CI number.\n*    If a contrary case is ever found, the commented out code above\n*    label IXCIPROC may be helpful in fixing a problem (likely\n*    a GETIX read error).\n* 4. Convert the use of OCO control blocks to CSI search. I did not\n*    researched (yet) if all data used by KSDSPACE can be retrieved via\n*    CSI though.\n* 5. For empty CAs (low/high key per CA report) add a second line\n*    with high key value.\n* 6. Add an average compressed key length per CA column in one of the\n*    reports (to be decided which one) a la Mainstar VSAM Manager.\n*    This may help with enh. # 2 above (\"dead\" CIs estimate).\n*\n* CHANGE ACTIVITY:\n*\n*  April 5/2004, JJ:\n*    .On a suggestion from Gerhard Postpischil added a local\n*     customization equate:\n*     RPTLPP EQU 65 (report lines per page)\n*     to make it easier to change in case the default is not\n*     appropriate in a particular (print) environment.\n*\n*  May   7/2003, JJ:\n*    .Changed Extended Addressability determination to a CSI call\n*     (from OBTAIN/format 1 DSCB). Is seems DSCB1 extended format\n*     flags may not mean the Extended Addressability.\n*\n*  Dec. 11/2002, JJ:\n*    .Added Extended Addressability KSDS support. In the EA KSDS, RBA\n*     in index records is expressed as relative CI number: this means\n*     that it needs to be multiplied by CI length to calculate a true\n*     RBA value.\n*\n*    .Converted RPL OPTCD from RBA to XRBA (this is required if\n*     Ext-Addr KSDS with size above 4GB is being processed: RBA\n*     should work until 4GB RBA is reached. It would fail from 4GB and\n*     above). Although, apparently, with PTF for APAR OW43595 applied -\n*     XRBA is required for Extended Addressability datasets regardless\n*     of dataset size.\n*\n*    .Removed check for DFSMS 1.3 or above. This means that lower\n*     (unsupported) levels of DFSMS are not supported. Use the old\n*     version of this program: KSDSPACO if running DFSMS 1.2 or older\n*     version of DFP, or a version that does not support XRBA\n*     (I do not know when XRBA was introduced).\n*\n*    .Replaced CI RBA in LOW/HIGH key report by CI# (relative CI\n*     number). This is due to difficulty in handling large (8 bytes)\n*     binary numbers (arithmetic and conversion to printable).\n*\n*    .Moved some control blocks/macros and report header lines to\n*     KSDSPACD csect to alleviate addressability constraints of\n*     the mainline CSECT.\n*\n*    .Removed bytes column from RPPT FREESPACE-CA and IX REC SHORT\n*     columns. This is related to restructuring of SUS (Space\n*     Utilization Summary) control block.\n*\n*    .Converted all bytes counts from 4 bytes binary to 8 bytes.\n*     This is in support of files larger than 4GB.\n*     If data component size is > 4 GiB - the grand total byte counts\n*     are rounded to 1KiB.\n*\n*    .For empty control areas added message in the key column:\n*     \"***** EMPTY Control Area *****\"\n*     (an empty CA has all logical data records deleted).\n*     The previous version would incorrectly print a line with high\n*     key from the previous CA.\n*\n*    .Separated all data fields/constants from code (this\n*     apparently impacts performance/ CPU time on z hardware).\n*\n*  Sept  4/01,JJ:\n*\n*    .Added Low/High key report: for every CA two lines are printed/\n*     written to LHKR (ddname) datasets. Line/data format is:\n*     CA#          - control area number\n*     CI RBA       - RBA of CI in which the Low/High key has occurred\n*     Low/High key - Low (first line for a CA)/ High (second line for\n*                    a CA) key as found in data CIs of a CA.\n*     The Low/High key are as found in data records (every data record\n*     is processed) and not the values from index Sequence Set CI.\n*\n*    .Fixed a serious error: RBA of data CI being read was always\n*     within the first CA. As a result the CI free/used space was\n*     always incorrect (except of the first CA). This was due to\n*     my missinterpretation of the vertical pointer (IBFLP3).\n*     IXHBRBA (CA base RBA) has to be added to vertical pointer\n*     to get a data CI RBA.\n*\n*  Aug  24/01,JJ:\n*    .Added report on index structure: # of IX records per IX level.\n*     This gets printed on RPTT only after IX stats. If index is\n*     IMBED - the count of records for IX level 1 (Sequence Set)\n*     is always 0 and is not valid. I do not bother to fix this\n*     (a sequential read of IMBED index will not read SS - SEOF\n*     occurs before SS) since the SS IX record count is the\n*     same Used Conrol Areas count printed at the end.\n*\n*  Aug  20/01,JJ:\n*    .Eliminated second header line on page #1 of RPTT (table format\n*     report).\n*\n*  DEC  03/99,JJ:\n*    .MINOR CHANGE TO ALLOW ICF BCS PROCESSING (ONLY IF KSDSPACE IS\n*     LINKEDITED WITH AC(1), INTO AN APF AUTHORIZED LOADLIB).\n*     TO OPEN A CATALOG AS A DATASET, YOU MUST HAVE ALTER AUTHORITY TO\n*     THE CATALOG AND APF AUTHORIZATION.\n*\n*  JUNE 24/99,JJ:\n*    .FIXED ABEND 0C4/ INVALID SECOND LINE ON SYSPRINT REPORT\n*     (DIAGNOSTIC MSGS). SECOND PAGE HEADER LINE ADDRESS WAS\n*     MISSING RESULTING IN EITHER GARBAGE LINE OR 0C4.\n*    .FIXED A MINOR LOGIC ERROR. NUMBER OF FREE (UNUSED) CA'S\n*     AT EOF WAS ALWAYS 0 (DFSMS 1.3 OR UP).\n*\n*  SEPT. 2/98,JJ:\n*     CALCULATION OF % OF USED/ FREE SPACE FAILED  (RPTTSDLP LABEL)\n*     0C7 ABEND IN \"MP    D,=PL3'1000'\". REPLACED THIS WITH A SHIFT OF\n*     2 GPRS (12 BITS, 3 ZONES)\n*\n*  OCT.  7/97,JJ:\n*     ITEM #1 BELOW IS NOT ADDRESSED YET. I DO NOT HAVE TIME AND\n*     A KEY RANGE KSDS TO WORK WITH.\n*     ITEM #2 BELOW IS FIXED - ADDED CODE TO DETERMINE THE\n*     DFP LEVEL AND INTERPRET RBA AS # OF CI'S ON DFSMS 1.3.0 AND UP.\n*\n*  OCT.  7/97,JJ:\n*     FOUND OUT TWO PROBLEMS THAT I INTEND TO FIX:\n*     1.I USE ONLY FIRST ARDB (ADDRESS RANGE DEFINITION BLOCK).\n*       THIS IS FINE FOR A REGULAR KSDS FILE. IT MIGHT BE INCORRECT\n*       THOUGH FOR A KEYRANGE DATA SET (THERE IS AN ARDB FOR EVERY\n*       KEYRANGE). WILL PROCESS ALL ARDB'S AND SELECT THE ONE WITH\n*       HIGHEST RBA.\n*     ??? AS OF TODAY, I DO NOT UNDERSTAND THE KEYRANGE DATA SET\n*     ??? PROCESSING. THE # OF FREE CA'S AT THE END OF A DATASET MAY\n*     ??? BE INCORECT. ALSO, IS EVERY KEYRANGE PROCESSED AS A SEPARATE\n*     ??? DATASET ?\n*     2.AS OF DFSMS 1.3 RBA'S IN ARDB ARE EXPRESSED IN NUMBER OF CI'S\n*       RATHER THAN BYTES. AS A RESULT - # OF CA'S AT THE END OF\n*       A DATA SET IS ALWAYS REPORTED AS 0.\n*\n*    APR. 10/97,JJ:\n*       FREE CA CI'S DUE TO IX RECORD TOO SHORT CALCULATION WAS\n*       INCORRECT. MADE A CORRECTION AND SEEMS TO BE OK NOW.\n*\n*    AUG. 27/92,JJ: A HEADER LINE WAS MISSING FOR RPTT REPORT ON ALL\n*       LINES EXCEPT OF LINE ONE. CORRECTED THIS.\n*\n*    JUNE 23/92,JJ: ADDED EXTRA LINE IN THE COMPONENT STATISTICS PART\n*       OF THE REPORTS.\n*       ADDED NUMBER OF CI'S (#CI HEADER) COLUMN FOR THE CA FREE SPACE,\n*       UNUSED CI'S AND USED SPACE.\n*\n         SPACE 2\n*  Acknowledgment:\n*  SUBENT and SUBRET macro are of an unknown origin.\n*  I borrowed them from some public domain (I think) code an use\n*  them here and in other programs.\n*\n*  \"SUBENT\" - SUBROUTINE ENTER MACRO\n*  \"SUBENT\" IS USED AT ENTRY TO INTERNAL SUBROUTINE\n*  LINK REGISTER IS ALWAYS R14\n         MACRO\n&LAB     SUBENT\n         SPACE\n&LAB     DS    0F\n         B     *+16                     AROUND EYE CATCHER AND R14 SAVE\n         DC    CL8'&LAB'                EYE CATCHER\n         DC    F'0'                     R14 SAVE\n         ST    R14,*-4                  STORE R14\n         SPACE\n         MEND\n*  \"SUBRET\" - SUBROUTINE RETURN MACRO\n*  \"SUBRET\" IS USED TO EXIT FROM AN INTERNAL SUBROUTINE\n         SPACE\n         MACRO\n&LAB1    SUBRET &LAB\n         SPACE\n&LAB1    L     R14,&LAB+12              RESTORE R14\n         BR    R14                      RETURN\n         SPACE\n         MEND\n         SPACE\n         PRINT NOGEN\nKSDSPACE CSECT                    CSECT NAME\nKSDSPACE AMODE 24\nKSDSPACE RMODE 24\n         USING KSDSPACE,R15\n         SAVE  (14,12)            SAVE REGISTERS\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   R2,SAE             SAVE AREA ADDRESS\n         DROP  R15\nSA       DS    18F                SAVE AREA\n         USING SA,R2\nSAE      ST    R13,SA+4           CHAIN\n         ST    R2,8(R13)          SAVE AREAS\n         LR    R13,R2             CURRENT SAVE AREA\n         DROP  R2\n         USING SA,R13,R12         PROGRAM BASE REGISTER\n         LA    R12,2048(,R13)     SECOND BASE REGISTER\n         LA    R12,2048(,R12)\n         SPACE\n* REGISTERS EQUATES\n         YREGS ,\n         SPACE\nTCHR     EQU   R2                 HEX TRANSLATED CHARACTER REGISTER\nHEXLEN   EQU   R3                 CONVHEX INPUT FIELD LENGTH\nDATACSR  EQU   R5                 Data CSECT addressability register\nHEXOUTAR EQU   R14                CONVHEX OUTPUT FIELD ADDRESS\nHEXINAR  EQU   R15                CONVHEX INPUT FIELD ADDRESS\nLNKREG1  EQU   R9                 LINK REGISTER 1\nRPTDBAR  EQU   R10                REPORT DEFINITION BLOCK ADDRESS\nMSGADDR  EQU   R11                ERROR MESSAGE ADDRESS\n         SPACE\n* Local customization equates\nRPTLPP   EQU   65                 Report lines per page\n         SPACE\n* OFFSETS OF A FEW FIELDS IN AMBL\nAMBLQ    EQU   23                 QUALIFIER           (IN AMBL)\nAMBLKSDS EQU   X'04'              CLUSTER OPEND AS KSDS FLAG (AMBLQ)\nAMBLDTA  EQU   52                 POINTER TO DATA AMB (IN AMBL)\nAMBLIX   EQU   56                 POINTER TO INDEX AMB (IN AMBL)\n         SPACE\n         OPEN  (VSAMF)\n         LTR   R15,R15            OPEN OK.............................?\n         BNZ   OPENERR            NO, OPEN ERROR---------------------->\n*  CHECK IF IT IS A KSDS FILE\n         L     R2,ACBAMBL         AMB LIST ADDRESS\n         TM    AMBLQ(R2),AMBLKSDS A KSDS CLUSTER......................?\n         BZ    NOTKSDS            NO, IT IS NOT A KSDS FILE----------->\n* PRINT OPEN TIME STATISTIC FOR DATA AND INDEX COMPONENTS AVAILABLE\n* IN THE AMDSB\n         L     R3,AMBLDTA(,R2)    LOAD DATA COMP. AMB ADDRESS\n         USING AMB,R3             AMB ADDRESSABILITY\n         L     R4,AMBDSB          LOAD DATA COMP. AMBSB ADDRESS\n         ST    R4,DATADSBA        SAVE DATA COMPONENT AMDSB ADDRESS\n         USING AMDSB,R4           AMBSB ADDRESSABLITY\n* We will adjust record length of the LHKR file/DCB\n         LA    R0,LHKL1KEY-LHKL1  lenght of fixed part of the record\n         AH    R0,AMDKEYLN        + key length = record length\n         STH   R0,LHKL1           store it in RDW\n* If LRECL < 137 will make it 137 (due to header line)\n         CH    R0,=H'137'\n         BNL   LHKRLA             L'LHKL1 >= 137\n         LH    R0,=H'137'         make is 137 (minimum LRECL)\nLHKRLA   L     R1,LHKRDCBA        DCB address\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         STH   R0,DCBLRECL        store LRECL in DCB\n         LH    R0,AMDKEYLN        Key length\n         DROP  R1                 Drop addressability\n         CVD   R0,D               CONVERT TO DECIMAL\n         L     R1,LHKRHTA         address of report header line\n         USING LHKRHLT,R1         header line addressibility\n         ED    LHKRHLKL,D+4       EDIT/convert key length\n*                                 to printable on LHKR header line\n         DROP  R1\n* ONLY A LOADED KSDS (NON-EMPTY) CAN BE PROCESSED BY THIS PROGRAM\n* FOR A BCS, AMDNLR FIELD IS ALWAYS ZERO:\n* WE NEED TO DETERMINE HERE IF THIS IS A BCS. WILL READ FMT 1 DSCB\n* OF DATA COMPONENT TO CHECK IF THIS IS A BCS.\n         L     DATACSR,=V(KSDSPACD) Data CSECT address\n         USING KSDSPACD,DATACSR   KSDSPACD addressability\n         MVC   DS1DSNAM,AMBDSNM   MOVE DATA COMPONENT DSNAME FOR\n*                                 CMALST/OBTAIN USE\n* NOW WE NEED TO GET DATA COMPONEMT 1-ST VOLSER FROM ARDB\n         L     R15,AMDPARDB       LOAD ARDB ADDRESS\n         USING ARDB,R15           ARDB ADDRESSABILITY\n         MVC   DS1DSSN,ARDVOLSR   MOVE DATA COMPONENT VOLSER FOR\n*                                 CMALST/OBTAIN USE\n         DROP  R15\n         OBTAIN CAMLSTO           GET FMT1 DSCB\n         LTR   R15,R15            OBTAIN SHOULD NEVER FAIL SINCE\n*                                 DATASET IS ALREADY OPEN, HOWEVER....?\n         BNZ   NOTBCS             WILL IGNORE IT DOES ---------------->\n         CLI   DS1FMTID,C'1'      DO WE HAVE FMT1 DSCB ...............?\n         BNE   NOTBCS             THIS IS UNEXPECTED, LET'S IGNORE IT->\n         TM    DS1OPTCD,DS1OPTBC  IS THIS AN ICF BCS .................?\n         BO    BCS1               YES, BYPASS EMPTY KSDS TEST--------->\n*\n*  Call Catalog Search to determine\n*  if this is an extended addressing KSDS\nNOTBCS   MVC   CSIFILTK,AMBDSNM   MOVE DATA COMPONENT DSN to CSI filter\n         L     R15,IGGCSIMA       IGGCSI00  EP ADDRESS into R15\n         LA    R1,CSIPARML        CSI call parm list\n         BASR  R14,R15            CSI call\n         LTR   R15,R15            Is RC=0 from CSI call ..............?\n         BNZ   CSICERR1           CSI call error---------------------->\n         TM    CSIEFLAG,CSIEDATAR Data returned for this entry........?\n         BZ    NOTBCS1            No, assume no Extended Addressability\n         TM    CSIFEAFLG,CSIFEA4GB Extended Addressability KSDS ......?\n         BZ    NOTBCS1            No\n         OI    CAFLAGS,EAKSDS     Yes, set Extended Addressability flag\nNOTBCS1  L     R14,AMDNLR         NO.OF RECORDS IN THE DATA COMPONENT\n         LTR   R14,R14            ANY RECORDS IN THE FILE.............?\n         BZ    KSDSNL             NO, DATA SET IS NOT LOADED---------->\n         DROP  DATACSR\nBCS1     MVC   CISIZED,AMDCINV    SAVE THE DATA COMPONENT CISIZE\n         BAL   R14,PRNTSTAT       PRINT DATA  COMPONENT STATISTICS\n         L     R3,AMBLIX(,R2)     LOAD INDEX COMP. AMB ADDRESS\n         L     R4,AMBDSB          LOAD INDEX COMP. AMBSB ADDRESS\n         ST    R4,INDXDSBA        SAVE INDEX COMPONENT AMDSB ADDRESS\n         MVC   CISIZEI,AMDCINV    SAVE THE INDEX COMPONENT CISIZE\n         BAL   R14,PRNTSTAT       PRINT INDEX COMPONENT STATISTICS\n* Find out # of records at each index level and print that like:\n* IX level   # of IX records\n         STM   R2,R15,SAVEA1      SAVE REGISTERS BEFORE CALLING\n         BAL   R14,IXRPT          Index analyses/ report\n         LM    R2,R15,SAVEA1      RESTORE THE REGISTERS\n         LA    R11,SGL1           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R11,SGL2           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R11,SGL3           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R11,SGL4           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         L     R11,RPTTHTA1       ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         USING RPTTL1H,R11        addressability to header line\n         MVI   RPTTL1HA,C'0' 1 SPACE NEXT TIME THIS HEADER LINE PRINTED\n         DROP  R11\n         BAL   R14,BLANKL         PRINT A BLANK LINE AFTER STATISTICS\n* AT THIS POINT WE HAVE INDEX AMDSB ADDRESS IN R4\n* From what I know  - this is a real RBA (not a relative CI#)\n* Besides, the KSDSes that I ever looked at - RBA of the first IX SS CI\n* is always zero (except of IMBED IX KSDS, and in this case, it is\n* expressed in bytes).\n         MVC   IXCIRBA,AMDSSRBA   MOVE RBA OF THE FIRST SEQUENCE SET\n         XC    IXCIRBAX,IXCIRBAX  Clear HO XRBA\n*        TM    AMDATTR,AMDSDT     IMBED INDEX.........................?\n*        BO    IXCIPROC           Yes, bypass multiply by CISIZEI----->\n*        L     R1,AMDSSRBA        RBA of the first IX SS record\n*                                 (expressed as relative CI#)\n*        M     R0,CISIZEI         * IX CI size = XRBA\n*        STM   R0,R1,IXCIRBAX     Store XRBA into work field\n         SPACE\n* THIS IS THE MAINLINE PROCESSING CODE.\n* AN INDEX SEQUENCE SET CI (RECORD) GOVERNING ONE CA IS READ.\n* FOR EVERY SS RECORD, ALL USED DATA CI FROM THAT CA ARE ALSO READ\n* AND PROCESSED. A REPORT LINE IS PRINTED FOR EACH CA.\nIXCIPROC DS    0H                 INDEX RECORD (SS) PROCESSING\n* Edit current CA number to printable (in LHKL1 for LHKR report)\n         MVC   LHKL1CA#,=X'4020202020202120' CA number edit mask\n         L     R15,DC#CA          this control area number (-1)\n         AL    R15,=F'1'          + 1 since DC#CA is updated at the\n*                                 of a CA processing\n         CVD   R15,D              CONVERT TO DECIMAL\n         ED    LHKL1CA#,D+4       EDIT/convert CA # to printable\n*\n         XC    CASUS,CASUS        RESET THE CA SUS TO ZEROS\n         XC    CAIXRLSL,CAIXRLSL  RESET LAST SS IX RECORD SECTION LEN\n         OI    CAFLAGS,CAFFDRP    set first CA data CI flag\n         L     R1,=A(RPLIX)       RPL address (index read)\n         GETIX RPL=(1)            GET AN INDEX (SS) RECORD\n         LTR   R15,R15            GET SEQUENCE SET RECORD OK..........?\n         BNZ   IXRERROR           NO, INDEX READ ERROR---------------->\n         L     R5,IXCIADDR        LOAD THE ADDRESS OF THE INDEX RECORD\n         USING IXHDR,R5           INDEX RECORD (HEADER) ADDRESSABILITY\n         CLI   IXHLV,X'01'        IS IT A SEQUENCE SET CI.............?\n         BNE   ABEND0             NO, SOMETHING WRONG, ABEND --------->\n* CHECK IF THIS IS SEOF (SOFTWARE END-OF-FILE) CI\n         LH    R14,IXHLL          LENGTH OF INDEX RECORD\n         LA    R15,IXHDR+3(R14)   ADDRESS OF THE CIDF FIELD\n         USING CIDF,R15           CIDF ADDRESSABLITY\n         OC    CIDF(4),CIDF       ALL ZEROS IN CIDF...................?\n         BZ    SEOF               YES, SOFTWARE END-OF-FILE----------->\n* CALCULATE THE VERTICAL POINTER LENGTH AND SAVE IF IN A FULLWORD\n* FOR EASE OF USE LATER ON\n         XR    R1,R1              CLEAR R1\n         IC    R1,IXHFLPLN        INDEX ENTRY CONTROL INFO.LENGTH\n         ST    R1,IXECILEN        SAVE IT IN A FULLWORD FOR EASE OF USE\n         BCTR  R1,0\n         BCTR  R1,0               - 2 = VERTICAL POINTER LENGTH\n         ST    R1,VPLENGTH        VERTICAL POINTER LENGTH\n* CHECK IF THERE ARE ANY UNUSED CI'S IN THE CA AND UPDATE THE\n* CAFSP FREE SPACE VALUE\n         XR    R0,R0              CLEAR R0 (PREPARE FOR A DIVIDE)\n         LH    R1,IXHFSO          OFFSET OF UNUSED SPACE IN THE CI\n         SH    R1,=H'24'          - LENGTH OF THE HEADER\n         BNP   IXCIP2             = 0, NO VERTICAL POINTERS TO FREE CI\n         D     R0,VPLENGTH        FREE CI ENTRIES LEN/VPL=NO.OF FREE CI\n         ST    R1,CA#FCI          KEEP RECORD OF NO.OF FREE CI'S\n         L     R4,DATADSBA        DATA AMDSB ADDRESS\n* AT THIS POINT WE HAVE DATA COMPONENT AMDSB ADDRESS IN R4\n* FOR THIS CA, WE ARE DONE HERE WITH THE CA FREE SPACE (# of free CIs)\nIXCIP2   DS    0H\n* NOW WE WILL CHECK IF THERE IS ANY UNUSED SPACE IN THIS INDEX\n* SEQUENCE SET RECORD\n*              (AMDCIPCA is 2 bytes, CA#FCI is an F)\n         CLC   CA#FCI+2(2),AMDCIPCA IF NO.OF FREE CI'S = NO.OF CI'S/CA\n*                                 IT MEANS THAT THE WHOLE CA IS FREE\n         BL    IXCIP4             NO, FEWER FREE CI'S THAN CI'S/CA\n* ALL CI'S IN THIS CA ARE FREE, IT MEANS THERE AREN'T ANY INDEX ENTRIES\n* (This case likely doesnt happen. An empty CA should have CI/CA - 1\n*  free data CI pointers + an entry for CA high key).\n         LH    R15,IXHLL          SS RECORD LENGTH\n         SH    R15,IXHFSO         - FREE SPACE OFFSET = LENGTH OF FSPC\n         BAL   LNKREG1,IXCIPFSU   Update IX SUS\n         B     IXCIPEX            EXIT PROCESSING FOR THIS CA\n* The common routine/code below is entered via LNKREG1\n* UPDATE THE USED SPACE FOR THE INDEX (SEQUENCE SET)\n*        R15 has this IX CI free space\n* We are doing 8 bytes arithmetic here\n* Update IX CI free space\nIXCIPFSU ST    R15,CAIXRFSP       save THIS IX REC FSPC in work field\n         L     R0,IX#CISS         Update # of IX SS records\n         AL    R0,=F'1'           + 1\n         ST    R0,IX#CISS         Updated\n* Update IX CI free space\n         LM    R0,R1,IXCIFSP      IX (SS) CI free space\n         ALR   R1,R15             + this IX record free space\n         BC    12,IXCIP2F         no carry in add logical\n         AL    R0,=F'1'           Carry: add 1 to HO 4 bytes of FSPC\nIXCIP2F  STM   R0,R1,IXCIFSP      Updated IX (SS) CI free space\n* Update IX CI used space\n         L     R14,CISIZEI        Index CI size\n         SLR   R14,R15            - this IX record free space =\n*                                 this CI used space\n         LM    R0,R1,IXUSPC       IX (SS) CI used space\n         ALR   R1,R14             + this IX record used space\n         BC    12,IXCIP2U         no carry in add logical\n         AL    R0,=F'1'           Carry: add 1 to HO 4 bytes of USPC\nIXCIP2U  STM   R0,R1,IXUSPC       Updated IX (SS) CI used space\n         BR    LNKREG1            return to caller\n* AT THIS POINT WE ARE DONE WITH AN IX SS RECORD AND THE DATA CA\n* CONTROLLED BY THIS SS RECORD\n         SPACE\nIXCIP4   DS    0H\n* THERE ARE INDEX ENTRIES (AND CORRESPONDING DATA CI'S) IN THIS\n* SEQUENCE SET RECORD. WE WILL GO THROUGH ALL INDEX ENTRIES, AND THEN\n* READ AND PROCCESS ALL DATA CI'S.\n* WE WILL PROCESS DATA CI'S IN THE KEY SEQUENCE (INDEX ENTRIES FROM\n* RIGHT TO LEFT).\n* PLEASE NOTE THAT OFFSETS TO INDEX ENTRIES ARE IN FACT OFFSETS TO THE\n* CONTROL INFORMATION IN AN ENTRY.\n*\nIXELEOR  EQU   R11                THIS REGISTER IS DESIGNATED TO HOLD\n*                                 OFFSET OF THE LAST INDEX ENTRY IN\n*                                 THE CURRENTLY PROCESSED SECTION OF\n*                                 THE INDEX RECORD\nIXEOR    EQU   R10                THIS REGISTER WILL HOLD OFFSET OF\n*                                 THE CURRENTLY PROCESSED INDEX ENTRY\n*\n* FIRST WE WILL CALCULATE THE FREE SPACE IN THIS INDEX RECORD\n* AND UPDATE THE IXSUS\n*\n         LH    IXELEOR,IXHLEO     LAST ENTRY OFFSET IN THE INDEX REC.\n         LA    R15,IXHDR(IXELEOR) ADDRESS OF THE CONTROL INFORMATION\n         USING IXECIFMT,R15       CONTROL INFO. DSECT ADDRESSABILITY\n         XR    R1,R1              CLEAR R1\n         IC    R1,IBFLPL          LENGTH OF KEY IN THE LAST ENTRY\n         LR    R15,IXELEOR        LAST ENTRY OFFSET IN THE INDEX REC.\n         SLR   R15,R1             - COMPRESSED KEY LENGTH\n         SH    R15,IXHFSO         - OFFSET OF THE FREE SPACE\n*                                 = FREE SPACE IN THIS IX RECORD\n         BAL   LNKREG1,IXCIPFSU   Update IX SUS\n*\n* NOW WE WILL PROCESS THE INDEX ENTRIES FROM RIGHT (LOWEST KEY) TO\n* THE LEFT (HIGHER KEYS)\n         LH    IXELEOR,IXHSEO     LAST ENTRY OFFSET IN THE FIRST SECT.\n         LH    IXEOR,IXHLL        INDEX RECORD LENGTH\n         SL    IXEOR,IXECILEN     - CONTROL INFO.LENGTH = OFFSET OF\n*                                 THE FIRST ENTRY\n* AT IXCIP5 LABEL WE HAVE AN INDEX ENTRY PROCESSING LOGIC.\n* FOR EACH ENTRY THE \"DCCIP\" SUBROUTINE IS CALLED TO READ AND PROCESS\n* A DATA CI CONTROLLED BY THE INDEX ENTRY.\nIXCIP5   LA    R15,IXHDR(IXEOR)   ADDRESS OF THE CONTROL INFORMATION\n         IC    R14,IXHPTLS        INSERT VERTICAL POINTER INDICATOR\n         XR    R1,R1              CLEAR R1\n         EX    R14,ICMVP          INSERT VERTICAL POINTER INTO R1\n         L     R4,DATADSBA        LOAD DATA AMDSB ADDRESS INTO R4\n         TM    CAFLAGS,EAKSDS     Extended Addressability KSDS .......?\n*  For EF IXHBRBA has CA base relative CI# rather than a \"true\" RBA\n         BNO   IXCIP6             No, we have a \"true\" RBA in IXHBRBA\n*  EF KSDS: CI# = VP + CA base CI#\n         AL    R1,IXHBRBA         VP + CA base (beginning) CI#\nIXCIP6   M     R0,CISIZED         relative CI# * DATA CI SIZE = XRBA\n         STM   R0,R1,DCCIRBAX     save DATA CI XRBA\n         TM    CAFLAGS,EAKSDS     Extended Addressability KSDS .......?\n         BO    IXCIP7             Yes, we have a \"true\" RBA in IXHBRBA\n* non-EF KSDS: RBA = VP * CIsize + CA base RBA\n         AL    R1,IXHBRBA         + CA base (beginning) RBA =\n         ST    R1,DCCIRBA         RBA OF THE DATA CI\nIXCIP7   STM   R2,R15,SAVEA1      SAVE REGISTERS BEFORE CALLING\n* (WE ARE SHORT OF GPR'S HERE)    DATA CI PROCESSING ROUTINE\n         BAL   R14,DCCIP          CALL DATA CI PROCESSING ROUTINE\n         LM    R2,R15,SAVEA1      RESTORE THE REGISTERS\n         XR    R1,R1              CLEAR R1\n         IC    R1,IBFLPL          LENGTH OF THE IXKEY FIELD IN IX ENTRY\n         CLR   IXELEOR,IXEOR      IS THIS THE LAST ENTRY IN THIS SECT.?\n         BNL   IXCIPNS            YES, LAST ENTRY IN THIS SECTION----->\n* WE STILL HAVE MORE ENTRIES IN THIS INDEX SECTION\n         SLR   IXEOR,R1           OFFSET OF CURRENT ENTRY -IXKEY LENGTH\n         SL    IXEOR,IXECILEN     - CONTROL INFO.LENGTH= NEXT HIGHER\n*                                 ENTRY OFFSET\n         B     IXCIP5             PROCESS THE NEXT ENTRY-------------->\n* WE'VE REACHED THE END OF CURRENT INDEX SECTION\nIXCIPNS  DS    0H                 NEW SECTION PROCESSING\n         CH    IXEOR,IXHLEO       IS IT THE LAST ENTRY IN THIS RECORD.?\n         BNH   IXCIPEX            YES, END OF CA PROCESSING----------->\n         SLR   IXEOR,R1           OFFSET OF CURRENT ENTRY -IXKEY LENGTH\n         BCTR  IXEOR,0            ENTRY OFFSET - 2 (LENGTH OF SECTION\n         BCTR  IXEOR,0            CONTROL FIELD)\n         LH    R1,IXHDR(IXEOR)    LOAD THIS SECTION CONTROL FIELD\n         STH   R1,CAIXRLSL        SAVE IT IN THE WORK FIELD\n*                          (USED  LATER FOR IX RECORD SHORT TEST)\n         SLR   IXELEOR,R1         = LAST ENTRY OFFSET IN THE NEXT SECT.\n         SL    IXEOR,IXECILEN     - CONTROL INFO.LENGTH= FIRST ENTRY\n*                                 OFFSET IN THE NEXT SECTION\n         B     IXCIP5             PROCESS THE NEXT ENTRY-------------->\n         SPACE\nICMVP    ICM   R1,X'00',IBFLP3    INSERT VERTICAL POINTER INTO R1\nSAVEA1   DS    16F                INTERNAL REGISTER SAVE AREA\n         SPACE\n* WE'VE GONNE THROUGH THE WHOLE SEQUENCE SET IX RECORD AND READ ALL\n* DATA CI'S UNDER ITS CONTROL (THE CONTROL AREA).\n* NOW WE WILL CHECK IF THIS SS IX RECORD DESCRIBES ALL CI'S IN THIS CA.\n* (EG. IF THERE ARE ANY UNUSED DATA CI'S BECAUSE OF LACK OF SPACE IN\n*  THIS INDEX RECORD).\n* THEN WILL WE WILL PRINT REPORT LINES FOR THIS CONTROL AREA.\nIXCIPEX  DS    0H                 END OF CONTROL AREA PROCESSING\n* THE LOGIC BELOW IS PROBABLY USELESS, BUT DOES NOT DO ANY HARM\n* (NORMALLY, A SS IX RECORD SHOULD ALWAYS ACCOUNT FOR ALL CI'S IN A CA)\n         L     R0,CA#FCI          NO.OF FREE CI'S IN THE CA\n         AL    R0,CA#UCI          + NO.OF USED CI'S = NO.OF DATA CI'S\n*                                 CONTROLLED BY THIS SS RECORD\n         CH    R0,AMDCIPCA        SAME AS NO.OF CI'S PER CA...........?\n         BNL   IXCIPEX1           ANOTHER CHECK FOR SS IX RECORD SHORT>\n* THERE ARE UNUSED CI'S IN THIS CA BECAUSE SEQUENCE SET INDEX RECORD\n* IS TOO SHORT\n         LH    R1,AMDCIPCA        NO.OF CI'S PER CA\n         SLR   R1,R0              - NO.OF CI'S CONTROLLED BY IX SS REC.\n*                                 = NO.OF UNUSED CI'S DUE TO IX RECLEN\n         ST    R1,CA#IXRSC        STORE IT IN THE CA SUS\nIXCIPEX1 L     R1,CA#FCI          ANY FREE CI'S IN THE CA\n         LTR   R1,R1              ?\n         BNP   IXCIPEXR           NO, NO POSSIBILITY OF IX REC SHORT\n*        CAIXRFSP is a fullword, CAIXRLSL is a halfword , since + 2\n         CLC   CAIXRLSL,CAIXRFSP+2  FREE SPACE IS LESS THAN LAST INDEX\n*                                 SECTION LENGTH                      ?\n         BL    IXCIPEXR           NO, ENOUGH OF FREE SPACE FOR ANOTHER\n*                                 INDEX SECTION\n* WE ARE ASSUMING THAT ALL THESE FREE CI'S ARE DUE TO INDEX RECORD\n* BEING TOO SHORT SINCE THERE IS NO FREE SPACE TO CREATE ANOTHER\n* SECTION OF THE INDEX (WE ARE WORKING WITH SS IX RECORD HERE)\n         AL    R1,CA#IXRSC        UPDATE THE IX rec short # of CIs\n         ST    R1,CA#IXRSC        STORE IT IN THE CA SUS\n* All free CIs are assumed to be due to IX record short\n* We need to nullify CA#FCI\n         XC    CA#FCI,CA#FCI      clear CA FSPC # of CIs\n* WE ARE GOING TO PRINT THE REPORT LINES FOR THE CA HERE\nIXCIPEXR DS    0H\n         STM   R2,R11,SAVEA1      SAVE REGISTERS (2 TO THE LAST BASE)\n         MVC   CISIZE,CISIZED     DATA COMPONENT CISIZE\n         BAL   R14,CARPTT         RPTT CA REPORT LINE(S)\n         BAL   R14,CARPTG         RPTG CA REPORT LINE(S)\n* Print HIGH key line in LHKR report\n         MVC   EMPTYCAS,LHKL1     save the record length\n         TM    CAFLAGS,LHKFOUND   a key/data record found in this CA..?\n         BO    IXCIPXR1           Yes, print it ---------------------->\n* We seem to have an empty CA (no data records) here\n         MVC   LHKL1KEY(L'EMPTYCA),EMPTYCA Empty CA message/text\n         LA    R10,(LHKL1KEY-LHKL1)+L'EMPTYCA this message length\n         STH   R10,LHKL1          store in record header\nIXCIPXR1 LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         NI    CAFLAGS,X'FF'-LHKFOUND Reset a key found in CA flag\n         MVC   LHKL1(2),EMPTYCAS  restore the record length\n         LM    R2,R11,SAVEA1      RESTORE REGISTERS\n         L     R4,INDXDSBA        RELOAD THE INDEX AMDSB ADDRESS\n*                                 (IT HAS TO BE AT THE IXCIPROC LABEL)\n         XR    R0,R0              clear R0\n         L     R1,IXHHP           RBA OF THE NEXT SEQUENCE SET RECORD\n         TM    CAFLAGS,EAKSDS     Extended Addressability KSDS .......?\n*  For EF: HP  has relative IX SS CI# rather than a \"true\" RBA\n         BNO   IXCIPXRB           No, we have a \"true\" RBA in IXHBRBA\n         M     R0,CISIZEI         relative CI# * IX CI SIZE = XRBA\nIXCIPXRB STM   R0,R1,IXCIRBAX     XRBA OF THE NEXT SEQUENCE SET RECORD\n         LA    R0,1               UPDATE THE NUMBER OF CA'S PROCESSED\n         AL    R0,DC#CA           NO.OF CA'S + 1\n         ST    R0,DC#CA           UPDATED\n* UPDATE THE DATA COMPONENT SPACE UTILIZATION SUMMARY\n* BY ADDING VALUES FROM THE CURRENT CONTROL AREA\n* 8 bytes binary counts are used for data component byte count totals\n         LA    R15,1              In case of carry: put 1 in R15\n* Data component used space\n         LM    R0,R1,DCUSPC       DC used space (8 bytes count)\n         AL    R0,CAUSPC          + CA used space (HO part)\n*                        (We assume no overflow in HO part)\n         AL    R1,CAUSPC+4        + CA used space (LO part)\n         BC    12,IXCIDCS1        no carry in add logical\n         ALR   R0,R15             Carry: add 1 to HO 4 bytes\nIXCIDCS1 STM   R0,R1,DCUSPC       Updated Data Comp. used space/bytes\n* Data component CI free space\n         LM    R0,R1,DCCIFSP      DC CI free space (8 bytes count)\n         AL    R0,CACIFSP         + CA CI free space (HO part)\n*                        (We assume no overflow in HO part)\n         AL    R1,CACIFSP+4       + CA CI free space (LO part)\n         BC    12,IXCIDCS2        no carry in add logical\n         ALR   R0,R15             Carry: add 1 to HO 4 bytes\nIXCIDCS2 STM   R0,R1,DCCIFSP      Updated DComp. CI free space/bytes\n* Data component # of used CIs\n         L     R0,DC#UCI          DC # of used CIs\n         AL    R0,CA#UCI          + current CA used CI count\n         ST    R0,DC#UCI          Updated DC used CI count\n* Data component CA free space # of free CIs\n         L     R0,DC#CAFCI        CA free space # of free CIs\n         AL    R0,CA#FCI          + current CA free CI count\n         ST    R0,DC#CAFCI        Updated DC CA freespce CI count\n* Data component unused CI's due to IX CI short\n         L     R0,DC#IXRSC        IX rec short  # of free CIs\n         AL    R0,CA#IXRSC        + current CA IX short free CIs\n         ST    R0,DC#IXRSC        Updated DC IX short free CI count\n* We are done Data Component SUS update here\n         OC    IXCIRBAX(8),IXCIRBAX      RBA OF NEXT SS RECORD = 0....?\n         BZ    SEOF               YES,END-OF-FILE,LAST SS CI PROCESSED>\n         B     IXCIPROC           PROCESS NEXT SS RECORD AND DATA CA\n         SPACE\n* SOFTWARE END-OF-FILE RECORD FOUND IN THE SEQUENCE SET\n* OR, LAST PROCESSED SS RECORD HORIZONTAL POINTER WAS 0 (EOF)\nSEOF     DS    0H\n* WE NEED TO CHECK IF THERE ARE ANY CA'S ALLOCATED AFTER THE LAST\n* PROCESSED.\n* LET'S CALCULATE HOW MANY CA'S AFTER EOF ARE UNUSED.\n* (WE HAVE TO FIND ARDB WITH THE HIGHEST DATA RBA: THIS ARDB CONTAINS\n*  THE HIGEST ALLOCATED RBA)\n         L     R4,DATADSBA        RELOAD THE DATA AMDSB ADDRESS\n         L     R15,AMDPARDB       LOAD ARDB ADDRESS\n         USING ARDB,R15           ARDB ADDRESSABILITY\n*  RBA MEANS # OF CI'S (DFSMS 1.3 AND UP)\n         L     R1,ARDERBA         HIGHEST RBA ALLOCATED IN DATA COMP.\n         SL    R1,ARDHRBA         - FIRST FREE CI RBA AT THE EOF\n         LTR   R1,R1              ANY FREE SPACE AFTER EOF............?\n         BZ    SEOF1              NO FREE CA'S AFTER EOF-------------->\n         LH    R14,AMDCIPCA       NO.OF CI'S PER CONTROL AREA\n         XR    R0,R0              PREPARE FOR DIVIDE ( R0=0 )\n         DR    R0,R14             FREE CI'S / CI PER CA = # FREE CA'S\n         ST    R1,DC#CAFR         NO.OF FREE CA'S AT THE END OF DATASET\n         DROP  R15\nSEOF1    DS    0H                 PRINT SUMMARY FOR DATA AND INDEX\n         BAL   R14,DCSUSPR        PRINT SUS FOR DATA COMPONENT\n         BAL   R14,IXSUSPR        PRINT SUS FOR INDEX COMPONENT\n         B     CLOSE              CLOSE VSAM ACB AND REPORTS' DCB'S\n* HERE IS THE END OF THE MAINLINE PROCESSING LOGIC. THE FOLLOWING ARE\n* VARIOUS PROCEDURES CALLED FROM THE MAINLINE.\n         SPACE\n*---------------------------------------------------------------------*\n* DATA CI PROCESSING ROUTINE                                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDCCIP    SUBENT\n* This code ensures that there are no idle data CI reads\n* (checks if we are positioned correctly, will however do an\n* unnecessary POINT for the first read of the data component CI)\n* Also, this prevents EODAD error if by a chance the last CI read\n* was the last CI of the data component.\n         LM    R0,R1,DCCIRBAR     XRBA of the last read data CI\n         AL    R1,CISIZED         + CI size = RBA of next to be read CI\n         BC    12,DCCIP0          no carry in add logical\n         AL    R0,=F'1'           Carry: add 1 to HO 4 bytes of XRBA\nDCCIP0   C     R0,DCCIRBAX        Next CI RBA = required RBA LO bytes.?\n         BNE   DCCIPP             No, position/POINT first------------>\n         C     R1,DCCIRBA         Next CI RBA = required RBA HO bytes.?\n         BNE   DCCIPP             No, position/POINT first------------>\nDCCIPG   L     R1,=A(RPLDC)       RPL address (data CI read)\n         GET   RPL=(1)            GET A DATA COMPONENT CI\n         LTR   R15,R15            GET DATA CI OK......................?\n         BNZ   DCIRERR            NO, DATA CI READ ERROR-------------->\n         SHOWCB RPL=RPLDC,        GET THE RBA OF JUST READ DATA CI     +\n               AREA=DCCIRBAR,     CURRENTLY READ CI RBA                +\n               LENGTH=8,                                               +\n               FIELDS=(XRBA)      XRBA WILL BE SHOWN\n         CLC   DCCIRBAR(8),DCCIRBAX  SAME READ AS REQUIRED FROM IX REC?\n         BE    DCCIP1             YES, W'VE GOT THE RIGHT DATA CI----->\n* NEXT SEQUENTIALLY READ DATA CI ISN'T THE RIGHT ONE. WE HAVE TO ISSUE\n* A POINT MACRO AND REREAD THE DATA CI\nDCCIPP   MODCB RPL=RPLDC,         MOVE ARGUMENT ADDRESS INTO RPL       +\n               ARG=DCCIRBAX       XRBA OF THE REQUIRED DATA CI\n         L     R1,=A(RPLDC)       RPL address (data CI read)\n         POINT RPL=(1)            POINT ON REQUIRED DATA CI\n         LTR   R15,R15            POINT OK............................?\n         BNZ   POINTERR           NO, ERROR--------------------------->\n         B     DCCIPG             GET THE REQUIRED DATA CI------------>\nDCCIP1   L     R2,DCCIADDR        ADDRESS OF THE CI IN A BUFFER\n         LM    R0,R1,DCCIRBAR     This data CI RBA\n         OC    DCCIRBAR(8),DCCIRBAR      RBA = 0......................?\n         BZ    DCCIP10            Yes, DIVIDE not required/invalid---->\n         D     R0,CISIZED         / DATA CIsize = relative CI#\nDCCIP10  CVD   R1,D               Convert to decimal\n         MVC   LHKL1CI#,=X'402020202020202020202120'\n         ED    LHKL1CI#,D+2       EDIT/convert CI# to printable\n* WE EXPECT DATA AMDSB ADDRESS TO BE IN R4\n* Register use:\n* R2  CI   address\n* R3  CIDF address\n* R4  AMDSB address\n* R3  1st/right RDF  address (if there is a pair)\nCIDFR    EQU   R3                 CIDF address register\nRDFR     EQU   R3                 RDF address register\n         USING AMDSB,R4           AMBSB ADDRESSABLITY\n         L     R15,CISIZED        DATA CI SIZE\n         LR    CIDFR,R15\n         SL    CIDFR,=F'4'        DATA CI SIZE - 4 = CIDF OFFSET\n         LA    CIDFR,0(R2,CIDFR)  CIDF ADDRESS\n         USING CIDF,CIDFR         CIDF  ADDRESSABLITY\n         ICM   R0,B'0011',CIDF11  LOAD LENGTH OF UNUSED SPACE INTO R0\n         SLL   R0,17              CLEAR THE CI BUSY BIT\n         SRL   R0,17\n         SLR   R15,R0             CI SIZE - UNSUED SPACE = USED SPACE\n* We need to 8 bytes arithmetic here: R15 used bytes, R0 - free bytes\n         AL    R15,CAUSPC+4       CA USED SPACE - LO 4 bytes\n         ST    R15,CAUSPC+4\n         BC    12,DCCIPFS         no carry in add logical\n         LA    R15,1              Carry: add 1 to HO 4 bytes\n         AL    R15,CAUSPC         CA USED SPACE - HO 4 bytes\n         ST    R15,CAUSPC         Update HO 4 bytes of count\nDCCIPFS  AL    R0,CACIFSP+4       UPDATE  CI FREE SPACE\n         ST    R0,CACIFSP+4       LO 4 bytes\n         BC    12,DCCIPFS1        no carry in add logical\n         LA    R0,1               Carry: add 1 to HO 4 bytes\n         AL    R0,CACIFSP         CA free SPACE - HO 4 bytes\n         ST    R0,CACIFSP         Update HO 4 bytes of count\nDCCIPFS1 LA    R0,1               UPDATED NO.OF USED DATA CI'S\n         AL    R0,CA#UCI          (+ 1)\n         ST    R0,CA#UCI\n* At this point we will be extracting keys from data records\n* in order to find LOW/HIGH keys in this data area\n         ICM   R1,B'0011',CIDFOSET LENGTH OF data records in this CI\n         SLL   R1,17              CLEAR THE CI BUSY BIT\n         SRL   R1,17\n         LTR   R1,R1              No data records (a free CI).........?\n*                                 (this should not happen, we check\n*                                  just in case)\n         BZ    DCCIPEX            empty CI, exit DCCIP\n*        CI address + lenght of data records = free space address\n         LA    R1,0(R2,R1)        Free space address in thi CI\n         ST    R1,DCCIPFSP        Save it for later checking if we\n*                                 went through all data records\n* (in case of spanned records this is somewhat simpler: after last\n*  or intermediate segment - there should not be any more records in\n*  this data CI).\n*\n* In case of a spanned record file - we have to find the first segment\n* (or the whole first record in this CI)\n* R2 points to a record or segment\n* We will proceed form left to right (in the CI) and extract key from\n* every record.\n* For the first record found - if this is the first CI in the CA\n* (CAFFDRP flag is on) - will write the LOW key line.\n* At the end of CA processing - will write the last/HIGH key line.\n* At this point RDFR points to CIDF\n         SH    RDFR,=H'6'         - 6 = left RDF address (if paired,\n*                                 if any)\n* ( we are getting view of left and right RDF even though there can\n*   be only the right one)\n         USING RDF,RDFR           RDF addressability\nDCCIPRP  TM    RRDFF,RRDFFS+RRDFLS a spanned record ..................?\n         BZ    DCCIPF             No, a fixed length record ---------->\n* We seem to have a spanned record here\n         TM    RRDFF,RRDFFS+RRDFLS intermediate segment...............?\n         BO    DCCIPEX            Yes, no more segments in this CI\n         TM    RRDFF,RRDFLS       last segment         ...............?\n* (in case of spanned records CI with last or intermediate segment\n*  cannot contain any other records)\n         BO    DCCIPEX            Yes, no more segments in this CI\n* We seem to have the first segment of a spanned record here\n         BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         TM    CAFLAGS,CAFFDRP    first data CI in this CA ...........?\n         BNO   DCCIPEX            No, Exit this CI processing--------->\n         LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* We printed the LOW key, let's reset the CAFFDRP flag\n         NI    CAFLAGS,X'FF'-CAFFDRP reset first CA data record flag\n         B     DCCIPEX            Exit this CI processing\n*                                 (a spanned segment should always be\n*                                 the last record in a data CI)\n         SPACE\n* We have a fixed record in this CI (pointed by R2)\nDCCIPF   TM    CAFLAGS,CAFFDRP    first data CI in this CA ...........?\n         BNO   DCCIPF1            No, Exit this CI processing--------->\n         BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         MVI   LHKL1CA#,X'40'     Ensure next line is single spaced\n* We printed the LOW key, let's reset the CAFFDRP flag\n         NI    CAFLAGS,X'FF'-CAFFDRP reset first CA data record flag\nDCCIPF1  TM    RRDFF,RRDFP        is it a paired RDF..................?\n         BO    DCCIPFP            Yes, paired RDF, get last rec   ---->\n* Just single record, extract key, position on next record\nDCCIPF2  BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         AH    R2,RRDF#           Next record address in the CI\n         C     R2,DCCIPFSP        = free space address ...............?\n         BNL   DCCIPEX            yes, we are done with this CI ------>\n* Since we have un-paired RDF, we need to decrement by 3 to get next\n         SH    RDFR,=H'3'         - 3 = next RDF address\n         B     DCCIPRP            Look at the next RDF/ data record\n* Multiple fixed length records described by paired RDF\nDCCIPFP  LH    R15,LRDF#          number of records described by this\n*                                 paired RDF\n         BCTR  R15,0              - 1\n         MH    R15,RRDF#          * record length = offste of last rec\n         LA    R2,0(R2,R15)       last record address\n         BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         AH    R2,RRDF#           Next record address in the CI\n         C     R2,DCCIPFSP        = free space address ...............?\n         BNL   DCCIPEX            yes, we are done with this CI ------>\n* In case of a paired RDF we need to subtract 6 bytes to position at\n* next RDF pair (if any).\n         SH    RDFR,=H'6'         - 6 = next RDF address\n         B     DCCIPRP            Look at the next RDF/ data record\n         DROP  CIDFR              Drop addressability of CIDF\n*        DROP  RDFR               Drop addressability of RDF\nDCCIPEX  SUBRET DCCIP             RETURN TO CALLER\nMVCKEY   MVC   LHKL1KEY(1),0(R15) move record key to LHKL1KEY\n* Extract key from this data record (pointed by R2)\nDCCIPEK  OI    CAFLAGS,LHKFOUND   We found a key/data record in this CA\n         LH    R15,AMDRKP         RELATIVE KEY POSITION\n         LH    R1,AMDKEYLN        KEY LENGTH\n         BCTR  R1,0               KEY LENGTH - 1\n         LA    R15,0(R2,R15)      Key address in the first record\n         EX    R1,MVCKEY          move load key to LHKL1KEY\n*********test***************************\n*        LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n*        LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n*        ST    R9,DCCIPR2S        save R2 ******* test ***************\n*        BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n*        L     R9,DCCIPR2S        restore R2 ******* test ***********\n*********test***************************\n         BR    LNKREG1            Return to caller\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT REPORT LINE FOR A CONTROL AREA - GRAPHICAL FORMAT             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCARPTG   SUBENT\n         LA    R6,CASUS           CONTROL AREA SUS ADDRESS\n         BAL   R14,RPTGSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET CARPTG            RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT REPORT LINE FOR A CONTROL AREA - TABLE FORMAT                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCARPTT   SUBENT\n         LA    R6,CASUS           CONTROL AREA SUS ADDRESS\n         BAL   R14,RPTTSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET CARPTT            RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT THE SPACE DISTRIBUTION LINE - GRAPHICAL FORMAT                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*\n* Round byte count to 1KiB if total > 4GiB\n* R0/R1 has 8 bytes count\nRPPGRKiB TM    CAFLAGS,GT4GiB     Is rounding required ...............?\n         BNOR  R14                No, return\n         D     R0,=F'1024'        Round to 1KiB\n         C     R0,=F'512'         If reminder >  512 will add 1 to\n*                                 the result\n         BNHR  R14                reminder <= 512  return\n         AL    R1,=F'1'           reminder >  512  add 1 to result\n         BR    R14                Return\n*\nRPTGSDL  SUBENT\n* R6 HAS THE SPACE UTILIZATION SUMMARY ADDRESS ( SUS )\n         USING SUS,R6             SUS ADDRESSABILITY\n         L     R15,SUSTOTB        LOAD total bytes or KiB saved by\n*                                 RPTTSDL\n* R15 HAS NOW TOTAL SPACE IN BYTES\n         LR    R11,R15            SAVE TOTAL SPACE IN THE R11\n         XR    R14,R14            CLEAR R14 (PREPARE FOR DIVIDE)\n         LA    R10,L'RPTGL1A      SPACE DISTRIBUTION AREA LENGTH\n         DR    R14,R10            TOTAL SPACE/PRINT LINE LENGTH\n* R15 (QUOTIENT) HAS NO.OF BYTES PER ONE CHARACTER OF THE PRINT LINE\n         LR    R8,R15             NO.OF BYTES PER ONE PRINT POSITION\n         SRL   R8,1               DIVIDE BY 2\n         LA    R9,RPTGL1A         ADDRESS OF THE AREA IN THE PRINT\n*                                 RECORD\n         MVI   RPTGL1C,C' '       ONE LINE SPACING\n         MVI   RPTGL1A,C' '       FILL PRINT AREA WITH BLANKS\n         MVC   RPTGL1A+1(L'RPTGL1A-1),RPTGL1A\n* USED SPACE PROCESSING: IT WILL BE REPRESENTED BY * CHARACTERS\n* ON THE PRINTOUT\n         LM    R0,R1,USPC         Used space\n         BAL   R14,RPPGRKiB       Round to KiB is required\n         LTR   R1,R1              IS THERE ANY USED SPACE.............?\n         BNP   RPTGSDLB           NO, CHECK CA FREE SPACE------------->\n* USED SPACE IS  IN R1\n         IC    R7,USPCID          CHARACTER REPRESENTING USED SPACE\n*                                 INTO R7\n         BAL   R14,RPTGSDP        CONVERT USED SPACE INTO * CHARS\n*                                 IN THE PRINT LINE\n* CI FREE SPACE PROCESSING: IT WILL BE REPRESENTED BY - CHARACTERS\n* ON THE PRINTOUT\nRPTGSDLB LM    R0,R1,CIFSP        CI free space\n         BAL   R14,RPPGRKiB       Round to KiB if required\n         LTR   R1,R1              IS THERE ANY CI FREE SPACE..........?\n         BNP   RPTGSDLC           NO, CHECK IX REC.SHORT FREE SPC----->\n         IC    R7,CIFSPCID        CHARACTER REPRESENTING CI FREE SPACE\n*                                 INTO R7\n         BAL   R14,RPTGSDP        CONVERT CI FREE SPACE INTO - CHARS\n*                                 ON THE PRINT LINE\n* CA FREE SPACE PROCESSING: IT WILL BE REPRESENTED BY + CHARACTERS\n* ON THE PRINTOUT\nRPTGSDLC L     R1,CAFSPCI#        # of CA free space CIs\n         LTR   R1,R1              IS THERE ANY CA FREE SPACE..........?\n         BNP   RPTGSDLD           NO, CHECK CI FREE SPACE------------->\n         M     R0,CISIZE          * CISIZE = # of bytes\n         BAL   R14,RPPGRKiB       Round to KiB if required\n         LTR   R1,R1              any free space after rounding ......?\n         BNP   RPTGSDLD           NO, CHECK CI FREE SPACE------------->\n         IC    R7,CAFSPCID        CHARACTER REPRESENTING CA FREE SPACE\n*                                 INTO R7\n         BAL   R14,RPTGSDP        CONVERT CA FREE SPACE INTO + CHARS\n*                                 IN THE PRINT LINE\n* CA FREE SPACE RESULTING FROM IX RECORD BEING TOO SHORT - IT WILL BE\n* REPRESENTED BY X CHARACTERS ON THE PRINTOUT\nRPTGSDLD L     R1,IX#SFCI         # of UNUSED CI'S due to IX CI SHORT\n         LTR   R1,R1              IS THERE ANY IX REC.SHORT FSPC......?\n         BNP   RPTGSDLP           NO, PRINT THE LINE OF THE RPTG------>\n         M     R0,CISIZE          * CISIZE = # of bytes\n         BAL   R14,RPPGRKiB       Round to KiB if required\n         LTR   R1,R1              any free space after rounding ......?\n         BNP   RPTGSDLP           NO, PRINT THE LINE OF THE RPTG------>\n         IC    R7,IXSFSPID        CHARACTER REPRESENTING IX RECORD\n*                                 SHORT CAUSED FREE SPACE INTO R7\n         BAL   R14,RPTGSDP        CONVERT IX REC.SHORT FSPC INTO X\n*                                 CHARS ON THE PRINT LINE\n* PRINT THE SPACE DISTRIBUTION REPRESENTATION ON RPTG\nRPTGSDLP LA    R11,RPTGL1         ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         SUBRET RPTGSDL           RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* THIS PROC FILLS THE RPTG PRINT LINE WITH REQUESTED CHARACTERS       *\n* REPRESENTING KSDS FILE SPACE DISTRIBUTION (CA IN PARTICULAR)        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTGSDP  SUBENT\n* REGISTER CONTENTS:\n* R1 - SPACE IN BYTES TO BE REPRESENTED BY SPECIFIED CHARS\n* R7 - CHARACTER REPRESENTIG GIVEN SPACE ON THE PRINT LINE (L/O BYTE)\n* R9 - ADDRESS OF AREA TO BE FILLED WITH THE ABOVE CHARACTERS\n* R10- LENGTH OF THE ABOVE AREA\n* R15- NO.OF BYTES REPRESENTED BY ONE PRINT LINE POSITION\n* R8 - CONTENTS OF R15 DIVIDED BY TWO (2)\n         XR    R4,R4              CLEAR R4 (PREPARE FOR DIVIDE)\n         LR    R5,R1              USED SPACE IN BYTES\n         DR    R4,R15             DIVIDE BY NO.OF CHARS/PRINT POSITION\n         CLR   R4,R8              REMAINDER >= HALF OF R15............?\n         BL    RPTGSDP1           NO, FILL PRINT AREA WITH CHARS------>\n         LA    R5,1(,R5)          YES, ONE POSITION EXTRA\nRPTGSDP1 LTR   R5,R5              ANY POSITIONS TO BE FILLED..........?\n         BNP   RPTGSDPE           NO, EXIT---------------------------->\n         CLR   R5,R10             # OF POSITION > AREA LENGTH.........?\n         BNH   RPTGSDP2           NO, WE ARE OK\n         LR    R5,R10             YES,CHANGE IT TO NO.OF POSITIONS LEFT\nRPTGSDP2 LR    R0,R5              SAVE NO.OF POSITIONS FILLED IN R0\n         STC   R7,0(,R9)          STORE SPECIFIED CHAR IN THE OUTAREA\n         SH    R5,=H'2'           NO.OF POSITIONS FILLED - 2\n         BM    RPTGSDP3           ONLY ONE CHARACTER WAS REQUIRED----->\n         EX    R5,MVCRPTG         FILL THE ARE WITH REQUIRED # OF CHARS\nRPTGSDP3 ALR   R9,R0              NEXT AVAILABLE BYTE ADDRESS IN THE\n*                                 PRINT AREA\n         SR    R10,R0             NO.OF CHARS LEFT IN THE PRINT AREA\n         BNP   RPTGSDLP           NONE LEFT, BYPASS ANY LEFT SPACE\n*                                 DISTRIBUTION COMPONENTS PROCESSING\nRPTGSDPE SUBRET RPTGSDP           RETURN TO CALLER\n         SPACE\nMVCRPTG  MVC   1(1,R9),0(R9) MOVE SPACE ID CHARACTERS INTO PRINT AREA\n         SPACE\n*---------------------------------------------------------------------*\n* REPORT PRINT PROCEDURE                                              *\n* REGISTERS CONTENTS AT ENTRY:                                        *\n* R11 HAS ADDRESS OF THE V FROMAT RECORD TO BE PRINTED                *\n* R10 HAS ADDRESS OF THE REPORT DEFINITION BLOCK                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTPP    SUBENT\n         USING RPTDB,R10          RPTDB ADDRESSABILITY\n* CHECK IF REPORT DCB IS OPEN\n         L     R9,RPTDCBA         REPORT DCB ADDRESS INTO R9\n         TM    48(R9),DCBOFOPN    IS REPORT FILE OPENED...............?\n         BO    RPTPPA             YES, ALREADY OPENED    ------------->\n         OPEN  ((9),(OUTPUT))\n         TM    48(R9),DCBOFOPN    OPEN SUCCESSFUL        .............?\n         BNO   RPTOPNER           NO, OPEN ERROR         ------------->\n* CHECK NUMBER OF LINES RESULTING FROM ANSI PRINT CONTROL CHARACTER\nRPTPPA   CLI   4(R11),C'+'        PRINT IN THE SAME LINE..............?\n         BE    RPTPP0             YES--------------------------------->\n         CLI   4(R11),C' '        ONE LINE SPACING....................?\n         BE    RPTPP1             YES--------------------------------->\n         CLI   4(R11),C'0'        TWO LINES SPACING...................?\n         BE    RPTPP2             YES--------------------------------->\n         CLI   4(R11),C'-'        THREE LINES SPACING.................?\n         BE    RPTPP3             YES--------------------------------->\n         MVI   4(R11),C' '        INVALID PRINT CNTRL CHAR, CHANGE IT\n         B     RPTPP1             TO BLANK (1 LINE SPACING)\nRPTPP0   SLR   R0,R0              SAME LINE PRINTING\n         B     RPTPPB             CHECK LINE COUNT-------------------->\nRPTPP1   LA    R0,1               ONE LINE SPACING\n         B     RPTPPB             CHECK LINE COUNT-------------------->\nRPTPP2   LA    R0,2               TWO LINES SPACING\n         B     RPTPPB             CHECK LINE COUNT-------------------->\nRPTPP3   LA    R0,3               THREE LINES SPACING\nRPTPPB   AL    R0,RPTLCNT         NEW LINE COUNT\n         CL    R0,RPTLPL          FITS ON CURRENT PAGE................?\n         BH    RPTPPN             NO, WE NEED TO START A NEW PAGE----->\n         ST    R0,RPTLCNT         YES, NEW PAGE COUNT\n         LR    R0,R11             PRINT LINE ADDRESS INTO R0\n         L     R1,RPTDCBA         REPORT DCB ADDRESS INTO R1\n         PUT   (1),(0)            PRINT THE REPORT LINE\n         SUBRET RPTPP\n         SPACE\nRPTPPN   BAL   R14,RPTNP          NEW PAGE OF THE REPORT PROC\n         MVI   4(R11),C'0'        TWO LINES SPACING AFTER NEW PAGE\n         B     RPTPP2             PRINT THE LINE ON NEW PAGE\n         SPACE\n*---------------------------------------------------------------------*\n* REPORT HEADER LINE PRINT PROCEDURE                                  *\n* REGISTERS CONTENTS AT ENTRY:                                        *\n* R10 HAS ADDRESS OF THE REPORT DEFINITION BLOCK                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTNP    SUBENT\n         MVC   RPTHDRP,=X'402020202120' EDIT MASK INTO HEADER LINE\n         L     R14,RPTPGN         LOAD PAGE NUMBER\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    RPTHDRP,D+5        EDIT THE PAGE NUMBER\n         LA    R14,1(,R14)        PAGE NUMBER + 1\n         ST    R14,RPTPGN         NEXT PAGE NUMBER\n         MVI   RPTHDRT,C' '       BALNK OUT THE HEADER LINE TEXT\n         MVC   RPTHDRT+1(L'RPTHDRT-1),RPTHDRT\n         L     R14,RPTHTA         REPORT HERADER TEXT ADDRESS\n         XR    R1,R1              CLEAR R1\n         IC    R1,0(,R14)         REPORT HEADER TEXT LENGTH\n         LA    R0,L'RPTHDRT       MAX.HEADER TEXT LENGTH\n         CLR   R1,R0              HEADER TEXT DOES NOT EXCEED MAX.....?\n         BNH   RPTNP1             NO, MOVE IT INTO HEADER LINE\n         LR    R1,R0              TEXT TOO LONG, TRUNCATE TO MAXLEN\nRPTNP1   BCTR  R1,0               TEXT LENGTH - 1 (FOR EXECUTE)\n         EX    R1,MVCHDRT         MOVE TEXT INTO HEADER LINE\n         L     R1,RPTDCBA         REPORT DCB ADDRESS INTO R1\n         PUT   (1),RPTHDR         PRINT THE HEADER LINE\n         LA    R1,1               NEW PAGE LINE COUNT\n         ST    R1,RPTLCNT\n* CHECK IF THERE IS A SECOND HEADER LINE TO BE PRINTED\n         L     R0,RPTHTA1         SECOND HEADER LINE ADDRESS\n         LTR   R0,R0              = 0 ................................?\n         BZ    RPTNPR             YES, NO SECOND LINE TO BE PRINTED--->\n         L     R1,RPTDCBA         REPORT DCB ADDRESS INTO R1\n         PUT   (1),(0)            PRINT THE SECOND HEADER LINE\n         L     R1,RPTLCNT\n* WE ARE ASSUMING THE SECOND HEADER LINE HAS ALWAYS '0' CTL CHAR\n         LA    R1,2(,R1)          NEW PAGE LINE COUNT + 2\n         ST    R1,RPTLCNT\nRPTNPR   SUBRET RPTNP             RETURN TO CALLER\n         SPACE\nMVCHDRT  MVC   RPTHDRT(1),1(R14)  MOVE TEXT INTO HEADER LINE\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT SUMMARY REPORTS FOR THE WHOLE DATA COMPONENT                  *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDCSUSPR  SUBENT\n* SUMMARY LINE 1\n         MVI   DCSL1C,C'-'        3 LINES SPACING\n         LA    R11,DCSL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* SUMMARY LINE 2\n         MVC   DCSL2N,=X'4020202020202120' EDIT MASK INTO SUMMARY LINE2\n         L     R14,DC#CA          NUMBER OF PROCESSED CA'S\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    DCSL2N,D+4         EDIT THE NUMBER OF CA'S\n         MVI   DCSL2C,C'0'        2 LINES SPACING\n         LA    R11,DCSL2          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* SUMMARY LINE 3\n         MVC   DCSL3N,=X'4020202020202120' EDIT MASK INTO SUMMARY LINE3\n         L     R14,DC#CAFR        NUMBER OF FREE CA'S AT EOF\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    DCSL3N,D+4         EDIT THE NUMBER OF FREE CA'S\n         MVI   DCSL3C,C'0'        2 LINES SPACING\n         LA    R11,DCSL3          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         BAL   R14,BLANKL         PRINT A BLANK LINE ON BOTH REPORTS\n* SUMMARY LINE 3 (SPACE DISTRIBUTION)\n         LA    R6,DCSUS           DATA COMPONENT SUS ADDRESS\n         MVC   CISIZE,CISIZED     DATA COMPONENT CISIZE\n         BAL   R14,RPTTSDL        PRINT THE SPACE DISTRIBUTION LINE\n         BAL   R14,RPTGSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET DCSUSPR           RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT SUMMARY REPORTS FOR THE WHOLE INDEX COMPONENT                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nIXSUSPR  SUBENT\n* SUMMARY LINE 1\n         MVI   IXSL1C,C'-'        3 LINES SPACING\n         LA    R11,IXSL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         BAL   R14,BLANKL         PRINT A BLANK LINE\n* SUMMARY LINE 2 (SPACE DISTRIBUTION)\n         LA    R6,IXSUS           INDEX COMPONENT SUS ADDRESS\n         MVC   CISIZE,CISIZEI     INDEX COMPONENT CISIZE\n         BAL   R14,RPTTSDL        PRINT THE SPACE DISTRIBUTION LINE\n         BAL   R14,RPTGSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET IXSUSPR           RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT DATA AND/OR INDEX COMPONENT STATISTICS                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRNTSTAT SUBENT\n         USING AMB,R3             AMB ADDRESSABILITY\n* STATISTICS LINE 1\n         MVI   STL1C,C'-'         3 LINES SPACING\n         MVC   STL1N,AMBDSNM      COMPONENT'S NAME\n         LA    R11,STL1           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n* PREVENT PRINTING OF SECOND HEADER LINE ON FIRST PAGE OF RPTT\n         MVC   RPTGHTA1,RPTTHTA1  SAVE 2ND HDR LINE ADDRESS (IN RPTGDB)\n         XC    RPTTHTA1,RPTTHTA1  CLEAR 2ND HDR ADDRESS (NO PRINT)\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         MVC   RPTTHTA1,RPTGHTA1  REST 2ND HDR LINE ADDRESS\n         XC    RPTGHTA1,RPTGHTA1  CLEAR 2ND HDR ADDRESS (NO PRINT)\n* STATISTICS LINE 2\n         MVC   STL2CI,=X'6020202020202120' EDIT MASK (CI SIZE)\n         L     R14,AMDCINV        CI SIZE\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CI,D+4         EDIT THE CI SIZE\n         MVC   STL2CICA,=X'6020202020202120' EDIT MASK (CI/CA)\n         LH    R14,AMDCIPCA       NO.OF CI'S PER CA\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CICA,D+4       EDIT THE CI/CA\n         XR    R14,R14            CLEAR R14 (BEFORE IC)\n         IC    R14,AMDPCTCI       % OF FREE BYTES IN A CI\n         CVD   R14,D              CONVERT TO DECIMAL\n         MVC   STL2FSCI,=X'602020202120' EDIT MASK (%CI FREESPACE)\n         ED    STL2FSCI,D+5       EDIT THE FREESPACE-%CI\n         IC    R14,AMDPCTCA       % OF FREE CI'S IN THE CA\n         CVD   R14,D              CONVERT TO DECIMAL\n         MVC   STL2FSCA,=X'602020202120' EDIT MASK (%CA FREESPACE)\n         ED    STL2FSCA,D+5       EDIT THE FREESPACE-%CA\n         MVC   STL2CISP,=X'6020202020202120' EDIT MASK (SPLITS-CI)\n         L     R14,AMDNCIS        NO.OF CI SPLITS\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CISP,D+4       EDIT THE SPLITS-CI\n         MVC   STL2CASP,=X'602020202120' EDIT MASK (SPLITS-CA)\n         L     R14,AMDNCAS        NO.OF CA SPLITS\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CASP,D+5       EDIT THE SPLITS-CA\n         MVI   STL2C,C'0'         2 LINES SPACING\n         LA    R11,STL2           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* STATISTICS LINE 3\n         MVC   STL3IXL,=X'60202120' EDIT MASK (IX LVLS)\n         LH    R14,AMDNIL         NUMBER OF INDEX LEVELS\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL3IXL,D+6        EDIT THE IX LEVELS\n         MVC   STL3EXT,=X'602020202120' EDIT MASK (EXTENTS)\n         LH    R14,AMDNEXT        NO.OF EXTENTS IN THE DATA SET\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL3EXT,D+5        EDIT THE EXTENTS #\n         MVC   STL3EXCP,=X'60202020202020202120' EDIT MASK (EXCPS)\n         L     R14,AMDEXCP        NO.OF EXCPS ISSUED BY VSAM\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL3EXCP,D+3       EDIT THE EXCP #\n         MVI   STL3EXTF,C' '      CLEAR the field\n         MVC   STL3EXTF+1(L'STL3EXTF-1),STL3EXTF\n         TM    AMDATTR,AMDSDT     IMBED INDEX.........................?\n         BNO   PRNTST3E           NO---------------------------------->\n         MVC   STL3IMBD,=C'IMBED IX' YES, INDICATE IMBED INDEX\nPRNTST3E TM    CAFLAGS,EAKSDS     Extended Addressability KSDS .......?\n         BNO   PRNTST3X           NO---------------------------------->\n         MVC   STL3EXTF,=C'Ext-Addr' Indicate extended address. KSDS\nPRNTST3X MVI   STL3C,C'0'         2 LINES SPACING\n         LA    R11,STL3           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         DROP  R3                 drop AMB addressability\n         SUBRET PRNTSTAT          RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT THE SPACE DISTRIBUTION LINE - TABLE FORMAT                    *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* A little subroutine entered via LNKREG1\n* Add R0/R1 (8 byte counts) to R14/R15\nADD8BC   ALR   R15,R1             + CI freespace LO 4 bytes\n         BC    12,ADD8BC1         no carry in add logical\n         AL    R14,=F'1'          Carry: add 1 to HO 4 bytes of FSPC\nADD8BC1  ALR   R14,R0             + CI freespace HO 4 bytes\n         BR    LNKREG1            Return\n*\n* Round all byte counts to 1KiB if total > 4GiB\n* R14/R15 has 8 bytes count\nRPPTRKiB TM    CAFLAGS,GT4GiB     Is rounding required ...............?\n         BNOR  LNKREG1            No, return\n         D     R14,=F'1024'       Round to 1KiB\n         C     R14,=F'512'        If reminder >  512 will add 1 to\n*                                 the result\n         BNHR  LNKREG1            reminder <= 512  return\n         AL    R15,=F'1'          reminder >  512  add 1 to result\n         BR    LNKREG1            Return\n*\nRPTTSDL  SUBENT\n         NI    CAFLAGS,X'FF'-GT4GiB      reset > 4GiB flag\n* R6 HAS THE SPACE UTILIZATION SUMMARY ADDRESS ( SUS )\n         USING SUS,R6             SUS ADDRESSABILITY\n* Add counters to get total space in bytes\n* If total space > 4GiB - will round it to KiB\n* We are struggling with pre-z hardware 8 bytes counters here\n         LM    R14,R15,USPC       LOAD used space in bytes\n         LM    R0,R1,CIFSP        LOAD CI free space\n         BAL   LNKREG1,ADD8BC     Add them\n         L     R1,CAFSPCI#        # of CA free space CIs\n         AL    R1,IX#SFCI         + # of UNUSED CI'S due to IX CI SHORT\n*                                 = total free CIs\n         M     R0,CISIZED         x DataCIsize = unused bytes\n         BAL   LNKREG1,ADD8BC     Add them\n* R14/R15 has total bytes\n         LTR   R14,R14            Total bytes > 4GiB .................?\n         BZ    RPPTSPD            No, convert to decimal ------------->\n         OI    CAFLAGS,GT4GiB     Set total > 4GiB flag\n* Round all byte counts to 1KiB if total > 4GiB\n         BAL   LNKREG1,RPPTRKiB   Round result to 1KB\n* R15 HAS NOW TOTAL SPACE IN BYTES or KiB\nRPPTSPD  ST    R15,SUSTOTB        Save this for RPTG use\n*                                 (since it needs to the same above\n*                                  calculation)\n         CVD   R15,D1             CONVERT TOTAL SPACE TO DECIMAL\n*        USED SPACE NOW\n         LM    R14,R15,USPC       LOAD used space in bytes\n         BAL   LNKREG1,RPPTRKiB   Round result to 1KB if required\n         CVD   R15,D              CONVERT used TO DECIMAL\n         MVC   RPTTL1U,RPPTMSK1   EDIT MASK\n         ED    RPTTL1U,D+2        EDIT THE USED SPACE\n         MVI   RPTTL1U+L'RPTTL1U,C' ' Blank KiB units indicator\n         TM    CAFLAGS,GT4GiB     Is this rounded to 1KiB.............?\n         BNO   RPPTSPDK           NO---------------------------------->\n         MVI   RPTTL1U+L'RPTTL1U,C'K' Yes, mark KiB units\nRPPTSPDK BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1UP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n* CI FREE SPACE\n         LM    R14,R15,CIFSP      LOAD CI free space in bytes\n         BAL   LNKREG1,RPPTRKiB   Round result to 1KB if required\n         CVD   R15,D              CONVERT TO BINARY\n         MVC   RPTTL1I,RPPTMSK1   EDIT MASK\n         ED    RPTTL1I,D+2        EDIT THE FREESPACE-CI\n         MVI   RPTTL1I+L'RPTTL1I,C' ' Blank KiB units indicator\n         TM    CAFLAGS,GT4GiB     Is this rounded to 1KiB.............?\n         BNO   *+8                No---------------------------------->\n         MVI   RPTTL1I+L'RPTTL1I,C'K' Yes, mark KiB units\n         BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1IP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n* # OF USED CI'S IN THIS SUS\n         L     R15,#UCIS          # of used CIs is this SUS\n         CVD   R15,D              = # CI'S, CONVERT TO BINARY\n         MVC   RPTTL1#O,RPPTMSK1   EDIT MASK\n         ED    RPTTL1#O,D+2        EDIT # OF CI'S\n* Will put total # of CIs in D1 work field (for % calucalation)\n         L     R1,CAFSPCI#        # of CA free space CIs\n         AL    R1,IX#SFCI         + # of UNUSED CI'S due to IX CI SHORT\n         AL    R1,#UCIS           + # of used  CI'S\n*                                 = total number of CIs\n         CVD   R1,D1              CONVERT TOTAL CI# TO DECIMAL\n* CA FREE SPACE (# of CIs)\n         L     R1,CAFSPCI#        # of CA free space CIs\n         CVD   R1,D               CONVERT TO BINARY\n         MVC   RPTTL1#C,RPPTMSK1  EDIT MASK\n         ED    RPTTL1#C,D+2       EDIT THE FREESPACE-CA\n         BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1CP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n* FREE SPACE RESULTING FROM INDEX CI BEING TOO SHORT (# of CIs)\n         L     R1,IX#SFCI         + # of UNUSED CI'S due to IX CI SHORT\n         CVD   R1,D               CONVERT TO BINARY\n         MVC   RPTTL1#U,RPPTMSK1   EDIT MASK\n         ED    RPTTL1#U,D+2        EDIT THE FREESPACE-CI\n         BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1SP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n* PRINT THE RPTT SPACE DISTRIBUTION LINE\n         MVI   RPTTL1A,C' '       ENSURE ONE LINE SPACING\n         LA    R11,RPTTL1         ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         SUBRET RPTTSDL\n         SPACE\n* CALCULATE AND EDIT PERCENTAGE OF TOTAL SPACE (RPTT LINE RPTTL1)\nRPTTSDLP DS    0H\n* D1 CONTAINS TOTAL SPACE IN BYTES or KiB or # of CI's\n* D  CONTAINS A SPACE DISTRIBUTION COMPONENT IN BYTES (DECIMAL)\n*    or KiB or # of CIs\n         MP    D,=PL2'100'        MULTIPLY BY A 100\n         DP    D,D1+2(6)          DIVIDE BY TOTAL SPACE = %\n         LH    R15,D              LOAD THE QUOTIENT INTO R4 (3 DECIMAL\n*                                 DIGITS PLUS A SIGN)\n         SRL   R15,4              ELIMINATE THE SIGN (SHIFTED OUT)\n         XC    D(2),D             CLEAR TWO H/O BYTES\n* A FIX TO ORIGINAL MULTILPY, REPLACED BY A SHIFT + MVC OF ZEROS/SIGN\n* AT THE END OF THE OPERAND (0C7 EVEN THOUGH ENOUGH OF LEADING ZEROS)\n*        MP    D,=PL3'1000'       MULTIPLY REMAINDER BY A 1000\n         STM   R0,R1,R0R1SA       SAVE R0,R1\n         LM    R0,R1,D            LOAD \"D\" INTO R0,R1\n         SLDL  R0,12              SHIFT LEFT BY 12 BITS/3 ZONES\n*                                 = MULTIPLY BY 1000\n         STM   R0,R1,D            STORE RESULT INTO D\n         MVC   D+6(2),=X'000C'    INSERT TRAILING ZEROS + DECIMAL SIGN\n         LM    R0,R1,R0R1SA       RESTORE R0,R1\n* END OF FIX, SEPT. 2/98\n         DP    D,D1+2(6)          DIVIDE BY TOTAL SPACE = %\n*                                 3 DIGITS AFTER DECIMAL POINT\n         MVC   D+6(2),D           MOVE THEM TO THE END OF D\n         STH   R15,D+4            PUT THE 3 DEC DIGITS BACK (SHIFTED\n*                                 ONE POSITION TO THE RIGHT)\n         XC    D(4),D             CLEAR 4 H/O BYTES\n* SHIFT AND ROUND THE PERCENTAGE: 2 DEC.DIGITS TO THE RIGHT. ONE\n* ROUNDED DECIMAL DIGITS AFTER DECIMAL POINT WILL BE LEFT\n         SRP   D,64-2,5\n         MVC   RPTTPCT,=X'40202021204B20' EDIT MASK INTO PERCENTAGE FLD\n         ED    RPTTPCT,D+5        EDIT THE ROUNDED PERCENTAGE\n         BR    R14                RETURN\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT A BLANK LINE ON RPTG AND RPTT                                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nBLANKL   SUBENT\n         MVI   BLANKLC,C' '       ONE LINE SPACING\n         LA    R11,BLANKLN        ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         SUBRET BLANKL\n         SPACE\n*---------------------------------------------------------------------*\n* INPUT KSDS FILE IS EMPTY                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nKSDSNL   DS    0H\n         L     R11,=A(EMPTM1)     ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,DMSGDB         ADDRESS OF THE DMSG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         B     RC16               TERMINATE WITH RC=16\n         SPACE\n* CLOSE ALL FILES AND TERMINATE\nCLOSE    BAL   R14,CLOSEP         CLOSE ALL FILES\n         SPACE\nRC0      SR    R15,R15            RC = 0 ( NORMAL COMPLETION )\n         SPACE\nRETURN   DS    0H\n         L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)   RETURN\n         SPACE\nRC16     DS    0H                 RC = 16 ( ERROR )\n         BAL   R14,CLOSEP         CLOSE ALL FILES\n         LA    R15,16             RC = 16 ( ERROR )\n         B     RETURN\n         SPACE\n*---------------------------------------------------------------------*\n* CLOSE FILES PROC                                                    *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCLOSEP   SUBENT\n         CLOSE (VSAMF)            CLOSE THE KSDS\n         CLOSE (MSGFILE,,RPTG,,RPTT,,LHKR)\n         SUBRET CLOSEP\n         SPACE\n*---------------------------------------------------------------------*\n* ABEND - INDEX RECORD JUST READ IS NOT A SEQUENCE SET RECORD         *\n*         AS EXPECTED                                                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nABEND0   ABEND 0,DUMP\n         SPACE\n*---------------------------------------------------------------------*\n* OPEN/CLOSE ERROR ROUTINE                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nOPENERR  DS    0H                 OPEN/CLOSE ERROR ROUTINE\n         ST    R15,ACBERROR       SAVE RC FROM R15\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,OCR15     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SHOWCB ACB=VSAMF,AREA=ACBERROR,LENGTH=4,                      +\n               FIELDS=(ERROR)     GET ERROR FIELD FROM ACB\n         LTR   R15,R15            SHOWCB OK...........................?\n         BNZ   SHOWCBER           NO, SHOWCB ERROR-------------------->\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,ACBERF    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX   CONVERT ACB ERROR FIELD TO HEXADECIMAL\n         LA    MSGADDR,OPECLOEM   OPEN/CLOSE ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* VSAM REQUEST ERROR ROUTINE                                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nIXRERROR DS    0H                 GETIX READ ERROR\n         MVC   REQTYPE,=CL11'GETIX' REQUEST TYPE ID\n         L     R8,=A(RPLIX)       RPL address (index read)\n         B     ERROR              GO TO ERROR PROC-------------------->\nPOINTERR DS    0H                 POINT REQUEST ERROR\n         MVC   REQTYPE,=CL11'POINT'  REQUEST TYPE ID\n         B     DCIRERR1           LOAD ADDRESS OF THE RPL INTO R8----->\nDCIRERR  DS    0H                 DATA CI READ ERROR\n         MVC   REQTYPE,=CL11'GET DATA CI' REQUEST TYPE ID\nDCIRERR1 L     R8,=A(RPLDC)       RPL ADDRESS\n         SPACE\nERROR    DS    0H                 VSAM REQUEST ERROR: GETIX/GET DATA CI\n         ST    R15,ACBERROR       SAVE RC FROM R15\n         SHOWCB RPL=(8),AREA=FTNCD,LENGTH=8,                           +\n               FIELDS=(FTNCD,FDBK)  GET FTNCD AND FDBK FIELD FROM RPL\n         LTR   R15,R15            SHOWCB OK...........................?\n         BNZ   SHOWCBER           NO, SHOWCB ERROR-------------------->\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,FTNCD      INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQFTNCD  OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'FTNCD     LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT FTNCD TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,FDBK       INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQFDBK   OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'FDBK      LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT FDBK  TO HEXADECIMAL\n         LA    MSGADDR,REQERRM    VSAM REQUEST ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n*********THESE ARE TEMPORARY, DIAGNOSTIC STMTS*************************\n*        CLOSE (MSGFILE,,RPTG,,RPTT) **********************************\n*        ABEND 1,DUMP ************A TEMPORARY DIAGNOSTIC DUMP**********\n*********THESE ARE TEMPORARY, DIAGNOSTIC STMTS*************************\n         B     RC16               TERMINATE THE PROGRAM--------------->\n         SPACE\n*---------------------------------------------------------------------*\n* SHOWCB ERROR ROUTINE                                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSHOWCBER DS    0H                 SHOWCB MACRO ERROR\n         STM   R15,R0,ACBERROR    SAVE R15 AND R0 (ERROR CODE)\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,SCBR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,ACBERROR+4 INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,SCBR0     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT ERROR CODE TO HEXADECIMAL\n         SPACE\n         LA    MSGADDR,SCBERRM    SHOWCB ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               TERMINATE THE PROGRAM WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* MODCB ERROR ROUTINE                                                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMODCBER  DS    0H                 MODCB MACRO ERROR\n         STM   R15,R0,ACBERROR    SAVE R15 AND R0 (ERROR CODE)\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,MCBR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,ACBERROR+4 INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,MCBR0     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT ERROR CODE TO HEXADECIMAL\n         SPACE\n         LA    MSGADDR,MCBERRM    SHOWCB ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* INPUT FILE IS NOT A KSDS                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOTKSDS  LA    MSGADDR,NKSDSEM    NON-KSDS DATA SET ON INPUT\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* CSI call error                                                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         USING KSDSPACD,DATACSR   KSDSPACD addressability\nCSICERR1 ST    R15,D              SAVE R15 in a work field\n         LA    HEXINAR,D          INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,CSIEMR15  OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,4           LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,CSIRSNCODE INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,CSIERSNC  OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,1           LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,CSIRTNCODE INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,CSIEMRETC OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,1           LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         MVC   CSIEMID,CSIMODID   CSI call catalog module id\n         LA    MSGADDR,CSIERRM    CSI call error message address\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         LA    MSGADDR,CSIERRM1   CSI call error follow up message\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     NOTBCS1            Will assume this is not an\n*                                 extended addressability KSDS\n         DROP  DATACSR\n         SPACE\n*---------------------------------------------------------------------*\n*   TRANSLATION OF ERROR CODES INTO HEXADECIMAL SUBROUTINE            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* HEXINAR  - INPUT FIELD ADDRESS\n* HEXOUTAR - OUTPUT FIELD ADDRESS\n* HEXLEN   - INPUT FIELD LENGTH\n         SPACE\nCONVHEX  DS    0H\n         IC    TCHR,0(0,HEXINAR)  TRANSLATED CHARACTER\n         SLL   TCHR,24            EXTRACT H/O HEX DIGIT\n         SRL   TCHR,28\n         LA    TCHR,HEXCH(TCHR)   HEX DIGIT ADDRESS\n         MVC   0(1,HEXOUTAR),0(TCHR) MOVE HEX DIGIT INTO OUTPUT STRING\n         IC    TCHR,0(0,HEXINAR)  TRANSLATED CHARACTER\n         SLL   TCHR,28            EXTRACT L/O HEX DIGIT\n         SRL   TCHR,28\n         LA    TCHR,HEXCH(TCHR)   HEX DIGIT ADDRESS\n         MVC   1(1,HEXOUTAR),0(TCHR) MOVE HEX DIGIT INTO OUTPUT STRING\n         LA    HEXINAR,1(0,HEXINAR) NEXT TRANSLATED CHAR ADDRESS\n         LA    HEXOUTAR,2(0,HEXOUTAR) NEXT OUTPUT ADDRESS\n         BCT   HEXLEN,CONVHEX     TRANSLATE NEXT CHARACTER\n         BR    LNKREG1            RETURN TO CALLER\n         SPACE\nIXRPT    SUBENT\n* REPORT ON INDEX STRUCTURE: Print # OF IX RECORDS PER IX LEVEL\n* Read index sequentially until SEOF.\n* Print # of index record in each IX level.\n* R4 - Index AMDSB address/pointer (saved in INDXDSBA)\n         USING AMDSB,R4           Index AMDSB ADDRESSABLITY\n* We need to get storage for the IXLVLT table\n         LH    R0,AMDNIL          # of IX levels\n         SLL   R0,1               times 2 = IXLVLT table size\n*                                 (one word for each IX level)\n         GETMAIN R,LV=(0),LOC=(24,31) Get storage for IXLVLT\n         LR    R2,R1              IXLVLT address into R2\n* We need to init the IXLVLT entries to 0\n         USING IXLVLT,R2          IXLVLT addressability\n         LH    R1,AMDNIL          # of IX levels\n         XR    R0,R0              clear R0 (0 value)\n         XR    R3,R3              clear R3 (IXLVLT index reg)\nIXRPT00  STH   R0,IXLVLR#(R3)     clear IXLVLT entry\n         LA    R3,2(,R3)          next IXLVLT entry address\n         BCT   R1,IXRPT00         Contine for all IXLVL entries\n* Now we will start reading index records sequentially until SEOF\n         XC    IXCIRBAX(8),IXCIRBAX   Start from begining (RBA=0)\nIXRPTR   DS    0H                 Read of the index record\n         L     R1,=A(RPLIX)       RPL address (index read)\n         GETIX RPL=(1)            GET AN INDEX (SS) RECORD\n         LTR   R15,R15            GET of index RECORD OK..............?\n         BNZ   IXRERROR           NO, INDEX READ ERROR---------------->\n         L     R5,IXCIADDR        LOAD THE ADDRESS OF THE INDEX RECORD\n         USING IXHDR,R5           INDEX RECORD (HEADER) ADDRESSABILITY\n* CHECK IF THIS IS SEOF (SOFTWARE END-OF-FILE) CI\n         LH    R14,IXHLL          LENGTH OF INDEX RECORD\n         LA    R15,IXHDR+3(R14)   ADDRESS OF THE CIDF FIELD\n         USING CIDF,R15           CIDF ADDRESSABLITY\n         OC    CIDF(4),CIDF       ALL ZEROS IN CIDF...................?\n         BZ    IXRPTEOF           YES, SOFTWARE END-OF-FILE----------->\n* Lets validate the IXHLV field and update IXLVLR# in IXLVLT\n         CLI   IXHLV,X'00'        A valid IX level should be from 1 to\n*                                 AMDNIL\n         BE    IXRPTE1            NO, SOMETHING WRONG, IX level=0----->\n         XR    R3,R3              clear R3\n         IC    R3,IXHLV           This IX recod index level\n         CH    R3,AMDNIL          IX level <= AMDNIL .................?\n         BH    IXRPTE1            NO, SOMETHING WRONG, IX level>max--->\n         BCTR  R3,0               IX level - 1\n         SLL   R3,1               * 2 = IXLVLR# offset in IXLVLT\n* Update IX record cound on this index level\n         LH    R1,IXLVLR#(R3)     current value\n         LA    R1,1(,R1)          + 1\n         STH   R1,IXLVLR#(R3)     current value\n* XRBA of next IX record = current record XRBA + IX CISIZE\n* This is a correct (I hope) 8 bytes binary arithmetic\nIXRPTNR  LM    R0,R1,IXCIRBAX     current record XRBA\n         AL    R1,CISIZEI         + IX CISIZE\n         BC    12,IXRPTNR1        no carry in add logical IX CIsize\n         LA    R15,1              Carry: put 1 in R15\n         ALR   R0,R15             Carry: add 1 to HO 4 bytes of XRBA\nIXRPTNR1 STM   R0,R1,IXCIRBAX     next record XRBA\n         B     IXRPTR             Read next record\n* We read all index record at this point\n* Let's now print the counts (on RPTT only)\nIXRPTEOF DS    0H\n         LA    R11,IXRPTL1        ADDRESS OF headr line\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         TM    AMDATTR,AMDSDT     IMBED INDEX.........................?\n         BO    IXRPTPR0           Yes, will print the comment 1st lne->\n         MVC   IXRPTL2C+1(L'IXRPTL2C-1),IXRPTL2C clear comment for\n*                                 IMBED index (SS IX count not valid)\n* Print IX level/ # of records lines\nIXRPTPR0 LH    R3,AMDNIL          # of IX levels\n         XR    R5,R5              clear R5 (IXLVLT index reg)\nIXRPTPR1 MVC   IXRPTL2L,=X'402020202120' edit mask into # IX level\n         ED    IXRPTL2L,IXRPTL#    edit to character format\n         LH    R0,IXLVLR#(R5)     number of IX records at this level\n         CVD   R0,D               convert to decimal\n         MVC   IXRPTL2R,=X'4020202020202120' edit mask into # of recs\n         ED    IXRPTL2R,D+4        edit to character format\n         LA    R11,IXRPTL2        ADDRESS OF headr line\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         MVC   IXRPTL2C+1(L'IXRPTL2C-1),IXRPTL2C clear comment for\n*                                 IMBED index (SS IX count not valid)\n         LA    R5,2(,R5)          next IXLVLT entry address\n         AP    IXRPTL#,=PL1'1'    Index level +1\n         BCT   R3,IXRPTPR1        Contine for all IXLVL entries\n* We are done with IX levels report, let's free the IXLVLT\n         LH    R0,AMDNIL          # of IX levels\n         SLL   R0,1               times 2 = IXLVLT table size\n*                                 (one word for each IX level)\n         LR    R1,R2              IXLVLT address into R2\n         FREEMAIN R,LV=(0),A=(1)  Free IXLVLT\nIXRPTEX  SUBRET IXRPT             Return back to caller\n         SPACE\nIXRPTE1  DS    0H                 Index level invalid (0 or > max)\n         MVC   IXRPTL3R,=X'4020206B2020206B2020206B202120'\n         L     R0,IXCIRBA         RBA of this index record\n         CVD   R0,D               convert to decimal\n         ED    IXRPTL3R,D+2       edit to character format\n         LA    R11,IXRPTL3        ADDRESS OF error msg line\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         B     IXRPTNR            Read next IX record\n         DROP  R2,R4,R5,R15       drop addressability for IXRPT\n         SPACE\nIXRPTL#  DC    PL3'1'             IX level\nIXRPTL1  DC    AL2(IXRPTL1E-IXRPTL1) IXRPT header line\n         DC    AL2(0)\n         DC    C'0Index level    # of records'\nIXRPTL1E EQU   *\n         SPACE\nIXRPTL2  DC    AL2(IXRPTL2E-IXRPTL2) IXRPT line 2\n         DC    AL2(0)\n         DC    C' '               ONE LINE SPACING\nIXRPTL2L DC    X'402020202120'    Index level\n         DC    C'          '\nIXRPTL2R DC    X'4020202020202120'  # OF IX CIs at this level\nIXRPTL2C DC    C' <-- SS IX count invalid when IMBED'\nIXRPTL2E EQU   *\n         SPACE\nIXRPTL3  DC    AL2(IXRPTL3E-IXRPTL3) IXRPT index error line\n         DC    AL2(0)\n         DC    C'0Index level invalid in IX record, RBA='\nIXRPTL3R DC    X'4020206B2020206B2020206B202120' RBA of IX record\n         DC    C' record ignored'\nIXRPTL3E EQU   *\n         SPACE\nUSPCID   DC    C'*'               CHARACTER REPRESENTING USED SPACE\nCAFSPCID DC    C'-'               CHARACTER REPRESENTING CA FREE SPACE\nCIFSPCID DC    C'X'               CHARACTER REPRESENTING CI FREE SPACE\nIXSFSPID DC    C'+'               CHARACTER REPRESENTING FREE SPACE\n*                                 RESULTING FROM INDEX CI BEING TOO\n*                                 SHORT\nRPTGL1   DC    AL2(RPTGL1E-RPTGL1) RPTG PRINT LINE 1 (RDW - RECLEN)\n         DC    AL2(0)\nRPTGL1C  DC    C' '               ANSI PRINT CONTROL CHAR (1 LINES SPC)\nRPTGL1A  DS    CL132              TEXT TO BE PRINTED\nRPTGL1E  EQU   *\n         SPACE\nRPTHDR   DC    AL2(RPTHDRE-RPTHDR) REPORT HEADER LINE RDW - RECLEN)\n         DC    AL2(0)\nRPTHDRC  DC    C'1'               ANSI PRINT CONTROL - NEW PAGE\nRPTHDRT  DS    CL122              HEADET TEXT\n         DC    C'PAGE'\nRPTHDRP  DC    X'402020202120'    PAGE NUMBER\nRPTHDRE  EQU   *\n         SPACE\nSTL1     DC    AL2(STL1E-STL1) COMPONENT STATISTICS LINE 1\n         DC    AL2(0)\nSTL1C    DC    C'-'               ANSI PRINT CONTROL - SPACE 3 LINES\nSTL1N    DS    CL44               COMPONENT NAME\nSTL1T    DC    C'STATISTICS:'\nSTL1E    EQU   *\n         SPACE\nSTL2     DC    AL2(STL2E-STL2) DC STATISTICS LINE 2\n         DC    AL2(0)\nSTL2C    DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\n         DC    C'CISIZE'\nSTL2CI   DC    X'6020202020202120'\n         DC    C'    CI/CA'\nSTL2CICA DC    X'6020202020202120'\n         DC    C'    FREESPACE-%CA'\nSTL2FSCA DC    X'602020202120'\n         DC    C'    FREESPACE-%CI'\nSTL2FSCI DC    X'602020202120'\n         DC    C'    SPLITS-CA'\nSTL2CASP DC    X'602020202120'\n         DC    C'    SPLITS-CI'\nSTL2CISP DC    X'6020202020202120'\nSTL2E    EQU   *\n         SPACE\nSTL3     DC    AL2(STL3E-STL3) DC STATISTICS LINE 3\n         DC    AL2(0)\nSTL3C    DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\n         DC    C'IX LEVELS-'\nSTL3IXL  DC    X'60202120'\n         DC    C'    EXTENTS'\nSTL3EXT  DC    X'602020202120'\n         DC    C'    EXCPS'\nSTL3EXCP DC    X'60202020202020202120'\n         DC    C'        '\nSTL3IMBD DS    C'IMBED IX'\n         ORG   STL3IMBD\nSTL3EXTF DS    C'Ext-Addr'\nSTL3E    EQU   *\n         SPACE\nIXSL1    DC    AL2(IXSL1E-IXSL1)  IX SUMMARY LINE 1\n         DC    AL2(0)\nIXSL1C   DC    C'-'               ANSI PRINT CONTROL - SPACE 3 LINES\nIXSL1T   DC    C'SPACE UTILIZATION SUMMARY FOR THE INDEX COMPONENT:'\nIXSL1E   EQU   *\n         SPACE\nDCSL1    DC    AL2(DCSL1E-DCSL1)  DC SUMMARY LINE 1\n         DC    AL2(0)\nDCSL1C   DC    C'-'               ANSI PRINT CONTROL - SPACE 3 LINES\nDCSL1T   DC    C'SPACE UTILIZATION SUMMARY FOR THE DATA COMPONENT:'\nDCSL1E   EQU   *\n         SPACE\nDCSL2    DC    AL2(DCSL2E-DCSL2)  DC SUMMARY LINE 2\n         DC    AL2(0)\nDCSL2C   DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\nDCSL2T   DC    C'NUMBER OF PROCESSED (USED) CONTROL AREAS: '\nDCSL2N   DC    X'4020202020202120'\nDCSL2E   EQU   *\n         SPACE\nDCSL3    DC    AL2(DCSL3E-DCSL3)  DC SUMMARY LINE 3\n         DC    AL2(0)\nDCSL3C   DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\nDCSL3T   DC    C'NUMBER OF FREE (UNUSED) CONTROL AREAS AT THE END OF TH+\n               E DATA SET: '\nDCSL3N   DC    X'4020202020202120'\nDCSL3E   EQU   *\n         SPACE\n         SPACE\nHEXCH    DC    C'0123456789ABCDEF' HEXADECIMAL CHARACTERS\n         SPACE\nBLANKLN  DC    AL2(BLANKLNE-BLANKLN)\n         DC    AL2(0)\nBLANKLC  DC    C'  '              ANSI PRINT CONTROL - SPACE 3 LINES\nBLANKLNE EQU   *\n         SPACE\nR0R1SA   DS    2F                 SAVE AREA FOR R0,R1\nRPTTPCT  DC    X'40202021204B20'  PERCENTAGE WORK FIELD\n         SPACE\nRPTTL1   DC    AL2(RPTTL1E-RPTTL1)  RPPT LINE 1\n         DC    AL2(0)\nRPTTL1A  DC    C' '               ONE LINE SPACING\nRPTTL1U  DC    X'4020206B2020206B2020206B202120' USED SPACE\n         DC    C'  ('\nRPTTL1UP DC    CL5' '             PERCENTAGE OF TOTAL SPACE\n         DC    C')'\nRPTTL1#O DC    X'4020206B2020206B2020206B202120'   # OF used CI'S\n         DC    C'  '\nRPTTL1I  DC    X'4020206B2020206B2020206B202120' CI FREE SPACE\n         DC    C'  ('\nRPTTL1IP DC    CL5' '  CI FSPC    PERCENTAGE OF TOTAL SPACE\n         DC    C')   '\n         DC    C' ('\nRPTTL1CP DC    CL5' ' CA free space: PERCENTAGE OF TOTAL SPACE\n         DC    C')'\nRPTTL1#C DC    X'4020206B2020206B2020206B202120'   # OF FREEE CI'S\n         DC    C'   ('\nRPTTL1SP DC    CL5' ' IX record short: PERCENTAGE OF TOTAL SPACE\n         DC    C') '\nRPTTL1#U DC    X'4020206B2020206B2020206B202120'    # OF UNUSED CI'S\nRPTTL1E  EQU   *\n         SPACE\n         SPACE\nRPTTDB   DS    6F                 RPTT DEFINITION BLOCK\n         ORG   RPTTDB\n*/////////////////////////////////////////////////////////////////////*\nRPTTDCBA DC    A(RPTT)            DCB ADDRESS\nRPTTLPL  DC    A(RPTLPP)          RPTT LINES PER PAGE LIMIT\nRPTTLCNT DC    A(RPTLPP)          RPTT LINE COUNT (FORCE FIRST HEADER)\nRPTTPGN  DC    A(1)               RPTT PAGE NUMBER\nRPTTHTA  DC    A(RPTTHLT)         PAGE HEADER LINE TEXT ADDRESS\nRPTTHTA1 DC    A(RPTTL1H)         SECOND PAGE HEADER LINE ADDRESS\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\nDMSGDB   DS    6F                 DIAGNOSTIC MSGS DEFINITION BLOCK\n         ORG   DMSGDB\n*/////////////////////////////////////////////////////////////////////*\nDMSGDCBA DC    A(MSGFILE)         DCB ADDRESS\nDMSGLPL  DC    A(RPTLPP)          DMSG LINES PER PAGE LIMIT\nDMSGLCNT DC    A(RPTLPP)          DMSG LINE COUNT (FORCE FIRST HEADER)\nDMSGPGN  DC    A(1)               DMSG PAGE NUMBER\nDMSGHTA  DC    A(DMSGHLT)         PAGE HEADER LINE TEXT ADDRESS\nDMSGHTA1 DC    A(0)               NO SECOND HEADER LINE FOR THIS RPT\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\nRPTGDB   DS    6F                 RPTG DEFINITION BLOCK\n         ORG   RPTGDB\n*/////////////////////////////////////////////////////////////////////*\nRPTGDCBA DC    A(RPTG)            DCB ADDRESS\nRPTGLPL  DC    A(RPTLPP)          RPTG LINES PER PAGE LIMIT\nRPTGLCNT DC    A(RPTLPP)          RPTG LINE COUNT (FORCE FIRST HEADER)\nRPTGPGN  DC    A(1)               RPTG PAGE NUMBER\nRPTGHTA  DC    A(RPTGHLT)         PAGE HEADER LINE TEXT ADDRESS\nRPTGHTA1 DC    A(0)               NO SECOND HEADER LINE FOR THIS RPT\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n*/////////////////////////////////////////////////////////////////////*\n*        THE FOLLOWING FULLWORDS ARE LOCATION DEPENDENT               *\nDISPLAY  DS    0F                 FIELDS OBTAINED BY SHOWCB           *\nLRECL    DS    F                  MAX. LRECL                          *\nRKP      DS    F                  RELATIVE KEY POSITION               *\nKEYLEN   DS    F                  KEY LENGTH                          *\nACBERROR DS    F                  ACB ERROR FIELD                     *\nFTNCD    DS    F                  RPL FUNCTION CODE                   *\nFDBK     DS    F                  RPL FEEDBACK FIELD                  *\n*/////////////////////////////////////////////////////////////////////*\nIXCIADDR DS    CL4                     INDEX CI ADDRESS IN A BUFFER\nDCCIADDR DS    CL4                     DATA  CI ADDRESS IN A BUFFER\n         SPACE\n         IFGACB DSECT=NO,AM=VSAM       ACB LAYOUT\n         ORG   IFGACB\nVSAMF    ACB   AM=VSAM,DDNAME=KSDS,MACRF=(CNV,DIR,SEQ),STRNO=2\n         SPACE\nRPTOPNER DS    0H                 MSG DCB OPEN ERROR\n         WTL   'KSDSPACE  - A report dataset could not be opened'\n         B     RC16\n         SPACE\nOPECLOEM DC    AL2(OPECLOME-OPECLOEM) OPEN/CLOSE ERROR MESSAGE\n         DC    AL2(0)\n         DC    C'0OPEN/CLOSE ERROR  R15='\nOCR15    DS    CL8                RC CODE IN R15\n         DC    C' ACB ERROR FIELD='\nACBERF   DS    CL8                ACB ERROR FILED\nOPECLOME EQU   *\n         SPACE\nREQERRM  DC    AL2(REQERRME-REQERRM) GET | PUT | ERASE ERROR MSG\n         DC    AL2(0)\n         DC    C'0VSAM '\nREQTYPE  DC    CL11'GET DATA CI'  REQUEST TYPE\n         DC    C' REQUEST ERROR  R15='\nREQR15   DS    CL8                RC CODE IN R15\n         DC    C' FTNCD='\nREQFTNCD DS    CL8                REQUEST FUNCTION CODE\n         DC    C' FDBK='\nREQFDBK  DS    CL8                REQUEST FEEDBACK FIELD\nREQERRME EQU   *\n         SPACE\nSCBERRM  DC    AL2(SCBERRME-SCBERRM) SHOWCB MACRO ERROR\n         DC    AL2(0)\n         DC    C'0SHOWCB MACRO ERROR  R15='\nSCBR15   DS    CL8                RC CODE IN R15\n         DC    C' R0='\nSCBR0    DS    CL8                REQUEST FUNCTION CODE\nSCBERRME EQU   *\n         SPACE\nMCBERRM  DC    AL2(MCBERRME-MCBERRM) MODCB MACRO ERROR MSG\n         DC    AL2(0)\n         DC    C'0MODECB MACRO ERROR  R15='\nMCBR15   DS    CL8                RC CODE IN R15\n         DC    C' R0='\nMCBR0    DS    CL8                REQUEST FUNCTION CODE\nMCBERRME EQU   *\n         SPACE\nNKSDSEM  DC    AL2(NKSDSEME-NKSDSEM) NOT KSDS FILE ERROR MESSAGE\n         DC    AL2(0)\n         DC    C'0NON-KSDS DATA SET IS NOT ALLOWED AS INPUT TO THIS PRO+\n               GRAM'\nNKSDSEME EQU   *\n         SPACE\nSGL1     DC    AL2(SGL1E-SGL1) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'-*  REPRESENTS SPACE USED BY DATA RECORDS'\nSGL1E    EQU   *\nSGL2     DC    AL2(SGL2E-SGL2) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'0-  REPRESENTS UNUSED CONTROL INTERVALS RESULTING FROM+\n                CA-FREESPACE SPECIFICATION AND/OR CA SPLITS'\nSGL2E    EQU   *\nSGL3     DC    AL2(SGL3E-SGL3) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'0X  REPRESENTS UNUSED CI SPACE RESULTING FROM CI-FREES+\n               PACE SPECIFICATION AND/OR CI SPLITS'\nSGL3E    EQU   *\nSGL4     DC    AL2(SGL4E-SGL4) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'0+  REPRESENTS UNUSED CA SPACE RESULTING FROM INDEX CI+\n                BEING TOO SHORT'\nSGL4E    EQU   *\n         SPACE\n* WORK AREAS/FILEDS\n         DS    0D\nD        DS    D                  A DOUBLEWORD\nD1       DS    D                  A DOUBLEWORD\nDATADSBA DS    A                  DATA COMPONENT STATISTICS BLOCK ADDR\nINDXDSBA DS    A                  INDEX COMPONENT STATISTICS BLOCK ADDR\nDCCIPFSP DS    A                  Address of free space in this data CI\n*/////////////////////////////////////////////////////////////////////*\n* 8 bytes binary RBA due to Extended Format and OPTCD=(XRBA)\nIXCIRBAX DS    F                  HO part of XRBA\nIXCIRBA  DS    F                  RBA OF THE NEXT INDEX (SS) CI TO BE\n*                                 READ\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n*/////////////////////////////////////////////////////////////////////*\n* 8 bytes binary RBA due to Extended Format and OPTCD=(XRBA)\nDCCIRBAX DS    F                  HO part of XRBA\nDCCIRBA  DS    F                  RBA OF THE DATA CI TO BE READ\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n*/////////////////////////////////////////////////////////////////////*\n* 8 bytes binary RBA due to Extended Format and OPTCD=(XRBA)\nDCCIRBAR DS    F                  HO part of XRBA\nDCCIRBAC DS    F                  RBA OF THE RETRIEVED DATA CI\n*/////////////////////////////////////////////////////////////////////*\nVPLENGTH DS    F                  VERTICAL POINTER LENGTH IN AN INDEX\n*                                 ENTRY\nIXECILEN DS    F                  INDEX ENTRY CONTROL INFO.LENGTH\nCISIZE   DS    F                  CISIZE FOR THE RPTTSDL SUBROUTINE\nCISIZED  DS    F                  DATA COMPONENT CISIZE\nCISIZEI  DS    F                  INDEX COMPONENT CISIZE\n         SPACE\n* INDEX (SEQUENCE SET) SPACE UTILIZATION SUMMARY\n*/////////////////////////////////////////////////////////////////////*\nIXSUS    DS    0CL16              4 FULLWORDS (LOCATION DEPENDENT)\nIXUSPC   DC    2F'0'              USED SPACE IN IX SS in bytes\nIXCIFSP  DC    2F'0'              CI FREE SPACE in IX SS\n         DC    F'0'               n/a (CA free CIs)\n         DC    F'0'               n/a\nIX#CISS  DC    F'0'               # of IX SS CIs\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n* DATA COMPONENT SPACE UTILIZATION SUMMARY\n* has now 8 bytes binary counts (used space and CI free space only)\n* This is to support EF datasets larger than 4GB.\n*/////////////////////////////////////////////////////////////////////*\nDCSUS    DS    0CL36              9  FULLWORDS (LOCATION DEPENDENT)\nDCUSPC   DC    2F'0'              Used space DATA COMPONENT in bytes\nDCCIFSP  DC    2F'0'              CI FREE SPACE in bytes\nDC#CAFCI DC    F'0'               # of CA free CIs\nDC#IXRSC DC    F'0'               # of UNUSED CI'S due to IX CI SHORT\nDC#UCI   DC    F'0'               # of USED CI'S in DATA component\n*                                 The below is not a part of SUS\nDC#CA    DC    F'0'               NUMBER OF PROCESSED (USED CA'S)\n*                                 IN THE DATA COMPONENT\nDC#CAFR  DC    F'0'               NUMBER OF FREE (UNUSED) CA'S AT\n*                                 THE END OF THE DATA SET\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n* DATA COMPONENT CONTROL AREA SPACE UTILIZATION SUMMARY\n* has now 8 bytes binary counts (used space and CI free space only)\n* This is to support EF datasets larger than 4GB.\n* (8 bytes are not required for a CA, however it has to match\n*  the SUS DSECT).\n*/////////////////////////////////////////////////////////////////////*\nCASUS    DS    0CL(CASUSE-CAUSPC) 7 FULLWORDS (LOCATION DEPENDENT)\nCAUSPC   DC    2F'0'              Used space DATA COMPONENT in bytes\nCACIFSP  DC    2F'0'              CI FREE SPACE in bytes\nCA#FCI   DC    F'0'               NUMBER OF FREE CI'S IN THE CA\nCA#IXRSC DC    F'0'               # of UNUSED CI'S due to IX CI SHORT\nCA#UCI   DC    F'0'               NUMBER OF USED CI'S IN THE CA\nCASUSE   EQU   *\n* The CI counts above are split into two halfwords becasue\n* that is how they are used by the code (as halfwords)\n*/////////////////////////////////////////////////////////////////////*\n*\n* WORK FIELDS FOR THE CURRENT CA: USED TO MAKE AN ASSUMPTION THAT\n* NEXT SECTION OF INDEX COULD NOT BE CREATED AND THAT ALL CI'S\n* CANNOT BE ADDRESSED BY THIS SS IX RECORD\n*\nSUSTOTB  DS    F             A work field, total bytes or KiB in SUS\nCAIXRFSP DC    F'0'              IX SS RECORD: FREE SPACE IN THIS REC\nCAIXRLSL DC    H'0'              IX SS RECORD: LAST IX SECTION LENGTH\n*                                 (LAST SECTION CONTROL FIELD VALUE)\n*\n* Control Area processing flags\nCAFLAGS  DC    X'00'              Control Area processing flags\nCAFFDRP  EQU   X'01'              First data CI in this CA has\n*                                 been processed (used for low/high\n*                                 key report processing)\nEAKSDS   EQU   X'02'              Extended Addressability KSDS flag\n* (means it can be > 4GB)         (the flag is NOT CA related)\nGT4GiB   EQU   X'04'              Total files size > 4GB\n*                                 (this will result in rounding of\n*                                 byte counts to 1KiB)\nLHKFOUND EQU   X'08'              A LOW/HIGH key found in this CA\n*                                 (this is to detect and empty CA)\n         SPACE\nLHKRDB   DS    6F                 LHKR DEFINITION BLOCK\n         ORG   LHKRDB\n*/////////////////////////////////////////////////////////////////////*\nLHKRDCBA DC    A(LHKR)            DCB ADDRESS\nLHKRLPL  DC    A(RPTLPP)          LHKR LINES PER PAGE LIMIT\nLHKRLCNT DC    A(RPTLPP)          LHKR LINE COUNT (FORCE FIRST HEADER)\nLHKRPGN  DC    A(1)               LHKR PAGE NUMBER\nLHKRHTA  DC    A(LHKRHLT)         PAGE HEADER LINE TEXT ADDRESS\nLHKRHTA1 DC    A(0)               NO SECOND HEADER LINE FOR THIS RPT\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n* Low/high key report print line\n* The record length will be set to (LHKL1KEY-LHKL1) + key length\n* After KSDS ACB open\nLHKL1    DC    AL2(LHKL1E-LHKL1)  Low/high key print line\n         DC    AL2(0)\nLHKL1CA# DC    X'4020202020202120' Control Area number\nLHKL1CI# DC    X'402020202020202020202120' relative CI# of this data CI\n         DC    X'40'\nLHKL1KEY DS    CL255              Low/High key (max 255 chars)\nLHKL1E   EQU   *\nEMPTYCA  DC    C'***** EMPTY Control Area *****'\nEMPTYCAS DS    CL2 work field to save the above record length\n         SPACE\nRPPTMSK1 DC    X'4020206B2020206B2020206B202120' edit mask for RPPT\n* Should be the same as RPTTL1U field            count fields\n         LTORG\n* This is a CSECT with some control blocks/ data in order to relieve\n* somewhat addressability constraints (we are approaching the 2 base\n* registers limit).\nKSDSPACD CSECT\n*\n* CAMLST FOR OBTAIN MACRO. OBTAIN READS 96 BYTES DATA PORTION OF FMT1\n* DSCB (STARTING ON DS1FMTID, THAT'S WHY DS1FMTID IS CODED IN WORKAREA\n* PARM OF CAMLST). OBTAIN WILL READ DATA INTO THE AREA GENERATED BY\n* IECSDSL1 MACRO.\nCAMLSTO  CAMLST SEARCH,DS1DSNAM,DS1DSSN,DS1FMTID\n         IECSDSL1 (1)           FORMAT 1 DSCB DATA SET NAME AND BUFFER\n         DS    CL(140-(DS1END-DS1FMTID)) OBTAIN WORKAREA HAS TO BE 140\n*              BYTES. THIS PADDS THE REQUIRED BYTES\n         SPACE\nRPTGHLT  DC    AL1(L'RPTGHLTT)    LENGTH OF THE HEADER LINE TEXT\nRPTGHLTT DC    C'KSDSPACE - RPTG: SPACE DISTRIBUTION IS SHOWN IN GRAPHI+\n               CAL FORM'\n         SPACE\nRPTTHLT  DC    AL1(L'RPTTHLTT)    LENGTH OF THE HEADER LINE TEXT\nRPTTHLTT DC    C'KSDSPACE - RPTT: SPACE DISTRIBUTION IS SHOWN IN BYTES/+\n               CI# AND PRECENTAGES OF TOTAL'\n         SPACE\nRPTTL1H  DC    AL2(RPTTL1HE-RPTTL1H)  RPPT LINE 1 HEADER\n         DC    AL2(0)\nRPTTL1HA DC    C'-'               THREE LINES SPACING\n         DC    CL15'     USED SPACE'\n         DC    C'  ('\n         DC    CL5'   % '         PERCENTAGE OF TOTAL SPACE\n         DC    C')            #CI   '\n         DC    CL15'   FREESPACE-CI'       CI FREE SPACE\n         DC    C' ('\n         DC    CL5'   % '         PERCENTAGE OF TOTAL SPACE\n         DC    C')   '\n         DC    C' FREESPACE-CA%'     CA FREE SPACE % of total\n         DC    C'      #CI'\n         DC    C'   IX REC SHORT%'  INDEX RECORD SHORT % of total\n         DC    C'       #CI'\nRPTTL1HE EQU   *\n         SPACE\nEMPTM1   DC    AL2(EMPTM1E-EMPTM1) EMPTY KSDSFILE ERROR MESSAGE\n         DC    AL2(0)\nEMPTM1C  DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\nEMPTM1T  DC    C'INPUT KSDS DATA SET IS EMPTY. PROCESSING TERMINATED'\nEMPTM1E  EQU   *\n         SPACE\nDMSGHLT  DC    AL1(L'DMSGHLTT)    LENGTH OF THE HEADER LINE TEXT\nDMSGHLTT DC    C'KSDSPACE - DIAGNOSTIC MESSAGES'\n         SPACE\nLHKRHLT  DC    AL1(LHKRHLTE-LHKRHLTT)  LENGTH OF THE HEADER LINE TEXT\nLHKRHLTT DC    C'     CA#     CI#    Low/High data record key '\n         DC    C'in CA, KeyLength=' +\nLHKRHLKL DC    X'4020202020202120' Key length\nLHKRHLTE EQU   *\n         SPACE\n*  LHKR (LO/High key per CA) report output file\n*  Max possible key lenght is specified. It will be adjusted/changed\n*  after VSAM KSDS ACB open\nLHKR     DCB   DSORG=PS,MACRF=PM,DDNAME=LHKR,RECFM=VBA,                +\n               EXLST=MSGEXLST,LRECL=(LHKL1E-LHKL1)\n         SPACE\n*  MESSAGE SEQL DATA SET\nMSGFILE  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=VBA,            +\n               LRECL=137,EXLST=MSGEXLST\nMSGEXLST DS    0F\n         DC    X'85',AL3(MSGDCBEX) EXIT FOR BLKSIZE NOT SPECIFIED\n         SPACE\n*  RPTG SEQL DATA SET\nRPTG     DCB   DSORG=PS,MACRF=PM,DDNAME=RPTG,RECFM=VBA,                +\n               LRECL=137,EXLST=MSGEXLST\n         SPACE\n*  RPTT SEQL DATA SET\nRPTT     DCB   DSORG=PS,MACRF=PM,DDNAME=RPTT,RECFM=VBA,                +\n               LRECL=137,EXLST=MSGEXLST\n         SPACE\nMSGDCBEX DS    0H                 EXIT IF BLKSIZE NOT SPECIFIED        +\n                                  MSG AND REPORT DATA SETS\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         LH    R2,DCBBLKSI        LOAD BLKSIZE\n         LTR   R2,R2              BLKSIZE=0 ..........................?\n         BNZR  R14                NO,RETURN <----------------\n         LH    R2,DCBLRECL        LRECL\n         LA    R2,4(,R2)          BLKSIZE = LRECL + 4 (RECFM=VB)\n         STH   R2,DCBBLKSI        BLKSIZE=LRECL+4======================\n         BR    R14                RETURN    <----------------\n         DROP  R1\n         SPACE\nRPLIX    RPL   ACB=VSAMF,              RPL TO READ AN INDEX SS CI      +\n               AREA=IXCIADDR,AREALEN=4,  FIELD FOR CI ADDRESS          +\n               ARG=IXCIRBAX,             FIELD FOR XRBA                +\n               OPTCD=(CNV,DIR,NUP,LOC,XRBA)\n         SPACE\nRPLDC    RPL   ACB=VSAMF,              RPL TO READ DATA COMPONENT      +\n               AREA=DCCIADDR,AREALEN=4,  FIELD FOR CI ADDRESS          +\n               OPTCD=(CNV,SEQ,NUP,LOC,XRBA)\n         SPACE\nCSIERRM  DC    AL2(CSIERRME-CSIERRM) CSI call ERROR MSG\n         DC    AL2(0)\n         DC    C'0CSI call error occurred: R15=x'\nCSIEMR15 DS    CL8                RC CODE IN R15\n         DC    C' ModID='\nCSIEMID  DS    CL2                Catalog module id\n         DC    C' RsnCode=x'\nCSIERSNC DS    CL2                CSI REQUEST reason code\n         DC    C' RetCode=x'\nCSIEMRETC DS   CL2                CSI REQUEST return code\nCSIERRME EQU   *\n         SPACE\nCSIERRM1 DC    AL2(CSIERRME1-CSIERRM1) CSI call ERROR MSG\n         DC    AL2(0)\n         DC    C'0Will assume this KSDS does not have Extended'\n         DC    C' Addressability'\nCSIERRME1 EQU   *\n         SPACE\nIGGCSIMA DC    V(IGGCSI00)        IGGCSI00 SUBROUTINE address\n**********************************************************************\n*                                                                    *\n* PARAMETER LIST FOR IGGCSI00 INVOCATION                             *\n*                                                                    *\n**********************************************************************\n*\nCSIPARML DS    0D\n         DC    A(CSIMRSRT)        MODULE/REASON/RETURN\n         DC    A(CSIFIELD)        CSI selection criteria fields\n         DC    A(CSIRWORK)        data returned from CSI\n*\n**********************************************************************\n*                                                                    *\n* MODULE ID/REASON CODE/RETURN CODE from CSI                         *\n*                                                                    *\n**********************************************************************\n*\nCSIMRSRT    DS 0F\nCSIMRC      DS 0CL4\nCSIMODID    DC XL2'0000'     MODULE ID\nCSIRSNCODE  DC XL1'00'       REASON CODE\nCSIRTNCODE  DC XL1'00'       RETURN CODE\n**********************************************************************\n*                                                                    *\n* PARAMETER FIELDS FOR CATALOG SEARCH INTERFACE (CSI)                *\n*                                                                    *\n**********************************************************************\n*\nCSIFIELD    DS 0F\nCSIFILTK    DC CL44'**'  FILTER   KEY\nCSICATNM    DC CL44' '        CATALOG NAME OR BLANKS\nCSIRESNM    DC CL44' '        RESUME NAME OR BLANKS\nCSIDTYPD    DS 0CL16          ENTRY TYPES\nCSIDTYPS    DC CL16'C               ' Cluster only\nCSIOPTS     DS 0CL4           CSI OPTIONS\nCSICLDI     DC CL1' '         RETURN D&I IF C A MATCH Y OR BLNK\nCSIRESUM    DC CL1' '         RESUME FLAG         Y OR BLANK\nCSIS1CAT    DC CL1'Y'         SEARCH CATALOG      Y OR BLANK\nCSIOPTNS    DC CL1' '         halfword lengths entries\nCSINUMEN    DC AL2((CSIENTSE-CSIENTS)/8)  NUMBER OF ENTRIES FOLLOWING\nCSIENTS     DS 0CL8           VARIABLE NUMBER OF ENTRIES FOLLOW\nCSIFLDNM1   DC CL8'XACIFLAG'  Extended attribute flags\nCSIENTSE    DS 0CL1           end of ENTRIES label\n*\nCSIRWORK    DS 0F             CSI Return Work Area\nCSIUSRLN    DC A(CSIRWORKE-CSIRWORK)     Work Area length\nCSIREQLN    DS F              Minimum work area length (1 entry\n*                             for catalog + 1 entry)\nCSIUSDLN    DS F              length of work area used\nCSINUMFD    DS H              Number of field names plus 1\n* INFORMATION RETURNED FOR EACH CATALOG\nCSICFLG     DS CL1            Catalog flag information\nCSICTYPE    DS CL1            Catalog type. X'F0'\nCSICNAME    DS CL44           Catalog name\nCSICRETN    DS 0CL4           Return information for Catalog\nCSICRETM    DS CL2            Catalog module id\nCSICRETR    DS CL1            Catalog return reason code\nCSICRETC    DS CL1            Catalog return code\n* INFORMATION RETURNED FOR EACH ENTRY\nCSIEFLAG    DS XL1            Entry flag information\nCSIENTER    EQU B'01000000'   Error indication is set for this entry\nCSIEDATAR   EQU B'00100000'   Data is returned for this entry\nCSIETYPE    DS CL1            Entry type\nCSIENAME    DS CL44           Entry name\nCSIERETN    DS 0CL4           Error return information if CSIENTER=1\n* CSIERETN exists only if CSIENTER=1, hence the ORG below\nCSIERETM    DS CL2            Entry return module ID\nCSIERETR    DS CL1            Entry return reason code\nCSIERETC    DS CL1            Entry return code\n*\n            ORG CSIERETN\n* CSIOPTNS IS NOT F\nCSIEDATA    DS 0CL1           Returned data for entry if CSIENTER=0\nCSITOTLN    DS AL2            Total length of returned information\n            DS CL2            reserved\nCSILENFD    DS 0CL1           Length of fields\nCSILENF1    DS AL2            First length field\n*\n* INFORMATION RETURNED FOR EACH FIELD NAME\nCSIFDDAT    DS 0CL1           Field data\nCSIFEAFLG   DS CL1            Extended attribute flags\nCSIFEA4GB   EQU B'01000000'   Extended Addressability flag\n*                             (Data set can be greater than 4GB)\n*\n            DS CL(1024-(*-CSIRWORK)) minimum work area length=1024\nCSIRWORKE   DS 0CL1           CSI Return Work Area end label\n*\n         SPACE\n*\n DC C'\"COPYRIGHT (C) 2002 by Jan (Janek) Jakubek. '\n DC C'ALL RIGHTS  RESERVED EXCEPT:  PARTICULAR LICENSE IS GRANTED TO '\n DC C'DISTRIBUTE THIS PROGRAM FREE OF CHARGE, '\n DC C'BUT IT MUST NOT BE SOLD.\"'\n*\nCODENDS  EQU   *\n         SPACE\n* VSAM ACCESS METHOD DATA SET STATISTICS BLOCK\nAMDSB    DSECT\nAMDSBID  DS    XL1                CONTROL BLOCK IDENTIFIER, X'60'\nAMDATTR  DS    XL1                ATTRIBUTES OF THE DATA SET:\nAMDDST   EQU   X'80'              KEY-SEQUENCED DATA SET\nAMDWCK   EQU   X'40'              CHECK EACH RECORD WHEN IT IS WRITTEN\nAMDSDT   EQU   X'20'              SEQUENCE SET IS STORED WHITH THE\n*                                 DATA AND REPLICATED\nAMDREPL  EQU   X'10'              ALL INDEX RECORDS ARE REPLICATED\nAMDORDER EQU   X'08'              USE THE VOLUMES IN THE SAME ORDER\n*                                 AS IN THE VOLUME LIST\nAMDRANGE EQU   X'04'              THE DATA SET IS DIVIDED INTO KEY\n*                                 RANGES\nAMDRRDS  EQU   X'02'              RELATIVE RECORD DATA SET\nAMDSPAN  EQU   X'01'              THE DATA SET CONTAINS SPANNED RECORDS\nAMDLEN   DS    XL2                LENGTH OF THE AMDSB\nAMDNEST  DS    XL2                NUMBER OF INDEX ENTRIES IN THE INDEX\n*                                 SECTION\nAMDRKP   DS    XL2                RELATIVE KEY POSITION\nAMDKEYLN DS    XL2                KEY LENGTH\nAMDPCTCA DS    XL1                % OF FREE CI IN THE CA\nAMDPCTCI DS    XL1                % OF FREE BYTES IN THE CI\nAMDCIPCA DS    XL2                NO. OF CONTROL INTERVALS IN A CA\nAMDFSCA  DS    XL2                NO. OF FREE CONTROL INTERVALS IN A CA\nAMDFSCI  DS    XL4                NO. OF FREE BYTES IN A CI\nAMDCINV  DS    XL4                CONTROL INTERVAL SIZE\nAMDLRECL DS    XL4                MAXIMUM RECORD LENGTH\nAMDHLRBA DS    XL4                RBA OF THE HIGH-LEVEL INDEX RECORD\nAMDNSLOT EQU   AMDHLRBA           NO. OF RECORD SLOTS PER CI\nAMDSSRBA DS    XL4                RBA OF THE FIRST SEQUENCE-SET RECORD\nAMDPARDB DS    XL4                ADDRESS OF THE FIRST ARDB\nAMDSTAT  DS    0CL56              DATA SET STATISTICS\nAMDATTR3 DS    XL1                ATTRIBUTES OF THE DATA SET\nAMDUNQ   EQU   X'80'              THE DATA SET HAS NONUNIQUE KEYS\nAMDLM    EQU   X'08'              DATA SET IS LOADED\nAMDSTRNO DS    XL1                NO.OF CONCURRENT REQUESTS\nAMDDUI   DS    XL4                IMS DBRC USAGE INDICATOR\nAMDBFNO  DS    XL2                NUMBER OF BUFFERS\nAMDSTSP  DS    XL8                SYSTEM TIME STAMP\nAMDNIL   DS    XL2                NUMBER OF INDEX LEVELS\nAMDNEXT  DS    XL2                NUMBER OF EXTENTS IN THE DATA SET\nAMDNLR   DS    XL4                NUMBER OF USER SUPPLIED RECORDS\nAMDDELR  DS    XL4                NUMBER OF DELETED RECORDS\nAMDIREC  DS    XL4                NUMBER OF INSERTED RECORDS\nAMDUPR   DS    XL4                NUMBER OF UPDATED RECORDS\nAMDRETR  DS    XL4                NUMBER OF RETRIEVED RECORDS\nAMDASPA  DS    XL4                NO.OF BYTES OF FREE SPACE\nAMDNCIS  DS    XL4                NO.OF CI SPLITS\nAMDNCAS  DS    XL4                NO.OF CA SPLITS\nAMDEXCP  DS    XL4                NO.OF EXCPS ISSUED BY VSAM ROUTINES\n         SPACE\n* ACCESS METHOD BLOCK\nAMB      DSECT\nAMBID    DS    XL1                CONTROL BLOCK IDENTIFIER, X'40'\nAMBRSC   DS    XL1                RESOURCE TS BYTE\nAMBLEN   DS    XL2                LENGTH OF THE AMB\nAMBLINK  DS    XL4                ADDRESS OF THE NEXT AMB IN THE CHAIN\nAMBBUFC  DS    XL4                ADDRESS OF THE BUFC HEADER\nAMBPH    DS    XL4                ADDRESS OF PLH HEADER\nAMBCACB  DS    XL4                ADDRESS OF THE VSAM CATALOG'S ACB\nAMBDSB   DS    XL4                ADDRESS OF THE AMDSB\nAMBEOVR  DS    XL1                END-OF-VOLUME REQUEST TYPE\nAMBFLG0  EQU   AMBEOVR            MVM AMB FLAGS:\nAMBPSDS  EQU   X'80'              PAGE SPACE\nAMBSWSP  EQU   X'40'              SWAP SPACE\nAMBSHR1  EQU   X'20'              SHARE OPTION\nAMBFLG1  DS    XL1                INDICATOR FLAGS:\nAMBCREAT EQU   X'80'              THE OBJECT IS BEING CREATED (LOADED)\nAMBTYPE  EQU   X'40'              THE AMB DESCRIBES THE KSDS INDEX\nAMBMCAT  EQU   X'20'              THE AMB DESCRIBES THE MASTER CATALOG\nAMBUCAT  EQU   X'10'              THE AMB DESCRIBES A USER CATALOG\nAMBSPEED EQU   X'08'              SPEED OPTION\nAMBUBUF  EQU   X'04'              USER BUFFERING HAS BEEN SPECIFIED\nAMBJRN   EQU   X'02'              EXLST HAS A JOURNALING EXIT RTN ADDR\nAMBINBUF EQU   X'01'              THE DATA SET IS SHARED - DIRECT BUF\nAMBDSORG DS    XL2                DATA SET ORGANIZATION INDICATORS\nAMBIOMB  DS    XL4                ADDRESS OF THE IOMB\nAMBCDSN  DS    XL3                DSN OF THE CATALOG\nAMBDDSN  DS    XL3                DSN OF OBJECT ASSOC.WITH THE AMB\n         DS    XL2                RESERVED\nAMBTIOT  DS    XL2                OFFSET TO TIOT\nAMBINFL  DS    XL1                INDICATOR FLAGS\nAMBCAT   EQU   X'10'              THE AMB DESCRIBES A CATALOG\nAMBSCRA  EQU   X'08'              CRA IS IN SYSTEM STORAGE\nAMBUCRA  EQU   X'04'              CRA IS IN USER'S STORAGE\nAMBUPX   EQU   X'02'              AN UPGRADE TABLE (UPT) EXISTS\nAMBSDS   EQU   X'01'              SYSTEM DATA SET\nAMBAMETH DS    XL1                VSAM ACCESS METHOD INDICATOR\nAMBDEBPT DS    0XL4               DEB ADDRESS\nAMBIFLGS DS    XL1                ERROR FLAGS\nAMBDEBAD DS    XL3                DEB ADDRESS\nAMBOFLGS DS    XL1                OPEN STATUS FLAGS:\nAMBOPEN  EQU   X'10'              THE AMB IS OPEN\nAMBEXFG  EQU   X'02'              USER EXIT ROUTINES ARE ACTIVE\nAMBBUSY  EQU   X'01'              BUSY BIT\nAMBFLG2  DS    XL1                FLAG BYTE 2:\nAMBPUG   EQU   X'80'              DATA SET IS AN AIX IN AN UPGRADE SET\nAMBSHR   EQU   X'40'              DATA SET USING SHARE OPTIONS 3 OR 4\nAMBUP    EQU   X'20'              UPAD IS PRESENT\nAMBRPT   DS    XL2\nAMBEDB   DS    XL4                ADDRESS OF THE EDB\nAMBEOVPT DS    XL4                ADDRESS OF THE AMBXN FOR AN EOV REQ.\nAMBAMBXN EQU   AMBEOVPT           POINTER TO AMB EXTENTION IN MVB\nAMBWKA   DS    XL4                ADDRESS OF THE AMB WORK AREA\nAMBIWA   DS    XL4                ADDRESS OF THE DIWA\nAMBIOBA  DS    XL4                ADDRESS OF THE IOB\nAMBSVI   EQU   AMBIOBA            OBJECT VSI POINTER\nAMBPIXP  DS    XL4                ADDRESS OF THE INDEX'S AMB\nAMBPAMBL DS    XL4                ADDRESS OF THE PRIMARY AMBL\nAMBUPLH  DS    XL4                ADDRESS OF UPGRADE PLACEHOLDER\nAMBAFLG  DS    XL1                FLAG BYTE:\nAMBLSR   EQU   X'40'              LOCAL SHARED RESOURCES\nAMBGSR   EQU   X'20'              GLOBAL SHARED RESOURCES\nAMBICI   EQU   X'10'              IMPROVED CONTROL-INTERVAL ACCESS\nAMBDFR   EQU   X'08'              DEFER WRITE OPERATIONS\nAMBSIS   EQU   X'04'              SEQUENTIAL INSERT STRATEGY\nAMBCFX   EQU   X'02'              CONTROL BLOCKS FIXED IN REAL STORAGE\n         DS    XL1                RESERVED\nAMBRDCNT DS    XL2                RESERVED\nAMBBM2SH DS    XL4                RESERVED\nAMBCPA   DS    XL4                LSR - ADDRESS OF THE WSHD\n*                                 NSR - ADDR OF THE FIRST CPA IN CHAIN\nAMBWSHD  DS    XL4                ADDR OF WORKING STORAGE HEADER\nAMBEXEX  DS    XL8                NAME OF USER EXCPETION EXIT ROUTINE\nAMBSZRD  DS    XL2                SIZE OF THE CHANNEL PROG. FOR READ\nAMBSZWR  DS    XL2                SIZE OF THE CHANNEL PROG. FOR WRITE\nAMBSZFW  DS    XL2               SIZE OF THE CHAN.PROG.FOR FORMAT WRITE\nAMBSZCP  DS    XL2                SIZE OF THE CPA BASE\nAMBVIOT  DS    XL4                ADDR OF THE VALID-IOMB TABLE\nAMBTRACE DS    XL4                ADDRESS OF TRACE TABLE\nAMBPAL   DS    XL3                PRIMARY ALLOCATION QUANTITY\n         DS    XL1                RESERVED\nAMBBSAL  DS    XL3                SECONDARY ALLOCATION QUANTITY\n         DS    XL1                RESERVED\nAMBSOPT  DS    XL1                ALLOCATION OPTION\nAMBRNLEN DS    0XL3               RNAME LENGTHS\nAMBRLN   DS    XL1                LENGTH OF RNAME\nAMBDSLN  DS    XL1                LENGTH OF DSNAME\nAMBCATLN DS    XL1                LENGTH OF CATALOG DSNAME\nAMBDSNM  DS    CL44               COMPONENT NAME\nAMBUPAD  DS    XL4                POINER TO UPAD ROUTINE\nAMBJRNAD DS    XL4                POINER TO JRNAD ROUTINE\n         SPACE\n* ADDRESS RANGE DEFINITION BLOCK\nARDB     DSECT\nARDID    DS    XL1                CONTROL BLOCK ID, X'61'\nARDTYPE  DS    XL1                TYPE OF SPACE DEFINED BY THE ARDB:\nARDKR    EQU   X'80'              ONE KEY RANGE OF A KEY-RANGE DATA SET\nARDHLI   EQU   X'40'              THE TOTAL INDEX OF A KSDS, OR\n*                                 NON SS INDEX PART IF SS IS IMBEDED\nARDSS    EQU   X'20'              THE SS OF A KSDS IF SS IS IMBEDED\nARDUOVFL EQU   X'10'              OVERFLOW MAY BE USED FOR THIS KEY RNG\nARDEOD   EQU   X'08'              KEY RANGE WITH HIGHEST DATA RBA\nARDUSED  EQU   X'04'              THE ARDHRBA INITIAL VALUE HAS CHANGED\nARDUPD   EQU   X'02'              ARDB MODIFIED\nARDLEN   DS    XL2                LENGTH OF THE ARDB\nARDNPTR  DS    XL4                POINTER TO NEXT ARDB IN THE CHAIN\nARDHKRBA DS    XL4                RBA OF DATA CI WITH HIGHEST KEY\nARDHRBA  DS    XL4                RBA OF NEXT FREE SPACE CI AT THE EOF\nARDERBA  DS    XL4                RBA OF THE HIGHEST CI ALLOCATED\nARDVOLSR DS    CL6                VOLSER WITH HIGHEST RBA ALLOCATED\nARDRELNO DS    XL2                SEQ.NO.OF THE DATA SET GROUP SET\nARDPRF   DS    XL1                PREFORMAT FLAGS:\nARDPRSS  EQU   X'80'              THE SS IS STORED WITH DATA\nARDPRFMT EQU   X'40'              THE KEY RANGE'S EXTENTS HAS BEEN\n*                                 PREFORMATTED\nARDKEYS  DS    0XL1               LOW AN HIGH KEY VALUES (2 * KEYLEN)\n         SPACE\n* INDEX RECORD HEADER DSECT\nIXHDR    DSECT\nIXHLL    DS    XL2                IX RECORD LENGTH (CI SIZE - 7)\nIXHFLPLN DS    XL1                LENGTH OF CONTROL INFO. IN EACH\n*                                 INDEX ENTRY (IBFLPF, IBFLPL, IBFLP3)\nIXHPTLS  DS    XL1                VERTICAL POINTERS LENGTH\nIXHBRBA  DS    XL4                SS - RBA OF THE DATA CA\nIXHHP    DS    XL4                HORIZONTAL POINTER (RBA) TO NEXT REC.\nIXHXX    DS    XL4                RESERVED\nIXHLV    DS    XL1                INDEX LEVEL NUMBER ( = 1 FOR SS )\nIXHFLGS  DS    XL1                RESERVED\nIXHFSO   DS    XL2                FREE SPACE OFFSET (IN THIS CI)\nIXHLEO   DS    XL2                LAST INDEX ENTRY OFFSET\nIXHSEO   DS    XL2                OFFSET OF THE LAST ENTRY IN THE FIRST\n*                                 SECTION\n         SPACE\n* SPACE UTILIZATION SUMMARY (FOR CA, SS, DATA SET)\nSUS      DSECT\nUSPC     DC    2F'0'              Used space DATA COMPONENT in bytes\nCIFSP    DC    2F'0'              CI FREE SPACE in bytes\nCAFSPCI# DC    F'0'               # of CA free space CIs\nIX#SFCI  DC    F'0'               # of UNUSED CI'S due to IX CI SHORT\n#UCIS    DC    F'0'               # of USED CI'S in DATA component\n         SPACE\n* CONTROL INTERVAL DEFINITION FIELD FORMAT\nCIDF     DSECT\nCIDFOSET DS    XL2                OFFSET OF UNUSED SPACE OR CNTRL INFO.\n*                                 (= RECL (CI-7) FOR IX)\nCIDF11   DS    XL2                LENGTH OF UNUSED SPACE (=0 FOR IX)\n         SPACE\n* INDEX ENTRY CONTROL INFORMATION FORMAT\nIXECIFMT DSECT\nIBFLPF   DS    XL1                FRONT-KEY COMPRESSION COUNT\nIBFLPL   DS    XL1                LENGTH OF IXKEY FIELD IN THIS ENTRY\nIBFLP3   DS    XL3                POINTER TO DATA CI (1 TO 3 BYTES)\n*                                 This is data CI number in this CA\n*                                 (beginning at 0)\n         SPACE\n* DATA CI Record Definition Field pair (Left and Right)\n* If RDF is not paired - there is only the one (Right) RDF\nRDF      DSECT\n* Left  RDF\nLRDFF    DS    XL1                Control field (flags)\n*                                 For spanned records:\nLRDFFS   EQU   X'10'              - first segment\nLRDFLS   EQU   X'20'              - last  segment\nLRDFIS   EQU   X'30'              - intermediate segment\nLRDF#R   EQU   X'08'              Non spanned: # of recs of same length\n*                                 Spanned recs: segment update #\nLRDF#    DS    XL2          Fixed length non spanned: # of records\n*                           Spanned : segment update number\n* Right RDF\nRRDFF    DS    XL1                Control field (flags)\nRRDFP    EQU   X'40'              a paired RDF to the left of this one\n*                                 For spanned records:\nRRDFFS   EQU   X'10'              - first segment\nRRDFLS   EQU   X'20'              - last  segment\nRRDFIS   EQU   X'30'              - intermediate segment\nRRDF#    DS    XL2                record/segment/slot length\n         SPACE\n* REPORT DEFINITION BLOCK\n* ALLOWS TO USE ONE PROCEDURE TO PRINT RPTG, RPTT, AND MESSAGES\nRPTDB    DSECT\n*/////////////////////////////////////////////////////////////////////*\nRPTDCBA  DS    A                  DCB ADDRESS\nRPTLPL   DS    A(RPTLPP)          RPTG LINES PER PAGE LIMIT\nRPTLCNT  DS    A(RPTLPP)          RPTG LINE COUNT (FORCE FIRST HEADER)\nRPTPGN   DS    A(1)               RPTG PAGE NUMBER\nRPTHTA   DS    A                  PAGE HEADER LINE TEXT ADDRESS\nRPTHTA1  DS    A                  SECOND HEADER LINE ADDRESS\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n* This is table for IXRPT proc (print # of Index records per IX level)\nIXLVLT   DSECT\nIXLVLR#  DS    H                  # of IX records per level (as many\n*                                 entries as index levels)\n         SPACE\n         IFGRPL DSECT=YES,AM=VSAM       RPL LAYOUT\n         SPACE\n         DCBD  DSORG=PS\n         SPACE\n         CVT   DSECT=YES                CVT MAPPING MACRO\n         SPACE\n         END   KSDSPACE\n/*\n//*\n//* IGGCSI00 is being linked due to KSDSPACE being AMODE=24\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF,AC=1'\n//SYSLMOD  DD DISP=SHR,DSN=...your.loadlib....\n//LINKLIB  DD DISP=SHR,DSN=SYS1.LINKLIB\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n INCLUDE LINKLIB(IGGCSI00)\n ENTRY KSDSPACE\n NAME  KSDSPACE(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KSDSPACO": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x010\\x00#\\x00\\x993\\x7f\\x01\\x024_\\x08#\\x08\\xe2\\x07I\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.48", "flags": 0, "createdate": "1999-12-03T00:00:00", "modifydate": "2002-12-11T08:23:23", "lines": 2274, "newlines": 1865, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....YOUR JOBCARD......\n//*\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,NOALIGN,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'KSDS FILE SPACE DISTRIBUTION ANALYSIS ROUTINE'\n* KSDS FILE SPACE DISTRIBUTION ANALYSIS ROUTINE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* THIS VERSION DOES A SEQUENTIAL PROCESSING OF THE DATA COMPONENT     *\n* RESULTING IN BETTER PERFORMANCE (VSAM BUFFER READ AHEAD) IF EXTRA   *\n* DATA BUFFERS ARE SPECIFIED.                                         *\n*                                                                     *\n* Older version of KSDSPACE. Should run on unsupported levels of      *\n* DFSMS (1.2 or less). It does not work with Extended format KSDS.    *\n* I saved it just in case there is a poor soul out there running      *\n* unsuppoted level of OS/390 or MVS/SP.                               *\n* I recently discovered that this version does not work with EF format*\n* KSDS (due to IX RBAs representing relative CI number rather than    *\n* bytes, which I didn't know, and is undocumented in z/OS 1.3 level   *\n* Using Datasets manaul). This could easly be fixed (and it is fixed  *\n* in current KSDSPACE) - however I do not have motivation to do it    *\n* (I do not know of anybody running DFSMS 1.2 or less).               *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME:       KSDSPACE\n*\n* ATTRIBUTES :       STANDARD (NOT AUTHORIZED) *** SEE NOTE #1 ***\n*                    RMODE 24\n*                    AMODE 24\n*\n* ASSEMBLER OPTIONS: NOALIGN\n*\n* Notes:\n* 1. If KSDSPACE is linkedited with AC=1 into an APF authorized\n*    LOADLIB - it can process BCS of an ICF catalog as well.\n*    Alter authority to the catalog is also required in order\n*    to open it as a dataset.\n*\n* FUNCTION = SEE BELOW\n*\n*     THE PURPOSE OF THIS ROUTINE IT TO READ THE INDEX (SEQUENCE SET\n*  ONLY) AND DATA COMPONENTS OF A KSDS CLUSTER AND PRODUCE SPACE\n*  UTILIZATION REPORTS FOR:\n*  .EACH CONTROL AREA (DATA COMPONENT ONLY)\n*  .INDEX COMPONENT\n*  .THE WHOLE DATA COMPONENT\n*  TWO REPORTS ARE PRINTED: ONE WITH NUMERIC VALUES (TABLE LIKE FORMAT)\n*  AND ANOTHER WHERE SPACE DISTRIBUTION IS PRESENTED IN A GRAPHICAL\n*  FORMAT: A LINE IS PRINTED FOR EACH CONTROL AREA. IT REPRESENTS\n*  100% OF THE SPACE. DIFFERENT CHARACTERS REPRESENT BREAKDOWN OF\n*  THAT SPACE INTO THE FOLLOWING COMPONENTS:\n*\n*  * - SPACE OCCUPIED BY DATA RECORDS.\n*  - - UNUSED CONTROL INTERVALS RESULTING FROM CA FREE SPACE\n*      SPECIFICATION AND/OR CA SPLITS (OR RECORD DELETES).\n*  X - UNUSED SPACE IN CONTROL INTERVALS CONTAINING DATA RECORDS\n*      RESULTING FROM CI FREE SPACE SPECIFICATION AND/OR CI SPLITS\n*      (OR RECORD DELETES).\n*  + - UNUSED CONTROL INTERVALS RESULTING FROM LACK OF SPACE IN THE\n*      INDEX CI (INDICATION THAT INDEX CI IS TOO SMALL).\n*      THIS IS AN ESTIMATE ONLY - NOT A PRECISE VALUE AND IT CAN ONLY\n*      SHOW UP WHEN A CA IS FULLY LOADED (NO CA FREE SPACE).\n*\n*  \"-\", \"+\" WILL NEVER BE SHOWN FOR AN INDEX COMPONENT. ALSO, \"X\"\n*  HAS A DIFFERENT MEANING: EITHER INDEX CI IS TWO LARGE OR IT RESULTS\n*  FROM \"-\" TYPE FREE SPACE IN THE DATA COMPONENT.\n*\n*  THE REPORTS CAN BE USEFUL FOR TUNNING OF A KSDS FILE: CI SIZE\n*  SELECTION (BOTH INDEX AND DATA COMPONENTS), FREE SPACE\n*  SPECIFICATION, CA SIZE SPECIFICATION, AND TO MAKE A DECISION TO\n*  REORGANIZE A FILE.\n*\n*\n*\n*\n* RETURN CODES FROM THE PROGRAM:\n*     0 - NORMAL SUCCESSFUL COMPLETION\n*    16 - ERROR. CHECK MESSAGES IN SYSPRINT AND/OR SYSTEM LOG.\n*\n*\n*    THE FOLLOWING JCL PROCEDURE HAS BEEN CATALOGED AND CAN BE INVOKED\n*    TO RUN THIS PROGRAM:\n*\n*        //KSDSPACE PROC DISP=SHR,RPTT='SYSOUT=*',RPTG='SYSOUT=*',\n*        //              LHKR='SYSOUT=*'\n*        //KSDSPACE EXEC PGM=KSDSPACE\n*        //STEPLIB    DD DSN=SYS1.UTIL.LINKLIB,DISP=SHR\n*        //KSDS       DD DSN=&KSDS,DISP=&DISP\n*        //SYSPRINT   DD SYSOUT=*           Diagnostic MESSAGE FILE\n*        //RPTT       DD &RPTT              TABLE FORMAT REPORT\n*        //RPTG       DD &RPTG              GRAPHICAL FORMAT REPORT\n*        //LHKR       DD &RPTG              Low/High key     REPORT\n*    (LHKR can be wiritten to a DASD data set for viewing/editing,\n*     particulary if the key is non-printable/binary/numeric).\n*\n*    \"KSDS\" SYMBOLIC PARAMETER HAS TO SPECIFY THE NAME OF THE KSDS\n*    CLUSTER. STEPCAT/JOBCAT MAY BE REQUIRED TO LOCATE THE KSDS FILE.\n*    PARTICULAR REPORTS CAN BE SUPRESSED BY SPECIFYING RPTT/RPTG=DUMMY.\n*\n* WRITTEN BY:\n*            JAN (JANEK) JAKUBEK\n*     TEL  : 416-255-8807 (CANADA, ONTARIO)\n*     EMAIL: JAN.JAKUBEK@CGI.COM\n*\n* DATE WRITTEN: MARCH-APRIL 1989\n*\n* Known restrictions:\n* 1. Since the program uses Control Interval Access (OPTCD=CNV) -\n*    RLS and compressed datasets are not supported.\n* 2. Extended KSDS with RBA greater than 4GB is not supported since\n*    I DO NOT use OPRTCD=XRBA (I hope to fix this in the future.\n*    At the moment I think not everybody has OW43595 applied that\n*    added XRBA support).\n*\n* KNOWN PROBLEMS, NOT YET FIXED:\n* 1. EXTENDED FORMAT DATASETS SUPPORT ?\n*\n*\n* FUTURE ENHANCEMENTS IDEAS (in no particular order):\n* 1. KEY-RANGE DATASET SUPPORT (LOW PRIORITY, SUPPORT FOR KEY-RANGE\n*    will BE REMOVED FROM VSAM IN THE FUTURE).\n* 2. Extended format dataset support (RPL OPTCD XRBA parameter. See\n*    APAR OW43595, PTF UW70909 for DFSMS 1.5).\n*\n* CHANGE ACTIVITY:\n*  Sept  4/01,JJ:\n*    .Added Low/High key report: for every CA two lines are printed/\n*     written to LHKR (ddname) datasets. Line/data format is:\n*     CA#          - control area number\n*     CI RBA       - RBA of CI in which the Low/High key has occurred\n*     Low/High key - Low (first line for a CA)/ High (second line for\n*                    a CA) key as found in data CIs of a CA.\n*     The Low/High key are as found in data records (every data record\n*     is processed) and not the values from index Sequence Set CI.\n*\n*     .Fixed a serious error: RBA of data CI being read was always\n*      within the first CA. As a result the CI free/used space was\n*      always incorrect (except of the first CA). This was due to\n*      my missinterpretation of the vertical pointer (IBFLP3).\n*      IXHBRBA (CA base RBA) has to be added to vertical pointer\n*      to get a data CI RBA.\n*  Aug  24/01,JJ:\n*    .Added report on index structure: # of IX records per IX level.\n*     This gets printed on RPTT only after IX stats. If index is\n*     IMBED - the count of records for IX level 1 (Sequence Set)\n*     is always 0 and is not valid. I do not bother to fix this\n*     (a sequential read of IMBED index will not read SS - SEOF\n*     occcurs before SS) since the SS IX record count is the\n*     same Used Conrol Areas count printed at the end.\n*  Aug  20/01,JJ:\n*    .Eliminated second header line on page #1 of RPTT (table format\n*     report).\n*  DEC  03/99,JJ:\n*    .MINOR CHANGE TO ALLOW ICF BCS PROCESSING (ONLY IF KSDSPACE IS\n*     LINKEDITED WITH AC(1), INTO AN APF AUTHORIZED LOADLIB).\n*     TO OPEN A CATALOG AS A DATASET, YOU MUST HAVE ALTER AUTHORITY TO\n*     THE CATALOG AND APF AUTHORIZATION.\n*  JUNE 24/99,JJ:\n*    .FIXED ABEND 0C4/ INVALID SECOND LINE ON SYSPRINT REPORT\n*     (DIAGNOSTIC MSGS). SECOND PAGE HEADER LINE ADDRESS WAS\n*     MISSING RESULTING IN EITHER GARBAGE LINE OR 0C4.\n*    .FIXED A MINOR LOGIC ERROR. NUMBER OF FREE (UNUSED) CA'S\n*     AT EOF WAS ALWAYS 0 (DFSMS 1.3 OR UP).\n*  SEPT. 2/98,JJ:\n*     CALCULATION OF % OF USED/ FREE SPACE FAILED  (RPTTSDLP LABEL)\n*     0C7 ABEND IN \"MP    D,=PL3'1000'\". REPLACED THIS WITH A SHIFT OF\n*     2 GPRS (12 BITS, 3 ZONES)\n*  OCT.  7/97,JJ:\n*     ITEM #1 BELOW IS NOT ADDRESSED YET. I DO NOT HAVE TIME AND\n*     A KEY RANGE KSDS TO WORK WITH.\n*     ITEM #2 BELOW IS FIXED - ADDED CODE TO DETERMINE THE\n*     DFP LEVEL AND INTERPRET RBA AS # OF CI'S ON DFSMS 1.3.0 AND UP.\n*  OCT.  7/97,JJ:\n*     FOUND OUT TWO PROBLEMS THAT I INTEND TO FIX:\n*     1.I USE ONLY FIRST ARDB (ADDRESS RANGE DEFINITION BLOCK).\n*       THIS IS FINE FOR A REGULAR KSDS FILE. IT MIGHT BE INCORRECT\n*       THOUGH FOR A KEYRANGE DATA SET (THERE IS AN ARDB FOR EVERY\n*       KEYRANGE). WILL PROCESS ALL ARDB'S AND SELECT THE ONE WITH\n*       HIGHEST RBA.\n*     ??? AS OF TODAY, I DO NOT UNDERSTAND THE KEYRANGE DATA SET\n*     ??? PROCESSING. THE # OF FREE CA'S AT THE END OF A DATASET MAY\n*     ??? BE INCORECT. ALSO, IS EVERY KEYRANGE PROCESSED AS A SEPARATE\n*     ??? DATASET ?\n*     2.AS OF DFSMS 1.3 RBA'S IN ARDB ARE EXPRESSED IN NUMBER OF CI'S\n*       RATHER THAN BYTES. AS A RESULT - # OF CA'S AT THE END OF\n*       A DATA SET IS ALWAYS REPORTED AS 0.\n*    APR. 10/97,JJ:\n*       FREE CA CI'S DUE TO IX RECORD TOO SHORT CALCULATION WAS\n*       INCORRECT. MADE A CORRECTION AND SEEMS TO BE OK NOW.\n*    AUG. 27/92,JJ: A HEADER LINE WAS MISSING FOR RPTT REPORT ON ALL\n*       LINES EXCEPT OF LINE ONE. CORRECTED THIS.\n*    JUNE 23/92,JJ: ADDED EXTRA LINE IN THE COMPONENT STATISTICS PART\n*       OF THE REPORTS.\n*       ADDED NUMBER OF CI'S (#CI HEADER) COLUMN FOR THE CA FREE SPACE,\n*       UNUSED CI'S AND USED SPACE.\n*\n         SPACE 2\n*  \"SUBENT\" - SUBROUTINE ENTER MACRO\n*  \"SUBENT\" IS USED AT ENTRY TO INTERNAL SUBROUTINE\n*  LINK REGISTER IS ALWAYS R14\n         MACRO\n&LAB     SUBENT\n         SPACE\n&LAB     DS    0F\n         B     *+16                     AROUND EYE CATCHER AND R14 SAVE\n         DC    CL8'&LAB'                EYE CATCHER\n         DC    F'0'                     R14 SAVE\n         ST    R14,*-4                  STORE R14\n         SPACE\n         MEND\n*  \"SUBRET\" - SUBROUTINE RETURN MACRO\n*  \"SUBRET\" IS USED TO EXIT FROM AN INTERNAL SUBROUTINE\n         SPACE\n         MACRO\n&LAB1    SUBRET &LAB\n         SPACE\n&LAB1    L     R14,&LAB+12              RESTORE R14\n         BR    R14                      RETURN\n         SPACE\n         MEND\n         SPACE\n         PRINT NOGEN\nKSDSPACE CSECT                    CSECT NAME\nKSDSPACE AMODE 24\nKSDSPACE RMODE 24\n         USING KSDSPACE,R15\n         SAVE  (14,12)            SAVE REGISTERS\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   R2,SAE             SAVE AREA ADDRESS\nSA       DS    18F                SAVE AREA\n         USING SA,R2\nSAE      ST    R13,SA+4           CHAIN\n         ST    R2,8(R13)          SAVE AREAS\n         LR    R13,R2             CURRENT SAVE AREA\n         DROP  R2\n         USING SA,R13,R12         PROGRAM BASE REGISTER\n         LA    R12,2048(,R13)     SECOND BASE REGISTER\n         LA    R12,2048(,R12)\n         SPACE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* LET'S DETERMINE DFP/DFSMS LEVEL WE ARE RUNNING ON\n* (AT THIS TIME IT IS FOR THE PURPOSE OF INTERPRETTING RBA'S\n*  IN ARDB AS EITHER # OF BYTES OF # OF CI'S)\n* DFP/DFSMS LEVEL CAN BE DETERMINED FROM IHADFA DATA AREA\n*     PSA -> CVT -> DFA\nCVTADDR  EQU   R2\nDFAADDR  EQU   R3\n* SWITCH AMODE TO 31 IN CASE ANY ADDRESS IS ABOVE THE LINE\n         L     R1,DFLAM31         SET ADDRESS WITH H/O BIT ON\n         BSM   R0,R1              SET AMODE 31\nDFLAM31  DC    A(DFLAM32+X'80000000')\nDFLAM32  L     CVTADDR,CVTPTR     LOAD CVT ADDRESS\n         USING CVT,CVTADDR        ADDRESSABILITY ON CVT\n         L     DFAADDR,CVTDFA     LOAD DFA  ADDRESS\n         USING DFA,DFAADDR        ADDRESSABILITY ON ASVT\n         CLC   =X'3321',DFAREL    ARE WE RUNNING DFSMS................?\n         BL    DFLP130            NO, DFP, PRE DFSMS V1--------------->\n         CLC   =X'01010300',DFARELSO DFSMS 1.3.0 .....................?\n         BL    DFLP130            NO, DFP, PRE DFSMS V1--------------->\n         B     DFLEX              DFSMS 1.3.0 OR HIGHER--------------->\nDFLP130  OI    DFLEVEL,DFPRE130   SET PRE DFSMS 1.3.0 FLAG\n*\n* EXIT FROM DFP LEVEL DETERMINATION\nDFLEX    LA    R1,DFLEXX          LOAD ADDRESS WITH H/O BIT OFF\n         BSM   R0,R1              SET MODE 24\nDFLEXX   DS    0H                 EXIT FROM DF LEVEL DETERMINATION\n         DROP  CVTADDR,DFAADDR    DROP CVT, DFA ADDRESSABILITY\n* END OF DF LEVEL DETERMINATION\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6                 Does not seem to be used at the moment\nR7       EQU   7                 (a good candidate for next base ?)\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\nTCHR     EQU   R2                 HEX TRANSLATED CHARACTER REGISTER\nHEXLEN   EQU   R3                 CONVHEX INPUT FIELD LENGTH\nHEXOUTAR EQU   R14                CONVHEX OUTPUT FIELD ADDRESS\nHEXINAR  EQU   R15                CONVHEX INPUT FIELD ADDRESS\nLNKREG1  EQU   R9                 LINK REGISTER 1\nRPTDBAR  EQU   R10                REPORT DEFINITION BLOCK ADDRESS\nMSGADDR  EQU   R11                ERROR MESSAGE ADDRESS\n         SPACE\n* OFFSETS OF A FEW FIELDS IN AMBL\nAMBLQ    EQU   23                 QUALIFIER           (IN AMBL)\nAMBLKSDS EQU   X'04'              CLUSTER OPEND AS KSDS FLAG (AMBLQ)\nAMBLDTA  EQU   52                 POINTER TO DATA AMB (IN AMBL)\nAMBLIX   EQU   56                 POINTER TO INDEX AMB (IN AMBL)\n         SPACE\n         OPEN  (VSAMF)\n         LTR   R15,R15            OPEN OK.............................?\n         BNZ   OPENERR            NO, OPEN ERROR---------------------->\n*  CHECK IF IT IS A KSDS FILE\n         L     R2,ACBAMBL         AMB LIST ADDRESS\n         TM    AMBLQ(R2),AMBLKSDS A KSDS CLUSTER......................?\n         BZ    NOTKSDS            NO, IT IS NOT A KSDS FILE----------->\n* PRINT OPEN TIME STATISTIC FOR DATA AND INDEX COMPONENTS AVAILABLE\n* IN THE AMDSB\n         L     R3,AMBLDTA(,R2)    LOAD DATA COMP. AMB ADDRESS\n         USING AMB,R3             AMB ADDRESSABILITY\n         L     R4,AMBDSB          LOAD DATA COMP. AMBSB ADDRESS\n         ST    R4,DATADSBA        SAVE DATA COMPONENT AMDSB ADDRESS\n         USING AMDSB,R4           AMBSB ADDRESSABLITY\n* We will adjust record length of the LHKR file/DCB\n         LA    R0,LHKL1KEY-LHKL1  lenght of fixed part of the record\n         AH    R0,AMDKEYLN        + key length = record length\n         STH   R0,LHKL1           store it in RDW\n* If LRECL < 137 will make it 137 (due to header line)\n         CH    R0,=H'137'\n         BNL   LHKRLA             L'LHKL1 >= 137\n         LH    R0,=H'137'         make is 137 (minimum LRECL)\nLHKRLA   LA    R1,LHKR            DCB address\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         STH   R0,DCBLRECL        store LRECL in DCB\n         LH    R0,AMDKEYLN        Key length\n         CVD   R0,D               CONVERT TO DECIMAL\n         ED    LHKRHLKL,D+4       EDIT/convert key lenght to printable\n*                                 on LHKR header line\n         DROP  R1                 Drop addressability\n* ONLY A LOADED KSDS (NON-EMPTY) CAN BE PROCESSED BY THIS PROGRAM\n* FOR A BCS, AMDNLR FIELD IS ALWAYS ZERO:\n* WE NEED TO DETERMINE HERE IF THIS IS A BCS. WILL READ FMT 1 DSCB\n* OF DATA COMPONENT TO CHECK IF THIS IS A BCS.\nDATACSR  EQU   R5                 Data CSECT addressability register\n         L     DATACSR,=V(KSDSPACD) Data CSECT address\n         USING KSDSPACD,DATACSR   KSDSPACD addressability\n         MVC   DS1DSNAM,AMBDSNM   MOVE DATA COMPONENT DSNAME FOR\n*                                 CMALST/OBTAIN USE\n* NOW WE NEED TO GET DATA COMPONEMT 1-ST VOLSER FROM ARDB\n         L     R15,AMDPARDB       LOAD ARDB ADDRESS\n         USING ARDB,R15           ARDB ADDRESSABILITY\n         MVC   DS1DSSN,ARDVOLSR   MOVE DATA COMPONENT VOLSER FOR\n*                                 CMALST/OBTAIN USE\n         DROP  R15\n         PRINT GEN\n         OBTAIN CAMLSTO           GET FMT1 DSCB\n         PRINT NOGEN\n         LTR   R15,R15            OBTAIN SHOULD NEVER FAIL SINCE\n*                                 DATASET IS ALREADY OPEN, HOWEVER....?\n         BNZ   NOTBCS             WILL IGNORE IT DOES ---------------->\n         CLI   DS1FMTID,C'1'      DO WE HAVE FMT1 DSCB ...............?\n         BNE   NOTBCS             THIS IS UNEXPECTED, LET'S IGNORE IT->\n         TM    DS1OPTCD,DS1OPTBC  IS THIS AN ICF BCS .................?\n         DROP  DATACSR\n         BO    BCS1               YES, BYPASS EMPTY KSDS TEST--------->\n*\nNOTBCS   L     R14,AMDNLR         NO.OF RECORDS IN THE DATA COMPONENT\n         LTR   R14,R14            ANY RECORDS IN THE FILE.............?\n         BZ    KSDSNL             NO, DATA SET IS NOT LOADED---------->\nBCS1     MVC   CISIZED,AMDCINV    SAVE THE DATA COMPONENT CISIZE\n         BAL   R14,PRNTSTAT       PRINT DATA  COMPONENT STATISTICS\n         L     R3,AMBLIX(,R2)     LOAD INDEX COMP. AMB ADDRESS\n         L     R4,AMBDSB          LOAD INDEX COMP. AMBSB ADDRESS\n         ST    R4,INDXDSBA        SAVE INDEX COMPONENT AMDSB ADDRESS\n         MVC   CISIZEI,AMDCINV    SAVE THE INDEX COMPONENT CISIZE\n         BAL   R14,PRNTSTAT       PRINT INDEX COMPONENT STATISTICS\n* Find out # of records at each index level and print that like:\n* IX level   # of IX records\n         STM   R2,R15,SAVEA1      SAVE REGISTERS BEFORE CALLING\n         BAL   R14,IXRPT          Index analyses/ report\n         LM    R2,R15,SAVEA1      RESTORE THE REGISTERS\n         LA    R11,SGL1           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R11,SGL2           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R11,SGL3           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R11,SGL4           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R11,RPTTL1H        ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         MVI   RPTTL1HA,C'0' 1 SPACE NEXT TIME THIS HEADER LINE PRINTED\n         BAL   R14,BLANKL         PRINT A BLANK LINE AFTER STATISTICS\n* AT THIS POINT WE HAVE INDEX AMDSB ADDRESS IN R4\n         MVC   IXCIRBA,AMDSSRBA   MOVE RBA OF THE FIRST SEQUENCE SET\n*                                 RECORD INTO A WORK FIELD\n         SPACE\n* THIS IS THE MAINLINE PROCESSING CODE.\n* AN INDEX SEQUENCE SET CI (RECORD) GOVERNING ONE CA IS READ.\n* FOR EVERY SS RECORD, ALL USED DATA CI FROM THAT CA ARE ALSO READ\n* AND PROCESSED. A REPORT LINE IS PRINTED FOR EACH CA.\nIXCIPROC DS    0H                 INDEX RECORD (SS) PROCESSING\n* Edit current CA number to printable (in LHKL1 for LHKR report)\n         MVC   LHKL1CA#,=X'4020202020202120' CA number edit mask\n         L     R15,DC#CA          this control area number (-1)\n         LA    R15,1(,R15)        + 1 since DC#CA is updated at the\n*                                 of a CA processing\n         CVD   R15,D              CONVERT TO DECIMAL\n         ED    LHKL1CA#,D+4       EDIT/convert CA # to printable\n*\n         XC    CASUS,CASUS        RESET THE CA SUS TO ZEROS\n         XC    CAIXRLSL,CAIXRLSL  RESET LAST SS IX RECORD SECTION LEN\n         OI    CAFLAGS,CAFFDRP    set first CA data record flag\n         MODCB RPL=RPLIX,         MOVE ARGUMENT ADDRESS INTO RPL       +\n               ARG=IXCIRBA        RBA OF THE INDEX SS CI\n         GETIX RPL=RPLIX          GET AN INDEX (SS) RECORD\n         LTR   R15,R15            GET SEQUENCE SET RECORD OK..........?\n         BNZ   IXRERROR           NO, INDEX READ ERROR---------------->\n         L     R5,IXCIADDR        LOAD THE ADDRESS OF THE INDEX RECORD\n         USING IXHDR,R5           INDEX RECORD (HEADER) ADDRESSABILITY\n         CLI   IXHLV,X'01'        IS IT A SEQUENCE SET CI.............?\n         BNE   ABEND0             NO, SOMETHING WRONG, ABEND --------->\n* CHECK IF THIS IS SEOF (SOFTWARE END-OF-FILE) CI\n         LH    R14,IXHLL          LENGTH OF INDEX RECORD\n         STH   R14,CAIXRFSP       INIT/PRIME THIS SS IX REC FREE SPC\n         LA    R15,IXHDR+3(R14)   ADDRESS OF THE CIDF FIELD\n         USING CIDF,R15           CIDF ADDRESSABLITY\n         OC    CIDF(4),CIDF       ALL ZEROS IN CIDF...................?\n         BZ    SEOF               YES, SOFTWARE END-OF-FILE----------->\n* CALCULATE THE VERTICAL POINTER LENGTH AND SAVE IF IN A FULLWORD\n* FOR EASE OF USE LATER ON\n         XR    R1,R1              CLEAR R1\n         IC    R1,IXHFLPLN        INDEX ENTRY CONTROL INFO.LENGTH\n         ST    R1,IXECILEN        SAVE IT IN A FULLWORD FOR EASE OF USE\n         BCTR  R1,0\n         BCTR  R1,0               - 2 = VERTICAL POINTER LENGTH\n         ST    R1,VPLENGTH        VERTICAL POINTER LENGTH\n* UPDATE THE USED SPACE FOR THE INDEX (SEQUENCE SET)\n         L     R0,IXUSPC          USED SPACE IN THE SEQUENCE SET\n         AL    R0,AMDCINV         + INDEX CI SIZE\n         ST    R0,IXUSPC          = NEW VALUE FOR USED SPACE IN BYTES\n* CHECK IF THERE ARE ANY UNUSED CI'S IN THE CA AND UPDATE THE\n* CAFSP FREE SPACE VALUE\n         XR    R0,R0              CLEAR R0 (PREPARE FOR A DIVIDE)\n         LH    R1,IXHFSO          OFFSET OF UNUSED SPACE IN THE CI\n         SH    R1,=H'24'          - LENGTH OF THE HEADER\n         BNP   IXCIP2             = 0, NO VERTICAL POINTERS TO FREE CI\n         L     R14,VPLENGTH       LOAD THE VERTICAL POINTER LENGTH\n         DR    R0,R14             FREE CI ENTRIES LEN/VPL=NO.OF FREE CI\n         STH   R1,CA#FCI          KEEP RECORD OF NO.OF FREE CI'S\n         L     R4,DATADSBA        DATA AMDSB ADDRESS\n* AT THIS POINT WE HAVE DATA COMPONENT AMDSB ADDRESS IN R4\n         M     R0,AMDCINV         NO.OF FREE CI * DATA CI LENGTH\n*                                 = NO.FREE CA BYTES\n         AL    R1,CACAFSP         ADD TO THE CA FREE SPACE\n         ST    R1,CACAFSP         AND UPDATE IT\n* FOR THIS CA, WE ARE DONE HERE WITH THE CA FREE SPACE\nIXCIP2   DS    0H\n* NOW WE WILL CHECK IF THERE IS ANY UNUSED SPACE IN THIS INDEX\n* SEQUENCE SET RECORD\n         CLC   CA#FCI,AMDCIPCA    IF NO.OF FREE CI'S = NO.OF CI'S/CA\n*                                 IT MEANS THAT THE WHOLE CA IS FREE\n         BL    IXCIP4             NO, FEWER FREE CI'S THAN CI'S/CA\n* ALL CI'S IN THIS CA ARE FREE, IT MEANS THERE AREN'T ANY INDEX ENTRIES\n         LH    R0,IXHLL           SS RECORD LENGTH\nIXCIP21  SH    R0,IXHFSO          - FREE SPACE OFFSET = LENGTH OF FSPC\n         L     R1,IXUSPC          IX (SS) USED SPACE\n         SLR   R1,R0              - FREE SPACE\n         ST    R1,IXUSPC          UPDATED USED SPACE IN THE IX (SS)\n         AL    R0,IXCIFSP         UPDATED FREE SPACE IN THE IX (SS)\n         ST    R0,IXCIFSP         STORE IT\n         B     IXCIPEX            EXIT PROCESSING FOR THIS CA\n* AT THIS POINT WE ARE DONE WITH AN IX SS RECORD AND THE DATA CA\n* CONTROLLED BY THIS SS RECORD\n         SPACE\nIXCIP4   DS    0H\n* THERE ARE INDEX ENTRIES (AND CORRESPONDING DATA CI'S) IN THIS\n* SEQUENCE SET RECORD. WE WILL GO THROUGH ALL INDEX ENTRIES, AND THEN\n* READ AND PROCCESS ALL DATA CI'S.\n* WE WILL PROCESS DATA CI'S IN THE KEY SEQUENCE (INDEX ENTRIES FROM\n* RIGHT TO LEFT).\n* PLEASE NOTE THAT OFFSETS TO INDEX ENTRIES ARE IN FACT OFFSETS TO THE\n* CONTROL INFORMATION IN AN ENTRY.\n*\nIXELEOR  EQU   R11                THIS REGISTER IS DESIGNATED TO HOLD\n*                                 OFFSET OF THE LAST INDEX ENTRY IN\n*                                 THE CURRENTLY PROCESSED SECTION OF\n*                                 THE INDEX RECORD\nIXEOR    EQU   R10                THIS REGISTER WILL HOLD OFFSET OF\n*                                 THE CURRENTLY PROCESSED INDEX ENTRY\n*\n* FIRST WE WILL CALCULATE THE FREE SPACE IN THIS INDEX RECORD\n* AND UPDATE THE IXSUS\n*\n         LH    IXELEOR,IXHLEO     LAST ENTRY OFFSET IN THE INDEX REC.\n         LA    R15,IXHDR(IXELEOR) ADDRESS OF THE CONTROL INFORMATION\n         USING IXECIFMT,R15       CONTROL INFO. DSECT ADDRESSABILITY\n         XR    R1,R1              CLEAR R1\n         IC    R1,IBFLPL          LENGTH OF IXKEY IN THE LAST ENTRY\n         SLR   R15,R1             ENTRY ADDR - COMPRESSED KEY LENGTH\n         BCTR  R15,0              - 2 (LAST SECT CNTRL FIELD = X'0000')\n         BCTR  R15,0              = ADDRESS OF THE LAST SECTION\n         SLR   R15,R5             - ADDRESS OF THE IX RECORD\n*                                 = OFFSET OF THE LAST SECTION IN R15\n         SH    R15,IXHFSO         - OFFSET OF THE FREE SPACE\n*                                 = FREE SPACE IN THIS IX RECORD\n         LR    R14,R15            SAVE IT IN R14\n         STH   R15,CAIXRFSP       SAVE IT IN THE WORK FIELD\n         AL    R15,IXCIFSP        UPDATED IX CI FREE SPACE\n         ST    R15,IXCIFSP\n         L     R15,IXUSPC         USED SPACE\n         SLR   R15,R14            - CI FREE SPACE\n         ST    R15,IXUSPC         = UPDATED USED SPACE\n*\n* NOW WE WILL PROCESS THE INDEX ENTRIES FROM RIGHT (LOWEST KEY) TO\n* THE LEFT (HIGHER KEYS)\n         LH    IXELEOR,IXHSEO     LAST ENTRY OFFSET IN THE FIRST SECT.\n         LH    IXEOR,IXHLL        INDEX RECORD LENGTH\n         SL    IXEOR,IXECILEN     - CONTROL INFO.LENGTH = OFFSET OF\n*                                 THE FIRST ENTRY\n* AT IXCIP5 LABEL WE HAVE AN INDEX ENTRY PROCESSING LOGIC.\n* FOR EACH ENTRY THE \"DCCIP\" SUBROUTINE IS CALLED TO READ AND PROCESS\n* A DATA CI CONTROLLED BY THE INDEX ENTRY.\nIXCIP5   LA    R15,IXHDR(IXEOR)   ADDRESS OF THE CONTROL INFORMATION\n         IC    R14,IXHPTLS        INSERT VERTICAL POINTER INDICATOR\n         XR    R1,R1              CLEAR R1\n         EX    R14,ICMVP          INSERT VERTICAL POINTER INTO R1\n         L     R4,DATADSBA        LOAD DATA AMDSB ADDRESS INTO R4\n         M     R0,AMDCINV         VERTICAL POINTER * DATA CI SIZE +\n         A     R1,IXHBRBA         + CA base (beginning) RBA =\n         ST    R1,DCCIRBA         RBA OF THE DATA CI\n         STM   R2,R15,SAVEA1      SAVE REGISTERS BEFORE CALLING\n* (WE ARE SHORT OF GPR'S HERE)    DATA CI PROCESSING ROUTINE\n         BAL   R14,DCCIP          CALL DATA CI PROCESSING ROUTINE\n         LM    R2,R15,SAVEA1      RESTORE THE REGISTERS\n         XR    R1,R1              CLEAR R1\n         IC    R1,IBFLPL          LENGTH OF THE IXKEY FIELD IN IX ENTRY\n         CLR   IXELEOR,IXEOR      IS THIS THE LAST ENTRY IN THIS SECT.?\n         BNL   IXCIPNS            YES, LAST ENTRY IN THIS SECTION----->\n* WE STILL HAVE MORE ENTRIES IN THIS INDEX SECTION\n         SLR   IXEOR,R1           OFFSET OF CURRENT ENTRY -IXKEY LENGTH\n         SL    IXEOR,IXECILEN     - CONTROL INFO.LENGTH= NEXT HIGHER\n*                                 ENTRY OFFSET\n         B     IXCIP5             PROCESS THE NEXT ENTRY-------------->\n* WE'VE REACHED THE END OF CURRENT INDEX SECTION\nIXCIPNS  DS    0H                 NEW SECTION PROCESSING\n         CH    IXEOR,IXHLEO       IS IT THE LAST ENTRY IN THIS RECORD.?\n         BNH   IXCIPEX            YES, END OF CA PROCESSING----------->\n         SLR   IXEOR,R1           OFFSET OF CURRENT ENTRY -IXKEY LENGTH\n         BCTR  IXEOR,0            ENTRY OFFSET - 2 (LENGTH OF SECTION\n         BCTR  IXEOR,0            CONTROL FIELD)\n         LH    R1,IXHDR(IXEOR)    LOAD THIS SECTION CONTROL FIELD\n         STH   R1,CAIXRLSL        SAVE IT IN THE WORK FIELD\n*                          (USED  LATER FOR IX RECORD SHORT TEST)\n         SLR   IXELEOR,R1         = LAST ENTRY OFFSET IN THE NEXT SECT.\n         SL    IXEOR,IXECILEN     - CONTROL INFO.LENGTH= FIRST ENTRY\n*                                 OFFSET IN THE NEXT SECTION\n         B     IXCIP5             PROCESS THE NEXT ENTRY-------------->\n         SPACE\nICMVP    ICM   R1,X'00',IBFLP3    INSERT VERTICAL POINTER INTO R1\nSAVEA1   DS    16F                INTERNAL REGISTER SAVE AREA\n         SPACE\n* WE'VE GONNE THROUGH THE WHOLE SEQUENCE SET IX RECORD AND READ ALL\n* DATA CI'S UNDER ITS CONTROL (THE CONTROL AREA).\n* NOW WE WILL CHECK IF THIS SS IX RECORD DESCRIBES ALL CI'S IN THIS CA.\n* (EG. IF THERE ARE ANY UNUSED DATA CI'S BECAUSE OF LACK OF SPACE IN\n*  THIS INDEX RECORD).\n* THEN WILL WE WILL PRINT REPORT LINES FOR THIS CONTROL AREA.\nIXCIPEX  DS    0H                 END OF CONTROL AREA PROCESSING\n* THE LOGIC BELOW IS PROBABLY USELESS, BUT DOES NOT DO ANY HARM\n* (NORMALLY, A SS IX RECORD SHOULD ALWAYS ACCOUNT FOR ALL CI'S IN A CA)\n         LH    R0,CA#FCI          NO.OF FREE CI'S IN THE CA\n         AH    R0,CA#UCI          + NO.OF USED CI'S = NO.OF DATA CI'S\n*                                 CONTROLLED BY THIS SS RECORD\n         CH    R0,AMDCIPCA        SAME AS NO.OF CI'S PER CA...........?\n         BNL   IXCIPEX1           ANOTHER CHECK FOR SS IX RECORD SHORT>\n* THERE ARE UNUSED CI'S IN THIS CA BECAUSE SEQUENCE SET INDEX RECORD\n* IS TOO SHORT\n         LH    R1,AMDCIPCA        NO.OF CI'S PER CA\n         SLR   R1,R0              - NO.OF CI'S CONTROLLED BY IX SS REC.\n*                                 = NO.OF UNUSED CI'S DUE TO IX RECLEN\n         M     R0,AMDCINV         * DATA CI SIZE = UNUSED SPACE\n         ST    R1,CAIXRSFS        STORE IT IN THE CA SUS\nIXCIPEX1 LH    R1,CA#FCI          ANY FREE CI'S IN THE CA\n         LTR   R1,R1              ?\n         BNP   IXCIPEXR           NO, NO POSSIBILITY OF IX REC SHORT\n         CLC   CAIXRLSL,CAIXRFSP  FREE SPACE IS LESS THAN LAST INDEX\n*                                 SECTION LENGTH                      ?\n         BL    IXCIPEXR           NO, ENOUGH OF FREE SPACE FOR ANOTHER\n*                                 INDEX SECTION\n* WE ARE ASSUMING THAT ALL THESE FREE CI'S ARE DUE TO INDEX RECORD\n* BEING TOO SHORT SINCE THERE IS NO FREE SPACE TO CREATE ANOTHER\n* SECTION OF THE INDEX (WE ARE WORKING WITH SS IX RECORD HERE)\n         M     R0,AMDCINV         NO.OF FREE CI * DATA CI LENGTH\n*                                 = NO.FREE CA BYTES\n         LR    R0,R1              = NO.FREE CA BYES - COPY TO R0\n         A     R0,CAIXRSFS        UPDATE THE VALUE\n         ST    R0,CAIXRSFS        STORE IT IN THE CA SUS\n* NOW WE HAVE TO SUBTRACT THIS VALUE FROM CACAFSP FIELD\n* SINCE IT HAS BEEN PREVIOUSLY ADDED\n         L     R0,CACAFSP         CA FREE SPACE\n         SR    R0,R1              - SPACE DUE TO IX RECORD SHORT\n         ST    R0,CACAFSP         AND UPDATE IT\n* WE ARE GOING TO PRINT THE REPORT LINES FOR THE CA HERE\nIXCIPEXR DS    0H\n         STM   R2,R11,SAVEA1      SAVE REGISTERS (2 TO THE LAST BASE)\n         MVC   CISIZE,CISIZED     DATA COMPONENT CISIZE\n         BAL   R14,CARPTT         RPTT CA REPORT LINE(S)\n         BAL   R14,CARPTG         RPTG CA REPORT LINE(S)\n* Print HIGH key line in LHKR report\n         LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LM    R2,R11,SAVEA1      RESTORE REGISTERS\n         L     R4,INDXDSBA        RELOAD THE INDEX AMDSB ADDRESS\n*                                 (IT HAS TO BE AT THE IXCIPROC LABEL)\n         MVC   IXCIRBA,IXHHP      RBA OF THE NEXT SEQUENCE SET RECORD\n         LA    R0,1               UPDATE THE NUMBER OF CA'S PROCESSED\n         AL    R0,DC#CA           NO.OF CA'S + 1\n         ST    R0,DC#CA           UPDATED\n* UPDATE THE DATA COMPONENT SPACE UTILIZATION SUMMARY\n* BY ADDING VALUES FROM THE CURRENT CONTROL AREA\n         LM    R14,R1,DCSUS       LOAD SUS VALUES INTO R14,R15,R0,R1\n         AL    R14,CAUSPC         USED DATA SPACE\n         AL    R15,CACAFSP        CA FREE SPACE\n         AL    R0,CACIFSP         CI FREE SPACE\n         AL    R1,CAIXRSFS        UNUSED CI'S BECAUSE IX CI SHORT\n         STM   R14,R1,DCSUS       STORE DATA COMPONENT UPDATED SUS\n         OC    IXCIRBA,IXCIRBA    RBA OF NEXT SS RECORD = 0...........?\n         BZ    SEOF               YES,END-OF-FILE,LAST SS CI PROCESSED>\n         B     IXCIPROC           PROCESS NEXT SS RECORD AND DATA CA\n         SPACE\n* SOFTWARE END-OF-FILE RECORD FOUND IN THE SEQUENCE SET\n* OR, LAST PROCESSED SS RECORD HORIZONTAL POINTER WAS 0 (EOF)\nSEOF     DS    0H\n* WE NEED TO CHECK IF THERE ARE ANY CA'S ALLOCATED AFTER THE LAST\n* PROCESSED.\n* LET'S CALCULATE HOW MANY CA'S AFTER EOF ARE UNUSED.\n* (WE HAVE TO FIND ARDB WITH THE HIGHEST DATA RBA: THIS ARDB CONTAINS\n*  THE HIGEST ALLOCATED RBA)\n         L     R4,DATADSBA        RELOAD THE DATA AMDSB ADDRESS\n         L     R15,AMDPARDB       LOAD ARDB ADDRESS\n         USING ARDB,R15           ARDB ADDRESSABILITY\n         L     R1,ARDERBA         HIGHEST RBA ALLOCATED IN DATA COMP.\n         SL    R1,ARDHRBA         - FIRST FREE CI RBA AT THE EOF\n         LTR   R1,R1              ANY FREE SPACE AFTER EOF............?\n         BZ    SEOF1              NO FREE CA'S AFTER EOF-------------->\n         XR    R0,R0              PREPARE FOR DIVIDE ( R0=0 )\n*  WE HAVE TO FIND OUT HERE IF RBA MEANS # OF CI'S (DFSMS 1.3 AND UP)\n         TM    DFLEVEL,DFPRE130   DFSMS 1.3.0 SYSTEM..................?\n         BO    SEOF130U           YES, DFSMS 1.3.0 OR UP-------------->\n*                                 WE ALREADY HAVE # OF FREE CI'S IN R1\n*                                 PRE DFSMS 1.3 DFP LEVEL\n         D     R0,AMDCINV         FREE BYTES/CI SIZE = NO.FREE CI'S\nSEOF130U LH    R14,AMDCIPCA       NO.OF CI'S PER CONTROL AREA\n         XR    R0,R0              PREPARE FOR DIVIDE ( R0=0 )\n         DR    R0,R14             FREE CI'S / CI PER CA = # FREE CA'S\n         ST    R1,DC#CAFR         NO.OF FREE CA'S AT THE END OF DATASET\n         DROP  R15\nSEOF1    DS    0H                 PRINT SUMMARY FOR DATA AND INDEX\n         BAL   R14,DCSUSPR        PRINT SUS FOR DATA COMPONENT\n         BAL   R14,IXSUSPR        PRINT SUS FOR INDEX COMPONENT\n         B     CLOSE              CLOSE VSAM ACB AND REPORTS' DCB'S\n* HERE IS THE END OF THE MAINLINE PROCESSING LOGIC. THE FOLLOWING ARE\n* VARIOUS PROCEDURES CALLED FROM THE MAINLINE.\n         SPACE\n*---------------------------------------------------------------------*\n* DATA CI PROCESSING ROUTINE                                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDCCIP    SUBENT\n* This code ensures that there are no idle data CI reads\n* (checks if we are positioned correctly, will however do an\n* unnecessary POINT for the first read of the data component CI)\n* Also, this prevents EODAD error if by a chance the last CI read\n* was the last CI of the data component.\n         L     R0,DCCIRBAC        RBA of the last read data CI\n         AL    R0,CISIZED         + CI size = RBA of next to be read CI\n         C     R0,DCCIRBA         Next CI RBA = required .............?\n         BNE   DCCIPP             No, position/POINT first------------>\nDCCIPG   GET   RPL=RPLDC          GET A DATA COMPONENT CI\n         LTR   R15,R15            GET DATA CI OK......................?\n         BNZ   DCIRERR            NO, DATA CI READ ERROR-------------->\n         SHOWCB RPL=RPLDC,        GET THE RBA OF JUST READ DATA CI     +\n               AREA=DCCIRBAC,     CURRENTLY READ CI RBA                +\n               LENGTH=4,                                               +\n               FIELDS=(RBA)      RBA WILL BE SHOWN\n         CLC   DCCIRBAC,DCCIRBA   SAME READ AS REQUIRED FROM IX REC...?\n         BE    DCCIP1             YES, W'VE GOT THE RIGHT DATA CI----->\n* NEXT SEQUENTIALLY READ DATA CI ISN'T THE RIGHT ONE. WE HAVE TO ISSUE\n* A POINT MACRO AND REREAD THE DATA CI\nDCCIPP   MODCB RPL=RPLDC,         MOVE ARGUMENT ADDRESS INTO RPL       +\n               ARG=DCCIRBA        RBA OF THE REQUIRED DATA CI\n         POINT RPL=RPLDC          POINT ON REQUIRED DATA CI\n         LTR   R15,R15            POINT OK............................?\n         BNZ   POINTERR           NO, ERROR--------------------------->\n         B     DCCIPG             GET THE REQUIRED DATA CI------------>\nDCCIP1   L     R2,DCCIADDR        ADDRESS OF THE CI IN A BUFFER\n         L     R0,DCCIRBAC        This data CI RBA\n         CVD   R0,D               Convert to decimal\n         MVC   LHKL1RBA,=X'402020202020202020202120'\n         ED    LHKL1RBA,D+2       EDIT/convert RBA to printable\n* WE EXPECT DATA AMDSB ADDRESS TO BE IN R4\n* Register use:\n* R2  CI   address\n* R3  CIDF address\n* R4  AMDSB address\n* R3  1st/right RDF  address (if there is a pair)\nCIDFR    EQU   R3                 CIDF address register\nRDFR     EQU   R3                 RDF address register\n         USING AMDSB,R4           AMBSB ADDRESSABLITY\n         L     R15,AMDCINV        DATA CI SIZE\n         LR    CIDFR,R15\n         SL    CIDFR,=F'4'        DATA CI SIZE - 4 = CIDF OFFSET\n         LA    CIDFR,0(R2,CIDFR)  CIDF ADDRESS\n         USING CIDF,CIDFR         CIDF  ADDRESSABLITY\n         ICM   R0,B'0011',CIDF11  LOAD LENGTH OF UNUSED SPACE INTO R0\n         SLL   R0,17              CLEAR THE CI BUSY BIT\n         SRL   R0,17\n         SLR   R15,R0             CI SIZE - UNSUED SPACE = USED SPACE\n         AL    R15,CAUSPC         UPDATED CA USED SPACE\n         ST    R15,CAUSPC\n         AL    R0,CACIFSP         UPDATED CI FREE SPACE\n         ST    R0,CACIFSP\n         LA    R0,1               UPDATED NO.OF USED DATA CI'S\n         AH    R0,CA#UCI\n         STH   R0,CA#UCI\n* At this point we will be extracting keys from data records\n* in order to find LOW/HIGH keys in this data area\n         ICM   R1,B'0011',CIDFOSET LENGTH OF data records in this CI\n         SLL   R1,17              CLEAR THE CI BUSY BIT\n         SRL   R1,17\n         LTR   R1,R1              No data records (a free CI).........?\n*                                 (this should not happen, we check\n*                                  just in case)\n         BZ    DCCIPEX            empty CI, exit DCCIP\n*        CI address + lenght of data records = free space address\n         LA    R1,0(R2,R1)        Free space address in thi CI\n         ST    R1,DCCIPFSP        Save it for later checking if we\n*                                 went through all data records\n* (in case of spanned records this is somewhat simpler: after last\n*  or intermediate segment - there should not be any more records in\n*  this data CI).\n*\n* In case of a spanned record file - we have to find the first segment\n* (or the whole first record in this CI)\n* R2 points to a record or segment\n* We will proceed form left to right (in the CI) and extract key from\n* every record.\n* For the first record found - if this is the first CI in the CA\n* (CAFFDRP flag is on) - will write the LOW key line.\n* At the end of CA processing - will write the last/HIGH key line.\n* At this point RDFR points to CIDF\n         SH    RDFR,=H'6'         - 6 = left RDF address (if paired,\n*                                 if any)\n* ( we are getting view of left and right RDF even though there can\n*   be only the right one)\n         USING RDF,RDFR           RDF addressability\nDCCIPRP  TM    RRDFF,RRDFFS+RRDFLS a spanned record ..................?\n         BZ    DCCIPF             No, a fixed length record ---------->\n* We seem to have a spanned record here\n         TM    RRDFF,RRDFFS+RRDFLS intermediate segment...............?\n         BO    DCCIPEX            Yes, no more segments in this CI\n         TM    RRDFF,RRDFLS       last segment         ...............?\n* (in case of spanned records CI with last or intermediate segment\n*  cannot contain any other records)\n         BO    DCCIPEX            Yes, no more segments in this CI\n* We seem to have the first segment of a spanned record here\n         BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         TM    CAFLAGS,CAFFDRP    first data CI in this CA ...........?\n         BNO   DCCIPEX            No, Exit this CI processing--------->\n         LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* We printed the LOW key, let's reset the CAFFDRP flag\n         NI    CAFLAGS,X'FF'-CAFFDRP reset first CA data record flag\n         B     DCCIPEX            Exit this CI processing\n*                                 (a spanned segment should always be\n*                                 the last record in a data CI)\n         SPACE\n* We have a fixed record in this CI (pointed by R2)\nDCCIPF   TM    CAFLAGS,CAFFDRP    first data CI in this CA ...........?\n         BNO   DCCIPF1            No, Exit this CI processing--------->\n         BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         MVI   LHKL1CA#,X'40'     Ensure next line is single spaced\n* We printed the LOW key, let's reset the CAFFDRP flag\n         NI    CAFLAGS,X'FF'-CAFFDRP reset first CA data record flag\nDCCIPF1  TM    RRDFF,RRDFP        is it a paired RDF..................?\n         BO    DCCIPFP            Yes, paired RDF, get last rec   ---->\n* Just single record, extract key, position on next record\nDCCIPF2  BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         AH    R2,RRDF#           Next record address in the CI\n         C     R2,DCCIPFSP        = free space address ...............?\n         BNL   DCCIPEX            yes, we are done with this CI ------>\n* Since we have un-paired RDF, we need to decrement by 3 to get next\n         SH    RDFR,=H'3'         - 3 = next RDF address\n         B     DCCIPRP            Look at the next RDF/ data record\n* Multiple fixed length records described by paired RDF\nDCCIPFP  LH    R15,LRDF#          number of records described by this\n*                                 paired RDF\n         BCTR  R15,0              - 1\n         MH    R15,RRDF#          * record length = offste of last rec\n         LA    R2,0(R2,R15)       last record address\n         BAL   LNKREG1,DCCIPEK    move key from data record to LHKL1KEY\n         AH    R2,RRDF#           Next record address in the CI\n         C     R2,DCCIPFSP        = free space address ...............?\n         BNL   DCCIPEX            yes, we are done with this CI ------>\n* In case of a paired RDF we need to subtract 6 bytes to position at\n* next RDF pair (if any).\n         SH    RDFR,=H'6'         - 6 = next RDF address\n         B     DCCIPRP            Look at the next RDF/ data record\n         DROP  CIDFR              Drop addressability of CIDF\n         DROP  RDFR               Drop addressability of RDF\nDCCIPEX  SUBRET DCCIP             RETURN TO CALLER\nMVCKEY   MVC   LHKL1KEY(1),0(R15) move record key to LHKL1KEY\nDCCIPFSP DS    A                  Address of free space in this data CI\n* Extract key from this data record (pointed by R2)\nDCCIPEK  LH    R15,AMDRKP         RELATIVE KEY POSITION\n         LH    R1,AMDKEYLN        KEY LENGTH\n         BCTR  R1,0               KEY LENGTH - 1\n         LA    R15,0(R2,R15)      Key address in the first record\n         EX    R1,MVCKEY          move load key to LHKL1KEY\n*********test***************************\n*        LA    R11,LHKL1          ADDRESS OF THE LINE TO BE PRINTED\n*        LA    R10,LHKRDB         ADDRESS OF THE LHKR DEFINITION BLOCK\n*        ST    R9,DCCIPR2S        save R2 ******* test ***************\n*        BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n*        L     R9,DCCIPR2S        restore R2 ******* test ***********\n*********test***************************\n         BR    LNKREG1            Return to caller\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT REPORT LINE FOR A CONTROL AREA - GRAPHICAL FORMAT             *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCARPTG   SUBENT\n         LA    R6,CASUS           CONTROL AREA SUS ADDRESS\n         BAL   R14,RPTGSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET CARPTG            RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT REPORT LINE FOR A CONTROL AREA - TABLE FORMAT                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCARPTT   SUBENT\n         LA    R6,CASUS           CONTROL AREA SUS ADDRESS\n         BAL   R14,RPTTSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET CARPTT            RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT THE SPACE DISTRIBUTION LINE - GRAPHICAL FORMAT                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTGSDL  SUBENT\n* R6 HAS THE SPACE UTILIZATION SUMMARY ADDRESS ( SUS )\n         USING SUS,R6             SUS ADDRESSABILITY\n         LM    R0,R3,SUS          LOAD USPC, CAFSP, CIFSP, IXRSFS\n         LR    R15,R0             USPC INTO R15 AND THEN ADD:\n         ALR   R15,R1             CA FREE SPACE\n         ALR   R15,R2             CI FREE SPACE\n         ALR   R15,R3             UNUSED SPACE BECAUSE IX CI SHORT\n* R15 HAS NOW TOTAL SPACE IN BYTES\n         LR    R11,R15            SAVE TOTAL SPACE IN THE R11\n         XR    R14,R14            CLEAR R14 (PREPARE FOR DIVIDE)\n         LA    R10,L'RPTGL1A      SPACE DISTRIBUTION AREA LENGTH\n         DR    R14,R10            TOTAL SPACE/PRINT LINE LENGTH\n* R15 (QUOTIENT) HAS NO.OF BYTES PER ONE CHARACTER OF THE PRINT LINE\n         LR    R8,R15             NO.OF BYTES PER ONE PRINT POSITION\n         SRL   R8,1               DIVIDE BY 2\n         LA    R9,RPTGL1A         ADDRESS OF THE AREA IN THE PRINT\n*                                 RECORD\n         MVI   RPTGL1C,C' '       ONE LINE SPACING\n         MVI   RPTGL1A,C' '       FILL PRINT AREA WITH BLANKS\n         MVC   RPTGL1A+1(L'RPTGL1A-1),RPTGL1A\n* USED SPACE PROCESSING: IT WILL BE REPRESENTED BY * CHARACTERS\n* ON THE PRINTOUT\n         LTR   R0,R0              IS THERE ANY USED SPACE.............?\n         BNP   RPTGSDLB           NO, CHECK CA FREE SPACE------------->\n* USED SPACE IS ALREADY IN R0\n         IC    R7,USPCID          CHARACTER REPRESENTING USED SPACE\n*                                 INTO R7\n         BAL   R14,RPTGSDP        CONVERT USED SPACE INTO * CHARS\n*                                 ON THE PRINT LINE\n* CA FREE SPACE PROCESSING: IT WILL BE REPRESENTED BY + CHARACTERS\n* ON THE PRINTOUT\nRPTGSDLB LTR   R1,R1              IS THERE ANY CA FREE SPACE..........?\n         BNP   RPTGSDLC           NO, CHECK CI FREE SPACE------------->\n         LR    R0,R1              CA FREE SPACE INTO R0\n         IC    R7,CAFSPCID        CHARACTER REPRESENTING CA FREE SPACE\n*                                 INTO R7\n         BAL   R14,RPTGSDP        CONVERT CA FREE SPACE INTO + CHARS\n*                                 IN THE PRINT LINE\n* CI FREE SPACE PROCESSING: IT WILL BE REPRESENTED BY - CHARACTERS\n* ON THE PRINTOUT\nRPTGSDLC LTR   R2,R2              IS THERE ANY CI FREE SPACE..........?\n         BNP   RPTGSDLD           NO, CHECK IX REC.SHORT FREE SPC----->\n         LR    R0,R2              CA FREE SPACE INTO R0\n         IC    R7,CIFSPCID        CHARACTER REPRESENTING CI FREE SPACE\n*                                 INTO R7\n         BAL   R14,RPTGSDP        CONVERT CI FREE SPACE INTO - CHARS\n*                                 IN THE PRINT LINE\n* CA FREE SPACE RESULTING FROM IX RECORD BEING TOO SHORT - IT WILL BE\n* REPRESENTED BY X CHARACTERS ON THE PRINTOUT\nRPTGSDLD LTR   R3,R3              IS THERE ANY IX REC.SHORT FSPC......?\n         BNP   RPTGSDLP           NO, PRINT THE LINE OF THE RPTG------>\n         LR    R0,R3              IX REC.SHORT RESULTING FREE SPACE\n         IC    R7,IXSFSPID        CHARACTER REPRESENTING IX RECORD\n*                                 SHORT CAUSED FREE SPACE INTO R7\n         BAL   R14,RPTGSDP        CONVERT IX REC.SHORT FSPC INTO X\n*                                 CHARS ON THE PRINT LINE\n* PRINT THE SPACE DISTRIBUTION REPRESENTATION ON RPTG\nRPTGSDLP LA    R11,RPTGL1         ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         SUBRET RPTGSDL           RETURN TO CALLER\n         SPACE\n*---------------------------------------------------------------------*\n* THIS PROC FILLS THE RPTG PRINT LINE WITH REQUESTED CHARACTERS       *\n* REPRESENTING KSDS FILE SPACE DISTRIBUTION (CA IN PARTICULAR)        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTGSDP  SUBENT\n* REGISTER CONTENTS:\n* R0 - SPACE IN BYTES TO BE REPRESENTED BY SPECIFIED CHARS\n* R7 - CHARACTER REPRESENTIG GIVEN SPACE ON THE PRINT LINE (L/O BYTE)\n* R9 - ADDRESS OF AREA TO BE FILLED WITH THE ABOVE CHARACTERS\n* R10- LENGTH OF THE ABOVE AREA\n* R15- NO.OF BYTES REPRESENTED BY ONE PRINT LINE POSITION\n* R8 - CONTENTS OF R15 DIVIDED BY TWO (2)\n         XR    R4,R4              CLEAR R4 (PREPARE FOR DIVIDE)\n         LR    R5,R0              USED SPACE IN BYTES\n         DR    R4,R15             DIVIDE BY NO.OF CHARS/PRINT POSITION\n         CLR   R4,R8              REMAINDER >= HALF OF R15............?\n         BL    RPTGSDP1           NO, FILL PRINT AREA WITH CHARS------>\n         LA    R5,1(,R5)          YES, ONE POSITION EXTRA\nRPTGSDP1 LTR   R5,R5              ANY POSITIONS TO BE FILLED..........?\n         BNP   RPTGSDPE           NO, EXIT---------------------------->\n         CLR   R5,R10             # OF POSITION > AREA LENGTH.........?\n         BNH   RPTGSDP2           NO, WE ARE OK\n         LR    R5,R10             YES,CHANGE IT TO NO.OF POSITIONS LEFT\nRPTGSDP2 LR    R0,R5              SAVE NO.OF POSITIONS FILLED IN R0\n         STC   R7,0(,R9)          STORE SPECIFIED CHAR IN THE OUTAREA\n         SH    R5,=H'2'           NO.OF POSITIONS FILLED - 2\n         BM    RPTGSDP3           ONLY ONE CHARACTER WAS REQUIRED----->\n         EX    R5,MVCRPTG         FILL THE ARE WITH REQUIRED # OF CHARS\nRPTGSDP3 ALR   R9,R0              NEXT AVAILABLE BYTE ADDRESS IN THE\n*                                 PRINT AREA\n         SR    R10,R0             NO.OF CHARS LEFT IN THE PRINT AREA\n         BNP   RPTGSDLP           NONE LEFT, BYPASS ANY LEFT SPACE\n*                                 DISTRIBUTION COMPONENTS PROCESSING\nRPTGSDPE SUBRET RPTGSDP           RETURN TO CALLER\n         SPACE\nMVCRPTG  MVC   1(1,R9),0(R9) MOVE SPACE ID CHARACTERS INTO PRINT AREA\nUSPCID   DC    C'*'               CHARACTER REPRESENTING USED SPACE\nCAFSPCID DC    C'-'               CHARACTER REPRESENTING CA FREE SPACE\nCIFSPCID DC    C'X'               CHARACTER REPRESENTING CI FREE SPACE\nIXSFSPID DC    C'+'               CHARACTER REPRESENTING FREE SPACE\n*                                 RESULTING FROM INDEX CI BEING TOO\n*                                 SHORT\nRPTGL1   DC    AL2(RPTGL1E-RPTGL1) RPTG PRINT LINE 1 (RDW - RECLEN)\n         DC    AL2(0)\nRPTGL1C  DC    C' '               ANSI PRINT CONTROL CHAR (1 LINES SPC)\nRPTGL1A  DS    CL132              TEXT TO BE PRINTED\nRPTGL1E  EQU   *\n         SPACE\nRPTGDB   DS    0CL20              RPTG DEFINITION BLOCK\n*/////////////////////////////////////////////////////////////////////*\nRPTGDCBA DC    A(RPTG)            DCB ADDRESS\nRPTGLPL  DC    A(65)              RPTG LINES PER PAGE LIMIT\nRPTGLCNT DC    A(65)              RPTG LINE COUNT (FORCE FIRST HEADER)\nRPTGPGN  DC    A(1)               RPTG PAGE NUMBER\nRPTGHTA  DC    A(RPTGHLT)         PAGE HEADER LINE TEXT ADDRESS\nRPTGHTA1 DC    A(0)               NO SECOND HEADER LINE FOR THIS RPT\n*/////////////////////////////////////////////////////////////////////*\nRPTGHLT  DC    AL1(L'RPTGHLTT)    LENGTH OF THE HEADER LINE TEXT\nRPTGHLTT DC    C'KSDSPACE - RPTG: SPACE DISTRIBUTION IS SHOWN IN GRAPHI+\n               CAL FORM'\n         SPACE\n*---------------------------------------------------------------------*\n* REPORT PRINT PROCEDURE                                              *\n* REGISTERS CONTENTS AT ENTRY:                                        *\n* R11 HAS ADDRESS OF THE V FROMAT RECORD TO BE PRINTED                *\n* R10 HAS ADDRESS OF THE REPORT DEFINITION BLOCK                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTPP    SUBENT\n         USING RPTDB,R10          RPTDB ADDRESSABILITY\n* CHECK IF REPORT DCB IS OPEN\n         L     R9,RPTDCBA         REPORT DCB ADDRESS INTO R9\n         TM    48(R9),DCBOFOPN    IS REPORT FILE OPENED...............?\n         BO    RPTPPA             YES, ALREADY OPENED    ------------->\n         OPEN  ((9),(OUTPUT))\n         TM    48(R9),DCBOFOPN    OPEN SUCCESSFUL        .............?\n         BNO   RPTOPNER           NO, OPEN ERROR         ------------->\n* CHECK NUMBER OF LINES RESULTING FROM ANSI PRINT CONTROL CHARACTER\nRPTPPA   CLI   4(R11),C'+'        PRINT IN THE SAME LINE..............?\n         BE    RPTPP0             YES--------------------------------->\n         CLI   4(R11),C' '        ONE LINE SPACING....................?\n         BE    RPTPP1             YES--------------------------------->\n         CLI   4(R11),C'0'        TWO LINES SPACING...................?\n         BE    RPTPP2             YES--------------------------------->\n         CLI   4(R11),C'-'        THREE LINES SPACING.................?\n         BE    RPTPP3             YES--------------------------------->\n         MVI   4(R11),C' '        INVALID PRINT CNTRL CHAR, CHANGE IT\n         B     RPTPP1             TO BLANK (1 LINE SPACING)\nRPTPP0   SLR   R0,R0              SAME LINE PRINTING\n         B     RPTPPB             CHECK LINE COUNT-------------------->\nRPTPP1   LA    R0,1               ONE LINE SPACING\n         B     RPTPPB             CHECK LINE COUNT-------------------->\nRPTPP2   LA    R0,2               TWO LINES SPACING\n         B     RPTPPB             CHECK LINE COUNT-------------------->\nRPTPP3   LA    R0,3               THREE LINES SPACING\nRPTPPB   AL    R0,RPTLCNT         NEW LINE COUNT\n         CL    R0,RPTLPL          FITS ON CURRENT PAGE................?\n         BH    RPTPPN             NO, WE NEED TO START A NEW PAGE----->\n         ST    R0,RPTLCNT         YES, NEW PAGE COUNT\n         LR    R0,R11             PRINT LINE ADDRESS INTO R0\n         L     R1,RPTDCBA         REPORT DCB ADDRESS INTO R1\n         PUT   (1),(0)            PRINT THE REPORT LINE\n         SUBRET RPTPP\n         SPACE\nRPTPPN   BAL   R14,RPTNP          NEW PAGE OF THE REPORT PROC\n         MVI   4(R11),C'0'        TWO LINES SPACING AFTER NEW PAGE\n         B     RPTPP2             PRINT THE LINE ON NEW PAGE\n         SPACE\n*---------------------------------------------------------------------*\n* REPORT HEADER LINE PRINT PROCEDURE                                  *\n* REGISTERS CONTENTS AT ENTRY:                                        *\n* R10 HAS ADDRESS OF THE REPORT DEFINITION BLOCK                      *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTNP    SUBENT\n         MVC   RPTHDRP,=X'402020202120' EDIT MASK INTO HEADER LINE\n         L     R14,RPTPGN         LOAD PAGE NUMBER\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    RPTHDRP,D+5        EDIT THE PAGE NUMBER\n         LA    R14,1(,R14)        PAGE NUMBER + 1\n         ST    R14,RPTPGN         NEXT PAGE NUMBER\n         MVI   RPTHDRT,C' '       BALNK OUT THE HEADER LINE TEXT\n         MVC   RPTHDRT+1(L'RPTHDRT-1),RPTHDRT\n         L     R14,RPTHTA         REPORT HERADER TEXT ADDRESS\n         XR    R1,R1              CLEAR R1\n         IC    R1,0(,R14)         REPORT HEADER TEXT LENGTH\n         LA    R0,L'RPTHDRT       MAX.HEADER TEXT LENGTH\n         CLR   R1,R0              HEADER TEXT DOES NOT EXCEED MAX.....?\n         BNH   RPTNP1             NO, MOVE IT INTO HEADER LINE\n         LR    R1,R0              TEXT TOO LONG, TRUNCATE TO MAXLEN\nRPTNP1   BCTR  R1,0               TEXT LENGTH - 1 (FOR EXECUTE)\n         EX    R1,MVCHDRT         MOVE TEXT INTO HEADER LINE\n         L     R1,RPTDCBA         REPORT DCB ADDRESS INTO R1\n         PUT   (1),RPTHDR         PRINT THE HEADER LINE\n         LA    R1,1               NEW PAGE LINE COUNT\n         ST    R1,RPTLCNT\n* CHECK IF THERE IS A SECOND HEADER LINE TO BE PRINTED\n         L     R0,RPTHTA1         SECOND HEADER LINE ADDRESS\n         LTR   R0,R0              = 0 ................................?\n         BZ    RPTNPR             YES, NO SECOND LINE TO BE PRINTED--->\n         L     R1,RPTDCBA         REPORT DCB ADDRESS INTO R1\n         PUT   (1),(0)            PRINT THE SECOND HEADER LINE\n         L     R1,RPTLCNT\n* WE ARE ASSUMING THE SECOND HEADER LINE HAS ALWAYS '0' CTL CHAR\n         LA    R1,2(,R1)          NEW PAGE LINE COUNT + 2\n         ST    R1,RPTLCNT\nRPTNPR   SUBRET RPTNP             RETURN TO CALLER\n         SPACE\nMVCHDRT  MVC   RPTHDRT(1),1(R14)  MOVE TEXT INTO HEADER LINE\nRPTHDR   DC    AL2(RPTHDRE-RPTHDR) REPORT HEADER LINE RDW - RECLEN)\n         DC    AL2(0)\nRPTHDRC  DC    C'1'               ANSI PRINT CONTROL - NEW PAGE\nRPTHDRT  DS    CL122              HEADET TEXT\n         DC    C'PAGE'\nRPTHDRP  DC    X'402020202120'    PAGE NUMBER\nRPTHDRE  EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT SUMMARY REPORTS FOR THE WHOLE DATA COMPONENT                  *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nDCSUSPR  SUBENT\n* SUMMARY LINE 1\n         MVI   DCSL1C,C'-'        3 LINES SPACING\n         LA    R11,DCSL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* SUMMARY LINE 2\n         MVC   DCSL2N,=X'4020202020202120' EDIT MASK INTO SUMMARY LINE2\n         L     R14,DC#CA          NUMBER OF PROCESSED CA'S\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    DCSL2N,D+4         EDIT THE NUMBER OF CA'S\n         MVI   DCSL2C,C'0'        2 LINES SPACING\n         LA    R11,DCSL2          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* SUMMARY LINE 3\n         MVC   DCSL3N,=X'4020202020202120' EDIT MASK INTO SUMMARY LINE3\n         L     R14,DC#CAFR        NUMBER OF FREE CA'S AT EOF\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    DCSL3N,D+4         EDIT THE NUMBER OF FREE CA'S\n         MVI   DCSL3C,C'0'        2 LINES SPACING\n         LA    R11,DCSL3          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         BAL   R14,BLANKL         PRINT A BLANK LINE ON BOTH REPORTS\n* SUMMARY LINE 3 (SPACE DISTRIBUTION)\n         LA    R6,DCSUS           DATA COMPONENT SUS ADDRESS\n         BAL   R14,RPTGSDL        PRINT THE SPACE DISTRIBUTION LINE\n         MVC   CISIZE,CISIZED     DATA COMPONENT CISIZE\n         BAL   R14,RPTTSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET DCSUSPR           RETURN TO CALLER\n         SPACE\nDCSL1    DC    AL2(DCSL1E-DCSL1)  DC SUMMARY LINE 1\n         DC    AL2(0)\nDCSL1C   DC    C'-'               ANSI PRINT CONTROL - SPACE 3 LINES\nDCSL1T   DC    C'SPACE UTILIZATION SUMMARY FOR THE DATA COMPONENT:'\nDCSL1E   EQU   *\n         SPACE\nDCSL2    DC    AL2(DCSL2E-DCSL2)  DC SUMMARY LINE 2\n         DC    AL2(0)\nDCSL2C   DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\nDCSL2T   DC    C'NUMBER OF PROCESSED (USED) CONTROL AREAS: '\nDCSL2N   DC    X'4020202020202120'\nDCSL2E   EQU   *\n         SPACE\nDCSL3    DC    AL2(DCSL3E-DCSL3)  DC SUMMARY LINE 3\n         DC    AL2(0)\nDCSL3C   DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\nDCSL3T   DC    C'NUMBER OF FREE (UNUSED) CONTROL AREAS AT THE END OF TH+\n               E DATA SET: '\nDCSL3N   DC    X'4020202020202120'\nDCSL3E   EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT SUMMARY REPORTS FOR THE WHOLE INDEX COMPONENT                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nIXSUSPR  SUBENT\n* SUMMARY LINE 1\n         MVI   IXSL1C,C'-'        3 LINES SPACING\n         LA    R11,IXSL1          ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         BAL   R14,BLANKL         PRINT A BLANK LINE\n* SUMMARY LINE 2 (SPACE DISTRIBUTION)\n         LA    R6,IXSUS           INDEX COMPONENT SUS ADDRESS\n         BAL   R14,RPTGSDL        PRINT THE SPACE DISTRIBUTION LINE\n         MVC   CISIZE,CISIZEI     INDEX COMPONENT CISIZE\n         BAL   R14,RPTTSDL        PRINT THE SPACE DISTRIBUTION LINE\n         SUBRET IXSUSPR           RETURN TO CALLER\n         SPACE\nIXSL1    DC    AL2(IXSL1E-IXSL1)  IX SUMMARY LINE 1\n         DC    AL2(0)\nIXSL1C   DC    C'-'               ANSI PRINT CONTROL - SPACE 3 LINES\nIXSL1T   DC    C'SPACE UTILIZATION SUMMARY FOR THE INDEX COMPONENT:'\nIXSL1E   EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT DATA AND/OR INDEX COMPONENT STATISTICS                        *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nPRNTSTAT SUBENT\n         USING AMB,R3             AMB ADDRESSABILITY\n* STATISTICS LINE 1\n         MVI   STL1C,C'-'         3 LINES SPACING\n         MVC   STL1N,AMBDSNM      COMPONENT'S NAME\n         LA    R11,STL1           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n* PREVENT PRINTING OF SECOND HEADER LINE ON FIRST PAGE OF RPTT\n         MVC   RPTGHTA1,RPTTHTA1  SAVE 2ND HDR LINE ADDRESS (IN RPTGDB)\n         XC    RPTTHTA1,RPTTHTA1  CLEAR 2ND HDR ADDRESS (NO PRINT)\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         MVC   RPTTHTA1,RPTGHTA1  REST 2ND HDR LINE ADDRESS\n         XC    RPTGHTA1,RPTGHTA1  CLEAR 2ND HDR ADDRESS (NO PRINT)\n* STATISTICS LINE 2\n         MVC   STL2CI,=X'6020202020202120' EDIT MASK (CI SIZE)\n         L     R14,AMDCINV        CI SIZE\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CI,D+4         EDIT THE CI SIZE\n         MVC   STL2CICA,=X'6020202020202120' EDIT MASK (CI/CA)\n         LH    R14,AMDCIPCA       NO.OF CI'S PER CA\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CICA,D+4       EDIT THE CI/CA\n         XR    R14,R14            CLEAR R14 (BEFORE IC)\n         IC    R14,AMDPCTCI       % OF FREE BYTES IN A CI\n         CVD   R14,D              CONVERT TO DECIMAL\n         MVC   STL2FSCI,=X'602020202120' EDIT MASK (%CI FREESPACE)\n         ED    STL2FSCI,D+5       EDIT THE FREESPACE-%CI\n         IC    R14,AMDPCTCA       % OF FREE CI'S IN THE CA\n         CVD   R14,D              CONVERT TO DECIMAL\n         MVC   STL2FSCA,=X'602020202120' EDIT MASK (%CA FREESPACE)\n         ED    STL2FSCA,D+5       EDIT THE FREESPACE-%CA\n         MVC   STL2CISP,=X'6020202020202120' EDIT MASK (SPLITS-CI)\n         L     R14,AMDNCIS        NO.OF CI SPLITS\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CISP,D+4       EDIT THE SPLITS-CI\n         MVC   STL2CASP,=X'602020202120' EDIT MASK (SPLITS-CA)\n         L     R14,AMDNCAS        NO.OF CA SPLITS\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL2CASP,D+5       EDIT THE SPLITS-CA\n         MVI   STL2C,C'0'         2 LINES SPACING\n         LA    R11,STL2           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n* STATISTICS LINE 3\n         MVC   STL3IXL,=X'60202120' EDIT MASK (IX LVLS)\n         LH    R14,AMDNIL         NUMBER OF INDEX LEVELS\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL3IXL,D+6        EDIT THE IX LEVELS\n         MVC   STL3EXT,=X'602020202120' EDIT MASK (EXTENTS)\n         LH    R14,AMDNEXT        NO.OF EXTENTS IN THE DATA SET\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL3EXT,D+5        EDIT THE EXTENTS #\n         MVC   STL3EXCP,=X'60202020202020202120' EDIT MASK (EXCPS)\n         L     R14,AMDEXCP        NO.OF EXCPS ISSUED BY VSAM\n         CVD   R14,D              CONVERT TO DECIMAL\n         ED    STL3EXCP,D+3       EDIT THE EXCP #\n         MVI   STL3IMBD,C' '      CLEAR IMBED IX INDICATOR\n         MVC   STL3IMBD+1(L'STL3IMBD-1),STL3IMBD\n         TM    AMDATTR,AMDSDT     IMBED INDEX.........................?\n         BNO   PRNTST3X           NO---------------------------------->\n         MVC   STL3IMBD,=C'IMBED IX' YES, INDICATE IMBED INDEX\nPRNTST3X MVI   STL3C,C'0'         2 LINES SPACING\n         LA    R11,STL3           ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         DROP  R3                 drop AMB addressability\n         SUBRET PRNTSTAT          RETURN TO CALLER\n         SPACE\nSTL1     DC    AL2(STL1E-STL1) COMPONENT STATISTICS LINE 1\n         DC    AL2(0)\nSTL1C    DC    C'-'               ANSI PRINT CONTROL - SPACE 3 LINES\nSTL1N    DS    CL44               COMPONENT NAME\nSTL1T    DC    C'STATISTICS:'\nSTL1E    EQU   *\n         SPACE\nSTL2     DC    AL2(STL2E-STL2) DC STATISTICS LINE 2\n         DC    AL2(0)\nSTL2C    DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\n         DC    C'CISIZE'\nSTL2CI   DC    X'6020202020202120'\n         DC    C'    CI/CA'\nSTL2CICA DC    X'6020202020202120'\n         DC    C'    FREESPACE-%CA'\nSTL2FSCA DC    X'602020202120'\n         DC    C'    FREESPACE-%CI'\nSTL2FSCI DC    X'602020202120'\n         DC    C'    SPLITS-CA'\nSTL2CASP DC    X'602020202120'\n         DC    C'    SPLITS-CI'\nSTL2CISP DC    X'6020202020202120'\nSTL2E    EQU   *\n         SPACE\nSTL3     DC    AL2(STL3E-STL3) DC STATISTICS LINE 3\n         DC    AL2(0)\nSTL3C    DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\n         DC    C'IX LEVELS-'\nSTL3IXL  DC    X'60202120'\n         DC    C'    EXTENTS'\nSTL3EXT  DC    X'602020202120'\n         DC    C'    EXCPS'\nSTL3EXCP DC    X'60202020202020202120'\n         DC    C'        '\nSTL3IMBD DS    C'IMBED IX'\nSTL3E    EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT THE SPACE DISTRIBUTION LINE - TABLE FORMAT                    *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRPTTSDL  SUBENT\n* R6 HAS THE SPACE UTILIZATION SUMMARY ADDRESS ( SUS )\n         USING SUS,R6             SUS ADDRESSABILITY\n         LM    R0,R3,SUS          LOAD USPC, CAFSP, CIFSP, IXRSFS\n         LR    R15,R0             USPC INTO R15 AND THEN ADD:\n         ALR   R15,R1             CA FREE SPACE\n         ALR   R15,R2             CI FREE SPACE\n         ALR   R15,R3             UNUSED SPACE BECAUSE IX CI SHORT\n* R15 HAS NOW TOTAL SPACE IN BYTES\n         CVD   R15,D1             CONVERT TOTAL SPACE TO DECIMAL\n*        R0 HAS USED SPACE NOW\n         CVD   R0,D               CONVERT TO BINARY\n         MVC   RPTTL1U,=X'4020206B2020206B2020206B202120' EDIT MASK\n         ED    RPTTL1U,D+2        EDIT THE USED SPACE\n         BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1UP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n* WE ARE GOING TO CALCULATE # OF USED CI'S IN THIS CA\n         XR    R14,R14            CLEAR R14 (BEFORE DIVIDE)\n         LR    R15,R0             USED SPACE IN BYTES\n         AR    R15,R2             + UNUSED CI SPACE IN BYTES\n         D     R14,CISIZE         DIVIDE USED CI'S SPACE BY CISIZE\n         CVD   R15,D              = # CI'S, CONVERT TO BINARY\n         MVC   RPTTL1#O,=X'402020202120' EDIT MASK\n         ED    RPTTL1#O,D+5        EDIT # OF CI'S\n*        R1 HAS CA FREE SPACE\n         CVD   R1,D               CONVERT TO BINARY\n         MVC   RPTTL1C,=X'4020206B2020206B2020206B202120' EDIT MASK\n         ED    RPTTL1C,D+2        EDIT THE FREESPACE-CA\n         BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1CP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n* WE ARE GOING TO CALCULATE # OF FREE CI'S IN THIS CA\n         XR    R0,R0              CLEAR R0 (BEFORE DIVIDE)\n         D     R0,CISIZE          DIVIDE FREE CA SPACE BY CISIZE\n         CVD   R1,D               = # CI'S, CONVERT TO BINARY\n         MVC   RPTTL1#C,=X'402020202120' EDIT MASK\n         ED    RPTTL1#C,D+5        EDIT # OF CI'S\n*        R2 HAS CI FREE SPACE\n         CVD   R2,D               CONVERT TO BINARY\n         MVC   RPTTL1I,=X'4020206B2020206B2020206B202120' EDIT MASK\n         ED    RPTTL1I,D+2        EDIT THE FREESPACE-CI\n         BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1IP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n*        R3 HAS FREE SPACE RESULTING FROM INDEX CI BEING TOO SHORT\n         CVD   R3,D               CONVERT TO BINARY\n         MVC   RPTTL1S,=X'4020206B2020206B2020206B202120' EDIT MASK\n         ED    RPTTL1S,D+2        EDIT THE FREESPACE-CI\n         BAL   R14,RPTTSDLP       CALCULATE AND EDIT THE % OF TOTAL\n         MVC   RPTTL1SP,RPTTPCT+2 MOVE % VALUE INTO THE LINE\n* WE ARE GOING TO CALCULATE # OF UNUSED CI'S IN THIS CA\n         XR    R2,R2              CLEAR R2 (BEFORE DIVIDE)\n         D     R2,CISIZE          DIVIDE UNUSED CA SPACE BY CISIZE\n         CVD   R3,D               = # CI'S, CONVERT TO BINARY\n         MVC   RPTTL1#U,=X'402020202120' EDIT MASK\n         ED    RPTTL1#U,D+5        EDIT # OF CI'S\n* PRINT THE RPTT SPACE DISTRIBUTION LINE\n         MVI   RPTTL1A,C' '       ENSURE ONE LINE SPACING\n         LA    R11,RPTTL1         ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         SUBRET RPTTSDL\n         SPACE\n* CALCULATE AND EDIT PERCENTAGE OF TOTAL SPACE (RPTT LINE RPTTL1)\nRPTTSDLP DS    0H\n* D1 CONTAINS TOTAL SPACE IN BYTES\n* D  CONTAINS A SPACE DISTRIBUTION COMPONENT IN BYTES (DECIMAL)\n         MP    D,=PL2'100'        MULTIPLY BY A 100\n         DP    D,D1+2(6)          DIVIDE BY TOTAL SPACE = %\n         LH    R15,D              LOAD THE QUOTIENT INTO R4 (3 DECIMAL\n*                                 DIGITS PLUS A SIGN)\n         SRL   R15,4              ELIMINATE THE SIGN (SHIFTED OUT)\n         XC    D(2),D             CLEAR TWO H/O BYTES\n* A FIX TO ORIGINAL MULTILPY, REPLACED BY A SHIFT + MVC OF ZEROS/SIGN\n* AT THE END OF THE OPERAND (0C7 EVET THOUGH ENOUGH OF LEADING ZEROS)\n*        MP    D,=PL3'1000'       MULTIPLY REMAINDER BY A 1000\n         STM   R0,R1,R0R1SA       SAVE R0,R1\n         LM    R0,R1,D            LOAD \"D\" INTO R0,R1\n         SLDL  R0,12              SHIFT LEFT BY 12 BITS/3 ZONES\n*                                 = MULTIPLY BY 1000\n         STM   R0,R1,D            STORE RESULT INTO D\n         MVC   D+6(2),=X'000C'    INSERT TRAILING ZEROS + DECIMAL SIGN\n         LM    R0,R1,R0R1SA       RESTORE R0,R1\n* END OF FIX, SEPT. 2/98\n         DP    D,D1+2(6)          DIVIDE BY TOTAL SPACE = %\n*                                 3 DIGITS AFTER DECIMAL POINT\n         MVC   D+6(2),D           MOVE THEM TO THE END OF D\n         STH   R15,D+4            PUT THE 3 DEC DIGITS BACK (SHIFTED\n*                                 ONE POSITION TO THE RIGHT)\n         XC    D(4),D             CLEAR 4 H/O BYTES\n* SHIFT AND ROUND THE PERCENTAGE: 2 DEC.DIGITS TO THE RIGHT. ONE\n* ROUNDED DECIMAL DIGITS AFTER DECIMAL POINT WILL BE LEFT\n         SRP   D,64-2,5\n         MVC   RPTTPCT,=X'40202021204B20' EDIT MASK INTO PERCENTAGE FLD\n         ED    RPTTPCT,D+5        EDIT THE ROUNDED PERCENTAGE\n         BR    R14                RETURN\nR0R1SA   DS    2F                 SAVE AREA FOR R0,R1\nRPTTPCT  DC    X'40202021204B20'  PERCENTAGE WORK FIELD\n         SPACE\nRPTTDB   DS    0CL20              RPTT DEFINITION BLOCK\n*/////////////////////////////////////////////////////////////////////*\nRPTTDCBA DC    A(RPTT)            DCB ADDRESS\nRPTTLPL  DC    A(65)              RPTT LINES PER PAGE LIMIT\nRPTTLCNT DC    A(65)              RPTT LINE COUNT (FORCE FIRST HEADER)\nRPTTPGN  DC    A(1)               RPTT PAGE NUMBER\nRPTTHTA  DC    A(RPTTHLT)         PAGE HEADER LINE TEXT ADDRESS\nRPTTHTA1 DC    A(RPTTL1H)         SECOND PAGE HEADER LINE ADDRESS\n*/////////////////////////////////////////////////////////////////////*\nRPTTHLT  DC    AL1(L'RPTTHLTT)    LENGTH OF THE HEADER LINE TEXT\nRPTTHLTT DC    C'KSDSPACE - RPTT: SPACE DISTRIBUTION IS SHOWN IN BYTES +\n               AND PRECENTAGES OF TOTAL'\n         SPACE\nRPTTL1   DC    AL2(RPTTL1E-RPTTL1)  RPPT LINE 1\n         DC    AL2(0)\nRPTTL1A  DC    C' '               ONE LINE SPACING\nRPTTL1U  DC    X'4020206B2020206B2020206B202120' USED SPACE\n         DC    C' ('\nRPTTL1UP DC    CL5' '             PERCENTAGE OF TOTAL SPACE\n         DC    C')'\nRPTTL1#O DC    X'402020202120'    # OF FREEE CI'S\n         DC    C'   '\nRPTTL1C  DC    X'4020206B2020206B2020206B202120' CA FREE SPACE\n         DC    C' ('\nRPTTL1CP DC    CL5' '             PERCENTAGE OF TOTAL SPACE\n         DC    C')'\nRPTTL1#C DC    X'402020202120'    # OF FREEE CI'S\n         DC    C'   '\nRPTTL1I  DC    X'4020206B2020206B2020206B202120' CI FREE SPACE\n         DC    C' ('\nRPTTL1IP DC    CL5' '             PERCENTAGE OF TOTAL SPACE\n         DC    C')   '\nRPTTL1S  DC    X'4020206B2020206B2020206B202120' CI RECORD SHORT\n         DC    C' ('\nRPTTL1SP DC    CL5' '             PERCENTAGE OF TOTAL SPACE\n         DC    C')'\nRPTTL1#U DC    X'402020202120'    # OF UNUSED CI'S\nRPTTL1E  EQU   *\n         SPACE\nRPTTL1H  DC    AL2(RPTTL1HE-RPTTL1H)  RPPT LINE 1 HEADER\n         DC    AL2(0)\nRPTTL1HA DC    C'-'               THREE LINES SPACING\n         DC    CL15'     USED SPACE'\n         DC    C' ('\n         DC    CL5'   % '         PERCENTAGE OF TOTAL SPACE\n         DC    C')   #CI   '\n         DC    CL15'   FREESPACE-CA'       CA FREE SPACE\n         DC    C' ('\n         DC    CL5'   % '         PERCENTAGE OF TOTAL SPACE\n         DC    C')   #CI   '\n         DC    CL15'   FREESPACE-CI'       CI FREE SPACE\n         DC    C' ('\n         DC    CL5'   % '         PERCENTAGE OF TOTAL SPACE\n         DC    C')   '\n         DC    CL15'   IX REC SHORT'       INDEX RECORD SHORT\n         DC    C' ('\n         DC    CL5'   % '         PERCENTAGE OF TOTAL SPACE\n         DC    C')   #CI'\nRPTTL1HE EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n* PRINT A BLANK LINE ON RPTG AND RPTT                                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nBLANKL   SUBENT\n         MVI   BLANKLC,C' '       ONE LINE SPACING\n         LA    R11,BLANKLN        ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,RPTGDB         ADDRESS OF THE RPTG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         LA    R10,RPTTDB         ADDRESS OF THE RPTT DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         SUBRET BLANKL\nBLANKLN  DC    AL2(BLANKLNE-BLANKLN)\n         DC    AL2(0)\nBLANKLC  DC    C'  '              ANSI PRINT CONTROL - SPACE 3 LINES\nBLANKLNE EQU   *\n         SPACE\n*---------------------------------------------------------------------*\n* INPUT KSDS FILE IS EMPTY                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nKSDSNL   DS    0H\n         LA    R11,EMPTM1         ADDRESS OF THE LINE TO BE PRINTED\n         LA    R10,DMSGDB         ADDRESS OF THE DMSG DEFINITION BLOCK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         B     RC16               TERMINATE WITH RC=16\n         SPACE\nEMPTM1   DC    AL2(EMPTM1E-EMPTM1) EMPTY KSDSFILE ERROR MESSAGE\n         DC    AL2(0)\nEMPTM1C  DC    C'0'               ANSI PRINT CONTROL - SPACE 2 LINES\nEMPTM1T  DC    C'INPUT KSDS DATA SET IS EMPTY. PROCESSING TERMINATED'\nEMPTM1E  EQU   *\n         SPACE\nDMSGDB   DS    0CL20              DIAGNOSTIC MSGS DEFINITION BLOCK\n*/////////////////////////////////////////////////////////////////////*\nDMSGDCBA DC    A(MSGFILE)         DCB ADDRESS\nDMSGLPL  DC    A(65)              DMSG LINES PER PAGE LIMIT\nDMSGLCNT DC    A(65)              DMSG LINE COUNT (FORCE FIRST HEADER)\nDMSGPGN  DC    A(1)               DMSG PAGE NUMBER\nDMSGHTA  DC    A(DMSGHLT)         PAGE HEADER LINE TEXT ADDRESS\nDMSGHTA1 DC    A(0)               NO SECOND HEADER LINE FOR THIS RPT\n*/////////////////////////////////////////////////////////////////////*\nDMSGHLT  DC    AL1(L'DMSGHLTT)    LENGTH OF THE HEADER LINE TEXT\nDMSGHLTT DC    C'KSDSPACE - DIAGNOSTIC MESSAGES'\n         SPACE\n* CLOSE ALL FILES AND TERMINATE\nCLOSE    BAL   R14,CLOSEP         CLOSE ALL FILES\n         SPACE\nRC0      SR    R15,R15            RC = 0 ( NORMAL COMPLETION )\n         SPACE\nRETURN   DS    0H\n         L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)   RETURN\n         SPACE\nRC16     DS    0H                 RC = 16 ( ERROR )\n         BAL   R14,CLOSEP         CLOSE ALL FILES\n         LA    R15,16             RC = 16 ( ERROR )\n         B     RETURN\n         SPACE\n*---------------------------------------------------------------------*\n* CLOSE FILES PROC                                                    *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCLOSEP   SUBENT\n         CLOSE (VSAMF)            CLOSE THE KSDS\n         CLOSE (MSGFILE,,RPTG,,RPTT,,LHKR)\n         SUBRET CLOSEP\n         SPACE\n*---------------------------------------------------------------------*\n* ABEND - INDEX RECORD JUST READ IS NOT A SEQUENCE SET RECORD         *\n*         AS EXPECTED                                                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nABEND0   ABEND 0,DUMP\n         SPACE\n*---------------------------------------------------------------------*\n* OPEN/CLOSE ERROR ROUTINE                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nOPENERR  DS    0H                 OPEN/CLOSE ERROR ROUTINE\n         ST    R15,ACBERROR       SAVE RC FROM R15\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,OCR15     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SHOWCB ACB=VSAMF,AREA=ACBERROR,LENGTH=4,                      +\n               FIELDS=(ERROR)     GET ERROR FIELD FROM ACB\n         LTR   R15,R15            SHOWCB OK...........................?\n         BNZ   SHOWCBER           NO, SHOWCB ERROR-------------------->\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,ACBERF    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX   CONVERT ACB ERROR FIELD TO HEXADECIMAL\n         LA    MSGADDR,OPECLOEM   OPEN/CLOSE ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* VSAM REQUEST ERROR ROUTINE                                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nIXRERROR DS    0H                 GETIX READ ERROR\n         MVC   REQTYPE,=CL11'GETIX' REQUEST TYPE ID\n         LA    R8,RPLIX           RPL ADDRESS\n         B     ERROR              GO TO ERROR PROC-------------------->\nPOINTERR DS    0H                 POINT REQUEST ERROR\n         MVC   REQTYPE,=CL11'POINT'  REQUEST TYPE ID\n         B     DCIRERR1           LOAD ADDRESS OF THE RPL INTO R8----->\nDCIRERR  DS    0H                 DATA CI READ ERROR\n         MVC   REQTYPE,=CL11'GET DATA CI' REQUEST TYPE ID\nDCIRERR1 LA    R8,RPLDC           RPL ADDRESS\n         SPACE\nERROR    DS    0H                 VSAM REQUEST ERROR: GETIX/GET DATA CI\n         ST    R15,ACBERROR       SAVE RC FROM R15\n         SHOWCB RPL=(8),AREA=FTNCD,LENGTH=8,                           +\n               FIELDS=(FTNCD,FDBK)  GET FTNCD AND FDBK FIELD FROM RPL\n         LTR   R15,R15            SHOWCB OK...........................?\n         BNZ   SHOWCBER           NO, SHOWCB ERROR-------------------->\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,FTNCD      INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQFTNCD  OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'FTNCD     LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT FTNCD TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,FDBK       INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,REQFDBK   OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'FDBK      LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT FDBK  TO HEXADECIMAL\n         LA    MSGADDR,REQERRM    VSAM REQUEST ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n*********THESE ARE TEMPORARY, DIAGNOSTIC STMTS*************************\n*        CLOSE (MSGFILE,,RPTG,,RPTT) **********************************\n*        ABEND 1,DUMP ************A TEMPORARY DIAGNOSTIC DUMP**********\n*********THESE ARE TEMPORARY, DIAGNOSTIC STMTS*************************\n         B     RC16               TERMINATE THE PROGRAM--------------->\n         SPACE\n*---------------------------------------------------------------------*\n* SHOWCB ERROR ROUTINE                                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nSHOWCBER DS    0H                 SHOWCB MACRO ERROR\n         STM   R15,R0,ACBERROR    SAVE R15 AND R0 (ERROR CODE)\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,SCBR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,ACBERROR+4 INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,SCBR0     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT ERROR CODE TO HEXADECIMAL\n         SPACE\n         LA    MSGADDR,SCBERRM    SHOWCB ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               TERMINATE THE PROGRAM WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* MODCB ERROR ROUTINE                                                 *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nMODCBER  DS    0H                 MODCB MACRO ERROR\n         STM   R15,R0,ACBERROR    SAVE R15 AND R0 (ERROR CODE)\n         LA    HEXINAR,ACBERROR   INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,MCBR15    OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT RC (R15) TO HEXADECIMAL\n         SPACE\n         LA    HEXINAR,ACBERROR+4 INPUT ADDRESS FOR CONVHEX\n         LA    HEXOUTAR,MCBR0     OUTPUT ADDRESS FOR CONVHEX\n         LA    HEXLEN,L'ACBERROR  LENGTH OF INPUT FIELD TO BE CONVERTED\n         BAL   LNKREG1,CONVHEX    CONVERT ERROR CODE TO HEXADECIMAL\n         SPACE\n         LA    MSGADDR,MCBERRM    SHOWCB ERROR MESSAGE ADDRESS\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n* INPUT FILE IS NOT A KSDS                                            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nNOTKSDS  LA    MSGADDR,NKSDSEM    NON-KSDS DATA SET ON INPUT\n         LA    RPTDBAR,DMSGDB     DIAGNOSTIC MSGS DEFINITION BLOCK\n         BAL   R14,RPTPP          PRINT ERROR MESSAGE\n         B     RC16               RETURN WITH RC=16\n         SPACE\n*---------------------------------------------------------------------*\n*   TRANSLATION OF ERROR CODES INTO HEXADECIMAL SUBROUTINE            *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n* HEXINAR  - INPUT FIELD ADDRESS\n* HEXOUTAR - OUTPUT FIELD ADDRESS\n* HEXLEN   - INPUT FIELD LENGTH\n         SPACE\nCONVHEX  DS    0H\n         IC    TCHR,0(0,HEXINAR)  TRANSLATED CHARACTER\n         SLL   TCHR,24            EXTRACT H/O HEX DIGIT\n         SRL   TCHR,28\n         LA    TCHR,HEXCH(TCHR)   HEX DIGIT ADDRESS\n         MVC   0(1,HEXOUTAR),0(TCHR) MOVE HEX DIGIT INTO OUTPUT STRING\n         IC    TCHR,0(0,HEXINAR)  TRANSLATED CHARACTER\n         SLL   TCHR,28            EXTRACT L/O HEX DIGIT\n         SRL   TCHR,28\n         LA    TCHR,HEXCH(TCHR)   HEX DIGIT ADDRESS\n         MVC   1(1,HEXOUTAR),0(TCHR) MOVE HEX DIGIT INTO OUTPUT STRING\n         LA    HEXINAR,1(0,HEXINAR) NEXT TRANSLATED CHAR ADDRESS\n         LA    HEXOUTAR,2(0,HEXOUTAR) NEXT OUTPUT ADDRESS\n         BCT   HEXLEN,CONVHEX     TRANSLATE NEXT CHARACTER\n         BR    LNKREG1            RETURN TO CALLER\n         SPACE\nHEXCH    DC    C'0123456789ABCDEF' HEXADECIMAL CHARACTERS\n         SPACE\nIXRPT    SUBENT\n* REPORT ON INDEX STRUCTURE: Print # OF IX RECORDS PER IX LEVEL\n* Read index sequentially until SEOF.\n* Print # of index record in each IX level.\n* R4 - Index AMDSB address/pointer (saved in INDXDSBA)\n         USING AMDSB,R4           Index AMDSB ADDRESSABLITY\n* We need to get storage for the IXLVLT table\n         LH    R0,AMDNIL          # of IX levels\n         SLL   R0,1               times 2 = IXLVLT table size\n*                                 (one word for each IX level)\n         GETMAIN R,LV=(0),LOC=(24,31) Get storage for IXLVLT\n         LR    R2,R1              IXLVLT address into R2\n* We need to init the IXLVLT entries to 0\n         USING IXLVLT,R2          IXLVLT addressability\n         LH    R1,AMDNIL          # of IX levels\n         XR    R0,R0              clear R0 (0 value)\n         XR    R3,R3              clear R3 (IXLVLT index reg)\nIXRPT00  STH   R0,IXLVLR#(R3)     clear IXLVLT entry\n         LA    R3,2(,R3)          next IXLVLT entry address\n         BCT   R1,IXRPT00         Contine for all IXLVL entries\n* Now we will start reading index records sequentially until SEOF\n         XC    IXCIRBA,IXCIRBA    Start from begining (RBA=0)\nIXRPTR   DS    0H                 Read of the index record\n         MODCB RPL=RPLIX,         MOVE ARGUMENT ADDRESS INTO RPL       +\n               ARG=IXCIRBA        RBA OF THE INDEX CI\n         GETIX RPL=RPLIX          GET AN INDEX RECORD\n         LTR   R15,R15            GET of index RECORD OK..............?\n         BNZ   IXRERROR           NO, INDEX READ ERROR---------------->\n         L     R5,IXCIADDR        LOAD THE ADDRESS OF THE INDEX RECORD\n         USING IXHDR,R5           INDEX RECORD (HEADER) ADDRESSABILITY\n* CHECK IF THIS IS SEOF (SOFTWARE END-OF-FILE) CI\n         LH    R14,IXHLL          LENGTH OF INDEX RECORD\n         LA    R15,IXHDR+3(R14)   ADDRESS OF THE CIDF FIELD\n         USING CIDF,R15           CIDF ADDRESSABLITY\n         OC    CIDF(4),CIDF       ALL ZEROS IN CIDF...................?\n         BZ    IXRPTEOF           YES, SOFTWARE END-OF-FILE----------->\n* Lets validate the IXHLV field and update IXLVLR# in IXLVLT\n         CLI   IXHLV,X'00'        A valid IX level should be from 1 to\n*                                 AMDNIL\n         BE    IXRPTE1            NO, SOMETHING WRONG, IX level=0----->\n         XR    R3,R3              clear R3\n         IC    R3,IXHLV           This IX recod index level\n         CH    R3,AMDNIL          IX level <= AMDNIL .................?\n         BH    IXRPTE1            NO, SOMETHING WRONG, IX level>max--->\n         BCTR  R3,0               IX level - 1\n         SLL   R3,1               * 2 = IXLVLR# offset in IXLVLT\n* Update IX record cound on this index level\n         LH    R1,IXLVLR#(R3)     current value\n         LA    R1,1(,R1)          + 1\n         STH   R1,IXLVLR#(R3)     current value\n* RBA of next IX record = current record RBA + IX CISIZE\nIXRPTNR  L     R0,IXCIRBA         current record RBA\n         A     R0,AMDCINV         + IX CISIZE\n         ST    R0,IXCIRBA         next record RBA\n         B     IXRPTR             Read next record\n* We read all index record at this point\n* Let's now print the counts (on RPTT only)\nIXRPTEOF DS    0H\n         LA    R11,IXRPTL1        ADDRESS OF headr line\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         TM    AMDATTR,AMDSDT     IMBED INDEX.........................?\n         BO    IXRPTPR0           Yes, will print the comment 1st lne->\n         MVC   IXRPTL2C+1(L'IXRPTL2C-1),IXRPTL2C clear comment for\n*                                 IMBED index (SS IX count not valid)\n* Print IX level/ # of records lines\nIXRPTPR0 LH    R3,AMDNIL          # of IX levels\n         XR    R5,R5              clear R5 (IXLVLT index reg)\nIXRPTPR1 MVC   IXRPTL2L,=X'402020202120' edit mask into # IX level\n         ED    IXRPTL2L,IXRPTL#    edit to character format\n         LH    R0,IXLVLR#(R5)     number of IX records at this level\n         CVD   R0,D               convert to decimal\n         MVC   IXRPTL2R,=X'4020202020202120' edit mask into # of recs\n         ED    IXRPTL2R,D+4        edit to character format\n         LA    R11,IXRPTL2        ADDRESS OF headr line\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         MVC   IXRPTL2C+1(L'IXRPTL2C-1),IXRPTL2C clear comment for\n*                                 IMBED index (SS IX count not valid)\n         LA    R5,2(,R5)          next IXLVLT entry address\n         AP    IXRPTL#,=PL1'1'    Index level +1\n         BCT   R3,IXRPTPR1        Contine for all IXLVL entries\n* We are done with IX levels report, let's free the IXLVLT\n         LH    R0,AMDNIL          # of IX levels\n         SLL   R0,1               times 2 = IXLVLT table size\n*                                 (one word for each IX level)\n         LR    R1,R2              IXLVLT address into R2\n         FREEMAIN R,LV=(0),A=(1)  Free IXLVLT\nIXRPTEX  SUBRET IXRPT             Return back to caller\n         SPACE\nIXRPTE1  DS    0H                 Index level invalid (0 or > max)\n         MVC   IXRPTL3R,=X'4020206B2020206B2020206B202120'\n         L     R0,IXCIRBA         RBA of this index record\n         CVD   R0,D               convert to decimal\n         ED    IXRPTL3R,D+2       edit to character format\n         LA    R11,IXRPTL3        ADDRESS OF error msg line\n         LA    R10,RPTTDB         ADDRESS OF THE REPORT DEFINITION BLK\n         BAL   R14,RPTPP          REPORT PRINT PROCEDURE\n         B     IXRPTNR            Read next IX record\n         DROP  R2,R4,R5,R15       drop addressability for IXRPT\n*********WORKING HERE NOW*************************************\n         SPACE\nIXRPTL#  DC    PL3'1'             IX level\nIXRPTL1  DC    AL2(IXRPTL1E-IXRPTL1) IXRPT header line\n         DC    AL2(0)\n         DC    C'0Index level    # of records'\nIXRPTL1E EQU   *\n         SPACE\nIXRPTL2  DC    AL2(IXRPTL2E-IXRPTL2) IXRPT line 2\n         DC    AL2(0)\n         DC    C' '               ONE LINE SPACING\nIXRPTL2L DC    X'402020202120'    Index level\n         DC    C'          '\nIXRPTL2R DC    X'4020202020202120'  # OF IX CIs at this level\nIXRPTL2C DC    C' <-- SS IX count invalid when IMBED'\nIXRPTL2E EQU   *\n         SPACE\nIXRPTL3  DC    AL2(IXRPTL3E-IXRPTL3) IXRPT index error line\n         DC    AL2(0)\n         DC    C'0Index level invalid in IX record, RBA='\nIXRPTL3R DC    X'4020206B2020206B2020206B202120' RBA of IX record\n         DC    C' record ignored'\nIXRPTL3E EQU   *\n         SPACE\n*/////////////////////////////////////////////////////////////////////*\n*        THE FOLLOWING FULLWORDS ARE LOCATION DEPENDENT               *\nDISPLAY  DS    0F                 FIELDS OBTAINED BY SHOWCB           *\nLRECL    DS    F                  MAX. LRECL                          *\nRKP      DS    F                  RELATIVE KEY POSITION               *\nKEYLEN   DS    F                  KEY LENGTH                          *\nACBERROR DS    F                  ACB ERROR FIELD                     *\nFTNCD    DS    F                  RPL FUNCTION CODE                   *\nFDBK     DS    F                  RPL FEEDBACK FIELD                  *\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n         IFGACB DSECT=NO,AM=VSAM       ACB LAYOUT\n         ORG   IFGACB\nVSAMF    ACB   AM=VSAM,DDNAME=KSDS,MACRF=(CNV,DIR,SEQ),STRNO=2\n         SPACE\nRPLIX    RPL   ACB=VSAMF,              RPL TO READ AN INDEX SS CI      +\n               AREA=IXCIADDR,AREALEN=4,  FIELD FOR CI ADDRESS          +\n               OPTCD=(CNV,DIR,NUP,LOC)\nIXCIADDR DS    CL4                     INDEX CI ADDRESS IN A BUFFER\n         SPACE\nRPLDC    RPL   ACB=VSAMF,              RPL TO READ DATA COMPONENT      +\n               AREA=DCCIADDR,AREALEN=4,  FIELD FOR CI ADDRESS          +\n               OPTCD=(CNV,SEQ,NUP,LOC)\nDCCIADDR DS    CL4                     DATA  CI ADDRESS IN A BUFFER\n         SPACE\n*  MESSAGE SEQL DATA SET\nMSGFILE  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=VBA,            +\n               LRECL=137,EXLST=MSGEXLST\nMSGEXLST DS    0F\n         DC    X'85',AL3(MSGDCBEX) EXIT FOR BLKSIZE NOT SPECIFIED\n*  RPTG SEQL DATA SET\nRPTG     DCB   DSORG=PS,MACRF=PM,DDNAME=RPTG,RECFM=VBA,                +\n               LRECL=137,EXLST=MSGEXLST\n*  RPTT SEQL DATA SET\nRPTT     DCB   DSORG=PS,MACRF=PM,DDNAME=RPTT,RECFM=VBA,                +\n               LRECL=137,EXLST=MSGEXLST\n*  LHKR (LO/High key per CA) report output file\n*  Max possible key lenght is specified. It will be adjusted/changed\n*  after VSAM KSDS ACB open\nLHKR     DCB   DSORG=PS,MACRF=PM,DDNAME=LHKR,RECFM=VBA,                +\n               EXLST=MSGEXLST,LRECL=(LHKL1E-LHKL1)\n         SPACE\nRPTOPNER DS    0H                 MSG DCB OPEN ERROR\n         WTL   'KSDSPACE  - A REPORT DATA SET COULD NOT BE OPEN'\n         B     RC16\n         SPACE\nMSGDCBEX DS    0H                 EXIT IF BLKSIZE NOT SPECIFIED        +\n                                  MSG AND REPORT DATA SETS\n         USING IHADCB,R1          DCB ADDRESSABILITY\n         LH    R2,DCBBLKSI        LOAD BLKSIZE\n         LTR   R2,R2              BLKSIZE=0 ..........................?\n         BNZR  R14                NO,RETURN <----------------\n         LH    R2,DCBLRECL        LRECL\n         LA    R2,4(,R2)          BLKSIZE = LRECL + 4 (RECFM=VB)\n         STH   R2,DCBBLKSI        BLKSIZE=LRECL+4======================\n         BR    R14                RETURN    <----------------\n         DROP  R1\n         SPACE\nOPECLOEM DC    AL2(OPECLOME-OPECLOEM) OPEN/CLOSE ERROR MESSAGE\n         DC    AL2(0)\n         DC    C'0OPEN/CLOSE ERROR  R15='\nOCR15    DS    CL8                RC CODE IN R15\n         DC    C' ACB ERROR FIELD='\nACBERF   DS    CL8                ACB ERROR FILED\nOPECLOME EQU   *\n         SPACE\nREQERRM  DC    AL2(REQERRME-REQERRM) GET | PUT | ERASE ERROR MSG\n         DC    AL2(0)\n         DC    C'0VSAM '\nREQTYPE  DC    CL11'GET DATA CI'  REQUEST TYPE\n         DC    C' REQUEST ERROR  R15='\nREQR15   DS    CL8                RC CODE IN R15\n         DC    C' FTNCD='\nREQFTNCD DS    CL8                REQUEST FUNCTION CODE\n         DC    C' FDBK='\nREQFDBK  DS    CL8                REQUEST FEEDBACK FIELD\nREQERRME EQU   *\n         SPACE\nSCBERRM  DC    AL2(SCBERRME-SCBERRM) SHOWCB MACRO ERROR\n         DC    AL2(0)\n         DC    C'0SHOWCB MACRO ERROR  R15='\nSCBR15   DS    CL8                RC CODE IN R15\n         DC    C' R0='\nSCBR0    DS    CL8                REQUEST FUNCTION CODE\nSCBERRME EQU   *\n         SPACE\nMCBERRM  DC    AL2(MCBERRME-MCBERRM) MODCB MACRO ERROR MSG\n         DC    AL2(0)\n         DC    C'0MODECB MACRO ERROR  R15='\nMCBR15   DS    CL8                RC CODE IN R15\n         DC    C' R0='\nMCBR0    DS    CL8                REQUEST FUNCTION CODE\nMCBERRME EQU   *\n         SPACE\nNKSDSEM  DC    AL2(NKSDSEME-NKSDSEM) NOT KSDS FILE ERROR MESSAGE\n         DC    AL2(0)\n         DC    C'0NON-KSDS DATA SET IS NOT ALLOWED AS INPUT TO THIS PRO+\n               GRAM'\nNKSDSEME EQU   *\n         SPACE\nSGL1     DC    AL2(SGL1E-SGL1) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'-*  REPRESENTS SPACE USED BY DATA RECORDS'\nSGL1E    EQU   *\nSGL2     DC    AL2(SGL2E-SGL2) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'0-  REPRESENTS UNUSED CONTROL INTERVALS RESULTING FROM+\n                CA-FREESPACE SPECIFICATION AND/OR CA SPLITS'\nSGL2E    EQU   *\nSGL3     DC    AL2(SGL3E-SGL3) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'0X  REPRESENTS UNUSED CI SPACE RESULTING FROM CI-FREES+\n               PACE SPECIFICATION AND/OR CI SPLITS'\nSGL3E    EQU   *\nSGL4     DC    AL2(SGL4E-SGL4) LEGEND LINE FOR RPTG\n         DC    AL2(0)\n         DC    C'0+  REPRESENTS UNUSED CA SPACE RESULTING FROM INDEX CI+\n                BEING TOO SHORT'\nSGL4E    EQU   *\n         SPACE\n* WORK AREAS/FILEDS\n         DS    0D\nD        DS    D                  A DOUBLEWORD\nD1       DS    D                  A DOUBLEWORD\nDATADSBA DS    A                  DATA COMPONENT STATISTICS BLOCK ADDR\nINDXDSBA DS    A                  INDEX COMPONENT STATISTICS BLOCK ADDR\nIXCIRBA  DS    F                  RBA OF THE NEXT INDEX (SS) CI TO BE\n*                                 READ\nDCCIRBA  DS    F                  RBA OF THE DATA CI TO BE READ\nDCCIRBAC DC    F'0'               RBA OF THE RETRIEVED DATA CI\nVPLENGTH DS    F                  VERTICAL POINTER LENGTH IN AN INDEX\n*                                 ENTRY\nIXECILEN DS    F                  INDEX ENTRY CONTROL INFO.LENGTH\nCISIZE   DS    F                  CISIZE FOR THE RPTTSDL SUBROUTINE\nCISIZED  DS    F                  DATA COMPONENT CISIZE\nCISIZEI  DS    F                  INDEX COMPONENT CISIZE\n         SPACE\n* INDEX (SEQUENCE SET) SPACE UTILIZATION SUMMARY\n*/////////////////////////////////////////////////////////////////////*\nIXSUS    DS    0CL16              4 FULLWORDS (LOCATION DEPENDENT)\nIXUSPC   DC    F'0'               USED SPACE IN THE SEQUENCE SET\nIXCAFSP  DC    F'0'               CA FREE SPACE (NOT USED FOR SS)\nIXCIFSP  DC    F'0'               CI FREE SPACE\nIXIXRSFS DC    F'0'               UNUSED CI'S BECAUSE IX CI SHORT\n*                                 (NOT USED FOR SS)\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n* DATA COMPONENT SPACE UTILIZATION SUMMARY\n*/////////////////////////////////////////////////////////////////////*\nDCSUS    DS    0CL24              6 FULLWORDS (LOCATION DEPENDENT)\nDCUSPC   DC    F'0'               USED SPACE IN THE DATA COMPONENT\nDCCAFSP  DC    F'0'               CA FREE SPACE\nDCCIFSP  DC    F'0'               CI FREE SPACE\nDCIXRSFS DC    F'0'               UNUSED CI'S BECAUSE IX CI SHORT\nDC#CA    DC    F'0'               NUMBER OF PROCESSED (USED CA'S)\n*                                 IN THE DATA COMPONENT\nDC#CAFR  DC    F'0'               NUMBER OF FREE (UNUSED) CA'S AT\n*                                 THE END OF THE DATA SET\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n* DATA COMPONENT CONTROL AREA SPACE UTILIZATION SUMMARY\n*/////////////////////////////////////////////////////////////////////*\nCASUS    DS    0CL20              5 FULLWORDS (LOCATION DEPENDENT)\nCAUSPC   DC    F'0'               USED SPACE IN THE CA\nCACAFSP  DC    F'0'               CA FREE SPACE\nCACIFSP  DC    F'0'               CI FREE SPACE\nCAIXRSFS DC    F'0'               UNUSED CI'S BECAUSE IX CI SHORT\nCA#FCI   DC    H'0'               NUMBER OF FREE CI'S IN THE CA\nCA#UCI   DC    H'0'               NUMBER OF USED CI'S IN THE CA\n*/////////////////////////////////////////////////////////////////////*\n*\n* WORK FIELDS FOR THE CURRENT CA: USED TO MAKE AN ASSUMPTION THAT\n* NEXT SECTION OF INDEX COULD NOT BE CREATED AND THAT ALL CI'S\n* CANNOT BE ADDRESSED BY THIS SS IX RECORD\n*\nCAIXRLSL DC    H'0'              IX SS RECORD: LAST IX SECTION LENGTH\n*                                 (LAST SECTION CONTROL FIELD VALUE)\nCAIXRFSP DC    H'0'              IX SS RECORD: FREE SPACE IN THIS REC\n*\n* DFP/DFSMS LEVEL FLAG\nDFLEVEL  DC    X'00'              DFP/DFSMS LEVEL/ CAPABILITIES FLAGS\nDFPRE130 EQU   X'01'              PRE DFSMS 1.3.0 LEVEL\n* Controls area processing flags\nCAFLAGS  DC    X'00'              Control Area processing flags\nCAFFDRP  EQU   X'01'              First data record in this CA has\n*                                 been processed (used for low/high\n*                                 key report processing)\n         SPACE\nLHKRDB   DS    0CL20              LHKR DEFINITION BLOCK\n*/////////////////////////////////////////////////////////////////////*\nLHKRDCBA DC    A(LHKR)            DCB ADDRESS\nLHKRLPL  DC    A(65)              LHKR LINES PER PAGE LIMIT\nLHKRLCNT DC    A(65)              LHKR LINE COUNT (FORCE FIRST HEADER)\nLHKRPGN  DC    A(1)               LHKR PAGE NUMBER\nLHKRHTA  DC    A(LHKRHLT)         PAGE HEADER LINE TEXT ADDRESS\nLHKRHTA1 DC    A(0)               NO SECOND HEADER LINE FOR THIS RPT\n*/////////////////////////////////////////////////////////////////////*\nLHKRHLT  DC    AL1(LHKRHLTE-LHKRHLTT)  LENGTH OF THE HEADER LINE TEXT\nLHKRHLTT DC    C'     CA#     CI RBA Low/High data record key '\n         DC    C'in CA, KeyLength=' +\nLHKRHLKL DC    X'4020202020202120' Key length\nLHKRHLTE EQU   *\n         SPACE\n* Low/high key report print line\n* The record length will be set to (LHKL1KEY-LHKL1) + key length\n* After KSDS ACB open\nLHKL1    DC    AL2(LHKL1E-LHKL1)  Low/high key print line\n         DC    AL2(0)\nLHKL1CA# DC    X'4020202020202120' Control Area number\nLHKL1RBA DC    X'402020202020202020202120' RBA of this data CI\n         DC    X'40'\nLHKL1KEY DS    CL255              Low/High key (max 255 chars)\nLHKL1E   EQU   *\n         SPACE\n         LTORG\n* This is a CSECT with some static data in order to relieve somewhat\n* the adressability constraints (we are approaching the 2 base\n* registers limit).\nKSDSPACD CSECT\n*\n* CAMLST FOR OBTAIN MACRO. OBTAIN READS 96 BYTES DATA PORTION OF FMT1\n* DSCB (STARTING ON DS1FMTID, THAT'S WHY DS1FMTID IS CODED IN WORKAREA\n* PARM OF CAMLST). OBTAIN WILL READ DATA INTO THE AREA GENERATED BY\n* IECSDSL1 MACRO.\n         PRINT GEN\nCAMLSTO  CAMLST SEARCH,DS1DSNAM,DS1DSSN,DS1FMTID\n         IECSDSL1 (1)           FORMAT 1 DSCB DATA SET NAME AND BUFFER\n         DS    CL(140-(DS1END-DS1FMTID)) OBTAIN WORKAREA HAS TO BE 140\n*              BYTES. THIS PADDS THE REQUIRED BYTES\nCODENDS  EQU   *\n         SPACE\n* VSAM ACCESS METHOD DATA SET STATISTICS BLOCK\nAMDSB    DSECT\nAMDSBID  DS    XL1                CONTROL BLOCK IDENTIFIER, X'60'\nAMDATTR  DS    XL1                ATTRIBUTES OF THE DATA SET:\nAMDDST   EQU   X'80'              KEY-SEQUENCED DATA SET\nAMDWCK   EQU   X'40'              CHECK EACH RECORD WHEN IT IS WRITTEN\nAMDSDT   EQU   X'20'              SEQUENCE SET IS STORED WHITH THE\n*                                 DATA AND REPLICATED\nAMDREPL  EQU   X'10'              ALL INDEX RECORDS ARE REPLICATED\nAMDORDER EQU   X'08'              USE THE VOLUMES IN THE SAME ORDER\n*                                 AS IN THE VOLUME LIST\nAMDRANGE EQU   X'04'              THE DATA SET IS DIVIDED INTO KEY\n*                                 RANGES\nAMDRRDS  EQU   X'02'              RELATIVE RECORD DATA SET\nAMDSPAN  EQU   X'01'              THE DATA SET CONTAINS SPANNED RECORDS\nAMDLEN   DS    XL2                LENGTH OF THE AMDSB\nAMDNEST  DS    XL2                NUMBER OF INDEX ENTRIES IN THE INDEX\n*                                 SECTION\nAMDRKP   DS    XL2                RELATIVE KEY POSITION\nAMDKEYLN DS    XL2                KEY LENGTH\nAMDPCTCA DS    XL1                % OF FREE CI IN THE CA\nAMDPCTCI DS    XL1                % OF FREE BYTES IN THE CI\nAMDCIPCA DS    XL2                NO. OF CONTROL INTERVALS IN A CA\nAMDFSCA  DS    XL2                NO. OF FREE CONTROL INTERVALS IN A CA\nAMDFSCI  DS    XL4                NO. OF FREE BYTES IN A CI\nAMDCINV  DS    XL4                CONTROL INTERVAL SIZE\nAMDLRECL DS    XL4                MAXIMUM RECORD LENGTH\nAMDHLRBA DS    XL4                RBA OF THE HIGH-LEVEL INDEX RECORD\nAMDNSLOT EQU   AMDHLRBA           NO. OF RECORD SLOTS PER CI\nAMDSSRBA DS    XL4                RBA OF THE FIRST SEQUENCE-SET RECORD\nAMDPARDB DS    XL4                ADDRESS OF THE FIRST ARDB\nAMDSTAT  DS    0CL56              DATA SET STATISTICS\nAMDATTR3 DS    XL1                ATTRIBUTES OF THE DATA SET\nAMDUNQ   EQU   X'80'              THE DATA SET HAS NONUNIQUE KEYS\nAMDLM    EQU   X'08'              DATA SET IS LOADED\nAMDSTRNO DS    XL1                NO.OF CONCURRENT REQUESTS\nAMDDUI   DS    XL4                IMS DBRC USAGE INDICATOR\nAMDBFNO  DS    XL2                NUMBER OF BUFFERS\nAMDSTSP  DS    XL8                SYSTEM TIME STAMP\nAMDNIL   DS    XL2                NUMBER OF INDEX LEVELS\nAMDNEXT  DS    XL2                NUMBER OF EXTENTS IN THE DATA SET\nAMDNLR   DS    XL4                NUMBER OF USER SUPPLIED RECORDS\nAMDDELR  DS    XL4                NUMBER OF DELETED RECORDS\nAMDIREC  DS    XL4                NUMBER OF INSERTED RECORDS\nAMDUPR   DS    XL4                NUMBER OF UPDATED RECORDS\nAMDRETR  DS    XL4                NUMBER OF RETRIEVED RECORDS\nAMDASPA  DS    XL4                NO.OF BYTES OF FREE SPACE\nAMDNCIS  DS    XL4                NO.OF CI SPLITS\nAMDNCAS  DS    XL4                NO.OF CA SPLITS\nAMDEXCP  DS    XL4                NO.OF EXCPS ISSUED BY VSAM ROUTINES\n         SPACE\n* ACCESS METHOD BLOCK\nAMB      DSECT\nAMBID    DS    XL1                CONTROL BLOCK IDENTIFIER, X'40'\nAMBRSC   DS    XL1                RESOURCE TS BYTE\nAMBLEN   DS    XL2                LENGTH OF THE AMB\nAMBLINK  DS    XL4                ADDRESS OF THE NEXT AMB IN THE CHAIN\nAMBBUFC  DS    XL4                ADDRESS OF THE BUFC HEADER\nAMBPH    DS    XL4                ADDRESS OF PLH HEADER\nAMBCACB  DS    XL4                ADDRESS OF THE VSAM CATALOG'S ACB\nAMBDSB   DS    XL4                ADDRESS OF THE AMDSB\nAMBEOVR  DS    XL1                END-OF-VOLUME REQUEST TYPE\nAMBFLG0  EQU   AMBEOVR            MVM AMB FLAGS:\nAMBPSDS  EQU   X'80'              PAGE SPACE\nAMBSWSP  EQU   X'40'              SWAP SPACE\nAMBSHR1  EQU   X'20'              SHARE OPTION\nAMBFLG1  DS    XL1                INDICATOR FLAGS:\nAMBCREAT EQU   X'80'              THE OBJECT IS BEING CREATED (LOADED)\nAMBTYPE  EQU   X'40'              THE AMB DESCRIBES THE KSDS INDEX\nAMBMCAT  EQU   X'20'              THE AMB DESCRIBES THE MASTER CATALOG\nAMBUCAT  EQU   X'10'              THE AMB DESCRIBES A USER CATALOG\nAMBSPEED EQU   X'08'              SPEED OPTION\nAMBUBUF  EQU   X'04'              USER BUFFERING HAS BEEN SPECIFIED\nAMBJRN   EQU   X'02'              EXLST HAS A JOURNALING EXIT RTN ADDR\nAMBINBUF EQU   X'01'              THE DATA SET IS SHARED - DIRECT BUF\nAMBDSORG DS    XL2                DATA SET ORGANIZATION INDICATORS\nAMBIOMB  DS    XL4                ADDRESS OF THE IOMB\nAMBCDSN  DS    XL3                DSN OF THE CATALOG\nAMBDDSN  DS    XL3                DSN OF OBJECT ASSOC.WITH THE AMB\n         DS    XL2                RESERVED\nAMBTIOT  DS    XL2                OFFSET TO TIOT\nAMBINFL  DS    XL1                INDICATOR FLAGS\nAMBCAT   EQU   X'10'              THE AMB DESCRIBES A CATALOG\nAMBSCRA  EQU   X'08'              CRA IS IN SYSTEM STORAGE\nAMBUCRA  EQU   X'04'              CRA IS IN USER'S STORAGE\nAMBUPX   EQU   X'02'              AN UPGRADE TABLE (UPT) EXISTS\nAMBSDS   EQU   X'01'              SYSTEM DATA SET\nAMBAMETH DS    XL1                VSAM ACCESS METHOD INDICATOR\nAMBDEBPT DS    0XL4               DEB ADDRESS\nAMBIFLGS DS    XL1                ERROR FLAGS\nAMBDEBAD DS    XL3                DEB ADDRESS\nAMBOFLGS DS    XL1                OPEN STATUS FLAGS:\nAMBOPEN  EQU   X'10'              THE AMB IS OPEN\nAMBEXFG  EQU   X'02'              USER EXIT ROUTINES ARE ACTIVE\nAMBBUSY  EQU   X'01'              BUSY BIT\nAMBFLG2  DS    XL1                FLAG BYTE 2:\nAMBPUG   EQU   X'80'              DATA SET IS AN AIX IN AN UPGRADE SET\nAMBSHR   EQU   X'40'              DATA SET USING SHARE OPTIONS 3 OR 4\nAMBUP    EQU   X'20'              UPAD IS PRESENT\nAMBRPT   DS    XL2\nAMBEDB   DS    XL4                ADDRESS OF THE EDB\nAMBEOVPT DS    XL4                ADDRESS OF THE AMBXN FOR AN EOV REQ.\nAMBAMBXN EQU   AMBEOVPT           POINTER TO AMB EXTENTION IN MVB\nAMBWKA   DS    XL4                ADDRESS OF THE AMB WORK AREA\nAMBIWA   DS    XL4                ADDRESS OF THE DIWA\nAMBIOBA  DS    XL4                ADDRESS OF THE IOB\nAMBSVI   EQU   AMBIOBA            OBJECT VSI POINTER\nAMBPIXP  DS    XL4                ADDRESS OF THE INDEX'S AMB\nAMBPAMBL DS    XL4                ADDRESS OF THE PRIMARY AMBL\nAMBUPLH  DS    XL4                ADDRESS OF UPGRADE PLACEHOLDER\nAMBAFLG  DS    XL1                FLAG BYTE:\nAMBLSR   EQU   X'40'              LOCAL SHARED RESOURCES\nAMBGSR   EQU   X'20'              GLOBAL SHARED RESOURCES\nAMBICI   EQU   X'10'              IMPROVED CONTROL-INTERVAL ACCESS\nAMBDFR   EQU   X'08'              DEFER WRITE OPERATIONS\nAMBSIS   EQU   X'04'              SEQUENTIAL INSERT STRATEGY\nAMBCFX   EQU   X'02'              CONTROL BLOCKS FIXED IN REAL STORAGE\n         DS    XL1                RESERVED\nAMBRDCNT DS    XL2                RESERVED\nAMBBM2SH DS    XL4                RESERVED\nAMBCPA   DS    XL4                LSR - ADDRESS OF THE WSHD\n*                                 NSR - ADDR OF THE FIRST CPA IN CHAIN\nAMBWSHD  DS    XL4                ADDR OF WORKING STORAGE HEADER\nAMBEXEX  DS    XL8                NAME OF USER EXCPETION EXIT ROUTINE\nAMBSZRD  DS    XL2                SIZE OF THE CHANNEL PROG. FOR READ\nAMBSZWR  DS    XL2                SIZE OF THE CHANNEL PROG. FOR WRITE\nAMBSZFW  DS    XL2               SIZE OF THE CHAN.PROG.FOR FORMAT WRITE\nAMBSZCP  DS    XL2                SIZE OF THE CPA BASE\nAMBVIOT  DS    XL4                ADDR OF THE VALID-IOMB TABLE\nAMBTRACE DS    XL4                ADDRESS OF TRACE TABLE\nAMBPAL   DS    XL3                PRIMARY ALLOCATION QUANTITY\n         DS    XL1                RESERVED\nAMBBSAL  DS    XL3                SECONDARY ALLOCATION QUANTITY\n         DS    XL1                RESERVED\nAMBSOPT  DS    XL1                ALLOCATION OPTION\nAMBRNLEN DS    0XL3               RNAME LENGTHS\nAMBRLN   DS    XL1                LENGTH OF RNAME\nAMBDSLN  DS    XL1                LENGTH OF DSNAME\nAMBCATLN DS    XL1                LENGTH OF CATALOG DSNAME\nAMBDSNM  DS    CL44               COMPONENT NAME\nAMBUPAD  DS    XL4                POINER TO UPAD ROUTINE\nAMBJRNAD DS    XL4                POINER TO JRNAD ROUTINE\n         SPACE\n* ADDRESS RANGE DEFINITION BLOCK\nARDB     DSECT\nARDID    DS    XL1                CONTROL BLOCK ID, X'61'\nARDTYPE  DS    XL1                TYPE OF SPACE DEFINED BY THE ARDB:\nARDKR    EQU   X'80'              ONE KEY RANGE OF A KEY-RANGE DATA SET\nARDHLI   EQU   X'40'              THE TOTAL INDEX OF A KSDS, OR\n*                                 NON SS INDEX PART IF SS IS IMBEDED\nARDSS    EQU   X'20'              THE SS OF A KSDS IF SS IS IMBEDED\nARDUOVFL EQU   X'10'              OVERFLOW MAY BE USED FOR THIS KEY RNG\nARDEOD   EQU   X'08'              KEY RANGE WITH HIGHEST DATA RBA\nARDUSED  EQU   X'04'              THE ARDHRBA INITIAL VALUE HAS CHANGED\nARDUPD   EQU   X'02'              ARDB MODIFIED\nARDLEN   DS    XL2                LENGTH OF THE ARDB\nARDNPTR  DS    XL4                POINTER TO NEXT ARDB IN THE CHAIN\nARDHKRBA DS    XL4                RBA OF DATA CI WITH HIGHEST KEY\nARDHRBA  DS    XL4                RBA OF NEXT FREE SPACE CI AT THE EOF\nARDERBA  DS    XL4                RBA OF THE HIGHEST CI ALLOCATED\nARDVOLSR DS    CL6                VOLSER WITH HIGHEST RBA ALLOCATED\nARDRELNO DS    XL2                SEQ.NO.OF THE DATA SET GROUP SET\nARDPRF   DS    XL1                PREFORMAT FLAGS:\nARDPRSS  EQU   X'80'              THE SS IS STORED WITH DATA\nARDPRFMT EQU   X'40'              THE KEY RANGE'S EXTENTS HAS BEEN\n*                                 PREFORMATTED\nARDKEYS  DS    0XL1               LOW AN HIGH KEY VALUES (2 * KEYLEN)\n         SPACE\n* INDEX RECORD HEADER DSECT\nIXHDR    DSECT\nIXHLL    DS    XL2                IX RECORD LENGTH (CI SIZE - 7)\nIXHFLPLN DS    XL1                LENGTH OF CONTROL INFO. IN EACH\n*                                 INDEX ENTRY (IBFLPF, IBFLPL, IBFLP3)\nIXHPTLS  DS    XL1                VERTICAL POINTERS LENGTH\nIXHBRBA  DS    XL4                SS - RBA OF THE DATA CA\nIXHHP    DS    XL4                HORIZONTAL POINTER (RBA) TO NEXT REC.\nIXHXX    DS    XL4                RESERVED\nIXHLV    DS    XL1                INDEX LEVEL NUMBER ( = 1 FOR SS )\nIXHFLGS  DS    XL1                RESERVED\nIXHFSO   DS    XL2                FREE SPACE OFFSET (IN THIS CI)\nIXHLEO   DS    XL2                LAST INDEX ENTRY OFFSET\nIXHSEO   DS    XL2                OFFSET OF THE LAST ENTRY IN THE FIRST\n*                                 SECTION\n         SPACE\n* SPACE UTILIZATION SUMMARY (FOR CA, SS, DATA SET)\nSUS      DSECT\nUSPC     DC    F'0'               USED SPACE IN THE DATA COMPONENT\nCAFSP    DC    F'0'               CA FREE SPACE\nCIFSP    DC    F'0'               CI FREE SPACE\nIXRSFS   DC    F'0'               UNUSED CI'S BECAUSE IX CI SHORT\n         SPACE\n* CONTROL INTERVAL DEFINITION FIELD FORMAT\nCIDF     DSECT\nCIDFOSET DS    XL2                OFFSET OF UNUSED SPACE OR CNTRL INFO.\n*                                 (= RECL (CI-7) FOR IX)\nCIDF11   DS    XL2                LENGTH OF UNUSED SPACE (=0 FOR IX)\n         SPACE\n* INDEX ENTRY CONTROL INFORMATION FORMAT\nIXECIFMT DSECT\nIBFLPF   DS    XL1                FRONT-KEY COMPRESSION COUNT\nIBFLPL   DS    XL1                LENGTH OF IXKEY FIELD IN THIS ENTRY\nIBFLP3   DS    XL3                POINTER TO DATA CI (1 TO 3 BYTES)\n*                                 This is data CI number in this CA\n*                                 (beginning at 0)\n         SPACE\n* DATA CI Record Definition Field pair (Left and Right)\n* If RDF is not paired - there is only the one (Right) RDF\nRDF      DSECT\n* Left  RDF\nLRDFF    DS    XL1                Control field (flags)\n*                                 For spanned records:\nLRDFFS   EQU   X'10'              - first segment\nLRDFLS   EQU   X'20'              - last  segment\nLRDFIS   EQU   X'30'              - intermediate segment\nLRDF#R   EQU   X'08'              Non spanned: # of recs of same length\n*                                 Spanned recs: segment update #\nLRDF#    DS    XL2          Fixed length non spanned: # of records\n*                           Spanned : segment update number\n* Right RDF\nRRDFF    DS    XL1                Control field (flags)\nRRDFP    EQU   X'40'              a paired RDF to the left of this one\n*                                 For spanned records:\nRRDFFS   EQU   X'10'              - first segment\nRRDFLS   EQU   X'20'              - last  segment\nRRDFIS   EQU   X'30'              - intermediate segment\nRRDF#    DS    XL2                record/segment/slot length\n         SPACE\n* REPORT DEFINITION BLOCK\n* ALLOWS TO USE ONE PROCEDURE TO PRINT RPTG, RPTT, AND MESSAGES\nRPTDB    DSECT\n*/////////////////////////////////////////////////////////////////////*\nRPTDCBA  DS    A                  DCB ADDRESS\nRPTLPL   DS    A(65)              RPTG LINES PER PAGE LIMIT\nRPTLCNT  DS    A(65)              RPTG LINE COUNT (FORCE FIRST HEADER)\nRPTPGN   DS    A(1)               RPTG PAGE NUMBER\nRPTHTA   DS    A                  PAGE HEADER LINE TEXT ADDRESS\nRPTHTA1  DS    A                  SECOND HEADER LINE ADDRESS\n*/////////////////////////////////////////////////////////////////////*\n         SPACE\n* This is table for IXRPT proc (print # of Index records per IX level)\nIXLVLT   DSECT\nIXLVLR#  DS    H                  # of IX records per level (as many\n*                                 entries as index levels)\n         SPACE\n         PRINT NOGEN\n         IFGRPL DSECT=YES,AM=VSAM       RPL LAYOUT\n         SPACE\n         DCBD  DSORG=PS\n         SPACE\n         CVT   DSECT=YES                CVT MAPPING MACRO\n         SPACE\n         IHADFA DSECT=YES               DFP/DFSMS LEVEL DETERMINATION\n* FIELD FOR DFSMS LEVEL DETERMINATION. THE REASON FOR this is that DFP\n* VERSIONS OF THE IHADFA MACRO DO NOT DEFINE \"DFARELS\" SYMBOL\n* (ON DFP VERSIONS OF IHADFA THIS IS A PART OF A RESERVED FIELD)\nDFARELSO EQU DFA+16,4\n         SPACE\n         END   KSDSPACE\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF,AC=1'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.LOADLIB....\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME KSDSPACO(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LDAPROBE": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x03\\x01_\\x01\\x03\\x01_\\tU\\x00Z\\x00Z\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-01-15T00:00:00", "modifydate": "2003-01-15T09:55:44", "lines": 90, "newlines": 90, "modlines": 0, "user": "SYMP118"}, "text": "/*.REXX EXEC */\n/*.*******************************************************************/\n/*.LDAPROBE : Issue ldapsearch command every  5  minute/s            */\n/*            Issue a highlighted message if command fails           */\n/*                                                                   */\n/* Can be stopped/ terminated via \"STOP jobname\" MVS command.        */\n/*                                                                   */\n/* Needs a userid with OMVS segment to run.                          */\n/* Needs to be customized to querry LDAP servers in your environment.*/\n/*                                                                   */\n/* External subroutines used:                                        */\n/* DELAY from L.Woren                                                */\n/* WTOH - my own (Janek's)                                           */\n/*                                                                   */\n/* Written by: Janek Jakubek, CGI                                    */\n/*             January  2003                                         */\n/*                                                                   */\n/* Acknowledgement:                                                  */\n/* Some of the code is borrowed from LDAPMAIL written by             */\n/* Lionel B. Dyck.                                                   */\n/*.*******************************************************************/\n/*.FORMAT: LDAPROBE                                                  */\n/*.*******************************************************************/\nTRACE OFF\nARG PARMS\nstdout  = \"LDAPMSGS\"\nstderr  = \"LDAPERRS\"\njobname = MVSVAR('SYMDEF',JOBNAME)\nmsgid   = SYSVAR('SYSICMD')\nEXITRC  = 0\nSECONDS = 300\n/* Issue LDAP search command  every 5 minutes (300 secs) */\nDO FOREVER\n  /* ----------------------------------------------------- *\n   * Now invoke the ldap search command.                   *\n   * ----------------------------------------------------- */\n   /* ----------------------------------------------------- *\n    * Set defaults                  *custom*                *\n    *                                                       *\n    *  ldap_s is the host name of the ldap server           *\n    *  ldap_o are data to be returned by ldapsearch         *\n    * ----------------------------------------------------- *\n    * Examples:                                             *\n    * ldap_s     = \"mailhub.kp.org\"                         *\n    * ldap_o     = \"o=Kaiser Permanente,c=US\"               *\n    * ----------------------------------------------------- */\n   ldap_o     = \"dc=xxxxxxxxxxx,dc=ca\"\n   /* *custom*: the 3 lines below are specific to every LDAP   */\n   /*           sever being monitored                          */\n   /* */\n   ldapsrvn   = \"LDAPstc1\"         /* prod LDAP server STC name*/\n   /* Below, specify LDAP server IP addr or host name          */\n   ldap_s     = \"xxx.xx.xx.xxx -p 389\"\n   CALL LDAPsrch\n   /* */\n   ldapsrvn   = \"LDAPstc2\"         /* test LDAP server STC name*/\n   /* Below, specify LDAP server IP addr or host name          */\n   ldap_s     = \"xxx.xx.xx.xxx -p 389\"\n   CALL LDAPsrch\n  /* CALL L.Woren DELAY subroutine               */\n  /* SAY 'READY TO SLEEP FOR ' SECONDS 'SECONDS' */\n   \"DELAY \"SECONDS\n   If Rc = 8 Then      /* Operator STOP has been issued */\n     do\n     say msgid 'Operator STOP has been issued, terminating ...'\n     exit   0;\n     end\n\nEND\n/* */\nEXIT:\nEXIT EXITRC\n/* */\nLDAPsrch:\ncmd = 'GLDSRCH ENVAR(\"LIBPATH=/\")' ,\n      '/ -h' ldap_s '-b \"'ldap_o'\"' ,\n      '\"dc=ca\"' ,\n      \">DD:\"stdout \"2>DD:\"stderr\ncmd\nIf Rc \u00ac= 0 Then\n  do\n  say msgid  ldapsrvn 'stc: Ldapsearch return code:' rc\n  errmsg = \"LDAP server \"||ldapsrvn||\" not responding, \"\n  errmsg = errmsg||\"review \"||stderr\" /investigate\"\n  say errmsg\n  /* Call JanekJ's WTOH subroutine               */\n  /* Issue a highlighted message to console      */\n  \"WTOH \"errmsg\n  end\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LDAPROBJ": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00X\\x01\\x03\\x01O\\x01\\x03\\x01_\\x10\\x16\\x00\\x1e\\x00\\x18\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2003-01-14T00:00:00", "modifydate": "2003-01-15T10:16:58", "lines": 30, "newlines": 24, "modlines": 0, "user": "SYMP118"}, "text": "//* Run LDAP probe EXEC (needs a USERID with OMVS segment).\n//*\n//* External subroutines used/required:\n//* DELAY from L.Woren\n//* WTOH - my own (Janek's)\n//*\n//* Issues LDAPSEARCH commands to monitored LDAP servers in your\n//* organization (the LDAPROBE REXX exec needs to be customized\n//* for your organization) every 5 minutes.\n//*\n//* In case an LDAP server is not responding - issues a highlighted\n//* message via \"WTOH\" subroutine.\n//*\n//* Can be stopped at any time via \"STOP LDAPROBE\" MVS command.\n//*\n//LDAPROBE EXEC PGM=IKJEFT01,PARM='%LDAPROBE'\n//STEPLIB  DD DISP=SHR,DSN=SYS1.GLD.SGLDLNK\n//         DD DISP=SHR,DSN=your.loadlib with DELAY and WTOH subroutines\n//SYSPROC  DD DISP=SHR,DSN=your.clist.library with LDAPROBE exec\n//SYSTSPRT DD SYSOUT=X\n//SYSTSIN  DD DUMMY\n//LDAPMSGS DD DUMMY,RECFM=VB,LRECL=6144,BLKSIZE=27998\n//LDAPERRS DD SYSOUT=X,RECFM=VB,LRECL=6144,BLKSIZE=27998\n//*\n//*LDAPMSGS DD UNIT=WORK,SPACE=(TRK,(200,200)),DISP=(MOD,CATLG),\n//*           DSN=hlq&SYSCLONE..LDAPROBE.MSGS,\n//*           RECFM=VB,LRECL=6144,BLKSIZE=27998\n//*LDAPERRS DD UNIT=WORK,SPACE=(TRK,(200,200)),DISP=(MOD,CATLG),\n//*           DSN=hlq&SYSCLONE..LDAPROBE.ERRS,\n//*           RECFM=VB,LRECL=6144,BLKSIZE=27998\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLAUPDTS": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x12\\x00\\x96\\t/\\x01\\x01\\x15\\x1f\\x10\\x03\\x01c\\x00\\xb0\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1996-04-01T00:00:00", "modifydate": "2001-05-31T10:03:12", "lines": 355, "newlines": 176, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....YOUR JOBCARD......\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=VIO,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=VIO,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'SYNCHROUNOUS LLA UPDATE ROUTINE'\n* SYNCHROUNOUS LLA UPDATE ROUTINE (USING \"LLACOPY\" MACRO)\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: LLAUPDTS\n*\n* ATTRIBUTES : AC=1\n*              RMODE 24\n*              AMODE 24\n*\n* FUNCTION = SEE BELOW\n*\n*     THIS ROUTINE INVOKES THE \"LLACOPY\" MACRO TO SYNCHRONOUSLY\n*  REFRESH AN INDIVIDUAL (MEMBER) LLA ENTRY.\n*  \"LLACOPY\" HAS TO BE INVOKED IN SUPERVISOR STATE, KEY 0.\n*  A LIST OF MEMBERS TO BE REFRESHED IS SPECIFIED IN THE \"SYSIN\" CARD\n*  IMAGE FILE.\n*\n*\n*  INPUT TO THE ROUTINE:\n*\n*    . \"LLAPDS\" DD SPECIFYING LLA MANAGED PDS WHICH ENTRIES\n*      (MEMBERS) ARE TO BE REFRESHED.\n*      IF JCL \"PARM=LL\" IS SPECIFIED - IT INDICATES TO THE PROGRAM\n*      THAT THE LINKLIST MEMBER(S) ARE TO BE REFRESHED. IN SUCH A\n*      CASE NO \"LLAPDS\" DD IS REQUIRED.\n*\n*    . SYSIN FILE (FB,80) WITH CARDS IN THE FOLLOWING FORMAT:\n*      YYYYYYYY   (STARTING IN COLUMN 1)\n*      \"YYYYYYYY\" IS THE MEMBER NAME WHICH LLA DIRECTORY ENTRY\n*      NEEDS TO BE UPDATED. MEMBER NAME IS REQUIRED. ONLY ONE MEMBER\n*      NAME PER \"SYSIN\" CARD IMAGE CAN BE SPECIFIED (THE REMAINING\n*      PART OF THE CARD IMAGE IS IGNORED).\n*      USE \"LLAUPDTE\" PROGRAM TO REFRESH THE WHOLE DIRECORY OF\n*      A PDS.\n*\n*\n*  OUTPUT:\n*     FOR EACH SYSIN MEMBER NAME - A SYSPRINT LINE IS PRINTED WITH\n*     A RETRUN CODE FROM THE \"LLACOPY\" MACRO:\n*       0 - NORMAL, SUCCESSFUL COMPLETION.\n*       4 - LLACOPY DID NOT FIND THE SPECIFED MEMBER IN THE \"LLAPDS\".\n*           ENTRY FOR THAT MEMBER WAS REMOVED FROM LLA (IF PRESENT).\n*       8 - I/O ERROR ACCESSING \"LLAPDS\", OR INSUFFICIENT VIRTUAL\n*           STORAGE\n*      16 - NO CONTROL CARDS/MEMBER NAMES IN SYSIN, OR, ANY DATASET\n*           OPEN ERROR\n*   NOTE: - IF A NON-LLA MANAGED PDS IS SPECIFIED ON LLAPDS DD, FOR\n*           FOUND MEMBERS LLACOPY RETURNS RC=0. PROGRAM REPORTS A\n*           RC=0 BUT, IN FACT, NO LLA DIRECTORY ENTRIES HAS BEEN\n*           UPDATED.\n*\n*\n*  SAMPLE JCL TO RUN THIS PROGRAM:\n*\n*         //LLAUPDTS PROC\n*         //LLAUPDTS EXEC PGM=LLAUPDTS{,PARM=LL}\n*         //STEPLIB    DD DISP=SHR,DSN=APF.PROG.LIB\n*        {//LLAPDS     DD DISP=SHR,DSN=&LLAPDS}\n*         //SYSPRINT   DD SYSOUT=*\n*         //         PEND\n*         //  EXEC LLAUPDTS,LLAPDS='DSNAME'\n*         //SYSIN      DD *\n*         MEMNAME\n*         .\n*         .\n*         /*\n*\n*\n* WRITTEN BY: JANEK JAKUBEK, OFD\n*             APRIL     1996\n*\n* CHANGE ACTIVITY:\n* APRIL 1/1996 JJ: THIS IS A VERSION OF THE \"LLAUPDTX\" PROGRAM IN WHICH\n*    MEMBER NAMES ARE SPECIFIED IN (FB,80) A SEQUENTIAL SYSIN FILE.\n*    80 BYTES CARD IMAGES SPECIFY THE MEMBER NAMES (MULTIPLE MEMBER\n*    NAMES/SYSIN CARDS CAN BE SPECIFIED) TO BE RE-FRESHED IN A LLA\n*    MANAGED DATA SET SPECIFIED IN \"LLAPDS\" DD.\n*    A SINGLE MEMBER NAME PER SYSIN CARD IMAGE SHOULD BE SPECIFIED\n*    STARTING IN COLUMN 1.\n*\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRDCB     EQU   R9                 DCB ADDRESS REGISTER\nRCVT     EQU   R8                 CVT ADDRESS REGISTER\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\n         PRINT NOGEN\nLLAUPDTS CSECT                    CSECT NAME\nLLAUPDTS AMODE 24\nLLAUPDTS RMODE 24\n         USING LLAUPDTS,R15\n         SAVE  (14,12)            SAVE REGISTERS\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   R2,SAE             SAVE AREA ADDRESS\nSA       DS    18F                SAVE AREA\n         USING SA,R2\nSAE      ST    R13,SA+4           CHAIN\n         ST    R2,8(R13)          SAVE AREAS\n         LR    R13,R2             CURRENT SAVE AREA\n         DROP  R2\n         USING SA,R13             PROGRAM BASE REGISTER\n         SPACE\n         L     R1,0(,R1)          LOAD ADDRESS OF THE PARM FIELD\n         CLC   0(2,R1),=H'0'      IS LL PARM SPECIFIED................?\n         BE    NOPARM             NO\n         CLC   0(2,R1),=H'2'      IS LL PARM SPECIFIED................?\n         BNE   PARMINV            NO, PARM EITHER TOO SHORT OR TOO LONG\n         MVC   LL,2(R1)           SAVE THE LINKLIST INDICATOR\n         CLC   LL,=C'LL'          IS THE LINKLIST INDICATOR VALID.....?\n         BE    NOPARM             YES, CONTINUE----------------------->\nPARMINV  WTO   'LLAUPDTS - INVALID JCL PARM, IGNORED'\n         SPACE\nNOPARM   DS    0H\n         MVC   MNAME,=CL8'LLAUPDTS' PROGRAM NAME FOR ANY OPEN ERR MSGS\n         OPEN  (MSGFILE,(OUTPUT)) OPEN DIAGNOSTIC MESSAGE FILE\n         TM    MSGFILE+48,DCBOFOPN    OPEN SUCCESSFUL    .............?\n         BNO   MSGOPNER           NO, OPEN ERROR         ------------->\n         OPEN  (SYSIN,(INPUT))    OPEN CONTROL INPUT FILE\n         TM    SYSIN+48,DCBOFOPN      OPEN SUCCESSFUL    .............?\n         BNO   SINOPNER           NO, OPEN ERROR         ------------->\n* CHECK IF LINKLIST MEMBER(S) UPDATE\n         CLC LL,=C'LL'            LINKLST UPDATE .....................?\n         BNE   NOTLNKL            NO, LOAD OUR DCB ADDRESS------------>\n* A LNKLST MEMBER UPDATE, USE LINK LIST DCB ADDRESS\n         L     RCVT,16            LOAD CVT ADDRESS\n         USING CVT,RCVT           SET CVT ADDRESSABILITY\n         L     RDCB,CVTLINK       LOAD LNKLST DCB ADDRESS\n         B     LLACOPY            ISSUE LLACOPY MACRO\nNOTLNKL  LA    RDCB,LLAPDS        LOAD OUR DCB ADDRESS\n         OPEN  (LLAPDS,(INPUT))   DCB FOR LLACOPY HAS TO BE OPENED\n         TM    LLAPDS+48,DCBOFOPN     OPEN SUCCESSFUL    .............?\n         BNO   PDSOPNER           NO, OPEN ERROR         ------------->\n         SPACE\n*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\////////////////////////////////////*\n* THE MAIN SYSIN READ/PROCESS PART\nLLACOPY  GET   SYSIN,INREC        GET INPUT MEMBER NAME\n         MVI   ANYINREC,C'Y'      SET FLAG INDICATING INPUT WAS PRESENT\n         MVC   MEMNAME,MNAME      MOVE MEMBER NAME INTO BLDL LIST\n* PREPARE THE DIAGNOSTIC MSG TEXT AREA\n         MVC   MSGSEP,=C' - '     A SEPARATOR\n         MVI   MSGTXT,C' '        CLEAR THE MSGTXT AREA\n         MVC   MSGTXT+1(L'MSGTXT-1),MSGTXT\n* ENTER SUPERVISOR STATE, KEY 0 FIRST\n*\n         MODESET MODE=SUP,KEY=ZERO\n         LLACOPY BLDLLIST=BLDL,DCB=(RDCB),                             +\n               RETCODE=RETNCODE,RSNCODE=RSONCODE\n         MODESET MODE=PROB,KEY=NZERO   RESTORE THE PROBLEM STATE\n* CHECK RETURN CODES FROM THE LLACOPY\n         L     R15,RETNCODE       LOAD RETURN CODE FROM LLACOPY\n         C     R15,RETCODE        HANDLE PROGRAM RETURN CODE\n         BNH   RCHECK0            NEED NOT BE UPDATED----------------->\n         ST    R15,RETCODE        UPDATE WITH A HIGHER RETURN CODE\nRCHECK0  C     R15,=F'8'          CHECK IF A KNOWN CODE...............?\n         BNH   RCHECK(R15)        DISCRIMINATE RC 0,4,8---------------\n         B     RCUNKNWN           UNKNOWN RETURN CODE----------------->\nRCHECK   B     LLARC0             SUCCESSFUL LLA UPDATE--------------->\n         B     LLARC4             MEMBER NOT FOUND OR DELETED--------->\n         B     LLARC8             I/O ERROR OR INSUFFICIENT STORAGE--->\n         SPACE\nLLARC0   MVC   MSGTXT(L'MSGRC0),MSGRC0\n         B     PUTDIAGM           PRINT A COMFORTING MESSAGE\n         SPACE\nLLARC4   MVC   MSGTXT(L'MSGRC4),MSGRC4\n         B     PUTDIAGM           PRINT A COMFORTING MESSAGE (NOT SO)\n         SPACE\nLLARC8   L     R15,RSONCODE       LOAD LLACOPY REASON CODE\n         C     R15,=F'4'          CHECK IF A KNOWN CODE...............?\n         BNH   RC8RCK(R15)        DISCRIMINATE RSC 0,4 --------------->\n         B     RC8NKNR            UNKNOWN REASON CODE----------------->\nRC8RCK   B     RC8RS0             I/O ERROR DOING DIRECTORY SEARCH---->\n         B     RC8RS4             INSUFFICIENT STORAGE IN PRIMARY AS-->\nRC8RS0   MVC   MSGTXT(L'MSGRC80),MSGRC80\n         B     PUTDIAGM           PRINT A COMFORTING MESSAGE (NOT SO)\nRC8RS4   MVC   MSGTXT(L'MSGRC84),MSGRC84\n         B     PUTDIAGM           PRINT A COMFORTING MESSAGE (NOT SO)\n* FOR RC=8, UNKNOWN REASON CODE IS IN R15\nRC8NKNR  BAL   R14,CONVHEX        CONVERT R15 TO HEXA\n         MVC   MSGRC8XR,HX8BYTE+4 REASON CODE INTO ERRO MSG TXT\n         MVC   MSGTXT(L'MSGRC8X+L'MSGRC8XR),MSGRC8X MOVE MSG TEXT\n         B     PUTDIAGM           PRINT A COMFORTING MESSAGE (NOT SO)\n         SPACE\n* UNKNOWN RETURN CODE FROM LLACOPY\n* RETURN CODE IS IN R15 ON ENTRY\nRCUNKNWN BAL   R14,CONVHEX        CONVERT R15 TO HEXA\n         MVC   MSGUKNRC,HX8BYTE+4 RETURN CODE INTO ERRO MSG TXT\n         L     R15,RSONCODE       LOAD REASON CODE INTO R15\n         BAL   R14,CONVHEX        CONVERT R15 TO HEXA\n         MVC   MSGUKNRS,HX8BYTE+4 REASON CODE INTO ERRO MSG TXT\n         MVC   MSGTXT(L'MSGUKNC),MSGUKNC MOVE MSG TEXT\n         B     PUTDIAGM           PRINT A COMFORTING MESSAGE (NOT SO)\n         SPACE\n* DIAGNOSTIC MESSAGE PRINT\nPUTDIAGM DS    0H                 PUT OUT A DIAGNOSTIC MESSAGE\n         PUT   MSGFILE,MSGREC     WRITE OUT A DIAGNOSTIC MESSAGE\n         B     LLACOPY            PROCESS NEXT SYSIN RECORD\n*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\////////////////////////////////////*\n         SPACE\n* WE HAVE EOD ON SYSIN\nEOF      CLI   ANYINREC,C'Y'      SYSIN INPUT WAS PRESENT\n         BE    EOFN               YES, NORMAL END\n         MVC   RETCODE,=F'16'     NO, SET RET.CODE=16\n         MVC   MSGTXT(L'MSGNSIN),MSGNSIN NO SYSIN INPUT ERROR MSG\n         PUT   MSGFILE,MSGREC     WRITE OUT A DIAGNOSTIC MESSAGE\nEOFN     CLC   LL,=C'LL'          LINKLST UPDATED.....................?\n         BE    LLACPYX            YES, NO CLOSE REQUIRED-------------->\n         CLOSE (LLAPDS)           NO, CLOSE THE DCB\nLLACPYX  CLOSE (SYSIN,,MSGFILE)   CLOSE SYSIN AND DIAGNOSTIC MSG FILE\n         L     R15,RETCODE        LOAD END OF RUN RETURN CODE\nRET      L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)\n         SPACE\nRC16P    PUT   MSGFILE,MSGREC     WRITE OUT A DIAGNOSTIC MESSAGE\nRC16     LA    R15,16             UNSUCCESSFUL COMPLETION\n         B     RET\n         SPACE\nMSGOPNER DS    0H                 DIAGNOSTIC ERROR MSG FILE COULD\n*                                 NOT BE OPENED\n         WTO   'LLAUPDTS - SYSPRINT OPEN ERROR, RC=16'\n         B     RC16\n         SPACE\nSINOPNER DS    0H                 SYSIN OPEN ERROR\n         MVC   MSGTXT(L'MSGSINOE),MSGSINOE SYSIN OPEN ERROR MSG\n         B     RC16P              PRINT ERR MSG AN EXIT WITH RC=16\n         SPACE\nPDSOPNER DS    0H                 LLAPDS OPEN ERROR\n         MVC   MSGTXT(L'MSGPDSOE),MSGPDSOE LLAPDS OPEN ERROR MSG\n         B     RC16P              PRINT ERR MSG AN EXIT WITH RC=16\n*---------------------------------------------------------------------*\n*  THIS ROUTINE CONVERTS R15 TO CHARACTER HEXA DIGITS\n*  RETURN THROUGH R14\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nCONVHEX  ST    R15,HX4BYTE           STORE ERROR CODE IN A WORK FIELD\n         UNPK  HX9BYTE,HX5BYTE\n         NC    HX8BYTE,=8X'0F'       CLEAR 4 BITS OF EACH BYTE\n         TR    HX8BYTE,=C'0123456789ABCDEF'\n         BR    R14                   RETURN TO THE CALLER\n*\nHX5BYTE  DS    0CL5                  'PACKED' DATA\nHX4BYTE  DS    CL4                   BINARY ERROR CODE\n         DS    C                     LAST BYTE TO UNPACK\nHX9BYTE  DS    0CL9                  'UNPACKED' DATA\nHX8BYTE  DS    CL8                   CHARACTER ERROR CODE\n         DS    C                     EXTRANOUS DATA\n*---------------------------------------------------------------------*\n         SPACE\n*  LLAPDS DATA SET\nLLAPDS   DCB   DSORG=PO,MACRF=R,DDNAME=LLAPDS\n*  DIAGNOSTIC MESSAGE MESSAGE FILE\nMSGFILE  DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,            +\n               LRECL=(L'MSGREC),BLKSIZE=(L'MSGREC*33)\n*  CONTROL (MEMBER NAMES TO BE REFRESHED) FILE\nSYSIN    DCB   DSORG=PS,MACRF=GM,DDNAME=SYSIN,RECFM=FB,LRECL=(L'INREC),+\n               EODAD=EOF\n         SPACE\nLL       DC    CL2'XX'            LL FROM JCL PARM\nRETNCODE DS    F                  RETURN CODE FROM LLACOPY MACRO\nRSONCODE DS    F                  REASON CODE FROM LLACOPY MACRO\nRETCODE  DC    F'0'               RETURN CODE FROM THE PROGRAM\n*                                 (HIGHEST RETURNED FROM LLACOPY MACRO)\n*//////////////////////////////////////////////////////////////////////\nBLDL     DS    0F                 BLDL LIST TO FOR LLACOPY\n         DC    AL2(1)             NUMBER OF ENTRIES\n         DC    AL2(12)            ENTRY LENGTH (MINIMUM IS 12 BYTES)\nMEMNAME  DS    CL8                MEMBER NAME TO BE REFRESHED IN LLA\n         DS    CL4                TTR,K FIELDS TO BE RETURNED\n*//////////////////////////////////////////////////////////////////////\n*\n*  DIAGNOSTIC MESSAGES\n*\n*//////////////////////////////////////////////////////////////////////\nMSGREC   DS    0CL121             121 BYTES LONG\nMSGASA   DC    C'0'               PRINT LINES SEPARATED BY 1 BLANK LINE\nINREC    DS    0CL80\nMNAME    DC    CL8' '             INPUT MEMBER NAME\nMSGSEP   DC    C' - '             A SEPARATOR\nMSGTXT   DC    CL(121-12)' '      DIAG MSG TEXT\n*//////////////////////////////////////////////////////////////////////\nANYINREC DC    X'00'              A FLAG INDICATING SYSIN INPUT PRESENT\nMSGRC0   DC    C'LLACOPY RC=0, SUCCESSFUL REFRESH'\nMSGRC4   DC    C'LLACOPY RC=4, MEMBER NOT FOUND IN LLAPDS/LINKLST'\nMSGRC80  DC    C'LLACOPY RC=8, LLAPDS DIR SEARCH I/O ERROR'\nMSGRC84  DC    C'LLACOPY RC=8, INSUFFICIENT VIRTUAL STORAGE'\n*//////////////////////////////////////////////////////////////////////\nMSGRC8X  DC    C'LLACOPY RC=8, UNKNOWN REASON CODE='\nMSGRC8XR DC    C'XXXX'              REASON CODE FROM LLACOPY\n*//////////////////////////////////////////////////////////////////////\n*//////////////////////////////////////////////////////////////////////\nMSGUKNC  DS    0CL(MSGUKNE-MSGUKNC1) UNKONWN RETURN CODE FROM LLACOPY\nMSGUKNC1 DC    C'LLACOPY RET.CODE='\nMSGUKNRC DC    C'XXXX'           RETURN CODE FROM LLACOPY\n         DC    C', RSN.CODE='\nMSGUKNRS DC    C'XXXX'           REASON CODE FROM LLACOPY\nMSGUKNE  EQU   *\n*//////////////////////////////////////////////////////////////////////\nMSGNSIN  DC    C'NO INPUT ON SYSIN, RC=16'\nMSGSINOE DC    C'SYSIN OPEN ERROR, RC=16'\nMSGPDSOE DC    C'LLAPDS OPEN ERROR, RC=16'\n         LTORG\n         SPACE\n         PRINT NOGEN\n         CVT   DSECT=YES          CVT MAPPING MACRO\n         SPACE\n         DCBD  DSORG=PS\n         END   LLAUPDTS\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF,AC=1'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.APF.LOADLIB....\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME LLAUPDTS(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLAUPDTX": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x12\\x00\\x91\\x16/\\x01\\x01\\x15\\x1f\\x10Y\\x00\\xbf\\x00\\x9f\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1991-06-11T00:00:00", "modifydate": "2001-05-31T10:59:12", "lines": 191, "newlines": 159, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....YOUR JOBCARD......\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=VIO,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=VIO,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'SYNCHROUNOUS LLA UPDATE ROUTINE'\n* SYNCHROUNOUS LLA UPDATE ROUTINE (USING \"LLACOPY\" MACRO)\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: LLAUPDTX\n*\n* ATTRIBUTES : AC=1\n*\n* FUNCTION = SEE BELOW\n*\n*     THIS ROUTINE INVOKES THE \"LLACOPY\" MACRO TO SYNCHRONOUSLY\n*  REFRESH AN INDIVIDUAL (MEMBER) LLA ENTRY.\n*  \"LLACOPY\" HAS TO BE INVOKED IN SUPERVISOR STATE, KEY 0.\n*\n*\n*  INPUT TO THE ROUTINE:\n*\n*       . \"LLAPDS\" DD SPECIFYING LLA MANAGED PDS IN WHICH THERE IS\n*         AN UPDATED MEMBER.\n*\n*       . JCL PARM FIELD IN THE FOLLOWING FORMAT: XXYYYYYYYY\n*         IF \"XX\" SPECIFIES \"LL\" IT MEANS THAT AN LINKLIST MEMBER IS\n*         TO BE REFRESHED. \"LLAPDS\" DD IS NOT REQUIRED IN SUCH A CASE.\n*         ANY OTHER VALUE OF \"XX\" IS IGNORED AND \"LLAPDS\" DD IS\n*         REQUIRED THEN.\n*         \"YYYYYYYY\" IS THE MEMBER NAME WHICH LLA DIRECTORY ENTRY\n*         NEEDS TO BE UPDATED. MEMBER NAME IS REQUIRED.\n*         USE \"LLAUPDTE\" PROGRAM TO REFRESH THE WHOLE DIRECORY OF\n*         A PDS.\n*\n*\n*  OUTPUT:\n*\n*       . A RETRUN CODE FROM THE \"LLACOPY\" MACRO.\n*         0 - NORMAL, SUCCESSFUL COMPLETION.\n*         4 - LLACOPY DID NOT FIND THE SPECIFED MEMBER IN THE \"LLAPDS\".\n*             ENTRY FOR THAT MEMBER WAS REMOVED FROM LLA (IF PRESENT).\n*         8 - I/O ERROR ACCESSING \"LLAPDS\"\n*        16 - PARM FIELD IS INVALID\n*\n*\n*  SAMPLE JCL TO RUN THIS PROGRAM:\n*\n*         //LLAUPDTX PROC LL=XX\n*         //LLAUPDTX EXEC PGM=LLAUPDTX,PARM='&LL.&MEMBER.'\n*         //STEPLIB    DD DISP=SHR,DSN=APF.PROG.LIB\n*         //LLAPDS     DD DISP=SHR,DSN=&LLAPDS\n*         //         PEND\n*         //  EXEC LLAUPDTX,LL=LL,MEMBER=PROGRAMX, LINKLST UPDTE\n*         //                LLAPDS='SYS1.LINKLIB'\n*         //  EXEC LLAUPDTX,MEMBER=PROGRAMY, A USER LIBRARY UPDTE\n*         //                LLAPDS='SYS2.LINKLIB'\n*\n*\n* WRITTEN BY: JANEK JAKUBEK, OGL\n*             JUNE      1991\n*\n* CHANGE ACTIVITY:\n*                 NONE\n*\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRDCB     EQU   R9                 DCB ADDRESS REGISTER\nRCVT     EQU   R8                 CVT ADDRESS REGISTER\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\n         PRINT NOGEN\nLLAUPDTX CSECT                    CSECT NAME\n         USING LLAUPDTX,R15\n         SAVE  (14,12)            SAVE REGISTERS\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   R2,SAE             SAVE AREA ADDRESS\nSA       DS    18F                SAVE AREA\n         USING SA,R2\nSAE      ST    R13,SA+4           CHAIN\n         ST    R2,8(R13)          SAVE AREAS\n         LR    R13,R2             CURRENT SAVE AREA\n         DROP  R2\n         USING SA,R13             PROGRAM BASE REGISTER\n         SPACE\n         L     R1,0(,R1)          LOAD ADDRESS OF THE PARM FIELD\n         CLC   0(2,R1),=H'3'      IS LL AND MEMBER NAME SPECIFIED.?\n         BL    PARMERR1           NO, PARM TOO SHORT\n         MVC   LL,2(R1)           SAVE THE LINKLIST INDICATOR\n         LH    R2,0(,R1)          LENGTH OF THE PARM FIELD INTO R2\n         SH    R2,=H'2'           - 2 (LL) = MEMBER NAME LENGTH\n         CH    R2,=H'8'           IS MEMBER NAME LENGTH > 8...........?\n         BNH   PARMP1             NO, SAVE MEMBER NAME --------------->\n         LH    R2,=H'8'           YES, USE ONLY FIRST 8 BYTES\nPARMP1   BCTR  R2,0               MEMBER NAME LENGTH - 1\n         MVC   MEMNAME,=CL9' '    CLEAR THE MEMBER NAME FIELD\n         EX    R2,MVCMEMN         MOVE MEMBER NAME INTO MEMNAME FIELD\n         SPACE\n* CHECK IF LINKLIST MEMBER UODATE\n         CLC LL,=C'LL'            LINKLST UPDATE .....................?\n         BNE   NOTLNKL            NO, LOAD OUR DCB ADDRESS------------>\n* A LNKLST MEMBER UPDATE, USE LINK LIST DCB ADDRESS\n         L     RCVT,16            LOAD CVT ADDRESS\n         USING CVT,RCVT           SET CVT ADDRESSABILITY\n         L     RDCB,CVTLINK       LOAD LNKLST DCB ADDRESS\n         B     LLACOPY            ISSUE LLACOPY MACRO\nNOTLNKL  LA    RDCB,LLAPDS        LOAD OUR DCB ADDRESS\n         OPEN  (LLAPDS,(INPUT))   DCB FOR LLACOPY HAS TO BE OPENED\n         SPACE\n* ENTER SUPERVISOR STATE, KEY 0 FIRST\n*\nLLACOPY  MODESET MODE=SUP,KEY=ZERO\n         LLACOPY BLDLLIST=BLDL,DCB=(RDCB),                             +\n               RETCODE=RETNCODE,RSNCODE=RSONCODE\n         MODESET MODE=PROB,KEY=NZERO   RESTORE THE PROBLEM STATE\n         CLC   LL,=C'LL'          LINKLST UPDATED.....................?\n         BE    LLACPYX            YES, NO CLOSE REQUIRED-------------->\n         CLOSE (LLAPDS)           NO, CLOSE THE DCB FIRST\nLLACPYX  L     R15,RETNCODE       LOAD RETURN CODE FROM LLACOPY\nRET      L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)\n         SPACE\nRC16     LA    R15,16             UNSUCCESSFUL COMPLETION\n         B     RET\n         SPACE\nMVCMEMN  MVC   MEMNAME(1),4(R1)   MOVE MEMBER NAME FROM THE PARM FIELD\n         SPACE\nPARMERR1 DS    0H                 INVALID PARM FIELD\n         WTO   'LLAUPDTX - INVALID PARM FIELD'\n         B     RC16\n*  LLAPDS DATA SET\nLLAPDS   DCB   DSORG=PO,MACRF=R,DDNAME=LLAPDS\n         SPACE\nLL       DS    CL2                LL FROM JCL PARM\nRETNCODE DS    F                  RETURN CODE FROM LLACOPY MACRO\nRSONCODE DS    F                  REASON CODE FROM LLACOPY MACRO\n*//////////////////////////////////////////////////////////////////////\nBLDL     DS    0F                 BLDL LIST TO FOR LLACOPY\n         DC    AL2(1)             NUMBER OF ENTRIES\n         DC    AL2(12)            ENTRY LENGTH (MINIMUM IS 12 BYTES)\nMEMNAME  DS    CL8                MEMBER NAME TO BE REFRESHED IN LLA\n         DS    CL4                TTR,K FIELDS TO BE RETURNED\n*//////////////////////////////////////////////////////////////////////\n         LTORG\n         SPACE\n         CVT   DSECT=YES          CVT MAPPING MACRO\n         END   LLAUPDTX\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF,AC=1'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.APF.LOADLIB....\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME LLAUPDTX(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKENSWP": {"ttr": 5642, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00D\\x01\\x025\\x0f\\x01\\x03\\x01o\\x08Q\\x00K\\x00!\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2002-12-16T00:00:00", "modifydate": "2003-01-16T08:51:44", "lines": 75, "newlines": 33, "modlines": 0, "user": "SYMP118"}, "text": "/* REXX    */\n/* Written by: Janek Jakubek, CGI MDC                              */\n/*             December 2002                                       */\n/*                                                                 */\n/* Function:                                                       */\n/* Make all address spaces with same name nonswappable. This can be*/\n/* useful for Unix applications (in our case CTG).                 */\n/* Does this via MXI MAKE command.                                 */\n/*                                                                 */\n/* Has to run in a TSO environment (batch or foreground)           */\n/* because MXI MAKE function is authorized. Will not work          */\n/* if invoked via IRXJCL.                                          */\n/* Also, the user that runs this has to be authorized to the       */\n/* FACILITY class resource MXICMD.MAKE .                           */\n/*                                                                 */\n/* Syntax: %MAKENSWP jobname                                       */\n/*                                                                 */\n/* TRACE A */\nparse upper arg jobname\nmsgid = SYSVAR('SYSICMD')\n/*                                                                 */\n/* JOBNAME has to be specified.                                    */\n/* We do not allow generic jobnames to prevent mistakes            */\n/* (like making all AS on a system non-swappable).                 */\n/*                                                                 */\nsay msgid 'Requested jobname:' jobname\nIf jobname = '' then\n  do\n  say msgid 'JOBNAME has to be specified.'\n  exit   16;\n  end\n/* We do not allow generic jobnames to avoid errors                */\nIf verify(jobname,'*%','Match') > 0 then\n  do\n  say msgid jobname '<--- generic jobname is not allowed'\n  exit   16;\n  end\n/*                                                                 */\ndacmd = 'DA 'jobname\nsay msgid 'Issuing command:' dacmd\nrcode0 = MXIREXX('outline1.','NOTITLES',dacmd)\nIf  (rcode0 = 0  & outline1.0 >= 1) then\n  do\n  If (outline1.0 >= 31 & substr(outline1.1,1,14) = 'Identification')\n  then    /* We seem to have a single address space display */\n    do\n    loopcnt = 1\n    asidxpos = 58    /* ASID (hex) position on the display    */\n    i = 2            /* DA display line # to look at          */\n    end\n  else               /* We seem to have a multi-AS DA display */\n    do               /* (one line for an AS)                  */\n    i = 1\n    asidxpos = 39    /* ASID (hex) position on the display    */\n    loopcnt = outline1.0\n    end\n  do loopcnt\n    say outline1.i\n    asidx = substr(outline1.i,asidxpos,4)\n    makecmd = 'MAKE A='asidx' SWAP(NO)'\n    say msgid 'Issuing command:' makecmd\n    rcode1 = MXIREXX('outline2.',makecmd)\n    if rcode1 \u00ac= 0\n    then say msgid 'MAKE command failed. Return Code:' rcode1\n    i = i + 1\n  end\n  end\nelse\n  do\n  say msgid 'DA 'jobname' command failed. Return Code:' rcode0\n  say msgid 'Number of lines returned by DA:' outline1.0\n  if outline1.0 = 0 then\n    say msgid 'Job' jobname 'is not active/ running.'\n  end\nexit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXIVSTOR": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01)\\x00X\\x01\\x04\\x04O\\x01\\x054\\x0f\\x16\\x19\\x00\\xe0\\x00<\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.41", "flags": 0, "createdate": "2004-02-13T00:00:00", "modifydate": "2005-12-06T16:19:58", "lines": 224, "newlines": 60, "modlines": 0, "user": "SYMP118"}, "text": "/* REXX    */\n/* Function: Displays virtual storage usage of an address space.   */\n/*                                                                 */\n/* Invokes MXI to display address space's LDA. LDA fields are used */\n/* to produce REXXSTOR (by Mark Zelden) like display.              */\n/* This function depends on MXI command MEM @LDA MAP(LDA) JOB(...) */\n/* displaying 64 lines LDA map. If MXI @LDA display/ layout        */\n/* changes - this rexx will need to be updated.                    */\n/* If any unresonable value, or a value with a decimal fraction    */\n/* is displayed - it is a sure sign that either MEM @LDA MAP(LDA)  */\n/* layout has changed or there is a corrupted value in LDA.        */\n/*                                                                 */\n/* Since LDA resides in a foreign address space - an authorized    */\n/* program is needed to retrieve it - MXI in this case.            */\n/*                                                                 */\n/* This exec has to run in a TSO environment (batch or foreground) */\n/* because MXI MEM  function is authorized. Will not work          */\n/* if invoked via IRXJCL.                                          */\n/* Also, a user that runs this has to be authorized to the         */\n/* FACILITY class resource MXICMD.MEM                              */\n/*                                                                 */\n/* Syntax: %MXIVSTOR jobname                                       */\n/* or    : %MXIVSTOR ASID(xxxx)                                    */\n/*             Where  \"xxxx\" is a 4 hex digits ASID id             */\n/*                                                                 */\n/* Prerequisites: MXI needs to be installed authorized and         */\n/*                available via LINKLIST/STEPLIB.                  */\n/*                                                                 */\n/* Written by: Janek Jakubek, CGI MDC                              */\n/*             March    2004                                       */\n/*                                                                 */\n/* Acknowledgements:                                               */\n/* This little rexx has been inspired by Mark Zelden's REXXSTOR.   */\n/* REXXSTOR code has been used here to produce the display.        */\n/*                                                                 */\n/* Change log:                                                     */\n/*                                                                 */\n/* Dec. 06/2005 JJ                                                 */\n/* Added MEMLIMIT display (for z/OS 1.2 and above running in       */\n/* z/Architecture mode). Code from Mark Zelden's REXXSTOR updated  */\n/* on 10/27/2005 has been used.                                    */\n/*                                                                 */\n/* TRACE R */\nparse upper arg jobname\nmsgid = SYSVAR('SYSICMD')\nNumeric digits 14\n/*                                                                 */\n/* If JOBNAME is not specified - current address space name is used*/\n/*                                                                 */\nIf jobname = '' then jobname = MVSVAR('SYMDEF','JOBNAME' )\nASname = '--------' /* Initial/ null value of Address Space name   */\n/*                                                                 */\n/* ASID(xxxx) parm processing                                      */\nIf Substr(jobname,1,5) = 'ASID(' then\n  Do\n  If Length(jobname) <> 10 then\n    Do\n    Say 'ASID must be specified as ASID(xxxx) <---- 4 hex digits'\n    Exit 4\n    End\n/* We are going to find the address space name via MXI DA command  */\n  dacmd = 'DA A='Substr(jobname,6,4)\n  darc = MXIREXX('daline1.','NOTITLES',dacmd)\n  If  (darc = 0   & daline1.0 > 1) then\n    Do\n    /* Extract address space name from MXI DA A=xxxx command output */\n    parse var daline1.2 a s ASname discard\n    End\n  mxicmd = 'MEM @LDA MAP(LDA)' jobname\n  End   /* End of ASID(xxxx) parm processing   */\n/*                                                                 */\nElse    /* Jobname   operand specified/assumed */\n   Do\n   mxicmd = 'MEM @LDA MAP(LDA) JOB('jobname')'\n   End\nmxirc = MXIREXX('outline1.','NOTITLES',mxicmd)\nIf  (mxirc = 0   & outline1.0 = 64) then\n  do\n  /* Extract hexadecimal values from MXI LDA map display output */\n  parse var outline1.21 offsd offsx id len XESIZA discard\n  parse var outline1.51 offsd offsx id len XREGRQ discard\n  parse var outline1.52 offsd offsx id len XLIMIT discard\n  parse var outline1.54 offsd offsx id len XELIM  discard\n  parse var outline1.58 offsd offsx id len XLOAL  discard\n  parse var outline1.60 offsd offsx id len XELOAL discard\n  /* Fix any invalid extended region limit values          */\n  /* ( OPSMVS is known to insert an invalid LDAELIM        */\n  /*  and LDAEVVRG = X'7FFFFFFF' )                         */\n  /*  If  LDAELIM > LDAESIZA then make LDAELIM = LDAESIZA  */\n  If X2d(XELIM)  > X2d(XESIZA) then XELIM  = XESIZA\n  /* Make REXXSTOR like display                            */\n  /* (code from REXXSTOR is used here)                     */\n  LDALIMIT = X2d(XLIMIT)                     /* <16m v=v             */\n  LDALIMIT = Right(LDALIMIT/1024,9)          /* convert to kbytes    */\n  LDALOAL  = X2d(XLOAL)                      /* <16m v=v alloc       */\n  LDALOAL  = Right(LDALOAL/1024,9)           /* convert to kbytes    */\n  LDAELIM  = X2d(XELIM)                      /* >16m v=v             */\n  LDAELIM  = Right(LDAELIM/1024,9)           /* convert to kbytes    */\n  LDAELOAL = X2d(XELOAL)                     /* >16m v=v alloc       */\n  LDAELOAL = Right(LDAELOAL/1024,9)          /* convert to kbytes    */\n  LDAREGRQ = X2d(XREGRQ)                     /* region requested     */\n  LDAREGRQ = LDAREGRQ/1024                   /* convert to kbytes    */\n  AVAIL    = Right(LDALIMIT-LDALOAL,9)       /* available <16M       */\n  EAVAIL   = Right(LDAELIM-LDAELOAL,9)       /* available >16M       */\n  call Memlimit\n/*********************************************************************/\n/* Display results                                                   */\n/*********************************************************************/\n  Say ''\n  title = jobname 'address space virtual storage usage'\n  Say title\n  underl = ASname'-------------------------------------------------'\n  underl = Substr(underl,1,Length(title))\n  Say underl\n  Say ' '\n  Say '        Region requested:' LDAREGRQ'K'\n  Say ' '\n  Say '                Limit     In-Use      Avail'\n  Say 'Below 16M:' LDALIMIT'K' LDALOAL'K' AVAIL'K'\n  Say 'Above 16M:' LDAELIM'K' LDAELOAL'K' EAVAIL'K'\n  If Show_MEMLIMIT_Display = 1 then ,     /* FLAG set to \"true\"?  */\n    Say 'Above 2G :' Right(RAXLVMEMLIM || MUNITS,10) ,\n        '    (64-bit MEMLIMIT)'\n  Exit 0\n  End\nelse\n  do\n  say msgid 'MXI cmd: 'mxicmd' failed or LDA layout is changed'\n  say msgid 'MXI cmd return code:' mxirc\n  if mxirc <> 0 then\n    say msgid 'Most likely address space is not available'\n  end\nexit\n/* MEMLIMIT subroutine                                               */\nMemlimit:\n/*********************************************************************/\n/* MEMLIMIT code (from Mark Zelden's REXXSTOR)                       */\n/*********************************************************************/\nShow_MEMLIMIT_Display = 0    /* Init flag to \"false\" - used later    */\nCVT      = C2d(Storage(10,4))                /* point to CVT         */\nCVTOSLV3 = Storage(D2x(CVT+1267),1)          /* byte 3 of CVTOSLVL   */\nFLCARCH  = Storage(A3,1)                     /* FLCARCH in PSA       */\nIf bitand(CVTOSLV3,'10'x) = '10'x & ,        /* z/OS 1.2 64-bit srvs */\n   C2d(FLCARCH) <> 0 then do                 /* non-zero is z/Arch.  */\n  Show_MEMLIMIT_Display = 1                  /* Set FLAG to \"true\"   */\n  /* We need help of MXI to get a foreign AS RAX pointer and         */\n  /* MEMLIMIT in RAX                                                 */\n  dascb  = 'MEM @ASCB MAP(ASCB) JOB('jobname')'\n  dasrc = MXIREXX('ascbl1.','NOTITLES',dascb)\n  If  (dasrc = 0   & ascbl1.0 >= 119) then\n  do\n    /* Extract RAX hex pointer from MXI ASCB map display */\n    parse var ascbl1.114 offsd offsx id len RAXP   discard\n    /* Retrieve MEMLIMIT from RAX+152 (8 bytes)          */\n    /* XMLIMP is hex MEMLIMIT pointer                    */\n    XMLIMP = Right(D2x(X2d(RAXP)+152),8)\n    dmlim  = 'MEM 'XMLIMP' LEN(8) JOB('jobname')'\n    dmlrc = MXIREXX('dmlml1.','NOTITLES',dmlim)\n    If  (dmlrc = 0   & dmlml1.0 = 1) then\n    do\n      /* Extract MEMLIMIT from MXI RAX+152 display  */\n      parse var dmlml1.1 addrx offsx MLIM1 MLIM2 discard\n      RAXLVMEMLIM = X2d(MLIM1||MLIM2)\n    end\n    /* MEMLIMIT could not be retrieved from RAX */\n    else\n    do\n      Show_MEMLIMIT_Display = 0\n      Return\n    end\n  end\n  /* MEMLIMIT could not be retrieved from RAX */\n  else\n  do\n    Show_MEMLIMIT_Display = 0\n    Return\n  end\n  /* We've got MEMLIMIT from RAX                                     */\n  /***************************************************************/\n  /* The following code is used to display the MEMLIMIT in the   */\n  /* largest possible unit.  For example, 1023G and 1025G are    */\n  /* displayed as 1023G and 1025G, but 1024G is displayed as 1T. */\n  /***************************************************************/\n  Select\n     When RAXLVMEMLIM < 1024 then do\n       MUNITS = 'M'\n     End\n     When RAXLVMEMLIM >= 1024 & RAXLVMEMLIM < 1048576 then do\n       If RAXLVMEMLIM/1024 == TRUNC(RAXLVMEMLIM/1024) then do\n         RAXLVMEMLIM = RAXLVMEMLIM/1024\n         MUNITS = 'G'\n       End\n       Else MUNITS = 'M'\n     End\n     When RAXLVMEMLIM >= 1048576 & RAXLVMEMLIM < 1073741824 then do\n       If RAXLVMEMLIM/1048576 == TRUNC(RAXLVMEMLIM/1048576) then do\n         RAXLVMEMLIM = RAXLVMEMLIM/1048576\n         MUNITS = 'T'\n       End\n       Else do\n         RAXLVMEMLIM = RAXLVMEMLIM/1024\n         MUNITS = 'G'\n       End\n     End\n     When RAXLVMEMLIM >= 1073741824 & ,\n          RAXLVMEMLIM <= 17591112302592 then do\n       If RAXLVMEMLIM/1073741824 == TRUNC(RAXLVMEMLIM/1073741824) ,\n          then do\n         RAXLVMEMLIM = RAXLVMEMLIM/1073741824\n         MUNITS = 'P'\n       End\n       Else do\n         RAXLVMEMLIM = RAXLVMEMLIM/1048576\n         MUNITS = 'T'\n       End\n     End\n     When RAXLVMEMLIM = 17592186040320 then do\n         RAXLVMEMLIM = 'NOLIMIT'   /* 16384P */\n         MUNITS = ''\n     End\n     Otherwise say 'Error in MEMLIMIT code. Contact Mark Zelden.'\n  End /* select */\nEnd /* If bitand(CVTOSLV3,'10'x) */\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OFDASVER": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x00\\x93\\x03?\\x01\\x04)_\\x10\\x17\\x01-\\x01\\x12\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-02-02T00:00:00", "modifydate": "2004-10-21T10:17:23", "lines": 301, "newlines": 274, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....your jobcard......\n//*\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=SYSALLDA,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n         TITLE 'VERIFY IF SPECIFIED ADDRESS SPACE(S) IS/ARE UP'\n* SPECIFICATIONS:\n*\n* MODULE NAME: OFDASVER\n*\n* ATTRIBUTES : NONE\n*\n* FUNCTION = SEE BELOW\n*\n*     THIS ROUTINE CHECKS IF SPECIFIED ADDRESS SPACE(S) IS/ARE UP.\n*  IF ALL SPECIFIED ADDRESS SPACES ARE UP, IT TERMINATES WITH\n*  RETURN CODE OF ZERO, OTHERWISE IT TERMINATES WITH A RETURN CODE\n*  OF 16.\n*  HERE ARE THE POSSIBLE APPLICATIONS FOR THIS PROGRAM:\n*  .VERFIY IF A CICS OR DBCOMM/DB REGION IS UP IN THE FIRST STEP\n*   OF A JOB. IF YES, CONTINUE THE JOB, OTHERWISE TERMINATE IT.\n*  .VERFIY IF ALL REQUIRED STARTED TASKS ARE UP AFTER IPL OR\n*   PERIODICALLY DURING A DAY. IF NOT - ISSUE A WARNING MESSAGE TO\n*   THE OPERATOR.\n*\n*\n*  PROGRAM INPUT:\n*\n*   SYSIN  - SPECIFIES A LIST OF ADDRESS SPACES TO BE VERIFIED.\n*            FORMAT OF THE SYSIN RECORD IS THE FOLLOWING:\n*\n*            1        10       19        - COLUMNS\n*            JOBNAME  STEPNAME PROCSTPN\n*\n*            ANY NUMBER OF CARDS WITH JOB/STC/TSU ADDRESS SPACE NAME\n*            CAN BE SPECIFIED IN THE SYSIN.\n*            STEP NAME AND PROCEDURE STEP NAME ARE OPTIONAL.\n*            IF SPECIFIED - PROGRAM WILL CHECK IF ADDRESS SPACE IS\n*            RUNNING THE SPECIFIED STEP. IF NOT, PROGRAM WILL TERMINATE\n*            WITH RC=16. IF STEP.NAME/PROC.STEP.NAME ARE NOT SPECIFIED,\n*            PROGRAM WILL ONLY CHECK IF THE SPECIFIED JOB/STC/TSU IS\n*            RUNNING.\n*            PROCEDURE STEP NAME SHOULD NOT BE SPECIFIED FOR A TSO\n*            USER (TSU ADDRESS SPACE).\n*\n*\n*  PROGRAM OUTPUT:\n*\n*   SYSPRINT - DIAGNOSTIC MESSAGES\n*\n*\n*  SAMPLE JCL TO RUN THE PROGRAM:\n*\n*   //OFDASVER EXEC PGM=OFDASVER\n*   //STEPLIB    DD DISP=SHR,DSN=<YOUR.LOAD.LIB>\n*   //SYSPRINT   DD SYSOUT=*      MESSAGES FILE\n*   //SYSUDUMP   DD SYSOUT=D      DUMP\n*   //SYSIN     DD *\n*   JOBNAME  STEPNAME PROCSTPN\n*   ......\n*   ......\n*   ......\n*   /*\n*\n* PROGRAM LOGIC:\n*\n*     THIS PROGRAM HAS TO HAVE AMODE=24, RMODE=24 BECAUSE IT USES\n*  NON-VSAM ACCESS METHOD. CSCB CONTROL BLOCK RESIDES HOWEVER ABOVE\n*  THE LINE, SO ADDRESSING MODE SWITCHING IS REQUIRED TO ACCESS IT.\n*     ADDRESS SPACE NAME/STEP NAME/PROCEDURE STEP NAME ARE FOUND IN\n*  THE CSCB CONTROL BLOCK. CSCB IS LOCATED THROUGH THE FOLLOWING\n*  CONTROL BLOCK CHAIN:\n*     PSA -> CVT -> ASVT -> ASCB -> CSCB           (FOR STC/TSU)\n*     PSA -> CVT -> ASVT -> ASCB -> CSCX -> CSCB   (FOR BATCH JOBS)\n*\n*\n* WRITTEN BY: JANEK JAKUBEK, OGL\n*             JANUARY 1993\n*\n* CHANGE ACTIVITY:\n*                 NONE\n*\n*        PRINT NOGEN\nOFDASVER CSECT\nOFDASVER AMODE 24\nOFDASVER RMODE 24\n         SAVE  (14,12)            SAVE REGISTERS\n         USING OFDASVER,R15\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   WRKR1,OFDASSAE     SET SAVE AREA ADDRESS\nOFDASSA  DS    18F                SAVE AREA\nOFDASSAE ST    R13,OFDASSA+4      CHAIN\n         ST    WRKR1,8(R13)       SAVE AREAS\n         LR    R13,WRKR1          CURRENT SAVE AREA\n         DROP  R15\n         USING OFDASSA,R13        PROGRAM BASE REGISTER\n         SPACE\nWRKR1    EQU   R2\nASCBPTR  EQU   R3\nCSCBPTR  EQU   R4\nCVTADDR  EQU   R5\nASVTPTR  EQU   R6\nMAXUSERS EQU   R7\nOUCBPTR  EQU   R8\n         SPACE\n*\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n         BAL   R14,CLEARINR       CLEAR INPUT RECORD\n         MVC   INPUTR(L'MSG1),MSG1 HEADER MESSAGE\n         PUT   SYSPRINT,INPUTR    PRINT IT\n         BAL   R14,CLEARINR       CLEAR INPUT RECORD\n         PUT   SYSPRINT,INPUTR    PRINT IT\n         SPACE\nGETNEXT  GET   SYSIN,INPUTR       GET THE INPUT RECORD\n* FOR EACH INPUT RECORD (ADDRESS SPACE NAME) WE WILL SCAN THE ASVT->\n* ASCB TO FIND OUT IF IT IS RUNNING\n         L     R1,AMODE31         SET ADDRESS WITH H/O BIT ON\n         BSM   R0,R1              SET AMODE 31\nAMODE31  DC    A(AMODE32+X'80000000')\nAMODE32  L     CVTADDR,CVTPTR     LOAD CVT ADDRESS\n         USING CVT,CVTADDR        ADDRESSABILITY ON CVT\n         L     ASVTPTR,CVTASVT    LOAD ASVT ADDRESS\n         USING ASVT,ASVTPTR       ADDRESSABILITY ON ASVT\n         LH    MAXUSERS,ASVTMAXU+2 MAXIMUM NUMBER OF ADDRESS SPACES\n         LA    WRKR1,ASVTENTY     FIRST ASCB ENTRY ADDRESS\n         SPACE\n* ASVT PROCESSING LOOP\nASVTPRL  TM    0(WRKR1),ASVTAVAL  IS THIS ENTRY AVAILABLE.............?\n         BO    NEXTASCB           YES, BYPASS THIS ENTRY-------------->\n         L     ASCBPTR,0(WRKR1)   LOAD ASCB ADDRESS\n         LA    ASCBPTR,0(ASCBPTR) CLEAR H/O BIT\n         LTR   ASCBPTR,ASCBPTR    ASCB POINTER IS ZERO................?\n         BZ    NEXTASCB           YES, CHECK NEXT ASCB---------------->\n         USING ASCB,ASCBPTR       ADDRESSABILITY ON ASCB\n* OUCB CHECK WAS TAKEN FROM SDSF ISFDA MODULE. IT IS PROBABLY TO ENSURE\n* THAT ADDRESS SPACE IS IN FACT RUNNING (AS OPPOSED TO BEING TERMINATED\n* OR CREATED)\n         L     OUCBPTR,ASCBOUCB   OUCB ADDRESS\n         LA    OUCBPTR,0(OUCBPTR) CLEAR H/O BIT\n         LTR   OUCBPTR,OUCBPTR    ANY OUCB............................?\n         BZ    NEXTASCB           NO,  CHECK NEXT ASCB---------------->\n         USING OUCB,OUCBPTR       ADDRESSABILITY ON OUCB\n         TM    OUCBSFL,OUCBINV    IS OUCB VALID.......................?\n         BO    NEXTASCB           NO,  CHECK NEXT ASCB---------------->\n* IN CASE OF A BATCH JOB - ASCBJBNI FILED POINTS TO A JOBNAME FIELD\n* IN THE CSCX CONTROL BLOCK\n         L     CSCBPTR,ASCBJBNI   JOBNAME  ADDRESS\n         LA    CSCBPTR,0(CSCBPTR) CLEAR H/O BIT\n         LTR   CSCBPTR,CSCBPTR    ANY JOBNAME.........................?\n         BZ    NOTBJOB            NO,  EITHER STC OR TSU-------------->\n         USING CHNAME,CSCBPTR     ADDRESSABILITY ON CSCX\n         L     CSCBPTR,CHCSCBP    LOAD CSCB ADDRESS\n         DROP  CSCBPTR            DROP ADDRESSABILITY ON CSCX\n         USING CSCB,CSCBPTR       ADDRESSABILITY ON CSCB\n         MVC   USRJNAME,CHKEY     JOB NAME FOR BATCH JOB\n         MVC   USRSNAME,CHSTEP    STEP NAME FOR BATCH JOB\n         MVC   USRPSTEP,CHPROCSN  PROC.STEP NAME FOR BATCH JOB\n         B     VERJBN             VERFIY IF THIS IS SPECIFIED JOB----->\nNOTBJOB  L     CSCBPTR,ASCBCSCB   CSCB ADDRESS\nNOTBJOB1 LA    CSCBPTR,0(CSCBPTR) CLEAR H/O BIT\n         LTR   CSCBPTR,CSCBPTR    ANY CSCB............................?\n         BZ    NEXTASCB           NO,  CHECK NEXT ASCB---------------->\n* NO JOBNAME POINTER PRESENT, MUST BE TSU, STC, OR INIT\n         TM    OUCBYFL,OUCBSTT+OUCBMNT IS IS A START OR MOUNT.........?\n         BZ    TSU1               NO,  MUST BE A TSU------------------>\n         MVC   USRJNAME,CHCLS     JOBNAME = PROC NAME FOR STC\n         MVC   USRSNAME,CHKEY     STEPNAME = TASK ID FOR STC\n         MVC   USRPSTEP,CHPROCSN  PROC.STEP NAME FOR STC\n         B     VERJBN             CHECK IF THIS IS SPECIFIED A/S------>\nTSU1     MVC   USRJNAME,CHKEY     JOBNAME = USERID FOT TSU\n         MVC   USRSNAME,CHCLS     STEPNAME = LOGON PROC NAME FOR STC\n         MVC   USRPSTEP,=CL8' '   NO PROC.STEP NAME FOR TSU\n* LET'S CHECK IF THIS IS ADDRESS SPACE SPECIFIED IN THE SYSIN\nVERJBN   CLC   ASNAME,USRJNAME    IS THIS THE REQUESTED A/S...........?\n         BNE   NEXTASCB           NO,  CHECK NEXT ASCB---------------->\n         CLI   STEPNAME,C' '      IS STEP NAME SPECIFIED AS WELL......?\n         BE    VERPRCSN           NO, VERIFY PROCEDURE STEPNAME------->\n         CLC   STEPNAME,USRSNAME  IS THIS THE REQUESTED STEP..........?\n         BNE   NEXTASCB           NO,  CHECK NEXT ASCB---------------->\nVERPRCSN CLI   PROCSNME,C' '      IS PROC.STP.NAME SPECIFIED AS WELL..?\n         BE    ASFOUND            NO, REQUESTED A/S IS RUNNING-------->\n         CLC   PROCSNME,USRPSTEP  IS THIS THE REQUESTED PROC.STEP.....?\n         BNE   NEXTASCB           NO,  CHECK NEXT ASCB---------------->\n* REQUESTED ADDRESS SPACE IS RUNNING\nASFOUND  MVC   MSGTEXT(L'MSGT0),MSGT0 MESSAGE TEXT\n         BAL   R14,PUTMSG         PRINT MESSAGE\n         BAL   R14,CLEARINR       CLEAR THE INPUT RECORD\n         B     GETNEXTM           GET THE NEXT INPUT A/S NAME--------->\n         SPACE\n* VERIFY NEXT ADDRESS SPACE FORM ASVT\nNEXTASCB LA    WRKR1,4(,WRKR1)    ADDRESS OF NEXT ASCB ENTRY IN ASVT\n         BCT   MAXUSERS,ASVTPRL\n* WE CHECKED ALL ASCBS AND NO MACHING A/S FOUND\n* REQUESTED ADDRESS SPACE IS NOT RUNNING IN THE SYSTEM\n         MVC   MSGTEXT(L'MSGT16),MSGT16 MESSAGE TEXT\n         BAL   R14,PUTMSG         PRINT MESSAGE\n         BAL   R14,CLEARINR       CLEAR THE INPUT RECORD\n         MVC   RC,=A(16)          RC=16\n         SPACE\nGETNEXTM LA    R1,GETNM24         LOAD ADDRESS WITH H/O BIT OFF\n         BSM   R0,R1              SET MODE 24\nGETNM24  B     GETNEXT            GET NEXT SYSIN RECORD--------------->\n         SPACE\nEOF      LA    R1,CLOSE24         LOAD ADDRESS WITH H/O BIT OFF\n         BSM   R0,R1              SET MODE 24\nCLOSE24  CLOSE (SYSIN,,SYSPRINT)  CLOSE FILES\n         L     R15,RC             SET RETURN CODE\n         L     R13,OFDASSA+4      PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)\n         SPACE\n* WRITE OUT A MESSAGE RECORD\n* ADDRESSING MODE SWITCHING IS REQUIRED FOR NON-VSAM MACROS\nPUTMSG   SUBENT\n         LA    R1,PUTMSG24        LOAD ADDRESS WITH H/O BIT OFF\n         BSM   R0,R1              SET MODE 24\nPUTMSG24 PUT   SYSPRINT,INPUTR    WRITE OUT A MESSAGE\n         L     R1,PUTMSG31        SET ADDRESS WITH H/O BIT ON\n         BSM   R0,R1              SET AMODE 31\nPUTMSG31 DC    A(PUTMSG32+X'80000000')\nPUTMSG32 SUBRET PUTMSG            RETURN\n         SPACE\n         PRINT NOGEN\nSYSIN    DCB   DSORG=PS,MACRF=GM,DDNAME=SYSIN,                         +\n               RECFM=FB,LRECL=80,EODAD=EOF\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      +\n               RECFM=FB,LRECL=120\n         SPACE\nMSG1     DC    C'OFDASVER - PROGRAM VERIFIES IF SPECIFIED ADDRESS SPACE+\n               S ARE RUNNING'\n         SPACE\nCLEARINR MVI   INPUTR,C' '        CLEAR THE RECORD\n         MVC   INPUTR+1(L'INPUTR-1),INPUTR\n         BR    R14\n         SPACE\nINPUTR   DS    0CL120\nASNAME   DS    CL8                ADDRESS SPACE NAME\n         DS    CL1\nSTEPNAME DS    CL8                STEP NAME\n         DS    CL1\nPROCSNME DS    CL8                PROCEDURE STEP NAME\n         DS    CL1\nMSGTEXT  DS    CL91               MESSAGE TEXT\n         SPACE\nUSRJNAME DS    CL8                ADDRESS SPACE NAME\nUSRSNAME DS    CL8                STEP NAME\nUSRPSTEP DS    CL8                PROCEDURE STEP NAME\n         SPACE\nMSGT0    DC    C' - RC=0, ADDRESS SPACE IS RUNNING IN THE SYSTEM'\nMSGT16   DC    C' - RC=16, ADDRESS IS NOT IN THE SYSTEM'\nRC       DC    A(0)               RETURN CODE FROM THE PROGRAM\n         SPACE\n         LTORG\n         SPACE\n* CONTROL BLOCK MAPPING\nCSCB     DSECT\n         IEECHAIN\n         CVT     DSECT=YES\n         IHAASCB DSECT=YES\n         IHAASVT\n         IRAOUCB\n         END   OFDASVER\n/*\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF'\n//SYSLMOD  DD DISP=SHR,DSN=...your.loadlib....\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n MODE AMODE(24),RMODE(24)\n ENTRY OFDASVER\n NAME  OFDASVER(R)\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OFDVBFB": {"ttr": 5899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x924O\\x01\\x01\\x15\\x1f\\x08R\\x00\\xe2\\x00\\xb9\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-12-09T00:00:00", "modifydate": "2001-05-31T08:52:00", "lines": 226, "newlines": 185, "modlines": 0, "user": "SYMP118"}, "text": "//*.......  JOB  ....YOUR JOBCARD......\n//*\n//ASM      EXEC PGM=ASMA90,PARM='OBJECT,NODECK,LINECOUNT(64)'\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSPUNCH DD DUMMY\n//SYSUT1   DD UNIT=VIO,SPACE=(1024,(120,120))\n//SYSLIN   DD UNIT=VIO,SPACE=(3040,(40,40),RLSE),\n//            DCB=(RECFM=FBS,LRECL=80,BLKSIZE=0),\n//            DSN=&&SYSLIN,DISP=(NEW,PASS)\n//SYSIN    DD *\n      TITLE 'CONVERT VB RECORDS INTO FB'\n* CONVERSION OF VB RECORDS INTO FB FORMAT\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: OFDVBFB\n*\n* ATTRIBUTES : STANDARD\n*              RMODE 24\n*              AMODE 24\n*\n* FUNCTION   :\n*\n*      PROGRAM CONVERTS VARIABLE RECORDS TO FIXED. IF INPUT RECORD IS\n*   LONGER THAN OUTPUT RECORD LENGTH, IT GETS TRUNCATED BEFORE BEING\n*   WRITTEN OUT. FOR INPUT RECORDS SHORTER THAN OUTPUT RECORD LENGTH -\n*   OUTPUT RECORD IS PADDED WITH BLANKS.\n*\n* INPUT TO THE PROGRAM:\n*\n* .VBIN - INPUT FILE (RECFM=V)\n*\n* .FBOUT  - OUTPUT FILE WITH RECFM=F\n*\n* HERE IS A SAMPLE JCL TO RUN THE PROGRAM:\n*\n*     //VBTOFB   EXEC PGM=OFDVBFB\n*     //STEPLIB    DD DSN=SYS2.TLINKLIB,DISP=SHR\n*     //VBIN       DD DSN=........\n*     //FBOUT      DD DSN=XXXXX.YYYYY,UNIT=DISK,SPACE=(TRK,(1,1)),\n*     //              DISP=(NEW,CATLG),LRECL=NNNN\n*\n*\n* WRITTEN BY: JANEK JAKUBEK\n*                DEC. 1991\n*\n* CHANGE ACTIVITY:\n*   MAY 30/2001JJ:\n*   INCLUDED TSTAMP MACRO INLINE, ADDED RMODE/AMODE 24 + JCL WRAP\n*\n*\n*\n         MACRO\n&NAME    TSTAMP\n.*\n.*  DATE AND TIME STAMP MACRO\n.*  GENERATES A CONSTANT WITH DATE AND TIME OF PROGRAM COMPILATION\n.*\n         LCLC  &STAMP\n&STAMP   SETC  'COMPILATION DATE='.'&SYSDATE'.' TIME='.'&SYSTIME'\n&NAME    DC    C'&STAMP'\n         MEND\nOFDVBFB  CSECT                    CSECT NAME\nOFDVBFB  AMODE 24\nOFDVBFB  RMODE 24\n         USING OFDVBFB,R15\n         SAVE  (14,12)            SAVE REGISTERS\n         B     AROUNDTS           BRANCH AROUND TIME STAMP\n         TSTAMP\n         PRINT NOGEN\nAROUNDTS CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   R2,SAE             SET SAVE AREA ADDRESS\nSA       DS    18F                SAVE AREA\n         DROP  R15\n         USING SA,R2\nSAE      ST    R13,SA+4           CHAIN\n         ST    R2,8(R13)          SAVE AREAS\n         LR    R13,R2             CURRENT SAVE AREA\n         DROP  R2\n         USING SA,R13             PROGRAM BASE REGISTER\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n* TWO PAIRS OF REGISTERS BELOW HAVE TO BE EVEN/ODD PAIRS\n*//////////////////////////////////////////////////////////////////////\nOUTRADR  EQU   R2                OUTPUR RECORD ADDRESS\nOUTRLEN  EQU   R3                OUTPUR RECORD ADDRESS\n*//////////////////////////////////////////////////////////////////////\nINRDADR  EQU   R4                INPUT RECORD DATA ADDRESS\nINRDLEN  EQU   R5                INPUT RECORD DATA LENGTH\n*//////////////////////////////////////////////////////////////////////\nDCBADR   EQU   R1                DCB ADDRESS REGISTER\nLNKREG1  EQU   R6                LINK REGISTER FOR SUBROUTINE CALLS\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         SPACE\n*  OPEN VBIN (INPUT) FILE\n         OPEN  (VBIN)\n         LA    DCBADR,VBIN        DCB ADDRESS\n         USING IHADCB,DCBADR      ADDRESSIBILITY ON DCB\n         TM    DCBOFLGS,DCBOFOPN  OPEN SUCCESSFUL.....................?\n         BNO   VBINOE             NO, VBIN OPEN ERROR----------------->\n         TM    DCBRECFM,DCBRECV   VARIABLE RECORD LENGTH..............?\n         BNO   VBINVE             NO, NOT A VARIABLE RECORD----------->\n*  OPEN OUTPUT FBOUT FILE (RECFM=F)\n         OPEN  (FBOUT,(OUTPUT))\n         LA    DCBADR,FBOUT       DCB ADDRESS\n         TM    DCBOFLGS,DCBOFOPN  OPEN SUCCESSFUL.....................?\n         BNO   FBOUTOE            NO, FBOUT OPEN ERROR---------------->\n         TM    DCBRECFM,DCBRECF   FIXED RECORD LENGTH.................?\n         BNO   FBOUTNF            NO, NOT A FIXED RECORD-------------->\n         LH    R0,DCBLRECL        LOAD THE LOGICAL RECORD LENGTH\n         STH   R0,OUTRECL         SAVE IT FOR LATER USE\n         GETMAIN R,LV=(0)         GET STORAGE FOR OUTPUT RECORD\n         ST    R1,OUTRECA         SAVE THE OUTPUT RECORD ADDRESS\n*\n* READ THE VBIN FILE AND PROCESS THE RECORDS\n*\nGETVBREC DS   0H\n         GET  VBIN                GET THE VBIN RECORD\n         LH   INRDLEN,0(R1)       INPUT RECORD LENGTH\n         SH   INRDLEN,=H'4'       - 4 = DATA LENGTH\n         LA   INRDADR,4(,R1)      INPUT RECORD DATA ADDRESS\n         ICM  INRDLEN,B'1000',=X'40'  INSERT PAD CHARACTER\n         L    OUTRADR,OUTRECA     OUTPUT RECORD ADDRESS\n         LH   OUTRLEN,OUTRECL     OUTPUT RECORD LENGTH\n         MVCL OUTRADR,INRDADR     MOVE INPUT RECORD DATA TO THE OUTPUT\n*                                 RECORD AREA WITH TRUNCATION/PADDING\n         L    R0,OUTRECA          OUTPUT RECORD ADDRESS\n         PUT  FBOUT,(0)           WRITE IT OUT AS AN FB\n         B    GETVBREC            GET NEXT INPUT RECORD\n         SPACE\n*---------------------------------------------------------------------*\n* END OF VBIN FILE, ALL RECORD PROCESSED                              *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nEOFVBIN  DS   0H                  END OF INPUT FILE\n         L     R1,OUTRECA         OUTPUT RECORD ADDRESS\n         LH    R0,OUTRECL         OUTPUT RECORD LENGTH\n         FREEMAIN R,LV=(0),A=(1)  FREE OUTPUT RECORD AREA\n         BAL   LNKREG1,CVBIN      CLOSE THE INPUT FILE\n         BAL   LNKREG1,CFBOUT     CLOSE THE OUTPUT FILE\nRET0     SR    R15,R15            RC = 0 ( NORMAL COMPLETION )\nRETNZ    L     R13,SA+4           PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=(15)   RETURN\n         SPACE\nCVBIN    CLOSE (VBIN)             CLOSE THE INPUT FILE\n         BR    LNKREG1            RETURN\nCFBOUT   CLOSE (FBOUT)            CLOSE THE OUTPUT FILE\n         BR    LNKREG1            RETURN\n         SPACE\nRC16     LA    R15,16             ERROR RETURN CODE\n         B     RETNZ              NON-ZERO RETURN CODE\n         SPACE\nVBINOE   DS    0H                 VBIN DCB OPEN ERROR\n         WTO   'OFDVBFB   - VBIN    DATA SET CANNOT BE OPENED',        +\n               MCSFLAG=(HRDCPY)\n         B     RC16\n         SPACE\nVBINVE   DS    0H                 VBIN NOT VARIABLE LENGTH RECORDS\n         WTO   'OFDVBFB   - VBIN    DOES NOT CONTAIN VARIABLE LENGTH RE+\n               CORDS',MCSFLAG=(HRDCPY)\n         BAL   LNKREG1,CVBIN      CLOSE THE INPUT FILE\n         B     RC16\n         SPACE\nFBOUTOE  DS    0H                 FBOUT DCB OPEN ERROR\n         WTO   'OFDVBFB   - FBOUT   DATA SET CANNOT BE OPENED',        +\n               MCSFLAG=(HRDCPY)\n         BAL   LNKREG1,CVBIN      CLOSE THE INPUT FILE\n         B     RC16\n         SPACE\nFBOUTNF  DS    0H                 FBOUT NOT VARIABLE LENGTH RECORDS\n         WTO   'OFDVBFB   - FBOUT   DOES NOT CONTAIN FIXED LENGTH RECOR+\n               DS',MCSFLAG=(HRDCPY)\n         BAL   LNKREG1,CVBIN      CLOSE THE INPUT FILE\n         BAL   LNKREG1,CFBOUT     CLOSE THE OUTPUT FILE\n         B     RC16\n         SPACE\n*  INPUT VBIN FILE\nVBIN     DCB   DSORG=PS,MACRF=GL,DDNAME=VBIN,EODAD=EOFVBIN\n         SPACE\n*  CONVERTED FBOUT RECORDS OUTPUT SEQUENTIAL FILE\nFBOUT    DCB   DSORG=PS,MACRF=PM,DDNAME=FBOUT\n         SPACE\nOUTRECA  DS    A                  OUTPUT RECORD ADDRESS\nOUTRECL  DS    H                  OUTPUT RECORD LENGTH\n         LTORG\n         SPACE\n         DCBD  DSORG=PS\n         END   OFDVBFB\n//*\n//LKED     EXEC PGM=IEWL,\n//         PARM='NCAL,LET,LIST,XREF'\n//SYSLMOD  DD DISP=SHR,DSN=...YOUR.LOADLIB....\n//SYSUT1   DD UNIT=VIO,SPACE=(TRK,(10,10))\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&SYSLIN,DISP=(OLD,DELETE)\n//         DD DDNAME=SYSIN\n//SYSIN    DD *\n NAME OFDVBFB(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SUBENT": {"ttr": 6148, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     SUBENT\n.* \"SUBENT\" MACRO IS USED AT ENTRY TO AN INTERNAL SUBROUTINE\n.* LINK REGISTER HAS TO BE ALWAYS R14.\n.* IT SHOULD BE USED WHENEVER R14 IS CHANGED BY SUBROUTINE.\n.*\n.* EXAMPLE:\n.*          ...\n.*          BAL   R14,SUBRNAME\n.*          ...\n.* SUBRNAME SUBENT\n.*          ...             SUBROUTINE'S CODE\n.*          SUBRET SUBRNAME\n.*\n&LAB     DS    0F\n         B     *+16               AROUND EYE CATCHER AND R14 SAVE\n         DC    CL8'&LAB'          EYE CATCHER\n         DC    F'0'               R14 SAVE\n         ST    R14,*-4            STORE R14\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBRET": {"ttr": 6150, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB1    SUBRET &LAB\n.* \"SUBRET\" MACRO IS USED AT EXIT FROM AN INTERNAL SUBROUTINE.\n.* IT IS INTENDED TO BE USED JOINTLY WITH \"SUBENT\" MACRO\n&LAB1    L     R14,&LAB+12              RESTORE R14\n         BR    R14                      RETURN\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBLACCSS": {"ttr": 6152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x00\\x90)\\x8f\\x01\\x025/\\x15$\\x00\\xf8\\x00\\xf5\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-10-25T00:00:00", "modifydate": "2002-12-18T15:24:27", "lines": 248, "newlines": 245, "modlines": 0, "user": "SYMP118"}, "text": "         TITLE 'TBLACCSS - TABLES ACCESS INTERFACE ROUTINE'\n* TABLES ACCESS INTERFACE ROUTINE FOR COBOL PROGRAMS\n*\n* SPECIFICATIONS:\n*\n* MODULE NAME: TBLACCSS\n*\n* FUNCTION = SEE BELOW\n*\n*       THE SUBROUTINE ALLOWS ACCESSING OF TABLES CREATED BY\n*    \"OFDTBGEN\" UTILITY IN COBOL APPLICATION PROGRAMS. IT LOADS\n*    A TABLE INTO STORAGE AND ACCESSES ITS ELEMENTS USING \"HALVE\"\n*    BINARY SEARCH SUBROUTINE. REFER TO \"OFDTBGEN\" AND \"HALVE\"\n*    WRITEUPS FOR MORE INFORMATION ABOUT THE TABLES. \"HALVE\"\n*    SUBROUTINE CAN NOT BE USED DIRECTLY IN A COBOL PROGRAM BECAUSE\n*    IT USES ADDRESS (POINTER) TYPE VARIABLES NOT AVAILABLE IN COBOL.\n*\n* CALL STMT FORMAT (IN COBOL):\n*\n*    CALL 'TBLACCSS' USING TABLE-NAME TABLE-ELEM ACCESS-TYPE RET-CODE.\n*\n*    TABLE-NAME  - GROUP DATA ITEM. CONTAINS NAME OF A TABLE (LOAD\n*                  MODULE NAME) PLUS TWO FIELDS RESERVED FOR \"TBLACCSS\"\n*                  USE ONLY (SEE THE SAMPLE BELOW).\n*    TABLE-ELEM  - GROUP DATA ITEM. ON OUTPUT IT CONTAINS THE REQUESTED\n*                  ELEMENT OF A TABLE (IF FOUND). ON INPUT IT HAS TO\n*                  HAVE THE KEY OF ELEMENT TO BE LOOKED FOR.\n*    ACCESS-TYPE - ONE BYTE CHARACTER DEFINING TYPE OF REQUEST:\n*                  \"G\" - GET TABLE ELEMENT.\n*                  \"I\" - INSERT. TABLE-ELEM HAS TO CONTAIN ELEMENT TO\n*                        BE INSERTED (ADDED TO) INTO THE TABLE.\n*                  \"R\" - REPLACE. TABLE-ELEM HAS TO CONTAIN ELEMENT TO\n*                        BE REPLACED IN THE TABLE.\n*    RET-CODE    - PIC 9(9) COMP (4 BYTES BINARY) ELEMENTARY DATA ITEM.\n*                  ON OUTPUT IT CONTAINS RETURN CODE DEPENDING ON\n*                  ACCESS-TYPE:\n*                  FOR \"G\": 0 - REQUESTED ELEMENT FOUND IN THE TABLE\n*                               AND RETURNED TO THE CALLER.\n*                           4 - REQUESTED ELEMENT NOT FOUND IN THE\n*                               TABLE.\n*                  FOR \"I\": 0 - REQUESTED ELEMENT INSERTED INTO THE\n*                               TABLE.\n*                           4 - ELEMENT WITH SPECIFIED KEY ALREADY\n*                               EXISTS IN THE TABLE.\n*                           8 - TABLE ALREADY FULL. NO NEW ELEMENT CAN\n*                               BE ADDED.\n*                  FOR \"R\": 0 - REQUESTED ELEMENT FOUND IN THE TABLE\n*                               AND REPLACED.\n*                           4 - REQUESTED ELEMENT NOT FOUND IN THE\n*                               TABLE AND THEAFORE COULD NOT BE\n*                               REPLACED.\n*                  IF ACCESS-TYPE DOES NOT SPECIFIY ANY OF THE ABOVE -\n*                  RET-CODE = 16 IS RETURNED AND TABLE ISN'T ACCESSED\n*                  AT ALL.\n*\n* WRITTEN BY: JANEK JAKUBEK, OGL\n*             MARCH-APRIL 1986\n*\n         SPACE\nTBLACCS1 CSECT                    CSECT NAME\n         DC    C'TBLACCSS'        DUMP EYE CATCHER\nTBLACCSS SAVE  (14,12)            SAVE REGISTERS\n         ENTRY TBLACCSS           ENTRY POINT\n         USING TBLACCSS,R15\n         SPACE\n*   REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\nPLAR     EQU   R1                 PARAMETER LIST ADDRESS\nWRKR1    EQU   R2                 WORK REGISTER 1\nTDEFAR   EQU   R7                 TDEF ADDRESS REGISTER\nNMSR     EQU   R8                 NM FROM TDEF SAVE REGISTER\n         SPACE\nKEYFF    EQU   X'80'              KEY FOUND ( IN THE TABLE ) FLAG\n         SPACE\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   WRKR1,SAE          SAVE AREA ADDRESS\nSAVEA    DS    20F                SAVE AREA (HALVE REQUIRES 20F)\n         DROP  R15\n         USING SAVEA,WRKR1\nSAE      ST    R13,SAVEA+4        CHAIN\n         ST    WRKR1,8(R13)       SAVE AREAS\n         LR    R13,WRKR1          CURRENT SAVE AREA\n         DROP  WRKR1\n         USING SAVEA,R13          PROGRAM BASE REGISTER\n         SPACE\n         USING PARMLST,PLAR       PARAMETERS LIST ADDRESSABILITY\n         LM    R3,R6,PARMLST      LOAD ADDRESSES FROM PARM LIST\n         USING TBLNAMED,R3        TABLE NAME ADDRESSABILITY\n         TM    TBLNAMEA,X'80'     TABLE NAME ONLY SPECIFIED IN CALL...?\n         BO    TBLONLY            YES, LOAD OR DELETE REQUEST ONLY---->\n         OC    TDEFADDR,TDEFADDR  FIRST ENTRY FOR THIS TABLE..........?\n         BNZ   NFE                NO, NOT FIRST ENTRY----------------->\n         BAL   R14,LOAD           YES, LOAD TABLE AND HALVE\n* SETUP PARM LIST FOR HALVE CALL\nNFE      MVC   HCTDEFA,TDEFADDR   TDEF ADDRESS INTO PARM LIST\n         ST    R4,HCIKA           INPUT_KEY (TABLE ELEMENT) ADDRESS\n         SPACE\n         USING TDEF,TDEFAR        TDEF ADDRESSABILITY\n         L     NMSR,NM            SAVE NM (MAX.SIZE OF THE TABLE)\n         CLI   0(R5),C'G'         GET REQUEST        .................?\n         BE    GETREQ             YES, GET REQUEST   ----------------->\n         CLI   0(R5),C'I'         INSERT REQUEST     .................?\n         BE    INSREQ             YES, INSERT        ----------------->\n         CLI   0(R5),C'R'         REPLACE REQUEST    .................?\n         BE    REPREQ             YES, REPLACE       ----------------->\n         B     INVREQ             INVALID REQUEST SPECIFIED----------->\n         SPACE\n* GET A TABLE ELEMENT\nGETREQ   MVC   NM,NA              LOCK THE TABLE (PREVENT EXPANTION)\n         LA    R1,HALVECAL        HALVE CALL PARM LIST ADDRESS\n         L     R15,HALVEADR       HALVE ENTRY POINT ADDRES\n         BALR  R14,R15            CALL HALVE SUBROUTINE\n         ST    NMSR,NM            RESTORE NM (UNLOCK THE TABLE)\n         TM    IFFI,KEYFF         WAS REQUESTED ELEMENT FOUND.........?\n         BZ    RC4                NOT FOUND, SET RET-CODE = 4 -------->\n* TABLE ELEMENT FOUND, MOVE IT INTO TABLE-ELEM\n         LR    R10,R4             TABLE-ELEM (OUTPUT) ADDRESS\n         LH    R11,LEN            LENGTH OF THE TABLE ELEMENT\n         LR    R15,R11\n         L     R14,EADR           FOUND TABLE ELEMENT ADDRESS\n         MVCL  R10,R14            MOVE ELEMENT INTO OUTPUT FIELD\n         B     RC0                SET 0 RET-CODE---------------------->\n         SPACE\n* INSERT AN ELEMENT INTO THE TABLE\nINSREQ   CLC   NM,NA              CAN NEW ELEMENTS BE ADDED...........?\n         BNH   RC8                NO, TABLE ALREADY FULL-------------->\n         LA    R1,HALVECAL        HALVE CALL PARM LIST ADDRESS\n         L     R15,HALVEADR       HALVE ENTRY POINT ADDRES\n         BALR  R14,R15            CALL HALVE SUBROUTINE\n         TM    IFFI,KEYFF         ELEMENT ADDED TO THE TABLE..........?\n         BO    RC4                ELEMENT ALREADY EXIST--------------->\n* TABLE ELEMENT INSERTION\n         LR    R10,R4             TABLE-ELEM (INPUT) ADDRESS\n         LH    R11,LEN            LENGTH OF THE TABLE ELEMENT\n         LR    R15,R11\n         L     R14,EADR           LOCATED TABLE ELEMENT ADDRESS\n         MVCL  R14,R10            MOVE INPUT ELEMENT INTO THE TABLE\n         B     RC0                SET 0 RET-CODE---------------------->\n         SPACE\n* REPLACE A TABLE ELEMENT\nREPREQ   MVC   NM,NA              LOCK THE TABLE (PREVENT EXPANTION)\n         LA    R1,HALVECAL        HALVE CALL PARM LIST ADDRESS\n         L     R15,HALVEADR       HALVE ENTRY POINT ADDRES\n         BALR  R14,R15            CALL HALVE SUBROUTINE\n         ST    NMSR,NM            RESTORE NM (UNLOCK THE TABLE)\n         TM    IFFI,KEYFF         WAS REQUESTED ELEMENT FOUND.........?\n         BZ    RC4                NOT FOUND, SET RET-CODE = 4 -------->\n* TABLE ELEMENT FOUND, REPLACE IT IN THE TABLE\n         LR    R10,R4             TABLE-ELEM (INPUT) ADDRESS\n         LH    R11,LEN            LENGTH OF THE TABLE ELEMENT\n         LR    R15,R11\n         L     R14,EADR           FOUND TABLE ELEMENT ADDRESS\n         MVCL  R14,R10            REPLACE ELEMENT IN THE TABLE\n         B     RC0                SET 0 RET-CODE---------------------->\n         SPACE\n* ONLY FIRST ARGUMENT SPECIFIED IN THE CALL, LOAD IF NOT LOADED,\n* DELETE REQUEST IF LOADED ALREADY\nTBLONLY  OC    TDEFADDR,TDEFADDR  LOAD OR DELETE REQUEST..............?\n         BZ    TBLOAD             LOAD BECAUSE ADDRESS IS ZERO-------->\n         BAL   R14,DELETE         DELETE BECAUSE LOADED PREVIOUSLY\n         B     RETURN             RETURN FROM THE PROGRAM------------->\nTBLOAD   BAL   R14,LOAD           LOAD TABLE AND HALVE INTO STORAGE\n         SPACE\nRETURN   DS    0H\n         L     R13,4(0,R13)       RESTORE OLD SAVE AREA ADDRESS\n         RETURN (14,12)           <-----------------------------------\n         SPACE\nSETRC    ST    R15,0(,R6)         SET RET-CODE VALUE\n         B     RETURN             RETURN TO THE CALLER---------------->\n         SPACE\nRC0      SR    R15,R15            NORMAL RETURN CODE\n         B     SETRC              STORE IT INTO OUTPUT RET-CODE------->\n         SPACE\nRC4      LA    R15,4              RET-CODE = 4\n         B     SETRC              STORE IT INTO OUTPUT RET-CODE------->\n         SPACE\nRC8      LA    R15,8              RET-CODE = 8\n         B     SETRC              STORE IT INTO OUTPUT RET-CODE------->\n         SPACE\nINVREQ   DS    0H                 INVALID REQUEST SPECIFIED\n         LA    R15,16             SET RET-CODE = 16\n         B     SETRC                                  ---------------->\n         SPACE\n*---------------------------------------------------------------------*\n*  LOAD TABLE AND HALVE INTO STORAGE                                  *\n*---------------------------------------------------------------------*\nLOAD     ST    R14,LEVELA         SAVE RETURN REGISTER\n         LOAD  EPLOC=TBLNAME      LOAD THE TABLE INTO STRORAGE\n         ST    R0,TDEFADDR        SAVE TABLE ADDRESS\n         LR    TDEFAR,R0          SET TDEF ADDRESS REGISTER\n         LOAD  EPLOC=HALVE        LOAD HALVE SUBROUTINE INTO STRORAGE\n         ST    R0,HALVEADR        SAVE HALVE EP ADDRESS\n         L     R14,LEVELA         RESTORE RETURN REGISTER\n         BR    R14                RETURN\n         SPACE\n*---------------------------------------------------------------------*\n*  DELETE THE TABLE AND HALVE FROM STORAGE                            *\n*---------------------------------------------------------------------*\nDELETE   ST    R14,LEVELA         SAVE RETURN REGISTER\n         DELETE EPLOC=TBLNAME     DELETE THE TABLE FROM STROAGE\n         DELETE EPLOC=HALVE       DELETE HALVE FROM STORAGE\n         SR    R0,R0\n         ST    R0,TDEFADDR        CLEAR TABLE ADDRESS\n         ST    R0,HALVEADR        CLEAR HALVE EP ADDRESS\n         L     R14,LEVELA         RESTORE RETURN REGISTER\n         BR    R14                RETURN\n         SPACE\nHALVE    DC    CL8'HALVE'         HALVE SUBROUTINE NAME\nLEVELA   DS    A                  LEVEL A SUBROUTINES RETADDR SAVE\n         SPACE\nHALVECAL DS    0A                 HALVE CALL LIST\nHCTDEFA  DS    A                  TDEF ADDRESS\nHCIKA    DS    A                  INPUT_KEY ADDRESS\nHCFI     DC    X'80',AL3(IFFI)    IF_FOUND_INDICATOR ADDRESS\n         SPACE\nIFFI     DS    XL1                IF_FOUND_INDICATOR\n         LTORG\n         SPACE 2\nTDEF     HLVTD DSECT              PROCESSED TABLE DEFINITION\n         SPACE\nPARMLST  DSECT                    INPUT PARAMETERS' ADDRESS LIST\nTBLNAMEA DS    A                  TABLE NAME ADDRESS\nTBLELEMA DS    A                  TABLE ELEMENT ADDRESS (INPUT)\nREQTYPEA DS    A                  REQUEST TYPE ADDRESS\nRETCODEA DS    A                  RETURN CODE ADDRESS\n         SPACE\nTBLNAMED DSECT                    TABLE NAME DSECT\nTBLNAME  DS    CL8                TABLE NAME\nTDEFADDR DS    A                  TABLE DEFINITION ADDRESS\nHALVEADR DS    A                  HALVE ENTRY POINT ADDRESS\n         SPACE\n         END   TBLACCSS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TI": {"ttr": 6157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x08\\x01\\x04\\x04O\\x01\\x04\\x08/\\x11\\x18\\x00#\\x00\\x1a\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2004-02-13T00:00:00", "modifydate": "2004-03-22T11:18:08", "lines": 35, "newlines": 26, "modlines": 0, "user": "SYMP118"}, "text": "/* REXX                                                           */\n/*                                                                */\n/* Display RMM tape dataset info for an ISPF 3.4 dataset list     */\n/* entry using RMM LISTDATASET subcommand                         */\n/* (will only work if entered on a 3.4 dataset list line).        */\n/*                                                                */\n/* This exec invokes CSILCAT exec from Neil's Computer Page       */\n/* at: http://www.uberfish.freeserve.co.uk/Computers/             */\n/* to retrieve tape file sequence # from a catalogue.             */\n/*                                                                */\n/* Author: Janek Jakubek                                          */\n/* Last update date: Feb.13/2004                                  */\n/*                                                                */\n/*----------------------------------------------------------------*/\n/* trace R */\nAddress ispexec 'CONTROL ERRORS RETURN'\n/* Retrieve some 3.4 panel line variables                         */\nAddress ispexec 'VGET (ZDLDSN ZDLVOL ZDLCAT)'\nIf ZDLVOL = ''  Then Do;\n  say 'Volser is required do display RMM dataset info'\n  Exit\n  End\n/* Get FILESEQ# for this dataset via CSI (CSILCAT exec)           */\nparse value CSILCAT(ZDLDSN,'FILESEQ') with rc ',' dsn.0 ',' dataset\nIf rc <> '0'  Then Do;\n  say 'Catalog search return code =' rc\n  Exit\n  End\nparse var dataset dsn ';' fseq#\nIf ( fseq# == '0' | dsn.0 <> '1' ) Then Do;\n  say 'This is not a tape dateaset'\n  say 'FSEQ#=' fseq# 'dsn.0=' dsn.0\n  Exit\n  End\nAddress TSO \"%BTSO RMM LD \"ZDLDSN\" VOLUME(\"ZDLVOL\") SEQ(\"fseq#\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTAMP": {"ttr": 6159, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    TSTAMP\n.*\n.*  DATE AND TIME STAMP MACRO\n.*  GENERATES A CONSTANT WITH DATE AND TIME OF PROGRAM COMPILATION\n.*\n         LCLC  &STAMP\n&STAMP   SETC  'COMPILATION DATE='.'&SYSDATE'.' TIME='.'&SYSTIME'\n&NAME    DC    C'&STAMP'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TV": {"ttr": 6161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00T\\x01\\x04\\x04?\\x01\\x04\\x04O\\x15P\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-02-12T00:00:00", "modifydate": "2004-02-13T15:50:54", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYMP118"}, "text": "PROC 1 DSN\n/*                                                             */\n/* Display RMM tape volume info for an ISPF 3.4 dataset list   */\n/* entry using RMM VOLUME subcommand                           */\n/* (will only work if entered on a 3.4 dataset list line).     */\n/*                                                             */\n/* Author: Janek Jakubek                                       */\n/* Last update date: Feb.13/2004                               */\n/*                                                             */\nCONTROL NOLIST NOMSG NOCONLIST NOSYMLIST NOFLUSH\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC VGET (ZDLVOL)\n%BTSO RMM LV &ZDLVOL ALL\nEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WTOH": {"ttr": 6163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x05\\x00\\x99\\x15o\\x01\\x03\\x01_\\x10\\x12\\x00\\xfb\\x00\\xf8\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-06-05T00:00:00", "modifydate": "2003-01-15T10:12:05", "lines": 251, "newlines": 248, "modlines": 0, "user": "SYMP118"}, "text": "//jobname  JOB ....your jobcard\n//*\n/*ROUTE PRINT LOCAL\n//ASM     EXEC PGM=ASMA90,PARM='NODECK,OBJ'\n//*STEPLIB   DD DISP=SHR,DSN=SYS1.SASMMOD1\n//SYSLIB    DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1    DD UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//SYSLIN    DD DSN=&&OBJECT,SPACE=(CYL,(1,1)),UNIT=SYSALLDA,\n//             DISP=(NEW,PASS),\n//             DCB=(BLKSIZE=0,LRECL=80,RECFM=FBS)\n//SYSIN     DD *\n         TITLE 'WRITE a highlighted MESSAGE TO OPERATOR ROUTINE'\n* SPECIFICATIONS:\n*\n* MODULE NAME: WTOH\n*\n* ATTRIBUTES : REUSABLE\n*\n* FUNCTION = SEE BELOW\n*\n*     THIS ROUTINE WRITES MESSAGE(S) TO THE OPERATOR. MESSAGE IS\n*  HIGHLIGHTED AND WILL STAY ON THE CONSOLE'S SCREEN UNTIL DELETED BY\n*  THE OPERATOR. THE PROGRAM IS INTENDED TO BE USED TO INFORM\n*  OPERATIONS ABOUT AN IMPORTANT CONDITION REQUIRING THEIR IMMEDIATE\n*  ATTENTION.\n*     MESSAGE TEXT CAN BE PASSED EITHER IN PARM FIELD OR IN SYSIN FILE.\n*  SYSIN FILE HAS TO HAVE 80 BYTES RECORDS. CONTENTS OF COLUMNS 1-72 OF\n*  EACH SYSIN RECORD IS WRITTEN AS SEPARATE \"WTO\" MESSAGE. THE ROUTINE\n*  WILL DISPLAY UP TO MAX OF 10 RECORDS FROM SYSIN IN ORDER TO AVOID\n*  FLOODING OF THE OPERATOR CONSOLE WITH MESSAGES FROM PROBLEM\n*  PROGRAMS.  BOTH PARM AND SYSIN INPUTS ARE OPTIONAL. IF BOTH ARE\n*  SPECIFIED, TEXT FROM PARM WILL BE DISPLAYED AS THE FIRST MESSAGE.\n*\n*    EACH WTO MESSAGE HAS JOB NAME PREFIXED TO IT.\n*\n*    THIS ROUTINE CAN BE EITHER INVOKED FROM JCL OR DYNAMICALLY THROUGH\n*  MEANS OF LINK OR LOAD/CALL MACROS. CALL FORMAT IS THE FOLLOWING :\n*\n*   CALL WTOH,(parm {,ddname}),VL\n*\n*        \"parm\" ARGUMENT HAS TO HAVE THE SAME FORMAT AS OS OPERATING\n*               SYSTEM STANDARD.\n*        \"ddname\" ARGUMENT IS OPTIONAL AND USER CAN SPECIFY IN IT\n*               DDNAME OF SYSIN MESSAGE INPUT FILE. SPECIFYING BLANK\n*               \"ddname\" PREVENTS WTOH FROM PROCESSING MESSAGE FILE\n*               AT ALL.\n*\n* SAMPLE EXECUTION FROM JCL :\n*\n*   //WTOH   PROC\n*   //WTOH   EXEC PGM=WTOH,PARM='&MSG.'\n*   //       PEND\n*   //       EXEC WTOH,MSG='UPDATE OF \"PRODUCE\" MASTER FILE FAILED'\n*   //SYSIN    DD *\n*   IDENTIFY AND CORRECT THE ERRORS AND DO THE RERUN PROCEDURE\n*   /*\n*\n* WRITTEN BY: Janek JAKUBEK, OGL\n*             FEBRUARY  1985\n*\n* CHANGE ACTIVITY:\n*                 NONE\n*\n*        PRINT NOGEN\nWTOH     CSECT\nWTOH     AMODE 24\nWTOH     RMODE 24\n         SAVE  (14,12)            SAVE REGISTERS\n         USING WTOH,R15\n         SPACE\n* REGISTERS EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\n*   BITS EQUATES\nBIT0     EQU   X'80'\nBIT1     EQU   X'40'\nBIT2     EQU   X'20'\nBIT3     EQU   X'10'\nBIT4     EQU   X'08'\nBIT5     EQU   X'04'\nBIT6     EQU   X'02'\nBIT7     EQU   X'01'\n         CNOP  0,4                ALIGNEMENT ON A FULLWORD BOUNDARY\n         BAL   WRKR1,WTOHSAE      SET SAVE AREA ADDRESS\nWTOHSA   DS    18F                SAVE AREA\nWTOHSAE  ST    R13,WTOHSA+4       CHAIN\n         ST    WRKR1,8(R13)       SAVE AREAS\n         LR    R13,WRKR1          CURRENT SAVE AREA\n         DROP  R15\n         USING WTOHSA,R13         PROGRAM BASE REGISTER\n         SPACE\nWRKR1    EQU   R2\nWRKR2    EQU   R3\nWRKR3    EQU   R4\nTIOTR    EQU   R5\nLNKREG   EQU   R6\n         SPACE\n*  CHECK IF SYSIN DDNAME SPECIFIED\n         SPACE\n         MVC   SYSIN+40(8),DDNSYSIN DEFAULT SYSIN DDNAME INTO DCB\n         USING PARMLST,R1\n         TM    PARMA,BIT0         LAST ENTRY IN PARM LIST.............?\n         BO    NODDN              YES, NO DDNAME SPECIFICATION-------->\n         L     WRKR1,DDNAMEA      DDNAME ADDRESS\n         MVC   SYSIN+40(8),0(WRKR1) CHANGE DDNAME IN DCB\nNODDN    L     WRKR1,PARMA        PARM ADDRESS\n         DROP  R1\n         SPACE\n* GET JOB NAME AND PUT IT INTO MESSAGE TEXT\n         SPACE\n         EXTRACT TIOTA,'S',FIELDS=(TIOT) EXTRACT JOB NAME INFO\n         L     TIOTR,TIOTA        TIOT ADDRESS\n         USING TIOT,TIOTR         TIOT ADDRESSABILITY\n         MVC   MSGJN,JOBN         MOVE JOB NAME INTO MESSAGE TEXT\n         SPACE\n* PARM FIELD PROCESSING\n         SPACE\n         MVI   FRAME,X'00'        NO MESSAGE FRAME\n         USING PARM,WRKR1\n         MVC   MSGL,PLEN          MOVE TO HALFW.IF NOT ON HALFW.BNDRY\n         LH    WRKR2,MSGL         PARM FIELD LENGTH\n         LTR   WRKR2,WRKR2        IS PARM SPECIFIED ..................?\n         BZ    SYSINP             NO, GOTO SYSIN PROCESSING----------->\n         LA    WRKR3,MSGT(WRKR2)  ADDRESS OF DESCRIPTOR CODES\n         MVC   0(2,WRKR3),DESCDE  MOVE DESCRIPTOR CODES AFTER MSG TEXT\n         MVC   2(2,WRKR3),ROUTCDE MOVE ROUTING CODES AFTER MSG DESCDE\n         BCTR  WRKR2,0            PARM LENGTH - 1\n         EX    WRKR2,MVCPARM      MOVE PARM INTO MESSAGE TEXT\n         LA    WRKR2,14(0,WRKR2)  MESSAGE LENGTH\n         STH   WRKR2,MSGL         COMPLETE LIST WTOH\n         BAL   LNKREG,MSGFRAME    START OF MESSAGE FRAME\n         WTO   MF=(E,MSG)         WRITE MESSAGE\n         SPACE\n* SYSIN PROCESSING\n         SPACE\nSYSINP   DS    0H\n         CLI   SYSIN+40,X'40'     BLANK DDNAME         ...............?\n         BE    RET                YES, DO NOT PROCESS MESSAGE FILE---->\n         RDJFCB MF=(E,SYSINOPN)   READ JFCB MACRO\n         LTR   R15,R15            JFCB READ SUCCESSFULLY..............?\n         BNZ   RET                NO, SYSIN DD NOT SPECIFIED---------->\n         OPEN  MF=(E,SYSINOPN)    OPEN SYSIN\n         LA    WRKR1,10           MAX NO. OF MESSAGES IN SYSIN\nGETMSG   GET   SYSIN,MSGT         GET MESSAGE RECORD\n         LA    WRKR2,71           CHECK OF MESSAGE TEXT LENGTH\nCHKMSGL  LA    WRKR3,MSGT(WRKR2)  LAST MSG CHAR ADDDRESS\n         CLI   0(WRKR3),X'40'     BLANK                ...............?\n         BNE   WTOHMSG            NO, LAST CHAR OF MESSAGE------------>\n         BCT   WRKR2,CHKMSGL      CHECK NEXT CHARACTER\nWTOHMSG  LA    WRKR2,14(0,WRKR2)  MESSAGE LENGTH\n         STH   WRKR2,MSGL         INTO WTOH LIST\n         LA    WRKR3,MSGL(WRKR2)  ADDRESS OF DESCRIPTOR CODES\n         MVC   0(2,WRKR3),DESCDE  MOVE DESCRIPTOR CODES AFTER MSG TEXT\n         MVC   2(2,WRKR3),ROUTCDE MOVE ROUTING CODES AFTER MSG DESCDE\n         CLI   FRAME,X'00'        START OF MESSAGE FRAME DONE.........?\n         BNE   WTOHMSG1           YES, DON'T DO IT AGAIN-------------->\n         BAL   LNKREG,MSGFRAME    START OF MESSAGE FRAME\nWTOHMSG1 WTO   MF=(E,MSG)         WRITE MESSAGE\n         BCT   WRKR1,GETMSG       GET NEXT MESSAGE RECORD\n         SPACE\nEOF      CLOSE (SYSIN)\nRET      CLI   FRAME,X'00'        START OF MESSAGE FRAME DONE.........?\n         BE    RET1               NO, NO END OF FRAME NECESSARY------->\n         BAL   LNKREG,MSGFRAME    END OF MESSAGE FRAME\nRET1     L     R13,WTOHSA+4       PREVIOUS SAVE AREA ADDRESS\n         RETURN (14,12),RC=0\n         SPACE\nMVCPARM  MVC   MSGT(1),PFLD       MOVE PARM FIELD INTO MSG TEXT\n         SPACE\nMSGFRAME DS    0H                 WTO MESSAGE FRAME\n         CLI   FRAME,X'FF'        START OF FRAME ALREADY DONE.........?\n         BE    MSGFRME1           YES, WRITE END OF FRAME------------->\n         WTO   '*******************************************************+\n               ****************',ROUTCDE=(2),                          +\n               DESC=(6)                               START OF FRAME\n         MVI   FRAME,X'FF'        START OF MESSAGE FRAME FLAG\n         BR    LNKREG             RETURN TO CALLER\nMSGFRME1 DS    0H                 END OF MESSAGE FRAME\n         WTO   '* * * * * * * * * * * * * * * * * * * * * * * * * * * *+\n                * * * * * * * *',ROUTCDE=(2),                          +\n               DESC=(6)                               END OF FRAME\n         BR    LNKREG             RETURN TO CALLER\n         SPACE\nDDNSYSIN DC    CL8'SYSIN'         DEFAULT SYSIN DDNAME\nMSG      DS    0F                 WTO LIST FORM\nMSGL     DS    H                  MESSAGE LENGTH\nMCSF     DC    B'1000000000000000' MCS FLAGS\nMSGJN    DS    CL8                JOB NAME\n         DC    C' '\nMSGT     DS    CL104              MESSAGE TEXT\nFRAME    DS    XL1                FRAME OF MESSAGES FLAG\nDESCDE   DC    B'0000000000100000' DESC=(11)   DESCRIPTOR CODE\nROUTCDE  DC    B'0100000000000000' ROUTCDE=(2) ROUTING CODE\n         SPACE\nTIOTA    DS    F                  TIOT ADDRESS\n         SPACE\nSYSIN    DCB   DSORG=PS,MACRF=GM,DDNAME=SYSIN,EODAD=EOF,               +\n               RECFM=FB,LRECL=80,EXLST=JFCBEXL\n         SPACE\nJFCBEXL  DS    0F                 JFCB PROCESSING EXIT\n         DC    X'87',AL3(JFCBAREA)\n         SPACE\nJFCBAREA DS    0F,CL176\nSYSINOPN OPEN  (SYSIN,(INPUT)),MF=L OPEN SYSIN LIST FORM\n         SPACE\nPARMLST  DSECT                    PARAMETER LIST\nPARMA    DS    A                  PARM FIELD ADDRESS\nDDNAMEA  DS    A                  SYSIN DDNAME ADDRESS ( OPTIONAL )\n         SPACE\nTIOT     DSECT                    TASK INPUT OUTPUT TABLE\nJOBN     DS    CL8                JOB NAME\n         SPACE\nPARM     DSECT                    PARM FIELD LAYOUT\nPLEN     DS    H                  FIELD LENGTH\nPFLD     DS    CL100              PARM FIELD TEXT\n         END   WTOH\n/*\n//LINK    EXEC PGM=HEWL,PARM='MAP,LET,LIST,REUS'\n//SYSLIN    DD DSN=&&OBJECT,DISP=(OLD,DELETE)\n//SYSLMOD   DD DISP=SHR,DSN=...your.loadlib    <=== DESTINATION\n//SYSUT1    DD UNIT=SYSALLDA,SPACE=(CYL,(1,1))\n//SYSPRINT  DD SYSOUT=*\n//*\n//* Optional step to refresh LLA entry (if SYSLMOD is LLA managed)\n//*\n//* LINKLIST MEMBER\n//LLAUPDTX PROC LL=LL,LLAPDS='SYS1.LINKLIB'\n//* NON-LINKLIST MEMBER\n//*LLAUPDTX PROC LL=AA,LLAPDS='YOUR.LLA.DSNAME'\n//LLAUPDTX EXEC PGM=LLAUPDTX,PARM='&LL.&MEMBER.'\n//LLAPDS     DD DISP=SHR,DSN=&LLAPDS\n//SYSUDUMP   DD SYSOUT=D\n//         PEND\n//  EXEC LLAUPDTX,LL=LL,MEMBER=WTOH\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMIT": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x04\\x07\\x8f\\x01\\x04\\x07\\x8f\\x10\\x02\\x00\\x02\\x00\\x02\\x00\\x00\\xe2\\xe8\\xd4\\xd7\\xf1\\xf1\\xf8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-03-18T00:00:00", "modifydate": "2004-03-18T10:02:58", "lines": 2, "newlines": 2, "modlines": 0, "user": "SYMP118"}, "text": "XMIT CBT/FILE394 DATASET(SYMP118.CBT.FILE394)\nOUTDSN(SYMP118.CBT.FILE394.XMI)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT394/FILE394.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT394", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}