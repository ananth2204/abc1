{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011258000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE124.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE124.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x10'", "DS1TRBAL": "b'\\x1b\\xe4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xc9\\x00\\x03\\x00\\xc9\\x00\\x0c\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "\n      Here are some ISPF/PDF things we have created and used at\n   Wilson Street Regional Computing Center, Madison, Wisconsin.\n   They are currently working under ISPF/PDF V2 R3 M0.\n\n      NO WARRENTY IS GIVEN OR IMPLIED BY WSRCC.  NO LIABILITY\n      IS ASSUMED BY WSRCC FOR ANY OF THE CODE IN THIS FILE.\n\n\n      If you have questions about any of these you can call us:\n\n         Joe Martin  (608) 266-9525\n         Tom Jarvis  (608) 266-9391\n\n\n    A description of the members of this PDS:\n\n\n$$$DOC      -  This member.\n\nAUTH        -  MACRO, used by SPF (see below).  AUTH is used by\n               the SPF program to invoke SVC 233 to turn on and\n               off JSCB Authorization.\n\nBPPL        -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nEDPRD       -  ISREDIT macro to invoke the PRINTDS command for the\n               dataset being edited.  Uses the PDPANL panel to prompt\n               for options which are saved in the profile.  The macro\n               works against the disk version of the dataset so if\n               changes have been made the dataset must be \"SAVE\"ed\n               before invoking EDPRD.\n\nEDPRT       -  ISREDIT macro to invoke the PRINTOFF command for the\n               dataset being edited.  Uses the PRPANL panel to prompt\n               for options which are saved in the profile.  The macro\n               works against the disk version of the dataset so if\n               changes have been made the dataset must be \"SAVE\"ed\n               before invoking EDPRT.\n\nEDSCR       -  ISREDIT macro to invoke the SCRIPT command for the\n               dataset being edited.  Uses the SCPANL panel to prompt\n               for options which are saved in the profile.  The macro\n               works against the disk version of the dataset so if\n               changes have been made the dataset must be \"SAVE\"ed\n               before invoking EDSCR.\n\nENTERR      -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nGDGUTIL     -  ISPF CLIST which invokes several functions one might want\n               to do to a GDG.  Create, List index, List datasets Modify\n               limit and Delete.  Can be used from panel 6 or included\n               as a selection entry on another panel.  Uses GDGUTILP\n               panel and RESETGDG program to do the work.\n\nGDGUTILP    -  ISPF PANEL used by GDGUTIL, see above.\n\nIGC0023C    -  SVC 233.  This is a Nno-authorized type 3 SVC that\n               turns bits in the JSCB on or off based on an entry\n               code is register 1.  It is called by the AUTH Macro\n               which is used by the SPF program (see below).\n\nIKJCVT      -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nISR@PDOC    -  ISPF/PDF Primary Option Panel documentaion.\n\nISR@PRIM    -  ISPF/PDF Primary Option Panel as used by WSRCC.  See the\n               member ISR@PDOC for description.\n\nKPPL        -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nLEAVER      -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nMOVE        -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nPDPANL      -  Prompting panel for use with EDPRD macro.\n\nPRPANL      -  Prompting panel for use with EDPRT macro.\n\nPRT         -  3.4 PRINTOFF CLIST, same as J.PRT, also main member for\n               aliases PR1 and PR2 3.4 PRINTOFF CLISTs.\n\nPRTPNL00    -  Members selection list panel used by J.PRT, J.PR1, J.PR2,\n               and the 3.4 CLISTs PRT, PR1, and PR2.\n\nPR1 (ALIAS) -  3.4 PRINTOFF CLIST, uses same options as J.PR1\n\nPR2 (ALIAS) -  3.4 PRINTOFF CLIST, uses same options as J.PR2\n\nREGEQU      -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nRESETGDG    -  Program to reset the LIMIT on GDG's.  See program for\n               additional information.  Called by GDGUTIL clist.\n\nSCPANL      -  Prompting panel for use with SCPRT macro.\n\nSPF         -  WSRCC's preprocessor which allocates ISPF/PDF files\n               and invokes ISPF/PDF.\n\nSPFDOC      -  Documentation for WSRCC's ISPF/PDF PREPROCESSOR\n\nSTACK       -  STACK program as taken from CBT Tape 259 file 270,\n               used for ISPF/PDF XL (exit and logoff) and XLN (exit and\n               logon) options.\n\nSTACKDOC    -  STACK program documentation, also as taken from\n               CBT Tape Version 259, file 270.\n\nWPROFILE    -  Sample member for use by WSRCC ISPF/PDF Preprosessor,\n               allocates ISPF/PDF files as used by WSRCC Customer\n               rather than as WSRCC System's Programmer.\n\nWSRCCEP1    -  This panel is called by all of the J commands (except for\n               SET), it decodes the command's selection code into a full\n               data set name and invokes the WSRCEPCL CLIST to handel\n               the requested command.\n\n               Several datasets and selection codes are codded into\n               the WSRCCEP1 panel and do not need to be added to each\n               individual's selections, the are frequently used PDSs:\n\n                  Code         Library\n                   S1        SYS1.PROCLIB\n                   S2        SYS2.PROCLIB\n                   PA        SYS1.PARMLIB\n                   C2        SYS2.CLISTLIB\n                   TSO       SYS2.TSOPROCS\n                   STC       SYS2.STCPROCS\n\nWSRCCLPN    -  This panel is the J Jump command selection panel.\n               All of the command options are also added to the\n               ISR@PRIM primary panel so you do not need to enter\n               J infront of each option,  this panel is mainly used\n               to show which functions work with the data set name\n               selection codes.\n\nWSRCEPCL    - This is the main Jump command CLIST.  This CLIST is\n              called by all of the J panel options (except SET) and\n              it invokes all of the J panel commands.\n\nWSRCESET    -  Selection code and Data Set Name setting for J options.\n               This PANEL is called by option J.SET and it allows you to\n               set up selection codes and data set names and the\n               PRINTOFF options for PR1 and PR2.\n\nWSRCMDS     -  XSPLIT\n               This is an EXAMPLE of the entry in our ISPCMDS which\n               allows us to enter XSPLIT (abrv. XS) on any command line\n               and bring up a new Primary Option Panel (ISR@PRIM) on top\n               of the current ISPF/PDF screen.  You can then do any\n               ISPF/PDF (almost) options and when you are through you\n               enter =X and go back to the screen you entered the XSPLIT\n               on.  This works sort of like an extra SPLIT, but you\n               still only have 2 screens to swap between.\n\nWSRCPRTC    -  PDS MEMBER LIST, SELECT, AND PRINTOFF CLIST\n               This CLIST is used by other clists (WSRCEPCL, PRT, and\n               PRT's aliases) to display a pds member selection list and\n               then PRINTOFF each of the members selected.\n\nWTP         -  Macro taken from CBT Tape Version 259 file 270.\n               Used in assembly of STACK program.\n\nXABGN       -  Macro, used by SPF program to set up standard linkage\n               at the begining of the program.\n\nXAFIN       -  Macro, used by SPF program to exit and free up\n               work area getmained by XABGN.\n\nXL          -  EXIT ISPF AND LOGOFF CLIST\n               This small CLIST issues the STACK Command to stack\n               a LOGOFF command, it is called by option XL in\n               ISR@PRIM.\n\nXLN         -  EXIT ISPF AND LOGON CLIST\n               This small CLIST issues the STACK Command to stack\n               a LOGON command, it is called by option XLN in\n               ISR@PRIM.  The CLIST does a VGET for 2 variables,\n               XT1 and XT2.  X1 is the logon-id to be logged on\n               and XT2 (if specified) is an alternate logon proc\n               to be used.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTH": {"ttr": 520, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    AUTH  &P\n         AIF   ('&NAME' EQ '').START\n&NAME    DS    0H\n.START   AIF   ('&P' EQ '' OR '&P' NE 'ON').OFF\n         SR    1,1 .               LOAD AUTHORIZATION ON CODE\n         SVC   233 .               TURN AUTHORIZATION ON\n         MEXIT\n.OFF     LA    1,4 .               LOAD AUTHORIZATION OFF CODE\n         SVC   233 .               TURN AUTHORIZATION OFF\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BPPL": {"ttr": 522, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB1    BPPL   &DSECT\n         LCLC  &LAB2\n*\n*               PARAMETER LIST PASSED TO OPERSCAN SUBROUTINE :\n*\n         AIF   (T'&LAB1 NE 'O').LOK\n&LAB2    SETC  'BPPL'\n         AGO   .DSCK\n.LOK     ANOP\n&LAB2    SETC  '&LAB1'\n.DSCK    AIF   ('&DSECT' EQ 'DSECT').DSL\n         DS    0A\n&LAB2    DS    0XL44\n         AGO   .ADSL\n.DSL     ANOP\n&LAB2    DSECT\n.ADSL    ANOP\nBUFFPTR  DS    F                        BUFFER PTR (CBUF)\nLENPTR   DS    F                        LENGTH PTR (CBUF LEN)\nSTARTPTR DS    F                        START SEARCH PTR\nOPERPTR  DS    F                        NEXT OPER LOC\nOPLENPTR DS    F                        NEXT OPER LEN PTR\nSUBPTR   DS    F                        SUBFIELD PTR (PARENS INCLUDED)\nSUBLENPT DS    F                        SUBFIELD LEN PTR\nWORKPTR  DS    F                        WORK PTR (OPTIONAL 350 BYTES)\nOPDESCP  DS    F                        PTR TO OPERAND DESCRIPTOR\n         DS    F                        RESERVED (ZERO)\n*\nOPLEN    DS    H                        POINTED TO BY OPLENPTR\nSUBLEN   DS    H                        POINTED TO BY SUBLENPT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDPRD": {"ttr": 524, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 0\nCONTROL PROMPT\nISREDIT MACRO\nISREDIT (DSNAME) = DATASET\nISREDIT (MEMBER) = MEMBER\nIF &MEMBER EQ /*NULL*/ -\n   THEN SET &PRDSN = &STR('&DSNAME')\n   ELSE SET &PRDSN = &STR('&DSNAME(&MEMBER)')\nISPEXEC DISPLAY PANEL(PDPANL)\nISPEXEC VPUT (PDOPTS) PROFILE\nIF &RESPONSE EQ /* NULL */ THEN -\n   DO\n /*WRITE PRINTDS DA(&PRDSN) &PDOPTS*/\n /*WRITE*/\n   PRINTDS DA(&PRDSN) &PDOPTS\n   SET &CCODE = &LASTCC\n   SET &ZEDSMSG = &STR(PRINTDS ENDED RC=&CCODE)\n   SET &ZEDLMSG = &STR(PRINTDS ENDED WITH A RETURN CODE OF &CCODE)\n   END\nELSE DO\n   SET &ZEDSMSG = &STR(REQUEST CANCELLED)\n   SET &ZEDLMSG = &STR(EDPRD TERMINATED BY AN END OR RETURN COMMAND)\n   END\nISPEXEC SETMSG MSG(ISRZ000)\nISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDPRT": {"ttr": 526, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 0\nCONTROL PROMPT\nISREDIT MACRO\nISREDIT (DSNAME) = DATASET\nISREDIT (MEMBER) = MEMBER\nIF &MEMBER EQ /*NULL*/ -\n   THEN SET &PRDSN = &STR('&DSNAME')\n   ELSE SET &PRDSN = &STR('&DSNAME(&MEMBER)')\nISPEXEC DISPLAY PANEL(PRPANL)\nISPEXEC VPUT (PROPTS) PROFILE\nIF &RESPONSE EQ /* NULL */ THEN -\n   DO\n   WRITE PRINTOFF &PRDSN &PROPTS\n   WRITE\n   PRINTOFF &PRDSN &PROPTS\n   SET &CCODE = &LASTCC\n   SET &ZEDSMSG = &STR(ENDED RC=&CCODE)\n   SET &ZEDLMSG = &STR(PRINTOFF ENDED WITH A RETURN CODE OF &CCODE)\n   END\nELSE DO\n   SET &ZEDSMSG = &STR(REQUEST CANCELLED)\n   SET &ZEDLMSG = &STR(EDPRT TERMINATED BY AN END OR RETURN COMMAND)\n   END\nISPEXEC SETMSG MSG(ISRZ000)\nISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDSCR": {"ttr": 528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 0\nCONTROL PROMPT\nISREDIT MACRO\nISREDIT (DSNAME) = DATASET\nISREDIT (MEMBER) = MEMBER\nIF &MEMBER EQ /*NULL*/ -\n   THEN SET &SCDSN = &STR('&DSNAME')\n   ELSE SET &SCDSN = &STR('&DSNAME(&MEMBER)')\nISPEXEC DISPLAY PANEL(SCPANL)\nISPEXEC VPUT (SCOPTS) PROFILE\nIF &RESPONSE EQ /* NULL */ THEN -\n   DO\n   SCRIPT &SCDSN &SCOPTS\n   SET &CCODE = &LASTCC\n   SET &ZEDSMSG = &STR(ENDED RC=&CCODE)\n   SET &ZEDLMSG = &STR(SCRIPT ENDED WITH A RETURN CODE OF &CCODE)\n   END\nELSE DO\n   SET &ZEDSMSG = &STR(REQUEST CANCELLED)\n   SET &ZEDLMSG = &STR(EDSCR TERMINATED BY AN END OR RETURN COMMAND)\n   END\nISPEXEC SETMSG MSG(ISRZ000)\nISPEXEC CONTROL DISPLAY REFRESH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENTERR": {"ttr": 530, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB1    ENTERR  &SA=SAVEAREA,&WA=WORKAREA,&WL=WORKLEN,&LEVEL=,&R=,   XX\n               &CLEAR=NO\n         MNOTE ' CLEAR=&CLEAR,SA=&SA,WA=&WA,WL=&WL,LEVEL=&LEVEL'\n&LAB1    CSECT\n         SAVE  (14,12),,&LAB1-&LEVEL\n         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING\n         USING &LAB1,R12\n         LR    R10,R1             SAVE PARM PTR R10->PARM PTR\n         L     R0,=A(&WL)         R0=GET LENGTH\n         GETMAIN R,LV=(0)         R1->WORKAREA\n         LR    R11,R13            R11->CALLERS SAVEAREA\n         LR    R13,R1             R13->WORKAREA\n         USING &WA.,R13\n         AIF   ('&CLEAR' NE 'YES').NCLEAR\n         L     R15,=A(&WL)        R0=GET LENGTH\n         S     R15,=F'72'         SKIP REGS\n         MOVE  72(13),(15),0,0,PAD=X'00'\n.NCLEAR  ANOP\n         ST    R11,&SA.+4         SAVE HIS SAVEAREA PTR\n         LA    R13,&SA            R13->SAVEAREA (MINE)\n         ST    R13,8(,R11)        MINE IN HIS\n         LR    R11,R1             R11->WORKAREA IN CASE NOT SAME AS R13\n*                       WORKAREA ADDR IS STILL R13 FOR\n*                       THE ASSEMBLER - IF DIFFERENT FROM R13\n*                       THEN USE: DROP R13 AND USING &WA.,R11\n         LR    R1,R10             RESTORE PARM PTR PTR\n         AIF   ('&R' EQ 'NO').NRE\n         REGEQU\n.NRE     ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GDGUTIL": {"ttr": 532, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 0 DEBUG\nCONTROL END(DEND) NOPROMPT NOFLUSH\nATTN  OFF\nERROR OFF\n /* */\nDISPLAY: +\nISPEXEC DISPLAY PANEL(GDGUTILP)\nIF &LASTCC NE 0 THEN GOTO ALLDONE\nISPEXEC VGET (GDGPREF,K,G,DEBUG,ZCHARCNL,GNM)\n /* */\nIF &DEBUG = DEBUG THEN CONTROL   LIST   MSG   PROMPT SYMLIST CONLIST\n                  ELSE CONTROL NOLIST NOMSG NOPROMPT\nIF &K \u00ac= &STR(M) THEN DELETE '&SYSUID..GDGPRT.LIST'\n /* */\nSET GDGNAME = &GDGPREF\nIF &SUBSTR(1:1,&STR(&GDGPREF) ) = &STR(') THEN DO\n   SET GDGLENG = &EVAL(&LENGTH(&STR(&GDGPREF))-1)\n   SET GDGNAME = &SUBSTR(2:&GDGLENG,&GDGPREF )\n   DEND\n ELSE DO\n   SET GDGNAME = &SYSPREF..&GDGPREF\n   DEND\nSET GDGPREF = &STR('&GDGNAME')\n /* */\nFREE ATTR($L$C$P $G$R$O $G$R$I)\nSET SUF = &STR(&SUBSTR(1:2,&SYSJDATE)&SUBSTR(4:6,&SYSJDATE))\nATTR $L$C$P LRECL(125) BLKSIZE(9076) RECFM(V B A)\nALLOC DD(D&SUF.1) DS('&SYSUID..GDGPRT.LIST') REUSE US($L$C$P) +\n         MOD CAT SPACE(2,1) TRACK\n /* */\nSET ALL = &STR(GDG)\nIF &G = I THEN DO\n   SET &ALL = &STR(GDG ALL)\n   GOTO LSTGDG\n   DEND\nIF &G = L THEN DO\n   SET &ALL = &STR(ALL)\n   GOTO LSTGDG\n   DEND\nIF &G = M THEN DO\n   SET GDGENTL = &LENGTH(&STR(00&GNM))\n   SET GDGENTS = &STR(&SUBSTR(&EVAL(&GDGENTL-2):&GDGENTL,&STR(00&GNM)))\n   SET ACTION  = &STR(MODIFIED)\n   GOTO MODGDG\n   DEND\nIF &G = C THEN DO\n   SET GDGENTS = &STR(&GNM)\n   SET ACTION  = &STR(CREATED)\n   SET &ALL = &STR(GDG ALL)\n   GOTO BLDGDG\n   DEND\nIF &G = D THEN DO\n   SET GDGENTS = &STR(&GNM)\n   SET ACTION  = &STR(DELETED)\n   GOTO MODGDG\n   DEND\n /* */\nLSTGDG: +\nLISTC ENT(&GDGPREF) &ALL OUTFILE(D&SUF.1)\nSET CCND = &LASTCC\nIF &CCND > 0 THEN DO\n   SET &ZEDSMSG = &STR(GDG NOT FOUND)\n   SET &ZEDLMSG = &STR(THE GDGINDEX &GDGPREF WAS NOT FOUND RC=&CCND)\n   ISPEXEC SETMSG MSG(ISRZ000)\n   DEND\n ELSE DO\n   SET HCHARCNL = &ZCHARCNL\n   SET ZCHARCNL = NOCC\n   ISPEXEC VPUT (ZCHARCNL)\n   ISPEXEC BROWSE DATASET('&SYSUID..GDGPRT.LIST')\n   SET ZCHARCNL = &HCHARCNL\n   ISPEXEC VPUT (ZCHARCNL)\n   SET &ZEDSMSG = &STR(GDG WAS DISPLAYED)\n   SET &ZEDLMSG = &STR(THE GDGINDEX &GDGPREF WAS DISPLAYED RC=&CCND)\n   ISPEXEC SETMSG MSG(ISRZ000)\n   DEND\nIF &K = D THEN FREE DD(D&SUF.1) DELETE\n          ELSE FREE DD(D&SUF.1)\nGOTO DISPLAY\n /* */\nBLDGDG: +\nCONTROL MSG\nDEFINE GDG(NAME(&GDGPREF) LIMIT(&GNM) SCRATCH OWNER(&SYSUID))\nSET CCND = &LASTCC\nIF &DEBUG = DEBUG THEN CONTROL MSG\n                  ELSE CONTROL NOMSG\nIF &CCND > 0 THEN DO\n   SET &ZEDSMSG = &STR(GDG NOT &ACTION)\n   SET &ZEDLMSG = &STR(THE GDGINDEX &GDGPREF WAS NOT &ACTION RC=&CCND)\n   ISPEXEC SETMSG MSG(ISRZ000)\n   DEND\n ELSE DO\n   LISTC ENT(&GDGPREF) &ALL OUTFILE(D&SUF.1)\n   SET HCHARCNL = &ZCHARCNL\n   SET ZCHARCNL = NOCC\n   ISPEXEC VPUT (ZCHARCNL)\n   ISPEXEC BROWSE DATASET('&SYSUID..GDGPRT.LIST')\n   SET ZCHARCNL = &HCHARCNL\n   ISPEXEC VPUT (ZCHARCNL)\n   SET &ZEDSMSG = &STR(GDG WAS &ACTION)\n   SET &ZEDLMSG = &STR(THE GDGINDEX &GDGPREF WAS &ACTION RC=&CCND)\n   ISPEXEC SETMSG MSG(ISRZ000)\n   DEND\nGOTO DISPLAY\n /* */\nMODGDG: +\nLISTC ENT(&GDGPREF) &ALL OUTFILE(D&SUF.1)\nSET CCND = &LASTCC\nIF &CCND > 0 THEN DO\n   SET &ZEDSMSG = &STR(GDG NOT FOUND)\n   SET &ZEDLMSG = &STR(THE GDGINDEX &GDGPREF WAS NOT FOUND RC=&CCND)\n   ISPEXEC SETMSG MSG(ISRZ000)\n   DEND\n ELSE DO\n   SET BLANKS = &STR(                                                  )\n   SET GDGWRK = &STR(&SUBSTR(1:45,&STR(&GDGNAME.&BLANKS))&STR(&GDGENTS))\n   SET HCHARCNL = &ZCHARCNL\n   SET ZCHARCNL = NOCC\n   ISPEXEC VPUT (ZCHARCNL)\n   FREE DD(D&SUF.1) DELETE\n   ATTR $G$R$O LRECL(133) BLKSIZE(9044) RECFM(F B M)\n   ATTR $G$R$I LRECL(80) BLKSIZE(80) RECFM(F B)\n   ALLOC DD(GDGOUT) DS('&SYSUID..GDGPRT1.LIST') REUSE US($G$R$O) +\n         MOD CAT SPACE(2,1) TRACK\n   ALLOC DD(GDGIN) DS('&SYSUID..GDGIN.DATA') REUSE US($G$R$I) +\n         NEW DEL SPACE(1) TRACK\n   ALLOC DD(SYSPRINT) DS('&SYSUID..GDGPRT2.LIST') REUSE US($L$C$P) +\n         MOD CAT SPACE(2,1) TRACK\n   OPENFILE  GDGIN OUTPUT\n   SET GDGIN = &STR(&GDGWRK)\n   PUTFILE GDGIN\n   CLOSFILE GDGIN\n   CALL 'SYS2.TECHSUP.LOAD(RESETGDG)'\n   ISPEXEC BROWSE DATASET('&SYSUID..GDGPRT1.LIST')\n   ISPEXEC BROWSE DATASET('&SYSUID..GDGPRT2.LIST')\n   SET ZCHARCNL = &HCHARCNL\n   ISPEXEC VPUT (ZCHARCNL)\n   FREE DD(D&SUF.3) DELETE\n   SET &ZEDSMSG = &STR(GDG WAS &ACTION)\n   SET &ZEDLMSG = &STR(THE GDGINDEX &GDGPREF WAS &ACTION RC=&CCND)\n   ISPEXEC SETMSG MSG(ISRZ000)\n   DEND\nFREE DD(GDGIN) DELETE\nIF &K = D THEN FREE DD(GDGOUT SYSPRINT) DELETE\n          ELSE FREE DD(GDGOUT SYSPRINT)\nALLOC DD(SYSPRINT) DS(*) REUSE\nGOTO DISPLAY\n /* */\nALLDONE: +\nFREE ATTR($L$C$P $G$R$O $G$R$I)\nISPEXEC VPUT (GDGPREF,K,G,DEBUG,ZCHARCNL,GNM)\nISPEXEC  CONTROL DISPLAY REFRESH\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GDGUTILP": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "%----------------------- Generation Data Group Utility -------------------------\n% Command ===>_ZCMD\n%\n+\n% GDG PREFIX ===>_GDGPREF                            +(35 chars maximum)\n+\n%  SELECTION ===>_G+\n+\n+                %I+- List the GDG%Index+entry information.\n+                %L+-%List+the GDG Datasets with VOLSER information.\n+                %C+-%Create+a GDG index.  Specify the entries below.\n+                %M+-%Modify+the number of GDG dataset entries to be kept.\n+                     GDG entries to be kept (2-255)%===>_GNM+\n+                %D+-%Delete+the GDG Index and%Uncatalog+(but not delete) any\n+                     datasets that currently are catalogued under this GDG.\n+\n+\n% LIST Data Set Disposition  ===>_K+ (K-keep|D-delete|M-mod) +\n+      '&ZUSER..GDGPRT.LIST'\n+\n+\n+Press the %ENTER KEY+to proceede or the%END KEY+to terminate this panel+_DEBUG\n\n)INIT\n .CURSOR = GDGPREF\n &G = I\n &GNM = &Z\n IF (&K = &Z)\n   &K = D\n)PROC\n  VER (&GDGPREF,NONBLANK)\n  VER (&GDGPREF,DSNAME)\n  VER (&K,NONBLANK)\n  VER (&K,LIST,K,D,M)\n  VER (&G,NONBLANK)\n  VER (&G,LIST,C,D,I,L,M)\n  IF (&G = 'M')\n     VER (&GNM,NONBLANK)\n     VER (&GNM,NUM)\n     VER (&GNM,RANGE,2,255)\n  IF (&G = 'C')\n     VER (&GNM,NONBLANK)\n     VER (&GNM,NUM)\n     VER (&GNM,RANGE,2,255)\n  IF (&G = 'D')\n     &GNM = 'DLX'\n VPUT (GDGPREF G K GNM DEBUG) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IGC0023C": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*          DATA SET IGC0023C   AT LEVEL 001 AS OF 03/31/81\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00001\n*                                                                     * 00002\n*  ----------------------S V C   2 3 3 -----------------------------  * 00003\n*  SETJSCB - A NON-AUTHORIZED TYPE 3 SVC THAT TURNS THE JSCB          * 00004\n*  AUTHORIZATION ON OR OFF BASED ON THE ENTRY CODE IN REGISTER 1.     * 00005\n*                                                                     * 00006\n*  ENTRY CODE = 0 - TURN JSCB AUTHORIZATION ON                        * 00007\n*  ENTRY CODE = 4 - TURN JSCB AUTHORIZATION OFF                       * 00008\n*                                                                     * 00009\n*  CODED 3/18/76 BY J. W. RICH (FROM R. MARKEL).                      * 00010\n*  MODED 3/31/81 BY J. A. MARTIN - W.S.R.C.C                          * 00011\n*        ADDED CHECK FOR R1=0 OR R1=4 => SDUMP IF NOT GOOD R1         * 00012\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00013\nIGC0023C CSECT                                                          00014\n         USING *,R6                BASE REGISTER                        00015\n         L     R12,PSATOLD         LOAD CURRENT TCB PTR                 00016\n         L     R12,TCBJSCB(0,R12)  LOAD JSCB PTR                        00017\n         LTR   R1,R1                    CHECK IF ZERO                   00018\n         BZ    DOIT                     R1=0 IS OK - GO DO IT           00019\n         C     R1,F4                    CHECK IF FOUR                   00020\n         BE    DOIT                     R1=4 IS OK - GO DO IT           00021\n         SDUMP HDR='IGC0023C ERROR R1 \u00ac= 0 OR 4 - WSRCC LOCAL SVC'      00022\n         SR    R1,R1                    SET OFF AUTH                    00023\nDOIT     EX    R0,APFON(R1)        \"EX\"ECUTE APFON OR APFOFF BASED      00024\n*                                       ON REGISTER 1 ENTRY CODE        00025\n         BR    R14                 RETURN                               00026\n         EJECT                                                          00027\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00028\n*  VARIOUS AND SUNDRY \"EX\"ECUTED INSTRUCTIONS                         * 00029\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00030\nAPFON    OI    JSCBOPTS(R12),JSCBAUTH        TURN ON AUTHORIZATION      00031\nAPFOFF   NI    JSCBOPTS(R12),X'FF'-JSCBAUTH  TURN OFF AUTHORIZATION     00032\n         EJECT                                                          00033\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00034\n*  VARIOUS AND SUNDRY EQUATES                                           00035\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* 00036\nF4       DC    F'04'               USED TO COMPARE TO R1                00037\nJSCBAUTH EQU   X'01'               JSCB AUTHORIZATION BIT               00038\nPSATOLD  EQU   X'21C'              OFFSET TO TCBOLD PTR                 00039\nTCBJSCB  EQU   X'B4'               OFFSET TO JSCB PTR                   00040\nJSCBOPTS EQU   X'EC'               OFFSET TO JSCB AUTHORIZATION FIELD   00041\nR0       EQU   0                   REGISTER 0                           00042\nR1       EQU   1                   REGISTER 1                           00043\nR6       EQU   6                   REGISTER 6                           00044\nR12      EQU   12                  REGISTER 12                          00045\nR14      EQU   14                  REGISTER 14                          00046\n         END                                                            00047\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IKJCVT": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&N       IKJCVT\nCVTPTR   EQU   16\nCVTMAP   DSECT\n         ORG   CVTMAP+480\nCVTSCAN  DS    F\n         ORG   CVTMAP+524\nCVTPARS  DS    F\n         ORG   CVTMAP+732\nCVTDAIR  DS    F\nCVTEHDEF DS    F\nCVTEHCIR DS    F\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISR@PDOC": {"ttr": 775, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "ISR@PRIM    -  ISPF/PDF Primary Option Panel\n\n                J - Jump commands, allows you to quickly Edit, Browse,\n                    and PRINTOFF frequently used data sets and PDS\n                    members.  All of the options offered under J should\n                    also be added to the ISR@PRIM panel.  Option J is\n                    just used as a way of putting them together in a\n                    group.\n\n                U - USERPANL,  Our ISPF/PDF preprocessor allocates the\n                    user's panel libraries (if any) before the ISPF/PDF\n                    panel libraries.  This option gives our users a way\n                    into their panels without their needing their own\n                    ISR@PRIM panel.  The users only have to create a\n                    panel named USERPANL and have all of their panels\n                    accessable thru it.  This allows us to update\n                    ISR@PRIM without the customer being affected.\n\n          XL, XLN - Exit-and-logoff, and Exit-and-logon.\n                    Also in the INIT section of ISR@PRIM is some code\n                    which allows the XL and XLN options to work.  A\n                    varaible &WEI is checked for the value 'G', if it is\n                    set then a command to be executed is stored in\n                    another variable &HOPT.  When &WEI is set to 'G' the\n                    &ZCMD is set to the command in &HOPT, &WEI is set to\n                    'N' and the .RESP is set to ENTER so the command\n                    will get executed.  In the PROC section the variable\n                    &OROPT is set to the truncated value of &ZCMD.  If\n                    the command entered is XL or XLN the command of 'X'\n                    is stored in &HOPT and &WEI is set to 'G' so that an\n                    exit will be executed on return from the options XL\n                    and XLN's CLISTs.\n\n      The following options are not described on the Primary panel but\n      are valid options:\n\n                E -  WSRCC User Library Edit.  By setting up a selection\n                     list the user can quickly edit (with the ISPF/PDF\n                     Editor) any dataset or member of a PDS within the\n                     selection list by simply entering E.DS where DS is\n                     the selection code assigned to a dataset or PDS\n                     thru the selection list.  If DS is a PDS you can\n                     edit a member of it by entering E.DS.member, or get\n                     a member list by E.DS, or a selected member list be\n                     E.DS.a* (to get all members starting with the\n                     letter A).  If the dataset specified by DS is not\n                     cataloged you can specify the VOLUME by entering\n                     E.DS.member.VOLUME, if you want a member selection\n                     list you specify it as E.DS.*.VOLUME.\n\n                B -  WSRCC User Library Browse. B uses the same\n                     selection list that is set up for Edit, see above,\n                     only the function is Browse.\n\n              PRT -  WSRCC User Library PRINTOFF.  This uses the same\n                     selection list that is set up for Edit, see above,\n                     only the function is PRINTOFF.  Before the dataset\n                     is printed a PRINTOFF Options selection panel is\n                     displayed so desired options can be specified.  If\n                     the dataset is a PDS and no member has been\n                     specified (or a selected member list was specified)\n                     you get a member selection list, after\n                     selecting members and hitting \"END\" each member\n                     is printed.\n\n              PR1 -  This option also does a PRINTOFF as above but the\n                     PRINTOFF options are pre selected and stored by\n                     the J.SET option.\n\n              PR2 -  This option is the same as above but with a\n                     different set of PRINTOFF options, also set and\n                     stored by the J.SET option.\n\n          NEWUSER -  In the INIT section of the ISR@PRIM is a\n                     check for a NULL value for the variable &NU.\n                     If the variable is NULL then the ZCMD is set\n                     to the option NEWUSER and .RESP is set to ENTER.\n                     This forces all NEW users to go thru our NEW USER\n                     CLIST which sets up JOB cards.  The variable &NU is\n                     set by our CLIST and stored in the users profile so\n                     they only go thru it once.  The code is commented\n                     out in the panel.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISR@PRIM": {"ttr": 778, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR\n  \u00a2 TYPE(OUTPUT)\n)BODY LMSG(LMF)\n%-----------  Wilson Street Regional Computing Center  -----------------&WL-----\n%               \u00a2LMF\n%COMMAND ===>_ZCMD\n%                                                           +USERID   - &ZUSER\n% 0 +ISPF PARMS  - Specify terminal and user parameters     +TIME     - &ZTIME\n% 1 +BROWSE      - Display source data or output listings   +DATE     - &ZDATE\n% 2 +EDIT        - Create or change source data                       - &ZJDATE\n% 3 +UTILITIES   - Perform utility functions                +TERMINAL - &ZTERM\n% 4 +FOREGROUND  - Invoke language processors in foreground +PF KEYS  - &ZKEYS\n% 5 +BATCH       - Submit Job for Language Processing\n% 6 +COMMAND     - Enter TSO command or CLIST\n% 7 +DIALOG TEST - Perform dialog testing\n% 9 +Changes     - Summary of changes to ISPF\n% J +J Commands  - Jump Commands, E, B, PRT, PR1, and PR2\n% T +TUTORIAL    - Display information about ISPF/PDF\n% U +User panel  - User defined panel\n% W +WSRCC       - Local WSRCC TSO utilities\n% X +EXIT        - Terminate ISPF using log and list defaults\n+        %&NEWS\n+Enter%END+command to terminate ISPF.\n)INIT\n  .HELP = ISR00003\n  &ZPRIM = YES        /* ALWAYS A PRIMARY OPTION MENU      */\n  &ZHTOP = ISR00003   /* TUTORIAL TABLE OF CONTENTS        */\n  &ZHINDEX = ISR91000 /* TUTORIAL INDEX - 1ST PAGE         */\n  &WL = TRUNC (&ZENVIR,8)\n  &NEWS = &Z\n  &LMF = 'ISPF/PDF V2 PRIMARY OPTION MENU'\n /* ************************************************************* */\n /*                                                               */\n /* IF (&NU = &Z)              /* If this is a new user then      */\n /*    &ZCMD = 'NEWUSER'       /*  force him thru the newuser     */\n /*    .RESP = ENTER           /*  panels. If not a new user ...  */\n /*      NOTE: &NU is set and saved in profile by NEWUSER option. */\n /*                                                               */\n /*                                                               */\n    IF (&WEI = 'G')            /* If &WEI = 'G' then there may be */\n       IF (&HOPT \u00ac= &Z)        /* a command in &HOPT to execute,  */\n          &ZCMD = &HOPT        /*  If there is set ZCMD to it and */\n          &WEI  = 'N'          /*  set &wei (no work), and        */\n          .RESP = ENTER        /*  set resp to do the command.    */\n /*                                                               */\n /* ************************************************************* */\n  VPUT (ZHTOP,ZHINDEX) PROFILE\n)PROC\n  &OROPT = TRUNC(&ZCMD,'.')\n  IF (&OROPT = XL)\n     &WEI = G\n     &HOPT = X     /* 'X'  Exit to be executed on return from XL  */\n  IF (&OROPT = XLN)\n     &WEI = G\n     &HOPT = X     /* 'X'  Exit to be executed on return from XLN */\n     &XT1 = .TRAIL /* XT1 is userid to be logged on               */\n     &ZCMD = XLN\n     IF (&XT1 \u00ac= &Z)\n       &XT1 = TRUNC(&XT1,'.')\n       &XT2 = .TRAIL /* XT2 is proc name to be used in logon      */\n     IF (&XT1 = &Z)\n       &XT1 = &ZUSER  /* If no user specified log use same id     */\n       &XT2 = &Z\n  &ZTRAIL = .TRAIL\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                0,'PANEL(ISPOPTA)'\n                1,'PGM(ISRBRO) PARM(ISRBRO01)'\n                2,'PGM(ISREDIT) PARM(P,ISREDM01)'\n                3,'PANEL(ISRUTIL)'\n                4,'PANEL(ISRFPA)'\n                5,'PGM(ISRJB1) PARM(ISRJPA) NOCHECK'\n                6,'PGM(ISRPTC)'\n                7,'PGM(ISRYXDR) NOCHECK'\n                8,'PANEL(ISRLPRIM)'\n                9,'PGM(ISPTUTOR) PARM(ISR00005)'\n                B,'PANEL(WSRCCEP1)'\n                E,'PANEL(WSRCCEP1)'\n                J,'PANEL(WSRCCLPN)'\n              NEWUSER,'CMD(%WSRCNUSR)' /* to set up job cards */\n              PDS,'PANEL(WSRCCEP1)'\n              PRT,'PANEL(WSRCCEP1)'\n              PR1,'PANEL(WSRCCEP1)'\n              PR2,'PANEL(WSRCCEP1)'\n                T,'PGM(ISPTUTOR) PARM(ISR00000)'\n                U,'PANEL(USERPANL)'\n                W,'PANEL(WSRCCMAN)'\n              ' ',' '\n                X,'EXIT'\n               XL,'CMD(%XL)'  /* exit and logoff, XL stacks logoff */\n              XLN,'CMD(%XLN)' /* exit and logon, XLN stacks logon  */\n                *,'?' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "KPPL": {"ttr": 781, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB1    KPPL   &DSECT\n         LCLC  &LAB2\n*\n*               PARAMETER LIST PASSED TO KMDPARS (10 FULLWORDS):\n*\n         AIF   (T'&LAB1 NE 'O').LOK\n&LAB2    SETC  'KPPL'\n         AGO   .DSCK\n.LOK     ANOP\n&LAB2    SETC  '&LAB1'\n.DSCK    AIF   ('&DSECT' EQ 'DSECT').DSL\n         DS    0A\n&LAB2    DS    0XL40\n         AGO   .ADSL\n.DSL     ANOP\n&LAB2    DSECT\n.ADSL    ANOP\nCBUFPTR  DS    F                        CMDBUF TO BE PARSED\nOPLSTPTR DS    F                        LIST OF OPERANDS TO FLAG\nFLAGPTR  DS    F                        WHERE TO FLAG THEM\nUNKNEXIT DS    F                        EXIT TO CALL IF UNKNOWN OPER\nEXITPARM DS    F                        PARAMETER TO PASS EXITS (ADDR)\n*                                       (R1 POINTS HERE AT EXIT ENTRY)\nBPPLPASS DS    F                        BPPL PTR WHEN EXIT GETS CONTROL\nWORKPASS DS    F                        OPTIONAL WORKAREA (512 BYTES)\nKEYLPASS DS    F                        LIST OF KEYWORD OPERANDS\nKEYWPASS DS    F                        WORKAREA FOR KEYWORD PROCESSOR\nREEXPASS DS    F                        ADDRESS OF REAL UNKNOWN EXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LEAVER": {"ttr": 783, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB     LEAVER &WR=R13,&WL=WORKLEN\n&LAB     LR    R1,&WR             WORKAREA ADDR FOR FREEMAIN\n         L     R0,=A(&WL)         WORKAREA LEN   \"    \"\n         L     R13,4(R13)         GET CALLERS SAVEAREA ADDR\n         LR    R11,R15            SAVE RETURN CODE\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R11            RESTORE RETURN CODE\n         RETURN (14,12),RC=(15)\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MOVE": {"ttr": 785, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&L1      MOVE  &TO,&TL,&FROM,&FL,&PAD=\n         LCLA  &NL,&UL,&VL\n         LCLC  &TO$,&TL$,&FROM$,&FL$\n&TO$     SETC  '&TO'\n&TL$     SETC  '&TL'\n&FROM$   SETC  '&FROM'\n&FL$     SETC  '&FL'\n         AIF   ('&TO'(1,1) NE '(').TLC\n&TO$     SETC  '0&TO'\n.TLC     AIF   ('&TL'(1,1) NE '(').FC\n&TL$     SETC  '0&TL'\n.FC      AIF   ('&FROM'(1,1) NE '(').FLC\n&FROM$   SETC  '0&FROM'\n.FLC     AIF   (T'&FL EQ 'O').OO\n         AIF   ('&FL'(1,1) NE '(').OO\n&FL$     SETC  '0&FL'\n.OO      ANOP\n&L1      STM   14,12,12(13)\n         LA    R2,&TO$\n         LA    R3,&TL$\n         LA    R4,&FROM$\n         AIF   (T'&FL EQ 'O').UTL\n         LA    R5,&FL$\n         AGO   .PC\n.UTL     LA    R5,&TL$\n.PC      AIF   ('&PAD' EQ '').NPC\n         ICM   R5,8,=&PAD\n.NPC     MVCL  R2,R4\n         LM    14,12,12(13)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDPANL": {"ttr": 787, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR\n \u00a6 TYPE(INPUT) INTENS(HIGH) CAPS(OFF)\n)BODY\n%---------------------------------- Printds ------------------------------------\n%OPTION  ===>\u00a6ZCMD                                                             +\n%\n+Enter operands for%PRINTDS+of%&PRDSN\n%===>\u00a6LOPER\n                                                                               +\n+Operands:  BMARGIN(lines)                     MEMBERS/DIRECTORY/ALL\n            CCHAR/SINGLE/DOUBLE/TRIPLE         MODIFY(module name,trc)\n            CHARS(charname, ...)               NUM(loc,len)/SNUM(loc,len)/NONUM\n            CLASS(c)                           OUTDES(descriptor name, ...)\n            COLUMNS(strt1:end1,strt2:end2,..)  PAGELEN(lines)\n            COPIES(nnn,(group value, ...))     TITLE/NOTITLE\n            DCF/NODCF                          TMARGIN(lines)\n            DEST(destname)                     TODATASET(dsn)/TODSNAME(dsn)\n            FCB(fcb name)                      TRC/NOTRC\n            FORMS(forms name)                  TRUNCATE(width)\n            HOLD/NOHOLD                        UCS(ucs name)\n            LINES(line-num1:line-num2)         WRITER(external writer name)\n            LMARGIN(columns)\n\n+Defaults:  ALL BMARGIN(0) CLASS(A) COPIES(1) DCF LMARGIN(0)\n            NOHOLD NONUM NOTRC PAGELEN(60) TITLE* TMARGIN(0)\n\n+Press the%ENTER+key to print or the%END+key to terminate without printing.\n)INIT\n .CURSOR=LOPER\n &LOPER=&PDOPTS\n &RESPONSE=&Z\n)PROC\n &PDOPTS='&LOPER'\n IF (.RESP = END)\n    &RESPONSE=.RESP\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRPANL": {"ttr": 789, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR\n \u00a6 TYPE(INPUT) INTENS(HIGH) CAPS(OFF)\n)BODY\n%---------------------------------- Printoff -----------------------------------\n%OPTION  ===>\u00a6ZCMD                                                             +\n%\n+Enter operands for%PRINTOFF+of%&PRDSN\n%===>\u00a6LOPER\n                                                                               +\n+Operands:  CLASS(c)           DEST(destname)     COPIES(num)\n            HOLD/NOHOLD        KEEP/DELETE        LIST/NOLIST\n            START(num)         STOP(num)          COUNT(num)\n            PRINT/NOPRINT      CAPS/ASIS          HEADING/NOHEADING\n            TITLE('title')     NOLINES/LINES(cnt) EJECT/NOEJECT(num)\n            DOUBLE             TRIPLE             PDS\n            FORMS(formname)    FCB(fcbname)       UCS(ucsname)\n            PROG(progname)     VOLUME(volname)    CCTL/CCTL(A/M)/NOCCTL\n            CHARS(cat1,cat2,cat3,cat4)            TRC(Y/N) ----------- 3800 ONLY\n            CGROUP(cg1,cg2,...cgn) ----------------------------------- 3800 ONLY\n\n+Defaults:  CLASS(A), COPIES(1), NOHOLD, LIST, PRINT, ASIS,\n            HEADING, KEEP, NOEJECT(4), NOLINES, DEST(local)\n\n+Press the%ENTER+key to print or the%END+key to terminate without printing.\n)INIT\n .CURSOR=LOPER\n &LOPER=&PROPTS\n &RESPONSE=&Z\n)PROC\n &PROPTS='&LOPER'\n IF (.RESP = END)\n    &RESPONSE=.RESP\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRT": {"ttr": 791, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 1 DSNM VOL()\nCONTROL MSG PROMPT END(DEND) NOLIST NOSYMLIST NOCONLIST\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n /*                                                             */\n /*  THIS CLIST (PRT) ALONG WITH THE ALIASES PR1 AND PR2 USE    */\n /*  THE SAME OPTIONS AS STORED BY J. PRT PR1 AND PR2.  THIS    */\n /*  IS FOR USE IN 3.4.                                         */\n /*                                                             */\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n ISPEXEC VGET (ZDLDSN ZDLVOL)  /* GET DSN AND VOLUME FROM 3.4 */\n  SET &VLM = /* NULL */\n  SET &DSNM = &SUBSTR(2:&EVAL(&LENGTH(&STR(&DSNM))-1),&STR(&DSNM))\n  IF &VOL NE /* NULL */ THEN -\n     SET &VLM = &STR(VOLUME(&VOL))\n  IF &VLM = /* NULL */  THEN -\n     SET &VLM = &STR(VOLUME(&ZDLVOL))\n  IF &STR(&DSNM) NE &STR(&ZDLDSN) THEN -\n    DO\n        SET &LD1 = &LENGTH(&STR(&ZDLDSN))                                 005778\n        SET &LD2 = &LENGTH(&STR(&DSNM))                                   005778\n       IF &SUBSTR(&LD2:&LD2,&STR(&DSNM)) EQ &STR()) THEN -\n         DO\n           SET &LD1 = &LD1 + 2\n           SET &LD2 = &LD2 - 1\n           SET &MBR = &SUBSTR(&LD1:&LD2,&STR(&DSNM))\n           SET &DSNM =  &STR(&ZDLDSN)\n         DEND\n    DEND\n  SET &DSNM =  &STR('&DSNM')\n  IF    &SYSICMD = PRT THEN -\n     DO\n        SET &PRDSN = &STR(&DSNM)\n        ISPEXEC DISPLAY PANEL(PRPANL)\n        IF &RESPONSE EQ &STR(END)  THEN EXIT\n        SET &PPARM = &PROPTS\n        ISPEXEC VPUT (PROPTS) PROFILE\n     DEND\n  IF    &SYSICMD = PR1 THEN -\n     DO\n        ISPEXEC VGET (WPR1)\n        SET &PPARM = &STR(&WPR1)\n     DEND\n  IF    &SYSICMD = PR2 THEN -\n     DO\n        ISPEXEC VGET (WPR2)\n        SET &PPARM = &STR(&WPR2)\n     DEND\n ISPEXEC VPUT (PPARM,VLM,DSNM,MBR) SHARED\n %WSRCPRTC\n  ISPEXEC CONTROL DISPLAY REFRESH\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRTPNL00": {"ttr": 793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)\n  | AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n  + TYPE(TEXT) INTENS(LOW)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) PAD(0)\n 01 TYPE(DATAIN) INTENS(HIGH) CAPS(ON)\n 02 TYPE(DATAOUT) INTENS(LOW)\n 03 TYPE(DATAIN)  INTENS(HIGH) CAPS(ON)\n 04 TYPE(DATAOUT)  INTENS(LOW)\n 05 TYPE(DATAOUT)  INTENS(HIGH)\n 06 TYPE(DATAOUT)  INTENS(LOW)\n)BODY WIDTH(80)\n%&ZDSN --&VLM---------------PRINTOFF------------------------%ROW\u00a2ZMLCR%OF\u00a2ZMLTR+\n%COMMAND ===>_ZCMD                                            %SCROLL ===>_Z   +\n SELECT MEMBERS, ENTER%'END'+TO PRINTOFF, ENTER%'CANCEL'+TO CANCEL PRINTOFF\n OPTIONS SPECIFIED:%&PPARM\n+\n&ZMLCOLS\n|ZDATA ------------------------------------------------------------------------|\n|                                                                              |\n| -----------------------------------------------------------------------------|\n)INIT\n  .ZVARS = 'ZSCML'         /* SCROLL AMT VARIABLE NAME  */\n  .HELP = ISR01130\n  VGET (PPARM VLM)\n  IF (&VLM EQ &Z)\n    &VL = '----'\n  ELSE\n    &VL = &VLM\n)PROC\n  &PENTR = &ZCMD\n  VPUT (PENTR) SHARED\n  VPUT (ZSCML) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PR1": {"ttr": 1026, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 1 DSNM VOL()\nCONTROL MSG PROMPT END(DEND) NOLIST NOSYMLIST NOCONLIST\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n /*                                                             */\n /*  THIS CLIST (PRT) ALONG WITH THE ALIASES PR1 AND PR2 USE    */\n /*  THE SAME OPTIONS AS STORED BY J. PRT PR1 AND PR2.  THIS    */\n /*  IS FOR USE IN 3.4.                                         */\n /*                                                             */\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n ISPEXEC VGET (ZDLDSN ZDLVOL)  /* GET DSN AND VOLUME FROM 3.4 */\n  SET &VLM = /* NULL */\n  SET &DSNM = &SUBSTR(2:&EVAL(&LENGTH(&STR(&DSNM))-1),&STR(&DSNM))\n  IF &VOL NE /* NULL */ THEN -\n     SET &VLM = &STR(VOLUME(&VOL))\n  IF &VLM = /* NULL */  THEN -\n     SET &VLM = &STR(VOLUME(&ZDLVOL))\n  IF &STR(&DSNM) NE &STR(&ZDLDSN) THEN -\n    DO\n        SET &LD1 = &LENGTH(&STR(&ZDLDSN))                                 005778\n        SET &LD2 = &LENGTH(&STR(&DSNM))                                   005778\n       IF &SUBSTR(&LD2:&LD2,&STR(&DSNM)) EQ &STR()) THEN -\n         DO\n           SET &LD1 = &LD1 + 2\n           SET &LD2 = &LD2 - 1\n           SET &MBR = &SUBSTR(&LD1:&LD2,&STR(&DSNM))\n           SET &DSNM =  &STR(&ZDLDSN)\n         DEND\n    DEND\n  SET &DSNM =  &STR('&DSNM')\n  IF    &SYSICMD = PRT THEN -\n     DO\n        SET &PRDSN = &STR(&DSNM)\n        ISPEXEC DISPLAY PANEL(PRPANL)\n        IF &RESPONSE EQ &STR(END)  THEN EXIT\n        SET &PPARM = &PROPTS\n        ISPEXEC VPUT (PROPTS) PROFILE\n     DEND\n  IF    &SYSICMD = PR1 THEN -\n     DO\n        ISPEXEC VGET (WPR1)\n        SET &PPARM = &STR(&WPR1)\n     DEND\n  IF    &SYSICMD = PR2 THEN -\n     DO\n        ISPEXEC VGET (WPR2)\n        SET &PPARM = &STR(&WPR2)\n     DEND\n ISPEXEC VPUT (PPARM,VLM,DSNM,MBR) SHARED\n %WSRCPRTC\n  ISPEXEC CONTROL DISPLAY REFRESH\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PR2": {"ttr": 1028, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 1 DSNM VOL()\nCONTROL MSG PROMPT END(DEND) NOLIST NOSYMLIST NOCONLIST\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n /*                                                             */\n /*  THIS CLIST (PRT) ALONG WITH THE ALIASES PR1 AND PR2 USE    */\n /*  THE SAME OPTIONS AS STORED BY J. PRT PR1 AND PR2.  THIS    */\n /*  IS FOR USE IN 3.4.                                         */\n /*                                                             */\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n ISPEXEC VGET (ZDLDSN ZDLVOL)  /* GET DSN AND VOLUME FROM 3.4 */\n  SET &VLM = /* NULL */\n  SET &DSNM = &SUBSTR(2:&EVAL(&LENGTH(&STR(&DSNM))-1),&STR(&DSNM))\n  IF &VOL NE /* NULL */ THEN -\n     SET &VLM = &STR(VOLUME(&VOL))\n  IF &VLM = /* NULL */  THEN -\n     SET &VLM = &STR(VOLUME(&ZDLVOL))\n  IF &STR(&DSNM) NE &STR(&ZDLDSN) THEN -\n    DO\n        SET &LD1 = &LENGTH(&STR(&ZDLDSN))                                 005778\n        SET &LD2 = &LENGTH(&STR(&DSNM))                                   005778\n       IF &SUBSTR(&LD2:&LD2,&STR(&DSNM)) EQ &STR()) THEN -\n         DO\n           SET &LD1 = &LD1 + 2\n           SET &LD2 = &LD2 - 1\n           SET &MBR = &SUBSTR(&LD1:&LD2,&STR(&DSNM))\n           SET &DSNM =  &STR(&ZDLDSN)\n         DEND\n    DEND\n  SET &DSNM =  &STR('&DSNM')\n  IF    &SYSICMD = PRT THEN -\n     DO\n        SET &PRDSN = &STR(&DSNM)\n        ISPEXEC DISPLAY PANEL(PRPANL)\n        IF &RESPONSE EQ &STR(END)  THEN EXIT\n        SET &PPARM = &PROPTS\n        ISPEXEC VPUT (PROPTS) PROFILE\n     DEND\n  IF    &SYSICMD = PR1 THEN -\n     DO\n        ISPEXEC VGET (WPR1)\n        SET &PPARM = &STR(&WPR1)\n     DEND\n  IF    &SYSICMD = PR2 THEN -\n     DO\n        ISPEXEC VGET (WPR2)\n        SET &PPARM = &STR(&WPR2)\n     DEND\n ISPEXEC VPUT (PPARM,VLM,DSNM,MBR) SHARED\n %WSRCPRTC\n  ISPEXEC CONTROL DISPLAY REFRESH\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGEQU": {"ttr": 1030, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         REGEQU\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RESETGDG": {"ttr": 1032, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*\n*      THIS PROGRAM IS USED WITH THE GDGUTIL CLIST AND THE\n*      GDGUTILP ISPF PANEL TO MODIFY THE NUMBER OF ENTRIES\n*      BEING KEPT FOR A GDG INDEX.\n*\n*      THIS CODE WAS DOWNLOADED FROM THE NASPA BULLETIN BOARD\n*      AND MODIFIED SLIGHTLY (DDNAMES AND WTO MSG) FOR USE\n*      AT THE WILSON STREET REGIONAL COMPUTING CENTER\n*             P.O. BOX 7850 - ROOM B174\n*             ONE WEST WILSON STREET\n*             MADISON, WI 53707-7850\n*\n*                      - J.MARTIN 4/26/89(608) 266-9525\n*\n*\n*      RESET # OF ENTRIES IN A GDG. INPUT EXISTING GDG NAME AT\n*      SYSIN. NAME IN COLS 1-44. NEW NUMBER OF ENTRIES IN COLS 46-48\n*      IN FORMAT NNN. ENTRIES MUST BE > 2 AND < 255. MULTIPLE\n*      RECORDS MAY BE INPUT. ANY ERROR WILL CAUSE FURTHER RECORDS\n*      TO NOT BE PROCESSED. ENTERING DLX IN ENTRIES FIELD WILL\n*      CAUSE INDEX TO BE DELETED.\n*\n*      THIS PROGRAM WILL HANDLE ONLY TWENTY VOLUMES PER DATA SET.\n*      IF THE DATA SET RESIDES ON MORE THAN 20 VOLUMES, ONLY\n*      THE FIRST 20 WILL BE RECATLOGED.\n*\n*      FOR SECURITY REASONS, YOU SHOULD FIRST LIST THE GDG\n*      YOU ARE PLANNING TO RESET.\n*\n*          EXECUTION JCL\n*\n*//RESET   EXEC PGM=RESETGDG\n*//STEPLIB  DD  DSN=AS.REQUIRED,DISP=SHR\n*//REPORT   DD  SYSOUT=*\n*//SYSPRINT DD  SYSOUT=*\n*//SYSUDUMP DD  SYSOUT=*\n*//SNAPPER  DD  SYSOUT=*\n*//SYSIN    DD  *\n*ABC.TEST.GDG                                 255\n*\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nRA       EQU   10\nR10      EQU   10\nRB       EQU   11\nR11      EQU   11\nRC       EQU   12\nR12      EQU   12\nRD       EQU   13\nR13      EQU   13\nRE       EQU   14\nR14      EQU   14\nRF       EQU   15\nR15      EQU   15\n***********************************************************************\n*                                                                     *\n*  RESET NUMBER OF ENTRIES IN A GDG  (MVS VERSION - OPERATES ON BOTH  *\n*   CVOLS AND VSAM/ICF CATALOGS)                                      *\n* ** WARNING ** AS OF YET, THIS PROGRAM WILL NOT HANDLE DATASETS      *\n*  RESIDING ON MORE THAN 20 VOLUMES. ONLY THE FIRST TWENTY VOLS       *\n*  WILL BE RECATALOGED.                                               *\n*                                                                     *\n*  THIS PROGRAM DOES NOT SCRATCH DISK DATASETS AS IT UNCATALOGES THEM *\n*                                                                     *\n***********************************************************************\n         EJECT\nRESETGDG CSECT\n         SAVE  (14,12),,RESETGDG&SYSDATE&SYSTIME\n         LR    R12,R15\n         USING RESETGDG,R12\n         USING TBLENTRY,R10\n         ST    R13,SAV+4          STORE ADDRESS OF HIS SAVEAREA\n         LR    R2,R13             SAVE ADDRESS OF HIS SAVEAREA\n         LA    13,SAV             LOAD ADDRESS OF MY SAVEAREA\n         ST    13,8(2)            STORE ADDRESS OF MY SAV IN HIS SAV\n*\n*\nINIT     EQU   *\n         OPEN  (SYSIN,INPUT,REPORT,OUTPUT)\n*\nCONTROL  EQU   *\nCNTRL1   BAL   R11,READ\n         CLC   ENTRIES,=C'DLX'    IS THIS A DELETE REQUEST?\n         BNE   CNTRL2               NO - SKIP AROUND\n*        WTO   'DELETED',ROUTCDE=11,DESC=6\n         B     CNTRL1\nCNTRL2   BAL   R11,RECAT\n*        WTO   'SUCCESS',ROUTCDE=11,DESC=6\n         FREEMAIN  R,LV=80000,A=TABADDR\n         B     CNTRL1\n*\nREAD     EQU   *\n         MVC   OUTAREA,SPACES\n         MVI   OUTAREA,X'89'      SKIP TO TOP\n         BAL   R8,WRITEPRT        WRITE A BLANK LINE WITH SKIP TO TOP\n         GET   SYSIN,INAREA       READ INPUT REC\n         MVC   OUTAREA+1(80),INAREA   MOVE THE RECORD TO OUTAREA\n         BAL   R8,WRITEPRT        WRITE THE RECORD TO REPORT\n         CLC   ENTRIES,=C'DLX'    IS THIS A DELETE REQUEST?\n         BE    DELREQ                YES - SKIP\n         CLC   ENTRIES,=C'001'    IS ENTRIES LESS THAN 1?\n         BL    BADENT               YES - TERMINATE\n         CLC   ENTRIES,=C'255'    IS ENTRIES GREATER THAN 255?\n         BH    BADENT               YES - TERM\n         PACK  PWORK,ENTRIES      CONVERT ENTRIES TO BINARY\n         CVB   R9,PWORK\n         STC   R9,BGDG+3          STORE # ENTRIES IN BLDG LIST\n         GETMAIN R,LV=80000       GET ENOUGH STORAGE FOR 256 ENTRIES\n         LR    R10,R1             LOAD THE WORKAREA ADDRESS\n         ST    R10,TABADDR        SAVE IT\nDELREQ   EQU   *                  LABEL FOR SKIP IF DELETE REQUEST\n         MVC   SAVENAME,GDGNAME   SAVE NAME FOR LATER BLDG\n         TRT   GDGNAME,BLANKTBL   FIND ADDRESS OF BLANK\n         LR    R3,R1              SAVE IT IN R3\n*\n         MVC   0(3,R3),=C'(0)'    INSERT RELATIVE GENERATION REF\n         LOCATE LOCNAME           FIND OUT WHAT KIND OF CATALOG WE HAVE\n         STCM  R1,B'1000',CATYPE  STORE THE HIGH ORDER BYTE\n         L     R2,16              GET ADDRESS OF CVT\n         TM    116(R2),X'20'      IS THIS VS1?\n         BNO   NOTVS1               NO -SKIP\n         MVI   CATYPE,CVOLTYPE    IF VS1 THIS MUST BE CVOL\nNOTVS1   CLC   ENTRIES,=C'DLX'    IS THIS A DELETE REQUEST?\n         BE   UNCREST               YES - GO DELETE\n*\nLOCLOOP  EQU   *\n         MVC   0(3,R3),=C'(0)'    INSERT RELATIVE GENERATION REF\n         LOCATE LOCNAME           LOCATE GENERATION(0)\n         LTR   R15,R15            WAS LOCATE SUCESSFULL?\n         BNZ   WRITEFF              NO - MUST HAVE BEEN THE LAST ONE\n         LA    R8,UNCAT-8         SAVE ADDRESS OF TAG FOR ERROR WTO\n         CATALOG  UNCAT           UNCAT THE DATASET\n         LTR   R15,R15            WAS UNCAT SUCESSFULL?\n         BNZ   ERROR                NO - ERROR\n         MVC   MSGNAME,GDGNAME    SET UP MSG LINE\n         MVC   MSGAREA(14),UNCATMSG\n         BAL   R8,WRITEPRT        GO WRITE MSG TO REPORT\n         LA    R4,TCATBLK         GET READY FOR MVCL\n         LA    R5,265             LENGTH IS 265\n         LA    R6,CATBLK\n         LA    R7,265\n         MVCL  R4,R6              MOVE BLK INTO TABLE\n         MVC   TNAME,GDGNAME      MOVE NAME INTO TABLE\n         LA    R10,310(,R10)      INCREMENT TABLE ADDRESS\n         BCT   R9,LOCLOOP         LOOP\nUNCREST  EQU   *\n         MVC   0(3,R3),=C'(0)'    INSERT RELATIVE GENERATION REF\n         LOCATE LOCNAME           GET THE ABSOLUTE GEN NUMBER\n         CATALOG  UNCAT           GO UNCAT THIS GEN\n         LTR   R15,R15            SUCESSFULL?\n         BNZ   WRITEFF              NO - MUST BE DONE - RETURN\n         MVC   MSGNAME,GDGNAME    SET UP MSG LINE\n         MVC   MSGAREA(14),UNCATMSG\n         BAL   R8,WRITEPRT        GO WRITE MSG TO REPORT\n         B     UNCREST            LOOP\nWRITEFF  EQU   *                  WRITE FF'S TO INDICATE END OF TABLE\n         CLC   ENTRIES,=C'DLX'    IS THIS A DELETE REQUEST?\n         BE    SKIP1                YES - SKIP AROUND FFFF WRITE\n         MVC   0(4,R10),=X'FFFFFFFF'   WRITE FF'S TO INDICATE END TBL\nSKIP1    EQU   *\n         TM    CATYPE,CVOLTYPE    IS THIS A CVOL?\n         BO    CVOLDEL              YES - USE THE CAMLST\n         B     ICFDEL               NO - USE IDCAMS\nCVOLDEL  LA    R8,DELIDX-8        SAVE ADDRESS OF TAG FOR ERROR WTO\n         INDEX  DELIDX            DELETE THE INDEX\n         LTR   R15,R15            WAS DELETE SUCESSFULL?\n         BNZ   ERROR                NO -ERROR\nDELOK    MVC   MSGNAME,SAVENAME   SET UP MSG LINE\n         MVC   MSGAREA(14),DELXMSG\n         BAL   R8,WRITEPRT        GO WRITE MSG TO REPORT\n         BR    R11                RETURN\n*\nICFDEL   EQU   *                  COME HERE IF ICF CATALOG\n         MVC   DELCARD+9(36),SAVENAME  MOVE THE GDG NAME INTO STMT\n         LA    R1,IDCDEL          POINT R1 TO THE PARM LIST\n         L     R15,=V(IDCAMSIN)   GET THE ADDR OF THE IDCAMS INTERFACE\n         BALR  R14,R15            GO UNCAT\n         LTR   R15,R15            SUCESSFULL?\n         BZ    DELOK                YES - BRANCH\n         B     IDCERROR            ELSE BRANCH TO HANDLE IDCAMS ERROR\n*\n*\nRECAT    EQU   *\n         TM    CATYPE,CVOLTYPE    IS THIS A CVOL?\n         BO    CVOLIDX              YES - USE THE INDEX\n         B     ICFDEF               NO - USE IDCAMS\nCVOLIDX  LA    R8,BGDG-8          SAVE ADDRESS OF TAG FOR ERROR WTO\n         INDEX BGDG               GO BUILD NEW INDEX USING NEW ENTRIES\n         LTR   R15,R15            SUCESSFULL?\n         BNZ   ERROR                NO - ERROR\nINDEXOK  MVC   MSGNAME,SAVENAME   SET UP MSG LINE\n         MVC   MSGAREA(26),BLDGMSG\n         MVC   MSGAREA+22(3),ENTRIES\n         BAL   R8,WRITEPRT        GO WRITE MSG TO REPORT\n         L     R10,TABADDR        LOAD START ADDRESS OF SAVE TABLE\n         CLC   TNAME(4),=X'FFFFFFFF'  IS THERE ANYTHING TO RECATALOG?\n         BNE   CATLOOP              YES - BRANCH AROUND\n         BR     R11\nCATLOOP  EQU   *\n         MVC   GDGNAME,TNAME      MOVE IN NAME\n         MVC   CATBLK(242),TVOLLIST  MOVE IN VOLUME LIST\n         LA    R8,CAT-8           SAVE ADDRESS OF TAG FOR ERROR WTO\n         CATALOG CAT              GO CATALOG THE DATASET\n         LTR   R15,R15            SUCESSFULL?\n         BNZ   ERROR                NO - ERROR\n         MVC   MSGNAME,GDGNAME    SET UP MSG LINE\n         MVC   MSGAREA(14),CATMSG\n         BAL   R8,WRITEPRT        GO WRITE MSG TO REPORT\n         LA    R10,310(,R10)      INCREMENT TABLE ADDRESS\n         CLC   TNAME(4),=X'FFFFFFFF'  IS THIS THE LAST ENTRY\n         BER   R11                  YES -RETURN\n         B     CATLOOP            ELSE LOOP\n*\nICFDEF   EQU   *\n         MVC   DEFCARD+15(36),SAVENAME      MOVE IN THE GDG NAME\n         MVC   DEFCARD+58(3),ENTRIES   MOVE IN THE LIMIT\n         LA    R1,IDCDEF          POINT R1 TO THE PARM LIST\n         L     R15,=V(IDCAMSIN)   GET THE ADDR OF THE IDCAMS INTERFACE\n         BALR  R14,R15            GO UNCAT\n         LTR   R15,R15            SUCESSFULL?\n         BZ    INDEXOK              YES - BRANCH\n         B     IDCERROR            ELSE BRANCH TO HANDLE IDCAMS ERROR\n*\n*\nERROR    EQU   *\n         ST    R15,CCODE          STORE RETURN CODE FROM CAMLST\n         MVC   WTOX+24(8),0(R8)   MOVE IN THE TAG\nWTOX     WTO   'ERROR IN CAMLST XXXXXXXX',ROUTCDE=11,DESC=6\n         B     TERM\n*\nIDCERROR EQU   *\n         ST    R15,CCODE          SAVE RETURN CODE FROM IDCAMS\n         WTO   'IDCAMS RETURNED ERROR - SEE IDCAMS SYSPRINT MESSAGES', X\n               ROUTCDE=11\n         B     TERM\n*\n*\nBYE      EQU   *\n         CLOSE (SYSIN,,REPORT)\n         L     R13,SAV+4\n         L     R15,CCODE\n         RETURN (14,12),RC=(15)\n*\n*\n***********************************************************************\nSNAPIT   EQU   *\n         LA    R11,320(,R10)\n         WTO   'SNAP DUMP REQUESTED',ROUTCDE=11,DESC=6\n         OPEN (SNAPPER,OUTPUT)\n         SNAP  DCB=SNAPPER,PDATA=(PSW,REGS),STORAGE=(CATBLK,BLANKTBL)\n         SNAP  DCB=SNAPPER,STORAGE=((R10),(R11))\n         CLOSE (SNAPPER)\n         B     BYE\n*\nBADENT   EQU   *\n         MVC   OUTAREA+1(25),ENTMSG   WRITE INVALID ENTRIES MSG\n         BAL   R8,WRITEPRT\n         MVC   CCODE,=F'99'\nTERM     MVC   OUTAREA+1(91),TERMMSG  WRITE TERMINATION MESSAGE\n         BAL   R8,WRITEPRT\n         B     SNAPIT\n*\nWRITEPRT EQU   *\n         PUT   REPORT,OUTAREA     WRITE OUTPUT RECORD\n         MVC   OUTAREA,SPACES     CLEAR OUTAREA\n         BR    R8                 RETURN\n*\n         DS    0F                 FULLWORD ALIGNMENT\n         DC    CL8'NAME    '      TAG FOR ERROR MSG\nLOCNAME  CAMLST NAME,GDGNAME,,CATBLK\n*\n         DC    CL8'UNCAT   '        TAG FOR ERROR MSG\nUNCAT    CAMLST UNCAT,GDGNAME   UNCAT AND RETAIN INDEX LEVLELS\n*\n         DC    CL8'DLTX    '        TAG FOR ERROR MSG\nDELIDX   CAMLST DLTX,SAVENAME   DELETE GDG INDEX\n*\n         DC    CL8'BLDG    '        TAG FOR ERROR MSG\nBGDG     CAMLST BLDG,SAVENAME,,,DELETE,,000\n*\n         DC    CL8'CAT     '        TAG FOR ERROR MSG\nCAT      CAMLST CAT,GDGNAME,,CATBLK\n*\n************************ DATA AREAS AND DCB'S *************************\n*\n         DS    0D\nCATBLK   DS    CL265\nSAV      DS    18F\nPWORK    DS    D\nTABADDR  DS    A(0)\nINAREA   DS    0CL80\nGDGNAME  DS    CL44\n         DS    CL1\nENTRIES  DS    CL3\n         DS    CL32\nSAVENAME DS    CL44\nCCODE    DC    F'0'\nPGEN     DS    PL3\nSPACES   DC    C' '\nOUTAREA  DS    0CL133\n         DC    C' '\nMSGNAME  DS    CL44\n         DS    CL8\nMSGAREA  DS    CL80\nCATYPE   DC    X'00'              CATALOG TYPE\nCVOLTYPE EQU   X'08'\nICFTYPE  EQU   X'00'\nIDCDEL   DC    F'1'               ONE CARD WILL BE PASSED TO IDCAMSIN\n         DC    A(DELCARD)         ADDRESS OF THE IDCAMS DELETE STMT\nDELCARD  DC    C' DELETE (                          ) GDG'\n         DC    (80-L'DELCARD)C' ' FILL IT OUT WITH BLANKS\nIDCDEF   DC    F'1'               ONE CARD WILL BE PASSED TO IDCAMSIN\n         DC    A(DEFCARD)         ADDRESS OF THE CARD\nDEFCARD  DC    C' DEF GDG (NAME(                                    )  X\n               LIM(000) SCR)'\n         DC    (80-L'DEFCARD)C' '  FILL IT OUT WITH BLANKS\nBLANKTBL DC    64X'00',X'FF',191X'00'\nTERMMSG  DC    CL91'** UNACCEPTABLE ERROR ** - PROGRAM TERMINATING - NOX\n                FURTHER INPUT RECORDS WILL BE PROCESSED'\nENTMSG   DC    CL25'*** INVALID ENTRIES INPUT'\nUNCATMSG DC    CL14'UNCATALOGED   '\nCATMSG   DC    CL14'CATALOGED     '\nDELXMSG  DC    CL14'INDEX DELETED '\nBLDGMSG  DC    CL26'INDEX CREATED ENTRIES=XXX'\n*\nSYSIN    DCB   DDNAME=GDGIN,MACRF=GM,LRECL=80,DSORG=PS,RECFM=FB,       C\n               EODAD=BYE\nREPORT   DCB   DDNAME=GDGOUT,MACRF=PM,LRECL=133,DSORG=PS,RECFM=FBM\nSNAPPER  DCB   DDNAME=SNAPPER,MACRF=W,LRECL=125,BLKSIZE=882,DSORG=PS,  C\n               RECFM=VBA\n         LTORG\nTBLENTRY DSECT                    310 BYTE TABLE ENTRY\nTNAME    DS    CL44               ABSOLUTE NAME\nTCATBLK  DS    0CL265             KEEP ON DBLWORD\nTVOLLIST DS    CL242              VOLUME LIST INCLUDING # OF VOLUMES\n         DS    CL10               ZEROS\nCHAINTTR DS    CL3                CHAIN TTR\n         DS    CL4                ZERO\nCVOLSER  DS    CL6                FOUND ON THIS CVOL\n         DS    C                  FILLER\n*\n         TITLE    'IDCAMS INTERFACE'\n***********************************************************************\n*                                                                     *\n*  THIS MODULE WILL ALLOW YOU TO INVOKE IDCAMS. ON ENTRY,             *\n*  R1 SHOULD POINT TO A LIST THAT LOOKS LIKE THIS:                    *\n*                                                                     *\n*   - FULLWORD CONTAINING THE BINARY COUNT OF 80 BYTE ENTRIES         *\n*     FOLLOWING.                                                      *\n*   - ADDRESS OF  80 BYTE IDCAMS SYSIN RECORDS                        *\n*                                                                     *\n*  THIS MODULE IGNORES OPEN/CLOSE REQUESTS FROM IDCAMS.               *\n*                                                                     *\n*  REGISTER USAGE -                                                   *\n*                                                                     *\n*    R2   = WORK REG                                                  *\n*    R3  =                                                            *\n*    R4  = NUMBER OF IDCAMS SYSIN RECORD IMAGES* FROM CALLER *        *\n*    R5  = POINTER TO CURRENT SYSIN RECORD           V                *\n*    R6  = POINTER TO IOFLAGS                  * FROM IDCAMS *        *\n*    R7  = POINTER TO IOINFO                         V                *\n*    R8  = POINTER TO USERDATA AREA                                   *\n*    R9                                                               *\n*    R10                                                              *\n*    R11 = BAL RETURN REG                                             *\n*    R12 = BASE                                                       *\n*    R13 = SAVEAREA POINTER\n*                                                                     *\n***********************************************************************\n         EJECT\nIDCAMSIN CSECT\n         SAVE  (14,12),,IDCAMSIN&SYSDATE&SYSTIME\n         LR    R12,R15\n         USING IDCAMSIN,R12\n         ST    R13,SAV2+4         STORE ADDRESS OF HIS SAVEAREA\n         LR    R2,R13             SAVE ADDRESS OF HIS SAVEAREA\n         LA    13,SAV2            LOAD ADDRESS OF MY SAVEAREA\n         ST    13,8(2)            STORE ADDRESS OF MY SAV IN HIS SAV\n*\n*\n         MVC   USRDATA(8),0(R1)   SAVE THE PARMS\n         LINK  EP=IDCAMS,PARAM=(OPTLIST,DNAMELST,PGNOLIST,IOLIST),     X\n               VL=1\n         L     R13,SAV2+4\n         RETURN (14,12),RC=(15)\nSAV2     DS    18F\n*\nOPTLIST  DC    H'0'               EMPTY OPTION LIST\nDNAMELST DC    H'0'               EMPTY DNAME LIST\nPGNOLIST DC    H'0'               EMPTY PAGE NO LIST\nIOLIST   DC    F'1'               ONE GROUP OF I/O LISTS FOLLOW\n         DC    A(SYSINID)         POINTER TO ID FOR SYSIN\n         DC    A(IOROUT)          POINTER TO I/O ROUTINE\n         DC    A(USRDATA)         ADDR OF USER DATA AREA\nSYSINID  DC    CL10'DDSYSIN   '   INDICATE WE WISH TO MANAGE SYSIN\nUSRDATA  DC    2F'0'              USER DATA AREA\n***********************************************************************\n         DROP  R12                DROP R12 TO RE-ESTABLISH BASE\n*\nIOROUT   CSECT                    USER I/O ROUTINE\n         SAVE  (14,12)            SAVE IDCAMS REGS\n         LR    R12,R15\n         USING IOROUT,R12\n         ST    R13,IOSAV+4        BACK CHAIN\n         LR    R2,R13\n         LA    R13,IOSAV          POINT TO THE SAVE AREA FOR THIS GUY\n         ST    R13,8(2)           FORWARD CHAIN\n         LM    R6,R7,4(R1)        GET THE IOFLGS AND IOINFO POINTERS\n         L     R1,0(,R1)          POINT TO THE USERDATA AREA\n         LM    R4,R5,0(R1)        GET THE USERDATA\n         LR    R8,R1              SAVE ADDR OF USERDATA AREA\n*\n         XR    R15,R15            CLEAR R15\n         IC    R15,0(,R6)         INSERT THE REQUEST CODE\n         L     R15,FUNCTAB(R15)     LOAD ROUTINE ADDRESS\n         BALR  R11,R15            AND GO DO IT\nRET      EQU   *                  GO BACK TO IDCAMS\n         L     R13,IOSAV+4        RESTORE THE IDCAMS SAVAREA POINTER\n         RETURN (14,12),RC=(15)\n*\nOPENRTN  EQU   *                  WE WILL INGNORE OPEN REQUESTS\n         XR    R15,R15            CLEAR THE RET CODE\n         BR    R11                AND RETURN\n*\nCLOSERTN EQU   *                  WE WILL IGNORE CLOSE REQUESTS\n         XR    R15,R15            CLEAR THE RET CODE\n         BR    R11                AND RETURN\n*\nGETRTN   EQU   *\n         LTR   R4,R4              ANY MORE SYSIN RECS?\n         BNZ   GETREC               YES - GO GET ONE\n         LA    R15,4              ELSE INDICATE END OF FILE\n         BR    R11                AND RETURN\nGETREC   ST    R5,0(,R7)          POINT TO THE RECORD IN IDCAM'S LIST\n         MVC   4(4,R7),=F'80'     INDICATE IT'S LENGTH IS 80\n         LA    R5,80(,R5)         POINT TO THE NEXT RECORD\n         XR    R15,R15            ZERO THE RETURN CODE\n         BCTR  R4,0               DECREMENT THE SYSIN RECORD COUNT\n         STM   R4,R5,0(R8)        STORE COUNT AND ADDRESS IN USRDATA\n         BR    R11                AND RETURN\n*\n***********************************************************************\n************************ DATA AREAS AND DCB'S *************************\n*\nIOSAV    DS    18F\n*\nFUNCTAB  EQU   *\n         DC    A(OPENRTN)\n         DC    A(CLOSERTN)\n         DC    A(GETRTN)\n         LTORG\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCPANL": {"ttr": 1281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")ATTR DEFAULT(%+_)\n    % TYPE(TEXT) INTENS(HIGH) COLOR(WHITE) SKIP(ON)\n    \u00a2 TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n    + TYPE(TEXT) INTENS(LOW)  COLOR(TURQ) SKIP(ON)\n    _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED)\n    \u00ac TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(RED) PAD(_)\n    \u00a6 TYPE(INPUT) INTENS(HIGH) CAPS(OFF)\n)BODY EXPAND(\\\\)\n+-\\-\\-\u00a2 Script +-\\-\\-\n%OPTION  ===>\u00a6ZCMD                                                             +\n%\n+Enter any operands below for%SCRIPT    &SCDSN\n%===>\u00a6LOPER\n\n                                                                               +\n%Operands:\n+ Bind(obind {ebind})                     CHars(font1..font4)\n+ DESt(station-id)                        DEVice(devtype)\n+ FIle{(fileid)}                          FOntlib({filetype}{filemodel})\n+ Lib(libename...)(opnum...)              Message({DELAY}{D}{TRACE})\n+ Options{(fileid)} (non-TSO)             PRInt{(copies,class,fcb,ucs)}\n+ PROfile{(fileid)}/NOPROFILE             SEArch(libname)(opnum...)\n+ SEGlib(libname)/NOSEGLIB                SYSvar(n value...)\n+ PAge{({PROMPT}{{FROM} p {TO} q} {{FROM} p FOR n}{{FROM} p ONLY})}\n+\n+ Continue/NOCont     CTf                 DDut/NODdut         FPasses n\n+ Index               NOSPie              NOWait              NUmber\n+ Quiet               SPellchk            STop                SYON/SYOFf\n+ TErm                TLib                TWopass             UNformat\n+ UPcase              @user-option\n+\n+Press the%ENTER+key to invoke Script or the%END+key to terminate.\n)INIT\n .CURSOR=LOPER\n &LOPER=&SCOPTS\n &RESPONSE=&Z\n)PROC\n &SCOPTS='&LOPER'\n IF (.RESP = END)\n    &RESPONSE=.RESP\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPF": {"ttr": 1283, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         PRINT   GEN\n***********************************************************************\n*                                                                     *\n*        SETUP                                                        *\n*                                                                     *\n***********************************************************************\nSPF      XABGN SAVE=(SAVEAREA,LSAVAREA),REQUS=YES,GEN=GEN\n         LA    R7,4095(R12)\n         USING SPF+4095,R7\n         LA    R9,4095(R13)\n         USING SAVEAREA+4095,R9\n         MVC   DAPB08C(DAPB08L),DAPB08CI SET UP DAPB08 CONTROL\n         MVC   DAPB18C(DAPB18L),DAPB18CI SET UP DAPB18 CONTROL\n         LR    R8,R1                   LOAD REGISTER 8 TO PRESERVE\n*                                      POINTER TO COMMAND PROCESSOR\n*                                      PARAMETER LIST\n         ST    R1,CPPLPNTR             SAVE R1\n         USING CPPL,R8                 ESTABLISH ADDRESSABILITY TO CPPL\n         LA    R6,DAPLSECT             LOAD ADDRESS OF DAIR PARAMETER\n*                                      LIST\n         USING DAPL,R6                 ESTABLISH ADDRESSABILITY TO DAPL\n         L     R1,CPPLUPT              LOAD POINTER TO USER PROFILE\n*                                      TABLE FROM CPPL\n         L     R2,CPPLECT              LOAD POINTER TO ENVIRONMENT\n*                                      CONTROL TABLE FROM CPPL\n         SR    R3,R3                   ZERO REGISTER 3\n         ST    R3,ECB                  STORE REGISTER AS ECB FOR PPL\n         LA    R3,ECB                  LOAD ADDRESS OF ECB\n         STM   R1,R3,DFPLSECT          STORE UPT,ECT,ECB IN DFPL\n         STM   R1,R3,DAPLSECT          STORE ADDRESS OF UPT, ECT, AND\n*                                      ECB IN DAPL\n         LA    R3,DFPBSECT             GET ADDRESS OF DFPB\n         ST    R3,DFPLSECT+12          PUT IT IN THE CONTROL BLOCK\n         USING DFPB,R3\n         LA    R2,DFPBDSL\n         ST    R2,DFPBDSN\n         LA    R2,DFPBQUA\n         ST    R2,DFPBQUAL\n         MVI   DFPBCODE,DFPB04\n         MVC   DFPBPSCB,CPPLPSCB\n         MVI   DFPBCNTL,DFPBRET\n         XC    DFPBCAT(8),DFPBCAT\n         DROP  R3\n         DROP  R6,R8             DROP ADDRESSABILITY TO CPPL, DAPL\n         EJECT\n****** INITIALIZE LIBRARY TABLES AND FLAGS\n         MVI   SYSPRGMR,C'N'   SET FLAG TO NOT SYSTEMS PROGRAMMER\n         MVI   SYSPROC,C'N'    SET FLAG TO NO SYSPROC\n         MVI   FPROF,C'N'      SET FLAG TO NO ISPPROF\n         MVI   FPLIB,C'N'      SET FLAG TO NO ISPPLIB\n         MVI   FMLIB,C'N'      SET FLAG TO NO ISPMLIB\n         MVI   FSLIB,C'N'      SET FLAG TO NO ISPSLIB\n         MVI   FTLIB,C'N'      SET FLAG TO NO ISPTLIB\n         MVI   FLLIB,C'N'      SET FLAG TO NO ISPLLIB\n         MVI   FTABL,C'N'      SET FLAG TO NO ISPTABL\n         MVI   FFILE,C'N'      SET FLAG TO NO ISPFILE\n         MVI   NPLIB,C'Y'      SET FLAG TO USE ISPPLIB DEFAULT\n         MVI   NMLIB,C'Y'      SET FLAG TO USE ISPMLIB DEFAULT\n         MVI   NSLIB,C'Y'      SET FLAG TO USE ISPSLIB DEFAULT\n         MVI   NTLIB,C'Y'      SET FLAG TO USE ISPTLIB DEFAULT\n         MVI   NTABL,C'N'      SET FLAG FOR NO ISPTABL DEFAULT\n         MVI   NFILE,C'N'      SET FLAG FOR NO ISPFILE DEFAULT\n         MVI   NLLIB,C'Y'      SET FLAG TO USE ISPLLIB DEFAULT\n         MVI   NCLIB,C'Y'      SET FLAG TO USE SYSPROC DEFAULT\n         SR    R2,R2           SET R2 TO ZERO\n         ST    R2,CLIBTABC          SET NUMBER OF ENTRIES TO ZERO\n         ST    R2,PLIBTABC          SET NUMBER OF ENTRIES TO ZERO\n         ST    R2,MLIBTABC          SET NUMBER OF ENTRIES TO ZERO\n         ST    R2,SLIBTABC          SET NUMBER OF ENTRIES TO ZERO\n         ST    R2,LLIBTABC          SET NUMBER OF ENTRIES TO ZERO\n         ST    R2,TLIBTABC          SET NUMBER OF ENTRIES TO ZERO\n         ST    R2,TABLTABC          SET NUMBER OF ENTRIES TO ZERO\n         ST    R2,FILETABC          SET NUMBER OF ENTRIES TO ZERO\n         MVC   CLIBTABL(8),=CL8'SYSPROC '  SET UP CLIB DDNAME\n         MVC   PLIBTABL(8),=CL8'ISPPLIB '  SET UP PLIB DDNAME\n         MVC   MLIBTABL(8),=CL8'ISPMLIB '  SET UP MLIB DDNAME\n         MVC   SLIBTABL(8),=CL8'ISPSLIB '  SET UP SLIB DDNAME\n         MVC   LLIBTABL(8),=CL8'ISPLLIB '  SET UP LLIB DDNAME\n         MVC   TLIBTABL(8),=CL8'ISPTLIB '  SET UP TLIB DDNAME\n         MVC   TABLTABL(8),=CL8'ISPTABL '  SET UP TABL DDNAME\n         MVC   FILETABL(8),=CL8'ISPFILE '  SET UP FILE DDNAME\n         MVC   PROFILE(8),=CL8'WPROFILE'   SET UP WPROFILE MEMBER NAME\n         EJECT\n****** GO THRU TIOT LOOKING FOR DD NAMES\n         L     R2,16           R2 <- ADDR OF CVT\n         L     R2,0(R2)        R2 <- ADDR OF ADDR OF TCB'S FROM CVT\n         L     R2,4(R2)        R2 <- ADDR OF CURRENT TCB\n         L     R2,12(R2)       R2 <- ADDR OF TIOT FROM TCB\n         LA    R2,24(R2)       R2 <- ADDR OF FIRST DD ENTRY IN TIOT\n         SR    R3,R3           R3 <- 0\nCHECKDD  CLC   4(8,R2),=CL8'SYSSPF  '  IS THIS A SYSTEMS PROGRAMMER?\n         BNE   CHKSPROC        IF NOT GO TO MOVE ENTRY INTO TABLE\n         MVI   SYSPRGMR,C'Y'   SET SYSTEMS PROGRAMMER FLAG\n         B     SKPENTRY        DO NOT MOVE THIS ENTRY INTO TABLE\nCHKSPROC DS    0H\n         CLC   4(8,R2),=CL8'SYSPROC' IS THIS THE SYSPROC DD\n         BNE   CHKISP          IT IS NOT, CHECK NEXT ISP DD\n         MVI   SYSPROC,C'Y'    SET SYSPROC PRESENT\n         B     SKPENTRY        DO NOT MOVE THIS ENTRY INTO TABLE\nCHKISP   CLC   4(3,R2),=CL8'ISP'       IS THIS AND ISP DD?\n         BNE   SKPENTRY        IF NOT SKIP ENTRY\n         CLC   4(8,R2),=CL8'ISPPROF '  IS THIS ISPPROF\n         BNE   CHKPLIB         IF NOT CHECK NEXT ISP DD\n         MVI   FPROF,C'Y'      SET ISPPROF\n         B     SKPENTRY\nCHKPLIB  DS    0H\n         CLC   4(8,R2),=CL8'ISPPLIB ' IS THIS THE ISPPLIB DD\n         BNE   CHKMLIB         IT IS NOT, CHECK FOR NEXT ISP DD\n         MVI   FPLIB,C'Y'      SET ISPPLIB PRESENT\n         B     SKPENTRY\nCHKMLIB  DS    0H\n         CLC   4(8,R2),=CL8'ISPMLIB ' IS THIS THE ISPMLIB DD\n         BNE   CHKSLIB         IT IS NOT, CHECK FOR NEXT ISP DD\n         MVI   FMLIB,C'Y'      SET ISPPLIB PRESENT\n         B     SKPENTRY        DO NOT MOVE THIS ENTRY INTO TABLE\nCHKSLIB  DS    0H\n         CLC   4(8,R2),=CL8'ISPSLIB ' IS THIS THE ISPSLIB DD\n         BNE   CHKLLIB         IT IS NOT, CHECK FOR NEXT ISP DD\n         MVI   FSLIB,C'Y'      SET ISPPLIB PRESENT\n         B     SKPENTRY\nCHKLLIB  DS    0H\n         CLC   4(8,R2),=CL8'ISPLLIB ' IS THIS THE ISPLLIB DD\n         BNE   CHKTLIB         IT IS NOT, CHECK FOR NEXT ISP DD\n         MVI   FLLIB,C'Y'      SET ISPLLIB PRESENT\n         B     SKPENTRY\nCHKTLIB  DS    0H\n         CLC   4(8,R2),=CL8'ISPTLIB ' IS THIS THE ISPTLIB DD\n         BNE   CHKTABL         IT IS NOT, CHECK FOR NEXT ISP DD\n         MVI   FTLIB,C'Y'      SET ISPTLIB PRESENT\n         B     SKPENTRY\nCHKTABL  DS    0H\n         CLC   4(8,R2),=CL8'ISPTABL ' IS THIS THE ISPTABL DD\n         BNE   CHKFILE         IT IS NOT, CHECK FOR NEXT ISP DD\n         MVI   FTABL,C'Y'      SET ISPTABL PRESENT\n         B     SKPENTRY\nCHKFILE  DS    0H\n         CLC   4(8,R2),=CL8'ISPFILE ' IS THIS THE ISPFILE DD\n         BNE   SKPENTRY        IT IS NOT, GO TO END OF CHECKS\n         MVI   FFILE,C'Y'      SET ISPFILE PRESENT\n         B     SKPENTRY\nSKPENTRY IC    R3,0(R2)        R3 <- LENGTH OF THIS TIOT ENTRY\n         AR    R2,R3           R2 <- ADDR OF NEXT TIOT ENTRY\n         CLI   0(R2),0         IS THIS AN ZERO LENGTH ENTRY (THE END)?\n         BNE   CHECKDD         NOPE, WE GOT A LIVE ONE.\n         EJECT\n****** CHECK TO SEE IF USER HAS PROFILE DATASET\n         CLI   FPROF,C'Y'      DOES USER HAVE ISPPROF ALLOCATED?\n         BE    CHKWPROF        IF SO BRANCH TO CHECK FOR WPROFILE\n****** ALLOCATE ISPPROF\n         L     R1,CPPLPNTR                            SET UP R1\n         L     R2,8(R1)                R1 NOW POINTS TO OF PSCB\n         LA    R4,18                   LOAD LENGTH OF PROFILE DSN\n         STH   R4,PROFDSNP             STORE LENGTH OF PROFILE DSN\n         MVC   PROFDSN(12),=CL44'TSO.PROFILE.'  SET UP PROFILE DSN\n         MVC   PROFDPID(6),0(R2)       MOVE IN THE DPID\n         LA    R3,=CL8'ISPPROF '         POINT AT DDNAME\n         LA    R4,PROFDSNP             POINT AT DSN FOR ALLOCATE\n         SR    R5,R5                   SET ATTR IND TO NO\n         BAL   R11,ALLOCATE            ALLOCATE ISPPROF\nCHKWPROF DS    0H\n**** CHECK (FIND) FOR WPROFILE MEMBER     ***************************\n         L     R1,CPPLPNTR                            SET UP R1\n         L     R2,8(R1)                R2 NOW POINTS TO OF PSCB\n         LA    R4,18                   LOAD LENGTH OF PROFILE DSN\n         STH   R4,PROFDSNP             STORE LENGTH OF PROFILE DSN\n         MVC   PROFDSN(12),=CL44'TSO.PROFILE.'  SET UP PROFILE DSN\n         MVC   PROFDPID(6),0(R2)       MOVE IN THE DPID\n**** DETERMIN USER WPROFILE NAME          ***************************\n*                                         ***************************\n         L     R1,CPPLPNTR                            SET UP R1\n         L     R2,0(R1)                R2 NOW POINTS TO COMMAND BUFF\n         LH    R1,0(R2)                R1 HAS COMMAND BUFF LENGTH\n         LH    R4,2(R2)                R4 HAS COMMAND OFFSET\n         AR    R2,R4                   R2 POINTS PAST COMMAND\n         SR    R1,R4                   R1 HAS LENGTH MINUS OFFSET\n         C     R1,=F'4'                CHECK R1, LENGTH MUST BE > 4\n         BNH   ENDWPNS                 IF NOT SKIP BUF CHECK\n         BCTR  R1,0                    IND CAN NOT BE LAST BYTE\nWPNSLOOP DS    0H\n         LR    R5,R1                   SETUP ADDRESS\n         AR    R5,R2                   SETUP ADDRESS\n         CLI   0(R5),C'<'              CHECK FOR PROF IND CHAR\n         BE    GOTWPNS                 GOT ONE\n         BCT   R1,WPNSLOOP             DECREMENT AND TRY AGAIN\n         B     ENDWPNS\nGOTWPNS  MVC   PROFILE(1),1(R5)        MOVE IN CHARACTER\n         OI    PROFILE,X'40'           MOVE IN CHARACTER\n         MVC   0(2,R5),=C'  '          CLEAR IND FROM COMMAND BUFF\nENDWPNS  DS    0H\n*                                         ***************************\n         CLI   PROFILE,C'/'               CHECK FOR \"NO WPROFILE\"\n         BE    ENDPROF\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * TPJ 9/17/86\n*  THE FOLLOWING COMMENTED OUT LINES WERE USED TO GET * TPJ 9/17/86\n* THE ACTUAL DSN ALLOCATED TO ISPPROF.  SINCE ONLY    * TPJ 9/17/86\n* SYSTEMS PROGRAMMERS EVER USED PROFILE DSNS OTHER    * TPJ 9/17/86\n* THAN THERE OWN, AND ONLY OCCASIONLY THIS WAS SEEN   * TPJ 9/17/86\n* AS UNNEEDED OVERHEAD AND HAS BEEN COMMENTED OUT.    * TPJ 9/17/86\n* THE @PROFILE MEMBER IS SEACHED FOR IN               * TPJ 9/17/86\n*  \"TSO.PROFILE.LOGONID\" NO MATTER WHAT DSN IS        * TPJ 9/17/86\n* ALLOCATED TO ISPPROF.                               * TPJ 9/17/86\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * TPJ 9/17/86\n*        MVC   PROFJFCB(LPDCIMAG),PROIMAGE              TPJ 9/17/86\n*        LA    R4,JFCBAREA                              TPJ 9/17/86\n*        ST    R4,JFCBA                                 TPJ 9/17/86\n*        LA    R4,7                                     TPJ 9/17/86\n*        STC   R4,JFCBA                                 TPJ 9/17/86\n*        LA    R4,JFCBA                                 TPJ 9/17/86\n*        LA    R4,0(R4)             CLEAR HIGH ORDER BYTEPJ 9/17/86\n*        ST    R4,PROFJFCB+36                           TPJ 9/17/86\n*        LA    R4,PROFJFCB                              TPJ 9/17/86\n*        RDJFCB ((4))                                   TPJ 9/17/86\n*        SR    R4,R4                   SET R4 TO ZERO   TPJ 9/17/86\n*        LA    R2,JFCBDSN              SET R2 TO START OF DSN 17/86\n*CNLP    LA    R4,1(R4)                SET R4 UP BY ONE TPJ 9/17/86\n*        LR    R1,R2                                    TPJ 9/17/86\n*        AR    R1,R4                                    TPJ 9/17/86\n*        CLI   0(R1),C' '              CHECK FOR A SPAC TPJ 9/17/86\n*        BNE   CNLP                                     TPJ 9/17/86\n*        BCTR  R4,0                    DECREMENT BY ONE TPJ 9/17/86\n*        ST    R4,JFCBDSLN             SAVE LENGTH      TPJ 9/17/86\n*        STH   R4,PROFDSNP             STORE LENGTH OF PROFILE DSN\n*        MVC   PROFDSN(44),JFCBDSN              GET PROFILE DSN\n         LA    R3,=CL8'WPROFILE'         POINT AT DDNAME\n         LA    R4,PROFDSNP             POINT AT DSN FOR ALLOCATE\n         SR    R5,R5                   SET ATTR IND TO NO\n         BAL   R11,ALLOCATE            ALLOCATE ISPPROF\n         MVC   ISPPARMI(LISPIIMA),ISPIIMAG\n         MVC   OPENLIST(LOPNIMAG),OPNIMAGE\n         MVC   CLOSLIST(LCLOIMAG),CLOIMAGE\n         LA    R2,ISPPARMI     R2 POINT TO INPUT DCB\n         OPEN  ((R2),INPUT),MF=(E,OPENLIST) OPEN THE PROFILE\n*                                                       TPJ 9/17/86\n         TM    X'30'(R2),X'10' IS THE OPEN OKAY?\n         BZ    ERROPENI        NOPE\n         FIND  (R2),PROFILE,D FIND THE WPROFILE MEMBER\n         LTR   R15,R15         WAS FIND SUCCESSFUL\n         BNZ   FINI            NOPE\n         LA    R2,ISPPARMI\n         CLOSE ((R2)),MF=(E,CLOSLIST)\n         LA    R3,=CL8'WPROFILE'         POINT AT THE DDNAME\n         BAL   R11,FREEDDNM              FREE THE DDNAME\n         L     R1,CPPLPNTR                            SET UP R1\n         L     R2,8(R1)                R1 NOW POINTS TO OF PSCB\n         LA    R4,18                   LOAD LENGTH OF PROFILE DSN\n         STH   R4,PROFDSNP             STORE LENGTH OF PROFILE DSN\n         MVC   PROFDSN(12),=CL44'TSO.PROFILE.'  SET UP PROFILE DSN\n         MVC   PROFDPID(6),0(R2)       MOVE IN THE DPID\n*        L     R4,JFCBDSLN             LOAD LENGTH\n*        STH   R4,PROFDSNP             STORE LENGTH OF PROFILE DSN\n*        MVC   PROFDSN(44),JFCBDSN     GET PROFILE DSN\n         LA    R3,=CL8'WPROFILE'       POINT AT DDNAME\n         MVC   DAP08MNM(8),PROFILE     MOVE IN MEMBER NAME\n         LA    R4,PROFDSNP             POINT AT DSN FOR ALLOCATE\n         SR    R5,R5                   SET ATTR IND TO NO\n         BAL   R11,ALLOCATE            ALLOCATE ISPPROF\n         MVC   DAP08MNM(8),=CL8' '     CLEAR MEMBER NAME\n         MVC   ISPPARMI(LISPIIMX),ISPIIMAX\n         LA    R2,ISPPARMI\n         OPEN  ((R2),INPUT),MF=(E,OPENLIST) OPEN THE WPROFILE\n         TM    X'30'(R2),X'10' IS THE OPEN OKAY?\n         BZ    ERROPENW        NOPE\n****** GO THRU WPROFILE PUTTING LIBRARIES INTO TABLES\n         LA    R10,PARMREC     R10 NOW POINT TO RECORD BUFFER\nREADNEXT DS    0H\n         GET   ISPPARMI,(R10)\n         LA    R4,PARMREC      POINTER INTO RECORD\n         CLI   0(R4),C'*'           IS IT A COMMENT CARD?\n         BE    READNEXT             IF IT IS IGNORE IT, READ NEXT\n         CLC   0(5,R4),=CL5'CLIB '    IS IT A CLIB LIBRARY?\n         BNE   CHKPLIBC             IF NOT CHECK IF PLIB\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPCLIB             SKIP DEFAULT CANCEL\n         MVI   NCLIB,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPCLIB DS    0H\n         CLI   SYSPROC,C'Y'         IS CLIB ALREADY ALLOCATED?\n         BE    READNEXT             IF SO THEN IGNORE, GOTO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,CLIBTABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\nCHKPLIBC CLC   0(5,R4),=CL5'PLIB '    IS IT A PLIB LIBRARY?\n         BNE   CHKMLIBC             IF NOT CHECK IF MLIB\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPPLIB             SKIP DEFAULT CANCEL\n         MVI   NPLIB,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPPLIB DS    0H\n         CLI   FPLIB,C'Y'           DO WE HAVE ISPPLIB?\n         BE    READNEXT             IF SO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,PLIBTABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\nCHKMLIBC CLC   0(5,R4),=CL5'MLIB '    IS IT A MLIB LIBRARY?\n         BNE   CHKSLIBC             IF NOT CHECK IF SLIB\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPMLIB             SKIP DEFAULT CANCEL\n         MVI   NMLIB,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPMLIB DS    0H\n         CLI   FMLIB,C'Y'           DO WE HAVE ISPMLIB?\n         BE    READNEXT             IF SO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,MLIBTABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\nCHKSLIBC CLC   0(5,R4),=CL5'SLIB '    IS IT A SLIB LIBRARY?\n         BNE   CHKTLIBC             IF NOT CHECK TLIB\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPSLIB             SKIP DEFAULT CANCEL\n         MVI   NSLIB,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPSLIB DS    0H\n         CLI   FSLIB,C'Y'           DO WE HAVE ISPSLIB?\n         BE    READNEXT             IF SO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,SLIBTABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\nCHKTLIBC CLC   0(5,R4),=CL5'TLIB '    IS IT A TLIB LIBRARY?\n         BNE   CHKTABLC             IF NOT CHECK TABL\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPTLIB             SKIP DEFAULT CANCEL\n         MVI   NTLIB,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPTLIB DS    0H\n         CLI   FTLIB,C'Y'           DO WE HAVE ISPTLIB?\n         BE    READNEXT             IF SO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,TLIBTABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\nCHKTABLC CLC   0(5,R4),=CL5'TABL '    IS IT A TABL LIBRARY?\n         BNE   CHKFILEC             IF NOT CHECK FILE\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPTABL             SKIP DEFAULT CANCEL\n         MVI   NTABL,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPTABL DS    0H\n         CLI   FTABL,C'Y'           DO WE HAVE ISPTABL?\n         BE    READNEXT             IF SO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,TABLTABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\nCHKFILEC CLC   0(5,R4),=CL5'FILE '    IS IT A TABL LIBRARY?\n         BNE   CHKLLIBC             IF NOT CHECK LLIB\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPFILE             SKIP DEFAULT CANCEL\n         MVI   NFILE,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPFILE DS    0H\n         CLI   FFILE,C'Y'           DO WE HAVE ISPTABL?\n         BE    READNEXT             IF SO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,FILETABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\nCHKLLIBC CLC   0(5,R4),=CL5'LLIB '    IS IT A LLIB LIBRARY?\n         BNE   BADCRD               IF NOT ITS A BAD CARD\n         CLC   5(5,R4),=CL5'NODEF'    NO DEFAULT LIBS SPECIFIED?\n         BNE   STUPLLIB             SKIP DEFAULT CANCEL\n         MVI   NLLIB,C'N'           SET TO \"NO DEFAULT\"\n         B     READNEXT             GOTO READ NEXT\nSTUPLLIB DS    0H\n         CLI   FLLIB,C'Y'           DO WE HAVE ISPTABL?\n         BE    READNEXT             IF SO READNEXT\n         CLI   5(R4),C' '           IS FIRST BYTE SPACE?\n         BE    BADCRD               IF IT IS GIVE BAD CARD MESSAGE\n         LA    R4,5(R4)             POINT R4 AT LIBRARY NAME\n         LA    R3,LLIBTABC          POINT AT TABLE ENTRY COUNT\n         BAL   R11,FILLTAB\n         B     READNEXT             GOTO READ NEXT\n****** END OF WPROFILE PROCESSING **********\nFINI     LA    R2,ISPPARMI\n         CLOSE ((R2)),MF=(E,CLOSLIST)\n         LA    R3,=CL8'WPROFILE'         POINT AT THE DDNAME\n         BAL   R11,FREEDDNM              FREE THE DDNAME\n         B     ENDPROF\n*\nBADCRD   DS    0H\n         TPUT  =C'SYS981I - SPF WPROFILE CONTAINS BAD CARD',40\n         TPUT  (R4),80\n         TPUT  =C'SYS981I - THE ABOVE CARD IS IGNORED',35\n         B     READNEXT\nERROPENI WTO   'SYS982I - SPF PROFILE INPUT OPEN ERROR',ROUTCDE=(11)\n         B     FINI\nERROPENW WTO   'SYS982I - SPF WPROFILE INPUT OPEN ERROR',ROUTCDE=(11)\n         B     FINI\nERRREAD  WTO   'SYS984I - SPF PROFILE READ ERROR',ROUTCDE=(11)\n         B     FINI\n*\nENDPROF  DS    0H\n         EJECT\n****** ADD DEFAULT LIBRARIES TO TABLES\n         CLI   SYSPROC,C'Y'         DO WE NEED TO FILL CLIB TABLE?\n         BE    APLIBTB              IF NOT CHECK PLIB TABLE\n         CLI   NCLIB,C'N'           DO WE NEED DEFAULT CLIB?\n         BE    APLIBTB              IF NOT CHECK PLIB TABLE\n         LA    R3,CLIBTABC          POINT AT TABLE ENTRY COUNT\n         CLI   SYSPRGMR,C'Y'        IS THIS A SYSTEMS PROGRAMMER?\n         BNE   CLIBUSR              IF NOT GIVE USER CLISTLIB\n         LA    R4,=CL46'SYS2.CLISTLIB'         (WSRCC SYSP CLIST)\n         BAL   R11,FILLTAB\n         LA    R4,=CL46'SYS1.ISPF230.SYSCLIB'  (WSRCC SYSCLIB)\n         B     CLIBFILL\nCLIBUSR  LA    R4,=CL46'SYS2.ISPCLIST'         (WSRCC CUST CLIST)\nCLIBFILL BAL   R11,FILLTAB\n         LA    R3,CLIBTABC          POINT AT TABLE ENTRY COUNT\n         LA    R4,=CL46'SYS1.ISPF230.PDFCLIB'  (ISPF CLISTLIB)\n         BAL   R11,FILLTAB\nAPLIBTB  DS    0H\n         CLI   FPLIB,C'Y'           DO WE NEED TO FILL PLIB TABLE?\n         BE    AMLIBTB              IF NOT CHECK MLIB TABLE\n         CLI   NPLIB,C'N'           DO WE NEED DEFAULT PLIB(S)?\n         BE    AMLIBTB              IF NOT CHECK MLIB TABLE\n         CLI   SYSPRGMR,C'Y'        IS THIS A SYSTEMS PROGRAMMER?\n         BNE   APLIBNS              IF NOT GOTO STORE PLIB\n         LA    R3,PLIBTABC          POINT AT FIRST EMPTY TABLE ENTRY\n         LA    R4,=CL46'SYS1.ISPF230.SYSPLIB'\n         BAL   R11,FILLTAB\nAPLIBNS  DS    0H\n         LA    R3,PLIBTABC          POINT AT FIRST EMPTY TABLE ENTRY\n         LA    R4,=CL46'SYS1.ISPF230.PDFPLIB'\n         BAL   R11,FILLTAB\nAMLIBTB  DS    0H\n         CLI   FMLIB,C'Y'           DO WE NEED TO FILL MLIB TABLE?\n         BE    ASLIBTB              IF NOT CHECK SLIB TABLE\n         CLI   NMLIB,C'N'           DO WE NEED TO DEFAULT MLIB?\n         BE    ASLIBTB              IF NOT CHECK SLIB TABLE\n         LA    R3,MLIBTABC          POINT AT FIRST EMPTY TABLE ENTRY\n         CLI   SYSPRGMR,C'Y'        IS THIS A SYSTEMS PROGRAMMER?\n         BNE   MLIBUSR              IF NOT GIVE USER MSG LIB\n         LA    R4,=CL46'SYS1.ISPF230.SYSMLIB'  (WSRCC SYSMLIB)\n         BAL   R11,FILLTAB\nMLIBUSR  LA    R4,=CL46'SYS1.ISPF230.PDFMLIB'\n         BAL   R11,FILLTAB\nASLIBTB  DS    0H\n         CLI   FSLIB,C'Y'           DO WE NEED TO FILL SLIB TABLE?\n         BE    ATLIBTB              IF NOT CHECK TLIB TABLE\n         CLI   NSLIB,C'N'           DO WE NEED DEFAULT SLIB?\n         BE    ATLIBTB              IF NOT CHECK TLIB TABLE\n         LA    R3,SLIBTABC          POINT AT FIRST EMPTY TABLE ENTRY\n         CLI   SYSPRGMR,C'Y'        IS THIS A SYSTEMS PROGRAMMER?\n         BNE   SLIBUSR              IF NOT GIVE USER SKELLIB\n         LA    R4,=CL46'SYS1.ISPF230.SYSSLIB'  (WSRCC SYSSLIB)\n         BAL   R11,FILLTAB\nSLIBUSR  LA    R4,=CL46'SYS1.ISPF230.PDFSLIB'\n         BAL   R11,FILLTAB\nATLIBTB  DS    0H\n         CLI   FTLIB,C'Y'           DO WE NEED TO FILL TLIB TABLE?\n         BE    ALLIBTB              IF NOT CHECK LLIB TABLE\n         CLI   NTLIB,C'N'           DO WE NEED DEFAULT TLIB?\n         BE    ALLIBTB              IF NOT CHECK LLIB TABLE\n         CLI   SYSPRGMR,C'Y'        IS THIS A SYSTEMS PROGRAMMER?\n         BNE   TLIBJUSR             IF NOT GIVE JUST USER TLIB\n         LA    R3,TLIBTABC          POINT AT FIRST EMPTY TABLE ENTRY\n         LA    R4,=CL46'SYS1.ISPF230.SYSTLIB'\n         BAL   R11,FILLTAB\nTLIBJUSR DS    0H\n         LA    R3,TLIBTABC          POINT AT FIRST EMPTY TABLE ENTRY\n         LA    R4,=CL46'SYS1.ISPF230.PDFTLIB'\n         BAL   R11,FILLTAB\nALLIBTB  DS    0H\n         CLI   FLLIB,C'Y'           DO WE NEED TO FILL LLIB TABLE?\n         BE    ENDADD\n         CLI   NLLIB,C'N'           DO WE NEED DEFAULT SLIB?\n         BE    ENDADD               IF NOT THEN END\n         LA    R3,LLIBTABC          POINT AT FIRST EMPTY TABLE ENTRY\n         CLI   SYSPRGMR,C'Y'        IS THIS A SYSTEMS PROGRAMMER?\n         BNE   LLIBUSR              IF NOT GIVE USER MSG LIB\n         LA    R4,=CL46'SYS1.ISPF230.SYSLOAD'  (WSRCC SYSMLIB)\n         BAL   R11,FILLTAB\nLLIBUSR  LA    R4,=CL46'SYS1.ISPF230.PDFLOAD'\n         BAL   R11,FILLTAB\n****                                                         ****\nENDADD   DS    0H\n       EJECT\n***** ALLOCATE FILES NOT ALREADY ALLOCATED\n         CLI   SYSPROC,C'Y'      DOES USER HAVE SYSPROC ALLOCATED?\n         BE    PERMCLIB        BRANCH TO MARK SYSPROC PERM\n         LA    R3,CLIBTABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES FOR SYSPROC\n*****\n***** IF SYSPROC ALLOCATED THEN MARK IT PERM\n*****\n***********************************************************************\n**  THE FOLLOWING WAS ADDED TO MARK THE SYSPROC DD SO THAT FREEALL   **\n** DID NOT FREE IT.                                                  **\n***********************************************************************\nPERMCLIB DS    0H             MARK SYSPROC PERM\n         L     R2,CVTPTR      CVT ADDR                           * #1 *\n         USING CVTMAP,R2                                         * #1 *\n         L     R2,CVTTCBP     TCB-TCB ADDR   (TCBHEAD)           * #1 *\n         L     R2,4(,R2)      TCB ADDR       (CURRENT TCB)       * #1 *\n         USING TCB,R2                                            * #1 *\n         L     R2,TCBJSCB     JOB STEP CONTROL BLOCK ADDR        * #1 *\n         USING IEZJSCB,R2                                        * #1 *\n         L     R2,JSCDSABQ    LOAD ADDRESS OF QDB FOR DSAB CHAIN * #1 *\n         L     R2,12(R2)      LOAD ADDRESS OF FIRST DSAB         * #1 *\n         USING DSAB,R2                                           * #1 *\nINLOOP   EQU   *                                                 * #1 *\n         L     R15,DSABTIOT   POINT TO TIOT                      * #1 *\n         USING TIOELNGH,R15                                      * #1 *\n         CLI   TIOEDDNM,C' '  PART OF A CONCAT GROUP?            * #1 *\n         BNE   RESETFLG       NO, CHECK THE LIST                 * #1 *\n         TM    FLAG,X'80'     IS THE CONCAT GROUP FLAG ON?       * #1 *\n         BO    PERM           YES, GO MARK THIS ONE              * #1 *\nRESETFLG NI    FLAG,X'FF'-X'80' TURN OFF THE FLAG                * #1 *\nDDLOOP   CLC   TIOEDDNM(8),=CL8'SYSPROC'                         * #1 *\n         BE    PERM           YES, GO MARK IT PERM               * #1 *\n         B     NOPERM                                            * #1 *\nPERM     BAL   R8,PERMDS      GO PERM THIS DDNAME                * #1 *\n         OI    FLAG,X'80'     TURN ON FLAG FOR CONCAT GROUP      * #1 *\nNOPERM   L     R2,DSABFCHN    LOAD POINTER TO NEXT DSAB ENTRY    * #1 *\n         LTR   R2,R2          END OF CHAIN ?                     * #1 *\n         BNE   INLOOP         NO, KEEP LOOKING                   * #1 *\n         B     ALLPLIB                                           * #1 *\nPERMDS   EQU   *                                                 * #1 *\n         STAX  DEFER=YES         NO ATTN WHILE WE ARE AUTHORIZED * #1 *\n         AUTH  ON                                                * #1 *\n         MODESET KEY=ZERO                                        * #1 *\n         NI    DSABFLG1,X'FF'-DSABDALC  INDICATE NO DYNAM ALLOCED* #1 *\n         MODESET KEY=NZERO                                       * #1 *\n         AUTH  OFF                                               * #1 *\n         STAX  DEFER=NO                                          * #1 *\n         BR    R8                       RETURN TO CALLER         * #1 *\n         DROP  R2\n         DROP  R15                                               * #1 *\n***********************************************************************\n***********************************************************************\n*****\n*****\nALLPLIB  DS    0H\n         CLI   FPLIB,C'Y'      DOES USER HAVE ISPPLIB ALLOCATED?\n         BE    ALLMLIB         IF SO BRANCH TO CHECK FOR ISPMLIB\n         LA    R3,PLIBTABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES\nALLMLIB  DS    0H\n         CLI   FMLIB,C'Y'      DOES USER HAVE ISPMLIB ALLOCATED?\n         BE    ALLSLIB         IF SO BRANCH TO CHECK FOR ISPSLIB\n         LA    R3,MLIBTABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES\nALLSLIB  DS    0H\n         CLI   FSLIB,C'Y'      DOES USER HAVE ISPSLIB ALLOCATED?\n         BE    ALLTLIB         IF SO BRANCH TO CHECK FOR ISPTLIB\n         LA    R3,SLIBTABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES\nALLTLIB  DS    0H\n         CLI   FTLIB,C'Y'      DOES USER HAVE ISPTLIB ALLOCATED?\n         BE    ALLTABL         IF SO BRANCH TO CHECK FOR ISPTABL\n         LA    R3,TLIBTABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES\nALLTABL  DS    0H\n         CLI   FTABL,C'Y'      DOES USER HAVE ISPTABL ALLOCATED?\n         BE    ALLFILE         IF SO BRANCH TO CHECK FOR ISPLLIB\n         LA    R3,TABLTABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES\nALLFILE  DS    0H\n         CLI   FFILE,C'Y'      DOES USER HAVE ISPTABL ALLOCATED?\n         BE    ALLLLIB         IF SO BRANCH TO CHECK FOR ISPLLIB\n         LA    R3,FILETABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES\nALLLLIB  DS    0H\n         CLI   FLLIB,C'Y'      DOES USER HAVE ISPLLIB ALLOCATED?\n         BE    FIN             IF SO BRANCH TO CHECK FOR ISPLLIB\n         LA    R3,LLIBTABL     LOAD ADDRESS OF TABLE\n         BAL   R11,ALLOCTAB    BRANCH TO ALLOCATE FILES\n         EJECT\nFIN      DS    0H\n         L     R1,CPPLPNTR        LOAD THE ADDRESS OF THE CPPL PNTR\n         L     R2,SAVEAREA+4      LOAD THE ADDRESS OF PREV SAVE AREA\n         ST    R1,0(R2)           SAVE THE ADDRESS OF THE CPPL PNTR\n         XAFIN  RETURN=NO,RC1=(R12),GEN=GEN\n         LR    R12,R1             RESTORE ADDRESSABILITY FOR XCTL\n         L     R1,0(R13)          LOAD ADDRESS OF CPPL PNTR\n         XCTL  EP=PDF\n         EJECT\n*\n      EJECT\n**************************************************************\n**** ALLOCATE FILE                                        ****\n****     ON ENTER:  R3 ===> DDNAME                        ****\n****                R4 ===> DSN  (LEN(2) DSN(44))         ****\n****                R5 ===> ATTRIB LIST (OR ZERO)         ****\n****     ON EXIT    R3 ===> DDNAME ALLOCATED              ****\n****     USES REGS: R3 R4 R1 R8 R14 R15                   ****\n**************************************************************\nALLOCATE DS    0H\n         STM   R1,R11,ALLOCSV          STORE REGS\n         MVC   DAP08DDN(8),0(R3)       MOVE IN DDNAME\n         LTR   R5,R5                   CHECK FOR ATTRIBUTE LIST\n         BZ    CLRALN                  IF ZERO CLEAR ATTR LIST\n         MVC   DAP08ALN(8),0(R5)       MOVE IN ATTRIBUTE NAME\n         B     STDSNADR                GO TO STORE DSN\nCLRALN   MVC   DAP08ALN(8),=CL8' '     CLEAR ATTR LIST\nSTDSNADR ST    R4,DAP08DSN             STORE ADDRESS OF DATA SET NAME\n         SR    R4,R4                   ZERO REGISTER 4\n         ST    R4,ECB                  STORE REGISTER 4 AS ECB\n         MVC   DAP08CD(2),=X'0008'     MOVE IN ALLOCATE CODE\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         LA    R8,DAPB08C              LOAD ADDRESS OF DAP08\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1                      DROP ADDRESSABILITY TO DAPL\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    ALRTN                   IF OK THEN RETURN TO CALLER\n         MVC   DFID,DFIDI              SET UP DFID FIELD\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE\n*                                      ERROR MESSAGE PUT OUT\nALRTN    DS    0H\n         LM    R1,R11,ALLOCSV    RESTORE REGS\n         LA    R3,DAP08DDN       RETURN ADDRESS OF DDNAME\n         BR    R11\n      EJECT\n**************************************************************\n**** ALLOCATE FILES FROM TABLES                           ****\n****     ON ENTER:  R3 ===> TABLE ADDRESS                 ****\n**************************************************************\nALLOCTAB DS    0H\n         STM   R1,R11,ALLOTSV          STORE REGS\n         MVC   HOLDDDNM(8),0(R3)             SAVE DDNAME\n         L     R6,8(R3)                      LOAD DSN COUNT INTO R6\n         LTR   R6,R6         MAKE SURE THERE IS DSN(S) TO ALLOCATE\n         BZ    ALTABDON      IF NOT THEN EXIT\n         LA    R2,12(R3)                     POINT AT FIRST DSN\n         USING DDNTDSCT,R2\n         SR    R3,R3                         CLEAR R3\n         STH   R3,DDNAMCNT        CLEAR DDNAME TABLE COUNT\nALTABLP  DS    0H\n         SR    R5,R5              CLEAR R5, NO ATTRIB LIST\n         LA    R3,HOLDDDNM        POINT AT DDNAME TO USE\n         LA    R4,DDNDSN          POINT R4 AT DSN TO ALLOC\n         BAL   R11,ALLOCATE       CALL ALLOCATE\n         CLC   0(3,R3),=C'SYS'  IS IT A 'SYS' DD NAME?        * #2 *\n         BE    ITSASYS                                        * #2 *\n         CLC   DDNAMCNT,=H'0'     WAS THERE ONLY ONE?         * #2 *\n         BE    ITSASYS            IF SO OK                    * #2 *\n         MVC   HOLDDDNM(8),=CL8' ' CLEAR DDNAME TO ALLOCATE   * #2 *\n         B     ALTABLP                                        * #2 *\nITSASYS  DS    0H                                             * #2 *\n         LH    R5,DDNAMCNT        LOAD DDNAME TABLE COUNT\n         LA    R5,1(R5)           INCREMENT COUNT\n         STH   R5,DDNAMCNT        UPDATE COUNT\n         BCTR  R5,R0              DECREMENT BACK FOR CALCULATION\n         M     R4,=F'8'           MULTIPLY BY NAME LENGTH\n         LA    R4,DDNAMTAB        POINT AT START OF TAB\n         AR    R5,R4              GET DISPLACEMENT TO NEXT OPEN SLOT\n         MVC   0(8,R5),0(R3)      MOVE IN DDNAME ALLOCATED\n         MVC   HOLDDDNM(8),=CL8' ' CLEAR DDNAME TO ALLOCATE\n         LA    R2,DDNNEXT         UPDATE TABLE POINTER\n         BCT   R6,ALTABLP         DECREMENT TABLE COUNT, REPEAT\n         LH    R6,DDNAMCNT        LOAD DDNAME COUNT\n         C     R6,=F'1'           WAS THERE ONLY ONE?\n         BE    ALTABDON           IF SO GO TO EXIT.\n         SR    R5,R5              SET R5 TO ZEROES\n         STH   R5,DA0CFLG         SET FLG TO ZEROES\n         STH   R5,DA0CDARC        SET ERROR CODE TO ZEROES\n         STH   R5,DA0CR1          SET TO ZEROES\n         STH   R5,DA0CR2          SET TO ZEROES\n         ST    R5,ECB                  STORE REGISTER 4 AS ECB\n         MVC   DA0CCD(2),=X'000C'      MOVE IN CONCATINATE CODE\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         LA    R8,DA0CCD               LOAD ADDRESS OF DA0CCD\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1                      DROP ADDRESSABILITY TO DAPL\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO CONCATINATE DDNAMES\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    ALTABDON                IF OK THEN RETURN TO CALLER\n         MVC   DFID,DFIDI              SET UP DFID FIELD\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE\n*                                      ERROR MESSAGE PUT OUT\nALTABDON DS    0H\n         LM    R1,R11,ALLOTSV    RESTORE REGS\n         BR    R11\n         DROP  R2\n        EJECT\n***********************************************************************\n*    FILL THE TABLE ENTRY                                             *\n*      R3===> TABLE ENTRY COUNT, +4 ===> FIRST TABLE ENTRY            *\n*      R4===> START OF DSNAME TO MOVE INTO TABLE                      *\n***********************************************************************\n*\nFILLTAB  DS    0H             FILL TABLE WITH FILE\n         STM   R1,R11,FILLTSV          STORE REGS\n         LA    R8,4(R3)       POINT AT FIRST ENTER\n         LR    R10,R4         SAVE POINTER TO DSN\n         L     R5,0(R3)       LOAD CURRENT ENTRY COUNT\n         LA    R5,1(R5)       INCREMENT COUNT BY 1\n         C     R5,=F'16'     MORE THAN POSSIBLE ENTRIES?\n         BE    TOMANYLB       IF TOO MANY LIBS TELL USER\n         ST    R5,0(R3)       STORE NEW VALUE\n         BCTR  R5,0           SET COUNT DOWN BY ONE\n         M     R4,=F'46'      MULTIPLY BY LENGTH OF ENTRY\n         AR    R8,R5          SET R8 TO FIRST EMPTY ENTRY ADDRESS\n         USING DDNTDSCT,R8\n         SR    R2,R2          SET R2 TO ZERO\nLOOPCHK  DS    0H\n         LR    R6,R2\n         AR    R6,R10\n         CLI   0(R6),C' '  CHECK FOR A BLANK\n         BE    FOUNDEND       IF SPACE FOUND\n         C     R2,=F'44'      LARGER THAN POSSIBLE DSN?\n         BE    BADDSNMS       IF BAD LENGTH GIVE USER MESSAGE\n         LA    R2,1(R2)       SET R2 UP BY ONE\n         B     LOOPCHK        CHECK NEXT BYTE\nFOUNDEND DS    0H\n         STH   R2,DDNDSNLN       STORE LENGTH OF\n         MVC   DDNDSNNM(44),=CL44' ' SPACE OUT DSN FIELD\n         BCTR  R2,0                DECREMENT R2 BY 1\n         EX    R2,MOVEDSN          MOVE IN THE DSN\nFILLEXIT LM    R1,R11,FILLTSV    RESTORE REGS\n         BR    R11\nBADDSNMS DS    0H\n         TPUT  =C'SYSXXXE - BAD DSN LENGTH, LIBRARY IGNORED',40\n         TPUT  (R10),80\n         TPUT  =C'SYSXXXE - THE ABOVE CARD IS IGNORED      ',40\n         L     R2,0(R3)       LOAD CURRENT ENTRY COUNT\n         BCTR  R2,0           SET COUNT DOWN BY ONE\n         ST    R2,0(R3)       STORE NEW VALUE\n         B     FILLEXIT\nTOMANYLB DS    0H\n         TPUT  =C'SYSXXXE - TO MANY LIBRARIES, USE NO MORE THAN 16',47\n         TPUT  (R10),80\n         TPUT  =C'SYSXXXE - THE ABOVE CARD IS IGNORED      ',40\n         B     FILLEXIT\nMOVEDSN  MVC   DDNDSNNM(0),0(R10)   MOVE IN DSN\n         DROP  R8\n      EJECT\n**************************************************************\n**** FREE DDNAME                                          ****\n****     ON ENTER:  R3 ===> DDNAME                        ****\n****     USES REGS:                                       ****\n**************************************************************\nFREEDDNM DS    0H\n         STM   R1,R11,FREEDDSV         STORE REGS\n         MVC   DAP18DDN(8),0(R3)       MOVE IN DDNAME\n         SR    R4,R4                   CLEAR REG 4\n         ST    R4,ECB                  STORE REGISTER 4 AS ECB\n         MVC   DAP18CD(2),=X'0018'     MOVE IN ALLOCATE CODE\n         LA    R1,DAPLSECT             LOAD ADDRESS OF DAPL\n         LA    R8,DAPB18C              LOAD ADDRESS OF DAPB18C\n         USING DAPL,R1                 ESTABLISH ADDRESSABILITY TO DAPL\n         ST    R8,DAPLDAPB             STORE ADDRESS OF DAPB IN DAPL\n         DROP  R1                      DROP ADDRESSABILITY TO DAPL\n         CALLTSSR EP=IKJDAIR           CALL DAIR TO ALLOCATE DATASET\n         LTR   R15,R15                 SEE IF RETURN CODE IS ZERO\n         BZ    FRRTN                   IF OK THEN RETURN TO CALLER\n         MVC   DFID,DFIDI              SET UP DFID FIELD\n         MVI   DFID+1,DFDAIR           SET DAIRFAIL ID TO INDICATE DAIR\n         BAL   R2,DAIRFAIL             GO TO DAIRFAIL ROUTINE TO HAVE\n*                                      ERROR MESSAGE PUT OUT\nFRRTN    DS    0H\n         LM    R1,R11,FREEDDSV    RESTORE REGS\n         BR    R11\n        EJECT\n***********************************************************************\n*                                                                     *\n*        INVOKE DAIRFAIL TO DISPLAY AN ERROR MESSAGE                  *\n*                                                                     *\n***********************************************************************\n*\nDAIRFAIL XC    DFPARMS(DFLEN),DFPARMS  INITIALIZE PARMLIST FOR DAIR\n*                                      FAIL TO ZEROS\n         ST    R1,DFDAPLP              STORE POINTER TO DAPL/RB IN\n*                                      PARAMETER LIST\n         ST    R15,RETCODE             STORE RETURN CODE\n         LA    R1,RETCODE              LOAD ADDRESS OF RETURN CODE\n         ST    R1,DFRCP                STORE POINTER TO RETURN CODE IN\n*                                      PARAMETER LIST\n         LA    R1,=F'0'                LOAD ADDRESS OF FULLWORD OF\n*                                      ZEROS\n         ST    R1,DFJEFF02             STORE DUMMY POINTER TO IKJEFF02\n*                                      IN PARMLIST\n         LA    R1,DFID                 LOAD ADDRESS OF DAIR FAIL ID\n*                                      FIELD\n         ST    R1,DFIDP                STORE POINTER TO DFID IN\n*                                      PARMLIST\n         L     R1,SAVEAREA+4           LOAD ADDRESS OF PEVIOUS\n*                                      SAVEAREA\n         L     R1,24(R1)               LOAD POINTER TO CPPL\n         ST    R1,DFCPPLP              STORE POINTER TO CPPL IN\n*                                      PARMLIST\n         LINK  EP=IKJEFF18,MF=(E,DFPARMS)  LINK TO DAIR FAIL SERVICE\n*                                      ROUTINE TO HANDLE RETURN\n*                                      CODE\n         XAFIN\n         LTORG\n***************************** CONSTANTS *******************************\n*\n*\nDFIDI    DC    X'0001' NO WTP, DAIRFAIL\nWPROFILE DC    CL8'WPROFILE'\n*\n******************** DAIR CONTROL BLOCK CONSTANTS *********************\nDAPB08CI DS    0F\n         DC    X'0008'                 DA08CD\n         DC    H'0'                    DA08FLG\n         DC    H'0'                    DA08DARC\n         DC    H'0'                    DA08CTRC\n         DC    A(0)                    DA08PDSN\n         DC    CL8'        '           DA08DDN\n         DC    CL8' '                  DA08UNIT\n         DC    CL8' '                  DA08SER\n         DC    F'0'                    DA08BLK\n         DC    F'0'                    DA08PQTY\n         DC    F'0'                    DA08SQTY\n         DC    F'0'                    DA08DQTY\n         DC    CL8' '                  DA08MNM\n         DC    CL8' '                  DA08PSWD\n         DC    X'08'                   DA08DSP1      SHR\n         DC    X'08'                   DA08DSP2      KEEP\n         DC    X'08'                   DA08DSP3      KEEP\n         DC    X'08'                   DA08CTL       PERM\n         DC    F'0'                    DA08DSO\n         DC    CL8' '                  DA08ALN\nDAPB08L  EQU   *-DAPB08CI              LENGTH\n        SPACE 3\nDAPB18CI DS    0F\n         DC    X'0018'                 DA18CD\n         DC    H'0'                    DA18FLG\n         DC    H'0'                    DA18DARC\n         DC    H'0'                    DA18CTRC\n         DC    A(0)                    DA18PDSN\n         DC    CL8'        '           DA18DDN\n         DC    CL8' '                  DA18MNM\n         DC    H'0'                    DA18CLS\n         DC    X'00'                   DA08DSP2\n         DC    X'10'                   DA08CTL\n         DC    8X'00'                  RESERVED\nDAPB18L   EQU   *-DAPB18CI              LENGTH\n        SPACE 3\nISPIIMAG DCB   DDNAME=WPROFILE,DSORG=PO,MACRF=R,EODAD=FINI\nLISPIIMA EQU   *-ISPIIMAG\nISPIIMAX DCB   DDNAME=WPROFILE,DSORG=PS,MACRF=GM,EODAD=FINI\nLISPIIMX EQU   *-ISPIIMAX\nOPNIMAGE OPEN  (ISPIIMAG,INPUT),MF=L\nLOPNIMAG EQU   *-OPNIMAGE\nCLOIMAGE CLOSE (),MF=L\nLCLOIMAG EQU   *-CLOIMAGE\n*PROIMAGE DCB   EXLST=PROIMAGE,DDNAME=ISPPROF,DSORG=PO,MACRF=R\n*LPDCIMAG EQU   *-PROIMAGE\n         EJECT\n         SPACE 2\n         IKJDAP08\nDAP08LEN EQU   *-DAPB08\n         IKJDAPL\nDAPLLEN  EQU   *-DAPL\n         IKJCPPL\nCPPLLEN  EQU   *-CPPL\n         IKJDFPB\n         CVT DSECT=YES\n         SPACE 4\n         IKJTCB                                                  * #1 *\n         IEZJSCB                                                 * #1 *\nDSAB     IHADSAB                                                 * #1 *\nTIOT     DSECT                                                   * #1 *\n         IEFTIOT1                                                * #1 *\n         EJECT\nDDNTDSCT DSECT\nDDNDSN   DS   0H                     FILE NAME LENGTH AND NAME\nDDNDSNLN DS    H                     FILE NAME LENGTH\nDDNDSNNM DS    CL44                  FILE NAME\nDDNNEXT  DS    0H                    NEXT DDN TABLE ENTERY\n        EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\n         DS    0D\nDAP08    DS    0F\n         ORG   DAP08+DAP08LEN\nDAPLSECT DS    0F\n         ORG   DAPLSECT+DAPLLEN\nDFPLSECT DS    4F                   SPACE FOR DFPL\nDFPBSECT DS    5F                   SPACE FOR DFPB\n         DS    H                    TO GET ALLIGNMENT\nDFPBDSL  DS    H                    DSNAME LENGTH\nDFPBNAME DS    CL44                 DSNAME\nDFPBQUA  DS    CL8\nECB      DS    F\nRETCODE  DS    F\n         SPACE 4\nCPPLPNTR DS    A               HOLD ADDRESS OF CPPL POINTER\nDFID     DS    XL2             '0001' NO WTP, DAIRFAIL\nDAPB08C  DS    0F\nDAP08CD  DS    XL2   '0008'            DA08CD\n         DS    H                       DA08FLG\n         DS    H                       DA08DARC\n         DS    H                       DA08CTRC\nDAP08DSN DS    A                       DA08PDSN\nDAP08DDN DS    CL8                     DA08DDN\n         DS    CL8                     DA08UNIT\n         DS    CL8                     DA08SER\n         DS    F                       DA08BLK\n         DS    F                       DA08PQTY\n         DS    F                       DA08SQTY\n         DS    F                       DA08DQTY\nDAP08MNM DS    CL8                     DA08MNM\n         DS    CL8                     DA08PSWD\n         DS    X                       DA08DSP1      SHR\nDAP08DSP DS    X                       DA08DSP2      KEEP\n         DS    X                       DA08DSP3      KEEP\n         DS    X                       DA08CTL       PERM\n         DS    F                       DA08DSO\nDAP08ALN DS    CL8                     DA08ALN\n        SPACE 3\nDAPB18C  DS    0F\nDAP18CD  DC    X'0018'                 DA18CD\n         DC    H'0'                    DA18FLG\n         DC    H'0'                    DA18DARC\n         DC    H'0'                    DA18CTRC\n         DC    A(0)                    DA18PDSN\nDAP18DDN DC    CL8'        '           DA18DDN\n         DC    CL8' '                  DA18MNM\n         DC    H'0'                    DA18CLS\n         DC    X'00'                   DA08DSP2\n         DC    X'00'                   DA08CTL\n         DC    8X'00'                  RESERVED\n        SPACE 4\n         IKJEFFDF\n        SPACE 4\nALLOCSV  DS    12F\nALLOTSV  DS    12F\nFILLTSV  DS    12F\nFREEDDSV DS    12F\n        SPACE 4\nSYSPRGMR DC    C'N'     SYSTEMS PROGRAMMER FLAG\nSYSPROC  DC    C'N'     SYSPROC PRESENT FLAG\nFPROF    DC    C'N'     FLAG FOR ISPPROF\nFPLIB    DC    C'N'     FLAG FOR ISPPLIB\nFMLIB    DC    C'N'     FLAG FOR ISPMLIB\nFTABL    DC    C'N'     FLAG FOR ISPTABL\nFTLIB    DC    C'N'     FLAG FOR ISPTLIB\nFSLIB    DC    C'N'     FLAG FOR ISPSLIB\nFLLIB    DC    C'N'     FLAG FOR ISPLLIB\nFFILE    DC    C'N'     FLAG FOR ISPFILE\nNPLIB    DC    C'Y'     FLAG FOR ISPPLIB DEFAULT\nNMLIB    DC    C'Y'     FLAG FOR ISPMLIB DEFAULT\nNTLIB    DC    C'Y'     FLAG FOR ISPTLIB DEFAULT\nNLLIB    DC    C'Y'     FLAG FOR ISPLLIB DEFAULT\nNTABL    DC    C'N'     FLAG FOR ISPTABL DEFAULT\nNFILE    DC    C'N'     FLAG FOR ISPFILE DEFAULT\nNSLIB    DC    C'Y'     FLAG FOR ISPSLIB DEFAULT\nNCLIB    DC    C'Y'     FLAG FOR SYSPROC DEFAULT\n         SPACE 4\nPROFILE  DS    CL8      AREA TO HOLD THE PROFILE NAME     * # 3 *\nPROFDSNP DS    H        PROFILE DATA SET NAME LENGTH (18)\nPROFDSN  DS    0CL44    PROFILE DATA SET NAME\n         DS    CL12     'TSO.PROFILE.'\nPROFDPID DS    CL6      USER'S DPID\n         DS    CL26     FILLER\n         SPACE 2\nISPPARMI DCB   DDNAME=WPROFILE,DSORG=PS,MACRF=GM,EODAD=FINI\nOPENLIST OPEN  (,),MF=L\nCLOSLIST CLOSE (),MF=L\n*PROFJFCB DCB   EXLST=PROIMAGE,DDNAME=ISPPROF,DSORG=PO,MACRF=R\nPARMREC  DS    CL80\n*\nHOLDDDNM DS    CL8      AREA TO HOLD DDNAME FOR ALLOCATE\n*\n**********    CONCATINATE DDNAMES CONTROL BLOCK  **************\nDA0CCD     DS    H               SET TO X'000C'\nDA0CFLG    DS    H               SET TO ZEROES\nDA0CDARC   DS    H               ERROR CODE\nDA0CR1     DS    H               SET TO ZEROES\nDDNAMCNT   DS    H               COUNT OF DDNAME TABLE ENTRIES\nDA0CR2     DS    H               SET TO ZEROES\nDDNAMTAB   DS    8CL8           TABLE TO HOLD 10 DD NAMES FOR ALLOCATE\nFLAG     DS    X                                                 * #1 *\n*\n*JFCBA    DS    F                 X'07',AL3(JFCBAREA)\n*JFCBAREA DS    0F\n*JFCBDSN  DS    44X                    X'00'\n*         DS    132X                   X'00'\n*JFCBDSLN DS    F                      TO HOLD DSN LENGTH\n*\n**** LIBRARY TABLES\n           DS     0D             START OF TABLE AREA\nCLIBTABL   DS     CL8            DD NAME\nCLIBTABC   DS     F              NUMBER OF ENTRIES\nCLIBTABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\nPLIBTABL   DS     CL8            DD NAME\nPLIBTABC   DS     F              NUMBER OF ENTRIES\nPLIBTABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\nMLIBTABL   DS     CL8            DD NAME\nMLIBTABC   DS     F              NUMBER OF ENTRIES\nMLIBTABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\nSLIBTABL   DS     CL8            DD NAME\nSLIBTABC   DS     F              NUMBER OF ENTRIES\nSLIBTABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\nTLIBTABL   DS     CL8            DD NAME\nTLIBTABC   DS     F              NUMBER OF ENTRIES\nTLIBTABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\nTABLTABL   DS     CL8            DD NAME\nTABLTABC   DS     F              NUMBER OF ENTRIES\nTABLTABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\nLLIBTABL   DS     CL8            DD NAME\nLLIBTABC   DS     F              NUMBER OF ENTRIES\nLLIBTABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\nFILETABL   DS     CL8            DD NAME\nFILETABC   DS     F              NUMBER OF ENTRIES\nFILETABE   DS    CL736          16 * LENGTH(H) AND DSN(CL44)\n*\nLSAVAREA EQU   *-SAVEAREA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPFDOC": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "                 ISPF/PDF Preprocessor\n\n   To get into ISPF/PDF you must use the WSRCC ISPF/PDF Preprocessor\n SPF.  SPF will allocate all of the required ISPF/PDF files and\n optionaly concatinate any special files specified.\n\n   When you enter the command \"SPF\" the program goes thru the DDnames\n allocated to your TSO session and only allocates the ISPF/PDF required\n DDnames that are not already allocated.  If you want to add your\n libraries to the allocated ISPF/PDF libraries you can do it by creating\n a member in your TSO.PROFILE.Logon-id file called WPROFILE.  The \"SPF\"\n preprocessor looks for a WPROFILE member before allocating the ISPF/PDF\n files.  If it finds a member it will read and process the entries which\n are used to modify what files get allocated for ISPF/PDF.  You must\n code the entries in your WPROFILE member carefully because the\n preprocessor is Position and Syntax sensative.  There are 9 types of\n data lines that can be entered, the first type being a comment.  Lines\n begining with an '*' are treated as comments.  The other 8 types start\n with a 4 character type identifier that describes the DDname under\n which it should be allocated. After the 4 character identifier is a\n space and then a dataset name (without quotes).  The datasets are\n allocated ahead of the default libraries and in the same order as they\n are entered in the WPROFILE member, the order is maintained even if all\n the entries of one type are not together.\n\n    The WPROFILE member entry types that can be coded are:\n\n        *    - Comment line\n        CLIB - ISPF CLIST LIBRARY\n        PLIB - ISPF Panel LIBRARY\n        MLIB - ISPF Message LIBRARY\n        SLIB - ISPF Skeleton LIBRARY\n        TLIB - ISPF Table LIBRARY\n        LLIB - ISPF Load LIBRARY\n        TABL - ISPF Table FILE\n        FILE - ISPF Table FILE\n\n    A SAMPLE WPROFILE MEMBER:\n\n                **********************************\n                ** WPROFILE LIBRARIES           **\n                **********************************\n                CLIB ADM.DP59022.SRCLIB\n                PLIB ADM.DP59022.SRCLIB\n                MLIB ADM.DP59022.SRCLIB\n\n    All libraries that you add must have blocksizes of 9040 or larger,\n except for the Load Library LLIB.\n\n    If you do not wish to have the default libraries allocated after\n your files, or if you are including the default libraries in your\n WPROFILE member, you must code the 4 character identifier and a space\n and the keyword \"NODEFAULT\" (or \"NODEF\"). This tells the preprocessor\n NOT to allocate the default libraries.  There is no default for TABL.\n\n    All of the DDnames referred to are ISP and then the 4 character type\n identifier (example: PLIB ==> ISPPLIB), except for CLIB.  The DDname\n that CLIB modfies is SYSPROC.\n\n    If you modify your (or create a) WPROFILE member you must go out of\n ISPF/PDF and free the DDname(s) for which you made a change or entry,\n and then invoke \"SPF\", otherwise the change will not take effect.  The\n SYSPROC (CLIB) DD will not be freed with a FREEALL command, you must\n FREE DD(SYSPROC) to free it.\n\n    You can have more than one \"WPROFILE\" member to control the\n allocation of ISPF/PDF Files.  To create a different member just\n change the \"W\" to some other letter (as in APROFILE) and then to\n specify which PROFILE member to use you invoke the ISPF/PDF\n preprocessor with: \"SPF <A\" (to use APROFILE).\n\n    If you do not want any \"WPROFILE\" member used you can invoke\n ISPF/PDF with: \"SPF </\".\n\n    SPF is set up to recognize any user with a \"SYSSPF DD DUMMY\"\n DD card in their TSO LOGON PROC as a Systems programmer.\n\n    SPF is only set up to use 6 character LOGON-IDs.\n\n    SPF Requires a ISPF/PDF PROFILE PDS with the name:\n        TSO.PROFILE.logon-ID\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STACK": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         TITLE 'STACK CP - PUT OUTPUT OF TSO CMD TO A FILE'\nSTACK    ENTERR LEVEL=V1M3\n         LR    R11,R1                   R11 -> CPPL\n         USING CPPL,R11\n         EJECT\n**********************************************************************\n*       MAINLINE PROCESSING CONTROL ROUTINE:                         *\n**********************************************************************\n*\n*              FIRST STEP IS EXTRACT OUR OPERANDS FROM COMMAND:\n*\nB4       BAL   R14,PB                   FIX BUFFER\n         LTR   R15,R15                  OK?\n         BNZ   TERMWERR                 NO\n*\n*              NOW GET SET UP\n*\n         BAL   R14,STACKME              STACK AND GET CMD\n         LTR   R15,R15                  OK?\n         BNZ   TERMWERR                 NO\n*\n*              DO THE CMD\n*\n         BAL   R14,ATTACHME             CALL HIM\n*        LTR   R15,R15                  OK?\n*        BNZ   TERM                     NO\n*\n*              REMOVE FROM STACK ?:\n*\n         BAL   R14,UNSTACKM             REMOVE TOP IF WE ADDED\n         EJECT\n         L     R15,AECB                 GET CMD RC IF NORMAL\n         SPACE 3\nTERM     LEAVER\n         SPACE 3\nTERMWERR WTP   'ERROR HAS OCCURED IN STACK CMD'\n         B     TERM\n         EJECT\n*\n*        PB -  PROCESS BUFFER TO REMOVE AND FLAG OUR OPERANDS\n*\nPB       ST    R14,L1LS\n*\n*       FIRST BUILD KOMAND-PROCESSING PARAMETER LIST:\n*\nBPI      XC    KPPL(40),KPPL            CLEAR BUFFER PROC PARMLIST\n         L     R10,0(,R11)              R10 -> CBUF\n         ST    R10,CBUFPTR              BUFFER PTR\n         LA    R10,OPLIST               OPERAND LIST\n         ST    R10,OPLSTPTR             PASS IT\n         LA    R9,FLAG                  FLAG AREA\n         ST    R9,FLAGPTR               PASS IT\n         LA    R8,UNKNEX                EXIT FOR OPS NOT IN MY LIST\n         ST    R8,UNKNEXIT              PASS IT\n         LA    R6,L1LS                  WORK AREA FOR EXIT\n         ST    R6,EXITPARM              PASS IT TO THE EXIT\n         LA    R7,FASTAREA              R7 -> OPLEN AREA\n         ST    R7,WORKPASS              LENGTH PTR RETURN AREA\n         XC    OPFLAG,OPFLAG            CLEAR OPERANDS PRESENT FLAG\n*\n*       THEN CALL KMDPARS (PARSE SUBROUTINE):\n*\n         LA    R1,KPPL                  R1 -> BUFFER PROC PARMLIST\nDOPO     CALL  KMDPARS                  PROCESS AN OPERAND\n         LTR   R15,R15                  ANYTHING FOUND?\n         BNZ   BPT                      YES\n         OI    OPFLAG,X'FF'\n*\n*       SAY DONE AND EXIT:\n*\nBPT      SLR   R15,R15                  RC=0\n         L     R14,L1LS\n         BR    R14\n*\n*   THIS EXIT SETS A FLAG IF ANY OPERANDS WHICH ARE NOT KNOWN ARE HERE:\n*\nUNKNEX   L     R1,0(,R1)                R1 -> L1LS\n         USING L1LS,R1\n         OI    UNKNFLAG,X'FF'           SET IT ON\n         SLR   R15,R15                  RC = 0  SAY OK TO CONTINUE\n         BR    R14                      RETURN TO KMDPARS\n         DROP  R1\n         EJECT\n*\n*   THIS EXIT SAVES THE DDNAMES:\n*\nDDINS    LA    R15,12(,R15)\nDDOUTS   LA    R15,12(,R15)\nTASKSV   LA    R15,10(,R15)\nDDSENT   STM   R14,R12,12(R13)          SAVE REGS\n         BALR  R11,R0                   R11->DDSTART\n         USING DDSTART,R11\nDDSTART  LA    R11,0(,R11)              CLR HI BYTE\n         SR    R15,R11                  R15 = 16,8,OR 0\n         L     R10,0(,R1)               R10-> L1LS\n         USING L1LS,R10\n         L     R9,4(,R1)                R9->BPPL\n         USING BPPL,R9\n         L     R8,SUBPTR                R8->SUB FLD\n         LTR   R8,R8                    ANY?\n         BZ    TRUBELL                  NO\n         L     R7,SUBLENPT              R7->SUBFLD LEN\n         LH    R6,0(R7)                 R6=SUBLEN\n         SH    R6,=H'3'                 -3 FOR PARENS AND EX\n         MVC   DDSAVE(8),=CL8' '        BLANK FILL\nRMVC     MVC   DDSAVE(0),1(R8)          EX ED MVC\n         EX    R6,RMVC                  SAVE IT\n         LA    R5,TASKDD(R15)           PT TO CORRECT AREA FOR THIS GUY\n         MVC   0(8,R5),DDSAVE           MOVE HIM TO HIS SLOT\nTRUBELL  LM    R14,R12,12(R13)          RESTORE REGS\n         SLR   R15,R15                  RC = 0  SAY OK TO CONTINUE\n         BR    R14                      RETURN TO KMDPARS\n         DROP  R11\n         DROP  R10\n         DROP  R9\n         USING CPPL,R11\n         EJECT\n*\n*   THIS ROUTINE STACKS THE DATASETS AND GETS THE CMD:\n*\nSTACKME  ST    R14,L1LS\n*\n         TM    FLAG,X'80'               DDIN PRESENT?\n         BO    STCK                     YES->DOIT\nGETPRE   BAL   R14,GETL                 NO-> GET THE CMD FIRST\n         LTR   R15,R15            OK?\n         BNZ   STEX               NO\n         SPACE\nSTCK     TM    FLAG,X'C0'               ANY DD TO STACK?\n         BZ    GETPOST                  NO\nSTACKIT  BAL   R14,ADDIT                YES->DOIT\n         LTR   R15,R15            OK?\n         BNZ   STEX               NO\n         SPACE\nGETPOST  TM    FLAG,X'80'               DDIN PRES?\n         BNO   PUTCK                    NO->WE ALREADY DID THIS\n         BAL   R14,GETL                 YES-> GET CMD\n         LTR   R15,R15            OK?\n         BNZ   STEX               NO\n         SPACE\nPUTCK    TM    FLAG,X'10'               LIST?\n         BNO   STEX\n         BAL   R14,PUTL                 YES-> ECHO CMD\n         SPACE\nSTEX     L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*   THIS ROUTINE STACKS THE DDNAME:\n*\nADDIT    ST    R14,L2LS\n*\n         L     R7,CPPLUPT               R7->UPT\n         L     R6,CPPLECT               R6->ECT\n         TM    FLAG,X'80'               DDIN PRES?\n         BZ    SE2                      NO\n         SPACE 2\nSE       STACK PARM=STPB,UPT=(R7),ECT=(R6),ECB=ECB,                    X\n               DATASET=(OUTDD=DDOUT,CNTL,SEQ,INDD=DDIN),MF=(E,IOPL)\n         SPACE\n         B     ADDX\n         EJECT\n*\nSE2      STACK PARM=STPB,UPT=(R7),ECT=(R6),ECB=ECB,                    X\n               DATASET=(OUTDD=DDOUT,CNTL,SEQ),                         X\n               MF=(E,IOPL)\n         SPACE 3\nADDX     LTR   R15,R15            STACK OK?\n         BNZ   AXT                NO\n         SPACE\n         OI    28(R6),X'02'             PRETEND BACKGROUND\n         SPACE\n         L     R5,4(,R6)          R5->IOSRL\n         MVC   SAVELEM(4),4(R5)   SAVE BOTTOM OF STACK PTR\n         MVC   4(4,R5),0(R5)      PRETEND ONLY ONE ELEMENT IN STACK\n*              (PREVENTS SUBTASK FROM TRYING TO DELETE IT)\n         SPACE\nAXT      L     R14,L2LS\n         BR    R14\n         EJECT\nGETL     ST    R14,L2LS\n         L     R7,CPPLUPT               R7->UPT\n         L     R6,CPPLECT               R6->ECT\n         SPACE 3\n         GETLINE  PARM=GTPB,UPT=(R7),ECT=(R6),ECB=ECB,                 X\n               INPUT=(ISTACK,LOGICAL),TERMGET=(EDIT,WAIT),MF=(E,IOPL)\n         SPACE 3\n         C     R15,=F'4'          RC=4\n         BNE   GETX               NO->LEAVE IT\n         SLR   R15,R15            4 SAME AS 0\n         SPACE 3\nGETX     L     R14,L2LS\n         BR    R14\n         EJECT\nPUTL     ST    R14,L2LS\n         L     R5,GTPB+4\n         SPACE 3\n         PUTLINE  PARM=PUTLIST,UPT=(R7),ECT=(R6),ECB=ECB,              X\n               OUTPUT=((R5),TERM,SINGLE,DATA),MF=(E,IOPL)\n         SPACE 3\nPUTX     L     R14,L2LS\n         BR    R14\n         EJECT\n*\n*        THIS  ROUTINE ATTACHES THE CMD:\n*\nATTACHME ST    R14,L1LS\n         SPACE 2\n         BAL   R14,SCAN                 SCAN FOR A CMD NAME\n         LTR   R15,R15                  OK?\n         BNZ   AEX                      NO\n*\n*              CALL APPROPRIATE ATTACH SUBRTN:\n*\n         TM    FLAG,X'20'               TASKDD PRES?\n         BNO   NTL                      NO\n         BAL   R14,AWTL                 YES->ATTACH WITH TASKLIB\n         B     AEX                      GOON\n         SPACE\nNTL      BAL   R14,AWNTL                ATTACH W/NO TASKLIB\n         SPACE 2\nAEX      L     R14,L1LS\n         BR    R14\n         EJECT\nSCAN     ST    R14,L2LS\n         LA    R10,CSPLA                R10->CSPL\n         USING CSPL,R10\n         LA    R9,CSOAA                 R9->CSOA\n         USING CSOA,R9\n         XC    CSPLA(9),CSPLA\n         MVC   CSPLUPT,CPPLUPT\n         MVC   CSPLECT,CPPLECT\n         LA    R8,ECB             R8->ECB\n         ST    R8,CSPLECB\n         LA    R7,CSOAF           R7->CSOAF\n         ST    R7,CSPLFLG\n         ST    R9,CSPLOA\n         L     R1,GTPB+4                R1->CBUF\n         ST    R1,CSPLCBUF              PASS CBUF TO SCAN\n         CLI   4(R1),C'0'               FIRST CHAR < 0 ?\n         BL    SCANIT                   YES->NO LINE NUMBER\n         MVC   4(8,R1),=CL8' '          NO->KILL LINE NUMBER\n         SPACE\nSCANIT   LR    R1,R10                   R1->CSPL\n         CALLTSSR EP=IKJSCAN\n         LTR   R15,R15\n         BNZ   SCANEX\n         EJECT\n         TM    CSOAFLG,X'C0'      ANY?\n         BNZ   GCN                YES\nSCANERR  LA    R15,33             NO->RC=33\n         B     SCANEX\nGCN      L     R6,CSOACNM               R6->CMD NAME\n         LTR   R6,R6                    OK?\n         BZ    SCANERR            YES\nGCL      LH    R5,CSOALNM               R5=CMD NAME LEN\n         LTR   R5,R5              R5>0?\n         BNP   SCANERR            NO\n         BCTR  R5,R0                    R5=R5-1 FOR EX\n         MVC   EPNAME,=CL8' '           CLEAR EPNAME AREA\nRM       MVC   EPNAME(0),0(R6)          EX'ED CMDNAME SAVE\n         EX    R5,RM                    DOIT\n         SPACE\n         L     R4,CPPLECT         R4->ECT\n         USING ECT,R4\n         MVC   ECTPCMD,=CL8' '          CLEAR ECT NAME AREA\nCNS      MVC   ECTPCMD(0),0(R6)         EX'ED CMDNAME SAVE\n         EX    R5,CNS                   DOIT\n         SPACE\n         NI    ECTSWS,255-ECTNOPD SAY OPERANDS\n         CLI   CSOAFLG,X'80'      PRESENT?\n         BE    SCANEX             YES\n         OI    ECTSWS,ECTNOPD     SAY NO OPERANDS\n         DROP  R4\n         SPACE\nSCANEX   L     R14,L2LS\n         BR    R14\n         EJECT\nAWNTL    ST    R14,L2LS\n         SPACE 2\nAWNTL2   MVC   CPPLCBUF,GTPB+4          PASS CBUF\n         LA    R1,CPPL                  PASS CPPL\n         SPACE\n         XC    ATTACHL(60),ATTACHL\n         ATTACH EPLOC=EPNAME,ECB=AECB,SHSPV=78,SF=(E,ATTACHL)\nACFIN    LTR   R1,R1                    ANY TCB?\n         BZ    AWNTLX                   NO->FASTEXIT\n         ST    R1,TCBADD\n         SPACE 2\n         XC    AECB,AECB                CLEAR ECB\n         WAIT  ECB=AECB                 LET HIM RUN THEN\n         SPACE 2\n         DETACH TCBADD                  REMOVE DEAD TCB\n         SPACE 2\nAWNTLX   L     R14,L2LS\n         BR    R14\n         EJECT\nAWTL     ST    R14,L2LS\n         SPACE\n         MVC   DCBL(96),DCBP            INIT DCB\n         MVC   DCBL+40(8),TASKDD       GET DDNAME\n         MVC   OPENL(4),=X'80000000'    INIT OPEN\n         OPEN  (DCBL,INPUT),MF=(E,OPENL)  OPEN THE TASKLIB\n         TM    DCBL+48,X'10'            DID IT OPEN?\n         BZ    AWNTL2                   NO->DON'T USE IT THEN\n         MVC   CPPLCBUF,GTPB+4          PASS CBUF\n         LA    R1,CPPL                  PASS CPPL\n         SPACE 2\n         XC    ATTACHL(60),ATTACHL\n         ATTACH EPLOC=EPNAME,ECB=AECB,SHSPV=78,DCB=DCBL,               X\n               TASKLIB=DCBL,SF=(E,ATTACHL)\n         SPACE\n         B     ACFIN                    REST IS THE SAME\n         EJECT\n*\n*        THIS  ROUTINE UNSTACKS WHATEVER WE STACKED:\n*\nUNSTACKM ST    R14,L1LS\n*\n         TM    FLAG,X'C0'               ANYTHING STACKED?\n         BZR   R14                      NO->EXIT FAST\n         SPACE 2\n         L     R6,CPPLECT         R6->ECT\n         L     R5,4(,R6)          R5->IOSRL\n         MVC   4(4,R5),SAVELEM    RESTORE TRUE STACK BOTTOM FIRST\n         SPACE 2\n         BAL   R14,DELIT                REMOVE TOP ENTRY\n         SPACE 3\nUSX      L     R14,L1LS\n         BR    R14\n         EJECT\n*\n*        THIS  ROUTINE REMOVES THE TOP ELEMENT ON THE STACK:\n*\nDELIT    ST    R14,L2LS\n*\n         L     R7,CPPLUPT               R7->UPT\n         L     R6,CPPLECT               R6->ECT\n*\nSED      STACK PARM=STPB,UPT=(R7),ECT=(R6),ECB=ECB,                    X\n               DELETE=TOP,MF=(E,IOPL)\n         SPACE 3\n         NI    28(R6),X'FD'             RETURN TO FOREGROUND\n         SPACE 3\n         L     R14,L2LS\n         BR    R14\n         EJECT\nSTATWORK EQU   *\n*\n*              STACK DDIN() DDOUT() TASKLIB() LIST\n*\nOPLIST   DC    F'0'                     LIST OF KNOWN OPERANDS:\n         DC    A(OPER1)\n         DC    A(OPER2)\n         DC    A(OPER3)\n         DC    A(OPER4)\n         DC    F'0'\n         DC    F'0'\n         SPACE\nOPER1    DS    0F\n         DC    X'8000'                  BYTE1=FLAG MASK,BYTE2=FLAG BYTE\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(DDINS)                 EXIT ADDR\n         DC    H'4'                     OPERAND LENGTH\nDDI      DC    CL8'DDIN'                OPERAND NAME\n         SPACE\nOPER2    DS    0F\n         DC    X'4000'\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(DDOUTS)                EXIT ADDR\n         DC    H'5'\nDDO      DC    CL8'DDOUT'\n         SPACE\nOPER3    DS    0F\n         DC    X'2000'\n         DC    X'8000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(TASKSV)                EXIT ADDR\n         DC    H'7'\nTASKLB   DC    CL8'TASKLIB'\n         SPACE\nOPER4    DS    0F\n         DC    X'1000'\n         DC    X'0000'                  OPTIONS  (X'80'=TAKE EXIT)\n*                                       OPTIONS  (X'40'=BLANK OUT)\n         DC    A(0)                     EXIT ADDR\n         DC    H'4'\nLIST     DC    CL8'LIST'\n         SPACE 3\n         LTORG\n         DC    80X'00'                  ZAP AREA\n         EJECT\nDCBP     DCB   DSORG=PO,MACRF=R         PATTERN DCB\n         EJECT\nWORKAREA DSECT\nSAVEAREA DS    18F\nL1LS     DS    F\nL2LS     DS    F\nL3LS     DS    F\nL4LS     DS    F\n*\nFLAG     DS    F\nOPFLAG   DS    X\nUNKNFLAG DS    X\nSAVELEM  DS    F\nDDSAVE   DC    CL8' '                   DDN SAVE\nTASKDD   DC    CL8' '                   DDN SAVE\nDDOUT    DC    CL8' '                   DDN SAVE\nDDIN     DC    CL8' '                   DDN SAVE\nEPNAME   DC    CL8' '                   EPN SAVE\nTCBADD   DC    F'0'\n*\n*              I/O RTN PARM AREA:\n*\nIOPL     DS    4F\nPUTLIST  PUTLINE  MF=L\n*\nSTPB     STACK MF=L\n*\nGTPB     GETLINE MF=L\n*\nECB      DS    F\nAECB     DS    F\n*\n*              CMD SCAN PARM AREA:\n*\nCSPLA    DS    6F\nCSOAA    DS    2F\nCSOAF    DS    F\n*\n         EJECT\nOPENL    OPEN  (DCBL,INPUT),MF=L\n         SPACE 3\nDCBL     DCB   DSORG=PO,MACRF=R         EXECUTION DCB\n         EJECT\nATTACHL  ATTACH EPLOC=EPNAME,ECB=AECB,SHSPV=78,SF=L\n         EJECT\n         KPPL\nFASTAREA DS    XL600                    SOME AREA TO GIVE KMDPARS\n*\nWORKLEN  EQU   *-WORKAREA\n         EJECT\nX        DSECT\n         BPPL\n         EJECT\nMCSPL    IKJCSPL\nMCSOA    IKJCSOA\n         IKJCVT\n         IKJCPPL\n         IKJECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STACKDOC": {"ttr": 1801, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "1 10.000\n-                                                         STACK cmd\n\n     STACK is a TSO COMMAND PROCESSOR which enables interception of\n PUTGET IO for the duration of the TSO command following STACK. Thus\n the output from a TSO command may be directed to a dataset. STACK\n imitates the TMP to obtain the next TSO command and attach it with\n the IO redirected via the STACK macro. STACK can be used to\n execute a command from a specific library (for example a test version)\n or to call a program using dynamic linkage since the optional TASKDD\n is also used as the tasklib for the duration of the command.\n VIO datasets may be used for the IO files. All operands are optional.\n\n            STACK DDIN(INPUTDD) DDOUT(OUTDD) -\n                  TASKLIB(TASKDD) LIST\n\n                        INPUTDD - DDNAME TO READ COMMAND FROM\n                                         INSTEAD OF NORMAL SOURCE\n                        OUTDD   - DDNAME THE COMMAND OUTPUT SHOULD\n                                         GO TO\n                        TASKDD  - DDNAME THE COMMAND SHOULD BE\n                                         ATTACHED FROM IF DESIRED\n                        LIST    - MEANS DISPLAY THE COMMAND ON THE\n                                         OUTPUT FILE\n                        (ALL OPERANDS ARE OPTIONAL)\n                        (ALL FILE IO MUST BE DONE\n                        VIA PUTGET MODULE TO BE INTERCEPTED)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WPROFILE": {"ttr": 1803, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***************************************************\n**                                               **\n**   CLIB - ISPF CLIST LIBRARY                   **\n**   LLIB - ISPF LOAD LIBRARY                    **\n**   MLIB - ISPF MESSAGE LIBRARY                 **\n**   PLIB - ISPF PANEL LIBRARY                   **\n**   SLIB - ISPF SKELETON LIBRARY                **\n**   TLIB - ISPF TABLE LIBRARY                   **\n**   TABL - ISPF TABLE LIBRARY                   **\n**   FILE - ISPF FILE DD(ISPFILE)                **\n**                                               **\n***************************************************\nCLIB NODEF\nCLIB SYS2.ISPCLIST\nCLIB SYS1.ISPF230.PDFCLIB\nLLIB NODEF\nLLIB SYS1.ISPF230.PDFLOAD\nMLIB NODEF\nMLIB SYS1.ISPF230.PDFMLIB\nPLIB NODEF\nPLIB SYS1.ISPF230.PDFPLIB\nSLIB NODEF\nSLIB SYS1.ISPF230.PDFSLIB\nTLIB NODEF\nTLIB SYS1.ISPF230.PDFTLIB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WSRCCEP1": {"ttr": 1805, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "%------------------ Wilson Street Regional Computing Center --------------------\n%                      &XDSP Panel For &ZUSER\n%  Enter Code ===>_ZCMD\n%  Enter Member ===>_MEM     +             +%Enter Volume ===>_VLU  +\n+\n%   &WEI1   +-  &WEN1\n%   &WEI2   +-  &WEN2\n%   &WEI3   +-  &WEN3\n%   &WEI4   +-  &WEN4\n%   &WEI5   +-  &WEN5\n%   &WEI6   +-  &WEN6\n%   &WEI7   +-  &WEN7\n%   &WEI8   +-  &WEN8\n%   &WEI9   +-  &WEN9\n%   &WEI10  +-  &WEN10\n%   &WEI11  +-  &WEN11\n%   &WEI12  +-  &WEN12\n%   &WEI13  +-  &WEN13\n%   &WEI14  +-  &WEN14\n%   &WEI15  +-  &WEN15\n%   SET+     -  To setup Datasets and the PR1 & PR2 PRINTOFF options\n%   PR1+     -  &WPR1\n%   PR2+     -  &WPR2\n+      PRESS%END KEY+TO TERMINATE THIS PANEL+\n)INIT\n     .CURSOR = ZCMD\n     &MEM = &Z\n     &VLU = &Z\n     IF (&OROPT = 'E')\n         &XDSP = 'Edit'\n     IF (&OROPT = 'B')\n         &XDSP = 'Browse'\n     IF (&OROPT = 'PRT')\n         &XDSP = 'Printoff'\n     IF (&OROPT = 'PR1')\n         &XDSP = 'Printoff'\n     IF (&OROPT = 'PR2')\n         &XDSP = 'Printoff'\n     IF (&OROPT = 'PDS')\n         &XDSP = 'PDS'\n)PROC\n     VER (&ZCMD,NONBLANK)\n     &ZCMD = TRUNC(&ZCMD,'.')\n     &TYP = &ZCMD\n     &MBR = &MEM\n     &MEM = &Z\n     &DSNM = &Z\n     IF (&TYP = *)\n         &DSNM = .TRAIL\n     IF (&TYP \u00ac= *)\n       IF (&MBR = &Z)\n          &HOLD= .TRAIL\n          &MBR = TRUNC(&HOLD,'.')\n          &VOL = .TRAIL\n     IF (&VOL = &Z)\n        &VOL = &VLU\n     &WEIX = &ZCMD\n     IF (&ZCMD = 'PA')\n         &DSNM = '''SYS1.PARMLIB'''\n     IF (&ZCMD = 'S1')\n         &DSNM = '''SYS1.PROCLIB'''\n     IF (&ZCMD = S2)\n         &DSNM = '''SYS2.PROCLIB'''\n     IF (&ZCMD = C2)\n         &DSNM = '''SYS2.CLISTLIB'''\n     IF (&ZCMD = TSO)\n         &DSNM = '''SYS2.TSOPROCS'''\n     IF (&ZCMD = STC)\n         &DSNM = '''SYS2.STCPROCS'''\n     IF (&ZCMD = PROF)\n         &DSNM = '''TSO.PROFILE.&ZUSER'''\n     IF (&ZCMD = &WEI1)\n         &DSNM = &WEN1\n     IF (&ZCMD = &WEI2)\n         &DSNM = &WEN2\n     IF (&ZCMD = &WEI3)\n         &DSNM = &WEN3\n     IF (&ZCMD = &WEI4)\n         &DSNM = &WEN4\n     IF (&ZCMD = &WEI5)\n         &DSNM = &WEN5\n     IF (&ZCMD = &WEI6)\n         &DSNM = &WEN6\n     IF (&ZCMD = &WEI7)\n         &DSNM = &WEN7\n     IF (&ZCMD = &WEI8)\n         &DSNM = &WEN8\n     IF (&ZCMD = &WEI9)\n         &DSNM = &WEN9\n     IF (&ZCMD = &WEI10)\n         &DSNM = &WEN10\n     IF (&ZCMD = &WEI11)\n         &DSNM = &WEN11\n     IF (&ZCMD = &WEI12)\n         &DSNM = &WEN12\n     IF (&ZCMD = &WEI13)\n         &DSNM = &WEN13\n     IF (&ZCMD = &WEI14)\n         &DSNM = &WEN14\n     IF (&ZCMD = &WEI15)\n         &DSNM = &WEN15\n     IF (&ZCMD = *)\n         &ZCMD = ZXXZ\n  &ZSEL = TRANS (TRUNC (&ZCMD,'.')\n           SET,'PANEL(WSRCESET)'\n           PRT,'CMD(%WSRCEPCL) NOCHECK'\n           PR1,'CMD(%WSRCEPCL) NOCHECK'\n           PR2,'CMD(%WSRCEPCL) NOCHECK'\n          ZXXZ,'CMD(%WSRCEPCL) NOCHECK'\n         &WEIX,'CMD(%WSRCEPCL) NOCHECK'\n           ' ',' ' )\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WSRCCLPN": {"ttr": 2051, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "%-----------------  Wilson Street Regional Computing Center  -------------------\n%                         Jump Commands\n%\n%SELECT OPTION ===>_ZCMD\n%\n%  B   +Browse  - ISPF Browse a dataset\n%  E   +Edit    - ISPF Edit a dataset\n%  PDS +PDS     - PDS command for specified library\n%  PR1 +Printo  - Print dataset with opts:%&WPR1\n%  PR2 +Printo  - Print dataset with opts:%&WPR2\n%  PRT +Printo  - Print dataset with opts:%DEST(W3820) FCB(A103)\n%  SET +SET     - Set up library selection codes and datasets\n%\n%\n+PRESS%END KEY+TO TERMINATE THIS PANEL+\n)INIT\n)PROC\n  &OROPT = TRUNC(&ZCMD,'.')\n  &ZSEL = TRANS( TRUNC (&ZCMD,'.')\n                B,'PANEL(WSRCCEP1)'\n                E,'PANEL(WSRCCEP1)'\n              PDS,'PANEL(WSRCCEP1)'\n              PRT,'PANEL(WSRCCEP1)'\n              PR1,'PANEL(WSRCCEP1)'\n              PR2,'PANEL(WSRCCEP1)'\n              SET,'PANEL(WSRCESET)'\n              ' ',' '\n                X,'EXIT'\n                *,'?' )\n  &ZTRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WSRCEPCL": {"ttr": 2053, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 0\nCONTROL NOLIST MSG PROMPT END(DEND)\nISPEXEC VGET (OROPT,TYP,DSNM,MBR,VOL)\nSET &TCMD   = EDIT\nSET &M     = /*NULL*/\nSET &QUOTE = /*NULL*/\nSET &VLM   = /*NULL*/\nIF &VOL NE /*NULL*/ THEN -\n   SET &VLM = &STR(VOLUME(&VOL))\n LISTDSI &DSNM &VLM\n IF &SYSREASON \u00ac= 0  THEN -\n DO\n   SET &S = &SYSREASON\n   SET &R = /* NULL */\n   IF &S=1 THEN SET &R=&STR(ERROR PARSING STATEMENT)\n   IF &S=2 THEN SET &R=&STR(DYNAMIC ALLOCATION PROCESSING ERROR)\n   IF &S=3 THEN SET &R=&STR(FILE IS OF TYPE THAT CANNOT BE PROCESSED)\n   IF &S=4 THEN SET &R=&STR(ERROR DETERMINING UNIT NAME)\n   IF &S=5 THEN SET &R=&STR(DATA SET NOT CATALOGED)\n   IF &S=6 THEN SET &R=&STR(ERROR OBTAINING THE DATA SET NAME)\n   IF &S=7 THEN SET &R=&STR(ERROR FINDING DEVICE TYPE)\n   IF &S=8 THEN SET &R=&STR(DATA SET DOES NOT RESIDE ON DA DEVICE)\n   IF &S=9 THEN SET &R=&STR(HSM MIGRATED DATA SET NORECALL)\n   IF &S=11 THEN SET &R=&STR(YOU LACK AUTHORITY TO ACCESS DATA SET)\n   IF &S=12 THEN SET &R=&STR(VSAM DATA SETS ARE NOT SUPPORTED)\n   IF &S=13 THEN SET &R=&STR(DATA SET COULD NOT BE OPENED)\n   IF &S=14 THEN SET &R=&STR(DEVICE TYPE NOT FOUND IN UCB TABLES)\n   IF &S=17 THEN SET &R=&STR(SYSTEM OR USER ABEND OCCURRED)\n   IF &S=18 THEN SET &R=&STR(PARTIAL DATA SET INFORMATION WAS OBTAINED)\n   IF &S=19 THEN SET &R=&STR(DATA SET RESIDES ON MULTIPLE VOLUMES)\n   IF &S=20 THEN SET &R=&STR(DEVICE TYPE NOT FOUND IN EDT)\n   IF &S=21 THEN SET &R=&STR(CATALOG ERROR IN TRYING TO LOCATE)\n   IF &S=22 THEN SET &R=&STR(VOLUME &VOL NOT MOUNTED)\n   IF &S=23 THEN SET &R=&STR(PERMANENT I/O ERROR ON VOLUME)\n   IF &S=24 THEN SET &R=&STR(DATA SET NOT FOUND BY OBTAIN MACRO)\n   IF &S=25 THEN SET &R=&STR(DATA SET MIGRATED TO NON-DASD DEVICE)\n   IF &S=26 THEN SET &R=&STR(DATA SET RESIDES ON MASS STORAGE DEVICE)\n   IF &S=27 THEN SET &R=&STR(NO VOLUME SERIAL IS ALLOCATED TO DATA SET)\n   WRITE\n   WRITE\n   WRITE\n   WRITE\n   WRITE  &DSNM  CANNOT BE PROCESSED\n   WRITE\n   WRITE             &R\n   EXIT\n DEND\n   /*                                                */\nIF &STR(&MBR) NE /*NULL*/ AND &STR(&MBR) NE &STR(*) THEN -\n DO\n   SET &M=&STR((&MBR))\n   IF &SUBSTR(1:1,&STR(&DSNM))= &STR(') THEN -\n     DO\n       SET &DSNM = &SUBSTR(1:&EVAL(&LENGTH(&STR(&DSNM))-1),&DSNM  )\n       SET &QUOTE = &STR(')\n     DEND\n DEND\n   /*                                                */\nIF &STR(&MBR) EQ &STR(*) THEN -\n   SET &MBR = /* NULL */\n   /*                                                */\nIF &SUBSTR(1:2,&STR(&OROPT) ) = PR THEN GOTO PRTIT\n   /*                                                */\nIF &OROPT = PDS THEN -\n DO\n   ISPEXEC  CONTROL DISPLAY LINE START(1)\n   PDS &DSNM&QUOTE &VLM\n   TERMIN EN END STOP\n   DATA\n    END\n   ENDDATA\n   CLEAR\n   ISPEXEC CONTROL DISPLAY REFRESH\n   END\n DEND\n   /*                                                */\nIF &OROPT = PDSB THEN -\n DO\n   PDSB DS(&DSNM&QUOTE) &VLM\n   ISPEXEC CONTROL DISPLAY REFRESH\n   END\n DEND\n   /*                                                */\nIF &OROPT = B THEN SET &TCMD = BROWSE\nSET &REC = 0\nIF &OROPT = E THEN -\n     DO\n      SET &REC = 0\n  EDRECLP: SET &CC = 0\n      ISPEXEC  CONTROL DISPLAY LINE START(1)\n      ISPEXEC EDREC QUERY\n      SET &CC = &LASTCC\n      IF &CC \u00ac= 0 THEN -\n         DO\n           SET &REC = 1\n           SET &TDSN = &ZEDTDSN\n           SET &TMEM = &ZEDTMEM\n           IF  &ZEDTMEM \u00ac= /*NULL*/ THEN SET &TMEM = &STR((&TMEM))\n           WRITE\n           WRITE\n           WRITE\n           WRITE           EDIT RECOVERY IN PROGRESS FOR:\n           WRITE\n           WRITE              &TDSN&TMEM\n           WAIT  02\n           CLEAR\n           ISPEXEC EDREC PROCESS\n           GOTO EDRECLP\n         DEND\n      SET &DSN  = &STR(&DSNM&M&QUOTE)\n      ISPEXEC VPUT (DSN) SHARED\n     DEND\n   IF  &REC = 1 THEN -\n     DO\n           WRITE\n           WRITE\n           WRITE\n           WRITE           ORIGINAL EDIT SESSION IN PROGRESS FOR:\n           WRITE\n           WRITE                  &DSNM&M&QUOTE\n           WAIT  02\n           CLEAR\n     DEND\nISPEXEC &TCMD DATASET(&DSNM&M&QUOTE) &VLM\nISPEXEC CONTROL DISPLAY REFRESH\nEND\nEXIT\n/* ****   PRINT IT   **** */\nPRTIT: -\n  SET &DSNM =  &STR(&DSNM&QUOTE)                                             005\n  IF    &OROPT = PRT THEN -\n     DO\n        SET &PRDSN = &DSNM\n        ISPEXEC DISPLAY PANEL(PRPANL)\n        IF &RESPONSE EQ &STR(END)  THEN EXIT\n        SET &PPARM = &PROPTS\n        ISPEXEC VPUT (PROPTS) PROFILE\n     DEND\n  IF    &OROPT = PR1 THEN -\n     DO\n        ISPEXEC VGET (WPR1)\n        SET &PPARM = &STR(&WPR1)\n     DEND\n  IF    &OROPT = PR2 THEN -\n     DO\n        ISPEXEC VGET (WPR2)\n        SET &PPARM = &STR(&WPR2)\n     DEND\n ISPEXEC VPUT (PPARM,VLM,DSNM,MBR) SHARED\n %WSRCPRTC\n  ISPEXEC CONTROL DISPLAY REFRESH\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WSRCESET": {"ttr": 2057, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "%------------------ Wilson Street Regional Computing Center ------------\n%                       Setup &KDSP Menu For &ZUSER\n%                 Enter Selection Characters and Dataset Names\n%   Selection        Dataset\n%   Character(s)      Name\n%   >_WEI1    %>_WEN1\n%   >_WEI2    %>_WEN2\n%   >_WEI3    %>_WEN3\n%   >_WEI4    %>_WEN4\n%   >_WEI5    %>_WEN5\n%   >_WEI6    %>_WEN6\n%   >_WEI7    %>_WEN7\n%   >_WEI8    %>_WEN8\n%   >_WEI9    %>_WEN9\n%   >_WEI10   %>_WEN10\n%   >_WEI11   %>_WEN11\n%   >_WEI12   %>_WEN12\n%   >_WEI13   %>_WEN13\n%   >_WEI14   %>_WEN14\n%   >_WEI15   %>_WEN15\n%    SET Printoff options for PR1 and PR2:\n%      PR1 >_WPR1                                +\n%      PR2 >_WPR2                                +\n+    PRESS%END KEY+TO TERMINATE THIS PANEL+\n)INIT\n     .CURSOR = WEI1\n     IF (&OROPT = 'E')\n         &KDSP = 'Edit'\n     IF (&OROPT = 'B')\n         &KDSP = 'Browse'\n)PROC\n   IF (&WEI1 \u00ac= &Z)\n     VER (&WEN1,NONBLANK)\n     VER (&WEN1,DSNAME)\n     VER (&WEI1,NONBLANK)\n   IF (&WEI2 \u00ac= &Z)\n     VER (&WEN2,NONBLANK)\n     VER (&WEN2,DSNAME)\n     VER (&WEI2,NONBLANK)\n   IF (&WEI3 \u00ac= &Z)\n     VER (&WEN3,NONBLANK)\n     VER (&WEN3,DSNAME)\n     VER (&WEI3,NONBLANK)\n   IF (&WEI4 \u00ac= &Z)\n     VER (&WEN4,NONBLANK)\n     VER (&WEN4,DSNAME)\n     VER (&WEI4,NONBLANK)\n   IF (&WEI5 \u00ac= &Z)\n     VER (&WEN5,NONBLANK)\n     VER (&WEN5,DSNAME)\n     VER (&WEI5,NONBLANK)\n   IF (&WEI6 \u00ac= &Z)\n     VER (&WEN6,NONBLANK)\n     VER (&WEN6,DSNAME)\n     VER (&WEI6,NONBLANK)\n   IF (&WEI7 \u00ac= &Z)\n     VER (&WEN7,NONBLANK)\n     VER (&WEN7,DSNAME)\n     VER (&WEI7,NONBLANK)\n   IF (&WEI8 \u00ac= &Z)\n     VER (&WEN8,NONBLANK)\n     VER (&WEN8,DSNAME)\n     VER (&WEI8,NONBLANK)\n   IF (&WEI9 \u00ac= &Z)\n     VER (&WEN9,NONBLANK)\n     VER (&WEN9,DSNAME)\n     VER (&WEI9,NONBLANK)\n   IF (&WEI10 \u00ac= &Z)\n     VER (&WEN10,NONBLANK)\n     VER (&WEN10,DSNAME)\n     VER (&WEI10,NONBLANK)\n   IF (&WEI11 \u00ac= &Z)\n     VER (&WEN11,NONBLANK)\n     VER (&WEN11,DSNAME)\n     VER (&WEI11,NONBLANK)\n   IF (&WEI12 \u00ac= &Z)\n     VER (&WEN12,NONBLANK)\n     VER (&WEN12,DSNAME)\n     VER (&WEI12,NONBLANK)\n   IF (&WEI13 \u00ac= &Z)\n     VER (&WEN13,NONBLANK)\n     VER (&WEN13,DSNAME)\n     VER (&WEI13,NONBLANK)\n   IF (&WEI14 \u00ac= &Z)\n     VER (&WEN14,NONBLANK)\n     VER (&WEN14,DSNAME)\n     VER (&WEI14,NONBLANK)\n   IF (&WEI15 \u00ac= &Z)\n     VER (&WEN15,NONBLANK)\n     VER (&WEN15,DSNAME)\n     VER (&WEI15,NONBLANK)\n   IF (&WEN1 \u00ac= &Z)\n     VER (&WEN1,NONBLANK)\n     VER (&WEN1,DSNAME)\n     VER (&WEI1,NONBLANK)\n   IF (&WEN2 \u00ac= &Z)\n     VER (&WEN2,NONBLANK)\n     VER (&WEN2,DSNAME)\n     VER (&WEI2,NONBLANK)\n   IF (&WEN3 \u00ac= &Z)\n     VER (&WEN3,NONBLANK)\n     VER (&WEN3,DSNAME)\n     VER (&WEI3,NONBLANK)\n   IF (&WEN4 \u00ac= &Z)\n     VER (&WEN4,NONBLANK)\n     VER (&WEN4,DSNAME)\n     VER (&WEI4,NONBLANK)\n   IF (&WEN5 \u00ac= &Z)\n     VER (&WEN5,NONBLANK)\n     VER (&WEN5,DSNAME)\n     VER (&WEI5,NONBLANK)\n   IF (&WEN6 \u00ac= &Z)\n     VER (&WEN6,NONBLANK)\n     VER (&WEN6,DSNAME)\n     VER (&WEI6,NONBLANK)\n   IF (&WEN7 \u00ac= &Z)\n     VER (&WEN7,NONBLANK)\n     VER (&WEN7,DSNAME)\n     VER (&WEI7,NONBLANK)\n   IF (&WEN8 \u00ac= &Z)\n     VER (&WEN8,NONBLANK)\n     VER (&WEN8,DSNAME)\n     VER (&WEI8,NONBLANK)\n   IF (&WEN9 \u00ac= &Z)\n     VER (&WEN9,NONBLANK)\n     VER (&WEN9,DSNAME)\n     VER (&WEI9,NONBLANK)\n   IF (&WEN10 \u00ac= &Z)\n     VER (&WEN10,NONBLANK)\n     VER (&WEN10,DSNAME)\n     VER (&WEI10,NONBLANK)\n   IF (&WEN11 \u00ac= &Z)\n     VER (&WEN11,NONBLANK)\n     VER (&WEN11,DSNAME)\n     VER (&WEI11,NONBLANK)\n   IF (&WEN12 \u00ac= &Z)\n     VER (&WEN12,NONBLANK)\n     VER (&WEN12,DSNAME)\n     VER (&WEI12,NONBLANK)\n   IF (&WEN13 \u00ac= &Z)\n     VER (&WEN13,NONBLANK)\n     VER (&WEN13,DSNAME)\n     VER (&WEI13,NONBLANK)\n   IF (&WEN14 \u00ac= &Z)\n     VER (&WEN14,NONBLANK)\n     VER (&WEN14,DSNAME)\n     VER (&WEI14,NONBLANK)\n   IF (&WEN15 \u00ac= &Z)\n     VER (&WEN15,NONBLANK)\n     VER (&WEN15,DSNAME)\n     VER (&WEI15,NONBLANK)\n VPUT (WEI1,WEI2,WEI3,WEI4,WEI5,WEI6,WEI7,WEI8,WEI9,WEI10) PROFILE\n VPUT (WEN1,WEN2,WEN3,WEN4,WEN5,WEN6,WEN7,WEN8,WEN9,WEN10) PROFILE\n VPUT (WEI11,WEI12,WEI13,WEI14,WEI15,WEN11,WEN12,WEN13)    PROFILE\n VPUT (WEN14,WEN15,WPR1,WPR2) PROFILE\n &ZSEL=' '\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WSRCMDS": {"ttr": 2061, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "WSRCPRTC": {"ttr": 2063, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " PROC 0 DEBUG\n CONTROL    NOLIST MSG\n IF &DEBUG = DEBUG THEN -\n CONTROL   CONLIST MSG SYMLIST\n SET &MEMBER = /* NULL */\n ISPEXEC VGET (PPARM,VLM,DSNM,MBR) SHARED\n LISTDSI &DSNM &VLM\n IF &SYSREASON \u00ac= 0  THEN -\n DO\n   SET &S = &SYSREASON\n   SET &R = /* NULL */\n   IF &S=1 THEN SET &R=&STR(ERROR PARSING STATEMENT)\n   IF &S=2 THEN SET &R=&STR(DYNAMIC ALLOCATION PROCESSING ERROR)\n   IF &S=3 THEN SET &R=&STR(FILE IS OF TYPE THAT CANNOT BE PROCESSED)\n   IF &S=4 THEN SET &R=&STR(ERROR DETERMINING UNIT NAME)\n   IF &S=5 THEN SET &R=&STR(DATA SET NOT CATALOGED)\n   IF &S=6 THEN SET &R=&STR(ERROR OBTAINING THE DATA SET NAME)\n   IF &S=7 THEN SET &R=&STR(ERROR FINDING DEVICE TYPE)\n   IF &S=8 THEN SET &R=&STR(DATA SET DOES NOT RESIDE ON DA DEVICE)\n   IF &S=9 THEN SET &R=&STR(HSM MIGRATED DATA SET NORECALL)\n   IF &S=11 THEN SET &R=&STR(YOU LACK AUTHORITY TO ACCESS DATA SET)\n   IF &S=12 THEN SET &R=&STR(VSAM DATA SETS ARE NOT SUPPORTED)\n   IF &S=13 THEN SET &R=&STR(DATA SET COULD NOT BE OPENED)\n   IF &S=14 THEN SET &R=&STR(DEVICE TYPE NOT FOUND IN UCB TABLES)\n   IF &S=17 THEN SET &R=&STR(SYSTEM OR USER ABEND OCCURRED)\n   IF &S=18 THEN SET &R=&STR(PARTIAL DATA SET INFORMATION WAS OBTAINED)\n   IF &S=19 THEN SET &R=&STR(DATA SET RESIDES ON MULTIPLE VOLUMES)\n   IF &S=20 THEN SET &R=&STR(DEVICE TYPE NOT FOUND IN EDT)\n   IF &S=21 THEN SET &R=&STR(CATALOG ERROR IN TRYING TO LOCATE)\n   IF &S=22 THEN SET &R=&STR(&VLM NOT MOUNTED)\n   IF &S=23 THEN SET &R=&STR(PERMANENT I/O ERROR ON VOLUME)\n   IF &S=24 THEN SET &R=&STR(DATA SET NOT FOUND BY OBTAIN MACRO)\n   IF &S=25 THEN SET &R=&STR(DATA SET MIGRATED TO NON-DASD DEVICE)\n   IF &S=26 THEN SET &R=&STR(DATA SET RESIDES ON MASS STORAGE DEVICE)\n   IF &S=27 THEN SET &R=&STR(NO VOLUME SERIAL IS ALLOCATED TO DATA SET)\n   WRITE\n   WRITE\n   WRITE\n   WRITE\n   WRITE  &DSNM  CANNOT BE PROCESSED\n   WRITE\n   WRITE             &R\n   EXIT\n END\n IF &SYSDSORG = &STR(PS) THEN -\n DO\n   PRINTO &DSNM &PPARM &VLM\n   EXIT\n END\n SET &MLC = &LENGTH(&STR(&MBR))\n IF  &MLC = 0 THEN SET &MLC = 1\n IF  &SUBSTR(&MLC:&MLC,&STR(&MBR  )) =  &STR(*) THEN -\n   DO\n    SET &MEMBER = &STR(MEMBER(&MBR))\n   END\n ELSE -\n IF &STR(&MBR) \u00ac= /* NULL */ THEN -\n DO\n    SET &MEMC = 1\n    SET &MEMN = &STR(&MBR)\n    GOTO WORK\n END\n SET &MEMC = 0\n SET &MEMN = /* NULL */\n SET &MEMH = /* NULL */\n ISPEXEC LMINIT  DATAID(PRTTSTD) DATASET(&DSNM) &VLM\n SET &LCC = &LASTCC\n IF &LCC \u00ac= 0 THEN -\n WRITE &LCC\n ISPEXEC LMOPEN  DATAID(&PRTTSTD)\n SET &LCC = &LASTCC\n IF &LCC \u00ac= 0 THEN -\n WRITE &LCC\n LOOP: -\n ISPEXEC LMMDISP DATAID(&PRTTSTD) PANEL(PRTPNL00) &MEMBER\n SET &FCC = &LASTCC\n ISPEXEC VGET (PENTR)\n IF &STR(&PENTR) = CANCEL OR &STR(&PENTR) = CAN THEN GOTO STOPIT\n IF &FCC \u00ac= 0 THEN GOTO WORK\n SET &MEMC = &MEMC + 1\n SET &MEMH = &ZLMEMBER\n SET &MEMN = &STR(&MEMN&SUBSTR(1:8,&MEMH        )\n  ISPEXEC LMMDISP DATAID(&PRTTSTD) OPTION(PUT) MEMBER(&MEMH) +\n   ZLUDATA(SELECTED)\n GETLOOP: -\n ISPEXEC LMMDISP DATAID(&PRTTSTD) OPTION(GET)\n SET &MCC = &LASTCC\n ISPEXEC VGET (PENTR)\n IF &STR(&PENTR) = CANCEL OR &STR(&PENTR) = CAN THEN GOTO STOPIT\n IF &MCC = 8 THEN GOTO LOOP\n SET &MEMC = &MEMC + 1\n SET &MEMH = &ZLMEMBER\n SET &MEMN = &STR(&MEMN&SUBSTR(1:8,&MEMH        )\n ISPEXEC LMMDISP DATAID(&PRTTSTD) OPTION(PUT) MEMBER(&MEMH) +\n   ZLUDATA(SELECTED)\n GOTO GETLOOP\n IF &FCC = 0 THEN GOTO LOOP\n STOPIT: -\n   ISPEXEC LMMDISP DATAID(&PRTTSTD) OPTION(FREE)\n   ISPEXEC LMCLOSE DATAID(&PRTTSTD)\n   ISPEXEC LMFREE DATAID(&PRTTSTD)\n  EXIT\n STRTWORK: -\n   ISPEXEC LMMDISP DATAID(&PRTTSTD) OPTION(FREE)\n   ISPEXEC LMCLOSE DATAID(&PRTTSTD)\n   ISPEXEC LMFREE DATAID(&PRTTSTD)\n WORK: -\n   SET &LCC = &LASTCC\n   IF &LCC \u00ac= 0 THEN -\n   WRITE &LCC\n   IF &MEMC = 0 THEN -\n   DO\n      WRITE NO MEMBERS SELECTED, PRINTOFF TERMINATING\n      EXIT\n   END\n   SET &PRMLEN = &LENGTH(&STR(&PPARM))\n   SET &DSNLEN = &LENGTH(&STR(&DSNM)\n   IF &SUBSTR(1:1,&STR(&DSNM) ) = &STR(') THEN -\n     SET &DSNM = &SUBSTR(1:&EVAL(&DSNLEN - 1),&STR(&DSNM) )\n   SET &PRTC = 0\n   SET &MS = -7\n   SET &ME =  0\nPRTLOOP: -\n   SET &PRTC = &PRTC + 1\n   SET &MS = &MS + 8\n   SET &ME = &ME + 8\n   SET &MBR = &SUBSTR(&MS:&ME,&MEMN       )\n   SET &MBR = &MBR\n   PRINTO &DSNM(&MBR)&STR(') &PPARM &VLM\n   IF &MEMC > &PRTC THEN GOTO PRTLOOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTP": {"ttr": 2305, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LAB1    WTP   &TXT,&LEN,&MF=I\n         LCLC  &GT,&T,&CL,&P\n         LCLA  &TL\n&P       SETC  '()'(1,1)\n&T       SETC  T'&TXT\n.*       MNOTE 'MESSAGE TYPE IS &T'\n         AIF   (T'&TXT EQ 'U').MP\n         AIF   (T'&TXT EQ 'N').MP\n.* NO MESSAGE PRESENT\n&GT      SETC  (125)' '\n&TL      SETA  125\n         AGO   .NQL\n.* MESSAGE PRESENT\n.MP      ANOP\n&GT      SETC  '&TXT'\n         AIF   ('&TXT'(1,1) NE '''').NQL\n&GT      SETC  '&TXT'(2,K'&TXT-2)\n.* CHECK LENGTH:\n.NQL     ANOP\n&T       SETC  T'&LEN\n.*       MNOTE 'LENGTH TYPE IS &T'\n         AIF   (T'&LEN NE 'O').NLC\n.* NO LENGTH PRESENT\n         AIF   (T'&TXT EQ 'O').DL\n         AIF   (T'&TXT EQ 'U').UL\n&TL      SETA  L'&TXT\n         AGO   .LOK\n.UL      ANOP\n&TL      SETA  K'&GT\n         AGO   .NLL\n.* NO LENGTH AND NO MESSAGE: DEFAULT LEN = 125\n.DL      ANOP\n&TL      SETA  125\n         AGO   .NLL\n.* LENGTH PRESENT\n.NLC     AIF   (T'&LEN EQ 'N').SDL\n         AIF   (T'&LEN EQ 'U').NLL\n.* LENGTH NOT SELF DEFINING\n&TL      SETA  L'&LEN\n         AGO   .LOK\n.* LENGTH SELF DEFINING\n.SDL     ANOP\n         AIF   ('&LEN'(1,1) EQ '&P').NLL\n&TL      SETA  &LEN\n.LOK     ANOP\n.* FORCE MESSAGE LENGTH:\n&GT      SETC  '&GT'.(125)' '\n&GT      SETC  '&GT'(1,&TL)\n.NLL     ANOP\n         AIF   ('&MF(1)' EQ 'L').WTPL\n         AIF   ('&MF(1)' EQ 'E').WTPE\n&LAB1    WTO   &TXT,ROUTCDE=(11)\n         MEXIT\n.WTPL    ANOP\n&LAB1    WTO   '&GT',ROUTCDE=(11),MF=L\n         MEXIT\n.WTPE    ANOP\n         AIF   (T'&TXT NE 'O').YM\n         AIF   (N'&MF EQ 2).MFOK\n         MNOTE 8,'WTP MF TYPE INVALID'\n         MEXIT\n.MFOK    ANOP\n&LAB1    WTO   MF=&MF\n         MEXIT\n.YM      ANOP\n&LAB1    DS    0H\n         LH    1,&MF(2)\n         SH    1,=H'6'\n         MVI   &MF(2).+4,C' '\nC&SYSNDX MVC   &MF(2).+5(0),&MF(2).+4   CLEAR WTO BUFF\n         EX    1,C&SYSNDX\n         AIF   (T'&LEN EQ 'U').UL2\n         AIF   (T'&LEN EQ 'O').AIL\n         AIF   ('&LEN'(1,1) NE '&P').AIL\n&P       SETC  '&LEN'(2,K'&LEN-2)\n&CL      SETC  '0'\n         BCTR  &P,0\n         EX    &P,M&SYSNDX\n         LA    &P,1(&P)\n         AGO   .CT\n.AIL     ANOP\n&CL      SETC  '&TL'\n         AGO   .CT\n.UL2     ANOP\n&CL      SETC  '&LEN'\n.CT      AIF   (T'&TXT EQ 'C').CC\nM&SYSNDX MVC   &MF(2).+4(&CL),=C'&GT'\n         AGO   .EWTO\n.CC      ANOP\nM&SYSNDX MVC   &MF(2).+4(&CL),&TXT\n.EWTO    ANOP\n         WTO   MF=&MF\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XABGN": {"ttr": 2308, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   XABGN &SAVAREA,      ** NAME OF SAVE AREA IN PROGRAM          *\n               &NAME,         ** NAME ON STM INSTRUCTION IF &STMLBL='' *\n               &ID=,          ** HAS NO FUNCTION - FOR COMPATIBILITY   *\n               &AUTHOR=***,      AUTHOR'S INITIALS            (3 CHAR) *\n               &AMODE=24,        ADDRESSING MODE (SPLEVEL=2 ONLY)      *\n               &BASE=,           UP TO 3 BASE REGS R,(R,R),OR(R,R,R)   *\n               &BUREAU=WSRCC,    BUREAU RESPONSIBLE FOR CODE  (7 CHAR) *\n               &CSECT=YES,       YES - GENERATE CSECT IF NONE FOUND    *\n               &GEN=NOGEN,       LIST CODE FOR GETMAINING SAVE AREA    *\n               &ICATCH=YES,      YES - INCLUDE WSRCC BEGIN EYECATCH    *\n               &NOP=NO,          YES - GENERATE NOPR'S FOR ZAPPING     *\n               &R=R,             CHARACTERS TO PREFIX REGISTER NUMBERS *\n               &REQUS=YES,       YES - GENERATE REGISTER EQUATES       *\n               &RMODE=24,        RESIDENCY MODE (SPLEVEL=2 ONLY)       *\n               &SAVE=,           ADDRESS OR SPECIFICATION OF SAVEAREA  *\n               &SECTION=TECHSUP, SECTION RESPONSIBLE FOR CODE (7 CHAR) *\n               &SPLEVEL=2,       LEVEL OF MVS/SP BEING USED (1 OR 2)   *\n               &STMLBL=,         LABEL FOR THE STM STATEMENT           *\n               &TITLBL=*DFLT,    LABEL FOR TITLE STATEMENT             *\n               &TITLE=,          TITLE INFORMATION                     *\n               &TITSTMT=YES,     YES - GENERATE A TITLE STATEMENT      *\n               &TYPE=CSECT,      TYPE OF ENTRY: CSECT OR ENTRY         *\n               &UNIT=SYSSOFT,    UNIT RESPONSIBLE FOR CODE    (7 CHAR) *\n               &USING13=YES,     YES - INCLUDE USING R13 FOR &SAVAREA  *\n               &VER=             VERSION OF CODE              (4 CHAR)\n.*\n.* ABOVE COMMENTS PRECEEDED BY A ASTERISK ('**') INDICATE PARAMETER\n.* IS INCLUDED FOR COMPATIBILITY ONLY AND SHOULD NOT BE USED\n.*\n         GBLB  &RFLAG\n         GBLC  &RLEN,&RSP\n         GBLC  &SYSSPLV                                           V201\n         LCLC  &CLABEL,&SCODE,&SREG1,&SREG2,&SLBL,&SAVNAME,&BREG1\n         LCLC  &TITLBLC,&TITL,&TITLVER,&VERTEMP\n         LCLC  &C,&SPOT,&HDR,&CVAL\n         LCLC  &SPLDFLT,&AM,&RM,&MODECM                           V201\n.*\n&SPLDFLT SETC  '1'               DEFAULT SPLEVEL IF NOT SPECD.    V201\n.*\n         MNOTE *,'***WSRCC REENTRANT BEGIN MACRO V02.01***'       V201\n.*                  WITH THANKS TO HEWLETT-PACKARD BAEDP\n.*\n.*       &SPLEVEL IS USED TO INDICATE WHAT LEVEL OF MVS/SP IS     V201\n.*       BEING USED. IF MVS/SP 2.1.0 OR GREATER IS TO BE USED     V201\n.*       THEN CODE SPLEVEL=2 OTHERWISE SPLEVEL WILL DEFAULT       V201\n.*       TO SPLEVEL=1.                                            V201\n.*\n         AIF   ('&SPLEVEL' EQ '').SPLV00                          V201\n         AIF   ('&SPLEVEL' NE '1' AND '&SPLEVEL' NE '2').SPLERR   V201\n&SYSSPLV SETC  '&SPLEVEL'                                         V201\n         AGO   .SPLV99\n.*\n.SPLERR  ANOP                                                     V201\n         MNOTE 4,'*** SPLEVEL=&SPLEVEL IS INVALID ***'            V201\n         MNOTE *,'*** SPLEVEL MUST BE EITHER \"1\" OR \"2\" ***'      V201\n.*\n.SPLV00  ANOP                                                     V201\n&SYSSPLV SETC  '&SPLDFLT'        SET THE DEFAULT IF NOT SPECD.    V201\n.*\n.SPLV99  ANOP\n         MNOTE *,'*** SPLEVEL=&SYSSPLV BEING USED ***'            V201\n.*\n&CLABEL  SETC  '&SYSECT'\n         AIF   ('&CSECT' NE 'YES').CLBL99\n&CLABEL  SETC  '&LABEL'\n         AIF   ('&CLABEL' NE '').CLBL99\n&CLABEL  SETC  'PRIVATE'\n         MNOTE *,'*** NO LABEL ON BEGIN, &TYPE CALLED ''PRIVATE'' ***'\n.*\n.CLBL99  ANOP\n         AIF    ('&TYPE' NE 'ENTRY').ENT99\n&CLABEL  DS    0H\n         ENTRY &CLABEL\n         AGO   .CST99\n.*\n.ENT99   ANOP\n         AIF   ('&CSECT' NE 'YES').CST99\n&CLABEL  CSECT\n.*\n.CST99   ANOP\n         AIF   ('&SYSSPLV' EQ '1').SLB00                          V201\n&MODECM  SETC  ''                                                 V201\n&AM      SETC  '&AMODE'                                           V201\n&RM      SETC  '&RMODE'                                           V201\n         AIF   ('&AM' EQ '24' AND '&RM' EQ '24').AMD99            V201\n         AIF   ('&AM' EQ '31' AND '&RM' EQ '24').AMD99            V201\n         AIF   ('&AM' EQ '31' AND '&RM' EQ 'ANY').AMD99           V201\n         AIF   ('&AM' EQ 'ANY' AND '&RM' EQ '24').AMD99           V201\n         AIF   ('&AM' EQ 'ANY' AND '&RM' EQ 'ANY').AMD01          V201\n         MNOTE 4,'*** AMODE=&AM AND RMODE=&RM INVALID ***'        V201\n&MODECM  SETC  'INSTEAD '\n&AM      SETC  '24'\n&RM      SETC  '24'\n         AGO   .AMD99                                             V201\n.*\n.AMD01   ANOP                                                     V201\n&MODECM  SETC  'INSTEAD '\n&AM      SETC  '31'\n.*\n.AMD99   ANOP                                                     V201\n         MNOTE *,'*** USING AMODE=&AM AND RMODE=&RM &MODECM***'   V201\n&CLABEL  AMODE &AM                                                V201\n&CLABEL  RMODE &RM                                                V201\n.*\n.SLB00   ANOP\n&SLBL    SETC  '&STMLBL'\n         AIF   ('&SLBL' NE '').S1\n&SLBL    SETC  '&NAME'\n.*\n.S1      ANOP\n         USING &CLABEL,&R.15\n&C       SETC  'C'\n&SPOT    SETC  '&SYSECT'\n         AIF   ('&CLABEL' EQ '').LBL99\n&SPOT    SETC  '&CLABEL'\n         AIF   ('&TYPE' NE 'ENTRY').LBL99\n&C       SETC  'E'\n.*\n.LBL99   ANOP\n.*\n.*   PAD THE VERSION WITH _'S\n.*\n&VERTEMP SETC  '____'\n         AIF   ('&VER' EQ '').VERNULL\n&VERTEMP SETC  '&VER'\n         AIF   ('&VER'(1,1) NE '''').NOQUOTE\n&VERTEMP SETC  '&VER'(2,K'&VER-2)\n.*\n.NOQUOTE ANOP\n         LCLC  &PADSTG\n&PADSTG  SETC  (4)'_'\n&PADSTG  SETC  '&VERTEMP'.'&PADSTG'\n&VERTEMP SETC  '&PADSTG'(1,4)\n.*\n.VERNULL ANOP\n&HDR     SETC  'CL4''&VERTEMP.'''\n.*\n.HDR99   ANOP\n         AIF   ('&ICATCH' NE 'YES').NOICTCH\n         B     *+68\n         DC    AL1(64),CL3'ID='\n         DC    CL8'&SPOT'\n         DC    C'&C',AL3(&SPOT)\n         DC    &HDR\n         DC    C'_',C'&SYSDATE.@&SYSTIME._'\n         DC    CL7'&BUREAU',C'-'\n         DC    CL7'&SECTION',C':'\n         DC    CL7'&UNIT',C','\n         DC    CL3'&AUTHOR',C'.'\n.*\n.NOICTCH ANOP\n&SLBL    STM   &R.14,&R.12,12(&R.13)\n.*\n         AIF ('&NOP' EQ 'NO').NONOP\n         CNOP  0,4\n         B     *+20\n         DC    CL16'ZAP TO 17FF07FE:'\n         NOPR  R15         CAN ZAP TO 17FF ( XR  R15,R15 )\n         NOPR  R14         CAN ZAP TO 07FE ( BR  R14     )\n.*\n.NONOP   ANOP\n         DROP  &R.15\n.*\n&BREG1   SETC  '&BASE(1)'\n         AIF   ('&BREG1' NE '').B10\n&BREG1   SETC '&R.12'\n         MNOTE *,'** NO BASE REGISTER SPECIFIED ASSUME REGISTER 12 **'\n.*\n.B10     ANOP\n         LR    &BREG1,&R.15\n         USING &CLABEL,&BREG1\n         AIF   ('&BASE(2)' EQ '').B999\n         LA    &BASE(2),4095(&BREG1)\n         LA    &BASE(2),1(&BASE(2).)\n         USING &CLABEL+4096,&BASE(2)\n         AIF   ('&BASE(3)' EQ '').B999\n         LA    &BASE(3),4095(&BASE(2).)\n         LA    &BASE(3),1(&BASE(3).)\n         USING &CLABEL+8192,&BASE(3)\n.*\n.B999    ANOP\n         AIF   ('&SAVE' EQ 'NONE').SV99\n&SAVNAME SETC  '&SAVE(1)'\n&RLEN    SETC  '&SAVE(2)'\n&RSP     SETC  '&SAVE(3)'\n         AIF   ('&SAVNAME' NE '').SV10\n&SAVNAME SETC  '&SAVAREA'\n.*\n.SV10    ANOP\n         AIF   ('&SAVE(1)' NE '' OR '&SAVE(2)'  NE '' OR '&SAVE(3)' NE *\n               '').SV20\n         AIF   ('&SAVAREA' NE '').SVNRENT\n         AGO   .SVRENT\n.*\n.SV20    ANOP\n         AIF   ('&SAVE(2)' EQ '' AND '&SAVE(3)' EQ '').SVNRENT\n         AGO   .SVRENT\n.*\n.SVNRENT ANOP\n&RFLAG   SETB  0\n         LR    &R.15,&R.13\n         LA    &R.13,&SAVNAME\n         ST    &R.15,4(&R.13)\n         ST    &R.13,8(&R.15)\n         AGO   .SV99\n.*\n.SVRENT  ANOP\n&RFLAG   SETB  1\n         AIF   ('&RLEN' NE '').SVRSET\n&RLEN    SETC  '72'\n         MNOTE *,'*** REENTRANT SAVE AREA FORMAT USED ***'\n.*\n.SVRSET  ANOP\n.*\n.********* FOLLOWING FIX APPLIED 15 JAN 79 - DP *********************\n.* IF &RLEN IS AN 'L'' TYPE CONSTANT, DOUBLE-UP THE QUOTES FOR MNOTE\n.*\n         GBLC  &RLENA,&RLENB\n         LCLA  &LRLEN\n&RLENA   SETC  ''\n&RLENB   SETC  '&RLEN'\n         AIF   ('&RLEN'(1,2) NE 'L''').NORLQ\n&RLENA   SETC  'L'''''\n&LRLEN   SETA  K'&RLEN-2\n&RLENB   SETC  '&RLEN'(3,&LRLEN)\n.*\n.NORLQ   ANOP\n         MNOTE *,'*      GETMAIN R,LV=&RLENA.&RLENB,SP=&RSP'\n         PUSH  PRINT\n         PRINT &GEN\n         GETMAIN R,LV=&RLEN,SP=&RSP\n         POP   PRINT\n         LR    &R.15,&R.13\n         LR    &R.13,&R.1\n         ST    &R.15,4(&R.13)\n         ST    &R.13,8(&R.15)\n         LM    &R.15,&R.1,16(&R.15)    RESET 0, 1, AND 15\n         AGO   .SV99\n.*\n.SV99    ANOP\n         AIF   ('&SAVNAME' EQ '').UTH99\n         AIF   ('&USING13' NE 'YES').UTH99\n         USING &SAVNAME,&R.13\n.*\n.UTH99   ANOP\n         AIF   ('&REQUS' NE 'YES').REQNO\n         MNOTE *,'REGISTER NAMES &R.0 THROUGH &R.15 ARE ASSIGNED'\n&R.0     EQU   0\n&R.1     EQU   1\n&R.2     EQU   2\n&R.3     EQU   3\n&R.4     EQU   4\n&R.5     EQU   5\n&R.6     EQU   6\n&R.7     EQU   7\n&R.8     EQU   8\n&R.9     EQU   9\n&R.10    EQU   10\n&R.11    EQU   11\n&R.12    EQU   12\n&R.13    EQU   13\n&R.14    EQU   14\n&R.15    EQU   15\n.*\n.REQNO   ANOP\n         AIF   ('&TITSTMT' NE 'YES').TIT99\n&TITLBLC SETC  '&CLABEL'\n         AIF   ('&TITLBL' EQ '*DFLT').TIT50\n&TITLBLC SETC  '&TITLBL'\n.*\n.TIT50   ANOP\n&TITL    SETC  '&TITLE'\n         PUSH  PRINT\n         PRINT OFF       TITLE STATEMENT FOLLOWS\n         AIF   ('&TITLE' NE '').TIT79\n&TITL    SETC  ''' '''\n         AIF   ('&VER' EQ '').TIT79\n&TITLVER SETC  '&VER'\n&TITL    SETC  '''VER '.'&TITLVER'.''''\n.*\n.TIT79   ANOP\n         AIF   ('&TITL'(1,1) EQ '''').TIT89\n&TITL    SETC  ''''.'&TITL'.''''\n.*\n.TIT89   ANOP\n&TITLBLC TITLE &TITL\n         POP   PRINT\n.*\n.TIT99   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XAFIN": {"ttr": 2314, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   XAFIN &GEN=NOGEN,             GEN - LIST CODE FOR FREEMAIN    *\n               &R=R,                   PREFIX FOR REGISTERS            *\n               &RC=0,                  ABSOLUTE OR (R) FOR RETURN CODE *\n               &RC1=,                  ABS OR (R) VALUE RETURNED IN R1 *\n               &RETURN=YES,            YES - GENERATE CODE FOR RETURN  *\n               &RTRNOFF=               RETURN OFFSET VALUE\n.*\n         GBLB  &RFLAG\n         GBLC  &RLEN,&RLENA,&RLENB,&RSP,&CT\n         GBLC  &SYSSPLV                                           V201\n         LCLC  &OPCD,&OPC1,&RETCODE,&RETCD1\n.*\n.*       MNOTE *,'***WSRCC REENTRANT FINISH MACRO V02.01***'      V201\n.*                  WITH THANKS TO HEWLETT-PACKARD BAEDP\n.*\n          AIF   ('&SYSLIST(1)' EQ '').ERR99\n          MNOTE 8,'*** PARTIAL REGISTER LIST NO LONGER SUPPORTED IN BEG*\n                IN OR FINISH ***'\n.*\n.ERR99   ANOP\n&RETCODE SETC  '&RC(1)'\n         AIF   ('&RETCODE' NE '').RC99\n&RETCODE SETC  '0'\n         MNOTE *,'*** NO RETURN CODE SPECIFIED ** ZERO ASSUMED ***'\n.*\n.RC99    ANOP\n&OPCD    SETC  'LR'\n         AIF   ('&RC'(1,1) EQ '(').OP99\n&OPCD    SETC  'LA'\n.*\n.OP99    ANOP\n&RETCD1  SETC  '&RC1(1)'\n         AIF   ('&RETCD1' EQ '').OP199\n.*\n&OPC1    SETC  'LR'\n         AIF   ('&RC1'(1,1) EQ '(').OP199\n&OPC1    SETC  'LA'\n.*\n.OP199   ANOP\n         CNOP  0,4\n&LABEL   DS    0H                                                 V201\n         AIF   ('&SYSSPLV' EQ '2').SKIPFF                         V201\n         OI    4(&R.13),X'FF'                                     V201\n.*\n.SKIPFF  ANOP\n         AIF   (NOT &RFLAG).GOHOME\n.*\n.RENT    ANOP\n         AIF   ('&OPCD' NE 'LR').RENT10\n         LR    &R.2,&RETCODE\n&RETCODE SETC  '&R.2'\n.*\n.RENT10  ANOP\n         AIF   ('&OPC1' NE 'LR').RENT20\n         LR    &R.3,&RETCD1\n&RETCD1  SETC  '&R.3'\n.*\n.RENT20  ANOP\n         LR    &R.1,&R.13\n         L     &R.13,4(&R.13)\n         MNOTE *,'*      FREEMAIN R,LV=&RLENA.&RLENB,A=(1),SP=&RSP'\n         PUSH  PRINT\n         PRINT &GEN\n         FREEMAIN R,LV=&RLEN,A=(1),SP=&RSP\n         POP   PRINT\n         AGO   .COMEND\n.*\n.GOHOME ANOP\n         L     &R.13,4(&R.13)\n.*\n.COMEND  ANOP\n         &OPCD &R.15,&RETCODE\n         L     &R.14,12(&R.13)\n         AIF   ('&OPC1' EQ '').GH90\n         L     &R.0,20(&R.13)\n         &OPC1 &R.1,&RETCD1\n         LM    &R.2,&R.12,28(&R.13)\n         AGO   .GH99\n.*\n.GH90    ANOP\n         LM    &R.0,&R.12,20(&R.13)\n.*\n.GH99    ANOP\n         AIF   ('&RETURN' NE 'YES').RET99\n         AIF   ('&SYSSPLV' EQ '2').ROFCK                          V201\n         MVI   12(&R.13),X'FF'\n.*\n.ROFCK   ANOP                                                     V201\n         AIF   ('&RTRNOFF' EQ '').BR14\n         B     &RTRNOFF.(&R.14)      TAKE SPECIAL RETURN WITH OFFSET\n         AGO   .RET99\n.*\n.BR14    ANOP\n         BR    &R.14\n.*\n.RET99   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XL": {"ttr": 2317, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "STACK\nLOGOFF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XLN": {"ttr": 2319, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 0\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n /* XLN DOES AN EXIT FROM ISPF, AND A LOGON FOR THE SAME USER       */\n /* XLN.XXXXXX DOES AN EXIT AND A LOGON FOR USER XXXXXX             */\n /* XLN.XXXXXX.YYYYYY DOES AN EXIT AND LOGON FOR USER XXXXX AND     */\n /*                   USES PROC YYYYYY                              */\n /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\nISPEXEC VGET (XT1 XT2)\nIF &XT2 \u00ac= /*NULL*/ THEN SET &XT2 = &STR(PROC(&XT2))\nSTACK\nLOGON &XT1 &XT2\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT124/FILE124.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT124", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}