{"INMR01": {"INMLRECL": 80, "INMFNODE": "MVSJESY", "INMFUID": "SCNS03", "INMTNODE": "NODE", "INMTUID": "DUMMY", "INMFTIME": "20140120191241000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 25500, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "SCNS.HDGA510.PERL.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SCNS.HDGA510.PERL.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 25500, "DS1LRECL": 255, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x0b\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x05\\x80\\x00\\x04|\\x1bh'", "extents": ["b'\\x0b\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x05\\x80\\x00\\x04|\\x1bh'", "b'X\\xfc\\x06`\\x00\\x00\\t\\xe2\\x00\\x07\\t\\xe2\\x00\\r\\x00\\x07'", "b'X\\xfc\\x06`\\x00\\x00\\x03#\\x00\\x05\\x03#\\x00\\x06\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x03#\\x00\\x07\\x03#\\x00\\x08\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x0cz\\x00\\t\\x0cz\\x00\\n\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x0cz\\x00\\x0b\\x0cz\\x00\\x0c\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x0cz\\x00\\r\\x0cz\\x00\\x0e\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x03\\xc9\\x00\\r\\x03\\xc9\\x00\\x0e\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x04:\\x00\\r\\x04:\\x00\\x0e\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x03l\\x00\\x0c\\x03l\\x00\\r\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\x03F\\x00\\t\\x03F\\x00\\n\\x00\\x02'", "b'X\\xfc\\x06`\\x00\\x00\\n\\x8a\\x00\\x06\\n\\x8a\\x00\\x07\\x00\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"JNDMEXPT": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x13$\\x8f\\x01\\x14\\x02\\x0f\\x14\\x11\\x00\\xb6\\x00\\xb8\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-05T00:00:00", "modifydate": "2014-01-20T14:11:11", "lines": 182, "newlines": 184, "modlines": 0, "user": "SCNS03"}, "text": "#!/usr/bin/perl\n# ndmdaily.pl - filter to convert ConnectDirect Unix Statistics file into NDM report format\n\n# Here's an example of an input record broken up to make readable.\n# STAR=20040826 10:45:07|PNAM=MVS2AS02|PNUM=60102|SSTA=20040826 10:45:06|\n# STRT=20040826 10:45:06|STOP=20040826 10:45:07|STPT=20040826 10:45:07|SELA=00:00:01|SUBM=SCNSXMT@SWPNDM01|\n# SNOD=SWPGIPAS02|CCOD=0|RECI=CTRC|RECC=CAPR|MSGI=SCPA000I|MSST=Copy step successful.|STDL=Thu Aug 26 10:45:07 2004|\n# CSDS=Thu Aug 26 10:45:06 2004|LCCD=0|LMSG=SCPA000I|OCCD=0|OMSG=SCPA000I|PNAM=MVS2AS02|PNUM=60102|\n# SNAM=STEP01|SBND=SWPNDM01|SBID=SCNSXMT|PNOD=SWPNDM01|SNOD=SWPGIPAS02|LNOD=S|FROM=P|XLAT=Y|SCMP=N|ECMP=Y|ECPR=9.79|\n# ECTP=ECZ|ZLVL=1|ZWIN=13|ZMEM=4|OERR=N|CKPT=N|LKFL=N|RSTR=N|RUSZ=4096|PACC=|SACC=|PPMN=PRTINFO|SFIL=SYS2.DOCUMENT|\n# SDS1=S|SDS2= |SDS3= |SBYR=696960|SFSZ=0|SRCR=8712|SBYX=68262|SRUX=0|SVSQ=0|SVCN=0|SVOL=|DFIL=/home/tcieri/prts.dat|\n# PPMN=PRTINFO|DDS1=R|DDS2= |DDS3= |DBYW=400752|DRCW=8712|DBYX=68262|DRUX=17|DVSQ=0|DVCN=0|DVOL=|ICRC=N|PCRC=N\n\n# Here is the header and an example of an output record.\n#    USERID      PROC #   PROC NAME    STEP NAME    EXCEPTION INFORMATION\n#    ******      ******   *********    *********    *****************************************************************\n#\n#    PRODJOB     81579    O0405P01     PRECHECK     11/01/2012 PNODE = SWPNDM01          SNODE = SWPEAET01\n#                                                   TRANSMISSION TIME = 0:00:00.25       COMPLETION CODE = 00000000\n#                                                   COPY STEP SUCCESSFUL.\n#                                                   SRC DSNAME IS D0370.CUSTOM.JJ370FTR.G1118V00\n#                                                   DEST DSNAME IS /apps/swp/ndmlanding/etltlm/SrcFiles/Pos/FT/JJ370FTR.TXT\n#                                                        SENDING NODE ==> SWPNDM01         RECEIVING NODE ==> SWPEAET01\n#                                                        BYTES READ   ==> 168              BYTES WRITTEN  ==> 149\n#                                                        RUs   READ   ==> 1                RUs   WRITTEN  ==> 0\n#                                                        RECS READ    ==> 5                RECS WRITTEN   ==> 5\n#                                                        BYTES SENT   ==> 154              BYTES RECEIVED ==> 154\n#                                                        COMPRESSION% ==> 8.3              COMPRESSION%   ==> -3.2\n#                                                        VOLSER       ==> STGS42           VOLSER         ==>\n#    -----------------------------------------------------------------------------------------------------------------------\n\n# Change Log:\n#\n# 2009-012  Truncate the Procname at 8 characters (PNAM). Also, add a subroutine to format the byte count to include commas.\n# 2012-314  Changed upper case 'EQ' and 'NE' to lower case for z/OS.\n#\n\n##\n## Check syntax\n##\n## If the offset of the last argument is not 0, in other words if the number of arguments is not exactly 1,\n## then print the text that appears between << and ARGERR\nif ($#ARGV != 0){\n   print <<ARGERR;\n***\n$0:\nFatal Error: Wrong number of arguments.\n\nUsage:\n       $0 input_file\n\nParameters:\n   input_file is any file containing NDM logs in the following format\n      each line is a record with fields delimited by vertical bar\n      each field is a label=value pair\n      the following labels are processed:\n         SBID, PNUM, PNAM, SNAM, RECI, STRT, STPT, XMIT, PNOD, ECPR, CTYP,\n         RUSZ, SBYX, CCOD, MSGI, STAR, SCMP, ECMP\n\nARGERR\n   exit;\n}\n\n$ifilename = $ARGV\u00dd0\u00a8;                                  # First command line argument is input file\nif (! -e $ifilename){\n   print \"Fatal Error: Could not find input file $ifilename\\n\";\n   exit;\n}\nopen IFILE, \"<$ifilename\" || die \"Fatal Error opening input file: $ifilename.\\n\";\n\n# Determine the name of the server we are running on\n$cdnode = `uname -n | /bin/tr '\u00dd:lower:\u00a8' '\u00dd:upper:\u00a8'`;\n# Print the Header first\nprint \"                                                    Connect:Direct Exception Report  (ARS00003)       \\n\";\nprint \"                                                           Node = $cdnode                      \\n\";\nprint \"          \\n\";\nprint \"   USERID     PROC #   PROC NAME  STEP NAME   EXCEPTION INFORMATION                                          \\n\"   ;\nprint \"   ******     ******   *********  *********   ************************************************************************************** \\n\";\nprint \"\\n\";\n\n# Read each line in, process and output immediately.\nwhile (<IFILE>){\n   if ((m/RECI\\=CTRC/) or                               # Don't bother processing fields that do not contain RECI=CTRC\n       (m/RECI\\=RJED/) or                               #                                                 or RECI=RJED\n       (m/RECI\\=RTED/) or                               #                                                 or RECI=RTED\n       (m/RECI\\=USEC/)){                                #                                                 or RECI=USEC\n      chomp;                                            # Remove the newline\n      @fields=split/\\|/;                                # Split record into fields on \"|\" save in the array named @fields\n      foreach $field (@fields){                         # For each | separated field\n         ($flabel, $fvalue) = split(/=/, $field, 2);    # Split it into label=value pairs\n\n         # Do some field specific processing.\n\n         $H{$flabel}=$fvalue;                           # And add an entry into hash indexed by label & containing value\n      }\n      if ($H{RECI} eq 'CTRC'){\n        if ($H{PNOD} eq $H{SNOD}){$lclnod = $H{SNOD};}\n      }\n      if (($H{CCOD} ne '0') && ($H{CCOD} ne '2')){\n\n      # Now do the processing that requires data in multiple fields since you'll finally have it here.\n\n      # Format the date for printing\n      $styrs =  substr($H{STAR}, 0, 4);\n      $stmos =  substr($H{STAR}, 4, 2);\n      $stday =  substr($H{STAR}, 6, 2);\n      $H{TIME} = substr($H{STAR}, 9, 8);\n      $H{DATE} = $stmos . \"/\" . $stday . \"/\" . $styrs ;\n\n      # Change record type (RECI) for readability (i.e. COPY, RUNJ, RUNT etc.)\n      if ($H{RECI} eq 'CTRC'){$H{RECT}=\"** COPY **\";}\n      if ($H{RECI} eq 'RJED'){$H{RECT}=\"** RUNJOB **\";}\n      if ($H{RECI} eq 'RTED'){$H{RECT}=\"** RUNTASK **\";}\n      if ($H{RECI} eq 'USEC'){$H{RECT}=\"** USER SEC **\";}\n\n      # Check for errors.\n\n      # SBID and first half of SUBM should match\n      ($sbid2, $trash) = split(/@/, $H{SUBM});\n      if ($sbid2 ne $H{SBID}){print STDERR \"Warning: SBID and first half of SUBM do not match.\\n\";}\n\n      # SCMP and ECMP should never both be 'Y'.\n      if (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'Y')){print STDERR \"Warning: SCMP and ECMP are both 'Y'.\\n\";}\n\n\n      # Now print individual record.\n      print \"  \";                                      # Leading 4 spaces\n\n      $tmp=sprintf(\"%8s\",  $H{SBID}); print \"$tmp \";\n      $tmp=sprintf(\"%9s\", &commify($H{PNUM})); print \"$tmp \";\n      $tmp=sprintf(\"%10.8s\",  $H{PNAM}); print \"$tmp \";\n      $tmp=sprintf(\"%10s\",  $H{SNAM}); print \"$tmp \";\n\n      # Now determine Sending and Receiving Nodes\n\n      if ($H{FROM} eq 'P'){$H{XNOD} = $H{PNOD}; $H{RNOD} = $H{SNOD};}\n      if ($H{FROM} eq 'S'){$H{XNOD} = $H{SNOD}; $H{RNOD} = $H{PNOD};}\n      if ($H{RECI} eq 'USEC'){\n         $H{XNOD} = $H{SBND};\n         if ($H{SNOD} ne $H{SBND}){$H{PNOD} = $H{SBND}; $H{RNOD} = $H{SNOD};}\n         if ($H{SNOD} eq $H{SBND}){$H{PNOD} = $lclnod; $H{RNOD} = $H{PNOD};}\n       }\n\n      # Now print the transmission info.\n\n      print \"   $H{RECT} \\n\"                                            ;\n      print \"                                              $H{DATE} $H{TIME} PNODE = \";\n      $tmp=sprintf(\"%-16s\",  $H{PNOD}); print \"$tmp \";\n      print \"SNODE = $H{SNOD} \\n\";\n      print \"                                              COMPLETION CODE = \";\n      $tmp=sprintf(\"%08s\",  $H{CCOD}); print \"$tmp \";\n      print \"                  MSG ID = \";\n      $tmp=sprintf(\"%8s\",  $H{MSGI}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              SENDING NODE ==> \";\n      $tmp=sprintf(\"%-16s\",  $H{XNOD}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              SRC DSNAME   ==> \";\n      $tmp=sprintf(\"%8s\",  $H{SFIL}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              RECEIVING NODE ==> \";\n      $tmp=sprintf(\"%-16s\",  $H{RNOD}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              DEST DSNAME    ==> \";\n      $tmp=sprintf(\"%8s\",  $H{DFIL}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              \";\n      $tmp=sprintf(\"%8s\",  $H{MSST}); print \"$tmp \";\n      print \"\\n\";\n      print \"   --------------------------------------------------------------------------------------------------------------------------------- \\n\";\n      }\n\n      foreach $field (keys(%H)){                         # Be sure to reinitialize all fields.\n         $H{$field}=\"\";\n      }\n   }\n}\nsub commify {\n    local($_) = shift;\n    1 while s/\u00ac(-?\\d+)(\\d{3})/$1,$2/;\n    return $_;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JNDMSECT": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x01\\x13$\\x8f\\x01\\x14\\x02\\x0f\\x14\\x11\\x00\\xa1\\x00\\xa3\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-05T00:00:00", "modifydate": "2014-01-20T14:11:15", "lines": 161, "newlines": 163, "modlines": 0, "user": "SCNS03"}, "text": "#!/usr/bin/perl\n# ndmdaily.pl - filter to convert ConnectDirect Unix Statistics file into NDM report format\n\n# Here's an example of an input record broken up to make readable.\n# STAR=20040826 10:45:07|PNAM=MVS2AS02|PNUM=60102|SSTA=20040826 10:45:06|\n# STRT=20040826 10:45:06|STOP=20040826 10:45:07|STPT=20040826 10:45:07|SELA=00:00:01|SUBM=SCNSXMT@SWPNDM01|\n# SNOD=SWPGIPAS02|CCOD=0|RECI=CTRC|RECC=CAPR|MSGI=SCPA000I|MSST=Copy step successful.|STDL=Thu Aug 26 10:45:07 2004|\n# CSDS=Thu Aug 26 10:45:06 2004|LCCD=0|LMSG=SCPA000I|OCCD=0|OMSG=SCPA000I|PNAM=MVS2AS02|PNUM=60102|\n# SNAM=STEP01|SBND=SWPNDM01|SBID=SCNSXMT|PNOD=SWPNDM01|SNOD=SWPGIPAS02|LNOD=S|FROM=P|XLAT=Y|SCMP=N|ECMP=Y|ECPR=9.79|\n# ECTP=ECZ|ZLVL=1|ZWIN=13|ZMEM=4|OERR=N|CKPT=N|LKFL=N|RSTR=N|RUSZ=4096|PACC=|SACC=|PPMN=PRTINFO|SFIL=SYS2.DOCUMENT|\n# SDS1=S|SDS2= |SDS3= |SBYR=696960|SFSZ=0|SRCR=8712|SBYX=68262|SRUX=0|SVSQ=0|SVCN=0|SVOL=|DFIL=/home/tcieri/prts.dat|\n# PPMN=PRTINFO|DDS1=R|DDS2= |DDS3= |DBYW=400752|DRCW=8712|DBYX=68262|DRUX=17|DVSQ=0|DVCN=0|DVOL=|ICRC=N|PCRC=N\n\n# Here is the header and an example of an output record.\n#    USERID      PROC #   PROC NAME    STEP NAME    EXCEPTION INFORMATION\n#    ******      ******   *********    *********    *****************************************************************\n#\n#    PRODJOB     81579    O0405P01     PRECHECK     11/01/2012 PNODE = SWPNDM01          SNODE = SWPEAET01\n#                                                   TRANSMISSION TIME = 0:00:00.25       COMPLETION CODE = 00000000\n#                                                   COPY STEP SUCCESSFUL.\n#                                                   SRC DSNAME IS D0370.CUSTOM.JJ370FTR.G1118V00\n#                                                   DEST DSNAME IS /apps/swp/ndmlanding/etltlm/SrcFiles/Pos/FT/JJ370FTR.TXT\n#                                                        SENDING NODE ==> SWPNDM01         RECEIVING NODE ==> SWPEAET01\n#                                                        BYTES READ   ==> 168              BYTES WRITTEN  ==> 149\n#                                                        RUs   READ   ==> 1                RUs   WRITTEN  ==> 0\n#                                                        RECS READ    ==> 5                RECS WRITTEN   ==> 5\n#                                                        BYTES SENT   ==> 154              BYTES RECEIVED ==> 154\n#                                                        COMPRESSION% ==> 8.3              COMPRESSION%   ==> -3.2\n#                                                        VOLSER       ==> STGS42           VOLSER         ==>\n#    -----------------------------------------------------------------------------------------------------------------------\n\n# Change Log:\n#\n# 2009-012  Truncate the Procname at 8 characters (PNAM). Also, add a subroutine to format the byte count to include commas.\n# 2012-314  Changed upper case 'EQ' and 'NE' to lower case for z/OS.\n#\n\n##\n## Check syntax\n##\n## If the offset of the last argument is not 0, in other words if the number of arguments is not exactly 1,\n## then print the text that appears between << and ARGERR\nif ($#ARGV != 0){\n   print <<ARGERR;\n***\n$0:\nFatal Error: Wrong number of arguments.\n\nUsage:\n       $0 input_file\n\nParameters:\n   input_file is any file containing NDM logs in the following format\n      each line is a record with fields delimited by vertical bar\n      each field is a label=value pair\n      the following labels are processed:\n         SBID, PNUM, PNAM, SNAM, RECI, STRT, STPT, XMIT, PNOD, ECPR, CTYP,\n         RUSZ, SBYX, CCOD, MSGI, STAR, SCMP, ECMP\n\nARGERR\n   exit;\n}\n\n$ifilename = $ARGV\u00dd0\u00a8;                                  # First command line argument is input file\nif (! -e $ifilename){\n   print \"Fatal Error: Could not find input file $ifilename\\n\";\n   exit;\n}\nopen IFILE, \"<$ifilename\" || die \"Fatal Error opening input file: $ifilename.\\n\";\n\n# Determine the name of the server we are running on\n$cdnode = `uname -n | /bin/tr '\u00dd:lower:\u00a8' '\u00dd:upper:\u00a8'`;\n\n# Print the Header first\nprint \"                                                    Connect:Direct Security Exception Report  (ARS00004)      \\n\";\nprint \"                                                           Node = $cdnode                      \\n\";\nprint \"          \\n\";\nprint \"   USERID     PROC #   PROC NAME  STEP NAME   EXCEPTION INFORMATION                                          \\n\"   ;\nprint \"   ******     ******   *********  *********   ************************************************************************************** \\n\";\nprint \"\\n\";\n\n# Read each line in, process and output immediately.\nwhile (<IFILE>){\n   if ((m/RECI\\=XBUM/) or                               # Don't bother processing fields that do not contain RECI=USEC\n       (m/RECI\\=XCMM/) or                               #                                                 or RECI=XCPS\n       (m/RECI\\=XCPS/) or                               #                                                 or RECI=XCPS\n       (m/RECI\\=XPMR/) or                               #                                                 or RECI=XCPS\n       (m/RECI\\=XSQF/)){                                #                                                 or RECI=XSQF\n      chomp;                                            # Remove the newline\n      @fields=split/\\|/;                                # Split record into fields on \"|\" save in the array named @fields\n      foreach $field (@fields){                         # For each | separated field\n         ($flabel, $fvalue) = split(/=/, $field, 2);    # Split it into label=value pairs\n\n         # Do some field specific processing.\n\n         $H{$flabel}=$fvalue;                           # And add an entry into hash indexed by label & containing value\n      }\n      if ($H{CCOD} ne '0'){\n\n      # Now do the processing that requires data in multiple fields since you'll finally have it here.\n\n      # Format the date for printing\n      $styrs =  substr($H{STAR}, 0, 4);\n      $stmos =  substr($H{STAR}, 4, 2);\n      $stday =  substr($H{STAR}, 6, 2);\n      $H{TIME} = substr($H{STAR}, 9, 8);\n      $H{DATE} = $stmos . \"/\" . $stday . \"/\" . $styrs ;\n\n      # Change record type (RECI) for readability (i.e. COPY, RUNJ, RUNT etc.)\n      if ($H{RECI} eq 'CTRC'){$H{RECT}=\"** COPY **\";}\n      if ($H{RECI} eq 'RJED'){$H{RECT}=\"** RUNJOB **\";}\n      if ($H{RECI} eq 'RTED'){$H{RECT}=\"** RUNTASK **\";}\n\n      # Check for errors.\n\n      # SBID and first half of SUBM should match\n      ($sbid2, $trash) = split(/@/, $H{SUBM});\n      if ($sbid2 ne $H{SBID}){print STDERR \"Warning: SBID and first half of SUBM do not match.\\n\";}\n\n      # SCMP and ECMP should never both be 'Y'.\n      if (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'Y')){print STDERR \"Warning: SCMP and ECMP are both 'Y'.\\n\";}\n\n\n      # Now print individual record.\n      print \"  \";                                      # Leading 4 spaces\n\n      $tmp=sprintf(\"%8s\",  $H{SBID}); print \"$tmp \";\n      $tmp=sprintf(\"%9s\", &commify($H{PNUM})); print \"$tmp \";\n      $tmp=sprintf(\"%10.8s\",  $H{PNAM}); print \"$tmp \";\n      $tmp=sprintf(\"%10s\",  $H{SNAM}); print \"$tmp \";\n\n      # Now determine Sending and Receiving Nodes\n\n      if ($H{FROM} eq 'P'){$H{XNOD} = $H{PNOD}; $H{RNOD} = $H{SNOD};}\n      if ($H{FROM} eq 'S'){$H{XNOD} = $H{SNOD}; $H{RNOD} = $H{PNOD};}\n\n      # Now print the transmission info.\n\n      print \"   $H{RECI} \\n\"                                            ;\n      print \"                                              $H{DATE} $H{TIME} PNODE = $H{PNOD}          SNODE = $H{SNOD} \\n\";\n      print \"                                              COMPLETION CODE = \";\n      $tmp=sprintf(\"%08s\",  $H{CCOD}); print \"$tmp \";\n      print \"                 MSG ID = \";\n      $tmp=sprintf(\"%8s\",  $H{MSGI}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              \";\n      $tmp=sprintf(\"%8s\",  $H{MSGT}); print \"$tmp \";\n      print \"\\n\";\n      print \"   --------------------------------------------------------------------------------------------------------------------------------- \\n\";\n      }\n\n      foreach $field (keys(%H)){                         # Be sure to reinitialize all fields.\n         $H{$field}=\"\";\n      }\n   }\n}\nsub commify {\n    local($_) = shift;\n    1 while s/\u00ac(-?\\d+)(\\d{3})/$1,$2/;\n    return $_;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JNDMTIME": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\"\\x01\\x13$\\x8f\\x01\\x14\\x02\\x0f\\x14\\x11\\x00\\xd0\\x00\\xd2\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-05T00:00:00", "modifydate": "2014-01-20T14:11:22", "lines": 208, "newlines": 210, "modlines": 0, "user": "SCNS03"}, "text": "#!/usr/bin/perl\n# ndmdaily.pl - filter to convert ConnectDirect Unix Statistics file into NDM report format\n\n# Here's an example of an input record broken up to make readable.\n# STAR=20040826 10:45:07|PNAM=MVS2AS02|PNUM=60102|SSTA=20040826 10:45:06|\n# STRT=20040826 10:45:06|STOP=20040826 10:45:07|STPT=20040826 10:45:07|SELA=00:00:01|SUBM=SCNSXMT@SWPNDM01|\n# SNOD=SWPGIPAS02|CCOD=0|RECI=CTRC|RECC=CAPR|MSGI=SCPA000I|MSST=Copy step successful.|STDL=Thu Aug 26 10:45:07 2004|\n# CSDS=Thu Aug 26 10:45:06 2004|LCCD=0|LMSG=SCPA000I|OCCD=0|OMSG=SCPA000I|PNAM=MVS2AS02|PNUM=60102|\n# SNAM=STEP01|SBND=SWPNDM01|SBID=SCNSXMT|PNOD=SWPNDM01|SNOD=SWPGIPAS02|LNOD=S|FROM=P|XLAT=Y|SCMP=N|ECMP=Y|ECPR=9.79|\n# ECTP=ECZ|ZLVL=1|ZWIN=13|ZMEM=4|OERR=N|CKPT=N|LKFL=N|RSTR=N|RUSZ=4096|PACC=|SACC=|PPMN=PRTINFO|SFIL=SYS2.DOCUMENT|\n# SDS1=S|SDS2= |SDS3= |SBYR=696960|SFSZ=0|SRCR=8712|SBYX=68262|SRUX=0|SVSQ=0|SVCN=0|SVOL=|DFIL=/home/tcieri/prts.dat|\n# PPMN=PRTINFO|DDS1=R|DDS2= |DDS3= |DBYW=400752|DRCW=8712|DBYX=68262|DRUX=17|DVSQ=0|DVCN=0|DVOL=|ICRC=N|PCRC=N\n\n# Here is the header and an example of an output record.\n#             PROC   PROC   STEP     STEP    START   END TIME    XMT TIME           COMP CMP    RU       BYTES COND\n#    USERID    #     NAME   NAME     TYPE  HH:MM:SS  HH:MM:SS  H:MM:SS.TT  PNODE       % TYP  SIZE        SENT CODE   MSG     DATE\n#\n#    PRODJOB 81579 O0405P01 PRECHECK RUNT   3:58:19   3:58:20  0:00:00.77 SWPNDM01    -          -           - 000000     08/30/04\n\n# Change Log:\n#\n# 2009-012  Truncate the Procname at 8 characters (PNAM). Also, add a subroutine to format the byte count to include commas.\n# 2012-314  Changed upper case 'EQ' and 'NE' to lower case for z/OS.\n#\n\n##\n## Check syntax\n##\n## If the offset of the last argument is not 0, in other words if the number of arguments is not exactly 1,\n## then print the text that appears between << and ARGERR\nif ($#ARGV != 0){\n   print <<ARGERR;\n***\n$0:\nFatal Error: Wrong number of arguments.\n\nUsage:\n       $0 input_file\n\nParameters:\n   input_file is any file containing NDM logs in the following format\n      each line is a record with fields delimited by vertical bar\n      each field is a label=value pair\n      the following labels are processed:\n         SBID, PNUM, PNAM, SNAM, RECI, STRT, STPT, XMIT, PNOD, ECPR, CTYP,\n         RUSZ, SBYX, CCOD, MSGI, STAR, SCMP, ECMP\n\nARGERR\n   exit;\n}\n\n$ifilename = $ARGV\u00dd0\u00a8;                                  # First command line argument is input file\nif (! -e $ifilename){\n   print \"Fatal Error: Could not find input file $ifilename\\n\";\n   exit;\n}\nopen IFILE, \"<$ifilename\" || die \"Fatal Error opening input file: $ifilename.\\n\";\n\n# Determine the name of the server we are running on\n$cdnode = `uname -n | /usr/bin/tr '\u00dd:lower:\u00a8' '\u00dd:upper:\u00a8'`;\n\n# Print the Header first\nprint \"                                                    Connect:Direct Activity Report      (ARS00001)       \\n\";\nprint \"                                                           Node = $cdnode                      \\n\";\nprint \"          \\n\";\nprint \"           PROC     PROC     STEP STEP    START END TIME XMT TIME                   COMP CMP    RU       BYTES COND\\n\";\nprint \"   USERID     #     NAME     NAME TYPE HH:MM:SS HH:MM:SS HH:MM:SS      Other NODE      % TYP  SIZE        SENT CODE      MSG     DATE\\n\";\nprint \"\\n\";\n\n# Read each line in, process and output immediately.\nwhile (<IFILE>){\n   if ((m/RECI\\=CTRC/) or                               # Don't bother processing fields that do not contain RECI=CTRC\n       (m/RECI\\=RJED/) or                               #                                                    RECI=RJED\n       (m/RECI\\=RTED/)){                                #                                                 or RECI=RTED\n      chomp;                                            # Remove the newline\n      @fields=split/\\|/;                                # Split record into fields on \"|\" save in the array named @fields\n      foreach $field (@fields){                         # For each | separated field\n         ($flabel, $fvalue) = split(/=/, $field);       # Split it into label=value pairs\n\n         # Do some field specific processing.\n         if ($flabel eq \"STRT\"){\n            ($vdate, $vtime) = split(/\\s+/, $fvalue);   # Split STRT into date and time components\n            $fvalue = $vtime;                           # and only keep the time.\n         }\n         if ($flabel eq \"STPT\"){\n            ($vdate, $vtime) = split(/\\s+/, $fvalue);   # Split STPT into date and time components\n            $fvalue = $vtime;                           # and only keep the time.\n         }\n         if ($flabel eq \"STAR\"){\n            ($vdate, $vtime) = split(/\\s+/, $fvalue);   # Split STRT into date and time components\n            $fvalue = $vdate;                           # and only keep the date.\n         }\n\n         $H{$flabel}=$fvalue;                           # And add an entry into hash indexed by label & containing value\n      }\n\n      # Now do the processing that requires data in multiple fields since you'll finally have it here.\n\n      # Calculate CTYP based upon SCMP and ECMP\n      if    (($H{SCMP} eq 'N') && ($H{ECMP} eq 'N')){$H{CTYP}=\" NO\";}\n      elsif (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'N')){$H{CTYP}=\"YES\";}\n      elsif (($H{SCMP} eq 'N') && ($H{ECMP} eq 'Y')){$H{CTYP}=\"EXT\";}\n      else                                          {$H{CTYP}=\"   \";} # (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'Y'))\n\n\n      # Calculate XMIT based upon STRT and STPT\n      # Convert STRT and STPT from HH:MM:SS format into seconds.\n      ($strthrs, $strtmins, $strtsecs) = split(/:/, $H{STRT});   # Split STRT into hours, minutes and seconds on \":\".\n      ($stpthrs, $stptmins, $stptsecs) = split(/:/, $H{STPT});   # Split STPT into hours, minutes and seconds on \":\".\n\n      $xmithrs =  $stpthrs - $strthrs;\n      $xmitmins = $stptmins - $strtmins;\n      $xmitsecs = $stptsecs - $strtsecs;\n\n      if ($strtmins > $stptmins){\n         $xmitmins = $xmitmins + 60;\n         $xmithrs = $xmithrs - 1;\n      }\n\n      if ($strtsecs > $stptsecs){\n         $xmitsecs = $xmitsecs + 60;\n         $xmitmins = $xmitmins - 1;\n      }\n\n      $hrs = $xmithrs;                      # Zero $hrs, $mins, $secs so we can reuse.\n      $mins = $xmitmins;\n      $secs = $xmitsecs;\n\n      # and then format for printing.\n      $hrs=\"\" .$hrs ;\n      $mins=\"\".$mins; while (length($mins)<2){$mins=\"0\".$mins;}\n      $secs=\"\".$secs; while (length($secs)<2){$secs=\"0\".$secs;}\n      $H{XMIT} = $hrs . \":\" . $mins . \":\" . $secs ;\n\n      # Calculate MSG based upon CCOD\n      if ($H{CCOD} eq '0'){$H{MSGI}=\"\";}\n\n      # Change record type (RECI) for readability (i.e. COPY, RUNJ, RUNT etc.)\n      if ($H{RECI} eq 'CTRC'){$H{RECT}=\"COPY\";}\n      if ($H{RECI} eq 'RJED'){$H{RECT}=\"RUNJ\";}\n      if ($H{RECI} eq 'RTED'){$H{RECT}=\"RUNT\";}\n\n      # Check for errors.\n\n      # SBID and first half of SUBM should match\n      ($sbid2, $trash) = split(/@/, $H{SUBM});\n      if ($sbid2 ne $H{SBID}){print STDERR \"Warning: SBID and first half of SUBM do not match.\\n\";}\n\n      # SCMP and ECMP should never both be 'Y'.\n      if (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'Y')){print STDERR \"Warning: SCMP and ECMP are both 'Y'.\\n\";}\n\n\n      # Now print individual record.\n      print \" \";                                       # Leading 4 spaces\n\n      $tmp=sprintf(\"%8s\",  $H{SBID}); print \"$tmp \";\n      $tmp=sprintf(\"%5s\",  $H{PNUM}); print \"$tmp \";\n      $tmp=sprintf(\"%10.8s\",  $H{PNAM}); print \"$tmp \";\n      $tmp=sprintf(\"%8s\",  $H{SNAM}); print \"$tmp \";\n      $tmp=sprintf(\"%4s\",  $H{RECT}); print \"$tmp \";   # Oddly there are two spaces after REC.\n      $tmp=sprintf(\"%8s\",  $H{STRT}); print \"$tmp \";   # Oddly there are two spaces after STRT.\n      $tmp=sprintf(\"%8s\",  $H{STPT}); print \"$tmp \";\n      $tmp=sprintf(\"%8s\",  $H{XMIT}); print \"$tmp \";   # need to calculate this\n\n      if ($H{LNOD} eq 'S'){$tmp=sprintf(\"%15s\", $H{PNOD}); print \"$tmp \";}\n      if ($H{LNOD} eq 'P'){$tmp=sprintf(\"%15s\", $H{SNOD}); print \"$tmp \";}\n\n      if ($H{ECMP} eq 'Y'){\n         if (length($H{ECPR})>5){\n            $temp1 = $H{SBYR}/$H{SBYX};\n            $temp2 = 1 - $temp1;\n            $temp3 = (100*$temp2);\n            $H{CMPP} = \"-\".$temp3;\n            $tmp=sprintf(\"%6.2f\",  $H{CMPP}); print \"$tmp \";\n         }\n         if (length($H{ECPR})<6){$tmp=sprintf(\"%6s\",  $H{ECPR}); print \"$tmp \";}\n      }\n      elsif (($H{ECMP} eq 'N') && ($H{SCMP} eq 'Y')){\n            if ($H{SBYR} eq '0'){$temp1 = 1;}\n            else {$temp1 = $H{SBYX}/$H{SBYR};}\n            $temp2 = 1 - $temp1;\n            $temp3 = (100*$temp2);\n            $H{CMPP} = $temp3;\n            $tmp=sprintf(\"%6.2f\",  $H{CMPP}); print \"$tmp \";\n      }\n      elsif ((($H{ECMP} eq 'N') && ($H{SCMP} eq 'N')) or ($H{RECI} ne 'CTRC')){\n            $H{CMPP} = \"   \";\n            $tmp=sprintf(\"%6s\",  $H{CMPP}); print \"$tmp \";\n      }\n\n      $tmp=sprintf(\"%3s\",  $H{CTYP}); print \"$tmp \";\n      $tmp=sprintf(\"%5s\",  $H{RUSZ}); print \"$tmp \";\n      $tmp=sprintf(\"%11s\", &commify($H{SBYX})); print \"$tmp \";\n      $tmp=sprintf(\"%4s\",  $H{CCOD}); print \"$tmp \";\n      $tmp=sprintf(\"%8s\",  $H{MSGI}); print \"$tmp \";\n      $tmp=sprintf(\"%8s\",  $H{STAR}); print \"$tmp \";\n      print \"\\n\";\n\n      foreach $field (keys(%H)){                         # Be sure to reinitialize all fields.\n         $H{$field}=\"\";\n      }\n   }\n}\nsub commify {\n    local($_) = shift;\n    1 while s/\u00ac(-?\\d+)(\\d{3})/$1,$2/;\n    return $_;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JNPDSCPY": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x13$\\x8f\\x01\\x14\\x02\\x0f\\x14\\x10\\x01\\x18\\x01\\x18\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-09-05T00:00:00", "modifydate": "2014-01-20T14:10:50", "lines": 280, "newlines": 280, "modlines": 0, "user": "SCNS03"}, "text": "#!/usr/bin/perl\n# ndmdaily.pl - filter to convert ConnectDirect Unix Statistics file into NDM report format\n\n# Here's an example of an input record broken up to make readable.\n# STAR=20040826 10:45:07|PNAM=MVS2AS02|PNUM=60102|SSTA=20040826 10:45:06|\n# STRT=20040826 10:45:06|STOP=20040826 10:45:07|STPT=20040826 10:45:07|SELA=00:00:01|SUBM=SCNSXMT@SWPNDM01|\n# SNOD=SWPGIPAS02|CCOD=0|RECI=CTRC|RECC=CAPR|MSGI=SCPA000I|MSST=Copy step successful.|STDL=Thu Aug 26 10:45:07 2004|\n# CSDS=Thu Aug 26 10:45:06 2004|LCCD=0|LMSG=SCPA000I|OCCD=0|OMSG=SCPA000I|PNAM=MVS2AS02|PNUM=60102|\n# SNAM=STEP01|SBND=SWPNDM01|SBID=SCNSXMT|PNOD=SWPNDM01|SNOD=SWPGIPAS02|LNOD=S|FROM=P|XLAT=Y|SCMP=N|ECMP=Y|ECPR=9.79|\n# ECTP=ECZ|ZLVL=1|ZWIN=13|ZMEM=4|OERR=N|CKPT=N|LKFL=N|RSTR=N|RUSZ=4096|PACC=|SACC=|PPMN=PRTINFO|SFIL=SYS2.DOCUMENT|\n# SDS1=S|SDS2= |SDS3= |SBYR=696960|SFSZ=0|SRCR=8712|SBYX=68262|SRUX=0|SVSQ=0|SVCN=0|SVOL=|DFIL=/home/tcieri/prts.dat|\n# PPMN=PRTINFO|DDS1=R|DDS2= |DDS3= |DBYW=400752|DRCW=8712|DBYX=68262|DRUX=17|DVSQ=0|DVCN=0|DVOL=|ICRC=N|PCRC=N\n\n# Here is the header and an example of an output record.\n#    USERID      PROC #   PROC NAME    STEP NAME    TRANSMISSION INFORMATION\n#    ******      ******   *********    *********    *****************************************************************\n#\n#    PRODJOB     81579    O0405P01     PRECHECK     11/01/2012 PNODE = SWPNDM01          SNODE = SWPEAET01\n#                                                   TRANSMISSION TIME = 0:00:00.25       COMPLETION CODE = 00000000\n#                                                   COPY STEP SUCCESSFUL.\n#                                                   ========================================================================\n#                                                   SRC DSNAME IS D0370.CUSTOM.JJ370FTR.G1118V00\n#                                                   DEST DSNAME IS /apps/swp/ndmlanding/etltlm/SrcFiles/Pos/FT/JJ370FTR.TXT\n#                                                        SENDING NODE ==> SWPNDM01         RECEIVING NODE ==> SWPEAET01\n#                                                        BYTES READ   ==> 168              BYTES WRITTEN  ==> 149\n#                                                        RUs   READ   ==> 1                RUs   WRITTEN  ==> 0\n#                                                        RECS READ    ==> 5                RECS WRITTEN   ==> 5\n#                                                        BYTES SENT   ==> 154              BYTES RECEIVED ==> 154\n#                                                        COMPRESSION% ==> 8.3              COMPRESSION%   ==> -3.2\n#                                                        VOLSER       ==> STGS42           VOLSER         ==>\n#    -----------------------------------------------------------------------------------------------------------------------\n\n# Change Log:\n#\n# 2009-012  Truncate the Procname at 8 characters (PNAM). Also, add a subroutine to format the byte count to include commas.\n# 2012-314  Changed upper case 'EQ' and 'NE' to lower case for z/OS.\n#\n\n##\n## Check syntax\n##\n## If the offset of the last argument is not 0, in other words if the number of arguments is not exactly 1,\n## then print the text that appears between << and ARGERR\nif ($#ARGV != 0){\n   print <<ARGERR;\n***\n$0:\nFatal Error: Wrong number of arguments.\n\nUsage:\n       $0 input_file\n\nParameters:\n   input_file is any file containing NDM logs in the following format\n      each line is a record with fields delimited by vertical bar\n      each field is a label=value pair\n      the following labels are processed:\n         SBID, PNUM, PNAM, SNAM, RECI, STRT, STPT, XMIT, PNOD, ECPR, CTYP,\n         RUSZ, SBYX, CCOD, MSGI, STAR, SCMP, ECMP\n\nARGERR\n   exit;\n}\n\n$ifilename = $ARGV\u00dd0\u00a8;                                  # First command line argument is input file\nif (! -e $ifilename){\n   print \"Fatal Error: Could not find input file $ifilename\\n\";\n   exit;\n}\nopen IFILE, \"<$ifilename\" || die \"Fatal Error opening input file: $ifilename.\\n\";\n\n# Determine the name of the server we are running on\n$cdnode = `uname -n | /bin/tr '\u00dd:lower:\u00a8' '\u00dd:upper:\u00a8'`;\n\n# Print the Header first\nprint \"                                                    Connect:Direct Non-PDS Copy Report  (ARS00005)       \\n\";\nprint \"                                                           Node = $cdnode                      \\n\";\nprint \"          \\n\";\nprint \"   USERID     PROC #   PROC NAME  STEP NAME   TRANSMISSION INFORMATION                                          \\n\";\nprint \"   ******     ******   *********  *********   ************************************************************************************** \\n\";\nprint \"\\n\";\n\n# Read each line in, process and output immediately.\nwhile (<IFILE>){\n   if  (m/RECI\\=CTRC/) {                                # Don't bother processing fields that do not contain RECI=CTRC\n      chomp;                                            # Remove the newline\n      @fields=split/\\|/;                                # Split record into fields on \"|\" save in the array named @fields\n      foreach $field (@fields){                         # For each | separated field\n         ($flabel, $fvalue) = split(/=/, $field);       # Split it into label=value pairs\n\n         # Do some field specific processing.\n         if ($flabel eq \"STRT\"){\n            ($vdate, $vtime) = split(/\\s+/, $fvalue);   # Split STRT into date and time components\n            $fvalue = $vtime;                           # and only keep the time.\n         }\n         if ($flabel eq \"STPT\"){\n            ($vdate, $vtime) = split(/\\s+/, $fvalue);   # Split STPT into date and time components\n            $fvalue = $vtime;                           # and only keep the time.\n         }\n         if ($flabel eq \"STAR\"){\n            ($vdate, $vtime) = split(/\\s+/, $fvalue);   # Split STRT into date and time components\n            $fvalue = $vdate;                           # and only keep the date.\n         }\n\n         $H{$flabel}=$fvalue;                           # And add an entry into hash indexed by label & containing value\n      }\n\n      # Now do the processing that requires data in multiple fields since you'll finally have it here.\n\n      # Calculate CTYP based upon SCMP and ECMP\n      if    (($H{SCMP} eq 'N') && ($H{ECMP} eq 'N')){$H{CTYP}=\" NO\";}\n      elsif (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'N')){$H{CTYP}=\"YES\";}\n      elsif (($H{SCMP} eq 'N') && ($H{ECMP} eq 'Y')){$H{CTYP}=\"EXT\";}\n      else                                          {$H{CTYP}=\"   \";} # (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'Y'))\n\n       # Format the date for printing\n       $styrs =  substr($H{STAR}, 0, 4);\n       $stmos =  substr($H{STAR}, 4, 2);\n       $stday =  substr($H{STAR}, 6, 2);\n       $H{DATE} = $stmos . \"/\" . $stday . \"/\" . $styrs ;\n\n      # Calculate XMIT based upon STRT and STPT\n      # Convert STRT and STPT from HH:MM:SS format into seconds.\n      ($strthrs, $strtmins, $strtsecs) = split(/:/, $H{STRT});   # Split STRT into hours, minutes and seconds on \":\".\n      ($stpthrs, $stptmins, $stptsecs) = split(/:/, $H{STPT});   # Split STPT into hours, minutes and seconds on \":\".\n\n      $xmithrs =  $stpthrs - $strthrs;\n      $xmitmins = $stptmins - $strtmins;\n      $xmitsecs = $stptsecs - $strtsecs;\n\n      if ($strtmins > $stptmins){\n         $xmitmins = $xmitmins + 60;\n         $xmithrs = $xmithrs - 1;\n      }\n\n      if ($strtsecs > $stptsecs){\n         $xmitsecs = $xmitsecs + 60;\n         $xmitmins = $xmitmins - 1;\n      }\n\n      $hrs = $xmithrs;                      # Zero $hrs, $mins, $secs so we can reuse.\n      $mins = $xmitmins;\n      $secs = $xmitsecs;\n\n      # and then format for printing.\n      $hrs=\"\" .$hrs ;\n      $mins=\"\".$mins; while (length($mins)<2){$mins=\"0\".$mins;}\n      $secs=\"\".$secs; while (length($secs)<2){$secs=\"0\".$secs;}\n      $H{XMIT} = $hrs . \":\" . $mins . \":\" . $secs ;\n\n      # Calculate MSG based upon CCOD\n#     if ($H{CCOD} eq '0'){$H{MSGI}=\"\";}\n\n      # Change record type (RECI) for readability (i.e. COPY, RUNJ, RUNT etc.)\n      if ($H{RECI} eq 'CTRC'){$H{RECT}=\"COPY\";}\n      if ($H{RECI} eq 'RJED'){$H{RECT}=\"RUNJ\";}\n      if ($H{RECI} eq 'RTED'){$H{RECT}=\"RUNT\";}\n\n      # Check for errors.\n\n      # SBID and first half of SUBM should match\n      ($sbid2, $trash) = split(/@/, $H{SUBM});\n      if ($sbid2 ne $H{SBID}){print STDERR \"Warning: SBID and first half of SUBM do not match.\\n\";}\n\n      # SCMP and ECMP should never both be 'Y'.\n      if (($H{SCMP} eq 'Y') && ($H{ECMP} eq 'Y')){print STDERR \"Warning: SCMP and ECMP are both 'Y'.\\n\";}\n\n\n      # Now print individual record.\n      print \"  \";                                      # Leading 4 spaces\n\n      $tmp=sprintf(\"%8s\",  $H{SBID}); print \"$tmp \";\n      $tmp=sprintf(\"%9s\", &commify($H{PNUM})); print \"$tmp \";\n      $tmp=sprintf(\"%10.8s\",  $H{PNAM}); print \"$tmp \";\n      $tmp=sprintf(\"%8s\",  $H{SNAM}); print \"$tmp \";\n\n      # Now determine Sending and Receiving Nodes\n\n      if ($H{FROM} eq 'P'){$H{XNOD} = $H{PNOD}; $H{RNOD} = $H{SNOD};}\n      if ($H{FROM} eq 'S'){$H{XNOD} = $H{SNOD}; $H{RNOD} = $H{PNOD};}\n\n      if ($H{SBYR} < $H{SBYX}){\n           if ($H{SBYX} eq '0'){$temp1 = 1;}\n           else {$temp1 = $H{SBYR}/$H{SBYX};}\n            $temp2 = 1 - $temp1;\n            $temp3 = (100*$temp2);\n            $H{CMPR} = \"-\".$temp3;\n      }\n      elsif ($H{SBYR} >= $H{SBYX}){\n           if ($H{SBYR} eq '0'){$temp1 = 1;}\n           else {$temp1 = $H{SBYX}/$H{SBYR};}\n            $temp2 = 1 - $temp1;\n            $temp3 = (100*$temp2);\n            $H{CMPR} = $temp3;\n      }\n      if ($H{DBYW} < $H{DBYX}){\n           if ($H{DBYX} eq '0'){$temp1 = 1;}\n           else {$temp1 = $H{DBYW}/$H{DBYX};}\n            $temp2 = 1 - $temp1;\n            $temp3 = (100*$temp2);\n            $H{CMPW} = \"-\".$temp3;\n      }\n      elsif ($H{DBYW} >= $H{DBYX}){\n           if ($H{DBYW} eq '0'){$temp1 = 1;}\n           else {$temp1 = $H{DBYX}/$H{DBYW};}\n            $temp2 = 1 - $temp1;\n            $temp3 = (100*$temp2);\n            $H{CMPW} = $temp3;\n      }\n\n      # Now print the transmission info.\n\n      print \"     $H{DATE}  PNODE = $H{PNOD}          SNODE = $H{SNOD} \\n\";\n      print \"                                              TRANSMISSION TIME = \";\n      $tmp=sprintf(\"%8s\",  $H{XMIT}); print \"$tmp \";\n      print \"       CONDITION CODE = \";\n      $tmp=sprintf(\"%08s\",  $H{CCOD}); print \"$tmp \";\n      print \"  MSG ID = \";\n      $tmp=sprintf(\"%8s\",  $H{MSGI}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              \";\n      $tmp=sprintf(\"%8s\",  $H{MSST}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              ====================================================================================== \\n\";\n      print \"                                              SRC DSNAME IS \";\n      $tmp=sprintf(\"%8s\",  $H{SFIL}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                              DEST DSNAME IS \";\n      $tmp=sprintf(\"%8s\",  $H{DFIL}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                                   SENDING NODE ==> \";\n      $tmp=sprintf(\"%-16s\",  $H{XNOD}); print \"$tmp \";\n      print \"   RECEIVING NODE ==> \";\n      $tmp=sprintf(\"%-16s\",  $H{RNOD}); print \"$tmp \";\n      print \"\\n\";\n      print \"                                                   Bytes READ   ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{SBYR})); print \"$tmp \";\n      print \"   Bytes WRITTEN  ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{DBYW})); print \"$tmp \";\n      print \"\\n\";\n      print \"                                                   RUs    READ  ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{SRUX})); print \"$tmp \";\n      print \"   RUs    WRITTEN ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{DRUX})); print \"$tmp \";\n      print \"\\n\";\n      print \"                                                   RECS READ    ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{SRCR})); print \"$tmp \";\n      print \"   RECS WRITTEN   ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{DRCW})); print \"$tmp \";\n      print \"\\n\";\n      print \"                                                   Bytes SENT   ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{SBYX})); print \"$tmp \";\n      print \"   Bytes RECEIVED ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{DBYX})); print \"$tmp \";\n      print \"\\n\";\n      print \"                                                   COMPRESSION% ==> \";\n      $tmp=sprintf(\"%-16.2f\",  $H{CMPR}); print \"$tmp \";\n      print \"   COMPRESSION%   ==> \";\n      $tmp=sprintf(\"%-16.2f\",  $H{CMPW}); print \"$tmp \";\n      print \"\\n\";\n\n      if (($H{SVOL} gt ' ') && ($H{DVOL} gt ' ')){\n      print \"                                                   VOLSER       ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{SVOL})); print \"$tmp \";\n      print \"   VOLSER         ==> \";\n      $tmp=sprintf(\"%-16s\", &commify($H{DVOL})); print \"$tmp \";\n      print \"\\n\";\n      }\n      print \"   --------------------------------------------------------------------------------------------------------------------------------- \\n\";\n\n      foreach $field (keys(%H)){                         # Be sure to reinitialize all fields.\n         $H{$field}=\"\";\n      }\n   }\n}\nsub commify {\n    local($_) = shift;\n    1 while s/\u00ac(-?\\d+)(\\d{3})/$1,$2/;\n    return $_;\n}\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT904/CBT.V500.FILE904.PDS/PERL.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT904/CBT.V500.FILE904.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}