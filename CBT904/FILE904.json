{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013357000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 881790, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "CBT.V500.FILE904.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 881790, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE904.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0f\\x0b'", "DS1TRBAL": "b'U\"'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\xdc\\x00\\x07\\x08\\xdd\\x00\\x07\\x00\\x10'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00%\\x01\\x14\\x02O\\x01\\x14\\x02O\\x120\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2014-01-24T00:00:00", "modifydate": "2014-01-24T12:30:25", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-488"}, "text": "REGULAR CBT TAPE - VERSION 488    FILE:  904\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT488.FILE904\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 47 MEMBERS COUNTED; CUMULATIVE SIZE IS 7,879 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/24/14    12:30:25    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DISCLM": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00!\\x01\\x133\\x9f\\x01\\x14\\x02?\\x12\\x18\\x00\\x18\\x00\\x17\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-12-05T00:00:00", "modifydate": "2014-01-23T12:18:21", "lines": 24, "newlines": 23, "modlines": 0, "user": "SCNS03T"}, "text": "\n     Anthony (Tony) Cieri neither expresses nor implies any warranty\n     as to the fitness of these computer programs for any function.\n     The use of these programs or the results therefrom is entirely\n     at the risk of the user.  Consequently, the user may modify\n     these programs in any way he/she thinks fit.\n\n             --------------------------------------------\n             |This software is provided on an asis basis|\n             |              and                         |\n             |       no warranty is provided            |\n             --------------------------------------------\n\n     These programs are Freeware and may be freely copied.  They\n     may be freely distributed to any other party on condition\n     that no inducement beyond reasonable handling costs is\n     offered or accepted by either side for such distribution.\n\n     I would be interested to hear of comments and/or proposed\n     enhancements, if so, please email me at:  Anthony.Cieri4@gmail.com\n\n     Thanks\n     Tony\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00#\\x01\\x13$\\x7f\\x01\\x14\\x02?\\x12\\x19\\x00A\\x00\\n\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2013-09-04T00:00:00", "modifydate": "2014-01-23T12:19:23", "lines": 65, "newlines": 10, "modlines": 0, "user": "SCNS03T"}, "text": "INDEX OF MEMBERS IN THIS DATASET\n================================\n\nMember     Description\n---------  --------------------------------------------------------\n$$DISCLM   The \"use at your own risk\" disclaimer!\n$$INDEX    This member\n$$README   Change history, general install information etc.\n$INSTALL   Installation instructions\n$NDMARS    Installation instructions for ARS (SAS) programs\n$NVAUTO    Installation instructions for Netview Automation examples\n$OPLIST    Installation instructions for OPLIST members\n$PERL      Installation instructions for Perl scripts\n$STATSW    Installation instructions for Stats Switch process\nCDJARS2$   Customized JCL to run modified SAS reports\nCDJEXTR$   Customized JCL to run SEL STATS command to a permanent\n           dataset to be used for future NDM reports.\nPerl       Collection of Perl scripts that process C:D UNIX stats\nTSTA339$   Sample assemble and link JCL for the TSTA339$ exit\nTSTA3390   Assembler source code for the TSTA3390 exit\nTSTSMF2    Assembler source code for the TSTSMF2 exit\nTSTSMF2$   Sample assemble and link JCL for the TSTSMF2 exit\nTSTSMF2    Assembler source code for the TSTSUBMY exit\nTSTSUBM$   Sample assemble and link JCL for the TSTSUBMY exit\nTSTXSIZP   Assembler source code for the TSTZSIZP exit\nTSTZSIZ$   Sample assemble and link JCL for the TSTZSIZP exit\n\n           SAS programs\n\nACTIVTY1   Custom version of SAS ACTIVITY program for a single node.\nACTIVTY2   Custom version of SAS ACTIVITY program providing more info.\nACTVSECP   Custom version of SAS ACTIVITY program for Secure+ copies.\nEXCEPT1    Custom version of SAS EXCEPT program for a single node.\nNPDSCPY1   Custom version of SAS NPDSCOPY program for a single node.\nPDSCOPY1   Custom version of SAS PDSCOPY program for a single node.\nRUNJOB1    Custom version of SAS RUNJOB program for a single node.\nRUNTASK1   Custom version of SAS RUNTASK program for a single node.\nSUBMIT1    Custom version of SAS SUBMIT program for a single node.\nSUMMACTC   Custom SAS program providing a compression summary by node.\nSUMMARY1   Custom version of SAS SUMMARY program for a single node.\n\n           Netview Automation members\n\nCDXOR01X   Sample Automation table fragment for NDM Exit messages.\nMPFLSTxx   Sample MPFLST statement for automated NDM messages.\nSNDMAIL6   Sample Rexx exec to send message via SMTP to EmailID.\nSVTMxxx    Sample Automation table fragment for NDM messages.\nSVTM083I   Sample Netview Clist to issue a RLSE command on SVTM083I msg\nSVTM105I   Sample Netview Clist to issue a RLSE command on SVTM105I msg\n\n           OPLIST members\n\nIDBG       OPLIST to issue INQUIRE DEBUG command from the console\nQUI        OPLIST to issue MODIFY SESSION QUIESCE from the console\nQUIESCE    OPLIST to issue MODIFY SESSION QUIESCE from the console\n           (Defaults to LOCAL node if no is node specified!!!)\nRES        OPLIST to issue MODIFY SESSION RESUME from the console\nRESUME     OPLIST to issue MODIFY SESSION RESUME from the console\n           (Defaults to LOCAL node if no is node specified!!!)\nXO         OPLIST to issue SEL STATS TYPE=XO command from the console\n\n           Stats Switch members\n\nSTATJOB4   OPLIST to issue MODIFY SESSION QUIESCE from the console\nSTATPRC4   OPLIST to issue INQUIRE DEBUG command from the console\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x01\\x01\\x131/\\x01\\x14\\x02?\\x12(\\x00\\xe9\\x003\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2013-11-08T00:00:00", "modifydate": "2014-01-23T12:28:01", "lines": 233, "newlines": 51, "modlines": 0, "user": "SCNS03T"}, "text": "\n                          CBT Tape File xxx\n\n                 (userid).CBTnnn.FILExxx.PDS($$README)\n\n------------------------------------------------------------------------\n\nThe contents of this CBT tape submission are various Connect:Direct mods\nthat I have written and used over many years. Some of these go back to\nthe 'System Center\" days. I have \"refreshed\" these for our recent\nupgrade to IBM Connect:Direct Version 5.1 (HDGA510). The collection is\ncategorized as follows:\n\n 1) Assembler Exits\n 2) ARS members\n 3) Automation stuff\n 4) OPLIST members\n 5) Perl members\n 6) Stats members\n\n------------------------------------------------------------------------\n\nAssembler Exits\n---------------\nAll four of the exits are written in assembler. There are eight members\nthat are prefixed with \"TST\". They are the four source code members and\nfour corresponding JCL members to assemble and link the load modules.\n\n\n       Exits\n       -----\n\n       TSTA3390 - A sample Allocation exit that is designed to check\n                  processes for destination datasets with 1) DISP=NEW\n                  or DISP= not specpfied, 2) UNIT=3390 or UNIT=SYSALLDA\n                  and 3) NO VOL=SER specified. If all (3) checks are\n                  met, then change the destination D/S unit to be\n                  UNIT=DISK80. If we change a process, then we\n                  issue a WTO message to the NDM log. The message is:\n\n               CDPAL01X UNIT= changed for PROCESS procname( nn,nnn) SUB\n               MITTED BY Snode=NNNNNNNNNNNNNNNN\n\n\n       TSTSMF2  - A modified version of the IBM provided exit, DGAXSMF\n                  (DMGSMF). This sample statistics exit 1) customizes\n                  the SMF record number, 2) enables the CPUTIME\n                  processing and 3) issues a WTO message to the NDM log\n                  for XO statistics records that represent any MODIFY\n                  SESSIONS commands (QUIesce or RESume). The format of\n                  the WTO messages is:\n\n               CDXOR01X Modify Session = XXX issued by CCCCCCCC MSG=xxx\n               xxxxx Node=NNNNNNNNNNNNNNNN\n\n                  Where 'XXX' is either QUI or RES, 'CCCCCCCC' is the user\n                  that initiated the command, 'NNNNNNNNNNNNNNNN' is the node\n                  name that was either quiesced or resumred and 'xxxxxxxx'\n                  is the MSGID of the response to the command. It can be one\n                  of the following:\n\n                       STRA009I  -  RESume for the LOCAL nodes\n                       STRA010I  -  QUIesce for the LOCAL nodes\n                       STRA035I  -  RESume for a remote node\n                       STRA036I  -  QUIesce for a remote node\n\n\n       TSTSUBMY - A sample SUBMIT exit that is designed to DISABLE\n                  compression if the remote node name matches one of\n                  several prefixes or if the explicit node name is in\n                  the internal table. If the node name is found in the\n                  table or there is a match on one of the prefixes, then\n                  the exit loops through the process, locates any COPY\n                  steps and disables ALL compression (Ext or Standard).\n                  The exit has one additional caveat. If the submitted\n                  process is coded with CLASS=1, then the requested\n                  compression value will be honored!!\n\n\n       TSTZSIZP - Another sample SUBMIT, that is designed to DISPLAY\n                  process step information, including the process\n                  control block sizes. This exit was intended as a tool\n                  to aid in the tuning of the TCQ file CISIZE value.\n                  The goal, if possible, is to try to \"fit\" the average\n                  process into a single VSAM CI.\n                  The first step is to determine the average process\n                  size. This sample exit will DISPLAY size information\n                  for each process step to the USRINFO DDNAME. It will\n                  keep a running total and DISPLAY the Total size at the\n                  process end. Step size values are derived from the\n                  Connect:Direct Configuration Guide (Chapter 1) except\n                  for SUBMIT steps. The base control block size for the\n                  SUBMIT step is 176 bytes.(i.e. SUBMIT PROC=xxxxxxxx).\n                  Any other parameters must be added to this initial\n                  value. In my testing all of the SUBMITs were from PDS\n                  members, so the dataset and member name lengths are\n                  added. This length is found in the TQSUBLNG field!\n\nAdditional information on installing these exits can be found in member\n$INSTALL in this PDS.\n\n------------------------------------------------------------------------\n\nARS (SAS) members\n-----------------\n\nThe ARS members in this PDS are:\n\n o) ACTIVTY1\n o) ACTIVTY2\n o) ACTVSECP\n o) CDJARS2$\n o) CDJEXTR$\n o) EXCEPT1\n o) NPDSCPY1\n o) PDSCOPY1\n o) RUNJOB1\n o) RUNTASK1\n o) SUBMIT1\n o) SUMMACTC\n o) SUMMARY1\n\nAdditional information on installing the ARS (SAS) samples can be found\nin member $NDMARS in this PDS.\n\n------------------------------------------------------------------------\n\nAutomation Stuff\n----------------\n\nThe Automation sample members in this PDS are:\n\n o) CDXOR01X\n o) MPFLSTXX\n o) SNDMAIL6\n o) SVTMXXX\n o) SVTM083I\n o) SVTM105I\n\nAdditional information on installing the automation samples can be found\nin member $NVAUTO in this PDS.\n\n------------------------------------------------------------------------\n\nOplist members\n--------------\n\nThe Connect:Direct Oplist members in this PDS are:\n\n o) IDBG\n o) QUI\n o) QUIESCE\n o) RES\n o) RESUME\n o) XO\n\nAdditional information on installing the Oplist samples can be found\nin member $OPLIST in this PDS.\n\n------------------------------------------------------------------------\n\nPerl stuff\n----------\n\nThe Connect:Direct Perl members in this PDS are all contained in member\nPERL and are in TSO transmit format. To unload these members, you must\n\"receive\" member PERL in this PDS with the TSO RECEIVE command. The\ndataset produced by the RECEIVE command should contain the following\nmembers:\n\n o) JNDMEXPT\n o) JNDMSECT\n o) JNDMTIME\n o) JNPDSCPY\n\nEach of these scripts was designed to produce a report similar to\nthe SAS reports produced by the ARS members. The Perl scripts expect\na Connect:Direct UNIX statistics file as input. We conCATenated the\nstats files on either a weekly or daily basis depending upon the\nvolume on the particular server. A sample CAT command might look like:\n\ncat /../cdstats/S20*.00* > /../cdstats/S`date +%Y%m%d`.weekly\n\nA sample invocation of the Perl script might look like:\n\n/../jndmtime.pl /../S`date +%Y%m%d`.weekly > /../jndmtime.`date +%Y%m%d`\n\nWe used cron jobs to CAT the stats files and run the Perl scripts. The\nresulting reports were archived in a variety of methods!\n\nAdditional information on installing the Perl samples can be found\nin member $PERL in this PDS.\n\n------------------------------------------------------------------------\n\nStats stuff\n-----------\n\nThe Connect:Direct stat switch member in this PDS are:\n\n o) STATJOB4\n o) STATPRC4\n\nAdditional information on installing the stats switch samples can be\nfound in member $STATSW in this PDS.\n\n------------------------------------------------------------------------\n\nBoring Stuff\n------------\nUse of this material is subject to the standard CBT Tape\ndisclaimer viewable at http://www.cbttape.org/disclaimer.htm\n\nThis material may be copied, distributed, modified and executed freely.\nHowever in doing so, headers and comments indicating the source\nof the material should not be removed. In addition, this material\nmust not be sold on for profit, either in part or as a whole, without\nthe consent of the author.\n\nThe author appreciates feedback as to good uses to which this material\nis serving, and would give due consideration to any suggestions for\ncorrections, clarifications or enhancements. The author can be contacted\nas follows. (Email is my preferred means of communication!!!)\n\nName:         Anthony J. Cieri\nAddress:\n              1 Freedom Valley Drive\n              Oaks,PA 19456\n              U.S.A.\nTelephone:    610  676  4088  (Work - direct line)\nFax:          484  676  4088  (Work)\n\nEmail:        Anthony.Cieri4@gmail.com\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INSTALL": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00W\\x01\\x13$\\x7f\\x01\\x133\\x9f\\x142\\x00h\\x00\\x11\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2013-09-04T00:00:00", "modifydate": "2013-12-05T14:32:57", "lines": 104, "newlines": 17, "modlines": 0, "user": "SCNS03T"}, "text": "Instructions on how to install the TSTA3390 C:D Allocation exit\n---------------------------------------------------------------\n\nStep 1.  Modify and Run the TSTA339$ JCL from this dataset to assemble\n         and link the TSTA3390 source code. Any \"lower case\" characters\n         must be changed to suit your environment. This JCL member was\n         coded with the assumption that Connect:direct was installed\n         into libraries with a high level qualifier of IBM.HDGA510. You\n         must change these entries to match your install dataset names!\n\n\nStep 2.  Change the Connect:Direct initialization member to include\n         a statement to load the exit:\n\n         (o) ALLOCATION.EXIT = TSTA3390\n\n\nStep 3.  Place a DD Card in the DTF JCL for DISPLAY output. (optional)\n\n         (o) //USRINFO  DD SYSOUT=A\n\n\nStep 4.  Restart the Connect:Direct task - installation is complete!\n\n\n\n\nInstructions on how to install the TSTSMF2 C:D statistics exit\n--------------------------------------------------------------\n\nStep 1.  Modify and Run the TSTSMF2$ JCL from this dataset to assemble\n         and link the TSTSMF2 source code. Any \"lower case\" characters\n         must be changed to suit your environment. This JCL member was\n         coded with the assumption that Connect:direct was installed\n         into libraries with a high level qualifier of IBM.HDGA510. You\n         must change these entries to match your install dataset names!\n\n\nStep 2.  Change the Connect:Direct initialization member to include\n         a statement to load the exit:\n\n         (o) STATISTICS.EXIT = TSTSMF2     /* test exit for XO records*/\n\n\nStep 3.  Place a DD Card in the DTF JCL for DISPLAY output. (optional)\n\n         (o) //USRINFO  DD SYSOUT=A\n\n\nStep 4.  Restart the Connect:Direct task - installation is complete!\n\n\n\n\nInstructions on how to install the TSTSUBMY C:D submit exit\n-----------------------------------------------------------\n\nStep 1.  Modify and Run the TSTSUBM$ JCL from this dataset to assemble\n         and link the TSTSUBMY source code. Any \"lower case\" characters\n         must be changed to suit your environment. This JCL member was\n         coded with the assumption that Connect:direct was installed\n         into libraries with a high level qualifier of IBM.HDGA510. You\n         must change these entries to match your install dataset names!\n\n\nStep 2.  Change the Connect:Direct initialization member to include\n         a statement to load the exit:\n\n         (o) SUBMIT.EXIT = TSTSUBMY      /* test exit to disable COMP*/\n\n\nStep 3.  Place a DD Card in the DTF JCL for DISPLAY output. (optional)\n\n         (o) //USRINFO  DD SYSOUT=A\n\n\nStep 4.  Restart the Connect:Direct task - installation is complete!\n\n\n\nInstructions on how to install the TSTXSIZP C:D submit exit\n-----------------------------------------------------------\n\nStep 1.  Modify and Run the TSTXSIZ$ JCL from this dataset to assemble\n         and link the TSTZSIZP source code. Any \"lower case\" characters\n         must be changed to suit your environment. This JCL member was\n         coded with the assumption that Connect:direct was installed\n         into libraries with a high level qualifier of IBM.HDGA510. You\n         must change these entries to match your install dataset names!\n\n\nStep 2.  Change the Connect:Direct initialization member to include\n         a statement to load the exit:\n\n         (o) SUBMIT.EXIT = TSTXSIZP      /* test exit to display size*/\n\n\nStep 3.  Place a DD Card in the DTF JCL for DISPLAY output. (optional)\n\n         (o) //USRINFO  DD SYSOUT=A\n\n\nStep 4.  Restart the Connect:Direct task - installation is complete!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$NDMARS": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x11\\x01\\x13&\\x7f\\x01\\x133\\x9f\\x14V\\x00&\\x00 \\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2013-09-24T00:00:00", "modifydate": "2013-12-05T14:56:11", "lines": 38, "newlines": 32, "modlines": 0, "user": "SCNS03T"}, "text": "Instructions on how to install the C:D ARS SAS members.\n-------------------------------------------------------\n\nStep 1.  Copy some or all of the following members into the dataset\n         referenced by the DD name SDGAMAP (or your equivalent)\n\n         (o) ACTIVTY1\n         (o) ACTIVTY2\n         (o) ACTVSECP\n         (o) EXCEPT1\n         (o) NPDSCPY1\n         (o) PDSCOPY1\n         (o) RUNJOB1\n         (o) RUNTASK1\n         (o) SUBMIT1\n         (o) SUMMACTC\n         (o) SUMMARY1\n\nSuggestions on execution of the C:D ARS SAS programs.\n-----------------------------------------------------\n\n1).      You can reference and modify the sample JCL provided in member\n         DGAJARS2 of the SDGAJCL library. This sample job executes two\n         job steps. The first, DGADBATC, performs a SELect STATistics\n         command and stores the statistics records in a temporary\n         dataset. The second job step executes the ARS SAS program(s)\n         using the temporary dataset created in the previous step as\n         input.\n\n2).      See the sample JCL members; CDJARS2$ and CDJEXTR$ provided in\n         this library. These samples illustrate a method of extracting\n         STATistics records to a \"Catalogued\" dataset and executing the\n         ARS (SAS) reports against that dataset. As a Service Bureau, we\n         execute many ARS reports for various clients. We have found\n         that repeated \"SEL STATs\" commands can adversely effect the\n         performance of the Connect:Direct task. To remediate this\n         situation, we perform one extract per day and then execute ALL\n         subsequent reports against this \"extracted\" dataset.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$NVAUTO": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x07\\x01\\x131/\\x01\\x14\\x02/\\x16R\\x00(\\x00 \\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-11-08T00:00:00", "modifydate": "2014-01-22T16:52:07", "lines": 40, "newlines": 32, "modlines": 0, "user": "SCNS03T"}, "text": "Instructions on how to install the C:D Netview Automation members.\n------------------------------------------------------------------\n\nStep 1.  Copy some or all of the following members into a dataset\n         referenced by the DD name DSICLD in your Netview PROCedure.\n\n         (o) SNDMAIL6              (written in Rexx)\n         (o) SVTM083I              (written Netview Clist language)\n         (o) SVTM105I              (written Netview Clist language)\n\n         If you seperate your Rexx code from the Netview Clist code\n         then segregate as appropriate!\n\n\nStep 2.  Copy some or all of the MPFLST statements provided in member\n         MPFLSTXX into your production MPFLSTxx member. You only need\n         to copy statements for those messages that you wish to suppress\n         or automate.\n\n         Refresh your MPF list after making any changes:\n\n                - SET MPF=xx\n\n\nStep 3.  Copy some or all of the Netview MAT statements provided in\n         members CDXOR01X and SVTMxxx to your production Netview\n         Message Automation Table. You could usea %INCLUDE statement\n         include the entire tables fragments in your production tables.\n         You only need to copy or include those statements for messages\n         that you wish to automate.\n\n         Refresh your Netview Message Automation Table after making any\n         changes:\n\n                - AUTOTBL MEMBER=xxxxxxxx,TEST\n\n         It is always a good idea to TEST the Message Automation Table\n         first, to esure there are NO errors.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$OPLIST": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x01\\x13&\\x0f\\x01\\x14\\x02\\x0f\\x16 \\x001\\x00$\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2014-01-20T16:20:35", "lines": 49, "newlines": 36, "modlines": 0, "user": "SCNS03"}, "text": "Instructions on how to install the C:D OPLIST members.\n------------------------------------------------------\n\nStep 1.  Reference the Connect:Direct initialization member and locate\n         the MCS.CLIST statement.\n\n         (o) MCS.CLIST = SYS2.NDM.OPLIST\n\nStep 2.  Copy some or all of the following members into the dataset\n         referenced in (1):\n\n         (o) IDBG\n         (o) QUI\n         (o) QUIESCE\n         (o) RES\n         (o) RESUME\n         (o) XO\n\nStep 3.  Ensure that you have a valid MCS.SIGNON statement specified in\n         the Connect:Direct initialization dataset/member:\n\n         (o)  MCS.SIGNON = (SIGNON USERID=(SUPERUSR,SUPPASS1) -\n                            CASE=NO                           -\n                            NETMAP=$CD.NETMAP)\n\nStep 4.  Ensure that the USERID specified in the MCS.SIGNON statement\n         (SUPERUSR in this example) is defined in the Connect:Direct\n         AUTH VSAM file with the correct password (SUPPASS1) and the\n         appropriate functional authority.\n\n\n    NOTE ** Depending upon the security software that you have **\n         ** installed, you may have other options or different **\n         ** standards for defining and authorizing the CONSOLE **\n         ** USERID!!!                                          **\n\n\nStep 5.  You can choose between the pair of Resume and Quiesce Oplists.\n         The QUIESCE and RESUME Oplist will quiesce and resume the LOCAL\n         node if a node name is not provided in the commands.\n\n         ** Quiescing the LOCAL node will SOP ALL processes.   **\n\n         Using the QUI or RES Oplists will result in an SRTA032I or\n         SRTA031I error message respectively, if a node name is NOT\n         provided on the command invocation. Use the latter two Oplists\n         if you do NOT want the ability to Quiesce or resume the LOCAL\n         node !!!\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PERL": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x16\\x01\\x13&\\x0f\\x01\\x130?\\x19'\\x00+\\x00\\x17\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-10-30T19:27:16", "lines": 43, "newlines": 23, "modlines": 0, "user": "SCNS03T"}, "text": "Instructions on how to install the Perl script members.\n-------------------------------------------------------\n\nStep 1.  Unload the PERL member of this PDS using the TSO RECEIVE\n         command:\n\n         (o) RECEIVE INDA('this.pds.name(PERL)')\n\nStep 2.  When you get the following prompt:\n\n         INMR901I Dataset SCNS.HDGA510.PERL.PDS from SCNS03T on MVSJEST\n         INMR906A Enter restore parameters or 'DELETE' or 'END' +\n\n         Provide your desired restore parameters. If you simply press\n         ENTER, you should load a dataset named 'hlq.HDGA510.PERL.PDS'\n         Where 'hlq' is your TSO high level qualifier!\n\n\n    NOTE ** The Perl scripts in this PDS all have an LRECL > 80**\n         ** Consequently the restored PDS will have a LRECL=255**\n         ** Once it is restore you can copy the members into   **\n         ** a HFS of your choice!!                             **\n\n    NOTE ** These Perl scripts were originally developed for   **\n         ** Connect:Direct Unix (V3.5) running on Solaris 9 in **\n         ** the 2004 time frame. They ran in this environment  **\n         ** up to and including C:D Unix V3.8.                 **\n         ** After the upgrade to V3.8 our Production Groups    **\n         ** were reorganized and there was a desire to produce **\n         ** these reports and archive them on the mainframe.   **\n         ** At that time, we installed Perl on z/OS (the FMID  **\n         ** is HPRL110) and the perl version was:              **\n         **                                                    **\n            This is perl, v5.8.7 built for os390-thread-multi\n\n            Copyright 1987-2005, Larry Wall\n            MVS (OS390) port by Mortice Kern Systems, 1997-1999\n\n         ** These scripts were easily moved to z/OS with very  **\n         ** little modification.                               **\n         ** From 2012 on, these scripts were executed on z/OS  **\n         ** USS and the resulting reports were archived on SAR **\n         ** (CA-View) for historical reference.                **\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$STATSW": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00#\\x01\\x133\\x9f\\x01\\x133\\x9f\\x16B\\x009\\x00$\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2013-12-05T00:00:00", "modifydate": "2013-12-05T16:42:23", "lines": 57, "newlines": 36, "modlines": 0, "user": "SCNS03T"}, "text": "Instructions on how to install the C:D STATs SWITCH process.\n------------------------------------------------------------\n\nStep 1.  Reference the Connect:Direct initialization member and locate\n         the STAT.SWITCH.SUBMIT statement.\n\n         (o) STAT.SWITCH.SUBMIT = your.ndm.process.lib(member)\n\nStep 2.  Code the STAT.SWITCH.SUBMIT parameter to reference the PDS\n         and the member that contains the statistics switch process.\n         If your process library is named SYS2.NDM.PROCESS and you use\n         the process member name provide in this example, then code:\n\n         (o) STAT.SWITCH.SUBMIT = SYS2.NDM.PROCESS(STATPRC4)\n\nStep 3.  Copy the statistics switch job (STATJOB4) into the JCL library\n         referenced in the RUNTASK statement in the STATPRC4 process.\n         If your JCL library is named SYS2.NDM.CNTL and you use the\n         the jobname member provided in this example, then code:\n\n         (o)      RUN TASK (PGM=DGADTSUB,\n                  PARM=(\"DISP=SHR,DSN=SYS2.NDM.CNTL(STATJOB4)\",\n                               \"DSNAME &EDSN\"))\n\n\n    NOTE ** The statistics switch process runs as a PNODE=SNODE**\n         ** process. You must have an adjacent node coded in   **\n         ** your NETMAP to support Pnode=Snode processing. In  **\n         ** the process you must code both the PNODE and SNODE **\n         ** parameters to be your node name. You could also    **\n         ** PNODE=%PNODE, but my experience has been that the  **\n         ** intrinsic variable, %PNODE does NOT work for the   **\n         ** SNODE parameter. Consult the Connect:Direct Admin  **\n         ** Guide for more details!!!                          **\n\n\nStep 4.  Depending upon your security requirements, you may also need\n         to code a userid in the STAT.USER parameter. This userid will\n         need sufficient access to submit the process and JCL provided\n         in the previous steps.\n\n    NOTE ** Depending upon the security software that you have **\n         ** installed, you may have other options or different **\n         ** standards for authorizing the STAT.USER userid.    **\n\n\n    NOTE ** In this example, the JOB submitted when the Stats  **\n         ** file switches contains two steps. The first step   **\n         ** executes ListCat Plus (PGM=LSTCAT) to produce the  **\n         ** VSAM statistics report. If you do NOT have ListCat **\n         ** Plus, you can change the first job step to use the **\n         ** IDCAMS utility instead. The second job step runs   **\n         ** the Connect:Direct utility named DGASSTAT. This    **\n         ** program provide additional statistics on the VSAM  **\n         ** file including a report of All of the record types **\n         ** in the statistics file and the space they consume. **\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE904": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04X\\x00\\x15\\x01\\x14\\x02O\\x01\\x14\\x02O\\x120\\x00\\x18\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf8@@@'", "ispf": {"version": "04.88", "flags": 0, "createdate": "2014-01-24T00:00:00", "modifydate": "2014-01-24T12:30:15", "lines": 24, "newlines": 24, "modlines": 0, "user": "CBT-488"}, "text": "//***FILE 904 is from Anthony Cieri and contains a collection of    *   FILE 904\n//*           exits and programs designed to work with IBM's        *   FILE 904\n//*           connect:direct product FMID HDGA510.  These exits     *   FILE 904\n//*           go back a long way, but they have been refreshed      *   FILE 904\n//*           to work with IBM Connect:Direct Version 5.1.          *   FILE 904\n//*                                                                 *   FILE 904\n//*           email:  ACieri@seic.com                               *   FILE 904\n//*                                                                 *   FILE 904\n//*       The contents of this CBT tape submission are various      *   FILE 904\n//*       Connect:Direct mods that I have written and used over     *   FILE 904\n//*       many years. Some of these go back to the 'System          *   FILE 904\n//*       Center\" days. I have \"refreshed\" these for our recent     *   FILE 904\n//*       upgrade to IBM Connect:Direct Version 5.1 (HDGA510).      *   FILE 904\n//*       The collection is categorized as follows:                 *   FILE 904\n//*                                                                 *   FILE 904\n//*            1) Assembler Exits                                   *   FILE 904\n//*            2) ARS members                                       *   FILE 904\n//*            3) Automation stuff                                  *   FILE 904\n//*            4) OPLIST members                                    *   FILE 904\n//*            5) Perl members                                      *   FILE 904\n//*            6) Stats members                                     *   FILE 904\n//*                                                                 *   FILE 904\n//*       See member $$README in this pds for more details.         *   FILE 904\n//*                                                                 *   FILE 904\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ACTIVTY1": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00A\\x01\\x13%\\x9f\\x01\\x135?\\x113\\x00\\xdd\\x00\\xda\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-09-16T00:00:00", "modifydate": "2013-12-19T11:33:41", "lines": 221, "newlines": 218, "modlines": 0, "user": "SCNS03"}, "text": "  DATA ACTIVITY;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*   ONLY WANT 'FUNCTION TERMINATION' STATISTICS RECORDS;\n      IF RECTYPE = 'CT' OR RECTYPE = 'RT' OR\n         RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN DO;\n      IF RECTYPE = 'CT' THEN\n         INPUT  @5 ENDHH PK1.        /* XXTIME BROKEN TO 4 PKDLEN 1*/\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.            /* XXDATE    */\n                @13 STRTHH PK1.      /* XXSTIME BROKEN TO 4 PKDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.\n                @21 CC $4.                /* XXSCC     */\n                @25 MSGID $8.             /* XXMSGID   */\n                @33 PROCNAME $8.          /* XXPROCNM    1363862*/\n                @41 PROCNUM IB4.          /* XXPROCNO  */\n                @45 STEPNAME $8.          /* XXSTEP    */\n                @69 UID $8.               /* XXUID       1363862 */\n                @77 MYNODE $16.           /* XXPNODE   */\n                @93 OTHRNODE $16.         /* XXSNODE   */\n                @109 THISNODE $1.         /* XXNODE    */\n                @110 SENDIND $1.\n                @111 CTRANS IB1.\n                @112 COPYTYPE $CHAR1.\n                @113 RUSZ   IB4.\n                @129 INBYTES IB8.\n                @137 INRECS IB4.\n                @141 INBLKS IB4.\n                @145 SNDBYTS IB8.\n                @153 OUTBYTES IB8.\n                @161 OUTRECS IB4.\n                @165 OUTBLKS IB4.\n                @169 RCVBYTS IB8. @;\n      IF RECTYPE = 'RT' OR RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN\n         INPUT  @5 ENDHH PK1.        /* XXTIME BROKEN TO 4 PKDLEN 1*/\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.            /* XXDATE    */\n                @13 STRTHH PK1.      /* XXSTIME BROKEN TO 4 PKDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.\n                @21 CC $4.                /* XXSCC     */\n                @25 MSGID $8.             /* XXMSGID   */\n                @33 PROCNAME $8.          /* XXPROCNM    1363862*/\n                @41 PROCNUM IB4.          /* XXPROCNO  */\n                @45 STEPNAME $8.          /* XXSTEP    */\n                @69 UID $8.               /* XXUID     */\n                @77 UID56 $56             /* XXUID     */\n                @133 MYNODE $16.          /* XXPNODE   */\n                @149 OTHRNODE $16.        /* XXSNODE   */\n                @165 THISNODE $1. @;      /* XXNODE    */\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n*        ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n*          ASSIGN SENDING AND RECEIVING NODES;\n**         IF SENDIND = 'P' THEN DO;\n**            SENDNODE = PNODE;\n**            RCVNODE = SNODE;\n**            END;\n**         ELSE DO;\n**            SENDNODE = SNODE;\n**            RCVNODE = PNODE;\n**            END;\n*        ASSIGN FUNCTION TYPE FOR OUTPUT;\n         IF RECTYPE = 'RT' THEN\n            FUNC = 'RUNT';\n         IF RECTYPE = 'CT' THEN\n            FUNC = 'COPY';\n         IF RECTYPE = 'RJ' THEN\n            FUNC = 'RUNJ';\n         IF RECTYPE = 'SW' THEN\n            FUNC = 'SUBM';\n         IF CC = '00000000'X THEN\n            FLAG = '        ';\n         ELSE\n            FLAG = MSGID;\n*           FLAG = '***';\n         CD = SUBSTR(CC,2,3);\n         IF FUNC = 'COPY' THEN CP = 'NO ';\n         IF CTRANS = '20' THEN CP = 'EXT';\n         IF CTRANS = '16' THEN CP = 'CMP';\n         IF CTRANS = '4' THEN CP = 'EXT';\n         IF CTRANS = '0' THEN CP = 'NO ';\n         DATE = DATEJUL(STRDTE);   /* CONVERT JULDTES->SAS FOR MATH*/\n         ENDDTE = DATEJUL(ENDDTE);\n      IF RECTYPE = 'CT' THEN DO;\n           IF INBYTES >= SNDBYTS THEN DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = SNDBYTS/INBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = INBYTES/SNDBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = -100 * TEMP2;\n              END;\n           END;\n           IF OUTBYTES >= RCVBYTS THEN DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = RCVBYTS/OUTBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = OUTBYTES/RCVBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = -100 * TEMP2;\n              END;\n           END;\n      END;\n*        'HMS' RETURNS SAS TIME VALUE FOR MATH;\n         STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n         ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n         TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n*                  {TRANS DAYS IN SECONDS  + TIME ENDED} - TIME STARTED;\n*        GET RID OF UNNECESSERY VARIABLES;\n         DROP ENDHH ENDMM ENDSS ENDTT ENDDTE STRTHH STRTMM STRTSS STRTTT\n              STRDTE OTHRNODE THISNODE RECTYPE;\n*             STARTIME ENDTIME\n*        ADD OBSERVATION TO SAS DATA SET BEING CREATED;\n         OUTPUT;\n      END;\n*     FORMAT DATE AND TIME FOR OUTPUT;\n      FORMAT UID $CHAR8.;                    /* 1371027 */\n      FORMAT PROCNUM BEST5.;                 /* 1371027 */\n      FORMAT PROCNAME $CHAR8.;               /* 1371027 */\n      FORMAT STEPNAME $CHAR8.;               /* 1371027 */\n      FORMAT FUNCTION $CHAR8.;               /* 1371027 */\n      FORMAT PNODE $CHAR16.;                 /* 1371027 */\n      FORMAT MSGID $CHAR8.;                  /* 1371027 */\n      FORMAT DATE MMDDYY8.;\n      FORMAT STARTIME TIME9.0;\n      FORMAT ENDTIME TIME9.0;\n      FORMAT TRANTIME TIME11.2;\n*     FORMAT CC $HEX8.;\n      FORMAT CD $HEX6.;\n      FORMAT SNDBYTS COMMA11.;\n* THIS DATA STEP SETS UP TO PUT NODENAME IN TITLE;\n  DATA _NULL_;\n    SET ACTIVITY;\n    CALL SYMPUT('NODE',MYNODE);\n    RUN;\n* PRINTS TITLES;\n  DATA _NULL_;\n    TITLE 'IBM Sterling Connect:Direct for z/OS Activity Report';\n    TITLE2 \"NODE = &NODE\";\n* SORT DATASET FOR PRINT;\n  PROC SORT;\n    BY SNODE PROCNUM;\n* ROUTE OUTPUT TO FT20F001 DD;\n  PROC PRINTTO NEW UNIT=20;\n* PRINT DATASET BY SNODE AND FOLLOWING ORDER ACROSS PAGE;\n  PROC PRINT LABEL NOOBS SPLIT='*' WIDTH=MINIMUM;\n    BY SNODE;\n    VAR UID PROCNUM PROCNAME STEPNAME FUNC STARTIME ENDTIME TRANTIME\n        PNODE COMFCTRR CP RUSZ SNDBYTS CD FLAG DATE;\n    LABEL FLAG='MSG' PROCNUM='PROC #' PROCNAME='PROC NAME'\n          STEPNAME='STEP NAME' UID='USERID' CD='COND*CODE'\n          STARTIME=' START *HH:MM:SS' ENDTIME='END TIME*HH:MM:SS'\n       FUNC='STEP*TYPE' COMFCTRR='COMP* % ' CP='CMP*TYP' RUSZ='RU SIZE'\n          SNDBYTS='BYTES*SENT' TRANTIME='XMT TIME*H:MM:SS.TT';\n/*  1  */\nPROC SUMMARY   DATA = ACTIVITY MISSING  NWAY;\n     CLASS SNODE;\n     VAR   SNDBYTS;\n     OUTPUT OUT=BYTSUM SUM=TOTBYT MEAN = AVGBYT;\nPROC PRINT DATA = BYTSUM SPLIT = '*';\n     TITLE1 'NDM NODE SUMMARY REPORT ';\n     ID  SNODE;\n     SUM TOTBYT;\nLABEL _FREQ_  = 'NUMB. OF*PROC STEPS'\n      AVGBYT  = 'AVERAGE*BYTES '\n      TOTBYT  = 'TOTAL*BYTES';\nFORMAT AVGBYT COMMA16.2\n       TOTBYT COMMA16.0;\n  PROC PRINTTO;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ACTIVTY2": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x13%\\x9f\\x01\\x135?\\x113\\x00\\xda\\x00\\xda\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-09-16T00:00:00", "modifydate": "2013-12-19T11:33:45", "lines": 218, "newlines": 218, "modlines": 0, "user": "SCNS03"}, "text": "  DATA ACTIVITY;\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*   ONLY WANT 'FUNCTION TERMINATION' STATISTICS RECORDS;\n      IF RECTYPE = 'CT' OR RECTYPE = 'RT' OR\n         RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN DO;\n      IF RECTYPE = 'CT' THEN\n         INPUT  @5 ENDHH PK1.        /* XXTIME BROKEN TO 4 PKDLEN 1*/\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.            /* XXDATE    */\n                @13 STRTHH PK1.      /* XXSTIME BROKEN TO 4 PKDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.\n                @21 CC $4.                /* XXSCC     */\n                @25 MSGID $8.             /* XXMSGID   */\n                @33 PROCNAME $8.          /* XXPROCNM    1363862*/\n                @41 PROCNUM IB4.          /* XXPROCNO  */\n                @45 STEPNAME $8.          /* XXSTEP    */\n                @69 UID $8.               /* XXUID       1363862 */\n                @77 MYNODE $16.           /* XXPNODE   */\n                @93 OTHRNODE $16.         /* XXSNODE   */\n                @109 THISNODE $1.         /* XXNODE    */\n                @110 SENDIND $1.\n                @111 CTRANS IB1.\n                @112 COPYTYPE $CHAR1.\n                @113 RUSZ   IB4.\n                @129 INBYTES IB8.\n                @137 INRECS IB4.\n                @141 INBLKS IB4.\n                @145 SNDBYTS IB8.\n                @153 OUTBYTES IB8.\n                @161 OUTRECS IB4.\n                @165 OUTBLKS IB4.\n                @169 RCVBYTS IB8. @;\n      IF RECTYPE = 'RT' OR RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN\n         INPUT  @5 ENDHH PK1.        /* XXTIME BROKEN TO 4 PKDLEN 1*/\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.            /* XXDATE    */\n                @13 STRTHH PK1.      /* XXSTIME BROKEN TO 4 PKDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.\n                @21 CC $4.                /* XXSCC     */\n                @25 MSGID $8.             /* XXMSGID   */\n                @33 PROCNAME $8.          /* XXPROCNM    1363862*/\n                @41 PROCNUM IB4.          /* XXPROCNO  */\n                @45 STEPNAME $8.          /* XXSTEP    */\n                @69 UID $8.               /* XXUID     */\n                @77 UID56 $56             /* XXUID     */\n                @133 MYNODE $16.          /* XXPNODE   */\n                @149 OTHRNODE $16.        /* XXSNODE   */\n                @165 THISNODE $1. @;      /* XXNODE    */\n*        ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n*          ASSIGN SENDING AND RECEIVING NODES;\n**         IF SENDIND = 'P' THEN DO;\n**            SENDNODE = PNODE;\n**            RCVNODE = SNODE;\n**            END;\n**         ELSE DO;\n**            SENDNODE = SNODE;\n**            RCVNODE = PNODE;\n**            END;\n*        ASSIGN FUNCTION TYPE FOR OUTPUT;\n         IF RECTYPE = 'RT' THEN\n            FUNC = 'RUNT';\n         IF RECTYPE = 'CT' THEN\n            FUNC = 'COPY';\n         IF RECTYPE = 'RJ' THEN\n            FUNC = 'RUNJ';\n         IF RECTYPE = 'SW' THEN\n            FUNC = 'SUBM';\n         IF CC = '00000000'X THEN\n            FLAG = '        ';\n         ELSE\n            FLAG = MSGID;\n*           FLAG = '***';\n         CD = SUBSTR(CC,2,3);\n         IF FUNC = 'COPY' THEN CP = 'NO ';\n         IF CTRANS = '20' THEN CP = 'EXT';\n         IF CTRANS = '16' THEN CP = 'CMP';\n         IF CTRANS = '4' THEN CP = 'EXT';\n         IF CTRANS = '0' THEN CP = 'NO ';\n         DATE = DATEJUL(STRDTE);   /* CONVERT JULDTES->SAS FOR MATH*/\n         ENDDTE = DATEJUL(ENDDTE);\n      IF RECTYPE = 'CT' THEN DO;\n           IF INBYTES >= SNDBYTS THEN DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = SNDBYTS/INBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = INBYTES/SNDBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = -100 * TEMP2;\n              END;\n           END;\n           IF OUTBYTES >= RCVBYTS THEN DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = RCVBYTS/OUTBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = OUTBYTES/RCVBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = -100 * TEMP2;\n              END;\n           END;\n      END;\n*        'HMS' RETURNS SAS TIME VALUE FOR MATH;\n         STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n         ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n         TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n*                  {TRANS DAYS IN SECONDS  + TIME ENDED} - TIME STARTED;\n*        GET RID OF UNNECESSERY VARIABLES;\n         DROP ENDHH ENDMM ENDSS ENDTT ENDDTE STRTHH STRTMM STRTSS STRTTT\n              STRDTE OTHRNODE THISNODE RECTYPE;\n*             STARTIME ENDTIME\n*        ADD OBSERVATION TO SAS DATA SET BEING CREATED;\n         OUTPUT;\n      END;\n*     FORMAT DATE AND TIME FOR OUTPUT;\n      FORMAT UID $CHAR8.;                    /* 1371027 */\n      FORMAT PROCNUM BEST5.;                 /* 1371027 */\n      FORMAT PROCNAME $CHAR8.;               /* 1371027 */\n      FORMAT STEPNAME $CHAR8.;               /* 1371027 */\n      FORMAT FUNCTION $CHAR8.;               /* 1371027 */\n      FORMAT PNODE $CHAR16.;                 /* 1371027 */\n      FORMAT MSGID $CHAR8.;                  /* 1371027 */\n      FORMAT DATE MMDDYY8.;\n      FORMAT STARTIME TIME9.0;\n      FORMAT ENDTIME TIME9.0;\n      FORMAT TRANTIME TIME11.2;\n*     FORMAT CC $HEX8.;\n      FORMAT CD $HEX6.;\n      FORMAT SNDBYTS COMMA11.;\n* THIS DATA STEP SETS UP TO PUT NODENAME IN TITLE;\n  DATA _NULL_;\n    SET ACTIVITY;\n    CALL SYMPUT('NODE',MYNODE);\n    RUN;\n* PRINTS TITLES;\n  DATA _NULL_;\n    TITLE 'IBM Sterling Connect:Direct for z/OS Activity Report';\n    TITLE2 \"NODE = &NODE\";\n* SORT DATASET FOR PRINT;\n  PROC SORT;\n    BY SNODE PROCNUM;\n* ROUTE OUTPUT TO FT20F001 DD;\n  PROC PRINTTO NEW UNIT=20;\n* PRINT DATASET BY SNODE AND FOLLOWING ORDER ACROSS PAGE;\n  PROC PRINT LABEL NOOBS SPLIT='*' WIDTH=MINIMUM;\n    BY SNODE;\n    VAR UID PROCNUM PROCNAME STEPNAME FUNC STARTIME ENDTIME TRANTIME\n        PNODE COMFCTRR CP RUSZ SNDBYTS CD FLAG DATE;\n    LABEL FLAG='MSG' PROCNUM='PROC #' PROCNAME='PROC NAME'\n          STEPNAME='STEP NAME' UID='USERID' CD='COND*CODE'\n          STARTIME=' START *HH:MM:SS' ENDTIME='END TIME*HH:MM:SS'\n       FUNC='STEP*TYPE' COMFCTRR='COMP* % ' CP='CMP*TYP' RUSZ='RU SIZE'\n          SNDBYTS='BYTES*SENT' TRANTIME='XMT TIME*H:MM:SS.TT';\n/*  1  */\nPROC SUMMARY   DATA = ACTIVITY MISSING  NWAY;\n     CLASS SNODE;\n     VAR   SNDBYTS;\n     OUTPUT OUT=BYTSUM SUM=TOTBYT MEAN = AVGBYT;\nPROC PRINT DATA = BYTSUM SPLIT = '*';\n     TITLE1 'NDM NODE SUMMARY REPORT ';\n     ID  SNODE;\n     SUM TOTBYT;\nLABEL _FREQ_  = 'NUMB. OF*PROC STEPS'\n      AVGBYT  = 'AVERAGE*BYTES '\n      TOTBYT  = 'TOTAL*BYTES';\nFORMAT AVGBYT COMMA16.2\n       TOTBYT COMMA16.0;\n  PROC PRINTTO;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ACTVSECP": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00I\\x01\\x130?\\x01\\x135?\\x113\\x00\\xdc\\x00\\x80\\x00\\x86\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2013-10-30T00:00:00", "modifydate": "2013-12-19T11:33:49", "lines": 220, "newlines": 128, "modlines": 134, "user": "SCNS03"}, "text": "  DATA ACTIVITY;\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*   ONLY WANT 'Copy TERMINATION' STATISTICS RECORDS;\n**    IF RECTYPE = 'CT' OR RECTYPE = 'RT' OR\n**       RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN DO;\n      IF RECTYPE = 'CT' THEN DO;\n         INPUT  @5 ENDHH PK1.        /* XXTIME BROKEN TO 4 PKDLEN 1*/\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.            /* XXDATE    */\n                @13 STRTHH PK1.      /* XXSTIME BROKEN TO 4 PKDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.\n                @21 CC $4.                /* XXSCC     */\n                @25 MSGID $8.             /* XXMSGID   */\n                @33 PROCNAME $8.          /* XXPROCNM    1363862*/\n                @41 PROCNUM IB4.          /* XXPROCNO  */\n                @45 STEPNAME $8.          /* XXSTEP    */\n                @69 UID $8.               /* XXUID       1363862 */\n                @77 MYNODE $16.           /* XXPNODE   */\n                @93 OTHRNODE $16.         /* XXSNODE   */\n                @109 THISNODE $1.         /* XXNODE  @ */\n                @110 SENDIND $1.\n                @111 CTRANS IB1.\n                @112 COPYTYPE $CHAR1.\n                @113 RUSZ   IB4.\n                @129 INBYTES IB8.\n                @137 INRECS IB4.\n                @141 INBLKS IB4.\n                @145 SNDBYTS IB8.\n                @153 OUTBYTES IB8.\n                @161 OUTRECS IB4.\n                @165 OUTBLKS IB4.\n                @169 RCVBYTS IB8.\n                @497 SECP1    $1.         /* SECURE+ CT FLAG1 */\n                @498 SECP2    $1.         /* SECURE+ CT FLAG2 */\n                @499 CIPHER   $1. @;      /* CIPHER SUITE #   */\n         IF SECP1 = '00'X AND SECP2 = '00'X THEN\n            DELETE;\n**    IF RECTYPE = 'RT' OR RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN\n*        INPUT  @5 ENDHH PK1.        /* XXTIME BROKEN TO 4 PKDLEN 1*/\n*               @6 ENDMM PK1.\n*               @7 ENDSS PK1.\n*               @8 ENDTT PK1.\n*               @9 ENDDTE PD4.            /* XXDATE    */\n*               @13 STRTHH PK1.      /* XXSTIME BROKEN TO 4 PKDLEN 1 */\n*               @14 STRTMM PK1.\n*               @15 STRTSS PK1.\n*               @16 STRTTT PK1.\n*               @17 STRDTE PD4.\n*               @21 CC $4.                /* XXSCC     */\n*               @25 MSGID $8.             /* XXMSGID   */\n*               @33 PROCNAME $8.          /* XXPROCNM    1363862*/\n*               @41 PROCNUM IB4.          /* XXPROCNO  */\n*               @45 STEPNAME $8.          /* XXSTEP    */\n*               @69 UID $8.               /* XXUID     */\n*               @77 UID56 $56             /* XXUID     */\n*               @133 MYNODE $16.          /* XXPNODE   */\n*               @149 OTHRNODE $16.        /* XXSNODE   */\n**              @165 THISNODE $1. @;      /* XXNODE    */\n*        ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n*        ASSIGN FUNCTION TYPE FOR OUTPUT;\n         IF RECTYPE = 'RT' THEN\n            FUNC = 'RUNT';\n         IF RECTYPE = 'CT' THEN\n            FUNC = 'COPY';\n         IF RECTYPE = 'RJ' THEN\n            FUNC = 'RUNJ';\n         IF RECTYPE = 'SW' THEN\n            FUNC = 'SUBM';\n         IF CC = '00000000'X THEN\n            FLAG = '     ';\n         ELSE\n            FLAG = MSGID;\n*           FLAG = '***';\n         CD = SUBSTR(CC,2,3);\n         IF CIPHER = '0A'X THEN\n            SECP = '3DES';\n         IF CIPHER = '2F'X THEN\n            SECP = 'AES1';\n         IF CIPHER = '35'X THEN\n            SECP = 'AES2';\n         IF FUNC = 'COPY' THEN CP = 'NO ';\n         IF CTRANS = '20' THEN CP = 'EXT';\n         IF CTRANS = '16' THEN CP = 'CMP';\n         IF CTRANS = '4' THEN CP = 'EXT';\n         IF CTRANS = '0' THEN CP = 'NO ';\n         DATE = DATEJUL(STRDTE);   /* CONVERT JULDTES->SAS FOR MATH*/\n         ENDDTE = DATEJUL(ENDDTE);\n      IF RECTYPE = 'CT' THEN DO;\n           IF INBYTES >= SNDBYTS THEN DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = SNDBYTS/INBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = INBYTES/SNDBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = -100 * TEMP2;\n              END;\n           END;\n           IF OUTBYTES >= RCVBYTS THEN DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = RCVBYTS/OUTBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = OUTBYTES/RCVBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = -100 * TEMP2;\n              END;\n           END;\n      END;\n*        'HMS' RETURNS SAS TIME VALUE FOR MATH;\n         STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n         ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n         TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n*                  {TRANS DAYS IN SECONDS  + TIME ENDED} - TIME STARTED;\n*        GET RID OF UNNECESSERY VARIABLES;\n         DROP ENDHH ENDMM ENDSS ENDTT ENDDTE STRTHH STRTMM STRTSS STRTTT\n              STRDTE OTHRNODE THISNODE RECTYPE;\n*             STARTIME ENDTIME\n*        ADD OBSERVATION TO SAS DATA SET BEING CREATED;\n         OUTPUT;\n      END;\n*     FORMAT DATE AND TIME FOR OUTPUT;\n      FORMAT UID $CHAR8.;                    /* 1371027 */\n      FORMAT PROCNUM BEST5.;                 /* 1371027 */\n      FORMAT PROCNAME $CHAR8.;               /* 1371027 */\n      FORMAT STEPNAME $CHAR8.;               /* 1371027 */\n      FORMAT FUNCTION $CHAR8.;               /* 1371027 */\n      FORMAT PNODE $CHAR16.;                 /* 1371027 */\n      FORMAT MSGID $CHAR8.;                  /* 1371027 */\n      FORMAT DATE MMDDYY10.;\n      FORMAT STARTIME TIME9.0;\n      FORMAT ENDTIME TIME9.0;\n      FORMAT TRANTIME TIME11.2;\n*     FORMAT CC $HEX8.;\n      FORMAT CC $HEX6.;\n      FORMAT SNDBYTS COMMA11.;\n* THIS DATA STEP SETS UP TO PUT NODENAME IN TITLE;\n  DATA _NULL_;\n    SET ACTIVITY;\n    CALL SYMPUT('NODE',MYNODE);\n    RUN;\n* PRINTS TITLES;\n  DATA _NULL_;\n    TITLE 'IBM Sterling Connect:Direct Secure+ Activity Report';\n    TITLE2 \"NODE = &NODE\";\n* SORT DATASET FOR PRINT;\n  PROC SORT;\n    BY SNODE UID PROCNUM;\n* ROUTE OUTPUT TO FT20F001 DD;\n  PROC PRINTTO NEW UNIT=20;\n* PRINT DATASET BY SNODE AND FOLLOWING ORDER ACROSS PAGE;\n  PROC PRINT LABEL NOOBS SPLIT='*' WIDTH=MINIMUM;\n    BY SNODE;\n    VAR UID PROCNUM PROCNAME STEPNAME FUNC STARTIME ENDTIME TRANTIME\n        PNODE COMFCTRR CP RUSZ SNDBYTS SECP CD FLAG DATE;\n    LABEL FLAG='MSG' PROCNUM='PROC #' PROCNAME='PROC NAME'\n          STEPNAME='STEP NAME' UID='USERID' CD='COND*CODE'\n          STARTIME=' START *HH:MM:SS' ENDTIME='END TIME*HH:MM:SS'\n       FUNC='STEP*TYPE' COMFCTRR='COMP* % ' CP='CMP*TYP' RUSZ='RU SIZE'\n       SNDBYTS='BYTES*SENT' SECP='SEC+' TRANTIME='XMT TIME*H:MM:SS.TT';\n/*  1  */\nPROC SUMMARY   DATA = ACTIVITY MISSING  NWAY;\n     CLASS SNODE;\n     VAR   SNDBYTS;\n     OUTPUT OUT=BYTSUM SUM=TOTBYT MEAN = AVGBYT;\nPROC PRINT DATA = BYTSUM SPLIT = '*';\n     TITLE1 'NDM NODE SUMMARY REPORT ';\n     ID  SNODE;\n     SUM TOTBYT;\nLABEL _FREQ_  = 'NUMB. OF*PROC STEPS'\n      AVGBYT  = 'AVERAGE*BYTES '\n      TOTBYT  = 'TOTAL*BYTES';\nFORMAT AVGBYT COMMA16.2\n       TOTBYT COMMA16.0;\n  PROC PRINTTO;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CDJARS2$": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x01\\x13&\\x0f\\x01\\x13&\\x0f\\x18@\\x00H\\x00F\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-09-17T18:40:15", "lines": 72, "newlines": 70, "modlines": 0, "user": "SCNS03T"}, "text": "//jobname  JOB (actng),'REPORT',NOTIFY=&SYSUID,TIME=(1),COND=(0,NE),\n//            REGION=1024K,MSGCLASS=,CLASS=,\n//********************************************************************/\n//* LICENSED MATERIALS - PROPERTY OF IBM                             */\n//* 5655-X01 COPYRIGHT IBM CORP. 2011                                */\n//* ALL RIGHTS RESERVED                                              */\n//* US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION OR      */\n//* DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE CONTRACT WITH IBM CORP.*/\n//********************************************************************/\n//********************************************************************/\n//* THIS JCL CAN BE EDITED TO CREATE A JOB STREAM THAT RUNS          */\n//* ARS INDEPENDENTLY OF THE ARS PANELS. IT IS SET UP TO             */\n//* PRODUCE MULTIPLE REPORTS. FOLLOW THE INSTRUCTIONS OUTLINED BELOW.*/\n//*                                                                  */\n//*                                                                  */\n//*  1) MODIFY JOB CARD WITH APPROPIATE INFORMATION.                 */\n//*  2) CHANGE $CD.SDGALINK TO BE THE NAME OF THE C:D LOAD LIBRARY.  */\n//*  3) CHANGE $CD.SDGAPROC TO THE NAME OF THE C:D PROCESS LIB.      */\n//*  4) CHANGE ALL OCCURANCES OF $CDVSAM.MSG TO THE NAME OF THE C:D  */\n//*     MESSAGE DATASET.                                             */\n//*  5) CHANGE $UID IN SIGNON CMD TO YOUR C:D USERID-ADD PSWD IF NEC.*/\n//*  6) CHANGE $CDVSAM.NETMAP YOUR NETWORK MAP DATASET NAME.         */\n//*  7) CHANGE ALL OCCURANCES OF $UNITNAME TO VALID UNIT.            */\n//*  8) CHANGE $SASPROC TO THE NAME OF SAS CATALOGED PROCEDURE USED  */\n//*     AT YOUR INSTALLATION.                                        */\n//*  9) ROUTE OUTPUT TO A SYSOUT CLASS (LOOK FOR FT20F001 DD)        */\n//*                                                                  */\n//*  OR....                                                          */\n//*                                                                  */\n//*  9) CHANGE ALL $OUTPUT.DATASET.NAME TO BE NAME OF THE DATASET YOU*/\n//*     HAVE CHOSEN TO ROUTE THE OUTPUT TO. THIS DATASET SHOULD BE   */\n//*     ALLOCATED AS FBA WITH AN LRECL OF 240 AND BLKSIZE OF 3120.   */\n//*     THIS DATASET SHOULD BE EMPTY BEFORE RUNNING THIS JOB.        */\n//*     (DON'T FORGET TO DELETE THE ASTERISK ON THIS LINE IN THE JOB */\n//*      AND PLACE IT ON THE LINE ABOVE BEFORE RUNNING.)             */\n//*                                                                  */\n//*     A) SINCE THE SAS PROGRAMS ARE SET UP TO BE RUN INDIVIDUALLY, */\n//*        YOU MUST EDIT THE MEMBERS 'ACTIVITY' AND 'SECURITY' IN    */\n//*        YOUR $CD.SDGAMAP DATASET IN THE FOLLOWING MANNER:         */\n//*                                                                  */\n//*        CHANGE THE SAS STATEMENT...                               */\n//*        PROC PRINTTO NEW UNIT=20;   TO...                         */\n//*                                                                  */\n//*        PROC PRINTTO UNIT=20;                                     */\n//*                                                                  */\n//*        THIS WILL CAUSE THE OUTPUT FROM EACH REPORT TO APPEND TO  */\n//*        THE END OF THE OUTPUT FILE RATHER THAN OVERLAY WHATS      */\n//*        ALREADY THERE.                                            */\n//*                                                                  */\n//* 10) CHANGE $CD.SDGAMAP TO THE NAME OF THE DATASET CONTAINING     */\n//*     THE SAS PROGRAMS.                                            */\n//*                                                                  */\n//* NOTE -- IF YOU WOULD LIKE TO PUT SPECIFIC BOUNDARIES ON THE TIME */\n//*    SPAN TO BE REPORTED ON, MODIFY THE SEL STATISTICS COMMAND IN  */\n//*    THE SYSIN STREAM OF THE DMBATCH STEP TO INCLUDE START AND STOP*/\n//*    TIMES. AS IS, REPORTING WILL OCCUR ON THE ENTIRE STAT FILE    */\n//********************************************************************/\n//*\n//SASTEP EXEC $SASPROC,\n//        OPTIONS='DQUOTE MACRO MACROGEN MERROR MISSING=\"-\"',\n//        PARM='SYSPARM=nodename'\n//WORK       DD UNIT=$UNITNAME,SPACE=(CYL,(20,10))\n//NDMX0001   DD DISP=OLD,DSN=your.extract.dataset\n//DMMSGFIL   DD DISP=SHR,DSN=$CDVSAM.MSG\n//SASPROGS   DD DISP=SHR,DSN=$CD.SDGAMAP\n//FT20F001   DD SYSOUT=*\n//*FT20F001   DD DISP=MOD,DSN=$OUTPUT.DATASET.NAME\n//SYSIN      DD *\n%INCLUDE SASPROGS(ACTIVTY1,SUMMARY1,EXCEPT1,SECURITY,NPDSCPY1,PDSCOPY1,\n         RUNJOB1,RUNTASK1,SUBMIT1);\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CDJEXTR$": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x13&\\x0f\\x01\\x13&\\x0f\\x185\\x00V\\x00V\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-09-17T18:35:13", "lines": 86, "newlines": 86, "modlines": 0, "user": "SCNS03T"}, "text": "//jobname  JOB (actng),'EXTRACT',NOTIFY=&SYSUID,TIME=(1),COND=(0,NE),\n//            REGION=1024K,MSGCLASS=,CLASS=,\n//********************************************************************/\n//* LICENSED MATERIALS - PROPERTY OF IBM                             */\n//* 5655-X01 COPYRIGHT IBM CORP. 2011                                */\n//* ALL RIGHTS RESERVED                                              */\n//* US GOVERNMENT USERS RESTRICTED RIGHTS - USE, DUPLICATION OR      */\n//* DISCLOSURE RESTRICTED BY GSA ADP SCHEDULE CONTRACT WITH IBM CORP.*/\n//********************************************************************/\n//********************************************************************/\n//* THIS JCL CAN BE EDITED TO CREATE A JOB STREAM THAT RUNS          */\n//* ARS INDEPENDENTLY OF THE ARS PANELS. IT IS SET UP TO             */\n//* PRODUCE MULTIPLE REPORTS. FOLLOW THE INSTRUCTIONS OUTLINED BELOW.*/\n//*                                                                  */\n//*                                                                  */\n//*  1) MODIFY JOB CARD WITH APPROPIATE INFORMATION.                 */\n//*  2) CHANGE $CD.SDGALINK TO BE THE NAME OF THE C:D LOAD LIBRARY.  */\n//*  3) CHANGE $CD.SDGAPROC TO THE NAME OF THE C:D PROCESS LIB.      */\n//*  4) CHANGE ALL OCCURANCES OF $CDVSAM.MSG TO THE NAME OF THE C:D  */\n//*     MESSAGE DATASET.                                             */\n//*  5) CHANGE $UID IN SIGNON CMD TO YOUR C:D USERID-ADD PSWD IF NEC.*/\n//*  6) CHANGE $CDVSAM.NETMAP YOUR NETWORK MAP DATASET NAME.         */\n//*  7) CHANGE ALL OCCURANCES OF $UNITNAME TO VALID UNIT.            */\n//*  8) CHANGE $SASPROC TO THE NAME OF SAS CATALOGED PROCEDURE USED  */\n//*     AT YOUR INSTALLATION.                                        */\n//*  9) ROUTE OUTPUT TO A SYSOUT CLASS (LOOK FOR FT20F001 DD)        */\n//*                                                                  */\n//*  OR....                                                          */\n//*                                                                  */\n//*  9) CHANGE ALL $OUTPUT.DATASET.NAME TO BE NAME OF THE DATASET YOU*/\n//*     HAVE CHOSEN TO ROUTE THE OUTPUT TO. THIS DATASET SHOULD BE   */\n//*     ALLOCATED AS FBA WITH AN LRECL OF 240 AND BLKSIZE OF 3120.   */\n//*     THIS DATASET SHOULD BE EMPTY BEFORE RUNNING THIS JOB.        */\n//*     (DON'T FORGET TO DELETE THE ASTERISK ON THIS LINE IN THE JOB */\n//*      AND PLACE IT ON THE LINE ABOVE BEFORE RUNNING.)             */\n//*                                                                  */\n//*     A) SINCE THE SAS PROGRAMS ARE SET UP TO BE RUN INDIVIDUALLY, */\n//*        YOU MUST EDIT THE MEMBERS 'ACTIVITY' AND 'SECURITY' IN    */\n//*        YOUR $CD.SDGAMAP DATASET IN THE FOLLOWING MANNER:         */\n//*                                                                  */\n//*        CHANGE THE SAS STATEMENT...                               */\n//*        PROC PRINTTO NEW UNIT=20;   TO...                         */\n//*                                                                  */\n//*        PROC PRINTTO UNIT=20;                                     */\n//*                                                                  */\n//*        THIS WILL CAUSE THE OUTPUT FROM EACH REPORT TO APPEND TO  */\n//*        THE END OF THE OUTPUT FILE RATHER THAN OVERLAY WHATS      */\n//*        ALREADY THERE.                                            */\n//*                                                                  */\n//* 10) CHANGE $CD.SDGAMAP TO THE NAME OF THE DATASET CONTAINING     */\n//*     THE SAS PROGRAMS.                                            */\n//*                                                                  */\n//* NOTE -- IF YOU WOULD LIKE TO PUT SPECIFIC BOUNDARIES ON THE TIME */\n//*    SPAN TO BE REPORTED ON, MODIFY THE SEL STATISTICS COMMAND IN  */\n//*    THE SYSIN STREAM OF THE DMBATCH STEP TO INCLUDE START AND STOP*/\n//*    TIMES. AS IS, REPORTING WILL OCCUR ON THE ENTIRE STAT FILE    */\n//********************************************************************/\n//*\n//BATCH    EXEC PGM=DGADBATC,PARM='YYSLN'\n//STEPLIB   DD DSN=$CD.SDGALINK,DISP=SHR\n//DMPUBLIB  DD DSN=$CD.SDGAPROC,DISP=SHR\n//DMMSGFIL  DD DSN=$CDVSAM.MSG,DISP=SHR\n//*------------------------------------------------------------------*\n//*  Choose one of the following TEMPDSN DD cards and delete the other\n//*------------------------------------------------------------------*\n//*  To allocate a new Extract File use the TEMPDSN DD card below    *\n//*------------------------------------------------------------------*\n//TEMPDSN   DD DSN=your.extract.dataset,\n//             DISP=(NEW,CATLG),\n//             DCB=(DSORG=PS,RECFM=VBA,LRECL=4100,BLKSIZE=4104),\n//             SPACE=(4104,(700,130)),\n//             UNIT=$UNITNAME\n//*------------------------------------------------------------------*\n//*  To use a catalogued Extract file use the TEMPDSN DD card below  *\n//*------------------------------------------------------------------*\n//TEMPDSN   DD DSN=your.extract.dataset,\n//             DISP=SHR\n//DMPRINT   DD  SYSOUT=*\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\n SIGNON USERID=($UID) NETMAP=$CDVSAM.NETMAP TMPDD=TEMPDSN\n SEL STAT -\n    WHERE (STARTT=(YESTERDAY,07:00) STOPT=(TODAY,07:00)) FILE\n SIGNOFF\n/*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CDXOR01X": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x14\\x02/\\x01\\x14\\x02/\\x16H\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-01-22T00:00:00", "modifydate": "2014-01-22T16:48:28", "lines": 20, "newlines": 20, "modlines": 0, "user": "SCNS03T"}, "text": "*=====================================================================*\n*                CDXor MESSAGES (NDM Exit-TSTSMF2)                    *\n*                                                                     *\n*  Change \"Email@company.com\" to Email address of desired recipient   *\n*=====================================================================*\n*=====================================================================*\n*                CDX  MESSAGES (NDM) (C:D User Exits)                 *\n*=====================================================================*\n IF (LABEL:CDXOR) MSGID = 'CDX' . THEN BEGIN;\n*\n IF (LABEL:CDXOR01X) MSGID='CDXOR01X' & JOBNAME = JOBN\n    THEN EXEC(CMD('SNDMAIL6 Email@company.com 'JOBN) ROUTE(ONE AUTONDM))\n    DISPLAY(Y) NETLOG(Y);\n*\n ALWAYS;\n*\n END;\n*=====================================================================*\n*                End of CDP  messages                                 *\n*=====================================================================*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXCEPT1": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x13%\\x9f\\x01\\x13%\\x9f\\x17\\x17\\x01=\\x01:\\x00\\x03\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-16T00:00:00", "modifydate": "2013-09-16T17:17:16", "lines": 317, "newlines": 314, "modlines": 3, "user": "SCNS03"}, "text": "  DATA EXCEPT;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    TITLE;\n    INFILE NDMX0001 END=FINAL RECFM=VB;               /* 1363862 */\n    FILE FT20F001;\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*     ONLY WANT \"FUNCTION TERMINATION\" STATISTICS RECORDS;\n      IF RECTYPE = 'CT' OR RECTYPE = 'RT' OR\n         RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN DO;\n         TOTRECS + 1;                 /* COUNT NUM OF FUNCTIONS */\n         IF RECTYPE = 'CT' THEN\n            TOTCOPS + 1;              /* COUNT NUM OF COPIES    */\n         IF RECTYPE = 'RT' THEN\n            TOTRTS + 1;               /* COUNT NUM OF RUNTASKS  */\n         IF RECTYPE = 'RJ' THEN\n            TOTRJS + 1;               /* COUNT NUM OF SUBMITS   */\n         IF RECTYPE = 'SW' THEN\n            TOTSUBS + 1;\n      IF RECTYPE = 'CT' THEN\n         INPUT @17 STRDTE PD4.        /* XXSDATE   */\n               @21 CC $4.             /* XXSCC     */\n               @25 MSGID $8.          /* XXMSGID   */\n               @33 PROCNAME $8.       /* XXPROCNM        1363862*/\n               @41 PROCNUM IB4.       /* XXPROCNO  */\n               @45 STEPNAME $8.       /* XXSTEP    */\n               @69 UID $8.            /* XXUID     */\n               @77 MYNODE $16.        /* XXPNODE   */\n               @93 OTHRNODE $16.      /* XXSNODE   */\n               @109 THISNODE $1.      /* XXNODE    */\n               @110 SENDIND $1. @;    /* XXFROM    */\n      IF RECTYPE = 'RT' OR RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN\n         INPUT @17 STRDTE PD4.        /* XXSDATE   */\n               @21 CC $4.             /* XXSCC     */\n               @25 MSGID $8.          /* XXMSGID   */\n               @33 PROCNAME $8.       /* XXPROCNM        1363862*/\n               @41 PROCNUM IB4.       /* XXPROCNO  */\n               @45 STEPNAME $8.       /* XXSTEP    */\n               @69 UID $8.            /* XXUID     */\n               @77 UID56 $56.         /* XXUID     */\n               @133 MYNODE $16.       /* XXPNODE   */\n               @149 OTHRNODE $16.     /* XXSNODE   */\n               @165 THISNODE $1. @;   /* XXNODE    */\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n*        ONLY WANT FAILED FUNCTION TERMINATION RECORDS;\n         IF CC \u00ac= '00000000'X THEN DO;\n            NZRECS + 1;               /* COUNT FAILED FUNCTIONS */\n*           ASSIGN PNODE AND SNODE;\n            IF THISNODE = 'P' THEN DO;\n               PNODE = MYNODE;\n               SNODE = OTHRNODE;\n               END;\n            ELSE DO;\n               PNODE = OTHRNODE;\n               SNODE = MYNODE;\n               END;\n            DATE = DATEJUL(STRDTE);  /* CONVERT DATE TO SAS VALUE */\n            FORMAT DATE MMDDYY10.;   /* FORMAT DATE FOR OUTPUT    */\n            IF RECTYPE = 'CT' THEN DO;\n               NZCOPS + 1;           /* COUNT FAILED COPIES       */\n*              ASSIGN SENDING AND RECEIVING NODES;\n               IF SENDIND = 'P' THEN DO;\n                  SENDNODE = PNODE;\n                  RCVNODE = SNODE;\n                  END;\n               ELSE DO;\n                  SENDNODE = SNODE;\n                  RCVNODE = PNODE;\n                  END;\n*              DETERMINE WHICH TYPE OF COPY FAILED;\n               INPUT @112 COPYTYPE $CHAR1. @;\n               IF COPYTYPE = '1.......'B THEN\n                 FUNCTION = 'PDS COPY    ';\n               ELSE\n                 FUNCTION = 'NON-PDS COPY';\n*              GO AFTER SRC AND DEST DATASET NAMES;\n               INPUT @221 SDSNLEN IB2.\n                     SDSNAME $VARYING64.SDSNLEN\n                     @295 DDSNLEN IB2.\n                     DDSNAME $VARYING64.DDSNLEN @;\n            END;\n            IF RECTYPE = 'RT' THEN DO;\n               NZRTS + 1;            /* COUNT FAILED RUNTASKS    */\n*              ASSIGN NODE UPON WHICH TASK IS ATTACHED;\n               IF SENDIND = 'P' THEN\n                  SUBNODE = PNODE;\n               ELSE\n                  SUBNODE = SNODE;\n               FUNCTION = 'RUNTASK';\n               INPUT @167 PGMNAME $8. @;    /* RTMODNM   1363862*/\n            END;\n            IF RECTYPE = 'RJ' THEN DO;\n               NZRJS + 1;             /* COUNT FAILED RUNJOBS     */\n*              ASSIGN NODE WHERE JOB WILL RUN;\n               IF SENDIND = 'P' THEN\n                  SUBNODE = PNODE;\n               ELSE\n                  SUBNODE = SNODE;\n               FUNCTION = 'RUNJOB';\n               INPUT @189 DSP2DSN IB2.@;   /* RJDDSN    */\n*              GO AFTER DATASET NAME CONTAINING JOB;\n               IF DSP2DSN \u00ac= 0 THEN DO;\n                 DSP2DSN + 1;               /* FOR BYTE REL TO 1 */\n                 INPUT @DSP2DSN DSNLEN IB2.\n                       DSNAME $VARYING200.DSNLEN @;   /* 1363862 */\n               END;\n            END;\n            IF RECTYPE = 'SW' THEN DO;\n               NZSUBS + 1                  /* COUNT FAILED SUBMITS */;\n*              ASSIGN NODE UPON WHICH PROCESS IS SUBMITTED;\n               IF SENDIND = 'P' THEN\n                  SUBNODE = PNODE;\n               ELSE\n                  SUBNODE = SNODE;\n               FUNCTION = 'SUBMIT';\n*              GO AFTER DATASET NAME CONTAINING PROCESS;\n               INPUT @323 DSP2DSN IB2.@;      /* PSSDSN# */\n               IF DSP2DSN \u00ac= 0 THEN DO;\n                 DSP2DSN + 1                /* FOR BYTE REL TO 1 */;\n                 INPUT @DSP2DSN DSNLEN IB2.\n                       DSNAME $VARYING200.DSNLEN @;   /* 1363862 */\n               END;\n            END;\n         END;\n         OUTPUT;\n      END;\n* MAKE COPY OF LAST RECORD WITH TRUE TOTALS SO THAT THEY DONT GET;\n* LOST IN THE SORT;\n DATA LASTREC;\n   SET EXCEPT END=FINAL;\n   IF FINAL THEN DO;\n     OUTPUT;\n   END;\n* ORDER RECS BY SNODE FOR OUTPUT;\n PROC SORT DATA=EXCEPT;\n   BY SNODE UID PROCNUM;\n* STICK LAST RECORD WITH TRUE TOTALS ONTO END OF SAS DATASET;\n* THIS MEANS THAT THIS RECORD EXISTS SOMEWHERE IN THE SAS DATASET;\n* AS WELL AS BEING THE LAST RECORD IN THE SAS DATASET;\n DATA FINALEX;\n   SET EXCEPT LASTREC END=FINAL;\n   FORMAT CC $HEX8.;\n   FILE FT20F001 LINESLEFT=L;\n*     FIRST TIME THRU OR NEW PAGE?;\n      IF CC \u00ac= '00000000'X THEN;\n        NZCOUNT + 1;\n      IF NZCOUNT =1 THEN DO;\n        PUT @45 'IBM Sterling Connect:Direct for z/OS Exception Report';\n        PUT @50 'NODE = ' MYNODE;\n        PUT /;\n        PUT @3 'USERID      PROC #   PROC NAME   STEP NAME     EXCEPTION\n INFORMATION';\n        PUT @3 '******      ******   *********   *********     *********\n************************************************************************\n**';\n        PUT /;\n      END;\n      IF (L < 10 AND \u00acFINAL AND NZCOUNT \u00ac= 1) THEN DO;\n        PUT _PAGE_;\n        PUT @45 'IBM Sterling Connect:Direct for z/OS Exception Report';\n        PUT @50 'NODE = ' MYNODE;\n        PUT /;\n        PUT @3 'USERID      PROC #   PROC NAME   STEP NAME     EXCEPTION\n INFORMATION';\n        PUT @3 '******      ******   *********   *********     *********\n************************************************************************\n**';\n        PUT /;\n      END;\n*     SPECIAL OUTPUT FOR A FAILED COPY;\n* DO NOT PROCESS LAST REC IN FILE--IT WILL HAVE ALREADY BEEN PROCESSED;\n      IF CC \u00ac= '00000000'X AND \u00acFINAL THEN DO;\n        IF RECTYPE = 'CT' THEN DO;\n            PUT @3 UID @15 PROCNUM @24 PROCNAME @36 STEPNAME\n                @50 '** ' FUNCTION '**';\n            PUT @50 DATE @61 'PNODE = ' PNODE @87 'SNODE = ' SNODE;\n            PUT @50 'COMPLETION CODE = ' CC @87 'MSG ID = ' MSGID;\n            PUT @50 'SENDING NODE ==> ' SENDNODE;\n            PUT @50 'SRC DSNAME   ==> ' SDSNAME;\n            PUT @50 'RECEIVING NODE ==> ' RCVNODE;\n            PUT @50 'DEST DSNAME    ==> ' DDSNAME;\n  *         GET SHORT MESSAGE TEXT;\n            INFILE DMMSGFIL VSAM KEY=MSGID;\n            INPUT @23 SHTXTLEN IB2. @;\n            SHTXTLEN = SHTXTLEN - 2;\n            INPUT SHTEXT $VARYING200.SHTXTLEN;\n            UPSHTEXT = UPCASE(SHTEXT);\n            PUT @50 UPSHTEXT;\n           PUT '--------------------------------------------------------\n------------------------------------------------------------------------\n---';\n         END;\n         IF RECTYPE = 'RT' THEN DO;\n  *         INCLUDE THIS OBSERVATION IN SAS DATASET BEING CREATED;\n  *         SPECIAL OUTPUT FOR A FAILED RUNTASK;\n            PUT @3 UID @15 PROCNUM @24 PROCNAME @36 STEPNAME\n                @50 '** ' FUNCTION '**';\n            PUT @50 DATE @61 'PNODE = ' PNODE @85 'SNODE = ' SNODE;\n            PUT @50 'COMPLETION CODE = ' CC @85 'MSG ID = ' MSGID;\n            PUT @50 'PROGRAM NAME = ' PGMNAME;\n            PUT @50 'INTENDED NODE FOR PROGRAM EXECUTION = ' SUBNODE;\n  *         GET SHORT MESSAGE TEXT;\n            INFILE DMMSGFIL VSAM KEY=MSGID;\n            INPUT @23 SHTXTLEN IB2. @;\n            SHTXTLEN = SHTXTLEN - 2;\n            INPUT SHTEXT $VARYING200.SHTXTLEN;\n            UPSHTEXT = UPCASE(SHTEXT);\n            PUT @50 UPSHTEXT;\n               PUT '----------------------------------------------------\n------------------------------------------------------------------------\n---';\n         END;\n         IF RECTYPE = 'RJ' THEN DO;\n  *         INCLUDE THIS OBSERVATION IN SAS DATASET BEING CREATED;\n  *         SPECIAL OUTPUT FOR FAILED RUNJOBS;\n            PUT @3 UID @15 PROCNUM @24 PROCNAME @36 STEPNAME\n                @50 '** ' FUNCTION '**';\n            PUT @50 DATE @61 'PNODE = ' PNODE @85 'SNODE = ' SNODE;\n            PUT @50 'COMPLETION CODE = ' CC @85 'MSG ID = ' MSGID;\n            PUT @50 'DATASET CONTAINING JOB = ' DSNAME;\n            PUT @50 'INTENDED NODE FOR JOB SUBMISSION = ' SUBNODE;\n  *         GET SHORT MESSAGE TEXT;\n            INFILE DMMSGFIL VSAM KEY=MSGID;\n            INPUT @23 SHTXTLEN IB2. @;\n            SHTXTLEN = SHTXTLEN - 2;\n            INPUT SHTEXT $VARYING200.SHTXTLEN;\n            UPSHTEXT = UPCASE(SHTEXT);\n            PUT @50 UPSHTEXT;\n               PUT '----------------------------------------------------\n------------------------------------------------------------------------\n---';\n         END;\n  *         INCLUDE THIS OBSERVATION IN SAS DATASET BEING CREATED;\n         IF RECTYPE = 'SW' THEN DO;\n  *         SPECIAL OUTPUT FOR FAILED SUBMITS;\n            PUT @3 UID @15 PROCNUM @24 PROCNAME @36 STEPNAME\n                @50 '** ' FUNCTION '**';\n            PUT @50 DATE @61 'PNODE = ' PNODE @85 'SNODE = ' SNODE;\n            PUT @50 'COMPLETION CODE = ' CC @85 'MSG ID = ' MSGID;\n            PUT @50 'DATASET CONTAINING PROCESS = ' DSNAME;\n            PUT @50 'INTENDED NODE FOR PROCESS SUBMISSION = ' SUBNODE;\n            INFILE DMMSGFIL VSAM KEY=MSGID;\n            INPUT @23 SHTXTLEN IB2. @;\n            SHTXTLEN = SHTXTLEN - 2;\n            INPUT SHTEXT $VARYING200.SHTXTLEN;\n            UPSHTEXT = UPCASE(SHTEXT);\n            PUT @50 UPSHTEXT;\n            PUT '-------------------------------------------------------\n------------------------------------------------------------------------\n---';\n         END;\n      END;\n      IF FINAL THEN DO;\n*       FIGURE OUT PERCENTAGES;\n        IF TOTRECS = 0 THEN\n          PERFPRCS = 0;\n        ELSE\n          PERFPRCS = (NZRECS / TOTRECS) * 100;\n        PERFPRCS = ROUND(PERFPRCS,.1);\n        IF TOTCOPS = 0 THEN\n          PERFCOPS = 0;\n        ELSE\n          PERFCOPS = (NZCOPS / TOTCOPS) * 100;\n        PERFCOPS = ROUND(PERFCOPS,.1);\n        IF TOTRJS = 0 THEN\n          PERFRJS = 0;\n        ELSE\n          PERFRJS = (NZRJS / TOTRJS) * 100;\n        PERFRJS = ROUND(PERFRJS,.1);\n        IF TOTRTS = 0 THEN\n          PERFRTS = 0;\n        ELSE\n          PERFRTS = (NZRTS / TOTRTS) * 100;\n        PERFRTS = ROUND(PERFRTS,.1);\n        IF TOTSUBS = 0 THEN\n          PERFSBS = 0;\n        ELSE\n          PERFSBS = (NZSUBS / TOTSUBS) * 100;\n        PERFSBS = ROUND(PERFSBS,.1);\n*       GO TO A NEW PAGE;\n        PUT _PAGE_;\n*       WRITE SUMMARY INFORMATION TO OUTPUT;\n        PUT @45 'IBM Sterling Connect:Direct for z/OS Exception Report';\n        PUT @50 'NODE = ' MYNODE;\n        PUT 'SUMMARY INFORMATION';\n        PUT '*******************';\n        PUT /// NZRECS @8 'NON-SUCCESSFUL STEPS IN ' @35 TOTRECS @42 'PR\nOCESS STEPS RUN OR';\n        PUT   / '--> ' PERFPRCS @14 '% OF TOTAL PROCESS STEPS RUN COMPLE\nTED WITH A NON-ZERO RETURN CODE';\n       PUT //// NZCOPS @8 'NON-SUCCESSFUL COPIES IN ' @35 TOTCOPS @42 'C\nOPY STEPS RUN OR';\n        PUT   / '--> ' PERFCOPS @14 '% OF TOTAL COPY STEPS RUN COMPLETED\n WITH A NON-ZERO RETURN CODE';\n       PUT //// NZRJS @8 'NON-SUCCESSFUL RUNJOBS IN ' @35 TOTRJS @42 'RU\nNJOB STEPS RUN OR';\n        PUT   / '--> ' PERFRJS @14 '% OF TOTAL RUNJOB STEPS RUN COMPLETE\nD WITH A NON-ZERO RETURN CODE';\n       PUT //// NZRTS @8 'NON-SUCCESSFUL RUNTASKS IN ' @35 TOTRTS @42 'R\nUNTASK STEPS RUN OR';\n        PUT   / '--> ' PERFRTS @14 '% OF TOTAL RUNTASK STEPS RUN COMPLET\nED WITH A NON-ZERO RETURN CODE';\n       PUT //// NZSUBS @8 'NON-SUCCESSFUL SUBMITS IN ' @35 TOTSUBS @42'S\nUBMIT STEPS RUN OR';\n        PUT   / '--> ' PERFSBS @14 '% OF TOTAL SUBMIT STEPS RUN COMPLETE\nD WITH A NON-ZERO RETURN CODE';\n      END;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IDBG": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x10\\x11\\x8f\\x01\\x10\\x11\\x8f\\x17#\\x00\\x06\\x00\\x06\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-28T00:00:00", "modifydate": "2010-04-28T17:23:05", "lines": 6, "newlines": 6, "modlines": 0, "user": "SCNS03"}, "text": "PROC 0\n***\n*** DISPLAY INITPARMS\n***\n***\n   INQUIRE DEBUG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MPFLSTXX": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x18\\x01\\x131/\\x01\\x14\\x02/\\x16C\\x00B\\x00A\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-11-08T00:00:00", "modifydate": "2014-01-22T16:43:18", "lines": 66, "newlines": 65, "modlines": 0, "user": "SCNS03T"}, "text": "/**********************************************************************/\n/*                                                                    */\n/*  NAME(MPFLST12)  SAMPLE(CNMS6202)  RELATED-TO()                    */\n/*                                                                    */\n/*  DESCRIPTION:                                                      */\n/*    This MPFLSTxx parmlib member takes an aggressive approach to    */\n/*    message suppression.  It suppresses all of the messages         */\n/*    suppressed in the conservative example and more.  Make sure     */\n/*    you review the list of messages suppressed below and remove     */\n/*    from the list all messages your operators still need to see.    */\n/*                                                                    */\n/*    The .DEFAULT statement tells the system what to do with the     */\n/*    messages listed below it.  Here, the system is to:              */\n/*    - mark the listed messages ineligible for automation by NetView */\n/*    - retain the listed messages in the action message retention    */\n/*      facility (action messages and WTORs only)                     */\n/*    - suppress (avoid displaying) the listed messages               */\n/*                                                                    */\n/*    However, you can override the values specified in               */\n/*    the .DEFAULT statement by putting values in the                 */\n/*    individual message lines.  For instance, you can                */\n/*    mark a message eligible for automation by NetView               */\n/*    (while still retaining it and suppressing it) by                */\n/*    by adding \",AUTO(YES)\" onto its entry in the list below.        */\n/*                                                                    */\n/*    The .NO_ENTRY statement tells the system what to do if          */\n/*    there is no entry listed for the message.                       */\n/*    Here, the system is to:                                         */\n/*    - mark the unlisted message ineligible for automation           */\n/*      by NetView                                                    */\n/*    - retain the unlisted message in the action message retention   */\n/*      facility (action messages and WTORs only)                     */\n/*    - display the unlisted message                                  */\n/*                                                                    */\n/*    If the .NO_ENTRY statement is used in this manner, every        */\n/*    message that needs to be eligible for NetView automation, must  */\n/*    be listed below and an entry must also be added to the NetView  */\n/*    Message Automation Table.                                       */\n/*                                                                    */\n/*  CNMS6202 CHANGED ACTIVITY:                                        */\n/*  CHANGE CODE  DATE      DESCRIPTION                                */\n/*  -----------  --------  ------------------------------------------ */\n/**********************************************************************/\n/*                                                                    */\n.NO_ENTRY,AUTO(NO),RETAIN(YES),SUP(NO)\n.DEFAULT,AUTO(ANSY),RETAIN(YES),SUP(YES)\n/*                                                                    */\n/*    The following messages are to be suppressed:                    */\n/*                                                                    */\nSVTM026I          NDM        Session NOT established\nSVTM036I                     Process started messages\nSVTM037I                     Process ended messages\nSVTM055I                     Session established\nSVTM056I                     Session terminated\n/*                                                                    */\n/*    The following messages are to be automated:                     */\n/*                                                                    */\n.DEFAULT,AUTO(YES),RETAIN(YES),SUP(YES)\n/*                                                                    */\nCDXOR01X          TSTSMF2    NDM User exit message\n/*                                                                    */\nSVTM052I          NDM        Run Task jjjjjjjj( nnnnnnnn)\nSVTM083I                     Pname(Pnum) &node REASON=&mgid\nSVTM102I                     Node not in Netmap\nSVTM105I                     Process moved to QUEUE\n/*                                                                    */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NPDSCPY1": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x13%\\x9f\\x01\\x13%\\x9f\\x17T\\x01\\x05\\x01\\x02\\x00\\x03\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-16T00:00:00", "modifydate": "2013-09-16T17:54:16", "lines": 261, "newlines": 258, "modlines": 3, "user": "SCNS03T"}, "text": "  DATA NPDSCOPY;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*     ONLY WANT COPY TERMINATION RECORDS;\n      IF RECTYPE = 'CT' THEN DO;\n         INPUT  @5 ENDHH PK1.\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.\n                @13 STRTHH PK1.\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRTDTE PD4.\n                @21 CC $4.\n                @25 MSGID $8.\n                @33 PROCNAME $8.                      /* 1363862 */\n                @41 PROCNUM IB4.\n                @45 STEPNAME $8.\n                @69 UID $8.                           /* 1363862 */\n                @77 MYNODE $16.\n                @93 OTHRNODE $16.\n                @109 THISNODE $1.\n                @110 SENDIND $1.\n                @112 COPYTYPE $CHAR1. @;\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n*        ONLY WANT NON-PDS COPIES;\n         IF COPYTYPE = '0.......'B THEN DO; /* NON-PDS COPY */\n*          ASSIGN PNODE AND SNODE;\n           IF THISNODE = 'P' THEN DO;\n              PNODE = MYNODE;\n              SNODE = OTHRNODE;\n              END;\n           ELSE DO;\n              PNODE = OTHRNODE;\n              SNODE = MYNODE;\n              END;\n*          ASSIGN SENDING AND RECEIVING NODES;\n           IF SENDIND = 'P' THEN DO;\n              SENDNODE = PNODE;\n              RCVNODE = SNODE;\n              END;\n           ELSE DO;\n              SENDNODE = SNODE;\n              RCVNODE = PNODE;\n              END;\n           ENDDTE = DATEJUL(ENDDTE);      /* CONVERT JUL->SAS: MATH */\n           DATE = DATEJUL(STRTDTE);\n           INPUT @129 INBYTES IB8.\n                 @137 INRECS IB4.\n                 @141 INBLKS IB4.\n                 @145 SNDBYTS IB8.\n                 @153 OUTBYTES IB8.\n                 @161 OUTRECS IB4.\n                 @165 OUTBLKS IB4.\n                 @169 RCVBYTS IB8.\n                 @221 SDSNLEN IB2.\n                 SDSNAME $VARYING64.SDSNLEN\n                 @295 DDSNLEN IB2.\n                 DDSNAME $VARYING64.DDSNLEN\n                 @389 DSP2VSR IB2.\n                 @391 DSP2VSS IB2. @;\n*                GO AFTER SRC AND DEST VOLSERS;\n                 IF DSP2VSR \u00ac= 0 THEN DO;\n                   DSP2VSR + 1;             /* REL TO 0 */\n                   INPUT @DSP2VSR NUMVSRS IB2. @;/*NUMBER OF VOLSERS */\n                         VSRRBYTS = NUMVSRS * 6;/* 6 BYTES PER VOLSER*/\n                         INPUT VOLSERR $VARYING200.VSRRBYTS @;\n                 END;\n                 IF DSP2VSS \u00ac= 0 THEN DO;\n                   DSP2VSS + 1 ;\n                   INPUT @DSP2VSS NUMVSSS IB2. @;\n                         VSRSBYTS = NUMVSSS * 6;/* 6 BYTES PER VOLSER*/\n                         INPUT VOLSERS $VARYING200.VSRSBYTS @;\n                 END;\n           IF INBYTES >= SNDBYTS THEN DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = SNDBYTS/INBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = INBYTES/SNDBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = -100 * TEMP2;\n              END;\n           END;\n           IF OUTBYTES >= RCVBYTS THEN DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = RCVBYTS/OUTBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = OUTBYTES/RCVBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = -100 * TEMP2;\n              END;\n           END;\n*          HMS RETURNS SAS TIME VALUE FROM HHMMSS;\n           STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n           ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n           TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n*                    {TRAN DAYS IN SECONDS} + {TRAN TIME IN SECONDS};\n*          DROP ALL NECESSERY VARIABLES;\n           DROP ENDHH ENDMM ENDSS ENDTT ENDDTE STRTHH STRTTT STRTDTE\n                OTHRNODE THISNODE SENDIND COPYTYPE\n                SDSNLEN DDSNLEN DSP2VSR DSP2VSS;\n*          FORMAT DATE AND TIME FOR OUTPUT;\n           FORMAT DATE MMDDYY10.;\n           FORMAT TRANTIME TIME10.2;\n           FORMAT CC $HEX8.;\n*          IS THIS MEMBER TO PS OR PS TO MEMBER?;\n*          GO AFTER MEMBER NAME FOR THE COPY;\n           IF COPYTYPE = '0.1.....'B OR COPYTYPE = '0..1....'B THEN DO;\n              INPUT @361 MEMBER $8. @;\n              FMEMBER = '(' ||TRIM(MEMBER)|| ')';\n              IF COPYTYPE = '0.1.....'B THEN\n                 SDSNAME = TRIM(SDSNAME) || FMEMBER;\n              ELSE\n                 DDSNAME = TRIM(DDSNAME) || FMEMBER;\n           END;\n           OUTPUT;\n         END;\n      END;\n  PROC SORT DATA=NPDSCOPY;\n    BY SNODE UID;\n  DATA SORTRECS;\n    SET NPDSCOPY;\n    FILE FT20F001 N=PS LINE=CURLINE;\n*     FIRST TIME THRU?;\n        IF _N_ =1 THEN DO;\n           PUT @45 'IBM Sterling Connect:Direct for z/OS Non-PDS Copy Re\nport';\n           PUT @50 'NODE = ' MYNODE;\n           PUT /;\n           PUT @3\n         'USERID      PROC #   PROC NAME    STEP NAME    TRANSMISSION IN\nFORMATION';\n           PUT @3\n         '******      ******   *********    *********    ***************\n******************************************************************';\n           PUT /;\n        END;\n*          EVERY THIRD COPY GO TO A NEW PAGE AND PRINT HEADINGS;\n           COUNT + 1;\n           REMAIN = MOD(COUNT,3);\n           IF REMAIN = 1 AND COUNT \u00ac= 1 THEN DO;\n               PUT _PAGE_;\n               PUT @45 'IBM Sterling Connect:Direct for z/OS Non-PDS Cop\ny Report';\n               PUT @50 'NODE = ' MYNODE;\n               PUT /@3\n         'USERID      PROC #   PROC NAME    STEP NAME    TRANSMISSION IN\nFORMATION';\n               PUT @3\n         '******      ******   *********    *********    ***************\n******************************************************************';\n               PUT /;\n           END;\n*          WRITE TO OUTPUT;\n           PUT @3 UID @15 PROCNUM @24 PROCNAME @37 STEPNAME\n               @50 DATE @61 'PNODE = ' PNODE @87 'SNODE = ' SNODE;\n           PUT @50 'TRANSMISSION TIME = ' TRANTIME\n               @87 'COMPLETION CODE = ' CC @114 'MSG ID = ' MSGID;\n           INFILE DMMSGFIL VSAM KEY=MSGID;\n           INPUT @23 SHTXTLEN IB2. @;\n           SHTXTLEN = SHTXTLEN - 2;\n           INPUT SHTEXT $VARYING200.SHTXTLEN;\n           UPSHTEXT = UPCASE(SHTEXT);\n           PUT @50 UPSHTEXT;\n           PUT @50 '====================================================\n=============================';\n           PUT @50 'SRC DSNAME IS ' SDSNAME;\n           PUT @50 'DEST DSNAME IS ' DDSNAME;\n           IF CC < '00000008'X OR INBYTES \u00ac= 0 OR OUTBYTES \u00ac= 0 THEN DO;\n             PUT @55 'SENDING NODE ==> ' SENDNODE\n                 @89 'RECEIVING NODE ==> ' RCVNODE;\n             PUT @55 'BYTES READ   ==> ' INBYTES\n                 @89 'BYTES WRITTEN  ==> ' OUTBYTES;\n             PUT @55 'BLOCKS READ  ==> ' INBLKS\n                 @89 'BLOCKS WRITTEN ==> ' OUTBLKS;\n             PUT @55 'RECS READ    ==> ' INRECS\n                 @89 'RECS WRITTEN   ==> ' OUTRECS;\n             PUT @55 'BYTES SENT   ==> ' SNDBYTS\n                 @89 'BYTES RECEIVED ==> ' RCVBYTS;\n             PUT @55 'COMPRESSION% ==> ' COMFCTRR\n                 @89 'COMPRESSION%   ==> ' COMFCTRW;\n             IF NUMVSSS > 1 THEN DO;\n               VLSRLINE = CURLINE;\n               POS = 1;\n               DO WHILE (POS < VSRSBYTS);\n                  VOL=SUBSTR(VOLSERS,POS,6);\n                  IF POS = 1 THEN\n                    PUT @55 'VOLSER       ==> ' VOL;\n                  ELSE\n                    PUT @72 VOL;\n                  POS = POS + 6;\n               END;\n             END;\n             ELSE\n               PUT @55 'VOLSER       ==> ' VOLSERS @;\n             IF NUMVSRS > 1 THEN DO;\n               POS = 1;\n               DO WHILE (POS < VSRRBYTS);\n                  VOL=SUBSTR(VOLSERR,POS,6);\n                  IF POS = 1 THEN\n                    IF NUMVSSS > 1 THEN\n                      PUT #VLSRLINE @89 'VOLSER         ==> ' VOL;\n                    ELSE\n                      PUT  @89 'VOLSER         ==> ' VOL;\n                  ELSE\n                    PUT @108 VOL;\n                  POS = POS + 6;\n               END;\n             END;\n             ELSE\n               IF NUMVSSS > 1 THEN DO;\n                 PUT #VLSRLINE @89 'VOLSER         ==> ' VOLSERR;\n                 LOOPCTR = NUMVSSS - 2;\n                 DO WHILE (LOOPCTR > 0);\n                   PUT /;\n                   LOOPCTR = LOOPCTR - 1;\n                 END;\n               END;\n               ELSE\n                 PUT @89 'VOLSER         ==> ' VOLSERR;\n           END;\n           PUT  @3 '----------------------------------------------------\n------------------------------------------------------------------------\n----';\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSCOPY1": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x13\\x01\\x13&\\x0f\\x01\\x13&\\x0f\\x17\\x05\\x01\\x12\\x01\\x0f\\x00\\x03\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-09-17T17:05:13", "lines": 274, "newlines": 271, "modlines": 3, "user": "SCNS03"}, "text": "  DATA COPYRECS;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n* ONLY WANT COPY TERMINATION RECORDS;\n      IF RECTYPE = 'CT' THEN DO;\n         INPUT  @5 ENDHH PK1.     /* CTTIME BROKEN TO 4 PACKED LEN 1 */\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.   /* CTDATE */\n                @13 STRTHH PK1.  /* CTSTIME BROKEN TO 4 PACKED LEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRTDTE PD4.       /* CTSDATE   */\n                @21 CC $4.             /* CTSCC     */\n                @25 MSGID $8.          /* CTMSGID   */\n                @33 PROCNAME $8.       /* CTPROCNM       1363862*/\n                @41 PROCNUM IB4.       /* CTPROCNO  */\n                @45 STEPNAME $8.       /* CTSTEP    */\n                @69 UID $8.            /* CTUID          1363862 */\n                @77 MYNODE $16.        /* CTPNODE   */\n                @93 OTHRNODE $16.      /* CTSNODE   */\n                @109 THISNODE $1.      /* CTNODE    */\n                @110 SENDIND $1.       /* CTFROM    */\n                @112 COPYTYPE $CHAR1.@; /* CTTRANS2--CTPDSCPY */\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n*        ONLY WANT PDS COPIES;\n         IF COPYTYPE = '1.......'B THEN DO; /* PDS COPY */\n           IF THISNODE = 'P' THEN DO;\n              PNODE = MYNODE;\n              SNODE = OTHRNODE;\n              END;\n           ELSE DO;\n              PNODE = OTHRNODE;\n              SNODE = MYNODE;\n              END;\n           IF SENDIND = 'P' THEN DO;\n              SENDNODE = PNODE;\n              RCVNODE = SNODE;\n              END;\n           ELSE DO;\n              SENDNODE = SNODE;\n              RCVNODE = PNODE;\n              END;\n           ENDDTE = DATEJUL(ENDDTE);\n           DATE = DATEJUL(STRTDTE);\n           INPUT @129 INBYTES IB8.      /* CTINBYTE  */\n                 @137 INRECS IB4.       /* CTINRECN  */\n                 @141 INBLKS IB4.       /* CTINBLK   */\n                 @145 SNDBYTS IB8.      /* CTSBYTES  */\n                 @153 OUTBYTES IB8.     /* CTOTBYTE  */\n                 @161 OUTRECS IB4.      /* CTOTRECN  */\n                 @165 OUTBLKS IB4.      /* CTOTBLK   */\n                 @169 RCVBYTS IB8.      /* CTRBYTES  */\n                 @221 SDSNLEN IB2.\n                 SDSNAME $VARYING64.SDSNLEN\n                 @295 DDSNLEN IB2.\n                 DDSNAME $VARYING64.DDSNLEN\n                 @389 DSP2VSR IB2.\n                 @391 DSP2VSS IB2. @;\n                 IF DSP2VSR \u00ac= 0 THEN DO;\n                   DSP2VSR + 1;             /* REL TO 0 */\n                   INPUT @DSP2VSR NUMVSRS IB2. @;/*NUMBER OF VOLSERS */\n                         VSRRBYTS = NUMVSRS * 6;/* 6 BYTES PER VOLSER*/\n                         INPUT VOLSERR $VARYING200.VSRRBYTS @;\n                 END;\n                 IF DSP2VSS \u00ac= 0 THEN DO;\n                   DSP2VSS + 1 ;\n                   INPUT @DSP2VSS NUMVSSS IB2. @;\n                         VSRSBYTS = NUMVSSS * 6;/* 6 BYTES PER VOLSER*/\n                         INPUT VOLSERS $VARYING200.VSRSBYTS @;\n                 END;\n           IF INBYTES >= SNDBYTS THEN DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = SNDBYTS/INBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF INBYTES = SNDBYTS THEN\n                COMFCTRR = 0;\n              ELSE DO;\n                TEMP1 = INBYTES/SNDBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRR = -100 * TEMP2;\n              END;\n           END;\n           IF OUTBYTES >= RCVBYTS THEN DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = RCVBYTS/OUTBYTES;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = 100 * TEMP2;\n              END;\n           END;\n           ELSE DO;\n              IF OUTBYTES = RCVBYTS THEN\n                COMFCTRW = 0;\n              ELSE DO;\n                TEMP1 = OUTBYTES/RCVBYTS;\n                TEMP2 = 1 - TEMP1;\n                TEMP2 = ROUND(TEMP2,.001);\n                COMFCTRW = -100 * TEMP2;\n              END;\n           END;\n           STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n           ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n           TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n           DROP ENDHH ENDMM ENDSS ENDTT ENDDTE STRTHH STRTTT STRTDTE\n                OTHRNODE THISNODE SENDIND COPYTYPE\n                SDSNLEN DDSNLEN DSP2VSR DSP2VSS;\n           FORMAT DATE MMDDYY10.;\n           FORMAT TRANTIME TIME10.2;\n           FORMAT CC $HEX8.;\n           OUTPUT;\n          END;\n      END;\n  DATA MEMRECS;\n    INFILE NDMX0001;\n    INPUT RECTYPE $ 3-4 @;\n      IF RECTYPE = 'MC' THEN DO;\n         INPUT @41 PROCNUM IB4.\n               @45 STEPNAME $8.\n               @167 DMEMB $8.\n               @175 SMEMB $8.;\n         OUTPUT;\n      END;\n  DATA PDSRECS;\n    SET COPYRECS MEMRECS;\n  PROC SORT DATA=PDSRECS;\n    BY PROCNUM STEPNAME;\n  DATA PDSCOPY;\n    SET PDSRECS;\n    FILE FT20F001 N=PS LINE=CURLINE LINESLEFT=L;\n      IF RECTYPE = 'CT' THEN DO;\n         COPYCNT + 1;\n         IF COPYCNT \u00ac= 1 THEN;\n             PUT _PAGE_;\n         PUT @45 'IBM Sterling Connect:Direct for z/OS PDS Copy Report';\n         PUT @50 'NODE = ' MYNODE;\n         PUT /;\n         PUT @3\n         'USERID      PROC #   PROC NAME    STEP NAME    TRANSMISSION IN\nFORMATION';\n         PUT @3\n         '******      ******   *********    *********    ***************\n****************************************************************';\n         PUT /;\n           PUT @3 UID @15 PROCNUM @24 PROCNAME @37 STEPNAME\n               @50 DATE @61 'PNODE = ' PNODE @87 'SNODE = ' SNODE;\n           PUT @50 'TRANSMISSION TIME = ' TRANTIME\n               @87 'COMPLETION CODE = ' CC\n               @114 'MSGID= ' MSGID;\n           INFILE DMMSGFIL VSAM KEY=MSGID;\n           INPUT @23 SHTXTLEN IB2. @;\n           SHTXTLEN = SHTXTLEN - 2;\n           INPUT SHTEXT $VARYING200.SHTXTLEN;\n           UPSHTEXT = UPCASE(SHTEXT);\n           PUT @50 UPSHTEXT;\n           PUT @50 '====================================================\n===========================';\n           PUT @50 'SRC DSNAME IS ' SDSNAME;\n           PUT @50 'DEST DSNAME IS ' DDSNAME;\n* IF BYTES WERE TRANSFERRED (EVEN FOR A FAILED COPY) THEN DISPLAY THEM;\n           IF CC < '00000008'X OR INBYTES \u00ac= 0 OR OUTBYTES \u00ac= 0 THEN DO;\n             PUT @55 'SENDING NODE ==> ' SENDNODE\n                 @89 'RECEIVING NODE ==> ' RCVNODE;\n             PUT @55 'BYTES READ   ==> ' INBYTES\n                 @89 'BYTES WRITTEN  ==> ' OUTBYTES;\n             PUT @55 'BLOCKS READ  ==> ' INBLKS\n                 @89 'BLOCKS WRITTEN ==> ' OUTBLKS;\n             PUT @55 'RECS READ    ==> ' INRECS\n                 @89 'RECS WRITTEN   ==> ' OUTRECS;\n             PUT @55 'BYTES SENT   ==> ' SNDBYTS\n                 @89 'BYTES RECEIVED ==> ' RCVBYTS;\n             PUT @55 'COMPRESSION% ==> ' COMFCTRR\n                 @89 'COMPRESSION%   ==> ' COMFCTRW;\n             IF NUMVSSS > 1 THEN DO;\n               VLSRLINE = CURLINE;\n               POS = 1;\n               DO WHILE (POS < VSRSBYTS);\n                  VOL=SUBSTR(VOLSERS,POS,6);\n                  IF POS = 1 THEN\n                    PUT @55 'VOLSER       ==> ' VOL;\n                  ELSE\n                    PUT @72 VOL;\n                  POS = POS + 6;\n               END;\n             END;\n             ELSE\n               PUT @55 'VOLSER       ==> ' VOLSERS @;\n             IF NUMVSRS > 1 THEN DO;\n               POS = 1;\n               DO WHILE (POS < VSRRBYTS);\n                  VOL=SUBSTR(VOLSERR,POS,6);\n                  IF POS = 1 THEN\n                    IF NUMVSSS > 1 THEN\n                      PUT #VLSRLINE @89 'VOLSER         ==> ' VOL;\n                    ELSE\n                      PUT  @89 'VOLSER         ==> ' VOL;\n                  ELSE\n                    PUT @108 VOL;\n                  POS = POS + 6;\n               END;\n             END;\n             ELSE\n               IF NUMVSSS > 1 THEN DO;\n                 PUT #VLSRLINE @89 'VOLSER         ==> ' VOLSERR;\n                 LOOPCTR = NUMVSSS - 2;\n                 DO WHILE (LOOPCTR > 0);\n                   PUT /;\n                   LOOPCTR = LOOPCTR - 1;\n                 END;\n               END;\n               ELSE\n                 PUT @89 'VOLSER         ==> ' VOLSERR;\n* ONLY WANT TO DISPLAY A MEMBER LIST IF THE COPY WORKED;\n             IF CC < '00000008'X THEN DO;\n               PUT  /;\n               PUT @50 '============================'\n                 / @50 'MEMBER LIST'\n                 / @50 '============================';\n             END;\n           END;\n           SAVEPNUM = PROCNUM;\n           SAVECC = CC;\n           SAVESRC = SDSNAME;\n           SAVEDEST = DDSNAME;\n           SAVESTEP = STEPNAME;\n           RETAIN SAVEPNUM;\n           RETAIN SAVECC;\n           RETAIN SAVESRC;\n           RETAIN SAVEDEST;\n           RETAIN SAVESTEP;\n      END;\n* ASSIGN MEMBERS TO APPROPRIATE COPY STEPS;\n* BASED ON THE PROCESS NUMBER AND STEP NAME;\n      IF RECTYPE = 'MC' AND SAVECC < '00000008'X THEN DO;\n        IF (PROCNUM = SAVEPNUM) AND (STEPNAME = SAVESTEP) THEN DO;\n           IF SMEMB = '        ' THEN\n             SMEMB = DMEMB;\n           IF L = 59 THEN DO;\n             PUT @45 'Connect:Direct PDS COPY REPORT (ARS00006)';\n             PUT @45 'IBM Sterling Connect:Direct for z/OS PDS Copy Repo\nrt';\n             PUT @3 'SRC DSNAME IS ' SAVESRC;\n             PUT @3 'DEST DSNAME IS ' SAVEDEST;\n             PUT @50 'MEMBER LIST (CONT)';\n             PUT @50 '******************';\n           END;\n           PUT @50 SMEMB @62 'TO    ' DMEMB;\n        END;\n      END;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PERL": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14\\x02O\\x01\\x14\\x02O\\x12\\x14\\n~\\n~\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-01-24T00:00:00", "modifydate": "2014-01-24T12:14:00", "lines": 2686, "newlines": 2686, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "QUI": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x10\\x11\\x7f\\x01\\x13$\\x7f\\x16\\x18\\x00\\n\\x00\\x10\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-04-27T00:00:00", "modifydate": "2013-09-04T16:18:18", "lines": 10, "newlines": 16, "modlines": 0, "user": "SCNS03"}, "text": "PROC 1 NODE\n***\n*** QUIESCE LOCAL NODE OR REMOTE NODE\n***\n*** F CD,QUIESCE NODE QUIESCE THIS SPECIFIC ADJACENT NODE\n*** STOPS ANY NEW TRAFFIC, INBOUND OR OUTBOUND\n*** CURRENTLY EXECUTING PROCESSES ARE NOT\n*** AFFECTED\n***\n  MODIFY SESSIONS Q WHERE(NODE=&NODE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QUIESCE": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00'\\x01\\x10\\x11\\x7f\\x01\\x14\\x00o\\x15\\t\\x00\\x15\\x00\\x14\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2010-04-27T00:00:00", "modifydate": "2014-01-06T15:09:27", "lines": 21, "newlines": 20, "modlines": 0, "user": "SCNS03T"}, "text": "PROC 1 NODE\n***\n*** QUIESCE LOCAL NODE OR REMOTE NODE\n***\n***\n*** F CD,QUIESCE QUIESCES THE LOCAL NODE, THIS WILL\n*** STOP ANY NEW TRAFFIC INBOUND OR\n*** OUTBOUND, CURRENTLY EXECUTING PROCESSES\n*** ARE NOT AFFECTED\n***\n***\n*** F CD,QUIESCE NODE QUIESCES THIS SPECIFIC ADJACENT NODE\n*** STOPS ANY NEW TRAFFIC, INBOUND OR OUTBOUND\n*** CURRENTLY EXECUTING PROCESSES ARE NOT\n*** AFFECTED\n***\n   %IF &NODE = ,\n     MODIFY SESSIONS Q\n   %ELSE\n     MODIFY SESSIONS Q WHERE(NODE=&NODE)\n   %EIF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RES": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x13$\\x7f\\x01\\x13$\\x7f\\x16\\x14\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-09-04T00:00:00", "modifydate": "2013-09-04T16:14:38", "lines": 10, "newlines": 10, "modlines": 0, "user": "SCNS03"}, "text": "PROC 1 NODE\n***\n*** RESUME LOCAL NODE OR REMOTE NODE\n***\n***\n*** F CD,RESUME RESUME THE LOCAL NODE\n***\n*** F CD,RESUME NODE RESUME THIS SPECIFIC ADJACENT NODE\n***\n     MODIFY SESSIONS R WHERE(NODE=&NODE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RESUME": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00X\\x01\\x10\\x11\\x7f\\x01\\x10\\x11\\x7f\\x157\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-04-27T00:00:00", "modifydate": "2010-04-27T15:37:58", "lines": 14, "newlines": 14, "modlines": 0, "user": "SCNS03"}, "text": "PROC 1 NODE\n***\n*** RESUME LOCAL NODE OR REMOTE NODE\n***\n***\n*** F CD,RESUME RESUME THE LOCAL NODE\n***\n*** F CD,RESUME NODE RESUME THIS SPECIFIC ADJACENT NODE\n***\n   %IF &NODE = ,\n     MODIFY SESSIONS R\n   %ELSE\n     MODIFY SESSIONS R WHERE(NODE=&NODE)\n   %EIF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RUNJOB1": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x13&\\x0f\\x01\\x13&\\x0f\\x17\\x07\\x00q\\x00p\\x00\\x01\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-09-17T17:07:07", "lines": 113, "newlines": 112, "modlines": 1, "user": "SCNS03"}, "text": "  DATA RUNJOB;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*     ONLY WANT RUNJOB TERMINATION RECORDS;\n      IF RECTYPE = 'RJ' THEN DO;\n         INPUT  @17 STRDTE PD4.        /* RJSDATE   */\n                @21 CC $4.             /* RJSCC     */\n                @25 MSGID $8.          /* RJMSGID   */\n                @33 PROCNAME $         /* RJPROCNM  */\n                @41 PROCNUM IB4.       /* RJPROCNO  */\n                @45 STEPNAME $8.       /* RJSTEP    */\n                @69 UID $8.            /* RJUID 1-8 */\n                @77 UID56 $56.         /* RJUID 9-64 */\n                @133 MYNODE $16.       /* RJPNODE   */\n                @149 OTHRNODE $16.     /* RJSNODE   */\n                @165 THISNODE $1.      /* RJNODE    */\n                @166 SUBIND $1.        /* RJFROM    */\n                @177 JOBNUM IB4.       /* RJJOBNO   */\n                @189 DSP2DSN IB2. @;   /* RJDDSN    */\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n*        ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n*        ASSIGN NODE JOB IS SUBMITTED ON;\n         IF SUBIND  = 'P' THEN\n            SUBNODE = PNODE;\n         ELSE\n            SUBNODE = SNODE;\n         DATE = DATEJUL(STRDTE);      /* CONVERT JUL->SAS FOR MATH*/\n*        GO AFTER DATASET NAME CONTAINING JOB;\n         IF DSP2DSN \u00ac= 0 THEN DO;\n           DSP2DSN + 1;               /* FOR BYTE REL TO 1 */\n           INPUT @DSP2DSN DSNLEN IB2.\n                 DSNAME $VARYING200.DSNLEN;\n         END;\n*        INCLUDE THIS OBSERVATION IN THE DATASET BEING CREATED;\n         OUTPUT;\n      END;\n      DROP RECTYPE OTHRNODE THISNODE STRDTE SUBIND;\n      FORMAT DATE MMDDYY10.;\n      FORMAT CC $HEX8.;\n* SORT DATASET FOR PRINT;\n  PROC SORT;\n    BY SNODE UID PROCNUM;\n  DATA FINALRJ;\n    SET RUNJOB;\n    FILE FT20F001 N=PS LINESLEFT=L;\n    IF _N_ = 1 THEN DO;\n       PUT @45 'IBM Sterling Connect:Direct for z/OS RUNJOB Report';\n       PUT @50 'NODE = ' MYNODE;\n       PUT /;\n       PUT @3\n       'USERID      PROC #   PROC NAME    STEP NAME    RUNJOB INFORMATIO\nN';\n       PUT @3\n       '******      ******   *********    *********    *****************\n******************************************************************';\n       PUT /;\n    END;\n    IF L < 9 THEN DO;\n       PUT _PAGE_;\n       PUT @45 'IBM Sterling Connect:Direct for z/OS RUNJOB Report';\n       PUT @50 'NODE = ' MYNODE;\n       PUT /;\n       PUT @3\n       'USERID      PROC #   PROC NAME    STEP NAME    RUNJOB INFORMATIO\nN';\n       PUT @3\n       '******      ******   *********    *********    *****************\n******************************************************************';\n       PUT /;\n    END;\n* WRITE TO OUTPUT;\n    PUT @3 UID @15 PROCNUM @24 PROCNAME @37 STEPNAME\n        @50 DATE @61 'PNODE = ' PNODE @87 'SNODE = ' SNODE;\n    PUT @50 'COMPLETION CODE = ' CC @87 'MSG ID = ' MSGID;\n    INFILE DMMSGFIL VSAM KEY=MSGID;\n    INPUT @23 SHTXTLEN IB2. @;\n    SHTXTLEN = SHTXTLEN - 2;\n    INPUT SHTEXT $VARYING200.SHTXTLEN;\n    UPSHTEXT = UPCASE(SHTEXT);\n    PUT @50 UPSHTEXT;\n    PUT @50 '===========================================================\n========================';\n    IF SUBNODE = MYNODE THEN\n      PUT @50 'DSNAME ==> ' DSNAME;\n    IF CC = '00000000'X THEN DO;\n      PUT @50 'JOB #  ==> ' JOBNUM;\n      PUT @50 'JOB SUBMITTED ON ' SUBNODE;\n      END;\n    ELSE\n      PUT @50 'INTENDED NODE FOR JOB SUBMISSION IS ' SUBNODE;\n   PUT @3 '-------------------------------------------------------------\n---------------------------------------------------------------------';\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RUNTASK1": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x13&\\x0f\\x01\\x13&\\x0f\\x17\\x08\\x00g\\x00e\\x00\\x02\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-09-17T17:08:07", "lines": 103, "newlines": 101, "modlines": 2, "user": "SCNS03"}, "text": "  DATA RUNTASK;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*     ONLY WANT RUN TASK TERMINATION RECORDS;\n      IF RECTYPE = 'RT' THEN DO;           /* RTRTYPE    */\n         INPUT  @17 STRDTE PD4.            /* RTSDATE    */\n                @21 CC $4.                 /* RTSCC      */\n                @25 MSGID $8.              /* RTMSGID    */\n                @33 PROCNAME $             /* RTPROCNM   */\n                @41 PROCNUM IB4.           /* RTPROCNO   */\n                @45 STEPNAME $8.           /* RTSTEP     */\n                @69 UID $8.                /* RTUID 1-8  */\n                @77 UID56 $56              /* RTUID 9-64 */\n                @133 MYNODE $16.           /* RTPNODE    */\n                @149 OTHRNODE $16.         /* RTSNODE    */\n                @165 THISNODE $1.          /* RTNODE     */\n                @166 SUBIND $1.            /* RTFROM     */\n                @167 PGMNAME $8.;          /* RTMODNM    */\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n*        ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n         IF SUBIND  = 'P' THEN\n            SUBNODE = PNODE;\n         ELSE\n            SUBNODE = SNODE;\n         DATE = DATEJUL(STRDTE);       /* CONVERT JULDATE TO SAS    */\n*        DROP ALL UNNECESSERY VARIABLES;\n         DROP RECTYPE OTHRNODE THISNODE STRDTE\n              SUBIND ;\n*        INCLUDE THIS OBSERVATION IN SAS DATASET BEING CREATED;\n         OUTPUT;\n      END;\n      FORMAT DATE MMDDYY10.;\n      FORMAT CC $HEX8.;\n  PROC SORT DATA=RUNTASK;\n    BY SNODE UID PROCNUM;\n  DATA FINALRT;\n    SET RUNTASK;\n    FILE FT20F001 N=PS LINESLEFT=L;\n    IF _N_ = 1 THEN DO;\n       PUT @45 'IBM Sterling Connect:Direct for z/OS RUNTASK Report';\n       PUT @50 'NODE = ' MYNODE;\n       PUT /;\n       PUT @3\n       'USERID      PROC #   PROC NAME    STEP NAME    RUNTASK INFORMATI\nON';\n       PUT @3\n       '******      ******   *********    *********    *****************\n******************************************************************';\n       PUT /;\n    END;\n    IF L < 8 THEN DO;\n       PUT _PAGE_;\n       PUT @45 'IBM Sterling Connect:Direct for z/OS RUNTASK Report';\n       PUT @50 'NODE = ' MYNODE;\n       PUT /;\n       PUT @3\n       'USERID      PROC #   PROC NAME    STEP NAME    RUNTASK INFORMATI\nON';\n       PUT @3\n       '******      ******   *********    *********    *****************\n******************************************************************';\n       PUT /;\n    END;\n* WRITE TO OUTPUT;\n    PUT @3 UID @15 PROCNUM @24 PROCNAME @37 STEPNAME\n        @50 DATE @61 'PNODE = ' PNODE @87 'SNODE = ' SNODE;\n    PUT @50 'COMPLETION CODE = ' CC @87 'MSG ID = ' MSGID;\n    INFILE DMMSGFIL VSAM KEY=MSGID;\n    INPUT @23 SHTXTLEN IB2. @;\n    SHTXTLEN = SHTXTLEN - 2;\n    INPUT SHTEXT $VARYING200.SHTXTLEN;\n    UPSHTEXT = UPCASE(SHTEXT);\n    PUT @50 UPSHTEXT;\n    PUT @50 '===========================================================\n========================';\n    PUT @50 'PROGRAM NAME  ==> ' PGMNAME;\n    IF CC = '00000000'X THEN\n      PUT @50 'PROGRAM ATTACHED ON ' SUBNODE;\n    ELSE\n      PUT @50 'INTENDED NODE FOR PROGRAM ATTACHMENT IS ' SUBNODE;\n   PUT /@3 '------------------------------------------------------------\n----------------------------------------------------------------------';\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SNDMAIL6": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00)\\x01\\x05\\x10\\x8f\\x01\\x131/\\x16\\x07\\x00G\\x00G\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2005-04-18T00:00:00", "modifydate": "2013-11-08T16:07:29", "lines": 71, "newlines": 71, "modlines": 0, "user": "SCNS03T"}, "text": "/*********************************************************************/\n/*  SNDMAIL6: This clist is called from the automation table to send */\n/*            the message being automated to an EMAIL ID.            */\n/*                                                                   */\n/*            The email ID must be passed to this clist as the first */\n/*            argument.                                              */\n/*                                                                   */\n/*  * Sample automation table statements                             */\n/*                                                                   */\n/*  IF MSGID='xxxxxxx' THEN                                          */\n/*     EXEC(CMD('SNDMAIL6 yyyyyyyy@yyyyyyyy.yyy'))                   */\n/*                                                                   */\n/*  Where xxxxxxx is the message to automate and the                 */\n/*  yyyyyyyy.yyyyyyyy.yyy is the email ID.                           */\n/*********************************************************************/\n Trace Off\n parse arg email_id job_id\n if job_id = '' then job_id = 'Netview'\n timezone = subsym('&UTZ')\n\n wvar.1=\"helo SMTP\"\n wvar.2=\"mail from:<\"opid()\"@\"cursys()\">\"\n wvar.3=\"rcpt to:<\"email_id\">\"\n wvar.4=\"data\"\n wvar.5=\"Date:    \"date('n')\" \"time()\" \"timezone\n wvar.6=\"From:    \"opid()\" - Netview Domain \"domain()\" - \"cursys()\n wvar.7=\"To:      \"email_id\n wvar.8=\"Subject: Automation Alert from \"job_id\" at \"time()\n wvar.9=\"This following message has been sent to you from the Netview\"\n wvar.10=\"automation table\"\n wvar.11=\" \"\n wvar.0=11\n\n/* say 'wvar.0= 'wvar.0 */\n\n/* Append automation message into the email message                  */\n'pipe safe * | stem wvar. append'\n\n len = length(wvar.12)\n /*say 'Length of wvar.12= 'len */\n\n If length(wvar.12) > 80 Then\n   Do\n     wvar.13  = substr(wvar.12,81,80)\n     wvar.0=wvar.0 + 1\n   End\n\n If length(wvar.12) > 160 Then\n   Do\n     wvar.14  = substr(wvar.12,161,80)\n     wvar.0=wvar.0 + 1\n   End\n\n/* Terminate message body with a period                              */\n'pipe lit /./ | stem wvar. append'\n\n/* Appenmd SMTP QUIT command to stem                                 */\n'pipe lit /QUIT/ | stem wvar. append'\n\n /* say 'wvar.0= 'wvar.0' (2)' */\n\n/* Create a safe from the stem variable                              */\n'pipe stem wvar. | safe SMTPSAFE'\n\n/* Call SENDMAIL to send the Email                                   */\n'sendmail SMTPSAFE RTRNSAFE'\n\n/* Check return code, if not zero display message in RTRNSAFE        */\nif rc <> 0\n   then\n      'pipe safe RTRNSAFE | collect | console'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STATJOB4": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x000\\x01\\x05\\x01\\x8f\\x01\\x133\\x9f\\x15F\\x00\\x1b\\x00\\x1c\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2005-01-18T00:00:00", "modifydate": "2013-12-05T15:46:30", "lines": 27, "newlines": 28, "modlines": 0, "user": "SCNS03T"}, "text": "//jobname  JOB (9999,9999),'DGASSTAT-Node4',CLASS=A,MSGCLASS=X,\n//            NOTIFY=userid\n//* ---------------------------------------------------------------- *\n//*        LISTCATP step to list VSAM dataset statistics             *\n//* ---------------------------------------------------------------- *\n//*\n//LISTPLUS EXEC PGM=LSTCAT\n//PRINT    DD SYSOUT=I\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSDBOUT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SORTWORK DD UNIT=SYSDA,SPACE=(CYL,(5,5))\n//CARD     DD *\nP                                   NN\n//IDCAMSIN DD *\n  LISTCAT ALL ENTRY(&DSNAME)\n/*\n//* ---------------------------------------------------------------- *\n//*        SCCSTAT  step to produce a report on the statistics file  *\n//* ---------------------------------------------------------------- *\n//*\n//STATSTAT EXEC PGM=DGASSTAT\n//SYSOUT    DD SYSOUT=I\n//ESDS      DD DISP=SHR,DSN=&DSNAME\n/*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STATPRC4": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00S\\x01\\x133\\x9f\\x01\\x133\\x9f\\x161\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-12-05T00:00:00", "modifydate": "2013-12-05T16:31:53", "lines": 9, "newlines": 9, "modlines": 0, "user": "SCNS03T"}, "text": "STATPRC4 PROCESS PNODE=%PNODE                                     -\n                 SNODE=your_pnodeid                               -\n                 CLASS=1                                          -\n                 PRTY=15                                          -\n                 REQUEUE=YES                                      -\n                 &EDSN=\n         RUN TASK (PGM=DGADTSUB,                                  -\n         PARM=(\"DISP=SHR,DSN=SYS2.NDM.CNTL(STATJOB4)\",            -\n                      \"DSNAME &EDSN\"))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBMIT1": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x13&\\x0f\\x01\\x13&\\x0f\\x17\\x13\\x00p\\x00o\\x00\\x01\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-09-17T17:13:22", "lines": 112, "newlines": 111, "modlines": 1, "user": "SCNS03"}, "text": "  DATA SUBMIT;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n* ONLY WANT SUBMIT W/IN PROC TERMINATION RECORDS;\n      IF RECTYPE = 'SW' THEN DO;        /* PSSRTYPE    */\n         INPUT  @17 STRDTE PD4.         /* PSSSDATE    */\n                @21 CC $4.              /* PSSSCC      */\n                @25 MSGID $8.           /* PSSMSGID    */\n                @33 PROCNAME $8.        /* PSSPRCNM      1363862*/\n                @41 PROCNUM IB4.        /* PSSPRCNO    */\n                @45 STEPNAME $8.        /* PSSSTEP     */\n                @69 UID $8.             /* PSSUID 1-8  */\n                @77 UID56 $56.          /* PSSUID 9-64 */\n                @133 MYNODE $16.        /* PSSPNODE    */\n                @149 OTHRNODE $16.      /* PSSSNODE    */\n                @165 THISNODE $1.       /* PSSNODE     */\n                @166 SUBIND $1. @;      /* PSSFROM     */\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n*        ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n*        ASSIGN NODE UPON WHICH PROCESS IS SUBMITTED;\n         IF SUBIND = 'P' THEN\n            SUBNODE = PNODE;\n         ELSE\n            SUBNODE = SNODE;\n         DATE = DATEJUL(STRDTE);     /* CONVERT JULDATE TO SAS    */\n*        GO AFTER DATASET NAME CONTAINING PROCESS;\n         INPUT @323 DSP2DSN IB2. @;   /* PSSDSN#  */\n         IF DSP2DSN \u00ac= 0 THEN DO;\n           DSP2DSN + 1;\n           INPUT @DSP2DSN DSNLEN IB2.\n                 DSNAME $VARYING200.DSNLEN;\n         END;\n*        GET RID OF UNNECESSARY VARIABLES;\n         DROP RECTYPE OTHRNODE THISNODE STRDTE SUBIND;\n*        ADD OBSERVATION TO SAS DATASET BEING CREATED;\n         OUTPUT;\n      END;\n      FORMAT DATE MMDDYY10.;\n      FORMAT CC $HEX8.;\n  PROC SORT;\n    BY SNODE UID PROCNUM;\n  DATA FINALSB;\n    SET SUBMIT;\n    FILE FT20F001 N=PS LINESLEFT=L;\n    IF _N_ = 1 THEN DO;\n       PUT @45 'IBM Sterling Connect:Direct for z/OS Submit within a Pro\ncess Report';\n       PUT @50 'NODE = ' MYNODE;\n       PUT /;\n       PUT @3 'USERID      PROC #   PROC NAME    STEP NAME    SUBMIT INF\nORMATION';\n       PUT @3 '******      ******   *********    *********    **********\n************************************************************************\n*';\n       PUT /;\n    END;\n    IF L < 8 THEN DO;\n       PUT _PAGE_;\n       PUT @45 'IBM Sterling Connect:Direct for z/OS Submit within a Pro\ncess Report';\n       PUT @50 'NODE = ' MYNODE;\n       PUT /;\n       PUT @3 'USERID      PROC #   PROC NAME    STEP NAME    SUBMIT INF\nORMATION';\n       PUT @3 '******      ******   *********    *********    **********\n************************************************************************\n*';\n       PUT /;\n    END;\n* WRITE TO OUTPUT;\n    PUT @3 UID @15 PROCNUM @24 PROCNAME @37 STEPNAME\n        @50 DATE @61 'PNODE = ' PNODE @87 'SNODE = ' SNODE;\n    PUT @50 'COMPLETION CODE = ' CC @87 'MSG ID = ' MSGID;\n    INFILE DMMSGFIL VSAM KEY=MSGID;\n    INPUT @23 SHTXTLEN IB2. @;\n    SHTXTLEN = SHTXTLEN - 2;\n    INPUT SHTEXT $VARYING200.SHTXTLEN;\n    UPSHTEXT = UPCASE(SHTEXT);\n    PUT @50 UPSHTEXT;\n    PUT @50 '===========================================================\n========================';\n    IF DSNAME = ' ' THEN\n      PUT @50 'DSNAME NOT AVAILABLE ';\n    ELSE\n      PUT @50 'DSNAME ==> ' DSNAME;\n    IF CC = '00000000'X THEN\n      PUT @50 'PROCESS SUBMITTED ON ' SUBNODE;\n    ELSE\n      PUT @50 'INTENDED NODE FOR PROCESS SUBMISSION IS ' SUBNODE;\n   PUT /@3 '------------------------------------------------------------\n----------------------------------------------------------------------';\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SUMMACTC": {"ttr": 2832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00$\\x01\\x05\"O\\x01\\x135?\\x115\\x00\\x90\\x00\\xd1\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2005-08-12T00:00:00", "modifydate": "2013-12-19T11:35:24", "lines": 144, "newlines": 209, "modlines": 0, "user": "SCNS03"}, "text": "  DATA ACTIVITY;\n    TITLE;\n    INFILE NDMX0001 RECFM=VB;                         /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*   ONLY WANT 'Copy TERMINATION' STATISTICS RECORDS;\n      IF RECTYPE = 'CT' THEN DO;\n         INPUT  @5 ENDHH PK1.        /* XXTIME BROKEN TO 4 PKDLEN 1*/\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.            /* XXDATE    */\n                @13 STRTHH PK1.      /* XXSTIME BROKEN TO 4 PKDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.\n                @21 CC $4.                /* XXSCC     */\n                @25 MSGID $8.             /* XXMSGID   */\n                @33 PROCNAME $8.          /* XXPROCNM    1363862*/\n                @41 PROCNUM IB4.          /* XXPROCNO  */\n                @45 STEPNAME $8.          /* XXSTEP    */\n                @69 UID $8.               /* XXUID       1363862 */\n                @77 MYNODE $16.           /* XXPNODE   */\n                @93 OTHRNODE $16.         /* XXSNODE   */\n                @109 THISNODE $1.         /* XXNODE    */\n                @110 SENDIND $1.\n                @111 CTRANS IB1.\n                @112 COPYTYPE $CHAR1.\n                @113 RUSZ   IB4.\n                @129 INBYTES IB8.\n                @137 INRECS IB4.\n                @141 INBLKS IB4.\n                @145 SNDBYTS IB8.\n                @153 OUTBYTES IB8.\n                @161 OUTRECS IB4.\n                @165 OUTBLKS IB4.\n                @169 RCVBYTS IB8. @;\n*        ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n*        ASSIGN FUNCTION TYPE FOR OUTPUT;\n         IF RECTYPE = 'RT' THEN\n            FUNCTION = 'RUNT';\n         IF RECTYPE = 'CT' THEN\n            FUNCTION = 'COPY';\n         IF RECTYPE = 'RJ' THEN\n            FUNCTION = 'RUNJ';\n         IF RECTYPE = 'SW' THEN\n            FUNCTION = 'SUBM';\n         IF CC = '00000000'X THEN\n            FLAG = '        ';\n         ELSE\n            FLAG = MSGID;\n*           FLAG = '***';\n         CD = SUBSTR(CC,2,3);\n         IF FUNCTION = 'COPY' THEN CP = 'NO ';\n            CE = 0;\n            CS = 0;\n            CN = 0;\n         IF CTRANS = '20' THEN DO;\n            CP = 'EXT';\n            CE = CE + 1;\n         END;\n         IF CTRANS = '16' THEN DO;\n            CP = 'CMP';\n            CS = CS + 1;\n         END;\n         IF CTRANS = '4' THEN DO;\n            CP = 'EXT';\n            CE = CE + 1;\n         END;\n         IF CP = 'NO' THEN CN = CN + 1;\n         IF CTRANS = '0' THEN CP = 'NO ';\n         DATE = DATEJUL(STRDTE);   /* CONVERT JULDTES->SAS FOR MATH*/\n         ENDDTE = DATEJUL(ENDDTE);\n*        'HMS' RETURNS SAS TIME VALUE FOR MATH;\n         STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n         ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n         TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n*                  {TRANS DAYS IN SECONDS  + TIME ENDED} - TIME STARTED;\n*        GET RID OF UNNECESSERY VARIABLES;\n         DROP ENDHH ENDMM ENDSS ENDTT ENDDTE STRTHH STRTMM STRTSS STRTTT\n              STRDTE OTHRNODE THISNODE RECTYPE;\n*             STARTIME ENDTIME\n*        ADD OBSERVATION TO SAS DATA SET BEING CREATED;\n         OUTPUT;\n      END;\n*     FORMAT DATE AND TIME FOR OUTPUT;\n      FORMAT DATE MMDDYY8.;\n      FORMAT STARTIME TIME9.0;\n      FORMAT ENDTIME TIME9.0;\n      FORMAT TRANTIME TIME11.2;\n*     FORMAT CC $HEX8.;\n      FORMAT CD $HEX6.;\n      FORMAT SNDBYTS COMMA14.;\n* THIS DATA STEP SETS UP TO PUT NODENAME IN TITLE;\n  DATA _NULL_;\n    SET ACTIVITY;\n    CALL SYMPUT('NODE',MYNODE);\n    RUN;\n* PRINTS TITLES;\n  DATA _NULL_;\n    TITLE 'IBM Sterling Connect:Direct for z/OS Activity Report';\n    TITLE2 \"NODE = &NODE\";\n* SORT DATASET FOR PRINT;\n  PROC SORT;\n    BY SNODE SNDBYTS PROCNUM;\n* ROUTE OUTPUT TO FT20F001 DD;\n  PROC PRINTTO NEW UNIT=20;\n* PRINT DATASET BY SNODE AND FOLLOWING ORDER ACROSS PAGE;\n/*  1  */\nPROC SUMMARY   DATA = ACTIVITY MISSING  NWAY;\n     CLASS SNODE;\n     VAR   SNDBYTS CE CS CN;\n     OUTPUT OUT=BYTSUM(DROP=_TYPE_) SUM=TOTBYT TOTCE TOTCS TOTCN MEAN = AVGBYT;\nPROC PRINT DATA = BYTSUM SPLIT = '*';\n     TITLE1 'C:D COMPRESSION SUMMARY REPORT ';\n     ID  SNODE;\n     SUM TOTBYT TOTCE TOTCS TOTCN ;\nLABEL _FREQ_  = 'NUMB. OF*COPY STEPS'\n      TOTCE   = 'CMP EXT*COPIES'\n      TOTCS   = 'CMP STD*COPIES'\n      TOTCN   = 'CMP  NO*COPIES'\n      AVGBYT  = 'AVERAGE*BYTES '\n      TOTBYT  = 'TOTAL*BYTES';\nFORMAT AVGBYT COMMA16.2\n       TOTBYT COMMA16.0;\n  PROC PRINTTO;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUMMARY1": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x13&\\x0f\\x01\\x13&\\x0f\\x17\\x14\\x02B\\x02A\\x00\\x01\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-09-17T00:00:00", "modifydate": "2013-09-17T17:14:55", "lines": 578, "newlines": 577, "modlines": 1, "user": "SCNS03"}, "text": "  DATA SUMMARY;\n   RPTNODE = SYMGET('SYSPARM');                       /* UserMod */\n    CALL SYMPUT('TOT',\"0\");                           /* 1363862 */\n    INFILE NDMX0001 END=FINAL RECFM=VB;               /* 1363862 */\n    INPUT RECTYPE $ 3-4 @;\n* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 IBM(R) Sterling Connect:Direct(R) for z/OS(R)\n*\n* (C) Copyright IBM Corp. 1982, 2011 All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\n*     ONLY WANT FUNCTION TERMINATION RECORDS;\n      IF RECTYPE = 'CT' OR RECTYPE = 'RT' OR\n         RECTYPE = 'RJ' OR RECTYPE = 'SW' THEN DO;\n      IF RECTYPE = 'RJ' OR RECTYPE = 'RT' OR RECTYPE = 'SW' THEN\n         INPUT  @5 ENDHH PK1.    /* XXTIME BROKEN TO 4 PKEDLEN 1 */\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.       /* XXDATE    */\n                @13 STRTHH PK1.  /* XXSTIME BROKEN TO 4 PKEDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.      /* XXSDATE   */\n                @21 CC IB4.          /* XXSCC     */\n                @133 MYNODE $16.     /* XXXPNODE  */\n                @149 OTHRNODE $16.   /* XXXSNODE  */\n                @165 THISNODE $1.    /* XXXNODE   */\n                @166 SUBIND $1. @;   /* XXXFROM   */\n         IF RECTYPE = 'CT' THEN\n         INPUT  @5 ENDHH PK1.    /* XXTIME BROKEN TO 4 PKEDLEN 1 */\n                @6 ENDMM PK1.\n                @7 ENDSS PK1.\n                @8 ENDTT PK1.\n                @9 ENDDTE PD4.       /* XXDATE    */\n                @13 STRTHH PK1.  /* XXSTIME BROKEN TO 4 PKEDLEN 1 */\n                @14 STRTMM PK1.\n                @15 STRTSS PK1.\n                @16 STRTTT PK1.\n                @17 STRDTE PD4.      /* XXSDATE   */\n                @21 CC IB4.          /* XXSCC     */\n                @77 MYNODE $16.      /* XXXPNODE  */\n                @93 OTHRNODE $16.    /* XXXSNODE  */\n                @109 THISNODE $1.    /* XXXNODE   */\n                @110 SUBIND $1.      /* XXXFROM   */\n                @129 INBYTES IB8.    /* CTINBYTE   */\n                @145 SNDBYTS IB8.    /* CTSBYTES   */\n                @153 OUTBYTES IB8.   /* CTOTBYTE   */\n                @169 RCVBYTS IB8.@;  /* CTRBYTES   */\n*        ONLY WANT RECORDS FOR A SPECIFIC NODE NAME;  /* UserMod */\n      IF (OTHRNODE \u00ac= RPTNODE) THEN DELETE;           /* UserMod */\n* ASSIGN PNODE AND SNODE;\n         IF THISNODE = 'P' THEN DO;\n            PNODE = MYNODE;\n            SNODE = OTHRNODE;\n            END;\n         ELSE DO;\n            PNODE = OTHRNODE;\n            SNODE = MYNODE;\n            END;\n         DATE = DATEJUL(STRDTE);       /* CONVERT JUL->SAS FOR MATH */\n         STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n         OUTPUT;\n     END;\n* SORT THE DATASET BY SNODE AND CHRONOLOGICALLY WITHIN SNODE;\n  PROC SORT;\n    BY SNODE DATE STARTIME;\n* SET UP MACRO NAMES FOR \"SUB SAS FILES\" TO BE CREATED;\n  DATA PARTFILE;\n    SET SUMMARY END=EOF;\n      BY SNODE;\n      IF FIRST.SNODE THEN DO;\n        COUNT + 1;\n        CALL SYMPUT('DEPT'||LEFT(COUNT),COUNT);\n      END;\n      IF EOF THEN DO;\n        COUNT + 1;\n        CALL SYMPUT('TOT',COUNT);\n        CALL SYMPUT('DEPT'||LEFT(COUNT),'LAST');      /* 1363862 */\n      END;\n     RUN;\n* THIS MACRO BREAKS UP THE ORIGINAL SAS DATASET INTO \"N\" SUB FILES;\n* WHERE \"N\" IS THE NUMBER OF UNIQUE SNODES IN THE DATASET;\n* THIS RESULTS IN \"N\" SAS FILES, EACH FILE IN TIME SEQUENCE ORDER AND;\n* SHARING A COMMON SNODE;\n    %MACRO SUBSETS;\n    DATA\n    %DO NUM=1 %TO &TOT;\n      DEPT&NUM\n    %END;;\n    SET SUMMARY;\n      BY SNODE;\n       IF FIRST.SNODE THEN\n        COUNT + 1;\n       %DO X=1 %TO &TOT;\n         IF COUNT = &X THEN\n          OUTPUT DEPT&X;\n       %END;\n    %MEND SUBSETS;\n* THIS MACRO PROCESSES EACH SAS DATASET BROKEN BY SNODE ONE AT A TIME;\n    %MACRO SUMIT;\n      %DO X=1 %TO &TOT;\n        DATA SUMIT;\n          SET DEPT&X END=FINAL;\n          TOTRECS + 1;\n          ENDDTE = DATEJUL(ENDDTE);\n*         HMS RETURNS SAS TIME VALUES FROM HHMMSS;\n          ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n          TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n*                   {TRAN DAYS IN SECONDS}  + {TRAN TIMES IN SECONDS};\n*         RETAIN TRANSITION TIME W/EACH OBSERVATION FOR TOTAL TRANTIM;\n          TOTRANTM + TRANTIME;\n          IF RECTYPE = 'CT' THEN DO;\n*            RETAIN TRANTIME W/EACH COPY FOR TOTAL COPY TIME;\n             COPYTIME + TRANTIME;\n             TOTCOPS + 1;               /* COUNT COPIES */\n             IF CC \u00ac= 0 THEN DO;\n               NZCOPS + 1;              /* COUNT FAILED COPIES */\n               NZRECS + 1;              /* COUNT FAILED FUNCTIONS */\n             END;\n*            RETAIN BYTES RECORDS AND BLOCKS READ AND WRITTEN WITH EACH;\n*            COPY FOR TOTALS;\n*            SUBIND = 'P' IMPLIES PNODE IS SENDING;\n*            SUBIND = 'S' IMPLIES SNODE IS SENDING;\n             IF SUBIND = 'P' THEN\n               IF MYNODE = PNODE THEN DO;\n                 TINBYTES + INBYTES;\n                 TSNDBYTS + SNDBYTS;\n                 END;\n               ELSE DO;\n                 TOUTBYTS + OUTBYTES;\n                 TRCVBYTS + RCVBYTS;\n               END;\n             ELSE IF SUBIND = 'S' THEN\n               IF MYNODE = SNODE THEN DO;\n                 TINBYTES + INBYTES;\n                 TSNDBYTS + SNDBYTS;\n                 END;\n               ELSE DO;\n                 TOUTBYTS + OUTBYTES;\n                 TRCVBYTS + RCVBYTS;\n                 END;\n          END;\n          IF RECTYPE = 'RT' THEN DO;\n             TOTRTS + 1;\n             IF CC \u00ac= 0 THEN DO;\n               NZRTS + 1;              /* COUNT FAILED RUNTASKS */\n               NZRECS + 1;             /* COUNT FAILED FUNCTIONS*/\n               END;\n             ELSE DO;                  /* IF RUNTASK DIDN'T FAIL */\n*              COUNT AND RETAIN RUNTASKS ATTACHED ON THIS NODE;\n               IF (SUBIND = 'P' AND PNODE = MYNODE) OR\n                  (SUBIND = 'S' AND SNODE=MYNODE) THEN\n                   RTSONMY + 1;\n               END;\n          END;\n          IF RECTYPE = 'RJ' THEN DO;\n             TOTRJS + 1;               /* COUNT RUNJOBS         */\n             IF CC \u00ac= 0 THEN DO;\n               NZRJS + 1;              /* COUNT FAILED RUNJOBS  */\n               NZRECS + 1;             /* COUNT FAILED FUNCTIONS*/\n               END;\n             ELSE DO;                  /* IF RUNJOB DIDN'T FAIL */\n*              COUNT AND RETAIN RUNJOBS SUBMITTED ON THIS NODE;\n               IF (SUBIND = 'P' AND PNODE = MYNODE) OR\n                  (SUBIND = 'S' AND SNODE=MYNODE) THEN\n                   RJSONMY + 1;\n             END;\n          END;\n          IF RECTYPE = 'SW' THEN DO;\n             TOTSUBS + 1;              /* COUNT SUBMITS         */\n             IF CC \u00ac= 0 THEN DO;\n               NZSUBS + 1;             /* COUNT FAILED SUBMITS  */\n               NZRECS + 1;             /* COUNT FAILED FUNCTIONS*/\n               END;\n             ELSE DO;                  /* IF SUBMIT DIDN'T FAIL */\n*              COUNT AND RETAIN SUBMITS ON THIS NODE;\n               IF (SUBIND = 'P' AND PNODE = MYNODE) OR\n                  (SUBIND = 'S' AND SNODE=MYNODE) THEN\n                  SBSONMY + 1;\n               END;\n          END;\n*        INCLUDE THESE OBSERVATIONS IN THE SAS DATASET BEING CREATED;\n          OUTPUT;\n* DETERMINE WHEN THE FIRST FUNCTION AND LAST FUNCTION HAPPENED;\n* TO PRINT IN THE SUMMARY REPORT;\n        DATA FUNCSS;\n          SET SUMIT END=FINAL;\n          IF _N_ = 1 THEN DO;\n            FUNBEGT = STARTIME;\n            FUNBEGD = DATE;\n            RETAIN FUNBEGT FUNBEGD;\n            FORMAT FUNBEGT TIME13.2;\n            FORMAT FUNBEGD MMDDYY10.;\n          END;\n          IF FINAL THEN DO;\n             FUNCFINT = ENDTIME;\n             FUNCFIND = ENDDTE;\n             FORMAT FUNCFINT TIME13.2;\n             FORMAT FUNCFIND MMDDYY10.;\n             OUTPUT;\n          END;\n*      DETERMINE WHEN THE FIRST AND LAST COPY HAPPENED FOR THRUPUT CALC;\n        DATA COPYRECS;\n          SET SUMIT;\n            IF RECTYPE = 'CT' THEN\n              OUTPUT;\n        DATA STRTSTOP;\n          SET COPYRECS END=FINAL;\n          IF _N_ = 1 THEN DO;\n             BEGINT = STARTIME;\n             BEGIND = DATE;\n             RETAIN BEGINT BEGIND;\n             FORMAT BEGINT TIME13.2;\n             FORMAT BEGIND MMDDYY10.;\n           END;\n           IF FINAL THEN DO;\n             FINISHT = ENDTIME;\n             FINISHD = ENDDTE;\n*    DURATION IS BASED OFF OF TIME FROM BEGINNING OF FIRST COPY IN FILE;\n*       AND THE END OF THE LAST COPY IN THE FILE;\n             DURATION = 86400 * (FINISHD - BEGIND) + FINISHT - BEGINT;\n             FORMAT FINISHT TIME13.2;\n             FORMAT FINISHD MMDDYY10.;\n             OUTPUT;\n           END;\n*  THIS MERGE STATEMENT WILL MERGE TWO SAS DATASET WITH ONE OBSERVATION;\n* EACH. FUNCSS CONTAINS ALL THE CUMULATIVE TOTALS FROM THE SUMMARY DATA;\n*      STEP AS WELL AS TIMES WHEN THE FIRST AND LAST FUNCTIONS OCCURRED;\n*  BY PLACING FUNCSS ON THE RIGHT, WE WONT LOSE THE CORRECT CUMULATIVE;\n*       TOTALS IN THE MERGE;\n        DATA DTETIMES;\n           MERGE STRTSTOP FUNCSS;\n        DATA TOTALS;\n          TITLE;\n          FILE FT20F001;\n          SET DTETIMES END=FINAL;\n*         ANY MORE OBSERVATIONS?;\n          IF FINAL THEN DO;\n*           FIGURE PERCENTAGES;\n            IF TOTRECS = 0 THEN DO;\n              PERCCOP = 0;\n              PERCRJS = 0;\n              PERCRTS = 0;\n              PERCSBS = 0;\n              AVGFUNTM = 0;\n              END;\n            ELSE DO;\n              PERCCOP = (TOTCOPS / TOTRECS) * 100;\n              PERCCOP = ROUND(PERCCOP,.1);\n              PERCRJS = (TOTRJS / TOTRECS) * 100;\n              PERCRJS = ROUND(PERCRJS,.1);\n              PERCRTS = (TOTRTS / TOTRECS) * 100;\n              PERCRTS = ROUND(PERCRTS,.1);\n              PERCSBS = (TOTSUBS / TOTRECS) * 100;\n              PERCSBS = ROUND(PERCSBS,.1);\n              AVGFUNTM = (TOTRANTM / TOTRECS);\n            END;\n            IF TOTCOPS = 0 THEN\n              AVGCOPTM = 0;\n            ELSE\n              AVGCOPTM = (COPYTIME / TOTCOPS);\n            IF DURATION = 0 THEN DO;\n              THRUPUTS = 0;\n              THRUPUTR = 0;\n              END;\n            ELSE DO;\n              THRUPUTS = (TSNDBYTS / DURATION);\n              THRUPUTS = ROUND(THRUPUTS,.001);\n              THRUPUTR = (TRCVBYTS / DURATION);\n              THRUPUTR = ROUND(THRUPUTR,.001);\n            END;\n*           WRITE TO OUTPUT;\n            FORMAT DURATION TIME13.2;\n            PUT @45 ' IBM Sterling Connect:Direct for z/OS  Summary Repo\nrt';\n            PUT @62 'NODE =  ' MYNODE;\n            PUT / @3 'SNODE = ' SNODE;\n            PUT // @3 'FIRST FUNCTION BEGAN EXECUTING ON ' @40 FUNBEGD '\nAT ' FUNBEGT;\n            PUT @3 'LAST FUNCTION FINISHED EXECUTING ON '  @40 FUNCFIND\n'AT ' FUNCFINT;\n            PUT ///;\n      PUT @3 TOTRECS ' PROCESS STEPS WERE COMPLETED FOR THIS TIME PERIOD\n.';\n      PUT /// @6 TOTCOPS @12 'TOTAL COPY STEPS OR ' PERCCOP @41 '% OF TO\nTAL STEPS RUN WERE COPIES';\n      PUT /// @6 TOTRJS @12 'TOTAL RUNJOB STEPS OR ' PERCRJS @41 '% OF T\nOTAL STEPS RUN WERE RUNJOBS';\n            PUT / @12 RJSONMY @18 'RUNJOBS WERE SUBMITTED ON ' MYNODE;\n       PUT /// @6 TOTRTS @12 'TOTAL RUNTASK STEPS OR ' PERCRTS @41 '% OF\n TOTAL STEPS RUN WERE RUNTASKS';\n            PUT / @12 RTSONMY @18 'RUNTASKS WERE ATTACHED ON ' MYNODE;\n       PUT /// @6 TOTSUBS @12 'TOTAL SUBMIT STEPS OR ' PERCSBS @41 '% OF\n TOTAL STEPS RUN WERE SUBMITS';\n        PUT / @12 SBSONMY @18 'SUBMITS (WITHIN A PROCESS) ON ' MYNODE;\n            SUCRECS = TOTRECS - NZRECS;\n            PERCNZS = (NZRECS / TOTRECS) * 100;\n            PERCNZS = ROUND(PERCNZS,.1);\n            PERSUCS = 100 - PERCNZS;\n     PUT //// @6 SUCRECS @12 'SUCCESSFUL STEPS OR ' PERSUCS @41 '% OF TO\nTAL STEPS RUN COMPLETED WITH A ZERO RETURN CODE';\n      PUT / @6 NZRECS @12 'UNSUCCESSFUL STEPS OR ' PERCNZS @41 '% OF TOT\nAL STEPS RUN COMPLETED WITH A NON-ZERO RETURN CODE';\n            PUT _PAGE_;\n            PUT @45 ' IBM Sterling Connect:Direct for z/OS  Summary Repo\nrt';\n            PUT @62 'NODE = ' MYNODE;\n            PUT / @3 'SNODE = ' SNODE;\n            PUT ///;\n            FORMAT TINBYTES COMMA32.;\n            FORMAT TSNDBYTS COMMA32.;\n            FORMAT TOUTBYTS COMMA32.;\n            FORMAT TRCVBYTS COMMA32.;\n            PUT @3 TINBYTES @45 'TOTAL BYTES WERE READ ';\n            PUT / @3 TSNDBYTS @45 'TOTAL BYTES WERE SENT';\n            PUT / @3 TOUTBYTS @45 'TOTAL BYTES WERE WRITTEN';\n            PUT / @3 TRCVBYTS @45 'TOTAL BYTES WERE RECEIVED';\n     PUT //// @3 TOTRANTM @15 'WAS THE TOTAL \"FUNCTION\" TIME (SPENT PERF\nORMING FUNCTIONS)';\n       PUT // @3 AVGFUNTM @15 'WAS THE AVERAGE TIME TO COMPLETE A FUNCTI\nON';\n       PUT // @3 COPYTIME @15 'WAS THE TOTAL \"COPY\" TIME (SPENT TRANSFER\nRING DATA)';\n       PUT // @3 AVGCOPTM @15 'WAS THE AVERAGE TIME TO COMPLETE A COPY';\n           PUT /// @3 THRUPUTS @15 'BYTES/SECOND = EFFECTIVE SEND RATE';\n          PUT / @3 THRUPUTR @15 'BYTES/SECOND = EFFECTIVE RECEIVE RATE';\n            FORMAT TOTRANTM TIME10.2;\n            FORMAT COPYTIME TIME10.2;\n            FORMAT AVGFUNTM TIME10.2;\n            FORMAT AVGCOPTM TIME10.2;\n          END;\n      %END;\n    %MEND SUMIT;\n  %SUBSETS;\n  RUN;\n  %SUMIT;\n* RE-SORT THE DATASET BACK TO ITS ORIGINAL TIME ORDERED SEQUENCE;\n* BEFORE PROCESSING THE DATASET AS A WHOLE;\n  PROC SORT DATA=SUMMARY;\n    BY DATE STARTIME;\n  DATA ALLNODES;\n    SET SUMMARY END=FINAL;\n          TOTRECS + 1;\n          DATE = DATEJUL(STRDTE);       /* CONVERT JUL->SAS FOR MATH */\n          ENDDTE = DATEJUL(ENDDTE);\n*         HMS RETURNS SAS TIME VALUES FROM HHMMSS;\n          STARTIME = HMS(STRTHH,STRTMM,STRTSS)+STRTTT/100;\n          ENDTIME = HMS(ENDHH,ENDMM,ENDSS)+ENDTT/100;\n          TRANTIME = 86400 * (ENDDTE - DATE) + ENDTIME - STARTIME;\n*                   {TRAN DAYS IN SECONDS}  + {TRAN TIMES IN SECONDS};\n*         RETAIN TRANSITION TIME W/EACH OBSERVATION FOR TOTAL TRANTIM;\n          TOTRANTM + TRANTIME;\n          IF RECTYPE = 'CT' THEN DO;\n*            RETAIN TRANTIME W/EACH COPY FOR TOTAL COPY TIME;\n             COPYTIME + TRANTIME;\n             TOTCOPS + 1;               /* COUNT COPIES */\n             IF CC \u00ac= 0 THEN DO;\n               NZCOPS + 1;              /* COUNT FAILED COPIES */\n               NZRECS + 1;              /* COUNT FAILED FUNCTIONS */\n             END;\n*            RETAIN BYTES RECORDS AND BLOCKS READ AND WRITTEN WITH EACH;\n*            COPY FOR TOTALS;\n*            SUBIND = 'P' IMPLIES PNODE IS SENDING;\n*            SUBIND = 'S' IMPLIES SNODE IS SENDING;\n             IF SUBIND = 'P' THEN\n               IF MYNODE = PNODE THEN DO;\n                 TINBYTES + INBYTES;\n                 TSNDBYTS + SNDBYTS;\n                 END;\n               ELSE DO;\n                 TOUTBYTS + OUTBYTES;\n                 TRCVBYTS + RCVBYTS;\n               END;\n             ELSE IF SUBIND = 'S' THEN\n               IF MYNODE = SNODE THEN DO;\n                 TINBYTES + INBYTES;\n                 TSNDBYTS + SNDBYTS;\n                 END;\n               ELSE DO;\n                 TOUTBYTS + OUTBYTES;\n                 TRCVBYTS + RCVBYTS;\n                 END;\n          END;\n          IF RECTYPE = 'RT' THEN DO;\n             TOTRTS + 1;\n             IF CC \u00ac= 0 THEN DO;\n               NZRTS + 1;              /* COUNT FAILED RUNTASKS */\n               NZRECS + 1;             /* COUNT FAILED FUNCTIONS*/\n               END;\n             ELSE DO;                  /* IF RUNTASK DIDN'T FAIL */\n*              COUNT AND RETAIN RUNTASKS ATTACHED ON THIS NODE;\n               IF (SUBIND = 'P' AND PNODE = MYNODE) OR\n                  (SUBIND = 'S' AND SNODE=MYNODE) THEN\n                  RTSONMY + 1;\n               END;\n          END;\n          IF RECTYPE = 'RJ' THEN DO;\n             TOTRJS + 1;               /* COUNT RUNJOBS         */\n             IF CC \u00ac= 0 THEN DO;\n               NZRJS + 1;              /* COUNT FAILED RUNJOBS  */\n               NZRECS + 1;             /* COUNT FAILED FUNCTIONS*/\n               END;\n             ELSE DO;                  /* IF RUNJOB DIDN'T FAIL */\n*              COUNT AND RETAIN RUNJOBS SUBMITTED ON THIS NODE;\n               IF (SUBIND = 'P' AND PNODE = MYNODE) OR\n                  (SUBIND = 'S' AND SNODE=MYNODE) THEN\n                  RJSONMY + 1;\n               END;\n          END;\n          IF RECTYPE = 'SW' THEN DO;\n             TOTSUBS + 1;              /* COUNT SUBMITS         */\n             IF CC \u00ac= 0 THEN DO;\n               NZSUBS + 1;             /* COUNT FAILED SUBMITS  */\n               NZRECS + 1;             /* COUNT FAILED FUNCTIONS*/\n               END;\n             ELSE DO;                  /* IF SUBMIT DIDN'T FAIL */\n*              COUNT AND RETAIN SUBMITS ON THIS NODE;\n               IF (SUBIND = 'P' AND PNODE = MYNODE) OR\n                  (SUBIND = 'S' AND SNODE=MYNODE) THEN\n                  SBSONMY + 1;\n               END;\n          END;\n*        INCLUDE THESE OBSERVATIONS IN THE SAS DATASET BEING CREATED;\n          OUTPUT;\n* DETERMINE WHEN THE FIRST FUNCTION AND LAST FUNCTION HAPPENED;\n* TO PRINT IN THE SUMMARY REPORT;\n        DATA FUNCSS;\n          SET ALLNODES END=FINAL;\n          IF _N_ = 1 THEN DO;\n            FUNBEGT = STARTIME;\n            FUNBEGD = DATE;\n            RETAIN FUNBEGT FUNBEGD;\n            FORMAT FUNBEGT TIME13.2;\n            FORMAT FUNBEGD MMDDYY10.;\n          END;\n          IF FINAL THEN DO;\n             FUNCFINT = ENDTIME;\n             FUNCFIND = ENDDTE;\n             FORMAT FUNCFINT TIME13.2;\n             FORMAT FUNCFIND MMDDYY10.;\n             OUTPUT;\n          END;\n*      DETERMINE WHEN THE FIRST AND LAST COPY HAPPENED FOR THRUPUT CALC;\n        DATA COPYRECS;\n          SET ALLNODES;\n            IF RECTYPE = 'CT' THEN\n              OUTPUT;\n        DATA STRTSTOP;\n          SET COPYRECS END=FINAL;\n          IF _N_ = 1 THEN DO;\n             BEGINT = STARTIME;\n             BEGIND = DATE;\n             RETAIN BEGINT BEGIND;\n             FORMAT BEGINT TIME13.2;\n             FORMAT BEGIND MMDDYY10.;\n           END;\n           IF FINAL THEN DO;\n             FINISHT = ENDTIME;\n             FINISHD = ENDDTE;\n*    DURATION IS BASED OFF OF TIME FROM BEGINNING OF FIRST COPY IN FILE;\n*       AND THE END OF THE LAST COPY IN THE FILE;\n             DURATION = 86400 * (FINISHD - BEGIND) + FINISHT - BEGINT;\n             FORMAT FINISHT TIME13.2;\n             FORMAT FINISHD MMDDYY10.;\n             OUTPUT;\n           END;\n*  THIS MERGE STATEMENT WILL MERGE TWO SAS DATASET WITH ONE OBSERVATION;\n* EACH. FUNCSS CONTAINS ALL THE CUMULATIVE TOTALS FROM THE SUMMARY DATA;\n*      STEP AS WELL AS TIMES WHEN THE FIRST AND LAST FUNCTIONS OCCURRED;\n*  BY PLACING FUNCSS ON THE RIGHT, WE WONT LOSE THE CORRECT CUMULATIVE;\n*       TOTALS IN THE MERGE;\n        DATA DTETIMES;\n           MERGE STRTSTOP FUNCSS;\n        DATA TOTALS;\n          TITLE;\n          FILE FT20F001;\n          SET DTETIMES END=FINAL;\n*         ANY MORE OBSERVATIONS?;\n          IF FINAL THEN DO;\n*           FIGURE PERCENTAGES;\n            IF TOTRECS = 0 THEN DO;\n              PERCCOP = 0;\n              PERCRJS = 0;\n              PERCRTS = 0;\n              PERCSBS = 0;\n              AVGFUNTM = 0;\n              END;\n            ELSE DO;\n              PERCCOP = (TOTCOPS / TOTRECS) * 100;\n              PERCCOP = ROUND(PERCCOP,.1);\n              PERCRJS = (TOTRJS / TOTRECS) * 100;\n              PERCRJS = ROUND(PERCRJS,.1);\n              PERCRTS = (TOTRTS / TOTRECS) * 100;\n              PERCRTS = ROUND(PERCRTS,.1);\n              PERCSBS = (TOTSUBS / TOTRECS) * 100;\n              PERCSBS = ROUND(PERCSBS,.1);\n              AVGFUNTM = (TOTRANTM / TOTRECS);\n            END;\n            IF TOTCOPS = 0 THEN\n              AVGCOPTM = 0;\n            ELSE\n              AVGCOPTM = (COPYTIME / TOTCOPS);\n            IF DURATION = 0 THEN DO;\n              THRUPUTS = 0;\n              THRUPUTR = 0;\n              END;\n            ELSE DO;\n              THRUPUTS = (TSNDBYTS / DURATION);\n              THRUPUTS = ROUND(THRUPUTS,.001);\n              THRUPUTR = (TRCVBYTS / DURATION);\n              THRUPUTR = ROUND(THRUPUTR,.001);\n            END;\n*           WRITE TO OUTPUT;\n            FORMAT DURATION TIME13.2;\n            PUT @45 ' IBM Sterling Connect:Direct for z/OS  Summary Repo\nrt';\n            PUT @62 'NODE = ' MYNODE;\n            PUT / @3 'SNODE = ALL SNODES';\n            PUT // @3 'FIRST FUNCTION BEGAN EXECUTING ON ' @40 FUNBEGD '\nAT ' FUNBEGT;\n            PUT @3 'LAST FUNCTION FINISHED EXECUTING ON '  @40 FUNCFIND\n'AT ' FUNCFINT;\n            PUT ///;\n      PUT @3 TOTRECS ' PROCESS STEPS WERE COMPLETED FOR THIS TIME PERIOD\n.';\n      PUT /// @6 TOTCOPS @12 'TOTAL COPY STEPS OR ' PERCCOP @41 '% OF TO\nTAL STEPS RUN WERE COPIES';\n      PUT /// @6 TOTRJS @12 'TOTAL RUNJOB STEPS OR ' PERCRJS @41 '% OF T\nOTAL STEPS RUN WERE RUNJOBS';\n            PUT / @12 RJSONMY @18 'RUNJOBS WERE SUBMITTED ON ' MYNODE;\n       PUT /// @6 TOTRTS @12 'TOTAL RUNTASK STEPS OR ' PERCRTS @41 '% OF\n TOTAL STEPS RUN WERE RUNTASKS';\n            PUT / @12 RTSONMY @18 'RUNTASKS WERE ATTACHED ON ' MYNODE;\n       PUT /// @6 TOTSUBS @12 'TOTAL SUBMIT STEPS OR ' PERCSBS @41 '% OF\n TOTAL STEPS RUN WERE SUBMITS';\n        PUT / @12 SBSONMY @18 'SUBMITS (WITHIN A PROCESS) ON ' MYNODE;\n            SUCRECS = TOTRECS - NZRECS;\n            PERCNZS = (NZRECS / TOTRECS) * 100;\n            PERCNZS = ROUND(PERCNZS,.1);\n            PERSUCS = 100 - PERCNZS;\n     PUT //// @6 SUCRECS @12 'SUCCESSFUL STEPS OR ' PERSUCS @41 '% OF TO\nTAL STEPS RUN COMPLETED WITH A ZERO RETURN CODE';\n      PUT / @6 NZRECS @12 'UNSUCCESSFUL STEPS OR ' PERCNZS @41 '% OF TOT\nAL STEPS RUN COMPLETED WITH A NON-ZERO RETURN CODE';\n            PUT _PAGE_;\n            PUT @45 ' IBM Sterling Connect:Direct for z/OS  Summary Repo\nrt';\n            PUT @62 'NODE = ' MYNODE;\n            PUT / @3 'SNODE = ALL SNODES';\n            PUT ///;\n            FORMAT TINBYTES COMMA32.;\n            FORMAT TSNDBYTS COMMA32.;\n            FORMAT TOUTBYTS COMMA32.;\n            FORMAT TRCVBYTS COMMA32.;\n            PUT @3 TINBYTES @45 'TOTAL BYTES WERE READ ';\n            PUT / @3 TSNDBYTS @45 'TOTAL BYTES WERE SENT';\n            PUT / @3 TOUTBYTS @45 'TOTAL BYTES WERE WRITTEN';\n            PUT / @3 TRCVBYTS @45 'TOTAL BYTES WERE RECEIVED';\n     PUT //// @3 TOTRANTM @15 'WAS THE TOTAL \"FUNCTION\" TIME (SPENT PERF\nORMING FUNCTIONS)';\n       PUT // @3 AVGFUNTM @15 'WAS THE AVERAGE TIME TO COMPLETE A FUNCTI\nON';\n       PUT // @3 COPYTIME @15 'WAS THE TOTAL \"COPY\" TIME (SPENT TRANSFER\nRING DATA)';\n       PUT // @3 AVGCOPTM @15 'WAS THE AVERAGE TIME TO COMPLETE A COPY';\n           PUT /// @3 THRUPUTS @15 'BYTES/SECOND = EFFECTIVE SEND RATE';\n          PUT / @3 THRUPUTR @15 'BYTES/SECOND = EFFECTIVE RECEIVE RATE';\n            FORMAT TOTRANTM TIME10.2;\n            FORMAT COPYTIME TIME10.2;\n            FORMAT AVGFUNTM TIME10.2;\n            FORMAT AVGCOPTM TIME10.2;\n          END;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVTMXXX": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x01\\x131/\\x01\\x131/\\x16\\x14\\x00$\\x00!\\x00\\x0e\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2013-11-08T00:00:00", "modifydate": "2013-11-08T16:14:14", "lines": 36, "newlines": 33, "modlines": 14, "user": "SCNS03T"}, "text": "*=====================================================================*\n*                Svtm MESSAGES (NDM)                                  *\n*                                                                     *\n*  Change \"Email@company.com\" to Email address of desired recipient   *\n*=====================================================================*\n IF (LABEL:SVTM) MSGID = 'SVTM' . THEN BEGIN;\n*\n IF (LABEL:SVTM052E) MSGID = 'SVTM052I' & JOBNAME = JOB\n    & (ACQUIRE('LASTLINE WORD 4.1') = .'SDEDSNRI'. |\n       ACQUIRE('LASTLINE WORD 4.1') = .'SDEPDSRI'. |\n       ACQUIRE('LASTLINE WORD 4.1') = .'SVTN001I'.)\n  THEN EXEC(CMD('SNDMAIL6 Email@company.com 'JOB)\n  ROUTE(ONE AUTO1));\n*\n IF (LABEL:SVTM083I) MSGID='SVTM083I' & TEXT = MESS & JOBNAME = JOB\n     & TEXT = .'*UNKNOWN'.\n     THEN EXEC(CMD('SNDMAIL6 Email@company.com 'JOB) ROUTE(ONE AUTONDM))\n          EXEC(CMD('SVTM083I 'JOB' 'MESS ))\n     DISPLAY(N) NETLOG(Y);\n*\n IF (LABEL:SVTM105I) MSGID = 'SVTM105I' & TEXT = MESS & JOBNAME = JOB\n    & (TEXT = .'JS4'. | TEXT = .'NOTIFY'.)\n  THEN EXEC(CMD('SVTM105I 'JOB' 'MESS )\n  ROUTE(ONE AUTONDM));\n*\n IF (LABEL:SVTM102I) MSGID='SVTM102I' & JOBNAME = JOB\n     & THRESHOLD(5 0 2:00:00) = '0'\n     THEN EXEC(CMD('SNDMAIL6 Email@company.com 'JOB) ROUTE(ONE AUTONDM))\n     DISPLAY(N) NETLOG(Y);\n*\n ALWAYS DISPLAY(Y) NETLOG(N);\n*\n END;\n*=====================================================================*\n*                End of SVTM Messages                                 *\n*=====================================================================*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVTM083I": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x18\\x01\\x13#\\x8f\\x01\\x131/\\x16\\x18\\x00\\x1e\\x00\\x16\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2013-08-26T00:00:00", "modifydate": "2013-11-08T16:18:18", "lines": 30, "newlines": 22, "modlines": 0, "user": "SCNS03T"}, "text": "SVTM083I CLIST\n&CONTROL ERR\nMSG LOG <>SVTM083I : &PARMSTR - &DATE &TIME\nPARSEL2R PARMSTR JOB MESS\nPARSEL2R MESS A B C D E F G H I J K L M N\nMSG LOG A= &A B=&B C=&C D= &D E= &E F= &F G= &G\n*&IF &A = 'SVTM083I' &THEN &GOTO -SVTM083\n-SVTM083\nMSG LOG PNAME= &B PNUM = &C\nPARSEL2R B P /(/ X\nPARSEL2R C D /)/ S\n&IF &D = 'PNUM=' &THEN &D = &E\nMSG LOG PNAME= &P PNUM = &D\nPARSEL2R D W /,/ Z\n&D = &CONCAT &W &Z\n*\n* NOTE:  Next statement send a message to a Netview User (userid)\n*\nMSG userid,NDM Process &P (&D) now in WC Que - (&S)\n*\n* NOTE:  Next statement check for certain process names\n*\n*IF &SUBSTR &P 1 1 \u00ac= 'J' &THEN &EXIT\nMSG LOG AFTER 00:01,MVS MODIFY &JOB,RLSE &D\n*\n* NOTE:  Next statement issues the release command if uncommented\n*\n*AFTER 00:01,MVS F &JOB,RLSE &D\nMSG LOG,AJC0105I Netview has release NDM Process &P (&D)\n&EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVTM105I": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00$\\x01\\x05\\x18_\\x01\\x131/\\x16\"\\x00\\x1c\\x00\\x14\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2005-07-04T00:00:00", "modifydate": "2013-11-08T16:22:24", "lines": 28, "newlines": 20, "modlines": 0, "user": "SCNS03T"}, "text": "SVTM105I CLIST\n&CONTROL ERR\n*VTM105I PNAME=JM428NPE, PNUM=   8,667    MOVED TO Q=HOLD   , QSTATUS=WC\n*   A         B            C       D        E   F    G      H    I\nMSG LOG <>SVTM105I : &PARMSTR - &DATE &TIME\nPARSEL2R PARMSTR JOB MESS\nPARSEL2R MESS A B C D E F G H I J K L M N\n*MSG LOG A= &A B= &B C= &C D= &D E= &E\n*MSG LOG F= &F G= &G H= &H I= &I J= &J\n&IF &A = 'SVTM105I' &THEN &GOTO -SVTM105\n-SVTM105\nPARSEL2R B W /=/ PNAM /,/\nPARSEL2R D X1 /,/ X2\n&PNUM = &CONCAT &X1 &X2\nPARSEL2R I Y /=/ QS\n*\n* NOTE:  Next statements issues a message to a Netview user (userid)\n*\nMSG userid,NDM Process &PNAM (&PNUM) now in &G Que - Status (&QS)\n&IF &SUBSTR &PNAM 1 1 \u00ac= 'J' &THEN &EXIT\n*\n* NOTE:  Next (2) statements issue the release command if uncommented\n*        Uncomment one (RLSE  by PNAM or PNUM\n*\n* AFTER 00:01,MVS MODIFY &JOB,RLSE , &PNAM\n* AFTER 00:01,MVS F &JOB,RLSE &PNUM\nMSG LOG,AJC0105I Netview has release NDM Process &PNAM (&PNUM)\n&EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSTA339$": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x005\\x01\\x12#o\\x01\\x14\\x02\\x0f\\x13I\\x00\\x1e\\x00\\x18\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2012-08-23T00:00:00", "modifydate": "2014-01-20T13:49:35", "lines": 30, "newlines": 24, "modlines": 0, "user": "SCNS03"}, "text": "//*jobname  JOB (xxxx,xxxx),NDMEXIT,CLASS=T,MSGCLASS=X,NOTIFY=&SYSUID\n//*-------------------------------------------------------------------*\n//*        ASSEMBLE USER EXIT ROUTINE TSTA3390 FOR C:D V5R1.1         *\n//*        USING THE HIGH LEVEL ASSEMBLER                             *\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=ibm.hdga510.sdgamac                                     *\n// SET SAMPLIB=ibm.hdga510.sdgasamp                                   *\n// SET SDGALINK=ibm.hdga510.sdgalink                                  *\n// SET SOURCE=the.source.code.pds                                     *\n// SET LOADLIB=your.loadlib                                           *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//TONY OUTPUT DEST=LOCAL,CLASS=X,JESDS=ALL,DEFAULT=Y\n//ASSEM    EXEC HLASMCL,REGION=1024K,PARM.C='OBJECT,NODECK',\n//         PARM.L='AC=01,MAP,LET,LIST,RENT,REUS,AMODE=ANY,RMODE=24'\n//C.SYSLIB DD\n//         DD  DSN=&MACLIB,DISP=SHR\n//         DD  DSN=&SAMPLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//C.SYSIN  DD  DISP=SHR,DSN=&SOURCE(TSTA3390)\n//L.SYSLIB DD  DSN=&SDGALINK,DISP=SHR\n//L.SYSLMOD DD DSN=&LOADLIB,DISP=SHR\n//L.SYSLIN DD\n//         DD  *\n  ENTRY TSTA3390\n  NAME TSTA3390(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTA3390": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x04\\x01\\x12#o\\x01\\x135?\\x116\\x01-\\x01.\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2012-08-23T00:00:00", "modifydate": "2013-12-19T11:36:04", "lines": 301, "newlines": 302, "modlines": 0, "user": "SCNS03"}, "text": "* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 Copyright IBM Corp. 2011\n*\n* All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\nTSTA3390 TITLE '- SAMPLE ALLOCATION EXIT'                       46497\nTSTA3390 START ,                                                46497\n         DGA$SAMP ,                                            DGA_STD\n         COPY  DMGBLS                                           46497\n         DMOS                                                   46497\n         LCLC  &LASTPTF,&UID                                    1348110\n&LASTPTF SETC  'R000000'                                        1348110\n&UID     SETC  ''       USE UP TO 8 CHARACTERS FOR LOCAL MOD    1348110\n**********************************************************************\n*                                                                    *\n*    Connect:Direct (tm)                                             *\n*    COPYRIGHT (C) 1983, 1998  Sterling Commerce, Inc.               *\n*                                                                    *\n*    This material is the confidential trade secret and proprietary  *\n*    information of Sterling Commerce, Inc. and/or its subsidiaries. *\n*    It may not be reproduced, used, sold, or transferred to any     *\n*    third party without the prior written consent of Sterling       *\n*    Commerce, Inc.  All rights reserved.                            *\n*                                                                    *\n*    Use, duplication, or disclosure by the Government is subject    *\n*    to restrictions as set forth in subparagraph (c)(1)(ii) of      *\n*    the Rights in Technical Data and Computer Software clause at    *\n*    FAR 52.227*7013.                                                *\n*                                                                    *\n**********************************************************************\n*                                                                    *\n*                       Connect:Direct PROLOG                        *\n*                                                                    *\n* FUNCTION:       Connect:Direct ALLOCATION EXIT                     *\n*                                                                    *\n* MODULE NAME:    TSTA3390   VER: 01 REL: 04 MOD: 00                 *\n*                                                                    *\n* DATE WRITTEN:   06/30/89                                           *\n*                                                                    *\n* PROGRAMMER:     JAY B. MORRIS                                      *\n*                                                                    *\n* ATTRIBUTES:     LINK WITH RENT, REUS                               *\n*                                                                    *\n* ENTRY POINT 1:  TSTA3390                                           *\n*                                                                    *\n*  INPUT:         R1 -> VSAMPL                                       *\n*                                                                    *\n*  OUTPUT:        MODIFIED DDESCR WITH GENERIC UNIT TYPE FOR 3390    *\n*                                                                    *\n* DESCRIPTION:    TSTA3390 PERFORMS THE FOLLOWING MAIN FUNCTION:     *\n*                                                                    *\n*                 1. CHECKS SOURCE DATASET DESCRIPTOR FOR UNIT=3390. *\n*                    IF 3390, CHANGES DESTINATION DATASET DESCRIPTOR *\n*                    BLOCK UNITTYPE FIELD TO SYSDA.  IF THE SOURCE   *\n*                    IS NOT 3390, IT IS NOT CHANGED.  THE DESTINATION*\n*                    UNIT IS NOT CHECKED.  IF THE USER SPECIFIES A   *\n*                    DESTINATION UNIT OF 3390, IT WILL NOT BE CHANGED*\n*                    SEE DESCRIPTION IN CODE.                        *\n*                                                                    *\n* CALLED BY:      DMVSOPEN                                           *\n*                                                                    *\n* CONTROL BLOCKS: VSAMPL                                             *\n*                 TCQSH                                              *\n*                 SDESCR                                             *\n*                 DDESCR                                             *\n*                                                                    *\n* REGISTERS:      R0     RESERVED FOR MACRO USE                      *\n*                 R1     RESERVED FOR MACRO USE                      *\n*                 R2     MODULE WORK REGISTER                        *\n*                 R3     BASE TO VSAMPL                              *\n*                 R4     BASE TO TCQSH                               *\n*                 R5     BASE TO SDESCR                              *\n*                 R6     BASE TO DDESCR                              *\n*                 R7     MODULE WORK REGISTER                        *\n*                 R8     MODULE WORK REGISTER                        *\n*                 R9     MODULE WORK REGISTER                        *\n*                 R10    DISPLAY LINK REGISTER               TRAC*API*\n*                 R11    MODULE WORK REGISTER                        *\n*                 R12    FIRST BASE REGISTER                         *\n*                 R13    CURRENT SAVE AREA                           *\n*                 R14    RETURN ADDRESS                              *\n*                 R15    BRANCH REGISTER AND RETURN CODE             *\n*                                                                    *\n**********************************************************************\n         EJECT\n         DMVSAMPL DSECT=YES\n         EJECT\n         DMTCQSH  DSECT=YES\n         EJECT\n         DMSDESCR DSECT=YES\n         EJECT\n         DMDDESCR DSECT=YES\n         EJECT\n         DMTCA  DSECT=YES              MAP TASK CONTROL AREA            AJC06258\n         EJECT                                                          AJC06258\n         DMTCQE DSECT=YES              MAP TASK CONTROL QUEUE HEADER    AJC06258\n         EJECT                                                          AJC06258\n*---------------------------------------------------------------------*\n*        LOCAL VARIABLE SECTION                                       *\n*---------------------------------------------------------------------*\nDSECT    DSECT\nSAVEAREA DS    10D         PROVIDED SAVEAREA\nWKAREA   DS    D           DISPLAY MACRO WORKAREA\nWKAREA2  DS    8D          DISPLAY MACRO WORKAREA\n DEBUG LINKAGE=(R10,DEBUG1,DEBUG2)                             TRAC*API\nDEBUG1   DS    D           DISPLAY MACRO WORKAREA\nDEBUG2   DS    D           DISPLAY MACRO WORKAREA\n*\nWTO      WTO   'CDPAL01X UNIT= changed for PROCESS 12345678( ##,###) SU*AJC06258\n               BMITTED BY Snode=NNNNNNNNNNNNNNNN',ROUTCDE=(11),MF=L     AJC06258\nWTONAME  EQU   WTO+4+35,8                                               AJC06258\nWTOPNUM  EQU   WTO+4+45,7                                               AJC06258\nWTOCOMA  EQU   WTO+4+47,1                                               AJC06258\nWTOPNU3  EQU   WTO+4+48,3                                               AJC06258\nWTONODE  EQU   WTO+4+72,16                                              AJC06258\n         DS    F                                                        AJC06258\nPACDEC   DS    D                                                        AJC06258\nZONDEC   DS    D                                                        AJC06258\nDSECT#   EQU   *-DSECT\n         EJECT\n*---------------------------------------------------------------------*\n*     MAINLINE\n*---------------------------------------------------------------------*\n&DMCSECT SCENTER BASE=(R12),GETMAIN=DSECT#,                     1348110X\n               AMODE=ANY,RMODE=24,LASTPTF=&LASTPTF,UID=&UID     1348110\n&DMCSECT SCSTART WKAREA=WKAREA,WKAREA2=WKAREA2                  1348110\n         USING DSECT,R13\n*---------------------------------------------------------------------*\n* REG 1 CONTAINS THE ADDRESS OF THE PARAMETER LIST COMING IN. THE     *\n* PARAMETER LIST PASSED TO THE ALLOCATION EXIT CONTAINS THE VSAMPL.   *\n*---------------------------------------------------------------------*\n         LR    R2,R1                   GET PARM LIST COMING IN\n         L     R3,0(,R2)               SAVE ADDR AWAY\n         USING VSAMPL,R3               USE VSAMPL\n*---------------------------------------------------------------------*\n* THE FIELD IN THE VSAMPL CALLED VSCCBADR IS THE POINTER TO THE       *\n* COPY CONTROL BLOCK STATEMENT HEADER.                                *\n*---------------------------------------------------------------------*\n         L     R4,VSCCBADR             PT AT TCQSH\n         USING TCQSH,R4                USE TCQSH\n*---------------------------------------------------------------------*\n* THE FIELD IN THE TCQSH CALLED TSHCBHLN CONTAINS THE LENGTH OF THE   *\n* TCQSH WHICH IS FOLLOWED BY THE SOURCE DATASET DESCRIPTOR CONTROL    *\n* BLOCK (DMSDESCR). ADD THAT LENGTH TO THE START OF THE TCQSH TO GET  *\n* THE ADDRESS OF THE SOURCE DESCRIPTOR.                               *\n*---------------------------------------------------------------------*\n         LH    R5,TSHCBHLN             LOAD LEN OF TCQSH AND\n         AR    R5,R4                   ADD START OF TCQSH TO GET SRC\n         USING SDESCR,R5               USE SDESCR\n*---------------------------------------------------------------------*\n* THE FIELD IN THE SDESCR CALLED S1SVSLNG CONTAINS THE LENGTH OF THE  *\n* SDESCR WHICH IS FOLLOWED BY THE DESTINATION DATASET DESCRIPTOR      *\n* CONTROL BLOCK (DMDDESCR). ADD THAT LENGTH TO THE START OF THE SDESCR*\n* TO GET THE ADDRESS OF THE DESTINATION DESCRIPTOR.                   *\n*---------------------------------------------------------------------*\n         LH    R6,S1SVSLNG             LOAD LEN OF SDESCR AND\n         AR    R6,R5                   ADD START OF SDESCR TO GET DEST\n         USING DDESCR,R6               USE DDESCR\n*---------------------------------------------------------------------*\n* HERE IS AN EXAMPLE OF HOW TO MODIFY THE DESTINATION UNIT IF THE     *\n* SOURCE UNIT IS A 3390.  THE DESTINATION UNIT IS NOT CHECKED IN THIS *\n* EXAMPLE, SO IF A USER WERE TO SPECIFY A DESTINATION UNIT OF 3390,   *\n* IT WOULD NOT BE CHANGED.  OF COURSE, IT WOULD BE VERY EASY TO ADD   *\n* THIS CHECK IF IT WERE NECESSARY.                                    *\n*                                                                     *\n* THE FOLLOWING DIAGRAM DESCRIBES THE SITUATION THAT THIS SAMPLE EXIT *\n* WILL HANDLE.                                                        *\n*                                                                     *\n*   SOURCE NODE                       DESTINATION NODE                *\n* +--------------+                    +--------------+                *\n* |              |                    |              |                *\n* |  SYSTEM A    | SUNIT=3390         |   SYSTEM B   | SUNIT=3390     *\n* |              |             -----> |              |                *\n* |    3390      | DUNIT=____         |    NO 3390   | DUNIT=SYSDA    *\n* |              |                    |              |                *\n* |   NO EXIT    |                    |  THIS EXIT   |                *\n* +--------------+                    +--------------+                *\n*                                                                     *\n*                                                                     *\n* THE FOLLOWING DIAGRAM DESCRIBES THE SITUATION THAT THIS SAMPLE EXIT *\n* WILL NOT HANDLE (BUT EASILY COULD IF SO DESIRED).                   *\n*                                                                     *\n*   SOURCE NODE                       DESTINATION NODE                *\n* +--------------+                    +--------------+                *\n* |              |                    |              |                *\n* |  SYSTEM A    | SUNIT=3380         |   SYSTEM B   | SUNIT=3380     *\n* |              |             -----> |              |                *\n* |    3390      | DUNIT=3390         |    NO 3390   | DUNIT=3390     *\n* |              |                    |              |                *\n* |   NO EXIT    |                    |  THIS EXIT   |                *\n* +--------------+                    +--------------+                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         TM    D1FLAG8,D1VOLSER        HAS USER SPEC. EXPLICIT VOLSER   AJC06258\n         BO    OKUNIT               YES, THEN HONOR THAT REQUEST I5453\n         CLC   D1DDISP1,=C' '          Was the DISP1 field specified ?  AJC06258\n         BE    CHKUNIT                 NO, the default is DISP=NEW      AJC06258\n         CLC   D1DDISP1,=C'N'          Is the first DISP field 'New'?   AJC06258\n         BNE   OKUNIT                  NO, UNIT IS OK ASIS              AJC06258\nCHKUNIT  DS    0H                                                       AJC06258\n         CLC   D1UNIT(4),=C'    '      Was the UNIT field specified ?   AJC06258\n         BE    CHKLAST                 NO, the default is ALL DASD      AJC06258\n         CLC   D1UNIT,=C'SYSALLDA'     SYSALLDA causes the same issue   AJC06258\n         BE    CHKLAST                 NO, the default is ALL DASD      AJC06258\n         CLC   D1UNIT(4),=C'3390'      IS UNIT TYPE 3390 ?              AJC06258\n         BNE   OKUNIT                  NO, UNIT IS OK ASIS\nCHKLAST  DS    0H                                                       AJC06258\n         DISPLAY (C'&DMCSECT: Found DISP=NEW+UNIT=3390'),(C),USRINFO    AJC06258\n         MVC   D1UNIT,=C'DISK80  '     YES, CHG DEST UNIT TO DISK80     AJC06258\n         OI    D1FLAG7,D1GRPTYP             AND SHOW UNIT AS CHANGED\nWTOMSG   DS    0H                                                       AJC06258\n*---------------------------------------------------------------------* AJC06258\n* THE FIELD IN THE VSAMPL CALLED VSTCAADR IS THE POINTER TO THE       * AJC06258\n* TASK CONTROL AREA (TCA) FOR THIS TASK.                              * AJC06258\n*---------------------------------------------------------------------* AJC06258\n         L     R7,VSTCAADR             Point at the TCA                 AJC06258\n         USING TCA,R7                  MAP the TCA                      AJC06258\n*---------------------------------------------------------------------* AJC06258\n* THE FIELD IN THE TCA CALLED TATCQE IS THE POINTER TO THE TASK       * AJC06258\n* CONTROL QUEUE ELEMENT (TCQE) FOR THIS TASK.                         * AJC06258\n*---------------------------------------------------------------------* AJC06258\n         L     R9,TATCQE               Point at the TCQE                AJC06258\n         USING TCQE,R9                 MAP the TCQE                     AJC06258\n*---------------------------------------------------------------------* AJC06258\n*        Issue WTO to provide an audit trail for the changed process  * AJC06258\n*---------------------------------------------------------------------* AJC06258\n         MVC   WTO(WTO#),WTOMODEL                                       AJC06258\n         MVC   WTONAME,TQPROCNM    MOVE IN PROCESS NAME                 AJC06258\n         L     R8,TQPROCNO         LOAD THE PROCESS NUMBER              AJC06258\n         DISPLAY (C'&DMCSECT: PROC NO     = ',(R8)),(C,X),USRINFO       AJC06258\n         CVD   R8,PACDEC           CONVERT TO PACKED DECIMAL            AJC06258\n         DISPLAY (C'&DMCSECT: PACDEC      = ',PACDEC),(C,X),USRINFO     AJC06258\n         UNPK  ZONDEC,PACDEC+4(4)  Unpk the packed decimal number       AJC06258\n         OI    ZONDEC+7,X'F0'      Take care of the sign field          AJC06258\n         DISPLAY (C'&DMCSECT: ZONDEC(1)   = ',ZONDEC),(C,X),USRINFO     AJC06258\n         MVC   WTOPNU3,ZONDEC+5    MOVE IN THE LOW ORDER DIGITS         AJC06258\n         CLI   ZONDEC+3,X'F0'      IS PROCESS NUMBER GT 10000           AJC06258\n         BE    NEXTCHK                                                  AJC06258\n         MVI   WTOCOMA,C','        MOVE IN THE COMMA                    AJC06258\n         MVC   WTOPNUM(2),ZONDEC+3 MOVE IN THE TEN THOUSAND DIGIT       AJC06258\nNEXTCHK  DS    0H                                                       AJC06258\n         CLI   ZONDEC+4,X'F0'      IS PROCESS NUMBER GT 1000            AJC06258\n         BE    PROC999                                                  AJC06258\n         MVI   WTOCOMA,C','        MOVE IN THE COMMA                    AJC06258\n         MVC   WTOPNUM+1(1),ZONDEC+4 MOVE IN THE THOUSAND DIGIT         AJC06258\nPROC999  DS    0H                                                       AJC06258\n         LA    R8,6                FILL IN PROCESS NUMBER               AJC06258\n         DISPLAY (C'&DMCSECT: ZONDEC(2)   = ',ZONDEC),(C,X),USRINFO     AJC06258\n         DISPLAY (C'&DMCSECT: WTOPNUM     = ',WTOPNUM),(C,X),          *AJC06258\n               LEN=(,(R8)),USRINFO                                      AJC06258\n         MVC   WTONODE,TQSNODE     MOVE IN THE SUBMITTER NODE NAME      AJC06258\n         WTO   MF=(E,WTO)                                               AJC06258\nOKUNIT   DS    0H\n***********************************************************************\n*        RETURN LOGIC                                                 *\n***********************************************************************\n         L     R15,VSRTNCD             PICK UP RETURN CODE\n*     SCRETURN WILL FREE SCENTER STORAGE AND RETURN TO CALLER   1348110\n         SCRETURN RC=(R15)                                      1348110\n         EJECT\n*---------------------------------------------------------------------* AJC06258\n*   Define Data Constants                                             * AJC06258\n*---------------------------------------------------------------------* AJC06258\n         DS    0F                                                       AJC06258\nWTOMODEL WTO   'CDPAL01X UNIT= changed for PROCESS 12345678(       ) SU*AJC06258\n               BMITTED BY Snode=NNNNNNNNNNNNNNNN',ROUTCDE=(11),MF=L     AJC06258\nWTO#     EQU   *-WTOMODEL                                               AJC06258\n**********************************************************************\n*                                                                    *\n* MAINTENANCE:                                                       *\n*                                                                    *\n* P46497  06/29/98 CLEANUP 'USING' FOR ASMA90 AND AMODE/RMODE        *\n*         JEL                                                        *\n*                                                                    *\n* 1348110 06/09/06 Use SCENTER to create standard eye catcher.       *\n*         JEL                                                        *\n*                                                                    *\n* TRAC*API 08/22/2006 Leave R11 (TCA) register alone.                *\n*         TOP                                                        *\n*                                                                    *\n* AJC06258 09/15/2006 Check for destination D/S with DISP=NEW and    *\n*          UNIT=3390 without a VOLSER and iff, then change it to     *\n*          UNIT=DISK80. If a process is changed, issue a WTO to the  *\n*          log. Search on AJC06258 (77) occurrences on COL 73-80.    *\n*                                                                    *\n* AJC06333 11/29/2006 Testing version of Submit exit. This is the    *\n*          same code, but with the DISPLAY macros enabled.           *\n*                                                                    *\n* AJC08007 01/07/2008 Change the DISPLAYs to use the USRINFO DDNAME  *\n*          that was added in C:D V4.6.00.                            *\n*                                                                    *\n* DGA_STD 01FEB2011  Change to standard SMP/E naming per IBM naming  *\n*         SThompson  standards.                                      *\n*                                                                    *\n**********************************************************************\n         SCEND &DMCSECT                                         1348110\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TSTSMF2": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00(\\x01\\x14\\x02/\\x01\\x14\\x02/\\x17\\x05\\x01\\xdc\\x01\\xdb\\x00\\x07\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2014-01-22T00:00:00", "modifydate": "2014-01-22T17:05:28", "lines": 476, "newlines": 475, "modlines": 7, "user": "SCNS03T"}, "text": "* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 Copyright IBM Corp. 2011\n*\n* All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\nTSTSMF2  TITLE '- SAMPLE STATEXIT TO INTERFACE WITH SMF'        46497\nTSTSMF2  START ,                                                46497\n         DGA$SAMP ,                                            DGA_STD\n         COPY  DMGBLS                                           46497\n         DMOS                                                   46497\n         LCLC  &LASTPTF,&UID                                    1348110\n&LASTPTF SETC  'R000000'                                        1348110\n&LASTPTF SETC  'PM54250'                            QC19822     QC19765\n&LASTPTF SETC  'PM77776'                                       R356952\n&UID     SETC  ''       USE UP TO 8 CHARACTERS FOR LOCAL MOD    1348110\n***********************************************************************\n*                                                                     *\n* FUNCTION:      CONNECT:DIRECT (TM) APPLICATION PROGRAM              *\n*                                                                     *\n* MODULE NAME:   TSTSMF2                                              *\n*                                                                     *\n* LEVEL:         VERSION 1, RELEASE 3                                 *\n*                                                                     *\n* DATE WRITTEN:  FEB. 1985                                            *\n*                                                                     *\n* PROGRAMMER:    K. C. THOMSON  SYSTEMS CONSULTANT                    *\n*                                                                     *\n* DESCRIPTION:   THIS ASSEMBLER PROGRAM IS AN SMF INTERFACE FOR       *\n*                CONNECT:DIRECT FOR ZOS THAT WILL WRITE THE           *\n*                CONNECT:DIRECT STATUS RECORD TO THE SMF LOG DATASET. *\n*                SMF RECORD TYPE = 248                       AJC98272 *\n*                                                                     *\n*                THIS PROGRAM IS DESIGNED FROM INFORMATION            *\n*                SUPPLIED IN IBM SMF MANUAL GC28-0706                 *\n*                                                                     *\n*                THE PROGRAM GETS 2K OF MAIN STORAGE TO HOLD          *\n*                THE CONNECT:Direct STATISTICS RECORD.                *\n*                IT THEN ADDS THE STANDARD SMF HEADER AND             *\n*                UPDATES THE RDW LENGTH TO WRITE THE RECORD           *\n*                AS USER TYPE 248 (X'F8')                    AJC98272 *\n*                                                                     *\n*                THE SMTWTM MACRO THEN WRITES THE RECORD TO THE       *\n*                SMF LOG DATA SET.                                    *\n*                                                                     *\n*                                                                     *\n*                CONNECT:Direct CONTROL BLOCKS PASSED:                *\n*                                                                     *\n*                            DMAER                                    *\n*                            DMCPTR                                   *\n*                            DMPTR                                    *\n*                            DMDPTR                                   *\n*                            DMDTR                                    *\n*                            DMFPTR                                   *\n*                            DMPSSR                                   *\n*                            DMSFR                                    *\n*                            DMSTDCR                                  *\n*                            DMTCQIF                                  *\n*                            DMTCQGT                                  *\n*                            DMXOR                                    *\n*                                                                     *\n*     THESE CONTROL BLOCKS CAN BE FOUND IN SAMPLIB THAT IS            *\n*     SHIPPED ON THE PRODUCT TAPE.                                    *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*          CONNECT:Direct MUST BE APF AUTHORIZED                      *\n*                                                               CPUTIME\n*      THIS ASSEMBLER PROGRAM EXECUTES AS A C:D-ZOS             CPUTIME\n*      STATISTICS EXIT ROUTINE.  IT IS A SAMPLE EXIT THAT       CPUTIME\n*      RETRIEVES CPU TIME FOR PROCESS STEPS AND ADDS IT TO      CPUTIME\n*      THE END OF THE STATISTICS RECORD FOR LATER REPORTING     CPUTIME\n*      OR WHATEVER PURPOSE THE CUSTOMER DESIRES.                CPUTIME\n*                                                               CPUTIME\n*      NOTE: ALTHOUGH 'PT' RECORDS FOR PROCESS TERMINATION      CPUTIME\n*            IS INCLUDED IN THIS SAMPLE EXIT, THE TIME          CPUTIME\n*            FOR 'PT' WILL NOT BE ACCURATE WHEN RUN TASKS       CPUTIME\n*            ARE INVOLVED.  THIS IS BECAUSE RUN TASKS           CPUTIME\n*            EXECUTE AS SEPARATE SUBTASKS (SEE CODE             CPUTIME\n*            BELOW WHICH ADDS 'RT' TIME).  ALSO, THE            CPUTIME\n*            SNODE PORTION OF A PROCESS DOES NOT CREATE         CPUTIME\n*            'PT' RECORDS BECAUSE THE PROCESS ONLY EXISTS       CPUTIME\n*            AT THE PNODE.                                      CPUTIME\n*                                                               CPUTIME\n*      NOTE: FOR DEBUGGING DISPLAYS, ADD A SYSOUT DD TO THE     CPUTIME\n*            DTF WITH THE NAME MATCHING THE NAME ON THE         CPUTIME\n*            START INSTRUCTION ABOVE.  &DMCSECT WILL BE         CPUTIME\n*            RESOLVED TO THAT NAME.  THIS MODULE NAME MUST      CPUTIME\n*            NOT BEGIN WITH 'CD'.                               CPUTIME\n*                                                               CPUTIME\n* ATTRIBUTES:    REENTRANT, REUSABLE, RELOCATABLE, REFRESHABLE        *\n*                                                                     *\n*                                                                     *\n* CSECT NAME: TSTSMF2                                                 *\n*                                                                     *\n* DSECT NAME: SMFDSECT                                                *\n*                                                                     *\n*                                                                     *\n* MACROS USED: SMFWTM                                                 *\n*              TIME                                                   *\n*              GETMAIN                                                *\n*              FREEMAIN                                               *\n*              SAVE                                                   *\n*              RETURN                                                 *\n*                                                                     *\n* DDNAMES:                                                            *\n*         NONE (WRITES TO SMF LOG DATASET VIA SMFWTM)                 *\n*                                                                     *\n*                                                                     *\n* FUNCTION:                                                           *\n*                                                                     *\n*    THIS MODULE IS ENVOKED WHEN CONNECT:Direct WRITES TO THE         *\n*    STATISTICS LOG.                                                  *\n*                                                                     *\n* ENTRY POINTS - TSTSMF2                                              *\n*                                                                     *\n*                                                                     *\n* INPUT                                                               *\n*                                                                     *\n*    REGISTER 1 POINTS TO A 4 BYTE ADDRESS FOR THE FOLLOWING          *\n*    PARAMETER: CONNECT:Direct STATISTICS RECORD                      *\n*                                                                     *\n*                                                                     *\n* REGISTER                                                            *\n*  EQUATES:                                                           *\n*                R0     =     WORK REGISTER.                          *\n*                R1     =     RDW POINTER (SMF RECORD)                *\n*                R2     =     HOLD REGISTOR FOR STATS REC ADDRESS     *\n*                R3     =     DSECT BASE.. FROM GETMAIN               *\n*                R4     =     GETMAIN WORK AREA                       *\n*                R5     =     WORK REGISTER.                          *\n*                R6     =     WORK REGISTER.                          *\n*                R7     =     WORK REGISTER.                          *\n*                R8     =     WORK REGISTER.                          *\n*                R9     =     WORK REGISTER.                          *\n*                R10    =     WORK REGISTER.                          *\n*                R11    =     TCA                                     *\n*                R12    =     BASE REGISTER.                          *\n*                R13    =     SAVEAREA POINTER.                       *\n*                R14    =     RETURN REGISTER.                        *\n*                R15    =     ENTRY POINT.                            *\n*                                                                     *\n*                                                                     *\n*        NOTE: IN AN XA ENVIRONMENT, UNLESS \"ALLOC.STORAGE=BELOW\"     *\n*              WAS SPECIFIED IN THE DTF INITIALIZATION PARMS, THE     *\n*              EXIT SHOULD BE LINKED WITH AMODE=31 BECAUSE THE        *\n*              CALLERS SAVE AREA AND THE STATISTICS RECORD WILL       *\n*              BE LOCATED ABOVE 16 MEGABYTES.                         *\n*                                                                     *\n***********************************************************************\n         DMCTR  DSECT=YES              MAP STATISTICS RECORDS   CPUTIME\n         DMTCA  DSECT=YES              MAP TASK CONTROL AREA    CPUTIME\n         DMRAT  DSECT=YES              MAP RESOURCE TABLE       1004557\n         DMFSQCB DSECT=YES             MAP SECURITY CB          R356952\n         DMXOR   DSECT=YES             MAP XOR records\n         EJECT\nD0       EQU   0                       DISP OF 0\nD12      EQU   12                      DISP OF 12\nD16      EQU   16                      DISP OF 16\nL2       EQU   2                       LENGTH OF 2\nL4       EQU   4                       LENGTH OF 4\n         EJECT\n***********************************************************************\n*        PROGRAM START                                                *\n***********************************************************************\n&DMCSECT SCENTER BASE=(R12),GETMAIN=SMFDSECT#,                  1348110X\n               AMODE=31,RMODE=24,LASTPTF=&LASTPTF,UID=&UID      1348110\n&DMCSECT SCSTART WKAREA=WKAREA,WKAREA2=WKAREA2                  CPUTIME\n         USING SMFDSECT,R13                                    1368488\n         L     R2,0(,R1)                GET STAT REC ADDR       R117181\n         USING CTR,R2                   MAP STAT RECORD         CPUTIME\n         L     R11,4(,R1)               GET SQCB ADDR           R356952\n         USING SQCB,R11                 MAP SQCB                R356952\n         L     R11,SQTCA                MAP TCA                 R356952\n         DROP  R11                      UNMAP SQCB              R356952\n         USING TCA,R11                  MAP THE TCA             CPUTIME\n         TIME      BIN\n         ST    R0,SMFTIME               TIME FOR SMF RECORD\n         ST    R1,SMFDATE               DATE FOR SMF RECORD\n         L     R1,16                    A(CVT)                  \\cb\n         L     R1,196(,R1)              A(SMCA)                 \\cb\n         MVC   SYSID,16(R1)             SET SYSTEM ID           \\cb\n         MVC   SMFSYS(2),SMFRCD         SET SMF SYS/REC TYPE\n*\n*   Change the following B to NOP if you want CPUTIME           1004557\n*\n**===>   B     NCPUTIME      AJC08003   NO CPUTIME DESIRED      1004557\n         L     R1,TARAT                 LOAD TABLE ADRS         1004557\n         USING RAT,R1                   MAP THE TABLE           1004557\n         TM    RAFLAG14,RAPLXMGR        IF PLEX MANAGER         1004557\n         BO    NCPUTIME                  CPUTIME LOGIC INVALID  1004557\n         DROP R1                                                1004557\n*\n         CLC   CTRTYPE,=CL2'PT'         IS THIS A PT REC?       CPUTIME\n         BE    CPUTIME                  BRANCH IF YES           CPUTIME\n         CLC   CTRTYPE,=CL2'CT'         IS THIS A CT REC?       CPUTIME\n         BE    CPUTIME                  BRANCH IF YES           CPUTIME\n         CLC   CTRTYPE,=CL2'RT'         IS THIS A RT REC?       CPUTIME\n         BE    CPUTIME                  BRANCH IF YES           CPUTIME\n         CLC   CTRTYPE,=CL2'RJ'         IS THIS A RJ REC?       CPUTIME\n         BNE   NCPUTIME                 BRANCH IF NOT           CPUTIME\nCPUTIME  DS    0H                       DO CPU TIME WORK        CPUTIME\n         XC    TIMEUSED,TIMEUSED                                CPUTIME\n*                                                               CPUTIME\n*     WE WILL GET THE CPU TIME IN MICROSECONDS FROM THE TCB,    CPUTIME\n*     WRITE IT OUT WITH A DISPLAY AND APPEND IT TO THE DESIRED  CPUTIME\n*     RECORDS.                                                  CPUTIME\n*                                                               CPUTIME\n*     A USER PROCESSING THESE ALTERED STAT RECORDS WOULD HAVE TOCPUTIME\n*     KNOW THAT THE CPU TIME IS THE LAST 16 BYTES OF THE RECORD CPUTIME\n*     AS 'CPUTIME=XXXXXXXX', WHERE XXXXXXXX IS IN BINARY FORMAT CPUTIME\n*     REPRESENTING MICROSECONDS.                                CPUTIME\n*                                                               CPUTIME\n         TIMEUSED STORADR=TIMEUSED,LINKAGE=SYSTEM,CPU=MIC       CPUTIME\n         CLC   CTRTYPE,=CL2'RT'         IS THIS A RT TERMINATION?PUTIME\n         BNE   NORTIME                  BRANCH IF NOT           CPUTIME\n         DISPLAY (C'&DMCSECT: LAST RT TIME=',TAWKAREA),(C,X),   1004557*\n               USRINFO                                 AJC08003 CPUTIME\n         DISPLAY (C'&DMCSECT: CURRENT TIME=',TIMEUSED),(C,X),   1004557*\n               USRINFO                                 AJC08003 CPUTIME\n*                                                               CPUTIME\n*     SINCE THE RUN TASK IS A SEPARATE SUBTASK (TCB), CPU IS'NT CPUTIME\n*     ACCOUNTED FOR IN THIS TIMEUSED CALL.  TAWKAREA CONTAINS   CPUTIME\n*     THE TIMEUSED FROM THE SUBTASK.  TO ACCURATELY REFLECT CPU CPUTIME\n*     ASSOCIATED WITH THE RUN TASK, THE VALUES MUST BE ADDED    CPUTIME\n*     TOGETHER AND STORED IN 'TIMEUSED'.                        CPUTIME\n*                                                               CPUTIME\n         CLC   TAWKAREA,=D'0'          RT TIME ZERO?            CPUTIME\n         BE    NORTIME                 YES, SKIP ADD OVERHEAD   CPUTIME\n         LM    R0,R1,TIMEUSED          LOAD TIME VALUE          CPUTIME\n         AL    R1,TAWKAREA+4           ADD LOW ORDER WORD       CPUTIME\n         BC    B'1100',NOCARRY         SKIP IF NO CARRY         CPUTIME\n         A     R0,=F'1'                ADJUST FOR CARRY         CPUTIME\nNOCARRY  DS    0H                                               CPUTIME\n         AL    R0,TAWKAREA             ADD HIGH ORDER WORD      CPUTIME\n         STM   R0,R1,TIMEUSED          STORE RESULTS            CPUTIME\nNORTIME  DS    0H                                               CPUTIME\n*              USRINFO                                 AJC08003 CPUTIME\n         DISPLAY (C'&DMCSECT: CPUTIME=',TIMEUSED,C', CTRTYPE=', 1004557*\n               CTRTYPE,C', TAID=',TAID),(C,X,C,C,C,C),USRINFO   CPUTIME\n*                                                               CPUTIME\n*     NOW APPEND THE CPUTIME (BINARY) TO THE END OF THE RECORD. CPUTIME\n*                                                               CPUTIME\n         LH    R3,CTRECLN          GET LENGTH OF STAT RECORD    CPUTIME\n         LA    R4,0(R3,R2)         POINT TO END OF CURR REC     CPUTIME\n         MVC   0(8,R4),=C'CPUTIME=' MOVE IN EYECATCHER          CPUTIME\n         MVC   8(8,R4),TIMEUSED    MOVE IN CPU TIME             CPUTIME\n         LA    R3,16(,R3)          BUMP LENGTH BY 16            CPUTIME\n         STH   R3,CTRECLN          UPDATE RECORD LENGTH         CPUTIME\nNCPUTIME DS    0H                                               CPUTIME\n*------------------------------------------------------Start-AJC08004-*\n*        Start of STATEXIT section - Process 'XO' records             *\n*---------------------------------------------------------------------*\n         CLC   CTRTYPE,=CL2'XO'      @@ IS THIS A Trace On/Off Record?\n         BNE   SMFEXIT                  NO, then ignore the record\n         DISPLAY (C'&DMCSECT: XO Record found'),(C),USRINFO\n         LR    R6,R2                    Copy R2 into R6\n         USING XOR,R6                   MAP XOR  RECORD\n         TM    XOFLG1,XOSESQ            Session=Q Specified ?\n         BO    PXORREC                  Yes, process record\n         TM    XOFLG1,XOSESR            Session=R Specified ?\n         BO    PXORREC                  Yes, process record\n         B     SMFEXIT                  NO, THEN IGNORE THE RECORD\n*---------------------------------------------------------------------*\n*        Issue WTO for XO record with MsgID = STRA035I or STRA036I    *\n*                  and (LOCAL NODE)   MsgID = STRA010I or STRA009I    *\n*---------------------------------------------------------------------*\nPXORREC  DS    0H\n         DISPLAY (C'&DMCSECT: Modify sessions'),(C),USRINFO\n         MVC   WTO(WTO#),WTOMODEL\n         MVC   CMDUSER(8),XOUID         Move in the command user\n         LA    R8,8                     Set length for Display\n       DISPLAY (C'&DMCSECT: issued by   = ',CMDUSER),(C,C),LEN=(,(R8)),*\n               USRINFO\n*--- PROCESS MSGID and SNODE\n         MVC   CMDMSID,XOMSGID          FILL IN PROCESS MSGID\n         CLC   CMDMSID,=CL8'STRA036I'   Was it a Quiesce CMD ?\n         BE    SETQUI\n         CLC   CMDMSID,=CL8'STRA010I'   Was it a local quiesce ?\n         BNE   RESUME\nSETQUI   MVC   CMDNAME,=CL3'QUI'        Move in the command name\n         B     QUIESCE\nRESUME   DS    0H\n         CLC   CMDMSID,=CL8'STRA035I'   Was it a Resume CMD ?\n         BE    SETRES\n         CLC   CMDMSID,=CL8'STRA009I'   Was it a local Resume ?\n         BNE   QUIESCE\nSETRES   MVC   CMDNAME,=CL3'RES'        No, then move in RESume\nQUIESCE  DS    0H\n         DISPLAY (C'&DMCSECT: MSG ID      = ',XOMSGID),(C,C),USRINFO\n         MVC   CMDNODE,XONODNAM  @@     FILL IN Node name for modify\n         DISPLAY (C'&DMCSECT: Snode       = ',XONODNAM),(C,C),USRINFO\n         CLC   CMDNAME,=CL3'XXX'        Was CMD sucessful ?\n         BE    SMFEXIT                  No, then skip WTO\n         CLC   XONODNAM,=CL16' '        Yes, then check nodename\n         BNE   SETWTO                   not blank, then issue WTO\n         MVC   CMDNODE,=CL16'** LOCAL-NODE **'\nSETWTO   DS    0H\n         WTO   MF=(E,WTO)\nSMFEXIT  DS    0H                                      End   AJC08004\n*   MOVE STAT RECORD TO SMF BUFFER\n         LH    R1,0(,R2)                GET LENGTH OF STAT RECORD\n*        CH    R1,=H'1006'              SEE HOW BIG THE RECORD R356952\n         CH    R1,=Y(L'DMREC)           SEE HOW BIG THE RECORD R356952\n         BH    USE1006                  IS - TOO BIG           i708600\n         CH    R1,=H'1'                 SEE IF NEGATIVE OR 0   i708600\n         BL    USE1006                     - TOO LOW           i708600\n         B     MOVEREC                  OK - MOVE IT ALL       i708600\nUSE1006  DS    0H                       USE LEN OF 1006        i708600\n*   IF HERE, THE LENGTH OF THE RECORD IS EITHER NEGATIVE OR    i708600\n*   TOO BIG TO FIT IN THE STORAGE GETMAINED ABOVE.             i708600\n*                                                              i708600\n*   YOU CAN EITHER 1) CHANGE THE LENGTH OF THE MOVE TO 1006    i708600\n*   BYTES BY USING THE \"LH\" INSTRUCTION BELOW OR, 2)           i708600\n*   CHOOSE TO JUST EXIT THE PROGRAM BY COMMENTING OUT THE      i708600\n*   \"LH\" INSTRUCTION BELOW AND UNCOMMENTING THE \"B  GETOUT\"    i708600\n*   INSTRUCTION.                                               i708600\n*                                                              i708600\n*   OPTION 1.  ADJUST MOVE LENGTH TO 1006 BYTES.               i708600\n*        LH    R1,=H'1006'                  LEN TO MOVE        R356952\n         LH    R1,=Y(L'DMREC)               LEN TO MOVE        R356952\n*   OPTION 2.  EXIT THE PROGRAM.                               i708600\n*        B     GETOUT                   BAD LENGTH - EXIT PGM. i708600\nMOVEREC  DS    0H                                              i708600\n         LR    R15,R1                   REPLICATE FOR LONG MOVE\n         LR    R5,R1                    SAVE LEN FOR LATER     i708600\n         LA    R0,0(,R2)                POINT AT STAT RECORD\n         LA    R14,DMREC                POINT AT TARGET ADDR\n         MVCL  R14,R0                MOVE STATS REC TO SMF BUFF\n****     LH    R1,0(,R2)       *****  REFRESH STATS REC LENGTH i708600\n         LR    R1,R5                    LENGTH saved EARLIER   i708600\n         AH    R1,RDWLEN                SET UP NEW RDW LENGTH\n         STH   R1,SMFRDWLL              SET TOTAL SMF RECORD LENGTH\n         XC    SMFRDWZZ,SMFRDWZZ        SET RDWZZ TO BINARY ZEROS\n         LA    R1,SMFOUT                POINT AT SMF RECORD\n         SMFWTM    (1)         AJC98272 WRITE SMF RECORD TYPE 248\n         LR    R3,R15                   SAVE RETURN CODE\n***********************************************************************\n* THIS HAS NOT BEEN CODED JUST A NOTE TO PROGRAMER                    *\n*                                                                     *\n* TEST REGISTOR 15 FOR RETURN CODE AFTER SMFWMT                       *\n* I HAVE SAVED THE RETURN CODE IN REG 3                               *\n* VALID RETURN CODES ARE                                              *\n*    REG 15 = 0  WRITE TO SMF LOG OK                                  *\n*                                                                     *\n*             4  NOT WRITTEN RECORD WILL NOT FIT IN SMF DATA SET      *\n*             8  RDW LENGTH LESS THAN 18 BYTES                        *\n*            16  SMF DATA SET \"FULL\"                                  *\n*            20  SMF RECORD SUPPRESED                                 *\n*                                                                     *\n*    SEE PAGE 56, SMF MANUAL GC28-0706                                *\n* LOAD RETURN CODE AND PASS TO CALLING PROGRAM                        *\n***********************************************************************\nGETOUT   DS    0H                       FREEMAIN AND EXIT      i708600\n         SCRETURN RC=(R3)               FREEMAIN AND EXIT      QC19765\n*QC19765 LR    R1,R13                   SET WORKAREA ADR IN R1  46497\n*QC19765 L     R13,4(,R13)              POINT TO PREV SAVE      46497\n*QC19765 ST    R3,16(,R13)              SAVE RC IN R15 LOCATION 46497\n*QC19765 FREEMAIN  R,LV=SMFDSECT#,A=(1) FREE SAVE AREA          46497\n*QC19765 DS    0H                       RETURN\n*QC19765 LM    R14,R12,12(R13)          RESTORE THE REGISTERS   R117181\n*QC19765 BSM   0,R14                    ..IF XA                 R117181\n***********************************************************************\n*   DEFINE DATA CONSTANTS                                             *\n***********************************************************************\n         DS    0F\n*DWLEN   DC    Y(DMSREC-SMFOUT)         SMF HEADER LEN         R356952\nRDWLEN   DC    Y(DMREC-SMFOUT)          SMF HEADER LEN         R356952\nSMFRCD   DC    X'02F8'         AJC98272 SMF SYSTEM TYPE (ZOS) +\n*                              AJC98272 RECORD TYPE (DEC '248', X'F8')*\nCDID     DC    C'CD '\n*                                                        Start AJC08004\nWTOMODEL WTO   'CDXOR01X Modify Session = XXX issued by CCCCCCCC MSG=xx*\n               xxxxxx Node=NNNNNNNNNNNNNNNN',ROUTCDE=(11),MF=L  46497\nWTO#     EQU   *-WTOMODEL                                       46497\n*                                                        End   AJC08004\n***********************************************************************\n*                                                                     *\n*   DEFINE DSECT FOR SMF STATISTICS  RECORD (TYPE X'F8')     AJC98272 *\n*   USER TYPE 248                                            AJC98272 *\n*                                                                     *\n***********************************************************************\nSMFDSECT DSECT\n         DS    9D                       SAVE AREA               46497\nWKAREA   DS    D           DISPLAY MACRO WORKAREA               CPUTIME\nWKAREA2  DS    8D          DISPLAY MACRO WORKAREA               CPUTIME\n         DEBUG LINKAGE=(R10,DEBUG,DEBUG2)                       CPUTIME\nDEBUG    DS    D           DISPLAY MACRO WORKAREA               CPUTIME\nDEBUG2   DS    D           DISPLAY MACRO WORKAREA               CPUTIME\nTIMEUSED DS    D                        TIMEUSED AREA           CPUTIME\n         DS    1H\n*                                                        Start AJC08004\nWTO      WTO   'CDXOR01X Modify Session = XXX issued by CCCCCCCC MSG=xx*\n               xxxxxx Node=NNNNNNNNNNNNNNNN',ROUTCDE=(11),MF=L\nCMDNAME  EQU   WTO+4+26,3\nCMDUSER  EQU   WTO+4+40,8\nCMDMSID  EQU   WTO+4+53,8\nCMDNODE  EQU   WTO+4+67,16\n         DS    F\nPACDEC   DS    D\nZONDEC   DS    D\nNMBR     DS    CL9' '\nPNUM     DS    CL8' '                                    End   AJC08004\nPAD      DS    F\nSMFOUT   EQU   *\nSMFRDWLL DS    BL2'0'                   RECORD DESC WORD LENGTH (RDWLL)\nSMFRDWZZ DS    BL2'0'                   RECORD DESC WORD FLAGS  (RDWZZ)\nSMFSYS   DS    BL1'0'                   SYSTEM TYPE\nSMFTYPE  DS    BL1'0'                   RECORD TYPE\nSMFTIME  DS    XL4                      TIME\nSMFDATE  DS    PL4                      DATE\nSYSID    DS    CL4                      SYSTEM ID\n*MSREC   EQU   *                        STATISTICS RECORD      R356952\nDMREC    DS    CL2048                   STATSTICS RECORD AREA   1348110\nSMFDSECT# EQU  *-SMFDSECT               LENGTH                  46497\n         EJECT\n***********************************************************************\n*                                                                     *\n*  MAINTENANCE:                                                       *\n*                                                                     *\n*  I708600 07-01-94: IF THERE IS AN INVALID STATISTICS RECORD         *\n*     LC   LENGTH, THEN ONLY MOVE 1006 BYTES (THE SIZE OF THE         *\n*          DMREC AREA).                                               *\n*                                                                     *\n* P46497  06/29/98 CLEANUP 'USING' FOR ASMA90 AND AMODE/RMODE         *\n*         JEL                                                         *\n*                                                                     *\n* CPUTIME 01/15/2002 - ADD CPUTIME TO CT, PT, RT AND RJ RECORDS       *\n*    TOP               (CAN BE TURNED OFF - SEE COMMENTS)             *\n*                                                                     *\n* 1004557 12/10/02 BYPASS CPUTIME LOGIC ON PLEX MANAGER AND COMMENT   *\n*         JEL      DEBUGGING DISPLAYS.  CPUTIME IS ONLY VALID ON      *\n*                  PLEX SERVERS OR STAND ALONE INSTANCES SINCE        *\n*                  PROCESSES DO NOT RUN ON PLEX MANAGERS.             *\n*                                                                     *\n* TRAC*API 08/22/2006 Document R11 (TCA) register usage.              *\n*         TOP                                                         *\n*                                                                     *\n* 1348110 09/05/07 Use SCENTER to create standard eye catcher.        *\n*         JEL                                                         *\n*                                                                     *\n* 1368488 2008/03/04 ASMA307E error due to missing USING dropped      *\n*         JEL        by SR1348110.                                    *\n*                                                                     *\n* QC16454 2010/05/19 Remove reference to obsolete mapping macros.     *\n*         JEL                                                         *\n*                                                                     *\n* DGA_STD 01FEB2011  Change to standard SMP/E naming per IBM naming   *\n*         SThompson  standards.                                       *\n*                                                                     *\n* QC19765 2011/12/13 Avoid possible S30A when RMODE(ANY) override is  *\n* QC19822 JEL        used by using SCRETURN instead of FREEMAIN.      *\n*                                                                     *\n* R356952 2012/11/15 Avoid truncation of long records by increasing   *\n* PM77776    JEL     length checked to match current maximum.         *\n*                    Also, do not assume R11 points to TCA but set    *\n*                    the address from the SQCB in the parameter list. *\n*                                                                     *\n* AJC98272 09/29/98 Change user SMF record type from 132 to 248.      *\n*          (007)                                                      *\n*                                                                     *\n* AJC08003 01/03/08 Modified version of DMGSMF code provided by C:D   *\n*                   Change CSECT name and Enable CPUTIME processing   *\n*          (004)    Change &DMCSECT to USRINFO on all DISPLAY macros  *\n*                                                                     *\n* AJC08004 01/04/08 Add code to produce a WTO (CDXOR01X) whenever a   *\n*                   XO stats record is passed for a Modify Sessions   *\n*     (50 + 5 + 12) command.                                          *\n*                                                                     *\n***********************************************************************\n         SCEND ,                                                1348110\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTSMF2$": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00R\\x01\\x13$o\\x01\\x14\\x02\\x0f\\x13T\\x00\\x1e\\x00\\x18\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2013-09-03T00:00:00", "modifydate": "2014-01-20T13:54:52", "lines": 30, "newlines": 24, "modlines": 0, "user": "SCNS03"}, "text": "//jobname  JOB (xxxx,xxxx),NDMEXIT,CLASS=T,MSGCLASS=X,NOTIFY=&SYSUID\n//*-------------------------------------------------------------------*\n//*        ASSEMBLE USER EXIT ROUTINE TSTA3390 FOR C:D V5R1.1         *\n//*        USING THE HIGH LEVEL ASSEMBLER                             *\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=ibm.hdga510.sdgamac                                     *\n// SET SAMPLIB=ibm.hdga510.sdgasamp                                   *\n// SET SDGALINK=ibm.hdga510.sdgalink                                  *\n// SET SOURCE=the.source.code.pds                                     *\n// SET LOADLIB=your.loadlib                                           *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//TONY OUTPUT DEST=LOCAL,CLASS=X,JESDS=ALL,DEFAULT=Y\n//ASSEM    EXEC HLASMCL,REGION=1024K,PARM.C='OBJECT,NODECK',\n//         PARM.L='AC=01,MAP,LET,LIST,RENT,REUS,AMODE=31,RMODE=24'\n//C.SYSLIB DD\n//         DD  DSN=&MACLIB,DISP=SHR\n//         DD  DSN=&SAMPLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//C.SYSIN  DD  DISP=SHR,DSN=&SOURCE(TSTSMF2)\n//L.SYSLIB DD  DSN=&SDGALINK,DISP=SHR\n//L.SYSLMOD DD DSN=&LOADLIB,DISP=SHR\n//L.SYSLIN DD\n//         DD  *\n  ENTRY TSTSMF2\n  NAME TSTSMF2(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTSUBM$": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00Y\\x01\\x07\\t\\x9f\\x01\\x14\\x02\\x0f\\x14\\x02\\x00\\x1e\\x00\\x1b\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2007-04-09T00:00:00", "modifydate": "2014-01-20T14:02:59", "lines": 30, "newlines": 27, "modlines": 0, "user": "SCNS03"}, "text": "//jobname  JOB (xxxx,xxxx),NDMEXIT,CLASS=T,MSGCLASS=X,NOTIFY=&SYSUID\n//*-------------------------------------------------------------------*\n//*        ASSEMBLE USER EXIT ROUTINE TSTA3390 FOR C:D V5R1.1         *\n//*        USING THE HIGH LEVEL ASSEMBLER                             *\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=ibm.hdga510.sdgamac                                     *\n// SET SAMPLIB=ibm.hdga510.sdgasamp                                   *\n// SET SDGALINK=ibm.hdga510.sdgalink                                  *\n// SET SOURCE=the.source.code.pds                                     *\n// SET LOADLIB=your.loadlib                                           *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//TONY OUTPUT DEST=LOCAL,CLASS=X,JESDS=ALL,DEFAULT=Y\n//ASSEM    EXEC HLASMCL,REGION=1024K,PARM.C='OBJECT,NODECK',\n//         PARM.L='AC=01,MAP,LET,LIST,RENT,REUS,AMODE=31,RMODE=24'\n//C.SYSLIB DD\n//         DD  DSN=&MACLIB,DISP=SHR\n//         DD  DSN=&SAMPLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//C.SYSIN  DD  DISP=SHR,DSN=&SOURCE(TSTSUBMY)\n//L.SYSLIB DD  DSN=&SDGALINK,DISP=SHR\n//L.SYSLMOD DD DSN=&LOADLIB,DISP=SHR\n//L.SYSLIN DD\n//         DD  *\n  ENTRY TSTSUBMY\n  NAME TSTSUBMY(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTSUBMY": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x005\\x01\\x12#o\\x01\\x130?\\x191\\x01B\\x01Z\\x00!\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2012-08-23T00:00:00", "modifydate": "2013-10-30T19:31:35", "lines": 322, "newlines": 346, "modlines": 33, "user": "SCNS03T"}, "text": "* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 Copyright IBM Corp. 2011\n*\n* All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\nTSTSUBMY TITLE '- SAMPLE STAGE 1-2 SUBMIT EXIT - 1.0.0'         46497\nTSTSUBMY START ,                                                46497\n         DGA$SAMP ,                                            DGA_STD\n         COPY  DMGBLS\n         DMOS                                                   46497\n         LCLC  &LASTPTF,&UID\n&LASTPTF SETC  'R000000'\n&UID     SETC  ''       USE UP TO 8 CHARACTERS FOR LOCAL MOD\n**********************************************************************\n*                                                                    *\n*                            CONNECT:Direct PROLOG                   *\n*                                                                    *\n* FUNCTION:       CONNECT:Direct STAGE 1-2 SUBMIT EXIT INTERFACE     *\n*                                                                    *\n* MODULE NAME:    TSTSUBMY (Connect:Direct SUBMIT exit)              *\n*                                                                    *\n* DATE WRITTEN:   April 2001                                         *\n*                                                                    *\n* ATTRIBUTES:     RENT,REUS (STAGE 2)                                *\n*                 NORENT,NOREUS (STAGE 1)                            *\n*                                                                    *\n* INPUT:          R1->TCQE: THE CONNECT:Direct PROCESS CONTROL BLOCK *\n*                                                                    *\n* DESCRIPTION:   This assembler program executes as a Connect:Direct *\n*                exit routine. It is intended to execute as a stage  *\n*                (2) SUBMIT exit. It is designed to check the SNODE, *\n*                AND iff the SNODE is coded in the table at the end  *\n*                of this program, then it will check to see if the   *\n*                process has requested EXTended COMPression. If so,  *\n*                the process is changed dynamically to use standard  *\n*                compression.                                   Tony *\n*                                                                    *\n*                 TO VIEW OUTPUT FROM DISPLAY, ALLOCATE DDNAME       *\n*                 \"SUBDSN\" IN THE ADDRESS SPACE WHERE THIS PROGRAM   *\n*                 WILL EXECUTE.                                      *\n*                                                                    *\n* Changes 2001-119 Comment out all of the DISPLAY macros. Sterling   *\n*                 has an intermittent problem where the DISPLAY can  *\n*                 cause an ABENDS0C6 at process submit time.    Tony *\n*                                                                    *\n* Changes 2002-171 Change exit to completely disable extended        *\n*                 compression (I.E. COMPRESS=NO).               Tony *\n*                                                                    *\n* Changes 2006-027 Change exit to check for standard compression     *\n*                 request, then disable it.                     Tony *\n*                                                                    *\n* Changes 2007-345 Changes with C:D z/OS v4.6. Use new DD of USRINFO *\n*                 for DISPLAY requests instead of SUBDSN.       Tony *\n*         2007-345 aded code to accomodate for larger format process *\n*                 > 64K. Search on TCQTCX (4) occurrances.      Tony *\n*                                                                    *\n* Changes 2013-045 Add new special prefix (CD.SEI) for extended      *\n*                 compression checking.    AJC13045             Tony *\n**********************************************************************\n         EJECT\n         DMTCQE DSECT=YES\n         EJECT\n         DMTCQSH DSECT=YES\n         EJECT\n         DMSDESCR DSECT=YES\n         EJECT\n         DMDDESCR DSECT=YES\n         EJECT\n*---------------------------------------------------------------------*\n*        LOCAL VARIABLE SECTION                                       *\n*---------------------------------------------------------------------*\nDSECT    DSECT\n         DS   18F                     OS SAVE AREA\n         DMWKAREA\n DEBUG LINKAGE=(R10,DEBUG1,DEBUG2)\nDEBUG1   DS     D\nDEBUG2   DS     D\nTMPCNT   DS     H\nDSECT#   EQU  *-DSECT                 LENGTH OF DSECT\n*-------------------------------------------------------------------*\n*     MAINLINE                                                      *\n*-------------------------------------------------------------------*\n*-------------------------------------------------------------------*\n&DMCSECT SCENTER BASE=(R12),GETMAIN=DSECT#,                     1348110X\n               AMODE=31,RMODE=24,LASTPTF=&LASTPTF,UID=&UID      1348110\n&DMCSECT SCSTART WKAREA=WKAREA,WKAREA2=WKAREA2                  1348110\n         USEBASE DSECT,R13           ADDRESSABILITY             1348110\n*-------------------------------------------------------------------*\n         L     R3,0(,R1)             LOAD TCQE ADDR\n         USEBASE TCQE,R3\n         LA    R2,0                  SET GOOD RC\n         ST    R2,TQRTNCD            STORE RC\n         LH    R11,TQSTMTN          @GET NUMBER OF STATEMENTS IN PROC\n         EJECT\n*-------------------------------------------------------------------*\n*     DISPLAY some pertinent process information from the TCQE      *\n*-------------------------------------------------------------------*\n         SR      R9,R9               Zero register\n         STH     R9,TMPCNT           Store temporary step count\n         DISPLAY (C'&DMCSECT: Proc name   = ',TQPROCNM),(C,C),USRINFO\n         DISPLAY (C'&DMCSECT: Proc #      = ',TQPROCNO),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Unq  #      = ',TQUNPRNO),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Ret= #      = ',TQRPRCNO),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Step name   = ',TQCSTEP),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: # statements= ',TQSTMTN),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Priority    = ',TQPRTY),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Psess cls BY= ',TQPRSBYT),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Psess cls BI= ',TQPRSBIT),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: P    Node   = ',TQPNODE),(C,C),USRINFO\n         DISPLAY (C'&DMCSECT: S    Node   = ',TQSNODE),(C,C),USRINFO\n*-------------------------------------------------------------------*\n*     Move onto the TCQSH Control Block                             *\n*-------------------------------------------------------------------*\n         XR    R7,R7                 CLEAR R7\n         ICM   R7,B'0011',TQCSPRD    GET OFFSET TO FIRST STATEMENT\n         TM    TQFLAGA,TQGT64K       IS NEW FORMAT               TCQTCX\n         BNO   OLDFMT                BRANCH IF NOT               TCQTCX\n         SLL   R7,4                  X 16                        TCQTCX\nOLDFMT   DS    0H                                                TCQTCX\n         LR    R4,R3                 (TCQE)\n         AR    R4,R7                 ADD TO TCQE ADDRESS\nPROCLOOP EQU     *\n         USEBASE TCQSH,R4            POINT TO STEP HEADER\n         CLC     TSHFUNCD,=X'0050'   IS THIS A COPY?\n         BNE     NEXTSTEP           $NO, SCRAM\n*-------------------------------------------------------------------*\n*     Check to see if the Node is permitted to use compress ext.    *\n*-------------------------------------------------------------------*\n         LA      R5,PREFIX1          Load address of prefix\n         CLC     0(L'PREFIX1,R5),TQSNODE  Is this a speical prefix?\n         BE      NEXTCHCK            Yes, proceed to the next check\n         LA      R5,PREFIX2          Load address of prefix\n         CLC     0(L'PREFIX2,R5),TQSNODE  Is this a speical prefix?\n         BE      NEXTCHCK            Yes, proceed to the next check\n         LA      R5,PREFIX3          Load address of prefix\n         CLC     0(L'PREFIX3,R5),TQSNODE  Is this a speical prefix?\n         BE      NEXTCHCK            Yes, proceed to the next check\n         LA      R5,PREFIX4          Load address of prefix\n         CLC     0(L'PREFIX4,R5),TQSNODE  Is this a speical prefix?\n         BE      NEXTCHCK            Yes, proceed to the next check\n         LA      R5,PREFIX5          Load address of prefix\n         CLC     0(L'PREFIX5,R5),TQSNODE  Is this a speical prefix?\n         BE      NEXTCHCK            Yes, proceed to the next check\n         LA      R5,PREFIX6          Load address of prefix  AJC13045\n         CLC     0(L'PREFIX6,R5),TQSNODE  Is this a speical prefix?\n         BE      NEXTCHCK            Yes, proceed to the next check\n         LA      R5,NODETAB          Load address of Node table\nNODELOOP EQU     *\n         CLC     0(4,R5),=F'0'       End of Table?\n         BE      EXIT                Not found, then exit\n         CLC     0(NODELEN,R5),TQSNODE   IS this node in the table?\n         BE      NEXTCHCK            Yes, proceed to the next check\n         LA      R5,NODELEN(,R5)     Bump to the next entry\n         B       NODELOOP            Loop\n*-------------------------------------------------------------------*\n*     Check to see if the Process is using a special Class          *\n*-------------------------------------------------------------------*\nNEXTCHCK EQU     *\n         DISPLAY (C'&DMCSECT: Snode Found in Table'),(C),USRINFO\n         CLI     TQPRSBYT,X'00'      Special CLass?\n         BNE     DISACOMP            No, Disable EXT COMP\n         CLI     TQPRSBIT,X'80'      Special CLass?\n         BNE     DISACOMP            No, Disable EXT COMP\n         DISPLAY (C'&DMCSECT: Special Class '),(C),USRINFO\n         B       EXIT                Yes, just exit\n*\n* IF THIS IS A MULTI-STEP PROCESS, AND YOU WANT TO GO TO THE\n* NEXT STATEMENT IN THE PROCESS, ADD TSHRECLN TO R4. YOU WILL\n* THEN BE POINTING AT THE NEXT TCQSH (STEP HEADER)\n*\nDISACOMP EQU     *\n         DISPLAY (C'&DMCSECT: Disable ExtCmp'),(C),USRINFO\n         LR      R7,R4               OFFSET IS FROM START OF TCQSH\n         AH      R7,TSHCBHLN         POINT TO SRC DATASET DESCRIPTOR\n         USEBASE SDESCR,R7           ADDRESSABILITY\n         LR      R8,R7               POINT TO DEST DATASET DESCRIPTOR\n         AH      R8,S1SVSLNG         IMMEDIATELY FOLLOWING SDESCR\n         USEBASE DDESCR,R8           ADDRESSABILITY\n         TM      D1FLAG1,D1DSN       IS DSN SPECIFIED?\n         BNO     NEXTSTEP           $NO, FORGET IT.\n         LR      R2,R4               BASE OF TCQSH\n         AH      R2,D1DDSN           GET DISPLACEMENT TO DEST DSNAME\n         XR      R9,R9               CLEAR R9\n         ICM     R9,B'0011',0(R2)    SET LENGTH OF DSNAME\n         AH      R9,=H'2'            ADD 2 FOR INCLUSIVE LEN\n         DISPLAY (C'&DMCSECT: DEST DSNAME = ',2(R2)),(C,C),USRINFO,    *\n               LEN=(,(R9))\n         DISPLAY (C'&DMCSECT: B4-D1FLAG11 = ',D1FLAG11),(C,X),USRINFO\n         SLR     R5,R5               Clear R5\n         AH      R5,=H'2'            Set length to 2\n         DISPLAY (C'&DMCSECT:    D1FLAG12 = ',D1FLAG12),(C,X),USRINFO, *\n               LEN=(,(R5))\n         DISPLAY (C'&DMCSECT:    D1FLAG13 = ',D1FLAG13),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1FLAG14 = ',D1FLAG14),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1razlvl = ',D1RAZLVL),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1razwin = ',D1RAZWIN),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1rLzmem = ',D1RAZMEM),(C,X),USRINFO\n*\n* R2 NOW POINTS TO THE DESTINATION DATASET NAME FOR THE FIRST COPY\n* STEP IN THE PROCESS. THE DATASET NAME IS A HALFWORD LEN FIELD\n* IMMEDIATELY FOLLOWED BY THE DATASET NAME ITSELF.\n*\n         TM      S1FLAG1,S1DSN       IS DSN SPECIFIED?\n         BNO     NEXTSTEP           $NO, FORGET IT.\n         LR      R6,R4               BASE OF TCQSH\n         AH      R6,S1DDSN           GET DISPLACEMENT TO SRC DSNAME\n         XR      R9,R9               CLEAR R9\n         ICM     R9,B'0011',0(R6)    SET LENGTH OF DSNAME\n         AH      R9,=H'2'            ADD 2 FOR INCLUSIVE LEN\n         DISPLAY (C'&DMCSECT: SRCE DSNAME = ',2(R6)),(C,C),USRINFO,    *\n               LEN=(,(R9))\n         DISPLAY (C'&DMCSECT: B4-S1FLAG11 = ',S1FLAG11),(C,X),USRINFO\n         SLR     R5,R5               Clear R5\n         AH      R5,=H'2'            Set length to 2\n         DISPLAY (C'&DMCSECT: S1FLAG12 = ',S1FLAG12),(C,X),USRINFO,    *\n               LEN=(,(R5))\n         DISPLAY (C'&DMCSECT: S1FLAG13 = ',S1FLAG13),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: S1FLAG14 = ',S1FLAG14),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: S1razlvl = ',S1RAZLVL),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: S1razwin = ',S1RAZWIN),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: S1rLzmem = ',S1RAZMEM),(C,X),USRINFO\n*\n* R6 NOW POINTS TO THE SOURCE DATASET NAME FOR THE FIRST COPY\n* STEP IN THE PROCESS. THE DATASET NAME IS A HALFWORD LEN FIELD\n* IMMEDIATELY FOLLOWED BY THE DATASET NAME ITSELF.\n*\n         TM    S1FLAG13,S1CMPEXT    HAS USER SPEC. EXTENDED COMPRESSION\n         BNZ   DISACMP2            $YES,THEN DISBALE\n         TM    S1FLAG11,S1COMP      HAS USER SPEC. STANDARD COMPRESSION\n         BZ    NEXTSTEP            $NO, THEN NEXTSTEP\nDISACMP2 EQU     *\n         NI    D1FLAG13,X'7F'       YES, THEN RESET D1CMPEXT FLAG\n         NI    S1FLAG13,X'7F'       YES, THEN RESET S1CMPEXT FLAG\n         NI    D1FLAG11,X'7F'       YES, THEN RESET D1COMP   FLAG\n         NI    S1FLAG11,X'7F'       YES, THEN RESET S1COMP   FLAG\n         SLR     R5,R5               Clear R5\n         AH      R5,=H'2'            Set length to 2\n         DISPLAY (C'&DMCSECT: AF-D1FLAG11 = ',D1FLAG11),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1FLAG12 = ',D1FLAG12),(C,X),USRINFO, *\n               LEN=(,(R5))\n         DISPLAY (C'&DMCSECT:    D1FLAG13 = ',D1FLAG13),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1FLAG14 = ',D1FLAG14),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1razlvl = ',D1RAZLVL),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1razwin = ',D1RAZWIN),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    D1rLzmem = ',D1RAZMEM),(C,X),USRINFO\n*\n         DISPLAY (C'&DMCSECT: AF-S1FLAG11 = ',S1FLAG11),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    S1FLAG12 = ',S1FLAG12),(C,X),USRINFO, *\n               LEN=(,(R5))\n         DISPLAY (C'&DMCSECT:    S1FLAG13 = ',S1FLAG13),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    S1FLAG14 = ',S1FLAG14),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    S1razlvl = ',S1RAZLVL),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    S1razwin = ',S1RAZWIN),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:    S1rLzmem = ',S1RAZMEM),(C,X),USRINFO\n*\n***********************************************************************\n*                            NOTE                                     *\n***********************************************************************\n*   IF MODIFICATIONS ARE MADE TO EITHER THE SRC OR THE DESTINATION    *\n*        DATASET NAMES, THEIR CORRESPONDING LENGTH FIELDS MUST BE     *\n*          MODIFIED AS WELL TO REFLECT THE CHANGES.                   *\n***********************************************************************\nNEXTSTEP DS      0H\n         CLC     TQSTMTN,=H'1'      @More than One step?\n         BNP     EXIT               @NO, Then we are done.\n*        STH     R11,TMPCNT          STORE STEP COUNT\n         LH      R9,TMPCNT           Load temporary step coutn\n         LA      R9,1(R9)            Increment step counter\n         STH     R9,TMPCNT           STORE STEP COUNT\n         DISPLAY (C'&DMCSECT: Rel Step ',TMPCNT),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT:     Type ',TSHFUNCD),(C,X),USRINFO\n         AH      R4,TSHRECLN        @Yes, point to next TCQSH\n         BCT     R11,PROCLOOP       @Yes, then check next step\n         DISPLAY (C'&DMCSECT: End of Proc '),(C),USRINFO\nEXIT     DS      0H\n         L       R15,TQRTNCD         LOAD RC\n*     SCRETURN WILL FREE SCENTER STORAGE AND RETURN TO CALLER\n         SCRETURN RC=(R15)\n*****************************************\n*          Node table                   *\n*****************************************\nPREFIX1  DC    C'ODR.CTC'             odr css nodes           AJC09237\nPREFIX2  DC    C'ODR.TST'             odr css nodes           AJC05223\nPREFIX3  DC    C'SEI.TEST'            BIS Nodes               AJC11305\nPREFIX4  DC    C'SEITEST'             ODR Test nodes          AJC05223\nPREFIX5  DC    C'SEIPS'               Performance station     AJC05223\nPREFIX6  DC    C'CD.SEIT'             BIS NODES               AJC13045\nNODETAB  EQU   *\n         DC    CL16'BIS.CTCBISPLP01 ' 10.52.50.6\nNODELEN  EQU   *-NODETAB              Length of one entry\n         DC    CL16'BIS.SEITESTNODE1' 172.16.115.27'\n         DC    CL16'CD.NODENAME1    ' 10.5.40.51\n         DC    CL16'CD.TESTNODE1    ' 10.5.40.84\n         DC    CL16'CD.DEV1         ' 10.72.10.241            AJC05160\n         DC    CL16'CD.TRUSTME2     ' 10.5.70.85              AJC06024\n         DC    CL16'CD.TRUSTME3     ' 10.5.40.60              AJC06024\n         DC    CL16'CSSZONEVM01     ' 10.52.32.122            AJC10257\n         DC    CL16'CSVIAG          ' 172.16.105.42\n         DC    CL16'CTCBISAPP05     ' 10.52.50.80             AJC08004\n         DC    CL16'CTSQA1          ' 10.52.10.143            AJC06024\n         DC    CL16'CTSQA2          ' 10.52.10.133            AJC06024\n         DC    CL16'CUSTODY01       ' 10.5.40.106\n         DC    CL16'FLYERSODR       ' 10.9.30.2               AJC05160\n         DC    CL16'FRSEINT2        ' 10.91.40.47\n         DC    CL16'JOSHUA01        ' 10.4.40.31\n         DC    CL16'OPSCD2A         ' 10.65.100.1\n         DC    CL16'SEIMAP01        ' 172.16.105.133\n         DC    CL16'SEINDM02        ' NDM Node name\n         DC    CL16'SEINDM03        ' NDM Node name\n         DC    CL16'SEINDM04        ' NDM Node name\n         DC    CL16'SEINDM05        ' NDM Node name\n         DC    CL16'SEIRTWDB01      ' 10.65.40.44\n         DC    CL16'T3KENG          ' 10.1.40.146             AJC06024\n         DC    F'0'                   End of the Table\nTABLEND  EQU   *                      END OF Node name table\nTABLLEN  DC    A(TABLEND-NODETAB)     Length of table\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTXSIZ$": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x133\\x9f\\x01\\x14\\x02\\x0f\\x14\\x06\\x00\\x1e\\x00\\x19\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-12-05T00:00:00", "modifydate": "2014-01-20T14:06:55", "lines": 30, "newlines": 25, "modlines": 0, "user": "SCNS03"}, "text": "//jobname  JOB (xxxx,xxxx),NDMEXIT,CLASS=T,MSGCLASS=X,NOTIFY=&SYSUID\n//*-------------------------------------------------------------------*\n//*        ASSEMBLE USER EXIT ROUTINE TSTA3390 FOR C:D V5R1.1         *\n//*        USING THE HIGH LEVEL ASSEMBLER                             *\n//*        Update the following \"SET\" statements.                     *\n//*                                                                   *\n// SET MACLIB=ibm.hdga510.sdgamac                                     *\n// SET SAMPLIB=ibm.hdga510.sdgasamp                                   *\n// SET SDGALINK=ibm.hdga510.sdgalink                                  *\n// SET SOURCE=the.source.code.pds                                     *\n// SET LOADLIB=your.loadlib                                           *\n//*                                                                   *\n//*-------------------------------------------------------------------*\n//TONY OUTPUT DEST=LOCAL,CLASS=X,JESDS=ALL,DEFAULT=Y\n//ASSEM    EXEC HLASMCL,REGION=1024K,PARM.C='OBJECT,NODECK',\n//         PARM.L='AC=01,MAP,LET,LIST,RENT,REUS,AMODE=31,RMODE=24'\n//C.SYSLIB DD\n//         DD  DSN=&MACLIB,DISP=SHR\n//         DD  DSN=&SAMPLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//C.SYSIN  DD  DISP=SHR,DSN=&SOURCE(TSTXSIZP)\n//L.SYSLIB DD  DSN=&SDGALINK,DISP=SHR\n//L.SYSLMOD DD DSN=&LOADLIB,DISP=SHR\n//L.SYSLIN DD\n//         DD  *\n  ENTRY TSTXSIZP\n  NAME TSTXSIZP(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSTXSIZP": {"ttr": 3846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00@\\x01\\x133\\x9f\\x01\\x135?\\x114\\x00\\xcd\\x00\\xc0\\x00\\xcd\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2013-12-05T00:00:00", "modifydate": "2013-12-19T11:34:40", "lines": 205, "newlines": 192, "modlines": 205, "user": "SCNS03"}, "text": "* ********************************************************************\n* Licensed Materials - Property of IBM\n*\n* 5655-X01 Copyright IBM Corp. 2011\n*\n* All Rights Reserved\n*\n* US Government Users Restricted Rights - Use, duplication or\n* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.\n* ********************************************************************\nTSTXSIZP TITLE '- SAMPLE STAGE 1-2 SUBMIT EXIT - 1.0.0'         46497\nTSTXSIZP START ,                                                46497\n         DGA$SAMP ,                                            DGA_STD\n         COPY  DMGBLS\n         DMOS                                                   46497\n         LCLC  &LASTPTF,&UID\n&LASTPTF SETC  'R000000'\n&UID     SETC  ''       USE UP TO 8 CHARACTERS FOR LOCAL MOD\n**********************************************************************\n*                                                                    *\n*                            CONNECT:Direct PROLOG                   *\n*                                                                    *\n* FUNCTION:       CONNECT:Direct STAGE 1-2 SUBMIT EXIT INTERFACE     *\n*                                                                    *\n* MODULE NAME:    TSTXSIZP (Connect:Direct SUBMIT exit)              *\n*                                                                    *\n* DATE WRITTEN:   April 2001                                         *\n*                                                                    *\n* ATTRIBUTES:     RENT,REUS (STAGE 2)                                *\n*                 NORENT,NOREUS (STAGE 1)                            *\n*                                                                    *\n* INPUT:          R1->TCQE: THE CONNECT:Direct PROCESS CONTROL BLOCK *\n*                                                                    *\n* DESCRIPTION:   This assembler program executes as a Connect:Direct *\n*                exit routine. It is intended to execute as a stage  *\n*                (2) SUBMIT exit. It is designed to check the process*\n*                AND issue DISPLAYs to document the step type and    *\n*                size of the process. It is intended to be a tool to *\n*                aid in determining the proper CISIZE for the VSAM   *\n*                TCQ dataset. Ideally, the TCFQ should fix an entire *\n*                process in one CI.                             Tony *\n*                                                                    *\n*                 TO VIEW OUTPUT FROM DISPLAY, ALLOCATE DDNAME       *\n*                 \"SUBDSN\" IN THE ADDRESS SPACE WHERE THIS PROGRAM   *\n*                 WILL EXECUTE.                                      *\n*                                                                    *\n* Changes 2007-345 Changes with C:D z/OS v4.6. Use new DD of USRINFO *\n*                 for DISPLAY requests instead of SUBDSN.       Tony *\n*         2007-345 aded code to accomodate for larger format process *\n*                 > 64K. Search on TCQTCX (4) occurrances.      Tony *\n*                                                                    *\n**********************************************************************\n         EJECT\n         DMTCQE DSECT=YES\n         EJECT\n         DMTCQSH DSECT=YES\n         EJECT\n         DMSDESCR DSECT=YES\n         EJECT\n         DMDDESCR DSECT=YES\n         EJECT\n*---------------------------------------------------------------------*\n*        LOCAL VARIABLE SECTION                                       *\n*---------------------------------------------------------------------*\nDSECT    DSECT\n         DS   18F                     OS SAVE AREA\n         DMWKAREA\n DEBUG LINKAGE=(R10,DEBUG1,DEBUG2)\nDEBUG1   DS     D\nDEBUG2   DS     D\nPACDEC   DS     D\nZONDEC   DS     D\nZONCNT   DS     D\nTMPCNT   DS     H\nPSIZE    DS     H\nTSIZE    DS     F\nDSECT#   EQU  *-DSECT                 LENGTH OF DSECT\n*-------------------------------------------------------------------*\n*     MAINLINE                                                      *\n*-------------------------------------------------------------------*\n&DMCSECT SCENTER BASE=(R12),GETMAIN=DSECT#,                     1348110X\n               AMODE=31,RMODE=24,LASTPTF=&LASTPTF,UID=&UID      1348110\n&DMCSECT SCSTART WKAREA=WKAREA,WKAREA2=WKAREA2                  1348110\n         USEBASE DSECT,R13           ADDRESSABILITY             1348110\n         L     R3,0(,R1)             LOAD TCQE ADDR\n         USEBASE TCQE,R3\n         LA    R2,0                  SET GOOD RC\n         ST    R2,TQRTNCD            STORE RC\n         LH    R11,TQSTMTN          @GET NUMBER OF STATEMENTS IN PROC\n         EJECT\n*-------------------------------------------------------------------*\n*     DISPLAY some pertinent process information from the TCQE      *\n*-------------------------------------------------------------------*\n         SR      R9,R9               Zero register\n         STH     R9,TMPCNT           Store temporary step count\n         DISPLAY (C'&DMCSECT: Proc name   = ',TQPROCNM),(C,C),USRINFO\n**       DISPLAY (C'&DMCSECT: Proc #      = ',TQPROCNO),(C,X),USRINFO\n**       DISPLAY (C'&DMCSECT: Step name   = ',TQCSTEP),(C,X),USRINFO\n         XR      R8,R8               Clear R8\n         LA      R8,1616             account for Hdr size\n         ST      R8,TSIZE            Store Proc size\n         CVD     R8,PACDEC           Convert to packed decimal\n         UNPK    ZONDEC,PACDEC+4(4)  unpack\n         OI      ZONDEC+7,x'F0'      take care of sign field\n         CVD     R11,PACDEC          Convert to packed decimal\n         UNPK    ZONCNT,PACDEC+4(4)  unpack\n         OI      ZONCNT+7,x'F0'      take care of sign field\n*>x      DISPLAY (C'&DMCSECT: # statements= ',TQSTMTN,                 +\n               C' Type Hdrx  size ',TSIZE),(C,X,C,X),USRINFO\n         DISPLAY (C'&DMCSECT: # statements= ',ZONCNT,                  +\n               C' Type Hdr  size ',ZONDEC),(C,C,C,C),USRINFO\n         DISPLAY (C'&DMCSECT: Priority    = ',TQPRTY),(C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Psess cls BY= ',TQPRSBYT,                +\n               C'   BI= ',TQPRSBIT),(C,X,C,X),USRINFO\n         DISPLAY (C'&DMCSECT: P    Node   = ',TQPNODE),(C,C),USRINFO\n         DISPLAY (C'&DMCSECT: S    Node   = ',TQSNODE),(C,C),USRINFO\n*-------------------------------------------------------------------*\n*     Move onto the TCQSH Control Block                             *\n*-------------------------------------------------------------------*\n         XR    R7,R7                 CLEAR R7\n         ICM   R7,B'0011',TQCSPRD    GET OFFSET TO FIRST STATEMENT\n         TM    TQFLAGA,TQGT64K       IS NEW FORMAT               TCQTCX\n         BNO   OLDFMT                BRANCH IF NOT               TCQTCX\n         SLL   R7,4                  X 16                        TCQTCX\nOLDFMT   DS    0H                                                TCQTCX\n         LR    R4,R3                 (TCQE)\n         AR    R4,R7                 ADD TO TCQE ADDRESS\nPROCLOOP EQU     *\n         USEBASE TCQSH,R4            POINT TO STEP HEADER\nNEXTSTEP DS      0H\n         CLC     TQSTMTN,=H'1'      @More than One step?\n         BNP     EXIT               @NO, Then we are done.\n*        STH     R11,TMPCNT          STORE STEP COUNT\n         LH      R9,TMPCNT           Load temporary step coutn\n         LA      R9,1(R9)            Increment step counter\n         STH     R9,TMPCNT           STORE STEP COUNT\n         XR      R8,R8               Clear R8\n         CLC     TSHFUNCD,=X'0050'   IS THIS A COPY?\n         BNE     NOCOPY              NO, GO to NEXT Step\n         AH      R8,=H'1024'         Set length to 1024\nNOCOPY   DS      0H\n         CLC     TSHFUNCD,=X'0054'   IS THIS A RUNJOB ?\n         BNE     NOSUBM              NO, GO to NEXT Step\n         AH      R8,=H'176'          Set length to 176\nNOSUBM   DS      0H\n         CLC     TSHFUNCD,=X'0058'   IS THIS A SUBMIT ?\n         BNE     NORUNJ              NO, GO to NEXT Step\n         AH      R8,=H'176'          Set length to 176 (can be bigger)\n         AH      R8,TQSUBLNG         account for DSN len in SUBMT\n*>Diag   DISPLAY (C'&DMCSECT: Rel Steps',TMPCNT,                       +\n               C'      Type ',TSHFUNCD,                                +\n               C' DSN= ',TQSUBLNG),(C,X,C,X,C,X),USRINFO\nNORUNJ   DS      0H\n         CLC     TSHFUNCD,=X'0059'   IS THIS A RUNTASK?\n         BNE     NORUNT              NO, GO to NEXT Step\n         AH      R8,=H'128'          Set length to 128\nNORUNT   DS      0H\n         CLC     TSHFUNCD,=X'0501'   IS THIS A GOTO ?\n         BNE     NOGOTO              NO, GO to NEXT Step\n         AH      R8,=H'96'           Set length to 96\nNOGOTO   DS      0H\n         CLC     TSHFUNCD,=X'0502'   IS THIS A IF ?\n         BNE     NOIF                NO, GO to NEXT Step\n         AH      R8,=H'208'          Set length to 208\nNOIF     DS      0H\n         CLC     TSHFUNCD,=X'0504'   IS THIS A EXIT ?\n         BNE     NOEXIT              NO, GO to NEXT Step\n         AH      R8,=H'96'           Set length to 96\nNOEXIT   DS      0H\n         STH     R8,PSIZE            STORE PROC SIZE\n         L       R15,TSIZE           Load running total\n         AR      R15,R8              Add Step size total\n         ST      R15,TSIZE           Store running total\n         CVD     R8,PACDEC           Convert to packed decimal\n         UNPK    ZONDEC,PACDEC+4(4)  unpack\n         OI      ZONDEC+7,x'F0'      take care of size\n         CVD     R9,PACDEC           Convert to packed decimal\n         UNPK    ZONCNT,PACDEC+4(4)  unpack\n         OI      ZONCNT+7,x'F0'      take care of size\n*>x      LH      R8,PSIZE            Store running total\n*>Diag   DISPLAY (C'&DMCSECT: Rel Stepx',TMPCNT,                       +\n               C'      Type ',TSHFUNCD,                                +\n               C' size ',TSHRECLN),(C,X,C,X,C,X),USRINFO\n         DISPLAY (C'&DMCSECT: Rel Step ',ZONCNT,                       +\n               C'   Type ',TSHFUNCD,                                   +\n               C' size ',ZONDEC),(C,C,C,X,C,C),USRINFO\n**       DISPLAY (C'&DMCSECT: (Diag) ',(R8),(R15),TSIZE),              +\n               (C,X,X,X),USRINFO\n         CVD     R15,PACDEC          Convert to packed decimal\n         UNPK    ZONDEC,PACDEC+4(4)  unpack\n         OI      ZONDEC+7,x'F0'      take care of size\n         L       R15,TSIZE           Store running total\n**       DISPLAY (C'&DMCSECT: (Dia2) ',(R8),(R15),ZONDEC),             +\n               (C,X,X,C),USRINFO\n         AH      R4,TSHRECLN        @Yes, point to next TCQSH\n         BCT     R11,PROCLOOP       @Yes, then check next step\n*>x      DISPLAY (C'&DMCSECT: End of Processx',                        +\n               C'          Total size = ',TSIZE),(C,C,X),USRINFO\n         DISPLAY (C'&DMCSECT: End of Process ',                        +\n               C'          Total size = ',ZONDEC),(C,C,C),USRINFO\nEXIT     DS      0H\n         L       R15,TQRTNCD         LOAD RC\n*     SCRETURN WILL FREE SCENTER STORAGE AND RETURN TO CALLER\n         SCRETURN RC=(R15)\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XO": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x10\\x12\\x0f\\x01\\x10\\x12\\x0f\\x12\\x06\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-30T00:00:00", "modifydate": "2010-04-30T12:06:41", "lines": 13, "newlines": 13, "modlines": 0, "user": "SCNS03"}, "text": "PROC 1 PARMS STARTT((TODAY,00:00))\n*** *****************************\n*** * SELECT STATISTICS *\n*** * *\n*** * SELECT STATS XO *\n*** * *\n*** *****************************\n***\n*** F NDM,STATSUM\n***\n  SEL STAT WHERE( -\n      TYPE=XO) -\n      TABLE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT904/FILE904.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT904", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}