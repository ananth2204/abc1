{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012502000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2057510, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE622.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2057510, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2057510, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE622.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00!\\x04'", "DS1TRBAL": "b'\\xa58'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x8b\\x00\\x08\\x04\\x8d\\x00\\x0b\\x00\"'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04;\\x00\\x00\\x01\\x03\\x11\\x1f\\x01\\x03\\x11\\x1f\\x07\\x16\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf9@@@'", "ispf": {"version": "04.59", "flags": 0, "createdate": "2003-04-21T00:00:00", "modifydate": "2003-04-21T07:16:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-459"}, "text": "REGULAR CBT TAPE - VERSION 459    FILE:  622\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT459.FILE622\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    12000   PO\n\n   PDS117I 24 MEMBERS COUNTED; CUMULATIVE SIZE IS 19,055 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/21/03    07:15:58    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$RECEIVE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00B\\x00\\x99\\t\\x0f\\x01\\x03\\x10O\\x10\\x08\\x00%\\x00\\t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1999-03-31T00:00:00", "modifydate": "2003-04-14T10:08:42", "lines": 37, "newlines": 9, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBT  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - *//\n//*                                                       *//\n//*   TSO RECEIVE JOB FOR MATRIX LIBRARIES                *//\n//*                                                       *//\n//*     VOL( ) PARAMETER IS OPTIONAL                      *//\n//*                                                       *//\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(API)')\n DSN('userid.MATRIX.V2.API.MACLIB') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(COBCOPY)')\n DSN('userid.MATRIX.V2.COBOL.COPYLIB') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(MATXCNTL)')\n DSN('userid.MATRIX.V2.CNTL') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(MATXLOAD)')\n DSN('userid.MATRIX.V2.LOAD') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(MATXOBJ)')\n DSN('userid.MATRIX.V2.OBJECT') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(MATXPARM)')\n DSN('userid.MATRIX.V2.PARMS') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(MATXPROC)')\n DSN('userid.MATRIX.V2.PROCLIB') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(SAMPLOAD)')\n DSN('userid.MATRIX.V2.SAMPLE.LOAD') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(SAMPMAC)')\n DSN('userid.MATRIX.V2.SAMPLE.MACLIB') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(SAMPOBJ)')\n DSN('userid.MATRIX.V2.SAMPLE.OBJECT') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(SAMPSRCE)')\n DSN('userid.MATRIX.V2.SAMPLE.SOURCE') VOL(DATA04) UNIT(SYSALLDA)\n RECEIVE INDSN('CBT.CBT459.FILE622.PDS(UTILLOAD)')\n DSN('userid.MATRIX.UTILITY.LOAD') VOL(DATA04) UNIT(SYSALLDA)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$RECESBG": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\"\\x00\\x99\\t\\x0f\\x01\\x03\\x10O\\x04S\\x00%\\x00\\t\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1999-03-31T00:00:00", "modifydate": "2003-04-14T04:53:22", "lines": 37, "newlines": 9, "modlines": 0, "user": "IBMUSER"}, "text": "//SBGOLOBT  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - *//\n//*                                                       *//\n//*   TSO RECEIVE JOB FOR MATRIX LIBRARIES                *//\n//*                                                       *//\n//*     VOL( ) PARAMETER IS OPTIONAL                      *//\n//*                                                       *//\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(API)')\n DSN('SBGOLOB.MATRIX.V2.API.MACLIB')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(COBCOPY)')\n DSN('SBGOLOB.MATRIX.V2.COBOL.COPYLIB')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(MATXCNTL)')\n DSN('SBGOLOB.MATRIX.V2.CNTL')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(MATXLOAD)')\n DSN('SBGOLOB.MATRIX.V2.LOAD')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(MATXOBJ)')\n DSN('SBGOLOB.MATRIX.V2.OBJECT')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(MATXPARM)')\n DSN('SBGOLOB.MATRIX.V2.PARMS')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(MATXPROC)')\n DSN('SBGOLOB.MATRIX.V2.PROCLIB')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(SAMPLOAD)')\n DSN('SBGOLOB.MATRIX.V2.SAMPLE.LOAD')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(SAMPMAC)')\n DSN('SBGOLOB.MATRIX.V2.SAMPLE.MACLIB')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(SAMPOBJ)')\n DSN('SBGOLOB.MATRIX.V2.SAMPLE.OBJECT')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(SAMPSRCE)')\n DSN('SBGOLOB.MATRIX.V2.SAMPLE.SOURCE')  UNIT(SYSALLDA)\n RECEIVE INDSN('SBGOLOB.CBT459.FILE622(UTILLOAD)')\n DSN('SBGOLOB.MATRIX.UTILITY.LOAD')  UNIT(SYSALLDA)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE622": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04;\\x00\\x00\\x01\\x03\\x11\\x1f\\x01\\x03\\x11\\x1f\\x07\\x15\\x00D\\x00D\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf9@@@'", "ispf": {"version": "04.59", "flags": 0, "createdate": "2003-04-21T00:00:00", "modifydate": "2003-04-21T07:15:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "CBT-459"}, "text": "//***FILE 622 is from Simon Spanchak and contains his MATRIX        *   FILE 622\n//*           software package.  This package is copyrighted, but   *   FILE 622\n//*           the author allows its use for free for educational    *   FILE 622\n//*           and non-commercial usage under conditions of the      *   FILE 622\n//*           copyright notice.                                     *   FILE 622\n//*                                                                 *   FILE 622\n//*           MATRIX allows non-system-oriented application         *   FILE 622\n//*           programmers to easily create large data spaces,       *   FILE 622\n//*           place data in them, and access the data.              *   FILE 622\n//*           MATRIX enables cross systems (sysplex) communications *   FILE 622\n//*           and cross systems events and large scale tabling.     *   FILE 622\n//*           This package contains Application Programming         *   FILE 622\n//*           Interfaces (API's) for C, COBOL, and Assembler.       *   FILE 622\n//*                                                                 *   FILE 622\n//*           email:  Simon Spanchak <spancha@exspans.com>          *   FILE 622\n//*           site :  www.exspans.com                               *   FILE 622\n//*                                                                 *   FILE 622\n//*    Matrix V2.2                                                  *   FILE 622\n//*                                                                 *   FILE 622\n//*    Matrix provides an applications programming interface        *   FILE 622\n//*    (API) to enable programmers to take advantage of the         *   FILE 622\n//*    power of OS/390 and z/OS without the in-depth knowledge      *   FILE 622\n//*    of systems internals, normally required.  Matrix             *   FILE 622\n//*    provides large scale data sharing, communications and        *   FILE 622\n//*    synchronization within the sysplex.  Also provides           *   FILE 622\n//*    large scale table management and Parallel program            *   FILE 622\n//*    execution.                                                   *   FILE 622\n//*                                                                 *   FILE 622\n//*    Documentation                                                *   FILE 622\n//*                                                                 *   FILE 622\n//*    Several manuals have been provided.  These are member        *   FILE 622\n//*    names beginning with MXM*****.  Current manuals provided     *   FILE 622\n//*    are:                                                         *   FILE 622\n//*                                                                 *   FILE 622\n//*       MXMCONCP  -  Concepts                                     *   FILE 622\n//*       MXMINSTL  -  Installation and Running                     *   FILE 622\n//*       MXMBAT01  -  Batch utility guide                          *   FILE 622\n//*       MXMTSO01  -  TSO access to MATRIX                         *   FILE 622\n//*       MXMASM01  -  Assembler programmer's access to MATRIX      *   FILE 622\n//*       MXMCOB01  -  COBOL programmer's access to MATRIX          *   FILE 622\n//*       MXMTBLAS  -  Assembler programmers access to MX-Tables    *   FILE 622\n//*       MXMTBLCB  -  COBOL programmer's access to MX-Tables       *   FILE 622\n//*                                                                 *   FILE 622\n//*    A C Language manual is currently under construction.         *   FILE 622\n//*                                                                 *   FILE 622\n//*    For further information, go to www.exspans.com               *   FILE 622\n//*                                                                 *   FILE 622\n//*    Disclaimer and Conditions:                                   *   FILE 622\n//*                                                                 *   FILE 622\n//*     Copyright (c) Exspans System and Software Development       *   FILE 622\n//*     Inc. 1997-2003                                              *   FILE 622\n//*                                                                 *   FILE 622\n//*     MATRIX is the property of Exspans System and Software       *   FILE 622\n//*     Development Inc.  It may not be disassembled or reverse     *   FILE 622\n//*     engineered. It may not be used in any other product or      *   FILE 622\n//*     service except as specified by a commercial use licence.    *   FILE 622\n//*                                                                 *   FILE 622\n//*     MATRIX is free for educational and non-commercial use.      *   FILE 622\n//*     Commercial users must obtain a commercial use licence       *   FILE 622\n//*     after 60 days free usage. Users must send a statement       *   FILE 622\n//*     of usage to the owners after 60 days usage, quoting the     *   FILE 622\n//*     product licence serial number.                              *   FILE 622\n//*                                                                 *   FILE 622\n//*     The owners and author accept no responsibility for the      *   FILE 622\n//*     way in which any user chooses to use it.  The owners and    *   FILE 622\n//*     author are not responsible for any damage or loss that      *   FILE 622\n//*     may result from the use of this product.                    *   FILE 622\n//*                                                                 *   FILE 622\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "API": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x10\\xbb\\x10\\xbb\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 4283, "newlines": 4283, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "COBCOPY": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x01\\x12\\x01\\x12\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 274, "newlines": 274, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MATXCNTL": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x00\\xff\\x00\\xff\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 255, "newlines": 255, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MATXLOAD": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x0b\\xb9\\x0b\\xb9\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 3001, "newlines": 3001, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MATXOBJ": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x01F\\x01F\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 326, "newlines": 326, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MATXPARM": {"ttr": 3847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MATXPROC": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x000\\x000\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "MXMASM01": {"ttr": 3851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x007\\x01\\x03\\x10O\\x01\\x03\\x10_\\x034\\x02\\xac\\x02U\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-15T03:34:37", "lines": 684, "newlines": 597, "modlines": 0, "user": "IBMUSER"}, "text": "\n\n\n\n  MATRIX\n\n                 Function Reference Manual\n                     S/390 Assembler\n\n\nSUMMARY OF CONTENTS\n\n\n\n    Return Codes:\n    Synchronous or Asynchronous?\n    Tokens\n    Matrix Message\n    Programming Example\n\n    Function Reference\n        Create\n        Delete\n        Connect\n        Disconnect\n        Load\n        Save\n        Read\n        Write\n        Associate\n        Disassociate\n        Obtain\n        Lock\n        Release\n        Lock\n        Copy\n        Search\n        Wait\n        Post\n\n        HotSwap\n\n\n\nRequesting Matrix Functions\n\nThe Matrix functions are requested through CALLMXid macro\ninstructions.  The macro instructions form a message which is\npassed to SRSTUB.  The macro instructions can be issued either\nwith without branch labels to determine the action to be taken\nfor return codes.\n\nThe macros that invoke Matrix functions are all fundementally\nsimilar and are used according to the following general model:\n\nlabel CALLMXid PREFIX=xx,PARM=@plst,SYNC=[YES/NO],\n                     other parameters\n                     RETOK=label,\n                     REQFAIL=label,\n                     NOTSUP=label,\n                     NOTFND=label,\n                     QUIESC=label,\n                     SOS=label,\n                     LOCKED=label,\n                     NOTINIT=label,\n                     DSPTCHD=label,\n                     ERROR=label\n\nWhere:\nlabel = Any appropriate program label\nid = request specific function identifier\nPREFIX = any two characters. Same as used on the SRUSPLST macro\nPARM = address of a double word in dynamic storage\nSYNC = [YES/NO] specifies if the task is to be synchronous or\nasynchronous other parameters = Parameters specific to request\n\nOptional labels are used to determine the next instruction to\nhave control when the function request is complete.  Either all\nlabels must be supplied or none.  If no labels are supplied then\nthe return code in R15 must be tested for values shown in the\nReturn Codes section..\n\nRETOK = label to branch to if all went well\nREQFAIL = label to branch to if request failed\nNOTSUP = label to branch to if function not supported\nNOTFND = label to branch to if Matrix not running\nQUIESC = label to branch to if Matrix is shutting down\nSOS = label to branch to if short on storage\nLOCKED = label to branch to if Matrix too busy to service request\nNOTINIT = label to branch to if Matrix initialization not complete\nDSPTCHD = label to branch to if asynchronous task dispatched\nERROR = label to branch to if any other error occurred\n\nThere are minor variations in each macro where certain conditions\nare required, for instance SYNC is always set to YES for macros\nthat return a value.  If a request runs asynchronously errors are\nreported to the console.\n\nParameters to the macros may be given in a variety of forms,\ndepending on the programs usage of variables:\n\ne.g\nSPACE=0                         numeric constant\nSPACE=(SPCNUM)        the fullword value in SPCNUM is used\nSPACE=SPCNUM          the address of the variable SPCNUM is used\nSPACE=(Rn)            the value in the specified register is used\n\nReturn codes:\n\n0 Request was successful\n4 Request Failed. There may be an explanation in the returned message\n8 Matrix is shutting down and will not service this request\n12 Matrix is not running\n16 Storage Shortage\n20 Error in request.  Ensure message has been properly\n   initialized and has not been improperly altered\n24 Matrix is temporarily busy. Retry request.\n28 Matrix is not initialized. Retry request later.\n32 Request invalid.\n36 Request Dispatched\n\n\nWith a return code of 4, Matrix may also return a 40 character\ndetailed message in the message return area MXRCRETX.\n\nReturn code 24 indicates that a required resource is not yet\navailable to complete a request.  The request should be retried\n\nReturn code of 36 is not an error.  This alerts the application\nto the status of an asynchronous task.  Return code 36 is only\nreturned if the request is dispatched asynchronously.\n\nSynchronous or Asynchronous?\nAn important decision to make with each Matrix request, is\nwhether it will run in background while the requesting\napplication continues, or will the application pause until the\nfunction is complete.  Some functions must return a value and so\nmay only run synchronously with the requesting program.  Whether\nan eligible request runs synchronously or asynchronously is\nentirely dependant on the applications requirements.  Control may\nor may not return to the application before an asynchronous\nfunction is complete.  Control usually returns to the application\nquicker for asynchronous requests.  Sync or Async is selected by\nsetting the SYNC field in the macro to YES or NO.   An\nasynchronous request always results in a return code of 36 if the\nrequest was successfully dispatched.  If the request failed to\ndispatch, one of the other return codes will apply.\n\nTokens\nA TOKEN is a 20 character field which provides for extra\nquick access to certain Matrix functions and is required for\nothers.  The TOKEN is returned by a Connect request.  Once a\ntoken has been obtained by an application it must be preserved\nunaltered.  Passing an invalid token to a Matrix function will\nhave unpredictable results.\n\nMatrix Message\nThe macros used to invoke Matrix functions require a \u00f4Message\u00f6.\nThis is generated by the SRUSPLST macro.  It is required in the\ndynamic storage of any program that invokes a Matrix function.\nThis message area contains the request before it goes out, and a\nresponse when it comes back.  The message is generated with a two\ncharacter prefix, which is used to identify the message to be\nused to a macro.\n\n\n*\n*DYNAMIC STORAGE DEFINITION\n*\n        SRUSPLST PREFIX=MX,DSECT=YES\n@PLST.DS.D\n\n\n\n*\n* DUMMY SECTIONS\n*\n        MXREQCOD PREFIX=MXUS\n        MXMSGREC DSECT=YES,PREFIX=MX\n\n\nProgramming Example\nThis example shows the setup and call required to copy data from\none virtual work area to another.  In this example, if Matrix is\nbusy (LOCKED), the request is retried.  If the request fails, the\ndetailed message is read from the message return area.  The\nreturned message is called C1RCRETX , because the PREFIX field of\nSRUSPLST specifies C1.\n\nIn this example most of the labels (EXIT, ERROR etc) are not\ncoded for brevity.\n\n*\n* Copy Data from one work area to another.\n*\nCOPYWA CALLMXCC PREFIX=C1,PARM=@PLST,SYNC=YES, ++\n            FROMNAME=FWANAM,                   ++\n            FROMADDR=FADDR,                    ++\n            TONAME=TWANAM,                     ++\n            TOADDR=TADDR,                      ++\n            LENGTH=CLEN,                       ++\n            RETOK=OK,                          ++\n            REQFAIL=RET04,                     ++\n            NOTSUP=ERROR,                      ++\n            NOTFND=NOTRUN,                     ++\n            QUIESC=SHUTDOWN,                   ++\n            SOS=NOSTG,                         ++\n            LOCKED=COPYWA,                     ++\n            NOTINIT=COPYWA,                    ++\n            DSPTCHD=BUG,                       ++\n            ERROR=BUG\nOK      DS 0H\n       . . .\n*\nRET04   DS 0H\n        MVC MSG,C1RCRETX    SAVE REASON MESSAGE\n        B EXIT\n*\n* DYNAMIC STORAGE\n*\n        SRUSPLST PREFIX=C1,DSECT=NO\n@PLST   DS D    Double Word Parameter List\nFADDR   DS D    Copy From Address in Virtual Work Area\nTADDR   DS D    Copy To Address in Virtual Work Area\nCLEN    DS D    Length to copy\nFWANAM  DS CL4  Copy From Wirtual Work Area name\nTWANAM  DS CL4  Copy To Virtual Work Area name\n\n*\n* DUMMY SECTIONS\n*\n        MXREQCOD PREFIX=C1US\n        MXMSGREC DSECT=YES,PREFIX=C1\n\n\n\n\n\nFunction Reference\n\nCreate Virtual Work Area\nA Work Area may be up to one half terabyte in size.  This\nfunction may run synchronously or asynchronously.  If it runs\nsynchronously it may return a message.  A virtual work area is\nidentified by a four character name.\n\nMacro Name: CALLMXCW\n\nlabel    CALLMXCW PREFIX=,PARM=, SYNC=,\n                            SIZE=,\n                            NAME=\n\nWhere:     NAME=name of work area to create\n                SIZE=size of work area\n\nReturns:\nNo value is returned.\n\nDelete Virtual Work Area\nDelete a Work Area.  When a work area has been deleted, the space\nit occupied is made available for other uses.  Once deleted,\nneither the space, nor the data in it are accessible.  This\nfunction may run synchronously or asynchronously.  If it runs\nsynchronously it may return a message.  Work Areas may be force\ndeleted.  Forcing a Work Area will delete it even if users are\nstill attached to it.\n\nMacro Name: CALLMXDW\n\nlabel    CALLMXDW PREFIX=,PARM=, SYNC=,\n                            NAME=,\n                            FORCE=\n\nWhere:    NAME=name of work area to delete\n               FORCE=[YES/NO]\n\nReturns:\nNo value is returned.\n\nConnect to a Work Area\nThis function connects a user program to a work area and returns\na token which is to be passed to Matrix with other function\nrequests.  This function runs synchronously, because it must\nreturn a value (token) to the invoker.\n\nMacro Name: CALLMXCN\n\nlabel    CALLMXCN TYPE=CONNECT,PREFIX=,PARM=, SYNC=YES,\n                            WANAME=,\n                            TOKEN=\n\nWhere:    WANAME=name of work area to connect to\n               TOKEN=address of variable to receive token\n\nReturns:\nA token is returned in token return field MXRCRCTK.  This value\nis placed in the specified TOKEN field.\n\nDisconnect from a Work Area\nDisconnect from a work area when work with it is complete.\nThis function may be requested synchronously or asynchronously.\nA valid Token, returned by the Connect request must be supplied.\n\nMacro Name: CALLMXCN\n\nlabel    CALLMXCN TYPE=DISCONN,PREFIX=,PARM=,SYNC=,\n                            TOKEN=\n\nWhere:    TOKEN=address of token returned by connect\n\nReturns:\nNo value is returned.\n\nLoad Data into Work Area\nThis loads a file into a specified virtual work area.  The file\nmust be cataloged and if Matrix is running in a SYSPLEX, it must\nbe accessible to the primary.   This function may be requested\nsynchronously or asynchronously.  If it runs synchronously it may\nreturn a message.\n\nMacro Name: CALLMXFI\n\nlabel    CALLMXFI TYPE=LOAD,PREFIX=,PARM=, DSN=,SYNC=[YES/NO],\n                           NAME= ,\n                           DSN=\n\nWhere:    NAME=name of work area to load into\n               DSN=data set name to load from\n\nReturns:\nNo value is returned.\n\nSave Work Area to file\nThis saves the contents of the specified virtual work area to a\ndataset.  If the dataset exists it must be cataloged.  The recod\nand block size of the existing file are used.  If the dataset\ndoes not exist, the record size of the data in the work area is\nused as the block size.  If there is no record size associated\nwith a work area a default block size of 4096 is used.   This\nfunction may be requested synchronously or asynchronously.  If it\nruns synchronously it may return a message.\n\nMacro Name: CALLMXFI\n\nlabel    CALLMXFI TYPE=SAVE,PREFIX=,PARM=, SYNC=[YES/NO],\n                           NAME= ,\n                           DSN=\n\nWhere:    NAME=name of work area to load into\n               DSN=data set name to load from\n\nReturns:\nNo value is returned.\n\nRead Data from Work Area\nThis function causes data to be read from a Work Area directly\ninto a program area.  This function may run synchronously or\nasynchronously.  If it runs synchronously it may return a\nmessage.  Large reads can be left to run in the background, if\ncircumstances dictate.  An asynchronous read returns only the\nrequested data to the requested record area.\n\nMacro Name: CALLMXRD\n\nlabel    CALLMXRD PREFIX=,PARM=, SYNC=[YES/NO],\n                           TOKEN= ,\n                           DEST=,\n                           READLEN=,\n                           FROMADDR=\n\nWhere:    TOKEN=variable containing TOKEN returned by Connect\n               DEST=address in program storage to receive the data\n               READLEN=length to read,\n               FROMADDR=Address in work area to read from\n\nReturns:\nActual number of bytes read is returned in MXUSREAD if request is\nSynchronous.\n\nWrite Data to Work Area\nWrite data from program working storage to a Virtual Work Area.\nThis function may run synchronously or asynchronously.  If it\nruns synchronously it may return a message.\n\nMacro Name: CALLMXWR\n\nlabel    CALLMXWR PREFIX=,PARM=,SYNC=[YES/NO],\n                           TOKEN= ,\n                           DEST=,\n                           WRTLEN=,\n                           FROMADDR=\n\nWhere:    TOKEN=variable containing TOKEN returned by Connect\n               DEST=address in work area to receive the data\n               WRTLEN=length to write,\n               FROMADDR=Address in program storage to write from\n\nReturns:\nActual number of bytes written is returned in MXUSWRIT if request\nis Synchronous.\n\nCopy data between Work Areas.\nThis function copies a block of data from one work area to\nanother or from one place to another within a single work area.\nThis function may run synchronously or asynchronously.  If it\nruns synchronously it may return a message.\n\nMacro Name: CALLMXCC\n\nlabel    CALLMXCC PREFIX=,PARM=,SYNC=[YES/NO],\n                           FROMNAME= ,\n                           FROMADDR=,\n                           TONAME=,\n                           TOADDR=,\n                            LENGTH=\n\nWhere:    FROMNAME=name of source work area\n               FROMADDR=Address of source data\n               TONAME=Name of target work area\n               TOADDR=Address of target data\n               LENGTH=length of data to be copied\n\nReturns:\nNo value is returned.\n\nSearch For Data in Work Area\nThere are two modes of operation for a search.  Searches can be\nperformed with or without a token.  If a token is not supplied,\nthen the work area name must be supplied.  If a token is\navailable, it should be used rather than the name.  This function\nmay only run synchronously because it returns a value.  The value\nreturned field MXRCHOFF in the return message is the address in\nthe work area of the start of the string that matches the search\ndata.\n\nMacro Name: CALLMXSR\n\nlabel    CALLMXSR PREFIX=,PARM=,SYNC=YES,\n                           [TOKEN= ,/\n                           WANAME=],\n                           DATA=,\n                           STARTAT=,\n                           SCANLEN=,\n                           ARGLEN=\n\nWhere:    TOKEN=Work Area Token returned by Connect\n               WANAME=Name of Work Area to Search\n               DATA=Address of data to be found\n               STARTAT=Address in Work Area to start search at\n               SCANLEN=length of Work Area to scan\n               ARGLEN=Length of the search data\n\nReturns:\nThe address of the location at which the data was found is\nreturned as a 64 bit address in MXRCHOFF.\n\nWith a Token\nlabel    CALLMXSR PREFIX=,PARM=,SYNC=YES,\n                           TOKEN= ,\n                           DATA=,\n                           STARTAT=,\n                           SCANLEN=,\n                           ARGLEN=\n\nWithout a Token\nlabel    CALLMXSR PREFIX=,PARM=,SYNC=YES,\n                           WANAME=,\n                           DATA=,\n                           STARTAT=,\n                           SCANLEN=,\n                           ARGLEN=\n\n\nHotSwap two Work Areas\nHot Swapping enable two work areas to be exchanged, while\ntransactions are in flight.  Before a HotSwap, reads, writes and\nsearches are directed to a specific Virtual Work Area.  After a\nHot Swap, subsequent reads, writes, and searches are directed to\nthe other Virtual Work Area.  The Hot Swap can prohibit an\nexchange if there are users attached to a Virtual Work Area.\nThis is selected by setting the EXINUSE=parameter to YES.  If\nEXINUSE=NO the exchange will take place while transactions are in\nflight.\n\nMacro Name:CALLMXXC\n\nlabel    CALLMXXC PREFIX=,PARM=,SYNC=[YES/NO],\n                           SOURCE=,\n                           TARGET=,\n                           EXINUSE=\n\nWhere:    SOURCE=Name of the source Work Area\n               TARGET=Name of Target Work Area\n                EXINUSE=[YES/NO]\n\nReturns:\nNo data returned.\n\nAssociate a Work Area\nAssociating a work area causes all updates to the work area to be\nrecorded in a backing dataset.  After the association has been\nmade between the work area and the backing dataset all updates\nwill be permanently recorded.   This request may run\nsynchronously or asynchronously.\n\nMacro Name: CALLMXFI\n\nlabel    CALLMXFI TYPE=ASSOC, PREFIX=,PARM=,SYNC=[YES/NO],\n                           NAME=,\n                           DSN=\n\nWhere:    NAME=Name of the Work Area\n               DSN=data set name to back space on\n\nReturns:\nNo data returned.\n\nDisassociate a Work Area\nDisassociation breaks the connection between a Virtual Work Area\nand a backing dataset.  After this request completes, backing is\nno longer performed for it.  This request may run synchronously\nor asynchronously.\n\nMacro Name: CALLMXFI\n\nlabel    CALLMXFI TYPE=DISASSOC, PREFIX=,PARM=,SYNC=[YES/NO],\n                           NAME=\n\nWhere:    NAME=Name of the Work Area\n\nReturns:\nNo data returned.\n\nObtain a Lock on a Work Area\nLocking a work area provides the application program with a\nserialization key.  As long as the application holds that key, no\nother application can get a new key.  The lock is held until the\nlock is released with the \"unlock\" request.  Applications may use\nthis lock to serialize any process appropriate to its function.\nThe use of this lock has no affect on the performance or function\nof Matrix.  The lock is provided to enable applications to\nprevent multiple simultaneous access by different instances of\nthe locked code.  The lock is therefore a task lock and not a\ncontrol block lock This request must run synchronously because it\nreturns a key.   If this function returns a code of 24 (Busy), it\nmeans that another application holds the lock.\n\nMacro Name: CALLMXLK\n\nlabel    CALLMXLK TYPE=LOCK, PREFIX=,PARM=,SYNC=YES,\n                           TOKEN=,\n                            KEY=\n\nWhere:    TOKEN=Token of the Work Area\n               KEY=address of 32 bit area to receive the key\n\nReturns:\nThe key to be used to release the lock is returned in R1 and the\nspecified KEY location\n\nRelease a Lock on a Work Area\nUnlocking a work area frees the serialization lock so that\nanother application can request it.   This request may run\nsynchronously or asynchronously.\n\nMacro Name: CALLMXLK\n\nlabel    CALLMXLK TYPE=UNLOCK, PREFIX=,PARM=,SYNC=[YES/NO],\n                           TOKEN=,\n                           KEY=\n\nWhere:    TOKEN=Token of the Work Area\n                KEY=address of 32 bit area to receive the key\n\nReturns:\nNo value returned.\n\nWait for an Event to occur\nMatrix enabled applications can signal the occurance of events to\neach other.  If an application is dependant on an event, such as\nthe completion of a space load process, it can wait on a\npredetermined event.  The program will pause until the event is\nposted by another program.\n\nMacro Name: CALLMXEV\n\nlabel    CALLMXEV TYPE=WAIT, PREFIX=,PARM=,SYNC=YES,\n                           EVENT=\n\nWhere:    EVENT=8 character event name\n\n\nReturns:\nReturn code 0 if wait completed OK\nReturn code 4 and a message if it failed\n\nPost an Event complete\nWhen a program detects that a condition has occured that would\nallow other waiting tasks to procede, it may post the event\ncomplete.  If no tasks are waiting on an event when it is posted,\nthge event is created in a posted state and subsequent tasks that\nwait on the event will not wait.  If tasks are waiting for the\nevent they will be released and will continue to operate\nindependantly.\n\nMacro Name: CALLMXEV\n\nlabel    CALLMXEV TYPE=POST, PREFIX=,PARM=,SYNC=[YES/NO],\n                           EVENT=\n\nWhere:    EVENT=8 character event name\n\n\nReturns:\nReturn code 0 if post completed OK\nReturn code 4 and a message if it failed\n\nFile Handling operations\nOpen a file to virtual work area\nMatrix allows certain file operations, such as GET, PUT, READ, WRITE to\ngo directly against a virtual work are. To achieve this the normal OPEN\nOPEN and CLOSE macros are replaced by OPENMX and CLOSEMX.\nThe actual I/O macros are left unchanged.\n\nOPENMX\nOPENMX replaces the OPEN macro.\n\nlabel OPENMX  PLIST=plist,\n              DCB=dcbaddr,\n              SYSNAME=nameaddr,\n              VWA=vwanameaddr\n\nIf the virtual work area specified by VWA= does not exist, it is created\nand loaded from the file specified by DCB=. If the virtual work area\ndoes exist, it is addressed and data returned from it, bypassing the\nfile.\n\n\nExample:\n\n*\n* OPEN THE DCB POINTED AT BY R3\n* NORMALLY DONE WITH AN OPEN MACRO AS COMMENTED HERE\n*\n*        OPEN ((R3),INPUT),MF=(E,(R2)),MODE=31  OPEN FILE\n*\n* INSTEAD WE USE OPENMX\n*\n         OPENMX  PLIST=OPMXPLST,       OPEN FILE IN MATRIX            ++\n               DCB=(R3),                                              ++\n               SYSNAME=CL4'MTRX',      SERVER NAME                    ++\n               VWA=CL4'TST1'           VIRTUAL WORK AREA NAME\n*\n         LTR   R15,R15                 DID IT WORK?\n         BNZ   OPNFAIL                 NO ERROR\n\n         TM    DCBOFLGS,DCBOFOPN       IS IT NOW OPEN?\n         BNO   OPNFAIL                 NO ERROR\n\n\n\nClose virtual work area file\nCLOSEMX\n\nlabel         CLOSEMX DCB=dcbaddr\n\nThis closes the file. The virtual work area is left intact with the data\nin it until the virtual work area is explicitly deleted.\n\nExample:\n\n*\n* CLOSE THE FILE. NORMALLY YOU USE A CLOSE MACRO\n* WE JUST REPLACE IT WITH A CLOSEMX\n*\n*        CLOSE ((R3)),MF=(E,(R2)),MODE=31  CLOSE FILE\n*\n         CLOSEMX DCB=(R3)\n*\n\n\n\n\n\u20ac 1997-2003 EXSPANS email: info@exspans.com\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MXMBAT01": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00\\x14\\x01\\x03\\x10O\\x01\\x03\\x10_\\x02\\x19\\x00\\xea\\x00\\xe4\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-15T02:19:14", "lines": 234, "newlines": 228, "modlines": 0, "user": "IBMUSER"}, "text": "\n\n\n\nMATRIX Utilities\nBatch\n\n          Applications Developers Manuals\n\n\n\n\n\nBatch Utility Program\n\nThe Matrix batch utility program, MXPRS001, enables the\napplications programmer or user to simply and effectively request\nand perform complex systems functions. The utility may be used as\nan administrative tool to prepare applications environments and\nto control the Matrix environment. The program SSUTIL which is invoked\nto run MXPRS001 is a generic language interpreter.\n\nThe batch utility program is run from hlq.MATRIX.UTILITY.LOAD\n\n//JOBNAME JOB (accnt),'user',....\n//        EXEC PGM=SSUTIL,PARM='MXPRS001'\n//STEPLIB  DD DSN=hlq.MATRIX.UTILITY.LOAD,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\ncontrol statements\n/*\n\nBatch Utility Control Statements\n\nThe control statements are read as standard 80 byte parameter\nrecords. An asterisk(*) in column 1 indicates a comment and the\nentire contents of that record are ignored. The statements may\nspan multiple lines and any number of spaces may be placed\nbetween words.\n\n1) Associate\nASSOCIATE xxxx WITH DSNAME(backing.dataset.name)\n\nThis will cause the Virtual Work Area named xxxx to be associated\nwith a backing dataset. When a VWA is backed, all updates to it\nare reflected in the backing dataset.\n\n2) Copy\nCOPY xxxx ADDR=XXXXXXXX,LEN=DDDDDDD TO yyyy ADDR=XXXXXXXX\n\nCopy the contents of VWA xxxx from location given by ADDR and a\nlength of LEN to the given address in VWA yyyy.  The addresses\nand lengths may be specified by up to 18 decimal digits.\n\n3) Create Virtual Work Area\nCREATE VWA xxxx {MIRROR/NOMIRROR} SIZE sz t\n\nThis will create a persistent work area with the name given as\nxxxx and a size specified by up to 18 decimal digits. The type of\nnumeric value specied is given by t. This may be B for Bytes, K\nfor KiloBytes, M for MegaBytes or G for GigaBytes. MIRROR specifies that\nthe work area will be mirrored on all systems. NOMIRROR specifies that\nit will exist on the creating system only.\n\n\n4) Delete Virtual Work Area\nDELETE VWA xxxx\n\nThis will delete the named Virtual Work Area.\n\n5) Delete Event\nDELETE EVENT xxxxxxxx\n\nThis will delete the named event.\n\n6) Disassociate\nDISASSOCIATE xxxx\n\nThis will disassociate a work area from its backing dataset.\n\n7) Display contents of a VWA\nDISPLAY xxxx ADDR 00000000 LEN 00005000\n\nThis will print out the contents of the work area, starting at\nthe specified address for the given length, in hexadecimal and\ncharacter format.\n\n8) List status of events\nLIST EVENTS\n\nThis displays a list of all events and their status. Status may\nbe unused, waiting or posted.\n\n9) Load VWA\nLOAD xxxx FROM DSNAME(data.set.name)\n\nLoad data from the specified dataset into the named Virtual Work\nArea\n\n10) Obtain a lock on a VWA\nLOCK xxxx\n\nThis obtains a serialization lock against a Virtual Work Area. A\nlock may be used for any application defined purpose and is used\nto serialize applications events, independently of Matrix task\ndispatching.\n\n11) Post an event complete\nPOST xxxxxxxx\n\nThis will notify Matrix and all dependant tasks that an\napplication defined event has occurred.\n\n12) Reset an event\nRESET xxxxxxxx\n\nThis resets a posted event to the unused condition to enable the\nevent label to be reused.\n\n13) Save a VWA\nSAVE xxxx TO DSNAME(data.set.name)\n\nThis writes the entire contents of a VWA to a sequential dataset\n\n14) Swap VWA's\nSWAP xxxx WITH yyyy\n\nThis exchanges Virtual Work Areas on the fly. If prior to the\nSWAP operation data was read and written to xxxx, after the\noperation yyyy will be the source and destination of reads and\nwrites.\n\n15) Release a lock on a VWA\nUNLOCK xxxx\n\nThis releases an application serialization event against a VWA.\n\n16) Wait for an event to complete\nWAIT xxxxxxxx\n\nThis will suspend processing of a task until the event is completed.\n\nExample:\nThis simple example shows two jobs. They are required to run in\nsequence. The first creates and loads a VWA, the second displays\nselected contents from the VWA then deletes it. These jobs may be\nsubmitted in any order provided that there are sufficient\ninitiators to ensure that they can execute simultaneously.\n\n//JOB1 JOB .....\n. . .\n// SYSIN   DD *\n* create a virtual work area, load it from a database file\n* then notify tasks that require access to the data that it is ready\nCREATE VWA VWA1 NOMIRROR SIZE 40 G\nLOAD VWA1 FROM DSNAME(DATA.BASE.FILE)\nPOST AAAAAAA\n/*\n\n\n\n//JOB2 JOB .....\n. . .\n// SYSIN   DD *\n* wait until the VWA1 has been formatted then display its\n* contents. When work with the VWA\n* is finished, delete it.\n\nWAIT AAAAAAAA\nDISPLAY VWA1 ADDR 00000000 LEN 00005000\nDELETE WORKAREA VWA1\n/*\n\n17) Create a virtual table\n\nTables may be fixed or varying length cells. To create a fixed\nlength cell table:\n\nCREATE TABLE tnam(n1,n2,n3....) DATA tdat CELLSIZE csz\n\nWhere tnam(n1,n2,n3...) is the name of the table to create and\nthe extent of each dimension. tdat is the name of the VWA which\nwill contain the table data and csz is the size of the fixed\nlength cells.\n\nTo create a varying length cell table:\n\nCREATE TABLE tnam(n1,n2,n3....) INDEX tidx DATA tdat CELLSIZE 0\n\nWhere tnam(n1,n2,n3...) is the name of the table to create and\nthe extent tof each dimension. tidx is the name of a VWA which\nwill contain the table index and tdat is the name of a VWA which\nwill hold the data. CELLSIZE is always zero for a variable length\ncell table.\n\n18) Allocate a variable length cell in a virtual table\n\nALLOC CELL TABLE tnam(n1,n2,n3...) CELLSIZE csz\n\nThis allocates a cell in the named table at the coorinates given.\nThe length of the cell is csz. Cells do not have to be created in\norder and cells that are not used do not need to be allocated.\n\n19) Save a table\n\nSAVE TABLE tnam TO (dsnprefix)\n\nThe components of a table are saved on the system that created\nthem. This command may be executed in any part of the sysplex.\nThe table to be saved is given as tnam and the datasets used to\nsave the table components are prefixed with dsnprefix.\n\n20) Load a table\n\nLOAD TABLE tnam FROM (dsnprefix)\n\nThe components of a table which were saved by the SAVE TABLE\ncommand may be reloaded. The components of the table are reloaded\nto the system that originally owned them.\n\n21) Display a cell\n\nDISPLAY TABLE tnam CELL(n1,n2,n3....)\n\nThe cell in tabal  tnam at the given coordinates are displayed in\nhexadecimal and text format.\n\n22) Delete a table\n\nDELETE TABLE tnam\n\nThe named table and its components are deleted.\n\n\u20ac 1997-2003 EXSPANS email: info@exspans.com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXMCOB01": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x02\\x05\\x00'\\x01\\x03\\x10O\\x01\\x03\\x10_\\x035\\x02\\xcc\\x03\\x15\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "02.05", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-15T03:35:27", "lines": 716, "newlines": 789, "modlines": 0, "user": "IBMUSER"}, "text": "\n\n\n\nMATRIX\n\n\n                 Function Reference Manual\n                          COBOL\n\n\nSUMMARY OF CONTENTS\n\n\nRequesting Matrix Functions\n\nReturn codes:\nSynchronous or Asynchronous?\nTokens\nMatrix Message\n\nProgramming Example\n\nFunction Reference List\n    Create\n    Delete\n    Connect\n    Disconnect\n    Load Save\n    Read Write\n    Associate\n    Disassociate\n    Obtain\n    Lock\n    Release\n    Lock Copy\n    Search\n    Wait Event\n    Post Event\n\n    HotSwap\n\n\n\n\nRequesting Matrix Functions\n\nMatrix functions are requested by calling the interface program,\nMXSTUB, with a message. A message for each request must be\ninitialized before invoking the interface.  MXSTUB returns a\nreturn code value after each invocation. The return code\nindicates the success or failure of the call, and the reason for\nthe failure.\n\nReturn codes:\n\n0 Request was successful\n4 Request Failed. There may be an explanation in the returned message\n8 Matrix is shutting down and will not service this request\n12 Matrix is not running\n16 Storage Shortage\n20 Error in request.  Ensure message has been properly\n   initialized and has not been improperly altered\n24 Matrix is temporarily busy. Retry request.\n28 Matrix is not initialized. Retry request later.\n32 Request invalid.\n36 Request Dispatched\n\n\nReturn code 4 Matrix may also return a 40 character detailed\nmessage in the message return area MATRIX-RETURN-MESSAGE.\n\nReturn code 24 indicates that a required resource is not yet\navailable to complete a request.  The request should be retried\n\nReturn code 36 alerts the application to the status of an\nasynchronous task.  This is only returned if the request is\ndispatched asynchronously.\n\nSynchronous or Asynchronous?\nAn important decision to make with each Matrix request, is\nwhether it will run in background while the requesting\napplication continues, or will the application pause until the\nfunction is complete.  Some functions must return a value and so\nmay only run synchronously with the requesting program.  Whether\nan eligible request runs synchronously or asynchronously is\nentirely dependent on the applications requirements.  Control may\nor may not return to the application before an asynchronous\nfunction is complete.  Control usually returns more quickly to\nthe application for asynchronous requests.\n\nSync or Async is selected by setting MATRIX-REQUEST-SYNC in the\nmessage to MATRIX-SYNC or MATRIX-ASYNC.\n\nAn asynchronous request always results in a return code of 36 if\nthe request was successfully dispatched.  If the request failed\nto dispatch, one of the other return codes will apply.\n\nTokens\nA TOKEN is an twenty character field which provides for enhanced\naccess to certain Matrix functions and is mandatory for other\nfunctions.  The TOKEN is returned by a Connect request.  Once a\ntoken has been obtained by an application, it must be preserved\nunaltered.\n\nMatrix Message\nThe message, which is passed to MXSTUB when requesting functions,\nis defined in copy member MXPLIST.  This member must be copied\ninto the working storage of any COBOL program that invokes\nMatrix.  Certain parts of the message must be specified for every\nrequest others are optional depending on the function requested.\nIt is important to set the mandatory fields correctly.  If any\none of these fields is invalid results are unpredictable.\n\nMandatory message fields:\n\nMATRIX-REQUEST Set to the desired request\nMATRIX-REQUEST-SYNC Specify Synchronous or Asynchronous\nMATRIX-REQUEST-PCR Set to LOW-VALUES\n\nThe fields that are specific to a request are listed with the\ndescription of that request .\n\nProgramming Example\nThis example shows the setup and call required to create a\nvirtual work area of approximately 3.5 Gigabytes.  In this\nexample if the return code is not zero, a message analysis\nroutine is called.  The code examples are intended to show the\nmechanics of the interface and do not necessarily represent good\nprogramming practice.\n\n  WORKING-STORAGE SECTION.\n*\n* COPY MATRIX INTERFACE PLIST\n*\n       COPY MXPLIST.\n*\n PROCEDURE DIVISION.\n 0000-MAINLINE.\n* CREATE A VIRTUAL WORK AREA\n     MOVE MATRIX-CREATE-WA TO MATRIX-REQUEST.\n     MOVE 'DIV1' TO MATRIX-CREATEWA-NAME.\n     MOVE 3500000000 TO MATRIX-CREATEWA-SIZE.\n     MOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\n     MOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\n     CALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\n     IF RETURN-CODE=0\n     THEN DISPLAY 'REQUEST SUCCESSFUL'\n     ELSE PERFORM 9000-MESSAGE.\n\n 9000-MESSAGE.\n     IF RETURN-CODE=4\n          MOVE MATRIX-RETURN-MESSAGE TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 8\n          MOVE 'MATRIX IS QUIESCING' TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 12\n          MOVE 'MATRIX NOT FOUND' TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 16\n          MOVE 'INSUFFICIENT STORAGE' TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 20\n          MOVE 'REQUEST NOT SUPPORTED' TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 24\n          MOVE 'MATRIX TEMP UNAVAIL' TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 28\n          MOVE 'APPLICATION NOT INITIALIZED' TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 32\n          MOVE 'ERROR IN REQUEST' TO WS-MESSAGE\n        ELSE IF RETURN-CODE = 36\n          MOVE 'REQUEST DISPATCHED' TO WS-MESSAGE.\n     DISPLAY WS-MESSAGE.\n 9000-EXIT.\n\nFunction Reference\n\nCreate Virtual Work Area\nA Virtual Work Area is identified by a four character name and be\nup to one half terabyte in size.  The amount of space requested\nmust be less than or equal to the residual amount left after all\nprevious allocations have been subtracted from this maximum.\nThis function may run synchronously or asynchronously.  If it\nruns synchronously it may return a message.\n\n\nRequest name: MATRIX-CREATE-WA.\nRequest specific parameters:\nMATRIX-CREATEWA-NAME The name of the Virtual Work Area\nMATRIX-CREATEWA-SIZE Size of the Virtual Work Area to be created\n\nExample:\nMOVE MATRIX-CREATE-WA TO MATRIX-REQUEST.\nMOVE name TO MATRIX-CREATEWA-NAME.\nMOVE size TO MATRIX-CREATEWA-SIZE.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0 . . .\n\nDelete Virtual Work Area\nWhen a work area has been deleted, the space it occupied is made\navailable for other uses.  Once deleted, neither the space, nor\nthe data in it are accessible.  This function may run\nsynchronously, or asynchronously.  If it runs synchronously, it\nmay return a message.\n\n\nRequest Name: MATRIX-DELETE-WA.\nRequest specific parameters:\nMATRIX-DELETE WA-NAME: The name of the Virtual Work Area to be deleted.\n\nExample:\nMOVE MATRIX-DELETE-WA TO MATRIX-REQUEST.\nMOVE 'DIV2' TO MATRIX-DELETEWA-NAME.\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0 . . .\n\nConnect to a Work Ar ea\nConnecting to a work area provides a fast path to the data in\nthat work area.  This function returns a token which is passed to\nMatrix with other function requests.  This function always runs\nsynchronously, because it must return a value (token) to the\ninvoker.\n\nRequest Name: MATRIX-CONNECT-WA.\nRequest specific parameters:\nMATRIX-CONNECT-WA-NAME: The name of the Virtual Work Area\nto connect to.\n\nExample:\nMOVE MATRIX-CONNECT-WA TO MATRIX-REQUEST.\nMOVE 'DIV2' TO MATRIX-CONNECT-WA-NAME.\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0\nTHEN MOVE MATRIX-RETURN-CONNECT-TOKEN TO TOKEN\nELSE . . .\nDisconnect from a Work Area\nDisconnect from a work area when work with it is complete.\nThis function may be requested synchronously or asynchronously.\nA valid Token, returned by the \"connect\" request must be supplied.\n\nRequest Name: MATRIX-DISCONNECT-WA.\nRequest specific parameters:\nMATRIX- DISCONNECT-TOKEN.  The token of the Virtual Work Area to\nbe disconnected from.\n\nExample:\nMOVE MATRIX-DISCONNECT-WA TO MATRIX-REQUEST.\nMOVE TOKEN TO MATRIX-DISCONNECT-TOKEN.\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG OMITTED.\nIF RETURN-CODE=0 . . .\n\nLoad Data into Work Area\nThis loads a file into a specified Virtual Work Area.  The file\nmust be cataloged and if Matrix is running in a SYSPLEX, it must\nbe accessible to the primary.  This function may be requested\nsynchronously or asynchronously.\n\nRequest Name:MATRIX-LOAD-WA.\nRequest specific parameters:\nMATRIX-LOAD-WA-NAME Name of Virtual Work area to be load.\nMATRIX-LOAD-WA-DSNAME. Name of dataset to load from.\n\nExample:\nMOVE MATRIX-LOAD-WA TO MATRIX-REQUEST.\nMOVE waname TO MATRIX-LOAD-WA-NAME.\nMOVE datasetname TO MATRIX-LOAD-WA-DSNAME.\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0 . . .\n\nSave Work Area to file\nThis request saves the contents of a work area to a disk file.\nIf the file exists, it must be cataloged.  If the file exists,\nits record and block size are used when writing it out.  If the\nfile does not exist, it will be created and cataloged with a\nblock size of 4096.  This function may be requested synchronously\nor asynchronously.\n\nRequest Name: MATRIX-SAVE-WA.\nRequest specific parameters:\nMATRIX-SAVE-WA-NAME Name of Virtual Work area to be saved.\nMATRIX-SAVE-WA-DSNAME. Name of dataset to save to.\n\nExample:\nMOVE MATRIX-SAVE-WA TO MATRIX-REQUEST.\nMOVE waname TO MATRIX-SAVE-WA-NAME.\nMOVE datasetname TO MATRIX-SAVE-WA-DSNAME.\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0 . . .\n\nRead Data from Work Area\nThis function causes data to be read from a Work Area directly\ninto a program area.  This function may run synchronously or\nasynchronously.  If it runs synchronously it may return a\nmessage.  Large reads can be left to run in the background, if\ncircumstances dictate.  An asynchronous read returns only the\nrequested data to the requested record area.\n\nRequest Name: MATRIX-READ-WA.\nRequest specific parameters:\nMATRIX-READ-TOKEN Token of Virtual Work Area to read from.\nMATRIX-READ-FROM-ADDRESS Address in Virtual Work Area of data\nto be read.\nMATRIX-READ-LENGTH. Length of data to be read\n\nThis function requires a token.\n\nThis function also requires a record area in working storage to\nplace the data at.  The record area is passed to Matrix as a\nsecond parameter, after the request message.\n\nExample:\nMOVE MATRIX-READ-WA TO MATRIX-REQUEST.\nMOVE token TO MATRIX-READ-TOKEN.\nMOVE address TO MATRIX-READ-FROM-ADDRESS.\nMOVE length TO MATRIX-READ-LENGTH.\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0 . . .\n\nWrite Data to Work Area\nWrite data from program working storage to a Virtual Work Area.\nThis function may run synchronously or asynchronously.  If it\nruns synchronously it may return a message.  A data area\ncontaining the record to be written must be passed with the\nmessage.\n\nRequest Name: MATRIX-WRITE-WA.\nRequest specific parameters:\nMATRIX-WRITE-TOKEN Token of Virtual Work Area to written to.\nMATRIX-WRITE-TO-ADDRESS Address in Virtual Work Area to place the data.\nMATRIX-WRITE-LENGTH. Length of data to be written.\n\nThis function requires a token.\nThis function also requires a record area in working storage to\nplace the data at.  The record area is passed to Matrix as a\nsecond parameter, after the request message.\n\nExample:\nMOVE MATRIX-WRITE-WA TO MATRIX-REQUEST.\nMOVE token TO MATRIX-WRITE-TOKEN.\nMOVE toaddr TO MATRIX-WRITE-TO-ADDRESS.\nMOVE len TO MATRIX-WRITE-LENGTH.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0\n\nCopy data between Work Areas\nThis function copies a block of data from one work area to\nanother.  This function may run synchronously or asynchronously.\nIf it runs synchronously it may return a message.\n\nRequest Name: MATRIX-COPY-WA.\nRequest specific parameters:\nMATRIX-COPY-FROM-WANAME Source Work Area name.\nMATRIX-COPY-FROM-ADDRESS Address of source data\nMATRIX-COPY-TO-WANAME Destination Work Area name.\nMATRIX-COPY-TO-ADDRESS Address of Destination.\nMATRIX-COPY-LENGTH Length to copy.\n\nExample:\nMOVE MATRIX-COPY-WA TO MATRIX-REQUEST.\nMOVE name1 TO MATRIX-COPY-FROM-WANAME.\nMOVE name2 TO MATRIX-COPY-TO-WANAME.\nMOVE length TO MATRIX-COPY-LENGTH.\nMOVE frad TO MATRIX-COPY-FROM-ADDRESS\nMOVE toad TO MATRIX-COPY-TO-ADDRESS\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0 . . .\n\nSearch For Data in Work Area\nThere are two modes of operation for a search.  Searches can be\nperformed with or without a token.  If a token is not supplied,\nthen the work area name must be supplied.  If a token is\navailable, it should be used rather than the name.  This function\nmay only run synchronously because it returns a value.  The value\nreturned in the return message is the address in the work area of\nthe start of the string that matches the search data.\n\nRequest Name: MATRIX-SEARCH-WA.\nRequest specific parameters:\nMATRIX-SEARCH-TOKEN Optional Token to identify the work area.\nMATRIX-SEARCH-WA-NAME Otional Name to identify the work area.\nMATRIX-SEARCH-START-ADDRESS Address in work area to start seasrch at.\nMATRIX-SEARCH-SCAN-LENGTH Length to scan for the data.\nMATRIX-SEARCH-DATA-LENGTH Length of data to be found.\nMATRIX-SEARCH-DATA Value of data to be found.\n\nThe address of the found data is returned in\nMATRIX-RETURN-FOUND-ADDRESS.\n\nWith a Token\nMOVE MATRIX-SEARCH-WA TO MATRIX-REQUEST.\nMOVE token TO MATRIX-SEARCH-TOKEN.\nMOVE LOW-VALUES TO MATRIX-SEARCH-WA-NAME.\nMOVE start TO MATRIX-SEARCH-START-ADDRESS.\nMOVE length TO MATRIX-SEARCH-SCAN-LENGTH.\nMOVE dlen TO MATRIX-SEARCH-DATA-LENGTH.\nMOVE data TO MATRIX-SEARCH-DATA.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\n*\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0\nTHEN MOVE MATRIX-RETURN-FOUND-ADDRESS TO WS-FOUND-ADDR\n\nWithout a Token\nMOVE MATRIX-SEARCH-WA TO MATRIX-REQUEST.\nMOVE name TO MATRIX-SEARCH-WA-NAME.\nMOVE start TO MATRIX-SEARCH-START-ADDRESS.\nMOVE length MATRIX-SEARCH-SCAN-LENGTH.\nMOVE dlen TO MATRIX-SEARCH-DATA-LENGTH.\nMOVE data TO MATRIX-SEARCH-DATA.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\n*\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0\nTHEN MOVE MATRIX-RETURN-FOUND-ADDRESS TO FOUND-ADDR\n\nHotSwap two Work Areas\nHot Swapping enable two work areas to be exchanged, while\ntransactions are in flight.  Before a HotSwap, reads, writes and\nsearches are directed to a specific Virtual Work Area.  After a\nHot Swap, subsequent reads, writes, and searches are directed to\nthe other Virtual Work Area.  The HotSwap can prohibit an\nexchange if there are users attached to a Virtual Work Area.\nThis is selected by setting the MATRIX-EXCHANGE-INUSE switch to\nMATRIX-NOFORCE.  Setting this switch to MATRIX-FORCE will force\nthe exchange while transactions are in flight.\n\nRequest Name: MATRIX-EXCHANGE-WA.\nRequest specific parameters:\nMATRIX-EXCHANGE-SOURCE-NAME Source Work Area name\nMATRIX-EXCHANGE-TARGET-NAME Target Work Area name\nMATRIX-EXCHANGE-INUSE Force the exchange even if work areas are in use\n\nExample:\nMOVE MATRIX-EXCHANGE-WA TO MATRIX-REQUEST.\nMOVE fname TO MATRIX-EXCHANGE-SOURCE-NAME.\nMOVE fname TO MATRIX-EXCHANGE-TARGET-NAME.\nMOVE MATRIX-NOFORCE TO MATRIX-EXCHANGE-INUSE.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\n*\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0\nTHEN . . .\n\nAssociate a Work Area\nAssociating a work area causes all updates to the work area to be\nrecorded in a backing dataset.  After the association has been\nmade between the work area and the backing dataset all updates\nwill be permanently recorded.  This request may run synchronously\nor asynchronously.\n\nRequest Name: MATRIX-ASSOCIATE-WA.\nRequest specific parameters:\nMATRIX-SAVE-WA-NAME Name of Work Area to be associated.\nMATRIX-SAVE-DSNAME Dataset name to be associated with the VWA\n\nExample: MOVE MATRIX-ASSOCIATE-WA TO MATRIX-REQUEST.\nMOVE 'DIV1' TO MATRIX-SAVE-WA-NAME.\nMOVE WS-DSNAME1 TO MATRIX-SAVE-DSNAME.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n*\n\nDisassociate a Work Area\nDisassociation breaks the connection between a Virtual Work Area\nand a backing dataset.  After this request completes, backing is\nno longer performed for it.  This request may run synchronously\nor asynchronously.\n\nRequest Name: MATRIX-DISASSOCIATE-WA.\nRequest specific parameters:\nMATRIX-SAVE-WA-NAME Name of Work Area to be disassociated.\n\nExample:\nMOVE MATRIX-DISASSOCIATE-WA TO MATRIX-REQUEST.\nMOVE 'DIV1' TO MATRIX-SAVE-WA-NAME.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n*\n\nObtain a Lock on a Work Area\nLocking a work area provides the application program with a\nserialization key.  As long as the application holds that key, no\nother application can get a new key.  The lock is held until the\nlock is released with the \"unlock\" request.  Applications may use\nthis lock to serialize any process appropriate to its function.\nThe use of this lock has no affect on the performance or function\nof Matrix.  This request must run synchronously because it\nreturns a key.\n\nIf this function returns a code of 24 (Busy), it means that\nanother application holds the lock.\n\nRequest Name: MATRIX-LOCK-WA.\nRequest specific parameters:\nMATRIX-LOCK-TOKEN Token of work area to lock.\n\nExample:\nMOVE MATRIX-LOCK-WA TO MATRIX-REQUEST.\nMOVE TOKEN-2 TO MATRIX-LOCK-TOKEN.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0\nTHEN MOVE MATRIX-RETURN-KEY TO WS-SAVE-KEY\nDISPLAY 'REQUEST SUCCESSFUL'\nELSE IF RETURN-CODE=24\nTHEN GOTO RETRY-CALL\nELSE PERFORM 9000-MESSAGE.\n*\n\nRelease a Lock on a Work Area\nUnlocking a work area frees the serialization lock so that\nanother application can request it.  This request may run\nsynchronously or asynchronously.\n\nRequest Name: MATRIX-UNLOCK-WA.\nRequest specific parameters:\nMATRIX-LOCK-TOKEN Token of work area to lock.\nMATRIX-LOCK-KEY Key returned by Lock request.\n\nExample:\nMOVE MATRIX-UNLOCK-WA TO MATRIX-REQUEST.\nMOVE TOKEN-2 TO MATRIX-LOCK-TOKEN.\nMOVE WS-SAVE-KEY TO MATRIX-LOCK-KEY.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n\nWait for Event to complete\nWait for another application or utility to signal the completion\nof an event.  Execution of the application will be suspended\nuntil notification is received of the completion of the event.\nThis request may only run synchronously because control is not\nreturned to the application until after the event occurs.\n\nRequest Name: MATRIX-WAIT-EVENT.\nRequest specific parameters:\nMATRIX-EVENT-NAME Name of event to wait on.\n\nExample:\nMOVE MATRIX-WAIT-EVENT TO MATRIX-REQUEST.\nMOVE 'evntname' TO MATRIX-EVENT-NAME.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n*\n\nPost an Event complete\nSignal the completion of an event.\nThis request may run synchronously or asynchronously.\n\nRequest Name: MATRIX-POST-EVENT.\nRequest specific parameters:\nMATRIX-EVENT-NAME Name of event to be posted.\n\nExample:\nMOVE MATRIX-POST-EVENT TO MATRIX-REQUEST.\nMOVE 'evntname' TO MATRIX-EVENT-NAME.\n*\nMOVE LOW-VALUES TO MATRIX-REQUEST-PCR.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\n\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG WS-DATA-AREA.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n*\n\nCreate a virtual table\nTables may contain fixed or varying length cells.  The procedure\nis slightly different for each.  This request may run\nsynchronously or asynchronously.\n\nRequest Name: MATRIX-CREATE-TABLE.\nRequest specific parameters:\nMATRIX-TABLE-NAME Name of new table.\nMATRIX-TABLE-NUM-DIMS Number of dimensions in the table.\nMATRIX-TABLE-DIMENSIONS(1) Scope of coordinates in this dimension\nMATRIX-TABLE-DIMENSIONS(n) Insert the scope of each dimension.\nMATRIX-TABLE-INDEX-NAME Name of VWA to contain index.\nMATRIX-TABLE-DATA-NAME Name of VWA to contain the data.\nMATRIX-TABLE-CELL-SIZE Size of cells in this table. Zero if\nit is variable length.\n\n\nExample 1: Create fixed length cell table\n\nMOVE MATRIX-CREATE-TABLE TO MATRIX-REQUEST.\nMOVE 'TBL1' TO MATRIX-TABLE-NAME.\nMOVE 3 TO MATRIX-TABLE-NUM-DIMS.\nMOVE 1000 TO MATRIX-TABLE-DIMENSIONS(1).\nMOVE 200 TO MATRIX-TABLE-DIMENSIONS(2).\nMOVE 176 TO MATRIX-TABLE-DIMENSIONS(3).\nMOVE \"DIV1\" TO MATRIX-TABLE-DATA-NAME.\nMOVE 100 TO MATRIX-TABLE-CELL-SIZE.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n\nExample 2: Create variable length cell table\n\nMOVE MATRIX-CREATE-TABLE TO MATRIX-REQUEST.\nMOVE 'TBL2' TO MATRIX-TABLE-NAME.\nMOVE 3 TO MATRIX-TABLE-NUM-DIMS.\nMOVE 1000 TO MATRIX-TABLE-DIMENSIONS(1).\nMOVE 200 TO MATRIX-TABLE-DIMENSIONS(2).\nMOVE 176 TO MATRIX-TABLE-DIMENSIONS(3).\nMOVE \"DIV1\" TO MATRIX-TABLE-INDEX-NAME.\nMOVE \"DIV2\" TO MATRIX-TABLE-DATA-NAME.\nMOVE ZERO TO MATRIX-TABLE-CELL-SIZE.\nMOVE MATRIX-SYNC TO MATRIX-REQUEST-SYNC.\nCALL 'MXSTUB' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n\nConnect to a virtual table\nFor high speed access tables return tokens on the connect process.\nThis request may run synchronously only.\n\nRequest Name: none.\nRequest specific parameters:\nMATRIX-CONNECT-TABLE-NAME Name of table to connect to.\n\nConnect to a table\n\nMOVE 'TBL1' TO MATRIX-CONNECT-TABLE-NAME.\nCALL 'MXTABLEC' USING MATRIX-REQUEST-MSG.\nIF RETURN-CODE=0\nTHEN MOVE MATRIX-RETURN-TABLE-TOKEN TO TABLTOK-1\nDISPLAY 'REQUEST SUCCESSFUL'\nELSE PERFORM 9000-MESSAGE.\n\nAllocate a Cell in a virtual table\nVariable length cell tables are created with cell length of zero.\nBefore an individual cell can be used it must be allocated.\nCells can be allocated in any order.\n\nRequest Name: none.\nRequest specific parameters:\nMATRIX-ALLOC-TABLE-TOKEN Token of table to allocate in.\n\nMATRIX-ALLOC-CELL-SIZE Size of this cell\n\nCoordinates of cell\n\nExample Allocate a cell at coordinate 1,4,7\n\n\nMOVE TABLTOK-1 TO MATRIX-ALLOC-TABLE-TOKEN.\nMOVE 200 TO MATRIX-ALLOC-CELL-SIZE.\nMOVE 1 TO COORD-LIST(1).\nMOVE 4 TO COORD-LIST(2).\nMOVE 7 TO COORD-LIST(3).\nCALL 'MXTABLEA' USING MATRIX-REQUEST-MSG TABLE-COORD.\nIF RETURN-CODE=0\nTHEN DISPLAY 'REQUEST SUCCESSFUL'\n     DISPLAY WS-DATA-AREA\nELSE PERFORM 9000-MESSAGE.\n\nExample program.\nThere are two complete example programs in hlq.MATRIX.V2.SAMPLE.SOURCE\n\nCOBEXMP - illustrates the Matrix COBOL API\nCOBTBL  - illustrates Matrix Tables\n\n\n\n\n\n\n\u20ac 1997-2003 EXSPANS email: info@exspans.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MXMCONCP": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x03\\x10_\\x01\\x03\\x10_\\x035\\x00\\xaf\\x00\\xaf\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-15T00:00:00", "modifydate": "2003-04-15T03:35:51", "lines": 175, "newlines": 175, "modlines": 0, "user": "IBMUSER"}, "text": "Copyright(C) Exspans Systems Inc. 1997 -2003\nMatrix Concepts\n\nWhat is Matrix\nMatrix is a Virtual Space Administration, tabling and cross systems\ncommunications tool.\n\nMatrix provides a simple consistent interface to enable applications\n programs to control virtual space as a resource.\n\nMatrix enables high speed cross systems data sharing for application\ns programs.\n\nThe mechanisms enabled by Matrix can be used to re-conceive the way\nin which applications software is developed and potentially improve\nits performance many fold.\n\nMatrix provides a gate way through which applications designers can\ntake full advantage of large scale data sharing.\n\nThe mechanisms enabled by Matrix normally requires complex authorize\nd supervisor state 'systems' programs. Matrix enables theses functio\nns for applications programs without resorting to complex system pro\ngramming.\n\nApplications may request the creation of shared virtual spaces, work\n areas, tables and events.\n\nMultiple applications from many different address spaces systems in\na sysplex may invoke the Matrix functions simultaneously.\n\nMatrix presents vast arenas of virtual storage as linear address ran\nges to applications program. Program view these as linear memory sta\nrting at address zero and proceeding byte by byte for the length of\nthe memory.\n\nThere is no restriction on the type of data that is placed in Virtua\nl Work Area and its interpretation is up to the applications program\n, in the same way that a program must interpret the contents of any\nfile or storage range.\n\nVirtual Work Areas\nMatrix provides applications with Virtual Work Areas in which the ap\nplication can store, access and share data. A Virtual Work Area is g\niven a 4 character name by the creating application when it is creat\ned. The name may include any printable character and must be unique\nwithin any shared group of Matrix enabled systems. The application m\nay apply any naming standard required by the application, and Matrix\n does not exercise any restrictions on the name.\n\nIf an application wishes to share data with any other application, i\nt must communicate the name to the other application.\n\nThe applications designer is at liberty to include Virtual Work Area\ns as a resource, in the same way as they do access methods now.\n\nMatrix provides analogues to all major file functions and can be ins\nerted into an application by replacement of I/O function requests wi\nth Matrix function requests.\n\nMatrix provides a structured interface for applications programs to\nenable them to take advantage of extended storage addressing without\n any knowledge of the underlying principles.\n\nMatrix allows the systems administrator to predefine patterns of dat\naspaces and workspaces to be used by applications programs. High lev\nel language applications programs may request access to and read and\n write data in the dataspaces. The numbers and sizes of the dataspac\nes may be controlled by an administrators TSO session.\n\nPredefining dataspaces enables systems tuners to match space allocat\nions to expected resource usage. Also the applications interface is\nsimple and standardized. Applications may now be conceived to use sp\nace as a resource and which allows for much simplified applications\ndesign.\n\nWhether applications require tables in storage of 10 Megabytes or 10\n Gigabytes, Matrix can supply and manage the storage on behalf of th\ne application such that the application sees the data area as a line\nar address range of real storage.\n\nApplications may view large tables, arrays, data items or files as c\nontiguous memory locations.\n\nWith Matrix files may be preloaded for ultra fast access. The instru\nction path length to obtain data from extended memory is much shorte\nr than the seek and access requirements for file I/O. This can resul\nt in access times as little as one one thousandth that required for\nshared files.\n\n\nShare data with anything\nMatrix addresses: slow external storage addressing\n\nMatrix enables sysplex wide communications for applications easily\n\nMatrix presents a 64 bit data addressing model. Sizes and lengths of\n data in Matrix Virtual Work Areas are presented to Matrix as 64 bit\n numbers.\n\nMatrix is expandable and can incorporate an application into itself.\n\nThe application then becomes a service routine with all of the benef\nits of Matrix Communications\n\n Synchronous or Asynchronous\nMatrix functions can run asynchronously or synchronously with the ap\nplication.\n\nBacking Memory\nMatrix memory is volatile, just like real storage. Matrix Memory can\n be backed to non-volatile storage.\n\n\nProblems addressed by Matrix\n\n* There are many heritage applications that could benefit from new s\ntorage technologies. Applications which have program residency restr\naints, such as those that must run below the 16Meg line, are limited\n in the memory resource they can allocate and manage.\n\nWith Matrix, these programs could have access to multiple Gigabytes\nof linear memory.\nMatrix will accept requests from programs in all addressing modes an\nd from any programming environment.\n\n* You have files or tables you want to share among multiple applicat\nions.\n\nThe Matrix memory is shared and accessible to all applications. Mult\niple simultaneous CICS transactions can share tables with multiply v\naried batch programs.\n\n* You have shared files or tables that need to be refreshed regularl\ny and you want to keep downtime to a minimum. Traditional method wou\nld include stopping transactions read file into tables restart trans\nactions\n\nWith Matrix, the new tables may be loaded into a work area and when\nready just swapped with the old one. Down time can be kept to zero.\n\n* I am developing Internet applications in the Unix environment and\nI want to serve up data items quickly.\n\nThe simple API for Matrix will enable a programmer whose expertise i\ns in the Unix arena to use complex systems functions with enhanced p\nerformance without having to be retrained in MVS internals.\n\nBy providing simple secure access to almost unlimited data address r\nanges Matrix allows the applications designer to re-conceive the way\n in which applications operate. High level language applications pro\ngrams may read, write and manipulate data in the user data spaces th\nrough a simple API.\n\n* My shared tables have become too large to maintain in storage and\nperformance is degraded.\n\nMatrix provides very large multigigabyte high performance work areas\n into which tables can be loaded and shared.\n\n* I need to access and update my shared tables from processes runnin\ng in different parts of my sysplex.\n\nMatrix enables the sharing of data in the sysplex. Access to data is\n transparent and there is no difference in access where ever in the\nsysplex the applications programs are running.\n\nMatrix enables cross systems event handling, such that a job in one\nsystem can wait until a job in another has completed.\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXMINSTL": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x03\\x10_\\x01\\x03\\x10_\\x036\\x00\\xc7\\x00\\xc7\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-15T00:00:00", "modifydate": "2003-04-15T03:36:54", "lines": 199, "newlines": 199, "modlines": 0, "user": "IBMUSER"}, "text": "Matrix V2.2 Installation.\n\nDownload Matrix.zip to your PC. This contains the software installat\nion and sample file. Unzip this file on your PC. You will extract 12\n files.\n\nThese are:\n\napi.maclib - Assembler language API\ncobol.copylib - COBOL language API\nmatrix.cntl - JCL to compile and run examples\nmatrix.load - Matrix load library\nmatrix.object - API interface modules\nmatrix.parms - start up parameter files\nmatrix.proclib - JCL procedure library\nsample.load - a load library for sample programs\nsample.maclib - macros to assemble sample code\nsample.object - an object library for sample code\nsample.source - source code examples of the Matrix API\nutil.load - TSO and batch utility programs\n\nTo run Matrix you must transfer a minimum of matrix.load, util.load\nand matrix.parms to the MVS-OS/390-z/OS host computer. All the other\n files are optional. The selected files must be uploaded to the MVS-\nOS/390-z/OS system as binary files with a record length of 80 and bl\nock size of 3120. After transferring the binary files to the host yo\nu must RECEIVE them through the TSO RECEIVE facility. The files all\nhave a file name prefix of DIST.MATRIX. If the file names are change\nd on receive the JCL in other files will need to be altered.\n\nTransfer and receive matrix.load. This is the Matrix execution libra\nry. This library MUST be APF authorized.\n\nTransfer and receive util.load. This library contains a TSO program\nand a batch utility program which demonstrate the Matrix API. It can\n be used to monitor and modify Matrix objects. This library must NOT\n be APF authorized.\n\nOptionally, if you wish to write your own applications programs usin\ng the Matrix API you may transfer any or all of the other files. If\nyou wish to use the batch utility program, you should transfer and r\neceive matrix.cntl, which contains JCL samples for running the batch\n utility program.\n\nIf you plan to write programs in COBOL, you need cobol.copylib which\n contains the COBOL programming interface and matrix.object which co\nntains high level language stubs. You should also transfer sample.so\nurce which contains sample code as a guide.\n\nIf you plan to write programs in Assembler, you need api.maclib whic\nh contains the Assembler language API. You should also transfer samp\nle.source which contains sample code as a guide.\n\nIf you wish to assemble the sample programs you need sample.maclib.\nThe macros in this library are only to enable the samples code to as\nsemble. They do not represent good programming practice and should n\not be used for any other purpose.\n\n\n\n\n\nRunning Matrix\n\nMatrix is started as a started task. Put a started task procedure si\nmilar to the following into a system procedure library such as SYS1.\nPROCLIB.\n\n\n//MATRIX   PROC\n//*\n//* MATRIX V2.2 START UP\n//*\n//MATRIX EXEC PGM=MATRIX[,PARM=xxxx]\n\n//STEPLIB   DD DSN=DEV.MATRIX.V2.LOAD,DISP=SHR\n//SYSIN     DD DSN=DEV.MATRIX.V2.PARMS(START1),DISP=SHR\n//MTRXIN    DD DSN=DEV.MATRIX.V2.PARMS(START2),DISP=SHR\n\nThere are two sets of parameters required to start Matrix. Create a\nparameter library to contain members for the SYSIN and MTRXIN datase\nts. The parameter files are 80 byte card images. The parameters to u\nse are in matrix.parms.\n\n\nSYSIN parameters\n*\n\n* ******************************************************************\n*\n* START UP PARAMETERS FOR MATRIX\n*\n* ******************************************************************\n*\n*\n* START SYSPLEX SUPPORT BY SPECIFYING A GROUP NAME\n*\nSYSPLEX=MXGROUP\n*\n* SPECIFY A TWO CHARACTER VERSION CODE. THIS SHOULD BE DIFFERENT FOR\n* EACH COPY OF MATRIX RUNNING IN THE SAME PROCESSOR\n*\nVERSION=AA\n\nThe VERSION parameter is required. Any two non-numeric characters ma\ny be specified.\nThe SYSPLEX parameter specifies the name of a SYSPLEX group which do\nes not conflict with any other sysplex group name in use. If this pa\nrameter is not specified, sysplex services may not be used. It shoul\nd be used even in a MONOPLEX if multiple copies of  Matrix are to be\n used. Any name of up to 8 characters may be specified.\n\n\nMTRXIN Parameters\n*\n* SPECIFY THE TYPE OF DATASPACE MATRIX IS TO USE\n*\nDATASPACE=COMMON\n\nThis parameter is optional and should only be changed on request from\nsupport\n\n\nRunning Multiple copies of Matrix\nEvery processor in a sysplex that will participate in data and event\n sharing must have a copy of Matrix running. Each copy must have the\n same SYSPLEX name specified in the SYSPLEX parameter.\n\nIf only a MONOPLEX is available to test and verify Matrix functional\nity each copy of Matrix must have a different name specified on the\nEXEC card parameter.\n\n//MATRIX EXEC PGM=MATRIX\n\ndefault name is MTRX\n\n//MATRIX EXEC PGM=MATRIX,PARM=MTR2\n\nname is MTR2\n\nThis name is used on an API CONNECT statement to connect to Matrix.\n\nStart Matrix\nEnter:  S Matrix\nAt the console\n\nStop Matrix\nEnter: P Matrix\nAt the console\n\nQuery Matrix license serial number\nEnter F Matrix,Serial\nAt the console\n\nEach copy of Matrix has a license serial number. This number is need\ned when making inquiries for technical support and on a statement of\nusage.\n\nStart Matrix API TSO demonstration Program\nAt a TSO terminal enter\nCall 'hlq.MATRIX.UTILITY.LOAD(MXDIALOG)'\n\nThis program presents a series of menus and panels that enable you t\no display and control Matrix objects.\nThis program invokes each of the Matrix API\u00c6s in response to termina\nl input. Each panel demonstrates one API function that can be used i\nn user programs. The TSO panels enable you to create and manage larg\ne cross-system virtual work areas. You can also use the panels to lo\nad and manipulate data, directly and in tables. If Matrix is not run\nning MXDIALOG will not start.\n\n\nRun Matrix API Batch demonstration Programs\nThe program used to demonstrate the API is a generic interpreter pro\ngram called SSUTIL. This program interprets English sentences and tr\nansforms them into API calls which are executed to perform the funct\nion. This program is rather unforgiving and will halt execution afte\nr any error. Note that an asterisk (*) in column 1 of the input deno\ntes a comment.\n\nThe JCL for the demonstration jobs are in hlq.MATRIX.V2.CNTL.\n\nRUNUTIL\nThis job contains an example of statements which can be executed aga\ninst Matrix.\n\nSee the Batch Utility Guide for details of the meaning of the statem\nents.\n\nRUNUTIL2\nThis contains a series of jobs which wait on cross systems events an\nd post others. This series of jobs is used to demonstrate a cascade\nof jobs that will wait then activate other jobs. If you run this ser\nies of jobs as they are, you should use the TSO events option to tri\ngger the cascade.\n\n\nSupported languages\nThe API is supported in Assembler, COBOL and C.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MXMTBLAS": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00B\\x01\\x03\\x10_\\x01\\x03\\x10_\\x03\\x07\\x01\\xad\\x01\\xad\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-15T00:00:00", "modifydate": "2003-04-15T03:07:42", "lines": 429, "newlines": 429, "modlines": 0, "user": "IBMUSER"}, "text": "MX-Tables\nAssembler Programming\nReference Manual\n\n\n\nAssembler Function Macros\t3\nCreate a table\t3\nDelete a table\t4\nCalculate the size of a table\t4\nRead a table element\t5\nWrite a table element\t5\nConnect to a table.\t6\nLoad a table.\t6\nSave a table.\t7\nDisconnect from a table.\t7\nQuery table cell size.\t8\nQuery table dimensions.\t8\nLocate a cell in a table.\t8\nAllocate a cell in a varying cell length table.\t9\n\n\nAssembler Function Macros\nFunctions are requested by the MXTABLES Macro. The API function to u\nse is given by function.\n\n\nCreate a table\nThis function create a system wide shared table within Matrix. If Ma\ntrix is running sysplex enabled, this table will be known to all ins\ntances of Matrix within the sysplex. All of the components of the ta\nble must be prepared and ready before this macro is performed. The V\nirtual Work Areas for index and data must have been created before t\nhis command is issued. See Matrix Assembler Programming Reference Ma\nnual for details on how to create VWA's.\n\nLABEL   MXTABLES CREATE,\n              PREFIX=,\n              PARM=,\n              SYSNAME=,\n              ATOK=,\n              NAME=,\n              INDEXWA=,\n              DATAWA=,\n              CELLSIZE=,\n              NUMDIMS=,\n              DIMS=,\n              SYNC=,\n              RETOK=,\n              ERROR=\n\nWhere:\n\nPREFIX=\t2 character prefix used on the SRUSPLST macro\nPARM=\t\taddress of a doubleword parameter area\n\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned (optional if ATOK used)\nATOK=\tMatrix Access token returned by SRVACCES. Optionally, SYSNAME\nmay be used.\nNAME=\t\tFour character name of the table\nINDEXWA=\tName of Virtual Work Area which will contain the index. Req\nuired for variable length cell tables. Must not be specified for fix\ned length cell tables\nDATAWA=\tName of Virtual Work Area which will contain the data\n\nCELLSIZE=\tSize in bytes of the cells in this table. Must be zero for\n variable cell length table.\nNUMDIMS=\tNumber of dimensions this array will have\n\nDIMS=\tAddress of a table of words, each containing the maximum coord\ninate of its corresponding  dimension.\nSYNC=\t\tYES or NO.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\n\nDelete a table\nWhen a table is no longer required, it should be deleted to free up\nresources.\n\nLABEL   MXTABLES DELETE,\n              PREFIX=,\n              PARM=,\n              SYSNAME=,\n              ATOK=,\n              NAME=,\n              TOKEN=,\n              FORCE=,\n              SYNC=,\n              RETOK=,\n              ERROR=\n\nWhere:\n\nPREFIX=\t2 character prefix used on the SRUSPLST macro\nPARM=\t\taddress of a doubleword parameter area\n\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned (optional if ATOK used)\nATOK=\t\tMatrix Access token returned by SRVACCES. Optional, SYSNAME m\nay be used or the\nACCESS token can be placed in SRUSATOK.\n\nNAME=\t\tFour character name of the table to be deleted. Optional if T\nOKEN used.\nTOKEN=\tToken of table to be deleted. Optional if NAME used.\n\n\nFORCE=\t\tYES or NO. If FORCE=YES is used the table will be deleted ev\nen if others could be accessing it.\n\nSYNC=\t\tYES or NO.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\nCalculate the size of a table\nThis function calculates the size of tables to enable the applicatio\nn to obtain the correct amount of space to hold it.\n\n\nLABEL   MXTABLES CALCSIZE,\n         \tNUMDIMS=,\n         \tCELLSIZE=,\n         \tDIMS=\n         \tRESULT=\n\nWhere:\n\nCELLSIZE=\tSize in bytes of the cells in this table. Must not be zero\nNUMDIMS=\tNumber of dimensions in this table\n\nDIMS=\tAddress of a table of words, each containing the maximum coord\ninate of its corresponding  dimension.\n\nRESULT=\tAddress of a double word to place the 64 bit result.\n\n\nRead a table element\n\nRead data from a specified table cell. This function is always perfo\nrmed synchronously\n\nLABEL   MXTABLES READ,\n              PREFIX=,\n              PARM=,\n              SYSNAME=,\n              ATOK=,\n              DEST=,\n              TOKEN=,\n         \t    COORDS=,\n              RETOK=,\n              ERROR=\n\nWhere:\n\nPREFIX=\t2 character prefix used on the SRUSPLST macro\nPARM=\t\taddress of a doubleword parameter area\n\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned (optional if ATOK used)\nATOK=\t\tMatrix Access token returned by SRVACCES. Optional, SYSNAME m\nay be used or the  ACCESS token can be placed in SRUSATOK.\n\nDEST=\t\tLocation in the applications program to receive the data retu\nrned by the read.\nTOKEN=\tToken of table to be read from.\nCOORDS=\tTable of one word entries containing the coordinates of the\ncell to read.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\nWrite a table element\n\nWrite data to a specified table cell. This function is always perfor\nmed synchronously.\n\nLABEL   MXTABLES WRITE,\n              PREFIX=,\n              PARM=,\n              SYSNAME=,\n              ATOK=,\n              SOURCE=,\n              TOKEN=,\n         \t    COORDS=,\n              RETOK=,\n              ERROR=\n\nWhere:\n\nPREFIX=\t2 character prefix used on the SRUSPLST macro\nPARM=\t\taddress of a doubleword parameter area\n\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned (optional if ATOK used)\nATOK=\t\tMatrix Access token returned by SRVACCES. Optional, SYSNAME m\nay be used or the ACCESS token can be placed in SRUSATOK.\n\nSOURCE=\tLocation in the applications program that contains the data\nto be placed in the cell.\nTOKEN=\tToken of table to write to.\nCOORDS=\tTable of one word entries containing the coordinates of the\ncell to be written.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\n\nConnect to a table.\n\nBefore a table can be used, an application must have a table token.\nThis function is always performed synchronously\n\nLABEL   MXTABLES CONNECT,\n             \tPREFIX=,\n            \t SYSNAME=,\n             \tATOK=,\n  \t\t          NAME=,\n\t\t            TOKEN=,\n             \tRETOK=,\n             \tERROR=\n\nWhere:\n\nPREFIX=\t2 character prefix used on the SRUSPLST macro\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned.\nATOK=\t\tMatrix Access token returned by SRVACCES. Optional, SYSNAME m\nay be used.\nTOKEN=\tAddress to place the table token. Optional. If not used the t\nable token is in R1.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\nLoad a table.\nLoad a table from a set of BASE and data files. This function may ru\nn synchronously or asynchronously. Neither the table nor any of its\ncomponents may exist when this is performed. This function will crea\nte the work areas and table components during the load.\n\nLABEL   MXTABLES LOAD,\n             \tPREFIX=,\n              PARM=,\n            \t SYSNAME=,\n             \tATOK=,\n  \t\t          NAME=,\n\t\t            DSNPRFX=,\n\t\t            SYNC=,\n             \tRETOK=,\n             \tERROR=\n\nWhere:\n\nPREFIX=\t2 character prefix used on the SRUSPLST macro\nPARM=\t\taddress of a doubleword parameter area\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned .\nATOK=\t\tMatrix Access token returned by SRVACCES. Optional, SYSNAME m\nay be used or the ACCESS token can be placed in SRUSATOK.\n\nNAME=\t\tName of table to be loaded\nDSNPRFX=\tDataset name prefix. A 44 byte field containing a partial d\nataset name padded to the right with spaces. The partial DSName is u\nsed as a prefix to the dataset names used by MX-Tables to load table\n files.\nSYNC=\t\tYES or NO.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\nSave a table.\nSave a table to a set of BASE and data files. This function may run\nsynchronously or asynchronously. The table and all of its components\n must exist when this is performed.\n\nLABEL   MXTABLES SAVE,\n             \tPREFIX=,\n              PARM=,\n            \t SYSNAME=,\n             \tATOK=,\n  \t\t          NAME=,\n\t\t            DSNPRFX=,\n\t\t            SYNC=,\n             \tRETOK=,\n             \tERROR=\n\nWhere:\n\nPREFIX=\t2 character prefix used on the MXMSGREC macro\nPARM=\t\taddress of a double word parameter area\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned .\nATOK=\tMatrix Access token returned by SRVACCES. Optionally, SYSNAME\nmay be used\nNAME=\t\tName of table to be saved\nDSNPRFX=\tDataset name prefix. A 44 byte field containing a partial d\nataset name padded to the right with spaces. The partial DSName is u\nsed as a prefix to the dataset names used by MX-Tables to save table\n files. When a table is saved its components are named as follows:\n\ndsnprfx.tnam.BASE\ttnam is the table name. BASE indicates a base file\ndsnprfx.tnam.ivwa\tivwa is the index VWA name\ndsnprfx.tnam.dvwa\tdvwa is the data VWA name\n\nSYNC=\t\tYES or NO.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\nDisconnect from a table.\nWhen all access to a table is completed, the application must discon\nnect from the table to free up resources.\n\nLABEL   MXTABLES DISCONNECT,\n            \t SYSNAME=,\n             \tATOK=,\n             \tTOKEN=,\n             \tRETOK=,\n             \tERROR=\n\nWhere:\n\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned .\nATOK=\tMatrix Access token returned by SRVACCES. Optional, SYSNAME ma\ny be used.\nTOKEN=\tToken of table to be disconnected from. Token was returned by\n MXTABLES CONNECT\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\nQuery table cell size.\n\nLABEL   MXTABLES QUERY,FIELD=CELLSIZE,\n             \tTOKEN=\n\nAt exit from the macro R1 contains the cell size.\n\nWhere:\n\nTOKEN=\tToken of table to be queried. Token was returned by MXTABLES\nCONNECT\n\nQuery table dimensions.\n\nLABEL   MXTABLES QUERY,FIELD=NUMDIMS,\n             \tTOKEN=\n\nAt exit from the macro R1 contains the number of dimensions.\n\nWhere:\n\nTOKEN=\tToken of table to be queried. Token was returned by MXTABLES\nCONNECT\n\nLocate a cell in a table.\n\nLABEL   MXTABLES LOCCELL,\n             \tTOKEN=,\n\t\tRESULT=\n\nAt exit from the macro the 64 bit address of the cell is in the RESU\nLT field.\n\nWhere:\n\nTOKEN=\tToken of table to be queried. Token was returned by MXTABLES\nCONNECT\nRESULT=\tAddress of  double word field to receive the 64 bit address.\n\n\nAllocate a cell in a varying cell length table.\nWhen a table array with varying length cells is created, each cell i\ns unallocated and has a length of zero. To be able to access a cell\nit must have a size. Allocating a cell sets the size of the specifie\nd cell. After it has been allocated the cell may be written to and r\nead from.\n\nLABEL   MXTABLES ALLOCCELL,\n            \t SYSNAME=,\n             \tATOK=,\n             \tPARM=,\n\t\t            TOKEN=,\n\t\t            COORDS=,\n\t\t            CELLSIZE=,\n             \tRETOK=,\n             \tERROR=\n\nAt exit from the macro the 64 bit address of the cell is in the RESU\nLT field.\n\nWhere:\n\nSYSNAME=\tThe four character name of the Matrix instance to be access\ned .\nATOK=\t\tMatrix Access token returned by SRVACCES. Optionally, SYSNAME\n may be used.\nTOKEN=\tToken of table to receive allocation. Was returned by MXTABLE\nS CONNECT\nCELLSIZE=\tSize in bytes of the cell to be allocated.\nCOORDS=\tAddress of table of one word entries. One entry for each dim\nension, each containing the\n\t\tcoordinate in that dimension.\nRETOK=\tOptional label to receive control if the request worked succe\nssfully.\nERROR=            \tOptional label to receive control if the request\nfailed\n\n\n\n\n\n\n1\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MXMTBLCB": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x03\\x10_\\x01\\x03\\x10_\\x03#\\x01<\\x01<\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-04-15T00:00:00", "modifydate": "2003-04-15T03:23:45", "lines": 316, "newlines": 316, "modlines": 0, "user": "IBMUSER"}, "text": "MX-Tables\nCOBOL\n Programming Reference Manual\n\n\nContents\nFunction Reference\t2\nCreate a Table\t3\nConnect to a Table\t4\nAllocate a cell in a Table\t5\nRead data from a Table\t6\nWrite data to a Table\t6\nDisconnect from a Table\t7\nLoad a Table\t7\nSave a Table\t8\nDelete a Table\t8\n\n\n\nFunction Reference\nMX-Tables is a Matrix function for creating and sharing tables in th\ne SYSPLEX. MX-Tables requires the Matrix applications programming en\nvironment and applications programs must be connected to Matrix to f\nunction. Before any of these functions are used the Matrix interface\n message block (MXPLIST) must be initialized by the MATRIX-ACCESS fu\nnction. See Matrix COBOL Programming Manual for further information.\nAn example of the access function could be written like this.\n\n\t\tMATRIX-ACCESS \tTO MATRIX-REQUEST.\n\t\tMOVE 'MTRX' \tTO MATRIX-ACCESS-NAME.\n\t\tMOVE LOW-VALUES \tTO MATRIX-ACCESS-TOKEN.\n\t\tMOVE MATRIX-SYNC \tTO MATRIX-REQUEST-FLAG.\n\t\tCALL 'MXSTUB'  USING MATRIX-REQUEST-MSG.\n\t\tIF RETURN-CODE = 0\n\t\t\tTHEN MOVE MATRIX-RETURN-ACCESS-TOKEN\n\t\t\tTO MATRIX-ACCESS-TOKEN\n\t\t\tELSE\n\n\nCreate a Table\nThere are two types of table, fixed length and variable length cell\ntables. In fixed length cell tables the sizes of the cells are all t\nhe same and are fixed when the table is created. In variable length\ncell tables the cell sizes may all be different and are set when the\ny are allocated. A fixed length table requires one Virtual Work Area\n for the data. A variable length table requires two VWA's, one for t\nhe index and one for the data. The VWA's required to construct a tab\nle must be created using MATRIX-CREATE-WA before the table is create\nd.  See Matrix COBOL Programming Manual for further information.\nTables may contain up to 12 dimensions. The range of coordinates in\neach dimension must be set before the table is created.\n\n      Table with variable length cells\n\n           MOVE MATRIX-CREATE-TABLE TO MATRIX-REQUEST.\n           MOVE tblname\t\t\tTO MATRIX-TABLE-NAME.\n           MOVE nDims \t\t\tTO MATRIX-TABLE-NUM-DIMS.\n           MOVE nDMax1 \t\t\tTO MATRIX-TABLE-DIMENSIONS(1).\n           MOVE nDMax2 \t\t\tTO MATRIX-TABLE-DIMENSIONS(2).\n           .....\n           MOVE nDMaxn \t\t\tTO MATRIX-TABLE-DIMENSIONS(n).\n           MOVE indexvwa\t\tTO MATRIX-TABLE-INDEX-NAME.\n           MOVE datavwa\t\t\tTO MATRIX-TABLE-DATA-NAME.\n           MOVE ZERO   \t\t\tTO MATRIX-TABLE-CELL-SIZE.\n           MOVE MATRIX-SYNC \t\tTO MATRIX-REQUEST-FLAG.\n           CALL 'MXSTUB'  USING MATRIX-REQUEST-MSG.\n           IF RETURN-CODE = 0\n           THEN\n           ELSE PERFORM 9000-MESSAGE.\n\n      Table with fixed length cells\n\n           MOVE MATRIX-CREATE-TABLE TO MATRIX-REQUEST.\n           MOVE tblname\t\t\tTO MATRIX-TABLE-NAME.\n           MOVE nDims \t\t\tTO MATRIX-TABLE-NUM-DIMS.\n           MOVE nDMax1 \t\t\tTO MATRIX-TABLE-DIMENSIONS(1).\n           MOVE nDMax2 \t\t\tTO MATRIX-TABLE-DIMENSIONS(2).\n           .....\n           MOVE nDMaxn \t\t\tTO MATRIX-TABLE-DIMENSIONS(n).\n           MOVE SPACES \t\t\tTO MATRIX-TABLE-INDEX-NAME.\n           MOVE datavwa \t\tTO MATRIX-TABLE-DATA-NAME.\n           MOVE nSiz   \t\t\tTO MATRIX-TABLE-CELL-SIZE.\n           MOVE MATRIX-SYNC \t\tTO MATRIX-REQUEST-FLAG.\n           CALL 'MXSTUB'  USING MATRIX-REQUEST-MSG.\n           IF RETURN-CODE = 0\n           THEN\n           ELSE PERFORM 9000-MESSAGE.\n\nWhere:\n\nMATRIX-TABLE-NAME\t\t\tfour character table name.\n\nMATRIX-TABLE-NUM-DIMS\t\t\tnumber of dimensions (up to 12)\n\nMATRIX-TABLE-DIMENSIONS(n)\t\tthe number of coordinates in the associa\nted \t\t\t\t\t\t\t\tdimension.\nMATRIX-TABLE-INDEX-NAME    \t\tname of index VWA. Spaces for fixed len\ngth \t\t\t\t\t\t\tcell table\nMATRIX-TABLE-DATA-NAME\t\t\tname of data VWA.\nMATRIX-TABLE-CELL-SIZE\t\t\tlength of cells in table. Zero if variable\nlength cell \t\t\t\t\t\t\ttable.\nMATRIX-REQUEST-FLAG\t\t\texecute synchronously (MATRIX-SYNC) or\nasynchronously (MATRIX-ASYNCH)\n\nConnect to a Table\nAn application must be connected to a table to be able to use it. Th\ne connection process returns a four character table token which is r\nequired on every other access to the table. The table token must be\nsaved in a variable in the applications program and presented to rea\nd and write cells. The token must be held until access to the table\nis no longer required at which point the token must be invalidated b\ny the disconnect process. Table connect is performed by function MXT\nABLEC which is part of the MXTABLES API.\n\n\n01 TABLE-TOKEN                PIC X(4).\n\n          MOVE tblname\t\tTO MATRIX-CONNECT-TABLE-NAME.\n          CALL 'MXTABLEC' USING MATRIX-REQUEST-MSG.\n          IF RETURN-CODE = 0\n          THEN MOVE MATRIX-RETURN-TABLE-TOKEN TO TABLE-TOKEN\n          ELSE\n\nWhere:\n\nMATRIX-CONNECT-TABLE-NAME\t\tfour character table name that access is\nrequired to.\n\n\nAllocate a cell in a Table\nIn variable length cell tables the cells have a size of zero until t\nhey are allocated. Each cell in a table that is to be used is alloca\nted with its own length which may be any size from 1 to 32786. The c\nell to be allocated is identified by its coordinates in a coordinate\n list. The coordinate list is specified separately from the request\nmessage because the request message is updated during calls to Matri\nx and running lists of coordinates would not be possible without a s\neparate list. The coordinate list must be prepared prior to the API\ncall and accompanies the message during the call.\n\n01 TABLE-COORD.\n    03 COORD-LIST              OCCURS 3 PIC 9(8) COMP.\n\n\n          MOVE nx\t      TO COORD-LIST(1).\n          MOVE ny       TO COORD-LIST(2).\n....\n          MOVE nz       TO COORD-LIST(n).\n          MOVE TABLE-TOKEN\tTO MATRIX-ALLOC-TABLE-TOKEN.\n          MOVE nCellSize   TO MATRIX-ALLOC-CELL-SIZE.\n          CALL 'MXTABLEA'  USING MATRIX-REQUEST-MSG TABLE-COORD.\n          IF RETURN-CODE = 0\n          THEN\n          ELSE\n\nWhere:\n\nMATRIX-ALLOC-TABLE-TOKEN\tThe token returned by Connect Table.\n\nMATRIX-ALLOC-CELL-SIZE\t\tSize to make the cell.\nCOORD-LIST\t\t\t\tTable of  numberic values. Each entry in the list is n\numbered\naccording to the dimension it represents. The numeric values in each\n entry is the coordinate in that dimension. Thus if the\n\t\t\t\t\trequired cell is (1,4,7) then COORD-LIST(1) = 1,\n\t\t\t\t\tCOORD-LIST(2) = 4 and COORD-LIST(3) = 7.\n\n\nRead data from a Table\nData is read from cells by the MXTABLER API call. The function requi\nres the coordinates of the cell to read in a coordinate list. A data\n area may be specified to read the cell into. This is passed to MXTA\nBLER as the second parameter. This parameter may be omitted, in whic\nh case the record will be returned in a buffer. The buffer address i\ns returned in MATRIX-RETURN-READ-ADDR. This buffer should be freed a\ns soon as it is no longer needed. The actual length read is returned\n in MATRIX-RETURN-LEN-READ.\n\n01 WS-DATA-AREA                PIC X(200).\n01 TABLE-COORD.\n    03 COORD-LIST              OCCURS 3 PIC 9(9) COMP.\n\n           MOVE nx\t      TO COORD-LIST(1).\n           MOVE ny       \tTO COORD-LIST(2).\n....\n           MOVE nz       \tTO COORD-LIST(n).\n           MOVE TABLE-TOKEN\tTO MATRIX-READ-TABLE-TOKEN.\n           CALL 'MXTABLER'  USING MATRIX-REQUEST-MSG WS-DATA-AREA\n                                  TABLE-COORD.\n           IF RETURN-CODE = 0\n           THEN DISPLAY WS-DATA-AREA\n \t\t             MOVE MATRIX-RETURN-LEN-READ TO LEN-READ\n \t\t             MOVE MATRIX-RETURN-READ-ADDR TO READ-ADDR\n           ELSE\nWhere:\n\nMATRIX-READ-TABLE-TOKEN\t\tThe token returned by Connect Table.\n\n\n\nWrite data to a Table\nData is written to cells by the MXTABLEW API call. The function requ\nires the coordinates of the target cell in a coordinate list. A data\n area containing the data to be written is required to be passed to\nMXTABLER as the second parameter.\n\n\n           MOVE nx\t      TO COORD-LIST(1).\n           MOVE ny       TO COORD-LIST(2).\n....\n           MOVE nz       TO COORD-LIST(n).\n\t          MOVE TABLE-TOKEN TO MATRIX-WRITE-TABLE-TOKEN.\n           CALL 'MXTABLEW'  USING MATRIX-REQUEST-MSG WS-DATA-AREA\n                                  TABLE-COORD.\n           IF RETURN-CODE = 0\n           THEN\n           ELSE\n\n\nDisconnect from a Table\nWhen access to a table is no longer required the application must di\nsconnect from it before exiting. Disconnect is handled by MXTABLED.\n\n\n           MOVE TABLE-TOKEN TO MATRIX-DISCON-TABLE-TOKEN.\n           CALL 'MXTABLED'  USING MATRIX-REQUEST-MSG.\n           IF RETURN-CODE = 0\n           THEN\n           ELSE\n\n\nLoad a Table\nTables may be saved to data files and be reloaded when required. No\npart of a table may be resident in any part of the sysplex when a ta\nble is loaded. If any VWA is present the load will fail and the tabl\ne will not be created. The base table file must be accessible to the\n CPU that this command is running on. The Index and data portions of\n tables do not need to be. They may be accessible to other CPU's in\nthe sysplex, in which case that portion of the table will be loaded\n on that CPU. This is potentially a long running task and it may be\ndispatched asynchronously.\n\n           MOVE MATRIX-LOAD-TABLE TO MATRIX-REQUEST.\n           MOVE tNam\t\t   TO MATRIX-LOAD-TABLE-NAME .\n           MOVE DSNPFX   TO MATRIX-LOAD-TABLE-DSNAME.\n           CALL 'MXSTUB'  USING MATRIX-REQUEST-MSG.\n           IF RETURN-CODE = 0\n           THEN\n           ELSE\n\nWhere:\n\nMATRIX-LOAD-TABLE-NAME \t\tName of table to load\nMATRIX-LOAD-TABLE-DSNAME\tDatasetname prefix to use when forming DSNa\nmes for table \t\t\t\t\t\tcomponents.\n\nThe dataset names for tables is:\n\t\tPREFIX.TNAME.BASE - Table descriptor\n\t\tPREFIX.TNAME.inam  -  Index file. inam is the VWA name given to th\ne index\n\t\tPREFIX.TNAME.dnam  -  Data file. dnam is the VWA name given to the\n data\n\n\n\nSave a Table\nTables may be saved to data files and be reloaded when required. If\ncomponents of tables exist on CPU's other that the one on which this\n command is running they will be saved on their resident system and\nMatrix will look for those systems when reloading the tables. This i\ns potentially a long running task and it may be dispatched asynchron\nously.\n\n\n           MOVE MATRIX-SAVE-TABLE TO MATRIX-REQUEST.\n           MOVE tNam\t   TO MATRIX-SAVE-TABLE-NAME .\n           MOVE DSNPFX  TO MATRIX-SAVE-TABLE-DSNAME.\n           CALL 'MXSTUB'  USING MATRIX-REQUEST-MSG.\n           IF RETURN-CODE = 0\n           THEN\n           ELSE\n\nWhere:\n\nMATRIX-SAVE-TABLE-NAME \t\tName of table to save\nMATRIX-SAVE-TABLE-DSNAME\t\tDatasetname prefix to use when forming DSN\names \t\t\t\t\tfor table \tcomponents.\n\nDelete a Table\nWhen a table is finished with it should be deleted..\n\n\n           MOVE MATRIX-DELETE-TABLE TO MATRIX-REQUEST.\n           MOVE TABLE-TOKEN TO MATRIX-DELETE-TABLE-TOKN.\n           MOVE MATRIX-FORCE TO MATRIX-DELETE-TABLE-FORC.\n           CALL 'MXSTUB'  USING MATRIX-REQUEST-MSG.\n           IF RETURN-CODE = 0\n           THEN\n           ELSE\n\nWhere:\n\nMATRIX-DELETE-TABLE-TOKN\t\tToken of table to delete\nMATRIX-DELETE-TABLE-FORC\t\tMATRIX-FORCE will delete the table even if\n                          it is still in use by others.\n\t\t\t\t\t                     MATRIX-NOFORCE will not delete a\n\t\t\t\t\t                     table or components if they are in use.\n\n\n\n\n\n\n1\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MXMTSO01": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00X\\x01\\x03\\x10O\\x01\\x03\\x10_\\x023\\x04m\\x00\\xf7\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-15T02:33:58", "lines": 1133, "newlines": 247, "modlines": 0, "user": "IBMUSER"}, "text": "\n\n\n\nMATRIX Utilities\n\nMatrix V2.2 TSO Utility Guide\n\n\nContents\nIntroduction\t1\nTSO Control Program\t1\nMXD1\t1\nInstructions\t2\nM101\t3\nM200\t3\nM300\t3\nM400\t4\nM700\t4\nM810\t4\nM900\t5\nMA00\t5\nBatch Control Program\t5\nRunning the program\t5\nInput Parameters\t5\n\n\nIntroduction\nMatrix is controlled by commands and requests from applications prog\nram. The Matrix TSO Utility program (MXDIALOG) is an example of a Ma\ntrix application. The Matrix TSO utility program allows the user to\ncontrol, monitor and manage Matrix objects. Each panel gives a visua\nl representation of one Matrix API function.\n\nTSO Control Program\n\nThe TSO control program is started at the READY prompt or at the ISP\nF command shell by\n\nCALL 'hlq.MATRIX.UTIL.LOAD(MXDIALOG)'\n\nThe control program is presented as a series of panels that follow o\nne consistent look and feel.\nThe use of PF keys has been standardized so that when the situation\nwarrents\n\nPF1\t-\tHelp\nPF3\t-\tReturn\nPF7\t-\tPage Backwards\nPF8\t-\tPage Forwards\n\nEach Program is identified by a 4 character ID in screen position 0,\n0.\n\nWhen the utility starts up it presents panel MINI to get the name of\nthe Matrix image you wish to connect to.\n\n\n MINI                    Matrix V2.2 API Demonstration\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n     Enter the Matrix Server name\n\n     that you wish to connect to  MTRX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n PF3-End\n\nOnce a connection is established to a Matrix image the first of a series\nof menus is displayed. To advance through a menu enter the number\ncorresponding to the function you require.\n\n\n\n\n\n MX00                        Matrix V2.2 Utilities\n\n\n\n     1  -  Space Management\n     2  -  Table Management\n     3  -  Events\n\n     X  -  Exit\n\n     Enter Selection: __\n\n\n\n\n\n\n\n\n\n\n\n\n PF1=Help PF3=End\n\n\n\n\nMXD1 -  menu of Matrix space management functions.\n\n MXD1                Matrix V2.2 Space Management Utilities\n\n\n\n\n\n\n\n     1  -  Display Space Allocation\n     2  -  Display Work Areas\n     3  -  Create Work Area\n     4  -  Adjust Work Area size\n     5  -  Delete Work Area\n     6  -  Load Work Area from File\n     7  -  Save Work Area to File\n     8  -  Copy Data between Work Areas\n     9  -  Edit Contents of Work Area\n     10 -  Exchange Work Areas\n     11 -  Associate Work Area with File\n     12 -  Search Work Area\n\n\n\n     X  -  Exit\n\n\n\n     Enter Selection: __\n\n\n\n\n\n\n\n PF1=Help PF3=End\n\n\n\nD300 - Menu of table functions\n\n D300                         Matrix V2.2 MXTables\n\n\n\n\n\n\n\n     1  -  Create a Table\n     2  -  Delete a Table\n     3  -  List Tables\n     4  -  Load a Table\n     5  -  Save a Table\n     6  -  Display Table Contents\n\n\n\n     X  -  Exit\n\n\n\n     Enter Selection: __\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n PF1=Help PF3=End\n\n\n\n\n\nM100 - list of all allocated and unallocated space\nWhen space is allocated its size is shown, along with the number of\nwork areas currently allocated in it.\nUnallocated spaces are shown as UNALLOC\nActions may be requested by entering a request into the selection fi\neld beside the space.\n\n\n M100               Matrix V2.2 Space Allocation\n          Server Name\n   Space # 000   -  013  of 250 on Server  MTRX\n\n\n      Space Size (K)   #WA     Used (K)  Free (K)\n       000  02097152   003     00544768  01552384\n       001  02097152   001     00032768  02064384\n       002  UNALLOC\n       003  UNALLOC\n       004  UNALLOC\n       005  UNALLOC\n       006  UNALLOC\n       007  UNALLOC\n       008  UNALLOC\n       009  UNALLOC\n       010  UNALLOC\n       011  UNALLOC\n       012  UNALLOC\n       013  UNALLOC\n\n\n\n\n\n  Command =>\n\n\n   MORE\n  ENTER PF1=Help PF3=End PF7=Bwd PF8=Fwd\n\nInstructions\nEnter a function request or press a PF-Key\n\nThe following selections are defined\n\nS\tSELECT \t\tView additional information\n\n\nM101 - Matrix V2.2 Space Division Display\n\n  M101               Matrix V2.1 Space Division Display\n\n    Space # 000      Segments = 001\n\n       Seg  Size(K)  Address    Token\n     _ 001 02097152  00000000  0101001C\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Command =>\n  NO MORE TO DISPLAY\n  ENTER=Select PF1=Help PF3=End PF7=Bwd PF8=Fwd\n\n  Instructions\nPress a PF-Key\n\n\n\n\nM200   -  Display Virtual Work Areas\n\n  M200               Matrix V2.2 Virtual Work Areas\n\n\n\n            000   -  013  of 250 on Server  MTRX\n\n\n\n           Name  Size (K)  Blk   Recsz Users\n\n   _   000 SSSS   2097152  001   00000 00000\n   _   001 TTTT     12288  001   00000 00000\n   _   002 RRRR    204800  001   00000 00000\n   _   003       UNALLOC\n   _   004       UNALLOC\n   _   005       UNALLOC\n   _   006       UNALLOC\n   _   007       UNALLOC\n   _   008       UNALLOC\n   _   009       UNALLOC\n   _   010       UNALLOC\n   _   011       UNALLOC\n   _   012       UNALLOC\n   _   013       UNALLOC\n\n\n\n\n\n  Command =>\n\n\n   MORE\n  ENTER PF1=Help PF3=End PF7=Bwd PF8=Fwd\n\n\n  Instructions\nEnter a function request or press a PF-Key\n\nThe following selections are defined\n\n A - Allocate a Work Area\n C - Copy between Work Areas\n D - Delete the Work Area\n E - Edit Work Area\n F - Find data in Work Area\n L - Load file into Work Area\n S - Save Work Area to file\n T - Associate Work Area with File\n X - Exchange Work Areas\n\n\n M400 - Create Virtual Work Area\n\n M400                    Matrix V2.2\n\n                 Create Virtual Work Area\n\n\n\n     Server Name MTRX\n\n\n     Enter:\n\n\n         Work Area Name         Read Only? N\n\n         Size              2048 M Units (B,K,M,G)\n\n\n\n\n\n     Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n\n Command =>\n\n\n\n PF3-End\n\n  Instructions\nEnter the new work area name and its size. If you wish to have the t\nask run asynchronously enter N at 'Wait for task to complete'.  Pres\ns enter when panel is complete. When you have finished defining Virt\nual Work Areas, press PF3 to exit.\n\n\n\nM500 - Delete Work Area\n\n M500                    Matrix V2.2\n                      Delete Work Area\n\n\n     Enter:\n\n         Work Area Name        On Server MTRX\n\n         Force Delete?  N\n\n\n     Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n Command =>\n\n PF3-End\n\n  Instructions\nEnter the work area name to be deleted. If you wish to have the task\n run asynchronously enter N at 'Wait for task to complete'.  Press e\nnter when panel is complete. When you have finished deleting Virtual\n Work Areas, press PF3 to exit. To forcefully delete a work area eve\nn if it is in use enter Y at Force Delete.  If force is used applica\ntions using this space will fail.\n\n\nM600 - Load Work Area on Server MTRX\n\n M600                    Matrix V2.1\n\n     Load Work Area on Server MTRX\n\n\n     Enter:\n\n         Work Area Name\n         Data Set Name\n\n\n     Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n Command =>\n\n PF3-End\n\n\n\nM700 - Save Work Area\n\n M700                    Matrix V2.1\n\n     Save Work Area on Server MTRX\n\n\n\n     Enter:\n\n\n         Work Area Name\n\n         Data Set Name\n\n\n     Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n Command =>\n\n PF3-End\n\n\n\nM800 -  Display Work Area\n\n M800                    Matrix V2.0\n                      Display Work Area\n\n\n\n\n     Enter:\n\n\n         Work Area Name        On Server MTRX\n\n\n\n\n\n\n\n\n\n\n\n Command =>\n\n PF3-End\n\n\n\n\nM810                 Matrix V2.2 Work Area Contents\n\n  M810                 Matrix V2.1 Work Area Contents\n\n  Work Area Name TTTT on Server MTRX                   Update Work Area\n\n\n\n  0000000000000000 - 00000000000000F0                  Length 000000\n0000C00000\n  +-- Address ---+\n\n  0000000000000000  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000010  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000020  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000030  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000040  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000050  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000060  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000070  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000080  00000000 00000000   00000000 00000000   * ......\n.......... *\n  0000000000000090  00000000 00000000   00000000 00000000   * ......\n.......... *\n  00000000000000A0  00000000 00000000   00000000 00000000   * ......\n.......... *\n  00000000000000B0  00000000 00000000   00000000 00000000   * ......\n.......... *\n  00000000000000C0  00000000 00000000   00000000 00000000   * ......\n.......... *\n  00000000000000D0  00000000 00000000   00000000 00000000   * ......\n.......... *\n  00000000000000E0  00000000 00000000   00000000 00000000   * ......\n.......... *\n\n\n  Command =>\n\n\n\n  ENTER=Select PF1=Help PF3=End PF7=Bwd PF8=Fwd\n\n\nEnter 'Y' in 'Update Work Area' before editing the HEXADECIMAL data\narea.\nThe update will be performed immediately and all shared users of the\n space will see the change at the same time.\n\nIf the 'Update Work Area' is not selected any changes made to the pa\nnel will not update the work area.\n\n\n\nM900                    Matrix V2.2\n\n      Copy Data Between Work Areas on   MTRX\n\n\n      Copy:\n\n          From:\n               Work Area Name\n               Copy From Addr        0\n\n          To:\n               Work Area Name\n               Copy To Addr          0\n\n          Length To Copy             0\n\n      Wait for task to complete? Y (Y/N)\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\nMA00 - Search Work Area\n\n  MA00                    Matrix V2.1\n\n      Search Work Area on Server  MTRX\n\n      Enter:\n\n          Work Area Name\n\n          Length to Scan                  0\n          Start Address    0000000000000000\n\n          Data To Locate:\n          Char\n          Hex\n\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\n\nMB00 - Exchange Work Areas\n\n  MB00                    Matrix V2.1\n\n      Exchange Work Areas on Server MTRX\n\n      Enter:\n          Space Number\n\n          Source Work Area Name\n          Target Work Area Name\n\n\n          Wait if Work Area not Free N\n          Wait for task to Complete? Y\n\n\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\nMD00 - Associate Work Area with File\n\n  MD00                    Matrix V2.1\n\n      Associate Work Area with File\n\n      On Server MTRX\n\n      Enter:\n\n          Work Area Name\n\n          Data Set Name\n\n          Assoc/Disassoc\n\n      Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\n\nD300 - MX-Tables main menu\n\n D300                         Matrix V2.2 MXTables\n\n\n\n\n\n\n\n     1  -  Create a Table\n     2  -  Delete a Table\n     3  -  List Tables\n     4  -  Load a Table\n     5  -  Save a Table\n     6  -  Display Table Contents\n\n\n     X  -  Exit\n\n\n\n     Enter Selection: __\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n PF1=Help PF3=End\n\n\nT100 - Create Table\n\n  T100                    Matrix Tables\n\n      Create Table on Server MTRX\n\n\n\n      Enter:\n\n\n\n          Table Name                Shr / Priv S\n\n          Num Dims           3\n\n          Cell Size        100\n\n          Index VWA                 Create? Y                0\n\n          Data VWA                  Create? Y                0\n\n\n\n  Enter Coordinates in each Dimension\n\n\n\n                    0         0         0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Command =>\n\n\n\n  PF3-End\n\n\nT200 - List of tables\n\n  T200               Matrix V2.1\n\n      Tables on Server MTRX\n\n            TBL1\n\n\n\n           Name I-VW D-VW    Dims  Cell Len\n\n   _       TBL1 TTTT SSSS        3        0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Command =>\n\n\n   END\n  ENTER PF1=Help PF3=End PF8=Fwd\n\n\n\nT300 - Delete Table\n\n  T300                    Matrix V2.1\n\n      Delete Table from Server MTRX\n\n\n\n      Enter:\n\n\n          Table Name:\n\n          Force Delete?  N\n\n\n      Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\nT600 - Load Table\n\n  T600                    Matrix V2.2\n\n\n\n      Load Table\n\n\n\n      Server name: MTRX\n\n\n\n\n\n\n\n      Enter:\n\n          Table Name\n\n\n\n          Data Set Prefix\n\n\n\n\n\n      Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Command =>\n\n\n\n  PF3-End\n\n\n\nT700 - Save Table\n\n\n\n  T700                    Matrix V2.2\n\n      Save Table\n\n      Server name: MTRX\n\n\n\n      Enter:\n          Table Name\n\n          Data Set Prefix\n\n\n      Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\nT800 - Display Table Contents\n\n  T800                    Matrix V2.1\n                       Display Table Contents\n\n\n\n\n      Enter:\n\n\n          Table Name      on Server MTRX\n\n\n\n\n\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\nT810                 Matrix V2.1 Table Contents\n\n  Table Name     TBL1 on Server MTRX Cell Len:   132   Update Cell\n    N\n  Dims:        3    200,10,50\n\n  Cell Coordinates: 0,0,0\n\n\n\n        0000  00000000 00000000   00000000 00000000   * ............\n.... *\n        0016  00000000 00000000   00000000 00000000   * ............\n.... *\n        0032  00000000 00000000   00000000 00000000   * ............\n.... *\n        0048  00000000 00000000   00000000 00000000   * ............\n.... *\n        0064  00000000 00000000   00000000 00000000   * ............\n.... *\n        0080  00000000 00000000   00000000 00000000   * ............\n.... *\n        0096  00000000 00000000   00000000 00000000   * ............\n.... *\n        0112  00000000 00000000   00000000 00000000   * ............\n.... *\n        0128  00000000                                * ....\n     *\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Command =>\n\n\n\n  ENTER=Select PF1=Help PF3=End PF7=Bwd PF8=Fwd\n\n\n\n\n\n\nME00               Matrix V2.2 Events\n\n     On Server MTRX\n\n           SEQ00001\n\n\n            Name   Waiting   State\n\n  _       SEQ00001        0 POSTED\n  _       SEQ00002        0 UNUSED\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Command =>\n\n No more to display\n  END\n ENTER PF1=Help PF3=End PF8=Fwd\n\n\n\nME02                    Matrix V2.2\n\n                       Post Event on Server MTRX\n\n\n\n      Enter:\n\n\n          Event Name SEQ00001\n\n\n\n\n      Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\nME04                    Matrix V2.0\n\n      Reset Event on Server MTRX\n\n\n\n      Enter:\n\n\n          Event Name SEQ00001\n\n\n\n\n      Wait for task to complete? Y (Y/N)\n\n\n\n\n\n\n  Command =>\n\n  PF3-End\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAMPLOAD": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x03i\\x03i\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 873, "newlines": 873, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SAMPMAC": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x00U\\x00U\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SAMPOBJ": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x00\\xda\\x00\\xda\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 218, "newlines": 218, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "SAMPSRCE": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\x08.\\x08.\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 2094, "newlines": 2094, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "UTILLOAD": {"ttr": 6920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x01\\x03\\x10O\\x01\\x03\\x10O\\x12\\x00\\r\\xc8\\r\\xc8\\x00\\x00\\xd4\\xc1\\xe3\\xd9\\xc9\\xe7@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2003-04-14T00:00:00", "modifydate": "2003-04-14T12:00:00", "lines": 3528, "newlines": 3528, "modlines": 0, "user": "MATRIX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT622/FILE622.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT622", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}