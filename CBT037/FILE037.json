{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011116000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE037.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE037.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x03'", "DS1TRBAL": "b'\\xc1\\x82'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00L\\x00\\x0e\\x00M\\x00\\x08\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "$$DOC......THIS MEMBER\n$CBTJCL....THE JCL USED AT CBT TO  INSTALL\n$MANUAL....THE COPYCAT MANUAL\n$UCLAJCL...THE JCL USED AT UCLA TO INSTALL\nCOPYCAT....COPYCAT CODE ITSELF\nFIX1.......FIX ESATE01 - CONVERTS COPYCAT FROM STAE TO ESTAE USE\n           AND CORRECTS AN S30A ABEND THAT OCCURS FOLLOWING AN X37 ABEND\nFIX2.......FIX XCP200  - CORRECTS AN S200 ABEND THAT INTERMITTENTLY OCCU\n           IN COPYCAT AFTER AN 'X37' ABEND DUE TO ALL OF THE I/O NOT\n           HAVING COMPLETED BEFORE SVC55 IS ISSUED FOR AN END-OF-VOLUME\n           INDICATION.\nOAC1.......FIX DEV3380 - ADDS 3380 SUPPORT TO COPYCAT\nOAC2.......FIX HASH001 - UCLA LOCAL MODE . SEE MEMBER FOR ADDITIONAL\n           INFORMATION\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CBTJCL": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//CBT1386 JOB 527TSO000S0008,COPYCAT,CLASS=J,MSGCLASS=6\n//STEP00    EXEC PGM=CBT299,PARM='TEC.CBT1386.PDS'\n//STEP01    EXEC PAN,SO=6\n++WRITE WORK,CBT1386\n//STEP02    EXEC PGM=PDSLOAD\n//SYSPRINT  DD   SYSOUT=*\n//SYSUT1    DD   DSN=&WORK,DISP=(OLD,DELETE)\n//SYSUT2    DD   DSN=TEC.CBT1386.PDS,DISP=(NEW,CATLG),UNIT=SYSDA,\n//          SPACE=(CYL,(2,2,35)),DCB=(LRECL=80,BLKSIZE=19040,RECFM=FB)\n//STEP03    EXEC PGM=IEBUPDTE\n//SYSPRINT  DD   SYSOUT=*\n//SYSUT1    DD   DISP=SHR,DSN=TEC.CBT1386.PDS\n//SYSUT2    DD   DISP=SHR,DSN=TEC.CBT1386.PDS\n//SYSIN     DD   DISP=SHR,DSN=TEC.CBT1386.PDS(FIX1)\n//STEP04    EXEC PGM=IEBUPDTE\n//SYSPRINT  DD   SYSOUT=*\n//SYSUT1    DD   DISP=SHR,DSN=TEC.CBT1386.PDS\n//SYSUT2    DD   DISP=SHR,DSN=TEC.CBT1386.PDS\n//SYSIN     DD   DISP=SHR,DSN=TEC.CBT1386.PDS(FIX2)\n//STEP05    EXEC PGM=IEBUPDTE\n//SYSPRINT  DD   SYSOUT=*\n//SYSUT1    DD   DISP=SHR,DSN=TEC.CBT1386.PDS\n//SYSUT2    DD   DISP=SHR,DSN=TEC.CBT1386.PDS\n//SYSIN     DD   DISP=SHR,DSN=TEC.CBT1386.PDS(OAC1)\n//STEP06    EXEC ASMBLR,SO=6\n//SYSIN     DD   DSN=TEC.CBT1386.PDS(COPYCAT),DISP=SHR\n//STEP07    EXEC TESTLINK,SO=6,LIB='SYS2.MLINKLIB',NAME=CBT1386\n//SYSIN     DD   *\n ALIAS COPYCAT\n/*\n//STEP08    EXEC PGM=CBT299,PARM='TEC.CBT1386.PDS'\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MANUAL": {"ttr": 520, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " M\n\n                    COPYCAT - OS CATALOG UTILITY PROGRAM\n                                     BY\n                             DOUGLAS E. ENGERT\n                        APPLIED MATHEMATICS DIVISION\n                        ARGONNE NATIONAL LABORATORY\n                           9700 SOUTH CASS AVENUE\n                          ARGONNE, ILLINOIS 60439\n\n\n    THIS 12-77 VERSION CONTAINS SEVERAL MINOR FIXES FROM ARGONNE\n    (\"F00001\" & \"F00003\") AND A MAJOR SPEED ENHANCEMENT TO THIS\n    ALREADY FAST PROGRAM IN THAT THE CATALOG I/O IS NOW DONE AT\n    EXCP LEVEL (\"EXCP01\").  A FIX FROM UCLA FOR A LITTLE MORE\n    SPEED YET IS ALSO INCLUDED (\"CCN\").  THE HARDCODED BLKSIZES\n    FOR SYSIN AND SYSPRINT HAVE BEEN CHANGED TO 3200 AND 605.\n                              F. PAJERSKI   NASA/GSFC   01DEC77\n\n\n                             TABLE OF CONTENTS\n\n      ABSTRACT\n\n      1.0 INTRODUCTION\n\n      2.0 USER MANUAL\n\n        2.1 FUNCTIONS\n\n          2.1.1 REDISTRIBUTION\n          2.1.2 RESTRUCTURING\n          2.2.3 MASTER AND SECONDARY CATALOGS\n          2.1.4 MASTER MODE\n          2.1.5 SECONDARY MODE\n          2.1.6 MODEL GENERATION DATA GROUP DSCBS\n          2.1.7 ADDITIONAL CVOL PROCESSING\n          2.1.8 ALIAS PROCESSING\n          2.1.9 MULTIPLE INPUTS\n\n        2.2 CONTROL CARDS\n\n          2.2.1 CONTROL\n          2.2.2 INPUT\n          2.2.3 OUTPUT\n          2.2.4 CVOL\n          2.2.5 LEVEL\n\n        2.3 JOB CONTROL STATEMENTS\n\n        2.4 MESSAGES AND CODES\n\n        2.5 EXAMPLES\n\n          2.5.1 COPY A CATALOG FROM ONE VOLUME TO ANOTHER\n          2.5.2 BACK UP A CATALOG\n          2.5.3 REDISTRIBUTE A CATALOG\n\n      3.0 PROGRAM LOGIC\n\n\n                COPYCAT IS AN  OS  UTILITY  PROGRAM  DESIGNED  TO\n           IMPROVE   PERFORMANCE  OF  OS  CATALOG  MANAGEMENT  BY\n           PRODUCING A RESTRUCTURED COPY OF A CATALOG IN ORDER TO\n           USE  THE  EXISTING  ACCESS  METHODS  MOST EFFECTIVELY.\n           MULTIPLE INPUT AND OUTPUT CATALOGS ARE  PROCESSED  AND\n           THE  REDISTRIBUTION  OF  THE  ENTRIES  IS  UNDER  USER\n           CONTROL. MODEL DSCBS FOR GENERATION  DATA  GROUPS  AND\n           ALIAS  ENTRIES  ARE  ALSO  PROCESSED.  CATALOGS ON ALL\n           DIRECT  ACCESS  DEVICES,  INCLUDING  DATA  CELLS,  ARE\n           SUPPORTED. BACKUP COPIES MAY ALSO BE MADE.\n\n\n      1.0 INTRODUCTION\n\n           COPYCAT IS AN OS UTILITY PROGRAM  DESIGNED  TO  PRODUCE  AN\n      EFFICENT  SYSTEM  WIDE CATALOG WHICH MAY RESIDE ON MANY VOLUMES.\n      SUBSTANTIAL IMPROVEMENT IN PERFORMANCE MAY ALSO BE OBTAINED ON A\n      SYSTEM  WITH  ONLY  A  SINGLE CATALOG. THIS IS ACCOMPLISHED IN A\n      NUMBER OF WAYS.  FIRST,  CATALOG  ENTRIES  FROM  MANY  DIFFERENT\n      CATALOGS  MAY  BE  REDISTRIBUTED  TO  EQUALIZE  THE LOAD ON EACH\n      INDIVIDUAL  CATALOG.  SECOND,   EACH   INDIVIDUAL   CATALOG   IS\n      RESTRUCTURED IN A WAY DESIGNED TO MINIMIZE THE I/O TIME REQUIRED\n      BOTH  FOR  SEARCHING  AND  UPDATING.  THE   REDISTRIBUTION   AND\n      RESTRUCTURING  PARAMETERS  ARE UNDER THE CONTROL OF THE USER WHO\n      SHOULD HAVE SOME KNOWLEDGE OF OS CATALOG MANAGEMENT.\n\n           OUR INSTALLATION AT ARGONNE CONSISTS OF A 370/195, USED FOR\n      BATCH  PROCESSING,  AND A 360/75 USED FOR TIME SHARING. THE TIME\n      SHARING SYSTEM, TSO, SHARES ALL ITS ONLINE DEVICES WITH THE 195.\n      SINCE  ALL  DATASETS  USED  BY  TSO  MUST BE CATALOGED, THEY ARE\n      CATALOGED ON THE RESIDENT VOLUME FOR THE 75 TO ALLOW BATCH  JOBS\n      TO  ACCESS TSO DATASETS. THIS HAS PLACED AN EXTREMELY HEAVY LOAD\n      ON THIS SHARED CATALOG, WHICH OCCUPIES ABOUT 20 CYLINDERS  ON  A\n      2314.  AFTER  SOME  STUDY OF THE SITUATION IT WAS FOUND THAT THE\n      ORGANIZATION OF THE  SHARED  CATALOG  WAS  ONE  OF  OUR  BIGGEST\n      BOTTLENECKS.  AFTER  RUNNING COPYCAT, SOFTWARE MONITORING SHOWED\n      THE PERCENT OF UNIT BUSY TIME OF THE SYSTEM RESIDENT VOLUME  FOR\n      THE  75  DROPPED  FROM  ABOUT  80%  TO ABOUT 20%, THE PERCENT OF\n      ENQUEUE WAIT FOR THE CATALOG DROPPED FROM  ABOUT  10%  TO  ABOUT\n      .1%,  AND  THE  NUMBER OF EXCPS REQUIRED TO LOGON TO TSO DROPPED\n      FROM ABOUT 120 TO 70.\n\n      2.0 USER MANUAL\n\n      2.1 FUNCTIONS\n\n           TWO DIFFERENT TYPES OF CATALOG SYSTEMS CAN BE PROCESSED  BY\n      COPYCAT.  THE FIRST IS THE STANDARD OS CATALOG SYSTEM CONSISTING\n      OF THE MASTER CATALOG ON THE SYSTEM RESIDENT VOLUME AND ZERO  OR\n      MORE  CATALOGS  ON  OTHER  VOLUMES.  THE  SECOND TYPE OF CATALOG\n      SYSTEM DOES NOT HAVE A MASTER CATALOG, BUT INSTEAD HAS  A  TABLE\n      BUILT  INTO  THE  CATALOG MANAGEMENT ROUTINES USED TO SELECT THE\n      FIRST CATALOG TO BE SEARCHED. THE CHANGES NEEDED FOR  THIS  TYPE\n      OF CATALOG SYSTEM MUST BE LOCALLY WRITTEN.\n\n\n      2.1.1 REDISTRIBUTION\n\n           WHEN MORE THAN ONE CATALOG IS BEING CREATED, REDISTRIBUTION\n      PARAMETERS  ARE  REQUIRED.  THESE PARAMETERS ARE SUPPLIED ON THE\n      OUTPUT CARDS IN THE FORM OF A RANGE OF NAMES. THE UPPER BOUND IS\n      DEFINED  ON  EACH  OUTPUT  CARD,  AND THE RANGE EXTENDS FROM THE\n      UPPER BOUND OF THE PREVIOUS CARD TO THIS UPPER BOUND. AN  EBCDIC\n      COLLATING SEQUENCE IS USED.\n\n      2.1.2 RESTRUCTURING\n\n           THE MAIN FUNCTION OF COPYCAT IS TO RESTRUCTURE A CATALOG SO\n      AS  TO TAKE ADVANTAGE OF THE CATALOG MANAGEMENT I/O ROUTINES. TO\n      DO THIS THREE PARAMETERS MAY BE SPECIFIED FOR EACH INDEX  LEVEL.\n      THE  FIRST  IS  THE  NUMBER  OF BYTES TO LEAVE IN EACH BLOCK FOR\n      EXPANSION.  BY  LEAVING  ENOUGH  ROOM,  THE  CATALOG  MANAGEMENT\n      ROUTINES  WILL  BE ABLE TO ADD ENTRIES WITHOUT HAVING TO ADD NEW\n      BLOCKS. EACH CVOL  POINTER  TAKES  TWENTY-TWO  (22)  BYTES,  AND\n      SINGLE  VOLUME  DATASET  ENTRIES  TAKE  TWENTY-SIX  (26)  BYTES.\n      SECOND, THE NUMBER OF DUMMY BLOCKS TO BE LEFT AFTER AN INDEX MAY\n      BE SPECIFIED SO THE INDEX CAN EXPAND AND NEW LOWER LEVEL INDEXES\n      CAN BE ADDED IN CLOSE PROXIMITY. THIRD,  THE  NUMBER  OF  BLOCKS\n      THAT  MUST  BE  ON A TRACK BEFORE STARTING THE NEXT INDEX MAY BE\n      GIVEN. SINCE INDEXES MAY REQUIRE MORE THEN  ONE  BLOCK,  AND  AN\n      INDEX  CAN  BE  SEARCHED  IN  ONE  I/O OPERATION IF IT IS ON ONE\n      TRACK, THIS NUMBER SHOULD BE SET LARGE ENOUGH SO MOST INDEXES AT\n      A PARTICULAR LEVEL CAN FIT ON ONE TRACK.\n\n      2.1.3 MASTER AND SECONDARY CATALOGS\n\n           WHEN MORE THEN ONE  OUTPUT  CATALOG  IS  PRODUCED,  ONE  IS\n      USUALLY  DEFINED  AS  THE  MASTER  CATALOG,  AND  THE  OTHERS AS\n      SECONDARY CATALOGS. IN THE CASE OF ONLY ONE OUTPUT  CATALOG,  IT\n      IS  ALWAYS A MASTER CATALOG. COPYCAT MUST BE RUN ONCE TO PRODUCE\n      THE MASTER CATALOG IN MASTER MODE, AND IF  THERE  ARE  SECONDARY\n      CATALOGS, ONCE IN SECONDARY MODE.\n\n      2.1.4 MASTER MODE\n\n           WHEN COPYCAT IS OPERATING IN MASTER MODE, ONLY  THE  MASTER\n      CATALOG  IS  PRODUCED  BASED  ON THE OUTPUT MASTER CARD(S). CVOL\n      POINTERS FOR INDEXES COVERED BY THE OUTPUT SECONDARY  CARDS,  IF\n      ANY, ARE ALSO ADDED TO THE MASTER CATALOG.\n\n      2.1.5 SECONDARY MODE\n\n           SECONDARY MODE IS USED TO PRODUCE THE  SECONDARY  CATALOGS.\n      THE  CHOICE  OF  WHICH  INDEXES ARE PLACED ON WHICH CATALOGS ARE\n      DEFINED ON THE OUTPUT CARDS.\n\n      2.1.6 MODEL GENERATION DATA GROUP DSCBS\n\n           MODEL DSCBS FOR GENERATION DATA GROUPS  ARE  ALSO  HANDLED.\n      SINCE THE MODEL DSCB MUST RESIDE ON THE VOLUME THAT CONTAINS THE\n      GENERATION INDEX, COPYCAT WILL MOVE OR  COPY  THESE  DSCBS.  THE\n      CHOICE  OF  WHETHER TO MOVE OR COPY THE DSCBS SHOULD BE BASED ON\n      THE APPLICATION. WHEN A SINGLE CATALOG IS BEING REBUILT  ON  THE\n      SAME PHYSICAL VOLUME, NOTHING NEED BE DONE, SINCE THE DSCBS WILL\n      STILL BE ON THE VOLUME. WHEN A CATALOG  IS  BEING  COPIED  TO  A\n      REPLACEMENT  VOLUME, SUCH AS A NEW RELEASE OF A SYSTEM, THEN THE\n      DSCBS SHOULD BE COPIED. WHEN THE WHOLE CATALOG SYSTEM  IS  BEING\n      REORGINIZED, THEN THE DSCBS SHOULD BE MOVED.\n\n      2.1.7 ADDITIONAL CVOL PROCESSING\n\n           SINCE EVERY DIRECT ACCESS VOLUME CAN HAVE A CATALOG, OR ONE\n      SYSTEM MAY HAVE ACCESS TO ANOTHER SYSTEMS CATALOG, IT MAY BECOME\n      NECESSARY TO CHANGE MANY CVOL POINTERS  ON  ONE  SYSTEM  IF  THE\n      OTHER SYSTEMS CATALOG IS REDISTRIBULED. THE CVOL CARDS HAVE BEEN\n      PROVIDED TO ACCOMPLISH THIS.\n\n      2.1.8 ALIAS PROCESSING\n\n           SPECIAL HANDLING OF ALIAS  ENTRIES  HAS  BEEN  INCLUDED  IN\n      COPYCAT.  IN  A  MULTIPLE  CATALOG SYSTEM, AN ALIAS NAME AND ITS\n      TRUE NAME SOMETIMES RESIDE IN DIFFERENT CATALOGS. CVOL  POINTERS\n      WITH  THE  ALIAS  NAME ARE PLACED IN THE MASTER CATALOG DURING A\n      MASTER OPERATION AND IN A SECONDARY CATALOG DURING  A  SECONDARY\n      OPERATION, POINTING AT THE TRUE NAMES VOLUME. THE ALIAS ENTRY IS\n      THEN PLACED IN THE TRUE NAMES CATALOG.\n\n      2.1.9 MULTIPLE INPUTS\n\n           THIRTY-TWO (32) CATALOGS MAY BE DEFINED AS  INPUT.  COPYCAT\n      HAS BEEN DESIGNED TO WORK ON A CATALOG SYSTEM WHERE A HIGH LEVEL\n      INDEX NAME, OTHER THAN A CVOL POINTER, MAY ONLY  APPEAR  IN  ONE\n      CATALOG.  WHEN  A  CONFLICT  IS  FOUND, THE ENTRY FROM THE FIRST\n      DEFINED INPUT CATALOG IS USED. AN EXAMPLE OF THIS WOULD BE IN  A\n      TWO  CPU  SYSTEM,  AND  BOTH SYSTEM RESIDENT VOLUME CATALOGS ARE\n      DEFINED AS INPUT TO COPYCAT. IF BOTH CATALOGS HAVE  ENTRIES  FOR\n      SYS1, THEN ONLY THE ENTRIES FROM THE FIRST DEFINED CATALOG WOULD\n      BE USED.\n\n      2.2 CONTROL CARDS\n\n           THE FORMAT FOR ALL CONTROL CARDS IS:\n\n        \u00ddNAME\u00a8 OPERATION OPERANDS COMMENTS\n\n           THE NAME FIELD, IF PRESENT, MUST BEGIN IN COLUMN  ONE.  THE\n      OPERATION  MUST  BE  SEPARATED  FROM THE NAME AND OPERANDS BY AT\n      LEAST ONE BLANK, AND MAY START ANYWHERE AFTER  COLUMN  ONE.  THE\n      OPERANDS MUST BE SEPARATED BY COMMAS WITH NO INTERVENING BLANKS.\n      A NULL OPERAND MUST BE DELIMITED BY COMMAS UNLESS IT IS THE LAST\n      OPERAND.  THE  COMMENTS  ARE  SEPARATED  FROM THE OPERANDS BY AT\n      LEAST ONE BLANK, AND ANY CARD WITH AN ASTERISK '*' IN COLUMN ONE\n      IS TREATED AS A COMMENT CARD.\n\n      2.2.1 CONTROL\n\n           THE  CONTROL  CARD  SPECIFIES  THE  MAIN  FUNCTIONS  TO  BE\n      PERFORMED, AND MUST BE THE FIRST NON-COMMENT CARD.\n\n        \u00ddNAME\u00a8 CONTROL \u00bbMASTER|SECONDARY\u00ba,\u00bbGDGMOVE|GDGCOPY\u00ba,\n                \u00bbKEEP|SPLIT|UNCATLG\u00ba\n\n           MASTER|SECONDARY - COPYCAT IS TO BE EXECUTED IN THE  MASTER\n                     MODE  TO  PRODUCE  THE  MASTER CATALOG, OR IN THE\n                     SECONDARY MODE TO PRODUCE THE SECONDARY CATALOGS.\n\n           GDGMOVE|GDGCOPY - GENERATION DATA GROUP MODEL DSCBS ARE  TO\n                     BE  MOVED OR COPIED. IF THIS OPERAND IS NULL THEN\n                     THEY ARE NOT PROCESSED.\n\n           KEEP|SPLIT|UNCATLG - THE FUNCTION TO BE PERFORMED ON SINGLE\n                     NAME  DATASETS.  THEY  MAY  BE KEPT IN THE MASTER\n                     CATALOG (KEEP),  THEY  MAY  BE  REDISTRIBUTED  TO\n                     SECONDARY   CATALOGS  (SPLIT),  OR  THEY  MAY  BE\n                     UNCATALOGED (UNCATLG).\n\n           WHEN  COPYCAT  IS  RUN  TWICE  FOR  A  MASTER  CATALOG  AND\n      SECONDARY  CATALOGS,  THESE LAST TWO OPERANDS SHOULD BE THE SAME\n      FOR BOTH RUNS. IF LOCAL MODIFICATIONS TO THE CATALOG  MANAGEMENT\n      ROUTINES  HAVE  BEEN  ADDED SO A MASTER CATALOG IS NOT REQUIRED,\n      COPYCAT NEED ONLY BE RUN ONCE IN SECONDARY MODE, AND  THE  THIRD\n      CONTROL CARD PARAMETER MUST BE SPLIT.\n\n      2.2.2 INPUT\n\n           THE INPUT CARD DEFINES AN INPUT CATALOG  TO  BE  PROCESSED.\n      THERE  MUST BE AT LEAST ONE AND AS MANY AS THIRTY-TWO (32) INPUT\n      CARDS. THE INPUT DATASETS  DEFINED  BY  THESE  CARDS  ARE  NEVER\n      CHANGED  BY THE PROGRAM. THEY MUST NOT BE THE SAME DATASETS USED\n      FOR OUTPUT. THE INPUT CARD(S) MUST FOLLOW THE CONTROL CARD.\n\n        \u00ddNAME\u00a8 INPUT DDNAME,VOLID\n\n           DDNAME - THE NAME OF A DD STATEMENT THAT DEFINES THIS INPUT\n                     DATASET.\n\n           VOLID - THE VOLUME NAME ON WHICH THIS CATALOG RESIDES  WHEN\n                     USED  BY  THE SYSTEM. THIS VOLUME NEED NOT BE THE\n                     SAME AS THAT DEFINED BY DDNAME.\n\n      2.2.3 OUTPUT\n\n           THE  OUTPUT  CARDS  DEFINE  THE  OUTPUT  DATASETS  AND  THE\n      REDISTRIBUTION TABLE. THESE CARDS MUST FOLLOW THE INPUT CARDS.\n\n        \u00ddNAME\u00a8 OUTPUT \u00bbMASTER|SECONDARY\u00ba,DDNAME,VOLID\u00dd,MAXNAME\u00a8\n\n           MASTER - THIS CARD DEFINES THE MASTER CATALOG, OR THE  ONLY\n                     CATALOG IF ONLY ONE IS BEING PRODUCED.\n\n           SECONDARY - THIS CARD DEFINES A SECONDARY CATALOG.\n\n           DDNAME - THE NAME OF A DD STATEMENT THAT DEFINES THE OUTPUT\n                     DATASET.\n\n           VOLID - THE VOLUME NAME ON WHICH THIS CATALOG WILL BE  USED\n                     BY  THE SYSTEM. THE CATALOG MAY BE PLACED ON SOME\n                     OTHER   VOLUME   TEMPORARILY   FOR   BACKUP    OR\n                     CONVENIENCE.\n\n           MAXNAME - THE HIGHEST NAME IN EBCDIC COLLATING SEQUENCE  TO\n                     WHICH THIS OUTPUT CARD APPLIES. THIS MAXNAME MUST\n                     BE GREATER  THEN  THE  MAXNAME  ON  THE  PREVIOUS\n                     OUTPUT  CARD, AND ON THE LAST OUTPUT CARD IT MUST\n                     BE NULL.\n\n           EACH OUTPUT CARD DEFINES A RANGE OF INDEX NAMES THAT ARE TO\n      BE  PLACED  IN ITS CATALOG. THIS RANGE EXTENDS FROM THE PREVIOUS\n      MAXNAME UP TO AND INCLUDING THE CURRENT MAXNAME. THE SAME DDNAME\n      AND  VOLID  PAIR  MAY  APPEAR ON MORE THEN ONE CARD. THIS ALLOWS\n      MORE THEN ONE RANGE OF INDEX NAMES TO BE PLACED ON ONE  CATALOG.\n      ALL MASTER CARDS MUST HAVE THE SAME DDNAME AND VOLID SINCE THERE\n      CAN ONLY BE ONE MASTER CATALOG. THE LAST OUTPUT CARD MUST HAVE A\n      NULL MAXNAME.\n\n      2.2.4 CVOL\n\n           THE CVOL CARD MAY BE USED TO ALTER CONTROL  VOLUME  POINTER\n      ENTRIES THAT POINT TO CATALOGS OUTSIDE THE CURRENT SYSTEM.\n\n        \u00ddNAME\u00a8 CVOL \u00ddVOLID\u00a8,NEWVOL,\u00ddMAXNAME\u00a8,DDNAME\n\n           VOLID - THE VOLUME NAME THAT IS BEING CHANGED.\n\n           NEWVOL - THE NEW VOLUME NAME FOR THE CVOL ENTRY.\n\n           MAXNAME - THE HIGHEST NAME IN  THE  RANGE  OF  INDEX  NAMES\n                     COVERED  BY THIS CVOL CARD. ALL THE CVOL POINTERS\n                     THAT POINT AT THIS VOLUME, WHOSE NAME IS  GREATER\n                     THAN  THE PREVIOUS MAXNAME AND LESS THEN OR EQUAL\n                     TO THIS MAXNAME, WILL  BE  CHANGED  TO  POINT  AT\n                     NEWVOL.  THE  LAST CVOL CARD IN A SET MUST HAVE A\n                     NULL VALUE FOR MAXNAME, WHICH IS THE  HIGHEST  IN\n                     THE COLLATING SEQUENCE.\n\n           DDNAME - THE NAME OF A DD STATEMENT USED  FOR  DEVICE  TYPE\n                     INFORMATION. THIS DD STATEMENT MUST DEFINE A UNIT\n                     OF THE SAME TYPE AS NEWVOL.\n\n           MANY SETS OF CVOL CARDS MAY BE DEFINED. EACH SET MUST  HAVE\n      VOLID  SPECIFIED  ON THE FIRST CARD, AND MAXNAME MUST BE NULL ON\n      THE LAST. CVOL CARDS MUST FOLLOW THE OUTPUT CARDS.\n\n      2.2.5 LEVEL\n\n           THE  LEVEL  CARD  IS  USED  TO  SPECIFY  THE  RESTRUCTURING\n      INFORMATION.  THE GREATEST PERFORMANCE IMPROVEMENTS DERIVED FROM\n      RUNNING COPYCAT DEPEND ON PROPERLY CHOOSING THESE PARAMETERS. UP\n      TO TWENTY-TWO LEVEL CARDS MAY BE DEFINED.\n\n        \u00ddNAME\u00a8 LEVEL LEVEL,BYTES,DUMMIES,BLOCKS\n\n           LEVEL - THE INDEX LEVEL BETWEEN ONE AND TWENTY-TWO TO WHICH\n                     THIS CARD APPLIES.\n\n           BTYES - THE NUMBER OF BYTES TO  LEAVE  IN  EACH  BLOCK  FOR\n                     FUTURE EXPANSION, BETWEEN 0 AND 200.\n\n           DUMMIES - THE NUMBER OF DUMMY BLOCKS TO  LEAVE  AFTER  THIS\n                     INDEX FOR FUTURE EXPANSION.\n\n           BLOCKS - THE NUMBER OF BLOCKS THAT MUST BE ON  THE  CURRENT\n                     OUTPUT TRACK BEFORE STARTING THIS INDEX.\n\n           THE LEVEL CARDS MUST FOLLOW  THE  CVOL  CARDS,  IF  ANY.  A\n      DEFAULT VALUE OF ZERO IS APPLIED FOR ANY NULL OR MISSING VALUES.\n\n      2.3 JOB CONTROL STATEMENTS\n\n           A JOB CARD AND AN EXEC CARD ARE  REQUIRED.  A  SYSPRINT  DD\n      STATEMENT  IS REQUIRED FOR A LISTING OF THE INPUT, INFORMATIONAL\n      MESSAGES AND ERROR MESSAGES. THE DCB  PARAMETERS  ARE  FIXED  AT\n      RECFM=FBA,LRECL=605,BLKSIZE=121. THE CONTROL CARDS ARE READ FROM\n      THE   SYSIN   FILE   WHICH   HAS   FIXED   DCB   PARAMETERS   OF\n      RECFM=FB,LRECL=80,BLKSIZE=3200.  ADDITIONAL  DD  STATEMENTS  ARE\n      REQUIRED AS SPECIFIED BY THE INPUT, OUTPUT AND CVOL  CARDS.  THE\n      DATASETS  DEFINED  BY  THESE  DD  STATEMENTS  NEED  NOT BE NAMED\n      SYSCTLG, BUT THEY MUST BE  ON  A  DIRECT  ACCESS  VOLUME.  IF  A\n      CATALOG  IS  CREATED  ON A VOLUME OTHER THEN THE ONE ON WHICH IT\n      WILL BE USED BY THE SYSTEM, THE TEMPORARY VOLUME  SHOULD  BE  OF\n      THE SAME DEVICE TYPE AS THE FINAL VOLUME.\n\n\n      2.4 MESSAGES AND CODES\n\n           AFTER A SUCCESSFUL RUN OF COPYCAT CERTAIN STATISTICS  ABOUT\n      EACH  OUTPUT  DATASET  ARE  LISTED. THE LAST TTR PLUS ONE IN THE\n      DATASET AND THE TTR OF THE LAST USED BLOCK PLUS ONE  ARE  LISTED\n      IN  HEXADECIMAL.  THE  NUMBER OF CONTROL VOLUME POINTER ENTRIES,\n      DUMMY BLOCKS,  BLOCKS  AT  LEVELS  ONE  AND  TWO,  AND  DATASETS\n      CATALOGED ARE LISTED IN DECIMAL.\n\n           THE FOLLOWING IS A LIST OF ERROR  MESSAGES  AND  COMPLETION\n      CODES. THE MAXIMUM COMPLETION CODE FOUND DURING EXECUTION OF THE\n      PROGRAM IS RETURNED TO OS.\n\n      ERR01 ERROR FOUND IN PARAMETER AT '$'\n\n           AN ERROR WAS FOUND IN A PARAMETER OR A  REQUIRED  PARAMETER\n           WAS MISSING. THE PREVIOUS LINE WILL CONTAIN A '$' UNDER THE\n           ERROR.\n           (COMPLETION CODE = 8)\n\n      ERR02 ERROR PROCESSING DDNAME='DDNAME'\n\n           A PROBLEM WAS FOUND WITH A DD STATEMENT. EITHER IT WAS  NOT\n           FOUND,  COULD  NOT BE OPENED, OR WAS NOT ON A DIRECT ACCESS\n           VOLUME.\n           (COMPLETION CODE = 8)\n\n      ERR03 UNEXPECTED END OF FILE ON SYSIN\n\n           MORE CONTROL CARDS WERE EXPECTED, BUT WERE NOT FOUND.\n           (COMPLETION CODE = 8)\n\n      ERR04 NAME=TRUENAME NOT FOUND FOR ALIAS=ALIASNAME\n\n           WHILE PROCESSING AN ALIAS ENTRY,  THE  TRUE  NAME  FOR  THE\n           ALIAS COULD NOT BE FOUND.\n           (COMPLETION CODE = 12)\n\n      ERR05 ALIAS COUNT ERROR FOUND FOR NAME=TRUENAME\n\n           THE ALIAS COUNT FIELD IN THE NAMED INDEX IS  NOT  EQUAL  TO\n           THE NUMBER OF ALIASES FOUND FOR THE NAME.\n           (COMPLETION CODE = 12)\n\n      ERR06 TOO MANY INPUT DATASETS\n\n           MORE THEN 32 INPUT CARDS WERE FOUND.\n           (COMPLETION CODE = 8)\n\n      ERR07 INDEX=INDEX FOUND ON VOLS=(X,Y) THE ENTRY  ON  X  WILL  BE\n      USED\n\n           THE SAME HIGH  LEVEL  INDEX  WAS  FOUND  ON  TWO  DIFFERENT\n           CATALOGS. THE ONE ON THE X VOLUME WILL BE USED.\n           (COMPLETION CODE = 4)\n\n      ERR08 NO INPUT CARDS FOUND\n\n           NO INPUT CARDS WERE FOUND,  OR  THEY  DID  NOT  FOLLOW  THE\n           CONTROL CARD.\n           (COMPLETION CODE = 8)\n\n      ERR09 FUNCTION FAILED  WITH  (CODE)  ON  VOLUME  FOR  GDG  MODEL\n      DSCB=NAME\n\n           WHILE MOVING OR COPYING MODEL DSCBS, AN OBTAIN, ALLOCATE OR\n           SCRATCH  OPERATION  FAILED  WITH  THE RETURN CODE OF 'CODE'\n           (DECIMAL).\n           (COMPLETION CODE = 4)\n\n      ERR10 MODEL DSCB FOR GDG DOES NOT HAVE ZERO EXTENTS DSN=NAME\n\n           THE NAMED MODEL DSCB IS NOT COPIED BECAUSE IT DOES NOT HAVE\n           ZERO EXTENTS.\n           (COMPLETION CODE = 4)\n\n      ERR11 MODEL DSCB FOR GDG EXISTS ON OUTPUT VOLUME WITH  DIFFERENT\n      ATTRIBUTES FOR DSN=NAME\n\n           WHILE MOVING OR COPYING MODEL DSCBS A DSCB  WITH  THE  SAME\n           NAME  WAS  FOUND  ON  THE OUTPUT VOLUME, BUT THE ATTRIBUTES\n           DEFINED BY THE TWELVE  BYTES  IN  THE  DSCB  AT  OFFSET  82\n           (DECIMAL)  ARE  NOT  THE  SAME.  THE  DSCB  IS NOT MOVED OR\n           COPIED.\n           (COMPLETION CODE = 4)\n\n      ERR12 ABEND - NNN - OCCURED. SEE SYSMSG. CURRENT OR LAST NAME IS\n      NAME\n\n           A D37, B37 OR 213 ABEND OCCURED. THE LAST  INDEX  STRUCTURE\n           BEING PROCESSED IS GIVEN.\n           (COMPLETION CODE = 16)\n\n      ERR13 I/O ERROR - SYNAD MESSAGE\n      ERR13 I/O ERROR CURRENT OR LAST NAME IS NAME\n\n           AN I/O ERROR OCCURED. THE STANDARD MESSAGE  PRODUCED  BY  A\n           SYNAD  MACRO  IS GIVEN, ALONG WITH THE LAST INDEX STRUCTURE\n           PROCESSED.\n           (COMPLETION CODE = 16)\n\n      ERR14 NO OUTPUT MASTER CARD WAS FOUND\n\n           WHEN IN MASTER MODE, AT LEAST ONE OUTPUT MASTER  CARD  MUST\n           BE DEFINED.\n           (COMPLETION CODE = 8)\n\n      THE COMPLETION CODES ARE AS FOLLOWS:\n\n          0 - NO ERRORS.\n\n          4 - ALL CATALOGS ARE USEABLE, BUT DUPLICATE INDEXES HAVE\n              BEEN  LEFT  OUT  OR  MODEL  DSCBS HAVE NOT BEEN MOVED OR\n              COPIED.\n\n          8 - ERRORS IN PROCESSING CONTROL CARDS. THE OUTPUT DATASETS\n              HAVE NOT BEEN CHANGED.\n\n   12 - ALL CATALOGS ARE USEABLE, BUT PROBLEMS EXIST WITH ALIAS\n              ENTRIES.\n\n   16 - OUTPUT CATALOGS HAVE BEEN PARTLY BUILT, AND ARE NOT\n              USEABLE.\n\n      2.5 EXAMPLES\n\n      2.5.1 COPY A CATALOG FROM ONE VOLUME TO ANOTHER\n\n           THIS FIRST EXAMPLE  ILLUSTRATES  THE  MOST  COMMON  USE  OF\n      COPYCAT.  A  CATALOG  ON  ONE  VOLUME IS TO BE COPIED TO ANOTHER\n      VOLUME, SUCH AS WHEN A NEW SYSTEM IS BEING INSTALLED.  THIS  JOB\n      WOULD  BE RUN UNDER THE OLD SYSTEM TO COPY THE CATALOG ON SYSRES\n      TO THE NEW SYSTEM PACK, NEWRES, WHICH WILL  LATER  BE  RELABELED\n      SYSRES.\n\n      //EX1    JOB   XXX\n      //       EXEC  PGM=COPYCAT,REGION=60K\n      //SYSPRINT DD  SYSOUT=A\n      //OLDRES DD    DSN=SYSCTLG,VOL=SER=SYSRES,\n      //             DISP=OLD,UNIT=DISK\n      //NEWRES DD    DSN=SYSCTLG,VOL=SER=NEWRES,\n      //             DISP=OLD,UNIT=DISK\n      //SYSIN  DD    *\n      *              EXAMPLE ONE\n               CONTROL MASTER,GDGCOPY,KEEP\n               INPUT OLDRES,SYSRES\n               OUTPUT MASTER,NEWRES,SYSRES\n               LEVEL 1,26,100\n               LEVEL 2,52,5,5\n\n           IN THIS EXAMPLE MODEL DSCBS FOR GENERATION DATA GROUPS  ARE\n      COPIED. 100 DUMMY BLOCKS ARE LEFT AFTER THE HIGHEST LEVEL INDEX,\n      WITH 26 BYTES LEFT IN EACH BLOCK FOR FUTURE EXPANSION. 52  BYTES\n      ARE  LEFT  IN  EACH  SECOND LEVEL INDEX BLOCK, 5 BLOCKS ARE LEFT\n      AFTER EACH INDEX, AND A SECOND LEVEL INDEX WILL NOT  BE  STARTED\n      ON A TRACK WITHIN 5 BLOCKS OF THE END.\n\n      2.5.2 BACK UP A CATALOG\n\n           THIS EXAMPLE DEMONSTRATES THE USE OF COPYCAT FOR BACKING UP\n      A  CATALOG.  NOTE  THAT  THE  BACKUP DATASET DOES NOT NEED TO BE\n      CALLED SYSCTLG, THUS MANY CATALOGS COULD BE  BACKED  UP  ON  THE\n      SAME VOLUME.\n\n      //EX2    JOB   XXX,REGION=60K\n      //       EXEC  PGM=COPYCAT\n      //SYSPRINT DD  SYSOUT=A\n      //CATALOG DD   DSNAME=SYSCTLG,VOL=SER=PACK01,\n      //             UNIT=DISK,DISP=OLD\n      //BACKUP DD    DSNAME=CAT.PACK01,VOL=SER=BACKUP,\n      //             UNIT=DISK,SPACE=(CYL,(3,2)),DISP=(NEW,KEEP)\n      //SYSIN  DD    *\n      *              EXAMPLE 2\n               CONTROL MASTER,GDGCOPY,KEEP\n               INPUT CATALOG,PACK01\n               OUTPUT MASTER,BACKUP,PACK01\n      /*\n\n      2.5.3 REDISTRIBUTE A CATALOG\n\n           IN THIS EXAMPLE A SINGLE CATALOG IS TO  BE  SPLIT  UP  INTO\n      FOUR  SEPARATE  CATALOGS.  THE FIRST STEP PRODUCES THE SECONDARY\n      CATALOGS, AND THE SECOND STEP PRODUCES THE MASTER  CATALOG.  THE\n      LAST  STEP IS EXECUTED ONLY IF THE FIRST TWO STEPS RAN PROPERLY,\n      AND IT RENAMES THE DATASET ON RES075.\n\n      //EX3    JOB   XXX\n      //STEP1  EXEC  PGM=COPYCAT,REGION=60K\n      //SYSPRINT DD  SYSOUT=A\n      //INPUT  DD    VOL=SER=RES075,UNIT=DISK,DISP=OLD,\n      //             DSNAME=SYSCTLG\n      //OLDRES DD    VOL=SER=RES075,UNIT=DISK,\n      //             DSNAME=NEWCAT,DISP=(NEW,KEEP),\n      //             SPACE=(CYL,(5,2))\n      //P87    DD    UNIT=DISK,VOL=SER=PACK87,\n      //             DSNAME=SYSCTLG,DISP=(NEW,KEEP),\n      //             SPACE=(CYL,(5,2))\n      //P88    DD    UNIT=DISK,VOL=SER=PACK88,\n      //             DSNAME=SYSCTLG,DISP=(NEW,KEEP),\n      //             SPACE=(CYL,(5,2))\n      //P89    DD    UNIT=DISK,VOL=SER=PACK89,\n      //             DSNAME=SYSCTLG,DISP=(NEW,KEEP),\n      //             SPACE=(CYL,(5,2))\n      //SYSIN  DD    *\n      *              EXAMPLE 3\n      *              PRODUCE THE SECONDARY CATALOGS\n               CONTROL SECONDARY,GDGMOVE,KEEP\n               INPUT INPUT,RES075\n               OUTPUT SECONDARY,P87,PACK87,B9999999\n               OUTPUT SECONDARY,P88,PACK88,H9999999\n               OUTPUT MASTER,OLDRES,RES075,K9999999\n               OUTPUT SECONDARY,P89,PACK89,R9999999\n               OUTPUT MASTER,OLDRES,RES075,S9999999\n               OUTPUT SECONDARY,P88,PACK88\n               LEVEL 1,26,100\n               LEVEL 2,54,5,5\n               LEVEL 3,,2,2\n      /*\n      //STEP2  EXEC  PGM=COPYCAT,REGION=60K\n      //SYSPRINT DD  SYSOUT=A\n      //INPUT  DD    VOL=SER=RES075,UNIT=DISK,DISP=OLD,\n                     DSNAME=SYSCTLG\n      //OLDRES DD    VOL=SER=RES075,UNIT=DISK,\n                     DSNAME=NEWCAT,DISP=OLD\n      //P87    DD    UNIT=DISK,VOL=SER=PACK87,\n                     DSNAME=SYSCTLG,DISP=OLD\n      //P88    DD    UNIT=DISK,VOL=SER=PACK88,\n                     DSNAME=SYSCTLG,DISP=OLD\n      //P89    DD    UNIT=DISK,VOL=SER=PACK89,\n                     DSNAME=SYSCTLG,DISP=OLD\n      //SYSIN  DD    *\n      *              EXAMPLE 3\n      *              PRODUCE THE MASTER CATALOG\n               CONTROL MASTER,GDGMOVE,KEEP\n               INPUT INPUT,RES075\n               OUTPUT SECONDARY,P87,PACK87,B9999999\n               OUTPUT SECONDARY,P88,PACK88,H9999999\n               OUTPUT MASTER,OLDRES,RES075,K9999999\n               OUTPUT SECONDARY,P89,PACK89,R9999999\n               OUTPUT MASTER,OLDRES,RES075,S9999999\n               OUTPUT SECONDARY,P88,PACK88\n               LEVEL 1,26,50\n               LEVEL 2,54,10,10\n      /*\n      //STEP3  EXEC  PGM=IEHPROGM,COND=(5,LT)\n      //SYSPRINT DD  SYSOUT=A\n      //OLDRES DD    UNIT=DISK,VOL=SER=RES075,DISP=OLD\n      //SYSIN  DD    *\n               RENAME VOL=2314=RES075,DSNAME=SYSCTLG,\n                     NEWNAME=OLDCATLG\n               RENAME VOL=2314=RES075,DSNAME=NEWCAT,\n                     NEWNAME=SYSCTLG\n      /*\n\n           ALL INDEXES UP TO C WILL BE ON PACK87, INDEXES FROM C TO  I\n      AND FROM T UPWARDS WILL BE ON PACK88, AND FROM L TO S WILL BE ON\n      PACK89. CVOL POINTERS FOR THESE INDEXES WILL BE PLACED ON RES075\n      ALONG  WITH  ALL  THE  OTHER INDEXES. STEP 3 WILL BE EXECUTED IF\n      THERE ARE NO SEVERE ERRORS.\n\n      3.0 PROGRAM LOGIC\n\n           COPYCAT IS WRITTEN ENTIRELY IN ASSEMBLER LANGUAGE. QSAM  IS\n      USED FOR SYSPRINT AND SYSIN, WHILE BSAM IN THE LOAD MODE IS USED\n      FOR THE OUTPUT DATASETS. BDAM IS  USED  FOR  THE  INPUT  AND  TO\n      ACCESS PREVIOUSLY WRITTEN OUTPUT BLOCKS.\n\n           THE HEART OF THE PROGRAM CONSISTS OF  A  RECURSIVE  ROUTINE\n      CALLED  RR, WHICH IS CALLED FOR EACH LEVEL. THE TTR OF THE FIRST\n      BLOCK OF THE LEVEL IS PASSED TO RR. AFTER AN  INDEX  IS  WRITTEN\n      WITH  THE OLD TTRS, IT IS REREAD AND FOR EACH ENTRY WITH A LOWER\n      LEVEL, RR IS RECURSIVELY CALLED. UPON RETURN,  THE  NEW  TTR  IS\n      PLACED IN THE ENTRY AND THE BLOCK IS REWRITTEN.\n\n           WHEN PROCESSING THE HIGHEST  LEVEL  INDEX,  THE  ADDITIONAL\n      INFORMATION  OF  WHICH  INPUT  DATASET THIS ENTRY CAME FROM MUST\n      ALSO BE SAVED. THIS IS DONE BY CHANGING THE COUNT FIELD  OF  THE\n      INDEX.  ONLY THREE TYPES OF ENTRIES NEED THIS INFORMATION SAVED:\n      THE INDEX POINTER ENTRY, THE VOLUME CONTROL BLOCK POINTER ENTRY,\n      AND THE GENERATION INDEX POINTER ENTRY. BY MAKING THE LAST THREE\n      BITS OF THE VOLUME CONTROL BLOCK POINTER ENTRY '110',  ONLY  THE\n      ENTRIES  WITH  A LAST BIT OF '0' CONTAIN ADDITIONAL INFORMATION.\n      TWO BITS ARE USED TO DISTINGUISH  BETWEEN  THE  THREE  TYPES  OF\n      ENTRIES,  AND  THE  OTHER FIVE BITS IN THE LENGTH FIELD ARE THEN\n      USED TO LOCATE THE PROPER INPUT DATASET.\n\n           WHEN PROCESSING  MODEL  DSCBS,  THE  OBTAIN,  ALLOCATE  AND\n      SCRATCH   SVCS   ARE   USED.   BEFORE   RUNNING  COPYCAT,  LOCAL\n      RESTRICTIONS ON ALLOCATING AND  SCRATCHING  DATASETS  SHOULD  BE\n      CONSIDERED.  THESE  SVCS  ARE  ONLY  USED  IN THE ROUTINE CALLED\n      GDSPROC.\n\n           TWO OTHER IMPORTANT ROUTINES ARE INR AND  PUTC.  INR  FINDS\n      THE  NEXT NAME IN THE HIGHEST LEVEL INDEXES TO BE PROCESSED FROM\n      AMONG ALL THE INPUTS. IT IS CALLED BY  RR  AND  IT  HANDLES  THE\n      PROBLEM  OF DUPLICATE INDEX NAMES. PUTC IS ALSO CALLED BY RR AND\n      IT TAKES AN INDEX AND ADDS IT TO THE NEXT BLOCK FOR OUTPUT. PUTC\n      PROCESSES THE PARAMETERS OF THE LEVEL CARDS.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$UCLAJCL": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//CSYSMASA JOB  ACCNT,NOTIFY=CSYSMAS,MSGCLASS=A,COND=(0,NE)\n/*ROUTE PRINT WYLBUR\n//COPY EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//I        DD DISP=SHR,DSN=CSYSMAS.COPYCAT.ASM\n//O        DD DISP=(NEW,CATLG),DSN=CSYSMAS.TMP.TMPCAT,\n//  UNIT=3350,VOL=SER=SYSDA1,SPACE=(CYL,(6,1,50),RLSE)\n//SYSIN    DD *\n  C I=I,O=O\n  S M=COPYCAT\n//IEBUPDTE EXEC PGM=IEBUPDTE PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSUT1   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSIN    DD DISP=SHR,DSN=CSYSMAS.COPYCAT.ASM(FIX1)\n//IEBUPDTE EXEC PGM=IEBUPDTE PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSUT1   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSIN    DD DISP=SHR,DSN=CSYSMAS.COPYCAT.ASM(FIX2)\n//IEBUPDTE EXEC PGM=IEBUPDTE PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSUT1   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSIN    DD DISP=SHR,DSN=CSYSMAS.COPYCAT.ASM(OAC1)\n//IEBUPDTE EXEC PGM=IEBUPDTE PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSUT1   DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT\n//SYSIN    DD DISP=SHR,DSN=CSYSMAS.COPYCAT.ASM(OAC2)\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n//ASM.SYSIN  DD DISP=SHR,DSN=CSYSMAS.TMP.TMPCAT(COPYCAT)\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS1.OACAPF(COPYCAT$),UNIT=,SPACE=\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYCAT": {"ttr": 775, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*           COPYCAT  07.42.07 80.171 TSO001 TS.CBT.COPYCAT.PDS\nCOPYCAT  CSECT\nCCAT     TITLE 'COPYCAT - COPY OR SPLIT THE OS CATALOG'\n*\n*\n*                   COPYCAT - OS CATALOG UTILITY PROGRAM\n*                                    BY\n*                            DOUGLAS E. ENGERT\n*                       APPLIED MATHEMATICS DIVISION\n*                       ARGONNE NATIONAL LABORATORY\n*                          9700 SOUTH CASS AVENUE\n*                         ARGONNE, ILLINOIS 60439\n*\n*\n*   THIS 12-77 VERSION CONTAINS SEVERAL MINOR FIXES FROM ARGONNE\n*   (\"F00001\" & \"F00003\") AND A MAJOR SPEED ENHANCEMENT TO THIS\n*   ALREADY FAST PROGRAM IN THAT THE CATALOG I/O IS NOW DONE AT\n*   EXCP LEVEL (\"EXCP01\").  A FIX FROM UCLA FOR A LITTLE MORE\n*   SPEED YET IS ALSO INCLUDED (\"CCN\").  THE HARDCODED BLKSIZES\n*   FOR SYSIN AND SYSPRINT HAVE BEEN CHANGED TO 3200 AND 605.\n*                             F. PAJERSKI   NASA/GSFC   01DEC77\n*\n*\n*                            TABLE OF CONTENTS\n*\n*     ABSTRACT\n*\n*     1.0 INTRODUCTION\n*\n*     2.0 USER MANUAL\n*\n*       2.1 FUNCTIONS\n*\n*         2.1.1 REDISTRIBUTION\n*         2.1.2 RESTRUCTURING\n*         2.2.3 MASTER AND SECONDARY CATALOGS\n*         2.1.4 MASTER MODE\n*         2.1.5 SECONDARY MODE\n*         2.1.6 MODEL GENERATION DATA GROUP DSCBS\n*         2.1.7 ADDITIONAL CVOL PROCESSING\n*         2.1.8 ALIAS PROCESSING\n*         2.1.9 MULTIPLE INPUTS\n*\n*       2.2 CONTROL CARDS\n*\n*         2.2.1 CONTROL\n*         2.2.2 INPUT\n*         2.2.3 OUTPUT\n*         2.2.4 CVOL\n*         2.2.5 LEVEL\n*\n*       2.3 JOB CONTROL STATEMENTS\n*\n*       2.4 MESSAGES AND CODES\n*\n*       2.5 EXAMPLES\n*\n*         2.5.1 COPY A CATALOG FROM ONE VOLUME TO ANOTHER\n*         2.5.2 BACK UP A CATALOG\n*         2.5.3 REDISTRIBUTE A CATALOG\n*\n*     3.0 PROGRAM LOGIC\n*\n*\n*               COPYCAT IS AN  OS  UTILITY  PROGRAM  DESIGNED  TO\n*          IMPROVE   PERFORMANCE  OF  OS  CATALOG  MANAGEMENT  BY\n*          PRODUCING A RESTRUCTURED COPY OF A CATALOG IN ORDER TO\n*          USE  THE  EXISTING  ACCESS  METHODS  MOST EFFECTIVELY.\n*          MULTIPLE INPUT AND OUTPUT CATALOGS ARE  PROCESSED  AND\n*          THE  REDISTRIBUTION  OF  THE  ENTRIES  IS  UNDER  USER\n*          CONTROL. MODEL DSCBS FOR GENERATION  DATA  GROUPS  AND\n*          ALIAS  ENTRIES  ARE  ALSO  PROCESSED.  CATALOGS ON ALL\n*          DIRECT  ACCESS  DEVICES,  INCLUDING  DATA  CELLS,  ARE\n*          SUPPORTED. BACKUP COPIES MAY ALSO BE MADE.\n*\n*\n*     1.0 INTRODUCTION\n*\n*          COPYCAT IS AN OS UTILITY PROGRAM  DESIGNED  TO  PRODUCE  AN\n*     EFFICENT  SYSTEM  WIDE CATALOG WHICH MAY RESIDE ON MANY VOLUMES.\n*     SUBSTANTIAL IMPROVEMENT IN PERFORMANCE MAY ALSO BE OBTAINED ON A\n*     SYSTEM  WITH  ONLY  A  SINGLE CATALOG. THIS IS ACCOMPLISHED IN A\n*     NUMBER OF WAYS.  FIRST,  CATALOG  ENTRIES  FROM  MANY  DIFFERENT\n*     CATALOGS  MAY  BE  REDISTRIBUTED  TO  EQUALIZE  THE LOAD ON EACH\n*     INDIVIDUAL  CATALOG.  SECOND,   EACH   INDIVIDUAL   CATALOG   IS\n*     RESTRUCTURED IN A WAY DESIGNED TO MINIMIZE THE I/O TIME REQUIRED\n*     BOTH  FOR  SEARCHING  AND  UPDATING.  THE   REDISTRIBUTION   AND\n*     RESTRUCTURING  PARAMETERS  ARE UNDER THE CONTROL OF THE USER WHO\n*     SHOULD HAVE SOME KNOWLEDGE OF OS CATALOG MANAGEMENT.\n*\n*          OUR INSTALLATION AT ARGONNE CONSISTS OF A 370/195, USED FOR\n*     BATCH  PROCESSING,  AND A 360/75 USED FOR TIME SHARING. THE TIME\n*     SHARING SYSTEM, TSO, SHARES ALL ITS ONLINE DEVICES WITH THE 195.\n*     SINCE  ALL  DATASETS  USED  BY  TSO  MUST BE CATALOGED, THEY ARE\n*     CATALOGED ON THE RESIDENT VOLUME FOR THE 75 TO ALLOW BATCH  JOBS\n*     TO  ACCESS TSO DATASETS. THIS HAS PLACED AN EXTREMELY HEAVY LOAD\n*     ON THIS SHARED CATALOG, WHICH OCCUPIES ABOUT 20 CYLINDERS  ON  A\n*     2314.  AFTER  SOME  STUDY OF THE SITUATION IT WAS FOUND THAT THE\n*     ORGANIZATION OF THE  SHARED  CATALOG  WAS  ONE  OF  OUR  BIGGEST\n*     BOTTLENECKS.  AFTER  RUNNING COPYCAT, SOFTWARE MONITORING SHOWED\n*     THE PERCENT OF UNIT BUSY TIME OF THE SYSTEM RESIDENT VOLUME  FOR\n*     THE  75  DROPPED  FROM  ABOUT  80%  TO ABOUT 20%, THE PERCENT OF\n*     ENQUEUE WAIT FOR THE CATALOG DROPPED FROM  ABOUT  10%  TO  ABOUT\n*     .1%,  AND  THE  NUMBER OF EXCPS REQUIRED TO LOGON TO TSO DROPPED\n*     FROM ABOUT 120 TO 70.\n*\n*     2.0 USER MANUAL\n*\n*     2.1 FUNCTIONS\n*\n*          TWO DIFFERENT TYPES OF CATALOG SYSTEMS CAN BE PROCESSED  BY\n*     COPYCAT.  THE FIRST IS THE STANDARD OS CATALOG SYSTEM CONSISTING\n*     OF THE MASTER CATALOG ON THE SYSTEM RESIDENT VOLUME AND ZERO  OR\n*     MORE  CATALOGS  ON  OTHER  VOLUMES.  THE  SECOND TYPE OF CATALOG\n*     SYSTEM DOES NOT HAVE A MASTER CATALOG, BUT INSTEAD HAS  A  TABLE\n*     BUILT  INTO  THE  CATALOG MANAGEMENT ROUTINES USED TO SELECT THE\n*     FIRST CATALOG TO BE SEARCHED. THE CHANGES NEEDED FOR  THIS  TYPE\n*     OF CATALOG SYSTEM MUST BE LOCALLY WRITTEN.\n*\n*\n*     2.1.1 REDISTRIBUTION\n*\n*          WHEN MORE THAN ONE CATALOG IS BEING CREATED, REDISTRIBUTION\n*     PARAMETERS  ARE  REQUIRED.  THESE PARAMETERS ARE SUPPLIED ON THE\n*     OUTPUT CARDS IN THE FORM OF A RANGE OF NAMES. THE UPPER BOUND IS\n*     DEFINED  ON  EACH  OUTPUT  CARD,  AND THE RANGE EXTENDS FROM THE\n*     UPPER BOUND OF THE PREVIOUS CARD TO THIS UPPER BOUND. AN  EBCDIC\n*     COLLATING SEQUENCE IS USED.\n*\n*     2.1.2 RESTRUCTURING\n*\n*          THE MAIN FUNCTION OF COPYCAT IS TO RESTRUCTURE A CATALOG SO\n*     AS  TO TAKE ADVANTAGE OF THE CATALOG MANAGEMENT I/O ROUTINES. TO\n*     DO THIS THREE PARAMETERS MAY BE SPECIFIED FOR EACH INDEX  LEVEL.\n*     THE  FIRST  IS  THE  NUMBER  OF BYTES TO LEAVE IN EACH BLOCK FOR\n*     EXPANSION.  BY  LEAVING  ENOUGH  ROOM,  THE  CATALOG  MANAGEMENT\n*     ROUTINES  WILL  BE ABLE TO ADD ENTRIES WITHOUT HAVING TO ADD NEW\n*     BLOCKS. EACH CVOL  POINTER  TAKES  TWENTY-TWO  (22)  BYTES,  AND\n*     SINGLE  VOLUME  DATASET  ENTRIES  TAKE  TWENTY-SIX  (26)  BYTES.\n*     SECOND, THE NUMBER OF DUMMY BLOCKS TO BE LEFT AFTER AN INDEX MAY\n*     BE SPECIFIED SO THE INDEX CAN EXPAND AND NEW LOWER LEVEL INDEXES\n*     CAN BE ADDED IN CLOSE PROXIMITY. THIRD,  THE  NUMBER  OF  BLOCKS\n*     THAT  MUST  BE  ON A TRACK BEFORE STARTING THE NEXT INDEX MAY BE\n*     GIVEN. SINCE INDEXES MAY REQUIRE MORE THEN  ONE  BLOCK,  AND  AN\n*     INDEX  CAN  BE  SEARCHED  IN  ONE  I/O OPERATION IF IT IS ON ONE\n*     TRACK, THIS NUMBER SHOULD BE SET LARGE ENOUGH SO MOST INDEXES AT\n*     A PARTICULAR LEVEL CAN FIT ON ONE TRACK.\n*\n*     2.1.3 MASTER AND SECONDARY CATALOGS\n*\n*          WHEN MORE THEN ONE  OUTPUT  CATALOG  IS  PRODUCED,  ONE  IS\n*     USUALLY  DEFINED  AS  THE  MASTER  CATALOG,  AND  THE  OTHERS AS\n*     SECONDARY CATALOGS. IN THE CASE OF ONLY ONE OUTPUT  CATALOG,  IT\n*     IS  ALWAYS A MASTER CATALOG. COPYCAT MUST BE RUN ONCE TO PRODUCE\n*     THE MASTER CATALOG IN MASTER MODE, AND IF  THERE  ARE  SECONDARY\n*     CATALOGS, ONCE IN SECONDARY MODE.\n*\n*     2.1.4 MASTER MODE\n*\n*          WHEN COPYCAT IS OPERATING IN MASTER MODE, ONLY  THE  MASTER\n*     CATALOG  IS  PRODUCED  BASED  ON THE OUTPUT MASTER CARD(S). CVOL\n*     POINTERS FOR INDEXES COVERED BY THE OUTPUT SECONDARY  CARDS,  IF\n*     ANY, ARE ALSO ADDED TO THE MASTER CATALOG.\n*\n*     2.1.5 SECONDARY MODE\n*\n*          SECONDARY MODE IS USED TO PRODUCE THE  SECONDARY  CATALOGS.\n*     THE  CHOICE  OF  WHICH  INDEXES ARE PLACED ON WHICH CATALOGS ARE\n*     DEFINED ON THE OUTPUT CARDS.\n*\n*     2.1.6 MODEL GENERATION DATA GROUP DSCBS\n*\n*          MODEL DSCBS FOR GENERATION DATA GROUPS  ARE  ALSO  HANDLED.\n*     SINCE THE MODEL DSCB MUST RESIDE ON THE VOLUME THAT CONTAINS THE\n*     GENERATION INDEX, COPYCAT WILL MOVE OR  COPY  THESE  DSCBS.  THE\n*     CHOICE  OF  WHETHER TO MOVE OR COPY THE DSCBS SHOULD BE BASED ON\n*     THE APPLICATION. WHEN A SINGLE CATALOG IS BEING REBUILT  ON  THE\n*     SAME PHYSICAL VOLUME, NOTHING NEED BE DONE, SINCE THE DSCBS WILL\n*     STILL BE ON THE VOLUME. WHEN A CATALOG  IS  BEING  COPIED  TO  A\n*     REPLACEMENT  VOLUME, SUCH AS A NEW RELEASE OF A SYSTEM, THEN THE\n*     DSCBS SHOULD BE COPIED. WHEN THE WHOLE CATALOG SYSTEM  IS  BEING\n*     REORGINIZED, THEN THE DSCBS SHOULD BE MOVED.\n*\n*     2.1.7 ADDITIONAL CVOL PROCESSING\n*\n*          SINCE EVERY DIRECT ACCESS VOLUME CAN HAVE A CATALOG, OR ONE\n*     SYSTEM MAY HAVE ACCESS TO ANOTHER SYSTEMS CATALOG, IT MAY BECOME\n*     NECESSARY TO CHANGE MANY CVOL POINTERS  ON  ONE  SYSTEM  IF  THE\n*     OTHER SYSTEMS CATALOG IS REDISTRIBULED. THE CVOL CARDS HAVE BEEN\n*     PROVIDED TO ACCOMPLISH THIS.\n*\n*     2.1.8 ALIAS PROCESSING\n*\n*          SPECIAL HANDLING OF ALIAS  ENTRIES  HAS  BEEN  INCLUDED  IN\n*     COPYCAT.  IN  A  MULTIPLE  CATALOG SYSTEM, AN ALIAS NAME AND ITS\n*     TRUE NAME SOMETIMES RESIDE IN DIFFERENT CATALOGS. CVOL  POINTERS\n*     WITH  THE  ALIAS  NAME ARE PLACED IN THE MASTER CATALOG DURING A\n*     MASTER OPERATION AND IN A SECONDARY CATALOG DURING  A  SECONDARY\n*     OPERATION, POINTING AT THE TRUE NAMES VOLUME. THE ALIAS ENTRY IS\n*     THEN PLACED IN THE TRUE NAMES CATALOG.\n*\n*     2.1.9 MULTIPLE INPUTS\n*\n*          THIRTY-TWO (32) CATALOGS MAY BE DEFINED AS  INPUT.  COPYCAT\n*     HAS BEEN DESIGNED TO WORK ON A CATALOG SYSTEM WHERE A HIGH LEVEL\n*     INDEX NAME, OTHER THAN A CVOL POINTER, MAY ONLY  APPEAR  IN  ONE\n*     CATALOG.  WHEN  A  CONFLICT  IS  FOUND, THE ENTRY FROM THE FIRST\n*     DEFINED INPUT CATALOG IS USED. AN EXAMPLE OF THIS WOULD BE IN  A\n*     TWO  CPU  SYSTEM,  AND  BOTH SYSTEM RESIDENT VOLUME CATALOGS ARE\n*     DEFINED AS INPUT TO COPYCAT. IF BOTH CATALOGS HAVE  ENTRIES  FOR\n*     SYS1, THEN ONLY THE ENTRIES FROM THE FIRST DEFINED CATALOG WOULD\n*     BE USED.\n*\n*     2.2 CONTROL CARDS\n*\n*          THE FORMAT FOR ALL CONTROL CARDS IS:\n*\n*       \u00ddNAME\u00a8 OPERATION OPERANDS COMMENTS\n*\n*          THE NAME FIELD, IF PRESENT, MUST BEGIN IN COLUMN  ONE.  THE\n*     OPERATION  MUST  BE  SEPARATED  FROM THE NAME AND OPERANDS BY AT\n*     LEAST ONE BLANK, AND MAY START ANYWHERE AFTER  COLUMN  ONE.  THE\n*     OPERANDS MUST BE SEPARATED BY COMMAS WITH NO INTERVENING BLANKS.\n*     A NULL OPERAND MUST BE DELIMITED BY COMMAS UNLESS IT IS THE LAST\n*     OPERAND.  THE  COMMENTS  ARE  SEPARATED  FROM THE OPERANDS BY AT\n*     LEAST ONE BLANK, AND ANY CARD WITH AN ASTERISK '*' IN COLUMN ONE\n*     IS TREATED AS A COMMENT CARD.\n*\n*     2.2.1 CONTROL\n*\n*          THE  CONTROL  CARD  SPECIFIES  THE  MAIN  FUNCTIONS  TO  BE\n*     PERFORMED, AND MUST BE THE FIRST NON-COMMENT CARD.\n*\n*       \u00ddNAME\u00a8 CONTROL \u00bbMASTER|SECONDARY\u00ba,\u00bbGDGMOVE|GDGCOPY\u00ba,\n*               \u00bbKEEP|SPLIT|UNCATLG\u00ba\n*\n*          MASTER|SECONDARY - COPYCAT IS TO BE EXECUTED IN THE  MASTER\n*                    MODE  TO  PRODUCE  THE  MASTER CATALOG, OR IN THE\n*                    SECONDARY MODE TO PRODUCE THE SECONDARY CATALOGS.\n*\n*          GDGMOVE|GDGCOPY - GENERATION DATA GROUP MODEL DSCBS ARE  TO\n*                    BE  MOVED OR COPIED. IF THIS OPERAND IS NULL THEN\n*                    THEY ARE NOT PROCESSED.\n*\n*          KEEP|SPLIT|UNCATLG - THE FUNCTION TO BE PERFORMED ON SINGLE\n*                    NAME  DATASETS.  THEY  MAY  BE KEPT IN THE MASTER\n*                    CATALOG (KEEP),  THEY  MAY  BE  REDISTRIBUTED  TO\n*                    SECONDARY   CATALOGS  (SPLIT),  OR  THEY  MAY  BE\n*                    UNCATALOGED (UNCATLG).\n*\n*          WHEN  COPYCAT  IS  RUN  TWICE  FOR  A  MASTER  CATALOG  AND\n*     SECONDARY  CATALOGS,  THESE LAST TWO OPERANDS SHOULD BE THE SAME\n*     FOR BOTH RUNS. IF LOCAL MODIFICATIONS TO THE CATALOG  MANAGEMENT\n*     ROUTINES  HAVE  BEEN  ADDED SO A MASTER CATALOG IS NOT REQUIRED,\n*     COPYCAT NEED ONLY BE RUN ONCE IN SECONDARY MODE, AND  THE  THIRD\n*     CONTROL CARD PARAMETER MUST BE SPLIT.\n*\n*     2.2.2 INPUT\n*\n*          THE INPUT CARD DEFINES AN INPUT CATALOG  TO  BE  PROCESSED.\n*     THERE  MUST BE AT LEAST ONE AND AS MANY AS THIRTY-TWO (32) INPUT\n*     CARDS. THE INPUT DATASETS  DEFINED  BY  THESE  CARDS  ARE  NEVER\n*     CHANGED  BY THE PROGRAM. THEY MUST NOT BE THE SAME DATASETS USED\n*     FOR OUTPUT. THE INPUT CARD(S) MUST FOLLOW THE CONTROL CARD.\n*\n*       \u00ddNAME\u00a8 INPUT DDNAME,VOLID\n*\n*          DDNAME - THE NAME OF A DD STATEMENT THAT DEFINES THIS INPUT\n*                    DATASET.\n*\n*          VOLID - THE VOLUME NAME ON WHICH THIS CATALOG RESIDES  WHEN\n*                    USED  BY  THE SYSTEM. THIS VOLUME NEED NOT BE THE\n*                    SAME AS THAT DEFINED BY DDNAME.\n*\n*     2.2.3 OUTPUT\n*\n*          THE  OUTPUT  CARDS  DEFINE  THE  OUTPUT  DATASETS  AND  THE\n*     REDISTRIBUTION TABLE. THESE CARDS MUST FOLLOW THE INPUT CARDS.\n*\n*       \u00ddNAME\u00a8 OUTPUT \u00bbMASTER|SECONDARY\u00ba,DDNAME,VOLID\u00dd,MAXNAME\u00a8\n*\n*          MASTER - THIS CARD DEFINES THE MASTER CATALOG, OR THE  ONLY\n*                    CATALOG IF ONLY ONE IS BEING PRODUCED.\n*\n*          SECONDARY - THIS CARD DEFINES A SECONDARY CATALOG.\n*\n*          DDNAME - THE NAME OF A DD STATEMENT THAT DEFINES THE OUTPUT\n*                    DATASET.\n*\n*          VOLID - THE VOLUME NAME ON WHICH THIS CATALOG WILL BE  USED\n*                    BY  THE SYSTEM. THE CATALOG MAY BE PLACED ON SOME\n*                    OTHER   VOLUME   TEMPORARILY   FOR   BACKUP    OR\n*                    CONVENIENCE.\n*\n*          MAXNAME - THE HIGHEST NAME IN EBCDIC COLLATING SEQUENCE  TO\n*                    WHICH THIS OUTPUT CARD APPLIES. THIS MAXNAME MUST\n*                    BE GREATER  THEN  THE  MAXNAME  ON  THE  PREVIOUS\n*                    OUTPUT  CARD, AND ON THE LAST OUTPUT CARD IT MUST\n*                    BE NULL.\n*\n*          EACH OUTPUT CARD DEFINES A RANGE OF INDEX NAMES THAT ARE TO\n*     BE  PLACED  IN ITS CATALOG. THIS RANGE EXTENDS FROM THE PREVIOUS\n*     MAXNAME UP TO AND INCLUDING THE CURRENT MAXNAME. THE SAME DDNAME\n*     AND  VOLID  PAIR  MAY  APPEAR ON MORE THEN ONE CARD. THIS ALLOWS\n*     MORE THEN ONE RANGE OF INDEX NAMES TO BE PLACED ON ONE  CATALOG.\n*     ALL MASTER CARDS MUST HAVE THE SAME DDNAME AND VOLID SINCE THERE\n*     CAN ONLY BE ONE MASTER CATALOG. THE LAST OUTPUT CARD MUST HAVE A\n*     NULL MAXNAME.\n*\n*     2.2.4 CVOL\n*\n*          THE CVOL CARD MAY BE USED TO ALTER CONTROL  VOLUME  POINTER\n*     ENTRIES THAT POINT TO CATALOGS OUTSIDE THE CURRENT SYSTEM.\n*\n*       \u00ddNAME\u00a8 CVOL \u00ddVOLID\u00a8,NEWVOL,\u00ddMAXNAME\u00a8,DDNAME\n*\n*          VOLID - THE VOLUME NAME THAT IS BEING CHANGED.\n*\n*          NEWVOL - THE NEW VOLUME NAME FOR THE CVOL ENTRY.\n*\n*          MAXNAME - THE HIGHEST NAME IN  THE  RANGE  OF  INDEX  NAMES\n*                    COVERED  BY THIS CVOL CARD. ALL THE CVOL POINTERS\n*                    THAT POINT AT THIS VOLUME, WHOSE NAME IS  GREATER\n*                    THAN  THE PREVIOUS MAXNAME AND LESS THEN OR EQUAL\n*                    TO THIS MAXNAME, WILL  BE  CHANGED  TO  POINT  AT\n*                    NEWVOL.  THE  LAST CVOL CARD IN A SET MUST HAVE A\n*                    NULL VALUE FOR MAXNAME, WHICH IS THE  HIGHEST  IN\n*                    THE COLLATING SEQUENCE.\n*\n*          DDNAME - THE NAME OF A DD STATEMENT USED  FOR  DEVICE  TYPE\n*                    INFORMATION. THIS DD STATEMENT MUST DEFINE A UNIT\n*                    OF THE SAME TYPE AS NEWVOL.\n*\n*          MANY SETS OF CVOL CARDS MAY BE DEFINED. EACH SET MUST  HAVE\n*     VOLID  SPECIFIED  ON THE FIRST CARD, AND MAXNAME MUST BE NULL ON\n*     THE LAST. CVOL CARDS MUST FOLLOW THE OUTPUT CARDS.\n*\n*     2.2.5 LEVEL\n*\n*          THE  LEVEL  CARD  IS  USED  TO  SPECIFY  THE  RESTRUCTURING\n*     INFORMATION.  THE GREATEST PERFORMANCE IMPROVEMENTS DERIVED FROM\n*     RUNNING COPYCAT DEPEND ON PROPERLY CHOOSING THESE PARAMETERS. UP\n*     TO TWENTY-TWO LEVEL CARDS MAY BE DEFINED.\n*\n*       \u00ddNAME\u00a8 LEVEL LEVEL,BYTES,DUMMIES,BLOCKS\n*\n*          LEVEL - THE INDEX LEVEL BETWEEN ONE AND TWENTY-TWO TO WHICH\n*                    THIS CARD APPLIES.\n*\n*          BTYES - THE NUMBER OF BYTES TO  LEAVE  IN  EACH  BLOCK  FOR\n*                    FUTURE EXPANSION, BETWEEN 0 AND 200.\n*\n*          DUMMIES - THE NUMBER OF DUMMY BLOCKS TO  LEAVE  AFTER  THIS\n*                    INDEX FOR FUTURE EXPANSION.\n*\n*          BLOCKS - THE NUMBER OF BLOCKS THAT MUST BE ON  THE  CURRENT\n*                    OUTPUT TRACK BEFORE STARTING THIS INDEX.\n*\n*          THE LEVEL CARDS MUST FOLLOW  THE  CVOL  CARDS,  IF  ANY.  A\n*     DEFAULT VALUE OF ZERO IS APPLIED FOR ANY NULL OR MISSING VALUES.\n*\n*     2.3 JOB CONTROL STATEMENTS\n*\n*          A JOB CARD AND AN EXEC CARD ARE  REQUIRED.  A  SYSPRINT  DD\n*     STATEMENT  IS REQUIRED FOR A LISTING OF THE INPUT, INFORMATIONAL\n*     MESSAGES AND ERROR MESSAGES. THE DCB  PARAMETERS  ARE  FIXED  AT\n*     RECFM=FBA,LRECL=605,BLKSIZE=121. THE CONTROL CARDS ARE READ FROM\n*     THE   SYSIN   FILE   WHICH   HAS   FIXED   DCB   PARAMETERS   OF\n*     RECFM=FB,LRECL=80,BLKSIZE=3200.  ADDITIONAL  DD  STATEMENTS  ARE\n*     REQUIRED AS SPECIFIED BY THE INPUT, OUTPUT AND CVOL  CARDS.  THE\n*     DATASETS  DEFINED  BY  THESE  DD  STATEMENTS  NEED  NOT BE NAMED\n*     SYSCTLG, BUT THEY MUST BE  ON  A  DIRECT  ACCESS  VOLUME.  IF  A\n*     CATALOG  IS  CREATED  ON A VOLUME OTHER THEN THE ONE ON WHICH IT\n*     WILL BE USED BY THE SYSTEM, THE TEMPORARY VOLUME  SHOULD  BE  OF\n*     THE SAME DEVICE TYPE AS THE FINAL VOLUME.\n*\n*\n*     2.4 MESSAGES AND CODES\n*\n*          AFTER A SUCCESSFUL RUN OF COPYCAT CERTAIN STATISTICS  ABOUT\n*     EACH  OUTPUT  DATASET  ARE  LISTED. THE LAST TTR PLUS ONE IN THE\n*     DATASET AND THE TTR OF THE LAST USED BLOCK PLUS ONE  ARE  LISTED\n*     IN  HEXADECIMAL.  THE  NUMBER OF CONTROL VOLUME POINTER ENTRIES,\n*     DUMMY BLOCKS,  BLOCKS  AT  LEVELS  ONE  AND  TWO,  AND  DATASETS\n*     CATALOGED ARE LISTED IN DECIMAL.\n*\n*          THE FOLLOWING IS A LIST OF ERROR  MESSAGES  AND  COMPLETION\n*     CODES. THE MAXIMUM COMPLETION CODE FOUND DURING EXECUTION OF THE\n*     PROGRAM IS RETURNED TO OS.\n*\n*     ERR01 ERROR FOUND IN PARAMETER AT '$'\n*\n*          AN ERROR WAS FOUND IN A PARAMETER OR A  REQUIRED  PARAMETER\n*          WAS MISSING. THE PREVIOUS LINE WILL CONTAIN A '$' UNDER THE\n*          ERROR.\n*          (COMPLETION CODE = 8)\n*\n*     ERR02 ERROR PROCESSING DDNAME='DDNAME'\n*\n*          A PROBLEM WAS FOUND WITH A DD STATEMENT. EITHER IT WAS  NOT\n*          FOUND,  COULD  NOT BE OPENED, OR WAS NOT ON A DIRECT ACCESS\n*          VOLUME.\n*          (COMPLETION CODE = 8)\n*\n*     ERR03 UNEXPECTED END OF FILE ON SYSIN\n*\n*          MORE CONTROL CARDS WERE EXPECTED, BUT WERE NOT FOUND.\n*          (COMPLETION CODE = 8)\n*\n*     ERR04 NAME=TRUENAME NOT FOUND FOR ALIAS=ALIASNAME\n*\n*          WHILE PROCESSING AN ALIAS ENTRY,  THE  TRUE  NAME  FOR  THE\n*          ALIAS COULD NOT BE FOUND.\n*          (COMPLETION CODE = 12)\n*\n*     ERR05 ALIAS COUNT ERROR FOUND FOR NAME=TRUENAME\n*\n*          THE ALIAS COUNT FIELD IN THE NAMED INDEX IS  NOT  EQUAL  TO\n*          THE NUMBER OF ALIASES FOUND FOR THE NAME.\n*          (COMPLETION CODE = 12)\n*\n*     ERR06 TOO MANY INPUT DATASETS\n*\n*          MORE THEN 32 INPUT CARDS WERE FOUND.\n*          (COMPLETION CODE = 8)\n*\n*     ERR07 INDEX=INDEX FOUND ON VOLS=(X,Y) THE ENTRY  ON  X  WILL  BE\n*     USED\n*\n*          THE SAME HIGH  LEVEL  INDEX  WAS  FOUND  ON  TWO  DIFFERENT\n*          CATALOGS. THE ONE ON THE X VOLUME WILL BE USED.\n*          (COMPLETION CODE = 4)\n*\n*     ERR08 NO INPUT CARDS FOUND\n*\n*          NO INPUT CARDS WERE FOUND,  OR  THEY  DID  NOT  FOLLOW  THE\n*          CONTROL CARD.\n*          (COMPLETION CODE = 8)\n*\n*     ERR09 FUNCTION FAILED  WITH  (CODE)  ON  VOLUME  FOR  GDG  MODEL\n*     DSCB=NAME\n*\n*          WHILE MOVING OR COPYING MODEL DSCBS, AN OBTAIN, ALLOCATE OR\n*          SCRATCH  OPERATION  FAILED  WITH  THE RETURN CODE OF 'CODE'\n*          (DECIMAL).\n*          (COMPLETION CODE = 4)\n*\n*     ERR10 MODEL DSCB FOR GDG DOES NOT HAVE ZERO EXTENTS DSN=NAME\n*\n*          THE NAMED MODEL DSCB IS NOT COPIED BECAUSE IT DOES NOT HAVE\n*          ZERO EXTENTS.\n*          (COMPLETION CODE = 4)\n*\n*     ERR11 MODEL DSCB FOR GDG EXISTS ON OUTPUT VOLUME WITH  DIFFERENT\n*     ATTRIBUTES FOR DSN=NAME\n*\n*          WHILE MOVING OR COPYING MODEL DSCBS A DSCB  WITH  THE  SAME\n*          NAME  WAS  FOUND  ON  THE OUTPUT VOLUME, BUT THE ATTRIBUTES\n*          DEFINED BY THE TWELVE  BYTES  IN  THE  DSCB  AT  OFFSET  82\n*          (DECIMAL)  ARE  NOT  THE  SAME.  THE  DSCB  IS NOT MOVED OR\n*          COPIED.\n*          (COMPLETION CODE = 4)\n*\n*     ERR12 ABEND - NNN - OCCURED. SEE SYSMSG. CURRENT OR LAST NAME IS\n*     NAME\n*\n*          A D37, B37 OR 213 ABEND OCCURED. THE LAST  INDEX  STRUCTURE\n*          BEING PROCESSED IS GIVEN.\n*          (COMPLETION CODE = 16)\n*\n*     ERR13 I/O ERROR - SYNAD MESSAGE\n*     ERR13 I/O ERROR CURRENT OR LAST NAME IS NAME\n*\n*          AN I/O ERROR OCCURED. THE STANDARD MESSAGE  PRODUCED  BY  A\n*          SYNAD  MACRO  IS GIVEN, ALONG WITH THE LAST INDEX STRUCTURE\n*          PROCESSED.\n*          (COMPLETION CODE = 16)\n*\n*     ERR14 NO OUTPUT MASTER CARD WAS FOUND\n*\n*          WHEN IN MASTER MODE, AT LEAST ONE OUTPUT MASTER  CARD  MUST\n*          BE DEFINED.\n*          (COMPLETION CODE = 8)\n*\n*     THE COMPLETION CODES ARE AS FOLLOWS:\n*\n*         0 - NO ERRORS.\n*\n*         4 - ALL CATALOGS ARE USEABLE, BUT DUPLICATE INDEXES HAVE\n*             BEEN  LEFT  OUT  OR  MODEL  DSCBS HAVE NOT BEEN MOVED OR\n*             COPIED.\n*\n*         8 - ERRORS IN PROCESSING CONTROL CARDS. THE OUTPUT DATASETS\n*             HAVE NOT BEEN CHANGED.\n*\n*  12 - ALL CATALOGS ARE USEABLE, BUT PROBLEMS EXIST WITH ALIAS\n*             ENTRIES.\n*\n*  16 - OUTPUT CATALOGS HAVE BEEN PARTLY BUILT, AND ARE NOT\n*             USEABLE.\n*\n*     2.5 EXAMPLES\n*\n*     2.5.1 COPY A CATALOG FROM ONE VOLUME TO ANOTHER\n*\n*          THIS FIRST EXAMPLE  ILLUSTRATES  THE  MOST  COMMON  USE  OF\n*     COPYCAT.  A  CATALOG  ON  ONE  VOLUME IS TO BE COPIED TO ANOTHER\n*     VOLUME, SUCH AS WHEN A NEW SYSTEM IS BEING INSTALLED.  THIS  JOB\n*     WOULD  BE RUN UNDER THE OLD SYSTEM TO COPY THE CATALOG ON SYSRES\n*     TO THE NEW SYSTEM PACK, NEWRES, WHICH WILL  LATER  BE  RELABELED\n*     SYSRES.\n*\n*     //EX1    JOB   XXX\n*     //       EXEC  PGM=COPYCAT,REGION=60K\n*     //SYSPRINT DD  SYSOUT=A\n*     //OLDRES DD    DSN=SYSCTLG,VOL=SER=SYSRES,\n*     //             DISP=OLD,UNIT=DISK\n*     //NEWRES DD    DSN=SYSCTLG,VOL=SER=NEWRES,\n*     //             DISP=OLD,UNIT=DISK\n*     //SYSIN  DD    *\n*     *              EXAMPLE ONE\n*              CONTROL MASTER,GDGCOPY,KEEP\n*              INPUT OLDRES,SYSRES\n*              OUTPUT MASTER,NEWRES,SYSRES\n*              LEVEL 1,26,100\n*              LEVEL 2,52,5,5\n*\n*          IN THIS EXAMPLE MODEL DSCBS FOR GENERATION DATA GROUPS  ARE\n*     COPIED. 100 DUMMY BLOCKS ARE LEFT AFTER THE HIGHEST LEVEL INDEX,\n*     WITH 26 BYTES LEFT IN EACH BLOCK FOR FUTURE EXPANSION. 52  BYTES\n*     ARE  LEFT  IN  EACH  SECOND LEVEL INDEX BLOCK, 5 BLOCKS ARE LEFT\n*     AFTER EACH INDEX, AND A SECOND LEVEL INDEX WILL NOT  BE  STARTED\n*     ON A TRACK WITHIN 5 BLOCKS OF THE END.\n*\n*     2.5.2 BACK UP A CATALOG\n*\n*          THIS EXAMPLE DEMONSTRATES THE USE OF COPYCAT FOR BACKING UP\n*     A  CATALOG.  NOTE  THAT  THE  BACKUP DATASET DOES NOT NEED TO BE\n*     CALLED SYSCTLG, THUS MANY CATALOGS COULD BE  BACKED  UP  ON  THE\n*     SAME VOLUME.\n*\n*     //EX2    JOB   XXX,REGION=60K\n*     //       EXEC  PGM=COPYCAT\n*     //SYSPRINT DD  SYSOUT=A\n*     //CATALOG DD   DSNAME=SYSCTLG,VOL=SER=PACK01,\n*     //             UNIT=DISK,DISP=OLD\n*     //BACKUP DD    DSNAME=CAT.PACK01,VOL=SER=BACKUP,\n*     //             UNIT=DISK,SPACE=(CYL,(3,2)),DISP=(NEW,KEEP)\n*     //SYSIN  DD    *\n*     *              EXAMPLE 2\n*              CONTROL MASTER,GDGCOPY,KEEP\n*              INPUT CATALOG,PACK01\n*              OUTPUT MASTER,BACKUP,PACK01\n*     /*\n*\n*     2.5.3 REDISTRIBUTE A CATALOG\n*\n*          IN THIS EXAMPLE A SINGLE CATALOG IS TO  BE  SPLIT  UP  INTO\n*     FOUR  SEPARATE  CATALOGS.  THE FIRST STEP PRODUCES THE SECONDARY\n*     CATALOGS, AND THE SECOND STEP PRODUCES THE MASTER  CATALOG.  THE\n*     LAST  STEP IS EXECUTED ONLY IF THE FIRST TWO STEPS RAN PROPERLY,\n*     AND IT RENAMES THE DATASET ON RES075.\n*\n*     //EX3    JOB   XXX\n*     //STEP1  EXEC  PGM=COPYCAT,REGION=60K\n*     //SYSPRINT DD  SYSOUT=A\n*     //INPUT  DD    VOL=SER=RES075,UNIT=DISK,DISP=OLD,\n*     //             DSNAME=SYSCTLG\n*     //OLDRES DD    VOL=SER=RES075,UNIT=DISK,\n*     //             DSNAME=NEWCAT,DISP=(NEW,KEEP),\n*     //             SPACE=(CYL,(5,2))\n*     //P87    DD    UNIT=DISK,VOL=SER=PACK87,\n*     //             DSNAME=SYSCTLG,DISP=(NEW,KEEP),\n*     //             SPACE=(CYL,(5,2))\n*     //P88    DD    UNIT=DISK,VOL=SER=PACK88,\n*     //             DSNAME=SYSCTLG,DISP=(NEW,KEEP),\n*     //             SPACE=(CYL,(5,2))\n*     //P89    DD    UNIT=DISK,VOL=SER=PACK89,\n*     //             DSNAME=SYSCTLG,DISP=(NEW,KEEP),\n*     //             SPACE=(CYL,(5,2))\n*     //SYSIN  DD    *\n*     *              EXAMPLE 3\n*     *              PRODUCE THE SECONDARY CATALOGS\n*              CONTROL SECONDARY,GDGMOVE,KEEP\n*              INPUT INPUT,RES075\n*              OUTPUT SECONDARY,P87,PACK87,B9999999\n*              OUTPUT SECONDARY,P88,PACK88,H9999999\n*              OUTPUT MASTER,OLDRES,RES075,K9999999\n*              OUTPUT SECONDARY,P89,PACK89,R9999999\n*              OUTPUT MASTER,OLDRES,RES075,S9999999\n*              OUTPUT SECONDARY,P88,PACK88\n*              LEVEL 1,26,100\n*              LEVEL 2,54,5,5\n*              LEVEL 3,,2,2\n*     /*\n*     //STEP2  EXEC  PGM=COPYCAT,REGION=60K\n*     //SYSPRINT DD  SYSOUT=A\n*     //INPUT  DD    VOL=SER=RES075,UNIT=DISK,DISP=OLD,\n*                    DSNAME=SYSCTLG\n*     //OLDRES DD    VOL=SER=RES075,UNIT=DISK,\n*                    DSNAME=NEWCAT,DISP=OLD\n*     //P87    DD    UNIT=DISK,VOL=SER=PACK87,\n*                    DSNAME=SYSCTLG,DISP=OLD\n*     //P88    DD    UNIT=DISK,VOL=SER=PACK88,\n*                    DSNAME=SYSCTLG,DISP=OLD\n*     //P89    DD    UNIT=DISK,VOL=SER=PACK89,\n*                    DSNAME=SYSCTLG,DISP=OLD\n*     //SYSIN  DD    *\n*     *              EXAMPLE 3\n*     *              PRODUCE THE MASTER CATALOG\n*              CONTROL MASTER,GDGMOVE,KEEP\n*              INPUT INPUT,RES075\n*              OUTPUT SECONDARY,P87,PACK87,B9999999\n*              OUTPUT SECONDARY,P88,PACK88,H9999999\n*              OUTPUT MASTER,OLDRES,RES075,K9999999\n*              OUTPUT SECONDARY,P89,PACK89,R9999999\n*              OUTPUT MASTER,OLDRES,RES075,S9999999\n*              OUTPUT SECONDARY,P88,PACK88\n*              LEVEL 1,26,50\n*              LEVEL 2,54,10,10\n*     /*\n*     //STEP3  EXEC  PGM=IEHPROGM,COND=(5,LT)\n*     //SYSPRINT DD  SYSOUT=A\n*     //OLDRES DD    UNIT=DISK,VOL=SER=RES075,DISP=OLD\n*     //SYSIN  DD    *\n*              RENAME VOL=2314=RES075,DSNAME=SYSCTLG,\n*                    NEWNAME=OLDCATLG\n*              RENAME VOL=2314=RES075,DSNAME=NEWCAT,\n*                    NEWNAME=SYSCTLG\n*     /*\n*\n*          ALL INDEXES UP TO C WILL BE ON PACK87, INDEXES FROM C TO  I\n*     AND FROM T UPWARDS WILL BE ON PACK88, AND FROM L TO S WILL BE ON\n*     PACK89. CVOL POINTERS FOR THESE INDEXES WILL BE PLACED ON RES075\n*     ALONG  WITH  ALL  THE  OTHER INDEXES. STEP 3 WILL BE EXECUTED IF\n*     THERE ARE NO SEVERE ERRORS.\n*\n*     3.0 PROGRAM LOGIC\n*\n*          COPYCAT IS WRITTEN ENTIRELY IN ASSEMBLER LANGUAGE. QSAM  IS\n*     USED FOR SYSPRINT AND SYSIN, WHILE BSAM IN THE LOAD MODE IS USED\n*     FOR THE OUTPUT DATASETS. BDAM IS  USED  FOR  THE  INPUT  AND  TO\n*     ACCESS PREVIOUSLY WRITTEN OUTPUT BLOCKS.\n*\n*          THE HEART OF THE PROGRAM CONSISTS OF  A  RECURSIVE  ROUTINE\n*     CALLED  RR, WHICH IS CALLED FOR EACH LEVEL. THE TTR OF THE FIRST\n*     BLOCK OF THE LEVEL IS PASSED TO RR. AFTER AN  INDEX  IS  WRITTEN\n*     WITH  THE OLD TTRS, IT IS REREAD AND FOR EACH ENTRY WITH A LOWER\n*     LEVEL, RR IS RECURSIVELY CALLED. UPON RETURN,  THE  NEW  TTR  IS\n*     PLACED IN THE ENTRY AND THE BLOCK IS REWRITTEN.\n*\n*          WHEN PROCESSING THE HIGHEST  LEVEL  INDEX,  THE  ADDITIONAL\n*     INFORMATION  OF  WHICH  INPUT  DATASET THIS ENTRY CAME FROM MUST\n*     ALSO BE SAVED. THIS IS DONE BY CHANGING THE COUNT FIELD  OF  THE\n*     INDEX.  ONLY THREE TYPES OF ENTRIES NEED THIS INFORMATION SAVED:\n*     THE INDEX POINTER ENTRY, THE VOLUME CONTROL BLOCK POINTER ENTRY,\n*     AND THE GENERATION INDEX POINTER ENTRY. BY MAKING THE LAST THREE\n*     BITS OF THE VOLUME CONTROL BLOCK POINTER ENTRY '110',  ONLY  THE\n*     ENTRIES  WITH  A LAST BIT OF '0' CONTAIN ADDITIONAL INFORMATION.\n*     TWO BITS ARE USED TO DISTINGUISH  BETWEEN  THE  THREE  TYPES  OF\n*     ENTRIES,  AND  THE  OTHER FIVE BITS IN THE LENGTH FIELD ARE THEN\n*     USED TO LOCATE THE PROPER INPUT DATASET.\n*\n*          WHEN PROCESSING  MODEL  DSCBS,  THE  OBTAIN,  ALLOCATE  AND\n*     SCRATCH   SVCS   ARE   USED.   BEFORE   RUNNING  COPYCAT,  LOCAL\n*     RESTRICTIONS ON ALLOCATING AND  SCRATCHING  DATASETS  SHOULD  BE\n*     CONSIDERED.  THESE  SVCS  ARE  ONLY  USED  IN THE ROUTINE CALLED\n*     GDSPROC.\n*\n*          TWO OTHER IMPORTANT ROUTINES ARE INR AND  PUTC.  INR  FINDS\n*     THE  NEXT NAME IN THE HIGHEST LEVEL INDEXES TO BE PROCESSED FROM\n*     AMONG ALL THE INPUTS. IT IS CALLED BY  RR  AND  IT  HANDLES  THE\n*     PROBLEM  OF DUPLICATE INDEX NAMES. PUTC IS ALSO CALLED BY RR AND\n*     IT TAKES AN INDEX AND ADDS IT TO THE NEXT BLOCK FOR OUTPUT. PUTC\n*     PROCESSES THE PARAMETERS OF THE LEVEL CARDS.\n*\n*\n         EJECT\n***********************************************************************\n*              EQUATE STATEMENTS                                      *\n***********************************************************************\n*              GENERAL\nNOP      EQU   0 -                 NO OPERATION\nFF       EQU   X'FF' -             ALL BITS ON\n*              AFTER COMPARE INSTRUCTIONS\nGT       EQU   2 -                 A HIGH\nLT       EQU   4 -                 A LOW\nNE       EQU   7 -                 A NOT EQUAL B\nEQ       EQU   8 -                 A EQUAL B\nGE       EQU   11 -                A NOT LOW\nLE       EQU   13 -                A NOT HIGH\n*              AFTER ARITHMETIC INSTRUCTIONS\nOV       EQU   1 -                 OVERFLOW\nPLUS     EQU   2 -                 PLUS\nMINUS    EQU   4 -                 MINUS\nNZERO    EQU   7 -                 NOT ZERO\nZERO     EQU   8 -                 ZERO\nZEROS    EQU   8 -                 ZERO\nNMINUS   EQU   11 -                NOT MINUS\nNPLUS    EQU   13 -                NOT PLUS\n*              AFTER TEST UNDER MASK INSTRUCTIONS\nALLON    EQU   1 -                 ALL ON\nMIXED    EQU   4 -                 MIXED\nNALLOFF  EQU   5 -                 ALLON+MIXED\nALLOFF   EQU   8 -                 ALL OFF\nNALLON   EQU   12 -                ALLOFF+MIXED\n         EJECT\n***********************************************************************\n*              REGISTER EQUIVALENTS                                   *\n***********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE 2\n         EJECT\n*---------------------------------------------------------------------*\n*              CATALOG ENTRIES\n*---------------------------------------------------------------------*\nCATENTRY DSECT\nCATNAME  DS    CL8                 NAME FIELD\nCATTTR   DS    XL3                 TTR\nCATCOUNT DS    X                   COUNT (HALFWORDS THAT FOLLOW\nCATVAR   DS    0X                  VARIABLE PARTS\n*              VICE - VOLUME INDEX CONTROL ENTRY\nCVICE    EQU   5                   COUNT FOR VOLUME INDEX CONTROL\nCVICUP   DS    XL3                 LAST BLOCK ADDR\n         DS    X'00'\nCVICFRST DS    XL3                 FIRST AVAILABLE BLOCK\n         DS    X'00'\nCVICULB  DS    XL2                 COUNT OF BYTES IN LAST BLOCK\n*              ICE - INDEX CONTROL ENTRY\n         ORG   CATVAR\nCICE     EQU   3                   CUUNT FOR ICE\nCICEILL  DS    XL3                 TTR OF THIS BLOCK\nCICEALIA DS    X                   # OF ALIASES\nCICEUBL  DS    XL2                 # OF UNUSED BYTES IN LAST BLOCK\n*              ILE - INDEX LINK ENTRY\n         ORG   CATVAR  -NAME HAS FF\nCILE     EQU   0                   COUNT FOR INDEX LINK ENTRY\n*              IPE - INDEX POINTER ENTRY\n         ORG   CATVAR\nCIPE     EQU   0\n*              DSPE  - DATA SET POINTER ENTRY\n         ORG   CATVAR\nCDSPE    EQU   7                   6*M+1 (M 1 THRU 5)\nCDSPEVC  DS    XL2                 #OF VOLUMES (M)\nCDSPEVE  DS    0XL12               FIRST ENTRY\n*              VCBPE - VOLUME CONTROL BLOCK POINTER ENTRY\n         ORG   CATVAR\nCVCBPE   EQU   1                   TTR POINTS AT VCB\n         DS    XL2'00'             UNUSED- ZERO\n*              VCPE - CONTROL VOLUME POINTER ENTRY\n         ORG   CATVAR\nCCVPE    EQU   3\nCCVPEVOL DS    CL6                CVOL NAME\n*              NCVPE  NEW CONTROL VOLUME POINTER ENTRY\n         ORG   CATVAR\nCNCVPE   EQU   5\nCNCVPEDT DS    XL4                 DEVICE TYPE CODE\nCNCVPEVO DS    CL6                 CVOL NAME\n*              AE - ALIAS ENTRY\n         ORG   CATVAR\nCAE      EQU   4\nCAENAME  DS    CL8                 TRUE NAME\n*              GIPE - GENERATION INDEX POINTER ENTRY\n         ORG   CATVAR\nCGIPE    EQU   2\nCGIPEFLA DS    X                   FLAG -EMPTY,DELETE\nCGIPEMAX DS    X                   MAX # OF GENERATIONS\nCGIPECUR DS    XL2                 CURRENT # OF ENTRIES\n*              VCB - VOLUME CONTROL BLOCK\n         ORG   CATNAME\nCVCNUM   DS    XL2                 #OF VOLUMES\nCVCBVOLI DS    XL240               FIRST 20 ENTRIES\n         DS    XL10                ZEROS\nCVCBNEXT DS    XL3                 TTR OF NEXT VCB IF CVCBNUM >20\n         DS    X                   ZEROS\n*              USED FOR SPLITING AND OUTPUT\n         EJECT\nVOLLIST  DSECT\n         PRINT NOGEN\nVOLLDCB  DCB   DSORG=PS,DDNAME=X,MACRF=(E),DEVD=DA,RECFM=F       EXCP01\n         DS    0F\nVOLLDCBE EQU   *\n         PRINT GEN\nVOLLMBLK DS    H                   # OF BLOCKS/TRK               EXCP01\nVOLLTTR  DS    XL3                 NEXT TTR FOR OUTPUT           EXCP01\nVOLLNEXT DS    A                   NEXT VOLLIST\nVOLLNAME DS    CL8                 MAX NAME FOR THIS ENTRY\nVOLLRNXT DS    A                   REAL VOLLIST ENTRY TO USE FOR IO\nVOLALCHN DS    A                   ALIAS NAME CHAIN\nVOLANCHN DS    A                   REAL NAME FOR ALIAS CHAIN\nVOLLFRST DS    XL3                 FIRST AVAILABLE BLOCK\nVOLLVOL  DS    CL6\nVOLLFLAG DS    X                   FLAGS\nVOLLKEEP EQU   X'80'               1=KEEP 0=SPLIT\nVOLLSECN EQU   X'40'               NEXT WRITE NEEDS NEW EXTENT\nVOLLDEVT DS    F                   DEVICE TYPE\n         DS    F                   MAX BLK SIZE\n         DS    H                   #OF CYL\nVOLLTRKP DS    H                   TRK / CYL\nVOLLTRKL DS    H                   TRK LENGTH\nVOLLBOH  DS    X                   BLOCK OVER HEAD\nVOLLBOHL DS    X                   BLOCK OVER HEAD  LAST BLOCK\n         DS    X                   BLOCK OVER HEAD  NOT KEYED\nVOLLDFLG DS    X                   FLAG\nVOLLTOL  EQU   X'01'               TOLERANCE FACTOR NEEDED\nVOLLBOHH EQU   X'08' -             BLOCK OERHEAD IS HALF WORD    F00003\nVOLLTOLF DS    H                   TOLERANCE FACTOR\n         DS    0F                  PCAREA USED FOR HIGH INDEX\nVOLLITTR DS    XL3\n         DS    X\nVOLLIKEY DS    CL8\nVOLLIBUF DS    XL256\nVOLLEXLT DS    A                   EXIT LIST FOR DCB\nVOLLJFCB DS    XL176               JFCB\nVOLLICVL DS    H                   # OF CVOL POINTERS\nVOLLIDUM DS    H                   # OF DUMMY BLOCKS\nVOLLI1   DS    H                   # OF BLOCKS AT LEVEL 1\nVOLLI2   DS    H                   # OF BLOCKS AT LEVEL 2\nVOLLDS   DS    F                   # OF DATA SETS\nVOLLEND  DS    0F\nVOLLSIZE EQU   VOLLEND-VOLLIST     SIZE OF ENTRY\n         EJECT\n*---------------------------------------------------------------------*\n*              INPUT DD WORK AREA\n*---------------------------------------------------------------------*\nINLIST   DSECT\n         PRINT NOGEN\nINDCB    DCB   DSORG=PS,DDNAME=X,MACRF=(E),DEVD=DA,RECFM=F       EXCP01\nINDCBE   EQU   *\n         PRINT GEN\nINMBLK   DS    H                   # OF BLOCKS PER TRACK         EXCP01\nINOFF    DS    H                   OFFSET TO NEXT ENTRY\nINTTR    DS    XL3                 TTR OF THIS RECORD\nININDEX  DS    X                   INDEX NUMBER\nINVOL    DS    CL6                 VOLUME THAT THIS DATA SET IS ON\nINKEY    DS    CL8                 KEY\nINBUF    DS    CL256               BUFFER\nINEND    EQU   *\nINSIZE   EQU   INEND-INLIST\n         EJECT\nLEVTABE  DSECT\nLEVBYTES DS    H                   BYTES TO LEAVE IN EACH BLOCK\nLEVBLOCK DS    H                   BLOCKS TO LEAVE AT END OF INDEX\nLEVBLONT DS    H                   BLOCKS THAT MUST BE LEFT ON THE TRK\nLEVTABL  EQU   *-LEVBYTES\n         SPACE 3\n*---------------------------------------------------------------------*\n*              PCAREA SUPLIED BY CALLER (CLEARED AT START OF INDEX)\n*---------------------------------------------------------------------*\nPCAREA   DSECT\nPCTTR    DS    XL3                 TTR RETURN AREA FOR USER\nPCFLAG   DS    X                   FLAG\nPCCLBUF  EQU   X'80'               BUFFER BEING USED\nPCVCB    EQU   X'40'               THIS IS A VCB (SET BY CALLER)\nPCKEY    DS    CL8                 KEY\nPCBUF    DS    XL256               BUFFER\n         SPACE 3\n*---------------------------------------------------------------------*\n*              OLD CVOL NAMES THAT MUST BE CHANGED\n*---------------------------------------------------------------------*\nCVOLD    DSECT\nCVOLDCHN DS    A                   FIRST CVNEW\nCVOLDDUM DS    CL8                 DUMMY SO LOOKS LIKE CVNEW\nCVOLDNXT DS    A                   NEXT CVOLD\nCVOLDNAM DS    CL6                 NAME\nCVOLDE   DS    0F                  END\nCVOLDSIZ EQU   CVOLDE-CVOLD        SIZE\n         SPACE 3\n*---------------------------------------------------------------------*\n*              NEW NAMES AND MAX NAMES FOR OLD CVOLS\n*---------------------------------------------------------------------*\nCVNEW    DSECT\nCVNEWNXT DS    A                   NEXT CVNEW\nCVNEWDSN DS    CL8                 MAX NAME FOR THIS NAME\nCVNEWDEV DS    F                   DEVICE TYPE\nCVNEWNAM DS    CL6                 NEW CVOL NAME\nCVNEWE   DS    0F                  END\nCVNEWSIZ EQU   CVNEWE-CVNEW        SIZE\n         EJECT\n*---------------------------------------------------------------------*\n*              ALIAS PROCESSING DSECT\n*---------------------------------------------------------------------*\nALENTRY  DSECT\nALNEXT   DS    A                   NEXT ALENTRY OR ZERO\nALTTR    DS    XL3                 TTR IN OUTPUT DATA SET\n         DS    X\nALOFF    DS    H                   OFFSET TO ENTRY IN OUTPUT BLOCK\nALNAME   DS    CL8                 NAME\nALRNAME  DS    CL8                 REAL NAME\nALEND    DS    0F\nALSIZE   EQU   ALEND-ALENTRY       SIZE\n         SPACE 3\n*---------------------------------------------------------------------*\n*              DSECT FOR NAMES THAT HAVE ALIASES\n*---------------------------------------------------------------------*\nANENTRY  DSECT\nANNEXT   DS    A                   NEXT OR ZERO\nANTTR    DS    XL3                 TTR IN OUTPUT DATA SET\nANCOUNT  DS    H                   COUNT OF ALIASES\nANNAME   DS    CL8                 NAME\nANEND    DS    0F                  END\nANSIZE   EQU   ANEND-ANENTRY       SIZE\n         EJECT\n*---------------------------------------------------------------------*\n*              RRWORK - WORK AREA FOR RECURSIVE ROUTINE\n*---------------------------------------------------------------------*\nRRWORK   DSECT\n         DS    18F\nRRLEV    DS    H                   LEVEL\nRRBYTES  DS    H                   BYTES LEFT IN LAST BLOCK\nRRSVTTR  DS    XL3                 TTR FOR READ + WRITE\n         DS    X\nRRRTTR   DS    XL3\nRRFSTTR  DS    A                   ADDRESS OF CALLERS TTR\nRRNAME   DS    A                   SPOT FOR NAME\nRRKEY    DS    CL8\nRRBUF    DS    XL256               BUFFER\nRRPTTR   DS    XL3                 PCAREA\n         DS    X\nRRPKEY   DS    CL8\nRRPBUF   DS    XL256\nRRWORKE  DS    0F\nRRWKSIZE EQU   RRWORKE-RRWORK\n         EJECT\n*----------------------------------------------------------------EXCP01\n*              BUFFER - TRACK BUFFER HEADER                      EXCP01\n*----------------------------------------------------------------EXCP01\nBUFFER   DSECT                                                   EXCP01\nBUFNEXT  DS    A                   NEXT TRACK BUFFER             EXCP01\nBUFADCB  DS    A                   ADDR OF DCB FIR THIS TRACK    EXCP01\nBUFTT    DS    H                   TT OF THACK                   EXCP01\nBUFFLAG  DS    X                   FLAGS                         EXCP01\nBUFRETN  EQU   X'80'               RETAIN THIS REC OF BUF        EXCP01\nBUFWTR   EQU   X'40'               REC OR BUF NEEDS TO BE WRITEN EXCP01\nBUFNRTR  EQU   X'20'               INPUT REC NOT YET READ        EXCP01\nBUFNCOMP EQU   X'10'               TRACK NOT COMPLETE            EXCP01\n         DS    X                                                 EXCP01\nBUFEND   EQU   *                   END OF HEADER OF BUFFER       EXCP01\nBUFSIZE  EQU   BUFEND-BUFFER                                     EXCP01\n         SPACE 2                                                 EXCP01\n*----------------------------------------------------------------EXCP01\n*              RBUFFER - RECORD ENTRIES IN THE TRACK BUFFER      EXCP01\n*----------------------------------------------------------------EXCP01\nRBUFFER  DSECT                                                   EXCP01\nRBUFFLAG DS    X                   FLAGS                         EXCP01\n         DS    XL3                                               EXCP01\nRBUFKEY  DS    XL8                 KEY                           EXCP01\nRBUFDATA DS    XL256               DATA                          EXCP01\nRBUFEND  EQU   *                   END OF THIS REC               EXCP01\nRBUFSIZE EQU   RBUFEND-RBUFFER                                   EXCP01\n         EJECT                                                   EXCP01\n*----------------------------------------------------------------EXCP01\n*              WORK AREA FOR EXCP READS AND WRITES               EXCP01\n*----------------------------------------------------------------EXCP01\nWRDSECT  DSECT                                                   EXCP01\nWRECB    DS    F                   ECB                           EXCP01\nWRIOB    DS    0XL40               IOB                           EXCP01\n         DC    XL16'00'                                          EXCP01\nIOBSTART DC    A(0) -              ADDR OF CHANNEL PROGRAM       EXCP01\nIOBDCBPT DC    A(0) -              ADDR OF DCB FOR THIS IOB      EXCP01\n         DC    XL8'00'                                           EXCP01\nIOBMBBCC DS    XL8                 MBBCCHHR                      EXCP01\nWRBUF    DS    F                   ADDR OF CURRENT BUFFER        EXCP01\nWREND    EQU   *                                                 EXCP01\n         EJECT                                                   EXCP01\n*----------------------------------------------------------------EXCP01\n*              THE CCWS USED FOR WRITE                           EXCP01\n*----------------------------------------------------------------EXCP01\nWTRCCWS  DSECT                                                   EXCP01\n         CCW   X'31',IOBMBBCC+3,X'40',5 SEARCH ID EQUAL          EXCP01\n         CCW   X'08',*-8,X'00',0       TIC                       EXCP01\nWTRCCW   CCW   X'1D',*+16,X'80',8  COUNT                         EXCP01\n         CCW   X'08',*+16,X'00',0  TIC AROUND COUNT              EXCP01\nWTRCCWC  DS    XL8                 COUNT FIELD                   EXCP01\nWTRCCWD  CCW   X'08',*-*,X'00',264     KEY AND DATA              EXCP01\nWTRCCWE  EQU   *                   START OF NEXT WTRCCW          EXCP01\n         SPACE  2                                                EXCP01\n*----------------------------------------------------------------EXCP01\n*              THE CCWS USED FOR READ                            EXCP01\n*----------------------------------------------------------------EXCP01\nRDCCWS   DSECT                                                   EXCP01\n         CCW   X'31',IOBMBBCC+3,X'40',5 SEARH ID EQ              EXCP01\n         CCW   X'08',*-8,X'00',0       TIC                       EXCP01\nRDCCW    CCW   X'0E',*-*,X'00',264     READ KEY + DATA           EXCP01\nRDCCWE   EQU   *                   NEXT RDCCW                    EXCP01\n         EJECT                                                   EXCP01\nIHADCB   DCBD  DEVD=(DA),DSORG=(PS)                              EXCP01\n         EJECT\n*---------------------------------------------------------------------*\n*\n*                       *** COPYCAT ***\n*\n*                              BY\n*\n*                       DOUGLAS E. ENGERT\n*\n*                  ARGONNE NATIONAL LABORATORY\n*\n*                            MAY 1974\n*\n*---------------------------------------------------------------------*\n*\n*                COPYCAT IS AN OS UTILITY PROGRAM WHICH CAN BE USED\n*              TO COPY AN OS CATALOG WHILE REFORMATING IT FOR\n*              FASTER ACCESSING. ONE OR MORE CATALOGS CAN BE USED\n*              FOR INPUT AND MORE THEN ONE CATALOG CAN BE\n*              PRODUCED.\n*                THERE ARE TWO OPERATING MODES:\n*                COPY  - ONLY THE MASTER CATALOG DEFINED BY THE\n*                        KEEP CARD IS PRODUCED.\n*                SPLIT - THE CATALOGS DEFINED BY THE SPLIT CARDS\n*                        ARE PRODUCED.\n*\n*---------------------------------------------------------------------*\nCOPYCAT  CSECT\n         SAVE  (14,12),,*\n         LA    R12,2048\n         LA    R11,2048(R12,R15)\n         LA    R12,2048(R12,R11)\n         LR    R10,R15\n         USING COPYCAT,R10,R11,R12\n         LA    R15,SAVEAREA\n         ST    R13,SAVEAREA+4\n         ST    R15,8(R13)\n         LR    R13,R15\n         STAE  STAEEXIT,CT\n         LA    R15,SETXX           DUMP PHONE NUMBER             F00003\n         BAL   R9,SETXX\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n         MVC   PRNTLINE+30-L'TITLE1/2(L'TITLE1),TITLE1\n         BAL   R9,PUTSP\n         MVI   PRNTLINE,C'0'\n         MVC   PRNTLINE+30-L'TITLE2/2(L'TITLE2),TITLE2\n         BAL   R9,PUTSP\n         MVI   PRNTLINE,C'0'       SET FOR 2 SPACES\n         MVC   PRNTLINE+30-L'TITLE3/2(L'TITLE3),TITLE3\n         BAL   R9,PUTSP\n         MVI   PRNTLINE,C'-'\n*---------------------------------------------------------------------*\n*              GET THE CONTROL RECORD\n*---------------------------------------------------------------------*\n         BAL   R9,GETCARD          GET CONTROL CARD\n         CLC   OPER,=CL8'CONTROL'  CONTROL?\n         BC    NE,ERROROP          NO,ERROR\n         LA    R1,9                SET LENGTH\n         BAL   R9,SCANOPER\n         CLC   OPER(9),=CL9'SECONDARY'\n         BC    EQ,CON005\n         CLC   OPER,=CL8'MASTER'\n         BC    NE,ERROR\n         OI    FLAG,COPY           SET COPY OPERATION\nCON005   BAL   R9,SCANOPR8         GET NEXT OPERAND\n         BC    ZERO,CON010         NONE,BRANCH\n         CLC   OPER,=CL8'GDGMOVE'\n         BC    NE,CON008           NO,BRANCH\n         OI    FLAG,GDSMOVE        SET MOVE\n         B     CON010\nCON008   CLC   OPER,=CL8'GDGCOPY'\n         BC    NE,ERROR\n         OI    FLAG,GDSCOPY        SET COPY ONLY\nCON010   BAL   R9,SCANOPR8         GET DATA SET OPERAND\n         BC    ZERO,CON014         NULL,BRANCH\n         CLC   OPER,=CL8'KEEP'\n         BC    NE,CON012           NO,BRACNH\n         OI    FLAG,DSKEEP         SET KEEP FLAG\n         B     CON015\nCON012   CLC   OPER,=CL8'SPLIT'\n         BC    EQ,CON014           YES,BRANCH\n         CLC   OPER,=CL8'UNCATLG'\n         BC    EQ,CON015           YES,BRANCH\n         BC    NE,ERROR            NO,ERROR\nCON014   OI    FLAG,DSSPLIT        SPLIT THEM\n*---------------------------------------------------------------------*\n*              READ INPUT LIST CARDS\n*---------------------------------------------------------------------*\nCON015   BAL   R9,GETCARD          READ INPUT CARD\n         CLC   OPER,=CL8'INPUT'\n         BC    NE,CON018           NO,BRANCH\n         GETMAIN R,LV=INSIZE,SP=2\n         LR    R3,R1\n         USING INLIST,R3\n         MVC   INDCB(INDCBE-INLIST),PATDCB MOVE PATTERN DCB      EXCP01\n         L     R1,INDCBA\n         CLI   INDCBA,31*8         TO MANY?\n         BC    LT,CON016           NO,BRANCH\n         MVC   PRNTLINE+2(L'ERRMSG6),ERRMSG6\n         BAL   R9,PUTSP\n         CLI   RETCODE+1,8\n         BC    GE,TERM\n         MVI   RETCODE+1,8\n         B     TERM\nCON016   ST    R3,0(R1)            SAVE ADDRESS\n         OI    0(R1),X'80'\n         SL    R1,=F'4'\n         NI    0(R1),FF-X'80'      CLEAR LAST EOF BIT\n         MVC   ININDEX,INDCBA      MOVE INDEX\n         AL    R1,=X'08000008'     INC INDEX AND ADDRESS\n         ST    R1,INDCBA           SAVE\n         LA    R2,DCBDDNAM-IHADCB+INLIST POINT AT DDNAME SPOT\n         BAL   R9,SCAN8            GO FIND DDNAME OPERAND\n         BC    ZERO,ERROR          NONE,ERROR\n         LA    R2,INVOL            POINT AT SPOT FOR VOL NAME\n         BAL   R9,SCAN6            GO FIND VOLID OPERAND\n         BC    ZERO,ERROR          NONE,ERROR\n         LR    R8,R3               POINT AT DCB                  EXCP01\n         BAL   R9,CON045B          GO GET RECS/TRACK             EXCP01\n         USING IHADCB,R3\n         OPEN  ((R3))              OPEN IT\n         TM    DCBOFLGS,X'10'      OPEN?\n         BC    ALLOFF,DCBERR       NO,BRANCH\n         B     CON015              GO LOOK FOR MORE\nCON018   CLC   INTAB+1(3),=XL3'00'  ANY?\n         BC    NE,CON022           YES,BRANCH\n         MVC   PRNTLINE+2(L'ERRMSG8),ERRMSG8\n         BAL   R9,PUTSP\n         CLI   RETCODE+1,8\n         BC    GE,TERM\n         MVI   RETCODE+1,8\n         B     TERM\n*---------------------------------------------------------------------*\n*-             READ  VOLLIST  ENTRIES.THE MUST BE IN ORDER\n*---------------------------------------------------------------------*\nCON020   BAL   R9,GETCARD          GET VOLLIST CARD\nCON022   CLC   OPER,=CL8'OUTPUT'\n         BC    NE,ERROROP          NO,ERROR\n         LA    R1,9\n         BAL   R9,SCANOPER         GET NEXT OPERAND\n         GETMAIN R,LV=VOLLSIZE,SP=2  GET A VOLLIST AREA\n         LR    R8,R1\n         USING VOLLIST,R8\n         XC    VOLLIST(256),VOLLIST\n         XC    VOLLIST+256(256),VOLLIST+256\n         XC    VOLLIST+512(VOLLSIZE-512),VOLLIST+512\n         MVC   VOLLDCB(VOLLDCBE-VOLLDCB),PATDCB MOVE DCBS\n         ST    R8,VOLLRNXT         POINT AT SELF\n         LA    R1,VOLLJFCB\n         ST    R1,VOLLEXLT         SAVE JFCB ADDRESS\n         MVI   VOLLEXLT,X'87'      SET JFCB EXIT AND END\n         CLC   OPER(9),=CL9'SECONDARY' SPLIT CARD?\n         BC    EQ,CON030           YES BR\n         CLC   OPER,=CL8'MASTER' KEEP CARD?\n         BC    NE,ERROR            NO,ERROR ON OPERATION\n         OI    VOLLFLAG,VOLLKEEP   SET KEEP THIS ENTRY\nCON030   LA    R3,VOLLDCB\n         LA    R1,VOLLEXLT         POINT AT EXIT LIST\n         O     R1,DCBRECFM         ADD RECFM TO HIGH BYTE\n         ST    R1,DCBEXLST         SAVE IN DCB\n         LA    R2,DCBDDNAM         POINT AT DDNAME SPOT\n         BAL   R9,SCAN8            GO FIND DDNAME OPERAND\n         BC    ZERO,ERROR          NULL,ERROR\n         LA    R2,VOLLVOL          SPOT FOR VOLID\n         BAL   R9,SCAN6            GO FIND VOLID OPERAND\n         BC    ZERO,ERROR          NONE,BRANCH\n         BAL   R9,SCANOPR8         FIND MAX NAME FOR THIS CARD\n         BC    NZERO,CON040        NAME FOUND,BRANCH\n         MVC   OPER,=XL8'FFFFFFFFFFFFFFFF' SET FOR MAX\nCON040   CLC   OPER,VOLNAMEL       IS THIS NAME GREATER THEN LAST?\n         BC    LE,ERROR            NO,BR\n         L     R1,VOLLAST          LOAD LAST ENTRY\n         LTR   R1,R1               ANY\n         BC    NZERO,CON045        YES,BRANCH\n         LA    R1,VOLCHAIN-VOLLNEXT+VOLLIST SET R1 FOR STORE\nCON045   ST    R8,VOLLNEXT-VOLLIST(R1)  CHAIN IN\n         ST    R8,VOLLAST\n         MVC   VOLLNAME,OPER       MOVE MAX NAME SO FAR\n         MVC   VOLNAMEL,OPER       SET LAST NAME SO FAR\n         LA    R9,CON045I          SET RETURN FOR FOLLOWING      EXCP01\nCON045B  EQU   *                                                 EXCP01\n         DEVTYPE DCBDDNAM,VOLLDEVT,DEVTAB\n         LTR   R15,R15             OK?\n         BC    NZERO,DCBERR        NO,BR\n         CLI   VOLLDEVT+2,X'20'    DASDI?\n         BC    NE,DCBERR           NO,BRANCH\n         LA    R15,264             DATA+KEY LENGTH\n         MH    R15,VOLLTOLF        *TOLDRANGE *2**9\n         SRA   R15,9               / 2**9\n         SR    R1,R1\n         SR    R0,R0\n         SR    R14,R14\n         IC    R14,VOLLBOH         OVER HEAD PER BLOCK\n         IC    R1,VOLLBOHL         OVER HEAD LAST BLOCK\n         TM    VOLLDFLG,VOLLBOHH   HALF WORD OVERHEAD?           F00003\n         BC    ALLOFF,CON045A      NO,BRANCH                     F00003\n         LH    R14,VOLLBOH         LOAD BLOCK OVER HEAD          F00003\n         LR    R1,R14              LOAD LAST BLOCK OVER HEAD     F00003\nCON045A  EQU   *                                                 F00003\n         AR    R1,R15              TOTAL LENGTH FOR LAST BLOCK\n         AR    R14,R15             TOTAL LENGTH FOR OTHER BLOCKS\n         SH    R1,VOLLTRKL        -TRK SIZE = - SIZE LEFT\n         LCR   R1,R1               COMPLEMENT\n         DR    R0,R14              =#OF BLOCKS -1\n         LA    R1,1(R1)            +1 FOR LAST\n         STH   R1,VOLLMBLK         # OF RECORDS / TRK MAX\n         CH    R1,MAXRECTK         THIS THE BIGGEST?             EXCP01\n         BC    LE,CON045E          NO,BRANCH                     EXCP01\n         STH   R1,MAXRECTK         SAVE MAX REC/TRK              EXCP01\nCON045E  BR    R9                  RETURN                        EXCP01\nCON045I  EQU   *                   RETURN FOR INLINE             EXCP01\n         MVI   VOLLTTR+2,X'01'     SET NEXT TO 001\n         TM    FLAG,COPY           COPY?\n         BC    ALLON,CON050        YES,BRANCH\n         TM    VOLLFLAG,VOLLKEEP   SHOULD WE OPEN DCB?\n         BC    ALLON,CON070        NO,BR\n         L     R1,VOLCHAIN\nCON046   CR    R1,R8               OURS?\n         BC    EQ,CON060           YES,BRANCH\n         TM    VOLLFLAG-VOLLIST(R1),VOLLKEEP KEEP?\n         BC    ALLOFF,CON048       NO,BRANCH\nCON047   L     R1,VOLLNEXT-VOLLIST(R1)\n         B     CON046              GO LOOK AT NEXT\nCON048   CLC   VOLLVOL,VOLLVOL-VOLLIST(R1) SAME?\n         BC    NE,CON047           NO,LOOK AGAIN\n         ST    R1,VOLLRNXT         YES,POINT AT IT\n         B     CON070              DONT OPEN\nCON050   TM    VOLLFLAG,VOLLKEEP   IS THIS THE KEEP ENTRY?\n         BC    ALLOFF,CON070       NO,GET NEXT\n         OC    VOLKEEP,VOLKEEP     FIRST KEEP?\n         BC    ZERO,CON055         YES,OPEN IT\n         MVC   VOLLRNXT,VOLLKEEP   POINT AT REAL ONE\n         B     CON070              GET NEXT CARD\nCON055   ST    R8,VOLKEEP          SAVE ADDRESS OF FIRST KEEP\nCON060   RDJFCB ((3))              READ JFCB\n         OI    VOLLJFCB+52,X'02'   DONT MERGE\n         OPEN  ((3),(OUTPUT)),TYPE=J\n         TM    DCBOFLGS,X'10'      OPEN?\n         BC    ALLOFF,DCBERR\n         LA    R1,1                                              EXCP01\n         AH    R1,MINBUFFS         ADD 1 TO COUNT OF MIN BUFS    EXCP01\n         STH   R1,MINBUFFS         SAVE                          EXCP01\nCON070   CLI   VOLLNAME,X'FF'      LAST?\n         BC    NE,CON020           NO,GO GET NEXT\n         TM    FLAG,COPY           COPY OPERATION?\n         BC    ALLOFF,CON078       NO,BRANCH\n         OC    VOLKEEP,VOLKEEP     KEEP FOUND?\n         MVC   VOLLAST,VOLKEEP\n         BC    NZERO,CON078        YES,BRANCH\n         MVC   PRNTLINE+2(L'ERRMSG14),ERRMSG14\n         BAL   R9,PUTSP\n         CLI   RETCODE+1,8\n         BC    GE,TERM\n         MVI   RETCODE+1,8\n         B     TERM\nCON078   EQU   *\n*---------------------------------------------------------------------*\n*              FINC CVOL ENTRIES (IF ANY)\n*---------------------------------------------------------------------*\n         SR    R3,R3\nCON080   BAL   R9,GETCARD          GET CVOL CARD\n         CLC   OPER,=CL8'CVOL'     CVOL CARD?\n         BC    NE,CON120           MVST BE END\n         BAL   R9,SCANOPR6         GO FIND VOL\n         LTR   R3,R3               ANY CVNEW S SO PAR?\n         BC    NZERO,CON090        YES,BRANCH\n         CLI   OPER,C' '           ANY?\n         BC    EQ,ERROR            NO,BRANCH\n         GETMAIN R,LV=CVOLDSIZ,SP=2  GET OLD ENTRY\n         USING CVOLD,R1\n         MVC   CVOLDNXT,CVOLCHAN   CHAIN IN\n         ST    R1,CVOLCHAN         CHAIN IN\n         MVC   CVOLDNAM,OPER       MOVE OLD CVOL NAME\n         XC    CVOLDDUM,CVOLDDUM   CLEAR\n         LR    R3,R1               SET SO CVNEW S ARE CHAINED IN\n         DROP  R1\n         USING CVNEW,R3\nCON090   GETMAIN R,LV=CVNEWSIZ,SP=2\n         LR    R4,R1               SAVE\n         LA    R2,CVNEWNAM-CVNEW(R4) SPOT FOR NAME\n         BAL   R9,SCAN6            GO FIND NEW NAME\n         BC    ZERO,ERROR          NULL,ERROR\n         BAL   R9,SCANOPR8         FIND MAX NAME OPERAND\n         BC    NZERO,CON100        FOUND,BRANCH\n         MVC   OPER,=XL8'FFFFFFFFFFFFFFFF' SET MAX\nCON100   CLC   CVNEWDSN,OPER       GT THEN LAST\n         BC    GE,ERROR            NO,ERROR\n         ST    R4,CVNEWNXT         CHAIN IN (MAY BE CVOLDCHAN)\n         LR    R3,R4\n         XC    CVNEWNXT,CVNEWNXT   CLEAR CHAIN\n         MVC   CVNEWDSN,OPER       MOVE HIGH NAME\n         BAL   R9,SCANOPR8         IFND DD NAME FOR DEVICE TYPE\n         BC    ZERO,ERROR          NULL,ERROR\n         DEVTYPE OPER,WORKAREA\n         MVC   CVNEWDEV,WORKAREA\n         LTR   R15,R15             OK?\n         BC    NE,DCBERRO          NO,BRANCH\n         CLI   CVNEWDSN,X'FF'      LAST?\n         BC    NE,CON080           NO,GO GET NEXT\n         SR    R3,R3               SET CVOL DONE\n         B     CON080\nCON120   LTR   R3,R3               CVOL COMPLETE?\n         BC    NZERO,ERROROP       NO,ERROR\n         B     CON210              CARD MUST BE LEVEL CARD\n*---------------------------------------------------------------------*\n*              GET THE LEVTAB ENTRIES\n*---------------------------------------------------------------------*\nCON200   BAL   R9,GETCARD          GET LEVEL CARD\nCON210   CLC   OPER,=CL8'LEVEL'\n         BC    NE,ERROROP          NOT LEVEL ERROR\n         BAL   R9,SCANOPR8         GET FIRST OPERAND\n         BAL   R9,CONV3            CONVERT TO BIN\n         CH    R1,=H'0'\n         BC    LE,ERROR\n         CH    R1,=H'22'\n         BC    GT,ERROR\n         MH    R1,=AL2(LEVTABL)\n         LA    R7,LEVTAB-LEVTABL(R1) POINT AT ENTRY\n         USING LEVTABE,R7\n         BAL   R9,SCANOPR8         BYTES TO LEAVE IN EACH BLOCK\n         BAL   R9,CONV3\n         CH    R1,=H'200'\n         BC    GT,ERROR\n         STH   R1,LEVBYTES         SAVE BYTES TO LEAVE ON A BLOCK\n         BAL   R9,SCANOPR8         GET BLOCKS TO LEAVE AT END\n         BAL   R9,CONV3\n         STH   R1,LEVBLOCK         SAVE BLOCKS +0 LEAVE AT END OF INDEX\n         BAL   R9,SCANOPR8         GET BLOCKS THAT MUST BE ON A TRK\n         BAL   R9,CONV3\n         STH   R1,LEVBLONT     SAVE BLOCKS THAT MUST BE ON TRK\n         B     CON200\n*---------------------------------------------------------------------*\n*              END OF FILE ON SYSIN\n*---------------------------------------------------------------------*\nEOFIN    CLI   VOLLNAME,X'FF'      WAS LAST VOLLIST CARD READ?\n         BC    NE,EOFINE           NO,ERROR\n         LTR   R3,R3               CVOLS READ OK?\n         BC    NZERO,EOFINE        NO,ERROR,BRANCH               EXCP01\n*----------------------------------------------------------------EXCP01\n*              BUILD CCWS                                        EXCP01\n*----------------------------------------------------------------EXCP01\n         LA    R6,=AL2(RDCCWE-RDCCW,RDCCW-RDCCWS) SIZES          EXCP01\n         LA    R5,ECBLISTR         FIRST WRDSECT                 EXCP01\nINE010   L     R4,0(R5)                                          EXCP01\n         USING WRDSECT,R4                                        EXCP01\n         LH    R0,MAXRECTK         MAX REC/TRACK                 EXCP01\n         MH    R0,0(R6)            SIZE OF CCW                   EXCP01\n         AH    R0,2(R6)            +FIXED SIZE                   EXCP01\n         GETMAIN R,LV=(0)          GET CCW AREA                  EXCP01\n         ST    R1,IOBSTART         SAVE IN IOB                   EXCP01\n         XC    0(16,R1),0(R1)      CLEAR FIRST 2 CCWS            EXCP01\n         ST    R1,8(R1) SAVE IN TIC                              EXCP01\n         LA    R7,IOBMBBCC+3       CCHH ADDR                     EXCP01\n         ST    R7,0(R1)            SAVE IN CCW                   EXCP01\n         OC    0(9,R1),=X'310000004000000508'  SEARCH AND TIC    EXCP01\n         LA    R1,16(R1)           POINT AT VARIABLE SEC         EXCP01\n         LA    R8,1                                              EXCP01\n         LH    R0,MAXRECTK                                       EXCP01\n         C     R4,ECBLISTR         READ PASS?                    EXCP01\n         BC    NE,INE040           NO,BRANCH                     EXCP01\nINE030   MVC   0(8,R1),=X'0E00000000000108' READ KEY+DATA,264    EXCP01\n         LA    R1,8(R1)            NEXT CCW                      EXCP01\n         BCT   R0,INE030           LOOP FOR ALL CCWS             EXCP01\n         B     INE060                                            EXCP01\nINE040   XC    0(32,R1),0(R1)      CLEAR CCWS                    EXCP01\n         LA    R15,16(R1)          COUNT FIELD                   EXCP01\n         ST    R15,0(R1)           SAVE IN CCW                   EXCP01\n         LA    R15,24(R1)          WTRCCWD                       EXCP01\n         ST    R15,8(R1)           SAVE IN TIC                   EXCP01\n         STC   R8,20(R1)           SAVE REC NUMBER               EXCP01\n         OC    0(32,R1),PATCCW     COMPLETE CCWS                 EXCP01\n         LA    R1,32(R1)           NEXT CCW SET                  EXCP01\n         LA    R8,1(R8)            REC NUM                       EXCP01\n         BCT   R0,INE040                                         EXCP01\nINE060   LA    R6,=AL2(WTRCCWE-WTRCCW,WTRCCW-WTRCCWS)            EXCP01\n         LTR   R4,R4               LAST?                         EXCP01\n         LA    R5,4(R5)                                          EXCP01\n         BC    PLUS,INE010         NO,BRANCH                     EXCP01\n*----------------------------------------------------------------EXCP01\n*              GET BUFFERS                                       EXCP01\n*----------------------------------------------------------------EXCP01\n         L     R0,MINCORE          LOAD REQUIRED CORE            EXCP01\n         GETMAIN R,LV=(0)                                        EXCP01\n         LR    R2,R1               SAVE FOR LATER                EXCP01\n         LA    R3,RBUFSIZE         SIZE OF REC AREA              EXCP01\n         MH    R3,MAXRECTK         *NUMBER                       EXCP01\n         LA    R3,BUFSIZE(R3)      +FIXED=BUFFER SIZE            EXCP01\n         GETMAIN VC,LA=GETMLA,A=GETMA GET THE BUFFERS            EXCP01\n         L     R0,MINCORE                                        EXCP01\n         FREEMAIN R,LV=(0),A=(2)   FREE MIN FREE CORE            EXCP01\n         LM    R14,R15,GETMA                                     EXCP01\n         SRL   R15,3               /8                            EXCP01\n         SR    R0,R0                                             EXCP01\n         SR    R1,R1                                             EXCP01\nINE070   STM   R0,R1,0(R14)        ZERO                          EXCP01\n         LA    R14,8(R14)                                        EXCP01\n         BCT   R15,INE070                                        EXCP01\n         L     R1,GETMS            SIZE GOTTEN                   EXCP01\n         SR    R0,R0                                             EXCP01\n         DR    R0,R3               /SIZE OF BUF=#OF BUFFS        EXCP01\n         CH    R1,MINBUFFS         MIN # OF BUFFS                EXCP01\n         BC    LT,INE200           NO,ERROR                      EXCP01\n         LA    R5,FREEBUFQ                                       EXCP01\n         L     R6,GETMA            POINT AT BUFFER AREA          EXCP01\nINE080   ST    R6,0(R5)            SAVE CHAIN ADDR               EXCP01\n         LR    R5,R6                                             EXCP01\n         AR    R6,R3               NEXT BUFFER                   EXCP01\n         BCT   R1,INE080           LOOP FOR ALL                  EXCP01\n         XC    0(4,R5),0(R5)       CLEAR LAST                    EXCP01\n         B     MAIN010                                           EXCP01\nINE200   MVC   PRNTLINE+2(L'ERRMSG15),ERRMSG15                   EXCP01\n         BAL   R9,PUTSP                                          EXCP01\n         B     EOF010                                            EXCP01\nEOFINE   MVC   PRNTLINE+2(L'ERRMSG3),ERRMSG3\n         BAL   R9,PUTSP\nEOF010   EQU   *                                                 EXCP01\n         CLI   RETCODE+1,8\n         BC    GE,TERM\n         MVI   RETCODE+1,8\n         B     TERM\n*\nCONV3    SR    R1,R1\n         LTR   R15,R0              LOAD LENGTH\n         BCR   ZERO,R9             NULL,RETURN ZERO\n         BCTR  R15,0               -1\n         XC    WORKAREA,WORKAREA\n         EX    R15,CONVMVZ         MOVE ZONES\n         EX    R15,CONVCLC         CHECH FOR NUMERIC\n         BC    NE,ERROR\n         EX    R15,CONVPCK         PACK NUMBER\n         CVB   R1,WORKAREA         CONVERT TO BIN\n         BR    R9                  RETURN\nCONVMVZ  MVZ   WORKAREA(0),OPER\nCONVCLC  CLC   WORKAREA(0),=CL8'00000000'\nCONVPCK  PACK  WORKAREA,OPER(0)\n*---------------------------------------------------------------------*\n*              EVERYTHING OR, START\n*---------------------------------------------------------------------*\nMAIN010  LA    R1,MAINTTR          POINT AT TTR\n         LH    R0,=H'1'            SET FOR LEVEL 1\n         LA    R15,RR\n         BALR  R14,R15             GO COPY CATALOG\n         MVC   PRNTLINE(L'HEAD1),HEAD1\n         BAL   R9,PUTSP\n         MVC   PRNTLINE(L'HEAD2),HEAD2\n         BAL   R9,PUTSP\n         MVC   PRNTLINE(L'HEAD3),HEAD3\n          BAL   R9,PUTSP\n         MVC   PRNTLINE(L'HEAD4),HEAD4\n         BAL   R9,PUTSP\n         MVI   PRNTLINE,C'0'\n         LA    R7,LEVTAB           POINT AT LEVEL TABLE\n         TM    FLAG,COPY           COPY?\n         MVC   LEVBLONT,=H'999'    SET SO PUTC WILL FILL TRK\n         L     R8,VOLCHAIN\n         BC    ALLOFF,MAIN050      NO,BRANCH\n         L     R8,VOLLAST          POINT AT LAST\nMAIN015  LA    R1,VOLLTTR          LOAD LAST USED TTR+1\n         LA    R2,PRNTLINE+16      POINT AT SPOT IN LINE\n         BAL   R9,CONVTTR          GO FORMAT\nMAIN020  TM    VOLLFLAG,VOLLSECN   AT END OF EXTENT?\n         BC    ALLON,MAIN030\n         LH    R1,=H'-1'           SET TO FILL TRK\n         LA    R15,PUTC\n         BALR  R14,R15\n         B     MAIN020\nMAIN030  LA    R1,MAINTTR\n         LA    R3,VOLLDCB                                        EXCP01\n         LA    R2,VOLLIKEY\n         AL    R2,=X'80000000'     RETAIN                        EXCP01\n         LA    R15,READC\n         BALR  R14,R15             READ IN VICE\n         LA    R5,VOLLIBUF+2\n         USING CATENTRY,R5\n         MVC   CVICFRST,VOLLFRST   SET FIRST AVAILABLE TTR\n         LH    R0,VOLLTTR          POINT AT NEXT TTR\n         SH    R0,=H'1'            -1 FOR PREVIOUS TRK\n         STH   R0,CVICUP           SAVE TT\n         MVC   CVICUP+2(1),VOLLMBLK+1 SET R TO LAST ON TRK\n         LA    R1,MAINTTR\n         LA    R2,VOLLIKEY\n         AL    R2,=X'80000000'     RETAIN                        EXCP01\n         LA    R15,WRITEC\n         BALR  R14,R15             WRITE VICE BACK\n*---------------------------------------------------------------------*\n*              HANDLE ALIAS ENTRIES FOR THIS VOLUME\n*---------------------------------------------------------------------*\n         L     R4,VOLALCHN\n         USING ALENTRY,R4\nALE010   LTR   R4,R4               ANY?\n         BC    ZERO,ALE050         NO,BRANCH\n         L     R6,VOLANCHN         POINT AT REAL NAME CHAIN\n         USING ANENTRY,R6\nALE020   LTR   R6,R6               ANY?\n         BC    ZERO,ALE040         NO,ERROR\n         CLC   ALRNAME,ANNAME      IS THIS ALIAS FOR THIS NAME?\n         BC    EQ,ALE030           YES,GO CHANGE\n         L     R6,ANNEXT           LOOK AT NEXT\n         B     ALE020\nALE030   LA    R2,VOLLIKEY         POINT AT KEY AND BUFFER\n         AL    R2,=X'80000000'     RETAIN                        EXCP01\n         LA    R1,ALTTR            POINT AT TTR\n         LA    R15,READC\n         BALR  R14,R15             READ BLOCK WITH ALIAS\n         LH    R5,ALOFF            LOAD OFFSET TO ALIAS ENTRY\n         LA    R5,VOLLIBUF(R5)     POINT AT ENTRY\n         MVC   CATTTR,ANTTR        MOVE TTR\n         LA    R15,WRITEC\n         BALR  R14,R15             WRITE BACK THE BLOCK\n         LH    R0,ANCOUNT          LOAD COUNT\n         SH    R0,=H'1'            -1\n         STH   R0,ANCOUNT          SAVE COUNT\nALE035   L     R4,ALNEXT           LOOK AT NEXT ALIAS\n         B     ALE010\nALE040   MVC   PRNTLINE+2(L'ERRMSG4),ERRMSG4\n         MVC   PRNTLINE+13(8),ALRNAME\n         MVC   PRNTLINE+42(8),ALNAME\n         BAL   R9,PUTSP\n         CLI   RETCODE+1,12\n         BC    GE,ALE035\n         MVI   RETCODE+1,12\n         B     ALE035\nALE050   L     R6,VOLANCHN         LOOK AT REAL NAMES\nALE052   LTR   R6,R6               ANY?\n         BC    ZERO,ALE070         NO,BRANCH\n         CH    R4,ANCOUNT          ALL ALIASES FOUND?\n         BC    EQ,ALE060           YES,BRANCH\n         MVC   PRNTLINE+2(L'ERRMSG5),ERRMSG5\n         MVC   PRNTLINE+41(8),ANNAME MOVE NAME\n         BAL   R9,PUTSP\n         CLI   RETCODE+1,12\n         BC    GE,ALE060\n         MVI   RETCODE+1,12\nALE060   L     R6,ANNEXT           LOOK AT NEXT NAME\n         B     ALE052\n         DROP  R4,R6\nALE070   EQU   *\n         MVC   PRNTLINE+2(6),VOLLVOL\n         LA    R1,VOLLTTR\n         LA    R2,PRNTLINE+9\n         BAL   R9,CONVTTR          GO CONVERT TTR FOR OUTPUT\n         LH    R1,VOLLICVL\n         LA    R2,PRNTLINE+23\n         BAL   R9,CONVDEC\n         LH    R1,VOLLIDUM\n         LA    R2,PRNTLINE+31\n         BAL   R9,CONVDEC\n         LH    R1,VOLLI1\n         LA    R2,PRNTLINE+39\n         BAL   R9,CONVDEC\n         LH    R1,VOLLI2\n         LA    R2,PRNTLINE+47\n         BAL   R9,CONVDEC\n         L     R1,VOLLDS\n         LA    R2,PRNTLINE+55\n         BAL   R9,CONVDEC\n         BAL   R9,PUTSP            GO PRINT LINE\n         MVI   VOLLDCB+DCBFDAD+7-IHADCB,X'FF' SET CATLOG FORMATED\n         TM    FLAG,COPY           COPY OPERATION?\n         BC    ALLON,MAIN060\nMAIN040  L     R8,VOLLNEXT         LOOK AT NEXT VOLLIST\n         LTR   R8,R8               ANY MORE?\n         BC    ZERO,MAIN060        NO,BRANCH\nMAIN050  TM    VOLLFLAG,VOLLKEEP   KEEP OR SPLIT?\n         BC    ALLON,MAIN040       KEEP,BRANCH\n         C     R8,VOLLRNXT         REAL VOLLIST?\n         BC    NE,MAIN040          NO,BRANCH LOOK AT NEXT\n         B     MAIN015             GO PROCESS THIS VOL\n*---------------------------------------------------------------------*\n         USING IHADCB,R3\nTERM     EQU   *\nMAIN060  LA    R2,PRNTLINE+16\n         L     R5,USEBUFQ                                        EXCP01\n         B     TERM003                                           EXCP01\n         USING BUFFER,R6                                         EXCP01\nTERM001  TM    BUFFLAG,BUFWTR      WRITE THIS BUFFER?            EXCP01\n         L     R5,BUFNEXT          POINT AT NEXT                 EXCP01\n         BC    ALLOFF,TERM002      NO,BRANCH                     EXCP01\n         MVC   BUFNEXT,OUTBUFQ     QUEUE IT                      EXCP01\n         ST    R6,OUTBUFQ          CHAIN IN AS FIRST             EXCP01\n         B     TERM003                                           EXCP01\nTERM002  MVC   BUFNEXT,FREEBUFQ                                  EXCP01\n         ST    R6,FREEBUFQ         CHAIN IN AS FREE              EXCP01\nTERM003  LTR   R6,R5               ANY MORE?                     EXCP01\n         BC    NZERO,TERM001       YES,LOOK AT THEM              EXCP01\nTERM004  LA    R15,WRITEB          FINISH WRITES                 EXCP01\n         BALR  R14,R15                                           EXCP01\n         LA    R5,ECBLISTW         POINT AT LIST OF ECB          EXCP01\nTERM005  L     R4,0(R5)                                          EXCP01\n         USING WRDSECT,R4                                        EXCP01\n         OC    WRBUF,WRBUF         ACTIVE?                       EXCP01\n         BC    NZERO,TERM006       YES,GO WAIT                   EXCP01\n         LTR   R4,R4               ANOTHER?                      EXCP01\n         LA    R5,4(R5)            NEXT ECB ADDR                 EXCP01\n         BC    PLUS,TERM005        GO LOOK AT IT                 EXCP01\n         B     TERM007                                           EXCP01\nTERM006  WAIT  ECBLIST=ECBLISTW    WAIT FOR WRITES               EXCP01\n         B     TERM004                                           EXCP01\nTERM007  EQU   *                                                 EXCP01\n         LH    R1,RETCODE          LOAD RETURN CODE\n         BAL   R9,CONVDEC\n         MVC   PRNTLINE(L'MSGOK),MSGOK\n         BAL   R9,PUTSP\n         CLOSE (SYSIN,,SYSPRINT)\n         OC    INTAB,INTAB         ANY?\n         BC    ZERO,TERM010        NO,BRANCH\n         CLOSE MF=(E,INTAB)        CLOSE OPEN INPUTS\nTERM010  L     R8,VOLCHAIN\nTERM015  LTR   R8,R8               ANY?\n         BC    ZERO,TERM030        NO,BRANCH\n         LA    R3,VOLLDCB\n         TM    DCBOFLGS,X'10'      OPEN?\n         BC    ALLOFF,TERM020      NO,BRANCH\n         CLOSE ((R3))                                            EXCP01\nTERM020  L     R8,VOLLNEXT\n         B     TERM015\nTERM030  FREEMAIN R,SP=2           FREE ALL OF SUBPOOL2\n         L     R13,SAVEAREA+4\n         LH    R15,RETCODE         LOAD RETURN CODE\n         RETURN (14,12),T,RC=(15)\n         EJECT\nERROROP  L     R15,SCANOP          LOAD SCAN POINTER\n         B     ERROR1\nERROR    L     R15,SCANREG2        POINT AT CHAR IN ERROR\nERROR1   S     R15,SCANSTRT        - START OF CARD\n         LA    R0,C'$'\n         STC   R0,PRNTLINE+10(R15) SET $ UNDER COL IN ERROR\n         BAL   R9,PUTSP\n         MVC   PRNTLINE+2(L'ERRMSG1),ERRMSG1\n         BAL   R9,PUTSP\n         CLI   RETCODE+1,8\n         BC    GE,TERM\n         MVI   RETCODE+1,8\n         B     TERM                GO TERMINATE\n         SPACE 3\nDCBERRO  LA    R3,OPER-DCBDDNAM+IHADCB\nDCBERR   MVC   ERRMSG2+31(8),DCBDDNAM   SET DDNAME\n         MVC   PRNTLINE+2(L'ERRMSG2),ERRMSG2\n         BAL   R9,PUTSP\n         CLI   RETCODE+1,8\n         BC    GE,TERM\n         MVI   RETCODE+1,8\n         B     TERM                TERMINATE\n         SPACE 3\nCONVTTR  ZAP   WORKAREA,=P'0'\n         MVC   WORKAREA+4(3),0(R1) MOVE TTR\n         UNPK  0(7,R2),WORKAREA+4(4)\n         TR    0(6,R2),TRTAB-240\n         MVI   6(R2),C' '\n         BR    R9\nTRTAB    DC    C'0123456789ABCDEF'\n         SPACE 3\nCONVDEC  CVD   R1,WORKAREA\n         UNPK  0(7,R2),WORKAREA\n         OI    6(R2),C'0'\n         BR    R9\n         EJECT\nPUTSP    PUT   SYSPRINT,PRNTLINE\n         MVI   PRNTLINE,C' '\n         MVC   PRNTLINE+1(120),PRNTLINE\n         BR    R9\n         EJECT\n*---------------------------------------------------------------------*\n*              GET CARD READS A CARD AND FINDS THE OPERATOR\n*              AND SAVES IT IN OPER\n*---------------------------------------------------------------------*\nGETCARD  GET   SYSIN\n         LR    R2,R1               POINT AT CARD\n         LA    R1,70(R1)           END OF CARD\n         ST    R2,SCANSTRT         SAVE STATR OF CARD\n         MVC   PRNTLINE+10(80),0(R2) MOVE CARD\n         STM   R1,R2,SCANREG1      SAVE\n         LR    R2,R9               SAVE R9\n         BAL   R9,PUTSP            PRINT CARD\n         LR    R9,R2               RESTORE R9\n         LM    R0,R2,SCANREG0      LOAD BXLE REGS\n         CLI   0(R2),C'*'          COMMENT?\n         BC    EQ,GETCARD          YES,GET NEXT CARD\nGET005   CLI   0(R2),C' '          BLANK?\n         BC    EQ,GET010           YES,BRANCH\n         BXLE  R2,R0,GET005        SKIP NAME IF ANY\n         B     GETCARD             BLANK CARD SKIP IT\nGET010   CLI   0(R2),C' '          NONE BLANK\n         BC    NE,GET020           YES,BRANCH\n         BXLE  R2,R0,GET010        LOOK FOR FIRST CHAR\n         B     SCANERR             NO NAME BRANCH\nGET020   ST    R2,SCANOP           SAVE ADDR OF FIRST OPERATOR\n         LR    R14,R2              SAVE START\n         LA    R15,8(R2)           END\n         CR    R15,R1              PASS END OF CARD?\n         BC    GT,GET030           YES,BRANCH\n         LR    R1,R15              SET END AT SHORTEST\nGET030   CLI   0(R2),C' '          BLANK?\n         BC    EQ,GET040           END\n         BXLE  R2,R0,GET030        NO,BRANCH\nGET040   LR    R15,R2              START\n         SR    R15,R14             FIND LENGRH\n         BC    ZERO,SCANERR        ERROR\n         MVC   OPER,=CL8' '\n         BCTR  R15,0               -1\n         EX    R15,MVCOPER\n         L     R1,SCANREG1         RESTORE END\nGET050   CLI   0(R2),C' '          FIND OPERAND\n         BC    NE,GET060           NO,BRANCH\n         BXLE  R2,R0,GET050\n         B     SCANERR             NO,E,BRANCH\nGET060   ST    R2,SCANREG2         SAVE FOR SCAN\n         BR    R9                  RETURN\nMVCOPER  MVC   OPER(0),0(R14)\n         EJECT\n*---------------------------------------------------------------------*\n*              SCAN - FIND NEXT OPERAND ON CARD\n*              SCAN R1=MAX LENGTH R2->SPOT FOR OPERAND R9 = RETURN\n*              CONDITION CODE OF LENGTH IS SET\n*---------------------------------------------------------------------*\nSCAN     LR    R14,R2              SAVE SPOT\n         LR    R15,R1              SAVE LENGTH\n         BCTR  R15,0\n         EX    R15,MVCBLANK        CLEAR AREA\n         LM    R0,R2,SCANREG0      LOAD BXLE REGS\n         AR    R15,R0              +1\nSCAN020  CR    R1,R2               AT END?\n         BC    LT,SCAN070          YES,BRANCH\nSCAN030  CLI   0(R2),C' '          END?\n         BC    EQ,SCAN040          YES,BRANCH\n         CLI   0(R2),C','          COMMA?\n         BC    EQ,SCAN040          YES,BRANCH\n         BXLE  R2,R0,SCAN030\nSCAN040  LR    R0,R2\n         L     R1,SCANREG2         OLD START\n         SR    R0,R1               LENGTH\n         BC    ZERO,SCAN045        ZERO BRANCH\n         CR    R0,R15              TO LONG?\n         BC    GT,SCANERR          YES,BRANCH\n         LR    R15,R0\n         BCTR  R15,0\n         EX    R15,MVCSCAN         MOVE OPERAND\nSCAN045  CLI   0(R2),C','          MORE?\n         BC    NE,SCAN050          NO,BRANCH\n         LA    R2,1(R2)            +1\nSCAN050  ST    R2,SCANREG2         SAVE START\n         LTR   R0,R0               SET CONDITION CODE\n         BR    R9                  RETURN\nSCAN070  SR    R0,R0               SET LENGTH OF ZERO\n         BR    R9                  RETURN\nMVCSCAN  MVC   0(0,R14),0(R1)      MOVE OPERANDS\nMVCBLANK MVC   0(0,R2),=CL9' '     BLANK OUT SPOT FOR OPERAND\n         SPACE 1\nSCANERR  ST    R2,SCANREG2         SAVE START\n         B     ERROR\n         SPACE 3\nSCANOPR8 LA    R1,8                SET FOR SCAN OF LENGTH OF 8\n         B     SCANOPER\nSCANOPR6 LA    R1,6\nSCANOPER LA    R2,OPER\n         B     SCAN\nSCAN8    LA    R1,8\n         B     SCAN\nSCAN6    LA    R1,6\n         B     SCAN\nSCANSTRT DS    A                   START OF CARD\nSCANREG0 DC    F'1'                BXLE INC\nSCANREG1 DS    A                   BXLE END\nSCANREG2 DS    A                   BXLE INDEX\nSCANOP   DS    A                   ADDR OF OPERATOR\nOPER     DS    CL8                 OPERAND\n         DS    C                   USED FOR 9TH CHAR\n         EJECT\n*---------------------------------------------------------------------*\n*              STAE PROCESSING\n*---------------------------------------------------------------------*\nSTAEEXIT LA    R4,12\n         CR    R0,R4               WORKAREA?\n         BC    EQ,STAE100          NO,BRANCH\n         LM    R10,R12,STAEBASE-STAEEXIT(R15) LOAD BASE REGS\n         MVC   STAEWK(2),5(R1)     MOVE ABEND CODE\n         OI    STAEWK+1,X'0F'      SET SIGN\n         UNPK  STAECD,STAEWK       CONVERT CODE\n         TR    STAECD,TRTAB-240\n         CLC   STAECD+1(2),=C'37'  EOV ERROR?\n         BC    NE,STAE020          NO,BEANCH\n         CLI   STAECD,C'D'         D37?\n         BC    EQ,STAE150          YES,BRANCH\n         CLI   STAECD,C'E'         E37?\n         BC    EQ,STAE150          YES,BRANCH\nSTAE020  CLC   STAECD,=C'213'      213?\n         BC    EQ,STAE150          YES,BRANCH\nSTAE100  SR    R15,R15             SET CONTINUE WITH ABEND\n         BR    R14                 RETURN\nSTAE150  LA    R0,STAERTRY         SET RETRY ROUTINE ADDRESS\n         LA    R15,4               SET RETRY\n         BR    R14                 RETURN\n*---------------------------------------------------------------------*\n*              STAE RETRY ROUTINE\n*---------------------------------------------------------------------*\nSTAERTRY LM    R10,R13,STAEBASE-STAERTRY(R15) SET BASE\n         L     R1,25*4(R1)         POINT AT IO RESTORE CHAIN\n         SVC   17                  RESTORE IO\n         MVC   ERRMSG12+14(3),STAECD\n         MVC   PRNTLINE+2(L'ERRMSG12),ERRMSG12\n         MVC   PRNTLINE+2+L'ERRMSG12(L'NAME),NAME\n         BAL   R9,PUTSP            PRINT ABEND MSG\n         CLI   RETCODE+1,16\n         BC    GE,TERM\n         MVI   RETCODE+1,16\n         B     TERM\nSTAEBASE DC    A(COPYCAT,COPYCAT+4096,COPYCAT+8192,SAVEAREA)\nSTAEWK   DS    H\nSTAECD   DC    CL3'   '            ABEND CODE\n         EJECT\n*---------------------------------------------------------------------*\n*              SYNAD EXITS\n*---------------------------------------------------------------------*\nSYNADEX  SYNADAF ACSMETH=EXCP                                    EXCP01\n         B     SYNAD\nSYNADPS  SYNADAF ACSMETH=QSAM\nSYNAD    MVC   PRNTLINE+2(L'ERRMSG13),ERRMSG13\n         MVC   PRNTLINE+2+L'ERRMSG13(128-68),68(R1) MOVE ERROR MSG\n         BAL   R9,PUTSP\n         MVC   PRNTLINE+2(L'ERRMSG13+L'ERRMSGD),ERRMSG13\n         MVC   PRNTLINE+2+L'ERRMSG13+L'ERRMSGD(L'NAME),NAME\n         BAL   R9,PUTSP\n         SYNADRLS\n         CLI   RETCODE+1,16\n         BC    GE,TERM\n         MVI   RETCODE+1,16        SET RETURN CODE\n         B     TERM\n         EJECT\n*---------------------------------------------------------------------*\n*              READ A BLOCK + KEY  R1=A(TTR) R3=A(DCB) R14=RETURN\n*                                  R2=AREA\n*---------------------------------------------------------------------*\nREADC    SAVE  (14,12),,*\n         LA    R14,READSAVE\n         ST   R13,READSAVE+4\n         ST    R14,8(R13)\n         LR    R13,R14\n         LA    R15,WRITEB          CHECK ANY WRITES              EXCP01\n         BALR  R14,R15                                           EXCP01\n         LA    R3,0(R3)            CLEAR BITS                    EXCP01\n         ST    R2,RDAREA           SAVE FOR LATER                EXCP01\n         LR    R7,R1               SAVE TTR ADDRESS              EXCP01\n         LH    R0,0(R7)            LOAD TT                       EXCP01\n         LA    R6,USEBUFQ          CHAIN PTR FOR USED BUFFERS    EXCP01\n         LA    R1,2                SET LOOP COUNTER              EXCP01\n         B     RD020                                             EXCP01\n         USING BUFFER,R6                                         EXCP01\nRD010    CH    R0,BUFTT            THIS TRACK?                   EXCP01\n         BC    NE,RD020            NO,BRANCH                     EXCP01\n         C     R3,BUFADCB          THIS DCB?                     EXCP01\n         BC    EQ,RD140            YES,FOUND IT                  EXCP01\nRD020    LR    R5,R6                                             EXCP01\n         L     R6,BUFNEXT                                        EXCP01\n         LTR   R6,R6               ANOTHER?                      EXCP01\n         BC    NZERO,RD010         YES,CHECK IT                  EXCP01\n         LA    R6,OUTBUFQ          NEXT QUEUE TO SEARCH          EXCP01\n         BCT   R1,RD020            GO CHECK IT                   EXCP01\n         LA    R9,ECBLISTW                                       EXCP01\nRD025    L     R4,0(R9)            POINT AT NEXT WRITE AREA      EXCP01\n         L     R6,WRBUF            POINT AT ACTIVE BUFFER        EXCP01\n         LTR   R6,R6               ANY?                          EXCP01\n         BC    ZERO,RD030          NO,BRANCH                     EXCP01\n         CH    R0,BUFTT            THIS TRACK?                   EXCP01\n         BC    NE,RD030            NO,BRANCH                     EXCP01\n         C     R3,BUFADCB          THIS DCB?                     EXCP01\n         BC    EQ,RD032            YES,THIS IS OUR BUF           EXCP01\nRD030    LA    R9,4(R9)            NEXT ECB                      EXCP01\n         LTR   R4,R4               END?                          EXCP01\n         BC    PLUS,RD025          NO,BRANCH                     EXCP01\n         B     RD035                                             EXCP01\nRD032    OI    WRBUF,X'80'         SET DO NOT FREE               EXCP01\n         WAIT  ECB=WRECB           WAIT FOR WRITE                EXCP01\n         LA    R15,WRITEB                                        EXCP01\n         BALR  R14,R15             GO AND CHECK                  EXCP01\n         B     RD145               USE THIS BUFFER               EXCP01\nRD035    EQU   *                                                 EXCP01\n*----------------------------------------------------------------EXCP01\n*              NOT FOUND IN CORE, HAVE TO READ TRACK             EXCP01\n*----------------------------------------------------------------EXCP01\n         LA    R15,GETBUF          GET A BUFFER                  EXCP01\n         BALR  R14,R15                                           EXCP01\n         LR    R6,R1               POINT AT IT                   EXCP01\n         MVC   BUFNEXT,USEBUFQ     CHAIN IN AT HEAD              EXCP01\n         ST    R6,USEBUFQ          CHAIN IN                      EXCP01\n         ST    R3,BUFADCB          SAVE DCB ADDRESS              EXCP01\n         LA    R4,RECB             POINT AT ECB,IOB ETC          EXCP01\n         USING WRDSECT,R4                                        EXCP01\n         ST    R6,WRBUF            SAVE BUF ADDR                 EXCP01\n         STH   R0,BUFTT            SAVE TT ADDRESS               EXCP01\n         SLL   R0,16                                             EXCP01\n         AL    R0,=X'00000100'     REC ONE                       EXCP01\n         L     R1,DCBDEBAD         DEB                           EXCP01\n         LA    R2,IOBMBBCC         SPOT FO R MBBCCHHR            EXCP01\n         STM   R9,R13,READSAVE+12                                EXCP01\n         L     R9,16               CVT                           EXCP01\n         L     R15,28(R9)          CVTPCNVT                      EXCP01\n         BALR  R14,R15                                           EXCP01\n         USING *,R14                                             EXCP01\n         LM    R9,R13,READSAVE+12                                EXCP01\n         DROP  R14                                               EXCP01\n         LH    R1,VOLLMBLK-VOLLIST(R3)  REC/TRK                  EXCP01\n         L     R5,IOBSTART         CCWS                          EXCP01\n         USING RDCCWS,R5                                         EXCP01\n         LA    R2,BUFEND+RBUFKEY-RBUFFER                         EXCP01\n         B     RD050                                             EXCP01\nRD040    LA    R2,RBUFEND-RBUFFER(R2) NEXT IN BUFFER             EXCP01\n         LA    R5,RDCCWE-RDCCW(R5)                               EXCP01\nRD050    ST    R2,RDCCW                                          EXCP01\n         MVI   RDCCW,X'0E'         READ KEY + DATA               EXCP01\n         OI    RDCCW+4,X'40'       COMMAND CHAIN                 EXCP01\n         BCT   R1,RD040                                          EXCP01\n         NI    RDCCW+4,FF-X'40'    OFF LAST COMMAND CHAIN        EXCP01\n         ST    R3,IOBDCBPT                                       EXCP01\n         LA    R1,WRIOB                                          EXCP01\n         SPACE 2                                                 EXCP01\n         EXCP  (1)                                               EXCP01\n         SPACE 2                                                 EXCP01\nRD080    WAIT  ECBLIST=ECBLISTR    WAIT FOR IO                   EXCP01\n         TM    WRECB,X'40'         POSTED?                       EXCP01\n         BC    ALLON,RD090         YES,TEST IT                   EXCP01\n         LA    R15,WRITEB          MUST BE WRITE POSTED          EXCP01\n         BALR  R14,R15             GO CHECK IT                   EXCP01\n         B     RD080               GO WAIT FOR READ              EXCP01\nRD090    CLI   WRECB,X'7F'         OK?                           EXCP01\n         BC    NE,SYNADEX          NO,ERROR                      EXCP01\n         L     R4,RDAREA                                         EXCP01\n         LTR   R4,R4               ANY?                          EXCP01\n         BC    ZERO,RD170          NO,BRANCH                     EXCP01\n         LH    R1,VOLLMBLK-VOLLIST(R3) REC/TRK                   EXCP01\n         LA    R5,BUFEND                                         EXCP01\n         L     R2,DCBDEBAD         DEB                           EXCP01\n         USING RBUFFER,R5                                        EXCP01\n         MVI   BUFFLAG,X'00'                                     EXCP01\nRD100    MVI   RBUFFLAG,X'00'      CLEAR FLAG                    EXCP01\n         CLC   RBUFKEY,=XL8'00'    DUMMY REC?                    EXCP01\n         BC    EQ,RD120            YES,BRANCH                    EXCP01\n         TM    12(R2),X'0F'        INPUT?                        EXCP01\n         BC    NALLOFF,RD120       NO,BRANCH                     EXCP01\n         OI    RBUFFLAG,BUFNRTR    NOT YET READ                  EXCP01\nRD120    LA    R5,RBUFEND                                        EXCP01\n         BCT   R1,RD100            LOOP ON ALL RECS              EXCP01\n         B     RD150                                             EXCP01\nRD140    MVC   BUFNEXT-BUFFER(,R5),BUFNEXT DECHAIN               EXCP01\nRD145    MVC   BUFNEXT,USEBUFQ     CHAIN IN AS FIRST             EXCP01\n         ST    R6,USEBUFQ                                        EXCP01\nRD150    L     R4,RDAREA                                         EXCP01\n         USING PCAREA,R4                                         EXCP01\n         LTR   R4,R4                                             EXCP01\n         BC    ZERO,RD170          JUST READ TRACK               EXCP01\n         SR    R1,R1                                             EXCP01\n         IC    R1,2(R7)                                          EXCP01\n         BCTR  R1,0                -1                            EXCP01\n         MH    R1,=AL2(RBUFSIZE)                                 EXCP01\n         LA    R5,BUFEND(R1)       POINT AT PROPER REC           EXCP01\n         NI    RBUFFLAG,FF-BUFNRTR SET READ ONCE                 EXCP01\n         LTR   R4,R4               RETAIN THIS REC IF POSSIBLE?  EXCP01\n         BC    PLUS,RD160          NO,BRANCH                     EXCP01\n         OI    RBUFFLAG,BUFRETN    RETAIN THIS BUF               EXCP01\nRD160    MVC   0(8,R4),RBUFKEY     MOVE KEY                      EXCP01\n         MVC   8(256,R4),RBUFDATA  MOVE DATA                     EXCP01\nRD170    LH    R1,VOLLMBLK-VOLLIST(R3)                           EXCP01\n         LA    R5,BUFEND                                         EXCP01\n         NI    BUFFLAG,FF-BUFRETN-BUFWTR-BUFNRTR CLEAR BITS      EXCP01\nRD190    OC    BUFFLAG,RBUFFLAG                                  EXCP01\n         LA    R5,RBUFEND                                        EXCP01\n         BCT   R1,RD190                                          EXCP01\n         TM    BUFFLAG,BUFRETN+BUFNRTR ALL DONE WITH BUF?        EXCP01\n         BC    NALLOFF,RD200       NO,BRANCH                     EXCP01\n         LTR   R4,R4               JUST READ THE TRACK?          EXCP01\n         BC    ZERO,RD200          YES,BRANCH                    EXCP01\n         MVC   USEBUFQ,BUFNEXT     DECHAIN THIS BUF (FIRST)      EXCP01\n         TM    BUFFLAG,BUFWTR      WRITE?                        EXCP01\n         LA    R1,FREEBUFQ                                       EXCP01\n         BC    ALLOFF,RD195        NO,BRANCH                     EXCP01\n         LA    R1,OUTBUFQ                                        EXCP01\nRD195    MVC   BUFNEXT,0(R1)       CHAIN ON FREE OR OUT          EXCP01\n         ST    R6,0(R1)                                          EXCP01\nRD200    LA    R15,WRITEB          GO CHECK WRITES               EXCP01\n         BALR  R14,R15                                           EXCP01\nREAD020  L     R13,READSAVE+4\n         RETURN (14,12),T\nREADSAVE DS    18F\nRDAREA   DS    A =0 THEN READ TRACK,ELSE READ REC,IF <0 THEN RETAEXCP01\n         EJECT\n*---------------------------------------------------------------------*\n*              WRITE A BLOCK  R2->AREA R1=A(TTR),R3=A(DCB)\n*              IF R1 = 0 THEN ONLY CHECK\n*---------------------------------------------------------------------*\nWRITEC   SAVE  (14,12),,*\n         LA    R14,WRITSAVE\n         ST    R13,WRITSAVE+4\n         ST    R14,8(R13)\n         LR    R13,R14\n         LR    R7,R1               POINT AT TTR                  EXCP01\n         ST    R2,WTRAREA          SAVE AREA                     EXCP01\n         LA    R15,WRITEB          CHECK WRITES                  EXCP01\n         BALR  R14,R15                                           EXCP01\n         LH    R0,0(R7)            LOAD TT                       EXCP01\n         LA    R3,0(R3)            CLEAR HIGH BYTE               EXCP01\n         LA    R6,USEBUFQ                                        EXCP01\n         B     WTR020              GO AND TEST                   EXCP01\nWTR010   CH    R0,BUFTT            THIS TRACK?                   EXCP01\n         BC    NE,WTR020           NO,BRANCH                     EXCP01\n         C     R3,BUFADCB          THIS DCB?                     EXCP01\n         BC    EQ,WTR070           YES,FOUND IN CORE             EXCP01\nWTR020   LR    R5,R6                                             EXCP01\n         L     R6,BUFNEXT                                        EXCP01\n         LTR   R6,R6               ANY MORE?                     EXCP01\n         BC    NZERO,WTR010        NO,BRANCH                     EXCP01\n         CH    R0,VOLLTTR-VOLLIST(R3) NEW TRACK?                 EXCP01\n         BC    LT,WTR060           NO,BRANCH                     EXCP01\n         LA    R15,GETBUF                                        EXCP01\n         BALR  R14,R15             GET A BUFFER                  EXCP01\n         LR    R6,R1               POINT AT IT                   EXCP01\n         ST    R3,BUFADCB          SAVE DCB ADDRESS              EXCP01\n         STH   R0,BUFTT            SAVE TT                       EXCP01\n         MVC   BUFNEXT,USEBUFQ     CHAIN IN                      EXCP01\n         ST    R6,USEBUFQ                                        EXCP01\n         MVI   BUFFLAG,BUFNCOMP    SET TRACK NOT COMPLETE        EXCP01\n         TM    VOLLFLAG-VOLLIST(R3),VOLLSECN NEED NEW EXTENT?    EXCP01\n         BC    ALLOFF,WTR040       NO,BRANCH                     EXCP01\n         LR    R1,R3               POINT AT DCB                  EXCP01\n         EOV   (1)                 GET NEW EXTENT                EXCP01\n         NI    VOLLFLAG-VOLLIST(R3),FF-VOLLSECN  CLEAR END OF EXTEXCP01\nWTR040   LA    R5,BUFEND                                         EXCP01\n         USING RBUFFER,R5                                        EXCP01\n         LH    R1,VOLLMBLK-VOLLIST(R3) REC/TRK                   EXCP01\nWTR050   MVI   RBUFFLAG,BUFNCOMP   SET NOT COMPLETE              EXCP01\n         MVC   RBUFFLAG+1(3),=X'EEEEEE' FOR DUMP                 EXCP01\n         XC    RBUFKEY,RBUFKEY     CLEAR BUFF                    EXCP01\n         XC    RBUFDATA,RBUFDATA                                 EXCP01\n         LA    R5,RBUFEND          NEXT REC BUF                  EXCP01\n         BCT   R1,WTR050                                         EXCP01\n         B     WTR080                                            EXCP01\nWTR060   LR    R1,R7               POINT AT TTR                  EXCP01\n         SR    R2,R2               ONLY READ TRACK               EXCP01\n         LA    R15,READC                                         EXCP01\n         BALR  R14,R15             READ TRACK                    EXCP01\n         L     R6,USEBUFQ          POINT AT IT                   EXCP01\n         B     WTR080                                            EXCP01\nWTR070   MVC   BUFNEXT-BUFFER(,R5),BUFNEXT                       EXCP01\n         MVC   BUFNEXT,USEBUFQ     CHAIN IN AT HEAD              EXCP01\n         ST    R6,USEBUFQ                                        EXCP01\nWTR080   SR    R1,R1                                             EXCP01\n         IC    R1,2(R7)            LOAD R                        EXCP01\n         BCTR  R1,0                                              EXCP01\n         MH    R1,=AL2(RBUFSIZE)                                 EXCP01\n         LA    R5,BUFEND(R1)                                     EXCP01\n         L     R2,WTRAREA          POINT AT INPUT DATA           EXCP01\n         MVC   RBUFKEY,0(R2)       MOVE KEY                      EXCP01\n         MVC   RBUFDATA,8(R2)      MOVE DATA                     EXCP01\n         MVI   RBUFFLAG,BUFWTR     SET NEEDS TO BE WRITTEN       EXCP01\n         LTR   R2,R2               RETAIN?                       EXCP01\n         BC    PLUS,WTR090         YES,BRANCH                    EXCP01\n         OI    RBUFFLAG,BUFRETN    SET RETAIN                    EXCP01\nWTR090   MVI   BUFFLAG,X'00'       CLEAR FLAG                    EXCP01\n         LA    R5,BUFEND                                         EXCP01\n         LH    R1,VOLLMBLK-VOLLIST(R3) REC/TRK                   EXCP01\nWTR100   OC    BUFFLAG,RBUFFLAG                                  EXCP01\n         LA    R5,RBUFEND          NEXT REC                      EXCP01\n         BCT   R1,WTR100                                         EXCP01\n*----------------------------------------------------------------EXCP01\n*              CHECK IF THIS IS LAST REC OF EXTENT               EXCP01\n*----------------------------------------------------------------EXCP01\n         CLI   VOLLTTR+2-VOLLIST(R3),X'01' IS NEXT REC 1?        EXCP01\n         BC    NE,WTR130           NO,BRANCH                     EXCP01\n         LH    R0,0(R7)            LOAD TT                       EXCP01\n         AH    R0,=H'1'            +1                            EXCP01\n         CH    R0,VOLLTTR-VOLLIST(R3) IS THIS THE NEXT TRACK?    EXCP01\n         BC    NE,WTR130           NO,BRANCH                     EXCP01\n         SLL   R0,16                                             EXCP01\n         L     R1,DCBDEBAD         DEB                           EXCP01\n         LA    R2,WRITSAVE+12      SPOT FOR MBBCCHHR             EXCP01\n         STM   R9,R13,WRITSAVE+20                                EXCP01\n         L     R9,16                                             EXCP01\n         L     R15,28(R9)          CVTPCNVT                      EXCP01\n         BALR  R14,R15                                           EXCP01\n         USING *,R14                                             EXCP01\n         LM    R9,R13,WRITSAVE+20                                EXCP01\n         DROP  R14                                               EXCP01\n         LTR   R15,R15             OK?                           EXCP01\n         BC    ZERO,WTR130         IN EXTENT,BRANCH              EXCP01\n         LA    R2,DCBFDAD          SPOT FOR MMBBCCHHR IN DCB     EXCP01\n         LH    R0,0(R7)            TT                            EXCP01\n         SLL   R0,16               MOVE                          EXCP01\n         STM   R9,R13,WRITSAVE+20                                EXCP01\n         L     R9,16                                             EXCP01\n         L     R15,28(R9)          CVTPCNVT                      EXCP01\n         BALR  R14,R15                                           EXCP01\n         USING *,R14                                             EXCP01\n         LM    R9,R13,WRITSAVE+20                                EXCP01\n         DROP  R14                                               EXCP01\n         OI    VOLLFLAG-VOLLIST(R3),VOLLSECN SET LAST REC IN EXTEEXCP01\nWTR130   TM    BUFFLAG,BUFRETN+BUFNCOMP ANY REASON NOT TO WRITE? EXCP01\n         BC    NALLOFF,WTR190      YES,BRANCH                    EXCP01\n         MVC   USEBUFQ,BUFNEXT     DECHAIN                       EXCP01\n         LR    R1,R6                                             EXCP01\n         LA    R5,OUTBUFQ                                        EXCP01\n         L     R6,0(R5)                                          EXCP01\nWTR150   LTR   R6,R6               LAST?                         EXCP01\n         BC    ZERO,WTR160         YES,BRANCH                    EXCP01\n         LR    R5,R6                                             EXCP01\n         L     R6,BUFNEXT                                        EXCP01\n         B     WTR150              GO FIND END                   EXCP01\nWTR160   ST    R1,BUFNEXT-BUFFER(R5)                             EXCP01\n         ST    R6,BUFNEXT-BUFFER(R1)                             EXCP01\n         LA    R15,WRITEB          GO START A WRITE              EXCP01\n         BALR  R14,R15             GO START THE WRITE            EXCP01\nWTR190   L     R13,WRITSAVE+4                                    EXCP01\n         RETURN (14,12),T                                        EXCP01\nWRITSAVE DS    18F                 SAVE AREA\nWTRAREA  DS    A                   INPUT AREA ADDR               EXCP01\n         EJECT                                                   EXCP01\n*----------------------------------------------------------------EXCP01\n*              CHECK ANY ACTIVE WRITES, AND START ANY IF POSSIBLEEXCP01\n*----------------------------------------------------------------EXCP01\nWRITEB   SAVE  (14,12),,*                                        EXCP01\n         LA    R14,WTRBSAVE                                      EXCP01\n         ST    R13,WTRBSAVE+4                                    EXCP01\n         ST    R14,8(R13)                                        EXCP01\n         LR    R13,R14                                           EXCP01\n         LA    R9,ECBLISTW         POINT AT LIST OF ECB ADDRS    EXCP01\nWTRB010  L     R4,0(R9)            POINT AT NEXT ECB-IOB AREA    EXCP01\n         USING WRDSECT,R4                                        EXCP01\n         L     R6,WRBUF            LOAD BUFFER ADDRESS           EXCP01\n         USING BUFFER,R6                                         EXCP01\n         LTR   R6,R6               ACTIVE?                       EXCP01\n         BC    ZERO,WTRB030        NO,BRANCH                     EXCP01\n         TM    WRECB,X'40'         POSTED?                       EXCP01\n         BC    ALLOFF,WTRB070      NO,BRANCH                     EXCP01\n         CLI   WRECB,X'7F'         OK?                           EXCP01\n         LA    R1,WRIOB            POINT AT IOB IF ERROR         EXCP01\n         BC    NE,SYNADEX          ERROR,BRANCH                  EXCP01\n         XC    WRBUF,WRBUF         CLEAR BUFFER ADDR             EXCP01\n         MVI   WRECB,X'00'         CLEAR ECB                     EXCP01\n         LTR   R6,R6               DOES READ WANT THIS BUFFER?   EXCP01\n         BC    NPLUS,WTRB030       YES,DONT CHAIN TO FREE BUFS   EXCP01\n         MVC   BUFNEXT,FREEBUFQ    ADD THIS BUFFER TO FREE QUEUE EXCP01\n         ST    R6,FREEBUFQ                                       EXCP01\nWTRB030  L     R6,OUTBUFQ          ANY BUFFERS TO WRITE?         EXCP01\n         LTR   R6,R6                                             EXCP01\n         BC    ZERO,WTRB070        NO,BRANCH                     EXCP01\n         MVC   OUTBUFQ,BUFNEXT     DECHAIN THIS BUFFER           EXCP01\n         ST    R6,WRBUF                                          EXCP01\n         L     R3,BUFADCB          POINT AT DCB FOR THIS BUFFER  EXCP01\n         LH    R0,BUFTT            TRACK ADDR                    EXCP01\n         SLL   R0,16               TT00                          EXCP01\n         L     R1,DCBDEBAD         POINT AT DEB                  EXCP01\n         LA    R2,IOBMBBCC         SPOT FOR MBBCCHHR             EXCP01\n         STM   R9,R13,WTRBSAVE+12  SAVE REGS                     EXCP01\n         L     R9,16               CVT ADDR                      EXCP01\n         L     R15,28(R9)           CVTPCNVT                     EXCP01\n         BALR  R14,R15             CONVERT TTR TO MBBCCHHR       EXCP01\n         USING *,R14                                             EXCP01\n         LM    R9,R13,WTRBSAVE+12                                EXCP01\n         DROP  R14                                               EXCP01\n         LH    R1,VOLLMBLK-VOLLIST(R3) LOAD REC/TRK FOR THIS DEVIEXCP01\n         L     R5,IOBSTART         POINT AT CCWS                 EXCP01\n         USING WTRCCWS,R5                                        EXCP01\n         LA    R2,BUFEND+RBUFKEY-RBUFFER FIRST REC               EXCP01\n         B     WTRB060                                           EXCP01\nWTRB050  LA    R2,RBUFEND-RBUFFER(R2) NEXT RECORD IN BUFFER      EXCP01\n         LA    R5,WTRCCWE-WTRCCW(R5) NEXT CCW SET                EXCP01\nWTRB060  ST    R2,WTRCCWD          SAVE KEY AND DATA ADDRESS     EXCP01\n         MVC   WTRCCWC(4),IOBMBBCC+3 MOVE CCHH                   EXCP01\n         OI    WTRCCWD+4,X'40'     SET COMMAND CHAIN             EXCP01\n         BCT   R1,WTRB050          LOOP ON ALL RECORDS           EXCP01\n         NI    WTRCCWD+4,FF-X'40'  OFF COMMAND CHAIN ON LAST     EXCP01\n         ST    R3,IOBDCBPT         SAVE DCB ADDRESS              EXCP01\n         LA    R1,WRIOB            POINT AT IOB                  EXCP01\n         SPACE 2                                                 EXCP01\n         EXCP  (1)                 WRITE A TRACK                 EXCP01\n         SPACE 2                                                 EXCP01\nWTRB070  LA    R9,4(R9)            NEXT ECB                      EXCP01\n         LTR   R4,R4               WAS THIS THE LAST             EXCP01\n         BC    PLUS,WTRB010        NO,LOOK AT NEXT               EXCP01\n         L     R13,WTRBSAVE+4                                    EXCP01\n         RETURN (14,12),T                                        EXCP01\nWTRBSAVE DS    18F                                               EXCP01\n         EJECT                                                   EXCP01\n*----------------------------------------------------------------EXCP01\n*              GETBUF - GET A BUFFER AND RETURN IN R1            EXCP01\n*----------------------------------------------------------------EXCP01\nGETBUF   SAVE  (14,12),,*                                        EXCP01\n         LA    R14,GBSAVE                                        EXCP01\n         ST    R13,GBSAVE+4                                      EXCP01\n         ST    R14,8(R13)                                        EXCP01\n         LR    R13,R14                                           EXCP01\nGB010    LA    R15,WRITEB          CHECKS WRITES                 EXCP01\n         BALR  R14,R15                                           EXCP01\n         L     R6,FREEBUFQ         POINT AT FREE BUFS            EXCP01\n         LTR   R6,R6               ANY?                          EXCP01\n         BC    NZERO,GB090         YES,BRANCH                    EXCP01\n*----------------------------------------------------------------EXCP01\n*              NO BUFFERS AVAILABLE,FIND ONE                     EXCP01\n*----------------------------------------------------------------EXCP01\n         LA    R2,ECBLISTW                                       EXCP01\nGB020    L     R4,0(R2)                                          EXCP01\n         USING WRDSECT,R4                                        EXCP01\n         OC    WRBUF,WRBUF         ACTIVE?                       EXCP01\n         BC    NZERO,GB040         YES,BRANCH                    EXCP01\n         LTR   R4,R4               END OF LIST                   EXCP01\n         BC    NPLUS,GB050         YES,NO WRITES ACTIVE          EXCP01\n         LA    R2,4(R2)            NEXT WRITE ECB                EXCP01\n         B     GB020                                             EXCP01\nGB040    WAIT  ECBLIST=ECBLISTW    WAIT FOR WRITE TO COMPLETE    EXCP01\n         B     GB010               GO CHECK IT, AND USE ITS BUF  EXCP01\n*              NO BUFFS BEING WRITEN,GET ONE IN USE              EXCP01\nGB050    LA    R5,USEBUFQ                                        EXCP01\n         L     R6,0(R5)            FIRST BUF                     EXCP01\n         SR    R1,R1               CLEAR FOUND BUF               EXCP01\n         SR    R2,R2               CLEAR LAST ONE                EXCP01\nGB060    TM    BUFFLAG,BUFNCOMP    NOT COMPLETE?                 EXCP01\n         BC    ALLON,GB070         YES,CANT USE IT               EXCP01\n         LR    R2,R5               SAVE                          EXCP01\n         LR    R1,R6               SAVE                          EXCP01\nGB070    LR    R5,R6                                             EXCP01\n         L     R6,BUFNEXT          NEXT                          EXCP01\n         LTR   R6,R6               MORE?                         EXCP01\n         BC    NZERO,GB060         LOOK AT MORE                  EXCP01\n         LR    R6,R1                                             EXCP01\n         MVC   BUFNEXT-BUFFER(,R2),BUFNEXT DECHAIN               EXCP01\n         TM    BUFFLAG,BUFWTR      NEED TO BE WRITTEN?           EXCP01\n         BC    ALLOFF,GB100        NO,USE IT                     EXCP01\n         MVC   BUFNEXT,OUTBUFQ     QUEUE FOR OUTPUT              EXCP01\n         ST    R6,OUTBUFQ                                        EXCP01\n         B     GB010               GO START WRITE AND WAIT       EXCP01\nGB090    MVC   FREEBUFQ,BUFNEXT    DECHAIN                       EXCP01\nGB100    LR    R1,R6                                             EXCP01\n         L     R13,GBSAVE+4                                      EXCP01\n         LM    R14,R0,12(R13)                                    EXCP01\n         RETURN (2,12),,T                                        EXCP01\nGBSAVE   DS    18F                                               EXCP01\n         DROP  R4,R5,R6                                          EXCP01\n         EJECT\n*---------------------------------------------------------------------*\n*              INR - FIND NEXT ENTRY IN CATALOGS DEFINED BY INTAB\n*              RETURN IN R1 ADDR OF ENTRY,AND SET INDCBA\n*---------------------------------------------------------------------*\nINR      SAVE  (14,12),,*\n         ST    R13,INRSAVE+4\n         LA    R14,INRSAVE\n         ST    R14,8(R13)\n         LR    R13,R14\n         L     R5,INRLAST          POINT AT LAST ENTRY\n         USING CATENTRY,R5                                       EXCP01\n         L     R3,INDCBA           POINT AT LAST INLIST\n         USING INLIST,R3\n         LTR   R5,R5               FIRST TIME?\n         BC    ZERO,INR200         YES,GO SETUP\nINR010   SR    R1,R1\n         IC    R1,CATCOUNT         # OF HALF WORDS\n         AR    R1,R1               *2\n         LA    R5,12(R1,R5)        POINT AT NEXT ENTRY\nINR020   CLI   CATCOUNT,CILE       ILE OR IPE?\n         BC    NE,INR030           NO,BRANCH\n         CLI   CATNAME,X'FF'       ILE?\n         BC    NE,INR030           NO,BRANCH\n         CLC   CATTTR,=XL3'00'     END?\n         BC    EQ,INR030           YES,BRANCG\n         MVC   INTTR,CATTTR        MOVE TTR\n         LA    R1,INTTR            POINT AT TTR\n         LA    R2,INKEY            POINT AT KEY AND BUFFER\n         LA    R15,READC\n         BALR  R14,R15             READ NEXT BLOCK\n         LA    R5,INBUF+2          POINT AT NEXT ENTRY\n         B     INR020              GO LOOK AT THIS ONE\nINR030   LA    R1,0(R3)            CLEAR HIGH BYTE\n         SR    R5,R1\n         STH   R5,INOFF            SAVE OFFSET\n*---------------------------------------------------------------------*\n*              FIND LOWEST NAME\n*---------------------------------------------------------------------*\nINR035   MVC   INLOWNAM,=XL8'FFFFFFFFFFFFFFFF'\n         LA    R4,INTAB            POINT AT FIRST INLIST\nINR040   L     R3,0(R4)            POINT AT INLIST\n         LH    R5,INOFF            LOAD OFFSET TO NEXT ENTRY\n         LA    R5,0(R3,R5)         POINT AT ENTRY\n         CLC   INLOWNAM,CATNAME    LOOK AT THIS NAME?\n         BC    LT,INR050           NO,LOOK AT NEXT INLIST\n         BC    EQ,INR080           SANE CHECK CONFLICTS\n         MVC   INLOWNAM,CATNAME    THIS IS NOW LOWEST\n         ST    R3,INDCBA           SAVE\n         ST    R5,INRLAST          SAVE ENTRY ADDRESS\n         MVC   INRLASTC,CATCOUNT   SAVE COUNT ALSO\nINR050   TM    0(R4),X'80'         LAST ENTRY?\n         BC    ALLON,INR060        YES,USE THIS ENTRY\n         LA    R4,4(R4)            LOOK AT NEXT\n         B     INR040\nINR060   SR    R1,R1\n         CLI   INLOWNAM,X'FF'      END OF ALL?\n         BC    EQ,INR070           YES,BEANCH\n         L     R1,INRLAST          LOAD ADDRESS OF ENTRY\nINR070   L     R13,INRSAVE+4\n         LM    R14,R0,12(R13)      LOAD R14-R0\n         RETURN (2,12),T\n*---------------------------------------------------------------------*\n*              SAME NAME FOUND TWICE\n*---------------------------------------------------------------------*\nINR080   CLI   CATNAME,X'FF'       END;\n         BC    EQ,INR050           OK FOR END\nINR082   CLI   CATCOUNT,CCVPE      CVOL?\n         BC    EQ,INR090           YES,BEANCH\n         CLI   CATCOUNT,CNCVPE     NEW CVOL?\n         BC    EQ,INR100           YES,BRANCH\n         CLI   INRLASTC,CCVPE      FIRST A CVOL?\n         BC    EQ,INR130           YES,BRANCH\n         CLI   INRLASTC,CNCVPE     FIRST A NEW CVOL?\n         BC    EQ,INR130           YES,BRANCH\nINR085   MVC   ERRMSG7+43(6),INVOL MOVE SECOND VOLUME NAME\n         MVC   ERRMSG7+12(8),INLOWNAM MOVE INDEX NAME\n         L     R1,INDCBA           ON THE FIRST\n         MVC   ERRMSG7+36(6),INVOL-INLIST(R1) FIRST VOLUME NAME\n         MVC   ERRMSG7+64(6),INVOL-INLIST(R1) FIRST VOLUME NAME\n         MVC   PRNTLINE+2(L'ERRMSG7),ERRMSG7\n         BAL   R9,PUTSP            PRINT ERROR\n         CLI   RETCODE+1,4\n         BC    GE,INR010\n         MVI   RETCODE+1,4\n         B     INR010              GET RID OF SECOND NAME\nINR090   LA    R2,CCVPEVOL         POINT AT VOLUME\n         B     INR110\nINR100   LA    R2,CNCVPEVO         POINT AT VOL NAME\nINR110   LA    R1,INTAB            POINT AT INPUT TABLE\nINR115   L     R6,0(R1)            POINT AT INLIST\n         CLC   0(6,R2),INVOL-INLIST(R6) CVOL FOR SOME INPUT?\n         BC    EQ,INR010           YES,DONT NEED IT\nINR120   TM    0(R1),X'80'         LAST?\n         BC    ALLON,INR085        YES,BRANCH\n         LA    R1,4(R1)            POINT AT NEXT ENTRY\n         B     INR115\nINR130   L     R0,INRLAST          INTER CHANGE ENTRIES\n         ST    R5,INRLAST\n         MVC   INRLASTC,CATCOUNT\n         LR    R5,R0\n         L     R1,INDCBA\n         ST    R3,INDCBA\n         LR    R3,R1\n         B     INR082              GO CLEAN UP\n*---------------------------------------------------------------------*\n*              INITIALIZE DCBS\n*---------------------------------------------------------------------*\nINR200   LA    R4,INTAB\nINR210   L     R3,0(R4)            POINT AT NEXT\n         MVC   INTTR,=XL3'000001'  SET FOR FIRST LEVEL\nINR215   LA    R1,INTTR\n         LA    R2,INKEY\n         LA    R15,READC\n         BALR  R14,R15             READ BLOCK\n         LA    R5,INBUF+2          POINT AT FIRST ENTRY\n         TM    0(R4),X'80'         LAST?\n         BC    ALLON,INR240        YES, PASS A VICE BACK\n         CLI   CATCOUNT,CVICE      VICE?\n         BC    NE,INR220           NO,BRANCH\n         CLI   CATNAME,X'00'       VICE?\n         BC    NE,INR230           NO,BRANCH\n         LA    R5,CVICE*2+12(R5)   POINT AT NEXT ENTRY\nINR220   CLI   CATCOUNT,CILE       ILE?\n         BC    NE,INR230           NO MUST BE ENTRY\n         CLI   CATNAME,X'FF'       ILE OR IPE?\n         BC    NE,INR230           IPE OK\n         CLC   CATTTR,=XL3'00'     END?\n         BC    EQ,INR230           YES,LET STAND\n         MVC   INTTR,CATTTR\n         B     INR215              GO READ NEXT\nINR230   LA    R1,0(R3)\n         SR    R5,R1               FIND OFFSET\n         STH   R5,INOFF\n         LA    R4,4(R4)            POINT AT NEXT INLIST\n         B     INR210\nINR240   ST    R5,INRLAST          SAVE ADDRESS\n         ST    R3,INDCBA           SAVE ADDRESS OF DCB\n         LR    R1,R5               SET RETURN\n         B     INR070              GO RETUEN VICE\nINRSAVE  DS    18F\n         EJECT\n*---------------------------------------------------------------------*\n*              PUTC - PUT ROUTINE FOR CATALOG\n*              R1=A(ENTRY) R0=A(PUTC AREA) R7=A(LEVTAB),\n*              R8=A(VOLLIST)\n*              IF R1=0 THEN END THIS INDEX\n*              IF R1<0 THEN FILL THIS TRACK\n*---------------------------------------------------------------------*\nPUTC     SAVE  (14,12),,*\n         LA    R14,PUTCSAVE\n         ST    R13,PUTCSAVE+4\n         ST    R14,8(R13)\n         LR    R13,R14\n         LR    R6,R0               SAVE PUT AREA ADDRESS\n         USING PCAREA,R6\n         LTR   R5,R1\n         USING CATENTRY,R5\n         BC    PLUS,PC004\n         BC    MINUS,PC002\n         LH    R4,LEVBLOCK         LOAD NUMBER OF BLOCKS TO LEV\n         AH    R4,=H'1'            +1 FOR BCT\n         MVC   PCKEY,=XL8'FFFFFFFFFFFFFFFF'\n         B     PC050               GO END UP\nPC002    LA    R6,PUTTTR           POINT AT DUMMY RECORD\n         LH    R0,LEVBLONT         LOAD NUMBER OF BLOCKS NEEDED ON A T\n         SR    R4,R4\n         IC    R4,VOLLTTR+2        LOAD NEXT RECORD NUMBER\n         SH    R4,VOLLMBLK         - MAX\n         LCR   R4,R4               R4 HAS # LEFT -1\n         SH    R0,=H'1'            R0 HAS # NEEDED-1\n         CR    R0,R4               ARE THERE ENOUGH?\n         BC    LE,PCRET            YES,BRANCH\n         AH    R4,=H'1'            ADD ONE FOR BCT\nPC003    LH    R15,VOLLIDUM        COUNT DUMMY RECORDS\n         AH    R15,=H'1'\n         STH   R15,VOLLIDUM        SAVE\n         CLC   VOLLFRST,=XL3'00'   ANY AVABILE BLKS SO FAR?\n         BC    NE,PC060            YES,BRANCH\n         MVC   VOLLFRST,VOLLTTR    SET THIS AS FIRST\n         B     PC060               NO,GO ADD DUMMY RECORDS\nPC004    LA    R1,CVCBNEXT-CATNAME+PCBUF-8 A(TTR-8) IF VCB       F00001\n         TM    PCFLAG,PCVCB        PCV?\n         BC    ALLON,PC060         YES,GO WRITE\n         SR    R1,R1\n         IC    R1,CATCOUNT         LOAD # OF HALF WORDS\nPC005    LA    R1,12(R1,R1)        LENGTH=12+2*CATCOUNT\n         TM    PCFLAG,PCCLBUF\n         BC    ALLON,PC008         BUFFER IN USE\n         XC    PCKEY,PCKEY         CLEAR KEY\n         XC    PCBUF,PCBUF         CLEAR BUFFER\n         MVI   PCBUF+1,X'02'       SET LENGTH USED\n         OI    PCFLAG,PCCLBUF      SET BUFFER IN USE\nPC008    LH    R2,PCBUF            LOAD COUNT USED SO FAR\nPC010    LA    R3,12(R2,R1)        SET NEW LENGTH IF ADDED TO BLOCK\n         LH    R0,LEVBYTES         LOAD BYTES TO LEAVE IN A BLOCK\n         AR    R0,R3\n         CH    R0,=H'256'          WILL IT FIT?\n         BC    GT,PC050            NO,BRANCH\n         LA    R0,0(R2,R1)         SET NEW LENGTH\n         STH   R0,PCBUF            SAVE IN BUFFER\n         LA    R2,PCBUF(R2)        POINT AT TO\n         BCTR  R1,0                -1 FOR EXECUTE\n         EX    R1,PCMVC            MOVE ENTRY\n         MVC   PCKEY,0(R5)         MOVE KEY ALSO\n         CLI   LEVEL+1,X'01'       LEVEL ONE?\n         BC    NE,PCRET            NO,BRANCH\n         CLI   CATCOUNT,CIPE       IPE?\n         BC    EQ,PC020            YES,BRANCH\n         CLI   CATCOUNT,CGIPE      GIPE?\n         BC    EQ,PC020            YES,BRANCH\n         CLI   CATCOUNT,CVCBPE     VCBPE?\n         BC    NE,PCRET            NO,BRANCH\n         MVI   CATCOUNT-CATNAME(R2),X'06' RESET TO 06\nPC020    L     R1,INDCBA           POINT AT INDCB\n         OC    CATCOUNT-CATNAME(1,R2),ININDEX-INLIST(R1) SAVE INDEX\n         B     PCRET               GO RETURN\n*              ENTRY DOES NOT FIT,WRITE CURRENT,ADD NEXT\nPC050    LH    R2,PCBUF            LOAD LENGTH SO FAR\n         LA    R1,PCBUF(R2)        POINT AT NEXT SPOT\n         LA    R2,12(R2)           +LENGTH FOR ILE\n         STH   R2,PCBUF            SAVE IT\n         MVC   0(8,R1),=XL8'FFFFFFFFFFFFFFFF' SET NAME AT FF\nPC060    MVC   PUTTTR,VOLLTTR      POINT AT TTR FOR THIS RECORD\n         SR    R0,R0\n         IC    R0,VOLLTTR+2        LOAD RECORD NUMBER\n         AH    R0,=H'1'            +1\n         CH    R0,VOLLMBLK         # OF BLOCKS / TRK\n         BC    LE,PC070            OK,BRANCH\n         LH    R0,VOLLTTR          LOAD IT\n         AH    R0,=H'1'            +1\n         STH   R0,VOLLTTR          SAVE NEW TTR\n         LTR   R5,R5                TEST OPERATION\n         BC    NPLUS,PC065         DONT SET KEY\n         TM    PCFLAG,PCVCB        VCB?\n         BC    ALLON,PC065         YES,BRANCH\n*******************************************************************CCN*\n*                                                                  CCN\n*  THE FOLLOWING INSTRUCTION CAUSES A SEEK TO OCCUR AT THE END OF  CCN\n*  EACH TRACK.  THIS CUASES UNNECESSARY OVERHEAD, AND IS NOT       CCN\n*  REQUIRED BY BLDL, WHO KNOWS HOW TO DO MULTITRACK SEARCHES       CCN\n*  JUST FINE.  CHRIS THOMAS, UCLA/CCN, 03/23/77.                   CCN\n**CCN**  MVC   PCKEY,=XL8'FFFFFFFFFFFFFFFF'                        CCN\n*******************************************************************CCN*\nPC065    EQU   *\n         MVI   VOLLTTR+2,X'01'     SET RECORD TO 1\n         B     PC080\nPC070    STC   R0,VOLLTTR+2        SAVE RECORD #\nPC080    LTR   R5,R5               END OF FILE?\n         BC    NPLUS,PC085         YES,BRANCH\n         TM    PCFLAG,PCVCB        VCB?\n         BC    ALLOFF,PC084        NO,BRANCH\n         OC    CVCBNEXT-CATENTRY+PCBUF,CVCBNEXT-CATENTRY+PCBUF\n         BC    ZERO,PC085          THIS IS LAST,BRANCH\nPC084    MVC   8(3,R1),VOLLTTR     MOVE NEXT BLOCK\nPC085    LA    R1,PUTTTR           POINT AT TTR\n         LA    R2,PCKEY            POINT AT KEY\n         CLC   PCKEY,=XL8'00'      DUMMY?                        EXCP01\n         BC    EQ,PC090            YES,BRANCH                    EXCP01\n         AL    R2,=X'80000000'     RETAIN                        EXCP01\nPC090    EQU   *                                                 EXCP01\n         LA    R3,VOLLDCB          POINT AT DCB\n         LA    R15,WRITEC\n         BALR  R14,R15             WRITE THIS BLOCK\nPC095    CLC   PCTTR,=X'000000'    NEED TTR FOR CALLER?\n         BC    NE,PC100            NO,BRANCH\n         MVC   PCTTR,PUTTTR        SAVE\nPC100    NI    PCFLAG,X'FF'-PCCLBUF\n         TM    PCFLAG,PCVCB        VCB?                          F00001\n         BC    ALLON,PCRET         YES,ALL DONE                  F00001\n         LTR   R5,R5               EOF?\n         BC    PLUS,PC004          NO,BRANCH\n         LA    R6,PUTTTR           SET DUMMY RECORD POINTER\n         BCT   R4,PC003            GO ADD DUMMY RECORDS\nPCRET    L     R13,PUTCSAVE+4\n         RETURN (14,12),T\nPCMVC    MVC   0(0,R2),0(R5)       USED BY EXECUTE\nPUTCSAVE DS    18F\nPUTTTR   DS    XL3                 USED AS DUMMY PCAREA AND FOR TTR\n         DC    X'00'               FLAGS\n         DC    XL8'00'             DUMMY KEY\n         DC    XL256'00'           DUMMY RECORD\n         DROP  R6\n         EJECT\n*---------------------------------------------------------------------*\n*              GDSPROC - MOVE OR COPY GDS DUMMY DSCBS\n*              INDCBA=A(INPUT DCB) R8-> VOLLIST FOR OUTPUT\n*              NAME HAS DATA SET NAME\n*---------------------------------------------------------------------*\nGDSPROC  SAVE  (14,12),,*\n         LA    R14,GDSSAVE\n         ST    R13,GDSSAVE+4\n         ST    R14,8(R13)\n         LR    R13,R14\n*---------------------------------------------------------------------*\n*              FIND INPUT VOLUME AND DSCB\n*---------------------------------------------------------------------*\n         L     R3,INDCBA\n         L     R4,DCBDEBAD-IHADCB(R3) POINT AT DEB\n         L     R1,DCBDEBAD-IHADCB(R8) POINT AT OUTPUT DEB\n         CLC   33(3,R1),33(R4)     SAME UCB?\n         BC    EQ,GDS100           YES,NOTHING TO DO\n         MVC   ALLOCUCB+1(3),33(R1) MOVE UCB ADDRESS\n         L     R4,32(R4)           POINT AT UCB\n         CLI   2(R4),X'FF'         UCB?\n         BC    NE,GDS010           NO,BRANCH\n         MVC   SCRDEV,16(R4)       MOVE DEVICE TYPE\n         MVC   OBTVOL,28(R4)       MOVE VOLID\n         B     GDS020\nGDS010   MVC   OBTVOL,4(R4)        MOVE CELL VOLID\n         LH    R1,0(R4)            LOAD BIN NUMBER\n         MH    R1,=H'-16'          SIZE OF CELL ENTRY\n         AR    R1,R4\n         AL    R1,=F'-56'          POINT AT START OF UCB\n         MVC   SCRDEV,16(R1)       MOVE DEVICE TYPE\nGDS020   MVC   ERRMSG9+36(6),OBTVOL\n         SR    R0,R0\n         OBTAIN OBTCLIST           FIND OLD DSCB\n         LTR   R15,R15             FOUND?\n         BC    ZERO,GDS030         YES,BRANCH\n         CH    R15,=H'8'           NOT FOUND?\n         BC    EQ,GDS100           YES,BRANCH\n         MVC   ERRMSG9+6(8),=CL8'OBTAIN' SET COMMENT\n         B     GDSERR9             GO PRINT ERR MSG\nGDS030   CLI   NAME+59,X'00'       ZERO EXTENTS?\n         BC    NE,GDSERR10         NO,ERROR BRANCH\n         XC    NAME+108(8),NAME+108\n         L     R1,ALLOCUCB         POINT AT UCB\n         CLI   2(R1),X'FF'         UCB?\n         BC    EQ,GDS050           YES,BRANCH\n         MVC   OBTVOL2,4(R1)       MOVE CELL VOLID\n         B     GDS060\nGDS050   MVC   OBTVOL2,28(R1)      MOVE VOLID\nGDS060   MVC   ERRMSG9+36(6),OBTVOL2\n         LM    R0,R1,ALLOCR0       LOAD PARM REGS\n         SVC   32                  ALLOCATE\n         LTR   R15,R15             OK?\n         BC    EQ,GDS090           YES,BRANCH\n         CH    R15,=H'4'           ALL READY THERE?\n         MVC   ERRMSG9+6(8),=CL8'ALLOCATE' SET COMMENT\n         BC    NE,GDSERR9          NO,ERROR BRANCH\n         SR    R0,R0\n         OBTAIN OBTCLST2           READ SECOND DSCB\n         LTR   R15,R15             OK?\n         MVC   ERRMSG9+6(8),=CL8'OBTAIN 2'\n         BC    NZERO,GDSERR9       ERROR,BRANCH\n         CLC   OBTWORK+82(12),OBTWORK2+82 SAME ATTRIBUTES?\n         BC    NE,GDSERR11         NO,ERROR\n*---------------------------------------------------------------------*\n*              DSCB HAS BEEN ADDED OR IS ALREADY THERE\n*---------------------------------------------------------------------*\nGDS090   TM    FLAG,GDSMOVE        MOVE?\n         BC    ALLOFF,GDS100       NO,MUST BE COPY SO RETURN\n         MVC   ERRMSG9+36(6),OBTVOL\n         XC    SCRRET,SCRRET\n         SR    R0,R0\n         SCRATCH SCRCLIST          SCRATCH THE OLD ONE\n         LTR   R15,R15             OK?\n         BC    ZERO,GDS100         YES,BRANCH\n         LH    R15,SCRRET          LOAD RETURN CODE\n         MVC   ERRMSG9+6(8),=CL8'SCRATCH' SET COMMENT\n         B     GDSERR9\n*---------------------------------------------------------------------*\n*              RETURN\n*---------------------------------------------------------------------*\nGDS100   L     R13,GDSSAVE+4\n         RETURN (14,12),T\n*---------------------------------------------------------------------*\n*              ERROR PROCESSING\n*---------------------------------------------------------------------*\nGDSERR9  CVD   R15,WORKAREA\n         UNPK  ERRMSG9+28(3),WORKAREA+6(2) SET RETURN CODE\n         MVC   PRNTLINE+2(L'ERRMSG9),ERRMSG9\n         MVC   PRNTLINE+2+L'ERRMSG9(L'NAME),NAME\nGDS200   BAL   R9,PUTSP\n         CLI   RETCODE+1,4\n         BC    GE,GDS100\n         MVI   RETCODE+1,4\n         B     GDS100              RETURN\nGDSERR10 MVC   PRNTLINE+2(L'ERRMSG10),ERRMSG10\n         MVC   PRNTLINE+2+L'ERRMSG10(L'NAME),NAME\n         B     GDS200\nGDSERR11 MVC   PRNTLINE+2(L'ERRMSG11),ERRMSG11\n         MVC   PRNTLINE+2+L'ERRMSG11(L'NAME),NAME\n         B     GDS200\nGDSSAVE  DS    18F\nOBTCLIST CAMLST SEARCH,NAME,OBTVOL,OBTWORK\nSCRCLIST CAMLST SCRATCH,NAME,,SCRLIST,,OVRD\nOBTCLST2 CAMLST SEARCH,NAME,OBTVOL2,OBTWORK2\nALLOCUCB DC    A(0)                UCB ADDR FOR ALLOCATE\nALLOCR0  DC    X'80',AL3(NAME)     DSCB ADDR\nALLOCR1  DC    A(ALLOCUCB)         UCB ADDRESS\nSCRLIST  DC    H'1'                # OF VOLUMES\nSCRDEV   DS    XL4                 DEVICE TYPE FOR SRATCH\nOBTVOL   DS    CL6                 VOLID\nSCRRET   DC    H'0'                SEQ NUMBER AND RETCODE\nOBTVOL2  DS    CL6                 SECOND VOLID\nNNAME    DC    A(NAME-1)           SPOT FOR FIRST LEVEL NAME\n         DS    0D\n         DS    CL4                 PADDING\nNAME     DC    CL44' '\nOBTWORK  DS    148C                WORK AREA FOR OBTAIN\n         DS    0D\nOBTWORK2 DS    148C                SECOND OBTAIN WORK AREA\n         EJECT\n*---------------------------------------------------------------------*\n*              RR -RECURSIVE ROUTINE - CALLED FOR EACH LEVEL\n*              R1=A(TTR) FOR NEXT LEVEL DOWN,\n*              R0=LEVEL NUMBER (HIGHEST IS 1)\n*              R8=A(VOLLIST) FOR LEVEL GT ONE\n*        RETURNS IN THE TTR POINTED AT BY R1 THE NEW TTR\n*---------------------------------------------------------------------*\nRR       SAVE  (14,12),,*\n         LR    R4,R1               SAVE R1\n         LR    R7,R0               SAVE LEVEL #\n         LA    R0,RRWKSIZE\n         GETMAIN R,LV=(0)\n         XC    0(256,R1),0(R1)\n         XC    256(256,R1),256(R1)\n         XC    512(RRWKSIZE-512,R1),512(R1)\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1              POINT AT WORK AREA\n         USING RRWORK,R13\n         ST    R4,RRFSTTR          SAVE ADDRESS OF CALLERS TTR\n         STH   R7,RRLEV            SAVE LEVEL\n         STH   R7,LEVEL\n         MH    R7,=AL2(LEVTABL)\n         LA    R7,LEVTAB-LEVTABL(R7) POINT AT LEVEL TABLE\n         CLI   RRLEV+1,X'01'       LEVEL ONE?\n         BC    EQ,RR050            YES,BRANCH\n         LH    R1,=H'-1'           SET TO CHECK FOR SPACE ON THIS TRK\n         LA    R15,PUTC\n         BALR  R14,R15\nRR010    LR    R1,R4               POINT AT TTR\n         LA    R2,RRKEY            POINT AT KEY+BUFFER\n         L     R3,INDCBA           POINT AT DCB\n         LA    R15,READC           READ THE BLOCK\n         BALR  R14,R15\n         LA    R5,RRBUF+2          POINT AT FIRST ENTRY\n         USING CATENTRY,R5\nRR005    CLI   CATCOUNT,CILE       IS THIS AN ILE OR CIPE\n         BC    NE,RR020            NO,BRANCH\n         CLI   CATNAME,X'FF'       ILE?\n         BC    NE,RR020            NO,BRANCH\n         CLC   CATTTR,=XL3'00'     END OF LEVEL?\n         BC    EQ,RR400            YES,BRANCH,GO MAKE SECOND PASS\n         LA    R4,CATTTR           POINT AT NEXT TTR\n         B     RR010               GO READ NEXT BLOCK\nRR020    CLI   RRLEV+1,X'01'       LEVEL ONE?\n         BC    EQ,RR100            YES,GO PROCESS\n*---------------------------------------------------------------------*\n*              ADD THIS ENTRY TO OUTPUT\n*---------------------------------------------------------------------*\n         LA    R0,RRPTTR           POINT AT PCAREA\nRR030    LR    R1,R5\nRR035    LA    R15,PUTC\n         BALR  R14,R15             CALL PUTC TO ADD ENTRY\nRR040    CLI   RRLEV+1,X'01'       LEVEL 1\n         BC    EQ,RR050            YES,GO GET NEXT ENTRY\n         SR    R1,R1\n         IC    R1,CATCOUNT         LOAD # OF HALF WORDS\n         AR    R1,R1               TIMES TWO\n         LA    R5,12(R1,R5)        POINT AT NEXT ENTRY\n         B     RR005               GO PROCESS IT\nRR050    LA    R15,INR             POINT AT INPUT ROUTINE\n         BALR  R14,R15             CALL IT\n         LTR   R5,R1               ANY MORE?\n         BC    ZERO,RR400          NO,END UP\n         B     RR005               GO PROCESS IT\n*---------------------------------------------------------------------*\n*              LEVEL ONE PROCESSING\n*---------------------------------------------------------------------*\nRR100    TM    FLAG,COPY           IS THIS COPY OR SPLIT\n         BC    ALLON,RR200         COPY,BRANCH\n*---------------------------------------------------------------------*\n*              OPERATION IS SPLIT\n*---------------------------------------------------------------------*\n         CLI   CATCOUNT,CVICE      VICE OR NCVPE?\n         BC    NE,RR130            NO,BRANCH\n         CLI   CATNAME,X'00'       VICE?\n         BC    NE,RR132            NO,SKIP ON NCVPE\n         L     R8,VOLCHAIN         POINT AT FIRST VOLLIST\nRR110    TM    VOLLFLAG,VOLLKEEP KEEP OR SPLIT?\n         BC    ALLON,RR120         KEEP,BRANCH\n         C     R8,VOLLRNXT         REAL VOLLIST?\n         BC    NE,RR120            NO,BRANCH\n         LA    R0,VOLLITTR         POINT AT PCAREA FOR HIGH INDEX\n         LR    R1,R5               POINT AT ENTRY\n         LA    R15,PUTC\n         BALR  R14,R15             GO ADD VICE\nRR120    L     R8,VOLLNEXT         POINT AT NEXT VOLLIST\n         LTR   R8,R8               ANY?\n         BC    NZERO,RR110         YES,KEEP GOING\n         B     RR040               ALL VICES ADDED,GO GET NEXT ENTRY\nRR130    CLI   CATCOUNT,CIPE       IPE?\n         BC    EQ,RR135            YES,CHECKIT\n         CLI   CATCOUNT,CAE        ALIAS?\n         BC    EQ,RR160            YES,BRANCH\n         CLI   CATCOUNT,CVCBPE     VCB POINTER?\n         BC    EQ,RR132            YES,BRANCH\n         CLI   CATCOUNT,CGIPE      GENERATION GROUP INDEX?\n         BC    EQ,RR135            YES,CHECK\nRR132    TM    FLAG,DSSPLIT        SPLIT DATA SETS?\n         BC    ALLOFF,RR040        NO,DELETE THEN\nRR135    L     R8,VOLCHAIN         POINT AT VOLLISTS\nRR140    CLC   CATNAME,VOLLNAME    USE THIS VOLLIST?\n         BC    LE,RR150            YES,BRANCH\n         L     R8,VOLLNEXT         LOOK AT NEXT\n         B     RR140\nRR150    TM    VOLLFLAG,VOLLKEEP   KEEP OR SPLIT\n         BC    ALLON,RR040         KEEP,BRANCH DONT ADD\n         L     R8,VOLLRNXT         POINT AT REAL VOLLIST\n         LA    R0,VOLLITTR         POINT AT PCAREA\n         CLI   CATCOUNT,CNCVPE     CVOL?\n         BC    EQ,RR155            YES,BRANCH\n         CLI   CATCOUNT,CCVPE      CVOL?\n         BC    NE,RR030            NO,BRANCH\nRR155    BAL   R9,RR180            CHECK CVOL\n         B     RR040               IF SAME VOL SKIP IT\n         LH    R15,VOLLICVL        LOAD CVOL COUNT\n         AH    R15,=H'1'\n         STH   R15,VOLLICVL        SAVE COUNT\n         B     RR030               GO ADD ENTRY\nRR160    L     R8,VOLCHAIN\nRR162    CLC   CAENAME,VOLLNAME    TRUE NAME HERE?\n         BC    LE,RR165            YES,BRANCH\n         L     R8,VOLLNEXT         LOOK AT NEXT\n         B     RR162\nRR165    L     R3,VOLLRNXT         POINT AT REAL NAMES VOLLIST\n         L     R8,VOLCHAIN\nRR168    CLC   CATNAME,VOLLNAME    THIS VOLLIST?\n         BC    LE,RR170            YES,BRANCH\n         L     R8,VOLLNEXT         LOK AT NEXT\n         B     RR168\nRR170    L     R8,VOLLRNXT         POINT AT ALIAS OLLIST\n         TM    VOLLFLAG,VOLLKEEP   ALIS TO BE KEPT?\n         BC    ALLOFF,RR175        NO,BRANCH\n         TM    VOLLFLAG-VOLLIST(R3),VOLLKEEP REAL NAME KEPT?\n         BC    ALLON,RR040         YES,DONT HAVE TO ADD\n         LR    R8,R3               POINT AT REAL NAMES VOLLIST\n         LA    R0,VOLLITTR         POINT AT PCAREA\n         B     RR030               GO ADD\nRR175    CR    R3,R8               BOTH SPLIT TO SAME VOLLIST?\n         LA    R0,VOLLITTR         POINT AT PCAREA\n         BC    EQ,RR030            YES,GO ADD ALIAS\n         MVC   RRCVNAME,CATNAME    MOVE CVOL NAME\n         MVC   RRCVDEV,VOLLDEVT-VOLLIST(R3) MOVE DEVICE TYPE\n         MVC   RRCVVOL,VOLLVOL-VOLLIST(R3) MOVE CVOL VOL NAME\n         LH    R15,VOLLICVL        LOAD COUNT OF CVOLS\n         AH    R15,=H'1'\n         STH   R15,VOLLICVL\n         LA    R1,RRCVNAME         POINT AT CVOL ENTRY\n         LA    R0,VOLLITTR         POINT AT PCAREA\n         LA    R15,PUTC\n         BALR  R14,R15             ADD CVOL ENTRY ON ALIAS VOLLIST\n         LR    R8,R3               POINT AT REAL NAMES VOLLIST\n         LA    R0,VOLLITTR         POINT AT PCAREA\n         TM    VOLLFLAG,VOLLKEEP   REAL KEPT?\n         BC    ALLOFF,RR030        NO,GO ADD ALIAS\n         B     RR040               YES,SKIP IT\n*---------------------------------------------------------------------*\n*              CHECK CVOLS AND REMAP IF NEEDED\n*---------------------------------------------------------------------*\nRR180    LA    R1,CCVPEVOL         POINT AT VOL NAME\n         CLI   CATCOUNT,CNCVPE     NEW ONE?\n         BC    NE,RR182            NO,BRANCH\n         LA    R1,CNCVPEVO         POINT AT VOLUME FOR NCVPE\nRR182    LA    R14,INTAB           POINT AT LIST OF INLISTS\nRR183    L     R15,0(R14)          POINT AT INLIST\n         CLC   0(6,R1),INVOL-INLIST(R15) POINT AT INPUT VOL?\n         BC    EQ,RR185            YES,BRANCH\n         TM    0(R14),X'80'        END?\n         BC    ALLON,RR195         YES,DOES NOT POINT AT INPUT VOL\n         LA    R14,4(R14)          INC TO NEXT INLIST PTR\n         B     RR183\nRR185    L     R14,VOLCHAIN        POINT AT VOLLIST\nRR187    CLC   CATNAME,VOLLNAME-VOLLIST(R14) USE THIS?\n         BC    LE,RR190            YES,BRANCH\n         L     R14,VOLLNEXT-VOLLIST(R14) LOOK AT NEXT\n         B     RR187\nRR190    CLC   VOLLVOL,VOLLVOL-VOLLIST(R14) POINT AT SAME VOLUME?\n         BCR   EQ,R9               YES,DELETE CVOL\n         MVC   0(6,R1),VOLLVOL-VOLLIST(R14) SET NEW VOLUME\n         CLI   CATCOUNT,CNCVPE     NEW CVOL?\n         BC    NE,4(R9)            NO,RETURN\n         MVC   CNCVPEDT,VOLLDEVT-VOLLIST(R14) SET DEVICE TYPE\n         B     4(R9)               RETURN\nRR195    CLC   0(6,R1),VOLLNAME    DOES CVOL POINT AT OITPUT VOL?\n         BCR   EQ,R9               YES,BY PASS ADD\n         B     4(R9)               NO,RETURN OK\n*---------------------------------------------------------------------*\n*              OPERATION IS COPY\n*---------------------------------------------------------------------*\nRR200    CLI   CATCOUNT,CVICE      VICE OR NCVPE?\n         BC    NE,RR210            NO,BRANCH\n         CLI   CATNAME,X'00'       VICE?\n         BC    NE,RR250            NO,NCVPE GO COUNT\nRR205    L     R8,VOLLAST          POINT AT VOLLIST\n         LA    R0,VOLLITTR         POINT AT PCAREA\n         B     RR030               GO ADD THIS VICE OR NCVPE\nRR210    CLI   CATCOUNT,CIPE       INDEX POINTER?\n         BC    EQ,RR215            YES,BRANCH\n         CLI   CATCOUNT,CAE        ALIAS?\n         BC    EQ,RR260            YES,BRANCH\n         CLI   CATCOUNT,CVCBPE\n         BC    EQ,RR212\n         CLI   CATCOUNT,CGIPE\n         BC    EQ,RR215\n         CLI   CATCOUNT,CDSPE      DATA SET?\n         BC    GE,RR212            YES,BRANCH\n         B     RR250\nRR212    TM    FLAG,DSKEEP         KEEP DATA SETS?\n         BC    ALLON,RR205         YES,BRANCH\n         TM    FLAG,DSSPLIT        SPLIT THEM THEN?\n         BC    ALLOFF,RR040        NO MUST BE UNCATLG SO SKIP THEM\nRR215    L     R8,VOLCHAIN         POINT AT VOLLIST\nRR220    CLC   CATNAME,VOLLNAME    USE THIS ENTRY?\n         BC    LE,RR230            YES,BRANCH\n         L     R8,VOLLNEXT         LOOK AT NEXT\n         B     RR220\nRR230    TM    VOLLFLAG,VOLLKEEP   KEEP OR SPLIT?\n         BC    ALLON,RR205         KEEP GO ADD THIS ENTRY\nRR240    MVC   RRCVNAME,CATNAME    MOVE NAME TO CVOL LIST\n         MVC   RRCVDEV,VOLLDEVT    MOVE DEVICE TYPE CODE\n         MVC   RRCVVOL,VOLLVOL     MOVE CVOL NAME\n         L     R8,VOLLAST          SET VOLLIST PTR\n         LH    R15,VOLLICVL        COUNT NUMBER OF CVOLS\n         AH    R15,=H'1'\n         STH   R15,VOLLICVL\n         LA    R1,RRCVNAME         POINT AT NEW ENTRY\n         LA    R0,VOLLITTR\n         B     RR035               GO ADD CVOL INSTEAD OF IPE\nRR250    L     R8,VOLLAST\n         BAL   R9,RR180\n         B     RR040\n         LH    R15,VOLLICVL\n         AH    R15,=H'1'\n         STH   R15,VOLLICVL\n         B     RR205               ALL OTHERS,GO ADD\nRR260    L     R8,VOLCHAIN\nRR270    CLC   CAENAME,VOLLNAME    IS THIS TRUE NAME HERE?\n         BC    LE,RR280            YES,BRANCH\n         L     R8,VOLLNEXT         LOOK AT NEXT\n         B     RR270\nRR280    TM    VOLLFLAG,VOLLKEEP   KEEP?\n         L     R8,VOLLRNXT\n         BC    ALLOFF,RR240        NO,GO ADD CVOL\n         L     R8,VOLLAST\n         B     RR030               GO ADD\n*---------------------------------------------------------------------*\n*              FIRST LEVEL IS ALL DONE, END UP THE INDEXES\n*---------------------------------------------------------------------*\nRR400    CLI   RRLEV+1,X'01'       LEVEL ONE?\n         LA    R5,RRPTTR           POINT AT PCAREA\n         BC    NE,RR430            NO,BRANCH\n         TM    FLAG,COPY           COPY?\n         BC    ALLOFF,RR410        NO,BRANCH\n         L     R8,VOLLAST          LOAD LAST\n         B     RR420\nRR410    L     R8,VOLCHAIN         POINT AT FIRST VOLLIST\n         B     RR630               GO FIND FIRST VOLLIST TO PROCESS\nRR420    LA    R5,VOLLITTR         POINT AT PCAREA\n         DROP  R5\n         USING PCAREA,R5\nRR430    LR    R0,R5               POINT AT PCAREA\n         MVC   RRSVTTR,PCTTR       SAVE TTR\n         XC    PCTTR,PCTTR\n         SR    R1,R1               SET EOF FOR PUTC\n         LA    R15,PUTC\n         BALR  R14,R15             GO CLEAN UP AND ADD EOF\n         LA    R1,256              MAX BYTES\n         SH    R1,PCBUF            -BYTES=BYTES LEFT IN LAST BLOCK\n         STH   R1,RRBYTES          SAVE\n*---------------------------------------------------------------------*\n*              AT THIS POINT PCTTR HAS TTR OF LAST BLOCK IN INDEX\n*              AND RRSVTTR HAS FIRST TTR OR ZERO IF FIRST=LAST\n*---------------------------------------------------------------------*\n         OC    RRSVTTR,RRSVTTR     FIRST BLOCK SAME AS LAST?\n         BC    ZERO,RR450          YES,DONT HAVE TO READ\n         LA    R1,RRSVTTR          POINT AT TTR\n         LA    R3,VOLLDCB                                        EXCP01\n         LA    R2,RRKEY            POINT AT AREA\n         AL    R2,=X'80000000'     RETAIN                        EXCP01\n         LA    R15,READC\n         BALR  R14,R15             READ IN FIRST BLOCK\n         B     RR460\nRR450    MVC   RRKEY,PCKEY         MOVE KEY\n         MVC   RRBUF,PCBUF         MOVE BUF\n         MVC   RRSVTTR,PCTTR\nRR460    MVC   RRBUF+2+CATTTR-CATNAME(3),PCTTR SET LAST BLK TTR\n         MVC   RRRTTR,RRSVTTR\n         DROP  R5                  MVCRRRTTR,RRSVTTR\n         USING CATENTRY,R5\n         LA    R5,RRBUF+2          POINT AT VICE OR ICE\n         CLI   CATCOUNT,CVICE      VICE?\n         BC    NE,RR470            NO,MUST BE ICE\n         MVC   CVICULB,RRBYTES     #OF UNUSED BYTES LAST BLOCK\n         B     RR480\nRR470    MVC   CICEUBL,RRBYTES     #UNUSED BYTES,LAST BLOCK\n         MVC   CICEILL,RRSVTTR     TTR OF THIS BLOCK\n         CLI   CICEALIA,X'00'      ANY ALIASES?\n         BC    EQ,RR480            NO,BRANCH\n         GETMAIN R,LV=ANSIZE,SP=2\n         USING ANENTRY,R1\n         MVC   ANNEXT,VOLANCHN\n         ST    R1,VOLANCHN         CHAIN IN\n         MVC   ANTTR,RRSVTTR       SAVE TTR OF THIS BLOCK\n         L     R15,RRFSTTR         POINT AT TTR\n         SH    R15,=H'8'           POINT AT NAME\n         MVC   ANNAME,0(R15)       MOVE NAME\n         MVC   ANCOUNT+1(1),CICEALIA\n         MVI   ANCOUNT,X'00'       SAVE # OF ALIASES IN HLF WRD\n         DROP  R1\nRR480    SR    R1,R1\n         IC    R1,CATCOUNT\n         AR    R1,R1               TIMES TWO\n         LA    R5,12(R1,R5)        POINT AT NEXT ENTRY\nRR490    CLI   LEVEL+1,X'01'       LEVEL ONE?\n         BC    NE,RR491            NO,BRANCH\n         TM    CATCOUNT,X'01'      EVEN?\n         BC    ALLON,RR491         NO,BRANCH\n         CLI   CATCOUNT,CAE        ALIAS?\n         BC    EQ,RR491            YES,BRANCH\n         IC    R1,CATCOUNT\n         N     R1,=X'000000F8'     CLEAR UNWANTED BITS\n         SRL   R1,1\n         LA    R1,INTAB(R1)        POINT AT INPUT DCB ADDRESS\n         MVC   INDCBA,0(R1)        MOVE ADDRESS\n         NI    CATCOUNT,X'07'      RESET INDEX BITS\n         CLI   CATCOUNT,X'06'      DUMMY FOR VCBPE?\n         BC    NE,RR491            NO,BRANCH\n         MVI   CATCOUNT,CVCBPE     RESET COUNT FIELD\nRR491    CLI   CATCOUNT,CILE       ILE OR IPE?\n         BC    NE,RR500            NO,BRANCH\n         CLI   CATNAME,X'FF'       ILE?\n         BC    NE,RR510            NO,BRANCH MUST BE IPE\n         LA    R1,RRRTTR           TTR OF THIS RECORD\n         LA    R2,RRKEY\n         LA    R3,VOLLDCB                                        EXCP01\n         LA    R15,WRITEC\n         BALR  R14,R15             WRITE THIS RECORD AGAIN\n         LA    R14,VOLLI1          POINT AT AREA FOR LEV ONE COUNT\n         CLI   RRLEV+1,X'02'       LEVEL 2\n         BC    GT,RR495            NO BRANCH\n         BC    LT,RR492            ONE,BRANCH\n         LA    R14,VOLLI2          POINT AT LEVEL 2 AREA\nRR492    LH    R15,0(R14)          COUNT OF BLOCKS AT THIS LEVEL\n         AH    R15,=H'1'           ADD ONE\n         STH   R15,0(R14)          SAVE\nRR495    CLC   CATTTR,=XL3'00'     ANY MORE?\n         BC    EQ,RR600            NO,END UP\n         MVC   RRRTTR,CATTTR       MOVE TTR FOR NEXT\n         LA    R15,READC\n         BALR  R14,R15             READ NEXT BLOCK\n         LA    R5,RRBUF+2          POINT AT FIRST ENTRY\n         B     RR490               GO CHECK IT\nRR500    CLI   CATCOUNT,CGIPE      GENERATION INDEX?\n         BC    NE,RR520\nRR510    L     R1,NNAME            POINT AT NEXT SPOT FOR NAME\n         ST    R1,RRNAME           SAVE IN RRWORK\n         MVI   0(R1),C'.'          SET .\n         MVC   1(8,R1),CATNAME     MOVE NAME\n         LA    R1,8(R1)            POINT PAST NAME\nRR512    CLI   0(R1),C' '          END?\n         BC    NE,RR513            YES,BRANCH\n         BCT   R1,RR512            NOT THE LAST CHAR YET\nRR513    AH    R1,=H'1'            POINT AT FIRST BLANK\n         ST    R1,NNAME            SAVE FOR NEXT LEVEL\n         LA    R1,CATTTR           POINT AT TTR\n         CLC   CATTTR,=XL3'000000' ANY?\n         BC    EQ,RR515            NO,DONT PROCESS\n         LH    R0,RRLEV            LOAD LEVEL\n         AH    R0,=H'1'            +1\n         LA    R15,RR\n         BALR  R14,R15             CALL RR FOR NEXT LEVEL,TTR CHANGED\nRR515    CLI   CATCOUNT,CGIPE      GENERATION INDEX?\n         BC    NE,RR517            NO,BRANCH\n         TM    FLAG,GDSMOVE+GDSCOPY MOVE OR COPY DUMMY DSCBS?\n         BC    ALLOFF,RR517        NO,BRANCH\n         LA    R15,GDSPROC         POINT AT SUBROUTINE\n         BALR  R14,R15             CALL IT\nRR517    L     R1,RRNAME\n         MVC   0(9,R1),=CL9' '     CLEAR LAST NAME AND .\n         ST    R1,NNAME            RESTORE\n         B     RR480               GO LOOK AT NEXT ENTRY\nRR520    CLI   CATCOUNT,CVCBPE     VCBPE?\n         BC    NE,RR530\n         XC    VCBPTTR,VCBPTTR\n         LA    R1,CATTTR           POINT AT FIRST TTR\nRR522    LA    R2,VCBKEY           POINT AT KEY\n         L     R3,INDCBA\n         LA    R15,READC\n         BALR  R14,R15             READ VCB\n         MVC   VCBTTRSV,CVCBNEXT-CATENTRY+VCBBUF SAVE TTR OF NEXTF00001\n         LA    R0,VCBPTTR          POINT AT VCB AREA\n         LA    R1,1                SET R1 TO PLUS\n         LA    R15,PUTC\n         BALR  R14,R15             WRITE VCB\n         LA    R1,VCBTTRSV         POINT AT TTR OF NEXT VCB      F00001\n         OC    0(3,R1),0(R1)       MORE?\n         BC    NZERO,RR522         YES,BRANCH\n         MVC   CATTTR,VCBPTTR      MOVE NEW TTR\n         B     RR480\nRR530    CLI   CATCOUNT,CCVPE      CVOL?\n         BC    EQ,RR550            YES,BRANCH\n         CLI   CATCOUNT,CAE        ALIAS?\n         BC    EQ,RR540            YES,BRANCH\n         CLI   CATCOUNT,CNCVPE     NEW CVOL?\n         BC    EQ,RR560            YES,BRANCH\n         CLI   CATCOUNT,CDSPE      DATA SET?\n         BC    LT,RR480\n         L     R15,VOLLDS          COUNT DATA SETS\n         AH    R15,=H'1'\n         ST    R15,VOLLDS          SAVE\n*              CODE COULD BE ADDED HERE TO CHANGE DEVICE TYPES\n         B     RR480\nRR540    GETMAIN R,LV=ALSIZE,SP=2  GET ALIAS AREA\n         USING ALENTRY,R1\n         MVC   ALNEXT,VOLALCHN     SAVE ALIAS CHAIN\n         ST    R1,VOLALCHN         CHAIN IN\n         MVC   ALTTR,RRRTTR        SAVE ADDRESS\n         MVC   ALNAME,CATNAME      SAVE ALIAS NAME\n         MVC   ALRNAME,CAENAME     SAVE REAL NAME\n         LR    R14,R5              POINT AT ENTRY\n         LA    R15,RRBUF           POINT AT BUFFER\n         SR    R14,R15\n         STH   R14,ALOFF           SAVE OFFSET INTO BUFFER\n         B     RR480\n         DROP  R1\nRR550    LA    R1,CCVPEVOL         POINT AT VOL\n         B     RR565\nRR560    LA    R1,CNCVPEVO         POINT AT VOL\nRR565    L     R2,CVOLCHAN         POINT AT CHAIN\n         USING CVOLD,R2\nRR570    LTR   R2,R2               ANY?\n         BC    ZERO,RR480          NO,END\n         CLC   CVOLDNAM,0(R1)      SAME?\n         BC    EQ,RR580            YES,BRANCH GO FIND NEW CVOL NAME\n         L     R2,CVOLDNXT\n         B     RR570               GO LOOK AT NEXT\nRR580    L     R2,CVOLDCHN         POINT AT NEW CVOLS\n         DROP  R2\n         USING CVNEW,R2\nRR585    CLC   CATNAME,CVNEWDSN    USE THIS ENTRY?\n         BC    LE,RR590            YES,BRANCH\n         L     R2,CVNEWNXT         LOOK AT NEXT\n         B     RR585\nRR590    CLI   CATCOUNT,CCVPE      CVPE OR NCVPE?\n         BC    EQ,RR595            CVPE,BRANCH\n         MVC   CNCVPEDT(10),CVNEWDEV MOVE DEVTYPE AND NAME\n         B     RR480\nRR595    MVC   CCVPEVOL,CVNEWNAM   MOVE NAME\n         B     RR480\n         DROP  R2\n*---------------------------------------------------------------------*\n*              ALL DONE AT THIS LEVEL\n*---------------------------------------------------------------------*\nRR600    LA    R1,RRRTTR\n         LA    R2,RRKEY\n         LA    R3,VOLLDCB                                        EXCP01\n         LA    R15,WRITEC\n         BALR  R14,R15             WRITE LAST BLOCK\n         CLI   RRLEV+1,X'01'       LEVEL ONE?\n         BC    NE,RR650            NO,BRANCH\n         TM    FLAG,COPY\n         BC    ALLON,RR650\nRR620    L     R8,VOLLNEXT         LOOK AT NEXT\n         LTR   R8,R8               ANYMORE?\n         BC    ZERO,RR650          NO,BRANCH\nRR630    TM    VOLLFLAG,VOLLKEEP   KEEP?\n         BC    ALLON,RR620         YES,ONLY NEED TO LOOK AT SPLIT\n         C     R8,VOLLRNXT         REAL VOLLIST?\n         BC    NE,RR620            NO,BRANCH\n         B     RR420               GO PROCESS THIS LEVEL\nRR650    L     R1,RRFSTTR          A(CALLERS TTR)\n         MVC   0(3,R1),RRSVTTR     SET TTR FOR CALLER\n         LH    R1,LEVEL\n         SH    R1,=H'1'\n         STH   R1,LEVEL\n         LR    R1,R13              POINT AT RR WORK\n         LA    R0,RRWKSIZE\n         L     R13,4(R13)          LOAD RETURN BASE\n         FREEMAIN R,LV=(0),A=(1)\n         RETURN (14,12),T\nRRCVNAME DS    CL8                 NAME USED FOR ADDING NEW CVOLS\n         DC    XL4'00000005'       TTR AND CATCOUNT FOR NCVPE\nRRCVDEV  DS    XL4                 DEVICE TYPE\nRRCVVOL  DS    CL6                 NEW CVOL NAME\n         EJECT\n*---------------------------------------------------------------------*\n*        CONSTANTS AND DATA AREA\n*---------------------------------------------------------------------*\nSAVEAREA DS    18F\n         PRINT NOGEN\nSYSIN    DCB   DDNAME=SYSIN,MACRF=(GL),LRECL=80,RECFM=FB,              X\n               BLKSIZE=3200,EODAD=EOFIN,DSORG=PS,SYNAD=SYNADPS      FJP\nSYSPRINT DCB   DDNAME=SYSPRINT,MACRF=(PM),LRECL=121,RECFM=FBA,         X\n               BLKSIZE=605,DSORG=PS,SYNAD=SYNADPS           FJP/01DEC77\n         PRINT GEN\nPATDCB   DCB   DDNAME=X,DSORG=PS,MACRF=(E),DEVD=DA,RECFM=F       EXCP01\nPRNTLINE DC    CL121'1 '\nTITLE1   DC    C'ARGONNE  NATIONAL  LABORATORY'\nTITLE2   DC    C'**  COPYCAT  12-77  **'\nTITLE3   DC    C'OS  CATALOG  UTILITY'\nERRMSG1  DC    C'ERR01 ERROR FOUND IN PARAMETER AT ''$'''\nERRMSG2  DC    C'ERR02 ERROR PROCESSING DDNAME=''XXXXXXXX'''\nERRMSG3  DC    C'ERR03 UNEXPECTED END OF FILE ON SYSIN'\nERRMSG4  DC    C'ERR04 NAME=XXXXXXXX NOT FOUND FOR ALIAS=XXXXXXXX'\nERRMSG5  DC    C'ERR05 ALIAS COUNT ERROR FOUND FOR NAME='\nERRMSG6  DC    C'ERR06 TO MANY INPUT DATASETS'\nERRMSG7  DC    C'ERR07 INDEX=XXXXXXXX FOUND ON VOLS=(XXXXXX,XXXXXX) THEX\n                ENTRY ON XXXXXX WILL BE USED'\nERRMSG8  DC    C'ERR08 NO INPUT CARDS FOUND'\nERRMSG9  DC    C'ERR09 XXXXXXXX FAILED WITH (XXX) ON XXXXXX FOR GDG MODX\n               EL DSCB='\nERRMSG10 DC    C'ERR10 MODEL DSCB FOR GDG DOES NOT HAVE ZERO EXTENTS DSX\n               N='\nERRMSG11 DC    C'ERR11 MODEL DSCB FOR GDG EXISTS ON OUTPUT VOLUME WITH X\n               DIFFERENT ATTRIBUTES FOR DSN='\nERRMSG12 DC    C'ERR12 ABEND - XXX - OCCURED. SEE SYSMSG. CURRENT OR LAX\n               ST NAME IS '\nERRMSG13 DC    C'ERR13 I/O ERROR - '\nERRMSGD  DC    C'CURRENT OR LAST NAME IS '\nERRMSG14 DC    C'ERR14 NO OUTPUT MASTER CARD WAS FOUND'\nERRMSG15 DC    C'ERR15 UNABLE TO ALLOCATE MINIMUM BUFFERS'       EXCP01\nHEAD1    DC    C'- OUTPUT STATISTICS'\nHEAD2    DC    C'0         LAST   LAST  CONTROL  DUMMY   BLOCKS  BLOCKSX\n                   DATA'\nHEAD3    DC    C'          TTR+1  USED  VOLUME   BLOCKS  AT LEV  AT LEVX\n                   SETS'\nHEAD4    DC    C'                 TTR+1 ENTRIES           ONE     TWO'\nMSGOK    DC    C'0  COMPLETION CODE - '\nWORKAREA DS    D\nMAINTTR  DC    XL3'000001'         TTR FOR START\nFLAG     DC    X'00'               FLAGS\nCOPY     EQU   X'80'               CONTROL RECORD FOR COPY\nDSSPLIT  EQU   X'40'               SPLIT DS IN LEVEL ONE\nDSKEEP   EQU   X'20'               KEEP DS AT HIGHEST LEVEL\nGDSMOVE  EQU   X'10'               MOVE GDG MODEL DSCBS\nGDSCOPY  EQU   X'08'               COPY GDG MODEL DSCBS\nCVOLCHAN DC    A(0)                CHAIN OV OLD CVOL NAMES\nVOLCHAIN DC    A(0)                CHAIN OF VOLLIST ENTRIES\nVOLLAST  DC    A(0)                ADDRESS OF LAST VOLLIST\nVOLKEEP  DC    A(0)                ADDR OF FIRST KEEP ENTRY\nVOLNAMEL DC    XL8'00'             HIGHEST NAME SO FAR\nRETCODE  DC    H'0'                RETURN CODE\n         DS    0H\nLEVTAB   DC    22XL(LEVTABL)'00'   ONE ENTRY FOR EACH LEVEL\n         DS    F                   DUMMY\nINTAB    DC    32A(0)              LIST OF DCBS FOR INPUT\nINDCBA   DC    A(INTAB)            ADDRESS OF CURRENT INPUT DCB\nLEVEL    DS    H                   CURRENT LEVEL\nINRLASTC DS    X                   COUNT FROM INLAST\nINRLAST  DC    A(0)                LAST ENTRY RETURNED BY INR\nINLOWNAM DS    CL8                 NAME SO FAR FOR INR\n         DS    0F\nVCBPTTR  DS    XL3                 TTR\n         DC    AL1(PCVCB)          SET THIS IS VCB PCAREA\nVCBKEY   DS    XL8\nVCBBUF   DS    XL256               BUFFER\nVCBTTRSV DS    XL3                 VCB TTR SAVE AREA             F00001\nMAXRECTK DC    H'0'                MAX REC/TRK ON ALL UNITS OPEN EXCP01\nMINBUFFS DC    H'1'                MIN BUFFS=INDDS+OUTDDS+1      EXCP01\nECBLISTR DC    A(RECB)             START OF ECBLIST              EXCP01\nECBLISTW DC    A(WECB1)            START OF ECB LIST FOR WRITES  EXCP01\n         DC    A(WECB2)                                          EXCP01\n         DC    X'80',AL3(WECB3)    LAST ECB                      EXCP01\nRECB     DC    F'0'                READ ECB                      EXCP01\nRIOB     DC    X'C2000000',A(RECB),8F'0' IOB                     EXCP01\n         DC    F'0'                                              EXCP01\nWECB1    DC    F'0'                WRITE ECB                     EXCP01\nWIOB1    DC    X'C0000000',A(WECB1),8F'0' IOB                    EXCP01\n         DC    F'0'                                              EXCP01\nWECB2    DC    F'0'                WRITE ECB                     EXCP01\nWIOB2    DC    X'C0000000',A(WECB2),8F'0' IOB                    EXCP01\n         DC    F'0'                                              EXCP01\nWECB3    DC    F'0'                WRITE ECB                     EXCP01\nWIOB3    DC    X'C0000000',A(WECB3),8F'0' IOB                    EXCP01\n         DC    F'0'                                              EXCP01\nFREEBUFQ DC    A(0)                FREE BUFFER QUEUE             EXCP01\nOUTBUFQ  DC    A(0)                OUTPUT BUFFER QUEUE           EXCP01\nUSEBUFQ  DC    A(0)                IN USE BUFFER QUEUE           EXCP01\nPATCCW   CCW   X'1D',*-*,X'80',8   WCKD -> CCHHRKDL              EXCP01\n         CCW   X'08',*-*,X'00',0        TIC                      EXCP01\n         DC    XL8'0000000000080100'    COUNT FIELD              EXCP01\n         CCW   X'00',*-*,X'00',264      -> KEY DATA              EXCP01\nMINCORE  DC    F'12288'            12K MIN FREE                  EXCP01\nGETMLA   DC    A(8),X'00FFFFF0'    GETMAIN LA LIST               EXCP01\nGETMA    DC    A(0)                ADDR OF BUFS FROM GETMAIN     EXCP01\nGETMS    DC    A(0)                SIZE OF BUFS FROM GETMAIN     EXCP01\n         LTORG\n         USING SETXX,R15                                         F00003\n               PRINT OFF\nSETXX    LA    R1,XXE\n         LA    R2,XX\n         LA    R0,32\nSETXXL   TR    0(32,R2),TR2TAB-240\n         BXLE  R2,R0,SETXXL\n         BR    R9\nTR2TAB   DC    C'  XX   X  '\n         DS    D\nXX       EQU   *\n         DC    C'01445689014456895641568989890100'\n         DC    C'02014702322456723083233312372300'\n         DC    C'87898743144310178945671444525464'\n         DC    C'83434347722456920505026655870145'\n         DC    C'82121263626898830165879865478955'\n         DC    C'10787892425401723456838908924561'\n         DC    C'01456895605501894016854995966800'\n         DC    C'52372382981201456895624562372358'\n         DC    C'97001103756345588901752808071666'\n         DC    C'02374447525345645617456745624566'\n         DC    C'07010102083266559102277700030011'\n         DC    C'62223383456789108183585394929110'\n         DC    C'01568811004956801551551100549090'\n         DC    C'01120008989892456348889942100145'\n         DC    C'00783956644443745389898987001144'\n         DC    C'87899745645887828211008892454488'\n         DC    C'92327289270102683787755663011919'\n         DC    C'62666266228882989247711002323311'\n         DC    C'89456664411900895461044560055566'\n         DC    C'04456689080902222012889244400115'\n         DC    C'85555668856982010755353564141441'\n         DC    C'45568989654013332441171115566440'\n         DC    C'52745145056053588389975544080988'\n         DC    C'02288556644012737555578888665556'\n         DC    C'01566489605144451455688996058410'\n         DC    C'02372441237002588211777444110590'\n         DC    C'02411312000292988242555744110546'\n         DC    C'52668763658782665263654101455665'\n         DC    C'12655247566353541717552265988996'\n         DC    C'82273556222111333456237745566655'\n         DC    C'01145689895556691918844188801489'\n         DC    C'42723782456244237552323242223456'\n         DC    C'03445663355352555243144113666345'\n         DC    C'47775557878783011117231117773000'\n         DC    C'02145552552247113252541112574144'\n         DC    C'02323347111311237743777753662666'\n         DC    C'44411005055016548568658889851400'\n         DC    C'02372310044050323055266632745645'\n         DC    C'00074445456452110202300245471111'\n         DC    C'00128889686545572111245889245501'\n         DC    C'88934411565652001300789893456669'\n         DC    C'99874488050155232897325627374401'\n         DC    C'01465544100445986985461450548698'\n         DC    C'02323344323654723556656662323214'\n         DC    C'48857883555312111744411004568358'\n         DC    C'14475566673555232356273114425656'\n         DC    C'89789442000388991348085191309090'\n         DC    C'99700114232456237898965445244114'\n         DC    C'45655880808188119004404550506606'\n         DC    C'02323244434144431586859442111255'\n         DC    C'88987899328100220011445566353555'\n         DC    C'88938989571441570044565685178585'\n         DC    C'44256565621114520011448958212111'\n         DC    C'01345411232114327885566863141344'\n         DC    C'56401456056055066541014560546896'\n         DC    C'11442894333555777444777454545111'\n         DC    C'45623012000262655363451451458541'\n         DC    C'44757851023011122553322458896600'\n         DC    C'82727787888212066342881245588968'\n         DC    C'11007015772566277444323485689999'\nXXE      EQU   *\n         DC    C'01456450019181414564561458585689'\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIX1": {"ttr": 2057, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "./ CHANGE      SEQFLD=738,NAME=COPYCAT\n         EJECT  ,                                               ESTAE01\n         IHASDWA ,                                              ESTAE01\n         ESTAE STAEEXIT,CT,                                     ESTAE01X\n               PURGE=QUIESCE       QUIESCE I/O REQUESTS         ESTAE01\nTERMAB01 NOP   TERM007             SET TO BR IF ABEND           ESTAE01\nSTAEEXIT DS    0H                  ENTRY TO ESTAE EXIT ROUTINE  ESTAE01\n         STM   R0,R15,STAEXRGS-STAEEXIT(R15) FOR DEBUG          ESTAE01\n         CH    R15,STAEY12-STAEEXIT(,R15)   SDWA PRESENT??      ESTAE01\n         BC    NE,STAE010-STAEEXIT(,R15)    BR IF YES           ESTAE01\n*                                                               ESTAE01\n*        IF AN SDWA IS NOT PRESENT, SET RETURN CODE ZERO TO     ESTAE01\n*        ALLOW THE ABEND TO PROCEED AN DO NO MORE PROCESSING.   ESTAE01\n         SR    R15,R15             CONTINUE WITH ABEND          ESTAE01\n         BR    R14                 RETURN                       ESTAE01\n*                                                               ESTAE01\n*        AN SDWA IS PRESENT, CONTINUE PROCESSING.               ESTAE01\nSTAE010  DS    0H                  CONTINUE WITH STAE EXIT      ESTAE01\n         STM   R14,R12,12(R13)     SAVE CALLING REGISTERS       ESTAE01\n         LR    R4,R1               SAVE SDWA ADDRESS            ESTAE01\n         MVC   STAEWK(2),SDWACMPC-SDWA(R4)   ABEND CODE         ESTAE01\nSTAE100  DS    0H                                               ESTAE01\n         SETRP RC=0,               CONTINUE WITH ABEND          ESTAE01X\n               REGS=(14,12)        RESTORE REGISTERS            ESTAE01\nSTAE150  DS    0H                                               ESTAE01\n         SETRP RC=4,               REQUEST RETRY ROUTINE        ESTAE01X\n               DUMP=NO,            SUPPRESS ERROR DUMP          ESTAE01X\n               RETADDR=STAERTRY,   -> RETRY ROUTINE             ESTAE01X\n               REGS=(14,12)        RESTORE REGISTERS            ESTAE01\nSTAERTRY DS    0H                  START RETRY ROUTINE          ESTAE01\n         LM    R10,R13,STAEBASE-STAERTRY(R15)  RELOAD BASE REGS ESTAE01\n         LR    R4,R1               SAVE SDWA ADDRESS            ESTAE01\n         ESTAE 0                   CANCEL ESTAE EXIT            ESTAE01\n         L     R1,SDWAIOBR-SDWA(,R4)    -> IOB RESTORE CHAIN    ESTAE01\n         LTR   R1,R1               IS RESTORE POINTER THERE??   ESTAE01\n         BC    ZERO,STAE210        BR AROUND SVC IF NOT         ESTAE01\n         SVC   17                  RESTORE I/O                  ESTAE01\nSTAE210  DS    0H                  BYPASS RESTORE SVC           ESTAE01\n         SPACE 1                                                ESTAE01\n         L     R0,SDWASPID-SDWA(,R4)    SP & LN FOR FREEMAIN    ESTAE01\n         LR    R1,R4                    SDWA ADDRESS            ESTAE01\n         FREEMAIN R,LV=(0),A=(1)        RELEASE SDWA            ESTAE01\n         OI    TERMAB01+1,X'F0'    CHANGE NOP TO BR             ESTAE01\n         SPACE 1                                                ESTAE01\n         SPACE 2                                                ESTAE01\nSTAEXRGS DC  16A(0)                REGS ON ENTRY TO EXIT        ESTAE01\nSTAEY12  DC    Y(12)               STAE EXIT ENTRY CODE TEST    ESTAE01\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FIX2": {"ttr": 2059, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "./ CHANGE      SEQFLD=738,NAME=COPYCAT\n         LA    R15,WRITEB          -> ACTIVE WRITES CHECK RTN    XCP200\n         BALR  R14,R15             GO REDRIVE I/O                XCP200\nWTRB005  LA    R9,ECBLISTW         POINT AT LIST OF ECB ADDRS    XCP200X\n                                   (SETS REPROCESSING INDIC OFF) XCP200\n         TM    WRECB,X'40'         POSTED?                       XCP200\n         BC    ALLON,WTRB021       YES, CHECK COMPLETION CODE    XCP200\n         L     R3,BUFADCB          -> DCB & VOLLIST              XCP200\n         TM    VOLLFLAG-VOLLIST(R3),VOLLSECN  NEED TO WAIT????   XCP200\n         BC    ALLON,WTRB020       YES, ISSUE WAIT SVC           XCP200\n*              THIS LINE DELETED                                 XCP200\n*              THIS LINE RESERVED                                XCP200\n*              THIS LINE RESERVED                                XCP200\n         B     WTRB070             NO,BRANCH                     XCP200\nWTRB020  WAIT  ECB=WRECB           COMPLETE I/O BEFORE SVC55     XCP200\nWTRB021  CLI   WRECB,X'7F'         DID I/O COMPLETE OK??         XCP200\n         TM    VOLLFLAG-VOLLIST(R3),VOLLSECN    POSS ADDL XTNTS? XCP200\n         BC    ALLOFF,*+L'*+4      BR IF NOT                     XCP200\n         O     R9,=X'80000000'     SET REPROCESSING INDICATOR    XCP200\nWTRB070  AL    R9,=F'4'            -> NEXT ECB POINTER           XCP200\n         LTR   R9,R9               IS REPROCESSING INDICATOR SET?XCP200\n         BC    MINUS,WTRB005       YES, LOOK AT IOB'S AGAIN      XCP200\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OAC1": {"ttr": 2061, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "./ CHANGE      SEQFLD=738,NAME=COPYCAT\n*  08/09/82 - UCLA/OAC - MAS - ADD 3375/3380 SUPPORT            DEV3380\n         L     R14,=X'01080100'   CATALOG RKDD                  DEV3380\n         TRKCALC FUNCTN=TRKCAP,TYPE=VOLLDEVT+3,RKDD=(R14),      DEV3380X\n               REGSAVE=YES                                      DEV3380\n         LTR   R15,R15            TRKCALC WORKED?               DEV3380\n         BC    NZERO,DCBERR       BIF TRKCALC FAILED            DEV3380\n         LR    R1,R0              # RECORDS / TRK               DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n*                        THIS LINE DELETED BY                   DEV3380\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OAC2": {"ttr": 2063, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "./ CHANGE      SEQFLD=738,NAME=COPYCAT\n./ NUMBER INSERT=YES,SEQ1=00001155,NEW1=00001156,INCR=1\n*  08/09/82 - UCLA/OAC - MAS - ADD HASH CVOL SUPPORT            HASH001\n./ NUMBER INSERT=YES,SEQ1=00003119,NEW1=00003120,INCR=1\n*                                                               HASH001\n*  UCLA/OAC MODIFICATIONS FOR HASH CVOL ROUTING SUPPORT.        HASH001\n*                                                               HASH001\n*  WE RUN A MOD IN CATALOG WHICH BYPASSES THE MASTER CATALOG    HASH001\n*  LOOKUP FOR MOST HIGH LEVEL INDEXES. THIS REMOVES THE         HASH001\n*  REQUIRMENT TO ADD AN ALIAS POINTER FOR EACH NEW USER AND     HASH001\n*  REDUCES THE EXPOSURE TO THE MASTER CATALOG.  THE PERFORMANCE HASH001\n*  IS ALSO BETTER.                                              HASH001\n*                                                               HASH001\n*  THESE HASH MODS ALLOW SPLITTING THE CATALOGS VIA A HASHING   HASH001\n*  PSUEDO-RANDOM WAY, THUS EQUALIZING THE LOAD.                 HASH001\n*                                                               HASH001\n*  A NEW CONTROL CARD IS ACCEPTED BY THIS VERSION OF COPYCAT.   HASH001\n*                                                               HASH001\n*  |NAME| HASH <MODULE NAME>                                    HASH001\n*                                                               HASH001\n*    <MODULE NAME> - HASHING ROUTINE LOAD MODULE NAME           HASH001\n*                                                               HASH001\n* HASH ROUTINE LINKAGE:                                         HASH001\n*                                                               HASH001\n* ENTRY: R0  - MAX LENGTH OF INDEX (STRING LENGTH)              HASH001\n*        R1  - @ HIGH LEVEL INDEX FOLLOWED BY '.' OR ' '        HASH001\n*        R13 - @ 72 BYTE SAVE AREA                              HASH001\n*        R14 - RETURN ADDRESS                                   HASH001\n*        R15 - @ HASH ROUTINE                                   HASH001\n*                                                               HASH001\n* EXIT:  R15 - RETURN CODE (CONDITION CODE SET)                 HASH001\n*              0 - HASH SUCCESSFUL, R1 = @ CL6 CVOL             HASH001\n*              4 - HASH UNSUCCESSFUL                            HASH001\n*                  (COPYCAT WILL USE NORMAL SPLIT LOGIC         HASH001\n*                    AS DETERMINED BY THE OUTPUT CARDS)         HASH001\n*                                                               HASH001\n         SPACE 1                                                HASH001\n         MACRO                                                  HASH001\n&LBL     CCHASH &KEY,&REG                                       HASH001\n.*  &KEY = @ CL8 NAME TO LOOK UP (OR HASH)                      HASH001\n.*  &REG = REGISTER TO RETURN @ VOLLIST (R1-R13 OR R14 ONLY)    HASH001\n&LBL     STM   R14,R0,RRHASHSV    TEMP SAVE R14-R0              HASH001\n         LA    R0,&KEY            @ KEY TO HASH/SEARCH          HASH001\n         L     R15,=A(HASHSUB)    @ HASH/SEARCH RTN             HASH001\n         BALR  R14,R15                                          HASH001\n         LR    &REG,R15           SET RETURN REGISTER           HASH001\n         AIF   ('&REG' EQ 'R14').XR14                           HASH001\n         LM    R14,R0,RRHASHSV    RESTORE TEMP REGS             HASH001\n         MEXIT                                                  HASH001\n.XR14    LM    R15,R0,RRHASHSV+4  RESTORE TEMP REGS             HASH001\n         MEND                                                   HASH001\n*--- PROCESS \"HASH <MODULE NAME>\" CONTROL CARD                  HASH001\n         CLC   OPER,=CL8'HASH'    HASH REQUEST?                 HASH001\n         BNE   CON015A            BIF NOT HASH REQUEST          HASH001\n         CLI   HASHMOD,C' '       ALREADY HASH?                 HASH001\n         BNE   ERROROP            BIF DUP HASH, ERROR           HASH001\n         LA    R2,HASHMOD         POINT AT MODULE NAME SPOT     HASH001\n         BAL   R9,SCAN8           SCAN FOR MODULE NAME          HASH001\n         BZ    ERROR              BIF NAME MISSING, ERROR       HASH001\n         LOAD  EPLOC=HASHMOD      LOAD MODULE                   HASH001\n         ST    R0,HASHEPA         SAVE @ HASH ROUTINE           HASH001\n         B     CON015              AND CONTINUE                 HASH001\nCON015A  DC    0H'0'                                            HASH001\nRR135    CCHASH CATNAME,R8        FIND CVOL FOR NAME      (REP) HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\nRR160    CCHASH CAENAME,R8        FIND CVOL FOR NAME      (REP) HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n         CCHASH CATNAME,R8        FIND CVOL FOR NAME      (REP) HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\nRR185    CCHASH CATNAME,R14       FIND CVOL FOR NAME      (REP) HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\nRR215    CCHASH CATNAME,R8        FIND CVOL FOR NAME      (REP) HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\nRR260    CCHASH CAENAME,R8        FIND CVOL FOR NAME      (REP) HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\n*              THIS LINE DELETED BY                             HASH001\nRRHASHSV DC    3F'0'              R14-R0 TEMP SAVE              HASH001\n./ NUMBER INSERT=YES,SEQ1=02018000,NEW1=02018010,INCR=10\n         EJECT ,                                                HASH001\n         PUSH USING                                             HASH001\n         DROP R8                  VOLLIST                       HASH001\n*-------------------------------------------------------------* HASH001\n*                                                             * HASH001\n* HASHSUB - SUBROUTINE USED BY RR TO DETERMINE CVOL FOR       * HASH001\n*           NAME FOUND IN CATALOG.  FIRST TRYS HASH, THEN     * HASH001\n*           SEARCH VOLLIST-VOLLNAME'S.                        * HASH001\n*                                                             * HASH001\n* ENTRY: R15 - @ HASHSUB                                      * HASH001\n*        R14 - RETURN ADDRESS                                 * HASH001\n*        R13 - ?                                              * HASH001\n*        R0  - @ CL8 NAME TO FIND CVOL FOR                    * HASH001\n*                                                             * HASH001\n* EXIT:  R15 - @ VOLLIST ENTRY FOR CVOL.                      * HASH001\n*                (R1 - R13 RESTORED).                         * HASH001\n*                                                             * HASH001\n*-------------------------------------------------------------* HASH001\n         SPACE 1                                                HASH001\nHASHSUB  STM   R1,R14,HASHSAV     SAVE REGS                     HASH001\n         LR    R12,R15                                          HASH001\n         USING HASHSUB,R12                                      HASH001\n         LA    R13,HASHSAV2       @ SAVE AREA                   HASH001\n         L     R3,=A(PRNTLINE)                                  HASH001\n         USING PRNTLINE,R3                                      HASH001\n         LR    R2,R0              @ NAME                        HASH001\n         MVC   HASHWRK(8),0(R2)   COPY NAME                     HASH001\n         LA    R1,HASHWRK                                       HASH001\n         LA    R0,9               MAX STRING LENGTH             HASH001\n         ICM   R15,15,HASHEPA     @ HASH ROUTINE                HASH001\n         BZ    HASHSUB2           BIF NO HASH ROUTINE           HASH001\n         BALR  R14,R15            TRY FOR HASH                  HASH001\n         BNZ   HASHSUB2           BIF NOT HASHED INDEX          HASH001\n* R1 = @ CL6 OF CVOL TO USE                                     HASH001\n         L     R15,VOLCHAIN       @ 1ST ON VOLLISTS             HASH001\n         USING VOLLIST,R15                                      HASH001\nHASHSUB1 CLC   VOLLVOL,0(R1)      THIS THE CVOL?                HASH001\n         BE    HASHSUB9           BIF CVOL FOUND                HASH001\n         ICM   R15,15,VOLLNEXT    @ NEXT (OR ZERO)              HASH001\n         BNZ   HASHSUB1           BIF NEXT CVOL EXISTS          HASH001\n* ---              HASH RTN RETURNED UNKNOWN CVOL       --- *   HASH001\n         MVC   PRNTLINE+1(L'ERRMSG20),ERRMSG20                  HASH001\n         MVC   PRNTLINE+1+L'ERRMSG20(6),0(R1)   UNKNOWN CVOL    HASH001\n         MVC   PRNTLINE+1+L'ERRMSG20+8(3),=C'FOR'               HASH001\n         MVC   PRNTLINE+1+L'ERRMSG20+13(8),0(R2) NAME           HASH001\n         BAL   R9,PUTSP           PRINT ERROR MSG               HASH001\n* ---             PROCESS NON-HASHED NAME               --- *   HASH001\nHASHSUB2 L     R15,VOLCHAIN       @ 1ST ON VOLLISTS             HASH001\n         CLC   HASHWRK,VOLLNAME   <= NAMES IN THIS VOL?         HASH001\n         BNH   HASHSUB9           BIF CVOL FOUND                HASH001\n         L     R15,VOLLNEXT       @ NEXT (NEVER ZERO)           HASH001\n         B     HASHSUB2                                         HASH001\nHASHSUB9 LM    R1,R14,HASHSAV     RESTORE REGS                  HASH001\n         BR    R14                                              HASH001\n         POP   USING                                            HASH001\n         SPACE 1                                                HASH001\nHASHMOD  DC    CL8' '             HASH MODULE NAME (OR BLANKS)  HASH001\nHASHEPA  DC    A(0)               @ HASH MODULE (OR ZERO)       HASH001\nHASHSAV  DC    16F'0'             REG SAVE R1-R14               HASH001\nHASHSAV2 DC    18F'0'             72 BYTE SAVEAREA              HASH001\nHASHWRK  DC    CL8' ',C' '        HASH WORK AREA (HLI, DELIM)   HASH001\nERRMSG20 DC    C'ERR20 UNKNOWN CVOL FROM HASH RTN, CVOL '       HASH001\n         LTORG ,                                                HASH001\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT037/FILE037.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT037", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}