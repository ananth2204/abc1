{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011928000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3350802, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE401.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3350802, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3350802, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE401.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x005\\x01'", "DS1TRBAL": "b'\\xe2\\xfa'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xd9\\x00\\x04\\x02\\xdc\\x00\\x0c\\x006'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"6\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:36:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 440    FILE:  401\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT440.FILE401\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 13 MEMBERS COUNTED; CUMULATIVE SIZE IS 31,791 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/22/01    22:36:52    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x01m\\x01m\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 365, "newlines": 365, "modlines": 0, "user": "SPIT360"}, "text": "SPITBOL 360 README FILE\n-----------------------\n\n11/08/2001  Updated for Hercules AWS installation (Bob Goldberg)\n 8/20/2001  Initial Version (Bob Goldberg)\n\n\n\nReadme Contents\n---------------\n\nWhat is SPITBOL 360?\n\nInstallation Overview\n\nGeneral Installation\n\nHercules AWS Intallation\n\nReassembling the Compiler\n\nAcknowledgments\n\n\n\nWhat is SPITBOL 360? [*]\n------------------------\n\nSPITBOL 360 is an implementation of the SNOBOL4 programming language\nfor use on IBM 360 compatible computers. SPITBOL is considerably\nsmaller than the original implementation of SNOBOL4 and has\nexecution speeds up to ten times faster. For certain programs,\nnotably those with in-line patterns, the gain in speed may be even\ngreater.\n\nUnlike SIL SNOBOL4[**], which is an interpreter, SPITBOL is a true\ncompiler which generates executable machine code. Of course, the\ncomplexity of the SNOBOL4 language dictates that system subroutines\nbe used for many common functions.\n\nSPITBOL can be run as an 'in-core' 'load-and-go' system like\nWATFIV, where programs are executed as soon as they are compiled.\nAlternately, the compiler can generate object modules that can be\nlinked with a run-time library to create load modules for later\nexecution.\n\nSPITBOL 360 was originally distributed under license, for a fee.[***]\nEffective November, 2001, SPITBOL 360 will be distributed under the\nGeneral Public License (GPL), for no fee.\n\nTo obtain current information and distribution files for SPITBOL 360,\nvisit:\n\n    http://www.snobol4.com\n\n\n----\n\n[*] SPITBOL = SPeedy ImplemenTation of SNOBOL4\n              --     -       -            ---\n\n[**] The original SNOBOL4 implementation from Bell Telephone\nLaboratories was developed by R. E. Griswold and I. Polonsky, the\ndesigners of the SNOBOL4 programming language. Thus, this reference\nimplementation is often referred to as BTL SNOBOL4. In the early\n1970s, after Griswold left BTL for The University of Arizona and\ncontinued SNOBOL4 distribution from there, this implementation\ngained another name: SIL SNOBOL4. (SIL = SNOBOL4 Implementation\nLanguage)\n\n[***] SPITBOL 360 was distributed from 1971 until 1984 when it was\nsuperseded by SPITBOL 370.\n\n\n\nInstallation Overview\n---------------------\n\nThe next two sections describe the installation procedures for\nSPITBOL 360. The first section, \"General Installation,\" describes\nan installation procedure that can be used on both \"real\" mainframes\nas well as Hercules emulated mainframes. A simplified Hercules\ninstallation, based on an AWS tape file, is described in the\n\"Hercules AWS Installation\" section. Users following the Hercules\nAWS installation procedure should still read the \"General\nInstallation\" section for perspective.\n\n\n\nGeneral Installation\n--------------------\n\nTake care when using a file transfer programs to transfer these\ndistribution files between machines! You MUST use a binary transfer\nmode to move each of the EBCDIC files. For example, if using FTP,\nset mode to Binary.\n\nBelow is a list of the files contained in the distribution ZIP/TAR\nfile. All files are EBCDIC except for the first two files which are\nprovided in ASCII as a convenience to users.\n\n\n  File Name        Contents\n  ---- ----------  -------------------------------------------------\n    1  README.TXT  (ASCII) Readme file (translation of README)\n\n    2  GPL.TXT     (ASCII) General Public License text (translation\n                   of GPL)\n\n    3  README      Readme file\n\n    4  GPL         General Public License\n\n    5  SBOLOBJ     Object files to create SPITBOL compiler\n\n    6  LINKSBOL    Sample JCL to link SPITBOL compiler\n\n    7  TESTPGMS    Compiler test programs\n\n    8  TESTSBOL    Sample JCL to run compiler test programs\n\n    9  SLIBOBJ     Object files to create SPITPROG runtime\n\n   10  LINKSPRG    Sample JCL to link SPITPROG runtime\n\n   11  OSINT       OSINT assembler source\n\n   12  SPITBOL     SPITBOL assembler source\n\n   13  TFSV23      TFs for SPITBOL and SPITPROG\n\n\nALL EBDCIC distribution files are sequential card image files, with\nDCB attributes RECBM=FB and LRECL=80.\n\n\nInstallation is quite simple: only four files need be loaded onto\nyour system, followed by a link edit and test run.\n\n\n  Step 1: Create datasets\n\n  Create two datasets:\n\n  (1) a SPITBOL.SRC PDS (SOURCE LIB) to receive object files, sample\n      JCL, and test programs\n\n  (2) a SPITBOL.LOAD PDS (LOAD LIB) to receive the output of the\n      linkage editor\n\n\n  Step 2: Populate the SPITBOL PDS\n\n  Load the following files into your SPITBOL PDS:\n\n\n    5  SBOLOBJ    Object files to create SPITBOL compiler\n\n    6  LINKSBOL   Sample JCL to link SPITBOL compiler\n\n    7  TESTPGMS   Compiler test programs\n\n    8  TESTSBOL   Sample JCL to run compiler test programs\n\n\n  Step 3: Link SPITBOL Compiler\n\n  Member LINKSBOL contains sample JCL to link the SPITBOL compiler.\n  Examine, modify, and run.\n\n    //.. JOB ....\n    // EXEC LKED\n    //SYSLMOD   DD  DSN=SPITBOL.LOAD,DISP=SHR\n    //OBJS      DD  DSN=SPITBOL.SRC,DISP=SHR\n    //SYSIN     DD  *\n     INCLUDE OBJS(SBOLOBJ)\n     ENTRY OSINT\n     NAME SPITBOL(R)\n    /*\n\n\n  Step 4: Test compiler\n\n  Run the test programs provided with the distribution. Note that you\n  only have to run the compiler once; SPITBOL 360 supports its own\n  batching of jobs. Member TESTSBOL contains sample JCL to run the\n  test programs. Examine, modify and run.\n\n\n    //.. JOB ....\n    // EXEC PGM=SPITBOL,REGION=512K\n    //STEPLIB   DD  DSN=SPITBOL.LOAD,DISP=SHR\n    //SYSPRINT  DD  SYSOUT=A\n    //SYSPUNCH  DD  DUMMY\n    //SYSIN     DD  DSN=SPITBOL.SRC(TESTPGMS),DISP=SHR\n\n  SPITBOL 360 is happiest in regions of 192K or more.\n\n\n  You're done! ENJOY!\n\n\n  Optional Step 5: Link SPITPROG Runtime Library\n\n  This step is optional.\n\n  SPITPROG is needed only if you plan to create load modules from your\n  SPITBOL programs. Since SPITBOL 360 is a load-and-go compiler,\n  linking of compiled programs is not required for them to be run.\n\n  Load the following files into your SPITBOL PDS:\n\n    9  SLIBOBJ    Object files to create SPITPROG runtime\n\n   10  LINKSPRG   Sample JCL to link SPITPROG runtime\n\n  Member LINKSLIB contains sample JCL to link the SPITBOL runtime\n  library. Examine, modify, and run.\n\n    //.. JOB ....\n    // EXEC LKED\n    //SYSLMOD   DD  DSN=SPITBOL.LOAD,DISP=SHR\n    //OBJS      DD  DSN=SPITBOL.SRC,DISP=SHR\n    //SYSIN     DD  *\n     INCLUDE OBJS(SLIBOBJ)\n     ENTRY OSINT\n     NAME SPITPROG(R)\n    /*\n\n  To compile and link a SPITBOL program:\n\n    //.. JOB ....\n    // EXEC PGM=SPITBOL\n    //STEPLIB   DD  DSN=SPITBOL.LOAD,DISP=SHR\n    //SYSPRINT  DD  SYSOUT=A\n    //SYSPUNCH  DD  DUMMY\n    //SYSOBJ    DD  DSN=&OBJ,UNIT=...,SPACE=(...),\n    //              DCB=(RECFM=FB,LRECL=80,BLKSIZE=1600),DISP=(NEW,PASS)\n    //SYSIN     DD  *\n    -NOEXECUTE\n    <program goes here>\n    /*\n    // EXEC LKED\n    //SYSLMOD   DD  DSN=<your load lib>,DISP=SHR\n    //LIB       DD  DSN=SPITBOL.LOAD,DISP=SHR\n    //OBJ       DD  DSN=&OBJ,DISP=(OLD,DELETE)\n    //SYSIN     DD  *\n     INCLUDE LIB(SPITPROG)\n     INCLUDE OBJ\n     ENTRY OSINT\n     NAME FOO\n    /*\n\n  See SPITBOL Newsletter #1, which is contained in the SPITBOL 360\n  Manual PDF file, for the original instructions circa 1971.\n\n\n\nHercules AWS Installation\n-------------------------\n\nIMPORTANT! You MUST have Hercules 2.14a or later in order to run\nSPITBOL 360. Hercules 2.14a includes a fix to its floating point\ninstruction emulation that is required for SPITBOL to execute\nproperly.\n\n\nBelow is a list of the files contained in the distribution ZIP/TAR\nfile.\n\n  File Name          Contents\n  ---- ------------  ----------------------------------------------\n    1  README.TXT    (ASCII) Readme file\n\n    2  GPL.TXT       (ASCII) General Public License text\n\n    3  SPT-LOAD.JCL  (ASCII) JCL to load files from AWS tape file\n\n    4  SPT-LINK.JCL  (ASCII) JCL to link SPITBOL load module\n\n    5  SPT-TEST.JCL  (ASCII) JCL to test SPITBOL\n\n    6  SPITBOL.AWS   AWS file representing unlabelled tape (NL)\n                     that contains files 3 to 13, in order, from\n                     the standard distribution (see list above)\n\n\n  Step 1: Load files from AWS tape onto disk\n\n  Inspect SPT-LOAD.JCL and modify the JCL statements (dataset names,\n  etc.) as necessary. Mount the AWS tape file and submit SPT-LOAD.JCL\n  to a job reader.\n\n\n  Step 2: Link SPITBOL compiler\n\n  Inspect SPT-LINK.JCL and modify the JCL statements (dataset names,\n  etc.) as necessary. Mount the AWS tape file and submit SPT-LINK.JCL\n  to a job reader.\n\n\n  Step 3: Test compiler\n\n  Inspect SPT-TEST.JCL and modify the JCL statements (dataset names,\n  etc.) as necessary. Mount the AWS tape file and submit SPT-TEST.JCL\n  to a job reader.\n\n  You're done. Enjoy!\n\n\nNote about floating point exceptions: When running SPITBOL 360 on\nHercules, Hercules may log a number of floating point exceptions.\nDon't be alarmed! SPITBOL 360 uses these exceptions to control\nexecution; they are to be expected.\n\n\n\nReassembling the Compiler\n-------------------------\n\nAlthough complete source for the SPITBOL 360 compiler is provided\nas part of this distribution, DON'T reassemble it unless you're\ncomfortable handling these issues:\n\nASCII Conversions. For those who are planning to convert the EBCDIC\nsource to ASCII and then back to EBCDIC for reassembly, be advised\nthat many EBCDIC to ASCII conversions fail to translate all\ncharacters properly. For example, the not and vertical bar characters\nare often improperly translated.\n\nBinary Characters. There are instances of binary, non-printing,\nEBCDIC characters in the assembly source.\n\nCompiler/Library Assembly. Be sure to set up the DEFLMOD source\nlibrary member accordingly.\n\nTemporary Fixes (TFs). Modifying instructions or data in the assembly\nsource may affect CSECT offsets. If so, you will need to adjust the\noffsets in V23TFS. If you're intent on modifying the compiler's\nsource, consider obtaining the SPITBOL 370 distribution which does\nnot require any patches.\n\nIf you do reassemble the compiler or library, you must reapply the\nTFs contained in file V23TFS. These TFs have already been applied\nto the object files provided with the distribution, so this step is\nnot part of the installation procedure described above.\n\n\n\nAcknowledgments\n---------------\n\nThanks to Robert Dewar and Ken Belcher for allowing me to re-release\nSPITBOL 360 under the GPL for all to use and study.\n\nThanks to Bob Lerche for helping me validate this release on a real\nIBM mainframe system.\n\nThanks to Jay Jaeger and Jay Maynard, both of whom validated this\nrelease on Hercules. Jay Jaeger also created the AWS tape file to\nmake life simpler for Hercules users.\n\n  Bob Goldberg\n  8 Nov 2001\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE401": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x009\\x00\\x99\\x08?\\x01\\x012o\"5\\x00P\\x00+\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2001-11-22T22:35:39", "lines": 80, "newlines": 43, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 401 is from Bob Goldberg and contains SPITBOL 360, the    *   FILE 401\n//*           earlier implementation of SPITBOL, which is a         *   FILE 401\n//*           compiler version of SNOBOL 4.                         *   FILE 401\n//*                                                                 *   FILE 401\n//*           email:  \"Bob Goldberg\" <gman_bob@yahoo.com>           *   FILE 401\n//*                   \"Bob Goldberg\" <gman_bob@pacbell.net>         *   FILE 401\n//*                                                                 *   FILE 401\n//*      SPITBOL 360 $README FILE                                   *   FILE 401\n//*      ------------------------                                   *   FILE 401\n//*                                                                 *   FILE 401\n//*      11/08/2001  Updated for Hercules AWS installation          *   FILE 401\n//*                  (Bob Goldberg)                                 *   FILE 401\n//*       8/20/2001  Initial Version (Bob Goldberg)                 *   FILE 401\n//*                                                                 *   FILE 401\n//*      Readme Contents                                            *   FILE 401\n//*      ---------------                                            *   FILE 401\n//*                                                                 *   FILE 401\n//*      What is SPITBOL 360?                                       *   FILE 401\n//*                                                                 *   FILE 401\n//*      Installation Overview                                      *   FILE 401\n//*                                                                 *   FILE 401\n//*      General Installation                                       *   FILE 401\n//*                                                                 *   FILE 401\n//*      Hercules AWS Intallation                                   *   FILE 401\n//*                                                                 *   FILE 401\n//*      Reassembling the Compiler                                  *   FILE 401\n//*                                                                 *   FILE 401\n//*      Acknowledgments                                            *   FILE 401\n//*                                                                 *   FILE 401\n//*      What is SPITBOL 360? [*]                                   *   FILE 401\n//*      ------------------------                                   *   FILE 401\n//*                                                                 *   FILE 401\n//*      SPITBOL 360 is an implementation of the SNOBOL4            *   FILE 401\n//*      programming language for use on IBM 360 compatible         *   FILE 401\n//*      computers. SPITBOL is considerably smaller than the        *   FILE 401\n//*      original implementation of SNOBOL4 and has execution       *   FILE 401\n//*      speeds up to ten times faster. For certain programs,       *   FILE 401\n//*      notably those with in-line patterns, the gain in speed     *   FILE 401\n//*      may be even greater.                                       *   FILE 401\n//*                                                                 *   FILE 401\n//*      Unlike SIL SNOBOL4[**], which is an interpreter,           *   FILE 401\n//*      SPITBOL is a true compiler which generates executable      *   FILE 401\n//*      machine code. Of course, the complexity of the SNOBOL4     *   FILE 401\n//*      language dictates that system subroutines be used for      *   FILE 401\n//*      many common functions.                                     *   FILE 401\n//*                                                                 *   FILE 401\n//*      SPITBOL can be run as an 'in-core' 'load-and-go' system    *   FILE 401\n//*      like WATFIV, where programs are executed as soon as they   *   FILE 401\n//*      are compiled.  Alternately, the compiler can generate      *   FILE 401\n//*      object modules that can be linked with a run-time          *   FILE 401\n//*      library to create load modules for later execution.        *   FILE 401\n//*                                                                 *   FILE 401\n//*      SPITBOL 360 was originally distributed under license,      *   FILE 401\n//*      for a fee.[***] Effective November, 2001, SPITBOL 360      *   FILE 401\n//*      will be distributed under the General Public License       *   FILE 401\n//*      (GPL), for no fee.                                         *   FILE 401\n//*                                                                 *   FILE 401\n//*      To obtain current information and distribution files       *   FILE 401\n//*      for SPITBOL 360, visit:                                    *   FILE 401\n//*                                                                 *   FILE 401\n//*          http://www.snobol4.com                                 *   FILE 401\n//*                                                                 *   FILE 401\n//*      ----                                                       *   FILE 401\n//*                                                                 *   FILE 401\n//*      [*] SPITBOL = SPeedy ImplemenTation of SNOBOL4             *   FILE 401\n//*                    --     -       -            ---              *   FILE 401\n//*                                                                 *   FILE 401\n//*      [**] The original SNOBOL4 implementation from Bell         *   FILE 401\n//*      Telephone Laboratories was developed by R. E. Griswold     *   FILE 401\n//*      and I. Polonsky, the designers of the SNOBOL4              *   FILE 401\n//*      programming language. Thus, this reference                 *   FILE 401\n//*      implementation is often referred to as BTL SNOBOL4. In     *   FILE 401\n//*      the early 1970s, after Griswold left BTL for The           *   FILE 401\n//*      University of Arizona and continued SNOBOL4 distribution   *   FILE 401\n//*      from there, this implementation gained another name: SIL   *   FILE 401\n//*      SNOBOL4. (SIL = SNOBOL4 Implementation Language)           *   FILE 401\n//*                                                                 *   FILE 401\n//*      [***] SPITBOL 360 was distributed from 1971 until 1984     *   FILE 401\n//*      when it was superseded by SPITBOL 370.                     *   FILE 401\n//*                                                                 *   FILE 401\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GPL": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o!Y\\x01\\x18\\x01\\x18\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T21:59:00", "lines": 280, "newlines": 280, "modlines": 0, "user": "SPIT360"}, "text": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINKSBOL": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SPIT360"}, "text": "//.. JOB ....\n// EXEC LKED\n//SYSLMOD   DD  DSN=SPITBOL.LOAD,DISP=SHR\n//OBJS      DD  DSN=SPITBOL.SRC,DISP=SHR\n//SYSIN     DD  *\n INCLUDE OBJS(SBOLOBJ)\n ENTRY OSINT\n NAME SPITBOL(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LINKSPRG": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SPIT360"}, "text": "//.. JOB ....\n// EXEC LKED\n//SYSLMOD   DD  DSN=SPITBOL.LOAD,DISP=SHR\n//OBJS      DD  DSN=SPITBOL.SRC,DISP=SHR\n//SYSIN     DD  *\n INCLUDE OBJS(SLIBOBJ)\n ENTRY OSINT\n NAME SPITPROG(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OSINT": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x0b[\\x0b[\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 2907, "newlines": 2907, "modlines": 0, "user": "SPIT360"}, "text": "         TITLE 'OSINT -- OS INTERFACE -- DESCRIPTION'\n*\n*        O    S    I    N    T\n*        ---------------------\n*\n*        GENERAL INTERFACE FOR OS/360\n*\n*        VERSION 2.3\n*\n*        ROBERT B. K. DEWAR\n*        KENNETH E. BELCHER\n*        ILLINOIS INSTITUTE OF TECHNOLOGY\n*\n*    COPYRIGHT (C) 1971, 2001 ROBERT B. K. DEWAR AND KENNETH E. BELCHER\n*\n*        NEITHER AUTHOR IS CURRENTLY ASSOCIATED WITH ILLINOIS\n*        INSTITUTE OF TECHNOLOGY. FOR CURRENT INFORMATION ABOUT\n*        ABOUT SPITBOL 360 VISIT HTTP://WWW.SNOBOL4.COM\n*        --------------------------------------------------------------\n*\n*\n*        THIS FILE IS PART OF SPITBOL 360\n*\n*        SPITBOL 360 IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR\n*        MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE\n*        AS PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2\n*        OF THE LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.\n*\n*        SPITBOL 360 IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,\n*        BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF\n*        MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  SEE THE\n*        GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.\n*\n*        YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC\n*        LICENSE ALONG WITH SPITBOL 360; IF NOT, WRITE TO THE FREE\n*        SOFTWARE FOUNDATION, INC., 59 TEMPLE PLACE, SUITE 330,\n*        BOSTON, MA  02111-1307  USA\n*\n*        -------------------------------------------------------------\n*\n*\n*        CHANGE LOG:\n*\n*        2.3   8/14/2001 BOB GOLDBERG\n*\n*              PREPARED SOURCE FOR GPL DISTRIBUTION:\n*              - UPDATED COMMENTS\n*              - APPLIED TFS 1 TO 6 TO SOURCE (OS MACROS PRODUCE\n*                DIFFERENT CODE NOW THAN IN '71; OFFSETS CHANGED)\n*              - FIXED CONDITIONAL BRANCHES USED TO ABORT EXECUTION\n*                AFTER EXPIRATION OF TRIAL VERSION (1999 = Y2K-1 BUG)\n*        --------------------------------------------------------------\n*\n*\n*        THIS PROGRAM PROVIDES A RANGE OF EASILY USEABLE ENTRY\n*        POINTS FOR SYSTEM FUNCTIONS AND ALLOWS A PROGRAM TO BE\n*        WRITTEN IN AN ESSENTIALLY SYSTEM INDEPENDENT MANNER.\n*        IT WAS ORIGINALLY WRITTEN FOR USE WITH SPITBOL/360 BUT\n*        NO PART DEPENDS ON THIS USE, SO OTHER USES ARE POSSIBLE\n*\n*        THE FOLLOWING PAGES DESCRIBE THE REQUIREMENTS FOR\n*        OPERATING UNDER CONTROL OF THE INTERFACE. NOTE THE GENERAL\n*        REQUIREMENT THAT NO SYSTEM MACRO CALLS ARE TO BE USED.\n         TITLE 'OSINT -- OS INTERFACE -- SYSTEM PARAMETERS'\n*\n*        ON ENTRY TO OSINT FROM THE CONTROL PROGRAM, A PARAMETER\n*        FIELD MAY BE PROVIDED. THE PARAMETER FIELD IS OF THE FORM --\n*\n*        'X=NNN,X=NNN,X=NNN,...'\n*\n*        WHERE X ARE THE CHARACTERS INDICATING THE PARAMETER TYPE\n*        AND NNN ARE THE ASSIGNED VALUES. NNN IS EITHER AN UNSIGED\n*        OR AN UNSIGNED INTEGER FOLLOWED BY K TO INDICATE\n*        MULTIPLICATION BY 1024. THE FOLLOWING IS A LIST OF PARAMETERS\n*\n*        NAME  DEFAULT            MEANING\n*        ----  -------            -------\n*\n*        R     8K                 MEMORY TO BE RESERVED TO SYSTEM\n*        L     16K                MINIMUM ACCEPTABLE DATA AREA SIZE\n*        H     1000K              MAXIMUM DATA AREA TO BE ALLOCATED\n*        T     55                 TIME LIMIT IN SECONDS\n*        P     100000             PAGE LIMIT (1 PAGE = N LINE RECORDS)\n*        C     100000             CARD LIMIT (SYSPUNCH)\n*        D     10                 MAX NUMBER OF OSINT DUMPS\n*        N     58                 NUMBER OF LINES PER PAGE\n*        I     0                  0/1 FOR PRECISE/IMPRECISE INTERRUPTS\n*\n*        THE DEFAULT VALUE IS USED IF THE PARAMETER IS NOT SUPPLIED.\n*\n*        T,P,L LIMITS ARE ENFORCED SEPARATELY FOR EACH JOB IN A BATCH.\n*\n*        THE VALUE OF D IS DECREMENTED FOR EVERY CALL TO SYSABEND.\n*        IF THE VALUE IS ZERO ON ENTRY TO SYSABEND, A STANDARD SYSTEM\n*        ABEND DUMP IS GIVEN.\n         TITLE 'OSINT -- OS INTERFACE -- MAIN PROGRAM ENTRY POINTS'\n*\n*        THE FOLLOWING ENTRY POINTS MUST BE PROVIDED IN THE MAIN PROGRM\n*\n*        SYSSTART\n*        --------\n*\n*        THIS IS THE ENTRY POINT TO THE MAIN PROGRAM. OSINT PASSES\n*        CONTROL TO SYSSTART AS FOLLOWS AFTER INITIALIZATION\n*\n*        (8)                      POINTS TO THE ALLOCATED DATA AREA\n*\n*        (15)                     ADDRESS OF SYSSTART\n*\n*        (REMAINING REGISTERS)    NOT USED, MAY BE DESTROYED\n*\n*        NOTE THAT OSINT RECOGNIZES THE SYMBOLS ./* IN COLUMNS 1-3\n*        OF A SYSIN IMAGE TO REPRESENT AN END OF FILE SEPARATING JOBS\n*        WHICH ARE BATCHED TOGETHER. IF THE MAIN PROGRAM IS NOT\n*        REUSABLE, IT MUST RECOGNIZE SUBSEQUENT ENTRIES AFTER THE\n*        FIRST AND RETURN WITHOUT ANY PROCESSING.\n*\n*        THE ALLOCATED DATA AREA IS TO BE USED TO MEET ALL VOLATILE\n*        STORAGE REQUIREMENTS OF THE MAIN PROGRAM. FOR A DESCRIPTION\n*        OF THE FORMAT OF THE DATA AREA, SEE THE DATA DSECT AT THE END\n*        OF THE LISTING. THE LARGEST AVAILABLE CONTINGUOUS AREA OF\n*        STORAGE (NOT EXCEEDING THE H PARAMETER) IS USED, RESERVING\n*        ONLY THAT SPECIFIED BY THE R PARAMETER FOR OTHER USES.\n*        THE MAIN PROGRAM IS EXPECTED TO DO ITS OWN STORAGE\n*        MANAGEMENT WITHIN THIS AREA (GETMAIN,FREEMAIN MAY NOT BE USED)\n*\n*        SYSHEAD\n*        -------\n*\n*        THE DATA AT THE ENTRY POINT SYSHEAD SPECIFIES THE HEADING\n*        TO BE PRINTED BY OSINT AT THE START OF A RUN. IT CONSISTS OF\n*        A SERIES OF LINES STARTING WITH AN ASA CONTROL CHARACTER.\n*        EACH LINE IS PRECEEDED BY A ONE BYTE COUNT GIVING THE ACTUAL\n*        LENGTH OF THE LINE. A BYTE OF ZEROS (X'00') ENDS THE LIST\n*\n*        THE FOLLOWING IS AN EXAMPLE OF A TYPICAL HEADING\n*\n*        ENTRY SYSHEAD\n*SYSHEAD DC    AL1(L'HED1)\n*HED1    DC    C'1DOODLETRAN VERSION 9.9'\n*        DC    AL1(L'HED1)\n*        DC    C'+______________________'\n*        DC    AL1(0)\n*\n*        SYSBATCH\n*        --------\n*\n*        A SINGLE BYTE WHICH IS SET TO 1 IF THE MODULE PERMITS SYSIN\n*        BATCHING (VIA ./*) OR ZERO IF NO BATCHING IS PERMITTED\n         EJECT\n*\n*        SYSINTR\n*        -------\n*\n*        THIS ENTRY POINT RECEIVES CONTROL AS FOLLOWS AFTER THE\n*        OCCURENCE OF A PROGRAM CHECK.\n*\n*        (15)                     POINTS TO SYSINTR\n*\n*        (8)                      POINTS TO ALLOCATED DATA AREA\n*                                 SYSPSW,SYSREGS STORED\n*\n*        (REMAINING REGS)         UNPREDICTABLE\n*\n*        SYSINTR CAN DETERMINE THE CAUSE OF THE INTERRUPT BY EXAMINING\n*        THE INTERRUPT PSW AND REGISTER VALUES STORED IN THE DATA AREA\n*        (AT SYSPSW AND SYSSTART). IT THEN TAKES APPROPRIATE ACTION.\n*\n*        NOTES.\n*\n*        SYSINTR RECEIVES CONTROL AFTER LEAVING TRAP STATE, THUS THERE\n*        IS NO PROVISION FOR 'RETURNING' VIA THE SYSTEM.\n*\n*        IF THE INTERRUPT IS AN ERROR, THEN SYSINTR SHOULD PRINT\n*        AN APPROPRIATE MESSAGE AND EXIT VIA SYSABEND. NOTE THAT THE\n*        PSW AND REG VALUES ARE IN THE DATA AREA AND WILL BE DUMPED.\n*\n*        REGISTER 8 IS SET CORRECTLY TO POINT TO THE DATA AREA EVEN IF\n*        IT WAS NOT SO SET AT THE TIME OF THE INTERRUPT.\n         EJECT\n*\n*        SYSOVTM\n*        -------\n*\n*\n*        THIS ENTRY POINT RECEIVES CONTROL ON AN OVERTIME TRAP\n*        (I.E. T PARAMETER EXCEEDED) AS FOLLOWS --\n*\n*        (15)                     ADDRESS OF SYSOVTM\n*\n*        (8)                      POINTER TO ALLOCATED DATA AREA\n*\n*        (14)                     RETURN POINT TO INTERFACE\n*\n*        (REMAINING REGS)         UNPREDICTABLE, NEED NOT BE SAVED\n*\n*        UNLIKE SYSINTR, THIS ROUTINE RECEIVES CONTROL WITHIN TRAP\n*        STATE AND MUST RETURN CONTROL VIA REGISTER 14. THUS THE\n*        ROUTINE SHOULD SET FLAGS ETC. WHICH THE MAIN STREAM ROUTINE\n*        RECOGNIZES AS SIGNIFYING THAT AN OVERTIME TRAP HAS OCCUED.\n*\n*        NOTE THAT THE GENERAL REGISTERS DO NOT CONTAIN USEABLE\n*        VALUES SINCE THE INTERRUPT MAY OCCUR DURING EXECUTION OF\n*        A ROUTINE WITHIN THE SYSTEM INTERFACE. HOWEVER, THE\n*        FLOATING POINT REG VALUES ARE UNCHANGED AND MAY BE MODIFIED.\n         TITLE 'OSINT -- OS INTERFACE -- INTERFACE ENTRY POINTS'\n*\n*        THE INTERFACE PROVIDES A SERIES OF ENTRY POINTS FOR PERFORMING\n*        VARIOUS SYSTEM DEPENDENT FUNCTIONS. A COMMON CALLING\n*        SEQUENCE IS USED AS FOLLOWS --\n*\n*        (8)                      POINTS TO THE ALLOCATED DATA AREA\n*\n*        (2)                      ADDRESS OF SYSTEM INTERFACE ROUTINE\n*                                 LOADED VIA A VCON\n*\n*        (1)                      RETURN POINT TO MAIN PROGRAM\n*\n*        (0,4,5,6,7)              PARAMETER VALUES AS REQUIRED BY\n*                                 THE PARTICULAR CALL\n*\n*        (REMAINING REGS)         NOT RELEVANT\n*\n*        ON RETURN, ALL REGISTERS, WITH THE POSSIBLE EXCEPTION\n*        OF (0) ARE RESTORED. IF AN ERROR OCCURED, AN ERROR CODE\n*        IS POSTED IN REGISTER (0) AND CONTROL IS RETURNED TO 0(1).\n*        IF THE CALL IS SUCCESSFUL, CONTROL RETURNS TO 4(1). IN SOME\n*        CASES, A RESULT IS RETURNED IN REGISTER (0).\n*\n*        NORMAL PRACTICE IS TO KEEP REGISTER (8) POINTING TO THE\n*        ALLOCATED DATA AREA AT ALL TIMES, ALTHOUGH THE VALUE IS\n*        ONLY REQUIRED TO BE LOADED WHEN AN INTERFACE CALL IS MADE.\n*        THUS A TYPICAL CALL TO AN OSINT ENTRY POINT IS AS FOLLOWS\n*\n*        L     2,=V(SYSXXX)\n*        LA    0,PARAM\n*        BALR  1,2\n*        B     ERROR\n*        -->   NORMAL RETURN\n*\n*        NOTE THAT THE SPACE FOR THE ERROR RETURN MUST BE PROVIDED EVEN\n*        FOR CALLS WHICH CANNOT GIVE AN ERROR RETURN.\n         EJECT\n*\n*        SYSABEND\n*        --------\n*\n*        PURPOSE:                 TERMINATE EXECUTION WITH AN ERROR\n*                                 INDICATION. A SYSTEM DUMP OR AN OSINT\n*                                 DUMP IS GIVEN DEPENDING ON THE\n*                                 SETTING OF THE D PARAMETER. THE OSINT\n*                                 DUMP INCLUDES THE ALLOCATED DATA\n*                                 AREA, DCB'S AND INTERFACE WORK AREA.\n*                                 AFTER AN OSINT DUMP, AN ATTEMPT\n*                                 IS MADE TO INITIATE THE NEXT JOB\n*                                 IN A BATCH.\n*\n*        ENTRY PARAMETERS:        NONE\n*\n*        RESULT RETURNED:         NONE (DOES NOT RETURN)\n*\n*\n*        SYSCLOSE\n*        --------\n*\n*        PURPOSE:                 CLOSE FILE AND RELEASE ITS ASSOCIATED\n*                                 STORAGE (BUFFER POOLS ETC.)\n*                                 SYSDCB MUST BE CALLED BEFORE ANY\n*                                 FURTHER OPERATIONS ARE PERFORMED\n*                                 ON THE FILE. SYSTEM FILES (SYSPUNCH,\n*                                 SYSIN, SYSPRINT) CANNOT BE CLOSED.\n*\n*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE\n*\n*        RESULT RETURNED:         ZERO\n*\n*\n*        SYSDATE\n*        -------\n*\n*        PURPOSE:                 OBTAIN CURRENT DATE (MM/DD/YY)\n*\n*        ENTRY PARAMETERS:        NONE\n*\n*        RESULT RETURNED:         POINTER TO 8 CHAR DATE (MM/DD/YY)\n*\n*\n*        SYSSETP\n*        -------\n*\n*        PURPOSE:                 TO INFORM THE INTERFACE THAT THE\n*                                 DATA AREA POINTER HAS BEEN CHANGED\n*\n*        ENTRY PARAMETERS         NONE (REG 8 POINTS TO NEW DATA AREA)\n*\n*        RESULT RETURNED:         NONE\n         EJECT\n*\n*        SYSDCB\n*        ------\n*\n*        PURPOSE:                 TO OBTAIN A DCB POINTER FOR A FILE\n*                                 FROM A FILENAME FOR USE IN\n*                                 SUBSEQUENT CALLS. SEE SEPARATE\n*                                 SECTION FOR DISCUSSION OF FILENAMES\n*\n*        ENTRY PARAMETERS:        (4)       ADDRESS OF FILE NAME\n*                                 (5)       NUMBER OF CHARS IN FILENAME\n*\n*        RESULT RETURNED:         POINTER TO DCB. NOTE THAT THE USER\n*                                 MUST NOT USE THIS POINTER EXCEPT\n*                                 FOR INTERFACE COMMUNICATION. THIS IS\n*                                 TO ENSURE COMPATABILITY WITH\n*                                 OTHER SYSTEMS SUCH AS DOS.\n*                                 THE POINTER IS VALID UNTIL THE FILE\n*                                 IS CLOSED USING SYSCLOSE.\n*\n*\n*        SYSDUMP\n*        -------\n*\n*        PURPOSE:                 PROVIDE A SPECIAL DUMP OF THE\n*                                 ALLOCATED DATA AREA, DCB'S AND THE\n*                                 INTERFACE WORK AREA. THE DUMP GIVES\n*                                 BOTH ABSOLUTE AND RELATIVE ADDRESSES\n*                                 IN EACH AREA. NOTE THAT THE REGISTER\n*                                 VALUES ARE NOT DUMPED AND MUST\n*                                 THEREFORE BE STORED IN THE DATA AREA\n*                                 PRIOR TO THE SYSDUMP CALL.\n*\n*        ENTRY PARAMETERS:        NONE\n*\n*        RESULT RETURNED:         NONE\n*\n*\n*        SYSEOJ\n*        ------\n*\n*        PURPOSE:                 NORMAL TERMINATION OF EXECUTION\n*                                 IF ON READING SYSIN, A ./* IS\n*                                 ENCOUNTERED, OSINT STARTS A NEW JOB\n*                                 BY REINITIALIZING AND PASSING\n*                                 CONTROL TO SYSSTART.\n*\n*        ENTRY PARAMETERS:        (0)       SYSTEM RETURN CODE\n*                                           LAST JOB IN A BATCH ONLY\n*\n*        RESULT RETURNED:         NONE (DOES NOT RETURN)\n         EJECT\n*\n*        SYSLOAD\n*        -------\n*\n*        PURPOSE:                 LOAD AN EXTERNAL MODULE\n*\n*        ENTRY PARAMETERS:        (4)       ADDRESS OF MODULE NAME\n*                                 (5)       NUMBER OF CHARS IN NAME\n*\n*        RESULT RETURNED:         STARTING ADDRESS OF LOADED MODULE\n*\n*\n*        SYSMAXL\n*        -------\n*\n*        PURPOSE:                 TO DETERMINE THE MAXIMUM POSSIBLE\n*                                 LENGTH OF AN INPUT RECORD FROM A FILE\n*                                 SO THAT THE CALLER CAN PROVIDE A\n*                                 SUITABLE BUFFER FOR A SYSREAD CALL\n*\n*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE\n*\n*        RESULT RETURNED:         MAX RECORD LENGTH IN BYTES\n*\n*\n*        SYSPHASE\n*        --------\n*\n*        PURPOSE:                 LOAD A PHASE IN A MULTIPHASE PROGRAM\n*                                 NOTE THAT THE INTERFACE MUST BE IN\n*                                 THE ROOT PHASE.\n*\n*        ENTRY PARAMETERS:        (0)       VCON OF PHASE TO BE LOADED\n*                                 (4)       ADDR OF 8 CHR PHASE NAME\n*\n*        RESULT RETURNED:         NONE\n*\n*\n*        SYSREAD\n*        -------\n*\n*        PURPOSE:                 READ A RECORD FROM A FILE\n*\n*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE\n*                                 (4)       ADDRESS OF BUFFER\n*\n*        RESULT RETURNED:         LENGTH OF RECORD READ\n*                                 SET NEGATIVE ON END OF FILE\n*\n         EJECT\n*        SYSRWIND\n*        --------\n*\n*        PURPOSE:                 REWIND A FILE, I.E. CLOSE FILE AND\n*                                 REPOSITION AT START OF FILE. SYSTEM\n*                                 FILES (SYSPUNCH, SYSIN, SYSPRINT)\n*                                 CANNOT BE REWOUND. THE STORAGE\n*                                 (BUFFER POOLS ETC.) IS NOT RELEASED.\n*\n*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE\n*\n*        RESULT RETURNED:         NONE\n*\n*\n*        SYSTIME\n*        -------\n*\n*        PURPOSE:                 GET CURRENT TIMER VALUE\n*\n*        ENTRY PARAMETERS:        NONE\n*\n*        RESULT RETURNED:         TIME IN MILLISECONDS SINCE\n*                                 SYSSTART RECEIVED CONTROL\n*\n*\n*        SYSUNLOD\n*        --------\n*\n*        PURPOSE:                 UNLOAD AN EXTERNAL MODULE\n*                                 (I.E. RELEASE CONTROL)\n*\n*        ENTRY PARAMETERS         (4)       ADDRESS OF MODULE NAME\n*                                 (5)       NUMBER OF CHARS IN NAME\n*\n*        RESULT RETURNED:         NONE\n*\n*\n*        SYSWRITE\n*        --------\n*\n*        PURPOSE:                 WRITE A RECORD TO A FILE\n*\n*        ENTRY PARAMETERS:        (0)       POINTER TO DCB FOR FILE\n*                                 (4)       ADDRESS OF RECORD\n*                                 (5)       LENGTH OF RECORD (BYTES)\n*                                 (6)       ADDRESS OF FORMAT STRING\n*                                 (7)       LENGTH OF FORMAT (0 = NONE)\n*\n*        RESULT RETURNED:         ZERO IF TOO MANY RECORDS WRITTEN\n*                                 ELSE UNCHANGED DCB POINTER\n         TITLE 'OSINT -- OS INTERFACE -- NOTES ON I/O'\n*\n*        ALL I/O IS DONE USING QSAM. ALL RECORD FORMATS ARE SUPPORTED.\n*\n*        A FILE IS OPENED WHEN THE FIRST READ OR WRITE OPERATION IS\n*        PERFORMED (I.E. CALL TO SYSREAD OR SYSWRITE).\n*\n*        IT IS NOT PERMISSIBLE TO SWITCH FROM READING TO WRITING OR\n*        VICE VERSA WITHOUT FIRST REWINDING OR CLOSING THE FILE.\n*\n*        RECORDS EXCEEDING THE LRECL VALUE ARE SUBDIVIDED AS REQUIRED.\n*        IN THE CASE OF FIXED LENGTH RECORDS, TRAILING BLANKS ARE\n*        SUPPLIED AS REQUIRED.\n*\n*        ZERO LENGTH RECORDS MAY BE WRITTEN AND ARE HANDELED AS FOLLOWS\n*        FIXED LENGTH             A BLANK RECORD IS WRITTEN\n*        VARIABLE,UNDEFINED       A ONE BYTE RECORD X'00' IS WRITTEN\n*\n*        THE FOLLOWING POSSIBILITIES ARE RECOGNIZED FOR FILENAMES\n*\n*        DDNAME                   REFERS TO FILE WITH DDNAME GIVEN\n*\n*        INTEGER NN               REFERS TO FILE WITH DDNAME FTNNF001\n*                                 WITH THE FOLLOWING SPECIAL EXCEPTIONS\n*                                 05 -> SYSIN IF FT05F001 NOT GIVEN\n*                                 06 -> SYSPRINT IF FT06F001 NOT GIVEN\n*                                 07 -> SYSPUNCH IF FT07F001 NOT GIVEN\n*\n*        DDNAME(ELNAME)           FOR A PARTIONED DATASET, ELNAME IS A\n*                                 MEMBER NAME. FOR A TAPE FILE, ELNAME\n*                                 IS A SEQUENCE (FILE) NUMBER.\n         TITLE 'OSINT -- OS INTERFACE -- MACRO DEFINITIONS'\n*\n*        MACRO TO IMPLEMENT ONE CHARACTER PARAMETERS (NUMERIC)\n*        FIRST ARGUMENT = PARAMETER CHARACTER\n*        SECOND ARGUMENT IS ADDRESS WHERE VALUE IS TO BE STORED\n*\n         MACRO\n&LBL     PARAM &LTR,&ADDR\n         CNOP  0,4\n&LBL     DC    C'&LTR',AL3(&ADDR-WORK)\n         MEND\n*\n*        COMMON ENTRY MACRO\n*\n         MACRO\n&NAME    ENTER\n         ENTRY &NAME\n&NAME    DS    0H\n         USING *,2\n         DROP  11,12\n         STM   0,15,SAVE1\n         LM    11,12,=A(OSINT,OSINT+4096)\n         USING OSINT,11,12\n         L     13,WORKLOC\n         DROP  2\n         MEND\n*\n*        XERR -- DEFINE ERROR CODE\n*\n         MACRO\n&NAME    XERR\n         GBLA  &ERRC\n&ERRC    SETA  &ERRC+1\n&NAME    BCTR  12,0\n         MEND\n         EJECT\n*\n*        MACRO TO GENERATE MESSAGE LINES\n*\n         MACRO\n&NAME    MSG   &TEXT\n         LCLA  &K\n&NAME    EQU   *\n&K       SETA  K'&TEXT-2\n         DC    AL1(&K)\n         DC    C&TEXT\n         MEND\n*\n*        MACRO TO PRINT A LINE GENERATE BY THE ABOVE MSG CALL\n*\n         MACRO\n&LABEL   PRT   &MESSAGE\n&LABEL   MVC   BUFR(70),&MESSAGE\n         BAL   5,PRNTLNB\n         MEND\n*\n         GBLA  &ERRC              COUNT OF ERROR CODES\n&ERRC    SETA  0                  INITIALIZE ERROR COUNT\n         PRINT NOGEN              NO GARBAGE PLEASE\n         TITLE 'OSINT -- OS INTERFACE -- DEFINITIONS'\nDEFS     DSECT ,                  START OF DEFINITIONS\n*\n*        DEFINITIONS FOR RR BRANCH MENOMONICS\n*\nE        EQU   8                  EUQAL\nZ        EQU   8                  ZERO, ZEROS\nNE       EQU   7                  NOT EQUAL\nNZ       EQU   8                  NOT ZERO, NOT ZEROS\nO        EQU   1                  OVERFLOW, ONES\nNO       EQU   14                 NO OVERFLOW, NOT ONES\nP        EQU   2                  POSITIVE\nH        EQU   2                  HIGH\nNP       EQU   13                 NOT POSITIVE\nNH       EQU   13                 NOT HIGH\nM        EQU   4                  MINUS\nL        EQU   4                  LOW\nNM       EQU   11                 NOT MINUS\nNL       EQU   11                 NOT LOW\n         TITLE 'OSINT -- OS INTERFACE -- INITIALIZATION'\n*\n*        ENTRY POINT FROM CONTROL PROGRAM\n*\nOSINT    CSECT ,                  START OF INTERFACE\n         SAVE  (14,12)            SAVE ENTRY REGISTERS\n         USING OSINT,15           INITIAL BASE SET BY SYSTEM\n         LM    11,12,=A(OSINT,OSINT+4096)   SET BASE REGS\n         DROP  15                 DROP TEMPORARY BASE\n         USING OSINT,11,12        STANDARD BASE REG FOR INTERFACE\n         L     4,0(,1)            GET ADDRESS OF EXEC PARAMETERS\n         GETMAIN   R,LV=LWORK     GET SPACE FOR INTERFACE WORK AREA\n         USING WORK,1             TEMPORARY BASE FOR WORK AREA\n         XC    WORK(256),WORK               ZERO INTERFACE WORK AREA\n         MVC   WORK+256(LWORK-256),WORK     . . . .\n         LA    5,FSTAKEND         GET END OF STACK ADDESS FOR FORMATS\n         LA    6,FORMSTAK-4       BOTTOM OF STACK ADDRESS\n         STM   5,6,FSTAKEND       INITIALIZE FORMAT STACK INFORMATION\n         MVC   LIMS(LLIMS),LIMSINIT         SET INITIAL VALUE OF LIMITS\n         ST    1,8(,13)           SET SAVE AREA FORWARD PTR\n         OI    8+3(13),1          SET OUR SPECIAL SAVE AREA FLAG BIT\n         ST    13,ENT13SV         SAVE POINTER TO PREVIOUS SAVE AREA\n         LR    13,1               SET WORK ADDRESS IN CORRECT REGISTER\n         USING WORK,13            TELL ASSEMBLER\n         USING IHADCB,10          REG TO POINT TO DCB'S\n         DROP  1                  DROP      TEMPORARY BASE\n         EXTRN SYSSTART           MAIN PROGRAM ENTRY POINT\n         MVC   STARTLOC,=A(SYSSTART)        SET IN WORK AREA FOR DUMPS\n*\n*        PROCESS PARAMETER FIELD\n*\n         LH    2,0(,4)            GET LENGTH OF PARAMETER FIELD\n         LA    1,2(,4)            POINT TO FIRST PARAMETER CHARACTER\n*\n*        LOOP THROUGH PARAMETERS\n*\nPARLOOP  CH    2,=H'3'            INSIST ON AT LEAST THREE CHARACTERS\n         BL    NOPARMS            IGNORE FIELD IF NOT THAT BIG\n         MVC   PTYPE(1),0(1)      MOVE PARAMETER NAME\n         CLI   1(1),C'='          NEXT CHARACTER MUST BE =\n         BNE   NOPARMS            IGNORE REST IF NOT\n         LA    1,2(,1)            POINT TO START OF NUMBER\n         LR    3,1                COPY STARTING ADDRESS\n         SR    0,0                INITIALIZE RESULT TO ZERO\n         SH    2,=H'2'            DECR COUNT OF CHARS LEFT FOR X=\n*\n*        LOOP TO CONVERT NUMBER\n*\nPARLOOP1 CLI   0(1),C','          COMMA FOR END OF PARAMETER?\n         BE    PARFND             B IF END OF FIELD\n         CLI   0(1),C'K'          K FOR *1024 ?\n         BNE   PARLOOPN           SKIP IF NOT\n         SLL   0,10               ELSE MULTIPLY WHAT WE HAVE BY 1024\n         B     PARLOOPE           JUMP TO END OF LOOP\n         EJECT\n*\n*        HERE TO CHECK FOR A DIGIT\n*\nPARLOOPN CLI   0(1),C'0'          CHECK FOR NUMERIC\n         BL    NOPARMS            SKIP IF TOO LOW\n         MH    0,=H'10'           SHIFT PREVIOUS TOTAL\n         IC    9,0(,1)            LOAD DIGIT\n         N     9,=X'0000000F'     MASK DIGIT VALUE\n         AR    0,9                ADD TO WHAT WE HAVE ALREADY\n*\n*        HERE AT END OF LOOP\n*\nPARLOOPE LA    1,1(,1)            BUMP POINTER\n         BCT   2,PARLOOP1         DECR COUNT, LOOP IF MORE TO GO\n*\n*        COME HERE WITH PARAMETER VALUE CONVERTED IN (0)\n*\nPARFND   LA    9,PARMNO           GET NUMBER OF PARAMETERS IN TABLE\n         LA    8,FSTPARM          GET START OF TABLE\n*\n*        LOOP TO FIND PROPER PARAMETER\n*\nPELOOP   CLC   PTYPE,0(8)         IS THIS THE PARAMETER?\n         BE    PENTRY             B IF FOUND\n         LA    8,4(,8)            POINT TO NEXT ENTRY\n         BCT   9,PELOOP           LOOP TO CHECK NEXT ENTRY\n         B     NEXTPRM            IF NO MATCH, IGNORE THIS PARAMETER\n*\n*        HERE WE HAVE FOUND THE APPROPRIATE PARAMETER\n*\nPENTRY   L     9,0(,8)            LOAD ADDRESS OFFSET OF PARAM VALUE\n         ST    0,WORK(9)          STORE PARAMETER VALUE\n*\n*        HERE TO MOVE TO NEXT PARAMETER\n*\nNEXTPRM  LA    1,1(,1)            SKIP PAST COMMA\n         BCT   2,PARLOOP          LOOP BACK IF WE HAD A COMMA\n*\n*        HERE AFTER PROCESSING PARAMS, ALLOCATE DYNAMIC MEMORY\n*\nNOPARMS  L     0,RESERV           MEMORY TO BE RESERVED TO SYSTEM\n         GETMAIN R,LV=(0)         RESERVE SYSTEM SPACE\n         ST    1,RESERV0          SAVE ADDRESS OF AREA\n         MVC   MLIST(LGETLIST),GETLIST      MOVE GETMAIN LIST\n         GETMAIN   LA=DYNALLOC,A=ALLOC,     ATTEMPT TO ALLOCATE IN LCS X\n               HIARCHY=1,MF=(E,MLIST)       . . . .\n         LTR   15,15              TEST RETURN CODE\n         BZ    ALLOCGO            SKIP IF LCS OBTAINED\n         GETMAIN   HIARCHY=0,MF=(E,MLIST)   IF NO LCS, GET NORMAL MEMRY\n         EJECT\n*\n*        COME HERE WITH MEMORY OBTAINED\n*\nALLOCGO  LM    0,1,RESERV         GET LENGTH/ADDRESS OF SYSTEM AREA\n         FREEMAIN  R,LV=(0),A=(1) FREE SYSTEM AREA\n         GETMAIN   R,LV=140       GET WORK BUFFER (ENOUGH FOR SYSPRINT)\n         ST    1,OUTWBF           STORE POINTER TO BUFFER OBTAINED\n         LA    1,140              GET LENGTH\n         STH   1,OUTWBFLN         STORE LENGTH OF WORK BUFFER\n         LM    1,2,ALLOC          GET ADDRESS AND LENGTH ALLOCATED\n         LR    8,1                COPY ADDRESS\n         USING DATA,8             TELL ASSEMBLER\n         ST    8,DATAPTR          STORE PTR TO DATA AREA IN OUR AREA\n         ST    2,DATASIZE         STORE ALLOCATED LENGTH\n         ST    13,WORKLOC         STORE PTR TO INTERFACE WORK AREA\n*\n*        NOW WE BUILD DCB'S FOR ALL DATASETS DEFINED BY DD CARDS\n*\n         MVC   MLIST(LEXTLIST),EXTLIST      MOVE EXTRACT LIST\n         EXTRACT   TIOTLOC,MF=(E,MLIST)     GET TIOT ADDRESS\n         SR    5,5                GET A ZERO\n         ST    5,PTRDCB           SET INITIAL DCB POINTER = 0\n         L     6,TIOTLOC          POINT TO START OF TIOT\n         USING TIOT,6             TELL ASSEMBLER\n*\n*        LOOP THROUGH ENTRIES IN TIOT\n*\nTIOTLOOP C     5,TIOENTRY         IS THIS THE END OF THE LIST?\n         BZ    ENDTIOTL           SKIP IF END OF LOOP\n         CLC   TIOEDDNM,=CL8' '   IS DDNAME BLANK (CONCATENATION)?\n         BE    TIOTSKP            IF SO, DO NOT BOTHER TO BUILD DCB\n         GETMAIN   R,LV=LMODDCB   ALLOCATE MEMORY FOR DCB\n         LR    10,1               COPY POINTER\n         MVC   0(LMODDCB,10),MODDCB         MOVE MODEL DCB INTO PLACE\n         MVC   DCBDDNAM,TIOEDDNM  COPY DDNAME INTO DCB\n         MVC   DDNAME,TIOEDDNM    SET OUR COPY OF DDNAME\n         MVC   FILENAME(8),TIOEDDNM         SET DDNAME AS FILENAME\n         L     1,PTRDCB           LOAD CURRENT CHAIN POINTER\n         ST    1,DCBNEXT          STORE AS FORWARD POINTER\n         ST    10,PTRDCB          STORE NEW HEADER PTR (THIS DCB)\n*\n*        HERE AFTER BUILDING DCB IF REQUIRED\n*\nTIOTSKP  SR    0,0                CLEAR FOR IC\n         IC    0,TIOELNOH         LOAD LENGTH OF TIOT ENTRY\n         AR    6,0                POINT TO NEXT ENTRY\n         B     TIOTLOOP           AND LOOP BACK\n         DROP  6                  DROP TIOT BASE REG\n         EJECT\n*\n*        ALL DCBS ARE NOW BUILT, FIND SYSPRINT DCB AND FIX IT UP\n*\nENDTIOTL LA    2,SYSDCB           POINT TO SYSTEM DCB LOCATE ROUTINE\n         LA    4,=C'SYSPRINT'     POINT TO NAME OF PRINT FILE\n         LA    5,8                NAME LENGTH = 8 CHARACTERS\n         BALR  1,2                CALL ROUTINE TO LOCATE SYSPRINT DCB\n         B     DDBOMB             ERROR IF NO SYSPRINT FILE\n         LR    10,0               MOVE DCB PTR TO STANDARD REGISTER\n         MVI   OFLAGS,PRINTER     SET SPECIAL FLAG FOR SYSPRINT\n         MVC   DCBEXLST+1(3),=AL3(EXLPRT)   SET PROPER EXIT LIST ADDR\n         ST    10,PRINTDCB        STORE ADDRESS OF DCB\n*\n*        FIND SYSPUNCH DCB AND FIX IT UP\n*\n         LA    4,=C'SYSPUNCH'     SET SYSPUNCH NAME (LENGTH IS SET)\n         BALR  1,2                CALL ROUTINE TO LOCATE SYSPUNCH DCB\n         B     DDBOMB             ERROR IF DD CARD MISSING\n         LR    10,0               ELSE MOVE DCB PTR TO STANDARD REG\n         MVI   OFLAGS,PUNCHER     SET SPECIAL SYSPUNCH FLAG\n         MVC   DCBEXLST+1(3),=AL3(EXLPCH)   SET PROPER EXIT LIST ADDR\n         ST    10,PUNCHDCB        STORE ADDRESS OF PUNCH DCB\n*\n*        FIND SYSIN DCB AND FIX IT UP\n*\n         LA    4,=CL8'SYSIN'      POINT TO SYSIN NAME (LENGTH = 8 SET)\n         BALR  1,2                CALL ROUTINE TO LOCATE SYSIN DCB\n         B     DDBOMB             ERROR IF MISSING DD CARD\n         LR    10,0               SET DCB PTR IN STANDARD REG\n         MVI   OFLAGS,READER      SET SPECIAL SYSIN FLAG\n         MVC   DCBEXLST+1(3),=AL3(EXLRDR)   SET PROPER EXIT LIST ADDR\n         ST    10,READDCB         STORE ADDRESS OF READER DCB\n*\n*        IF SYSOBJ FILE IS GIVEN, FIX IT UP\n*\n         LA    4,=CL8'SYSOBJ'     POINT TO NAME (LENGTH=8 IS SET)\n         BALR  1,2                CALL ROUTINE TO GET SYSOBJ DCB\n         B     SETPCEX            SKIP IF FILE NOT GIVEN\n         LR    10,0               ELSE SET DCB PTR IN STANDARD REG\n         MVC   DCBEXLST+1(3),=AL3(EXLOBJ)   SET PROPER EXIT LIST ADDR\n         EJECT\n*\n*        SET PROPER PSW AND INTERRUPT INTERCEPT\n*\nSETPCEX  SPIE  PCEXIT,((1,15))    GET CONTROL ON ALL INTERRUPTS\n         SR    0,0                GET 0\n         SPM   0                  MASK MASKABLE PC'S\n         ST    1,PICASAV          SAVE CALLER'S PICA ADDRESS\n*\n*        PRINT HEADING AND OTHER INFORMATION\n*\n         EXTRN SYSHEAD            GAIN ACCESS TO HEADER\n         L     9,=A(SYSHEAD)      POINT TO HEADING\n*\n*        LOOP TO PRINT SUPPLIED HEADING\n*\nHEADL    SR    6,6                CLEAR FOR IC\n         IC    6,0(,9)            LOAD LINE LENGTH\n         LTR   6,6                CHECK FOR END OF HEADERS\n         BZ    HEAD2              SKIP IF END OF HEADERS\n         EX    6,HEADMVC          MOVE HEADER TO PRINT BUFFER\n         BAL   5,PRNTLNB          PRINT HEADING LINE FROM BUFFER\n         LA    9,1(6,9)           POINT TO NEXT HEADER LINE\n         B     HEADL              LOOP BACK\n*\nHEADMVC  MVC   BUFR(*-*),0(9)     MOVE HEADER LINE TO BUFFER\n*\n*        HERE WHEN LINES OF HEADER HAVE BEEN PRINTED\n*\nHEAD2    PRT   OSMSG              IDENTIFY SYSTEM AS OS\n         PRT   BLANKL             PRINT AN EXTRA BLANK LINE\n         PRT   PARMHEAD           PRINT HEADER FOR PARAMS\n         PRT   BLANKL             PRINT A BLANK LINE\n         LA    9,PARMNO           NUMBER OF PARAMETERS\n         LA    6,FSTPARM          POINT TO PARAMETER TABLE\n         MVC   BUFR(28),PARMPRT   MOVE MODEL TO BUFFER\n*\n*        LOOP TO PRINT PARAMETER VALUES\n*\nPARMPL   MVC   BUFR+2(1),0(6)     MOVE CHARACTER NAME\n         L     3,0(,6)            WORK OFFSET OF PARAM ADDRESS VALUE\n         L     3,WORK(3)          LOAD PARAMETER VALUE\n         LA    2,BUFR+6           POINT TO CONVERT LOCATION\n         BAL   7,CONVOUT          CONVERT NUMBER FOR OUTPUT\n         BAL   5,PRNTLNB          PRINT BUFFER\n         LA    6,4(,6)            PUSH TO NEXT PARAMETER\n         BCT   9,PARMPL           LOOP UNTIL ALL PARAMETERS PRINTED\n         EJECT\n*\n*        PRINT LENGTH OF MEMORY OBTAINED\n*\n         PRT   BLANKL             PRINT A BLANK LINE\n         L     3,ALLOC+4          LENGTH ALLOCATED\n         MVC   BUFR(50),PRTMEM    MOVE MESSAGE TO BUFFER\n         LA    2,BUFR+29          POINT TO CONVERT LOCATION\n         BAL   7,CONVOUT          CONVERT IT\n         BAL   5,PRNTLNB          PRINT ALLOCATED MEMORY\n         PRT   BLANKL             PRINT A BLANK LINE\n*\n*        ACQUIRE BYTE FOR ALLOWING BATCHING (SYSBATCH)\n*\n         EXTRN SYSBATCH           FLAG BYTE IS IN MAIN MODULE\n         L     1,=A(SYSBATCH)     LOAD ADDRESS OF BYTE\n         MVC   BATCHFLG,0(1)      MOVE FLAG BYTE TO INTERFACE WORK AREA\n*\n*        CONVERT TIME LIMIT TO TIMER UNITS\n*\n         L     1,TLIMIT           LOAD TIME LIMIT IN SECONDS\n         M     0,=F'38400'        CONVERT TO TIMER UNITS           V2.3\n         ST    1,TLIMIT           STORE BACK IN TIME LIMIT\n*\n*        NOW MAKE SURE WE HAVE ENOUGH ROOM\n*\n         C     3,DYNAMIN          IS IT ENOUGH?\n         BNL   TFIXCHK            SKIP IF WE HAVE ROOM\n*\n*        HERE IF WE HAVE INSUFFICIENT MEMORY\n*\n         PRT   DYNAMSG            PRINT COMPLAINT\n         ABEND 200,DUMP           GIVE PROPER ABEND\n*\n*        HERE IF WE ARE MISSING A DD CARD FOR A STANDARD SYSTEM FILE\n*\nDDBOMB   ABEND 400,DUMP           GIVE PROPER ABEND\n         EJECT\n*\n*        HERE WE CHECK FOR POSSIBLE TF'S (TEMPORARY FIXES)\n*\nTFIXCHK  PRT   BLANKL             PRINT A BLANK LINE\n         SR    6,6                INITIALIZE OFFSET INTO TFIXES LIST\n         LA    9,NFIXES           SET MAX POSSIBLE NUMBER OF FIXES\n*\n*        LOOP TO CHECK FOR FIXES\n*\nFIXLOOP  LH    3,TFIXES(6)        LOAD POSSIBLE TF NUMBER\n         LTR   3,3                IS THIS ONE IN USE (APPLIED)?\n         BZ    EFIXL              SKIP IF NOT\n         MVC   BUFR(39),TFIXMSG   IF SO, MOVE MESSAGE TO BUFFER\n         LA    2,BUFR+17          POINT TO LOCATION FOR CONVERT\n         BAL   7,CONVOUT          CONVERT CODE NUMBER\n         BAL   5,PRNTLNB          PRINT MESSAGE FROM BUFFER\n*\n*        HERE TO LOOP TO THE NEXT ONE\n*\nEFIXL    LA    6,2(,6)            BUMP POINTER\n         BCT   9,FIXLOOP          LOOP BACK IF MORE TO GO\n         EJECT\n*\n*        NOW CHECK FOR PAST CUTOFF DATE\n*\n         PACK  BUFR(3),DATECUT    PACK CUTOFF DATE\n         LA    2,0                GET ZERO\n         L     2,16(,2)           LOAD ADDRESS OF CVT\n         CP    56+1(3,2),BUFR(3)  COMPARE DATES\n         B     DATECK             SKIP IF OK           ALWAYS OK - V2.3\n*\n*        HERE WE HAVE EXCEEDED THE CUTOFF DATE -- TELL HIM\n*\n         PRT   EXPIRE             PRINT EXPIRATION MESSAGE\n         ABEND 111                GIVE A FUNNY ABEND\n*\n*        HERE WE RECOMPUTE THE DATE CHECK DIGIT\n*\nDATECK   SR    0,0                CLEAR ACCUMULATOR\n         IC    1,DATECUT          FIRST DIGIT\n         AR    0,1                ADD IT IN\n         IC    1,DATECUT+1        SECOND DIGIT\n         AR    0,1                ADD IT IN\n         IC    1,DATECUT+2        THIRD DIGIT\n         AR    0,1                ADD IT IN\n         IC    1,DATECUT+3        FOURTH DIGIT\n         AR    0,1                ADD IT IN\n         IC    1,DATECUT+4        FIFTH DIGIT\n         AR    0,1                ADD IT IN\n         STC   0,CKDIGITC         STORE FOR LATER CHECK\n         B     NEWJOB             JUMP TO START NEW JOB\n         EJECT\n*\n*        CONVOUT                  CONVERT NUMBER FOR OUTPUT\n*\n*        (2)                      OUTPUT LOCATION\n*        (3)                      NUMBER TO CONVERT\n*        BAL   7,CONVOUT\n*\nCONVOUT  MVC   0(11,2),=X'2020202020202020202120' SET EDIT PATTERN\n         CVD   3,SAVE2            CONVERT ARGUMENT TO DECIMAL\n         LA    1,10(,2)           PRESET REGISTER 1 IN CASE NO SIGCHR\n         EDMK  0(11,2),SAVE2+2    EDIT TO CHARACTERS\n         BNM   *+10               SKIP IF NON-NEGATIVE\n         BCTR  1,0                POINT BEHIND CONVERTED NUMBER\n         MVI   0(1),C'-'          AND SET NEGATIVE SIGN\n         MVC   0(11,2),0(1)       LEFT JUSTIFY\n         BR    7                  RETURN TO CALLER\n*\n*        ROUTINE TO PRINT A LINE FROM THE PRINT BUFFER\n*\n*        BUFR                     ONE BYTE COUNT OF DATA CHARS\n*        BUFR+1 -- BUFR+N         DATA CHARACTERS FOR PRINT LINE\n*        BAL   5,PRNTLNB          CALL TO PRINT LINE\n*\nPRNTLNB  STM   5,7,PRNSAVE        SAVE WORK REGS\n         SR    5,5                CLEAR FOR IC\n         IC    5,BUFR             LOAD LENGTH OF IMAGE\n         LA    4,BUFR+1           POINT TO DATA CHARACTERS\n         SR    7,7                SET FORMAT LENGTH = 0 (UNFORMATTED)\n         L     0,PRINTDCB         LOAD POINTER TO PRINTER DCB\n         LA    2,SYSWRITE         POINT TO SYSTEM WRITE ROUTINE\n         BALR  1,2                CALL SYSTEM OUTPUT ROUTINE\n         NOP   0                  ERROR RETURN ON SYSPRINT NOT ALLOWED\n         LM    5,7,PRNSAVE        RESTORE REGS\n         BR    5                  RETURN TO CALLER\n*\n*        TABLE OF PARAMETERS\n*\nFSTPARM  PARAM L,DYNAMIN          MINIMUM DYNAMIC CORE\n         PARAM H,DYNAMAX          MAXIMUM DYNAMIC CORE\n         PARAM R,RESERV           RESERVED DYNAMIC CORE\n         PARAM C,CLIMIT           CARD LIMIT\n         PARAM P,PLIMIT           PAGE LIMIT\n         PARAM T,TLIMIT           TIME LIMIT\n         PARAM D,DLIMIT           DUMP LIMIT\n         PARAM N,PAGEDPTH         NUMBER OF LINES PER PAGE\n         PARAM I,INTVAL           INTERRUPT TYPE INDICATOR\nPARMNO   EQU   (*-FSTPARM)/4      CALC NUMBER OF PARAMETERS IN TABLE\n         EJECT\n*\n*        MESSAGES\n*\nOSMSG    MSG   '0SYSTEM = OS/360'\nPARMHEAD MSG   '0PARAMETER VALUES FOR THIS RUN'\nPARMPRT  MSG   ' X = XXXXXXXXXXX          '\nPRTMEM   MSG   '0DYNAMIC MEMORY AVAILABLE = XXXXXXXXXXX         '\nDYNAMSG  MSG   '0INADEQUATE DYNAMIC MEMORY -- RUN TERMINATED'\nTFIXMSG  MSG   ' TF APPLIED 2.3.XXXXXXXXXXX            '           V2.3\n         ORG   TFIXMSG                                             V2.3\n         DC    X'14'                                               V2.3\n         ORG   ,                                                   V2.3\nBLANKL   MSG   ' '\nHEDM0    MSG   '1INTERNAL SYSTEM ERROR ABORT'\nHEDM1    MSG   '0DUMP OF INTERFACE WORK AREA'\nHEDM2    MSG   '1DUMP OF ALLOCATED DATA AREA'\nEXPIRE   MSG   '0TRIAL PERIOD OVER, RETURN SYSTEM TO AUTHOR'\n*\n         LTORG ,                  LITERALS FOR INITIALIZATION CIRCUIT\n         TITLE 'OSINT -- OS INTERFACE -- INITIATE NEW JOB'\n*\n*        COME HERE TO INITIATE NEW JOB\n*\nNEWJOB   MVI   EOFLAG,0           RESET EOF FLAGS, SET NO DATA READ YET\n         L     10,READDCB         LOAD POINTER TO SYSIN DCB\n         NI    OFLAGS,X'FF'-EOFE  CLEAR POSSIBLE END OF FILE FLAG\n         MVC   PGDEPTH,PAGEDPTH   MOVE PAGE DEPTH TO DATA AREA\n         MVC   INTFLAG,INTVAL     MOVE INTERRUPT FLAG TO DATA AREA\n         L     10,PRINTDCB        POINT TO SYSPRINT DCB\n         L     1,PLIMIT           GET PAGE LIMIT\n         M     0,PAGEDPTH         CONVERT TO LINE (RECORD) LIMIT\n         ST    1,MAXRECW          STORE IN SYSPRINT DCB\n         L     10,PUNCHDCB        POINT TO SYSPUNCH DCB\n         MVC   MAXRECW,CLIMIT     SET LIMIT ON CARDS IN SYSPUNCH DCB\n         MVC   TSTART,TLIMIT      SAVE INITIAL TIME (SEE SYSTIME)\n*\n*        CLEAR ALLOCATED DATA AREA TO ZEROS\n*\n         SDR   0,0                GET DOUBLE WORD ZERO\n         LA    2,USERD            POINT TO USER SECTION OF DATA AREA\n         L     3,DATASIZE         LENGTH OF AREA\n         SH    3,=Y(USERD-DATA)   ADJUST FOR OUR STUFF AT START\n         LA    4,USERD-24(3)      POINT TO LAST 24 BYTES OF AREA\n         XC    0(24,4),0(4)       ZERO LAST 24 BYTES\n         SRL   3,5                /32 = NUMBER OF LOOPS\n*\n*        LOOP TO CLEAR 32 BYTES AT A TIME\n*\nCLEARC   STD   0,0(,2)            CLEAR 32 BYTES WITH FAST STD\n         STD   0,8(,2)            . . . .\n         STD   0,16(,2)           . . . .\n         STD   0,24(,2)           . . . .\n         LA    2,32(,2)           PUSH ADDRESS\n         BCT   3,CLEARC           LOOP BACK TILL ALL CLEARED\n*\n*        NOW SET TIMER AND INITIATE RUN\n*\n         STIMER TASK,OVERTIME,TUINTVL=TLIMIT SET PROPER TIME LIMIT\n         L     15,=V(SYSSTART)    POINT TO MAIN PROGRAM ENTRY POINT\n         ST    15,STARTADR        STORE ADDRESS OF SYSSTART\n         CLC   CKDIGIT,CKDIGITC   CHECK DATE CHECK DIGIT\n         BR    15                 OFF TO EXECUTE IF OK   ALWAYS OK V2.3\n*\n*        HERE HE HAS FIDDLED WITH THE DATE, GIVE A NASTY BOMB\n*\n         LM    0,15,2000(8)       CLEAR ALL REGS TO ZEROS\n         BR    15                 JUMP TO LOCATION ZERO\n         TITLE 'OSINT -- OS INTERFACE -- SYSDATE'\n*\n*        OBTAIN DATE IN MM/DD/YY FORMAT\n*\n*        ENTRY CONDITIONS\n*\n*        NO PARAMETERS PASSED\n*\n*        EXIT CONDITIONS\n*\n*        (0)                      POINTER TO DATE MM/DD/YY\n*\n*        ERROR CODES RETURNED\n*\n*        NONE\n*\nSYSDATE  ENTER ,                  ENTRY POINT\n         TIME  ,                  GET DATE IN YY/DDD FORM\n         ST    1,SAVE2+8          SAVE VALUE TO WORK WITH IT\n         ZAP   SAVE2(8),SAVE2+10(2)         MOVE IN DDD+SIGN, CLEAR\n         CVB   0,SAVE2            BINARY DAY TO (0)\n         SRL   1,4*3              RIGHT JUSTIFY YY + GARBAGE DIGIT\n         ST    1,SAVE2+4          STORE YY\n         OI    SAVE2+7,X'0F'      MAKE GARBAGE DIGIT A PLUS SIGN\n         CVB   1,SAVE2            BINARY YEARS TO (1)\n         LR    3,1                SAVE YEAR FOR LATER\n         L     5,=X'CEEFBB00'     LOAD BIT MASK FOR MONTH LENGTHS\n         N     1,=X'00000003'     GET 4'S RESIDUE FOR LEAP YEAR TEST\n         BNZ   *+8                SKIP IF NOT LEAP YEAR\n         O     5,=X'10000000'     SET FEB DAYS = 29 IN MONTH MASK\n         SR    2,2                INITIALIZE MONTHS REGISTER\n*\n*        NOW LOOP THROUGH MONTHS -- IN THE BIT MASK, EACH MONTH HAS\n*        TWO BITS -- ADDING THESE BITS TO 28 GIVES THE LENGTH\n*\nMONTHL   LA    2,1(,2)            BUMP COUNT OF MONTHS\n         SR    4,4                CLEAR DAYS IN MONTH REGISTER\n         SLDL  4,2                SHIFT IN ADJUSTING BITS\n         LA    4,28(,4)           ADD STANDARD BASE\n         SR    0,4                CRANK DAYS DOWN\n         BP    MONTHL             AND LOOP BACK IF MORE TO GO\n         AR    0,4                ELSE REPAIR DAYS COUNT & MERGE\n*\n*        EXIT POINT -- HERE WE ARE ALL SET WITH MONTH IN (2) DAY IN (0)\n*\n         MH    2,=H'100'          MM*100\n         AR    2,0                MM*100+DD\n         MH    2,=H'100'          MM*10000+DD*100\n         AR    2,3                MM*10000+DD*100+YY\n         CVD   2,SAVE2            CONVERT TO DECIMAL\n         MVC   DATE,DATEPAT       MOVE DATE EDIT PATTERN INTO PLACE\n         ED    DATE,SAVE2+4       EDIT TO MM/DD/YY FORM\n         LA    0,DATE+2           POINT TO DATE\n         B     EXIT0              EXIT PRESERVING (0) = ADDRESS OF DATE\n*\nDATEPAT  DC    X'F0212020612020612020'      EDIT PATTERN FOR DATE\n         TITLE 'OSINT -- OS INTERFACE -- SYSLOAD'\n*\n*        LOAD A MODULE\n*\n*        ENTRY CONDITIONS\n*\n*        (4)                      ADDRESS OF MODULE NAME\n*\n*        (5)                      LENGTH OF MODULE NAME\n*\n*        EXIT CONDITIONS\n*\n*        (0)                      ADDRESS OF LOADED CODE\n*\n*        ERROR CODES RETURNED\n*\n*        E$MODN                   MODULE NAME LONGER THAN 8 CHARS\n*        E$LIOE                   I/O ERROR DURING LOAD\n*        E$LNFN                   ENTRY NOT FOUND\n*\nSYSLOAD  ENTER ,                  ENTRY POINT\n         LA    7,E$MODN           SET PROPER ERROR IN CASE > 8 CHARS\n         BAL   2,GETNAME          MOVE MODULE NAME TO 'NAME'\n         MVC   BLDLIST(4),=X'0001003A'      SET 1 ENTRY, LENGTH = 58\n         LR    3,0                COPY PARAMETER ADDRESS\n         BLDL  0,BLDLIST          SEARCH DIRECTORY\n         SH    15,=H'4'           TEST RETURN CODE\n*\n*        CHECK HERE FOR ERROR\n*\n         BZ    E$LNFN             B IF NOT FOUND\n         BP    E$LIOE             ELSE I/O ERROR\n*\n*        HERE IF WE FOUND THE ENTRY\n*\nLODER1   LOAD  DE=NAME            LOAD THE MODULE\n         B     EXIT0              EXIT PRESERVING (0) = CODE ADDRESS\n         TITLE 'OSINT -- OS INTERFACE -- SYSUNLOD'\n*\n*        UNLOAD A LOAD MODULE\n*\n*        ENTRY CONDITIONS\n*\n*        (4)                      POINTER TO MODULE NAME\n*\n*        (5)                      LENGTH OF MODULE NAME\n*\n*        EXIT CONDITIONS\n*\n*        NO RESULTS RETURNED\n*\n*        ERROR CODES RETURNED\n*\n*        E$DELE                   MODULE NOT CURRENTLY LOADED\n*        E$MODN                   MODULE NAME LONGER THAN 8 CHARS\n*\nSYSUNLOD ENTER ,                  ENTRY POINT\n         LA    7,E$MODN           SET MESSAGE IN CASE NAME LENGTH > 8\n         BAL   2,GETNAME          ACQUIRE NAME\n         DELETE EPLOC=NAME        RELEASE THE MODULE\n         LTR   15,15              TEST RETURN CODE\n         BZ    EXIT               SUCCESS RETURN IF OK\n         B     E$DELE             ELSE ERROR RETURN\n         TITLE 'OSINT -- OS INTERFACE -- SYSPHASE'\n*\n*        LOAD A PHASE IN A MULTIPHASE ENVIRONMENT\n*\n*        ENTRY CONDITIONS\n*\n*        (0)                      CONTAINS VCON FOR PHASE\n*\n*        (4)                      POINTS TO 8 CHARACTER PHASE NAME\n*\n*        EXIT CONDITIONS\n*\n*        REQUESTED PHASE LOADED\n*\n*        ERROR CODES RETURNED\n*\n*        NONE\n*\n*        THE PHASE NAME IS NOT REQUIRED IN OS. IT IS INCLUDED IN THE\n*        CALLING SEQUENCE FOR USE IN OTHER SYSTEMS (E.G. DOS/360)\n*\nSYSPHASE ENTER ,                  ENTRY POINT\n         LR    1,0                COPY VCON TO OS PARAMETER REGISTER\n         LA    0,1                INDICATE SEGWT\n         SVC   37                 ISSUE SEGWT SVC\n         B     EXIT               RETURN TO CALLER\n         TITLE 'OSINT -- OS INTERFACE -- SYSSETP'\n*\n*        INFORM INTERFACE OF CHANGE IN DATA AREA POINTER\n*\n*        ENTRY CONDITIONS\n*\n*        (8)                      POINTS TO NEW DATA AREA\n*\n*        EXIT CONDITIONS\n*\n*        NO RESULTS RETURNED\n*\n*        ERROR CODES RETURNED\n*\n*        NONE\n*\n*        THIS ENTRY POINT IS USED IF THE EXECUTING PROGRAM WISHES TO\n*        REGARD SOME OTHER AREA THAN THE ALLOCATED DYNAMIC AREA AS\n*        THE DATA REGION USED FOR COMMUNICATION WITH THE INTERFACE.\n*        BEFORE THIS ROUTINE IS CALLED. THE CALLER MUST COPY ALL THE\n*        STANDARD INFORMATION FROM THE START OF THE ORIGINAL DATA\n*        AREA ALLOCATED BY THE INTERFACE INTO THE NEW AREA.\n*\nSYSSETP  ENTER ,                  ENTRY POINT\n         ST    8,DATAPTR          STORE NEW DATA AREA POINTER\n         B     EXIT               RETURN TO CALLER\n         TITLE 'OSINT -- OS INTERFACE -- SYSDCB'\n*\n*        LOCATE DCB FOR GIVEN FILENAME\n*\n*        ENTRY CONDITIONS\n*\n*        (4)                      POINTER TO FILENAME\n*        (5)                      LENGTH OF FILENAME\n*\n*        EXIT CONDITIONS\n*\n*        (0)                      POINTER TO DCB\n*\n*        ERROR CODES RETURNED\n*\n*        E$MSDD                   MISSING DD CARD\n*        E$FILG                   ILLEGAL FILENAME\n*\nSYSDCB   ENTER ,                  ENTRY POINT\n         LA    7,E$FILG           SET ERROR MESSAGE IF BAD NAME\n         BAL   2,GETNAME          ASSEMBLE FILENAME\n         L     10,PTRDCB          POINT TO FIRST DCB\n*\n*        LOOP TO CHECK FOR DCB WITH MATCHING NAME\n*\nSYSDCBL  LTR   0,10               COPY AND TEST POINTER\n         BZ    E$MSDD             MISSING DD CARD IF AT END OF CHAIN\n         CLC   NAME(8),FILENAME   ELSE COMPARE NAMES\n         BE    EXIT0              EXIT WITH DCB PTR SET IF MATCH\n         L     10,DCBNEXT         ELSE POINT TO NEXT DCB ON CHAIN\n         B     SYSDCBL            AND LOOP BACK TO CHECK NEXT\n         TITLE 'OSINT -- OS INTERFACE -- SYSMAXL'\n*\n*        GET MAXIMUM RECORD LENGTH FOR INPUT RECORD\n*\n*        ENTRY CONDITIONS\n*\n*        (0)                      POINTER TO DCB\n*\n*        EXIT CONDITIONS\n*\n*        (0)                      MAXIMUM LENGTH OF DATA RECORD\n*\n*        ERROR CODES RETURNED\n*\n*        NONE\n*\nSYSMAXL  ENTER ,                  ENTRY POINT\n         LR    10,0               COPY DCB POINTER\n         LH    0,MAXRECL          LOAD MAX DATA RECORD LENGTH\n         TM    OFLAGS,OPENI       MAKE SURE WE ARE OPEN FOR INPUT\n         BO    EXIT0              RETURN WITH RESULT IN (0) IF SO\n*\n*        IF NOT OPEN FOR INPUT WE MUST OPEN THE FILE FIRST\n*\n         TM    OFLAGS,OPENO       ARE WE OPEN FOR OUTPUT?\n         BO    E$READ             GIVE ERROR RETURN IF SO\n         MVC   MLIST(LOPNLIST),OPNLIST      MOVE LIST INTO PLACE\n         OPEN  ((10),INPUT),MF=(E,MLIST)    EXECUTE OPEN\n         TM    DCBOFLGS,OPENOK    WAS OPEN SUCESSFUL?\n         BZ    E$OPNI             GIVE ERROR IF NOT\n         OI    OFLAGS,OPENI       ELSE SET OPEN FOR INPUT FLAG\n         LH    0,MAXRECL          LOAD MAX DATA RECORD LENGTH\n         B     EXIT0              RETURN RESULT IN REG (0)\n         TITLE 'OSINT -- OS INTERFACE -- SYSREAD'\n*\n*        READ A RECORD\n*\n*        CALLING CONDITIONS\n*\n*        (0)                      POINTER TO SPITBOL DCB\n*        (4)                      POINTER TO BUFFER TO RECEIVE RECORD\n*\n*        EXIT CONDITIONS\n*\n*        (0)                      LENGTH OF RECORD ACTUALLY READ\n*                                 SET TO ZERO FOR A NULL RECORD\n*                                 SET NEGATIVE FOR END OF FILE\n*\n*        ERROR CODES RETURNED\n*\n*        E$READ                   FILE OPENED FOR OUTPUT\n*        E$EOFR                   PREVIOUS END OF FILE ENCOUNTERED\n*        E$IERR                   PERMANENT INPUT ERROR\n*        E$NOIN                   ATTEMPTED READ FROM WRITE ONLY FILE\n*        E$OPNI                   ERROR IN OPENING FILE FOR INPUT\n*\nSYSREAD  ENTER ,                  ENTRY POINT\n         LR    10,0               COPY POINTER TO DCB INTO PROPER REG\n         TM    OFLAGS,OPENI       ARE WE OPEN FOR INPUT?\n         BO    SYSREAD2           SKIP IF SO\n         TM    OFLAGS,OPENO       ARE WE OPEN FOR OUTPUT?\n         BO    E$READ             GIVE ERROR IF FILE OPENED FOR OUTPUT\n*\n*        HERE TO OPEN FILE FOR INPUT\n*\nSYSREAD1 MVC   MLIST(LOPNLIST),OPNLIST      MOVE LIST INTO PLACE\n         OPEN  ((10),INPUT),MF=(E,MLIST)    EXECUTE OPEN\n         TM    DCBOFLGS,OPENOK    WAS OPEN SUCCESSFUL?\n         BZ    E$OPNI             GIVE ERROR IF NOT\n         OI    OFLAGS,OPENI       SET OPEN FOR INPUT FLAG\n*\n*        HERE WITH FILE OPEN FOR INPUT\n*\nSYSREAD2 TM    OFLAGS,EOFE        PREVIOUS END OF FILE\n         BO    E$EOFR             GIVE ERROR MSG IF SO\n*\n*        HERE TO MOVE THE RECORD\n*\nSYSREAD3 MVI   REREAD,0           RESET FLAG FOR REREAD\n         TM    DCBRECFM,F         CHECK RECORD FORMAT\n         BZ    SYSREADV           SKIP IF RECORD IS VARIABLE LENGTH\n         GET   (10),(4)           TRANSMIT RECORD\n         CLI   REREAD,0           MUST WE REREAD\n         BNZ   SYSREAD3           LOOP BACK IF SO\n         EJECT\n*\n*        HERE FOR F AND U TYPE RECORDS\n*\n         LH    0,DCBLRECL         LOAD RECORD LENGTH\n*\n*        HERE TO EXIT WITH CHECK FOR ./* EOF ON SYSIN\n*\nSYSREADX TM    OFLAGS,READER      STANDARD READ FILE?\n         BNO   SYSREADZ           SKIP IF NOT\n         CH    0,=H'80'           CHECK FOR RECORD TOO LONG ON SYSIN\n         BH    E$SSIN             GIVE ERROR IF SO\n         CLI   BATCHFLG,0         IS BATCHING ALLOWED?\n         BE    SYSREADZ           SKIP IF NOT\n         CLC   0(3,4),=C'./*'     ELSE TEST FOR TEMPORARY EOF ON READER\n         BNE   SYSREADZ           SKIP IF NOT\n         OI    EOFLAG,TEMPEOF     IF SO, SET FLAG\n         TM    EOFLAG,DATAIN      DID WE READ ANYTHING?\n         BNO   NEWJOB             IF NOT, SKIP TO IGNORE NULL PROGRAM\n         B     EOF1               AND MERGE WITH EOF CIRCUIT\n*\n*        HERE FOR VARIABLE LENGTH RECORD\n*\nSYSREADV SH    4,=H'4'            POINT 4 BYTES BEHIND RECORD\n         MVC   SAVEBF,0(4)        SAVE CHARS THERE NOW\n         GET   (10),(4)           TRANSMIT V TYPE RECORD\n         MVC   SAVE2(2),0(4)      MOVE RECORD LENGTH\n         MVC   0(4,4),SAVEBF      RESTORE 4 BYTES BEFORE BUFFER\n         LA    4,4(,4)            POINT TO DATA\n         CLI   REREAD,0           MUST WE REREAD?\n         BNZ   SYSREAD3           LOOP BACK IF SO\n         LH    0,SAVE2            LOAD RECORD LENGTH\n         SH    0,=H'4'            GET LENGTH OF DATA BYTES\n         CH    0,=H'1'            CHECK FOR ONE CHARACTER RECORD\n         BH    SYSREADX           JUMP IF NOT 1 CHAR RECORD\n         CLI   0(4),X'00'         IF SO, IS IT HEX ZERO RECORD?\n         BNE   SYSREADZ           SKIP IF NOT\n         SR    0,0                ELSE TREAT 1 CHAR X'00' AS NULL\n*\n*        HERE TO RETURN TO CALLER\n*\nSYSREADZ OI    EOFLAG,DATAIN      RECORD SOME DATA HAS BEEN READ\n         B     EXIT0              EXIT TO CALLER\n         TITLE 'OSINT -- OSINTERFACE -- SYSWRITE'\n*\n*        WRITE A RECORD\n*\n*        CALLING CONDITIONS --\n*\n*        (0)                      POINTER TO SPITBOL DCB\n*        (4)   SADR               ADDRESS OF STRING TO BE WRITTEN\n*        (5)   SLEN               LENGTH OF STRING TO BE WRITTEN\n*        (6)   FADR               ADDRESS OF FORMAT (UNUSED IF FLEN=0)\n*        (7)   FLEN               LENGTH OF FORMAT STRING\n*\n*        ERROR CODE RETURNED\n*\n*        E$WRIT                   FILE OPENED FOR INPUT\n*        E$OERR                   PERMANENT OUTPUT ERROR\n*        E$NOUT                   ATTEMPTED WRITE TO READ ONLY FILE\n*        E$OPNO                   ERROR IN OPENING FILE FOR OUTPUT\n*\nSYSWRITE ENTER ,                  ENTRY POINT\n         LR    10,0               COPY DCB POINTER\n         TM    OFLAGS,OPENO       ARE WE OPEN FOR OUTPUT?\n         BO    SYSWRIT1           SKIP IF SO\n         TM    OFLAGS,OPENI       ARE WE OPEN FOR INPUT?\n         BO    E$WRIT             GIVE ERROR MESSAGE IF SO\n*\n*        HERE TO OPEN FILE FOR OUTPUT\n*\nSYSWRIT0 MVC   MLIST(LOPNLIST),OPNLIST      MOVE OPEN PARAMETER LIST\n         OPEN  ((10),OUTPUT),MF=(E,MLIST)   EXECUTE OPEN\n         TM    DCBOFLGS,OPENOK    WAS OPEN SUCCESSFUL?\n         BZ    E$OPNO             GIVE ERROR IF NOT\n         OI    OFLAGS,OPENO       SET OPEN FOR OUTPUT FLAG\n*\n*        HERE TO PERFORM THE OUTPUT\n*\nSYSWRIT1 LTR   SLEN,SLEN          TEST STRING LENGTH\n         BNZ   SYSWRIT2           JUMP IF NON-NULL\n*\n*        HERE FOR A NULL STRING, WRITE AS 1 CHAR X'00'\n*\n         LA    SADR,=X'00'        POINT TO DUMMY RECORD\n         LA    SLEN,1             SET DUMMY RECORD LENGTH = 1\n         TM    DCBRECFM,V         TEST RECORD FORMAT TYPE\n         BZ    SYSWRITG           IF NOT V RECORD WRITE BLANK REC  V2.3\n         TM    DCBRECFM,A         IF V WITH ASA WRITE BLANK REC    V2.3\n         BZ    SYSWRIT2           ELSE V NO ASA WRITE X'00' REC    V2.3\nSYSWRITG LA    SADR,=C' '         ELSE SET TO WRITE A BLANK RECORD V2.3\n*\n*        HERE AFTER TAKING CARE OF NULL POSSIBILITY\n*\nSYSWRIT2 CH    FLEN,=H'1'         CHECK FORMAT LENGTH\n         BNH   SYSWRITS           SKIP IF NOT FORTRAN FORMAT\n         EJECT\n*\n*        HERE FOR CASE OF FORTRAN FORMAT\n*\n         BAL   3,FORMAT           CALL FORMAT PROCESSING ROUTINE\n         B     EXIT               ALL DONE\n*\n*        HERE FOR UNFORMATTED OR SINGLE CHAR FORMAT (CONTROL CHAR)\n*\nSYSWRITS LTR   FLEN,FLEN          CHECK FOR FORMAT (CONTROL CHAR)\n         BNZ   SYSWRITM           SKIP IF FORMATTED\n         LA    FADR,SAVE2         ELSE SET GARBAGE LOC FOR CHAR RESTORE\n         B     SYSWRITL           AND JUMP TO CALL WRITREC\n*\n*        COME HERE FOR FORMATTED RECORD\n*\nSYSWRITM BCTR  SADR,0             POINT TO CHAR BEHIND RECORD\n         LA    SLEN,1(,SLEN)      ADJUST LENGTH FOR CONTROL CHARACTER\n         MVC   SAVCHR,0(SADR)     SAVE CURRENT BYTE BEHIND RECORD\n         MVC   0(1,SADR),0(FADR)  SET CONTROL CHARACTER\n         LR    FADR,SADR          SAVE LOC TO REPLACE CHAR\n*\n*        MERGE HERE FOR UNFORMATTED RECORDS\n*\nSYSWRITL LH    R1,MAXRECL         LOAD MAX RECORD LENGTH\n         LR    R2,SADR            POINT TO THIS RECORD\n         CR    R1,SLEN            WILL THIS BE A FULL RECORD?\n         BNH   *+6                SKIP IF SO\n         LR    R1,SLEN            ELSE SET TO WRITE REST\n         AR    SADR,R1            BUMP STRING POINTER\n         SR    SLEN,R1            DECREMENT COUNT LEFT\n         BAL   LINK1,WRITREC      OUTPUT RECORD\n         MVC   0(1,FADR),SAVCHR   REPLACE SAVED CHAR BEHIND RECORD\n*                                 NOTE: HARMLESS STORE IN SAVE2\n*                                 IF UNFORMATTED\n         LTR   SLEN,SLEN          MORE TO GO?\n         BNP   EXIT               IF NOT, JUMP TO EXIT\n         TM    DCBRECFM,A         ASA CONTROL CHARACTERS?\n         BNO   SYSWRITL           IF NOT, BACK TO TREAT AS UNFORMATTED\n         LA    FADR,=C' '         FOR ASA CONTROL CHARS, POINT TO BLANK\n         B     SYSWRITM           AND BACK TO TREAT AS FORMATTED\n         EJECT\n*\n*        LOCATE                   OBTAIN A BLANK BUFFER\n*\n*        BAL   LINK1,LOCATE\n*        (BADR)                   POINTS TO BUFFER\n*        BUFSTART                 POINTS TO BUFFER\n*        (BLEN)                   MAX RECORD LENGTH\n*\nLOCATE   LH    R2,MAXRECL         GET MAXIMUM RECORD LENGTH\n         LR    BLEN,R2            SAVE FOR RETURN\n         AH    R2,=H'4'           BUMP POINTER FOR EXTRA STUFF\n         CH    R2,OUTWBFLN        IS CURRENT WORK BUFFER LONG ENOUGH?\n         BNH   LOCATE1            SKIP IF SO\n*\n*        HERE IF WE MUST GET A NEW LARGER WORK BUFFER\n*\n         LH    R0,OUTWBFLN        LOAD OLD BUFFER LENGTH\n         FREEMAIN  R,LV=(0),A=OUTWBF        FREE OLD AREA\n         LR    R0,R2              COPY NEW LENGTH REQUIRED\n         GETMAIN   R,LV=(0)       ALLOCATE NEW AREA\n         ST    R1,OUTWBF          STORE BUFFER POINTER\n         STH   R2,OUTWBFLN        STORE NEW LENGTH\n*\n*        MERGE HERE TO CLEAR BUFFER OBTAINED\n*\nLOCATE1  L     BADR,OUTWBF        POINT TO BUFFER\n         AH    BADR,=H'4'         ALLOW 4 EXTRA BYTES AT START\n         LA    R0,256+1           CONSTANT TO CLEAR\n         LR    R1,BADR            COPY STARTING ADDRESS\n         LR    R2,BLEN            GET NUMBER OF CHARACTERS TO BLANK\n*\n*        LOOP TO CLEAR 257 CHARACTERS AT A TIME\n*\nLOCATEL  MVI   0(R1),C' '         SET BLANK AT START\n         CR    R2,R0              HOW MANY CHARS LEFT?\n         BNH   LOCATEX            JUMP IF ONLY ONE CHUNK LEFT\n         MVC   1(256,R1),0(R1)    ELSE BLANK 256 CHARS (+ 1 = 257)\n         AR    R1,R0              PUSH POINTER\n         SR    R2,R0              DECREMENT COUNT OF CHARS LEFT\n         B     LOCATEL            LOOP BACK\n*\n*        HERE FOR LAST CHUNK\n*\nLOCATEX  BCTR  R2,0               ADJUST COUNT FOR 360\n         BCTR  R2,0               -1 FOR BLANK INSERTED\n         EX    R2,LOCATEM         CLEAR REMAINING CHARACTERS\n         ST    BADR,BUFSTART      SAVE LOC OF START OF BUFFER\n         BR    LINK1              RETURN TO CALLER\n*\nLOCATEM  MVC   1(*-*,R1),0(R1)    BLANK LAST CHARACTERS\n         EJECT\n*\n*        WRITREC                  SUBROUTINE TO WRITE A RECORD\n*\n*        (R1)                     RECORD LENGTH IN CHARACTERS\n*        (R2)                     STARTING ADDRESS OF RECORD\n*        BAL   LINK1,WRITREC\n*        THIS ROUTINE DESTROYES REGISTERS 3,9\n*\n*\nWRITREC  ST    LINK1,WRITRECS     SAVE LINKAGE\n         CH    R1,=H'1'           ONE CHARACTER RECORD?\n         BH    WRITREC2           SKIP IF NOT\n*\n*        HERE WE HAVE A ONE CHARACTER RECORD. THIS CAUSES TROUBLE ON\n*        PRINTERS WITH ASA CONTROL, SO PAD AN EXTRA BLANK IF ASA CNTRL\n*\n         TM    DCBRECFM,A         ASA CONTROL CHARACTERS?\n         BNO   WRITREC2           SKIP IF NOT\n         MVC   BUFR+10(1),0(2)    ELSE MOVE THE ONE CHAR TO BUFFER\n         MVI   BUFR+11,C' '       SUPPLY A BLANK PAD CHARACTER\n         LA    R1,2               SET NEW RECORD LENGTH TWO CHARACTERS\n         LA    R2,BUFR+10         POINT TO NEW RECORD\n*\n*        MERGE HERE AFTER DEALING WITH ONE CHARACTER RECORDS\n*\nWRITREC2 TM    DCBRECFM,V         CHECK RECORD FORMAT\n         BZ    WRITRECF           SKIP IF FIXED LENGTH RECORDS\n         TM    DCBRECFM,U         FURTHER CHECK\n         BO    WRITRECU           SKIP IF UNDEFINED RECORDS\n*\n*        HERE FOR VARIABLE LENGTH RECORDS\n*\n         SH    R2,=H'4'           POINT FOUR BYTES BEHIND BUFFER\n         MVC   SAVEBF,0(R2)       SAVE THE FOUR BYTES THERE\n         LA    R1,4(,R1)          ADD IN LENGTH OF CONTROL FIELD\n         SLL   R1,16              LEFT JUSTIFY RECORD LENGTH\n         ST    R1,SAVE2           STORE RECORD LENGTH + 2 ZERO BYTES\n         MVC   0(4,R2),SAVE2      SET AS HEADER FOR V TYPE RECORD\n         B     WRITRECM           JUMP TO MERGE POINT\n*\n*        HERE FOR UNDEFINED RECORDS\n*\nWRITRECU STH   R1,DCBLRECL        STORE ACTUAL LENGTH IN DCB\n         B     WRITRECM           MERGE\n         EJECT\n*\n*        WRITREC (CONTINUED)\n*\n*        HERE FOR FIXED LENGTH RECORDS\n*\nWRITRECF CH    R1,DCBLRECL        DO WE NEED BLANK PADDING?\n         BE    WRITRECM           IF NOT, JUMP TO MERGE\n*\n*        HERE IF WE MUST BLANK PAD A FIXED LENGTH RECORD\n*\n         STM   R1,R2,SAVE2        SAVE REGS\n         BAL   LINK1,LOCATE       GET A BLANK BUFFER\n         LM    R1,R2,SAVE2        RESTORE REGS\n         BAL   LINK1,FORMMOVE     MOVE PARTIAL RECORD TO THIS BUFFER\n         L     R2,BUFSTART        POINT TO START OF BUFFER, MERGE\n*\n*        MERGE HERE TO MOVE RECORD TO SYSTEM BUFFERS\n*\nWRITRECM L     0,MAXRECW          FIRST GET OUTPUT RECORD COUNTER\n         SH    0,=H'1'            DECREMENT\n         ST    0,MAXRECW          STORE DECREMENTED COUNT\n         BZ    EXIT0              IMMEDIATE EXIT IF TOO MANY RECORDS\n         PUT   (10),(2)           ELSE MOVE RECORD TO SYSTEM BUFFERS\n         L     LINK1,WRITRECS     RESTORE WRITREC LINKAGE\n         TM    DCBRECFM,F         CHECK RECORD FORMAT\n         BCR   1,LINK1            ALL DONE UNLESS V TYPE RECORD\n         MVC   0(4,R2),SAVEBF     ELSE RESTORE 4 BYTES BEFORE V RECORD\n         BR    LINK1              AND THEN RETURN TO CALLER\n         TITLE 'OSINT -- OS INTERFACE -- FORTRAN FORMAT PROCESSOR'\n*\n*        THIS ROUTINE PROCESSES FORTRAN FORMATS CONTAINING ANY OF\n*        THE FOLLOWING FORMAT TYPES A,X,H,',T,/,(). THE LOCATE ROUTINE\n*        IS USED TO FIND WHERE THE CONVERTED RECORD IS TO BE MOVED\n*\n*        CALLING SEQUENCE\n*\n*        (4)                      POINTER TO STRING TO BE OUTPUT\n*        (5)                      REAL LENGTH OF OUTPUT STRING\n*        (6)                      POINTER TO OUTPUT FORMAT\n*        (7)                      REAL LENGTH OF FORMAT\n*        BAL   3,FORMAT\n*\n*        REGISTER DEFINITIONS FOR FORMAT ROUTINE\n*\nR0       EQU   0                  SCRATCH\nR1       EQU   1                  SCRATCH\nR2       EQU   2                  SCRATCH\nSADR     EQU   4                  ADDRESS OF NEXT CHARACTER IN STRING\nSLEN     EQU   5                  NUMBER OF CHARACTERS LEFT IN STRING\nFADR     EQU   6                  ADDRESS OF NEXT CHARACTER IN FORMAT\nFLEN     EQU   7                  NUMBER OF CHARACTERS LEFT IN FORMAT\nBADR     EQU   3                  ADDRESS OF NEXT AVAILABLE LOC IN BUFR\nBLEN     EQU   9                  NUMBER OF POSITIONS LEFT IN BUFFER\nLINK1    EQU   14                 INTERNAL CALLING REGISTER\n*\n*        ENTRY POINT\n*\nFORMAT   MVC   FSTAKADR,FSTAKBOT  INITIALIZE STACK ADDRESS\n         ST    3,FORMRTN          SAVE RETURN POINT\n         CLI   0(FADR),C'('       IS FIRST CHARACTER A (?\n         BNE   E$FNLP             ERROR IF NOT\n         LA    R1,0(FLEN,FADR)    POINT PAST FORMAT\n         BCTR  R1,0               POINT TO LAST CHARACTER\n         CLI   0(R1),C')'         DOES IT END WITH A )?\n         BNE   E$FNRP             ERROR IF NOT\n         BAL   LINK1,LOCATE       POINT TO BUFFER (SET BADR,BLEN)\n         LA    R1,1               SET REPEAT COUNT FOR OUTER LEVEL\n         EJECT\n*\n*        COME HERE FOR LEFT PAREN -- PUT ENTRY ON STACK\n*\nFORMLP   L     R2,FSTAKADR        GET CURRENT STACK LEVEL\n         LA    R2,4(,R2)          PUSH STACK LEVEL\n         C     R2,FSTAKEND        HAVE WE OVERFLOWED?\n         BNL   E$FSOV             OFF TO GIVE ERR MSG IF SO\n         ST    R2,FSTAKADR        ELSE STORE PUSHED POINTER\n         ST    FADR,0(,R2)        ELSE STORE PAREN ADDRESS\n         STC   R1,0(,R2)          AND SAVE REPEAT COUNT\n         ST    FADR,FLASTLP       SAVE FOR FORMAT REPEAT\n*\n*        COME HERE TO DECREASE FORMAT COUNT AND PUSH FADR\n*\nFORMLP0  BCTR  FLEN,0             DECREASE NUMBER OF CHARS LEFT\n*\n*        COME HERE TO JUST PUSH FADR PAST 1 CHAR\n*\nFORMLP1  LA    FADR,1(,FADR)      BUMP PAST CHARACTER\n*\n*        COME HERE TO EXAMINE NEXT ELEMENT IN FORMAT\n*\nFORMLOOP BAL   LINK1,FORMNUM      TRY TO GET A NUMBER\n         B     FNODIG             TRY SOMETHING ELSE IF NO NUMBER\n         CLI   0(FADR),C'A'       IS THIS AN A TYPE FORMAT?\n         BNE   FORMNOTA           SKIP IF NOT\n*\n*        COME HERE TO PROCESS AN A TYPE FORMAT, R1=REPEAT COUNT\n*\nFORMA    LR    R2,R1              SAVE FOR POSSIBLE NEW NUMBER\n         LA    FADR,1(,FADR)      PUSH PAST THE 'A'\n         BCTR  FLEN,0             DECREASE REMAINING SIZE\n         BAL   LINK1,FORMNUM      TRY TO GET ANOTHER NUMBER\n         LA    R1,1               SET DEFAULT LENGTH TO 1\n         MR    R0,R2              A FIELD WIDTH IS PRODUCT OF 2 NUMBERS\n         EJECT\n*\n*        COME HERE WITH 'A' FIELD WIDTH IN (R1)\n*\nFORMA1   SR    SLEN,R1            SUB NUMBER OF CHARS TO BE USED\n         BNM   *+10               SKIP IF ENOUGH CHARACTERS\n         AR    R1,SLEN            ELSE SET MOVE AMOUNT TO NO. OF CHARS\n         BZ    FORMA2             SKIP IF NO CHARACTERS TO MOVE\n         LR    R2,SADR            FROM ADDRESS IS START OF STRING\n         AR    SADR,R1            PUSH PAST MOVED CHARACTERS\n         BAL   LINK1,FORMMOVE     AND MOVE THE CHARACTERS\n         LTR   SLEN,SLEN          DID WE HAVE AN UNFILLED A FIELD?\n         BNM   FNODIG             GET NEXT ELEMENT IF NOT\n*\n*        COME HERE ON END OF FORMAT PROCESSING\n*\nFORMA2   BAL   LINK1,RECOUT       OUTPUT RECORD\n         L     3,FORMRTN          RELOAD RETURN POINT\n         BR    3                  RETURN TO CALLER\n*\n*        COME HERE TO CHECK FOR X TYPE FORMAT\n*\nFORMNOTA CLI   0(FADR),C'X'       IS IT X TYPE?\n         BNE   FORMNOTX           JUMP IF NOT\n*\n*        COME HERE FOR 'X' FORMAT WITH COUNT IN (R1)\n*\nFORMX    AR    BADR,R1            PUSH BUFFER POINTER\n         SR    BLEN,R1            DECREMENT COUNT OF CHARS LEFT IN BFR\n         B     FORMLP0            LOOP BACK FOR NEXT ITEM\n*\n*        COME HERE TO CHECK FOR H TYPE FORMAT\n*\nFORMNOTX CLI   0(FADR),C'H'       IS IT H TYPE FORMAT?\n         BNE   FORMNOTH           SKIP IF NOT\n         BCTR  FLEN,0             DECREASE COUNT FOR 'H'\n         SR    FLEN,R1            IS THIS A LEGITIMATE NUMBER?\n         BNP   E$FHLN             GIVE ERROR MESSAGE IF NOT\n         LA    R2,1(,FADR)        POINT TO FIRST DATA CHARACTER\n         AR    FADR,R1            SKIP PAST DATA\n         BAL   LINK1,FORMMOVE     MOVE CHARACTERS\n         B     FORMLP1            AND PUSH FORMAT ADDRESS WHEN DONE\n*\n*        COME HERE TO CHECK FOR (\n*\nFORMNOTH CLI   0(FADR),C'('       IS IT LEFT PARENTHESIS?\n         BE    FORMLP             MAKE STACK ENTRY IF SO\n         B     E$FILL             ELSE ILLEGAL FORMAT TYPE\n         EJECT\n*\n*        COME HERE IF FORMAT TYPE NOT STARTED WITH DIGITS\n*\nFNODIG   CLI   0(FADR),C' '       IS IT A BLANK?\n         BE    FORMLP0            SKIP IT AND CONTINUE IF SO\n         CLI   0(FADR),C','       IS IT A COMMA?\n         BE    FORMLP0            SKIP PAST IT IF SO\n         LA    R1,1               SET DEFAULT COUNT FOR 'A' OR '('\n         CLI   0(FADR),C'A'       IS IT A TYPE FORMAT?\n         BE    FORMA              MERGE IF SO\n         CLI   0(FADR),C'('       IS IT LEFT PARENTHESIS?\n         BE    FORMLP             MAKE STACK ENTRY IF SO\n         CLI   0(FADR),C'X'       CHECK FOR AN X WITH NO COUNT\n         BE    FORMX              JUMP BACK IF SO TO GET ONE SPACE\n         CLI   0(FADR),C')'       IS IT RIGHT PARENTHESIS?\n         BNE   FORMNTRP           SKIP IF NOT\n*\n*        HERE FOR ) -- LOOP BACK IF REPEAT COUNT NOT EXHAUSTED\n*\n         L     R2,FSTAKADR        GET ADDRESS OF CURRENT STACK ENTRY\n         SR    R0,R0              CLEAR FOR IC\n         IC    R0,0(,R2)          GET REPEAT COUNT\n         BCT   R0,FORMRP1         DECREMENT AND TEST REPEAT COUNT\n*\n*        COME HERE IF LOOP DONE\n*\n         SH    R2,=H'4'           UNCONVER PREVIOUS ENTRY\n         ST    R2,FSTAKADR        STORE FOR NEXT REFERENCE\n         C     R2,FSTAKBOT        HAVE WE GONE PAST BOTTOM?\n         BH    FORMLP0            SKIP PAST ) IF NOT\n*\n*        COME HERE IN CASE OF TOO MANY )'S OR END OF FORMAT\n*\n         BCT   FLEN,E$FUBP        TEST FOR END OF FMT, ERROR IF NOT\n         BAL   LINK1,RECOUT       OUTPUT RECORD\n         LTR   SLEN,SLEN          ARE WE AT END OF STRING?\n         L     3,FORMRTN          RELOAD RETURN POINT IN CASE\n         BCR   Z,3                RETURN IF SO TO CALLER\n         BAL   LINK1,LOCATE       ELSE GET BUFFER PTRS FOR NEXT RECORD\n         LA    R2,FORMSTAK        GET ADDR IF ONLY ONE ENTRY\n         CLC   FLASTLP+1(3),FORMSTAK+1      WERE THERE ANY OTHER LPS?\n         BE    *+8                SKIP IF NOT (LEAVE 1 STACK ENTRY)\n         LA    R2,FORMSTAK+4      INDICATE 2 ENTRIES\n         ST    R2,FSTAKADR        STORE STACK POINTER\n         LA    FLEN,1(,FADR)      POINT PAST END OF FORMAT FOR AD CALC\n         L     FADR,FLASTLP       POINT TO PREVIOUS LEFT PAREN\n         SR    FLEN,FADR          CALCULATE NEW LENGTH REMAINING\n         B     FORMLP0            JUMP TO GET NEXT FORMAT CHARACTER\n         EJECT\n*\n*        COME HERE IF MORE LOOPING TO GO FOR THIS PAREN CASE\n*\nFORMRP1  STC   R0,0(,R2)          STORE UPDATED REPEAT COUNT\n         AR    FLEN,FADR          POINT OFF STRING\n         L     FADR,0(,R2)        GET STACK ENTRY\n         LA    FADR,1(,FADR)      SKIP OVER LP, CLEAR UPPER BYTE\n         SR    FLEN,FADR          CALCULATE CHARACTERS REMAINING\n         B     FORMLOOP           AND OFF TO PROCESS FORMAT LOOP\n*\n*        COME HERE TO CHECK FOR /\n*\nFORMNTRP CLI   0(FADR),C'/'       IS IT SLASH?\n         BNE   FORMNSLH           SKIP IF NOT\n*\n*        COME HERE TO PROCESS / (NEW RECORD)\n*\nFORMSLSH BAL   LINK1,RECOUT       OUTPUT RECORD\n         BAL   LINK1,LOCATE       GET NEW POINTERS\n         B     FORMLP0            BACK FOR NEXT FORMAT ITEM\n*\n*        COME HERE TO TEST FOR LITERAL\n*\nFORMNSLH CLI   0(FADR),C''''      IS IT A QUOTE?\n         BNE   FORMNTQT           SKIP IF NOT\n         LA    R2,1(,FADR)        POINT TO FIRST CHAR TO BE MOVED\n*\n*        COME HERE TO PAST PAST FORMAT ON NEW MOVE CASE\n*\nFQUOTE0  AR    FLEN,FADR          POINT PAST FORMAT STRING\n*\n*        LOOP TO SKIP NON QUOTE CHARACTERS\n*\nFQUOTE   LA    FADR,1(,FADR)      SKIP OVER CHARACTER\n         CLI   0(FADR),C''''      IS NEXT CHARACTER A QUOTE?\n         BNE   FQUOTE             SKIP IT IF NOT\n         LR    R1,FADR            PREPARE LENGTH CALC\n         SR    FLEN,FADR          GET REMAINING LENGTH OF FORMAT\n         SR    R1,R2              GET LENGTH TO MOVE\n         BZ    *+8                SKIP MOVE IF NO CHARACTERS\n         BAL   LINK1,FORMMOVE     MOVE DATA CHARACTERS\n         CLI   1(FADR),C''''      ARE THER TWO QUOTES?\n         BNE   FORMLP0            SKIP PAST SINGLE QUOTE IF NOT\n         LA    FADR,1(,FADR)      PUSH PAST FIRST QUOTE\n         LR    R2,FADR            POINT TO QUOTE TO BE MOVED\n         BCT   FLEN,FQUOTE0       DECREASE SIZE FOR QUOTE AND LOOP\n         EJECT\n*\n*        COME HERE TO TEST FOR .\n*\nFORMNTQT CLI   0(FADR),C'.'       IS IT POSSIBLE END OF FORMAT?\n         BNE   FORMNDOT           SKIP IF NOT\n         LTR   SLEN,SLEN          ARE WE AT END OF STRING?\n         BP    FORMLP0            SKIP . IF NOT\n         B     FORMA2             ELSE MERGE WITH END OF STRING CODE\n*\n*        COME HERE TO CHECK FOR T TYPE FORMAT\n*\nFORMNDOT CLI   0(FADR),C'T'       IS IT T TYPE FORMAT?\n         BNE   E$FILL             ILLEGAL TYPE IF NOT\n         LA    FADR,1(,FADR)      SKIP PAST 'T'\n         BAL   LINK1,FORMNUM      GET THE FOLLOWING NUMBER\n         B     E$FTNM             GIVE ERR IF NOT NUMERIC\n         BCTR  R1,0               GET TAB LOC AS OFFSET\n         LH    BLEN,MAXRECL       GET MAX RECORD SIZE\n         SR    BLEN,R1            CHARS LEFT = MAX - TAB\n         A     R1,BUFSTART        TAB TO LOCATION IN BUFFER\n         LR    BADR,R1            COPY NEW BUFFER LOCATION\n         BCT   FLEN,FNODIG        -1 FOR T, CHECK NEXT CASE=\u00acNUMERIC\n         EJECT\n*\n*        FORMMOVE                 MOVE CHARACTERS TO BUFFER\n*\n*        (R1)                     NUMBER OF CHARACTERS TO MOVE\n*        (BADR)                   POINTER TO LOCATION IN BUFFER\n*        (R2)                     POINTER TO DATA TO BE MOVED\n*        BAL   LINK1,FORMMOVE\n*        (BADR)                   UPDATED PAST MOVED CHARS\n*        (BLEN)                   LENGTH REMAINING -- DECREMENTED\n*\n*        ANY CHARACTERS WHICH WOULD FALL BEYOND THE BUFFER ARE IGNORED\n*\nFORMMOVE LTR   BLEN,BLEN          ARE WE AT END OF RECORD?\n         BCR   13,LINK1           RETURN IF NO ROOM IN BUFFER\n         SR    BLEN,R1            DECREMENT FOR CHARS TO BE MOVED\n         BNM   *+6                SKIP IF ENOUGH ROOM\n         AR    R1,BLEN            ELSE SET MOVE SIZE TO BUFFER ROOM\n*\n*        COME HERE WITH REGISTERS SET UP FOR MOVE\n*\nFORMMOV1 BCTR  R1,0               GET 360 LENGTH\n         LA    R0,256             GET VITAL CONSTANT\n*\n*        LOOP TO MOVE 256 CHARACTERS AT A TIME\n*\nFORMLMOV CR    R1,R0              ARE WE SMALL ENOUGH FOR ONE MOVE?\n         BL    FORMSMOV           SKIP IF SO\n         MVC   0(256,BADR),0(R2)  MOVE LARGE PIECE\n         AR    R2,R0              PUSH FROM POINTER\n         AR    BADR,R0            PUSH TO ADDRESS\n         SR    R1,R0              BACK UP LENGTH\n         B     FORMLMOV           CHECK LENGTH AND MOVE REST\n*\n*        COME HERE TO MOVE <= 256 BYTES\n*\nFORMSMOV EX    R1,FORMMVC         MOVE IN LAST CHARACTERS\n         LA    BADR,1(BADR,R1)    UPDATE BUFFER ADDRESS\n         BR    LINK1              RETURN TO FORMMOVE CALLER\n*\nFORMMVC  MVC   0(*-*,BADR),0(R2)  MOVE IN VARIABLE LENGTH PIECE\n         EJECT\n*\n*        FORMNUM                  SCAN OUT NUMBER\n*\n*        (FADR)                   FORMAT POINTER\n*        (FLEN)                   NUMBER OF CHARS REMAINING IN FORMAT\n*        BAL   LINK1,FORMNUM\n*        -->                      RETURN HERE IF NON-NUMERIC\n*        -->                      NORMAL RETURN\n*        (R1)                     VALUE OF NUMBER IN BINARY\n*        (FADR)                   UPDATED PAST NUMBER\n*        (FLEN)                   UPDATED PAST NUMBER\n*\n*        --> E$FZER               ERROR RETURN FOR ZERO RESULT\n*\nFORMNUM  CLI   0(FADR),C'0'       IS FIRST CHARACTER A DIGIT?\n         BCR   L,LINK1            RETURN IF NOT\n         SR    R1,R1              CLEAR RESULT REGISTER\n*\n*        LOOP TO PICK UP DIGIT AND COMBINE WITH RESULT\n*\nFNUMLOOP IC    R0,0(,FADR)        GET NEXT DIGIT\n         N     R0,=X'0000000F'    REMOVE ZONE + OTHER GARBAGE\n         MH    R1,=H'10'          SHIFT LEFT CURRENT NUMBER ONE DIGIT\n         AR    R1,R0              AND ADD IN THIS DIGIT\n         LA    FADR,1(,FADR)      SKIP PAST DIGIT\n         BCTR  FLEN,0             DECREASE LENGTH REMAINING\n         CLI   0(FADR),C'0'       IS NEXT CHARACTER AT LEAST DIGIT?\n         BNL   FNUMLOOP           LOOP IF DIGIT\n*\n*        COME HERE TO CHECK FOR ZERO RESULT\n*\nFNUMXIT  LTR   R1,R1              IS RESULT ZERO?\n         BP    4(,LINK1)          RETURN TO CALLER IF NOT\n         B     E$FZER             ELSE GIVE ERROR MESSAGE\n*\n*\n*        RECOUT                   OUTPUT FORMATTED RECORD\n*\n*        (BADR)                   POINTER PAST LAST CHAR IN BUFFER\n*        BAL   LINK1,RECOUT\n*        -->   RETURN WITH RECORD OUTPUT\n*        (BLEN,BADR,R1,R2)        DESTROYED\n*\nRECOUT   L     R2,BUFSTART        POINT TO START OF RECORD\n         LR    R1,BADR            COPY CURRENT POINTER\n         SR    R1,R2              SUBTRACT TO GET RECORD LENGTH\n         TM    DCBRECFM,V         CHECK RECORD FORMAT\n         BO    WRITREC            JUMP TO OUTPUT ROUTINE IF U OR V REC\n         LH    R1,DCBLRECL        ELSE SET LENGTH OF FULL REC IF F TYPE\n         B     WRITREC            JUMP TO OUTPUT ROUTINE\n         TITLE 'OSINT -- OS INTERFACE -- SYNCHRONOUS ERROR ROUTINES'\n*\n*        HERE FOR I/O ERROR (SYNAD ROUTINE)\n*\nSYNAD    TM    OFLAGS,READER      IS THIS SYSIN?\n         BNO   *+8                SKIP IF NOT\n         OI    EOFLAG,PERMEOF     ELSE SET SPECIAL SYSIN EOF FLAG\n         TM    OFLAGS,OPENI       IS THIS INPUT CASE?\n         BO    E$IERR             GIVE INPUT ERROR IF SO\n         B     E$OERR             ELSE GIVE OUTPUT ERROR MESSAGE\n*\n*        ROUTINE ENTERED ON ENCOUNTERING END OF FILE (EODAD ROUTINE)\n*\nEOF      TM    OFLAGS,READER      IS THIS AN EOF ON SYSIN?\n         BNO   EOF1               SKIP IF NOT\n         OI    EOFLAG,PERMEOF     ELSE SET SPECIAL SYSIN EOF\n         SR    0,0                SET RETURN CODE = 0 IN CASE OF EOJ\n         TM    EOFLAG,DATAIN      HAS ANY DATA BEEN READ?\n         BNO   SYSEOJM            IF NOT, TREAT AS EOJ, ELSE MERGE\n*\n*        HERE AFTER SPECIAL PROCESSING FOR SYSIN\n*\nEOF1     OI    OFLAGS,EOFE        SET END OF FILE FLAG\n         LCR   0,11               SET (0) = NEGATIVE = END OF FILE\n         B     EXIT0              JUMP TO EXIT\n*\n*        HERE FOR ERROR ON SYSPRINT FILE\n*\nPRNERROR WTO   'ERROR ON SYSPRINT FILE'     TELL OPERATOR\n         ABEND 300,DUMP           GIVE ABEND\n         TITLE 'OSINT -- OS INTERFACE -- SYSTIME'\n*\n*        GET TIMER VALUE\n*\n*        NO PARAMETERS\n*\n*        EXIT CONDITIONS\n*\n*        (0)                      ELAPSED TIME IN MILLISECONDS\n*\n*        ERROR CODES RETURNED\n*\n*        NONE\n*\nSYSTIME  ENTER ,                  ENTRY POINT\n         TTIMER ,                 GET CURRENT TIMER\n         S     0,TSTART           SUBTRACT STARTING TIME\n         LCR   1,0                MOVE AND COMPLEMENT\n         M     0,=F'26040'        CONVERT TO NANOSECS\n         D     0,=F'1000000'      CONVERT TO MILLESECS\n         LR    0,1                PUT IN PROPER REGISTER\n         B     EXIT0              JUMP TO EXIT\n         TITLE 'OSINT -- OS INTERFACE -- SYSDUMP'\n*\n*        DUMP MEMORY\n*\n*        NO ENTRY PARAMETERS\n*\n*        NO RESULT RETURNED\n*\n*        ERROR CODES              NONE\n*\nSYSDUMP  ENTER ,                  ENTRY POINT\n         MVC   SYSREGS(64),SAVE1  SAVE ENTRY REGS & SET FOR DUMP\n         BAL   14,DUMP            CALL DUMP ROUTINE\n         MVC   SAVE1(64),SYSREGS  RESTORE ENTRY REGS TO ENTRY SAVE AREA\n         B     EXIT               GIVE NORMAL EXIT\n         TITLE 'OSINT -- OS INTERFACE -- SYSRWIND'\n*\n*        REWIND FILE\n*\n*        CALLING CONDITIONS\n*\n*        (0)                      POINTER TO DCB FOR FILE\n*\n*        EXIT CONDITIONS\n*\n*        NO RESULTS RETURNED\n*\n*        ERROR CODES RETURNED\n*\n*        E$RSYS                   ATTEMPT TO REWIND SYSTEM FILE\n*\nSYSRWIND ENTER ,                  ENTRY POINT\n         LR    10,0               COPY DCB POINTER\n         TM    OFLAGS,PRINTER+PUNCHER+READER SYSTEM FILE?\n         BNZ   E$RSYS             GIVE ERROR IF SO\n         TM    OFLAGS,OPENI+OPENO IS FILE ACTUALLY OPEN?\n         BZ    EXIT               IMMEDIATE EXIT IF NOT\n         MVC   MLIST(LCLSLIST),CLSLIST      MOVE CLOSE PARAMETER LIST\n         CLOSE ((10),REREAD),MF=(E,MLIST)   EXECUTE CLOSE\n         NI    OFLAGS,X'FF'-OPENI-OPENO-EOFE RESET OPEN, EOF FLAGS\n         B     EXIT               EXIT TO CALLER\n         TITLE 'OSINT -- OS INTERFACE -- SYSCLOSE'\n*\n*        CLOSE FILE\n*\n*        ENTRY CONDITIONS\n*\n*        (0)                      POINTER TO DCB FOR FILE\n*\n*        EXIT CONDITIONS\n*\n*        NO RESULTS RETURNED\n*\n*\n*        ERROR CODES RETURNED\n*\n*        NONE\nSYSCLOSE ENTER ,                  ENTRY POINT\n         LR    10,0               MOVE DCB POINTER TO STANDARD REGISTER\n         TM    OFLAGS,READER+PRINTER+PUNCHER SYSTEM FILE?\n         BNZ   EXIT               IGNORE CALL TO CLOSE SYSTEM FILE\n         BAL   2,CLOSER           ELSE CLOSE FILE\n         B     EXIT               RETURN TO CALLER\n*\n*        UTILITY ROUTINE TO CLOSE A FILE\n*\n*        (10)                     POINTS TO DCB\n*        BAL   2,CLOSER\n*\nCLOSER   TM    OFLAGS,OPENI+OPENO IS FILE OPEN?\n         BCR   Z,2                IMMEDIATE RETURN IF NOT\n         MVC   MLIST(LCLSLIST),CLSLIST      MOVE CLOSE PARAMETER LIST\n         CLOSE ((10),DISP),MF=(E,MLIST)     EXECUTE CLOSE\n         FREEPOOL  (10)           FREE BUFFER POOL\n         NI    OFLAGS,X'FF'-OPENI-OPENO-EOFE RESET OPEN, EOF FLAGS\n         BR    2                  RETURN TO CALLER\n         TITLE 'OSIN0 -- OS INTERFACE -- DCB EXIT ROUTINES'\n*\n*        DCB EXIT ROUTINE FOR SYSPRINT\n*\nEXPRT    BAL   2,FILLIN           CALL COMMON ROUTINE\n         DC    Y(V+B+A)           DEFAULT RECFM=VBA\n         DC    Y(1782)            DEFAULT BLKSIZE=1782\n         DC    Y(137)             DEFAULT LRECL=137\n*\n*        DCB EXIT ROUTINE FOR SYSPUNCH\n*\nEXPCH    BAL   2,FILLIN           CALL COMMON ROUTINE\n         DC    Y(V+B)             DEFAULT RECFM=VB\n         DC    Y(88)              DEFAULT BLKSIZE=88\n         DC    Y(84)              DEFAULT LRECL=80\n*\n*        DCB EXIT ROUTINE FOR SYSIN\n*\nEXRDR    BAL   2,FILLIN           CALL COMMON ROUTINE\n         DC    Y(F+B)             DEFAULT RECFM=FB\n         DC    Y(400)             DEFAULT BLKSIZE=400\n         DC    Y(80)              DEFAULT LRECL=80\n*\n*        DCB EXIT ROUTINE FOR SYSOBJ\n*\nEXOBJ    BAL   2,FILLIN           CALL COMMON ROUTINE\n         DC    Y(F+B)             DEFAULT RECFM=FB\n         DC    Y(400)             DEFAULT BLKSIZE=400\n         DC    Y(80)              DEFAULT LRECL=80\n*\n*        DCB EXIT ROUTINE FOR NON-SYSTEM FILES\n*\nEXALL    BAL   2,FILLIN           CALL COMMON ROUTINE\n         DC    Y(V+B+S)           DEFAULT RECFM=VBS\n         DC    Y(1782)            DEFAULT BLKSIZE=1782\n         DC    Y(2004)            DEFAULT LRECL=2004\n         EJECT\n*\n*        COMMON ROUTINE TO FILL IN MISSING FIELDS\n*\nFILLIN   LR    10,1               POINT TO DCB\n         CLI   DCBRECFM,0         WAS RECFM GIVEN?\n         BNZ   FILLIN1            SKIP IF SO (ASSUME OTHER PARAMS)\n         MVC   DCBRECFM(1),1(2)   ELSE SET PROPER DEFAULT RECFM\n         LH    3,DCBBLKSI         GET BLKSIZE?\n         LTR   3,3                WAS ONE GIVEN?\n         BNZ   *+10               SKIP IF SO\n         MVC   DCBBLKSI,2(2)      ELSE SET PROPER DEFAULT\n         LH    3,DCBLRECL         LOAD LRECL\n         LTR   3,3                WAS LRECL GIVEN?\n         BNZ   *+10               SKIP IF SO\n         MVC   DCBLRECL,4(2)      ELSE SET PROPER DEFAULT\n*\n*        NOW GET AND SET MAXRECL\n*\nFILLIN1  LH    3,DCBLRECL         GET LRECL\n         LTR   3,3                DO WE HAVE LRECL GIVEN?\n         BNZ   *+8                SKIP IF SO\n         LH    3,DCBBLKSI         ELSE GET BLKSIZE\n         TM    DCBRECFM,F         CHECK RECFM\n         BO    *+8                SKIP IF F OR U\n         SH    3,=H'4'            ELSE ADJUST FOR LENGTH OF V RECORD\n         STH   3,MAXRECL          STORE MAX RECORD LENGTH\n         OI    DCBOFLGS,X'08'     SET FOR POSSIBLE CONCATENATION\n         MVI   REREAD,1           SET REREAD FLAG\n         BR    14                 CONTINUE WITH OPEN PROCESSING\n         TITLE 'OSINT -- OS INTERFACE -- SYSABEND'\n*\n*        ABEND TERMINATION\n*\n*        ENTRY CONDITIONS\n*\n*        NONE\n*\n*        EXIT CONDITIONS\n*\n*        SYSABEND DOES NOT RETURN TO ITS CALLER\n*\n*        ERROR CODES\n*\n*        NONE\n*\nSYSABEND ENTER ,                  ENTRY POINT\n         L     1,DLIMIT           LOAD CURRENT VALUE OF D PARAMETER\n         LTR   1,1                TEST IT\n         BZ    SYSABOMB           JUMP IF HE WANTS SYSTEM BOMB\n*\n*        HERE WE GIVE AN OSINT DUMP\n*\n         BCTR  1,0                DECREMENT D PARAMETER\n         ST    1,DLIMIT           STORE DECREMENTED VALUE\n         BAL   14,DUMP            GIVE OSINT DUMP\n         LA    2,SYSEOJ           POINT TO END OF JOB ROUTINE\n         MVI   BOMBFLG,1          SET FLAG FOR BOMB OCCURED\n         BALR  1,2                JUMP TO END OF JOB ROUTINE\n*\n*        HERE IF HE WANTS A SYSTEM DUMP\n*\nSYSABOMB ABEND 100,DUMP           GIVE DUMP CODE=U100\n         TITLE 'OSINT -- OS INTERFACE -- SYSEOJ'\n*\n*        END OF JOB\n*\n*        ENTRY CONDITIONS\n*\n*        (0)                      COMPLETION CODE\n*\n*        EXIT CONDITIONS\n*\n*        SYSEOJ DOES NOT RETURN EXCEPT TO INITIATE A NEW JOB IN A\n*        BATCHED RUN (SEE NEWJOB)\n*\n*        ERROR CODES RETURNED\n*\n*        NONE (SYSEOJ DOES NOT RETURN)\n*\nSYSEOJ   ENTER ,                  ENTRY POINT\n*\n*        MERGE HERE AFTER NULL JOB (NO INPUT)\n*\nSYSEOJM  LR    6,0                SAVE COMPLETION CODE\n         L     0,PTRDCB           POINT TO FIRST DCB ON CHAIN\n         LA    2,SYSCLOSE         POINT TO CLOSE ROUTINE\n*\n*        LOOP TO CLOSE ANY FILES LEFT OPEN (EXCEPT SYSTEM FILES)\n*\nSYSEOJ1  BALR  1,2                CALL CLOSE ROUTINE\n         NOP   0                  NO ERROR POSSIBLE FROM CLOSE\n         LR    10,0               COPY DCB PTR TO STANDARD REG\n         L     0,DCBNEXT          POINT TO NEXT DCB ON CHAIN\n         LTR   0,0                END OF CHAIN?\n         BNZ   SYSEOJ1            LOOP BACK IF NOT\n*\n*        ALL FILES CLOSED, NOW CHECK FOR POSSIBILITY OF BATCHED JOB\n*\n         CLI   BATCHFLG,0         TEST FOR BATCHING ALLOWED\n         BE    SYSEOJX            IF NOT, SKIP TO REAL END OF JOB\n*\n*        HERE TO SEE IF WE HAVE ANOTHER JOB IN THE BATCH\n*\nSYSEOJ2  TM    EOFLAG,PERMEOF     PERMANENT (SYSTEM) EOF?\n         BO    SYSEOJX            NO NEW JOB IF NO NEW INPUT\n         TM    EOFLAG,TEMPEOF     DID WE READ A ./* ?\n         BO    NEWJOB             IF SO, JUMP TO INITIATE NEW JOB\n*\n*        HERE WE READ TO AN EOF (./* OR /*)\n*\n         L     4,OUTWBF           POINT TO WORK BUFFER\n         AH    4,=H'4'            ADJUST FOR POSSIBLE LENGTH FLD\n         LA    2,SYSREAD          POINT TO READ ROUTINE\n         L     0,READDCB          POINT TO READER DCB\n         BALR  1,2                READ A CARD\n         B     SYSEOJX            JUMP TO END OF RUN ON INPUT ERROR\n         B     SYSEOJ2            ELSE BACK TO TEST FOR EOF\n         EJECT\n*\n*        COME HERE TO TERMINATE, FIRST CLOSE SYSTEM FILES\n*\nSYSEOJX  L     10,PRINTDCB        POINT TO SYSPRINT DCB\n         BAL   2,CLOSER           CLOSE IT\n         L     10,PUNCHDCB        POINT TO SYSPUNCH DCB\n         BAL   2,CLOSER           CLOSE IT\n         L     10,READDCB         POINT TO SYSIN DCB\n         BAL   2,CLOSER           CLOSE IT\n*\n*        RELEASE MAIN DYNAMIC STORAGE AREA TO SYSTEM\n*\n         LM    1,2,ALLOC          ADDRESS / LENGTH ORIGINALLY OBTAINED\n         LR    0,2                PUT LENGTH IN PROPER REGISTER\n         FREEMAIN  R,LV=(0),A=(1) FREE MAIN DYNAMIC AREA\n         L     10,PTRDCB          LOAD POINTER TO FIRST DCB\n*\n*        LOOP TO FREE AREAS FOR DCBS\n*\nSYSEOJL  LR    1,10               MOVE DCB ADDRESS TO PROPER REG\n         LA    0,LMODDCB          SET PROPER DCB LENGTH\n         L     10,DCBNEXT         POINT TO NEXT DCB\n         FREEMAIN  R,LV=(0),A=(1) FREE AREA FOR DCB\n         LTR   10,10              END OF CHAIN?\n         BNZ   SYSEOJL            LOOP TILL ALL FREED\n*\n*        NOW WE ARE READY TO RETURN TO THE SYSTEM\n*\n         L     5,PICASAV          LOAD POINTER TO CALLER'S PICA\n         SPIE  MF=(E,(5))         RESTORE PICA FOR CALLER, FREE OURS\n         CLI   BOMBFLG,0          DID WE HAVE A BOMB?\n         BNZ   SYSEOJB            JUMP IF SO TO GIVE ABEND\n         LR    1,13               ELSE SAVE ADDRESS OF WORK AREA\n         L     13,ENT13SV         RELOAD PTR TO CALLERS SAVE AREA\n         FREEMAIN  R,LV=LWORK,A=(1)         FREE WORK AREA\n         LR    15,6               GET RETURN CODE (ITS STILL THERE)\n         RETURN    (14,12),RC=(15)          RETURN TO SYSTEM\n*\n*        HERE IF WE HAD A BOMB, GIVE A U100 ABEND\n*\nSYSEOJB  ABEND 100                GIVE ABEND (NO DUMP)\n         TITLE 'OSINT -- OS INTERFACE -- EXIT'\n*\n*        COME HERE TO EXIT TO INTERFACE CALLER\n*\n*        USE THIS ENTRY POINT IF (0) CONTAINS A RESULT TO BE RETURNED\n*\nEXIT0    ST    0,SAVE1            SAVE RESULT SO WE CAN MERGE\n*\n*        USE THIS ENTRY POINT IF ALL REGS ARE TO BE RESTORED\n*\nEXIT     LM    0,15,SAVE1         RESTORE ALL REGS\n         B     4(,1)              RETURN TO CALLER PAST ERROR RETURN\n*\n*        CUTOFF DATE -- GETS WRITTEN WHEN TAPES ARE GENERATED\n*\n         ORG   *                  PUT ON NEW TEXT CARD\nDATECUT  DC    C'99000'           YYDDD CUTOFF DATE\n*\n*        DATE CHECK DIGIT, ALSO SET ON A COPY\n*\nCKDIGIT  DC    X'C2'              SEE CHECK CIRCUIT FOR DETAILS\n         TITLE 'OSINT -- OS INTERFACE -- GETNAME'\n*\n*        AUXILIARY SUBROUTINE TO CONSTRUCT NAME\n*\n*        (4,5)                    STRING NAME (FROM SPITBOL)\n*        (7)                      ADDRESS OF ERROR ROUTINE IF NAME > 8\n*        BAL   2,GETNAME\n*        -->   NORMAL RETURN\n*        NAME                     CONTAINS NAME RIGHT BLANK PADDED\n*\n*        IF NAME IS LONGER THAN 8 CHARACTERS AN ERROR RETURN USING\n*        THE ERROR MESSAGE WHOSE ADDRESS IS GIVEN IN (7)\n*\nGETNAME  BCTR  5,0                GET 360 LENGTH OF NAME\n         CH    5,=H'7'            CHECK FOR TOO LONG\n         BCR   2,7                GIVE ERROR IF TOO LONG\n         CH    5,=H'1'            IS IT MORE THAN 2 CHARACTER NAME?\n         BH    GETNAME1           SKIP IF YES\n*\n*        HERE WE MAY HAVE AN INTEGER, IN WHICH CASE WE USE THE\n*        FORTRAN TYPE NAME FTXXF001 AS THE DDNAME FOR COMPATABILITY\n*\n         MVC   NAME,=C'FT00F001'  MOVE IN FORTRAN NAME MODEL\n         LA    1,NAME+3           SET UP POINTER IF ONE CHAR NAME\n         SR    1,5                BACK UP IF 2 CHARACTER NAME\n         EX    5,GETNAMBL         MOVE IN POSSIBLE DIGITS\n         CLI   NAME+3,X'F0'       IS SECOND CHARACTER NUMERIC?\n         BL    GETNAME1           SKIP IF NOT (NOT FORTRAN NAME)\n         CLI   NAME+2,X'F0'       ELSE IS FIRST DIGIT NUMERIC?\n         BCR   H,2                EXIT IF YES AND NON-ZERO\n         BE    GETNAMEC           SKIP FOR SPECIAL CHECK IF ZERO\n*\n*        COME HERE TO USE NAME EXACTLY AS GIVEN\n*\nGETNAME1 MVC   NAME+1(7),=C'       '        PREBLANK NAME AREA\n         EX    5,GETNAMEM         MOVE CHARS OF NAME\n         BR    2                  EXIT TO CALLER\n*\nGETNAMEM MVC   NAME(*-*),0(4)     MOVE NAME\n*\nGETNAMBL MVC   0(*-*,1),0(4)      TO CONSTRUCT FORTRAN TYPE NAME\n         EJECT\n*\n*        COME HERE FOR FORTRAN NAME WHERE DATASET REFERENCE NUMBER\n*        IS ONLY ONE DIGIT. IF A SYSTEM FILE IS REFERENCED (5,6,7)\n*        AND THERE IS NO DD CARD WITH THE PROPER DDNAME, THEN THE\n*        STANDARD DDNAME IS SUBSTITUTED, E.G. SYSIN FOR FT05F001\n*\nGETNAMEC CLI   NAME+3,C'5'        FT05F001?\n         LA    9,=CL8'SYSIN'      GET SYSIN NAME IN CASE\n         BE    GETNAMET           SKIP IF POSSIBLE SUBSTITUTION\n         CLI   NAME+3,C'6'        FT06F001?\n         LA    9,=CL8'SYSPRINT'   GET SYSPRINT NAME IN CASE\n         BE    GETNAMET           SKIP IF POSSIBLE SUBSTITUTION\n         CLI   NAME+3,C'7'        FT07F001?\n         LA    9,=CL8'SYSPUNCH'   GET SYSPUNCH NAME IN CASE\n         BCR   NE,2               IF NONE OF THESE, EXIT (USE FTXXF001)\n*\n*        HERE IF WE HAVE A POSSIBLE SUBSTITUTION\n*\nGETNAMET LR    0,2                SAVE GETNAME LINKAGE\n         BAL   2,DDCHEK           SEE IF DD CARD WAS ALREADY GIVEN\n         LR    2,0                RESTORE GETNAME LINKAGE\n         BCR   Z,2                IF DD CARD SUPPLIED, EXIT TO USE IT\n         MVC   NAME,0(9)          ELSE USE SUBSTITUTE NAME\n         BR    2                  AND THEN EXIT\n         TITLE 'OSINT -- OS INTERFACE -- DDCHEK'\n*\n*        SUBROUTINE TO CHECK FOR PRESENCE OF A GIVEN DDNAME\n*\n*        NAME                     DDNAME TO BE SEARCHED FOR\n*        BAL   2,DDCHEK\n*        -->   RETURN HERE WITH CC SET EQUAL IF FOUND, ELSE UNEQUAL\n*\n*        USES REGISTERS 1,7\n*\nDDCHEK   L     7,TIOTLOC          POINT TO TIOT\n         USING TIOT,7             TELL ASSEMBLER\n*\n*        LOOP TO SEARCH TIOT\n*\nDDCHEKL  CLC   NAME,TIOEDDNM      IS THIS THE ONE?\n         BCR   E,2                RETURN IF SO WITH CC EQUAL\n         SR    1,1                ELSE CLEAR 1 FOR IC\n         IC    1,TIOELNOH         LOAD TIOT ENTRY LENGTH\n         LTR   1,1                TEST FOR END OF TIOT (LENGTH = 0)\n         LA    7,0(1,7)           PUSH TO NEXT ENTRY IF IT EXISTS\n         BNZ   DDCHEKL            LOOP BACK IF MORE ENTRIES TO GO\n*\n*        HERE IF WE DID NOT FIND IT\n*\n         CR    11,12              COMPARE BASE REGS TO GET CC = UNEQUAL\n         BR    2                  RETURN TO CALLER\n         DROP  7                  DROP TIOT BASE REG\n         TITLE 'OSINT -- OS INTERFACE -- PATCH SPACE'\n         DC    20F'0'             INTERFACE PATCH SPACE\n*\n*        THE FOLLOWING LOCATIONS ARE PATCHED TO CONTAIN TF NUMBERS\n*        WHENEVER A TF IS APPLIED (HALFWORD CODES)\n*\nTFIXES   DC    35H'0'             ASSEMBLE AS ZEROS                V2.3\n*\nNFIXES   EQU   35                 NUMBER OF POSSIBLE FIXES\n         TITLE 'OSINT -- OS INTERFACE -- INTERVAL TIMER INTERRUPT'\n*\n*        THIS ROUTINE RECEIVES CONTROL ON A TIMER TRAP\n*\n         USING OVERTIME,11        BASE REG FOR OVERTIME ROUTINE\n         DROP  12                 DROP STANDARD BASE REG\nOVERTIME SAVE  (14,12)            SAVE REGISTERS\n         LR    11,15              SET BASE REGISTER\n         LR    0,13               SAVE REG 13\n         L     2,16               POINT TO CVT\n         L     2,CVTTCBP(,2)      POINT TO TCB POINTERS\n         L     2,4(,2)            POINT TO CURRENT TCB\n         L     13,TCBFSA(,2)      POINT TO HIGHEST SAVE AREA\n*\n*        LOOP TO LOCATE OUR SAVE AREA (LOW ORDER BIT OF FORWARD PTR ON)\n*\nOVERTIMA TM    8+3(13),1          IS THIS OUR SAVE AREA?\n         L     13,8(,13)          POINT TO NEXT SAVE AREA ANYWAY\n         BNO   OVERTIMA           LOOP BACK IF NOT THE ONE WE WANT\n*\n*        HERE WHEN WE HAVE FOUND OUR SAVE AREA\n*\nOVERTIMB BCTR  13,0               REMOVE GARBAGE LOW ORDER BIT\n         L     8,DATAPTR          LOAD POINTER TO DATA AREA\n         ST    0,SYSREGS          SAVE POINTER TO PREVIOUS SAVE AREA\n         STIMER    TASK,OVERTIME,TUINTVL=TINC  KEEP TIMER GOING\n         L     15,TINC            LOAD INCREMENTAL TIME VALUE\n         A     15,TSTART          ADD TO OLD STARTING VALUE\n         ST    15,TSTART          STORE MODIFIED STARTING VALUE\n         L     15,=V(SYSOVTM)     POINT TO OVERTIME ROUTINE\n         BALR  14,15              PASS CONTROL TO ROUTINE\n         L     13,SYSREGS         RELOAD POINTER TO PREVIOUS SAVE AREA\n         RETURN (14,12)           RETURN VIA CONTROL PROGRAM\n         DROP  11                 DROP TEMPORARY BASE REGISTER\n*\nTINC     DC    F'999999999'       INCREMENT TO KEEP TIMER GOING\n         TITLE 'OSINT -- OS INTERFACE -- PROGRAM CHECK ROUTINE'\n*\n*        THIS ROUTINE RECEIVES CONTROL ON ANY PROGRAM INTERRUPT\n*        REGISTER (1) POINTS TO THE PROGRAM INTERRUPTION ELEMENT\n*\n*        THE MAIN PROGRAM MUST PROVIDE AN ENTRY POINT 'SYSINTR'\n*        WHICH RECEIVES CONTROL AS FOLLOWS\n*\n*        (8)                      POINTS TO THE DATA AREA\n*                                 (EVEN IF NOT SET AT INTERRUPT TIME)\n*        (15)                     POINTS TO SYSINTR\n         BR    15\n*\n         USING PCEXIT,15          BASE REG SET BY CALLER\nPCEXIT   LR    0,13               SAVE REG 13\n         L     2,16               POINT TO CVT\n         L     2,CVTTCBP(,2)      POINT TO TCB POINTERS\n         L     2,4(,2)            POINT TO CURRENT TCB\n         L     13,TCBFSA(,2)      POINT TO HIGHEST SAVE AREA\n*\n*        LOOP TO LOCATE OUR SAVE AREA (LOW ORDER BIT OF PTR ON)\n*\nPCEXITL  TM    8+3(13),1          IS THIS OUR SAVE AREA?\n         L     13,8(,13)          POINT TO NEXT SAVE AREA ANYWAY\n         BNO   PCEXITL            LOOP BACK IF NOT THE ONE WE WANT\n*\n*        HERE WHEN WE FIND OUR SAVE AREA\n*\nPCEXIT2  BCTR  13,0               REMOVE GARBAGE LOW ORDER BIT\n         LR    2,8                SAVE OLD REG 8 VALUE\n         L     8,DATAPTR          LOAD POINTER TO ALLOCATED DATA AREA\n         MVC   SYSPSW,4(1)        SAVE INTERRUPT PSW\n         MVC   SYSREGS(3*4),20(1) SAVE REGS 0,1,2\n         MVC   SYSREGS+14*4(2*4),12(1)      SAVE REGS 14,15\n         STM   3,12,SYSREGS+3*4   SAVE REGS 3-12\n         ST    0,SYSREGS+13*4     SAVE REG 13\n         ST    2,SYSREGS+8*4      SAVE REG 8\n         STD   0,SYSREGS+16*4     SAVE FR0\n         STD   2,SYSREGS+16*4+8   SAVE FR2\n         STD   4,SYSREGS+16*4+16  SAVE FR4\n         STD   6,SYSREGS+16*4+24  SAVE FR6\n         EXTRN SYSINTR            INTERRUPT ROUTINE IS EXTERNAL\n         L     15,=A(SYSINTR)     POINT TO INTERRUPT HANDLING ROUTINE\n         ST    15,16(1)           SET TO BE RESTORED AS REG 15\n         ST    15,8(1)            SAVE AS NEW PSW EXIT ADDRESS\n         BR    14                 RETURN TO SYSINTR VIA SYSTEM\n         DROP  15                 DROP PCEXIT BASE REGISTER\n         TITLE 'OSINT -- OS INTERFACE -- DUMP'\n*\n*        TO ASSIST IN DEBUGGING, THE INTERFACE PROVIDES THE FOLLOWING\n*        DUMP ROUTINE WHICH DUMPS THE FOLLOWING AREAS --\n*\n*        1)    INTERFACE SAVE AREA\n*        2)    MAIN DATA AREA\n*        3)    ACTIVE DCB'S IN FREE CORE\n*\n*        EACH BLOCK IS DUMPED 48 BYTES/LINE WITH ABSOLUTE AND\n*        RELATIVE ADDRESSES. ALL ZERO LINES ARE OMITTED FROM THE DUMP\n*\n*        BAL   14,DUMP\n*\n         USING OSINT,11,12        STANDARD BASE REGS\nDUMP     ST    14,DMPRTN          SAVE LINKAGE\n         PRT   HEDM0              PRINT HEADING FOR DUMP\n         PRT   HEDM1              PRINT TITLE FOR INTERFACE WORK AREA\n         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE\n         LR    6,13               START OF SAVE AREA ADDRESS\n         LA    7,LWORK(,6)        END OF SAVE AREA\n         BAL   14,DUMPER          DUMP INTERFACE SAVE AREA\n         PRT   HEDM2              PRINT HEADING FOR DATA AREA\n         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE\n         LR    6,8                COPY POINTER TO START OF DATA AREA\n         LR    7,8                ANOTHER COPY\n         A     7,DATASIZE         POINT TO END OF DATA AREA\n         BAL   14,DUMPER          DUMP DATA AREA\n         L     10,PTRDCB          LOAD POINTER TO FIRST DCB\n         MVI   BUFR+1,C'1'        FIRST DCB IS ON NEW PAGE\n         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE\n*\n*        LOOP TO DUMP DCB'S\n*\nDUMP1    L     14,DMPRTN          RELOAD RETURN POINT IN CASE ALL DONE\n         LTR   10,10              DCB'S ALL DUMPED?\n         BCR   Z,14               RETURN TO DUMP CALLER IF SO\n         MVC   BUFR+2(15),=C'DUMP OF DCB FOR'    SET HEADING\n         MVC   BUFR+18(20),FILENAME         SET PROPER FILE NAME\n         MVI   BUFR,17+20         SET PROPER LENGTH\n         BAL   5,PRNTLNB          PRINT HEADING\n         LR    6,10               POINT TO DCB\n         LA    7,LMODDCB(,6)      POINT TO END OF DCB\n         BAL   14,DUMPER          DUMP DCB\n         L     10,DCBNEXT         POINT TO NEXT DCB ON CHAIN\n         MVI   BUFR+1,C'0'        SET FOR NEXT HEADING DOUBLE SPACED\n         B     DUMP1              LOOP BACK TO DUMP IT\n         EJECT\n*\n*        SUBROUTINE TO DUMP ONE REGION OF MEMORY\n*\n*        (6)                      STARTING ADDRESS\n*        (7)                      ENDING ADDRESS\n*        BAL   14,DUMPER\n*\nDUMPER   PRT   BLANKL             PRINT A BLANK LINE\n         ST    6,DUMPBAS          STORE STARTING ADDRESS\n         MVI   BUFR,132           REMAINING LINES ARE 132 CHARS LONG\n         LA    9,DUMPHEX          POINT TO HEX CONVERSION ROUTINE\n*\n*        HERE IS THE LOOP THROUGH LINES (48 BYTES/LINE)\n*\nDUMPER1  LA    0,48(,6)           POINT 48 BYTES AHEAD\n         CR    0,7                PAST END?\n         BH    DUMPERY            FORCE PRINT IF LAST LINE OF DUMP\n         CLI   0(6),X'00'         FIRST BYTE ZERO?\n         BNZ   DUMPERY            DEFINITELY DUMP IF SO\n         CLC   1(47,6),0(6)       ELSE IS REST OF LINE ZEROS?\n         BZ    DUMPERL2           SKIP IF SO, DO NOT PRINT IT\n*\n*        HERE IF WE HAVE AT LEAST A PARTIAL LINE TO BE PRINTED\n*\nDUMPERY  MVI   BUFR+1,C' '        BLANK BUFFER\n         MVC   BUFR+2(131),BUFR+1 . . . .\n         BCT   15,DUMPERL1        SKIP IF ROOM ON THIS PAGE\n         L     15,PAGEDPTH        SET NUMBER OF LINES LEFT ON PAGE\n         MVI   BUFR+1,C'1'        SET FOR NEW PAGE\n*\n*        HERE AFTER CLEARING BUFFER AND DEALING WITH LINE COUNT\n*\nDUMPERL1 LA    2,BUFR+2           POINT TO FIRST LOCATION\n         LR    0,6                COPY POINTER TO DATA\n         LR    1,6                AND AGAIN\n         S     1,DUMPBAS          ABSOLUTE ADDR->(0), RELATIVE->(1)\n         STM   0,1,DUMPWRK        STORE ABSOLUTE/RELATIVE ADDRESS\n         LA    3,DUMPWRK          POINT TO ADDRESSES\n         BALR  1,9                CONVERT ABSOLUTE ADDRESS\n         MVC   BUFR+2(8),BUFR+4   POSITION LAST 6 HEX DIGITS\n         BALR  1,9                CONVERT RELATIVE ADDRESS TO HEX\n         MVC   BUFR+10(9),BUFR+13 POSITION LAST 6 HEX DIGITS\n         EJECT\n*\n*        HERE WE CONVERT THE ACTUAL DATA (48 BYTES IN 3 GROUPS OF 16)\n*\n         LA    2,BUFR+20          POINT TO STARTING LOCATION FOR DATA\n         LR    3,6                POINT TO DATA TO BE DUMPED\n         BALR  1,9                DUMP FIRST GROUP OF 16 BYTES\n         BALR  1,9                . . . .\n         BALR  1,9                . . . .\n         BALR  1,9                . . . .\n         CR    3,7                MORE TO GO?\n         BNL   DUMPERLP           SKIP IF NOT\n         LA    2,3(,2)            ALLOW 2 EXTRA BLANKS\n         BALR  1,9                DUMP SECOND GROUP OF 16 BYTES\n         BALR  1,9                . . . .\n         BALR  1,9                . . . .\n         BALR  1,9                . . . .\n         CR    3,7                MORE TO GO?\n         BNL   DUMPERLP           SKIP IF NOT\n         LA    2,3(,2)            TWO EXTRA BLANKS\n         BALR  1,9                DUMP THIRD GROUP OF 16 BYTES\n         BALR  1,9                . . . .\n         BALR  1,9                . . . .\n         BALR  1,9                . . . .\n*\n*        HERE TO PRINT FORMATTED DUMP LINE\n*\nDUMPERLP BAL   5,PRNTLNB          PRINT BUFR CONTAINING LINE\n*\n*        HERE AFTER DUMPING LINE, MERGE FOR ALL ZERO LINE\n*\nDUMPERL2 LA    6,3*16(,6)         POINT PAST DATA DUMPED\n         CR    6,7                ALL DONE YET?\n         BL    DUMPER1            LOOP BACK FOR NEXT LINE IF NOT\n         BR    14                 ELSE RETURN TO DUMPER CALLER\n*\n*        SUBROUTINE TO CONVERT TO HEX\n*\n*        (2)                      BUFFER POINTER\n*        (3)                      POINTS TO 4 BYTES OF DATA\n*        BALR  1,9                (9) POINTS TO DUMPHEX\n*        (2)                      BUMPED PAST 8 HEX DIGS + BLANK\n*        (3)                      BUMPED PAST 4 BYTES DATA\n*\nDUMPHEX  UNPK  0(8+1,2),0(4+1,3)  SPREAD DIGITS\n         TR    0(8,2),DUMPTR-C'0' TRANSLATE TO HEX\n         MVI   8(2),C' '          BLANK LAST GARBAGE DIGIT\n         LA    2,8+1(,2)          BUMP PAST 8 DIGITS + 1 BLANK\n         LA    3,4(,3)            BUMP PAST FOUR BYTES DATA\n         BR    1                  RETURN TO CALLER\n*\nDUMPTR   DC    C'0123456789ABCDEF'          TABLE TO TRANSLATE TO HEX\n         TITLE 'OSINT -- OS INTERFACE -- MODEL DCB'\n*\n*        MODEL DCB USED TO CONSTRUCT DCBS IN FREE CORE\n*\nMODDCB   DCB   DDNAME=XXXXXXXX,DSORG=PS,MACRF=(GM,PM),                 X\n               EODAD=EOF,SYNAD=SYNAD,EXLST=EXLALL\n         DC    CL8' '                       DDNAME\n         DC    X'0000000000000000'          MEMNAME\n         DC    CL20' '                      FILENAME\n         DS    Y                  MAXRECL\n         DC    X'00'              ALL FLAGS ARE RESET\n         DC    A(0)               DUMMY CHAIN POINTER\n         DC    X'7FFFFFFF'        MAX WRITE RECORD COUNT (INFINITE)\nLMODDCB  EQU   *-MODDCB           LENGTH OF MODEL DCB\n*\n*\n*        DCB EXIT LISTS\n*\n         DS    0F                 ALLIGN\nEXLPRT   DC    X'85',AL3(EXPRT)   EXIT LIST FOR SYSPRINT\nEXLPCH   DC    X'85',AL3(EXPCH)   EXIT LIST FOR SYSPUNCH\nEXLRDR   DC    X'85',AL3(EXRDR)   EXIT LIST FOR SYSIN\nEXLOBJ   DC    X'85',AL3(EXOBJ)   EXIT LIST FOR SYSOBJ\nEXLALL   DC    X'85',AL3(EXALL)   EXIT LIST FOR ALL OTHER FILES\n         TITLE 'OSINT -- OS INTERFACE -- ERROR CODES'\n*\n*        THESE ERROR CODES GENERATE A BCTR 12,0. THE ROUTINE AT THE\n*        END COMPUTES THE PROPER ERROR CODE FROM THE VALUE IN (12)\n*\nE$FILG   XERR  12                 INVALID FILE NAME\n*\nE$MSDD   XERR  12                 MISSING DD CARD FOR REFERENCED FILE\n*\nE$MODN   XERR  12                 MODULE NAME FOR LOAD OR UNLOAD\n*                                 LONGER THAN 8 CHARACTERS\n*\nE$IERR   XERR  12                 UNCORRECTABLE INPUT ERROR\n*\nE$OERR   XERR  12                 UNCORRECTABLE OUTPUT ERROR\n*\nE$EOFR   XERR  12                 ATTEMPT TO READ PAST END OF DATA\n*\nE$LIOE   XERR  12                 UNCORRECTABLE INPUT ERROR DURING\n*                                 LOADING OF AN EXTERNAL FUNCTION\n*\nE$LNFN   XERR  12                 MODULE FOR EXTERNAL FUNCTION NOT\n*                                 FOUND IN LIBRARY (POSSIBLE MISSING\n*                                 JOBLIB DD CARD)\n*\nE$DELE   XERR  12                 MODULE TO BE UNLOADED IS NOT\n*                                 CURRENTLY LOADED\n*\nE$RSYS   XERR  12                 ATTEMPT TO REWIND SYSTEM FILE\n*                                 (DDNAME = SYSPRINT,SYSPUNCH,SYSIN)\n*\nE$READ   XERR  12                 ATTEMPT TO READ FILE PREVIOUSLY\n*                                 WRITTEN WITHOUT INTERVENING REWIND\n*\nE$WRIT   XERR  12                 ATTEMPT TO WRITE A FILE PREVIOUSLY\n*                                 READ FROM WITHOUT INTERVENING REWIND\n         EJECT\n*\nE$FZER   XERR  12                 DUPLICATION FACTOR OR TAB LOCATION\n*                                 IN FORMAT EQUALS ZERO\n*\nE$FILL   XERR  12                 ILLEGAL CHARACTER IN OUTPUT FORMAT\n*\nE$FSOV   XERR  12                 TOO MANY LEVELS OF PARENTHESIS IN\n*                                 FORMAT -- LIMIT IS 10\n*\nE$FUBP   XERR  12                 TOO MANY RIGHT PARENTHESIS IN FORMAT\n*\nE$FTNM   XERR  12                 MISSING NUMBER AFTER T FORMAT\n*\nE$FHLN   XERR  12                 LENGTH SPECIFIED IN H TYPE FORMAT\n*                                 EXCEEDS LENGTH OF FORMAT\n*\n*\nE$FNLP   XERR  12                 FORTRAN TYPE OUTPUT FORMAT IS\n*                                 MISSING AN INITIAL LEFT PARENTHESIS\n*\nE$FNRP   XERR  12                 A FORTRAN TYPE OUTPUT FORMAT IS\n*                                 MISSING A FINAL RIGHT PARENTHESIS\n*\nE$SSIN   XERR  12                 A SYSIN RECORD EXCEEDS 80\n*                                 CHARACTERS IN LENGTH\n*\nE$OPNO   XERR  12                 ERROR IN OPENING FILE FOR OUTPUT\n*\nE$OPNI   XERR  12                 ERROR IN OPENING FILE FOR INPUT\n*\n*        COME HERE TO CALCULATE ERROR CODE\n*        WE ENTER HERE FROM TABLE OF BCTR 12,0'S AND SUBTRACTED AMOUNT\n*        TELLS US WHICH ERROR MESSAGE WE ARE GIVING\n*        ERROR CODE = (12)-(11)-4095+&ERRC\n*\n         LA    1,4095(,11)        (11)+4095\n         LA    0,&ERRC.(,12)      (12)+&ERRC\n         SR    0,1                CALCULATE ERROR CODE\n         LM    1,15,SAVE1+4       SAVE REGS PRESERVING ERROR CODE\n         BR    1                  GIVE ERROR RETURN\n         TITLE 'OSINT -- OS INTERFACE -- MACRO CALL PARAMETER LISTS'\n*\n*        LISTS FOR SYSTEM MACRO CALLS (MOVED TO MLIST FOR USE)\n*\nGETLIST  GETMAIN   VC,HIARCHY=1,MF=L         GETMAIN LIST\nLGETLIST EQU     *-GETLIST         LENGTH OF LIST\n*\nOPNLIST  OPEN    (,),MF=L          OPEN LIST\nLOPNLIST EQU     *-OPNLIST         LENGTH OF LIST\n*\nCLSLIST  CLOSE   (,),MF=L          CLOSE LIST\nLCLSLIST EQU     *-CLSLIST         LENGTH OF LIST\n*\nEXTLIST  EXTRACT   ,'S',FIELDS=(TIOT),MF=L  EXTRACT LIST\nLEXTLIST EQU   *-EXTLIST          LENGTH OF LIST\n         TITLE 'OSINT -- OS INTERFACE -- INITIAL LIMIT VALUES'\n*\n*        THIS TABLE OF VALUES IS MOVED TO 'LIMS' IN THE INTERFACE\n*        WORK AREA AFTER OBTAINING THE REQUIRED MEMORY\n*\nLIMSINIT DS    0F                 START OF LIMITS\n         DC    F'55'              TIME LIMIT (DEFAULT = 55 SECONDS)\n         DC    F'100000'          CARD LIMIT = 100000\n         DC    F'100000'          PAGE LIMIT = 100000\n         DC    A(8*1024)          SPACE TO RESERVE FOR SYSTEM = 8K\n         DC    F'0'               ADDRESS OF SYSTEM AREA\n         DC    F'8'               MINIMUM MEMORY REQUESTED = 8 BYTES\n         DC    A(1000*1024)       MAX MEMORY REQUIRED AND REQUESTED\n         DC    A(16*1024)         MINIMUM MEMORY REQUIRED\n         DC    2A(0)              ADDRESS LENGTH ACTUALLY ALLOCATED\n         DC    A(10)              DEFAULT NUMBER OF OSINT DUMPS\n         DC    A(58)              DEFAULT IS 58 LINES PER PAGE\n         DC    A(0)               DEFAULT IS PRECISE INTERRUPTS\n         TITLE 'OSINT -- OS INTERFACE -- LITERAL POOL'\n*\n*        NOTE THAT IF THE INTERFACE GETS BIGGER, WE MUST WATCH THE\n*        POSITIONING OF THE LITERAL TABLES SINCE THE LITERAL USED TO\n*        LOAD BASE REGISTERS MUST BE WITHIN 4K OF THE FIRST ENTRY POINT\n*\n         LTORG ,                  PLACE LITERALS HERE\n         TITLE 'OSINT -- OS INTERFACE -- WORK DSECT'\n*\n*        THE WORK DSECT CONTAINS THE GENERAL WORK AREAS FOR THE\n*        INTERFACE. A POINTER TO THIS AREA IS STORED IN THE DATA AREA\n*        AT WORKLOC. THIS ADDRESS IS LOADED INTO REGISTER (13)\n*        ON ENTRY TO ANY OF THE SYSTEM INTERFACE ENTRY POINTS.\n*\nWORK     DSECT ,                  START OF DSECT, (13) POINTS HERE\n*\n*        SINCE (13) ALWAYS POINTS TO THIS AREA, THE FIRST 18 WORDS ARE\n*        RESERVED FOR USE AS A SAVE AREA BY THE NEXT LEVEL OF ROUTINES\n*\nSAVE2    DS    9D                 SAVE AREA FOR NEXT LEVEL\n*\n*        WORK AREAS FOR DUMP ROUTINE\n*\nDUMPWRK  DS    2F                 SAVE ADDRESSES IN DUMPER\nDMPRTN   DS    F                  RETURN LINKAGE TO DUMP ROUTINE\nDUMPBAS  DS    A                  BASE ADDRESS IN DUMPER\n*\n*        THE FOLLOWING IS USED TO BUILD DUMP LINES & OTHER MESSAGES\n*\nBUFR     DS    CL134              132 + CTL CHAR + LENGTH\n*\n*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE DATA AREA\n*\nDATAPTR  DS    F                  POINTER TO ALLOCATED DATA AREA\n*\n*        THE FOLLOWING LOCATION CONTAINS A POINTER TO THE MAIN PROGRAM\n*\nSTARTLOC DS    A                  POINTER TO SYSSTART\n*\n*        REGISTER SAVE AREAS\n*\nENT13SV  DS    A                  SAVE REG 13 ON ENTRY TO INTERFACE\nSAVEX    DS    8F                 SAVE AREA FOR INTERRUPT ROUTINE\nPRNSAVE  DS    3F                 SAVE REGS IN PRNTLN\nBOMBSV   DS    2F                 SAVE REGS 0,1 ON A BOMB\nBOMBPSW  DS    F                  SAVE CODE/ADDR FROM PSW ON A BOMB\nWRITRECS DS    A                  SAVE WRITREC LINKAGE\nFORMSAVE DS    2F                 SAVE REGS FOR FORMMOVE\n*\n*        AREA TO SAVE POINTER TO PICA FOR CALLER\n*\nPICASAV  DS    A                  POINTER TO CALLER'S PICA\n*\n*        LOCATION USED TO STORE STARTING (INITIAL) TIMER VALUE\n*\nTSTART   DS    F                  INITIAL TIMER VALUE\n         EJECT\n*\n*        LIST FOR BLDL\n*\n         ORG   SAVEX              OVERLAP UNUSED REG SAVE AREAS\nBLDLIST  DS    H'1'               SET TO 1 FOR ONE ENTRY\n         DS    H'58'              SET TO 58 = LENGTH OF ENTRY\nNAME     DS    CL8                NAME FOR LOAD,UNLOAD,OPEN, ETC.\n         DS    CL50               WORK AREA FOR BLDL\n         ORG   ,                  REPOSITION\n*\n*        AREA TO BUILD PARAMETER LISTS FOR SYSTEM MACRO CALLS\n*\nMLIST    DS      0D                START OF AREA\n         GETMAIN   VC,HIARCHY=1,MF=L\n         ORG     MLIST\n         OPEN    (,),MF=L\n         ORG     MLIST\n         CLOSE   (,),MF=L\n         ORG   MLIST\n         EXTRACT   ,'S',FIELDS=(TIOT),MF=L\n         ORG     ,                 REPOSITION PAST LONGEST LIST\n*\n*        USER PROGRAM LIMITS (INITIALIZED FROM LIMSINIT)\n*\nLIMS     DS    0F                 START OF INITIALIZED LIMIT VALUES\nTLIMIT   DS    F                  TIME LIMIT (TIMER UNITS)\nCLIMIT   DS    F                  CARD LIMIT\nPLIMIT   DS    F                  PAGE LIMIT\nRESERV   DS    F                  SPACE TO RESERVE TO SYSTEM (BYTES)\nRESERV0  DS    A                  ADDRESS OF AREA TO RESERVE TO SYSTEM\nDYNALLOC DS    A                  MINIMUM MEMORY REQUESTED (BYTES)\nDYNAMAX  DS    A                  MAX MEMORY REQUIRED & REQUESTED\nDYNAMIN  DS    F                  MINIMUM MEMORY REQUIRED\nALLOC    DS    2A                 ADDRESS/LENGTH ACTUALLY ALLOCATED\nDLIMIT   DS    F                  NUMBER OF OSINT DUMPS ON SYSABEND\nPAGEDPTH DS    F                  NUMBER OF LINES PER PAGE\nINTVAL   DS    F                  INTERRUPT TYPE INDICATOR\nLLIMS    EQU   *-LIMS             LENGTH OF LIMIT VALUES\n         EJECT\n*\n*        MISCELLANEOUS WORK AREAS\n*\nTIOTLOC  DS    F                  LOCATION OF TIOT FOR THIS TASK\nPTRDCB   DS    A                  ADDRESS OF FIRST DCB ON DCB CHAIN\nSYSTEM   DS    A                  SAVE EXIT ADDRESS IN INTRUP ROUTINE\nOUTWBF   DS    A                  POINTER TO OUTPUT WORK BUFFER\nOUTWBFLN DS    H                  LENGTH OF OUTPUT WORK BUFFER\nREREAD   DS    X                  REREAD FLAG FOR DATASET CONCATENATION\nSAVEBF   DS    CL4                SAVE CHRS BEHIND READ BFR (SYSREAD)\nEOFLAG   DS    X                  END OF FILE FLAG\nTEMPEOF  EQU   X'80'              FLAG FOR TEMPORARY (./*) EOF\nPERMEOF  EQU   X'40'              FLAG FOR PERMANENT EOF (/*)\nDATAIN   EQU   X'20'              FLAG FOR SOME DATA READ\nPTYPE    DS    C                  OPTION LETTER (PARAMETER SCAN)\nRECFLAG  DS    X                  FLAG FOR UNKNOWN RECLEN (SYSWRITE)\nSAVCHR   DS    C                  SAVE CHAR BEHIND RECORD IN SYSWRITE\nBOMBFLG  DS    X                  SET NONZERO IF ANY SYSABEND CALLS\nDATE     DS    CL10               SPACE TO BUILD DATE (SYSDATE)\nCKDIGITC DS    C                  COMPUTED DATE CHECK DIGIT\nBATCHFLG DS    AL1(*-*)           BATCHING FLAG COPIED FROM SYSBATCH\n*\n*        WORK AREAS FOR FORMAT PROCESSOR\n*\nFORMFLGS DS    C                  FLAG BYTE FOR FORMAT PROCESSOR\nXFORM    EQU   X'80'              FLAG FOR MOVE OF BLANKS\nFBLKCC   EQU   X'40'              FLAG FOR BLANK CTL CHAR REQUIRED\nFSPECL   EQU   X'20'              FLAG FOR NO FORMAT GIVEN\nBUFSTART DS    A                  ADDRESS OF CURRENT BUFFER\nFLASTLP  DS    A                  ADDR AND REPEAT COUNT FOR LAST LP\nFSTAKADR DS    F                  ADDRESS OF CURRENT STACK ENTRY\nFORMSTAK DS    10F                ROOM FOR 10 PAREN LEVELS\nFSTAKEND DS    A(*)               END OF STACK ADDRESS\nFSTAKBOT DS    A(FORMSTAK-4)      BOTOOM OF LP STACK\nFORMRTN  DS    F                  SAVE RETURN POINT TO FORMAT PROCESSOR\nLWORK    EQU   *-WORK             LENGTH OF WORK AREA\n         TITLE 'OSINT -- OS INTERFACE -- DATA DSECT'\n*\n*        THE DATA AREA IS ALWAYS POINTED TO BY REGISTER (8). THIS\n*        REGISTER MUST BE SET CORRECTLY ON ALL CALLS TO THE INTERFACE.\n*        THIS AREA IS PRIMARILY FOR THE USE OF THE MAIN PROGRAM.\n*        HOWEVER, THE FIRST FEW LOCATIONS ARE RESERVED TO THE INTERFACE\n*        AS INDICATED BELOW.\n*\nDATA     DSECT ,                  START OF DATA DSECT\n*\n         DS    F                  FOUR BYTES UNUSED BY INTERFACE\nWORKLOC  DS    A                  POINTER TO INTERFACE WORK AREA\nSAVE1    DS    18F                SAVE AREA FOR REGS ON ENTRY\n*\n*        THE FOLLOWING AREAS ARE USED IF A PROGRAM CHECK OCCURS\n*\nSYSPSW   DS    D                  SAVE INTERRUPT PSW\nSYSREGS  DS    12D                REG VALS ON INTERRUPT (0-15,FR0-FR6)\n*\n*        THE FOLLOWING CONSTANTS ARE SET BY THE INTERFACE\n*\nDATASIZE DS    F                  LENGTH OF DATA AREA ALLOCATED\nPRINTDCB DS    A                  POINTER TO DCB FOR SYSPRINT\nPUNCHDCB DS    A                  POINTER TO DCB FOR PUNCH\nREADDCB  DS    A                  POINTER TO SYSIN DCB\nPGDEPTH  DS    F                  NUMBER OF LINES PER PAGE\nSTARTADR DS    A                  ADDRESS OF SYSSTART\nINTFLAG  DS    F                  INTERRUPT TYPE INDICATOR\n*\n*        THE REMAINING SECTION OF THE DATA AREA MAY BE USED BY THE MAIN\n*        PROGRAM IN ANY WAY IT DESIRES.\n*\nUSERD    DS    0D                 START OF USER AREA\n         TITLE 'OSINT -- OS INTERFACE -- TIOT DSECT'\n*\n*        THIS DSECT DESCRIBES THE FIELDS IN A TIOT ENTRY WHICH ARE\n*        REFERENCED BY THE INTERFACE.\n*\nTIOT     DSECT ,                  START OF DSECT\n*\n         DS    CL24               FILLER (JOB/STEP NAMES, UNUSED)\nTIOENTRY DS    0F                 START OF ENTRY (0 = END OF CHAIN)\nTIOELNOH DS    AL1                LENGTH OF ENTRY\n         DS    CL3                FILLER (UNUSED)\nTIOEDDNM DS    CL8                DDNAME\n*\n*\n*        ADDITIONAL CONTROL PROGRAM FIELDS REFERENCED\n*\nCVTTCBP  EQU   0                  OFFSET TO TCB BLOCK PTR IN CVT\nTCBFSA   EQU   112                OFFSET TO PTR TO 1ST SAVE AREA IN TCB\n         TITLE 'OSINT -- OS INTERFACE -- DCB DSECT'\n*\n*        THE FOLLOWING DSECT DESCRIBES THE DCB FORMAT USED BY THIS\n*        INTERFACE, WHICH CONSISTS OF A STANDARD SYSTEM DCB FOLLOWED\n*        BY A SET OF SPECIAL FIELDS\n*\n         DCBD  DSORG=QS,DEVD=DA   PROVIDE SYMBOLIC NAMES FOR DCB\nDDNAME   DS    CL8                DDNAME\nMEMNAME  DS    CL8                MEMBER NAME (ZERO IF NONE)\nFILENAME DS    CL20               FULL FILE NAME AS SUPPLIED\nMAXRECL  DS    Y                  MAXIMUM INPUT RECORD LENGTH\nOFLAGS   DS    X                  FLAGS AS FOLLOWS\nOPENI    EQU   1                  DCB IS OPEN FOR INPUT\nOPENO    EQU   2                  DCB IS OPEN FOR OUTPUT\nEOFE     EQU   4                  END OF FILE HAS BEEN READ\nPRINTER  EQU   8                  FLAG FOR SYSPRINT\nPUNCHER  EQU   16                 FLAG FOR SYSPUNCH\nREADER   EQU   32                 FLAG FOR SYSIN\nDCBNEXT  DS    A                  POINTER TO NEXT DCB ON CHAIN\nMAXRECW  DS    F                  MAXIMUM RECORDS TO BE WRITTEN\n*\nOPENOK   EQU   X'10'              FLAG FOR SUCCESSFUL OPEN IN DCBOFLGS\n*\nF        EQU   X'80'              FLAG FOR F TYPE RECORDS (ALSO U)\nV        EQU   X'40'              FLAG FOR V TYPE RECORDS (ALSO U)\nU        EQU   F+V                FLAG FOR U TYPE RECORDS\nB        EQU   X'10'              FLAG FOR B (BLOCKED) RECORDS\nS        EQU   X'08'              FLAG FOR S TYPE RECORDS\nA        EQU   X'04'              FLAG FOR A (ASA CTL) TYPE RECORDS\n*\n         END   OSINT              END OF INTERFACE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SBOLOBJ": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x03\\xc0\\x03\\xc0\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 960, "newlines": 960, "modlines": 0, "user": "SPIT360"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SLIBOBJ": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x03`\\x03`\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 864, "newlines": 864, "modlines": 0, "user": "SPIT360"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SPITBOL": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\\x15\\x01_\\xb9_\\xb9\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T15:01:00", "lines": 24505, "newlines": 24505, "modlines": 0, "user": "SPIT360"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TESTPGMS": {"ttr": 12803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x05k\\x05k\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 1387, "newlines": 1387, "modlines": 0, "user": "SPIT360"}, "text": "-TITLE SPITBOL TEST PROGRAM #1 -- DIAGNOSTICS PHASE ONE\n*\n*        THIS IS A STANDARD TEST PROGRAM FOR SPITBOL WHICH TESTS\n*        OUT FUNCTIONS, OPERATORS AND DATATYPE MANIPULATIONS\n*\n         &DUMP = 2\n         TRACE(.TEST)\n         &TRACE = 1000000\n         STARS =                     '  ERROR DETECTED          ***'\n         &ERRLIMIT = 1000\n         SETEXIT(.ERRORS)         ;*        SET INTERRUPT LOCATION\n         OUTPUT = '************************************************'\n         OUTPUT = '**** S P I T B O L    D I A G N O S T I C S ****'\n         OUTPUT = '****          P H A S E    O N E            ****'\n         OUTPUT = '************************************************'\n         OUTPUT = '****  ANY TRACE OUTPUT INDICATES AN ERROR   ****'\n         OUTPUT = '************************************************'\n-EJECT\n*\n*        TEST REPLACE FUNCTION\n*\n         TEST = DIFFER(REPLACE('AXXBYYY','XY','01'),'A00B111') STARS\n         A = REPLACE(&ALPHABET,'XY','AB')\n         TEST = DIFFER(REPLACE('AXY',&ALPHABET,A),'AAB') STARS\n*\n*        TEST LPAD,RPAD FUNCTIONS\n*\n         TEST = DIFFER(LPAD('ABC',5,'X'),'XXABC') STARS\n         TEST = DIFFER(RPAD('ABC',5,'X'),'ABCXX') STARS\n         TEST = DIFFER(LPAD(12,5),'   12') STARS\n         TEST = DIFFER(RPAD(10,4),'10  ') STARS\n         TEST = DIFFER(LPAD('ABC',2),'ABC') STARS\n         TEST = DIFFER(RPAD('AB',1),'AB') STARS\n         TEST = DIFFER(LPAD('AB',2),'AB') STARS\n         TEST = DIFFER(LPAD()) STARS\n         TEST = DIFFER(LPAD(,5),'     ') STARS\n*\n*        TEST CONVERT FUNCTION\n*\n         TEST = DIFFER(CONVERT('12','INTEGER') , 12) STARS\n         TEST = DIFFER(CONVERT(2.5,'INTEGER'),2)       STARS\n         TEST = DIFFER(CONVERT(2,'REAL'),2.0) STARS\n         TEST = DIFFER(CONVERT('.2','REAL'),0.2) STARS\n-EJECT\n*\n*        TEST REVERSE FUNCTION\n*\n         TEST = DIFFER(REVERSE('123'),'321') STARS\n         TEST = DIFFER(REVERSE()) STARS\n         TEST = DIFFER(REVERSE(12),'21') STARS\n*\n*        TEST DATATYPE FUNCTION\n*\n         TEST = DIFFER(DATATYPE('JKL'),'STRING') STARS\n         TEST = DIFFER(DATATYPE(12),'INTEGER') STARS\n         TEST = DIFFER(DATATYPE(1.33),'REAL') STARS\n         TEST = DIFFER(DATATYPE(NULL),'STRING') STARS\n-EJECT\n*\n*        TEST ARITHMETIC OPERATORS\n*\n         TEST = DIFFER(3 + 2,5) STARS\n         TEST = DIFFER(3 - 2,1) STARS\n         TEST = DIFFER(3 * 2,6) STARS\n         TEST = DIFFER(5 / 2,2) STARS\n         TEST = DIFFER(2 ** 3,8) STARS\n         TEST = DIFFER(3 + 1,4) STARS\n         TEST = DIFFER(3 - 1,2) STARS\n         TEST = DIFFER('3' + 2,5) STARS\n         TEST = DIFFER(3 + '-2',1) STARS\n         TEST = DIFFER('1' + '0',1) STARS\n         TEST = DIFFER(5 + NULL,5) STARS\n         TEST = DIFFER(-5,0 - 5) STARS\n         TEST = DIFFER(+'4',4) STARS\n         TEST = DIFFER(2.0 + 3.0,5.0) STARS\n         TEST = DIFFER(3.0 - 1.0,2.0) STARS\n         TEST = DIFFER(3.0 * 2.0,6.0) STARS\n         TEST = DIFFER(3.0 / 2.0,1.5) STARS\n         TEST = DIFFER(3.0 ** 3,27.0) STARS\n         TEST = DIFFER(-1.0,0.0 - 1.0) STARS\n*\n*        TEST MIXED MODE\n*\n         TEST = DIFFER(1 + 2.0,3.0) STARS\n         TEST = DIFFER(3.0 / 2,1.5) STARS\n-EJECT\n*\n*        TEST FUNCTIONS\n*\n*        FIRST, A SIMPLE TEST OF A FACTORIAL FUNCTION\n*\n         DEFINE('FACT(N)')                  :(FACTEND)\nFACT     FACT = EQ(N,1) 1         :S(RETURN)\n         FACT = N * FACT(N - 1)             :(RETURN)\nFACTEND  TEST = NE(FACT(5),120) STARS\n         TEST = DIFFER(OPSYN(.FACTO,'FACT')) STARS\n         TEST = DIFFER(FACTO(4),24) STARS\n*\n*        SEE IF ALTERNATE ENTRY POINT WORKS OK\n*\n         DEFINE('FACT2(N)',.FACT2ENT)       :(FACT2ENDF)\nFACT2ENT FACT2 = EQ(N,1) 1        :S(RETURN)\n         FACT2 = N * FACT2(N - 1) :(RETURN)\nFACT2ENDF OUTPUT = NE(FACT(6),720) STARS\n*\n*        TEST FUNCTION REDEFINITION AND CASE OF ARGUMENT = FUNC NAME\n*\n         TEST = DIFFER(DEFINE('FACT(FACT)','FACT3')) STARS\n.                                           :(FACT2END)\nFACT3    FACT = NE(FACT,1) FACT * FACT(FACT - 1)\n.                                           :(RETURN)\nFACT2END\n         TEST = NE(FACT(4),24) STARS\n*\n*        TEST OUT LOCALS\n*\n         DEFINE('LFUNC(A,B,C)D,E,F')        :(LFUNCEND)\nLFUNC    TEST = \u00ac(IDENT(A,'A') IDENT(B,'B') IDENT(C,'C')) STARS\n         TEST = \u00ac(IDENT(D) IDENT(E) IDENT(F)) STARS\n         A = 'AA' ; B = 'BB' ; C = 'CC' ; D = 'DD' ; E = 'EE' ; F = 'FF'\n.                                 :(RETURN)\nLFUNCEND AA = 'A' ; BB = 'B' ; CC = 'C'\n         D = 'D' ; E = 'E' ; F = 'F'\n         A = 'X' ; B = 'Y' ; C = 'Z'\n         TEST = DIFFER(LFUNC(AA,BB,CC)) STARS\n         TEST = \u00ac(IDENT(A,'X') IDENT(B,'Y') IDENT(C,'Z')) STARS\n         TEST = \u00ac(IDENT(AA,'A') IDENT(BB,'B') IDENT(CC,'C')) STARS\n         TEST = \u00ac(IDENT(D,'D') IDENT(E,'E') IDENT(F,'F')) STARS\n*\n*        TEST NRETURN\n*\n         DEFINE('NTEST()')                  :(ENDNTEST)\nNTEST    NTEST = .A                         :(NRETURN)\nENDNTEST A = 27\n         TEST = DIFFER(NTEST(),27) STARS\n.              :F(ST59)            ;ST59\n         NTEST() = 26\n.              :F(ST60)            ;ST60\n         TEST = DIFFER(A,26) STARS\n-EJECT\n*\n*        CONTINUE TEST OF FUNCTIONS\n*\n*\n*        TEST FAILURE RETURN\n*\n         DEFINE('FAILURE()')                :(FAILEND)\nFAILURE                           :(FRETURN)\nFAILEND  TEST = FAILURE() STARS\n-EJECT\n*\n*        TEST OPSYN FOR OPERATORS\n*\n         OPSYN('@',.DUPL,2)\n         OPSYN('|',.SIZE,1)\n         TEST = DIFFER('A' @ 4,'AAAA') STARS\n         TEST = DIFFER(|'STRING',6) STARS\n*\n*        TEST OUT ARRAY FACILITY\n*\n         A = ARRAY(3)\n         TEST = DIFFER(A<1>) STARS\n         A<2> = 4.5\n         TEST = DIFFER(A<2>,4.5) STARS\n         TEST = ?A<4> STARS\n         TEST = ?A<0> STARS\n         TEST = DIFFER(PROTOTYPE(A),3) STARS\n         B = ARRAY(3,10)\n         TEST = DIFFER(B<2>,10) STARS\n         B = ARRAY('3')\n         B<2> = 'A'\n         TEST = DIFFER(B<2>,'A') STARS\n         C = ARRAY('2,2')\n         C<1,2> = '*'\n         TEST = DIFFER(C<1,2>,'*') STARS\n         TEST = DIFFER(PROTOTYPE(C),'2,2') STARS\n         D = ARRAY('-1:1,2')\n         D<-1,1> = 0\n         TEST = DIFFER(D<-1,1>,0) STARS\n         TEST = ?D<-2,1> STARS\n         TEST = ?D<2,1> STARS\n-EJECT\n*\n*        TEST PROGRAM DEFINED DATATYPE FUNCTIONS\n*\n         DATA('NODE(VAL,LSON,RSON)')\n         A = NODE('X','Y','Z')\n         TEST = DIFFER(DATATYPE(A),'NODE') STARS\n         TEST = DIFFER(VAL(A),'X') STARS\n         B = NODE()\n         TEST = DIFFER(RSON(B)) STARS\n         LSON(B) = A\n         TEST = DIFFER(RSON(LSON(B)),'Z') STARS\n         TEST = DIFFER(VALUE('B'),B) STARS\n*\n*        TEST MULTIPLE USE OF FIELD FUNCTION NAME\n*\n         DATA('CLUNK(VALUE,LSON)')\n         TEST = DIFFER(RSON(LSON(B)),'Z') STARS\n         TEST = DIFFER(VALUE('B'),B) STARS\n         C = CLUNK('A','B')\n         TEST = DIFFER(LSON(C),'B') STARS\n-EJECT\n*\n*        TEST NUMERICAL PREDICATES\n*\n         TEST = LT(5,4) STARS\n         TEST = LT(4,4) STARS\n         TEST = \u00acLT(4,5) STARS\n         TEST = LE(5,2) STARS\n         TEST = \u00acLE(4,4) STARS\n         TEST = \u00acLE(4,10) STARS\n         TEST = EQ(4,5) STARS\n         TEST = EQ(5,4) STARS\n         TEST = \u00acEQ(5,5) STARS\n         TEST = NE(4,4) STARS\n         TEST = \u00acNE(4,6) STARS\n         TEST = \u00acNE(6,4) STARS\n         TEST = GT(4,6) STARS\n         TEST = GT(4,4) STARS\n         TEST = \u00acGT(5,2) STARS\n         TEST = GE(5,7) STARS\n         TEST = \u00acGE(4,4) STARS\n         TEST = \u00acGE(7,5) STARS\n         TEST = NE(4,5 - 1) STARS\n         TEST = GT(4,3 + 1) STARS\n         TEST = LE(20,5 + 6) STARS\n         TEST = EQ(1.0,2.0) STARS\n         TEST = GT(-2.0,-1.0) STARS\n         TEST = GT(-3.0,4.0) STARS\n         TEST = NE('12',12) STARS\n         TEST = NE('12',12.0) STARS\n         TEST = \u00acCONVERT(BAL,'PATTERN') STARS\n-EJECT\n*\n*        TEST INTEGER\n*\n         TEST = INTEGER('ABC') STARS\n         TEST = \u00acINTEGER(12) STARS\n         TEST = \u00acINTEGER('12') STARS\n*\n*        TEST SIZE\n*\n         TEST = NE(SIZE('ABC'),3) STARS\n         TEST = NE(SIZE(12),2) STARS\n         TEST = NE(SIZE(NULL),0) STARS\n*\n*        TEST LGT\n*\n         TEST = LGT('ABC','XYZ') STARS\n         TEST = LGT('ABC','ABC') STARS\n         TEST = \u00acLGT('XYZ','ABC') STARS\n         TEST = LGT(NULL,'ABC') STARS\n         TEST = \u00acLGT('ABC',NULL) STARS\n*\n*        TEST INDIRECT ADDRESSING\n*\n         TEST = DIFFER($'BAL',BAL) STARS\n         TEST = DIFFER($.BAL,BAL) STARS\n         $'QQ' = 'X'\n         TEST = DIFFER(QQ,'X') STARS\n         TEST = DIFFER($'GARBAGE') STARS\n         A = ARRAY(3)\n         A<2> = 'X'\n         TEST = DIFFER($.A<2>,'X') STARS\n-EJECT\n*\n*        TEST CONCATENATION\n*\n         TEST = DIFFER('A' 'B','AB')        STARS\n         TEST = DIFFER('A' 'B' 'C','ABC') STARS\n         TEST = DIFFER(1 2,'12') STARS\n         TEST = DIFFER(2 2 2,'222') STARS\n         TEST = DIFFER(1 3.4,'13.4') STARS\n         TEST = DIFFER(BAL NULL,BAL)        STARS\n         TEST = DIFFER(NULL BAL,BAL) STARS\n*\n*        TEST DREALS\n*\n         TEST = DIFFER(1.0D2 + 2.0D2,3.0D2) STARS\n         TEST = DIFFER(2.5D0 * 2.0D0,5.00D0) STARS\n         TEST = DIFFER(3.0D0 / 3.0D0,1.0D0) STARS\n         TEST = DIFFER(4.0D0 - 3.0D0,1.0D0) STARS\n         TEST = DIFFER(3.D0 + 1.,4.D0) STARS\n         TEST = DIFFER(1. + 3.D0,4.D0) STARS\n         TEST = DIFFER(1.0D0 + 1,2.0D0) STARS\n         TEST = DIFFER(3 + 1.0D0,4.0D0) STARS\n         TEST = DIFFER(3.0D0 ** 3,27.0D0) STARS\n-EJECT\n*\n*        TEST REMDR\n*\n         TEST = DIFFER(REMDR(10,3),1) STARS\n         TEST = DIFFER(REMDR(11,10),1) STARS\n*\n*        TEST DUPL\n*\n         TEST = DIFFER(DUPL('ABC',2),'ABCABC') STARS\n         TEST = DIFFER(DUPL(NULL,10),NULL) STARS\n         TEST = DIFFER(DUPL('ABCDEFG',0),NULL) STARS\n         TEST = DIFFER(DUPL(1,10),'1111111111')  STARS\n*\n*        TEST TABLE FACILITY\n*\n         T = TABLE(10)\n         TEST = DIFFER(T<'CAT'>) STARS\n         T<'CAT'> = 'DOG'\n         TEST = DIFFER(T<'CAT'>,'DOG')   STARS\n         T<7> = 45\n         TEST = DIFFER(T<7>,45)   STARS\n         TEST = DIFFER(T<'CAT'>,'DOG')  STARS\n         TA = CONVERT(T,'ARRAY')\n         TEST = DIFFER(PROTOTYPE(TA),'2,2') STARS\n         ATA = CONVERT(TA,'TABLE')\n         TEST = DIFFER(ATA<7>,45) STARS\n         TEST = DIFFER(ATA<'CAT'>,'DOG') STARS\n*\n*        TEST ITEM FUNCTION\n*\n         AAA = ARRAY(10)\n         ITEM(AAA,1) = 5\n         TEST = DIFFER(ITEM(AAA,1),5) STARS\n         TEST = DIFFER(AAA<1>,5) STARS\n         AAA<2> = 22\n         TEST = DIFFER(ITEM(AAA,2),22) STARS\n         AMA = ARRAY('2,2,2,2')\n         ITEM(AMA,1,2,1,2) = 1212\n         TEST = DIFFER(ITEM(AMA,1,2,1,2),1212) STARS\n         TEST = DIFFER(AMA<1,2,1,2>,1212) STARS\n         AMA<2,1,2,1> = 2121\n         TEST = DIFFER(ITEM(AMA,2,1,2,1),2121) STARS\n-EJECT\n*\n*        TEST EVAL\n*\n         EXPR = *('ABC' 'DEF')\n         TEST = DIFFER(EVAL(EXPR),'ABCDEF') STARS\n         Q = 'QQQ'\n         SEXP = *Q\n         TEST = DIFFER(EVAL(SEXP),'QQQ') STARS\n         FEXP = *IDENT(1,2)\n         TEST = EVAL(FEXP) STARS\n*\n*        TEST SUBSTR\n*\n         TEST = DIFFER(SUBSTR('ABC',2,1),'B') STARS\n         TEST = DIFFER(SUBSTR('ABCDEF',1,5),'ABCDE') STARS\n         TEST = SUBSTR('ABC',50,1) STARS\n         TEST = SUBSTR('ABC',81,50) STARS\n         TEST = SUBSTR(NULL,1,1) STARS\n*\n*        TEST ARG\n*\nJLAB     DEFINE('JLAB(A,B,C)D,E,F')\n         TEST = DIFFER(ARG(.JLAB,1),'A') STARS\n         TEST = DIFFER(ARG(.JLAB,3),'C') STARS\n         TEST = ARG(.JLAB,0) STARS\n         TEST = ARG(.JLAB,4) STARS\n*\n*        TEST LOCAL\n*\n         TEST = DIFFER(LOCAL(.JLAB,1),'D') STARS\n         TEST = DIFFER(LOCAL(.JLAB,3),'F') STARS\n         TEST = LOCAL(.JLAB,0) STARS\n         TEST = LOCAL(.JLAB,4) STARS\n*\n*        TEST APPLY\n*\n         TEST = APPLY(.EQ,1,2) STARS\n         TEST = \u00acAPPLY(.EQ,1,1) STARS\n         TEST = \u00acAPPLY(.EQ,0) STARS\n         TEST = \u00acAPPLY(.EQ,1,1,1) STARS\n         TEST = \u00acIDENT(APPLY(.TRIM,'ABC '),'ABC') STARS\n-EJECT\n*\n*        FINAL PROCESSING\n*\n         OUTPUT = '************************************************'\n         DIAGNOSTICS = 1000000 - &TRACE\n         EQ(DIAGNOSTICS,0)        :S(TERMINATE)\n         &DUMP = 2\n         OUTPUT = '****    NUMBER OF ERRORS DETECTED  '\n.                                 LPAD(DIAGNOSTICS,5) '    ****'\n         OUTPUT = '**** E N D    O F     D I A G N O S T I C S ****'\n         OUTPUT = '************************************************'\n.                                           :(END)\nTERMINATE OUTPUT = '**** N O     E R R O R S    D E T E C T E D ****'\n         OUTPUT = '**** E N D    O F     D I A G N O S T I C S ****'\n         OUTPUT = '************************************************'\n :(END)\n*\n*        ERROR HANDLING ROUTINE\n*\nERRORS   OUTPUT = '****  ERROR AT '\n.        LPAD(&LASTNO,4)   '      &ERRTYPE = ' LPAD(&ERRTYPE,7,' ')\n.                                           ' ****'\n         &TRACE = &TRACE - 1\n         SETEXIT(.ERRORS)                   :(CONTINUE)\nEND\n./*\n-TITLE SPITBOL TEST PROGRAM #2 -- DIAGNOSTICS PHASE TWO\n*\n*        THIS IS THE STANDARD TEST PROGRAM FOR SPITBOL WHICH\n*        TESTS PATTERN MATCHING USING BOTH FULLSCAN AND QUICKSCAN\n*\n         &DUMP = 2\n         DEFINE('ERROR()')\n         &TRACE = 1000\n         &ERRLIMIT = 100\n         TRACE(.ERRTYPE,'KEYWORD')\n         &FULLSCAN = 0\n         OUTPUT = '**********************************************'\n         OUTPUT = '**** SPITBOL DIAGNOSTICS -- PHASE TWO     ****'\n         OUTPUT = '**********************************************'\nFLOOP    ERRCOUNT = 0\n         OUTPUT = '****           &FULLSCAN = ' &FULLSCAN\n.        '              ****'\n         TEST = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n*\n*        TEST PATTERN MATCHING AGAINST SIMPLE STRING\n*\n         TEST  'ABC' :S(S01) ; ERROR()\nS01      TEST 'BCD' :S(S02) ; ERROR()\nS02      TEST 'XYZ' :S(S03) ; ERROR()\nS03      TEST 'ABD' :F(S04) ; ERROR()\nS04      &ANCHOR = 1\n         TEST 'ABC' :S(S05) ; ERROR()\nS05      TEST 'BCD' :F(S06) ; ERROR()\nS06      TEST TEST :S(S06A) ; ERROR()\n*\n*        TEST SIMPLE CASES OF $\n*\nS06A     TEST 'ABC' $ VAR :S(S07) ; ERROR()\nS07      IDENT(VAR,'ABC') :S(S08) ; ERROR()\nS08      TEST 'ABC' . VARD :S(S09) ; ERROR()\nS09      IDENT(VARD,'ABC') :S(S10) ; ERROR()\n*\n*        TEST LEN\n*\nS10      &ANCHOR = 0\n         TEST LEN(3) $ VARL :S(S11) ; ERROR()\nS11      IDENT(VARL,'ABC') :S(S12) ; ERROR()\nS12      TEST LEN(26) $ VARL :S(S13) ; ERROR()\nS13      IDENT(VARL,TEST) :S(S14) ; ERROR()\nS14      TEST LEN(27) :F(S15) ; ERROR()\n*\n*        TEST TAB\n*\nS15      TEST TAB(3) $ VART :S(S16) ; ERROR()\nS16      IDENT(VART,'ABC') :S(S17) ; ERROR()\nS17      TEST TAB(26) $ VART :S(S18) ; ERROR()\nS18      IDENT(TEST,VART) :S(S19) ; ERROR()\nS19      TEST TAB(0) $ VART :S(S20) ; ERROR()\nS20      IDENT(VART) :S(S21) ; ERROR()\n-EJECT\n*\n*        TEST ARB\n*\nS21      TEST ARB $ VARA 'C' :S(S22) ; ERROR()\nS22      IDENT(VARA,'AB') :S(S23) ; ERROR()\nS23      &ANCHOR = 1\n         TEST ARB $ VARA POS(60) :F(S24) ; ERROR()\nS24      IDENT(VARA,TEST) :S(S25) ; ERROR()\n*\n*        TEST POS\n*\nS25      TEST ARB $ VARA POS(2) $ VARP :S(S26) ; ERROR()\nS26      (IDENT(VARA,'AB') IDENT(VARP)) :S(S27) ; ERROR()\nS27      &ANCHOR = 0\n         TEST ARB $ VARA POS(26) $ VARP :S(S28) ; ERROR()\nS28      (IDENT(VARA,TEST) IDENT(VARP)) : S(S29) ; ERROR()\nS29      TEST ARB $ VARA POS(0) $ VARP :S(S30) ; ERROR()\nS30      IDENT(VARA VARP) :S(S31) ; ERROR()\nS31      TEST POS(0) ARB $ VARA POS(26) :S(S32) ; ERROR()\nS32      IDENT(TEST,VARA) :S(S33) ; ERROR()\nS33      TEST POS(2) ARB $ VARA POS(3) :S(S34) ; ERROR()\nS34      IDENT(VARA,'C') :S(S35) ; ERROR()\nS35      TEST POS(27) :F(S36) ; ERROR()\n*\n*        TEST RPOS\n*\nS36      TEST ARB $ VARA RPOS(25) :S(S37) ; ERROR()\nS37      IDENT(VARA,'A') :S(S38) ; ERROR()\nS38      TEST ARB $ VARA RPOS(0) :S(S39) ; ERROR()\nS39      IDENT(TEST,VARA) :S(S39A) ; ERROR()\nS39A     TEST ARB $ VARA RPOS(26) :S(S40) ; ERROR()\nS40      IDENT(VARA) :S(S41) ; ERROR()\nS41      TEST RPOS(27) :F(S42) ; ERROR()\n*\n*        TEST RTAB\n*\nS42      TEST RTAB(26) $ VARA :S(S43) ; ERROR()\nS43      IDENT(VARA) :S(S44) ; ERROR()\nS44      TEST RTAB(27) :F(S45) ; ERROR()\nS45      TEST RTAB(0) $ VARA :S(S46) ; ERROR()\nS46      IDENT(VARA,TEST) :S(S47) ; ERROR()\nS47      TEST RTAB(25) $ VARA :S(S48) ; ERROR()\nS48      IDENT(VARA,'A') :S(S49) ; ERROR()\n*\n*        TEST @\n*\nS49      TEST LEN(6) @VARA :S(S50) ; ERROR()\nS50      IDENT(VARA,6) :S(S51) ; ERROR()\nS51      TEST @VARA :S(S52) ; ERROR()\nS52      IDENT(VARA,0) :S(S53) ; ERROR()\nS53      TEST LEN(26) @VARA :S(S54) ; ERROR()\nS54      IDENT(VARA,26) :S(S55) ; ERROR()\n-EJECT\n*\n*        TEST BREAK\n*\nS55      TEST BREAK('C') $ VARA :S(S56) ; ERROR()\nS56      IDENT(VARA,'AB') :S(S57) ; ERROR()\nS57      TEST BREAK('Z()') $ VARA :S(S58)     ; ERROR()\nS58      IDENT(VARA,'ABCDEFGHIJKLMNOPQRSTUVWXY') :S(S59) ; ERROR()\nS59      TEST BREAK(',') :F(S60) ; ERROR()\nS60      LPAD(TEST,1000) BREAK('A') $ VARA :S(S61) ; ERROR()\nS61      IDENT(LPAD(' ',1000 - 26),VARA) :S(S62) ; ERROR()\nS62      LPAD(TEST,1000) BREAK(',') :F(S63) ; ERROR()\n*\n*        TEST SPAN\n*\nS63      TEST SPAN(TEST) $ VARA :S(S64) ; ERROR()\nS64      IDENT(TEST,VARA) :S(S65) ;ERROR()\nS65      TEST SPAN('CDQ') $ VARA :S(S66) ; ERROR()\nS66      IDENT(VARA,'CD') :S(S67) ; ERROR()\nS67      TEST SPAN(',') :F(S68) ; ERROR()\nS68      LPAD(TEST,1000) SPAN(' ') $ VARA :S(S69) ; ERROR()\nS69      IDENT(VARA,LPAD(' ',1000 - 26)) :S(S70) ; ERROR()\n*\n*        TEST BREAKX\n*\nS70      (TEST TEST) POS(0) BREAKX('E') $ VARA '.' :F(S71) ; ERROR()\nS71      IDENT(VARA,TEST 'ABCD') :S(S72) ; ERROR()\nS72      TEST BREAKX('.') :F(S73) ; ERROR()\n*\n*        TEST ANY\n*\nS73      TEST ANY('MXZ') $ VARA :S(S74) ; ERROR()\nS74      IDENT(VARA,'M') :S(S75) ; ERROR()\nS75      TEST ANY(',.') :F(S76) ; ERROR()\n-EJECT\n*\n*        TEST NOTANY\n*\nS76      TEST NOTANY('ABCDEFGHJKLMPQRSTUWXYZ') $ VARA :S(S77) ; ERROR()\nS77      IDENT(VARA,'I') :S(S78) ; ERROR()\nS78      TEST NOTANY(TEST) :F(S79) ; ERROR()\n*\n*        TEST REM\n*\nS79      TEST REM $ VARA :S(S80) ; ERROR()\nS80      IDENT(VARA,TEST) :S(S81) ; ERROR()\nS81      TEST LEN(26) REM $ VARA :S(S82) ; ERROR()\nS82      IDENT(VARA) :S(S83) ; ERROR()\n*\n*        TEST ALTERNATION\n*\nS83      TEST ('ABD' | 'AB') $ VARA :S(D84) ; ERROR()\nD84      IDENT(VARA,'AB') :S(D85) ; ERROR()\nD85      TEST (TEST 'A' | TEST) $ VARL :S(D86) ; ERROR()\nD86      IDENT(VARL,TEST) :S(D00) ; ERROR()\n*\n*        TEST DEFERRED STRINGS\n*\nD00      TEST *'ABC' :S(D01) ; ERROR()\nD01      TEST *'ABD' :F(D06) ; ERROR()\n*\n*        TEST $ . WITH DEFERRED NAME ARGUMENTS\n*\nD06      TEST 'ABC' $ *VAR :S(D07) ; ERROR()\nD07      IDENT(VAR,'ABC') :S(D08) ; ERROR()\nD08      TEST 'ABC' . *$'VARD' :S(D09) ; ERROR()\nD09      IDENT(VARD,'ABC') :S(D10) ; ERROR()\n*\n*        TEST LEN WITH DEFERRED ARGUMENT\n*\nD10      &ANCHOR = 0\n         TEST LEN(*3) $ VARL :S(D11) ; ERROR()\nD11      IDENT(VARL,'ABC') :S(D15) ; ERROR()\n*\n*        TEST TAB WITH DEFERRED ARGUMENT\n*\nD15      TEST TAB(*3) $ VART :S(D16) ; ERROR()\nD16      IDENT(VART,'ABC') :S(D21) ; ERROR()\n-EJECT\n*\n*        TEST POS WITH DEFERRED ARGUMENT\n*\nD21      &ANCHOR = 1\n         TEST ARB $ VARA POS(*2) $ VARP :S(D26) ; ERROR()\nD26      (IDENT(VARA,'AB') IDENT(VARP)) :S(D27) ; ERROR()\nD27      &ANCHOR = 0\n         TEST ARB $ VARA POS(*0) $ VARP :S(D35) ; ERROR()\nD35      IDENT(VARA VARP) :S(D36) ; ERROR()\n*\n*        TEST RPOS WITH DEFERRED ARGUMENT\n*\nD36      TEST ARB $ VARA RPOS(*25) :S(D37) ; ERROR()\nD37      IDENT(VARA,'A') :S(D38) ; ERROR()\n*\n*        TEST RTAB WITH DEFERRED ARGUMENT\n*\nD38      TEST RTAB(*26) $ VARA :S(D43) ; ERROR()\nD43      IDENT(VARA) :S(D49) ; ERROR()\n*\n*        TEST @ WITH DEFERRED ARGUMENT\n*\nD49      TEST LEN(6) @*VARA :S(D50) ; ERROR()\nD50      IDENT(VARA,6) :S(D51) ; ERROR()\nD51      TEST @*$'VARA' :S(D52) ; ERROR()\nD52      IDENT(VARA,0) :S(D55) ; ERROR()\n*\n*        TEST BREAK WITH DEFERRED ARGUMENT\n*\nD55      TEST BREAK(*'C') $ VARA :S(D56) ; ERROR()\nD56      IDENT(VARA,'AB') :S(D57) ; ERROR()\n*\n*        TEST SPAN WITH DEFERRED ARGUMENT\n*\nD57      TEST SPAN(*TEST) $ VARA :S(D64) ; ERROR()\nD64      IDENT(TEST,VARA) :S(D70) ; ERROR()\n*\n*        TEST BREAKX WITH DEFERRED ARGUMENT\n*\nD70      (TEST TEST) POS(*0) BREAKX(*'E') $ VARA '.' :F(D71) ; ERROR()\nD71      IDENT(VARA,TEST 'ABCD') :S(D73) ; ERROR()\n-EJECT\n*\n*        TEST ANY WITH DEFERRED ARGUMENT\n*\nD73      TEST ANY(*'MXZ') $ VARA :S(D74) ; ERROR()\nD74      IDENT(VARA,'M') :S(D75) ; ERROR()\n*\n*        TEST NOTANY WITH DEFERRED ARGUMENT\n*\nD75      TEST NOTANY(*'ABCDEFGHJKLMPQRSTUWXYZ') $ VARA :S(D77) ;\n.                                                          ERROR()\nD77      IDENT(VARA,'I') :S(D79) ; ERROR()\nD79      :(ALLDONE)\n         EJECT\n*\n*        ERROR HANDLING ROUTINE\n*\nERROR    OUTPUT = '****** ERROR DETECTED AT ' &LASTNO ' ********'\n         ERRCOUNT = ERRCOUNT + 1\n         OUTPUT = '***** RESUMING EXECUTION *******'       :(RETURN)\n*\n*        TERMINATION ROUTINE\n*\nALLDONE\n         ERRCOUNT = ERRCOUNT + &ERRLIMIT - 100\n         &ERRLIMIT = 100\n         OUTPUT = EQ(ERRCOUNT,0)\n.                 '****           NO ERRORS DETECTED         ****'\n         OUTPUT = '**********************************************'\n         &FULLSCAN = EQ(&FULLSCAN,0) 1           :S(FLOOP)\n         OUTPUT = '****           END OF DIAGNOSTICS         ****'\n         OUTPUT = '**********************************************'\nEND\n./*\n-TITLE SPITBOL TEST PROGRAM #3 -- COMPUTE FACTORIAL TABLE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        THIS PROGRAM COMPUTES AND PRINTS A TABLE OF N FACTORIAL      *\n*        FOR VALUES OF N FROM 1 THROUGH AN UPPER LIMIT \"NX\".          *\n*                                                                     *\n*        IT DEMONSTRATES A METHOD OF MANIPULATING NUMBERS WHICH ARE   *\n*        TOO LARGE FOR THE COMPUTER, AS STRINGS OF CHARACTERS.  THE   *\n*        COMMAS IN THE PRINTED VALUES ARE OPTIONAL, ADDED FOR READING *\n*        EASE.                                                        *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*        INITIALIZATION.\n*\n         NX = 45\n         N = 1\n         NSET = 1\n         NUM = ARRAY(1000)\n         NUM<1> = 1\n         FILL = ARRAY('0:3')\n         FILL<0> = '000'\n         FILL<1> = '00'\n         FILL<2> = '0'\n*\n         OUTPUT = '          TABLE OF FACTORIALS FOR 1 THROUGH ' NX\n         OUTPUT =\n*\n*        COMPUTE THE NEXT VALUE FROM THE PREVIOUS ONE.\n*\nL1       I = 1\nL2       NUM<I> = NUM<I> * N                           :F(ERR)\n         I = LT(I,NSET) I + 1                          :S(L2)\n         I = 1\nL3       LT(NUM<I>,1000)                               :S(L4)\n         NUMX = NUM<I> / 1000                          :F(ERR)\n         NUM<I + 1> = NUM<I + 1> + NUMX                :F(ERR)\n         NUM<I> = NUM<I> - 1000 * NUMX                 :F(ERR)\nL4       I = LT(I,NSET) I + 1                          :S(L3)\n*\n*        FORM A STRING REPRESENTING THE FACTORIAL.\n*\nL5       NSET = DIFFER(NUM<NSET + 1>) NSET + 1\n         NUMBER = NUM<NSET>                            :F(ERR)\n         I = GT(NSET,1) NSET - 1                       :F(L7)\nL6       NUMBER = NUMBER ',' FILL<SIZE(NUM<I>)> NUM<I>\n         I = GT(I,1) I - 1                             :S(L6)\n*\n*        OUTPUT A LINE OF THE TABLE.\n*\nL7       OUTPUT = N '!=' NUMBER\n         N = LT(N,NX) N + 1                            :S(L1)F(END)\n*\n*        ERROR TERMINATION.\n*\nERR      OUTPUT = N '! CANNOT BE COMPUTED BECAUSE OF TABLE OVERFLOW.'\n         OUTPUT = '     INCREASE THE SIZE OF ARRAY \"NUM\".'\n*\nEND\n./*\n-TITLE SPITBOL TEST PROGRAM #4 -- SYNTACTIC RECOGNIZER FOR SPITBOL\n*\n*        THIS PROGRAM IS A SYNTACTIC RECOGNIZER FOR SPITBOL STATEMENTS\n*\n*      FIRST A SERIES OF PATTERNS IS BUILD CULMINATING IN A PATTERN\n*      WHICH MATCHES ONLY SYNTACTICALLY CORRECT STATEMENTS.  CARD IMAGES\n*      ARE THEN READ IN AND PROCESSED.  INCORRECT STATEMENTS ARE\n*      IDENTIFIED BY AN ERROR MESSAGE.\n*\n*      THE FUNCTION OPT FORMS A PATTERN THAT MATCHES EITHER NULL OR ITS\n*      ARGUMENT.\n*\n         DEFINE('OPT(PATTERN)')\n*\n         LETTERS   =   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n*\n*      ON THE IBM SYSTEM/360 LETTERS INCLUDE LOWER CASE AS WELL.\n*\n         DIGITS   =   '0123456789'\n         ALPHANUMERICS   =   LETTERS DIGITS\n         BLANKS   =   SPAN(' ')\n         INTEGER   =   SPAN(DIGITS)\n         REAL   =   SPAN(DIGITS) '.' OPT(SPAN(DIGITS))\n         IDENTIFIER   =   ANY(LETTERS) OPT(SPAN(ALPHANUMERICS '_.'))\n         UNARY   =   ANY('+-&.$*?\u00ac@%#')\n         BINARY   =   ANY('-+.$*|/@*#') | '**'\n         BINARYOP   =   BLANKS OPT(BINARY BLANKS)\n         UNQALPHABET   =   &ALPHABET\n         UNQALPHABET   '\"'   =\n         UNQALPHABET   \"'\"   =\n         DLITERAL   =   '\"' SPAN(UNQALPHABET \"'\") '\"'\n         SLITERAL   =   \"'\" SPAN(UNQALPHABET '\"') \"'\"\n         LITERAL   =   SLITERAL | DLITERAL | INTEGER | REAL\n         ELEMENT   =   OPT(UNARY) (IDENTIFIER | LITERAL | *FUNCTION_CALL\n.                      | '(' *EXPRESSION | OPT(BLANKS) ')' | *ARRAY_REF)\n         OPERATION   =   *ELEMENT BINARYOP (*ELEMENT | *EXPRESSION)\n         EXPRESSION   =   OPT(BLANKS) (*ELEMENT | *OPERATION | NULL)\n.                         OPT(BLANKS)\n         ARG_LIST   =   *EXPRESSION OPT(',' *ARG_LIST)\n         FUNCTION_CALL   =   IDENTIFIER '(' *ARG_LIST ')'\n         ARRAY_SUB   =   '<' *ARG_LIST '>' OPT(*ARRAY_SUB)\n         ARRAY_REF   =   IDENTIFIER ARRAY_SUB\n         LABEL   =   ANY(ALPHANUMERICS) (BREAK(' ;') | REM)\n         LABEL_FIELD   =   OPT(LABEL)\n         GOTO   =   '(' EXPRESSION ')'\n         GOTO_FIELD   =   OPT(BLANKS ':' FENCE OPT(BLANKS) (GOTO | 'S'\n.                         GOTO | 'F' GOTO | 'S' GOTO OPT(BLANKS) 'F'\n.                         GOTO | 'F' GOTO OPT(BLANKS) 'S' GOTO)\n.                         OPT(BLANKS))\n         RULE   =   OPT(BLANKS ELEMENT (OPT(BLANKS) '=' OPT(OPT(BLANKS)\n.                   EXPRESSION) | OPT(BLANKS EXPRESSION OPT(OPT(BLANKS)\n.                   '=' OPT(OPT(BLANKS) EXPRESSION)))))\n         EOS   =   RPOS(0) | ';'\n         STATEMENT   =   LABEL_FIELD RULE GOTO_FIELD EOS\n-EJECT\n*\n*      THE PATTERN FOR RECOGNIZING STATEMENTS IS NOW FORMED.  THE\n*      PROGRAM TO ANALYZE INPUT CARDS FOLLOWS.\n*\n         COMMENT   =   ANY('*-')\n         CONTINUE   =   ANY('.+') . CC\n         &ANCHOR   =   1\n         &FULLSCAN   =   1\n         EOF   =\n         INPUT(.INPUT,,72)\n*\n*      INITIALIZE PROCESS FROM FIRST CARD.\n*\nREADI    IMAGE   =   TRIM(INPUT)                       :F(END)\n         OUTPUT   =   '     ' IMAGE\n*\n*        DO NOT PROCESS COMMENT OR CONTINUE CARDS.\n*\n         IMAGE   COMMENT                               :F(READC)S(READI)\nNEXTST   IDENT(EOF)                                    :F(END)\n         OUTPUT   =   '     ' LINE\n         IMAGE   =   LINE\nREADC    LINE   =   TRIM(INPUT)                        :F(ENDGAME)\n         LINE   COMMENT                                :S(PRINT)\n         LINE   CONTINUE   =                           :F(ANALYZE)\n         OUTPUT   =   '     ' CC LINE\n         IMAGE   =   IMAGE LINE                        :(READC)\nANALYZE  IMAGE   STATEMENT   =                         :F(ERROR)\n         DIFFER(IMAGE)                                 :S(ANALYZE)\n         OUTPUT   =   '<<< NO SYNTACTIC ERROR >>>'\nSKIP     OUTPUT   =                                    :(NEXTST)\n*\n*      IF AN ERRONEOUS STATEMENT IS  ENCOUNTERED IN A STRING OF\n*      STATEMENTS SEPARATED BY SEMICOLONS, SUBSEQUENT STATEMENTS ARE\n*      NOT PROCESSED.\n*\nERROR    OUTPUT   =   '<<< SYNTACTIC ERROR >>>'        :(SKIP)\n*\nPRINT    OUTPUT   =   '     ' LINE                     :(READC)\nENDGAME  EOF   =   1                                   :(ANALYZE)\n*\n*\nOPT      OPT   =   NULL | PATTERN                      :(RETURN)\nEND\n*\n*      A VARIETY OF CORRECT AND INCORRECT SPITBOL STATEMENTS FOLLOW\n*\n-LIST\nCOMPUTE  X   =  Y + 3 ** -'2'\n       X   =   Y+Z\n         ELEMENT<I,J>= ELEMENT<I,-J> + ELEMENT<-I,J>\n       ELEMENT<I><J><K>   =   ELEMENT<K><J><I>\n       A<X,Y,Z + 1>   =   F(X,STRUCTURE_BUILD(TYPE,LENGTH + 1))\nSETUP    PAT1   =   (BREAK(',:') $ FIRST | SPAN(' .') $ SECOND\n.                   . VALUE ARBNO(BAL | LEN(1))  :($SWITCH)\n       DEFINE('F(X,Y))\n       L   =   LT(N,B<J> L + 1\nNEWONE_TRIAL   X   =   \u00acCOORD<1,K> X * X\n       TRIM(INPUT)   PAT1    :S(OK)  :F(BAD)\n   X   =   3.01; Y = 2.    ; Z   =   X * -Y\n./*\n-TITLE SPITBOL TEST PROGRAM #5 -- DEMONSTRATION VERSION OF TREESORT4\n-STITL DRIVER\n DEFINE('TREESORT4(DATA,NUMBER_TO_SORT)')\n DEFINE('PRINTER()')\n DATA = ARRAY(24)\n         INPUT(.INPUT,,72)\nREADER J = J + 1\n DATA<J> = TRIM(INPUT)  :S(READER)\n OUTPUT = 'UNSORTED DATA'\n OUTPUT =\n PRINTER()\n TREESORT4(DATA,24)\n OUTPUT =\n OUTPUT = 'SORTED DATA'\n OUTPUT =\n PRINTER() :(END)\n*\nPRINTER J = 0\nPRINTL J = J + 1\n OUTPUT = DATA<J>    :S(PRINTL)F(RETURN)\n-STITL ACTUAL TREESORT4 SUBROUTINE\n*             TREESORT4\n*             ---------\n*\n*             SORTING ALGORITHM DERIVED FROM FLOYD'S TREESORT3 PUBLISHED\n*             IN CACM DEC. 1967 -- THE MODIFICATIONS DEVISED BY R. DEWAR\n*             AND L.FISHER REDUCE THE NUMBER OF COMPARES FROM 2NLOGN\n*             TO NLOGN -- THIS VERSION CODED IN SNOBOL4 BY R. DEWAR\n*\nTREESORT4\n.             NUMBER_IN_TREE = NUMBER_TO_SORT\n              NODE_TO_SIFT = NUMBER_TO_SORT / 2\n              RETURN_FROM_SIFT = .SIFT_RETURN_1\nSIFT_CALL_1\n.             HOLD_LOCATION = DATA<NODE_TO_SIFT> :(SIFT_NODE)\nSIFT_RETURN_1\n.             NODE_TO_SIFT = GT(NODE_TO_SIFT,1)\n.                              NODE_TO_SIFT - 1  :S(SIFT_CALL_1)\nSECOND_PHASE\n.             RETURN_FROM_SIFT = .SIFT_RETURN_2\nSIFT_RETURN_2\n.             HOLD_LOCATION = DATA<NUMBER_IN_TREE>\n              DATA<NUMBER_IN_TREE> = DATA<1>\n              NUMBER_IN_TREE = GT(NUMBER_IN_TREE,1)\n.                               NUMBER_IN_TREE - 1\n.                                                :S(SIFT_NODE)F(RETURN)\n-EJECT\nSIFT_NODE\n.             FATHER = NODE_TO_SIFT\nPULL_UP_LARGER_SON\n.             LEFT_SON = FATHER * 2\n              LT(LEFT_SON,NUMBER_IN_TREE)        :S(COMPARE_SONS)\n              EQ(LEFT_SON,NUMBER_IN_TREE)        :S(LEFT_SON_HIGH)\n                                                 :(CHECK_FATHERS)\nCOMPARE_SONS\n.             RIGHT_SON = LEFT_SON + 1\n              LGT(DATA<LEFT_SON>,DATA<RIGHT_SON>)\n.                                                :S(LEFT_SON_HIGH)\nRIGHT_SON_HIGH\n.             DATA<FATHER> = DATA<RIGHT_SON>\n              FATHER = RIGHT_SON                 :(PULL_UP_LARGER_SON)\nLEFT_SON_HIGH\n.             DATA<FATHER> = DATA<LEFT_SON>\n              FATHER = LEFT_SON                  :(PULL_UP_LARGER_SON)\nCHECK_FATHERS\n.             HOLE_IN_TREE = FATHER\nTEST_NEXT_FATHER\n.             FATHER_OF_HOLE = HOLE_IN_TREE / 2\n              LT(FATHER_OF_HOLE,NODE_TO_SIFT)    :S(FILL_HOLE)\n              LGT(DATA<FATHER_OF_HOLE>,HOLD_LOCATION)\n.                                                :S(FILL_HOLE)\n              DATA<HOLE_IN_TREE> = DATA<FATHER_OF_HOLE>\n              HOLE_IN_TREE = FATHER_OF_HOLE      :(TEST_NEXT_FATHER)\nFILL_HOLE\n.             DATA<HOLE_IN_TREE> = HOLD_LOCATION\n.                                                :($RETURN_FROM_SIFT)\nEND\nSHALL\nI\nCOMPARE\nTHEE\nTO\nA\nSUMMERS\nDAY\nTHOU\nART\nMORE\nLOVELY\nAND\nMORE\nTEMPORATE\nROUGH\nWINDS\nDO\nSHAKE\nTHE\nDARLING\nBUDS\nOF\nMAY\n./*\n-TITLE SPITBOL TEST PROGRAM #6 -- TOPOLOGICAL SORT\n*\n*        TOPOLOGICAL SORT\n*\n*   MAPS A PARTIAL ORDERING OF OBJECTS INTO A LINEAR ORDERING\n*\n*        A(1), A(2), ..., A(N)\n*\n*   SUCH THAT IF   A(S) < A(T) IN THE PARTIAL ORDERING,THEN S < T.\n*   (CF. D.E.KNUTH, THE ART OF COMPUTER PROGRAMMING,VOLUME 1,\n*   ADDISON-WESLEY,MASS.,1968, P.262)\n*\n         &DUMP = 2\n         OUTPUT('OUT',6,'(121A1)')\n         PAIR      = BREAK('<') . MU LEN(1) BREAK(',') . NU LEN(1)\n         DATA('ITEM(COUNT,TOP)')\n         DATA('NODE(SUC,NEXT)')\n         DEFINE('DECR(X)')\n         DEFINE('INDEX(TAU)')\n         INPUT(.INPUT,,72)\n*\n*     READ IN THE NUMBER OF ITEMS, N, AND GENERATE AN ARRAY OF ITEMS.\n*\n*   EACH ITEM HAS TWO FIELDS, (COUNT,TOP), WHERE\n*        COUNT = NO. OF ELEMENTS PRECEEDING IT.\n         TOP = TOP OF LIST OF ITEMS SUCCEEDING IT.\n*\n         N         = TRIM(INPUT)\n         X         = ARRAY('0:' N)\n*   INITIALIZE THE ITEMS TO (0,NULL).\n*\nT1       X<I>      =  ITEM(0,)              :F(T1A)\n         I         =  I + 1                 :(T1)\n*\n*   READ IN RELATIONS.\n*\nT1A      OUT       = '1 THE RELATIONS ARE:'\nT2A      REL       = TRIM(INPUT) ','        :F(T3A)\n         OUTPUT    = REL\nT2       REL       PAIR  =                  :F(T2A)\n         J         = INDEX(MU)\n         K         = INDEX(NU)\n*\n*   SINCE MU < NU, INCREASE THE COUNT OF THE KTH ITEM AND ADD A\n*   NODE TO THE LIST OF SUCCESSORS OF THE JTH ITEM.\n*\nT3       COUNT(X<K>) = COUNT(X<K>) + 1\n         TOP(X<J>) = NODE(K,TOP(X<J>))      :(T2)\n-EJECT\n*\n*    A QUEUE IS MAINTAINED OF THOSE ITEMS WITH ZERO COUNT FIELD.\n*    THE LINKS FOR THE QUEUE, QLINK, ARE KEPT IN THE COUNT FIELD.\n*    THE VARIABLES F,R POINT TO THE FRONT AND REAR OF THE QUEUE.\n*\nT3A      OPSYN('QLINK','COUNT')\n*\n*    INITIALIZE THE QUEUE FOR OUTPUT.\n*\n         R         = 0\n         QLINK(X<0>) = 0\n         K         = 0\nT4       K         = ?X<K + 1>  K + 1       :F(T4A)\n         QLINK(X<R>) = EQ(COUNT(X<K>),0)  K :F(T4)\n         R         = K                      :(T4)\nT4A      F         = QLINK(X<0>)\n*\n*    OUTPUT THE FRONT OF THE QUEUE.\n*\n         OUT       = '0 THE LINEAR ORDERING IS:'\nT5       OUTPUT    = NE(F,0)  $(F ':')      :F(T8)\n         N         = N - 1\n         P         = TOP(X<F>)\n*    ERASE RELATIONS.\nT6       IDENT(P)                           :S(T7)\n         DECR(.COUNT(X<SUC(P)>))            :S(T6A)\n*\n*    IF COUNT IS ZERO ADD  ITEM TO QUEUE.\n*\n         QLINK(X<R>) = SUC(P)\n         R         = SUC(P)\nT6A      P         = NEXT(P)                :(T6)\n*\n*    REMOVE FROM QUEUE.\n*\nT7       F         = QLINK(X<F>)            :(T5)\n*\n*    FUNCTION DEFINITIONS.\n*\nDECR     $X        = GT($X,1)  $X - 1       :S(RETURN)\n         $X        = 0                      :(FRETURN)\n*\nINDEX    INDEX     = DIFFER($(TAU ':'))  $(TAU ':')  :S(RETURN)\n         TERMCT    = LT(TERMCT,N)  TERMCT + 1    :F(FRETURN)\n         INDEX     = TERMCT\n         $(TERMCT ':')   =  TAU\n         $(TAU ':')   =  TERMCT             :(RETURN)\n*\nT8       OUTPUT    = NE(N,0) 'THE ORDERING CONTAINS A LOOP.'\nEND\n14\nLETTERS<ALPHANUM,NUMBERS<ALPHANUM\nBLANKS<OPTBLANKS\nNUMBERS<REAL\nNUMBERS<INTEGER\nLETTERS<VARIABLE,ALPHANUM<VARIABLE\nBINARY<BINARYOP,BLANKS<BINARYOP\nUNQALPHABET<DLITERAL\nUNQALPHABET<SLITERAL\nSLITERAL<LITERAL,DLITERAL<LITERAL,INTEGER<LITERAL,REAL<LITERAL\n./*\n-TITLE SPITBOL TEST PROGRAM #7 -- SYMBOL TABLE GENERATOR\n*\n*        THIS PROGRAM DEMONSTRATES THE STORAGE OF SYMBOL TABLES\n*        USING A TECHIQUE IN WHICH NAMES ARE STORED AS LINKED LISTS\n*        OF CHARACTERS. THE DATA FUNCTION IS USED TO FORM THE\n*        REQUIRED NODES WHICH CONTAIN APPROPRIATE POINTERS TO BE\n*        USED ON FAILURE OR SUCCESS OF THE CHARACTER BY CHARACTER MATCH\n*\n-CODE\n         DATA('SYMB(CHAR,LINK,ALT,ASSOC,SUCC)')\n         INPUT(.INPUT,,72)\n         SPC = '     ::'\n         ALPH = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nCLEAR    HEAD =\n         SWITCH1 = .FIRST\n         X = 0\nREADA    OUTPUT =\nREAD     CARD = TRIM(INPUT)                      :F(END1)\n         OUTPUT = CARD\n         DIFFER(CARD)                            :F(BADCARD)\n         CARD POS(0) '$' =                       :S(CONTROL)\n         CARD NOTANY(ALPH)                       :F(INCX)\nBADCARD  OUTPUT = '  CARD ABOVE IS ILLEGAL'      :(READ)\nINCX     X = X + 1                               :($SWITCH1)\nFIRST    SWITCH1 = .SEARCH\nF1       CARD LEN(1) . CH =                      :F(ERR)\n         HEAD = SYMB(CH)\n         CURRENT = HEAD\nF2       CARD LEN(1) . CH =                      :F(INSERT)\nF3       SUCC(CURRENT) = SYMB(CH,CURRENT)\n         CURRENT = SUCC(CURRENT)                 :(F2)\nINSERT   ASSOC(CURRENT) = ASSOC(CURRENT) X \",\"   :(READ)\nSEARCH   CARD LEN(1) . CH =                      :F(ERR)\n         LGT(CHAR(HEAD), CH)                     :S(S7)\n         IDENT(CHAR(HEAD),CH)                    :S(S5)\n*\n*  FIRST CHARACTER OF HEAD IS < FIRST CHAR OF CHAR JUST READ\n*  IF ALT(HEAD) NULL THEN MUST EXTEND STRUCTURE\n*\n         IDENT(ALT(HEAD))                        :S(S3)\n         CURRENT = ALT(HEAD)\nS1       LGT(CHAR(CURRENT),CH)                   :S(S6)\n         IDENT(CHAR(CURRENT),CH)                 :S(S4)\n         IDENT(ALT(CURRENT))                     :S(S2)\n         CURRENT = ALT(CURRENT)                  :(S1)\n*\n*  NEW ALTERNATIVE MUST BE INSERTED AT END\n*\nS2       ALT(CURRENT) = SYMB(CH,CURRENT)\n*\n*  THEN REST OF WORD STRUNG OUT\n*\n         CURRENT = ALT(CURRENT)                  :(F2)\n*\n*  NEW ALTERNATIVE MUST BE INSERTED AT HEAD OF LIST\n*\nS3       ALT(HEAD) = SYMB(CH,HEAD)\n         CURRENT = ALT(HEAD)                     :(F2)\n-EJECT\n*\n*  CHARACTER HAS BEEN FOUND. NOW LOOK AT NEXT HCARACTER OF WORD\n*\nS4       CARD LEN(1) . CH  =                     :F(INSERT)\n*  IF NO SUCCESSORS, STRING OUT REST OF WORD\n*\n         IDENT(SUCC(CURRENT))                    :S(F3)\n*\n*  OTHERWISE CONTINUE EXAMINATION\n*\n         CURRENT = SUCC(CURRENT)                 :(S1)\nS5       CURRENT = HEAD                          :(S4)\n*\n*  CHAR IS SMALLER THAN CURRENT ALTERNATIVE\n*\nS6       Y = LINK(CURRENT)\n         ALT(Y) = IDENT(ALT(Y),CURRENT) SYMB(CH,Y)         :F(S6A)\n         Y = ALT(Y)                              :(S6B)\nS6A      SUCC(Y) = SYMB(CH,Y)\n         Y = SUCC(Y)\nS6B      ALT(Y) = CURRENT\n         LINK(CURRENT) = Y\n         CURRENT = Y                             :(F2)\n*\n*  NEW ALTERNATIVE MUST BE LINKED TO HEAD, AT TOP OF LIST\n*\nS7       Y = HEAD\n         HEAD = SYMB(CH)\n         LINK(Y) = HEAD\n         ALT(HEAD) = Y\n         CURRENT = HEAD                          :(F2)\nCONTROL  IDENT(CARD,\"*\")                         :F(C1)\n         OUTPUT =\n         OUTPUT = '  (STRUCTURE IS CLEARED)'\n         OUTPUT =                                :(CLEAR)\nC1       IDENT(CARD,'$')                         :F(C2)\n         OUTPUT =\n         OUTPUT = '  (PRINTOUT OF ENTIRE STRUCTURE FOLLOWS...)'\n         OUTPUT =\n         IDENT(HEAD)                             :S(C4)\n         HOLD =\n         START = HEAD                            :(LISTEM)\nC2       IDENT(CARD)                             :S(BADCARD)\n         CARD NOTANY(ALPH)                       :S(BADCARD)\n-EJECT\n*\n*  HERE TO PRINT WORDS STARTING WITH SPECIFIED HEAD\n*\n         OUTPUT =\n         OUTPUT = '  (PRINTOUT OF ALL WORDS BEGINNING WITH \"'\n+          CARD '\"...)'\n         OUTPUT =\n         HOLD = CARD\n         CURRENT = HEAD\n         CARD LEN(1) . CH =\nC3       IDENT(CHAR(CURRENT),CH)                 :S(NEXT)\n         CURRENT = ALT(CURRENT)\n         IDENT(CURRENT)                          :F(C3)\nC4       OUTPUT = '  (NO WORDS)'                 :(READA)\nNEXT     CARD LEN(1) . CH =                      :F(SETUP)\n         CURRENT = SUCC(CURRENT)\n         IDENT(CURRENT)                          :S(C4)F(C3)\nSETUP    OUTPUT = DIFFER(ASSOC(CURRENT)) SPC HOLD '  ' ASSOC(CURRENT)\n         START = DIFFER(SUCC(CURRENT)) SUCC(CURRENT)  :F(C4)\nLISTEM   N = 0\n         CURRENT = START\nL1       HOLD = HOLD CHAR(CURRENT)\nL2       OUTPUT = DIFFER(ASSOC(CURRENT)) SPC HOLD '  ' ASSOC(CURRENT)\n         CURRENT = DIFFER(SUCC(CURRENT)) SUCC(CURRENT)  :S(L1)\nBACKUP   CURRENT = DIFFER(ALT(CURRENT)) ALT(CURRENT)  :F(B1)\n         N = N + 1\n         $('STACK' N) = LINK(CURRENT)\n         HOLD LEN(1) RPOS(0) = CHAR(CURRENT)     :(L2)\nB1       Y = LINK(CURRENT)\n         IDENT(Y)                                :S(READA)\n         IDENT(Y,START) IDENT(ALT(Y),CURRENT)    :S(READA)\n         IDENT(Y,START) IDENT(ALT(Y))            :S(READA)\n         CURRENT = Y\n         HOLD DIFFER($('STACK' N),Y)  LEN(1) RPOS(0) =  :S(BACKUP)\n         N = N - 1                               :(B1)\nEND1     OUTPUT =\n         OUTPUT = '(ALL DATA PROCESSED)'\nEND\nABC\nABCD\nABCDE\nBCDEF\n$$\n$*\nELASTIC\nHAPPILY\nBOX\nFOX\nCARS\nGAITERS\nALL\nDUMP\nJUNE\nIN\n$$\n$*\nSISTER\nSUSIE\nSELLS\nSEA\nSHELLS\nBY\nTHE\nSEA\nSHORE\n$$\n$S\n$SH\nSOME\nSEA\nSHELLS\nSEND\nSAILORS\nSWIMMING\n$$\n$S\n$SE\n$*\n$$\nCATTLE\nCARP\nCAT\nGORGE\nMONSTER\nMONEY\nCAR\nDOG\nMETAL\nCAVE\nCAKE\nCAT\n$$\n$MON\n$M\n$C\n$CA\n$CAT\n$CATT\n$CAX\n$$\n./*\n-TITLE SPITBOL TEST PROGRAM #8 -- BRIDGE DEALER\n         DATA('CARD(NUM,NEXT)')\n*\n         OUTPUT('TITLE',6,'(14H1THIS IS HAND ,110A1)')\n         OUTPUT('DEALER',6,'(11H DEALER IS ,110A1)')\n         OUTPUT('SKIP',6,'(A1)')\n*\n         DEFINE('INSERT(LIST,CARD)TEMP')               :(INSERTEND)\n*\nINSERT   $LIST  =  IDENT($LIST)  CARD(NUM(CARD),NULL)  :S(RETURN)\n         $LIST  =  GT(NUM(CARD),NUM($LIST))  CARD(NUM(CARD),$LIST)\n.                                                      :S(RETURN)\n         TEMP  =  $LIST\nINS1     IDENT(NEXT(TEMP))                             :S(INS2)\n         NEXT(TEMP)  =  GT(NUM(CARD),NUM(NEXT(TEMP)))\n.                       CARD(NUM(CARD),NEXT(TEMP))     :S(RETURN)\n         TEMP  =  NEXT(TEMP)                           :(INS1)\nINS2     NEXT(TEMP)  =  CARD(NUM(CARD),NULL)           :(RETURN)\nINSERTEND\n*\n*\n         DEFINE('LINE(STR1,COL1,STR2,COL2)BL1,BL2')    :(LINEEND)\n*\nLINE     BL  LEN(COL1 - 1) . BL1\n         IDENT(STR2)                                   :S(LINE1)\n         BL  LEN(COL2 - (COL1 + SIZE(STR1))) . BL2\nLINE1    LINE  =  BL1  STR1  BL2  STR2                 :(RETURN)\nLINEEND\n*\n*\n         DEFINE('NTH(LIST,NUM)TEMP')                   :(NTHEND)\n*\nNTH      NTH  =  EQ(NUM,0)  $LIST                      :F(NTH1)\n         $LIST  =  NEXT($LIST)                         :(RETURN)\nNTH1     TEMP  =  $LIST\nNTH2     NUM  =  NUM - 1\n         NTH  =  EQ(NUM,0)  NEXT(TEMP)                 :S(NTH3)\n         TEMP  =  NEXT(TEMP)                           :(NTH2)\nNTH3     NEXT(TEMP)  =  NEXT(NEXT(TEMP))               :(RETURN)\nNTHEND\n*\n*\n         DEFINE('RANDOM(N)')                           :(RANDOMEND)\nRANDOM   RAN.VAR  =  RAN.VAR * 1061 + 3251\n         RAN.VAR  ARB  RPOS(5)  =\n         RANDOM  =  (RAN.VAR * N) / 100000             :(RETURN)\nRANDOMEND\n*\n*\n         DEFINE('SUITL(HAND,SUIT)')                    :(SUITLEND)\n*\nSUITL    SUITL  =  SUIT  '  '\nSUITL1   GT(NUM($HAND),$SUIT)                          :F(RETURN)\n         SUITL  =  SUITL  $(NUM($HAND) - $SUIT)\n         $HAND  =  DIFFER(NEXT($HAND))  NEXT($HAND) :S(SUITL1)F(RETURN)\nSUITLEND\n-EJECT\n*\n*                  CONSTANTS\n*\n         BL  =  '                                        '\n.               '                                        '\n         S  =  39\n         H  =  26\n         D  =  13\n         C  =  0\n         $1  =  2\n         $2  =  3\n         $3  =  4\n         $4  =  5\n         $5  =  6\n         $6  =  7\n         $7  =  8\n         $8  =  9\n         $9  =  10\n         $10  =  'J'\n         $11  =  'Q'\n         $12  =  'K'\n         $13  =  'A'\n         DEALSEQ  =  'NORTH,EAST,SOUTH,WEST,NORTH,'\n         RAN.VAR  =  157\n         DEALMAX  =  3\n         NTHDEAL  =\n         DEAL  =  'WEST'\nNEWDEAL  NTHDEAL  =  LT(NTHDEAL,DEALMAX)  NTHDEAL + 1  :F(END)\n         N  =  1\n         NORTH  =\n         EAST  =\n         SOUTH  =\n         WEST  =\n         DECK  =\nDLOOP    DECK  =  CARD(N,DECK)\n         N  =  LT(N,52)  N + 1                         :S(DLOOP)\n         DEALSEQ  DEAL  ','  BREAK(',') . DEAL         :F(ERR)\n         HAND  =  DEAL\n         N  =  52\nNLOOP    DEALSEQ  HAND  ','  BREAK(',') . HAND         :F(ERR)\n         INSERT(HAND,NTH('DECK',RANDOM(N)))\n         N  =  GT(N,1)  N - 1                          :S(NLOOP)\n-EJECT\n*\n*                  OUTPUT OF HAND\n*\n         TITLE  =  NTHDEAL\n         DEALER  =  DEAL\n         SKIP = '        '\n         OUTPUT  =  LINE('NORTH',40)\n         OUTPUT  =\n         OUTPUT  =  LINE(SUITL('NORTH','S'),40)\n         OUTPUT  =  LINE(SUITL('NORTH','H'),40)\n         OUTPUT  =  LINE(SUITL('NORTH','D'),40)\n         OUTPUT  =  LINE(SUITL('NORTH','C'),40)\n         SKIP = '        '\n         OUTPUT  =  LINE('WEST',20,'EAST',60)\n         OUTPUT  =\n         OUTPUT  =  LINE(SUITL('WEST','S'),20,\n.                        SUITL('EAST','S'),60)\n         OUTPUT  =  LINE(SUITL('WEST','H'),20,\n.                        SUITL('EAST','H'),60)\n         OUTPUT  =  LINE(SUITL('WEST','D'),20,\n.                        SUITL('EAST','D'),60)\n         OUTPUT  =  LINE(SUITL('WEST','C'),20,\n.                        SUITL('EAST','C'),60)\n         SKIP = '        '\n         OUTPUT  =  LINE('SOUTH',40)\n         OUTPUT  =\n         OUTPUT  =  LINE(SUITL('SOUTH','S'),40)\n         OUTPUT  =  LINE(SUITL('SOUTH','H'),40)\n         OUTPUT  =  LINE(SUITL('SOUTH','D'),40)\n         OUTPUT  =  LINE(SUITL('SOUTH','C'),40)\n.                                                      :(NEWDEAL)\nEND\n./*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTSBOL": {"ttr": 13317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x00\\x06\\x00\\x06\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "SPIT360"}, "text": "//.. JOB ....\n// EXEC PGM=SPITBOL,REGION=512K\n//STEPLIB   DD  DSN=SPITBOL.LOAD,DISP=SHR\n//SYSPRINT  DD  SYSOUT=A\n//SYSPUNCH  DD  DUMMY\n//SYSIN     DD  DSN=SPITBOL.SRC(TESTPGMS),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TFSV23": {"ttr": 13319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x012o\\x01\\x012o\"\\t\\x01\\x97\\x01\\x97\\x00\\x00\\xe2\\xd7\\xc9\\xe3\\xf3\\xf6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-22T00:00:00", "modifydate": "2001-11-22T22:09:00", "lines": 407, "newlines": 407, "modlines": 0, "user": "SPIT360"}, "text": "NAME SPITBOL OSINT                                         STD TF 2.3.1 01 OF 10\nVERIFY 1168 0000                                           STD TF 2.3.1 02 OF 10\nREPLACE 1168 0001                                          STD TF 2.3.1 03 OF 10\n*EPLACE 04C8 C414                                          STD TF 2.3.1 04 OF 10\n*EPLACE 04D6 F24B,F24B                                     STD TF 2.3.1 05 OF 10\nNAME SPITBOL SPITBOLR                                      STD TF 2.3.1 06 OF 10\nVERIFY 0B38 2026                                           STD TF 2.3.1 07 OF 10\nREPLACE 0B38 22CC                                          STD TF 2.3.1 08 OF 10\nVERIFY 0DE8 0000                                           STD TF 2.3.1 09 OF 10\nREPLACE 0DE8 5030,85C0,47F0,2026                           STD TF 2.3.1 10 OF 10\n\nNAME SPITPROG OSINT                                        LD  TF 2.3.1 01 OF 10\nVERIFY 1168 0000                                           LD  TF 2.3.1 02 OF 10\nREPLACE 1168 0001                                          LD  TF 2.3.1 03 OF 10\n*EPLACE 04C8 C414                                          LD  TF 2.3.1 04 OF 10\n*EPLACE 04D6 F24B,F24B                                     LD  TF 2.3.1 05 OF 10\nNAME SPITPROG SPITBLLR                                     LD  TF 2.3.1 06 OF 10\nVERIFY 0B38 2026                                           LD  TF 2.3.1 07 OF 10\nREPLACE 0B38 22CC                                          LD  TF 2.3.1 08 OF 10\nVERIFY 0DE8 0000                                           LD  TF 2.3.1 09 OF 10\nREPLACE 0DE8 5030,85C0,47F0,2026                           LD  TF 2.3.1 10 OF 10\n\nNAME SPITBOL SPITBOLF                                      STD TF 2.3.2 01 OF 19\nVERIFY 161E B026                                           STD TF 2.3.2 02 OF 19\nREPLACE 161E B024                                          STD TF 2.3.2 03 OF 19\nNAME SPITBOL SPITBOLX                                      STD TF 2.3.2 04 OF 19\nVERIFY 2724 5821                                           STD TF 2.3.2 05 OF 19\nREPLACE 2724 4550,EFAE                                     STD TF 2.3.2 06 OF 19\nVERIFY 2100 9547                                           STD TF 2.3.2 07 OF 19\nREPLACE 2100 47F0,EFB8                                     STD TF 2.3.2 08 OF 19\nNAME SPITBOL SPITBOLA                                      STD TF 2.3.2 09 OF 19\nVERIFY 0FAE 0000                                           STD TF 2.3.2 10 OF 19\nREPLACE 0FAE 5821,80F8,4120,2000,07F5                      STD TF 2.3.2 11 OF 19\nREPLACE 0FB8 9507,4000,4770,EFC4,4140,4002,9547,4000       STD TF 2.3.2 12 OF 19\nREPLACE 0FC8 47F0,B58A                                     STD TF 2.3.2 13 OF 19\nNAME SPITBOL SPITBOLR                                      STD TF 2.3.2 14 OF 19\nVERIFY 021E 0701                                           STD TF 2.3.2 15 OF 19\nREPLACE 021E 07F0                                          STD TF 2.3.2 16 OF 19\nNAME SPITBOL OSINT                                         STD TF 2.3.2 17 OF 19\nVERIFY 116A 0000                                           STD TF 2.3.2 18 OF 19\nREPLACE 116A 0002                                          STD TF 2.3.2 19 OF 19\n\nNAME SPITPROG SPITBLLF                                     LD  TF 2.3.2 01 OF 19\nVERIFY 161E B026                                           LD  TF 2.3.2 02 OF 19\nREPLACE 161E B024                                          LD  TF 2.3.2 03 OF 19\nNAME SPITPROG SPITBLLX                                     LD  TF 2.3.2 04 OF 19\nVERIFY 2724 5821                                           LD  TF 2.3.2 05 OF 19\nREPLACE 2724 4550,EFAE                                     LD  TF 2.3.2 06 OF 19\nVERIFY 2100 9547                                           LD  TF 2.3.2 07 OF 19\nREPLACE 2100 47F0,EFB8                                     LD  TF 2.3.2 08 OF 19\nNAME SPITPROG SPITBLLA                                     LD  TF 2.3.2 09 OF 19\nVERIFY 0FAE 0000                                           LD  TF 2.3.2 10 OF 19\nREPLACE 0FAE 5821,80F8,4120,2000,07F5                      LD  TF 2.3.2 11 OF 19\nREPLACE 0FB8 9507,4000,4770,EFC4,4140,4002,9547,4000       LD  TF 2.3.2 12 OF 19\nREPLACE 0FC8 47F0,B58A                                     LD  TF 2.3.2 13 OF 19\nNAME SPITPROG SPITBLLR                                     LD  TF 2.3.2 14 OF 19\nVERIFY 021E 0701                                           LD  TF 2.3.2 15 OF 19\nREPLACE 021E 07F0                                          LD  TF 2.3.2 16 OF 19\nNAME SPITPROG OSINT                                        LD  TF 2.3.2 17 OF 19\nVERIFY 116A 0000                                           LD  TF 2.3.2 18 OF 19\nREPLACE 116A 0002                                          LD  TF 2.3.2 19 OF 19\n\nNAME SPITBOL OSINT                                         STD TF 2.3.3 01 OF 76\n*ERIFY 0950 4770                                           STD TF 2.3.3 02 OF 76\n*EPLACE 0950 47F0,C0EC                                     STD TF 2.3.3 03 OF 76\n*ERIFY 10EC 0000                                           STD TF 2.3.3 04 OF 76\n*EPLACE 10EC 4780,B954,9104,A024,4770,B954,47F0,B958       STD TF 2.3.3 05 OF 76\nVERIFY 116C 0000                                           STD TF 2.3.3 06 OF 76\nREPLACE 116C 0003                                          STD TF 2.3.3 07 OF 76\nNAME SPITBOL SPITBOLC                                      STD TF 2.3.3 08 OF 76\nVERIFY 0A44 D008                                           STD TF 2.3.3 09 OF 76\nREPLACE 0A44 D00A                                          STD TF 2.3.3 10 OF 76\nVERIFY 0A36 D207,D000,AEA6                                 STD TF 2.3.3 11 OF 76\nREPLACE 0A36 D209,D000,BF00                                STD TF 2.3.3 12 OF 76\nVERIFY 2F00 0000                                           STD TF 2.3.3 13 OF 76\nREPLACE 2F00 05D0,3E02,07F0,50D0,82F8                      STD TF 2.3.3 14 OF 76\nVERIFY 2F0A 0000                                           STD TF 2.3.3 15 OF 76\nREPLACE 2F0A 9200,83D1,9200,83B0,9200,83B3,07F2            STD TF 2.3.3 16 OF 76\nVERIFY 01AC 9200                                           STD TF 2.3.3 17 OF 76\nREPLACE 01AC 4520,BF0A                                     STD TF 2.3.3 18 OF 76\nVERIFY 2862 0512                                           STD TF 2.3.3 19 OF 76\nREPLACE 2862 4540,BF18,0700                                STD TF 2.3.3 20 OF 76\nVERIFY 2F18 0000                                           STD TF 2.3.3 21 OF 76\nREPLACE 2F18 0512,47F0,B8F2,4900,BFAE,07F4                 STD TF 2.3.3 22 OF 76\nVERIFY 25F6 910F,5001                                      STD TF 2.3.3 23 OF 76\nREPLACE 25F6 47F0,B5CC,41E0,BD83,47F0,BBB8                 STD TF 2.3.3 24 OF 76\nVERIFY 29A4 0579                                           STD TF 2.3.3 25 OF 76\nREPLACE 29A4 47F0,B5FA                                     STD TF 2.3.3 26 OF 76\nNAME SPITBOL SPITBOLF                                      STD TF 2.3.3 27 OF 76\nVERIFY 0624 3034                                           STD TF 2.3.3 28 OF 76\nREPLACE 0624 3038                                          STD TF 2.3.3 29 OF 76\nVERIFY 063E 0028                                           STD TF 2.3.3 30 OF 76\nREPLACE 063E 002C,5000,3008,4100,0038,5000,3004,D72B       STD TF 2.3.3 31 OF 76\nVERIFY 1A9E 6019,6019                                      STD TF 2.3.3 32 OF 76\nREPLACE 1AA2 07FD                                          STD TF 2.3.3 33 OF 76\nVERIFY 1DD8 E3BE                                           STD TF 2.3.3 34 OF 76\nREPLACE 1DD8 EFD2                                          STD TF 2.3.3 35 OF 76\nNAME SPITBOL SPITBOLX                                      STD TF 2.3.3 36 OF 76\nVERIFY 0E96 3840                                           STD TF 2.3.3 37 OF 76\nREPLACE 0E96 7000,8300,5810,8300,5B10,8300,7060,8300       STD TF 2.3.3 38 OF 76\nREPLACE 0EA6 5A10,82D0,5010,82D0,7800,EE74,7000,828C       STD TF 2.3.3 39 OF 76\nREPLACE 0EB6 1915,47D0,20C4,05DE,0B05,5050,82C0,07FD       STD TF 2.3.3 40 OF 76\nNAME SPITBOL SPITBOLR                                      STD TF 2.3.3 41 OF 76\nVERIFY 07C6 0800                                           STD TF 2.3.3 42 OF 76\nREPLACE 07C6 0400                                          STD TF 2.3.3 43 OF 76\nVERIFY 0774 5820                                           STD TF 2.3.3 44 OF 76\nREPLACE 0774 47F0,F6D6                                     STD TF 2.3.3 45 OF 76\nVERIFY 0DF0 0000                                           STD TF 2.3.3 46 OF 76\nREPLACE 0DF0 41A0,F06C,950C,8053,4780,F060,D501,8052       STD TF 2.3.3 47 OF 76\nREPLACE 0E00 F6B0,4780,F060,5820,F682,0512                 STD TF 2.3.3 48 OF 76\nVERIFY 00F4 4670                                           STD TF 2.3.3 49 OF 76\nREPLACE 00F4 47F0                                          STD TF 2.3.3 50 OF 76\nVERIFY 002A 0701                                           STD TF 2.3.3 51 OF 76\nREPLACE 002A 07F0                                          STD TF 2.3.3 52 OF 76\nVERIFY 0244 601A                                           STD TF 2.3.3 53 OF 76\nREPLACE 0244 600A,47F0,600A                                STD TF 2.3.3 54 OF 76\nNAME SPITBOL SPITBOLX                                      STD TF 2.3.3 55 OF 76\nVERIFY 2D10 5860                                           STD TF 2.3.3 56 OF 76\nREPLACE 2D10 5840                                          STD TF 2.3.3 57 OF 76\nVERIFY 2306 B55E                                           STD TF 2.3.3 58 OF 76\nREPLACE 2306 EFF2                                          STD TF 2.3.3 59 OF 76\nVERIFY 1048 B12C                                           STD TF 2.3.3 60 OF 76\nREPLACE 1048 EFCC                                          STD TF 2.3.3 61 OF 76\nNAME SPITBOL SPITBOLA                                      STD TF 2.3.3 62 OF 76\nVERIFY 0622 E62E                                           STD TF 2.3.3 63 OF 76\nREPLACE 0622 E5FC                                          STD TF 2.3.3 64 OF 76\nVERIFY 0FE8 0000                                           STD TF 2.3.3 65 OF 76\nREPLACE 0FE8 5000,82DC,98CD,82E0,07F1,58F0,8318,47F0,B55E  STD TF 2.3.3 66 OF 76\nVERIFY 059E 4710,E5AE                                      STD TF 2.3.3 67 OF 76\nREPLACE 059E 47F0,EFD8                                     STD TF 2.3.3 68 OF 76\nREPLACE 0FD8 4710,E5AE,9110,D004,47E0,E5A2,47F0,E5AE       STD TF 2.3.3 69 OF 76\nVERIFY 0FCC 0000                                           STD TF 2.3.3 70 OF 76\nREPLACE 0FCC 1815,47F0,B12C                                STD TF 2.3.3 71 OF 76\nVERIFY 0FD2 0000                                           STD TF 2.3.3 72 OF 76\nREPLACE 0FD2 41D0,E3BE,07F7                                STD TF 2.3.3 73 OF 76\nNAME SPITBOL SPITBOLP                                      STD TF 2.3.3 74 OF 76\nVERIFY 073E 7316                                           STD TF 2.3.3 75 OF 76\nREPLACE 073E F316                                          STD TF 2.3.3 76 OF 76\n\nNAME SPITPROG OSINT                                        LD  TF 2.3.3 01 OF 68\nVERIFY 0950 4770                                           LD  TF 2.3.3 02 OF 68\nREPLACE 0950 47F0,C0EC                                     LD  TF 2.3.3 03 OF 68\n*ERIFY 10EC 0000                                           LD  TF 2.3.3 04 OF 68\n*EPLACE 10EC 4780,B954,9104,A024,4770,B954,47F0,B958       LD  TF 2.3.3 05 OF 68\nVERIFY 116C 0000                                           LD  TF 2.3.3 06 OF 68\nREPLACE 116C 0003                                          LD  TF 2.3.3 07 OF 68\nNAME SPITPROG SPITBLLC                                     LD  TF 2.3.3 08 OF 68\nVERIFY 085C D008                                           LD  TF 2.3.3 09 OF 68\nREPLACE 085C D00A                                          LD  TF 2.3.3 10 OF 68\nVERIFY 084E D207,D000,AC7E                                 LD  TF 2.3.3 11 OF 68\nREPLACE 084E D209,D000,AF68                                LD  TF 2.3.3 12 OF 68\nVERIFY 1F68 0000                                           LD  TF 2.3.3 13 OF 68\nREPLACE 1F68 05D0,3E02,07F0,50D0,82F8                      LD  TF 2.3.3 14 OF 68\nVERIFY 1F72 0000                                           LD  TF 2.3.3 15 OF 68\nREPLACE 1F72 9200,83D1,9200,83B0,9200,83B3,07F2            LD  TF 2.3.3 16 OF 68\nVERIFY 007A 9200                                           LD  TF 2.3.3 17 OF 68\nREPLACE 007A 4520,AF72                                     LD  TF 2.3.3 18 OF 68\nNAME SPITPROG SPITBLLF                                     LD  TF 2.3.3 19 OF 68\nVERIFY 0624 3034                                           LD  TF 2.3.3 20 OF 68\nREPLACE 0624 3038                                          LD  TF 2.3.3 21 OF 68\nVERIFY 063E 0028                                           LD  TF 2.3.3 22 OF 68\nREPLACE 063E 002C,5000,3008,4100,0038,5000,3004,D72B       LD  TF 2.3.3 23 OF 68\nVERIFY 1A9E 6019,6019                                      LD  TF 2.3.3 24 OF 68\nREPLACE 1AA2 07FD                                          LD  TF 2.3.3 25 OF 68\nVERIFY 1DD8 E3BE                                           LD  TF 2.3.3 26 OF 68\nREPLACE 1DD8 EFD2                                          LD  TF 2.3.3 27 OF 68\nNAME SPITPROG SPITBLLX                                     LD  TF 2.3.3 28 OF 68\nVERIFY 0E96 3840                                           LD  TF 2.3.3 29 OF 68\nREPLACE 0E96 7000,8300,5810,8300,5B10,8300,7060,8300       LD  TF 2.3.3 30 OF 68\nREPLACE 0EA6 5A10,82D0,5010,82D0,7800,EE74,7000,828C       LD  TF 2.3.3 31 OF 68\nREPLACE 0EB6 1915,47D0,20C4,05DE,0B05,5050,82C0,07FD       LD  TF 2.3.3 32 OF 68\nNAME SPITPROG SPITBLLR                                     LD  TF 2.3.3 33 OF 68\nVERIFY 07C6 0800                                           LD  TF 2.3.3 34 OF 68\nREPLACE 07C6 0400                                          LD  TF 2.3.3 35 OF 68\nVERIFY 0774 5820                                           LD  TF 2.3.3 36 OF 68\nREPLACE 0774 47F0,F6D6                                     LD  TF 2.3.3 37 OF 68\nVERIFY 0DF0 0000                                           LD  TF 2.3.3 38 OF 68\nREPLACE 0DF0 41A0,F06C,950C,8053,4780,F060,D501,8052       LD  TF 2.3.3 39 OF 68\nREPLACE 0E00 F6B0,4780,F060,5820,F682,0512                 LD  TF 2.3.3 40 OF 68\nVERIFY 00F4 4670                                           LD  TF 2.3.3 41 OF 68\nREPLACE 00F4 47F0                                          LD  TF 2.3.3 42 OF 68\nVERIFY 002A 0701                                           LD  TF 2.3.3 43 OF 68\nREPLACE 002A 07F0                                          LD  TF 2.3.3 44 OF 68\nVERIFY 0244 601A                                           LD  TF 2.3.3 45 OF 68\nREPLACE 0244 600A,47F0,600A                                LD  TF 2.3.3 46 OF 68\nNAME SPITPROG SPITBLLX                                     LD  TF 2.3.3 47 OF 68\nVERIFY 2AF2 5860                                           LD  TF 2.3.3 48 OF 68\nREPLACE 2AF2 5840                                          LD  TF 2.3.3 49 OF 68\nVERIFY 2306 B55E                                           LD  TF 2.3.3 50 OF 68\nREPLACE 2306 EFF2                                          LD  TF 2.3.3 51 OF 68\nVERIFY 1048 B12C                                           LD  TF 2.3.3 52 OF 68\nREPLACE 1048 EFCC                                          LD  TF 2.3.3 53 OF 68\nNAME SPITPROG SPITBLLA                                     LD  TF 2.3.3 54 OF 68\nVERIFY 0622 E62E                                           LD  TF 2.3.3 55 OF 68\nREPLACE 0622 E5FC                                          LD  TF 2.3.3 56 OF 68\nVERIFY 0FE8 0000                                           LD  TF 2.3.3 57 OF 68\nREPLACE 0FE8 5000,82DC,98CD,82E0,07F1,58F0,8318,47F0,B55E  LD  TF 2.3.3 58 OF 68\nVERIFY 059E 4710,E5AE                                      LD  TF 2.3.3 59 OF 68\nREPLACE 059E 47F0,EFD8                                     LD  TF 2.3.3 60 OF 68\nREPLACE 0FD8 4710,E5AE,9110,D004,47E0,E5A2,47F0,E5AE       LD  TF 2.3.3 61 OF 68\nVERIFY 0FCC 0000                                           LD  TF 2.3.3 62 OF 68\nREPLACE 0FCC 1815,47F0,B12C                                LD  TF 2.3.3 63 OF 68\nVERIFY 0FD2 0000                                           LD  TF 2.3.3 64 OF 68\nREPLACE 0FD2 41D0,E3BE,07F7                                LD  TF 2.3.3 65 OF 68\nNAME SPITPROG SPITBLLP                                     LD  TF 2.3.3 66 OF 68\nVERIFY 073E 7316                                           LD  TF 2.3.3 67 OF 68\nREPLACE 073E F316                                          LD  TF 2.3.3 68 OF 68\n\nNAME SPITBOL OSINT                                         STD TF 2.3.4 01 OF 71\n*ERIFY 02F6 5D00                                           STD TF 2.3.4 02 OF 71\n*EPLACE 02F6 4700                                          STD TF 2.3.4 03 OF 71\n*ERIFY 05B8 3B9A                                           STD TF 2.3.4 04 OF 71\n*EPLACE 05B8 0000,9600                                     STD TF 2.3.4 05 OF 71\nVERIFY 116E 0000                                           STD TF 2.3.4 06 OF 71\nREPLACE 116E 0004                                          STD TF 2.3.4 07 OF 71\nNAME SPITBOL SPITBOLC                                      STD TF 2.3.4 08 OF 71\nVERIFY 02A4 1B00                                           STD TF 2.3.4 09 OF 71\nREPLACE 02A4 47F0,97C8                                     STD TF 2.3.4 10 OF 71\nVERIFY 02A8 D000                                           STD TF 2.3.4 11 OF 71\nREPLACE 02A8 5010,85E8,47F0,92E2                           STD TF 2.3.4 12 OF 71\nVERIFY 0452 9500                                           STD TF 2.3.4 13 OF 71\nREPLACE 0452 9501,862B,4770,9430,9500,835E,4770,947C       STD TF 2.3.4 14 OF 71\nVERIFY 06F4 92A0                                           STD TF 2.3.4 15 OF 71\nREPLACE 06F4 92A8                                          STD TF 2.3.4 16 OF 71\nVERIFY 29B0 4120                                           STD TF 2.3.4 17 OF 71\nREPLACE 29B0 5070,83D8,50F0,83DC,4120,BB1C                 STD TF 2.3.4 18 OF 71\nVERIFY 29EC B9B0                                           STD TF 2.3.4 19 OF 71\nREPLACE 29EC B9B8                                          STD TF 2.3.4 20 OF 71\nVERIFY 2A00 B848                                           STD TF 2.3.4 21 OF 71\nREPLACE 2A00 BB14                                          STD TF 2.3.4 22 OF 71\nNAME SPITBOL SPITBOLR                                      STD TF 2.3.4 23 OF 71\nVERIFY 0B32 9101                                           STD TF 2.3.4 24 OF 71\nREPLACE 0B32 1803,9101,8178,47E0,202C,50F0,81FC,58F0       STD TF 2.3.4 25 OF 71\nVERIFY 0B42 4150                                           STD TF 2.3.4 26 OF 71\nREPLACE 0B42 85F0,5800,8190,1A05,190F,4740,2052,1A65       STD TF 2.3.4 27 OF 71\nREPLACE 0B52 5060,8194                                     STD TF 2.3.4 28 OF 71\nVERIFY 0B6C 2026                                           STD TF 2.3.4 29 OF 71\nREPLACE 0B6C 2004                                          STD TF 2.3.4 30 OF 71\nNAME SPITBOL SPITBOLP                                      STD TF 2.3.4 31 OF 71\nVERIFY 0002 45A0                                           STD TF 2.3.4 32 OF 71\nREPLACE 0002 41D0,D04C,07FD                                STD TF 2.3.4 33 OF 71\nNAME SPITBOL SPITBOLX                                      STD TF 2.3.4 34 OF 71\nVERIFY 00D4 9598                                           STD TF 2.3.4 35 OF 71\nREPLACE 00D4 9108,1000,4710,D0E8,47F0,D0E4                 STD TF 2.3.4 36 OF 71\nVERIFY 0248 45C0                                           STD TF 2.3.4 37 OF 71\nREPLACE 0248 7060,8304,4190,83C8,45C0,D3C4                 STD TF 2.3.4 38 OF 71\nVERIFY 0EA0 8300,7060                                      STD TF 2.3.4 39 OF 71\nREPLACE 0EA0 828C                                          STD TF 2.3.4 40 OF 71\nVERIFY 2170 EAA8                                           STD TF 2.3.4 41 OF 71\nREPLACE 2170 EAAC                                          STD TF 2.3.4 42 OF 71\nVERIFY 2222 98CD                                           STD TF 2.3.4 43 OF 71\nREPLACE 2222 7960,82E4,4780,E04C                           STD TF 2.3.4 44 OF 71\nVERIFY 2230 EAA8                                           STD TF 2.3.4 45 OF 71\nREPLACE 2230 EAAC                                          STD TF 2.3.4 46 OF 71\nVERIFY 2232 12CC                                           STD TF 2.3.4 47 OF 71\nREPLACE 2232 47F0,EFE8                                     STD TF 2.3.4 48 OF 71\nVERIFY 229E 9200                                           STD TF 2.3.4 49 OF 71\nREPLACE 229E D7FF,8638,8638,0700,58F0,8318,94F7,8178       STD TF 2.3.4 50 OF 71\nVERIFY 22D0 58F0                                           STD TF 2.3.4 51 OF 71\nREPLACE 22D0 7060,F7E0                                     STD TF 2.3.4 52 OF 71\nVERIFY 2914 EAA8                                           STD TF 2.3.4 53 OF 71\nREPLACE 2914 EAAC                                          STD TF 2.3.4 54 OF 71\nNAME SPITBOL SPITBOLA                                      STD TF 2.3.4 55 OF 71\nVERIFY 004C 1000                                           STD TF 2.3.4 56 OF 71\nREPLACE 004C 4510,E014,0803                                STD TF 2.3.4 57 OF 71\nVERIFY 011E E0B8                                           STD TF 2.3.4 58 OF 71\nREPLACE 011E E0B4                                          STD TF 2.3.4 59 OF 71\nVERIFY 04A6 B288                                           STD TF 2.3.4 60 OF 71\nREPLACE 04A6 B28E                                          STD TF 2.3.4 61 OF 71\nVERIFY 060E EAA8                                           STD TF 2.3.4 62 OF 71\nREPLACE 060E EAAC                                          STD TF 2.3.4 63 OF 71\nVERIFY 0AA6 1881                                           STD TF 2.3.4 64 OF 71\nREPLACE 0AA6 0700,47F0,E306,7800,8180                      STD TF 2.3.4 65 OF 71\nREPLACE 0EAC 0700,0000                                     STD TF 2.3.4 66 OF 71\nVERIFY 0FE8 5000                                           STD TF 2.3.4 67 OF 71\nREPLACE 0FE8 98CD,82E0,7060,82E4,07FC                      STD TF 2.3.4 68 OF 71\nNAME SPITBOL SPITBOLF                                      STD TF 2.3.4 69 OF 71\nVERIFY 0922 E050                                           STD TF 2.3.4 70 OF 71\nREPLACE 0922 EEAC                                          STD TF 2.3.4 71 OF 71\n\nNAME SPITPROG OSINT                                        LD  TF 2.3.4 01 OF 69\n*ERIFY 02F6 5D00                                           LD  TF 2.3.4 02 OF 69\n*EPLACE 02F6 4700                                          LD  TF 2.3.4 03 OF 69\n*ERIFY 05B8 3B9A                                           LD  TF 2.3.4 04 OF 69\n*EPLACE 05B8 0000,9600                                     LD  TF 2.3.4 05 OF 69\nVERIFY 116E 0000                                           LD  TF 2.3.4 06 OF 69\nREPLACE 116E 0004                                          LD  TF 2.3.4 07 OF 69\nNAME SPITPROG SPITBLLC                                     LD  TF 2.3.4 08 OF 69\nVERIFY 0170 1B00                                           LD  TF 2.3.4 09 OF 69\nREPLACE 0170 47F0,964E                                     LD  TF 2.3.4 10 OF 69\nVERIFY 0174 D000                                           LD  TF 2.3.4 11 OF 69\nREPLACE 0174 5010,85E8,47F0,91AE                           LD  TF 2.3.4 12 OF 69\nVERIFY 05C0 916C                                           LD  TF 2.3.4 13 OF 69\nREPLACE 05C0 9174                                          LD  TF 2.3.4 14 OF 69\nVERIFY 1E3C 47E0                                           LD  TF 2.3.4 15 OF 69\nREPLACE 1E3C 4710,C18E,9118,2000,4780,C1A8,4740,C18E       LD  TF 2.3.4 16 OF 69\nVERIFY 1E4C 5000                                           LD  TF 2.3.4 17 OF 69\nREPLACE 1E4C 4110,2010,05D4,47F0,C1A8                      LD  TF 2.3.4 18 OF 69\nVERIFY 1E56 2000                                           LD  TF 2.3.4 19 OF 69\nREPLACE 1E56 4110,200C,05D4,4770,C1A8,5B10,80DC,5A10       LD  TF 2.3.4 20 OF 69\nVERIFY 1E66 47F0                                           LD  TF 2.3.4 21 OF 69\nREPLACE 1E66 C21C,5010,200C,4700                           LD  TF 2.3.4 22 OF 69\nNAME SPITPROG SPITBLLR                                     LD  TF 2.3.4 23 OF 69\nVERIFY 0B32 9101                                           LD  TF 2.3.4 24 OF 69\nREPLACE 0B32 1803,9101,8178,47E0,202C,50F0,81FC,58F0       LD  TF 2.3.4 25 OF 69\nVERIFY 0B42 4150                                           LD  TF 2.3.4 26 OF 69\nREPLACE 0B42 85F0,5800,8190,1A05,190F,4740,2052,1A65       LD  TF 2.3.4 27 OF 69\nREPLACE 0B52 5060,8194                                     LD  TF 2.3.4 28 OF 69\nVERIFY 0B6C 2026                                           LD  TF 2.3.4 29 OF 69\nREPLACE 0B6C 2004                                          LD  TF 2.3.4 30 OF 69\nNAME SPITPROG SPITBLLP                                     LD  TF 2.3.4 31 OF 69\nVERIFY 0002 45A0                                           LD  TF 2.3.4 32 OF 69\nREPLACE 0002 41D0,D04C,07FD                                LD  TF 2.3.4 33 OF 69\nNAME SPITPROG SPITBLLX                                     LD  TF 2.3.4 34 OF 69\nVERIFY 00D4 9598                                           LD  TF 2.3.4 35 OF 69\nREPLACE 00D4 9108,1000,4710,D0E8,47F0,D0E4                 LD  TF 2.3.4 36 OF 69\nVERIFY 0248 45C0                                           LD  TF 2.3.4 37 OF 69\nREPLACE 0248 7060,8304,4190,83C8,45C0,D3C4                 LD  TF 2.3.4 38 OF 69\nVERIFY 0EA0 8300,7060                                      LD  TF 2.3.4 39 OF 69\nREPLACE 0EA0 828C                                          LD  TF 2.3.4 40 OF 69\nVERIFY 2170 EAA8                                           LD  TF 2.3.4 41 OF 69\nREPLACE 2170 EAAC                                          LD  TF 2.3.4 42 OF 69\nVERIFY 2222 98CD                                           LD  TF 2.3.4 43 OF 69\nREPLACE 2222 7960,82E4,4780,E04C                           LD  TF 2.3.4 44 OF 69\nVERIFY 2230 EAA8                                           LD  TF 2.3.4 45 OF 69\nREPLACE 2230 EAAC                                          LD  TF 2.3.4 46 OF 69\nVERIFY 2232 12CC                                           LD  TF 2.3.4 47 OF 69\nREPLACE 2232 47F0,EFE8                                     LD  TF 2.3.4 48 OF 69\nVERIFY 229E 9200                                           LD  TF 2.3.4 49 OF 69\nREPLACE 229E D7FF,8638,8638,0700,58F0,8318,94F7,8178       LD  TF 2.3.4 50 OF 69\nVERIFY 22D0 58F0                                           LD  TF 2.3.4 51 OF 69\nREPLACE 22D0 7060,F7E0                                     LD  TF 2.3.4 52 OF 69\nNAME SPITPROG SPITBLLA                                     LD  TF 2.3.4 53 OF 69\nVERIFY 004C 1000                                           LD  TF 2.3.4 54 OF 69\nREPLACE 004C 4510,E014,0803                                LD  TF 2.3.4 55 OF 69\nVERIFY 011E E0B8                                           LD  TF 2.3.4 56 OF 69\nREPLACE 011E E0B4                                          LD  TF 2.3.4 57 OF 69\nVERIFY 04A6 B288                                           LD  TF 2.3.4 58 OF 69\nREPLACE 04A6 B28E                                          LD  TF 2.3.4 59 OF 69\nVERIFY 060E EAA8                                           LD  TF 2.3.4 60 OF 69\nREPLACE 060E EAAC                                          LD  TF 2.3.4 61 OF 69\nVERIFY 0AA6 1881                                           LD  TF 2.3.4 62 OF 69\nREPLACE 0AA6 0700,47F0,E306,7800,8180                      LD  TF 2.3.4 63 OF 69\nREPLACE 0EAC 0700,0000                                     LD  TF 2.3.4 64 OF 69\nVERIFY 0FE8 5000                                           LD  TF 2.3.4 65 OF 69\nREPLACE 0FE8 98CD,82E0,7060,82E4,07FC                      LD  TF 2.3.4 66 OF 69\nNAME SPITPROG SPITBLLF                                     LD  TF 2.3.4 67 OF 69\nVERIFY 0922 E050                                           LD  TF 2.3.4 68 OF 69\nREPLACE 0922 EEAC                                          LD  TF 2.3.4 69 OF 69\n\nNAME SPITBOL OSINT                                         STD TF 2.3.5 01 OF 23\nVERIFY 1170 0000                                           STD TF 2.3.5 02 OF 23\nREPLACE 1170 0005                                          STD TF 2.3.5 03 OF 23\nNAME SPITBOL SPITBOLX                                      STD TF 2.3.5 04 OF 23\nVERIFY 02B0 9867                                           STD TF 2.3.5 05 OF 23\nREPLACE 02B0 7060,830C,47F0,D204                           STD TF 2.3.5 06 OF 23\nVERIFY 0250 45C0,D3C4                                      STD TF 2.3.5 07 OF 23\nREPLACE 0250 4700                                          STD TF 2.3.5 08 OF 23\nVERIFY 0AA8 50D0                                           STD TF 2.3.5 09 OF 23\nREPLACE 0AA8 9845,83C8                                     STD TF 2.3.5 10 OF 23\nVERIFY 0AC2 7060                                           STD TF 2.3.5 11 OF 23\nREPLACE 0AC2 4140,0000,45D0,EA5A,58D0,82DC,9045,83C8       STD TF 2.3.5 12 OF 23\nREPLACE 0AD2 47F0,7012                                     STD TF 2.3.5 13 OF 23\nNAME SPITBOL SPITBOLR                                      STD TF 2.3.5 14 OF 23\nVERIFY 0C50 4160                                           STD TF 2.3.5 15 OF 23\nREPLACE 0C50 4100,0800,1B60,5460,229C,5850,818C,5060       STD TF 2.3.5 16 OF 23\nREPLACE 0C60 818C,1B56,5840,8188,1864,1B65,5060,8188       STD TF 2.3.5 17 OF 23\nREPLACE 0C70 5A00,8190,0650,1906,4740,20CA,47F0,2168       STD TF 2.3.5 18 OF 23\nNAME SPITBOL SPITBOLC                                      STD TF 2.3.5 19 OF 23\nVERIFY 001E 1B00                                           STD TF 2.3.5 20 OF 23\nREPLACE 001E 9201,87B4                                     STD TF 2.3.5 21 OF 23\nVERIFY 00A0 9201                                           STD TF 2.3.5 22 OF 23\nREPLACE 00A0 4100,8522,5000,8368                           STD TF 2.3.5 23 OF 23\n\nNAME SPITPROG SPITBLLF                                     LD  TF 2.3.5 01 OF 13\nVERIFY 1170 0000                                           LD  TF 2.3.5 02 OF 13\nREPLACE 1170 0005                                          LD  TF 2.3.5 03 OF 13\nNAME SPITPROG SPITBLLX                                     LD  TF 2.3.5 04 OF 13\nVERIFY 02B0 9867                                           LD  TF 2.3.5 05 OF 13\nREPLACE 02B0 7060,830C,47F0,D204                           LD  TF 2.3.5 06 OF 13\nVERIFY 0250 45C0,D3C4                                      LD  TF 2.3.5 07 OF 13\nREPLACE 0250 4700                                          LD  TF 2.3.5 08 OF 13\nVERIFY 0AA8 50D0                                           LD  TF 2.3.5 09 OF 13\nREPLACE 0AA8 9845,83C8                                     LD  TF 2.3.5 10 OF 13\nVERIFY 0AC2 7060                                           LD  TF 2.3.5 11 OF 13\nREPLACE 0AC2 4140,0000,45D0,EA5A,58D0,82DC,9045,83C8       LD  TF 2.3.5 12 OF 13\nREPLACE 0AD2 47F0,7012                                     LD  TF 2.3.5 13 OF 13\n\nNAME SPITBOL OSINT                                         STD TF 2.3.6 01 OF 12\nVERIFY 1172 0000                                           STD TF 2.3.6 02 OF 12\nREPLACE 1172 0006                                          STD TF 2.3.6 03 OF 12\nNAME SPITBOL SPITBOLC                                      STD TF 2.3.6 04 OF 12\nVERIFY 0034 BF94                                           STD TF 2.3.6 05 OF 12\nREPLACE 0034 BF34                                          STD TF 2.3.6 06 OF 12\nNAME SPITBOL SPITBOLR                                      STD TF 2.3.6 07 OF 12\nVERIFY 0C74 0650                                           STD TF 2.3.6 08 OF 12\nREPLACE 0C74 5850,818C,1B56,0650,1906,4740,20CA,0700       STD TF 2.3.6 09 OF 12\nNAME SPITBOL SPITBOLP                                      STD TF 2.3.6 10 OF 12\nVERIFY 0604 2000                                           STD TF 2.3.6 11 OF 12\nREPLACE 0604 2006                                          STD TF 2.3.6 12 OF 12\n\nNAME SPITPROG OSINT                                        LD  TF 2.3.6 01 OF  6\nVERIFY 1172 0000                                           LD  TF 2.3.6 02 OF  6\nREPLACE 1172 0006                                          LD  TF 2.3.6 03 OF  6\nNAME SPITPROG SPITBLLP                                     LD  TF 2.3.6 04 OF  6\nVERIFY 0604 2000                                           LD  TF 2.3.6 05 OF  6\nREPLACE 0604 2006                                          LD  TF 2.3.6 06 OF  6\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT401/FILE401.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT401", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}