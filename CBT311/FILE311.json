{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011720000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 7407036, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE311.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 7407036, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 7407036, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE311.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00r\\x07'", "DS1TRBAL": "b'r\\xe2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02-\\x00\\x00\\x024\\x00\\t\\x00s'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x046\\x00\\x00\\x01\\x021\\x1f\\x01\\x021\\x1f\\x11\\x02\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf4@@@'", "ispf": {"version": "04.54", "flags": 0, "createdate": "2002-11-07T00:00:00", "modifydate": "2002-11-07T11:02:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-454"}, "text": "REGULAR CBT TAPE - VERSION 454    FILE:  311\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT454.FILE311\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 49 MEMBERS COUNTED; CUMULATIVE SIZE IS 69,907 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/07/02    11:02:29    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$README": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00)\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18 \\x00*\\x002\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:20:29", "lines": 42, "newlines": 50, "modlines": 0, "user": "IBMUSER"}, "text": " This CBT file was generated by David Alcock on 2002-11-02\n --------------------------------------------------------------\n\n The contents of this file are FREEWARE. Use at your own risk. It\n is provided for your enjoyment and neither David Alcock or his\n employer provides any warranty for their use.  I'd like to hear how\n they work on your system:\n\n    David Alcock :: dave@planetmvs.com\n\n Updates of the contents of the CBT file may also be posted to this\n URL on the Internet:\n\n    http://www.planetmvs.com/\n\n Replace \"ibmuser\" for your userid when found in this file.\n\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n Types of files in member $INDEX\n\n - PDS Unload...Contains input to utilities IEBUPDTE (IBM) or\n                PDSLOAD (CBT tape).  I recommend using PDSLOAD for the\n                ISPF stats.  The PDSLOAD program  can be found at\n\n                   http://www.cbttape.org/ftp/cbt/CBT093.zip\n\n                See sample job $PDSLOAD for doing this via PDSLOAD\n\n - Text.........Just plain text\n\n - TSO xmit.....This member is in TSO TRANSMIT format so that the\n                variable blocked source could be transferred in a\n                LRECL=80 file.  You will need to copy this dataset to a\n                LRECL=80 BLKSIZE=80 RECFM=F file and then use this\n                command to retrieve the members:\n\n                   RECEIVE INDATASET(CBTxxx.FILE311.PDS(member))\n\n                Hint: In ISPF 3.4, you can do this:\n\n                   RECEIVE INDATASET(/(member))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CHANGES": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x0f\\x00\\x17\\x00\\x99\\x06\\x0f\\x01\\x020o\\x198\\x00O\\x00>\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.15", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T19:38:17", "lines": 79, "newlines": 62, "modlines": 0, "user": "IBMUSER"}, "text": "Changes to FILE311:\n\n 2002-11-02 -----------------------------------------------------------\n\n - APFADD....Added exec;\n - BENCHMRK..Added program and sample output (BENCHMR1 & BENCHMR2);\n - CATME.....Added exec;\n - CA90S.....Added exec;\n - CLIPBRD...Removed because it is obsolete with OS/390 R8 clipboard.\n - DASRC.....Fixes WHATDATE dialog panel error;\n - DIVER.....Changed driving exec and panels names; Added wait sub;\n - FINDMOD...Added assembler program;\n - LASTUSE...Added exec;\n - OSCMD.....Added exec;\n - SHOWFDR...Added ISPF dialog;\n - SHOWMRO...Brought up to 2000-07-31 level;\n - SUBME.....Added exec;\n - VSMAP.....Brought up to 1999-08-30 level;\n\n 02-JAN-1999 - 01-MAR-1999 --------------------------------------------\n\n Updated:\n - DASRC.....Package of source library:\n             - DA$ENQS now handles multi-system enqueue correctly\n             - DA$BRODC was added: a SYS1.BRODCAST analyzer\n             - DA$PDSR had misc (minor) changes\n\n Added:\n - NEWISPF...Rexx exec that makes Version 4 of ISPF look and act more\n             like older versions.\n - COPYANSI..Rexx exec that filters an input file that has ANSI printer\n             control charactes and translates them for PCs (except top\n             of page).\n - HLASMTR...High Level Assembler Listing trimmer.  Good for when you\n             are downloading a listing for printing on a PC printer.\n             The title lines and trailing report stuff (like xref) are\n             trimmed out.\n - D2SEQN....Death 2 Sequence Numbers - a filter that removes sequence\n             numbers when copying records.  This makes printouts of\n             source code easier to read. I use this when I printout\n             JES2 source code for example.  PTF strings like \"@THX1138\"\n             when found as the last word on a line are also removed.\n             I find this really enhances my source code viewing\n             pleasure.\n\n 15-JUN-1998 - 28-AUG-1998 -------------------------------------------\n\n Added:\n - MPFEXITS..The MPF exits I use at my shop\n\n Updated:\n - CLIPBRD...An ISPF application that enhances the use of the IBM\n             supplied ISRCUT and ISRPASTE edit macros.  Use the PASTEIT\n             TSO command to paste information that is slightly larger\n             than the ISPF edit screen on a blank ISPF panel.  The\n             information on the blank screen are written to ISRPASTE\n             friendly variables in your profile.  You then use the\n             ISRPASTE edit macro to paste these lines into your ISPF\n             edit dataset.\n\n 28-MAY-1998 ---------------------------------------------------------\n\n - CBT$XREF..Rexx exec was added (See $INDEX member)\n - DASRC.....Package of source library:\n             - DA$DISKR now handles 4 digit and dynamic UCBs\n             - DA$PDSR has too many updates to mention!  Look at\n               the modification history in the comments\n - IMGCOPY...Rexx exec was added (See $INDEX member)\n - IMGINFO...Rexx exec had minor changes\n - ISPFVAR...Update to show ISPF system variables up to ISPF v4.3\n - ISPF34L...Rexx exec was added (See $INDEX member)\n - SASGIF1...Batch job was added (See $INDEX member)\n - SASGIF2...Batch job was added (See $INDEX member)\n - SMPEPP....Updated for OS/390 2.4 SMP/E\n - XMITINFO..Rexx exec was added (See $INDEX member)\n\n 16-JAN-1998 ---------------------------------------------------------\n\n - Initial PDS created for the CBT tape\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INDEX": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x07\\x00H\\x00\\x99\\x06\\x0f\\x01\\x020o\\x197\\x00\\xa6\\x00\\x82\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.07", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T19:37:48", "lines": 166, "newlines": 130, "modlines": 0, "user": "IBMUSER"}, "text": "                         C o n t e n t s\n                         ===============\n\n Member    File Type   Description\n --------  ----------  -----------\n $$README  Text        This file you are reading now.\n\n APFADD    Text        Uses the OSCMD exec (also included) to issue\n                       a SETPROG APF ADD command to add a dataset to\n                       the APF list dynamically;\n\n BENCHMRK  Text        Program that shows if there is any consideration\n                       between using one method of doing the same thing\n                       over another.  For Example, performance wise does\n                       the GETMAIN use more or less CPU than the STORAGE\n                       macro?\n\n BENCHMR1  Text        Sample output of BENCHMRK on a 9672-R56.\n BENCHMR2  Text        Sample output of BENCHMRK on a 2064-1C7.\n\n CATME     Text        Rexx exec that invokes DEFINE NONVSAM for\n                       generic and system system symbolics. Good for\n                       ISPF 3.4 vtoc lists.\n\n CA90S     Text        Rexx exec that invokes the Computer Associates\n                       CA90s (TNGFW) diagnostic display programs.  Not\n                       terribly useful.\n\n CBT$XREF  Text        First attempt at creating a CBT tape cross\n                       reference utility.  This version creates\n                       MVS/Quickref user database entries.  As it\n                       is today, it isn't all that useful yet.\n\n COMPPDS   Text        Rexx exec that compares two PDS at the member\n                       level. If a member exists in both PDSs, then\n                       ISPF compare is invoked to compare at the record\n                       level.\n COMPPDSJ  Text        JCL to run COMPPDS in batch\n\n COPYANSI  Text        Rexx exec that filters an input file that has\n                       ANSI printer control charactes and translates\n                       them for PCs (except top of page).\n\n DASRC     PDS Unload  A collection of mostly batch utility that I have\n                       written over the years. Recommend putting in a\n                       dataset with name \"ibmuser.DA.SOURCE\".\n\n DASRCV    XMIT        Additions to the DASRC file in LRECL > 80\n                       RECFM=VB. Recommend putting in a\n                       dataset with name \"ibmuser.DA.SOURCEV\".\n\n DIVER     PDS Unload  A very useless but fun ISPF application of an\n                       animated stick figure known as MR. ASCII diving\n                       into a pool.\n\n D2SEQN    Text        Death 2 Sequence Numbers - a filter that\n                       removes sequence numbers when copying records.\n                       This makes printouts of source code easier to\n                       read. I use this when I printout JES2 source\n                       code for example.  PTF strings like \"@THX1138\"\n                       when found as the last word on a line are also\n                       removed.  I find this really enhances my\n                       source code viewing pleasure.\n\n FINDMOD   Text        Assembler program that searchs the normal search\n                       order (JPA, LNKLST, LPALST, etc) for a module.\n\n HLASMTR   Text        High Level Assembler Listing trimmer.  Good\n                       for when you are downloading a listing for\n                       printing on a PC printer.  The title lines and\n                       trailing report stuff (like xref) are trimmed\n                       out.\n\n IMGCOPY   Text        REXX exec that copies all bytes from the SYSUT1\n                       file to SYSUT2 when the concept of records is\n                       not relevant.  Good for copying .GIF and .ZIP\n                       files around on a mainframe.\n\n IMGINFO   Text        REXX exec that shows the size of GIF and JPG\n                       files in a format suitable for web pages.\n\n ISGECMOM  PDS Unload  An (slight) enhancement to IBM's sample ISGECMON\n\n ISPFVAR   Text        REXX exec that shows all of the IBM supplied\n                       ISPF variables (all/most vars up to ISPF 3.5)\n\n ISPF34L   Text        REXX exec that creates utility cards, job\n                       streams from data set lists from ISPF 3.4. It\n                       does not handle the whole volume listing very\n                       well (as I just found out today).  It works best\n                       on listings from a given HLQ.\n\n JES2EXIT  PDS Unload  Edited versions of my JES2 exits\n\n LASTUSE   Text        Only useful for shops that have CA-DISK (also\n                       called (SAMS:DISK or DMS).  It shows the last\n                       job that used the dataset and the date.\n\n MPFEXITS  PDS Unload  The MPF exits I use at my shop\n\n MVSVAR    Text        REXX exec that shows all of the IBM supplied\n                       MVSVAR() function variables (TSO/E 2.5 or higher)\n\n NEWISPF   Text        Rexx exec that makes Version 4 of ISPF look\n                       and act more like older versions.\n\n OSCMD     Text        Rexx exec that uses the CONSOLE command to issue\n                       a MVS command.  You must have proper access to\n                       the TSO CONSOLE command to use OSCMD.\n\n PROGXX    PDS Unload  ISPF edit macro that verifies the APF entries in\n                       the SYS1.PARMLIB PROGxx member.\n\n SASGIF1   Text        Sample jobstream that creates a .GIF file using\n                       SAS.\n\n SASGIF2   Text        Sample jobstream that creates a .GIF file (with\n                       a transparent background) using SAS.\n\n SHOWFDR   PDS Unload  Small ISPF \"dialog\" that invokes the FDR\n                       diagnostic ISPF-based display functions;\n\n SHOWMRO   Text        Assembler program that shows the currently active\n                       CICS MRO regions via TSO TPUTs.\n\n SHOWSYM   PDS Unload  ISPF edit macro that shows the system sumbols on\n                       you MVS version 5 or higher\n\n SMFEXIT   PDS Unload  Edited versions of my SMF exits\n\n SMPEPP    PDS Unload  REXX exec that processes your SMP/E APPLY\n                       CHECK output for PTFs bypassed due to ACTION,\n                       HOLD, DOC, etc.  A list is presented that makes\n                       viewing of the HOLD Text an easy task.\n\n SPELLCHK  PDS Unload  ISPF edit macro that performs a spell check on\n                       selected lines or the whole edit file.  SAS is\n                       needed.\n\n SUBME     Text        REXX exec that submits the currently edited data\n                       to the Job Entry Subsystem.  Used when ISPF\n                       submit fails.\n\n SYSVAR    Text        REXX exec that shows all of the IBM supplied\n                       SYSVAR() function variables\n\n TOD       PDS Unload  This package adds two features to pre-OS/390\n                       JES2 to simulate the time of day functions\n                       in the JES2 JOB log.\n\n VSMAP     Text        REXX exec that shows the Virtual Storage map.\n                       The subroutine is good for inclusion in other\n                       execs.\n\n XMITINFO  Text        REXX exec that shows some internal information\n                       about a TSO XMIT file.  This exec is more useful\n                       on a PC when trying to determine if a file is\n                       actually a TSO XMIT file.  This is the first\n                       phase of a project to create a PC program to\n                       extract files and PDS members from a TSO XMIT\n                       file.  XMITINFO does work on TSO.\n\n----------------------------------------------------------------------\n\nSee the $$README file for information on the file types: Text,\nPDS Unload and TSO XMIT.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$PDSLOAD": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00I\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18\"\\x00\\x12\\x00\\x0e\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:22:49", "lines": 18, "newlines": 14, "modlines": 0, "user": "IBMUSER"}, "text": "\nThe following sample job use the PDSLOAD program from the CBT tape\nand unloads the DASRC member to a dataset \"userid.DA.SOURCE\".\n\nThe PDSLOAD program can be found on the Internet at:\n\n    http://www.cbttape.org/ftp/cbt/CBT093.zip\n\n//UPDATE   EXEC PGM=PDSLOAD,PARM=SPF\n//STEPLIB  DD DISP=SHR,DSN=ibmuser.LOAD    <- HAS PDSLOAD PROGRAM\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//SYSUT2   DD DSN=ibmuser.DA.SOURCE,\n//            DISP=(,CATLG),UNIT=SYSDA,\n//            DCB=(LRECL=80,BLKSIZE=8800,RECFM=FB),\n//            SPACE=(TRK,(100,100,64),RLSE)\n//SYSUT1   DD DISP=SHR,DSN=ibmuser.CBT.FILExxx.PDS(member)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE311": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x046\\x00\\x00\\x01\\x021\\x1f\\x01\\x021\\x1f\\x11\\x01\\x00\\xe8\\x00\\xe8\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf4@@@'", "ispf": {"version": "04.54", "flags": 0, "createdate": "2002-11-07T00:00:00", "modifydate": "2002-11-07T11:01:00", "lines": 232, "newlines": 232, "modlines": 0, "user": "CBT-454"}, "text": "//***FILE 311 IS FROM DAVE ALCOCK AND CONTAINS HIS LARGE            *   FILE 311\n//*           COLLECTION OF UTILITIES.                              *   FILE 311\n//*                                                                 *   FILE 311\n//*           Dave Alcock can be reached at his email               *   FILE 311\n//*           addresses:   David Alcock <dave@planetmvs.com>        *   FILE 311\n//*                        dalcock@csw.com   (work)                 *   FILE 311\n//*                                                                 *   FILE 311\n//*     UPDATES OF THE CONTENTS OF THE CBT FILE MAY ALSO            *   FILE 311\n//*     BE POSTED TO THIS URL ON THE INTERNET:                      *   FILE 311\n//*                                                                 *   FILE 311\n//*        http://www.planetmvs.com/                                *   FILE 311\n//*                                                                 *   FILE 311\n//*                        C o n t e n t s                          *   FILE 311\n//*                        ===============                          *   FILE 311\n//*                                                                 *   FILE 311\n//*      Member    File Type   Description                          *   FILE 311\n//*      --------  ----------  -----------                          *   FILE 311\n//*      $$README  Text        This file you are reading now.       *   FILE 311\n//*                                                                 *   FILE 311\n//*      APFADD    Text        Uses the OSCMD exec (also            *   FILE 311\n//*                            included) to issue a SETPROG APF     *   FILE 311\n//*                            ADD command to add a dataset to      *   FILE 311\n//*                            the APF list dynamically;            *   FILE 311\n//*                                                                 *   FILE 311\n//*      BENCHMRK  Text        Program that shows if there is       *   FILE 311\n//*                            any consideration between using      *   FILE 311\n//*                            one method of doing the same         *   FILE 311\n//*                            thing over another.  For             *   FILE 311\n//*                            Example, performance wise does       *   FILE 311\n//*                            the GETMAIN use more or less CPU     *   FILE 311\n//*                            than the STORAGE macro?              *   FILE 311\n//*                                                                 *   FILE 311\n//*      BENCHMR1  Text        Sample output of BENCHMRK on a       *   FILE 311\n//*                            9672-R56.                            *   FILE 311\n//*                                                                 *   FILE 311\n//*      BENCHMR2  Text        Sample output of BENCHMRK on a       *   FILE 311\n//*                            2064-1C7.                            *   FILE 311\n//*                                                                 *   FILE 311\n//*      CATME     Text        Rexx exec that invokes DEFINE        *   FILE 311\n//*                            NONVSAM for generic and system       *   FILE 311\n//*                            system symbolics. Good for ISPF      *   FILE 311\n//*                            3.4 vtoc lists.                      *   FILE 311\n//*                                                                 *   FILE 311\n//*      CA90S     Text        Rexx exec that invokes the           *   FILE 311\n//*                            Computer Associates CA90s (TNGFW)    *   FILE 311\n//*                            diagnostic display programs.  Not    *   FILE 311\n//*                            terribly useful.                     *   FILE 311\n//*                                                                 *   FILE 311\n//*      CBT$XREF  Text        First attempt at creating a CBT      *   FILE 311\n//*                            tape cross reference utility.        *   FILE 311\n//*                            This version creates MVS/Quickref    *   FILE 311\n//*                            user database entries.  As it is     *   FILE 311\n//*                            today, it isn't all that useful      *   FILE 311\n//*                            yet.                                 *   FILE 311\n//*                                                                 *   FILE 311\n//*      COMPPDS   Text        Rexx exec that compares two PDS      *   FILE 311\n//*                            at the member level. If a member     *   FILE 311\n//*                            exists in both PDSs, then ISPF       *   FILE 311\n//*                            compare is invoked to compare at     *   FILE 311\n//*                            the record level.                    *   FILE 311\n//*                                                                 *   FILE 311\n//*      COMPPDSJ  Text        JCL to run COMPPDS in batch          *   FILE 311\n//*                                                                 *   FILE 311\n//*      COPYANSI  Text        Rexx exec that filters an input      *   FILE 311\n//*                            file that has ANSI printer           *   FILE 311\n//*                            control charactes and translates     *   FILE 311\n//*                            them for PCs (except top of          *   FILE 311\n//*                            page).                               *   FILE 311\n//*                                                                 *   FILE 311\n//*      DASRC     PDS Unload  A collection of mostly batch         *   FILE 311\n//*                            utility that I have written over     *   FILE 311\n//*                            the years. Recommend putting in a    *   FILE 311\n//*                            dataset with name                    *   FILE 311\n//*                            \"ibmuser.DA.SOURCE\".                 *   FILE 311\n//*                                                                 *   FILE 311\n//*      DASRCV    XMIT        Additions to the DASRC file in       *   FILE 311\n//*                            LRECL > 80 RECFM=VB. Recommend       *   FILE 311\n//*                            putting in a dataset with name       *   FILE 311\n//*                            \"ibmuser.DA.SOURCEV\".                *   FILE 311\n//*                                                                 *   FILE 311\n//*      DIVER     PDS Unload  A very useless but fun ISPF          *   FILE 311\n//*                            application of an animated stick     *   FILE 311\n//*                            figure known as MR. ASCII diving     *   FILE 311\n//*                            into a pool.                         *   FILE 311\n//*                                                                 *   FILE 311\n//*      D2SEQN    Text        Death 2 Sequence Numbers - a         *   FILE 311\n//*                            filter that removes sequence         *   FILE 311\n//*                            numbers when copying records.        *   FILE 311\n//*                            This makes printouts of source       *   FILE 311\n//*                            code easier to read. I use this      *   FILE 311\n//*                            when I printout JES2 source code     *   FILE 311\n//*                            for example.  PTF strings like       *   FILE 311\n//*                            \"@THX1138\" when found as the last    *   FILE 311\n//*                            word on a line are also removed.     *   FILE 311\n//*                            I find this really enhances my       *   FILE 311\n//*                            source code viewing pleasure.        *   FILE 311\n//*                                                                 *   FILE 311\n//*      FINDMOD   Text        Assembler program that searchs       *   FILE 311\n//*                            the normal search order (JPA,        *   FILE 311\n//*                            LNKLST, LPALST, etc) for a           *   FILE 311\n//*                            module.                              *   FILE 311\n//*                                                                 *   FILE 311\n//*      HLASMTR   Text        High Level Assembler Listing         *   FILE 311\n//*                            trimmer.  Good for when you are      *   FILE 311\n//*                            downloading a listing for            *   FILE 311\n//*                            printing on a PC printer.  The       *   FILE 311\n//*                            title lines and trailing report      *   FILE 311\n//*                            stuff (like xref) are trimmed        *   FILE 311\n//*                            out.                                 *   FILE 311\n//*                                                                 *   FILE 311\n//*      IMGCOPY   Text        REXX exec that copies all bytes      *   FILE 311\n//*                            from the SYSUT1 file to SYSUT2       *   FILE 311\n//*                            when the concept of records is       *   FILE 311\n//*                            not relevant.  Good for copying      *   FILE 311\n//*                            .GIF and .ZIP files around on a      *   FILE 311\n//*                            mainframe.                           *   FILE 311\n//*                                                                 *   FILE 311\n//*      IMGINFO   Text        REXX exec that shows the size of     *   FILE 311\n//*                            GIF and JPG files in a format        *   FILE 311\n//*                            suitable for web pages.              *   FILE 311\n//*                                                                 *   FILE 311\n//*      ISGECMOM  PDS Unload  An (slight) enhancement to IBM's     *   FILE 311\n//*                            sample ISGECMON                      *   FILE 311\n//*                                                                 *   FILE 311\n//*      ISPFVAR   Text        REXX exec that shows all of the      *   FILE 311\n//*                            IBM supplied ISPF variables          *   FILE 311\n//*                            (all/most vars up to ISPF 3.5)       *   FILE 311\n//*                                                                 *   FILE 311\n//*      ISPF34L   Text        REXX exec that creates utility       *   FILE 311\n//*                            cards, job streams from data set     *   FILE 311\n//*                            lists from ISPF 3.4. It does not     *   FILE 311\n//*                            handle the whole volume listing      *   FILE 311\n//*                            very well (as I just found out       *   FILE 311\n//*                            today).  It works best on            *   FILE 311\n//*                            listings from a given HLQ.           *   FILE 311\n//*                                                                 *   FILE 311\n//*      JES2EXIT  PDS Unload  Edited versions of my JES2 exits     *   FILE 311\n//*                                                                 *   FILE 311\n//*      LASTUSE   Text        Only useful for shops that have      *   FILE 311\n//*                            CA-DISK (also called (SAMS:DISK      *   FILE 311\n//*                            or DMS).  It shows the last job      *   FILE 311\n//*                            that used the dataset and the        *   FILE 311\n//*                            date.                                *   FILE 311\n//*                                                                 *   FILE 311\n//*      MPFEXITS  PDS Unload  The MPF exits I use at my shop       *   FILE 311\n//*                                                                 *   FILE 311\n//*      MVSVAR    Text        REXX exec that shows all of the      *   FILE 311\n//*                            IBM supplied MVSVAR() function       *   FILE 311\n//*                            variables (TSO/E 2.5 or higher)      *   FILE 311\n//*                                                                 *   FILE 311\n//*      NEWISPF   Text        Rexx exec that makes Version 4 of    *   FILE 311\n//*                            ISPF look and act more like older    *   FILE 311\n//*                            versions.                            *   FILE 311\n//*                                                                 *   FILE 311\n//*      OSCMD     Text        Rexx exec that uses the CONSOLE      *   FILE 311\n//*                            command to issue a MVS command.      *   FILE 311\n//*                            You must have proper access to       *   FILE 311\n//*                            the TSO CONSOLE command to use       *   FILE 311\n//*                            OSCMD.                               *   FILE 311\n//*                                                                 *   FILE 311\n//*      PROGXX    PDS Unload  ISPF edit macro that verifies the    *   FILE 311\n//*                            APF entries in the SYS1.PARMLIB      *   FILE 311\n//*                            PROGxx member.                       *   FILE 311\n//*                                                                 *   FILE 311\n//*      SASGIF1   Text        Sample jobstream that creates a      *   FILE 311\n//*                            .GIF file using SAS.                 *   FILE 311\n//*                                                                 *   FILE 311\n//*      SASGIF2   Text        Sample jobstream that creates a      *   FILE 311\n//*                            .GIF file (with a transparent        *   FILE 311\n//*                            background) using SAS.               *   FILE 311\n//*                                                                 *   FILE 311\n//*      SHOWFDR   PDS Unload  Small ISPF \"dialog\" that invokes     *   FILE 311\n//*                            the FDR diagnostic ISPF-based        *   FILE 311\n//*                            display functions;                   *   FILE 311\n//*                                                                 *   FILE 311\n//*      SHOWMRO   Text        Assembler program that shows the     *   FILE 311\n//*                            currently active CICS MRO regions    *   FILE 311\n//*                            via TSO TPUTs.                       *   FILE 311\n//*                                                                 *   FILE 311\n//*      SHOWSYM   PDS Unload  ISPF edit macro that shows the       *   FILE 311\n//*                            system sumbols on you MVS version    *   FILE 311\n//*                            5 or higher                          *   FILE 311\n//*                                                                 *   FILE 311\n//*      SMFEXIT   PDS Unload  Edited versions of my SMF exits      *   FILE 311\n//*                                                                 *   FILE 311\n//*      SMPEPP    PDS Unload  REXX exec that processes your        *   FILE 311\n//*                            SMP/E APPLY CHECK output for PTFs    *   FILE 311\n//*                            bypassed due to ACTION, HOLD,        *   FILE 311\n//*                            DOC, etc.  A list is presented       *   FILE 311\n//*                            that makes viewing of the HOLD       *   FILE 311\n//*                            Text an easy task.                   *   FILE 311\n//*                                                                 *   FILE 311\n//*      SPELLCHK  PDS Unload  ISPF edit macro that performs a      *   FILE 311\n//*                            spell check on selected lines or     *   FILE 311\n//*                            the whole edit file.  SAS is         *   FILE 311\n//*                            needed.                              *   FILE 311\n//*                                                                 *   FILE 311\n//*      SUBME     Text        REXX exec that submits the           *   FILE 311\n//*                            currently edited data to the Job     *   FILE 311\n//*                            Entry Subsystem.  Used when ISPF     *   FILE 311\n//*                            submit fails.                        *   FILE 311\n//*                                                                 *   FILE 311\n//*      SYSVAR    Text        REXX exec that shows all of the      *   FILE 311\n//*                            IBM supplied SYSVAR() function       *   FILE 311\n//*                            variables                            *   FILE 311\n//*                                                                 *   FILE 311\n//*      TOD       PDS Unload  This package adds two features to    *   FILE 311\n//*                            pre-OS/390 JES2 to simulate the      *   FILE 311\n//*                            time of day functions in the JES2    *   FILE 311\n//*                            JOB log.                             *   FILE 311\n//*                                                                 *   FILE 311\n//*      VSMAP     Text        REXX exec that shows the Virtual     *   FILE 311\n//*                            Storage map.  The subroutine is      *   FILE 311\n//*                            good for inclusion in other          *   FILE 311\n//*                            execs.                               *   FILE 311\n//*                                                                 *   FILE 311\n//*      XMITINFO  Text        REXX exec that shows some internal   *   FILE 311\n//*                            information about a TSO XMIT file.   *   FILE 311\n//*                            This exec is more useful on a PC     *   FILE 311\n//*                            when trying to determine if a file   *   FILE 311\n//*                            is actually a TSO XMIT file.  This   *   FILE 311\n//*                            is the first phase of a project to   *   FILE 311\n//*                            create a PC program to extract       *   FILE 311\n//*                            files and PDS members from a TSO     *   FILE 311\n//*                            XMIT file.  XMITINFO does work on    *   FILE 311\n//*                            TSO.                                 *   FILE 311\n//*                                                                 *   FILE 311\n//*     ----------------------------------------------------------  *   FILE 311\n//*                                                                 *   FILE 311\n//*     See the $$README file for information on the file types:    *   FILE 311\n//*     Text, PDS Unload and TSO XMIT.                              *   FILE 311\n//*                                                                 *   FILE 311\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APFADD": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00#\\x01\\x020o\\x01\\x020o\\x14\\t\\x00e\\x00W\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T14:09:23", "lines": 101, "newlines": 87, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: APFADD\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Add a dataset to the APFLST using the OSCMD Rexx exec;\n |\n | Hint: Can be used from ISPF 3.4\n |\n | Syntax: APFADD 'SYS2.BOZO.CLOWNLIB'\n |\n | Requirements: Rexx exec OSCMD (file 311 from http://www.cbttape.org)\n |               or equivalent;\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1997-2002+ by David Alcock\n |             All rights reserved.\n |\n */\n\n/*---------------------------------------------------------------------\n | Installation dependant\n ------------------------------------------------------------------- */\n\nmcs_cmd = \"%OSCMD  \"   /* Installation dependant */\n\n/*---------------------------------------------------------------------\n | Verify the dataset\n ------------------------------------------------------------------- */\n\narg dsn vol nodelay\n\nif dsn == \"\" then do\n   say \"Missing dataset name\"\n   exit\n   end\n\ndodelay = 1\nif translate(vol) == \"NODELAY\" then do\n   dodelay = 0\n   vol = \"\"\n   end\nif translate(nodelay) == \"NODELAY\" then dodelay = 0\n\nif vol == \"\" then do\n   say \"Missing volume serial, will use cataloged version\"\n   x = LISTDSI(dsn)\n   if x <> 0 then do\n      say \"Error: Dataset not found:\" dsn\n      exit\n      end\n   vol = sysvolume\n   say \"Using volume \"vol\" for dsn=\"dsn\n   end\n\nvol = strip(vol)\nx = LISTDSI(dsn \"VOLUME(\"vol\")\" 'NORECALL' )\nif x <> 0 then do\n   say \"LISTDSI failed to DSN=\"dsn \"VOL=\"vol\n   exit\n   end\n\nif sysrecfm <> \"U\" then do\n   say \"Dataset does not appear to be a load library - RECFM=\"sysrecfm\n   say \"It was NOT added to the APFLST\"\n   exit\n   end\nif sysdsorg <> \"PO\" then do\n   say \"Dataset does not appear to be a load library - DSORG=\"sysdsorg\n   say \"It was NOT added to the APFLST\"\n   exit\n   end\n\n/*---------------------------------------------------------------------\n | Issue the operator command\n ------------------------------------------------------------------- */\n\nsay \"Issuing command: SETPROG APF,ADD,DSN=\"sysdsname\",VOL=\"sysvolume\naddress TSO mcs_cmd  \"SETPROG APF,ADD,DSN=\"sysdsname\",VOL=\"sysvolume\nxtime = time()\n\n/* When you issue a \"D PROG,APF\" right after an add, the new dataset\n   doesn't show up in the list - A delay or wait command would be\n   better than this do loop */\nif dodelay then do\n   do i = 1 to 100000  /* put in a short delay */\n      nop\n      end\n   address TSO mcs_cmd \"NODISP D PROG,APF\"\n   say \"Look in the SYSLOG around \"time()\" for D PROG,APF\"\n   say \"New datasets are at the end of the D PROG,APF list\"\n   end\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BENCHMRK": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00T\\x01\\x020o\\x01\\x020o\\x189\\x02\\xa2\\x02\\x96\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T18:39:54", "lines": 674, "newlines": 662, "modlines": 0, "user": "IBMUSER"}, "text": "BENCHMRK TITLE 'Simple benchmark of various OS/390 methods'\n* ===================================================================\n*\n* Name: BENCHMRK\n*\n* Author: David Alcock :: dave@planetmvs.com\n*\n* Purpose: Perform a simple benchmark to compare different ways of\n*          doing the same thing to see is one has a performance\n*          advantage over another one.\n*\n* Requirements:\n* - High Level Assembler\n* - MVS version 3 and higher (for entry and exit housekeeping)\n*\n* Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001-2002+ by David Alcock\n*             All rights reserved.\n* ===================================================================\n\n* Set number of loops\n\n#LOOPS   EQU   4*(1024*1024)\n\n* Inline macros\n\n         MACRO ,\n&LABEL   SETMODE &MODE,               24 \u00a6 31                          @\n               &WREG=1                WORK REGISTER\n         AIF   ('&MODE' EQ '24').XAOFF\n         AIF   ('&MODE' EQ '31').XAON\n         MNOTE 8,'INVALID ADDRESSING MODE SPECIFIED - &MODE'\n         MEXIT ,\n.XAON    ANOP ,                    GO TO 31 BIT MODE\n         CNOP  2,4                 FORCE FULL WORD ALIGNMENT\n         LA    &WREG,*+14          POINT TO AMODE = 31 CODE\n         O     &WREG,*+6           TURN ON AMODE = 31 BIT\n         BSM   0,&WREG             BRANCH TO AMODE = 31 CODE\n         DC    X'80000000'         AMODE = 31 BIT\n         MEXIT ,\n.XAOFF   LA    &WREG,*+6           POINT TO AMODE = 24 CODE\n         BSM   0,&WREG             BRANCH TO AMODE = 24 CODE\n         MEND\n\n* IBM macros\n\n         PRINT NOGEN\n         YREGS ,\n         CVT   DSECT=YES,LIST=NO\n         IHASDWA ,                      System Diagnostic Work Area\n         PRINT GEN\n         EJECT ,\nBENCHMRK CSECT ,\nBENCHMRK AMODE 24\nBENCHMRK RMODE 24\n*\nBM_EC    B     BM_ECL(0,R15)            Bump past EyeCatcher\n         DC    AL1(BM_ECE-BM_ECV)       Length of Eyecatcher\nBM_ECV   DC    C'BENCHMRK '\n         DC    C'-- &SYSDATC &SYSTIME '\n         DC    C'-- Benchmark various S/390 methods'\nBM_ECE   EQU   *\n         DS    0H\nBM_ECL   EQU   *-BM_EC\n*\n         BAKR  R14,0                    Save regs\n         LAE   R12,0(R15,0)             Get base register\n         USING BENCHMRK,R12             Get addressibility\n         SAC   0\n         SYSSTATE ASCENV=P\n*\n         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage\n         LR    R13,R1                   Point to Save Area\n         USING WORKDS,R13               Get addressibility to area\n         MVC   4(4,R13),=C'F1SA'        Indicate stack SA\n\n* Create ESTAE in case instruction isn't implemented on this boxen\n\n         MVC   PARMLIST(C_ESTAEl),C_ESTAE Initlialize parameter list\n         MVC   EWA_ID(4),=CL4'EWA'      Eyecatcher\n         STM   R10,R13,EWA_Regs         Save important registers\n         L     R7,=V(MYESTAE)           Locate ESTAE routine\n         LA    R8,EWA                   Locate EWA\n         ESTAE (7),CT,                  Create ESTAE environment       @\n               PARAM=((8)),             ..Parameter passed to ESTAE    @\n               MF=(E,PARMLIST)\n\n* Program title\n\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         LA    R15,MSGAREA\n         MVC   0(16,R15),=C'Benchmarks using'\n         LA    R15,17(R15)\n         L     R1,=A(#LOOPS)\n         BAS   R14,EDITFWF\n         MVC   1(5,R15),=C'loops'\n         LA    R15,1+5(R15)\n         LA    R1,MSGAREA\n         SR    R15,R1\n         LR    R0,R15\n         TPUT  (1),(0)\n\n* Housekeeping Benchmark\n\n         LA    R4,C_HOUSE\n         BAS   R9,Print_Section_Title\n*\n         L     R3,=V(HOUSEOLD)\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$HOLD   DS    0H\n         LR    R15,R3\n         BALR  R14,R15\n         BCT   R2,L$HOLD\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_HOLD\n         BAS   R9,Report_On_BenchMark\n*\n         L     R3,=V(HOUSEESA)\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$HESA   DS    0H\n         LR    R15,R3\n         BALR  R14,R15\n         BCT   R2,L$HESA\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_HESA\n         BAS   R9,Report_On_BenchMark\n\n* Clear registers\n\n         LA    R4,C_ClearReg\n         BAS   R9,Print_Section_Title\n*\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$CLEARL DS    0H\n         LA    R15,0\n         BCT   R2,L$CLEARL\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_ClearRegLA\n         BAS   R9,Report_On_BenchMark\n*\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$CLEARS DS    0H\n         SLR   R15,R15\n         BCT   R2,L$CLEARS\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_ClearRegSLR\n         BAS   R9,Report_On_BenchMark\n*\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$CLEARX DS    0H\n         XR    R15,R15\n         BCT   R2,L$CLEARX\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_ClearRegXR\n         BAS   R9,Report_On_BenchMark\n\n* GETMAIN vs Storage benchmark\n\n         LA    R4,C_STOR\n         BAS   R9,Print_Section_Title\n*\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$STORG  DS    0H\n         L     R0,=A(4096)\n         GETMAIN R,LV=(0)\n         FREEMAIN R,LV=(0),A=(1)\n         BCT   R2,L$STORG\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_STORG\n         BAS   R9,Report_On_BenchMark\n*\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$STORS  DS    0H\n         L     R0,=A(4096)\n         STORAGE OBTAIN,LENGTH=(0),LOC=BELOW Obtain storage\n         STORAGE RELEASE,LENGTH=(0),ADDR=(1) Release storage\n         BCT   R2,L$STORS\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_STORS\n         BAS   R9,Report_On_BenchMark\n AGO .CPOOLX\n --> I'm not sure why I have the cpool stuff commented out...\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$STORC  DS    0H\n         L     R0,=A(4096)\n**       CPOOL BUILD,PCELLCT=10,SCELLCT=20,CSIZE=(0)\n**       STORAGE OBTAIN,LENGTH=(0),LOC=BELOW Obtain storage\n**       STORAGE RELEASE,LENGTH=(0),ADDR=(1) Release storage\n         BCT   R2,L$STORC\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_STORC\n         BAS   R9,Report_On_BenchMark\n.CPOOLX ANOP ,\nSTARTHERE DS 0H\n\n* Mode switching methods\n\n         LA    R4,C_MODESWITCH\n         BAS   R9,Print_Section_Title\n*\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$S24BL  DS    0H\n         SETMODE 24\n         BCT   R2,L$S24BL\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         LA    R4,C_MODESWITCHB24\n         BAS   R9,Report_On_BenchMark\n*\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$S31BL  DS    0H\n         SETMODE 31\n         BCT   R2,L$S31BL\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         SETMODE 24  Back to good addressing mode\n         LA    R4,C_MODESWITCHB31\n         BAS   R9,Report_On_BenchMark\n*\n         LA    R1,l$s24E                Locate retry recovery routine\n         ST    R1,EWA_RetryA            Save it\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$S24IL  DS    0H\n         SAM24 ,\n         BCT   R2,L$S24IL\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         XC    EWA_RetryA,EWA_RetryA\n         LA    R4,C_MODESWITCHI24\n         BAS   R9,Report_On_BenchMark\n         B     L$S24EX\nL$S24EM  DC    C'        SAM24 instruction not defined on this box'\nL$S24E   DS    0H\n         XC    EWA_RetryA,EWA_RetryA\n         MVI   MSGAREA,C' '\n         TPUT  MSGAREA,1\n         MVC   MSGAREA(L'L$S24EM),L$S24EM\n         TPUT  MSGAREA,L'L$S24EM\nL$S24EX  DS    0H\n*\n         LA    R1,l$s31E                Locate retry recovery routine\n         ST    R1,EWA_RetryA            Save it\n         L     R2,=A(#LOOPS)\n         TIMEUSED STORADR=TU_START,LINKAGE=SYSTEM,CPU=TOD\nL$S31IL  DS    0H\n         SAM31 ,\n         BCT   R2,L$S31IL\n         TIMEUSED STORADR=TU_END,LINKAGE=SYSTEM,CPU=TOD\n         XC    EWA_RetryA,EWA_RetryA\n         SAM24 ,     Back to good addressing mode\n         LA    R4,C_MODESWITCHI31\n         BAS   R9,Report_On_BenchMark\n         B     L$S31EX\nL$S31EM  DC    C'        SAM31 instruction not defined on this box'\nL$S31E   DS    0H\n         XC    EWA_RetryA,EWA_RetryA\n         MVI   MSGAREA,C' '\n         TPUT  MSGAREA,1\n         MVC   MSGAREA(L'L$S31EM),L$S31EM\n         TPUT  MSGAREA,L'L$S31EM\nL$S31EX  DS    0H\n\n* Leave\n\nEXIT     DS    0H\n         ESTAE 0\n         LR    R2,R13                     Get storage address\n         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage\n         SLR   R15,R15                    Set return code\n         PR    ,                          Return to caller\n         EJECT\n***********************************************************************\n***\n**       Report on the results of the benchmark\n**\n** On entry:\n** - TU_START - Timeused at start\n** - TU_END   - Timeused at end\n** - R4 - Address of string\n***\n***********************************************************************\n         SPACE 2\nReport_On_BenchMark DS 0H\n         LM    R0,R1,TU_END\n         SL    R1,TU_START+4\n         BC    11,*+6\n         BCTR  R0,0\n         SL    R0,TU_START\n         STM   R0,R1,TU_TCPU\n*\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         TPUT  MSGAREA,1\n*\n         LA    R15,MSGAREA+8\n         SLR   R14,R14\n         IC    R14,0(R4)\n         EX    R14,ROB$MOVE\n         TPUT  MSGAREA,79\n*\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         AGO   .INHEX - - - - - - - - - - - - - - Skip debugging code\n         LA    R15,MSGAREA+12\n         UNPK  0(9,R15),TU_START(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         UNPK  0(9,R15),TU_START+4(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         MVC   0(6,R15),=C'=Start'\n         TPUT  MSGAREA,79\n*\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         LA    R15,MSGAREA+12\n         UNPK  0(9,R15),TU_END(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         UNPK  0(9,R15),TU_END+4(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         MVC   0(4,R15),=C'=End'\n         TPUT  MSGAREA,79\n*\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         LA    R15,MSGAREA+12\n         UNPK  0(9,R15),TU_TCPU(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         UNPK  0(9,R15),TU_TCPU+4(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         MVC   0(6,R15),=C'=Total'\n         TPUT  MSGAREA,79\n.INHEX   ANOP  , - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n         MVC   PARMLIST(C_STCKCONVL),C_STCKCONV Get parameter list\n         STCKCONV STCKVAL=TU_TCPU,          Convert STCK from TOD,     @\n               CONVVAL=DOUBLE2,             ..Output return area       @\n               TIMETYPE=DEC,                ..Type of time field       @\n               DATETYPE=YYYYMMDD,           ..Type of date field       @\n               MF=(E,PARMLIST)              ..Execute from here\n         ST    R15,PARMLIST\n*\n*-TIME is returned in format: \"HHMMSSthmiju0000\"\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         LA    R15,MSGAREA+12\n         MVC   0(14,R15),=C'CPU Time used:'\n         LA    R15,15(R15)      H H : M M : S S . t h m i\n         MVC   0(15,R15),=X'402120207A20207A20204B20202020'\n         ED    0(15,R15),DOUBLE2          Edit the cpu time\n         TPUT  MSGAREA,79\n*\n         BSM   0,R9\nROB$MOVE MVC   0(0,R15),1(R4)\n\n*\n** Report on the benchmark title\n*\nPrint_Section_Title DS 0H\n         MVI   MSGAREA,C' '\n         TPUT  MSGAREA,1\n         MVI   MSGAREA,C' '\n         MVC   MSGAREA+1(L'MSGAREA-1),MSGAREA\n         LA    R15,MSGAREA+4\n         SLR   R14,R14\n         IC    R14,0(R4)\n         EX    R14,RT$MOVE\n         LA    R15,1(R14,R15)\n         LA    R1,MSGAREA\n         SR    R15,R1\n         LR    R0,R15\n         TPUT  (1),(0)\n         BSM   0,R9\nRT$MOVE  MVC   0(*-*,R15),1(R4)\n         EJECT\n***********************************************************************\n***\n**       Misc subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n**       EDIT FULLWORD (FLUSH TO R15)\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nEDITFWF  DS    0H\n         ST    R14,EF_RA\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITFWF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,EDITFWFM               MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '                Fix unprintable character\n         L     R14,EF_RA\n         BSM   0,R14                      RETURN TO CALLER\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         L     R14,EF_RA\n         BSM   0,R14                      RETURN TO CALLER\n         EJECT\n***********************************************************************\n***\n**       Constants for BENCHMRK CSECT\n***\n***********************************************************************\nC_HOUSE  DC    AL1(C_HOUSEL-2)\n         DC    C'Entry/Exit Housekeeping Methods'\nC_HOUSEL EQU   *-C_HOUSE\n\nC_HOLD   DC    AL1(C_HOLDL-2)\n         DC    C'Using S/360 Instructions (STM/LM)'\nC_HOLDL  EQU   *-C_HOLD\n\nC_HESA   DC    AL1(C_HESAL-2)\n         DC    C'Using ESA Instructions (BAKR/PR)'\nC_HESAL  EQU   *-C_HESA\n\nC_ClearReg DC  AL1(C_ClearRegL-2)\n         DC    C'Clearing register'\nC_ClearRegL EQU *-C_ClearReg\n\nC_ClearRegLA DC AL1(C_ClearRegLAL-2)\n         DC    C'Using LA R15,0 instruction'\nC_ClearRegLAL EQU *-C_ClearRegLA\n\nC_ClearRegXR DC AL1(C_ClearRegXRL-2)\n         DC    C'Using XR R15,R15 instruction'\nC_ClearRegXRL EQU *-C_ClearRegXR\n\nC_ClearRegSLR DC AL1(C_ClearRegSLRL-2)\n         DC    C'Using SLR R15,R15 instruction'\nC_ClearRegSLRL EQU *-C_ClearRegSLR\n\n\nC_STOR   DC    AL1(C_STORL-2)\n         DC    C'Virtual Storage obtain/release Methods'\nC_STORL EQU    *-C_STOR\n\nC_STORG  DC    AL1(C_STORGL-2)\n         DC    C'Using Getmain/Freemain R'\nC_STORGL EQU   *-C_STORG\nC_STORS  DC    AL1(C_STORSL-2)\n         DC    C'Using Storage macro'\nC_STORSL EQU   *-C_STORS\nC_STORC  DC    AL1(C_STORCL-2)\n         DC    C'Using CPOOL macro'\nC_STORCL EQU   *-C_STORC\n\nC_MODESWITCH DC AL1(C_MODESWITCHL-2)\n         DC    C'Addressing Mode switch'\nC_MODESWITCHL EQU *-C_MODESWITCH\n\nC_MODESWITCHB24 DC AL1(C_MODESWITCHB24L-2)\n         DC    C'Using Old Branch method to 24-bit'\nC_MODESWITCHB24L EQU *-C_MODESWITCHB24\n\nC_MODESWITCHB31 DC AL1(C_MODESWITCHB31L-2)\n         DC    C'Using Old Branch method to 31-bit'\nC_MODESWITCHB31L EQU *-C_MODESWITCHB31\n\nC_MODESWITCHI24 DC AL1(C_MODESWITCHI24L-2)\n         DC    C'Using z/Arch SAM24 instruction'\nC_MODESWITCHI24L EQU *-C_MODESWITCHI24\n\nC_MODESWITCHI31 DC AL1(C_MODESWITCHI31L-2)\n         DC    C'Using z/Arch SAM31 instruction'\nC_MODESWITCHI31L EQU *-C_MODESWITCHI31\n\n* Macro expansions\n\nC_STCKCONV  STCKCONV MF=L\nC_STCKCONVL EQU *-C_STCKCONV\n\nC_ESTAE  ESTAE *-*,CT,TERM=NO,MF=L\nC_ESTAEl EQU   *-C_ESTAE\n\n* Literals\n\n         LTORG ,\n         DROP  R12,R13\n         EJECT\n***********************************************************************\n***\n**        Entry/Exit housekeeping\n***\n***********************************************************************\n         SPACE 2\n*\n** Entry and Exit housekeeping using the old method\n*\nHOUSEOLD CSECT ,\nHOUSEOLD AMODE 31\nHOUSEOLD RMODE ANY\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         USING HOUSEOLD,R12\n         ST    R13,SAVEAREA+4\n         LR    R2,R13\n         LA    R13,SAVEAREA\n         ST    R13,8(R2)\n*\n         SLR   R15,R15\n*\n         L     R13,SAVEAREA+4\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         DS    0F\nSAVEAREA DS    18F\n         DROP  R12\n*\n** Entry and Exit housekeeping using the ESA method\n*\nHOUSEESA CSECT ,\nHOUSEESA AMODE 31\nHOUSEESA RMODE ANY\n         BAKR  R14,0\n         LAE   R12,0(R15,0)\n         USING HOUSEESA,R12\n*\n         SLR   R15,R15\n*\n         PR    ,\n         DROP  R12\n\n***********************************************************************\n***\n**     E S T A E   E X I T  - Gets control for ABENDs\n**\n**     \\\\//////      ________________\n**     \\\\    |      /                \\\n**     \\(_  x|     /  Bloooeeahhh!!! |\n**     \\    __)  _/__________________/\n**   __/   _\\ ,. .\n**  /     /  .%:. * .\n** |  |   |   . ;>, $  '                 \"Castles made of sand,\n** |  |   |    .=.~@ .  &                fall into the sea,\n** UUUU---|   :?. ;. .\u00ac#  .   \u00ac          eventually\" -- Jimi Hendrix\n** |      |    < * '   .   ,  *\n**\n***\n***********************************************************************\n\nMYESTAE  CSECT ,\nMYESTAE  AMODE 31\nMYESTAE  RMODE ANY\n\n* Standard O/S eyecatcher\n\nER_EC    B     ER_ECL(0,R15)            Bump past EyeCatcher\n         DC    AL1(ER_ECE-ER_ECV)       Length of Eyecatcher\nER_ECV   DC    C'MYESTAE - ESTAE error routine'\nER_ECE   EQU   *\n         DS    0H\nER_ECL   EQU   *-ER_EC\n\n* Standard ESA entry housekeeping\n\n bakr  r14,0                            Save regs\n lae   r12,0(r15,0)                     Get base register\n USING MYESTAE,R12                      Get addressibility\n SAC   0\n SYSSTATE ASCENV=P\n\n* Register input parameters\n* R0 - Code:\n*      - 0  ... Active I/O has be Quiesced and is restorable\n*      - 4  ... Active I/O has been halted and is not restorable\n*      - 8  ... No active I/O at ABEND Time\n*      - 12 ... an SDWA was not obtained\n*      - 16 ... No I/O processing was performed\n* R1 - IF R0 <> 12 THEN it has SDWA ELSE ABEND code\n\n ch    r0,=H'12'                        SDWA present?\n be    er$x                             No, just leave\n lr    r2,r1                            Save SDWA address\n USING SDWA,r2\n l     r4,SDWAPARM                      Locate EWA\n\n* Get set for return address\n\n ICM   R3,B'1111',EWA_RetryA-EWA(R4)    Get retry addr\n BZ    ER$X                             Not there, give up\n MVC   SDWASR13(4),EWA_R13-EWA(R4)\n MVC   SDWASR12(4),EWA_R12-EWA(R4)\n MVC   SDWASR11(4),EWA_R11-EWA(R4)\n MVC   SDWASR10(4),EWA_R10-EWA(R4)\n\n         SETRP WKAREA=(2),              Set Return Parameters          @\n               RETADDR=(3),             ..Return Address               @\n               RETREGS=YES,             ..Reset regs using SDWASRSV    @\n               DUMP=NO,                 ..Not verbose, just recover    @\n               RC=4                     ..Retry using RETADDR\n         DROP  R2\n\n* Return with no attempt to retry\n\ner$x ds 0h\n pr    ,                                Return to caller\n\n* constants\n\n LTORG ,                                Literals\n ds    0d                               End on doubleword boundry\nMYESTAEL equ    *-MYESTAE\n drop  R12\n         EJECT\n***********************************************************************\n***\n**       Dynamic Save area\n***\n***********************************************************************\n         SPACE 2\nWORKDS         DSECT ,\n               DS    18F               Register Save Area\nDOUBLE         DS    D\nDOUBLE2        DS    2D\nPARMLIST       DS    10F\nEF_RA          DS    F\n\nEWA            ds    0f                 ESTAE Work Area\nEWA_ID         ds    cl4'EWA'           ..ID for dumps\nEWA_RetryA     ds    xl4                ..Retry address\nEWA_Regs       equ   *                  ..Important registers\nEWA_R10        ds    f\nEWA_R11        ds    f\nEWA_R12        ds    f\nEWA_R13        ds    f\nEWAL           equ   *-EWA\n\nMSGAREA        DS    CL133\n               DS    0D\n*\nTU_START       DS    XL8\nTU_END         DS    XL8\nTU_TCPU        DS    XL8\n               DS    0D\nWORKDSL        EQU   *-WORKDS\n               END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BENCHMR1": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x020o\\x01\\x020o\\x174\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T17:34:03", "lines": 31, "newlines": 31, "modlines": 0, "user": "IBMUSER"}, "text": "Output of the BENCHMRK program on a 9672-R56:\n\nBenchmarks using 4,194,304 loops\n\n    Entry/Exit Housekeeping Methods\n\n        Using S/360 Instructions (STM/LM)\n            CPU Time used:   00:00:05.9946\n\n        Using ESA Instructions (BAKR/PR)\n            CPU Time used:   00:00:21.7179\n\n    Virtual Storage obtain/release Methods\n\n        Using Getmain/Freemain R\n            CPU Time used:   00:10:96.7121\n\n        Using Storage macro\n            CPU Time used:   00:12:56.7357\n\n    Addressing Mode switch\n\n        Using Old Branch method to 24-bit\n            CPU Time used:   00:00:01.1148\n\n        Using Old Branch method to 31-bit\n            CPU Time used:   00:00:01.5262\n\n        SAM24 instruction not defined on this box\n\n        SAM31 instruction not defined on this box\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BENCHMR2": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x020o\\x01\\x020o\\x17R\\x00!\\x00!\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T17:52:07", "lines": 33, "newlines": 33, "modlines": 0, "user": "IBMUSER"}, "text": "Output of the BENCHMRK program on a 2064-1C7 (z boxen):\n\nBenchmarks using 4,194,304 loops\n\n    Entry/Exit Housekeeping Methods\n\n        Using S/360 Instructions (STM/LM)\n            CPU Time used:   00:00:09.3219\n\n        Using ESA Instructions (BAKR/PR)\n            CPU Time used:   00:00:14.6652\n\n    Virtual Storage obtain/release Methods\n\n        Using Getmain/Freemain R\n            CPU Time used:   00:04:54.3725\n\n        Using Storage macro\n            CPU Time used:   00:05:51.3017\n\n    Addressing Mode switch\n\n        Using Old Branch method to 24-bit\n            CPU Time used:   00:00:00.7100\n\n        Using Old Branch method to 31-bit\n            CPU Time used:   00:00:00.7642\n\n        Using SAM24 instruction\n            CPU Time used:   00:00:00.2730\n\n        Using SAM31 instruction\n            CPU Time used:   00:00:00.2732\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CATME": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x01\\x020o\\x01\\x020o\\x18@\\x00`\\x00`\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T18:40:04", "lines": 96, "newlines": 96, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: CATME\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Catalog a dataset with generics like \"******\" or\n |          or system symbolics (which require double '&&' as\n |          in '&&SYSR2').\n |\n | Hint: Good for use in ISPF 3.4 VTOC lists.\n |\n | Written: 1996-03-17\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1996-2000 by David Alcock\n |             All rights reserved.\n */\n\narg dsn vol unit mcat\n\nif dsn == \"\" then do\n   say \"%CATME - No dataset given\"\n   call showsyntax\n   exit 8\n   end\n\nif vol == \"\" then do\n   say \"%CATME - No volume given\"\n   call showsyntax\n   exit 8\n   end\n\n/*\n * Allow: CATME 'SYS1.LINKLIB' SYSRES\n * Allow: CATME 'SYS1.LINKLIB' SYSRES . CATALOG.MASTER\n */\n\nif unit == \".\" then unit = \"3390\"\nif unit == \"\"  then unit = \"3390\"\n\n/*\n * If a catalog was specified, use it.\n */\n\nif mcat == \"\" then catalog = \"\"\nelse catalog = \"CATALOG('\"strip(mcat\")\"\n\n/*\n * Translate volume to generics or system symbolic\n */\nselect\n   when translate(strip(options)) == \"GENERIC\" then do\n        volume = \"******\"\n        end\n   when vol == '******' then volume = vol\n   when strip(substr(vol,1,1)) == '&' then volume = vol\n   otherwise\n        say \"%CATME - You need to specify a volume, generic or \"\n        say \"         system symbolic\"\n        call showsyntax\n        exit 8\n        end\n\ncommand = \"DEFINE NONVSAM (\" ,\n                           \"NAME(\"dsn\")\" ,\n                           \"VOLUMES(\"volume\")\" ,\n                           \"DEVICETYPES(\"unit\")\" ,\n                          \") \"catalog\nsay \"%CATME - About to issue command: +\"\nsay command\n\naddress TSO command\ndefrc = rc\nsay \"%CATME - Catalog return code (from DEFINE NONVSAM) was \"defrc\nexit defrc\n\nshowsyntax:\nsay \" \"\nsay \"Syntax: \"\nsay \" \"\nsay \"%CATME 'SYS1.BOZO.CLOWNLIB' SYS001\"\nsay \"%CATME 'SYS1.BOZO.CLOWNLIB' SYS001 3390\"\nsay \"%CATME 'SYS1.BOZO.CLOWNLIB' SYS001 3390 CATALOG.MASTER\"\nsay \"%CATME 'SYS1.BOZO.CLOWNLIB' SYS001 . CATALOG.MASTER\"\nsay \"%CATME 'SYS1.BOZO.CLOWNLIB' ******\"\nsay \"%CATME 'SYS1.BOZO.CLOWNLIB' &&SYSR2\"\nsay \"%CATME 'SYS1.BOZO.CLOWNLIB' &&SYSR3\"\nsay \" \"\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CA90S": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x020o\\x01\\x020o\\x18#\\x00;\\x002\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T18:23:46", "lines": 59, "newlines": 50, "modlines": 0, "user": "IBMUSER"}, "text": "/* Rexx\n |\n | Name: CA90S\n |\n | Purpose: Invoke all of the CA90 services inquiry programs\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.\n */\n\"TSOEXEC CAIRIMU\"\nsay \" \"\nsay \"Hit the Enter key for more...\"\npull it\n\"TSOEXEC CAISMFU\"\nsay \" \"\nsay \"Hit the Enter key for more...\"\npull it\n\"TSOEXEC CAISUBU\"\nsay \" \"\nsay \"Hit the Enter key to end\"\npull it\nexit 0\n\n/* Here is a started task you can start via your CAS9 started task\n   which does the same thing.  Put it in your //AUTOCMDS list to be\n   kicked off at CAS9 startup time\n\n//CAS9INFO PROC\n//*-----------------------------------------------------------------***\n//*                                                                 ***\n//* DISPLAY ALL OF THE CA90S INFORMATION WE CAN TO THE CONSOLE      ***\n//*                                                                 ***\n//*-----------------------------------------------------------------***\n//*\n//** INVOKE  THE  CAI  RESOURCE INITIALIZATION MANAGER UTILITY.\n//** CAIRIMU  DISPLAYS  THE  CURRENT  STATUS OF ALL INSTALLED CAI\n//** PRODUCTS.\n//*\n//CAIRIMU  EXEC PGM=CAIRIMU\n//*\n//** INVOKE  THE  CAI  DYNAMIC  SMF  DATA  INTERCEPTOR UTILITY.\n//** CAISMFU  DISPLAYS  THE  CURRENT  STATUS OF ALL INSTALLED  CAI\n//** SMF INQUIRY AND MANAGEMENT ROUTINES.\n//*\n//CAISMFU  EXEC PGM=CAISMFU\n//*\n//** INVOKE  THE  CAI   SUBSYSTEM  INTERFACE  UTILITY.  CAISUBU\n//** DISPLAYS  THE  CURRENT   STATUS  OF  ALL SUBSYSTEMS INSTALLED VIA\n//** CAIRIM. OUTPUT IS ISSUED\n//*\n//CAISUBU  EXEC PGM=CAISUBU\n\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBT$XREF": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00P\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18B\\x01\\xbb\\x01\\xbd\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:42:50", "lines": 443, "newlines": 445, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: CBT$XREF\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Process a new CBT \"tape\" (on DASD) and perform various\n |          Cross Reference functions.\n |\n |          This utility creates MVS/Quickref user database items in\n |          MVS/Quickref version 5.1 format.\n |\n | Assumptions:\n | - The format of the FILE001 and FILE003 CBT tapes remain unchanged.\n | - The CBT tape is layed down with standard names:\n |   index.FILExxx.DATA or index.FILExxx.PDS\n |\n | Sample job stream:\n |\n |  //*\n |  //** PROCESS THE FILE001 AND FILE003 MEMBERS AND CREATE XREFS\n |  //*\n |  //CBT$XREF EXEC PGM=IKJEFT01,PARM='%CBT$XREF',\n |  //         TIME=1439,DYNAMNBR=100\n |  //SYSEXEC  DD DISP=SHR,DSN=ibmuser.EXEC <- Home of CBT$XREF\n |  //SYSTSPRT DD SYSOUT=*\n |  //SYSTSIN  DD DUMMY\n |  //*\n |  //FILE001  DD DISP=SHR,DSN=CBT.V415.FILE001.DATA\n |  //FILE003  DD DISP=SHR,DSN=CBT.V415.FILE003.DATA\n |  //QWUSERDB DD DSN=&&QWUSERDB,\n |  //            DISP=(,CATLG),UNIT=SYSDA,\n |  //            DCB=(LRECL=80,BLKSIZE=8800,RECFM=FB),\n |  //            SPACE=(CYL,(60,60))\n |  //SORTIN   DD DSN=&&SORTIN,\n |  //            DISP=(,CATLG),UNIT=SYSDA,\n |  //            DCB=(LRECL=12,BLKSIZE=1200,RECFM=FB),\n |  //            SPACE=(CYL,(15,15))\n |  //SORTOUT  DD DSN=&&SORTOUT,\n |  //            DISP=(,CATLG),UNIT=SYSDA,\n |  //            DCB=(LRECL=12,BLKSIZE=1200,RECFM=FB),\n |  //            SPACE=(CYL,(15,15))\n |  //SYSIN    DD DSN=&&SYSIN,\n |  //            DISP=(,CATLG),UNIT=SYSDA,\n |  //            DCB=(LRECL=80,BLKSIZE=800,RECFM=FB),\n |  //            SPACE=(TRK,(1,1))\n |  //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(10),,CONTIG)\n |  //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(10),,CONTIG)\n |  //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(10),,CONTIG)\n |  //SYSOUT   DD SYSOUT=*\n |  //*\n |  //** SEE WHAT THE USER DATABASE CONTROL CARDS LOOK LIKE\n |  //*\n |  //SAVEIT   EXEC PGM=IEBGENER\n |  //SYSIN    DD DUMMY\n |  //SYSPRINT DD SYSOUT=*\n |  //SYSUT1   DD DISP=SHR,DSN=&&QWUSERDB\n |  //SYSUT2   DD SYSOUT=*\n |  //*\n |  //** DELETE USER LIBRARY\n |  //*\n |  //DELOLD EXEC PGM=IDCAMS\n |  //SYSPRINT DD SYSOUT=*\n |  //SYSIN    DD *\n |    DELETE 'SYS3.QUICKREF.USERDB'\n |  //*\n |  //** CREATE MVS/QUICKREF USER DATABASE\n |  //*\n |  //USERDB EXEC PGM=QWIKREF2,REGION=8M,PARM='OLDKEYS=N'\n |  //STEPLIB  DD DISP=SHR,DSN=SYS3.QUICKREF.LOAD\n |  //SYSPRINT DD SYSOUT=*\n |  //DATAIN   DD DISP=OLD,DSN=&&QWUSERDB\n |  //QWREFDD  DD DSN=SYS3.QUICKREF.USERDB,\n |  //            DISP=(,CATLG,DELETE),\n |  //            UNIT=3390,VOL=SER=PPXA20,\n |  //            DCB=(RECFM=F,BLKSIZE=6160,LRECL=6160), <-DO NOT CHANGE!\n |  //            SPACE=(TRK,(90,30),RLSE)\n |  //SYSIN    DD DUMMY\n |  //SYSOUT    DD SYSOUT=*\n |  //SORTIN   DD UNIT=SYSDA,SPACE=(CYL,(20),,CONTIG)\n |  //SORTOUT  DD UNIT=SYSDA,SPACE=(CYL,(20),,CONTIG)\n |  //SORTWK01 DD UNIT=SYSDA,SPACE=(CYL,(20),,CONTIG)\n |  //SORTWK02 DD UNIT=SYSDA,SPACE=(CYL,(20),,CONTIG)\n |  //SORTWK03 DD UNIT=SYSDA,SPACE=(CYL,(20),,CONTIG)\n |\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code provided.\n |             It is copyright 1998-2002+ by David Alcock.\n |             All rights reserved.\n */\n\n/**********************************************************************\n*           M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ---------------------------------------------\n* DGAlcock   05-MAY-1998 v1.0 Initial exec written\n**********************************************************************/\n\n/*---------------------------------------------------------------------\n | Installation dependant code\n ------------------------------------------------------------------- */\n\nvnew_max = 10 /* Max Number of \"New for Vxxx\" to create */\n\n/*---------------------------------------------------------------------\n | Dave's standard starting messages\n ------------------------------------------------------------------- */\n\nvrm = '1.0'\n\nmtype = address()\nPARSE SOURCE s1 s2 s3 s4 s5 s6 s7 s8 s9\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then systemid = mvsvar(syssmfid)\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        systemid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse systemid = \"\"\n\nsay \"CBT$XREF - version \"vrm \"- Freeware - CBT tape XREF utility\"\nsay \"Copyright 1998 by David Alcock. All rights reserved.\"\nsay \" \"\nsay \". Executing in Environment: \"s1 \"-\" mtype\nif systemid <> \"\" then say \". Executing on system: \"systemid\nelse do\n     say \"This exec is meant to be executed on a MVS (OS/390)\" ,\n         \"system only, terminating\"\n     signal quickout\n     end\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Misc initializations\n ------------------------------------------------------------------- */\n\naddress TSO \"NEWSTACK\"        /* output to DDNAME=QWUSERDB */\n\nqueue \"KCAD C=CBT-TAPE\" ,\n      \"D='MVS Freeware and Public Domain software'\"\n/*        ....+....1....+....2....+....3....+....4....+... */\n\ncbtver = \"???\"\ncbtdate = \"\"\n\n/*---------------------------------------------------------------------\n | Process CBT file 001\n ------------------------------------------------------------------- */\n\nsay \"File 001 processing begins\"\n\nx = LISTDSI(\"FILE001\" \"FILE\")\nif x <> 0 then do\n   say \"Error accessing DD=FILE001\"\n   say \"> \"sysmsglvl1\n   say \"> \"sysmsglvl2\n   say \"> SYSREASON: \"sysreason\n   exit\n   end\nfile1_dsn = sysdsname\nparse value file1_dsn with cbtindex \"FILE001.DATA\"\nif cbtindex == \"\" then do\n   say \" \"\n   say \"Non-Standard CBT File001 file found\"\n   cbtindex = \"<unknown>\"\n   end\nsay \"Reading file: '\"file1_dsn\"'\"\n\n\"EXECIO * DISKR FILE001 (FINIS STEM file1.\"\n\nin_header = 1\nin_vnew = 0\nin_doc = 0\nin_file = 0\nfilenum = \"\"\nfilecnt = 0\ncurv = \"\"\nvnew_cur = 0\n\ndo i = 1 to file1.0\n\n   if in_header == 1 then do\n      if word(file1.i,3) == \"VERSION\" then ,\n         if word(file1.i,4) == \"#\" then ,\n            cbtver = word(file1.i,5)\n         else cbtdate = word(file1.i,4)\n      if substr(file1.i,1,8) == \"//***CBT\" then in_header = 0\n\n      end\n\n   if substr(file1.i,1,13) == \"//***SECTION \" then do\n      in_header = 0\n      in_vnew = 0\n      in_doc = 0\n      in_file = 0\n\n      if substr(file1.i,14,2) == \"V-\" then do\n         vnew_cur = vnew_cur + 1\n\n\n         if vnew_cur > vnew_max then iterate\n\n         in_vnew = 1\n         vnum = substr(file1.i,16,3)\n         say \"Created _NEW\"vnum\" MVS/Quickref item\"\n         queue \"K V='CBT' P='CBTINDEX' R='\"cbtver\"' I=_NEW\"vnum\n         end\n      if substr(file1.i,14,3) == \"DOC\" then do\n         in_doc = 1\n         say \"Processing file section\"\n         end\n\n      end\n\n   if in_vnew then queue \" \"substr(file1.i,6,63)\n   if in_doc  then do\n      if substr(file1.i,1,9) == \"//***FILE\" then do\n         in_file = 1\n         filecnt = filecnt + 1\n         filenum = substr(file1.i,11,3)\n         queue \"K V='CBT' P='CBTINDEX' R='\"cbtver\"' I=FILE\"filenum\n         end\n      if filenum == \"\" then iterate\n      end\n   if in_file then queue \" \"substr(file1.i,6,63)\n\n   end\n\n\nsay \"Created \"filecnt\" FILExxx MVS/Quickref items\"\nsay \"File 001 processing ends\"\n\n/*---------------------------------------------------------------------\n | Now that we have the CBT version and creation date, lets create\n | the category association and create the $$README entry in CBTINDEX\n ------------------------------------------------------------------- */\n\nqueue \"KCAP V='CBT' P='CBTINDEX' R='\"cbtver\"' C=CBT-TAPE\"\n\n/*\n | create the $$README entry for the CBTINDEX\n */\n\nqueue \"K V='CBT' P='CBTINDEX' R='\"cbtver\"' I=$$README\"\nqueue \" The CBT tape is comprised of MVS freeware (copyrighted) and \"\nqueue \" public domain (non-copyrighted) software that has been made \"\nqueue \" available free of charge.\"\nqueue \" \"\nqueue \"    CBT tape version: \"cbtver\" - created on \"cbtdate\nqueue \" \"\n\n/* Put installation information here */\n\nif substr(systemid,1,3) == \"XYZ\" then do\n   queue \" At XYZ, the CBT tape has been saved into a FDR backup.\"\n   queue \" Here is a sample jobstream to restore a CBT file:\"\n   queue \" \"\n   queue \"   //RESTORE EXEC PGM=FDRDSF,REGION=4096K,TIME=1439   \"\n   queue \"   //SYSPRINT DD SYSOUT=*                             \"\n   queue \"   //SYSUDUMP DD SYSOUT=*                             \"\n   queue \"   //DISK1    DD UNIT=3380,VOL=SER=WRK205,DISP=SHR    \"\n   queue \"   //TAPE1    DD DISP=SHR,DSN=ibmuser.XBACKUP.CBT\"cbtver\n   queue \"   //SYSIN    DD *                                    \"\n   queue \"       RESTORE TYPE=DSF,DSNENQ=TEST                   \"\n   queue \"       EXCLUDE DSG=SYS1.VVDS                          \"\n   queue \"       SELECT  DSG=SYS9.SYS.CBT.V\"cbtver\".FILE183\"\n   end\n\n\n/*---------------------------------------------------------------------\n | Process CBT file 3 to get datasets with PDS members\n ------------------------------------------------------------------- */\n\nsay \" \"\nsay \"File 003 processing begins\"\n\n/*\n |   Ensure the file looks good, allocate it and read it in\n */\n\nx = LISTDSI(\"FILE003\" \"FILE\")\nif x <> 0 then do\n   say \"Error accessing DD=FILE003\"\n   say \"> \"sysmsglvl1\n   say \"> \"sysmsglvl2\n   say \"> SYSREASON: \"sysreason\n   signal file3x\n   end\nfile3_dsn = sysdsname\n/* If file1 had non-standard name, try file3 */\nif cbtindex == \"<unknown>\" then do\n   parse value file3_dsn with cbtindex \"FILE003.DATA\"\n   if cbtindex == \"\" then do\n      say \" \"\n      say \"Non-Standard CBT File003 file found\"\n      cbtindex = \"<unknown>\"\n      end\n   end\nsay \"Reading file: '\"file3_dsn\"'\"\n\n\"EXECIO * DISKR FILE003 (FINIS STEM file3.\"\n\n/*\n |  Process file 3 contents, pick out PDSs and process them\n */\n\naddress TSO \"NEWSTACK\"   /* output to DDNAME=SORTIN */\n\nmemtot = 0\np = 0\n\ndo i = 1 to file3.0\n   if substr(file3.i,1,9) == \"//STEPLIB\" then iterate\n   if substr(file3.i,1,6) == \"//STEP\" then do\n      parse value file3.i with . \"EXEC\" util \",LAB=\" num .\n      if num == \"\" then iterate\n      num = substr(num,1,3)   /* strip off any trailing stuff */\n      util = strip(util)\n      if substr(util,1,5) <> \"GENER\" then do\n         p = p + 1\n\n         x = outtrap(\"filemem.\",\"*\")\n         \"LISTD '\"cbtindex\"FILE\"num\".PDS' MEMBERS\"\n         lrc = rc\n         x = outtrap(\"off\")\n\n         do m = 1 to filemem.0\n            if filemem.m = \"--MEMBERS--\" then leave\n            end\n\n         if m == filemem.0 then do\n            say \"No members found for '\"cbtindex\"FILE\"num\".PDS'\" ,\n                \"LISTD RC=\"lrc\n            end\n         else do\n              k = filemem.0 - m\n              say \"Processing '\"cbtindex\"FILE\"num\".PDS',\" ,\n                  \"number of members: \"k\n              do j = m to filemem.0\n                 queue substr(filemem.j,3,8) num\n                 memtot = memtot + 1\n                 end\n              end\n         end\n      end\n   end\n\nsay \"Processed \"p\" PDS datasets - total members: \"memtot\n\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW SORTIN (FINIS\"\naddress TSO \"DELSTACK\"\n\n/*\n |  Create the sort control card\n |\n |                          123456789012\n |  File records look like \"MMMMMMMM NNN\"\n */\n\naddress TSO \"NEWSTACK\"\nqueue ' SORT  FIELDS=(1,8,CH,A,10,3,CH,A)'\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW SYSIN    (FINIS\"\naddress TSO \"DELSTACK\"\n\n/*\n | Invoke the system sort - sort by member name\n */\n\n\"TSOEXEC SORT\"\nsortrc = rc\nsay \"Completed sort of members, SORT RC=\"sortrc\n\n/*\n | If the sort was successful, create new MVS/Quickref items.\n */\n\nmemcnt = 0\n\nif sortrc == 0 then do\n   \"EXECIO * DISKR SORTOUT (FINIS STEM sortout.\"\n   lastmem = \"\"\n   lastpre = \"\"\n   do i = 1 to sortout.0\n      parse value sortout.i with member num\n      num = strip(num)\n      member = strip(member)\n\n      if member <> lastmem then do\n         lastmem = member\n         memcnt = memcnt + 1\n\n         f = substr(member,1,1)\n         queue \"K V='CBT' P='CBTMEM\"f\"' R='\"cbtver\"' I=\"member\n\n         if lastpre <> f then do\n            say   \"New member prefix:\" f\n            queue \"KCAP V='CBT' P='CBTMEM\"f\"' R='\"cbtver\"' C=CBT-TAPE\"\n            lastpre = f\n            end\n\n         end\n\n      queue \" Member=\"member\" found in DSN=\"cbtindex\"FILE\"num\".PDS\"\n      end\n\n   end\n\nsay \" \"\nsay \"Created \"memcnt\" MVS/Quickref items for members\"\n\n\n/*\n | End of processing of file 003\n */\n\nfile3x:\nsay \"File 003 processing ends\"\n\n/*---------------------------------------------------------------------\n | Terminate: Write out the user database and leave\n ------------------------------------------------------------------- */\n\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW QWUSERDB (FINIS\"\naddress TSO \"DELSTACK\"\n\nquickout:\nsay \" \"\nsay \"End of processing\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLIPBRD": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x00\\x00\\x00\\x00\\x99\\x06\\x0f\\x00\\x99\\x06\\x0f\\x14\\x14\\x02\\xa2\\x02\\xa2\\x00\\x00\\xc4\\xc1\\xe5\\xc5\\xc1@@@@@'", "ispf": {"version": "20.00", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "1999-03-01T14:14:00", "lines": 674, "newlines": 674, "modlines": 0, "user": "DAVEA"}, "text": "./ ADD NAME=$$README 1100-98162-98162-1817-00047-00047-00000-DALCOCK\nReadme file for the ClipBoard/PasteIt! ISPF app v1.1 - 27-MAY-1998\n\nThis ISPF application enhances the IBM-supplied ISRCUT and ISRPASTE\nedit macros:\n\n- Provides a Paste Area for when the input area of the screen is\n  too small to fit the current paste value\n\n- View, Print, Edit the current cut lines - known as the Clip Board.\n\n=====================================================================\n\nFriendly disclaimer:\n-------------------\n\n   The contents of this file are FREEWARE.  Use at your own risk.  It\n   is provided for your enjoyment and neither David Alcock or his\n   employer provides any warranty for their use.  I'd like to hear\n   feedback on how they work on your system:\n\n       David Alcock\n       dalcock@csw.com ...... Internet email (work)\n       davea@ticnet.com ..... Internet email (home)\n\nLegal disclaimer:\n----------------\n\n   The ClipBoard/PasteIt! application IS PROVIDED \"AS IS\" AND\n   WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\n   LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND\n   FITNESS FOR A PARTICULAR PURPOSE.\n\n=====================================================================\n\nTo install:\n\n- Put members CLIPBRD and PASTEIT in your //SYSPROC or //SYSEXEC\n  concatenation\n\n- Put members CLIPBRDE, CLIPBRDI, CLIPBRD2, CLIPBRD3, CLIPBRD4 and\n  CLIPBRD5 into your //ISPPLIB concatenation\n\n  Please note that the panel name CLIPBRDI is not suffixed with the\n  number 1 but the letter I.\n\n=====================================================================\nEnd of member $$README - ClipBoard/PasteIt! application\n./ ADD NAME=CLIPBRD  1100-98162-98162-1817-00196-00196-00000-DALCOCK\n/* REXX\n |\n | Name: CLIPBRD\n |\n | Application: ClipBoard/PasteIt!\n |\n | Author: David Alcock\n |         dalcock@csw.com\n |         davea@ticnet.com\n |\n | Purpose: This exec shows the current \"clip board\" as used by the IBM\n |          ISRCUT and ISRPASTE edit macros.  You can then print the\n |          clip board, edit it, delete it, etc.\n |\n | Requirements: This exec uses the specs from the IBM-supplied\n |               ISRCUT and ISRPASTE edit macros that are shipped\n |               with ISPF.  On my OS/390 1.2 system, these edit macros\n |               are found in DSN=ISP.SISPSAMP.  At many shops, this\n |               dataset is renamed to SYS1.ISP.SISPSAMP.\n |\n |               Typically, your systems programmer will copy the\n |               ISRCUT and ISRPASTE members from the sample library\n |               and put them into your installation's //SYSPROC or\n |               //SYSEXEC concatenation as names \"CUT\" and \"PASTE\".\n |\n | Panels: CLIPBRDE\n |\n | Terms: Only on IBM mainframes is the \"COPY\" function termed \"CUT\"\n |        (in my experience).\n |\n | Obsolete: IBM is planning very big enhancements in ISPF clipboards\n |           as heard at the February 1998 SHARE.  This EXEC will\n |           probably continue to work but the new clipboard sounds very\n |           nice.\n |\n */\n/* ================================================================= *\n |\n |           M o d i f i c a t i o n   H i s t o r y\n |\n | Person     Date        Description\n | ---------- ----------- --------------------------------------------\n | DGAlcock   11-JUN-1998 v1.0:\n |                        - Initial Rexx exec created;\n * ================================================================= */\n\n/*\n | Installation fields to change\n */\n\ni_dsn       = sysvar(sysuid)\".SPFTEMP1.CLIP.BOARD\"\ni_unitname  = 'VIO'                   /* Temp file unit name */\n\n/*\n | Validate clipboard option: browse, edit or view\n */\naddress ISPEXEC\n\narg option\noption = translate(strip(option))\nselect\n    when option == ''       then option = 'BROWSE'\n    when option == 'BROWSE' then nop\n    when option == 'BR'     then option = 'BROWSE'\n    when option == 'EDIT'   then nop\n    when option == 'ED'     then option = 'EDIT'\n    when option == 'VIEW'   then do\n         'vget (ZENVIR)'\n         if substr(zenvir,6,1) < '4' then do /* 'ISPF x.x' */\n            zedsmsg = 'Browse used'\n            zedlmsg = 'Browse substituted for View for pre-ISPF v4'\n            'SETMSG MSG(ISRZ001)'\n            option = 'BROWSE'\n            end\n         end\n    otherwise\n        zedsmsg = 'Invalid option'\n        zedlmsg = 'Must be BR, BROWSE, ED, EDIT or VIEW'\n        'SETMSG MSG(ISRZ001)'\n        exit\n        end\n\n/*\n | Get the current number of lines that have been cut and exit if it\n | is empty\n */\n\n'VGET (CUTCNT) PROFILE'\n\nif cutcnt == 0 then do\n   zedsmsg = ''\n   zedlmsg = 'The ISRCUT/ISRPASTE Clipbord is empty'\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\n/*\n | Create a new dataset that the user can edit\n */\n\naddress TSO\n'newstack'\naddress ISPEXEC\n\nlrecl = 0\ndo i = 1 to cutcnt\n   'VGET (CL'i')'\n   interpret 't = CL'i\n   if t == '' then t = ' '  /* Null lines means end-of-file */\n   queue t\n   lrecl = max(lrecl,length(t))\n   end\n\naddress TSO\n\nclipbrd_dsn = \"'\"i_dsn\"'\"\n\nx = outtrap(\"XMSG.\",\"*\")\n'DELETE 'clipbrd_dsn\nx = outtrap(\"off\")\n\nclipbrd_dd = 'clpb'random()\n'ALLOCATE FILE('clipbrd_dd') DA('clipbrd_dsn')',\n         'UNIT('i_unitname') NEW REUSE SPACE(30 30) TRACKS',\n         'LRECL('lrecl') BLKSIZE(32760) RECFM(V B)'\n\n\nqueue ''      /* add null line to indicate End-Of-File */\n'EXECIO * DISKW 'clipbrd_dd' (FINIS'\n'DELSTACK'\n\n/*\n | Let the user perform an edit on the \"clip board\"\n */\n\naddress ISPEXEC\n'CONTROL ERRORS RETURN'\noption ' DATASET('clipbrd_dsn')' /* Browse, Edit or View */\nerc = rc\n'CONTROL ERRORS CANCEL'\n\n/*\n | If the user modified the contents of the clip board, let him\n | decide whether to save the modified clip board\n */\n\nif option <> 'EDIT' then signal theend\n\nif erc == 0 then do\n   'ADDPOP'\n   'DISPLAY PANEL(CLIPBRDE)'\n   orc = rc\n   'REMPOP'\n   if orc <> 0 then do\n      zedsmsg = 'Cancelled'\n      zedlmsg = 'Did not replace the clip board as requested'\n      'SETMSG MSG(ISRZ001)'\n      end\n   else do\n        address TSO\n        \"EXECIO * DISKR \"clipbrd_dd\" (FINIS STEM mclip.\"\n        address ISPEXEC\n        do i = 1 to mclip.0\n           interpret 'CL'i '= mclip.'i\n           'VPUT (CL'i') PROFILE'\n           end\n\n        if mclip.0 > cutcnt then ,\n           do i = (mclip.0 + 1)  to cutcnt\n              'VERASE (CL'i') PROFILE'\n              end\n\n        cutcnt = mclip.0\n        'VPUT (CUTCNT) PROFILE' /* Save new count of cut lines */\n\n        end\n   end\n\n/*\n | Delete the temporary clip board viewing dataset\n */\n\ntheend:\naddress TSO\nx = outtrap(\"XMSG.\",\"*\")\n'DELETE 'clipbrd_dsn\n'FREE FILE('clipbrd_dd')'\nx = outtrap(\"off\")\n\nexit 0\n\n/* | ---------EEEEEEEE---------NN-----NN---------DDDDDDD--------- |\n   | ---------EE---------------NNNN---NN---------DD----DD-------- |\n   | ---------EEEEE------------NN-NN--NN---------DD----DD-------- |\n   | ---------EE---------------NN---NNNN---------DD----DD-------- |\n   | ---------EEEEEEEE---------NN----NNN---------DDDDDDD--------- | */\n./ ADD NAME=CLIPBRDE 1100-98162-98162-1817-00020-00020-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: CLIPBRDE                                                   */\n /* Author: David Alcock                                             */\n /* Application: ClipBoard/PasteIt!                                  */\n /* Purpose: Startup display                                         */\n /********************************************************************/\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n # type(text) intens(low)  color(green)\n)body window(65,6)\n\n~You have changed the contents of the#Clip Board~while you were\n~editing it.  You have the choice to save the changes you made.\n\n_Z~Hit`ENTER~to replace the#Clip Board~or`END~to cancel.\n)init\n  .ZVARS = '(CURSOR)'\n)proc\n)end\n./ ADD NAME=CLIPBRDI 1100-98162-98162-1817-00022-00022-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: CLIPBRDI                                                   */\n /* Author: David Alcock                                             */\n /* Application: ClipBoard/PasteIt!                                  */\n /* Purpose: Startup display from the PASTEIT Rexx exec              */\n /********************************************************************/\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n # type(text) intens(low)  color(red)\n)body window(65,7)\n\n~A completely blank screen will appear that you can paste data\n~into.  The data will be available via the IBM PASTE command.\n#Please note that the screen width is one less than shown.\n\n_Z~Hit`ENTER~to get the blank paste screen or`END~to cancel.\n\n)init\n  .ZVARS = '(CURSOR)'\n)proc\n)end\n./ ADD NAME=CLIPBRD2 1100-98162-98162-1817-00036-00036-00000-DALCOCK\n)attr\n /********************************************************************/\n /* Name: CLIPBRD2                                                   */\n /* Author: David Alcock                                             */\n /* Application: ClipBoard/PasteIt!                                  */\n /* Purpose: Put up a screen to get pasted data for model 2          */\n /********************************************************************/\n $ type(input) intens(high) color(white) just(asis) caps(off)\n)body\n$line1\n$line2\n$line3\n$line4\n$line5\n$line6\n$line7\n$line8\n$line9\n$line10\n$line11\n$line12\n$line13\n$line14\n$line15\n$line16\n$line17\n$line18\n$line19\n$line20\n$line21\n$line22\n$line23\n$line24\n)init\n)proc\n)end\n./ ADD NAME=CLIPBRD3 1100-98162-98162-1817-00044-00044-00000-DALCOCK\n)attr\n /********************************************************************/\n /* Name: CLIPBRD3                                                   */\n /* Author: David Alcock                                             */\n /* Application: ClipBoard/PasteIt!                                  */\n /* Purpose: Put up a screen to get pasted data for model 3          */\n /********************************************************************/\n $ type(input) intens(high) color(white) just(asis) caps(off)\n)body\n$line1\n$line2\n$line3\n$line4\n$line5\n$line6\n$line7\n$line8\n$line9\n$line10\n$line11\n$line12\n$line13\n$line14\n$line15\n$line16\n$line17\n$line18\n$line19\n$line20\n$line21\n$line22\n$line23\n$line24\n$line25\n$line26\n$line27\n$line28\n$line29\n$line30\n$line31\n$line32\n)init\n)proc\n)end\n./ ADD NAME=CLIPBRD4 1100-98162-98162-1817-00056-00056-00000-DALCOCK\n)attr\n /********************************************************************/\n /* Name: CLIPBRD4                                                   */\n /* Author: David Alcock                                             */\n /* Application: ClipBoard/PasteIt!                                  */\n /* Purpose: Put up a screen to get pasted data for model 4          */\n /********************************************************************/\n $ type(input) intens(high) color(white) just(asis) caps(off)\n)body\n$line1\n$line2\n$line3\n$line4\n$line5\n$line6\n$line7\n$line8\n$line9\n$line10\n$line11\n$line12\n$line13\n$line14\n$line15\n$line16\n$line17\n$line18\n$line19\n$line20\n$line21\n$line22\n$line23\n$line24\n$line25\n$line26\n$line27\n$line28\n$line29\n$line30\n$line31\n$line32\n$line32\n$line33\n$line34\n$line35\n$line36\n$line37\n$line38\n$line39\n$line40\n$line41\n$line42\n$line43\n)init\n)proc\n)end\n./ ADD NAME=CLIPBRD5 1100-98162-98162-1817-00039-00039-00000-DALCOCK\n)attr\n /********************************************************************/\n /* Name: CLIPBRD5                                                   */\n /* Author: David Alcock                                             */\n /* Application: ClipBoard/PasteIt!                                  */\n /* Purpose: Put up a screen to get pasted data for model 5 terms    */\n /********************************************************************/\n $ type(input) intens(high) color(white) just(asis) caps(off)\n)body\n$line1\n$line2\n$line3\n$line4\n$line5\n$line6\n$line7\n$line8\n$line9\n$line10\n$line11\n$line12\n$line13\n$line14\n$line15\n$line16\n$line17\n$line18\n$line19\n$line20\n$line21\n$line22\n$line23\n$line24\n$line25\n$line26\n$line27\n)init\n)proc\n)end\n./ ADD NAME=PASTEIT  1100-98162-98162-1817-00204-00204-00000-DALCOCK\n/* REXX\n |\n | Name: PASTEIT\n |\n | Application: ClipBoard/PasteIt!\n |\n | Author: David Alcock\n |         dalcock@csw.com\n |         davea@ticnet.com\n |\n | Purpose: Provide a Paste area for those times the area on the screen\n |          is just a tad too small for text to get pasted into.\n |\n |          You could use this with your 3270 terminal emulator and\n |          your dumb terminal (with multi-session manager that provides\n |          a CUT and PASTE function).\n |\n | Requirements: This exec uses the specs from the IBM-supplied\n |               ISRCUT and ISRPASTE edit macros that are shipped\n |               with ISPF.  On my OS/390 1.2 system, these edit macros\n |               are found in DSN=ISP.SISPSAMP.  At many shops, this\n |               dataset is renamed to SYS1.ISP.SISPSAMP.\n |\n |               Typically, your systems programmer will copy the\n |               ISRCUT and ISRPASTE members from the sample library\n |               and put them into your installation's //SYSPROC or\n |               //SYSEXEC concatenation as names \"CUT\" and \"PASTE\".\n |\n | Terms: Only on IBM mainframes is the \"COPY\" function termed \"CUT\"\n |        (in my experience).\n |\n | Multi-Session-Managers:\n | - CA-TPX (formerly from Legent): has CUT and PASTE functions\n |   available for dumb terminals.\n | - Candle?\n | - NetMaster?\n |\n | Obsolete: IBM is planning very big enhancements in ISPF clipboards\n |           as heard at the February 1998 SHARE.  This EXEC will\n |           probably continue to work but the new clipboard sounds very\n |           nice.\n |\n */\n/* ================================================================= *\n |\n |           M o d i f i c a t i o n   H i s t o r y\n |\n | Person     Date        Description\n | ---------- ----------- --------------------------------------------\n | DGAlcock   11-JUN-1998 v1.1:\n |                        - This exec was renamed from CLIPBRD to\n |                          PASTEIT to better reflect what it does;\n |                        - Don't include blank lines from the paste\n |                          screen (from the bottom up);\n |                        - Be a better ISPF application and use ISPF\n |                          messages instead of REXX says;\n |                        - Misc code cleanup and better comments;\n |\n | DGAlcock   20-MAY-1997 V1.0:\n |                        - Initial application created; This was a\n |                          quick and dirty, fast implementation and not\n |                          very elegant - but it works.\n |\n * ================================================================= */\n\naddress ISPEXEC\n\n/*\n | Display the popup screen informing the user what to do when the\n | blank screen appears. Allow him to exit application if he doesn't\n | want to do it now.\n */\n\n'ADDPOP'\n'DISPLAY PANEL(CLIPBRDI)'\norc = rc\n'REMPOP'\nif orc <> 0 then do\n   zedsmsg = 'Cancelled'\n   zedlmsg = 'Cancelling PasteIt! application as requested'\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\n/*\n | Hurray! He wants to go thru with it.  Figure out the max number of\n | lines the terminal allows and set our panel to match it.\n */\n\n'vget (ZSCRMAXD)'\nselect\n  when zscrmaxd == '0027' then do\n       panelid = 'CLIPBRD5'\n       new_cutcnt = 27\n       end\n  when zscrmaxd == '0032' then do\n       panelid = 'CLIPBRD3'\n       new_cutcnt = 32\n       end\n  when zscrmaxd == '0043' then do\n       panelid = 'CLIPBRD4'\n       new_cutcnt = 43\n       end\n  otherwise\n       panelid = 'CLIPBRD2'\n       new_cutcnt = 24\n       end\n\nline1  = ''; line2  = ''; line3  = ''; line4  = ''; line5  = ''\nline6  = ''; line7  = ''; line8  = ''; line9  = ''; line10 = ''\nline11 = ''; line12 = ''; line13 = ''; line14 = ''; line15 = ''\nline16 = ''; line17 = ''; line18 = ''; line19 = ''; line20 = ''\nline21 = ''; line22 = ''; line23 = ''; line24 = ''; line25 = ''\nline26 = ''; line27 = ''; line28 = ''; line29 = ''; line30 = ''\nline31 = ''; line32 = ''; line33 = ''; line34 = ''; line35 = ''\nline36 = ''; line37 = ''; line38 = ''; line39 = ''; line40 = ''\nline41 = ''; line42 = ''; line43 = ''\n\n/*\n | Display the blank 'paste area' screen\n */\n\n'DISPLAY PANEL ('panelid')'\ndrc = rc\nif drc <> 0 then do\n   zedsmsg = 'Cancelled'\n   zedlmsg = 'Cancelling save of paste area as requested'\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\n/* Save our new cut lines */\nCL1  = line1;  cl2 =  line2 ;  cl3  = line3 ;  cl4 = line4;\nCL5  = line5;  cl6 =  line6 ;  cl7  = line7 ;  cl8 = line8;\nCL9  = line9;  cl10 = line10\nCL11 = line11; cl12 = line12 ; cl13 = line13 ; cl14 = line14;\nCL15 = line15; cl16 = line16 ; cl17 = line17 ; cl18 = line18;\nCL19 = line19; cl20 = line20\nCL21 = line21; cl22 = line22 ; cl23 = line23 ; cl24 = line24;\nCL25 = line25; cl26 = line26 ; cl27 = line27 ; cl28 = line28;\nCL29 = line29; cl30 = line30\nCL31 = line31; cl32 = line32 ; cl33 = line33 ; cl34 = line34;\nCL35 = line35; cl36 = line36 ; cl37 = line37 ; cl38 = line38;\nCL39 = line39; cl40 = line40\nCL41 = line41; cl42 = line42 ; cl43 = line43\n\n/*\n | Before we continue, let's get the previous number of cut lines.\n | We may need to delete old vars out of the profile later\n */\n\n'VGET (CUTCNT) PROFILE'\nold_cutcnt = cutcnt\n\n/*\n | Eliminate blank lines from our paste screen (from the bottom up)\n */\n\ndo i = new_cutcnt to 1 by -1\n   interpret 't = CL'i\n   if strip(t) <> '' then leave\n   new_cutcnt = new_cutcnt - 1\n   end\n\n/*\n | Update the count of cut lines in the user's ISPF profile\n */\n\ncutcnt = new_cutcnt  /* Set new profile value */\n'VPUT (CUTCNT) PROFILE' /* Save new count of cut lines in profile */\n\n/*\n | Did we end up with any lines\n */\n\nif new_cutcnt == 0 then do\n   zedsmsg = ''\n   zedlmsg = 'The paste area was completely blank, terminating'\n   'SETMSG MSG(ISRZ001)'\n   exit\n   end\n\n/*\n | Insert cut lines into the ISPF profile\n */\n\ndo i = 1 to cutcnt\n   'VPUT (CL'i') PROFILE'\n   end\n\nzedsmsg = ''\nzedlmsg = 'You are now ready to use the PASTE EDIT macro'\n'SETMSG MSG(ISRZ001)'\n\n/*\n | If the previous cut lines are more than our paste area, delete\n | them from the users profile: Don't leave junk in the profile.\n */\n\nif old_cutcnt > new_cutcnt then ,\n   do i = (new_cutcnt + 1)  to old_cutcnt\n      'VERASE (CL'i') PROFILE'\n      end\nexit\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 14:09 ON 99/03/01\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPPDS": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x020o\\x01\\x020o\\x19&\\x01/\\x01!\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T19:26:44", "lines": 303, "newlines": 289, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: COMPPDS\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Compare the contents of two PDS datasets.\n |\n | Requires: IBM's ISPF ISRSUPR compare utility\n |           IBM's ISPF LM services (needs to run under ISPF)\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code provided.\n |             It is copyright 2002+ by David Alcock.\n |             All Rights reserved.\n */\n\n/**********************************************************************\n*           M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ---------------------------------------------\n* DGAlcock   2002-08-09  v1.0 Initial version created;\n**********************************************************************/\n\n/*---------------------------------------------------------------------\n | Installation settings\n ------------------------------------------------------------------- */\n\nPDS_CMD = \"PDS\"   /* name of PDS command from CBT tape or Serena's\n                     starTools name */\n\ndiskunit = \"SYSALLDA\"  /* unit name for allocating compare datasets */\n\n\n/*---------------------------------------------------------------------\n | Create standard starting exec messages\n ------------------------------------------------------------------- */\n\nvrm = '1.0'\n\nmtype = address()\nPARSE SOURCE s1 s2 s3 s4 s5 s6 s7 s8 s9\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then do\n      systemid = mvsvar(syssmfid)\n      sysopsys = mvsvar('sysopsys')\n      osname = word(sysopsys,1)\n      osver  = word(sysopsys,2)\n      end\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        systemid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse do\n     systemid = \"\"\n     osname = \"\"\n     osver = \"\"\n     end\n\nsay \"COMPPDS - version \"vrm \"- Freeware - PDS compare\"\nsay \" \"\nsay \". Executing in Environment: \"s1 \"-\" mtype\nif systemid <> \"\" then say \". Executing on system: \"systemid\nelse do\n     say \"This Rexx exec can only execute properly on a OS/390\" ,\n         \"(MVS) mainframe\"\n     exit 12\n     end\nif osname <> \"\" then say \". Operating system: \"osname osver\nsay \". Date: \"date() \"Time:\" time()\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Create a PDS where we will put the COMPARE output\n ------------------------------------------------------------------- */\n\noutdsn = sysvar(SYSUID)\".SPFTEMP1.COMPPDS.OUTPUT\"\nx = outtrap(\"XMSG.\",\"*\")\naddress TSO \"DELETE '\"outdsn\"'\"\nx = outtrap(\"off\")\naddress TSO \"ALLOCATE FILE(OUTDD) DA('\"outdsn\"')\" ,\n            \"UNIT(\"diskunit\") NEW REUSE SPACE(90 90) DIR(64) TRACKS\",\n            \"LRECL(133) BLKSIZE(1330) RECFM(F B A)\"\nSay \"Compare output to file:\" outdsn\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Get the directory of the old library using ISPF LM services\n ------------------------------------------------------------------- */\n\nx = LISTDSI(OLDLIB \"FILE\")\nif x <> 0 then do\n   say \"Error with LISTDSI for //OLDLIB\"\n   EXIT 12\n   END\nolddsn = sysdsname\noldvol = sysvolume\n\naddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"LMINIT DATAID(OLDID) DATASET('\"OLDDSN\"') VOLUME(\"OLDVOL\")\"\n\"LMOPEN DATAID(\"OLDID\")\"\nMEMBER = ' '\n\"LMMLIST  DATAID(\"OLDID\") MEMBER(MEMBER) STATS(YES)\"\ndoldcnt = 0\ndo while RC = 0\n   doldcnt = doldcnt + 1\n   olddir.doldcnt = member\n   \"LMMLIST  DATAID(\"OLDID\") MEMBER(MEMBER) STATS(YES)\"\n   END\n\"LMFREE  DATAID(\"OLDID\")\"\nolddir.0 = doldcnt\nSay \"Processing OLD library:\" olddsn \"on volume\" oldvol ,\n    \"members:\" doldcnt\n\n/*---------------------------------------------------------------------\n | Get the directory of the new library using ISPF LM services\n ------------------------------------------------------------------- */\n\nx = LISTDSI(NEWLIB \"FILE\")\nif x <> 0 then do\n   say \"Error with LISTDSI for //NEWLIB\"\n   EXIT 12\n   END\nnewdsn = sysdsname\nnewvol = sysvolume\n\naddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"LMINIT DATAID(NEWID) DATASET('\"NEWDSN\"') VOLUME(\"NEWVOL\")\"\n\"LMOPEN DATAID(\"NEWID\")\"\nMEMBER = ' '\n\"LMMLIST  DATAID(\"NEWID\") MEMBER(MEMBER) STATS(YES)\"\ndnewcnt = 0\ndo while RC = 0\n   dnewcnt = dnewcnt + 1\n   newdir.dnewcnt = member\n   \"LMMLIST  DATAID(\"NEWID\") MEMBER(MEMBER) STATS(YES)\"\n   END\n\"LMFREE  DATAID(\"NEWID\")\"\nnewdir.0 = dnewcnt\nSay \"Processing NEW library:\" newdsn \"on volume\" newvol ,\n    \"members:\" dnewcnt\n\n/*---------------------------------------------------------------------\n | Compare the two partitioned datasets using the directory list.\n ------------------------------------------------------------------- */\n\nsay \" \"\noldcnt = 0\nnewcnt = 0\ndifcnt = 0\nsamecnt = 0\nmatcnt = 0\nmoldcnt = 0\nmnewcnt = 0\ntotal = 0\n\naddress TSO\ncall ReadOldDir                       /* Start on first member */\ncall ReadNewDir                       /* Start on first member */\n\nend_of_file = 0\n\ndo while end_of_file = 0\n\noldmem = word(oldrec,1)\nnewmem = word(newrec,1)\nselect\n  when oldmem == newmem then do\n       matcnt = matcnt + 1\n\n       \"ALLOC FILE(NEWDD) DA('\"newdsn\"(\"strip(newmem)\")') SHR REUSE\" ,\n                          \"VOLUME(\"newvol\") UNIT(\"diskunit\")\"\n\n       \"ALLOC FILE(OLDDD) DA('\"olddsn\"(\"strip(oldmem)\")') SHR REUSE\" ,\n                          \"VOLUME(\"oldvol\") UNIT(\"diskunit\")\"\n\n       \"ALLOC FILE(OUTDD) DA('\"outdsn\"(\"strip(oldmem)\")') SHR REUSE\"\n\n       \"CALL *(ISRSUPC) 'DELTAL,LINECMP,SEQ'\"\n       CRC = RC\n\n       /* If the compare showed exact match, delete the member from\n          the output PDS so we end up with only members with\n          differences in the compare output pds */\n\n       if CRC == 0 then do\n          samecnt = samecnt + 1\n          x = outtrap(\"XMSG.\",\"*\")\n          pds_cmd \"'\"outdsn\"' del \"oldmem\n          prc = rc\n          x = outtrap(\"off\")\n          if prc <> 0 then do i = 1 to xmsg.0\n             say \">\" xmsg.i\n             end\n          end\n\n       else difcnt = difcnt + 1\n\n       say left(\"Match for member:\",20) left(newmem,8) ,\n           \"Compare RC=\"crc\n\n       call ReadNewDir\n       call ReadOldDir\n       end\n  when oldeof == 1 then do\n       moldcnt = moldcnt + 1\n       Say Left(\"Missing in Old:\",20) left(newmem,8)\n       call ReadNewDir\n       end\n  when neweof == 1 then do\n       mnewcnt = mnewcnt + 1\n       Say Left(\"Missing in New:\",20) left(oldmem,8)\n       call ReadOldDir\n       end\n  when oldmem > newmem then do\n       moldcnt = moldcnt + 1\n       Say Left(\"Missing in Old:\",20) left(newmem,8)\n       call ReadNewDir\n       end\n  when newmem > oldmem then do\n       mnewcnt = mnewcnt + 1\n       Say Left(\"Missing in New:\",20) left(oldmem,8)\n       call ReadOldDir\n       end\n  otherwise\n       Say Left(\"Error!         \",20) newmem \"+\" oldmem\n       Exit 12\n       end\n\nif oldeof == 1 then ,\n   if neweof == 1 then end_of_file = 1\n\ntotal = total + 1\nend /* of \"do while end_of_file = 0\" */\n\n/*---------------------------------------------------------------------\n | Print summary and terminate\n ------------------------------------------------------------------- */\n\nsay \" \"\nsay \"Summary:\"\nsay \"o Total members. . . . . . . . . . . .\"total\nsay \"o Members in both old and new. . . . .\"matcnt\nsay \"o Members in both that differed. . . .\"difcnt\nsay \"o Members in both that were the same .\"samecnt\nsay \" \"\nsay \"o NEW library:\"\nsay \"  o Data set name. . . . . . . . . . .\"newdsn\nsay \"  o Volume . . . . . . . . . . . . . .\"newvol\nsay \"  o Total members. . . . . . . . . . .\"dnewcnt\nsay \"  o Members missing. . . . . . . . . .\"mnewcnt\nsay \" \"\nsay \"o OLD library:\"\nsay \"  o Data set name. . . . . . . . . . .\"olddsn\nsay \"  o Volume . . . . . . . . . . . . . .\"oldvol\nsay \"  o Total members. . . . . . . . . . .\"doldcnt\nsay \"  o Members missing. . . . . . . . . .\"moldcnt\nsay \" \"\nsay \" \"\n\nexit 0\n\n/*---------------------------------------------------------------------\n | Position to the next directory entry (new)\n ------------------------------------------------------------------- */\nReadNewDir:\nif (newcnt + 1) > newdir.0 then do\n   neweof = 1\n   return\n   end\n\nnewcnt = newcnt + 1\nnewrec = newdir.newcnt\nreturn\n\n/*---------------------------------------------------------------------\n | Position to the next directory entry (old)\n ------------------------------------------------------------------- */\nReadOldDir:\nif (oldcnt + 1) > olddir.0 then do\n   oldeof = 1\n   return\n   end\n\noldcnt = oldcnt + 1\noldrec = olddir.oldcnt\nreturn\n\n/*---------------------------------------------------------------------\n | End of COMPPDS Rexx exec - May the source be with you. ObiWan.\n ------------------------------------------------------------------- */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPPDSJ": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x020o\\x01\\x020o\\x16Y\\x00#\\x00#\\x00\\x00\\xc4\\xc1\\xd3\\xc3\\xd6\\xc3\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T16:59:18", "lines": 35, "newlines": 35, "modlines": 0, "user": "DALCOCK"}, "text": "      - job card here -\n//*\n//** INVOKE OS/390 ISPF IN BATCH TO COMPARE TWO PARTITIONED DATASETS\n//*\n//T$BATCH EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,\n//  PARM='ISPSTART CMD(%COMPPDS)'\n//*\n//OLDLIB   DD DISP=SHR,DSN=SYS1.PARMLIB,UNIT=3390,VOL=SER=RES1A1\n//NEWLIB   DD DISP=SHR,DSN=SYS1.PARMLIB,UNIT=3390,VOL=SER=RES1B1\n//*\n//SYSEXEC  DD DISP=SHR,DSN=ibmuser.CBTxxx.FILE311.PDS <- COMPPDS exec\n//SYSHELP  DD DISP=SHR,DSN=SYS1.ISP.SISPHELP\n//         DD DISP=SHR,DSN=SYS1.HELP\n//SYSPROC  DD DISP=SHR,DSN=SYS1.ISP.SISPCLIB\n//         DD DISP=SHR,DSN=SYS1.ISP.SISPEXEC\n//ISPMLIB  DD DISP=SHR,DSN=SYS1.ISP.SISPMENU\n//ISPPLIB  DD DISP=SHR,DSN=SYS1.ISP.SISPPENU\n//ISPSLIB  DD DISP=SHR,DSN=SYS1.ISP.SISPSENU\n//ISPTLIB  DD DISP=SHR,DSN=SYS1.ISP.SISPTENU\n//ISPPROF  DD DISP=(,DELETE),UNIT=VIO,\n//            DCB=(LRECL=80,BLKSIZE=6320,RECFM=FB),\n//            SPACE=(CYL,(5,0,24))\n//ISPCTL1  DD UNIT=VIO,SPACE=(CYL,(1,1)),DISP=NEW,\n//            DCB=(LRECL=80,BLKSIZE=8000,RECFM=FB)\n//ISPCTL2  DD UNIT=VIO,SPACE=(CYL,(1,1)),DISP=NEW,\n//            DCB=(LRECL=80,BLKSIZE=8000,RECFM=FB)\n//ISPLST1  DD UNIT=VIO,SPACE=(CYL,(1,1)),DISP=NEW,\n//            DCB=(LRECL=121,BLKSIZE=4840,RECFM=FBA)\n//ISPLST2  DD UNIT=VIO,SPACE=(CYL,(1,1)),DISP=NEW,\n//            DCB=(LRECL=121,BLKSIZE=4840,RECFM=FBA)\n//ISPLOG   DD UNIT=VIO,SPACE=(CYL,(1,1)),DISP=NEW,\n//            DCB=(LRECL=121,BLKSIZE=4840,RECFM=FBA)\n//*\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COPYANSI": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00U\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18B\\x00\\x8b\\x00\\x8c\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:42:55", "lines": 139, "newlines": 140, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: COPYANSI\n |\n | Author: David Alcock :: Dave@planetmvs.com\n |\n | Purpose: Convert a file that has ANSI control characters.  Good\n |          for running prior to downloading to PC.\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code provided.\n |             It is copyright 1998-2002+ by David Alcock.\n |             All rights reserved.\n */\n\n/**********************************************************************\n*           M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ---------------------------------------------\n* DGAlcock   16-OCT-1998 v1.0 Initial exec written\n**********************************************************************/\n\nvrm = '1.0'\n\nmtype = address()\nPARSE SOURCE s1 s2 s3 s4 s5 s6 s7 s8 s9\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then systemid = mvsvar(syssmfid)\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        systemid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse systemid = \"\"\n\nif substr(systemid,1,3) == \"XYZ\" then \"cls\" /* clear screen for Dave */\n\nsay \"COPYANSI - version \"vrm \"- Freeware - Convert ANSI utility\"\n/* say \"Copyright 1998-1999 by David Alcock. All rights reserved.\" */\nsay \" \"\nsay \". Executing in Environment: \"s1 \"-\" mtype\nif systemid <> \"\" then say \". Executing on system: \"systemid\nsay \" \"\n\n/***********************************************************************\n* Verify that the input dataset exists read the whole thing in\n***********************************************************************/\n\narg sysut1_dsn\nif sysut1_dsn == \"\" then ,\n   sysut1_dsn = 'SPF8.LIST'\n\nx = LISTDSI(sysut1_dsn)\nif x <> 0 then do\n   say \"Error accessing DSN:\" sysut1_dsn\n   say \"> \"sysmsglvl1\n   say \"> \"sysmsglvl2\n   say \"> SYSREASON: \"sysreason\n   exit\n   end\n\nsysut1_pdsn = sysdsname\nparse value sysut1_dsn with . \"(\" member \")\" .\nif member <> \"\" then do\n   sysut1_pdsn = sysut1_pdsn\"(\"strip(member)\")\"\n   end\nsay \"Processing input file \"sysut1_pdsn\n\nsysut1_dd = \"SYU1\"random()\naddress TSO \"ALLOCATE FILE(\"sysut1_dd\") DA('\"sysut1_pdsn\"') SHR REUSE\"\n\"EXECIO * DISKR \"sysut1_dd\" (FINIS STEM sysut1_file.\"\naddress TSO \"FREE FILE(\"sysut1_dd\")\"\n\n/***********************************************************************\n* Create the output dataset\n***********************************************************************/\n\nsysut2_dsn = sysvar(sysuid)\".SPFTEMP1.ANSI\"\nsay \"Writing to DSN=\"sysut2_dsn\naddress TSO \"DELETE '\"sysut2_dsn\"'\"\naddress TSO \"ALLOCATE FILE(SYSUT2) DA('\"sysut2_dsn\"')\",\n            \"UNIT(SYSDA) NEW REUSE SPACE(15 15) TRACKS\",\n            \"LRECL(137) BLKSIZE(141) RECFM(V B)\"\n\n\n/***********************************************************************\n* Process the SYSUT1 (input) file and write stuff to the output file\n***********************************************************************/\n\nsay \"Processing \"sysut1_file.0\" lines of input\"\nadded = 0\ndropped = 0\naddress TSO \"NEWSTACK\"   /* Place to put SYSUT2 output */\n\ndo i = 1 to sysut1_file.0\n   select\n     when substr(sysut1_file.i,1,1) == \"0\" then do\n          added = added + 1\n          queue \" \"\n          end\n     when substr(sysut1_file.i,1,1) == \"-\" then do\n          added = added + 2\n          queue \" \"\n          queue \" \"\n          end\n     when substr(sysut1_file.i,1,1) == \"+\" then do\n          dropped = dropped + 1\n          iterate\n          end\n     otherwise\n       nop\n       end\n   line = substr(sysut1_file.i,2,length(sysut1_file.i)-1)\n   if strip(line) <> \"\" then queue line\n\n   end\n\n/*********************************************************************\n* That's all folks...\n*********************************************************************/\n\nif added == 0 then say \"No lines were added\"\nelse say added \"Blank lines were added for advancing ANSI characters\"\nif dropped == 0 then say \"No lines were dropped (no + ANSI characters)\"\nelse say dropped \"Lines were dropped\"\n\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW SYSUT2 (FINIS\"\naddress TSO \"DELSTACK\"\naddress TSO \"FREE FILE(SYSUT2)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASRC": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x00\\x12\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18B\\xaf\\xc6\\xa0<\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:42:12", "lines": 44998, "newlines": 41020, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 0100-01266-01266-1821-00095-00095-00000-DAVE\n Source library - David Alcock's various apps - Library 1 of 2\n\n The contents of this file are FREEWARE. Use at your own risk. It\n is provided for your enjoyment and neither David Alcock or his\n employer provides any warranty for their use.  I'd like to hear how\n they work on your system:\n\n    David Alcock :: dave@planetmvs.com\n\n    This package may be obtained at:\n    http://www.planetmvs.com/freeware/dasrc.zip\n\n Package contents:\n\n - DA.SOURCE - fixed block lrecl 80 library  <------------- This file\n   (in zip file as DASRC.XMI)\n - DA.SOURCEV - variable block library\n   (in zip file as DASRCV.XMI)\n\n Note:\n - Some of these programs date back to when I was learning assembler\n   and are NOT state-of-the-art assembler code BUT they remain useful\n   over 10 years later.\n - Others like DA$ASMHA have very dense code with long ugly labels\n   and you really need a machete to cut thru the jungle. Maybe I\n   learned a lesson here?\n\n =====================================================================\n\n F i l e   C o n t e n t s . . . . . . . . . . . . . . . . . . . . . .\n\n Member   Description\n ------   -----------\n $$README Text: this file\n\n #EREP    Doc: Brief startup information for the EREP application\n\n $ASM     JCL: Sample job to assemble the DA$ programs\n\n I$EREP   ISPF: ISPF panels for the EREP application\n\n DA$ASMHA Batch: Assembler H analysis program\n DA$BRODC Batch: SYS1.BRODCAST analysis\n DA$DISKR Batch: Disk Reporter (volume space among other things)\n DA$IDC   Batch: IDCAMS post processing (with no extra I/O)\n DA$PDSR  Batch: PDS report program\n DA$PDSRT Exec:  Processes a DA$PDSR \"flatout\" file to relink a module\n                 if a CSECT is found. See X$PDSRP for sample job.\n DA$SPF2D Batch: Convert an ISPF panel to 3270 Data Stream.  Use to\n                 prototype 3270 screens in ISPF.\n DA$W4TCP Batch: Waits for IBM's TCP/IP to come active;\n\n DA$ENQS  TSOCP: Enqueue display program\n\n DA$EREP  ISPF: Called by the R$EREP REXX exec to read the LOGREC\n                ACCDEV file and create ISPF table entries\n DA$WDATE ISPF: Julian and Gregorian Date conversions\n DA#WDATE ISPF: Panels needed by DA$WDATE (IEBUPDTE format)\n\n DA$DATE  Subroutine: Date routine\n DA$MXD   Subroutine: Mini-Hex-Dump routine\n\n DA#DATE  Macro: DSECTs and Equates for the DA$DATE subroutine\n DA#MXD   Macro: DSECTs and Equates for the DA$MXD subroutine\n DA#COBOL Macro: Mapping macro for COBOL eyecatchers\n\n DA#ENTER Macro: Entry housekeeping (not ESA)\n DA#EYEC  Macro: Create O/S eyecatcher\n DA#LEAVE Macro: Exit housekeeping (not ESA)\n DA#REGS  Macro: Generate register equates\n DA#SMODE Macro: Change addressing modes\n DA#STR   Macro: Generate a Pascal-like string\n DA#TSOS  Macro: TSO Support\n DA#Z00   Macro: Inner - Locate operand\n DA#Z01   Macro: Inner - Generate a label\n DA#Z02   Macro: Inner - Generate a test and branch\n DA#Z04   Macro: Inner - Generate a parameter list\n DA#Z05   Macro: Inner - Generate a branch\n\n X$ASMHA1 JCL: Sample job to execute the DA$ASMHA program (MVS macros)\n X$ASMHA2 JCL: Sample job to execute the DA$ASMHA program (misc)\n X$BRODC1 JCL: Sample job to execute the DA$BRODC program (report only)\n X$BRODC2 JCL: Sample job to execute the DA$BRODC program (lost mail)\n X$BRODC3 EXEC: Sample Rexx exec to show lost mail\n X$DISKR  JCL: Sample job to execute the DA$DISKR program\n X$IDC    JCL: Sample job to execute the DA$IDC   program\n X$PDSR   JCL: Sample job to execute the DA$PDSR  program\n X$PDSRP  JCL: Sample job to show using the FLATOUT option of DA$PDSR\n               to relink a module if the PL/I date routine is found.\n X$SPF2D  JCL: Sample job to execute the DA$SPF2D program\n X$EREP   JCL: Sample job to get LOGREC data ready for the EREP ISPF\n               application (program DA$EREP and rexx R$EREP)\n =====================================================================\n\n May the SOURCE be with you...Obi Wan\n./ ADD NAME=$ASM     0102-01266-02289-2351-00162-00178-00000-DALCOCK\n//* -- PUT JOB CARD HERE --\n//*\n//* SEE LINES MARKED WITH \"<-\" WHICH MIGHT NEED MODIFICATION\n//*********************************************************************\n//***                                                               ***\n//**  SUBROUTINES THAT MIGHT BE LINKED IN LATER                      **\n//***                                                               ***\n//*********************************************************************\n//*\n//** ASSEMBLE AND LINK THE DA$DATE PROGRAM\n//*\n//DA$DATE  EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$DATE)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$DATE)\n//*\n//** ASSEMBLE AND LINK THE DA$MXD PROGRAM\n//*\n//DA$MXD   EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$MXD)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$MXD)\n//*********************************************************************\n//***                                                               ***\n//**  STAND ALONE PROGRAMS                                           **\n//***                                                               ***\n//*********************************************************************\n//*\n//** ASSEMBLE AND LINK DA$ADATA - HLASM ADATA\n//*\n//DA$ADATA EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//*        DD DISP=SHR,DSN=SYS1.SASMMAC1  <- HLASM MACROS\n//*        DD DISP=SHR,DSN=ASM.SASMMAC1   <- HLASM MACROS\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ADATA)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//*\n//** ASSEMBLE AND LINK DA$BRODC - SYS1.BRODCAST ANALYSIS\n//*\n//DA$BRODC EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$BRODC)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$BRODC)\n//*\n//** ASSEMBLE AND LINK DA$ENQS - WHOHAS ENQUEUE\n//*\n//DA$ENQS EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ENQS)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//*\n//** ASSEMBLE AND LINK DA$EREP - EREP ISPF APPLICATION\n//*\n//DA$EREP EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$EREP)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$EREP)\n//*L.SISPLOAD DD DISP=SHR,DSN=ISP.SISPLOAD     <- ISPF LOAD LIB\n//L.SISPLOAD DD DISP=SHR,DSN=SYS1.ISP.SISPLOAD   <- ISPF LOAD LIB\n//*\n//** ASSEMBLE AND LINK DA$SPF2D - ISPF TO 3270 DATASTREAM\n//*\n//DA$SPF2D EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$SPF2D)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$SPF2D)\n//*\n//** ASSEMBLE AND LINK DA$IDC - IDCAMS driver/enhancements\n//*\n//DA$IDC  EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$IDC)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$IDC)\n//*\n//** ASSEMBLE AND LINK DA$PDSR - PDS REPORTER\n//*\n//DA$PDSR EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$PDSR)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(DA$PDSR)\n//*\n//** ASSEMBLE AND LINK DA$ASMHA - ASSEMBLER H SYSPRINT SCRAPER\n//**\n//** NOTE: THE IEFSD095 (IBM BLOCK LETTER ROUTINE) IS OPTIONAL. YOU\n//**       WILL GET A LINK EDIT RC = 8 BUT THE PROGRAM WILL EXECUTE\n//**       WITHOUT IT.\n//*\n//DA$ASMHA EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ASMHA)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//*.AOSB0   DD DISP=SHR,DSN=SYS1.AOSB0   OPTIONAL: IEFSD095\n//*.AOSB0   DD DISP=SHR,DSN=IBMUSER.OS390R10.SYS1.AOSB0\n//L.SYSUDUMP DD SYSOUT=*\n//*\n//** ASSEMBLE AND LINK DA$DISKR - DASD VOLUME REPORTER\n//**\n//** NOTE: THE IEFSD095 (IBM BLOCK LETTER ROUTINE) IS OPTIONAL. YOU\n//**       WILL GET A LINK EDIT RC = 8 BUT THE PROGRAM WILL EXECUTE\n//**       WITHOUT IT.\n//*\n//DA$DISKR EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$DISKR)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//*.AOSB0   DD DISP=SHR,DSN=SYS1.AOSB0   OPTIONAL: IEFSD095\n//L.AOSB0   DD DISP=SHR,DSN=IBMUSER.OS390R10.SYS1.AOSB0\n//*\n//** ASSEMBLE AND LINK DA$WDATE - DATE CONVERSION ISPF APPLICATION\n//*\n//DA$WDATE EXEC HLASMCL,\n//         PARM.C='ASA,SIZE(MAX,ABOVE),NOXREF,BATCH,NORXREF',\n//         PARM.L='MAP,RENT,REUS'\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$WDATE)\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n./ ADD NAME=$CHANGES 0103-01266-02289-1515-00044-00032-00000-DALCOCK\n History of changes - not maintained religiously\n\n 2002-07-18  - DA$W4TCP - Removed from DA.SOURCE.  This is now a standalone\n                          program.  It doesn't use the DA macros and doesn't\n                          need to be included in this package.  It is\n                          available as new program name WAIT4TCP at:\n\n               http://www.planetmvs.com/freeware/wait4tcp.html\n\n 2002-07-10  - DA$PDSRR - Add exec to show using the flatout file to\n                          invoke the disassembler to find instruction\n                          usage.\n 2002-07-10  - X$PDSRR  - Add sample job to show using DA$PDSRR\n\n 2001-09-23  - DA$PDSR  - Small //FLATOUT enhancements\n 2001-09-21  - DA$PDSRT - Added exec to DA.SOURCE\n 2001-09-21  - X$PDSRP  - Added job stream to DA.SOURCE\n\n 2001-04-23  - DA$IDC   - Added program to DA.SOURCE\n 2001-04-23  - *all*    - Added disclaimer\n\n 2000-09-09  - DA$ADATA - Added support for HLASM R3; Removed dep. on\n                          my DA$DATE date routine;\n 2000-09-09  - DA$DISKR - See modifications history in module;\n 2000-09-09  - DA$W4TCP - New program added - wait for a TCP/IP stack\n                          to start;\n 2000-09-09  - DA#EYEC  - Default to new Time format of standard;\n 2000-09-09  - *all*    - Consistent eyecatchers and version variable\n                          was added to all programs; Other misc\n                          standardization was performed.\n 2000-09-09  - $ASM     - Added DA$W4TCP; Added parm for fast asm;\n\n 1999-12-30  - DA$EREP  - Updated for four digit dates (cosmetic)\n 1999-09-09  - DA$DATE  - Added ISO date output option\n 1999-09-09  - DA$WDATE - New application: Date Conversions\n\n Opps: Not all changes/updates were logged here!\n\n 21-JUN-1997 - DA$EREP  - Removed Guide/SPF macro library requirement\n\n 02-JAN-1997 - DA$BRODC - Added utility to DA.SOURCE\n 02-JAN-1997 - DA$PDSR  - See comments in member\n 02-JAN-1997 - $ASM     - Some comments were in error\n\n./ ADD NAME=##EREP   0100-01266-01266-1821-00104-00104-00000-DAVE\nNOTE TO DAVE: ADD SDWA FORMATTING, HERE A SAMPLE FROM AN EREP OUTPUT:\n\nHEXADECIMAL DUMP\n  HEADER\n  +000    40831820    00000000    0098357F    03244239    | C.......Q.\"....|\n  +010    D8110491    90210000                            |Q..J....        |\n\n  JOBNAME\n  +000    D7C3C9E2    F8F1F3C4                            |PCIS813D        |\n\n  SDWA BASE\n  +000    00000C60    84878000    00000000    00000000    |...-DG..........|\n  +010    00000000    00000000    84000000    84878000    |........D...DG..|\n  +020    00AFE084    0300E202    02B43000    00000000    |..\\D..S.........|\n  +030    000000F8    0142B418    01532EE8    00001000    |...8.......Y....|\n  +040    00000000    00000000    02C5EA88    00B1DC00    |.........E.H....|\n  +050    8142B97C    00000004    00000000    00000000    |A..@............|\n  +060    00000000    00000000    040C1000    814559CC    |............A...|\n  +070    0002000D    00000000    040C0000    00FF9A88    |...............H|\n  +080    0002000D    00000000    84000000    84878000    |........D...DG..|\n  +090    00AFE084    0300E202    02B43000    00000000    |..\\D..S.........|\n  +0A0    000000F8    0142B418    01532EE8    00001000    |...8.......Y....|\n  +0B0    00000000    00000000    02C5EA88    00B1DC00    |.........E.H....|\n  +0C0    8142B97C    00000004    00000000    00000000    |A..@............|\n  +0D0    00000000    00000000    00000000    00000000    |................|\n  +0E0    00000000    00000000    040A0001    00000041    |................|\n  +0F0    00000000    00FBFAFC    00000000    00800000    |................|\n  +100    00000000    00000000    00000000    00000000    |................|\n  +110    00000000    00000000    00000000    00000000    |................|\n  +120    012C211E    D5E4C3D3    C5E4E240    C9C5C3E5    |....NUCLEUS IECV|\n  +130    C5E7E2D4    C9C5C3E5    C5E7C6D9    00FBFAA8    |EXSMIECVEXFR...Y|\n  +140    00000000    00000000    00000000    00000000    |................|\n  +150    00000000    00000000    00000000    00000000    |................|\n  +160    00000000    00000000    00000000    FFFF0006    |................|\n  +170    00FBFDF8    00C0012C    0000012C    00000000    |...8.{..........|\n  +180    00000000    00000000    00000000    0001DFC7    |...............G|\n  +190    00FFE093                                        |..\\L            |\n\n  VARIABLE RECORDING AREA (SDWAVRA)\n\n  +000    KEY: 38     LENGTH: 04\n  +002    08780878                                        |....            |\n\n  +006    KEY: 10     LENGTH: 18\n  +008    00B00500    80083D12    00000000    80010040    |............... |\n  +018    00FFC380    00AFE054                            |..C...\\.        |\n\n  +020    KEY: 00     LENGTH: 00\n\n  +022    KEY: 12     LENGTH: 38\n  +024    00F37FF0    000C8720    00ABA6BC    00ABBE88    |.3\"0..G...W....H|\n  +034    00000000    00000000    00000000    00000000    |................|\n  +044    00000000    80400001    00000000    00000000    |..... ..........|\n  +054    80083D12    00000000                            |........        |\n\n  +05C    KEY: 00     LENGTH: 00\n\n  +05E    KEY: 00     LENGTH: 00\n\n  +060    KEY: 00     LENGTH: 00\n\n  +062    KEY: 00     LENGTH: 00\n\n  SDWA FIRST RECORDABLE EXTENSION (SDWARC1)\n  +000    E2C3F1C3    F6C5E7C3    D740E2E3    D6D9C1C7    |SC1C6EXCP STORAG|\n  +010    C540D4C1    D5C1C7C5    D94B4040    F0F961F1    |E MANAGER.  09/1|\n  +020    F961F9F5    40C8C2C2    F6F6F0F1    00000004    |9/95 HBB6601....|\n  +030    C9C5C3E5    C5E7C6D9    F5F7F5F2    00000001    |IECVEXFR5752....|\n  +040    00000201    00000000    00000000    00FF9A88    |...............H|\n  +050    00B00500    80083D12    00000000    80010040    |............... |\n  +060    00FFC380    00AFE054    00000000    00000000    |..C...\\.........|\n  +070    00000000    0000012C    00ABBE88    00181610    |...........H....|\n  +080    0A0D18CE    18FB180C    00EA1580    2D15007F    |...............\"|\n  +090    84878000    00000004    5FB1EE40    2D15007F    |DG......\u00ac.. ...\"|\n  +0A0    32F6DDC0    00C0012C    0000012C    71919B00    |.6.{.{.......J..|\n  +0B0    00000000    2D15007F    00000000    00000000    |.......\"........|\n  +0C0    00000000    00000000    047B3253    2D15007F    |.........#.....\"|\n  +0D0    DF8F191E    7F7A7008    00AFB01F    00000000    |....\":..........|\n  +0E0    00000000    00000000    00000000    00000000    |................|\n  +0F0    00000000    00000000    00000000    00000000    |................|\n  +100    00000000    00000000    00000000    00000000    |................|\n  +110    80AFA03C    00000000    00AFB01F    00000000    |................|\n  +120    00000000    00000000    00000000    00000000    |................|\n  +130    00000000    00000000    00000000    00000000    |................|\n  +140    00000000    00000000    00000000    00000000    |................|\n  +150    80AFA03C    00000000    71919B00    00000000    |.........J......|\n  +160    00000000    00000000    32F6DF00    00000000    |.........6......|\n  +170    00000000    00000000    00000000    00000000    |................|\n  +180    00000000    00000000    00000000    00000000    |................|\n  +190    00000000    00000000    00000000    00000000    |................|\n  +1A0    00000000    7F7A7008    00000000    00000000    |....\":..........|\n  +1B0    00000000    00000000    00000000    00000000    |................|\n  +1C0    C3E2E6F1    40404040                            |XYZ1            |\n\n  SDWA SECOND RECORDABLE EXTENSION (SDWARC2)\n  +000    00000000    00000000    00000000    00000000    |................|\n\n  SDWA THIRD RECORDABLE EXTENSION (SDWARC3)\n  +000    00000000    00000000    00000000    00000000    |................|\n  +010    00000000    00000000    00000000    00000000    |................|\n\n  ERRORID\n  +000    211E0041    012C0001    DFC7                    |.........G      |\n\n./ ADD NAME=#DASD    0100-01266-01266-1821-00064-00064-00000-DAVE\nMessage: 5\n   Date: Mon, 22 Jan 2001 19:49:06 +0100 (CET)\n   From: \"Axel Schwarzer -shw.AXP-\" <SchwarzerA@messe-duesseldorf.de> Subject: R\n\nmy latest version of the dasd gemetries is this:\n---8<---\n                          Track     Tracks/  Cylinders/   Volume\nDisk                     Capacity  Cylinder    Volume    Capacity\n-----------------------  --------  --------  ----------  --------\n3330    model I           13,030      19        404        100 M\n3330    model II          13,030      19        808        200 M\n3350                      19,069      30        555        317 M\n3375                      35,616      12        959        409 M\n3380    single density    47,476      15        885        630 M\n3380    double density    47,476      15      1,770      1,260 M\n3380    triple density    47,476      15      2,655      1,890 M\n\n\n                             CKD DEVICES\n\n              DATA   ALT    TRK/   BYTES/    BYTES/         BYTES/\nDISK TYPE     CYLS  CYLS    CYL    TRACK       CYL         MODULE\n------------ -----  ----  ------  -------  --------  -------------\n2305-1          48     6      8    14,136   113,088      5,428,224\n2305-2          96    12      8    14,660   117,280     11,258,880\n2311           200     2     10     3,625    36,250      7,250,000\n2314           200     3     20     7,294   145,880     29,176,000\n3330-1         404     7     19    13,030   247,570    100,018,280\n3330-11        808     7     19    13,030   247,570    200,036,560\n3340-35        348     1     12     8,368   100,416     34,944,768\n3340-70        696     2     12     8,368   100,416     68,889,536\n3350           555     5     30    19,069   572,070    317,498,850\n3375           959     1     12    35,616   427,392    409,868,928\n3380 A/B/D/J   885     1     15    47,476   712,140    630,243,900\n3380 E        1770     2     15    47,476   712,140  1,260,487,800\n3380 K        2655     3     15    47,476   712,140  1,890,731,700\nEMC338OK+     3339     3     15    47,476   712,140  2,377,835,460\nEMC338OK++    3993     3     15    47,476   712,140  2,843,575,020\n3390-1        1113     1     15    56,664   849,960    946,005,480\n3390-2        2226     1     15    56,664   849,960  1,892,010,960\n3390-3        3339     1     15    56,664   849,960  2,838,016,440\n3390-9       10017     3     15    56,664   849,960  8,514,049,320\n9345-1        1440     0     15    46,456   696,840  1,003,449,600\n9345-2        2156     0     15    46,456   696,840  1,502,387,040\n\n\n                            FBA DEVICES\n\n              BYTES/  BLOCKS/   BLOCKS/     BLOCKS/        BYTES/\nDISK TYPE     BLOCK    TRACK   CYLINDER   ACTUATOR      ACTUATOR\n------------  ------  -------  --------  ----------  ------------\n3310             512       32       352     125,664    64,339,968\n3370-Al/BI       512       62       744     558,000   285,696,000\n3370-A2/B2       512       62       744     712,752   364,929,024\n9332-200         512       73       292     360,036   184,338,432\n9332-400         512       73       292     360,036   184,338,432\n9332-600         512       73       292     554,800   284,057,600\n9335             512       71       426     804,714   412,013,568\n9336-10          512       63       315     920,115   471,098,880\n9336-20/25       512      111       777   1,672,881   856,515,072\n---8<---\n\n\nMit freundlichem Gruss/Kind regards\n./ ADD NAME=#EREP    0100-01266-01266-1821-00017-00017-00000-DAVE\nHere is a brief documentation on getting the EREP/LOGREC application\nup and running:\n\n- Assemble and link DA$EREP to your load library via $ASM member\n  The module DA$DATE is needed and is also assembled via $ASM job.\n\n- Copy userid.DA.SOURCEV(LRS) to your variable blocked SYSPROC\n  or SYSEXEC dataset.\n\n- Unload the IEBUPDTE panel source to a panel library. A sample\n  job is in the X$EREPU member\n\n- Modify and run member X$EREP to copy LOGREC data from your\n  active LOGREC datasets and your saved LOGREC data (if any)\n  to a file we can process.\n\n- Invoke the application: LRS DSN 'your.logrec.accdev.file'\n./ ADD NAME=DA$ADATA 0101-02289-02289-1533-00958-00951-00000-DALCOCK\nDA$ADATA TITLE 'ASMADATA Bootstrap program for REXX ADATA support'\n* =================================================================== *\n*\n*  Name = DA$ADATA\n*\n*  Author = David Alcock :: dave@planetmvs.com\n*\n*  Purpose = Build the REXX versions of the ASMADATA DSECTs as a\n*            \"bootstrap\" for further SYSADATA development in REXX.\n*\n*            Print hex dump of SYSADATA records to aid in the\n*            development in REXX\n*\n*  Files:\n*  - SYSPRINT - Utility messages\n*  - REXXOUT  - Rexx variable output\n*  - SYSADATA - Input SYSADATA file\n*\n*  Programs called:\n*  - DA$MXD...Mini-Hex-Dump\n*\n*  Non-Standard Macro Usage:\n*  - DA#STR   - Generate a string array with byte length (-1)\n*  - DA#SMODE - Change addressing mode to and from 24/31\n*  - DA$MXD   - Equates and DSECTs for DA$MXD subroutine\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n*  Limitations:\n*  - High Level Assembler Macro library: hlq.SASMMAC1\n*\n*    Note: If you don't have the HLASM 1.3.0 maclib available, you\n*    will need to edit the ASMADATA below to remove the new keywords\n*    that are not in your relese yet.\n*\n*  - Tied to internal format of vendor files, must verify at when\n*    maintenance and release changes occur.\n*  - Program must be assembled with Assembler H or higher\n*\n* =================================================================== *\n         SPACE 2\n&DAVER   SETC  '1.7'\n*======================================================================\n*\n*             M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date       Ver Description\n* ---------- ---------- --- -------------------------------------------\n* DGAlcock   2002-10-16 1.7 Added HLASM V4 support;\n* DGAlcock   2000-09-09 1.6 Removed DA$DATE date routine dependencies;\n* DGAlcock   2000-04-01 1.5 HLASM v3 support;\n*                           Remove my Entry & exit housekeeping macs;\n*\n*======================================================================\n         EJECT ,\n         PRINT NOGEN\n*\n** Dave's DSECTs\n*\n         DA#MXD ,                         Mini-Hex dump routine\n*\n** IBM dsects and equates\n*\n         DCBD  DSORG=PS,DEVD=DA           Data Control Block\n         CVT  DSECT=YES,LIST=NO           MVS Comm. Vector Table\n         YREGS ,                          Register equates\n         PRINT GEN\n*\n** HLASM DSECTs\n**\n** Delete lines if not on latest HLASM maclib\n*\n      ASMADATA PRINT=GEN,JID=YES,OPT=YES,ESD=YES,SOURCE=YES,    V1.1.0 @       X\n               SRCERR=YES,DCDS=YES,MACH=YES,SYM=YES,XREF=YES,   V1.1.0 @\n               USING=YES,RLD=YES,MXREF=YES,STATS=YES,           V1.1.0 @\n               MXREFX=YES,OUTPUT=YES,USER=YES,AID=YES,          V1.2.0 @\n               COMPUNIT=YES,DCDSX=YES,                          V1.2.0 @\n               RXREF=YES,                                       V1.3.0 @\n               AOPT=YES                                         V1.4.0\n*\n** Map the T_RT table\n*\nTRT        DSECT ,\nTRT_ID     DS    CL6\nTRT_VALUE  DS    XL2\nTRT_DESC   DS    XL2\nTRT_CL     EQU   *-TRT\nTRT_COUNT  DS    XL4\nTRTL       EQU   *-TRT\n*\n** Convert assembly date from format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n*\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***\n**       Initialization\n***\n***********************************************************************\n         SPACE 2\nDA$ADATA CSECT ,\nDA$ADATA AMODE 24\nDA$ADATA RMODE 24\n*\n** Standard O/S eyecatcher\n*\nAD_EC    B    AD_ECL(0,R15)             Bump past EyeCatcher\n         DC   AL1(AD_ECE-AD_ECV)        Length of eyecatcher\nAD_ECV   DC   C'DA$ADATA '\nAD_ECD   DC   C'&ASMDATE'\n         DC   C' '\nAD_ECT   DC   C'&SYSTIME'\n         DC   C' V&DAVER '\n         DC   C'Utility: Process HLASM SYSADATA for REXX bootstrap'\nAD_ECE   EQU  *\n         DS   0H\nAD_ECL   EQU  *-AD_EC\n*\n** Standard ESA entry housekeeping code\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         LAE   R11,2048(,R12)           Set up for second base reg\n         LA    R11,2048(,R11)           Locate 4096 past R12\n         LAE   R10,2048(,R11)           Set up for third base reg\n         LA    R10,2048(,R10)           Locate 4096 past R11\n         USING DA$ADATA,R12,R11,R10     Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1\n*\n** Obtain Dynamic Save Area\n*\n         STORAGE OBTAIN,LENGTH=DSAL,LOC=BELOW Obtain storage\n         LR    R13,R1                   Point to Save Area\n*\n         LR    R14,R13                  To: Address\n         L     R15,=A(DSAL)             To: Length\n         SLR   R1,R1                    From: Set length and pad\n         MVCL  R14,R0                   Zero out area\n*\n         MVC   4(4,R13),=C'F1SA'        Indicate stack SA\n         USING DSA,R13                  Get addressibility to area\n*\n         BAS   R9,Get_Current_Time_Date Get time and date for rpts\n*\n** Initlialize record table\n*\n         LA    R0,T_RTN+1                 Set number in table\n         LA    R1,T_RT                    Locate constants table\n         LA    R14,X_RT                   Locate variable table\nIRT$L    EQU   *\n         MVC   0(TRT_CL,R14),0(R1)        Move constants part\n         LA    R1,TRT_CL(R1)              Bump to next entry\n         LA    R14,TRTL(R14)              Bump to next entry\n         BCT   R0,IRT$L\n*\n** Open the messages file\n*\n         LA    R3,SYSPRINT\n         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'\n         MVC   PARMLIST(C_LSTOL),C_LSTO   Copy in OPEN parm list\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PARMLIST)\n         MVI   PSR_LC,99                  Force heading on first record\n*\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG0L,R15),MSG0          Get message\n         LA    R15,MSG0L+1(R15)           Bump past text\n         MVC   0(L'AD_ECD,R15),AD_ECD\n         LA    R15,L'AD_ECD+1(R15)\n         MVC   0(L'AD_ECT,R15),AD_ECT\n         LA    R15,L'AD_ECT(R15)\n         MVC   0(2,R15),=C').'\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n*\n** Open the output REXX file\n*\n         DEVTYPE =CL8'REXXOUT',DOUBLE     Get DD allocation info\n         LTR   R15,R15                    Is FILE=REXXOUT allocated?\n         BNZ   I$ROND                     No, leave\n         LA    R3,REXXOUT                 Locate DCB work area\n         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant\n         NI    DCBRECFM-IHADCB(R3),255-DCBRECCA  Not ASA!!!\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'REXXOUT'\n         MVC   PARMLIST(C_LSTOL),C_LSTO   Copy in OPEN parm list\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PARMLIST)\n         LTR   R15,R15\n         BNZ   I$ROE\n*\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(133-1),RECOUT\n         LA    R15,RECOUT\n         MVC   0(C_HDR1L,R15),C_HDR1\n         PUT   REXXOUT,RECOUT\n*\n         LA    R15,RECOUT\n         MVC   0(C_HDR2L,R15),C_HDR2\n         PUT   REXXOUT,RECOUT\n*\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(C_HDR2L,R15),0(R15)\n         MVC   0(C_HDR3L,R15),C_HDR3\n         LA    R15,C_HDR3L+1(R15)\n         MVC   0(L'AD_ECD,R15),AD_ECD\n         LA    R15,L'AD_ECD+1(R15)\n         MVC   0(2,R15),=C'at'\n         LA    R15,3(R15)\n         MVC   0(L'AD_ECT,R15),AD_ECT\n         PUT   REXXOUT,RECOUT\n*\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(70,R15),0(R15)\n         MVC   0(C_HDR4L,R15),C_HDR4\n         LA    R15,C_HDR4L+1(R15)\n         MVC   0(L'X_DATE,R15),X_DATE\n         LA    R15,L'X_DATE+1(R15)\n         MVC   0(2,R15),=C'at'\n         LA    R15,3(R15)\n         MVC   0(L'X_TIME,R15),X_TIME\n         LA    R15,L'X_TIME+1(R15)\n         PUT   REXXOUT,RECOUT\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(70,R15),0(R15)\n         MVC   0(C_HDR5L,R15),C_HDR5\n         PUT   REXXOUT,RECOUT\n         B     I$ROX\nI$ROE    EQU   *\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG4L,R15),MSG4          Get message\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\nI$ROND   EQU   *\n         OI    X_FLAG1,$XF1_NRO\nI$ROX    EQU   *\n*\n** Open_SYSADATA_File\n*\nOPEN_SYSADATA_FILE EQU *\n         DEVTYPE =CL8'SYSADATA',DOUBLE    Get DD allocation info\n         LTR   R15,R15                    Is FILE=SYSADATA allocated?\n         BNZ   OSIF$ND                    No, leave\n         LA    R3,SYSADATA                Locate DCB work area\n         MVC   0(C_DCBIL,R3),C_DCBI       Copy in DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSADATA' Insert DDNAME\n         LA    R1,PSF$EOF\n         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Insert EOF routine\n*\n         MVC   PARMLIST(C_LSTIL),C_LSTI   Get input parm list\n         OPEN  ((3),(INPUT)),             Open BKLID file              @\n               MF=(E,PARMLIST)            ..with parm list\n         LTR   R15,R15                    Good open?\n         BZ    OSIF$X                     No, gripe about it\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG2L,R15),MSG2          Get message\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         B     EXIT\nOSIF$ND  EQU   *\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG3L,R15),MSG3          Get message\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         MVI   X_MAXCC,20\n         B     EXIT\nOSIF$X   EQU   *\n         EJECT\n***********************************************************************\n***\n**       Process the SYSADATA file\n***\n***********************************************************************\n         SPACE 2\nPROCESS_SYSADATA_FILE EQU *\nPSF$L    EQU   *\n         GET   SYSADATA                   Get record\n         LR    R8,R1                      Save address of Record\n         SLR   R7,R7                      Clear register\n         ICM   R7,B'0011',0(R8)           Get record length\n*\n         L     R1,PSF_RECR                Get count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PSF_RECR                Save it\n*\n** Save trivia about number of records found\n*\n         LA    R2,X_RT\n         LA    R3,T_RTN\nPSF$LRL  EQU   *\n         CLC   ADATA_RECTYPE-ASMADATA(2,R8),TRT_VALUE-TRT(R2) Match?\n         BE    PSF$LRLF\n         LA    R2,TRTL(R2)\n         BCT   R3,PSF$LRL\nPSF$LRLF EQU   *\n         SLR   R1,R1\n         ICM   R1,B'1111',TRT_COUNT-TRT(R2)\n         LA    R1,1(R1)\n         STCM  R1,B'1111',TRT_COUNT-TRT(R2)\n*\n** Print Mini-Hex Dump of record\n*\n         TM    X_FLAG1,$XF1_NMXD          Have routine?\n         BO    PSF$LMX                    No, continue\n         ICM   R1,B'1111',EP_DA$MXD       Have routine?\n         BNZ   PSF$LMS                    Yes, continue\n         ICM   R0,B'1111',=V(DA$MXD)      Linked into us?\n         BNZ   PSF$LMLX                   Yes, use it\n         LOAD  EPLOC==CL8'DA$MXD',ERRET=PSF$LME No, load it\n         OI    X_FLAG1,$XF1_LDA$MXD       Say we had to load it\nPSF$LMLX DS    0H\n         ST    R0,EP_DA$MXD               Save entry point\n         B     PSF$LMS                    ..and continue\nPSF$LME  EQU   *\n         OI    X_FLAG1,$XF1_NMXD          Never had it, Never will\n         B     PSF$LMX                    Continue\nPSF$LMS  EQU   *\n         BAS   R14,CLEAR_RECOUT\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n*\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG80L,R15),MSG80        Get message\n         LA    R15,MSG80L(R15)            Bump past it\n         UNPK  0(5,R15),TRT_VALUE-TRT(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4(R15)\n         MVC   0(3,R15),=C''' -'\n         LA    R15,4(R15)\n         SLR   R1,R1\n         ICM   R1,B'0011',TRT_DESC-TRT(R2)\n         AR    R1,R12\n         SLR   R14,R14\n         IC    R14,0(R1)\n         EX    R14,PSF$LMM\n         LA    R15,2(R14,R15)             Bump past record type\n*\n         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSRC+(TRT_VALUE-TRT)\n         BE    PSF$LMSN$SRC\n         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSYM+(TRT_VALUE-TRT)\n         BE    PSF$LMSN$SYM\n         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTXREF+(TRT_VALUE-TRT)\n         BE    PSF$LMSN$XREF\n         B     PSF$LMSNX\nPSF$LMSN$SRC EQU *\n         ICM   R1,B'1111',ADSRC_STMT-ASMADATA(R8)\n         B     PSF$LMSNP\nPSF$LMSN$SYM EQU *\n         ICM   R1,B'1111',ADSYM_STMT-ASMADATA(R8)\n         B     PSF$LMSNP\nPSF$LMSN$XREF EQU *\n         ICM   R1,B'1111',ADXREF_STMT-ASMADATA(R8)\nPSF$LMSNP EQU  *\n         MVC   0(19,R15),=C'- Statement-Number='\n         LA    R15,19(R15)\n         BAS   R9,EDITFWF\nPSF$LMSNX EQU *\n         L     R1,PSF_RECR                Get count\n         MVC   0(17,R15),=C' - Record-Number='\n         LA    R15,17(R15)\n         BAS   R9,EDITFWF\n*\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n*\n         XC    W_DA$MXD(CMXDL),W_DA$MXD Initialize parm area\n         LR    R15,R8                     Locate area to print\n         SLR   R0,R0                      Clear register\n         ICM   R0,B'0011',0(R8)           Get length of record\n         LA    R1,RECOUT+1+9+MSG81L+1     Locate output record\n         STM   R15,R1,W_DA$MXD+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   W_DA$MXD+CMXD_OUTPUTL-CMXD(2),=AL2(133)   Longer\nPSF$LML  EQU   *\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG81L,R15),MSG81        Get message\n         LA    R1,W_DA$MXD                Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         LR    R6,R15                     Save return code\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         LTR   R6,R6                      Any more lines to do...\n         BNZ   PSF$LML                    Thank you: May I have another\n         B     PSF$LMX\nPSF$LMM  MVC   0(0,R15),1(R1)\nPSF$LMX  EQU   *\n.PSFMXDX ANOP  ,\n*\n** Branch to routines for this record type\n*\n         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSYM+(TRT_VALUE-TRT)\n         BE    PSF$SYM\n         CLC   ADATA_RECTYPE-ASMADATA(2,R8),T_RTSRC+(TRT_VALUE-TRT)\n         BE    PSF$SRC\n         B     PSF$L\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Source record\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPSF$SRC  EQU   *\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG82L,R15),MSG82        Get message\n         LA    R15,MSG82L(R15)            Bump past it\n         MVC   0(L'ADSRC_RECORD,R15),ADSRC_RECORD-ASMADATA(R8)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         B     PSF$L\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Symbol record\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPSF$SYM  EQU   *\n         TM    X_FLAG1,$XF1_NRO       REXXOUT available\n         BO    PSF$L                  No, skip this code\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(133-1),RECOUT\n         LA    R15,RECOUT\n         MVC   0(2,R15),=C'o_'\n         LA    R15,2(R15)\n         SLR   R14,R14\n         ICM   R14,B'0011',ADSYM_NAME_LEN-ASMADATA(R8)\n         BCTR  R14,0\n         EX    R14,PSFSYM$M\n         LA    R15,2(R14,R15)\n         MVI   0(R15),C'='\n         LA    R15,2(R15)\n         LR    R4,R15\n         LA    R5,9(R15)\n         ICM   R1,B'1111',ADSYM_LOCTR-ASMADATA(R8)\n         BAS   R9,EDITFWF\n         LR    R15,R5\n         MVC   0(2,R15),=C'/*'\n         LA    R15,3(R15)\n         MVC   0(2,R15),=C'x'''\n         LA    R15,2(R15)\n         UNPK  0(9,R15),ADSYM_LOCTR-ASMADATA(5,R8)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         MVI   8(R15),X'7D'\n         LA    R15,10(R15)\n         MVC   0(2,R15),=C'*/'\n         PUT   REXXOUT,RECOUT\n*\n         MVI   RECOUT,C'l'              Make it \"l_name\" from \"o_name\"\n         LR    R15,R4                   Get output location\n         MVI   0(R15),C' '\n         MVC   1(32,R15),0(R15)\n         SLR   R1,R1\n         ICM   R1,B'0011',ADSYM_BYTE_LEN-ASMADATA(R8)\n         BAS   R9,EDITFWF\n         PUT   REXXOUT,RECOUT\n*\n         B     PSF$L\n*\nPSFSYM$M MVC   0(0,R15),ADSYM_NAME-ASMADATA(R8)\n*\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** End of file on SYSADATA file\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPSF$EOF  EQU   *\n*\n** Print stats\n*\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         LA    R2,X_RT\n         LA    R3,T_RTN+1\nPSF$ERL  EQU   *\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG10L,R15),MSG10        Get message\n         LA    R15,MSG10L(R15)            Bump past it\n         SLR   R1,R1\n         ICM   R1,B'1111',TRT_COUNT-TRT(R2)\n         BAS   R14,EDIT15                 Edit it to message\n         LA    R15,16(R15)\n         MVI   0(R15),C'-'\n         LA    R15,2(R15)\n         SLR   R1,R1\n         ICM   R1,B'0011',TRT_DESC-TRT(R2)\n         AR    R1,R12\n         SLR   R14,R14\n         IC    R14,0(R1)\n         EX    R14,PSF$EM\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         LA    R2,TRTL(R2)\n         BCT   R3,PSF$ERL\n         B     PSF$ERLX\nPSF$EM   MVC   0(0,R15),1(R1)\nPSF$ERLX EQU   *\n         EJECT\n***********************************************************************\n***\n**       Termination section\n***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         BAS   R14,FORMAT_MESSAGE         Format the message\n         MVC   0(MSG99L,R15),MSG99        Get message\n         LA    R15,MSG99L+1(R15)          Bump past it\n         SLR   R1,R1                      Clear register to zeros\n         IC    R1,X_MAXCC                 Get maximum condition code\n         BAS   R9,EDITFWF                 Edit it to message\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message on SYSPRINT\n*\n** Delete loaded routines\n*\n         TM    X_FLAG1,$XF1_LDA$MXD       Did we load it?\n         BNO   X$MXDX                     No, continue\n         ICM   R0,B'1111',EP_DA$MXD       Did we load it\n         BZ    X$MXDX                     No, continue\n         DELETE EPLOC==CL8'DA$MXD'        Delete module\nX$MXDX   EQU   *\n*\n** Close the files\n*\n         LA    R3,SYSPRINT\n         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list\n         CLOSE ((3)),MF=(E,PARMLIST)      Close file\n         LA    R3,REXXOUT\n         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list\n         CLOSE ((3)),MF=(E,PARMLIST)      Close File\n         LA    R3,SYSADATA\n         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list\n         CLOSE ((3)),MF=(E,PARMLIST)      Close File\n*\n** Return to caller\n*\n         LR    R2,R13                     Get storage address\n         SLR   R3,R3\n         IC    R3,X_MAXCC\n         STORAGE RELEASE,LENGTH=DSAL,ADDR=(R2) Release storage\n         LR    R15,R3                     Set return code\n         PR    ,                          Return to caller\n         EJECT\n***********************************************************************\n***\n**       Misc Internal subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Get Current Time and Date\n*\nGet_Current_Time_Date ds 0h\n*-Obtain the time via the STCK instruction and format it\n         STCK  STCKCONI                   Get current time stamp\n*-Adjust for GMT time. Based on SYS1.V2R5M0.SHASSRC(HASCSRIC)\n         LM    R2,R3,STCKCONI      Get it\n         L     R5,CVTPTR           Get CVT addressability\n         L     R5,CVTEXT2-CVT(,R5)  Get address of extension\n         LM    R14,R15,CVTLDTO-CVTXTNT2(R5)  Time zone diff\n         LM    R6,R7,CVTLSO-CVTXTNT2(R5)  Get leap seconds\n         ALR   R3,R15              Add low order time offset\n         BC    12,GCTD$NOV         Branch if no overflow\n         AL    R2,=F'1'            Carry the 1\nGCTD$NOV ALR   R2,R14              Add high order words\n         SLR   R3,R7               Subtract low-order leap seconds\n         BC    3,GCTD$NOB          Branch if no borrow\n         BCTR  R2,0                Subtract one for borrow\nGCTD$NOB SLR   R2,R6               Subtract high-order leap seconds\n         STM   R2,R3,STCKCONI      Save adjusted time stamp\n*-Convert the time stamp from the STCK instruction\n         STCKCONV STCKVAL=STCKCONI,       Convert this TOD Stamp       @\n               CONVVAL=STCKCONO,          ..Into these date/time areas @\n               TIMETYPE=DEC,              ..Output time format         @\n               DATETYPE=YYYYMMDD,         ..Output Date format         @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    STCKCONV worked?\n         BNZ   GCTD$ES                    Failed, ABEND me\n*-Format the returned time\n         UNPK  DOUBLE2(9),STCKCONO(5)\n         MVZ   DOUBLE2(8),=8X'00'\n         TR    DOUBLE2(8),=C'0123456789ABCDEF'\n         UNPK  DOUBLE2+8(9),STCKCONO+4(5)\n         MVZ   DOUBLE2+8(8),=8X'00'\n         TR    DOUBLE2+8(8),=C'0123456789ABCDEF'\n         MVI   DOUBLE2+16,C' '\n*\n         MVC   X_TIME(2),DOUBLE2\n         MVI   X_TIME+2,C':'\n         MVC   X_TIME+3(2),DOUBLE2+2\n         MVI   X_TIME+5,C':'\n         MVC   X_TIME+6(2),DOUBLE2+4\n*-Format the returned date\n         UNPK  DOUBLE2(9),STCKCONO+8(5)\n         MVZ   DOUBLE2(8),=8X'00'\n         TR    DOUBLE2(8),=C'0123456789ABCDEF'\n         UNPK  DOUBLE2+8(9),STCKCONO+8+4(5)\n         MVZ   DOUBLE2+8(8),=8X'00'\n         TR    DOUBLE2+8(8),=C'0123456789ABCDEF'\n         MVI   DOUBLE2+16,C' '\n*                                         0123456789   01234567\n         MVC   X_DATE(4),DOUBLE2         \"CCYY      \" \"CCYYmmdd\"\n         MVI   X_DATE+4,C'-'             \"CCYY-     \"\n         MVC   X_DATE+5(2),DOUBLE2+4     \"CCYY-MM   \" \"ccyyMMdd\"\n         MVI   X_DATE+7,C'-'             \"CCYY-MM-  \"\n         MVC   X_DATE+8(2),DOUBLE2+6     \"CCYY-MM-DD\" \"ccyymmDD\"\n         B     GCTD$X\nGCTD$ES  DS    0H\n         MVC   X_TIME(8),=CL11'notavail'\n         MVC   X_DATE(11),=CL11'notavail'\nGCTD$X   DS    0H\n         BSM   0,R9\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      Check for zero\n         BZ    EDITFWF0                   Yes, save cpu time\n         CVD   R1,DOUBLE                  No, convert to packed\n         LA    R1,DOUBLE2+14              Locate Sig digit\n         MVC   DOUBLE2(15),EDITFWFP       Move in edit pattern\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,EDITFWFM               Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '                Insert space after number\n         BSM   0,R9                       Return to caller\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Insert zero\n         LA    R15,1(R15)                 Bump past zero\n         BSM   0,R9                       Return to caller\n*\n**  EDIT FULLWORD\n**   INPUT:  R1  ADDRESS OF FULLWORD\n**   OUTPUT: R15 ADDRESS OF OUTPUT (4 BYTES)\n*\nEDITFW4  DS    0H\n         CVD   R1,DOUBLE             GET IN DECIMAL\n         MVC   0(4,R15),=X'40,20,20,20'\n         ED    0(4,R15),DOUBLE+6     FORMAT PERCENTAGE\n         OI    3(R15),C'0'           ENSURE NUMERICS\n         BSM   0,R14\n*\n** Edit number\n** INPUT:  R1 - VALUE TO EDIT\n**         R15 - ADDRESS TO PUT PATTERN\n*\nEDIT15   DS    0H\n         CVD   R1,DOUBLE                  Convert to packed\n         MVC   0(15,R15),EDITP15          Get edit pattern\n         ED    0(15,R15),DOUBLE+2         Edit number\n         OI    14(R15),C'0'               Ensure zero\n         BSM   0,R14                      Return to caller\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\n         DS    0H\n*\n** Point Register 15 to the first blank in a string\n** Input:  R0  - Maximum length of the string\n**         R15 - String\n** Output: R15 - First space in the string\n*\nLOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '                Blank?\n         BE    LFS$X                      Yes, leave\n         LA    R15,1(R15)                 No, bump to next byte\n         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat\nLFS$X    EQU   *\n         BSM   0,R14                      Return to caller\n*\n** Format RECOUT for message\n*\nFORMAT_MESSAGE EQU *\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(L'RECOUT-1,R15),0(R15)\n         LA    R15,1(R15)                 Bump past FBA byte\n         MVC   0(8,R15),5(R12)            \"DA$ADATA\" from DA#ENTER\n         MVI   8(R15),C'-'\n         LA    R15,8+1(R15)\n         BSM   0,R14\n*\n** Print record on file=SYSPRINT\n*\nPRINT_SYSPRINT_RECORD EQU *\n         ST    R9,PSR_RA                  Save return address\n         CLI   PSR_LC,55\n         BNH   PSR$HX\n*\n         BAS   R14,CLEAR_HEADREC\n         MVI   0(R15),C'1'\n         LA    R15,1(R15)\n         MVC   0(8,R15),AD_ECV            Get name from module eyecatr\n         LA    R0,8\n         BAS   R14,LOCATE_FIRST_SPACE\n         MVC   1(20,R15),=C'- Utility messages -'\n         LA    R15,1+20+1(R15)            Bump past it\n         L     R1,CVTPTR                  Locate to CVT\n         MVC   0(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R1)\n         LA    R0,L'CVTSNAME              Set length of field\n         BAS   R14,LOCATE_FIRST_SPACE     Look for first space\n         MVI   1(R15),C'-'                Insert delimiter\n         LA    R15,1+1+1(R15)             Bump past it\n         MVC   0(L'X_DATE,R15),X_DATE\n         LA    R15,L'X_DATE+1(R15)\n         MVC   0(L'X_TIME,R15),X_TIME\n         LA    R15,L'X_TIME+1(R15)\n         MVC   0(6,R15),=C'- Page'        Insert text\n         LA    R15,7(R15)                Bump past it\n         L     R1,PSR_PC                  Get page count\n         LA    R1,1(R1)                   Increment\n         ST    R1,PSR_PC                  SAVE IT\n         BAS   R9,EDITFWF                 Edit the page number\n         PUT   SYSPRINT,HEADREC           Print heading record\n*\n         BAS   R14,CLEAR_HEADREC\n         PUT   SYSPRINT,HEADREC\n         MVI   PSR_LC,0\nPSR$HX   EQU   *\n         SLR   R1,R1\n         IC    R1,PSR_LC                  Get line count\n         LA    R1,1(R1)                   Increment by 1\n         STC   R1,PSR_LC                  Save line count\n         PUT   SYSPRINT,RECOUT            Print record\n*\n         L     R9,PSR_RA                  Get return address\n         BSM   0,R9                       Return to caller\n*\n** Clear heading record to blanks\n*\nCLEAR_HEADREC EQU *\n         LA    R15,HEADREC                Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it\n         BSM   0,R14                      Return to caller\n*\n** CLEAR RECOUT TO BLANKS\n*\nCLEAR_RECOUT EQU *\n         LA    R15,RECOUT                 Locate output Record\n         MVI   0(R15),C' '                Get blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         LA    R15,1(R15)                 Bump past FBA byte\n         BSM   0,R14                      Leave\n         EJECT\n***********************************************************************\n***\n**       Data Constants\n***\n***********************************************************************\n         SPACE 2\nMSG0     DC    C'00I Execution begins. (Program assembled:'\nMSG0L    EQU   *-MSG0\nMSG2     DC    C'02E Open failed to SYSADATA file'\nMSG2L    EQU   *-MSG2\nMSG3     DC    C'03E Required file not allocated: '\nMSG3SL   EQU   *-MSG3\n         DC    C'SYSADATA'\nMSG3L    EQU   *-MSG3\nMSG4     DC    C'04W Open failed to REXXOUT file, proceding without it'\nMSG4L    EQU   *-MSG4\n*\nMSG10    DC    C'04I Number of records:'\nMSG10L   EQU   *-MSG10\n*\nMSG80    DC    C'80I Record dump of type=x',X'7D'\nMSG80L   EQU   *-MSG80\nMSG81    DC    C'81I'\nMSG81L   EQU   *-MSG81\nMSG82    DC    C'82I Source record: '\nMSG82L   EQU   *-MSG82\n*\nMSG99    DC    C'99I Execution ends. Maximum condition code was'\nMSG99L   EQU   *-MSG99\n*\n** Misc constants\n*\nC_HDR1   DC    C'/*'\nC_HDR1L  EQU   *-C_HDR1\n*\nC_HDR2   DC    C' | This Rexx code was created by program DA$ADATA'\nC_HDR2L  EQU   *-C_HDR2\n*\nC_HDR3   DC    C' | which was assembled on'\nC_HDR3L  EQU   *-C_HDR3\n*\nC_HDR4   DC    C' | This output created on'\nC_HDR4L  EQU   *-C_HDR4\n*\nC_HDR5   DC    C' */'\nC_HDR5L  EQU   *-C_HDR5\n*\n** Macro copies\n*\n         PRINT NOGEN\nC_CLS    CLOSE (*-*),MF=L\nC_CLSL   EQU   *-C_CLS\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133\nC_DCBOL  EQU   *-C_DCBO\nC_DCBI   DCB   DDNAME=C_DCBI,                                          @\n               DSORG=PS,MACRF=GL,EODAD=*-*,RECFM=VB\nC_DCBIL  EQU   *-C_DCBI\n*\n         PRINT DATA\n*\n** ASMADATA record type table\n*\nT_RT       DS 0H\nT_RTJID    DC CL6'JID   ',AL2(ADATA_RECJID,TRD_JID-DA$ADATA)\nT_RTOPT    DC CL6'OPT   ',AL2(ADATA_RECOPT,TRD_OPT-DA$ADATA)\nT_RTESD    DC CL6'ESD   ',AL2(ADATA_RECESD,TRD_ESD-DA$ADATA)\nT_RTSRC    DC CL6'SOURCE',AL2(ADATA_RECSOURCE,TRD_SOURCE-DA$ADATA)\nT_RTSRCERR DC CL6'SRCERR',AL2(ADATA_RECSRCERR,TRD_SRCERR-DA$ADATA)\nT_RTDCDS   DC CL6'DCDS  ',AL2(ADATA_RECDCDS,TRD_DCDS-DA$ADATA)\nT_RTDCDSX  DC CL6'DCDSX ',AL2(ADATA_RECDCDSX,TRD_DCDSX-DA$ADATA)\nT_RTMACH   DC CL6'MACH  ',AL2(ADATA_RECMACH,TRD_MACH-DA$ADATA)\nT_RTRLD    DC CL6'RLD   ',AL2(ADATA_RECRLD,TRD_RLD-DA$ADATA)\nT_RTSYM    DC CL6'SYM   ',AL2(ADATA_RECSYM,TRD_SYM-DA$ADATA)\nT_RTXREF   DC CL6'XREF  ',AL2(ADATA_RECXREF,TRD_XREF-DA$ADATA)\nT_RTMXREF  DC CL6'MXREF ',AL2(ADATA_RECMXREF,TRD_MXREF-DA$ADATA)\nT_RTMXREFX DC CL6'MXREFX',AL2(ADATA_RECMXREFX,TRD_MXREFX-DA$ADATA)\nT_RTOUTPUT DC CL6'OUTPUT',AL2(ADATA_RECOUTPUT,TRD_OUTPUT-DA$ADATA)\nT_RTUSER   DC CL6'USER  ',AL2(ADATA_RECUSER,TRD_USER-DA$ADATA)\nT_RTUSING  DC CL6'USING ',AL2(ADATA_RECUSING,TRD_USING-DA$ADATA)\nT_RTSTATS  DC CL6'STATS ',AL2(ADATA_RECSTATS,TRD_STATS-DA$ADATA)\nT_RTAID    DC CL6'AID   ',AL2(ADATA_RECAID,TRD_AID-DA$ADATA)\nT_RTCOMP   DC CL6'COMPUN',AL2(ADATA_RECCOMPUNIT,TRD_COMPUN-DA$ADATA)\n           AIF (NOT D'ADATA_RECRXREF).TRTRXREFX\nT_RTRXREF  DC CL6'RXREF ',AL2(ADATA_RECRXREF,TRD_RXREF-DA$ADATA)\n.TRTRXREFX ANOP ,\n           AIF (NOT D'ADATA_RECAOPT).TRTAOPTX\nT_RTRAOPT  DC CL6'AOPT  ',AL2(ADATA_RECAOPT,TRD_AOPT-DA$ADATA)\n.TRTAOPTX  ANOP ,\nT_RTN      EQU   (*-T_RT)/TRT_CL\n           DC CL6'??????',AL2(0,TRD_UNK-DA$ADATA)\nT_RTL      EQU   (*-T_RT)\n           PRINT NODATA\n*\n*\nTRD_JID    DA#STR 'Job Identification record'\nTRD_OPT    DA#STR 'Options record'\nTRD_ESD    DA#STR 'External Symbol Dictionary record'\nTRD_SOURCE DA#STR 'Source record'\nTRD_SRCERR DA#STR 'Source Error record'\nTRD_DCDS   DA#STR 'DC/DS record'\nTRD_DCDSX  DA#STR 'DC/DS Extension'\nTRD_MACH   DA#STR 'Machine Instruction record'\nTRD_RLD    DA#STR 'Relocation Dictionary record'\nTRD_SYM    DA#STR 'Symbol record'\nTRD_XREF   DA#STR 'Symbol and Literal Cross Reference record'\nTRD_MXREF  DA#STR 'Macro and Copy Code Source Catalog record'\nTRD_MXREFX DA#STR 'Macro and Copy Code Cross Reference'\nTRD_USER   DA#STR 'User data'\nTRD_USING  DA#STR 'USING Map record'\nTRD_STATS  DA#STR 'Assembly Statistics record'\nTRD_OUTPUT DA#STR 'Output File Information'\nTRD_AID    DA#STR 'ADATA Identification'\nTRD_COMPUN DA#STR 'Compilation unit Start/End'\nTRD_RXREF  DA#STR 'Register Cross Reference'\nTRD_AOPT   DA#STR 'Options File Information'\nTRD_UNK    DA#STR 'Unknown record type'\n*\n** Literals\n*\nLTORG    EQU   *\n         LTORG ,\nLTORGL   EQU   *-LTORG\n         DS    0D\n*\n** Determine length left addressible in main (DA$ADATA) CSECT\n*\n#DA$ADATA EQU  *-DA$ADATA                 Bytes used\n#DA$ADATA_LEFT EQU (4096*3)-#DA$ADATA     Bytes left\n         EJECT\n***********************************************************************\n***\n**       GETMAINed work area\n***\n***********************************************************************\n           SPACE 2\nDSA        DSECT ,\n           DS    18F                      Register Save Area\nPARMLIST   DS    10F                      Parameter list for calls\nDOUBLE     DS    D                        DOUBLE WORD WORK AREA\nDOUBLE2    DS    2D                       DOUBLE WORD WORK AREA\n*                                         Execution stuff\nPSF_RECR   DS    F\n*                                         Execution stuff\nX_MAXCC    DS    X                        ..Maximum CC\nX_FLAG1    DS    B'00000000'              ..Flag 1\n$XF1_NMXD        EQU B'10000000'            ..No Mini-Hex-Dump routine\n$XF1_NRO         EQU B'01000000'            ..No REXXOUT\n$XF1_LDA$MXD     EQU B'00100000'            ..Loaded DA#MXD?\n*\n** Get_Current_Time_Date fields\n*\n         DS    0D\nSTCKCONI DS    D\nSTCKCONO DS    CL16\nX_TIME   DC    C'hh:mm:ss'\nX_DATE   DC    C'ccyy-mm-dd'\n*\n** DCBs and other file fields\n*\nSYSADATA   DS    XL(C_DCBIL)              SYSADATA file\nSYSPRINT   DS    XL(C_DCBOL)              Messages file\nREXXOUT    DS    XL(C_DCBOL)              Report file\n*\nRECOUT     DS    CL133                    RECOUT\n           DS    CL133                    \"BOB\" says we need slack\nHEADREC    DS    CL133                    Heading record\n           DS    CL133                    \"BOB\" says we need slack\n           DS    0F                       Print_Sysprint_Record\nPSR_RA     DS    F                        ..Return Address\nPSR_PC     DS    F                        ..Page Count\nPSR_LC     DS    X                        ..Line Count\n           DS    0F                       Entry Points\nEP_DA$MXD  DS    F                        ..DA$MXD\n           DS    0F\nW_DA$MXD   DS    XL(CMXDL)                DA$MXD work area\n*\n#XRTL      EQU   (T_RTL*TRTL)             Generate length of table\nX_RT       DS    XL(#XRTL)                Table\n*\n** End of the Dynamic Save Area\n*\n           DS    0D                       Align DBL word for FREEMAIN\nDSAL       EQU   *-DSA\n         END ,\n***********************************************************************\n***\n**        Linkage editor cards - ASM.PARM='BATCH,...'\n***\n***********************************************************************\n         SPACE 2\n PUNCH ' ENTRY   DA$ADATA          '      Entry point\n PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Subroutine: Mini-Hex-Dump\n PUNCH ' NAME    DA$ADATA(R)       '      Name of load module\n         END ,\n./ ADD NAME=DA$ASMHA 0100-01266-01266-1821-04390-04390-00000-DAVE\nDA$ASMHA TITLE 'Assembler H Analysis'\n***********************************************************************\n***                                                                 ***\n** Name: DA$ASMHA                                                    **\n**                                                                   **\n** Author = David Alcock :: dave@planetmvs.com\n**                                                                   **\n** Written: 1 September 1989                                         **\n**                                                                   **\n** Attributes: Reentrant, Reusable, Non-Authorized                   **\n**                                                                   **\n** Purpose: Assembler-H analysis - This program reads the output     **\n**          of the IEV90 (Assembler H) and provides these functions: **\n**                                                                   **\n**          o Create Data Area Handbook - inspired by Lionel Dyck's  **\n**            DAHANDBK program.  DA$ASMHA handles symbolics longer   **\n**            than 8 characters and instructions that are not in     **\n**            the standard columns.  IBM has started to use          **\n**            labels longer than 8 characters with TSO/E V1.4,       **\n**            'SYS1.MACLIB(IKJEESCB)'.  The handbook is in the       **\n**            format of the MVS debugging handbooks and is in these  **\n**            output types:                                          **\n**                                                                   **\n**            o Text                                                 **\n**            o DCF (not tested since 1990)                          **\n**                                                                   **\n**          o PASS3: Analysis of code:                               **\n**            o Detect subtle errors                                 **\n**            o Detect use of obsolete interfaces (Future)           **\n**            o Remove sequence numbers - Allow comments to be       **\n**              written on hardcopy without skip.                    **\n**                                                                   **\n** Parameters on the EXEC card:                                      **\n** - NAMEL=x........Length of label (name) field in Data Area        **\n**                  Handbook.  Defaults to 8. It should be specified **\n**                  as one more than you want. For example, NAMEL=11 **\n**                  for labels from 1-10.                            **\n** - ASMPARM(x,y)...Parameters to be passed to IEV90 when doing      **\n**                  inline assembles                                 **\n** - SYSTEM(title)..Title of application system? DCF only?           **\n** - ADDR=01234567..Starting address.  As the program listing is     **\n**                  being printed, the address will increment based  **\n**                  on the starting address.  You could use this     **\n**                  while debugging to make a SYSUDUMP reading easier**\n**                  by getting the execution EPA and the assembler   **\n**                  listing would match the dump                     **\n** - Flags:                                                          **\n**   - ASM..........Invoke the IEV90 assembler (see ASMPARM())       **\n**   - DEBUGS.......Debugging messages short (Consise)               **\n**   - DEBUGF.......Debugging messages full (Verbose)                **\n**   - NOLOGO.......Do not invoke the IBM BLOCK letter routine       **\n**   - NOCDASH......Bypass a dash at the beginning of a comment      **\n**   - REMOVESQ.....Remove Sequence numbers                          **\n**   - DCF..........Create DCF output                                **\n**     - NOBOX........Do not put box on DCF output                   **\n**     - BODYONLY.....DCF: only print the body                       **\n**                                                                   **\n** External Programs:                                                **\n** o IEFSD095...IBM block letter routine (optional)                  **\n** o IEV90......With the PARM='ASM,ASMPARM()\" option: invoke IBM's   **\n**              Assembler H                                          **\n** o DA$DATE....Date routine                                         **\n** o DA$MXD.....Mini-Hex-Dump routine                                **\n**                                                                   **\n** Non-IBM assembler MACROs:                                         **\n** o DA#ENTER...Entry housekeeping                                   **\n** o DA#LEAVE...Termination housekeeping                             **\n** o DA#EYEC....Build standard O/S module eyecatcher                 **\n**              (invoked by the DA#ENTER)                            **\n** o DA#REGS....Define registers (invoked by DA#ENTER)               **\n** o DA#DATE....Equates and DSECTs for the date routine              **\n** o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine     **\n**                                                                   **\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n**                                                                   **\n** Restrictions:                                                     **\n** o Assembler H (for both assembling and processing)                **\n** o DCF option: Requires DCF, Data Composition Facility and Book-   **\n**   Master for interpretation of output.                            **\n** o Assembler control instructions not supported:                   **\n**   ICTL, OPSYN                                                     **\n**                                                                   **\n** Note:                                                             **\n** o Terms based on GC26-4037 \"Assembler H V2 Language Reference\":   **\n**   NAME     OPERATION OPERAND            REMARKS                   **\n**   -------- --------- ---------------    ------------------------  **\n**   OPENFLS  OPEN      (SYSIN,(INPUT))    Open input file           **\n**                                                                   **\n** ----------------------------------------------------------------- **\n**                                                                   **\n** Enhancement queue:                                                **\n** o Create COBOL, IPCS, PL1 and SAS code from DSECTs                **\n** o Source Pretty Printing (half-implemented)                       **\n** o DCF is old hat, HTML is king!!!!!  circa 1996                   **\n**                                                                   **\n**   This enhancement queue will probably never be implemented       **\n**   because the Assembler H has been replaced with HLASM and it     **\n**   has the ADATA output file which is FAR superior to this         **\n**   \"Screen Scraper\" technology....David Alcock 13-NOV-1996         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n&DAVER   SETC  '1.4'\n***********************************************************************\n***\n**           M o d i f i c a t i o n   H i s t o r y\n**\n** Person     Date        Ver Description\n** ---------- ----------- --- ----------------------------------------\n** D Alcock   13-NOV-1996 1.4 Added Label overflow code to print msgs\n**                            17 and 18; Detect Trailer records and\n**                            ignore them;\n** D Alcock   06-NOV-1996 1.3 Renamed to DA$ASMHA\n** D Alcock   08-JAN-1991 1.2 Added better DCF formating; BAL STMT\n**                            suppression in Data Area Hand Books;\n** D Alcock   25-JUL-1990 1.1 Completed DCF/BookMaster output creation;\n** D Alcock   01-SEP-1989 1.0 Initial program created;\n**\n***\n***********************************************************************\n         EJECT ,\nDA$ASMHA DA#ENTER 'V&DAVER Utility: Assembler H output analysis',      @\n               RENT=YES,                  Indicate we want GETMAIN     @\n               LV=WORKDSL,                Length of GETMAIN            @\n               BASE=(12,11,10)            Obtain some base registers\n         USING WORKDS,R13                 Addressability to work area\n         ST    R1,R1SAVE                  Save parameter list address\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Initialization Section                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Load external routines needed\n*\n         ICM   R0,B'1111',=V(DA$DATE)     DA$DATE linked into us?\n         BNZ   I$DA$DATEX                 Yes\n         LA    R8,=CL8'DA$DATE'           No, get name\n         LOAD  EPLOC=(8),ERRET=E$LOAD     ....and try to load it\n         OI    X_FLAG2,$XF2_DDATE         Turn on flag\nI$DA$DATEX EQU *\n         ST    R0,EP_DA$DATE\n*\n** Set the current date and time for report headings\n*\n         MVC   X_ODGEUR11(C_ODGEUR11L),C_ODGEUR11\n         MVC   X_OTIMES11(C_OTIMES11L),C_OTIMES11\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of R$DATE routine\n         CALL  (15),(X_ODGEUR11,X_OTIMES11),VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n*\n** Open SYSPRINT file for Global messages\n*\n         LA    R1,WA_FWA_SYSPRINT         Locate file work area\n         L     R14,=V(RAA$DATA)\n         LA    R15,C_SYSPRINT-RAA$DATA(R14)\n         LA    R8,C_SYSPRINTN-RAA$DATA(R14)\n         BAS   R14,OPEN_FILE_WORK_AREA    Open the file\n*\n** Print starting message\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG1L,R15),MSG1-RAA$DATA(R1)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Parse parameter card                                        **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPARSE_PARAMETER_CARD EQU *\n#PPC_NAMEL EQU 8-1\n         LA    R1,#PPC_NAMEL\n         ST    R1,PPC_NAMEL\n         MVI   PPC_CCC,C'!'               Set default Comment Cntl Char\n*\n** Locate the parameter card from the EXEC card\n*\n         L     R1,R1SAVE                  Get address of parameter addr\n         L     R1,0(R1)                   Get address of parameter\n         SLR   R6,R6                      Zero register\n         ICM   R6,B'0011',0(R1)           Get length of parameter\n         BZ    PPC$X                      None, continue\n         LA    R7,2(R1)                   Locate past length halfword\n         BAS   R9,FORMAT_MESSAGE          Format message\n         MVC   0(MSG105L,R15),MSG105-RAA$DATA(R1)\n         LA    R15,MSG105L+1(R15)         Bump past it\n         LR    R1,R6                      Get length\n         BCTR  R1,0                       Decrement by 1\n         EX    R1,PPC$PRMM                Move parameter to message\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     PPC$DLMX                   Test first parameter\nPPC$PRMM MVC   0(0,R15),0(R7)             Get parameter\n*\n** Test for valid delimiter between operands\n*\nPPC$DLM  EQU   *\n         CLI   0(R7),C','                 Valid delimiter?\n         BE    PPC$DLME                   No, print error message\n         CLI   0(R7),C' '                 Valid delimiter?\n         BNE   PPC$DLMX                   Yes, continue\n         LA    R7,1(R7)                   Bump to next byte\n         BCT   R6,PPC$DLM                 Find next non-blank\n         B     PPC$X                      Leave\nPPC$DLMG EQU   *\n         LA    R7,1(R7)                   Bump past delimiter\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      End?\n         BZ    PPC$END                    Yes, continue\nPPC$DLME EQU   *\n         LA    R7,1(R7)                   Bump past delimiter\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      End?\n         BZ    PPC$END                    Yes, continue\nPPC$DLMX EQU   *\n*\n** Process keywords into program flags. Generate an OI instruction to\n** turn on flag:\n**\n** OI   PPC_FLAG1,$PPC_F1NOLOGO   -   If PARM=NOLOGO\n*\n         LA    R3,T_PFLAGSN               Get number of entries\n         L     R2,=V(RAA$DATA)\n         LA    R2,T_PFLAGS-RAA$DATA(R2)   Locate flag\nPPC$FL   EQU   *\n         SLR   R14,R14                    Clear register\n         IC    R14,TPF_NAMEL-TPF(R2)      Get length of operand\n         CR    R14,R6                     Room in parse area for flag?\n         BH    PPC$FLB                    No, continue\n         EX    R14,PPC$FLC                Match?\n         BE    PPC$FLX                    Yes, continue\nPPC$FLB  EQU   *\n         LA    R2,TPFL(R2)                Bump to next entry\n         BCT   R3,PPC$FL                  ..Process it\n         B     PPC$FX                     Continue: not a flag\nPPC$FLC  CLC   TPF_NAME-TPF(0,R2),0(R7)\nPPC$FOI  OI    *-*,4\nPPC$FLX  EQU   *\n         MVC   DOUBLE(4),PPC$FOI          Get Instruction\n         MVC   DOUBLE+1(1),TPF_FLAG-TPF(R2)    Set flag\n         MVC   DOUBLE+2(2),TPF_OFFSET-TPF(R2) Get offset\n         OI    DOUBLE+2,X'D0'             Register 13/WORKDS\n*The next few instructions can be uncommented and used for debugging\n*MVC WTOMSG+8+10(8),TPF_NAME-TPF(R2)\n*UNPK WTOMSG+8+19(9),DOUBLE(5)\n*MVZ  WTOMSG+8+19(8),ZEROS\n*TR   WTOMSG+8+19(8),HEXTABLE\n*MVI  WTOMSG+8+19+8,C'='\n*WTOMSG WTO 'R$PDSANL: xxxxxxxx xxxxxxxx=Instruction'\n         LA    R15,0                      Set up for EX\n         EX    R15,DOUBLE                 Execute: OI field,flag\nPPC$FLDL EQU   *\n         CLI   0(R7),C' '                 Valid Delimiter?\n         BE    PPC$DLM\n         CLI   0(R7),C','                 Valid Delimiter?\n         BE    PPC$DLM\n         LA    R7,1(R7)                   Bump past extra byte\n         BCT   R6,PPC$FLDL                Process next one\n         B     PPC$X                      End of the Parameter string\n*\nPPC$FX   EQU   *\n*\n** Maximum name length for Data Area Hand Books\n*\nPPC$NAME EQU   *\n         CLC   0(6,R7),=C'NAMEL='\n         BNE   PPC$NAMEX                  No, continue\n         LA    R7,6(R7)                   Bump past \"NAMEL=\"\n         SH    R6,=H'6'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,DOUBLE                  Locate output\n         LA    R14,4                      Set max\n         SLR   R15,R15                    Set count\nPPC$NAMEL EQU  *\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$NAMELX                 Yes, continue\n         LA    R15,1(R15)                 Increment count\n         CLI   0(R7),C','                 Found delimiter?\n         BE    PPC$NAMELX                 Yes, leave\n         BCT   R6,PPC$NAMEL               Process next byte\nPPC$NAMELX EQU *\n         BCTR  R15,0                      Decrement for later\n         EX    R15,PPC$NAMEP              Save count\n         CVB   R1,DOUBLE2                 Convert it to binary\n         LTR   R1,R1                      Zero?\n         BZ    PPC$OERR                   I can't take a joke\n         BCTR  R1,0                       Decrement for EX\n         ST    R1,PPC_NAMEL               Save it\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$NAMEP PACK DOUBLE2(8),DOUBLE(0)\nPPC$NAMEX EQU  *\n*\n** Assembler Parameter (when we invoke it)\n*\nPPC$AP   EQU   *\n         CLC   0(8,R7),=C'ASMPARM('\n         BNE   PPC$APX\n         OI    PPC_FLAG1,$PPC_F1ASM       Turn on option !!!!!!!!!!\n         LA    R7,8(R7)                   Bump past \"ASMPARM=\"\n         SH    R6,=H'8'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,PPC_ASMPARM+2           Locate output\n         LA    R14,L'PPC_ASMPARM-3        Set max\n         SLR   R15,R15                    Set count\nPPC$APL  EQU   *\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         LA    R15,1(R15)                 Increment count\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$APLX                   Yes, continue\n         CLI   0(R7),C')'                 Found delimiter?\n         BE    PPC$APLX                   Yes, leave\n         BCT   R6,PPC$APL                 Process next byte\nPPC$APLX EQU   *\n         STC   R15,PPC_ASMPARM+1          Save count\n         LA    R7,1(R7)                   Bump past \")\"\n         SH    R6,=H'2'                   Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$APX EQU    *\n*\n** System\n*\nPPC$TL   EQU   *\n         CLC   0(7,R7),=C'SYSTEM('\n         BNE   PPC$TLX\n         LA    R7,7(R7)                   Bump past \"SYSTEM(\"\n         SH    R6,=H'7'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,PPC_TITLE+1             Locate output\n         LA    R14,L'PPC_TITLE-1          Set max length\n         SLR   R15,R15                    Set count\nPPC$TLL  EQU   *\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         LA    R15,1(R15)                 Increment count\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$TLLX                   Yes, continue\n         CLI   0(R7),C')'                 Found delimiter?\n         BE    PPC$TLLX                   Yes, leave\n         BCT   R6,PPC$TLL                 Process next byte\nPPC$TLLX EQU   *\n         BCTR  R15,0                      Decrement for later EX\n         STC   R15,PPC_TITLE              Save count\n         LA    R7,1(R7)                   Bump past \")\"\n         SH    R6,=H'2'                   Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$TLX EQU    *\n*\n** Starting address to enhance Assembly listing\n*\nPPC$ADDR EQU   *\n         CLC   0(5,R7),=C'ADDR='\n         BNE   PPC$ADDRX\n         LA    R7,5(R7)                   Bump past \"ADDR=\"\n         SH    R6,=H'5'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,PARMLIST                Output location\n         LA    R14,8                      Set max\n         SLR   R15,R15                    Set count\nPPC$ADDRL EQU  *\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         LA    R15,1(R15)                 Increment count\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$ADDRLX                 Yes, continue\n         CLI   0(R7),C','                 Found delimiter?\n         BE    PPC$ADDRLX                 Yes, leave\n         BCT   R6,PPC$ADDRL               Process next byte\nPPC$ADDRLX EQU *\n         CH    R15,=H'8'\n         BNE   PPC$OERR\n         LA    R0,4                       Input length / 2\n         LA    R1,PPC_ADDR                Locate output hex value str\n         LA    R15,PARMLIST               Get input location\n         BAS   R8,HEXTRAN                 Convert to hex\n         OI    PPC_FLAG1,$PPC_F1ADDR\n*\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$ADDRX EQU  *\n*\n** Parameter in error: isolate it, note position and continue\n*\nPPC$OERR EQU   *\n         SLR   R1,R1                      CLEAR OUT REGISTER\n         ICM   R1,B'0011',PPC_COL         GET PREVIOUS PARM ERR COLUMN\n         BNZ   PPC$GNUM                   YES, GO INCREMENT NUMBER\n         L     R1,R1SAVE                  GET ADDR OF ADDR OF PARM\n         L     R1,0(R1)                   NOW GET ADDRESS OF PARM\n         LH    R1,0(R1)                   GET LENGTH OF PARM\n         SR    R1,R6                      SUBTRACT FROM CURRENT LOC\n         LA    R1,1(R1)                   Make offset from 1 not zero\n         STH   R1,PPC_COL                 SAVE LOCATION OF ERROR\nPPC$GNUM EQU   *\n         LH    R1,PPC_NUM                 GET NUMBER OF ERRORS IN PARM\n         LA    R1,1(R1)                   INCREMENT BY 1\n         STH   R1,PPC_NUM                 SAVE FOR LATER\nPPC$RR   EQU   *\n         CLI   0(R7),C','                 HIT A COMMA YET?\n         BE    PPC$BRK                    YES, LEAVE\n         LA    R7,1(R7)                   BUMP TO NEXT BYTE\n         BCT   R6,PPC$RR                  TEST IT OUT\n         B     PPC$END                    END OF PARMS...\nPPC$BRK  EQU   *\n         LA    R7,1(R7)                   BUMP PAST COMMA\n         LTR   R6,R6                      TEST FOR ZERO LENGTH\n         BZ    PPC$END                    YES, END RIGHT NOW\n         BCT   R6,PPC$DLMX                NO, LETS TEST SOME MORE\n*\n** End of parameters found\n*\nPPC$END  EQU   *\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0011',PPC_NUM         Get number of parm errors\n         BZ    PPC$X                      None, continue\n*\n         MVI   X_MAXCC,20                 Set max condition code\n         BAS   R9,FORMAT_MESSAGE          Format message\n         MVC   0(MSG106L,R15),MSG106-RAA$DATA(R1)\n         LA    R15,MSG105L+1(R15)         Bump past it\n         L     R8,R1SAVE                  Get address of parameter addr\n         L     R8,0(R8)                   Get address of parameter\n         LH    R14,0(R8)                  Get length of parameter\n         BCTR  R14,0                      Decrement by 1\n         LA    R7,C_NUMBER-RAA$DATA(R1)   Locate numbers\n         EX    R14,PPC$PRMM               Move parameter to message\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BAS   R9,FORMAT_MESSAGE          Format message\n         MVC   0(MSG107L,R15),MSG107-RAA$DATA(R1)\n         LA    R15,MSG107L(R15)           Bump past it\n         LH    R1,PPC_NUM                 Get number\n         BAS   R9,EDITFWF                 Edit number\n         MVC   0(30,R15),=C', first one in error at column'\n         LA    R15,31(R15)                Bump past text\n         LH    R1,PPC_COL                 Get column number\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     EXIT\n*\n** Common Exit from Parse_Parameter_Card\n*\nPPC$X    EQU   *\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Invoke assembler                                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nINVOKE_ASSEMBLER EQU *\n         MVC   RAR_IDD(8),=CL8'SYSUT1'    Set default\n         TM    PPC_FLAG1,$PPC_F1ASM\n         BNO   IA$X\n*\n** Is Assembler input file allocated?\n*\n         L     R8,=V(RAA$DATA)            -> RAA$DATA\n         LA    R7,C_APIDD-RAA$DATA(R8)    Locate input DD name\n         DEVTYPE (7),DOUBLE               Get file information\n         LTR   R15,R15                    Allocated?\n         BZ    IA$TDDX                    No, continue\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG12L,R15),MSG12-RAA$DATA(R1)\n         MVC   MSG12L(8,R12),C_APIDD-RAA$DATA(R8)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         MVI   X_MAXCC,20\n         B     EXIT\nIA$TDDX  EQU   *\n*\n** Attach the assembler\n*\n         LA    R9,DOUBLE                  Locate Event Control Block\n         XC    0(4,R9),0(R9)              Clear Event control Block\n         L     R14,=V(RAA$DATA)           -> RAA$DATA\n         MVC   PARMLIST(C_ATCL),C_ATC-RAA$DATA(R14)\n*\n         LA    R1,RAR_DPNAMEA             Assembler Parameter List area\n         LA    R14,PPC_ASMPARM            -> Option list\n         ST    R14,0(R1)                  Save\n         LA    R14,C_APDD-RAA$DATA(R8)    -> DDNAME list\n         ST    R14,4(R1)                  Save\n         OI    4(R1),X'80'                Set end of list\n*\n         ATTACH EPLOC==CL8'IEV90',        Attach Assembler             @\n               ECB=(9),                   ..Event Control Block        @\n               SF=(E,PARMLIST)            ..Attach Execute form\n         ST    R1,DOUBLE2                 Save TCB address\n*\n         WAIT  ECB=DOUBLE                 Wait for Assembler\n         DETACH DOUBLE2                   Detach Assembler\n*\n** Print status of call to assembler\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG8L,R15),MSG8-RAA$DATA(R1)\n         LA    R15,MSG8L(R15)             Bump past it\n         UNPK  0(7,R15),DOUBLE+1(4)\n         MVZ   0(6,R15),=X'00,00,00,00,00,00,00,00'\n         TR    0(6,R15),=C'0123456789ABCDEF'\n         MVI   6(R15),C' '\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n         MVC   RAR_IDD(8),C_APIDD-RAA$DATA(R8)\n*\n         CLC   DOUBLE+1(3),=X'00,00,04'   Assembler successful?\n         BNH   IA$X\n         MVI   X_MAXCC,20\n         B     EXIT\n*\n** Exit from Invoke_Assembler\n*\nIA$X     EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Read Assembler records                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nREAD_ASSEMBLER_RECORD EQU *\n*\n** Open input assembler file (SYSUT1 or ASMPRINT)\n*\n         LA    R3,SYSUT1                  Locate DCB\n         MVC   0(C_DCBIL,R3),C_DCBI       Copy in DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),RAR_IDD\n         LA    R1,RAR$EOF                 Locate end of file location\n         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n*\n         LA    R15,SYSUT1_EXLST           LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n*\n         LA    R14,SYSUT1_JFCB            Locate JFCB return area\n         ST    R14,SYSUT1_EXLST           Save into JFCB area\n         OI    SYSUT1_EXLST,X'07'         Indicate JFCB return\n*\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,SYSUT1_EXLST+4          PUT INTO EXLST\n         OI    SYSUT1_EXLST+4,X'11'       DCB EXIT\n         OI    SYSUT1_EXLST+4,X'80'       END OF LIST\n         XC    CO_OPENC(4),CO_OPENC       CLEAR OPEN-ABEND CODE\n*\n         MVC   PARMLIST(C_RDJFCBL),C_RDJFCB\n         RDJFCB ((3),(INPUT)),MF=(E,PARMLIST)\n*\n         MVC   PARMLIST(C_LSTIL),C_LSTI   COPY IN OPEN PARM LIST\n         OPEN  ((3),(INPUT)),TYPE=J,                                   @\n               MF=(E,PARMLIST)            OPEN DCB\n         BAS   R9,CHECK_OPEN              CHECK OPEN\n*\n** Print message showing type\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG11L,R15),MSG11-RAA$DATA(R1)\n         LA    R15,MSG11L(R15)            Bump past it\n         LA    R8,SYSUT1_JFCB\n         MVC   0(44,R15),JFCBDSNM-INFMJFCB(R8)\n         LA    R0,44\n         BAS   R14,LOCATE_FIRST_SPACE\n         TM    JFCBIND1-INFMJFCB(R8),JFCPDS\n         BNO   RAR$IS1POX\n         MVI   0(R15),C'('\n         MVC   1(8,R15),JFCBELNM-INFMJFCB(R8) Get member name\n         LA    R0,9                       Length of \"(member  \"\n         BAS   R14,LOCATE_FIRST_SPACE\n         MVI   0(R15),C')'\n         LA    R15,1(R15)\nRAR$IS1POX EQU *\n         MVC   0(4,R15),=C', as'\n         LA    R15,5(R15)\n         CLI   DCBLRECL-IHADCB+1(R3),80   80 byte source input?\n         BE    RAR$IS1S\n         MVC   0(7,R15),=C'listing'\n         B     RAR$IS1X\nRAR$IS1S EQU   *\n         MVC   0(6,R15),=C'source'\n         OI    X_FLAG1,$XF1_SRC\nRAR$IS1X EQU   *\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n** Open optional PASS3 file\n*\n         TM    X_FLAG1,$XF1_SRC           Source?\n         BO    RAR$IP3X                   Yes, bypass open of PASS3\n         LA    R8,=CL8'PASS3'             Locate file name\n         DEVTYPE (8),DOUBLE               Get file information\n         LTR   R15,R15                    Allocated?\n         BNZ   RAR$IP3X                   No, continue\n         OI    X_FLAG1,$XF1_PASS3         Yes, turn on flag\n*\n         LA    R3,PASS3                   Locate DCB area\n         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),0(R8)\n         LA    R1,SYSUT1                  Locate input asm file\n         MVC   DCBLRECL-IHADCB(2,R3),=AL2(133)\n         MVC   DCBBLKSI-IHADCB(2,R3),=AL2(1330)\n         MVC   DCBRECFM-IHADCB(1,R3),DCBRECFM-IHADCB(R1)\n*\n         LA    R15,PASS3_EXLST            LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,PASS3_EXLST             PUT INTO EXLST\n         OI    PASS3_EXLST,X'11'          DCB EXIT\n         OI    PASS3_EXLST,X'80'          END OF LIST\n         XC    CO_OPENC(4),CO_OPENC       CLEAR OPEN-ABEND CODE\n*\n         MVC   PARMLIST(C_LSTOL),C_LSTO   Get open Parameter List\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PARMLIST)\n         BAS   R9,CHECK_OPEN              CHECK OPEN\nRAR$IP3X EQU   *\n*\n** Open optional INDEX file\n*\n         TM    PPC_FLAG2,$PPC_F2DCF       Document Composition Fac?\n         BO    RAR$IINDEXX                Yes, no need for index\n         TM    X_FLAG1,$XF1_SRC           Source?\n         BO    RAR$IINDEXX                Yes, no Data-Area-HandBook\n         LA    R8,C_INDEX+1               Locate file name\n         DEVTYPE (8),DOUBLE               Get file information\n         LTR   R15,R15                    Allocated?\n         BNZ   RAR$IINDEXX                No, continue\n         OI    X_FLAG1,$XF1_INDEX         Yes, turn on flag\n*\n         LA    R0,INDEXAL                 No, get length of area\n         GETMAIN R,LV=(0)                 Obtain storage\n         STM   R0,R1,INDEX_AREA           Save address and length\n*\n         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate file work area\n         LA    R15,C_INDEXD               Description string\n         BAS   R14,OPEN_FILE_WORK_AREA    Open the file\n*\n         L     R1,INDEX_AREA+4            Locate Index Area\n         LA    R15,INDEXA_RH1-INDEXA(R1)  Locate our title line\n         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate File work area\n         ST    R15,FWA_RH1A-FWA(R1)       Save it\n         BAS   R14,CR$CLEAR               Clear area to blanks\n*\n         L     R1,INDEX_AREA+4            Locate Index Area\n         LA    R15,INDEXA_RH2-INDEXA(R1)  Locate our title line\n         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate File work area\n         ST    R15,FWA_RH2A-FWA(R1)       Save it\n         BAS   R14,CR$CLEAR               Clear area to blanks\n         MVC   INDEX_NUM+1-INDEX(3,R15),=C'Num'\n         MVC   INDEX_NAME-INDEX(04,R15),=C'Name'\n         MVC   INDEX_PAGE-INDEX(04,R15),=C'Page'\n*\n         L     R15,=V(RAA$DATA)           -> Data CSECT\n         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dashes\n         ST    R15,FWA_RH3A-FWA(R1)       Save it\nRAR$IINDEXX EQU *\n*\n** Open optional REPORT file\n*\n         LA    R8,=CL8'REPORT'            Locate file name\n         DEVTYPE (8),DOUBLE               Get file information\n         LTR   R15,R15                    Allocated?\n         BNZ   RAR$IRPTX                  No, continue\n         OI    X_FLAG1,$XF1_REPORT        Yes, turn on flag\n*\n         LA    R1,WA_FWA_REPORT           Locate file work area\n         LA    R15,RAR_DHB_DESC           Description string\n         TM    X_FLAG1,$XF1_SRC\n         BNO   RAR$IRPT_SRCX\n         LA    R15,C_SRC\nRAR$IRPT_SRCX EQU *\n         MVC   0(C_DAHANDBKDL,R15),C_DAHANDBKD\n         BAS   R14,OPEN_FILE_WORK_AREA    Open the file\n*\n         TM    X_FLAG1,$XF1_SRC\n         BO    RAR$IRPTX\n         OI    X_FLAG1,$XF1_DHB           Turn on Data Hand Book flag\n         LA    R1,WA_FWA_REPORT           Locate file work area\n         LA    R15,DAHANDBK_RH1           Locate our title line\n         ST    R15,FWA_RH1A-FWA(R1)       Save it\n         BAS   R14,CR$CLEAR               Clear area to blanks\n         MVC   DHBR_OFFD-DHBR(16,R15),=C'---- Offset ----'\n*\n         LA    R15,DAHANDBK_RH2           Locate our title line\n         ST    R15,FWA_RH2A-FWA(R1)       Save it\n         BAS   R14,CR$CLEAR               Clear area to blanks\n         MVC   DHBR_OFFD+1-DHBR(07,R15),=C'Decimal'\n         MVC   DHBR_OFFX-DHBR(03,R15),=C'Hex'\n         MVC   DHBR_TYPE-DHBR(04,R15),=C'Type'\n         MVC   DHBR_LEN+2-DHBR(06,R15),=C'Length'\n         MVC   DHBR_NAME-DHBR(04,R15),=C'Name'\n         LA    R15,DHBR_NAME-DHBR(R15)\n         A     R15,PPC_NAMEL\n         MVC   3(11,R15),=C'Description'\n*\n         L     R15,=V(RAA$DATA)           -> Data CSECT\n         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dashes\n         ST    R15,FWA_RH3A-FWA(R1)       Save it\n*\n         LA    R1,132-4                   Get length of record\n         S     R1,PPC_NAMEL               - length of name\n         SH    R1,=AL2(DHBR_NAME-DHBR)    - rest of record\n         ST    R1,RAR_DHB_DESCL           Max amount for description\nRAR$IRPTX EQU  *\n*\n** Load Block letter routine (if available)\n**\n** IEFSD095 - IBM: In 'SYS1.AOSD0'\n**\n** Note: This routine is not essential and will be bypassed if program\n**       can not be located.\n*\n         TM    PPC_FLAG1,$PPC_F1NOLOGO    Need Logos?\n         BO    RAR$ID095X                 Nope\n         ICM   R0,B'1111',=V(IEFSD095)    IEFSD095 linked into us?\n         BNZ   RAR$ID095X                 Yes, continue\n         BAS   R14,CLEAR_RECOUT\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG5L,R15),MSG5-RAA$DATA(R1)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\nRAR$ID095X EQU *\n*\n** DCF initializations\n*\n         TM    PPC_FLAG2,$PPC_F2BODYONLY  Body Only?\n         BO    RAR$IDCFX                  No, continue\n         TM    PPC_FLAG2,$PPC_F2DCF       DCF?\n         BNO   RAR$IDCFX                  No, continue\n*\n         L     R8,=V(RAA$DCF)             -> RAA$DCF CSECT\n         LA    R1,RAA$DCF_HEADER-RAA$DCF(R8) Locate heading\n         BAS   R14,PRINT_DCF_STRINGS      Print all strings\nRAR$IDCFX EQU *\n*\n** Misc initializations\n*\n         BAS   R14,RAR$RSETF              Reset fields\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Read Assembler record                                       **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Read record\n*\nRAR$L    EQU   *\n         GET   SYSUT1                     Get input record\n         LR    R5,R1                      Save address\n*\n         MVI   RAR_TYPE,0                 Reset type\n*\n** Increment record count\n*\n         L     R1,RAR_CNTIREC             Get current count\n         LA    R1,1(R1)                   Increment it\n         ST    R1,RAR_CNTIREC             Save count\n*\n** Source pre-processing\n*\n         TM    X_FLAG1,$XF1_SRC           Source input?\n         BNO   RAR$PP_SRCX                No, continue\n         LR    R15,R5                     Save input record location\n         LA    R5,RAR_SRC_REC             Locate new fake record\n         MVI   0(R5),C' '                 Get blank\n         MVC   1(L'RAR_SRC_REC-1,R5),0(R5) ..Propagate it\n         MVC   AHSD_SOURCE-AHS(80,R5),0(R15)  Get input record\n         L     R1,RAR_CNTIREC             Get record count\n         CVD   R1,DOUBLE                  Make packed\n         MVC   AHSD_STMT+2-AHS(3,R5),EDITP15F+1\n         ED    AHSD_STMT+1-AHS(4,R5),DOUBLE+6\n         MVC   RAR_SRC_DPFLAG1(1),RAR_DPFLAG1\nRAR$PP_SRCX EQU *\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Debugging                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Print Dash line\n*\n         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?\n         BNO   RAR$DB1UX                  No, skip record echo\n         L     R15,=V(RAA$DATA)           -> Data CSECT\n         MVC   RECOUT(133),C_DASHLINE-RAA$DATA(R15)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\nRAR$DB1UX EQU *\n*\n** Print input record hex dump format\n*\n         TM    PPC_FLAG1,$PPC_F1DEBUGF    Debugging full mode?\n         BNO   RAR$DB1FX                  No, skip hex dump\n*\n         TM    X_FLAG1,$XF1_NMXD          Determined not available?\n         BO    RAR$DB1FX                  Yes, continue\n         TM    X_FLAG2,$XF2_DMXD          Loaded DA$MXD already?\n         BO    RAR$DB1RX                  Yes, continue\n         ICM   R0,B'1111',=V(DA$MXD)      DA$MXD linked into us?\n         BNZ   RAR$DB1LX                  Yes, use it\n         LA    R8,=CL8'DA#MXD'            -> Name of routine\n         LOAD  EPLOC=(8),ERRET=RAR$DB1RE  Load into V/S\n         OI    X_FLAG2,$XF2_DMXD          Turn on flag\nRAR$DB1LX DS   0H\n         ST    R0,EP_DA$MXD               Save address\n         B     RAR$DB1RX                  Continue\nRAR$DB1RE EQU  *\n         OI    X_FLAG1,$XF1_NMXD          Turn on flag\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG99L,R15),MSG99-RAA$DATA(R1)\n         MVC   MSG99L(8,R15),0(R8)\n         MVC   MSG99L+8(34,R15),=C', no hex dumps will be performed'\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         B     RAR$DB1FX\nRAR$DB1RX EQU  *\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVC   0(22,R15),=C'+ Dump of input record'\n         LA    R15,23(R15)\n         L     R1,RAR_CNTIREC             Get record number\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(14,R15),=C', in buffer at'\n         LA    R15,15(R15)\n         ST    R5,DOUBLE\n         UNPK  0(9,R15),DOUBLE(5)\n         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         MVI   0(R15),C':'                Insert colon\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         LA    R3,WA_FWA_SYSPRINT         Locate File-Work-Area\n*\n         XC    PARMLIST(CMXDL),PARMLIST   Initialize area\n         LR    R15,R5                     Locate input record\n         LA    R1,SYSUT1                  Locate DCB\n         LH    R0,DCBLRECL-IHADCB(R1)     Get LRECL\n         LA    R1,RECOUT+3                Get output location\n         STM   R15,R1,PARMLIST+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   PARMLIST+CMXD_OUTPUTL-CMXD(2),=AL2(132)\nRAR$DB1L EQU   *\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         LA    R1,PARMLIST                Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         LR    R8,R15                     Save return code\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   RAR$DB1L                   Thank you: May I have another\nRAR$DB1FX EQU  *\n*\n** Print input record in charater\n*\n         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?\n         BNO   RAR$DB1SX                  No, skip record echo\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVI   0(R15),C'>'\n         LA    R15,2(R15)\n         MVC   0(121-1,R15),1(R5)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\nRAR$DB1SX EQU  *\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Parse for record type                                       **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         CLI   AHS_CC-AHS(R5),X'8B'       Werid FBM thang?\n         BE    RAR$LX\n*\n         CLC   AHSI_IEVMSGP-AHS(6,R5),=C'   IEV'\n         BE    RAR$IEV\n*\n         CLC   AHST_PAGELIT-AHS(4,R5),=C'PAGE'\n         BE    RAR$TITLE\n*\n         CLC   AHSH_LOC-AHS(3,R5),=C'LOC'\n         BE    RAR$HEAD\n*\n         CLI   AHSD_STMT+4-AHS(R5),C'0'\n         BNL   RAR$DATA\n         CLI   AHSD_MACEXP-AHS(R5),C'+'\n         BE    RAR$DATA\n*\n** End of processing\n*\nRAR$LX   EQU   *\n         TM    X_FLAG1,$XF1_DHB           Doing Data Book Handbook?\n         BNO   RAR$LXDHBX                 No, continue\n         BAS   R14,RAR$DHB                Yes, do routine\nRAR$LXDHBX EQU *\n         TM    X_FLAG1,$XF1_SRC\n         BNO   RAR$LXSRCX                 No, continue\n         BAS   R14,RAR$SRC                Yes, do routine\nRAR$LXSRCX EQU *\n         TM    X_FLAG1,$XF1_PASS3         Doing Data Book Handbook?\n         BNO   RAR$LXP3X                  No, continuen\n         BAS   R14,RAR$PASS3              Yes, do routine\nRAR$LXP3X EQU  *\n         TM    RAR_DPFLAG1,$RARDPF1_CONT  Continutation card\n         BO    RAR$LXRFX                  Yes, no reset...\n         BAS   R14,RAR$RSETF              Reset fields\nRAR$LXRFX EQU  *\n         B     RAR$L                      Read next record\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Data/Assembler Instruction record                           **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$DATA  EQU  *\n         MVI   RAR_TYPE,$RART_DATA       Indicate we get instructions\n*\n** Debugging message\n*\n         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?\n         BNO   RAR$DDB1X                  No, skip type found\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVC   0(23,R15),=C'# Record type detected:'\n         LA    R15,24(R15)\n         MVC   0(4,R15),=C'Data'          Get type\n         TM    RAR_FLAG2,$RARF2_TRAILER   Trailer record?\n         BNO   RAR$DDB1P                  No, continue\n         MVC   5(9,R15),=C'(trailer)'\nRAR$DDB1P EQU  *\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\nRAR$DDB1X EQU  *\n         TM    RAR_FLAG2,$RARF2_TRAILER   Trailer record?\n         BO    RAR$LX                     Yes, skip it\n*\n** Continuation initialization\n*\n         NI    RAR_DPFLAG1,255-$RARDPF1_PCONT Ensure flag is off\n         TM    RAR_DPFLAG1,$RARDPF1_CONT  Previous line continued?\n         BNO   RAR$DCONTS\n         OI    RAR_DPFLAG1,$RARDPF1_PCONT Set flag\nRAR$DCONTS EQU *\n         NI    RAR_DPFLAG1,255-$RARDPF1_CONT Ensure flag is off\n         CLI   AHSD_CONT-AHS(R5),C' '     This line continued?\n         BE    RAR$DCONTX                 No, move on\n         OI    RAR_DPFLAG1,$RARDPF1_CONT  This line is continued\nRAR$DCONTX EQU *\n*\n** Get the current location\n*\n         CLI   AHSD_LOC-AHS(R5),C'0'      Numeric location?\n         BL    RAR$DLOCX                  No, skip it\n         LA    R15,RAR_DPLOCCP            Locate input hex char string\n         MVC   0(2,R15),=C'00'            Ensure leading zeros\n         MVC   RAR_DPLOCC(6),AHSD_LOC-AHS(R5)\n         LA    R0,4                       Input length / 2\n         LA    R1,RAR_DPLOCX              Locate output hex value str\n         BAS   R8,HEXTRAN                 Make right\nRAR$DLOCX EQU *\n*\n** Get address 2\n*\n         XC    RAR_DPADDR2X(4),RAR_DPADDR2X  Zero field\n         CLI   AHSD_ADDR2-AHS(R5),C'0'    Numeric Address 2?\n         BL    RAR$DADDR2X                No, skip it\n         LA    R15,RAR_DPADDR2CP          Locate input hex char string\n         MVC   0(3,R15),=C'000'           Insert leading zeros\n         MVC   RAR_DPADDR2C(5),AHSD_ADDR2-AHS(R5)\n         LA    R0,4                       Input length / 2\n         LA    R1,RAR_DPADDR2X            Locate output hex value str\n         BAS   R8,HEXTRAN                 Make right\nRAR$DADDR2X EQU *\n*\n** Set up for parse\n*\n         LA    R2,AHSD_SOURCE-AHS(R5)     Locate assembler source\n         LA    R3,L'AHSD_SOURCE           Get length of source\n         CLC   0(2,R2),=C'.*'             Macro comment?\n         BE    RAR$DCOMX                  Yes, go straight to inc\n         CLI   0(R2),C'*'                 Comment record?\n         BE    RAR$DCOM                   Yes, process it for dir.\n*\n** Trap the NAME field (if any)\n*\n         TM    RAR_DPFLAG1,$RARDPF1_PCONT Previous line continued?\n         BNO   RAR$DC1X                   No, move on\n         LA    R2,15(R2)                  Bump to Operand field\n         SH    R3,=H'15'                  Decrement counter\n         B     RAR$DPOPR                  Bump to operand\nRAR$DC1X EQU   *\n         CLI   0(R2),C' '                 Got a \"NAME\"\n         BE    RAR$DPNX                   No, continue\n         L     R4,RAR_DPNAMEA             Locate output field\n         MVI   0(R4),C' '\n         MVC   1(L'RAR_DPNAME-1,R4),0(R4)\n         LA    R0,63                      Maximum length\n         BAS   R14,RAR$DENDF              Locate end of field\nRAR$DPNLX EQU  *\n         LA    R14,RAR_DPNAME             Locate start\n         SR    R4,R14                     Length = End - Beginning\n         BCTR  R4,0                       Decrement by 1\n         STH   R4,RAR_DPNAMEL             Save length\nRAR$DPNX EQU   *\n*\n** Locate the OPERATION field\n**\n** Note: We will *assume* that the operation field is not continued...\n*\n         BAS   R14,RAR$DNEXTF             Locate next field\n         LTR   R3,R3                      At wits end?\n         BZ    RAR$DPX                    Yes, leave\n*\n         L     R4,RAR_DPOPTA              Locate current location\n         LR    R0,R3                      Maximum length\n         BAS   R14,RAR$DENDF              Locate end of field\n         ST    R4,RAR_DPOPTA              Save current location\n         LA    R15,RAR_DPOPT              Locate beginning\n         SR    R4,R15                     Length = End - Beginning\n         BCTR  R4,0                       Decrement by 1\n         STH   R4,RAR_DPOPTL              Save length\nRAR$DPOTX EQU *\n*\n** Trap the OPERAND field\n*\nRAR$DPOPR EQU *\n         TM    RAR_DPFLAG1,$RARDPF1_PCONT Previous line continued?\n         BNO   RAR$DPOPRCX                No, move on\n         TM    RAR_DPFLAG1,$RARDPF1_OPERAND In operand mode?\n         BNO   RAR$DPOPRX                 No, remaining must be rem.\n         B     RAR$DPOPRS                 Don't remove blanks...\nRAR$DPOPRCX EQU *\n         BAS   R14,RAR$DNEXTF             Locate next field\n         LTR   R3,R3                      At wits end?\n         BZ    RAR$DPX                    Yes, leave\nRAR$DPOPRS EQU *\n         L     R4,RAR_DPOPRA              Locate current location\n         LR    R0,R3                      Maximum length\n         OI    RAR_DPFLAG1,$RARDPF1_OPERAND Turn on operand flag\n         BAS   R14,RAR$DENDF              Locate end of field\n         ST    R4,RAR_DPOPRA              Save current location\n         LA    R15,RAR_DPOPR              Locate beginning\n         SR    R4,R15                     Length = End - Beginning\n         BCTR  R4,0                       Decrement by 1\n         STH   R4,RAR_DPOPRL              Save length\n         LTR   R3,R3                      Check length\n         BZ    RAR$DPX                    Zero, field is continued\n         BM    RAR$DPX                    Minus: field is continued\nRAR$DPOPRX EQU *\n         NI    RAR_DPFLAG1,255-$RARDPF1_OPERAND\n*\n** Trap the REMARKS field\n*\n         BAS   R14,RAR$DNEXTF             Locate next field\n         LTR   R3,R3                      At wits end?\n         BZ    RAR$DPX                    Yes, leave\n*\n         TM    PPC_FLAG1,$PPC_F1NOCDASH   Eliminate leading dash?\n         BNO   RAR$DRCDX                  No, continue\n         CLC   0(2,R2),=C'- '             Leading dash?\n         BNE   RAR$DRCDX                  No, continue\n         LA    R2,1(R2)                   Bump past it\n         BCTR  R3,0                       Decrement length\n         LTR   R3,R3                      Anything left?\n         BZ    RAR$DPX                    No, continue\n         BAS   R14,RAR$DNEXTF             Locate next field\n         LTR   R3,R3                      At wits end?\n         BZ    RAR$DPX                    Yes, leave\nRAR$DRCDX EQU  *\n*\n         L     R1,RAR_CNTREMARK           Get current count\n         LA    R1,1(R1)                   Increment it\n         ST    R1,RAR_CNTREMARK           Save count\n*\n         LA    R15,AHSD_CONT-1-AHS(R5)    Locate last possible\n         LR    R0,R3                      Maximum length\n         BAS   R14,LOCATE_LAST_NSPACE     Locate end of field\n         SR    R15,R2                     Length = End - Beginning\n         L     R4,RAR_DPREMARKA           Get current locaiton\n         TM    PPC_FLAG1,$PPC_F1STRIPC    Strip IBM change status?\n         BO    RAR$DPRC                   Yes, continue\n*\n         EX    R15,RAR$DPRM               Append remark\n         LA    R4,1(R15,R4)               Bump past it\n         B     RAR$DPRX\nRAR$DPRM MVC   0(0,R4),0(R2)              ** Executed **\nRAR$DPRC EQU   *\n         LA    R14,1(R15)                 Get length + 1\nRAR$DPRCL EQU  *\n* - - - - - - - - - - - - - - - - - - - - Strip Change ID - - - - - *\n         CLI   0(R2),C'#'                 Pound sign?\n         BE    RAR$DPRCL$AL               No, continue\n         CLI   0(R2),C'@'                 At sign?\n         BNE   RAR$DPRCLB                 No, continue\nRAR$DPRCL$AL EQU *\n         CLI   0(R2),C' '                 End yet?\n         BE    RAR$DPRCLB                 Yes, continue\n         LA    R2,1(R2)                   No, bump past byte\n         BCTR  R15,0                      Decrement Length count\n         BCT   R14,RAR$DPRCL$AL           Decrement loop count\n         B     RAR$DPRX                   Found end of the line\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\nRAR$DPRCLB EQU *\n         MVC   0(1,R4),0(R2)              Move current byte\n         LA    R2,1(R2)                   Bump to next input byte\n         LA    R4,1(R4)                   Decrement length\n         BCT   R14,RAR$DPRCL              Process next byte\nRAR$DPRX EQU   *\n         LH    R1,RAR_DPREMARKL           Get Previous length\n         AR    R15,R1                     Add to current\n         LA    R15,1(R15)                 Append space (length)\n         MVI   0(R4),C' '                 Append space (value)\n         LA    R4,1(R4)                   Append space for multi-lines\n         STH   R15,RAR_DPREMARKL          Save total length\n         ST    R4,RAR_DPREMARKA           Save it\nRAR$DPX  EQU   *                          Parsing complete!!!!!!!\n*\n** Check for unbalanced quotes\n*\n         TM    RAR_DPFLAG1,$RARDPF1_CONT  This line continued?\n         BO    RAR$DCCX                   No, continue on\n         TM    RAR_DPFLAG1,$RARDPF1_QUOTE Trailing quote?\n         BNO   RAR$DCCX                   No, its cool\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG10L,R15),MSG10-RAA$DATA(R1)\n         LA    R15,MSG10L+1(R15)          Bump past it\n         L     R1,RAR_CNTIREC             Get rel. record number\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(9,R15),=C', at STMT'\n         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print record\n         NI    RAR_DPFLAG1,255-$RARDPF1_QUOTE\nRAR$DCCX EQU   *\n*\n** Debugging: Show what we got\n*\nRAR$DDB2 EQU   *\n         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?\n         BNO   RAR$DDB2X                  No, continue\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVI   0(R15),C'+'\n         LA    R15,2(R15)\n*\n         CLI   RAR_DPNAME,0\n         BE    RAR$DDB2NX\n         MVC   0(5,R15),=C'Name('\n         LA    R15,5(R15)\n         LH    R14,RAR_DPNAMEL\nRAR$DDB2M MVC  0(0,R15),RAR_DPNAME\n         EX    R14,RAR$DDB2M\n         LA    R15,1(R14,R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\nRAR$DDB2NX EQU *\n*\n         CLI   RAR_DPOPT,0\n         BE    RAR$DDB2OTX\n         MVC   0(10,R15),=C'Operation('\n         LA    R15,10(R15)\n         LH    R14,RAR_DPOPTL\n         MVC   0(0,R15),RAR_DPOPT\n         EX    R14,*-6\n         LA    R15,1(R14,R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\nRAR$DDB2OTX EQU *\n*\n         CLI   RAR_DPOPR,0\n         BE    RAR$DDB2ORX\n         MVC   0(8,R15),=C'Operand('\n         LA    R15,8(R15)\n         LH    R14,RAR_DPOPRL\n         CH    R14,=H'60'\n         BNH   RAR$DDB2OR\n         LA    R14,60\nRAR$DDB2OR EQU *\n         MVC   0(0,R15),RAR_DPOPR\n         EX    R14,*-6\n         LA    R15,1(R14,R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\nRAR$DDB2ORX EQU *\n*\n         CLI   RAR_DPREMARK,C' '\n         BE    RAR$DDB2RX\n         MVC   0(8,R15),=C'Remarks('\n         LA    R15,8(R15)\n         LH    R14,RAR_DPREMARKL\n         CH    R14,=H'60'\n         BNH   RAR$DDB2R\n         LA    R14,60\nRAR$DDB2R EQU *\n         MVC   0(0,R15),RAR_DPREMARK\n         EX    R14,*-6\n         LA    R15,1(R14,R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\nRAR$DDB2RX EQU *\n*\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\nRAR$DDB2X EQU  *\n*\n** Full Debugging stuff\n*\n         TM    PPC_FLAG1,$PPC_F1DEBUGF    Debugging Full?\n         BNO   RAR$DDB3X                  No, continue\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVI   0(R15),C'+'\n         LA    R15,2(R15)\n*\n         MVC   0(4,R15),=C'LOC('\n         LA    R15,4(R15)\n         MVC   0(L'AHSD_LOC,R15),AHSD_LOC-AHS(R5)\n         LA    R15,L'AHSD_LOC(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         MVC   0(5,R15),=C'OBJ1('\n         LA    R15,5(R15)\n         MVC   0(L'AHSD_OBJ1,R15),AHSD_OBJ1-AHS(R5)\n         LA    R15,L'AHSD_OBJ1(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         MVC   0(5,R15),=C'OBJ2('\n         LA    R15,5(R15)\n         MVC   0(L'AHSD_OBJ2,R15),AHSD_OBJ2-AHS(R5)\n         LA    R15,L'AHSD_OBJ2(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         MVC   0(5,R15),=C'OBJ3('\n         LA    R15,5(R15)\n         MVC   0(L'AHSD_OBJ3,R15),AHSD_OBJ3-AHS(R5)\n         LA    R15,L'AHSD_OBJ3(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         MVC   0(6,R15),=C'ADDR1('\n         LA    R15,6(R15)\n         MVC   0(L'AHSD_ADDR1,R15),AHSD_ADDR1-AHS(R5)\n         LA    R15,L'AHSD_ADDR1(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         MVC   0(6,R15),=C'ADDR2('\n         LA    R15,6(R15)\n         MVC   0(L'AHSD_ADDR2,R15),AHSD_ADDR2-AHS(R5)\n         LA    R15,L'AHSD_ADDR2(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         MVC   0(5,R15),=C'CONT('\n         LA    R15,5(R15)\n         MVC   0(L'AHSD_CONT,R15),AHSD_CONT-AHS(R5)\n         LA    R15,L'AHSD_CONT(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         MVC   0(7,R15),=C'SEQNUM('\n         LA    R15,7(R15)\n         MVC   0(L'AHSD_SEQNUM,R15),AHSD_SEQNUM-AHS(R5)\n         LA    R15,L'AHSD_SEQNUM(R15)\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n*\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\nRAR$DDB3X EQU  *\n*\n** Starting and ending label processing\n*\n         CLI   RAR_DPNAME,0               Name/Label present?\n         BE    RAR$D_CCNX                 No, skip checking\n         LH    R1,RAR_DPNAMEL             Get length of name/label\n         LA    R1,1(R1)                   Increment to add space at end\n         CLI   RAR_SNAME,0                Start label present?\n         BE    RAR$D_CCN_SLX              No, continue\n         TM    RAR_FLAG1,$RARF1_NPROC     Processing now?\n         BNO   RAR$D_CCN_SLX              No, forget 'bout it\n         EX    R1,RAR$D_CCN_SLC           Name/Label match?\n         BNE   RAR$D_CCN_SLX              No, continue\n         NI    RAR_FLAG1,255-$RARF1_NPROC Turn off \"No Processing\" flag\n         OI    RAR_FLAG1,$RARF1_SNAME     Indicate we just saw it\n         B     RAR$D_CCNX                 If a Start, can't be 'else\nRAR$D_CCN_SLC CLC RAR_DPNAME(0),RAR_SNAME\nRAR$D_CCN_ELC CLC RAR_DPNAME(0),RAR_ENAME\n*\nRAR$D_CCN_SLX EQU *\n         CLI   RAR_ENAME,0                Start label present?\n         BE    RAR$D_CCN_ELX              No, continue\n         EX    R1,RAR$D_CCN_ELC           Name/Label match?\n         BNE   RAR$D_CCN_ELX              No, continue\n         OI    RAR_FLAG1,$RARF1_NPROC     Turn on \"No Processing\" flag\n         OI    RAR_FLAG1,$RARF1_ENAME     Indicate we just saw it\nRAR$D_CCN_ELX EQU *\nRAR$D_CCNX EQU *\n*\n** DSECT processing\n*\n         CLC   RAR_DPOPT(C_DSECTL),C_DSECT\n         BNE   RAR$DDX\n*        TM    X_FLAG1,$XF1_SRC\n*        BNO   RAR$DDSX\n*        ICM   R0,B'1111',RAR_DPLOCX      Same DSECT\n*        BNZ   RAR$DDX                    Yes, they're playing games\nRAR$DDSX EQU   *\n         BAS   R14,RAR$PM17               Print Message 17 if needed\n         OI    RAR_FLAG1,$RARF1_DSECT     Set in DSECT mode\n         NI    RAR_FLAG1,255-$RARF1_CSECT Can't be in CSECT mode...\n*\n         LA    R8,C_DSECT\n         B     RAR$DMSG7\nRAR$DDX  EQU   *\n*\n** CSECT processing\n*\n         CLC   RAR_DPOPT(C_CSECTL),C_CSECT\n         BNE   RAR$DCX\n         BAS   R14,RAR$PM17               Print Message 17 if needed\n         OI    RAR_FLAG1,$RARF1_CSECT     Set in CSECT mode\n         NI    RAR_FLAG1,255-$RARF1_DSECT Can't be in DSECT mode...\n         MVC   RAR_CSECT(8),=8C' '        Ensure trailing blanks\n         CLI   RAR_DPNAME,0               Got a label/name?\n         BE    RAR$DCX                    No, skip it\n         LH    R14,RAR_DPNAMEL            Get length of field\n         LA    R1,8                       Get max length\n         CR    R14,R1                     Okay?\n         BNH   RAR$DCN                    Yes, continue\n         LR    R14,R1                     No, set truncated\nRAR$DCN  EQU   *\n         EX    R14,RAR$DCM                Move in CSECT Name\n         ST    R14,DOUBLE\n         LA    R8,C_CSECT\nRAR$DMSG7 EQU  *\n         BAS   R14,RAR$PM17               Print Message 17 if needed\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG7L,R15),MSG7-RAA$DATA(R1)\n         LA    R15,MSG7L(R15)             Bump past it\n         MVC   0(5,R15),0(R8)             Get type: DSECT or CSECT\n         MVI   5(R15),C':'                Insert delimiter\n         LH    R14,RAR_DPNAMEL            Obtain length\n         EX    R14,RAR$DM7M               Move in CSECT/DSECT name\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print record\nRAR$DCX  EQU   *\n*\n** End card\n*\n         CLC   RAR_DPOPT(C_ENDL),C_END    End card?\n         BNE   RAR$DENDX\n         NI    RAR_FLAG1,255-$RARF1_DSECT\n         NI    RAR_FLAG1,255-$RARF1_CSECT\nRAR$DENDX EQU  *\n*\n** End of RAR$DATA processing\n*\nRAR$DATAX EQU  *\n         B     RAR$LX\nRAR$DCM  MVC   RAR_CSECT(0),RAR_DPNAME    ** Executed **\nRAR$DM7M MVC   7(0,R15),RAR_DPNAME        ** Executed **\n*\n** Print message 17 if needed\n*\nRAR$PM17 DS    0H\n         ICM   R0,B'1111',RAR_LOVER       Any overflows?\n         BZ    RAR$PM17X                  No, continue\n         ST    R14,RAR_LOVERR             Save return address\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG17L,R15),MSG17-RAA$DATA(R1)\n         LA    R15,MSG17L+1(R15)          Bump past message\n         ICM   R1,B'1111',RAR_LOVER       Get count\n         BAS   R9,EDITFWF                 Edit the count\n         MVC   1(18,R15),=C'times, max length:' Get trailing text\n         LA    R15,1+18+1(R15)            Bump past text\n         LH    R1,RAR_LOVERLC             Get count\n         BAS   R9,EDITFWF                 Edit the count\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print record\n         XC    RAR_LOVER(4),RAR_LOVER     Reset Line Overflow\n         XC    RAR_LOVERLC(2),RAR_LOVERLC Reset length\n         L     R14,RAR_LOVERR             Get return address\nRAR$PM17X DS  0H\n         BSM   0,R14\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Data: Comment                                                     **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$DCOM EQU   *\n         CLC   1(1,R2),PPC_CCC            Our special symbol?\n         BNE   RAR$DCOMX                  No, continue\n         CLI   2(R2),C' '                 Space after cntl char?\n         BNE   RAR$DCOMX                  No, must not be ours...\n*\n         LA    R2,3(R2)                   Bump past \"*! \"\n         SH    R3,=H'3'                   Decrement count\n         BAS   R14,RAR$DNEXTF             Locate first field\n         LTR   R3,R3                      Found it\n         BNZ   RAR$DC_FNZ                 Yes, continue\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG6L,R15),MSG6-RAA$DATA(R1) Get message\n         LA    R15,MSG6L+1(R15)           Bump past it\n         L     R1,RAR_CNTIREC             Get rel. record number\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(9,R15),=C', at STMT'\n         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     RAR$DCOMX                  Continue\nRAR$DC_FNZ EQU  *\n         STM   R2,R3,RAR_DCREGS           Save registers\n         LA    R0,L'TDC_VERB              Get max length of verb\n         LA    R4,RAR_DCVERB              Locate output area\n         MVI   0(R4),C' '                 Clear to blank\n         MVC   1(L'RAR_DCVERB,R4),0(R4)    ..Propagate 'em\n         BAS   R14,RAR$DENDF              Trap verb\n         LA    R15,RAR_DCVERB+1           Locate start (+1 for EX)\n         SR    R4,R15                     Length = end - start\n*\n** Search thru \"Comment Directive\" verb table for match\n*\n         L     R1,=V(RAA$DATA)            -> Data CSECT\n         LA    R1,T_COMDIR-RAA$DATA(R1)   Locate table\n         LA    R0,T_COMDIRN               Get number in table\nRAR$DC_TCDL EQU *\n         CLM   R4,B'0001',TDC_VERBL-TDC(R1) Verb length match?\n         BNE   RAR$DC_TCDLB               No, continue\n         EX    R4,RAR$DC_TCDC             Verb value match?\n         BE    RAR$DC_TCDLX               Yes, continue\nRAR$DC_TCDLB EQU *\n         LA    R1,TDCL(R1)                Bump past entry\n         BCT   R0,RAR$DC_TCDL             Process it\n*\n** Verb not found, gripe about it\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG13L,R15),MSG13-RAA$DATA(R1) Get message\n         LA    R15,MSG13L+1(R15)          Bump past it\n         L     R1,RAR_CNTIREC             Get rel. record number\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(9,R15),=C', at STMT'\n         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     RAR$DCOMX\nRAR$DC_TCDC    CLC TDC_VERB-TDC(0,R1),RAR_DCVERB\nRAR$DC_TCDLM   MVC 0(0,R15),0(R1)\n*\n** Invalid or missing operand\n*\nRAR$DC_IOPER EQU *\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG14L,R15),MSG14-RAA$DATA(R1) Get message\n         LA    R15,MSG14L+1(R15)          Bump past it\n         MVC   0(L'TDC_VERB,R15),RAR_DCVERB Move in verb\n         LA    R0,L'TDC_VERB              Get length of verb\n         BAS   R14,LOCATE_FIRST_SPACE     Locate first space\n         MVC   1(9,R15),=C'on record'     Get text\n         LA    R15,1+9+1(R15)             Bump past it\n         L     R1,RAR_CNTIREC             Get rel. record number\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(9,R15),=C', at STMT'\n         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     RAR$DCOMX\n*\n** Found entry: Get routine address, find operand (if any), print\n** message, and branch to the routine\n*\nRAR$DC_TCDLX EQU *\n         SLR   R8,R8                      Clear register\n         ICM   R8,B'0011',TDC_ROUTINE-TDC(R1) Get routine offset\n         AR    R8,R12                     Calc routine address\n         BAS   R14,RAR$DNEXTF             Locate next field\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG9L,R15),MSG9-RAA$DATA(R1)\n         LA    R15,MSG9L+1(R15)           Bump past it\n         L     R1,RAR_DCREGS              Get address\n         L     R14,RAR_DCREGS+4           Get length\n         BCTR  R14,0                      Decrement\n         EX    R14,RAR$DC_TCDLM           Move line to message\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BR    R8\n*\n** DSECT header\n*\nRAR$DC_DSECTH EQU *\n         TM    X_FLAG1,$XF1_DSECTHO       Overflow?\n         BO    RAR$DC_DHOF                Yes, we can't take a joke\n         LTR   R3,R3                      Check out length\n         BZ    RAR$DC_IOPER               Zero: end of record\n         ICM   R8,B'1111',RAR_DCDSECTHC   -> Data area\n         BNZ   RAR$DC_DHS                 We got it, continue\n         L     R0,=F'32760'               Get some memory\n         GETMAIN R,LV=(0)                 Obtain storage\n         STM   R0,R1,RAR_DCDSECTH         Save length and address\n         LR    R8,R1\nRAR$DC_DHS EQU *\n         LR    R4,R8                      Locate output area\n         MVI   0(R4),C' '                 Get blank\n         MVC   1(DSHL-1,R4),0(R4)         ..Propagate it\n         LA    R0,L'DSH_NAME              Get length to trap\n         BAS   R14,RAR$DENDF              Trap label\n         BAS   R14,RAR$DNEXTF             Locate next field\n         LTR   R3,R3                      Any thing left?\n         BZ    RAR$DC_DHOX                No, blanks is all...\n         LR    R15,R2                     Get current location\n         AR    R15,R3                     Locate the end\n         LR    R0,R3                      Get length left\n         BAS   R14,LOCATE_LAST_NSPACE     Backup to last space\n         SR    R15,R2                     Length = End - Start\n         LA    R0,L'DSH_DCFCODE-1         Get length to trap\n         CR    R15,R0                     Too much?\n         BNH   RAR$DC_DHOS                No, continue\n         LA   R15,L'DSH_DCFCODE-1         Get length to trap\nRAR$DC_DHOS EQU *\nRAR$DC_DHOM MVC DSH_DCFCODE-DSH(0,R8),0(R2)\n         EX     R15,RAR$DC_DHOM           Move operand to area\nRAR$DC_DHOX EQU *\n         LA    R8,DSHL(R8)                Bump to next entry\n         L     R1,RAR_DCDSECTH+4          Get start of area\n         A     R1,RAR_DCDSECTH            Get length of area\n         BCTR  R1,0                       Locate last byte of area\n         CR    R8,R1                      Are we about to run out?\n         BH    RAR$DC_DHOE                Yes, gripe about it\n         ST    R8,RAR_DCDSECTHC           Save current\n         B     RAR$DCOMX                  Continue\nRAR$DC_DHOE EQU *\n         OI    X_FLAG1,$XF1_DSECTHO       Turn on overflow flag\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG15L,R15),MSG15-RAA$DATA(R1)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\nRAR$DC_DHOF EQU *\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG16L,R15),MSG16-RAA$DATA(R1) Get message\n         LA    R15,MSG16L+1(R15)          Bump past it\n         L     R1,RAR_CNTIREC             Get rel. record number\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(9,R15),=C', at STMT'\n         MVC   9(L'AHSD_STMT,R15),AHSD_STMT-AHS(R5)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     RAR$DCOMX\n*\n** Start name (label)\n*\nRAR$DC_SNAME EQU *\n         LTR   R3,R3                      Check out length\n         BZ    RAR$DC_IOPER               Zero: end of record\n         LA    R0,L'RAR_SNAME             Get max length of area\n         LA    R4,RAR_SNAME               Locate it\n         MVI   0(R4),C' '                 Get blank\n         MVC   1(L'RAR_SNAME-1,R4),0(R4)   ..Propagate it\n         BAS   R14,RAR$DENDF              Trap label\n         OI    RAR_FLAG1,$RARF1_NPROC     Turn on no-processing flag\n         B     RAR$DCOMX\n*\n** End name (label)\n*\nRAR$DC_ENAME EQU *\n         LTR   R3,R3                      Check out length\n         BZ    RAR$DC_IOPER               Zero: end of record\n         LA    R0,L'RAR_ENAME             Get max length of area\n         LA    R4,RAR_ENAME               Locate it\n         MVI   0(R4),C' '                 Get blank\n         MVC   1(L'RAR_ENAME-1,R4),0(R4)   ..Propagate it\n         BAS   R14,RAR$DENDF              Trap label\n*\n** Common exit from RAR$DCOM processing\n*\nRAR$DCOMX EQU *\n         MVI   RAR_TYPE,$RART_DATAC       Change our mind: comment\n         L     R1,RAR_CNTCOMMENT\n         LA    R1,1(R1)\n         ST    R1,RAR_CNTCOMMENT\n         B     RAR$DPX\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Data Handbook                                               **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$DHB   EQU  *\n         ST    R14,RAR_DHB_RA             Save return address\n*\n         TM    RAR_DPFLAG1,$RARDPF1_CONT  Current line continued?\n         BO    RAR$DHBX                   Yes, don't have all info...\n         CLI   RAR_TYPE,$RART_DATA        Data line?\n         BNE   RAR$DHBX                   No, leave\n*\n         CLC   RAR_DPOPT(C_ENDL),C_END    End card?\n         BE    RAR$DHBX                   Yes, skip it\n         CLC   RAR_DPOPT(C_EJECTL),C_EJECT\n         BE    RAR$DHBX                   Yes, skip it\n         CLC   RAR_DPOPT(C_SPACEL),C_SPACE\n         BE    RAR$DHBX                   Yes, skip it\n         CLC   RAR_DPOPT(C_ORGL),C_ORG    ORG card?\n         BE    RAR$DHBX                   Yes, skip it\n         TM    RAR_FLAG1,$RARF1_DSECT     In DSECT mode?\n         BNO   RAR$DHBX                   No, skip data handbook...\n*\n** Format the field with common fields\n*\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n*\n         CLI   RAR_DPNAME,0               Have a value?\n         BE    RAR$DHB$NX                 No, skip it\n         LH    R14,RAR_DPNAMEL            Get length of field\n         L     R1,PPC_NAMEL               Get max length\n*        AH    R1,=H'1'                   It's one less...\n         CR    R14,R1                     Okay?\n         BNH   RAR$DHB$N                  Yes, continue\n         CH    R14,RAR_LOVERLC            No, check out max length\n         BL    RAR$DHB$LOC                It's within the highest known\n         STH   R14,RAR_LOVERLC            Save new higher\nRAR$DHB$LOC DS 0H\n         CH    R14,RAR_LOVERLT            No, check out max length\n         BL    RAR$DHB$LOT                It's within the highest known\n         STH   R14,RAR_LOVERLT            Save new higher\nRAR$DHB$LOT DS 0H\n         LR    R14,R1                     No, set truncated\n         LA    R1,DHBR_NAME-DHBR(R15)     Locate to start of name\n         A     R1,PPC_NAMEL               Bump to end\n         MVI   1(R1),C'*'                 Indicate truncated...\n         L     R0,RAR_LOVER               Get current count\n         AH    R0,=H'1'                   Increment by one\n         ST    R0,RAR_LOVER               Save new count\nRAR$DHB$N EQU  *\n         EX    R14,RAR$DHB$NM\nRAR$DHB$NX EQU *\n*\n         CLI   RAR_DPREMARK,C' '          Have a value?\n         BE    RAR$DHB$DX                 No, skip it\n         LH    R14,RAR_DPREMARKL          Get length of field\n         LA    R1,RAR_DHB_DESCL           Get max length\n         CR    R14,R1                     Okay?\n         BNH   RAR$DHB$D                  Yes, continue\n         LR    R14,R1                     No, set truncated\nRAR$DHB$D EQU  *\n         LA    R1,DHBR_NAME-DHBR(R15)     Locate start of name\n         A     R1,PPC_NAMEL               Add length of name\n         EX    R14,RAR$DHB$DM             Move remark to area\nRAR$DHB$DX EQU *\n*\n** Offset/Location\n*\n         CLC   RAR_DPOPT(C_EQUL),C_EQU    Equate?\n         BE    RAR$DHBLNX                 Yes, skip it\n*\n         L     R1,RAR_DPLOCX\n         CVD   R1,DOUBLE\n         MVC   DHBR_OFFD-DHBR(8,R15),EDITP15F\n         ED    DHBR_OFFD-DHBR(8,R15),DOUBLE+4\n         OI    DHBR_OFFD+7-DHBR(R15),C'0' Ensure numeric if zero\n*\n         LA    R14,DHBR_OFFX-DHBR(R15)    Locate output for hex offset\n         MVI   0(R14),C'('                Hex prefix\n         LA    R14,1(R14)                 Bump past it\n         LA    R1,RAR_DPLOCC              Locate hex character string\n         LA    R0,L'RAR_DPLOCC-1          Get length\nRAR$DHB$O1L EQU *\n         CLI   0(R1),C'0'                 Leading zero?\n         BNE   RAR$DHB$O2L                Yes,ignore it\n         LA    R1,1(R1)\n         BCT   R0,RAR$DHB$O1L\n         B     RAR$DHB$O2LX\nRAR$DHB$O2L EQU *\n         MVC   0(1,R14),0(R1)             No, we need the puppy\n         LA    R14,1(R14)                 Bump to next output byte\n         LA    R1,1(R1)                   Bump to next input byte\n         BCT   R0,RAR$DHB$O2L             ..Process next byte\nRAR$DHB$O2LX  EQU *\n         MVC   0(1,R14),0(R1)             No, we need the puppy\n         MVI   1(R14),C')'                Attach hex suffix\nRAR$DHBLNX EQU *\n*\n** Data type checking\n*\n         CLC   RAR_DPOPT(C_DSECTL),C_DSECT\n         BE    RAR$DHB$DSE\n         CLC   RAR_DPOPT(C_EQUL),C_EQU\n         BE    RAR$DHB$EQU\n         CLC   RAR_DPOPT(C_DCL),C_DC\n         BE    RAR$DHBT\n         CLC   RAR_DPOPT(C_DSL),C_DS\n         BE    RAR$DHBT\n*\n** Isn't something we know about...\n*\n         L     R1,=V(RAA$DATA)\n         LA    R1,T_BALSTMT-RAA$DATA(R1)  Locate ignore table\n         LA    R0,T_BALSTMTN              Get length\nRAR$DHB$BSXL EQU *\n         CLC   0(8,R1),RAR_DPOPT          Match?\n         BE    RAR$DHBX  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n         LA    R1,8(R1)                   Bump to next entry\n         BCT   R0,RAR$DHB$BSXL            Try it\n*\n         MVC   DHBR_TYPE-DHBR(8,R15),=C'BAL STMT'\n         MVI   DHBR_OFFD-DHBR(R15),C' '\n         MVC   DHBR_OFFD+1-DHBR(L'DHBR_OFFD-1,R15),DHBR_OFFD-DHBR(R15)\n         MVI   DHBR_OFFX-DHBR(R15),C' '\n         MVC   DHBR_OFFX+1-DHBR(L'DHBR_OFFX+1,R15),DHBR_OFFX-DHBR(R15)\n* Note: Put Operation on DHBR_LEN which is not used for \"BAL STMT\"\n         LH    R14,RAR_DPOPTL             Get length of field\n         LA    R1,L'DHBR_LEN              Get max length\n         CR    R14,R1                     Okay?\n         BNH   RAR$DHB$BSL                Yes, continue\n         LR    R14,R1                     No, set truncated\n         MVI   DHBR_LEN+L'DHBR_LEN-DHBR(R15),C'<'\nRAR$DHB$BSL    EQU *\n         EX    R14,RAR$DHB$BSM            Move out operand field\n         B     RAR$DHBTX\nRAR$DHB$NM  MVC   DHBR_NAME-DHBR(0,R15),RAR_DPNAME\nRAR$DHB$DM  MVC   3(0,R1),RAR_DPREMARK\nRAR$DHB$BSM MVC   DHBR_LEN-DHBR(0,R15),RAR_DPOPT   ** Executed **\n*\n** DSECT\n*\nRAR$DHB$DSE EQU *\n         MVC   DHBR_TYPE-DHBR(10,R15),T_OPRTST+(TOPRT_NAME-TOPRT)\n         MVI   RAR_DHB_DESCC,C' '\n         MVC   RAR_DHB_DESCC+1(L'RAR_DHB_DESCC-1),RAR_DHB_DESCC\n         SLR   R1,R1                      Clear register\n         IC    R1,C_DAHANDBKD             Get length of prefix\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',RAR_DPNAMEL    Get length of DSECT name\n         BNZ   RAR$DHB$DSED               Go with it bozo\n         MVC   RAR_DHB_DESCC(7),=C'Unknown'\n         LA    R1,7(R1)                   Bump past it\n         B     RAR$DHB$DSEDX\nRAR$DHB$DSED EQU *\n         L     R15,RAR_DPNAMEA            Get address of DSECT name\n         EX    R14,RAR$DHB$DSEDM          Move DSECT name out\n         LA    R14,1(R14)\nRAR$DHB$DSEDX EQU *\n         AR    R1,R14                     Increment length\n         STC   R1,RAR_DHB_DESC            Save length of Desc string\n*\n         TM    RAR_FLAG1,$RARF1_NPROC     Doing any work now?\n         BO    RAR$DHB$DSEDLX             No, continue\n*\n         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?\n         BNO   RAR$DHB$DSE_DCFX\n         BAS   R14,CLEAR_DHB_RECORD\n         ICM   R0,B'1111',RAR_DHB_DSECTC\n         BZ    RAR$DHB$DSE_DCF1X\n         MVC   RAR_DHB_DREC(8),=C':etable.'\n         BAS   R14,PUT_DCF_RECORD\nRAR$DHB$DSE_DCF1X EQU *\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n         LA    R15,RAR_DHB_DREC           Locate start of record\n         MVI   0(R15),C'.'                Get dot\n         MVI   1(R15),C'*'                Get comment ID\n         MVC   2(69,R15),1(R15)           ..Propagate it\n         BAS   R14,PUT_DCF_RECORD         Print delimiter line\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n*\n         MVC   RAR_DHB_DREC(4),=C':h1.'\n         MVC   RAR_DHB_DREC+4(L'RAR_DHB_DESCC-1),RAR_DHB_DESCC\n         BAS   R14,PUT_DCF_RECORD\n*\n         MVC   RAR_DHB_DREC(4),=C':i1.'\n         BAS   R14,PUT_DCF_RECORD\n*\n         ICM   R8,B'1111',RAR_DCDSECTH+4  -> Entries\n         BZ    RAR$DHB$DSE_DHLX           None, leave\nRAR$DHB$DSE_DHL EQU *\n         CLC   DSH_NAME-DSH(63,R8),RAR_DHB_DESCC  Match?\n         BNE   RAR$DHB$DSE_DHLB           No, continue\n*\n         CLC   RAR_DHB_DREC(4),=C':i1.'   First time?\n         BNE   RAR$DHB$DSE_DHLS           No, continue\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n         MVC   RAR_DHB_DREC(15),=C':dl tsize=25mm.'\n         BAS   R14,PUT_DCF_RECORD\nRAR$DHB$DSE_DHLS EQU *\n*\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n         MVC   RAR_DHB_DREC(L'DSH_DCFCODE),DSH_DCFCODE-DSH(R8)\n         BAS   R14,PUT_DCF_RECORD\nRAR$DHB$DSE_DHLB EQU *\n         LA    R8,DSHL(R8)                Bump to next entry\n         C     R8,RAR_DCDSECTHC           At end?\n         BNH   RAR$DHB$DSE_DHL            No, process next one\n*\n         CLC   RAR_DHB_DREC(4),=C':i1.'   First time?\n         BE    RAR$DHB$DSE_DHLX           No, continue\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n         MVC   RAR_DHB_DREC(5),=C':edl.'\n         BAS   R14,PUT_DCF_RECORD\nRAR$DHB$DSE_DHLX EQU *\n*\n         L     R1,=V(RAA$DCF)             -> DCF data CSECT\n         LA    R1,RAA$DCF_NDSECT-RAA$DCF(R1) Locate New DSECT stuff\n         BAS   R14,PRINT_DCF_STRINGS      Print 'em\n         BAS   R14,CLEAR_DHB_RECORD       Leave things blank\nRAR$DHB$DSE_DCFX EQU *\n*\n         L     R14,RAR_DHB_DSECTC         Get current count\n         LA    R14,1(R14)                 Increment by 1\n         ST    R14,RAR_DHB_DSECTC         Save it\n*\n         LA    R0,1                       Generate 1\n         L     R14,RAR_DHB_DSECTC         Get DSECT count\n         CR    R14,R0                     Processing first DSECT?\n         BE    RAR$DHB$DSEDLX             Yes, skip underline\n         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?\n         BO    RAR$DHB$DSE_PRDX\n* Print previous record\n         BAS   R14,RAR$DHB$PPREC          Print previous record\n* Print dash line\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         L     R15,=V(RAA$DATA)           Locate Data CSECT\n         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dash line\n         LR    R0,R15                     Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\n* Mark previous record\nRAR$DHB$DSE_PRDX EQU *\n         MVI   RAR_DHB_PREC,0             Set initialize\nRAR$DHB$DSEDLX EQU *\n*\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         OI    FWA_FLAG1-FWA(R1),$FWA_F1RDESC  Reset description str\n         MVI   FWA_LINECNT-FWA(R1),99     Force heading\n*\n         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?\n         BO    RAR$DHB$DSEDHLX            Yes, leave\n         ICM   R8,B'1111',RAR_DCDSECTH+4  -> DSECT header table\n         BZ    RAR$DHB$DSEDHLX            None, leave\n         NI    X_FLAG1,255-$XF1_RHPROC\n*\nRAR$DHB$DSEDHL EQU *\n         CLC   DSH_NAME-DSH(63,R8),RAR_DHB_DESCC  Match?\n         BNE   RAR$DHB$DSEDHLB            No, continue\n*\n         MVC   DOUBLE(3),DSH_DCFCODE-DSH(R8) Grap control directive\n         OC    DOUBLE+1(2),=C'  '         Ensure uppercase for compare\n         CLC   DOUBLE(3),=C':DT'          Term?\n         BE    RAR$DHB$DSEDHL_DT\n         CLC   DOUBLE(3),=C':DD'          Description?\n         BE    RAR$DHB$DSEDHL_DD\n         CLC   DOUBLE(3),=C'.SP'          Need a space?\n         BE    RAR$DHB$DSEDHL_SP\n*\n         BAS   R14,CLEAR_DHB_RECORD       Clear record to blanks\n         MVC   RAR_DHB_DREC+20(L'DSH_DCFCODE),DSH_DCFCODE-DSH(R8)\n         B     RAR$DHB$DSEDHL_PRT\n*\nRAR$DHB$DSEDHL_SP EQU *\n         BAS   R14,CLEAR_DHB_RECORD       Clear record to blanks\n         B     RAR$DHB$DSEDHL_PRT\n*\nRAR$DHB$DSEDHL_DD EQU *\n         MVC   RAR_DHB_DREC+20(L'DSH_DCFCODE-4),DSH_DCFCODE+4-DSH(R8)\n*\nRAR$DHB$DSEDHL_PRT EQU *\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         LA    R0,RAR_DHB_DREC            Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\n         B     RAR$DHB$DSEDHLB\n*\nRAR$DHB$DSEDHL_DT EQU *\n         TM    X_FLAG1,$XF1_RHPROC        Processed Reports Head yet?\n         BO    RAR$DHB$DSEDHL_DTS         Yes, continue\n         OI    X_FLAG1,$XF1_RHPROC        Turn on flag\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         OI    FWA_FLAG1-FWA(R1),$FWA_F1NORH   No reports heading\n*\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         LA    R0,RAR_DHB_DREC            Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\nRAR$DHB$DSEDHL_DTS EQU *\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n         MVC   RAR_DHB_DREC+1(19),DSH_DCFCODE+4-DSH(R8)\n*\nRAR$DHB$DSEDHLB EQU *\n         LA    R8,DSHL(R8)                Bump to next entry\n         C     R8,RAR_DCDSECTHC           At end?\n         BNH   RAR$DHB$DSEDHL             No, process next one\n*\n         TM    X_FLAG1,$XF1_RHPROC        Processed Reports Headings?\n         BNO   RAR$DHB$DSEDHLX            No, leave\n         BAS   R14,CLEAR_DHB_RECORD       Clear record\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         LA    R0,RAR_DHB_DREC            Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         LA    R0,RAR_DHB_DREC            Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\n*\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         OI    FWA_FLAG1-FWA(R1),$FWA_F1PRTRH  Need Report heading...\n         NI    FWA_FLAG1-FWA(R1),255-$FWA_F1NORH Need report heading...\nRAR$DHB$DSEDHLX EQU *\n*\n         TM    X_FLAG1,$XF1_INDEX         Index file available...\n         BNO   RAR$DHB$DSEIX              No, continue\n         L     R15,INDEX_AREA+4\n         LA    R15,INDEXA_RECOUT-INDEXA(R15) Locate output record\n         BAS   R14,CR$CLEAR               Clear recout to blanks\n*\n         LA    R14,INDEX_NAME-INDEX(R15)  Locate name area\n         MVI   0(R14),C'.'                Get dots\n         MVC   1(L'INDEX_NAME-1,R14),0(R14) ..propagate it\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',RAR_DPNAMEL    Get length of DSECT name\n         BNZ   RAR$DHB$DSEID              Go with it bozo\n         MVC   RAR_DHB_DESCC(7),=C'Unknown'\n         LA    R1,7(R1)                   Bump past it\n         B     RAR$DHB$DSEIDX\nRAR$DHB$DSEID EQU *\n         L     R1,RAR_DPNAMEA             Get address of DSECT name\n         EX    R14,RAR$DHB$DSEIDM         Move DSECT name out\nRAR$DHB$DSEIDX EQU *\n         L     R14,RAR_DHB_DSECTC         Save it\n         CVD   R14,DOUBLE\n         MVC   INDEX_NUM-INDEX(4,R15),EDITP15F\n         ED    INDEX_NUM-INDEX(4,R15),DOUBLE+6\n*\n         LA    R15,INDEX_PAGE-INDEX(R15)  Locate output location\n         LA    R14,WA_FWA_REPORT          -> Data Handbook file area\n         ICM   R1,B'1111',FWA_PAGECNT-FWA(R14) Get page count\n         LA    R1,1(R1)                   Always starts on next page #\n         BAS   R9,EDITFWF                 Edit page count\n         L     R1,INDEX_AREA+4            Locate Index Area\n         LA    R0,INDEXA_RECOUT-INDEXA(R1) Locate output record\n         LA    R1,INDEXA_FWA-INDEXA(R1)   Locate File-Work-Area\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\nRAR$DHB$DSEIX EQU *\n         B     RAR$DHBTX\nRAR$DHB$DSEDM    MVC   RAR_DHB_DESCC(0),0(R15)    ** Executed **\nRAR$DHB$DSEIDM   MVC   INDEX_NAME-INDEX(0,R15),0(R1)\n*\n** Equate\n*\nRAR$DHB$EQU  EQU *\n         CLI   RAR_DPOPR,0                Have a value?\n         BE    RAR$DHBTX                  No, skip it\n*\n         LA    R14,RAR_DHB_PREC+1         Locate previous record\n         CLC   DHBR_TYPE-DHBR(10,R14),T_OPRTX+(TOPRT_NAME-TOPRT)\n         BNE   RAR$DHB$EQUHX              No, continue\n         MVC   DHBR_TYPE-DHBR(10,R14),T_OPRTB+(TOPRT_NAME-TOPRT)\n*\n         MVI   DHBR_LEN+7-DHBR(R14),C'1'  Assume 1!!!!!!\nRAR$DHB$EQUHX EQU *\n*\n         CLC   RAR_DPOPR(2),=X'5C,00'     \"EQU *\"?\n         BE    RAR$DHBTX                  Yes, skip it\n         CLC   RAR_DPOPR(2),=X'5C,60'     \"EQU *-\" ?\n         BE    RAR$DHB$EQUE               Yes, skip Bitstr, get len\n         CLC   AHSD_ADDR2-AHS(3,R5),=C'000' Value is one byte?\n         BNE   RAR$DHB$EQUE               No, continue\n         LA    R15,AHSD_ADDR2+3-AHS(R5)   Locate value\n         LA    R0,1                       Input length / 2\n         LA    R1,DOUBLE                  Locate output hex value str\n         BAS   R8,HEXTRAN                 Make right\n         LA    R15,RECOUT+1               Reset R15\n         LA    R14,DHBR_TYPE-DHBR(R15)    Locate bit string output\n         MVI   0(R14),C'.'                Get unused\n         MVC   1(9-1,R14),0(R14)          ..Propagate it\n         TM    DOUBLE,X'80'\n         BNO   RAR$DHB$E80X\n         MVI   0(R14),C'1'\nRAR$DHB$E80X EQU *\n         TM    DOUBLE,X'40'\n         BNO   RAR$DHB$E40X\n         MVI   1(R14),C'1'\nRAR$DHB$E40X EQU *\n         TM    DOUBLE,X'20'\n         BNO   RAR$DHB$E20X\n         MVI   2(R14),C'1'\nRAR$DHB$E20X EQU *\n         TM    DOUBLE,X'10'\n         BNO   RAR$DHB$E10X\n         MVI   3(R14),C'1'\nRAR$DHB$E10X EQU *\n         LA    R14,4(R14)\n         MVI   0(R14),C' '\n         LA    R14,1(R14)\n         TM    DOUBLE,X'08'\n         BNO   RAR$DHB$E08X\n         MVI   0(R14),C'1'\nRAR$DHB$E08X EQU *\n         TM    DOUBLE,X'04'\n         BNO   RAR$DHB$E04X\n         MVI   1(R14),C'1'\nRAR$DHB$E04X EQU *\n         TM    DOUBLE,X'02'\n         BNO   RAR$DHB$E02X\n         MVI   2(R14),C'1'\nRAR$DHB$E02X EQU *\n         TM    DOUBLE,X'01'\n         BNO   RAR$DHB$E01X\n         MVI   3(R14),C'1'\nRAR$DHB$E01X EQU *\n         CLC   RAR_DPOPR(2),=C'B'''       Bitstrings?\n         BE    RAR$DHBTX                  Yes, already got em\n* Note: Put operand on DHBR_LEN which is not used for equates\n         LH    R14,RAR_DPOPRL             Get length of field\n         LA    R1,L'DHBR_LEN              Get max length\n         CR    R14,R1                     Okay?\n         BNH   RAR$DHB$EQU$EL             Yes, continue\n         LR    R14,R1                     No, set truncated\nRAR$DHB$EQU$EL EQU *\n         EX    R14,RAR$DHB$EQUEM          Move out operand field\n         B     RAR$DHBTX                  Continue\n* Note: Put operand on DHBR_TYPE, it's value is more than 255\nRAR$DHB$EQUE  EQU *\n         LH    R14,RAR_DPOPRL             Get length of field\n         LA    R1,L'DHBR_TYPE+L'DHBR_LEN  Get max length\n         CR    R14,R1                     Okay?\n         BNH   RAR$DHB$EQUEN              Yes, continue\n         LR    R14,R1                     No, set truncated\nRAR$DHB$EQUEN EQU *\n         EX    R14,RAR$DHB$EQUENM         Move out operand field\n*\n         L     R1,RAR_DPADDR2X            Get value\n         CVD   R1,DOUBLE                  Make packed\n         MVC   DHBR_LEN-DHBR(8,R15),EDITP15F\n         ED    DHBR_LEN-DHBR(8,R15),DOUBLE+4\n         B     RAR$DHBTX\nRAR$DHB$EQUEM   MVC   DHBR_LEN-DHBR(0,R15),RAR_DPOPR   ** Executed **\nRAR$DHB$EQUENM  MVC   DHBR_TYPE-DHBR(0,R15),RAR_DPOPR  ** Executed **\nRAR$DHBTDM      MVC   DHBR_LEN-DHBR(0,R15),RAR_DPOPR   ** Executed **\n*\n** Bump past numeric quanity in operand, i e \"DS   5F\" or \"DS 10C'A'\"\n*\nRAR$DHBT EQU   *\n         LA    R14,RAR_DPOPR              Locate start\n         LH    R0,RAR_DPOPRL              Get length of operand\nRAR$DHBNL EQU  *\n         CLI   0(R14),C'0'                Numeric/Quanity?\n         BL    RAR$DHBNLX\n         LA    R14,1(R14)                 Bump past number byte\n         BCT   R0,RAR$DHBNL\nRAR$DHBNLX EQU *\n*\n** Search thru table for \"DC\" and \"DS\" operations\n*\n         LA    R1,T_OPRT                  Locate table\n         LA    R0,T_OPRTE                 Get number of entries\nRAR$DHBTL EQU  *\n         CLC   TOPRT_VAL-TOPRT(1,R1),0(R14)  Match?\n         BE    RAR$DHBTLX                 Yes, continue\n         LA    R1,TOPRTL(R1)              No, Bump to next entry\n         BCT   R0,RAR$DHBTL               ..Continue\nRAR$DHBTLX EQU *\n         CLC   RAR_DPOPT(C_DSL),C_DS      Ensure \"DS 0x\"\n         BNE   RAR$DHBTDX                 No, undefined\n         CLI   RAR_DPOPR,C'0'             Dup?\n         BNE   RAR$DHBTDX\n         CLC   RAR_DPOPR+1(2),=X'C8,00'   \"DS 0H\"\n         BE    RAR$DHBTD\n         CLC   RAR_DPOPR+1(2),=X'C6,00'   \"DS 0F\"\n         BE    RAR$DHBTD\n         CLC   RAR_DPOPR+1(2),=X'C4,00'   \"DS 0D\"\n         BE    RAR$DHBTD\n         CLC   RAR_DPOPR+1(2),=X'E7,00'   \"DS 0X\" Rare...\n         BE    RAR$DHBTD\n         CLC   RAR_DPOPR+1(2),=X'C3,00'   \"DS 0C\" Rare...\n         BNE   RAR$DHBTDX\nRAR$DHBTD EQU *\n         LH    R14,RAR_DPOPRL             Get length\n         EX    R14,RAR$DHBTDM             Move alignment to length\n         LA    R1,T_OPRTA                 Locate our entry\nRAR$DHBTDX EQU *\n         MVC   DHBR_TYPE-DHBR(10,R15),TOPRT_NAME-TOPRT(R1)\n*\nRAR$DHBTPR EQU *\n         CLC   RAR_DHB_POPT(C_EQUL),C_EQU Previous one an Equate?\n         BE    RAR$DHBTX                  Yes, continue\n         LA    R14,RAR_DHB_PREC+1         Locate previous record\n         CLC   DHBR_TYPE-DHBR(8,R14),=C'BAL STMT'  Valid guy?\n         BE    RAR$DHBTX                  No, continue\n         L     R1,RAR_DPLOCX              Get current location\n         S     R1,RAR_DHB_PLOCX           Length = curr - Prev\n         CLI   DHBR_LEN-DHBR(R14),C' '    Check for Alignment\n         BNE   RAR$DHBTX                  Field is in use...\n         CVD   R1,DOUBLE                  Make packed\n         MVC   DHBR_LEN-DHBR(8,R14),EDITP15F\n         ED    DHBR_LEN-DHBR(8,R14),DOUBLE+4\nRAR$DHBTX EQU  *\n*\n** Print previous record and save current record\n*\n         BAS   R14,RAR$DHB$PPREC          Print previous record\n*\n         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?\n         BNO   RAR$DHB$PRX                No, continue\n         LA    R1,WA_FWA_SYSPRINT         Locate File-Work-Area\n         LA    R0,RAR_DHB_PREC            Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\nRAR$DHB$PRX EQU *\n         MVC   RAR_DHB_PREC(133),RECOUT   Save current record\n         MVC   RAR_DHB_PLOCX(4),RAR_DPLOCX Save current location\n         MVC   RAR_DHB_POPT(8),RAR_DPOPT   Save current operation\n*\n** Common exit from Data-Book-Handbook routine\n*\nRAR$DHBX EQU   *\n         L     R14,RAR_DHB_RA             Get return address\n         BSM   0,R14\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Print previous DHB record                                         **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$DHB$PPREC  EQU *\n         ST    R14,RAR_DHB_PPRRA          Save return address\n*\n         CLI   RAR_DHB_PREC,0             Have a previous record?\n         BE    RAR$DHB$PPRECX             No, continue\n*\n         TM    RAR_FLAG1,$RARF1_ENAME     Just got End Name\n         BO    RAR$DHB$PPREC_ENAME        Yes, process previous one\n*\n         TM    RAR_FLAG1,$RARF1_NPROC     Processing just now?\n         BO    RAR$DHB$PPRECX             No, leave\n*\n         TM    RAR_FLAG1,$RARF1_SNAME     Just got Start Name\n         BO    RAR$DHB$PPREC_SNAME        Yes, ignore this one\n*\n** End_Name processing\n*\n         B     RAR$DHB$PPREC_ENAMEX\nRAR$DHB$PPREC_ENAME EQU *\n         NI    RAR_FLAG1,255-$RARF1_ENAME\nRAR$DHB$PPREC_ENAMEX EQU *\n*\n** Document Composition Facility support\n*\n         TM    PPC_FLAG2,$PPC_F2DCF       DCF?\n         BNO   RAR$DHB$PPREC_DCFX         No, continue\n         L     R8,=V(RAA$DCF)\n         LA    R7,RAR_DHB_PREC+1          Locate output record\n*\n         BAS   R14,CLEAR_DHB_RECORD\n         MVC   RAR_DHB_DREC(L'RAA$DCF_ROW),RAA$DCF_ROW-RAA$DCF(R8)\n         BAS   R14,PUT_DCF_RECORD\n*\n         BAS   R14,CLEAR_DHB_RECORD\n         MVC   RAR_DHB_DREC(3),=C':c.'    New row\n         LA    R1,L'DHBR_OFFD-1           Length of offset (Dec)\n         LR    R15,R1                     Get it for loop control\n         LA    R14,DHBR_OFFD-DHBR(R7)     Locate start of value\nRAR$DHB$PPREC_DCFODL EQU *                Remove left justification\n         CLI   0(R14),C' '                Start of string\n         BNE   RAR$DHB$PPREC_DCFODLX      Yes, leave\n         LA    R14,1(R14)                 No, bump to next byte\n         BCTR  R1,0                           Decrement length\n         BCT   R15,RAR$DHB$PPREC_DCFODL       process next byte\nRAR$DHB$PPREC_DCFODLX EQU *\n         EX    R1,RAR$DHB$PPREC_DCFODM\n         BAS   R14,PUT_DCF_RECORD\n*\n         MVI   RAR_DHB_DREC+3,C' '\n         MVC   RAR_DHB_DREC+4(L'DHBR_OFFD-1),RAR_DHB_DREC+3\n         MVC   RAR_DHB_DREC+3(L'DHBR_OFFX),DHBR_OFFX-DHBR(R7)\n         BAS   R14,PUT_DCF_RECORD\n*\n         MVI   RAR_DHB_DREC+3,C' '\n         MVC   RAR_DHB_DREC+4(L'DHBR_OFFX-1),RAR_DHB_DREC+3\n         MVC   RAR_DHB_DREC+3(L'DHBR_TYPE),DHBR_TYPE-DHBR(R7)\n         BAS   R14,PUT_DCF_RECORD\n*\n         MVI   RAR_DHB_DREC+3,C' '\n         MVC   RAR_DHB_DREC+4(L'DHBR_TYPE-1),RAR_DHB_DREC+3\n         LA    R1,L'DHBR_LEN-1            Length of value\n         LR    R15,R1                     Get it for loop control\n         LA    R14,DHBR_LEN-DHBR(R7)      Locate start of value\nRAR$DHB$PPREC_DCFLNL EQU *                Remove left justification\n         CLI   0(R14),C' '                Start of string\n         BNE   RAR$DHB$PPREC_DCFLNLX      Yes, leave\n         LA    R14,1(R14)                 No, bump to next byte\n         BCTR  R1,0                           Decrement length\n         BCT   R15,RAR$DHB$PPREC_DCFLNL       process next byte\nRAR$DHB$PPREC_DCFLNLX EQU *\n         EX    R1,RAR$DHB$PPREC_DCFODM    Move value in\n         BAS   R14,PUT_DCF_RECORD\n*\n         MVI   RAR_DHB_DREC+3,C' '\n         MVC   RAR_DHB_DREC+4(L'DHBR_LEN-1),RAR_DHB_DREC+3\n         L     R8,PPC_NAMEL\n         LA    R1,8(R1)\n         EX    R8,RAR$DHB$PPREC_DCFN1M\n         BAS   R14,PUT_DCF_RECORD\n*\n         CLC   RAR_DPOPT(C_DSECTL),C_DSECT DSECT card?\n         BE    RAR$DHB$PPREC_DCFIX        Yes, already have index...\n         CLI   RAR_DHB_DREC+3,C' '        Have something?\n         BE    RAR$DHB$PPREC_DCFIX        No, continue\n         MVC   RAR_DHB_DREC+1(3),=C'i2.'\n         EX    R8,RAR$DHB$PPREC_DCFN2M\n         BAS   R14,PUT_DCF_RECORD\n         MVC   RAR_DHB_DREC(3),=C':c.'\nRAR$DHB$PPREC_DCFIX EQU *\n*\n         MVI   RAR_DHB_DREC+3,C' '\n         MVC   RAR_DHB_DREC+4(63),RAR_DHB_DREC+3\n         L     R14,RAR_DHB_DESCL          Get max length\n         LA    R1,DHBR_NAME-DHBR(R7)      Locate start of name\n         A     R1,PPC_NAMEL               Add length of name\n         EX    R14,RAR$DHB$PPREC_DCFRM\n         BAS   R14,PUT_DCF_RECORD\n         B     RAR$DHB$PPRECX             Leave\n*\n** Executed instructions\n*\nRAR$DHB$PPREC_DCFN1M  MVC RAR_DHB_DREC+3(0),DHBR_NAME-DHBR(R7)\nRAR$DHB$PPREC_DCFN2M  MVC RAR_DHB_DREC+4(0),DHBR_NAME-DHBR(R7)\nRAR$DHB$PPREC_DCFRM   MVC RAR_DHB_DREC+3(0),3(R1)\nRAR$DHB$PPREC_DCFODM  MVC RAR_DHB_DREC+3(0),0(R14)\n*\nRAR$DHB$PPREC_DCFX EQU *\n*\n** Print regular (non-DCF) output\n*\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         LA    R0,RAR_DHB_PREC            Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\n         B     RAR$DHB$PPRECX\n*\n** Turn off flag for Start_Name processing\n*\nRAR$DHB$PPREC_SNAME EQU *\n         NI    RAR_FLAG1,255-$RARF1_SNAME\n*\n** Return to caller\n*\nRAR$DHB$PPRECX EQU *\n         L     R14,RAR_DHB_PPRRA          Save return address\n         BSM   0,R14\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Source Pretty printing                                      **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$SRC  EQU   *\n         ST    R14,RAR_SRC_RA\n*\n** We are just echoing source now...\n*\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         LA    R0,RAR_SRC_REC             Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\n*\n** Common exit from RAR$SRC processing\n*\nRAR$SRCX EQU   *\n         L     R14,RAR_SRC_RA\n         BSM   0,R14\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Pass 3 analysis                                             **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$PASS3 EQU  *\n         ST    R14,RAR_P3_RA              Save return address\n*\n** Print \"PASS3\" in Block Letters\n*\n         TM    PPC_FLAG1,$PPC_F1NOLOGO    Need Logos?\n         BO    RAR$P3LX                   No, continue\n         L     R1,RAR_CNTIREC             Get count\n         CH    R1,=H'1'                   First time\n         BH    RAR$P3LX                   No, skip header\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         MVI   RECOUT,X'8B'               FBM: Top of form\n         PUT   PASS3,RECOUT               Print blank line\n*\n         MVI   RECOUT,X'09'               FBM byte for single space\n         LA    R7,PASS3                   Locate DCB\n         LA    R8,C_PASS3                 Get string\n         BAS   R14,BLOCK_LETTERS          Print string\n*\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         MVI   RECOUT,X'09'               Single spaceing\n         PUT   PASS3,RECOUT\n         PUT   PASS3,RECOUT\n         PUT   PASS3,RECOUT\n         LA    R15,RECOUT+1\n         MVC   0(C_PASS3NL,R15),C_PASS3N\n         LA    R15,C_PASS3NL+1(R15)\n         MVC   0(8,R15),5(R12)            Get \"DA$ASMHA\"\n         PUT   PASS3,RECOUT\n*\n         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?\n         BNO   RAR$P3LAX\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         MVI   RECOUT,X'09'               Single spaceing\n         PUT   PASS3,RECOUT\n         PUT   PASS3,RECOUT\n         LA    R15,RECOUT+1\n         MVC   0(C_ADDRL,R15),C_ADDR\n         LA    R15,C_ADDRL+1(R15)\n         UNPK  0(9,R15),PPC_ADDR(5)\n         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         MVI   8(R15),C' '\n         PUT   PASS3,RECOUT\nRAR$P3LAX EQU *\n*\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         MVI   RECOUT,X'09'               Single spaceing\n         PUT   PASS3,RECOUT\n         PUT   PASS3,RECOUT\n         MVI   RECOUT,X'8B'               Top of page\n         PUT   PASS3,RECOUT\nRAR$P3LX EQU   *\n*\n** Copy input record to our area\n*\n         BAS   R14,CLEAR_RECOUT\n         MVC   RECOUT(121),0(R5)          Get record we can modify\n*\n** Process the data/instruction record\n*\n         CLI   RAR_TYPE,$RART_DATAC       Data record Comment?\n         BE    RAR$P3D                    No, continue\n         CLI   RAR_TYPE,$RART_DATA        Data record?\n         BNE   RAR$P3DX                   No, continue\nRAR$P3D  EQU   *\n         TM    PPC_FLAG1,$PPC_F1RSEQNUM   Remove sequence numbers?\n         BNO   RAR$P3DSNX                 No, continue\n         LA    R14,RECOUT+AHSD_SEQNUM-AHS Locate sequence number\n         MVI   0(R14),C' '                Get blank\n         MVC   1(8-1,R14),0(R14)          ..Propagate it\nRAR$P3DSNX EQU *\n         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?\n         BNO   RAR$P3DAX\n         MVC   RECOUT+1+8+1(120),1(R5)    \"x00000000x\"\n         CLI   RAR_DPLOCCP,0\n         BE    RAR$P3DAL\n         TM    RAR_FLAG1,$RARF1_ADDRE     Stopped doing addresses?\n         BO    RAR$P3DAL                  Yes, continue\n*\n         CLC   RAR_DPOPT(C_CSECTL),C_CSECT\n         BNE   RAR$P3DCX\n         TM    RAR_FLAG1,$RARF1_ADDRC     First CSECT?\n         BNO   RAR$P3DCS                  Yes, continue\n         OI    RAR_FLAG1,$RARF1_ADDRE     Stop making sense\n         B     RAR$P3DAL                  Yes, continue\nRAR$P3DCS EQU  *\n         OI    RAR_FLAG1,$RARF1_ADDRC\nRAR$P3DCX EQU  *\n*\n         L     R1,PPC_ADDR\n         A     R1,RAR_DPLOCX\n         ST    R1,DOUBLE\n         UNPK  RECOUT+1(9),DOUBLE(5)\n         MVZ   RECOUT+1(8),=X'00,00,00,00,00,00,00,00'\n         TR    RECOUT+1(8),=C'0123456789ABCDEF'\n         MVI   RECOUT+1+8,C' '\n         B     RAR$P3DAX\nRAR$P3DAL EQU  *\n         MVI   RECOUT+1,C' '\n         MVC   RECOUT+1+1(8),RECOUT+1\n         B     RAR$P3DAX\nRAR$P3DAX EQU  *\n*\n         CLI   RAR_TYPE,$RART_DATAC       Data record Comment?\n         BE    RAR$P3X                    Yes, That's all folks...\n*\n         CLC   RAR_DPOPT(C_STL),C_ST      ST instruction?\n         BNE   RAR$P3D$STX                No, continue\n         CLC   AHSD_OBJ1-AHS(2,R5),=C'50' ST instruction?\n         BNE   RAR$P3D$STX                No, continue\n         CLI   AHSD_OBJ1+3-AHS(R5),C'0'   Off register 0?\n         BNE   RAR$P3D$STX                No, leave\n         CLI   AHSD_OBJ2-AHS(R5),C'0'     Off register 0?\n         BE    RAR$P3D$MLCM               Yes, Low Core Message\nRAR$P3D$STX EQU *\n*\n         CLC   RAR_DPOPT(C_MVCL),C_MVC    MVC instruction?\n         BNE   RAR$P3D$MVCX               No, continue\n         CLC   AHSD_OBJ1-AHS(2,R5),=C'D2' MVC instruction?\n         BNE   RAR$P3D$MVCX               No, continue\n         CLI   AHSD_OBJ2-AHS(R5),C'0'     Off Register 0?\n         BE    RAR$P3D$MLCM               Yes, Low Core Message\nRAR$P3D$MVCX EQU *\n*\n         CLC   RAR_DPOPT(C_BL),C_B        Branch\n         BE    RAR$P3D$BC15               Yes, perform check\n         CLC   RAR_DPOPT(C_BCL),C_BC      Branch\n         BNE   RAR$P3D$BC15X              No, continue\nRAR$P3D$BC15  EQU *\n         CLC   AHSD_OBJ1-AHS(2,R5),=C'47' BC instruction?\n         BNE   RAR$P3D$BC15X              No, continue\n         CLI   AHSD_OBJ2-AHS(R5),C'0'     Off Register 0?\n         BE    RAR$P3D$BLCM               Yes, Low Core Message\nRAR$P3D$BC15X EQU *\n*\n         B     RAR$P3X                    Leave\nRAR$P3DX EQU   *\n*\n** Process the Heading record\n*\n         CLI   RAR_TYPE,$RART_HEADING\n         BNE   RAR$P3HLX\n*\n         MVI   RECOUT,X'09'\n         LA    R1,RECOUT                  Locate start of record\n         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?\n         BNO   RAR$P3HAX\n         MVC   RECOUT+1+8+1(120),1(R5)\n         MVC   RECOUT+1(9),=C'Address  '\n         LA    R1,RECOUT+1+8              Locate past \"xAddress  \"\nRAR$P3HAX EQU  *\n*\n         LA    R14,AHSH_BLANKS-AHS(R1)    Locate \"(DA$ASMHA Vx.xx.x)\"\n         MVI   0(R14),C'('                Prefix  0....+....1....+..\n         MVC   1(8,R14),5(R12)            Get \"DA$ASMHA\"\n         MVC   10(7,R14),X'18'(R12)       Get \"Vx.x.xx\"\n         MVI   17(R14),C')'               Suffix\n         MVC   AHSH_LOC-1-AHSH(6,R1),=C'Offset'\n         MVC   AHSH_OBJECT+1-AHSH(10,R1),=C'bject Code'\n         MVC   AHSH_SOURCE+2-AHSH(15,R1),=C'ource Statement'\n         PUT   PASS3,RECOUT               Print the record\n*\n         BAS   R14,CLEAR_RECOUT           Clear output record to blanks\n         MVI   RECOUT,X'09'               Single space\n         LA    R1,RECOUT                  Locate start of record\n         TM    PPC_FLAG1,$PPC_F1ADDR      Address mode?\n         BNO   RAR$P3HAUX\n         MVI   RECOUT+1,C'-'\n         MVC   RECOUT+2(7),RECOUT+1\n         LA    R1,RECOUT+1+8              Locate past \"xAddress  \"\nRAR$P3HAUX EQU *\n         MVI   AHSH_LOC-1-AHSH(R1),C'-'\n         MVC   AHSH_LOC-AHSH(5,R1),AHSH_LOC-1-AHSH(R1)\n#P3OBJL  EQU   L'AHSH_OBJECT\n         MVI   AHSH_OBJECT-AHSH(R1),C'-'\n         MVC   AHSH_OBJECT+1-AHSH(#P3OBJL-2,R1),AHSH_OBJECT-AHSH(R1)\n         MVI   AHSH_ADDR-AHSH(R1),C'-'\n         MVC   AHSH_ADDR+1-AHSH(4,R1),AHSH_ADDR-AHSH(R1)\n         MVI   AHSH_ADDR+6-AHSH(R1),C'-'\n         MVC   AHSH_ADDR+7-AHSH(4,R1),AHSH_ADDR+6-AHSH(R1)\n         MVI   AHSH_STMT-AHSH(R1),C'-'\n         MVC   AHSH_STMT+1-AHSH(L'AHSH_STMT-3,R1),AHSH_STMT-AHSH(R1)\n         MVI   AHSH_SOURCE-1-AHSH(R1),C'-'\n         MVC   AHSH_SOURCE-AHSH(AHSH_SRCL,R1),AHSH_SOURCE-1-AHSH(R1)\nRAR$P3HLX EQU  *\n*\n** Common Exit from PASS3 processing\n*\nRAR$P3X  EQU   *\n         PUT   PASS3,RECOUT               Print the record\n         L     R14,RAR_P3_RA              Save return address\n         BSM   0,R14\n*\n** Format our IEV messages\n*\nRAR$P3D$FM EQU *\n         PUT   PASS3,RECOUT               Print the record\n         BAS   R14,CLEAR_RECOUT\n         MVI   RECOUT,X'09'               Single space it\n         LA    R15,AHSI_MSG-AHS-1(R15)\n         L     R1,=V(RAA$DATA)\n         MVC   0(L'MSGP3XX,R15),MSGP3XX-RAA$DATA(R1)\n         LA    R15,L'MSGP3XX+2(R15)\n         BSM   0,R9\n*\n** Possible modification of low core (R0)...\n*\nRAR$P3D$MLCM EQU *\n         BAS   R9,RAR$P3D$FM              Format Message\n         MVC   0(MSGP300L,R15),MSGP300-RAA$DATA(R1)\n         B     RAR$P3X\n*\n** Possible Branch to low core (R0)...\n*\nRAR$P3D$BLCM EQU *\n         BAS   R9,RAR$P3D$FM              Format Message\n         MVC   0(MSGP301L,R15),MSGP301-RAA$DATA(R1)\n         B     RAR$P3X\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Locate end of current field                                       **\n**                                                                   **\n** Input: R0 has max length                                          **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$DENDF EQU  *\n*\n** Full Debugging: Show current byte being processed\n*\n TM    PPC_FLAG1,$PPC_F1DEBUGF\n BNO   RAR$DEF$DB1X\n ST    R0,DOUBLE\n ST    R14,DOUBLE+4\n BAS   R14,CLEAR_RECOUT           Clear record to blanks\n MVI   0(R15),C'+'\n LA    R15,2(R15)\n MVC   0(1,R15),0(R2)\n MVC   1(5,R15),=C'=Byte'\n BAS   R9,PRINT_SYSPRINT_RECORD\n L     R0,DOUBLE\n L     R14,DOUBLE+4\nRAR$DEF$DB1X EQU *\n*\n** Double quote check\n*\n         TM    RAR_DPFLAG1,$RARDPF1_QUOTE Quote mode?\n         BNO   RAR$DEFQX                  No, continue\n         CLI   0(R2),X'7D'                Ending Quote?\n         BNE   RAR$DEFB                   No, bump past it\n         CLI   1(R2),X'7D'                Double quote?\n         BNE   RAR$DEFQO1                 No,continue\n         BCTR  R3,0                       Decrement by 1\n         LA    R2,1(R2)                   Bump past first one and\n         B     RAR$DEFB                   then bump past second one\nRAR$DEFQO1 EQU *\n*\n** Full Debugging: Note that we turned quote mode off\n*\n TM    PPC_FLAG1,$PPC_F1DEBUGF\n BNO   RAR$DEF$DB2X\n ST    R0,DOUBLE\n ST    R14,DOUBLE+4\n BAS   R14,CLEAR_RECOUT           Clear record to blanks\n MVI   0(R15),C'+'\n LA    R15,2(R15)\n MVC   0(27,R15),=C'Note: Quote mode turned off'\n BAS   R9,PRINT_SYSPRINT_RECORD\n L     R0,DOUBLE\n L     R14,DOUBLE+4\nRAR$DEF$DB2X EQU *\n         NI    RAR_DPFLAG1,255-$RARDPF1_QUOTE\n         B     RAR$DEFB\nRAR$DEFQX EQU *\n*\n** Check for starting quote\n*\n         CLI   0(R2),X'7D'                Single Quote?\n         BNE   RAR$DEFQCX                 No, continue\n         TM    RAR_DPFLAG1,$RARDPF1_OPERAND Special Operand stuff?\n         BNO   RAR$DEFQC                  No, continue\n         LR    R15,R2                     Get current location\n         BCTR  R15,0                      Backup one\n         CLI   0(R15),C'L'                Doing a \"L'field\"\n         BE    RAR$DEFB                   Yes, skip quote proc.\nRAR$DEFQC EQU *\n*\n** Full Debugging: Note that we turned quote mode on\n*\n TM    PPC_FLAG1,$PPC_F1DEBUGF\n BNO   RAR$DEF$DB3X\n ST    R0,DOUBLE\n ST    R14,DOUBLE+4\n BAS   R14,CLEAR_RECOUT           Clear record to blanks\n MVI   0(R15),C'+'\n LA    R15,2(R15)\n MVC   0(26,R15),=C'Note: Quote mode turned on'\n BAS   R9,PRINT_SYSPRINT_RECORD\n L     R0,DOUBLE\n L     R14,DOUBLE+4\nRAR$DEF$DB3X EQU *\n         OI    RAR_DPFLAG1,$RARDPF1_QUOTE Turn on flag\n         B     RAR$DEFB                   Continue\nRAR$DEFQCX EQU *\n*\n** Check for end of field when not in quote mode...\n*\n         CLI   0(R2),C' '                 Blank?\n         BE    RAR$DEFX                   Yes, leave\n*\n** Bump to next byte\n*\nRAR$DEFB EQU   *\n         MVC   0(1,R4),0(R2)              Save byte\n         LA    R4,1(R4)                   Bump past it\n         LA    R2,1(R2)                   No, skip to next byte\n         BCTR  R3,0                       Decrement total count\n         LTR   R3,R3                      Hit end?\n         BZ    RAR$DEFE                   Yes, error\n         BCT   R0,RAR$DENDF               No, process next byte\n*\n** Field extends past end of source statement, it will be continued\n** on next line...\n*\nRAR$DEFE EQU *\n*\n** End of processing\n*\nRAR$DEFX EQU *\n         BSM   0,R14\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Bump past extra spaces until we get to next field           **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$DNEXTF EQU *\n         CLI   0(R2),C' '                 Blank?\n         BNE   RAR$DNEXTFX                No, found next guy...\n         LA    R2,1(R2)                   Bump to next byte\n         BCT   R3,RAR$DNEXTF              Process it\nRAR$DNEXTFX EQU *\n         BSM   0,R14\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Title card                                                  **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$TITLE EQU  *\n         L     R14,=V(RAA$DATA)\n         CLC   AHST_TITLE-AHS(C_XREFL,R5),C_XREF-RAA$DATA(R14)\n         BE    RAR$TITLE$TM\n         CLC   AHST_TITLE-AHS(C_DXREFL,R5),C_DXREF-RAA$DATA(R14)\n         BE    RAR$TITLE$TM\n         CLC   AHST_TITLE-AHS(C_RLDL,R5),C_RLD-RAA$DATA(R14)\n         BNE   RAR$TITLE$TMX\nRAR$TITLE$TM DS 0H\n         OI    RAR_FLAG2,$RARF2_TRAILER   Turn on flag\nRAR$TITLE$TMX DS 0H\n         MVI   RAR_TYPE,$RART_TITLE\n*  Could save title and CSECT name...\n         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?\n         BNO   RAR$LX\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVC   0(23,R15),=C'# Record type detected:'\n         LA    R15,24(R15)\n         MVC   0(5,R15),=C'Title'\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     RAR$LX                     Read next record\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Heading card                                                **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$HEAD EQU   *\n         MVI   RAR_TYPE,$RART_HEADING\n         TM    PPC_FLAG1,$PPC_F1DEBUGS    Debugging short?\n         BNO   RAR$LX\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVC   0(23,R15),=C'# Record type detected:'\n         LA    R15,24(R15)\n         MVC   0(7,R15),=C'Heading'\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     RAR$LX                     Read next record\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       IEV message card                                            **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$IEV  EQU   *\n         MVI   RAR_TYPE,$RART_IEVMSG\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         MVC   0(AHSI_MSGL,R15),AHSI_MSG-AHS(R5)\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n         B     RAR$LX                     Read next record\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Reset fields                                                **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$RSETF EQU  *\n         ST    R14,DOUBLE\n*\n         LA    R14,RAR_DPI                To: Address\n         LA    R15,RAR_DPIL               To: Length\n         SLR   R1,R1                      From: Set length to zero\n         MVCL  R14,R0\n*\n         LA    R1,RAR_DPNAME\n         MVI   0(R1),0\n         XC    RAR_DPNAMEL(2),RAR_DPNAMEL\n         ST    R1,RAR_DPNAMEA\n         LA    R1,RAR_DPOPT\n         MVI   0(R1),0\n         ST    R1,RAR_DPOPTA\n         LA    R1,RAR_DPOPR\n         MVI   0(R1),0\n         ST    R1,RAR_DPOPRA\n         LA    R1,RAR_DPREMARK\n         MVI   0(R1),C' '\n         ST    R1,RAR_DPREMARKA\n*\n         L     R14,DOUBLE\n         BSM   0,R14\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       End of file on SYSUT1                                       **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRAR$EOF  EQU   *\n         BAS   R14,RAR$PM17               Print Message 17 if needed\n*\n** Close any open files\n*\n         LA    R3,SYSUT1\n         BAS   R9,CLOSE_FILE\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Termination Section                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n*\n** Print previous record and save current record\n*\n         TM    X_FLAG1,$XF1_REPORT        Doing Data HandBook?\n         BNO   X$DHBX                     No, continue\n         CLI   RAR_DHB_PREC,0             Have a previous record?\n         BE    X$DHBX                     No, continue\n         BAS   R14,RAR$DHB$PPREC          Print previous record\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG20L,R15),MSG20-RAA$DATA(R1)\n         LA    R15,MSG20L+1(R15)          Bump past it\n         L     R1,RAR_DHB_DSECTC          Get DSECT count\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(7,R15),=C' DSECTs'\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         ICM   R1,B'0011',RAR_LOVERLT     Have a total overflow?\n         BZ    X$OVERX                    No, leave\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG18L,R15),MSG18-RAA$DATA(R1)\n         LA    R15,MSG18L+1(R15)          Bump past it\n         LH    R1,RAR_LOVERLT             Get total overflow?\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\nX$OVERX  DS    0H\n*\n         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?\n         BO    X$DHB$DCF\n* Print dash line\n         LA    R1,WA_FWA_REPORT           Locate File-Work-Area\n         L     R15,=V(RAA$DATA)           Locate Data CSECT\n         LA    R15,C_DASHLINE-RAA$DATA(R15) Locate dash line\n         LR    R0,R15                     Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\n         B     X$DHBX\n*\nX$DHB$DCF EQU  *\n         BAS   R14,CLEAR_DHB_RECORD\n         MVC   RAR_DHB_DREC(8),=C':etable.'\n         BAS   R14,PUT_DCF_RECORD\n*\n         TM    PPC_FLAG2,$PPC_F2BODYONLY  DCF body only?\n         BO    X$DHBX                     yes, skip end of document\n*\n         L     R8,=V(RAA$DCF)             -> RAA$DCF CSECT\n         LA    R1,RAA$DCF_TRAILER-RAA$DCF(R8) Locate heading\n         BAS   R14,PRINT_DCF_STRINGS      Print all strings\nX$DHBX   EQU   *\n*\n** Print ending message\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG4L,R15),MSG4-RAA$DATA(R1)\n         LA    R15,MSG4L+1(R15)           Bump past it\n         L     R1,RAR_CNTIREC             Get number of records\n         BAS   R9,EDITFWF                 Edit it\n         MVI   0(R15),C' '                Fix hex 0 byte\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n         BAS   R9,FORMAT_MESSAGE\n         MVC   0(MSG2L,R15),MSG2-RAA$DATA(R1)\n         LA    R15,MSG2L+1(R15)           Bump past it\n         SLR   R1,R1                      Clear register\n         IC    R1,X_MAXCC                 Get max condition code\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print blank line\n*\n** Close any open files\n*\n         LA    R3,WA_FWA_SYSPRINT         Locate File-Work-Area\n         LA    R3,FWA_DCB-FWA(R3)         Locate DCB\n         BAS   R9,CLOSE_FILE              Close the file\n*\n         LA    R3,PASS3                   Locate DCB\n         BAS   R9,CLOSE_FILE              Close the file\n*\n         LA    R3,WA_FWA_REPORT           Locate File-Work-Area\n         LA    R3,FWA_DCB-FWA(R3)         Locate DCB\n         BAS   R9,CLOSE_FILE              Close the file\n*\n** Release INDEX resources\n*\n         TM    X_FLAG1,$XF1_INDEX         Yes, turn on flag\n         BNO   X$INDEXX\n*\n         L     R3,INDEX_AREA+4            Locate index area\n         LA    R3,INDEXA_FWA-INDEXA(R3)   Locate File-Work-Area\n         LA    R3,FWA_DCB-FWA(R3)         Locate DCB\n         BAS   R9,CLOSE_FILE              Close the file\n*\n         LM    R0,R1,INDEX_AREA           Get Length and address\n         FREEMAIN R,LV=(0),A=(1)          Free the storage\nX$INDEXX EQU   *\n*\n** Delete LOADed modules\n*\n         TM    X_FLAG2,$XF2_DDATE         Did we load it?\n         BNO   X$DA$DATEX                 No, don't need to delete it\n         ICM   R0,B'1111',EP_DA$DATE\n         BZ    X$DA$DATEX\n         DELETE EPLOC==CL8'DA$DATE'\nX$DA$DATEX EQU *\n         TM    X_FLAG2,$XF2_DMXD          Did we load it?\n         BNO   X$DA$MXDX                  No, don't need to delete it\n         ICM   R0,B'1111',EP_DA$MXD\n         BZ    X$DA$MXDX\n         DELETE EPLOC==CL8'DA$MXD'\nX$DA$MXDX EQU *\n*\n** Release any storage still left around\n*\n         LM    R0,R1,RAR_DCDSECTH         Save length and address\n         LTR   R0,R0                      Any storage?\n         BZ    X$DCDSX                    No, continue\n         FREEMAIN R,LV=(0),A=(1)          Release storage\nX$DCDSX  EQU   *\n*\n** Return to caller\n*\nX$LEAVE  EQU   *\n         SLR   R15,R15                    Clear register\n         IC    R15,X_MAXCC                Get max condition code\n         DA#LEAVE RC=(15)                 Return to caller\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Generate some errors for PASS3 to detect                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         B     14                         Branch to low core (S0C1)\n         MVC   0(8),MSG1-RAA$DATA(R1)     Modify Low core (S0C4)\n         ST    14,0                       Modify Low core (S0C4)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Error routines                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Routine could not be loaded\n**\n** Input: R8 points to 8 byte module name\n*\nE$LOAD   EQU   *\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG99L,R15),MSG99-RAA$DATA(R1)\n         MVC   MSG99L(8,R15),0(R8)\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         B     X$LEAVE\n*\n** Fileo open error: input: R3 - DCB\n*\nE$FOPEN  EQU   *\n         LR    R2,R15                     SAVE RETURN CODE\n*\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG3L,R15),MSG3-RAA$DATA(R1)\n         LA    R15,MSG3L+1(R15)\n         MVC   0(8,R15),DCBDDNAM-IHADCB(R3) GET DDNAME\n         LA    R0,L'DCBDDNAM              MAX LENGTH OF DDNAME\n         BAS   R14,LOCATE_FIRST_SPACE     LOCATE FIRST SPACE\n*\n         LR    R1,R2                      GET OPEN RETURN CODE\n         LTR   R1,R1                      OPEN RC=0\n         BZ    EFO$OX                     YES, DONT PRINT RC=0\n         MVC   0(10,R15),=C', OPEN RC='   TEXT\n         LA    R15,10(R15)                BUMP PAST TEXT\n         BAS   R9,EDITFWF                 EDIT IT\nEFO$OX   EQU   *\n*\n         ICM   R1,B'1111',CO_OPENC        GET OPEN ABEND CODE\n         BZ    EFO$CX                     NONE, MOVE ON\n         N     R1,=A(X'FFF0FF00')         TURN OFF UNNEEDED BITS\n         MVC   0(9,R15),=C', ABEND S'     TEXT\n         LA    R15,9(R15)                 BUMP PAST IT\n         ST    R1,DOUBLE                  SAVE ABEND CODE\n         UNPK  0(9,R15),DOUBLE(5)                   ---+\n         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'    | BINARY TO HEX\n         TR    0(8,R15),=C'0123456789ABCDEF'        ---+\n         MVI   3(R15),C'-'                MOVE IN DASH\n         LA    R15,6(R15)\n         MVI   0(R15),C' '\n         MVI   1(R15),C' '\nEFO$CX   EQU   *\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         B     EXIT\n*\n** DCB ABEND exit routine: GC26-4013 MVS/XA DATA ADMINISTRATION GUIDE\n**                         CHAPTER 7.\n*\nE$OPENA  EQU   *\n         L     R2,0(R1)                   GET ABEND CODE\n         ST    R2,CO_OPENC                SAVE ABEND CODE\n         MVI   3(R1),4                    IGNORE ABEND\n         BSM   0,R14                      RETURN TO IOS\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**  Print \"Strings\" from RAA$DCF CSECT to report file                **\n**                                                                   **\n**       Input: R1 has address of table                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPRINT_DCF_STRINGS EQU *\n         ST    R14,PDS_RA                 Save return address\n         STM   R8,R9,PDS_REGS             Save registers\n         LR    R8,R1                      Locate input string\n         LA    R9,RAR_DHB_DREC            Locate output location\nPDT$L    EQU   *\n         BAS   R14,CLEAR_DHB_RECORD       Clear record to blanks\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R8)                   Get length of string\n         EX    R1,PDT$LM                  Move string to recout\n*\n         L     R15,=V(RAA$DCF)            -> DCF data CSECT\n*\n** Exception: stitle\n*\n         LA    R14,RAA$DCF_HSTITLE-RAA$DCF(R15) Locate to string\n         CR    R14,R8                     At ':title stitle='\n         BNE   PDT$LSTX                   No, continue\n         MVI   14(R9),X'7D'               Get starting quote\n         LA    R15,15(R9)                 Locate output location\n         BAS   R14,PDT$TITLE              Insert Title line\n         MVI   0(R15),X'7D'               Ending quote\n         MVI   1(R15),C'.'                Ending dot\n         B     PDT$LB                     Continue\nPDT$LSTX EQU   *\n*\n** Exception: GDOC\n*\n         LA    R14,RAA$DCF_HGDOC-RAA$DCF(R15) Locate to string\n         CR    R14,R8                     At ':GDOC\"\n         BNE   PDT$LGDX                   No, continue\n         MVI   10(R9),X'7D'               Get starting quote\n         LA    R15,11(R9)                 Locate output location\n         BAS   R14,PDT$TITLE              Insert Title line\n         L     R14,=V(RAA$DCF)            -> DCF data CSECT\n         MVC   1(RAA$DCF_HDHBL-1,R15),RAA$DCF_HDHB+1-RAA$DCF(R14)\n         LA    R15,1+RAA$DCF_HDHBL-1(R15) Bump past it\n         MVI   0(R15),X'7D'               Ending quote\n         B     PDT$LB                     Continue\nPDT$LGDX EQU   *\n*\n** Exception: date\n*\n         LA    R14,RAA$DCF_HDATE-RAA$DCF(R15) Locate to string\n         CR    R14,R8                     At ':date.\"\n         BNE   PDT$LHDX                   No, continue\n         MVC   6(11,R9),X_ODGEUR11_STR\n         B     PDT$LB                     Continue\nPDT$LHDX EQU   *\n*\n** Exception: title\n*\n         LA    R14,RAA$DCF_HTITLE-RAA$DCF(R15)\n         CR    R14,R8                     Title?\n         BNE   PDT$LTX                    No, continue\n         LR    R15,R9                     Locate output location\n         BAS   R14,PDT$TITLE              Insert Title line\n         B     PDT$LB                     Continue\nPDT$LTX  EQU   *\n*\n** Exception: frame=\n*\n         LA    R14,RAA$DCF_NDBOX-RAA$DCF(R15) Locate to string\n         CR    R14,R8                     At \"Frame=\"\n         BNE   PDT$LBOXX                  No, continue\n         TM    PPC_FLAG2,$PPC_F2NBOX      Option specified?\n         BNO   PDT$LBOXX\n         MVC   13(4,R9),=C'none'          Make it \"frame=none\"\n         B     PDT$LB\nPDT$LBOXX EQU  *\n*\n** Exception: cwidth\n*\n         LA    R14,RAA$DCF_HCW1-RAA$DCF(R15) Locate to string\n         CR    R14,R8                     At CWIDTH?\n         BE    PDT$LCW                    No, continue\n         LA    R14,RAA$DCF_HCW2-RAA$DCF(R15) Locate to string\n         CR    R14,R8                     At CWIDTH?\n         BNE   PDT$LCWX                   No, continue\nPDT$LCW  EQU   *\n         CLC   PPC_NAMEL+2(2),=AL2(#PPC_NAMEL) Default or lower?\n         BNH   PDT$LCWX                   Yes, leave\n         MVI   27(R9),C'5'                Make name field longer\n         MVI   30(R9),C'5'                Make name field longer\nPDT$LCWX EQU   *\n*\n** Bump to past this string to next one\n*\nPDT$LB   EQU   *\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R8)                   Restore length of string\n         LA    R8,2(R1,R8)                Bump past string\n         BAS   R14,PUT_DCF_RECORD         Print the record\n         CLI   0(R8),X'FF'                End of records\n         BNE   PDT$L                      No, continue\n*\n** Return to caller\n*\n         LM    R8,R9,PDS_REGS             Restore registers\n         L     R14,PDS_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\nPDT$LM   MVC   0(0,R9),1(R8)\nPDT$TTM  MVC   0(0,R15),PPC_TITLE+1\n*\n** Move title to output line at R15\n*\nPDT$TITLE EQU *\n         ST    R14,DOUBLE                 Save return address\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0001',PPC_TITLE      Get length of title\n         BNZ   PDT$TM                     Have one?\n         MVC   0(4,R15),=C'Misc'          Don't know what we have\n         LA    R15,5(R15)                 Bump past it\n         B     PDT$TMX                    Leave\nPDT$TM   EQU   *\n         EX    R14,PDT$TTM                Move title to output\n         LA    R15,1(R14,R15)             Bump past it\nPDT$TMX  EQU   *\n         L     R14,DOUBLE                 Get return address\n         BSM   0,R14                      Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       MISC Internal subroutines                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Put DCF record to file\n*\nPUT_DCF_RECORD EQU *\n         ST    R14,DOUBLE                 Save return address\n         LA    R1,WA_FWA_REPORT           Locate File work area\n*\n         L     R14,FWA_PAGECNT-FWA(R1)    Get current count\n         LA    R14,1(R14)\n         ST    R14,FWA_PAGECNT-FWA(R1)    Get current count\n*\n         LA    R1,FWA_DCB-FWA(R1)         Locate DCB\n         PUT   (1),RAR_DHB_DREC           Put record on file\n         L     R14,DOUBLE                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Close a file\n** Input: R3 - Address of the DCB to close\n*\nCLOSE_FILE EQU *\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   CF$X                       No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize Parameter List\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\nCF$X     EQU   *\n         BSM   0,R9                       Return to caller\n*\n** Format message\n*\nFORMAT_MESSAGE EQU *\n         L     R1,=V(RAA$DATA)\n         LA    R15,WA_FWA_SYSPRINT\n         LA    R15,FWA_DCB-FWA(R15)\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS IT OPEN?\n         BO    FM$RO                      YES, FORMAT NORMAL MESSAGE\n         LA    R15,RECOUT                 LOCATE MESSAGE WORK AREA\n         MVC   0(C_WTOL,R15),C_WTO-RAA$DATA(R1)\n         LA    R15,4(R15)                 BUMP PAST WTO FLAGS\n         B     FM$ROX                     MOVE PAST SYSPRINT MESSAGE\nFM$RO    EQU   *\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\nFM$ROX   EQU   *\n         MVC   0(8,R15),5(R12)            Move in \"DA$ASMHA\"\n         MVI   8(R15),C'-'\n         LA    R15,9(R15)                 Bump past \"DA$ASMHA-\"\n         BSM   0,R9\n*\n** Check open of file\n**\n** Input: R15 - Open Return Code\n**        R3  - Address of DCB\n**        CO_OPENC - ABEND code from Exit-List\n*\nCHECK_OPEN EQU *\n         LTR   R15,R15                    CHECK OPEN RETURN CODE\n         BNZ   E$FOPEN                    NOT GOOD: PRINT ERROR\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN IS IT OPEN?\n         BNO   E$FOPEN                    NO, PRINT ERROR MESSAGES\n         ICM   R1,B'1111',CO_OPENC        GET OPEN-ABEND CODE\n         BNZ   E$FOPEN                    YES, NO ABEND CODE...\n         BSM   0,R9\n*\n** POINT REGISTER 15 TO FIRST BLANK IN STRING\n** INPUT:  R0  - MAXIMUM LENGTH OF STRING\n**         R15 - STRING\n** OUTPUT: R15 - FIRST SPACE IN STRING\n*\nLOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '\n         BE    FS$EXIT\n         LA    R15,1(R15)\n         BCT   R0,LOCATE_FIRST_SPACE\nFS$EXIT  EQU   *\n         BSM   0,R14\n*\n** Trim the trailing blanks from a string\n** Input:  R0  - Maximum length of string\n**         R15 - Last byte in string\n** Output: R15 - Last non-space in string\n*\nLOCATE_LAST_NSPACE EQU *\n         CLI   0(R15),C' '                Blank?\n         BNE   LNS$X                      No, found last non-space\n         BCTR  R15,0                      Backup one\n         BCT   R0,LOCATE_LAST_NSPACE      Repeat\nLNS$X    EQU   *\n         BSM   0,R14                      Return to caller\n*\n** Print record on SYSPRINT\n*\nPRINT_SYSPRINT_RECORD EQU *\n** Check for WTO processing if SYSPRINT is not open\n         LA    R1,WA_FWA_SYSPRINT         Locate File-Work-Area\n         LA    R14,FWA_DCB-FWA(R1)        Locate DCB\n         TM    DCBOFLGS-IHADCB(R14),DCBOFOPN Open?\n         BO    PSR$WTOX                   Yes, do file services\n*\n         SLR   R14,R14\n         IC    R14,FWA_LINECNT-FWA(R1)\n         LA    R14,1(R14)\n         STC   R14,FWA_LINECNT-FWA(R1)\n         CLI   FWA_LINECNT-FWA(R1),50\n         BNH   PSR$WTOS\n         LA    R1,RECOUT                  LOCATE WTO MESSAGE\n         WTO   ,MF=(E,(1))                ..ISSUE IT\n         BAS   R9,FORMAT_MESSAGE          Format Message\n         MVC   0(MSG98L,R15),MSG98-RAA$DATA(R1)\n         WTO   ,MF=(E,RECOUT)\n         DC    A(0)                       Force S0C1 ABEND\nPSR$WTOS EQU   *\n         LA    R1,RECOUT                  LOCATE WTO MESSAGE\n         WTO   ,MF=(E,(1))                ..ISSUE IT\n         BSM   0,R9\nPSR$WTOX EQU   *\n*\n         LA    R0,RECOUT                  Locate output record\n         L     R15,=V(RAA$PRT)            -> RAA$PRT CSECT\n         BALR  R14,R15                    Call the print routine\nPSR$X    EQU   *\n         BSM   0,R9                       Return to caller\n*\n** Open file in FWA area\n**\n** Input: R1 - FWA area\n**        R15 - Description string address or none\n**        R8 - DDNAME\n*\nOPEN_FILE_WORK_AREA EQU *\n         ST    R14,OFWA_RA                Save return address\n*\n   XC    FWA_INIT-FWA(FWA_INITL,R1),FWA_INIT-FWA(R1)\n         MVI   FWA_LINECNT-FWA(R1),99     Force heading\n         MVC   FWA_STRTLIT-FWA(4,R1),=CL4'FWA'\n         MVC   FWA_DCBLIT-FWA(4,R1),=CL4'DCB'\n         MVC   FWA_ENDLIT-FWA(4,R1),=CL8'END FWA'\n         MVC   FWA_DDNAME-FWA(8,R1),0(R8)\n         ST    R15,FWA_DESC-FWA(R1)       Save string\n         LA    R15,X_ODGEUR11             Locate date string structure\n         ST    R15,FWA_DATE-FWA(R1)       Save it\n         LA    R15,X_OTIMES11             Locate date string structure\n         ST    R15,FWA_TIME-FWA(R1)       Save it\n*\n         LA    R3,FWA_DCB-FWA(R1)         Locate DCB area\n         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant\n*\n         TM    PPC_FLAG2,$PPC_F2DCF       DCF mode?\n         BNO   OFWA$RX\n         CLC   0(8,R8),=CL8'REPORT'       Report file?\n         BNE   OFWA$RX\n         NI    DCBRECFM-IHADCB(R3),255-DCBRECCA  Turn off ANSI...\nOFWA$RX  EQU   *\n*\n         MVC   DCBDDNAM-IHADCB(8,R3),0(R8)\n         LA    R15,133                    Set LRECL\n         STH   R15,DCBLRECL-IHADCB(R3)    Save it\n*\n         LA    R15,FWA_EXLST-FWA(R1) Locate EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) Save it\n         LA    R15,E$OPENA                Locate DCB ABEND routine\n         ST    R15,FWA_EXLST-FWA(R1) PUT INTO EXLST\n         OI    FWA_EXLST-FWA(R1),X'11'+X'80'\n         XC    CO_OPENC(4),CO_OPENC       Clear code\n*\n         MVC   PARMLIST(C_LSTOL),C_LSTO   Get open Parameter List\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PARMLIST)\n*\n         L     R14,OFWA_RA                Get return address\n         BSM   0,R14                      Return to caller\n*\n**       EDIT FULLWORD (FLUSH TO R15)\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITFWF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\nEF$EDMK  EQU   *\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,EF$OM                  MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '                Fix byte\n         BSM   0,R9                       RETURN TO CALLER\nEF$OM    MVC   0(0,R15),0(R1)\nEDITFWF0 EQU   *\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n**       EDIT FULLWORD (FLUSH TO R15) WITHOUT COMMAS\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nEDITNCF  EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITNCF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+7               LOCATE SIG DIGIT\n         MVC   DOUBLE2(8),EDITP15F\n         EDMK  DOUBLE2(8),DOUBLE+4        EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,ENCFM                  MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         BSM   0,R9                       RETURN TO CALLER\nENCFM    MVC   0(0,R15),0(R1)\nEDITNCF0 EQU   *\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n** Clear heading record to blanks\n*\nCLEAR_DHB_RECORD EQU *\n         LA    R15,RAR_DHB_DREC           Locate output record\n         B     CR$CLEAR\nCLEAR_RECOUT  EQU *\n         LA    R15,RECOUT                 Locate output record\nCR$CLEAR EQU   *\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)  ..Propagate it\n         LA    R15,1(R15)\n         BSM   0,R14                      Return to caller\n*\n** Convert a hex string from character to binary value\n** For example: From CL8'3020100E' to X'3020100E'\n**\n** Input: R0 - Length of output string (input / 2)\n**        R1 - Output location\n**        R15 - Input location\n*\nHEXTRAN EQU *\n STM   R3,R6,DOUBLE2                      Save registers\nHT$MT EQU *\n MVI   0(R1),0                            Zero output byte\n LA    R4,1                               Offset for first hex char\n LA    R5,2                               Number of Nibbles in a byte\nHT$CL EQU *\n L     R6,=V(RAA$DATA)                    -> Data CSECT\n LA    R6,T_HEX-RAA$DATA(R6)              Locate Hex table\n LA    R3,T_HEXE                          Number of entries in table\nHT$C1L EQU *\n CLC   0(1,R6),0(R15)                     Match?\n BE    HT$C1LX                            Yes, move on\n LA    R6,3(R6)                           No, bump to next byte\n BCT   R3,HT$C1L                          Repeat\n B     HT$X                               Character not valid\nHT$C1LX EQU *\n LA    R6,0(R4,R6)                        Bump to bitstring\n OC    0(1,R1),0(R6)                      Turn on bits for this nibble\n LA    R4,1(R4)                           Increment for next nibble\n LA    R15,1(R15)                         Bump to the next input byte\n BCT   R5,HT$CL                           Do next hex nibble in byte\n LA    R1,1(R1)                           Bump to next output byte\n BCT   R0,HT$MT                           ..do it\n SLR   R15,R15                            Clear register: success\nHT$X EQU *\n LM    R3,R6,DOUBLE2                      Restore registers\n BSM   0,R8                               Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Print Big letters via IEFSD095                             **\n**                                                                   **\n**        Input: R8 points to a string                               **\n**               R7 points to the DCB to print on                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nBLOCK_LETTERS EQU *\n         ICM   R15,B'1111',=V(IEFSD095)\n         BZ    BL$X\n         ST    R14,BL_RA                  Save return address\n*\n** Fix the string\n*\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R8)                   Get string length\n         LA    R1,1(R1)                   Increment by 1\n         XC    BL_LEN(3),BL_LEN           Fix first 3 bytes of fullword\n         STC   R1,BL_LEN+3                Save length for IEFSD095\n         LA    R8,1(R8)\n*\n** Call IEFSD095 until all lines are printed\n*\n         LA    R1,1\n         ST    R1,BL_LINEC              GET LINE COUNTER FOR LOOP INDEX\n         LA    R1,RECOUT+12+5           OUTPUT LOC (5 CENTER, 12 SLANT)\n         ST    R1,BL_ADDR               Save location\nBL$LP    DS    0H\n         MVI   RECOUT+1,C' '\n         MVC   RECOUT+2(131),RECOUT+1\n*\n         L     R5,BL_ADDR\n         L     R15,=V(IEFSD095)           Locate routine: IEFSD095\n         CALL  (15),                             Call IEFSD095         @\n               ((8),BL_LINEC,(5),BL_LEN),        ..Parameters          @\n               VL,MF=(E,PARMLIST)                ..Parm list/VL\n         PUT   (7),RECOUT                 Print record on file=REPORT\n*\n         L     R1,BL_ADDR\n         BCTR  R1,0                       Decrement for slant\n         ST    R1,BL_ADDR\n*\n         L     R1,BL_LINEC\n         LA    R1,1(R1)                   Increment line counter\n         ST    R1,BL_LINEC\n*\n         CH    R1,=H'12'                  End of the line?\n         BNH   BL$LP                      Nope, do next line\n         L     R14,BL_RA                  Save return address\n*\n** Common exit from Block_Letter routine\n*\nBL$X     EQU   *\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITP15F DC    X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'\n*\n** Copy/Constants\n*\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nC_RDJFCB RDJFCB (*-*,(INPUT)),MF=L\nC_RDJFCBL EQU *-C_RDJFCB\n*\n         PRINT NOGEN\nC_DCBI   DCB   DDNAME=C_DCB,                                           @\n               DSORG=PS,MACRF=GL,EODAD=*-*,RECFM=FBM\nC_DCBIL  EQU   *-C_DCBI\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DSORG=PS,MACRF=PM,RECFM=FBA\nC_DCBOL  EQU   *-C_DCBO\n         PRINT GEN\nC_ODDOW9   DA#DATE DPE,OPREFIX=C_ODDOW9,OSTR=NO,                       @\n               OSTRL=$DA#DATE_ODDOW9,OTYPE=$DA#DATE_ODDOW\nC_ODGEUR11 DA#DATE DPE,OPREFIX=C_ODGEUR11,OSTR=NO,                     @\n               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR\nC_OTIMES11 DA#DATE DPE,OPREFIX=C_OTIMES11,OSTR=NO,                     @\n               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES\n*\n** Some strings\n*\nC_NOTITLE   DA#STR 'Data Area Handbooks'\nC_SRC       DA#STR 'Assembler Source listing for'\nC_DAHANDBKD DA#STR 'Data Area Handbook for '\nC_INDEX     DA#STR 'INDEX   '\nC_INDEXD    DA#STR 'Index of Data Handbook DSECTs'\nC_PASS3N    DC  C'Note: The following listing was processed by'\nC_PASS3NL   EQU *-C_PASS3N\nC_ADDR      DC  C'Note: Performing Address processing based on offset/'\n            DC  C'LOC in program starting at'\nC_ADDRL     EQU *-C_ADDR\nC_PASS3     DA#STR 'PASS 3'\n*\n** Assembler checking: we put a hex zero on the end to ensure that\n** \"DS\" does not match for \"DSECT\". If you know what I mean and I\n** think you do...\n*\nC_DS     DC    C'DS',X'00'\nC_DSL    EQU   *-C_DS\nC_DC     DC    C'DC',X'00'\nC_DCL    EQU   *-C_DC\nC_EQU    DC    C'EQU',X'00'\nC_EQUL   EQU   *-C_EQU\nC_ORG    DC    C'ORG',X'00'\nC_ORGL   EQU   *-C_ORG\nC_END    DC    C'END',X'00'\nC_ENDL   EQU   *-C_END\nC_EJECT  DC    C'EJECT',X'00'\nC_EJECTL EQU   *-C_EJECT\nC_SPACE  DC    C'SPACE',X'00'\nC_SPACEL EQU   *-C_SPACE\nC_DSECT  DC    C'DSECT',X'00'\nC_DSECTL EQU   *-C_DSECT\nC_CSECT  DC    C'CSECT',X'00'\nC_CSECTL EQU   *-C_CSECT\nC_ST     DC    C'ST',X'00'\nC_STL    EQU   *-C_ST\nC_MVC    DC    C'MVC',X'00'\nC_MVCL   EQU   *-C_MVC\nC_B      DC    C'B',X'00'\nC_BL     EQU   *-C_B\nC_BC     DC    C'BC',X'00'\nC_BCL    EQU   *-C_BC\n*\n** Operand type\n*\nT_OPRT   EQU   *\n         DC    C'A',CL10'Address'\nT_OPRTX  DC    C'X',CL10'Hex'\nT_OPRTB  DC    C'B',CL10'Bitstring'\n         DC    C'F',CL10'Fixed'\n         DC    C'V',CL10'VCON EPA'\n         DC    C'Z',CL10'Zoned'\n         DC    C'P',CL10'Packed'\n         DC    C'H',CL10'Binary'\n         DC    C'D',CL10'DBL Word'\n         DC    C'C',CL10'Character'\n         DC    C'Y',CL10'Y-type adr'\nT_OPRTST DC    C'0',CL10'Structure'\nT_OPRTE  EQU   (*-T_OPRT)/TOPRTL\n         DC    C' ',CL10'Unknown'\nT_OPRTA  DC    C'0',CL10'Alignment'\n*\n** Literals\n*\n         LTORG ,\n         DS    0D\n         DROP  R10,R11,R12,R13\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Print routine                                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nRAA$PRT  DA#ENTER 'PRINT ROUTINE FOR DA$ASMHA',RSA=(1)\n         USING FWA,R13                    Locate work area\n         LR    R7,R0                      Get record to print\n         LA    R8,FWA_DCB                 Locate DCB\n*\n         TM    FWA_FLAG1,$FWA_F1PRTRH     Do report headings now?\n         BO    NPR$RH1                    Yes, continue\n*\n         CLI   0(R7),C'1'                 Heading line?\n         BE    NPR$HEAD                   Yes, ignore line count check\n         CLI   FWA_LINECNT,53             Heading needed?\n         BNH   NPR$DETAIL                 No, continue\n*\n** Heading\n*\nNPR$HEAD EQU   *\n         MVI   FWA_LINECNT,0              Reset line count\n* Skip a line for online viewing ease...\n         ICM   R1,B'1111',FWA_PAGECNT     Get page count\n         BZ    NPR$HC1X                   Zero skip it\n         PUT   (8),FWA_RT2                Print SYSPRINT record\nNPR$HC1X EQU   *\n*\n         ICM   R15,B'1111',FWA_PGL        Get page number location\n         BNZ   NPR$PG                     Yes, continue\n         LA    R15,FWA_RT2                Locate title line\n         MVI   0(R15),C' '                Get blank\n         MVC   1(L'FWA_RT1-1,R15),0(R15) .. Propagate it\n         LA    R15,FWA_RT1                Locate title line\n         MVI   0(R15),C' '                Get blank\n         MVC   1(L'FWA_RT1-1,R15),0(R15) .. Propagate it\n         MVI   0(R15),C'1'                Top of page\n         LA    R15,1(R15)\n*\n         CLC   FWA_DDNAME(8),=CL8'REPORT'\n         BE    NPR$PNX\n         MVC   0(8,R15),=CL8'DA$ASMHA'\n         LA    R15,8+1(R15)\n         MVC   0(2,R15),=C'--'            Insert delimiter\n         LA    R15,2+1(R15)\nNPR$PNX  EQU   *\n*\n         LA    R1,FWA_RT1                 Locate beginning\n         LR    R14,R15                    Get current location\n         SR    R14,R1                     Offset = end - start\n         STC   R14,FWA_DESCO              Save description offset\n         ICM   R14,B'1111',FWA_DESC       -> Description\n         BZ    NPR$DX                     None, skip it\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R14)                  Get length of string\n         EX    R1,NPR$DM                  Move description out\n*        LA    R15,2(R1,R15)              Bump past it\nNPR$DX   EQU   *\n*\n         LA    R15,FWA_RT1+132-11-3-11-3-5-4-1\n         ICM   R14,B'1111',FWA_DATE       Get date address\n         BZ    NPDA#DATEX\n         SLR   R1,R1\n         IC    R1,DA#DATED_STRL-DA#DATED(R14)\n         BCTR  R1,0\n         EX    R1,NPR$DATM\n         LA    R15,2(R1,R15)\n         MVC   0(2,R15),=C'--'\n         LA    R15,2+1(R15)\nNPDA#DATEX EQU *\n*\n         ICM   R14,B'1111',FWA_TIME       Get date address\n         BZ    NPR$TIMEX\n         SLR   R1,R1\n         IC    R1,DA#DATED_STRL-DA#DATED(R14)\n         BCTR  R1,0\n         EX    R1,NPR$TIMM\n         LA    R15,2(R1,R15)\n         MVC   0(2,R15),=C'--'\n         LA    R15,2+1(R15)\nNPR$TIMEX EQU  *\n*\n         MVC   0(4,R15),=C'Page'          Insert text\n         LA    R15,5(R15)                 Bump past it\n         ST    R15,FWA_PGL                Save output location\nNPR$PG   EQU   *\n         L     R1,FWA_PAGECNT             Get page count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,FWA_PAGECNT             Save page count\n         CVD   R1,FWA_TIME\n         UNPK  0(4,R15),FWA_TIME+6(2)\n         OI    3(R15),C'0'\n         MVI   FWA_RT2,C' '\n         MVC   FWA_RT2+1(8-1),FWA_RT2\n*\n         TM    FWA_FLAG1,$FWA_F1RDESC     Reset description?\n         BNO   NPR$RDSSX                  No, continue\n         NI    FWA_FLAG1,255-$FWA_F1RDESC Turn off flag\n         LA    R15,FWA_RT1                Get title line address\n         SLR   R1,R1                      Clear register\n         IC    R1,FWA_DESCO               Get description offset\n         AR    R15,R1                     Locate description output\n         MVI   0(R15),C' '                Get spaces\n         MVC   1(79,R15),0(R15)           ..Propagate it\n         ICM   R14,B'1111',FWA_DESC       -> Description\n         BZ    NPR$RDSSX                  None, skip it\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R14)                  Get length of string\n         EX    R1,NPR$RDSM                Move description out\nNPR$RDSSX EQU *\n*\n         PUT   (8),FWA_RT1\n         PUT   (8),FWA_RT2\n*\nNPR$RH1  EQU   *\n         NI    FWA_FLAG1,255-$FWA_F1PRTRH Ensure that flag is off\n         TM    FWA_FLAG1,$FWA_F1NORH      No report headings?\n         BO    NPR$DETAIL                 Yes, skip report headings\n         ICM   R3,B'1111',FWA_RH1A        Locate Heading line 1\n         BZ    NPR$RH1X                   None, leave\n         LR    R15,R3                     Locate FBA byte\n         BAS   R14,NPR$INC_LC             Increment line count\n         PUT   (8),(3)                    Print record\nNPR$RH1X EQU   *\n*\n         ICM   R3,B'1111',FWA_RH2A        Locate Heading line 1\n         BZ    NPR$RH2X                   None, leave\n         LR    R15,R3                     Locate FBA byte\n         BAS   R14,NPR$INC_LC             Increment line count\n         PUT   (8),(3)                    Print record\nNPR$RH2X EQU   *\n*\n         ICM   R3,B'1111',FWA_RH3A        Locate Heading line 1\n         BZ    NPR$RH3X                   None, leave\n         LR    R15,R3                     Locate FBA byte\n         BAS   R14,NPR$INC_LC             Increment line count\n         PUT   (8),(3)                    Print record\nNPR$RH3X EQU   *\n*\n** Print detail record\n*\nNPR$DETAIL EQU *\n         L     R1,FWA_REC                 Get record count\n         LA    R1,1(R1)                   Increment by one\n         ST    R1,FWA_REC                 Save record count\n*\n         LR    R15,R7                     Locate record\n         BAS   R14,NPR$INC_LC             Increment line count\n         CLI   0(R7),C'1'                 Heading being forced?\n         BNE   NPR$D                      No, continue\n         MVI   0(R7),C' '                 Yes, already at Top-of-Page\nNPR$D    EQU   *\n         PUT   (8),(7)                    Print record\n*\n** Common exit from RAA$PRT\n*\nNPR$X    EQU   *\n         DA#LEAVE ,\nNPR$DM   MVC   0(0,R15),1(R14)            ** Executed **\nNPR$DATM MVC   0(0,R15),DA#DATED_STR-DA#DATED(R14)\nNPR$TIMM MVC   0(0,R15),DA#DATED_STR-DA#DATED(R14)\nNPR$RDSM MVC   0(0,R15),1(R14)            ** Executed **\n*\n** Increment Line count\n**\n** Input: R15 - Record to check\n*\nNPR$INC_LC EQU *\n         SLR   R1,R1                      Clear register\n         IC    R1,FWA_LINECNT             Obtain line count\n         CLI   0(15),C'+'\n         BE    NPR$ILCX\n         CLI   0(15),C'-'\n         BE    NPR$ILC3\n         CLI   0(15),C'0'\n         BE    NPR$ILC2\n         B     NPR$ILC1\nNPR$ILC3 EQU   *\n         LA    R1,1(R1)\nNPR$ILC2 EQU   *\n         LA    R1,1(R1)\nNPR$ILC1 EQU   *\n         LA    R1,1(R1)\nNPR$ILCX EQU   *\n         STC   R1,FWA_LINECNT             Save line count\n         BSM   0,R14                      Return to caller\n*\n** Literals in RAA$PRT\n*\n         LTORG ,\n         DS    0D\n         DROP  R12,R13\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Data CSECT                                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nRAA$DATA CSECT ,\n*\n** Messages\n*\nMSG1     DC    C'001I Execution begins.'\nMSG1L    EQU   *-MSG1\nMSG2     DC    C'002I Execution complete. Maximum condition code was'\nMSG2L    EQU   *-MSG2\nMSG3     DC    C'003E File could not be opened:'\nMSG3L    EQU   *-MSG3\nMSG4     DC    C'004I Number of input Assembler records read:'\nMSG4L    EQU   *-MSG4\nMSG5     DC    C'005W Block letters can not be printed, IEFSD095 is '\n         DC    C'not available'\nMSG5L    EQU   *-MSG5\nMSG6     DC    C'006W Missing verb on what appeared to be a '\n         DC    C'DA$ASMHA assembler comment on record'\nMSG6L    EQU   *-MSG6\nMSG7     DC    C'007I Processing '\nMSG7L    EQU   *-MSG7\nMSG8     DC    C'008I Assembler RC='\nMSG8L    EQU   *-MSG8\nMSG9     DC    C'009I Control Statement:'\nMSG9L    EQU   *-MSG9\nMSG10    DC    C'010E Unbalanced quotes found on record'\nMSG10L   EQU   *-MSG10\nMSG11    DC    C'011I Processing input DSN='\nMSG11L   EQU   *-MSG11\nMSG12    DC    C'012E Missing required DDNAME='\nMSG12L   EQU   *-MSG12\nMSG13    DC    C'013E Invalid DA$ASMHA comment directive verb on '\n         DC    C'record'\nMSG13L   EQU   *-MSG13\nMSG14    DC    C'014E Invalid or missing operand for verb='\nMSG14L   EQU   *-MSG14\nMSG15    DC    C'015E DSECT header table has overflowed'\nMSG15L   EQU   *-MSG15\nMSG16    DC    C'016W DSECT header entry ignored, no room in table '\n         DC    C'on record'\nMSG16L   EQU   *-MSG16\nMSG17    DC    C'017W > The label area overflowed'\nMSG17L   EQU   *-MSG17\nMSG18    DC    C'018I The maximum label overflow length was'\nMSG18L   EQU   *-MSG18\n*\nMSG20    DC    C'020I Data Area Handbooks were generated for'\nMSG20L   EQU   *-MSG20\n*\nMSG98    DC    C'098E Maximum WTO records printed, '\n         DC    C'S0C1 ABEND scheduled'\nMSG98L   EQU   *-MSG98\nMSG99    DC    C'099E Program needed for execution could not be '\n         DC    C'loaded, Name='\nMSG99L   EQU   *-MSG99\nMSG105   DC    C'105I Parameter:'\nMSG105L  EQU   *-MSG105\nMSG106   DC    C'106I'\nMSG106L  EQU   *-MSG106\nMSG107   DC    C'107E Number of parameters in error='\nMSG107L  EQU   *-MSG107\n*\nMSGP3XX  DC   C'IEV$P3 ** Warning **'\nMSGP300  DC   C'Possible modification of low core detected'\nMSGP300L EQU  *-MSGP300\nMSGP301  DC   C'Possible branch to low core detected'\nMSGP301L EQU  *-MSGP301\nC_DASHLINE DC   C' ',132C'-'\nC_ATC    ATTACH EPLOC=*-*,SF=L\nC_ATCL   EQU   *-C_ATC\n*\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\nC_NUMBER DC    C'....+....1....+....2....+....3....+....4....+....5'\n         DC    C'....+....6....+....7....+....8....+....9....+....0'\n         DC    C'....+....1....+....2....+....3....+....4....+....5'\n*\n** Checks for trailing messages area\n*\nC_RLD    DC    C'                                        R'\n         DC    C'ELOCATION DICTIONARY'\nC_RLDL   EQU   *-C_RLD\nC_XREF   DC    C'                                    C'\n         DC    C'ROSS REFERENCE'\nC_XREFL  EQU   *-C_XREF\nC_DXREF  DC    C'                         D'\n         DC    C'IAGNOSTIC CROSS REFERENCE AND ASSEMBLER SUMM'\nC_DXREFL EQU   *-C_DXREF\n*\n** Some strings\n*\nC_SYSPRINT  DA#STR 'Command statements and output'\nC_SYSPRINTN DC  CL8'SYSPRINT'\nC_DHBN      DC  C'Note: The following report was created by'\nC_DHBNL     EQU *-C_DHBN\nC_DHBL1     DA#STR '  DATA'\nC_DHBL2     DA#STR 'HANDBOOK'\n*\n** Assembler H parameters\n*\n         DS    0H\nC_APDD   DC    AL2(C_APDDL)\nC_APDDS  EQU   *                          DD entries\n         DC    CL8'ASMLIN'                1\n         DC    XL8'00'                    2\n         DC    XL8'00'                    3\n         DC    CL8'ASMLIB'                4\n         DC    CL8'ASMIN'                 5\nC_APIDD  DC    CL8'ASMPRINT'              6\n         DC    CL8'ASMPUNCH'              7\n         DC    CL8'ASMUT1'                8\n         DC    XL8'00'                    9\n         DC    XL8'00'                    10\n         DC    XL8'00'                    11\n         DC    CL8'ASMTERM'               12\nC_APDDL EQU    *-C_APDDS\n*\n** Parse flags\n**\n** Note: If there is a keyword like ASM and a parameter like ASMPARM\n**       you must check for the trailing \" \" or \",\" or get conflicts\n*\nT_PFLAGS EQU   *\n  DC      AL1($PPC_F1ASM,3),CL8'ASM     ',AL2(PPC_FLAG1-WORKDS)\n  DC      AL1($PPC_F1ASM,3),CL8'ASM,    ',AL2(PPC_FLAG1-WORKDS)\n  DC AL1($PPC_F2BODYONLY,4),CL8'BODYO   ',AL2(PPC_FLAG2-WORKDS)\n  DC AL1($PPC_F2BODYONLY,7),CL8'BODYONLY',AL2(PPC_FLAG2-WORKDS)\n  DC      AL1($PPC_F2DCF,2),CL8'DCF     ',AL2(PPC_FLAG2-WORKDS)\n  DC   AL1($PPC_F1DEBUGS,5),CL8'DEBUGS  ',AL2(PPC_FLAG1-WORKDS)\n  DC   AL1($PPC_F1DEBUGF,5),CL8'DEBUGF  ',AL2(PPC_FLAG1-WORKDS)\n  DC   AL1($PPC_F1NOLOGO,5),CL8'NOLOGO  ',AL2(PPC_FLAG1-WORKDS)\n  DC  AL1($PPC_F1NOCDASH,6),CL8'NOCDASH ',AL2(PPC_FLAG1-WORKDS)\n  DC     AL1($PPC_F2NBOX,3),CL8'NOBOX   ',AL2(PPC_FLAG2-WORKDS)\n  DC  AL1($PPC_F1RSEQNUM,7),CL8'REMOVESQ',AL2(PPC_FLAG1-WORKDS)\n  DC   AL1($PPC_F1STRIPC,5),CL8'STRIPCHG',AL2(PPC_FLAG1-WORKDS)\nT_PFLAGSN EQU   (*-T_PFLAGS)/TPFL\n*\n** Comment directive verb table\n*\nT_COMDIR EQU   *\n         DC    AL1(0,4),CL8'SNAME   ',AL2(RAR$DC_SNAME-DA$ASMHA)\n         DC    AL1(0,4),CL8'ENAME   ',AL2(RAR$DC_ENAME-DA$ASMHA)\n         DC    AL1(0,5),CL8'DSECTH  ',AL2(RAR$DC_DSECTH-DA$ASMHA)\nT_COMDIRN EQU  (*-T_COMDIR)/TDCL\n*\n** HEX TABLE FORMAT:\n**   C'0'         - CHARACTER THAT WE ARE CONVERTING\n**   B'11110000'  - FIRST NIBBLE OF BYTE\n**   B'00001111'  - LAST NIBBLE OF BYTE\n*\nT_HEX    EQU   *\n         DC    C'0',B'00000000',B'00000000'\n         DC    C'1',B'00010000',B'00000001'\n         DC    C'2',B'00100000',B'00000010'\n         DC    C'3',B'00110000',B'00000011'\n         DC    C'4',B'01000000',B'00000100'\n         DC    C'5',B'01010000',B'00000101'\n         DC    C'6',B'01100000',B'00000110'\n         DC    C'7',B'01110000',B'00000111'\n         DC    C'8',B'10000000',B'00001000'\n         DC    C'9',B'10010000',B'00001001'\n         DC    C'A',B'10100000',B'00001010'\n         DC    C'B',B'10110000',B'00001011'\n         DC    C'C',B'11000000',B'00001100'\n         DC    C'D',B'11010000',B'00001101'\n         DC    C'E',B'11100000',B'00001110'\n         DC    C'F',B'11110000',B'00001111'\nT_HEXE   EQU   ((*-T_HEX)/(1+1+1))\n*\n** Basic Assembler Language (BAL) statements to ignore while\n** printing Data Area Handbooks\n*\nT_BALSTMT EQU  *\n          DC   8X'00'\n          ORG  *-8\n          DC   C'USING'\n          ORG  ,\n*\n          DC   8X'00'\n          ORG  *-8\n          DC   C'CNOP'\n          ORG  ,\nT_BALSTMTN EQU *-T_BALSTMT\n*\n** End of RAA$DATA CSECT\n*\n DS 0D\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       DCF data CSECT                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nRAA$DCF  CSECT ,\n*\n** Misc stuff for DCF\n*\nRAA$DCF_ROW    DC    C':row split=yes refid=element.'\n*\n** DCF header\n*\nRAA$DCF_HEADER EQU *\n DA#STR '.DF F12 TYPE(''ITC AVANT GARDE GOTHIC '' 12) '\n DA#STR '    CODEPAGE T1GI0361'\n DA#STR '.DF F7  TYPE(''ITC AVANT GARDE GOTHIC '' 7) '\n DA#STR '    CODEPAGE T1GI0361'\nRAA$DCF_HGDOC DA#STR ':gdoc sec='\n DA#STR ':prolog.'\n DA#STR ':docprof ldrdots=yes'\n DA#STR '         layout=1'\n DA#STR '         justify=yes'\n DA#STR '         rhrfrule=bottom.'\nRAA$DCF_HSTITLE DA#STR ':title stitle='\nRAA$DCF_HTITLE  DA#STR '*'\nRAA$DCF_HDHB DA#STR 'Data Area Handbooks'\n DA#STR ':etitle.'\nRAA$DCF_HDATE DA#STR ':date.'\n DA#STR ':address.'\n DA#STR ':aline.<<Your Name here>>'\n DA#STR ':eaddress.'\n DA#STR ':eprolog.'\n DA#STR ':frontm.'\n DA#STR ':tipage.'\n DA#STR ':notices.'\n DA#STR 'This document was created using DA$ASMHA, Assembler Analysis'\n DA#STR 'program, Document Composition Facility and IBM Publishing'\n DA#STR 'Systems Bookmaster'\n DA#STR ':enotices.'\n DA#STR ':body.'\n DA#STR '.bf f7'\n DA#STR '.ll 7i'\n DA#STR '.pm .5i'\n DA#STR '.*'\n DA#STR '.** Define table'\n DA#STR '.*'\n DA#STR ':rdef id=header'\n DA#STR '      concat=yes'\nRAA$DCF_HCW1 DA#STR '      cwidths=''2* 2* 2* 2* 2* 6*'' '\n DA#STR '      align=''r r l r l l''.'\n DA#STR ':rdef id=element'\n DA#STR '      concat=yes'\nRAA$DCF_HCW2 DA#STR '      cwidths=''2* 2* 2* 2* 2* 6*'' '\n DA#STR '      align=''r r l r l l''.'\n DA#STR '.*'\n DA#STR '.** Rows for this table'\n DA#STR '.*'\n DC  X'FF'\n*\n** DCF trailer\n*\nRAA$DCF_TRAILER EQU *\n DA#STR ':backm.'\n DA#STR ':index.'\n DA#STR ':egdoc.'\n DC  X'FF'\n*\n** New DSECT found\n*\nRAA$DCF_NDSECT EQU *\n DA#STR '.*'\n DA#STR '.** Create table for new DSECT'\n DA#STR '.*'\n DA#STR ':table refid=element'\n DA#STR '       width=page'\nRAA$DCF_NDBOX DA#STR '       frame=box'\n DA#STR '       split=yes.'\n DA#STR ':thd refid=header.'\n DA#STR ':c.Decimal'\n DA#STR ':c.Hex'\n DA#STR ':c.Type'\n DA#STR ':c.Length'\n DA#STR ':c.Name'\n DA#STR ':c.Description'\n DA#STR ':ethd.'\n DC  X'FF'\n DS  0D\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**              Dynamic Save Area                                    **\n***                                                                 ***\n***********************************************************************\n                SPACE 2\nWORKDS          DSECT ,\nWORKRSA         DS    18F                Register Save Area\nSUBRSA          DS    18F                Register Save Area for subs\nR1SAVE          DS    F                  R1 at entry (parameter)\nDOUBLE          DS    D                  Double word\nDOUBLE2         DS    2D                 Double work (2)\nPARMLIST        DS    256X               Parameter List for calls\n                DS    0F                 Entry Point\nEP_DA$DATE      DS    F                  ..DA$DATE\nEP_DA$MXD       DS    F                  ..DA#MXD\n*                                         Print_DCF_Strings\nPDS_RA          DS    F                   ..Return address\nPDS_REGS        DS    2F                  ..Saved registers\n                DS    0F                 Parse_Parameter_Card\nPPC_COL         DS    H                  ..Column in error\nPPC_NUM         DS    H                  ..Number of errors\nPPC_NAMEL       DS    F                  ..Name length of DHBs\nPPC_ADDR        DS    F                  ..Address\nPPC_FLAG1       DS    B'00000000'        ..Flag 1\n$PPC_F1DEBUGF   EQU   B'11000000'          ..Debug Full?\n$PPC_F1DEBUGS   EQU   B'01000000'          ..Debug Short?\n$PPC_F1RSEQNUM  EQU   B'00100000'          ..Remove Sequence Numbers?\n$PPC_F1STRIPC   EQU   B'00010000'          ..Ignore Change status?\n$PPC_F1NOLOGO   EQU   B'00001000'          ..No logo?\n$PPC_F1NOCDASH  EQU   B'00000100'          ..No leading comment dash?\n$PPC_F1ADDR     EQU   B'00000010'          ..Address mode\n$PPC_F1ASM      EQU   B'00000001'          ..Assemble?\nPPC_FLAG2       DS    B'00000000'        ..Flag 2\n$PPC_F2DCF      EQU   B'10000000'          ..Document Comp. Fac.?\n$PPC_F2BODYONLY EQU   B'11000000'          ..DCF Body only?\n$PPC_F2NBOX     EQU   B'00100000'          ..No box on DCF table?\nPPC_CCC         DS    C'!'               ..Comment Control Character\n*\nPPC_ASMPARM     DS    CL120'xxPARMS'     ..Assembler parameters\nPPC_TITLE       DS    CL65'xTitle...'    ..Title\n                DS    0F                 OPEN_FILE_WORK_AREA\nOFWA_RA         DS    F                  ..Return address\n                DS    0F                 Check_Open\nCO_OPENC        DS    F                  ..ABEND code from OPEN\n                DS    0F                 Read_Assembler_Record\nRAR_IDD         DS    CL8'SYSUT1'        ..Input DDNAME\nRAR_CNTIREC     DS    F                  ..Input Record count\nRAR_CNTREMARK   DS    F                  ..Remark count\nRAR_CNTCOMMENT  DS    F                  ..Comment line count\nRAR_CSECT       DS    CL8                ..CSECT\nRAR_SNAME       DS    CL64               ..Start Label\nRAR_ENAME       DS    CL64               ..End Label\n                DS    0F                 ..Line Overflow\nRAR_LOVER       DS    F                    ..Count\nRAR_LOVERR      DS    F                    ..MSG17 Return Address\nRAR_LOVERLC     DS    H                    ..Max length (Current)\nRAR_LOVERLT     DS    H                    ..Max length (Total)\n*\nRAR_FLAG1       DS    B'00000000'        ..Flag 1\n$RARF1_DSECT    EQU   B'10000000'          ..DSECT mode?\n$RARF1_CSECT    EQU   B'01000000'          ..CSECT mode?\n$RARF1_DATA     EQU   B'00100000'          ..Data line?\n$RARF1_ADDRC    EQU   B'00010000'          ..PASS3 Address?\n$RARF1_ADDRE    EQU   B'00001000'          ..PASS3 Address stopped?\n$RARF1_NPROC    EQU   B'00000100'          ..Not processing now?\n$RARF1_SNAME    EQU   B'00000010'          ..Just did Start Name?\n$RARF1_ENAME    EQU   B'00000001'          ..Just did End Name?\nRAR_FLAG2       DS    B'00000000'        ..Flag 2\n$RARF2_TRAILER  EQU   B'10000000'          ..Trailer record?\n*\nRAR_TYPE        DS    X                  ..Type of record\n$RART_DATA      EQU   1                    ..Data (instruction)\n$RART_DATAC     EQU   2                    ..Data (comment)\n$RART_TITLE     EQU   3                    ..Title\n$RART_HEADING   EQU   4                    ..Heading\n$RART_IEVMSG    EQU   5                    ..IEVxxx message\n                DS    0F                 ..Data Parse\nRAR_DPNAMEA     DS    F                    ..Name address\nRAR_DPOPTA      DS    F                    ..Operation address\nRAR_DPOPRA      DS    F                    ..Operand address\nRAR_DPREMARKA   DS    F                    ..Remark address\n*\nRAR_DPI         EQU   *\nRAR_DPNAME      DS    CL64                 ..Name\nRAR_DPOPT       DS    CL64                 ..Operation\nRAR_DPOPR       DS    CL256                ..Operand\nRAR_DPADDR2CP   DS    CL3                  ..Address 2 (prefix)\nRAR_DPADDR2C    DS    CL5                  ..Address 2\nRAR_DPADDR2X    DS    XL4                  ..Address 2 (Hex value)\nRAR_DPLOCCP     DS    CL2                  ..Location (character)\nRAR_DPLOCC      DS    CL6                  ..Location (character)\nRAR_DPLOCX      DS    XL4                  ..Location (hex value)\nRAR_DPNAMEL     DS    H                    ..Name length\nRAR_DPOPTL      DS    H                    ..Operation length\nRAR_DPOPRL      DS    H                    ..Operand length\nRAR_DPREMARKL   DS    H                    ..Remark length\n*\nRAR_DPFLAG1     DS    B'00000000'          ..Flag 1\n$RARDPF1_CONT   EQU   B'10000000'            ..Current line cont?\n$RARDPF1_PCONT  EQU   B'01000000'            ..Prev. line continued?\n$RARDPF1_QUOTE  EQU   B'00100000'            ..Quote mode?\n$RARDPF1_OPERAND EQU  B'00010000'            ..Operand?\nRAR_DPIL        EQU   *-RAR_DPI\n                DS    0F                  ..Data comment\nRAR_DCDSECTH    DS    2F                    ..Area length and address\nRAR_DCDSECTHC   DS    F                     ..Area current loc\nRAR_DCVERB      DS    XL(L'TDC_VERB)        ..Verb\nRAR_DCREGS      DS    2F                    ..Addr, Len of dir\n                DS    0F                  ..Data-HandBook\nRAR_DHB_DREC    DS    CL133                 ..DCF record\nRAR_DHB_PREC    DS    CL133                 ..Previous Record\nRAR_DHB_POPT    DS    CL8                   ..Previous Operation\n                DS    0F\nRAR_DHB_DESCL   DS    F                     ..Description length\nRAR_DHB_PPRRA   DS    F\nRAR_DHB_PLOCX   DS    F                     ..Previous location hex\nRAR_DHB_DSECTC  DS    F                     ..DSECT count\nRAR_DHB_RA      DS    F                     ..Return address\nRAR_DHB_DESC    DS    XL(C_DAHANDBKDL)      ..Description area\nRAR_DHB_DESCC   DS    CL63                  ..DSECT name\n                DS    0F                  ..Source\nRAR_SRC_RA      DS    F                     ..Return address\nRAR_SRC_REC     DS    CL133                 ..Record\nRAR_SRC_DPFLAG1 DS    X                     ..Save of RAR_DPFLAG1\n*                                         ..Pass3\nRAR_P3_RA       DS    F                     ..Return Address\nRAR_P3PLOC      DS    CL6                   ..Return Address\n*\nRECOUT          DS    CL133               Output record location\n                DS    CL133               Slack if we get carried away\nDAHANDBK_RH1    DS    CL133               Output record location\nDAHANDBK_RH2    DS    CL133               Output record location\n*\nINDEX_AREA      DS    2F                  Index storage area\n                DS    0F                  Block Letters:\nBL_LEN          DS    F                   ..Length\nBL_ADDR         DS    F                   ..Address\nBL_LINEC        DS    F                   ..Line Count\nBL_RA           DS    F                   ..Return Address\n                DS    0H                  Global Execution stuff\nX_FLAG1         DS    B'00000000'         ..Flag 1\n$XF1_REPORT     EQU   B'10000000'         ..REPORT file?\n$XF1_PASS3      EQU   B'01000000'         ..PASS3 file?\n$XF1_INDEX      EQU   B'00100000'         ..Index file?\n$XF1_SRC        EQU   B'00010000'         ..Source file?\n$XF1_DHB        EQU   B'00001000'         ..Data Area HandBook?\n$XF1_DSECTHO    EQU   B'00000100'         ..DSECT Header table overflw?\n$XF1_RHPROC     EQU   B'00000010'         ..Processed Report headings?\n$XF1_NMXD       EQU   B'00000001'         ..MXD routine is not avail?\nX_FLAG2         DS    B'00000000'         ..Flag 2\n$XF2_DDATE      EQU   B'10000000'         ..Delete DA$DATE?\n$XF2_DMXD       EQU   B'01000000'         ..Delete DA$MXD?\nX_MAXCC         DS    X                   ..Maximum condition code\nX_LASTCC        DS    X                   ..Last condition code\n                DS    0F\nX_ODGEUR11     DA#DATE DPE,OPREFIX=X_ODGEUR11,OSTR=YES,                @\n               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR\nX_OTIMES11     DA#DATE DPE,OPREFIX=X_OTIMES11,OSTR=YES,                @\n               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES\n*\n** DCBs\n*\n                DS    0D\nPASS3           DS    XL(C_DCBOL)\nPASS3_EXLST     DS    F\nSYSUT1          DS    XL(C_DCBIL)\nSYSUT1_EXLST    DS    2F\nSYSUT1_JFCB     DS    XL176\n*\n                DS    0D\nWA_FWA_SYSPRINT DS    XL(FWAL)\n                DS    0D\nWA_FWA_REPORT   DS    XL(FWAL)\n*\nRAR_DPREMARK    DS    CL1024               ..Remark\n                DS    0D\nWORKDSL         EQU   *-WORKDS            Length of WORKDS area\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Program DSECTs and equates                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Data HandBook - Report output map\n*\nDHBR         DSECT ,\nDHBR_OFFD    DS    CL8\n             DS    CL2\nDHBR_OFFX    DS    C'(0000)'\n             DS    CL3\nDHBR_TYPE    DS    CL10\n             DS    CL3\nDHBR_LEN     DS    CL8'Length'\n             DS    CL3\nDHBR_NAMET   DS    C\nDHBR_NAME    EQU   *\nDHBRL        EQU   *-DHBR\n*\n** Index output\n*\nINDEX        DSECT ,\nINDEX_NUM    DS    CL4\n             DS    C\nINDEX_NAME   DS    CL50\nINDEX_PAGE   DS    CL12\n             DS    0D\nINDEXL       EQU   *-INDEX\n*\n** Index Area\n*\nINDEXA          DSECT ,\nINDEXA_RH1      DS    CL133               Output record location\nINDEXA_RH2      DS    CL133               Output record location\nINDEXA_RECOUT   DS    CL133\n                DS    0D\nINDEXA_FWA      DS    XL(FWAL)            File work area\nINDEXAL         EQU   *-INDEXA\n*\n** Assembler H SYSPRINT mapping\n*\nAHS            DSECT ,\nAHS_CC         DS    X                    Printer Control Character\nAHS_VAR        EQU   *\n*\n ORG AHS_VAR\nAHSI           EQU   *\nAHSI_IEVMSGP   DS    C'   IEV'            Message ID\nAHSI_MSG       EQU   *-3                  Locate \"IEV'\nAHSI_IEVMSGID  DS    C'000'               Message number\n               DS    C' *** '\nAHSI_TYPE      DS    C'ERROR'             Type: ERROR, MNOTE, etc\n               DS    C' ***  '\nAHSI_MSGTEXT   DS    XL(AHSI_MSGTEXTL)\nAHSI_MSGTEXTL  EQU   121-(AHSI_MSGTEXT-AHS)\nAHSI_MSGL      EQU   *-AHSI_MSG\nAHSIL          EQU   *-AHS\n ORG ,\n*\n ORG AHS_VAR\nAHST           EQU   *\nAHST_LABEL     DS    CL8                  Label from TITLE statement\n               DS    C\nAHST_TITLE     DS    CL100                Operand from TITLE statement\n               DS    CL2\nAHST_PAGELIT   DS    C'PAGE'              Page literal\nAHST_PAGENUM   DS    C'    1'             Page Number\nAHSTL          EQU   *-AHS\n ORG ,\n*\n ORG AHS_VAR\nAHSH           EQU   *\n               DS    C'  '\nAHSH_LOC       DS    C'LOC  '\n               DS    C\nAHSH_OBJECT    DS    C'OBJECT CODE    '\nAHSH_ADDR      DS    C'ADDR1 ADDR2 '\nAHSH_STMT      DS    C' STMT  '\nAHSH_SOURCE    DS    C'SOURCE STATEMENT '\nAHSH_BLANKS    DS    CL36\nAHSH_ASMNLIT   DS    C'ASM '\nAHSH_ASMNVAL   DS    C'H '\nAHSH_ASMVLIT   DS    C'V '\nAHSH_ASMVVAL   DS    C'02 '\nAHSH_TIME      DS    C'HH.MM '\nAHSH_SRCL      EQU   *-AHSH_SOURCE\nAHSH_DATE      DS    C'MM/DD/YY'\nAHSHL          EQU   *-AHS\n ORG ,\n*\n ORG AHS_VAR\nAHSD           EQU   *\nAHSD_LOC       DS    CL6\n               DS    C\nAHSD_OBJ1      DS    CL4\n               DS    C\nAHSD_OBJ2      DS    CL4\n               DS    C\nAHSD_OBJ3      DS    CL4\n               DS    C\nAHSD_ADDR1     DS    CL5\n               DS    C\nAHSD_ADDR2     DS    CL5\n               DS    C\nAHSD_STMT      DS    CL5\nAHSD_MACEXP    DS    C\nAHSD_SOURCE    DS    CL71\nAHSD_CONT      DS    CL1\nAHSD_SEQNUM    DS    CL8\nAHSL           EQU   *-AHS\n ORG\n*\n** Table - Operand Type mapping\n*\nTOPRT          DSECT ,\nTOPRT_VAL      DS    C\nTOPRT_NAME     DS    CL10\nTOPRTL         EQU   *-TOPRT\n*\n** File Work Area\n*\nFWA            DSECT ,\nFWA_RSA        DS    18F                  Register Save Area\nFWA_STRTLIT    DS    CL4'FWA '            Literal (for debugging)\nFWA_DDNAME     DS    CL8                  DDNAME (for debugging)\nFWA_LENGTH     DS    F                    Length of this area\nFWA_INIT       EQU   *                    Initialize area:\nFWA_TIME       DS    F                    DA$DATE Time address\nFWA_DATE       DS    F                    DA$DATE Date address\nFWA_DESC       DS    F                    Description string address\nFWA_PAGECNT    DS    F                    Page Count\nFWA_RH1A       DS    F                    Heading line 1 or zero\nFWA_RH2A       DS    F                    Heading line 2 or zero\nFWA_RH3A       DS    F                    Heading line 2 or zero\nFWA_PGL        DS    F                    Place to put page number\nFWA_REC        DS    F                    Number of detail records\nFWA_FLAG1      DS    B'00000000'          Flag 1\n$FWA_F1BLKLINE EQU   B'10000000'          ..Last record a blank line\n$FWA_F1RDESC   EQU   B'01000000'          ..Reset Description str?\n$FWA_F1NORH    EQU   B'00100000'          ..No report heading?\n$FWA_F1PRTRH   EQU   B'00010000'          ..Do report heading?\nFWA_DESCO      DS    X                    Description offset\nFWA_INITL      EQU   *-FWA_INIT           Length to initialize\nFWA_LINECNT    DS    X                    Line Count on page\n*\nFWA_RT1        DS    CL133                Title line 1\nFWA_RT2        DS    CL133                Title line 2\n               DS    0F\nFWA_EXLST      DS    F                    Exit list\nFWA_DCBLIT     DS    C'DCB '              Exit list\nFWA_DCB        DS    XL(C_DCBOL)          DCB area\nFWA_ENDLIT     DS    C'FWA END '          Exit list\n               DS    0D\nFWAL           EQU   *-FWA\n*\n** Map RAR_DCDSECTH entries\n*\nDSH           DSECT ,\nDSH_NAME      DS    CL63                  DSECT name\nDSH_DCFCODE   DS    CL69                  DCF code\nDSHL          EQU   *-DSH\n*\n** Table of comment directives mapping\n*\nTDC           DSECT ,\n              DS    X                     Reserved (alignment)\nTDC_VERBL     DS    X                     Verb length\nTDC_VERB      DS    CL8'verb'             Verb\nTDC_ROUTINE   DS    XL2                   Routine address\nTDCL          EQU   *-TDC                 Flag value\n*\n** T_PFLAG mapping\n*\nTPF           DSECT ,\nTPF_FLAG      DS    X                     Flag value\nTPF_NAMEL     DS    X                     Name length\nTPF_NAME      DS    CL8                   Name value\nTPF_OFFSET    DS    XL2                   Offset to field in WORKDS\nTPFL          EQU   *-TPF\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       DSECTs                                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA           Data Control Block\n         IEFJFCBN LIST=YES                Job File Control Block\n         DA#DATE ,                        Date routine\n         DA#MXD ,                         Hex Dump routine\n         END\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Linkage editor cards - ASM.PARM='BATCH,...'                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n PUNCH ' ENTRY   DA$ASMHA          '      Entry point\n PUNCH ' INCLUDE AOSB0(IEFSD095)   '      Subroutine: block letters\n PUNCH ' INCLUDE SYSLMOD(DA$DATE)  '      Subroutine: Date routine\n PUNCH ' INCLUDE SYSLMOD(DA$MXD)   '      Subroutine: Mini-Hex-Dump\n PUNCH ' NAME    DA$ASMHA(R)       '      Name of load module\n         END ,\n./ ADD NAME=DA$BRODC 0100-01266-01266-1821-01672-01672-00000-DAVE\nDA$BRODC  TITLE  'SYS1.BRODCAST analysis'\n***********************************************************************\n***\n** Name:  DA$BRODC\n**\n** Author = David Alcock :: dave@planetmvs.com\n**\n** Purpose = Report on usage of SYS1.BRODCAST\n**\n**           Optionally: Can put all messages for a given user to\n**           a //IEBUPDTE file to be used by the LOSTMAIL exec when\n**           you are reformatting SYS1.BRODCAST.  See member X$BRODC\n**           for sample job to save SYS1.BRODCAST mail and member\n**           Y$BRODC for LOSTMAIL rexx exec.\n**\n** Attributes: Reentrant, non-authorized\n**\n** Requirements: Assembler H or higher\n**\n** Non-IBM macros:\n** - DA#ENTER...Entry housekeeping\n** - DA#LEAVE...Exit  housekeeping\n** - DA#SMODE...Change addressing modes\n** - DA#EYEC....Generate module eyecatcher (invoked by DA#ENTER)\n**              which generates these fields:\n**              - DA$BRODC_ECNAME - \"DA$BRODC\"\n**              - DA$BRODC_ECDATE - Date of assembly: 06-MAR-1962\n**              - DA$BRODC_ECTIME - Time of assembly: 19:02\n** - DA#REGS....Equate Registers (invoked by DA#ENTER)\n**\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**\n** ACF2 LIDS support:\n**\n**   To use the ACF2 maclib, set the &ACF2 var to 1\n**\n**   Even if you don't have ACF2 or have access to it's sequential\n**   LIDS file, you could create a variable block file with just\n**   these fields:\n**\n**   - Standard VB RDW\n**   - USERID for 8 bytes\n**   - Filler for 4 bytes\n**   - User's name for 20 bytes\n**   - Phone number (or other info here) for at least 12 bytes\n**\n**   Associating a user name and phone number with a userid makes\n**   the index file more usable.\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**\n** Sample JCL:\n**\n**   //JUSTDOIT EXEC PGM=DA$BRODC\n**   //SYSPRINT DD SYSOUT=*\n**   //MAIL     DD SYSOUT=*\n**   //INDEX    DD SYSOUT=*\n**   //BRODCAST DD DISP=SHR,DSN=SYS1.BRODCAST\n**   //BKLIDS   DD DISP=SHR,DSN=ACF.PRI.BKLIDS  ** optional **\n**   //IEBUPDTE DD SYSOUT=* -or- to a file      ** optional **\n***\n***********************************************************************\n         SPACE 2\n&DAVER   SETC  '1.4'\n***********************************************************************\n***\n**           M o d i f i c a t i o n   H i s t o r y\n**\n** Person     Date        Ver Description\n** ---------- ----------- --- -----------------------------------------\n** DGAlcock   02-JAN-1999 1.4 Packaged for Internet distribution;\n** DGAlcock   19-FEB-1994 1.3 Added optional IEBUPDTE file\n**                            for writing mail to file for easy\n**                            loading into a PDS; Renamed from\n**                            BRODSCAN to DA$BRODC;\n** DGAlcock   15-SEP-1994 1.2 Added optional BKLIDS dataset for\n**                            getting programmer name from the ACF2\n**                            BKLIDS file;\n** DGAlcock   10-AUG-1994 1.1 Added message about top message\n**                            user; Divisional/company totals;\n**                            Message type Totals; Threshold on INDEX\n**                            output added; Added percentages;\n** DGAlcock   05-SEP-1986 1.0 Initial program written;\n***\n***********************************************************************\n         EJECT\n*\n** Globals\n*\n         GBLB  &ACF2\n         GBLC  &BCINDEX\n&BCINDEX SETC  '10'\n#BCINDEX EQU   10\n#BKUSERS EQU   20000                        Number of BKLIDS records\n&ACF2    SETB  0                            1=Use_ACF2_Macro 0=Don't\n         EJECT ,\nDA$BRODC DA#ENTER 'V&DAVER Utility: SYS1.BRODCAST usage reporting',    @\n               RENT=YES,                    We want getmained area     @\n               LV=DSAL,                     Length of getmained area   @\n               BASE=(12,11)                 Base registers\n         USING DSA,R13                      Addressability to work area\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Initialization                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         MVC   DSA_LIT1(8),DA$BRODC_ECNAME\n         MVC   DSA_LIT2(8),=CL8'DSA'\n         MVC   FLAG_LIT(4),=C'FLAG'       Set for dumps\n*\n** Obtain storage for division/company tables and initialize them\n*\n         LA    R6,256                     Number of possible characters\n         MH    R6,=H'4'                   Each entry in table\n         LA    R6,8(R6)                   Add length of eyecatcher\n         LR    R0,R6                      Save length of table\n         GETMAIN RU,LV=(0)                Obtain storage\n         STM   R0,R1,X_CUSERS             Save length and address\n         LR    R14,R1                     To: Address\n         LR    R15,R6                     To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         L     R1,X_CUSERS+4              Get address of table\n         MVC   0(8,R1),=CL8'CO-USERS'     Eyecatcher for dump reading\n*\n         LR    R0,R6                      Get length\n         GETMAIN RU,LV=(0)                Obtain storage\n         STM   R0,R1,X_CMSGS              Save length and address\n         LR    R14,R1                     To: Address\n         LR    R15,R6                     To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         L     R1,X_CMSGS+4               Get address of table\n         MVC   0(8,R1),=CL8'CO-MSGS'      Eyecatcher for dump reading\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Open files                                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Open SYSPRINT file\n*\n         LA    R3,SYSPRINT                LOCATE WRKFILE1 DCB WORK AREA\n         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'\n*\n         LA    R15,SYSPRINT_EXLST         LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,SYSPRINT_EXLST          PUT INTO EXLST\n         OI    SYSPRINT_EXLST,X'11'       <- DCB EXIT\n         OI    SYSPRINT_EXLST,X'80'       <- END OF LIST\n         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE\n*\n         LA    R1,133                     LRECL=133\n         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL\n         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST\n         OPEN  ((3),(OUTPUT)),                                         @\n               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB\n         BAS   R9,CHECK_OPEN              CHECK OPEN\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG1L,R15),MSG1\n         LA    R15,MSG1L+1(R15)\n         MVC   0(7,R15),=C'started'\n         LA    R15,8(R15)\n         MVC   0(MSG1ASML,R15),MSG1ASM\n         LA    R15,MSG1ASML+1(R15)\n         MVC   0(L'DA$BRODC_ECDATE,R15),DA$BRODC_ECDATE\n         LA    R15,L'DA$BRODC_ECDATE+1(R15)\n         MVC   0(L'DA$BRODC_ECTIME,R15),DA$BRODC_ECTIME\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         BAS   R9,PRINT_SYSPRINT_RECORD\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG3L,R15),MSG3\n         BAS   R9,PRINT_SYSPRINT_RECORD\n*\n** Open mail file for actual mail data\n*\n         LA    R3,MAIL                    LOCATE WRKFILE1 DCB WORK AREA\n         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'MAIL'\n*\n         LA    R15,MAIL_EXLST             LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,MAIL_EXLST              PUT INTO EXLST\n         OI    MAIL_EXLST,X'11'           <- DCB EXIT\n         OI    MAIL_EXLST,X'80'           <- END OF LIST\n         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE\n*\n         LA    R1,133                     LRECL=133\n         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL\n         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST\n         OPEN  ((3),(OUTPUT)),                                         @\n               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB\n         BAS   R9,CHECK_OPEN              CHECK OPEN\n*\n** Open index file\n*\n         LA    R3,INDEX                   LOCATE WRKFILE1 DCB WORK AREA\n         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'INDEX'\n*\n         LA    R15,INDEX_EXLST            LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,INDEX_EXLST             PUT INTO EXLST\n         OI    INDEX_EXLST,X'11'          <- DCB EXIT\n         OI    INDEX_EXLST,X'80'          <- END OF LIST\n         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE\n*\n         LA    R1,133                     LRECL=133\n         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL\n         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST\n         OPEN  ((3),(OUTPUT)),                                         @\n               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB\n         BAS   R9,CHECK_OPEN              CHECK OPEN\n*\n** Open input file\n*\n         MVC   BRODCAST_DECB(C_DECBL),C_DECB Initialize DECB\n*\n         LA    R3,BRODCAST                Locate DCB\n         MVC   0(C_DCBFIL,R3),C_DCBFI     COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'BRODCAST'\n*\n         LA    R15,BRODCAST_EXLST         LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,BRODCAST_EXLST          PUT INTO EXLST\n         OI    BRODCAST_EXLST,X'11'       <- DCB EXIT\n         OI    BRODCAST_EXLST,X'80'       <- END OF LIST\n         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE\n*\n         LA    R1,E$OPENS                 LOCATE SYNAD ERROR\n         STCM  R1,B'0111',DCBSYNAD-IHADCB+1(R3) INSERT INTO DCB\n*\n         MVC   PARMLIST(C_LSTIL),C_LSTI   COPY IN OPEN PARM LIST\n         OPEN  ((3),(INPUT)),                                          @\n               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB\n         BAS   R9,CHECK_OPEN              CHECK OPEN\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Open optional IEBUPDTE file                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nOPEN_IEBUPDTE_FILE EQU *\n*\n** Is the file allocated in the JCL?\n*\n         DEVTYPE =CL8'IEBUPDTE',DOUBLE\n         LTR   R15,R15\n         BNZ   OIF$X\n*\n** Open the file for output\n*\n         LA    R3,IEBUPDTE                LOCATE WRKFILE1 DCB WORK AREA\n         MVC   0(C_DCBOL,R3),C_DCBO       COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'IEBUPDTE'\n*\n         LA    R15,IEBUPDTE_EXLST         LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,IEBUPDTE_EXLST          PUT INTO EXLST\n         OI    IEBUPDTE_EXLST,X'11'       <- DCB EXIT\n         OI    IEBUPDTE_EXLST,X'80'       <- END OF LIST\n         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE\n*\n         LA    R1,80                      LRECL=80\n         STH   R1,DCBLRECL-IHADCB(R3)     SAVE LRECL\n         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST\n         OPEN  ((3),(OUTPUT)),                                         @\n               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB\n         BAS   R9,CHECK_OPEN              CHECK OPEN\n         OI    FLAG1,$F1_IEBUPDTE         Turn on flag\n*\n         BAS   R9,FORMAT_MESSAGE          Format message\n         MVC   0(MSG13L,R15),MSG13        Move in message text\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print record\n*\n** Common exit from Open_IEBUPDTE_file\n*\nOIF$X    EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Open optional ACF2 BKLIDS file                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nREAD_BKLIDS_FILE EQU *\n*\n** Is the file allocated in the JCL?\n*\n         DEVTYPE =CL8'BKLIDS',DOUBLE\n         LTR   R15,R15\n         BNZ   RBF$X\n*\n** open the file for input\n*\n         LA    R3,BKLIDS                  LOCATE WRKFILE1 DCB WORK AREA\n         MVC   0(C_DCBIL,R3),C_DCBI       COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'BKLIDS'\n*\n         LA    R15,BKLIDS_EXLST           LOCATE OUR EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,E$OPENA                 LOCATE OUR DCB ABEND ROUTINE\n         ST    R1,BKLIDS_EXLST            PUT INTO EXLST\n         OI    SYSPRINT_EXLST,X'11'       <- DCB EXIT\n         OI    SYSPRINT_EXLST,X'80'       <- END OF LIST\n         XC    CO_CODE(4),CO_CODE         CLEAR OPEN-ABEND CODE\n*\n         LA    R2,RBF$EOF                 Locate End-of-File\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n*\n         MVC   PARMLIST(C_LSTIL),C_LSTI   COPY IN OPEN PARM LIST\n         OPEN  ((3),(INPUT)),                                          @\n               MF=(E,PARMLIST)            OPEN WRKFILE1 DCB\n         BAS   R9,CHECK_OPEN              CHECK OPEN\n*\n         L     R1,C_BKUSRC                Get number to read in\n         MH    R1,=AL2(BKLEL)             Get number to read in\n         LA    R1,BKLHL(R1)               Add for header\n         LR    R0,R1\n         GETMAIN RU,LV=(0),LOC=(ANY,ANY)  Obtain storage\n         STM   R0,R1,RBF_VS               Save length and address\n         LR    R8,R1                      Get start of table\n         DA#SMODE 31                      Get into 31 bit mode\n         MVC   BKLH_ID-BKLH(8,R8),=CL8'BKLIDST'\n         LA    R8,BKLHL(R8)               Start of entries\n         L     R9,C_BKUSRC                Set number of users\n         SLR   R6,R6                      Get number used\n*\n** Read records\n*\nRBF$RR   EQU   *\n         DA#SMODE 24                      Get into 24 bit mode\n         GET   BKLIDS\n         LR    R7,R1                      Save address\n         DA#SMODE 31                      Get into 31 bit mode\n         MVC   BKLE_USER-BKLE(L'LIDLID,R8),LIDLID-LIDREC+4(R7)\n         MVC   BKLE_NAME-BKLE(L'LIDNAME,R8),LIDNAME-LIDREC+4(R7)\n         MVC   BKLE_PHONE-BKLE(L'LIDPHONE,R8),LIDPHONE-LIDREC+4(R7)\n         LA    R6,1(R6)                   Increment count\n         LA    R8,BKLEL(R8)\n         BCT   R9,RBF$RR\n*\n         DA#SMODE 24                      Get into 24 bit mode\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG12L,R15),MSG12\n         LA    R15,MSG12L+1(R15)\n         L     R1,C_BKUSRC\n         BAS   R9,EDITFWF\n         MVC   1(9,R15),=C'were used'\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         SLR   R9,R9                      Number unused is zero\n*\n** End of file on BKLids file\n*\nRBF$EOF  EQU   *\n         ST    R6,RBF_USERC               Get number users\n*\n         LA    R3,BKLIDS                  Locate DCB\n         BAS   R9,CLOSE_FILE              Close file\n*\n** Exit from Read_BKLids_File processing\n*\nRBF$X    EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process header                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Read header record\n*\n         BAS   R9,READ_RECORD\n         MVC   UI_RRUI(3),BDS_HDR_RRUI-BDS_HDR(R2) SAVE ADDR OF USERIDS\n         MVC   BM_RRN(3),BDS_HDR_RRN-BDS_HDR(R2)   SAVE ADDR OF BROD\n         L     R1,BDS_HDR_TBLKS-BDS_HDR(R2) GET NUMBER OF BLOCKS\n         ST    R1,X_TRECS                 Save count\n*\n** Print header eyecatcher\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG10L,R15),MSG10        GET MESSAGE\n         LA    R15,MSG10L(R15)            BUMP PAST MESSAGE\n         MVC   0(L'BDS_HDR_EYEC,R15),BDS_HDR_EYEC-BDS_HDR(R2)\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process BRODCAST messages (if any)                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nBRODCAST_MESSAGES EQU *\nBM$L     EQU   *\n         MVC   BRODCAST_BLKN(3),BM_RRN    GET NOTICE RELATIVE RECORD\n         BAS   R9,READ_RECORD             READ RECORD\n*\n         LA    R14,BRODCAST_DECB          LOCATE DECB\n         L     R1,DECKYADR-DECB(R14)      -> KEY ADDRESS\n         CLI   0(R1),X'00'                KEY = USERID INDEX?\n         BNE   BM$LX                      NO, LEAVE\n*\n** LOOP THROUGH NOTICES FOR THE NOTICE DIRECTORY RECORD\n*\n         MVC   BM_REC(129),0(R2)          SAVE NOTICE DIRECTORY RECORD\n         LA    R8,BM_REC                  POSITION TO BEGINNING OF REC\nBM$NL    EQU   *\n         CLI   0(R8),X'7F'                END OF THE RECORD\n         BE    BM$NLX                     YES, LEAVE\n*\n         CLI   BDS_BM_NUM-BDS_BM(R8),X'80' IS BRODCAST MESSAGE IN USE?\n         BNL   BM$NLB                     NO, MOVE ON\n*\n         MVC   BRODCAST_BLKN(3),BDS_BM_RR-BDS_BM(R8)\n         BAS   R9,READ_RECORD             READ RECORD\n*\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         LA    R15,RECOUT+1               LOCATE RECOUT\n         MVC   0(5,R15),=C'*BC*-'         BRODCAST MESSAGE\n         LA    R15,5(R15)                 BUMP PAST IT\n         SLR   R1,R1                      CLEAR REGISTER\n         ICM   R1,B'0011',BDS_BM_NUM-BDS_BM(R8) GET THE BRODCAST NUMBER\n         BAS   R9,EDITFWF                 EDIT IT\n*\n         MVC   RECOUT+9(125),1(R2)        MOVE MESSAGE TO PRINT LINE\n*        OC    RECOUT+9(125),=CL125' '    MAKE UPPERCASE\n*\n         BAS   R9,PRINT_MAIL_RECORD       PRINT LINE\nBM$NLB   EQU   *\n         LA    R8,BDS_BM_LEN(R8)          BUMP TO NEXT ENTRY\n         B     BM$NL                      NO, PROCESS NEXT ENTRY\nBM$NLX   EQU   *\n*\n** BUMP TO NEXT MESSAGE\n*\n         SLR   R1,R1                      CLEAR REGISTER\n         ICM   R1,B'0111',BM_RRN          GET RELATIVE RECORD NUMBER\n         LA    R1,1(R1)                   INCREMENT BY 1\n         STCM  R1,B'0111',BM_RRN          SAVE FOR LATER\n         B     BM$L                       DO NEXT NOTICE RECORD\n*\n** COMMON EXIT FROM BRODCAST MESSAGES PROCESSING\n*\nBM$LX    EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process USERID chains (index)                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nUI$LOOP  EQU   *\n*\n** READ RECORD\n*\n         MVC   BRODCAST_BLKN(3),UI_RRUI\n         BAS   R9,READ_RECORD\n*\n** CHECK TYPE\n*\n         LA    R14,BRODCAST_DECB          LOCATE DECB\n         L     R1,DECKYADR-DECB(R14)      -> KEY ADDRESS\n         CLI   0(R1),X'01'                KEY = USERID INDEX?\n         BNE   UI$X                       NO, LEAVE\n*\n** PRINT USERIDS\n*\n         MVC   UI_REC(129),0(R2)          SAVE RECORD FOR PROCESSING\n         LA    R7,UI_REC                  LOCATE RECORD\n         LA    R8,9                       NUMBER OF USERIDS ON RECORD\nUI$PUL   EQU   *\n         CLC   BDS_UID_NAME-BDS_UID(7,R7),=X'00,00,00,00,00,00,00'\n         BE    UI$PUB\n         BAS   R9,PRINT_USER_RECORDS      PRINT USERID RECORDS\nUI$PUB   EQU   *\n         LA    R7,BDS_UID_LEN(R7)\n         BCT   R8,UI$PUL\n*\n** ADVANCE TO NEXT USERID RECORD\n*\n         SLR   R1,R1\n         ICM   R1,B'0111',UI_RRUI         GET ADDRESS OF FIRST RECORD\n         LA    R1,1(R1)                   ITS RELATIVE TO ZERO\n         STCM  R1,B'0111',UI_RRUI         SAVE FOR READ_RECORD\n         B     UI$LOOP\n*\n** USERID LOOP EXIT\n*\nUI$X     EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       REPORT ON DATASET COMPOSITION                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nREPORT_DATASET_COMPOSITION EQU *\n         MVC   RDC_T(C_RTABL),C_RTAB      INITIALIZE TABLE\n         L     R8,X_TRECS                 Get total records in file\n         BCTR  R8,0                       SKIP FIRST RECORD\n         LA    R7,1                       START ON FIRST RECORD\nRDC$L    EQU   *\n         STCM  R7,B'0111',BRODCAST_BLKN   SAVE BLOCK NUMBER\n         BAS   R9,READ_RECORD             READ RECORD\n         LA    R14,BRODCAST_DECB          LOCATE DECB\n         L     R1,DECKYADR-DECB(R14)      -> KEY ADDRESS\n         LA    R0,C_RTABN                 NUMBER OF ENTRIES IN TABLE\n         LA    R14,RDC_T                  LOCATE TABLE\nRDC$TL   EQU   *\n         CLC   0(1,R1),RTAB_TYPE-RTAB(R14) TEST TYPE\n         BE    RDC$TLX                    FOUND, UPDATE COUNT\n         LA    R14,RTABL(R14)             BUMP TO NEXT ENTRY\n         BCT   R0,RDC$TL                  TRY IT OUT\n         L     R1,RDC_UNK                 GET UNKNOWN COUNT\n         LA    R1,1(R1)                   INCREMENT BY 1\n         ST    R1,RDC_UNK                 SAVE FOR LATER\n         LA    R14,BRODCAST_DECB          LOCATE DECB\n         L     R2,DECBAREA-DECB(R14)      LOCATE THE DATA\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG11L,R15),MSG11        GET MESSAGE\n         LA    R15,MSG11L(R15)            LOCATE PAST IT\n         LA    R14,BRODCAST_DECB          LOCATE DECB\n         L     R14,DECKYADR-DECB(R14)     -> KEY ADDRESS\n         SLR   R1,R1                      CLEAR REGISTER\n         IC    R1,0(R14)                  GET KEY TYPE\n         BAS   R9,CONHEX                  EDIT IT\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT\n*\n*        BAS   R9,DUMPREC                 DUMP RECORD\n         B     RDC$LB                     BUMP TO NEXT RECORD\nRDC$TLX  EQU   *\n         SLR   R1,R1                      CLEAR REGISTER\n         ICM   R1,B'0111',1(R14)          GET ENTRY COUNT\n         LA    R1,1(R1)                   INCREMENT BY 1\n         STCM  R1,B'0111',1(R14)          SAVE ENTRY COUNT\nRDC$LB   EQU   *\n         LA    R7,1(R7)                   BUMP RECORD COUNT\n         BCT   R8,RDC$L                   ..DO ALL RECORDS\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Termination                                                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n         TM    FLAG1,$F1_OPENE            File open error\n         BO    X$PEMSG                    Yes, continue\n*\n** Misc totals\n*\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(7,R15),=C'Trivia:'\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'Users defined-------'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         L     R1,X_UCOUNT                GET COUNT\n         BAS   R14,EDITD15                EDIT USER COUNT\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'Most messages queued'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         MVC   0(8,R15),=8C'-'\n         MVC   8(7,R15),PUR_HUSERN        Get user with the most cake\n         LA    R15,15(R15)\n*\n         SLR   R0,R0                       Clear even register\n         L     R1,PUR_HUSERC               Get count of notices\n         M     R0,=F'10000'                Magnify it\n         SLR   R0,R0                       Clear even register\n         D     R0,X_TRECS                  Calculate percentage\n         CVD   R1,DOUBLE                   Save it\n         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern\n         ED    0(7,R15),DOUBLE+5           Edit percentage\n         MVI   7(R15),C'%'                 Add suffix\n         LA    R15,7+1+2(R15)              Bump past percentage stuff\n*\n         MVC   0(8,R15),=C'Messages'      Insert text for 2nd column\n         LA    R15,8(R15)                 Bump past it\n         L     R1,PUR_HUSERC              Get message count\n         BAS   R14,EDITD15                Edit count\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'Total blocks--------'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         L     R1,X_TRECS                 Get total records in file\n         BAS   R14,EDITD15                EDIT USER COUNT\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n         L     R1,RDC_UNK                 GET UNKNOWN COUNT\n*\n** Print record totals\n*\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(14,R15),=C'Record totals:'\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n*\n         LA    R7,C_RTABN                 NUMBER OF ENTRIES IN TABLE\n         LA    R8,RDC_T                   LOCATE TABLE\nX$PRT    EQU   *\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),RTAB_TEXT-RTAB(R8) GET MESSAGE FROM TABLE\n         LA    R15,20(R15)                BUMP PAST TEXT\n*\n         CLI   RTAB_TYPE-RTAB(R8),X'03'   User records?\n         BNE   X$PRTUX                    Nope, continue\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0111',1(R8)           Save user message count\n         ST    R1,X_UMSGS                 Save number of user messages\nX$PRTUX  EQU   *\n*\n         SLR   R1,R1                      CLEAR REGISTER\n         ICM   R1,B'0111',RTAB_COUNT-RTAB(R8) GET ENTRY COUNT\n         BAS   R14,EDITD15                EDIT ENTRY COUNT\n*\n         SLR   R0,R0                      Clear even register\n         SLR   R1,R1                      Clear odd register\n         ICM   R1,B'0111',RTAB_COUNT-RTAB(R8) Get number\n         M     R0,=F'10000'               Magnify it\n         SLR   R0,R0                      Clear even register\n         D     R0,X_TRECS                 Calculate percentage\n         CVD   R1,DOUBLE                  Save it\n         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern\n         ED    0(7,R15),DOUBLE+5          Edit percentage\n         MVI   7(R15),C'%'                Add suffix\n*\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n         LA    R8,RTABL(R8)               BUMP TO NEXT ENTRY\n         BCT   R7,X$PRT                   TRY IT OUT\n*\n         ICM   R1,B'1111',RDC_UNK         Get unknown record count\n         BZ    X$UNKX                     None?\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'Unknown records-----'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         L     R1,RDC_UNK                 GET COUNT\n         BAS   R14,EDITD15                EDIT USER COUNT\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\nX$UNKX   EQU   *\n*\n** Message types\n*\n         L     R6,X_UMSGS                 Get total user message count\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(14,R15),=C'Message types:'\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'> $HASP165/Notify---'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         L     R1,PUR_$HASP165            GET COUNT\n         SR    R6,R1                      Subtract for this type\n         BAS   R14,EDITD15                EDIT USER COUNT\n         BAS   R9,PRINT_SYSPRINT_RECORD\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'> $HASP549/Mail-----'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         L     R1,PUR_$HASP549            GET COUNT\n         SR    R6,R1                      Subtract for this type\n         BAS   R14,EDITD15                EDIT USER COUNT\n         BAS   R9,PRINT_SYSPRINT_RECORD\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'> DMTAXM104I/VM-----'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         L     R1,PUR_DMTAXM104I          GET COUNT\n         SR    R6,R1                      Subtract for this type\n         BAS   R14,EDITD15                EDIT USER COUNT\n         BAS   R9,PRINT_SYSPRINT_RECORD\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'> Other-------------'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         LR    R1,R6                      GET COUNT\n         BAS   R14,EDITD15                EDIT USER COUNT\n         BAS   R9,PRINT_SYSPRINT_RECORD\n*\n** Print company/division statistics\n*\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(15,R15),=C'Company totals:'\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE\n*\n         L     R5,X_CUSERS+4              Locate table\n         LA    R5,8(R5)                   Bump past eyecatcher\n         L     R6,X_CMSGS+4               Locate table\n         LA    R6,8(R6)                   Bump past eyecatcher\n         LA    R7,C'A'                    Start with first possible\n         LR    R14,R7                     Get starting entry\n         MH    R14,=H'4'                  Calculate offset\n         AR    R5,R14                     Locate to first entry\n         AR    R6,R14                     Locate to first entry\nX$CL     EQU   *\n         ICM   R8,B'1111',0(R5)           Get count for this company\n         BZ    X$CLB\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'> _ users-----------'\n         STC   R7,2(R15)                  Save company code\n         LA    R15,20(R15)                BUMP PAST TEXT\n         LR    R1,R8                      GET COUNT\n         BAS   R14,EDITD15                Edit count\n*\n         SLR   R0,R0                       Clear even register\n         L     R1,0(R5)                    Get count of notices\n         M     R0,=F'10000'                Magnify it\n         SLR   R0,R0                       Clear even register\n         D     R0,X_TRECS                  Calculate percentage\n         CVD   R1,DOUBLE                   Save it\n         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern\n         ED    0(7,R15),DOUBLE+5           Edit percentage\n         MVI   7(R15),C'%'                 Add suffix\n         LA    R15,7+1+2(R15)\n*\n         MVC   0(8,R15),=C'Messages'      Insert text for 2nd column\n         LA    R15,8(R15)                 Bump past it\n         L     R1,0(R6)                   Get message count\n         BAS   R14,EDITD15                Edit count\n*\n         SLR   R0,R0                       Clear even register\n         L     R1,0(R6)                    Get count of notices\n         M     R0,=F'10000'                Magnify it\n         SLR   R0,R0                       Clear even register\n         D     R0,X_UCOUNT                 Calculate percentage\n         CVD   R1,DOUBLE                   Save it\n         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern\n         ED    0(7,R15),DOUBLE+5           Edit percentage\n         MVI   7(R15),C'%'                 Add suffix\n*\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\nX$CLB    EQU   *\n         LA    R5,4(R5)                   Bump to next entry\n         LA    R6,4(R6)                   Bump to next entry\n         LA    R7,1(R7)                   Bump to next company\n         CH    R7,=H'256'                 At the end of the table yet\n         BL    X$CL\n*\n         LM    R0,R1,X_CUSERS             Get table length, address\n         FREEMAIN R,LV=(0),A=(1)          Free table\n         LM    R0,R1,X_CMSGS              Get table length, address\n         FREEMAIN R,LV=(0),A=(1)          Free table\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG2L,R15),MSG2          GET MESSAGE\n         LA    R15,MSG2L+1(R15)           BUMP PAST MESSAGE\n         MVC   0(20,R15),=CL20'Total---------------'\n         LA    R15,20(R15)                BUMP PAST TEXT\n         L     R1,X_UCOUNT                GET COUNT\n         BAS   R14,EDITD15                Edit count\n         LA    R15,7+1+2(R15)             Locate past number\n         MVC   0(8,R15),=C'Messages'      Insert text for 2nd column\n         LA    R15,8(R15)                 Bump past it\n         L     R1,X_UMSGS                 Get messages\n         BAS   R14,EDITD15                Edit count\n         BAS   R9,PRINT_SYSPRINT_RECORD   Print message\n*\n** Print \"ENDED\" Message\n*\nX$PEMSG  EQU   *\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE\n         MVC   0(MSG1L,R15),MSG1\n         LA    R15,MSG1L+1(R15)\n         MVC   0(5,R15),=C'ended'\n         BAS   R9,PRINT_SYSPRINT_RECORD\n*\n** Free BKLids table (if any)\n*\n         LM    R0,R1,RBF_VS               Get table length and address\n         LTR   R0,R0                      Any table to free?\n         BZ    X$RBFX                     No, continue\n         FREEMAIN RU,LV=(0),A=(1)         Release storage\nX$RBFX   EQU   *\n*\n** Close files\n*\n         FREEDBUF BRODCAST_DECB,D,BRODCAST FREE I/O BUFFER\n         LA    R3,BRODCAST\n         BAS   R9,CLOSE_FILE\n         LA    R3,MAIL\n         BAS   R9,CLOSE_FILE\n         LA    R3,INDEX\n         BAS   R9,CLOSE_FILE\n         LA    R3,SYSPRINT\n         BAS   R9,CLOSE_FILE\n         LA    R3,IEBUPDTE\n         BAS   R9,CLOSE_FILE\n*\n** Return to caller\n*\n         DA#LEAVE ,                       Exit housekeeping\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       ERROR ROUTINES                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** FILE OPEN ERROR: INPUT: R3 - DCB\n*\nE$SYNAD  EQU   *\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE\n         MVC   0(MSG9L,R15),MSG9          GET MESSAGE\n         LA    R15,MSG9L+1(R15)           BUMP PAST MESSAGE\n         L     R1,X_RECI                  GET NUMBER\n         BAS   R9,EDITFWF                 EDIT IT\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT\n         B     EXIT\n*\n** FILE OPEN ERROR: INPUT: R3 - DCB\n*\nE$FOPEN  EQU   *\n         OI    FLAG1,$F1_OPENE\n         LR    R2,R15                     SAVE RETURN CODE\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE\n         MVC   0(MSG5L,R15),MSG5          GET MESSAGE\n         LA    R15,MSG5L(R15)             BUMP PAST MESSAGE\n         MVC   0(8,R15),DCBDDNAM-IHADCB(R3) GET DDNAME\n         LA    R0,L'DCBDDNAM              MAX LENGTH OF DDNAME\n         BAS   R14,FIRSTSPC               LOCATE FIRST SPACE\n*\n         LR    R1,R2                      GET OPEN RETURN CODE\n         LTR   R1,R1                      OPEN RC=0\n         BZ    EFO$OX                     YES, DONT PRINT RC=0\n         MVC   0(10,R15),=C', OPEN RC='   TEXT\n         LA    R15,10(R15)                BUMP PAST TEXT\n         BAS   R9,EDITFWF                 EDIT IT\n         BCTR  R15,0                      BACKUP OVER SPACE\nEFO$OX   EQU   *\n*\n         ICM   R1,B'1111',CO_CODE         GET OPEN ABEND CODE\n         BZ    EFO$CX                     NONE, MOVE ON\n         N     R1,=A(X'FFF0FF00')         TURN OFF UNNEEDED BITS\n         MVC   0(9,R15),=C', ABEND S'     TEXT\n         LA    R15,9(R15)                 BUMP PAST IT\n         ST    R1,DOUBLE                  SAVE ABEND CODE\n         UNPK  0(9,R15),DOUBLE(5)                   ---+\n         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'    | BINARY TO HEX\n         TR    0(8,R15),=C'0123456789ABCDEF'        ---+\n         MVI   3(R15),C'-'                MOVE IN DASH\n         LA    R15,6(R15)\n         MVI   0(R15),C' '\n         MVI   1(R15),C' '\nEFO$CX   EQU   *\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MSG5 ON SYSPRINT\n         B     EXIT\n*\n** DCB ABEND EXIT ROUTINE: GC26-4013 MVS/XA DATA ADMINISTRATION GUIDE\n**                         CHAPTER 7.\n*\nE$OPENA  EQU   *\n         L     R2,0(R1)                   GET ABEND CODE\n         ST    R2,CO_CODE                 SAVE ABEND CODE\n         MVI   3(R1),4                    IGNORE ABEND\n         BSM   0,R14                      RETURN TO IOS\n*\n** SYNAD ERROR ROUTINE\n*\nE$OPENS  EQU   *\n         PRINT GEN\n         STM  R12,R14,EOS_REGS\n*\n         SYNADAF ACSMETH=BDAM\n*\n         LR    R2,R13                    SAVE ADDRESS OF SAVE AREA\n         L     R13,4(R13)                RESTORE save area\n         MVC   EOS_MSG(78),50(R1)        GET MESSAGE FROM IOS\n         LR    R13,R2                    RESTORE SAVEAREA FROM SYNADAF\n*\n         SYNADRLS ,\n*\n         LM   R12,R14,EOS_REGS\n         BSM  0,R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       PRINT USERID RECORDS                                        **\n**       INPUT: R7 POINTS TO A USERID ENTRY (BDS_UID)                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPRINT_USER_RECORDS EQU *\n         ST    R9,PUR_RA                  SAVE RETURN ADDRESS\n*\n         L     R1,X_UCOUNT                GET USER COUNT\n         LA    R1,1(R1)                   INCREMENT COUNT\n         ST    R1,X_UCOUNT                SAVE USER COUNT\n*\n** Any mail for this user?\n*\n         XC    PUR_MCNT(4),PUR_MCNT       CLEAR MAIL COUNT\n         CLC   BDS_UID_FIRST-BDS_UID(3,R7),=X'00,00,00'\n         BE    PUR$LX                     ZEROS: NO MAIL FOR THIS GUY\n*\n** Locate first mail address\n*\n         MVC   BRODCAST_BLKN(3),BDS_UID_FIRST-BDS_UID(R7)\n         B     PUR$LCX                    BRANCH PAST FIRST/LAST CHECK\n*\n** LOOP THRU USERID'S MAIL\n*\nPUR$L    EQU   *\n*        CLC   BRODCAST_BLKN(3),BDS_UID_LAST-BDS_UID(R7) Last?\n*        BE    PUR$LX                     YES, LEAVE\nPUR$LCX  EQU   *\n         L     R1,PUR_MCNT                GET MAIL COUNT\n         LA    R1,1(R1)                   INCREMENT COUNT\n         ST    R1,PUR_MCNT                SAVE MAIL COUNT\n*\n         BAS   R9,READ_RECORD             READ USERID'S MAIL BY REL REC\n*\n         BAS   R14,CLEAR_RECOUT           CLEAR RECORD\n         LA    R15,RECOUT+1               LOCATE PAST FBA BYTE\n         MVC   0(7,R15),BDS_UID_NAME-BDS_UID(R7) GET USERID\n         LA    R15,8(R15)                 BUMP PAST IT\n         SLR   R1,R1                      CLEAR REGISTER\n         IC    R1,BDS_MAIL_TEXTL-BDS_MAIL(R2)   GET LENGTH OF MAIL\n         EX    R1,PUR$LMME                MOVE MAIL TO PRINT LINE\n         BAS   R9,PRINT_MAIL_RECORD       PRINT LINE\n*                                     0....+....1....+....2....+\n* Save trivia about Notify messages: \"hh.mm.ss JOB##### $HASP165\"\n*\n         CLI   BDS_MAIL_TEXT-BDS_MAIL+2(R2),C'.' Looks a JES2 message?\n         BNE   PUR$LMJX                   Nope, continue\n         CLC   BDS_MAIL_TEXT-BDS_MAIL+18(8,R2),=C'$HASP549'\n         BE    PUR$LMM                    Yes, continue\n         CLC   BDS_MAIL_TEXT-BDS_MAIL+18(8,R2),=C'$HASP165'\n         BNE   PUR$LMJX                   Nope, continue\n         L     R1,PUR_$HASP165            Get count\n         LA    R1,1(R1)                   Increment it\n         ST    R1,PUR_$HASP165            Save it\n         B     PUR$LMJX\nPUR$LMM  EQU   *\n         L     R1,PUR_$HASP549            Get count\n         LA    R1,1(R1)                   Increment it\n         ST    R1,PUR_$HASP549            Save it\n         B     PUR$LMJX\nPUR$LMJX EQU   *\n         CLI   BDS_MAIL_TEXT-BDS_MAIL+18(R2),C'D'\n         BNE   PUR$LMX\n         CLC   BDS_MAIL_TEXT-BDS_MAIL+18(10,R2),=C'DMTAXM104I'\n         BNE   PUR$LMX                    Yes, continue\n         L     R1,PUR_DMTAXM104I\n         LA    R1,1(R1)\n         ST    R1,PUR_DMTAXM104I\nPUR$LMX  EQU   *\n*\n         L     R1,X_CMSGS+4               Get address of table\n         LA    R1,8(R1)                   Bump past header\n         SLR   R14,R14                    Clear register\n         IC    R14,BDS_UID_NAME-BDS_UID(R7) Get division/co\n         MH    R14,=H'4'                  Length of each entry\n         AR    R1,R14                     Locate to fullword for comp.\n         L     R15,0(R1)                  Get company/division count\n         LA    R15,1(R15)                 Increment count by 1\n         ST    R15,0(R1)                  Save company/division count\n*\n** Any more?\n*\n         MVC   BRODCAST_BLKN(3),BDS_MAIL_NEXT-BDS_MAIL(R2) -> Mail\n         CLC   BRODCAST_BLKN(3),=X'00,00,00' ZERO?\n         BNE   PUR$L                      NO, PROCESS IT\n*\n** Print number of mail messages on index file\n*\nPUR$LX   EQU   *\n*\n         CLC   PUR_HUSERC(4),PUR_MCNT     Higher?\n         BH    PUR$IHUX                   No, continue\n         MVC   PUR_HUSERC(4),PUR_MCNT     Save new count\n         MVC   PUR_HUSERN(7),BDS_UID_NAME-BDS_UID(R7) Save user name\nPUR$IHUX EQU   *\n*\n         L     R1,X_CUSERS+4              Get address of table\n         LA    R1,8(R1)                   Bump past header\n         SLR   R14,R14                    Clear register\n         IC    R14,BDS_UID_NAME-BDS_UID(R7) Get division/co\n         MH    R14,=H'4'                  Length of each entry\n         AR    R1,R14                     Locate to fullword for comp.\n         L     R15,0(R1)                  Get company/division count\n         LA    R15,1(R15)                 Increment count by 1\n         ST    R15,0(R1)                  Save company/division count\n*\n         L     R1,PUR_MCNT                Get count\n         C     R1,=AL4(#BCINDEX)          Under threshold?\n         BL    PUR$IRX                    Yep, ignore it\n         BAS   R14,CLEAR_RECOUT\n         LA    R15,RECOUT+1\n         L     R1,PUR_MCNT\n         CVD   R1,DOUBLE                  CONVERT TO PACKED\n         MVC   0(15,R15),EDITP15          GET EDIT PATTERN\n         ED    0(15,R15),DOUBLE+2         EDIT\n         LTR   R1,R1\n         BNZ   PUR$IX\n         MVI   14(R15),C'0'\nPUR$IX   EQU   *\n         LA    R15,16(R15)\n*\n         SLR   R0,R0                       Clear even register\n         L     R1,PUR_MCNT                 Get count of notices\n         M     R0,=F'10000'                Magnify it\n         SLR   R0,R0                       Clear even register\n         D     R0,X_TRECS                  Calculate percentage\n         CVD   R1,DOUBLE                   Save it\n         MVC   0(7,R15),=X'40,20,21,20,4B,20,20' Get edit pattern\n         ED    0(7,R15),DOUBLE+5           Edit percentage\n         MVI   7(R15),C'%'                 Add suffix\n         LA    R15,9(R15)\n         MVC   0(7,R15),BDS_UID_NAME-BDS_UID(R7)\n         LA    R15,9(R15)\n*\n         ICM   R9,B'1111',RBF_VS+4         Get table address\n         BZ    PUR$IRP\n         ICM   R0,B'1111',RBF_USERC        Get user count\n         BZ    PUR$IRP\n         DA#SMODE 31                      Get into 31 bit mode\n         LA    R9,BKLHL(R9)                Bump past header\n         ICM   R0,B'1111',RBF_USERC        Get user count\nPUR$IRUL EQU   *\n         CLC   BKLE_USER-BKLE(7,R9),BDS_UID_NAME-BDS_UID(R7)\n         BE    PUR$IRUF\n         LA    R9,BKLEL(R9)\n         BCT   R0,PUR$IRUL\n         B     PUR$IRUX\nPUR$IRUF EQU   *\n         MVC   0(L'BKLE_NAME,R15),BKLE_NAME-BKLE(R9)\n         LA    R15,L'BKLE_NAME+3(R15)\n         MVC   0(6,R15),=C'Phone:'\n         MVC   7(L'BKLE_PHONE,R15),BKLE_PHONE-BKLE(R9)\nPUR$IRUX EQU   *\n         DA#SMODE 24                      Get into 24 bit mode\n*\nPUR$IRP  EQU   *\n         BAS   R9,PRINT_INDEX_RECORD\nPUR$IRX  EQU   *\n*\n** Common exit from PRINT_USER_RECORDS processing\n*\nPUR$X    EQU   *\n         L     R9,PUR_RA                  RESTORE RETURN ADDRESS\n         BSM   0,R9\n*\nPUR$LMME MVC   0(0,R15),BDS_MAIL_TEXT-BDS_MAIL(R2)  *** EXECUTED ***\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Read a record from the BRODCAST dataset                     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nREAD_RECORD EQU *\n         ST    R9,RR_RA                   SAVE RETURN ADDRESS\n*\n         L     R1,X_RECI                  GET INPUT RECORD COUNT\n         LA    R1,1(R1)                   INCREMENT RECORD COUNT\n         ST    R1,X_RECI                  SAVE INPUT RECORD COUNT\n*\n** FREE THE BUFFER (DON'T DO THE FIRST TIME THRU)\n*\n         LA    R15,1                      FIRST RECORD = 1\n         CR    R1,R15                     FIRST RECORD?\n         BE    RR$IO                      YES, MOVE ON\n         FREEDBUF BRODCAST_DECB,D,BRODCAST FREE I/O BUFFER\nRR$IO    EQU   *\n*\n** READ RECORD BY BRODCAST_BLKN\n*\n         LA    R3,BRODCAST_DECB\n         LA    R4,BRODCAST\n         LA    R5,BRODCAST_BLKN\n         READ  (3),DI,(4),'S','S','S',(5),MF=E\n         CHECK (3)\n*\n** CHECK FOR SYNAD ERRORS\n*\n         CLI   EOS_MSG,X'00'              GOT A SYNAD MESSAGE?\n         BE    RR$SNDX                    NO, MOVE ON\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE\n         MVC   0(MSG8L,R15),MSG8          GET YSLOGUTL MESSAGE\n         LA    R15,MSG8L+1(R15)           BUMP AROUND IT\n         MVC   0(78,R15),EOS_MSG          GET SYNAD ERROR MESSAGE\n         BAS   R9,PRINT_SYSPRINT_RECORD\n         B     E$SYNAD                    TURN SYNAD MESSAGE OFF\nRR$SNDX  EQU   *\n*\n** LOCATE THE RECORD\n*\n         L     R2,DECBAREA-DECB(R3)       LOCATE THE DATA\n*\n         L     R9,RR_RA                   GET RETURN ADDRESS\n         BSM   0,R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Misc internal subroutines                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Close file\n**\n** Input: R3 points to DCB\n*\nCLOSE_FILE EQU *\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?\n         BNO   CF$X\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\nCF$X     EQU   *\n         BSM   0,R9\n*\n** CHECK OPEN OF FILE\n** INPUT: R15 - OPEN RC\n**        R3  - ADDRESS OF DCB\n**        CO_CODE - ABEND CODE FROM EXLST\n*\nCHECK_OPEN EQU *\n         LTR   R15,R15                    CHECK OPEN RETURN CODE\n         BNZ   E$FOPEN                    NOT GOOD: PRINT ERROR\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN IS IT OPEN?\n         BNO   E$FOPEN                    NO, PRINT ERROR MESSAGES\n         ICM   R1,B'1111',CO_CODE         GET OPEN-ABEND CODE\n         BNZ   E$FOPEN                    YES, NO ABEND CODE...\n         BSM   0,R9\n*\n** FORMAT MESSAGE\n*\nFORMAT_MESSAGE EQU *\n         LA    R15,SYSPRINT               LOCATE GLOBAL MESSAGES DCB\n         TM    DCBOFLGS-IHADCB(R15),DCBOFOPN IS IT OPEN?\n         BO    FM$RO                      YES, FORMAT NORMAL MESSAGE\n         LA    R15,RECOUT                 LOCATE MESSAGE WORK AREA\n         MVC   0(C_WTOL,R15),C_WTO        MOVE WTO TO RECOUT\n         LA    R15,4(R15)                 BUMP PAST WTO FLAGS\n         B     FM$ROX                     MOVE PAST SYSPRINT MESSAGE\nFM$RO    EQU   *\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         LA    R15,RECOUT+1               LOCATE RECOUT\nFM$ROX   EQU   *\n         MVC   0(MSGPL,R15),MSGP          GET MESSAGE PREFIX\n         LA    R15,MSGPL(R15)             BUMP PAST MESSAGE PREFIX\n         BSM   0,R9\n*\n** POINT REGISTER 15 TO FIRST BLANK IN STRING\n** INPUT:  R0  - MAXIMUM LENGTH OF STRING\n**         R15 - STRING\n** OUTPUT: R15 - FIRST SPACE IN STRING\n*\nFIRSTSPC EQU   *\n         CLI   0(R15),C' '\n         BE    FS$EXIT\n         LA    R15,1(R15)\n         BCT   R0,FIRSTSPC\nFS$EXIT  EQU   *\n         BSM   0,R14\n*\n** CONVERT R1 TO A HEX STRING - FULL 8 BYTES\n** INPUT: R1 = NUMBER TO CONVERT\n** OUTPUT: R15 - ADDRESS TO PUT 8 BYTE LITERAL\n*\nHEXSTR8  EQU   *\n         ST    R1,DOUBLE                  SAVE NUMBER\n         UNPK  0(9,R15),DOUBLE(5)\n         MVZ   0(8,R15),=X'00,00,00,00,00,00,00,00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         MVI   0(R15),C' '\n         BSM   0,R9\n*\n** CONVERT NUMBER TO HEX STRING, IGNORE LEADING ZEROS\n** INPUT: R1 = NUMBER TO CONVERT\n** OUTPUT: R15 - PAST LAST BYTE OF HEX STRING\n*\nCONHEX   EQU   *\n         MVI   0(R15),X'7D'               INSERT TICK\n         LA    R15,1(R15)                 BUMP PAST TICK\n         ST    R1,DOUBLE                  SAVE NUMBER\n         UNPK  DOUBLE2(9),DOUBLE(5)\n         MVZ   DOUBLE2(8),=X'00,00,00,00,00,00,00,00'\n         TR    DOUBLE2(8),=C'0123456789ABCDEF'\n         LA    R0,6                       MAX SKIP OF LEADING ZEROS\n         LA    R1,8                       MAX LENGTH OF STRING\n         LA    R14,DOUBLE2                LOCATE HEX STRING\nCH$LOOP1 EQU   *\n         CLI  0(R14),C'0'                 LEADING ZERO?\n         BNE  CH$LOOP2                    NO, GET OUT OF LOOP\n         LA   R14,1(R14)                  YES, BUMP PAST THIS BOZO\n         SH   R1,=H'1'                    DECREMENT COUNTER\n         BCT  R0,CH$LOOP1                 ..TRY NEXT BYTE\nCH$LOOP2 EQU  *\n         MVC  0(1,R15),0(R14)             MOVE TO OUTPUT LOCATION\n         LA   R15,1(R15)                  BUMP UP (OUTPUT)\n         LA   R14,1(R14)                  BUMP UP (INPUT)\n         BCT  R1,CH$LOOP2                 ..GET NEXT BYTE\nCH$LOOPX EQU  *\n         MVI   0(R15),X'7D'               INSERT TICK\n         LA    R15,1(R15)                 BUMP PAST TICK\n         BSM   0,R9\n*\n**       EDIT FULLWORD (FLUSH TO R15)\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITFWF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,EDITFWFM               MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '\n         BSM   0,R9                       RETURN TO CALLER\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,2(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n** DUMP RECORD\n** INPUT: R2 - ADDRESS OF RECORD TO DUMP\n**        BRODCAST_BLKN - BLOCK ID\n*\nDUMPREC  EQU   *\n AGO .DRX\n         ST    R9,RA_DR                   SAVE RETURN ADDRESS\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG7L,R15),MSG7          GET MESSAGE\n         LA    R15,MSG7L(R15)             LOCATE PAST IT\n         SLR   R1,R1                      CLEAR REGISTER\n         ICM   R1,B'0111',BRODCAST_BLKN   GET BLOCK NUMBER\n         BAS   R9,EDITFWF                 EDIT IT\n         BCTR  R15,0                      BACKUP ONE\n         MVC   0(2,R15),=C'):'            GET SUFFIX\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT\n*\n         MVC   MXD_LEN(2),=AL2(16)        INITIALIZE MINIXDMP LENGTH\n         XC    MXD_OFF(2),MXD_OFF         INITIALIZE MINIXDMP OFFSET\n         LA    R4,8                       16 * 6 = 96\n         LR    R3,R2                      MOVE IN ADDRESS OF RECORD\nDR$L     EQU   *                               -\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG6L,R15),MSG6          GET MESSAGE\n         LA    R5,MSG6L+1(R15)            LOCATE PAST IT\n         LINK  EP=MINIXDMP,               LINK TO MINI-HEX-DUMP PGM    @\n               PARAM=(MXD_LEN,(3),(5),MXD_OFF),                        @\n               MF=(E,PARMLIST)\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT\n         LA    R3,16(R3)                  BUMP TO NEXT ENTRY\n         BCT   R4,DR$L                    ..DO IT\n*\n         BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n         MVC   0(MSG6L,R15),MSG6          GET MESSAGE\n         LA    R5,MSG6L+1(R15)            LOCATE PAST IT\n         MVC   MXD_LEN(2),=AL2(1)         INITIALIZE MINIXDMP LENGTH\n         LINK  EP=MINIXDMP,               LINK TO MINI-HEX-DUMP PGM    @\n               PARAM=(MXD_LEN,(3),(5),MXD_OFF),                        @\n               MF=(E,PARMLIST)\n         BAS   R9,PRINT_SYSPRINT_RECORD   PRINT MESSAGE ON SYSPRINT\n*\n         L     R9,RA_DR                   RESTORE RETURN ADDRESS\n.DRX ANOP ,\n         BSM   0,R9\n*\n** EDIT WITH DASHED PRECEEDING\n** INPUT: R1 - NUMBER TO EDIT\n**        R15 - WHERE TO PUT OUTPUT\n*\nEDITD15  EQU   *\n         CVD   R1,DOUBLE                  CONVERT TO PACKED\n         MVC   0(15,R15),EDITP15          GET EDIT PATTERN\n         MVI   0(15),C'-'                 LEADING DASHES\n         ED    0(15,R15),DOUBLE+2         EDIT\n         LTR   R1,R1\n         BNZ   EDITD15X\n         MVI   14(R15),C'0'\nEDITD15X EQU   *\n         LA    R15,15(R15)                BUMP PAST NUMBER\n         BSM   0,R14                      RETURN\n*\n** CLEAR RECOUT TO BLANKS\n*\nCLEAR_RECOUT EQU *\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(L'RECOUT-1),RECOUT\n         BSM   0,R14\n*\n** PRINT RECORD ON MAIL FILE\n*\nPRINT_MAIL_RECORD EQU *\n         PUT   MAIL,RECOUT\n         TM    FLAG1,$F1_IEBUPDTE         Doing IEBUPDTE?\n         BNO   PMR$X\n         CLI   RECOUT+1,C'*'              Special case?\n         BE    PMR$X                      Yes, skip it\n         CLC   RECOUT+1(7),PMR_LAST       Same guy?\n         BE    PMR$PIR                    Yes, continue\n         MVI   RECOUTS,C' '               Get blank\n         MVC   RECOUTS+1(79),RECOUTS      and propagate it\n         MVC   RECOUTS(12),=C'./ ADD NAME=' Get IEBUPDTE control card\n         MVC   RECOUTS+12(7),RECOUT+1     Get new userid\n         PUT   IEBUPDTE,RECOUTS           Put record\n         MVC   PMR_LAST(7),RECOUT+1       Save for next time\nPMR$PIR  EQU   *\n         CLI   RECOUT+9,C'.'              Conflict with IEBUPDTE?\n         BNE   PMR$PIRC\n         MVI   RECOUT+9,C'!'              Well it has a dot in it!\nPMR$PIRC EQU   *\n         PUT   IEBUPDTE,RECOUT+9          \"_USERID._msg\"\n         LA    R15,RECOUT+9+80            Bump past 80 byte record\n         CLC   0(133-80-9,R15),=CL80' '   Any more?\n         BE    PMR$X\n         SH    R15,=AL2(13)\n         MVC   0(13,R15),=C'(Continued): '\n         MVI   RECOUTS,C' '\n         MVC   RECOUTS+1(11+7),RECOUTS    Just enough...\n         PUT   IEBUPDTE,(R15)             Put out that second line\nPMR$X    EQU   *\n         BSM   0,R9\n*\n** PRINT RECORD ON index file\n*\nPRINT_INDEX_RECORD EQU *\n         PUT   INDEX,RECOUT\n         BSM   0,R9\n*\n** PRINT RECORD ON SYSPRINT FILE\n*\nPRINT_SYSPRINT_RECORD EQU *\n         LA    R1,SYSPRINT\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN IS IT OPEN?\n         BO    PRTS$FP\n         LA    R1,RECOUT                  LOCATE WTO\n         WTO   ,MF=(E,(1))                ISSUE IT\n         B     PRTS$X                     LEAVE\nPRTS$FP  EQU   *\n         PUT   SYSPRINT,RECOUT\nPRTS$X   EQU   *\n         BSM   0,R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSGP     DC    C'BRSC'\nMSGPL    EQU   *-MSGP\nMSG1     DC    C'001I System BRODCAST analyze utility'\nMSG1L    EQU   *-MSG1\nMSG1ASM  DC    C'- Assembled:'\nMSG1ASML EQU   *-MSG1ASM\nMSG2     DC    C'002I'      TRIVIA\nMSG2L    EQU   *-MSG2\nMSG3     DC    C'003I Users with more than &BCINDEX messages '\n         DC    C'will be written to the INDEX file'\nMSG3L    EQU   *-MSG3\nMSG4     DC    C'004I --'\nMSG4L    EQU   *-MSG4\nMSG5     DC    C'005E Open failed to DDNAME='\nMSG5L    EQU   *-MSG5\nMSG6     DC    C'006I'\nMSG6L    EQU   *-MSG6\nMSG7     DC    C'007I Dump of record, Block-number('\nMSG7L    EQU   *-MSG7\nMSG8     DC    C'008E SYNAD Error:'\nMSG8L    EQU   *-MSG8\nMSG9     DC    C'009E I/O Error while reading record number'\nMSG9L    EQU   *-MSG9\nMSG10    DC    C'010I'\nMSG10L   EQU   *-MSG10\nMSG11    DC    C'011W Unknown record type found, X'\nMSG11L   EQU   *-MSG11\nMSG12    DC    C'012E Overflow on BKLIDS table, only first'\nMSG12L   EQU   *-MSG12\nMSG13    DC    C'013I Writing mail records to IEBUPDTE file'\nMSG13L   EQU   *-MSG13\n*\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\n*\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\n*\n         PRINT GEN\n         DS    0D\nC_DECB   READ  C_DECBC,DI,*-*,'S','S','S',*-*,MF=L\nC_DECBL  EQU   *-C_DECB\n         PRINT NOGEN\nC_DCBFI  DCB   DDNAME=C_DCB,                                           @\n               DSORG=DA,MACRF=RISC,OPTCD=R,BLKSIZE=129,                @\n               RECFM=F,BUFNO=2,KEYLEN=1,BUFL=130\nC_DCBFIL EQU   *-C_DCBFI\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DSORG=PS,MACRF=PM,RECFM=FBA\nC_DCBOL  EQU   *-C_DCBO\nC_DCBI   DCB   DDNAME=C_DCBI,                                          @\n               DSORG=PS,MACRF=GL,EODAD=*-*,RECFM=VB\nC_DCBIL  EQU   *-C_DCBI\n         DS    0D\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\n         PRINT GEN\nC_RTAB   EQU   *\n         DC    X'00',X'00,00,00',CL20'Notice--------------'\n         DC    X'01',X'00,00,00',CL20'USERID index--------'\n         DC    X'02',X'00,00,00',CL20'BRODCAST------------'\n         DC    X'03',X'00,00,00',CL20'User message--------'\n         DC    X'04',X'00,00,00',CL20'Header--------------'\n         DC    X'05',X'00,00,00',CL20'System--------------'\n         DC    X'FF',X'00,00,00',CL20'Free----------------'\nC_RTABL  EQU   *-C_RTAB\nC_RTABN  EQU   C_RTABL/RTABL\n*\n** Literals used in program\n*\n         DS    0F\n         DC    CL8'BKUSERMC'          Literal for easy zapping\nC_BKUSRC DC    AL4(#BKUSERS)          Max number of users considered\n*\n** Literals used in program\n*\n         LTORG ,\n         DS    0D                     End of DA$BRODC CSECT\n*\n** Calculate length of code available in CSECT\n*\nDA$BRODCL EQU *-DA$BRODC              Length used\nDA$BRODCF EQU (4096*2)-DA$BRODCL      Length available\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAINed work area                                         **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nDSA            DSECT ,\n               DS    18F                  Register Save Area\nDSA_LIT1       DS    CL8'DA#BRODC'        Literal for dumps\nDSA_LIT2       DS    CL8' DSA'            Literal for dumps\nDOUBLE         DS    D                    Double word work area\nDOUBLE2        DS    2D                   Double word work area * 2\nPARMLIST       DS    10F                  Parameter list for calls\nRECOUT         DS    CL133                Output record area\nRECOUTS        DS    CL133                Slack\n               DS    0F                   E$OPENS\nEOS_REGS       DS    18F                  ..Register Save Area\nEOS_MSG        DS    CL78                 ..Message from SYNAD\n*                                         Print_Mail_Record\nPMR_LAST       DS    CL7                  ..Last userid\n               DS    0F                   EXECUTION\nX_RECI         DS    F                    ..SYNAD ERROR COUNT\nX_UCOUNT       DS    F                    ..Userid count\nX_UMSGS        DS    F                    ..User message count\nX_TRECS        DS    F                    ..Total records in file\nX_CUSERS       DS    2F                   ..Company/division users\nX_CMSGS        DS    2F                   ..Company/division msgs\n               DS    0F                   Check_Open\nCO_CODE        DS    F                    ..ABEND code\n               DS    0F                   Read_BKLIDS_File\nRBF_VS         DS    2F                   ..Notify\nRBF_USERC      DS    F                    ..Number of users in table\n               DS    0F                   Print_User_Records\nPUR_$HASP165   DS    F                    ..Notify\nPUR_$HASP549   DS    F                    ..Mail\nPUR_DMTAXM104I DS    F                    ..VM\nPUR_HUSERC     DS    F                    ..Highest user Count\nPUR_HUSERN     DS    CL8                  ..Highest user Name\nPUR_MCNT       DS    F                    ..Mail number\nPUR_RA         DS    F                    ..Return address\n               DS    0F                   Report_Dataset_Composition\nRDC_UNK        DS    F                    ..UNKNOWN\nRDC_T          DS    XL(C_RTABL)          ..Table\n               DS    0F                   Read_Records\nRR_RA          DS    F                    ..Return address\n*                                         BrodCAST_Messages\nBM_RRN         DS    XL3                  ..Relative record\nBM_REC         DS    CL129                ..Record saved\n*                                         Userid_Loop\nUI_RRUI        DS    XL3                  ..Relative record\nUI_REC         DS    CL129                ..Record saved\n*\n** File data areas\n*\n               DS    0D\nBKLIDS         DS    XL(C_DCBIL)\nBKLIDS_EXLST   DS    F\n               DS    0D\nSYSPRINT       DS    XL(C_DCBOL)\nSYSPRINT_EXLST DS    F\n               DS    0D\nINDEX          DS    XL(C_DCBOL)\nINDEX_EXLST    DS    F\n               DS    0D\nIEBUPDTE       DS    XL(C_DCBOL)\nIEBUPDTE_EXLST DS    F\n               DS    0D\nSTUFFED        DS    XL(C_DCBOL)\nSTUFFED_EXLST  DS    F\n               DS    0D\nMAIL           DS    XL(C_DCBOL)\nMAIL_EXLST     DS    F\n               DS    0D                   Brodcast (input)\nBRODCAST       DS    XL(C_DCBFIL)         ..DCB\nBRODCAST_EXLST DS    F                    ..Exit List\nBRODCAST_DECB  DS    XL(C_DECBL)          ..DECB for random\nBRODCAST_BLKN  DS    F                    ..Record number\n*\nFLAG_LIT       DS    C'FLAG'              Literal for dumps\nFLAG1          DS    B'00000000'          Flag 1\n$F1_OPENE      EQU   B'10000000'          ..Open file failed\n$F1_IEBUPDTE   EQU   B'01000000'          ..Have a IEBUPDTE file?\n               DS    0D\nDSAL           EQU   *-DSA\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Internal DSECTs                                             **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n*\n** BRODCAST dataset\n*\nBDS_HDR        DSECT ,                    HEADER\n               DS    XL1                  ..FILLER\nBDS_HDR_RRN    DS    XL3                  ..RELATIVE RECORD: NOTICES\n               DS    XL1                  ..FILLER\nBDS_HDR_RRUI   DS    XL3                  ..RELATIVE RECORD: UID INDEX\nBDS_HDR_TBLKS  DS    F                    ..TOTAL BLOCKS IN DATASET\nBDS_HDR_SL     EQU   *-BDS_HDR            ..Length to save\n               DS    XL2\nBDS_HDR_EYEC   DS    C' SYS1.BRODCAST DATA SET LEVEL 2'\n*\nBDS_BM         DSECT ,                    BRODCAST MESSAGE\nBDS_BM_NUM     DS    XL2                  ..NUMBER\nBDS_BM_RR      DS    XL3                  ..RELATIVE RECORD\nBDS_BM_LEN     EQU   *-BDS_BM             ..LENGTH OF NOTICE ENTRY\n*\nBDS_UID        DSECT ,                    USERID\nBDS_UID_NAME   DS    CL7                  ..NAME\nBDS_UID_FIRST  DS    XL3                  ..RELATIVE RECORD: FIRST MSG\nBDS_UID_LAST   DS    XL3                  ..RELATIVE RECORD: LAST MSG\nBDS_UID_LEN    EQU   *-BDS_UID            ..LENGTH OF USERID ENTRY\n*\nBDS_MAIL       DSECT ,                    MAIL\nBDS_MAIL_TEXTL DS    X                    ..LENGTH OF MSG TEXT\nBDS_MAIL_TEXT  DS    CL125                ..LITERAL MESSAGE TEXT\nBDS_MAIL_NEXT  DS    XL3                  ..RELATIVE RECORD: NEXT MAIL\n*\n** Record Table\n*\nRTAB       DSECT ,\nRTAB_TYPE  DS    X\nRTAB_COUNT DS    XL3\nRTAB_TEXT  DS    CL20\nRTABL      EQU   *-RTAB\n*\n** BKLIDS Table\n*\nBKL        DSECT ,\nBKLH       EQU   *\nBKLH_ID    DS    CL8'BKLIDST'\nBKLHL      EQU   *-BKLH\n*\nBKLE       EQU   *\nBKLE_USER  DS    XL(L'LIDLID)\nBKLE_NAME  DS    XL(L'LIDNAME)\nBKLE_PHONE DS    XL(L'LIDPHONE)\nBKLEL      EQU   *-BKLE\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       External DSECTs                                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA           ** DATA CONTROL BLOCK      **\n         PRINT GEN\n         IHADECB ,                        ** DATA EVENT CONTROL BLK  **\n*\n** If we have the ACF2 macro library use it, otherwise create our own\n*\n         AIF   (&ACF2).DSACF2             Do we have the ACF2 mac lib?\nLIDREC   DSECT ,                          Our own simulated layout:\nLIDLID   DS    CL8                        ..Userid\n         DS    XL4                        ..Unused by us\nLIDNAME  DS    CL20                       ..Programmer name\nLIDPHONE DS    CL12                       ..Phone number\n         AGO   .DSACF2X\n.DSACF2  ANOP  ,\n         LIDREC ,\n.DSACF2X ANOP  ,\n         END\n./ ADD NAME=DA$COBR  0100-01266-01266-1821-01539-01539-00000-DAVE\nDA$COBR  TITLE 'COBOL compile setting reporting'\n***********************************************************************\n***                                                                 ***\n** Name: DA$COBR                                                     **\n**                                                                   **\n** Author: David Alcock :: dave@planetmvs.com                        **\n**                                                                   **\n**         Portions of this program were taken verbatim from:        **\n**         - PGM=COMPILE written by Roland Schiradin (Systematics    **\n**           Service GmbH, Hamburg Germany) - COBOL/370 & VS COBOL II**\n**         - PGM=COBFMT written by Rex Widmer - taken from CBT file  **\n**           200 - ANSI COBOL & OS/VS COBOL                          **\n**                                                                   **\n** Note: Roland kept updating his version and this has stagnated.    **\n**       Look on http://www.cbttape.org/ for his latest analyzer.    **\n**                                                                   **\n** Written: 12 February 1997                                         **\n**                                                                   **\n** Attributes: Reentrant, Reusable, Non-Authorized                   **\n**                                                                   **\n** Purpose: This program loads a module and tries to report on the   **\n**          settings as found in the module for compile options.     **\n**                                                                   **\n**  Non-IBM assembler MACROs:                                        **\n**  o DA#COBOL...Mapping macro for the COBOL eyecatcher              **\n**  o DA#ENTER...Entry housekeeping                                  **\n**  o DA#LEAVE...Termination housekeeping                            **\n**  o DA#EYEC....Build standard O/S module eyecatcher                **\n**               (invoked by the DA#ENTER)                           **\n**  o DA#REGS....Define registers (invoked by DA#ENTER)              **\n**  o DA#SMODE...Change addressing mode (24 or 31)                   **\n**  o STRING.....String handling routine - You need file 183 of the  **\n**               CBT to assemble this program.                       **\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n**                                                                   **\n***********************************************************************\n         SPACE 2\n&DAVER   SETC  '1.1'\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** D Alcock   24-FEB-1997 V1.1 Made COBOL DSECTs an external macro for\n**                        easy sharing;\n** D Alcock   12-FEB-1997 V1.0 Took code from Roland Schiradin's\n**                        COMPILE program:\n**                        - Removed DB2 macro (not used in code);\n**                        - Remove inline STRING macro, use most\n**                          current one (maybe not really needed\n**                          but why not be on latest one).\n**                        - VERSION macro not available here,\n**                          probably a only builds a module\n**                          eyecatcher so it was commented out.\n**                        - Storage macro gets buffer above the\n**                          line, bad news for QSAM\n**                        - Do a \"STRING GENERATE\" for this\n**                          level of the STRING macro\n**                        Incorporated some of the COBREAD/COBFMT\n**                        code from CBT tape file #200 for ANSI and\n**                        OS/VS COBOL analysis\n***\n***********************************************************************\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       External DSECTs                                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\n         CVT DSECT=YES,LIST=NO            Commuications Vector Table\n         DCBD  DSORG=PS,DEVD=DA           Data Control Block\n         IKJCPPL ,                        IBM: Cmd Processor Parm List\n         IHAPSA ,                         Prefixed Save Area\n         IKJTCB DSECT=YES,LIST=NO         Task Control Block\n         IEFTIOT1 ,                       Task Input/Output Table\n         IKJIOPL ,                        Input/Output Parameter List\n#IOPL    EQU   *-IOPL\n         IEZBITS ,                        BIT0 - BIT7\n         PRINT GEN\n         DA#COBOL ,                       Map COBOL eyecatcher\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Entry housekeeping and initializations                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         EJECT ,\nDA$COBR  DA#ENTER 'V&DAVER Utility: COBOL program analysis',           @\n               RENT=YES,                  Indicate we want GETMAIN     @\n               LV=DSAL,                   Length of GETMAIN            @\n               BASE=(12,11)               Obtain some base registers\n         USING DSA,R13                    Addressability to work area\n*        ST    R1,R1SAVE\n         MVC   PGMNAME(8),=C'TEMPNAME'    Set default\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Process input parameters from CBUF or O/S parameter         **\n**                                                                   **\n** Note: We are expecting only a parm of the program name to         **\n**       process.                                                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPROCESS_PARAMETER EQU *\n TM    CPPLCBUF-CPPL(R1),X'80'            Was this command called?\n BNO   PP$NC                              No, need to look at CBUF\n*\n** We were called, it has a Batch type parameter list\n*\n L     R2,0(R1)                           Get address of parm\n SLR   R3,R3                              Clear register\n ICM   R3,B'0011',0(R2)                   Get length of parm\n BZ    PP$X                               None, leave\n LA    R2,2(R2)                           Bump past parm length HW\n B     PP$PARSE                           Parse the input\n*\n** Invoked from the command line in TSO as a command processor\n*\nPP$NC EQU   *\n OI    X_FLAG1,$XF1_PL                    We need to do PUTLINEs\n LA    R15,79+4                           79 is width + PUTLINE header\n STH   R15,RECOUTH                        Save length\n MVC   PM_PBLK(C_PBLKL),C_PBLK            Initialize IOPL\n LA    R14,PM_IOPL                        Locate it\n MVC   IOPLUPT-IOPL(4,R14),CPPLUPT-CPPL(R1) Fill in UPT pointer\n MVC   IOPLECT-IOPL(4,R14),CPPLECT-CPPL(R1) Fill in ECT pointer\n LA    R15,PM_ECB                         Locate ECB\n ST    R15,IOPLECB-IOPL(R14)              Fill it in\n*\n L     R2,CPPLCBUF-CPPL(R1)               Locate Command Buffer\n SLR   R3,R3                              Clear register\n ICM   R3,B'0011',0(R2)                   Get total CBUF length\n SLR   R0,R0                              Clear register\n ICM   R0,B'0011',2(R2)                   Get total Command name length\n LA    R15,4                              Length of header\n AR    R2,R15                             Bump past header\n SR    R3,R15                             Decrement for header length\n AR    R2,R0                              Bump past Command length\n SR    R3,R0                              Length of data\n*\n** Look thru command buffer/parameter for our commands\n** Input: R2 - Address of command-buffer/Parameter\n**        R3 - Length of command-buffer/Parameter\n*\nPP$PARSE EQU *\n LTR   R3,R3                              Check out length\n BZ    PP$X                               Length = Zero: Leave\n BM    PP$X                               Length < Zero: Leave\n BAS   R14,PP$UC                          Make input uppercase\n*\n** Copy the first parm to the program name\n*\n LA    R15,PGMNAME                        Locate the program name (out)\n MVC   0(8,R15),BLANKS                    Pad with blanks\n LA    R14,8                              Length to consider\nPP$PL DS 0H\n MVC   0(1,R15),0(R2)                     Get a byte\n LA    R15,1(R15)                         Bump to next output byte\n BCTR  R14,0                              Decrement length\n LTR   R14,R14                            Okay?\n BZ    PP$X                               No, hit the end...\n LA    R2,1(R2)                           Yes, bump to next input byte\n BCT   R3,PP$PL                           ..and try it out\n*-Other parms could be gathered here or do multiple members\n B     PP$X\n*\n** Make input uppercase\n** Input: R3 - Length (Do not modify this register!!)\n**        R2 - Address (Do not modify this register!!)\n*\nPP$UC EQU *\n LR    R0,R3                              Get length of Data\n LR    R1,R2                              Get address of Data\nPP$UCL EQU *\n OI    0(R1),C' '                         Make it upper case\n LA    R1,1(R1)                           Bump past it\n BCT   R0,PP$UCL                          ..do next byte\n BSM   0,R14                              Return to caller\n*\n** Common exit from Process_Parameter\n*\nPP$X EQU *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Getting started                                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         STRING 'COBOL module analysis is starting',INTO=RECOUT\n         BAS   R14,PRINT_MSG              Print starting message\n*\n** Load the progamm\n*\n         LOAD  EPLOC=PGMNAME,ERRET=E$LOAD Load program\n         ST    R0,ADR_PGMNAME             Save the address\n         OI    X_FLAG1,$XF1_LOAD          Set that we loaded it\n*\n** Write load information to SYSPRINT\n*\n         STRING 'Program Name=',PGMNAME,                               @\n               ' was loaded into storage at EPA=',(ADR_PGMNAME,,X),    @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n*\n** Determine if the type of program is COBOL/370 or VS COBOL II\n*\n         DA#SMODE 31                      Get into 31 bit addr mode\n         L     R4,ADR_PGMNAME             Get EPA of module\n*\n         CLC   CEE_EYECATCHER-COBOL_370_DSECT(4,R4),C_COBOL370\n         BE    COBOL_370\n         CLC   C2_EYECATCHER-COBOL_2_DSECT(4,R4),=CL4' C2 '\n         BE    COBOL_2\n         CLC   X'14'(4,R4),=CL4'ANS4'     ANSI (Ancient) COBOL?\n         BE    COBOL_ANSI\n         CLC   X'14'(4,R4),=CL4'VSR1'     OS/VS COBOL?\n         BE    COBOL_OSVS                 Yes, got a live one\n*\n         STRING 'Can not established the program language',INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         LA    R15,8                      Set the return code\n         B     EXIT                       Leave\n*\n** Load of program failed, gripe about it and leave\n*\nE$LOAD DS 0H\n         STRING 'Error during load of program=',PGMNAME,INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         LA    R15,12\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Termination of program                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT DS 0H\n         LR    R2,R15                     Save return code\n         DA#SMODE 24                      Get into 24 bit mode\n*\n** Delete the module\n*\n         TM    X_FLAG1,$XF1_LOAD          Did we load it?\n         BNO   X$DELX\n         DELETE EPLOC=PGMNAME             Delete from memory\nX$DELX   DS    0H\n*\n** Print ending message\n*\n         STRING '============ Termination ===========================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'COBOL module analysis is Ending',INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG        Print ending message\n*\n** Close SYSPRINT (if open)\n*\n         TM    X_FLAG1,$XF1_SPO           SysPrint Open?\n         BO    X$CLOSEX                   No, don't need close\n         LA    R3,SYSPRINT                Locate DCB\n         MVC   PARMLIST(C_CLSL),C_CLS     Move in CLOSE parameter list\n         CLOSE ((3)),MF=(E,PARMLIST)      Close file\nX$CLOSEX DS    0H\n*\n** Exit housekeeping\n*\n         LR    R15,R2                    Get return code\n         DA#LEAVE RC=(15)                Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Older COBOLs                                                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nCOBOL_ANSI DS 0H\n         STRING '============ Info ==================================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Program ',PGMNAME,' is ANSI COBOL',INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         B     COBOL_OLD\nCOBOL_OSVS DS 0H\n         STRING '============ Info ==================================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Program ',PGMNAME,' is OS/VS COBOL',INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         OI    X_FLAG1,$XF1_VS            Turn on flag\nCOBOL_OLD DS 0H\n         L     R5,60(,R4)                 Get TGT pointer\n*        ST    R5,TGTPTR                  SAVE FOR OTHER USAGE\n*        ST    R4,INIT1PTR                SAVE FOR OTHER USAGE\n         CLC   X'1BC'(8,R5),=CL8'SYSOUT  ' Check for good TGT\n         BNE   NOTTGT                     Doesn't look good...\n*\n         MVC   RECOUT(79),BLANKS          Move in blanks\n         LA    R15,RECOUT                 Locate output location\n         MVC   0(8,R15),=C'Options:'      Insert text\n         LA    R15,9(R15)                 Bump past text\n*\n*        SET FLAGS IN DETAIL PRINT LINE  -\n*        BASED UPON THE SWITCH WORD IN THE TGT\n*\n*        SWITCH BIT MEANINGS - SOURCE COBOL COMPILER PLM\n*         BYTE 1  BIT 0 MASK X'80'  USED BY ON SIZE ERROR\n*         BYTE 1  BIT 1 MASK X'40'  USED BY READY TRACE VERB\n*         BYTE 1  BIT 2 MASK X'20'  INITIALIZATION FLAG\n*         BYTE 1  BIT 3 MASK X'10'  MAIN PROGRAM FLAG\n*         BYTE 1  BIT 4 MASK X'08'  SYMDUMP FLAG\n*         BYTE 1  BIT 5 MASK X'04'  FLOW FLAG\n*         BYTE 1  BIT 6 MASK X'02'  STATE FLAG / REUSED AT RUN TIME\n*         BYTE 1  BIT 7 MASK X'01'  OPTIMIZATION FLAG\n*         BYTE 2  BIT 0 MASK X'80'  RESERVED\n*         BYTE 2  BIT 1 MASK X'40'  USED BY CALL AND CANCEL\n*         BYTE 2  BIT 2 MASK X'20'  EXEC TIME STATE FLAG\n*         BYTE 2  BIT 3 MASK X'10'  TEST ATTRIBUTE FLAG\n*         BYTE 2  BIT 4 MASK X'08'  QUOTE IS APOST FLAG\n*         BYTE 2  BIT 5 MASK X'04'  SPECIAL SYMDUMP USAGE\n*         BYTE 2  BIT 6 MASK X'02'  LONG TGT FLAG, ALWAYS 1 FOR V4 / VS\n*         BYTE 2  BIT 7 MASK X'01'  Q-ROUTINE USAGE\n*         BYTE 3  BIT 0 MASK X'80'  NORES FLAG, SET TO 0 FOR RES OPTION\n*         BYTE 3  BIT 1 MASK X'40'  ENDJOB WAS SPECIFIED\n*         BYTE 3  BIT 2 MASK X'20'  OBJECT COMPUTER 370 SPECIFIED\n*         BYTE 3  BIT 3 MASK X'10'  Q-ROUTINE FLAG\n*         BYTE 3  BIT 4 MASK X'08'  COUNT OPTION - VS\n*         BYTE 3  BIT 5 MASK X'04'  TRACE VERB IS PRESENT\n*         BYTE 3  BIT 6 MASK X'02'  SYNADAF USAGE\n*         BYTE 3  BIT 7 MASK X'01'  UNUSED BIT\n*         BYTE 4  DEC POINT IS COMMA BYTE\n*                 C',' IF SPECIFIED, ELSE C'.'\n         EJECT\n         TM    X'48'(R5),X'08' IS IT SYMDUMP\n         BZ    X01\n         MVC   0(4,R15),=C'SYMD'\n         LA    R15,5(R15)\nX01      DS    0H\n         SPACE 1\n         TM    X'48'(R5),X'04' IS IT FLOW\n         BZ    X02\n         MVC   0(4,R15),=C'FLOW'\n         LA    R15,5(R15)\nX02      DS    0H\n         SPACE 1\n         TM    X'48'(R5),X'02' IS IT STATE\n         BZ    X03\n         MVC   0(5,R15),=C'STATE'\n         LA    R15,6(R15)\nX03      DS    0H\n         SPACE 1\n         TM    X'49'(R5),X'10' IS IT TEST\n         BZ    X04\n         MVC   0(4,R15),=C'TEST'\n         LA    R15,5(R15)\nX04      DS    0H\n         SPACE 1\n         TM    X'4A'(R5),X'80' IS IT RESIDENT\n         BO    X05\n         MVC   0(3,R15),=C'RES'\n         LA    R15,4(R15)\nX05      DS    0H\n         SPACE 1\n         TM    X'4A'(R5),X'40' IS IT ENDJOB\n         BZ    X06\n         MVC   0(6,R15),=C'ENDJOB'\n         LA    R15,7(R15)\nX06      DS    0H\n         TM    X'4A'(R5),X'20' IS IT OBJECT 370\n         BZ    X07\n         MVC   0(6,R15),=C'OBJ370'\n         LA    R15,7(R15)\nX07      DS    0H\n         SPACE 1\n         TM    X'48'(R5),X'01' IS IT COBOL OPTIMISED\n         BZ    X08\n         MVC   0(6,R15),=C'COBOPT'\n         LA    R15,7(R15)\nX08      DS    0H\n         CLC   X'48'(6,R4),=CL6'CAPEX'  IS IT CAPEX OPTIMISED ?\n         BNE   CAPEXX\n         MVC   0(5,R15),=C'CAPEX'\n         LA    R15,6(R15)\nCAPEXX   DS    0H\n         TM    X_FLAG1,$XF1_VS     VS COBOL II?\n         BNO   NOTVS\n         TM    X'4A'(R5),X'08'     SEE IF COUNT WAS SPECIFIED\n         BZ    X09                 NO COUNT OPTION\n         MVC   0(5,R15),=C'COUNT'  PUT IT IN MSG\n         LA    R15,6(R15)\nX09      DS    0H\n         TM    X'4A'(R5),X'04'     WAS TRACE VERB IN PGM\n         BZ    X10                  NO, DO NOT FLAG IT ON LISTING\n         MVC   0(5,R15),=C'TRACE'  PUT IT IN MSG\n         LA    R15,6(R15)\nNOTVS    DS    0H\nX10      DS    0H\nDONEFMT  DS    0H\n         BAS   R14,PRINT_BLINE_MSG\n         LA    R15,0\n         NI    X_FLAG1,255-$XF1_VS\n         B     EXIT\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING 'Program ',PGMNAME,' failed the TGT (Task Global',     @\n               'Table) test',INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         LA    R15,8\n         NI    X_FLAG1,255-$XF1_VS\n         B     EXIT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       COBOL/370 program                                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         MVI   LE_SWITCH,C'1'\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         DROP  R4\n         B     LE370_INFO\n*============================================================*\n*  VS COBOL II program                                       *\n*============================================================*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n         MVC   LE_COMP_YEAR,C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         DROP  R4\n         B     LE370_INFO\nLE370_INFO DS  0H\n         STRING '============ Info ==================================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Program ',PGMNAME,' is COBOL/370 Version ',LE_VERS,   @\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECOUT\n         CLI   LE_SWITCH,C'1'\n         BE    JUMP_AROUND\n         STRING 'Program ',PGMNAME,' is VS COBOL II Version ',LE_VERS, @\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECOUT\nJUMP_AROUND DS 0H\n         BAS   R14,PRINT_BLINE_MSG\n         STRING '============ Timestamps ============================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *\n               ':',LE_COMP_SEC,INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING '============ Statistics ============================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *\n               INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING '============ Options in effect =====================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(6),=CL6'ADV'\n         TM    LE_STATUS_BYTE_01,ADV\n         BO    LE_370_01\n         MVC   RECOUT+1(6),=CL6'NOADV'\nLE_370_01 DS 0H\n         MVC   RECOUT+8(6),=CL6'APOST'\n         TM    LE_STATUS_BYTE_01,APOST\n         BO    LE_370_02\n         MVC   RECOUT+8(6),=CL6'QUOTE'\nLE_370_02 DS 0H\n         MVC   RECOUT+16(9),=CL9'DATA(31)'\n         TM    LE_STATUS_BYTE_01,DATA31\n         BO    LE_370_03\n         MVC   RECOUT+16(9),=CL9'DATA(24)'\nLE_370_03 DS 0H\n         MVC   RECOUT+25(6),=CL6'DECK'\n         TM    LE_STATUS_BYTE_01,DECK\n         BO    LE_370_04\n         MVC   RECOUT+25(6),=CL6'NODECK'\nLE_370_04 DS 0H\n         MVC   RECOUT+33(6),=CL6'DUMP'\n         TM    LE_STATUS_BYTE_01,DUMP\n         BO    LE_370_05\n         MVC   RECOUT+33(6),=CL6'NODUMP'\nLE_370_05 DS 0H\n         MVC   RECOUT+40(8),=CL8'DYNAM'\n         TM    LE_STATUS_BYTE_01,DYNAM\n         BO    LE_370_06\n         MVC   RECOUT+40(8),=CL8'NODYNAM'\nLE_370_06 DS 0H\n         MVC   RECOUT+51(10),=CL10'FASTSRT'\n         TM    LE_STATUS_BYTE_01,FASTSRT\n         BO    LE_370_07\n         MVC   RECOUT+51(10),=CL10'NOFASTSRT'\nLE_370_07 DS 0H\n         MVC   RECOUT+62(8),=CL8'FDUMP'\n         TM    LE_STATUS_BYTE_01,FDUMP\n         BO    LE_370_08\n         MVC   RECOUT+62(8),=CL8'NOFDUMP'\nLE_370_08 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(6),=CL6'LIB'\n         TM    LE_STATUS_BYTE_02,LIB\n         BO    LE_370_11\n         MVC   RECOUT+1(6),=CL6'NOLIB'\nLE_370_11 DS 0H\n         MVC   RECOUT+8(7),=CL7'LIST'\n         TM    LE_STATUS_BYTE_02,LIST\n         BO    LE_370_12\n         MVC   RECOUT+8(7),=CL7'NOLIST'\nLE_370_12 DS 0H\n         MVC   RECOUT+16(9),=CL9'MAP'\n         TM    LE_STATUS_BYTE_02,MAP\n         BO    LE_370_13\n         MVC   RECOUT+16(9),=CL9'NOMAP'\nLE_370_13 DS 0H\n         MVC   RECOUT+25(6),=CL6'NUM'\n         TM    LE_STATUS_BYTE_02,NUM\n         BO    LE_370_14\n         MVC   RECOUT+25(6),=CL6'NONUM'\nLE_370_14 DS 0H\n         MVC   RECOUT+33(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,OBJ\n         BO    LE_370_15\n         MVC   RECOUT+33(6),=CL6'NOOBJ'\nLE_370_15 DS 0H\n         MVC   RECOUT+40(8),=CL8'OFFSET'\n         TM    LE_STATUS_BYTE_02,OFFSET\n         BO    LE_370_16\n         MVC   RECOUT+40(8),=CL8'NOOFFSET'\nLE_370_16 DS 0H\n         MVC   RECOUT+51(10),=CL10'OPTIMIZE'\n         TM    LE_STATUS_BYTE_02,OPTIMIZE\n         BO    LE_370_17\n         MVC   RECOUT+51(10),=CL10'NOOPTIMIZE'\nLE_370_17 DS 0H\n         MVC   RECOUT+62(17),=CL17'DDNAME(no default)'\n         TM    LE_STATUS_BYTE_02,DDNAME\n         BO    LE_370_18\n         MVC   RECOUT+62(17),=CL17'DDNAME(default)'\nLE_370_18 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(15),=CL15'NUMPROC(MIG)'\n         TM    LE_STATUS_BYTE_05,NUMPROCM\n         BO    LE_370_21\nLE_370_21A DS 0H\n         MVC   RECOUT+1(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,NUMPROC\n         BO    LE_370_21\n         MVC   RECOUT+1(15),=CL15'NUMPROC(NOPFD)'\nLE_370_21 DS 0H\n         MVC   RECOUT+16(7),=CL7'RENT'\n         TM    LE_STATUS_BYTE_03,RENT\n         BO    LE_370_22\n         MVC   RECOUT+16(7),=CL7'NORENT'\nLE_370_22 DS 0H\n         MVC   RECOUT+25(6),=CL6'RES'\n         TM    LE_STATUS_BYTE_03,RES\n         BO    LE_370_23\n         MVC   RECOUT+25(6),=CL6'NORES'\nLE_370_23 DS 0H\n         MVC   RECOUT+33(6),=CL6'SEQ'\n         TM    LE_STATUS_BYTE_03,SEQUENCE\n         BO    LE_370_24\n         MVC   RECOUT+33(6),=CL6'NOSEQ'\nLE_370_24 DS 0H\n         MVC   RECOUT+40(12),=CL12'SIZE(MAX)'\n         TM    LE_STATUS_BYTE_03,SIZE\n         BO    LE_370_25\n         MVC   RECOUT+40(12),=CL12'SIZE(value)'\nLE_370_25 DS 0H\n         MVC   RECOUT+51(9),=CL9'SOURCE'\n         TM    LE_STATUS_BYTE_03,SOURCE\n         BO    LE_370_26\n         MVC   RECOUT+51(9),=CL9'NOSOURCE'\nLE_370_26 DS 0H\n         MVC   RECOUT+62(10),=CL10'SSRANGE'\n         TM    LE_STATUS_BYTE_03,SSRANGE\n         BO    LE_370_27\n         MVC   RECOUT+62(10),=CL10'NOSSRANGE'\nLE_370_27 DS 0H\n         MVC   RECOUT+72(8),=CL8'TERM'\n         TM    LE_STATUS_BYTE_03,TERM\n         BO    LE_370_28\n         MVC   RECOUT+72(8),=CL8'NOTERM'\nLE_370_28 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(8),=CL8'TEST'\n         TM    LE_STATUS_BYTE_04,TEST\n         BO    LE_370_31\n         MVC   RECOUT+1(8),=CL8'NOTEST'\nLE_370_31 DS 0H\n         MVC   RECOUT+8(10),=CL11'TRUNC(BIN)'\n         TM    LE_STATUS_BYTE_05,TRUNCB\n         BO    LE_370_33\n         MVC   RECOUT+8(10),=CL11'TRUNC(STD)'\n         TM    LE_STATUS_BYTE_04,TRUNC\n         BO    LE_370_33\n         MVC   RECOUT+8(10),=CL11'TRUNC(OPT)'\nLE_370_33 DS 0H\n         MVC   RECOUT+25(8),=CL8'VBREF'\n         TM    LE_STATUS_BYTE_04,VBREF\n         BO    LE_370_34\n         MVC   RECOUT+25(8),=CL8'NOVBREF'\nLE_370_34 DS 0H\n         MVC   RECOUT+33(6),=CL6'XREF'\n         TM    LE_STATUS_BYTE_04,XREF\n         BO    LE_370_35\n         MVC   RECOUT+33(6),=CL6'NOXREF'\nLE_370_35 DS 0H\n         MVC   RECOUT+40(6),=CL6'ZWB'\n         TM    LE_STATUS_BYTE_04,ZWB\n         BO    LE_370_36\n         MVC   RECOUT+40(6),=CL6'NOZWB'\nLE_370_36 DS 0H\n         MVC   RECOUT+51(7),=CL7'NAME'\n         TM    LE_STATUS_BYTE_04,NAME\n         BO    LE_370_37\n         MVC   RECOUT+51(7),=CL7'NONAME'\nLE_370_37 DS 0H\n         MVC   RECOUT+62(8),=CL8'CMPR2'\n         TM    LE_STATUS_BYTE_04,CMPR2\n         BO    LE_370_38\n         MVC   RECOUT+62(8),=CL8'NOCMPR2'\nLE_370_38 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(11),=CL11'NUMCLASS'\n         TM    LE_STATUS_BYTE_05,NUMCLASS\n         BO    LE_370_41\n         MVC   RECOUT+1(11),=CL11'NONUMCLASS'\nLE_370_41 DS 0H\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BE    LE_370_42\n         MVC   RECOUT+1(11),=CL11'NUMCLS'\n         TM    LE_STATUS_BYTE_05,NUMCLASS\n         BO    LE_370_42\n         MVC   RECOUT+1(11),=CL11'NONCLS'\nLE_370_42 DS 0H\n         MVC   RECOUT+16(7),=CL7'DBCS'\n         TM    LE_STATUS_BYTE_05,DBCS\n         BO    LE_370_43\n         MVC   RECOUT+16(7),=CL7'NODBCS'\nLE_370_43 DS 0H\n         MVC   RECOUT+25(6),=CL6'AWO'\n         TM    LE_STATUS_BYTE_05,AWO\n         BO    LE_370_45\n         MVC   RECOUT+25(6),=CL6'NOAWO'\nLE_370_45 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_48                       no, jump around\n         MVC   RECOUT+33(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,EVENTS\n         BO    LE_370_46\n         MVC   RECOUT+33(9),=CL9'NOEVENTS'\nLE_370_46 DS 0H\n         MVC   RECOUT+40(11),=CL11'CURRENCY'   n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,CURRENCY\n         BO    LE_370_48\n         MVC   RECOUT+40(11),=CL11'NOCURRENCY'\nLE_370_48 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(40),=CL40'User supplied reserved word list'\n         TM    LE_STATUS_BYTE_04,USERW\n         BO    LE_370_49\n  MVC   RECOUT+1(40),=CL40'Installation default reserved word list'\nLE_370_49 DS 0H\n         BAS   R14,PRINT_BLINE_MSG\n         STRING '============ Additional information ================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         STRING '============ about DATA DIVISION    ================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Program use no QSAM or SAM access method',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT0\n         BNO   LE_370_51\n         STRING 'Program use QSAM or SAM access',INTO=RECOUT\nLE_370_51 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program use no VSAM sequential files',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT1\n         BNO   LE_370_52\n         STRING 'Program use VSAM sequential files',INTO=RECOUT\nLE_370_52 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program use no VSAM indexed files',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT2\n         BNO   LE_370_53\n         STRING 'Program use VSAM indexed files',INTO=RECOUT\nLE_370_53 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program use no VSAM rba files',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT3\n         BNO   LE_370_54\n         STRING 'Program use VSAM rba files',INTO=RECOUT\nLE_370_54 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program use no CODE-SET (ASCII files)',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT4\n         BNO   LE_370_55\n         STRING 'Program use CODE-SET (ASCII files)',INTO=RECOUT\nLE_370_55 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program use no spanned records',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT5\n         BNO   LE_370_56\n         STRING 'Program use spanned receords',INTO=RECOUT\nLE_370_56 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no picture G (DBCS) items',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT6\n         BNO   LE_370_57\n         STRING 'Program has picture G (DBCS) items',INTO=RECOUT\nLE_370_57 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no OCCURS DEPENDING ON items',INTO=RECOUT\n         TM    LE_STATUS_BYTE_06,BIT7\n         BNO   LE_370_58\n         STRING 'Program has OCCURS DEPENDING ON items',INTO=RECOUT\nLE_370_58 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no SYNCHRONIZED clause',INTO=RECOUT\n         TM    LE_STATUS_BYTE_07,BIT0\n         BNO   LE_370_59\n         STRING 'Program has SYNCHRONIZED clause',INTO=RECOUT\nLE_370_59 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no JUSTIFIED clause',INTO=RECOUT\n         TM    LE_STATUS_BYTE_07,BIT1\n         BNO   LE_370_60\n         STRING 'Program has JUSTIFIED clause',INTO=RECOUT\nLE_370_60 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no POINTER items',INTO=RECOUT\n         TM    LE_STATUS_BYTE_07,BIT2\n         BNO   LE_370_61\n         STRING 'Program has POINTER items',INTO=RECOUT\nLE_370_61 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no complex ODO clause',INTO=RECOUT\n         TM    LE_STATUS_BYTE_07,BIT3\n         BNO   LE_370_62\n         STRING 'Program has complex ODO clause',INTO=RECOUT\nLE_370_62 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no external floating-point items',        @\n               INTO=RECOUT\n         TM    LE_STATUS_BYTE_07,BIT4\n         BNO   LE_370_63\n         STRING 'Program has external floating-point items',INTO=RECOUT\nLE_370_63 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_64                       no, jump around\n         BAS   R14,PRINT_MSG\n         STRING 'Program has no procedure-pointer items',INTO=RECOUT\n         TM    LE_STATUS_BYTE_07,BIT6          n/a cobol/2\n         BNO   LE_370_64\n         STRING 'Program has procedure-pointer items',INTO=RECOUT\nLE_370_64 DS 0H\n         BAS   R14,PRINT_BLINE_MSG\n         STRING '============ Additional information    =============',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         STRING '============ about ENVIROMENT DIVISION =============',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Program use no FILE-STATUS clause',INTO=RECOUT\n         TM    LE_STATUS_BYTE_08,BIT0\n         BNO   LE_370_66\n         STRING 'Program use FILE-STATUS clause',INTO=RECOUT\nLE_370_66 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program use no RERUN clause in I/O-control',          @\n               INTO=RECOUT\n         TM    LE_STATUS_BYTE_08,BIT1\n         BNO   LE_370_67\n         STRING 'Program has RERUN clause in I/O-control',INTO=RECOUT\nLE_370_67 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'Program use no UPSI switches',INTO=RECOUT\n         TM    LE_STATUS_BYTE_08,BIT2\n         BNO   LE_370_68\n         STRING 'Program use UPSI switches',INTO=RECOUT\nLE_370_68 DS 0H\n         BAS   R14,PRINT_BLINE_MSG\n         STRING '============ Additional information    =============',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         STRING '============ about PROCEDURE DIVISION  =============',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Following statements in control (check Y/N):',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(6),=CL6'Accept'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         BNO   LE_370_69\n         MVI   RECOUT+15,C'Y'\nLE_370_69 DS 0H\n         MVC   RECOUT+18(3),=CL3'Add'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         BNO   LE_370_70\n         MVI   RECOUT+32,C'Y'\nLE_370_70 DS 0H\n         MVC   RECOUT+35(5),=CL5'Alter'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         BNO   LE_370_71\n         MVI   RECOUT+49,C'Y'\nLE_370_71 DS 0H\n         MVC   RECOUT+52(4),=CL4'Call'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         BNO   LE_370_72\n         MVI   RECOUT+66,C'Y'\nLE_370_72 DS 0H\n         MVC   RECOUT+69(6),=CL6'Cancel'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         BNO   LE_370_73\n         MVI   RECOUT+83,C'Y'\nLE_370_73 DS 0H\n         MVC   RECOUT+86(5),=CL5'CLose'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT7\n         BNO   LE_370_74\n         MVI   RECOUT+100,C'Y'\nLE_370_74 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(7),=CL7'Compute'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         BNO   LE_370_75\n         MVI   RECOUT+15,C'Y'\nLE_370_75 DS 0H\n         MVC   RECOUT+18(6),=CL6'Delete'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         BNO   LE_370_76\n         MVI   RECOUT+32,C'Y'\nLE_370_76 DS 0H\n         MVC   RECOUT+35(7),=CL7'Display'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         BNO   LE_370_77\n         MVI   RECOUT+49,C'Y'\nLE_370_77 DS 0H\n         MVC   RECOUT+52(6),=CL6'Divide'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         BNO   LE_370_78\n         MVI   RECOUT+66,C'Y'\nLE_370_78 DS 0H\n         MVC   RECOUT+69(11),=CL11'End-Perform'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         BNO   LE_370_79\n         MVI   RECOUT+83,C'Y'\nLE_370_79 DS 0H\n         MVC   RECOUT+86(5),=CL5'Enter'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         BNO   LE_370_80\n         MVI   RECOUT+100,C'Y'\nLE_370_80 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(5),=CL5'Entry'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         BNO   LE_370_81\n         MVI   RECOUT+15,C'Y'\nLE_370_81 DS 0H\n         MVC   RECOUT+18(4),=CL4'Exit'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         BNO   LE_370_82\n         MVI   RECOUT+32,C'Y'\nLE_370_82 DS 0H\n         MVC   RECOUT+35(5),=CL5'Go to'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         BNO   LE_370_83\n         MVI   RECOUT+49,C'Y'\nLE_370_83 DS 0H\n         MVC   RECOUT+52(2),=CL2'If'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         BNO   LE_370_84\n         MVI   RECOUT+66,C'Y'\nLE_370_84 DS 0H\n         MVC   RECOUT+69(10),=CL10'Initialize'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         BNO   LE_370_85\n         MVI   RECOUT+83,C'Y'\nLE_370_85 DS 0H\n         MVC   RECOUT+86(7),=CL7'Inspect'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         BNO   LE_370_86\n         MVI   RECOUT+100,C'Y'\nLE_370_86 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(5),=CL5'Merge'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         BNO   LE_370_88\n         MVI   RECOUT+15,C'Y'\nLE_370_88 DS 0H\n         MVC   RECOUT+18(4),=CL4'Move'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         BNO   LE_370_89\n         MVI   RECOUT+32,C'Y'\nLE_370_89 DS 0H\n         MVC   RECOUT+35(8),=CL8'Multiply'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         BNO   LE_370_90\n         MVI   RECOUT+49,C'Y'\nLE_370_90 DS 0H\n         MVC   RECOUT+52(4),=CL4'Open'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         BNO   LE_370_91\n         MVI   RECOUT+66,C'Y'\nLE_370_91 DS 0H\n         MVC   RECOUT+69(7),=CL7'Perform'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         BNO   LE_370_92\n         MVI   RECOUT+83,C'Y'\nLE_370_92 DS 0H\n         MVC   RECOUT+86(4),=CL4'Read'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         BNO   LE_370_93\n         MVI   RECOUT+100,C'Y'\nLE_370_93 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(7),=CL7'Release'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         BNO   LE_370_94\n         MVI   RECOUT+15,C'Y'\nLE_370_94 DS 0H\n         MVC   RECOUT+18(6),=CL6'Return'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         BNO   LE_370_95\n         MVI   RECOUT+32,C'Y'\nLE_370_95 DS 0H\n         MVC   RECOUT+35(7),=CL7'Rewrite'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         BNO   LE_370_96\n         MVI   RECOUT+49,C'Y'\nLE_370_96 DS 0H\n         MVC   RECOUT+52(6),=CL6'Search'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         BNO   LE_370_97\n         MVI   RECOUT+66,C'Y'\nLE_370_97 DS 0H\n         MVC   RECOUT+69(3),=CL3'Set'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         BNO   LE_370_98\n         MVI   RECOUT+83,C'Y'\nLE_370_98 DS 0H\n         MVC   RECOUT+86(4),=CL4'Sort'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         BNO   LE_370_99\n         MVI   RECOUT+100,C'Y'\nLE_370_99 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(5),=CL5'Start'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         BNO   LE_370_100\n         MVI   RECOUT+15,C'Y'\nLE_370_100 DS 0H\n         MVC   RECOUT+18(4),=CL4'Stop'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         BNO   LE_370_101\n         MVI   RECOUT+32,C'Y'\nLE_370_101 DS 0H\n         MVC   RECOUT+35(6),=CL6'String'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         BNO   LE_370_102\n         MVI   RECOUT+49,C'Y'\nLE_370_102 DS 0H\n         MVC   RECOUT+52(4),=CL4'Subtract'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         BNO   LE_370_103\n         MVI   RECOUT+66,C'Y'\nLE_370_103 DS 0H\n         MVC   RECOUT+69(8),=CL8'Unstring'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         BNO   LE_370_104\n         MVI   RECOUT+83,C'Y'\nLE_370_104 DS 0H\n         MVC   RECOUT+86(3),=CL3'Use'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         BNO   LE_370_105\n         MVI   RECOUT+100,C'Y'\nLE_370_105 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(5),=CL5'Write'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         BNO   LE_370_106\n         MVI   RECOUT+15,C'Y'\nLE_370_106 DS 0H\n         MVC   RECOUT+18(4),=CL4'Continue'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         BNO   LE_370_107\n         MVI   RECOUT+32,C'Y'\nLE_370_107 DS 0H\n         MVC   RECOUT+35(7),=CL7'End-Add'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         BNO   LE_370_108\n         MVI   RECOUT+49,C'Y'\nLE_370_108 DS 0H\n         MVC   RECOUT+52(7),=CL7'End-Call'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         BNO   LE_370_109\n         MVI   RECOUT+66,C'Y'\nLE_370_109 DS 0H\n         MVC   RECOUT+69(11),=CL11'End-Compute'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         BNO   LE_370_110\n         MVI   RECOUT+83,C'Y'\nLE_370_110 DS 0H\n         MVC   RECOUT+86(10),=CL10'End-Delete'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         BNO   LE_370_111\n         MVI   RECOUT+100,C'Y'\nLE_370_111 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(10),=C'End-Divide'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         BNO   LE_370_112\n         MVI   RECOUT+15,C'Y'\nLE_370_112 DS 0H\n         MVC   RECOUT+18(11),=C'End-Evaluate'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         BNO   LE_370_113\n         MVI   RECOUT+32,C'Y'\nLE_370_113 DS 0H\n         MVC   RECOUT+35(6),=C'End-If'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         BNO   LE_370_114\n         MVI   RECOUT+49,C'Y'\nLE_370_114 DS 0H\n         MVC   RECOUT+52(11),=CL11'End-Muliply'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         BNO   LE_370_115\n         MVI   RECOUT+66,C'Y'\nLE_370_115 DS 0H\n         MVC   RECOUT+69(8),=CL8'End-Read'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         BNO   LE_370_116\n         MVI   RECOUT+83,C'Y'\nLE_370_116 DS 0H\n         MVC   RECOUT+86(10),=CL10'End-Return'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         BNO   LE_370_117\n         MVI   RECOUT+100,C'Y'\nLE_370_117 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(11),=C'End-Rewrite'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         BNO   LE_370_118\n         MVI   RECOUT+15,C'Y'\nLE_370_118 DS 0H\n         MVC   RECOUT+18(10),=C'End-Search'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         BNO   LE_370_119\n         MVI   RECOUT+32,C'Y'\nLE_370_119 DS 0H\n         MVC   RECOUT+35(9),=C'End-Start'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         BNO   LE_370_120\n         MVI   RECOUT+49,C'Y'\nLE_370_120 DS 0H\n         MVC   RECOUT+52(10),=CL10'End-String'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         BNO   LE_370_121\n         MVI   RECOUT+66,C'Y'\nLE_370_121 DS 0H\n         MVC   RECOUT+69(13),=CL13'End-Substract'\n         MVI   RECOUT+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         BNO   LE_370_122\n         MVI   RECOUT+83,C'Y'\nLE_370_122 DS 0H\n         MVC   RECOUT+86(12),=CL12'End-Unstring'\n         MVI   RECOUT+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         BNO   LE_370_123\n         MVI   RECOUT+100,C'Y'\nLE_370_123 DS 0H\n         BAS   R14,PRINT_MSG\n         MVC   RECOUT,BLANKS\n         MVC   RECOUT+1(9),=C'End-Write'\n         MVI   RECOUT+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         BNO   LE_370_124\n         MVI   RECOUT+15,C'Y'\nLE_370_124 DS 0H\n         MVC   RECOUT+18(10),=C'Goback'\n         MVI   RECOUT+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         BNO   LE_370_125\n         MVI   RECOUT+32,C'Y'\nLE_370_125 DS 0H\n         MVC   RECOUT+35(9),=C'Evaluate'\n         MVI   RECOUT+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         BNO   LE_370_126\n         MVI   RECOUT+49,C'Y'\nLE_370_126 DS 0H\n         MVC   RECOUT+52(7),=CL7'Service'\n         MVI   RECOUT+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         BNO   LE_370_127\n         MVI   RECOUT+66,C'Y'\nLE_370_127 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING '====================================================',*\n               '=============================================',        @\n               INTO=RECOUT\n         BAS   R14,PRINT_BLINE_MSG\n         STRING 'Procedure has no hexadecimal literals',INTO=RECOUT\n         TM    LE_STATUS_BYTE_21,BIT0\n         BNO   LE_370_128\n         STRING 'Procedure include hexadecimal literals',INTO=RECOUT\nLE_370_128 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No altered GO TO',INTO=RECOUT\n         TM    LE_STATUS_BYTE_21,BIT1\n         BNO   LE_370_129\n         STRING 'Program contains altered GO TO',INTO=RECOUT\nLE_370_129 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No I/O error declarative',INTO=RECOUT\n         TM    LE_STATUS_BYTE_21,BIT2\n         BNO   LE_370_130\n         STRING 'I/O error declarative',INTO=RECOUT\nLE_370_130 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No Label declarative',INTO=RECOUT\n         TM    LE_STATUS_BYTE_21,BIT3\n         BNO   LE_370_131\n         STRING 'Label declarative',INTO=RECOUT\nLE_370_131 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No debugging declarative',INTO=RECOUT\n         TM    LE_STATUS_BYTE_21,BIT4\n         BNO   LE_370_132\n         STRING 'Debugging declarative',INTO=RECOUT\nLE_370_132 DS 0H\n         STRING 'No program segmentation',INTO=RECOUT\n         BAS   R14,PRINT_MSG\n         TM    LE_STATUS_BYTE_21,BIT5\n         BNO   LE_370_133\n         STRING 'Programm segmentation',INTO=RECOUT\nLE_370_133 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No Open Extend',INTO=RECOUT\n         TM    LE_STATUS_BYTE_21,BIT6\n         BNO   LE_370_134\n         STRING 'Open Extend',INTO=RECOUT\nLE_370_134 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No exit program',INTO=RECOUT\n         TM    LE_STATUS_BYTE_21,BIT7\n         BNO   LE_370_135\n         STRING 'Exit Program',INTO=RECOUT\nLE_370_135 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No call literal',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT0\n         BNO   LE_370_136\n         STRING 'Call literal (static?), see options',INTO=RECOUT\nLE_370_136 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No call identifier',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT1\n         BNO   LE_370_137\n         STRING 'Call identifier',INTO=RECOUT\nLE_370_137 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No call on overflow',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT2\n         BNO   LE_370_138\n         STRING 'Call on overflow',INTO=RECOUT\nLE_370_138 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No call length of',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT3\n         BNO   LE_370_139\n         STRING 'Call length of',INTO=RECOUT\nLE_370_139 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No call address of',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT4\n         BNO   LE_370_140\n         STRING 'Call address',INTO=RECOUT\nLE_370_140 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No close reel/unit',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT5\n         BNO   LE_370_141\n         STRING 'Close reel/unit',INTO=RECOUT\nLE_370_141 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No exponentiation used',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT6\n         BNO   LE_370_142\n         STRING 'Exponentiation used',INTO=RECOUT\nLE_370_142 DS 0H\n         BAS   R14,PRINT_MSG\n         STRING 'No floating point items used',INTO=RECOUT\n         TM    LE_STATUS_BYTE_22,BIT7\n         BNO   LE_370_143\n         STRING 'Floating point items used',INTO=RECOUT\nLE_370_143 DS 0H\n         BAS   R14,PRINT_MSG\n         LA    R15,0\n         B     EXIT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Print message on SYSPRINT or via PUTLINE (TSO c.p.)         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPRINT_BLINE_MSG DS 0H\n         OI    X_FLAG1,$XF1_BLKL          Need a blank line\n*\n** Print message on output medium\n*\nPRINT_MSG EQU *\n         ST    R14,PM_RA                  Save return address\n         TM    X_FLAG1,$XF1_PL            PUTLINE?\n         BO    PM$XF1_PL                  Yes, do it\n         TM    X_FLAG1,$XF1_SPO           Have we opened the file yet?\n         BO    PM$PUTR                    Yes, continue\n         LA    R3,SYSPRINT                Locate DCB\n         MVC   0(C_DCBOL,R3),C_DCBO       Copy in DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'\n         MVC   PARMLIST(C_LSTOL),C_LSTO   Copy in OPEN parm list\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PARMLIST)\n         OI    X_FLAG1,$XF1_SPO\nPM$PUTR  DS    0H\n         DA#SMODE 24                      Get into 24 bit address mode\n         TM    X_FLAG1,$XF1_BLKL          Need a Blank line?\n         BNO   PM$PR1                     Yes, do it\n         PUT   SYSPRINT,BLANKS            Print a blank line\nPM$PR1   DS    0H\n         PUT   SYSPRINT,RECOUT            Print the message\n         DA#SMODE 31\n         NI    X_FLAG1,255-$XF1_BLKL      Turn off the flag\n         L     R14,PM_RA                  Get return address\n         BSM   0,R14                      Return to caller\nPM$XF1_PL EQU *\n         TM    X_FLAG1,$XF1_BLKL          Need a Blank line?\n         BNO   PM$PL1                     No, continue\n         PUTLINE PARM=PM_PBLK,                                         @\n               OUTPUT=(BLANKL,TERM,SINGLE,DATA),                       @\n               MF=(E,PM_IOPL)\nPM$PL1   DS    0H\n         PUTLINE PARM=PM_PBLK,                                         @\n               OUTPUT=(RECOUTH,TERM,SINGLE,DATA),                      @\n               MF=(E,PM_IOPL)\n         NI    X_FLAG1,255-$XF1_BLKL      Turn off the flag\n         L     R14,PM_RA                  Get return address\n         BSM   0,R14                      Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nBLANKL   DC    AL2(4+1,0)         Full word PUTLINE header\nBLANKS   DC    CL255' '           just blanks\n*\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\n*\n         PRINT NOGEN\nC_PBLK   PUTLINE MF=L\nC_PBLKL  EQU   *-C_PBLK\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_CLS    CLOSE (*-*),MF=L\nC_CLSL   EQU   *-C_CLS\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80\nC_DCBOL  EQU   *-C_DCBO\n         PRINT GEN\n*\n** Literals\n*\nLTORG    EQU   *\n         LTORG ,\nLTORGL   EQU   *-LTORG\n         DS    0D\n*\n** Generate STRING constants and CSECT\n*\n         STRING GENERATE\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Dynamic Save Area                                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDSA                 DSECT\n                    DS    18F   Register Save Area\nPGMNAME             DS    CL8   Pgmname from the parmlist\nADR_PGMNAME         DS    F     Save entry-point Application PGM\n                    DS    0F\nSYSPRINT            DS    XL(C_DCBOL)\n                    DS    0F\nPARMLIST            DS    8F\n*\n** Program information\n*\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of programm\nLE_COMP_YEAR        DS CL4  year of compilation\nLE_COMP_MONTH       DS CL2  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\n*\n** Misc fields\n*\n          DS    0F\n*                                         Print_Message\nPM_RA     DS    F                         ..Return Address\nPM_IOPL   DS    XL(#IOPL)                 ..Input/Output Parm List\nPM_PBLK   DS    XL(C_PBLKL)               ..PUTLINE block\nPM_ECB    DS    F                         ..Input/Output Parm List\n*\nX_FLAG1   DC    B'00000000'               X_FLAG1 byte\n$XF1_PL   EQU   B'10000000'               ..PUTLINE\n$XF1_BLKL EQU   B'01000000'               ..Need a blank line\n$XF1_SPO  EQU   B'00100000'               ..File open yet?\n$XF1_VS   EQU   B'00010000'               ..VS COBOL II?\n$XF1_LOAD EQU   B'00001000'               ..Did we load program?\n          DS    0H\nRECOUTH   DS    XL4                       Header\nRECOUT    DS    CL256                     Record output area\n          DS    0D\nDSAL      EQU   *-DSA\n          END\n./ ADD NAME=DA$DATE  0100-01266-01266-1821-02148-02148-00000-DAVE\n* =================================================================== *\n*\n* Name: DA$DATE\n*\n* Author = David Alcock :: dave@planetmvs.com\n*\n* Purpose: Date routine\n*          o Multiple input date/time formats\n*          o Multiple output date/time formats\n*          o Calendar processing\n*\n*          This routine processes an input parameter list that\n*          may consist of multiple input and output date and time\n*          formats. A most current version of the date is kept up\n*          to date based on the input received.  If an output type\n*          is found and no input found, the current date and time\n*          is used.  Some example parameter lists:\n*\n*             PARM=(output-julian,output-standard-time)\n*\n*             PARM=(input-gregorian,input-time,output-gregorian,\n*                   output-standard-time,output-calendar,\n*                   input-julian(newday!),output-gregorian)\n*\n*          As it processes the parameters, the input time and date\n*          will be altered.\n*\n* Warning: Now that we have the nice IBM-supplied date routines\n*          for assembler programs: STCKCONV and CONVTOD, why use a\n*          date routine like this one?  This program is used by my\n*          older programs before STCKCONV and CONVTOD.\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n* Non-IBM assembler MACROs:\n* o DA#DATE....Equates and DSECTs for the date routine\n* o DA#ENTER...Entry housekeeping\n* o DA#LEAVE...Termination housekeeping\n* o DA#EYEC....Build standard O/S module eyecatcher\n*              (invoked by the DA#ENTER)\n* o DA#REGS....Define registers (invoked by DA#ENTER)\n*\n* =================================================================== *\n         SPACE 2\n&DAVER   SETC  '2.4'\n* =================================================================== *\n*\n*           M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ------------------------------------------\n* DGAlcock   15-SEP-1999 2.4 Use STCKCON macro for TOD time stamps;\n* DGAlcock   09-SEP-1999 2.3 Added year windowing based on 1950;\n* DGAlcock   07-SEP-1999 2.2 Added input  ISO date format: ccyy-mm-dd;\n* DGAlcock   09-MAY-1997 2.1 Added output ISO date format: ccyy-mm-dd;\n* DGAlcock   05-MAY-1997 2.0 Added complete leap year calculation\n*                        (100 and 400 tests);\n* DGAlcock   23-FEB-1987 1.0 Initial program created;\n*\n* =================================================================== *\n         EJECT ,\n*\n** External DSECTS\n*\n         DA#DATE ,                        Map our DSECT and equates\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO          MVS CVT\n         PRINT GEN\n         EJECT ,\n***********************************************************************\n***\n**       Entry housekeeping\n***\n***********************************************************************\n         SPACE 2\nDA$DATE  DA#ENTER 'V&DAVER Subroutine: Ubiquitous Date routine',       @\n               LV=DSAL,RENT=YES,          GETMAIN area and length      @\n               AMODE=31,RMODE=ANY,        Any where in V/S             @\n               BASE=(12,11)               Base registers\n USING DSA,R13                            Get addressability to area\n LR    R2,R1                              Save Address of parms\n EJECT\n***********************************************************************\n***\n**       Process parameters\n**\n**       T_ROUT table is mapped by the TR DSECT\n***\n***********************************************************************\n SPACE 2\nI$L EQU *\n ST    R2,I_LA                            Save Current loop Address\n ICM   R8,B'1111',0(R2)                   Load address of string\n BZ    EXIT                               LEAVE if parm entry = 0...\n USING DA#DATED,R8                        Map the input parameter\n LA    R8,0(R8)                           Zero high order bit (if any)\n* Note: R8 is a \"Global\" register - do not change outside of \"I$\"\n*\n** Check table for routine address - input paramter\n*\n LA    R4,T_ROUT                          Locate table\n LA    R5,T_ROUTE                         Number of entries in table\nI$LRL EQU *\n CLC   TR_TYPE-TR(2,R4),DA#DATED_TYPE     Match?\n BE    I$LRLX                             Yes, branch to the routine\n LA    R4,8(R4)                           Bump to next entry\n BCT   R5,I$LRL                           ..and process it\n*\n** Invalid parameter entry - type not in table\n*\nI$INVALID_TYPE EQU *\n MVI   DA#DATED_FLAG,$DA#DATE_EITYPE      Invalid parm indication\n B     I$LB                               Ignore entry: not in table\n*\n** Found entry in table - Invoke the routine\n*\nI$LRLX EQU *\n BAS   R9,LOCATE_STRING                   Get output string addr: R15\n L     R14,TR_ROUT-TR(R4)                 Locate routine address\n BR    R14                                Do the routine\n B     I$LB                               Now - Check the return code\n*\n** Bump to next parameter entry\n*\nI$LB EQU *                                -> Return here after routine\n L     R2,I_LA                            Get loop address\n TM    0(R2),B'10000000'                  X'80' means end of list...\n BO    EXIT                               Yes, leave\n LA    R15,4                              Length of each parameter ptr\n AR    R2,R15                             Bump to next parameter ptr\n B     I$L                                ..Process next one\n*\n** Complete output: Calculate length of output string\n** Input: R15 - Points to the last byte in the string + 1\n*\nI$UPDATE_LENGTH EQU *\n DA#DATE STRLEN                           Calcuate string length\n B     I$LB                               Process next parameter\n*\n** Invalid length for input field found, - set result/return code\n*\nI$INVALID_STRLT EQU *\n MVI   S_TIME,$DA#DATE_INVALID            Indicate time was invalid\n B     I$INVALID_STR                      Move on\nI$INVALID_STRLD EQU *\n MVI   S_JDATE,$DA#DATE_INVALID           Indicate date was invalid\nI$INVALID_STRL EQU *\n MVI   DA#DATED_FLAG,$DA#DATE_EISTRL      Set: invalid string length\n B     I$LB\n*\n** Invalid input string found\n*\nI$INVALID_STRT EQU *\n MVI   S_TIME,$DA#DATE_INVALID            Indicate time was invalid\n B     I$INVALID_STR                      Move on\nI$INVALID_STRD EQU *\n MVI   S_JDATE,$DA#DATE_INVALID           Indicate date was invalid\nI$INVALID_STR  EQU *\n MVI   DA#DATED_FLAG,$DA#DATE_EISTR       Set: invalid string\n B     I$LB\n*\n** No Saved entry found\n*\nI$NO_SAVED_ENTRY EQU *\n MVI   DA#DATED_FLAG,$DA#DATE_ENOSAVE     Set flag\n B     I$LB\n EJECT\n***********************************************************************\n***\n**                 Common exit from DA#DATE\n***\n***********************************************************************\n SPACE 2\nEXIT EQU *\n DA#LEAVE ,                               Exit housekeeping\n EJECT ,\n***********************************************************************\n***\n**       Routine branch table\n***\n***********************************************************************\n SPACE 2\n PRINT DATA\nT_ROUT EQU *\n*\n** Date/Time stuff\n*\n DC AL2($DA#DATE_ODISO,0),AL4(OUTPUT_DATE_ISO)\n DC AL2($DA#DATE_ODGUS,0),AL4(OUTPUT_DATE_GREGORIAN)\n DC AL2($DA#DATE_ODGEUR,0),AL4(OUTPUT_DATE_GREGORIAN)\n DC AL2($DA#DATE_ODJUL,0),AL4(OUTPUT_DATE_JULIAN)\n DC AL2($DA#DATE_ODCAL,0),AL4(OUTPUT_DATE_CALENDAR)\n DC AL2($DA#DATE_ODCALND,0),AL4(OUTPUT_DATE_CALENDAR)\n DC AL2($DA#DATE_ODDOW,0),AL4(OUTPUT_DATE_DOW)\n DC AL2($DA#DATE_ODMONTHN,0),AL4(OUTPUT_DATE_MONTHN)\n DC AL2($DA#DATE_OTIMEM,0),AL4(OUTPUT_TIME_MILITARY)\n DC AL2($DA#DATE_OTIMES,0),AL4(OUTPUT_TIME_STANDARD)\n*\n DC AL2($DA#DATE_IDGUS,0),AL4(INPUT_DATE_GREGORIAN)\n DC AL2($DA#DATE_IDISO,0),AL4(INPUT_DATE_ISO8601)\n DC AL2($DA#DATE_IDJULP,0),AL4(INPUT_DATE_JULIAN_PACKED)\n DC AL2($DA#DATE_IDJULC,0),AL4(INPUT_DATE_JULIAN_CHARACTER)\n DC AL2($DA#DATE_ITDEC,0),AL4(INPUT_TIME_DECIMAL)\n DC AL2($DA#DATE_ITBIN,0),AL4(INPUT_TIME_BINARY)\n DC AL2($DA#DATE_ITIMES,0),AL4(INPUT_TIME_CHAR_STANDARD)\n DC AL2($DA#DATE_ITIMEM,0),AL4(INPUT_TIME_CHAR_MILITARY)\n DC AL2($DA#DATE_ISTMPC,0),AL4(INPUT_TIMESTAMP_CHARACTER)\n DC AL2($DA#DATE_ISTMPV,0),AL4(INPUT_TIMESTAMP_VALUE)\n*\n** End of Table\n*\nT_ROUTE EQU (*-T_ROUT)/4\n DS    0H\n PRINT NODATA\n EJECT ,\n***********************************************************************\n***\n**       Misc Internal Subroutines\n***\n***********************************************************************\n         SPACE 2\nLOCATE_STRING EQU *\n DA#DATE STRLOC\n BSM 0,R9\n*\n** Point to first blank in string (if any)\n** Input:  R0  - Length of string\n**         R15 - String\n** Output: R15 - First space in string\n*\nLOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '\n         BE    LFS$X\n         LA    R15,1(R15)\n         BCT   R0,LOCATE_FIRST_SPACE\nLFS$X    EQU   *\n         BSM   0,R14\n*\n** Suppress Leading Zeroes, (Will leave last zero)\n**\n** Input: R0  - Length of field\n**        R1  - Address of input\n**        R15 - Address to put output\n*\nSUPLZ     EQU   *\n          SH    R0,=H'1'                  Decrement count by 1\nSLZ$L     EQU   *\n          CLI   0(R1),C'0'                Zero?\n          BNE   SLZ$LX                    No, move rest to output\n          LA    R1,1(R1)                  Skip this byte\n          BCT   R0,SLZ$L                  ..process next one\n          MVC   0(1,R15),0(R1)            Move last byte to output\n          LA    R15,1(R15)                Bump past it\n          BR    R14                       Return to caller\nSLZ$LX    EQU   *\n          AH    R0,=H'1'                  Increment count\nSLZ$RL    EQU   *\n          MVC   0(1,R15),0(R1)            Move byte to output\n          LA    R1,1(R1)                  Bump input\n          LA    R15,1(R15)                Bump output\n          BCT   R0,SLZ$RL                 ..process next byte\n          BSM   0,R14                     Return to caller\n*\n** Clear output string to blanks\n** Input: R15 - address of string- ** Do not modify **\n*\nCLEAR_STRING EQU *\n SLR   R1,R1                              Zero out register\n IC    R1,DA#DATED_STRL                   Get output length\n BCTR  R1,0                               Decrement for EX\n BCTR  R1,0                               Decrement for MVC +1 stuff\n MVI   0(R15),C' '                        Move in blank\n MVC   1(0,R15),0(R15)                    ** Executed **\n EX    R1,*-6                             ..Propagate blank\n BSM   0,R9\n*\n** Convert a hex string from character\n** For example: From CL8'3020100E' to X'3020100E'\n**\n** Input: R0 - Length of output string (input / 2)\n**        R1 - Output location\n**        R15 - Input location\n*\nHEXTRAN EQU *\n STM   R3,R6,PARMLIST                     Save registers\nHT$MT EQU *\n MVI   0(R1),0                            Zero output byte\n LA    R4,1                               Offset for first hex char\n LA    R5,2                               Number of Nibbles in a byte\nHT$CL EQU *\n LA    R6,T_HEX                           Locate Hex table\n LA    R3,T_HEXE                          Number of entries in table\nHT$C1L EQU *\n CLC   0(1,R6),0(R15)                     Match?\n BE    HT$C1LX                            Yes, move on\n LA    R6,3(R6)                           No, bump to next byte\n BCT   R3,HT$C1L                          Repeat\n B     HT$X                               Character not valid\nHT$C1LX EQU *\n LA    R6,0(R4,R6)                        Bump to bitstring\n OC    0(1,R1),0(R6)                      Turn on bits for this nibble\n LA    R4,1(R4)                           Increment for next nibble\n LA    R15,1(R15)                         Bump to the next input byte\n BCT   R5,HT$CL                           Do next hex nibble in byte\n LA    R1,1(R1)                           Bump to next output byte\n BCT   R0,HT$MT                           ..do it\n SLR   R15,R15                            Clear register: success\nHT$X EQU *\n LM    R3,R6,PARMLIST                     Save registers\n BSM   0,R9\n*\n** HEX TABLE FORMAT:\n**   C'0'         - CHARACTER THAT WE ARE CONVERTING\n**   B'11110000'  - FIRST NIBBLE OF BYTE\n**   B'00001111'  - LAST NIBBLE OF BYTE\n*\nT_HEX    EQU   *\n         DC    C'0',B'00000000',B'00000000'\n         DC    C'1',B'00010000',B'00000001'\n         DC    C'2',B'00100000',B'00000010'\n         DC    C'3',B'00110000',B'00000011'\n         DC    C'4',B'01000000',B'00000100'\n         DC    C'5',B'01010000',B'00000101'\n         DC    C'6',B'01100000',B'00000110'\n         DC    C'7',B'01110000',B'00000111'\n         DC    C'8',B'10000000',B'00001000'\n         DC    C'9',B'10010000',B'00001001'\n         DC    C'A',B'10100000',B'00001010'\n         DC    C'B',B'10110000',B'00001011'\n         DC    C'C',B'11000000',B'00001100'\n         DC    C'D',B'11010000',B'00001101'\n         DC    C'E',B'11100000',B'00001110'\n         DC    C'F',B'11110000',B'00001111'\nT_HEXE   EQU   ((*-T_HEX)/(1+1+1))\n EJECT ,\n***********************************************************************\n***\n**              Input Gregorian date processing\n**\n**   Enhancement queue:\n**   - Add European support...\n***\n***********************************************************************\n SPACE 2\nINPUT_DATE_GREGORIAN EQU *\n*\n** Check for lengths\n*\n CLI   DA#DATED_STRL,$DA#DATE_IDGUS12\n BE    IDG$F12\n CLI   DA#DATED_STRL,$DA#DATE_IDGUS10\n BE    IDG$F10\n CLI   DA#DATED_STRL,$DA#DATE_IDGUS8\n BE    IDG$F8\n CLI   DA#DATED_STRL,$DA#DATE_IDGUS6\n BE    IDG$F6\n*\n B     I$INVALID_STRLD            Branch to invalid length code\n*\n** Field in format: \"MMM DD, CCYY\"\n*                    012345678\nIDG$F12 EQU *\n LA    R1,T_MONTH                         Locate month table\n LA    R0,T_MONTHE                        Get number of entries\n MVC   DOUBLE(3),0(R15)                   Get the month\n OC    DOUBLE(3),=CL3' '                  Make uppercase\nIDG$F12L EQU *\n MVC   DOUBLE+3(3),TM_NAME-TM(R1)         Get table entry month\n OC    DOUBLE+3(3),=CL3' '                Make uppercase\n CLC   DOUBLE(3),DOUBLE+3                 Month match?\n BE    IDG$F12LX                          Yes, move on\n LA    R1,TML(R1)                         Bump to next month entry\n BCT   R0,IDG$F12L                        Repeat\n B     I$INVALID_STRD                     Month not in table...\nIDG$F12LX EQU *\n LA    R2,TM_NUMC-TM(R1)                  Locate month\n LA    R3,4(R15)                          Make day of month\n LA    R4,8(R15)                          Locate century\n B     IDG$X                              Field location complete\n*\n** Field in format: \"MM/DD/CCYY\"\n*                    012345678\nIDG$F10 EQU *\n LA    R2,0(R15)                          Locate month\n LA    R3,3(R15)                          Locate day of month\n LA    R4,6(R15)                          Locate century\n B     IDG$X                              Field location complete\n*\n** Field in format: \"MM/DD/YY\"\n*                    012345678\nIDG$F8 EQU *\n LA    R2,0(R15)                          Locate month\n LA    R3,3(R15)                          Locate day of month\n LA    R4,W_CCYY                          Locate YYYY area\n*MVC   0(2,R4),=C'19'                     Move in 19\n MVC   2(2,R4),6(R15)                     Get year\n BAS   R14,PERFORM_YEAR_WINDOW            Get a good century\n B     IDG$X                              Field location complete\n*\n** Field in format: MMDDYY\n*                   012345\nIDG$F6 EQU *\n LA    R2,0(R15)                          Locate month\n LA    R3,2(R15)                          Locate day of month\n LA    R4,W_CCYY                          Locate YYYY area\n*MVC   0(2,R4),=C'19'                     Move in 19\n MVC   2(2,R4),4(R15)                     Get year\n BAS   R14,PERFORM_YEAR_WINDOW            Get a good century\n*\n** Ensure that the input is valid numeric\n*\nIDG$X  EQU *\n LA    R1,W_GDATE                         Locate \"MMDDCCYY\" field\n MVC   0(2,R1),0(R2)                      ==>     MM\n MVC   2(2,R1),0(R3)                      ==>       DD\n MVC   4(4,R1),0(R4)                      ==>         CCYY\n*\n LA    R2,0(R1)                           Reset MM location\n LA    R3,2(R1)                           Reset DD location\n LA    R4,4(R1)                           Reset CCYY location\n*\n LA    R0,8                               Length to check\n BAS   R14,ENSURE_NUMERICS                Ensure numerics\n LTR   R15,R15                            All okay?\n BNZ   I$INVALID_STRD                     Nope, move on\n*\n** Call conversion routines until S_JDATE has \"CCYYDDDF\"\n*\n LA    R6,PARMLIST+20                     Output location for DOY\n BAS   R9,RETURN_DAY_OFTHE_YEAR           Get Day of the year\n*\n LA    R3,1(R6)                           Locate \"DDD\"\n*Note: R4 still points to \"CCYY\"\n LA    R6,S_JDATE                         Output addr for julian date\n BAS   R9,RETURN_JULIAN_PACKED            Change character to packed\n B     I$LB                               Return address\n EJECT ,\n***********************************************************************\n***\n**              Input Gregorian date in ISO 8601 format\n**\n**              Format: ccyy-mm-dd\n***\n***********************************************************************\n SPACE 2\nINPUT_DATE_ISO8601 DS 0H\n*\n** Check for lengths\n*\n CLI   DA#DATED_STRL,$DA#DATE_IDISO10\n BE    IDI$F10\n*\n B     I$INVALID_STRLD            Branch to invalid length code\n*\n** Field in format: \"CCYY-MM-DD\"\n*                    012345678\nIDI$F10 EQU *\n LA    R2,5(R15)                          Locate month\n LA    R3,8(R15)                          Locate day of month\n LA    R4,0(R15)                          Locate century\n*B     IDI$X                              Field location complete\n*\n** Ensure that the input is valid numeric\n*\nIDI$X  EQU *\n LA    R1,W_GDATE                         Locate \"MMDDCCYY\" field\n MVC   0(2,R1),0(R2)                      ==>     MM\n MVC   2(2,R1),0(R3)                      ==>       DD\n MVC   4(4,R1),0(R4)                      ==>         CCYY\n*\n LA    R2,0(R1)                           Reset MM location\n LA    R3,2(R1)                           Reset DD location\n LA    R4,4(R1)                           Reset CCYY location\n*\n LA    R0,8                               Length to check\n BAS   R14,ENSURE_NUMERICS                Ensure numerics\n LTR   R15,R15                            All okay?\n BNZ   I$INVALID_STRD                     Nope, move on\n*\n** Call conversion routines until S_JDATE has \"CCYYDDDF\"\n*\n LA    R6,PARMLIST+20                     Output location for DOY\n BAS   R9,RETURN_DAY_OFTHE_YEAR           Get Day of the year\n*\n LA    R3,1(R6)                           Locate \"DDD\"\n*Note: R4 still points to \"CCYY\"\n LA    R6,S_JDATE                         Output addr for julian date\n BAS   R9,RETURN_JULIAN_PACKED            Change character to packed\n B     I$LB                               Return address\n EJECT ,\n***********************************************************************\n***\n**                Input System Time Stamp\n***\n***********************************************************************\n SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**        System time stamp - input is double word value\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_TIMESTAMP_VALUE EQU *\n CLI   DA#DATED_STRL,$DA#DATE_ISTMPV8     Correct length?\n BNE   I$INVALID_STRLD                    Invalid?\n MVC   DOUBLE(8),0(R15)                   Get value\n*\n LA    R3,DOUBLE                          Locate input time stamp value\n LA    R5,S_TIME                          Locate output time\n LA    R6,S_JDATE                         Locate output date\n BAS   R9,CONVERT_TIMESTAMP               Convert Time stamp\n LTR   R15,R15                            Ensure STCKCON worked ok\n BNZ   I$INVALID_STRLD                    No, gripe about it\n B     I$LB\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**        System time stamp - input in character format\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_TIMESTAMP_CHARACTER EQU *\n CLI   DA#DATED_STRL,$DA#DATE_ISTMPC16    Correct length?\n BNE   I$INVALID_STRLD                    Invalid?\n*\n MVC   DWA(16),0(R15)                     Get the input string\n OC    DWA(16),=CL16' '                   Ensure uppercase\n*\n** Convert the character string to the true value\n*\n LA    R1,DOUBLE                          Locate output double word\n LA    R15,DWA                            Locate input hex characters\n LA    R0,8                               Length of input string / 2\n BAS   R9,HEXTRAN                         Translate to hex value\n BXH   R15,R15,I$INVALID_STRD             Check for invalid string\n*\n LA    R3,DOUBLE                          Locate input time stamp value\n LA    R5,S_TIME                          Locate output time\n LA    R6,S_JDATE                         Locate output date\n BAS   R9,CONVERT_TIMESTAMP               Convert Time stamp\n LTR   R15,R15                            Ensure STCKCON worked ok\n BNZ   I$INVALID_STRLD                    No, gripe about it\n B     I$LB\n EJECT\n***********************************************************************\n***\n**       Input Julian (IBM) date processing\n***\n***********************************************************************\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**    Input julian date - Packed format\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_DATE_JULIAN_PACKED EQU *\n CLI   DA#DATED_STRL,$DA#DATE_IDJULP3     yydddF ?\n BE    IDJULP3                            move on\n CLI   DA#DATED_STRL,$DA#DATE_IDJULP4     ccyydddF ?\n BNE   I$INVALID_STRLD                    Invalid?\n MVC   S_JDATE(4),0(R15)                  Move in Input PL4'ccyyddd'\n B     I$LB\nIDJULP3  EQU   *\n MVI   S_JDATE,0                          Set century byte to zero\n MVC   S_JDATE+1(3),0(R15)                Move in Input PL3'yyddd'\n B     IDJ$X                              Ensure valid julian date\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**          Input Julian Date - Character format\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_DATE_JULIAN_CHARACTER EQU *\n*\n** Check length\n*\n CLI   DA#DATED_STRL,$DA#DATE_IDJULC5     YYDDD    - 62065\n BE    IDJC$5\n CLI   DA#DATED_STRL,$DA#DATE_IDJULC6     YY.DDD   - 62.064\n BE    IDJC$6\n CLI   DA#DATED_STRL,$DA#DATE_IDJULC7     CCYYDDD  - 1962064\n BE    IDJC$7\n CLI   DA#DATED_STRL,$DA#DATE_IDJULC8     CCYY.DDD - 1962.064\n BE    IDJC$8\n B     I$INVALID_STRLD                    Branch to invalid length code\n*\n** Julian character format: \"YYDDD\"\n*                            01234\nIDJC$5 EQU *\n LA    R3,2(R15)                          Locate \"DDD\"\n LA    R4,DOUBLE                          Locate work location\n*MVC   0(2,R4),=C'19'                     Default for century\n MVC   2(2,R4),0(R15)                     Move in YY\n BAS   R14,PERFORM_YEAR_WINDOW            Get a good century\n B     IDJC$X\n*\n** Julian character format: \"YY.DDD\"\n*                            0123\nIDJC$6 EQU *\n LA    R3,3(R15)                          Locate \"DDD\"\n LA    R4,DOUBLE                          Locate year location\n*MVC   0(2,R4),=C'19'                     Make it this century\n MVC   2(2,R4),0(R15)                     Move in YYDDD\n BAS   R14,PERFORM_YEAR_WINDOW            Get a good century\n B     IDJC$X\n*\n** Julian character format: \"CCYYDDD\"\n*                            01234\nIDJC$7 EQU *\n LA    R3,4(R15)                          Locate \"DDD\"\n LA    R4,0(R15)                          Locate \"CCYY\"\n B     IDJC$X\n*\n** Julian character format: \"CCYY.DDD\"\n*                            012345\nIDJC$8 EQU *\n LA    R3,5(R15)                          Locate \"DDD\"\n LA    R4,0(R15)                          Locate \"CCYY\"\n*\n** Exit from Input_Date_Julian_Character\n*\nIDJC$X EQU *\n LA    R1,PARMLIST                        Locate work area\n MVC   0(4,R1),0(R4)                      Move in \"CCYY\"\n MVC   4(3,R1),0(R3)                      Move in \"DDD\"\n LA    R0,7                               Length to check\n BAS   R14,ENSURE_NUMERICS                Ensure numerics\n LTR   R15,R15                            All okay?\n BNZ   I$INVALID_STRD                     Nope, move on\n*\n LA    R6,S_JDATE                         Output location\n BAS   R9,RETURN_JULIAN_PACKED            Convert value\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**               Ensure that the input date is correct\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nIDJ$X EQU *\n LA    R3,S_JDATE                         Locate packed Julian date\n BAS   R9,ENSURE_VALID_JULIAN             Ensure the number is valid\n LTR   R15,R15                            Valid?\n BZ    I$LB                               Yes, move on\n B     I$INVALID_STRD                     Leave\n EJECT ,\n***********************************************************************\n***\n**       Input Time\n***\n***********************************************************************\n SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**    Input time character - Standard - based on a 12 hour clock\n**                           with AM or PM appended\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_TIME_CHAR_STANDARD EQU *\n MVI   DOUBLE,C'0'                       Get zero\n MVC   DOUBLE+1(7),DOUBLE                ..Propagate it\n*\n CLI   DA#DATED_STRL,$DA#DATE_ITIMES14\n BE    ITCS$14\n CLI   DA#DATED_STRL,$DA#DATE_ITIMES11\n BE    ITCS$11\n CLI   DA#DATED_STRL,$DA#DATE_ITIMES8\n BE    ITCS$8\n CLI   DA#DATED_STRL,$DA#DATE_ITIMES6\n BE    ITCS$6\n CLI   DA#DATED_STRL,$DA#DATE_ITIMES5\n BNE   I$INVALID_STRLD                    No, invalid\n*\nITCS$5 EQU *                              HHMMa to HHMM0000 A\n MVC   DOUBLE(4),0(R15)\n MVC   DWA(1),4(R15)\n B     ITCS$CONVERT\nITCS$6 EQU *                              HH:MMa to HHMM0000 A\n MVC   DOUBLE(2),0(R15)\n MVC   DOUBLE+2(2),3(R15)\n MVC   DWA(1),5(R15)\n B     ITCS$CONVERT\nITCS$8 EQU *                              HH:MM am to HHMM0000 A\n MVC   DOUBLE(2),0(R15)\n MVC   DOUBLE+2(2),3(R15)\n MVC   DWA(1),6(R15)\n B     ITCS$CONVERT\nITCS$11 EQU *                             HH:MM:SS am to HHMMSS00 A\n MVC   DOUBLE(2),0(R15)\n MVC   DOUBLE+2(2),3(R15)\n MVC   DOUBLE+4(2),6(R15)\n MVC   DWA(1),9(R15)\n B     ITCS$CONVERT\nITCS$14 EQU *                             HH:MM:SS.th am to HHMMSSTH A\n MVC   DOUBLE(2),0(R15)\n MVC   DOUBLE+2(2),3(R15)\n MVC   DOUBLE+4(2),6(R15)\n MVC   DOUBLE+6(2),9(R15)\n MVC   DWA(1),12(R15)\n*B     ITCS$CONVERT\n*\n** Need to convert hours based on AM or PM\n*\nITCS$CONVERT EQU *\n OI    DWA,C' '                           Convert xM to uppercase\n CLI   DWA,C'P'                           PM?\n BNE   ITC$CONVERT                        No: AM or assume that it is\n LA    R0,2                               Get length of input time\n LA    R1,DOUBLE                          Locate input time area\n BAS   R14,ENSURE_NUMERICS                Ensure its all valid nums\n LTR   R15,R15                            Valid?\n BNZ   I$INVALID_STRD                     No, gripe about it\n PACK  DWA(8),DOUBLE(2)                   Make packed\n CVB   R1,DWA                             Make hour binary\n AH    R1,=H'12'                          Add 12 to make it military\n CVD   R1,DWA                             Convert back to packed\n UNPK  PARMLIST(4),DWA+6(2)               Convert packed to zoned\n OI    PARMLIST+3,C'0'                    Fix sign byte\n MVC   DOUBLE(2),PARMLIST+2               Move hours to output area\n B     ITC$CONVERT\n SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**    Input time character - Miltary - based on a 24 hour clock\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_TIME_CHAR_MILITARY EQU *\n MVI   DOUBLE,C'0'                       Get zero\n MVC   DOUBLE+1(7),DOUBLE                ..Propagate it\n CLI   DA#DATED_STRL,$DA#DATE_ITIMEM11\n BE    ITCM$11\n CLI   DA#DATED_STRL,$DA#DATE_ITIMEM8\n BE    ITCM$8\n CLI   DA#DATED_STRL,$DA#DATE_ITIMEM6\n BE    ITCM$6\n CLI   DA#DATED_STRL,$DA#DATE_ITIMEM5\n BE    ITCM$5\n CLI   DA#DATED_STRL,$DA#DATE_ITIMEM4\n BNE   I$INVALID_STRLD                    No, invalid\nITCM$4 EQU *                              HHMM to HHMM0000\n MVC   DOUBLE(4),0(R15)\n B     ITC$CONVERT\nITCM$5 EQU *                              HH:MM to HHMM0000\n MVC   DOUBLE(2),0(R15)\n MVC   DOUBLE+2(2),3(R15)\n B     ITC$CONVERT\nITCM$6 EQU *                              HHMMSS to HHMMSS00\n MVC   DOUBLE(6),0(R15)\n B     ITC$CONVERT\nITCM$8 EQU *                              HH:MM:SS to HHMMSS00\n MVC   DOUBLE(2),0(R15)\n MVC   DOUBLE+2(2),3(R15)\n MVC   DOUBLE+4(2),6(R15)\n B     ITC$CONVERT\nITCM$11 EQU *                             HH:MM:SS.th to HHMMSSTH\n MVC   DOUBLE(2),0(R15)\n MVC   DOUBLE+2(2),3(R15)\n MVC   DOUBLE+4(2),6(R15)\n MVC   DOUBLE+6(2),9(R15)\n*B     ITC$CONVERT\n SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**    Input time character - Convert DOUBLE from character to\n**                           TIME DEC (binary)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nITC$CONVERT EQU *\n LA    R0,8                               Get length of input time\n LA    R1,DOUBLE                          Locate input time area\n BAS   R14,ENSURE_NUMERICS                Ensure its all valid nums\n LTR   R15,R15                            Valid?\n BNZ   I$INVALID_STRD                     No, gripe about it\n*\n LA    R1,S_TIME                          Locate output area\n LA    R15,DOUBLE                         Locate input hex characters\n LA    R0,4                               Length of input string / 2\n BAS   R9,HEXTRAN                         Translate to hex value\n B     I$LB                               Done!\n SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**    Input time Decimal - like from \"TIME DEC\" macro\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_TIME_DECIMAL EQU *\n CLI   DA#DATED_STRL,$DA#DATE_ITDEC4      HHMMSSTH ?\n BNE   I$INVALID_STRLD                    No, invalid\n MVC   S_TIME(4),0(R15)                   Move in Input X'HHMMSSTH'\n B     I$LB                               Leave\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**        Time in binary - Seconds from midnight?\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nINPUT_TIME_BINARY EQU *\n         CLI   DA#DATED_STRL,$DA#DATE_ITBIN4\n         BNE   I$INVALID_STRLT            Invalid?\n         L     R5,0(R15)                  Get Time in R5\n* Note: This code was liberated from Skip Abadie's BDATE program\n         SLR   R4,R4                      CLEAR REMAINDER\n         D     R4,=F'100'                 EXTRACT 1/100 SEC\n         CVD   R4,DOUBLE                  MAKE DEC IN WORK AREA\n         ZAP   DWA(5),DOUBLE              ACCUMULATE 1/100 SECS\n         SR    R4,R4                      CLEAR REMAINDER\n         D     R4,=F'60'                  EXTRACT SECONDS\n         MH    R4,=H'100'                 SHIFT LEFT 2 POSITIONS\n         CVD   R4,DOUBLE                  MAKE DEC IN WORK AREA\n         AP    DWA(5),DOUBLE              BUILD SECONDS\n         SR    R4,R4                      CLEAR REMAINDER\n         D     R4,=F'60'                  EXTRACT MINUTES\n         MH    R4,=H'10000'               SHIFT LEFT 4 POSITIONS\n         CVD   R4,DOUBLE                  MAKE DEC IN WORK AREA\n         AP    DWA(5),DOUBLE              BUILD MINUTES\n         M     R4,=F'1000000'             MOVE LEFT 6 POSITIONS\n         CVD   R5,DOUBLE                  EXTRACT HOURS IN WORK AREA\n         AP    DWA(5),DOUBLE              BUILD HOURS\n         LM    R2,R3,DWA                  Get time generated\n         SLDA  R2,4                       It's four bits off...\n         ST    R2,S_TIME                  Save the time to current loc\n         B     I$LB                       Leave\n EJECT\n***********************************************************************\n***\n**                Output Calendar processing\n***\n***********************************************************************\n SPACE 2\nOUTPUT_DATE_CALENDAR EQU *\n BAS   R9,D$CHK                           Check date\n BAS   R9,LOCATE_STRING                   Locate output location\n LR    R5,R15                             Save output location\n*\n** Get month entry for this Gregorian Date\n*\n PACK  DOUBLE(8),W_GDATE(2)               Pack the month \"MMddccyy\"\n CVB   R2,DOUBLE                          Make month binary\n PACK  DOUBLE(8),W_GDATE+4(4)             Pack the Year: \"mmddCCYY\"\n CVB   R4,DOUBLE                          Make Year binary\n BAS   R14,RETURN_MONTH_ENTRY             Get month entry\n LR    R6,R15                             Save address of month entry\n*\n** Clear area to blanks\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODCALV      Hex value\n BE    ODCAL$CLRV                         Yes, do it\n MVI   0(R5),C' '                         Move in blanks\n MVC   1($DA#DATE_ODCALC-1,R5),0(R5)      ..propagate it\n*\n MVC   1(9,R5),TM_NAME-TM(R6)            Move in month Name\n MVC   $DA#DATE_ODCALC_WEEKL-4(4,R5),W_GDATE+4 Move in CCYY\n LA    R5,$DA#DATE_ODCALC_WEEKL(R5)       Bump to next \"Week\"\n*\n MVC   0(C_HEADL,R5),C_HEAD               Move in heading line\n LA    R5,$DA#DATE_ODCALC_WEEKL(R5)       Bump to next \"Week\"\n B     ODCAL$CLRX                         Move on\nODCAL$CLRV EQU *\n MVI   0(R5),0                            Move in zero\n MVC   1($DA#DATE_ODCALV-1,R5),0(R5)      ..propagate it\nODCAL$CLRX EQU *\n*\n** Calculate the first day of the month and locate starting output\n** location\n*\n LA    R2,W_GDATE+0                       Locate \"MM\" in \"MMDDCCYY\"\n LA    R3,=C'01'                          Based on first day of month\n LA    R4,W_GDATE+4                       Locate \"CCYY\" in \"MMDDCCYY\"\n BAS   R9,RETURN_DOW                      Return the day of the week\n*\n SLR   R1,R1                              Clear register\n IC    R1,TD_NUM-TD(R15)                  Get DOW number (start w/Sun)\n CLI   DA#DATED_STRL,$DA#DATE_ODCALV      Hex value\n BE    ODCAL$DSOX                         Yes, skip multiply\n MH    R1,=AL2($DA#DATE_ODCALC_DATEEL)    Offset for first day of month\nODCAL$DSOX EQU *\n AR    R5,R1                              Locate in output area\n*\n** Get number of days in month\n*\n SLR   R1,R1                              Clear register\n IC    R1,TM_DIM-TM(R6)                   Get Days-in-Month\n CLI   DA#DATED_STRL,$DA#DATE_ODCALV      Hex value\n BE    ODCAL$VX                           Yes, finish up\n MH    R1,=AL2($DA#DATE_ODCALC_DATEEL)    Offset for first day of month\n BCTR  R1,0                               Decrement for EX\n EX    R1,ODCAL$MM                        Move numbers to output area\n*\n** Place \"**\" in the day of the month\n*\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODCALND)\n BE    CAL$X                              Yes...\n PACK  DOUBLE(8),W_GDATE+2(2)             Pack the month \"mmDDccyy\"\n CVB   R15,DOUBLE                         Make month binary\n BCTR  R15,0                              Decrement by 1\n MH    R15,=AL2($DA#DATE_ODCALC_DATEEL)   Offset for first day of month\n AR    R15,R5                             Locate day entry\n MVC   1(2,R15),=C'**'                    Move in placemark\nCAL$X EQU *\n B    I$LB                                Return to loop\nODCAL$MM MVC   0(0,R5),C_MONTHC\n*\n** Hex value processing exit\n** R1 has number of days\n*\nODCAL$VX EQU *\n BCTR R1,0                                Decrement for EX\n EX   R1,ODCAL$VM                         Move in table\n B    I$LB                                Return to loop\nODCAL$VM MVC  0(0,R5),C_MONTHV\n EJECT\n***********************************************************************\n***\n**                Output ISO Date processing\n**\n** Date format proposed by the International Standards Organization\n** (ISO):\n**\n**   - The order in which year, month and day are expressed:\n**     Year, then month, then day.\n**\n**   - The manner in which the three numbers, when written, are set\n**     off from each other: The \"-\" sign is used to separate them.\n**\n**   - Whether the numbers less than 10 are written with a leading\n**     zero:  Yes; for example the third is expressed as \"03\".\n***\n***********************************************************************\n SPACE 2\nOUTPUT_DATE_ISO DS 0H\n BAS   R9,D$CHK                           Check date\n BAS   R9,LOCATE_STRING                   Locate output location\n BAS   R9,CLEAR_STRING                    Clear output to blanks\n*\n** Check length\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODISO10\n BE    ODI$S\n B     I$INVALID_STRL\n*\n**                   01234567       0123456789\n** Convert W_GDATE (\"mmddccyy\") to \"ccyy-mm-dd\"\n*\nODI$S  DS 0H                              \"ccyy-mm-dd\"\n MVC   0(4,R15),W_GDATE+4                 Get \"ccyy\"\n MVI   4(R15),C'-'\n MVC   5(2,R15),W_GDATE                   Move in month\n MVI   7(R15),C'-'\n MVC   8(2,R15),W_GDATE+2                 Move in day of the month\n LA    R15,10(R15)                        Bump past \"ccyy-mm-dd\"\n B     I$UPDATE_LENGTH                    Now, complete the length\n EJECT\n***********************************************************************\n***\n**                Output Gregorian Date processing\n***\n***********************************************************************\n SPACE 2\nOUTPUT_DATE_GREGORIAN EQU *\n BAS   R9,D$CHK                           Check date\n BAS   R9,LOCATE_STRING                   Locate output location\n BAS   R9,CLEAR_STRING                    Clear output to blanks\n*\n** Check length\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS29\n BNL   ODG$F29\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS23\n BNL   ODG$F23\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS18\n BNL   ODG$F18\n CLI   DA#DATED_STRL,$DA#DATE_ODGEUR11   ODGUS12/ODGEUR11 are similiar\n BNL   ODG$F12\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS10\n BNL   ODG$F10\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS8T\n BE    ODG$F8T\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS8\n BNL   ODG$F8\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS6\n BNL   ODG$F6\n B     I$INVALID_STRL\n*\n** Output: \"DayOfWeek, Month DD CCYY\" (US)\n**          or \"DayofWeek DD Month CCYY\" (European)\n*\nODG$F29 EQU    *\n*\n** Output: \"DOW, Month DD CCYY\" (US) \u00a6 \"DOW, DD Month CCYY\" (European)\n*\nODG$F23 EQU    *\n ST    R15,PARMLIST                       Save output location\n LA    R2,W_GDATE+0                       Locate \"MM\" in \"MMDDCCYY\"\n LA    R3,W_GDATE+2                       Locate \"DD\" in \"MMDDCCYY\"\n LA    R4,W_GDATE+4                       Locate \"CCYY\" in \"MMDDCCYY\"\n BAS   R9,RETURN_DOW                      Return the day of the week\n LR    R1,R15                             Get T_DOW entry\n L     R15,PARMLIST                       Get output location\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS29     Short form of DOW?\n BL    ODG$F23D                           Yes, move on\n SLR   R14,R14                            Clear register\n IC    R14,TD_NAMEL-TD(R1)                Get name length\n MVC   0(0,R15),TD_NAME-TD(R1)            ** Executed **\n EX    R14,*-6                            Move in day of the week\n LA    R15,1(R14,R15)                     Bump past it\n B     ODG$F23C\nODG$F23D EQU *\n MVC   0(3,R15),TD_NAME-TD(R1)            Move in Day of week (3 char)\n OC    0(3,R15),=CL3' '                   Ensure uppercase\n LA    R15,3(R15)                         Bump past it\nODG$F23C EQU *\n MVI   0(R15),C','                        Insert a comma\n LA    R15,2(R15)                         Bump past comma\nODG$F23CX EQU *\n*\n** Output: \"Month DD CCYY\" (US) \u00a6  \"DD month CCYY\" (European)\n*\nODG$F18 EQU    *\n*\n** Output: \"MMM-DD-CCYY\" (US) \u00a6 \"DD-MMM-CCYY\" (European)\n*\nODG$F12 EQU    *\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BNE   ODG$F12EDX                         No, move on\n MVC   0(2,R15),W_GDATE+2                 Get day of the month\n MVI   2(R15),C'-'                        Fix\n LA    R15,3(R15)                         Bump past it\n*\nODG$F12EDX EQU *\n PACK  DOUBLE(8),W_GDATE(2)               Pack the month \"MMddccyy\"\n CVB   R2,DOUBLE                          Make month binary\n PACK  DOUBLE(8),W_GDATE+4(4)             Pack the Year: \"mmddCCYY\"\n CVB   R4,DOUBLE                          Make Year binary\n ST    R15,PARMLIST                       Save location\n BAS   R14,RETURN_MONTH_ENTRY             Return the month entry\n LR    R1,R15                             Get month entry\n L     R15,PARMLIST                       Get location\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS18     Only need 3 characters?\n BL    ODG$F12T                           Yes, move on\n SLR   R14,R14                            Clear register\n IC    R14,TM_NAMEL-TM(R1)                Get month length\n MVC   0(0,R15),TM_NAME-TM(R1)            ** Executed **\n EX    R14,*-6                            Move in Month name\n LA    R15,1(R14,R15)                     Bump past it\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BNE   ODG$F12MD                          No, don't need dash\n MVI   0(R15),C'-'                        Insert a dash\nODG$F12MD EQU *\n LA    R15,1(R15)                         Bump past it\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BE    ODG$F10Y                           Yes, don't need Date again\n B     ODG$F12D                           Move on\nODG$F12T EQU *\n MVC   0(3,R15),TM_NAME-TM(R1)            Move in month name\n OC    0(3,R15),=CL3' '                   Ensure uppercase\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS18     Need dash?\n BH    ODG$F18DL                          No, move on\n MVI   3(R15),C'-'                        Fix\nODG$F18DL EQU *\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BNE   ODG$F12EMX                         No, move on\n LA    R15,4(R15)                         Bump past \"MMM \"\n B     ODG$F10Y                           Do year now\nODG$F12EMX EQU *\n LA    R15,4(R15)                         Bump past \"MMM \"\nODG$F12D EQU *\n MVC   0(2,R15),W_GDATE+2                 Get day of the month\n LA    R15,3(R15)                         Bump past month\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS18     Need comma?\n BL    ODG$F12DD                          No, move on\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BE    ODG$F10Y                           Yes, move on\n BCTR  R15,0                              Backup over extra space\n MVI   0(R15),C','                        Insert a comma\n LA    R15,2(R15)                         Bump past comma\n B     ODG$F10Y\nODG$F12DD EQU *\n BCTR  R15,0                              Backup over extra space\n MVI   0(R15),C'-'                        Insert a comma\n LA    R15,1(R15)                         Bump past comma\n B     ODG$F10Y\n*\n** Output: \"MM/DD/CCYY\" (US) \u00a6 \"DD/MM/CCYY\" (European)\n*\nODG$F10 EQU *\n*\n** Output: \"MM/DD/YY\" (US) \u00a6 \"DD/MM/YY\" (European)\n*\nODG$F8 EQU *\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BNE   ODG$F8EX                           No, do US\n MVC   0(2,R15),W_GDATE+2                 Move in day of the month\n LA    R15,2(R15)                         Bump past it\n MVI   0(R15),C'/'                        Slash\n MVC   1(2,R15),W_GDATE                   Move in month\n B     ODG$F8UX                           Move on\nODG$F8EX EQU *\n MVC   0(2,R15),W_GDATE                   Move in month\n LA    R15,2(R15)                         Bump past it\n MVI   0(R15),C'/'                        Slash\n MVC   1(2,R15),W_GDATE+2                 Move in day of the month\nODG$F8UX EQU *\n MVI   3(R15),C'/'                        Insert delimiter\n LA    R15,4(R15)                         Bump past \"/xx/\"\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODGUS8      Doing mm/dd/yy code?\n BNH   ODG$F8Y                            Yes, get the year\nODG$F10Y EQU *\n MVC   0(2,R15),W_GDATE+4                 Get two byte century\n LA    R15,2(R15)                         Bump past the century\nODG$F8Y EQU    *\n MVC   0(2,R15),W_GDATE+6                 Move in year - \"MMDDCCYY\"\n LA    R15,2(R15)                         Bump to Past year\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\n** Output: \"MMDDCCYY\" (US) \u00a6 \"DDMMCCYY\" (European)\n*\nODG$F8T EQU    *\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BE    ODG$F8TE                           Yes, do year now\n MVC   0(8,R15),W_GDATE                   Move \"MMDD\"\n LA    R15,8(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\nODG$F8TE EQU *\n MVC   0(2,R15),W_GDATE+2                 Get DD\n MVC   2(2,R15),W_GDATE                   Get MM\n MVC   4(4,R15),W_GDATE+4                 Get CCYY\n LA    R15,8(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\n** Output: \"MMDDYY\" (US) \"DDMMYY\" (European)\n*\nODG$F6 EQU     *\n CLC   DA#DATED_TYPE(2),=AL2($DA#DATE_ODGEUR) European format?\n BE    ODG$F6E                            Yes, do year now\n MVC   0(4,R15),W_GDATE                   Move \"MMDD\"\n MVC   4(2,R15),W_GDATE+6                 Get \"YY\" from \"MMDDCCYY\"\n LA    R15,6(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\nODG$F6E EQU *\n MVC   0(2,R15),W_GDATE+2                 Get DD\n MVC   2(2,R15),W_GDATE                   Get MM\n MVC   4(2,R15),W_GDATE+6                 Get YY\n LA    R15,6(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n EJECT ,\n***********************************************************************\n***\n**       Julian (IBM) processing\n***\n***********************************************************************\n SPACE 2\nOUTPUT_DATE_JULIAN EQU *\n BAS   R9,D$CHK                           Check the date\n BAS   R9,LOCATE_STRING                   Locate output location\n BAS   R9,CLEAR_STRING                    Clear output to blanks\n CLI   DA#DATED_STRL,$DA#DATE_ODJUL8\n BNL   ODJ$F8\n CLI   DA#DATED_STRL,$DA#DATE_ODJUL6\n BNL   ODJ$F6\n CLI   DA#DATED_STRL,$DA#DATE_ODJUL5\n BNL   ODJ$F5\n CLI   DA#DATED_STRL,$DA#DATE_ODJUL3\n BNL   ODJ$F3\n B     I$INVALID_STRL                     Branch to invalid length code\n*\n** Output: CCYY.DDD\n*\nODJ$F8 EQU *\n LA    R1,S_JDATE                         Locate century input area\n MVC   0(2,R15),W_GDATE+4                 Get two century: \"MMDDCCYY\"\n LA    R15,2(R15)                         Bump past the century\n*\n** Output: YY.DDD\n*\nODJ$F6 EQU *\n* We need edit pattern that works every time here!!!!!\n MVC   DWA(7),=X'40,20,20,4B,20,20,20'    Move in edit pattern\n ED    DWA(7),S_JDATE+1                   Edit the julian date\n OI    DWA+1,X'F0'       <-| 00.xxx and | Ensure no leading spaces\n OI    DWA+2,X'F0'      <--| 00.001 fail| Ensure no leading spaces\n MVI   DWA+3,C'.'      <---| without    | Ensure dot\n OI    DWA+4,X'F0'    <----| this       | Ensure no leading spaces\n OI    DWA+5,X'F0'   <-----| kludge!    | Ensure no leading spaces\nODJ$F6KX EQU *\n MVC   0(6,R15),DWA+1                     Move number to output addr\n LA    R15,6(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\n** Output: YYDDD\n*\nODJ$F5 EQU *\n UNPK  0(5,R15),S_JDATE+1(3)              Unpack to zoned from packed\n OI    4(R15),C'0'                        Fix sign byte\n LA    R15,5(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\n** Output: DDD\n*\nODJ$F3 DS  0H\n UNPK  0(3,R15),S_JDATE+2(2)              Unpack to zoned from packed\n OI    2(R15),C'0'                        Fix sign byte\n LA    R15,3(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n EJECT\n***********************************************************************\n***\n**                Output Day of the week\n***\n***********************************************************************\n SPACE 2\nOUTPUT_DATE_DOW EQU *\n BAS   R9,D$CHK                           Check date\n BAS   R9,LOCATE_STRING                   Locate output location\n BAS   R9,CLEAR_STRING                    Clear output to blanks\n*\n ST    R15,PARMLIST                       Save output location\n LA    R2,W_GDATE+0                       Locate \"MM\" in \"MMDDCCYY\"\n LA    R3,W_GDATE+2                       Locate \"DD\" in \"MMDDCCYY\"\n LA    R4,W_GDATE+4                       Locate \"CCYY\" in \"MMDDCCYY\"\n BAS   R9,RETURN_DOW                      Return the day of the week\n LR    R1,R15                             Get T_DOW entry\n L     R15,PARMLIST                       Get output location\n*\n** \"DayOfWeek\"\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODDOW9      Short form of DOW?\n BL    ODD$3                              Yes, move on\n SLR   R14,R14                            Clear register\n IC    R14,TD_NAMEL-TD(R1)                Get name length\n MVC   0(0,R15),TD_NAME-TD(R1)            ** Executed **\n EX    R14,*-6                            Move in day of the week\n LA    R15,1(R14,R15)                     Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\n** \"DOW\"\n*\nODD$3    EQU *\n CLI   DA#DATED_STRL,$DA#DATE_ODDOW3      Shorter form of Dow?\n BL    ODD$1                              Yes, move on\n MVC   0(3,R15),TD_NAME-TD(R1)            Move in Day of week (3 char)\n OC    0(3,R15),=CL3' '                   Make uppercase\n LA    R15,3(R15)                         Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\n** Number representation of day of week\n*\nODD$1 EQU *\n MVC   0(1,R15),TD_NUM-TD(R1)             Get day of the week\n LA    R15,1(R15)                         Bump past the number\n B     I$UPDATE_LENGTH                    Now, complete the length\n EJECT\n***********************************************************************\n***\n**                Output Month Name\n***\n***********************************************************************\n SPACE 2\nOUTPUT_DATE_MONTHN EQU *\n BAS   R9,D$CHK                           Check date\n BAS   R9,LOCATE_STRING                   Locate output location\n BAS   R9,CLEAR_STRING                    Clear output to blanks\n*\n** Get the month name\n*\n PACK  DOUBLE(8),W_GDATE(2)               Pack the month \"MMddccyy\"\n CVB   R2,DOUBLE                          Make month binary\n PACK  DOUBLE(8),W_GDATE+4(4)             Pack the Year: \"mmddCCYY\"\n CVB   R4,DOUBLE                          Make Year binary\n ST    R15,PARMLIST                       Save location\n BAS   R14,RETURN_MONTH_ENTRY             Return the month entry\n LR    R1,R15                             Get month entry\n L     R15,PARMLIST                       Get location\n*\n** Long version: \"September\"\n*\n CLI   DA#DATED_STRL,$DA#DATE_ODMONTHN9   Only need 3 characters?\n BL    ODM$3                              Yes, move on\n SLR   R14,R14                            Clear register\n IC    R14,TM_NAMEL-TM(R1)                Get month length\n MVC   0(0,R15),TM_NAME-TM(R1)            ** Executed **\n EX    R14,*-6                            Move in Month name\n LA    R15,2(R14,R15)                     Bump past it\n B     I$UPDATE_LENGTH                    Now, complete the length\n*\n** Short version: \"SEP\"\n*\nODM$3 EQU *\n MVC   0(3,R15),TM_NAME-TM(R1)            Move in day of the month\n OC    0(3,R15),=CL3' '                   Ensure uppercase\n B     I$UPDATE_LENGTH                    Now, complete the length\n EJECT ,\n***********************************************************************\n***\n**               Output time processing\n***\n***********************************************************************\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**                Military time: 00:00 - 23:59\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nOUTPUT_TIME_MILITARY EQU *\n         BAS   R9,T$CHK                   Check the time\n         BAS   R9,LOCATE_STRING           Locate output location\n         BAS   R9,CLEAR_STRING            Clear output to blanks\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM11\n         BNL   OTM$F5\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM8\n         BNL   OTM$F5\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM6C\n         BNL   OTM$F6C\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM5\n         BNL   OTM$F5\n         B     I$INVALID_STRL             Branch to invalid length code\nOTM$F5   EQU   *                          HH:MM\n         MVC   0(2,R15),W_TIMEM           Move in HH\n         MVI   2(R15),C':'                Insert :\n         MVC   3(2,R15),W_TIMEM+2         Move in MM\n         LA    R15,5(R15)                 Bump past HH:MM\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM5 Want more?\n         BNH   I$UPDATE_LENGTH            No, move on\nOTM$F8   EQU   *                          HH:MM:SS\n         MVI   0(R15),C':'                Insert :\n         MVC   1(2,R15),W_TIMEM+4         Move in SS\n         LA    R15,3(R15)                 Bump past :SS\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMEM8 Want more?\n         BNH   I$UPDATE_LENGTH            Want more?\nOTM$F11  EQU   *                          HH:MM:SS.TH\n         MVI   0(R15),C'.'                Insert .\n         MVC   1(2,R15),W_TIMEM+6         Move in th\n         LA    R15,3(R15)                 Bump past .th\n         B     I$UPDATE_LENGTH            Now, complete the length\nOTM$F6C  EQU   *                          HHMMSSth\n         MVC   0(8,R15),W_TIMEM           Move in complete string\n         LA    R15,8(R15)                 Bump past it\n         B     I$UPDATE_LENGTH            Now, complete the length\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**        Standard time: 12:00 - 11:59 AM / 12:00 - 11:59 PM\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nOUTPUT_TIME_STANDARD EQU *\n         BAS   R9,T$CHK                   Check the time\n*\n         LA    R3,W_TIMEM                 Locate Military time area\n         BAS   R9,T$RETURN_STIME          Get W_SHOUR, W_STYPE\n*\n         BAS   R9,LOCATE_STRING           Locate output location\n         BAS   R9,CLEAR_STRING            Clear output to blanks\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMES5 Minimum length check\n         BL    I$INVALID_STRL             Branch to invalid length code\nOTS$F5   EQU   *                          HH:MM\n         MVC   0(2,R15),W_SHOUR           Move in HH\n         MVI   2(R15),C':'                Insert :\n         MVC   3(2,R15),W_TIMEM+2         Move in MM\n         LA    R15,5(R15)                 Bump past HH:MM\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMES5 Want more?\n         BNH   I$UPDATE_LENGTH            No, move on\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMES8 Want more?\n         BNH   OTS$FT                     Want more?\n         MVI   0(R15),C':'                Insert :\n         MVC   1(2,R15),W_TIMEM+4         Move in SS\n         LA    R15,3(R15)                 Bump past :SS\n         CLI   DA#DATED_STRL,$DA#DATE_OTIMES11 More?\n         BNH   OTS$FT                     Want more?\n         MVI   0(R15),C'.'                Insert .\n         MVC   1(2,R15),W_TIMEM+6         Move in th\n         LA    R15,3(R15)                 Bump past .th\nOTS$FT   EQU   *\n         MVC   1(2,R15),W_STYPE           Move in type: AM or PM\n         LA    R15,3(R15)                 Bump past type\n         B     I$UPDATE_LENGTH            Now, complete the length\n         EJECT\n***********************************************************************\n***\n**       Misc date internal subroutines\n***\n***********************************************************************\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**   Return Month entry and return leap year\n**\n**   Input: R2 - Month in binary\n**          R4 - Year in binary (including century)\n**\n**   Output: R0  - 0 if leap year \u00a6 \u00ac0 if not\n**           R15 - T_MONTH entry address\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nRETURN_MONTH_ENTRY EQU *\n BAS   R15,RETURN_LEAP_YEAR               Check if this is a leap year\n*=> R0 will have 0 for leap year or \u00ac0 for non-Leap year\n*\n** Locate month entry, correct for leap year\n*\n LR    R1,R2                              Get month\n BCTR  R1,0                               Decrement by 1\n MH    R1,=AL2(TML)                       Calculate offset in table\n LA    R15,T_MONTH                        Locate table\n AR    R15,R1                             Locate table entry\n*\n LTR   R0,R0                              Leap year?\n BNZ   RME$X                              Nope, move on\n MVC   W_MONTHE(TML),0(R15)               Move in Entry\n LA    R15,W_MONTHE                       Locate entry\n CLI   TM_NUM-TM(R15),2                   February?\n BNE   RME$FX                             Nope, move on\n MVI   TM_DIM-TM(R15),29                  Feb has 29 days in leap year\n B     RME$X                              Finished...leave\nRME$FX EQU *\n CLI   TM_NUM-TM(R15),1                   January?\n BE    RME$X                              Yes, move on\n SLR   R1,R1                              Clear register\n LH    R1,TM_PDAYS-TM(R15)                Get previous number of days\n LA    R1,1(R1)                           Increment for Feb 29...\n STH   R1,TM_PDAYS-TM(R15)                Save previous number of days\nRME$X  EQU *\n BSM   0,R14                              Return to caller\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**                  Return Leap year indication in R0\n**\n**   Input: R4 - CCYY ... year in binary w/Century -- Ex. 1962\n**\n**   Output: R0 will have 0 for leap year or \u00ac0 for non-Leap year\n**\n** Tested with 1900 (not a leap year) and 2000 (is a leap year) and\n** a few other known leap years like 1992, 1994, 2004, etc.\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nRETURN_LEAP_YEAR EQU *\n SLR   R0,R0                              Clear register\n LR    R1,R4                              Get year\n D     R0,=F'4'                           Divide by 4 for leap year\n LTR   R0,R0                              Evenly divisable?\n BNZ   RLY$X                              No, all bets are off\n*-At this point, the year IS divisable by 4 so it still looks like a\n* a leap year, but let's check out the 100 test.\n SLR   R0,R0                              Clear reg for divide\n LR    R1,R4                              Get year back\n D     R0,=F'100'                         Divide by 100\n LTR   R0,R0                              Evenly divisable by 100?\n BNZ   RLY$0                              No, it's a leap year for sure\n*-At this point, the year IS divisable by 4 and 100, if it is divisable\n* by 400 it's a leap year\n SLR   R0,R0                              Clear reg for divide\n LR    R1,R4                              Get year back\n D     R0,=F'400'                         Do 400 test\n B     RLY$X                              Leave, results in R0\nRLY$0  DS 0H\n SLR   R0,R0                              Failed 100 test: a leap year\nRLY$X  DS 0H\n BSM   0,R15                              Return to caller\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**        Convert Julian date (character) to Packed\n**\n**    Input: R3 - Address of Z'DDD' - Day of the year\n**           R4 - Address of Z'CCYY' - Year w/century\n**           R6 - Address of X'ccyydddF' (output)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nRETURN_JULIAN_PACKED EQU *\n MVC   DWA(2),2(R4)                       Move in YY\n MVC   DWA+2(3),0(R3)                     Move in DDD\n PACK  0(4,R6),DWA(5)                     Make YYDDD packed\n*\nCJCP$CENT EQU *\n CLC   0(2,R4),=C'19'                     1900-1999?\n BE    CJCP$C0\n CLC   0(2,R4),=C'20'                     2000-2099?\n BE    CJCP$C1\n CLC   0(2,R4),=C'21'                     2100-2199?\n BE    CJCP$C2\nCJCP$C0 EQU *\n MVI   0(R6),X'00'                        1900-1999 = Century 0\n BSM   0,R9\nCJCP$C1 EQU *\n MVI   0(R6),X'01'                        2000-2099 = Century 1\n BSM   0,R9\nCJCP$C2 EQU *\n MVI   0(R6),X'02'                        2100-2199 = Century 2\n BSM   0,R9\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**           Ensure Numerics\n**\n**            Input: R1 - Numeric input string address\n**                   R0 - Numeric input string length\n**            Output: R15 - 0 if valid or \u00ac= 0 if not\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nENSURE_NUMERICS EQU *\n LA    R15,1                              Set return code\nEN$L EQU *\n CLI   0(R1),C'0'\n BL    EN$X\n CLI   0(R1),C'9'\n BH    EN$X\n LA    R1,1(R1)\n BCT   R0,EN$L\n SLR   R15,R15\nEN$X EQU *\n BSM   0,R14\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**           Ensure valid Julian Packed date\n**\n**              Byte 1 - Century indicator: Hex 0-2\n**              Byte 2-3 Packed number: PL3'YYDDD'\n**\n**            Input: R3 - Packed Julian date\n**            Output: R15 - 0 if valid or \u00ac= 0 if not\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nENSURE_VALID_JULIAN EQU *\n LA    R15,1                              Set return code\n*\n** Check century and sign bytes\n*\n CLI   0(R3),X'02'                        Only Century 0-2 valid...\n BH    EVJ$X                              It's invalid\n*\n TM    3(R3),X'0C'                        Valid sign?\n BO    EVJ$VSX                            Yes, move on\n TM    3(R3),X'0F'                        Valid sign?\n BNO   EVJ$X                              Nope, move on\nEVJ$VSX EQU *\n*\n** Check for valid packed numbers: 0-9 only, skip check of sign byte\n*\n UNPK  DOUBLE(7),1(4,R3)                       **\n MVZ   DOUBLE(6),=X'00,00,00,00,00,00,00,00'   *** Hex convert\n TR    DOUBLE(6),=C'0123456789ABCDEF'          **\n LA    R1,DOUBLE                          Locate hex EBCDIC area\n LA    R0,5                               Length to check\nEVJ$VPNL EQU *\n CLI   0(R1),C'0'                         Valid numeric?\n BL    EVJ$X                              Nope, invalid\n CLI   0(R1),C'9'                         Valid numeric?\n BH    EVJ$X                              Nope, invalid\n LA    R1,1(R1)                           Bump to next byte\n BCT   R0,EVJ$VPNL                        Repeat\n*\n** Get the year in binary and Leap year indicator\n*\n BAS   R14,RETURN_YEAR                    Get CCYY in R4\n BAS   R15,RETURN_LEAP_YEAR               Check if this is a leap year\n*=> R0 will have 0 for leap year or \u00ac0 for non-Leap year\n*\n** Obtain the day of the year in binary\n*                                                -----DOUBLE-----\n XC    DOUBLE(8),DOUBLE                   Clear: 0000000000000000\n MVC   DOUBLE+6(2),2(R3)                  Get:   000000000000DDDF\n CVB   R1,DOUBLE                          Make day of year binary\n*\n** Check for valid number of days in the year\n*\n LA    R15,365                            Default number of days\n LTR   R0,R0                              Leap year?\n BNZ   EVJ$LYX                            Nope, move on\n LA    R15,1(R15)                         Set max number of days to 366\nEVJ$LYX EQU *\n CR    R1,R15                             Input date more than max?\n BH    EVJ$X                              Yes, its invalid\n SLR   R15,R15                            Clear register\nEVJ$X  EQU *\n BSM   0,R9\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**    Return the Day-of-the-Year from Gregorian date\n**\n**    Input: R2 - Input Month                   ZL2'03'\n**           R3 - Input Day of month            ZL2'06'\n**           R4 - Input Year (with century)     ZL4'1962\n**           R6 - Output Day-of-Year            ZL4'0065'\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nRETURN_DAY_OFTHE_YEAR EQU *\n STM   R2,R4,PARMLIST                     Save parameter values\n*\n** Ensure that the month and day-of-month meet min. requirements\n*\n CLC   0(2,R2),=C'00'                     Validate Month\n BE    I$INVALID_STRD\n CLC   0(2,R2),=C'12'                     Validate month\n BH    I$INVALID_STRD\n*\n CLC   0(2,R3),=C'00'                     Validate Day of the month\n BE    I$INVALID_STRD\n CLC   0(2,R3),=C'31'                     Validate Day of the month\n BH    I$INVALID_STRD\n*\n** Locate the month entry for this month\n*\n PACK  DOUBLE(8),0(2,R2)                  Convert month to packed\n CVB   R2,DOUBLE                          Convert from packed to binary\n PACK  DOUBLE(8),0(4,R4)                  Convert year to packed\n CVB   R4,DOUBLE                          Convert from packed to binary\n*\n BAS   R14,RETURN_MONTH_ENTRY             Locate month entry\n*=> R15 points to T_MONTH entry...\n*\n SLR   R0,R0                              Clear register\n IC    R0,TM_DIM-TM(R15)                  Obtain days in month\n*\n L     R3,PARMLIST+4                      Get input Day-Of-Month addr\n PACK  DOUBLE(8),0(2,R3)                  Convert day to packed\n CVB   R1,DOUBLE                          Convert from packed to binary\n*\n CR    R1,R0                              Check days in month...\n BH    I$INVALID_STRD                     Too high, leave\n*\n** Save the date into output\n*\n SLR   R0,R0                              Clear register\n LH    R0,TM_PDAYS-TM(R15)                Obtain Previous days in year\n AR    R1,R0                              Add current day to prev. days\n*\n CVD   R1,DOUBLE                          Convert Day of the year\n UNPK  0(4,R6),DOUBLE+6(2)                Make it zoned: 00DDD\n OI    3(R6),C'0'                         Fix sign byte\n*\n LM    R2,R4,PARMLIST                     Save parameter values\n BSM   0,R9\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**       Process the time stamp value to output time & date\n**\n**   Input: R3 - Input double word value\n**          R5 - Output time: F\n**          R6 - Output Date: X'CCYYDDDF'\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nCONVERT_TIMESTAMP EQU *\n*\n** Use the STCKCON macro if we are on a MVS 4.1 system or higher\n*\n         L     R1,CVTPTR\n         TM    CVTOSLV0-CVTMAP(R1),CVTH4410\n         BNO   CT$OLD\n         MVC   PARMLIST(C_STCKL),C_STCK\n         STCKCONV STCKVAL=(3),            Convert TOD                  @\n               CONVVAL=DWA,               ..Output Time and date       @\n               TIMETYPE=DEC,              ..Output time format         @\n               DATETYPE=YYYYDDD,          ..Output Date format         @\n               MF=(E,PARMLIST)\n         LTR   R15,R15\n         BNZ   CT$X\n         L     R1,DWA+8                   Get \"0yyyyddd\"\n         SLL   R1,4                       Make it \"yyyyddd0\"\n         O     R1,=X'0000000F'            Make it \"yyyydddF\"\n         CLM   R1,B'1000',=X'19'\n         BE    CT$Y19\n         CLM   R1,B'1000',=X'20'\n         BE    CT$Y20\n         CLM   R1,B'1000',=X'21'\n         BE    CT$Y21\n*-Invalid century, use x'00'\nCT$Y19   DS    0H\n         ICM   R1,B'1000',=X'00'          CC=00 for 19\n         B     CT$YX\nCT$Y20   DS    0H\n         ICM   R1,B'1000',=X'01'          CC=01 for 20\n         B     CT$YX\nCT$Y21   DS    0H\n         ICM   R1,B'1000',=X'02'          CC=02 for 21\nCT$YX    DS    0H\n         ST    R1,0(R6)                   Save Julian date \"ccyydddF\"\n         MVC   0(4,R5),DWA                Save Time\nCT$X     DS    0H\n         BSM   0,R9\n*\n** Here we do the TOD conversion ourself.\n**\n** There's a bug with this code: it only does HH:MM - need SS:TH...\n*\nCT$OLD   DS    0H\n         LM    R0,R1,0(R3)                Load value into work regs\n         SRDL  R0,12                      Align to micro seconds\n         D     R0,=A(1000*1000*60)        R1 = MM\n         SR    R0,R0\n         D     R0,=F'60'                  R1 = HH\n         STCM  R0,B'0001',1(R5)           Save MM\n         SR    R0,R0\n         D     R0,=F'24'                  R1 = DD\n         STCM  R0,B'0001',0(R5)           Save HH\n*\n** NOW DO DATE\n*\n         SR    R0,R0\n         D     R0,=A(365*4+1)             # DAYS BETWEEN LEAPS\n         LR    R15,R1                     R15 = # 4 YEAR INTERVALS\n         AH    R0,=H'2'                   DAYS RELATIVE TO 1\n         CH    R0,=H'366'                 MORE THAN 1 YEAR\n         BH    TS$01                      YES, DO IT\n         SR    R1,R1                      INIT YEAR COUNTER\n         B     TS$02\nTS$01    EQU   *\n         LR    R1,R0                      R1 = DAYS SINCE JAN 1 OF LEAP\n         SH    R1,=H'367'                 ALLOW FOR LEAP YEAR\n         SR    R0,R0\n         D     R0,=F'365'                 R1 = YEARS R0=DAYS\n         AH    R1,=H'1'                   ADD BACK IN LEAP YEAR\n         AH    R0,=H'1'                   ADD BACK IN DAY\nTS$02    EQU   *\n         SLL   R15,2                      # OF YEARS BEFORE THESE 4\n         AR    R1,R15                     ADD THEM TO YEARS IN PERIOD\n         STCM  R1,B'0001',1(R6)           SAVE YEAR\n         STCM  R0,B'0011',2(R6)           SAVE DAYS\n*\n         SLR   R0,R0                      CLEAR REGISTER\n         IC    R0,1(R6)                   R0 = 00,00,00,YY\n         MH    R0,=H'1000'                R0 = 00,YY,00,00\n         AH    R0,2(R6)                   R0 = 00,YY,DD,DD\n         CVD   R0,DOUBLE                  CONVERT TO PACKED DECIMAL\n         MVC   0(4,R6),DOUBLE+4           Save as packed\n*\n** Time is in Binary, make it packed and save into current time\n*\n         SLR   R1,R1                      CLEAR REG\n         IC    R1,0(R5)                   GET HH\n         MH    R1,=H'1000'                R1 = 00,HH,00,00\n         SLR   R14,R14                    CLEAR REG\n         IC    R14,1(R5)                  GET MM\n         MH    R14,=H'10'                 R14=00,00,MM,00\n         AR    R1,R14                     R1= 00,HH,MM,00\n         CVD   R1,DOUBLE                  DOUBLE=00,00,00,00,HH,MM,0B\n         MVC   0(2,R5),DOUBLE+5\n*\n         SLR   R15,R15\n         BSM   0,R9\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**     Date check: IF S_JDATE is zero, seed it with current date\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nD$CHK EQU *\n CLI   S_JDATE,$DA#DATE_INVALID           Invalid Input Date?\n BE    I$LB                               Yes, skip output processing\n*\n CLC   S_JDATE(4),=X'00,00,00,00'         Zero?\n BNE   D$CHKTMX                           No, move on\n TIME  ,                                  Get current time/date\n ST    R1,S_JDATE                         Save date\nD$CHKTMX EQU *\n*\n** Convert the Julian date to Gregorian\n*\n ST    R9,PARMLIST+20                     Save return address\n LA    R3,S_JDATE                         Locate the current date\n LA    R6,W_GDATE                         Locate output gregorian date\n BAS   R9,D$RETURN_GREGORIAN_DATE         Return the Gregorian Date\n L     R9,PARMLIST+20                     Get return address\n*\n** Return to caller\n*\nD$CHKX EQU *\n BSM   0,R9                               Return to caller\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**  Return Day-of-the-Week table entry\n**\n**  Input: R2 - ZL2'03'     - Month\n**         R3 - ZL2'06'     - Day\n**         R4 - ZL4'1962'   - Year\n**\n**  Output: R15 - T_DOW entry address\n**\n**        N = D + 2M + 3(M+1)/5 + Y + Y/4 - Y/100 + Y/400 + 2\n**\n**        WHERE M = 3-14 (JAN,FEB ARE 13,14 OF Y-1)\n**              N/7 LEAVES REMAINDER 0-6, 0 INDICATING SATURDAY\n**\n**  Note: this was \"liberated\" from CBT tape, file 316\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nRETURN_DOW EQU *\n PACK DOUBLE(8),0(2,R2)\n CVB  R14,DOUBLE\n**\n PACK DOUBLE(8),0(2,R3)\n CVB  R1,DOUBLE\n**\n PACK DOUBLE(8),0(4,R4)\n CVB  R15,DOUBLE\n*\n         CH    R14,=H'2'           JAN OR FEB?\n         BH    WEEKMMOK\n         BE    WEEKFEB\n         LA    R14,13              SET M=13\n         B     WEEKYMIN\nWEEKFEB  LA    R14,14              SET M=14\nWEEKYMIN BCTR  R15,0               SET Y = Y-1\nWEEKMMOK LR    R0,R14              COPY M\n         ALR   R0,R0               GET 2M\n         ALR   R1,R0               SET N = N + 2M\n         LR    R0,R15              SAVE REDEFINED Y\n         SPACE\n         LA    R14,1(,R14)         GET M+1\n         MH    R14,=H'3'           GET 3(M+1)\n         SRDL  R14,32              SHIFT INTO R15, ZERO R14\n         D     R14,=F'5'           GET 3(M+1)/5 IN R15\n         ALR   R1,R15              SET N = N + 3(M+1)/5\n         SPACE\n         LR    R15,R0              GET Y\n         ALR   R1,R15              SET N = N + Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'4'           GET Y/4\n         ALR   R1,R15              SET N = N + Y/4\n         SPACE\n         LR    R15,R0              GET Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'100'         GET Y/100\n         SLR   R1,R15              SET N = N - Y/100\n         SPACE\n         LR    R15,R0              GET Y\n         SLR   R14,R14             ZERO R14\n         D     R14,=F'400'         GET Y/400\n         ALR   R1,R15              SET N = N + Y/400\n         LA    R15,2               GET 2\n         ALR   R1,R15              SET N = N + 2\n         SLR   R0,R0               ZERO R0\n         D     R0,=F'7'            SET N = N/7\n*\n         MH    R0,=AL2(TDL)        Calculate offset of entry in table\n         LA    R15,T_DOW           Point to table\n         AR    R15,R0              Point to name\n         LR    R14,R0              Save day of the week\n         BSM   0,R9                Return to caller\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**   Return Gregorian date from Julian (packed)\n**\n**   Input: R3 - Address of input field: \"X'00YYDDDF\"\n**          R6 - Address of output field: CL8'MMDDCCYY'\n**\n**   Enhancement queue:\n**   - Recognize the special julian dates: 99000 98000 99365...\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nD$RETURN_GREGORIAN_DATE EQU *\n ST    R3,PARMLIST                        Save input date address\n ST    R9,PARMLIST+4                      Save return address\n*\n** Get the year and place into the output area\n*\n BAS   R14,RETURN_YEAR                    Return CCYY in R4\n CVD   R4,DOUBLE                          Convert to Packed\n UNPK  4(4,R6),DOUBLE+5(3)                Convert to Zoned\n OI    4+3(R6),C'0'                       Fix sign byte\n*\n** Convert 'DDDF in X'cc,yy,DD,DF' to binary\n*                                                0 1 2 3  4 5 6 7\n XC    DOUBLE(8),DOUBLE                   Clear: 00000000 00000000\n MVC   DOUBLE+6(2),2(R3)                  Get:   00000000 0000DDDF\n CVB   R3,DOUBLE                          Make day of year binary\n*\n** Loop thru month table entries for this Day-of-Year\n*\n LA    R2,1                               Locate month entry\nD$RGDL EQU *\n BAS   R14,RETURN_MONTH_ENTRY             Return Month entry: R2 & R4\n*=> R15 has month entry...\n CLM   R3,B'0011',TM_PDAYS-TM(R15)        Check out previous days\n BNH   D$RGDLX                            Less, current month is good\n LA    R2,1(R2)                           Bump to next entry\n B     D$RGDL                             Repeat\n*\n** Calculate the Day in the month and move it and Month number\n*\nD$RGDLX EQU *\n BCTR  R2,0                               Decrement to previous month\n BAS   R14,RETURN_MONTH_ENTRY             Return Month entry: R2 & R4\n SH    R3,TM_PDAYS-TM(R15)                Day of the month = DOY - prev\n CVD   R3,DOUBLE                          Make Day-of-month packed\n UNPK  2(2,R6),DOUBLE+6(2)                Unpack it into zoned decimal\n OI    2+1(R6),C'0'                       Fix sign byte\n*\n MVC   0(2,R6),TM_NUMC-TM(R15)            Move in MM\n*\n** Return to caller\n*\n L     R3,PARMLIST\n L     R9,PARMLIST+4\n BSM   0,R9\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**          Return the CCYY in R4\n**\n**    Input: R3 - Packed Julian date        (Address)\n**    Output: R4 - CCYY in binary format    (Value)\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nRETURN_YEAR EQU *\n*\n** Process the Year\n*\n SLR   R0,R0                              Clear register\n SLR   R1,R1                              Clear register\n IC    R1,1(R3)                           Year: 00YYDDDF -> 000000YY-R1\n SLA   R1,4                               Move over: 00000YY0\n STM   R0,R1,DOUBLE                       Save: \"00000000 00000YY0\"\n OI    DOUBLE+7,X'0F'                     Make: \"00000000 00000YYF\"\n CVB   R0,DOUBLE                          Convert the year to binary\n*\n** Process the Century\n*\n LA    R4,19                              Default century: 0 = 1900\n SLR   R15,R15                            Clear register\n IC    R15,0(R3)                          Get century offset\n AR    R4,R15                             Century = 19 + offset\n MH    R4,=H'100'                         Each century has 100 years...\n*\n** Add the Century to the Year to complete the number; return to caller\n*\n AR    R4,R0                              Add in year: ex. 1962\n*\n BSM   0,R14\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**      Convert Time (TIME DEC format) to Zoned decimal\n**\n**      Input: R3 - Address of input time (FW)\n**      Output: R5 - Address of output time (ZL8)\n**\n**    Note: S_TIME is a packed field without a sign byte, we will\n**          shift it over 4 bits and insert a sign byte...\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nT$RETURN_MTIME EQU *\n SLR  R0,R0                               Clear register\n L    R1,0(R3)                            Get time\n SLDA R0,4                                Shift over for sign\n STM  R0,R1,DOUBLE                        Put into work location\n OI   DOUBLE+7,X'0F'                      Insert sign byte\n UNPK 0(8,R5),DOUBLE+3(5)                 Convert to zoned decimal\n OI   7(R5),C'0'                          Fix sign byte\n BSM  0,R14                               Return to caller\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**            Convert Military time to Standard\n**\n**      Input: R3 - Address of input time - ZL8'MMHHSSTH'\n**\n**      Output: W_STYPE - AM or PM\n**              W_SHOUR - Hour adjusted (if needed)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nT$RETURN_STIME EQU *\n MVC   W_SHOUR(2),0(R3)                   Set default hour\n MVC   W_STYPE(2),=CL2'AM'                Set default type\n*\n CLC   0(2,R3),=CL2'12'                   Is this 12:00 - 12:59?\n BE    TGS$PM                             Yes, just change AM to PM\n CLC   0(2,R3),=CL2'13'                   Is it past 13:00:00?\n BL    TGS$X                              No, its okay\n*\n PACK  DOUBLE(3),0(2,R3)                  Convert hour to packed\n SP    DOUBLE(3),=PL3'12'                 Make time standard\n UNPK  W_SHOUR(2),DOUBLE(3)               Convert hour to zoned\n OI    W_SHOUR+1,C'0'                     Fix sign byte\nTGS$PM EQU *\n MVC   W_STYPE(2),=CL2'PM'                Set to PM\nTGS$X EQU *\n BSM   0,R9\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n**       Set \"S_TIME\" if no value is found\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nT$CHK    EQU   *\n CLI   S_TIME,$DA#DATE_INVALID            Invalid Input time?\n BE    I$LB                               Yes, skip output processing\n*\n CLC   S_TIME(4),=X'00,00,00,00'          Have a Time value?\n BNE   T$CHKTMX                           Yes, move on\n TIME  ,                                  Get current time\n ST    R0,S_TIME                          Save time for later\nT$CHKTMX EQU *\n LA    R3,S_TIME                          Input time area\n LA    R5,W_TIMEM                         Output time area\n BAS   R14,T$RETURN_MTIME                 Convert S_TIME to W_TIMEM\nT$CHKX EQU *\n BSM   0,R9                               Return to caller\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Year windowing\n**\n** Input: R4 points to \"xxYY\" which we will fill in with a century.\n** This routine will only work in the 1900-2099 as is.\n**\n** For example: 00 becomes 2000, 50 becomes 2050 - 00-50 are 2000-2050\n**              51 becomes 1951, 99 becomes 1999 - 51-99 are 1951-1999\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\nPERFORM_YEAR_WINDOW DS 0H\n         CLC   2(2,R4),=C'50'\n         BH    PYW1900\n         MVC   0(2,R4),=C'20'\n         BSM   0,R14\nPYW1900  DS    0H\n         MVC   0(2,R4),=C'19'\n         BSM   0,R14\n EJECT ,\n***********************************************************************\n***\n**       Gregorian/Julian/Dow tables\n***\n***********************************************************************\n         SPACE 2\n*\n** Day of Week table -- Mapped by the TD DSECT\n*\nT_DOW    EQU   *\n         DC    AL1(6,5,7,0,7),CL9'Saturday '\n         DC    AL1(0,5,6,0,5),CL9'Sunday   '\n         DC    AL1(1,5,5,1,5),CL9'Monday   '\n         DC    AL1(2,4,4,2,6),CL9'Tuesday  '\n         DC    AL1(3,3,3,3,8),CL9'Wednesday'\n         DC    AL1(4,2,2,4,7),CL9'Thursday '\n         DC    AL1(5,1,1,5,5),CL9'Friday   '\nT_DOWE   EQU   (*-T_DOW)/TDL\n*\n** Month table -- Mapped by the TM DSECT\n*\nT_MONTH EQU *\n DC AL1(01),AL1(31),AL2(000),AL1(6),CL9'January  ',CL2'01'\n DC AL1(02),AL1(28),AL2(031),AL1(7),CL9'February ',CL2'02'\n DC AL1(03),AL1(31),AL2(059),AL1(4),CL9'March    ',CL2'03'\n DC AL1(04),AL1(30),AL2(090),AL1(4),CL9'April    ',CL2'04'\n DC AL1(05),AL1(31),AL2(120),AL1(2),CL9'May      ',CL2'05'\n DC AL1(06),AL1(30),AL2(151),AL1(3),CL9'June     ',CL2'06'\n DC AL1(07),AL1(31),AL2(181),AL1(3),CL9'July     ',CL2'07'\n DC AL1(08),AL1(31),AL2(212),AL1(5),CL9'August   ',CL2'08'\n DC AL1(09),AL1(30),AL2(243),AL1(8),CL9'September',CL2'09'\n DC AL1(10),AL1(31),AL2(273),AL1(6),CL9'October  ',CL2'10'\n DC AL1(11),AL1(30),AL2(304),AL1(7),CL9'November ',CL2'11'\n DC AL1(12),AL1(31),AL2(334),AL1(7),CL9'December ',CL2'12'\nT_MONTHE EQU (*-T_MONTH)/TML\n DC AL1(13),AL1(0),AL2(365)               Last entry\n EJECT\n***********************************************************************\n***\n**       Data constants\n***\n***********************************************************************\n SPACE 2\n*\n** Calendar constants\n*\nC_MONTHV DC    AL1(01,02,03,04,05,06,07,08,09,10)\n         DC    AL1(11,12,13,14,15,16,17,18,19,20)\n         DC    AL1(21,22,23,24,25,26,27,28,29,30)\n         DC    AL1(31)\n*\nC_MONTHC DC    C' 01 02 03 04 05 06 07 08 09 10'\n         DC    C' 11 12 13 14 15 16 17 18 19 20'\n         DC    C' 21 22 23 24 25 26 27 28 29 30'\n         DC    C' 31'\n*\nC_HEAD   DC    C' Su Mo Tu We Th Fr Sa'\nC_HEADL  EQU   *-C_HEAD\n*\nC_STCK   STCKCONV MF=L\nC_STCKL  EQU   *-C_STCK\n*\n** Literals in program\n*\n LTORG ,\n DS    0D                                 End of DA#DATE CSECT\n EJECT\n***********************************************************************\n***\n**       GETMAINed work area\n***\n***********************************************************************\n SPACE 2\nDSA      DSECT ,\n         DS    18F                        Register Save Area\n*                                         Input Loop\nI_LA     DS    F                          ..Addr. of current parm ent.\n*\n** Fields to be save past entry processing\n*\n         DS    0F                         Save\nS_TIME   DS    F                          ..Time of day: TIME DEC form.\nS_JDATE  DS    F                          ..Julian date: TIME DEC form.\n*\n** Misc work areas\n*\nDOUBLE   DS    D                          Double word work area\nDWA      DS    2D                         Double word work area 2\nPARMLIST DS    10F                        Parameter List\n*\n** Time/Date fields\n*\nW_TIMEM  DS    CL8'HHMMSSTH'              Current time\nW_SHOUR  DS    CL2'HH'                    Hour the day: standard\nW_STYPE  DS    CL2'AM'                    Type: AM or PM\nW_GDATE  DS    CL8'MMDDCCYY'              Gregorian date (US)\nW_CCYY   DS    C'CCYY'                    Full 4 byte year\nW_MONTHE DS    XL(TML)                    Leap year month entry\n         DS    0D                         Alignment for FREEMAIN\nDSAL     EQU   *-DSA\n EJECT ,\n***********************************************************************\n***\n**       DSECTs and equates\n***\n***********************************************************************\n SPACE 2\n*\n** T_ROUT table mapping DSECT\n*\nTR       DSECT ,\nTR_TYPE  DS    XL2                        Type of call\n         DS    X                          - not used\nTR_ROUTN DS    C                          Routine Name or 0 if main\nTR_ROUT  DS    F                          Routine address for type\n*\n** Map of T_MONTH\n*\nTM       DSECT ,\nTM_NUM   DS    X                          ..Month number (Binary)\nTM_DIM   DS    X                          ..Days in month\nTM_PDAYS DS    XL2                        ..Days previous to month\nTM_NAMEL DS    X                          ..Month name length\nTM_NAME  DS    CL9                        ..Month name\nTM_NUMC  DS    CL2                        ..Month number (Character)\nTML      EQU   *-TM                       Length of entry\n*\n** Map of T_DOW\n*\nTD       DSECT ,\nTD_NUM   DS    X                          ..Number of week - Start=sun\nTD_FWWD  DS    X                          ..First week - Working days\nTD_FWSUB DS    X                          ..First week - Subtract\nTD_LWWD  DS    X                          ..Last week - Working days\nTD_NAMEL DS    X                          ..Length of DOW Name\nTD_NAME  DS    CL9                        ..Length of DOW Name\nTDL      EQU   *-TD\n END   ,\n./ ADD NAME=DA$DISKR 0100-01266-01266-1821-06679-06679-00000-DAVE\nDA$DISKR TITLE 'Disk Reporter Utility'\n* =================================================================== *\n*\n*  Name: DA$DISKR - Disk Reporter Utility\n*\n*  Author: David Alcock :: dave@planetmvs.com\n*\n*  Purpose: Reports on disk usage:\n*           o Scan all online DISK ucbs and report on utilization\n*           o Optionally report on all datasets found on a volume\n*\n*           ===> See HELP text at label HELPTEXT for more info\n*\n* Attributes: Reentrant, Reusable, Non-Authorized | Authorized\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n* CSECTs used:\n* o Internal:\n*   o DA$DISKR - Main CSECT\n*   o DRU$OPTS - Options\n*   o DRU$CON1 - Constants CSECT #1\n*   o DRU$ESTA - Estae routine\n*   o DRU$PPC  - Parse Parameter Card\n*   o DRU$RVOL - Reset headings\n*   o DRU$ALCV - Dynamically allocate volumes\n*   o DRU$ROPR - Reset headings for operations report\n*   o DRU$PRR  - Print Report Record\n*   o DRU$PSR  - Print SYSPRINT record\n*   o DRU$BLET - Print Big letters\n*   o DRU$HELP - Print help information for PARM=HELP\n*\n* External Programs:\n* o Ours:\n*   o DA$DATE....Date routine\n*   o DA$MXD.....Mini-Hex-Dump routine\n* o IBM:\n*   o IEFEB4UV...Unit verification\n*   o IDCSS01....Cache (LISTDATA) API\n*   o IEFSD095...IBM Block (big) Letter routine\n*\n* Non-IBM assembler MACROs:\n* o DA#DATE....Equates and DSECTs for the date routine\n* o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine\n* o DA#SMODE...Change addressing mode to/from 24 bit/31 bit\n* o DA#STR.....Create Pascal-like string with length byte (-1)\n*\n*  Limitations:\n*  o Assembler H or higher\n*  o MVS/ESA v3 and higher\n*  o SYS1.AOSB0 is needed at link time to resolve the _OPTIONAL_\n*    IEFSD095 (big letter) routine;\n*  o APF Authorization limitations:\n*    o Lack of authorization does not stop the majority of options\n*      and will not cause ABENDs since the TESTAUTH macro is used.\n*    o Needed for following functions\n*      o Node checking for RACF group verification (VTOCRPT)\n*      o Cached volume detection\n*\n*  Enhancement queue:\n*  o Convert from using DA$DATE to CONVTOD\n*  o Parse: UCB= HEXDUMP NOHEADING\n*  o Release buffers at close of datasets\n*  o DASD CONFIG section is for operations report, need user report\n*    %USED on DASD LIST\n*  o Sort DASD list by free space\n*  o Add in DSN DASD space calcuations\n*\n*  o ds1pdse is a pdse ds1pdse+ds1pdsex is a hfs\n*\n*  o SMS stats:\n*    o 5 of 100 (5%) of online volumes are SMS-indicated\n*    o 1 of 3 (33%) of selected volumes are SMS-indicated\n* =================================================================== *\n         SPACE 2\n         LCLC  &DAVER\n&DAVER   SETC  '2.1'\n* =================================================================== *\n* Note: PARM=DATAONLY is not complete!\n*\n*             M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ---------------------------------------------\n* D.Alcock   2000-01-29  V2.1:\n*                        - Put Total Tracks for volume in Report;\n*                        - Calculate total tracks free for volume;\n*                        - Use inline ESA entry/exit housekeeping code\n*                          instead of homegrown (home groan) macros;\n*                        - Remove non-working subchannel/chpid code;\n* D.Alcock   25-JUN-1998 V2.0:\n*                        - Moved Print_Sysprint_Record and Print_\n*                          Report_Record to separate CSECTs;\n*                        - Message prefix is now \"DRU\" not \"DA$DISKR-\"\n*                          DRU = Disk Reporter Utility;\n*                        - Eliminate VATDEF during merge;\n*                        - Added PARM=HELP: print help info;\n*                        - Added PARM=NOSYSP: Bypass System Profile\n*                        - Added PARM=NOPIC: Bypass Star Trek Pic;\n*                        - Print silly Star Trek \"ASCII\" picture\n*                          at startup in //SYSPRINT;\n*                        - Started DATAONLY option for //REPORT\n*                          and //VTOCRPT ** Incomplete!! **;\n*                        - Re-enable System Profile by moving it\n*                          to a separate CSECT;\n*                        - Change &ASMDATE to ISO format;\n* D.Alcock   19-FEB-1998 Corrected S0C4 with PSM (Print Sort MSG)\n*                        option;\n* D.Alcock   29-DEC-1997 &ASMDATE changed to ISO standard;\n* D.Alcock   06-OCT-1997 Added support for using the UCBSCAN macro\n*                        so we can see Dynamic UCBs and 4 digit\n*                        UCBs;  All code was changed to use 4 digit\n*                        UCBs (UCBCHAN used instead of UCBNAME);\n* D.Alcock   18-MAR-1997 Corrected CVAF/BSAM bug;  Added check for\n*                        LSPACE failure and printing message;\n* D.Alcock   17-MAR-1997 Added RPTBDSN parm; Added CATCHK to reduce\n*                        overhead; Added SMSMCHK parm for migrating\n*                        to SMS;  Started multiple date formats;\n* D.Alcock   15-MAR-1997 Added PARM= processing and volume prefix\n*                        option; Changed to use lower case hex;\n* D.Alcock   13-MAR-1997 Renamed to DA$DISKR and macros converted;\n* D.Alcock   07-JUL-1994 Changed all \"*-6\" executed instructions\n*                        from in-line to out-of-path labels; Print\n*                        assemble and link date at startup;\n* D.Alcock   09-APR-1994 Added $$NOAPF DDNAME check; S0C4 ABEND in\n*                        IDCSS01 prompted this check;\n* D.Alcock   24-JAN-1985 Initial program created;\n* =================================================================== *\n         EJECT\n***********************************************************************\n***\n**       Set the DFP/DFSMS and O/S maclib levels to variables\n***\n***********************************************************************\n         SPACE 2\n         GBLC  &DMACLIB                   DFP/DFSMS maclib version\n&DMACLIB SETC  'PRE-DFP'                  Start out at ancient level\n         GBLC  &IHADFARELS                IHADFA sets to system level\n*-If you aren't at DFP maclib, comment out \"IHADFA\"\n         IHADFA ,                         Data Facilities Area\n         AIF   (NOT D'DFA).SMSX           Have IHADFA?\n         AIF   (D'DFADFSMS).SMSSTRT       At DFSMS 1.1?\n*-DFP maclib checks\n&DMACLIB SETC  'DFP'\n         AIF   (NOT D'DFASMS).SMSX\n&DMACLIB SETC  'DFP 310'\n         AIF   (NOT D'DFAPDSE).SMSX\n&DMACLIB SETC  'DFP 320'\n         AIF   (NOT D'DFAVOLSN).SMSX\n&DMACLIB SETC  'DFP 330'\n         AIF   (NOT D'DFAVOLSN).SMSX\n&DMACLIB SETC  'DFP 331'\n         AIF   (NOT D'DFARECAL).SMSX\n&DMACLIB SETC  'DFP 332'\n         AGO   .SMSX\n*-As stated in the \"DFSMS/MVS 1.3 DFSMSdfp Advanced Services\" manual,\n* the IHADFA macro did not always set &IHADFARELS (but they could\n* in the future), so attempt to deterimine prior release levels.\n.SMSSTRT ANOP  ,\n         AIF   ('&IHADFARELS' NE '').SMSSET   Already have SMS level?\n&IHADFARELS SETC '01010100'               Start at DFSMS 1.1\n         AIF   (NOT D'DFADEEXT).SMSSET    At DFSMS 1.2?\n&IHADFARELS SETC '01010200'               Up to DFSMS 1.2\n.SMSSET  ANOP  ,                          Set level\n&DMACLIB SETC  'DFSMS/MVS &IHADFARELS'    Set DFP/DFSMS maclib level\n.SMSX    ANOP  ,\n*\n         CVT   DSECT=YES,LIST=NO,PREFIX=YES MVS CVT\n*-Attempt to identify the MVS maclib level\n         GBLC  &MMACLIB                   MVS maclib version\n         AIF   (NOT D'CVTH6606).MMR6X\n&MMACLIB SETC  'OS/390 R6 or higher'\n         AGO   .MMX\n.MMR6X   ANOP    ,\n         AIF   (NOT D'CVTH6605).MMR5X\n&MMACLIB SETC  'OS/390 R5'\n         AGO   .MMX\n.MMR5X   ANOP    ,\n         AIF   (NOT D'CVTJ6604).MMR4X\n&MMACLIB SETC  'OS/390 R4'\n         AGO   .MMX\n.MMR4X   ANOP    ,\n         AIF   (NOT D'CVTH6603).MMR3X\n&MMACLIB SETC  'OS/390 R3'\n         AGO   .MMX\n.MMR3X   ANOP    ,\n         AIF   (NOT D'CVTJ6602).MMR2X\n&MMACLIB SETC  'OS/390 R2'\n         AGO   .MMX\n.MMR2X   ANOP    ,\n         AIF   (NOT D'CVTH6601).MMR1X\n&MMACLIB SETC  'OS/390 R1'\n         AGO   .MMX\n.MMR1X   ANOP    ,\n         AIF   (NOT D'CVTJ5522).MM522X\n&MMACLIB SETC  'MVS 5.2.2'\n         AGO   .MMX\n.MM522X  ANOP    ,\n         AIF   (NOT D'CVTH5520).MM520X\n&MMACLIB SETC  'MVS 5.2.0'\n         AGO   .MMX\n.MM520X  ANOP  ,\n         AIF   (NOT D'CVTH5510).MM510X\n&MMACLIB SETC  'MVS 5.1.0'\n         AGO   .MMX\n.MM510X  ANOP  ,\n         AIF   (NOT D'CVTH4430).MM430X\n&MMACLIB SETC  'MVS 4.3.0'\n         AGO   .MMX\n.MM430X  ANOP  ,\n         AIF   (NOT D'CVTJ4422).MM422X\n&MMACLIB SETC  'MVS 4.2.2'\n         AGO   .MMX\n.MM422X  ANOP  ,\n         AIF   (NOT D'CVTH4420).MM420X\n&MMACLIB SETC  'MVS 4.2.0'\n         AGO   .MMX\n.MM420X  ANOP  ,\n         AIF   (NOT D'CVTH4410).MM410X\n         AGO   .MMX\n&MMACLIB SETC  'MVS 4.1.0'\n.MM410X  ANOP  ,\n         AIF   (NOT D'CVTJ3313).MM313X\n&MMACLIB SETC  'MVS 3.1.3'\n         AGO   .MMX\n.MM313X  ANOP  ,\n         AIF   (NOT D'CVTJ3311).MM311X\n&MMACLIB SETC  'MVS 3.1.1'\n         AGO   .MMX\n.MM311X  ANOP  ,\n         AIF   (NOT D'CVTH3310).MM310X\n&MMACLIB SETC  'MVS 3.1.0'\n         AGO   .MMX\n.MM310X  ANOP  ,\n&MMACLIB SETC  'Pre-MVS3.1.0'             ..Default to pre-MVS3.1.0\n.MMX     ANOP  ,\n         EJECT\n***********************************************************************\n***\n**       External Dsects\n***\n***********************************************************************\n         SPACE 2\n         PRINT GEN\n         IECDDCE ,                        DASD Class Extension\n         EJECT ,\n         LSPACE MF=(D,DATA)               LSPACE data mapping\n         EJECT ,\n         LSPACE MF=(D,MSG)                LSPACE msg mapping\n         EJECT ,\n         IECSDSL1 (1,2,3,4,5,6)           DSCB\n         EJECT ,\n         ICVAFPL ,                        CVPL - CVAF macros\n         EJECT ,\n         ICVAFBFL ,                       CVAF Buffer lists\n         EJECT ,\n         IEFUCBOB PREFIX=YES              Unit control block\n         PRINT NOGEN\n         EJECT ,\n         IHAPSA ,                         Prefixed Save Area\n         IHASDWA ,                        System Diagnostic Work Area\n         IEZJSCB ,                        Job Step Control Block\n         IEFJSSIB ,                       Sub System ID block\n         IKJTCB DSECT=YES,LIST=NO         Task control block\n         DCBD DEVD=DA,DSORG=PS            Data Control Block\n         IHADECB ,                        Data Event Control Block\n         IEFZB4D0 ,                       SVC 99 - RB\n         IEFZB4D2 ,                       SVC 99 - Text Equates\n         IEFJFCBN ,                       Job File Control block\n         IEESMCA ,                        SMF Control Area\n         IEFJESCT ,                       JES control Table\n         IEFJSCVT ,                       SubSystem Control Table\n         IEFJSSVT ,                       SubSystem Vector Table\n*        ICHPRCVT ,                       RACF CVT\n         IKJCPPL ,                        Command Proc Parm list\n         AIF   (NOT D'CVTH4410).MECVTX    Have a ECVT in MACLIB?\n         IHAECVT DSECT=YES                Extended CVT\n.MECVT   ANOP  ,\n         YREGS ,                          Expand R0-R15 (registers)\n*\n** Our macros\n*\n         DA#DATE ,                        Date Routine\n         DA#MXD ,                         Mini-hex dump routine\n         PRINT GEN\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***\n**       Program initialization\n***\n***********************************************************************\n         SPACE 2\nDA$DISKR CSECT ,\nDA$DISKR AMODE 31\nDA$DISKR RMODE ANY\n*\n** Standard O/S eyecatcher\n*\nDRU_EC   B    DRU_ECL(0,R15)            Bump past EyeCatcher\n         DC   AL1(DRU_ECE-DRU_ECV)      Length of eyecatcher\nDRU_ECV  DC   C'DA$DISKR &ASMDATE &SYSTIME V&DAVER '\n         DC   C'Utility: DASD Usage Reporter'\nDRU_ECE  EQU  *\n         DS   0H\nDRU_ECL  EQU  *-DRU_EC\n*\n** Standard ESA entry housekeeping code\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         LAE   R11,2048(,R12)           Set up for second base reg\n         LA    R11,2048(,R11)           Locate 4096 past R12\n         LAE   R10,2048(,R11)           Set up for third base reg\n         LA    R10,2048(,R10)           Locate 4096 past R11\n         USING DA$DISKR,R12,R11,R10     Set module base\n*\n** Obtain Dynamic Save Area\n*\n         STORAGE OBTAIN,LENGTH=DSAL,LOC=BELOW Obtain storage\n         LR    R13,R1                   Point to Save Area\n*\n         LR    R14,R13                  To: Address\n         L     R15,=A(DSAL)             To: Length\n         SLR   R1,R1                    From: Set length and pad\n         MVCL  R14,R0                   Zero out area\n*\n         MVC   4(4,R13),=C'F1SA'        Indicate stack SA\n         USING DSA,R13                  Get addressibility to area\n*\n** Set Default options\n*\n         MVI   PSR_LC,99                  Force heading on 1st rec\n*\n** Set DDNAMEs - This needs to be changed back to dynamic allocations\n*\n         L     R14,=V(DRU$OPTS)           Locate options CSECT\n         MVC   DDN_WF1(8),OP_WF1-OP(R14)  LRECL=512\n         MVC   DDN_WF2(8),OP_WF2-OP(R14)  LRECL=512\n         MVC   DDN_WF3(8),OP_WF3-OP(R14)  LRECL=512\n         MVC   DDN_WF4(8),OP_WF4-OP(R14)  LRECL=80\n         MVC   DDN_WF5(8),OP_WF5-OP(R14)  LRECL=121\n         MVC   DDN_VAT(8),OP_VAT-OP(R14)  LRECL=80\n*\n** Doing VTOC report?\n*\n         DEVTYPE =CL8'VTOCRPT',DOUBLE     Get VTOCRPT information\n         LTR   R15,R15                    Is it allocated?\n         BNZ   I$VRX                      No, continue\n         OI    FLAG_X1,$FX1_VTOC          Turn on flag\nI$VRX    EQU   *\n*\n** Invoke the parse routine\n*\n*        MVI   PPC_DATEF,$PPC_DFEGREG    Date format is Eur Greg\n         L     R8,=V(DRU$PPC)             Locate CSECT\n         BASSM R9,R8                      Invoke the parse routine\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Act upon options found                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Test for APF authorization and set flag if on\n*\n         TESTAUTH FCTN=1                  Test APF authorization\n         LTR   R15,R15                    Are we authorized?\n         BNZ   I$APFX                     No, continue\n         OI    FLAG_X1,$FX1_APF           Yes, set flag\nI$APFX   EQU   *\n*\n** Load routines to be used for life of job\n*\n         LOAD  EPLOC==CL8'IEFEB4UV',ERRET=I$EB4UVX\n         ST    R0,EP_EB4UV\nI$EB4UVX EQU   *\n         ICM   R0,B'1111',=V(DA$MXD)\n         BNZ   I$MXDL\n         LOAD  EPLOC==CL8'DA$MXD',ERRET=I$MXDX\n         OI    FLAG_X2,$FX2_LMXD\nI$MXDL   DS    0H\n         ST    R0,EP_DA$MXD\nI$MXDX   EQU   *\n         ICM   R0,B'1111',=V(DA$DATE)\n         BNZ   I$DATEL\n         LOAD  EPLOC==CL8'DA$DATE',ERRET=I$DATEX\n         OI    FLAG_X2,$FX2_LDATE\nI$DATEL  DS    0H\n         ST    R0,EP_DA$DATE\nI$DATEX  EQU   *\n*\n         TM    FLAG_X1,$FX1_APF           APF authorized?\n         BNO   I$SS01X                    No, continue\n         TM    PPC_FLAG2,$PPC_F2NAUTH     Doing authorized stuff?\n         BNO   I$SS01X                    No, continue\n         LOAD  EPLOC==CL8'IDCSS01',ERRET=I$SS01X\n         ST    R0,EP_SS01\nI$SS01X  EQU   *\n*\n** Open Messages file\n*\n         LA    R3,SYSPRINT                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'\n         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n*\n** Print starting message\n*\n         TIME  BIN\n         ST    R0,DOUBLE\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG1L,R15),MSG1-DRU$CON1(R1)  Get message\n         LA    R15,MSG1L+1(R15)           Bump past the message\n         MVC   0(MSG1AL,R15),MSG1A-DRU$CON1(R1)\n         LA    R15,MSG1AL(R15)\n         L     R1,DOUBLE\n         BAS   R14,CONVERT_BINARY_TIME\n         LA    R15,10(R15)\n*\n         TM    FLAG_X1,$FX1_APF           APF authorized?\n         BNO   I$MSG1APX\n         MVC   0(5,R15),=CL5'(APF)'\n         LA    R15,6(R15)\nI$MSG1APX EQU  *\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n*\n         L     R7,=V(DRU$CON1)            Locate constants CSECT\n         TM    PPC_FLAG2,$PPC_F2NOPIC\n         BNO   I$PICS\n         LA    R7,NO_PICTURE-DRU$CON1(R7) Locate text strings\n         B     I$PICL\nI$PICS   DS    0H\n         LA    R7,STARTUP_PICTURE-DRU$CON1(R7) Locate Startup picture\nI$PICL   DS    0H\n         LA    R15,RECOUT+5               Locate output area\n         SLR   R14,R14                    Clear register for IC\n         IC    R14,0(R7)                  Obtain length of messsage - 1\n         EX    R14,I$PICM                 Move string to message area\n         LA    R7,2(R14,R7)               Bump past this string\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         CLC   0(2,R7),=X'FFFFFFFF'       At end of strings?\n         BNE   I$PICL                     No, continue\n         B     I$PICX\nI$PICM   MVC   0(0,R15),1(R7)\nI$PICX   DS    0H\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print another blank line\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Print parm card if any\n*\n         BAS   R14,FORMAT_MESSAGE         Format message\n         MVC   0(MSG30L,R15),MSG30-DRU$CON1(R1)\n         LA    R15,MSG30L+1(R15)          Bump past it\n         ICM   R1,B'1111',PPC_CB+4        Get address of parameter\n         BZ    I$PPCX\n         ICM   R14,B'1111',PPC_CB         Get Lenght of parameter\n         BCTR  R14,0                      Decrement by 1\n         EX    R14,I$PPCPM                Move parameter to message\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Print Errors in parm card\n*\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0011',PPC_NUM         Get number of parm errors\n         BZ    I$PPCX                     None, continue\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG31L,R15),MSG31-DRU$CON1(R1) Move in message\n         LA    R15,MSG31L+1(R15)          Bump past it\n         LH    R1,PPC_COL                 Get parameter column\n         LA    R1,1(R1)                   Start from 1 not zero\n         BAS   R9,EDITFWF                 Print column number\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG32L,R15),MSG32-DRU$CON1(R1) Move in message\n         LA    R15,MSG32L+1(R15)          Bump past it\n         LH    R1,PPC_NUM                 Get number of parm errors\n         BAS   R9,EDITFWF                 Print it\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         MVI   MAXCC,20\n         B     EXIT\nI$PPCPM  MVC   0(0,R15),0(R1)\nI$PPCX   DS    0H\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print the DFSMS (if under DFSMS), DFP and MVS BCP levels\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG63L,R15),MSG63-DRU$CON1(R1) Move in message\n         LA    R15,MSG63L+1(R15)          Bump past it\n*\n** Insert \"DF/SMS level\" (if we are executing on a system with DFSMS)\n** into message\n*\n         MVC   G_DFSMSLVL(5),=C'N/A  '\n         L     R2,CVTPTR                  -> CVT\n         L     R2,CVTDFA-CVTMAP(R2)       -> Data Facilities Area\n         AIF   ('&IHADFARELS' LT '01010100').RELSX .at DFSMS/MVS 1.1?\n         CLC   DFARELS-DFA(4,R2),=8X'00'  Pre-DFSMS/MVS?\n         BE    I$SMSLX                    Yes, skip\n         MVC   G_DFARELS(4),DFARELS-DFA(R2) Save DFSMS/MVS level info\n         LA    R4,DFAVER-DFA(R2)          Locate to version\n         LA    R5,L'DFAVER+L'DFARLSE+L'DFAMOD Length to consider\n         L     R1,=V(DRU$CON1)\n         MVC   0(L'MSG63B,R15),MSG63B-DRU$CON1(R1)\n         LA    R15,L'MSG63B+1(R15)\n         ST    R15,PARMLIST\nI$SMSLL  DS    0H\n         SLR   R1,R1                      Get ready for Insert\n         IC    R1,0(R4)                   Get value\n         BAS   R9,EDITFWF                 Edit it flush\n         MVI   0(R15),C'.'                Insert delimiter\n         LA    R15,1(R15)                 Bump past delimiter\n         LA    R4,1(R4)                   Bump to next value\n         BCT   R5,I$SMSLL                 ..Try it out\n         L     R1,PARMLIST\n         MVC   G_DFSMSLVL(5),0(R1)        Save level\n         BCTR  R15,0\n         MVI   0(R15),C' '\n         LA    R15,1(R15)\n         MVI   0(R15),C'-'\n         LA    R15,2(R15)                 Locate past it\nI$SMSLX  DS    0H\n.RELSX ANOP ,\n*\n** Insert \"DFP level\" into message\n*\n         L     R1,=V(DRU$CON1)\n         MVC   0(L'MSG63D,R15),MSG63D-DRU$CON1(R1)\n         LA    R15,L'MSG63D+1(R15)\n         UNPK  DOUBLE2(5),DFAREL-DFA(3,R2)\n         MVZ   DOUBLE2(4),=8X'00'\n         TR    DOUBLE2(4),=C'0123456789ABCDEF'\n         MVC   0(1,R15),DOUBLE2\n         MVI   1(R15),C'.'\n         MVC   2(1,R15),DOUBLE2+1\n         MVI   3(R15),C'.'\n         MVC   4(1,R15),DOUBLE2+2\n         MVC   G_DFPLVL(5),0(R15)          Save DFP level for later\n         LA    R15,6(R15)\n*\n** Insert \"MVS BCP level\" into message\n*\n         L     R1,=V(DRU$CON1)            Locate constants CSECT\n         MVC   0(L'MSG63E,R15),MSG63E-DRU$CON1(R1)\n         LA    R15,L'MSG63E+1(R15)\n         L     R1,CVTPTR                  -> CVT\n         LA    R0,CVTLEVL+L'CVTLEVL-CVTFIX Length of CVT prefix\n         SR    R1,R0                      -> Backup to start of Prefix\n         MVC   G_BCPLEVEL(L'CVTPRODN),CVTPRODN-CVTFIX(R1)\n         MVC   0(L'CVTPRODN,R15),G_BCPLEVEL\n*\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Authorization\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Print authorization message\n*\n         TM    FLAG_X1,$FX1_APF           Running authorized?\n         BNO   I$AUTHTX                   No, continue\n         TM    PPC_FLAG2,$PPC_F2NAUTH     Don't use authorized stuff\n         BNO   I$AUTHTX                   No, continue\n         NI    FLAG_X1,255-$FX1_APF       Turn off authorized fuctions\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG24L,R15),MSG24-DRU$CON1(R1) Get message\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     I$AUTHMX                   Bump past auth check\nI$AUTHTX EQU   *\n*\n** Print authorization message\n*\n         TM    FLAG_X1,$FX1_APF           Running authorized?\n         BO    I$AUTHMX                   No, continue\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG20L,R15),MSG20-DRU$CON1(R1) Get message\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nI$AUTHMX EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print help information\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Print help information if requested\n*\n         TM    PPC_FLAG2,$PPC_F2HELP\n         BNO   I$HELPX\n         LA    R0,SUBRSA\n         L     R15,=V(DRU$HELP)\n         BASR  R14,R15\nI$HELPX  DS    0H\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Check out the MVS level\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Use the UCBSCAN macro if executing on a MVS v4.2.2 system or higher\n*\n         CLC   G_BCPLEVEL(5),=C'SP4.2.2'  Under the weather?\n         BL    I$UCBSX                    Yes, use CVTUCBSC\n         OI    FLAG_X1,$FX1_UCBSCAN       Use UCBSCAN macro\nI$UCBSX  DS    0H\n*\n** Act on CVTUCBSC flag\n*\n         TM    PPC_FLAG2,$PPC_F2CVTUS     User wants old service?\n         BNO   I$UCVTUSX                  No, continue\n         CLC   G_BCPLEVEL(5),=C'SP5.2'    Under\n         BL    I$UCVTUSX                  No, problem\n         NI    FLAG_X1,255-$FX1_UCBSCAN   Use UCBSCAN macro\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG36L,R15),MSG36-DRU$CON1(R1) Get message\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nI$UCVTUSX DS   0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Scan thru DASD UCB's and save online ones into work file    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Open work file for system Configuration information\n*\n         LA    R3,WRKFILE1                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1 Move in DDNAME\n         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n*\n** Obtain DASD Device count table\n*\n#DDCEN   EQU   64\n         LA    R0,DDC_HL+((#DDCEN+1)*DDC_EL)\n         GETMAIN R,LV=(0)                Obtain table\n         STM   R0,R1,SDU_DDC             Save length and address\n         MVC   DDC_HID-DDC_H(8,R1),=CL8'DASD-DC' Set eyecatcher\n         MVI   DDC_HL(R1),X'FF'          Set end of table\n*\n** Create ESTAE exit for UCB processing\n*\n         SPACE 2\n         L     R14,=V(DRU$CON1)           -> DRU$CON1\n         MVC   PARMLIST(C_ESTAEL),C_ESTAE-DRU$CON1(R14)\n*\n         STM   R10,R12,RSEP_R10           Save base registers\n         LA    R8,RSEP                    Locate parameters\n         L     R9,=V(DRU$ESTA)            Locate routine\n         ESTAE (9),CT,                    Create new ESTAE             @\n               PARAM=((8)),               ..Parameter passed to rout.  @\n               MF=(E,PARMLIST)            ..Parameter list\n         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Scan through DASD UCBs\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\n*\n** Start of DASD UCB loop\n*\n         LA    R8,WRKREC                  Locate output record\n         SLR   R7,R7                      Zero DASD count\n         MVI   SDU_DEVT,UCB3DACC          Only process DASD Devices\n         XC    SDU_WA(L'SDU_WA),SDU_WA  Clear workarea to binary zeros\n         LA    R2,SDU_UA                Keep address of UCB returned\n         ST    R2,SDU_UCB                 Get address of UCB\n         LA    R1,256\n         STH   R1,SDU_DCELEN\n*\nSDU$L    DS    0H\n         TM    FLAG_X1,$FX1_UCBSCAN       Use UCBSCAN macro?\n         BO    SDU$LUSS                   Yes, continue\n         L     R15,CVTPTR                 ->  CVT\n         L     R15,CVTUCBSC-CVTMAP(R15)   ->  Scan service address\n         CALL  (15),                      Call UCB scan service        @\n               (SDU_WA,SDU_DEVT,SDU_UCB), ..Parameters                 @\n               VL,MF=(E,PARMLIST)         ..Parm list\n         LTR   R15,R15                    End of DASD UCBs?\n         BNZ   SDU$LX                     Yes, leave\n         L     R2,SDU_UCB                 Get address of UCB\n         B     SDU$LUSX                   Continue\n****\nSDU$LUSS DS    0H\n         UCBSCAN COPY,                  Get UCB copy                   @\n               WORKAREA=SDU_WA,         ..Work area                    @\n               UCBAREA=SDU_UA,          ..UCB area                     @\n               CMXTAREA=SDU_CMXT,       ..CMXT area                    @\n               UCBPAREA=SDU_UCBP,       ..UCB Prefix                   @\n               DCEAREA=SDU_DCE,         ..DCE area                     @\n               DCELEN=SDU_DCELEN,       ..DCE length                   @\n               DYNAMIC=YES,             ..Get all UCBs                 @\n               RANGE=ALL,               ..Yes these too                @\n               DEVCLASS=DASD,           ..Only DASD devices though     @\n               RETCODE=SDU_RETCODE,     ..Return RC here               @\n               RSNCODE=SDU_RSNCODE,     ..Return Reason code here      @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                  Check return code\n         BZ    SDU$LUSX                 Okay, continue\n         C     R15,=F'4'                End of UCB's?\n         BE    SDU$LX                   Yes, leave\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG37L,R15),MSG37-DRU$CON1(R1)\n         LA    R15,MSG37L(R15)            Bump past message\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4(R15)\n         MVC   0(5,R15),=C', RC='\n         LA    R15,5(R15)\n         UNPK  0(9,R15),SDU_RETCODE(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         MVC   0(6,R15),=C', RSN='\n         LA    R15,6(R15)\n         UNPK  0(9,R15),SDU_RSNCODE(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n*        LA    R15,8(R15)\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     SDU$L\nSDU$LUSX DS    0H\n*\n** UCB check\n*\n         TM    UCBSTAT-UCBOB(R2),UCBONLI  Is it online?\n         BNO   SDU$STAT$OFF               No, get next one\n         CLC   UCBVOLI-UCBOB(6,R2),=8X'00' Valid volser?\n         BE    SDU$STAT$OFFV              No, ignore it\n         L     R1,SDU_CON                 Get current count of online\n         LA    R1,1(R1)                   Increment count\n         ST    R1,SDU_CON                 Save count\n         B     SDU$STATX                  Continue\nSDU$STAT$OFFV DS 0H\n         TM    PPC_FLAG2,$PPC_F2DEBUG     Flag on?\n         BNO   SDU$STAT$OFF               No, continue\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG38L,R15),MSG38-DRU$CON1(R1)\n         MVC   MSG38L(4,R15),WD_UCB-WD(R8)\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nSDU$STAT$OFF EQU *\n         L     R1,SDU_COFF                Get current count of online\n         LA    R1,1(R1)                   Increment count\n         ST    R1,SDU_COFF                Save count\n         B     SDU$L                      Skip this puppy\nSDU$STATX EQU *\n         LA    R7,1(R7)                   Increment online DASD count\n*\n** Do we need to process this volume?\n*\n         CLI   PPC_VPREFIXL,$PPC_NOCHK    Don't check volume prefix?\n         BE    SDU$VOLCM                  Yes, skip check\n         SLR   R1,R1                      Clear reg for IC\n         IC    R1,PPC_VPREFIXL            Get volume length\n         EX    R1,SDU$VOLCC               Match?\n         BNE   SDU$L                      No, bypass volume\nSDU$VOLCM DS   0H\n         L     R1,SDU_CMATCH              Get current match count\n         LA    R1,1(R1)                   Increment count\n         ST    R1,SDU_CMATCH              Save count\n         B     SDU$VOLCX\nSDU$VOLCC CLC  UCBVOLI-UCBOB(0,R2),PPC_VPREFIX\nSDU$VOLCX DS   0H\n*\n** Initialization for this record\n*\n         MVI   0(R8),0                    Get hex zeros\n         MVC   1(132,R8),0(R8)            ..Propagate them\n         MVC   WD_VER-WD(4,R8),DRU_ECV+9 Get \"vV.M'\n*\n** UCB information\n*\n         MVC   WD_VOLS-WD(6,R8),UCBVOLI-UCBOB(R2)  Volume serial\n         UNPK  WD_UCB-WD(5,R8),UCBCHAN-UCBOB(3,R2)\n         MVZ   WD_UCB-WD(4,R8),=8X'00'\n         TR    WD_UCB-WD(4,R8),=C'0123456789ABCDEF'\n*\n         MVC   RSEP_VOL(6),UCBVOLI-UCBOB(R2)       Volume serial\n         MVC   RSEP_UCB(4),WD_UCB-WD(R8)\n*\n** Save the System name in case the work file is being read by\n** another program to merge fields from different systems\n*\n         L     R15,CVTPTR                 ->  CVT\n         MVC   WD_SNAME-WD(8,R8),CVTSNAME-CVTMAP(R15) Save system\n*\n** Get UCB mount status\n*\n         MVC   WD_SMNT-WD(3,R8),=C'   '\n         TM    UCBSTAB-UCBOB(R2),UCBBSTR  Pack usage = Storage?\n         BO    SDU$CU0                    Yes, move on\n         TM    UCBSTAB-UCBOB(R2),UCBBPUB  Pack usage = Public?\n         BO    SDU$CU1                    Yes, Move on\n         MVC   WD_SMNT-WD(3,R8),=C'PRI'\n         B     SDU$CUX\nSDU$CU0  DS    0H\n         MVC   WD_SMNT-WD(3,R8),=C'STR'\n         B     SDU$CUX\nSDU$CU1  DS    0H\n         MVC   WD_SMNT-WD(3,R8),=C'PUB'\nSDU$CUX  DS    0H\n*\n** Get device type\n*\n         ICM   R15,B'1111',EP_EB4UV       Routine loaded?\n         BZ    SDU$DTX                    No, leave\n*\n         LA    R1,SDU$DTE-DA$DISKR        Locate retry offset\n         STH   R1,RSEP_RETRYO             Save retry address\n         MVC   RSEP_FUNC(8),=CL8'IEFEB4UV' Set reason\n*\n         LA    R1,PARMLIST+8              Locate our input parm\n         MVI   0(R1),0                    Get zeroes\n         MVC   1(19,R1),0(R1)             ..propagate them\n         MVC   8(4,R1),UCBTYP-UCBOB(R2)   Get device type\n* Note: IEFEB4UV returns RC=4 when X'3030200E' but 0 if X'3010200E'\n MVI 8+1(R1),X'10'  Why do I have to do this? #@($*&#@($*&#$@\n         DA#SMODE 31                      Get into 31 bit mode\n         CALL  (15),                      Call unit verification       @\n               (PARMLIST+8,=X'2000'),     ..Unit table, flags          @\n               VL,MF=(E,PARMLIST)         ..Parameter area\n         DA#SMODE 24                      Get back to 24 bit mode\n         LTR   R15,R15                    Check return code\n         BNZ   SDU$DTRCE                  uh oh\n         MVI   WD_DEVTL-WD(R8),4-1        Assume \"3380\" length\n         MVC   WD_DEVT-WD(8,R8),PARMLIST+8 Get device type returned\n         MVC   WD_DEVTA-WD(8,R8),PARMLIST+8 Get device type returned\n         B     SDU$DTX                    Continue\nSDU$DTRCE EQU  *\n         LR    R5,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG7L,R15),MSG7-DRU$CON1(R1)\n         LA    R15,MSG7L(R15)             Bump past the message\n         LR    R1,R5                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(6,R15),=C', UCB='        Text\n         LA    R15,6(R15)\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     SDU$DTX\nSDU$DTE  DS    0H\n         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address\n         BAS   R14,SDU$UCBE               Call error routine\n         MVI   WD_DEVTL-WD(R8),1-1\n         MVI   WD_DEVT-WD(R8),C'?'\n         MVI   WD_DEVTA-WD(R8),C'?'\nSDU$DTX  EQU   *\n*-Note: I've taken out this code for two reasons (18-MAR-1997):\n*------ 1) Claim back more room in the main CSECT\n*------ 2) I wonder how useful this is or if it actually works right\n AGO .SYSVTOCX\n*\n** Issue ENQ for SYSVTOC, Don't get hung up on one volume.\n** You can only ENQ on \"SYS\" stuff when you are authorized or ABEND\n*\n         TM    FLAG_X1,$FX1_APF           APF authorized?\n         BNO   SDU$ENQX                   No, continue\n*\n         LA    R1,SDU$ENQE-DA$DISKR       Locate retry offset\n         STH   R1,RSEP_RETRYO             Save retry address\n         MVC   RSEP_FUNC(8),=CL8'ENQ-VTOC' Set reason\n*\n         XC    DOUBLE(4),DOUBLE           Set retry count to zero\n         LA    R9,UCBVOLI-UCBOB(R2)       Locate Volume name\nSDU$ENQL EQU   *\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_ENQL),C_ENQ-DRU$CON1(R1) Get parm list\n         ENQ   (=CL8'SYSVTOC',(9),S,6,SYSTEM),RET=TEST,                @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    Check return code\n         BZ    SDU$ENQX                   Zero, its okay to proceed\n         L     R1,DOUBLE                  Get current retry count\n         LA    R1,1(R1)                   Increment by one\n         CH    R1,=H'5'                   Hit maximun tries yet?\n         BH    SDU$ENQF                   Yes, can't get to volume now\n         ST    R1,DOUBLE                  Save retry count\n         STIMER WAIT,BINTVL==F'0500'      Wait a bit\n         B     SDU$ENQL                   Try again\nSDU$ENQF EQU   *\n         LR    R5,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG2L,R15),MSG2-DRU$CON1(R1)\n         LA    R15,MSG2L(R15)             Bump past the message\n         LR    R1,R5                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(6,R15),=C', UCB='        Text\n         LA    R15,6(R15)\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4(R15)\n         MVC   0(9,R15),=C', Volume='     Text\n         MVC   9(6,R15),UCBVOLI-UCBOB(R2) Move in UCB address\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     SDU$ENQX\nSDU$ENQE DS    0H\n         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address\n         BAS   R14,SDU$UCBE               Call error routine\nSDU$ENQX EQU  *\n.SYSVTOCX ANOP ,\n*\n** Issue the LSPACE SVC for volume space information\n*\n         LA    R1,SDU$LSPCE-DA$DISKR      Locate retry offset\n         STH   R1,RSEP_RETRYO             Save retry address\n         MVC   RSEP_FUNC(8),=CL8'LSPACE'  Set reason\n*\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_LSPCL),C_LSPC-DRU$CON1(R1)\n         LA    R9,WD_LSPCD-WD(R8)         Locate LSPACE Data ret. area\n         LA    R3,WD_F4DSCB-WD(R8)        Locate F4DSCB area\n         MVC   0(C_LSPCDLL,R9),C_LSPCDL-DRU$CON1(R1)\n        LSPACE UCB=(2),                   Obtain DASD space infor      @\n               F4DSCB=(3),                ..F4DSCB                     @\n               DATA=(9),                  ..Data return area           @\n               MF=(E,PARMLIST)            ..Execute from here\n         LTR   R15,R15                    Successful?\n         BZ    SDU$LSPCX                  Yes, move on\n*-If first LSPACE fails, Do another one to get the EBCDIC info\n         OI    WD_FLAG1-WD(R8),$WDF1_NLSPC Set NO LSPACE info\n         LR    R5,R15                     Save return code\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_LSPCL),C_LSPC-DRU$CON1(R1)\n         LA    R9,PARMLIST+C_LSPCL        Locate past parameter list\n        LSPACE UCB=(2),                   Obtain DASD space infor      @\n               MSG=(9),                   ..Data return area           @\n               MF=(E,PARMLIST)            ..Execute from here\n         MVC   WD_LSPCD-WD(L'LSPMTEXT,R8),0(R9)\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG6L,R15),MSG6-DRU$CON1(R1)\n         LA    R15,MSG6L(R15)             Bump past the message\n         LR    R1,R5                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(6,R15),=C', UCB='        Text\n         LA    R15,6(R15)\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4+1(R15)               Bump past UCB\n         MVI   0(R15),C'-'                Insert delimiter\n         MVC   2(L'LSPMTEXT,R15),PARMLIST+C_LSPCL\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     SDU$LSPCX\nSDU$LSPCE DS   0H\n         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address\n         BAS   R14,SDU$UCBE               Call error routine\nSDU$LSPCX EQU  *\n** - - - - - - - - - - - - - - - - - - -  Print areas for debugging\n*-When you want a quick way to see the F4DSCB and LSPACE, then\n*-comment the next line.  You do this in development only!\n         AGO   .DF4LSX\n*\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(132),RECOUT\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)\n         MVC   MSG19L+1(6,R15),=C'F4DSCB'\n         LA    R15,MSG19L+1+6(R15)\n         MVC   0(6,R15),=C', UCB='        Text\n         LA    R15,6(R15)\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4(R15)\n         MVC   0(9,R15),=C', Volume='     Text\n         MVC   9(6,R15),UCBVOLI-UCBOB(R2) Move in UCB address\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(132),RECOUT\n*\n         XC    CMXD_WA(CMXDL),CMXD_WA\n         LA    R15,WD_F4DSCB-WD(R8)       Locate area to print\n         LA    R0,L'WD_F4DSCB             Get length to dump\n         LA    R1,RECOUT+8                Locate output record\n         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)\nSDU$PDAL1 EQU  *\n         LA    R1,CMXD_WA                 Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         STC   R15,CMXD_RC                Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         CLI   CMXD_RC,0                  Any more lines to do...\n         BNE   SDU$PDAL1                  Thank you: May I have another\n*\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(132),RECOUT\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)\n         MVC   MSG19L+1(12,R15),=C'LSpace(Data)'\n         LA    R15,MSG19L+1+12(R15)\n         MVC   0(6,R15),=C', UCB='        Text\n         LA    R15,6(R15)\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4(R15)\n         MVC   0(9,R15),=C', Volume='     Text\n         MVC   9(6,R15),UCBVOLI-UCBOB(R2) Move in UCB address\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(132),RECOUT\n*\n         XC    CMXD_WA(CMXDL),CMXD_WA\n         LA    R15,WD_LSPCD-WD(R8)        Locate area to print\n         LA    R0,L'WD_LSPCD              Get length to dump\n         LA    R1,RECOUT+8                Locate output record\n         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)\nSDU$PDAL2 EQU  *\n         LA    R1,CMXD_WA                 Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         STC   R15,CMXD_RC                Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         CLI   CMXD_RC,0                  Any more lines to do...\n         BNE   SDU$PDAL2                  Thank you: May I have another\n*\n         MVI   RECOUT,C' '\n         MVC   RECOUT+1(132),RECOUT\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nSDU$PDAX DS    0H\n.DF4LSX  ANOP  ,\n** - - - - - - - - - - - - - - - - - - -  Print areas for debugging\n*\n** Calculate VTOC size\n*\n         TM    WD_FLAG1-WD(R8),$WDF1_NLSPC  NO LSPACE info?\n         BO    SDU$VSZX                   Yes, don't have a F4DSCB\n         LA    R5,DS4VTOCE-DS4IDFMT(R3)   Locate VTOC extent\n         SLR   R0,R0                      Clear register\n         SLR   R1,R1                      Clear register\n         SLR   R15,R15                    Clear register\n         ICM   R0,B'0011',2(R5)           Start Cylinder\n         ICM   R1,B'0011',4(R5)           Start Track\n         MH    R0,DS4DEVSZ+2-DS4IDFMT(R3) Convert to tracks\n         ALR   R0,R1                      Relative track\n         ICM   R1,B'0011',6(R5)           End Cylinder\n         ICM   R15,B'0011',8(R5)          End Track\n         MH    R1,DS4DEVSZ+2-DS4IDFMT(R3) Convert to tracks\n         ALR   R1,R15                     Relative track\n         SLR   R1,R0                      Tracks -1\n         LA    R1,1(R1)                   Adjust\n         STCM  R1,B'0011',WD_VTOCT-WD(R8) Save VTOC size in tracks\nSDU$VSZX DS    0H\n*\n** Test for indexed VTOCS, must be after LSPACE for accuracy.\n**\n**  IF (The LSPACE SVC was not issued)\n**     and (The DASD has not been referenced by anybody since IPL)\n**     THEN (CVAFTST will not show Indexed VTOC even if it is)\n*\n         LA    R1,SDU$IVE-DA$DISKR        Locate retry address\n         STH   R1,RSEP_RETRYO             Save retry address\n         MVC   RSEP_FUNC(8),=CL8'CVAFTST' Set reason\n*\n         CVAFTST UCB=(2)                  Test for indexed VTOC\n         CH    R15,=H'8'                  Check return code\n         BNE   SDU$IVX                    Not indexed, move on\n         OI    WD_FLAG1-WD(R8),$WDF1_IVTOC\n         B     SDU$IVX\nSDU$IVE  DS    0H\n         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address\n         BAS   R14,SDU$UCBE               Call error routine\nSDU$IVX  DS    0H\n*\n** Cached volume information\n*\n*-Note: Removed on 18-MAR-1997 - This code hasn't been executed in\n*-      Many years, put back and test...\n AGO .CACHEX\n         LA    R1,SDU$CVE-DA$DISKR        Locate retry address\n         STH   R1,RSEP_RETRYO             Save retry address\n         MVC   RSEP_FUNC(8),=CL8'IDCSS01' Set reason\n*\n*        CLI   UCBTBYT4-UCBOB(R2),X'0E'   3380?\n*        BNE   SDU$CVX\n         SLR   R1,R1\n         ICM   R1,B'0111',UCBEXTP-UCBOB(R2) -> UCB extension\n         BZ    SDU$CVX\n         ICM   R1,B'1111',UCBCLEXT-UCBCMEXT(R1)\n         BZ    SDU$CVX\n         TM    DCEFEAT1-DCE(R1),DCECACHE  Cached controller?\n         BNO   SDU$CVX                    No, volume can't be cached\n         OI    WD_FLAG1-WD(R8),$WDF1_CACHEC Cached Controller...\n         TM    FLAG_X1,$FX1_APF           APF authorized?\n         BNO   SDU$CVX                    No, avoid error\n         ICM   R15,B'1111',EP_SS01        -> IDCSS01\n         BZ    SDU$CVX                    Not available, continue\n*\n         LA    R1,PARMLIST                Parameter list for IDCSS01\n         XC    0(4,R1),0(R1)              Clear word 1 to zeros\n         LA    R14,DOUBLE                 Locate return code area\n         ST    R14,8(R1)                  Save as word 3\n         LA    R14,PARMLIST+20            Locate SSGARGL\n         ST    R14,4(R1)                  Save as word 2\n         LA    R14,WD_VOLS-WD(R8)\n         ST    R14,12(R1)                 Into SSGAVOL\n         LA    R14,UCBTYP-UCBOB(R2)\n         ST    R14,16(R1)                 Into SSGUNIT\n         OI    28(R1),B'01000000'         SSGOPT,SSGRSS SubSys Status\n         BALR  R14,R15\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)\n         MVC   MSG19L+1(17,R15),=C'SSGARGL (IDCSS01)'\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         XC    CMXD_WA(CMXDL),CMXD_WA\n         LA    R15,PARMLIST+20            Locate area to print\n         LA    R0,32                      Get length to dump\n         LA    R1,RECOUT+14               Locate output record\n         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)\nSDU$CVDL EQU   *\n         LA    R1,CMXD_WA                 Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         STC   R15,CMXD_RC                Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         CLI   CMXD_RC,0                  Any more lines to do...\n         BNE   SDU$CVDL                   Thank you: May I have another\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)\n         MVC   MSG19L+1(16,R15),=C'Buffer (IDCSS01)'\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         XC    CMXD_WA(CMXDL),CMXD_WA Initialize parm area\n         LA    R15,PARMLIST+20            Locate area to print\n         L     R15,24(R15)                SSGOADR Address\n         L     R0,20(R5)                  SSGOLN Length\n         LA    R1,RECOUT+14               Locate output record\n         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)\nSDU$CVBL EQU   *\n         LA    R1,CMXD_WA                 Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         STC   R15,CMXD_RC                Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         CLI   CMXD_RC,0                  Any more lines to do...\n         BNE   SDU$CVBL                   Thank you: May I have another\n*\n         B     SDU$CVX\nSDU$CVE  DS    0H\n         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address\n         BAS   R14,SDU$UCBE               Call error routine\nSDU$CVX  DS    0H\n.CACHEX  ANOP  ,\n*\n** Get device type information\n*\n         LA    R1,SDU$DTS-DA$DISKR        Locate retry offset\n         STH   R1,RSEP_RETRYO             Save retry address\n         MVC   RSEP_FUNC(8),=CL8'DEVTYPE' Set reason\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_DTYPEL),C_DTYPE-DRU$CON1(R1)\n         LA    R3,WD_DTAREA-WD(R8)        Locate device type\n       DEVTYPE ,((3),24),                 Obtain device information    @\n               UCBLIST=(SDU_UCB,1),       ..By this UCB                @\n               MF=(E,PARMLIST)            ..Execute from here\n         LTR   R15,R15                    Check return code\n         BZ    SDU$DTS                    Okay?\n         LR    R5,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG5L,R15),MSG5-DRU$CON1(R1)\n         LA    R15,MSG5L(R15)             Bump past the message\n         LR    R1,R5                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(6,R15),=C', UCB='        Text\n         LA    R15,6(R15)\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         MVC   8(4,R3),=AL2(885+1,15)     Assume 3380 single\nSDU$DTS  EQU   *\n         XC    RSEP_FUNC(8),RSEP_FUNC\n*\n** Nickname lookup\n*\n         L     R1,=V(DRU$OPTS)            Locate options CSECT\n         LA    R1,OP_TDASDT-OP(R1)        Locate DASD Type table\n         LA    R0,OP_TDASDTE              Get number of entries\nSDU$DTNL EQU   *\n         CLC   OPTDT_NAME-OPTDT(8,R1),WD_DEVT-WD(R8)\n         BNE   SDU$DTNLB\n         CLC   OPTDT_CYLS-OPTDT(2,R1),8(R3) Cylinders match\n         BNE   SDU$DTNLB\n* Note: Following code *Assumes* 4 byte name, example: 3380 to 3380K\n         MVC   WD_DEVT+4-WD(1,R8),OPTDT_TYPE-OPTDT(R1)\n         B     SDU$DTNLX\nSDU$DTNLB EQU  *\n         LA    R1,OPTDTL(R1)              Bump to next entry\n         BCT   R0,SDU$DTNL                ..Process it\nSDU$DTNLX EQU  *\n*\n** Save count of device type\n*\n         L     R14,SDU_DDC+4              Get table length\n         LA    R14,DDC_HL(R14)            Bump past the header\n         LA    R0,#DDCEN                  Max number\nSDU$DDCL EQU   *\n         CLI   0(R14),X'FF'               End of table?\n         BE    SDU$DDCN                   Yes, new guy\n         CLC   DDC_ENAME-DDC_E(8,R14),WD_DEVT-WD(R8)  Match?\n         BE    SDU$DDCU                   Yes, update count\n         LA    R14,DDC_EL(R14)            No, bump to next entry\n         BCT   R0,SDU$DDCL                    and process it\n         TM    FLAG_X2,$FX2_DDCO          Overflow?\n         BO    SDU$DDCX                   Yes, continue\n         OI    FLAG_X2,$FX2_DDCO          Overflow!\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG29L,R15),MSG29-DRU$CON1(R1) Get message\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     SDU$DDCX\nSDU$DDCN EQU  *\n         MVC   DDC_ENAME-DDC_E(8,R14),WD_DEVT-WD(R8)  Get device name\n         LA    R1,1                                   Get count of 1\n         STCM  R1,B'1111',DDC_ECOUNT-DDC_E(R14)       Save count\n         MVI   DDC_EL(R14),X'FF'              Set new end\n         B     SDU$DDCX\nSDU$DDCU EQU   *\n         ICM   R1,B'1111',DDC_ECOUNT-DDC_E(R14)       Get count\n         LA    R1,1(R1)                               Increment by 1\n         STCM  R1,B'1111',DDC_ECOUNT-DDC_E(R14)       Save count\nSDU$DDCX EQU   *\n*\n** Locate the UCB prefix for some channel trivia\n*\n         LR    R14,R2                     Address of the UCB\n         LA    R15,UCBCMSEG-UCBPXST       Length of offset to prefix\n         SR    R14,R15                    -> UCB prefix\n*-->     MVC   WD_CHPID-WD(8,R8),UCBCHPID-UCBPXST(R14)\n*\n** Print the record on the work file\n*\n         PUT   WRKFILE1,WRKREC            Kick out record\n*\n** Hex dump of input\n*\n         TM    PPC_FLAG2,$PPC_F2DEBUG     Flag on?\n         BNO   SDU$WDX                    No skip debugging\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG19L,R15),MSG19-DRU$CON1(R1)\n         MVC   MSG19L+1(17,R15),=C'Work Area for UCB'\n         LA    R15,MSG19L+1+17+1(R15)\n         UNPK  0(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         XC    CMXD_WA(CMXDL),CMXD_WA\n         LA    R15,WRKREC                 Locate area to print\n         LA    R0,WDL                     Get length to dump\n         LA    R1,RECOUT+14               Locate output record\n         STM   R15,R1,CMXD_WA+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   CMXD_WA+CMXD_OUTPUTL-CMXD(2),=AL2(133-14)\nSDU$WDDL EQU   *\n         LA    R1,CMXD_WA                 Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         STC   R15,CMXD_RC                Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         CLI   CMXD_RC,0                  Any more lines to do...\n         BNE   SDU$WDDL                   Thank you: May I have another\nSDU$WDX  EQU   *\n*\n** End of the loop\n*\n         B     SDU$L                      ..process the next UCB\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Entered ESTAE routine for a UCB\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\nSDU$UCBE DS    0H\n         ST    R14,SDU_UCBERA             Save return address\n*\n** Print error message\n*\n         L     R2,SDU_UCB                 Get address of UCB\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG27L,R15),MSG27-DRU$CON1(R1)\n         UNPK  MSG27UCB-MSG27(5,R15),UCBCHAN-UCBOB(3,R2)\n         MVZ   MSG27UCB-MSG27(4,R15),=8X'00'\n         TR    MSG27UCB-MSG27(4,R15),=C'0123456789ABCDEF'\n         MVI   MSG27D-MSG27(R15),C'-'\n         MVC   MSG27VOL-MSG27(6,R15),UCBVOLI-UCBOB(R2)\n         MVC   MSG27ID-MSG27(8,R15),RSEP_FUNC\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Print error message\n*\n         L     R14,SDU_UCBERA             Get return address\n         BSM   0,R14                      Return to caller\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** End of the DASD UCBs\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\nSDU$LX   DS    0H\n         ST    R7,G_DASD                  Save DASD count\n*\n** Turn off ESTAE\n*\n         XC    RSEP_RETRYO(2),RSEP_RETRYO Reset retry address\n         ESTAE 0                          Turn off ESTAE exit\n*\n** Close the work file\n*\n         LA    R3,WRKFILE1                Locate the work file\n         BAS   R9,CLOSE_FILE              Close file\n*\n** Print some mindless trivia\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG28L,R15),MSG28-DRU$CON1(R1)  Get message\n         LA    R15,MSG28L(R15)            Bump past message\n         L     R1,SDU_CON                 Get online DASD count\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(10,R15),=C', Offline='   Insert text\n         LA    R15,10(R15)                Bump past it\n         L     R1,SDU_COFF                Get the offline count\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(8,R15),=C', Total='\n         LA    R15,8(R15)\n         L     R1,SDU_CON                 Get the online DASD count\n         A     R1,SDU_COFF                Add in offline ones\n         BAS   R9,EDITFWF                 Edit the return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Look at the number of volumes matched\n*\n         CLI   PPC_VPREFIXL,$PPC_NOCHK    Don't check volume prefix?\n         BE    SDU$MCX                    Yes, skip message\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG33L,R15),MSG33-DRU$CON1(R1)  Get message\n         LA    R15,MSG33L+1(R15)          Bump past message\n         L     R1,SDU_CMATCH              Get current match count\n         BAS   R9,EDITFWF                 Edit the return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         ICM   R1,B'1111',SDU_CMATCH      Hey, wait a second\n         BNZ   SDU$MCX                    whew, looks okay\n         MVI   MAXCC,8                    Set a bad cond code\n         B     EXIT                       ..and leave\nSDU$MCX  DS    0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process VATDEF card (ESA or higher)                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 3\n         MVC   PVC_IPLUSE(3),=C'PUB'\n         MVC   PVC_SYSUSE(3),=C'PUB'\n         MVC   PARMLIST+200(6),=C'PUBLIC('\n         MVI   PARMLIST+200+6,C' '\n         MVC   PARMLIST+207(7),PARMLIST+200\n*\n** Open VATLST\n*\n         LA    R3,WRKFILE4                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_VAT  Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n*\n         LA    R2,PVC$EOF                 Locate END-OF-FILE area\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n*\n         OPEN  ((3),(INPUT)),             Open the file                @\n               MF=(E,PARMLIST)\n*\n** Read first record\n*\n         GET   (3)                        Read record (address in R1)\n*\n         LA    R0,72-7                    Set max search limit\n         LR    R14,R1\nPVC$VDL  EQU   *\n         CLI   0(R14),C' '                Blank?\n         BNE   PVC$VDLX                   No, continue\n         LA    R14,1(R14)                 Bump to next byte\n         BCT   R0,PVC$VDL                 Process it\n         B     PVC$EOF                    End of statement found\nPVC$VDLX EQU   *\n         CLC   0(7,R14),=C'VATDEF '       VATDEF card?\n         BNE   PVC$EOF                    Yes, leave\n         MVC   PVC_VATDEF(72),0(R1)       Save card for later\n         LA    R14,7(R14)                 Bump past \"VATDEF\"\nPVC$BL   EQU   *\n         CLI   0(R14),C','                Delimiter?\n         BE    PVC$BLB                    Yes, continue\n         CLI   0(R14),C' '                Delimiter?\n         BNE   PVC$BLX                    No, check for operand\nPVC$BLB  EQU   *\n         LA    R14,1(R14)                 Bump to next byte\n         BCT   R0,PVC$BL                  Process it\n         B     PVC$EOF                    End of card...\nPVC$BLX  EQU   *\n         CLC   0(7,R14),=C'IPLUSE('       IPLUSE operand?\n         BE    PVC$IPL\n         CLC   0(7,R14),=C'SYSUSE('       SYSUSE operand?\n         BE    PVC$SYS\nPVC$ERR  EQU   *\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG22L,R15),MSG22-DRU$CON1(R1) Get message\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     PVC$EOF\nPVC$IPL  EQU   *\n         LA    R15,PVC_IPLUSE             Locate output field\n         LA    R1,PARMLIST+200\n         B     PVC$ATTR\nPVC$SYS  EQU   *\n         LA    R15,PVC_SYSUSE             Locate output field\n         LA    R1,PARMLIST+207\nPVC$ATTR EQU   *\n         LA    R14,7(R14)                 Bump past \"xxxUSE(\"\n         SH    R0,=H'7'                   Decrement counter\n         CLC   0(7,R14),=C'PUBLIC)'\n         BE    PVC$APUB\n         CLC   0(8,R14),=C'PRIVATE)'\n         BE    PVC$APRI\n         CLC   0(8,R14),=C'STORAGE)'\n         BNE   PVC$ERR\n         MVC   0(3,R15),=C'STR'\n         MVC   0(7,R1),=C'STORAGE)'\n         LA    R14,8(R14)                 Bump past \"STORAGE)\"\n         SH    R0,=AL2(8-1)               Decrement counter - 1\n         B     PVC$AX\nPVC$APUB EQU   *\n         MVC   0(3,R15),=C'PUB'\n         MVC   0(6,R1),=C'PUBLIC)'\n         MVI   6(R1),C' '\n         LA    R14,7(R14)                 Bump past \"PUBLIC)\"\n         SH    R0,=AL2(7-1)               Decrement counter - 1\n         B     PVC$AX\nPVC$APRI EQU   *\n         MVC   0(3,R15),=C'PRI'\n         MVC   0(7,R1),=C'PRIVATE)'\n         LA    R14,8(R14)                 Bump past \"PRIVATE)\"\n         SH    R0,=AL2(8-1)               Decrement counter - 1\nPVC$AX   EQU   *\n         BCT   R0,PVC$BL\n*\n** End of file\n*\nPVC$EOF  EQU   *\n*\n         LA    R3,WRKFILE4\n         BAS   R9,CLOSE_FILE              Close file\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG21L,R15),MSG21-DRU$CON1(R1) Get message\n*        MVC   MSG21T-MSG21(6,R15),=C'VATLST'\n         MVC   MSG21A-MSG21(7,R15),PARMLIST+200\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG21L,R15),MSG21-DRU$CON1(R1) Get message\n         MVC   MSG21T-MSG21(6,R15),=C'SYSTEM'\n         MVC   MSG21A-MSG21(7,R15),PARMLIST+207\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Merge the VATLST with SYSTEM:                               **\n**       WRKFILE4 - Sorted VATLST         (Input)                    **\n**       WRKFILE2 - Sorted System Config  (Input)                    **\n**       WRKFILE1 - Merged System/VATLST  (Output)                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Sort the System UCB information by Volume                         **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         LA    R1,PARMLIST+16             Locate sort string\n         MVI   0(R1),7                    Set length (-1)\n         MVC   1(8,R1),=C'1,6,CH,A'       Get sort string\n         MVC   SF_SORTIN(8),DDN_WF1       Sort Input file\n         MVC   SF_SORTOUT(8),DDN_WF2      Sort Output file\n*\n         BAS   R14,SORT_FILE              Sort WRKFILE1 by volser\n         LTR   R15,R15\n         BNZ   EXIT\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Sort VATLST into WRKFILE4                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LA    R1,PARMLIST+16             Locate sort string\n         MVI   0(R1),7                    Set length (-1)\n         MVC   1(8,R1),=C'1,6,CH,A'       Get sort string\n         MVC   SF_SORTIN(8),DDN_VAT        Sort Input file\n         MVC   SF_SORTOUT(8),DDN_WF4      Sort Output file\n*\n         BAS   R14,SORT_FILE              Sort VATLST by VOLSER\n         LTR   R15,R15\n         BNZ   EXIT\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Initialize files for VATLST/System Configuration merge      **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** OPEN sorted VATLST file (input)\n*\n         LA    R3,WRKFILE4                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF4  Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n*\n         LA    R2,MVS$VEOF                Locate END-OF-FILE area\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n*\n         OPEN  ((3),(INPUT)),             Open the file                @\n               MF=(E,PARMLIST)\n*\n** Open system configuration file (INPUT)\n*\n         LA    R3,WRKFILE2                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF2 Move in DDname\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n*\n         LA    R2,MVS$SEOF                End of File address\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n*\n         OPEN  ((3),(INPUT)),             Open file                    @\n               MF=(E,PARMLIST)\n*\n** Open merged file (output)\n*\n         LA    R3,WRKFILE1                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1 Move in DDNAME\n         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)\n         OPEN  ((3),(OUTPUT)),            Open DCB                     @\n               MF=(E,PARMLIST)\n*\n** Create table\n*\n         TM    FLAG_X1,$FX1_VTOC          Doing VTOC processing?\n         BNO   MVS$IVX                    No, continue\n         L     R0,G_DASD                  Get number of DASD\n         MH    R0,=AL2(VIL)               Calculate length of table\n       GETMAIN R,LV=(0)                   Obtain Storage\n         STM   R0,R1,PV_VIT               Save Length and Address\n         LR    R8,R1                      Save table address\nMVS$IVX  EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**        Merge System configuration and VATLST                      **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nMVS$LOOP DS    0H\n         BAS   R9,MVS$R4                  Read WRKFILE4 - VATLST\n         BAS   R9,MVS$R2                  Read WRKFILE2 - System config\n*\n** Check for match\n*\nMVS$DEC  DS    0H\n         CLC   WD_VOLS-WD(6,R2),VL_VOLS-VL(R3) Match?\n         BE    MVS$COMB                   Yes, combine records...\n         BH    MVS$RV                     Need another system record\n*\n** DASD volume is on the system but is not in the VATLST\n*\n         LA    R14,WRKREC                 To: address\n         LA    R15,WDL                    To: length\n         LR    R0,R2                      From: Address\n         LA    R1,WDL                     From: length\n         MVCL  R14,R0                     Move record\n*\n         MVC   WRKREC+WD_VMNT-WD(3),PVC_IPLUSE\n         LA    R15,WRKREC+WD_DESC-WD      Locate description\n         MVI   0(R15),C' '                Get blank\n         MVC   1(L'WD_DESC-1,R15),0(R15)  Insert blanks\n         BAS   R9,MVS$W1                  Write current record\n         BAS   R9,MVS$R2                  Read WRKFILE2 - SYSTEM\n         B     MVS$DEC                    Go compare them\n*\n** VATLST record is not a ONLINE DASD volume\n*\nMVS$RV   DS    0H\n         BAS   R9,MVS$IVAT                Increment VATLST\n         BAS   R9,MVS$R4                  READ WRKFILE4 - VATLST\n         B     MVS$DEC                    COMPARE RECORDS\n*\n** Combine the system configuration record with the VATLST\n*\nMVS$COMC CLC   WD_DEVT-WD(0,R15),VL_DEVT-VL(R3) VATLST device\n*\nMVS$COMB DS    0H\n         LA    R14,WRKREC                 To: Address\n         LA    R15,WDL                    To: Length\n         LR    R0,R2                      From: Address\n         LA    R1,WDL                     From: Length\n         MVCL  R14,R0                     Move record\n*\n         LA    R15,WRKREC                 Locate merged record\n         SLR   R1,R1                      Clear register\n         IC    R1,WD_DEVTL-WD(R15)        Get device type\n         EX    R1,MVS$COMC                Match?\n         BE    MVS$COMB_DTX               Device types match!\n         BAS   R14,FORMAT_MESSAGE\n         MVC   0(MSG8L,R15),MSG8-DRU$CON1(R1)\n         LA    R15,MSG8L(R15)             Bump past the message\n         MVC   0(6,R15),WD_VOLS-WD(R2)    Move in volume name\n         LA    R15,6(R15)                 Bump past it\n         MVC   0(8,R15),=C') - UCB='      Move in text\n         LA    R15,8(R15)                 Bump past it\n         MVC   0(8,R15),WD_DEVT-WD(R2)    Move in UCB device type\n         LA    R0,8                       Generate length of Deviec typ\n         BAS   R14,LOCATE_FIRST_SPACE     Locate first space\n         MVC   0(9,R15),=C', VATLST='     Insert text\n         LA    R15,9(R15)                 Bump past it\n         MVC   0(8,R15),VL_DEVT-VL(R3)    Move in VATLST device type\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the warning message\n         LA    R15,WRKREC                 Locate merged record\nMVS$COMB_DTX EQU *\n         MVC   WD_DESC-WD(L'WD_DESC,R15),VL_DESC-VL(R3) Description\n*\n         MVC   WD_VMNT-WD(3,R15),=C'   '\n         CLI   VL_USE-VL(R3),VL_USE0      Pack usage = Storage?\n         BE    MVS$CU0                    Yes, move on\n         CLI   VL_USE-VL(R3),VL_USE1      Pack usage = Public?\n         BE    MVS$CU1                    Yes, Move on\n         MVC   WD_VMNT-WD(3,R15),=C'PRI'\n         B     MVS$CUX\nMVS$CU0  DS    0H\n         MVC   WD_VMNT-WD(3,R15),=C'STR'\n         B     MVS$CUX\nMVS$CU1  DS    0H\n         MVC   WD_VMNT-WD(3,R15),=C'PUB'\nMVS$CUX  DS    0H\n         CLC   WD_VMNT-WD(3,R15),WD_SMNT-WD(R15) VATLST match system\n         BE    MVS$CUCX                   Yes, move on\n         L     R1,G_VATMNT                No, Get count\n         LA    R1,1(R1)                       Increment it by one\n         ST    R1,G_VATMNT                    Save count for later\nMVS$CUCX DS    0H\n         BAS   R9,MVS$W1                  Write record\n         B     MVS$LOOP                   Go get record\n*\n** VATLST increment routine: Save unused VATLST entry into table\n** Note: the first invocation will force a GETMAIN for the table...\n*\nMVS$IVAT DS    0H\n         ICM   R1,B'1111',MVS_IV_VSC      Get current storage location\n         BNZ   MVS$IVGX                   We have one, move on\n         L     R0,=A(4096*IV_LEN)         Max DASD volumes * Entry len\n         GETMAIN R,LV=(0)                 Obtain storage\n         ST    R0,MVS_IV_VSL              Save length obtained\n         ST    R1,MVS_IV_VSA              Save address of storage\nMVS$IVGX DS    0H\n         L     R14,MVS_IV_NUM             Obtain Count\n         LA    R14,1(R14)                 Increment by 1\n         ST    R14,MVS_IV_NUM             Save count\n         MVC   IV_VOL-IV(L'IV_VOL,R1),VL_VOLS-VL(R3)   Move in volser\n         LA    R1,IV_LEN(R1)              Bump to next entry\n         ST    R1,MVS_IV_VSC              Save into table\n         BSM   0,R9\n*\n** Write WRKFILE1 - Merged system configuration/VATLST file\n*\nMVS$W1   DS    0H\n         TM    FLAG_X1,$FX1_VTOC          Doing VTOC processing?\n         BNO   MVS$W1VX                   No, continue\n         STCM  R8,B'1111',WRKREC+WD_VIT-WD Save VTOC Info table entry\n         LA    R8,VIL(R8)                  Bump to next entry\nMVS$W1VX EQU   *\n*\n         PUT   WRKFILE1,WRKREC             Put record on file\n         BSM   0,R9\n*\n** Read WRKFILE2 - Sorted system configuration file\n*\nMVS$R2   DS    0H\n         GET   WRKFILE2                   Get Record\n         LR    R2,R1                      Save record address\n         BSM   0,R9\n*\n** Read WRKFILE4 - Sorted VATLST file\n*\nMVS$R4   DS    0H\n         GET   WRKFILE4                   Get Record\n         CLC   0(6,R1),=C'VATDEF'         VATDEF?\n         BE    MVS$R4                     Yes, skip it\n         LR    R3,R1                      Save record address\n         BSM   0,R9\n*\n** End of file for VATLST, echo remaining system to merged record\n*\nMVS$VEOF DS 0H\n         OI    FLAG_R,$FX1_VEOF           Vatlst End of file flag\n         TM    FLAG_R,$FX1_SEOF           System Config at EOF?\n         BO    MVS$MEOF                   Yes, leave\nMVS$VEL  DS    0H\n         BAS   R9,MVS$R2                  Read system record\n*\n         LA    R14,WRKREC                 To: Address\n         LA    R15,WDL                    To: Length\n         LR    R0,R2                      From: Address\n         LA    R1,WDL                     From: Length\n         MVCL  R14,R0                     Move record\n*\n         LA    R15,WRKREC+WD_DESC-WD      Locate description\n         MVI   0(R15),C' '                Get blank\n         MVC   1(L'WD_DESC-1,R15),0(R15)  Insert blanks\n         BAS   R9,MVS$W1                  Write record\n         B     MVS$VEL                    Read next record\n*\n** End of file for System, Save unused VATLST entries\n*\nMVS$SEOF DS    0H\n         OI    FLAG_R,$FX1_SEOF           System End of file flag\n         TM    FLAG_R,$FX1_VEOF           VATLST at EOF?\n         BO    MVS$MEOF                   Yes, leave\nMVS$SEL  DS    0H\n         BAS   R9,MVS$R4                  Read VATLST record\n         BAS   R9,MVS$IVAT                Save record into table\n         B     MVS$SEL                    Read next record\n*\n** All records read from VATLST and system file, close WORK FILES\n*\nMVS$MEOF DS    0H\n*\n         LA    R3,WRKFILE1\n         BAS   R9,CLOSE_FILE              Close file\n         LA    R3,WRKFILE2\n         BAS   R9,CLOSE_FILE              Close file\n         LA    R3,WRKFILE4\n         BAS   R9,CLOSE_FILE              Close file\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Print mount differences                                          **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         ICM   R2,B'1111',G_VATMNT        Get VATLST-system mount\n         BZ    MVS$MMX                    Zero, move on\n         BAS   R14,FORMAT_MESSAGE         Clear output record to blanks\n         MVC   0(MSG3L,R15),MSG3-DRU$CON1(R1)\n         LA    R15,MSG3L+1(R15)           Bump past it\n         LR    R1,R2                      Get the difference count\n         BAS   R9,EDITFWF                 Edit the number\n         MVC   1(7,R15),=C'volumes'       Message suffix\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\nMVS$MMX  DS    0H\n         SPACE 3\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Print VATLST entries that are not in use\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\n*\n** See if we have any VATLST entries to print\n*\n         ICM   R3,B'1111',MVS_IV_VSA      Get VATLST table address\n         BZ    MVS$PVX                    Not there, leave\n         ICM   R4,B'1111',MVS_IV_VSC      Get current location\n         BZ    MVS$PVX                    Not there, leave\n*\n** Print \"Following\" message\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG12L,R15),MSG12-DRU$CON1(R1)\n         LA    R15,MSG12L+1(R15)          Bump past prefix\n         L     R1,MVS_IV_NUM              Get number\n         BAS   R9,EDITFWF                 Edit it\n         L     R1,=V(DRU$CON1)\n         MVC   0(MSG12AL,R15),MSG12A-DRU$CON1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Loop through table printing entries on SYSPRINT\n*\n         LA    R15,IV_LEN                 Length of table entry\n         SR    R3,R15                     Backup for loop logic\n         SR    R4,R15                     Stop on the last entry...\nMVS$PVML DS    0H\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG12L,R15),MSG12-DRU$CON1(R1)\n         LA    R5,MSG12L+1(R15)           Locate offset to start\n         ST    R5,PV_DECB                 Save output location\n         LA    R6,#VATLSTE                Number of entries across\nMVS$PVLL DS    0H\n         LA    R3,IV_LEN(R3)              Bump to next entry (Input)\n         CR    R3,R4                      Are we at the end\n         BH    MVS$PVLX                   Yes, leave\n         MVC   0(6,R5),IV_VOL-IV(R3)      Move in VOLSER\n         MVI   6(R5),C','                 Insert comma\n         LA    R5,8(R5)                   Bump to next entry (Output)\n         BCT   R6,MVS$PVLL                Do next entry\n* Next 3 instructions are to keep dangling \"volser, +\" if last one...\n         LA    R1,IV_LEN(R3)              Bump to next entry (Input)\n         CR    R1,R4                      Are we at the end\n         BH    MVS$PVME                   Yes, leave\n         MVI   1(R5),C'+'                 Indicate there's more commin'\n         BAS   R14,PRINT_SYSPRINT_RECORD Print record\n         B     MVS$PVML                   Refresh line\n*\n** End of the table found, Print last record (if anything on it)\n*\nMVS$PVLX DS    0H\n         L     R1,PV_DECB                 Get output location\n         CLI   0(R1),C' '                 Anything on last line?\n         BE    MVS$PVMX                   No, move on\nMVS$PVME EQU   *\n         SH    R5,=H'2'                   Backup to last comma\n         MVI   0(R5),C' '                 Rub out comma\n         BAS   R14,PRINT_SYSPRINT_RECORD Print last detail record\nMVS$PVMX DS    0H\n*\n** Free the table's storage\n*\n         L     R0,MVS_IV_VSL              Save length obtained\n         L     R1,MVS_IV_VSA              Save address of storage\n         FREEMAIN R,LV=(0),A=(1)          Free the storage\n*\n** Common exit from PrintVATLST processing\n*\nMVS$PVX  DS    0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Process the VTOCs                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPROCESS_VTOCS EQU *\n         TM    FLAG_X1,$FX1_VTOC          Doing VTOC processing?\n         BNO   PV$X                       No, continue\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         TIME  BIN\n         STM   R0,R1,PV_STOD              Save start time and date\n*\n** OPEN Merged file (INPUT)\n*\n         LA    R3,WRKFILE1                Locate DCB work area\n         L     R1,=V(DRU$CON1)            Locate constant CSECT\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1) Initialize DCB\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1 Move in DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1) Initialize parm\n         LA    R2,PV$LX                   Locate End-of-File routine\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Save EOF routine in DCB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST) Open the file\n*\n** Allocate VTOC output list\n*\n         LA    R3,WRKFILE2                Locate DCB work area\n         L     R1,=V(DRU$CON1)            Locate constant CSECT\n         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)  Initialize DCB\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE2' Set DDNAME\n         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1) Initialize parm\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST) Open file\n*\n** Initialize for RDJFCB processing\n*\n         LA    R1,PV_EXLST                Locate the Exit list\n         LA    R14,E$OPENA                Locate DCB ABEND exit\n         ST    R14,4(R1)                  Insert into EXLST\n         OI    4(R1),X'11'                Set as DCB ABEND exit\n         LA    R14,PV_JFCB                Locate JFCB return area\n         ST    R14,0(R1)                  Save into EXLST\n         OI    0(R1),X'87'                Set for JFCB + End of list\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Initialize for new volume record:\n** o Read record\n** o Locate VTOC information table and initialize it\n** o Dynamically allocate the volume\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nPV$L     DS    0H\n         GET   WRKFILE1                   Get input record\n         LR    R2,R1                      Save address of record\n         XC    PV_DCOUNT(4),PV_DCOUNT     Reset count\n*\n** Print that we are processing a new volume\n*\n         TIME  BIN\n         ST    R0,DOUBLE                  Save time\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG40L,R15),MSG40-DRU$CON1(R1)\n         MVC   MSG40UCB-MSG40(L'WD_UCB,R15),WD_UCB-WD(R2)\n         MVC   MSG40VOL-MSG40(L'WD_VOLS,R15),WD_VOLS-WD(R2)\n         LA    R15,MSG40L(R15)            Bump past the message\n         L     R1,DOUBLE\n         BAS   R14,CONVERT_BINARY_TIME    \" hh:mm:ss\"\n         LA    R15,9(R15)                 Bump past \" hh:mm:ss\"\n         MVC   1(8,R15),=C'- number'\n         LA    R15,1+8+1(R15)\n         L     R1,PV_VCOUNT               Get current count\n         LA    R1,1(R1)\n         ST    R1,PV_VCOUNT               Save new count\n         BAS   R9,EDITFWF\n         MVC   1(2,R15),=C'of'\n         LA    R15,1+2+1(R15)\n         L     R1,SDU_CMATCH              Get total match count\n         BAS   R9,EDITFWF\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Dynamically allocate the volume\n*\n         LA    R14,WD_DEVTA-WD(R2)        Locate device type\n         LA    R15,WD_VOLS-WD(R2)         Locate the volume\n         L     R8,=V(DRU$ALCV)            Locate CSECT\n         BASSM R9,R8                      Allocate volume\n*=> DOUBLE2 has returned DDNAME, R15 has RC from SVC 99/DYNALLOC\n         ICM   R8,B'1111',WD_VIT-WD(R2)   Locate VTOC info Table entry\n         XC    0(VIL,R8),0(R8)            Clear table entry\n         L     R1,DOUBLE2                 Locate DDNAME\n         MVC   VI_DDN-VI(8,R8),0(R1)      Save DDNAME\n         MVC   VI_SER-VI(6,R8),WD_VOLS-WD(R2) Get volume serial\n         LTR   R15,R15                    Volume allocated?\n         BZ    PV$LIX                     Yes, continue\n*\n** Dynamic Allocation to volume failed, print error message\n*\n         LR    R5,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG15L,R15),MSG15-DRU$CON1(R1)\n         LA    R15,MSG15L(R15)            Bump past the message\n         LR    R1,R5                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(9,R15),=C', Volume='     Text\n         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume\n         LA    R15,9(R15)\n         LA    R0,6\n         BAS   R14,LOCATE_FIRST_SPACE\n         MVC   0(11,R15),=C', S99ERROR='\n         LA    R15,11(R15)\n         LA    R14,HEADREC                Get address of work area\n         UNPK  0(5,R15),S99ERROR-S99RB(3,R14)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4(R15)\n         MVC   0(10,R15),=C', S99INFO='\n         LA    R15,10(R15)\n         UNPK  0(5,R15),S99INFO-S99RB(3,R14)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789ABCDEF'\n         LA    R15,4(R15)\n         MVI   0(R15),C' '\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     PV$L\n*\n** Common exit from Initialization processing\n*\nPV$LIX   EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Open the VTOC for processing                                      **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Initialize the VTOC DCB\n*\n         LA    R3,WRKFILE3                Locate DCB work area\n         L     R1,=V(DRU$CON1)            Locate constants CSECT\n         MVC   0(C_DCBVL,R3),C_DCBV-DRU$CON1(R1) Initialize DCB\n         L     R1,DOUBLE2                 Locate returned DDNAME\n         MVC   DCBDDNAM-IHADCB(8,R3),0(R1) Save it for volume access\n         LA    R1,PV_EXLST                Locate for Exit list\n         STCM  R1,B'0111',DCBEXLST-IHADCB+1(R3) SAVE INTO DCB\n         LA    R1,PV$LVX                  Locate End-of-File routine\n         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Save into DCB\n         XC    E_OPENA_CODE(4),E_OPENA_CODE  Reset code\n*\n** Perform a Read_Job_File_Control_Block\n*\n         L     R1,=V(DRU$CON1)            Locate cons\n         MVC   PARMLIST(C_RDJFCBL),C_RDJFCB-DRU$CON1(R1)\n         RDJFCB ((3),(INPUT)),MF=(E,PARMLIST) Read the JFCB\n         LTR   R15,R15                    Test RC\n         BZ    PV$LRJX                    Okay move on\n         LR    R5,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG16L,R15),MSG16-DRU$CON1(R1)\n         LA    R15,MSG16L(R15)            Bump past the message\n         LR    R1,R5                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(9,R15),=C', Volume='     Text\n         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     PV$L\nPV$LRJX  EQU   *\n         LA    R1,PV_JFCB\n         MVI   JFCBDSNM-INFMJFCB(R1),X'04'\n         MVC   JFCBDSNM+1-INFMJFCB(43,R1),JFCBDSNM-INFMJFCB(R1)\n*        MVC   JFCBVOLS-INFMJFCB(6,R1),WD_VOLS-WD(R2)\n         OI    JFCBTSDM-INFMJFCB(R1),JFCNWRIT\n*\n** Open the file\n*\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n         OPEN  ((3),(INPUT)),TYPE=J,MF=(E,PARMLIST)\n         ICM   R0,B'1111',E_OPENA_CODE    Get open ABEND code\n         BNZ   PV$OPENE\n         LTR   R15,R15                    Test RC\n         BZ    PV$LOX                     Okay move on\nPV$OPENE EQU   *\n         LR    R5,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG17L,R15),MSG17-DRU$CON1(R1)\n         LA    R15,MSG17L(R15)            Bump past the message\n         LR    R1,R5                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         ICM   R1,B'1111',E_OPENA_CODE    Get open ABEND code\n         BZ    PV$OEAX\n         N     R1,=A(X'FFF0FF00')         TURN OFF UNNEEDED BITS\n         MVC   0(9,R15),=C', ABEND S'     TEXT\n         LA    R15,9(R15)                 BUMP PAST IT\n         ST    R1,DOUBLE                  SAVE ABEND CODE\n         UNPK  0(9,R15),DOUBLE(5)                   ---+\n         MVZ   0(8,R15),=8X'00'                        | BINARY TO HEX\n         TR    0(8,R15),=C'0123456789ABCDEF'        ---+\n         MVI   3(R15),C'-'                MOVE IN DASH\n         LA    R15,6(R15)\nPV$OEAX  EQU   *\n         MVC   0(9,R15),=C', Volume='     Text\n         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         B     PV$L\n*\n** Processing for this volume has ended, close VTOC file\n*\nPV$LVX   EQU   *\n         TM    WD_FLAG1-WD(R2),$WDF1_CVAFF CVAF failed?\n         BO    PV$LVCVX                   Yes, skip free\n         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC Indexed VTOC?\n         BNO   PV$LVCVX                   No, dont free indexed stuff\n         CVAFDIR ACCESS=RLSE,BUFLIST=0,IXRCDS=NOKEEP,MF=(E,PV_CVPL)\nPV$LVCVX DS    0H\n*        Note: R3 has DCB address\n         BAS   R9,CLOSE_FILE              Close file\n         TM    PPC_FLAG1,$PPC_F1VERB      Verbose mode?\n         BNO   PV$LVXVX\n*-Print elasped time and dataset count\nPV$LVXVX DS    0H\n         B     PV$L                       Next record\n*\n** Common exit from Open processing\n*\nPV$LOX   EQU   *\n         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC Indexed VTOC?\n         BNO   PV$LNILS                   No, do Non-Indexed READ\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Indexed VTOC support                                        **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG41L,R15),MSG41-DRU$CON1(R1)\n         MVC   MSG41T-MSG41(4,R15),=C'CVAF'\n         MVC   MSG41V-MSG41(6,R15),WD_VOLS-WD(R2)\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Initialize for Indexed VTOC processing\n*\n         LA    R1,PV_CVPL                 Locate CVPL\n         L     R14,=V(DRU$CON1)\n         MVC   0(C_CVPLL,R1),C_CVPL-DRU$CON1(R14)\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0111',DCBDEBA-IHADCB(R3) Get DEB address from DCB\n         ST    R14,CVDEB-CVPL(R1)         Save DEB address\n*\n         LA    R14,PV_BAREA               Locate buffer area\n         ST    R14,CVBUFL-CVPL(R1)        Save it in CVPL\n         XC    0(BFLHLN,R14),0(R14)       Clear area\n         MVI   BFLHKEY-BFLHDR(R14),BFLHDSCB DSCBs to be read w/Buf list\n         MVI   BFLHNOE-BFLHDR(R14),1      Set number to retrieve\n*\n         LA    R14,BFLHLN(R14)            Locate to entry location\n         XC    0(BFLELN,R14),0(R14)       Clear area\n         LA    R15,WRKREC+PVR_DSCB-PVR    Locate DSCB area\n         ST    R15,BFLEBUF-BFLE(R14)      Save DSCB return area\n         LA    R15,140                    Get length of DSCB\n         STC   R15,BFLELTH-BFLE(R14)      Save length\n*\n** Read next indexed VTOC record\n*\nPV$LCSL  EQU   *\n       CVAFSEQ MF=(E,PV_CVPL)             Access the VTOC\n         MVI   PV_CVPL+CVFCTN-CVPL,CVSEQGT Make ACCESS=GT\n         LTR   R15,R15                    Test RC\n         BZ    PV$LD                      Okay move on\n         CH    R15,=H'4'                  Right RC for CVSTAT?\n         BNE   PV$LCSN4                   No, error...\n         CLI   PV_CVPL+CVSTAT-CVPL,STAT032 End of data\n         BE    PV$LVX                     Yes, leave\nPV$LCSN4 EQU   *\n         LR    R9,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG18L,R15),MSG18-DRU$CON1(R1)\n         LA    R15,MSG18L(R15)            Bump past the message\n         LR    R1,R9                      Get the return code\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(9,R15),=C', CVSTAT='     Text\n         LA    R15,9(R15)                 Bump past it\n         SLR   R1,R1                      Clear register\n         IC    R1,PV_CVPL+CVSTAT-CVPL     Get status byte\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(9,R15),=C', Volume='     Text\n         MVC   9(6,R15),WD_VOLS-WD(R2)    Move in volume\n         LA    R15,9+6(R15)\n         MVC   0(8,R15),=C', DSCB #'\n         LA    R15,8(R15)\n         ICM   R1,B'1111',PV_DCOUNT       Get current DSCB count\n         LA    R1,1(R1)\n         BAS   R9,EDITFWF                 Edit the return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         ICM   R1,B'1111',PV_DCOUNT       Get current DSCB count\n         BNZ   PV$LVX                     Not on the first one, give up\n*- or do we have to give up?????????\n         OI    WD_FLAG1-WD(R2),$WDF1_CVAFF Set that CVAF failed\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Read Non-Index VTOC with BSAM                                     **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\nPV$LNILS EQU   *\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG41L,R15),MSG41-DRU$CON1(R1)\n         MVC   MSG41T-MSG41(4,R15),=C'BSAM'\n         MVC   MSG41V-MSG41(6,R15),WD_VOLS-WD(R2)\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         LA    R1,PV_DECB\n         L     R14,=V(DRU$CON1)\n         MVC   0(C_DECBL,R1),C_DECB-DRU$CON1(R14)\n         ST    R3,DECDCBAD-DECB(R1)       Save DCB address\n         LA    R14,WRKREC+PVR_DSCB-PVR    Locate DSCB return area\n         ST    R14,DECAREA-DECB(R1)       Set DSCB return area\nPV$LNIL  EQU   *\n         LA    R1,PV_DECB                 Locate DECB\n         READ  (1),SF,MF=E                Read next VTOC record\n         LA    R1,PV_DECB                 Locate DECB\n         CHECK (1)                        Wait for I/O to complete\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Process the DSCB returned to us                                  **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPV$LD    EQU   *\n         L     R1,PV_DCOUNT\n         LA    R1,1(R1)\n         ST    R1,PV_DCOUNT\n*\n** Check the format type\n*\n         LA    R5,WRKREC+PVR_DSCB-PVR    Locate to DSCB returned\n*\n         CLI   DS1FMTID-IECSDSL1(R5),C'1' Format 1 DSCB?\n         BE    PV$LDF1\n         CLI   IECSDSF2-IECSDSL2(R5),C'2' Format 2 DSCB?\n         BE    PV$LDF2\n         CLI   DS3FMTID-IECSDSL3(R5),C'3' Format 3 DSCB?\n         BE    PV$LDF3\n         CLI   DS4IDFMT-IECSDSL4(R5),C'4' Format 4 DSCB?\n         BE    PV$LDF4\n         CLI   DS5FMTID-IECSDSL5(R5),C'5' Format 5 DSCB?\n         BE    PV$LDF5\n         CLI   DS6FMTID-IECSDSL6(R5),C'6' Format 6 DSCB?\n         BNE   PV$LDFX\n         L     R1,VI_F6-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_F6-VI(R8)\n         B     PV$LDFX\n*\n** Format 1\n*\nPV$LDF1  EQU   *\n         L     R1,VI_F1-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_F1-VI(R8)\n*\n         TM    PPC_FLAG2,$PPC_F2ORU       Only RECFM=U?\n         BNO   PV$LD1RUX                  No, take all of them\n         TM    DS1RECFM-IECSDSL1(R5),DS1RECFU  RECFM=U?\n         BNO   PV$LDFX                         No, skip this one\n         TM    PPC_FLAG2,$PPC_F2OLL       Only Load Libraries?\n         BNO   PV$LD1RUX                  No, take all of them\n         TM    DS1DSORG-IECSDSL1(R5),DS1DSGPO  DSORG=PO?\n         BNO   PV$LDFX                         No, skip this one\nPV$LD1RUX DS   0H\n*\n         LA    R4,WRKREC                  Locate start of record\n         MVC   PVR_UCB-PVR(4,R4),WD_UCB-WD(R2)\n         MVC   PVR_VOLS-PVR(6,R4),WD_VOLS-WD(R2)\n         MVI   PVR_CAT-PVR(R4),C' '       Set default value\n*\n         TM    PPC_FLAG1,$PPC_F1CATC      Skip catalog check?\n         BNO   PV$LD1CX                   Yes, skip out of here\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_LOCATEL),C_LOCATE-DRU$CON1(R1)\n         ST    R5,PARMLIST+4              Save into parmeter list\n         LA    R1,WORKAREA                Locate the work area\n         ST    R1,PARMLIST+12             Save into parmeter list\n         LOCATE PARMLIST                  Is the Data set catalogued?\n         LTR   R15,R15                    Well?\n         BNZ   PV$LD1CU                   Nope, move on\n         CLC   PVR_VOLS-PVR(6,R4),WORKAREA+6 Volume match?\n         BE    PV$LD1CX                   Yes, its okay\nPV$LD1CU EQU   *\n         MVI   PVR_CAT-PVR(R4),C'Y'       Not Catalogued flag\n         L     R1,VI_UNCAT-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_UNCAT-VI(R8)\nPV$LD1CX EQU   *\n*\n         CLC   0(12,R5),=C'SYS1.VTOCIX.'\n         BNE   PV$LD1IXX\n         CLC   12(6,R5),PVR_VOLS-PVR(R4)  SYS1.VTOCIX.xxxxxx\n         BE    PV$LD1IXX\n         CLC   13(6,R5),PVR_VOLS-PVR(R4)  SYS1.VTOCIX.Vxxxxxx\n         BE    PV$LD1IXX\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG9L,R15),MSG9-DRU$CON1(R1) Get message\n         LA    R15,MSG9L(R15)             Bump past message\n         MVC   0(6,R15),PVR_VOLS-PVR(R4)  Insert volume\n         MVC   6(6,R15),=C', DSN='        Insert text\n         MVC   6+6(44,R15),0(R5)          Get Dataset name\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nPV$LD1IXX EQU  *\n         CLC   0(11,R5),=C'SYS1.VVDS.V'\n         BNE   PV$LD1VVX\n         CLC   11(6,R5),PVR_VOLS-PVR(R4)\n         BE    PV$LD1VVX\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG9L,R15),MSG9-DRU$CON1(R1)\n         LA    R15,MSG9L(R15)             Bump past message\n         MVC   0(6,R15),PVR_VOLS-PVR(R4)  Insert volume\n         MVC   6(6,R15),=C', DSN='        Insert text\n         MVC   6+6(44,R15),0(R5)          Get Dataset name\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nPV$LD1VVX EQU  *\n*\n         LA    R15,PVR_DSORG-PVR(R4)\n         TM    DS1DSORG-IECSDSL1(R5),DS1DSGIS\n         BO    PV$LDDIS\n         TM    DS1DSORG-IECSDSL1(R5),DS1DSGPS\n         BO    PV$LDDPS\n         TM    DS1DSORG-IECSDSL1(R5),DS1DSGDA\n         BO    PV$LDDDA\n         TM    DS1DSORG-IECSDSL1(R5),DS1DSGPO\n         BO    PV$LDDPO\n         TM    DS1DSORG+1-IECSDSL1(R5),DS1ORGAM\n         BO    PV$LDDAM\n         L     R1,VI_UN-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_UN-VI(R8)\n         B     PV$LDDX\nPV$LDDAM EQU   *\n         MVC   0(2,R15),=C'AM'\n         L     R1,VI_AM-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_AM-VI(R8)\n         B     PV$LDDX\nPV$LDDIS EQU   *\n         MVC   0(2,R15),=C'IS'\n         L     R1,VI_IS-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_IS-VI(R8)\n         B     PV$LDDX\nPV$LDDPO EQU   *\n         MVC   0(2,R15),=C'PO'\n         LA    R15,2(R15)\n         L     R1,VI_PO-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_PO-VI(R8)\n         B     PV$LDDCU\nPV$LDDPS EQU   *\n         MVC   0(2,R15),=C'PS'\n         LA    R15,2(R15)\n         L     R1,VI_PS-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_PS-VI(R8)\n         B     PV$LDDCU\nPV$LDDDA EQU   *\n         MVC   0(2,R15),=C'DA'\n         LA    R15,2(R15)\n         L     R1,VI_DA-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_DA-VI(R8)\n*        B     PV$LDDCU\nPV$LDDCU EQU   *\n         TM    DS1DSORG-IECSDSL1(R5),DS1DSGIS\n         BNO   PV$LDDX\n         MVI   0(R15),C'U'\n*        B     PV$LDDX\nPV$LDDX  EQU   *\n         PUT   WRKFILE2,WRKREC\n         ICM   R8,B'1111',WD_VIT-WD(R2)   Locate VTOC info Table entry\n         B     PV$LDFX\n*\n** Format 2\n*\nPV$LDF2  EQU   *\n         L     R1,VI_F2-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_F2-VI(R8)\n         B     PV$LDFX\n*\n** Format 3\n*\nPV$LDF3  EQU   *\n         L     R1,VI_F3-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_F3-VI(R8)\n         B     PV$LDFX\n*\n** Format 4\n*\nPV$LDF4  EQU   *\n         L     R1,VI_F4-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_F4-VI(R8)\n         B     PV$LDFX\n*\n** Format 5\n*\nPV$LDF5  EQU   *\n         L     R1,VI_F5-VI(R8)\n         LA    R1,1(R1)\n         ST    R1,VI_F5-VI(R8)\n*>       B     PV$LDFX                    Fall into PV$LDFX!!!!!!!!!!!\n*\n** End of format processing\n*\nPV$LDFX  EQU   *\n         TM    WD_FLAG1-WD(R2),$WDF1_CVAFF CVAF failed?\n         BO    PV$LNIL                    Yes, do BSAM not CVAF\n         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC Indexed VTOC?\n         BNO   PV$LNIL                    No, do Non-Indexed READ\n         B     PV$LCSL                    Do next CVAFSEQ read\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** End of file on input merged volume file\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nPV$LX    DS    0H\n*\n** Close the files\n*\n         LA    R3,WRKFILE1\n         BAS   R9,CLOSE_FILE              Close file\n         LA    R3,WRKFILE2\n         BAS   R9,CLOSE_FILE              Close file\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**        Print trivia about elasped time reading vtoc               **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TIME  BIN\n         STM   R0,R1,PV_ETOD              Save end time and date\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG34L,R15),MSG34-DRU$CON1(R1)\n         LA    R15,MSG34L(R15)            Bump past the message\n         L     R1,PV_STOD\n         BAS   R14,CONVERT_BINARY_TIME    \" hh:mm:ss\"\n         LA    R15,9(R15)                 Bump past \" hh:mm:ss\"\n         MVC   1(8,R15),=C'ended at'\n         LA    R15,1+8(R15)\n         L     R1,PV_ETOD\n         BAS   R14,CONVERT_BINARY_TIME    \" hh:mm:ss\"\n*-Need elapsed time here\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Initialize for VTOCRPT processing                                **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Set up title for VTOC listing\n*\n         LA    R1,C_STVL\n         ST    R1,PRR_TITLE               Set title\n*\n** Open VTOCRPT file\n*\n         LA    R3,REPORT                  Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'VTOCRPT'\n         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1)\n         OPEN  ((3),(OUTPUT)),            OPEN file                    @\n               MF=(E,PARMLIST)\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**        Create DSN list by Volume                                  **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG2,$PPC_F2DO        Dataonly?\n         BO    PV$DLSH\n*\n** Print \"DSN LIST\" \"BY VOL\" in big letters\n*\n         LA    R1,C_DSNLV                 Data Set List by Volume\n         ST    R1,PRR_STITLE              Set subtitle\n         MVI   PRR_LC,99                  Start on new page\n*\n         LA    R1,W_RH2\n         MVI   0(R1),C' '\n         MVI   1(R1),C'*'\n         MVC   2(132-1,R1),1(R1)\n         LA    R1,W_RH3\n         MVI   0(R1),C' '\n         MVC   1(133-1,R1),0(R1)\n         LA    R1,W_RH4\n         MVI   0(R1),C' '\n         MVC   1(133-1,R1),0(R1)\n*\n         L     R14,=V(DRU$CON1)\n         LA    R1,C_BLDL-DRU$CON1(R14)    Locate string\n         LA    R0,BLETRSA\n         L     R15,=V(DRU$BLET)\n         BASR  R14,R15\n*\n         BAS   R14,CLEAR_RECOUT           Clear recout to blanks\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n         L     R14,=V(DRU$CON1)\n         LA    R1,C_BLBV-DRU$CON1(R14)    Locate string\n         LA    R0,BLETRSA\n         L     R15,=V(DRU$BLET)\n         BASR  R14,R15\n*\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         MVI   RECOUT,C'*'                GET DASH\n         MVC   RECOUT+1(132-1),RECOUT ..PROPAGATE IT\n         MVI   RECOUT,C' '                FBA BYTE\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n         L     R8,=V(DRU$RVOL)            Locate CSECT\n         BASSM R9,R8                      Reset heading lines\nPV$DLSH  DS    0H\n*\n** Sort the VTOC records by DSN\n*\n         LA    R1,PARMLIST+16             Locate sort string\n         MVI   0(R1),7+11                 Set length (-1)\n         MVC   1(8,R1),=C'1,6,CH,A'       Get sort string\n         MVC   1+8(11,R1),=C',11,44,CH,A'\n         MVC   SF_SORTIN(8),DDN_WF2       Sort Input file\n         MVC   SF_SORTOUT(8),DDN_WF3      Sort Output file\n*\n         BAS   R14,SORT_FILE              Sort by volume\n         LTR   R15,R15                    Successful?\n         BNZ   PV$DLVX                    No, skip report\n*\n** OPEN sorted VTOC file\n*\n         LA    R3,WRKFILE3                LOCATE DCB WORK AREA\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF3  GET DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n         LA    R1,PV$DLVLX                Locate for End-of-File\n         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\n         XC    LASTVOLP(6),LASTVOLP\n*\n** Process record from sorted file\n*\nPV$DLVL  EQU   *\n         GET   WRKFILE3                   Get record\n         LR    R4,R1                      Save record location\n*\n         CLI   LASTVOLP,0                 First time thru?\n         BE    PV$DLVLV                   Yes, do volume start\n         CLC   PVR_VOLS-PVR(6,R4),LASTVOLP  Match?\n         BE    PV$DLVLVX                  Yes, move on\n         BAS   R14,PV$DLVT\n         MVI   PRR_LC,99                  Start on new page\nPV$DLVLV EQU   *\n         XC    PV_DECB(4),PV_DECB         Clear Dataset Count\n         MVC   LASTVOLP(6),PVR_VOLS-PVR(R4) Save new volume group\nPV$DLVLVX EQU  *\n         L     R1,PV_DECB\n         LA    R1,1(R1)\n         ST    R1,PV_DECB\n*\n         BAS   R9,VTOC_DETAIL_RECORD      Format Detail record\n         BAS   R14,PRINT_REPORT_RECORD    Print report\n**\n         L     R1,PV_TCOUNT               Get current count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PV_TCOUNT               Save new count\n**\n         LA    R1,PVR_DSCB-PVR(R4)\n         CLI   DS1SMSFG-IECSDSL1(R1),0    SMS flags set?\n         BE    PV$DLSMSX                  No, continue\n         L     R1,PV_SCOUNT\n         LA    R1,1(R1)\n         ST    R1,PV_SCOUNT\n         TM    PPC_FLAG1,$PPC_F1SMSMC     Doing SMS check?\n         BNO   PV$DLSMSX                  No, continue\n         TM    PPC_FLAG1,$PPC_F1VERB      Verbose mode?\n         BNO   PV$DLSMSX\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG35L,R15),MSG35-DRU$CON1(R1)\n         UNPK  MSG35F-MSG35(3,R15),DS1SMSFG-IECSDSL1(2,R8)\n         MVZ   MSG35F-MSG35(2,R15),=8X'00'\n         TR    MSG35F-MSG35(2,R15),=C'0123456789ABCDEF'\n         MVI   MSG35F+2-MSG35(R15),C' '\n         MVC   MSG35V-MSG35(6,R15),PVR_VOLS-PVR(R4)\n         LA    R15,MSG35L(R15)            Bump past the message\n         MVC   0(44,R15),PVR_DSCB-PVR(R4)\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nPV$DLSMSX DS   0H\n**\n         B     PV$DLVL                    Read next record\n*\n** Close Sorted VTOC file\n*\nPV$DLVLX EQU   *\n         BAS   R14,PV$DLVT\n         LA    R3,WRKFILE3\n         BAS   R9,CLOSE_FILE              Close file\n         B     PV$DLVX\n*\n** Print trailer message\n*\nPV$DLVT  EQU   *\n         ST    R14,PV_DECB+4              Save return address\n         TM    PPC_FLAG2,$PPC_F2DO        Dataonly?\n         BO    PV$DLVTX\n         MVI   RECOUT+1,C'-'\n         MVC   RECOUT+2(132-1),RECOUT+1\n         MVI   RECOUT,C' '\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         BAS   R14,CLEAR_RECOUT\n         L     R1,=V(DRU$CON1)\n         MVC   1(L'C_NUMV,R15),C_NUMV-DRU$CON1(R1)\n         LA    R15,1+31+1(R15)\n         L     R1,PV_DECB\n         BAS   R9,EDITFWF\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\nPV$DLVTX DS    0H\n         L     R14,PV_DECB+4              Get return address\n         BSM   0,R14                      Return to caller\n*\n** Common exit from DSN-list-by-Volume processing\n*\nPV$DLVX  EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**        Create DSN list by Dataset                                 **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG1,$PPC_F1RDSN      Do report by Dsname as well\n         BNO   PV$RDSNX                   No, leave\n*\n** Obtain table for node report\n*\n         L    R14,=V(DRU$OPTS)            Locate options table\n         LH   R0,OP_NODES-OP(R14)         Get number of nodes\n         MH   R0,=H'9'                    Length of entries\n         GETMAIN R,LV=(0)                 Obtain Storage\n         STM   R0,R1,PV_CVPL              Save length and address\n         MVI   0(R1),X'FF'                End of table\n         AR    R1,R0                      Locate to end of table\n         SH    R1,=H'10'                  Back up for last entry\n         ST    R1,PV_CVPL+8               Save end of table\n*\n** Print \"DSN LIST\" \"BY DSN\" in big letters\n*\n         MVI   PRR_LC,99                  Start on new page\n         LA    R1,C_DSNLD                 Data Set List by Volume\n         ST    R1,PRR_STITLE              Set subtitle\n         XC    PRR_PC(4),PRR_PC           Reset Page count\n*\n         LA    R1,W_RH2\n         MVI   0(R1),C' '\n         MVI   1(R1),C'*'\n         MVC   2(132-1,R1),1(R1)\n         LA    R1,W_RH3\n         MVI   0(R1),C' '\n         MVC   1(133-1,R1),0(R1)\n         LA    R1,W_RH4\n         MVI   0(R1),C' '\n         MVC   1(133-1,R1),0(R1)\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n         L     R14,=V(DRU$CON1)\n         LA    R1,C_BLDL-DRU$CON1(R14)    Locate string\n         LA    R0,BLETRSA\n         L     R15,=V(DRU$BLET)\n         BASR  R14,R15\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n         L     R14,=V(DRU$CON1)\n         LA    R1,C_BLBD-DRU$CON1(R14)    Locate string\n         LA    R0,BLETRSA\n         L     R15,=V(DRU$BLET)\n         BASR  R14,R15\n*\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         MVI   RECOUT,C'*'                GET DASH\n         MVC   RECOUT+1(132),RECOUT ..PROPAGATE IT\n         MVI   RECOUT,C' '                FBA BYTE\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n         L     R8,=V(DRU$RVOL)            Locate CSECT\n         BASSM R9,R8                      Reset heading lines\n*\n** Sort the VTOC records by DSN\n*\n         LA    R1,PARMLIST+16             Locate sort string\n         MVC   0(11,R1),=C',11,44,CH,A'\n         MVI   0(R1),9                    Set length (-1)\n         MVC   SF_SORTIN(8),DDN_WF2       Sort Input file\n         MVC   SF_SORTOUT(8),DDN_WF3      Sort Output file\n*\n         BAS   R14,SORT_FILE              Sort by DSN\n         LTR   R15,R15                    Successful?\n         BNZ   PV$DLDX                    No, skip report\n*\n** OPEN sorted VTOC file\n*\n         LA    R3,WRKFILE3                LOCATE DCB WORK AREA\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF3  GET DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n         LA    R1,PV$DLDLX                Locate for End-of-File\n         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\n*\n** Process record from sorted file\n*\nPV$DLDL  EQU   *\n         GET   WRKFILE3                   Get record\n         LR    R4,R1                      Save record location\n         BAS   R9,VTOC_DETAIL_RECORD      Format Detail record\n         BAS   R14,PRINT_REPORT_RECORD    Print report\n*\n         BAS   R9,PV$NODE\n         B     PV$DLDL                    Read next record\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Process for nodes                                                 **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPV$NODE  EQU   *\n         LA    R15,PVR_DSCB-PVR(R4)       Locate Dataset name\n*\n** The Easy way out\n*\n         CLI   PV_CVPL+8,X'FF'            Maxed out on table?\n         BE    PV$NX                      Yes, skip node check\n         CLC   PV_CVPL+12(8),0(R15)       Same as last one?\n         BE    PV$NX                      Yes, skip it\n         MVC   PV_CVPL+12(8),0(R15)       Save for next DSN check\n*\n** Get length of this node\n*\n         SLR   R14,R14                    Clear count\nPV$NL    EQU   *\n         CLI   0(R15),C'.'                End of first node?\n         BE    PV$NLX                     Yes, continue\n         CLI   0(R15),C' '                End of single node DSN\n         BE    PV$NLX                     Yes, continue\n         LA    R14,1(R14)                 Increment node length\n         LA    R15,1(R15)                 Bump to next byte\n         CH    R14,=H'8'                  Max?\n         BNH   PV$NL                      No, move on\nPV$NLX   EQU   *\n         BCTR  R14,0                      Decrement for EX\n         L     R1,PV_CVPL+4               Locate node table\n*\n** Find match in table\n*\nPV$NML   EQU   *\n         CLI   0(R1),X'FF'                End of node table?\n         BE    PV$NEND                    Yes, append this one there\n         CLM   R14,B'0001',0(R1)          Compare lengths\n         BNE   PV$NMLB                    No match, bump to next one\n         EX    R14,PV$NMLC                Match?\n         BE    PV$NX                      Yes, already in table\nPV$NMLB  EQU   *\n         SLR   R15,R15                    Clear register\n         IC    R15,0(R1)                  Get length of this entry\n         LA    R1,1+1(R15,R1)             Bump to next entry\n         C     R1,PV_CVPL+8               End of table?\n         BE    PV$MAX                     Yes, we are maxed, dude\n         B     PV$NML                     Process next entry\nPV$NMLC  CLC   1(0,R1),PVR_DSCB-PVR(R4)   ** Executed **\n*\n** Maxed out, table too small\n*\nPV$MAX   EQU   *\n         MVI   PV_CVPL+8,X'FF'            Set flag\n         B     PV$NX                      We are outa here\n*\n** End of table, append current node to it\n*\nPV$NEND  EQU   *\n         STC   R14,0(R1)                  Save node length\n         EX    R14,PV$NENDM               Save node value\n         LA    R1,1+1(R14,R1)             Bump to next entry\n         MVI   0(R1),X'FF'                Set end of table\n*\n** Common exit from PV$NODE processing\n*\nPV$NX    EQU   *\n         BSM   0,R9\nPV$NENDM MVC   1(0,R1),PVR_DSCB-PVR(R4)   ** Executed **\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Close Sorted VTOC file                                            **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPV$DLDLX EQU   *\n         LA    R3,WRKFILE3\n         BAS   R9,CLOSE_FILE              Close file\nPV$DLDX  EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print the nodes found                                       **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPV$NODE_PRINT EQU *\n         LA    R1,C_NODE\n         ST    R1,PRR_TITLE               Set title\n         XC    PRR_STITLE(4),PRR_STITLE   Clear sub-title address\n         MVI   PRR_LC,99                  Start on new page\n         BAS   R14,CLEAR_RH               Clear report headings\n*\n** Print the node table\n*\n         MVI   PV_CVPL+20,0               Footer check\n         L     R5,PV_CVPL+4               Locate to generic entries\n         LA    R3,RECOUT+129              Locate output\n         LA    R2,10                      Length\nPV$NPL   EQU   *\n         BAS   R14,CLEAR_RECOUT           Clear output record\n         LA    R4,6(R15)                  Locate output\nPV$NPLLL EQU   *\n         SLR   R1,R1                      Clear output register\n         IC    R1,0(R5)                   Get this codes value length\n*\n         LR    R15,R4                     Save output\n         BXLE  R4,R2,PV$NPLB\n         BAS   R14,PRINT_REPORT_RECORD    Print current record\n         B     PV$NPL\n*\nPV$NPLB1 MVC   1(0,R15),1(R5)             ** Executed **\nPV$NPLB2 MVC   DOUBLE2+1(0),1(R5)         Get Job Name\nPV$NPLB  EQU   *\n         EX    R1,PV$NPLB1                Move code to output line\n         EX    R1,PV$NPLB2                Move code to output line\n         LA    R5,1+1(R1,R5)              Locate to next entry\n         LA    R1,1(R1)                   Increment for true length\n         STC   R1,DOUBLE2                 Save length of group\n         ST    R15,DOUBLE                 Save address of output area\n*\n         TM    FLAG_X1,$FX1_APF           APF authorized?\n         BNO   PV$NPLLRX                  No, avoid S684 ABEND\n B     PV$NPLLRX\n AGO .RACF1X\n         LA    R1,32                      Get length of WKAREA\n         ST    R1,PARMLIST                Save it\n         MVC   PARMLIST+32(C_RLOCL),C_RLOC Initialize Parameter List\n         ICHEINTY LOCATE,TYPE='GRP',      Locate Userid                @\n               ENTRY=DOUBLE2,             ..UserID Location            @\n               WKAREA=PARMLIST,           ..Return area (not used)     @\n               MF=(E,PARMLIST+32)         ..Execute from here\n.RACF1X ANOP ,\n         LTR   R15,R15                    Check return code\n         BZ    PV$NPLLRX                  Okay, leave\n         L     R15,DOUBLE                 Locate output location\n         MVI   0(R15),C'*'                Indicate no RACF group\n         MVI   PV_CVPL+20,X'FF'           Indicate that we need footer\nPV$NPLLRX EQU  *\n*\n         CLI   0(R5),X'FF'                End of input record?\n         BNE   PV$NPLLL                   No, process next line\n         BAS   R14,PRINT_REPORT_RECORD    Print current record\n*\n** Check for footer\n*\n AGO .RACFFX\n         CLI   PV_CVPL+20,X'FF'           Indicate that we need footer\n         BNE   PV$NPFX\n         BAS   R14,CLEAR_RECOUT\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         MVC   RECOUT+1(C_NODERFL),C_NODERF\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n.RACFFX ANOP ,\nPV$NPFX  EQU   *\n*\n** End of table\n*\n         LM    R0,R1,PV_CVPL              Get length and address\n      FREEMAIN R,LV=(0),A=(1)             Free Storage\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Close VTOCRPT file                                               **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPV$RDSNX DS    0H\n         LA    R3,REPORT\n         BAS   R9,CLOSE_FILE              Close file\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Common exit from Process_Volume processing                       **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPV$X     EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Print summary page for DASD CONFIGURATION section           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         L     R14,=V(DRU$CON1)           Locate constants CSECT\n         LA    R1,C_STDC-DRU$CON1(R14)\n         ST    R1,PRR_TITLE               Set title\n         LA    R1,C_SUM-DRU$CON1(R14)\n         ST    R1,PRR_STITLE              Set subtitle\n         BAS   R14,CLEAR_RH               Clear Report headings\n         MVI   PRR_LC,99                  Start on new page\n         XC    PRR_PC(4),PRR_PC           Reset Page count\n*\n** Open REPORT file\n*\n         LA    R3,REPORT                  Locate DCB work area\n         L     R1,=V(DRU$CON1)            Locate constants CSECT\n         MVC   0(C_DCBOL,R3),C_DCBO-DRU$CON1(R1) Initialize DCB\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'REPORT' Get DDNAME\n         MVC   PARMLIST(C_LSTOL),C_LSTO-DRU$CON1(R1) Initialize parm\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST) Open file\n*\n         TM    PPC_FLAG3,$PPC_F3NSYSP\n         BO    DC$SYSPX\n         LA    R0,SUBRSA\n         L     R15,=V(DRU$SYSP)\n         BASR  R14,R15\nDC$SYSPX DS    0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n**   Create DASD Usage page, showing volume \"groups\" and cylinders   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LA    R1,C_DU\n         ST    R1,PRR_STITLE              Set subtitle\n*\n         MVI   PRR_LC,99                  Start on new page\n         BAS   R14,CLEAR_RH               Clear Report headings\n*\n** Sub heading line 3\n*\n         LA    R15,W_RH3                  Locate work heading 2\n         MVI   0(R15),C'-'                FBA byte: skip some lines\n         L     R1,=V(DRU$CON1)\n         MVC   DU_GROUP-DU(5,R15),C_DU_GROUP-DRU$CON1(R1)\n         MVC   DU_NUM-DU(6,R15),C_DU_NUM-DRU$CON1(R1)\n         MVC   DU_TTRK-DU+3(12,R15),C_DU_TTRK-DRU$CON1(R1)\n         MVC   DU_ATRK-DU+4(16,R15),C_DU_ATRK-DRU$CON1(R1)\n         MVC   DU_FTRK-DU+9(12,R15),C_DU_FTRK-DRU$CON1(R1) '\n*\n*\n** Sub heading line 4\n*\n         LA    R15,W_RH4                  Locate work heading 2\n         MVI   DU_GROUP-DU(R15),C'-'\n         MVC   DU_GROUP+1-DU(DU_GROUPL-1,R15),DU_GROUP-DU(R15)\n         MVI   DU_NUM-DU(R15),C'-'\n         MVC   DU_NUM+1-DU(5,R15),DU_NUM-DU(R15)\n         MVI   DU_TTRK-DU(R15),C'-'\n         MVC   DU_TTRK+1-DU(14,R15),DU_TTRK-DU(R15)\n         MVI   DU_ATRK-DU(R15),C'-'\n         MVC   DU_ATRK+1-DU(DU_ATRKL-1,R15),DU_ATRK-DU(R15)\n         MVI   DU_FTRK-DU(R15),C'-'\n         MVC   DU_FTRK+1-DU(DU_FTRKL-1,R15),DU_FTRK-DU(R15)\n*\n** Open Merged file (input)\n*\n         LA    R3,WRKFILE1                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1  Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n         LA    R1,DU$EOF                  Locate EODAD\n         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Save into DCB\n         OPEN  ((3),(INPUT)),             Open file                    @\n               MF=(E,PARMLIST)\n*\n** Initlialize\n*\n         SLR   R6,R6                      Clear register\n         L     R14,=V(DRU$OPTS)           Locate options CSECT\n         IC    R6,OP_VOLP-OP(R14)         Get Volume prefix length\n         BCTR  R6,0                       Decrement by one\n         XC    DU_WGVOLC(4),DU_WGVOLC\n         XC    DU_WGFTRK(4),DU_WGFTRK\n         XC    DU_WGTTRK(4),DU_WGTTRK\n         XC    DU_TF1(4),DU_TF1\n         XC    DU_TUC(4),DU_TUC\n         XC    LASTVOLP(5),LASTVOLP\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Read records\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\nDU$LOOP  DS    0H\n         GET   WRKFILE1                   Get input record\n         LR    R3,R1                      Save input location\n*\n** Compares for Volume prefix\n*\n         EX    R6,DU$LVPC                 Volumes prefix match?\n         BE    DU$UPDT                    Yes, update current stuff\n         CLC   LASTVOLP(5),=8X'00'        First time?\n         BE    DU$INIT                    Yes, don't kick record out\n*\n** Print a detail record for the current group\n*\n         BAS   R9,DU$PRT                  Print detail record\n*\n** Initialize for next group\n*\nDU$INIT  DS    0H\n         XC    DU_WGVOLC(4),DU_WGVOLC\n         XC    DU_WGFTRK(4),DU_WGFTRK\n         XC    DU_WGTTRK(4),DU_WGTTRK\n         EX    R6,DU$INITM                Move in Volume prefix\n*\n** Update count for this group\n*\nDU$UPDT  DS    0H\n         L     R1,DU_WGVOLC               Get group volume count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,DU_WGVOLC               Save Group volume count\n*\n         LA    R15,WD_LSPCD-WD(R3)        Locate numeric field\n         ICM   R1,B'1111',LSPDTCYL-LSPDRETN(R15)  Cylinders free\n         LA    R14,WD_F4DSCB-WD(R3)       Locate F4DSCB\n         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert cylinders to Tracks\n         A     R1,LSPDTTRK-LSPDRETN(R15)  Add tracks\n         L     R0,DU_WGFTRK               Get Total group\n         AR    R0,R1                      Add this entry\n         ST    R0,DU_WGFTRK               Save Group total\nDU$FTRKX DS    0H\n*\n** Process VTOC information\n*\n         ICM   R14,B'1111',WD_VIT-WD(R3)\n         BZ    DU$VITX\n         ICM   R1,B'1111',VI_UNCAT-VI(R14)\n         BZ    DU$VUCX\n         L     R0,DU_TUC                  Get uncatalogued count\n         AR    R0,R1                      Add for this volume\n         ST    R0,DU_TUC                  Save running total\nDU$VUCX  EQU   *\n         ICM   R1,B'1111',VI_F1-VI(R14)   Get number of datasets (F1)\n         BZ    DU$VITX\n         L     R0,DU_TF1                  Get uncatalogued count\n         AR    R0,R1                      Add for this volume\n         ST    R0,DU_TF1                  Save running total\nDU$VITX  EQU   *\n.VITX ANOP ,\n*\n** Add Tracks\n*\nDU$TRKF  DS    0H\n         L     R15,DU_WGTTRK              Get Total group\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0011',WD_DTAREA+8-WD(R3) Get number of cylinders\n         BCTR  R1,0                       Remove Alternate Cylinder\n         LA    R14,WD_F4DSCB-WD(R3)       Locate F4DSCB\n         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert Cyls to Tracks\n         AR    R15,R1                     Add cylinders for this device\n         ST    R15,DU_WGTTRK              Save Group total\n         B     DU$LOOP\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** End of file on merged input\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\nDU$EOF   DS    0H\n*\n** Close work file\n*\n         LA    R3,WRKFILE1\n         BAS   R9,CLOSE_FILE              Close file\n*\n** Print last detail record\n*\n         BAS   R9,DU$PRT                  Print detail record\n*\n** Print \"under-line\" line\n*\n         BAS   R14,CLEAR_RECOUT           Clear output record to blanks\n         LA    R15,RECOUT\n         MVI   DU_NUM-DU(R15),C'-'\n         MVC   DU_NUM+1-DU(5,R15),DU_NUM-DU(R15)\n         MVI   DU_TTRK-DU(R15),C'-'\n         MVC   DU_TTRK+1-DU(14,R15),DU_TTRK-DU(R15)\n         MVI   DU_ATRK-DU(R15),C'-'\n         MVC   DU_ATRK+1-DU(DU_ATRKL-1,R15),DU_ATRK-DU(R15)\n         MVI   DU_FTRK-DU(R15),C'-'\n         MVC   DU_FTRK+1-DU(DU_FTRKL-1,R15),DU_FTRK-DU(R15)\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n** Print Grand total line\n*\n         BAS   R14,CLEAR_RECOUT           Clear output record to blanks\n         LA    R8,RECOUT                  Locate output record\n*\n         L     R1,DU_WTVOLC\n         CVD   R1,DOUBLE\n         MVC   DU_NUM-DU(6,R8),=X'40,20,20,20,20,20'\n         ED    DU_NUM-DU(6,R8),DOUBLE+5\n*\n         L     R1,DU_WTTTRK               Get Total\n         LA    R15,DU_TTRK-DU(R8)         Locate output location\n         BAS   R14,EDIT15                 Edit number\n*\n         L     R14,DU_WTTTRK              Get Total number\n         L     R1,DU_WTFTRK               Get Free number\n         LA    R15,DU_FTRKP-DU(R8)        Locate output location\n         BAS   R9,EDITPER                 Edit percentage\n         MVI   DU_FTRKP-DU+4(R8),C'%'     Insert Percentage sign\n*\n         L     R1,DU_WTATRK               Get Allocated tracks\n         LA    R15,DU_FTRK-DU(R8)         Locate output location\n         BAS   R14,EDIT15                 Edit number\n*\n         L     R1,DU_WTFTRK               Get Free Tracks\n         LA    R15,DU_FTRK-DU(R8)         Locate output location\n         BAS   R14,EDIT15                 Edit number\n*\n         L     R1,DU_WTTTRK               Get Group Total tracks\n         L     R0,DU_WTFTRK               Get Free\n         SR    R1,R0                      Calculate Allocated trk.\n         LR    R7,R1                      Save number\n         LA    R15,DU_ATRK-DU(R8)         Locate output location\n         BAS   R14,EDIT15                 Edit number\n*\n         L     R14,DU_WTTTRK              Get Total number\n         LR    R1,R7                      Get Free number\n         LA    R15,DU_ATRKP-DU(R8)        Locate output location\n         BAS   R9,EDITPER                 Edit percentage\n         MVI   DU_ATRKP-DU+4(R8),C'%'     Insert Percentage sign\n*\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         B     DU$X\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Executed instructions\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\nDU$LVPC  CLC   LASTVOLP(0),WD_VOLS-WD(R3) ** Executed **\nDU$INITM MVC   LASTVOLP(0),WD_VOLS-WD(R3) ** Executed **\nDU$PRTM  MVC   DU_GROUP-DU(0,R8),LASTVOLP  ** Executed **\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Print detail record for DASD usage\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\nDU$PRT   DS    0H\n         ST    R9,RA$DUPRT                Save return address\n*\n         BAS   R14,CLEAR_RECOUT           Clear output record to blanks\n         LA    R8,RECOUT                  Locate output record\n*\n         EX    R6,DU$PRTM\n         L     R14,G_DASD                 Get Total number of DASD\n         L     R1,DU_WGVOLC               Get Group volume count\n         LA    R15,DU_GROUPP-DU(R8)\n         BAS   R9,EDITPER                 Edit percentage\n         MVI   DU_GROUPPP-DU(R8),C'%'\n*\n         L     R1,DU_WGVOLC               Get Group volume count\n         L     R0,DU_WTVOLC               Get Total volume count\n         AR    R0,R1                      Add Group + Total\n         ST    R0,DU_WTVOLC               Save Total\n         CVD   R1,DOUBLE                  Make packed\n         MVC   DU_NUM-DU(6,R8),=X'40,20,20,20,20,20' Move in edit zones\n         ED    DU_NUM-DU(6,R8),DOUBLE+5   Edit it\n*\n         L     R1,DU_WGFTRK               Get group Free tracks\n         L     R0,DU_WTFTRK               Get Total Free tracks\n         AR    R0,R1                      Add Group + Total\n         ST    R0,DU_WTFTRK               Save Total\n         LA    R15,DU_FTRK-DU(R8)         Locate output location\n         BAS   R14,EDIT15                 Edit number\n*\n         L     R14,DU_WGTTRK              Get Total number\n         L     R1,DU_WGFTRK               Get Free number\n         LA    R15,DU_FTRKP-DU(R8)        Locate output location\n         BAS   R9,EDITPER                 Edit percentage\n         MVI   DU_FTRKP-DU+4(R8),C'%'     Insert Percentage sign\n*\n         L     R1,DU_WGTTRK               Get Group Total Tracks\n         L     R0,DU_WTTTRK               Get Total Total tracks\n         AR    R0,R1                      Add Group + Total\n         ST    R0,DU_WTTTRK               Save Total\n         LA    R15,DU_TTRK-DU(R8)         Locate output location\n         BAS   R14,EDIT15                 Edit number\n*\n         L     R1,DU_WGTTRK               Get Group Total tracks\n         L     R0,DU_WGFTRK               Get Free tracks\n         SR    R1,R0                      Calculate Allocated trk.\n         LR    R7,R1                      Save number\n         LA    R15,DU_ATRK-DU(R8)         Locate output location\n         BAS   R14,EDIT15                 Edit number\n*\n         L     R14,DU_WGTTRK              Get Total number\n         LR    R1,R7                      Get Free number\n         LA    R15,DU_ATRKP-DU(R8)        Locate output location\n         BAS   R9,EDITPER                 Edit percentage\n         MVI   DU_ATRKP-DU+4(R8),C'%'     Insert Percentage sign\n*\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n         L     R9,RA$DUPRT                Get return address\n         BSM   0,R9                       Return to caller\n         AGO   .SKIPSN\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Print special notes\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\n*\n** Print uncatalogued dataset count\n*\n         ICM   R1,B'1111',DU_TUC\n         BZ    DU$PUCX\n         BAS   R14,CLEAR_RECOUT\n         MVI   RECOUT,C'-'\n         MVC   14(5,R15),=C'Note:'\n         MVC   20(9,R15),=C'There are'\n         LA    R15,20+9+1(R15)\n         L     R1,DU_TUC\n         BAS   R9,EDITFWF\n         MVC   1(21,R15),=C'uncatalogued datasets'\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\nDU$PUCX  EQU   *\n*\n** Print total dataset\n*\n         ICM   R1,B'1111',DU_TF1\n         BZ    DU$PF1X\n         BAS   R14,CLEAR_RECOUT\n         MVC   14(5,R15),=C'Note:'\n         MVC   20(9,R15),=C'There are'\n         LA    R15,20+9+1(R15)\n         L     R1,DU_TF1\n         BAS   R9,EDITFWF\n         MVC   1(14,R15),=C'total datasets'\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\nDU$PF1X  EQU   *\n.SKIPSN  ANOP  ,\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Exit from DASD usage\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nDU$X     DS    0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n**   Print Dasd type summary total                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LA    R1,C_DT\n         ST    R1,PRR_STITLE              Set subtitle\n*\n         MVI   PRR_LC,99                  Start on new page\n         BAS   R14,CLEAR_RH               Clear Report headings\n*\n** Sub heading line 3\n*\n         LA    R15,W_RH3                  Locate work heading 2\n         MVI   0(R15),C'-'                FBA byte: skip some lines\n         MVC   DT_NAME-DT(4,R15),=C'Type'\n         MVC   DT_COUNT-DT(5,R15),=C'Count'\n*\n** Sub heading line 4\n*\n         LA    R15,W_RH4                  Locate work heading 2\n         MVI   DT_NAME-DT(R15),C'-'\n         MVC   DT_NAME+1-DT(L'DT_NAME-1,R15),DT_NAME-DT(R15)\n         MVI   DT_COUNT-DT(R15),C'-'\n         MVC   DT_COUNT+1-DT(L'DT_COUNT-1,R15),DT_COUNT-DT(R15)\n*\n** Loop thru table\n*\n         L     R8,SDU_DDC+4               Obtain address\n         LA    R8,DDC_HL(R8)              Bump past header\n         LA    R7,#DDCEN                  Get max number of entries\nDTR$L    EQU   *\n         CLI   0(R8),X'FF'                End?\n         BE    DTR$END\n         BAS   R14,CLEAR_RECOUT\n         MVC   DT_NAME-DT(8,R15),DDC_ENAME-DDC_E(R8)\n         L     R1,DDC_ECOUNT-DDC_E(R8)    Get count\n         LA    R15,DT_COUNT-DT(R15)       Locate to output area\n         BAS   R9,EDITFWF                 Edit total device count\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         LA    R8,DDC_EL(R8)              Bump to next entry\n         BCT   R7,DTR$L                   Continue\nDTR$END  EQU   *\n         LM    R0,R1,SDU_DDC              Get length and address\n         FREEMAIN R,LV=(0),A=(1)          Free table\nDTR$X    EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       PRINT \"DASD Configuration Report\" BY VOLSER                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         TM    PPC_FLAG1,$PPC_F1RBOTH     Do both reports?\n         BO    DCR$VS                     Yes, continue\n         TM    PPC_FLAG1,$PPC_F1RUCB      Do report by UCB?\n         BO    DCR$US                     Yes, skip volume\nDCR$VS   DS    0H\n*\n** Reset headings for DASD Configuration Report by volume\n*\n         LA    R1,C_DCRV\n         L     R8,=V(DRU$ROPR)            Locate CSECT\n         BASSM R9,R8                      Reset heading lines\n*\n** OPEN MERGED FILE (INPUT)\n*\n         LA    R3,WRKFILE1                LOCATE DCB WORK AREA\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF1  GET DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n         LA    R2,DCR$FX1_VEOF            LOCATE VOLUME EODAD\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB\n         OPEN  ((3),(INPUT)),                                          @\n               MF=(E,PARMLIST)            OPEN DCB\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** READ THE MERGED FILE AND CREATE DCR BY VOLSER\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         OI    FLAG_R,$DCRV               SET: DASD CONFIG BY VOLUME\nDCR$VL   DS    0H\n         GET   WRKFILE1                   GET INPUT RECORD\n         LR    R2,R1                      SAVE INPUT LOCATION\n         BAS   R9,RPTDT                   FORMAT REPORT DETAIL LINE\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         B     DCR$VL                     NEXT RECORD\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** END OF FILE FOR WORK FILE 1\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nDCR$FX1_VEOF DS 0H\n         NI    FLAG_R,255-$DCRV           TURN OFF DASD CONFIG - VOLUME\n*\n** Print Dash line after report\n*\n         MVI   RECOUT,C'-'\n         MVC   RECOUT+1(132),RECOUT\n         MVI   RECOUT,C' '\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n*\n** Close the work file\n*\n         LA    R3,WRKFILE1\n         BAS   R9,CLOSE_FILE\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       PRINT \"DASD Configuration Report\" BY UCB                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         TM    PPC_FLAG1,$PPC_F1RUCB      Do report by UCB?\n         BNO   DCR$UX                     No, continue\nDCR$US   DS    0H\n*\n** Sort the work file by \"AC\" (ASCII) to get hexidecmial UCB order\n*\n         LA    R1,PARMLIST+16             Locate sort string\n         MVI   0(R1),7                    Set length (-1)\n         MVC   1(8,R1),=C'7,4,AC,A'\n         MVC   SF_SORTIN(8),DDN_WF1       Sort Input file\n         MVC   SF_SORTOUT(8),DDN_WF2      Sort Output file\n*\n         BAS   R14,SORT_FILE              SORT WRKFILE1 BY UCB\n         LTR   R15,R15\n         BNZ   DCR$UX\n*\n** Reset headings for DASD Configuration Report by volume\n*\n         L     R1,=V(DRU$CON1)\n         LA    R1,C_DCRC-DRU$CON1(R1)\n         L     R8,=V(DRU$ROPR)            Locate CSECT\n         BASSM R9,R8                      Reset heading lines\n*\n** OPEN MERGED FILE (INPUT)\n*\n         LA    R3,WRKFILE2                LOCATE DCB WORK AREA\n         L     R1,=V(DRU$CON1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF2  GET DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n         LA    R2,DCR$UEOF                LOCATE VOLUME EODAD\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) SAVE INTO DCB\n         OPEN  ((3),(INPUT)),                                          @\n               MF=(E,PARMLIST)            OPEN DCB\n         SPACE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** READ THE MERGED FILE AND CREATE DCR BY UCB\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         SPACE 2\n         OI    FLAG_R,$DCRU               SET: DASD CONFIG BY VOLUME\nDCR$UL   DS    0H\n         GET   WRKFILE2                   GET INPUT RECORD\n         LR    R2,R1                      SAVE INPUT LOCATION\n         BAS   R9,RPTDT                   FORMAT REPORT DETAIL LINE\n*\n         CLC   LASTCHAN(1),WD_UCB+1-WD(R2)  SAME \"CHANNEL\"?\n         BE    DCR$UP                     YES, MOVE ON\n         CLI   LASTCHAN,X'00'             FIRST TIME THRU LOOP?\n         BE    DCR$UCU                    YES, NO NEED FOR DOUBLE SPACE\n         MVI   RECOUT,C'0'                DOUBLE SPACE BEFORE CHANNEL\nDCR$UCU  DS    0H\n         MVC   LASTCHAN(1),WD_UCB+1-WD(R2)  Reset CHANNEL control break\nDCR$UP   DS    0H\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\n         B     DCR$UL                     NEXT RECORD\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** END OF FILE FOR WORK FILE 2\n**- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nDCR$UEOF DS    0H\n         NI    FLAG_R,255-$DCRU           TURN OFF DASD CONFIG - UCB\n*\n** Close the work file\n*\n         LA    R3,WRKFILE2\n         BAS   R9,CLOSE_FILE              Close file\n*\n** Print Dash line after report\n*\n         MVI   RECOUT,C'-'\n         MVC   RECOUT+1(132),RECOUT\n         MVI   RECOUT,C' '\n         BAS   R14,PRINT_REPORT_RECORD    Print record on file=REPORT\nDCR$UX   EQU   *       ***  End of need of sorted file by UCB ***\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Termination section                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     DS    0H\n*\n** Print trivia from VTOC reporting\n*\n         TM    FLAG_X1,$FX1_VTOC          Look at the vtocs?\n         BNO   X$VTOCX                    No, continue\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG61L,R15),MSG61-DRU$CON1(R1)\n         LA    R15,MSG61L+1(R15)          Bump past the message\n         L     R1,PV_TCOUNT               Get SMS count\n         BAS   R9,EDITFWF                 Edit the return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG60L,R15),MSG60-DRU$CON1(R1)\n         LA    R15,MSG60L+1(R15)          Bump past the message\n         L     R1,PV_SCOUNT               Get SMS count\n         BAS   R9,EDITFWF                 Edit the return code\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\nX$VTOCX  DS    0H\n*\n** Print ending message\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n         TIME  BIN\n         LR    R5,R0\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG1L,R15),MSG1-DRU$CON1(R1)\n         LA    R15,MSG1L+1(R15)           Bump past the message\n         MVC   0(MSG1BL,R15),MSG1B-DRU$CON1(R1)\n         LA    R15,MSG1BL+1(R15)          Bump past it\n         SLR   R1,R1                      Get the return code\n         IC    R1,MAXCC\n         BAS   R9,EDITFWF                 Edit the return code\n         MVC   0(7,R15),=C', Time:'\n         LA    R15,7(R15)\n         LR    R1,R5                      Get time\n         BAS   R14,CONVERT_BINARY_TIME\n         BAS   R14,PRINT_SYSPRINT_RECORD Print message\n*\n** Delete storage\n*\n         LM    R0,R1,PV_VIT               Save Length and Address\n         LTR   R0,R0                      Any length?\n         BZ    X$VITX                     No, move on\n      FREEMAIN R,LV=(0),A=(1)             Free storage\nX$VITX   EQU   *\n*\n** Delete modules loaded\n*\n         ICM   R1,B'1111',EP_EB4UV\n         BZ    X$EB4UVX\n         DELETE EPLOC==CL8'IEFEB4UV'\nX$EB4UVX EQU   *\n         ICM   R1,B'1111',EP_SS01\n         BZ    X$SS01X\n         DELETE EPLOC==CL8'IDCSS01'\nX$SS01X  EQU   *\n         TM    FLAG_X2,$FX2_LMXD          Loaded DA$MXD?\n         BNO   X$MXDX                     No, continue\n         ICM   R0,B'1111',EP_DA$MXD\n         BZ    X$MXDX\n         DELETE EPLOC==CL8'DA$MXD'\nX$MXDX   EQU   *\n         TM    FLAG_X2,$FX2_LDATE         Loaded DA$DATE?\n         BNO   X$DATEX                    No, continue\n         ICM   R0,B'1111',EP_DA$DATE\n         BZ    X$DATEX\n         DELETE EPLOC==CL8'DA$DATE'\nX$DATEX  EQU   *\n*\n** Close global files\n*\n         LA    R3,SYSPRINT\n         BAS   R9,CLOSE_FILE              Close file\n*\n         LA    R3,REPORT\n         BAS   R9,CLOSE_FILE              Close file\n*\n** Free resources and terminate\n*\n         LR    R2,R13                     Get storage address\n         SLR   R3,R3\n         IC    R3,MAXCC\n         STORAGE RELEASE,LENGTH=DSAL,ADDR=(R2) Release storage\n         LR    R15,R3                     Set return code\n         PR    ,                          Return to caller\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Error routines                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** DCB ABEND EXIT ROUTINE: GC26-4013 MVS/XA DATA ADMINISTRATION GUIDE\n**                         CHAPTER 7.\n*\nE$OPENA  EQU   *\n         L     R2,0(R1)                   GET ABEND CODE\n         ST    R2,E_OPENA_CODE            SAVE ABEND CODE\n         MVI   3(R1),4                    IGNORE ABEND\n         BSM   0,R14                      RETURN TO IOS\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Format report detail line                                   **\n**       Input R2: Points to work file input record                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nRPTDT    DS    0H\n         BAS   R14,CLEAR_RECOUT           CLEAR RECOUT TO BLANKS\n         LA    R3,RECOUT                  LOCATE RECOUT\n*\n** MASS MERGE\n*\n         MVC   OR_UCB-OR(4,R3),WD_UCB-WD(R2)      UCB NAME (ADDRESS)\n         MVC   OR_VOLS-OR(6,R3),WD_VOLS-WD(R2)    VOL SER\n         TM    WD_FLAG1-WD(R2),$WDF1_IVTOC\n         BNO   RDT$IVX\n         MVI   OR_IVTOC-OR(R3),C'I'               Indexed VTOC = I\nRDT$IVX  EQU   *\n         TM    WD_FLAG1-WD(R2),$WDF1_CACHEC       Cached Controller?\n         BNO   RDT$CVX\n         MVI   OR_CACHE-OR(R3),C'C'               Cached..\n         TM    WD_FLAG1-WD(R2),$WDF1_CACHEV       Cached Volume?\n         BNO   RDT$CVX\n         MVI   OR_CACHE+1-OR(R3),C'C'             Only know bout cntrlr\nRDT$CVX  EQU   *\n         MVC   OR_VMNT-OR(3,R3),WD_VMNT-WD(R2)    Mount status\n         MVC   OR_SMNT-OR(3,R3),WD_SMNT-WD(R2)    Mount status\n         MVC   OR_DESC-OR(40,R3),WD_DESC-WD(R2)   Description of use\n         MVC   OR_DEVT-OR(8,R3),WD_DEVT-WD(R2)    Device type\n*\n** VTOC stuff\n*\n         TM    WD_FLAG1-WD(R2),$WDF1_NLSPC       Have LSPACE info\n         BO    RDT$VTOCX\n         SLR   R1,R1\n         ICM   R1,B'0011',WD_VTOCT-WD(R2)        Get VTOC size\n         CVD   R1,DOUBLE                         Convert it to packed\n         MVC   OR_VTOCT-OR(4,R3),=X'40,20,20,20' Get edit pattern\n         ED    OR_VTOCT-OR(4,R3),DOUBLE+6        Edit the number\n         OI    OR_VTOCT+3-OR(R3),C'0'\n*\n         LA    R14,WD_LSPCD-WD(R2)               Locate LSPACE data\n         ICM   R0,B'1111',LSPDF0S-LSPDRETN(R14)  Get Free DSCBs\n         CVD   R0,DOUBLE                         Convert it to packed\n         MVC   OR_VTOCF-2-OR(6,R3),=X'40,20,20,20,20,20'\n         ED    OR_VTOCF-2-OR(6,R3),DOUBLE+5\n         OI    OR_VTOCF+3-OR(R3),C'0'\n*\n         LA    R14,WD_F4DSCB-WD(R2)              Locate F4DSCB\n         MVI   DOUBLE,0                   Fix first byte of half word\n         MVC   DOUBLE+1(1),DS4DEVDT-DS4IDFMT(R14) Get # of DSCBs: Trk\n         MH    R1,DOUBLE                         Calculate # of DSCBs\n         ST    R1,DOUBLE                         Save for divide\n         SR    R1,R0                             Get used count\n         SLR   R0,R0                             Clear register\n         LTR   R1,R1                             Any value?\n         BZ    RDT$VTOCX                         No, avoid SC09\n         M     R0,=F'100'                        Make right for percent\n         D     R0,DOUBLE                         Get free percent\n         CVD   R1,DOUBLE                         Make packed\n         MVC   OR_VTOCP-1-OR(4,R3),=X'40,20,20,20'\n         ED    OR_VTOCP-1-OR(4,R3),DOUBLE+6\n         OI    OR_VTOCP+2-OR(R3),C'0'\n         MVI   OR_VTOCP+3-OR(R3),C'%'\n*                                         Edit the total tracks free\n         LA    R14,WD_F4DSCB-WD(R2)       Locate F4DSCB\n         SLR   R1,R1\n         ICM   R1,B'0011',DS4DSCYL-DS4IDFMT(R14) Get total Cylinders\n         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert cylinders to Tracks\n         ST    R1,PARMLIST                Save total tracks\n         LA    R15,WORKAREA               Locate temp. output\n         BAS   R14,EDIT15                 Edit number\n         MVC   OR_TTRKS-OR(10,R3),WORKAREA+5 Move out free space\n*                                         Edit the total tracks free\n         LA    R14,WD_LSPCD-WD(R2)        Locate LSPACE data\n         L     R0,LSPDTTRK-LSPDRETN(R14)  Tracks Free\n         L     R1,LSPDTCYL-LSPDRETN(R14)  Cylinders Free\n         LA    R14,WD_F4DSCB-WD(R2)       Locate F4DSCB\n         MH    R1,DS4DEVSZ+2-DS4IDFMT(R14) Convert cylinders to Tracks\n         AR    R1,R0                      Total Free = Cyls + Trks\n         ST    R1,PARMLIST+4              Save free tracks\n         LA    R15,WORKAREA               Locate temp. output\n         BAS   R14,EDIT15                 Edit number\n         MVC   OR_FTRKS-OR(10,R3),WORKAREA+5 Move out free space\n*\n         ST    R9,PARMLIST+8              Save return address\n         L     R14,PARMLIST               Get Total number\n         L     R1,PARMLIST+4              Get Free number\n         LA    R15,OR_FTRKP-1-OR(R3)        Locate output location\n         BAS   R9,EDITPER                 Edit percentage\n         MVI   OR_FTRKP-OR+3(R3),C'%'     Insert Percentage sign\n         L     R9,PARMLIST+8              Restore return address\n         B     RDT$VTOCX\nRDT$VTOCE EQU *\n         MVC   OR_VTOC-OR(OR_VTOCL,R3),WD_LSPCD+7-WD(R2) Get message\nRDT$VTOCX EQU *\n*\n** Return to caller\n*\n         BSM   0,R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Format VTOC detail record                                  **\n**                                                                   **\n**        Input: R4 points to PVR                                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nVTOC_DETAIL_RECORD EQU *\n         LA    R8,PVR_DSCB-PVR(R4)\n*\n         BAS   R14,CLEAR_RECOUT\n         LA    R15,RECOUT+1\n         MVC   DLR_DSN-DLR(44,R15),PVR_DSCB-PVR(R4)\n         MVC   DLR_VOLS-DLR(6,R15),PVR_VOLS-PVR(R4)\n         MVC   DLR_CAT-DLR(1,R15),PVR_CAT-PVR(R4)\n         MVC   DLR_DSORG+2-DLR(3,R15),PVR_DSORG-PVR(R4)\n*\n** Format the Creation and Last Reference dates\n*\n         LA    R15,DLR_CDATE-DLR(R15)\n         LA    R1,DS1CREDT-IECSDSL1(R8)\n         BAS   R14,CONVDATE\n         LA    R15,RECOUT+1+DLR_UDATE-DLR\n         LA    R1,DS1REFD-IECSDSL1(R8)\n         BAS   R14,CONVDATE\n         LA    R15,RECOUT+1\n*\n** RECFM\n*\n         LA    R14,DLR_RECFM+2-DLR(R15)\n         TM    DS1RECFM-IECSDSL1(R8),DS1RECFU\n         BO    VDR$RU\n         TM    DS1RECFM-IECSDSL1(R8),DS1RECFF\n         BO    VDR$RF\n         TM    DS1RECFM-IECSDSL1(R8),DS1RECFV\n         BNO   VDR$RX\n         MVI   0(R14),C'V'\n         LA    R14,1(R14)\n         B     VDR$RCB\nVDR$RU   EQU   *\n         MVI   0(R14),C'U'\n         LA    R14,1(R14)\n         B     VDR$RX\nVDR$RF   EQU   *\n         MVI   0(R14),C'F'\n         LA    R14,1(R14)\n*        B     VDR$RCB\nVDR$RCB  EQU   *\n         TM    DS1RECFM-IECSDSL1(R8),DS1RECFB\n         BNO   VDR$RCA\n         MVI   0(R14),C'B'\n         LA    R14,1(R14)\nVDR$RCA  EQU   *\n         TM    DS1RECFM-IECSDSL1(R8),DS1RECFA\n         BNO   VDR$RAX\n         MVI   0(R14),C'A'\n         LA    R14,1(R14)\n         B     VDR$RX\nVDR$RAX  EQU   *\n         TM    DS1RECFM-IECSDSL1(R8),DS1RECFS\n         BNO   VDR$RSX\n         MVI   0(R14),C'S'\n         LA    R14,1(R14)\n         B     VDR$RX\nVDR$RSX  EQU   *\n         TM    DS1RECFM-IECSDSL1(R8),DS1RECMC\n         BNO   VDR$RX\n         MVI   0(R14),C'M'\n         LA    R14,1(R14)\nVDR$RX   EQU   *\n*\n** LRECL\n*\n         LH    R1,DS1LRECL-IECSDSL1(R8)   Obtain LRECL\n         CVD   R1,DOUBLE\n         MVC   DLR_LRECL-1-DLR(6,R15),=X'40,20,20,20,20,20'\n         ED    DLR_LRECL-1-DLR(6,R15),DOUBLE+5\n         OI    DLR_LRECL+4-DLR(R15),C'0'\n*\n** Block Size\n*\n         LH    R1,DS1BLKL-IECSDSL1(R8)    Obtain BLKSIZE\n         CVD   R1,DOUBLE\n         MVC   DLR_BLKSIZE-1-DLR(6,R15),=X'40,20,20,20,20,20'\n         ED    DLR_BLKSIZE-1-DLR(6,R15),DOUBLE+5\n         OI    DLR_BLKSIZE+4-DLR(R15),C'0'\n*\n** SMS byte\n*\n         UNPK  DLR_SMS-DLR(3,R15),DS1SMSFG-IECSDSL1(2,R8)\n         MVZ   DLR_SMS-DLR(2,R15),=8X'00'\n         TR    DLR_SMS-DLR(2,R15),=C'0123456789ABCDEF'\n         MVI   DLR_SMS+3-DLR(R15),C' '\n*\n** Common Exit from VTOC_Detail_Record\n*\nVDR$X    EQU   *\n         BSM   0,R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Misc Internal Subroutines                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Increment Line count\n**\n** Input: RECOUT - FBA byte\n**        R1 - current line count (to be incremented)\n*\nINC_LC   EQU   *\n         CLI   RECOUT,C'+'\n         BE    ILCX\n         CLI   RECOUT,C'-'\n         BE    ILC3\n         CLI   RECOUT,C'0'\n         BE    ILC2\n         B     ILC1\nILC3     EQU   *\n         LA    R1,1(R1)\nILC2     EQU   *\n         LA    R1,1(R1)\nILC1     EQU   *\n         LA    R1,1(R1)\nILCX     EQU   *\n         BSM   0,R14\n*\n** Close file in R3\n*\nCLOSE_FILE EQU *\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   CF$X                       No, ignore it\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-DRU$CON1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\nCF$X     DS    0H\n         BSM   0,R9\n*\n** Print message on file SYSPRINT\n*\nPRINT_REPORT_RECORD EQU *\n         ST    R14,PRR_RA                 Save return address\n*\n         LA    R0,PRRRSA                  Locate work area\n         LA    R1,RECOUT   (assumed)      Locate record to print\n         L     R15,=V(DRU$PRR)            Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         L     R14,PRR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Print message on file SYSPRINT\n*\nPRINT_SYSPRINT_RECORD EQU *\n         ST    R14,PSR_RA                 Save return address\n*\n         LA    R0,PSRRSA                  Locate work area\n         LA    R1,RECOUT   (assumed)      Locate record to print\n         L     R15,=V(DRU$PSR)            Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         L     R14,PSR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Clear heading record to blanks\n*\nCLEAR_HEADREC EQU *\n         LA    R15,HEADREC                Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it\n         L     R1,=V(DRU$CON1)            -> Constants CSECTs\n         BSM   0,R14                      Return to caller\n*\n** Clear report headings\n*\nCLEAR_RH EQU   *\n         LA    R15,W_RH2                  Locate work heading 2\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(133-1,R15),0(R15)        ..Propagate it\n         LA    R15,W_RH3                  Locate work heading 2\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(133-1,R15),0(R15)        ..Propagate it\n         LA    R15,W_RH4                  Locate work heading 2\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(133-1,R15),0(R15)        ..Propagate it\n         BSM   0,R14\n*\n** Initialize message\n**\n** Output:\n** R15 - Output area on line\n** R1 - address of constants CSECT\n*\nFORMAT_MESSAGE EQU *\n         LA    R15,RECOUT                 Locate record output area\n         MVI   0(R15),C' '                Move in blank\n         MVC   1(132,R15),0(R15)          ..Propagate it\n         LA    R15,1(R15)                 Bump past FBA byte\n         MVC   0(3,R15),=C'DRU'           Get Message prefix\n         LA    R15,3(R15)                 Bump past \"DA$DISKR-\"\n         L     R1,=V(DRU$CON1)            -> Constants CSECTs\n         BSM   0,R14                      Return to caller\n*\n**       EDIT FULLWORD (FLUSH TO R15)\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITFWF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,EDITFWFM               MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '\n         BSM   0,R9                       RETURN TO CALLER\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWF0 EQU   *\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n** Convert Date from X'YY,DD,DD' to output date format\n** - C'CCYY.DDD' .... Julian\n** - C'dd-mmm-ccyy'.. European Gregorian\n** - C'CCYY-mm-dd' .. ISO standard\n**\n** Input: R1  - Address of X'yy,dd,dd'\n** Output: R15 - Address to put output date\n*\nCONVDATE EQU  *\n         CLI   0(R1),X'00'               YEAR = ZEROS?\n         BE    CVD$X                     YES, DONT EVEN BOTHER\n         CLI   PPC_DATEF,$PPC_DFEGREG    Date format is Eur Greg?\n         BE    CVD$EG                    Yes, do it\n* cli ppc_datef,$ppc_dfiso\n* be  cvd$iso\n*-Julian: 'ccyy.ddd'\n         SLR   R0,R0                     ----+\n         ICM   R0,B'0001',0(R1)              |\n         AH    R0,=H'1900'                   |\n         CVD   R0,DOUBLE                     |  FORMAT YEAR\n         UNPK  0(4,R15),DOUBLE+5(3)          |\n         OI    3(R15),C'0'               ----+\n*\n         SLR   R0,R0                     ----+\n         ICM   R0,B'0011',1(R1)              |\n         CVD   R0,DOUBLE                     |  FORMAT DAY\n         UNPK  5(3,R15),DOUBLE+6(2)          |\n         OI    7(R15),C'0'               ----+\n*\n         MVI   4(R15),C'.'\n         B     CVD$X\n*-European Gregorian: 'dd-mmm-ccyy'\nCVD$EG   DS    0H\n* need to convert yydddd in binary to \"00yydddf\"\n UNPK 0(7,R15),0(4,R1)\n MVZ  0(6,R15),=8X'00'\n TR   0(6,R15),=C'0123456789ABCDEF'\n MVI  6(R15),C' '\n B    CVD$X\n         ST    R14,DOUBLE                 Save return address\n         L     R14,=V(DRU$CON1)           Locate constants CSECT\n         MVC   W_IDJULP4(C_IDJULP4L),C_IDJULP4-DRU$CON1(R14)\n         MVI   W_IDJULP4_STR,0\n         MVC   W_IDJULP4_STR+1(3),0(R1)\n         MVC   W_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-DRU$CON1(R14)\n         ST    R15,W_ODGEUR11A_STR\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of R$DATE routine\n         CALL  (15),(W_IDJULP4,W_ODGEUR11A),                           @\n               VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n         L     R14,DOUBLE\nCVD$X    DS    0H\n         BSM   0,R14\n*\n** CONVERT BINARY TIME TO PRINT\n** INPUT: R1  - TIME TO CONVERT\n**        R15 - OUTPUT LOCATION\n*\nCONVERT_BINARY_TIME EQU *\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'100'                 DIVIDE OUT 100THS OF SECOND\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'60'                  DIVIDE OUT SECONDS\n         CVD   R0,DOUBLE                  CONVERT SECONDS TO PACKED\n         UNPK  6(3,R15),DOUBLE+6(2)       SAVE SECONDS\n         OI    6+2(R15),C'0'              FIX SIGN BYTE\n         MVI   6(R15),C':'                COLON\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'60'                  DIVIDE OUT MINUTES\n         CVD   R0,DOUBLE                  CONVERT MINUTES TO PACKED\n         UNPK  3(3,R15),DOUBLE+6(2)       SAVE MINUTES\n         OI    3+2(R15),C'0'              FIX SIGN BYTE\n         MVI   3(R15),C':'                COLON\n         CVD   R1,DOUBLE                  CONVERT MINUTES TO PACKED\n         UNPK  0(3,R15),DOUBLE+6(2)       SAVE HOURS\n         OI    0+2(R15),C'0'              FIX SIGN BYTE\n         MVI   0(R15),C' '                LEADING SPACE\n         BSM   0,R14                      Return to caller\n*\n** POINT REGISTER 15 TO FIRST BLANK IN STRING\n** INPUT:  R0  - MAXIMUM LENGTH OF STRING\n**         R15 - STRING\n** OUTPUT: R15 - FIRST SPACE IN STRING\n*\nLOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '\n         BE    LFS$X\n         LA    R15,1(R15)\n         BCT   R0,LOCATE_FIRST_SPACE\nLFS$X    EQU   *\n         BSM   0,R14\n*\n** CONVERT R1 TO A HEX STRING - FULL 8 BYTES\n** INPUT: R1 = NUMBER TO CONVERT\n** OUTPUT: R15 - ADDRESS TO PUT 8 BYTE LITERAL\n*\nHEXSTR8  DS    0H\n         ST    R1,DOUBLE                  SAVE NUMBER\n         UNPK  0(9,R15),DOUBLE(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         LA    R15,8(R15)\n         MVI   0(R15),C' '\n         BSM   0,R9\n*\n** Check number to ensure its numeric\n*\nCHKNUM   DS    0H\n         CLI   0(R15),C'0'                Min number?\n         BL    CN$INV                     No, its invalid\n         CLI   0(R15),C'9'                Max number?\n         BH    CN$INV                     No, its invalid\n         LA    R15,1(R15)                 Bump to next one\n         BCT   R0,CHKNUM                  Check number\n         BSM   0,R14\nCN$INV   DS    0H\n         SLR   R15,R15\n         BSM   0,R14\n*\n** EDIT PERCENTAGE\n**  INPUT:  R14 DIVISOR\n**          R1 DIVIDEND\n**  OUTPUT: R15 ADDRESS OF OUTPUT (4 BYTES)\n*\nEDITPER  DS    0H\n         C     R1,=8X'00'\n         BE    EDITFW4               Continue\nEP$DB0CX EQU   *\n         SLR   R0,R0                 CLEAR REGISTER\n         M     R0,=F'100'\n         SLR   R0,R0                 CLEAR REGISTER\n         DR    R0,R14                DIVIDE IT\n         SRL   R14,1\n         CR    R0,R14                IS ROUNDING NEEDED ?\n         BL    *+8                   BRANCH IF NOT\n         AH    R1,=H'1'\n* NOTE: FALL THRU INTO EDITFW4 INTERNAL SUBROUTINE...\n*\n**  EDIT FULLWORD\n**   INPUT:  R1  ADDRESS OF FULLWORD\n**   OUTPUT: R15 ADDRESS OF OUTPUT (4 BYTES)\n*\nEDITFW4  DS    0H\n         CVD   R1,DOUBLE             GET IN DECIMAL\n         MVC   0(4,R15),=X'40,20,20,20'\n         ED    0(4,R15),DOUBLE+6     FORMAT PERCENTAGE\n         OI    3(R15),C'0'           ENSURE NUMERICS\n         BSM   0,R9\n*\n** Edit number\n** INPUT:  R1 - VALUE TO EDIT\n**         R15 - ADDRESS TO PUT PATTERN\n*\nEDIT15   DS    0H\n         CVD   R1,DOUBLE                  Convert to packed\n         MVC   0(15,R15),EDITP15          Get edit pattern\n         ED    0(15,R15),DOUBLE+2         Edit number\n         OI    14(R15),C'0'               Ensure zero\n         BSM   0,R14                      Return to caller\n*\n** EDIT WITH DASH FILL FROM LEFT TO RIGHT (15 BYTES)\n** INPUT:  R1 - VALUE TO EDIT\n**         R15 - ADDRESS TO PUT PATTERN\n*\nEDITD15  DS    0H\n         CVD   R1,DOUBLE                  CONVERT TO PACKED\n         MVC   0(15,R15),EDITP15          GET EDIT PATTERN\n         MVI   0(15),C'-'                 LEADING DASHES\n         ED    0(15,R15),DOUBLE+2         EDIT\n         LTR   R1,R1                      DID HE FIND ANYTHING TO EDIT?\n         BNZ   EDITD15X                   YES, MOVE ON\n         MVI   14(R15),C'0'               NO, LEAVE A ZERO\nEDITD15X DS    0H\n         BSM   0,R9                       RETURN\n*\n** Clear recout to blanks\n*\nCLEAR_RECOUT EQU *\n         LA    R15,RECOUT                 Locate output record\n         MVI   0(R15),C' '                Get blank\n         MVC   1(132,R15),0(R15)          ..propagate it\n         BSM   0,R14                      Leave\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Sort file specified on sort statement at RECOUT             **\n**                                                                   **\n**       Input: R1 has sort string                                   **\n**              SF_SORTIN  - DDNAME of input file                    **\n**              SF_SORTOUT - DDNAME of output file                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nSORT_FILE DS   0H\n         ST    R14,RA$SORT_FILE           Save return address\n*\n** Create SORT control card string\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         LA    R15,RECOUT+3               Locate SORT statement start\n         MVC   0(13,R15),=C'SORT FIELDS=(' Text\n         LA    R15,13(R15)                Bump past it\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R1)                  Get length\n         EX    R14,SF$MSF                 Move in sort fields\n         LA    R15,1(R14,R15)             Bump past sort fields\n         MVC   0(16,R15),=C') OPTION SORTIN=' Text\n         LA    R15,16(R15)                Bump past it\n         MVC   0(8,R15),SF_SORTIN         WRKFILE1 DDNAME\n         LA    R0,8                       Max length of DDNAMe\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n*\n         MVC   0(9,R15),=C',SORTOUT='     Text\n         LA    R15,9(R15)                 Bump past it\n         MVC   0(8,R15),SF_SORTOUT        WRKFILE2 DDNAME\n         LA    R0,8                       Max length of DDNAME\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n*\n         LR    R5,R15                     Save location on record\n         DEVTYPE =CL8'SORTWK01',DOUBLE    User specified files for us?\n         LTR   R15,R15                    Have at least one?\n         BZ    SF$DSWX                    Yes, continue\n         LR    R15,R5                     Get location on record\n         MVC   0(11,R15),=C',DYNALLOC=('  Text\n         LA    R15,11(R15)                Bump past it\n         L     R14,=V(DRU$OPTS)           Locate options CSECT\n         MVC   0(8,R15),OP_SRTUNIT-DRU$OPTS(R14)\n         LA    R0,8                       Max length of DDNAME\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n         MVC   0(3,R15),=C',3)'           Text\n         LA    R15,3(R15)                 Bump past it\nSF$DSWX EQU    *\n*\n         MVC   0(8,R15),=C',MSGDDN='      Text\n         LA    R15,8(R15)                 Bump past it\n         MVC   0(8,R15),DDN_WF5           Sort message DDNAME\n         LA    R0,8                       Max length of DDNAME\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n*\n** Calculate length of the sort control statement and fix parameter lst\n*\n         LA    R15,1(R15)                 Add for ending space\n         LA    R14,RECOUT+2               Beginning of sort statement\n         SR    R15,R14                    Length = End - Beginning\n         STCM  R15,B'0011',RECOUT         Save length of sort statement\n*\n         SLR   R5,R5                      Set pseudo return code\n         LA    R1,SF_PARM                 Locate parameter list\n         LA    R15,RECOUT                 Locate control statements\n         ST    R15,0(R1)                  Save it into parm list\n         MVC   4(4,R1),=X'FFFFFFFF'       Set end of list\n*\n** Attach the sort\n*\n         LA    R9,SF_ECB                  Locate Event Control Block\n         XC    0(4,R9),0(R9)              Clear Event control Block\n         L     R14,=V(DRU$CON1)           -> DRU$CON1\n         MVC   PARMLIST(C_ATCL),C_ATC-DRU$CON1(R14)\n*\n         ATTACH EPLOC==CL8'SORT',         Attach Sort                  @\n               ECB=(9),                   ..Event Control Block        @\n               SF=(E,PARMLIST)            ..Attach Execute form\n         ST    R1,SF_TCB                  Save TCB address\n*\n         WAIT  ECB=SF_ECB                 Wait for Sort to complete\n         DETACH SF_TCB                    Detach Sort\n*\n         CLC   SF_ECB+1(3),=8X'00'        Sort successful?\n         BNE   SF$ERR                     No, error!\n         TM    PPC_FLAG1,$PPC_F1PSM       Print Sort messages?\n         BO    SF$ECHO                    Yes, echo the output\n         B     SF$EX                      No, leave\nSF$ERR   DS    0H\n         MVI   MAXCC,20\n*\n** Echo the SORT results to our SYSPRINT\n*\nSF$ECHO  EQU   *\n         BAS   R14,CLEAR_RECOUT\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\n         BAS   R14,FORMAT_MESSAGE         Clear output record to blanks\n         MVC   0(MSG4L,R15),MSG4-DRU$CON1(R1)\n         LA    R15,MSG4L(R15)             Bump past it\n         UNPK  0(9,R15),SF_ECB(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         MVI   8(R15),C' '\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\n*\n         LA    R3,WRKFILE5                Locate DCB work area\n         L     R1,=V(DRU$CON1)\n         MVC   PARMLIST(C_LSTIL),C_LSTI-DRU$CON1(R1)\n         MVC   0(C_DCBIL,R3),C_DCBI-DRU$CON1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),DDN_WF5  Get DDNAME\n         OI    DCBRECFM-IHADCB(R3),DCBRECCA   Turn on ASA\n         LA    R1,SF$SYNAD\n         STCM  R1,B'0111',DCBSYNAD+1-IHADCB(R3)\n         LA    R2,SF$ELX                  Locate END-OF-FILE area\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\n         MVI   RECOUT+1,C'-'\n         MVC   RECOUT+2(131),RECOUT+1\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\n         MVI   RECOUT+121,C' '\n         MVC   RECOUT+122(11),RECOUT+121\n*\nSF$EL    EQU   *\n         GET   WRKFILE5                   Get SORTMSG record\n         TM    FLAG_X1,$FX1_SYNAD         Hit a SYNAD error?\n         BO    SF$SERR                    Yes, leave\n         MVC   RECOUT+1(120),1(R1)        Move SORTMSG record\n         BAS   R14,PRINT_SYSPRINT_RECORD Issue it\n         B     SF$EL\n*\nSF$SERR  EQU   *\n         BAS   R14,FORMAT_MESSAGE         Clear output record to blanks\n         MVC   0(MSG23L,R15),MSG23-DRU$CON1(R1)\n         LA    R15,MSG23L+1(R15)\n         MVC   0(78,R15),WORKAREA\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\n*\nSF$ELX   EQU   *\n         MVI   RECOUT+1,C'-'\n         MVC   RECOUT+2(131),RECOUT+1\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\n         BAS   R14,CLEAR_RECOUT\n         BAS   R14,PRINT_SYSPRINT_RECORD Print the record\n*\n         LA    R3,WRKFILE5\n         BAS   R9,CLOSE_FILE\nSF$EX    EQU   *\n*\n** Common exit from Sort_File\n*\nSF$X     EQU   *\n         LR    R15,R5                     SORT successful?\n         L     R14,RA$SORT_FILE           Get return address\n         BSM   0,R14                      Return to caller\nSF$MSF   MVC   0(0,R15),1(R1)             Get fields\n*\n** SYNAD error routine for reading SORTMSG\n*\nSF$SYNAD EQU   *\n         STM   R12,R14,PARMLIST\n         SYNADAF ACSMETH=QSAM\n*\n         MVC   WORKAREA(78),50(R1)      Save error message\n         OI    FLAG_X1,$FX1_SYNAD       Turn on flag\n*\n         SYNADRLS ,\n*\n         LM    R12,R14,PARMLIST\n         BR    R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Data Constants                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\n*\nC_DSNLV  DC    AL1(C_DSNLVL/2)\nC_DSNLVS DA#STR 'By Volume'\nC_DSNLVL EQU   *-C_DSNLV-3\n*\nC_DSNLD  DC    AL1(C_DSNLDL/2)\nC_DSNLDS DA#STR 'By Data Set Name'\nC_DSNLDL EQU   *-C_DSNLD-3\n*\nC_NODE   DC    AL1(C_NODEL/2)\nC_NODES  DA#STR  'NODE list'\nC_NODEL  EQU   *-C_NODE-3\n*\nC_DCRV   DC    AL1(C_DCRVL/2)\nC_DCRVS  DA#STR  'DASD list by Volume'\nC_DCRVL  EQU   *-C_DCRV-3\n*\n AGO .RACF2X\nC_NODERF DC    C'Note: \"*\" nodes have no RACF group'\nC_NODERFL EQU  *-C_NODERF\n*\nC_RLOC   ICHEINTY LOCATE,TYPE='USR',MF=L\nC_RLOCL  EQU   *-C_RLOC\n.RACF2X ANOP ,\n*\nC_DU     DC    AL1(C_DUL/2)\nC_DUS    DA#STR  'DASD Usage'\nC_DUL    EQU   *-C_DU-3\n*\nC_DT     DC    AL1(C_DTL/2)\nC_DTS    DA#STR  'Device Type Summary'\nC_DTL    EQU   *-C_DT-3\n*\n*\nC_STVL   DC    AL1(C_STVLL/2)\nC_STVLS  DA#STR 'VTOC LISTING'\nC_STVLL  EQU   *-C_STVL-3\n*\n** Literals\n*\nLTORG    DS    0F\n         LTORG ,\nLTORGL   EQU   *-LTORG\n         DS    0D\n*\n** Calculate room used and left in main CSECT\n*\n#DA$DISKR EQU  *-DA$DISKR                 Length of CSECT\n#DA$DISKR_LEFT EQU (3*4096)-#DA$DISKR     Bytes free in CSECT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAINed work area                                         **\n***                                                                 ***\n***********************************************************************\n             SPACE 2\nDSA          DSECT ,\n             DS    18F                    Register Save area\nSUBRSA       DS    18F                    Register Save Area 4 subs\nBLETRSA      DS    18F                    Register Save Area 4 DRU$BLET\nPSRRSA       DS    18F                    Register Save Area 4 DRU$PSR\nPRRRSA       DS    18F                    Register Save Area 4 DRU$PRR\nPARMLIST     DS    XL256                  Parameter list\n             DS    0D\nDOUBLE       DS    D                      Double word work area\nDOUBLE2      DS    2D                     Double word work area * 2\nE_OPENA_CODE DS    F                      E$OPENA - Code\n*                                         Merge: VATLST, System config\nMVS_IV_VSL   DS    F                      ..IncVATLST - Table Length\nMVS_IV_VSA   DS    F                      ..IncVATLST - Table Address\nMVS_IV_VSC   DS    F                      ..IncVATLST - Table Cur. Loc.\nMVS_IV_NUM   DS    F                      ..Number in table\n*                                         Return Address\nRA$DUPRT     DS    F                      ..DU$PRT\nRA$SORT_FILE DS    F                      ..SORT_FILE\n*                                         Big Letters:\nBL_LEN       DS    F                      ..Length\nBL_ADDR      DS    F                      ..Address\nBL_LINEC     DS    F                      ..Line Count\nBL_RA        DS    F                      ..Return Address\n*                                         DASD Usage\n*                                         ..Group\nDU_WGVOLC    DS    F                      ..Volume count\nDU_WGFTRK    DS    F                      ..Free tracks\nDU_WGTTRK    DS    F                      ..Total tracks\n*                                         ..Total\nDU_WTVOLC    DS    F                      ..Volume count\nDU_WTTTRK    DS    F                      ..Total tracks\nDU_WTATRK    DS    F                      ..Allocated tracks\nDU_WTFTRK    DS    F                      ..Free tracks\n*\nDU_TF1       DS    F                      ..F1DSCB\nDU_TUC       DS    F                      ..Uncatalogued datasets\n*                                         Entry point\nEP_EB4UV     DS    F                      ..IEFEB4UV\nEP_SS01      DS    F                      ..IDCSS01\nEP_DA$MXD    DS    F                      ..DA$MXD\nEP_DA$DATE   DS    F                      ..DA$DATE\n*                                         Process_Volume\nPV_VIT       DS    2F                     ..VTOC Information Table\nPV_EXLST     DS    2F                     ..Exit List\nPV_VCOUNT    DS    F                      ..Volume count\nPV_SCOUNT    DS    F                      ..SMS count\nPV_TCOUNT    DS    F                      ..Total datasets\nPV_DCOUNT    DS    F                      ..DSCB count for volume\nPV_STOD      DS    2F                     ..Start time and date\nPV_ETOD      DS    2F                     ..End time and date\nPV_JFCB      DS    XL(JFCBLGTH)           ..JFCB area\nPV_CVPL      DS    XL(C_CVPLL)            ..CVAF - VTOC acess\nPV_BAREA     DS    XL(#BUFLST)            ..CVAFSEQ buffer list\nPV_DECB      DS    XL(C_DECBL)            ..DECB area\n             DS    0F                     Scan_DASD_UCBs:\nSDU_UCB      DS    F                      ..Returned UCB address\nSDU_RETCODE  DS    XL4                    ..RC\nSDU_RSNCODE  DS    XL4                    ..Reason\nSDU_WA       DS    XL100                  ..Workarea\n             DS    0F\nSDU_UA       DS    XL48                   ..UCB area\n             DS    0F\nSDU_CMXT     DS    XL32                   ..CMXT area\n             DS    0F\nSDU_UCBP     DS    XL48                   ..UCB prefix\n             DS    0F\nSDU_DCE      DS    XL256                  ..DCE area\nSDU_DCELEN   DS    XL2                    ..DCE length\nSDU_DEVT     DS    CL1                    ..Device class\n             DS    0F                     Search DASD_UCBs\nSDU_CMATCH   DS    F                      ..Count: Volume matched\nSDU_COFF     DS    F                      ..Count: Offline\nSDU_CON      DS    F                      ..Count: Online\nSDU_UCBERA   DS    F                      ..Return address\nSDU_DDC      DS    2F                     ..DDC table length, address\n             DS    0F                     Parse_Parameter_Card\nPPC_RA       DS    F                      ..Return Address\nPPC_CB       DS    2F                     ..Command Buffer len,addr\nPPC_NUM      DS    H                      ..Number of parms in error\nPPC_COL      DS    H                      ..Column of first error\n*-DATEF is not set via a parm yet.\nPPC_DATEF    DS    X                      ..Date format\n$PPC_DFJUL   EQU   X'00'                    ..Julian       1962.056\n$PPC_DFISO   EQU   X'01'                    ..US Gregorian 1962-03-06\n$PPC_DFEGREG EQU   X'02'                    ..Eur. Greg.   06-MAR-1997\n$PPC_NOCHK   EQU   255                    ..Length byte if no check\nPPC_VPREFIXL DS    X                      ..Volume prefix length\nPPC_VPREFIX  DS    CL6' '                 ..Volume prefix\nPPC_FLAG1    DS    B'00000000'            ..Flag 1\n$PPC_F1VERB  EQU   B'10000000'              ..Verbose\n$PPC_F1RUCB  EQU   B'01000000'              ..Report by UCB also?\n$PPC_F1RBOTH EQU   B'01100000'              ..Report by both UCB+Volume\n$PPC_F1PSM   EQU   B'00010000'              ..Print Sort Messages?\n$PPC_F1SMSMC EQU   B'00001000'              ..SMS migration check?\n$PPC_F1CATC  EQU   B'00000100'              ..Catalog check?\n$PPC_F1RDSN  EQU   B'00000010'              ..Report by DSN also?\nPPC_FLAG2    DS    B'00000000'            ..Flag 2\n$PPC_F2DEBUG EQU   B'10000000'              ..Debug mode?\n$PPC_F2NAUTH EQU   B'01000000'              ..Don't try auth stuff?\n$PPC_F2CVTUS EQU   B'00100000'              ..Use CVTUS?\n$PPC_F2ORU   EQU   B'00010000'              ..Only RECFM=U?\n$PPC_F2OLL   EQU   B'00011000'              ..Only RECFM=U & PDS?\n$PPC_F2DO    EQU   B'00000100'              ..DATAONLY for VTOCRPT?\n$PPC_F2HELP  EQU   B'00000010'              ..Help wanted?\n$PPC_F2NOPIC EQU   B'00000001'              ..No picture at startup?\nPPC_FLAG3    DS    B'00000000'            ..Flag 3\n$PPC_F3NSYSP EQU   B'10000000'              ..No System Profile?\n             DS    0F                     Heading management\nPRR_TITLE    DS    F                      ..Report title\nPRR_STITLE   DS    F                      ..Report Sub-Title\nPRR_PC       DS    F                      ..Report page count\nPRR_LC       DS    X                      ..Sysprint Line count\n*                                         Process VATDEF card\nPVC_VATDEF   DS    CL72                   ..VATDEF card\nPVC_IPLUSE   DS    CL3' '                 ..IPLUSE\nPVC_SYSUSE   DS    CL3' '                 ..SYSUSE\n*                                         DD Names\nDDN_WF1      DS    CL8                    ..WRKFILE1\nDDN_WF2      DS    CL8                    ..WRKFILE2\nDDN_WF3      DS    CL8                    ..WRKFILE3\nDDN_WF4      DS    CL8                    ..WRKFILE4 (LRECL=80)\nDDN_VAT      DS    CL8                    ..VATLST\nDDN_WF5      DS    CL8                    ..Sort Messages\n*\n** DCB areas\n*\n             DS    0F                     DCB areas\nWRKFILE1     DS    XL(C_DCBIL)            ..WORK FILE 1\nWRKFILE2     DS    XL(C_DCBIL)            ..WORK FILE 2\nWRKFILE3     DS    XL(C_DCBIL)            ..WORK FILE 3\nWRKFILE4     DS    XL(C_DCBIL)            ..WORK FILE 4\nWRKFILE5     DS    XL(C_DCBIL)            ..WORK FILE 5\nREPORT       DS    XL(C_DCBOL)            ..REPORT\n             DS    0F                     Print_SYSPRINT_Record\nSYSPRINT     DS    XL(C_DCBOL)            ..SYSPRINT\nPSR_RA       DS    F                      ..Return address\nPSR_PC       DS    F                      ..Sysprint Page count\nPSR_LC       DS    X                      ..Line count on page\n             DS    0F                     Print_Report_Record:\nPRR_RA       DS    F                      ..Return address\n             DS    0F                     Global variables\nG_DASD       DS    F                      ..Online DASD count\nG_VATMNT     DS    F                      ..Number: VATLST-UCB mount\nG_BCPLEVEL   DS    XL(L'CVTPRODN)         ..BCP Product Name\nG_DFARELS    DS    XL(L'DFARELS)          ..DFSMS/MVS level (binary)\nG_DFSMSLVL   DS    CL5'1.3.0'             ..DFSMS/MVS level (Character)\nG_DFPLVL     DS    CL5'3.3.2'             ..DFP level\n*\n** Work areas\n*\nHEADREC      DS    CL133                  Heading record\n             DS    0D\nCMXD_WA      DS    XL(CMXDL)\nCMXD_RC      DS    X\n*                                         Sort_File\nSF_ECB       DS    F                      ..Event Control Block\nSF_TCB       DS    F                      ..Task Control Block\nSF_PARM      DS    3F                     ..Parameter List\nSF_SORTIN    DS    CL8                    ..SORTIN ddname\nSF_SORTOUT   DS    CL8                    ..SORTOUT ddname\nSF_EXIT15    DS    XL4                    ..Exit 15 address\nSF_TYPE      DS    C                      ..Type for Exit 15\nSF_LRECL     DS    C'80'                  ..LRECL for Exit 15\n*\n** DA$DISKR ESTAE parameters\n*\nRSEP         DS    0D                     DRU$ESTA parameters\nRSEP_R10     DS    F                      ..Base register (10)\nRSEP_R11     DS    F                      ..Base register (11)\nRSEP_R12     DS    F                      ..Base register (12)\nRSEP_RETRYO  DS    H                      ..Retry routine offset\nRSEP_UCB     DS    CL4                    ..UCB\nRSEP_VOL     DS    CL6                    ..Volume\nRSEP_FUNC    DS    CL8                    ..ID of function\nRSEP_WTO     DS    XL(C_WTOL)             ..WTO work area\n             DS    0D                     Alignment\n*\n** DA#DATE work areas\n*\nW_ODDOW9     DA#DATE DPE,OPREFIX=W_ODDOW9,                             @\n               OSTR=YES,OSTRL=$DA#DATE_ODDOW9\nW_ODJUL8     DA#DATE DPE,OPREFIX=W_ODJUL8,                             @\n               OSTR=YES,OSTRL=$DA#DATE_ODJUL8\nW_ODGEUR11   DA#DATE DPE,OPREFIX=W_ODGEUR11,                           @\n               OSTR=YES,OSTRL=$DA#DATE_ODGEUR11\nW_OTIMES8    DA#DATE DPE,OPREFIX=W_OTIMES8,                            @\n               OSTR=YES,OSTRL=$DA#DATE_OTIMES8\nW_IDJULP4    DA#DATE DPE,OPREFIX=W_IDJULP4,OSTR=YES,                   @\n               OSTRL=$DA#DATE_IDJULP4\nW_ODGEUR11A  DA#DATE DPE,OPREFIX=W_ODGEUR11A,OSTR=YES,OSTRL=4\nW_ODDOW3A    DA#DATE DPE,OPREFIX=W_ODDOW3A,OSTR=YES,OSTRL=4\n*\n** Flags\n*\nFLAG_R       DS    B'00000000'            ..REPORT\n$DCRV        EQU   B'10000000'            ....DASD CONFIG RPT BY VOLS\n$DCRU        EQU   B'01000000'            ....DASD CONFIG RPT BY UCB\nFLAG_X1      DS    B'00000000'            ..Execution flag\n$FX1_SYSPRT  EQU   B'10000000'            ....SYSPRINT file error\n$FX1_VEOF    EQU   B'01000000'            ....VATLST End-of-file\n$FX1_SEOF    EQU   B'00100000'            ....Sys config end-of-file\n$FX1_APF     EQU   B'00010000'            ....APF Authorization?\n$FX1_SYNAD   EQU   B'00001000'            ....SYNAD error?\n$FX1_VTOC    EQU   B'00000100'            ....VTOC processing?\n$FX1_UCBSCAN EQU   B'00000010'            ....Use UCBSCAN?\n*open----->  EQU   B'00000001'            ....\nFLAG_X2      DS    B'00000000'            ..Execution flag 2\n$FX2_DDCO    EQU   B'10000000'            ....DDC table overflow\n$FX2_LDATE   EQU   B'01000000'            ....Loaded DA$DATE?\n$FX2_LMXD    EQU   B'00100000'            ....Loaded DA$MXD?\nMAXCC        DS    X                      Maximum Condition code\n*\nLASTVOLP     DS    CL5                    Last volume (control break)\nLASTCHAN     DS    CL1                    Last channel (control break)\n*\n** Output records\n*\nW_RH2        DS    CL133                  Report heading 2\nW_RH3        DS    CL133                  Report heading 3\nW_RH4        DS    CL133                  Report heading 4\n*\nRECOUT       DS    XL(WDL)                Output record\nWRKREC       DS    XL(WDL)                Work record\n             DS    0D\nWORKAREA     DS    XL265                  Work area\n             DS    0D\nDSAL         EQU   *-DSA\n             EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Constants CSECT                                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDRU$CON1 CSECT ,\nDRU$CON1 AMODE 24\nDRU$CON1 RMODE 24\n*\n** Standard O/S eyecatcher\n*\nCON1_EC  B    CON1_ECL(0,R15)           Bump past EyeCatcher\n         DC   AL1(L'CON1_ECV)           Length of eyecatcher\nCON1_ECV DC   C'DRU$CON1 -- Constant CSECT #1'\n         DS   0H\nCON1_ECL EQU  *-CON1_EC\n*\n** Messages\n*\nMSG1     DC    C'01I Execution'\nMSG1L    EQU   *-MSG1\nMSG1A    DC    C'Begins. Time:'\nMSG1AL   EQU   *-MSG1A\nMSG1B    DC    C'Ends. Maximum condition code was'\nMSG1BL   EQU   *-MSG1B\n*\nMSG2     DC    C'02E ENQ to VTOC failed, RC='\nMSG2L    EQU   *-MSG2\nMSG3     DC    C'03I VATLST and system mounts differ on'\nMSG3L    EQU   *-MSG3\nMSG4     DC    C'04I Sort completed with ECB='\nMSG4L    EQU   *-MSG4\nMSG5     DC    C'05E DEVTYPE failure: assuming 3380D, RC='\nMSG5L    EQU   *-MSG5\nMSG6     DC    C'06E LSPACE failed, RC='\nMSG6L    EQU   *-MSG6\nMSG7     DC    C'07E IEFEB4UV failed, RC='\nMSG7L    EQU   *-MSG7\nMSG8     DC    C'08W Device types do not match on volume('\nMSG8L    EQU   *-MSG8\nMSG9     DC    C'09W Name not consistent on volume='\nMSG9L    EQU   *-MSG9\nMSG10    DC    C'10I UCB disassociated from subchannel: ('\nMSG10L   EQU   *-MSG10\nMSG12    DC    C'12I'\nMSG12L   EQU   *-MSG12\nMSG12A   DC    C' VATLST entries are unused:'\nMSG12AL  EQU   *-MSG12A\nMSG15    DC    C'15E DYNALLOC to volume failed, RC='\nMSG15L   EQU   *-MSG15\nMSG16    DC    C'16E RDJFCB failed, RC='\nMSG16L   EQU   *-MSG16\nMSG17    DC    C'17E OPEN failed, RC='\nMSG17L   EQU   *-MSG17\nMSG18    DC    C'18E CVAFSEQ failed, RC='\nMSG18L   EQU   *-MSG18\nMSG19    DC    C'19I Dump of'\nMSG19L   EQU   *-MSG19\nMSG20    DC    C'20W Runing unauthorized, some functions disabled'\nMSG20L   EQU   *-MSG20\nMSG21    DC    C'21I IEA168I '\nMSG21T   DC    C'VATLST default use attribute of '\nMSG21A   DC    C'PRIVATE used'\nMSG21L   EQU   *-MSG21\nMSG22    DC    C'22I Format error found in VATDEF statement'\nMSG22L   EQU   *-MSG22\nMSG23    DC    C'23I Read of SORTMSG failed:'\nMSG23L   EQU   *-MSG23\nMSG24    DC    C'24I Found $$NOAPF DDNAME, turning off authorized '\n         DC    C'function processing'\nMSG24L   EQU   *-MSG24\nMSG25    EQU   *-*                        Reserved for ESTAE routine\nMSG26    DC    C'DA$DISKR-026I '\n         DC    C'Attempting retry after ABEND: UCB='\nMSG26UCB DC    C'xxxx'\n         DC    C', volume='\nMSG26VOL DC    C'vvvvvv'\n         DC    C' - function='\nMSG26ID  DC    8C'?'\nMSG26L   EQU   *-MSG26\nMSG27    DC    C'27E ABEND occurred while processing ('\nMSG27UCB DC    C'xxxx'\nMSG27D   DC    C'-'\nMSG27VOL DC    C'vvvvvv)'\n         DC    C' function='\nMSG27ID DC     8C'?'\nMSG27L   EQU   *-MSG27\nMSG28    DC    C'28I Number of DASD UCBs Online='\nMSG28L   EQU   *-MSG28\nMSG29    DC    C'29W Overflow found in DASD device count table'\nMSG29L   EQU   *-MSG29\nMSG30    DC    C'30I Parameter:'\nMSG30L   EQU   *-MSG30\nMSG31    DC    C'30E First invalid parm at column:'\nMSG31L   EQU   *-MSG31\nMSG32    DC    C'31E Number of invalid parms:'\nMSG32L   EQU   *-MSG32\nMSG33    DC    C'33I Number of volumes matched:'\nMSG33L   EQU   *-MSG33\nMSG34    DC    C'34I VTOC processing started at'\nMSG34L   EQU   *-MSG34\nMSG35    DC    C'35I SMS flag byte='\nMSG35F   DC    C'xx '\n         DC    C'- volume='\nMSG35V   DC    C'volume'\n         DC    C', dsn='\nMSG35L   EQU   *-MSG35\nMSG36    DC    C'36W Warning: Not all DASD UCBs will be shown if '\n         DC    C'defined dynamic or above the line'\nMSG36L   EQU   *-MSG36\nMSG37    DC    C'37E UCBSCAN macro failed for UCB='\nMSG37L   EQU   *-MSG37\nMSG38    DC    C'38I UCBVOLI all zeros: Skipping UCB='\nMSG38L   EQU   *-MSG38\n*\nMSG40    DC    C'40I Processing UCB='\nMSG40UCB DS    XL(L'WD_UCB)\n         DC    C' volume='\nMSG40VOL DS    XL(L'WD_VOLS)\n         DC    C' at'\nMSG40L   EQU   *-MSG40\nMSG41    DC    C'41I > VTOC will be read using '\nMSG41T   DC    C'BSAM'\n         DC    C' for volume '\nMSG41V   DC    C'volume'\nMSG41L   EQU   *-MSG41\n*\nMSG60    DC    C'60I Datasets with SMS indicators: '\nMSG60L   EQU   *-MSG60\nMSG61    DC    C'61I Total number of datasets:     '\nMSG61L   EQU   *-MSG61\nMSG62    DC    C'062I Help information for DA$DISKR:'\nMSG62L   EQU   *-MSG62\nMSG63    DC    C'63I '\nMSG63A   DC    C'Level of'\nMSG63L   EQU   *-MSG63\nMSG63B   DC    C'DFSMS/MVS:'\nMSG63D   DC    C'DFP:'\nMSG63E   DC    C'- BCP:'\n*\nC_MSGS   DC    C'M e s s a g e s'\nC_SYSID  DC    C'SYSID:'\nC_DU_GROUP DC C'Group'\nC_DU_NUM   DC C'Number'\nC_DU_TTRK  DC C'Total Tracks'\nC_DU_ATRK  DC C'Allocated Tracks'\nC_DU_FTRK  DC C'Free  Tracks'\nC_NUMV     DC C'Number of datasets on volume is'\n*\nC_DCRC   DC    AL1(C_DCRCL/2)\nC_DCRCS  DA#STR  'DASD list by Channel'\nC_DCRCL  EQU   *-C_DCRC-3\nC_STDC   DC    AL1(C_STDCL/2)\nC_STDCS  DA#STR  'DASD Configuration'\nC_STDCL  EQU   *-C_STDC-3\n*\nC_SUM    DC    AL1(C_SUML/2)\nC_SUMS   DA#STR  'Summary'\nC_SUML   EQU   *-C_SUM-3\n*\nC_BLDC1  DA#STR '  DASD  '\nC_BLDC2  DA#STR ' CONFIG '\nC_BLDL   DA#STR 'DSN LIST'\nC_BLBV   DA#STR ' BY VOL '\nC_BLBD   DA#STR ' BY DSN '\n*\n** DA#DATE constants\n*\nC_ODDOW9   DA#DATE DPE,OPREFIX=C_ODDOW9,OSTR=NO,                       @\n               OSTRL=$DA#DATE_ODDOW9,OTYPE=$DA#DATE_ODDOW\nC_ODJUL8   DA#DATE DPE,OPREFIX=C_ODJUL8,OSTR=NO,                       @\n               OSTRL=$DA#DATE_ODJUL8,OTYPE=$DA#DATE_ODJUL\nC_ODGEUR11 DA#DATE DPE,OPREFIX=C_ODGEUR11,OSTR=NO,                     @\n               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR\nC_OTIMES8  DA#DATE DPE,OPREFIX=C_OTIMES8,OSTR=NO,                      @\n               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES\nC_IDJULP4  DA#DATE DPE,OPREFIX=C_IDJULP4,OSTR=NO,                      @\n               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP\nC_ODGEUR11A DA#DATE DPE,OPREFIX=C_ODGEUR11A,                           @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR\nC_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW\n*\n** I/O constatns\n*\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\n         PRINT NOGEN\n         READ  C_DECB,SF,*-*,*-*,'S',MF=L\nC_DECBL  EQU   *-C_DECB\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\n*\nC_RDJFCB RDJFCB (*-*),MF=L\nC_RDJFCBL EQU  *-C_RDJFCB\n*\n** Constant DCBs\n*\nC_DCBI   DCB   DDNAME=C_DCBI,                                          @\n               DSORG=PS,MACRF=GL,RECFM=FB,EODAD=*-*\nC_DCBIL  EQU   *-C_DCBI\nC_DCBV   DCB   DDNAME=C_DCBV,                                          @\n               DSORG=PS,MACRF=R,RECFM=F,BLKSIZE=96,KEYLEN=44\nC_DCBVL  EQU   *-C_DCBV\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DSORG=PS,MACRF=PM\nC_DCBOL  EQU   *-C_DCBO\n*\n** LSPACE\n*\nC_LSPC   LSPACE MF=L\nC_LSPCL  EQU   *-C_LSPC\nC_LSPCDL LSPACE MF=(L,DATA)               LSPACE data mapping\nC_LSPCDLL EQU  *-C_LSPCDL\n*\n** Misc\n*\nC_CVPL   CVAFSEQ DEB=*-*,BUFLIST=*-*,                                  @\n               IXRCDS=KEEP,                                            @\n               ACCESS=GTEQ,                                            @\n               MF=L\nC_CVPLL  EQU   *-C_CVPL\n*\nC_ATC    ATTACH EPLOC=*-*,SF=L\nC_ATCL   EQU   *-C_ATC\n*\nC_LOCATE CAMLST NAME,*-*,,*-*\nC_LOCATEL EQU  *-C_LOCATE\n*\nC_DTYPE  DEVTYPE ,(*-*,24),UCBLIST=(*-*,*-*),MF=L\nC_DTYPEL EQU   *-C_DTYPE\n*\nC_ESTAE  ESTAE *-*,CT,TERM=NO,MF=L\nC_ESTAEL EQU   *-C_ESTAE\n*\nC_ENQ    ENQ   (*-*,*-*,S,6,SYSTEM),RET=TEST,MF=L\nC_ENQL   EQU   *-C_ENQ\n*\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\n*\n** Startup picture\n**\n** Author of this \"ASCII\" art is unknown.\n*\nSTARTUP_PICTURE DS 0H\n DA#STR ' '\n DA#STR '              ________*________     The Disk Report Utility - @\n               v&DAVER'\n DA#STR '____________  \\_______________/'\n DA#STR '\\__________/      / /               Freeware! written by David@\n                Alcock'\n DA#STR '     __\\ \\_______/ /__ '\n DA#STR '     \\_______________/              Assembled on &ASMDATE. at @\n               &SYSTIME using:'\n DA#STR ' '\n DA#STR '        DASD Space:                 - &DMACLIB. MACLIBs'\n DA#STR '     The Final Frontier             - &MMACLIB. MACLIBs'\n DC  X'FFFF'\n*\n* That silliness deserves some more:\n* ---------------------------------\n*\n* Star Trek XVII - The search for DASD space.\n* To boldy go where no DASD report utility has gone before!\n*\n* DASD Space: The final frontier. 0 bytes free.\n*\n* Dammit Jim! I'm a doctor not a DASD storage admistrator.\n*\n* Spock: Are you out of your Vulcan mind?\n*\n* Data: \"It's a Singer\". Captain Picard: \"Make it sew\".\n*\nNO_PICTURE DS 0H\n DA#STR 'The Disk Report Utility - v&DAVER'\n DA#STR ' '\n DA#STR 'Freeware! written by David Alcock'\n DA#STR ' '\n DA#STR 'Assembled on &ASMDATE. at &SYSTIME using:'\n DA#STR ' '\n DA#STR '- &DMACLIB. MACLIBs'\n DA#STR '- &MMACLIB. MACLIBs'\n DA#STR ' '\n DC  X'FFFF'\n         DS    0D\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Options CSECT                                               **\n***                                                                 ***\n***********************************************************************\n           SPACE 2\nDRU$OPTS   CSECT ,\nDRU$OPTS   AMODE 24\nDRU$OPTS   RMODE 24\n*\nOP         EQU   *\n*\n** Standard O/S eyecatcher\n*\nOPTS_EC  B    OPTS_ECL(0,R15)           Bump past EyeCatcher\n         DC   AL1(L'OPTS_ECV)           Length of eyecatcher\nOPTS_ECV DC   C'DRU$OPTS -- Options'\n         DS   0H\nOPTS_ECL EQU  *-OPTS_EC\n*\n*\n           DC    C'NODES='\nOP_NODES   DC    H'4096'\n*\n           DC    C'VOLPRFX='\nOP_VOLP    DC    X'04'\n*\n           DC    C'SRTUNIT='\nOP_SRTUNIT DC    CL8'SYSDA'\n*\n           DC    C'DDNAMES='\nOP_WF1     DC    CL8'WRKFILE1'\nOP_WF2     DC    CL8'WRKFILE2'\nOP_WF3     DC    CL8'WRKFILE3'\nOP_WF4     DC    CL8'WRKFILE4'\nOP_WF5     DC    CL8'WRKFILE5'\nOP_VAT     DC    CL8'VATLST'\n*\nOP_TDASDT  EQU   *\n           DC    CL8'3380',C'E',AL2(1770+1)\n           DC    CL8'3380',C'K',AL2(2655+1)\nOP_TDASDTE EQU   (*-OP_TDASDT)/OPTDTL\n*\nOPL        EQU   *-OP\n           DS    0D\n*\n** Map OP_TDASDT\n*\nOPTDT       DSECT   ,\nOPTDT_NAME  DS   CL8'3380'                Name returned from IEFEB4UV\nOPTDT_TYPE  DS   C                        Type\nOPTDT_CYLS  DS   XL2                      Number of cylinders\nOPTDTL      EQU  *-OPTDT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Reset headings for VTOC listing                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDRU$RVOL CSECT ,\nDRU$RVOL AMODE 24\nDRU$RVOL RMODE 24\n         USING DRU$RVOL,R8                Set base register for CSECT\n*\n** Standard O/S eyecatcher\n*\nRVOL_EC  B    RVOL_ECL(0,R8)            Bump past EyeCatcher\n         DC   AL1(L'RVOL_ECV)           Length of eyecatcher\nRVOL_ECV DC   C'DRU$RVOL -- Reset Headings for VTOC listings'\n         DS   0H\nRVOL_ECL EQU  *-RVOL_EC\n*\n         MVI   PRR_LC,99                  Start on new page\n         LA    R1,C_STVL\n         ST    R1,PRR_TITLE               Set title\n         BAS   R14,CLEAR_RH               Clear Report headings\n*\n         LA    R15,W_RH2+1                Locate work heading 2\n         MVC   DLR_VOLS-DLR(6,R15),=C'Volume'\n         TM    PPC_FLAG1,$PPC_F1CATC\n         BNO   RV$NC1X\n         MVC   DLR_CAT-1-DLR(3,R15),=C'NOT'\nRV$NC1X  DS    0H\n         MVC   DLR_CDATE-DLR(24,R15),=C'-------- Dates ----------'\n*        MVC   DLR_ATYPE-DLR(23,R15),=C'----- Allocation ------'\n*\n         LA    R15,W_RH3+1                Locate work heading 2\n         MVC   DLR_DSN-DLR(13,R15),=C'Data Set Name'\n         MVC   DLR_VOLS-DLR(6,R15),=C'Serial'\n         TM    PPC_FLAG1,$PPC_F1CATC\n         BNO   RV$NC2X\n         MVC   DLR_CAT-1-DLR(3,R15),=C'CAT'\nRV$NC2X  DS    0H\n         MVC   DLR_DSORG-DLR(5,R15),=C'DSORG'\n         MVC   DLR_RECFM-DLR(5,R15),=C'RECFM'\n         MVC   DLR_LRECL-DLR(5,R15),=C'LRECL'\n         MVC   DLR_BLKSIZE-DLR(5,R15),=C'BLKSZ'\n         MVC   DLR_CDATE-DLR(7,R15),=C'Created'\n         MVC   DLR_UDATE-DLR(8,R15),=C'Last Ref'\n*        MVC   DLR_ATYPE-DLR(4,R15),=C'Type'\n*        MVC   DLR_SEC-DLR(5,R15),=C' Prim'\n*        MVC   DLR_PRI-DLR(5,R15),=C'  Sec'\n*        MVC   DLR_USED-DLR(5,R15),=C' Used'\n         MVC   DLR_SMS-DLR(3,R15),=C'SMS'\n*\n         LA    R15,W_RH4                  Locate work heading 2\n         MVI   0(R15),C'-'                Get Blank\n         MVC   1(133-1,R15),0(R15)        ..Propagate it\n         MVI   0(R15),C' '                Get Blank\n         BSM   0,R9\n         LTORG ,\n         DS    0D\n         DROP  R8\n         EJECT\n***********************************************************************\n***                                                                 ***\n**           Dynamically Allocate volume                             **\n**                                                                   **\n**     Input: R14 - Unit literal                                     **\n**            R15 - Volume Serial literal                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDRU$ALCV CSECT ,\nDRU$ALCV AMODE 24\nDRU$ALCV RMODE 24\n         USING DRU$ALCV,R8                Set base register for CSECT\n*\n** Standard O/S eyecatcher\n*\nALCV_EC  B    ALCV_ECL(0,R8)            Bump past EyeCatcher\n         DC   AL1(L'ALCV_ECV)           Length of eyecatcher\nALCV_ECV DC   C'DRU$ALCV -- Dynamically Allcoate Volume'\n         DS   0H\nALCV_ECL EQU  *-ALCV_EC\n*\n         STM   R14,R15,DOUBLE2+4          Save address of unit & Volume\n*\n** Format pointers\n*\n         SPACE 1\n         LA    R4,HEADREC                 Get address of work area\n         ST    R4,DOUBLE                  Save address\n         OI    DOUBLE,S99RBPND            Indicate last one\n         XC    0(S99RBEND-S99RB,R4),0(R4) Clear Request Block area\n         MVI   S99RBLN-S99RB(R4),S99RBEND-S99RB Length of REQUEST BLK\n         LA    R5,S99RBEND-S99RB(R4)      Locate Text Units Pointers\n         ST    R5,S99TXTPP-S99RB(R4)      STORE ADDR OF Text Unit PTRs\n         LA    R6,20(R5)    5*4=20        Bump past Text pointers\n         MVI   S99VERB-S99RB(R4),S99VRBAL    Verb = ALLOCATE\n***                                                               ***\n*** The address of each of the text Units will be stored in the   ***\n*** request block text PTR area as they are being defined,        ***\n*** Active registers are: R5 - Address in text unit pointers      ***\n***                       R6 - Address in text unit define area   ***\n***                                                               ***\n         SPACE 2\n***-(1)---------------------------------- DDNAME=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALRTDDN                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,8                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         LA    R1,S99TUPAR-S99TUNIT(R6)     Locate DDNAME\n         ST    R1,DOUBLE2                   Save Addr: Returned DDNAME\n*\n         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit\n***-(2)---------------------------------- DISP=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALSTATS                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,1                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVI   S99TUPAR-S99TUNIT(R6),8      DISP=SHR\n*\n         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit\n***-(3)---------------------------------- UNIT=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALUNIT                  Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,8                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         L     R1,DOUBLE2+4                 Get address of Unit\n         MVC   S99TUPAR-S99TUNIT(8,R6),0(R1) Save unit\n*\n         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit\n***-(4)---------------------------------- DSN=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALDSNAM                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,12                       Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVC   S99TUPAR-S99TUNIT(12,R6),=C'FORMAT4.DSCB'\n*\n         LA    R6,S99TUPAR-S99TUNIT+12(R6)  Bump past this Text Unit\n***-(5,LAST)----------------------------- VOLUME=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication\n*\n         LA    R14,DALVLSER                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,6                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         L     R1,DOUBLE2+8                 Get address of volume\n         MVC   S99TUPAR-S99TUNIT(6,R6),0(R1)\n***-------------------------------------- Complete and make request\n         LA    R1,DOUBLE                  Get address of Request BLK\n         DYNALLOC ,                       Invoke SVC 99\nAV$X     EQU   *\n         BSM   0,R9                       Return to caller\n         LTORG ,\n         DS    0D\n         DROP  R8\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Reset headings for Operations report                       **\n** Input: R1 - points to 12 byte literal for Status line literal\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDRU$ROPR CSECT ,\nDRU$ROPR AMODE 24\nDRU$ROPR RMODE 24\n         USING DRU$ROPR,R8                Set base register for CSECT\n*\n** Standard O/S eyecatcher\n*\nRPOR_EC  B    RPOR_ECL(0,R8)            Bump past EyeCatcher\n         DC   AL1(L'RPOR_ECV)           Length of eyecatcher\nRPOR_ECV DC   C'DRU$RPOR -- Reset headings for operations report'\n         DS   0H\nRPOR_ECL EQU  *-RPOR_EC\n*\n         ST    R1,PRR_STITLE              Set subtitle\n         MVI   PRR_LC,99                  Start on new page\n         BAS   R14,CLEAR_RH               Clear Report headings\n*\n** Format Report Heading 2\n*\n         LA    R15,W_RH2\n         MVC   OR_VOLS-OR(6,R15),=C'Volume'\n         MVC   OR_DEVT-OR(6,R15),=C'Device'\n         MVC   OR_VMNT-OR-1(6,R15),=C'VATLST'\n         MVC   OR_SMNT-OR(3,R15),=C'UCB'\n         MVC   OR_TRKS-OR(26,R15),=C'--------- Tracks ---------'\n         MVC   OR_VTOC-OR(18,R15),=C'------ VTOC ------'\n*\n** Format Report Heading 3\n*\n         LA    R15,W_RH3\n         MVC   OR_UCB-OR(3,R15),=C'UCB'\n         MVC   OR_VOLS-OR(6,R15),=C'Serial'\n         MVC   OR_DEVT-OR(4,R15),=C'Type'\n         MVC   OR_VMNT-OR(3,R15),=C'MNT'\n         MVC   OR_SMNT-OR(3,R15),=C'MNT'\n         MVC   OR_FTRKS-OR(10,R15),=C'      Free'\n         MVC   OR_TTRKS-OR(10,R15),=C'     Total'\n         MVC   OR_VTOCP-OR(4,R15),=C'Used'\n         MVI   OR_IVTOC-OR(R15),C'I'\n         MVC   OR_VTOCT-OR(4,R15),=C'Size'\n         MVC   OR_VTOCF-OR(4,R15),=C'DSCB'\n         MVC   OR_DESC-OR(23,R15),=C'Description from VATLST'\n*\n** Format Report Heading line 4\n*\n         LA    R15,W_RH4\n         MVI   0(R15),C'-'\n         MVC   1(L'W_RH4-1,R15),0(R15)\n         MVI   0(R15),C' '                Fix FBA byte\n*\n** Return to caller\n*\n         BSM   0,R9\n*\n** Data Constants\n*\n         LTORG ,\n         DS    0D\n         DROP  R8\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Parse parameter card                                        **\n**                                                                   **\n**       Note: This has been moved to a seperate CSECT to save       **\n**             data area in main CSECT.                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDRU$PPC  CSECT ,\nDRU$PPC  AMODE 31\nDRU$PPC  RMODE ANY\n         USING DRU$PPC,R8                 Set base register for CSECT\n*\n** Standard O/S eyecatcher\n*\nPPC_EC   B    PPC_ECL(0,R8)             Bump past EyeCatcher\n         DC   AL1(L'PPC_ECV)            Length of eyecatcher\nPPC_ECV DC    C'DRU$PPC  -- Parse Parameter Card'\n         DS   0H\nPPC_ECL EQU   *-PPC_EC\n*\n         ST    R9,PPC_RA                  Save Return Address\n         SPACE 2\nPARSE_PARAMETER_CARD EQU *\n*\n** Set defaults\n*\n         MVI   PPC_VPREFIXL,$PPC_NOCHK    All volumes\n*\n** See what register 1 has on input to this program\n*\n         EREG  R1,R1                      Get CPPL/parameter address\n         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?\n         BNO   PPC$NC                     No, need to look at CBUF\n*\n** We were called, it has a Batch type (EXEC) parameter\n*\n         L     R7,0(R1)                   Get address of parm\n         SLR   R6,R6                      Clear register\n         ICM   R6,B'0011',0(R7)           Get length of parm\n         BZ    PPC$X                      None, leave\n         LA    R7,2(R7)                   Bump past parm length HW\n         B     PPC$PARSE                  Parse the input\n*\n** We were not called, we are a \"TSO Command Processor\"\n*\nPPC$NC   EQU   *\n         L     R7,CPPLCBUF-CPPL(R1)       Locate Command Buffer\n         SLR   R6,R6                      Clear register\n         ICM   R6,B'0011',0(R7)           Get total CBUF length\n         SLR   R0,R0                      Clear register\n         ICM   R0,B'0011',2(R7)           Get total Command name length\n         LA    R15,4                      Length of header\n         AR    R7,R15                     Bump past header\n         SR    R6,R15                     Decrement for header length\n         AR    R7,R0                      Bump past Command length\n         SR    R6,R0                      Length of data\n*\n** Look thru command buffer/parameter for our commands\n** Input: R7 - Address of command-buffer/Parameter\n**        R6 - Length of command-buffer/Parameter\n*\nPPC$PARSE EQU *\n         STM   R6,R7,PPC_CB               Save length and address\n         B     PPC$DLMX                   Test first parameter\nPPC$PRMM MVC   0(0,R15),0(R7)             Get parameter\nPPC$FLC  CLC   TPF_NAME-TPF(0,R2),0(R7)\n*\n** Test for valid delimiter between operands\n*\nPPC$DLM  EQU   *\n         CLI   0(R7),C' '                 Valid delimiter?\n         BE    PPC$DLMS                   Yes, continue\n         CLI   0(R7),C','                 Valid delimiter?\n         BNE   PPC$OERR                   No, print error message\nPPC$DLMS EQU   *\n         LA    R7,1(R7)                   Bump past delimiter\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      End?\n         BZ    PPC$END                    Yes, continue\nPPC$DLMX EQU   *\n*\n** Process keywords into program flags. Generate an OI instruction to\n** turn on flag:\n**\n** OI   PPC_FLAG1,$PPC_F1XDUMP    -   If PARM=HEXDUMP\n*\n         LA    R3,T_PFLAGSN               Get number of entries\n         LA    R2,T_PFLAGS                Locate flag table\nPPC$FL   EQU   *\n         SLR   R14,R14                    Clear register\n         IC    R14,TPF_NAMEL-TPF(R2)      Get length of operand\n         CR    R14,R6                     Room in parse area for flag?\n         BH    PPC$FLB                    No, continue\n         EX    R14,PPC$FLC                Match?\n         BE    PPC$FLX                    Yes, continue\nPPC$FLB  EQU   *\n         LA    R2,TPFL(R2)                Bump to next entry\n         BCT   R3,PPC$FL                  ..Process it\n         B     PPC$FX                     Continue: not a flag\nPPC$FOI  OI    *-*,4\nPPC$FLX  EQU   *\n         MVC   DOUBLE(4),PPC$FOI          Get Instruction\n         MVC   DOUBLE+1(1),TPF_FLAG-TPF(R2)    Set flag\n         MVC   DOUBLE+2(2),TPF_OFFSET-TPF(R2) Get offset\n         OI    DOUBLE+2,X'D0'             Register 13/DSA\n*The next few instructions can be uncommented and run for debugging\n*MVC WTOMSG+8+10(8),TPF_NAME-TPF(R2)\n*UNPK WTOMSG+8+19(9),DOUBLE(5)\n*MVZ  WTOMSG+8+19(8),ZEROS\n*TR   WTOMSG+8+19(8),HEXTABLE\n*MVI  WTOMSG+8+19+8,C'='\n*WTOMSG WTO 'R$PDSANL: xxxxxxxx xxxxxxxx=Instruction'\n         LA    R15,0                      Set up for EX\n         EX    R15,DOUBLE                 Execute: OI field,flag\n         LA    R14,1(R14)                 Increment after EX\n         AR    R7,R14                     Bump past known length\n         SR    R6,R14                     Subtract from total\n         LTR   R6,R6                      Check out length\n         BZ    PPC$X                      Zero, leave\n         BM    PPC$X                      Zero, leave\nPPC$FLDL EQU   *\n         CLI   0(R7),C' '                 Valid Delimiter?\n         BE    PPC$DLMS\n         CLI   0(R7),C','                 Valid Delimiter?\n         BE    PPC$DLMS\n         LA    R7,1(R7)                   Bump past extra byte\n         BCT   R6,PPC$FLDL                Process next one\n         B     PPC$X                      End of the Parameter string\nPPC$FX   EQU   *\n*\n** Volume prefix\n*\nPPC$VOLP EQU   *\n         CLC   0(7,R7),=C'VOLUME='\n         BNE   PPC$VOLPX\n         LA    R7,7(R7)                   Bump past \"VOLUME=\"\n         SH    R6,=H'7'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,PPC_VPREFIX             Locate output\n         MVI   0(R1),C' '\n         MVC   1(L'PPC_VPREFIX-1,R1),0(R1)\n         LA    R14,8                      Set max\n         SLR   R15,R15                    Set count\nPPC$VOLPL EQU  *\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         LA    R15,1(R15)                 Increment count\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$VOLPLX                 Yes, continue\n         CLI   0(R7),C','                 Found delimiter?\n         BE    PPC$VOLPLX                 Yes, leave\n         BCT   R6,PPC$VOLPL               Process next byte\nPPC$VOLPLX EQU *\n         BCTR  R15,0                      Decrement for later\n**\n         LA    R14,PPC_VPREFIX            Locate start of VOLPname\n         AR    R14,R15                    Locate last character\n         CLI   0(R14),C'*'                Generic?\n         BE    PPC$VOLPG                  Yes, continue\n         CLI   0(R14),C'/'                Generic?\n         BNE   PPC$VOLPGX                 No, continue\nPPC$VOLPG EQU  *\n         BCTR  R15,0                      Decrement for generic byte\n         MVI   0(R14),C' '                Not so fast, Louie\nPPC$VOLPGX EQU *\n**\n         STC   R15,PPC_VPREFIXL           Save count\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$VOLPX EQU  *\n*\n** Parameter in error: isolate it, note position and continue\n*\nPPC$OERR EQU   *\n         SLR   R1,R1                      CLEAR OUT REGISTER\n         ICM   R1,B'0011',PPC_COL         GET PREVIOUS PARM ERR COLUMN\n         BNZ   PPC$GNUM                   YES, GO INCREMENT NUMBER\n         EREG  R1,R1                      GET ADDR OF ADDR OF PARM\n         L     R1,0(R1)                   NOW GET ADDRESS OF PARM\n         LH    R1,0(R1)                   GET LENGTH OF PARM\n         SR    R1,R6                      SUBTRACT FROM CURRENT LOC\n         LA    R1,1(R1)                   Make offset from 1 not zero\n         STH   R1,PPC_COL                 SAVE LOCATION OF ERROR\nPPC$GNUM EQU   *\n         LH    R1,PPC_NUM                 GET NUMBER OF ERRORS IN PARM\n         LA    R1,1(R1)                   INCREMENT BY 1\n         STH   R1,PPC_NUM                 SAVE FOR LATER\nPPC$RR   EQU   *\n         CLI   0(R7),C','                 HIT A COMMA YET?\n         BE    PPC$BRK                    YES, LEAVE\n         LA    R7,1(R7)                   BUMP TO NEXT BYTE\n         BCT   R6,PPC$RR                  TEST IT OUT\n         B     PPC$END                    END OF PARMS...\nPPC$BRK  EQU   *\n         LA    R7,1(R7)                   BUMP PAST COMMA\n         LTR   R6,R6                      TEST FOR ZERO LENGTH\n         BZ    PPC$END                    YES, END RIGTH NOW\n         BCT   R6,PPC$DLMX                NO, Let's test some more\n*\n** End of parameters found\n*\nPPC$END  EQU   *\n*\n** Common Exit from Parse_Parameter_Card\n*\nPPC$X    EQU   *\n         L     R9,PPC_RA                  Get return address\n         BSM   0,R9                       Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Constants                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LTORG ,                          Literals\n*\n** Parse flags (mapped by TPF DSECT)\n*\nT_PFLAGS EQU   *\n         DC   AL1($PPC_F1VERB,4-1),CL8'VERBOSE ',AL2(PPC_FLAG1-DSA)\n         DC    AL1($PPC_F1PSM,6-1),CL8'PRTSORTM',AL2(PPC_FLAG1-DSA)\n         DC    AL1($PPC_F1PSM,3-1),CL8'PSM     ',AL2(PPC_FLAG1-DSA)\n         DC    AL1($PPC_F1PSM,3-1),CL8'PRTSMSG ',AL2(PPC_FLAG1-DSA)\n         DC   AL1($PPC_F1RUCB,6-1),CL8'RPTBYUCB',AL2(PPC_FLAG1-DSA)\n         DC  AL1($PPC_F1RBOTH,5-1),CL8'RPTBOTH ',AL2(PPC_FLAG1-DSA)\n         DC  AL1($PPC_F1SMSMC,5-1),CL8'SMSMCHK ',AL2(PPC_FLAG1-DSA)\n         DC   AL1($PPC_F1CATC,4-1),CL8'CATCHK  ',AL2(PPC_FLAG1-DSA)\n         DC   AL1($PPC_F1RDSN,6-1),CL8'RPTBYDSN',AL2(PPC_FLAG1-DSA)\n         DC  AL1($PPC_F2DEBUG,5-1),CL8'DEBUG   ',AL2(PPC_FLAG2-DSA)\n         DC  AL1($PPC_F2NAUTH,6-1),CL8'NOAUTH  ',AL2(PPC_FLAG2-DSA)\n         DC  AL1($PPC_F2NAUTH,5-1),CL8'NAUTH   ',AL2(PPC_FLAG2-DSA)\n         DC  AL1($PPC_F2CVTUS,5-1),CL8'CVTUCBSC',AL2(PPC_FLAG2-DSA)\n         DC    AL1($PPC_F2ORU,8-1),CL8'ONLYRECU',AL2(PPC_FLAG2-DSA)\n         DC    AL1($PPC_F2OLL,8-1),CL8'ONLYLLIB',AL2(PPC_FLAG2-DSA)\n         DC     AL1($PPC_F2DO,8-1),CL8'DATAONLY',AL2(PPC_FLAG2-DSA)\n         DC   AL1($PPC_F2HELP,4-1),CL8'HELP    ',AL2(PPC_FLAG2-DSA)\n         DC  AL1($PPC_F2NOPIC,4-1),CL8'NOPIC   ',AL2(PPC_FLAG2-DSA)\n         DC  AL1($PPC_F3NSYSP,4-1),CL8'NOSYSP  ',AL2(PPC_FLAG3-DSA)\nT_PFLAGSN EQU   (*-T_PFLAGS)/TPFL\n         DS    0D                         End CSECT on double word\n*\n** Calculate length of module\n*\n#DRU$PPC EQU   *-DRU$PPC\n#DRU$PPC_LEFT EQU 4096-#DRU$PPC\n         DROP  R8                         Drop base of DRU$PPC\n*\n** T_PFLAG mapping\n*\nTPF           DSECT ,\nTPF_FLAG      DS    X                     Flag value\nTPF_NAMEL     DS    X                     Name length\nTPF_NAME      DS    CL8                   Name value\nTPF_OFFSET    DS    XL2                   Offset to field in DSA\nTPFL          EQU   *-TPF\n         DROP  R13,R12,R11,R10\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       ESTAE routine - Handle ABENDs while processing              **\n**                                                                   **\n**              \\\\//////      ________________                       **\n**              \\\\    |      /                \\                      **\n**              \\(_  x|     /  Bloooeeahhh!!! |                      **\n**              \\    __)  _/__________________/                      **\n**            __/   _\\ ,. .                                          **\n**           /     /  .%:. * .                                       **\n**          |  |   |   . ;>, $  '                                    **\n**          |  |   |    .=.~@ .  &                                   **\n**          UUUU---|   :?. ;. .\u00ac#  .   \u00ac                             **\n**          |      |    < * '   .   ,  *                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT GEN\nDRU$ESTA CSECT ,\nDRU$ESTA AMODE 31\nDRU$ESTA RMODE ANY\n*\n** Standard O/S eyecatcher\n*\nEST_EC   B     EST_ECL(0,R15)           Bump past EyeCatcher\n         DC    AL1(EST_ECE-EST_ECV)     Length of Eyecatcher\nEST_ECV  DC    C'DRU$ESTA -- ESTAE routine'\nEST_ECE  EQU   *\n         DS    0H\nEST_ECL  EQU   *-EST_EC\n*\n** Standard ESA entry housekeeping\n*\n         BAKR  R14,0                    Save regs\n         LAE   R12,0(R15,0)             Get base register\n         USING DRU$ESTA,R12             Get addressibility\n         SAC   0\n         SYSSTATE ASCENV=P\n*\n** Register input parameters\n** R0 - Code:\n**      - 0  ... Active I/O has be Quiesced and is restorable\n**      - 4  ... Active I/O has been halted and is not restorable\n**      - 8  ... No active I/O at ABEND Time\n**      - 12 ... an SDWA was not obtained\n**      - 16 ... No I/O processing was performed\n** R1 - IF R0 \u00ac= 12 THEN it has SDWA ELSE ABEND code\n*\n         CH    R0,=H'12'                  SDWA present?\n         BE    RSE$X                      No, just leave\n         LR    R2,R1                      Save SDWA address\n*\n** Perform retry if possible\n*\n         L     R4,SDWAPARM-SDWA(R2)       Locate RSEP\n         SLR   R3,R3                      Clear register\n         ICM   R3,B'0011',RSEP_RETRYO-RSEP(R4) Get retry address\n         BZ    RSE$X                      Not there, give up\n         A     R3,RSEP_R12-RSEP(R4)       Locate to routine\n         MVC   SDWASR12-SDWA(4,R2),RSEP_R12-RSEP(R4)\n         MVC   SDWASR11-SDWA(4,R2),RSEP_R11-RSEP(R4)\n         MVC   SDWASR10-SDWA(4,R2),RSEP_R10-RSEP(R4)\n*\n         L     R1,=V(DRU$CON1)\n         MVC   RSEP_WTO-RSEP(C_WTOL,R4),C_WTO-DRU$CON1(R1)\n         LA    R15,RSEP_WTO+4-RSEP(R4)\n         MVC   0(MSG26L,R15),MSG26-DRU$CON1(R1)\n         MVC   MSG26UCB-MSG26(4,R15),RSEP_UCB-RSEP(R4)\n         MVC   MSG26VOL-MSG26(6,R15),RSEP_VOL-RSEP(R4)\n         MVC   MSG26ID-MSG26(8,R15),RSEP_FUNC-RSEP(R4)\n         LA    R1,RSEP_WTO-RSEP(R4)\n         WTO   ,MF=(E,(1))                Issue WTO\n*\n         SETRP WKAREA=(2),                Set Return Parameters        @\n               RETADDR=(3),               ..Return Address             @\n               RETREGS=YES,               ..Reset regs using SDWASRSV  @\n               RC=4                       ..Retry using RETADDR\n*\n** Return to RTM emtpy handed - No recovery is being attempted\n*\nRSE$X    DS    0H\n         PR    ,                          ESA exit housekeeping instr.\n*\n** Constants\n*\n         LTORG ,                          Literals\n         DS    0D                         End CSECT on double word\n         DROP  R12\n         EJECT\n***********************************************************************\n***\n**   Print Report Record\n***\n***********************************************************************\n         SPACE 2\nDRU$PRR  CSECT ,\nDRU$PRR  AMODE 24\nDRU$PRR  RMODE 24\n*\n** Standard O/S eyecatcher\n*\nPRR_EC   B    PRR_ECL(0,R15)              Bump past EyeCatcher\n         DC   AL1(L'PRR_ECV)              Length of eyecatcher\nPRR_ECV  DC   C'DRU$PRR  -- Print Report Record'\n         DS   0H\nPRR_ECL  EQU  *-PRR_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING DRU$PRR,R12                Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R0                     Save input RSA\n         LR    R10,R1                     Save input record address\n         USING PRRRSA,R13\n*\n** Checking\n*\n         TM    PPC_FLAG2,$PPC_F2DO        Dataonly?\n         BO    PRR$HP                     Yes, skip heading lines\nPRR$VRCX DS    0H\n         CLI   PRR_LC,47\n         BNH   PRR$HX\n*-Need a new heading, update the time and date\n         L     R1,=V(DRU$CON1)\n         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8-DRU$CON1(R1)\n         MVC   W_ODDOW9(C_ODDOW9L),C_ODDOW9-DRU$CON1(R1)\n         MVC   W_ODGEUR11(C_ODGEUR11L),C_ODGEUR11-DRU$CON1(R1)\n         MVC   W_OTIMES8(C_OTIMES8L),C_OTIMES8-DRU$CON1(R1)\n         DA#SMODE 31\n         ICM   R15,B'1111',EP_DA$DATE\n         CALL  (15),                                                   @\n               (W_ODGEUR11,W_OTIMES8,W_ODJUL8,W_ODDOW9),               @\n               VL,MF=(E,PARMLIST)\n         DA#SMODE 31\n*-Format the report heading\n*\n         BAS   R14,PRR$CLEAR_HEADREC\n         MVI   0(R15),C'1'\n         LA    R15,HEADREC+(133/2)        Locate middle of record\n         L     R1,PRR_TITLE               Get title\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R1)                  Get centering\n         SR    R15,R14                    Backup to center this guy\n         SLR   R14,R14                    Clear register\n         IC    R14,1(R1)                  Get length of string\n         EX    R14,PRR$MOVE               Move string to record\n         PUT   REPORT,HEADREC\n*\n         BAS   R14,PRR$CLEAR_HEADREC\n         MVI   0(R15),C'0'\n         LA    R15,HEADREC+(133/2)        Locate middle of record\n         ICM   R1,B'1111',PRR_STITLE      Get subtitle\n         BZ    PRR$STX\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R1)                  Get centering\n         SR    R15,R14                    Backup to center this guy\n         SLR   R14,R14                    Clear register\n         IC    R14,1(R1)                  Get length of string\n         EX    R14,PRR$MOVE               Move string to record\n         PUT   REPORT,HEADREC\nPRR$STX  EQU   *\n*\n         BAS   R14,PRR$CLEAR_HEADREC\n         MVI   0(R15),C'0'\n         MVC   1(8,R15),=CL8'DA$DISKR'    Get program name\n         MVC   1+8+1(6,R15),C_SYSID-DRU$CON1(R1)\n         L     R14,CVTPTR                 ->  CVT\n         MVC   1+8+1+6+1(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R14)\n         MVC   125(4,R15),=CL4'Page'      Insert text\n         L     R1,PRR_PC                  GET PAGE COUNT\n         LA    R1,1(R1)                   INCREMENT\n         ST    R1,PRR_PC                  SAVE IT\n         CVD   R1,DOUBLE                  CONVERT TO PACKED DEC\n         MVC   129(4,R15),=X'40,20,20,20' GET EDIT PATTERN\n         ED    129(4,R15),DOUBLE+6        EDIT TO ZONED\n         PUT   REPORT,HEADREC\n*\n         BAS   R14,PRR$CLEAR_HEADREC\n         MVC   1(11,R15),W_ODGEUR11_STR\n*        MVC   1+11+1(9,R15),W_ODDOW9_STR\n         MVC   116(8,R15),W_ODJUL8_STR\n         MVC   125(8,R15),W_OTIMES8_STR\n         PUT   REPORT,HEADREC\n*\n         BAS   R14,PRR$CLEAR_HEADREC\n         PUT   REPORT,HEADREC\n         PUT   REPORT,W_RH2\n         PUT   REPORT,W_RH3\n         PUT   REPORT,W_RH4\n         MVI   PRR_LC,0\nPRR$HX   EQU   *\n         SLR   R1,R1\n         IC    R1,PRR_LC                  Get line count\n         BAS   R14,PRR$INC_LC             Increment line count\n         STC   R1,PRR_LC                  Save line count\nPRR$HP   EQU   *\n         PUT   REPORT,RECOUT              Print record\n*\n** Exit\n*\n         SLR   R15,R15\n         PR    ,                          Return to caller\n*\nPRR$MOVE MVC   0(0,R15),2(R1)             ** Executed **\n*\n** Increment line count\n*\nPRR$INC_LC EQU *\n         CLI   0(R10),C'+'\n         BE    PRR$ILCX\n         CLI   0(R10),C'-'\n         BE    PRR$ILC3\n         CLI   0(R10),C'0'\n         BE    PRR$ILC2\n         B     PRR$ILC1\nPRR$ILC3 EQU   *\n         LA    R1,1(R1)\nPRR$ILC2 EQU   *\n         LA    R1,1(R1)\nPRR$ILC1 EQU   *\n         LA    R1,1(R1)\nPRR$ILCX EQU   *\n         BSM   0,R14\n*\n** Clear heading record to blanks\n*\nPRR$CLEAR_HEADREC EQU *\n         LA    R15,HEADREC                Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it\n         L     R1,=V(DRU$CON1)            -> Constants CSECTs\n         BSM   0,R14                      Return to caller\n*\n** Literals and end of DRU$PRR routine\n*\n         LTORG ,                          Literals in DRU$PRR\n         DS    0D                         End of DRU$PRR\n         DROP  R12\n         DROP  R13\n         EJECT\n***********************************************************************\n***\n**   Print SYSPRINT Record\n***\n***********************************************************************\n         SPACE 2\nDRU$PSR  CSECT ,\nDRU$PSR  AMODE 24\nDRU$PSR  RMODE 24\n*\n** Standard O/S eyecatcher\n*\nPSR_EC   B    PSR_ECL(0,R15)              Bump past EyeCatcher\n         DC   AL1(L'PSR_ECV)              Length of eyecatcher\nPSR_ECV  DC   C'DRU$PSR  -- Print SYSPRINT Record'\n         DS   0H\nPSR_ECL  EQU  *-PSR_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING DRU$PSR,R12                Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R0                     Save input RSA\n         LR    R10,R1                     Save input record address\n         USING PSRRSA,R13\n*\n** Heading needed?\n*\n         CLI   PSR_LC,50\n         BNH   PSR$HX\n*-Need a new heading, update the time and date\n         L     R1,=V(DRU$CON1)\n         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8-DRU$CON1(R1)\n         MVC   W_ODDOW9(C_ODDOW9L),C_ODDOW9-DRU$CON1(R1)\n         MVC   W_ODGEUR11(C_ODGEUR11L),C_ODGEUR11-DRU$CON1(R1)\n         MVC   W_OTIMES8(C_OTIMES8L),C_OTIMES8-DRU$CON1(R1)\n         DA#SMODE 31\n         ICM   R15,B'1111',EP_DA$DATE\n         CALL  (15),                                                   @\n               (W_ODGEUR11,W_OTIMES8,W_ODJUL8,W_ODDOW9),               @\n               VL,MF=(E,PARMLIST)\n         DA#SMODE 31\n*-Format the report heading\n         BAS   R14,PSR$CLEAR_HEADREC\n         MVI   0(R15),C'1'\n         MVC   59(L'C_MSGS,R15),C_MSGS-DRU$CON1(R1)\n         PUT   SYSPRINT,HEADREC\n*\n         BAS   R14,PSR$CLEAR_HEADREC\n         MVI   0(R15),C'0'\n         MVC   1(8,R15),=CL8'DA$DISKR'    Get program name\n         MVC   1+8+1(6,R15),C_SYSID-DRU$CON1(R1)\n         L     R14,CVTPTR                 ->  CVT\n         MVC   1+8+1+6+1(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R14)\n         MVC   125(4,R15),=CL4'Page'      Insert text\n         L     R1,PSR_PC                  GET PAGE COUNT\n         LA    R1,1(R1)                   INCREMENT\n         ST    R1,PSR_PC                  SAVE IT\n         CVD   R1,DOUBLE                  CONVERT TO PACKED DEC\n         MVC   129(4,R15),=X'40,20,20,20' GET EDIT PATTERN\n         ED    129(4,R15),DOUBLE+6        EDIT TO ZONED\n         PUT   SYSPRINT,HEADREC\n*\n         BAS   R14,PSR$CLEAR_HEADREC\n         MVC   1(11,R15),W_ODGEUR11_STR\n*        MVC   1+11+1(9,R15),W_ODDOW9_STR\n         MVC   116(8,R15),W_ODJUL8_STR\n         MVC   125(8,R15),W_OTIMES8_STR\n         PUT   SYSPRINT,HEADREC\n*\n         BAS   R14,PSR$CLEAR_HEADREC\n         PUT   SYSPRINT,HEADREC\n         MVI   PSR_LC,0\nPSR$HX   EQU   *\n*-Print the detail line\n         SLR   R1,R1\n         IC    R1,PSR_LC                  Get line count\n         BAS   R14,PSR$INC_LC             Increment line count\n         STC   R1,PSR_LC                  Save line count\n         PUT   SYSPRINT,RECOUT            Print record\n*\n** Exit\n*\n         SLR   R15,R15\n         PR    ,                          Return to caller\n*\n** Increment line count\n*\nPSR$INC_LC EQU *\n         CLI   0(R10),C'+'\n         BE    PSR$ILCX\n         CLI   0(R10),C'-'\n         BE    PSR$ILC3\n         CLI   0(R10),C'0'\n         BE    PSR$ILC2\n         B     PSR$ILC1\nPSR$ILC3 EQU   *\n         LA    R1,1(R1)\nPSR$ILC2 EQU   *\n         LA    R1,1(R1)\nPSR$ILC1 EQU   *\n         LA    R1,1(R1)\nPSR$ILCX EQU   *\n         BSM   0,R14\n*\n** Clear heading record to blanks\n*\nPSR$CLEAR_HEADREC EQU *\n         LA    R15,HEADREC                Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'HEADREC-1,R15),0(R15) ..Propagate it\n         L     R1,=V(DRU$CON1)            -> Constants CSECTs\n         BSM   0,R14                      Return to caller\n*\n** Literals and end of DRU$PSR routine\n*\n         LTORG ,                          Literals in DRU$PSR\n         DS    0D                         End of DRU$PSR\n         DROP  R12\n         DROP  R13\n         EJECT\n***********************************************************************\n***\n**   Print System Profile at beginning of //REPORT\n**\n**-------------------------  System Profile  -------------------------*\n*|                                                                    |\n*|  O/S----------------MVS SP4.3.0    FMID-------------------JBBxxxx  |\n*|  O/S------------OS/390_01.02.00    FMID-------------------JBB6602  |\n*|  DF/SMS-------------------1.3.0    DFP----------------------3.3.2  |\n*|  System Name---------------XYZ1    SMF ID--------------------XYZ1  |\n*|                                                                    |\n**--------------------------------------------------------------------*\n***\n***********************************************************************\n         SPACE 2\n*\n** \"System Profile\" equates\n*\n@START   EQU   32                         ..STARTING LOCATION ON LINE\n@TEXT1   EQU   @START+3                   ..TEXT LOCATION 1\n@VALUE1E EQU   @START+33                  ..VALUE LOCATION END 1\n@TEXT2   EQU   @START+37                  ..TEXT LOCATION 2\n@VALUE2E EQU   @START+67                  ..VALUE LOCATION END 2\n*\n** Start of CSECT\n*\nDRU$SYSP CSECT ,\nDRU$SYSP AMODE 24\nDRU$SYSP RMODE 24\n*\n** Standard O/S eyecatcher\n*\nSYSP_EC  B    SYSP_ECL(0,R15)             Bump past EyeCatcher\n         DC   AL1(L'SYSP_ECV)             Length of eyecatcher\nSYSP_ECV DC   C'DRU$SYSP -- Print System Profile'\n         DS   0H\nSYSP_ECL EQU  *-SYSP_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING DRU$SYSP,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R0                     Save input RSA\n         LR    R10,R1                     Save input record address\n         USING SUBRSA,R13\n*\n** Print \"DASD CONFIG\" in big letters\n*\n         LA    R1,W_RH2\n         MVI   0(R1),C' '\n         MVI   1(R1),C'*'\n         MVC   2(132-1,R1),1(R1)\n         LA    R1,W_RH3\n         MVI   0(R1),C' '\n         MVC   1(133-1,R1),0(R1)\n         LA    R1,W_RH4\n         MVI   0(R1),C' '\n         MVC   1(133-1,R1),0(R1)\n         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n         L     R14,=V(DRU$CON1)\n         LA    R1,C_BLDC1-DRU$CON1(R14)    Locate string\n         LA    R0,BLETRSA\n         L     R15,=V(DRU$BLET)\n         BASR  R14,R15\n*\n         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n         L     R14,=V(DRU$CON1)\n         LA    R1,C_BLDC2-DRU$CON1(R14)    Locate string\n         LA    R0,BLETRSA\n         L     R15,=V(DRU$BLET)\n         BASR  R14,R15\n*\n         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout to blanks\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n         MVI   RECOUT,C'*'                Get star\n         MVC   RECOUT+1(132),RECOUT       ..Propagate it\n         MVI   RECOUT,C' '                Set FBA byte\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** Skip a couple of lines\n*\n         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout\n         MVI   RECOUT,C'0'                Skip a couple of lines\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** PRINT \" *-------------  System Profile  --------------*\"\n*\n         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout to blanks\n         MVI   RECOUT,C'-'                FBA: skip 3 lines\n         LA    R15,RECOUT+@START          LOCATE PAST FBA BYTE\n         MVC   0(2,R15),=C'*-'            CORNER\n         LA    R15,1(R15)                 BUMP PAST IT\n         MVC   1(24,R15),0(R15)           PROPAGATE DASH\n         LA    R15,25+2(R15)              BUMP PAST DASHES\n         MVC   0(14,R15),=C'System Profile' BOX TITLE\n         LA    R15,14+2(R15)              BUMP PAST BOX TITLE\n         MVI   0(R15),C'-'                GET DASH\n         MVC   1(24,R15),0(R15)           PROPAGATE DASHES\n         LA    R15,25(R15)                BUMP PAST DASHES\n         MVI   0(R15),C'*'                RIGHT CORNER\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** PRINT \" |                                             |\"\n*\n         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT TO BLANKS\n         LA    R15,RECOUT+@START          LOCATE AT STARTING LOCATION\n         MVI   0(R15),C'|'                LEFT\n         MVI   69(R15),C'|'               RIGHT\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** PRINT \" |  O/S----MVS SPx.x.x   FMID--------JBB2125 |\"\n** PRINT \" |  O/S-OS/390 01.02.00  FMID--------JBBxxxx |\"\n*\n         BAS   R9,SYSP$IREC               INITIALIZE LINE\n         MVC   RECOUT+@TEXT1(3),=C'O/S'\n         MVC   RECOUT+@TEXT2(4),=C'FMID'\n*\n         L     R1,CVTPTR                -> CVT\n         TM    CVTDCB-CVTMAP(R1),CVTOSEXT CVTOSLVL okay?\n         BNO   SYSP$MVS                 No, ancient system!\n         AIF   (NOT D'CVTOS390).SYSPO31 Have OS/390 stuff?\n         TM    CVTOSLV1-CVTMAP(R1),CVTOS390 OS/390?\n         BO    SYSP$OS390               Yes, format name and release\n.SYSPO31 ANOP  ,\nSYSP$MVS DS    0H\n         LA    R0,CVTLEVL-CVTPROD+L'CVTLEVL Offset back to product lvl\n         SR    R1,R0                    Locate product level\n         LA    R2,PARMLIST\n         MVC   0(4,R2),=C'MVS '\n         MVC   4(8,R2),CVTPRODN-CVTPROD(R1)  Get \"SPx.x.x \"\n         LA    R3,4+8                   Length of \"MVS SPx.x.x \"\n         B     SYSP$OS390X\nSYSP$OS390 DS  0H\n         AIF   (NOT D'CVTOS390).SYSPO32 Have OS/390 stuff?\n         DA#SMODE 31                    The ECVT is above the line\n         L     R1,CVTPTR                -> CVT\n         L     R1,CVTECVT-CVTMAP(R1)    -> ECVT\n         LA    R15,PARMLIST\n         MVC   0(L'ECVTPNAM,R15),ECVTPNAM-ECVT(R1)\n         LA    R0,L'ECVTPNAM\n         BAS   R14,SYSP$LOCATE_FIRST_SPACE\n         MVI   0(R15),C'_'\n         LA    R15,1(R15)\n         MVC   0(2,R15),ECVTPVER-ECVT(R1) Get Version\n         MVI   2(R15),C'.'\n         MVC   3(2,R15),ECVTPREL-ECVT(R1) Get Release\n         MVI   5(R15),C'.'\n         MVC   6(2,R15),ECVTPMOD-ECVT(R1) Get Modification\n         LA    R15,8(R15)                 bump past \"01.02.00\"\n         LA    R2,PARMLIST                Locate start of \"name v.r.m\"\n         LR    R3,R15                     Locate end of v.r.m\n         SR    R3,R2                      Length = end - start\n         DA#SMODE 24                    Get back, joe!\n.SYSPO32 ANOP  ,\nSYSP$OS390X DS 0H\n*-At this point R2=\"name level\" and R3 has the length\n         LA    R15,RECOUT+@VALUE1E        LOCATE END OF VALUE ONE\n         SR    R15,R3                     BACKUP TO STRING START\n         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING\n*\n         LA    R15,RECOUT+@VALUE2E        LOCATE END OF VALUE ONE\n         L     R1,CVTPTR\n         LA    R0,CVTLEVL-CVTPROD+L'CVTLEVL Offset back to product lvl\n         SR    R1,R0                    Locate product level\n         LA    R3,L'CVTPRODI              GET LENGTH OF STRING\n         SR    R15,R3                     BACKUP TO STRING START\n         LA    R2,CVTPRODI-CVTPROD(R1)    ADDRESS OF STRING\n         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** PRINT \" |  DF/SMS----------1.3.0  DFP-----------3.3.2 |\"\n*\n         BAS   R9,SYSP$IREC               INITIALIZE LINE\n         MVC   RECOUT+@TEXT1(6),=C'DF/SMS'\n         MVC   RECOUT+@TEXT2(3),=C'DFP'\n*\n         LA    R2,G_DFSMSLVL              Locate DF/SMS level\n         LA    R15,RECOUT+@VALUE1E        LOCATE END OF VALUE ONE\n         LA    R3,L'G_DFSMSLVL            GET LENGTH OF STRING\n         SR    R15,R3                     BACKUP TO STRING START\n         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING\n*\n         LA    R15,RECOUT+@VALUE2E        LOCATE END OF VALUE ONE\n         LA    R3,L'G_DFPLVL              GET LENGTH OF STRING\n         SR    R15,R3                     BACKUP TO STRING START\n         LA    R2,G_DFPLVL                Locate DFP level\n         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** PRINT \" |  System Name--DavesBox  SMF ID---------DAVE |\"\n*\n         BAS   R9,SYSP$IREC               INITIALIZE LINE\n         MVC   RECOUT+@TEXT1(11),=C'System Name'\n         MVC   RECOUT+@TEXT2(6),=C'SMF ID'\n*\n         L     R2,CVTPTR                  -> CVT\n         LA    R2,CVTSNAME-CVTMAP(R2)     Locate System Name\n         LA    R15,RECOUT+@VALUE1E        LOCATE END OF VALUE ONE\n         LA    R3,L'CVTSNAME              GET LENGTH OF STRING\n         SR    R15,R3                     BACKUP TO STRING START\n         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING\n*\n         LA    R15,RECOUT+@VALUE2E        LOCATE END OF VALUE ONE\n         LA    R3,L'SMCASID               GET LENGTH OF STRING\n         SR    R15,R3                     BACKUP TO STRING START\n         L     R2,CVTPTR                  -> CVT\n         L     R2,CVTSMCA-CVTMAP(R2)      -> SMCA\n         LA    R2,SMCASID-SMCABASE(R2)    Locate System ID\n         BAS   R9,SYSP$RITEJUST           RIGHT JUSTIFY STRING\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** PRINT \" |                                             |\"\n*\n         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT TO BLANKS\n         LA    R15,RECOUT+@START          LOCATE AT STARTING LOCATION\n         MVI   0(R15),C'|'                LEFT\n         MVI   69(R15),C'|'               RIGHT\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** PRINT \" *---------------------------------------------*\"\n*\n         BAS   R14,SYSP$CLEAR_RECOUT      CLEAR RECOUT TO BLANKS\n         LA    R15,RECOUT+@START          LOCATE STARTING LOCATION\n         MVC   0(2,R15),=C'*-'            LEFT CORNER\n         LA    R15,1(R15)                 BUMP PAST STAR\n         MVC   1(67,R15),0(R15)           PROPAGATE DASH\n         LA    R15,68(R15)                BUMP PAST DASHES\n         MVI   0(R15),C'*'                RIGHT CORNER\n         BAS   R14,SYSP$PRR               Print record on file=REPORT\n*\n** Exit\n*\n         SLR   R15,R15\n         PR    ,                          Return to caller\n*\n** Print SYSPRINT Record\n*\nSYSP$PRR DS    0H\n         ST    R14,PRR_RA                 Save return address\n         LA    R0,PRRRSA                  Locate work area\n         LA    R1,RECOUT                  Locate record to print\n         L     R15,=V(DRU$PRR)            Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n         L     R14,PRR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Clear output record to blanks\n*\nSYSP$CLEAR_RECOUT  DS 0H\n         LA    R15,RECOUT                 Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(133-1,R15),0(R15)        ..Propagate it\n         BSM   0,R14                      Return to caller\n*\n** RIGHT JUSTIFY A STRING\n** INPUT: R15 ADDRESS TO PUT STRING\n**        R2  ADDRESS OF STRING\n**        R3  LENGTH OF STRING\n** OUTPUT: STRING WILL BE RIGHT JUSTIFIED AT ADDRESS OF R15\n*\nSYSP$RITEJUST DS 0H\n         SLR   R0,R0                      CLEAR COUNTER\n         LR    R1,R3                      GET LENGTH TO WORK REG\n         LR    R14,R2                     GET ADDRESS TO WORK REG\nSYSP$RJ$CSL DS 0H\n         CLI   0(R14),C' '                SPACE?\n         BNE   SYSP$RJ$CSB                NO, MOVE ON\n         AH    R0,=H'1'                   INCREMENT COUNTER\nSYSP$RJ$CSB DS 0H\n         LA    R14,1(R14)                 BUMP TO NEXT BYTE\n         BCT   R1,SYSP$RJ$CSL             ..DO IT\n         LR    R1,R0                      GET NUM OF BLANKS\n         LA    R14,0(R1,R15)              PLACE TO PUT STRING\n         LR    R1,R3                      GET LENGTH\n         SR    R1,R0                      NUMBER OF NON-BLANKS\n         BCTR  R1,0                       DECREMENT FOR EX\n         EX    R1,SYSP$RJ$CSM             RIGHT JUSTIFY STRING\n         BSM   0,R9                       RETURN TO CALLER\nSYSP$RJ$CSM MVC 0(0,R14),0(R2)            ** EXECUTED **\n*\n** Initialize System Profile record\n*\nSYSP$IREC DS 0H\n         BAS   R14,SYSP$CLEAR_RECOUT      Clear recout to blanks\n         LA    R15,RECOUT+@START          STARTING LOCATION ON LINE\n         MVI   0(R15),C'|'                LEFT\n         MVI   69(R15),C'|'                    RIGHT\n         LA    R15,RECOUT+@TEXT1          BUMP TO TEXT LOCATION 1\n         MVI   0(R15),C'-'                GET DASH\n         MVC   1(29,R15),0(R15)           ..PROPAGATE IT\n         LA    R15,RECOUT+@TEXT2          BUMP TO TEXT LOCATION 2\n         MVI   0(R15),C'-'                GET DASH\n         MVC   1(29,R15),0(R15)           ..PROPAGATE IT\n         BSM   0,R9                       RETURN\n*\n** EDIT WITH DASH FILL FROM LEFT TO RIGHT (15 BYTES)\n** INPUT:  R1 - VALUE TO EDIT\n**         R15 - ADDRESS TO PUT PATTERN\n*\nSYSP$EDITD15 DS 0H\n         CVD   R1,DOUBLE                  CONVERT TO PACKED\n         MVC   0(15,R15),SYSP$EDITP15     GET EDIT PATTERN\n         MVI   0(15),C'-'                 LEADING DASHES\n         ED    0(15,R15),DOUBLE+2         EDIT\n         LTR   R1,R1                      DID HE FIND ANYTHING TO EDIT?\n         BNZ   SYSP$EDITD15X              YES, MOVE ON\n         MVI   14(R15),C'0'               NO, LEAVE A ZERO\nSYSP$EDITD15X DS 0H\n         BSM   0,R9                       RETURN\nSYSP$EDITP15 DC X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\n*\n** POINT REGISTER 15 TO FIRST BLANK IN STRING\n** INPUT:  R0  - MAXIMUM LENGTH OF STRING\n**         R15 - STRING\n** OUTPUT: R15 - FIRST SPACE IN STRING\n*\nSYSP$LOCATE_FIRST_SPACE DS 0H\n         CLI   0(R15),C' '\n         BE    SYSP$LFS$X\n         LA    R15,1(R15)\n         BCT   R0,SYSP$LOCATE_FIRST_SPACE\nSYSP$LFS$X DS  0H\n         BSM   0,R14\n*\n** Literals and end of DRU$SYSP routine\n*\n         LTORG ,                          Literals in DRU$SYSP\n         DS    0D                         End of DRU$SYSP\n         DROP  R12\n         DROP  R13\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Print Big letters via IEFSD095                             **\n**                                                                   **\n**        Input: R1 points to a string                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDRU$BLET CSECT ,\nDRU$BLET AMODE 24\nDRU$BLET RMODE 24\n*\n** Standard O/S eyecatcher\n*\nBLET_EC  B    BLET_ECL(0,R15)             Bump past EyeCatcher\n         DC   AL1(L'BLET_ECV)             Length of eyecatcher\nBLET_ECV DC   C'DRU$BLET -- Print Big Letters'\n         DS   0H\nBLET_ECL EQU  *-BLET_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING DRU$BLET,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R0                     Save input RSA\n         LR    R8,R1                      Save input to print\n         USING BLETRSA,R13\n*\n         ICM   R15,B'1111',=V(IEFSD095)\n         BZ    BL$X\n*\n** Fix the string\n*\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R8)                   Get string length\n         LA    R1,1(R1)                   Increment by 1\n         XC    BL_LEN(3),BL_LEN           Fix first 3 bytes of fullword\n         STC   R1,BL_LEN+3                Save length for IEFSD095\n         LA    R8,1(R8)\n*\n** Print 'DASD LIST' in big slant letters\n*\n         LA    R1,1\n         ST    R1,BL_LINEC              GET LINE COUNTER FOR LOOP INDEX\n         LA    R1,RECOUT+12+5           OUTPUT LOC (5 CENTER, 12 SLANT)\n         ST    R1,BL_ADDR               Save location\nBL$LP    DS    0H\n         BAS   R14,BL$CLEAR_RECOUT        Clear RECOUT to blanks\n*\n         L     R5,BL_ADDR\n         L     R15,=V(IEFSD095)           Locate routine: IEFSD095\n         CALL  (15),                             Call IEFSD095         @\n               ((8),BL_LINEC,(5),BL_LEN),        ..Parameters          @\n               VL,MF=(E,PARMLIST)                ..Parm list/VL\n         BAS   R14,BL$PRR                 Print record on file=REPORT\n*\n         L     R1,BL_ADDR\n         BCTR  R1,0                       Decrement for slant\n         ST    R1,BL_ADDR\n*\n         L     R1,BL_LINEC\n         LA    R1,1(R1)                   Increment line counter\n         ST    R1,BL_LINEC\n*\n         CH    R1,=H'12'                  End of the line?\n         BNH   BL$LP                      Nope, do next line\n*\n** Common exit from Big_Letter routine\n*\nBL$X     EQU   *\n         PR    ,\n*\n** Print SYSPRINT Record\n*\nBL$PRR   DS    0H\n         ST    R14,PRR_RA                 Save return address\n         LA    R0,PRRRSA                  Locate work area\n         LA    R1,RECOUT                  Locate record to print\n         L     R15,=V(DRU$PRR)            Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n         L     R14,PRR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Clear output record to blanks\n*\nBL$CLEAR_RECOUT  DS 0H\n         LA    R15,RECOUT                 Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(133-1,R15),0(R15)        ..Propagate it\n         BSM   0,R14                      Return to caller\n*\n** Literals and end of DRU$BLET routine\n*\n         LTORG ,                          Literals in DRU$BLET\n         DS    0D                         End of DRU$BLET\n         DROP  R12\n         DROP  R13\n         EJECT ,\n***********************************************************************\n***\n**       Help me - Help me - I've been hyp-mo-tized\n**\n** This routine prints the help information.  The Pascal-like\n** strings make the bulk of the input.  There are a few attribute\n** bytes which are used instead of a usual string length:\n**\n** - FF ... End of help information\n** - FE ... Print a blank line\n** - FD ... Print the translator table\n** - FC ... Print the Linkage Editor/Binder Translator table\n**\n** Help information - We are trying to keep this information\n** under 80 columns for good TSO viewing.  It is printed when this\n** program is executed with PARM='HELP'.\n***\n***********************************************************************\n         SPACE 2\nDRU$HELP CSECT ,\nDRU$HELP AMODE 24\nDRU$HELP RMODE 24\n*\n** Standard O/S eyecatcher\n*\nHLP_EC   B    HLP_ECL(0,R15)            Bump past EyeCatcher\n         DC   AL1(L'HLP_ECV)            Length of eyecatcher\nHLP_ECV  DC   C'DRU$HELP -- Help Information'\n         DS   0H\nHLP_ECL  EQU  *-HLP_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         USING DRU$HELP,R12             Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1\n         LR    R13,R0\n         USING SUBRSA,R13                 Locate to data area\n         SPACE 2\n*\n** Print initial messages\n*\n         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks\n         BAS   R14,HELP$PSR               Print the record\n*\n         BAS   R14,HELP$FORMAT_MESSAGE   Initialize the message area\n         MVC   0(MSG62L,R15),MSG62-DRU$CON1(R1) Move in message\n         BAS   R14,HELP$PSR               Print the record\n*\n** Loop thru help text\n*\n         LA    R3,HELPTEXT                Locate start of text\nHELP$L   DS    0H\n         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks\n*-Blank line\n         CLI   0(R3),X'FE'                Blank line?\n         BNE   HELP$LM                    No, continue\n         BAS   R14,HELP$PSR               Print the record\n         LA    R3,1(R3)                   Bump past attribute character\n         B     HELP$L\nHELP$LM  DS    0H\n*-Print special info here\n**       CLI   0(R3),X'FD'                Translators?\n**       BNE   HELP$TTX                   No, continue\n*-Print string\n         LA    R15,RECOUT+1               Bump past prefix and 'xxxI '\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R3)                  Obtain length of messsage - 1\n         EX    R14,HELP$MVE               Move string to message area\n         LA    R3,2(R14,R3)               Bump past this string\n         BAS   R14,HELP$PSR               Print record\n*-End of table\n         CLI   0(R3),X'FF'                End of table?\n         BNE   HELP$L                     No, process next string\n*\n         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks\n         BAS   R14,HELP$PSR               Print the record\n         B     HELP$X                     Continue\n*\nHELP$MVE MVC   0(0,R15),1(R3)\n*\n** Common exit from HELP processing\n*\nHELP$X   DS    0H\n         PR    ,                          Return to caller\n*\n** Print SYSPRINT Record\n*\nHELP$PSR DS    0H\n         ST    R14,PSR_RA                 Save return address\n         LA    R0,PSRRSA                  Locate work area\n         LA    R1,RECOUT                  Locate record to print\n         L     R15,=V(DRU$PSR)            Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n         L     R14,PSR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Clear output record to blanks\n*\nHELP$CLEAR_RECOUT  DS 0H\n         LA    R15,RECOUT                 Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(133-1,R15),0(R15)        ..Propagate it\n         BSM   0,R14                      Return to caller\n*\n** Initialize message\n**\n** Output: R1 has DRU$CON1\n*\nHELP$FORMAT_MESSAGE DS 0H\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(133-1,R15),0(R15)\n         LA    R15,1(R15)\n         MVC   0(3,R15),=C'DRU'           Move in message prefix\n         LA    R15,3(R15)\n         L     R1,=V(DRU$CON1)            -> DRU$CON1 CSECT\n         BSM   0,R14\n*\n** Literals for the DRU$HELP CSECT\n*\n         LTORG ,\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Help text area\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nHELPTEXT DS    0H\n DC  X'FE'                                Skip a line\n*\n** General information\n*\n DA#STR 'DA$DISKR is a utility that will create reports about your '\n DA#STR 'DASD farm'\n*\n** Sample JCL\n*\n DC  X'FE'                                Skip a line\n DA#STR 'It can be invoked via the following JCL:'\n DC  X'FE'                                Skip a line\n DA#STR '//stepname EXEC PGM=DA$DISKR,PARM=''options'' '\n DA#STR '//VATLST   DD DISP=SHR,DSN=SYS1.PARMLIB(VATLST00)'\n DA#STR '//*'\n DA#STR '//SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=FA)'\n DA#STR '//REPORT   DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)'\n DA#STR '//VTOCRPT  DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)'\n DA#STR '//SYSUDUMP DD SYSOUT=*'\n DA#STR '//*'\n DA#STR '//WRKFILE1 DD DISP=(,PASS),DSN=&&WRKFILE1,UNIT=SYSDA,'\n DA#STR '//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),'\n DA#STR '//            SPACE=(CYL,(5,5))'\n DA#STR '//WRKFILE2 DD DISP=(,PASS),DSN=&&WRKFILE2,UNIT=SYSDA,'\n DA#STR '//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),'\n DA#STR '//            SPACE=(CYL,(20,20))'\n DA#STR '//WRKFILE3 DD DISP=(,PASS),DSN=&&WRKFILE3,UNIT=SYSDA,'\n DA#STR '//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),'\n DA#STR '//            SPACE=(CYL,(20,20))'\n DA#STR '//WRKFILE4 DD DISP=(,PASS),DSN=&&WRKFILE4,UNIT=SYSDA,'\n DA#STR '//            DCB=(LRECL=80,BLKSIZE=80,RECFM=FB),'\n DA#STR '//            SPACE=(CYL,(5,5))'\n DA#STR '//WRKFILE5 DD DISP=(,PASS),DSN=&&WRKFILE5,UNIT=SYSDA,'\n DA#STR '//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),'\n DA#STR '//            SPACE=(CYL,(5,5))'\n DC  X'FE'                                Skip a line\n DC  X'FE'                                Skip a line\n DA#STR ' Note: If you don''t want a VTOC report, simply comment out'\n DA#STR '       the //VTOCRPT JCL statement'\n*\n** Pair-A-Meters\n*\n DC  X'FE'                                Skip a line\n DC  X'FE'                                Skip a line\n DA#STR 'The following options can be specified on the parm card '\n DA#STR '(PARM=\"option,option\")'\n DC  X'FE'                                Skip a line\n DA#STR 'CATCHK   - Perform check to see if dataset is catalogued'\n DC  X'FE'                                Skip a line\n DA#STR 'CVTUCBSC - Use the older UCB scan method even though we are '\n DA#STR '           executing on a system that can use the new way.'\n DA#STR '           This is not recommended: no dynamic or 4 digit '\n DA#STR '           UCBs will be found'\n DC  X'FE'                                Skip a line\n DA#STR 'DATAONLY - Reports only have data line items: no headings or'\n DA#STR '           footings'\n DC  X'FE'                                Skip a line\n DA#STR 'DEBUG    - Show some debugging information'\n DC  X'FE'                                Skip a line\n DA#STR 'HELP     - Print help information for using this utility'\n DC  X'FE'                                Skip a line\n DA#STR 'NAUTH    - Do not use facility that require authorization'\n DA#STR '           if we are able to do do'\n DC  X'FE'                                Skip a line\n DA#STR '           Alias: NOAUTH'\n DC  X'FE'                                Skip a line\n DA#STR 'NOPIC    - Don''t display picture at startup'\n DC  X'FE'                                Skip a line\n DA#STR 'NOSYSP   - Don''t print System Profile at the beginning of '\n DA#STR '           the //REPORT file output'\n DC  X'FE'                                Skip a line\n DA#STR 'ONLYLLIB - Only process Load Libraries'\n DC  X'FE'                                Skip a line\n DA#STR 'ONLYRECU - Only process RECFM=U libraries'\n DC  X'FE'                                Skip a line\n DA#STR 'PRTSMSG  - Print sort messages (usually only printed when the'\n DA#STR '           SORT has a bad RC or ABEND)'\n DC  X'FE'                                Skip a line\n DA#STR '           Alias: PRTSORTM and PSM'\n DC  X'FE'                                Skip a line\n DA#STR 'RPTBOTH  - Print DASD report by UCB and DSN'\n DC  X'FE'                                Skip a line\n DA#STR 'RPTBYDSN - Print report by DSN'\n DC  X'FE'                                Skip a line\n DA#STR 'RPTBYUCB - Print report by UCB'\n DC  X'FE'                                Skip a line\n DA#STR 'SMSMCHK '\n DC  X'FE'                                Skip a line\n DA#STR 'VERBOSE '\n DC  X'FE'                                Skip a line\n DC  X'FE'                                Skip a line\n DA#STR 'DASD Configuration Report field source:'\n DC  X'FE'                                Skip a line\n DA#STR 'o UCB.............UCB:   UCBCHAN'\n DA#STR 'o Volume_Serial...UCB:   UCBVOLI'\n DA#STR 'o Device_Type.....IEFEB4UV and internal nickname table'\n DA#STR 'o Tracks_Free.....LSPACE: LSPDTTRK LSPDTCYL'\n DA#STR 'o Tracks_Total....DSCB4: DS4DSCYL * DS4STRK'\n DA#STR '                  (Other programs subtract the VTOC'\n DA#STR '                  and other overhead areas)'\n DA#STR 'o VTOC_size.......DSCB4: DS4VTOEC w/DS4DEVSZ calcs'\n DA#STR 'o VTOC_DSCB.......DSCB4: DS4DEVDT'\n*\n** End of HELP CSECT\n*\n DC  X'FE'                                Skip a line\n DA#STR 'End of Help.'\n DC  X'FF'\n*\n** End of DRU$HELP\n*\n         DROP  R12,R13\n         DS  0D\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        DA$DISKR DSECTs                                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Work DASD area\n*\nWD           DSECT ,\nWD_VOLS      DS    CL6                    Volume serial\nWD_UCB       DS    CL4                    UCB address\nWD_SNAME     DS    CL8                    System name from CVTSNAME\nWD_VER       DS    CL4'V1.0'              DA$DISKR Version.Release\nWD_DEVTL     DS    X                      Device type length\nWD_DEVT      DS    CL8                    Device type\nWD_DEVTA     DS    CL8                    Device type for allocation\nWD_FLAG1     DS    B'00000000'            Flag 1\n$WDF1_NLSPC  EQU   B'10000000'            ..No LSPACE information\n$WDF1_IVTOC  EQU   B'01000000'            ..Indexed VTOC?\n$WDF1_CACHEC EQU   B'00100000'            ..Cached controller?\n$WDF1_CACHEV EQU   B'00010000'            ..Cached volume?\n$WDF1_CVAFF  EQU   B'00001000'            ..CVAF failed?\nWD_VTOCT     DS    XL2                    Number of tracks in VTOC\nWD_UCBT      DS    CL4                    UCB type\nWD_VMNT      DS    CL3                    Mount status (VATLST)\nWD_SMNT      DS    CL3                    Mount status (SYSTEM)\nWD_CHPID     DS    CL8                    Channel path id\nWD_VIT       DS    XL4                    VTOC info Table entry\n             DS    0F\nWD_LSPCD     DS    XL(C_LSPCDLL)          LSPACE SVC Data information\nWD_F4DSCB    DS    XL(#F4DSCBL)           Format 4 DSCB\nWD_DESC      DS    CL40                   Description\n             DS    0D                     Get aligned\nWD_DTAREA    DS    XL24                   Device type macro return\nWDL          EQU   *-WD\n*\n** Process_VTOC / VTOC Information\n*\nDDC          DSECT ,\nDDC_H        EQU   *\nDDC_HID      DC    CL8'DASD-DC'\nDDC_HL       EQU   *-DDC_H\nDDC_E        EQU   *                     Entry\nDDC_ENAME    DS    CL8'3380K'            ..Device type\nDDC_ECOUNT   DS    XL4                   ..Count\nDDC_EL       EQU   *-DDC_E\n*\n** Process_VTOC / VTOC Information\n*\nVI           DSECT ,\nVI_SER       DS    CL6                    Volume name\nVI_FLAG1     DS    B'00000000'            Flag 1\nVI_FLAG2     DS    B'00000000'            Flag 2\nVI_DDN       DS    CL8                    DDNAME used to access it\n*                                         DSCB counts:\nVI_F0        DS    F                      ..Format 0 (free)\nVI_F1        DS    F                      ..Format 1\nVI_F2        DS    F                      ..Format 2\nVI_F3        DS    F                      ..Format 3\nVI_F4        DS    F                      ..Format 4\nVI_F5        DS    F                      ..Format 5\nVI_F6        DS    F                      ..Format 6\n*                                         RECFM counts:\nVI_PS        DS    F                      ..Physically Sequential\nVI_DA        DS    F                      ..Direct Access\nVI_PO        DS    F                      ..Partitioned Organization\nVI_IS        DS    F                      ..ISAM\nVI_AM        DS    F                      ..VSAM\nVI_UN        DS    F                      ..UnKnown\n*                                         Misc:\nVI_UNCAT     DS    F                      ..Un-Catalogued Datasets\nVIL          EQU   *-VI\n*\n** Process_VTOC Records\n*\nPVR          DSECT ,\nPVR_VOLS     DS    CL6\nPVR_UCB      DS    CL4\nPVR_CAT      DS    C' '\nPVR_DSCB     DS    CL140\nPVR_DSORG    DS    CL3' '\nPVRL         EQU   *-PVR\n*\n** VATLST Description\n*\nVL          DSECT ,\nVL_VOLS     DS    CL6                     VOLSER\n            DS    CL1                     ,\nVL_MNT      DS    CL1                     MOUNT ATTRIBUTE\nVL_MNT0     EQU   X'F0'                   ..PERMANENTLY RESIDENT\nVL_MNT1     EQU   X'F1'                   ..RESERVED\n            DS    CL1                     ,\nVL_USE      DS    CL1                     DEFAULT MOUNTING OF VOLUME\nVL_USE0     EQU   X'F0'                   ..STORAGE\nVL_USE1     EQU   X'F1'                   ..PUBLIC\nVL_USE2     EQU   X'F2'                   ..PRIVATE\n            DS    CL1                     ,\nVL_DEVT     DS    CL8                     DEVICE TYPE\n            DS    CL1                     ,\nVL_MSG      DS    CL1                     N\n            DS    CL1                     FILLER\nVL_DESC     DS    CL40                    DESCRIPTION OF USE\n*\n** Operations Report\n*\nOR       DSECT ,\n         DS    CL1                        FBA BYTE\nOR_UCB   DS    CL4                        UCB\n         DS    CL1\nOR_VOLS  DS    CL6                        Volume Serial\n         DS    CL1\nOR_DEVT  DS    CL8                        Device Type\n         DS    CL1\nOR_VMNT  DS    CL3                        Mount status (VATLST)\n         DS    CL3\nOR_SMNT  DS    CL3                        Mount status (system)\n         DS    CL2\nOR_TRKS  EQU   *                          Tracks\nOR_FTRKP DS    CL4                        ..Percent free\nOR_FTRKS DS    CL10                       ..Number\n         DS    CL2\nOR_TTRKS DS    CL10                       ..Total\n         DS    CL2\nOR_VTOC  EQU   *                          VTOC\nOR_VTOCP DS    CL4                        ..Percent used\n         DS    CL2\nOR_IVTOC DS    CL1                        Indexed VTOC indication\n         DS    CL1\nOR_VTOCT DS    CL4                        ..Size\n         DS    CL2\nOR_VTOCF DS    CL4                        ..Free DSCBs\nOR_VTOCL EQU   *-OR_VTOC\n         DS    CL2\nOR_CACHE DS    CL2                        Cached volume?\n         DS    CL1\nOR_DESC  DS    CL40                       VATLST description\n*\n** VTOC output\n*\nVR       DSECT ,\nVR_DSN   DS    CL44                       Dataset name\n         DS    C\nVR_UCB   DS    CL4\n         DS    C\nVR_VOLS  DS    CL3\n         DS    C\nVR_CDATE DS    C'06 MAR 1989'\n         DS    C\nVR_DSORG DS    CL4\n         DS    C\nVR_ALLOC DS    CL4\n         DS    C\nVR_PRI   DS    CL4\n         DS    C\nVR_SEC   DS    CL4\n         DS    C\nVR_RECFM DS    CL4\nVRL      EQU   *-VR\n*\n** Increment VATLST\n*\nIV       DSECT ,\nIV_VOL   DS    CL6                        Volume\nIV_LEN   EQU   *-IV                       Length of entry\n*\n** DASD Usage\n*\nDT       DSECT ,\n         DS    CL21\nDT_NAME  DS    CL8                        Name (3380, 3380K, 3390, etc)\n         DS    CL4\nDT_COUNT DS    CL5\n*\n** DASD Usage\n*\nDU       DSECT ,\n         DS    CL21\nDU_GROUP DS    CL6                        VOLUME GROUP\n         DS    C\nDU_GROUPP  DS  CL4\nDU_GROUPPP DS  C'%'\nDU_GROUPL EQU  *-DU_GROUP                 VOLUME GROUP\n         DS    CL5                        FILLER\nDU_NUM   DS    CL6                        NUMBER IN GROUP\n         DS    CL5                        FILLER\nDU_TTRK  DS    CL15                       TOTAL tracks\n         DS    CL5                        FILLER\nDU_FTRK  EQU   *                          FREE Tracks\nDU_FTRKN DS    CL15                       ..NUMBER\n         DS    CL1                        ..FILLER\nDU_FTRKP DS    CL4                        ..PERCENTAGE\n         DS    C\nDU_FTRKL EQU   *-DU_FTRK\n         DS    CL5                        FILLER\nDU_ATRK  EQU   *                          Allocated Tracks\nDU_ATRKN DS    CL15                       ..NUMBER\n         DS    CL1                        ..FILLER\nDU_ATRKP DS    CL4                        ..PERCENTAGE\n         DS    C\nDU_ATRKL EQU   *-DU_ATRK\nDUL      EQU   *-DU\n*\n** Dataset List Record\n*\nDLR         DSECT ,\nDLR_DSN     DS   CL44\n            DS   C\nDLR_VOLS    DS   CL6\n            DS   CL3\nDLR_CAT     DS   C\n            DS   CL3\nDLR_DSORG   DS   CL5\n            DS   CL2\nDLR_RECFM   DS   CL5\n            DS   CL2\nDLR_LRECL   DS   CL5\n            DS   CL2\nDLR_BLKSIZE DS   CL5\n            DS   CL2\nDLR_CDATE   DS   C'dd-mmm-ccyy'\n            DS   CL2\nDLR_UDATE   DS   C'dd-mmm-ccyy'\n            DS   CL2\nDLR_SMS     DS   CL3\n            DS   CL1\nDLR_ATYPE   DS   CL5\n            DS   CL1\nDLR_SEC     DS   CL5\n            DS   CL1\nDLR_PRI     DS   CL5\n            DS   CL1\nDLR_USED    DS   CL5\nDLRL        EQU  *-DLR\n*\n** Misc Equates\n*\n#VATLSTE EQU   12                         Number: unused VATLST across\n*\n#BUFLST  EQU   BFLHLN+BFLELN              Set length of buffer area\n#F4DSCBL EQU   DS4END-IECSDSL4            Generate length of F4DSCB\n         END ,\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Linkage editor cards - ASM.PARM='BATCH,...'                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n PUNCH ' ENTRY   DA$DISKR         '       Entry point\n PUNCH ' INCLUDE AOSB0(IEFSD095)  '       IBM big letter routine\n PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Our Minx-Hex-Dump routine\n PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Our Date routine\n PUNCH ' SETCODE AC(1)            '       Authorization helps (ENQ)\n PUNCH ' NAME    DA$DISKR(R)      '       Name of load module\n         END ,\n./ ADD NAME=DA$ENQS  0100-01266-01266-1821-00938-00938-00000-DAVE\n***********************************************************************\n***\n** Name: DA$ENQS\n**\n** Author = David Alcock :: dave@planetmvs.com\n**\n** Purpose: This is a TSO command processor that displays enqueue\n**          information for the given RNAME and QNAME.\n**\n** Syntax: WHOHAS RNAME QNAME\n**\n**         For example:\n**\n**         WHOHAS 'SYS1.PARMLIB'     /* Defaults QNAME to SYSDSN */\n**         WHOHAS * SPFUSER          /* Show TSO users in ISPF   */\n**\n** Jobname field has the following formats:\n** - \"XYZ     >LLA     \" - On system \"XYZ\", jobname LLA has resource\n** - \"TSU01234-IBMUSER \" - On executing system, jobid TSU01234 has\n**                         the resource.\n** - \"ASID0021-LLA     \" - On executing system, jobname LLA (which\n**                         has no JES jobnumber (or JSAB control\n**                         block available) holds the resource.\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n**\n** Attributes: Reentrant, Reusable, Non-Authorized\n**\n** Non-IBM assembler MACROs:\n** o DA#TSOS....TSO services: parsing and messages\n** o DA#ENTER...Entry housekeeping\n** o DA#LEAVE...Termination housekeeping\n** o DA#EYEC....Build standard O/S module eyecatcher\n**              (invoked by the DA#ENTER)\n** o DA#REGS....Define registers (invoked by DA#ENTER)\n***\n***********************************************************************\n         EJECT\n&DAVER   SETC  '1.2'\n***********************************************************************\n***\n**            M o d i f i c a t i o n   H i s t o r y\n**\n**  Person        Date         Description\n**  ------------  -----------  ----------------------------------------\n**  D.Alcock      17-DEC-1998  V1.2:\n**                             - Use JSAB to get the JOBID;  This\n**                               change means we can only execute on\n**                               a MVS version 4 or higher system;\n**                             - Use LOCACSB macro correctly;\n**                             - Check for Enqueues from other systems\n**                               and handle them correctly;\n**                             - Handle 4 digit UCBs; (Not tested!)\n**  D.Alcock      28-MAY-1998  V1.1:\n**                             - MSG1 lines up by having the job\n**                               field always 12 characters long;\n**                             - Change *-6 Execute instructions from\n**                               inline to outline;\n**  D.Alcock      13-NOV-1996  V1.0 - Renamed from WHOHAS to DA$ENQS\n***\n***********************************************************************\n         SPACE 2\n*\n** IBM DSECTs\n*\n ISGRIB ,                                 GRS - Resource map\n PRINT NOGEN\n IHASDWA ,                                System Diagnostic Work Area\n IRAOUCB ,                                Resource manager User C.B.\n IEECHAIN ,                               CSCB\n IEZJSCB ,                                Job Step Control Block\n CVT   DSECT=YES,LIST=NO                  Communications Vector Table\n IHAPSA ,                                 Prefixed Save Area\n IHAASCB ,                                Address Space Control Block\n IHAASXB ,                                Address Space Extension Block\n IAZJSAB ,                                Job Schedular\n IHAASSB ,                                Address Space Sec Block\n IEFUCBOB PREFIX=YES                      Unit Control Block\n IKJEFLWA ,                               Logon Work area\n IKJEFFGF GFDSECT=YES                     IKJEFF19 GNRLFAIL\n IKJPSCB ,                                Protected Step Control Block\n IKJTCB DSECT=YES,LIST=NO                 Task Control Block\n IKJUPT ,                                 User Profile Table\n IKJCPPL ,                                Command Processor Parm List\n#CPPL  EQU *-CPPL                         ..Length of CPPL\n IKJIOPL ,                                Input/Output Parameter Block\n#IOPL  EQU *-IOPL\n IKJPPL ,                                 Parse Parameter List\n#PPL   EQU *-PPL\n IKJECT ,                                 Enviornment Control Table\n IKJPTPB ,                                PUTLINE Parm Block\n*\n** Dave's DSECTs\n*\n PRINT GEN\n DA#TSOS ,                                TSO parse, PUTLINE, etc.\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**               Initialization Section                              **\n***                                                                 ***\n***********************************************************************\n         EJECT\nDA$ENQS  DA#ENTER 'V&DAVER TSO CMD: Who has an enqueue',               @\n               RENT=YES,LV=DSAL,                                       @\n               AMODE=31,RMODE=ANY\n USING DSA,R13\n ST    R1,R1SAVE                          Save the address of CPPL\n         SPACE 2\n*\n** CPPL, PUTLINE, and PARSE Initialization\n*\n LA    R2,X'05'(R12)                      Locate program name DA$ENQS\n DA#TSOS INIT,WA_DA#TSOS,                 Initialize CPPL, PUTLINE...  @\n               CPPL=R1SAVE,               ..CPPL                       @\n               PCL==V(WHOHASP),           ..Parse area                 @\n               PNAME=(R2),PNAMEL=6,       ..Program name Addr,length   @\n               ERRET=X$TSOX\n*\n** Ensure we are on a MVS version 4 system or higher\n*\n L     R1,CVTPTR\n TM    CVTOSLV0-CVTMAP(R1),CVTH4410\n BO    I$MVS4X\n*MVI   MAXCC,$SEVERE                      Set return code\n DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG10\nI$MVS4X DS 0H\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**           Parse for fields                                        **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n*\n** Set Defaults\n*\n OI    FLAG_X1,$ENQCON                    Looking for ENQ conflicts\n*\n MVI   GQS_RNAMEL,0                       Set to binary zero\n MVI   GQS_RNAME,0                        Set first byte to zero\n MVC   GQS_RNAMEI(4),=AL2(0,MSG1RNME)     Get message insert\n*\n MVC   GQS_QNAMEI(4),=AL2(4+8,MSG1QNME)   Get message insert\n MVC   GQS_QNAME(8),=8C' '                Set field to zero\n*\n** Retrieve the QNAME\n*\n DA#TSOS PDE2STR,WA_DA#TSOS,NAME=PDE_QNAME,OUTPUT=GQS_QNAME\n LTR   R14,R14                            Check length of QNAME\n BZ    P$QNAMEX                           None...\n NI    FLAG_X1,255-$ENQCON                Turn off flag\nP$QNAMEX EQU *\n*\n** Retrieve the RNAME\n*\n DA#TSOS PDE2STR,WA_DA#TSOS,NAME=PDE_RNAME,OUTPUT=GQS_RNAME\n LTR   R14,R14                            Check length of RNAME\n BZ    P$RNAMEX                           None...\n NI    FLAG_X1,255-$ENQCON                Turn off flag\n CLI   GQS_QNAME,C' '                     Got a QNAME\n BNE   P$RNQX                             Yes, continue\n MVC   GQS_QNAME(8),T_ENQCON              Move in \"SYSDSN\"\nP$RNQX EQU *\n BAS   R9,FORMAT_DATASET_NAME             Format dataset name\nP$RNAMEX EQU *\n*\n** Enqueue Conflict processing\n*\n TM    FLAG_X1,$ENQCON                    Enqueue processing?\n BNO   P$ENQCONX                          Nope, move on\n LA    R1,T_ENQCON                        Locate Enqueue Conflict Table\n ST    R1,GQS_ECTLOC                      Save location\n MVC   GQS_QNAME(8),0(R1)                 Move in first QNAME\n*\n XC    GQS_ECCNT(4),GQS_ECCNT             Clear Enqueue Conflict count\nP$ENQCONX EQU *\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Invoke GRS scan facilities to locate this guy               **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Initialization for GQSCAN services                             **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n*\n** Obtain a work area\n*\n#GQS_LEN EQU   16384                      Area length is 16K\n GETMAIN R,LV=#GQS_LEN                    Obtain area for GQSCAN\n ST    R0,GQS_VSL                         Save Area length\n ST    R1,GQS_VSA                         Save Area address\n*\n** Initialize registers and fields\n*\n SLR   R2,R2                              Clear register\n IC    R2,GQS_RNAMEL                      Get length of RNAME\n*\n MVC   INS$JOB(4),=AL2(4+17,MSG1JOB)      Fix PUTLINE message header\n MVC   INS$ST(4),=AL2(4+3,MSG1ST)         Fix PUTLINE message header\n MVC   INS$ACT(4),=AL2(0,MSG1ACT)         Fix PUTLINE message header\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**   Process the request                                             **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\nGQS$ECLOOP EQU *\n XC    GQS_TOKEN(4),GQS_TOKEN             Clear Token\n*\n MVC   GQS_QNAMEI(2),=AL2(4+8)            Reset full length\n LA    R15,GQS_QNAMEI                     Locate field\n BAS   R9,TRIM_TRAILING_BLANKS            Trim trailing blanks\n*\nGQS$LOOP EQU   *\n AGO .E1X\n*\n** Establish ESATE exit for GQSCAN S90A abends\n*\n MVC   PARMLIST(C_ESTAEL),C_ESTAE         Initialize ESATE param. list\n L     R0,=V(WHOHASE)                     Locate ESTAE routine\n LA    R1,E$ESTAE                         Locate error routine\n ST    R1,GQS_PARMS                       Save it\n ST    R13,GQS_PARMS+4                    Save our Register Save Area\n LA    R6,GQS_PARMS                       Locate our parm address\n ESTAE (0),PARAM=((6)),                   Establish ESTAE for GQSCAN   @\n               MF=(E,PARMLIST)\n.E1X ANOP ,\n*\n** Make inquiry into GRS via GQSCAN\n*\n L     R6,GQS_VSA                         Locate Area address\n MVC   PARMLIST(C_GQSL),C_GQS             Initialize GQSCAN parm list\n GQSCAN AREA=((R6),#GQS_LEN),                                          @\n               SCOPE=ALL,                                              @\n               TOKEN=GQS_TOKEN,                                        @\n               RESNAME=(GQS_QNAME,GQS_RNAME,(R2),GENERIC),             @\n               MF=(E,PARMLIST)\n*\n** Save Return Code from GQSCAN execution\n*\n ST    R0,GQS_RIB                         Save RIB | RIBE length\n ST    R1,GQS_RIBN                        Number of RIBs in area\n STC   R15,GQS_RC                         Save return code\n AGO .E2X\n*\n** Remove our ESTAE routine\n*\n ESTAE 0                                  Remove ESTAE\n.E2X ANOP ,\n*\n** Check valid Return codes\n*\n CLI   GQS_RC,0                           Everything okay?\n BE    GQS$OK                             Yep, move on\n CLI   GQS_RC,8                           Everything okay?\n BE    GQS$OK                             Yep, move on\n TM    FLAG_X1,$ENQCON                    Checking enqueue Conflicts?\n BO    GQS$ECLOOPX                        Yes, skip error message...\n B     E$GQSCAN                           Error: QNAME/RNAME not found\nGQS$OK EQU *\n*\n** Dump the RIB\n*\n*DA#TSOS KWCHK,NAME=KWDUMP,ERRET=GQS$DRIBX\n*LA    R9,RIBEND-RIB                      Generate length of RIB\n*CALL,SUB=HEXDUMP,PARAM=((6),(9),C_RIB),MF=(E,PARMLIST)\nGQS$DRIBX EQU *\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**   Process the Resource Information Block - Extent                 **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\nGQS$RIBL EQU   *\n*\n** Locate the first RIBE in the RIB\n*\n LR    R7,R6                              RIB locate starting point\n SLR   R1,R1                              Clear register\n ICM   R1,B'0011',GQS_RIB                 Get length of RIB\n AR    R7,R1                              Locate RIBE\n AH    R7,RIBVLEN-RIB(R6)                 ..past the variable area\n L     R8,RIBNRIBE-RIB(R6)                Number of RIBE for RIB\nGQS$RIBEL EQU  *\n*\n** Dump the RIBE (if option on)\n*\n* KWCHK,NAME=KWDUMP,ERRET=GQS$DRIBEX\n*LH    R9,GQS_RIBE                        Get length of RIBE\n*CALL,SUB=HEXDUMP,PARAM=((7),(9),C_RIBE),MF=(E,PARMLIST)\nGQS$DRIBEX EQU *\n*\n** Check for ENQ conflict\n*\n TM    FLAG_X1,$ENQCON                    Checking only conflicts?\n BNO   GQS$RIBCX                          Nope, move on\n*\n CLC   RIBNTWE-RIB(4,R6),=X'00,00,00,00'  Waiting exclusive?\n BNE   GQS$RIBC                           Yes, move on\n CLC   RIBNTWS-RIB(4,R6),=X'00,00,00,00'  Waiting shared?\n BE    GQS$RIBB                           Nope, skip this guy\nGQS$RIBC  EQU *\n L     R1,GQS_ECCNT                       Get count\n LA    R1,1(R1)                           Increment by 1\n ST    R1,GQS_ECCNT                       Save count\nGQS$RIBCX EQU *\n*\n** Complete detail line\n*\n MVC   INS$JOB+4(17),=17C' '\n ICM   R1,B'1111',RIBEUCB-RIBE(R7)        Get UCB address\n BZ    GQS$JOBN                           None, we have job info\n LA    R15,INS$JOB\n MVC   0(4,R15),=C'UCB:'\n LA    R15,5(R15)\n UNPK  0(5,R15),UCBCHAN-UCBOB(3,R1)      Get UCB name\n MVZ   0(4,R15),=8X'00'                  Get UCB name\n TR    0(4,R15),=C'0123456789ABCDEF'     Get UCB name\n MVI   4(R15),C' '\n MVC   5(6,R15),UCBVOLI-UCBOB(R1)        Move in volume serial\n B     GQS$JOBNX\nGQS$JOBN EQU *\n L     R1,CVTPTR\n CLC   RIBESYSN-RIBE(8,R7),CVTSNAME-CVTMAP(R1)\n BNE   GQS$JOBNS\n LOCASCB ASID=RIBEASID-RIBE(R7)           Locate Address Space C.B.\n LTR   R15,R15                            Find it?\n BNZ   GQS$JOBNR\n L     R14,ASCBASSB-ASCB(,R1)             -> ASSB\n ICM   R14,B'1111',ASSBJSAB-ASSB(R14)     -> JSAB\n BZ    GQS$JOBNR                          No JSAB?\n CLC   JSABJBID-JSAB(8,R14),=8X'00'       Have a JES jobnumber?\n BE    GQS$JOBNR                          No, continue\n MVC   INS$JOB+4+0(8),JSABJBID-JSAB(R14)  Get jobid\n MVI   INS$JOB+4+8,C'-'                   Insert dash\n MVC   INS$JOB+4+9(8),RIBEJBNM-RIBE(R7)   Move in Job Name\n B     GQS$JOBNX\nGQS$JOBNS EQU *\n MVC   INS$JOB+4(8),RIBESYSN-RIBE(R7)\n MVI   INS$JOB+4+8,C'>'\n MVC   INS$JOB+4+9(8),RIBEJBNM-RIBE(R7)   Move in Job Name\n B     GQS$JOBNX\nGQS$JOBNR EQU *\n MVC   INS$JOB+4+0(4),=C'ASID'\n UNPK  INS$JOB+4+4(5),RIBEASID-RIBE(3,R7)\n MVZ   INS$JOB+4+4(4),=8X'00'\n TR    INS$JOB+4+4(4),=C'0123456789ABCDEF'\n MVI   INS$JOB+4+8,C'-'                   Insert dash\n MVC   INS$JOB+4+9(8),RIBEJBNM-RIBE(R7)   Move in Job Name\nGQS$JOBNX EQU *\n*\n TM    RIBERFLG-RIBE(R7),RIBETYPE\n BO    GQS$STS\n MVC   INS$ST+4(3),=C'EXC'\n B     GQS$STX\nGQS$STS EQU *\n MVC   INS$ST+4(3),=C'SHR'\nGQS$STX EQU *\n*\n TM    RIBESFLG-RIBE(R7),RIBESTAT\n BO    GQS$ACTH\n MVC   INS$ACT(2),=AL2(4+10)\n MVC   INS$ACT+4(10),=C'is waiting'\n B     GQS$ACTX\nGQS$ACTH EQU *\n MVC   INS$ACT(2),=AL2(4+5)\n MVC   INS$ACT+4(5),=C'holds'\nGQS$ACTX EQU *\n*\n** Get the returned RNAME from the generic request\n*\n SLR   R1,R1\n IC    R1,RIBRNMLN-RIB(R6)\n BCTR  R1,0\n EX    R1,GQS$XM1\n LA    R1,5(R1)\n STH   R1,GQS_RNAMEI\n*\n DA#TSOS PRTMSG,WA_DA#TSOS,MSG=(MSG1,                                 @@\n               INS$JOB,INS$ACT,GQS_QNAMEI,INS$ST,GQS_RNAMEI)\n*\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**   Any more work to do                                             **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\nGQS$RIBB EQU *\n*\n** Any more RIBEs\n*\n SLR   R1,R1                              Clear register\n ICM   R1,B'0011',GQS_RIBE                Get length of RIBE\n AR    R7,R1                              Bump to end of RIBE\n BCT   R8,GQS$RIBEL                       Do next one\n*\n** Any more RIBs\n*\n LR    R6,R7                              Set address of next RIB\n*\n L     R1,GQS_RIBN                        Get number of RIBs left\n BCTR  R1,0                               Decrement by one\n ST    R1,GQS_RIBN                        Get number of RIBs left\n LTR   R1,R1                              Check out number\n BNZ   GQS$RIBL                           It not over yet, Fly Boy\n*\n** More RIBs than could fit in the area?\n*\n CLI   GQS_RC,X'08'                       More stuff?\n BE    GQS$LOOP                           Yes, do it\n*\n** Enqueue Conflict processing\n*\n TM    FLAG_X1,$ENQCON                    Doing Enqueue Conflicts\n BNO   GQS$X                              Nope, end of the line bubba\nGQS$ECLOOPX EQU *\n L     R1,GQS_ECTLOC                      Get location in the table\n LA    R1,8(R1)                           Bump to next one\n CLI   0(R1),X'FF'                        At the end of the table?\n BE    GQS$X                              Yes, bye bye\n ST    R1,GQS_ECTLOC                      Save current location in tab.\n MVC   GQS_QNAME(8),0(R1)                 Set QNAME\n B     GQS$ECLOOP                         Do some more\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**   Common Exit from GQSCAN processing                              **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\nGQS$X EQU *\n*\n** Free the GQS area\n*\n L     R0,GQS_VSL                         Get area length\n L     R1,GQS_VSA                         Get area address\n FREEMAIN R,LV=(0),A=(1)                  Free the area\n*\n** Check ENQ conficts count: Did we catch anything?\n*\n TM    FLAG_X1,$ENQCON                    Processing ENQ conflicts\n BNO   GQS$XECX                           Nope, move on\n CLC   GQS_ECCNT(4),=X'00,00,00,00'       Find anything?\n BNE   GQS$XECX                           Yes, move on\n DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG2\n*MVI   MAXCC,$WARN                        Set condition code\nGQS$XECX EQU *\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Termination section                                         **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nEXIT EQU *\n*\n** Terminate TSO stuff\n*\nX$TSOX EQU *\n DA#TSOS TERM,WA_DA#TSOS\n*\n** Return to caller\n*\n DA#LEAVE ,\n EJECT\n***********************************************************************\n***                                                                 ***\n**       Error routines                                              **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n*\n** Error from GQSCAN execution\n*\nE$GQSCAN EQU *\n*\n CLC   GQS_QNAME(8),=CL8'SYSDSN'          Is this for QNAME=SYSDSN?\n BNE   EGQS$SDX\n CLI   GQS_RC,4                           Normal not enqueued?\n BNE   EGQS$SDX\n MVC   INS$JOB+4(12),=CL12'No job'\n MVC   INS$ACT(2),=AL2(4+5)\n MVC   INS$ACT+4(5),=C'holds'\n MVC   INS$ST+4(3),=C'   '\n*-Since MSG9 is a clone of MSG1, we can use the same insert offsets\n DA#TSOS PRTMSG,WA_DA#TSOS,MSG=(MSG9,                                 @@\n               INS$JOB,INS$ACT,GQS_QNAMEI,INS$ST,GQS_RNAMEI)\n B     GQS$X                              Free the Work area\nEGQS$SDX DS 0H\n*\n SLR   R1,R1                              Clear register\n IC    R1,GQS_RC                          Obtain the return code\n DA#TSOS EDITR1,OUTPUT=INS$RC,MF=(E,PARMLIST)\n MVC   INS$RC+2(2),=AL2(MSG3RC)           Fix offset\n*\n BAS   R9,FIND_GQSCAN_ERROR               Find error, return in R8\n*\n DA#TSOS PRTMSG,WA_DA#TSOS,MSG=(MSG3,INS$RC,(8))\n* Note: We could print the QNAME/RNAME here...\n*MVI   MAXCC,$SEVERE                      Set return code\n B     GQS$X                              Free the Work area\n*\n** Error: GQSCAN abended, ABEND code in GQS_PARM+4\n*\nE$ESTAE EQU *\n*ESTAE 0                                  Remove ESTAE\n*MVI   MAXCC,$SEVERE                      Set return code\n DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG8\n B     GQS$X                              Free GETMAINed area\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**        Find GQSCAN error                                          **\n**                                                                   **\n**        Input: GQS_RC                                              **\n**        Output: R8 - address of description insert                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nFIND_GQSCAN_ERROR EQU   *\n LA    R0,T_GQSE                         Number of entries\n LA    R1,T_GQS                          Locate table\nFGE$LOOP EQU   *\n CLC   GQS_RC(1),1(R1)                   Return code match?\n BE    FGE$LOOPX                         Yes, leave loop\n LA    R1,2+2+4(R1)                      No, bump to next entry\n BCT   R0,FGE$LOOP                       ..do it\n LA    R8,GQS002                         Move in default\n BSM   0,R9                              Return to caller\nFGE$LOOPX EQU  *\n L     R8,2+2(R1)                        Load description address\n BSM   0,R9                              Return to caller\n*\n**  Table\n*\nT_GQS    EQU   *\n         DC    AL2(4,0),AL4(GQS001)\n         DC    AL2(8,0),AL4(GQS002)\n         DC    AL2(12,0),AL4(GQS003)\n         DC    AL2(16,0),AL4(GQS004)\n         DC    AL2(20,0),AL4(GQS005)\nT_GQSE   EQU   ((*-T_GQS)/(2+2+4))\n*\nGQS001   DC    AL2(GQS001L,MSG3DESC)\n         DC    C'No resources matched your request'\nGQS001L EQU    *-GQS001\n*\nGQS002   DC    AL2(GQS002L,MSG3DESC)\n         DC    C'See manual \"SPL: System Macros\" -'\n         DC    C'dependent on application'\nGQS002L EQU    *-GQS002\n*\nGQS003   DC    AL2(GQS003L,MSG3DESC)\n         DC    C'Encountered an abnormal situaltion while processing'\nGQS003L EQU    *-GQS003\n*\nGQS004   DC    AL2(GQS004L,MSG3DESC)\n         DC    C'Invalid SYSNAME was specified as input to GQSCAN'\nGQS004L EQU    *-GQS004\n*\nGQS005   DC    AL2(GQS005L,MSG3DESC)\n         DC    C'Information returned by GQSCAN not complete'\nGQS005L EQU    *-GQS005\n DS 0H\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Misc Internal Subroutines                                   **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n*\n** Trim trailing blanks from an insert\n**\n** Input: R15 - points to a message insert with full length\n*\nTRIM_TRAILING_BLANKS EQU *\n DA#TSOS TRIM,MF=(E,(15))               Trim trailing blanks\n BSM   0,R9\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Format Dataset name                                        **\n**                                                                   **\n**        Input: R14 has RNAME - 1                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nFORMAT_DATASET_NAME EQU *\n*\n** Check for enqueues which have a RNAME that is a Dataset\n*\n CLC   GQS_QNAME(6),TE_SYSD               SYSDSN?\n BE    FDN$S\n CLC   GQS_QNAME(7),TE_SPFE               SYSEDIT?\n BE    FDN$S\n CLC   GQS_QNAME(6),TE_SPFD               SPFDSN?\n BNE   FDN$X\n*\n** Startup\n*\nFDN$S EQU *\n EX    R14,FDN$XM1                        Save copy of RNAME/DSN\n LA    R2,GQS_RNAME                       Locate beg\n MVI   0(R2),C' '                         Move in blank\n MVC   1(44-1,R2),0(R2)                   ..propagate it\n CLI   PARMLIST,X'7D'                     Begins with a quote?\n BE    FDN$Q                              Yes, do quote code\n*\n** Unquoted dataset needs prefix added to beginning\n*\n DA#TSOS GETCPPL,WA_DA#TSOS,WRKREG=1      -> CPPL\n L     R1,CPPLUPT-CPPL(R1)                -> UPT\n SLR   R15,R15                            Clear register\n IC    R15,UPTPREFL-UPT(R1)               Obtain prefix length\n BCTR  R15,0                              Decrement for EX\n EX    R15,FDN$XM2                        Move prefix to RNAME\n LA    R2,1(R15,R2)                       Bump past prefix\n MVI   0(R2),C'.'                         Insert a dot\n EX    R14,FDN$XM3                        Move unprefixed part out\n AR    R14,R15                            Add prefix + suffix\n LA    R14,1+1(R14)                       Add: EX + \".\"\n B     FDN$C\n*\n** Handle quoted dataset name\n*\nFDN$Q EQU *\n SH    R14,=AL2(2)                        Remove for both quotes...\n EX    R14,FDN$XM4                        Move unquoted RNAME/DSN\n*\n** Common code: ensure that dataset exists\n*\nFDN$C EQU *\n LR    R3,R14                             Save RNAME length\n MVC   PARMLIST(C_LOCATEL),C_LOCATE       Move in parameter list\n LA    R1,GQS_RNAME                       Locate the Data Set Name\n ST    R1,PARMLIST+4                      Save into parmeter list\n LA    R1,W_CAMLST                        Locate the work area\n ST    R1,PARMLIST+12                     Save into parmeter list\n LOCATE PARMLIST                          Is the Data set catalogued?\n LTR   R15,R15                            Well?\n BZ    FDN$CX                             Nope, move on\n DA#TSOS PRTMSG,WA_DA#TSOS,MSG=MSG7\nFDN$CX EQU *\n LR    R14,R3                             Restore RNAME length\n*\n** Exit: Save RNAME length fields\n*\nFDN$X EQU *\n LA    R14,1(R14)                         Increment for EX\n STC   R14,GQS_RNAMEL                     Save length\n LA    R14,4(R14)                         Add length of message insert\n STH   R14,GQS_RNAMEI                     Set length of Message insert\n BSM   0,R9                               Return to caller\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Data Constants                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nGQS$XM1  MVC   GQS_RNAME(0),RIBEND-RIB(R6)\nFDN$XM1  MVC   PARMLIST(0),GQS_RNAME\nFDN$XM2  MVC   0(0,R2),UPTPREFX-UPT(R1)\nFDN$XM3  MVC   1(0,R2),PARMLIST\nFDN$XM4  MVC   0(0,R2),PARMLIST+1\n*\nMSG1     DC    AL2(MSG1L,0)\nMSG1S    EQU   *\n         DC    C'WHOHAS-01I '\nMSG1JOB  EQU   *-MSG1S\n         DC    C' '\nMSG1ACT  EQU   *-MSG1S\n         DC    C' '\nMSG1QNME EQU   *-MSG1S\n         DC    C' '\nMSG1ST   EQU   *-MSG1S\n         DC    C': '\nMSG1RNME EQU   *-MSG1S\n         DC    C' '\nMSG1L    EQU   *-MSG1\n*\nMSG2     DC    AL2(MSG2L,0)\n         DC    C'WHOHAS-02I '\n         DC    C'There are no ENQ conflicts!'\nMSG2L    EQU   *-MSG2\n*\nMSG3     DC    AL2(MSG3L,0)\nMSG3S    EQU   *\n         DC    C'WHOHAS-03E '\n         DC    C'GQSCAN error: RC='\nMSG3RC   EQU   *-MSG3S\n         DC    C', '\nMSG3DESC EQU   *-MSG3S\n         DC    C' '\nMSG3L    EQU   *-MSG3\n*\nMSG7     DC    AL2(MSG7L,0)\n         DC    C'WHOHAS-07W '\n         DC    C'Data set is not catalogued'\nMSG7L    EQU   *-MSG7\n*\nMSG8     DC    AL2(MSG8L,0)\n         DC    C'WHOHAS-08I '\n         DC    C'GQSCAN abend occurred processing your request'\nMSG8L    EQU   *-MSG8\n*\nMSG9     DC    AL2(MSG9L,0)\nMSG9S    EQU   *\n         DC    C'WHOHAS-09E '\nMSG9JOB  EQU   *-MSG9S\n         DC    C' '\nMSG9ACT  EQU   *-MSG9S\n         DC    C' '\nMSG9QNME EQU   *-MSG9S\n         DC    C' '\nMSG9ST   EQU   *-MSG9S\n         DC    C': '\nMSG9RNME EQU   *-MSG9S\n         DC    C' '\nMSG9L    EQU   *-MSG9\n*\nMSG10    DC    AL2(MSG10L,0)\n         DC    C'WHOHAS-10E '\n         DC    C'This system is not at MVS version 4 or higher'\nMSG10L   EQU   *-MSG10\n*\n*\n** Copy code\n*\nC_RIB    DC    AL1(C_RIBL-2),C'RIB'\nC_RIBL   EQU   *-C_RIB\nC_RIBE   DC    AL1(C_RIBEL-2),C'RIBE'\nC_RIBEL  EQU   *-C_RIBE\nC_LOCATE CAMLST NAME,*-*,,*-*\nC_LOCATEL EQU  *-C_LOCATE\n*\nC_ESTAE ESTAE  MF=L\nC_ESTAEL EQU   *-C_ESTAE\n*\nC_GQS   GQSCAN AREA=(*-*,*-*),                                         @\n               SCOPE=ALL,                                              @\n               TOKEN=*-*,                                              @\n               RESNAME=(*-*,*-*,*-*),                                  @\n               MF=L\nC_GQSL  EQU    *-C_GQS\n*\n** Literals used in program\n*\n LTORG ,\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Table of QNAME to use for ENQ conflicts                     **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nT_ENQCON EQU   *\nTE_SYSD  DC    CL8'SYSDSN'\nTE_SPFE  DC    CL8'SPFEDIT '\nTE_SPFD  DC    CL8'SPFDSN  '\n         DC    CL8'SYSIEA01'\n         DC    CL8'SYSIEFSD'\n         DC    CL8'SYSIEWLP'\n         DC    CL8'SYSIGGV1'\n         DC    CL8'SYSIGGV2'\n         DC    CL8'SYSIKJBC'\n         DC    CL8'SYSIKJUA'\n         DC    CL8'SYSSMF01'\n         DC    CL8'SYSVSAM'\n         DC    CL8'SYSVTOC'\n         DC    CL8'SYSZCAXW'\n         DC    CL8'SYSZCOMM'\n         DC    CL8'SYSZJES2'\n         DC    CL8'SYSZJWTP'\n         DC    CL8'SYSZOPEN'\n         DC    CL8'SYSZPCCB'\n         DC    CL8'SYSZRPLW'\n         DC    CL8'SYSZSIPS'\n         DC    CL8'SYSZSMF1'\n         DC    CL8'SYSZTIOT'\n         DC    CL8'SYSZVARY'\n         DC    CL8'SYSZVOLS'\n         DC    CL8'SYSZWTOR'\n         DC    X'FF'                      End of the table\n         DS    0D\n EJECT\n***********************************************************************\n***                                                                 ***\n**       PARSE descriptors                                           **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nWHOHASP CSECT ,\nWHOHASP AMODE 31\nWHOHASP RMODE ANY\nWHOHASP IKJPARM ,\nPDE_RNAME IKJIDENT 'RNAME',                                            @\n               MAXLNTH=255,FIRST=ANY,OTHER=ANY,                        @\n               HELP=('The RNAME to use to inquire GRS')\nPDE_QNAME IKJIDENT 'QNAME',                                            @\n               MAXLNTH=8,FIRST=ANY,OTHER=ANY\n*\n** Keyword: TYPE\n*\nKWDUMP   IKJKEYWD ,\n$KWDUMP  EQU   1\n         IKJNAME 'DUMP'\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**                 End of Parse definitions                          **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\n IKJENDP ,\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       GETMAINed work area                                         **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nDSA      DSECT ,\n         DS    18F                        Register Save Area\nR1SAVE   DS    F                          R1 (CPPL) on entry\nWA_DA#TSOS DS  XL(DA#TSOSDL)              CPPL/PUTLINE/PARSE code\n*\n** Misc fields\n*\n           DS 0D\nDOUBLE     DS D\nDWA        DS 2D\nPARMLIST   DS XL(C_GQSL)                  Parameter list area\n*\n** GQSCAN areas\n*\n           DS  0F                         Virtual Storage obtained\nGQS_VSA    DS  F                          ..Address\nGQS_VSL    DS  F                          ..Length\nGQS_PARMS  DS  2F                         Parameter area for ESTAE\nGQS_TOKEN  DS  F                          Token\nGQS_RIB    DS  H                          Length of RIB\nGQS_RIBE   DS  H                          Length of RIBE\nGQS_RIBN   DS  F                          Number of RIBs in area\nGQS_ECCNT  DS  F                          ENQ Conflict: Count\nGQS_ECTLOC DS  F                          ENQ Conflict: Table location\n*\nGQS_QNAMEI DS  XL4                        QName PUTLINE message insert\nGQS_QNAME  DS  CL8                        QName literal\n*\nGQS_RNAMEI DS  XL4                        RName PUTLINE message insert\nGQS_RNAME  DS  CL255                      RNAME literal\nGQS_RNAMEL DS  X                          RNAME length\n*\nGQS_RC     DS  X                          GQSCAN return code\n*\n** Execution Flags\n*\nFLAG_X1  DS    B'00000000'                Flag: Execution 1\n$ENQCON  EQU   B'10000000'                ..Enqueue Conflict checks?\n*\n** Message inserts\n*\nINS$JOB   DS  XL36\nINS$ST    DS  XL36\nINS$ACT   DS  XL36\nINS$RC    DS  XL36\n*\n           DS 0D\nW_CAMLST   DS XL265\n           DS 0D\nDSAL     EQU   *-DSA                      Reset addressiblity\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**           ESTAE exit for GQSCAN ABENDS                            **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nWHOHASE CSECT ,\nWHOHASE AMODE 31\nWHOHASE RMODE ANY\n USING WHOHASE,R15\n*\n** Standard O/S Module Eyecatcher\n*\n B     WHOHASE_ECX\n DC    AL1(WHOHASE_ECL)\nWHOHASE_EC   EQU *\n DC    C'WHOHASE  &ASMDATE. &SYSTIME. V&DAVER ESTAE_ROUTINE'\nWHOHASE_ECL EQU *-WHOHASE_EC\nWHOHASE_ECX DS   0H\n*\n** Can we attempt retry?\n*\n CH    R0,=H'12'                          SDWA present?\n BE    WHOHASE_ABEND                      Nope, leave\n TM    SDWAERRD-SDWA(R1),SDWACLUP         Can we perform retry?\n BC    1,WHOHASE_ABEND                    Nope, leave\n*\n** Attempt retry\n*\n L     R3,SDWAPARM-SDWA(R1)               Get Parameters\n L     R13,4(R3)                          Get WHOHAS RSA\n*LM    R10,R12,XXXXXXX_RSA_R10-XXXXXXX_RSA(R13) Restore registers\n L     R4,SDWAABCC-SDWA(R1)               Get ABEND code\n ST    R4,4(R3)                           Save it for later use\n L     R4,0(R3)                           Get retry address\n SETRP RC=4,RETADDR=(4),RECORD=NO\n BSM   0,R14\n*\n** Continue with ABEND\n*\nWHOHASE_ABEND EQU *\n SETRP RC=0\n BSM   0,R14\n*\n** Literals for WHOHASE\n*\n LTORG ,\n END ,\n EJECT\n***********************************************************************\n***                                                                 ***\n**       Linkage editor cards                                        **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n PUNCH ' ENTRY   DA$ENQS         '        Entry point\n PUNCH ' ALIAS   WHOHAS          '        Alias\n PUNCH ' NAME    DA$ENQS(R)      '        Name of load module\n END ,\n./ ADD NAME=DA$EREP  0100-01266-01266-1821-02210-02210-00000-DAVE\nDA$EREP  TITLE 'EREP (LOGREC) ISPF application - ACCIN to ISPF table'\n* =================================================================== *\n*\n* Name: DA$EREP\n*\n* Author = David Alcock :: dave@planetmvs.com\n*\n* Purpose: This program is part of an ISPF application to display\n*          Software LOGREC entries in an ISPF table for easy\n*          perusal.  This makes it very easy to invoke EREP to\n*          get a report on a particular LOGREC entry.\n*\n*          This program must be invoked by a CLIST or EXEC that:\n*          - Allocates file ACCIN to the reduced LOGREC file\n*          - Creates table LRSTABLE and passes its name to us\n*          - Creates table SUMTABLE and passes its name to us\n*          - Creates table STATABLE and passes its name to us\n*          - And most important - displays the result!\n*\n* Reference: GC28-1378 EREP User's Guide\n*            GC28-1670 MVS/ESA SYS1.LOGREC Error Recording\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n*  Programs called:\n*  - DA$DATE....Date routine\n*  - ISPLINK....ISPF interface module\n*\n*  Non-Standard Macro Usage:\n*  - DA#ENTER...Entry Housekeeping\n*  - DA#LEAVE...Exit Housekeeping\n*  - DA#EYEC....Create module eyecatcher (invoked by DA#ENTER)\n*  - DA#REGS....Generate register equates (invoked by DA#ENTER)\n*  - DA#STR.....Generate a string array with byte length (-1)\n*  - DA#DATE....Equates used invoking the DA#DATE date routine\n*  - DA#MXD.....Mini-Hex-Dump routine DSECTs and equates\n*\n* Limitations:\n* - MVS EREP format. The Software entries are mapped by IHAHDR\n*   which IBM doesn't put into SYS1.MACLIB or SYS1.MODGEN.  We\n*   are left to hardcode our own SFT DSECT (from EREP manual).\n* - Assemble with Assembler H, HLASM or higher\n*\n*\n* =================================================================== *\n         SPACE 2\n&DAVER   SETC  '2.3'\n*======================================================================\n*\n*             M o d i f i c a t i o n   H i s t o r y\n*\n* Person      Date       Description\n* ----------  ---------- ----------------------------------------------\n* Dave Alcock 2000-03-02 v2.3:\n*                        - Fix edit pattern for LRSDATEJ for sig dig;\n*                        - Count number of recs with 1900 century;\n* Dave Alcock 2000-01-05 v2.2:\n*                        - Added Date windowing code for the bad\n*                          EREP records that IBM is creating;\n* Dave Alcock 2000-01-04 v2.1:\n*                        - Added Debugging code (output to //DA$EREP);\n*                        - Added new base register 10;\n* Dave Alcock 1999-12-29 v2.0:\n*                        - Use ISO date format CCYY-MM-DD\n*                        - DA$DATE subroutine needs to be 1999-09-09 or\n*                          better (has ISO ccyy-mm-dd support);\n* Dave Alcock 1997-06-21 Removed Guide/SPF macro requirement;\n* Dave Alcock 1996-11-11 Removed code that read SYS1.LOGREC (It wasn't\n*                        fully implemented anyway);\n* Dave Alcock 1995-11-11 Added external CPU table support;\n* Dave Alcock 1993-10-30 Added support to read SYS1.LOGREC;\n* Dave Alcock 1991-09-25 Rewritten to seperate installation code,\n*                        made Reentrant, 31 bit addressibility,\n*                        create stats table, Add X'4C' symptom\n*                        record processing;\n*======================================================================\n         SPACE 2\n*\n** IBM DSECTs\n*\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA           Data Control Block\n         IKJTSVT ,                        TSO Vector Table\n         CVT   DSECT=YES,LIST=NO          Communications Vector Table\n         PRINT GEN\n         EJECT ,\n         ADSR  ,                          Symptom String\n         EJECT ,\n         IHALRB ,                         Logrec Buffer map (hardware)\n         EJECT ,\n         IHASDWA ,                        System Diagnostic Work Area\n*\n** Non-IBM DSECTs\n*\n         DA#DATE ,                        Date routine\n         DA#MXD ,                         Mini-Hex-Dump\n*\n** Misc Equates\n*\n#MAXMOD  EQU   2048                       Maximum modules in Summary\n#MAXCPUN EQU   128                        Maximum CPUs to count\n#STATUSL EQU   500                        Update status - lrstable\n#STATUSS EQU   100                        Update status - sumtable\n#MAXCPUS EQU   256                        Maximum CPU Serial numbers\n         EJECT ,\n*\n** Entry housekeeping code\n*\nDA$EREP  DA#ENTER 'V&DAVER Subroutine: Process EREP records',          @\n               AMODE=31,RMODE=ANY,        ..Residency                  @\n               BASE=(12,11,10),           ..Base registers             @\n               LV=DSAL,RENT=YES           ..Dynamic Save Area\n         USING DSA,R13                    Get addressability\n         EJECT ,\n***********************************************************************\n***\n**       Misc initializations\n***\n***********************************************************************\n         SPACE 2\n*\n** Load external modules\n*\n         ICM   R0,B'1111',=V(DA$DATE)     Is it linked into us?\n         BNZ   I$DATES                    Yes, use it\n         LA    R8,=CL8'DA$DATE'           Locate module name\n         LOAD  EPLOC=(8),ERRET=I$DATEX    Load it\n         OI    FLAG2,$F2LDATE             Indicate we loaded it\nI$DATES  EQU   *\n         ST    R0,EP_DA$DATE              Save entry point address\nI$DATEX  EQU   *\n*\n         ICM   R0,B'1111',=V(DA$MXD)      Is it linked into us?\n         BNZ   I$MXDS                     Yes, use it\n         LA    R8,=CL8'DA$MXD'            Locate module name\n         LOAD  EPLOC=(8),ERRET=I$MXDX     Load it\n         OI    FLAG2,$F2LMXD              Indicate we loaded it\nI$MXDS   EQU   *\n         ST    R0,EP_DA$MXD               Save entry point address\nI$MXDX   EQU   *\n*\n         ICM   R0,B'1111',=V(ISPLINK)     Is it linked into us?\n         BNZ   I$ISPLS                    Yes, use it\n         LA    R8,=CL8'ISPLINK'           Locate module name\n         LOAD  EPLOC=(8),ERRET=I$ISPLE    Load it\n         OI    FLAG2,$F2LISPL             Indicate we loaded it\n         B     I$ISPLS\nI$ISPLE  DS    0H\n ABEND 1\nI$ISPLS  DS    0H\n         ST    R0,EP_ISPLINK              Save entry point address\nI$ISPLX  EQU   *\n*\n** Obtain storage for Unknown record count\n*\n         LA    R0,256*4                   Set length of table\n         GETMAIN R,LV=(0)                 Obtain storage\n         STM   R0,R1,URCT_ST              Save length and address\n         LR    R14,R1                     To: Address\n         LR    R15,R0                     To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table\n*\n** Obtain storage for CPU count table\n*\n         LA    R0,#MAXCPUN*CPUCL          Set length of table\n         GETMAIN R,LV=(0)                 Obtain storage\n         STM   R0,R1,CPUC_ST              Save length and address\n         MVI   0(R1),X'FF'                Set end of table\n         AR    R1,R0                      Locate end of storage area\n         SH    R1,=AL2(CPUCL)             Backup to last entry\n         BCTR  R1,0                       Backup 1\n         ST    R1,CPUC_END                Save it\n*\n** Misc inits\n*\n         MVC   PAR_SDAT(10),=10X'FF'        Ensure first check works\n*\n** Define row variables for LRSTABLE and obtain table name\n*\n*->      VDEFINE '(LRSTIME)',LRSTIME,CHAR,11,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSTIME)',             ..Name                       @\n               LRSTIME,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'11'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSDATEJ)',LRSDATEJ,CHAR,6,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSDATEJ)',            ..Name                       @\n               LRSDATEJ,                  ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'6'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSDATEG)',LRSDATEG,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSDATEG)',            ..Name                       @\n               LRSDATEG,                  ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'10'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSDAY)',LRSDAY,CHAR,3,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSDAY)',              ..Name                       @\n               LRSDAY,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'3'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSBTIME)',LRSBTIME,FIXED,4,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSBTIME)',            ..Name                       @\n               LRSBTIME,                  ..Location                   @\n               =CL8'FIXED',               ..Format                     @\n               =F'4'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSBDATE)',LRSBDATE,FIXED,4,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSBDATE)',            ..Name                       @\n               LRSBDATE,                  ..Location                   @\n               =CL8'FIXED',               ..Format                     @\n               =F'4'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSDAYN)',LRSDAYN,FIXED,1,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSDAYN)',             ..Name                       @\n               LRSDAYN,                   ..Location                   @\n               =CL8'FIXED',               ..Format                     @\n               =F'1'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSTYPE)',LRSTYPE,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSTYPE)',             ..Name                       @\n               LRSTYPE,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSJOBN)',LRSJOBN,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSJOBN)',             ..Name                       @\n               LRSJOBN,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSCOMP)',LRSCOMP,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSCOMP)',             ..Name                       @\n               LRSCOMP,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSCSCT)',LRSCSCT,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSCSCT)',             ..Name                       @\n               LRSCSCT,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSREAS)',LRSREAS,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSREAS)',             ..Name                       @\n               LRSREAS,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSCPU)',LRSCPU,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSCPU)',              ..Name                       @\n               LRSCPU,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSSEQN)',LRSSEQN,CHAR,5,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSSEQN)',             ..Name                       @\n               LRSSEQN,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'5'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(LRSDESC)',LRSDESC,CHAR,256,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LRSDESC)',             ..Name                       @\n               LRSDESC,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'256'),                  ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VCOPY '(LRSTABLE)',=F'8',LRSTABLE,MOVE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(LRSTABLE)',            ..Name                       @\n               =F'8',                     ..Length                     @\n               LRSTABLE,                  ..Location                   @\n               =CL8'MOVE'),               ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n** ZENVIR on TSO:   \"ISPF 4.5MVS     BATCH\"\n** ZENVIR in Batch: \"ISPF 4.5MVS     BATCH\"\n**                   0....+....1....+....2....\n*\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(ZENVIR)',              ..Name                       @\n               =F'32',                    ..Length                     @\n               ZENVIR,                    ..Location                   @\n               =CL8'MOVE'),               ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         EJECT\n***********************************************************************\n***\n**       Initialize CPU table\n**\n** The next step is to getmain a table and merge the entries from\n** the internal and external tables.\n***\n***********************************************************************\n         SPACE 2\nINITIALIZE_CPU_TABLE EQU *\n*\n** Locate internal table\n*\n         L     R15,=V(CPUS)               Locate CPUs CSECT\n         LA    R15,8(R15)                 Bump past eyecatcher\n         ST    R15,CPUS_ST+4              Save address of internal\n*\n** See if the external table is available, verify that it looks\n** valid and save address for later\n*\n*->      VCOPY '(DA#LRSC)',DA#LRSCL,DA#LRSCA,LOCATE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(DA#LRSC)',             ..Name                       @\n               DA#LRSCL,                  ..Length                     @\n               DA#LRSCA,                  ..Location                   @\n               =CL8'LOCATE'),             ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         ICM   R14,B'1111',DA#LRSCA       Have a variable address?\n         BZ    ICT$X                      No, give up\n         ICM   R15,B'1111',DA#LRSCL       Have a variable length?\n         BZ    ICT$X                      No, give up\n         CH    R15,=AL2(8+CPUSNL+4)       Minimum length?\n         BZ    ICT$TE                     Nope, leave\n         CLC   0(8,R14),=CL8'CPUS4LRS'    Looks like our variable?\n         BNE   ICT$X                      Nope.\n         LA    R14,8(R14)                 Bump past header\n         SH    R15,=H'8'                  Decrement for header length\nICT$L    EQU   *\n         CLC   0(4,R14),=X'FF,FF,FF,FF'   Ending?\n         BE    ICT$LOK                    Yes, looks good\n         LA    R14,CPUSNL(R14)            No, bump to next entry\n         SH    R15,=AL2(CPUSNL)           Decrement length of entry\n         LTR   R15,R15                    Any length left?\n         BNZ   ICT$L                      Yes, continue\nICT$TE   EQU   *\n* Note: we could put something here to let the user know that the\n* table looks invalid\n         B     ICT$X                      No, give up\nICT$LOK  EQU   *\n         L     R1,DA#LRSCA                Locate variable again\n         LA    R1,8(R1)                   Bump past header\n         ST    R1,CPUS_ST+4               Save address for override\n*\n** Common exit from Initialize_CPU_Table processing\n*\nICT$X    EQU   *\n         EJECT\n***********************************************************************\n***\n**       Open files\n***\n***********************************************************************\n         SPACE 2\n*\n** Open the (required) input ACCIN file\n*\n         LA    R3,ACCIN                   Locate DCB work area\n         MVC   0(C_DCBIL,R3),C_DCBI       Initialize DCB area\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'ACCIN'    Get DDNAME\n         MVC   ACCINE(C_DCBIEL),C_DCBIE    Initialize DCBE\n         LA    R14,ACCINE\n         ST    R14,DCBDCBE-IHADCB(R3)     Save DCBE ptr in DCB\n         OI    DCBBFALN-IHADCB(R3),DCBH1+DCBH0 Indicate DCBE is there\n         MVC   PARMLIST(C_LSTIL),C_LSTI   Initialize parameter list\n         OPEN  ((3),(INPUT)),MODE=31,MF=(E,PARMLIST) Open ACCIN\n*\n** Open the (optional) output debug file (DD=DA$EREP) if allocated\n*\n         DEVTYPE =CL8'DA$EREP',DOUBLE     Is file allocated?\n         LTR   R15,R15\n         BNZ   OF$DBX\n         LA    R3,DEBUGOUT                Locate DCB work area\n         MVC   0(C_DCBOL,R3),C_DCBO       Initialize DCB area\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'DA$EREP'  Get DDNAME\n         MVC   DEBUGOUE(C_DCBOEL),C_DCBOE    Initialize DCBE\n         LA    R14,DEBUGOUE\n         ST    R14,DCBDCBE-IHADCB(R3)     Save DCBE ptr in DCB\n*        OI    DCBBFALN-IHADCB(R3),DCBH1+DCBH0 Indicate DCBE is there\n         MVC   PARMLIST(C_LSTOL),C_LSTO   Initialize parameter list\n         OPEN  ((3),(OUTPUT)),MODE=31,MF=(E,PARMLIST) Open Debug file\n         OI    FLAG2,$F2DEBUG\n         DEVTYPE =CL8'DA$EREPD',DOUBLE    Is file allocated?\n         LTR   R15,R15\n         BNZ   OF$DBX\n         OI    FLAG2,$F2DUMP              Dump records to //DA$EREP\nOF$DBX   DS    0H\n         EJECT\n***********************************************************************\n***\n**       Process all ACCIN records\n***\n***********************************************************************\n         SPACE 2\nPROCESS_ACCIN_RECORD EQU *\n*\n** Read record from ACCIN file\n*\nPAR$RR   EQU   *\n         GET   ACCIN                      Get record from //ACCIN\n         LR    R2,R1                      Save Software record\n         LA    R3,ESRSFT-ESR(R2)          Locate SFT part of rec.\n*\n         L     R1,PAR_RECNUM              Physical Record number\n         LA    R1,1(R1)                   Add one (duh)\n         ST    R1,PAR_RECNUM              Save it\n*\n** Initialize row fields\n*\n         MVI   LRSTROW,C' '               Get blank\n         MVC   LRSTROW+1(LRSTROWL-1),LRSTROW ..Propagate it\n         MVI   LRSDESC,C' '               Get blank\n         MVC   LRSDESC+1(L'LRSDESC-1),LRSDESC ..Propagate it\n         MVC   LRSBTIME(4),SFTTIME-SFT(R3)\n         MVC   LRSBDATE(4),SFTDATE-SFT(R3)\n*\n** Date Windowing code to correct for IBM's creating EREP records\n** after 1999-12-31 which are 1900 instead of 2000\n*\n         MVI   CENT1900,C' '\n         CLC   LRSBDATE(4),=X'0065001F'       Below 1965?\n         BH    PAR$DWX\n         MVI   LRSBDATE,X'01'                 Make it 2000\n*-Non-essential code for trivial pursuits\n         L     R1,PAR_C1900\n         LA    R1,1(R1)\n         ST    R1,PAR_C1900\n         MVI   CENT1900,C'*'\nPAR$DWX  DS    0H\n*\n** Time - HH:MM:SS.th\n*\n*->      TM    SFTTIME+3-SFT(R3),B'00001111'  Looks right?\n*->      BNO   PAR$TEX\n         MVC   LRSTIME-1(12),=X'F021207A20207A20204B2020'\n         ED    LRSTIME-1(12),SFTTIME-SFT(R3)\nPAR$TEX  EQU   *\n*\n** Date - YY.DDD and optional DayOfWeek and gregorian date\n*\n*->      TM    SFTDATE+3-SFT(R3),B'00001111'  Looks right?\n*->      BNO   PAR$DEX\n         MVC   LRSDATEJ-1(7),=X'F021204B202020'\n         ED    LRSDATEJ-1(7),LRSBDATE+1\n*        MVI   LRSDATEJ+2,C'.'            \"yy.ddd\"\nPAR$DEX  EQU   *\n*\n         ICM   R15,B'1111',EP_DA$DATE     Date routine available?\n         BNZ   PAR$GD                     Yes, continue\nPAR$DB   EQU   *\n         MVC   LRSDATEG(3),=C'N/A'        Indicate that no Greg. date\n         MVC   LRSDAY(3),=C'N/A'          Indicate that no Day of week\n         B     PAR$GDX                    Continue\nPAR$GD   EQU   *\n*\n         TM    LRSBDATE+0,B'10100000' X'A0'          ! Julian format\n         BO    PAR$DB                                ! Julian format\n         TM    LRSBDATE+0,B'00001010' X'0A'          ! Julian format\n         BO    PAR$DB                                ! Julian format\n         TM    LRSBDATE+1,B'10100000' X'A0'          ! Julian format\n         BO    PAR$DB                                ! Julian format\n         TM    LRSBDATE+1,B'00001010' X'0A'          ! Julian format\n         BO    PAR$DB                                ! Julian format\n         TM    LRSBDATE+2,B'10100000' X'A0'          ! Julian format\n         BO    PAR$DB                                ! Julian format\n         TM    LRSBDATE+2,B'00001010' X'0A'          ! Julian format\n         BO    PAR$DB                                ! Julian format\n         TM    LRSBDATE+3,B'10100000' X'A0'          ! Julian format\n         BO    PAR$DB                                ! Julian format\n         TM    LRSBDATE+3,B'00001010' X'0A'          ! Julian format\n         BNO   PAR$DB                                ! Julian format\n*\n         MVC   W_IDJULP4A(C_IDJULP4AL),C_IDJULP4A Initialize parm\n         LA    R1,LRSBDATE                Locate input julian date\n         ST    R1,W_IDJULP4A_STR          Save it\n         MVC   W_ODISO10A(C_ODISO10AL),C_ODISO10A Initialize parm\n         LA    R1,LRSDATEG                Locate output area\n         ST    R1,W_ODISO10A_STR          Save it\n         MVC   W_ODDOW3A(C_ODDOW3AL),C_ODDOW3A Initialize parm\n         LA    R1,LRSDAY                  Locate output area\n         ST    R1,W_ODDOW3A_STR           Save it\n         MVC   W_ODDOW1A(C_ODDOW1AL),C_ODDOW1A Initialize parm\n         LA    R1,LRSDAYN                 Locate output area\n         ST    R1,W_ODDOW1A_STR           Save it\n*\n         L     R15,EP_DA$DATE             Locate EPA of DA$DATE\n         CALL  (15),(W_IDJULP4A,W_ODISO10A,W_ODDOW3A,W_ODDOW1A),       @\n               VL,MF=(E,PARMLIST)\nPAR$GDX  EQU   *\n*\n** Change CPU serial number to a name for ease of use\n*\n         UNPK  LRSCPU(7),SFTSER-SFT(4,R3)       >\n         MVZ   LRSCPU(6),=8X'00'                >> Hex convert\n         TR    LRSCPU(6),=C'0123456789ABCDEF'   >\n*\n         ICM   R15,B'1111',CPUS_ST+4      Have CPU information?\n         BZ    PAR$CPUE                   No, insert number\nPAR$CPUL EQU   *\n         CLC   LRSCPU(6),CPUSNS-CPUSN(R15) Serial match?\n         BE    PAR$CPUF                   Yes, continue\n         LA    R15,CPUSNL(R15)            No, try next entry\n         CLC   0(4,R15),=X'FF,FF,FF,FF'   End of table?\n         BNE   PAR$CPUL                   No, try it out\nPAR$CPUE EQU   *                          123456x\n         MVI   LRSCPU+6,C' '              Fix byte after UNPK\n         B     PAR$CPUT\nPAR$CPUF EQU   *\n         MVC   LRSCPU(8),CPUSNN-CPUSN(R15) Get name from table\nPAR$CPUT EQU   *\n*\n** Add new CPU count entry or find existing entry for this CPU\n*\n         L     R5,CPUC_ST+4               Locate CPU Count table\nPAR$CPUTL EQU  *\n         CLI   0(R5),X'FF'                End of table?\n         BE    PAR$CPUTI                  Yes, new guy\n         CLC   CPUCN-CPUC(8,R5),LRSCPU    Match?\n         BE    PAR$CPUTX                  Yes, we have good entry\n         LA    R5,CPUCL(R5)               No, bump to next one\n         C     R5,CPUC_END                About to overflow\n         BL    PAR$CPUTL                  No, continue\n         SH    R5,=AL2(CPUCL)             Backup to last entry\n         MVC   CPUCN-CPUC(8,R5),=CL8'*Error*' Mark as invalid!\n         OI    FLAG1,$F1CPUCO             Indicate overflag\n         B     PAR$CPUTX                  and count no mo'\nPAR$CPUTI EQU  *\n         XC    0(CPUCL,R5),0(R5)          Clear storage\n         MVC   CPUCN-CPUC(8,R5),LRSCPU    Move in CPU\n         MVI   CPUCL(R5),X'FF'            Mark next entry as end\nPAR$CPUTX EQU  *                          R5 now has CPUC entry...\n*\n** Update total count for this CPU\n*\n         SLR   R1,R1\n         ICM   R1,B'0011',CPUCTOTL-CPUC(R5) Get total count\n         LA    R1,1(R1)                     Increment by one\n         STCM  R1,B'0011',CPUCTOTL-CPUC(R5) Save total count\n*\n** Determine record type\n*\n         SLR   R1,R1                      Clear register for count\n         CLI   SFTKEY1-SFT(R3),X'40'\n         BE    PAR$ABN\n         CLI   SFTKEY1-SFT(R3),X'42'\n         BE    PAR$PI\n*        CLI   SFTKEY1-SFT(R3),X'44'\n*        BE    PAR$RST\n*        CLI   SFTKEY1-SFT(R3),X'48'\n*        BE    PAR$MCH\n         CLI   SFTKEY1-SFT(R3),X'4C'\n         BE    PAR$SYM\n         CLI   SFTKEY1-SFT(R3),X'4F'\n         BE    PAR$LOST\n         CLI   SFTKEY1-SFT(R3),X'50'\n         BE    PAR$IPL\n         CLI   SFTKEY1-SFT(R3),X'80'\n         BE    PAR$EOD\n         CLI   SFTKEY1-SFT(R3),X'81'\n         BE    PAR$EOD81\n         CLI   SFTKEY1-SFT(R3),X'84'\n         BE    PAR$EOD84\n*-Here are some \"new\" ones that I don't handle well yet\n         CLI   SFTKEY1-SFT(R3),X'30'\n         BE    PAR$OBR\n         CLI   SFTKEY1-SFT(R3),X'71'\n         BE    PAR$MIH\n         CLI   SFTKEY1-SFT(R3),X'90'\n         BE    PAR$SVC91\n         CLI   SFTKEY1-SFT(R3),X'91'\n         BE    PAR$MDR\n*\nPAR$IGNORE DS  0H\n         SLR   R1,R1                      Clear register\n         IC    R1,SFTKEY1-SFT(R3)         Get record type\n         L     R14,URCT_ST+4              Locate table\n         MH    R1,=H'4'                   Get offset of entry\n         AR    R1,R14                     Locate entry\n         L     R15,0(R1)                  Get current count\n         LA    R15,1(R15)                 Increment by 1\n         ST    R15,0(R1)                  Save current count\n         B     PAR$RR\n*\n** Symptom record\n*\nPAR$SYM  EQU   *\n         ICM   R1,B'0011',CPUCSYM-CPUC(R5)   Get current count\n         LA    R1,1(R1)                      Increment by 1\n         STCM  R1,B'0011',CPUCSYM-CPUC(R5)   Save new count\n         MVC   LRSTYPE(7),=C'SYMPTOM'        Indicate type\n*\n         LA    R4,SFTHEADE-SFT(R3)           Locate ADSR\n         CLC   ADSRID-ADSR(2,R4),=C'SR'      Have a valid ADSR ID?\n         BNE   PAR$SYME                      No, leave\n*\n         SLR   R1,R1                         Clear register\n         ICM   R1,B'0011',ADSRCSO-ADSR(R4)   Get offset of ADSRCMPS\n         BZ    PAR$SYM_CSOX                  None!\n         AR    R1,R4                         Locate ADSRCMPS\n         CLI   ADSRCDSC-ADSRCMPS(R1),0       Have a Text description?\n         BE    PAR$SYM_CDSCX                 No, continue\n         MVC   LRSDESC(L'ADSRCDSC),ADSRCDSC-ADSRCMPS(R1)\nPAR$SYM_CDSCX EQU *\n*\n         CLI   ADSRPRID-ADSRCMPS(R1),0       Have a Problem ID?\n         BE    PAR$SYM_PRIDX                 No, continue\n         MVC   LRSCOMP(L'LRSCOMP),ADSRPRID-ADSRCMPS(R1)\nPAR$SYM_PRIDX EQU *\n*\n         CLI   ADSRPTF-ADSRCMPS(R1),0        Have a PTF?\n         BE    PAR$SYM_PTF                   No, continue\n         MVC   LRSCSCT(L'LRSCSCT),ADSRPTF-ADSRCMPS(R1)\nPAR$SYM_PTF EQU *\n*\n         CLI   ADSRSSID-ADSRCMPS(R1),0       Have a SubSystem?\n         BE    PAR$SYM_SSIDE                 No, continue\n         MVC   LRSJOBN(L'LRSJOBN),ADSRSSID-ADSRCMPS(R1)\n         B     PAR$SYM_SSIDX                 Thru...\nPAR$SYM_SSIDE EQU *\n         LA    R14,T_CID                     Get table address\n         LA    R15,T_CIDN                    Get length of table\nPAR$SYM_SSIDL EQU *\n         CLC   ADSRCID-ADSRCMPS(9,R1),TCID_ID-TCID(R14) Match?\n         BNE   PAR$SYM_SSIDB                         No, continue\n         MVC   LRSJOBN(L'LRSJOBN),TCID_NM-TCID(R14)  Yes, get name\n         B     PAR$SYM_SSIDX                 Continue\nPAR$SYM_SSIDB  EQU *\n         LA    R14,TCIDL(R14)                Bump to next entry\n         BCT   R15,PAR$SYM_SSIDL             and process it\n         MVC   LRSJOBN(8),ADSRCID-ADSRCMPS(R1)  Not in table...\nPAR$SYM_SSIDX EQU *\n*\nPAR$SYM_CSOX  EQU *\n* Note: Could access the ADSRDBO, ADSROSA and ADSRRONA here...\n         B    PAR$SYMX\nPAR$SYME EQU  *\n         MVC  LRSDESC(19),=C'Invalid ADSR found!'\nPAR$SYMX EQU  *\n         B     PAR$TADD\n*\n** ABEND\n*\nPAR$ABN  EQU   *\n         ICM   R1,B'0011',CPUCABN-CPUC(R5) Get current count\n         LA    R1,1(R1)                    Increment by 1\n         STCM  R1,B'0011',CPUCABN-CPUC(R5) Save new count\n         MVC   LRSTYPE(5),=C'ABEND'\n         B     PAR$SDWA\n*\n** Program Interrupt\n*\nPAR$PI   EQU   *\n         ICM   R1,B'0011',CPUCPI-CPUC(R5) Get current count\n         LA    R1,1(R1)                   Increment by 1\n         STCM  R1,B'0011',CPUCPI-CPUC(R5) Save new count\n         MVC   LRSTYPE(7),=C'PROGINT'\n         B     PAR$SDWA\n*\n** Lost record\n*\nPAR$LOST EQU   *\n         ICM   R1,B'0011',CPUCLOST-CPUC(R5)  Get current count\n         LA    R1,1(R1)                      Increment by 1\n         STCM  R1,B'0011',CPUCLOST-CPUC(R5)  Save new count\n         MVC   LRSTYPE(7),=C'LOSTREC'     Set type\n         SLR   R1,R1                      Clear register\n         IC    R1,RCBLCNT-SFT(R3)         Get number of lost records\n         LA    R15,LRSREAS                Locate output field\n         MVC   0(2,R15),=C'N='            Insert text\n         LA    R15,2(R15)                 Bump past it\n         BAS   R9,EDITFWF                 Edit the number\n         B     PAR$TADD                   Continue\n*\n** IPL performed\n*\nPAR$IPL  EQU   *\n         ICM   R1,B'0011',CPUCIPL-CPUC(R5)   Get current count\n         LA    R1,1(R1)                      Increment by 1\n         STCM  R1,B'0011',CPUCIPL-CPUC(R5)   Save new count\n         MVC   LRSTYPE(3),=C'IPL'\n*\n         CLI   IPLSYSID-SFT(R3),0         Null?\n         BE    PAR$ISX                    Yes, leave\n         LA    R1,T_IPLS                  Locate table\n         LA    R0,T_IPLSN                 Number in table\nPAR$ISL  EQU   *\n         CLC   0(1,R1),IPLSYSID-SFT(R3)   Match?\n         BE    PAR$ISF                    Yes, continue\n         LA    R1,1+8(R1)                 No, bump to next one\n         BCT   R0,PAR$ISL                 Process next entry\n         UNPK  LRSCSCT(3),IPLSYSID-SFT(2,R3)\n         MVZ   LRSCSCT(2),=8X'00'\n         TR    LRSCSCT(2),=C'0123456789ABCDEF'\n         MVC   LRSCSCT+2(4),=C'=SID'      Insert text\n         B     PAR$ISX                    Leave\nPAR$ISF  EQU   *\n         MVC   LRSCSCT(8),1(R1)\nPAR$ISX  EQU   *\n*\n         LA    R1,T_IPLR                  Locate table\n         LA    R0,T_IPLRN                 Number in table\nPAR$IRL  EQU   *\n         CLC   TIPLRR-TIPLR(2,R1),IPLREAS-SFT(R3)  Reason match?\n         BE    PAR$IRF                    Yes, continue\n         LA    R1,TIPLRL(R1)              No, bump to next one\n         BCT   R0,PAR$IRL                 Process next entry\n         UNPK  LRSCOMP(3),IPLREAS-SFT(2,R3)\n         MVZ   LRSCOMP(2),=8X'00'\n         TR    LRSCOMP(2),=C'0123456789ABCDEF'\n         MVC   LRSCOMP+2(5),=C'=REAS'     Insert text\n         B     PAR$IRMX\nPAR$IRF  EQU   *\n         MVC   LRSCOMP(8),TIPLRC-TIPLR(R1)  Move in Comp\nPAR$IRMX EQU   *\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',TIPLRD-TIPLR(R1) Get offset\n         AR    R14,R1                     Locate description string\n         SLR   R15,R15                    Clear register\n         IC    R15,0(R14)                 Get length of string\n         CH    R15,=AL2(L'LRSDESC)        Too long?\n         BNH   PAR$IRDL                   No, continue\n         LA    R15,L'LRSDESC              Yes, set to max length\nPAR$IRDL EQU   *\n         BCTR  R15,0                      Decrement for EX\n         EX    R15,PAR$IRM                Move description out\n         B     PAR$TADD\nPAR$IRM  MVC   LRSDESC(0),1(R14)          Move description out\n*\n** EOD\n*\nPAR$EOD81 EQU  *\n         MVC   LRSTYPE+3(4),=C'-NRS'      Non-Restartable\n         B     PAR$EOD\nPAR$EOD84 EQU  *\n         MVC   LRSTYPE+3(4),=C'-RWS'      Restartable Wait State\nPAR$EOD  EQU   *\n         MVC   LRSTYPE(3),=C'EOD'\n         ICM   R1,B'0011',CPUCZEOD-CPUC(R5)  Get current count\n         LA    R1,1(R1)                      Increment by 1\n         STCM  R1,B'0011',CPUCZEOD-CPUC(R5)  Save new count\n*\n         LH    R1,ESRRDW-ESR(R2)             Get length of record\n         LA    R14,SFTHEADE-SFT+(ESRSFT-ESR) Get length without ext.\n         CR    R1,R14                        Have an extension?\n         BNH   PAR$TADD                      No, continue\n*\n         UNPK  LRSREAS(9),EODWSC-SFT(5,R3)\n         MVZ   LRSREAS(8),=8X'00'\n         TR    LRSREAS(8),=C'0123456789ABCDEF'\n         B     PAR$TADD\n*\n** MIH\n*\nPAR$MIH  DS    0H\n         MVC   LRSTYPE(3),=C'MIH'\n         MVC   LRSTYPE(3),=C'MDR'\n         B     PAR$IGNORE\n*\n** OBR\n*\nPAR$OBR  DS    0H\n         MVC   LRSTYPE(3),=C'OBR'\n         BAS   R14,PAR$DBE              Print Debugging (if batch)\n         B     PAR$IGNORE\n*\n** SVC 91\n*\nPAR$SVC91 DS   0H\n         MVC   LRSTYPE(5),=C'SVC91'\n         BAS   R14,PAR$DBE              Print Debugging (if batch)\n         B     PAR$IGNORE\n*\n** MDR\n*\nPAR$MDR  DS    0H\n         MVC   LRSTYPE(3),=C'MDR'\n         BAS   R14,PAR$DBE              Print Debugging (if batch)\n         B     PAR$IGNORE\n*\n** SDWA processing for software records\n*\nPAR$SDWA EQU   *\n         MVC   LRSJOBN(8),SFTJOBID-SFT(R3)\n         LA    R4,SFTSDWA-SFT(R3)         Locate SDWA (SFT only)\n*\n         UNPK  LRSREAS(9),SDWAABCC-SDWA(5,R4)\n         MVZ   LRSREAS(8),=8X'00'\n         TR    LRSREAS(8),=C'0123456789ABCDEF'\n*\n         MVC   LRSCOMP(8),SDWAMODN-SDWA(R4)\n         MVC   LRSCSCT(8),SDWACSCT-SDWA(R4)\n*\n         TM    SFTSW2-SFT(R3),X'20'       Is there an ErrorID?\n         BNO   PAR$EIX                    No, continue\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0011',ESRRDW-ESR(R2)  Get length of record\n         AR    R1,R2                      Locate to end of record\n         S     R1,=AL4(L'ESRERROR)        Backup to error ID\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',ESRESEQ-ESRERROR(R1) Get Sequence number\n         CVD   R14,DOUBLE                 Convert to packed\n         MVC   LRSSEQN-1(6),=X'F02020202020' Get edit pattern\n         ED    LRSSEQN-1(6),DOUBLE+5      Edit number\nPAR$EIX  DS    0H\n*\n** Format the SDWA VRA area\n*\n         TM    SDWADPVA-SDWA(R4),SDWAEBC  VRA in EBCDIC?\n         BNO   PAR$SVX                    No, continue\n         LA    R15,SFTSDWA-SFT(R3)        Locate SDWA\n         TM    SDWADPVA-SDWA(R4),SDWAVRAM In IHAVRA format?\n         BNO   PAR$SVOF                   No, continue\n         LA    R15,SDWARA-SDWA(R4)        Locate IHAVRA area\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0001',VRALEN-VRAMAP(R15) Get length of VRADAT\n         BZ    PAR$SVX                    None, leave\n         LA    R15,VRADAT-VRAMAP(R15)     Locate data area\n         B     PAR$SVD                    Continue\nPAR$SVDM MVC   LRSDESC(0),0(R15)          Move data to desc. area\nPAR$SVOF EQU   *\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0001',SDWAURAL-SDWA(R4) Get length of VRA\n         BZ    PAR$SVX                    None, leave\n         LA    R15,SDWAVRA-SDWA(R4)       Bump to variable area\nPAR$SVD  EQU   *\n         LA    R14,L'LRSDESC              Get max length of area\n         CR    R1,R14                     Fits?\n         BNH   PAR$SVDL                   Yes, continue\n         LA    R1,L'LRSDESC               No, set to length of area\nPAR$SVDL EQU   *\n         BCTR  R1,0                       Decrement for EX\n         EX    R1,PAR$SVDM                Move VRA to description\nPAR$SVX  EQU   *\n*\n** Save summary information into in-core table\n*\n         ICM   R1,B'1111',SUMT_ST+4       Locate Summary table\n         BNZ   PAR$SUML                   Already obtained, continue\n         L     R0,=AL4(#MAXMOD*SUMTROWL)  Set length of table\n         GETMAIN R,LV=(0)                 Obtain storage\n         STM   R0,R1,SUMT_ST              Save length and address\n         MVI   0(R1),X'FF'                Set end of table\n         AR    R1,R0                      Locate end of storage area\n         BCTR  R1,0                       Backup 1\n         SH    R1,=AL2(SUMTROWL)          Backup to last entry\n         ST    R1,SUMT_END                Save it\n         L     R1,SUMT_ST+4               Locate Summary table\n         B     PAR$SUMA                   Add first entry\nPAR$SUML EQU   *\n         CLI   0(R1),X'FF'                At end of table\n         BE    PAR$SUMA                   Yes, add new entry...\n* Check for a \"Component/Module - CSECT\" - Reason match\n         CLC   SUMMOD-SUMTROW(1,R1),LRSCOMP\n         BNE   PAR$SUMB\n         CLC   SUMMOD+1-SUMTROW(7,R1),LRSCOMP+1\n         BNE   PAR$SUMB\n         CLC   SUMCSCT-SUMTROW(1,R1),LRSCSCT\n         BNE   PAR$SUMB\n         CLC   SUMCSCT+1-SUMTROW(7,R1),LRSCSCT+1\n         BNE   PAR$SUMB\n         CLC   SUMREAS-SUMTROW(1,R1),LRSREAS\n         BNE   PAR$SUMB\n         CLC   SUMREAS+1-SUMTROW(7,R1),LRSREAS+1\n         BNE   PAR$SUMB\n*\n         ICM   R15,B'1111',SUMCOUNT-SUMTROW(R1) Get count\n         LA    R15,1(R15)                       Increment by 1\n         STCM  R15,B'1111',SUMCOUNT-SUMTROW(R1) Save new count\n         CLC   LRSDATEG(L'LRSDATEG),SUMSDATG-SUMTROW(R1)\n         BNL   PAR$SSDX\n         MVC   SUMSDATG-SUMTROW(L'SUMSDATG,R1),LRSDATEG\n         MVC   SUMSDATD-SUMTROW(L'SUMSDATD,R1),LRSDAY\nPAR$SSDX EQU   *\n         CLC   LRSDATEG(L'LRSDATEG),SUMEDATG-SUMTROW(R1)\n         BL    PAR$SEDX                         No, continue\n         MVC   SUMEDATG-SUMTROW(L'SUMEDATG,R1),LRSDATEG\n         MVC   SUMEDATD-SUMTROW(L'SUMEDATD,R1),LRSDAY\nPAR$SEDX EQU   *\n         B     PAR$SUMX                   We are finished with summary\n*\nPAR$SUMB EQU   *\n         LA    R1,SUMTROWL(R1)            Bump to next entry\n         C     R1,SUMT_END                End of table?\n         BL    PAR$SUML                   No, continue\n         OI    FLAG1,$F1SUMTO             Yes, set overflow flag\n         B     PAR$SUMX                   Continue\n*\nPAR$SUMA EQU   *                          Add new entry to table\n         XC    0(SUMTROWL,R1),0(R1)       Clear table entry\n         MVC   SUMMOD-SUMTROW(L'SUMMOD,R1),LRSCOMP\n         MVC   SUMCSCT-SUMTROW(L'SUMCSCT,R1),LRSCSCT\n         MVC   SUMREAS-SUMTROW(L'SUMREAS,R1),LRSREAS\n         MVC   SUMSDATG-SUMTROW(L'SUMSDATG,R1),LRSDATEG\n         MVC   SUMSDATD-SUMTROW(L'SUMSDATD,R1),LRSDAY\n         MVC   SUMEDATG-SUMTROW(L'SUMEDATG,R1),LRSDATEG\n         MVC   SUMEDATD-SUMTROW(L'SUMEDATD,R1),LRSDAY\n         MVI   SUMCOUNT+L'SUMCOUNT-1-SUMTROW(R1),1\n         MVI   SUMTROWL(R1),X'FF'         Set new end of table\nPAR$SUMX EQU   *\n*\n** Add entry to table\n*\nPAR$TADD EQU   *\n         OC    LRSCOMP(8),=CL8' '         Ensure uppercase\n         OC    LRSCSCT(8),=CL8' '         Ensure uppercase\n*->      TBADD LRSTABLE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'TBADD',         Service: TBADD               @\n               LRSTABLE),                 ..Table name                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         LTR   R15,R15\n         BZ    PAR$TADDX\n ST R15,DOUBLE\n UNPK DEBUGMSG(9),DOUBLE(5)\n MVZ  DEBUGMSG(8),=8X'00'\n TR   DEBUGMSG(8),=C'0123456789ABCDEF'\n LA   R1,DEBUGMSG+8\n MVC  0(8,R15),=C'=TBADD: '\n LA   R15,8(R15)\n MVC  0(60,R15),LRSTROW\n TPUT DEBUGMSG,78\nPAR$TADDX DS   0H\n         BAS   R14,PAR$DBE             Print Debugging messages\n*\n** Save start and end dates of Logrec entries\n**\n** We only care about the ones we write out via TBADD...\n*\n         CLC   LRSDATEG(L'LRSDATEG),PAR_SDAT\n         BNL   PAR$SDX\n         MVC   PAR_SDAT(L'LRSDATEG),LRSDATEG\n         MVC   PAR_SDAT+10(3),LRSDAY      Save Day of week\n**\n         TM    FLAG2,$F2DEBUG             Debugging?\n         BNO   PAR$DBSX                   No, skip this code\n         LA    R15,DEBUGMSG               Locate message area\n         MVI   0(R15),C' '                Get blank\n         MVC   1(132,R15),0(R15)          ..and propagate it\n         MVC   0(30,R15),=C'This is the start date record:'\n         MVC   32(L'PAR_SDAT,R15),PAR_SDAT\n         PUT   DEBUGOUT,DEBUGMSG\nPAR$DBSX DS    0H\n**\nPAR$SDX  EQU   *\n         CLC   LRSDATEG(L'LRSDATEG),PAR_EDAT\n         BL    PAR$EDX\n         MVC   PAR_EDAT(L'LRSDATEG),LRSDATEG\n         MVC   PAR_EDAT+10(3),LRSDAY      Save Day of week\nPAR$EDX  EQU   *\n*\n** Display logo screen with current row information to let user\n** know that we are doing something - at regular intervals...\n*\n         L     R1,PAR_TCNT                Get total add count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PAR_TCNT                Save total count\n*\n         CLI   ZENVIR+16,C'B'             Batch?\n         BE    PAR$TACX                   Yes, skip this nonsense\n*\n         SLR   R0,R0                      Clear register\n         D     R0,=AL4(#STATUSL)          Divide by display increment\n         LTR   R0,R0                      Evenly?\n         BNZ   PAR$TACX                   No, continue\n         BAS   R9,INITIALIZE_LOGO_VARIABLES  Initialize to blanks\n         LA    R15,STATUS                 Locate status line\n*                           ....+....1....+....2....+....3....+.\n         MVC   0(35,R15),=C'Reading LOGREC file - record number'\n         LA    R15,36(R15)                Bump past text\n         L     R1,PAR_TCNT                Get current count\n         BAS   R9,EDITFWF                 Edit the number\n*\n         LA    R15,INFO1\n         MVC   0(5,R15),=C'Time:'\n         LA    R15,6(R15)\n         MVC   0(L'LRSTIME,R15),LRSTIME\n         LA    R15,L'LRSTIME+2(R15)\n         MVC   0(5,R15),=C'Date:'\n         LA    R15,6(R15)\n         MVC   0(L'LRSDATEJ,R15),LRSDATEJ\n         LA    R15,L'LRSDATEJ+1(R15)\n         MVC   0(L'LRSDAY,R15),LRSDAY\n         LA    R15,L'LRSDAY+1(R15)\n         MVC   0(L'LRSDATEG,R15),LRSDATEG\n         LA    R15,L'LRSDATEG+2(R15)\n         MVC   0(5,R15),=C'Type:'\n         LA    R15,6(R15)\n         MVC   0(L'LRSTYPE,R15),LRSTYPE\n         LA    R15,L'LRSTYPE+2(R15)\n         MVC   0(4,R15),=C'CPU:'\n         LA    R15,5(R15)\n         MVC   0(L'LRSCPU,R15),LRSCPU\n         LA    R15,L'LRSCPU+2(R15)\n*\n         LA    R15,INFO2\n         MVC   0(L'LRSCOMP,R15),LRSCOMP\n         LA    R15,L'LRSCOMP+2(R15)\n         MVC   0(L'LRSCSCT,R15),LRSCSCT\n         LA    R15,L'LRSCSCT+2(R15)\n         MVC   0(L'LRSREAS,R15),LRSREAS\n         LA    R15,L'LRSREAS+2(R15)\n         MVC   0(L'LRSCOMP,R15),LRSCOMP\n         LA    R15,L'LRSCOMP+2(R15)\n*\n         MVC   INFO3(L'INFO3),LRSDESC\n*\n*->      CONTROL DISPLAY,LOCK,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'CONTROL',       Service: CONTROL             @\n               =CL8'DISPLAY',             ..display                    @\n               =CL8'LOCK'),               ..LOCK it                    @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      DISPLAY PANEL='LRS$LOGO',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'DISPLAY',       Service: DISPLAY             @\n               =CL8'LRS$LOGO'),           ..Panel name                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\nPAR$TACX EQU   *\n*\n** When we see the current date for the first time, save the\n** row number for fast locate to the current date\n*\n         CLC   PAR_LDTV(4),LRSBDATE       Already seen this one?\n         BE    PAR$RR                     Yes, continue\n         MVC   PAR_LDTV(4),LRSBDATE       Save Date\n         MVC   PAR_LDTR(4),PAR_TCNT       Save row number\n         B     PAR$RR                     Continue\n*\n** Print Debugging message\n*\nPAR$DBE  DS    0H\n         TM    FLAG2,$F2DEBUG             Debugging?\n         BNO   PAR$DBEX                       No, skip this code!\n         ST    R14,PAR_DBERA                  Save return address\n*\n         MVI   DEBUGMSG,C' '\n         MVC   DEBUGMSG+1(132),DEBUGMSG\n         PUT   DEBUGOUT,DEBUGMSG\n*\n         LA    R15,DEBUGMSG\n         MVC   0(5,R15),=C'Date:'\n         LA    R15,6(R15)\n         MVC   0(L'LRSDATEG,R15),LRSDATEG\n         LA    R15,L'LRSDATEG+1(R15)\n         MVC   0(L'LRSDAY,R15),LRSDAY\n         LA    R15,L'LRSDAY+1(R15)\n#DBOFF   EQU   6+L'LRSDATEG+1+L'LRSDAY+1\n         MVC   0(1,R15),CENT1900\n         LA    R15,2(R15)\n         MVC   0(4,R15),=C'Job:'\n         LA    R15,5(R15)\n         MVC   0(L'LRSJOBN,R15),LRSJOBN\n         LA    R15,L'LRSJOBN+1(R15)\n*-More here\n         PUT   DEBUGOUT,DEBUGMSG\n         MVI   DEBUGMSG,C' '\n         MVC   DEBUGMSG+1(132),DEBUGMSG\n         LA    R15,DEBUGMSG\n         MVC   0(5,R15),=C'Time:'\n         LA    R15,6(R15)\n         MVC   0(L'LRSTIME,R15),LRSTIME\n         LA    R15,L'LRSTIME+1(R15)\n         LA    R15,DEBUGMSG+#DBOFF+1\n         MVC   0(5,R15),=C'Comp:'\n         LA    R15,6(R15)\n         MVC   0(L'LRSCOMP,R15),LRSCOMP\n         LA    R15,L'LRSCOMP+1(R15)\n         MVC   0(5,R15),=C'Type:'\n         LA    R15,6(R15)\n         UNPK  0(3,R15),SFTKEY1-SFT(2,R3)\n         MVZ   0(2,R15),=8X'00'\n         TR    0(2,R15),=C'012345678ABCDEF'\n         MVI   2(R15),C'/'\n         LA    R15,3(R15)\n         MVC   0(L'LRSTYPE,R15),LRSTYPE\n         LA    R15,L'LRSTYPE+1(R15)\n*-More here\n         PUT   DEBUGOUT,DEBUGMSG\n*\n         TM    FLAG2,$F2DUMP              Dump\n         BNO   PAR$DBDX\n         MVI   DEBUGMSG,C' '\n         MVC   DEBUGMSG+1(132),DEBUGMSG\n         PUT   DEBUGOUT,DEBUGMSG\n         LA    R15,DEBUGMSG\n         MVC   0(21,R15),=C'Dump of record number'\n         LA    R15,22(R15)\n         L     R1,PAR_RECNUM              Get record number\n         BAS   R9,EDITFWF\n         MVC   1(5,R15),=C'Type='\n         LA    R15,1+5(R15)\n         UNPK  0(3,R15),SFTKEY1-SFT(2,R3)\n         MVZ   0(2,R15),=8X'00'\n         TR    0(2,R15),=C'012345678ABCDEF'\n         MVI   2(R15),C'/'\n         MVC   3(L'LRSTYPE,R15),LRSTYPE\n         PUT   DEBUGOUT,DEBUGMSG\n*\n         XC    PARMLIST(CMXDL),PARMLIST   Initialize area\n         LR    R15,R2                     Locate LOGREC record\n         SLR   R0,R0\n         ICM   R0,B'0011',0(R2)           Get length of Record\n SH    R0,=H'4' Fudge(BOZO)\n         LA    R1,DEBUGMSG\n         STM   R15,R1,PARMLIST+CMXD_ADDRESS-CMXD Data, Length, Output\nPAR$DBEL DS    0H\n         LA    R1,PARMLIST                Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BALR  R14,R15                    Call DA$MXD\n         LR    R8,R15                     Save return code\n         PUT   DEBUGOUT,DEBUGMSG          Print record\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   PAR$DBEL                   Thank you: May I have another\nPAR$DBDX DS    0H\n         L     R14,PAR_DBERA              Get return address\nPAR$DBEX DS    0H\n         BSM   0,R14\n*\n** End of file on ACCIN file\n*\nPAR$EOF  EQU   *\n         LA    R3,ACCIN                   Locate DCB\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize parameter list\n         CLOSE ((3)),MODE=31,MF=(E,PARMLIST)  Close file\n*\n         FREEPOOL ACCIN                   Free buffer pool\n*\n** Create TSO variable with row number of latest date\n*\n         LA    R14,=C'LRSCDROW'           Locate variable name\n         ST    R14,CTV_NAMEP              Save it\n         LA    R14,8                      Set variable name length\n         ST    R14,CTV_NAMEL              Save it\n*\n         LA    R15,CCL_LINE               Locate variable area\n         L     R1,PAR_LDTR                Get row number\n         BAS   R9,EDITNCF                 Edit the row number\n         LA    R14,CCL_LINE               Get start\n         SR    R15,R14                    Length = end - start\n*\n         LA    R1,CCL_LINE                Locate value\n         LR    R0,R15                     Get length of value\n         BAS   R9,CREATE_TSO_VARIABLE     Create TSO variable\n         EJECT ,\n***********************************************************************\n***\n** Create ISPF summary table from in-core summary table entries\n***\n***********************************************************************\n         SPACE 2\nCREATE_SUMMARY_TABLE EQU *\n*\n** Define row variables for SUMTABLE and obtain it's name\n*\n*->      VDEFINE '(SUMMOD)',SUMMOD,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(SUMMOD)',              ..Name                       @\n               SUMMOD,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(SUMCSCT)',SUMCSCT,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(SUMCSCT)',             ..Name                       @\n               SUMCSCT,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(SUMREAS)',SUMREAS,CHAR,8,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(SUMREAS)',             ..Name                       @\n               SUMREAS,                   ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(SUMSDATE)',SUMSDATE,CHAR,12,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(SUMSDATE)',            ..Name                       @\n               SUMSDATE,                  ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'14'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(SUMEDATE)',SUMEDATE,CHAR,12,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(SUMEDATE)',            ..Name                       @\n               SUMEDATE,                  ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'14'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(SUMCOUNT)',SUMCOUNT,FIXED,4,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(SUMCOUNT)',            ..Name                       @\n               SUMCOUNT,                  ..Location                   @\n               =CL8'FIXED',               ..Format                     @\n               =F'4'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n*->      VCOPY '(SUMTABLE)',=F'8',SUMTABLE,MOVE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(SUMTABLE)',            ..Name                       @\n               =F'8',                     ..Length                     @\n               SUMTABLE,                  ..Location                   @\n               =CL8'MOVE'),               ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n** Create ISPF table entries from in-core entries\n*\n         L     R2,SUMT_ST+4               Locate table\nCST$L    EQU   *\n         CLI   0(R2),X'FF'                End of table?\n         BE    CST$X                      Yes, leave\n         MVC   SUMMOD(L'SUMMOD),SUMMOD-SUMTROW(R2)\n         MVC   SUMCSCT(L'SUMCSCT),SUMCSCT-SUMTROW(R2)\n         MVC   SUMREAS(L'SUMREAS),SUMREAS-SUMTROW(R2)\n         MVC   SUMSDATE(L'SUMSDATE),SUMSDATE-SUMTROW(R2)\n         MVI   SUMSDATS,C' '\n         MVC   SUMEDATE(L'SUMEDATE),SUMEDATE-SUMTROW(R2)\n         MVI   SUMEDATS,C' '\n         MVC   SUMCOUNT(L'SUMCOUNT),SUMCOUNT-SUMTROW(R2)\n*\n         L     R1,CST_TCNT              Get total add count\n         LA    R1,1(R1)                 Increment by 1\n         ST    R1,CST_TCNT              Save total count\n         SLR   R0,R0                    Clear register\n         D     R0,=AL4(#STATUSS)        Divide by display increment\n         LTR   R0,R0                    Evenly?\n         BNZ   CST$TACX                 No, continue\n         BAS   R9,INITIALIZE_LOGO_VARIABLES\n         LA    R15,STATUS\n*                           ....+....1....+....2....+....3..\n         MVC   0(32,R15),=C'Processing Summary record number'\n         LA    R15,33(R15)\n         L     R1,CST_TCNT\n         BAS   R9,EDITFWF\n*\n         LA    R15,INFO1\n         MVC   0(L'SUMMOD,R15),SUMMOD\n         LA    R15,L'SUMMOD+2(R15)\n         MVC   0(L'SUMCSCT,R15),SUMCSCT\n         LA    R15,L'SUMCSCT+2(R15)\n         MVC   0(L'SUMREAS,R15),SUMREAS\n         LA    R15,L'SUMREAS+2(R15)\n         LA    R15,INFO3\n         MVC   0(L'SUMSDATE,R15),SUMSDATE\n         LA    R15,L'SUMSDATE+2(R15)\n         MVC   0(L'SUMEDATE,R15),SUMEDATE\n         LA    R15,L'SUMEDATE+2(R15)\n*\n         CLI   ZENVIR+16,C'B'             Batch?\n         BE    CST$TACX                   Yes, skip this nonsense\n*->      CONTROL DISPLAY,LOCK,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'CONTROL',       Service: CONTROL             @\n               =CL8'DISPLAY',             ..display                    @\n               =CL8'LOCK'),               ..LOCK it                    @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      DISPLAY PANEL='LRS$LOGO',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'DISPLAY',       Service: DISPLAY             @\n               =CL8'LRS$LOGO'),           ..Panel name                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\nCST$TACX EQU   *\n*->      TBADD SUMTABLE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'TBADD',         Service: TBADD               @\n               SUMTABLE),                 ..Table name                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n         LA    R2,SUMTROWL(R2)            Bump to next entry\n         C     R2,SUMT_END                End of table?\n         BL    CST$L                      No, continue\n*\n** Free Summary table\n*\nCST$X    EQU   *\n         LM    R0,R1,SUMT_ST              Get length and address\n         LTR   R0,R0\n         BZ    CST$SUMX\n         FREEMAIN R,LV=(0),A=(1)          Free storage\nCST$SUMX EQU   *\n         EJECT ,\n***********************************************************************\n***\n**       Process the CPU count entries into CLIST/REXX variables\n***\n***********************************************************************\n         SPACE 2\nCREATE_CPU_LINES EQU *\n         L     R2,CPUC_ST+4               Locate CPU count table\n*\n** Create TSO variable LRSRANGE\n*\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         MVC   0(23,R4),=C'LOGREC entries start on'\n         LA    R4,24(R4)                  Bump past text\n         MVC   0(3,R4),PAR_SDAT+10        Get day of week\n         MVC   3+1(10,R4),PAR_SDAT        Get gregorian Date\n         LA    R4,3+1+10+1(R4)             Bump past it\n         MVC   0(10,R4),=C'and end on'    Insert more text\n         LA    R4,11(R4)                  Bump past it\n         MVC   0(3,R4),PAR_EDAT+10        Get day of week\n         MVC   3+1(10,R4),PAR_EDAT        Get gregorian Date\n*\n         LA    R14,=C'LRSRANGE'           Locate variable name\n         ST    R14,CTV_NAMEP              Save it\n         LA    R14,8                      Set variable name length\n         ST    R14,CTV_NAMEL              Save it\n         LA    R1,CCL_LINE                Locate value\n         LA    R0,L'CCL_LINE              Get length of value\n         BAS   R9,CREATE_TSO_VARIABLE     Create TSO variable\n*\n** Create table title lines\n*\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         MVC   0(C_CLT1L,R4),C_CLT1       Get title line 1\n         BAS   R9,CCL$NEWROW              Create new variable\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         MVC   0(C_CLT2L,R4),C_CLT2       Get title line 2\n         BAS   R9,CCL$NEWROW              Create new variable\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         MVC   0(C_CLT3L,R4),C_CLT3       Get title line 3\n         BAS   R9,CCL$NEWROW              Create new variable\n*\n         LA    R1,LRSTROW                 Locate total work area\n         XC    0(CPUCL,R1),0(R1)          Clear area\n         MVC   CPUCN-CPUC(8,R1),=CL8'Total'\n         MVI   CPUCL(R1),X'FF'            Set end of \"table\"\n*\nCCL$L    EQU   *\n         CLI   0(R2),X'FF'                End of table?\n         BE    CCL$CLE                    Yes, continue\nCCL$LLST EQU   *\n         BAS   R14,CCL$CLO                Clear CCL_LINE to blanks\n         MVC   0(8,R4),CPUCN-CPUC(R2)     Get CPU name\n         LA    R4,8+1(R4)                 Bump past CPU name\n*\n         LA    R0,CPUCCSN                 Get number of count fields\n         LA    R1,CPUCCS-CPUC(R2)         Locate start of count fields\n         SLR   R14,R14                    Clear total\n         LA    R5,LRSTROW                 Locate total work area\n         LA    R5,CPUCCS-CPUC(R5)         Locate to count fields\nCCL$CL   EQU   *\n         SLR   R15,R15                    Clear register\n         ICM   R15,B'0011',0(R1)          Get entry number\n         SLR   R9,R9                      Clear register\n         ICM   R9,B'0011',0(R5)           Get total value\n         AR    R9,R15                     Add for this CPU\n         STCM  R9,B'0011',0(R5)           Save new total\n         AR    R14,R15                    Add to total count\n         CVD   R15,DOUBLE                 Convert to packed\n         MVC   2(6,R4),=X'40,20,20,20,20,20' Get edit pattern\n         ED    2(6,R4),DOUBLE+5           Edit total\n         OI    2+5(R4),C'0'               Ensure a zero\n         LA    R4,2+6+1(R4)               Bump to next output area\n         LA    R1,2(R1)                   Bump to next input entry cnt\n         LA    R5,2(R5)                   Bump to next input total cnt\n         BCT   R0,CCL$CL                  Process next count field\n*\n         BAS   R9,CCL$NEWROW              Create new variable\n         LA    R2,CPUCL(R2)               Bump to next one\n         C     R2,CPUC_END                At end of table\n         BL    CCL$L                      Process next CPU entry\n*\nCCL$CLE  EQU   *\n         TM    FLAG1,$F1CPUCT             Already did totals?\n         BO    CCL$CLEX                   Yes, leave\n         OI    FLAG1,$F1CPUCT             Turn on flag\n         LA    R2,LRSTROW                 Locate total work area\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         MVC   0(C_CLT3L,R4),C_CLT3       Get title line 3\n         BAS   R9,CCL$NEWROW              Create new variable\n         B     CCL$LLST                   Do last line\nCCL$CLEX EQU   *\n*\n** Print unsupported record count\n*\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         BAS   R9,CCL$NEWROW              Create new variable\n         L     R8,URCT_ST+4               Locate table\n         LA    R7,0                       Set type\n         LA    R6,256                     Number of records\nCCL$URL  EQU   *\n         ICM   R5,B'1111',0(R8)           Get count for record type\n         BZ    CCL$URLB\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n*                          ....+....1....+....2....+....3....\n         MVC   0(34,R4),=C'Unsupported (other) record type X'''\n         LA    R4,34(R4)\n         STC   R7,DOUBLE\n         UNPK  0(3,R4),DOUBLE(2)\n         MVZ   0(2,R4),=8X'00'\n         TR    0(2,R4),=C'0123456789ABCDEF'\n         LA    R4,2(R4)\n         MVC   0(10,R4),=C''' occurred'\n         LR    R1,R5\n         LA    R15,11(R4)\n         BAS   R9,EDITFWF\n         LA    R4,1(R15)\n         MVC   0(5,R4),=C'times'\n         BAS   R9,CCL$NEWROW\nCCL$URLB EQU   *\n         LA    R8,4(R8)                   Bump to next entry\n         LA    R7,1(R7)                   Increment record type count\n         BCT   R6,CCL$URL                 Try it on for size\n*\n** Print number of records with 1900 century (if any)\n*\n         ICM   R1,B'1111',PAR_C1900\n         BZ    CCL$BDX\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         BAS   R9,CCL$NEWROW              Create new variable\n         MVC   0(36,R4),=C'Number of records with 1900 century:'\n         LA    R15,37(R4)                 Locate output loc for EDITFWF\n         L     R1,PAR_C1900               Get records with bad century\n         BAS   R9,EDITFWF\n*        LA    R4,1(R15)\n         BAS   R9,CCL$NEWROW\nCCL$BDX  DS    0H\n*\n** Print \"footer\" lines\n*\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         BAS   R9,CCL$NEWROW              Create new variable\n         BAS   R14,CCL$CLO                Clear CCL_LINE\n         TM    FLAG1,$F1CPUCO             Have a CPUC overflow\n         BNO   CCL$COCX                   No, continue\n         MVC   0(C_OVERL,R4),C_OVER       Get overflow line\n         MVC   C_OVERL(4,R4),=C'CPUC'     Set table name\n         BAS   R9,CCL$NEWROW              Create new variable\nCCL$COCX EQU   *\n         TM    FLAG1,$F1CPUSO             Have a CPUC overflow\n         BNO   CCL$COSX                   No, continue\n         MVC   0(C_OVERL,R4),C_OVER       Get overflow line\n         MVC   C_OVERL(4,R4),=C'CPUS'     Set table name\n         BAS   R9,CCL$NEWROW              Create new variable\nCCL$COSX EQU   *\n         TM    FLAG1,$F1SUMTO             Have a SUMT overflow\n         BNO   CCL$COSTX                  No, continue\n         MVC   0(C_OVERL,R4),C_OVER       Get overflow line\n         MVC   C_OVERL(4,R4),=C'SUMT'     Set table name\n         BAS   R9,CCL$NEWROW              Create new variable\nCCL$COSTX EQU  *\n         B     CCL$X\n*\n** Clear CCL_LINE to blanks\n*\nCCL$CLO  EQU   *\n         LA    R4,CCL_LINE                Locate output area\n         MVI   0(R4),C' '                 Get blank\n         MVC   1(L'CCL_LINE-1,R4),0(R4)   ..propagate it\n         BSM   0,R14\n*\n** Add new row to stats table\n*\nCCL$NEWROW EQU  *\n         TM    FLAG1,$F1CCLV              Handled variables yet?\n         BO    CCL$NRVX                   Yes, continue\n         OI    FLAG1,$F1CCLV              Set flag\n*->      VDEFINE '(LINE)',CCL_LINE,CHAR,80,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LINE)',                ..Name                       @\n               CCL_LINE,                  ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'80'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VCOPY '(STATABLE)',=F'8',CCL_TBLN,MOVE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(STATABLE)',            ..Name                       @\n               =F'8',                     ..Length                     @\n               CCL_TBLN,                  ..Location                   @\n               =CL8'MOVE'),               ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\nCCL$NRVX EQU   *\n*->      TBADD CCL_TBLN,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'TBADD',         Service: TBADD               @\n               CCL_TBLN),                 ..Table name                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         BSM   0,R9\n*\n** Free CPU count table\n*\nCCL$X    EQU   *\n         LM    R0,R1,CPUC_ST              Get length and address\n         FREEMAIN R,LV=(0),A=(1)          Free storage\n         LM    R0,R1,URCT_ST              Get length and address\n         FREEMAIN R,LV=(0),A=(1)          Free storage\n         EJECT ,\n***********************************************************************\n***\n**       Termination section\n***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n*\n** Close DEBUGOUT DCB (if open)\n*\n*        TM    FLAG2,$F2DEBUG             Debugging?\n         LA    R3,DEBUGOUT                Locate DCB\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN\n         BNO   X$DBX\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize parameter list\n         CLOSE ((3)),MODE=31,MF=(E,PARMLIST)  Close file\n         FREEPOOL DEBUGOUT                Free buffer pool\nX$DBX    DS    0H\n*\n** Delete modules from memory\n*\n         TM    FLAG2,$F2LDATE             Did we load it?\n         BNO   X$DATEX                    No, leave\n         ICM   R0,B'1111',EP_DA$DATE      -> Program Loaded?\n         BZ    X$DATEX                    No, continue\n         DELETE EPLOC==CL8'DA$DATE'       Delete from V/S\nX$DATEX  EQU   *\n*\n         TM    FLAG2,$F2LMXD              Did we load it?\n         BNO   X$MXDX                     No, leave\n         ICM   R0,B'1111',EP_DA$MXD       -> Program Loaded?\n         BZ    X$MXDX                     No, continue\n         DELETE EPLOC==CL8'DA$MXD'        Delete from V/S\nX$MXDX   EQU   *\n*\n         TM    FLAG2,$F2LISPL             Did we load it?\n         BNO   X$ISPLX                    No, leave\n         ICM   R0,B'1111',EP_ISPLINK      -> Program Loaded?\n         BZ    X$ISPLX                    No, continue\n         DELETE EPLOC==CL8'ISPLINK'       Delete from V/S\nX$ISPLX  EQU   *\n*\n** Exit housekeeping\n*\n         DA#LEAVE ,                       Exit housekeeping\n         EJECT ,\n***********************************************************************\n***\n**       Misc Internal subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Initialize LOGO variables to blanks and VDEFINE them if first time\n*\nINITIALIZE_LOGO_VARIABLES EQU *\n         TM    FLAG1,$F1LOGOV             VDEFINEd vars yet?\n         BO    ILV$VDX                    Yes, continue\n         OI    FLAG1,$F1LOGOV             Say we done did it\n*\n*->      VDEFINE '(INFO1)',INFO1,CHAR,80,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(INFO1)',               ..Name                       @\n               INFO1,                     ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'80'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n*->      VDEFINE '(INFO2)',INFO2,CHAR,80,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(INFO2)',               ..Name                       @\n               INFO2,                     ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'80'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n*->      VDEFINE '(INFO3)',INFO3,CHAR,80,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(INFO3)',               ..Name                       @\n               INFO3,                     ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'80'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n*->      VDEFINE '(INFO4)',INFO4,CHAR,80,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(INFO4)',               ..Name                       @\n               INFO4,                     ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'80'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n*->      VDEFINE '(STATUS)',STATUS,CHAR,80,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(STATUS)',              ..Name                       @\n               STATUS,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'80'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\nILV$VDX  EQU   *\n         MVI   INFO1,C' '\n         MVC   INFO1+1(INFOM1L-1),INFO1\n         MVI   INFO3,C' '\n         MVC   INFO3+1(INFOM3L-1),INFO3\n         BSM   0,R9\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITFWF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,EDITMOV                MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '\n         BSM   0,R9                       Return to caller\nEDITMOV  MVC   0(0,R15),0(R1)\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Insert zero\n         LA    R15,1(R15)                 Bump past zero\n         BSM   0,R9                       Return to caller\n*\n**       EDIT FULLWORD (FLUSH TO R15) WITHOUT COMMAS\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nEDITNCF  EQU   *\n         LTR   R1,R1                      Check for zero\n         BZ    EDITNCF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+7               LOCATE SIG DIGIT\n         MVC   DOUBLE2(8),EDITP15F\n         EDMK  DOUBLE2(8),DOUBLE+4        EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,ENCFM                  MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         BSM   0,R9                       RETURN TO CALLER\nENCFM    MVC   0(0,R15),0(R1)\nEDITP15F DC    X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'\nEDITNCF0 DS    0H\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n** Create TSO variable\n**\n** Input: R0 - Length of CLIST variable\n**        R1 - Address of CLIST variable\n**        The name and name length should already be set in CTV_NAMEx\n*\nCREATE_TSO_VARIABLE EQU *\n         STM   R0,R1,CTV_VALUEL           Save value length and address\n         XC    DOUBLE(4),DOUBLE           Reset token\n         L     R15,CVTPTR                 -> CVT\n         L     R15,CVTTVT-CVTMAP(R15)     -> TSVT\n         L     R15,TSVTVACC-TSVT(,R15)    -> CLIST Variable routine\n         CALL  (15),                      Call Variable routine        @\n               (=A(TSVEUPDT),             ..Add/Update variable        @\n               CTV_NAMEP,                 ..Pointer to variable name   @\n               CTV_NAMEL,                 ..Length of variable name    @\n               CTV_VALUEP,                ..Pointer to variable value  @\n               CTV_VALUEL,                ..Length of variable value   @\n               DOUBLE),                   ..Token (not used by us)     @\n               VL,MF=(E,PARMLIST)         ..Variable list and execute\n         BSM   0,R9\n         EJECT ,\n***********************************************************************\n***\n**       Constants\n***\n***********************************************************************\n         SPACE 2\n*\n** Component ID table (mapped by TCID DSECT)\n*\nT_CID    EQU   *\n         DC    CL9'5752SC1CM',CL8'RTM2    '\n         DC    CL9'566528901',CL8'VTAM/XA '\n         DC    CL9'568508501',CL8'VTAM/ESA'\nT_CIDN   EQU   (*-T_CID)/TCIDL\n*\n** IPL device information\n*\nT_IPLS   EQU   *\n         DC    X'10',CL8'Processr'\n         DC    X'20',CL8'DASD'\n         DC    X'30',CL8'Other'\n         DC    X'40',CL8'Tape'\n         DC    X'50',CL8'Card/Prt'\n         DC    X'60',CL8'MICR/OCR'\n         DC    X'70',CL8'TeleProc'\n         DC    X'80',CL8'GrafDisp'\n         DC    X'90',CL8'IBM SCP'\n         DC    X'91',CL8'IBM PP'\nT_IPLSN  EQU   (*-T_IPLS)/(1+8)\nT_IPLSU  DC    X'00',CL8'Unknown'         Unknown type...\n*\n** IPL reasons and their descriptions in string format\n*\nT_IPLR   EQU   *\n         DC    AL2(C_IPLDF-*,$IPLDF),CL8'Default '\n         DC    AL2(C_IPLNM-*,$IPLNM),CL8'Normal  '\n         DC    AL2(C_IPLIE-*,$IPLIE),CL8'CE notRQ'\n         DC    AL2(C_IPLIM-*,$IPLIM),CL8'CE Req  '\n         DC    AL2(C_IPLME-*,$IPLME),CL8'Media   '\n         DC    AL2(C_IPLUN-*,$IPLUN),CL8'Unknown '\n         DC    AL2(C_IPLOP-*,$IPLOP),CL8'Operatn '\n         DC    AL2(C_IPLUP-*,$IPLUP),CL8'UserProg'\n         DC    AL2(C_IPLEN-*,$IPLEN),CL8'Env     '\n         DC    AL2(C_IPLCE-*,$IPLCE),CL8'CESYS   '\nT_IPLRN  EQU   (*-T_IPLR)/(TIPLRL)\n         DC    AL2(C_IPLZZ-*,000000),CL8'Unknown!'\n*\nC_IPLZZ  DA#STR 'Unknown IPL reason, need to update program'\nC_IPLNM  DA#STR 'Normal system initialization'\nC_IPLIE  DA#STR 'IBM hardware/programming problem, CE/PSR not required'\nC_IPLIM  DA#STR 'IBM hardware/programming problem, CE/PSR required'\nC_IPLME  DA#STR 'An IBM hardware unit failed because of a faulty or dam@\n               aged media'\nC_IPLUN  DA#STR 'An undetermied hardare or software failure'\nC_IPLOP  DA#STR 'An operator error or prcedure problem'\nC_IPLUP DA#STR 'A program other than an IBM-supplied control program or@\n                programming product failed'\nC_IPLEN DA#STR 'A failure other than hardware/software or operational c@\n               aused system to be restarted (power, A/C, etc.)'\nC_IPLCE  DA#STR 'System restart at CE/PSR request to correct a problem'\nC_IPLDF DA#STR 'Operator replied \"U\" or entered a null line to message @\n               IFB010D (normal IPL)'\n*\n** Title lines for statistics ISPF screen\n**\n** The C_CLTx title fields must match the order of CPUCCS - CPUCCSN\n*\nC_CLT1   DC    CL8'        ',C' '\n         DC    CL8'        ',C' '\n         DC    CL8'        ',C' '\n         DC    CL8' Program',C' '\n         DC    CL8'    Lost',C' '\n         DC    CL8'        ',C' '\n         DC    CL8' Symptom',C' '\n         DC    CL8'        ',C' '\nC_CLT1L  EQU   *-C_CLT1\nC_CLT2   DC    CL8'CPU     ',C' '\n         DC    CL8'     IPL',C' '\n         DC    CL8'   ABEND',C' '\n         DC    CL8'Interupt',C' '\n         DC    CL8'  Record',C' '\n         DC    CL8'     EOD',C' '\n         DC    CL8' Records',C' '\n         DC    CL8'   Total',C' '\nC_CLT2L  EQU   *-C_CLT2\nC_CLT3   DC    CL8'--------',C' '\n         DC    CL8'--------',C' '\n         DC    CL8'--------',C' '\n         DC    CL8'--------',C' '\n         DC    CL8'--------',C' '\n         DC    CL8'--------',C' '\n         DC    CL8'--------',C' '\n         DC    CL8'--------',C' '\nC_CLT3L  EQU   *-C_CLT3\nC_OVER   DC    C'Warning: LRSOFTLG table overflow: '\nC_OVERL  EQU   *-C_OVER\n*\n** Misc copy constants\n*\nC_CLOSE  CLOSE (*-*),MODE=31,MF=L\nC_CLOSEL EQU   *-C_CLOSE\nC_LSTI   OPEN  (*-*,(INPUT)),MODE=31,MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_LSTO   OPEN  (*-*,(OUTPUT)),MODE=31,MF=L\nC_LSTOL  EQU   *-C_LSTO\n*\nC_DCBI   DCB   DDNAME=C_DCBI,                                          @\n               BUFNO=20,BUFL=7000,                                     @\n               DSORG=PS,MACRF=GL,EODAD=*-*\nC_DCBIL  EQU   *-C_DCBI\nC_DCBIE  DCBE  RMODE31=BUFF,EODAD=PAR$EOF\nC_DCBIEL EQU   *-C_DCBIE\n*\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DCBE=C_DCBOE,                                           @\n               DSORG=PS,MACRF=PM,LRECL=133,RECFM=F\nC_DCBOL  EQU   *-C_DCBO\nC_DCBOE  DCBE  RMODE31=NONE\nC_DCBOEL EQU   *-C_DCBOE\n*\nC_ISTMPV8A DA#DATE DPE,OPREFIX=C_ISTMPV8A,                             @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ISTMPV8,OTYPE=$DA#DATE_ISTMPV\nC_IDJULP4A DA#DATE DPE,OPREFIX=C_IDJULP4A,                             @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP\nC_ODISO10A DA#DATE DPE,OPREFIX=C_ODISO10A,                             @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO\nC_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW\nC_ODDOW1A  DA#DATE DPE,OPREFIX=C_ODDOW1A,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODDOW1,OTYPE=$DA#DATE_ODDOW\nC_OTIMEM11A DA#DATE DPE,OPREFIX=C_OTIMEM11A,                           @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_OTIMEM11,OTYPE=$DA#DATE_OTIMEM\nC_ODJUL6A  DA#DATE DPE,OPREFIX=C_ODJUL6A,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODJUL6,OTYPE=$DA#DATE_ODJUL\n*\n         LTORG ,\n         DS    0D                         End of CSECT\n         EJECT ,\n***********************************************************************\n***\n**       Installation dependent - Match CPU serials to names\n**\n**       Note: It's easier to use the external method of putting\n**             all serial numbers in the REXX exec that invokes us;\n**\n**       Must match mapping DSECT CPUSN\n***\n***********************************************************************\n         SPACE 2\nCPUS     CSECT ,\n         DC    CL8'CPUSNLRS'              Internal eyecatcher name\n*\n         DC    C'123456',CL8'NAMEHERE'\n         DC    C'123456',CL8'NAMEHERE'\n         DC    C'123456',CL8'NAMEHERE'\n*\n         DC    X'FF,FF,FF,FF'             Last entry - must be here!\n         DS    0D                         End of CPUS CSECT\n         EJECT ,\n***********************************************************************\n***\n**       Dynamic Save Area\n***\n***********************************************************************\n         SPACE 2\nDSA      DSECT ,\n         DS    18F                        Register Save Area\nFLAG1    DS    B'00000000'                Flag 1\n$F1CPUCT EQU   B'10000000'                ..CPU Count totals done?\n$F1CPUCO EQU   B'01000000'                ..CPU Count table overflow?\n$F1CPUSO EQU   B'00100000'                ..CPU Serial table overflow?\n$F1SUMTO EQU   B'00010000'                ..SUMT table overflow?\n$F1LOGOV EQU   B'00001000'                ..VDEFINEd LOGO vars?\n$F1CCLV  EQU   B'00000100'                ..CCL - Variables yet?\nFLAG2    DS    B'00000000'                Flag 2\n$F2LDATE EQU   B'10000000'                ..Loaded DA$DATE?\n$F2LISPL EQU   B'01000000'                ..Loaded ISPLINK?\n$F2LMXD  EQU   B'00100000'                ..Loaded DA$MXD?\n$F2DEBUG EQU   B'00010000'                ..Debugging output?\n$F2DUMP  EQU   B'00001000'                ..Debugging output?\nCENT1900 DS    C' '                       Wrong century\n         DS    0D\nDOUBLE2  DS    2D                         Double word work area * 2\nDOUBLE   DS    D                          Double word work area\nPARMLIST DS    XL(CMXDL)                  Parameter list for calls\n*\nACCIN    DS    XL(C_DCBIL)                ACCIN DCB work area\nACCINE   DS    XL(C_DCBIEL)               ACCIN DCBE work area\nDEBUGOUT DS    XL(C_DCBOL)                DEBUGOUT DCB work area\nDEBUGOUE DS    XL(C_DCBOEL)               DEBUGOUT DCBE work area\n         DS    0F                         Entry_Point\nEP_DA$DATE DS  F                          ..DA$DATE\nEP_ISPLINK DS  F                          ..ISPLINK\nEP_DA$MXD  DS  F                          ..DA$MXD\n*                                         CPU serial number table\nCPUS_ST  DS    2F                         ..Length, Address\n*                                         CPU Count table\nCPUC_ST  DS    2F                         ..Length, Address\nCPUC_END DS    F                          ..End of table\nDA#LRSCA DS    F\nDA#LRSCL DS    F\n*                                         Unsupport_Record_Count Table\nURCT_ST  DS    2F                         ..Length, Address\n*                                         Summary Table\nSUMT_ST  DS    2F                         ..Length, Address\nSUMT_END DS    F                          ..End of table\n         DS    0F                         Process_ACCIN_Records\nPAR_RECNUM DS  F                          ..Physical Record number\nPAR_C1900  DS  F                          ..Bad Dates\nPAR_LDTV DS    F                          ..Last date Value\nPAR_LDTR DS    F                          ..Last Date Row number\nPAR_TCNT DS    F                          ..Total add count\nPAR_DBERA DS   F                          ..Debug Entry Return Addr\nPAR_SDAT DS    CL10,CL3                   ..Starting date in ACCIN\nPAR_EDAT DS    CL10,CL3                   ..Ending date in ACCIN\n         DS    0F                         Create_Summary_Table\nCST_TCNT DS    F                          ..Total TBADD count\n         DS    0F                         Create_CPU_Lines\nCCL_TBLN DS    CL8                        ..Table name\nCCL_LINE DS    CL80                       ..Line\n           DS    0F                       Create_TSO_Variable\nCTV_NAMEL  DS    F                        ..CLIST var name length\nCTV_NAMEP  DS    F                        ..Pointer to CLIST Var name\nCTV_VALUEL DS    F                        ..Value length\nCTV_VALUEP DS    F                        ..Value pointer\n*\nZENVIR   DS    CL32'ISPF 4.5MVS     TSO'  ZENVIR (IBM Env. var)\n*\n** LRS table variables\n*\nLRSTABLE DS    CL8                        Table name\n*\nLRSBTIME DS    XL4                        Binary Time for sorts\nLRSBDATE DS    XL4                        Binary Date for sorts\nLRSTROW  DS    0F                         Table row\n         DS    C                          ..Slack byte for edit pattern\nLRSDATEJ DS    CL6'yy.ddd'                ..Julian date\n         DS    C                          ..Slack byte for edit pattern\nLRSTIME  DS    CL11'hh:mm:ss.th'          ..Time of day\nLRSDATEG DS    CL10'ccyy-mm-dd'           ..Gregorian date\nLRSDAY   DS    CL3'sun'                   ..Day of the week\nLRSDAYN  DS    C'0'                       ..Day of the week as number\nLRSTYPE  DS    CL8                        ..Type of record\nLRSJOBN  DS    CL8                        ..Jobname (if software)\nLRSCOMP  DS    CL8                        ..Component or module\nLRSCSCT  DS    CL8                        ..CSECT\nLRSREAS  DS    CL8                        ..Reason\n         DS    C                          ..Slack byte\nLRSSEQN  DS    CL5                        ..Logrec file sequence\nLRSCPU   DS    CL8                        ..CPU name or serial number\nLRSTROWL EQU   *-LRSTROW\nLRSDESC  DS    CL256                      ..Description of record\n*\n** Summary Table variables\n*\nSUMTABLE DS    CL8                        Table name\n*\n* Note: Labels from SUMTROW thru SUMTROWL map both ISPF variables\n*       and each entry in GETMAINed table SUMT_ST. Otay!\n*\nSUMTROW  EQU   *                          Table row\nSUMMOD   DS    CL8                        ..Module name\nSUMCSCT  DS    CL8                        ..CSECT\nSUMREAS  DS    CL8                        ..Reason\nSUMSDATE DS    0CL14                      ..Start date\nSUMSDATG DS    C'1999-12-31'                ..Gregorian date\nSUMSDATS DS    C' '                         ..Space\nSUMSDATD DS    C'FRI'                       ..Day of week\nSUMEDATE DS    0CL14                      ..End Date\nSUMEDATG DS    C'2000-01-01'                ..Gregorian date\nSUMEDATS DS    C' '                         ..Space\nSUMEDATD DS    C'SAT'                       ..Day of week\nSUMCOUNT DS    CL4                        ..Number of matches\nSUMTROWL EQU   *-SUMTROW\n*\nINFO1    DS    CL80\nINFO2    DS    CL80\nINFOM1L  EQU   *-INFO1\nINFO3    DS    CL80\nINFO4    DS    CL80\nSTATUS   DS    CL80\nINFOM3L  EQU   *-INFO3\n*\n** Date routine areas\n*\n         DS    0F\nW_ISTMPV8A     DA#DATE DPE,OPREFIX=W_ISTMPV8A,OSTR=YES,OSTRL=4\nW_IDJULP4A     DA#DATE DPE,OPREFIX=W_IDJULP4A,OSTR=YES,OSTRL=4\nW_ODISO10A     DA#DATE DPE,OPREFIX=W_ODISO10A,OSTR=YES,OSTRL=4\nW_ODDOW3A      DA#DATE DPE,OPREFIX=W_ODDOW3A,OSTR=YES,OSTRL=4\nW_ODDOW1A      DA#DATE DPE,OPREFIX=W_ODDOW1A,OSTR=YES,OSTRL=4\nW_OTIMEM11A    DA#DATE DPE,OPREFIX=W_OTIMEM11A,OSTR=YES,OSTRL=4\nW_ODJUL6A      DA#DATE DPE,OPREFIX=W_ODJUL6A,OSTR=YES,OSTRL=4\n*\nDEBUGMSG DS    CL256    BOZO - Delete me\nTREC     DS    XL4\n         DS    CL256\nTRECS    DS    XL256\n         DS    0D                         Alignment for FREEMAIN\nDSAL     EQU   *-DSA\n         EJECT ,\n***********************************************************************\n***\n**       Internal program DSECTs\n***\n***********************************************************************\n         SPACE 2\n*\n** Map T_IPLR table\n*\nTCID     DSECT ,\nTCID_ID  DS    CL9'5665DAVEA'\nTCID_NM  DS    CL8'Author'\nTCIDL    EQU   *-TCID\n*\n** Map T_IPLR table\n*\nTIPLR    DSECT ,\nTIPLRD   DS    AL2(*-*)                   Offset of Description string\nTIPLRR   DS    CL2'NM'                    Reason\nTIPLRC   DS    CL8'Normal'                Component\nTIPLRL   EQU   *-TIPLR\n*\n** CPU Serial Number Table mapping\n*\nCPUC     DSECT ,\nCPUCN    DS    CL8'Name'                  Name of CPU\nCPUCCS   EQU   *\nCPUCIPL  DS    XL2                        Number of IPL records\nCPUCABN  DS    XL2                        Number of Abend records\nCPUCPI   DS    XL2                        Number of ProgInt records\nCPUCLOST DS    XL2                        Number of Lost records\nCPUCZEOD DS    XL2                        Number of Z EOD records\nCPUCSYM  DS    XL2                        Number of Symptom records\nCPUCTOTL DS    XL2                        Total for this CPU\nCPUCCSN  EQU   (*-CPUCCS)/2\nCPUCL    EQU   *-CPUC\n*\n** CPU Serial Number Table mapping\n*\nCPUSN    DSECT ,\nCPUSNS   DS    CL6'012345'                Serial number\nCPUSNN   DS    CL8'Name'                  Name of CPU (alias)\nCPUSNL   EQU   *-CPUSN\n         EJECT ,\n***********************************************************************\n***\n**       External DSECTs\n***\n***********************************************************************\n         SPACE 2\n*\n** EREP Software Record\n*\nESR      DSECT ,\nESRRDW   DS    XL4                        Variable block RDW\nESRSFT   EQU   *                          Logrec Buffer map (hardware)\n*\nESRERROR DS    0XL10                      RTM Generated Error ID\nESRESEQ  DS    XL2                        Sequence number\nESRECPU  DS    XL2                        CPU Idenitifer\nESREASID DS    XL2                        ASID\nESRETOD  DS    XL4                        Time stamp\n*\n** Software Error (SFT) Record format\n** Copied from GC28-1378-4 EREP User's Guide\n*\nSFT      DSECT ,\nSFTKEY1  DS    X                          Class/Source\nSFTKEY2  DS    X                          System/release level\nSFTSMS   DS    X                          Record-independent switches\nSFTSW2   DS    X                          Record-dependent switch 1\n         DS    X                          Reserved\n         DS    X                          Reserved\nSFTRCDCT DS    X                          Record Count\n         DS    X                          Reserved\nSFTDATE  DS    XL4                        Date\nSFTTIME  DS    XL4                        Time\nSFTCPUID DS    0CL8                       CPU identification\nSFTVER   DS    X                          ..Machine version code\nSFTSER   DS    XL3                        ..CPU Serial number\nSFTMOD   DS    XL2                        ..CPU module number\n         DS    XL2                        ..Reserved\nSFTHEADE EQU   *\nSFTJOBID DS    CL8                        Jobname if not short record\nSFTSDWA  EQU   *                          System Diagnostic work area\n*\n** EOD\n*\n         ORG   SFTHEADE                   Locate to end of header\nEODXL    DS    XL4                        Length of user data\nEODWSC   DS    XL4                        Wait state code\nEODUSERD DS    CL32                       User data\n         ORG   ,\n*\n** Lost record\n*\n         ORG   SFTHEADE                   Locate to end of header\nRCBLCNT  DS    X                          Number of records lost\n         ORG   ,\n*\n** System Initalization Record\n*\n         ORG   SFTHEADE                   Locate to end of header\nIPLSYSID DS    X                          Device type or program that\n*                                         caused restart\n         DS    XL3                        Not used for IPL record\nIPLREAS  DS    XL2                        Reason for IPL\n$IPLNM   EQU   C'NM'                      ..Normal\n$IPLIE   EQU   C'IE'                      ..IBM hardware/prog. problem\n$IPLIM   EQU   C'IM'                      ..IBM hardware/prog. problem\n$IPLME   EQU   C'ME'                      ..Media\n$IPLUN   EQU   C'UN'                      ..Unknown\n$IPLOP   EQU   C'OP'                      ..An unknown hard or sofware\n$IPLUP   EQU   C'UP'                      ..User program\n$IPLEN   EQU   C'EN'                      ..Environmental\n$IPLCE   EQU   C'CE'                      ..CE/PSR has system\n$IPLDF   EQU   C'DF'                      ..Default\nIPLCHNM  DS    XL2                        Channel Map\nIPLCHAN  DS    XL8                        Not used in 370XA\n         ORG   ,\n*\n** SYS1.LOGREC - Header Record\n**\n** Copied from GC28-1670-02 MVS/ESA SP V4 SYS1.LOGREC Error Recording\n*\nHR          DSECT ,\nHR_CLASRC   DS    XL2                     Header record identifier\nHR_LOWLIMIT DS    XL4                     Address of low extent\nHR_UPLIMIT  DS    XL4                     Address of high extent\nHR_MSGCNT   DS    X                       Count of LOGREC Full msgs\nHR_RESTART  DS    XL7                     Address of record entry\nHR_BYTSREM  DS    XL2                     Remaining bytes on track\nHR_TRKCAP   DS    XL2                     Total bytes on track\nHR_LASTTR   DS    XL7                     Address of last track written\nHR_TRKSPER  DS    XL2                     Highest addressable track\nHR_EWMCNT   DS    XL2                     Warning count\nHR_DEVCODE  DS    X                       Device Code\nHR_EWMTRK   DS    XL4                     Early warning message track\nHR_EWMSW    DS    X                       Switch byte:\n$HR$EWMSWF  EQU   B'10000000'             ..90% full\nHR_SFTYBYTS DS    X                       Check byte - should be 1\n#HR$SFTYBYTS EQU  1                       Must be 1 for validity\nHRL         EQU   *-HR\n*\n** SYS1.LOGREC - Time Stamp Record\n**\n** Copied from GC28-1670-02 MVS/ESA SP V4 SYS1.LOGREC Error Recording\n*\nTSR         DSECT ,\nTSR_CLASRC  DS    X                       Class/Source:\n$TSR$CLASRC EQU   B'10000011'             ..Time Stamp Record\nTSR_OPSYS   DS    X                       System/Release Record\nTSR_SW1     DS    B'00000000'             Record switch 1\nTSR$SW1_MR  EQU   B'10000000'             ..More records follow\nTSR$SW1_TOD EQU   B'01000000'             ..Time of Day Instruction\nTSR$SW1_RT  EQU   B'00100000'             ..Record truncated\nTSR$SW1_XA  EQU   B'00010000'             ..Created by SP 2, 3, 4 etc\nTSR$SW1_TME EQU   B'00001000'             ..TIME macro used\nTSR_SW2     DS    B'00000000'             Record switch 2\nTSR_SW3     DS    B'00000000'             Record switch 3\nTSR_SW4     DS    B'00000000'             Record switch 4\n            DS    XL2\nTSR_DATE    DS    XL4                     Date of IPL\nTSR_TIME    DS    XL4                     System time\nTSR_VERNO   DS    X                       Machine version code\nTSR_CPUSER  DS    XL3                     Central Processor Serial\nTSR_CPUMOD  DS    XL2                     CPU model\nTSR_MCELLNG DS    XL2\n            DS    XL16\nTSRL        EQU   *-TSR\n         END   ,\n         EJECT\n***********************************************************************\n***\n**        Linkage editor cards - ASM.PARM='BATCH,...'\n***\n***********************************************************************\n         SPACE 2\n PUNCH ' ENTRY   DA$EREP          '       Entry point\n PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Subroutine: Date routine\n PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Subroutine: Date routine\n PUNCH ' INCLUDE SISPLOAD(ISPLINK) '      Subroutine: ISPF interface\n PUNCH ' NAME    DA$EREP(R)       '       Name of load module\n         END ,\n./ ADD NAME=DA$IDC   0100-01266-01266-1821-02587-02587-00000-DAVE\nDA$IDC   TITLE 'IDCAMS Post Processing Utility'\n* =================================================================== *\n*\n* Name: DA$IDC\n*\n* Author: David Alcock\n*         dave@planetmvs.com\n*\n* Purpose: Enhanced IDCAMS print program.  DA$IDC invokes IDCAMS and\n*          gets control for each record printed on SYSPRINT. This\n*          allows us to reformat without any additional I/O. Sweet!\n*\n*          This program is a \"Screen Scraper\" - Use at your own risk.\n*          This program is a \"Screen Scraper\" - Use at your own risk.\n*          This program is a \"Screen Scraper\" - Use at your own risk.\n*          This program is a \"Screen Scraper\" - Use at your own risk.\n*\n*          Here are some examples of the enhanced lines:\n*\n*          - Translate DEVTYPE hex string to the generic name:\n*            X'3010200E' to 3380\n*          - Creation date given in Gregorian (ISO) format:\n*            CREATION---------1991.011\n*            Sunday.........1991-01-11       <- New line\n*          - Time stamp changed to human form:\n*                 X'A548B2C2CA6A1612'\n*            GMT: 1992-02-22 00:14 AM        <- New line\n*\n*          To make the IDCAMS listing easier to read on SDSF, We\n*          will use real blank lines when we see ANSI control chars.\n*          2001-04-23: I see I have some ANSI code ripped out via\n*                      an AGO around it.  Do find on BOZO\n*\n*          If the RECAP DD statement is allocated, then a \"RECAP\"\n*          of a LISTCAT listing is written.  You might want to make\n*          the SYSPRINT file DUMMY and just get the Recap in some\n*          cases.\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n* Dependencies: Assembler H or higher\n*\n* Limitations: Dependent on IDCAMs format, to maximize performance\n*              the columns are hardcoded (via DSECT). Some IDCAMS\n*              verbs require APF authorization. If those are\n*              needed, this program must be linked AC=1 into\n*              an APF authorized library.\n*\n* Reference: GC26-4019 MVS/XA Access Method Services\n*            Appendix D. Invoking Access Method Services from a\n*                        problem program.\n*\n* Non-IBM External programs:\n* o DA$DATE....Date routine\n* o DA$MXD.....Mini-Hex-Dump routine\n*\n* Non-IBM assembler MACROs:\n* o DA#ENTER...Entry housekeeping\n* o DA#LEAVE...Termination housekeeping\n* o DA#EYEC....Build standard O/S module eyecatcher\n*              (invoked by the DA#ENTER)\n* o DA#REGS....Define registers (invoked by DA#ENTER)\n* o DA#DATE....Equates and DSECTs for the date routine\n* o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine\n* o DA#SMODE...Change addressing mode to/from 24 bit/31 bit\n*\n* CSECTs used:\n* o Internal:\n*   o DA$IDC.....Main CSECT\n*   o IDC$IOR....IDCAMS I/O routine\n*   o IDC$RCP....Recap of IDCAMS listing\n*   o IDC$PRR....Pring Report Record\n*   o IDC$ERR....Error Processing\n* o External:\n*   o DA$MXD.....Mini-Hex-Dump routine\n*   o DA$DATE....Date routine\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* E n h a n c e m e n t   I d e a s\n*\n*  An enterprising person could add the following enhancements:\n*  - Add a line with the UCB for DASD\n*    VOLSER------------SYSRES   <- IBM\n*    UCB/VOLSER---xxxx/SYSRES   <- Changed\n*\n*  - Call TMS for tape volsers via the CA API:\n*    CJOB------------YSM001DP  STEPNAME--------DUMPSMF   <- New line\n*    LRECL--------------32756  BLKSIZE-----------32760   <- New line\n*\n* =================================================================== *\n         EJECT\n&IDCVER  SETC  '2.2'\n* =================================================================== *\n*\n*             M o d i f i c a t i o n   H i s t o r y\n*\n* 2001-06-12 -- David Alcock -- V2.2:\n* - Instead of overlaying the Device Type, I now add another line:\n*   > IBM:  DevType------X'78048083'   (Modified for Mix case)\n*   > Dave: Unit Name---------3590-1   (Added after this line)\n* - Check for device type of \"00000000\" and bypass IEFEB4UV call\n*\n* 2001-04-23 -- David Alcock -- V2.1:\n* - Changed Creation date to format: 'DayOfWeek.....ccyy-mm-dd'\n*   from:                            'Creation-------DOW dd-MM'\n* - Changed all gregorian dates from dd-mm-ccyy to ccyy-mm-dd (ISO)\n* - Indicate that the timestamp value is GMT.\n*\n* 07-MAY-1998 -- David Alcock -- V2.0:\n* - Renamed to DA$IDC and changed to use DA* macros\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* 22-FEB-1992 -- David Alcock -- V1.5\n* - Added creation date to gregorian\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* 05-APR-1991 -- David Alcock -- V1.4\n* - Changed SNAP to DA#MXD;\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* 15-MAR-1991 -- David Alcock -- V1.3\n* - Added check for valid input IDCAMS records;\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* 24-JAN-1989 -- David Alcock -- V1.2\n* - MVS 2.2 support (GDG output change\n* - DATA/INDEX cluster support\n* - ERROR report processing\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* 03-OCT-1988 -- David Alcock -- V1.1\n* - Changed EDT device string from hard-\n* - coded lookup to IEFEB4UV.\n* - Added TimeStamp date conversion\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* 15-SEP-1986 -- David Alcock -- V1.0\n* - Initial program 5-SEP-1986\n* =================================================================== *\n         EJECT\n***********************************************************************\n***\n**       External DSECTs\n***\n***********************************************************************\n         SPACE 2\n*\n** IBM's Macros\n*\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO          Communications Vector Table\n         IEFUCBOB ,                       Unit Control Block\n         DCBD  DSORG=PS,DEVD=DA           Data Control Block\n         IEFJFCBN ,                       Job File Control Block\n         IHAPSA ,                         Prefixed Save Area\n         IEFTIOT1 ,                       Task I/O Table\n         IKJTCB DSECT=YES,LIST=NO         Task Control Table\n         IECSDSL1 (1)                     F1 Data Set Control Block\n*\n** David Alcock's Macros\n*\n         DA#DATE ,                        Date routine\n         DA#MXD ,                         Hex Dump routine\n         PRINT GEN\n         EJECT\n***********************************************************************\n***\n**       Initialization\n***\n***********************************************************************\n         SPACE 2\n         EJECT\nDA$IDC   DA#ENTER 'IDCAMS POST PROCESSING',                            @\n               RENT=YES,                    Indicate GETMAIN required  @\n               LV=DSAL                      Lenght of GETMAIN\n         USING DSA,R13                      Addressability to work area\n*\n** Misc Initializations\n*\n         ST    R1,IDC_PARM                Save R1 on entry\n         ST    R12,EP_DA$IDC              Save our EPA for routines\n         MVC   FLAG_LIT(4),=C'FLAG'       Set literal for debugging\n*\n** Load routines to be used for life of job\n*\n         LA    R8,N_EB4UV\n         LOAD  EPLOC=(8),ERRET=E$LOAD\n         ST    R0,EP_IEFEB4UV\n*\n         ICM   R0,B'1111',=V(DA$DATE)     Linked into us\n         BNZ   I$LDARS\n         LA    R8,N_DA$DATE\n         LOAD  EPLOC=(8),ERRET=E$LOAD\n         OI    FLAG1,$F1_LDA#DATE\nI$LDARS  DS    0H\n         ST    R0,EP_DA$DATE\n*\n** Set the current date and time for IDC$PRR\n*\n         MVC   PRR_ODISO10(C_ODISO10L),C_ODISO10\n         MVC   PRR_OTIMES11(C_OTIMES11L),C_OTIMES11\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of Date routine\n         CALL  (15),(PRR_ODISO10,PRR_OTIMES11),VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n         EJECT\n***********************************************************************\n***\n**       Ensure that files are allocated\n***\n***********************************************************************\n         SPACE 2\n*\n** Ensure that SYSIN is allocated\n*\n         LA    R8,=CL8'SYSIN'             DDNAME TO CHECK\n         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED\n         BXH   R15,R15,E$DD               Do error routine if not...\n*\n** Ensure that SYSPRINT is allocated\n*\n         LA    R8,=CL8'SYSPRINT'          DDNAME TO CHECK\n         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED\n         BXH   R15,R15,E$DD               Do error routine if not...\n*\n** Check for DATAONLY (No Heading) DD statement\n*\n         LA    R8,=CL8'DATAONLY'          DDNAME TO CHECK\n         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED\n         BXH   R15,R15,I$NHX              WAS IT ALLOCATED?\n         OI    FLAG1,$F1_DATAO            NO HEADING WANTED\nI$NHX    EQU   *\n*\n** Check for $$DEBUG\n*\n         LA    R8,=CL8'$$DEBUG'           DDNAME to check\n         BAS   R9,CHECKDD                 Allocated?\n         BXH   R15,R15,I$DBX              No, continue\n*\n         ICM   R0,B'1111',=V(DA$MXD)      Linked into us?\n         BNZ   I$LMXDRS                   Yes, continue\n         LA    R8,N_DA$MXD                Locate =CL8'DA#MXD'\n         LOAD  EPLOC=(8),ERRET=E$LOAD     Load module into storage\n         OI    FLAG1,$F1_LDA#MXD          Turn on flag\nI$LMXDRS DS    0H\n         ST    R0,EP_DA$MXD               Save address\n         OI    FLAG1,$F1_DEBUG            Turn on flag\nI$DBX    EQU   *\n         EJECT\n***********************************************************************\n***\n**        Error report initialization\n***\n***********************************************************************\n         SPACE 2\n*\n** Check for ERROR report\n*\n         LA    R8,=CL8'ERROR'             DDNAME to check\n         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED\n         BXH   R15,R15,I$REX              DDNAME=ERROR ALLOCATED?\n         OI    FLAG1,$F1_ERROR            TURN ON FLAG\n*\n         LA    R1,99                      GET LINE COUNT\n         STC   R1,ERR_RLC                 FORCE HEADING ON FIRST PRINT\nI$REX    EQU   *\n         EJECT\n***********************************************************************\n***\n**       Recap processing initialization\n***\n***********************************************************************\n         SPACE 2\nINITIALIZE_RECAP EQU *\n*\n** Check for RECAP DD statement\n*\n         LA    R8,=CL8'RECAP'             DDNAME TO CHECK\n         BAS   R9,CHECKDD                 ENSURE IT IS ALLOCATED\n         BXH   R15,R15,IR$X               DDNAME=RECAP ALLOCATED?\n         OI    FLAG1,$F1_RECAP            TURN ON FLAG\n*\n         LA    R1,99                      GET LINE COUNT\n         STC   R1,RCP_RLC                 FORCE HEADING ON FIRST PRINT\n*\n         MVI   RCP_TBL,0                  Ensure initialization\n*\n** Common exit from INITIALIZE_RECAP processing\n*\nIR$X     EQU   *\n         EJECT\n***********************************************************************\n***\n**       Invoke IDCAMS\n***\n***********************************************************************\n         SPACE 2\n*\n** SET UP I/O ROUTINE PARAMETERS\n*\n         LA    R1,1                      NUMBER OF GROUPS\n         ST    R1,IDC_ION                SAVE NUMBER\n         LA    R1,C_IDCDD                LOCATE DDNAME STRING\n         ST    R1,IDC_IODD               SAVE ADDRESS INTO LIST\n         L     R1,=V(IDC$IOR)            LOCATE I/O ROUTINE ADDRESS\n         ST    R1,IDC_IOR                SAVE FOR LATER\n         ST    R13,IDC_IOUD              SAVE ADDRESS OF DSA\n         LA    R3,IDC_IOL                LOCATE IO LIST\n*\n** PAGE NUMBERS\n*\n         LA    R1,3                      GET PARM FROM JCL\n         STCM  R1,B'0011',IDC_PL         SAVE PAGE NUMBER LENGTH\n         MVC   IDC_PNUM(3),=C'100'       STARTING PAGE NUMBER\n*\n** INVOKE IDCAMS\n*\n         LINK  EPLOC=N_IDCAMS,           CALL IDCAMS                   @\n               PARAM=(IDC_PARM,=H'00',IDC_P,(3)),                      @\n               VL=1,MF=(E,PARMLIST)\n         LR    R2,R15                     Save return code\n         EJECT\n***********************************************************************\n***\n**       Termination section\n***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n*\n** Delete routines that have been loaded\n*\n         TM    FLAG1,$F1_LDA#DATE         Loaded DA#DATE?\n         BNO   X$DATEX                    No, continue\n         ICM   R1,B'1111',EP_DA$DATE      GET ROUTINE ADDRESS\n         BZ    X$DATEX                    NONE, MOVE ON\n         DELETE EPLOC=N_DA$DATE           DELETE IT\nX$DATEX  DS    0H\n*\n         TM    FLAG1,$F1_LDA#MXD          Loaded DA#MXD?\n         BNO   X$MXDX                     No, continue\n         ICM   R1,B'1111',EP_DA$MXD       GET ROUTINE ADDRESS\n         BZ    X$MXDX                     NONE, MOVE ON\n         DELETE EPLOC=N_DA$MXD            DELETE IT\nX$MXDX   DS    0H\n*\n         ICM   R1,B'1111',EP_IEFEB4UV     GET ROUTINE ADDRESS\n         BZ    X$EB4UVX                   NONE, MOVE ON\n         DELETE EPLOC=N_EB4UV             DELETE IT\nX$EB4UVX EQU   *\n*\n** Return to caller\n*\n         LR    R15,R2                     GET IDCAMS RETURN CODE\n         DA#LEAVE RC=(15)                 EXIT STAGE LEFT\n         EJECT\n***********************************************************************\n***\n**       Error routines\n***\n***********************************************************************\n         SPACE 2\n*\n** Module could not be loaded\n*\nE$LOAD   EQU   *\n         BAS   R9,FORMWTO                 Format the WTO\n         MVC   0(MSG1L,R15),MSG1          Move message to WTO area\n         MVC   MSG1L(8,R15),0(R8)         Move in module name\n         LA    R1,RCP_WA                  Locate WTO\n         WTO   ,MF=(E,(1))                Issue WTO\n         B     EXIT                       Leave\n*\n** DDNAME not found, R8 points to 8 byte DDNAME\n*\nE$DD     EQU   *\n         BAS   R9,FORMWTO                 Format the WTO\n         MVC   0(MSG2L,R15),MSG2          Move message to WTO area\n         LA    R15,MSG2L(R15)             Bump past message\n         MVC   0(8,R15),0(R8)             Move in DDNAME\n         LA    R1,RCP_WA                  Locate WTO\n         WTO   ,MF=(E,(1))                Issue WTO\n         B     EXIT\n         EJECT\n***********************************************************************\n***\n**       Misc internal subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      Check for 0\n         BZ    EDITFWF0                   Yes, put zero\n         CVD   R1,DOUBLE                  No, convert to packec\n         LA    R1,DOUBLE2+14              Locate sig digit\n         MVC   DOUBLE2(15),EDITFWFP\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for ex\n         EX    R14,EDITFWFM               Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '\n         BSM   0,R9                       Return to caller\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Put in zero\n         LA    R15,1(R15)                 Bump pointer past zero\n         BSM   0,R9                       Return to caller\n*\n** FORMAT THE WTO AND INSERT MESSAGE PREFIX\n*\nFORMWTO  EQU   *\n         LA    R15,RCP_WA                 LOCATE WTO\n         MVC   0(C_WTOL,R15),C_WTO        MOVE IN WTO CONSTANTS\n         LA    R15,4(R15)                 BUMP PAST HEADER BYTES\n         MVC   0(6,R15),DA$IDC_ECNAME     Get \"DA$IDC\" from DA#ENTER\n         LA    R15,6(R15)                 Bump past it\n         BSM   0,R9\n*\n** ENSURE THAT DDNAME POINTED TO BY R8 IS ALLOCATED\n*\nCHECKDD  EQU   *\n         DEVTYPE (8),DOUBLE2              TEST IT\n         BSM   0,R9                       RETURN TO CALLER\n*\n** POINT REGISTER 15 TO FIRST BLANK IN STRING\n** INPUT:  R0  - MAXIMUM LENGTH OF STRING\n**         R15 - STRING\n** OUTPUT: R15 - FIRST SPACE IN STRING\n*\nLOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '\n         BE    LFS$X\n         LA    R15,1(R15)\n         BCT   R0,LOCATE_FIRST_SPACE\nLFS$X    EQU   *\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***\n**       Constants\n***\n***********************************************************************\n         SPACE 2\nMSG1     DC    C'-01E Required module could not be loaded, Name='\nMSG1L    EQU   *-MSG1\nMSG2     DC    C'-02E File not allocated, DD='\nMSG2L    EQU   *-MSG2\n*\n*\nN_IDCAMS DC    CL8'IDCAMS'                Mr. ID CAMS\nN_DA$MXD DC    CL8'DA$MXD'                Mini-Hex-Dump routine\nN_DA$DATE DC   CL8'DA$DATE'               Date Conversion routine\nN_EB4UV  DC    CL8'IEFEB4UV'              EDT Verification\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\n*\n** Copy constants\n*\nC_ODISO10 DA#DATE DPE,OPREFIX=C_ODISO10,OSTR=NO,                       @\n               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO\nC_OTIMES11 DA#DATE DPE,OPREFIX=C_OTIMES11,OSTR=NO,                     @\n               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES\n*\nC_IDCDD  DC    CL10'DDSYSPRINT'\n         DS    0D\nC_WTO    WTO   '                                                       @\n                                                                       @\n                      ',                                               @\n               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\n*\n** Literals used in DA$IDC\n*\n         LTORG ,\n         DS    0D\n         EJECT ,\n***********************************************************************\n***\n**       DA$IDC -- IDC$IOR --- I/O SUBROUTINE\n**\n**       Input Parameter list:\n**       +0 .. User parameter - DSA address\n**       +4 .. I/O flags\n**       +8 .. IOINFO\n***\n***********************************************************************\n         SPACE 2\n         DROP  R13,R12\nIDC$IOR  DA#ENTER 'I/O ROUTINE'\n         L     R11,0(R1)                  Get address of DSA\n         USING DSA,R11                    Addressibility\n*\n* Note: The DA#ENTER macro leaves trash in the high order byte of R13\n*       which causes 31-bit sensitive programs like IEFEB4UV to S0C4.\n         LA    R13,0(R13)                 Clear high order byte\n*\n**       R3 -- IOFLAGs\n**       R4 -- IOINFO\n*\n         LM    R3,R4,4(R1)                Get 2nd & 3rd parameters\n         CLI   IOF_B1-IOF(R3),$IOF_O      OPEN request?\n         BE    IOR$OPEN\n         CLI   IOF_B1-IOF(R3),$IOF_C      CLOSE Request?\n         BE    IOR$CLS\n         CLI   IOF_B1-IOF(R3),$IOF_P      PUT Request?\n         BE    IOR$PUT\n*\n** Common exit from I/O routine\n*\nIOR$X    EQU   *\n         DA#LEAVE ,\n         EJECT\n***********************************************************************\n***\n**       IDC$IOR --- Open SYSPRINT FILE\n***\n***********************************************************************\n         SPACE 2\nIOR$OPEN EQU   *\n*\n** Open SYSPRINT DCB\n*\n         LA    R5,SYSPRINT                LOCATE DCB WORK AREA\n         MVC   0(C_DCBVOL,R5),C_DCBVO     COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'SYSPRINT'\n*\n         LA    R1,IOR_JFCBX               Locate exit list\n         STCM  R1,B'0111',DCBEXLST-IHADCB+1(R5) Save into DCB\n         LA    R14,IOR_JFCB               Locate JFCB return area\n         ST    R14,0(R1)                  Save into JFCB area\n         OI    0(R1),X'87'                TURN ON JFCB + END-OF-LIST\n*\n         LA    R6,PARMLIST                LOCATE PARM LIST\n         MVC   0(C_RJFCBL,R6),C_RJFCB     COPY IN READ-JOB-FILE-C.B.\n         RDJFCB ((5),(OUTPUT)),           READ JFCB                    @\n               MF=(E,(6))\n         LTR   R15,R15                    TEST RESULT OF READ JFCB\n         BZ    IOR$OJF                    OKAY: MOVE ON\n         LA    R0,125                     LRECL\n         LA    R1,629                     BLKSIZE\n         B     IOR$OJFX                   LEAVE\n*\nIOR$OJF  EQU   *\n         LA    R14,IOR_JFCB               LOCATE JOB-FILE-CONTROL-BLK\n         SLR   R0,R0                      CLEAR REGISTER\n         ICM   R0,B'0011',JFCLRECL-INFMJFCB(R14) GET LRECL FROM JCL\n         BNZ   IOR$OJLX                   WE HAVE SOMETHING, MOVE ON\n         LA    R0,125                     SET DEFAULT LRECL\nIOR$OJLX EQU   *\n         SLR   R1,R1                      CLEAR REGISTER\n         ICM   R1,B'0011',JFCBLKSI-INFMJFCB(R14) GET BLKSIZE FROM JCL\n         BNZ   IOR$OJBX                   WE HAVE SOMETHING, MOVE ON\n         LA    R1,629                     SET DEFAULT BLKSIZE\nIOR$OJBX EQU   *\n*\nIOR$OJFX EQU   *\n*\n         STCM  R0,B'0011',DCBLRECL-IHADCB(R5) INSERT LRECL\n         STCM  R1,B'0011',DCBBLKSI-IHADCB(R5) INSERT BLKSIZE\n         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST\n         OPEN  ((5),(OUTPUT)),                                         @\n               MF=(E,PARMLIST)\n*\n** OPEN RECAP FILE (IF FLAG IS SET)\n*\n         TM    FLAG1,$F1_RECAP\n         BNO   IOR$ORX\n         LA    R5,RECAP                   LOCATE DCB WORK AREA\n         MVC   0(C_DCBOL,R5),C_DCBO       COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'RECAP'\n         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST\n         OPEN  ((5),(OUTPUT)),                                         @\n               MF=(E,PARMLIST)\nIOR$ORX  EQU   *\n*\n** Open ERROR file (if flag is set)\n*\n         TM    FLAG1,$F1_ERROR\n         BNO   IOR$OEX\n         LA    R5,ERROR                   LOCATE DCB WORK AREA\n         MVC   0(C_DCBOL,R5),C_DCBO       COPY IN DCB CONSTANT\n         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'ERROR'\n         MVC   PARMLIST(C_LSTOL),C_LSTO   COPY IN OPEN PARM LIST\n         OPEN  ((5),(OUTPUT)),                                         @\n               MF=(E,PARMLIST)\nIOR$OEX  EQU   *\n*\n** Open $$DEBUG file (if flag is set)\n*\n         TM    FLAG1,$F1_DEBUG            Debugging mode?\n         BNO   IOR$OSX                    No, continue\n         LA    R5,$$DEBUG                 Locate DCB area\n         MVC   0(C_DCBOL,R5),C_DCBO       Initialize DCB\n         MVC   DCBDDNAM-IHADCB(8,R5),=CL8'$$DEBUG'\n         MVC   PARMLIST(C_LSTOL),C_LSTO   Initialize Parameter List\n         OPEN  ((5),(OUTPUT)),MF=(E,PARMLIST)\n*\n         MVI   $$DEBUGR,C' '\n         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR\n         LA    R15,$$DEBUGR+1\n         L     R1,EP_DA$IDC\n#IOR$OL  EQU   DA$IDC_ECL-(DA$IDC_ECNAME-DA$IDC)\n         MVC   0(#IOR$OL,R15),DA$IDC_ECNAME-DA$IDC(R1)\n         LA    R15,#IOR$OL+1(R15)\n         MVC   0(17,R15),=C'-- $$DEBUG output'\n         PUT   $$DEBUG,$$DEBUGR\n         MVI   $$DEBUGR,C' '\n         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR\n         PUT   $$DEBUG,$$DEBUGR\nIOR$OSX  EQU   *\n*\n** Common Exit from IOR$OPEN\n*\nIOR$OX   EQU   *\n         B     IOR$X\n         EJECT\n***********************************************************************\n***\n**       IDC$IOR --- PUT SYSPRINT record\n***\n***********************************************************************\n         SPACE 2\nIOR$PUT  EQU   *\n         MVI   FLAGP1,0                   Initialize put flag\n*\n         L     R4,0(R4)                   Locate record\n         BAS   R14,CLRRECV                Clear out record area\n         LA    R15,2                      Length of record length\n         SR    R4,R15                     Locate record length\n*\n** Initialize record from input IDCAMS\n*\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0011',0(R4)           Get length of record\n         BZ    IOR$RCM                    Zero?\n         BNM   IOR$RCMX                   Minus?\nIOR$RCM  EQU   *\n         LA    R1,1                       Must be at least one\nIOR$RCMX EQU   *\n         BCTR  R1,0                       Decrement for EX\n         EX    R1,IOR$RECM                Move record\n         LA    R1,4+1(R1)                 Add back 1 and for RDW\n         STCM  R1,B'0011',RECOUTV         Save length of record\n*\n** Dump input record if option is on\n*\n         TM    FLAG1,$F1_DEBUG\n         BNO   IOR$SBX\n         MVI   $$DEBUGR,C' '\n         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR\n         MVC   $$DEBUGR+1(IOR_DBGL),IOR_DBG Get message\n         PUT   $$DEBUG,$$DEBUGR           Locate print routine\n*\n         BAS   R9,IOR$DUMP_RECOUT         Dump recout\nIOR$SBX  EQU   *\n*\n** Process the Device type string - give it meaning\n*\n         LA    R1,RECOUT+8                VSAM type location\n         BAS   R9,P$DevType               Process for Device type\n         LA    R1,RECOUT+37               Non-VSAM type location\n         BAS   R9,P$DevType               Process for Device type\n*\n         LA    R1,RECOUT+37               Non-VSAM type location\n         BAS   R9,P$CDATE                 Process for Creation date\n*\n         LA    R1,RECOUT+37               Non-VSAM type location\n         BAS   R9,P$EDATE                 Process for Expiration date\n*\n         LA    R1,RECOUT+71               Time Stamp location (VSAM)\n         BAS   R9,P$TIMEST                Process for Time Stamp\n*\n         LA    R1,RECOUT                  Title starting location\n         BAS   R9,P$TITLE                 Process for Title\n*\n         TM    FLAGP1,$FP1_DEL            Delete (don't print record)?\n         BO    IOR$PRTX                   Yes, continue\n*\n** Make listing easier to read on SDSF.  Change FBA to real spacing\n** (triple space)\n*\n AGO .BOZO\n         CLI   RECOUT,C'-'                Skipping a line?\n         BNE   IOR$FBADX\n         MVC   RECOUTS(RECOUTVL),RECOUTV  Save record\n         MVC   RECOUTV(5),=X'00,05,00,00,40'  RDW+C' '\n         LA    R5,SYSPRINT                DCB\n         LA    R6,RECOUTV                 Record to print\n         PUT   (5),(6)                    Print record\n         MVC   RECOUTS(RECOUTVL),RECOUTV  Save record\n         MVC   RECOUTV(5),=X'00,05,00,00,40'  RDW+C' '\n         LA    R5,SYSPRINT                DCB\n         LA    R6,RECOUTV                 Record to print\n         PUT   (5),(6)                    Print record\n         MVC   RECOUTV(RECOUTVL),RECOUTS  Reset record\n         MVI   RECOUT,C' '                Change spacing\nIOR$FBADX EQU  *\n.BOZO ANOP ,\n*\n** Make listing easier to read on SDSF.  Change FBA to real spacing\n** (double space)\n*\n         CLI   RECOUT,C'0'                Skipping a line?\n         BNE   IOR$FBA0X\n         MVC   RECOUTS(RECOUTVL),RECOUTV  Save record\n         MVC   RECOUTV(5),=X'00,05,00,00,40'  RDW+C' '\n         LA    R5,SYSPRINT                DCB\n         LA    R6,RECOUTV                 Record to print\n         PUT   (5),(6)                    Print record\n         MVC   RECOUTV(RECOUTVL),RECOUTS  Reset record\n         MVI   RECOUT,C' '                Change spacing\nIOR$FBA0X EQU  *\n*\n** Print the record\n*\n         LA    R5,SYSPRINT                DCB\n         LA    R6,RECOUTV                 Record to print\n         PUT   (5),(6)                    Print record\nIOR$PRTX EQU   *\n*\n** Debugging stuff\n*\n         TM    FLAG1,$F1_DEBUG            Debugging mode?\n         BNO   IOR$SAX                    No, continue\n         MVI   $$DEBUGR,C' '              Get blank\n         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR ..Propagate it\n         TM    FLAGP1,$FP1_ADD            Adding record?\n         BO    IOR$SAA                    No, continue\n         TM    FLAGP1,$FP1_DEL            Deleting record?\n         BO    IOR$SAD                    No, continue\n         TM    FLAGP1,$FP1_MOD            Modified the record?\n         BNO   IOR$SAN                    No, continue\n         LA    R15,$$DEBUGR+1             Locate record\n         MVC   0(IOR_DBGL,R15),IOR_DBG    Move in message\n         MVC   IOR_DBGA-IOR_DBG(6,R15),=C'after ' Change it\n         PUT   $$DEBUG,$$DEBUGR           Locate print routine\n*\n         BAS   R9,IOR$DUMP_RECOUT         Dump record after mod\n         B     IOR$SANX                   Continue\n*\nIOR$SAA  EQU   *                 ....+....1....+....2....+..\n         LA    R15,$$DEBUGR+1             Locate record\n         MVC   0(IOR_DBGB,R15),IOR_DBG    Move in message\n         MVC   IOR_DBGA-IOR_DBG(6,R15),=C'added:' Change it\n         PUT   $$DEBUG,$$DEBUGR           Locate print routine\n*\n         BAS   R9,IOR$DUMP_RECOUT         Dump record after mod\n         B     IOR$SANX                   Continue\n*\nIOR$SAD  EQU   *                 ....+....1....+....2....+..\n         MVC   $$DEBUGR+1(22),=C'*** Record deleted ***'\n         PUT   $$DEBUG,$$DEBUGR           Locate print routine\n         B     IOR$SANX                   Continue\n*\nIOR$SAN  EQU   *                 ....+....1....+....2....+..\n         MVC   $$DEBUGR+1(27),=C'*** Record not modified ***'\n         PUT   $$DEBUG,$$DEBUGR           Locate print routine\nIOR$SANX EQU   *\n         MVI   $$DEBUGR,C' '\n         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR\n         PUT   $$DEBUG,$$DEBUGR           Locate print routine\n         PUT   $$DEBUG,IOR_DASH           Print dash line\nIOR$SAX  EQU   *\n*\n** Call RECAP if option is on\n*\n         TM    FLAG1,$F1_RECAP            Option on?\n         BNO   IOR$PRX                    No, continue\n         L     R15,=V(IDC$RCP)            Locate routine\n         CALL  (15),                      Call it                      @\n               ((11)),                    ..DSA address                @\n               MF=(E,PARMLIST)            ..Execution parms\nIOR$PRX  EQU   *\n*\n** Common exit from IOR$PUT processing\n*\nIOR$PX   EQU   *\n         B     IOR$X                      LEAVE\n*\nIOR$RECM MVC   RECOUT(0),2(R4)            ** EXECUTED **\n         EJECT ,\n***********************************************************************\n***\n**       Dump complete RECOUT to $$DEBUG file\n***\n***********************************************************************\n         SPACE 2\nIOR$DUMP_RECOUT EQU *\n         XC    $$DEBUGW(CMXDL),$$DEBUGW   Initialize area\n         LA    R15,RECOUTV                Locate record\n         LA    R0,RECOUTVL                Get length of record\n         LA    R1,$$DEBUGR+1              Locate output area\n         STM   R15,R1,$$DEBUGW+CMXD_ADDRESS-CMXD Data, Length, Output\n         MVC   $$DEBUGW+CMXD_OUTPUTL-CMXD(2),=AL2(133)\nIOR$DRL  EQU   *\n         MVI   $$DEBUGR,C' '\n         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR\n         LA    R1,$$DEBUGW                Locate work area\n         L     R15,EP_DA$MXD              -> DA#MXD E.P.A.\n         BASSM R14,R15                    Call DA#MXD\n         LR    R8,R15                     Save return code\n         PUT   $$DEBUG,$$DEBUGR           Locate print routine\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   IOR$DRL                    Thank you, May I have another\n*\n         MVI   $$DEBUGR,C' '\n         MVC   $$DEBUGR+1(L'$$DEBUGR-1),$$DEBUGR\n         PUT   $$DEBUG,$$DEBUGR           Print blank record\n         BSM   0,R9\n         EJECT\n***********************************************************************\n***\n**       IDC$IOR --- CLOSE SYSPRINT\n***\n***********************************************************************\n         SPACE 2\nIOR$CLS  EQU   *\n*\n** Recap termination\n*\nIOR$CRT  EQU   *\n         TM    FLAG1,$F1_RECAP            Recap done?\n         BNO   IOR$CRTX                   No, move on\n         BAS   R14,CLRRECV                INIT RECORD\n         LA    R15,1+9(R15)               Bump past FBA+\"IDC0002I \"\n         MVI   RECOUT,C'1'                Set FBA\n         MVC   0(IOR_M3L,R15),IOR_M3      Get message\n         LA    R15,IOR_M3L(R15)           Bump past it\n         BAS   R9,PRINTREC                Print record\n*\n         LA    R2,RCP_TBL\n         LA    R4,RCP_TBLT                Locate total entry\nIOR$CRTL EQU   *\n         BAS   R9,CLRRECV                 Clear record\n         LA    R15,10(R15)                Bump to data location\n         MVI   0(R15),C'-'                Set fill character\n         MVC   1(11,R15),0(R15)           ..Propagate it\n         SLR   R1,R1                      Clear register\n         IC    R1,RT_TYPEL-RT(R2)         Get type length\n         MVC   0(0,R15),RT_TYPE-RT(R2)    ** Executed **\n         EX    R1,*-6                     Move to output line\n         LA    R14,1(R1,R15)              Locate past last byte\n         MVI   0(R14),C' '                Insert space\n         LA    R15,12(R15)                Bump past type\n*\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0111',RT_CNT-RT(R2)   Get count\n         CR    R2,R4                      Doing total entry?\n         BE    IOR$CRTT                   Yes, don't change total total\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0111',RT_CNT-RT(R4)  Get total count\n         AR    R14,R1                     Add entry to total count\n         STCM  R14,B'0111',RT_CNT-RT(R4)  Save total count\nIOR$CRTT EQU   *\n*\n         CVD   R1,DOUBLE                  Convert to packed\n         MVC   0(15,R15),IOR_EP15         Get edit pattern\n         MVI   0(R15),X'60'               Change fill character\n         ED    0(15,R15),DOUBLE+2         Edit it\n         OI    14(R15),C'0'               Ensure zero\n         LA    R15,16(R15)                Bump past output number\n         BAS   R9,PRINTREC                Print it\n         LA    R2,RTL(R2)                 Bump to next entry\n         CR    R2,R4\n         BNH   IOR$CRTL                   No, do next entry\nIOR$CRTX EQU   *\n*\n** Close SYSPRINT file\n*\n         LA    R5,SYSPRINT                Locate DCB\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE Initialize parameter list\n         CLOSE ((5)),MF=(E,PARMLIST)\n*\n** Close RECAP file\n*\n         TM    FLAG1,$F1_RECAP            RECAP TURNED ON?\n         BNO   IOR$CRX                    NO, MOVE ON\n*\n         CLI   RO_NAME-RO(R6),C' '        ANYTHING LEFTOVER?\n         BNE   IOR$CRC                    NO, MOVE ON\n         PUT   RECAP,RCP_REC              PRINT RECORD\n*\nIOR$CRC  EQU   *\n         LA    R5,RECAP                   LOCATE DCB\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE GET PARM LIST\n         CLOSE ((5)),                                                  @\n               MF=(E,PARMLIST)\nIOR$CRX  EQU   *\n*\n** Close error file\n*\n         TM    FLAG1,$F1_ERROR            ERROR file option on?\n         BNO   IOR$CEX                    No, continue\n         LA    R5,ERROR                   Locate DCB\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE Get parameter list\n         CLOSE ((5)),                     Close ERROR file             @\n               MF=(E,PARMLIST)            ..w/Parameter list\nIOR$CEX  EQU   *\n*\n** Close debug file\n*\n         TM    FLAG1,$F1_DEBUG            Option on?\n         BNO   IOR$CSX                    No, continue\n         LA    R5,$$DEBUG                 Locate DCB\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE Get parameter list\n         CLOSE ((5)),                     Close ERROR file             @\n               MF=(E,PARMLIST)            ..w/Parameter list\nIOR$CSX  EQU   *\n*\n** Common exit from IOR$CLS\n*\nIOR$CX   EQU   *\n         B     IOR$X\n         EJECT\n***********************************************************************\n***\n**       IDC$IOR --- Misc subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Print RECOUT/RECOUTV on file SYSPRINT\n** Input: R15 - last character on line\n*\nPRINTREC EQU   *\n         LA    R1,RECOUTV\n         SR    R15,R1\n         STH   R15,0(R1)\n         PUT   SYSPRINT,RECOUTV\n         BSM   0,R9\n*\n** INITIALIZE VARIABLE RECORD\n*\nCLRRECV  EQU   *\n         XC    RECOUTV(4),RECOUTV         CLEAR RDW\n         LA    R15,RECOUT                 LOCATE RECOUT BEGINNING\n         MVI   0(R15),C' '                GET SPACE\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..PROPAGATE IT\n         BSM   0,R14\n*\n**       EDIT FULLWORD (FLUSH TO R15)\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nIOR$EDITFWF EQU *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    IOR$EDITFWF0               YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),IOR_EP15\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         MVC   0(0,R15),0(R1)\n         EX    R14,*-6                    MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER\n         BSM   0,R9                       RETURN TO CALLER\nIOR$EDITFWF0 EQU *\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,2(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n** Process Title line\n**\n** R1 - points to expected location for \"1IDCAMS  SYSTEM...\n**\n**       ---7----+----8----+----9----+----0----+----1---\n**  IBM: TIME: 19:08:09        04/23/01     PAGE    100\n**  Me:  Time: 19:08:09   ccyy-04-23        Page    100\n*\nP$TITLE  EQU   *\n         CLC   0(7,R1),=C'1IDCAMS'        Title record?\n         BNE   PT$X                       No, leave\n         TM    FLAG1,$F1_HEADING          Headings Printed?\n         BNO   PT$H                       No, continue\n         OI    FLAGP1,$FP1_DEL            Yes, delete this heading\n         B     PT$X                       ..and leave\nPT$H     EQU   *\n         OI    FLAG1,$F1_HEADING          Headings Printed!!!!\n         OI    FLAGP1,$FP1_MOD            Yes, we modified the record\n         MVC   10(14,R1),=C'ystem Services' Make mixed case\n         MVC   25(L'PT_LIT,R1),PT_LIT\n*-Here we transform the '     mm/dd/yy' to ISO: 'ccyy-mm-dd   '\n         CLI   91(R1),C'/'                Looks good?\n         BNE   PT$DX\n         CLI   94(R1),C'/'                Still looking good?\n         BNE   PT$DX\n         CLI   97(R1),C' '                Looks like a 2 digit date?\n         BNE   PT$DX\n* Note: this is date windowing code!  It will fail unmodified in 2063\n         CLC   95(2,R1),=C'62'            looks like a 19xx date?\n         BH    PT$D19\n         MVC   84(2,R1),=C'20'            Looks like the 21st century\n         B     PT$D19X\nPT$D19   DS    0H\n         MVC   84(2,R1),=C'19'            Looks like the 20th century\nPT$D19X  DS    0H\n         MVC   86(2,R1),95(R1)            Move year over\n         MVI   88(R1),C'-'\n         MVI   91(R1),C'-'\n         MVC   94(3,R1),=C'   '           Blank out \"/yy\"\nPT$DX    DS    0H\n*\n         CLC   67(4,R1),=C'TIME'\n         BNE   PT$TX\n         MVC   68(3,R1),=C'ime'\nPT$TX    DS    0H\n*\n         CLC   102(4,R1),=C'PAGE'\n         BNE   PT$PGX\n         MVC   103(3,R1),=C'age'\nPT$PGX   DS    0H\n*\nPT$X     EQU   *\n         BSM   0,R9\nPT_LIT   DC    C'- Processed by DA$IDC v&IDCVER'\n*\n** Process Expiration date\n**\n** R1 - points to expected location for \"Expiration------1992.011\"\n*\nP$EDATE  DS    0H\n         CLC   0(11,R1),=C'EXPIRATION-'   Expiration date?\n         BNE   PED$X                      No, leave\n         MVC   1(9,R1),=C'xpiration'      Make mixed case\n* Note: we could check for 99.365 here and print NEVER here...\n         OI    FLAGP1,$FP1_MOD            Yes, we modified the record\nPED$X    EQU   *                          No, leave\n         BSM   0,R9\n*\n** Process Creation date\n**\n** R1 - points to expected location for \"CREATION--------1992.011\"\n**\n** Older code did this:                 \"Creation------SUN 11-JAN\"\n** Newer code does this:                \"dayofweek ... ccyy-mm-dd\"\n*\nP$CDATE  EQU   *\n         CLC   0(10,R1),=C'CREATION--'    Creation?\n         BNE   PCD$X                      No, leave\n         MVC   1(7,R1),=C'reation'        Make mixed case\n         OI    FLAGP1,$FP1_ADD            Say we are adding a record\n         ST    R1,DOUBLE                  Save output location\n*\n         MVC   W_IDJULC8(C_IDJULC8L),C_IDJULC8 Set date input code\n         MVC   W_IDJULC8_STR(8),16(R1)    Get Julian date\n         CLI   W_IDJULC8_STR,C'-'         Have century?\n         BNE   PCD$CX                     Yes, continue\n         MVC   W_IDJULC8_STR(2),=C'19'    Assume century is 19\nPCD$CX   EQU   *\n*\n         LA    R5,SYSPRINT                Locate DCB\n         LA    R6,RECOUTV                 Record to print\n         PUT   (5),(6)                    Print record asis\n*\n         BAS   R14,CLRRECV                Clear record\n*\n         L     R15,DOUBLE                 Locate output area\n         MVC   W_ODDOWA(C_ODDOW9AL),C_ODDOW9A Initialize input code\n         ST    R15,W_ODDOWA_STR           Move in output location ptr\n         LA    R15,14(R15)                Bump to place for ccyy-mm-dd\n         MVC   W_ODISOA(C_ODISO10AL),C_ODISO10A\n         ST    R15,W_ODISOA_STR           Move in output location ptr\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of Date routine\n         CALL  (15),(W_IDJULC8,W_ODDOWA,W_ODISOA),                     @\n               VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n*-Insert dots between Day of the week and the ISO date\n         L     R15,DOUBLE                 Locate output area\n         LA    R15,6(R15)                 \"Monday\" Shortest day of week\n         LA    R0,8                       \"Monday........ccyy-mm-dd\"\nPCD$DL   DS    0H\n         CLI   0(R15),C' '                Blank?\n         BNE   PCD$DLB                    Nope...\n         MVI   0(R15),C'.'                Yep, replace with dot\nPCD$DLB  DS    0H\n         LA    R15,1(R15)\n         BCT   R0,PCD$DL\n*-Complete output line\n         L     R15,DOUBLE                 Locate Time stamp location\n         LA    R15,24(R15)                Bump past output stuff\n         LA    R1,RECOUTV                 Locate beginning of record\n         SR    R15,R1                     Length = end - beginning\n         STH   R15,RECOUTV                Save length\nPCD$X    EQU   *\n         BSM   0,R9                       Return to caller\n*\n** Process Time Stamp\n**\n** R1 - points to expected location for \"X'................'\"\n*\nP$TIMEST EQU   *\n         CLC   0(2,R1),=X'E7,7D'          \"X'\"\n         BNE   PTS$X                      No, leave\n         CLC   2(16,R1),=16C'0'           All zeros?\n         BE    PTS$X                      Yes, why bother...\n         OI    FLAGP1,$FP1_ADD            Say we are adding a record\n*\n         LA    R15,2(R1)                  Bump to hex string\n         ST    R15,DOUBLE                 Save output location\n         MVC   W_ISTMPC16(C_ISTMPC16L),C_ISTMPC16  Get timestamp\n         MVC   W_ISTMPC16_STR(16),0(R15)  Move in number\n*\n         LA    R5,SYSPRINT                Locate DCB\n         LA    R6,RECOUTV                 Record to print\n         PUT   (5),(6)                    Print record asis\n*\n         BAS   R14,CLRRECV                CLEAR RECORD\n         L     R15,DOUBLE                 Locate Time stamp location\n         SH    R15,=H'7'                  Backup to start\n         MVC   0(4,R15),=C'GMT:'\n         LA    R15,5(R15)\n         MVC   W_ODISOA(C_ODISO10AL),C_ODISO10A\n         ST    R15,W_ODISOA_STR           Set pointer to output area\n         MVC   W_OTIMESA(C_OTIMES8AL),C_OTIMES8A\n         LA    R15,10+1(R15)              Bump past it\n         ST    R15,W_OTIMESA_STR          Set pointer to output area\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of Date routine\n         CALL  (15),(W_ISTMPC16,W_ODISOA,W_OTIMESA),                   @\n               VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n*\n         L     R15,DOUBLE                 Locate Time stamp location\n         LA    R15,11+1+8(R15)            Bump past output stuff\n         LA    R1,RECOUTV                 Locate beginning of record\n         SR    R15,R1                     Length = end - beginning\n         STH   R15,RECOUTV                Save length\nPTS$X    EQU   *\n         BSM   0,R9                       Return to caller\n*\n** Process Device Type\n**\n** R1 - points to expected location for \"DEVTYPE---\"\n*\nP$DevType DS 0H\n         CLC   0(10,R1),=C'DEVTYPE---'    Device type?\n         BNE   PDT$X                      No, leave\n         MVC   0(10,R1),=C'DevType---'    Make easier on the IIs\n         CLC   15(8,R1),=C'00000000'      Migrated?\n         BE    PDT$Migrated               Yes, skip translate\n*-Output IBM line\n         OI    FLAGP1,$FP1_ADD            We're adding a record\n         ST    R1,DOUBLE                  Save output location\n         MVC   DT_VALUE(8),15(R1)         Save hex string\n\n         LA    R5,SYSPRINT                Locate DCB\n         LA    R6,RECOUTV                 Record to print\n         PUT   (5),(6)                    Print record asis\n*-Call IBM program that converts a device type to a unit name\n         LA    R1,PARMLIST+8              Locate Unit table area\n         MVI   0(R1),0                    Get hex zero\n         MVC   1(20-1,R1),0(R1)           ..Propagate them\n         LA    R1,8(R1)                   Locate output location\n         LA    R0,4                       Output length\n         LA    R15,DT_VALUE               Locate device type hex string\n         BAS   R8,HEXTRAN                 Translate to hex value\n         BXH   R15,R15,PDT$X              Leave if invalid hex string\n         DA#SMODE 31                      Get into 31 bit mode\n         L     R15,EP_IEFEB4UV            Locate EPA of IEFEB4UV\n         CALL  (15),                      Call unit verification       @\n               (PARMLIST+8,=X'2000'),     ..Unit table, flags          @\n               VL,MF=(E,PARMLIST)         ..Parameter area\n         DA#SMODE 24                      Get back to 24 bit mode\n         ST    R15,DOUBLE+4               Save Return code (BXH trashs)\n         BXH   R15,R15,PDT$ERR            Leave if could not translate\n*-Create a new line with translated unit name\n         BAS   R14,CLRRECV                Clear record\n         L     R15,DOUBLE                 Locate \"DEVTYPE----\"\n         MVC   0(9,R15),=C'Unit Name'\n         MVI   9(R15),C'-'                Get dash\n         MVC   10(15,R15),9(R15)          and propagate it\n         LA    R15,24-8(R15)              Locate to place to put string\n         LA    R6,PARMLIST+8              Point to translate Devtype\n         LA    R7,8                       Set length of string\n         BAS   R14,RIGHT_JUSTIFY          Right justify the string\n         B     PDT$RDW                    Complete RDW Header\n*-IBM's IEFEB4UV got a bad RC, print that on output.\nPDT$ERR  DS    0H\n         BAS   R14,CLRRECV                Clear record\n         L     R15,DOUBLE                 LOCATE THE ORIGINAL STRING\n         MVC   0(12,R15),=C'IEFEB4UV rc='\n         LA    R15,12(R15)\n         UNPK  0(9,R15),DOUBLE+4(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         MVI   8(R15),C' '\nPDT$RDW  DS    0H                         Need good RDW for line\n         L     R15,DOUBLE                 Locate original output loc\n         LA    R15,24(R15)                Bump past output stuff\n         LA    R1,RECOUTV                 Locate beginning of record\n         SR    R15,R1                     Length = end - beginning\n         STH   R15,RECOUTV                Save length\n         B     PDT$X\n*-The device type is \"00000000\" which usually means migrated\nPDT$Migrated DS 0H\n         OI    FLAGP1,$FP1_MOD            We modified the record\n*-Common Exit from P$DevType processing\nPDT$X    DS    0H\n         BSM   0,R9                       Return to caller\n*\n** RIGHT JUSTIFY A STRING\n** INPUT: R15 ADDRESS TO PUT STRING\n**        R6  ADDRESS OF STRING\n**        R7  LENGTH OF STRING\n** OUTPUT: STRING WILL BE RIGHT JUSTIFIED AT ADDRESS OF R15\n*\nRIGHT_JUSTIFY EQU *\n         ST    R14,RJ_RA                  SAVE RETURN ADDRESS\n         SLR   R0,R0                      CLEAR COUNTER\n         LR    R1,R7                      GET LENGTH TO WORK REG\n         LR    R14,R6                     GET ADDRESS TO WORK REG\nRJ$CSL   EQU   *\n         CLI   0(R14),C' '                SPACE?\n         BNE   RJ$CSB                     NO, MOVE ON\n         AH    R0,=H'1'                   INCREMENT COUNTER\nRJ$CSB   EQU   *\n         LA    R14,1(R14)                 BUMP TO NEXT BYTE\n         BCT   R1,RJ$CSL                  ..DO IT\n         CR    R7,R0                      IS STRING ALL BLANKS?\n         BE    RJ$EXIT                    YES, LEAVE\n         LR    R1,R0                      GET NUM OF BLANKS\n         LA    R14,0(R1,R15)              PLACE TO PUT STRING\n         LR    R1,R7                      GET LENGTH\n         SR    R1,R0                      NUMBER OF NON-BLANKS\n         BCTR  R1,0                       DECREMENT FOR EX\n         EX    R1,RJ$MOVE                 RIGHT JUSTIFY STRING\nRJ$EXIT  EQU   *\n         L     R14,RJ_RA                  GET RETURN ADDRESS\n         BSM   0,R14                      RETURN TO CALLER\nRJ$MOVE  MVC   0(0,R14),0(R6)             ** EXECUTED **\n*\n** Convert a hex string from character\n** For example: From CL8'3020100E' to X'3020100E'\n**\n** Input: R0 - Length of output string (input / 2)\n**        R1 - Output location\n**        R15 - Input location\n*\nHEXTRAN  DS    0H\n         STM   R3,R6,HT_SAVEREGS          Save registers\nHT$MT    EQU   *\n         MVI   0(R1),0                    Zero output byte\n         LA    R4,1                       Offset for first hex char\n         LA    R5,2                       Number of Nibbles in a byte\nHT$CL    EQU   *\n         LA    R6,T_HEX                   Locate Hex table\n         LA    R3,T_HEXE                  Number of entries in table\nHT$C1L   EQU   *\n         CLC   0(1,R6),0(R15)             Match?\n         BE    HT$C1LX                    Yes, move on\n         LA    R6,3(R6)                   No, bump to next byte\n         BCT   R3,HT$C1L                  Repeat\n         B     HT$X                       Character not valid\nHT$C1LX EQU    *\n         LA    R6,0(R4,R6)                Bump to bitstring\n         OC    0(1,R1),0(R6)              Turn on bits for this nibble\n         LA    R4,1(R4)                   Increment for next nibble\n         LA    R15,1(R15)                 Bump to the next input byte\n         BCT   R5,HT$CL                   Do next hex nibble in byte\n         LA    R1,1(R1)                   Bump to next output byte\n         BCT   R0,HT$MT                   ..do it\n         SLR   R15,R15                    Clear register: success\nHT$X     EQU   *\n         LM    R3,R6,HT_SAVEREGS          Restore registers\n         BSM   0,R8\n         EJECT\n***********************************************************************\n***\n**       IDC$IOR --- Constants\n***\n***********************************************************************\n         SPACE 2\nIOR_M3   DC    C'The number of entries from Recap processing:'\nIOR_M3L  EQU   *-IOR_M3\nIOR_DASH DC    C' ',132C'-'\n*\nIOR_EP15 DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\n*\nIOR_DBG  DC    C'Dump of IDCAMS record '\nIOR_DBGB EQU   *-IOR_DBG\nIOR_DBGA DC    C'before'\n         DC    C' modification:'\nIOR_DBGL EQU *-IOR_DBG\n*\nC_ISTMPC16 DA#DATE DPE,OPREFIX=C_ISTMPC16,OSTR=NO,                     @\n               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC\nC_IDJULC8  DA#DATE DPE,OPREFIX=C_IDJULC8,OSTR=NO,                      @\n               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC\nC_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW\nC_ODDOW9A  DA#DATE DPE,OPREFIX=C_ODDOW9A,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODDOW9,OTYPE=$DA#DATE_ODDOW\nC_ODISO10A DA#DATE DPE,OPREFIX=C_ODISO10A,                             @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO\nC_OTIMES8A DA#DATE DPE,OPREFIX=C_OTIMES8A,                             @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES\n*\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\n*\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\n*\nC_DCBVO  DCB   DDNAME=C_DCBVO,                                         @\n               DSORG=PS,MACRF=(PM),RECFM=VBA\nC_DCBVOL EQU   *-C_DCBVO\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DSORG=PS,MACRF=(PM),RECFM=FBA,LRECL=133\nC_DCBOL  EQU   *-C_DCBO\n*\n         DS    0D\nC_RJFCB  RDJFCB (*-*,(INPUT)),MF=L\nC_RJFCBL EQU   *-C_RJFCB\n*\n** HEX TABLE FORMAT:\n**   C'0'         - CHARACTER THAT WE ARE CONVERTING\n**   B'11110000'  - FIRST NIBBLE OF BYTE\n**   B'00001111'  - LAST NIBBLE OF BYTE\n*\nT_HEX    EQU   *\n         DC    C'0',B'00000000',B'00000000'\n         DC    C'1',B'00010000',B'00000001'\n         DC    C'2',B'00100000',B'00000010'\n         DC    C'3',B'00110000',B'00000011'\n         DC    C'4',B'01000000',B'00000100'\n         DC    C'5',B'01010000',B'00000101'\n         DC    C'6',B'01100000',B'00000110'\n         DC    C'7',B'01110000',B'00000111'\n         DC    C'8',B'10000000',B'00001000'\n         DC    C'9',B'10010000',B'00001001'\n         DC    C'A',B'10100000',B'00001010'\n         DC    C'B',B'10110000',B'00001011'\n         DC    C'C',B'11000000',B'00001100'\n         DC    C'D',B'11010000',B'00001101'\n         DC    C'E',B'11100000',B'00001110'\n         DC    C'F',B'11110000',B'00001111'\nT_HEXE   EQU   ((*-T_HEX)/(1+1+1))\n*\n** Literals used in IDC$IOR\n*\n         LTORG ,\n         DS    0D\n         DROP  R11,R12                    DROP REGISTER USED\n         EJECT\n***********************************************************************\n***\n**       DA$IDC -- IDC$RCP -- RECAP\n***\n***********************************************************************\n         SPACE 2\nIDC$RCP  DA#ENTER 'RECAP OF IDCAMS LISTING'\n         L     R11,0(R1)                  GET ADDRESS OF PROGRAM PARMS\n         USING DSA,R11                    ADDRESSIBLITY TO WORK AREA\n*\n** INITIALIZE RECORD ADDRESS/LENGTH REGISTERS\n*\n         LA    R4,RECOUT                  LOCATE RECORD\n         SLR   R5,R5                      CLEAR REGISTER\n         ICM   R5,B'0011',RECOUTV         GET LENGTH OF RECORD\n         SH    R5,=H'4'                   DECREMENT FOR L'RDW\n*\n** Initialize routine table if not done already\n*\n         CLI   RCP_TBL,0                  Table initialized?\n         BNE   RCP$TIX                    Yes, move on\n         LA    R15,RCP_TBL                Locate work area table\n         LA    R1,T_TYPE                  Locate constant table\n         LA    R0,T_TYPEN                 Get number of entries\nRCP$TIL  EQU   *\n         MVC   0(T_TYPEL,R15),0(R1)       Move in entry\n         LA    R15,RTL(R15)               Bump to next output entry\n         LA    R1,T_TYPEL(R1)             Bump to next input entry\n         BCT   R0,RCP$TIL                 Repeat\n         MVC   RCP_TBLT(1+5),T_TYPET      Move in total entry\n*\n         LA    R14,RCP_REC+RO_VOLS-RO     Locate starting location\n         ST    R14,RCP_OVSC               Save as current entry\n         LA    R14,RCP_REC+L'RCP_REC-8    Locate to last possible\n         ST    R14,RCP_OVSE               Save it\nRCP$TIX  EQU   *\n*\n** Search routine table for this record\n*\nRCP$TCHK EQU   *\n         LA    R1,RCP_TBL                 Locate type table\n         LA    R0,T_TYPEN                 Number of entries in table\nRCP$TL   EQU   *\n         SLR   R3,R3                      Clear register\n         IC    R3,RT_TYPEL-RT(R1)         Get length of this entry\n         CLC   RT_TYPE-RT(0,R1),RECOUT+1  ** Executed **\n         EX    R3,*-6                     Type match?\n         BE    RCP$TFND                   Yes, leave\n         LA    R1,RTL(R1)                 Bump to next entry\n         BCT   R0,RCP$TL                  Repeat\n*\n** New type not found, do current routine\n*\n         ICM   R14,B'1111',RCP_TBLC       Get current table entry\n         BZ    RCP$X                      None, at beginning of listing\n         LA    R6,RCP_REC                 Locate output record\n         L     R14,RT_IROUT-RT(R14)       Locate input routine\n         BSM   0,R14                      Perform it\n*\n** Found entry in table, execute the routine\n*\nRCP$TFND EQU   *\n         ST    R1,RCP_TBLN                Save next entry\n         LA    R6,RCP_REC                 Locate output record\n         ICM   R14,B'1111',RCP_TBLC       Get current table entry\n         BZ    RCP$TFPX                   None, first time thru\n         L     R14,RT_OROUT-RT(R14)       Locate output entry\n         BSM   0,R14                      Execute the routine\nRCP$TFPX EQU   *\n         LA    R6,RCP_REC                 Locate output record\n         MVI   0(R6),C' '                 Insert blank\n         MVC   1(L'RCP_REC-1,R6),0(R6)    ..Propagate blank\n*\n         L     R1,RCP_TBLN                Save next entry\n         ST    R1,RCP_TBLC                Save as current\n         MVC   RO_TYPE-RO(11,R6),RT_TYPE-RT(R1) Get entry type\n*\n         SLR   R15,R15                    Clear register\n         ICM   R15,B'0111',RT_CNT-RT(R1)  Get count\n         LA    R15,1(R15)                 Increment by 1\n         STCM  R15,B'0111',RT_CNT-RT(R1)  Save count\n*\n         LA    R14,RCP_REC+RO_VOLS-RO     Locate starting location\n         ST    R14,RCP_OVSC               Save as current entry\n*\n         L     R14,RT_IROUT-RT(R1)        Locate input routine\n         BSM   0,R14                      Perform it\n*\n** Common exit from module IDC$RCP\n*\nRCP$X    EQU   *\n         DA#LEAVE RC=0,RENT=NO\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- AIX\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IAI  EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(3,R4),T_TYPEA+1   \"AIX\"\n         BE    RCP$SENT                   Yes, save it\n         B     RCP$X                      Dont process this one\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OAI  EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Alias\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IA   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(5,R4),T_TYPEA+1   \"ALIAS\"\n         BE    RCP$SENT                   Yes, save it\n         CLC   IL_MOPTL(7,R4),=C'USERCAT'\n         BE    RCP$IAU                    Yes, save it\n         B     RCP$X                      Dont process this one\n*\n** UserCatalog\n*\nRCP$IAU  EQU   *\n         LA    R1,RO_CAT-RO(R6)          Locate output area\n         B     RCP$SENTT                  Get User Catalog name\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OA   EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Cluster\n***\n***********************************************************************\n         SPACE 2\n*\n** Map RCP_WA\n*\nC_DATA   EQU   0,44\nC_INDEX  EQU   44,44\nC_L      EQU   44+44\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IC   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(7,R4),T_TYPEC+1   \"CLUSTER\"\n         BE    RCP$ICE                    Yes, save it\n         CLC   IL_MOPTL(4,R4),T_TYPED+1   \"DATA\"\n         BE    RCP$ICD                    Yes, save it\n         CLC   IL_MOPTL(4,R4),T_TYPEI+1   \"INDEX\"\n         BE    RCP$ICI                    Yes, save it\n         B     RCP$X                      Dont process this one\n*\n** Cluster name\n*\nRCP$ICE  EQU   *\n         MVI   RCP_WA,C' '                Set to blank\n         MVC   RCP_WA+1(C_L-1),RCP_WA     ..propagate\n         LA    R1,RCP_WA+C_DATA           Locate data output area\n         B     RCP$SENT                   Save it\n*\n** Data entry\n*\nRCP$ICD  EQU   *\n         LA    R1,RCP_WA+C_DATA           Locate data output area\n         B     RCP$SENTT                  Save it\n*\n** Index entry\n*\nRCP$ICI  EQU   *\n         LA    R1,RCP_WA+C_INDEX          Locate index output area\n         B     RCP$SENTT                  Save it\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OC   EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Data component of Cluster\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$ID   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(4,R4),T_TYPED+1   \"DATA\"\n         BE    RCP$SENT                   Yes, save it\n         CLC   IL_MOPTL(6,R4),=C'VOLSER'\n         BE    RCP$MVSL                   Yes, save it\n         CLC   IL_MOPTL(7,R4),=C'DEVTYPE'\n         BE    RCP$MDTL                   Yes, save it\n         B     RCP$X                      Dont process this one\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OD   EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Index component of Cluster\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$II   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(5,R4),T_TYPEI+1   \"INDEX\"\n         BE    RCP$SENT                   Yes, save it\n         CLC   IL_MOPTL(6,R4),=C'VOLSER'\n         BE    RCP$MVSL                   Yes, save it\n         CLC   IL_MOPTL(7,R4),=C'DEVTYPE'\n         BE    RCP$MDTL                   Yes, save it\n         B     RCP$X                      Dont process this one\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OI   EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Non-VSAM processing\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$INV  EQU   *\n*\n** Lines in NONVSAM output to consider\n*\n         CLC   IL_MFBAL(7,R4),T_TYPENV+1  \"NONVSAM\"\n         BE    RCP$SENT\n         CLC   IL_MOPTL(6,R4),=C'VOLSER'\n         BE    RCP$DDT\n         B     RCP$X\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$ONV  EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- GDG BASE\n***\n***********************************************************************\n         SPACE 2\n*\n** Map RCP_WA for GDG processing\n*\nG_COUNT  EQU   0,4\nG_LIMIT  EQU   4,4\nG_ATTR1  EQU   8,10\nG_ATTR2  EQU   18,10\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IG   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(3,R4),T_TYPEG+1   \"GDG BASE\"\n         BE    RCP$IGE                    Yes, save it\n         CLC   IL_MOPTL(7,R4),T_TYPENV+1  \"NONVSAM\"\n         BE    RCP$IGNV                   Get count\n         CLC   IL_MOPTL(5,R4),=C'LIMIT'   Limit?\n         BE    RCP$IGL                    Yes, process it\n         B     RCP$X                      Dont process this one\n*\n** Entry\n*\nRCP$IGE  EQU   *\n         LA    R1,RCP_WA\n         XC    G_COUNT(4,R1),G_COUNT(R1)\n         B     RCP$SENT                   Yes, save it\n*\n** Limit/Attribute processing\n*\nRCP$IGL  EQU   *\n         MVC   RCP_WA+G_ATTR1(10),IL_GATTR1L(R4)\n         MVC   RCP_WA+G_ATTR2(10),IL_GATTR2L(R4)\n         LA    R15,IL_GLMTL(R4)           Locate input string\n         LA    R14,3                      Set string length\n         LA    R1,RCP_WA+G_LIMIT          Locate output location\n         BAS   R9,TRAPNUM                 Trap \"Limit------------xxx\"\n         B     RCP$X\n*\n** Count entries\n*\nRCP$IGNV EQU   *\n         L     R14,RCP_WA+G_COUNT         Get count\n         LA    R14,1(R14)                 Increment by 1\n         ST    R14,RCP_WA+G_COUNT         Save count\n         B     RCP$X                      Continue\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OG   EQU   *\n         LA    R15,RO_DEVT-RO(R6)         Locate past \"GDG \"\n         MVC   0(6,R15),=C'COUNT='\n         LA    R15,6(R15)\n         L     R1,RCP_WA+G_COUNT          Get count\n         CVD   R1,DOUBLE\n         UNPK  0(4,R15),DOUBLE+6(2)\n         OI    3(R15),C'0'\n*\n         LA    R15,RO_VOLS-RO(R6)\n         MVC   0(6,R15),=C'LIMIT='\n         LA    R15,6(R15)\n         L     R1,RCP_WA+G_LIMIT          Get count\n         CVD   R1,DOUBLE\n         UNPK  0(4,R15),DOUBLE+6(2)\n         OI    3(R15),C'0'\n*\n         LA    R15,RO_VOLS+12-RO(R6)\n         MVC   0(11,R15),=C'Attributes:'\n         LA    R15,11+1(R15)\n         MVC   0(10,R15),RCP_WA+G_ATTR1\n         LA    R15,10+1(R15)\n         MVC   0(10,R15),RCP_WA+G_ATTR2\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Page Space\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IPS  EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(9,R4),T_TYPEPS+1  \"PAGESPACE\"\n         BE    RCP$SENT                   Yes, save it\n         CLC   IL_MOPTL(6,R4),=C'VOLSER'\n         BE    RCP$MVSL                   Yes, save it\n         CLC   IL_MOPTL(7,R4),=C'DEVTYPE'\n         BE    RCP$MDTL                   Yes, save it\n         B     RCP$X                      Dont process this one\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OPS  EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Path\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IP   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(4,R4),T_TYPEP+1   \"PATH\"\n         BE    RCP$SENT                   Yes, save it\n         B     RCP$X                      Dont process this one\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OP   EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Space\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IS   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(5,R4),T_TYPES+1   \"SPACE\"\n         BE    RCP$SENT                   Yes, save it\n         B     RCP$X                      Dont process this one\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OS   EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- User Catalog\n***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Input processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$IU   EQU   *\n*\n** Lines to consider\n*\n         CLC   IL_MFBAL(10,R4),T_TYPEU+1  \"USERCATALOG\"\n         BE    RCP$SENT                   Yes, save it\n         CLC   IL_MOPTL(6,R4),=C'VOLSER'\n         BE    RCP$DDT\n         B     RCP$X                      Dont process this one\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Output processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRCP$OU   EQU   *\n         B     RCP$PENT\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Internal subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Save Device Type\n*\nRCP$MDTL EQU   *\n         MVC   RO_DEVT-RO(11,R6),IL_MDTL(R4) Get device type\n         LA    R0,11                      Length of string\n         LA    R15,RO_DEVT-RO(R6)         Locate string\n         BAS   R14,RCP$ROD                Rub out dashes\n         B     RCP$X\n*\n** \"VOLSER---------xxxxxx    DEVTYPE-----X'3010200E\" type records\n*\nRCP$DDT  EQU   *\n         CLI   RO_DEVT+L'RO_DEVT-1-RO(R6),C' ' Have a device type yet?\n         BNE   RCP$DDTX                   Yes, skip it\n         MVC   RO_DEVT-RO(11,R6),IL_DDT(R4) Get device type\n         LA    R0,11                      Get length of string\n         LA    R15,RO_DEVT-RO(R6)         Locate string\n         BAS   R14,RCP$ROD                Rub out them dashes\nRCP$DDTX EQU   *\n*=> Fall into RCP$DVS...  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n*\n** Save volser\n*\nRCP$DVS  EQU   *\n         LA    R1,IL_DVS(R4)              Locate volser (input)\n         B     RCP$SVS\nRCP$MVSL EQU   *\n         LA    R1,IL_MVSL(R4)             Locate volser (input)\nRCP$SVS  EQU   *\n         LM    R14,R15,RCP_OVSC           Get Current output location\n         CR    R14,R15                    Compare with last possible\n         BH    RCP$SVSE                   Error, at end of the line\n         MVC   0(6,R14),0(R1)             Get volume serial\n         LA    R14,6+1(R14)               Bump past it\n         ST    R14,RCP_OVSC               Save current location\n         B     RCP$X                      Leave\nRCP$SVSE EQU   *\n         MVI   RCP_REC+L'RCP_REC-5,C'+'   Indicate truncation\n         B     RCP$X                      Leave\n*\n** Print entry information\n*\nRCP$PENT EQU   *\n*\n         TM    FLAG1,$F1_DATAO            Headings wanted?\n         BO    RCP$PEHX                   No, skip heading stuff\n         L     R15,=V(IDC$PRR)            Locate print routine\n         CALL  (15),                      Call it                      @\n               ((11),                     ..DSA address                @\n               RECAP,                     ..DCB                        @\n               RCP_RLC,                   ..Line count                 @\n               RCP_RPC,                   ..Page count                 @\n               RCP_TITLE),                ..Title                      @\n               MF=(E,PARMLIST)            ..Execute here\nRCP$PEHX EQU   *\n         PUT   RECAP,RCP_REC              Print record\n         TM    FLAG1,$F1_ERROR            Error processing?\n         BNO   RCP$TFPX                   No, continue\n*\n         LR    R1,R11                     Get address of DSA\n         L     R15,=V(IDC$ERR)            -> Locate Error routine\n         BALR  R14,R15                    Execute it\n         B     RCP$TFPX                   Continue\n*\n** Save entry name into RO_NAME\n*\nRCP$SENT EQU   *\n         LA    R1,RO_NAME-RO(R6)          Locate output location\nRCP$SENTT EQU  *\n         LR    R15,R4                     Locate start of record\n         LA    R15,0(R5,R15)              Locate the end\n         LA    R14,IL_MNAML(R4)           Bump to start of name\n         SR    R15,R14                    Length of name = end - beg.\n         MVC   0(0,R1),0(R14)             ** EXECUTED **\n         EX    R15,*-6                    Move Entry to output area\n         B     RCP$X\n*\n** Trap number from \"-----10\"  like dill\n** Input: R14 - Length of \"-----10\"\n**        R15 - Address of \"-----10\" string\n**        R1 - Output full word number\n**\n** Note: This routine does not check for trailing blanks, you must hit\n**       right on!!!\n*\nTRAPNUM  EQU   *\n         CLI   0(R15),C'-'                Dash?\n         BNE   TRAPNUMX                   No, at number!\n         LA    R15,1(R15)                 Yes, Skip it\n         BCT   R14,TRAPNUM                     Repeat for next byte\n         XC    0(4,R1),0(R1)              Invalid number, set to zero\n         BSM   0,R9                       Return to caller\nTRAPNUMX EQU   *\n         BCTR  R14,0                      Decrement for EX\n         PACK  DOUBLE(8),0(0,R15)         ** Executed **\n         EX    R14,*-6                    Convert zoned to packed\n         CVB   R15,DOUBLE                 Convert packed to Binary\n         ST    R15,0(R1)                  Save Number\n         BSM   0,R9                       Return to caller\n*\n**       EDIT FULLWORD (FLUSH TO R15)\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nRCP$EFWF EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    RCP$EF0                    YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),RCPEP15\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         MVC   0(0,R15),0(R1)\n         EX    R14,*-6                    MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER\n         BSM   0,R9                       RETURN TO CALLER\nRCP$EF0  EQU   *\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,2(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n** POINT REGISTER 15 TO FIRST BLANK IN STRING\n** INPUT:  R0  - MAXIMUM LENGTH OF STRING\n**         R15 - STRING\n** OUTPUT: R15 - FIRST SPACE IN STRING\n*\nRCP$FS   EQU   *\n         CLI   0(R15),C' '\n         BE    RCP$FSX\n         LA    R15,1(R15)\n         BCT   R0,RCP$FS\nRCP$FSX  EQU   *\n         BSM   0,R14\n*\n** POINT REGISTER 15 TO FIRST BLANK IN STRING\n** INPUT:  R0  - MAXIMUM LENGTH OF STRING\n**         R15 - STRING\n** OUTPUT: R15 - FIRST SPACE IN STRING\n*\nRCP$FNS  EQU   *\n         CLI   0(R15),C' '\n         BNE   RCP$FNSX\n         LA    R15,1(R15)\n         BCT   R0,RCP$FNS\nRCP$FNSX EQU   *\n         BSM   0,R14\n*\n** RUB OUT LEADING DASH\n** INPUT: R0 LENGTH OF STRING\n**        R15: ADDRESS OF STRING\n*\nRCP$ROD  EQU   *\n         CLI   0(R15),C'-'                DASH?\n         BNE   RCP$RODX                   NO, MOVE ON\n         MVI   0(R15),C' '                YES, STRIP IT\n         LA    R15,1(R15)                 BUMP TO NEXT BYTE\n         BCT   R0,RCP$ROD                 ..AND DO IT TO IT\nRCP$RODX EQU   *\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***\n**       IDC$RCP --- Constants\n***\n***********************************************************************\n           SPACE 2\nRCPEP15    DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nRCP_TITLE  DC    AL1(RCP_TITLEL-2),C'Recap of IDCAMS listing'\nRCP_TITLEL EQU   *-RCP_TITLE\n*\n** Type table\n*\n         PRINT DATA\n         DS    0F\nT_TYPE   EQU   *\nT_TYPEAI DC    AL1(03-1),CL11'AIX        ',AL4(RCP$IAI,RCP$OAI)\nT_TYPEA  DC    AL1(05-1),CL11'ALIAS      ',AL4(RCP$IA,RCP$OA)\nT_TYPEC  DC    AL1(07-1),CL11'CLUSTER    ',AL4(RCP$IC,RCP$OC)\nT_TYPED  DC    AL1(04-1),CL11'DATA       ',AL4(RCP$ID,RCP$OD)\nT_TYPEG  DC    AL1(03-1),CL11'GDG        ',AL4(RCP$IG,RCP$OG)\nT_TYPEI  DC    AL1(05-1),CL11'INDEX      ',AL4(RCP$II,RCP$OI)\nT_TYPENV DC    AL1(07-1),CL11'NONVSAM    ',AL4(RCP$INV,RCP$ONV)\nT_TYPEPS DC    AL1(09-1),CL11'PAGESPACE  ',AL4(RCP$IPS,RCP$OPS)\nT_TYPEP  DC    AL1(04-1),CL11'PATH       ',AL4(RCP$IP,RCP$OP)\nT_TYPES  DC    AL1(05-1),CL11'SPACE      ',AL4(RCP$IS,RCP$OS)\nT_TYPEU  DC    AL1(11-1),CL11'USERCATALOG',AL4(RCP$IU,RCP$OU)\nT_TYPEN  EQU   ((*-T_TYPE)/T_TYPEL)       Number of entries\nT_TYPEL  EQU   1+11+4+4                   Length of constant table ent\nT_TYPER  EQU   T_TYPEN*RTL                Table length\n*\nT_TYPET  DC    AL1(05-1),C'TOTAL'\n         PRINT NODATA\n*\n** IDC$RCP Literals\n*\n         LTORG ,\n         DS    0D\n         EJECT\n***********************************************************************\n***\n**       Print Report (RECAP or ERROR) Record\n***\n***********************************************************************\n         SPACE 2\n         DROP  R11,R12\nIDC$PRR  DA#ENTER 'PRINT REPORT RECORD',RENT=NO\n         LM    R2,R6,0(R1)\n         USING DSA,R2\n*\n** R2 = DSA area\n** R3 = DCB\n** R4 = Line count byte\n** R5 = Page count fullword\n** R6 = Title String\n*\n         EJECT ,\n*\n** Do we need a heading line\n*\n         SLR   R1,R1                      CLEAR REGISTER\n         IC    R1,0(R4)                   GET LINE COUNT\n         CH    R1,=H'56'                  MAX ON PAGE YET?\n         BL    PRR$TX                     NO, LEAVE\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Print title / heading lines\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Initialize record area\n*\n         LA    R15,PRR_REC                Locate record\n         MVI   0(R15),C' '                Clear it\n         MVC   1(L'PRR_REC-1,R15),0(R15) ..Propagate it\n         MVI   0(R15),C'1'                Set FBA byte for Top-Of-Page\n         LA    R15,1(R15)                 Bump past FBA byte\n*\n** Get program name from DA#ENTER macro eyecatcher\n*\n         L     R1,EP_DA$IDC               Locate DA$IDC EPA\n         MVC   0(8,R15),DA$IDC_ECNAME-DA$IDC(R1)\n         LA    R15,8+1(R15)               Bump past it\n*\n** Print this file's title string\n*\n         MVI   0(R15),C'-'\n         LA    R15,2(R15)\n         SLR   R1,R1\n         IC    R1,0(R6)\n         MVC   0(0,R15),1(R6)\n         EX    R1,*-6\n         LA    R15,2(R1,R15)\n         MVI   0(R15),C'-'                Insert Delimiter\n         LA    R15,2(R15)                 Bump past it\n*\n** Get time and date\n*\n         SLR   R1,R1\n         IC    R1,PRR_ODISO10_STRL\n         BCTR  R1,0\n         MVC   0(0,R15),PRR_ODISO10_STR\n         EX    R1,*-6\n         LA    R15,2(R1,R15)\n         MVI   0(R15),C'-'\n         LA    R15,2(R15)\n*\n         SLR   R1,R1\n         IC    R1,PRR_OTIMES11_STRL\n         BCTR  R1,0\n         MVC   0(0,R15),PRR_OTIMES11_STR\n         EX    R1,*-6\n         LA    R15,2(R1,R15)\n*\n** Page number\n*\n         MVC   0(6,R15),=C'- Page'\n         LA    R15,7(R15)\n*\n         L     R1,0(R5)                   GET PAGE COUNT\n         LA    R1,1(R1)                   INCREMENT PAGE COUNT\n         ST    R1,0(R5)                   SAVE PAGE COUNT\n         BAS   R9,PRR_EDITFWF\n         MVI   0(R15),C' '\n*\n** Print title line\n*\n         PUT   (3),PRR_REC\n*\n** Print heading lines\n*\n         LA    R15,PRR_REC                LOCATE RECORD\n         MVI   0(R15),C' '                Clear it\n         MVC   1(L'PRR_REC-1,R15),0(R15)  ..Propagate it\n         MVI   PRR_REC,C'0'               SKIP A COUPLE OF LINES\n         CLI   1(R6),C'R'\n         BE    PRR$TH1R\n         MVC   RO_NAME-RO(19,R15),=C'E n t r y   N a m e'\n         MVC   RO_TYPE-RO(20,R15),=C'Description of Error'\n         B     PRR$TH1P\nPRR$TH1R EQU   *\n         MVC   RO_NAME-RO(19,R15),=C'E n t r y   N a m e'\n         MVC   RO_TYPE-RO(10,R15),=C'Entry type'\n         MVC   RO_DEVT-RO(11,R15),=C'Device type'\n         MVC   RO_VOLS-RO(13,R15),=C'Volume Serial'\n         MVC   RO_CAT-RO(7,R15),=C'Catalog'\nPRR$TH1P EQU   *\n         PUT   (3),PRR_REC\n*\n         LA    R15,PRR_REC                LOCATE RECORD\n         MVI   0(R15),C'-'                Clear it\n         MVC   1(L'PRR_REC-1,R15),0(R15)  ..Propagate it\n         MVI   0(R15),C' '                Clear it\n         PUT   (3),PRR_REC\n*\n         SLR   R1,R1                      CLEAR LINE COUNT\nPRR$TX   EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Termination - return to caller\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LA    R1,1(R1)                   Increment line count\n         STC   R1,0(R4)                   Save line count\n         DA#LEAVE RENT=NO                 Return to caller\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       IDC$PRR - Misc internal Subroutines\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n**       EDIT FULLWORD (FLUSH TO R15)\n**       R1 --> INPUT:REGISTER TO PRINT\n**       R15 --> OUTPUT: ADDRESS WHERE OUTPUT IS TO BE PUT\n*\nPRR_EDITFWF EQU *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    PRR_EDITFWF0               YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),PRR_EDITP15\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         MVC   0(0,R15),0(R1)\n         EX    R14,*-6                    MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,1(R14,R15)             BUMP POINTER PAST NUMBER\n         BSM   0,R9                       RETURN TO CALLER\nPRR_EDITFWF0 EQU *\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       IDC$PRR - Constants\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPRR_EDITP15  DC X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\n*\n** Literals\n*\n         LTORG ,                          Literal used in IDC$PRR\n         DS    0D\n         DROP  R2,R12                     DSA=R2  IDC$PRR=R12\n         EJECT\n***********************************************************************\n***\n**       Error processing\n***\n***********************************************************************\n         SPACE 2\nIDC$ERR  DA#ENTER 'ERROR PROCESSING'\n         LR    R11,R1                     Get address of DSA\n         USING DSA,R11                    Addressibility\n         LA    R10,RCP_REC                Locate input record\n*\n** Process based on input type\n*\n         CLC   RO_TYPE-RO(5,R10),=C'NONVSAM'\n         BE    ERR$NV\n*\n** Common exit from IDC$ERR\n*\nERR$X    EQU   *\n         DA#LEAVE ,\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**   Process the dataset\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nERR$NV   EQU   *\n*\n** Ensure DASD device\n*\n         CLI   RO_VOLS-RO(R10),C'0'       Tape volume?\n         BL    ERR$NVD                    Yes, leave\n         B     ERR$X                      Do checking\n*\n** Obtain F1DSCB\n*\nERR$NVD  EQU   *                          DASD/DSCB checking\n*\n         MVC   PARMLIST(VTOCLOCL),VTOCLOC Initialize VTOC CAMLST area\n         LA    R1,RO_NAME-RO(R10)\n         ST    R1,PARMLIST+4\n*\n         LA    R1,RO_VOLS-RO(R10)         Default: Volume from IDCAMS\n         CLC   0(6,R1),=C'MIGRAT'         HSM got this one?\n         BNE   ERR$NVDOX                  No, continue\n*\n         CLC   0(6,R1),=C'******'         SYSRES indirect?\n         BNE   ERR$NVDVX                  No, continue\n         L     R1,CVTPTR                  -> CVT\n         L     R1,CVTSYSAD-CVTMAP(,R1)    -> System Res UCB\n         LA    R1,UCBVOLI-UCBOB(R1)       Locate IPL volume\nERR$NVDVX EQU *\n         ST    R1,PARMLIST+8              Save Volume location\n*\n         LA    R1,ERR_F1DSCB              Locate DSCB\n         ST    R1,PARMLIST+12             Save it\n         OBTAIN PARMLIST                  Locate F1-DSCB for dataset\n         LTR   R15,R15                    Found?\n         BZ    ERR$NVDOX                  Yes, do some checking\n*\n         BAS   R14,ERR$CREC               Clear record\n         MVC   0(13,R15),=C'Catalogued to'\n         LA    R15,14(R15)\n         MVC   0(6,R15),RO_VOLS-RO(R10)\n         LA    R15,7(R15)\n         MVC   0(25,R15),=C'but does not reside there'\n         BAS   R9,ERR$PREC\n         B     ERR$NVDX\nERR$NVDOX EQU  *\n         LA    R2,ERR_F1DSCB              Locate F1DSCB\n*\n** Check for Secondary extents in a RECFM=U PDS\n*\n         TM    DS1RECFM-DS1FMTID(R2),DS1RECFU  RECFM=U\n         BNO   ERR$NVDDUX                 No, continue\n*\n         CLC   DS1SCAL3-DS1FMTID(3,R2),=X'00,00,00'\n         BE    ERR$NVDDUX\n         BAS   R14,ERR$CREC               Clear record\n         MVC   0(ERR_W1L,R15),ERR_W1      Get message\n         BAS   R9,ERR$PREC                Clear record\nERR$NVDDUX EQU *\n*\n** Check for Expiration date\n*\n         CLC   DS1EXPDT-DS1FMTID(3,R2),=X'00,00,00'\n         BE    ERR$NVDDEX\n         BAS   R14,ERR$CREC               Clear record\n         MVC   0(ERR_W2L,R15),ERR_W2      Get message\n         BAS   R9,ERR$PREC                Clear record\nERR$NVDDEX EQU *\nERR$NVDX EQU   *                          End of DSCB checking\n         B     ERR$X\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Misc internal subroutines\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Clear record area and set R15 to start of description\n*\nERR$CREC EQU   *\n         LA    R15,ERR_REC\n         MVI   0(R15),C' '\n         MVC   1(L'ERR_REC-1,R15),0(R15)\n         MVC   ERR_REC+1(44),RO_NAME-RO(R10)\n         LA    R15,1+RO_ERRS-RO(R15)\n         BSM   0,R14\n*\n** Print record\n*\nERR$PREC EQU   *\n         TM    FLAG1,$F1_DATAO            Headings wanted?\n         BO    ERR$PRHX                   No, skip heading stuff\n         L     R15,=V(IDC$PRR)            Locate print routine\n         CALL  (15),                      Call it                      @\n               ((11),                     ..DSA address                @\n               ERROR,                     ..DCB                        @\n               ERR_RLC,                   ..Line count                 @\n               ERR_RPC,                   ..Page count                 @\n               ERR_TITLE),                ..Title                      @\n               MF=(E,PARMLIST)            ..Execute here\nERR$PRHX EQU   *\n         PUT   ERROR,ERR_REC\n         BSM   0,R9\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**    Data areas for IDC$ERR\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nVTOCLOC  CAMLST SEARCH,*-*,*-*,*-*\nVTOCLOCL EQU   *-VTOCLOC\n*\nERR_TITLE DC   AL1(ERR_TITLEL-2),C'Error report'\nERR_TITLEL EQU *-ERR_TITLE\n*\nERR_W1   DC    C'Load library allocated with secondary extents'\nERR_W1L  EQU   *-ERR_W1\nERR_W2   DC    C'Expiration date for disk data set'\nERR_W2L  EQU   *-ERR_W2\n*\n** Literals\n*\n         LTORG ,\n         DS    0D\n         EJECT\n***********************************************************************\n***\n**       Getmained Work area - Shared between all CSECTs/Programs\n***\n***********************************************************************\n              SPACE 2\nDSA           DSECT ,\nWORKRSA       DS    18F                   Register Save Area\nPARMLIST      DS    20F                   Parameter List for calls\nDOUBLE2       DS    2D                    Double word work area * 2\nDOUBLE        DS    2D                    Double word work area\n*                                         Entry point\nEP_DA$DATE    DS    F                     ..DA#DATE\nEP_IEFEB4UV   DS    F                     ..IEFEB4UV\nEP_DA$IDC     DS    F                     ..DA$IDC\nEP_DA$MXD     DS    F                     ..DA$IDC\n*                                         Right_Justify\nRJ_RA         DS    F                     ..Return address\n              DS    0F                    IDCAMS\nIDC_PARM      DS    F                     ..R1 ON ENTRY (JCL PARM)\nIDC_IOL       EQU   *                     ..I/O LIST\nIDC_ION       DS    F'1'                  ..NUMBER OF FW FOLLOWING\nIDC_IODD      DS    F                     ..DDNAME STRING\nIDC_IOR       DS    F                     ..ROUTINE\nIDC_IOUD      DS    F                     ..ROUTINE\nIDC_P         EQU   *                     ..PAGE NUMBER\nIDC_PL        DS    AL2(L'IDC_PNUM)       ..LENGTH\nIDC_PNUM      DS    CL3'100'              ..NUMBER\n*\n** Input/Output Record areas\n*\n              DS    0H\nRECOUTV       DS    XL4                   Variable record RDW\nRECOUT        DS    CL133                 Data area\nRECOUTVL      EQU   *-RECOUTV\nRECOUTS       DS    XL(RECOUTVL)          Save record\n*\n** Debug work areas\n*\n              DS    0F\n$$DEBUGW      DS    XL(CMXDL)             DA#MXD work area\n$$DEBUG       DS    XL(DCBLNGQS)          DCB area\n$$DEBUGR      DS    CL133                 Output record area\n*\n** Date routine work areas\n*\n              DS    0F\nW_ODDOWA      DA#DATE DPE,OPREFIX=W_ODDOWA,                            @\n               OSTR=YES,OFLAG=$DA#DATE_ADDR,OSTRL=4\nW_ODISOA      DA#DATE DPE,OPREFIX=W_ODISOA,                            @\n               OSTR=YES,OFLAG=$DA#DATE_ADDR,OSTRL=4\nW_OTIMESA     DA#DATE DPE,OPREFIX=W_OTIMESA,                           @\n               OSTR=YES,OFLAG=$DA#DATE_ADDR,OSTRL=4\nW_IDJULC8     DA#DATE DPE,OPREFIX=W_IDJULC8,OSTR=YES,                  @\n               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC\nW_ISTMPC16    DA#DATE DPE,OPREFIX=W_ISTMPC16,OSTR=YES,                 @\n               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC\n*\n** Print Routine\n*\nPRR_ODISO10   DA#DATE DPE,OPREFIX=PRR_ODISO10,OSTR=YES,                @\n               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO\nPRR_OTIMES11  DA#DATE DPE,OPREFIX=PRR_OTIMES11,OSTR=YES,               @\n               OSTRL=$DA#DATE_OTIMES11,OTYPE=$DA#DATE_OTIMES\nPRR_REC       DS    CL133                 Output record\n              DS    0F                    Recap area\nRCP_OVSC      DS    F                     ..Output Volser - Current\nRCP_OVSE      DS    F                     ..Output Volser - Last\nRCP_TBL       DS    XL(T_TYPER)           ..Table for routines\nRCP_TBLT      DS    XL(RTL)               ..Total entry\nRCP_TBLC      DS    F                     ..Current entry\nRCP_TBLN      DS    F                     ..Next entry (temp)\nRCP_WA        DS    XL256                 ..Work area\nRCP_REC       DS    CL133                 ..Output record\nRCP_RPC       DS    F                     ..Page count\nRCP_RLC       DS    X                     ..Line count\n              DS    0F                    Error\nERR_RPC       DS    F                     ..Page count\nERR_RLC       DS    X                     ..Line count\nERR_REC       DS    CL133                 ..output record\nERR_F1DSCB    DS    CL140                 .. F1DSCB w/DSNAME\n              DS    0F                    I/O routine\nIOR_JFCBX     DS    F                     ..JFCB EXLST\nIOR_JFCB      DS    CL176                 ..JFCB area\n              DS    0F\nHT_SAVEREGS   DS    4F                    Save regs for HEXTRAN\nDT_VALUE      DS    CL8'78048083'         Device Type hex string\nDT_FILESEQ    DS    CL4'---1'             File sequence\n*\nSYSPRINT      DS    XL(DCBLNGQS)          DCB area\nRECAP         DS    XL(DCBLNGQS)          DCB area\nERROR         DS    XL(DCBLNGQS)          DCB area\n*\n** Flags\n*\nFLAG_LIT     DS    C'FLAG'                Literal for dumps\nFLAG1        DS    B'00000000'            Execution flag 1\n$F1_RECAP    EQU   B'10000000'            ..RECAP report?\n$F1_ERROR    EQU   B'01000000'            ..Error report?\n$F1_DATAO    EQU   B'00100000'            ..No heading?\n$F1_DEBUG    EQU   B'00010000'            ..Debugging mode?\n$F1_HEADING  EQU   B'00001000'            ..Printed first IDCAMS head?\n$F1_LDA#DATE EQU   B'00000100'            ..Loaded DA#DATE?\n$F1_LDA#MXD  EQU   B'00000010'            ..Loaded DA#MXD?\nFLAGP1       DS    B'00000000'            IOR (processing) flag 1\n$FP1_MOD     EQU   B'10000000'            ..Modified record?\n$FP1_ADD     EQU   B'01000000'            ..Added record?\n$FP1_DEL     EQU   B'00100000'            ..Delete record?\n             DS    0D                     Alignment for FREEMAIN\nDSAL         EQU   *-DSA                  Length of DSECT area\n         EJECT\n***********************************************************************\n***\n**       Internal DSECTs\n***\n***********************************************************************\n         SPACE 2\n*\n** IDC$IOR --- IDCAMS I/O FLAG MAP\n*\nIOF      DSECT ,                          I/O FLAGS\nIOF_B1   DS    X                          ..BYTE 1\n$IOF_O   EQU   X'00'                        ..OPEN\n$IOF_C   EQU   X'04'                        ..CLOSE\n$IOF_G   EQU   X'08'                        ..GET\n$IOF_P   EQU   X'0C'                        ..PUT\nIOF_B2   DS    X                          ..BYTE 2\n$IOF_OI  EQU   B'10000000'                  ..OPEN FOR INPUT\n$IOF_OO  EQU   B'01000000'                  ..OPEN FOR OUTPUT\n$IOF_OFI EQU   B'00100000'                  ..INFO HAS ADDR(DDNAME)\n$IOF_OFO EQU   B'00010000'                  ..INFO HAS ADDR(DSN)\nIOF_B3   DS    X                          ..BYTE 2\nIOF_B4   DS    X                          ..BYTE 2\n*\n** IDC$RCP --- RECAP TYPE TABLE MAP\n*\nRT       DSECT ,                          Routine table\nRT_TYPEL DS    X                          ..Type length\nRT_TYPE  DS    CL11                       ..Type literal\nRT_IROUT DS    A                          ..Input Routine\nRT_OROUT DS    A                          ..Output routine\nRT_OFF   DS    X                          ..Offset in print record\nRT_CNT   DS    XL3                        ..Count\nRTL      EQU   *-RT                       Length of entry\n*\n** IDC$RCP --- RECAP REPORT DETAIL LINE MAP\n*\nRO       DSECT\n         DS    CL1\nRO_NAME  DS    CL44\n         DS    CL1\nRO_ERRS  EQU   *\nRO_TYPE  DS    CL11\n         DS    CL2\nRO_DEVT  DS    CL11\n         DS    CL2\nRO_VOLS  DS    CL61\nRO_CAT   EQU   RO_VOLS+15\nRO_ERRL  EQU   *-RO_ERRS\n         EJECT\n***********************************************************************\n***\n**       IDCAMS LISTING DSECTS\n***\n***********************************************************************\n         SPACE 2\nIL       DSECT ,\n*\n** MISC FIELDS (COMMON TO MULIPLE TYPES)\n*\nIL_MVS   DS    C'0       VOLSER------------'\nIL_MVSL  EQU   *-IL_MVS\nIL_MDT   DS    C'0       DEVTYPE------'\nIL_MDTL  EQU   *-IL_MDT\nIL_MFBA  DS    C'0'                       FBA BYTE\nIL_MFBAL EQU   *-IL_MFBA\nIL_MNAM  DS    C'0       XXXXXX---'\nIL_MNAML EQU   *-IL_MNAM\nIL_MOPT  DS    C'0       '\nIL_MOPTL EQU   *-IL_MOPT\n*\n** GDG SPECIFIC\n*\nIL_GN    DS    C'0   '\nIL_GNL   EQU   *-IL_GN\nIL_GLMT  DS    C'0'\n         DS    CL7' '\n         DS    C'LIMIT----------------'\nIL_GLMTL EQU   *-IL_GLMT\n         DS    C'123'\n         DS    C'     '\nIL_GATTR1L EQU *-IL_GLMT\n         DS    CL10'SCRATCH'\n         DS    CL4' '\nIL_GATTR2L EQU *-IL_GLMT\n         DS    CL10'   NOEMPTY'\n*\n** NON-VSAM SPECIFIC\n*\nIL_D     DS    C'0       '\n         DS    C'VOLSER------------'\nIL_DVS   EQU   *-IL_D\n         DS    C'123456'\n         DS    C'     '\n         DS    C'DEVTYPE------'\nIL_DDT   EQU   *-IL_D\n         DS    C'X\"12345678\"'\n         DS    C'     '\n         DS    C'FSEQN---------------'\nIL_DFS   EQU   *-IL_D\n         DS    C'1234'\n         END\n         EJECT\n***********************************************************************\n***\n**        Linkage editor cards - ASM.PARM='BATCH,...'\n***\n***********************************************************************\n         SPACE 2\n PUNCH ' ENTRY   DA$IDC'                  Entry point\n PUNCH ' SETCODE AC(1)'                   APF Authorization\n PUNCH ' INCLUDE SYSLMOD(DA$DATE)'        Subroutine: Date routine\n PUNCH ' INCLUDE SYSLMOD(DA$MXD)'         Subroutine: Mini-Hex-Dump\n PUNCH ' NAME    DA$IDC(R)'               Name of load module\n         END ,\n./ ADD NAME=DA$MXD   0100-01266-01266-1821-00507-00507-00000-DAVE\nDA$MXD   TITLE 'Mini-Hex-Dump routine'\n***********************************************************************\n***\n** Name: DA$MXD - External subroutine\n**\n*  Author = David Alcock :: dave@planetmvs.com\n**\n** Date: 02-MAR-1985\n**\n** Purpose: Produce a mini Hex dump one line at time, varying output\n**          length based on input.\n**\n** Attributes: Reentrant, Reusable, Runs above the line\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n** Non-IBM assembler MACROs:\n** o DA#ENTER...Entry housekeeping\n** o DA#LEAVE...Termination housekeeping\n** o DA#EYEC....Build standard O/S module eyecatcher\n**              (invoked by the DA#ENTER)\n** o DA#REGS....Define registers (invoked by DA#ENTER)\n** o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine\n**\n** Input: CMXD DSECT (Expanded with DA#MXD MACRO). The minuimum\n**        input is CMXD_ADDRESS CMXD_LENGTH and CMXD_OUTPUT with\n**        the assumption of 80 byte output. Callers executing in\n**        24 bit mode should invoke via BASSM.\n***\n***********************************************************************\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*  Sample program to invoke DA$MXD\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*TESTIT   DA#ENTER 'SAMPLE DA$MXD INVOCATION'\n*         XC    WORKA(CMXDL),WORKA\n*         MVC   WORKA+CMXD_ADDRESS-CMXD(12),=A(DATA,DATAL,OUTPUT)\n**-> OPT: MVC   WORKA+CMXD_OUTPUTL-CMXD(2),=AL2(132)\n*LOOP     EQU   *\n*         LA    R1,WORKA                   LOCATE WORK AREA\n*         LINK  EP=DA$MXD                  CALL DA$MXD\n*         LR    R2,R15                     SAVE RETURN CODE\n*         TPUT  OUTPUT,L'OUTPUT            PRINT HEX DUMP LINE\n*         LTR   R2,R2                      CHECK RETURN CODE\n*         BNZ   LOOP                       NEED ANOTHER LINE\n*         DA#LEAVE RC=0                    LEAVE\n*WORKA    DS    XL(CMXDL)                  WORK AREA\n*DATA     DC    X'00,00,00,00,11,11,11,11,22,22,22,22,33,33,33,33'\n*         DC    C'0123456789ABCDEF'\n*         DC    C'DDDDAAAAVVVVEEEE'\n*         DC    C'LASTONE'\n*DATAL    EQU   *-DATA\n*OUTPUT   DC    CL132' '\n*         LTORG ,                            LITERALS\n*         DA#MXD ,                           MAP DSECT\n*         END   ,\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         EJECT ,\n&DAVER   SETC  '1.4'\n         SPACE 2\n***********************************************************************\n***\n**           M o d i f i c a t i o n   H i s t o r y\n**\n** Person     Date        Ver Description\n** ---------- ----------- --- ---------------------------------------\n** D Alcock   2000-01-04  1.4 Added version\n** D Alcock   28-APR-1997 1.3 Converted CMXD_OFFSET to fullword;\n** D Alcock   13-NOV-1996 1.2 Renamed to DA$MXD;\n** D Alcock   11-MAR-1991 1.1 Added CAPs support for character dumps;\n** D Alcock   02-MAR-1985 1.0 Initial program written\n***\n***********************************************************************\n         EJECT ,\nDA$MXD   DA#ENTER 'V&DAVER Subroutine: Mini-Hex-Dump',                 @\n               RSA=(R1),                Work area in R1                @\n               AMODE=31,RMODE=ANY       Any where in V/S\n         USING CMXD,R13                 Get addressability to DSA\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**              Master control                                       **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nMINI_HEX_DUMP EQU *\n LM    R4,R5,CMXD_ADDRESS                 Get address and length\n*\n** Next line?\n*\n TM    W_FLAG1,$W_F1NEXT                  Next line?\n BNO   MXD$FIRST                          No, first time thru\n LM    R5,R7,W_REGS                       Get registers\n B     MXD$START\n*\n** First time initialization and calculations\n*\nMXD$FIRST EQU *\n MVC   CMXD_LIT(4),=C'CMXD'               Set literal for dumps\n*\n ICM   R0,B'1111',CMXD_TRTAB              User specified trans table?\n BNZ   MXD$FTX                            Yes, continue\n TM    CMXD_FLAG1,$CMXD_F1CAPS            Only caps?\n BNO   MXD$FTL                            No, continue\n LA    R1,TRANTABU                        Table with no lower case\n B     MXD$FTLX                           Continue\nMXD$FTL EQU *\n LA    R1,TRANTAB                         Get address of default table\nMXD$FTLX EQU *\n ST    R1,CMXD_TRTAB                      Save it for later\nMXD$FTX EQU *\n*\n CLC   CMXD_OUTPUTL(2),ZEROS              Output length there?\n BNE   MXD$FOLX                           Yes, continue\n MVI   CMXD_OUTPUTL+1,80                  Default to 80\n MVC   W_CHARL(2),TO_DEF+TO_CHARL-TO      Set default length (16)\n B     MXD$OX                             Leave\nMXD$FOLX EQU *\n LA    R0,T_OUTN                          Get number in table\n LA    R1,T_OUT                           Get address in table\n LH    R14,CMXD_OUTPUTL                   Get output length\n TM    CMXD_FLAG1,$CMXD_F1ADDR            Address?\n BNO   MXD$OL                             No, continue\n SH    R14,=H'9'                          Subtract length\nMXD$OL EQU *\n CLM   R14,B'0011',TO_MAXLEN-TO(R1)       Maximum length?\n BH    MXD$OLX                            Fits, use it\n LA    R1,TOL(R1)                         Bump to next one\n BCT   R0,MXD$OL                          Continue\n L     R15,CMXD_OUTPUT                    -> output area\n MVC   0(32,R15),=C'DA$MXD: ERROR IN CMXD_OUTPUTL'\n SLR   R15,R15                            Indicate no more coming\n B     EXIT                               Leave\nMXD$OLX EQU *\n MVC   W_CHARL(2),TO_CHARL-TO(R1)         Set to new character length\nMXD$OX EQU *\n*\n SLR   R6,R6                              Clear register\n LR    R7,R5                              Get total length\n LH    R15,W_CHARL                        Number of bytes to process\n DR    R6,R15                             Calculate the number of lines\n*\n** Start of hex dump activity\n**\n** R6 - Number of bytes on last line\n** R7 - Number of full lines\n*\nMXD$START EQU *\n LTR   R7,R7                              Any full lines?\n BZ    SHORT_LINE                         No, move on\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**              Print complete lines                                 **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nFULL_LINE_LOOP EQU *\n BAS   R14,INITIALIZE_LINE                Initialize the line\n*\n** Format hex area (4 fullwords)\n*\n LH    R0,W_CHARL                         Get length to process\n SRL   R0,2                               Divide by 4 to get # of FWs\n LR    R1,R4                              Locate input bytes\n BAS   R14,FORMAT_HEX_FULLWORDS           Full_Word_Line_Dump\n*\n** Translate character portion\n*\n LH    R14,W_CHARL                        Get number of bytes\n BAS   R9,TRANSLATE_CHARACTERS\n*\n** Bump to next area\n*\nFLL$B EQU *\n AH    R4,W_CHARL                         Bump past to next 16 bytes\n SH    R5,W_CHARL                         Decrement total length\n*\n L     R1,CMXD_ADDRESS                    Get current address\n AH    R1,W_CHARL                         Add for length just done\n ST    R1,CMXD_ADDRESS                    New address for next time\n*\n L     R1,CMXD_OFFSET                     Get current offset\n AH    R1,W_CHARL                         Add for length just done\n ST    R1,CMXD_OFFSET                     Save for next time thru\n*\n BCT   R7,FLL$NEXT                        Do next one\n*\n** End of full line loops, if no more signal it\n*\n LTR   R5,R5                              Any more work to do?\n BNZ   FLL$NEXT                           Yes, print remaining bytes\n SLR   R15,R15\n B     EXIT                               Leave\n*\n** Perform next line\n*\nFLL$NEXT EQU *\n OI    W_FLAG1,$W_F1NEXT                  Next line mode\n STM   R5,R7,W_REGS                       Get registers\n LA    R15,4                              Set MORE return code\n B     EXIT\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**        Print hex dump lines which are less than a full one        **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nSHORT_LINE EQU *\n BAS   R14,INITIALIZE_LINE                Initialize hex line\n*\n** Format line\n*\n ST    R15,DOUBLE\n LH    R1,W_CHARL                         Get character length\n SRL   R1,2                               Divide by 4 for number of FWs\n MH    R1,=H'9'                           Get length of hex area\n AR    R15,R1                             Bump past hex area\n LR    R14,R5                             Get number of characters\n BAS   R9,TRANSLATE_CHARACTERS            Translate characters\n L     R15,DOUBLE\n*\n** Calculate number of fullwords to print - into R7\n*\n SLR   R6,R6                              Clear register\n LR    R7,R5                              Get total bytes left\n LA    R14,4                              Number of full words\n DR    R6,R14                             Calculate the number of lines\n*\n** Format the fullwords\n*\n LTR   R7,R7                              Full words to do?\n BZ    SL$RBL                             No, less than 4 bytes left\n LR    R1,R4                              Locate input\n LR    R0,R7                              Get number of fullwords\n BAS   R14,FORMAT_HEX_FULLWORDS           Full_Word_Line_Dump\n*\n MH    R7,=H'4'                           Calculate Total FW byte count\n LA    R4,0(R7,R4)                        Bump past what we just did\n SR    R5,R7                              Decrement the total count\n*\n** Format leftover bytes (less than 4)\n**\n** R5 - total length left  should be less than 4\n** R4 - Address of remaining bytes\n*\n LTR   R5,R5                              Any more to do?\n BZ    SL$PLL                             None, leave\nSL$RBL EQU *\n UNPK  0(3,R15),0(2,R4)                   **\n MVZ   0(2,R15),ZEROS                     *** Hex convert\n TR    0(2,R15),HEXSTR                    **\n LA    R4,1(R4)                           Bump past input byte\n LA    R15,2(R15)                         Bump past output byte\n BCT   R5,SL$RBL                          ..repeat\n MVI   0(R15),C' '                        Fix byte\nSL$PLL EQU *\n*\n** Common exit\n*\nSL$X EQU *\n SLR   R15,R15                            Last line...\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Common exit                                                 **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nEXIT EQU *\n DA#LEAVE RC=(15)                        Return to caller\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**            Initialize output line                                 **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nINITIALIZE_LINE EQU *\n L     R15,CMXD_OUTPUT                    Locate CHAR start location\n*\n TM    CMXD_FLAG1,$CMXD_F1ADDR            Address wanted?\n BNO   IL$ADDRX                           No, continue\n UNPK  0(9,R15),CMXD_ADDRESS(5)           **\n MVZ   0(8,R15),ZEROS                     *** Hex convert\n TR    0(8,R15),HEXSTR                    **\n MVI   8(R15),C' '                        Fix corrupted byte\n LA    R15,9(R15)                         Bump past address\nIL$ADDRX EQU *\n*\n TM    CMXD_FLAG1,$CMXD_F1MOFF            Want max offset?\n BO    IL$MAX                             Yes, continue\n CLC   CMXD_LENGTH(4),=AL4(256)\n BNH   IL$O256\n CLC   CMXD_LENGTH(4),=AL4(32768)\n BNH   IL$OHW\n*\nIL$MAX DS 0H\n MVI   0(R15),C'+'                        Indicate we are an offset\n UNPK  1(9,R15),CMXD_OFFSET(5)            **\n MVZ   1(8,R15),ZEROS                     *** Hex convert\n TR    1(8,R15),HEXSTR                    **\n MVI   1+8(R15),C' '                      Fix corrupted byte\n LA    R15,8+2(R15)                       Past \"+0000\"\n B     IL$OX\n*\nIL$O256 DS 0H\n MVI   0(R15),C'+'                        Indicate we are an offset\n UNPK  1(3,R15),CMXD_OFFSET+3(2)          **\n MVZ   1(2,R15),ZEROS                     *** Hex convert\n TR    1(2,R15),HEXSTR                    **\n MVI   1+2(R15),C' '                      Fix corrupted byte\n LA    R15,2+2(R15)                       Past \"+00\"\n B     IL$OX\n*\nIL$OHW DS 0H\n MVI   0(R15),C'+'                        Indicate we are an offset\n UNPK  1(5,R15),CMXD_OFFSET+2(3)          **\n MVZ   1(4,R15),ZEROS                     *** Hex convert\n TR    1(4,R15),HEXSTR                    **\n MVI   1+4(R15),C' '                      Fix corrupted byte\n LA    R15,4+2(R15)                       Past \"+0000\"\nIL$OX  DS 0H\n*\n LH    R1,W_CHARL                         Get character length\n SRL   R1,2                               Divide by 4 for number of FWs\n MH    R1,=H'9'                           Get length of hex area\n AH    R1,=H'2'                           Add for \"*\" characters\n AH    R1,W_CHARL                         Add in characters\n MVI   0(R15),C' '                        Get blank\n EX    R1,IL$CLEAR                        Set output area to blanks\n*\n BSM   0,R14                              Return\nIL$CLEAR MVC   1(0,R15),0(R15)            Propagate blanks\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**                 Full Word Line Dump                               **\n**                                                                   **\n**         Input: R0 - Number of Fullwords                           **\n**                R1 - Address of Fullwords (input)                  **\n**                R15 - Address to put output                        **\n**                                                                   **\n**    Note: The extra \"MVC\" before the \"UNPK\" has to be done or a    **\n**          S0C4 can occur if the area to be dumped is at the        **\n**          last 4 bytes. (It ** only misses by 1 byte)              **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nFORMAT_HEX_FULLWORDS EQU *\n MVC   DOUBLE(4),0(R1)                    Move full word to be dumped\n UNPK  0(9,R15),DOUBLE(5)                 **\n MVZ   0(8,R15),ZEROS                     *** Hex convert\n TR    0(8,R15),HEXSTR                    **\n MVI   8(R15),C' '                        Fix that last byte\n LA    R15,9(R15)                         Bump past this hex string\n LA    R1,4(R1)                           Bump to next full word\n BCT   R0,FORMAT_HEX_FULLWORDS            Repeat as necessary\n BSM   0,R14                              Return\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**               Translate character portion                         **\n**                                                                   **\n**  Input: R14 - Length                                              **\n**         R15 - Output location on line                             **\n**         R4  - Address of character                                **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nTRANSLATE_CHARACTERS EQU *\n MVI   0(R15),C'*'                        Insert our delimiter\n BCTR  R14,0                              Decrement by 1 for EX\n EX    R14,TC$MOVEC                       Move in the characters\n L     R1,CMXD_TRTAB                      -> Translate table\n EX    R14,TC$TRAN                        Translate the characters\n AH    R15,W_CHARL                        Bump past characters\n MVI   1(R15),C'*'                        Insert ending\n BSM   0,R9\n*\nTC$TRAN  TR    1(0,R15),0(R1)\nTC$MOVEC MVC   1(0,R15),0(R4)\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**              Error routines                                       **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nE$ EQU *\n SLR   R15,R15\n B     EXIT\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**                     C o n s t a n t s                             **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n*\n** Constants\n*\nZEROS    DC    8X'00'                  Zeros\nHEXSTR   DC    C'0123456789ABCDEF'     Hex convert table\n*\n** Character translate table (with lower case)\n*\nTRANTAB  DC    256C'.'\n         ORG   TRANTAB+C' '\n         DC    C' '\n         ORG   TRANTAB+C'$'\n         DC    C'$'\n         ORG   TRANTAB+C'#'\n         DC    C'#'\n         ORG   TRANTAB+C'@'\n         DC    C'@'\n*\n         ORG   TRANTAB+C'a'\n         DC    C'abcdefghi'\n         ORG   TRANTAB+C'j'\n         DC    C'jklmnopqr'\n         ORG   TRANTAB+C's'\n         DC    C'stuvwxyz'\n*\n         ORG   TRANTAB+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   TRANTAB+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   TRANTAB+C'S'\n         DC    C'STUVWXYZ'\n*\n         ORG   TRANTAB+C'0'\n         DC    C'0123456789'\n         ORG   ,\n*\n** Character translate table (with no lower case)\n*\nTRANTABU DC    256C'.'\n         ORG   TRANTABU+C' '\n         DC    C' '\n         ORG   TRANTABU+C'$'\n         DC    C'$'\n         ORG   TRANTABU+C'#'\n         DC    C'#'\n         ORG   TRANTABU+C'@'\n         DC    C'@'\n*\n         ORG   TRANTABU+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   TRANTABU+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   TRANTABU+C'S'\n         DC    C'STUVWXYZ'\n*\n         ORG   TRANTABU+C'0'\n         DC    C'0123456789'\n         ORG   ,\n*\n** Output table\n*\nT_OUT    EQU   *\n         DC    AL2(32,#TO32)        120\nTO_DEF   DC    AL2(16,#TO16)         80\n         DC    AL2(8,#TO8)           40\nT_OUTN   EQU   (*-T_OUT)/TOL\n*\n#TO8     EQU   ((8/4)*9)+8+2\n#TO16    EQU   ((16/4)*9)+16+2\n#TO32    EQU   ((32/4)*9)+32+2\n*\n** Literals\n*\n LTORG ,\n DS    0D\n EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Passed Dynamic Save Area                                    **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n DA#MXD ,                                 Generate work area\n ORG   CMXD_VAR                           Locate to our variable area\n            DS    0D\nDOUBLE      DS    D                       Double word work area\nSL_HEXS     DS    F\nW_REGS      DS    3F                      Registers save passed invoc.\nW_CHARL     DS    H                       Character/processing length\nW_FLAG1     DS    X                       Flag 1\n$W_F1NEXT   EQU   B'10000000'             ..Processing next line?\n ORG ,\n*\n** Map T_OUT table\n*\nTO          DSECT ,\nTO_CHARL    DS    XL2\nTO_MAXLEN   DS    XL2\nTOL         EQU   *-TO\n END ,\n./ ADD NAME=DA$PDSR  0101-01344-02221-1557-12915-12907-00000-DALCOCK\nDA$PDSR  TITLE 'The PDS Report Utility'\n\n\n* Note: PARM=CALLRACF doesn't work yet.  It gets\n*       icheinty locate rc=00000030\n\n\n* =================================================================== *\n*\n* Name: DA$PDSR\n*\n* Author = David Alcock :: dave@planetmvs.com\n*\n* Purpose: PDS (Partitioned Data Set) reporting\n*          See text at label HELPTEXT for more information *OR*\n*          execute this program with PARM='HELP'\n*\n* Attributes: Reentrant, Reusable, NonAuthorized (except for RACF call)\n*\n* Requirements:\n* o MVS/ESA and higher\n* o Assembler H and higher\n* o Some functions require DFSMS/MVS. We test for the level of\n*   DF/SMS at assembly (look at DSECTs) and execution (look at\n*   various control blocks).\n*\n* Non-IBM External programs:\n* o DA$DATE....Date routine\n* o DA$MXD.....Mini-Hex-Dump routine\n*\n* Non-IBM assembler MACROs:\n* o DA#ENTER...Entry housekeeping\n* o DA#LEAVE...Termination housekeeping\n* o DA#EYEC....Build standard O/S module eyecatcher\n*              (invoked by the DA#ENTER)\n* o DA#REGS....Define registers (invoked by DA#ENTER)\n* o DA#DATE....Equates and DSECTs for the date routine\n* o DA#MXD.....Equates and DSECTs for the mini-hex-dump routine\n* o DA#SMODE...Change addressing mode to/from 24 bit/31 bit\n* o DA#STR.....Create Pascal-like string with length byte (-1)\n*\n* Reference: SC26-4916 DFSMS/MVS Program Management\n*            LY26-3902 MVS/XA Linkage Editor Logic (old)\n*\n* CSECTs used:\n* o Internal:\n*   o DA$PDSR  - Main CSECT\n*   o PDSR$APF - APF library check\n*   o PDSR$RBF - Read BKLIDS file\n*   o PDSR$PRR - Print Report Record\n*   o PDSR$PSR - Print SYSPRINT Record\n*   o PDSR$MSG - Messages\n*   o PDSR$C1  - Constants CSECT 1\n*   o PDSR$C2  - Constants CSECT 2\n*   o PDSR$TRT - Translator and LKED Tables\n*   o PDSR$HLP - Help Information\n*   o PDSR$DA  - Dynamic Allocation\n*   o PDSR$LMF - Load Module formating\n*   o PDSR$IS  - ISPF Stats formating\n*   o PDSR$DSP - Dataset Summary Processing\n*   o PDSR$PPC - Parse Parameter Card and SYSIN\n*   o PDSR$IVC - Ignore Vendor CSECTs\n*   o PDSR$EC  - Eyecatcher formatter\n*   o PDSR$COC - COBOL CICS verification\n*   o PDSRCM   - Binder API reports\n*   o PDSRCMC  - Constants CSECT for PDSRCM\n*   o PDSRCMFM - FLATOUT member processing\n*   o PDSRCMM  - Msg Exit for PDSRCM\n* o External (optionally linked into us):\n*   o DA$DATE  - Date routine\n*   o DA$MXD   - Mini-Hex Dump\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n* Basic Logic:\n*\n*  Initialization: open files, init Binder API, etc.\n*  |\n*  |  Loop thru DDNAMEs and/or LNKLST and/or LPALST for PDSes\n*  |  |\n*  |  |  Open Partitioned Datasets\n*  |  |  |\n*  |  |  |  Process each member in the directory\n*  |  |  |  |\n*  |  |  |  | > Non-DFSMS: Look at IDR information\n*  |  |  |  | > DFSMS: Invoke the Binder API for each member\n*  |  |  |  |   and put output to //TRANRPT, //HISTRPT, etc.\n*  |  |  |  |\n*  |  |  |  Print report line about member information to //REPORT\n*  |  |  |\n*  |  |  Close PDS file\n*  |  |\n*  |  Print summary (next release of DA$PDSR)\n*  |\n*  Terminate: Term Binder API, close files, return to caller\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*   E n h a n c e m e n t   I d e a s\n*\n* o Extend EDITNCF and PDSRCM_EDITNCF to do a full 16 byte edit\n*   pattern and not just the 8\n* o Need to check #G_MAXFILES somewhere prudent\n* o PDSR$DA could be changed to regular call not base 8\n* o Module sizes in report need to be 8 bytes instead of 6.\n* o Correct \"Totals\" report header at the bottom of load libs.\n* o Convert julian date to gregorian in Translater/history reports\n* o File space information\n* o Create an ESTAE to gain control back if we aren't lucky in\n*   processing a member;\n* =================================================================== *\n         EJECT ,\n&DAVER SETC    '2.7'\n* =================================================================== *\n*\n*             M o d i f i c a t i o n   H i s t o r y\n*\n* 2002-08-09 -- David Alcock -- V2.7:\n* - Eliminated unrequested lines in //REPORT for PARM=DATAONLY;\n*\n* 2001-09-23 -- David Alcock -- V2.6:\n* - Add module link date to //FLATOUT output record for module rec.\n* - Added heading line so to document the level of DA$PDSR used.\n*   --> Incompatiblity in Flatout output (from 2.5)\n*   --> 1) Inserted Link Date \"DATE: value\" before \"ATTR:\"\n*   --> 2) Added new type \"H\" for heading line showing DA$PDSR info\n*   --> If proessing FLATOUT output, you will need to allow for these\n*\n* 2000-09-10 -- David Alcock -- V2.5:\n* - Added Processing of BKLIDS file (this associates a full name\n*   with a userid). This is used in the ISPF stats process only.\n*   Although the BKLIDS is an CA-ACF2 maintained sequential file,\n*   any shop can create a sequential file with the same fields\n*   to associate a userid with a name.\n* - Added preliminary support for PARM=CALLRACF to do calls to RACF for\n*   each userid for ISPF statistics.  This code currently hasn't been\n*   observed to work fully because I only have access to an ACF2\n*   system.  I also need to do the following:\n*   - Save user information that RACF passes to us so as to cut\n*     I/O to RACF database.  Should be saved into BKL control block...\n*   - See if RACROUTE extract might be better - RACF manual says so...\n*\n* 10-NOV-1998 - ??-???-1998 -- David Alcock -- V2.4:\n* - Eliminate message for GETN/RC4/RSN8300800 if flag EODC not on;\n*\n* 05-AUG-1998 -- David Alcock -- V2.3:\n* - Test for RC=4 and 83000801 for GETN call for CA-PDSMAN $$$SPACE\n*   member loops;\n* - Fix MSG999 TIME=00:00:00 to show correct time;\n*\n* 30-MAR-1998 - 03-APR-1998 -- David Alcock -- V2.2:\n* - Added vendor CSECT total counting and printing by category\n* - Added time on start and end messages\n* - Added option: NOEAGLE for people who don't want to see it or use\n*   a different code page that doesn't have the same characters.\n* - Added Ensure_Printable_Member routine to PDSRCM and PDSRCMM\n* - IVCSECTx enhancements:\n*   - List Vendor CSECTs\n*   - Added option NVENDORL for those who don't want list\n*   - Cache BLDL hits for less I/O\n*   - Statistics are printed at termination about IVC processing\n*\n* 26-MAR-1998 - 30-MAR-1998 -- David Alcock -- V2.1:\n* - Added IVCSECTx (Ignore Vendor CSECT) options:\n*   - IVCSECTS (Stats) - ignore when doing trivia (stats)\n*   - IVCSECTF (Full) - ignore when doing translator, zap and user rpt\n*   A //IVCSECT DD concatenation can be used to augment the internal\n*   vendor table with all known vendor csects.  CEE.SCEELKED has a LOT\n*   of squirelly CSECT names of LE/370 vendor CSECTS.\n* - Moved Load module (report line)  formating to separate CSECT\n*   PDSR$LMF to free room in main CSECT. Freed: 1048 bytes (418 hex)\n* - Bruce Leland sent me his latest Translator ID table!!!!\n* - Fix S0C4 because CSECT name for $Private was too long when the\n*   number > 99 - the $Private CSECTs are now $Priv#1-$Priv#9999. This\n*   allows DA$PDR to process EOY.SEOYLOAD at OS/390 v1r2 level now!\n*   Highest I've seen so far is $Priv#196;\n* - CA-Endevor leaves \"footprints\" in load modules:\n*   - For each CSECT, footprints are kept in a IDRU\n*   - For the whole load module, footprints are kept in a IDRZ\n*   I now accept RC=4 on the Binder API and proceed when the Binder API\n*   complains about the IDRU CA-Endevor errors, for example:\n*   \"IEW2520W 4706 IDRZ IMAGE FFF1 DOES NOT CONTAIN A VALID ESD ID...\"\n* - Fix trialing binary zero for ISO date format in heading line\n* - Detect $Private CSECTs in PDSRCM$M_TRAN (IDL) routine.\n* - Added message CM18 so we know who the Binder is talking about.\n* - Fix bug in PDSRCM_DUMPE (Dump entry) routine where the area string\n*   wasn't being saved.\n*\n* 09-MAR-1998 -- David Alcock -- V2.0:\n* - Start version numbering at 2.0\n* - Dataset summary added to the end of the //REPORT file\n* - Added EDITNCF routine for editing reg 1 flush without commas\n* - Show Oldest CSECT found in library\n* - Show Dataset allocations by track\n* - Added DA$PDSR mascot to SYSPRINT: the PDS Eagle (author unknown)\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* Person     Date        Description\n* ---------- ----------- --------------------------------------------\n* 02-FEB-1998 D Alcock   Insert first 256 bytes of CSECT to FLATOUT;\n*                        Moved member DA$PDSRC inline; Removed option\n*                        CSDUMP (use AMASPZAP instead); Eyecatcher\n*                        report will get ALL CSECTs if using Binder\n*                        API (not just main); CSECT name added to\n*                        ECRPT output line;\n* 19-JAN-1998 D Alcock   Add detection of OS/390 v2.3 and v2.4 mac;\n* 10-JAN-1998 D Alcock   Move ISPF stats formating to separate CSECT\n*                        PDSR$IS to save room in main CSECT; Started\n*                        FLATOUT file code;  Misc code improvements\n*                        with USINGS;\n* 29-DEC-1997 D Alcock   Fix S0C4 at OS/390 r2 with SWA=ABOVE;\n*                        &ASMDATE changed to ISO standard;\n* 15-MAY-1997 D Alcock   Fixed Binder info for pre-DFSMS 1.3; Fixed\n*                        missing \"*Unknown\" for first compiler not\n*                        known in TranRpt; Added DUMPBLDL option;\n*                        Renamed DIRENT option to DUMPDIRE and moved\n*                        moved output to SYSPRINT (from REPORT);\n* 09-MAY-1997 D Alcock   Added DATE=US/EUR/ISO operand; Removed USDATE\n*                        operand; Added ISO date processing;\n* 08-MAY-1997 D Alcock   Better handling of CSECT names over the\n*                        current report field length of 10; Detect\n*                        $Private sections and create a good name\n*                        (rather than binary) and append a count; Use\n*                        class name format based on SMS level;\n* 03-MAY-1997 D Alcock   Parse option from SYSIN;  Added NOSYSIN;\n*                        Added date and time to translator and history\n*                        report headings; Added CSECT count to load\n*                        module report; Call IGWASMS; Added dynamic\n*                        APFLST for MVS 4.3 and higher; Always print\n*                        DFP level (even if DFSMS/MVS);\n* 29-APR-1997 D Alcock   Added TEXT load module processing using the\n*                        Binder API - option CSDUMP= added; Added\n*                        TSOVIEW option; Restructuring;\n* 25-APR-1997 D Alcock   Added a debugging mode to the Binder API\n*                        message exit (CSECT PDSRCMM) and added DFSMS\n*                        version checking;\n* 23-APR-1997 D Alcock   Added OPEN/BLDL/CLOSE for DCB=PO for LOAD and\n*                        PDSRCM processing; Added DCB/DirEnt\n*                        processing to PDSRCM; Use fancier message\n*                        wrapping to PDSRCM/MSGEXIT; Use CSVQUERY when\n*                        on MVS 4.3 and higher; Moved Eye- catcher\n*                        format and Help routines to separate CSECTS\n*                        to save code area in main CSECT;\n* 22-APR-1997 D Alcock   Moved STARTD to Init and ENDD to Term to\n*                        aid performance; FINDMEM=member added;\n*                        Option=ONLYFIND added; Option=NOSMS added;\n* 21-APR-1997 D Alcock   Removed CESD and IDR$TRN code; Correct\n*                        S0C3 for MEMXREF and CHKDUP;  Added hex\n*                        dump of Binder API control blocks;\n* 15-APR-1997 D Alcock   Added History report (dd=HISTRPT);\n* 14-APR-1997 D Alcock   Added program PDSRCM which uses the IBM\n*                        DFSMS/MVS Binder API to process CSECTS; Added\n*                        Translator report (dd=TRANRPT);\n* 16-MAR-1997 D Alcock   Moved parm parse routine to separate\n*                        CSECT; Added time to MSG20;\n* 13-MAR-1997 D Alcock   Fix endless loop if invalid parm is given;\n*                        Remove PARM=APFLST; Corrected duplicate\n*                        ZAPRPT flag; Added CPPL parameter call;\n* 24-FEB-1997 D Alcock   Added: COBCRPT - COBOL CICS report;\n* 12-DEC-1996 D Alcock   Misc fixes to ZAPRPT; Removed some dead\n*                        via AGO/ANOP for CESD and IDR$TRN; Check\n*                        for Length of 0 in Eyecatcher; Added\n*                        Translator list in PARM=HELP;\n* ??-DEC-1996 D Alcock   Added hexstring translate to lower;\n* 25-NOV-1996 D Alcock   Renamed to DA$PDSR; Check for dynamic\n*                        APFLST (Support will be added later);\n*                        Corrected a few bugs;\n* 20-FEB-1991 D Alcock   Added: ECRPT - Eye Catcher Report;\n* 08-JAN-1991 D Alcock   Added: ZAPRPT - AMASPZAP report;\n* 16-MAR-1990 D Alcock   Added: APFLST; CHKDUP; LNKLST; LPALST;\n*                        HELP; NODETAIL; MEMXREF; DUMPDSCB\n* 15-APR-1985 D Alcock   Original program written;\n* =================================================================== *\n         SPACE 2\n*\n** Installation customization\n*\n#BKUSERS EQU   20000                        Number of BKLIDS records\n&ACF2    SETB  0                            1=Use_ACF2_Macro 0=Don't\n         EJECT\n***********************************************************************\n***\n**       Set the DFP/DFSMS and O/S maclib levels to variables\n***\n***********************************************************************\n         SPACE 2\n         GBLC  &DMACLIB                   DFP/DFSMS maclib version\n&DMACLIB SETC  'PRE-DFP'                  Start out at ancient level\n         GBLC  &IHADFARELS                IHADFA sets to system level\n*-If you aren't at DFP maclib, comment out \"IHADFA\"\n         IHADFA ,                         Data Facilities Area\n         AIF   (NOT D'DFA).SMSX           Have IHADFA?\n         AIF   (D'DFADFSMS).SMSSTRT       At DFSMS 1.1?\n*-DFP maclib checks\n&DMACLIB SETC  'DFP'\n         AIF   (NOT D'DFASMS).SMSX\n&DMACLIB SETC  'DFP 310'\n         AIF   (NOT D'DFAPDSE).SMSX\n&DMACLIB SETC  'DFP 320'\n         AIF   (NOT D'DFAVOLSN).SMSX\n&DMACLIB SETC  'DFP 330'\n         AIF   (NOT D'DFAVOLSN).SMSX\n&DMACLIB SETC  'DFP 331'\n         AIF   (NOT D'DFARECAL).SMSX\n&DMACLIB SETC  'DFP 332'\n         AGO   .SMSX\n*-As stated in the \"DFSMS/MVS 1.3 DFSMSdfp Advanced Services\" manual,\n* the IHADFA macro did not always set &IHADFARELS (but they could\n* in the future), so attempt to deterimine prior release levels.\n.SMSSTRT ANOP  ,\n         AIF   ('&IHADFARELS' NE '').SMSSET   Already have SMS level?\n&IHADFARELS SETC '01010100'               Start at DFSMS 1.1\n         AIF   (NOT D'DFADEEXT).SMSSET    At DFSMS 1.2?\n&IHADFARELS SETC '01010200'               Up to DFSMS 1.2\n.SMSSET  ANOP  ,                          Set level\n&DMACLIB SETC  'DFSMS/MVS &IHADFARELS'    Set DFP/DFSMS maclib level\n.SMSX    ANOP  ,\n*\n         CVT   DSECT=YES,LIST=NO,PREFIX=YES MVS CVT\n*-Attempt to identify the MVS maclib level\n         GBLC  &MMACLIB                   MVS maclib version\n         AIF   (NOT D'CVTJ6604).MMO24X\n&MMACLIB SETC  'OS/390 v2.4 or higher'\n         AGO   .MMX\n.MMO24X  ANOP    ,\n         AIF   (NOT D'CVTH6603).MMO23X\n&MMACLIB SETC  'OS/390 v2.3'\n         AGO   .MMX\n.MMO23X  ANOP    ,\n         AIF   (NOT D'CVTJ6602).MMO12X\n&MMACLIB SETC  'OS/390 v1.2'\n         AGO   .MMX\n.MMO12X  ANOP    ,\n         AIF   (NOT D'CVTH6601).MMO11X\n&MMACLIB SETC  'OS/390 v1.1'\n         AGO   .MMX\n.MMO11X  ANOP    ,\n         AIF   (NOT D'CVTJ5522).MM522X\n&MMACLIB SETC  'MVS 5.2.2'\n         AGO   .MMX\n.MM522X  ANOP    ,\n         AIF   (NOT D'CVTH5520).MM520X\n&MMACLIB SETC  'MVS 5.2.0'\n         AGO   .MMX\n.MM520X  ANOP  ,\n         AIF   (NOT D'CVTH5510).MM510X\n&MMACLIB SETC  'MVS 5.1.0'\n         AGO   .MMX\n.MM510X  ANOP  ,\n         AIF   (NOT D'CVTH4430).MM430X\n&MMACLIB SETC  'MVS 4.3.0'\n         AGO   .MMX\n.MM430X  ANOP  ,\n         AIF   (NOT D'CVTJ4422).MM422X\n&MMACLIB SETC  'MVS 4.2.2'\n         AGO   .MMX\n.MM422X  ANOP  ,\n         AIF   (NOT D'CVTH4420).MM420X\n&MMACLIB SETC  'MVS 4.2.0'\n         AGO   .MMX\n.MM420X  ANOP  ,\n         AIF   (NOT D'CVTH4410).MM410X\n         AGO   .MMX\n&MMACLIB SETC  'MVS 4.1.0'\n.MM410X  ANOP  ,\n         AIF   (NOT D'CVTJ3313).MM313X\n&MMACLIB SETC  'MVS 3.1.3'\n         AGO   .MMX\n.MM313X  ANOP  ,\n         AIF   (NOT D'CVTJ3311).MM311X\n&MMACLIB SETC  'MVS 3.1.1'\n         AGO   .MMX\n.MM311X  ANOP  ,\n         AIF   (NOT D'CVTH3310).MM310X\n&MMACLIB SETC  'MVS 3.1.0'\n         AGO   .MMX\n.MM310X  ANOP  ,\n&MMACLIB SETC  'PRE-MVS3.1.0'             ..Default to pre-MVS3.1.0\n.MMX     ANOP  ,\n         EJECT ,\n***********************************************************************\n***\n**       External DSECTs\n***\n***********************************************************************\n         SPACE 2\n         IHAPDS PDSBLDL=NO                PDS Directory entry\n         PRINT NOGEN\n         IHAPSA ,                         Prefixed Save Area\n         IEFTIOT1 ,                       Task I/O Table\n         IKJTCB DSECT=YES,LIST=NO         Task Control Block\n         IEFJFCBN LIST=YES                Job File Control Block\n         IEFUCBOB LIST=YES                Unit Control Block\n         DCBD   DSORG=PO,DEVD=DA          Data Control Block\n         IEZDEB ,                         Data Extent Block\n         IECSDSL1 (1)                     DSCB - Format 1\n         IHADECB ,                        Data Event Control Block\n         IEFZB4D0 ,                       SVC 99 - RB\n         IEFZB4D2 ,                       SVC 99 - Text Equates\n         IEFZB505 LOCEPAX=YES             EPA mapping for SWAREQ\n         IEFQMIDS ,                       Equates for SWA requests\n         IEFJESCT ,                       JES Communications Table\n         IEESMCA ,                        SMF Control Area\n         IKJCPPL ,                        Command Processor parm list\n         AIF   (NOT D'CVTH4430).DSM43X    At the right MVS level?\nCSVQRY$  DSECT ,\n         CSVQUERY PLISTVER=0,MF=(L,CSVQRY) CSVQuery parmlist\n         CSVAPFAA ,                       Dynamic APF\n.DSM43X ANOP ,\n*\n** Non-IBM macros\n*\n         DA#DATE ,                        Date Routine\n         DA#MXD ,                         Hex Dump routine\n         DA#COBOL ,                       Map COBOL eyecatchers\n*\n** Copied from debugging handbook - IBM in their wisdom does not give\n** us the mapping DSECT\n*\nLLTCOUNT EQU   X'04'                      Number of Datasets in LNKLST\nLLTENTRY EQU   X'08'                      Offset to first entry\n*\nLPATCNT  EQU   X'04'                      Number of Datasets in LPALST\nLPATNTRY EQU   X'08'                      Offset to first entry\n*\n** If we have the ACF2 macro library use it, otherwise create our own\n*\n         AIF   (&ACF2).DSACF2             Do we have the ACF2 mac lib?\nLIDREC   DSECT ,                          Our own simulated layout:\nLIDLID   DS    CL8                        ..Userid\n         DS    XL4                        ..Unused by us\nLIDNAME  DS    CL20                       ..Programmer name\n         AGO   .DSACF2X\n.DSACF2  ANOP  ,\n         LIDREC ,\n.DSACF2X ANOP  ,\n*\n** BKLIDS Table\n*\nBKL        DSECT ,\nBKLH       EQU   *\nBKLH_ID    DS    CL8'BKLIDST'           ID for dumps\nBKLH_LEN   DS    XL4                    Length of area obtained\nBKLH_USERC DS    XL4                    Number of users we have\nBKLH_DCB   DS    XL(C_DCBVIL)           DCB for BKLIDS\nBKLHL      EQU   *-BKLH\n*\nBKLE       EQU   *\nBKLE_USER  DS    XL(L'LIDLID)\nBKLE_NAME  DS    XL(L'LIDNAME)\nBKLEL      EQU   *-BKLE\n         EJECT\n***********************************************************************\n***\n**       Set misc internal assembly variables\n***\n***********************************************************************\n         SPACE 2\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         PRINT GEN\n*\n** Global Program equates\n*\n#G_MAXFILE  EQU   999                     Maximum number of files\n*Fix label: FOR_LIBN when 999 (#MAXFILE) is more than 3 digits\n            SPACE 2\n#G_ORPHANS  EQU   1000                    Number of orphans per PDS\n         EJECT\n***********************************************************************\n***\n**       Entry Housekeeping and misc initializations\n***\n***********************************************************************\n         SPACE 2\n         EJECT ,\nDA$PDSR  DA#ENTER 'V&DAVER Utility: PDS reporting',                    @\n               RENT=YES,                  Indicate we need GETMAIN     @\n               LV=WORKDSL,                Length of GETMAIN            @\n               BASE=(12,11,10)            Base Registers\n         USING WORKDS,R13                 Addressibility to work area\n         ST    R1,PPC_R1ENTRY             Save parameter address\n         MVC   SUBRSA+4(4),=C'F1SA'       Fix up RSA\n*\n** Load/locate external programs\n*\n         ICM   R0,B'1111',=V(DA$DATE)     Have DA$DATE linked in?\n         BNZ   I$DATES                    Yes, save address\n         LA    R8,=CL8'DA$DATE'           Locate module name\n         LOAD  EPLOC=(8),ERRET=E$LOAD     Load it\n         OI    W_FLAG1,$W_F1LRDATE        We loaded it, alright!\nI$DATES  DS    0H\n         ST    R0,EP_DA$DATE              Save entry point address\n*\n#MXDWIDE EQU   132-(MSGPREL+8)            Length of output area\n         ICM   R0,B'1111',=V(DA$MXD)      Have DA$MXD linked in?\n         BNZ   I$MXDS                     Yes, save address\n         LA    R8,=CL8'DA$MXD'            Locate module name\n         LOAD  EPLOC=(8),ERRET=E$LOAD     Load it\n         OI    W_FLAG1,$W_F1LRMXD         We loaded it, alright!\nI$MXDS   DS    0H\n         ST    R0,EP_DA$MXD               Save entry point address\n*\n** Invoke the parse routine for the parm='options' field\n*\n         LA    R0,#PPC_OPTION_PARM        Option = Parse PARM='option'\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$PPC)           Locate CSECT\n         BASR  R14,R15                    Invoke the parse routine\n*\n** Get the current date and time for report headings\n*\n         L     R1,=V(PDSR$C1)             -> Constants CSECT\n         MVC   W_ODGEUR11(C_ODGEUR11L),C_ODGEUR11-PDSR$C1(R1)\n         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?\n         BO    I$CDISO\n         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?\n         BNO   I$CDISOX                   Use default of \"European\"\n         MVI   W_ODGEUR11_TYPE+1,$DA#DATE_ODGUS Make Gregorian US\n         MVI   W_ODGEUR11_STRL,$DA#DATE_ODGUS10 Set length\n         B     I$CDISOX\nI$CDISO  DS    0H\n         MVI   W_ODGEUR11_TYPE+1,$DA#DATE_ODISO Make ISO\n         MVI   W_ODGEUR11_STRL,$DA#DATE_ODISO10 Set length\n         MVI   W_ODGEUR11_STR+10,C' '     Fix trailing zero to blank\nI$CDISOX DS    0H\n         MVC   W_OTIMES8(C_OTIMES8L),C_OTIMES8-PDSR$C1(R1)\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine\n         CALL  (15),(W_ODGEUR11,W_OTIMES8),VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n*\n** Open the messages file\n*\n         LA    R3,SYSPRINT                Locate DCB work area\n         L     R1,=V(PDSR$C1)             -> Constants\n         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSPRINT'\n         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)\n         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n         LA    R8,=CL8'SYSPRINT'          Locate file\n         BAS   R14,CHECK_OPEN_ABEND       Check for Abend\n         LA    R1,255                     Get excessive count\n         STC   R1,PSR_LC                  ..Force heading\n         MVC   PSRAREA+4(4),=C'F1SA'      Fix up RSA\n*\n         TIME  BIN                        Get the time\n         ST    R0,DOUBLE                  Save for later\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG1L,R15),MSG1-PDSR$MSG(R1) Move in message\n         LA    R15,MSG1L(R15)             Bump past the message\n         L     R1,DOUBLE                  Get the time\n         BAS   R14,CONVERT_BINARY_TIME    \" hh:mm:ss\"\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         L     R7,=V(PDSR$C2)             Locate constants CSECT\n         TM    PPC_FLAG5,$PPC_F5NOEAGLE\n         BNO   I$EAGLES\n         LA    R7,NO_PICTURE-PDSR$C2(R7)  Locate text strings\n         B     I$EAGLEL\nI$EAGLES DS    0H\n         LA    R7,EAGLE_PICTURE-PDSR$C2(R7) Locate eagle picture\nI$EAGLEL DS    0H\n         LA    R15,RECOUT+14              Locate output area\n         SLR   R14,R14                    Clear register for IC\n         IC    R14,0(R7)                  Obtain length of messsage - 1\n         EX    R14,I$EAGLEM               Move string to message area\n         LA    R7,2(R14,R7)               Bump past this string\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         CLC   0(2,R7),=X'FFFFFFFF'       At end of strings?\n         BNE   I$EAGLEL                   No, continue\n         B     I$EAGLEX\nI$EAGLEM MVC   0(0,R15),1(R7)\nI$EAGLEX DS    0H\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print another blank line\n*\n** Obtain dataset summary table\n*\n#IDSUM   EQU   DSUMHL+(#G_MAXFILE*DSUMEL) Calc length of area\n         L     R0,=AL4(#IDSUM)            Get length of area\n         GETMAIN RU,LV=(0)                Obtain storage\n         ST    R1,PP_DSUMA                Save address\n         MVC   DSUMH_NAME-DSUMH(4,R1),=C'DSUM'     Set eyecatcher\n         ST    R0,DSUMH_LEN-DSUMH(R1)     Save length of area\n         XC    DSUMH_I-DSUMH(DSUMH_IL,R1),DSUMH_I-DSUMH(R1)\n         LA    R14,DSUMHL(R1)             Locate to first entry\n         ST    R14,DSUMH_CURR-DSUMH(R1)   Set current entry\n*\n** Obtain orphan table\n**\n** Note: Have not added ORPHANS=xxxx as parameter yet...\n*\n         L     R0,=AL4(#G_ORPHANS*ORPTL)  Get length of area\n         GETMAIN RU,LV=(0),LOC=(ANY,ANY)  Obtain storage\n         STM   R0,R1,PP_OT                Save length and address\n         A     R1,=AL4(1000*ORPTL)        Locate past it\n         SH    R1,=AL2(ORPTL-1)           Backup to last entry\n         ST    R1,PP_OTLE                 save it\n*\n** Print Parm card information\n*\n         L     R7,PPC_R1ENTRY             -> Parameter pointer\n         L     R7,0(R7)                   Get parameter\n         SLR   R8,R8                      Clear register\n         ICM   R8,B'0011',0(R7)           Get length of passed parm\n         BZ    I$PEX                      None, leave\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG2L,R15),MSG2-PDSR$MSG(R1) Move in message\n         LA    R15,MSG2L(R15)             Bump past it\n         BCTR  R8,0                       Decrement for EX\n         EX    R8,I$MPRM                  Move parameter to message\n         LA    R15,1(R8,R15)              Bump past it\n         MVI   0(R15),X'7D'               Insert ending tick\n         BAS   R14,PRINT_SYSPRINT_RECORD\n*\n         SLR   R1,R1                      Zero out register\n         ICM   R1,B'0011',PPC_NUM         Get number of parms errors\n         BZ    I$PESI                     None, leave\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(4,R15),MSG3-PDSR$MSG(R1) Move in message ID\n         LA    R15,MSG2L(R15)\n         L     R1,=V(PDSR$C1)\n         MVC   0(90,R15),C_COLS-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG3L,R15),MSG3-PDSR$MSG(R1) Move in message\n         LA    R15,MSG3L+1(R15)           Bump past it\n         LH    R1,PPC_COL                 Get parameter column\n         LA    R1,1(R1)                   Start from 1 not zero\n         BAS   R9,EDITFWF                 Print column number\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nI$PESI   DS    0H\n         TM    PPC_FLAG4,$PPC_F4NOSYSIN   User doesn't want SYSIN?\n         BO    I$PESIX                    Yes, leave\nI$PESIL  DS    0H\n         LA    R0,#PPC_OPTION_SYSIN       Option = Parse SYSIN\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$PPC)           Locate CSECT\n         BASR  R14,R15                    Invoke the parse routine\n         CH    R15,=AL2(#PPC_RC_EOF)      End of SYSIN\n         BNE   I$PESIL                    No, try another\n*\nI$PESIX  DS    0H\n         ICM   R1,B'0011',PPC_NUM         Get number of parms errors\n         BZ    I$PEX                      None, leave\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG4L,R15),MSG4-PDSR$MSG(R1) Move in message\n         LA    R15,MSG4L+1(R15)           Bump past it\n         LH    R1,PPC_NUM                 Get number of parm errors\n         BAS   R9,EDITFWF                 Print it\n         TM    PPC_IFLAG1,$PPC_IF1DATEERR\n         BNO   I$MPRMDX\n         L     R1,=V(PDSR$MSG)\n         MVC   1(MSG4AL,R15),MSG4A-PDSR$MSG(R1) Move in message\nI$MPRMDX DS    0H\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVI   MAXCC,$SEVERE              Set maximum condition code\n         B     EXIT\nI$MPRM   MVC   0(0,R15),2(R7)\nI$MDDP   MVC   0(0,R15),PPC_DDP\nI$PEX    DS    0H\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print the DFSMS (if under DFSMS), DFP and MVS BCP levels\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG48L,R15),MSG48-PDSR$MSG(R1) Move in message\n         LA    R15,MSG48L+1(R15)          Bump past it\n*\n** Insert \"DF/SMS level\" (if we are executing on a system with DFSMS)\n** into message\n*\n         L     R2,CVTPTR                  -> CVT\n         L     R2,CVTDFA-CVTMAP(R2)       -> Data Facilities Area\n         AIF   ('&IHADFARELS' LT '01010100').RELSX .at DFSMS/MVS 1.1?\n         CLC   DFARELS-DFA(4,R2),ZEROS    Pre-DFSMS/MVS?\n         BE    I$SMSLX                    Yes, skip\n         MVC   W_DFARELS(4),DFARELS-DFA(R2) Save DFSMS/MVS level info\n         OI    W_FLAG1,$W_F1DFSMS         We are DFSMS/MVS!\n         ST    R15,DOUBLE2                Save current location\n         BAS   R14,OBTAIN_PDSRCMD         Obtain work area\n         L     R15,DOUBLE2                Restore current location\n         L     R1,=V(PDSR$MSG)            Locate constants CSECT\n         MVC   0(L'MSG48B,R15),MSG48B-PDSR$MSG(R1)\n         LA    R15,L'MSG48B+1(R15)\n         LA    R4,DFAVER-DFA(R2)          Locate to version\n         LA    R5,L'DFAVER+L'DFARLSE+L'DFAMOD Length to consider\nI$SMSLL  DS    0H\n         SLR   R1,R1                      Get ready for Insert\n         IC    R1,0(R4)                   Get value\n         BAS   R9,EDITFWF                 Edit it flush\n         MVI   0(R15),C'.'                Insert delimiter\n         LA    R15,1(R15)                 Bump past delimiter\n         LA    R4,1(R4)                   Bump to next value\n         BCT   R5,I$SMSLL                 ..Try it out\n         BCTR  R15,0\n         MVI   0(R15),C' '\n         LA    R15,1(R15)\n*\n         L     R1,=V(PDSR$MSG)            Locate constants CSECT\n         TM    PPC_FLAG4,$PPC_F4NOSMS     No SMS processing?\n         BNO   I$SMSLYX                   No, continue\n         NI    W_FLAG1,255-$W_F1DFSMS     Don't use DFSMS services\n         OI    W_FLAG1,$W_F1NOSMS         Might be useful to know later\n         MVC   0(L'MSG48C,R15),MSG48C-PDSR$MSG(R1) Move in message\n         LA    R15,L'MSG48C+1(R15)        Locate past it\nI$SMSLYX DS    0H\n         MVI   0(R15),C'-'\n         LA    R15,2(R15)                 Locate past it\nI$SMSLX  DS    0H\n.RELSX ANOP ,\n*\n** Insert \"DFP level\" into message\n*\n         MVC   0(L'MSG48D,R15),MSG48D-PDSR$MSG(R1)\n         LA    R15,L'MSG48D+1(R15)\n         UNPK  DOUBLE2(5),DFAREL-DFA(3,R2)\n         MVZ   DOUBLE2(4),ZEROS\n         TR    DOUBLE2(4),HEXTABLE\n         MVC   0(1,R15),DOUBLE2\n         MVI   1(R15),C'.'\n         MVC   2(1,R15),DOUBLE2+1\n         MVI   3(R15),C'.'\n         MVC   4(1,R15),DOUBLE2+2\n         LA    R15,6(R15)\nI$DFPLX  DS    0H\n*\n** Insert \"MVS BCP level\" into message\n*\n         L     R1,=V(PDSR$MSG)            Locate constants CSECT\n         MVC   0(L'MSG48E,R15),MSG48E-PDSR$MSG(R1)\n         LA    R15,L'MSG48E+1(R15)\n         L     R1,CVTPTR                  -> CVT\n         LA    R0,CVTLEVL+L'CVTLEVL-CVTFIX Length of CVT prefix\n         SR    R1,R0                      -> Backup to start of Prefix\n         MVC   0(L'CVTPRODN,R15),CVTPRODN-CVTFIX(R1)\n         MVC   W_BCPLEVEL(L'CVTPRODN),CVTPRODN-CVTFIX(R1)\n*\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Initialization for Ignore_Vendor_CSECT\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG5,$PPC_F5IVCSECTS\n         BNO   I$IVCX\n         LA    R0,#IVC_INIT\n         LA    R1,SUBRSA\n         L     R15,=V(PDSR$IVC)\n         BASR  R14,R15\nI$IVCX   DS    0H\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       If PARM=CALLRACF, we better be authorized\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG5,$PPC_F5CALLRACF  Call RACF?\n         BNO   I$CRX                      Nope, Continue\n         TESTAUTH FCTN=1                  Test APF authorization\n         LTR   R15,R15                    Are we authorized?\n         BZ    I$CRX                      Yes, continue\n         NI    PPC_FLAG5,255-$PPC_F5CALLRACF Turn off option\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG8L,R15),MSG8-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nI$CRX    EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print help information if requested\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG2,$PPC_F2HELP\n         BNO   I$HELPX\n         LA    R1,SUBRSA\n         L     R15,=V(PDSR$HLP)\n         BASR  R14,R15\nI$HELPX  DS    0H\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Check for mutually exclusive options\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** CHKDUP and MEMXREF\n*\n         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for Duplicates?\n         BNO   I$CDX                      No, continue\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?\n         BNO   I$CDX                      No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG7L,R15),MSG7-PDSR$MSG(R1) Move in message\n         LA    R15,MSG7L+1(R15)           Bump past message\n         L     R14,=V(PDSR$PPC)\n         MVC   0(6,R15),TPF_CHKDUP+1-PDSR$PPC(R14)\n         MVC   8(7,R15),TPF_MEMXREF+1-PDSR$PPC(R14)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVI   MAXCC,$SEVERE              Set maximum condition code\n         TM    PPC_FLAG1,$PPC_F1SIMULATE  Simulate mode?\n         BNO   EXIT                       No, leave right now\nI$CDX    DS    0H\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print criteria\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG5L,R15),MSG5-PDSR$MSG(R1) Move in message\n         LA    R15,MSG5L(R15)             Bump past message\n         SLR   R14,R14                    Clear register\n         IC    R14,PPC_DDPL               Get length of DD prefix\n         EX    R14,I$MDDP                 Move DD prefix out\n         LA    R15,1(R14,R15)             Bump past it\n         MVI   0(R15),C'\"'                Insert delimiter\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print record\n         EJECT ,\n***********************************************************************\n***\n**  Misc report file opens\n**\n**  NOTE: This code needs to be reworked and standardized.\n**        Dave_Alcock@31Jan1998\n***\n***********************************************************************\n         SPACE 2\n*\n** Open the ECRPT file if option is set\n*\n         TM    PPC_FLAG3,$PPC_F3ECRPT     Need report?\n         BNO   I$ECRX                     No, continue\n         LA    R3,ECRPT                   Locate DCB work area\n         L     R1,=V(PDSR$C1)             -> Constants\n         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_ECRPT-PDSR$C1(R1)\n         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)\n         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n         L     R8,=V(PDSR$C1)             -> Constants\n         LA    R8,C_DD_ECRPT-PDSR$C1(R8)  Locate DDNAME=ZAPRPT\n         BAS   R14,CHECK_OPEN_ABEND       Check for Abend\n         AIF   ('&IHADFARELS' LT '01010100').IECX\n         TM    W_FLAG1,$W_F1DFSMS         DFSMS/MVS?\n         BNO   I$ECRX                     No, continue\n         BAS   R14,OBTAIN_PDSRCMD         Obtain work area\n.IECX    ANOP  ,\nI$ECRX   EQU   *\n*\n** Open the ZAPRPT file if option is set\n*\n         TM    PPC_FLAG3,$PPC_F3ZAPRPT   Need Zap report\n         BNO   I$ZRX\n         TM    W_FLAG1,$W_F1DFSMS         DFSMS/MVS?\n         BO    I$ZRSMS                    Yes, continue\n         LA    R3,ZAPRPT                  Locate DCB work area\n         L     R1,=V(PDSR$C1)             -> Constants\n         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_ZAPRPT-PDSR$C1(R1)\n         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)\n         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n         L     R8,=V(PDSR$C1)             -> Constants\n         LA    R8,C_DD_ZAPRPT-PDSR$C1(R8) Locate DDNAME=ZAPRPT\n         BAS   R14,CHECK_OPEN_ABEND       Check for Abend\n         B     I$ZRX\nI$ZRSMS  DS    0H\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG51L,R15),MSG51-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         OI    PPC_FLAG4,$PPC_F4HISTR\n         NI    PPC_FLAG3,255-$PPC_F3ZAPRPT  Turn off Zap report\nI$ZRX    DS    0H\n*\n** Initialization if Translator report is needed\n*\n         TM    PPC_FLAG4,$PPC_F4TRANR     Need report?\n         BNO   I$TRANRRX                  No, continue\n         TM    W_FLAG1,$W_F1NOSMS         Using DFSMS services?\n         BO    I$TRANRNS                  No, skip\n         L     R8,=V(PDSR$C1)             -> Constants\n         LA    R8,C_DD_TRANRPT-PDSR$C1(R8) Locate =CL8'TRANRPT'\n         DEVTYPE (R8),DOUBLE              Get file information\n         LTR   R15,R15\n         BNZ   I$TRANRE\n*\n         AIF   ('&IHADFARELS' LT '01010100').TRANRN\n         BAS   R14,OBTAIN_PDSRCMD          Obtain work area\n         OI    PDSRCMD_FLAG1-PDSRCMD(R1),$PDSRCMD_F1TRAN\n         B     I$TRANRRX\n         AGO   .TRANRX\n.TRANRN ANOP   ,\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG50L,R15),MSG50-PDSR$MSG(R1) Move in message\n         L     R1,=V(PDSR$C1)\n         MVC   MSG50T-MSG50(4,R15),C_DD_TRANRPT-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         MVI   MAXCC,8\n         B     EXIT\n.TRANRX ANOP   ,\n*\nI$TRANRNS DS 0H\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG52L,R15),MSG52-PDSR$MSG(R1) Move in message\n         L     R1,=V(PDSR$C1)\n         MVC   MSG52T-MSG52(7,R15),C_DD_TRANRPT-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         B     I$TRANRRX\n*\nI$TRANRE DS 0H\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG49L,R15),MSG49-PDSR$MSG(R1) Move in message\n         LA    R15,MSG49L(R15)\n         L     R1,=V(PDSR$C1)\n         MVC   0(8,R15),C_DD_TRANRPT-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         MVI   MAXCC,8\n         B     EXIT\nI$TRANRRX DS 0H\n*\n** Initialization if History report is needed\n*\n         TM    PPC_FLAG4,$PPC_F4HISTR     Need report?\n         BNO   I$HISTRRX                  No, continue\n         TM    W_FLAG1,$W_F1NOSMS         Using DFSMS services?\n         BO    I$HISTRNS                  No, skip\n         L     R8,=V(PDSR$C1)             -> Constants\n         LA    R8,C_DD_HISTRPT-PDSR$C1(R8) Locate =CL8'TRANRPT'\n         DEVTYPE (R8),DOUBLE              Get file information\n         LTR   R15,R15\n         BNZ   I$HISTRE\n*\n         AIF   ('&IHADFARELS' LT '01010100').HISTRN\n         BAS   R14,OBTAIN_PDSRCMD          Obtain work area\n         OI    PDSRCMD_FLAG1-PDSRCMD(R1),$PDSRCMD_F1HIST\n         B     I$HISTRRX\n         AGO   .HISTRX\n.HISTRN ANOP   ,\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG50L,R15),MSG50-PDSR$MSG(R1) Move in message\n         L     R1,=V(PDSR$C1)\n         MVC   MSG50T-MSG50(4,R15),C_DD_HISTRPT-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         MVI   MAXCC,8\n         B     EXIT\n.HISTRX ANOP   ,\n*\nI$HISTRNS DS 0H\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG52L,R15),MSG52-PDSR$MSG(R1) Move in message\n         L     R1,=V(PDSR$C1)\n         MVC   MSG52T-MSG52(7,R15),C_DD_HISTRPT-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         B     I$HISTRRX\n*\nI$HISTRE DS 0H\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG49L,R15),MSG49-PDSR$MSG(R1) Move in message\n         LA    R15,MSG49L(R15)\n         L     R1,=V(PDSR$C1)\n         MVC   0(8,R15),C_DD_HISTRPT-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         MVI   MAXCC,8\n         B     EXIT\nI$HISTRRX DS 0H\n*\n** After all PDSRCM functions have been found, initialize PDSRCM\n*\n         AIF   ('&IHADFARELS' LT '01010100').RCMIX\n*\n         ICM   R1,B'1111',A_PDSRCMD+4     Locate area\n         BZ    I$PDSRCM$X                 None, PDSRCM not needed\n         LA    R15,W_ODGEUR11\n         ST    R15,PDSRCMD_DATE-PDSRCMD(R1)\n         LA    R15,W_OTIMES8\n         ST    R15,PDSRCMD_TIME-PDSRCMD(R1)\n         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_INIT\n         MVC   PDSRCMD_DFARELS-PDSRCMD(L'W_DFARELS,R1),W_DFARELS\n*\n         LA    R14,SUBRSA\n         ST    R14,PDSRCMD_SUBRSAP-PDSRCMD(R1)\n*\n         L     R15,=V(PDSRCM)             Locate routine\n         BASR  R14,R15                    Initialize\n         LTR   R15,R15\n         BZ    I$PDSRCM$X\n         MVI   MAXCC,8\n         B     EXIT\nI$PDSRCM$X DS  0H\n.RCMIX   ANOP  ,\n*\n** Open the COBCRPT file if option is set\n*\n         TM    PPC_FLAG3,$PPC_F3COBCRPT   Need report?\n         BNO   I$CCRX                     No, continue\n         LA    R3,COBCRPT                 Locate DCB work area\n         L     R1,=V(PDSR$C1)             -> Constants\n         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_COBCRPT-PDSR$C1(R1)\n         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)\n         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n         L     R8,=V(PDSR$C1)             -> Constants\n         LA    R8,C_DD_COBCRPT-PDSR$C1(R8) Locate DDNAME=COBCRPT\n         BAS   R14,CHECK_OPEN_ABEND       Check for Abend\nI$CCRX   EQU   *\n         EJECT ,\n***********************************************************************\n***\n**       Check for Duplicates / Member XREF --- Initialization\n***\n***********************************************************************\n         SPACE 2\nCHECK_FOR_DUPLICATES_INITIALIZATION EQU *\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member Cross reference?\n         BO    CFDI$S                     Yes, do it\n         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates?\n         BNO   CFDI$X                     No, continue\nCFDI$S   EQU   *\n*\n** Ensure that needed files are allocated\n*\n         LA    R8,=CL8'WRKFILE1'\n         BAS   R7,CFDI$FA\n         LA    R8,=CL8'WRKFILE2'\n         BAS   R7,CFDI$FA\n         LA    R8,=CL8'WRKFILE3'\n         BAS   R7,CFDI$FA\n         CLI   MAXCC,$SEVERE              All files there?\n         BE    EXIT                       No, we can't take a joke\n*\n** Open sort input file\n*\n         LA    R3,WRKFILE1                Locate DCB work area\n         L     R1,=V(PDSR$C1)             -> Constants\n         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE1'\n         LA    R1,SORTRECL\n         STH   R1,DCBLRECL-IHADCB(R3)\n         MH    R1,=H'100'\n         STH   R1,DCBBLKSI-IHADCB(R3)\n         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n         B     CFDI$X\n*\n** Subroutine: Ensure that file in R8 is allocated\n*\nCFDI$FA  EQU   *\n         DEVTYPE (R8),DOUBLE              Get file information\n         LTR   R15,R15                    File allocated?\n         BZ    CFDI$FAX                   Yes, continue\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG82L,R15),MSG82-PDSR$MSG(R1) Move in message\n         MVC   MSG82L+1(8,R15),0(R8)      Get DDNAME\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         MVI   MAXCC,$SEVERE\nCFDI$FAX EQU   *\n         BSM   0,R7\n*\n** Common exit from Check_For_Duplicate_Initialization\n*\nCFDI$X   EQU   *\n         EJECT\n***********************************************************************\n***\n**       Process all DDNAMES which match the prefix\n***\n***********************************************************************\n         SPACE 2\nPROCESS_PDS EQU *\n*\n** Locate TIOT\n*\n         L     R9,PSATOLD-PSA             -> TCB\n         L     R9,TCBTIO-TCB(,R9)         -> TIOT\n         LA    R9,TIOENTRY-TIOT1(R9)      Locate first DD entry\n         OI    PP_FLAG1,$PP_F1TIOT        In TIOT processing mode\n         B     PP$TIOTS                   Start right\n*\n** Process TIOT entry\n*\nPP$TIOT  EQU   *\n         AR    R9,R8                      Bump to next DD entry\nPP$TIOTS EQU   *\n         SLR   R8,R8                      Set register to zero\n         ICM   R8,B'0001',TIOELNGH-TIOENTRY(R9) Get length of entry\n         BZ    PP$TIOTX                   None, end of the TIOT\n         LA    R15,PP_PDDN                Locate previous DDNAME\n         CLI   TIOEDDNM-TIOENTRY(R9),C' ' Blank DDNAME\n         BE    PP$TIOTC                   Yes, use previous\n         MVC   PP_PDDN(8),TIOEDDNM-TIOENTRY(R9) Save DDNAME\n         MVC   PP_PDDN+8(8),=CL8' '       Blank out concaten stuff\n         XC    PP_CCCNT(4),PP_CCCNT       Clear concatenation count\n         LA    R15,TIOEDDNM-TIOENTRY(R9)  Locate DDNAME to check\nPP$TIOTC EQU   *\n         SLR   R14,R14                    Clear register\n         IC    R14,PPC_DDPL               Get length of DD prefix\n         EX    R14,PP$TIOTZ               DDNAME Match?\n         BNE   PP$TIOT                    No, bump to next DD\n         MVC   PP_ADDN(8),TIOEDDNM-TIOENTRY(R9) Save DDNAME\n         B     PP$INIT\nPP$TIOTZ CLC   PPC_DDP(0),0(R15)\nPP$TIOTX DS    0H\n         NI    PP_FLAG1,255-$PP_F1TIOT    Turn off flag\n         ICM   R1,B'1111',PP_NLIBS        Any files meet prefix req?\n         BNZ   PP$TIOTXX                  Yes, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG18L,R15),MSG18-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\nPP$TIOTXX EQU  *\n*\n** LNKLST processing\n*\nPP$LNKLST EQU *\n         TM    PPC_FLAG2,$PPC_F2LNKLST    Need to do this one?\n         BNO   PP$LNKLSTX                 No, continue\n         OI    PP_FLAG1,$PP_F1LNKLST      Turn on flag\n         L     R1,=V(PDSR$PPC)            -> Constants CSECT\n         LA    R7,TPF_LNKLST+1-PDSR$PPC(R1)\n         L     R8,CVTPTR                  -> CVT\n         L     R8,CVTLLTA-CVTMAP(R8)      -> LNKLST datasets\n         L     R9,LLTCOUNT(R8)            Obtain number of entries\n         LA    R8,LLTENTRY(R8)            Locate first entry in list\n         BAS   R14,PP$LST_INIT\nPP$LNKLST_L EQU *\n         LA    R1,AREAJFCB\n         MVC   JFCBDSNM-INFMJFCB(44,R1),1(R8)\n         XC    JFCBVOLS-INFMJFCB(6,R1),JFCBVOLS-INFMJFCB(R1)\n         B     PP$INIT                    Continue\nPP$LNKLST_LB EQU *\n         LA    R8,45(R8)                  Locate next name in list\n         BCT   R9,PP$LNKLST_L             Process it\n         NI    PP_FLAG1,255-$PP_F1LNKLST  Turn off flag\nPP$LNKLSTX EQU *\n*\n** LPALST processing\n*\nPP$LPALST EQU *\n         TM    PPC_FLAG2,$PPC_F2LPALST    Need to do this one?\n         BNO   PP$LPALSTX                 No, continue\n         OI    PP_FLAG1,$PP_F1LPALST      Turn on flag\n         DA#SMODE 31                      Get into 31 bit mode\n         L     R1,=V(PDSR$PPC)            -> Constants CSECT\n         LA    R7,TPF_LPALST+1-PDSR$PPC(R1)\n         L     R8,CVTPTR                  -> CVT\n         L     R8,CVTSMEXT-CVTMAP(R8)     -> CVT storage extension\n         L     R8,CVTEPLPS-CVTVSTGX(R8)   -> E-PLPA start\n         L     R9,LPATCNT(R8)             Number of entries\n         LA    R8,LPATNTRY(R8)            Locate first entry\n         DA#SMODE 24                      Get into 24 bit mode\n         BAS   R14,PP$LST_INIT            Initialize for list\n         DA#SMODE 31                      Get into 31 bit mode\nPP$LPALST_L EQU *\n         LA    R1,AREAJFCB\n         MVC   JFCBDSNM-INFMJFCB(44,R1),1(R8)\n         XC    JFCBVOLS-INFMJFCB(6,R1),JFCBVOLS-INFMJFCB(R1)\n         DA#SMODE 24                      Get into 24 bit mode\n         B     PP$INIT                    Continue\nPP$LPALST_LB EQU *\n         DA#SMODE 31                      Get into 31 bit mode\n         LA    R8,45(R8)                  Locate next name in list\n         BCT   R9,PP$LPALST_L             Process it\n         DA#SMODE 24                      Get into 24 bit mode\n         NI    PP_FLAG1,255-$PP_F1LPALST  Turn off flag\nPP$LPALSTX EQU *\n         B     PP$X                       End of the line\n*\n** Intialize fields for access\n*\nPP$INIT  EQU   *\n         XC    PPD_CLR(PPD_CLRL),PPD_CLR  Clear fields\n         XC    SR_INIT(SR_INITL),SR_INIT  Initialize area for new PDS\n         MVI   PRR_TITLE1,0               Initialize\n         MVI   PRR_TITLE2,0               Initialize\n         STM   R8,R9,PP_REGS              Save registers\n*\n** Dataset summary - get ready for this new dataset\n*\n         L     R1,PP_DSUMA                Get address of area\n         L     R14,DSUMH_NUM-DSUMH(R1)    Get current count\n         LA    R14,1(R14)                 Bump to next one\n         ST    R14,DSUMH_NUM-DSUMH(R1)    Save current count\n*\n         L     R14,DSUMH_CURR-DSUMH(R1)   Get current entry\n         MVI   0(R14),C' '\n         MVC   1(DSUMEL,R14),0(R14)\n*\n** Fix up the DDNAME for concatenated/xxxLST files\n*\n         TM    PP_FLAG1,$PP_F1TIOT        TIOT mode?\n         BNO   PP$ADD                     No, do it\n         CLI   PP_ADDN,C' '               Concatenated DDNAME?\n         BNE   PP$ADDNX                   No, continue\nPP$ADD   EQU   *\n         LA    R15,PP_PDDN                Locate DDNAME\n         LA    R0,8                       Max length of DDNAME\nPP$ADDNL EQU   *\n         CLI   0(R15),C' '                End of DDNAME\n         BE    PP$ADDNLX                  Yes, continue\n         CLI   0(R15),C'('                Start of concaten stuff\n         BE    PP$ADDNLX                  Yes, continue\n         LA    R15,1(R15)                 Bump to next byte\n         BCT   R0,PP$ADDNL                Process it\nPP$ADDNLX EQU *\n         MVC   0(2,R15),=C'(+'            Insert concaten stuff\n         LA    R15,2(R15)                 Bump past it\n         L     R1,PP_CCCNT                Get concatenation count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PP_CCCNT                Save concatenation count\n         BAS   R9,EDITFWF                 Edit the number\n         MVI   0(R15),C')'                Insert suffix\nPP$ADDNX EQU   *\n*\n** Print that we are processing the DDNAME\n*\n         BAS   R14,CLEAR_RECOUT           Initialize the message area\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         BAS   R14,PRINT_SYSPRINT_RECORD\n*\n         TIME  BIN\n         ST    R0,DOUBLE\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG20L,R15),MSG20-PDSR$MSG(R1) Move in message\n         LA    R15,MSG20L+1(R15)\n         MVC   0(16,R15),PP_PDDN\n         LA    R0,16\n         BAS   R14,LOCATE_FIRST_SPACE\n         MVC   1(10,R15),=C'started at'\n         LA    R15,1+10(R15)\n         L     R1,DOUBLE\n         BAS   R14,CONVERT_BINARY_TIME    \" hh:mm:ss\"\n*        LA    R15,10(R15)                Bump past \" hh:mm:ss \"\n         BAS   R14,PRINT_SYSPRINT_RECORD\n*\n** Get the JFCB for this file\n*\n         TM    PP_FLAG1,$PP_F1TIOT        TIOT entry?\n         BNO   PP$JFCBX\n         L     R14,PP_TIOTEA              Locate TIOT entry\n         BAS   R9,LOCATE_JFCB             Locate the JFCB\n         LTR   R15,R15                    Found it?\n         BNZ   PP$JFCBS                   Yes, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG33L,R15),MSG33-PDSR$MSG(R1) Move in message\n         LA    R15,MSG33L(R15)            Bump past it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVI   LASTCC,$SEVERE             Set Condition Code\n         B     PP$PRTCC\nPP$JFCBS EQU   *\n         DA#SMODE 31                      JFCB may be above the line\n         MVC   AREAJFCB(JFCBLGTH),0(R15)  Retrieve copy of JFCB\n         DA#SMODE 24                      Back to 24 bit mode\nPP$JFCBX EQU   *\n*\n** Perform a locate for file\n*\nPP$LOCATE EQU *\n         TM    PP_FLAG1,$PP_F1TIOT        TIOT file\n         BO    PP$LOCATEX                 Yes, we already have volser\n*\n         L     R1,=V(PDSR$C1)             -> PDSR$C1 Csect\n         MVC   PARMLIST(C_LOCATEL),C_LOCATE-PDSR$C1(R1)\n         LA    R1,AREAJFCB+JFCBDSNM-INFMJFCB Locate DSN\n         ST    R1,PARMLIST+4              Save into parmeter list\n         LA    R1,W_AREA                  Locate the work area\n         ST    R1,PARMLIST+12             Save into parmeter list\n         LOCATE PARMLIST                  Get catalogue information\n         ST    R15,W_AREA                 Save return code\n         CLI   AREAJFCB+JFCBVOLS-INFMJFCB,0 Need Volume Serial?\n         BNE   PP$LOCATEX                 No, continue\n         LTR   R15,R15                    Catalogued?\n         BZ    PP$LOCATE_OK               Yes, continue\n*\n         LR    R8,R15                     Save return code\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG39L,R15),MSG39-PDSR$MSG(R1) Move in message\n         LA    R15,MSG39L(R15)            Bump past it\n         LR    R1,R8                      Get SVC 99 Return Code\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(6,R15),=C', DSN='\n         MVC   6(44,R15),AREAJFCB+JFCBDSNM-INFMJFCB\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print error message\n         MVI   LASTCC,$SEVERE             Set last condition code\n         B     PP$PRTCC                   Process next guy\n*\nPP$LOCATE_OK EQU *\n         MVC   AREAJFCB+JFCBVOLS-INFMJFCB(6),W_AREA+6\nPP$LOCATEX EQU *\n*\n** Print Volume and Dataset name\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG21L,R15),MSG21-PDSR$MSG(R1) Move in message\n         LA    R15,MSG21L(R15)            Bump past message\n         MVC   0(6,R15),AREAJFCB+JFCBVOLS-INFMJFCB Get Volume\n         LA    R15,6(R15)                 Bump past volume serial\n         MVC   0(6,R15),=C', DSN='        Insert text\n         LA    R15,6(R15)                 Bump past it\n         MVC   0(44,R15),AREAJFCB+JFCBDSNM-INFMJFCB Get DSN\n         ICM   R0,B'1111',W_AREA          LOCATE RC=0?\n         BNZ   PP$M21_UCX                 No, continue\n         CLC   W_AREA+6(6),AREAJFCB+JFCBVOLS-INFMJFCB Volumes match?\n         BE    PP$M21_UCX                 No, continue\n         LA    R0,44                      Max length\n         BAS   R14,LOCATE_FIRST_SPACE     Locate first space in DSN\n         MVC   0(15,R15),=C', catalogued to' Insert text\n         LA    R15,15+1(R15)              Bump past it\n         MVC   0(6,R15),W_AREA+6          Get catalogued version\n         LA    R15,6(R15)                 Bump past it\nPP$M21_UCX EQU *\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print error message\n*\n** Dynamically allocate the file\n*\n         TM    PP_FLAG1,$PP_F1TIOT        Processing the TIOT?\n         BNO   PP$DA                      No, must do DYNALLOC\n         ICM   R1,B'1111',PP_CCCNT        Get concatenation count\n         BZ    PP$DASDC                   None, no need to allocate\nPP$DA    EQU   *\n         MVI   DOUBLE2,#PDSR$DA$ADSN      Indicate allocate by DSNAME\n         L     R8,=V(PDSR$DA)             Locate CSECT\n         BASSM R9,R8                      Allocate volume\n         LTR   R15,R15                    Did we allocate the file?\n         BNZ   PP$DAE                     No, gripe 'bout it\n         L     R1,DOUBLE2                 Get Addr: Returned DDNAME\n         MVC   PP_ADDN(8),0(R1)           Get allocated DDNAME\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG38L,R15),MSG38-PDSR$MSG(R1) Move in message\n         LA    R15,MSG38L+1(R15)          Bump past it\n*\n         TM    PP_FLAG1,$PP_F1TIOT        TIOT mode?\n         BNO   PP$DASRCX\n         MVC   0(MSG38CL,R15),MSG38C-PDSR$MSG(R1) Move in message\n         LA    R15,MSG38CL+1(R15)          Bump past it\nPP$DASRCX EQU  *\n         MVC   0(7,R15),=C'DDNAME='\n         LA    R15,7(R15)\n         MVC   0(8,R15),PP_ADDN           Get returned DDNAME\n         LA    R15,9(R15)                 Bump past it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         B     PP$DASDCX\nPP$DAE   EQU   *\n         LR    R8,R15                     Save return code\n         MVC   AREADSCB(2),S99ERROR-S99RB(R4) Save error code\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG34L,R15),MSG34-PDSR$MSG(R1) Move in message\n         LA    R15,MSG34L(R15)            Bump past it\n         LR    R1,R8                      Get SVC 99 Return Code\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(7,R15),=C', INFO='       Set verbage\n         LA    R15,7(R15)                 Bump past it\n         UNPK  0(5,R15),AREADSCB(3)       **\n         MVZ   0(4,R15),ZEROS             *** Hex convert INFO\n         TR    0(4,R15),HEXTABLE          **\n         MVI   4(R15),C' '                Fix byte\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVI   LASTCC,$SEVERE             Set Condition Code\n         B     PP$PRTCC\n*\n** Check for unsupported file types\n*\nPP$DASDC EQU   *\n         DEVTYPE PP_ADDN,DOUBLE           Get file information\n         CLC   DOUBLE(8),ZEROS            DUMMY?\n         BE    PP$DUM                     Yes, print error\n         CLC   DOUBLE(8),=X'00,00,01,01,00,00,7F,F8' TSO?\n         BE    PP$TSO                     Yes, print error\n         CLC   DOUBLE(4),=X'00,00,01,02,00,00,7F,F8' SYSIN/SYSOUT?\n         BNE   PP$DUMX                    No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG27L,R15),MSG27-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         MVI   LASTCC,$WARN\n         B     PP$NEXT\nPP$TSO   EQU   *\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG29L,R15),MSG29-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         MVI   LASTCC,$WARN\n         B     PP$NEXT\nPP$DUM   EQU   *\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG28L,R15),MSG28-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         MVI   LASTCC,$WARN\n         B     PP$NEXT\nPP$DUMX EQU    *\n*\n** Ensure that file is on a DASD device - DEVTYPE returned UCBTYP in\n** first fullword of DOUBLE\n*\n         TM    DOUBLE+2,UCB3DACC          Direct Access Device?\n         BO    PP$DASDCX                  Yes, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG43L,R15),MSG43-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         MVI   LASTCC,$WARN\n         B     PP$NEXT\nPP$DASDCX EQU *\n*\n** Create the DCB to read the directory\n*\n         LA    R3,SYSLIB                  Locate DCB work area\n         L     R1,=V(PDSR$C1)\n         MVC   0(C_DCBDL,R3),C_DCBD-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),PP_ADDN Get DDNAME\n*\n         LA    R1,PPD$X                   Locate for End-of-File (BSAM)\n         STCM  R1,B'0111',DCBEODAD-IHADCB+1(R3) Save into DCB\n         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit\n*\n** Obtain format 1 DSCB\n*\n         L     R1,=V(PDSR$C1)             -> PDSR$C1 Csect\n         MVC   PARMLIST(C_VTOCSL),C_VTOCS-PDSR$C1(R1)\n         LA    R14,AREAJFCB               -> JFCB\n         LA    R1,JFCBDSNM-INFMJFCB(R14)  Locate Data set Name\n         ST    R1,PARMLIST+4\n         LA    R1,JFCBVOLS-INFMJFCB(R14)  Locate Volume Serial\n         ST    R1,PARMLIST+8\n         LA    R1,AREADSCB                Locate return area for DSCB\n         ST    R1,PARMLIST+12\n         OBTAIN PARMLIST                  Locate F1-DSCB for dataset\n         LTR   R15,R15                    Successfull?\n         BZ    PP$DSCB1X                  Yes, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG23L,R15),MSG23-PDSR$MSG(R1) Move in message\n         LA    R15,MSG23L(R15)            Bump past it\n         MVC   0(6,R15),AREAJFCB+JFCBVOLS-INFMJFCB\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVI   LASTCC,$SEVERE             Fix condition code\n         B     PP$NEXT                    Bump to next dataset\nPP$DSCB1X EQU *\n*\n** Dump DSCB\n*\n         TM    PPC_FLAG2,$PPC_F2DUMPDSCB  Option on?\n         BNO   PP$DDSCBX                  No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG45L,R15),MSG45-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message\n         XC    W_AREA(CMXDL),W_AREA       Initialize area\n         LA    R15,AREADSCB               Locate directory entry\n         LA    R0,L'AREADSCB              Get length of directory ent.\n         LA    R1,RECOUT+MSGPREL+8        \"RPA045I > \"\n         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output\n         LA    R1,DS1FMTID-IECSDSF1       First field past DSN\n         ST    R1,W_AREA+CMXD_OFFSET-CMXD Set starting offset\n         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?\n         BO    PP$DDSCBL\n         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(#MXDWIDE)\nPP$DDSCBL EQU  *\n         LA    R1,W_AREA                  Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         LR    R8,R15                     Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD  Locate print routine\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   PP$DDSCBL                  Thank you: May I have another\nPP$DDSCBX EQU *\n*\n** Validate Dataset organization as Partitioned Data Set (PDS)\n*\n         LA    R1,AREADSCB                Locate DSCB\n         TM    DS1DSORG-DS1FMTID(R1),DS1DSGPO PDS?\n         BO    PP$POX                     Yes, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG24L,R15),MSG24-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message\n         MVI   LASTCC,$WARN               Set condition code\n         B     PP$NEXT                    Process next file\nPP$POX   EQU   *\n*\n** Check for RECFM type and start ISPF processing for RECFM not U\n*\n         TM    DS1RECFM-DS1FMTID(R1),DS1RECFU Load Library\n         BO    PP$RFU                     Yes, do it\n*\n         OI    PPD_FLAG1,$PPD_F1ISPF      Set flag\n         MVI   SR_FLAG1,$PPD_F1ISPF       ISPF type...\n*\n         CLI   PRR_IHEAD1,0               First time through here?\n         BNE   PP$RFX                     No, continue\n         LA    R0,#IS_HEADINGS            Option: Create headings\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$IS)            Locate CSECT\n         BASR  R14,R15                    Invoke the parse routine\n*-Read in BKLIDS file\n         TM    PPD_FLAG1,$PPD_F1RBF       Already did this?\n         BO    PP$RFX                     Yep, continue\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$RBF)           Read BKLIDS file\n         BASR  R14,R15                    Call routine\n         OI    PPD_FLAG1,$PPD_F1RBF       Set flag\n         B     PP$RFX\n*\n** Set up for this new load library\n*\nPP$RFU   EQU   *\n         AIF   ('&IHADFARELS' LT '01010100').RCMNX\n         ICM   R8,B'1111',A_PDSRCMD+4     Locate area\n         BZ    PP$RFU$CMX                 None\n*\n         LA    R1,AREAJFCB+JFCBDSNM-INFMJFCB  Locate DSNAME\n         ST    R1,PDSRCMD_DSNAME-PDSRCMD(R8)\n         LA    R1,AREAJFCB+JFCBVOLS-INFMJFCB  Locate volser\n         ST    R1,PDSRCMD_VOLSER-PDSRCMD(R8)\n*\n         LA    R1,PP_ADDN\n         LA    R0,L'PP_ADDN-1\n         LA    R14,1\nPP$RFU$CM$ILL DS 0H\n         CLI   0(R1),C' '\n         BE    PP$RFU$CM$ILLX\n         LA    R14,1(R14)\n         LA    R1,1(R1)\n         BCT   R0,PP$RFU$CM$ILL\nPP$RFU$CM$ILLX DS 0H\n         STH   R14,PDSRCMD_INCLLIB-PDSRCMD(R8)\n         MVC   PDSRCMD_INCLLIB+2-PDSRCMD(8,R8),PP_ADDN\n*\n         LR    R1,R8                      Locate work area\n         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_LIBS Set option\n         L     R15,=V(PDSRCM)             Locate routine\n         BASR  R14,R15                    Call routine\nPP$RFU$CMX DS  0H\n.RCMNX   ANOP  ,\n*\n         L     R1,=V(PDSR$C1)\n         LA    R3,PPD_PODCB               Locate DCB\n         MVC   0(C_DCBPOL,R3),C_DCBPO-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),PP_ADDN Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)\n         OPEN  ((3),(INPUT)),             Open the directory           @\n               MF=(E,PARMLIST)            ..Parameter List\n***>     LTR   R15,R15\n***>     BZ    ....\n*\n         OI    PPD_FLAG1,$PPD_F1LOAD\n         OI    W_FLAG1,$W_F1LOADLIB\n         MVI   SR_FLAG1,$PPD_F1LOAD       Load library type\n*\n         L     R1,=V(PDSR$C1)\n         MVC   PLM_DECB(C_DECBML),C_DECBM-PDSR$C1(R1)\n*\n         LA    R0,#LMF_HEADINGS           Option: Create headings\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$LMF)           Locate CSECT\n         BASR  R14,R15                    Invoke the parse routine\n*\n** Perform check to see if this library is APF authorized\n**\n** At MVS 4.3 and higher, datasets in the LPALST do not have to be\n** in the APFLST at IPL time.  Before MVS 4.3, datasets could only\n** get into the LPALST by being in the APFLST. If we find a dataset\n** in the LPALST that is not in the APFLST:\n**\n** - We will consider that the library is authorized for processing\n**   sake.\n** - We will print a warning message for systems before MVS 4.3.\n*\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$APF)           Locate CSECT\n         BASR  R14,R15                    Call routine\n         TM    PPD_FLAG1,$PPD_F1APF       Was it APF authorized?\n         BO    PP$RFMSG                   No, continue\n         TM    PP_FLAG1,$PP_F1LPALST      Processing the LPALST?\n         BNO   PP$RFX                     No, leave\n         OI    PPD_FLAG1,$PPD_F1APF       LPALST is always APF...\n*-Should get here for one or both of these reasons:\n* -The LPALST dataset was removed from the APFLST after the IPL by\n*  Omegamon (or other non-IBM program) or via SETPROG\n* -On MVS 4.3 and higher and dataset is in LPALST and not APFLST\n*  and was considered APF authorized for NIP processing so let's\n*  don't brag about it.\n         CLC   W_BCPLEVEL(5),=C'SP4.3'    At MVS 4.3 or higher?\n         BNL   PP$RFX                     Yes, skip warning message\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG58L,R15),MSG58-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         B     PP$RFX\nPP$RFMSG DS    0H\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG57L,R15),MSG57-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nPP$RFX   DS    0H\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Open and process the library\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Increment library count\n*\n         L     R1,PP_NLIBS                Get number of libraries\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PP_NLIBS                Save for later\n*\n** Open directory\n*\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)\n         LA    R3,SYSLIB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\n         BAS   R14,PP$CHECK_OPEN_ABEND    Check for Abend\n*\n** Print dataset allocation information\n**\n** The code to get the allocated number of tracks was\n** modeled after a 24-Sep-1997 post on comp.lang.asm370\n** by Steve Myers (smyers@popmail.voicenet.com) - Thanks Steve.\n*\n         SLR   R0,R0\n         SLR   R14,R14\n         L     R1,DCBDEBAD-IHADCB(R3)\n         IC    R0,DEBNMEXT-DEBBASIC(R1)\n         LA    R1,DEBBASND-DEBBASIC(R1)\nPP$ATRKL DS    0H\n         AH    R14,DEBNMTRK-DEBDASD(R1)\n         LA    R1,DEBDASDE-DEBDASD(R1)\n         BCT   R0,PP$ATRKL\n         ST    R14,PPD_TRKA               Save num of allocate tracks\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG62L,R15),MSG62-PDSR$MSG(R1) Move in message\n         LA    R15,MSG62L(R15)\n         L     R1,PPD_TRKA\n         BAS   R9,EDITNCF                 Edit it\n*\n         MVC   0(7,R15),=C', used='\n         LA    R15,7(R15)\n         LA    R14,AREADSCB               Locate DSCB\n         LH    R1,DS1LSTAR-DS1FMTID(R14)  Load tracks used\n         N     R1,=X'0000FFFF'            Turn off high order bytes\n         AH    R1,=H'1'                   Fludge upwards.\n         BAS   R9,EDITNCF                 Edit it\n*\n         MVC   0(10,R15),=C', extents='\n         LA    R15,10(R15)\n         LA    R14,AREADSCB               Locate DSCB\n         SR    R1,R1\n         IC    R1,DS1NOEPV-DS1FMTID(R14)  Get extents\n         BAS   R9,EDITNCF                 Edit # of extents for file\n*\n         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message\n*\n** Open Library for member processing\n*\n         LA    R3,SYSMEM                  Locate Member DCB\n         L     R1,=V(PDSR$C1)\n         MVC   0(C_DCBML,R3),C_DCBM-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),PP_ADDN\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)\n         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\n         BAS   R14,PP$CHECK_OPEN_ABEND    Check for Abend\n*\n** Obtain buffer for Member read\n*\n         LA    R1,SYSMEM                  -> DCB\n         ICM   R0,B'1111',PP_PDSBUF       Get length of previous buffer\n         BZ    PP$OB                      No buffer available...\n         CH    R0,DCBBLKSI-IHADCB(R1)     Got enough?\n         BNL   PP$OBX                     Yes, use it\n         L     R1,PP_PDSBUF+4             Get buffer length and address\n         FREEMAIN R,LV=(0),A=(1)          Free PDS buffer\nPP$OB    EQU   *\n         LA    R1,SYSMEM                  -> DCB\n         SLR   R0,R0                      Zero register\n         ICM   R0,B'0011',DCBBLKSI-IHADCB(R1) Obtain blocksize\n         GETMAIN R,LV=(0)                 Request storage for buffer\n         STM   R0,R1,PP_PDSBUF            Save length and address\nPP$OBX   EQU   *\n*\n** Initialize fields\n*\n         MVC   PP_OTCP(4),PP_OT+4         Set first entry of table\n*\n** Open the report file\n*\n         TM    W_FLAG1,$W_F1REPORT        Report file opened?\n         BO    PP$REPORTX                 Yes, continue\n         OI    W_FLAG1,$W_F1REPORT        Report file opened?\n         LA    R3,REPORT                  Locate DCB work area\n         L     R1,=V(PDSR$C1)\n         MVC   0(C_DCBOL,R3),C_DCBO-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'REPORT'\n         MVC   PARMLIST(C_LSTOL),C_LSTO-PDSR$C1(R1)\n         BAS   R14,SET_ABEND_EXIT         Set up ABEND exit\n         OPEN  ((3),(OUTPUT)),MF=(E,PARMLIST)\n         LA    R8,=CL8'REPORT'            Locate file\n         BAS   R14,CHECK_OPEN_ABEND       Check for Abend\n         LA    R1,255                     Get excessive count\n         STC   R1,PRR_LC                  ..force heading\nPP$REPORTX EQU *\n*\n** Simulate mode\n**\n** We do everything, including open, but do not process the directory\n*\n         TM    PPC_FLAG1,$PPC_F1SIMULATE  Stimulate mode?\n         BNO   PP$OSIMX                   Yes, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG44L,R15),MSG44-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         B     PP$CLOSE\nPP$OSIMX EQU   *\n*\n** Initialize report line count and process the PDS directory\n*\n         LA    R1,99                      Set excessive count\n         STC   R1,PRR_LC                  Force new heading\n         BAS   R14,PROCESS_PDS_DIRECTORY  Process the PDS directory\n*\n** Close PDS files\n*\nPP$CLOSE  EQU   *\n         LA    R3,SYSMEM\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?\n         BNO   PP$CSMX\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\nPP$CSMX  EQU   *\n         LA    R3,SYSLIB\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?\n         BNO   PP$CSLX\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\nPP$CSLX  EQU   *\n         LA    R3,PPD_PODCB               Locate the DCB\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?\n         BNO   PP$CSPX\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close the file\nPP$CSPX  EQU   *\n*\n** Simulate mode\n*\n         TM    PPC_FLAG1,$PPC_F1SIMULATE  Stimulate mode?\n         BO    PP$NEXT                    Yes, skip stats\n*\n** Check for APF library error\n*\n         ICM   R1,B'1111',PPD_NAPF\n         BZ    PP$APFX\n         BAS   R14,FORMAT_MESSAGE\n         MVC   0(MSG31L,R15),MSG31-PDSR$MSG(R1) Move in message\n         LA    R15,MSG31L+1(R15)\n         L     R1,PPD_NAPF\n         BAS   R9,EDITFWF\n         L     R1,=V(PDSR$MSG)\n         MVC   1(MSG31AL,R15),MSG31A-PDSR$MSG(R1) Move in message\n         TM    PP_FLAG1,$PP_F1LNKLST      Processing the LNKLST?\n         BNO   PP$APFPM                   Yes, bypass: all are auth\n         LA    R15,1+MSG31AL+1(R15)\n         MVC   0(MSG31BL,R15),MSG31B-PDSR$MSG(R1) Move in message\nPP$APFPM EQU   *\n         BAS   R14,PRINT_SYSPRINT_RECORD\nPP$APFX  EQU   *\n*\n** Print directory block information\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG22L,R15),MSG22-PDSR$MSG(R1) Move in message\n         LA    R15,MSG22L+1(R15)          Bump past it\n         L     R1,PPD_DIRBLKS             Number of members\n         S     R1,PPD_DIRBLKSU            - Unused = Used\n         BAS   R9,EDITFWF                 Edit it\n         MVC   1(6,R15),=C'out of'        Insert text\n         LA    R15,1+6+1(R15)             Bump past it\n         L     R1,PPD_DIRBLKS             Number of members\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print it\n*\n** Print number of members\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG26L,R15),MSG26-PDSR$MSG(R1) Move in message\n         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?\n         BNO   PP$NMF                     No, need flush EDITFWF\n*-Following two lines commented out on 14-APR-1997\n****     TM    PPC_FLAG1,$PPC_F1CSECT     CSECT mode?\n*****    BO    PP$NML                     No, move on\nPP$NMF   EQU   *\n         LA    R15,MSG26L+1(R15)          Bump past it\n         L     R1,PPD_NMEM                Number of members\n         BAS   R9,EDITFWF                 Edit it\n         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?\n*-Whatever are we doing here - I need to spend some more time here...\n         BO    PP$NM_LWEX    (WhatEver)   Yes, CSECT mode...\n         B     PP$NM_LEX                  No, ISPF mode...\nPP$NML   EQU   *\n         LA    R15,MSG26SL(R15)           Bump to start\n         L     R1,PPD_NMEM                Number of members\n         CVD   R1,DOUBLE                  Convert number to packed\n         MVC   0(6,R15),=X'40,20,20,20,20,20'\n         ED    0(6,R15),DOUBLE+5\n         OI    0(R15),C'0'\n         LA    R15,PPTTR_COUNTE-PPTTR(R15) Bump past number\nPP$NM_LWEX DS 0H\n*\n         ICM   R1,B'1111',PPD_NEX         Get number of Non-Execute m.\n         BZ    PP$NM_LNEXX\n         L     R14,=V(PDSR$C1)            -> Constants CSECT\n         MVC   0(L'C_NMNE,R15),C_NMNE-PDSR$C1(R14)\n         LA    R15,L'C_NMNE(R15)\n         BAS   R9,EDITFWF\nPP$NM_LNEXX EQU *\n*\n         ICM   R1,B'1111',PPD_NLERR       Get number of Load Errors\n         BZ    PP$NM_LEX\n         L     R14,=V(PDSR$C1)\n         MVC   0(L'C_NMLE,R15),C_NMLE-PDSR$C1(R14)\n         LA    R15,14(R15)\n         BAS   R9,EDITFWF\nPP$NM_LEX EQU *\n         BAS   R14,PRINT_SYSPRINT_RECORD\n*\n         L     R1,PP_TMEM                Get total number of members\n         A     R1,PPD_NMEM               Add total for this library\n         ST    R1,PP_TMEM                Save total\n*\n** Print the number of COBOL CICS errors we found\n*\n         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?\n         BNO   PP$COBCNX                  No, skip this\n         TM    PPC_FLAG3,$PPC_F3COBCRPT   Doing it?\n         BNO   PP$COBCNX                  No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG47L,R15),MSG47-PDSR$MSG(R1) Move in message\n         LA    R15,MSG47L+1(R15)          Bump past it\n         L     R1,PPD_NUMCOBCE            Number of std eye catchers\n         BAS   R9,EDITFWF                 Edit number\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print record\nPP$COBCNX DS   0H\n*\n** Print the number of standard Eyecatchers we found\n*\n         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?\n         BNO   PP$ECNX                    No, skip this\n         TM    PPC_FLAG3,$PPC_F3ECRPT     Doing it?\n         BNO   PP$ECNX                    No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG42L,R15),MSG42-PDSR$MSG(R1) Move in message\n         LA    R15,MSG42L+1(R15)          Bump past it\n         L     R1,PPD_NUMEC               Number of std eye catchers\n         BAS   R9,EDITFWF                 Edit number\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print record\nPP$ECNX  DS    0H\n*\n** Print trivia that the binder found\n*\n         AIF   ('&IHADFARELS' LT '01010100').RCMLEX\n         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?\n         BNO   PP$TRTX                    No, skip this\n         ICM   R1,B'1111',A_PDSRCMD+4     Locate area\n         BZ    PP$TRTX                    Looks like don't need it\n         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_LIBE Set option\n         L     R15,=V(PDSRCM)             Locate routine\n         BASR  R14,R15                    Call routine\nPP$TRTX  DS    0H\n.RCMLEX  ANOP  ,\n*\n** Print the number of zapped modules found (only pre-DFSMS/MVS)\n*\n         TM    PPD_FLAG1,$PPD_F1LOAD      Processed a Load Library?\n         BNO   PP$ZAPNX                   No, skip this\n         TM    W_FLAG1,$W_F1DFSMS         We are DFSMS/MVS!\n         BO    PP$ZAPNX                   No, continue\n         TM    PPC_FLAG3,$PPC_F3ZAPRPT    Doing it?\n         BNO   PP$ZAPNX                   No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG46L,R15),MSG46-PDSR$MSG(R1) Move in message\n         LA    R15,MSG46L+1(R15)          Bump past it\n         L     R1,PPD_NUMZAP              Number of std eye catchers\n         BAS   R9,EDITFWF                 Edit number\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print record\nPP$ZAPNX DS    0H\n*\n** Process aliases found\n*\n         ICM   R8,B'1111',PPD_NALIAS      Get number of aliases\n         BZ    PP$PALX                    None, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG35L,R15),MSG35-PDSR$MSG(R1) Move in message\n         LA    R15,MSG35L+1(R15)          Bump past it\n         LR    R1,R8                      Get number of aliases\n         BAS   R9,EDITFWF                 Edit number\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print record\n         CLC   PP_OT+4(4),PP_OTCP         Any orphans found?\n         BE    PP$PALX                    No, continue\n         L     R7,PP_OT+4                 Get first entry address\nPP$PALL  EQU   *\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG36L,R15),MSG36-PDSR$MSG(R1) Move in message\n         LA    R15,MSG36L+1(R15)          Bump past it\n         DA#SMODE 31                      Get into 31 bit mode\n         MVC   0(8,R15),ORPT_ANAME-ORPT(R7) Get alias name\n         BAS   R14,ENSURE_PRINTABLE_MEMNAME Ensure good member name\n         LA    R0,#EPML                   Max length of member name\n*-If it is flush, then they don't line up! Changed on 25-NOV-1996\n*        BAS   R14,LOCATE_FIRST_SPACE     Locate first space\n         LA    R15,8(R15)\n         MVC   1(7,R15),=C'at TTR='\n         LA    R15,1+7(R15)               Bump past it\n         UNPK  0(7,R15),ORPT_ATTR-ORPT(4,R7)\n         MVZ   0(6,R15),ZEROS\n         TR    0(6,R15),HEXTABLE\n         LA    R15,6(R15)                 Bump past TTR\n         MVC   0(9,R15),=C' alias of'     Insert Text\n         LA    R15,10(R15)                Bump past it\n         MVC   0(8,R15),ORPT_RNAME-ORPT(R7) Get real member name\n         BAS   R14,ENSURE_PRINTABLE_MEMNAME Ensure good member name\n         LA    R0,#EPML                   Bump past it\n*-If it is flush, then they don't line up! Changed on 25-NOV-1996\n*        BAS   R14,LOCATE_FIRST_SPACE     Locate first Space\n         LA    R15,8(R15)\n         CLC   ORPT_RTTR-ORPT(3,R7),ZEROS Really-out-there orphan?\n         BE    PP$PALB                    Yes, supposed to be diff.\n         CLC   ORPT_ATTR-ORPT(3,R7),ORPT_RTTR-ORPT(R7) Match?\n         BE    PP$PALB                    Yes, skip it\n         LA    R0,8                       Max length of member name\n         BAS   R14,LOCATE_FIRST_SPACE     Locate first space\n         MVC   1(7,R15),=C'at TTR='\n         LA    R15,1+7(R15)               Bump past it\n         UNPK  0(7,R15),ORPT_RTTR-ORPT(4,R7)\n         MVZ   0(6,R15),ZEROS\n         TR    0(6,R15),HEXTABLE\n         LA    R15,6(R15)                 Bump past TTR\n         L     R1,=V(PDSR$C1)\n         MVC   0(L'C_PPTTR,R15),C_PPTTR-PDSR$C1(R1)\nPP$PALB  EQU   *\n         LA    R7,ORPTL(R7)               Bump to next entry\n         DA#SMODE 24                      Get back into 24 bit mode\n         BAS   R14,PRINT_SYSPRINT_RECORD  print message\n         C     R7,PP_OTCP                 Hit max?\n         BL    PP$PALL                    No, process next one\n*\n         BAS   R14,CLEAR_RECOUT           Initialize the message area\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print blank line\nPP$PALX  EQU   *\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Print footing information on report file\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG1,$PPC_F1DATONLY   Do report footing?\n         BO    PP$FOOTX                   No, move on\n         TM    PPC_FLAG1,$PPC_F1NODET     Do detail records?\n         BO    PP$FOOTX                   No, move on\n         ICM   R1,B'1111',PPD_NMEM        Any Members?\n         BZ    PP$FOOTX                   No, continue\n         NI    PPD_FLAG1,255-$PPD_F1NEWHEAD\n*\n** Print delimiter line\n*\n         MVI   RECOUT+1,C'-'              Get dash\n         MVC   RECOUT+2(131),RECOUT+1     ..Propagate it\n         BAS   R14,PRINT_REPORT_RECORD\n*\n** Print totals line\n*\n         BAS   R14,CLEAR_RECOUT\n         LA    R15,RECOUT+1\n         TM    PPD_FLAG1,$PPD_F1LOAD      Load library?\n         BNO   PP$FT_SPF                  No, ISPF thang\n*\n*-Commented out this code which doesn't print a valid totals length\n*-for the load library. Need to find out what is zeroing out PPD_SIZE\n*-for load libraries (ispf seems to be fine). 29-apr-1997\n AGO .LENERRX\n         UNPK  DET_LSIZE-2-DET(9,R15),PPD_SIZE(5)\n         MVZ   DET_LSIZE-2-DET(8,R15),ZEROS\n         TR    DET_LSIZE-2-DET(8,R15),HEXTABLE\n         MVI   DET_LSIZE+6-DET(R15),C' '\n         BAS   R14,PRINT_REPORT_RECORD\n.LENERRX ANOP ,\n         B     PP$FT_SPFX                 No, ISPF thang\nPP$FT_SPF EQU *\n         MVC   DETMEM-DET(7,R15),=C'Totals:'\n         L     R1,PPD_SIZE\n         CVD   R1,DOUBLE\n         MVC   DET_ISIZE-DET(6,R15),=X'40,20,20,20,20,20'\n         ED    DET_ISIZE-DET(6,R15),DOUBLE+5\n         L     R1,PPD_IINIT\n         CVD   R1,DOUBLE\n         MVC   DET_IINIT-DET(6,R15),=X'40,20,20,20,20,20'\n         ED    DET_IINIT-DET(6,R15),DOUBLE+5\n         L     R1,PPD_IMODL\n         CVD   R1,DOUBLE\n         MVC   DET_IMODL-DET(6,R15),=X'40,20,20,20,20,20'\n         ED    DET_IMODL-DET(6,R15),DOUBLE+5\n         BAS   R14,PRINT_REPORT_RECORD\nPP$FT_SPFX EQU *\n*\n** Print number of members\n*\n         BAS   R14,CLEAR_RECOUT\n         BAS   R14,PRINT_REPORT_RECORD\n         L     R1,=V(PDSR$MSG)\n         LA    R15,RECOUT+1\n         MVC   0(L'MSG26NOM,R15),MSG26NOM-PDSR$MSG(R1)\n         LA    R15,L'MSG26NOM+1(R15)\n         L     R1,PPD_NMEM\n         BAS   R9,EDITFWF\n         BAS   R14,PRINT_REPORT_RECORD\nPP$FOOTX EQU *\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Bump to next file to process\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\nPP$NEXT  EQU   *\n*\n** Dataset summary - get ready for the next dataset\n*\n         SLR   R0,R0                      R0 is not currently used\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$DSP)           Locate CSECT\n         BASR  R14,R15                    Invoke the parse routine\n*\n** Free Dynamically allocated File\n*\n         TM    PP_FLAG1,$PP_F1TIOT        TIOT file?\n         BNO   PP$FDAF                    No, always free it\n         ICM   R1,B'1111',PP_CCCNT        Get concatenation count\n         BZ    PP$NFDDX                   Not zero, skip check\nPP$FDAF  EQU   *\n         MVI   DOUBLE2,#PDSR$DA$FDD       Indicate free by DDNAME\n         L     R8,=V(PDSR$DA)             Locate CSECT\n         BASSM R9,R8                      Allocate volume\n         LTR   R15,R15                    Did we allocate the file?\n         BZ    PP$NFDDX                   No, gripe 'bout it\n         LR    R8,R15                     Save return code\n         MVC   AREADSCB(2),S99ERROR-S99RB(R4) Save error code\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG37L,R15),MSG37-PDSR$MSG(R1) Move in message\n         LA    R15,MSG37L(R15)            Bump past it\n         MVC   0(8,R15),PP_ADDN           Get returned DDNAME\n         LA    R15,8(R15)                 Bump past it\n         MVC   0(5,R15),=C', RC='         Insert text\n         LA    R15,5(R15)                 Bump past text\n         LR    R1,R8                      Get DYNALLOC return code\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(8,R15),=C', Error='      Insert text\n         UNPK  8(5,R15),AREADSCB(3)\n         MVZ   8(4,R15),ZEROS\n         TR    8(4,R15),HEXTABLE\n         MVI   8+4(R15),C' '\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nPP$NFDDX EQU   *\n*\n** Print Last condition code\n*\nPP$PRTCC EQU   *\n         BAS   R14,FORMAT_MESSAGE         Initialize RECOUT to blanks\n         MVC   0(MSG90L,R15),MSG90-PDSR$MSG(R1) Move in message\n         LA    R15,MSG90L+1(R15)          Bump past it\n         SLR   R1,R1                      Clear register\n         IC    R1,LASTCC                  Get condition code\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         CLC   MAXCC(1),LASTCC            Need to put higher c.c.\n         BH    PP$LCCX                    No, move on\n         MVC   MAXCC(1),LASTCC            Save condition code\nPP$LCCX  EQU   *\n         MVI   LASTCC,0                   Reset condition code\n*\n** Print a blank line\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n** Locate to next file to process\n*\n         LM    R8,R9,PP_REGS              Restore registers\n         TM    PP_FLAG1,$PP_F1TIOT        TIOT mode?\n         BO    PP$TIOT                    Yes, continue\n         TM    PP_FLAG1,$PP_F1LNKLST      LNKLST mode?\n         BO    PP$LNKLST_LB               Yes, continue\n         TM    PP_FLAG1,$PP_F1LPALST      LPALST mode?\n         BO    PP$LPALST_LB               Yes, continue\n         B     PP$X                       Leave (Should not happen)\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Misc subroutines for Process_PDS\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Print Message 19 - R8 has type of processing\n*\nPP$LST_INIT EQU *\n         ST    R14,PP_REGS                Save return address\n         ST    R9,PP_REGS+4               Save register\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize message area\n         MVC   0(MSG19L,R15),MSG19-PDSR$MSG(R1) Move in message\n         LA    R15,MSG19L+1(R15)          Bump past it\n         MVC   0(6,R15),0(R7)             Get \"LNK/LPA\"\n         MVC   6(L'MSG19N,R15),MSG19N-PDSR$MSG(R1)\n         LA    R15,6+L'MSG19N+1(R15)      Bump past it\n         L     R1,PP_REGS+4               Get number in list\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         XC    AREAJFCB(L'AREAJFCB),AREAJFCB\n         MVC   PP_PDDN(6),0(R7)           Get type\n         MVC   PP_PDDN+6(2),=C'  '        Ensure trailing blank\n         MVC   PP_ADDN(8),=CL8' '         Blank it out\n         MVC   PP_PDDN+8(8),=CL8' '       Blank it out\n         L     R1,=F'-1'                  Start out as \"+0\"\n         ST    R1,PP_CCCNT                Get concatenation count\n*\n         L     R9,PP_REGS+4               Restore register\n         L     R14,PP_REGS                Save return address\n         BSM   0,R14\n*\n** Check for open abend\n*\nPP$CHECK_OPEN_ABEND EQU *\n         CLC   OX_CODE(4),ZEROS           Open failed?\n         BNE   PP$COAS                    Yes, forget it\n         LTR   R15,R15                    Open okay?\n         BNZ   PP$COAS                    Yes, move on\n         BSM   0,R14\nPP$COAS  EQU   *\n         ST    R15,DOUBLE                 Save OPEN return code\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG41L,R15),MSG41-PDSR$MSG(R1) Move in message\n         LA    R15,MSG41L+1(R15)          Bump past it\n         LA    R8,PP_ADDN                 Locate DDNAME\n         BAS   R14,FORMAT_OPEN_ABEND_MSG  Format error msg\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVI   LASTCC,20                  Set Condition code\n         B     PP$CLOSE\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  Common exit from Process_TIOT_Entries\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPP$X     EQU   *\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n** Print error message about APF\n*\n         TM    W_FLAG1,$W_F1APFLSTD       Did we find error?\n         BNO   PP$APFEX                   No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize RECOUT to blanks\n         MVC   0(MSG91L,R15),MSG91-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\nPP$APFEX DS    0H\n*\n** Print LNKLST information\n*\n         TM    PPC_FLAG2,$PPC_F2LNKLST    Need to do this one?\n         BNO   PP$LLTX                    No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG63L,R15),MSG63-PDSR$MSG(R1) Move in message\n         LA    R15,MSG63L+1(R15)          Bump past it\n         L     R1,PP_DSUMA                Locate area\n         L     R1,DSUMH_LLE-DSUMH(R1)     Get number of LNKLST extents\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nPP$LLTX  DS    0H\n*\n** Print number of libraries processed\n*\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG998L,R15),MSG998-PDSR$MSG(R1) Move in message\n         LA    R15,MSG998L+1(R15)         Bump past it\n         L     R1,PP_NLIBS                Get number of libraries\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(20,R15),=C', members processed:' Add text\n         LA    R15,20+1(R15)              Bump past it\n         L     R1,PP_TMEM                 Get total members\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n*\n** If we are doing find member processing, print totals\n*\n         SPACE 2\n         TM    PPC_IFLAG1,$PPC_IF1FMG     Was it generic?\n         BO    PP$FMG\n         CLI   PPC_FML,0                  Doing find member checking?\n         BE    PP$FMX                     No, leave\nPP$FMG   DS    0H\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG54L,R15),MSG54-PDSR$MSG(R1) Move in message\n         MVC   MSG54N-MSG54(8,R15),PPC_FM Get member name\n         ICM   R0,B'1111',PP_FMCOUNT      Get count\n         BZ    PP$FM0\n         LA    R15,MSG54L(R15)\n         LR    R1,R0\n         BAS   R9,EDITFWF\n         MVC   1(5,R15),=C'times'\n         B     PP$FM0X\nPP$FM0   DS    0H\n         MVC   MSG54E-MSG54(4,R15),=C'not '\n         LA    R15,MSG54E+4-MSG54(R15)\n         MVC   0(5,R15),MSG54E-PDSR$MSG(R1)\nPP$FM0X  DS    0H\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nPP$FMX   DS    0H\n         EJECT ,\n***********************************************************************\n***\n**       Check for Duplicates / Member Cross references\n***\n***********************************************************************\n         SPACE 2\nCHECK_FOR_DUPLICATES EQU *\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member Cross reference?\n         BO    CFD$S                      Yes, do it\n         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates?\n         BNO   CFD$X                      No, continue\nCFD$S    EQU   *\n*\n** Close input sort file\n*\n         LA    R3,WRKFILE1\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\n*\n         TM    PPC_FLAG1,$PPC_F1SIMULATE  Simulate mode?\n         BO    CFD$X                      Yes, skip this\n*\n** Print starting message\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG70L,R15),MSG70-PDSR$MSG(R1) Move in message\n         LA    R15,MSG70L+1(R15)\n         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates\n         BO    CFD$M70D                   Yes, do duplicate\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?\n         BO    CFD$M70C                   Yes, do cross reference\n         MVI   0(R15),C'?'                Say what\n         LA    R15,2(R15)\n         B     CFD$M70M\nCFD$M70C EQU   *\n         MVC   0(MSG70BL,R15),MSG70B-PDSR$MSG(R1)\n         LA    R15,MSG70BL+1(R15)\n         B     CFD$M70M\nCFD$M70D EQU   *\n         MVC   0(MSG70AL,R15),MSG70A-PDSR$MSG(R1)\n         LA    R15,MSG70AL+1(R15)\nCFD$M70M EQU   *\n         MVC   0(7,R15),=C'started'\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nCFD$M70X EQU   *\n*\n** Sort the input file (WRKFILE1) into the output file (WRKFILE2)\n*\n         LA    R1,C_SFCFD                 Locate sort fields string\n         BAS   R14,SORT_FILE              Sort WRKFILE1 by Key\n         LTR   R15,R15                    Okay?\n         BZ    CFD$SORTX                  Yes, continue\n         MVI   MAXCC,$SEVERE              No, set max condition code\n         B     EXIT                       Leave\nCFD$SORTX EQU  *\n*\n** Correct headings\n*\n*\n         LA    R15,PRR_IHEAD1+1           Locate heading record\n         USING DET,R15\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         USING PDSR$C2,R1\n         MVC   DET_IMULT(DET_IMULTL),C_BLANKS\n         MVC   DET_IDD(9),C_DET_IDD\n         MVC   DET_IVOL(6),C_DET_IVOL\n         MVC   DET_IDSN(13),C_DET_IDSN\n         LA    R15,PRR_IHEAD2+1           Locate heading record\n         MVC   DET_IMULT(DET_IMULTL),C_BLANKS\n         MVC   DET_IDD(L'DET_IDD),C_DASHS+1\n         MVC   DET_IVOL(L'DET_IVOL),C_DASHS+1\n         MVC   DET_IDSN(DET_IDSNL),C_DASHS+1\n*\n         LA    R15,PRR_LHEAD1+1           Locate heading record\n         MVC   DET_LMULT(DET_LMULTL),C_BLANKS\n         LA    R15,PRR_LHEAD2+1           Locate heading record\n         MVC   DET_LMULT(DET_LMULTL),C_BLANKS\n         MVC   DET_LDD(6),C_DET_LDD\n         MVC   DET_LVOL(6),C_DET_LVOL\n         MVC   DET_LDSN(13),C_DET_LDSN\n         LA    R15,PRR_LHEAD3+1           Locate heading record\n         MVC   DET_LMULT(DET_LMULTL),C_BLANKS\n         MVC   DET_LDD(L'DET_LDD),C_DASHS+1\n         MVC   DET_LVOL(L'DET_LVOL),C_DASHS+1\n         MVC   DET_LDSN(DET_LDSNL),C_DASHS+1\n         DROP  R1,R15\n*\n** Open the sorted file\n*\n         LA    R3,WRKFILE2                Locate DCB work area\n         L     R1,=V(PDSR$C1)\n         MVC   0(C_DCBIL,R3),C_DCBI-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE2' Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)\n         LA    R2,CFD$LX                  Locate END-OF-FILE area\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\n*\n** Process the sorted file\n*\n         XC    CFD_MEMBER(8),CFD_MEMBER   Initialize control break\n         XC    CFD_NUM(4),CFD_NUM         Clear number of duplicates\n         MVI   CFD_RECOUT,255             Hadn't printed a thing yet\n         MVI   CFD_TYPE,0                 Set type\n         MVI   CFD_FIRST,0                First time?\n         MVI   PRR_LC,255                 Force heading\n         MVI   PRR_TITLE1,0               Initialize\n         MVI   PRR_TITLE2,0               Initialize\nCFD$L    EQU   *\n         GET   WRKFILE2                   Get input record\n         LR    R2,R1                      Save address of record\n*MVC RECOUT(133),RECOUT-SORTREC(R2)\n*BAS R14,PRINT_SYSPRINT_RECORD\n*\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member Cross reference?\n         BO    CFD$LMEMX                  Yes, print record asis\n         CLI   CFD_MEMBER,0               First time thru?\n         BE    CFD$LI                     Yes, initialize for member\n         CLC   CFD_MEMBER(8),RECOUT+1+(DETMEM-DET)-SORTREC(R2)\n         BNE   CFD$LI                     New member to worry about\n*\n         L     R1,CFD_NUM                 Get current number\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,CFD_NUM                 Save number\n*\n         CLI   CFD_RECOUT,0               Printed previous record?\n         BE    CFD$LPRX                   Yes, continue\n*\n         CLI   CFD_FIRST,0                Feel like the first time?\n         BE    CFD$LFX                    Yes, don't need delimiter\n         NI    PPD_FLAG1,255-$PPD_F1NEWHEAD\n         MVI   RECOUT,C' '                Fill in FBA byte\n         MVI   RECOUT+1,C'='\n         MVC   RECOUT+2(L'RECOUT-2),RECOUT+1\n         BAS   R14,PRINT_REPORT_RECORD    Print report record\nCFD$LFX  EQU   *\n         MVI   CFD_FIRST,1                Set flag\n         LA    R6,CFD_RECOUT              Locate previous record\n         BAS   R7,CFD$LOC                 Fill in location\n         BAS   R14,PRINT_REPORT_RECORD    Print report record\nCFD$LPRX EQU   *\n         MVC   CFD_MEMBER(8),RECOUT+1+(DETMEM-DET)-SORTREC(R2)\nCFD$LMEMX EQU  *\n         LR    R6,R2                      Locate fields for CFD$LOC\n         BAS   R7,CFD$LOC                 Fill in location\n         BAS   R14,PRINT_REPORT_RECORD    Print current record\n         MVI   CFD_RECOUT,0               Printed previous record\n         MVI   CFD_FIRST,1                Feel like the first time\n         B     CFD$L\n*\nCFD$LI   EQU   *\n         MVC   CFD_MEMBER(8),RECOUT+1+(DETMEM-DET)-SORTREC(R2)\n         MVC   CFD_RECOUT(SORTRECL),0(R2)\n         B     CFD$L\n*\n** Fill in location\n*\nCFD$LOC  EQU   *\n         MVC   RECOUT(133),RECOUT-SORTREC(R6)   Fix output record\n         MVC   PPD_FLAG1(1),SR_FLAG1-SORTREC(R6) Set flag for print\n*\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?\n         BO    CFD$LPF1M\n         OI    PPD_FLAG1,$PPD_F1CHKDUP    We are in duplicate process\n         B     CFD$LPF1MX\nCFD$LPF1M EQU *\n         OI    PPD_FLAG1,$PPD_F1MEMXREF   We are doing member XREF\nCFD$LPF1MX EQU *\n*\n         CLI   CFD_TYPE,0                 First time?\n         BE    CFD$LOCHX                  Yes, normal headings will do\n         CLC   CFD_TYPE(1),SR_FLAG1-SORTREC(R6)\n         BE    CFD$LOCHX                  Yes, continue\n         OI    PPD_FLAG1,$PPD_F1NEWHEAD   Need new headings\nCFD$LOCHX EQU *\n         MVC   CFD_TYPE(1),SR_FLAG1-SORTREC(R6) Fill in type\n         LA    R15,RECOUT+1               Locate output record\n*\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         TM    PPD_FLAG1,$PPD_F1ISPF      ISPF?\n         BO    CFD$LOCI                   Yes, continue\n         MVC   DET_LMULT-DET(DET_LMULTL,R15),C_BLANKS-PDSR$C2(R1)\n         MVC   DET_LDD-DET(16,R15),SR_DDNAME-SORTREC(R6)\n         MVC   DET_LVOL-DET(6,R15),SR_VOLSER-SORTREC(R6)\n         MVC   DET_LDSN-DET(44,R15),SR_DSN-SORTREC(R6)\n         MVI   DET_LMULTD-DET(R15),C'|'\n         BSM   0,R7\nCFD$LOCI EQU   *\n         MVC   DET_IMULT-DET(DET_IMULTL,R15),C_BLANKS-PDSR$C2(R1)\n         MVC   DET_IDD-DET(16,R15),SR_DDNAME-SORTREC(R6)\n         MVC   DET_IVOL-DET(6,R15),SR_VOLSER-SORTREC(R6)\n         MVC   DET_IDSN-DET(44,R15),SR_DSN-SORTREC(R6)\n         MVI   DET_IMULTD-DET(R15),C'|'\n         BSM   0,R7\n*\n** End of file\n*\nCFD$LX   EQU   *\n         LA    R3,WRKFILE3\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\n*\n         LA    R3,WRKFILE2\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\n*\n** Print number of duplicates found\n*\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?\n         BO    CFD$M71X                   Yes, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG71L,R15),MSG71-PDSR$MSG(R1) Move in message\n         LA    R15,MSG71L+1(R15)          Bump past it\n         L     R1,CFD_NUM                 Get number of duplicates\n         BAS   R9,EDITFWF                 Edit it\n         MVC   1(6,R15),=C'out of'        Insert text\n         LA    R15,1+6+1(R15)             Bump past it\n         L     R1,PP_TMEM                 Get total members\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD\nCFD$M71X EQU   *\n*\n** Common exit from Check_For_Duplicates\n*\nCFD$X    EQU   *\n         EJECT\n***********************************************************************\n***\n**       Print Dataset summary\n***\n***********************************************************************\n         SPACE 2\nPRINT_DATASET_SUMMARY DS 0H\n*\n** Initialize\n*\n         L     R2,PP_DSUMA                Save length and address\n         TM    PPC_Flag1,$PPC_F1DATONLY   Data only?\n         BO    PDS$X                      Yes, skip this\n         L     R3,DSUMH_NUM-DSUMH(R2)     Get total number\n         LA    R4,DSUMHL(R2)              Locate to first entry\n         OI    W_FLAG2,$W_F2PDSUM+$W_F2PDSUM1  Flags needed for report\n         MVC   PRR_LC(2),=H'9999'         Force heading\n         MVI   PRR_TITLE1,0               Indicate first time\n*\n** Loop through the Dataset entries\n*\nPDS$L    DS    0H\n         MVI   RECOUT+1,C' '              Get space\n         MVC   RECOUT+2(131),RECOUT+1     ..Propagate it\n         MVC   RECOUT+1(DSUMEL),0(R4)\n         BAS   R14,PRINT_REPORT_RECORD\n         LA    R4,DSUMEL(R4)\n         BCT   R3,PDS$L\n*\n         MVI   RECOUT+1,C'-'              Get dash\n         MVC   RECOUT+2(DSUMEL-1),RECOUT+1 ..Propagate it\n         BAS   R14,PRINT_REPORT_RECORD\n*\n         MVI   RECOUT+1,C' '              Get space\n         MVC   RECOUT+2(DSUMEL-1),RECOUT+1     ..Propagate it\n         LA    R4,RECOUT+1\n         L     R1,DSUMH_CNTTRKA-DSUMH(R2) Get total\n         CVD   R1,DOUBLE                  Convert number to packed\n         MVC   DSUME_TRKA-DSUME(6,R4),=X'40,20,20,20,20,20'\n         ED    DSUME_TRKA-DSUME(6,R4),DOUBLE+5\n         L     R1,DSUMH_CNTTRKU-DSUMH(R2) Get total\n         CVD   R1,DOUBLE                  Convert number to packed\n         MVC   DSUME_TRKU-DSUME(6,R4),=X'40,20,20,20,20,20'\n         ED    DSUME_TRKU-DSUME(6,R4),DOUBLE+5\n         L     R1,DSUMH_CNTMEM-DSUMH(R2)  Get total\n         CVD   R1,DOUBLE                  Convert number to packed\n         MVC   DSUME_MEMBERS-DSUME(6,R4),=X'40,20,20,20,20,20'\n         ED    DSUME_MEMBERS-DSUME(6,R4),DOUBLE+5\n         L     R1,DSUMH_NUM-DSUMH(R2)     Get library count\n         LA    R15,DSUME_DSN-DSUME(R4)    Locate to output area\n         BAS   R9,EDITFWF                 Edit library count\n         BAS   R14,PRINT_REPORT_RECORD\n*\n** Free the Dataset Summary data area\n*\nPDS$X    DS    0H\n         LR    R1,R2                      Get address of area\n         L     R0,DSUMH_LEN-DSUMH(R1)     Get length of area\n         FREEMAIN R,LV=(0),A=(1)          Then free the area\n         EJECT\n***********************************************************************\n***\n**       Termination Section\n***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n*\n** Call PDSR$IVC for termination\n*\n         TM    PPC_FLAG5,$PPC_F5IVCSECTS\n         BNO   X$IVCX\n         LA    R0,#IVC_TERM\n         LA    R1,SUBRSA\n         L     R15,=V(PDSR$IVC)\n         BASR  R14,R15\nX$IVCX   DS    0H\n*\n** Call PDSRCM for termination\n*\n         AIF   ('&IHADFARELS' LT '01010100').RCMXX\n         ICM   R1,B'1111',A_PDSRCMD+4     Locate area\n         BZ    X$PDSRCM$X                 None, PDSRCM not needed\n         MVI   PDSRCMD_CALLT-PDSRCMD(R1),$PDSRCMD_CT_TERM\n         L     R15,=V(PDSRCM)             Locate routine\n         BASR  R14,R15                    Initialize\n         LM    R0,R1,A_PDSRCMD            Get length and address\n         FREEMAIN R,LV=(0),A=(1)          Then free the area\nX$PDSRCM$X DS  0H\n.RCMXX   ANOP  ,\n*\n** Free APFLST table for MVS 4.3 and higher using Dynamic type\n*\n         LM    R0,R1,APF_DYN              Get area length and address\n         LTR   R0,R0                      Anything to free?\n         BZ    X$APFX                     No, continue\n         FREEMAIN RU,LV=(0),A=(1)         Release storage\nX$APFX   EQU   *\n*\n** Free BKLids table (if any)\n*\n         ICM   R1,B'1111',RBF_PTR         Table obtained\n         BZ    X$RBFX                     No, continue\n         L     R0,BKLH_LEN-BKLH(R1)       Yes, get length and...\n         FREEMAIN RU,LV=(0),A=(1)         Release storage\nX$RBFX   EQU   *\n*\n** Free Alias table\n*\n         LM    R0,R1,PP_OT                Get table length and address\n         LTR   R0,R0                      Any table to free?\n         BZ    X$ATX                      No, continue\n         FREEMAIN RU,LV=(0),A=(1)         Release storage\nX$ATX    EQU   *\n*\n** Free Translator table\n*\n         LM    R0,R1,PP_TT                Get table length and address\n         LTR   R0,R0                      Any table to free?\n         BZ    X$TTX                      No, continue\n         FREEMAIN RU,LV=(0),A=(1)         Release storage\nX$TTX    EQU   *\n*\n** Free I/O buffer if allocated\n*\n         LM    R0,R1,PP_PDSBUF            Get buffer length and address\n         LTR   R0,R0                      Any buffer to free?\n         BZ    X$PPDBX                    No, continue\n         FREEMAIN R,LV=(0),A=(1)          Release storage\nX$PPDBX  EQU   *\n*\n** Print ending message on //SYSPRINT: MAX condition code and time\n*\n         TM    SYSPRINT+(DCBOFLGS-IHADCB),DCBOFOPN Is file open?\n         BNO   X$MSGX\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         TIME  BIN                        Get the time\n         ST    R0,SF_RA                   Save for later\n         BAS   R14,FORMAT_MESSAGE         Initialize RECOUT to blanks\n         MVC   0(MSG999L,R15),MSG999-PDSR$MSG(R1) Move in message\n         LA    R15,MSG999L+1(R15)         Bump past it\n         SLR   R1,R1                      Clear register\n         IC    R1,MAXCC                   Get condition code\n         BAS   R9,EDITFWF                 Edit it\n         MVC   0(7,R15),=C', Time:'\n         LA    R15,7(R15)\n         L     R1,SF_RA                   Get the time\n         BAS   R14,CONVERT_BINARY_TIME    \" hh:mm:ss\"\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\nX$MSGX   EQU   *\n*\n** Print \"End of Report\" on //REPORT\n*\n         TM    PPC_Flag1,$PPC_F1DATONLY   Data only?\n         BO    X$RPTX                     Yes, skip this\n         TM    REPORT+(DCBOFLGS-IHADCB),DCBOFOPN Is file open?\n         BNO   X$RPTX                     No, continue\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_REPORT_RECORD    Print the record\n         MVC   RECOUT+1(14),=C'End of Report.'\n         BAS   R14,PRINT_REPORT_RECORD    Print the record\nX$RPTX   DS    0H\n*\n** Close files\n*\n         LA    R3,ZAPRPT\n         BAS   R9,CLOSE_FILE\n         LA    R3,ECRPT\n         BAS   R9,CLOSE_FILE\n         LA    R3,COBCRPT\n         BAS   R9,CLOSE_FILE\n         LA    R3,REPORT\n         BAS   R9,CLOSE_FILE\n         LA    R3,SYSPRINT\n         BAS   R9,CLOSE_FILE\n*\n** Delete modules from memory\n*\n         TM    W_FLAG1,$W_F1LRDATE        Did we get loaded?\n         BNO   X$DATEX                    No, bummer dude!\n         ICM   R0,B'1111',EP_DA$DATE      -> Program Loaded?\n         BZ    X$DATEX                    No, continue\n         DELETE EPLOC==CL8'DA$DATE'       Delete from V/S\nX$DATEX EQU    *\n         TM    W_FLAG1,$W_F1LRMXD         Did we get loaded?\n         BNO   X$MXDUMPX                  No, bummer dude!\n         ICM   R0,B'1111',EP_DA$MXD       -> Program Loaded?\n         BZ    X$MXDUMPX                  No, continue\n         DELETE EPLOC==CL8'DA$MXD'        Delete from V/S\nX$MXDUMPX EQU  *\n*\n** Return to caller with the maximum condition code\n*\n         SLR   R15,R15                    Get ready for IC\n         IC    R15,MAXCC                  Get maximum condition code\nX$LEAVE  EQU   *\n         DA#LEAVE RC=(15)                 Return to caller\n         EJECT\n***********************************************************************\n***\n**       Error routines\n***\n***********************************************************************\n         SPACE 2\n*\n** Error: Required load module not found, execution not possible\n**\n** Input: R8 - 8 byte program name\n*\nE$LOAD   EQU   *\n         LA    R1,RECOUT                  Locate WTO work area\n         L     R14,=V(PDSR$C1)            -> Constants CSECT\n         MVC   0(C_WTOL,R1),C_WTO-PDSR$C1(R14) Initialize WTO\n         LA    R15,4(R1)                  Bump past WTO flags\n         BAS   R14,FM$PRE                 Get message prefix\n         MVC   0(MSG80L,R15),MSG80-PDSR$MSG(R1) Move in message\n         MVC   MSG80L+1(8,R15),0(R8)      Get module name\n         WTO   ,MF=(E,RECOUT)             Issue WTO message\n         LA    R15,20                     Set condition code\n         B     X$LEAVE\n*\n** Error: Open of global file (SYSPRINT or REPORT failed)\n**\n** Input: R8 - 8 file name\n*\nE$OPENG  EQU   *\n         ST    R15,DOUBLE                 Save return code\n         CLI   0(R8),C'S'                 SYSPRINT file?\n         BNE   EOG$SI                     Yes, initialize reg msg\n         LA    R1,RECOUT                  Locate WTO work area\n         L     R14,=V(PDSR$C1)            -> Constants CSECT\n         MVC   0(C_WTOL,R1),C_WTO-PDSR$C1(R14) Initialize WTO\n         LA    R15,4(R1)                  Bump past WTO flags\n         BAS   R14,FM$PRE                 Get message prefix\n         B     EOG$SIX\nEOG$SI   EQU   *\n         BAS   R14,FORMAT_MESSAGE         Initialize message\nEOG$SIX  EQU   *\n         MVC   0(MSG83L,R15),MSG83-PDSR$MSG(R1) Move in message\n         LA    R15,MSG83L(R15)            Bump past it\n         BAS   R14,FORMAT_OPEN_ABEND_MSG  Format OPEN error msg\n         CLI   0(R8),C'S'                 SYSPRINT file?\n         BNE   EOG$ST                     No, regular message\n         WTO   ,MF=(E,RECOUT)             Issue WTO message\n         MVI   MAXCC,$SEVERE\n         B     EXIT\nEOG$ST   EQU   *\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         MVI   MAXCC,$SEVERE\n         B     EXIT\n*\n** DCB ABEND Exit routine: GC26-4013 MVS/XA Data Administration Guide\n**                         Chapter 7.\n*\nE$OPEN   EQU   *\n         L     R2,0(R1)                  Get ABEND code\n         ST    R2,OX_CODE                Save ABEND code\n         MVI   3(R1),4                   Ignore ABEND (for now...)\n         BSM   0,R14                     Return to IOS\n         EJECT\n***********************************************************************\n***\n**       Process the PDS directory\n***\n***********************************************************************\n         SPACE 2\nPROCESS_PDS_DIRECTORY EQU *\n         ST    R14,PPD_RA                 Save our return address\n*\n** Read directory block\n*\nPPD$GET  EQU   *\n         GET   SYSLIB                     Read directory Block\n*\n** Count directory blocks\n*\n         L     R14,PPD_DIRBLKS            Get directory block count\n         LA    R14,1(R14)                 Increment by 1\n         ST    R14,PPD_DIRBLKS            Save it\n*\n         TM    PPD_FLAG2,$PPD_F2BLKCNT    Just counting blocks?\n         BNO   PPD$GDBX                   No, continue\n         L     R14,PPD_DIRBLKSU           Get directory block count\n         LA    R14,1(R14)                 Increment by 1\n         ST    R14,PPD_DIRBLKSU           Save it\n         B     PPD$GET                    Get next one\nPPD$GDBX EQU   *\n*\n** Calculate End-of-block\n*\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',0(R1)          Get length of used portion\n         LA    R15,0(R14,R1)              Locate end of block\n         ST    R15,PPD_EOB                Save for later\n         LA    R2,2(R1)                   Bump past length halfword\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Process member\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPD$MEM  EQU   *\n         CLC   0(8,R2),=8X'FF'            End of directory?\n         BNE   PPD$LASTX                  No, continue\n         OI    PPD_FLAG2,$PPD_F2BLKCNT    Turn on flag\n         B     PPD$GET\nPPD$LASTX EQU  *\n*\n** Calculate length of Directory entry\n*\n         MVC   DOUBLE(1),PDS2INDC-PDS2(R2) Get indicator byte\n         NI    DOUBLE,B'00011111'         Turn off unneeded bits\n         SLR   R1,R1                      Clear register\n         IC    R1,DOUBLE                  Get value\n         SLL   R1,1                       Times 2 for user halfwords\n         AH    R1,=AL2(PDS2USRD-PDS2)     Add Length of fixed section\n         STH   R1,PPD_DIRENTL             Save length of entry\n         SPACE 3\n*\n** If we are doing find member processing see if in library\n*\n         TM    PPC_IFLAG1,$PPC_IF1FMG     Was it generic?\n         BO    PPD$FMG\n         CLI   PPC_FML,0                  Doing find member checking?\n         BE    PPD$FMX                    No, leave\nPPD$FMG  DS    0H\n         SLR   R1,R1                      Clear for IC\n         IC    R1,PPC_FML                 Get length\n         EX    R1,PPD$FMC                 Match?\n         BNE   PPD$FMNM                   No, continue\n         L     R1,PP_FMCOUNT              Get count\n         LA    R1,1(R1)                   Add 1\n         ST    R1,PP_FMCOUNT              Save count\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG53L,R15),MSG53-PDSR$MSG(R1) Move in message\n         MVC   MSG53N-MSG53(8,R15),PDS2NAME-PDS2(R2)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         B     PPD$FMX\nPPD$FMC  CLC   PPC_FM(0),PDS2NAME-PDS2(R2)\nPPD$FMNM DS    0H                         No match on member\n         TM    PPC_FLAG4,$PPC_F4ONLYF     Only processing FINDMEMs?\n         BO    PPD$MB                     Yes, skip this member\nPPD$FMX  DS    0H\n*\n** Initialize record and place member name on it\n*\n         BAS   R14,CLEAR_RECOUT           Clear for record\n         MVC   1+DETMEM-DET(8,R15),PDS2NAME-PDS2(R2)\n         L     R1,=V(PDSR$C2)             -> PDSR$C2 CSECT\n         TR    1+DETMEM-DET(8,R15),C_TRTABM-PDSR$C2(R1)\n*\n** Get TTR Information\n*\n         UNPK  1+DETADDR-DET(7,R15),PDS2TTRP-PDS2(4,R2)\n         MVZ   1+DETADDR-DET(6,R15),ZEROS\n         TR    1+DETADDR-DET(6,R15),HEXTABLE\n         MVI   1+DETADDR-DET+6(R15),C' '\n*\n** Increment member count\n*\n         L     R1,PPD_NMEM                Get current number\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PPD_NMEM                Save it\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**   Skip a line between systems (First 3 characters)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\n         TM    PPC_FLAG1,$PPC_F1NOBREAK   No breaks?\n         BO    PPD$NBX                    Yes, skip processing\n         CLC   PPD_LSYS(3),ZEROS          First time thru?\n         BE    PPD$NB                     Yes, initialize\n         CLC   PPD_LSYS(3),PDS2NAME-PDS2(R2) Last system?\n         BE    PPD$NBX                    Yes, continue\n         MVI   RECOUT,C'0'                Skip a line...\nPPD$NB   EQU   *\n         MVC   PPD_LSYS(3),PDS2NAME-PDS2(R2) Initialize for this system\nPPD$NBX  EQU   *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**  ISPF processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPD$ISPF EQU   *\n         TM    PPD_FLAG1,$PPD_F1ISPF      Need ISPF stats?\n         BNO   PPD$ISPFX                  No, continue\n*\n         LA    R0,#IS_FORMAT              Option: Format ISPF stats\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$IS)            Locate CSECT\n         BASR  R14,R15                    Invoke the parse routine\n         B     PPD$MPRT\nPPD$ISPFX EQU *\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Perform a BLDL to get the PDS directory entry\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Perform the BLDL\n*\n         NI    PPD_FLAG1,255-$PPD_F1BLDLF\n         XC    PPD_PDS(PPD_PDSL),PPD_PDS  Clear to zeros\n         MVC   PPD_PDS_FF(2),=AL2(1)      Number of members found\n         MVC   PPD_PDS_LL(2),=AL2(PPD_PDS_ENTRYL) Move in entry length\n         MVC   PPD_PDS_ENTRY+(PDS2NAME-PDS2)(8),PDS2NAME-PDS2(R2)\n         LA    R3,PPD_PODCB               Locate DCB\n         BLDL  (3),PPD_PDS                Perform BLDL\n         LR    R3,R15                     Save BLDL return code\n*\n         TM    PPC_FLAG2,$PPC_F2DUMPBLDL  Option on?\n         BNO   PPD$BLDLDX                 No, continue\n         MVC   SLACKR(133),RECOUT         Save current record\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG60L,R15),MSG60-PDSR$MSG(R1) Move in message\n         MVC   MSG60N-MSG60(8,R15),PDS2NAME-PDS2(R2)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message\n         XC    W_AREA(CMXDL),W_AREA       Initialize area\n         LA    R15,PPD_PDS                Locate PDS BLDL return area\n         LA    R0,PPD_PDSL                Get length of area\n         LA    R1,RECOUT+MSGPREL+8        \"DA$PDSR-000I    \"\n         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output\n         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?\n         BO    PPD$BLDLDL\n         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(#MXDWIDE)\nPPD$BLDLDL DS 0H\n         LA    R1,W_AREA                  Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         LR    R8,R15                     Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD  Locate print routine\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   PPD$BLDLDL                 Thank you: May I have another\n         MVC   RECOUT(133),SLACKR         Restore record\nPPD$BLDLDX DS 0H\n*\n         LTR   R3,R3                      Successful?\n         BZ    PPD$BLDLO                  Yes, continue\n         OI    PPD_FLAG1,$PPD_F1BLDLF     BLDL failed!!!!!\n*\n         MVC   SLACKR(133),RECOUT         Save current record\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG55L,R15),MSG55-PDSR$MSG(R1) Move in message\n         LA    R15,MSG55L+1(R15)          Bump past it\n         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name\n         LA    R0,8                       Length of member name\n         BAS   R14,LOCATE_FIRST_SPACE     Locate first space\n         MVC   0(5,R15),=C', RC='         Insert text\n         LA    R15,5(R15)                 Bump past it\n         LR    R1,R3                      Get RC\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVC   RECOUT(133),SLACKR         Restore record\n*\n         AIF   ('&IHADFARELS' LT '01010100').RCMBDX\n         ICM   R8,B'1111',A_PDSRCMD+4\n         BZ    PPD$BLDLX\n         NI    PDSRCMD_FLAG1-PDSRCMD(R8),255-$PDSRCMD_F1DCB\n.RCMBDX  ANOP  ,\n         B     PPD$BLDLX\n*\nPPD$BLDLO DS   0H\n         AIF   ('&IHADFARELS' LT '01010100').RCMBOX\n         ICM   R8,B'1111',A_PDSRCMD+4\n         BZ    PPD$BLDLX\n         OI    PDSRCMD_FLAG1-PDSRCMD(R8),$PDSRCMD_F1DCB\n         LA    R1,PPD_PODCB               Locate DCB\n         ST    R1,PDSRCMD_DCBPTR-PDSRCMD(R8)\n         LA    R1,PPD_PDS_ENTRY           Locate Directory entry\n         ST    R1,PDSRCMD_DEPTR-PDSRCMD(R8)\nPPD$BLDL_UDX DS 0H\n.RCMBOX  ANOP  ,\nPPD$BLDLX DS   0H\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Translator/history reports via PDSRCM\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         AIF   ('&IHADFARELS' LT '01010100').RCMMX\n         ICM   R8,B'1111',A_PDSRCMD+4\n         BZ    PPD$CM$CSX\n         OI    PPD_FLAG2,$PPD_F2NBLINFO    Default that we need it\n         ST    R2,PDSRCMD_PDS2-PDSRCMD(R8) Save PDS member location\n*\n** Get member name into the proper format: AL2(length),C'name'\n*\n         LA    R1,PDS2NAME+1-PDS2(R2)\n         LA    R0,L'PDS2NAME-1\n         LA    R14,1\nPPD$CM$MNL DS  0H\n         CLI   0(R1),C' '\n         BE    PPD$CM$MNLX\n         LA    R14,1(R14)\n         LA    R1,1(R1)\n         BCT   R0,PPD$CM$MNL\nPPD$CM$MNLX DS 0H\n         STH   R14,PDSRCMD_MODNAME-PDSRCMD(R8)\n         MVC   PDSRCMD_MODNAME+2-PDSRCMD(8,R8),PDS2NAME-PDS2(R2)\n         MVC   PDSRCMD_ALIAS-PDSRCMD(2,R8),=C'  '\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS\n         BNO   PPD$CM$ALIASX\n         MVC   PDSRCMD_ALIAS-PDSRCMD(2,R8),=C'-A'\nPPD$CM$ALIASX DS 0H\n*\n** Call PDSRCM to produce the report(s)\n*\n         MVI   PDSRCMD_CALLT-PDSRCMD(R8),$PDSRCMD_CT_MEM\n         LR    R1,R8\n         L     R15,=V(PDSRCM)\n         BASR  R14,R15\n*\n** Update the REPORT fields on the current output record for this\n** member with information gleaned from PDSRCM.\n*\n         ICM   R8,B'1111',A_PDSRCMD+4     Locate area\n         LA    R15,RECOUT+1\n*\n         ICM   R1,B'1111',PDSRCMD_CSECTS-PDSRCMD(R8)\n         BZ    PPD$CM$CSCX\n         CVD   R1,DOUBLE\n         MVC   DET_LCSECT+2-DET(6,R15),=X'40,20,20,20,20,20'\n         ED    DET_LCSECT+2-DET(6,R15),DOUBLE+5\nPPD$CM$CSCX DS 0H\n*\n         L     R1,PDSRCMD_MZAPCNT-PDSRCMD(R8)\n         CVD   R1,DOUBLE\n         MVC   DET_LZAP-DET(4,R15),EDPAT4 Get edit pattern\n         ED    DET_LZAP-DET(4,R15),DOUBLE+6 Edit zap count\n*\n         ICM   R8,B'1111',PDSRCMD_BINDER-PDSRCMD(R8)\n         BZ    PPD$CM$CSX\n         NI    PPD_FLAG2,255-$PPD_F2NBLINFO\n         USING IDB_ENTRY,R8\n         TM    PPC_FLAG4,$PPC_F4NTRANID          Don't translate PID?\n         BO    PPD$CM$CSTLX                      Yes, just insert PID\n         L     R1,=V(PDSR$TRT)                   Locate CSECT\n         LA    R1,T_LINKT-PDSR$TRT(R1)           Locate table\n         LA    R0,T_LINKTN                       Get number of entries\nPPD$CM$CSTL DS 0H\n         CLC   IDB_BINDER_ID(L'TLT_ID),TLT_ID-TLT(R1)  PID match?\n         BE    PPD$CM$CSTLF                      Yes, continue\n         LA    R1,TLTL(R1)                       No, bump to next entry\n         BCT   R0,PPD$CM$CSTL                    ..and process it\nPPD$CM$CSTLX DS 0H\n         MVC   DET_LTNAME-DET(10,R15),IDB_BINDER_ID Insert PID\n         B     PPD$CM$CSTX                       Continue\nPPD$CM$CSTLF DS 0H\n         MVC   DET_LTNAME-DET(L'TLT_NAME,R15),TLT_NAME-TLT(R1)\nPPD$CM$CSTX DS 0H\n*\n         LA    R14,DET_LTD_DATE-DET(R15)\n         ST    R14,EJ_ODGEUR11A_STR\n         LA    R14,IDB_DATE_BOUND\n         ST    R14,W_IDJULC7_STR\n         LA    R14,RECOUT+1+DET_LTD_DOW-DET\n         ST    R14,EJ_ODDOW3A_STR\n         L     R1,=V(PDSR$C1)\n         MVC   W_IDJULC7(C_IDJULC7L),C_IDJULC7-PDSR$C1(R1)\n         MVC   EJ_ODDOW3A(C_ODDOW3AL),C_ODDOW3A-PDSR$C1(R1)\n         MVC   EJ_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-PDSR$C1(R1)\n         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?\n         BO    PPD$CM$CSTE$CDISO\n         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?\n         BNO   PPD$CM$CSTE$CDISOX         Use default of \"European\"\n         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODGUS Make Gregorian US\n         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODGUS10 Set length\n         B     PPD$CM$CSTE$CDISOX\nPPD$CM$CSTE$CDISO DS 0H\n         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODISO Make ISO\n         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODISO10 Set length\nPPD$CM$CSTE$CDISOX DS 0H\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine\n         CALL  (15),(W_IDJULC7,EJ_ODGEUR11A,EJ_ODDOW3A),               @\n               VL,MF=(E,PARMLIST)\n         LTR   R15,R15\n         BZ    PPD$CM$CSTEJX\n         MVC   DET_LTD_DATE-DET(4,R15),IDB_DATE_BOUND Get \"ccyy\"\n         MVI   DET_LTD_DATE+4-DET(R15),C'.'\n         MVC   DET_LTD_DATE+5-DET(3,R15),IDB_DATE_BOUND+4\nPPD$CM$CSTEJX DS 0H\n         DA#SMODE 24                      Back to 24 bit mode\n*\n         DROP  R8\nPPD$CM$CSX DS  0H\n.RCMMX   ANOP  ,\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Issue an MVS LOAD against the module:\n** - EyeCatcher report\n** - COBOL CICS report\n** - Ensure executable modules\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG3,$PPC_F3LOADMOD\n         BNO   PPD$NLOAD\n*\n** Load the module into storage\n*\n         LA    R8,SYSLIB                  Locate DCB\n         TM    PPD_FLAG1,$PPD_F1BLDLF     BLDL failed?\n         BO    PPD$LOAD_EP                Yes, can't use BLDL dir ent\n         LOAD  DE=PPD_PDS_ENTRY,          Load module into V/S         @\n               DCB=(8),                   ..Only use the one from here @\n               ERRET=PPD$LE00             ..Catch LOAD errors\n         B     PPD$LOAD_EPX\nPPD$LOAD_EP DS    0H\n         LOAD  EPLOC=PDS2NAME-PDS2(R2),   Load module into V/S         @\n               DCB=(8),                   ..Only use the one from here @\n               ERRET=PPD$LE00             ..Catch LOAD errors\nPPD$LOAD_EPX DS 0H\n         LR    R9,R0                      Save EPA of module\n*\n** Determine the length of the module\n*\n         AIF   (NOT D'CVTH4430).CSVQ1X\n         L     R14,CVTPTR\n         TM    CVTOSLV0-CVTMAP(R14),CVTH4430 ESA 4.3 or higher?\n         BO    PPD$CSVQ                   Yes, always do CSVQUERY...\n.CSVQ1X  ANOP  ,\n         ICM   R1,B'1000',ZEROS           Turn off authorization bit\n         SLR   R0,R0                      Clear register for divide\n         M     R0,=F'8'                   Multiply to get length in dw\n         LR    R8,R1                      Save length\n         B     PPD$CSVQX                  and leave\nPPD$CSVQ DS    0H\n         AIF   (NOT D'CVTH4430).CSVQ2X\n         ST    R9,DOUBLE2\n         CSVQUERY INADDR=DOUBLE2,         Get module info by addr      @\n               OUTLENGTH=DOUBLE,          ..Get length to here         @\n               MF=(E,PARMLIST)            ..Execute parmlist\n         LTR   R15,R15\n         BZ    PPD$CSVQO\n         LR    R3,R15\n         MVC   SLACKR(L'RECOUT),RECOUT    Save current record\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG56L,R15),MSG56-PDSR$MSG(R1) Move in message\n         LA    R15,MSG56L+1(R15)          Bump past it\n         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name\n         LA    R0,8                       Length of member name\n         BAS   R14,LOCATE_FIRST_SPACE     Locate first space\n         MVC   0(5,R15),=C', RC='         Insert text\n         LA    R15,5(R15)                 Bump past it\n         LR    R1,R3                      Get RC\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVC   RECOUT(L'RECOUT),SLACKR\n         LA    R1,4\n         ST    R1,DOUBLE\nPPD$CSVQO DS   0H\n         L     R8,DOUBLE                  Obtain module length\n.CSVQ2X  DS    0H\nPPD$CSVQX DS   0H\n*\n** COBOL CICS report processing\n*\n         TM    PPC_FLAG3,$PPC_F3COBCRPT   Doing it?\n         BNO   PPD$LCOBCX                 No, continue\n         LA    R15,SLACKR                 Locate to output record\n         BAS   R14,CR$PTR                 Clear recout to blanks\n         LA    R3,SLACKR                  Locate output record\n*-R2=PDS R3=Output R8=Module Length R9=Module start\n         L     R15,=V(PDSR$COC)           Locate routine\n         BASR  R14,R15\n         CLI   COBCR_ERROR-COBCR(R3),C'E' Found an error?\n         BNE   PPD$LCOBCX                 No, continue\n         MVC   COBCR_MEMBER-COBCR(8,R3),PDS2NAME-PDS2(R2)\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?\n         BNO   PPD$LCOBC_AX\n         MVC   COBCR_ALIAS-COBCR(2,R3),=C'-A'\nPPD$LCOBC_AX DS 0H\n* Note: The WORKDS area went over 4096 bytes so we have to do this\n*       kludgy code to reference SLACKR+55\n         LA    R1,SLACKR                  Locate to last field\n         LA    R1,55(R1)\n         MVC   0(44,R1),AREAJFCB+JFCBDSNM-INFMJFCB Get DSN\n*\n         ICM   R1,B'1111',PPD_NUMCOBCE    Get current number\n         BNZ   PPD$LCOBCB\n* Note: The WORKDS area went over 4096 bytes so we have to do this\n*       kludgy code to reference SLACKR2\n         LA    R4,SLACKR                  Locate to last field\n         LA    R4,L'SLACKR(R4)            Locate to next field\n*\n         MVI   0(R4),C' '                 Get blank\n         MVC   1(132,R4),0(R4)            ..Propagate it\n         L     R3,=V(PDSR$C2)             -> PDSR$C2 CSECT\n         MVC   1(C_COBCDL,R4),C_COBCD-PDSR$C2(R3)\n         PUT   COBCRPT,(4)                Put out record\n         MVI   0(R4),C' '                 Get blank\n         MVC   1(132,R4),0(R4)            ..Propagate it\n         PUT   COBCRPT,(4)                Put out record\n         L     R1,PPD_NUMCOBCE            Get current number\nPPD$LCOBCB DS 0H\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PPD_NUMCOBCE            Save new number\n         PUT   COBCRPT,SLACKR             Put out record\nPPD$LCOBCX DS 0H\n*\n** Eye-Catcher report processing\n*\n         TM    W_FLAG1,$W_F1DFSMS         We are DFSMS/MVS?\n         BO    PPD$LECX                   Yes, we do this in PDSRCM\n         TM    PPC_FLAG3,$PPC_F3ECRPT     Doing it?\n         BNO   PPD$LECX                   No, continue\n         LA    R1,SUBRSA                  Locate to work area\n         LA    R3,SLACKR                  Locate output record\n         LA    R0,0                       No CSECT - Main module\n*-R0=CSECT R1=SUBRSA R2=PDS2 R3=Output R8=Module Length R9=Module start\n         L     R15,=V(PDSR$EC)            Locate routine\n         BASR  R14,R15                    Call Eyecatcher routine\n         PUT   ECRPT,SLACKR               Put out record\nPPD$LECX DS    0H\n*\n** Delete the module from storage\n*\n         DELETE EPLOC=PDS2NAME-PDS2(R2)\n         B     PPD$NLOAD\n*\n** Error: Module could not be loaded\n*\nPPD$LE00 EQU   *\n         ST    R1,PPD_ABEND               Save ABEND code\n         ST    R15,PPD_ABENDR             Save reason code\n         L     R1,PPD_NLERR               ----+\n         LA    R1,1(R1)                       | Increment counter\n         ST    R1,PPD_NLERR               ----+\n         OI    PPD_FLAG2,$PPD_F2LOADERR Indicate load error\nPPD$NLOAD EQU  *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**   Load Module TTR, EPA, size and attributes\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LA    R0,#LMF_FORMAT             Option: Create headings\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSR$LMF)           Locate CSECT\n         BASR  R14,R15                    Invoke the parse routine\n*\n** Process the member\n*\n         MVC   PPD_TTR(3),PDS2TTRP-PDS2(R2) Save TTR address for point\n         TM    W_FLAG1,$W_F1DFSMS         Are we DFSMS/MVS?\n         BNO   PPD$LOADS                  No, always do it\n         TM    PPD_FLAG2,$PPD_F2NBLINFO\n         BO    PPD$LOADS                  No, always do it\n         CLC   W_DFARELS(4),=X'01010100'  DFSMS/MVS?\n         BH    PPD$LOADX                  Yes, use DFSMS always\nPPD$LOADS DS   0H\n         BAS   R14,PROCESS_LOAD_MODULE    Process the member\nPPD$LOADX EQU  *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Call for flatout processing - need member record\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG4,$PPC_F4FLATOUT   Doing //FLATOUT processing?\n         BNO   PPD$FOX\n         LA    R0,#FLATOUT_Member         Invocation: Member\n         LA    R1,SUBRSA                  Locate subroutine RSA\n         L     R15,=V(PDSRCMFM)           Locate CSECT\n         BASR  R14,R15                    Invoke the flatout routine\nPPD$FOX  DS    0H\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Check for SYNAD (I/O) errors while reading the member\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\n         TM    PPD_FLAG2,$PPD_F2SYNAD     Error found on SYSMEM file?\n         BNO   PPD$SYNADX                 No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG25L,R15),MSG25-PDSR$MSG(R1) Move in message\n         LA    R15,MSG25L(R15)            Bump past message\n         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name\n         LA    R0,8                       Max length of member\n         BAS   R14,LOCATE_FIRST_SPACE     Locate first space in name\n         MVI   0(R15),C':'                Insert delimiter\n         MVC   2(78,R15),SYNADMSG         Get SYNAD error message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\n         MVI   LASTCC,$SEVERE             Set condition code\nPPD$SYNADX EQU *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Print the report detail record\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPD$MPRT EQU   *\n*\n** Duplicate and Member XREF processing\n*\n         TM    PPC_FLAG1,$PPC_F1MEMXREF   Member XREF?\n         BO    PPD$MPRT_CFDS              Yes, do it\n         TM    PPC_FLAG1,$PPC_F1CHKDUP    Check for duplicates?\n         BNO   PPD$MPRT_CFDX              No, continue\nPPD$MPRT_CFDS  EQU *\n         CLI   SR_INIT,0                  Already filled in common?\n         BNE   PPD$MPRT_CFDKX             Yes, continue\n         MVC   SR_DDNAME(16),PP_PDDN\n         MVC   SR_DSN(44),AREAJFCB+(JFCBDSNM-INFMJFCB)\n         MVC   SR_VOLSER(6),AREAJFCB+(JFCBVOLS-INFMJFCB)\n         MVC   SR_NLIB(2),PP_NLIBS+2      Fill in library number\nPPD$MPRT_CFDKX EQU *\n         MVI   RECOUT,C' '                Make FBA byte space\n         MVC   SR_MEMBER(8),RECOUT+1+(DETMEM-DET)  Get member name\n         PUT   WRKFILE1,SORTREC           Put record out\nPPD$MPRT_CFDX  EQU *\n*\n** Just print record?\n*\n         TM    PPC_FLAG1,$PPC_F1NODET     Printing detail records?\n         BO    PPD$MPRT_NDX               No, continue\n         BAS   R14,PRINT_REPORT_RECORD    Print detail line\nPPD$MPRT_NDX EQU *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Directory dump\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPC_FLAG2,$PPC_F2DUMPDIRE  Printing Directory entry?\n         BNO   PPD$DIREX                  No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG61L,R15),MSG61-PDSR$MSG(R1) Move in message\n         BAS   R14,PRINT_SYSPRINT_RECORD  Issue error message\n*\n         XC    W_AREA(CMXDL),W_AREA       Initialize area\n         LR    R15,R2                     Locate directory entry\n         LH    R0,PPD_DIRENTL             Get length of directory ent.\n         LA    R1,RECOUT+MSGPREL+8        \"DA$PDSR-000I    \"\n         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output\n         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?\n         BO    PPD$DIREL\n         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(#MXDWIDE)\nPPD$DIREL EQU  *\n         LA    R1,W_AREA                  Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         LR    R8,R15                     Save return code\n         BAS   R14,PRINT_SYSPRINT_RECORD  Locate print routine\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   PPD$DIREL                  Thank you: May I have another\nPPD$DIREX EQU  *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Check for member name with non-Standard characters\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LA    R15,SLACKR                 Locate slack area\n         MVC   0(8,R15),PDS2NAME-PDS2(R2) Get member name\n         MVI   8(R15),C' '                Ensure delimiter is not there\n         BAS   R14,ENSURE_PRINTABLE_MEMNAME Ensure good member name\n         CLI   8(R15),C'/'                Found an invalid member name?\n         BNE   PPD$UPRTX                  No, continue\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG40L,R15),MSG40-PDSR$MSG(R1) Move in message\n         LA    R15,MSG40L+1(R15)          Bump past it\n         MVC   0(#EPML,R15),SLACKR        Get whole string\n         LA    R15,#EPML+1(R15)           bump past it\n         MVC   0(7,R15),=C'at TTR='       Insert verbage\n         LA    R15,7(R15)                 Bump past it\n         UNPK  0(7,R15),PDS2TTRP-PDS2(4,R2) |\n         MVZ   0(6,R15),ZEROS               |> Hex convert\n         TR    0(6,R15),HEXTABLE            |\n         MVI   6(R15),C' '                Fix byte after convert\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print message\nPPD$UPRTX EQU  *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Check for Load error\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         TM    PPD_FLAG2,$PPD_F2LOADERR\n         BNO   PDD$MPLEX\n         BAS   R14,FORMAT_MESSAGE         Initialize the message area\n         MVC   0(MSG30L,R15),MSG30-PDSR$MSG(R1) Move in message\n         LA    R15,MSG30L(R15)\n         MVC   0(8,R15),PDS2NAME-PDS2(R2)\n         LA    R0,8\n         BAS   R14,LOCATE_FIRST_SPACE\n         MVC   0(9,R15),=C', ABEND=S'\n         LA    R15,9(R15)\n         UNPK  0(4,R15),PPD_ABEND+2(3)\n         MVZ   0(4,R15),ZEROS\n         TR    0(4,R15),HEXTABLE\n         LA    R15,3(R15)\n         MVC   0(16,R15),=C', Reason code is'\n         LA    R15,17(R15)\n         UNPK  0(9,R15),PPD_ABENDR(5)\n         MVZ   0(8,R15),ZEROS\n         TR    0(8,R15),HEXTABLE\n         MVI   8(R15),C' '\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         MVI   LASTCC,$WARN\n         NI    PPD_FLAG2,255-$PPD_F2LOADERR\nPDD$MPLEX EQU  *\n SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Bump to next member/PDS directory block\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n SPACE 2\nPPD$MB   EQU   *\n         AH    R2,PPD_DIRENTL             Locate to next entry\n         C     R2,PPD_EOB                 End of block?\n         BL    PPD$MEM                    No, process next member\n         B     PPD$GET                    Yes, read next directory blk\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Common Exit from Process_PDS_Directory\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPD$X    EQU   *\n         L     R14,PPD_RA                 Get return address\n         BSM   0,R14                      Leave\n         EJECT\n***********************************************************************\n***\n**                     Process Load Module\n***\n***********************************************************************\n         SPACE 2\nPROCESS_LOAD_MODULE EQU *\n         ST    R14,PLM_RA                 Save return address\n*\n** Read module record\n*\n         POINT SYSMEM,PPD_TTR             POINT TO PDS DATA BLOCK\nPLM$READ EQU   *\n         LA    R1,PLM_DECB                Locate DECB\n         XC    DECSDECB-DECB(4,R1),DECSDECB-DECB(R1) Clear ECB\n*\n         L     R4,PP_PDSBUF+4\n         READ  (1),SF,                    GET LOAD MODULE RECORD       @\n               SYSMEM,(4),'S',MF=E\n         CHECK PLM_DECB                   CHECK FOR ERRORS\n*\n         TM    PPD_FLAG2,$PPD_F2SYNAD\n         BO    PLM$X                      YES, MOVE ON\n*\n** Check for record type\n*\n         CLI   0(R4),B'10000000'          CSECT ID record (IDR)?\n         BE    IDRREC\n*        CLI   0(R4),B'00100000'          CESD?\n*        BE    CESD\n         TM    0(R4),1                    Is record before a text one?\n         BNO   PLM$READ                   No, read next block\n*\n** End of member found\n*\nPLM$X    EQU   *\n         L     R14,PLM_RA                 Get return address\n         BSM   0,R14                      Return to caller\n         EJECT ,\n***********************************************************************\n***\n**       CSECT Identification record: IDR\n***\n***********************************************************************\n         SPACE 2\nIDRREC   EQU   *\n*\n** What kind of IDR record?\n*\n         TM    2(R4),B'00000010'          Linkage Editor?\n         BO    IDR$LNK                    Yes, try it out\n*\n         TM    W_FLAG1,$W_F1DFSMS         Are we DFSMS/MVS?\n         BNO   IDR$CX                     No, read other types\n         TM    PPD_FLAG2,$PPD_F2NBLINFO   Doing binder/lked info?\n         BO    IDR$LX\n         CLC   W_DFARELS(4),=X'01010100'  DFSMS/MVS?\n         BH    IDR$LX                     Yes, skip other types\nIDR$CX   DS    0H\n*\n         TM    2(R4),B'00000001'          AMASPZAP?\n         BO    IDR$ZAP\nIDR$LX   DS    0H\n         B     PLM$READ                   GET NEXT BLOCK\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** AMASPZAP record\n**\n**  +--------------------------+     +-------------------------+\n**  | 85/07/30    Z5091001     |     | 88/02/11    NO IDENT    |\n**  | ......e..Z5091001....... |     | ......h..NO IDENT...... |\n**  | 8F0000821EFFFFFFF0000000 |     | 8F0000802DD4CCCDE000000 |\n**  | 0A110551F950910010000000 |     | 0A110E84F56094553000000 |\n**  +--------------------------+     +-------------------------+\n**\n**  ......i..Z5181406..i.|Z5183260..i.|Z5186377..i.|Z5186135.. ...\n**  8F0002811EFFFFFFF02834EFFFFFFF03834EFFFFFFF00834EFFFFFFF00 ...\n**  0A1F0990F951814060E92F951832600D92F951863770992F9518613509 ...\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIDR$ZAP  EQU   *\n         SLR   R14,R14                    Clear register\n         IC    R14,3(,R4)                 Get number of zaps\n         N     R14,=F'63'                 Turn off unneeded bits\n         LTR   R14,R14                    Still more than 0\n         BZ    PLM$READ                   No, ignore it\n         CVD   R14,DOUBLE                 Change to packed decimal\n         LA    R1,RECOUT+1                Locate output line\n         MVC   DET_LZAP-DET(4,R1),EDPAT4  Get edit pattern\n         ED    DET_LZAP-DET(4,R1),DOUBLE+6 Edit zap count\n*\n** Count total number of modules that have been zapped\n*\n         L     R1,PPD_NUMZAP              Get current number\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PPD_NUMZAP              Save new number\n*\n** Zap report - Print member name, date and data if option is set.\n*\n         TM    PPC_FLAG3,$PPC_F3ZAPRPT    Zap report?\n         BNO   PLM$READ                   No, process next record\n         LR    R8,R14                     Get count\n         LA    R7,5(R4)                   Locate first entry\nIDR$ZAPL EQU   *\n*-Clear the output record and get the member name\n         MVI   SLACKR,C' '                Get Blank\n         MVC   SLACKR+1(132),SLACKR       Propagate blank\n         LA    R15,SLACKR\n         MVC   1(8,R15),PDS2NAME-PDS2(R2) Move in record\n         LA    R15,1+8+1(R15)             Bump past member area\n*-Output the zap date\n         MVC   0(10,R15),=C'Zapped on:'\n         LA    R15,11(R15)\n         MVI   EJ_IDJULP4_STR,0           This century = 19\n         MVC   EJ_IDJULP4_STR+1(3),IDRZAPE_DATE-IDRZAPE(R7)\n         ST    R15,EJ_ODDOW3A_STR         Save output area for DOW\n         LA    R15,3+1(R15)               Bump past Day of the week\n         ST    R15,EJ_ODGEUR11A_STR       Save output area for Greg\n         BAS   R9,EDIT_JULIAN             Edit Julian to output\n         L     R15,EJ_ODGEUR11A_STR       Get start of Gregorian Date\n         LA    R15,11(R15)                Bump past it\n         MVC   0(4,R15),=X'40,20,20,20'   Get edit pattern for DOY\n         ED    0(4,R15),IDRZAPE_DATE+1-IDRZAPE(R7)\n         MVI   0(R15),C'.'\n         OI    1(R15),C'0'\n         OI    2(R15),C'0'\n         LA    R15,5(R15)                 Bump past \" DDD \"\n*-Output the AMASPZAP Data field if found\n         MVC   0(5,R15),=C'Data:'\n         LA    R15,5(R15)\n         LA    R7,IDRZAPE_NAME-IDRZAPE(R7) Locate start of name\nIDR$ZAPIL EQU  *\n         MVC   0(1,R15),0(R7)             Move byte\n         LA    R15,1(R15)                 Bump to next output byte\n         LA    R7,1(R7)                   Bump to next input byte\n         CLI   0(R7),X'40'                End of name?\n         BNL   IDR$ZAPIL                  Yes, continue\n         LA    R7,1(R7)                   Bump past zero byte\n*-Print record\n         PUT   ZAPRPT,SLACKR              Print record\n*-Try next zap entry\n         BCT   R8,IDR$ZAPL                Do next zap entry\n         B     PLM$READ                   Process next record\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Linkage editor record\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIDR$LNK  EQU   *\n         TM    15+2(R4),X'0F'             Ends with valid packed sign?\n         BNO   IDR$INVALID_LINKDATE       No, gripe about it\n*\n** Search for this linkage editor in translator table\n*\n         LA    R15,RECOUT+1\n         TM    PPC_FLAG4,$PPC_F4NTRANID          Don't translate PID?\n         BO    IDR$LNK$CSTLX                     Yes, just insert PID\n         L     R1,=V(PDSR$TRT)                   Locate CSECT\n         LA    R1,T_LINKT-PDSR$TRT(R1)           Locate table\n         LA    R0,T_LINKTN                       Get number of entries\nIDR$LNK$CSTL DS 0H\n         CLC   3(8,R4),TLT_ID-TLT(R1)            PID match?\n         BE    IDR$LNK$CSTLF                     Yes, continue\n         LA    R1,TLTL(R1)                       No, bump to next entry\n         BCT   R0,IDR$LNK$CSTL                   ..and process it\nIDR$LNK$CSTLX DS 0H\n         MVC   DET_LTNAME-DET(10,R15),3(R4)      Insert PID\n         B     IDR$LNK$CSTX                      Continue\nIDR$LNK$CSTLF DS 0H\n         MVC   DET_LTNAME-DET(L'TLT_NAME,R15),TLT_NAME-TLT(R1)\nIDR$LNK$CSTX DS 0H\n*\n** Format the link date\n*\nIDR$LNK_DATE EQU *\n         MVI   EJ_IDJULP4_STR,0           This century = 19\n         MVC   EJ_IDJULP4_STR+1(3),15(R4) Get \"YYDDDF\"\n         LA    R1,RECOUT+1+DET_LTD_DATE-DET\n         ST    R1,EJ_ODGEUR11A_STR\n         LA    R1,RECOUT+1+DET_LTD_DOW-DET\n         ST    R1,EJ_ODDOW3A_STR\n         BAS   R9,EDIT_JULIAN             Edit Julian to output\n         B     PLM$READ                   Process next one\n*\n** Link date is invalid or missing\n*\nIDR$INVALID_LINKDATE EQU *\n L     R1,=V(PDSR$C2)                     -> Constant CSECT\n MVC RECOUT+1+DET_LTD_DATE-DET(L'DET_LTD_DATE),C_BLANKS+1-PDSR$C2(R1)\n MVC RECOUT+1+DET_LTD_DATE-DET+3(9),=C'-Missing-'\n B     PLM$READ                           Read next record\n SPACE 2\n         EJECT\n***********************************************************************\n***\n**       Sort file WRKFILE1 into WRKFILE2 based on Sort field\n**\n**       Input: R1 has sort field string\n***\n***********************************************************************\n         SPACE 2\nSORT_FILE DS   0H\n         ST    R14,SF_RA                  Save return address\n*\n** Create SORT control card string\n*\n         BAS   R14,CLEAR_RECOUT           Clear string area to blanks\n         LA    R15,RECOUT+3               Locate SORT statement start\n         MVC   0(13,R15),=C'SORT FIELDS=(' Text\n         LA    R15,13(R15)                Bump past it\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R1)                  Get length\n         EX    R14,SF$MSF                 Move in sort fields\n         LA    R15,1(R14,R15)             Bump past sort fields\n         MVC   0(16,R15),=C') OPTION SORTIN=' Text\n         LA    R15,16(R15)                Bump past it\n         MVC   0(8,R15),=CL8'WRKFILE1'    WRKFILE1 DDNAME\n         LA    R0,8                       Max length of DDNAMe\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n*\n         MVC   0(9,R15),=C',SORTOUT='     Text\n         LA    R15,9(R15)                 Bump past it\n         MVC   0(8,R15),=CL8'WRKFILE2'    WRKFILE2 DDNAME\n         LA    R0,8                       Max length of DDNAME\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n*\n         LR    R5,R15                     Save location on record\n         DEVTYPE =CL8'SORTWK01',DOUBLE    User specified files for us?\n         LTR   R15,R15                    Have at least one?\n         BZ    SF$DSWX                    Yes, continue\n         LR    R15,R5                     Get location on record\n         MVC   0(11,R15),=C',DYNALLOC=('  Text\n         LA    R15,11(R15)                Bump past it\n         MVC   0(8,R15),PPC_WUNIT\n         LA    R0,8                       Max length of DDNAME\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n         MVC   0(3,R15),=C',3)'           Text\n         LA    R15,3(R15)                 Bump past it\n*\n         MVC   0(8,R15),=C',MSGDDN='      Text\n         LA    R15,8(R15)                 Bump past it\n         MVC   0(8,R15),=CL8'WRKFILE3'    Sort message DDNAME\n         LA    R0,8                       Max length of DDNAME\n         BAS   R14,LOCATE_FIRST_SPACE     Locate the first space\n         LR    R5,R15\nSF$DSWX EQU    *\n*\n** Calcluate the length of the SORT control statement generated\n*\n         LA    R14,RECOUT+1               Locate Beginning\n         SR    R5,R14                     Length = End - Beginning\n         STCM  R5,B'0011',RECOUT          Save length of SORT statement\n*\n** Invoke the SORT\n*\n         SLR   R5,R5                      Set pseudo return code\n         LA    R1,PARMLIST                Locate parameter list\n         LA    R15,RECOUT                 Locate control statements\n         ST    R15,0(R1)                  Save it into parm list\n         MVC   4(4,R1),=X'FFFFFFFF'       Set end of list\n         LINK  EP=SORT,ERRET=SF$LINKE     Link to sort\n         LTR   R15,R15                    Okay?\n         BNZ   SF$ERR                     Yes, leave\n         DEVTYPE =CL8'SORTDIAG',DOUBLE    Get file information\n         LTR   R15,R15                    File allocated?\n         BZ    SF$ECHO                    Yes, user wants sort info\n         B     SF$X                       No, clean sort: leave\n*\n** Error routines\n*\nSF$ERR   EQU   *\n         LR    R5,R15                     Save return code from Sort\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG81L,R15),MSG81-PDSR$MSG(R1) Move in message\n         LA    R15,MSG81L+1(R15)          Bump past it\n         MVC   0(3,R15),=C'RC='           Move in Text\n         LA    R15,3(R15)                 Bump past it\n         LR    R1,R5                      Get RC\n         BAS   R9,EDITFWF                 Edit it\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print sysprint record\n         B     SF$ECHO                    Yes, leave\nSF$LINKE EQU   *\n         ST    R1,DOUBLE                  Save ABEND code\n         ST    R15,DOUBLE+4               Save reason code\n         BAS   R14,FORMAT_MESSAGE         Clear recout to blanks\n         MVC   0(MSG81L,R15),MSG81-PDSR$MSG(R1) Move in message\n         LA    R15,MSG81L+1(R15)          Bump past it\n         MVC   0(6,R15),=C'ABEND='        Move in Text\n         LA    R15,6(R15)                 Bump past it\n         LA    R1,DOUBLE                  Point to ABEND code Fullword\n         BAS   R9,FORMAT_ABEND            Format the ABEND code\n         MVC   0(9,R15),=C', Reason='     Insert text\n         LA    R15,9(R15)                 Bump past it\n         UNPK  0(9,R15),DOUBLE+4(5)\n         MVZ   0(8,R15),ZEROS\n         TR    0(8,R15),HEXTABLE\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print sysprint record\n         LA    R5,20                      Set our return code to NZERO\n*\n** Echo the sort messages to SYSPRINT\n*\nSF$ECHO  EQU   *\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         MVC   RECOUT(133),C_EQUALS-PDSR$C2(R1)\n         MVC   RECOUT+132-C_SFSTRTL(C_SFSTRTL),C_SFSTRT-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         LA    R3,WRKFILE3                Locate DCB work area\n         L     R1,=V(PDSR$C1)\n         MVC   0(C_DCBIL,R3),C_DCBI-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'WRKFILE3'\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)\n         LA    R2,SF$ELX                  Locate END-OF-FILE area\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\n         BAS   R14,CLEAR_RECOUT\nSF$EL    EQU   *\n         GET   WRKFILE3\n         MVC   RECOUT+1(120),1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD\n         B     SF$EL\nSF$ELX   EQU   *\n         LA    R3,WRKFILE3\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\n*\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         MVC   RECOUT(133),C_EQUALS-PDSR$C2(R1)\n         MVC   RECOUT+132-C_SFENDL(C_SFENDL),C_SFEND-PDSR$C1(R1)\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\n*\n         BAS   R14,CLEAR_RECOUT           Clear record to blanks\n         BAS   R14,PRINT_SYSPRINT_RECORD  Print the record\nSF$EX    EQU   *\n*\n** Common exit from Sort_File\n*\nSF$X     EQU   *\n         LR    R15,R5                     Get return code from Sort\n         L     R14,SF_RA                  Get return address\n         BSM   0,R14                      Return to caller\n*\n** Executed instructions\n*\nSF$MSF   MVC   0(0,R15),1(R1)             Get fields\n         EJECT\n***********************************************************************\n***\n**       MISC Internal Subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Close file\n**\n** Input: R3 points to DCB\n*\nCLOSE_FILE EQU *\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?\n         BNO   CF$X\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\nCF$X     EQU   *\n         BSM   0,R9\n*\n** Edit full word in Register 1 flush at location in Register 15\n** with no commas\n**\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITNCF  EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITNCF0                   YES, PUT ZERO\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n**\n LA    R1,DOUBLE2+7               LOCATE SIG DIGIT\n MVC   DOUBLE2(8),EDITNCFP\n EDMK  DOUBLE2(8),DOUBLE+4        EDIT AND SAVE PLACE\n LA    R14,DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1\n**\n*        LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n*        MVC   DOUBLE2(15),EDITNCFP\n*        EDMK  DOUBLE2(15),DOUBLE+2        EDIT AND SAVE PLACE\n*        LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,EDITNCFM               MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '\n         BSM   0,R9                       RETURN TO CALLER\nEDITNCFM MVC   0(0,R15),0(R1)\nEDITNCFP DC    X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'\nEDITNCF0 DS    0H\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R9                       RETURN TO CALLER\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      Check for 0\n         BZ    EDITFWF0                   Yes, put zero\n         CVD   R1,DOUBLE                  No, convert to packec\n         LA    R1,DOUBLE2+14              Locate sig digit\n         MVC   DOUBLE2(15),EDITFWFP\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for ex\n         EX    R14,EDITFWFM               Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '\n         BSM   0,R9                       Return to caller\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Put in zero\n         LA    R15,1(R15)                 Bump pointer past zero\n         BSM   0,R9                       Return to caller\n*\n** CONVERT BINARY TIME TO PRINT\n** INPUT: R1  - TIME TO CONVERT\n**        R15 - OUTPUT LOCATION\n*\nCONVERT_BINARY_TIME EQU *\n         SLR   R0,R0                      Clear register\n         D     R0,=F'100'                 Divide out 100ths of second\n         SLR   R0,R0                      Clear register\n         D     R0,=F'60'                  Divide out seconds\n         CVD   R0,DOUBLE                  Convert seconds to packed\n         UNPK  6(3,R15),DOUBLE+6(2)       Save seconds\n         OI    6+2(R15),C'0'              Fix sign byte\n         MVI   6(R15),C':'                Colon\n         SLR   R0,R0                      Clear register\n         D     R0,=F'60'                  Divide out minutes\n         CVD   R0,DOUBLE                  Convert minutes to packed\n         UNPK  3(3,R15),DOUBLE+6(2)       Save minutes\n         OI    3+2(R15),C'0'              Fix sign byte\n         MVI   3(R15),C':'                Colon\n         CVD   R1,DOUBLE                  Convert minutes to packed\n         UNPK  0(3,R15),DOUBLE+6(2)       Save hours\n         OI    0+2(R15),C'0'              Fix sign byte\n         MVI   0(R15),C' '                Leading space\n         BSM   0,R14                      Return to caller\n*\n** Point Register 15 to the first blank in a string\n** Input:  R0  - Maximum length of the string\n**         R15 - String\n** Output: R15 - First space in the string\n*\nLOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '                Blank?\n         BE    LFS$X                      Yes, leave\n         LA    R15,1(R15)                 No, bump to next byte\n         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat\nLFS$X    EQU   *\n         BSM   0,R14                      Return to caller\n*\n** Obtain PDSRCMD data area\n*\n         AIF   ('&IHADFARELS' LT '01010100').RCMOX\nOBTAIN_PDSRCMD DS 0H\n         ST    R14,DOUBLE                 Save return address\n         ICM   R1,B'1111',A_PDSRCMD+4     Get address of area\n         BNZ   OPRC$X                     Already have it, leave\n         LA    R0,PDSRCMDL                Need to get it, get length\n         GETMAIN R,LV=(0)                 Obtain area below the line\n         STM   R0,R1,A_PDSRCMD            Save length and address\n         LA    R14,PSRAREA                Locate work area for SYSPRINT\n         ST    R14,PDSRCMD_PSRAREA-PDSRCMD(R1) Save it for later\nOPRC$X   DS    0H\n         L     R14,DOUBLE                 Get return address\n         BSM   0,R14                      Return to caller\n.RCMOX   ANOP  ,\n*\n** Format common part of Open ABEND message\n**\n** Input: R8 has DDNAME\n**        DOUBLE - RC from OPEN\n**        OX_CODE - OPEN abend code\n*\nFORMAT_OPEN_ABEND_MSG EQU *\n         ST    R14,FOAM_RA                Save return code\n         MVC   0(8,R15),0(R8)             Get DD name\n         LA    R0,8                       Set DD name length\n         BAS   R14,LOCATE_FIRST_SPACE     Find first space\n         CLC   DOUBLE(4),ZEROS\n         BE    FOAM$RCX\n         MVC   0(5,R15),=C', RC='         Get return code text\n         LA    R15,5(R15)                 Bump past it\n         L     R1,DOUBLE                  Get RC from OPEN\n         BAS   R9,EDITFWF                 Edit it\nFOAM$RCX EQU   *\n         CLC   OX_CODE(4),ZEROS           Did we ABEND?\n         BE    FOAM$CX                    No, continue\n         MVC   0(9,R15),=C', ABEND=S'     Insert text\n         LA    R15,9(R15)                 Bump past it\n         UNPK  DOUBLE2(9),OX_CODE(5)      >\n         MVZ   DOUBLE2(8),ZEROS           >> Hex translate\n         TR    DOUBLE2(8),HEXTABLE        >\n         MVC   0(6,R15),DOUBLE2           Get \"AAARRR\" ABEND/RETURN C.\n         MVI   3(R15),C'-'                Insert dash\nFOAM$CX  EQU   *\n         L     R14,FOAM_RA                Get return code\n         BSM   0,R14                      Return to caller\n*\n** Format ABEND\n** Input: R1 - ABEND code\n**        R15 - Output for formated ABEND\n*\nFORMAT_ABEND EQU *\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',1(R1)          Get ABEND code\n         SRA   R14,4                      Clear out user ABEND nibble\n         LTR   R14,R14                    Anything there?\n         BZ    FA$U                       No, this is a user ABEND\n         MVI   0(R15),C'S'                Indicate System ABEND\n         UNPK  1(5,R15),1(3,R1)\n         MVZ   1(4,R15),ZEROS\n         TR    1(4,R15),HEXTABLE\n         MVI   4(R15),C' '                Fix byte after hex trans\n         LA    R15,4(R15)                 Bump past \"S###\"\n         B     FA$X                       Leave\nFA$U     EQU   *\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',2(R1)          Get User ABEND\n         CVD   R14,DOUBLE2                Make number packed\n         MVI   0(R15),C'U'                Indicate User ABEND\n         UNPK  1(4,R15),DOUBLE2+5(3)      Make number zoned\n         OI    1+3(R15),C'0'              Fix Sign byte\n         LA    R15,5(R15)                 Bump past \"U####\"\nFA$X     EQU   *\n         BSM   0,R9\n*\n** Initialize message\n**\n** Output: R1 has PDSR$MSG\n*\nFORMAT_MESSAGE DS 0H\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(L'RECOUT-1,R15),0(R15)\n         LA    R15,1(R15)\nFM$PRE   DS    0H\n         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT\n         MVC   0(7,R15),5(R12)            Move in \"DA$PDSR\"\n         MVI   7(R15),C'-'                Insert dash\n         LA    R15,MSGPREL(R15)           Bump past \"DA$PDSR-\"\n         BSM   0,R14\nMSGPREL  EQU   7+1                        \"DA$PDSR-\"\n*\n** Edit input Julian to output area\n**\n** Keep in sync with IS$EDIT_JULIAN: use same code!!!!!!\n*\nEDIT_JULIAN EQU *\n         L     R1,=V(PDSR$C1)\n         MVC   EJ_IDJULP4(C_IDJULP4L),C_IDJULP4-PDSR$C1(R1)\n         MVC   EJ_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-PDSR$C1(R1)\n         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?\n         BO    EJ$CDISO\n         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?\n         BNO   EJ$CDISOX                  Use default of \"European\"\n         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODGUS Make Gregorian US\n         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODGUS10 Set length\n         B     EJ$CDISOX\nEJ$CDISO DS 0H\n         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODISO Make ISO\n         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODISO10 Set length\nEJ$CDISOX DS 0H\n         MVC   EJ_ODDOW3A(C_ODDOW3AL),C_ODDOW3A-PDSR$C1(R1)\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine\n         CALL  (15),(EJ_IDJULP4,EJ_ODGEUR11A,EJ_ODDOW3A),              @\n               VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n         BSM   0,R9\n*\n** Edit fullword\n**  INPUT:  R1  ADDRESS OF FULLWORD\n**  OUTPUT: R15 ADDRESS OF OUTPUT (12 BYTES)\n*\nEDITFW12 EQU   *\n         CVD   R1,DOUBLE\n         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'\n         ED    0(12,R15),DOUBLE+3\n         BSM   0,R9\n*\n** Set up Abend exit into DCB at R3\n*\nSET_ABEND_EXIT EQU *\n         LA    R15,OX_EXLST               Locate our EXLST\n         STCM  R15,B'0111',DCBEXLST-IHADCB+1(R3)  Save into DCB\n         LA    R1,E$OPEN                  Locate our DCB abend routine\n         ST    R1,OX_EXLST                Place into EXLST\n         OI    OX_EXLST,X'11'             <- DCB exit\n         OI    OX_EXLST,X'80'             <- End of list\n         XC    OX_CODE(4),OX_CODE         Clear the open abend code\n         BSM   0,R14\n*\n** Check for open abend\n*\nCHECK_OPEN_ABEND EQU *\n         CLC   OX_CODE(4),ZEROS           Open failed?\n         BNE   E$OPENG                    Yes, forget it\n         LTR   R15,R15                    Open okay?\n         BNZ   E$OPENG                    Yes, move on\n         BSM   0,R14\n*\n** Ensure that member (or any 8 byte area) has only valid characters\n**\n** Input: R15 - 8 byte member name with 18 bytes for hex conversion\n**\n** Note: We save R2 because TRT *DESTROYS* R2\n*\nENSURE_PRINTABLE_MEMNAME EQU *\n         ST    R14,EPM_REGS               Save return address\n         ST    R2,EPM_REGS+4              Save this register (TRT)\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         TRT   0(8,R15),C_TABPRT-PDSR$C2(R1) Valid characters only?\n         BZ    EPM$X                      Yes, leave\n         MVI   8(R15),C'/'                Insert delimiter\n         UNPK  9(9,R15),0(5,R15)          >>\n         MVZ   9(8,R15),ZEROS             >>> Convert first 4 bytes\n         TR    9(8,R15),HEXTABLE          >>\n         UNPK  9+8(9,R15),4(5,R15)        <<\n         MVZ   9+8(8,R15),ZEROS           <<< Convert last 4 bytes\n         TR    9+8(8,R15),HEXTABLE        <<\n         MVI   9+8+8(R15),C' '            Fix last byte\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         TR    0(8,R15),C_TRTABM-PDSR$C2(R1) Translate to valid...\nEPM$X    EQU   *\n         L     R2,EPM_REGS+4              Restore this register\n         L     R14,EPM_REGS               Get return address\n         BSM   0,R14                      Return to caller\n#EPML    EQU   8+1+16                     Length of total area\n*\n** Print record on file SYSPRINT\n*\nPRINT_REPORT_RECORD EQU *\n         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary\n         BO    PRR$SIMCX\n         TM    PPC_FLAG1,$PPC_F1SIMULATE  Stimulate mode?\n         BO    PRR$SIMX                   Yes, leave\nPRR$SIMCX DS   0H                         Only for simulate exit\n         ST    R14,PRR_RA                 Save return address\n*\n         LA    R1,SUBRSA                  Locate register save area\n         L     R15,=V(PDSR$PRR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         L     R14,PRR_RA                 Get return address\nPRR$SIMX EQU   *                          Only for simulate exit\n         BSM   0,R14                      Return to caller\n*\n** Print record on file SYSPRINT\n*\nPRINT_SYSPRINT_RECORD EQU *\n         ST    R14,PSR_RA                 Save return address\n*\n         LA    R0,PSRAREA                 Locate work area\n         LA    R1,RECOUT   (assumed)      Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         L     R14,PSR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Clear output record to blanks\n*\nCLEAR_RECOUT  EQU *\n         LA    R15,RECOUT                 Locate output record\nCR$PTR   EQU   *\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         BSM   0,R14                      Return to caller\n         EJECT ,\n***********************************************************************\n***\n**              Locate the JFCB from the TIOT entry\n**\n**  Starting with MVS 2.2 fields in the SWA must be located with the\n**  IEFQMREQ or SWAREQ macros.  Fields such as the TIOEJFCB have a SVA\n**  (SWA_Virtual_Address) which can not be considered the Virtual\n**  Storage address but an index to be used in locating the control\n**  Block.\n**\n**     Note: The SWAREQ macro will only execute/expand on a MVS\n**               2.2 system or higher.\n**\n**     Input: R14 - TIOT entry\n**\n**     Output: R15 - JFCB address\n**             or 0 if the JFCB could not be found...\n***\n***********************************************************************\n SPACE 2\nLOCATE_JFCB EQU *\n         DA#SMODE 31                      Must be in 31 bit mode\n         LA    R1,W_AREA                  Locate start of EPA\n         ST    R1,DOUBLE                  Save address\n         XC    0(L'SWAEPAX,R1),0(R1)      Clear area to zeros\n         MVC   SWVA-ZB505(3,R1),TIOEJFCB-TIOENTRY(R14) Get SVA\n         MVI   SWBLKID-ZB505(R1),SWJFCBID Indicate we need JFCB\n         L     R15,=V(PDSR$C1)            Locate constants area\n         MVC   PARMLIST(C_SWAREQL),C_SWAREQ-PDSR$C1(R15)\n        SWAREQ FCODE=RL,                  Locate JFCB                  @\n               EPA=DOUBLE,                ..EPA pointer                @\n               UNAUTH=YES,                ..Unauthorized acess         @\n               MF=(E,PARMLIST)            ..Execute from here\n         LTR   R15,R15                    Successful?\n         BNZ   LJ$SWAE                    No, branch to error\n         LA    R1,W_AREA                  Locate start of EPA\n         L     R15,SWBLKPTR-ZB505(R1)     Locate the control Block\n         B     LJ$X                       Return to caller\nLJ$SWAE  DS    0H\n         SLR   R15,R15                    Indicate no JFCB\nLJ$X     DS    0H\n         DA#SMODE 24                      Get back to 24 bit mode\n         BSM   0,R9                       Return to caller\n         EJECT ,\n***********************************************************************\n***\n**       SYNAD Error routine for member reads\n***\n***********************************************************************\n         SPACE 2\nSMSYNAD  EQU   *\n         STM   R12,R14,PARMLIST\n         SYNADAF ACSMETH=BPAM\n*\n         MVC   SYNADMSG(78),50(R1)      Save error message\n         OI    PPD_FLAG2,$PPD_F2SYNAD   Turn on flag\n*\n         SYNADRLS ,\n*\n         LM    R12,R14,PARMLIST\n         BR    R14\n         EJECT\n***********************************************************************\n***\n**       Constants\n***\n***********************************************************************\n         SPACE 2\n         DS    0F\nZEROS    DC    X'00,00,00,00,00,00,00,00'\nHEXTABLE DC    C'0123456789abcdef'\nEDPAT4   DC    X'40,20,20,20'\nC_CLDSN  DC    AL1(7),C'DATASET'\nC_SFCFD  DA#STR '1,10,CH,A'\n*\n** Literals - To get more room, more of these LTORG values could\n**            be moved to one of the constants CSECTs\n*\n         PRINT DATA\nLTORG    LTORG ,\nLTORGL   EQU   *-LTORG\n         PRINT NODATA\n*\n** Calculate length of main CSECT\n*\n         DS    0D                         End on double word boundry\nDA$PDSRL EQU   *-DA$PDSR                  Length of program\nDA$PDSRB EQU   (3*4096)-DA$PDSRL          Bytes left addressable\n         DS    0D\n         DROP  R13,R12,R11,R10\n         EJECT\n***********************************************************************\n***\n**   APF library check\n**\n**   See if the current library is APF authorized by setting the\n**   flag PPD_FLAG1,$PPD_F1APF on\n**\n** Question: Would it be less overhead in MVS 4.3 and higher to\n**           just do a REQUEST=QUERY for each dataset instead of\n**           obtaining the full list and then looking at it each\n**           time?\n***\n***********************************************************************\n         SPACE 2\nPDSR$APF CSECT ,\nPDSR$APF AMODE 24\nPDSR$APF RMODE 24\n*\n** Standard O/S eyecatcher\n*\nAPF_EC         B    APF_ECL(0,R15)         Bump past EyeCatcher\n               DC   AL1(L'APF_ECLIT)       Length of eyecatcher\nAPF_ECLIT      DC   C'PDSR$APF - APF library check'\n               DS   0H\nAPF_ECL        EQU  *-APF_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$APF,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R1                     Get register save area\n         USING SUBRSA,R13\n*\n** If at MVS ESA SP4.3.0 or higher, we might have a dynamic list\n*\n         L     R3,CVTPTR                  -> CVT\n         L     R3,CVTAUTHL-CVTMAP(R3)     -> Authorized Library Table\n         CLC   W_BCPLEVEL(5),=C'SP4.3'    At MVS/ESA 4.3 or higher\n         BL    APF$43B                    No, continue\n         C     R3,=X'7FFFF001'            Dynamic APF?\n         BNE   APF$43O                    No, it's static\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** We are at MVS ESA SP4.3.0 or higher, and we have a dynamic list\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         AIF   (NOT D'CVTH4430).APF43E    .MVS 4.3 or higher maclib?\n         DA#SMODE 31\n         TM    W_FLAG1,$W_F1APFDYN        Did we already get it?\n         BO    APF$DYNOK\n         OI    W_FLAG1,$W_F1APFDYN        Turn on flag that we did\n#APFEL EQU L'APFEDSNAME+(APFEDSNAME-APFE)+12  entry len + slack\n#APFL  EQU 4096*#APFEL                    Length to get\n L     R0,=AL4(#APFL)                     Get length to acquire\n GETMAIN RU,LV=(0),LOC=(ANY,ANY)\n STM   R0,R1,APF_DYN                      Save Length Address\n*\n LR    R4,R1                              Locate to output location\n LA    R5,APF_DYN                         Locate length we got\n CSVAPF REQUEST=LIST,                     Get the APF List             @\n               ANSAREA=(4),ANSLEN=(5),    ..Answer area and length     @\n               RETCODE=APF_LRETCODE,      ..Return code                @\n               RSNCODE=APF_LRSNCODE,      ..Reason code                @\n               MF=(E,PARMLIST)           ..Parameter list area\n CLC   APF_LRETCODE,=AL4(CSVAPFRC_OK)    Success?\n BE    APF$DYNOK                         Yes, process data\n CLC   APF_LRETCODE,=AL4(CSVAPFRC_WARN) Warning?\n BNE   APF$DYNOK                         Yes, process data\n NC    APF_LRSNCODE,=AL4(CSVAPFRSNCODEMASK)     Clear high order bits\n CLC   APF_LRSNCODE,=AL4(CSVAPFRSNNOTALLDATARETURNED)      More data?\n*BE    ...\nAPF$DYNOK DS 0H\n L     R3,APF_DYN+4                       Get address of list\n L     R2,APFH#REC-APFHDR(R3)             Get number of entries\n L     R1,APFHOFF-APFHDR(R3)              Offset to first entry\n AR    R3,R1                              Locate to first entry\n LA    R4,AREAJFCB                        Locate JFCB\nAPF$DYNL DS 0H\n CLC   APFEVOLUME-APFE(6,R3),JFCBVOLS-INFMJFCB(R4) Volumes match?\n BNE   APF$DYNLB\n SLR   R1,R1\n IC    R1,APFEDSLEN-APFE(R3)\n BCTR  R1,0\n EX    R1,APF$DYNLC\n BNE   APF$DYNLB\n OI    PPD_FLAG1,$PPD_F1APF               Indicate APF library\n B     APF$DYNX\n*\nAPF$DYNLB DS 0H\n LH    R1,APFELEN-APFE(R3)                Get length of this entry\n AR    R3,R1                              Locate next entry\n BCT   R2,APF$DYNL                        Repeat\nAPF$DYNX  DS 0H\n DA#SMODE 24\n B     APF$X\nAPF$DYNLC CLC  APFEDSNAME-APFE(0,R3),JFCBDSNM-INFMJFCB(R4)\n         AGO   .APF43EX\n.APF43E  ANOP  ,\n         OI    W_FLAG1,$W_F1APFLSTD       Turn on flag that we couldn't\n         B     APF$X\n.APF43EX ANOP  ,\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Process the static APFLST\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** We are at MVS ESA SP4.3.0 or higher and the APFLST is static\n*\nAPF$43O  DS    0H\n         SLR   R2,R2                      Clear register\n         ICM   R2,B'0011',0(R3)           Get Library count\n         LA    R3,2(R3)                   Bump to first entry\n         B     APF$43BX\n*\n** We are at an MVS before SP4.3.0, it's static (of course)\n*\nAPF$43B  DS    0H\n         SLR   R2,R2                      Clear register\n         ICM   R2,B'0001',0(R3)           Get library count\n*        ICM   R2,B'0011',0(R3)           Get Library count\n         LA    R3,2(R3)                   Bump to first entry\nAPF$43BX DS    0H\n*\n** Loop thru the Static APF list looking for our dataset\n*\n         LA    R4,AREAJFCB                Locate JFCB\nAPF$ALL  DS    0H\n         CLC   1(6,R3),JFCBVOLS-INFMJFCB(R4) Volumes match?\n         BNE   APF$ALLB                   No, try next entry\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R3)                   Get length of Entry\n* DOUBLE CHECK THE NEXT LINE:\n         SH    R1,=AL2(6+1+1)             Subtract Volume and for EX\n         EX    R1,APF$LIBC                Dataset match?\n         BNE   APF$ALLB                   No, continue\n         OI    PPD_FLAG1,$PPD_F1APF       Indicate APF library\n         B     APF$X                      Leave\nAPF$LIBC CLC   1+6(0,R3),JFCBDSNM-INFMJFCB(R4) ** Executed **\nAPF$ALLB DS    0H\n         SLR   R1,R1                      Clear register\n         IC    R1,0(R3)                   Get length of Entry\n         LA    R3,1(R1,R3)                Bump to next entry\n         BCT   R2,APF$ALL                 Repeat\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Exit and constants for PDSR$APF\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nAPF$X    DS    0H\n         PR    ,                          Return to caller\n*\n** Literals and end of PDSR$APF routine\n*\n         LTORG ,                          Literals in PDSR$APF\n         DS    0D                         End of PDSR$APF\n         DROP  R13,R12\n         EJECT\n***********************************************************************\n***\n**   Read BKLIDS file into memory\n**\n***\n***********************************************************************\n         SPACE 2\nPDSR$RBF CSECT ,\nPDSR$RBF AMODE 24\nPDSR$RBF RMODE 24\n*\n** Standard O/S eyecatcher\n*\nRBF_EC         B    RBF_ECL(0,R15)         Bump past EyeCatcher\n               DC   AL1(L'RBF_ECLIT)       Length of eyecatcher\nRBF_ECLIT      DC   C'PDSR$RBF - Read BKLIDS file into memory'\n               DS   0H\nRBF_ECL        EQU  *-RBF_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$RBF,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R1                     Get register save area\n         USING SUBRSA,R13\n*\n** Is the file allocated in the JCL?\n*\n         DEVTYPE =CL8'BKLIDS',DOUBLE\n         LTR   R15,R15\n         BNZ   RBF$X\n*\n** Obtain storage for work area\n*\n         L     R1,C_BKUSRC                Get number to read in\n         MH    R1,=AL2(BKLEL)             Get number to read in\n         LA    R1,BKLHL(R1)               Add for header\n         LR    R0,R1\n         GETMAIN RU,LV=(0)                Obtain storage\n         ST    R1,RBF_PTR                 Save address of area\n         LR    R8,R1                      Get start of table\n         MVC   BKLH_ID-BKLH(8,R8),=CL8'BKLIDST'\n         ST    R0,BKLH_LEN-BKLH(R8)       Save length of area\n*\n** Open the file for input\n*\n         LA    R3,BKLH_DCB-BKLH(R8)       Locate DCB\n         L     R1,=V(PDSR$C1)\n         MVC   0(C_DCBVIL,R3),C_DCBVI-PDSR$C1(R1) Get DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'BKLIDS'\n         LA    R2,RBF$EOF                 Locate End-of-File\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1) Get parm list\n         OPEN  ((3),(INPUT)),                                          @\n               MF=(E,PARMLIST)            Open BKLIDS file\n*\n** Read records\n*\n         LA    R8,BKLHL(R8)               Start of entries\n         L     R9,C_BKUSRC                Set number of users\n         SLR   R6,R6                      Get number used\nRBF$RR   EQU   *\n         GET   (3)                        Read Record\n         LR    R7,R1                      Save address\n         MVC   BKLE_USER-BKLE(L'LIDLID,R8),LIDLID-LIDREC+4(R7)\n         MVC   BKLE_NAME-BKLE(L'LIDNAME,R8),LIDNAME-LIDREC+4(R7)\n         LA    R6,1(R6)                   Increment count\n         LA    R8,BKLEL(R8)\n         BCT   R9,RBF$RR\n*-We could print an overflow message here like the following:\n*        BAS   R9,FORMAT_MESSAGE          FORMAT MESSAGE PREFIX\n*        MVC   0(MSG12L,R15),MSG12\n*        LA    R15,MSG12L+1(R15)\n*        L     R1,C_BKUSRC\n*        BAS   R9,EDITFWF\n*        MVC   1(9,R15),=C'were used'\n*        BAS   R9,PRINT_SYSPRINT_RECORD\n*        SLR   R9,R9                      Number unused is zero\n*\n** End of file on BKLids file\n*\nRBF$EOF  EQU   *\n         L     R1,RBF_PTR                 Locate header\n         ST    R6,BKLH_USERC-BKLH(R1)     Save number of users\n*\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Exit and constants for PDSR$RBF\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nRBF$X    DS    0H\n         PR    ,                          Return to caller\n*\n** Literals and end of PDSR$RBF routine\n*\n         DS    0F\nC_BKUSRC DC    AL4(#BKUSERS)          Max number of users considered\n         LTORG ,                          Literals in PDSR$RBF\n         DS    0D                         End of PDSR$RBF\n         DROP  R13,R12\n         EJECT\n***********************************************************************\n***\n**   Print Report Record\n***\n***********************************************************************\n         SPACE 2\nPDSR$PRR CSECT ,\nPDSR$PRR AMODE 24\nPDSR$PRR RMODE 24\n*\n** Standard O/S eyecatcher\n*\nPRR_EC         B    PRR_ECL(0,R15)         Bump past EyeCatcher\n               DC   AL1(L'PRR_ECLIT)       Length of eyecatcher\nPRR_ECLIT      DC   C'PDSR$PRR - Print Report Record'\n               DS   0H\nPRR_ECL        EQU  *-PRR_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$PRR,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R1                     Get register save area\n         USING SUBRSA,R13\n*\n         TM    PPC_FLAG1,$PPC_F1DATONLY   Data only/No headings?\n         BO    PRR$TITLEX                 Yes, leave\n         SLR   R1,R1                      Clear register\n         LH    R1,PRR_LC                  Get line count\n         BAS   R14,PRR$INC_LC             Increment line count\n         TM    PPD_FLAG1,$PPD_F1NEWHEAD   Need new headings?\n         BNO   PRR$INCX                   No, continue\n         AH    R1,=H'4'                   Max number for headings\nPRR$INCX EQU   *\n*\n         CLM   R1,B'0011',PPC_LINECNT     Need Heading?\n         BH    PRR$TITLE                  No, continue\n         STH   R1,PRR_LC                  Save line count\n*\n         TM    PPD_FLAG1,$PPD_F1NEWHEAD   Need new headings?\n         BO    PRR$NH                     Yes, do them\n         B     PRR$TITLEX                 No, bypass titles\n*\nPRR$TITLE EQU  *\n         MVC   PRR_LC(2),=AL2(5)          Reset line count\n         LA    R15,PRR_TITLE1             Locate title line 1\n         CLI   0(R15),0                   First time?\n         BNE   PRR$PAGE                   No, don't fill it in\n         BAS   R14,PRR$CR                 Clear to spaces\n         MVI   0(R15),C'1'                Set FBA to 1\n         L     R14,=V(DA$PDSR)            Locate start of main CSECT\n         MVC   1(8,R15),5(R14)            Get \"DA$PDSR\" from DA#ENTER\n         MVC   1+8+1(11,R15),W_ODGEUR11_STR\n         MVC   125-10(8,R15),W_OTIMES8_STR\n         MVC   125(4,R15),=CL4'Page'      Insert text\n*\n         L     R1,=V(PDSR$C1)             -> PDSR$C1 CSECT\n         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary?\n         BO    PRR$T1DS\n         TM    PPD_FLAG1,$PPD_F1MEMXREF   Check Duplicates\n         BO    PRR$T1M                    Yes, get it\n         TM    PPD_FLAG1,$PPD_F1CHKDUP    Check Duplicates\n         BO    PRR$T1D                    Yes, get it\n         TM    PPD_FLAG1,$PPD_F1ISPF      ISPF heading?\n         BO    PRR$T1S                    Yes, get it\n         MVC   54(SUBHEADL,R15),SUBHEAD-PDSR$C1(R1)\n         B     PRR$PAGE\nPRR$T1DS EQU  *\n         MVC   53(SUBHDSL,R15),SUBHDS-PDSR$C1(R1)\n         TM    W_FLAG2,$W_F2PDSUM1        Print Dataset Sum: 1st time?\n         BNO   PRR$PAGE\n         NI    W_FLAG2,255-$W_F2PDSUM1\n*\n         LA    R15,PRR_LHEAD1\n         MVI   0(R15),C' '\n         MVC   1(133-1,R15),0(R15)           123456 123456\n         MVC   1+DSUME_TRKA-DSUME(14,R15),=C'<---Tracks--->'\n         MVC   1+DSUME_MEMBERS-DSUME(6,R15),=C'Member'\n         MVC   1+DSUME_RECFM-DSUME(3,R15),=C'REC'\n         LA    R15,PRR_LHEAD2\n         MVI   0(R15),C' '\n         MVC   1(133-1,R15),0(R15)\n         MVC   1+DSUME_DDNAME-DSUME(6,R15),=C'DDNAME'\n         MVC   1+DSUME_ATTR-DSUME(6,R15),=C'Attrib'\n         MVC   1+DSUME_TRKA-DSUME(5,R15),=C'Alloc'\n         MVC   1+DSUME_TRKU-DSUME(4,R15),=C'Used'\n         MVC   1+DSUME_EXTENTS-DSUME(2,R15),=C'EX'\n         MVC   1+DSUME_RECFM-DSUME(3,R15),=C'-FM'\n         MVC   1+DSUME_MEMBERS+1-DSUME(5,R15),=C'Count'\n         MVC   1+DSUME_DSN-DSUME(13,R15),=C'Data Set Name'\n         MVC   1+DSUME_VOL-DSUME(6,R15),=C'Volume'\n         LA    R15,PRR_LHEAD3\n         MVI   0(R15),C' '\n         MVC   1(133-1,R15),0(R15)\n         MVC   1+DSUME_DDNAME-DSUME(L'DSUME_DDNAME,R15),PRR_DASHS\n         MVC   1+DSUME_ATTR-DSUME(L'DSUME_ATTR,R15),PRR_DASHS\n         MVC   1+DSUME_TRKA-DSUME(L'DSUME_TRKA,R15),PRR_DASHS\n         MVC   1+DSUME_TRKU-DSUME(L'DSUME_TRKU,R15),PRR_DASHS\n         MVC   1+DSUME_EXTENTS-DSUME(L'DSUME_EXTENTS,R15),PRR_DASHS\n         MVC   1+DSUME_RECFM-DSUME(L'DSUME_RECFM,R15),PRR_DASHS\n         MVC   1+DSUME_MEMBERS-DSUME(L'DSUME_MEMBERS,R15),PRR_DASHS\n         MVC   1+DSUME_DSN-DSUME(L'DSUME_DSN,R15),PRR_DASHS\n         MVC   1+DSUME_VOL-DSUME(L'DSUME_VOL,R15),PRR_DASHS\n         LA    R15,PRR_TITLE1             Locate title line 1\n         B     PRR$PAGE\nPRR$T1M  EQU  *\n         MVC   53(SUBHML,R15),SUBHM-PDSR$C1(R1)\n         B     PRR$PAGE\nPRR$T1D  EQU  *\n         MVC   53(SUBHDL,R15),SUBHD-PDSR$C1(R1)\n         B     PRR$PAGE\nPRR$T1S  EQU  *\n         MVC   59(SUBHSL,R15),SUBHS-PDSR$C1(R1)\nPRR$PAGE EQU  *\n         L     R1,PRR_PC                  Get page count\n         LA    R1,1(R1)                   Increment it by 1\n         ST    R1,PRR_PC                  Save it\n         CVD   R1,DOUBLE                  Convert it to packed\n         MVC   129(4,R15),=X'40,20,20,20' Get edit pattern\n         ED    129(4,R15),DOUBLE+6        Edit it\n         PUT   REPORT,PRR_TITLE1          Print title line\n*\n** Print second heading line\n*\n         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary?\n         BO    PRR$T2X\n         LA    R15,PRR_TITLE2             Locate title line 2\n         CLI   0(R15),0                   First time?\n         BNE   PRR$T2                     No, line already formated\n         BAS   R14,PRR$CR                 Clear to blanks\n         TM    PPD_FLAG1,$PPD_F1MEMXREF   Check Duplicates\n         BO    PRR$T2                     Yes, get it\n         TM    PPD_FLAG1,$PPD_F1CHKDUP    Check Duplicates\n         BO    PRR$T2                     Yes, get it\n         MVI   PRR_TITLE2,C'0'            Skip a line\n         LA    R1,AREAJFCB\n         MVC   1(10,R15),=C'File Name:'\n         MVC   1+10+1(16,R15),PP_PDDN\n#PRR$TC  EQU   (133-24)/2\n         LA    R15,PRR_TITLE2+#PRR$TC\n         MVC   0(4,R15),=C'DSN='\n         MVC   4(44,R15),JFCBDSNM-INFMJFCB(R1)\n         LA    R15,PRR_TITLE2+L'PRR_TITLE2-8-6\n         MVC   0(8,R15),=C'VOL=SER='\n         MVC   8(6,R15),JFCBVOLS-INFMJFCB(R1)\nPRR$T2   EQU   *\n         PUT   REPORT,PRR_TITLE2\nPRR$T2X  EQU   *\n*\nPRR$NH   EQU   *\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         LA    R0,C_BLANKS-PDSR$C2(R1)    Locate blank line\n         PUT   REPORT,(0)                 Print blank line\n*\n** Print of \"logical heading lines\" for this type of report\n*\n         TM    W_FLAG2,$W_F2PDSUM         Print Dataset Summary?\n         BO    PRR$OH                     Yes, only need two lines\n         TM    PPD_FLAG1,$PPD_F1ISPF      ISPF heading?\n         BO    PRR$SPFH                   Yes, get it\nPRR$OH   DS    0H\n         PUT   REPORT,PRR_LHEAD1\n         PUT   REPORT,PRR_LHEAD2\n         PUT   REPORT,PRR_LHEAD3\n         B     PRR$SPFHX\nPRR$SPFH EQU  *\n         PUT   REPORT,PRR_IHEAD1\n         PUT   REPORT,PRR_IHEAD2\nPRR$SPFHX EQU *\n*\nPRR$TITLEX EQU *\n*\n** Print detail record\n*\n         PUT   REPORT,RECOUT              Print record\n*\n** Return to caller\n*\n         PR    ,                          Return to caller\n*\n** Increment Line count\n**\n** Input: RECOUT - FBA byte\n**        R1 - current line count (to be incremented)\n*\nPRR$INC_LC EQU *\n         CLI   RECOUT,C'+'\n         BE    PRR$ILCX\n         CLI   RECOUT,C'-'\n         BE    PRR$ILC3\n         CLI   RECOUT,C'0'\n         BE    PRR$ILC2\n         B     PRR$ILC1\nPRR$ILC3 EQU   *\n         LA    R1,1(R1)\nPRR$ILC2 EQU   *\n         LA    R1,1(R1)\nPRR$ILC1 EQU   *\n         LA    R1,1(R1)\nPRR$ILCX EQU   *\n         BSM   0,R14\n*\n** Clear recout to blanks\n*\nPRR$CR   EQU   *\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         BSM   0,R14                      Return to caller\n*\n** Literals, constants\n*\n         LTORG ,                          Literals in PDSR$PRR\n*\nPRR_DASHS DC   44C'-'\n*\n** End of the CSECT\n*\n         DS    0D                         End on double word boundry\n*\nPDSR$PRRL EQU  *-PDSR$PRR                 Length of CSECT\nPDSR$PRRB EQU  4096-PDSR$PRRL             Bytes left addressable\n*\n         DROP  R13,R12\n         EJECT\n***********************************************************************\n***\n**   Print SYSPRINT Record\n***\n***********************************************************************\n         SPACE 2\nPDSR$PSR CSECT ,\nPDSR$PSR AMODE 24\nPDSR$PSR RMODE 24\n*\n** Standard O/S eyecatcher\n*\nPSR_EC         B    PSR_ECL(0,R15)         Bump past EyeCatcher\n               DC   AL1(L'PSR_ECLIT)       Length of eyecatcher\nPSR_ECLIT      DC   C'PDSR$PSR - Print SYSPRINT Record'\n               DS   0H\nPSR_ECL        EQU  *-PSR_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$PSR,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers 0 and 1\n         LR    R13,R0                     Save input parmlist address\n         LR    R10,R1                     Save input record address\n         USING PSRAREA,R13\n*\n** Print title line if needed\n*\n         CLC   PSR_LC(2),PPC_LINECNT      Hit max?\n         BNH   PSR$HX                     No, continue\n*\n         LA    R15,PSR_TITLE              Locate title line\n         CLI   0(R15),0                   First time thru?\n         BNE   PSR$PAGE\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         MVI   PSRT_FBA-PSRT(R15),C'1'\n         L     R1,=V(DA$PDSR)\n         MVC   PSRT_PGM-PSRT(8,R15),5(R1) Get \"DA$PDSR\"\n         MVC   PSRT_D1-PSRT(2,R15),=C'--'\n         L     R1,=V(PDSR$C1)\n         MVC   PSRT_DESC-PSRT(C_PSRTDL,R15),C_PSRTD-PDSR$C1(R1)\n         MVC   PSRT_D2-PSRT(2,R15),=C'--'\n         MVC   PSRT_SIDD-PSRT(6,R15),=C'SYSID='\n*\n         L     R14,CVTPTR\n         MVC   PSRT_SID-PSRT(8,R15),CVTSNAME-CVTMAP(R14)\n*\n         MVC   PSRT_D3-PSRT(2,R15),=C'--'\n         MVC   PSRT_TIME-PSRT(8,R15),W_OTIMES8_STR\n         MVC   PSRT_DATE-PSRT(11,R15),W_ODGEUR11_STR\n         MVC   PSRT_D4-PSRT(2,R15),=C'--'\n         MVC   PSRT_PAGE-PSRT(4,R15),=C'Page'\nPSR$PAGE EQU   *\n         L     R1,PSR_PC                  Get page count\n         LA    R1,1(R1)                   Increment it by 1\n         ST    R1,PSR_PC                  Save for next time\n         CVD   R1,DOUBLE                  Convert to packed\n         MVC   PSRT_PAGE+4-PSRT(4,R15),=X'40,20,20,20'\n         ED    PSRT_PAGE+4-PSRT(4,R15),DOUBLE+6\n         PUT   SYSPRINT,PSR_TITLE\n*\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         LA    R0,C_BLANKS-PDSR$C2(R1)    Locate blank line\n         PUT   SYSPRINT,(0)               Print blank line\n         MVC   PSR_LC(2),=AL2(2)          Reset line count\nPSR$HX   EQU   *\n         LH    R1,PSR_LC                  Get line count\n         BAS   R14,PSR$INC_LC             Increment line count\n         STH   R1,PSR_LC                  Save line count\n*\n** Print the input record\n*\n         PUT   SYSPRINT,0(R10)\n*\n** Exit\n*\n         SLR   R15,R15\n         PR    ,                          Return to caller\n*\n** Increment line count\n*\nPSR$INC_LC EQU *\n         CLI   0(R10),C'+'\n         BE    PSR$ILCX\n         CLI   0(R10),C'-'\n         BE    PSR$ILC3\n         CLI   0(R10),C'0'\n         BE    PSR$ILC2\n         B     PSR$ILC1\nPSR$ILC3 EQU   *\n         LA    R1,1(R1)\nPSR$ILC2 EQU   *\n         LA    R1,1(R1)\nPSR$ILC1 EQU   *\n         LA    R1,1(R1)\nPSR$ILCX EQU   *\n         BSM   0,R14\n*\n** Literals and end of PDSR$PSR routine\n*\n         LTORG ,                          Literals in PDSR$PSR\n         DS    0D                         End of PDSR$PSR\n         DROP  R12\n         DROP  R13\n         EJECT ,\n***********************************************************************\n***\n**       Program messages\n***\n***********************************************************************\n         SPACE 2\nPDSR$MSG CSECT ,\nPDSR$MSG AMODE 24\nPDSR$MSG RMODE 24\n*\n** Standard O/S eyecatcher\n*\nMSG_EC         B    MSG_ECL(0,R15)         Bump past EyeCatcher\n               DC   AL1(L'MSG_ECLIT)       Length of eyecatcher\nMSG_ECLIT      DC   C'PDSR$MSG - Messages'\n               DS   0H\nMSG_ECL        EQU  *-MSG_EC\n*\n** Messages\n*\nMSG1     DC    C'001I Execution Begins. Time:'\nMSG1L    EQU   *-MSG1\nMSG2     DC    C'002I Parameter from EXEC card: '''\nMSG2L    EQU   *-MSG2\nMSG3     DC    C'003E First invalid parm at column:'\nMSG3L    EQU   *-MSG3\nMSG4     DC    C'004E Number of invalid parms:'\nMSG4L    EQU   *-MSG4\nMSG4A    DC    C'(Date format error)'\nMSG4AL   EQU   *-MSG4A\nMSG5     DC    C'005I Processing DDNames with prefix \"'\nMSG5L    EQU   *-MSG5\nMSG6     DC    C'006I Help information for DA$PDSR:'\nMSG6L    EQU   *-MSG6\nMSG7     DC    C'007E Mutally exclusive keywords not allowed:'\nMSG7L    EQU   *-MSG7\nMSG8     DC    C'008E PARM=CALLRACF ignored, this program is not '\n         DC    C'APF authorized'\nMSG8L    EQU   *-MSG8\n*\nMSG18    DC    C'018I There were no files found with DDNAME prefix'\nMSG18L   EQU   *-MSG18\nMSG19    DC    C'019I Processing the current'\nMSG19L   EQU   *-MSG19\nMSG19N   DC    C', Number of files:'\nMSG20    DC    C'020I Processing of file'\nMSG20L   EQU   *-MSG20\nMSG21    DC    C'021I > VOL=SER='\nMSG21L   EQU   *-MSG21\nMSG21A   DC    C', catalogued to'\nMSG21AL  EQU   *-MSG21A\nMSG22    DC    C'022I > Used blocks in directory:'\nMSG22L   EQU   *-MSG22\nMSG23    DC    C'023E > Dataset not found on VOL=SER='\nMSG23L   EQU   *-MSG23\nMSG24    DC    C'024E > Dataset is not a PDS'\nMSG24L   EQU   *-MSG24\nMSG25    DC    C'025E > Error while reading member='\nMSG25L   EQU   *-MSG25\nMSG26    DC    C'026I > '\nMSG26SL  EQU   *-MSG26\nMSG26NOM DC    C'Number of members processed:'\nMSG26L   EQU   *-MSG26\nMSG27    DC    C'027E > SYSIN/SYSOUT datasets not supported'\nMSG27L   EQU   *-MSG27\nMSG28    DC    C'028E > DUMMY dataset not supported'\nMSG28L   EQU   *-MSG28\nMSG29    DC    C'029E > TSO terminal allocation not supported'\nMSG29L   EQU   *-MSG29\nMSG30    DC    C'030E > Load failed for member='\nMSG30L   EQU   *-MSG30\nMSG31    DC    C'031W > There were'\nMSG31L   EQU   *-MSG31\nMSG31A   DC    C'modules marked authorized in an unauthorized library'\nMSG31AL  EQU   *-MSG31A\nMSG31B   DC    C'(Verify LNKAUTH=LNKLST IEAAPFxx)'\nMSG31BL  EQU   *-MSG31B\nMSG32    DC    C'032I >'      ** Translater **\nMSG32L   EQU   *-MSG32\nMSG33    DC    C'033E JFCB could not be located'\nMSG33L   EQU   *-MSG33\nMSG34    DC    C'034E Dynamic Allocation failed: RC='\nMSG34L   EQU   *-MSG34\nMSG35    DC    C'035I > Number of aliases:'\nMSG35L   EQU   *-MSG35\nMSG36    DC    C'036W > Orphan:'\nMSG36L   EQU   *-MSG36\nMSG37    DC    C'037E > Deallocation of concatenated file failed: DD='\nMSG37L   EQU   *-MSG37\nMSG38    DC    C'038I > Dynamically allocated'\nMSG38L   EQU   *-MSG38\nMSG38C   DC    C'concatenated file:'\nMSG38CL  EQU   *-MSG38C\nMSG39    DC    C'039E > Catalog locate failed to dataset, CAMLST RC='\nMSG39L   EQU   *-MSG39\nMSG40    DC    C'040W > Non-standard characters in member name:'\nMSG40L   EQU   *-MSG40\nMSG41    DC    C'041E > OPEN of file failed, DDNAME='\nMSG41L   EQU   *-MSG41\nMSG42    DC    C'042I > Number of modules with standard eyecatchers:'\nMSG42L   EQU   *-MSG42\nMSG43    DC    C'043E > Non-DASD files are not supported'\nMSG43L   EQU   *-MSG43\nMSG44    DC    C'044I > Simulate mode: directory not processed'\nMSG44L   EQU   *-MSG44\nMSG45    DC    C'045I > Hex dump of F1-DSCB + '\nMSG45L   EQU   *-MSG45\nMSG46    DC    C'046I > Number of zapped modules:'\nMSG46L   EQU   *-MSG46\nMSG47    DC    C'047I > Number of COBOL modules compiled incorrectly '\n         DC    C'for CICS:'\nMSG47L   EQU   *-MSG47\nMSG48    DC    C'048I '\nMSG48A   DC    C'Level of'\nMSG48L   EQU   *-MSG48\nMSG48B   DC    C'DFSMS/MVS:'\nMSG48C   DC    C'(but we won''t use it''s services)'\nMSG48D   DC    C'DFP:'\nMSG48E   DC    C'- BCP:'\nMSG49    DC    C'049I Output file was not allocated, DD='\nMSG49L   EQU   *-MSG49\nMSG50    DC    C'050E This program was assembled with a '\n         DC    C'pre-DFSMS/MVS maclib and the '\nMSG50T   DC    C'xxxx'\n         DC    C'RPT option is not available'\nMSG50L   EQU   *-MSG50\nMSG51    DC    C'051I Under DFSMS/MVS, the Zap report '\n         DC    C'is included with the HISTRPT option and file output'\nMSG51L   EQU   *-MSG51\nMSG52    DC    C'052I Option='\nMSG52T   DC    CL8' '\n         DC    C' was ignored since you specified NOSMS'\nMSG52L   EQU   *-MSG52\nMSG53    DC    C'053I > Member '\nMSG53N   DC    CL8' '\n         DC    C' was found in library'\nMSG53L   EQU   *-MSG53\nMSG54    DC    C'054I Member '\nMSG54N   DC    CL8' '\n         DC    C' was '\nMSG54E   DC    C'found '\nMSG54L   EQU   *-MSG54\nMSG55    DC    C'055E > BLDL failed for'\nMSG55L   EQU   *-MSG55\nMSG56    DC    C'056E > CSVQUERY failed for'\nMSG56L   EQU   *-MSG56\nMSG57    DC    C'057I > This library is APF authorized'\nMSG57L   EQU   *-MSG57\nMSG58    DC    C'058W > This library is in the LPALST and is not in '\n         DC    C'the APFLST'\nMSG58L   EQU   *-MSG58\nMSG59    DC    C'059W Warning: When the DATE= operand is used in '\n         DC    C'SYSIN, it will not be used in all situations, '\n         DC    C'recommend placing in PARM card'\nMSG59L   EQU   *-MSG59\nMSG60    DC    C'060I > Hex dump of BLDL of member='\nMSG60N   DS    CL8' '\n         DS    C' +'\nMSG60L   EQU   *-MSG60\nMSG61    DC    C'061I > Hex dump of directory entry +'\nMSG61L   EQU   *-MSG61\nMSG62    DC    C'062I > Number of allocated tracks='\nMSG62L   EQU   *-MSG62\nMSG63    DC    C'063I Number of extents in LNKLST datasets:'\nMSG63L   EQU   *-MSG63\nMSG64    DC    C'064I DD=IVCSECT found allocated and will be used'\nMSG64L   EQU   *-MSG64\nMSG65    DC    C'065I Conflicting options: IVCSECTx and NIVENDOR '\n         DC    C'specified with no //IVCSECT file allocated'\nMSG65L   EQU   *-MSG65\n*\nMSG70    DC    C'070I Processing for'\nMSG70L   EQU   *-MSG70\nMSG70A   DC    C'Duplicate members'\nMSG70AL  EQU   *-MSG70A\nMSG70B   DC    C'Member Cross Reference'\nMSG70BL  EQU   *-MSG70B\nMSG71    DC    C'071I Number of duplicate members:'\nMSG71L   EQU   *-MSG71\n*\nMSG80    DC    C'080E Required program not found:'\nMSG80L   EQU   *-MSG80\nMSG81    DC    C'081E Sort failed,'\nMSG81L   EQU   *-MSG81\nMSG82    DC    C'082E Required work file not allocated:'\nMSG82L   EQU   *-MSG82\nMSG83    DC    C'083E Open to global file failed, DDN='\nMSG83L   EQU   *-MSG83\n*\nMSG90    DC    C'090I File processing complete. Condition code was'\nMSG90L   EQU   *-MSG90\nMSG91    DC    C'091W Was unable to determine APF attribute because '\n         DC    C'this program was assembled with backlevel MVS maclib:'\n         DC    C' &MMACLIB'\nMSG91L   EQU   *-MSG91\n*\n** MSG100 - MSG119 reserved for PDSR$IVC processing\n*\nMSG100   DC    C'100I Vendor CSECT results for all libraries:'\nMSG100L  EQU   *-MSG100\nMSG102   DC    C'102I > Number of'\nMSG102L  EQU   *-MSG102\nMSG103   DC    C'103I > Vendor CSECT by type:'\nMSG103L  EQU   *-MSG103\nMSG104   DC    C'104I   >'\nMSG104L  EQU   *-MSG104\nMSG110   DC    C'110I > Vendor CSECT results for this library:'\nMSG110L  EQU   *-MSG110\nMSG111   DC    C'111I   > No Vendor CSECTs were found'\nMSG111L  EQU   *-MSG111\nMSG112   DC    C'112I   > Number of'\nMSG112L  EQU   *-MSG112\nMSG113   DC    C'113I   > Vendor module totals:'\nMSG113L  EQU   *-MSG113\nMSG114   DC    C'114I     > '\nMSG114SL EQU   *-MSG114\nMSG114C  DC    C'Module: '\nMSG114M  DS    XL(L'TVP_PREFIX)\n         DC    C' Type: '\nMSG114T  DC    CL(#TVPDSL)' '\n         DC    C'  '\nMSG114E  EQU   *\nMSG114L  EQU   *-MSG114\nMSG115   DC    C'115I'\nMSG115L  EQU   *-MSG115\nMSG118   DC    C'118W > Storage area maxed out for'\nMSG118L  EQU   *-MSG118\nMSG119   DC    C'119I Vendor CSECTs matched from'\nMSG119L  EQU   *-MSG119\n*\n** End of processing messages\n*\nMSG998   DC    C'998I Number of PDS files processed:'\nMSG998L  EQU   *-MSG998\nMSG999   DC    C'999I Execution Ends. Maximum Condition code was'\nMSG999L  EQU   *-MSG999\n*\n** End of PDSR$MSG\n*\n         DS    0D                         End on double word boundry\nPDSR$MSGL EQU  *-PDSR$MSG                 Length of CSECT\nPDSR$MSGB EQU  4096-PDSR$MSGL             Bytes left addressable\n         EJECT ,\n***********************************************************************\n***\n**       Program Constants CSECT #1\n***\n***********************************************************************\n         SPACE 2\nPDSR$C1  CSECT ,\nPDSR$C1  AMODE 24\nPDSR$C1  RMODE 24\n*\n** Standard O/S eyecatcher\n*\nC1_EC          B    C1_ECL(0,R15)          Bump past EyeCatcher\n               DC   AL1(L'C1_ECLIT)        Length of eyecatcher\nC1_ECLIT       DC   C'PDSR$C1  - Constants CSECT 1'\n               DS   0H\nC1_ECL         EQU  *-C1_EC\n*\n** Misc constants\n*\nSUBHEAD  DC    C'Load Library Audit Report'\nSUBHEADL EQU   *-SUBHEAD\nSUBHS    DC    C'ISPF Statistics'\nSUBHSL   EQU   *-SUBHS\nSUBHD    DC    C'Duplicate Members Report'\nSUBHDL   EQU   *-SUBHD\nSUBHM    DC    C'Member Cross Reference'\nSUBHML   EQU   *-SUBHM\nSUBHDS   DC    C'Dataset Summary'\nSUBHDSL  EQU   *-SUBHDS\nC_PSRTD  DC    C'The PDS Report Utility v&DAVER.'\nC_PSRTDL EQU   *-C_PSRTD\nC_PPTTR  DC    C' (Does not point to current version of member)'\nC_NMLE   DC    C', LOAD errors='\nC_NMNE   DC    C', Non-Executable='\n*\nC_COLS   EQU   *\n         DC    C'....+....1....+....2....+....3'\n         DC    C'....+....4....+....5....+....6'\n         DC    C'....+....7....+....8....+....9'\n*\nC_DD_FLATOUT DC CL8'FLATOUT'\nC_DD_TRANRPT DC CL8'TRANRPT'\nC_DD_HISTRPT DC CL8'HISTRPT'\nC_DD_ZAPRPT  DC CL8'ZAPRPT'\nC_DD_ECRPT   DC CL8'ECRPT'\nC_DD_COBCRPT DC CL8'COBCRPT'\nC_DD_SYSLIB  DC CL6'SYSLIB'\nC_WUNIT      DC CL8'SYSDA'\n*\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\n*\nC_DCBI   DCB   DDNAME=C_DCBI,                                          @\n               DSORG=PS,MACRF=GL,RECFM=FB,EODAD=*-*\nC_DCBIL  EQU   *-C_DCBI\n*\nC_DCBVI  DCB   DDNAME=C_DCBVI,                                         @\n               DSORG=PS,MACRF=GL,RECFM=VB,EODAD=*-*\nC_DCBVIL EQU   *-C_DCBVI\nC_DCBO   DCB   DDNAME=C_DCBO,                                          @\n               DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nC_DCBOL  EQU   *-C_DCBO\n*\nC_DCBPO  DCB   DDNAME=DIRPO,DSORG=PO,MACRF=R,RECFM=U\nC_DCBPOL EQU   *-C_DCBPO\n*\nC_DCBM DCB     DDNAME=C_DCBM,                                          @\n               DSORG=PS,RECFM=U,                                       @\n               MACRF=(RP),EODAD=PLM$X,SYNAD=SMSYNAD\nC_DCBML EQU    *-C_DCBM\n*\nC_DCBD   DCB   DDNAME=C_DCBD,                                          @\n               DSORG=PS,MACRF=GL,RECFM=FB,LRECL=256,BLKSIZE=256\nC_DCBDL  EQU   *-C_DCBD\n         READ  C_DECBM,SF,*-*,,'S',MF=L\nC_DECBML EQU   *-C_DECBM\n*\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nC_VTOCS  CAMLST SEARCH,*-*,*-*,*-*\nC_VTOCSL EQU   *-C_VTOCS\nC_LOCATE CAMLST NAME,*-*,,*-*\nC_LOCATEL EQU  *-C_LOCATE\nC_SFSTRT DC    C'Start of sort messages'\nC_SFSTRTL EQU  *-C_SFSTRT\nC_SFEND  DC    C'End of sort messages'\nC_SFENDL EQU   *-C_SFEND\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               ROUTCDE=(11,14),MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\nC_SWAREQ SWAREQ FCODE=RL,EPA=*-*,MF=L\nC_SWAREQL EQU *-C_SWAREQ\n*\n** DA#DATE constants\n*\nC_IDJULC7  DA#DATE DPE,OPREFIX=C_IDJULC7,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_IDJULC7,OTYPE=$DA#DATE_IDJULC\nC_IDJULP4  DA#DATE DPE,OPREFIX=C_IDJULP4,OSTR=NO,                      @\n               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP\nC_ODGEUR11A DA#DATE DPE,OPREFIX=C_ODGEUR11A,                           @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR\nC_ODDOW3A  DA#DATE DPE,OPREFIX=C_ODDOW3A,                              @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_ODDOW3,OTYPE=$DA#DATE_ODDOW\n           DS  0F\nC_ODGEUR11 DA#DATE DPE,OPREFIX=C_ODGEUR11,OSTR=NO,                     @\n               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR\nC_OTIMES8 DA#DATE DPE,OPREFIX=C_OTIMES8,OSTR=NO,                       @\n               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES\n*\n** End of PDSR$C1\n*\n         DS    0D                         End on double word boundry\nPDSR$C1L EQU   *-PDSR$C1                  Length of CSECT\nPDSR$C1B EQU   4096-PDSR$C1L              Bytes left addressable\n         EJECT ,\n***********************************************************************\n***\n**       Program Constants CSECT #2\n**\n** Note: Had to create a new constants CSECT because code that\n**       tried to locate fields started to get a \"invalid\n**       displacement\" error because PDSR$C1 grew past 4096 bytes.\n***\n***********************************************************************\n         SPACE 2\nPDSR$C2  CSECT ,\nPDSR$C2  AMODE 24\nPDSR$C2  RMODE 24\n*\n** Standard O/S eyecatcher\n*\nC2_EC          B    C2_ECL(0,R15)          Bump past EyeCatcher\n               DC   AL1(L'C2_ECLIT)        Length of eyecatcher\nC2_ECLIT       DC   C'PDSR$C2  - Constants CSECT 2'\n               DS   0H\nC2_ECL         EQU  *-C2_EC\n*\nC_BLANKS DC    133C' '\nC_DASHS  DC    C' ',132C'-'               Output line of dashs\nC_EQUALS DC    C' ',132C'='               Equal line delimiter\n*\n** Headings\n*\nC_DETMEM       DC    C'Member'\nC_DETADDR      DC    C'TTR'\nC_DETALIAS     DC    C'Alias'\n*\nC_DET_IVER     DC    C'VV.MM'\nC_DET_ICDATE   DC    C'Created'\nC_DET_ILDATE   DC    C'Changed'\nC_DET_ISIZE    DC    C'Size'\nC_DET_IINIT    DC    C'INIT'\nC_DET_IMODL    DC    C'MOD'\nC_DET_IUID     DC    C'UserID'\n*\nC_DET_LTRANT   DC    C'LKED/Binder'\nC_DET_LMODE1   DC    C'XA Mode'\nC_DET_LZAP1    DC    C'Zap'\nC_DET_LSIZE    DC    C'Size'\nC_DET_LTD_DATE DC    C'Translator Date'\nC_DET_LTNAME   DC    C'Translator Name'\nC_DET_LMODEA   DC    C'Addr'\nC_DET_LCSECT   DC    C'CSECT'\nC_DET_LCSECTN  DC    C'Count'\nC_DET_LMODER   DC    C'Res'\nC_DET_LATTR    DC    C'Attributes'\nC_DET_LZAP     DC    C'Cnt'\nC_DET_LSSI     DC    C'SSI'\nC_DET_LEPA     DC    C'EPA'\nC_DET_LCODE    DC    C'Code'\n*\nC_DET_IDD      DC    C'File Name'\nC_DET_IVOL     DC    C'Volume'\nC_DET_IDSN     DC    C'Data Set Name'\nC_DET_LDD      DC    C'DDNAME'\nC_DET_LVOL     EQU   C_DET_IVOL   -->  DC    C'Volume'\nC_DET_LDSN     EQU   C_DET_IDSN   -->  DC    C'Data Set Name'\n*\nC_COBCD  DC    C'Note: The following modules failed the CICS COBOL '\n         DC    C'tests.  Please verify that they used in CICS '\n         DC    C'and recompile if needed.'\nC_COBCDL EQU  *-C_COBCD\n*\n** Translate table for detecting members with non-standard characters\n**\n** Standard: Blank, $, #, @, A-Z, and 0-9 (National Characters)\n*\nC_TABPRT DC    X'00,01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F'\n         DC    X'10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F'\n         DC    X'20,21,22,23,24,25,26,27,28,29,2A,2B,2C,2D,2E,2F'\n         DC    X'30,31,32,33,34,35,36,37,38,39,3A,3B,3C,3D,3E,3F'\n         DC    X'00,41,42,43,44,45,46,47,48,49,4A,4B,4C,4D,4E,4F' space\n         DC    X'50,51,52,53,54,55,56,57,58,59,5A,00,5C,5D,5E,5F' $\n         DC    X'60,61,62,63,64,65,66,67,68,69,6A,6B,6C,6D,6E,6F'\n         DC    X'70,71,72,73,74,75,76,77,78,79,7A,00,00,7D,7E,7F' # @\n         DC    X'80,81,82,83,84,85,86,87,88,89,8A,8B,8C,8D,8E,8F'\n         DC    X'90,91,92,93,94,95,96,97,98,99,9A,9B,9C,9D,9E,9F'\n         DC    X'A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE,AF'\n         DC    X'B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,BA,BB,BC,BD,BE,BF'\n         DC    X'C0,00,00,00,00,00,00,00,00,00,CA,CB,CC,CD,CE,CF' A-I\n         DC    X'D0,00,00,00,00,00,00,00,00,00,DA,DB,DC,DD,DE,DF' J-R\n         DC    X'E0,E1,00,00,00,00,00,00,00,00,EA,EB,EC,ED,EE,EF' S-Z\n         DC    X'00,00,00,00,00,00,00,00,00,00,FA,FB,FC,FD,FE,FF'\n*\n** Table to ensure that special characters are changed to dots. Use\n** this one for member names as these are the only characters allowed\n** by TSO/ISPF conventions\n*\nC_TRTABM DC    256C'.'\n         ORG   C_TRTABM+C' '\n         DC    C' '\n         ORG   C_TRTABM+C'$'\n         DC    C'$'\n         ORG   C_TRTABM+C'#'\n         DC    C'#'\n         ORG   C_TRTABM+C'@'\n         DC    C'@'\n         ORG   C_TRTABM+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   C_TRTABM+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   C_TRTABM+C'S'\n         DC    C'STUVWXYZ'\n         ORG   C_TRTABM+C'0'\n         DC    C'0123456789'\n         ORG   ,\n*\n** Table to ensure that special characters are changed to dots. Use\n** this one for non-member names where we can allow a few more\n** printable character thru\n*\nC_TRTABA DC    256C'.'\n         ORG   C_TRTABA+C' '\n         DC    C' '\n         ORG   C_TRTABA+C'\u00a2'\n         DC    C'\u00a2'\n         ORG   C_TRTABA+C'<'\n         DC    C'<'\n         ORG   C_TRTABA+C'('\n         DC    C'('\n         ORG   C_TRTABA+C'+'\n         DC    C'+'\n         ORG   C_TRTABA+C'|'\n         DC    C'|'\n         ORG   C_TRTABA+X'50'\n         DC    X'50'                   &\n         ORG   C_TRTABA+C'$'\n         DC    C'$'\n         ORG   C_TRTABA+C'*'\n         DC    C'*'\n         ORG   C_TRTABA+C')'\n         DC    C')'\n         ORG   C_TRTABA+X'5E'\n         DC    X'5E'                   ;\n         ORG   C_TRTABA+C'\u00ac'\n         DC    C'\u00ac'\n         ORG   C_TRTABA+C'-'\n         DC    C'-'\n         ORG   C_TRTABA+C'/'\n         DC    C'/'\n         ORG   C_TRTABA+C'\u00a6'\n         DC    C'\u00a6'\n         ORG   C_TRTABA+C','\n         DC    C','\n         ORG   C_TRTABA+C'%'\n         DC    C'%'\n         ORG   C_TRTABA+C'_'\n         DC    C'_'\n         ORG   C_TRTABA+C'>'\n         DC    C'>'\n         ORG   C_TRTABA+C'?'\n         DC    C'?'\n         ORG   C_TRTABA+C'`'\n         DC    C'`'\n         ORG   C_TRTABA+C':'\n         DC    C':'\n         ORG   C_TRTABA+C'#'\n         DC    C'#'\n         ORG   C_TRTABA+C'@'\n         DC    C'@'\n         ORG   C_TRTABA+X'7D'             Single quotes...\n         DC    X'7D'\n         ORG   C_TRTABA+C'='\n         DC    C'='\n         ORG   C_TRTABA+C'\"'\n         DC    C'\"'\n*\n         ORG   C_TRTABA+C'a'\n         DC    C'abcdefghi'\n         ORG   C_TRTABA+C'j'\n         DC    C'jklmnopqr'\n         ORG   C_TRTABA+C's'\n         DC    C'stuvwxyz'\n*\n         ORG   C_TRTABA+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   C_TRTABA+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   C_TRTABA+C'S'\n         DC    C'STUVWXYZ'\n*\n         ORG   C_TRTABA+X'F0'\n         DC    C'0123456789'\n         ORG   ,\n*\n** Eagle picture\n**\n** Author of this \"ASCII\" Eagle unknown.\n*\nEAGLE_PICTURE DS 0H\n DA#STR '\\             / /        The PDS Report Utility - v&DAVER'\n DA#STR ' \\\\\\'' ,      / //'\n DA#STR '  \\\\\\//,   _/ //,        Freeware! written by David Alcock'\n DA#STR '   \\_ //'' /  //,'\n DA#STR '     \\ ///  //`          Assembled on &ASMDATE. at &SYSTIME us@\n               ing:'\n DA#STR '   _/ >>  \\\\\\`'\n DA#STR '  /,)-~>> _\\`            - &DMACLIB. MACLIBs'\n DA#STR '  (/ \\\\ \\\\\\\\\\            - &MMACLIB. MACLIBs'\n DA#STR '     // // \\\\\\'\n DA#STR '    (( ((                The PDS Eagle has landed!'\n DC  X'FFFF'                      or the buzzards are circling\n*\nNO_PICTURE DS 0H\n DA#STR 'The PDS Report Utility - v&DAVER'\n DA#STR ' '\n DA#STR 'Freeware! written by David Alcock'\n DA#STR ' '\n DA#STR 'Assembled on &ASMDATE. at &SYSTIME using:'\n DA#STR ' '\n DA#STR '- &DMACLIB. MACLIBs'\n DA#STR '- &MMACLIB. MACLIBs'\n DA#STR ' '\n DC  X'FFFF'\n*\n** End of PDSR$C2\n*\n         DS    0D                         End on double word boundry\nPDSR$C2L EQU   *-PDSR$C2                  Length of CSECT\nPDSR$C2B EQU   4096-PDSR$C2L              Bytes left addressable\n         EJECT\n***********************************************************************\n***\n**       Translator tables\n***\n***********************************************************************\n         SPACE 2\nPDSR$TRT CSECT ,\nPDSR$TRT RMODE 24\nPDSR$TRT AMODE 24\n*\n** Standard O/S eyecatcher\n*\nTRT_EC         B    TRT_ECL(0,R15)         Bump past EyeCatcher\n               DC   AL1(L'TRT_ECLIT)       Length of eyecatcher\nTRT_ECLIT      DC   C'PDSR$TRT - Translator and LKED Tables'\n               DS   0H\nTRT_ECL        EQU  *-TRT_EC\n*\n** Translator program number table\n**\n** (Thanks for your list, Bruce Leland!)\n*\n         DC    CL8'T_TRAN'\nT_TRAN   DS    0H\n         DC    CL10'566896201 ',CL8'ASMH    ' ASSEMBLER H\n         DC    CL10'5734AS1   ',CL8'ASMH    ' OLD\n         DC    CL10'569623400 ',CL8'ASMA90  ' HIGH LEVEL ASSEMBLER\n         DC    CL10'40CB1     ',CL8'COBOLVS ' SEE APAR PP80690\n         DC    CL10'12345     ',CL8'COBOLVS ' OLD\n         DC    CL10'5741SC103 ',CL8'IFOX00  ' 1972-1987\n         DC    CL10'360SAS037 ',CL8'IFOX00  ' OLD IFOX\n         DC    CL10'360SAS038 ',CL8'IFOX00  ' OLD IFOX\n         DC    CL10'5734AS100 ',CL8'IFOX00  ' 1977-1992\n         DC    CL10'5752SC104 ',CL8'COBOLV4 ' COBOL   V4\n         DC    CL10'5740CB103 ',CL8'COBOLVS ' COBOL VS2\n         DC    CL10'566895801 ',CL8'COBOLII ' COBOL II\n         DC    CL10'566895807 ',CL8'COBOL370' COBOL LE/370\n         DC    CL10'566895901 ',CL8'COBOLII ' COBOL II\n         DC    CL10'5734-PL1  ',CL8'PL1     ' PL/1 V1\n         DC    CL10'5734-FO2  ',CL8'FORTRANG' FORTRAN G\n         DC    CL10'5734-FO3  ',CL8'FORTRANH' FORTRAN H\n         DC    CL10'5740RG1   ',CL8'RPG     ' RPG\n         DC    CL10'1234-5    ',CL8'COBOLV4 ' OLD\n         DC    CL10'40CB-1    ',CL8'CAPEXOPT' CAPEX OPTIMIZER\n         DC    CL10'5668-910  ',CL8'PL1     ' PL/1 V2\n         DC    CL10'5734-F02  ',CL8'FORTRANG' FORTRAN\n         DC    CL10'569501301 ',CL8'REXX370 ' COMPILED REXX\n         DC    CL10'5668-806  ',CL8'FORTRANV' FORTRAN VS\n         DC    CL10'5748-FO3  ',CL8'FORTRANV' FORTRAN VS\n         DC    CL10'5688187   ',CL8'C370    ' C/370\n         DC    CL10'5688216   ',CL8'C370    ' C/370\n         DC    CL10'5688-235  ',CL8'PL1     ' PL/1 FOR MVS AND VM\n         DC    CL10'5688040   ',CL8'C370    ' C/370\n         DC    CL10'SAS/C     ',CL8'SAS/C   ' SAS/C\n         DC    CL10'LC370B    ',CL8'SAS/C   ' SAS/C\n         DC    CL10'PL/X-370  ',CL8'PL/X-370' PL/X\n         DC    CL10'C''PLS-III'' ',CL8'PLS-III ' PLS-III\n         DC    CL10' 5796-PKR ',CL8'EXT.EXP.' EXT. EXPONENT FORTRAN\n         DC    CL10'566876701 ',CL8'PASCAL  ' PASCAL\n         DC    CL10'CA-PLNK 0 ',CL8'CA PL/S ' CA-PL/S CLONE\n         DC    CL10'SAS/C/    ',CL8'SAS/C   ' SAS/C\n         DC    CL10'SDS080888 ',CL8'SAS/C   ' SAS/C\n         DC    CL10'BLD121988 ',CL8'SAS/C   ' SAS/C\n         DC    CL10'TMCOMPIL  ',CL8'XPEDITER' XPIDITER\n         DC    CL10'52ASM32B88',CL8'IFOX00  ' STRANGE IFOX\n         DC    CL10'52ASM31686',CL8'IFOX00  ' STRANGE IFOX\n         DC    CL10'566528444 ',CL8'IEBIMAGE' IEBIMAGE\n         DC    CL10'5742SC1UM ',CL8'IEBIMAGE' IEBIMAGE\n         DC    CL10'5752SC1UM ',CL8'IEBIMAGE' IEBIMAGE\n         DC    CL10'568819801 ',CL8'LECOMMON' LE COMMON EXEC\n         DC    CL10'568819802 ',CL8'LECOBOL ' LE COBOL\n         DC    CL10'568819803 ',CL8'LEPL/I  ' LE PL/I\n         DC    CL10'568819804 ',CL8'LEFORT  ' LE FORTRAN\n         DC    CL10'568819805 ',CL8'LEC++   ' LE C++\n*\n*-From Dave:\n         DC    CL10'5645001   ',CL8'LE_C++r2' OS/390 v1r2\nT_TRANL  EQU   *-T_TRAN\nT_TRANN  EQU   T_TRANL/TRANTL\n         DC    18X'FF'\n*\n** Translator program ID's for Linkage Editor/Binders\n*\n         DC    CL8'T_LINKT'\nT_LINKT  DS    0H\n         DC    CL10'5695DF108 ',CL16'DFSMS Binder'\n         DC    CL10'566528408 ',CL16'DFP LKED'\n         DC    CL10'566529508 ',CL16'DFP LKED'\n         DC    CL10'5752SC104 ',CL16'LKED-F'\n         DC    CL10'04LE960488',CL16'MVSLKED'\nT_LINKTL EQU   *-T_LINKT\nT_LINKTN EQU   T_LINKTL/TLTL\n         DC    26X'FF'\n*\n** Table of Vendor CSECT prefix - mapped by TVP DSECT\n** Low resource table (over //IVCSECT method)\n*\n         DC    CL8'T_VENDOR'\nT_VENDOR DS    0F\n         DC    AL2(3-1,0),CL8'AMP*    ',AL2(T_VPAS-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'CEE*    ',AL2(T_VLE-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'CBC*    ',AL2(T_VC-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'EDC*    ',AL2(T_VC-PDSR$TRT)\n         DC    AL2(5-1,0),CL8'BLDQS   ',AL2(T_VCOBII-PDSR$TRT)\n         DC    AL2(8-1,0),CL8'COBDBG  ',AL2(T_VCOBII-PDSR$TRT)\n         DC    AL2(8-1,0),CL8'COBTEST ',AL2(T_VCOBII-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'IGZ*    ',AL2(T_VCOBII-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'ILB*    ',AL2(T_VCOBVS-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'IFY*    ',AL2(T_VFORT-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'AFH*    ',AL2(T_VFORT-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'IHE*    ',AL2(T_VPLIA-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'IBM*    ',AL2(T_VPLI-PDSR$TRT)\n         DC    AL2(8-1,0),CL8'PLISTART',AL2(T_VPLI-PDSR$TRT)\n         DC    AL2(8-1,0),CL8'PLIMAIN ',AL2(T_VPLI-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'DFH*    ',AL2(T_VCICS-PDSR$TRT)\n         DC    AL2(3-1,0),CL8'DSN*    ',AL2(T_VDB2-PDSR$TRT)\n         DC    AL2(4-1,0),CL8'IDMS*   ',AL2(T_VIDMS-PDSR$TRT)\nT_VENDORN EQU  (*-T_VENDOR)/TVP_SL\n         DC    9X'FF'\n*\n#TVPDSL   EQU    19+2                     Set for max desc string +\n*                 ....+....1....+....2\nT_VPAS    DA#STR 'IBM_Pascal'\nT_VLE     DA#STR 'IBM_LE/370'\nT_VC      DA#STR 'IBM_C/C++'\nT_VCOBII  DA#STR 'IBM_VS COBOL II'\nT_VCOBVS  DA#STR 'IBM_OS/VS COBOL'\nT_VFORT   DA#STR 'IBM_FORTRAN'\nT_VPLIA   DA#STR 'IBM_PL/I (ancient)'\nT_VPLI    DA#STR 'IBM_PL/I'\nT_VCICS   DA#STR 'IBM_CICS'\nT_VDB2    DA#STR 'IBM_DB2'\nT_VIDMS   DA#STR 'CA-IDMS'\n          DS     0D\nPDSR$TRTL EQU    *-PDSR$TRT               End of PDSR$TRT CSECT\n*\n** Map T_LINKT\n*\nTLT      DSECT ,\nTLT_ID   DS    CL10' '\nTLT_NAME DS    CL16' '\nTLTL     EQU   *-TLT\n*\n** Map T_TRAN table\n*\nTRANT        DSECT ,\nTRANT_ID     DS    CL10                   Translator ID\nTRANT_NAME   DS    CL8                    Translator Name\nTRANTL       EQU   *-TRANT                Length of entry\n*\n** Map T_VENDOR table\n*\nTVP          DSECT ,\nTVP_PREFL    DS    XL2                    Prefix length\n             DS    XL2                    Not used, get on fullwrd bnd\nTVP_PREFIX   DS    CL8                    Prefix value\nTVP_IEL      EQU   *-TVP                  Length to copy during init\nTVP_OFF      DS    AL2                    Offset in PDSR$TRT of desc\nTVP_SL       EQU   *-TVP                  Length of static entry\n             ORG   TVP_OFF\nTVP_DADDR    DS    AL4                    Address of description\nTVP_I        EQU   *\nTVP_CNTLIB   DS    AL4                    Count: for this library\nTVP_CNTALL   DS    AL4                    Count: for all libraries\nTVP_IL       EQU   *-TVP_I\nTVP_DL       EQU   *-TVP                  Length of entry\n             ORG   ,\n         EJECT ,\n***********************************************************************\n***\n**       Help me - Help me - I've been hyp-mo-tized\n**\n** This routine prints the help information.  The Pascal-like\n** strings make the bulk of the input.  There are a few attribute\n** bytes which are used instead of a usual string length:\n**\n** - FF ... End of help information\n** - FE ... Print a blank line\n** - FD ... Print the translator table\n** - FC ... Print the Linkage Editor/Binder Translator table\n**\n** Help information - We are trying to keep this information\n** under 80 columns for good TSO viewing.  It is printed when this\n** program is executed with PARM='HELP'.\n***\n***********************************************************************\n         SPACE 2\nPDSR$HLP CSECT ,\nPDSR$HLP AMODE 24\nPDSR$HLP RMODE 24\n*\n** Standard O/S eyecatcher\n*\nHLP_EC         B    HLP_ECL(0,R15)         Bump past EyeCatcher\n               DC   AL1(L'HLP_ECLIT)       Length of eyecatcher\nHLP_ECLIT      DC   C'PDSR$HLP - Help Information'\n               DS   0H\nHLP_ECL        EQU  *-HLP_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         USING PDSR$HLP,R12             Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1\n         LR    R13,R1\n         USING SUBRSA,R13                 Locate to data area\n         SPACE 2\n*\n** Print initial messages\n*\n         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks\n         BAS   R14,HELP$PSR               Print the record\n*\n         BAS   R14,HELP$FORMAT_MESSAGE   Initialize the message area\n         MVC   0(MSG6L,R15),MSG6-PDSR$MSG(R1) Move in message\n         BAS   R14,HELP$PSR               Print the record\n*\n** Loop thru help text\n*\n         LA    R3,HELPTEXT                Locate start of text\nHELP$L   DS    0H\n         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks\n*-Blank line\n         CLI   0(R3),X'FE'                Blank line?\n         BNE   HELP$LM                    No, continue\n         BAS   R14,HELP$PSR               Print the record\n         LA    R3,1(R3)                   Bump past attribute character\n         B     HELP$L\nHELP$LM  DS    0H\n*-Print translator table\n         CLI   0(R3),X'FD'                Translators?\n         BNE   HELP$TTX                   No, continue\n         L     R4,=V(PDSR$TRT)            -> Translater CSECT\n         LA    R4,T_TRAN-PDSR$TRT(R4)     Locate to table start\n         LA    R5,T_TRANN                 Get number of entries\nHELP$TTL DS    0H\n         LA    R15,RECOUT+12              Get output location\n         MVC   0(L'TRANT_ID,R15),TRANT_ID-TRANT(R4)  Get ID\n         LA    R15,L'TRANT_ID+2(R15)                 Bump past ID\n         MVC   0(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R4) Get Name\n         BAS   R14,HELP$PSR               Print the record\n         LA    R4,TRANTL(R4)              Next entry (input)\n         BCT   R5,HELP$TTL                Process next entry\n         LA    R3,1(R3)                   Bump past attribute character\n         B     HELP$L\nHELP$TTX DS    0H\n*-Print LinkageEditor/Binder Translator table\n         CLI   0(R3),X'FC'                LKED translators?\n         BNE   HELP$LTX                   No, continue\n         L     R4,=V(PDSR$TRT)            -> Translater CSECT\n         LA    R4,T_LINKT-PDSR$TRT(R4)    Locate to table start\n         LA    R5,T_LINKTN                Get number of entries\nHELP$LTL DS    0H\n         LA    R15,RECOUT+12              Get output location\n         MVC   0(L'TLT_ID,R15),TLT_ID-TLT(R4)        Get ID\n         LA    R15,L'TLT_ID+2(R15)                   Bump past ID\n         MVC   0(L'TLT_NAME,R15),TLT_NAME-TLT(R4) Get Name\n         BAS   R14,HELP$PSR               Print the record\n         LA    R4,TLTL(R4)                Next entry (input)\n         BCT   R5,HELP$LTL                Process next entry\n         LA    R3,1(R3)                   Bump past attribute character\n         B     HELP$L\nHELP$LTX DS    0H\n*-Print Vendor table\n         CLI   0(R3),X'FB'                LKED translators?\n         BNE   HELP$LVX                   No, continue\n         L     R4,=V(PDSR$TRT)            -> Translater CSECT\n         LA    R4,T_VENDOR-PDSR$TRT(R4)   Locate to table start\n         LA    R5,T_VENDORN               Get number of entries\nHELP$LVL DS    0H\n         LA    R15,RECOUT+12              Get output location\n         MVC   0(L'TVP_PREFIX,R15),TVP_PREFIX-TVP(R4) Get ID\n         BAS   R14,HELP$PSR               Print the record\n         LA    R4,TVP_SL(R4)              Next entry (input)\n         BCT   R5,HELP$LVL                Process next entry\n         LA    R3,1(R3)                   Bump past attribute character\n         B     HELP$L\nHELP$LVX DS    0H\n*-Print string\n         LA    R15,RECOUT+1               Bump past prefix and 'xxxI '\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R3)                  Obtain length of messsage - 1\n         EX    R14,HELP$MVE               Move string to message area\n         LA    R3,2(R14,R3)               Bump past this string\n         BAS   R14,HELP$PSR               Print record\n*-End of table\n         CLI   0(R3),X'FF'                End of table?\n         BNE   HELP$L                     No, process next string\n*\n         BAS   R14,HELP$CLEAR_RECOUT      Clear record to blanks\n         BAS   R14,HELP$PSR               Print the record\n         B     HELP$X                     Continue\n*\nHELP$MVE MVC   0(0,R15),1(R3)\n*\n** Common exit from HELP processing\n*\nHELP$X   DS    0H\n         PR    ,                          Return to caller\n*\n** Print SYSPRINT Record\n*\nHELP$PSR DS    0H\n         ST    R14,PSR_RA                 Save return address\n         LA    R0,PSRAREA                 Locate work area\n         LA    R1,RECOUT                  Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n         L     R14,PSR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Clear output record to blanks\n*\nHELP$CLEAR_RECOUT  DS 0H\n         LA    R15,RECOUT                 Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         BSM   0,R14                      Return to caller\n*\n** Initialize message\n**\n** Output: R1 has PDSR$MSG\n*\nHELP$FORMAT_MESSAGE DS 0H\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(L'RECOUT-1,R15),0(R15)\n         LA    R15,1(R15)\n         L     R1,=V(DA$PDSR)             -> main CSECT\n         MVC   0(7,R15),5(R1)             Move in \"DA$PDSR\"\n         MVI   7(R15),C'-'                Insert dash\n         LA    R15,MSGPREL(R15)           Bump past \"DA$PDSR-\"\n         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT\n         BSM   0,R14\n*\n** Literals for the PDSR$HLP CSECT\n*\n         LTORG ,\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Help text area\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nHELPTEXT DS    0H\n DC  X'FE'                                Skip a line\n*\n** General information\n*\n DA#STR 'DA$PDSR, a PDS reporting program, can be used to manage'\n DA#STR 'your partitioned datasets.  It processes both load libraries'\n DA#STR 'and non-load libraries. By default, it will process every '\n DA#STR 'library that is allocated with a DDNAME that begins with '\n DA#STR '\"SYSLIB\" (although you can change the DSNAME prefix to suit'\n DA#STR 'your needs).  You can omit the //SYSLIBxx datasets and '\n DA#STR 'optionally process the whole LNKLST or LPALST'\n*\n** Sample JCL\n*\n DC  X'FE'                                Skip a line\n DA#STR 'It can be invoked via the following JCL:'\n DC  X'FE'                                Skip a line\n DA#STR '//stepname EXEC PGM=DA$PDSR,PARM=''options'' '\n DA#STR '//SYSPRINT DD SYSOUT=*'\n DA#STR '//REPORT   DD SYSOUT=*'\n DA#STR '//HISTRPT  DD SYSOUT=*                      <- optional'\n DA#STR '//TRANRPT  DD SYSOUT=*                      <- optional'\n DA#STR '//ZAPRPT   DD SYSOUT=*                      <- optional'\n DA#STR '//ECRPT    DD SYSOUT=*                      <- optional'\n DA#STR '//*'\n DA#STR '//IVCSECT  DD DISP=SHR,DSN=CEE.SCEELKED     <- optional'\n DA#STR '//         DD DISP=SHR,DSN=COBOL.COB2LIB    <- optional'\n DA#STR '//         DD DISP=SHR,DSN=FORT.VSF2FORT    <- optional'\n DA#STR '//*'\n DA#STR '//SYSLIBaa DD DSN=data-set-name,DISP=SHR'\n DA#STR '//SYSLIBzz DD DSN=data-set-name,DISP=SHR'\n DA#STR '//WRKFILE1 DD DISP=(,DELETE),SPACE=(CYL,1)  <- optional'\n DA#STR '//WRKFILE2 DD DISP=(,DELETE),SPACE=(CYL,##) <- optional'\n DA#STR '//WRKFILE3 DD DISP=(,DELETE),SPACE=(CYL,##) <- optional'\n DA#STR '//SYSIN    DD *                             <- optional'\n DA#STR 'options'\n DA#STR 'options'\n DA#STR '/*'\n DC  X'FE'                                Skip a line\n DA#STR '  Notes:'\n DA#STR '  - The WRKFILEx files are optional and only needed for '\n DA#STR '    sorting when you use the CHKDUP and MEMXREF options '\n DA#STR '    are specified.'\n DA#STR '  - If a \"//SORTDIAG\" is found allocated, then all of the'\n DA#STR '    SORT messages will be printed in the SYSPRINT file.'\n DA#STR '    Otherwise, the sort messages are only printed if the'\n DA#STR '    SORT has a non-zero return code.'\n DA#STR '  - The CSECTS column of the load module report will only'\n DA#STR '    be updated when you use an option that uses the'\n DA#STR '    DFSMS/MVS Binder API to process a load module''s'\n DA#STR '    CSECTs: TRANRPT, ZAPRPT, ECRPT, etc.'\n DA#STR '  - When running under DFSMS/MVS and you ask for a HISTRPT'\n DA#STR '    TRANRPT or ZAPRPT, you can influence processing by'\n DA#STR '    allocating these files (changes Binder API options):'\n DC  X'FE'                                Skip a line\n DA#STR '      //BINDERDB DD DUMMY      <- Ask for Binder API output'\n DA#STR '      //BINDEROU DD SYSOUT=*   <- Binder API output goes here'\n DC  X'FE'                                Skip a line\n DA#STR '    If you are running DFSMS 1.3 without UW32119, use these'\n DA#STR '    DD statements to turn off Binder API messages:'\n DC  X'FE'                                Skip a line\n DA#STR '      //BINDEROU DD DUMMY      <- Binder API output goes here'\n DA#STR '      //BINDERPR DD DUMMY      <- Turn on print'\n DC  X'FE'                                Skip a line\n*\n** Pair-A-Meters\n*\n DC  X'FE'                                Skip a line\n DC  X'FE'                                Skip a line\n DA#STR 'The following options can be specified on the parm card '\n DA#STR '(PARM=\"option,option\") or in the //SYSIN file:'\n DC  X'FE'                                Skip a line\n DA#STR 'NOBREAK  - Do not \"Break\" (place a blank line between member'\n DA#STR '           names) when the prefix changes. The prefix is the '\n DA#STR '           first 3 characters: IEFBR14, IEFACTRT, etc.'\n DA#STR '                               ___      ___'\n*\n DA#STR 'CHKDUP   - Check for duplicate members in all of the datasets'\n DA#STR '           processed'\n*\n DA#STR 'DATAONLY - Do not produce headings on REPORT file'\n*\n DA#STR 'DATE=    - Date format: (DATE=US | DATE=EUR | DATE=ISO)'\n DA#STR '           US - United States date format: MM/DD/CCYY'\n DA#STR '           EUR - \"European\" date format: DD-MMM-CCYY'\n DA#STR '           ISO - ISO Date format: CCYY-MM-DD'\n DA#STR '           << default is DATE=EUR >>'\n*\n DA#STR 'EODC     - Report on End Of Data Conditions reported by '\n DA#STR '           the Binder API GETN call for RC=4'\n*\n DA#STR 'NODETAIL - Do not print normal detail records if PARM=CHKDUP '\n DA#STR '           was specified.  This option lets you get only the'\n DA#STR '           information needed: the duplicate members.'\n*\n DA#STR 'DUMPBLDL - Print the BLDL results from the PDS in hex dump'\n DA#STR '           format'\n*\n DA#STR 'DUMPDIRE - Print the PDS directory entry in hex dump format'\n*\n DA#STR 'DUMPDSCB - Print the Format-1 DSCB (Data Set Control Block) '\n DA#STR '           in hex dump format as we process the file'\n*\n DA#STR 'FINDMEM= - Search each library we process and look for the '\n DA#STR '           the member.  Trailing generics are allowed, for'\n DA#STR '           example: FINDMEM=IEF*'\n*\n DA#STR 'FLATOUT  - Put dataset and member detail records to the'\n DA#STR '           DD=FLATOUT file.  This output is good for analysis'\n DA#STR '           by programs written in REXX or SAS'\n DA#STR '           Note: You should have a file allocated to FLATOUT'\n*\n DA#STR 'HELP     - List the current options to the SYSPRINT dataset'\n*\n DA#STR 'HISTRPT  - Produce a History (IDR Identify and Zap) report on'\n DA#STR '           file HISTRPT.  This function only works on'\n DA#STR '           DFSMS/MVS systems.'\n*\n DA#STR 'IVCSECTS - Ignore Vendor CSECT Statistics: The statistics for'\n DA#STR '           CSECTs will not reflect Vendor CSECTs. The vendor'\n DA#STR '           CSECTs will be included in the detail reports'\n DC  X'FE'                                Skip a line\n DA#STR '           Use the //IVCSECT DD concatenation to augment'\n DA#STR '           the CSECTs to be considered as Vendor CSECTS'\n DC  X'FE'                                Skip a line\n DA#STR '           See related option: NIVENDOR'\n DC  X'FE'                                Skip a line\n*\n DA#STR 'IVCSECTF - Ignore Vendor CSECT FULL: The vendor CSECTs will '\n DA#STR '           not be reflected in statistics or in the reports'\n DC  X'FE'                                Skip a line\n DA#STR '           Use the //IVCSECT DD concatenation to augment'\n DA#STR '           the CSECTs to be considered as Vendor CSECTS'\n DC  X'FE'                                Skip a line\n DA#STR '           See related option: NIVENDOR'\n DC  X'FE'                                Skip a line\n*\n DA#STR 'LINECNT= - Specify the number of lines to be printed per page'\n*\n DA#STR 'LNKLST   - Process all of the datasets in the current LNKLST'\n*\n DA#STR 'LOADMOD  - Perform a MVS LOAD for all members in a load'\n DA#STR '           library to ensure that they are LOADable.'\n*\n DA#STR 'LPALST   - Process all of the datasets in the current LPALST'\n*\n DA#STR 'MEMXREF  - Perform Member Cross reference on the libraries'\n DA#STR '           processed.  The REPORT file has some member'\n DA#STR '           information and the data set name of the library'\n DA#STR '           it was found in.  All members are shown.'\n*\n DA#STR 'NIVENDOR - Don''t use internal Vendor CSECT table, only'\n DA#STR '           members in the //IVCSECT PDS concatenation will '\n DA#STR '           be considered.  This is used with the IVCSECTx '\n DA#STR '           options'\n*\n DA#STR 'ONLYFIND - Only process the modules that are found using'\n DA#STR '           the FINDMEM= value'\n*\n DA#STR 'PREFIX=  - Use a different DD prefix for specifing the files'\n DA#STR '           to be processed, the default is SYSLIB. All of the'\n DA#STR '           files allocated to the job step with this prefix'\n DA#STR '           will be processed in addition to other options'\n DA#STR '           like LNKLST, LPALST, etc.'\n*\n DA#STR 'SIMULATE - Show the files that would have been processed.  No'\n DA#STR '           reporting is performed but every library has a'\n DA#STR '           MVS OPEN file I/O to ensure access'\n*\n DA#STR 'NOSMS    - Do not invoke DFSMS/MVS services when executing '\n DA#STR '           in a DFSMS/MVS environment. This disables some '\n DA#STR '           functions like TRANRPT and HISTRPT'\n*\n DA#STR 'NOSYSIN  - Do not process file SYSIN for options'\n*\n DA#STR 'NOTRANID - Do not convert Linkage Editor/Binder Translator'\n DA#STR '           program IDs to alias name on the report'\n*\n DA#STR 'TRANRPT  - Produce a Translator report on file TRANRPT. This '\n DA#STR '           function only works on DFSMS/MVS systems.'\n*\n DA#STR 'TSOVIEW  - When we do an internal hex dump, make the output'\n DA#STR '           fit in 80 columns for easy terminal viewing'\n*\n DA#STR 'ZAPRPT   - Create ZAP report on file ZAPRPT (non-DFSMS/MVS)'\n DA#STR '           Note: the ZAP information goes to the HISTRPT when'\n DA#STR '                 executing on a DFSMS/MVS system'\n*\n** Print the translators\n*\n DC  X'FE'                                Skip a line\n DC  X'FE'                                Skip a line\n DA#STR 'List of Translator IDs and Names:'\n DC  X'FE'                                Skip a line\n DC  X'FD'                                Print translators here\n*\n** Print the Linkage Editor/Binder Translators\n*\n DC  X'FE'                                Skip a line\n DC  X'FE'                                Skip a line\n DA#STR 'List of Linkage-Editor/Binder Translator IDs and Names:'\n DC  X'FE'                                Skip a line\n DC  X'FC'                                Print LKED/Binder Trans here\n*\n** Print the List of vendor CSECTs:\n*\n DC  X'FE'                                Skip a line\n DC  X'FE'                                Skip a line\n DA#STR 'List of Vendor CSECTs in internal table:'\n DC  X'FE'                                Skip a line\n DC  X'FB'                                Print LKED/Binder Trans here\n*\n** End of HELP CSECT\n*\n DC  X'FE'                                Skip a line\n DA#STR 'End of Help.'\n DC  X'FF'\n*\n** End of PDSR$HLP\n*\n         DROP  R12,R13\n         DS  0D\n         EJECT ,\n***********************************************************************\n***\n**           Dynamic Allocation (SVC 99) services\n**\n**     Input: DOUBLE2 - #R$PDS99_func\n**     Output: R15 has the return code from SVC 99 (DYNALLOC)\n***\n***********************************************************************\n         SPACE 2\nPDSR$DA  CSECT ,\nPDSR$DA  AMODE 24\nPDSR$DA  RMODE 24\n         USING PDSR$DA,R8                 Set base register for CSECT\n         USING WORKDS,R13                 Need this area\n*\n** Standard O/S eyecatcher\n*\nDA_EC          B    DA_ECL(0,R8)           Bump past EyeCatcher\n               DC   AL1(L'DA_ECLIT)        Length of eyecatcher\nDA_ECLIT       DC   C'PDSR$DA  - Dynamic Allocation'\n               DS   0H\nDA_ECL         EQU  *-DA_EC\n*\n** Format Request block and set up for DYNALLOC\n*\n         SPACE 1\n         LA    R4,RECOUT                  Get address of work area\n         ST    R4,DOUBLE                  Save address\n         OI    DOUBLE,S99RBPND            Indicate last one\n         XC    0(S99RBEND-S99RB,R4),0(R4) Clear Request Block area\n         MVI   S99RBLN-S99RB(R4),S99RBEND-S99RB Length of REQUEST BLK\n         LA    R5,S99RBEND-S99RB(R4)      Locate Text Units Pointers\n         ST    R5,S99TXTPP-S99RB(R4)      STORE ADDR OF Text Unit PTRs\n         LA    R6,20(R5)    5*4=20        Bump past Text pointers\n****\n**\n** The address of each of the text Units will be stored in the\n** request block text PTR area as they are being defined,\n** Active registers are: R5 - Address in text unit pointers\n**                       R6 - Address in text unit define area\n**\n****\n** What type of function to perform?\n*\n         CLI   DOUBLE2,#PDSR$DA$ADSN      Allocate by DSNAME\n         BE    DYNA$ADSN\n         CLI   DOUBLE2,#PDSR$DA$FDD       Free by DDNAME\n         BE    DYNA$FDD\n*\n         MVC   S99ERROR-S99RB(2,R4),=X'FFFFFFFF' Set internal error\n         LA    R15,20                     Set return code\n         B     DYNA$X\n         SPACE 2\n*\n** Allocate by DSNAME (AREAJFCB)\n*\nDYNA$ADSN EQU *\n         MVI   S99VERB-S99RB(R4),S99VRBAL    Verb = ALLOCATE\n***-(1)---------------------------------- DDNAME=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALRTDDN                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,8                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         LA    R1,S99TUPAR-S99TUNIT(R6)     Locate DDNAME\n         ST    R1,DOUBLE2                   Save Addr: Returned DDNAME\n*\n         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit\n***-(2)---------------------------------- DISP=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALSTATS                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,1                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVI   S99TUPAR-S99TUNIT(R6),8      DISP=SHR\n*\n         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit\n***-(3,LAST)----------------------------- DSN=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication\n*\n         LA    R14,DALDSNAM                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,44                       Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVC   S99TUPAR-S99TUNIT(44,R6),AREAJFCB\n***-------------------------------------- Complete and make request\n         B     DYNA$DA                      Perform DYNALLOC\n*\n** Free by DDNAME in PP_ADDN\n*\nDYNA$FDD EQU   *\n         MVI   S99VERB-S99RB(R4),S99VRBUN    Verb = Deallocation\n***-(1,LAST)----------------------------- DDNAME=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication\n*\n         LA    R14,DUNDDNAM                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,8                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVC   S99TUPAR-S99TUNIT(8,R6),PP_ADDN Get the DDNAME\n***-------------------------------------- Complete and make request\n*\n** Perform dynamic allocation\n*\nDYNA$DA EQU    *\n         LA    R1,DOUBLE                  Get address of Request BLK\n         DYNALLOC ,                       Invoke SVC 99\n*\n** Common exit from PDSR$DA\n*\nDYNA$X   EQU   *\n         BSM   0,R9                       Return to caller\n*\n** Constants for PDSR$DA\n*\n         LTORG ,\n         DS    0D\n*\n** Equates for function type (in first byte of DOUBLE2\n*\n#PDSR$DA$ADSN EQU 0\n#PDSR$DA$FDD   EQU 1\n         DROP  R8,R13\n         EJECT\n***********************************************************************\n***\n**       Load Module formating\n**\n**       This CSECT was created to save room in primary CSECT\n***\n***********************************************************************\n         SPACE 2\nPDSR$LMF CSECT ,\nPDSR$LMF AMODE 24\nPDSR$LMF RMODE 24\n*\n** Standard O/S eyecatcher\n*\nLMF_EC        B    LMF_ECL(0,R15)         Bump past EyeCatcher\n              DC   AL1(L'LMF_ECLIT)       Length of eyecatcher\nLMF_ECLIT     DC   C'PDSR$LMF - Load Module formating'\n              DS   0H\nLMF_ECL       EQU  *-LMF_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$LMF,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore registers R0 and R1\n         LR    R13,R1                     Locate RSA and work area\n         USING SUBRSA,R13                 Locate to data area\n*\n** Branch to routine\n*\n#LMF_HEADINGS EQU 1\n#LMF_FORMAT  EQU 2\n*\n         CH    R0,=AL2(#LMF_HEADINGS)     Want headings?\n         BE    LMF$HEADINGS\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Format detail line\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         EREG  R2,R3                      Get PDS2 area address\n*\n** Format EPA Information\n*\n         LA    R1,RECOUT+1                POINT TO OUTPUT LINE\n         UNPK  DET_LEPA-DET(7,R1),PDS2EPA-PDS2(4,R2)\n         MVZ   DET_LEPA-DET(6,R1),LMF_ZEROS\n         TR    DET_LEPA-DET(6,R1),LMF_HEXTABLE\n         MVI   DET_LEPA-DET+6(R1),C' '\n*\n** Format size and add to total PDS count\n*\n         LA    R1,RECOUT+1                POINT TO OUTPUT LINE\n         UNPK  DET_LSIZE-DET(7,R1),PDS2STOR-PDS2(4,R2)\n         MVZ   DET_LSIZE-DET(6,R1),LMF_ZEROS\n         TR    DET_LSIZE-DET(6,R1),LMF_HEXTABLE\n         MVI   DET_LSIZE-DET+6(R1),C' '\n*\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?\n         BNO   PPD$LSIZEX                 Yes, don't need it\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0111',PDS2STOR-PDS2(R2) Get size\n         L     R15,PPD_SIZE               Get current size\n         AR    R15,R1                     Add for this member\n         ST    R15,PPD_SIZE               Save it\nPPD$LSIZEX EQU *\n*\n** Do Amode and Rmode\n*\n         MVC   RECOUT+1+DET_LMODER-DET(2),=C'24'\n         TM    PDS2FTB2-PDS2(R2),PDSLRMOD\n         BNO   PPD$MODE_RX\n         MVC   RECOUT+1+DET_LMODER-DET(3),=C'Any'\nPPD$MODE_RX EQU *\n*\n         TM    PDS2FTB2-PDS2(R2),PDSMAMOD  Both on?\n         BO    PPD$MODE_AANY              Yes, its ANY\n         TM    PDS2FTB2-PDS2(R2),BIT6     Just one?\n         BO    PPD$MODE_A31               Yes, its 31\n         MVC   RECOUT+1+DET_LMODEA-DET(2),=C'24'\n         B     PPD$MODE_AX\nPPD$MODE_A31 EQU *\n         MVC   RECOUT+1+DET_LMODEA-DET(2),=C'31'\n         B     PPD$MODE_AX\nPPD$MODE_AANY EQU *\n         MVC   RECOUT+1+DET_LMODEA-DET(3),=C'Any'\nPPD$MODE_AX EQU *\n*\n** Process module attributes\n*\n         LA    R7,RECOUT+1+DET_LATTR-DET\n         TM    PDS2ATR2-PDS2(R2),PDS2FLVL\n         BNO   PPD$PM_FOX\n         MVC   0(2,R7),=C'FO'\n         LA    R7,3(R7)\nPPD$PM_FOX EQU  *\n         TM    PDS2ATR1-PDS2(R2),PDS2EXEC\n         BO    PPD$PMA1\n         MVC   0(2,R7),=C'NX'\n         LA    R7,3(R7)\n         L     R1,PPD_NEX\n         LA    R1,1(R1)\n         ST    R1,PPD_NEX\nPPD$PMA1 EQU   *\n         TM    PDS2ATR1-PDS2(R2),PDS2RENT\n         BNO   PPD$PMA2\n         MVC   0(2,R7),=C'RE'\n         LA    R7,3(R7)\nPPD$PMA2 EQU   *\n         TM    PDS2ATR1-PDS2(R2),PDS2REUS\n         BNO   PPD$PMA3\n         MVC   0(2,R7),=C'RU'\n         LA    R7,3(R7)\nPPD$PMA3 EQU   *\n         TM    PDS2ATR1-PDS2(R2),PDS2OVLY\n         BNO   PPD$PMA4\n         MVC   0(2,R7),=C'OV'\n         LA    R7,3(R7)\nPPD$PMA4 EQU   *\n*\n** Process Load module section\n**\n** Locating the PDS sections is documented in the comments of the\n** 'SYS1.AMODGEN(IHAPDS)' macro.\n*\n         LA    R5,PDSBCEND-PDS2(R2)       Locate end of PDS2 Area\n         TM    PDS2ATR1-PDS2(R2),PDS2SCTR Scatter Load?\n         BNO   PPD$LMS_SCX                No, continue\n         LA    R5,PDSS01LN(R5)            Bump past scatter section\nPPD$LMS_SCX EQU *\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?\n         BNO   PPD$LMS_ALX                No, Continue\n         LA    R1,RECOUT+1                Point to output line\n         MVC   DETALIAS-DET(2,R1),=C'-A'\n         MVC   DETALIAS+3-DET(8,R1),PDS2MNM-PDSS02(R5)\n         L     R1,PPD_NALIAS              Get current alias count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PPD_NALIAS              Save current alias count\n*\n         LA    R1,AREABLDL                Locate work area\n         XC    0(BLDLAL,R1),0(R1)         Clear it to zeros\n         MVC   BLDLA_FF-BLDLA(2,R1),=AL2(1) Set number of modules to 1\n         MVC   BLDLA_LL-BLDLA(2,R1),=AL2(BLDLAL-2) Set length\n         MVC   BLDLA_NAME-BLDLA(8,R1),PDS2MNM-PDSS02(R5)\n         LR    R0,R1                      Get parameter list address\n         BLDL  SYSMEM,(0)                 Perform BLDL\n         LA    R1,AREABLDL                Locate work area\n         CLC   BLDLA_TTR-BLDLA(3,R1),PDS2TTRP-PDS2(R2)\n         BNE   PPD$LMS_AL                 No, this puppy is orphaned\n         LTR   R15,R15                    Found?\n         BZ    PPD$LMS_ALBX               No, continue\nPPD$LMS_AL EQU *\n         LA    R1,RECOUT+1                Point to output line\n         MVI   DETALIAS-1-DET(R1),C'>'    Mark as not found\n         DA#SMODE 31                      Get into 31 bit mode\n         L     R14,PP_OTCP                -> Current entry in alias tab\n         C     R14,PP_OTLE                At last entry in table?\n         BE    PPD$LMS_ALB                Yes, skip it\n         MVC   ORPT_RNAME-ORPT(8,R14),PDS2MNM-PDSS02(R5) Real Name\n         LA    R1,AREABLDL                Locate BLDL area\n         MVC   ORPT_RTTR-ORPT(3,R14),BLDLA_TTR-BLDLA(R1)\n         MVC   ORPT_ANAME-ORPT(8,R14),PDS2NAME-PDS2(R2) Alias name\n         MVC   ORPT_ATTR-ORPT(3,R14),PDS2TTRP-PDS2(R2) Alias EPA\n         LA    R14,ORPTL(R14)             Bump to next entry\n         ST    R14,PP_OTCP                Save its position\nPPD$LMS_ALB    EQU *\n         DA#SMODE 24                      Get back to 24 bit mode\nPPD$LMS_ALBX   EQU *\n         LA    R5,PDSS02LN(R5)            Bump past Alias section\nPPD$LMS_ALX EQU *\n         TM    PDS2FTB1-PDS2(R2),PDS2SSI  SSI?\n         BNO   PPD$LMS_SSIX               No, Continue\n         LA    R1,RECOUT+1                Locate output line\n         UNPK  DET_LSSI-DET(9,R1),PDSSSIWD-PDSS03(5,R5)\n         MVZ   DET_LSSI-DET(8,R1),LMF_ZEROS\n         TR    DET_LSSI-DET(8,R1),LMF_HEXTABLE\n         MVI   DET_LSSI-DET+8(R1),C' '    Fix byte\n         LA    R5,PDSS03LN(R5)            Bump past SSI section\nPPD$LMS_SSIX EQU *\n         SLR   R15,R15                    Clear register\n         ICM   R15,B'0001',PDSAPFCT-PDSS04(R5) Get length of APF sect.\n         BZ    PPD$LMS$APFE               Zero, not there\n         IC    R15,PDSAPFAC-PDSS04(R5)    Get auth code\n         CVD   R15,DOUBLE                 Convert to packed\n         LA    R1,RECOUT+1                Locate output\n         UNPK  DET_LCODE+2-DET(2,R1),DOUBLE+7(1) Make zoned\n         OI    DET_LCODE+2+1-DET(R1),X'F0'  Fix sign byte\n         CLI   PDSAPFAC-PDSS04(R5),0      Zero?\n         BE    PPD$LMS$APFX               Yes, leave\n         TM    PPD_FLAG1,$PPD_F1APF       This an APF authorized lib?\n         BO    PPD$LMS$APFX               Yes, leave\n         TM    PP_FLAG1,$PP_F1LPALST      LPALST mode?\n         BO    PPD$LMS$APFX               Yes, all are APFed\n         L     R1,PPD_NAPF                Get count\n         LA    R1,1(R1)                   Increment by one\n         ST    R1,PPD_NAPF                Save it\n         B     PPD$LMS$APFX               Continue\nPPD$LMS$APFE EQU *\n         LA    R1,RECOUT+1                Locate output line\n         MVC   DET_LCODE+2-DET(2,R1),=CL2'??'  \"??\" like ISPF does...\nPPD$LMS$APFX EQU *\n         B     LMF$X\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Format headings\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nLMF$HEADINGS DS 0H\n         LA    R15,PRR_LHEAD1             Locate heading record\n         CLI   0(R15),0                   First time thru?\n         BNE   PP$RFU_HEADX               No, continue\n         BAS   R14,LMF$PTR                Clear to blanks\n         LA    R15,1(R15)                 Bump past FBA byte\n         USING DET,R15\n         L     R1,=V(PDSR$C2)             -> Constant CSECT\n         USING PDSR$C2,R1\n         MVC   DET_LTD_DATE(11),C_DET_LTRANT\n         MVC   DET_LTNAME(11),C_DET_LTRANT\n         MVC   DET_LMODE(7),C_DET_LMODE1\n         MVC   DET_LZAP+1(3),C_DET_LZAP1\n         TM    W_FLAG1,$W_F1DFSMS         Using DFSMS/MVS services?\n         BNO   PP$HCS1                    No, don't have CSECT count\n         MVC   DET_LCSECT+2(5),C_DET_LCSECT-PDSR$C2(R1)\nPP$HCS1  DS    0H\n         LA    R15,PRR_LHEAD2\n         BAS   R14,LMF$PTR                Clear to blanks\n         LA    R15,1(R15)                 Bump past FBA byte\n         L     R1,=V(PDSR$C2)             -> Constant CSECT\n         USING PDSR$C2,R1\n         MVC   DETMEM(6),C_DETMEM\n         MVC   DETADDR(3),C_DETADDR\n         MVC   DETALIAS(5),C_DETALIAS\n         MVC   DET_LSIZE(4),C_DET_LSIZE\n         MVC   DET_LTD_DATE(15),C_DET_LTD_DATE\n         MVC   DET_LTNAME(15),C_DET_LTNAME\n         MVC   DET_LMODEA(4),C_DET_LMODEA\n         TM    W_FLAG1,$W_F1DFSMS         Using DFSMS/MVS services?\n         BNO   PP$HCS2                    No, don't have CSECT count\n         MVC   DET_LCSECT+2(5),C_DET_LCSECTN-PDSR$C2(R1)\nPP$HCS2  DS    0H\n         MVC   DET_LMODER(3),C_DET_LMODER\n         MVC   DET_LATTR(10),C_DET_LATTR\n         MVC   DET_LZAP+1(3),C_DET_LZAP\n         MVC   DET_LSSI+1(3),C_DET_LSSI\n         MVC   DET_LEPA(3),C_DET_LEPA\n         MVC   DET_LCODE(4),C_DET_LCODE\n         LA    R15,PRR_LHEAD3\n         BAS   R14,LMF$PTR                Clear to blanks\n         LA    R15,1(R15)                 Bump past FBA byte\n         L     R1,=V(PDSR$C2)             -> Constant CSECT\n         MVC   DETMEM(L'DETMEM),C_DASHS+1\n         MVC   DETALIAS(L'DETALIAS),C_DASHS+1\n         MVC   DETADDR(L'DETADDR),C_DASHS+1\n         MVC   DET_LSIZE(L'DET_LSIZE),C_DASHS+1\n         MVC   DET_LTD(DET_LTDL),C_DASHS+1\n         TM    W_FLAG1,$W_F1DFSMS  Using DFSMS/MVS services?\n         BNO   PP$HCS3             No, don't have CSECT count\n         MVC   DET_LCSECT(L'DET_LCSECT),C_DASHS+1\nPP$HCS3 DS 0H\n         MVC   DET_LTNAME(DET_LTNAMEL),C_DASHS+1\n         MVC   DET_LMODE(DET_LMODEL),C_DASHS+1\n         MVC   DET_LATTR(L'DET_LATTR),C_DASHS+1\n         MVC   DET_LZAP(L'DET_LZAP),C_DASHS+1\n         MVC   DET_LSSI(L'DET_LSSI),C_DASHS+1\n         MVC   DET_LEPA(L'DET_LEPA),C_DASHS+1\n         MVC   DET_LCODE(L'DET_LCODE),C_DASHS+1\n         DROP  R1,R15\nPP$RFU_HEADX EQU *\n         B     LMF$X\nLMF$PTR  EQU   *\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         BSM   0,R14                      Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Common Exit from PDSR$LMF\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nLMF$X    DS    0H\n         PR    ,                          Return to caller\n*\n** Constants\n*\nLMF_ZEROS    DC    X'00,00,00,00,00,00,00,00'\nLMF_HEXTABLE DC    C'0123456789abcdef'\n         LTORG ,                          Literals\n*\n** Calculate length of module\n*\n#PDSR$LMF EQU  *-PDSR$LMF\n#PDSR$LMF_LEFT EQU 4096-#PDSR$LMF\n         DROP  R13,R12\n         EJECT\n***********************************************************************\n***\n**       ISPF Stats formating\n**\n**       This CSECT was created to save room in primary CSECT\n***\n***********************************************************************\n         SPACE 2\nPDSR$IS  CSECT ,\nPDSR$IS  AMODE 24\nPDSR$IS  RMODE 24\n*\n** Standard O/S eyecatcher\n*\nIS_EC         B    IS_ECL(0,R15)          Bump past EyeCatcher\n              DC   AL1(L'IS_ECLIT)        Length of eyecatcher\nIS_ECLIT      DC   C'PDSR$IS  - ISPF Stats formating'\n              DS   0H\nIS_ECL        EQU  *-IS_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$IS,R12                Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore registers R0 and R1\n         LR    R13,R1                     Locate RSA and work area\n         USING SUBRSA,R13                 Locate to data area\n*\n** Branch to routine\n*\n#IS_HEADINGS EQU 1\n#IS_FORMAT   EQU 2\n*\n         CH    R0,=AL2(#IS_HEADINGS)      Want headings?\n         BE    IS$HEADINGS\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Format ISPF stats\n**\n** Input: R2 has PDS entry\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIS$FORMAT DS 0H\n         LA    R4,RECOUT+1                Locate output\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?\n         BNO   IS$FALX                    No, continue\n         L     R1,PPD_NALIAS              Get current alias count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PPD_NALIAS              Save current alias count\n         MVC   DETALIAS-DET(2,R4),=C'-A'\n* Note: we could look at PDS2TTRP and determine real name...\nIS$FALX  DS    0H\n         TM    PDS2INDC-PDS2(R2),X'0F'    ISPF Stats?\n         BO    IS$FSTAT                   Yes, get stats\n         L     R1,PPD_NNSSTAT             Get count\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PPD_NNSSTAT             Save count\n         B     IS$X                       Continue\nIS$FSTAT DS    0H\n         LA    R8,PDS2USRD-PDS2(R2)       Locate to user data (Stats)\n*\n** Version/modification levels\n*\n         SLR   R1,R1                      Clear register\n         IC    R1,UDISPF_VER-UDISPF(R8)   Get Version\n         CVD   R1,DOUBLE                  Convert to packed\n         UNPK  DET_IVER-DET(2,R4),DOUBLE+6(2) Convert to zoned\n         OI    DET_IVER-DET+1(R4),X'F0'   Fix sign byte\n         MVI   DET_IVMD-DET(R4),C'.'      Move in delimiter\n         SLR   R1,R1                      Clear register\n         IC    R1,UDISPF_MOD-UDISPF(R8)   Get Modification\n         CVD   R1,DOUBLE                  Convert to packed\n         UNPK  DET_IMOD-DET(2,R4),DOUBLE+6(2) Convert to zoned\n         OI    DET_IMOD-DET+1(R4),X'F0'   Fix sign byte\n*\n** Get creation date\n*\n**       MVI   EJ_IDJULP4_STR,0\n**       MVC   EJ_IDJULP4_STR+1(3),UDISPF_CDATE-UDISPF+1(R8)\n         MVC   EJ_IDJULP4_STR(4),UDISPF_CDATE-UDISPF(R8)\n         LA    R14,DET_ICDATE-DET(R4)\n         ST    R14,EJ_ODGEUR11A_STR\n         LA    R14,DET_ICDATED-DET(R4)\n         ST    R14,EJ_ODDOW3A_STR\n         BAS   R9,IS$EDIT_JULIAN\n*\n** Process changed date and time\n*\n         MVC   EJ_IDJULP4_STR(4),UDISPF_LDATE-UDISPF(R8)\n         LA    R14,DET_ILDATE-DET(R4)\n         ST    R14,EJ_ODGEUR11A_STR\n         LA    R14,DET_ILDATED-DET(R4)\n         ST    R14,EJ_ODDOW3A_STR\n         BAS   R9,IS$EDIT_JULIAN\n*\n         MVC   DET_ILTIME-DET(6,R4),=X'40,20,20,7A,20,21'\n         ED    DET_ILTIME-DET(6,R4),UDISPF_LTIME-UDISPF(R8)\n*\n         SLR   R1,R1\n         ICM   R1,B'0011',UDISPF_SIZE-UDISPF(R8)\n         BZ    IS$FSIZEX\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?\n         BO    IS$FSIZES             Yes, skip increment of size/lines\n         L     R15,PPD_SIZE          Get current size\n         AR    R15,R1                Add for this member\n         ST    R15,PPD_SIZE          Save it\nIS$FSIZES DS   0H\n         CVD   R1,DOUBLE\n         MVC   DET_ISIZE-DET(6,R4),=X'40,20,20,20,20,20'\n         ED    DET_ISIZE-DET(6,R4),DOUBLE+5\nIS$FSIZEX DS   0H\n         OI    DET_ISIZE-DET+5(R4),C'0'\n*\n         SLR   R1,R1\n         ICM   R1,B'0011',UDISPF_INIT-UDISPF(R8)\n         BZ    IS$FINITX\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS  Alias?\n         BO    IS$FINITS             Yes, skip increment of size/lines\n         L     R15,PPD_IINIT         Get current size\n         AR    R15,R1                Add for this member\n         ST    R15,PPD_IINIT         Save it\nIS$FINITS DS   0H\n         CVD   R1,DOUBLE\n         MVC   DET_IINIT-DET(6,R4),=X'40,20,20,20,20,20'\n         ED    DET_IINIT-DET(6,R4),DOUBLE+5\nIS$FINITX DS   0H\n         OI    DET_IINIT-DET+5(R4),C'0'\n*\n         SLR   R1,R1\n         ICM   R1,B'0011',UDISPF_MODL-UDISPF(R8)\n         BZ    IS$FMODLX\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?\n         BO    IS$FMODLS             Yes, skip increment of size/lines\n         L     R15,PPD_IMODL         Get current size\n         AR    R15,R1                Add for this member\n         ST    R15,PPD_IMODL         Save it\nIS$FMODLS DS   0H\n         CVD   R1,DOUBLE\n         MVC   DET_IMODL-DET(6,R4),=X'40,20,20,20,20,20'\n         ED    DET_IMODL-DET(6,R4),DOUBLE+5\nIS$FMODLX DS   0H\n         OI    DET_IMODL-DET+5(R4),C'0'\n*\n         MVC   DET_IUID-DET(7,R4),UDISPF_UID-UDISPF(R8)\n*\n** Here we process the BKLIDs entries.  These entries may have been\n** Read in from the //BKLIDS file or userids already looked up via\n** RACF calls (see code just below this).\n*\n         ICM   R9,B'1111',RBF_PTR          Get table address\n         BZ    IS$RBEX\n         ICM   R0,B'1111',BKLH_USERC-BKLH(R9) Get user count\n         BZ    IS$RBEX\n         LA    R9,BKLHL(R9)                Bump past header\nIS$RBEL  DS    0H\n         CLC   BKLE_USER-BKLE(7,R9),UDISPF_UID-UDISPF(R8)\n         BE    IS$RBEF\n         LA    R9,BKLEL(R9)\n         BCT   R0,IS$RBEL\n         B     IS$RBEX\nIS$RBEF  DS    0H\n         LA    R15,DET_IUID+L'DET_IUID+1-DET(R4)\n         MVI   0(R15),C'-'\n         MVC   2(L'BKLE_NAME,R15),BKLE_NAME-BKLE(R9)\n         B     IS$X\nIS$RBEX  DS    0H\n*\n** Ask RACF (nicely) if we can have userid information on this guy\n*\n* Note: this code is not fully functional.  That is to say that\n*       I have only tested it on a system running ACF2 and I see\n*       RC=18 (24) - I/O error accessing RACF database. It is possible\n*       that this code *may* work on an actual RACF system...\n*\n         TM    PPC_FLAG5,$PPC_F5CALLRACF  Call RACF?\n         BNO   IS$RLX                     Nope, Continue\n MVC   RACF_ENTRY(8),UDISPF_UID-UDISPF(R8) Get TSO user name\n LA    R0,8\n LA    R1,RACF_ENTRYL                     Locate entry\n BAS   R14,SET_ENTRY_LENGTH               Set entry length\n*\n CLI   RACF_ENTRY,C' '                    Have a TSO UserID yet?\n BE    IS$RLX                             No, skip it\n CLI   RACF_ENTRY,0                       Have a TSO UserID yet?\n BE    IS$RLX                             No, skip it\n*\n XC    WORKAREA(256),WORKAREA             Clear first 256 bytes\n LA    R1,L'WORKAREA                      Get length of WKAREA\n ST    R1,WORKAREA                        Save it\n MVC   PARMLIST(C_RLOCUL),C_RLOCU         Initialize parameter list\n ICHEINTY LOCATE,TYPE='USR',              Get USER information         @\n               ENTRY=RACF_ENTRYL,         ..UserID Location            @\n               WKAREA=WORKAREA,           ..Return area                @\n               MF=(E,PARMLIST)            ..Execute from here\n LTR   R15,R15\n BNZ   IS$RLE\n SLR   R14,R14                            Clear register\n ICM   R14,B'0001',WORKAREA+31            Get programmer name length\n BZ    IS$RLX                             Zero, leave\n         LA    R15,DET_IUID+L'DET_IUID+1-DET(R4)\n         MVI   0(R15),C'-'\n BCTR  R14,0                              Decrement for EX\n EX    R14,IS$RLM                         Get programmer name\n*-Here we should insert code to save userids into BKL control block\n B     IS$RLX\nIS$RLE DS    0H\n ST    R15,DOUBLE\n         LA    R15,DET_IUID+L'DET_IUID+1-DET(R4)\n         MVI   0(R15),C'-'\n         MVC   2(19,R15),=C'icheinty locate rc='\n         LA    R15,2+19(R15)\n         UNPK  0(9,R15),DOUBLE(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         MVI   8(R15),C' '\n         B     IS$RLX\nIS$RLM MVC   2(0,R15),WORKAREA+32         Get programmer name\n*\nC_RLOCU  ICHEINTY LOCATE,TYPE='USR',                                   @\n               ACTIONS=(C_UNAME),         ..User Name                  @\n               RELEASE=1.8,               ..RACF release               @\n               MF=L\nC_RLOCUL EQU   *-C_RLOCU\n*\nC_UNAME  ICHEACTN FIELD=NAME,MF=L\nIS$RLX DS 0H\n         B     IS$X\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Misc int subroutines\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Set RACF entry length\n** Input: R0 - max length of entry\n**        R1 - address of entry\n*\nSET_ENTRY_LENGTH EQU *\n LA    R15,1(R1)                          Bump past length byte\nSEL$L EQU *\n CLI   0(R15),C' '                        Blank?\n BE    SEL$LX                             Yes, leave\n CLI   0(R15),0                           Zero?\n BE    SEL$LX                             Yes, leave\n LA    R15,1(R15)                         No, bump to next byte\n BCT   R0,SEL$L                           Repeat\nSEL$LX EQU *\n BCTR  R15,0                              Decrement for EX\n SR    R15,R1                             Length = End - Beginning\n STC   R15,0(R1)                          Save length\n BSM   0,R14\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Create headings\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIS$HEADINGS DS 0H\n         LA    R15,PRR_IHEAD1             Locate heading record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         LA    R15,1(R15)                 Bump past FBA byte\n         USING DET,R15\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         USING PDSR$C2,R1\n         MVC   DETMEM(6),C_DETMEM\n         MVC   DETADDR(3),C_DETADDR\n         MVC   DETALIAS(5),C_DETALIAS\n         MVC   DET_IVER(5),C_DET_IVER\n         MVC   DET_ICDATE+5(7),C_DET_ICDATE\n         MVC   DET_ILDATE+7(7),C_DET_ILDATE\n         MVC   DET_ISIZE+2(4),C_DET_ISIZE\n         MVC   DET_IINIT+2(4),C_DET_IINIT\n         MVC   DET_IMODL+3(3),C_DET_IMODL\n         MVC   DET_IUID(6),C_DET_IUID\n         DROP  R15,R1\n*\n         LA    R15,PRR_IHEAD2             Locate heading record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         LA    R15,1(R15)                 Bump past FBA byte\n         USING DET,R15\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         USING PDSR$C2,R1\n         MVC   DETMEM(L'DETMEM),C_DASHS+1\n         MVC   DETADDR(L'DETADDR),C_DASHS+1\n         MVC   DETALIAS(L'DETALIAS),C_DASHS+1\n         MVC   DET_IVER(DET_IVVMML),C_DASHS+1\n         MVC   DET_ICDATE(DET_ICDATEL),C_DASHS+1\n         MVC   DET_ILDATE(DET_ILTODL),C_DASHS+1\n         MVC   DET_ISIZE(L'DET_ISIZE),C_DASHS+1\n         MVC   DET_IINIT(L'DET_IINIT),C_DASHS+1\n         MVC   DET_IMODL(L'DET_IMODL),C_DASHS+1\n         MVC   DET_IUID(L'DET_IUID),C_DASHS+1\n         DROP  R15,R1\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Common Exit from ISPF_Statistics\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIS$X     DS    0H\n         PR    ,                          Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Edit input Julian to output area\n**\n** Keep in sync with EDIT_JULIAN: use same code!!!!!!\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIS$EDIT_JULIAN EQU *\n         L     R1,=V(PDSR$C1)\n         MVC   EJ_IDJULP4(C_IDJULP4L),C_IDJULP4-PDSR$C1(R1)\n         MVC   EJ_ODGEUR11A(C_ODGEUR11AL),C_ODGEUR11A-PDSR$C1(R1)\n         TM    PPC_IFLAG1,$PPC_IF1DATEISO ISO format?\n         BO    IS$EJ$CDISO\n         TM    PPC_IFLAG1,$PPC_IF1DATEUS  United States format?\n         BNO   IS$EJ$CDISOX               Use default of \"European\"\n         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODGUS Make Gregorian US\n         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODGUS10 Set length\n         B     IS$EJ$CDISOX\nIS$EJ$CDISO DS 0H\n         MVI   EJ_ODGEUR11A_TYPE+1,$DA#DATE_ODISO Make ISO\n         MVI   EJ_ODGEUR11A_STRL,$DA#DATE_ODISO10 Set length\nIS$EJ$CDISOX DS 0H\n         MVC   EJ_ODDOW3A(C_ODDOW3AL),C_ODDOW3A-PDSR$C1(R1)\n         DA#SMODE 31                      Must be in 31 bit mode\n         L     R15,EP_DA$DATE             Locate EPA of DA$DATE routine\n         CALL  (15),(EJ_IDJULP4,EJ_ODGEUR11A,EJ_ODDOW3A),              @\n               VL,MF=(E,PARMLIST)\n         DA#SMODE 24                      Back to 24 bit mode\n         BSM   0,R9\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Constants\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LTORG ,                          Literals\n*\n** Calculate length of module\n*\n#PDSR$IS EQU   *-PDSR$IS\n#PDSR$IS_LEFT EQU 4096-#PDSR$IS\n         DROP  R13,R12\n         EJECT\n***********************************************************************\n***\n**       Dataset Summary processing\n**\n**       This CSECT was created to save room in primary CSECT\n***\n***********************************************************************\n         SPACE 2\nPDSR$DSP CSECT ,\nPDSR$DSP AMODE 24\nPDSR$DSP RMODE 24\n*\n** Standard O/S eyecatcher\n*\nDSP_EC        B    DSP_ECL(0,R15)         Bump past EyeCatcher\n              DC   AL1(L'DSP_ECLIT)       Length of eyecatcher\nDSP_ECLIT     DC   C'PDSR$DSP - Dataset Summary Processing'\n              DS   0H\nDSP_ECL       EQU  *-DSP_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$DSP,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore registers R0 and R1\n         LR    R13,R1                     Locate RSA and work area\n         USING SUBRSA,R13                 Locate to data area\n         SPACE 2\n*\n** Complete this dataset's information\n*\n         L     R3,PP_DSUMA                Get address of area\n         L     R4,DSUMH_CURR-DSUMH(R3)    Get current entry\n*\n** Look at this datasets attributes\n**\n** The most I expect here is 7 bytes total used:\n**\n** \"LNK    \",   \"LNK APF\",  \"LPA    \",  \"LPA APF\",  \"APF    \"\n**\n*\n         LA    R15,DSUME_ATTR-DSUME(R4)\n         TM    PP_FLAG1,$PP_F1LNKLST\n         BNO   DSP$ATTR$LNKLSTX\n         MVC   0(3,R15),=C'LNK'\n         LA    R15,4(R15)\nDSP$ATTR$LNKLSTX DS 0H\n         TM    PP_FLAG1,$PP_F1LPALST\n         BNO   DSP$ATTR$LPALSTX\n         MVC   0(3,R15),=C'LPA'\n         LA    R15,4(R15)\nDSP$ATTR$LPALSTX DS 0H\n         TM    PPD_FLAG1,$PPD_F1APF\n         BNO   DSP$ATTR$APFLSTX\n         MVC   0(3,R15),=C'APF'\n         LA    R15,4(R15)\nDSP$ATTR$APFLSTX DS 0H\n*\n** Get fields from the JFCB\n*\n         LA    R5,AREAJFCB                Locate \"JFCB\"\n         MVC   DSUME_VOL-DSUME(L'DSUME_VOL,R4),JFCBVOLS-INFMJFCB(R5)\n         MVC   DSUME_DSN-DSUME(L'DSUME_DSN,R4),JFCBDSNM-INFMJFCB(R5)\n         MVC   DSUME_DDNAME-DSUME(L'DSUME_DDNAME,R4),PP_PDDN\n*\n         LA    R6,AREADSCB                Locate DSCB\n         TM    DS1DSORG-DS1FMTID(R6),DS1DSGPO PDS?\n         BNO   DSP$POE\n         LH    R1,DS1LSTAR-DS1FMTID(R6)   Load tracks used\n         N     R1,=X'0000FFFF'            Turn off high order bytes\n         LA    R1,1(R1)                   Add one\n         L     R0,DSUMH_CNTTRKU-DSUMH(R3) Get total\n         AR    R0,R1\n         ST    R0,DSUMH_CNTTRKU-DSUMH(R3) save new total\n         CVD   R1,DOUBLE                  Convert number to packed\n         MVC   DSUME_TRKU-DSUME(6,R4),=X'40,20,20,20,20,20'\n         ED    DSUME_TRKU-DSUME(6,R4),DOUBLE+5\n*\n         L     R1,PPD_TRKA\n         L     R0,DSUMH_CNTTRKA-DSUMH(R3) Get total\n         AR    R0,R1\n         ST    R0,DSUMH_CNTTRKA-DSUMH(R3) save new total\n         CVD   R1,DOUBLE                  Convert number to packed\n         MVC   DSUME_TRKA-DSUME(6,R4),=X'40,20,20,20,20,20'\n         ED    DSUME_TRKA-DSUME(6,R4),DOUBLE+5\n*\n         SR    R1,R1\n         IC    R1,DS1NOEPV-DS1FMTID(R6)   Get extents\n*\n         TM    PP_FLAG1,$PP_F1LNKLST      Is this a LNKLST dataset?\n         BNO   DSP$LEX\n         L     R0,DSUMH_LLE-DSUMH(R3)     Get LNKLST extents\n         TM    DS1SMSFG-DS1FMTID(R6),DS1PDSE PDSE?\n         BO    DSP$LEP                    Yes, count only as 1 extent\n         AR    R0,R1                      Add all extents for this guy\n         BO    DSP$LEPX                   Continue\nDSP$LEP  DS    0H\n         AH    R0,=H'1'                   Add only 1 extent for PDSE\nDSP$LEPX DS    0H\n         ST    R0,DSUMH_LLE-DSUMH(R3)     Save LNKLST extents\nDSP$LEX  DS    0H\n*\n         CVD   R1,DOUBLE                  Convert to packed\n         UNPK  DSUME_EXTENTS-DSUME(2,R4),DOUBLE+6(2) Convert to zoned\n         OI    DSUME_EXTENTS-DSUME+1(R4),X'F0' Fix sign byte\n*\n         L     R1,PPD_NMEM                Number of members\n         L     R0,DSUMH_CNTMEM-DSUMH(R3)  Get total\n         AR    R0,R1\n         ST    R0,DSUMH_CNTMEM-DSUMH(R3)  Save new total\n         CVD   R1,DOUBLE                  Convert number to packed\n         MVC   DSUME_MEMBERS-DSUME(6,R4),=X'40,20,20,20,20,20'\n         ED    DSUME_MEMBERS-DSUME(6,R4),DOUBLE+5\n         B     DSP$POX\nDSP$POE  DS    0H\n         MVC   DSUME_ATTR-DSUME(7,R4),=C'Not PDS'\nDSP$POX  DS    0H\n*\n         LA    R15,DSUME_RECFM-DSUME(R4)\n         TM    DS1RECFM-DS1FMTID(R6),DS1RECFU\n         BO    PJ$DR1U\n         TM    DS1RECFM-DS1FMTID(R6),DS1RECFF\n         BO    PJ$DR1F\n         TM    DS1RECFM-DS1FMTID(R6),DS1RECFV\n         BO    PJ$DR1V\n         MVI   0(R15),C'?'\n         B     PJ$DR1X\nPJ$DR1U  EQU   *\n         MVI   0(R15),C'U'\n         B     PJ$DR1X\nPJ$DR1V  EQU   *\n         MVI   0(R15),C'V'\n         B     PJ$DR1X\nPJ$DR1F  EQU   *\n         MVI   0(R15),C'F'\nPJ$DR1X  EQU   *\n         LA    R15,1(R15)\n         TM    DS1RECFM-DS1FMTID(R6),DS1RECFB\n         BNO   PJ$DR2X\n         MVI   0(R15),C'B'\n         LA    R15,1(R15)\nPJ$DR2X  EQU   *\n         TM    DS1RECFM-DS1FMTID(R6),DS1RECFA\n         BO    PJ$DR3A\n         TM    DS1RECFM-DS1FMTID(R6),DS1RECMC\n         BO    PJ$DR3M\n         B     PJ$DR3X\nPJ$DR3A  EQU   *\n         MVI   0(R15),C'A'\n         LA    R15,1(R15)\n         B     PJ$DR3X\nPJ$DR3M  EQU   *\n         MVI   0(R15),C'M'\n         LA    R15,1(R15)\nPJ$DR3X  EQU   *\n*\n** Locate to next one\n*\n         LA    R4,DSUMEL(R4)              Locate to next entry\n         ST    R4,DSUMH_CURR-DSUMH(R3)    Set next current entry\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Common Exit from Dataset_Summary_Processing\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nDSP$X    DS    0H\n         PR    ,                          Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Constants\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LTORG ,                          Literals\n*\n** Calculate length of module\n*\n#PDSR$DSP EQU  *-PDSR$DSP\n#PDSR$DSP_LEFT EQU 4096-#PDSR$DSP\n         DROP  R13,R12\n         EJECT\n***********************************************************************\n***\n**       Parse parameter card\n***\n***********************************************************************\n         SPACE 2\n*\n#PPC_OPTION_PARM  EQU 0                   Option: parse parm card\n#PPC_OPTION_SYSIN EQU 1                   Option: parse SYSIN record\n#PPC_RC_OK        EQU 0                   Return code: Parse okay\n#PPC_RC_EOF       EQU 4                   Return code: EOF on SYSIN\n#PPCIRL           EQU 71                  Input Record Length\n*\nPDSR$PPC CSECT ,\nPDSR$PPC AMODE 24\nPDSR$PPC RMODE 24\n*\n** Standard O/S eyecatcher\n*\nPPC_EC        B    PPC_ECL(0,R15)         Bump past EyeCatcher\n              DC   AL1(L'PPC_ECLIT)       Length of eyecatcher\nPPC_ECLIT     DC   C'PDSR$PPC - Parse Parameter Card and SYSIN'\n              DS   0H\nPPC_ECL       EQU  *-PPC_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSR$PPC,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore registers R0 and R1\n         LR    R13,R1                     Locate RSA and work area\n         USING SUBRSA,R13                 Locate to data area\n*\n** Decide why we are here\n*\nPARSE_PARAMETER_CARD DS 0H\n         NI    PPC_IFLAG1,255-$PPC_IF1DATESET\n*\n         STC   R0,PPC_OPTION              Save option\n         CH    R0,=AL2(#PPC_OPTION_PARM)  Parsing PARM= card?\n         BE    PPC$PARM\n         CH    R0,=AL2(#PPC_OPTION_SYSIN) Parsing SYSIN?\n         BE    PPC$SYSIN\n         B     PPC$X\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Parse the SYSIN input file (1 record at a time)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPC$SYSIN DS   0H\n         TM    PPCSI_FLAG1,$PPCSI_F1OIF   Opened Input file yet?\n         BO    PPC$SIOX\n         OI    PPCSI_FLAG1,$PPCSI_F1OIF   We opened SYSIN...\n         MVC   PPCSI_NUM(2),PPC_NUM       Save number of errors\n         DEVTYPE =CL8'SYSIN',DOUBLE       Is file allocated?\n         LTR   R15,R15\n         BNZ   PPC$SIEX\n         LA    R3,PPCSI_DCB               Locate DCB work area\n         L     R1,=V(PDSR$C1)\n         MVC   0(C_DCBIL,R3),C_DCBI-PDSR$C1(R1)\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'SYSIN'    Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1)\n         LA    R2,PPC$SIEOF               Locate END-OF-FILE area\n         STCM  R2,B'0111',DCBEODAD-IHADCB+1(R3) Insert into DCB\n         OPEN  ((3),(INPUT)),MF=(E,PARMLIST)\nPPC$SIOX DS    0H\n*\n** Read and process SYSIN record\n*\n         GET   PPCSI_DCB                  Get input record - DD=SYSIN\n         LR    R7,R1                      Get address of input record\n         LA    R6,#PPCIRL                 Set max length to consider\n*-Trim trailing blanks on input record\n         LR    R1,R7                      Get start of record\n         AR    R1,R6                      Locate to last byte (+1)\n         BCTR  R1,0                       Backup to last actual byte\nPPC$SITL DS    0H\n         CLI   0(R1),C' '                 Blank?\n         BNE   PPC$SITX                   No, found end of line\n         BCTR  R1,0                       Backup one more byte\n         BCTR  R6,0                       Decrement line length\n         LTR   R6,R6                      Any more to do?\n         BNZ   PPC$SITL                   Process next line\nPPC$SITX DS    0H\n*\n         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area\n         MVC   0(4,R15),MSG2-PDSR$MSG(R1) Move in \"002I\"\n         LA    R15,5(R15)                 Bump past it\n         MVC   0(6,R15),=C'SYSIN:'        Insert text\n         LA    R15,7(R15)\n         MVC   0(#PPCIRL,R15),0(R7)       Get record\n         BAS   R14,PPC$SI_PSR             Print Sysprint Record\n         LTR   R6,R6                      Blank record?\n         BZ    PPC$X                      Yes, no need to parse\n         CLI   0(R7),C'*'                 Comment card?\n         BE    PPC$X                      Yes, no need to parse\n*\n         XC    PPC_COL(2),PPC_COL         Start fresh\n         XC    PPC_NUM(2),PPC_NUM         Start fresh\n         B     PPC$PARSE                  Parse input record\n*\n** Print the parsing errors for this SYSIN card (if any)\n*\nPPC$SIPE DS    0H\n         SLR   R1,R1                      Zero out register\n         ICM   R1,B'0011',PPC_NUM         Get number of parms errors\n         BZ    PPC$SIPE_ERRX              None, leave\n         AH    R1,PPCSI_NUM               Add to total\n         STH   R1,PPCSI_NUM               Save new total\n*\n         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area\n         MVC   0(4,R15),MSG3-PDSR$MSG(R1) Move in message ID\n         LA    R15,12(R15)                Locate past \"002I SYSIN: \"\n         L     R1,=V(PDSR$C1)\n         MVC   0(#PPCIRL,R15),C_COLS-PDSR$C1(R1)\n         BAS   R14,PPC$SI_PSR             Print Sysprint Record\n*\n         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG3L,R15),MSG3-PDSR$MSG(R1) Move in message\n         LA    R15,MSG3L+1(R15)           Bump past it\n         LH    R1,PPC_COL                 Get parameter column\n         LA    R1,1(R1)                   Start from 1 not zero\n         BAS   R9,PPC$SI_EDITFWF          Print column number\n         BAS   R14,PPC$SI_PSR             Print Sysprint Record\nPPC$SIPE_ERRX DS 0H\n         TM    PPC_IFLAG1,$PPC_IF1DATESET Was the Date format set?\n         BNO   PPC$SIPE_DSX               No, continue\n         BAS   R14,PPC$SI_FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG59L,R15),MSG59-PDSR$MSG(R1) Move in message\n         BAS   R14,PPC$SI_PSR             Print Sysprint Record\nPPC$SIPE_DSX DS  0H\n         B     PPC$X\n*\n** End of file on SYSIN\n*\nPPC$SIEOF DS   0H\n         LA    R3,PPCSI_DCB               Locate DCB work area\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?\n         BNO   PPC$SIEX\n         L     R1,=V(PDSR$C1)\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1)\n         CLOSE ((3)),MF=(E,PARMLIST)      Close it\nPPC$SIEX DS    0H\n         MVC   PPC_NUM(2),PPCSI_NUM       Save total number of errors\n         LA    R15,#PPC_RC_EOF            Get return code\n         ST    R15,PPC_RC                 Save it\n         B     PPC$X                      Leave\n*\n** Print SYSPRINT Record\n*\nPPC$SI_PSR DS  0H\n         ST    R14,PSR_RA                 Save return address\n         LA    R0,PSRAREA                 Locate work area\n         LA    R1,RECOUT                  Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n         L     R14,PSR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Initialize message\n**\n** Output: R1 has PDSR$MSG\n*\nPPC$SI_FORMAT_MESSAGE DS 0H\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(L'RECOUT-1,R15),0(R15)\n         LA    R15,1(R15)\n         L     R1,=V(DA$PDSR)             -> main CSECT\n         MVC   0(7,R15),5(R1)             Move in \"DA$PDSR\"\n         MVI   7(R15),C'-'                Insert dash\n         LA    R15,MSGPREL(R15)           Bump past \"DA$PDSR-\"\n         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT\n         BSM   0,R14\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nPPC$SI_EDITFWF  EQU   *\n         LTR   R1,R1                      Check for 0\n         BZ    PPC$SI_EDITFWF0            Yes, put zero\n         CVD   R1,DOUBLE                  No, convert to packec\n         LA    R1,DOUBLE2+14              Locate sig digit\n         MVC   DOUBLE2(15),PPC$SI_EDITP15\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for ex\n         EX    R14,PPC$SI_EDITFWFM        Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '\n         BSM   0,R9                       Return to caller\nPPC$SI_EDITFWFM MVC 0(0,R15),0(R1)\nPPC$SI_EDITP15  DC X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nPPC$SI_EDITFWF0 DS 0H\n         MVI   0(R15),C'0'                Put in zero\n         LA    R15,1(R15)                 Bump pointer past zero\n         BSM   0,R9                       Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Parse the PARM= Card\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPC$PARM DS    0H\n*\n** Set defaults\n*\n         L     R1,=V(PDSR$C1)             -> Constants CSECT\n         MVI   PPC_DDPL,6-1               Set value length\n         MVC   PPC_DDP(6),C_DD_SYSLIB-PDSR$C1(R1)\n         MVC   PPC_WUNIT(8),C_WUNIT-PDSR$C1(R1)\n         LA    R1,52\n         STH   R1,PPC_LINECNT             Set as default line count\n         XC    W_AREA(256),W_AREA         Initialize\n*\n** See what register 1 has on input to DA$PDSR\n*\n         L     R1,PPC_R1ENTRY             -> CPPL\n         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?\n         BNO   PPC$NC                     No, need to look at CBUF\n*\n** We were called, it has a Batch type (EXEC) parameter\n*\n         L     R7,0(R1)                   Get address of parm\n         SLR   R6,R6                      Clear register\n         ICM   R6,B'0011',0(R7)           Get length of parm\n         BZ    PPC$X                      None, leave\n         LA    R7,2(R7)                   Bump past parm length HW\n         B     PPC$PARSE                  Parse the input\n*\n** We were not called, we are a \"TSO Command Processor\"\n*\nPPC$NC   EQU   *\n         L     R7,CPPLCBUF-CPPL(R1)       Locate Command Buffer\n         SLR   R6,R6                      Clear register\n         ICM   R6,B'0011',0(R7)           Get total CBUF length\n         SLR   R0,R0                      Clear register\n         ICM   R0,B'0011',2(R7)           Get total Command name length\n         LA    R15,4                      Length of header\n         AR    R7,R15                     Bump past header\n         SR    R6,R15                     Decrement for header length\n         AR    R7,R0                      Bump past Command length\n         SR    R6,R0                      Length of data\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**\n** Look thru command buffer/parameter for our commands\n**\n** Input: R7 - Address of command-buffer/Parameter\n**        R6 - Length of command-buffer/Parameter\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPC$PARSE EQU *\n         STM   R6,R7,PPC_BUFFER           Save length and address\n         B     PPC$DLMX\n*\n** Test for valid delimiter between operands\n*\nPPC$DLM  EQU   *\n         CLI   0(R7),C' '                 Valid delimiter?\n         BE    PPC$DLMS                   Yes, continue\n         CLI   0(R7),C','                 Valid delimiter?\n         BNE   PPC$OERR                   No, print error message\nPPC$DLMS EQU   *\n         LA    R7,1(R7)                   Bump past delimiter\n         BCT   R6,PPC$DLMX                Decrement count\n         B     PPC$END                    Hit zero: leave\nPPC$DLMX EQU   *\n*\n** Process keywords into program flags.\n**\n** This loop compares the value at R7 with flag strings and when\n** there is a match, we dynamically create an \"OI\" machine instruction\n** to turn on the flag. For example, if PARM='LNKLST\" is matched, this\n** machine instruction is generated:\n**\n**      OI   PPC_FLAG1,$PPC_F1LNKLST\n**\n** Since the PPC_FLAGx fields are in the WORKDS/SUBRSA area, the instr\n** must be based off R13 (hex \"D\") for it to update the right area.\n*\n         LA    R3,T_PFLAGSN               Get number of entries\n         LA    R2,T_PFLAGS                Locate flag\nPPC$FL   EQU   *\n         SLR   R15,R15                    Clear register\n         ICM   R15,B'0011',TPF_NAME-TPF(R2) Get offset of name string\n         AR    R15,R12                    Locate name string (TPF_???)\n         SLR   R14,R14                    Get ready for \"IC\"\n         IC    R14,0(R15)                 Get length of string\n         CR    R14,R6                     Room left for keyword?\n         BH    PPC$FLB                    No, skip this table entry\n         EX    R14,PPC$FNC                Match?\n         BE    PPC$FLX                    Yes, continue\nPPC$FLB  EQU   *\n         LA    R2,TPFL(R2)                Bump to next entry\n         BCT   R3,PPC$FL                  ..Process it\n         B     PPC$FX                     Continue: not a flag\nPPC$FNC  CLC   1(0,R15),0(R7)\nPPC$FOI  OI    *-*,4\nPPC$FLX  DS    0H\n         MVC   DOUBLE(4),PPC$FOI          Get Instruction\n         MVC   DOUBLE+1(1),TPF_FLAG-TPF(R2)    Set flag\n         MVC   DOUBLE+2(2),TPF_OFFSET-TPF(R2) Get offset\n         OI    DOUBLE+2,X'D0'             Register 13/SUBRSA\n**-Start of debugging code -----------------------------------------\n** This code block can be uncommented and run for debugging when you\n** want to see the machine instruction that gets dynamically created\n** to set flags on based on the option value\n*==>     STM  R14,R15,DOUBLE2\n*==>     LA   R15,PPCWTO+8\n*==>     MVC  0(10,R15),=C'MachInstr='\n*==>     LA   R15,10(R15)\n*==>     UNPK 0(9,R15),DOUBLE(5)\n*==>     MVZ  0(8,R15),=8X'00'\n*==>     TR   0(8,R15),=C'0123456789abcdef'\n*==>     MVI  8(R15),C' '\n*==>     L    R1,DOUBLE2+4\n*==>     MVC  9(0,R15),1(R1)\n*==>     EX   R14,*-6\n*==> PPCWTO WTO '                                                  '\n*==>     L  R14,DOUBLE2\n**-End of debugging code -----------------------------------------\n*\n         LA    R15,0                      Set up for EX\n         EX    R15,DOUBLE                 Execute: OI field,flag\n         LA    R14,1(R14)                 Increment after EX\n         AR    R7,R14                     Bump past known length\n         SR    R6,R14                     Subtract from total\n         LTR   R6,R6                      Check out length\n         BZ    PPC$END                    Zero, leave\n         BM    PPC$END                    Zero, leave\nPPC$FLDL EQU   *\n         CLI   0(R7),C' '                 Valid Delimiter?\n         BE    PPC$DLMS\n         CLI   0(R7),C','                 Valid Delimiter?\n         BE    PPC$DLMS\n         LA    R7,1(R7)                   Bump past extra byte\n         BCT   R6,PPC$FLDL                Process next one\n         B     PPC$END                    End of the Parameter string\nPPC$FX   EQU   *\n*\n** DD name prefix (TIOT)\n*\nPPC$DDP  EQU   *\n         CLC   0(7,R7),=C'PREFIX='        Overriding DD prefix?\n         BNE   PPC$DDPX                   No, continue\n         LA    R7,7(R7)                   Bump past \"PREFIX=\"\n         SH    R6,=H'7'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,PPC_DDP                 Locate output\n         LA    R14,7                      Set max\n         SLR   R15,R15                    Set count\nPPC$DDPL EQU   *\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$OERR                   Yes, continue\n         LA    R15,1(R15)                 Increment count\n         CLI   0(R7),C','                 Found delimiter?\n         BE    PPC$DDPLX                  Yes, leave\n         BCT   R6,PPC$DDPL                Process next byte\nPPC$DDPLX EQU  *\n         BCTR  R15,0                      Decrement for later\n         STC   R15,PPC_DDPL               Save count\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$DDPX EQU   *\n*\n** Date format\n*\nPPC$DF   EQU   *\n         CLC   0(5,R7),=C'DATE='          Overriding Date format?\n         BNE   PPC$DFX                    No, continue\n         MVC   PPC_DATEFV+2(2),=C'  '     Ensure trailing blanks\n         LA    R7,5(R7)                   Bump past \"DATE=\"\n         SH    R6,=H'5'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,PPC_DATEFV              Locate output\n         LA    R14,5                      Set max\n         SLR   R15,R15                    Set count\nPPC$DFL  DS    0H\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$OERR                   Yes, continue\n         LA    R15,1(R15)                 Increment count\n         CLI   0(R7),C','                 Found delimiter?\n         BE    PPC$DFLX                   Yes, leave\n         BCT   R6,PPC$DFL                 Process next byte\nPPC$DFLX DS    0H\n         BCTR  R15,0                      Decrement for later\n         OI    PPC_IFLAG1,$PPC_IF1DATESET\n         CLI   PPC_DATEFV,C'E'            Looks like \"EUR\"?\n         BE    PPC$DFSE\n         CLI   PPC_DATEFV,C'U'            Looks like \"US\"?\n         BE    PPC$DFSU\n         CLI   PPC_DATEFV,C'I'            Looks like \"ISO\"?\n         BE    PPC$DFSI                   None, they made a mistake\nPPC$DFSERR DS  0H\n         OI    PPC_IFLAG1,$PPC_IF1DATEERR\n         BCTR  R6,0                       Decrement count\n         B     PPC$OERR\nPPC$DFSI DS    0H\n         OI    PPC_IFLAG1,$PPC_IF1DATEISO\n         CLC   PPC_DATEFV(3),=C'ISO'      Looks okay?\n         BE    PPC$DFSX\n         CLC   PPC_DATEFV(3),=C'I  '      Looks okay?\n         BE    PPC$DFSX\n         B     PPC$DFSERR\nPPC$DFSE DS    0H\n         CLC   PPC_DATEFV(3),=C'EUR'      Looks okay?\n         BE    PPC$DFSX\n         CLC   PPC_DATEFV(3),=C'E  '      Looks okay?\n         BE    PPC$DFSX\n         B     PPC$DFSERR\nPPC$DFSU DS    0H\n         OI    PPC_IFLAG1,$PPC_IF1DATEUS\n         CLC   PPC_DATEFV(3),=C'US '      Looks okay?\n         BE    PPC$DFSX\n         CLC   PPC_DATEFV(3),=C'U  '      Looks okay?\n         BNE   PPC$DFSERR\nPPC$DFSX DS    0H\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$DFX  DS    0H\n*\n** FINDMEM=member\n**\n** Note: There is a logic error in here somewhere, FINDMEM=12345678\n**       fails but FINDMEM=1234567 works.  10JAN1998@DAlcock\n*\nPPC$FM   EQU   *\n         CLC   0(8,R7),=C'FINDMEM='       Finding a member?\n         BNE   PPC$FMX                    No, continue\n         LA    R7,8(R7)                   Bump past \"FINDMEM=\"\n         SH    R6,=H'8'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,PPC_FM                  Locate output\n         MVC   0(8,R1),=CL8' '            Get trailing blanks\n         LA    R14,8                      Set max\n         SLR   R15,R15                    Set count\nPPC$FML  DS    0H\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n LA    R15,1(R15)                 Increment count\n CLI   0(R7),C','                 Found delimiter?\n BE    PPC$FMLX                   Yes, leave\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$OERR                   Yes, continue\n         BCT   R6,PPC$FML                 Process next byte\nPPC$FMLX DS    0H\n         BCTR  R15,0                      Decrement for later\n****\n         LA    R14,PPC_FM                 Locate start of field\n         AR    R14,R15                    Locate last character\n         CLI   0(R14),C'*'                Generic?\n         BE    PPC$FMG                    Yes, continue\n         CLI   0(R14),C'/'                Generic?\n         BNE   PPC$FMGX                   No, continue\nPPC$FMG  DS    0H\n*-Note: Since FINDMEM=A* results in PPC_FML being zero, we can't just\n*-assume that PPC_FML=0 means that no findmem.\n         OI    PPC_IFLAG1,$PPC_IF1FMG     FINDMEM was generic\n         BCTR  R15,0                      Decrement for generic byte\nPPC$FMGX DS    0H\n****\n         STC   R15,PPC_FML                Save count\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$FMX  DS    0H\n*\n** Line count for output files\n*\nPPC$LINEC EQU  *\n         CLC   0(8,R7),=C'LINECNT='\n         BNE   PPC$LINECX                 No, continue\n         LA    R7,8(R7)                   Bump past \"LINECNT=\"\n         SH    R6,=H'8'                   Decrement for length\n         LTR   R6,R6                      Check out length\n         BZ    PPC$OERR                   Zero, leave\n         LA    R1,DOUBLE                  Locate output\n         LA    R14,8                      Set max\n         SLR   R15,R15                    Set count\nPPC$LINECL EQU *\n         MVC   0(1,R1),0(R7)              Move input byte\n         LA    R7,1(R7)                   Bump to next input byte\n         LA    R1,1(R1)                   Bump to next output byte\n         BCTR  R14,0                      Decrement max count\n         LTR   R14,R14                    Check for overflow...\n         BZ    PPC$LINECLX                Yes, continue\n         LA    R15,1(R15)                 Increment count\n         CLI   0(R7),C','                 Found delimiter?\n         BE    PPC$LINECLX                Yes, leave\n         BCT   R6,PPC$LINECL              Process next byte\nPPC$LINECLX EQU *\n         BCTR  R15,0                      Decrement for later\n         EX    R15,PPC$LINECP             Save count\n         CVB   R1,DOUBLE2                 Convert it to binary\n         STH   R1,PPC_LINECNT             Save it\n         BCTR  R6,0                       Decrement count\n         LTR   R6,R6                      Check count\n         BZ    PPC$END                    Zero, at end of parameter\n         BM    PPC$END                    Zero, at end of parameter\n         B     PPC$DLM                    Process next option\nPPC$LINECP PACK DOUBLE2(8),DOUBLE(0)\nPPC$LINECX DS  0H\n*\n** Parameter in error: isolate it, note position and continue\n*\nPPC$OERR EQU   *\n         SLR   R1,R1                      Clear out register\n         ICM   R1,B'0011',PPC_COL         Get previous parm err column\n         BNZ   PPC$GNUM                   Yes, go increment number\n         L     R1,PPC_BUFFER              Get length of buffer\n         SR    R1,R6                      Get location\n         STH   R1,PPC_COL                 Save location of error\nPPC$GNUM EQU   *\n         LH    R1,PPC_NUM                 Get number of errors in parm\n         LA    R1,1(R1)                   Increment by 1\n         STH   R1,PPC_NUM                 Save for later\nPPC$RR   EQU   *\n         CLI   0(R7),C','                 Hit a comma yet?\n         BE    PPC$BRK                    Yes, leave\n         LA    R7,1(R7)                   Bump to next byte\n         BCT   R6,PPC$RR                  Test it out\n         B     PPC$END                    End of parms...\nPPC$BRK  EQU   *\n         LA    R7,1(R7)                   Bump past comma\n         LTR   R6,R6                      Test for zero length\n         BZ    PPC$END                    Yes, end rigth now\n         BM    PPC$END                    Yes, end rigth now\n         BCT   R6,PPC$DLMX                No, let's test some more\n*\n** End of parameters found\n*\nPPC$END  EQU   *\n         CLI   PPC_OPTION,#PPC_OPTION_SYSIN  Processing SYSIN?\n         BE    PPC$SIPE                   Print errors (if any)\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Common Exit from Parse_Parameter_Card\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPPC$X    EQU   *\n         L     R15,PPC_RC                 Get return code\n         PR    ,                          Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Constants\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         LTORG ,                          Literals\n*\n** Parse flags (mapped by TPF DSECT)\n*\nT_PFLAGS DS  0H\n DC AL1($PPC_F1DATONLY),AL2(TPF_DATAONLY-PDSR$PPC,PPC_FLAG1-SUBRSA)\n DC AL1($PPC_F1NOBREAK),AL2(TPF_NOBREAK-PDSR$PPC,PPC_FLAG1-SUBRSA)\n DC AL1($PPC_F1CHKDUP),AL2(TPF_CHKDUP-PDSR$PPC,PPC_FLAG1-SUBRSA)\n DC AL1($PPC_F1CHKDUP),AL2(TPF_CHKDUP2-PDSR$PPC,PPC_FLAG1-SUBRSA)\n DC AL1($PPC_F1MEMXREF),AL2(TPF_MEMXREF-PDSR$PPC,PPC_FLAG1-SUBRSA)\n DC AL1($PPC_F1NODET),AL2(TPF_NODET-PDSR$PPC,PPC_FLAG1-SUBRSA)\n DC AL1($PPC_F1NODET),AL2(TPF_NODET2-PDSR$PPC,PPC_FLAG1-SUBRSA)\n DC AL1($PPC_F1SIMULATE),AL2(TPF_SIMULATE-PDSR$PPC,PPC_FLAG1-SUBRSA)\n*\n DC AL1($PPC_F2LNKLST),AL2(TPF_LNKLST-PDSR$PPC,PPC_FLAG2-SUBRSA)\n DC AL1($PPC_F2LPALST),AL2(TPF_LPALST-PDSR$PPC,PPC_FLAG2-SUBRSA)\n DC AL1($PPC_F2DUMPDIRE),AL2(TPF_DUMPDIRE-PDSR$PPC,PPC_FLAG2-SUBRSA)\n DC AL1($PPC_F2DUMPDIRE),AL2(TPF_DUMPDIRE2-PDSR$PPC,PPC_FLAG2-SUBRSA)\n DC AL1($PPC_F2DUMPDIRE),AL2(TPF_DUMPDIRE3-PDSR$PPC,PPC_FLAG2-SUBRSA)\n DC AL1($PPC_F2DUMPBLDL),AL2(TPF_DUMPBLDL-PDSR$PPC,PPC_FLAG2-SUBRSA)\n DC AL1($PPC_F2DUMPDSCB),AL2(TPF_DUMPDSCB-PDSR$PPC,PPC_FLAG2-SUBRSA)\n DC AL1($PPC_F2HELP),AL2(TPF_HELP-PDSR$PPC,PPC_FLAG2-SUBRSA)\n*\n DC AL1($PPC_F3LOADMOD),AL2(TPF_LOADMOD-PDSR$PPC,PPC_FLAG3-SUBRSA)\n DC AL1($PPC_F3ECRPT),AL2(TPF_ECRPT-PDSR$PPC,PPC_FLAG3-SUBRSA)\n DC AL1($PPC_F3ZAPRPT),AL2(TPF_ZAPRPT-PDSR$PPC,PPC_FLAG3-SUBRSA)\n DC AL1($PPC_F3COBCRPT),AL2(TPF_COBCRPT-PDSR$PPC,PPC_FLAG3-SUBRSA)\n*\n DC AL1($PPC_F4NTRANID),AL2(TPF_NOTRANID-PDSR$PPC,PPC_FLAG4-SUBRSA)\n DC AL1($PPC_F4TRANR),AL2(TPF_TRANRPT-PDSR$PPC,PPC_FLAG4-SUBRSA)\n DC AL1($PPC_F4HISTR),AL2(TPF_HISTRPT-PDSR$PPC,PPC_FLAG4-SUBRSA)\n DC AL1($PPC_F4NOSMS),AL2(TPF_NOSMS-PDSR$PPC,PPC_FLAG4-SUBRSA)\n DC AL1($PPC_F4ONLYF),AL2(TPF_ONLYFIND-PDSR$PPC,PPC_FLAG4-SUBRSA)\n DC AL1($PPC_F4TSOVIEW),AL2(TPF_TSOVIEW-PDSR$PPC,PPC_FLAG4-SUBRSA)\n DC AL1($PPC_F4NOSYSIN),AL2(TPF_NOSYSIN-PDSR$PPC,PPC_FLAG4-SUBRSA)\n DC AL1($PPC_F4FLATOUT),AL2(TPF_FLATOUT-PDSR$PPC,PPC_FLAG4-SUBRSA)\n*\n DC AL1($PPC_F5IVCSECTF),AL2(TPF_IVCSECTF-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5IVCSECTF),AL2(TPF_IVCSECTF2-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5IVCSECTF),AL2(TPF_IVCSECTF3-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5IVCSECTS),AL2(TPF_IVCSECTS-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5IVCSECTS),AL2(TPF_IVCSECTS2-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5IVCSECTS),AL2(TPF_IVCSECTS3-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5NIVENDOR),AL2(TPF_NIVENDOR-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5NIVENDOR),AL2(TPF_NIVENDOR2-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5NIVENDOR),AL2(TPF_NIVENDOR3-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5NVENDORL),AL2(TPF_NVENDORL-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5NVENDORL),AL2(TPF_NVENDORL2-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5NVENDORL),AL2(TPF_NVENDORL3-PDSR$PPC,PPC_FLAG5-SUBRSA)\n  DC AL1($PPC_F5NOEAGLE),AL2(TPF_NOEAGLE-PDSR$PPC,PPC_FLAG5-SUBRSA)\n     DC AL1($PPC_F5EODC),AL2(TPF_EODC-PDSR$PPC,PPC_FLAG5-SUBRSA)\n DC AL1($PPC_F5CALLRACF),AL2(TPF_CALLRACF-PDSR$PPC,PPC_FLAG5-SUBRSA)\nT_PFLAGSN EQU   (*-T_PFLAGS)/TPFL\n*\n** Parse name strings\n**\n** The longer names are intended for //SYSIN and not the parm card\n*\nTPF_DATAONLY    DA#STR 'DATAONLY'\nTPF_NOBREAK     DA#STR 'NOBREAK'\nTPF_CHKDUP      DA#STR 'CHKDUP'\nTPF_CHKDUP2     DA#STR 'CHECKDUPLICATES'\nTPF_MEMXREF     DA#STR 'MEMXREF'\nTPF_NODET       DA#STR 'NODET'\nTPF_NODET2      DA#STR 'NODETAIL'\nTPF_SIMULATE    DA#STR 'SIMULATE'\n*\nTPF_LNKLST      DA#STR 'LNKLST'\nTPF_LPALST      DA#STR 'LPALST'\nTPF_DUMPDIRE    DA#STR 'DUMPDIRE'\nTPF_DUMPDIRE2   DA#STR 'DUMPDIRECTORYENTRIES'\nTPF_DUMPDIRE3   DA#STR 'DUMP_DIRECTORY_ENTRIES'\nTPF_DUMPBLDL    DA#STR 'DUMPBLDL'\nTPF_CALLRACF    DA#STR 'CALLRACF'\nTPF_DUMPDSCB    DA#STR 'DUMPDSCB'\nTPF_HELP        DA#STR 'HELP'\n*\nTPF_LOADMOD     DA#STR 'LOADMOD'\nTPF_ECRPT       DA#STR 'ECRPT'\nTPF_ZAPRPT      DA#STR 'ZAPRPT'\nTPF_COBCRPT     DA#STR 'COBCRPT'\n*\nTPF_NOTRANID    DA#STR 'NOTRANID'\nTPF_TRANRPT     DA#STR 'TRANRPT'\nTPF_HISTRPT     DA#STR 'HISTRPT'\nTPF_NOSMS       DA#STR 'NOSMS'\nTPF_ONLYFIND    DA#STR 'ONLYFIND'\nTPF_TSOVIEW     DA#STR 'TSOVIEW'\nTPF_NOSYSIN     DA#STR 'NOSYSIN'\nTPF_FLATOUT     DA#STR 'FLATOUT'\n*\nTPF_IVCSECTF    DA#STR 'IVCSECTF'\nTPF_IVCSECTF2   DA#STR 'IGNOREVENDORCSECTFULL'\nTPF_IVCSECTF3   DA#STR 'IGNORE_VENDOR_CSECT_FULL'\nTPF_IVCSECTS    DA#STR 'IVCSECTS'\nTPF_IVCSECTS2   DA#STR 'IGNOREVENDORCSECTSTAT'\nTPF_IVCSECTS3   DA#STR 'IGNORE_VENDOR_CSECT_STAT'\nTPF_NIVENDOR    DA#STR 'NIVENDOR'\nTPF_NIVENDOR2   DA#STR 'NOINTERNALVENDOR'\nTPF_NIVENDOR3   DA#STR 'NO_INTERNAL_VENDOR'\nTPF_NVENDORL    DA#STR 'NVENDORL'\nTPF_NVENDORL2   DA#STR 'NOVENDORLIST'\nTPF_NVENDORL3   DA#STR 'NO_VENDOR_LIST'\nTPF_NOEAGLE     DA#STR 'NOEAGLE'\nTPF_EODC        DA#STR 'EODC'\n*\n         DS    0D                         End CSECT on double word\n*\n** Calculate length of module\n*\n#PDSR$PPC EQU  *-PDSR$PPC\n#PDSR$PPC_LEFT EQU 4096-#PDSR$PPC\n         DROP  R13,R12\n*\n** T_PFLAG mapping\n*\nTPF           DSECT ,\nTPF_FLAG      DS    X                     Flag value\nTPF_NAME      DS    XL2                   Offset to flag name string\nTPF_OFFSET    DS    XL2                   Offset to field in WORKDS\nTPFL          EQU   *-TPF\n         EJECT\n***********************************************************************\n***\n**  Ignore Vendor CSECT\n**\n**  Upon input:\n**  - R0...points to CSECT name\n**  - R1...points to SUBRSA (our register save area)\n***\n***********************************************************************\n SPACE 2\n*\n** Entry codes\n*\n#IVC_INIT EQU  1                       Initialization\n#IVC_TERM EQU  2                       Termination\n#IVC_PDST EQU  3                       PDS termination\n*\n** Create a standard O/S eyecatcher\n*\nPDSR$IVC CSECT ,\nPDSR$IVC AMODE 31\nPDSR$IVC RMODE ANY\nIVCEC    B     IVCECL(0,R15)           Bump past Eyecatcher\n         DC    AL1(L'IVCECT)           Length of eyecatcher\nIVCECT   DC    C'PDSR$IVC - Ignore Vendor CSECTs'\n         DS    0H                      Ensure halfword alignment\nIVCECL   EQU   *-IVCEC\n*\n** Entry housekeeping\n*\n         BAKR  R14,0                   Save registers\n         LAE   R12,0(R15,0)            Get base register\n         USING PDSR$IVC,R12            Set module base\n*\n** Locate input fields and output locations\n*\n         EREG  R0,R1                   Get CSECT, WORKDS address\n         LR    R13,R1                  Get register save area\n         USING SUBRSA,R13\n*\n** Branch to the right routine or continue with check\n*\n         C     R0,=AL4(#IVC_INIT)      Initialization?\n         BE    IVC$INIT\n         C     R0,=AL4(#IVC_TERM)      Termination?\n         BE    IVC$TERM\n         C     R0,=AL4(#IVC_PDST)      PDS termination?\n         BE    IVC$PDST\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Check for CSECT in Interal Table and //IVCSECT concatenation\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIVC$CHK  DS    0H\n         ICM   R9,B'1111',IVC_AREA+4   Locate area\n         USING IVCA,R9                 Get addressability to it\n*\n         EREG  R2,R3                   Get R2=PDSRCMD area R3=notused\n         USING PDSRCMD,R2              Addressibility\n*\n         NI    PDSRCMD_IFLAG3,255-$PDSRCMD_IF3IVC Turn off flag\n         LR    R8,R0                   Save location of CSECT name\n*\n         TM    PPC_FLAG5,$PPC_F5NIVENDOR Don't use vendor table?\n         BO    IVC$CACHE               Yes, skip using it\n*\n** Loop through internal table looking for Vendor CSECT matchs\n*\n         LA    R1,IVCA_VENDOR          Locate to Table\n         LA    R0,T_VENDORN            Number in table\nIVC$VL   DS    0H\n         LH    R14,TVP_PREFL-TVP(R1) Get length\n         EX    R14,IVC$VLC             Match?\n         BE    IVC$VF                  Yes, continue...\n         LA    R1,TVP_DL(R1)           No, bump to next one\n         BCT   R0,IVC$VL                   and try it out\n         B     IVC$CACHE               No match in internal table\nIVC$VLC  CLC   TVP_PREFIX-TVP(0,R1),0(R8)\nIVC$VF   DS    0H\n         L     R15,TVP_CNTLIB-TVP(R1)  Get count for this library\n         LA    R15,1(R15)              Increment by 1\n         ST    R15,TVP_CNTLIB-TVP(R1)  Save count for this library\n*\n** If the user wants a list of CSECTs identified as for vendors, put\n** them in a nice little table\n**\n** I've borrowed the code from my IVCC table and will use the same\n** CSECT to map the area to contain the list\n*\n*\n         TM    PPC_FLAG5,$PPC_F5NVENDORL List vendor csects matched?\n         BO    IVC$FND                 No, continue\n         TM    IVCA_FLAG1,$IVCA_F1MAXC Hit max for table?\n         BO    IVC$FND                 Yes, can't add anymore\n         DA#SMODE 31                   Get into 31 bit mode\n         ICM   R14,B'1111',IVCA_VENDORMT+4 Locate table\n         BNZ   IVC$VM                  Have it, ready to search\n         L     R0,=AL4(#IVCC)          Get length of area\n         GETMAIN RU,LV=(0),LOC=(ANY,ANY) Obtain storage\n         STM   R0,R1,IVCA_VENDORMT     Save length and address\n         MVC   IVCC_HID-IVCC(4,R1),=CL4'IVCV'\n         LR    R14,R1                  Save address of IVCC\n         SH    R0,=H'17'               Length - 17 is last possible\n         LR    R15,R14                 Get start of area\n         AR    R15,R0                  Locate last possible entry\n         ST    R15,IVCC_HLAST-IVCC(R14) Save it for later\n         MVI   8(R15),X'FF'            Just in case\n         MVC   9(7,R15),=CL7'IVCVEND'  Debugging for dumps\n         LA    R1,IVCC_HL(R1)          Locate past header\n         B     IVC$VAD\nIVC$VM   DS    0H\n         LA    R1,IVCC_HL(R14)         Bump past header\nIVC$VBCL DS    0H\n         CLC   0(8,R1),0(R8)           Match?\n         BE    IVC$VX                  Yes, continue\n         LA    R1,8(R1)                No, skip to next entry\n         CLI   0(R1),X'FF'             End yet?\n         BNE   IVC$VBCL                No, try it out\nIVC$VAP  DS    0H\n         L     R1,IVCC_HPREV-IVCC(R14) Locate previous entry\n         LA    R1,8(R1)                Locate next slot\n         C     R1,IVCC_HLAST-IVCC(R14) In range?\n         BL    IVC$VAD\n         OI    IVCA_FLAG1,$IVCA_F1MAXV Set max flag\n         B     IVC$FND                 Leave\nIVC$VAD  DS    0H\n         MVC   0(8,R1),0(R8)           Insert new entry\n         MVI   8(R1),X'FF'             Mark end of table\n         ST    R1,IVCC_HPREV-IVCC(R14) Save entry\nIVC$VX   DS    0H\n         DA#SMODE 24                   Get back to 24 bit mode\n         B     IVC$FND\n*\n** See if this member has already been found and lurking in the cache\n*\nIVC$CACHE DS  0H\n         DA#SMODE 31                   Set addressing mode to 31\n         ICM   R1,B'1111',IVCA_CACHE+4 Locate Cache\n         BZ    IVC$CHX                 Not created yet...\n         LA    R1,IVCC_HL(R1)          Bump past header\nIVC$CHL  DS    0H\n         CLC   0(8,R1),0(R8)           Match?\n         BE    IVC$FNDM                Yes, continue\n         LA    R1,8(R1)                No, skip to next entry\n         CLI   0(R1),X'FF'             End yet?\n         BNE   IVC$CHL                 No, try it out\nIVC$CHX  DS    0H\n         DA#SMODE 24                   Set addressing mode to 24\n*\n** Perform BLDL for the member against //IVCSECT\n*\n         XC    IVCA_PDS(IVCA_PDSL),IVCA_PDS Clear to zeros\n         MVC   IVCA_PDS_FF(2),=AL2(1)  Number of members found\n         MVC   IVCA_PDS_LL(2),=AL2(IVCA_PDS_ENTRYL) Move in entry len\n         MVC   IVCA_PDS_ENTRY+(PDS2NAME-PDS2)(8),0(R8)\n         LA    R3,IVCA_PODCB           Locate DCB\n         BLDL  (3),IVCA_PDS            Perform BLDL\n         LTR   R15,R15                 Check out BLDL\n         BNZ   IVC$X                   CSECT not in //IVCSECT\n         L     R1,IVCA_CNTABLDL        Get it\n         LA    R1,1(R1)                Increment it\n         ST    R1,IVCA_CNTABLDL        Save it\n         L     R1,IVCA_CNTLBLDL        Get it\n         LA    R1,1(R1)                Increment it\n         ST    R1,IVCA_CNTLBLDL        Save it\n*\n** Found a new member, add to cache\n*\n         TM    IVCA_FLAG1,$IVCA_F1MAXC Hit max for table?\n         BO    IVC$FND                 Yes, can't add anymore\n         DA#SMODE 31                   Get into 31 bit mode\n         ICM   R14,B'1111',IVCA_CACHE+4 Locate Cache\n         BNZ   IVC$CAP                 Have it, ready to append nu 1\n#IVCC    EQU   IVCC_HL+(32768*8)       Header + Entries\n         L     R0,=AL4(#IVCC)          Get length of area\n         GETMAIN RU,LV=(0),LOC=(ANY,ANY) Obtain storage\n         STM   R0,R1,IVCA_CACHE        Save length and address\n         MVC   IVCC_HID-IVCC(4,R1),=CL4'IVCC'\n         LR    R14,R1                  Save address of IVCC\n         SH    R0,=H'17'               Length - 17 is last possible\n         LR    R15,R14                 Get start of area\n         AR    R15,R0                  Locate last possible entry\n         ST    R15,IVCC_HLAST-IVCC(R14) Save it for later\n         MVI   8(R15),X'FF'            Just in case\n         MVC   9(7,R15),=CL7'IVCCEND'  Debugging for dumps\n         LA    R1,IVCC_HL(R1)          Locate past header\n         B     IVC$CAD\nIVC$CAP  DS    0H\n         L     R1,IVCC_HPREV-IVCC(R14) Locate previous entry\n         LA    R1,8(R1)                Locate next slot\n         C     R1,IVCC_HLAST-IVCC(R14) In range?\n         BL    IVC$CAD\n         OI    IVCA_FLAG1,$IVCA_F1MAXC Set max flag\n         B     IVC$FND                 Leave\nIVC$CAD  DS    0H\n         MVC   0(8,R1),0(R8)           Insert new entry\n         MVI   8(R1),X'FF'             Mark new end-of-table\n         ST    R1,IVCC_HPREV-IVCC(R14) Save entry location\n         B     IVC$FND                 Continue\n*\n** Found: Match on vendor CSECT in Cache\n*\nIVC$FNDM DS    0H\n         L     R1,IVCA_CNTACM          Get it\n         LA    R1,1(R1)                Increment it\n         ST    R1,IVCA_CNTACM          Save it\n*\n         L     R1,IVCA_CNTLCM          Get it\n         LA    R1,1(R1)                Increment it\n         ST    R1,IVCA_CNTLCM          Save it\n         DA#SMODE 24                   Ensure we are back to 24\n*\n** Found: follow up code\n*\nIVC$FND  DS    0H\n         OI    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Turn on flag\n         B     IVC$X\n         DROP  R2                      PDSRCMD work area\n         DROP  R9                      IVCA area\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** PDS (library) termination\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIVC$PDST DS    0H\n         ICM   R9,B'1111',IVC_AREA+4   Locate area\n         USING IVCA,R9                 Get addressability to it\n*\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG110L,R15),MSG110-PDSR$MSG(R1) Move in message\n         BAS   R14,IVC$PSR             Print the record\n*\n         ICM   R0,B'1111',IVCA_CNTLBLDL\n         BZ    IVCA$PTM2BX\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG112L,R15),MSG112-PDSR$MSG(R1) Move in message\n         MVC   MSG112L+1(22,R15),=CL22'BLDL matchs:'\n         LA    R15,MSG112L+1+23(R15)   Bump past message\n         L     R1,IVCA_CNTLBLDL        Get count\n         BAS   R14,IVC_EDITFWF         Edit it\n         BAS   R14,IVC$PSR             Print the message\n         XC    IVCA_CNTLBLDL(4),IVCA_CNTLBLDL\nIVCA$PTM2BX DS 0H\n*\n         ICM   R0,B'1111',IVCA_CNTLCM\n         BZ    IVCA$PTM2CX\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG112L,R15),MSG112-PDSR$MSG(R1) Move in message\n         MVC   MSG102L+1(22,R15),=CL22'BLDL cache matchs:'\n         LA    R15,MSG112L+1+23(R15)   Bump past message\n         L     R1,IVCA_CNTLCM          Get count\n         BAS   R14,IVC_EDITFWF         Edit it\n         BAS   R14,IVC$PSR             Print the message\n         XC    IVCA_CNTLCM(4),IVCA_CNTLCM\nIVCA$PTM2CX DS 0H\n*\n** Print totals for this library (if any found)\n*\n         LA    R4,IVCA_VENDOR          Locate dynamic vendor table\n         LA    R5,T_VENDORN            Number in table\n         MVI   IVCA_PDS,0              Flag area\n         SLR   R8,R8                   Clear total count\nIVC$PTVL DS    0H\n         ICM   R6,B'1111',TVP_CNTLIB-TVP(R4)\n         BZ    IVC$PTVB\n         XC    TVP_CNTLIB-TVP(L'TVP_CNTLIB,R4),TVP_CNTLIB-TVP(R4)\n         L     R1,TVP_CNTALL-TVP(R4)   Get total library count\n         AR    R1,R6                   Add for this library\n         ST    R1,TVP_CNTALL-TVP(R4)   Save new total\n         AR    R8,R6                   Update total for this library\n*\n         BAS   R14,IVC$PTVP            Print title message\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG114L,R15),MSG114-PDSR$MSG(R1) Move in message\n         MVC   MSG114M-MSG114(L'TVP_PREFIX,R15),TVP_PREFIX-TVP(R4)\n         L     R14,TVP_DADDR-TVP(R4)   Get address of description str\n         SLR   R1,R1\n         IC    R1,0(R14)               Get length of string\n         EX    R1,IVC$PTVM             Move desc string out\n         LA    R15,MSG114L(R15)        Locate past message\n         CVD   R6,DOUBLE\n         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'\n         ED    0(12,R15),DOUBLE+3\n         BAS   R14,IVC$PSR             Print the record\nIVC$PTVB DS    0H\n         LA    R4,TVP_DL(R4)           Locate to next output entry\n         BCT   R5,IVC$PTVL             Try out next entry\n         LTR   R8,R8                   Check out total\n         BZ    IVC$PT0\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG115L,R15),MSG115-PDSR$MSG(R1) Move in message\n         LA    R15,MSG114SL(R15)       Locate to end of \" >\"\n         MVI   0(R15),C'-'             Get line\n         MVC   1(MSG114E-MSG114C+12-1,R15),0(R15)\n         BAS   R14,IVC$PSR             Print the record\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG115L,R15),MSG115-PDSR$MSG(R1) Move in message\n         MVC   MSG114SL(18,R15),=C'Total for library:'\n         LA    R15,MSG114L(R15)        Locate to end of message\n         CVD   R8,DOUBLE\n         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'\n         ED    0(12,R15),DOUBLE+3\n         BAS   R14,IVC$PSR             Print the record\n         BAS   R14,IVC$CLEAR_RECOUT    Clear output record\n         BAS   R14,IVC$PSR             Print the record\n         B     IVC$X\nIVC$PT0  DS    0H\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG111L,R15),MSG111-PDSR$MSG(R1) Move in message\n         BAS   R14,IVC$PSR             Print the record\n         B     IVC$X\nIVC$PTVM MVC   MSG114T-MSG114(0,R15),1(R14)\n*\n** Print title line first time\n*\nIVC$PTVP DS    0H\n         TM    IVCA_PDS,X'80'          Printed title line yet?\n         BO    IVC$PTVPX               Yes, leave\n         OI    IVCA_PDS,X'80'          Printed title line yet?\n         ST    R14,IVCA_PDS+4          Save return address\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG113L,R15),MSG113-PDSR$MSG(R1) Move in message\n         BAS   R14,IVC$PSR             Print the record\n         L     R14,IVCA_PDS+4          Get return address\nIVC$PTVPX DS   0H\n         BSM   0,R14\n         DROP  R9                      IVCA area\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Initialization\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIVC$INIT DS    0H\n*\n** Allocate storage area for PDSR$IVC use\n*\n         LA    R0,IVCAL\n         GETMAIN RU,LV=(0)             Obtain storage\n         STM   R0,R1,IVC_AREA          Save length and address\n         LR    R9,R1\n         USING IVCA,R9\n         MVC   IVCA_ID(4),=CL4'IVCA'   Set ID for dumps\n         MVC   IVCA_PODCBI(4),=CL4'DCB' Set for dumps\n         MVC   IVCA_VENDORI(8),=CL8'VENDOR' set for dumps\n         MVC   IVCA_END(4),=CL4'END'   Set for dumps\n         XC    IVCA_INIT(IVCA_INITL),IVCA_INIT  Init to zeros\n*\n** Move the static vendor table to our dynamic storage.  We will then\n** convert the offsets of the description strings to addresses and\n** init the count areas to zero\n*\n         L     R1,=V(PDSR$TRT)         Locate to Table CSECT\n         LA    R1,T_VENDOR-PDSR$TRT(R1) Locate to static vendor table\n         LA    R15,IVCA_VENDOR         Locate dynamic vendor table\n         LA    R0,T_VENDORN            Number in table\nIVC$IVL  DS    0H\n         MVC   0(TVP_IEL,R15),0(R1)    Move in entry\n         LH    R14,TVP_OFF-TVP(R1)     Get offset of desc string\n         A     R14,IVC_TRT             Locate it\n         ST    R14,TVP_DADDR-TVP(R15)  Save address\n         XC    TVP_I-TVP(TVP_IL,R15),TVP_I-TVP(R15)\n         LA    R1,TVP_SL(R1)           Locate to next input entry\n         LA    R15,TVP_DL(R15)         Locate to next output entry\n         BCT   R0,IVC$IVL              Try out next entry\n*\n** If user has DD=IVCSECT allocated, print message and continue\n*\n         DEVTYPE =CL8'IVCSECT',DOUBLE  Check //IVCSECT allocation\n         LTR   R15,R15                 Allocated?\n         BZ    IVC$IDD                 Yes, continue\n*-Check for Parm=IVCSECTx, No-DD-Allocated and PARM=NIVENDOR and gripe\n         TM    PPC_FLAG5,$PPC_F5NIVENDOR Option specified?\n         BNO   IVC$X                   No, looks good\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG65L,R15),MSG65-PDSR$MSG(R1) Move in message\n         BAS   R14,IVC$PSR             Print the record\n         OI    IVCA_FLAG1,$IVCA_F1CONP Conflicting parms\n         B     IVC$X\n*\nIVC$IDD  DS    0H\n         OI    IVCA_FLAG1,$IVCA_F1FILE Say we have a file\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG64L,R15),MSG64-PDSR$MSG(R1) Move in message\n         BAS   R14,IVC$PSR             Print the record\n*\n** Open the DCB to be used to check for vendor modules\n*\n         L     R1,=V(PDSR$C1)          Locate Constants CSECT\n         LA    R3,IVCA_PODCB           Locate DCB\n         MVC   0(C_DCBPOL,R3),C_DCBPO-PDSR$C1(R1) Get DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'IVCSECT' Update DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI-PDSR$C1(R1) Init parm list\n         OPEN  ((3),(INPUT)),          Open the directory              @\n               MF=(E,PARMLIST)         ..Parameter List\n         B     IVC$X\n         DROP  R9\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Termination: Close file and free resources\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIVC$TERM DS    0H\n         ICM   R9,B'1111',IVC_AREA+4   Locate area\n         USING IVCA,R9\n*\n** Trivia about IVCSECT processing\n*\n         TM    IVCA_FLAG1,$IVCA_F1CONP Conflicting parms?\n         BO    IVC$TTX                 Yes, leave\n         BAS   R14,IVC$CLEAR_RECOUT    Blank out record\n         BAS   R14,IVC$PSR             Print the record\n*\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG100L,R15),MSG100-PDSR$MSG(R1) Move in message\n         BAS   R14,IVC$PSR             Print the record\n*\n*\n         TM    IVCA_FLAG1,$IVCA_F1FILE Have a //IVCSECT DD?\n         BNO   IVC$TTFX                No, continue\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG102L,R15),MSG102-PDSR$MSG(R1) Move in message\n         MVC   MSG102L+1(22,R15),=CL22'BLDL matchs:'\n         LA    R15,MSG102L+1+23(R15)   Bump past message\n         L     R1,IVCA_CNTABLDL        Get count\n         BAS   R14,IVC_EDITFWF         Edit it\n         BAS   R14,IVC$PSR             Print the message\n*\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG102L,R15),MSG102-PDSR$MSG(R1) Move in message\n         MVC   MSG102L+1(22,R15),=CL22'BLDL cache matchs:'\n         LA    R15,MSG102L+1+23(R15)   Bump past message\n         L     R1,IVCA_CNTACM          Get count\n         BAS   R14,IVC_EDITFWF         Edit it\n         BAS   R14,IVC$PSR             Print the message\nIVC$TTFX DS    0H\n         TM    PPC_FLAG5,$PPC_F5NIVENDOR Don't use vendor table?\n         BO    IVC$TTVX                Yes, skip reporting about it\nIVC$TTVX DS    0H\nIVC$TTX  DS    0H\n*\n** Print warning messages about cache and Vendor_Match_Table overflow\n*\n         TM    IVCA_FLAG1,$IVCA_F1MAXC Maxed out on Cache table?\n         BNO   IVC$TMCX                Yes, leave\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG118L,R15),MSG118-PDSR$MSG(R1) Move in message\n         MVC   MSG118L+1(5,R15),=C'Cache'\n         BAS   R14,IVC$PSR             Print the record\nIVC$TMCX DS    0H\n*\n         TM    IVCA_FLAG1,$IVCA_F1MAXV Maxed out on Cache table?\n         BNO   IVC$TMVX                Yes, leave\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG118L,R15),MSG118-PDSR$MSG(R1) Move in message\n         MVC   MSG118L+1(6,R15),=C'Vendor'\n         BAS   R14,IVC$PSR             Print the record\nIVC$TMVX DS    0H\n*\n** List out the Vendor match tables if requested\n*\n         TM    PPC_FLAG5,$PPC_F5NVENDORL List vendor csects matched?\n         BO    IVC$TVLX                No, continue\n         L     R2,IVCA_CACHE+4         Get length and address\n         LA    R3,IVC_C_CACHE\n         BAS   R4,IVC$TLIST            List out contents\n         L     R2,IVCA_VENDORMT+4      Get length and address\n         LA    R3,IVC_C_VENDOR\n         BAS   R4,IVC$TLIST            List out contents\nIVC$TVLX DS    0H\n*\n** Close the //IVCSECT file\n*\n         TM    IVCA_FLAG1,$IVCA_F1FILE File was open?\n         BNO   IVC$TCFX                No, continue\n         LA    R3,IVCA_PODCB           Locate the DCB\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is file open?\n         BNO   IVC$TCFX                No, continue\n         L     R1,=V(PDSR$C1)          locate constants CSECT\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE-PDSR$C1(R1) Get CLOSE parms\n         CLOSE ((3)),MF=(E,PARMLIST)   Close the file\nIVC$TCFX DS    0H\n*\n** Free IVCC area storage\n*\n         LM    R0,R1,IVCA_CACHE        Get area length and address\n         LTR   R0,R0                   Check out length\n         BZ    IVC$TFCX                None?\n         FREEMAIN RU,LV=(0),A=(1)      Release storage\nIVC$TFCX DS    0H\n*\n** Free IVCV area storage\n*\n         LM    R0,R1,IVCA_VENDORMT     Get area length and address\n         LTR   R0,R0                   Check out length\n         BZ    IVC$TFVX                None?\n         FREEMAIN RU,LV=(0),A=(1)      Release storage\nIVC$TFVX DS    0H\n*\n** Free IVCA area storage\n*\n         DROP  R9\n         LM    R0,R1,IVC_AREA          Get area length and address\n         FREEMAIN R,LV=(0),A=(1)       Release storage\n         B     IVC$X                   Leave\n*\n** List the contents of the cache and Vendor_Module_Table areas\n**\n** Input: R2 has the address of the table to print\n**        R3 has a DA#STR string to append to message 119\n*\nIVC$TLIST DS   0H\n         LTR   R2,R2\n         BZ    IVC$TLX\n         BAS   R14,IVC$CLEAR_RECOUT    Blank out record\n         BAS   R14,IVC$PSR             Print the record\n*\n         BAS   R14,IVC$FORMAT_MESSAGE  Initialize the message area\n         MVC   0(MSG119L,R15),MSG119-PDSR$MSG(R1) Move in message\n         LA    R15,MSG119L+1(R15)      Bump past text\n         SLR   R14,R14                 Clear register\n         IC    R14,0(R3)               Get length of string\n         EX    R14,IVC$TMS             Append string to message\n         BAS   R14,IVC$PSR             Print the record\n*\n         DA#SMODE 31\n         LA    R2,IVCC_HL(R2)          Locate to first entry\n         DA#SMODE 24\nIVC$TLLS DS    0H\n         LA    R5,RECOUT+76            Locate right border\n         BAS   R14,IVC$CLEAR_RECOUT    Blank out record\n         LA    R15,RECOUT+14           Locate left border\n         DA#SMODE 31\nIVC$TLL  DS    0H\n         MVC   0(8,R15),0(R2)          Move out csect to output line\n         LA    R15,9(R15)              Bump to next output location\n         LA    R2,8(R2)                Bump to next input location\n         CLI   0(R2),X'FF'             End of the table?\n         BE    IVC$TLLX                Yes, print last record\n         CR    R15,R5                  Still in bounds?\n         BNH   IVC$TLL                 Yes, get next csect\n         DA#SMODE 24\n         BAS   R14,IVC$PSR             No, print full output line\n         B     IVC$TLLS                    and then re-init for line\nIVC$TLLX DS    0H\n         DA#SMODE 24\n         CLI   RECOUT+14,C' '          Anything on last line?\n         BE    IVC$TLX                 No, skip print of extra one\n         BAS   R14,IVC$PSR             Print the record\nIVC$TLX  DS    0H\n         BSM   0,R4                    Return to caller\nIVC$TMS  MVC   0(0,R15),1(R3)\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Misc internal subroutines\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n*\n** Print SYSPRINT Record\n*\nIVC$PSR  DS    0H\n         ST    R14,PSR_RA                 Save return address\n         LA    R0,PSRAREA                 Locate work area\n         LA    R1,RECOUT                  Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n         L     R14,PSR_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Clear output record to blanks\n*\nIVC$CLEAR_RECOUT   DS 0H\n         LA    R15,RECOUT                 Locate output record\n         MVI   0(R15),C' '                Get Blank\n         MVC   1(L'RECOUT-1,R15),0(R15)   ..Propagate it\n         BSM   0,R14                      Return to caller\n*\n** Initialize message\n**\n** Output: R1 has PDSR$MSG\n*\nIVC$FORMAT_MESSAGE DS 0H\n         LA    R15,RECOUT\n         MVI   0(R15),C' '\n         MVC   1(L'RECOUT-1,R15),0(R15)\n         LA    R15,1(R15)\n         L     R1,=V(DA$PDSR)             -> main CSECT\n         MVC   0(7,R15),5(R1)             Move in \"DA$PDSR\"\n         MVI   7(R15),C'-'                Insert dash\n         LA    R15,MSGPREL(R15)           Bump past \"DA$PDSR-\"\n         L     R1,=V(PDSR$MSG)            -> PDSR$MSG CSECT\n         BSM   0,R14\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nIVC_EDITFWF DS 0H\n         LTR   R1,R1                      Check for 0\n         BZ    IVC_EDITFWF0               Yes, put zero\n         ST    R14,PARMLIST               Save return address\n         CVD   R1,DOUBLE                  No, convert to packec\n         LA    R1,DOUBLE2+14              Locate sig digit\n         MVC   DOUBLE2(15),IVC_EDITP15\n         EDMK  DOUBLE2(15),DOUBLE+2 EDIT AND SAVE                 PLACE\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for ex\n         EX    R14,IVC_EDITFWFM           Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '\n         L     R14,PARMLIST\n         BSM   0,R14                      Return to caller\nIVC_EDITFWFM MVC 0(0,R15),0(R1)\nIVC_EDITP15  DC  X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nIVC_EDITFWF0 DS     0H\n         MVI   0(R15),C'0'                Put in zero\n         LA    R15,1(R15)                 Bump pointer past zero\n         BSM   0,R14                      Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Exit from PDSR$IVC (Ignore Vendor CSECT)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nIVC$X    DS    0H\n         SLR   R15,R15\n         PR    ,                        Return to caller\n*\n** Local constants\n*\nIVC_C_CACHE  DA#STR 'BLDL against //IVCSECT:'\nIVC_C_VENDOR DA#STR 'Internal Vendor Table:'\n         DS    0F\nIVC_TRT  DC    V(PDSR$TRT)\n         LTORG ,\n         DROP  R12,R13\n         DS    0D\n#PDSR$IVC EQU  *-PDSR$IVC\n#PDSR$IVC_LEFT EQU 4096-#PDSR$IVC\n*\n** Map our area\n*\nIVCA           DSECT ,                     PDSR$IVC area\nIVCA_ID        DS    CL4'IVCA'             ..ID for dumps\nIVCA_INIT      EQU   *\nIVCA_CACHE     DS    2F                    ..Cache of BLDL hits\nIVCA_VENDORMT  DS    2F                    ..Vendor Table match list\nIVCA_CNTABLDL  DS    F                     ..BLDLs (all)\nIVCA_CNTACM    DS    F                     ..Cache Matchs (all)\nIVCA_CNTLBLDL  DS    F                     ..BLDLs (library)\nIVCA_CNTLCM    DS    F                     ..Cache Matchs (library)\nIVCA_FLAG1     DS    B'00000000'           ..Flag 1\n$IVCA_F1MAXC   EQU   B'10000000'             ..Maxout in Cache\n$IVCA_F1MAXV   EQU   B'01000000'             ..Maxout in Vendor list\n$IVCA_F1FILE   EQU   B'00100000'             ..Opened the PO DCB\n$IVCA_F1CONP   EQU   B'00010000'             ..Conflicting parms\nIVCA_INITL     EQU   *-IVCA_INIT           ..Length of to init to 0\nIVCA_PDS       DS    0F                    ..BLDL area\nIVCA_PDS_FF    DS    X'00,00'                ..Total number of entries\nIVCA_PDS_LL    DS    X'00,00'                ..Length of the area\nIVCA_PDS_ENTRY DS    XL(#IVCAENT)            ..Length of a pds entry\n#IVCAENT       EQU   PDS2USRD-PDS2           ..-> Length of an entry\nIVCA_PDS_USERD DS    CL62                    ..User data\nIVCA_PDS_ENTRYL EQU  *-IVCA_PDS_ENTRY        ..Length of PDS entry\nIVCA_PDSL      EQU   *-IVCA_PDS              ..Length of PDS area\n*\nIVCA_PODCBI    DS    CL4'DCB'              ..ID for dumps\nIVCA_PODCB     DS    XL(C_DCBPOL)          ..BLDL DCB\n*\n#IVCA_VENDORL  EQU   T_VENDORN*TVP_DL      ..Length of vendor area\nIVCA_VENDORI   DS    CL8'VENDOR'           ..ID for dumps\nIVCA_VENDOR    DS    XL(#IVCA_VENDORL)     ..Table of vendor prefixes\nIVCA_END       DS    CL4'END'              ..ID for dumps\n               DS    0D\nIVCAL          EQU   *-IVCA\n*\n** Cache/Vendor_Match_Table Control Block\n*\nIVCC           DSECT ,                     PDSR$IVC cache area\nIVCC_HID       DS    CL4'IVCC'             ..ID for dumps\nIVCC_HPREV     DS    F                     ..Previous entry\nIVCC_HLAST     DS    F                     ..Last possible entry\nIVCC_HL        EQU   *-IVCC                ..Length of header\nIVCC_ENTRY     DS    CL8                   Module entries\n         EJECT\n***********************************************************************\n***\n**  Module Eyecatcher routine\n**\n**  This routine is invoked after a successful load of a member\n**  or for the text of each CSECT if using the Binder API.\n**\n**  The eyecatcher of the module is examined to see if it is a\n**  \"OS Standard\" eyecatcher (see the IBM SAVE macro for format).\n**\n**  Upon input:\n**  - R0...points to CSECT name\n**  - R1...points to SUBRSA (our register save area)\n**  - R2...points to PDS2 area\n**  - R3...points to output line\n**  - R8...has module length\n**  - R9...has module start\n***\n***********************************************************************\n         SPACE 2\nPDSR$EC  CSECT ,\nPDSR$EC  AMODE 31\nPDSR$EC  RMODE ANY\n*\n** Create a standard O/S eyecatcher\n*\nECEC     B     ECECL(0,R15)             Bump past Eyecatcher\n         DC    AL1(L'ECECT)             Length of eyecatcher\nECECT    DC    C'PDSR$EC  - Eyecatcher formatter'\n         DS    0H                       Ensure halfword alignment\nECECL    EQU   *-ECEC\n*\n** Entry housekeeping\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         USING PDSR$EC,R12              Set module base\n*\n** Locate input fields and output locations\n*\n         EREG  R2,R3                    Get PDS, Output\n         EREG  R8,R9                    Get Module length, address\n         EREG  R0,R1                    Get CSECT, WORKDS address\n         LR    R13,R1                    Get register save area\n         USING SUBRSA,R13\n*\n** Format start of line\n*\n         MVI   0(R3),C' '               Get blank\n         MVC   1(132,R3),0(R3)          Propagate it\n*\n         MVC   ECR_MEMBER-ECR(8,R3),PDS2NAME-PDS2(R2)\n*-Indicate whether this is an alias\n         TM    PDS2INDC-PDS2(R2),PDS2ALIS Alias?\n         BNO   EC$AX\n         MVC   ECR_ALIAS-ECR(2,R3),=C'-A'\nEC$AX    DS    0H\n*-Get the CSECT name (if any)\n         LTR   R0,R0                      Passed to us?\n         BZ    EC$CSECT0                  No, load of primary CSECT...\n         LR    R14,R0\n         MVC   ECR_CSECT-ECR(8,R3),0(R14)\n         B     EC$CSECTX\nEC$CSECT0 DS   0H\n         MVC   ECR_CSECT-ECR(8,R3),=CL8'<<main>>' main\nEC$CSECTX DS   0H\n*-Print the length of the module\n         ST    R8,DOUBLE\n         UNPK  ECR_LENGTH-ECR(9,R3),DOUBLE(5)\n         MVZ   ECR_LENGTH-ECR(8,R3),=8X'00'\n         TR    ECR_LENGTH-ECR(8,R3),=C'0123456789abcdef'\n         MVI   ECR_LENGTH+8-ECR(R3),C' '\n*\n** Now, tackle the module's eyecatcher, if any\n*\n         DA#SMODE 31                      Module may be over the line\n AGO .JES3ECX - - - - -- - - - - - - - - - - - - - - - - - - - - - - -\n         LA    R15,ECR_EC-ECR(R3)\nEC$J3L EQU *                              JES3 or regular literal type\n         CH    R8,=AL2(4+8)               Module long enough for CLC?\n         BL    EC$OS                      No, avoid S0C4\n         CLC   4(8,R9),PDS2NAME-PDS2(R2)  JES3/Literal type w/Module?\n         BNE   EC$OS                      No, try O/S standard\n         LA    R0,128                     Max length to consider\n         LA    R9,4(R9)                   Bump to start of literal\nEC$J3LL EQU *\n         MVC   0(1,R15),0(R9)             Move byte in\n         LA    R15,1(R15)                 Bump to next output byte\n         LA    R9,1(R9)                   Bump to next input byte\n         CLI   0(R9),C' '                 Valid character?\n         BL    LE$CP                      No, must be in code...\n         BCT   R0,EC$J3LL                 Process next byte\n         MVI   0(R15),C'<'                Indicate truncated\n         B     LE$CP\nEC$OS EQU *                               Standard O/S EyeCatcher\n.JES3ECX ANOP  , - - - - - - - - - - - - - - - - - - - - - - - - - -\n*-Here we look for a standard O/S eyecatcher\n*-Well sometimes, there is a branch at the beginning without a VALID\n*-length byte like a \"standard O/S eyecatcher\" should have.\n         CLC   0(2,R9),=X'47F0F0'         Branch, R15?\n         BNE   LE$CP                      No, print what we have\n         L     R1,PPD_NUMEC               Get current number\n         LA    R1,1(R1)                   Increment by 1\n         ST    R1,PPD_NUMEC               Save new number\n         SLR   R1,R1                      Clear register\n         IC    R1,4(R9)                   Get length of literal\n         LR    R14,R8                     Get module length\n         SH    R14,=H'5'                  Subtract for header\n         CR    R1,R14                     In length?\n         BNH   LE$CB                      Yes, continue\n         LR    R1,R14                     No, use shorter module length\nLE$CB    DS    0H\n#MAXECL  EQU   133-(ECR_EC-ECR)           Max Eyecatcher - other stuff\n         CH    R1,=AL2(#MAXECL)           In range?\n         BNH   LE$CC                      No, continue\n         LA    R1,#MAXECL                 Set new max\nLE$CC    DS    0H\n         BCTR  R1,0                       Decrement for EX\n         LTR   R1,R1                      Check out the length\n         BM    LE$CP                      Doesn't look good\n         EX    R1,LE$CM                   Move eyecatcher out\nLE$CP    DS    0H\n#ECT     EQU   132-(ECR_EC-ECR)           Max length of eyecatcher\n         L     R1,=V(PDSR$C2)             Locate constants CSECT\n         TR    ECR_EC-ECR(#ECT,R3),C_TRTABA-PDSR$C2(R1)\n*\n** Exit\n*\nEC$X     DS    0H\n         DA#SMODE 24                    Get into 24 bit addr mode\n         PR    ,                        Return to caller\n*\n** Local constants\n*\n         DS    0H\nLE$CM    MVC   ECR_EC-ECR(0,R3),5(R9)\n         LTORG ,\n         DROP  R12,R13\n*\n** Map the EyeCatcher report line\n*\nECR        DSECT ,\n           DS    C\nECR_MEMBER DS    CL8\nECR_ALIAS  DS    C'-A'\n           DS    C\nECR_CSECT  DS    CL8\n           DS    C\nECR_LENGTH DS    CL8' '\n           DS    C\nECR_EC     EQU   *\n         EJECT\n***********************************************************************\n***\n**  COBOL CICS report routine\n**\n**  This routine is invoked after a successful load of a member.\n**  The eyecatcher of the module is examined to see if it is a\n**  COBOL program and what options it was compiled with that would\n**  impact CICS.\n**\n**  The COBOL II manual says that CICS COBOL programs should be\n**  compiled with these options:  RES, RENT, NODYNAM, and LIB\n**\n**  Upon input:\n**  - R2...points to PDS directory entry\n**  - R3...points to output line\n**  - R8...has module length\n**  - R9...has module start\n***\n***********************************************************************\n         SPACE 2\nPDSR$COC CSECT ,\nPDSR$COC AMODE 24\nPDSR$COC RMODE 24\n*\n** Create a standard O/S eyecatcher\n*\nCOBCEC   B     COBCECL(0,R15)           Bump past Eyecatcher\n         DC    AL1(L'COBCECT)           Length of eyecatcher\nCOBCECT  DC    C'PDSR$COC - COBOL CICS verification'\n         DS    0H                       Ensure halfword alignment\nCOBCECL  EQU   *-COBCEC\n*\n** Entry housekeeping\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         USING PDSR$COC,R12             Set module base\n*\n** Locate input fields and output locations\n*\n         EREG  R2,R3                    Get PDS, Output\n         EREG  R8,R9                    Get Module length, address\n         LA    R7,COBCR_INFO-COBCR(R3)  Locate to information output\n*\n** Determine if the type of program is COBOL/370 or VS COBOL II\n*\n         DA#SMODE 31                    Get into 31 bit addr mode\n         CH    R8,=AL2(CEE_EYECATCHER+4-COBOL_370_DSECT) Module okay?\n         BL    COBC$X                   No, this module is very short\n*\n         CLC   CEE_EYECATCHER-COBOL_370_DSECT(4,R9),COBC_C370\n         BE    COBC$370\n         CLC   C2_EYECATCHER-COBOL_2_DSECT(4,R9),=CL4' C2 '\n         BE    COBC$2\n***      CLC   X'14'(4,R9),=CL4'ANS4'     ANSI (Ancient) COBOL?\n***      BE    COBC$ANSI\n***      CLC   X'14'(4,R9),=CL4'VSR1'     OS/VS COBOL?\n***      BE    COBC$OSVS                  Yes, got a live one\n*\n** Exit\n*\nCOBC$X   DS    0H\n         DA#SMODE 24                      Get into 24 bit addr mode\n         PR    ,                        Return to caller\n*\n** Older COBOL non-Support\n*\nCOBC$ANSI DS 0H\n         MVC   COBCR_TYPE-COBCR(10,R3),=C'ANSI_COBOL'\n         B     COBC$OLD\nCOBC$OSVS DS 0H\n         MVC   COBCR_TYPE-COBCR(11,R3),=C'OS/VS_COBOL'\nCOBC$OLD DS 0H\n         B     COBC$X\n*\n** COBOL/370\n*\nCOBC$370 DS 0H\n         USING COBOL_370_DSECT,R9\n*\n         CH    R8,=AL2(CEE_STATUS_BYTE_03+1-COBOL_370_DSECT)\n         BL    COBC$X\n*\n         TM    CEE_STATUS_BYTE_01,DYNAM\n         BNO   COBC$370_DYNAMX\n         MVC   0(5,R7),=C'DYNAM'\n         LA    R7,6(R7)\nCOBC$370_DYNAMX DS 0H\n         TM    CEE_STATUS_BYTE_02,LIB\n         BO    COBC$370_LIBX\n         MVC   0(5,R7),=C'NOLIB'\n         LA    R7,6(R7)\nCOBC$370_LIBX DS 0H\n         TM    CEE_STATUS_BYTE_03,RENT\n         BO    COBC$370_RENTX\n         MVC   0(6,R7),=C'NORENT'\n         LA    R7,7(R7)\nCOBC$370_RENTX DS 0H\n         TM    CEE_STATUS_BYTE_03,RES\n         BO    COBC$370_RESX\n         MVC   0(5,R7),=C'NORES'\n         LA    R7,6(R7)\nCOBC$370_RESX DS 0H\n*\n         DROP  R9\n*\n         CLI   COBCR_INFO-COBCR(R3),C' ' Found any errors above?\n         BE    COBC$X                    No, continue\n         MVC   COBCR_TYPE-COBCR(9,R3),=C'COBOL/370' Mark COBOL type\n         MVC   COBCR_ERROR-COBCR(6,R3),=C'Error:'   Set error indicator\n         B     COBC$X\n*\n** VS COBOL II\n*\nCOBC$2   DS    0H\n         USING COBOL_2_DSECT,R9\n*\n         CH    R8,=AL2(C2_STATUS_BYTE_03+1-COBOL_2_DSECT)\n         BL    COBC$X\n*\n         TM    C2_STATUS_BYTE_01,DYNAM\n         BNO   COBC$2_DYNAMX\n         MVC   0(5,R7),=C'DYNAM'\n         LA    R7,6(R7)\nCOBC$2_DYNAMX DS 0H\n         TM    C2_STATUS_BYTE_02,LIB\n         BO    COBC$2_LIBX\n         MVC   0(5,R7),=C'NOLIB'\n         LA    R7,6(R7)\nCOBC$2_LIBX DS 0H\n         TM    C2_STATUS_BYTE_03,RENT\n         BO    COBC$2_RENTX\n         MVC   0(6,R7),=C'NORENT'\n         LA    R7,7(R7)\nCOBC$2_RENTX DS 0H\n         TM    C2_STATUS_BYTE_03,RES\n         BO    COBC$2_RESX\n         MVC   0(5,R7),=C'NORES'\n         LA    R7,6(R7)\nCOBC$2_RESX DS 0H\n*\n         DROP  R9\n         CLI   COBCR_INFO-COBCR(R3),C' ' Found any errors above?\n         BE    COBC$X                    No, continue\n         MVC   COBCR_TYPE-COBCR(11,R3),=C'VS_COBOL_II' Mark COBOL type\n         MVC   COBCR_ERROR-COBCR(6,R3),=C'Error:'   Set error indicator\n         B     COBC$X\n*\n** Local constants\n*\nCOBC_C370 DC X'00',C'CEE'                    COBOL/370 ?  X'00C3C5C5'\n         DS    0H\n         LTORG ,\n         DROP  R12\n         EJECT\n***********************************************************************\n***\n**       Copy in the DA$PDSRC member for DFSMS/MVS Binder API\n***\n***********************************************************************\n         SPACE 2\n         AIF   ('&IHADFARELS' LT '01010100').CCMX\n         PRINT GEN\n*\n* +-------------------------------------------------------------------+\n* | Name: PDSRCM (originally ..CM meant Csect Map)                    |\n* |                                                                   |\n* | Purpose: Use IBM's Binder API to analyze a load library member:   |\n* |          - Produce a Translator report                            |\n* |          - Produce a History (IDR Identify and Zap) Report        |\n* |          - Process load module text                               |\n* |                                                                   |\n* | This program checks to see if these files are allocated and uses  |\n* | them as options (parameters).  You would usually allocate them    |\n* | via \"DD DUMMY\":                                                   |\n* |                                                                   |\n* | o USEDCB .....Use DCB instead of Name method                      |\n* | o BINDERMD....Message Exit Debugging                              |\n* | o BINDERDB....Binder API \"debugging mode\" - show all messages     |\n* | o BINDERDE....Dump Binder API buffer entries (hex dump)           |\n* | o BINDERNM....No Binder API messages                              |\n* | o BINDERPR....Get around UW32119 problem with DFSMS/MVS 1.3       |\n* |                                                                   |\n* | Known Problems:                                                   |\n* | - Binder messages will go to the console if UW32119 is not on     |\n* |   DFSMS/MVS 1.3 for option=NOPRINT.  Best thing to do is to run   |\n* |   with BINDEROU/BINDERPR DD's set to dummy if UW32119 is not on.  |\n* |                                                                   |\n* +-------------------------------------------------------------------+\n         EJECT ,\n* +-------------------------------------------------------------------+\n* | Start of CSECT                                                    |\n* +-------------------------------------------------------------------+\n*\nPDSRCM   CSECT ,\nPDSRCM   AMODE 24\nPDSRCM   RMODE 24\n*\n** Standard O/S eyecatcher\n*\nPDSRCM_EC     B    PDSRCM_ECL(0,R15)      Bump past EyeCatcher\n              DC   AL1(L'PDSRCM_ECLIT)    Length of eyecatcher\nPDSRCM_ECLIT  DC   C'PDSRCM   - Binder API reports'\n              DS   0H\nPDSRCM_ECL    EQU  *-PDSRCM_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         LAE   R11,2048(,R12)           Set up for second base reg\n         LA    R11,2048(,R11)           Locate 4096 past R12\n         LAE   R10,2048(,R11)           Set up for third base reg\n         LA    R10,2048(,R10)           Locate 4096 past R11\n         USING PDSRCM,R12,R11,R10       Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1\n         LR    R13,R1                     Locate RSA and work area\n         USING PDSRCMD,R13                Locate to data area\n*\n** Do processing that we are called to perform\n*\n         MVC   PDSRCMD_FUNC(8),=CL8' '    Nothing doing (so far)\n*\n         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_INIT Initialization?\n         BE    PDSRCM$I\n         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_MEM  Member?\n         BE    PDSRCM$M\n         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_LIBS Library start?\n         BE    PDSRCM$S\n         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_LIBE Library end?\n         BE    PDSRCM$E\n         CLI   PDSRCMD_CALLT,$PDSRCMD_CT_TERM Termination?\n         BE    PDSRCM$T\n         LA    R15,255                    Error: invalid option\n*\n** Termination for PDSRCM\n*\nPDSRCM$X DS    0H                         Exit\n         PR    ,                          Return to caller\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Since I check for the availablity of some of the fields copied\n** in by IEWBCES, I need this up here and not with the rest of the\n** constants and equates.\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         COPY IEWBCES ,                 ESD codes\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Process a member:\n**\n** - Binder information\n** - CSECT processing:\n**   - Translator report\n**   - History report\n**   - Process text records for a CSECT\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$M DS    0H\n         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2EMSG Turn off flag\n         XC    PDSRCMD_MZAPCNT(4),PDSRCMD_MZAPCNT\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2MEM  Say we came this way\n         XC    PDSRCMD_CSECTS(4),PDSRCMD_CSECTS\n         XC    PDSRCMD_CSPRIVC(2),PDSRCMD_CSPRIVC\n*\n** Print a blank line for new member\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?\n         BNO   PDSRCM$M_TRSLX             No, continue\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1TRM  Found a Translator?\n         BNO   PDSRCM$M_TRSLX\n         CLI   PDSRCMD_TRPRRLC,99\n         BE    PDSRCM$M_TRSLX\n         BAS   R14,PDSRCM_CLEAR_RECOUT\n         BAS   R14,PDSRCM_TRPRR     Print Report Record\nPDSRCM$M_TRSLX DS 0H\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?\n         BNO   PDSRCM$M_HISLX             No, continue\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1HIM  Found a History mem?\n         BNO   PDSRCM$M_HISLX\n         CLI   PDSRCMD_HIPRRLC,99\n         BE    PDSRCM$M_HISLX\n         BAS   R14,PDSRCM_CLEAR_RECOUT\n         BAS   R14,PDSRCM_HIPRR     Print Report Record\nPDSRCM$M_HISLX DS 0H\n*\n** Create a Workmod with Intent ACCESS\n*\n         MVC   PDSRCMD_WKTOKEN(8),PDSRCM_ZEROS Clear workmod token\n         MVC   PDSRCMD_FUNC(8),=CL8'CREATEW'\n         IEWBIND FUNC=CREATEW,                                         C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               DIALOG=PDSRCMD_DTOKEN,                                  C\n               INTENT=ACCESS,                                          C\n               MF=(E,PDSRCMD_PARMLIST)\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code\n         BNE   PDSRCM$ME                  Exit if not zero\n*\n** Set Binder API options\n**\n** DFSMS/MVS 1.3 adds the PARMS= keyword\n*\n         MVC   PDSRCMD_FUNC(8),=CL8'SETO'\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Binder Debug Mode?\n         BO    PDSRCM$M_BDBO              Yes, more info\n         AIF   ('&IHADFARELS' LT '01010300').MSOP1 .at DFSMS/MVS 1.3?\n*-Regular mode for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=SETO,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               OPTION=O_LIST,OPTVAL=V_OFF,       LIST(OFF)             C\n               PARMS=PARMS_NODB,                                       C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MSOP1X\n.MSOP1   ANOP  ,\n*-Regular mode for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=SETO,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               OPTION=O_LIST,OPTVAL=V_OFF,       LIST(OFF)             C\n               MF=(E,PDSRCMD_PARMLIST)\n.MSOP1X  ANOP  ,\n         B     PDSRCM$M_BDBOX\nPDSRCM$M_BDBO  DS 0H\n         AIF   ('&IHADFARELS' LT '01010300').MSOP2 .at DFSMS/MVS 1.3?\n*-Debugging mode for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=SETO,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               OPTION=O_LIST,OPTVAL=V_ALL,      LIST(ALL)              C\n               PARMS=PARMS_DB,                                         C\n               MF=(E,PDSRCMD_PARMLIST)\n.MSOP2   ANOP  ,\n*-Debugging mode for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=SETO,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               OPTION=O_LIST,OPTVAL=V_ALL,      LIST(ALL)              C\n               MF=(E,PDSRCMD_PARMLIST)\n.MSOP2X  ANOP  ,\nPDSRCM$M_BDBOX DS 0H\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code\n         BNE   PDSRCM$ME                  Exit if not zero\n*\n** Include the module\n*\n     TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2UDCB    DCB allowed?\n     BNO   PDSRCM$M_INAM                      No, always do with name\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1DCB   Driver thought DCB okay?\n         BO    PDSRCM$M_IDCB                  Yes, do it that way\nPDSRCM$M_INAM DS 0H\n         MVC   PDSRCMD_FUNC(8),=CL8'INCLUDEn'  <- Include intype=Name\n         IEWBIND FUNC=INCLUDE,                                         C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               INTYPE=NAME,                                            C\n               DDNAME=PDSRCMD_INCLLIB,                                 C\n               MEMBER=PDSRCMD_MODNAME,                                 C\n               MF=(E,PDSRCMD_PARMLIST)\n         B     PDSRCM$M_IDCBX\nPDSRCM$M_IDCB DS 0H\n         MVC   PDSRCMD_FUNC(8),=CL8'INCLUDEp' <- Include intype=Pointer\n         IEWBIND FUNC=INCLUDE,                                         C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               INTYPE=POINTER,                                         C\n               DCBPTR=PDSRCMD_DCBPTR,                                  C\n               DEPTR=PDSRCMD_DEPTR,                                    C\n               MF=(E,PDSRCMD_PARMLIST)\nPDSRCM$M_IDCBX DS 0H\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code\n         BE    PDSRCM$M_IDCBO\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Warning?\n         BNE   PDSRCM$ME\n*\n** Obtain all section names\n*\nPDSRCM$M_IDCBO DS 0H\n         LM    R6,R7,PDSRCMD_SAVEESD     Get saved registers\n         USING IEWBESD,R6\n         USING ESD_ENTRY,R7\n         LM    R8,R9,PDSRCMD_SAVEBNL     Get saved registers\n         USING IEWBBNL,R8\n         USING BNL_ENTRY,R9\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2FSEC\n*\n         MVC   PDSRCMD_CURSORN(4),PDSRCM_ZEROS\n         MVC   PDSRCMD_FUNC(8),=CL8'GETN'\n         AIF   ('&IHADFARELS' LT '01010300').MGETN  at DFSMS/MVS 1.3?\n*-GETN for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETN,                                            C\n               VERSION=1,                                              C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               AREA=IEWBBNL,                                           C\n               CURSOR=PDSRCMD_CURSORN,                                 C\n               COUNT=PDSRCMD_COUNTN,                                   C\n               TCOUNT=PDSRCMD_TCOUNT,                                  C\n               NTYPE=S,                                                C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MGETNX\n.MGETN   ANOP  ,\n*-GETN for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=GETN,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               AREA=IEWBBNL,                                           C\n               CURSOR=PDSRCMD_CURSORN,                                 C\n               COUNT=PDSRCMD_COUNTN,                                   C\n               TCOUNT=PDSRCMD_TCOUNT,                                  C\n               NTYPE=S,                                                C\n               MF=(E,PDSRCMD_PARMLIST)\n.MGETNX  ANOP  ,\n*\n         XC    PDSRCMD_COUNTNC(4),PDSRCMD_COUNTNC Current count (debug)\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code\n         BE    PDSRCM$M_NOK\n*\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING RC=4?\n         BNE   PDSRCM$M_NRC4X             No, continue\n         CLC   PDSRCMD_RSNCODE(4),=X'83000800'  End of data?\n         BE    PDSRCM$M_NRCVC\n         CLC   PDSRCMD_RSNCODE(4),=X'83000801'  No section names?\n         BE    PDSRCM$ME\n         B     PDSRCM$M_NRCVCX\nPDSRCM$M_NRCVC DS 0H\n         L     R14,PDSRCMD_PSRAREA        Locate to area\n         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5EODC User wants this?\n         BNO   PDSRCM$M_NOK               No, continue\nPDSRCM$M_NRCVCX DS 0H\n*\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM20L,R15),MSGCM20-PDSRCMC(R1) Get message text\n         LA    R15,MSGCM20L(R15)          Bump past message\n         UNPK  0(9,R15),PDSRCMD_RSNCODE(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789abcdef'\n         MVC   8(9,R15),=C', member='\n         LA    R15,8+9(R15)\n         MVC   0(8,R15),PDSRCMD_MODNAME+2\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n         B     PDSRCM$M_NOK               Yes, continue\nPDSRCM$M_NRC4X DS 0H\n*\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM1L,R15),MSGCM1-PDSRCMC(R1) Get message text\n         LA    R15,MSGCM1L(R15)           Bump past message\n         L     R1,PDSRCMD_TCOUNT          Get total number of sections\n         S     R1,PDSRCMD_COUNTN          Number we didn't get\n         BAS   R14,PDSRCM_EDITFWF         Edit it\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$M_NOK EQU *\n*\n** Process all sections\n*\n         L     R5,PDSRCMD_COUNTN          Number of sections\nPDSRCM$M_L1 DS 0H\n         L     R1,PDSRCMD_COUNTNC\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_COUNTNC\n*\n         L     R3,BNL_NAME_PTR            Extract section name\n         LH    R2,BNL_NAME_CHARS          Get length of section name\n         STH   R2,PDSRCMD_SECTION         Save for later\n         LA    R4,PDSRCMD_SECTION\n*\n         LA    R15,PDSRCMD_SECTION+2      | Note:\n         MVI   0(R15),C' '                | This is being done for us\n         MVC   1(255,R15),0(R15)          | and not for the Binder API\n*\n         BCTR  R2,0                       Decrement for EX\n         EX    R2,MOVESEC                 Get section name\n*-Note: Bruce says he increments the $PRIVATE CSECTs.\n*\n* .   .    .    .    .    .    .     .    .    .    .   .    .   .\n*-Print the section name if we are dumping control blocks\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1DMPA Dumping areas?\n         BNO   PDSRCM$M_DESX              Nope, leave\n         BAS   R14,PDSRCM_FORMAT_MESSAGE\n         MVC   0(MSGCM4L,R15),MSGCM4\n         MVC   MSGCM4M-MSGCM4(8,R15),PDSRCMD_MODNAME+2\n         LA    R15,MSGCM4L(R15)\n         CLI   PDSRCMD_SECTION+2,C'A'\n         BL    PDSRCM$M_DESS\n         LH    R1,PDSRCMD_SECTION\n         CH    R1,=H'64'\n         BNH   PDSRCM$M_DESK\n         LA    R1,64\nPDSRCM$M_DESK DS 0H\n         BCTR  R1,0\n         EX    R1,PDSRCM$M_DESM\n         LA    R15,1(R1,R15)\n         MVI   0(R15),C'\"'\n         LA    R15,2(R15)\n         B     PDSRCM$M_DES$C\nPDSRCM$M_DESS  DS 0H\n         SH    R15,=H'2'                      Backup over '=\"'\n         MVI   0(R15),C':'\n         LA    R15,2(R15)\n         UNPK  0(5,R15),PDSRCMD_SECTION(3)\n         MVZ   0(4,R15),PDSRCM_ZEROS\n         TR    0(4,R15),PDSRCM_HEXTABLE\n         MVI   4(R15),C'-'\n         LA    R15,5(R15)\n         LH    R0,PDSRCMD_SECTION\n         LA    R1,PDSRCMD_SECTION+2\nPDSRCM$M_DES$L DS 0H\n         UNPK  0(3,R15),0(2,R1)\n         MVZ   0(2,R15),PDSRCM_ZEROS\n         TR    0(2,R15),PDSRCM_HEXTABLE\n         MVI   2(R15),C' '\n         LA    R15,2(R15)\n         LA    R1,1(R1)\n         BCT   R0,PDSRCM$M_DES$L\nPDSRCM$M_DES$C DS 0H\n         MVI   1(R15),C'#'\n         LA    R15,2(R15)\n         L     R1,PDSRCMD_COUNTNC\n         BAS   R14,PDSRCM_EDITFWF\n         MVC   1(2,R15),=C'of'\n         LA    R15,1+2+1(R15)\n         L     R1,PDSRCMD_COUNTN\n         BAS   R14,PDSRCM_EDITFWF\n         B     PDSRCM$M_DES$X\nPDSRCM$M_DESM  MVC 0(0,R15),PDSRCMD_SECTION+2\nPDSRCM$M_DES$X DS   0H\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$M_DESX DS 0H\n* .   .    .    .    .    .    .     .    .    .    .   .    .   .\n*\n** Process the current Section and obtain ESD entries\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FSEC      First section?\n         BNO   PDSRCM$M_DESBX                       No, continue\n         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2FSEC  Reset flag\n         BAS   R14,PDSRCM$M_BIND                    Get binder info\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN        Translator?\n         BO    PDSRCM$M_DESBX                       No, continue\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST        History?\n         BO    PDSRCM$M_DESBX                       No, continue\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT        Text processing?\n         BO    PDSRCM$M_DESBX                       No, continue\n         B     PDSRCM$M_DW                          Leave w/only binder\nPDSRCM$M_DESBX DS 0H\n*\n         MVC   PDSRCMD_CURSORDE(4),PDSRCM_ZEROS\n         MVC   PDSRCMD_FUNC(8),=CL8'GETD-ESD'\n         AIF   ('&IHADFARELS' LT '01010300').MGESD  at DFSMS/MVS 1.3?\n*-GETD/ESD for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETD,                                            C\n               VERSION=1,                                              C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBESD,                                           C\n               CLASS=PDSRCMD_B_ESD,                                    C\n               CURSOR=PDSRCMD_CURSORDE,                                C\n               COUNT=PDSRCMD_COUNTDE,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MGESDX\n.MGESD   ANOP  ,\n*-GETD/ESD for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=GETD,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBESD,                                           C\n               CLASS=PDSRCMD_B_ESD,                                    C\n               CURSOR=PDSRCMD_CURSORDE,                                C\n               COUNT=PDSRCMD_COUNTDE,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n.MGESDX  ANOP  ,\n*\n         LH    R0,=AL2(ESDH_END-ESDH_START) Get length of header\n         LA    R1,C_ID_ESD_HEADER   Locate string of header name\n         LR    R15,R6               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK\n         BE    PDSRCM$M_DEOK\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer\n         BE    PDSRCM$M_DEOK\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR  No data for item\n         BNE   PDSRCM$M_L2X                        Yes, leave\nPDSRCM$M_DEOK EQU *\n         L     R4,PDSRCMD_COUNTDE   Number of ESD entries in buffer\n         LTR   R4,R4                Skip empty section\n         BZ    PDSRCM$M_NS          None, leave\n         LA    R7,ESDH_END          First record in ESD buffer\nPDSRCM$M_L2 DS 0H\n         CLC   ESD_TYPE(L'ESD_TYPE),ESDT_CTRL_SEC CSECT?\n         BNE   PDSRCM$M_L2B         No, skip this ESD entry\n*\n         L     R1,PDSRCMD_CSECTS    Get number\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_CSECTS    Save it\n*\n         LH    R0,=AL2(ESD_END-ESD_ENTRY)  Get length of entry\n         LA    R1,C_ID_ESD_BUFFER   Locate string of entry type\n         LR    R15,R7               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n*-Format the CSECT name for output reports - - - - - - - - - - - - -\n         CLI   ESD_SCOPE,C'S'             $PRIVATE?\n         BE    PDSRCM$M_L2_CSPRIV         Yes, looks that way...\n         LH    R1,PDSRCMD_SECTION         Get length of CSECT name\n         CH    R1,=AL2(L'OCL_CSECT)       Longer than field name?\n         BNH   PDSRCM$M_L2_CSXOK\n         MVC   PDSRCMD_OCLCSECT(L'OCL_CSECT-5),PDSRCMD_SECTION+2\n         L     R14,=V(PDSR$C2)            Locate constants CSECT\n         TR    PDSRCMD_OCLCSECT(L'OCL_CSECT-5),C_TRTABA-PDSR$C2(R14)\n         L     R1,PDSRCMD_TRUNCC\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_TRUNCC\n*-Here we turn \"LONGERNAME\" into \"LONGE_xxxx\" where xxxx is in dec\n* for the number of truncated CSECT names\n         LA    R14,PDSRCMD_OCLCSECT+(L'OCL_CSECT-5)\n         MVI   0(R14),C'_'\n         CVD   R1,PDSRCMD_DOUBLE2\n         UNPK  1(4,R14),PDSRCMD_DOUBLE2+6(2)\n         OI    1+3(R14),C'0'\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message\n         MVC   0(MSGCM17L,R15),MSGCM17    Get text\n         LA    R15,MSGCM17L(R15)\n         MVC   0(L'OCL_CSECT,R15),PDSRCMD_OCLCSECT\n         LA    R15,L'OCL_CSECT(R15)       Locate past CSECT name\n         MVC   0(9,R15),=C', actual='     Insert text\n         LA    R15,9(R15)                 Bump past it\n         LH    R14,PDSRCMD_SECTION        Get length of name\n         CH    R14,=H'64'                 Over 64?\n         BNH   PDSRCM$M_L2_CSLCX          No, can fit on this line\n*-Note: need to do wraping here. (don't need to truncate twice!!!)\n LA R14,64 Will you still love me, will you still need me when I'm 64\nPDSRCM$M_L2_CSLCX DS 0H\n         BCTR  R14,0\n         EX    R14,PDSRCM$M_L2_CSLCM\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n         B     PDSRCM$M_L2_CSXX           Brance around executed instr\nPDSRCM$M_L2_CSLCM  MVC 0(0,R15),PDSRCMD_SECTION+2\nPDSRCM$M_L2_CSOKLM MVC PDSRCMD_OCLCSECT(0),PDSRCMD_SECTION+2\nPDSRCM$M_L2_CSOKLT TR  PDSRCMD_OCLCSECT(0),C_TRTABA-PDSR$C2(R14)\n         SPACE 2\n*-CSECT looks to be a $PRIVATE section, name it so and append a number\nPDSRCM$M_L2_CSPRIV DS 0H\n         MVI   PDSRCMD_OCLCSECT,C' '\n         MVC   PDSRCMD_OCLCSECT+1(L'OCL_CSECT-1),PDSRCMD_OCLCSECT\n         LA    R15,PDSRCMD_OCLCSECT\n         MVC   0(6,R15),=C'$Priv#'\n         LA    R15,6(R15)\n         LH    R1,PDSRCMD_CSPRIVC\n         LA    R1,1(R1)\n         STH   R1,PDSRCMD_CSPRIVC\n         BAS   R14,PDSRCM_EDITFWF\n         B     PDSRCM$M_L2_CSXX\n         SPACE 2\n*-CSECT name is okay in length, move it to field for later\nPDSRCM$M_L2_CSXOK  DS 0H\n         MVI   PDSRCMD_OCLCSECT,C' '\n         MVC   PDSRCMD_OCLCSECT+1(L'OCL_CSECT-1),PDSRCMD_OCLCSECT\n         BCTR  R1,0\n         EX    R1,PDSRCM$M_L2_CSOKLM      Move out CSECT name\n         L     R14,=V(PDSR$C2)            Locate constants CSECT\n         EX    R1,PDSRCM$M_L2_CSOKLT      Ensure Name is printable\nPDSRCM$M_L2_CSXX DS 0H\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n** Initialize for //FLATOUT processing\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?\n         BNO   PDSRCM$M_L2FIX       No, skip this code\n         L     R1,PDSRCMD_FOA+4     Locate FLATOUT record Area\n         LA    R1,FOM_RECORD-FOM(R1) Locate to record output\n         MVI   FOR_TYPE-FOR(R1),$FORTYPE_C\n         MVI   FOR_SPACE1-FOR(R1),C' '\n         MVI   FOR_SPACE2-FOR(R1),C' '\n         MVI   FORC_SPACE1-FOR(R1),C' '\nPDSRCM$M_L2FIX DS 0H\n*\n** See if this CSECT is a \"vendor\" CSECT\n*\n         L     R14,PDSRCMD_PSRAREA        Locate to area\n         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5IVCSECTS Flag on?\n         BNO   PDSRCM$M_L2_IVCX           No, continue\n*\n         LA    R0,PDSRCMD_SECTION+2       Locate CSECT name\n         L     R1,PDSRCMD_SUBRSAP         Locate SUBRSA\n         LR    R2,R13                     Locate PDSRCMD area\n         L     R15,=V(PDSR$IVC)           Locate routine\n         BASR  R14,R15                    Call Ignore_Vendor_CSECT rout\n*\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?\n         BNO   PDSRCM$M_L2_IVCX           No, continue\n         L     R14,PDSRCMD_PSRAREA        Locate to area\n         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5IVCSECTF Full ignore?\n         BO    PDSRCM$M_L2B               Yes, skip CSECT completely\nPDSRCM$M_L2_IVCX DS 0H\n*\n** Call each type of routine that looks at a CSECT\n*\n         BAS   R14,PDSRCM$M_TRAN    Get translator information\n         BAS   R14,PDSRCM$M_HISTZ   Get History information (Zap)\n         BAS   R14,PDSRCM$M_HISTU   Get History information (User)\n         BAS   R14,PDSRCM$M_TEXT    Text (Flatout, eyecatcher)\n*\n** At this time, the Flatout record is complete, put out record\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?\n         BNO   PDSRCM$M_L2FTX       No, skip this code\n         L     R1,PDSRCMD_FOA+4     Locate FLATOUT record Area\n         LA    R1,FOM_RDW-FOM(R1)\n         LA    R14,FORCL+L'FOM_RDW\n         STH   R14,0(R1)\n         LR    R0,R1\n         PUT   PDSRCMD_DCBF,(0)\nPDSRCM$M_L2FTX DS 0H\n*\nPDSRCM$M_L2B DS 0H\n         A     R7,ESDH_ENTRY_LENG   Move to next ESD in this section\n         BCT   R4,PDSRCM$M_L2\nPDSRCM$M_L2X DS 0H\n*\n** Bump to the next section\n*\nPDSRCM$M_NS DS 0H                         Next section - - - - - - -\n         A     R9,BNLH_ENTRY_LENG         Move to next section name\n         BCT   R5,PDSRCM$M_L1\n         B     PDSRCM$MEX\n         DROP  R6,R7,R8,R9\n*\n** Errors found on Binder API call\n*\nPDSRCM$ME DS 0H\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message\n         MVC   0(MSGCM2L,R15),MSGCM2-PDSRCMC(R1)  Get text\n         LA    R15,MSGCM2L(R15)\n         MVC   0(8,R15),PDSRCMD_MODNAME+2   Get member name\n         BAS   R14,PDSRCM_EPM             Ensure Printable Member\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message\n         MVC   0(MSGCM2AL,R15),MSGCM2A    Get text\n         LA    R15,MSGCM2AL(R15)          Bump past text\n         L     R1,PDSRCMD_PARMLIST+0      Get function address\n         UNPK  0(5,R15),0(3,R1)                >\n         MVZ   0(4,R15),PDSRCM_ZEROS           >> Hex translate\n         TR    0(4,R15),PDSRCM_HEXTABLE >\n         MVC   4(2,R15),=C')-'            Delimiter\n         LA    R15,6(R15)                 Bump past delimiter\n         MVC   0(L'PDSRCMD_FUNC,R15),PDSRCMD_FUNC Function name\n         LA    R0,L'PDSRCMD_FUNC          Get max length 0123/function\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE  Locate first space\n         MVC   0(5,R15),=C', RC='         Get text\n         LA    R15,5(R15)                 Bump past it\n         L     R1,PDSRCMD_RETCODE         Get return code\n         BAS   R14,PDSRCM_EDITFWF         Edit it\n         MVC   0(9,R15),=C', Reason='     Get text\n         LA    R15,9(R15)                 Bump past it\n         UNPK  0(9,R15),PDSRCMD_RSNCODE(5)   >\n         MVZ   0(8,R15),PDSRCM_ZEROS         >> Hex translate\n         TR    0(8,R15),PDSRCM_HEXTABLE >\n         MVI   8(R15),C' '                Fix trailing byte\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear recout to blanks\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$MEX DS 0H\n*\n** Delete the workmod\n*\nPDSRCM$M_DW DS 0H\n         MVC   PDSRCMD_FUNC(8),=CL8'DELETEW'\n         IEWBIND FUNC=DELETEW,                                         C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               PROTECT=YES,                                            C\n               MF=(E,PDSRCMD_PARMLIST)\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK\n         BNE   PDSRCM$MDWE\n         MVC   PDSRCMD_FUNC(8),=CL8'????????'\n         B     PDSRCM$X\n*\nPDSRCM$MDWE DS 0H\n         LA    R15,4\n         B     PDSRCM$X\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** This routine formats the common section for the various reports\n** (It would be very unlucky to overlay PDSRCMD_DOUBLE here!!!!)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM_MFCS    DS 0H\n         USING IEWBESD,R6\n         USING ESD_ENTRY,R7\n         ST    R14,PDSRCMD_DOUBLE                  Save return address\n         BAS   R14,PDSRCM_CLEAR_RECOUT\n         MVC   OCL_MEMBER-OCL(L'OCL_MEMBER,R15),PDSRCMD_MODNAME+2\n         MVC   OCL_ALIAS-OCL(L'OCL_ALIAS,R15),PDSRCMD_ALIAS\n*\n         UNPK  PDSRCMD_DOUBLE2(9),ESD_LENG(5)\n         MVZ   PDSRCMD_DOUBLE2(8),PDSRCM_ZEROS\n         TR    PDSRCMD_DOUBLE2(8),PDSRCM_HEXTABLE\n         MVC   OCL_LENGTH-OCL(8,R15),PDSRCMD_DOUBLE2\n*\n         UNPK  PDSRCMD_DOUBLE2(9),ESD_MODULE_OFFSET(5)\n         MVZ   PDSRCMD_DOUBLE2(8),PDSRCM_ZEROS\n         TR    PDSRCMD_DOUBLE2(8),PDSRCM_HEXTABLE\n         MVC   OCL_OFFSET-OCL(8,R15),PDSRCMD_DOUBLE2\n*\n         MVC   OCL_CSECT-OCL(L'OCL_CSECT,R15),PDSRCMD_OCLCSECT\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?\n         BNO   PDSRCM$M_MFC$VCX           Yes, don't test it\n         MVI   OCL_CSECT-1-OCL(R15),C'!'\nPDSRCM$M_MFC$VCX DS 0H\n*\n         CLI   ESD_AMODE,ESDAM_UNSPEC\n         BE    PDSRCM$M_MFC$AMX\n         CLI   ESD_AMODE,ESDAM_24\n         BE    PDSRCM$M_MFC$AM24\n         CLI   ESD_AMODE,ESDAM_31\n         BE    PDSRCM$M_MFC$AM31\n         CLI   ESD_AMODE,ESDAM_ANY\n         BE    PDSRCM$M_MFC$AMANY\n         CLI   ESD_AMODE,ESDAM_MIN\n         BNE   PDSRCM$M_MFC$AMX\n         MVC   OCL_AMODE-OCL(9,R15),=C'AMODE Min'\n         B     PDSRCM$M_MFC$AMX\nPDSRCM$M_MFC$AMANY DS 0H\n         MVC   OCL_AMODE-OCL(9,R15),=C'AMODE Any'\n         B     PDSRCM$M_MFC$AMX\nPDSRCM$M_MFC$AM31 DS 0H\n         MVC   OCL_AMODE-OCL(8,R15),=C'AMODE 31'\n         B     PDSRCM$M_MFC$AMX\nPDSRCM$M_MFC$AM24 DS 0H\n         MVC   OCL_AMODE-OCL(8,R15),=C'AMODE 24'\nPDSRCM$M_MFC$AMX DS 0H\n*\n         CLI   ESD_RMODE,ESDRM_UNSPEC\n         BE    PDSRCM$M_MFC$RMX\n         CLI   ESD_RMODE,ESDRM_24\n         BE    PDSRCM$M_MFC$RM24\n         CLI   ESD_RMODE,ESDRM_ANY\n         BNE   PDSRCM$M_MFC$RMX\n         MVC   OCL_RMODE-OCL(9,R15),=C'RMODE Any'\n         B     PDSRCM$M_MFC$RMX\nPDSRCM$M_MFC$RM24 DS 0H\n         MVC   OCL_RMODE-OCL(8,R15),=C'RMODE 24'\nPDSRCM$M_MFC$RMX DS 0H\n*\n         CLI   ESD_ALIGN,ESDAL_BYTE\n         BE    PDSRCM$M_MFC$AL_BYTE\n         CLI   ESD_ALIGN,ESDAL_HALF_WORD\n         BE    PDSRCM$M_MFC$AL_HALF\n         CLI   ESD_ALIGN,ESDAL_FULL_WORD\n         BE    PDSRCM$M_MFC$AL_FULL\n         CLI   ESD_ALIGN,ESDAL_DOUBLE_WORD\n         BE    PDSRCM$M_MFC$AL_DOUBLE\n         AIF   (NOT D'ESDAL_PAGE).MFCPX\n         CLI   ESD_ALIGN,ESDAL_DOUBLE_WORD\n         BE    PDSRCM$M_MFC$AL_PAGE\n         B     PDSRCM$M_MFC$ALX\nPDSRCM$M_MFC$AL_PAGE DS 0H\n         MVC   OCL_ALIGN-OCL(4,R15),=C'Page'\n.MFCPX   ANOP  ,\n         B     PDSRCM$M_MFC$ALX\nPDSRCM$M_MFC$AL_BYTE DS 0H\n         MVC   OCL_ALIGN-OCL(4,R15),=C'Byte'\n         B     PDSRCM$M_MFC$ALX\nPDSRCM$M_MFC$AL_HALF DS 0H\n         MVC   OCL_ALIGN-OCL(9,R15),=C'Half Word'\n         B     PDSRCM$M_MFC$ALX\nPDSRCM$M_MFC$AL_FULL DS 0H\n         MVC   OCL_ALIGN-OCL(9,R15),=C'Full Word'\n         B     PDSRCM$M_MFC$ALX\nPDSRCM$M_MFC$AL_DOUBLE DS 0H\n         MVC   OCL_ALIGN-OCL(11,R15),=C'Double Word'\nPDSRCM$M_MFC$ALX DS 0H\n*\n** Return to caller\n*\n         L     R14,PDSRCMD_DOUBLE                  Get return address\n         BSM   0,R14\n         DROP  R6,R7\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Report on Translator information\n**\n** We have some special code that looks at the modules that have more\n** than one translator record.  Sometimes the second entry is fine\n** like for PLS.  Other times, there is a \"garbage\" second entry that\n** begins with the member name.  When we figure out when the second\n** translator isn't bogus, we can remove the IF1FT flag stuff...\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$M_TRAN DS 0H\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN\n         BNO   PDSRCM$M_TRANQO\n         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1TRM\n         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1FT\n         ST    R14,PDSRCMD_MTRA          Save return address\n*\n         BAS   R14,PDSRCM_MFCS           Format common report section\n*\n         STM   R4,R9,PDSRCMD_MTSREG      Save work registers\n         LM    R6,R7,PDSRCMD_SAVEIDL     Get saved registers\n         USING IEWBIDL,R6\n         USING IDL_ENTRY,R7\n         MVC   PDSRCMD_CURSORDL(4),PDSRCM_ZEROS Set cursor\n         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDL'\n         AIF   ('&IHADFARELS' LT '01010300').MGIDL  at DFSMS/MVS 1.3?\n*-GETD/IDL for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETD,                                            C\n               VERSION=1,                                              C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDL,                                           C\n               CLASS=PDSRCMD_B_IDRL,                                   C\n               CURSOR=PDSRCMD_CURSORDL,                                C\n               COUNT=PDSRCMD_COUNTDL,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MGIDLX\n.MGIDL   ANOP  ,\n*-GETD/IDL for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=GETD,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDL,                                           C\n               CLASS=PDSRCMD_B_IDRL,                                   C\n               CURSOR=PDSRCMD_CURSORDL,                                C\n               COUNT=PDSRCMD_COUNTDL,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n.MGIDLX  ANOP  ,\n*\n         LH    R0,=AL2(IDLH_END-IDLH_START) Get length of header\n         LA    R1,C_ID_IDL_HEADER   Locate string of header name\n         LR    R15,R6               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK\n         BE    PDSRCM$M_TRANS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?\n         BE    PDSRCM$M_TRANS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item\n         BNE   PDSRCM$M_TRANX       Nothing to report...\n*\n** Look at the output of the GETD translator call\n*\nPDSRCM$M_TRANS DS 0H\n         L     R4,PDSRCMD_COUNTDL   Number of IDRL entries in buffer\n         LTR   R4,R4                Skip empty section\n         BZ    PDSRCM$M_TRANX\n         LA    R7,IDLH_END          First record in IDL buffer\nPDSRCM$M_TRANL DS 0H\n*\n         LH    R0,=AL2(IDL_END-IDL_ENTRY) Get length of entry\n         LA    R1,C_ID_IDL_BUFFER         Locate string of entry type\n         LR    R15,R7                     Locate area to dump\n         BAS   R14,PDSRCM_DUMPE           Dump entry\n*\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?\n         BO    PDSRCM$M_TRANSZX           Yes, don't test it\n         L     R14,PDSRCMD_SAVEESD+4\n         CLC   ESD_LENG-ESD_ENTRY(4,R14),PDSRCMD_TRMSIZE\n         BNH   PDSRCM$M_TRANSZX\n         MVC   PDSRCMD_TRMSIZE(4),ESD_LENG-ESD_ENTRY(R14)\n*-Note: need to support CSECT names longer than 8 bytes!!!!\n         MVC   PDSRCMD_TRMSIZEN(8),PDSRCMD_SECTION+2\n         MVC   PDSRCMD_TRMSIZEM(8),PDSRCMD_MODNAME+2\nPDSRCM$M_TRANSZX DS 0H\n*\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1FT First one?\n         BO    PDSRCM$M_TRANLB            No, continue\n*\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1TRM\n         LA    R15,PDSRCMD_RECOUT         Restore address\n*\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Vendor CSECT?\n         BO    PDSRCM$M_TRODX                 Yes, leave\n         CLC   PDSRCMD_TRODATE(L'PDSRCMD_TRODATE),IDL_DATE_PROCESSED\n         BL    PDSRCM$M_TRODX\n         MVC   PDSRCMD_TRODATE(L'IDL_DATE_PROCESSED),IDL_DATE_PROCESSED\n         MVC   PDSRCMD_TRODATEM(8),PDSRCMD_MODNAME+2\n*-Note: need to support CSECT names longer than 8 bytes!!!!\n         MVC   PDSRCMD_TRODATEN(L'PDSRCMD_TRODATEN),PDSRCMD_SECTION+2\n         L     R14,PDSRCMD_SAVEESD+4\n         CLI   ESD_SCOPE-ESD_ENTRY(R14),C'S' $PRIVATE?\n         BNE   PDSRCM$M_TRODX                No, continue\n         LA    R15,PDSRCMD_TRODATEN\n         MVI   0(R15),C' '\n         MVC   1(L'PDSRCMD_TRODATEN-1,R15),0(R15)\n         MVC   0(6,R15),=C'$Priv#'\n         LA    R15,6(R15)\n         LH    R1,PDSRCMD_CSPRIVC\n         BAS   R14,PDSRCM_EDITFWF\n         LA    R15,PDSRCMD_RECOUT         Restore address\nPDSRCM$M_TRODX DS 0H\n         MVC   OCL_TRANDATE-OCL(4,R15),IDL_DATE_PROCESSED\n         MVI   OCL_TRANDATE+4-OCL(R15),C'.'\n         MVC   OCL_TRANDATE+5-OCL(3,R15),IDL_DATE_PROCESSED+4\n*\n         MVC   OCL_TRANID-OCL(L'OCL_TRANID,R15),IDL_PID_ID\n         MVC   OCL_TRANVER-OCL(L'OCL_TRANVER,R15),IDL_VERSION\n         MVI   OCL_TRANDOT-OCL(R15),C'.'\n         MVC   OCL_TRANMOD-OCL(L'OCL_TRANMOD,R15),IDL_MOD_LEVEL\n*\n         LM    R0,R1,PDSRCMD_MTRCXREF     Get table length & address\n         SH    R0,=AL2(CXREFL)            Subtract for last entry\nPDSRCM$M_TRANTSL DS 0H\n         CLC   TRANT_ID-TRANT(L'TRANT_ID,R1),IDL_PID_ID\n         BE    PDSRCM$M_TRANTSF\n         LA    R1,CXREFL(R1)              Bump to next one\n         SH    R0,=AL2(CXREFL)            Decrement table length\n         LTR   R0,R0\n         BZ    PDSRCM$M_TRANTSE\n         BM    PDSRCM$M_TRANTSE\n         CLC   0(2,R1),=X'FF,FF'          End of the table?\n         BNE   PDSRCM$M_TRANTSL\n         MVC   OCL_TRANNAME-OCL(8,R15),=C'*Unknown'\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Turn on flag\n         BO    PDSRCM$M_TRANTSX\n         MVC   TRANT_ID-TRANT(L'TRANT_ID,R1),IDL_PID_ID\n         MVC   TRANT_NAME-TRANT(8,R1),=C'*Unknown'\n         LA    R14,1\n         STCM  R14,B'1111',CXREF_COUNTT-CXREF(R1)\n         STCM  R14,B'1111',CXREF_COUNTL-CXREF(R1)\n         MVI   CXREF_TYPE-CXREF(R1),$CXREFT_D Set as dynamic add\n         MVC   CXREFL(2,R1),=X'FF,FF'     Set next table entry as end\n         B     PDSRCM$M_TRANTSX\nPDSRCM$M_TRANTSE DS 0H\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1TTO\n         BO    PDSRCM$M_TRANTSX\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1TTO\n         MVC   PDSRCMD_DEREC(133),PDSRCMD_RECOUT  Save record\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM99L,R15),MSGCM99-PDSRCMC(R1)\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n         MVC   PDSRCMD_RECOUT(133),PDSRCMD_DEREC  Restore record\n         LA    R15,PDSRCMD_RECOUT         Restore address\n         B     PDSRCM$M_TRANTSX\nPDSRCM$M_TRANTSF DS 0H\n         MVC   OCL_TRANNAME-OCL(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R1)\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3IVC Turn on flag\n         BO    PDSRCM$M_TRANTSX\n         ICM   R14,B'1111',CXREF_COUNTT-CXREF(R1)\n         LA    R14,1(R14)\n         STCM  R14,B'1111',CXREF_COUNTT-CXREF(R1)\n         ICM   R14,B'1111',CXREF_COUNTL-CXREF(R1)\n         LA    R14,1(R14)\n         STCM  R14,B'1111',CXREF_COUNTL-CXREF(R1)\nPDSRCM$M_TRANTSX DS 0H\n*\n         BAS   R14,PDSRCM_TRPRR     Print Report Record\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?\n         BNO   PDSRCM$M_TRANFOX     No, skip this code\n         L     R1,PDSRCMD_FOA+4     Locate FLATOUT record Area\n         LA    R1,FOM_RECORD-FOM(R1) Locate to record output\n         MVC   FORC_OCL-FOR(OCLSL-1,R1),PDSRCMD_RECOUT+1\nPDSRCM$M_TRANFOX DS 0H\n*\n         BAS   R14,PDSRCM_CLEAR_RECOUT\n\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1FT Say that we've been here\nPDSRCM$M_TRANLB DS 0H\n         A     R7,IDLH_ENTRY_LENG   Move to next IDL in this section\n         BCT   R4,PDSRCM$M_TRANL\nPDSRCM$M_TRANLBX DS 0H\n*\n** Exit from translator processing\n*\nPDSRCM$M_TRANX DS 0H\n         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line\n         LM    R4,R9,PDSRCMD_MTSREG Restore our regs\n         L     R14,PDSRCMD_MTRA     Get return address\nPDSRCM$M_TRANQO DS 0H\n         BSM   0,R14                Return to caller\n         DROP  R6,R7\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Report on Binder Identification information\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$M_BIND DS 0H\n         XC    PDSRCMD_BINDER(4),PDSRCMD_BINDER Reset binder pointer\n         ST    R14,PDSRCMD_MTRA          Save return address\n*\n         STM   R4,R9,PDSRCMD_MTSREG      Save work registers\n         LM    R6,R7,PDSRCMD_SAVEIDB     Get saved registers\n         USING IEWBIDB,R6\n         USING IDB_ENTRY,R7\n         MVC   PDSRCMD_CURSORDL(4),PDSRCM_ZEROS Set cursor\n         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDB'\n         AIF   ('&IHADFARELS' LT '01010300').MGIDB  at DFSMS/MVS 1.3?\n*-GETD/IDB for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETD,                                            C\n               VERSION=1,                                              C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDB,                                           C\n               CLASS=PDSRCMD_B_IDRB,                                   C\n               CURSOR=PDSRCMD_CURSORDL,                                C\n               COUNT=PDSRCMD_COUNTDL,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MGIDBX\n.MGIDB   ANOP  ,\n*-GETD/IDB for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=GETD,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDB,                                           C\n               CLASS=PDSRCMD_B_IDRB,                                   C\n               CURSOR=PDSRCMD_CURSORDL,                                C\n               COUNT=PDSRCMD_COUNTDL,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n.MGIDBX  ANOP  ,\n*\n         LH    R0,=AL2(IDBH_END-IDBH_START) Get length of header\n         LA    R1,C_ID_IDB_HEADER   Locate string of header name\n         LR    R15,R6               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK\n         BE    PDSRCM$M_BINDS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?\n         BE    PDSRCM$M_BINDS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item\n         BNE   PDSRCM$M_BINDX       Nothing to report...\n*\n** Look at the output of the GETD Binder call\n*\nPDSRCM$M_BINDS DS 0H\n         L     R4,PDSRCMD_COUNTDL   Number of IDRB entries in buffer\n         LTR   R4,R4                Skip empty section\n         BZ    PDSRCM$M_BINDX\n         LA    R7,IDBH_END          First record in IDB buffer\nPDSRCM$M_BINDL DS 0H\n*\n         LH    R0,=AL2(IDB_END-IDB_ENTRY)  Get length of entry\n         LA    R1,C_ID_IDB_BUFFER   Locate string of entry type\n         LR    R15,R7               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n         ST    R7,PDSRCMD_BINDER    Save IDB buffer entry pointer\n*\nPDSRCM$M_BINDLB DS 0H\n*->      A     R7,IDBH_ENTRY_LENG   Move to next IDB in this section\n*->      BCT   R4,PDSRCM$M_BINDL\nPDSRCM$M_BINDLBX DS 0H\n*\n** Exit from Binder processing\n*\nPDSRCM$M_BINDX DS 0H\n         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line\n         LM    R4,R9,PDSRCMD_MTSREG Restore our regs\n         L     R14,PDSRCMD_MTRA     Get return address\nPDSRCM$M_BINDQO DS 0H\n         DROP  R6,R7\n.IDBEX   ANOP  ,\n         BSM   0,R14                Return to caller\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Process TEXT data for this CSECT\n** - Dump CSECT\n** - Eyecatcher report\n** - Search for string (not implemented yet)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$M_TEXT DS 0H\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT Doing text processing?\n         BNO   PDSRCM$M_TEXTQO           No, quick out\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?\n         BO    PDSRCM$M_TEXTIX           No, skip this code\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3EC Eyecatcher?\n         BO    PDSRCM$M_TEXTIX           Yes, Continue\n         B     PDSRCM$M_TEXTQO           Oops, no valid options\nPDSRCM$M_TEXTIX DS 0H\n         ST    R14,PDSRCMD_MTRA          Save return address\n*\n** Get the Binder API to cough up the text for this CSECT\n*\n         STM   R4,R9,PDSRCMD_MTSREG      Save work registers\n         LM    R6,R7,PDSRCMD_SAVETXT     Get saved registers\n         USING IEWBTXT,R6\n         USING TXT_ENTRY,R7\n         MVC   PDSRCMD_CURSORDL(4),PDSRCM_ZEROS Set cursor\n         MVC   PDSRCMD_FUNC(8),=CL8'GETD-TXT'\n         AIF   ('&IHADFARELS' LT '01010300').MGTXT  at DFSMS/MVS 1.3?\n*-GETD/TXT for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETD,                                            C\n               VERSION=1,                                              C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBTXT,                                           C\n               CLASS=PDSRCMD_B_TEXT,                                   C\n               CURSOR=PDSRCMD_CURSORDL,                                C\n               COUNT=PDSRCMD_COUNTDL,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MGTXTX\n.MGTXT   ANOP  ,\n*-GETD/TXT for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=GETD,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBTXT,                                           C\n               CLASS=PDSRCMD_B_TEXT,                                   C\n               CURSOR=PDSRCMD_CURSORDL,                                C\n               COUNT=PDSRCMD_COUNTDL,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n.MGTXTX  ANOP  ,\n*\n         LH    R0,=AL2(TXTH_END-TXTH_START) Get length of header\n         LA    R1,C_ID_TXT_HEADER   Locate string of header name\n         LR    R15,R6               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK\n         BE    PDSRCM$M_TEXTS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?\n         BE    PDSRCM$M_TEXTS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item\n         BNE   PDSRCM$M_TEXTX       Nothing to report...\n*\n** Look at the output of the GETD TEXT call\n*\nPDSRCM$M_TEXTS DS 0H\n         L     R4,PDSRCMD_COUNTDL   Number of TEXT entries in buffer\n         LTR   R4,R4                Skip empty section\n         BZ    PDSRCM$M_TEXTX\n         LA    R7,TXTH_END          First record in TXT buffer\nPDSRCM$M_TEXTL DS 0H\n*\n** Eye-Catcher report processing\n**\n** We use PDSRCMM's MXREC and MXSAVE\n*\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3EC Eyecatcher?\n         BNO   PDSRCM$M_TEXTECX           No, continue\n         STM   R2,R9,PDSRCMD_MXSAVE       Save work regs\n         LA    R3,PDSRCMD_MXREC           Locate output record\n         L     R2,PDSRCMD_PDS2            Locate PDS2 area\n         LR    R9,R7                      Get CSECT start\n         L     R8,PDSRCMD_SAVEESD+4\n         L     R8,ESD_LENG-ESD_ENTRY(R8)\n         LA    R0,PDSRCMD_SECTION+2       Locate CSECT name\n         L     R1,PDSRCMD_SUBRSAP         Locate SUBRSA\n*\n*-R0=CSECT R1=SUBRSA R2=PDS2 R3=Output R8=Module Length R9=Module start\n         L     R15,=V(PDSR$EC)            Locate routine\n         BASR  R14,R15                    Call Eyecatcher routine\n*\n         L     R1,PDSRCMD_SUBRSAP         Locate to area\n         LA    R1,ECRPT-SUBRSA(R1)\n         PUT   (1),PDSRCMD_MXREC          Put out record\n         LM    R2,R9,PDSRCMD_MXSAVE       Rest work regs\nPDSRCM$M_TEXTECX DS 0H  . . . . . . . . . . . . . . . . . . . . .\n*\n** Get the first 256 bytes of the CSECT into the FLATOUT record\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO Flatout processing?\n         BNO   PDSRCM$M_TEXTFX        No, skip this code\n         L     R1,PDSRCMD_FOA+4        Locate FLATOUT record Area\n         LA    R1,FOM_RECORD-FOM(R1)    Locate to record output\n         XC    FORC_CSECT256-FOR(256,R1),FORC_CSECT256-FOR(R1)\n         L     R14,PDSRCMD_SAVEESD+4       Locate Binder area\n         L     R14,ESD_LENG-ESD_ENTRY(R14)  Get length of CSECT\n         C     R14,=F'256'                   Under our minimum?\n         BNH   PDSRCM$M_TEXTFS                Yes, continue\n         LA    R14,256                         No, set max length\nPDSRCM$M_TEXTFS DS 0H                           Ready for move\n         BCTR  R14,0                             Decrement for EX\n         EX    R14,PDSRCM$M_TEXTFM                Move up to first 256\n         B     PDSRCM$M_TEXTFX                     Continue\nPDSRCM$M_TEXTFM MVC FORC_CSECT256-FOR(0,R1),0(R7)   Executed\nPDSRCM$M_TEXTFX DS 0H\n*\n** Exit from Text processing\n*\nPDSRCM$M_TEXTX DS 0H\n         LM    R4,R9,PDSRCMD_MTSREG Restore our regs\n         L     R14,PDSRCMD_MTRA     Get return address\nPDSRCM$M_TEXTQO DS 0H\n         BSM   0,R14                Return to caller\n         DROP  R6,R7\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** CSECT history report for User records\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$M_HISTU DS 0H\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST\n         BNO   PDSRCM$M_HISTUQO\n         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1HIM\n         ST    R14,PDSRCMD_MHIA          Save return address\n*\n         BAS   R14,PDSRCM_MFCS           Format common report section\n*\n         STM   R4,R7,PDSRCMD_MHSREG      Save work registers\n         LM    R6,R7,PDSRCMD_SAVEIDU     Get saved registers\n         USING IEWBIDU,R6\n         USING IDU_ENTRY,R7\n         MVC   PDSRCMD_CURSORDU(4),PDSRCM_ZEROS Set cursor\n         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDU'\n         AIF   ('&IHADFARELS' LT '01010300').MGIDU  at DFSMS/MVS 1.3?\n*-GETD/IDU for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETD,                                            C\n               VERSION=1,                                              C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDU,                                           C\n               CLASS=PDSRCMD_B_IDRU,                                   C\n               CURSOR=PDSRCMD_CURSORDU,                                C\n               COUNT=PDSRCMD_COUNTDU,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MGIDUX\n.MGIDU   ANOP  ,\n*-GETD/IDU for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETD,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDU,                                           C\n               CLASS=PDSRCMD_B_IDRU,                                   C\n               CURSOR=PDSRCMD_CURSORDU,                                C\n               COUNT=PDSRCMD_COUNTDU,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n.MGIDUX  ANOP  ,\n*\n         LH    R0,=AL2(IDUH_END-IDUH_START) Get length of header\n         LA    R1,C_ID_IDU_HEADER   Locate string of header name\n         LR    R15,R6               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK\n         BE    PDSRCM$M_HISTUS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING Last buffer?\n         BE    PDSRCM$M_HISTUS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_ERROR No data for item\n         BNE   PDSRCM$M_HISTUX      Nothing to report...\n*\n** Look at the output of the GETD IDR User call\n*\nPDSRCM$M_HISTUS DS 0H\n         L     R4,PDSRCMD_COUNTDU   Number of IDRU entries in buffer\n         LTR   R4,R4                Skip empty section\n         BZ    PDSRCM$M_HISTUX\n         LA    R7,IDUH_END          First record in IDU buffer\nPDSRCM$M_HISTUL DS 0H\n         L     R1,PDSRCMD_MHCOUNTU  Get total count\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_MHCOUNTU  Save total count\n*\n         LH    R0,=AL2(IDU_END-IDU_ENTRY)  Get length of entry\n         LA    R1,C_ID_IDU_BUFFER   Locate string of entry type\n         LR    R15,R7               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1HIM\n         LA    R15,PDSRCMD_RECOUT   Restore address\n         MVC   OCL_HISTDATE-OCL(4,R15),IDU_CREATE_DATE\n         MVI   OCL_HISTDATE+4-OCL(R15),C'.'\n         MVC   OCL_HISTDATE+5-OCL(3,R15),IDU_CREATE_DATE+4\n         MVC   OCL_HISTDATA-OCL(3,R15),=C'ID:'\n#IDU_HISTDATA EQU 27-5\n         LH    R1,IDU_DATA_CHARS    Get number of good bytes\n         CH    R1,=AL2(#IDU_HISTDATA)\n         BL    PDSRCM$M_HISTULHDM\n         LA    R1,#IDU_HISTDATA\nPDSRCM$M_HISTULHDM DS 0H\n         BCTR  R1,0\n         EX    R1,PDSRCM$M_HISTUDM  Move data to line\n*-Added for CA-Endevor which puts non-human readable stuff in IDRU\n         L     R14,=V(PDSR$C2)      Locate constants CSECT\n         EX    R1,PDSRCM$M_HISTUDT  Translate data (just in case)\n*\n         BAS   R14,PDSRCM_HIPRR     Print Report Record\n         BAS   R14,PDSRCM_CLEAR_RECOUT\n\nPDSRCM$M_HISTULB DS 0H\n         A     R7,IDUH_ENTRY_LENG   Move to next IDU in this section\n         BCT   R4,PDSRCM$M_HISTUL\n*\n** Exit from History processing\n*\nPDSRCM$M_HISTUX DS 0H\n         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line\n         LM    R4,R7,PDSRCMD_MHSREG Restore our regs\n         L     R14,PDSRCMD_MHIA     Get return address\nPDSRCM$M_HISTUQO DS 0H\n         BSM   0,R14                Return to caller\n*\nPDSRCM$M_HISTUDM MVC   OCL_HISTDATA+4-OCL(0,R15),IDU_DATA\nPDSRCM$M_HISTUDT TR    OCL_HISTDATA+4-OCL(0,R15),C_TRTABA-PDSR$C2(R14)\n         DROP  R6,R7\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** CSECT history report for Zap records\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$M_HISTZ DS 0H\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST\n         BNO   PDSRCM$M_HISTZQO\n         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1HIM\n         ST    R14,PDSRCMD_MHIA          Save return address\n*\n         BAS   R14,PDSRCM_MFCS           Format common report section\n*\n         STM   R4,R7,PDSRCMD_MHSREG      Save work registers\n         LM    R6,R7,PDSRCMD_SAVEIDZ     Get saved registers\n         USING IEWBIDZ,R6\n         USING IDZ_ENTRY,R7\n         MVC   PDSRCMD_CURSORDU(4),PDSRCM_ZEROS Set cursor\n         MVC   PDSRCMD_FUNC(8),=CL8'GETD-IDZ'\n         AIF   ('&IHADFARELS' LT '01010300').MGIDZ  at DFSMS/MVS 1.3?\n*-GETD/IDZ for DFSMS/MVS 1.3 and higher\n         IEWBIND FUNC=GETD,                                            C\n               VERSION=1,                                              C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDZ,                                           C\n               CLASS=PDSRCMD_B_IDRZ,                                   C\n               CURSOR=PDSRCMD_CURSORDU,                                C\n               COUNT=PDSRCMD_COUNTDU,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n         AGO   .MGIDZX\n.MGIDZ   ANOP  ,\n*-GETD/IDZ for DFSMS/MVS 1.1 and 1.2\n         IEWBIND FUNC=GETD,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               WORKMOD=PDSRCMD_WKTOKEN,                                C\n               SECTION=PDSRCMD_SECTION,                                C\n               AREA=IEWBIDZ,                                           C\n               CLASS=PDSRCMD_B_IDRZ,                                   C\n               CURSOR=PDSRCMD_CURSORDU,                                C\n               COUNT=PDSRCMD_COUNTDU,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\n.MGIDZX  ANOP  ,\n*\n         LH    R0,=AL2(IDZH_END-IDZH_START) Get length of header\n         LA    R1,C_ID_IDZ_HEADER   Locate string of header name\n         LR    R15,R6               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK\n         BE    PDSRCM$M_HISTZS\n         CLC   PDSRCMD_RETCODE(4),C_IEWB_RC_WARNING\n         BNE   PDSRCM$M_HISTZE\n*\n** Look at the output of the GETD IDZ call\n*\nPDSRCM$M_HISTZS DS 0H\n         L     R4,PDSRCMD_COUNTDU   Number of IDRZ entries in buffer\n         LTR   R4,R4                Skip empty section\n         BZ    PDSRCM$M_HISTZX\n         LA    R7,IDZH_END          First record in IDZ buffer\nPDSRCM$M_HISTZL DS 0H\n         L     R1,PDSRCMD_MHCOUNTZ  Get total count\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_MHCOUNTZ  Save total count\n*\n         L     R1,PDSRCMD_MZAPCNT   Get total count\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_MZAPCNT   Save total count\n*\n         LH    R0,=AL2(IDZ_END-IDZ_ENTRY)  Get length of entry\n         LA    R1,C_ID_IDZ_BUFFER   Locate string of entry type\n         LR    R15,R7               Locate area to dump\n         BAS   R14,PDSRCM_DUMPE     Dump entry\n*\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1HIM\n         LA    R15,PDSRCMD_RECOUT   Restore address\n         MVC   OCL_HISTDATE-OCL(4,R15),IDZ_DATE\n         MVI   OCL_HISTDATE+4-OCL(R15),C'.'\n         MVC   OCL_HISTDATE+5-OCL(3,R15),IDZ_DATE+4\n         MVC   OCL_HISTDATA-OCL(4,R15),=C'Zap:'\n         MVC   OCL_HISTDATA+5-OCL(L'IDZ_ZAP_DATA,R15),IDZ_ZAP_DATA\n*\n         BAS   R14,PDSRCM_HIPRR     Print Report Record\n         BAS   R14,PDSRCM_CLEAR_RECOUT\n\nPDSRCM$M_HISTZLB DS 0H\n         A     R7,IDZH_ENTRY_LENG   Move to next IDZ in this section\n         BCT   R4,PDSRCM$M_HISTZL\n         B     PDSRCM$M_HISTZX\n*\n** Error in History processing\n** Not seen in real life - added: 27MAR1998\n*\nPDSRCM$M_HISTZE DS 0H\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format message\n         MVC   0(MSGCM19L,R15),MSGCM19-PDSRCMC(R1) Get text\n         MVC   MSGCM19L(8,R15),PDSRCMD_MODNAME+2  Get member name\n         LA    R15,MSGCM19L+8(R15)\n         MVC   0(5,R15),=C'- RC='\n         LA    R15,5(R15)\n         L     R1,PDSRCMD_RETCODE\n         BAS   R14,PDSRCM_EDITFWF        Edit it\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n** Exit from History processing\n*\nPDSRCM$M_HISTZX DS 0H\n         LA    R15,PDSRCMD_RECOUT   Restore R15 to output line\n         LM    R4,R7,PDSRCMD_MHSREG Restore our regs\n         L     R14,PDSRCMD_MHIA     Get return address\nPDSRCM$M_HISTZQO DS 0H\n         BSM   0,R14                Return to caller\n*\n         DROP  R6,R7\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Library Start - Initialize for new library\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$S DS    0H\n         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2MEM   Turn off flag\n         MVI   PDSRCMD_TRPRRLC,99                   Reset heading\n         XC    PDSRCMD_TRMSIZE(4),PDSRCMD_TRMSIZE   Clear size\n         MVC   PDSRCMD_TRODATE(7),=X'FF,FF,FF,FF,FF,FF,FF'\n         MVI   PDSRCMD_HIPRRLC,99                   Reset heading\n         XC    PDSRCMD_MHCOUNTU(4),PDSRCMD_MHCOUNTU\n         XC    PDSRCMD_MHCOUNTZ(4),PDSRCMD_MHCOUNTZ\n         XC    PDSRCMD_CSECTS(4),PDSRCMD_CSECTS\n*\n         L     R1,PDSRCMD_LIBC           Get library count\n         LA    R1,1(R1)                  Increment by 1\n         ST    R1,PDSRCMD_LIBC           Save count\n*\n** Flatout processing\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO    Flatout processing?\n         BNO   PDSRCM$S_FOX                     No, skip this code\n         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area\n         LA    R1,FOM_RECORD-FOM(R1) Locate to record output\n         MVI   FOR_TYPE-FOR(R1),$FORTYPE_D  Set type: DSN\n         MVI   FOR_SPACE1-FOR(R1),C' '\n         MVI   FOR_SPACE2-FOR(R1),C' '\n         LA    R15,FOR_LIBN-FOR(R1)      Locate library num output\n         MVI   0(R15),C' '               Get blank\n         MVC   1(L'FOR_LIBN-1,R15),0(R15) Propagate blanks.\n         L     R1,PDSRCMD_LIBC           Get library count\n         BAS   R14,PDSRCM_EDITFWF        Edit it\n*\n         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area\n         LA    R1,FOM_RECORD-FOM(R1)     Locate to record output\n         L     R14,PDSRCMD_VOLSER        Get address of volser\n         MVC   FORD_VOL-FOR(6,R1),0(R14) Insert volser\n         MVI   FORD_SPACE1-FOR(R1),C' '  Ensure space in right place\n         L     R14,PDSRCMD_DSNAME        Locate dataset name\n         MVC   FORD_DSN-FOR(44,R1),0(R14) Insert dataset name\n         LA    R15,FORD_DSN-FOR(R1)      Locate to start of DSN\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area\n         LA    R1,FOM_RDW-FOM(R1)        Locate to record output\n         SR    R15,R1                    Length = end - start\n         STH   R15,0(R1)                 Save length of variable record\n         LR    R0,R1                     Get record loc to rite reg\n         PUT   PDSRCMD_DCBF,(0)          Output record...\nPDSRCM$S_FOX DS 0H\n*\n** Print SMS information about this dataset\n*\n#SMSDAL  EQU   30                        Length of each sms_data area\n#SMSDN   EQU   3                         Number of sms_data areas\n#SMSDL   EQU   #SMSDAL*#SMSDN            Total length of areas\n*\n         AIF   ('&IHADFARELS' LT '01010300').SASMSX at DFSMS/MVS 1.3?\n         CLC   PDSRCMD_DFARELS(4),=X'01010300' Lower than v1.3?\n         BL    PDSRCM$S_ASMSX            Yes, don't bother\n         ICM   R15,B'1111',PDSRCMD_IGWASMS\n         BZ    PDSRCM$S_ASMSX            Yes, don't bother\n*\n         L     R1,PDSRCMD_DSNAME         Locate dataset name\n         SLR   R14,R14                   Clear length counter\n         LA    R0,44                     Set max length of dsname\nPDSRCM$S_ASMS_DSL DS 0H\n         CLI   0(R1),C' '                Hit the end yet?\n         BE    PDSRCM$S_ASMS_DSX         Yes, leave\n         LA    R1,1(R1)                  No, bump to next byte\n         LA    R14,1(R14)                ..increment counter\n         BCT   R0,PDSRCM$S_ASMS_DSL      ..and process next byte\nPDSRCM$S_ASMS_DSX DS 0H\n         ST    R14,PDSRCMD_COUNTDL       Save dsname length\n*\n         MVC   PDSRCMD_FUNC(8),=CL8'IGWASMS'  Set for debugging\n         LA    R1,PDSRCMD_PARMLIST       Locate parameter list\n         LA    R14,PDSRCMD_RETCODE       Locate return_code\n         XC    0(4,R14),0(R14)\n         ST    R14,0(R1)\n         LA    R14,PDSRCMD_RSNCODE       Locate reason_code\n         XC    0(4,R14),0(R14)\n         ST    R14,4(R1)\n         LA    R14,PDSRCMD_COUNTN        Locate prob_det\n         XC    0(8,R14),0(R14)\n         ST    R14,8(R1)\n         LA    R14,PDSRCMD_COUNTDL       Locate dsname_length\n         ST    R14,12(R1)\n         L     R14,PDSRCMD_DSNAME        Locate dsname\n         ST    R14,16(R1)\n         LA    R14,PDSRCMD_SECTION       Locate sms_data\n         XC    0(#SMSDL,R14),0(R14)\n         ST    R14,20(R1)\n         LA    R14,PDSRCMD_COUNTDE       Locate ds_type\n         ST    R14,24(R1)\n         BASSM R14,R15\n*\n         ICM   R15,B'1111',PDSRCMD_RETCODE Get return code\n         BZ    PDSRCM$S_ASMSOK\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM16L,R15),MSGCM16    Move in message text\n         LA    R15,MSGCM16L(R15)\n         L     R1,PDSRCMD_RETCODE\n         BAS   R14,PDSRCM_EDITFWF\n         MVC   1(6,R15),=C', RSN='\n         LA    R15,1+6(R15)\n         L     R1,PDSRCMD_RETCODE\n         BAS   R14,PDSRCM_EDITFWF\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n         B     PDSRCM$S_ASMSX\nPDSRCM$S_ASMSOK DS 0H\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Binder Debug Mode?\n         BO    PDSRCM$S_ASMSM15           Yes, be verbose\n*-If it makes sense to issue the SMS information, message, do it\n         CLC   PDSRCMD_COUNTDE(4),PDSRCM_ZEROS DSTYPE filled in?\n         BNE   PDSRCM$S_ASMSM15           Yes, let's print MSG15\n         LA    R8,PDSRCMD_SECTION         Locate to area\n         CLI   0(R8),C' '                 SMS info?\n         BNE   PDSRCM$S_ASMSM15           Yes, let's print MSG15\n         LA    R8,#SMSDAL(R8)             Locate to Management clas\n         CLI   0(R8),C' '                 SMS info?\n         BNE   PDSRCM$S_ASMSM15           Yes, let's print MSG15\n         LA    R8,#SMSDAL(R8)             Locate to data class\n         CLI   0(R8),C' '                 SMS info?\n         BE    PDSRCM$S_ASMSX             No, nothing: leave\nPDSRCM$S_ASMSM15 DS 0H\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM15L,R15),MSGCM15    Move in message text\n         LA    R15,MSGCM15L(R15)\n         CLC   PDSRCMD_COUNTDE(4),PDSRCM_ZEROS Regular PDS?\n         BE    PDSRCM$S_DST_PDS\n         CLI   PDSRCMD_COUNTDE+3,1        PDS/E?\n         BE    PDSRCM$S_DST_PDSE\n         CLI   PDSRCMD_COUNTDE+3,2        HFS?\n         BE    PDSRCM$S_DST_HFS\n         UNPK  0(9,R15),PDSRCMD_COUNTDE(5)\n         MVZ   0(8,R15),PDSRCM_ZEROS\n         TR    0(8,R15),PDSRCM_HEXTABLE\n         LA    R15,8(R15)\n         B     PDSRCM$S_DSTX\nPDSRCM$S_DST_HFS DS 0H\n         MVC   0(3,R15),=C'HFS'\n         LA    R15,3(R15)\n         B     PDSRCM$S_DSTX\nPDSRCM$S_DST_PDSE DS 0H\n         MVC   0(4,R15),=C'PDSE'\n         LA    R15,4(R15)\n         B     PDSRCM$S_DSTX\nPDSRCM$S_DST_PDS DS 0H\n         MVC   0(3,R15),=C'PDSE'\n         LA    R15,3(R15)\nPDSRCM$S_DSTX  DS 0H\n         LA    R8,PDSRCMD_SECTION         Locate to area\n         MVC   0(13,R15),=C', STOR-Class='\n         LA    R15,13(R15)\n         CLI   0(R8),C' '\n         BE    PDSRCM$S_SCB\n         MVC   0(#SMSDAL,R15),0(R8)\n         LA    R0,#SMSDAL\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         B     PDSRCM$S_SCX\nPDSRCM$S_SCB   DS 0H\n         MVI   0(R15),C'*'\n         LA    R15,1(R15)\nPDSRCM$S_SCX   DS 0H\n*\n         LA    R8,#SMSDAL(R8)             Locate to Management class\n         MVC   0(13,R15),=C', MGMT-Class='\n         LA    R15,13(R15)\n         CLI   0(R8),C' '\n         BE    PDSRCM$S_MCB\n         MVC   0(#SMSDAL,R15),0(R8)\n         LA    R0,#SMSDAL\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         B     PDSRCM$S_MCX\nPDSRCM$S_MCB   DS 0H\n         MVI   0(R15),C'*'\n         LA    R15,1(R15)\nPDSRCM$S_MCX   DS 0H\n*\n         LA    R8,#SMSDAL(R8)               Locate to Data class\n         MVC   0(13,R15),=C', Data-Class='\n         LA    R15,13(R15)\n         CLI   0(R8),C' '\n         BE    PDSRCM$S_DCB\n         MVC   0(#SMSDAL,R15),0(R8)\n         LA    R0,#SMSDAL\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         B     PDSRCM$S_DCX\nPDSRCM$S_DCB   DS 0H\n         MVI   0(R15),C'*'\n         LA    R15,1(R15)\nPDSRCM$S_DCX   DS 0H\n*\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$S_ASMSX DS 0H\n.SASMSX  ANOP  ,\n*\n** Common exit from $Library_Start processing\n*\n         SLR   R15,R15\n         B     PDSRCM$X\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Library End - print ending statistics if needed\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$E DS    0H\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MEM Do anything?\n         BNO   PDSRCM$E_X\n*\n** Print Translator stats for library we just processed\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?\n         BNO   PDSRCM$E_TRX               Nope, leave\n*\n         LM    R2,R3,PDSRCMD_MTRCXREF     Get table length & address\n         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1THR\n         SLR   R4,R4                      Clear total\nPDSRCM$E_TRL DS 0H\n         CLC   CXREF_COUNTL-CXREF(4,R3),PDSRCM_ZEROS Found any?\n         BE    PDSRCM$E_TRLB              No, skip print\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR Print heading?\n         BO    PDSRCM$E_TRLHX\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR We printed the heading\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM7L,R15),MSGCM7-PDSRCMC(R1) Get text\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$E_TRLHX DS 0H\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM8L,R15),MSGCM8      Move in message text\n         MVC   MSGCM8I-MSGCM8(L'TRANT_ID,R15),TRANT_ID-TRANT(R3)\n         MVC   MSGCM8N-MSGCM8(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R3)\n         LA    R15,MSGCM8L(R15)           Bump past message\n         ICM   R1,B'1111',CXREF_COUNTL-CXREF(R3) Get count\n         AR    R4,R1                      Update total\n         CVD   R1,PDSRCMD_DOUBLE\n         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'\n         ED    0(12,R15),PDSRCMD_DOUBLE+3\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n         LA    R1,0\n         STCM  R1,B'1111',CXREF_COUNTL-CXREF(R3) Get count\nPDSRCM$E_TRLB DS 0H\n         LA    R3,CXREFL(R3)              Bump to next one\n         SH    R2,=AL2(CXREFL)            Decrement table length\n         LTR   R2,R2\n         BZ    PDSRCM$E_TRLX\n         BM    PDSRCM$E_TRLX\n         CLC   0(2,R3),=X'FF,FF'          End of the table?\n         BNE   PDSRCM$E_TRL\nPDSRCM$E_TRLX DS 0H\n*-Print divider line\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(L'MSGCM8,R15),MSGCM8     Move in \"C08I  \"\n         LA    R14,MSGCM8S+2-MSGCM8(R15)  Locate to overright area\n         MVI   0(R14),C'-'                Get dash\n         MVC   1(MSGCM8SL-2+12-1,R14),0(R14) Propagate dashes\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*-Print totals line\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(L'MSGCM8,R15),MSGCM8     Move in \"C08I  \"\n         MVC   MSGCM8S+2-MSGCM8(L'MSGCM8A,R15),MSGCM8A\n         LA    R15,MSGCM8L(R15)           Bump past message\n         LR    R1,R4                      Update total\n         CVD   R1,PDSRCMD_DOUBLE\n         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'\n         ED    0(12,R15),PDSRCMD_DOUBLE+3\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear output record\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n         L     R14,PDSRCMD_PSRAREA        Locate to area\n         TM    PPC_FLAG5-PSRAREA(R14),$PPC_F5IVCSECTS Full ignore?\n         BNO   PDSRCM$E_TRLIX             None, continue\n         LA    R0,#IVC_PDST\n         L     R1,PDSRCMD_SUBRSAP         Locate SUBRSA\n         L     R15,=V(PDSR$IVC)\n         BASR  R14,R15\nPDSRCM$E_TRLIX DS 0H\n*\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM13L,R15),MSGCM13-PDSRCMC(R1) Get text\n         LA    R15,MSGCM13L(R15)          Locate to overright area\n*        UNPK  0(9,R15),PDSRCMD_TRMSIZE(5)\n*        MVZ   0(8,R15),PDSRCM_ZEROS\n*        TR    0(8,R15),PDSRCM_HEXTABLE\n*        MVI   8(R15),C' '\n*        LA    R15,9(R15)\n*        MVI   0(R15),C'('\n*        LA    R15,1(R15)\n         L     R1,PDSRCMD_TRMSIZE         Get it\n         BAS   R14,PDSRCM_EDITNCF         and print it\n         MVC   1(12,R15),=C'bytes, name='\n         LA    R15,13(R15)\n*-Note: need to support CSECT names longer than 8 bytes!!!!\n         MVC   0(8,R15),PDSRCMD_TRMSIZEN  Get name\n         LA    R0,8\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         MVC   0(9,R15),=C', member='\n         LA    R15,9(R15)\n         MVC   0(8,R15),PDSRCMD_TRMSIZEM  Get name\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM14L,R15),MSGCM14-PDSRCMC(R1) Get text\n         LA    R15,MSGCM14L(R15)          Locate to overright area\n         MVC   0(4,R15),PDSRCMD_TRODATE   YYYY\n         MVI   4(R15),C'.'                    .\n         MVC   5(3,R15),PDSRCMD_TRODATE+4      DDD\n         LA    R15,4+1+3(R15)\n         MVC   0(7,R15),=C', name='\n         LA    R15,7(R15)\n*-Note: need to support CSECT names longer than 10 bytes!!!\n         MVC   0(L'PDSRCMD_TRODATEN,R15),PDSRCMD_TRODATEN  Get name\n         LA    R0,L'PDSRCMD_TRODATEN\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         MVC   0(9,R15),=C', member='\n         LA    R15,9(R15)\n         MVC   0(8,R15),PDSRCMD_TRODATEM  Get name\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$E_TRX DS 0H\n*\n** Print History stats for the library we just processed\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?\n         BNO   PDSRCM$E_HIX               Nope, leave\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM9L,R15),MSGCM9-PDSRCMC(R1)\n         LA    R15,MSGCM9L+1(R15)         Bump past it\n         L     R1,PDSRCMD_MHCOUNTU        Get count\n         BAS   R14,PDSRCM_EDITFWF         Edit it\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM10L,R15),MSGCM10-PDSRCMC(R1)\n         LA    R15,MSGCM10L+1(R15)        Bump past it\n         L     R1,PDSRCMD_MHCOUNTZ        Get count\n         BAS   R14,PDSRCM_EDITFWF         Edit it\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$E_HIX DS 0H\n*\n** Common exit from $Library_End processing\n*\n         NI    PDSRCMD_IFLAG2,255-$PDSRCMD_IF2MEM\nPDSRCM$E_X DS 0H\n         SLR   R15,R15\n         B     PDSRCM$X\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Initialization (called only once)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$I DS    0H\n         MVC   4(4,R13),=C'F1SA'          Set up Register Save Area\n         MVC   PDSRCMD_MXSAVE+4(4),=C'F1SA'      Set up RSA\n         MVC   PDSRCMD_ID(8),=CL8'PDSRCMD'       ID for dumps\n         MVC   PDSRCMD_IFLAG(4),=C'IFLG'         Set for dumps\n         MVC   PDSRCMD_WKTOKENI(8),=CL8' WTOKEN='\n         MVC   PDSRCMD_DTOKENI(8),=CL8' DTOKEN='\n         MVC   PDSRCMD_RETCODEI(4),=CL4' RC='\n         MVC   PDSRCMD_RSNCODEI(4),=CL4'RSN='\n*\n** Set the class names based on the DFSMS level\n**\n** Note: I've seen DFSMS 1.2 work with all but B_IDRB but let's\n**       use the older names for 1.2.\n*\n         CLC   PDSRCMD_DFARELS(4),=X'01010300' Lower than v1.3?\n         BL    PDSRCM$I_CLASSL           Yes, use older names\n         MVC   PDSRCMD_B_ESD(7),B_ESD\n         MVC   PDSRCMD_B_IDRL(8),B_IDRL\n         MVC   PDSRCMD_B_IDRU(8),B_IDRU\n         MVC   PDSRCMD_B_IDRZ(8),B_IDRZ\n         MVC   PDSRCMD_B_IDRB(8),B_IDRB\n         MVC   PDSRCMD_B_TEXT(8),B_TEXT\n         B     PDSRCM$I_CLASSX\nPDSRCM$I_CLASSL DS 0H\n         MVC   PDSRCMD_B_ESD(6),B@ESD\n         MVC   PDSRCMD_B_IDRL(7),B@IDRL\n         MVC   PDSRCMD_B_IDRU(7),B@IDRU\n         MVC   PDSRCMD_B_IDRZ(7),B@IDRZ\n         MVC   PDSRCMD_B_IDRB(7),B@IDRB\n         MVC   PDSRCMD_B_TEXT(7),B@TEXT\nPDSRCM$I_CLASSX DS 0H\n*\n** Load the IGWASMS program into storage\n*\n         AIF   ('&IHADFARELS' LT '01010300').IASMSX at DFSMS/MVS 1.3?\n         CLC   PDSRCMD_DFARELS(4),=X'01010300' Lower than v1.3?\n         BL    PDSRCM$I_ASMSX            Yes, don't bother\n         LOAD  EPLOC==CL8'IGWASMS',ERRET=PDSRCM$I_ASMSX\n         ST    R0,PDSRCMD_IGWASMS\nPDSRCM$I_ASMSX DS 0H\n.IASMSX  ANOP  ,\n* - - - - - - - - - - - - - - - - - - - - WORKDS fields enabled\n         L     R9,PDSRCMD_PSRAREA         Locate to area\n         USING PSRAREA,R9                 Enable field access\n*\n** Eyecatcher\n*\n         TM    PPC_FLAG3,$PPC_F3ECRPT          ECRPT?\n         BNO   PDSRCM$I_ECX                    Yes,...\n         OI    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT   Need text processing\n         OI    PDSRCMD_IFLAG3,$PDSRCMD_IF3EC   Turn on ECRPT flag\nPDSRCM$I_ECX DS 0H\n*\n** Set options based on DA$PDSRC\n*\n         TM    PPC_FLAG4,$PPC_F4TSOVIEW   TSO viewing?\n         BNO   PDSRCM$I_TVX\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2TSOV\nPDSRCM$I_TVX DS 0H\n*\n** Open the FLATOUT file if option is set\n**\n*\n         TM    PPC_FLAG4,$PPC_F4FLATOUT   //FLATOUT processing?\n         BNO   PDSRCM$I_FOX               No, leave\n*\n         TM    PPC_FLAG4,$PPC_F4TRANR     Did user specify TRANRPT?\n         BO    PDSRCM$I_FOTX\n         OI    PDSRCMD_IFLAG3,$PDSRCMD_IF3STR  Simulate TRANRPT...\n         OI    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN   Doing Translator report\nPDSRCM$I_FOTX DS 0H\n*\n         LA    R0,#FLATOUT_Open           Invocation: record\n         LA    R1,PDSRCMD_SUBRSA          Locate subroutine RSA\n         L     R15,=V(PDSRCMFM)           Locate CSECT\n         BASR  R14,R15                    Invoke the flatout routine\nPDSRCM$I_FOX   DS 0H\n* - - - - - - - - - - - - - - - - - - - - WORKDS fields disabled\n         DROP  R9\n*\n** Temp code: determine whether we use DCB or name method\n*\n         DEVTYPE =CL8'USEDCB',PDSRCMD_DOUBLE Get file information\n         LTR   R15,R15                    Is it allocated?\n         BNZ   I$USEDCBX                  No, continue\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2UDCB\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM98L,R15),MSGCM98-PDSRCMC(R1) Get message text\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nI$USEDCBX DS   0H\n*\n** Check for option to do \"Message Exit Debugging\"\n*\n         DEVTYPE =CL8'BINDERMD',PDSRCMD_DOUBLE Get DD allocation info\n         LTR   R15,R15                    Is FILE=BINDERMD allocated?\n         BNZ   PDSRCM$I_MXDBX             No, leave\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB\nPDSRCM$I_MXDBX DS 0H\n*\n** Fix message exit parameters\n*\n         MVC   PDSRCMD_MESSAGE(4),=V(PDSRCMM) Set msgexit routine addr\n         ST    R13,PDSRCMD_MESSAGE+4      Save work area address\n         LA    R8,=F'4'                   Default: RC=4 or higher\n         DEVTYPE =CL8'BINDERDB',PDSRCMD_DOUBLE Get DD allocation info\n         LTR   R15,R15                    Is FILE=BINDERDB allocated?\n         BNZ   PDSRCM$I_BDBX              No, leave\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB\n         LA    R8,=F'0'                   Yes, set to print all msgs\nPDSRCM$I_BDBX DS 0H\n         ST    R8,PDSRCMD_MESSAGE+8\n*\n         MVC   PDSRCMD_EXITLIST(CEXITLL),CEXITL\n         LA    R1,PDSRCMD_MESSAGE\n         ST    R1,PDSRCMD_EXITLIST+(CEXITLA-CEXITL)\n*\n** Initialize for NAME access\n*\n         IEWBUFF FUNC=GETBUF,TYPE=NAME\n         LR    R14,R8                     To: Address\n         L     R15,BNLI_BUFFER_LENG       To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n*\n         IEWBUFF FUNC=INITBUF,TYPE=NAME\n         STM   R8,R9,PDSRCMD_SAVEBNL      save regs\n         DROP  R8,R9\n*\n** Initialize for ESD access\n*\n         IEWBUFF FUNC=GETBUF,TYPE=ESD\n         LR    R14,R6                     To: Address\n         L     R15,ESDI_BUFFER_LENG       To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         IEWBUFF FUNC=INITBUF,TYPE=ESD\n         STM   R6,R7,PDSRCMD_SAVEESD      save regs\n         DROP  R6,R7\n*\n** Initialize for IDRB (Binder Indentifcation)\n*\n         IEWBUFF FUNC=GETBUF,TYPE=IDRB\n         LR    R14,R6                     To: Address\n         L     R15,IDBI_BUFFER_LENG       To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         IEWBUFF FUNC=INITBUF,TYPE=IDRB\n         STM   R6,R7,PDSRCMD_SAVEIDB      Save regs\n         DROP  R6,R7\n*\n** Initialize for TEXT processing\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT\n         BNO   PDSRCM$I_TXTX\n         IEWBUFF FUNC=GETBUF,TYPE=TEXT\n         LR    R14,R6                     To: Address\n         L     R15,TXTI_BUFFER_LENG       To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         IEWBUFF FUNC=INITBUF,TYPE=TEXT\n         STM   R6,R7,PDSRCMD_SAVETXT      Save regs\n         DROP  R6,R7\nPDSRCM$I_TXTX DS 0H\n*\n** Initialize for IDRL (Translator) report\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?\n         BNO   PDSRCM$I_TRX               No, continue\n         IEWBUFF FUNC=GETBUF,TYPE=IDRL\n         LR    R14,R6                     To: Address\n         L     R15,IDLI_BUFFER_LENG       To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         IEWBUFF FUNC=INITBUF,TYPE=IDRL\n         STM   R6,R7,PDSRCMD_SAVEIDL      Save regs\n         DROP  R6,R7\n*\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3STR   Simulate TRANRPT?\n         BO    PDSRCM$I_TROX              Yes, skip open\n         LA    R3,PDSRCMD_DCBT            Locate DCB\n         MVC   0(PDSRCMCDL,R3),PDSRCMCD   Copy in DCB constant\n         L     R1,=V(PDSR$C1)\n         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_TRANRPT-PDSR$C1(R1)\n         MVC   PDSRCMD_PARMLIST(PDSRCMLOL),PDSRCMLO\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PDSRCMD_PARMLIST)\nPDSRCM$I_TROX DS 0H\n*\n         MVI   PDSRCMD_TRPRRLC,99         Start on a new page\n         XC    PDSRCMD_TRPRRPC(4),PDSRCMD_TRPRRPC  Set page count\n*\n#CXREFN  EQU   T_TRANN+1024               Total number to get\n#CXREFL  EQU   #CXREFN*CXREFL             Length to grab\n         L     R0,=AL4(#CXREFL)           Get length to obtain\n         GETMAIN RU,LV=(0)                Get storage\n         STM   R0,R1,PDSRCMD_MTRCXREF     Save table length & address\n         LR    R14,R1                     To: Address\n         LR    R15,R0                     To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n*\n         L     R1,PDSRCMD_MTRCXREF+4      Get table address\n         LA    R0,T_TRANN                 Obtain number in table\n         L     R14,=V(PDSR$TRT)           Locate CSECT\n         LA    R14,T_TRAN-PDSR$TRT(R14)   Locate to table\nPDSRCM$I_TRL DS 0H\n         MVC   CXREF_TRANT-CXREF(TRANTL,R1),0(R14)\n         LA    R14,TRANTL(R14)\n         LA    R1,CXREFL(R1)\n         BCT   R0,PDSRCM$I_TRL\n         MVC   0(2,R1),=X'FF,FF'          Set end of table\nPDSRCM$I_TRX DS 0H\n*\n** Initialize for History report which has IDU and IDZ buffers\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?\n         BNO   PDSRCM$I_HIX               No, continue\n         IEWBUFF FUNC=GETBUF,TYPE=IDRU\n         LR    R14,R6                     To: Address\n         L     R15,IDUI_BUFFER_LENG       To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         IEWBUFF FUNC=INITBUF,TYPE=IDRU\n         STM   R6,R7,PDSRCMD_SAVEIDU      Save regs\n         DROP  R6,R7\n*\n         IEWBUFF FUNC=GETBUF,TYPE=IDRZ\n         LR    R14,R6                     To: Address\n         L     R15,IDZI_BUFFER_LENG       To: Length\n         SLR   R1,R1                      From: Set length and pad\n         MVCL  R14,R0                     Zero out table area\n         IEWBUFF FUNC=INITBUF,TYPE=IDRZ\n         STM   R6,R7,PDSRCMD_SAVEIDZ      Save regs\n         DROP  R6,R7\n*\n         LA    R3,PDSRCMD_DCBH            Locate DCB\n         MVC   0(PDSRCMCDL,R3),PDSRCMCD   Copy in DCB constant\n         L     R1,=V(PDSR$C1)\n         MVC   DCBDDNAM-IHADCB(8,R3),C_DD_HISTRPT-PDSR$C1(R1)\n         MVC   PDSRCMD_PARMLIST(PDSRCMLOL),PDSRCMLO\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PDSRCMD_PARMLIST)\n*\n         MVI   PDSRCMD_HIPRRLC,99         Start on a new page\n         XC    PDSRCMD_HIPRRPC(4),PDSRCMD_HIPRRPC  Set page count\nPDSRCM$I_HIX DS 0H\n*\n** Dump Binder entries?\n**\n** Also (temp) show all translator records\n*\n         DEVTYPE =CL8'BINDERDE',PDSRCMD_DOUBLE Check allocation\n         LTR   R15,R15                    Is file allocated?\n         BNZ   PDSRCM$I_DEX               No...\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1DMPA Set option to dump areas\nPDSRCM$I_DEX DS 0H\n*\n** Start the dialog\n*\n         MVC   PDSRCMD_FUNC(8),=CL8'STARTD'\n         MVC   PDSRCMD_DTOKEN(8),PDSRCM_ZEROS Clear dialog token\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Binder Debug Mode?\n         BO    PDSRCM$I_BDBS              Yes, need file list\n         DEVTYPE =CL8'BINDERNM',PDSRCMD_DOUBLE Get DD allocation info\n         LTR   R15,R15                    Is FILE=BINDERNM allocated?\n         BZ    PDSRCM$I_BDBPNM\n         DEVTYPE =CL8'BINDERPR',PDSRCMD_DOUBLE Get DD allocation info\n         LTR   R15,R15                    Is FILE=BINDERPR allocated?\n         BZ    PDSRCM$I_BDBP\n         IEWBIND FUNC=STARTD,                                          C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               DIALOG=PDSRCMD_DTOKEN,                                  C\n               EXITS=PDSRCMD_EXITLIST,                                 C\n               OPTIONS=OPTLIST1,         <- Has term and print off     C\n               MF=(E,PDSRCMD_PARMLIST)\n         B     PDSRCM$I_BDBSX\n*-No messages\nPDSRCM$I_BDBPNM DS 0H\n         IEWBIND FUNC=STARTD,                                          C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               DIALOG=PDSRCMD_DTOKEN,                                  C\n               FILES=FILELIST,           <- Has file list for print    C\n               OPTIONS=OPTLIST3,         <- Has term off and print on  C\n               MF=(E,PDSRCMD_PARMLIST)\n         B     PDSRCM$I_BDBSX\n*-Temp solution/workaround to use until UW32119 is on DFSMS/MVS 1.3\nPDSRCM$I_BDBP  DS 0H\n         IEWBIND FUNC=STARTD,                                          C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               DIALOG=PDSRCMD_DTOKEN,                                  C\n               EXITS=PDSRCMD_EXITLIST,                                 C\n               FILES=FILELIST,           <- Has file list for print    C\n               OPTIONS=OPTLIST3,         <- Has term off and print on  C\n               MF=(E,PDSRCMD_PARMLIST)\n         B     PDSRCM$I_BDBSX\nPDSRCM$I_BDBS  DS 0H\n         IEWBIND FUNC=STARTD,                                          C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               DIALOG=PDSRCMD_DTOKEN,                                  C\n               EXITS=PDSRCMD_EXITLIST,                                 C\n               FILES=FILELIST,           <- Has file list              C\n               OPTIONS=OPTLIST2,         <- Has term and print on      C\n               MF=(E,PDSRCMD_PARMLIST)\nPDSRCM$I_BDBSX DS 0H\n         CLC   PDSRCMD_RSNCODE(4),C_IEWB_RC_OK Check reason code\n         BE    PDSRCM$IX                  Okay fine\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1INIT We initialized...\n         LA    R15,254                    Error with STARTD\n         B     PDSRCM$X\n*\n** End of $Intialization processing\n*\nPDSRCM$IX DS 0H\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1INIT We initialized...\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2SD   We did STARTD\n         SLR   R15,R15\n         B     PDSRCM$X\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Termination - Free resources\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM$T DS    0H\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1INIT Did we initialize?\n         BNO   PDSRCM$TX\n*\n** End the dialog\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2SD   Did we do a STARTD?\n         BNO   PDSRCM$T_EDX                    No, skip this\n         MVC   PDSRCMD_FUNC(8),=CL8'ENDD'\n         IEWBIND FUNC=ENDD,                                            C\n               RETCODE=PDSRCMD_RETCODE,                                C\n               RSNCODE=PDSRCMD_RSNCODE,                                C\n               DIALOG=PDSRCMD_DTOKEN,                                  C\n               MF=(E,PDSRCMD_PARMLIST)\nPDSRCM$T_EDX DS 0H\n*\n** Delete IGWASMS program\n*\n         AIF   ('&IHADFARELS' LT '01010300').TASMSX at DFSMS/MVS 1.3?\n         ICM   R0,B'1111',PDSRCMD_IGWASMS\n         BZ    PDSRCM$T_ASMSX\n         DELETE EPLOC==CL8'IGWASMS'\n         XC    PDSRCMD_IGWASMS(4),PDSRCMD_IGWASMS\nPDSRCM$T_ASMSX DS 0H\n.TASMSX  ANOP  ,\n*\n** Free global Buffers\n*\n         LM    R6,R7,PDSRCMD_SAVEESD      Get saved registers\n         USING IEWBESD,R6\n         USING ESD_ENTRY,R7\n         IEWBUFF FUNC=FREEBUF,TYPE=ESD\n         DROP  R6,R7\n*\n         LM    R8,R9,PDSRCMD_SAVEBNL      Get saved registers\n         USING IEWBBNL,R8\n         USING BNL_ENTRY,R9\n         IEWBUFF FUNC=FREEBUF,TYPE=NAME\n         DROP  R8,R9\n*\n         LM    R6,R7,PDSRCMD_SAVEIDB      Get saved registers\n         USING IEWBIDB,R6\n         USING IDB_ENTRY,R7\n         IEWBUFF FUNC=FREEBUF,TYPE=IDRB\n         DROP  R6,R7\n*\n** Free Buffers and resources for Text processing\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT\n         BNO   PDSRCM$T_TXTX              No, continue\n         LM    R6,R7,PDSRCMD_SAVETXT      Get saved registers\n         USING IEWBTXT,R6\n         USING IDL_ENTRY,R7\n         IEWBUFF FUNC=FREEBUF,TYPE=TEXT\n         DROP  R6,R7\nPDSRCM$T_TXTX DS 0H\n*\n** Free Buffers and resources for Translator report\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1TRAN Doing Translator report?\n         BNO   PDSRCM$T_TRX               No, continue\n         LM    R6,R7,PDSRCMD_SAVEIDL      Get saved registers\n         USING IEWBIDL,R6\n         USING IDL_ENTRY,R7\n         IEWBUFF FUNC=FREEBUF,TYPE=IDRL\n         DROP  R6,R7\n*\n         LA    R3,PDSRCMD_DCBT\n         MVC   PDSRCMD_PARMLIST(PDSRCMCLL),PDSRCMCL\n         CLOSE ((3)),MF=(E,PDSRCMD_PARMLIST)\n*\n         ICM   R1,B'1111',PDSRCMD_LIBC    Get library count\n         BZ    PDSRCM$T_TRUX              None, continue\n         C     R1,=F'1'                   Processed only one library?\n         BE    PDSRCM$T_TRUX              Skip redundant information\n         LM    R2,R3,PDSRCMD_MTRCXREF     Get table length & address\n         NI    PDSRCMD_IFLAG1,255-$PDSRCMD_IF1THR\n         SLR   R4,R4                      Clear total Translators\n         SLR   R5,R5                      Clear total unknown ones\nPDSRCM$T_TRL DS 0H\n         CLC   CXREF_COUNTT-CXREF(4,R3),PDSRCM_ZEROS Found any?\n         BE    PDSRCM$T_TRLB              No, skip print\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR Print heading?\n         BO    PDSRCM$T_TRLHX\n         OI    PDSRCMD_IFLAG1,$PDSRCMD_IF1THR We printed the heading\n         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear recout to blanks\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM5L,R15),MSGCM5-PDSRCMC(R1) Get text\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$T_TRLHX DS 0H\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM6L,R15),MSGCM6      Move in message text\n         MVC   MSGCM6I-MSGCM6(L'TRANT_ID,R15),TRANT_ID-TRANT(R3)\n         MVC   MSGCM6N-MSGCM6(L'TRANT_NAME,R15),TRANT_NAME-TRANT(R3)\n         CLI   CXREF_TYPE-CXREF(R3),$CXREFT_S  Static?\n         BE    PDSRCM$T_TRLUX             Just boring Static entry\n         LA    R5,1(R5)                   Increment dynamic count\n         MVI   MSGCM6U-MSGCM6(R15),C'*'   Mark as dynamic (unknown)\nPDSRCM$T_TRLUX DS 0H\n         LA    R15,MSGCM6L(R15)           Bump past message\n         ICM   R1,B'1111',CXREF_COUNTT-CXREF(R3) Get count\n         AR    R4,R1\n         CVD   R1,PDSRCMD_DOUBLE\n         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'\n         ED    0(12,R15),PDSRCMD_DOUBLE+3\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$T_TRLB DS 0H\n         LA    R3,CXREFL(R3)              Bump to next one\n         SH    R2,=AL2(CXREFL)            Decrement table length\n         LTR   R2,R2\n         BZ    PDSRCM$T_TRLX\n         BM    PDSRCM$T_TRLX\n         CLC   0(2,R3),=X'FF,FF'          End of the table?\n         BNE   PDSRCM$T_TRL\nPDSRCM$T_TRLX DS 0H\n         LTR   R4,R4\n         BZ    PDSRCM$T_TRTX\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(L'MSGCM6,R15),MSGCM6     Move in message text\n         LA    R14,MSGCM6S+2-MSGCM6(R15)  Locate to overright area\n         MVI   0(R14),C'-'                Get dash\n         MVC   1(MSGCM6SL-2+12+6-1,R14),0(R14) Propagate dashes\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n*\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(L'MSGCM6,R15),MSGCM6      Move in message text\n         MVC   MSGCM6S+2-MSGCM6(L'MSGCM6A,R15),MSGCM6A\n         LA    R15,MSGCM6L(R15)           Bump past message\n         LR    R1,R4                      Update total\n         CVD   R1,PDSRCMD_DOUBLE\n         MVC   0(12,R15),=X'40,20,20,20,6B,20,20,20,6B,20,20,20'\n         ED    0(12,R15),PDSRCMD_DOUBLE+3\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\n         BAS   R14,PDSRCM_CLEAR_RECOUT    Clear output record\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$T_TRTX DS 0H\n*\n         LTR   R5,R5                      Did we find any unknown ones?\n         BZ    PDSRCM$T_TRUX              Nope!\n         BAS   R14,PDSRCM_FORMAT_MESSAGE  Format the message\n         MVC   0(MSGCM11L,R15),MSGCM11-PDSRCMC(R1) Get message\n         LA    R15,MSGCM11L+1(R15)        Locate past message text\n         LR    R1,R5                      Get total new program ids\n         BAS   R14,PDSRCM_EDITFWF         Edit it\n         BAS   R14,PDSRCM_PRINT_RECOUT    Print record to SYSPRINT\nPDSRCM$T_TRUX DS 0H\n*\n         LM    R0,R1,PDSRCMD_MTRCXREF     Get table length & address\n         FREEMAIN RU,LV=(0),A=(1)         Free storage\nPDSRCM$T_TRX DS 0H\n*\n** Free Buffers and resources for History report\n*\n         TM    PDSRCMD_FLAG1,$PDSRCMD_F1HIST Doing History report?\n         BNO   PDSRCM$T_HIX               No, continue\n         LM    R6,R7,PDSRCMD_SAVEIDU      Get saved registers\n         USING IEWBIDU,R6\n         USING IDU_ENTRY,R7\n         IEWBUFF FUNC=FREEBUF,TYPE=IDRU\n         DROP  R6,R7\n*\n         LM    R6,R7,PDSRCMD_SAVEIDZ      Get saved registers\n         USING IEWBIDZ,R6\n         USING IDU_ENTRY,R7\n         IEWBUFF FUNC=FREEBUF,TYPE=IDRZ\n         DROP  R6,R7\n*\n         LA    R3,PDSRCMD_DCBH\n         MVC   PDSRCMD_PARMLIST(PDSRCMCLL),PDSRCMCL\n         CLOSE ((3)),MF=(E,PDSRCMD_PARMLIST)\nPDSRCM$T_HIX DS 0H\n*\n** Close file if we did //FLATOUT processing\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO    FLATOUT?\n         BNO   PDSRCM$T_FOX               No, leave\n         LA    R3,PDSRCMD_DCBF\n         MVC   PDSRCMD_PARMLIST(PDSRCMCLL),PDSRCMCL\n         CLOSE ((3)),MF=(E,PDSRCMD_PARMLIST)\n*\n         LM    R0,R1,PDSRCMD_FOA          Get area length & address\n         FREEMAIN RU,LV=(0),A=(1)         Free storage\nPDSRCM$T_FOX DS 0H\n*\n** End of $Termination processing\n*\nPDSRCM$TX DS 0H\n         SLR   R15,R15\n         B     PDSRCM$X\n*\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Create a hex dump of an entry\n**\n**       Input: R0 has entry length\n**              R1 has ID string of entry type\n**              R15 points to the entry to be dumped\n**\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM_DUMPE DS 0H\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1DMPA Dumping Areas?\n         BNO   PDSRCM_DEQO                Nope, leave\n         ST    R14,PDSRCMD_DERA           Save return address\n         STM   R8,R9,PDSRCMD_DESREG       Save register\n         L     R9,PDSRCMD_PSRAREA         Locate to area\n         USING PSRAREA,R9                 Enable field access\n         STM   R15,R1,PDSRCMD_DESREGA     Save regs\n*\n** Print message that has the name of the area we are dumping\n*\n         LA    R15,PDSRCMD_DEREC          Locate output record\n         BAS   R14,PDSRCM_FMS             Format message\n         MVC   0(MSGCM3L,R15),MSGCM3      Get text\n         LA    R15,MSGCM3L(R15)           Bump past text\n         L     R1,PDSRCMD_DESREGI         Get ID string address\n         SLR   R14,R14                    Clear reg for IC\n         IC    R14,0(R1)                  Get length of string\n         EX    R14,PDSRCM_DEMID           Move string out\n         LA    R15,1(R14,R15)\n         MVC   0(12,R15),=C'\" - address='\n         LA    R15,12(R15)\n         UNPK  0(9,R15),PDSRCMD_DESREGA(5)\n         MVZ   0(8,R15),PDSRCM_ZEROS\n         TR    0(8,R15),PDSRCM_HEXTABLE\n         MVC   8(8,R15),=C' length='\n         LA    R15,8+8(R15)\n         L     R1,PDSRCMD_DESREGL\n         BAS   R14,PDSRCM_EDITFWF         Edit it\n         MVI   1(R15),C'('\n         LA    R15,2(R15)\n         UNPK  0(5,R15),PDSRCMD_DESREGL+2(3)\n         MVZ   0(4,R15),PDSRCM_ZEROS\n         TR    0(4,R15),PDSRCM_HEXTABLE\n         MVI   4(R15),C')'\n*\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LA    R1,PDSRCMD_DEREC           Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         MVI   PDSRCMD_DEREC,C' '\n         MVC   PDSRCMD_DEREC+1(L'PDSRCMD_DEREC-1),PDSRCMD_DEREC\n*\n** Perform a hex dump on the area\n*\n         XC    W_AREA(CMXDL),W_AREA       Initialize area\n         LM    R15,R1,PDSRCMD_DESREGA     Restore regs\n*-R15 has area address                    Locate directory entry\n*-R0 has length                           Get length of directory ent.\n         LA    R1,PDSRCMD_DEREC+14        Get output location\n         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2TSOV\n         BO    PDSRCM_DE$DIREL\n         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(132) <- TSO viewing\nPDSRCM_DE$DIREL EQU *\n         LA    R1,W_AREA                  Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         LR    R8,R15                     Save return code\n*\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LA    R1,PDSRCMD_DEREC           Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   PDSRCM_DE$DIREL            Thank you: May I have another\n*\n         MVI   PDSRCMD_DEREC,C' '\n         MVC   PDSRCMD_DEREC+1(L'PDSRCMD_DEREC-1),PDSRCMD_DEREC\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LA    R1,PDSRCMD_DEREC           Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n** Return to caller\n*\n         L     R14,PDSRCMD_DERA           Get return address\n         LM    R8,R9,PDSRCMD_DESREG       Get registers back\nPDSRCM_DEQO DS 0H\n         BSM   0,R14                      Return to caller\n         DROP  R9                         Drop psrarea addressability\nPDSRCM_DEMID MVC 0(0,R15),1(R1)           ** Executed **\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Misc subroutines\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Print PDSRCMD_RECOUT to the sysprint file\n*\nPDSRCM_PRINT_RECOUT DS 0H\n         ST    R14,PDSRCMD_DOUBLE         Save return address\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LA    R1,PDSRCMD_RECOUT          Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n         L     R14,PDSRCMD_DOUBLE         Get return address\n         BSM   0,R14\n*\n** Format for message\n*\nPDSRCM_FORMAT_MESSAGE DS 0H\n         LA    R15,PDSRCMD_RECOUT\nPDSRCM_FMS DS 0H\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         MVC   1(7,R15),=CL7'DA$PDSR'\n         MVI   1+7(R15),C'-'\n         LA    R15,1+7+1(R15)\n         L     R1,=V(PDSRCMC)\n         BSM   0,R14\n*\n** Clear recout to blanks\n*\nPDSRCM_CLEAR_RECOUT DS 0H\n         LA    R15,PDSRCMD_RECOUT\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         BSM   0,R14\n*\n** Edit full word in Register 1 flush at location in Register 15\n** with no commas\n**\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nPDSRCM_EDITNCF EQU *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    PDSRCM_EDITNCF0            YES, PUT ZERO\n         ST    R14,PDSRCMD_EDITRA         Save return address\n         CVD   R1,PDSRCMD_DOUBLE          NO, CONVERT TO PACKEC\n**\n LA    R1,PDSRCMD_DOUBLE2+7               LOCATE SIG DIGIT\n MVC   PDSRCMD_DOUBLE2(8),PDSRCM_EDITNCFP\n EDMK  PDSRCMD_DOUBLE2(8),PDSRCMD_DOUBLE+4 EDIT AND SAVE PLACE\n LA    R14,PDSRCMD_DOUBLE2+9              LOCATE LAST POSSIBLE BYTE + 1\n**\n*        LA    R1,PDSRCMD_DOUBLE2+14      LOCATE SIG DIGIT\n*        MVC   PDSRCMD_DOUBLE2(15),PDSRCM_EDITNCFP\n*        EDMK  PDSRCMD_DOUBLE2(15),PDSRCMD_DOUBLE+2 EDIT AND SAVE PLACE\n*        LA    R14,PDSRCMD_DOUBLE2+16     LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,PDSRCM_EDITNCFM        MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '\n         L     R14,PDSRCMD_EDITRA         Get return address\n         BSM   0,R14                      RETURN TO CALLER\nPDSRCM_EDITNCFM MVC 0(0,R15),0(R1)\nPDSRCM_EDITNCFP DC X'40,20,20,20,20,20,20,20,20,20,20,20,20,20,20'\nPDSRCM_EDITNCF0 DS 0H\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R14                      RETURN TO CALLER\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nPDSRCM_EDITFWF DS 0H\n         LTR   R1,R1                      Check for 0\n         BZ    PDSRCM_EDITFWF0            Yes, put zero\n         ST    R14,PDSRCMD_EDITRA         Save return address\n         CVD   R1,PDSRCMD_DOUBLE          No, convert to packec\n         LA    R1,PDSRCMD_DOUBLE2+14      Locate sig digit\n         MVC   PDSRCMD_DOUBLE2(15),PDSRCM_EDITP15\n         EDMK  PDSRCMD_DOUBLE2(15),PDSRCMD_DOUBLE+2 EDIT AND SAVE PLACE\n         LA    R14,PDSRCMD_DOUBLE2+16     Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for ex\n         EX    R14,PDSRCM_EDITFWFM        Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '\n         L     R14,PDSRCMD_EDITRA\n         BSM   0,R14                      Return to caller\nPDSRCM_EDITFWFM MVC 0(0,R15),0(R1)\nPDSRCM_EDITP15  DC  X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nPDSRCM_EDITFWF0 DS  0H\n         MVI   0(R15),C'0'                Put in zero\n         LA    R15,1(R15)                 Bump pointer past zero\n         BSM   0,R14                      Return to caller\n*\n** Point Register 15 to the first blank in a string\n** Input:  R0  - Maximum length of the string\n**         R15 - String\n** Output: R15 - First space in the string\n*\nPDSRCM_LOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '                Blank?\n         BE    PDSRCM_LFS$X               Yes, leave\n         LA    R15,1(R15)                 No, bump to next byte\n         BCT   R0,PDSRCM_LOCATE_FIRST_SPACE ..Repeat\nPDSRCM_LFS$X DS 0H\n         BSM   0,R14                      Return to caller\n*\n** Ensure that member (or any 8 byte area) has only valid characters\n**\n** Input: R15 - 8 byte member name with 18 bytes for hex conversion\n**\n** Note: We save R2 because TRT *DESTROYS* R2\n*\nPDSRCM_EPM DS 0H\n         ST    R14,PDSRCMD_DOUBLE         Save return address\n         ST    R2,PDSRCMD_DOUBLE+4        Save this register (TRT)\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         TRT   0(8,R15),C_TABPRT-PDSR$C2(R1) Valid characters only?\n         BZ    PDSRCM$EPM$X               Yes, leave\n         MVI   8(R15),C'/'                Insert delimiter\n         UNPK  9(9,R15),0(5,R15)          >>\n         MVZ   9(8,R15),PDSRCM_ZEROS      >>> Convert first 4 bytes\n         TR    9(8,R15),PDSRCM_HEXTABLE   >>\n         UNPK  9+8(9,R15),4(5,R15)        <<\n         MVZ   9+8(8,R15),PDSRCM_ZEROS    <<< Convert last 4 bytes\n         TR    9+8(8,R15),PDSRCM_HEXTABLE <<\n         MVI   9+8+8(R15),C' '            Fix last byte\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         TR    0(8,R15),C_TRTABM-PDSR$C2(R1) Translate to valid...\nPDSRCM$EPM$X EQU *\n         L     R2,PDSRCMD_DOUBLE+4        Restore this register\n         L     R14,PDSRCMD_DOUBLE         Get return address\n         BSM   0,R14                      Return to caller\n#PDSRCM_EPML    EQU   8+1+16              Max length\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print Report Record for Translator report\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM_TRPRR DS 0H\n         TM    PDSRCMD_IFLAG3,$PDSRCMD_IF3STR   Simulate TRANRPT?\n         BO    PDSRCM_TRPRR_QO            Yes, quick out\n         ST    R14,PDSRCMD_PRRRA          Save return address\n*\n         SLR   R1,R1                      Clear register for IC\n         IC    R1,PDSRCMD_TRPRRLC         Get current line count\n         LA    R1,1(R1)                   Increment by 1\n         STC   R1,PDSRCMD_TRPRRLC         Save new line count\n         CLI   PDSRCMD_TRPRRLC,47         Over max for page?\n         BL    PDSRCM_TRPRR$PL            No, continue\n         MVI   PDSRCMD_TRPRRLC,1          Yes, start over on new page\n*\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         MVC   0(27,R15),=C'1Translator report for DSN='\n         LA    R15,27(R15)\n         L     R1,PDSRCMD_DSNAME\n         MVC   0(44,R15),0(R1)\n         LA    R0,44\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         MVC   1(9,R15),=C'- Volser='\n         LA    R15,1+9(R15)\n         L     R1,PDSRCMD_VOLSER\n         MVC   0(6,R15),0(R1)\n         LA    R0,6\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         MVC   1(7,R15),=C'- Page:'\n         LA    R15,1+7+1(R15)\n         L     R1,PDSRCMD_TRPRRPC\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_TRPRRPC\n         BAS   R14,PDSRCM_EDITFWF\n*\n         MVI   1(R15),C'-'                Insert delimiter\n         LA    R15,3(R15)                 Bump past it\n         ICM   R1,B'1111',PDSRCMD_DATE    Locate Date DA$DATE area\n         SLR   R14,R14                         Clear reg for IC\n         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of date\n         BCTR  R14,0                           Decrement for EX\n         EX    R14,PDSRCM_TRPRRMDS        Move date to heading line\n         LA    R15,2(R14,R15)             Bump past date\n         ICM   R1,B'1111',PDSRCMD_TIME    Locate time DA#DATE area\n         SLR   R14,R14                         Clear reg for IC\n         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of time\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,PDSRCM_TRPRRMDS        Move time out\n         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL\n*-Print blank line\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL\n*-Print first heading line\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         MVC   OCL_TRAN-OCL(L'PDSRCM_TID,R15),PDSRCM_TID\n         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL\n*-Print second heading line\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         L     R14,=V(PDSRCMC)\n         MVC   OCL_MEMBER-OCL(6,R15),CMC_MEMBER-PDSRCMC(R14)\n         MVC   OCL_CSECT-OCL(10,R15),CMC_CSECT-PDSRCMC(R14)\n         MVC   OCL_OFFSET-OCL(6,R15),CMC_OFFSET-PDSRCMC(R14)\n         MVC   OCL_LENGTH-OCL(6,R15),CMC_LENGTH-PDSRCMC(R14)\n         MVC   OCL_TRANDATE-OCL(4,R15),CMC_TRANDATE-PDSRCMC(R14)\n         MVC   OCL_TRANID-OCL(2,R15),CMC_TRANID-PDSRCMC(R14)\n         MVC   OCL_TRANVER-OCL(5,R15),CMC_TRANVER-PDSRCMC(R14)\n         MVC   OCL_TRANNAME-OCL(4,R15),CMC_TRANNAME-PDSRCMC(R14)\n         MVC   OCL_AMODE-OCL(15,R15),CMC_AMODE-PDSRCMC(R14)\n         MVC   OCL_ALIGN-OCL(9,R15),CMC_ALIGN-PDSRCMC(R14)\n         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL\n*-Print third heading line\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         L     R14,=V(PDSRCMC)\n         MVC   OCL_MEMBER-OCL(L'OCL_MEMBER,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_CSECT-OCL(L'OCL_CSECT,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_OFFSET-OCL(L'OCL_OFFSET,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_LENGTH-OCL(L'OCL_LENGTH,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_TRANDATE-OCL(4+1+3,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_TRANID-OCL(L'OCL_TRANID,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_TRANVER-OCL(5,R15),CMC_DASH-PDSRCMC(R14)\n       MVC OCL_TRANNAME-OCL(L'OCL_TRANNAME,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_AMODE-OCL(OCL_AML,R15),CMC_DASH-PDSRCMC(R14)\n         MVC   OCL_ALIGN-OCL(9,R15),CMC_DASH-PDSRCMC(R14)\n         PUT   PDSRCMD_DCBT,PDSRCMD_PRRHL\nPDSRCM_TRPRR$PL DS 0H\n         PUT   PDSRCMD_DCBT,PDSRCMD_RECOUT\n*\n         L     R14,PDSRCMD_PRRRA\nPDSRCM_TRPRR_QO DS 0H\n         BSM   0,R14\n*\nPDSRCM_TRPRRMDS MVC 0(0,R15),DA#DATED_STR-DA#DATED(R1)\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Print Report Record for History report\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM_HIPRR DS 0H\n         ST    R14,PDSRCMD_PRRRA          Save return address\n*\n         SLR   R1,R1                      Clear register for IC\n         IC    R1,PDSRCMD_HIPRRLC         Get current line count\n         LA    R1,1(R1)                   Increment by 1\n         STC   R1,PDSRCMD_HIPRRLC         Save new line count\n         CLI   PDSRCMD_HIPRRLC,47         Over max for page?\n         BL    PDSRCM_HIPRR$PL            No, continue\n         MVI   PDSRCMD_HIPRRLC,1          Yes, start over on new page\n*\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         MVC   0(24,R15),=C'1History report for DSN='\n         LA    R15,24(R15)\n         L     R1,PDSRCMD_DSNAME\n         MVC   0(44,R15),0(R1)\n         LA    R0,44\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         MVC   1(9,R15),=C'- Volser='\n         LA    R15,1+9(R15)\n         L     R1,PDSRCMD_VOLSER\n         MVC   0(6,R15),0(R1)\n         LA    R0,6\n         BAS   R14,PDSRCM_LOCATE_FIRST_SPACE\n         MVC   1(7,R15),=C'- Page:'\n         LA    R15,1+7+1(R15)\n         L     R1,PDSRCMD_HIPRRPC\n         LA    R1,1(R1)\n         ST    R1,PDSRCMD_HIPRRPC\n         BAS   R14,PDSRCM_EDITFWF\n*\n         MVI   1(R15),C'-'                Insert delimiter\n         LA    R15,3(R15)                 Bump past it\n         ICM   R1,B'1111',PDSRCMD_DATE    Locate Date DA$DATE area\n         SLR   R14,R14                         Clear reg for IC\n         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of date\n         BCTR  R14,0                           Decrement for EX\n         EX    R14,PDSRCM_HIPRRMDS        Move date to heading line\n         LA    R15,2(R14,R15)             Bump past date\n         ICM   R1,B'1111',PDSRCMD_TIME    Locate time DA#DATE area\n         SLR   R14,R14                         Clear reg for IC\n         IC    R14,DA#DATED_STRL-DA#DATED(R1)  Get length of time\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,PDSRCM_HIPRRMDS        Move time out\n*\n         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL\n*-Print blank line\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL\n*-Print heading line 1\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         MVC   OCL_MEMBER-OCL(6,R15),=C'Member'\n         MVC   OCL_CSECT-OCL(10,R15),=C'CSECT Name'\n         MVC   OCL_OFFSET-OCL(6,R15),=C'Offset'\n         MVC   OCL_LENGTH-OCL(6,R15),=C'length'\n         MVC   OCL_HISTDATE-OCL(4,R15),=C'Date'\n         MVC   OCL_HISTDATA-OCL(4,R15),=C'Data'\n         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL\n*-Print heading line 2\n         LA    R15,PDSRCMD_PRRHL\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         MVC   OCL_MEMBER-OCL(L'OCL_MEMBER,R15),=32C'-'\n         MVC   OCL_CSECT-OCL(L'OCL_CSECT,R15),=32C'-'\n         MVC   OCL_OFFSET-OCL(L'OCL_OFFSET,R15),=32C'-'\n         MVC   OCL_LENGTH-OCL(L'OCL_LENGTH,R15),=32C'-'\n         MVC   OCL_HISTDATE-OCL(4+1+3,R15),=32C'-'\n         MVC   OCL_HISTDATA-OCL(4,R15),=32C'-'\n         PUT   PDSRCMD_DCBH,PDSRCMD_PRRHL\nPDSRCM_HIPRR$PL DS 0H\n         PUT   PDSRCMD_DCBH,PDSRCMD_RECOUT\n*\n         L     R14,PDSRCMD_PRRRA\n         BSM   0,R14\nPDSRCM_HIPRRMDS MVC 0(0,R15),DA#DATED_STR-DA#DATED(R1)\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**       Constants for PDSRCM\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCM_ZEROS    DC    X'00,00,00,00,00,00,00,00'\nPDSRCM_HEXTABLE DC C'0123456789abcdef'\n*\nC_IEWB_RC_OK       DC AL4($IEWB_RC_OK)      .... 0\nC_IEWB_RC_WARNING  DC AL4($IEWB_RC_WARNING) .... 4\nC_IEWB_RC_ERROR    DC AL4($IEWB_RC_ERROR)   .... 8\nC_IEWB_RC_SEVERE   DC AL4($IEWB_RC_SEVERE)  .... 12\nC_IEWB_RC_TERMINAL DC AL4($IEWB_RC_TERMINAL) ... 16\n*\nC_ID_IDL_BUFFER DA#STR 'IDL_Buffer Entry'\nC_ID_IDU_BUFFER DA#STR 'IDU_Buffer Entry'\nC_ID_IDZ_BUFFER DA#STR 'IDZ_Buffer Entry'\nC_ID_IDB_BUFFER DA#STR 'IDB_Buffer Entry'\nC_ID_ESD_BUFFER DA#STR 'ESD_Buffer Entry'\nC_ID_TXT_BUFFER DA#STR 'TXT_Buffer Entry'\n*\nC_ID_IDL_HEADER DA#STR 'IDL_Buffer Header'\nC_ID_IDU_HEADER DA#STR 'IDU_Buffer Header'\nC_ID_IDZ_HEADER DA#STR 'IDZ_Buffer Header'\nC_ID_IDB_HEADER DA#STR 'IDB_Buffer Header'\nC_ID_ESD_HEADER DA#STR 'ESD_Buffer Header'\nC_ID_TXT_HEADER DA#STR 'TXT_Buffer Header'\n*\nMOVESEC  MVC   2(0,R4),0(R3)\n*\nPDSRCM_TID DC  C'<.......T r a n s l a t o r.........>'\n*\n*--> 1  <----------------------------------> Defined in PDSRCMC CSECT\nMSGCM2A  DC    C'C02E   > IEWBIND FUNC=('\nMSGCM2AL EQU   *-MSGCM2A\nMSGCM3   DC    C'C03I Dump of \"'\nMSGCM3L  EQU   *-MSGCM3\nMSGCM4   DC    C'C04I > Processing Member='\nMSGCM4M  DC    CL8' '\n         DC    C' Section=\"'\nMSGCM4L  EQU   *-MSGCM4\n*\nMSGCM6   DC    C'C06I '\nMSGCM6S  DC    C'> Program ID: '\nMSGCM6I  DS    XL(L'TRANT_ID)\n         DC    C' Name: '\nMSGCM6N  DS    XL(L'TRANT_NAME)\nMSGCM6U  DC    C'  '\nMSGCM6SL EQU   *-MSGCM6S\n         DC    C'Count:'\nMSGCM6L  EQU   *-MSGCM6\nMSGCM6A  DC    C'Total for all libraries:'\n*\nMSGCM8   DC    C'C08I   '\nMSGCM8S  DC    C'> Program ID: '\nMSGCM8I  DS    XL(L'TRANT_ID)\n         DC    C' Name: '\nMSGCM8N  DS    XL(L'TRANT_NAME)\n         DC    C'           '\nMSGCM8SL EQU   *-MSGCM8S\nMSGCM8L  EQU   *-MSGCM8\nMSGCM8A  DC    C'Total for library:'\n*\nMSGCM12  EQU   *-*          Used in PDSRCMM\nMSGCM15  DC    C'C15I > Dataset type='\nMSGCM15L EQU   *-MSGCM15\nMSGCM16  DC    C'C16I > IGWASMS error, rc='\nMSGCM16L EQU   *-MSGCM16\nMSGCM17  DC    C'C17W > Truncated CSECT name, shown='\nMSGCM17L EQU   *-MSGCM17\n*--> 18 <----------------------------------> Defined in PDSRCMC CSECT\n*\n*\n** Variable length string constants for version 1.1 and 1.2\n*\nB@ESD    DC    H'4',C'@ESD'               Class name for ESD\nB@IDRL   DC    H'5',C'@IDRL'              Class name for IDR translator\nB@IDRU   DC    H'5',C'@IDRU'              Class name for IDR user recs\nB@IDRZ   DC    H'5',C'@IDRZ'              Class name for IDR Zap recs\nB@IDRB   DC    H'5',C'@IDRB'              Class name for Binder ID Data\nB@TEXT   DC    H'5',C'@TEXT'              Class name for TEXT records\n*\n** Variable length string constants for version 1.3 and higher\n*\nB_ESD    DC    H'5',C'B_ESD'              Class name for ESD\nB_IDRL   DC    H'6',C'B_IDRL'             Class name for IDR translator\nB_IDRU   DC    H'6',C'B_IDRU'             Class name for IDR user recs\nB_IDRZ   DC    H'6',C'B_IDRZ'             Class name for IDR Zap recs\nB_IDRB   DC    H'6',C'B_IDRB'             Class name for Binder ID Data\nB_TEXT   DC    H'6',C'B_TEXT'             Class name for TEXT records\n*\n** Misc binder options\n*\nO_LIST   DC    H'4',C'LIST'               Option: List\nV_ALL    DC    H'3',C'ALL'                Value: All\nV_OFF    DC    H'3',C'OFF'                Value: Off\n*\nPARMS_DB   DC  AL2(L'PARMS_DBV)\nPARMS_DBV  DC  C'PRINT(Y)'\n*\nPARMS_NDB  DC  AL2(L'PARMS_NDBV)\nPARMS_NDBV DC  C'PRINT(N)'\n*\n** Various list constants\n*\nFILELIST DS    0F                         ddname\n         DC    F'1'                       Number\n         DC    CL8'PRINT',F'8',A(PRINTX)  Type, length of ddname, addr\nPRINTX   DC    CL8'BINDEROU'              The ddname\n*\nOPTION_Y DC    C'Y'\nOPTION_N DC    C'N'\n*\nOPTLIST1 DS    0F                         Global options specs\n         DC    F'2'                       Number of list entries\n         DC    CL8'TERM    ',F'1',A(OPTION_N)\n         DC    CL8'PRINT   ',F'1',A(OPTION_N)\n*\nOPTLIST2 DS    0F                         Global options specs\n         DC    F'2'                       Number of list entries\n         DC    CL8'TERM    ',F'1',A(OPTION_Y)\n         DC    CL8'PRINT   ',F'1',A(OPTION_Y)\n*\nOPTLIST3 DS    0F                         Global options specs\n         DC    F'2'                       Number of list entries\n         DC    CL8'TERM    ',F'1',A(OPTION_N)\n         DC    CL8'PRINT   ',F'1',A(OPTION_Y)\n*\nCEXITL   DS    0F                         User exit specifications\n         DC    F'1'                       Number of list entries\n         DC    CL8'MESSAGE'               Type\n         DC    F'12'                      Length of exit list\nCEXITLA  DC    A(0)\nCEXITLL  EQU   *-CEXITL\n*\n** QSAM I/O\n*\nPDSRCMCD DCB   DDNAME=PDSRCMCD,                                        @\n               DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA\nPDSRCMCDL EQU  *-PDSRCMCD\nPDSRCMLO OPEN  (*-*,(OUTPUT)),MF=L\nPDSRCMLOL EQU  *-PDSRCMLO\nPDSRCMCL CLOSE (*-*),MF=L\nPDSRCMCLL EQU  *-PDSRCMCL\n*\n** Buffer Mappings\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRB,SIZE=32,                        C\n               VERSION=1,                                              C\n               HEADREG=6,ENTRYREG=7\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRL,SIZE=32,                        C\n               VERSION=1,                                              C\n               HEADREG=6,ENTRYREG=7\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRU,SIZE=256,                       C\n               VERSION=1,                                              C\n               HEADREG=6,ENTRYREG=7\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRZ,SIZE=256,                       C\n               VERSION=1,                                              C\n               HEADREG=6,ENTRYREG=7\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=TEXT,SIZE=128000,    128k            C\n               VERSION=1,                                              C\n               HEADREG=6,ENTRYREG=7\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=ESD,SIZE=256,                        C\n               VERSION=1,                                              C\n               HEADREG=6,ENTRYREG=7\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=NAME,SIZE=8192,                      C\n               VERSION=1,                                              C\n               HEADREG=8,ENTRYREG=9\n*\n** Copy in constants and equates for the Binder API\n*\n*        COPY IEWBCRL ,                 RLD codes\n*        COPY IEWBCRS ,                 Binder API equates\n*-Instead of importing over 700 lines from IEWBCRS, I just copied\n*-the ones I needed:\n$IEWB_RC_OK          EQU            0\n$IEWB_RC_WARNING     EQU            4\n$IEWB_RC_ERROR       EQU            8\n$IEWB_RC_SEVERE      EQU            12\n$IEWB_RC_TERMINAL    EQU            16\n*\n** Literals - To get more room, more of these LTORG values could\n**            be moved to one of the constants CSECTs\n*\n         PRINT DATA\nPDSRCM_LTORG  EQU  *\n         LTORG ,\nPDSRCM_LTORGL EQU *-PDSRCM_LTORG\n         PRINT NODATA\n*\n** Calculate length of main CSECT\n*\n         DS    0D                         End on double word boundry\nPDSRCML EQU    *-PDSRCM                   Length of program\nPDSRCMB EQU    (3*4096)-PDSRCML           Bytes left addressable\n         DS    0D\n         DROP  R13,R12,R11,R10\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Constants for PDSRCM CSECT\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\nPDSRCMC  CSECT ,\nPDSRCMC  AMODE 24\nPDSRCMC  RMODE 24\n*\n** Standard O/S eyecatcher\n*\nPDSRCMC_EC    B    PDSRCMC_ECL(0,R15)     Bump past EyeCatcher\n              DC   AL1(L'PDSRCMC_ECLIT)   Length of eyecatcher\nPDSRCMC_ECLIT DC   C'PDSRCMC  - Constants CSECT for PDSRCM'\n              DS   0H\nPDSRCMC_ECL   EQU  *-PDSRCMC_EC\n*\n** Moved constants here to make more room in PDSRCM CSECT\n*\nMSGCM1   DC    C'C01I > Warning: Not all sections processed, number '\n         DC    C'not shown='\nMSGCM1L  EQU   *-MSGCM1\nMSGCM2   DC    C'C02E > Error using DFSMS/MVS Binder API on member='\nMSGCM2L  EQU   *-MSGCM2\nMSGCM5   DC    C'C05I Translator XREF for all libraries:'\nMSGCM5L  EQU   *-MSGCM5\nMSGCM7   DC    C'C07I > Translator XREF for this library:'\nMSGCM7L  EQU   *-MSGCM7\nMSGCM9   DC    C'C09I > Number of History (IDENTIFY) entries:'\nMSGCM9L  EQU   *-MSGCM9\nMSGCM10  DC    C'C10I > Number of History (ZAP) entries:'\nMSGCM10L EQU   *-MSGCM10\n*\nMSGCM11  DC    C'C11I Number of Translator Program IDs that were '\n         DC    C'unknown:'\nMSGCM11L EQU   *-MSGCM11\nMSGCM13  DC    C'C13I > Largest CSECT processed: size='\nMSGCM13L EQU   *-MSGCM13\nMSGCM14  DC    C'C14I > Oldest CSECT processed: date='\nMSGCM14L EQU   *-MSGCM14\nMSGCM18  DC    C'DA$PDSR-C18I > The following Binder (IEW) messages'\n         DC    C' are for member='\nMSGCM18L EQU   *-MSGCM18\nMSGCM20  DC    C'C20W > Binder API GETN RC=4, Reason='\nMSGCM20L EQU   *-MSGCM20\nMSGCM19  DC    C'C19W > Binder API error for IDZ processing, Member='\nMSGCM19L EQU   *-MSGCM19\nMSGCM98  DC    C'C98I Using INTYPE=POINTER (DCB/DirectoryEntry) for '\n         DC    C'Binder API IEWBIND FUNC=INCLUDE'\nMSGCM98L EQU   *-MSGCM98\nMSGCM99  DC    C'C99E Overflow on internal translator table'\nMSGCM99L EQU   *-MSGCM99\n*\nCMC_MEMBER   DC  C'Member'\nCMC_CSECT    DC  C'CSECT Name'\nCMC_OFFSET   DC  C'Offset'\nCMC_LENGTH   DC  C'length'\nCMC_TRANDATE DC  C'Date'\nCMC_TRANID   DC  C'ID'\nCMC_TRANVER  DC  C'vv.mm'\nCMC_TRANNAME DC  C'Name'\nCMC_AMODE    DC  C'Addressing Mode'\nCMC_ALIGN    DC  C'Alignment'\nCMC_DASH     DC  32C'-'\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Flatout Member processing\n**\n** Output a line to //FLATOUT for each member processed.  We use\n** the information on the output report line.\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCMFM CSECT ,\nPDSRCMFM AMODE 24\nPDSRCMFM RMODE 24\n*\n** Standard O/S eyecatcher\n*\nCMFM_EC    B    CMFM_ECL(0,R15)        Bump past EyeCatcher\n           DC   AL1(L'CMFM_ECLIT)      Length of eyecatcher\nCMFM_ECLIT DC   C'PDSRCMFM - FLATOUT member processing'\n           DS   0H\nCMFM_ECL   EQU  *-CMFM_EC\n*\n** Entry Housekeeping\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSRCMFM,R12               Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore registers R0 and R1\n         LR    R13,R1                     Locate RSA and work area\n*\n         CH    R0,=AL2(#FLATOUT_Member)\n         BE    CMFM$Member\n         CH    R0,=AL2(#FLATOUT_Open)\n         BE    CMFM$Open\n         B     CMFM$X\n*\n** Open\n*\nCMFM$Open ds 0h\n         USING PDSRCMD_SUBRSA,R13        Locate to data area\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2FO    Turn on flatout flag\n         OI    PDSRCMD_FLAG1,$PDSRCMD_F1TEXT    Need Text processing\n*\n         LA    R3,PDSRCMD_DCBF            Locate DCB\n         MVC   0(CMFMDCBVL,R3),CMFMDCBV    Copy in DCB constant\n         MVC   DCBDDNAM-IHADCB(8,R3),=CL8'FLATOUT'\n         MVC   PDSRCMD_PARMLIST(CMFMOPNL),CMFMOPN\n         OPEN  ((3),(OUTPUT)),            Open the file                @\n               MF=(E,PDSRCMD_PARMLIST)\n         L     R0,=AL4(32756+8)           Create record area\n         GETMAIN RU,LV=(0)                Obtain storage\n         STM   R0,R1,PDSRCMD_FOA          Save length and address\n         MVC   FOM_EC-FOM(8,R1),=CL8'FLATOUT'\n         MVI   FOM_EC+7-FOM(R1),C'R'\n         XC    FOM_RDW-FOM(4,R1),FOM_RDW-FOM(R1) Zero out RDW\n*\n         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area\n         LA    R1,FOM_RECORD-FOM(R1) Locate to record output\n         MVI   0(R1),C' '\n         MVC   1(FORHL-1,R1),0(R1)\n         MVI   FOR_TYPE-FOR(R1),$FORTYPE_H  Set type: Heading line\n         L     R14,=V(DA$PDSR)\n         MVC   FORH_NAME-FOR(7,R1),=C'DA$PDSR'\n         MVC   FORH_VER-FOR(5,R1),=C'V&DAVER'\n         MVC   FORH_ADATE-FOR(10,R1),=C'&ASMDATE'\n         MVC   FORH_ATIME-FOR(5,R1),=C'&SYSTIME'\n         LA    R15,FORHL(R1)             Locate to end of our line\n         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area\n         LA    R1,FOM_RDW-FOM(R1)        Locate to record output\n         SR    R15,R1                    Length = end - start\n         STH   R15,0(R1)                 Save length of variable record\n         LR    R0,R1                     Get record loc to rite reg\n         PUT   PDSRCMD_DCBF,(0)          Output record...\n         B     CMFM$X                    Leave\n         DROP  R13                       Drop: SUBRSA2 + rest of workds\n*\n** Here we get called for each member\n*\nCMFM$Member ds 0h\n         USING SUBRSA,R13                 Locate to data area\n         ICM   R9,B'1111',A_PDSRCMD+4     Locate area\n         BZ    CMFM$X                     None?\n         USING PDSRCMD,R9                 Get addressability\n*\n** Debugging code to see what our input RECOUT field looks like\n*\n AGO .CMFMDX ....................................\n         L     R1,PDSRCMD_FOA+4\n         LA    R14,FOM_RECORD-FOM(R1)\n         MVI   FOR_TYPE-FOR(R14),$FORTYPE_DB\n         MVC   FORDB_TYPE-FOR(8,R14),=CL8'CMFM'\n         MVC   FORDB_VAR-FOR(132,R14),RECOUT+1\n*\n         LA    R1,FOM_RDW-FOM(R1)\n         LA    R15,FORDBL+132+4\n         STH   R15,0(R1)\n         LR    R0,R1\n         PUT   PDSRCMD_DCBF,(0)\n.CMFMDX ANOP ....................................\n*\n         LA    R8,RECOUT+1\n         USING DET,R8\n*\n         L     R7,PDSRCMD_FOA+4          Locate FLATOUT record Area\n         LA    R7,FOM_RECORD-FOM(R7)     Locate to record output\n         USING FOR,R7\n*\n         MVI   FOR_TYPE,$FORTYPE_M       Type = Member\n         MVC   FORM_NAME(L'DETMEM),DETMEM\n         MVI   FORM_SPACE1,C' '\n         MVC   FORM_SIZE(L'DET_LSIZE),DET_LSIZE\n         MVI   FORM_SPACE2,C' '\n         MVC   FORM_AMODET(5),=C'AMODE'\n         MVC   FORM_AMODE(2),DET_LMODEA\n         MVI   FORM_SPACE3,C' '\n         MVC   FORM_RMODET(5),=C'RMODE'\n         MVC   FORM_RMODE(3),DET_LMODER\n         MVI   FORM_SPACE4,C' '\n         MVC   FORM_DATET(6),=C'DATE: '\n         MVC   FORM_DATE(L'DET_LTD_DATE),DET_LTD_DATE\n         MVI   FORM_SPACE5,C' '\n         MVC   FORM_ATTRT(6),=C'ATTR: '\n         MVC   FORM_ATTR(L'DET_LATTR),DET_LATTR\n*-Note: More fields can be added here to output member record\n*\n         DROP  R7                        Drop: using=FOR\n         DROP  R8                        Drop: using=DET: RECOUT+1\n*\n** Put the record to the //flatout file\n*\n         L     R1,PDSRCMD_FOA+4          Locate FLATOUT record Area\n         LA    R1,FOM_RDW-FOM(R1)        Locate to record output\n         LA    R15,FORML+4               Length = end - start\n         STH   R15,0(R1)                 Save length of variable record\n         LR    R0,R1                     Get record loc to rite reg\n         PUT   PDSRCMD_DCBF,(0)          Output record...\n         DROP  R9                        Drop: using=PDSRCMD\n         DROP  R13                       Drop: SUBRSA + rest of workds\n*\n** Exit\n*\nCMFM$X   DS    0H\n         SLR   R15,R15\n         PR    ,\n*\n** Constants\n*\nCMFMDCBV DCB   DDNAME=CMFMDCBV,                                        @\n               DSORG=PS,MACRF=PM,RECFM=VB\nCMFMDCBVL EQU  *-CMFMDCBV\nCMFMOPN OPEN   (*-*,(OUTPUT)),MF=L\nCMFMOPNL EQU   *-CMFMOPN\n*\n** Literals and end of CSECT\n*\n         LTORG ,\n         DS    0D\nCMFM$L   EQU   *-PDSRCMFM\n         DROP  R12\n         EJECT ,\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Message exit routine for Binder API.  This routine gets invoked\n** when a message is issued by the Binder.\n**\n** Although not documented in the current version of the DFSMS 1.3\n** \"Program Management\" manual (SC26-4916-02 May 1997), the message\n** buffer differs from the manual when executing under DFSMS 1.3\n** where it has a halfword length byte preceding the message.  The\n** code below allows for the different buffer format for DFSMS/MVS\n** version 1.1, 1.2, 1.3 and higher.\n**\n** Messages come from the binder of varying lengths include longer\n** than 133 so we can't just blindly print the whole message asis.\n** The code below breaks up the input line link the Binder at 120\n** columns.\n**\n** After the first line, the left margin gets changed to 10 so text\n** text for a message on remaining lines are after the message id.\n** For example, a long message would look like:\n**\n** MSGID text text text text text text text (on line1)\n**       text text text (on line 2)\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nPDSRCMM  CSECT ,\n*\n** Standard O/S eyecatcher\n*\nPDSRCMM_EC    B    PDSRCMM_ECL(0,R15)     Bump past EyeCatcher\n              DC   AL1(L'PDSRCMM_ECLIT)   Length of eyecatcher\nPDSRCMM_ECLIT DC   C'PDSRCMM  - Msg Exit for PDSRCM'\n              DS   0H\nPDSRCMM_ECL   EQU  *-PDSRCMM_EC\n*\n         BAKR  R14,0                      Save registers\n         LAE   R12,0(R15,0)               Get base register\n         USING PDSRCMM,R12                Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         EREG  R0,R1                      Restore Registers R0 and R1\n*\n         LR    R10,R1                     Save input parmlist address\n         L     R1,MXPL_USERDATA-MXPL(R10) Get address of user data\n         L     R11,0(,R1)                 Get user data (work area)\n         USING PDSRCMD,R11                Get addressability\n         L     R1,MXPL_BUFFER-MXPL(R10)   Get addr of addr of msg buf\n         L     R3,0(,R1)                  Get address of message buffer\n*-Skip some silly messages if not in Binder-Debug mode\n         TM    PDSRCMD_IFLAG1,$PDSRCMD_IF1BDB Debug mode?\n         BO    MX$BDBX\n         CLC   PDSRCMD_DFARELS(4),=X'01010200' v1.3 or higher?\n         BH    MX$SMV13                   Yes, chk with new msg format\n         CLC   1(8,R3),=C'IEW2370W'       No data for $PRIVATE\n         BE    MX$X\n         CLC   1(8,R3),=C'IEW2371W'       GETD no data for IDRU\n         BE    MX$X\n         B     MX$BDBX\nMX$SMV13 DS    0H\n         CLC   2(8,R3),=C'IEW2370W'       No data for $PRIVATE\n         BE    MX$X\n         CLC   2(8,R3),=C'IEW2371W'       GETD no data for IDRU\n         BE    MX$X\nMX$BDBX  DS    0H\n*\n** Locate some common fields\n*\n         L     R1,MXPL_LINECNT-MXPL(,R10) Get addr of line count hw\n         LH    R4,0(R1)                   Get number of lines\n         L     R1,MXPL_CHARCNT-MXPL(,R10) Get addr of char count hw\n         LH    R5,0(R1)                   Number of characters on line\n*\n         LA    R13,PDSRCMD_MXSAVE\n         MVC   4(4,R13),=C'F1SA'          Set up Register Save Area\n         LA    R7,PDSRCMD_MXREC\n*\n** Message exit debugging\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB  Debugging mode?\n         BNO   MX$DBX                           Yes, do it\n         LR    R15,R7\n         MVI   0(R15),C' '\n         MVC   1(132,R15),0(R15)\n         MVC   1(29,R15),=C'DA$PDSR-C12I MSGEXIT - Lines='\n         LA    R15,1+29(R15)\n         L     R1,MXPL_LINECNT-MXPL(,R10) Get addr of line count hw\n         UNPK  0(5,R15),0(3,R1)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789abdef'\n         LA    R15,4(R15)\n         MVC   0(10,R15),=C', LineLen='\n         LA    R15,10(R15)\n         L     R1,MXPL_CHARCNT-MXPL(,R10) Get addr of char count hw\n         UNPK  0(5,R15),0(3,R1)\n         MVZ   0(4,R15),=8X'00'\n         TR    0(4,R15),=C'0123456789abdef'\n         LA    R15,4(R15)\n         MVC   0(8,R15),=C', DFSMS='\n         LA    R15,8(R15)\n         UNPK  0(9,R15),PDSRCMD_DFARELS(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789abdef'\n         MVI   8(R15),C' '\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LR    R1,R7                      Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n** R3 = message  R4 = Number of lines     R5 = Length of line\n         MVI   0(R7),C' '\n         MVC   1(132,R7),0(R7)\n         L     R9,PDSRCMD_PSRAREA         Locate to area\n         USING PSRAREA,R9                 Enable field access\nMX$DBML  DS    0H\n         XC    W_AREA(CMXDL),W_AREA       Initialize area\n         LR    R15,R3                     Get address of area to dump\n         LR    R0,R5                      Get length of msg line\n         LA    R1,9(R7)                   Get output location\n         STM   R15,R1,W_AREA+CMXD_ADDRESS-CMXD  Data, Length, Output\n         OI    W_AREA+CMXD_FLAG1-CMXD,$CMXD_F1ADDR\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2TSOV\n         BO    MX$DBDL\n         MVC   W_AREA+CMXD_OUTPUTL-CMXD(2),=AL2(132) <- TSO viewing\nMX$DBDL  DS    0H\n         LA    R1,W_AREA                  Locate work area\n         L     R15,EP_DA$MXD              -> DA$MXD E.P.A.\n         BASSM R14,R15                    Call DA$MXD\n         LR    R8,R15                     Save return code\n*\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LR    R1,R7                      Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         LTR   R8,R8                      Any more lines to do...\n         BNZ   MX$DBDL                    Thank you: May I have another\n*\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LR    R1,R7                      Locate record to print\n         MVI   0(R1),C' '                 Get blank\n         MVC   1(132,R1),0(R1)            ..propagate blank\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         AR    R3,R5                      Locate next line (if any)\n         BCT   R4,MX$DBML\nMX$DBX   DS    0H\n         L     R1,MXPL_BUFFER-MXPL(R10)   Get addr of addr of msg buf\n         L     R3,0(,R1)                  Get address of message buffer\n         L     R1,MXPL_LINECNT-MXPL(,R10) Get addr of line count hw\n         LH    R4,0(R1)                   Get number of lines\n         DROP  R9\n*\n** For the first Binder messages for this member:\n** - Print a message line with the member name so we know who it is for\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB\n         BO    MX$BLX\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2EMSG\n         BO    MX$BLX\n         OI    PDSRCMD_IFLAG2,$PDSRCMD_IF2EMSG\n*\n         LR    R15,R7                     Locate print record\n         L     R1,=V(PDSRCMC)             Locate constants CSECT\n         MVC   1(MSGCM18L,R15),MSGCM18-PDSRCMC(R1) Get message\n         LA    R15,1+MSGCM18L(R15)        Locate past message\n         MVC   0(8,R15),PDSRCMD_MODNAME+2 Get member name\n         BAS   R14,MX_EPM                 Ensure Printable Member name\n         LA    R0,#MX_EPML\n*-Instream Locate_First_Space routine (it does look familiar?)\nMX$M18L  DS    0H\n         CLI   0(R15),C' '                Blank?\n         BE    MX$M18X                    Yes, leave\n         LA    R15,1(R15)                 No, bump to next byte\n         BCT   R0,MX$M18L                 ..Repeat\nMX$M18X  DS    0H\n         MVI   0(R15),C':'                Append it\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LR    R1,R7                      Get input record location\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         LR    R1,R7                      Locate record to print\n         MVI   0(R1),C' '                 Get blank\n         MVC   1(132,R1),0(R1)            ..propagate blank\nMX$BLX   DS    0H\n         CLC   PDSRCMD_DFARELS(4),=X'01010200' v1.3 or higher?\n         BH    MX$V13                     Yes, use new format\n*\n** Set for the message format of DFSMS/MVS 1.1 and 1.2\n**\n** R3 = message  R4 = Number of lines     R5 = Length of line\n*\nMX$V11   DS    0H\n         LR    R9,R5                      Get length in odd register\n         SLR   R8,R8                      Clear for multiply\n         MR    R8,R4                      R9 = total message length\n         LR    R6,R3                      Locate start of message\n         CLI   0(R6),C' '                 Blank at start?\n         BNE   MX$V11BX                   No, continue\n         BCTR  R9,0                       Yes, decrement length by 1\n         LA    R6,1(R6)                   .....and bump past blank\nMX$V11BX DS    0H\n*-Trim trailing blanks from message\n         LR    R1,R6                      Locate start of message\n         AR    R1,R9                      Now find the end\nMX$V11TL DS    0H\n         CLI   0(R1),C' '                 Trailing blank\n         BNE   MX$V11TX                   No, leave\n         BCTR  R1,0                       Backup 1\n         BCT   R9,MX$V11TL                Process next byte\nMX$V11TX DS    0H\n         LA    R9,1(R9)                   Add back last byte\n         B     MX$FPM                     Now format and print message\n*\n** Set up for the new feature of DFSMS/MVS 1.3 where the message\n** buffer now has a halfword length value of the relevant part of\n** the message.\n*\nMX$V13   DS    0H\n         LH    R9,0(R3)                   Get length of input record\n         LTR   R9,R9                      Input length is zero?\n         BZ    MX$V11                     Yes, avoid divide by zero\n         LA    R6,2(R3)                   Locate first byte of record\n*\n** Format and print Message\n**\n** R9 has total length of message, R6 has start of message\n*\n#MXRECL  EQU   119                        Length to print on line\nMX$FPM   DS    0H\n         SLR   R2,R2                      Current line number\n         SLR   R8,R8                      Clear for divide\n         D     R8,=AL4(#MXRECL)           Calculate number of lines\n         LTR   R9,R9                      At least one full line?\n         BZ    MX$FPMLX                   Nope, shorter than #MXRECL\nMX$FPML  DS    0H\n         MVI   0(R7),C' '                 Get Blank\n         MVC   1(132,R7),0(R7)            ..Propagate it\n         LTR   R2,R2                      Check out line number\n         BZ    MX$FPMLM                   First one: use left margin\n         LA    R1,10\n         MVC   10(#MXRECL,R7),0(R6)       Move over a bit\n         B     MX$FPMLMX\nMX$FPMLM DS    0H\n         LA    R1,1\n         MVC   1(#MXRECL,R7),0(R6)        Get full line\nMX$FPMLMX DS   0H\n         LTR   R8,R8                      Anything on partial line?\n         BZ    MX$FPMLAX                  No\n         LR    R14,R7                     Locate start of line\n         LA    R14,#MXRECL(R14)           Locate to end of line\n         AR    R14,R1                     Add for left margin\n         MVI   1(R14),C'+'                Indicate continuation line\n         CH    R9,=H'1'                   On last line?\n         BNE   MX$FPMLAX                  No\n         CH    R8,=H'5'                   Makes sense to append?\n         BH    MX$FPMLAX                  No\n         LR    R15,R6                     Locate start of data\n         LA    R15,#MXRECL(R15)           Locate to partial line start\n         BCTR  R8,0                       Decrement for ex\n         EX    R8,MX$FPMLAM               Append partial to last full\n         SLR   R8,R8                      No more partial line\nMX$FPMLAX DS   0H\n*\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LR    R1,R7                      Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n         LA    R6,#MXRECL(R6)             Bump to next full line\n         LA    R2,1(R2)                   Increment line number\n         BCT   R9,MX$FPML                 Try it out\nMX$FPMLX DS    0H\n         LTR   R8,R8                      Check out partial line\n         BZ    MX$FPMX                    None, even divide\n         MVI   0(R7),C' '                 Get blank\n         MVC   1(132,R7),0(R7)            ..propagate it\n         BCTR  R8,0                       Decrement for EX\n         LTR   R2,R2                      Check out line number\n         BZ    MX$FPMLMP                  First one: use left margin\n         EX    R8,MX$FPMMPO               Move partial line out\n         B     MX$FPMLMPX\nMX$FPMLAM MVC  0(0,R14),0(R15)            ** Executed **\nMX$FPMMP  MVC  1(0,R7),0(R6)              ** Executed **\nMX$FPMMPO MVC  10(0,R7),0(R6)             ** Executed **\nMX$FPMLMP DS   0H\n          EX    R8,MX$FPMMP               Move partial line out\nMX$FPMLMPX DS  0H\n*\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LR    R1,R7                      Locate record to print\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\nMX$FPMX  DS    0H\n*\n** If in MSGEXIT debugging mode, print a blank line after msg(s)\n*\n         TM    PDSRCMD_IFLAG2,$PDSRCMD_IF2MXDB\n         BNO   MX$X\n         L     R0,PDSRCMD_PSRAREA         Locate work area\n         LR    R1,R7                      Locate record to print\n         MVI   0(R1),C' '                 Get blank\n         MVC   1(132,R1),0(R1)            ..propagate blank\n         L     R15,=V(PDSR$PSR)           Locate sysprint routine\n         BASR  R14,R15                    Print Sysprint Record\n*\n** Exit from PDSRCMM\n*\nMX$X     DS    0H\n         L     R1,MXPL_RC-MXPL(R10)       Locate return code\n         XC    0(4,R1),0(R1)              Clear return code (parm)\n         SLR   R15,R15                    Clear return code\n         PR    ,                          Return to caller\n*\n** Ensure that member (or any 8 byte area) has only valid characters\n**\n** Input: R15 - 8 byte member name with 18 bytes for hex conversion\n**\n** Note: We save R2 because TRT *DESTROYS* R2\n*\nMX_EPM   DS    0H\n         ST    R14,PDSRCMD_DOUBLE         Save return address\n         ST    R2,PDSRCMD_DOUBLE+4        Save this register (TRT)\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         TRT   0(8,R15),C_TABPRT-PDSR$C2(R1) Valid characters only?\n         BZ    MX$EPM$X                   Yes, leave\n         MVI   8(R15),C'/'                Insert delimiter\n         UNPK  9(9,R15),0(5,R15)          >>\n         MVZ   9(8,R15),MX_ZEROS          >>> Convert first 4 bytes\n         TR    9(8,R15),MX_HEXTABLE       >>\n         UNPK  9+8(9,R15),4(5,R15)        <<\n         MVZ   9+8(8,R15),MX_ZEROS        <<< Convert last 4 bytes\n         TR    9+8(8,R15),MX_HEXTABLE     <<\n         MVI   9+8+8(R15),C' '            Fix last byte\n         L     R1,=V(PDSR$C2)             -> Constants CSECT\n         TR    0(8,R15),C_TRTABM-PDSR$C2(R1) Translate to valid...\nMX$EPM$X EQU *\n         L     R2,PDSRCMD_DOUBLE+4        Restore this register\n         L     R14,PDSRCMD_DOUBLE         Get return address\n         BSM   0,R14                      Return to caller\n#MX_EPML EQU   8+1+16                     Max length\n*\n** Constants\n*\nMX_ZEROS    DC    X'00,00,00,00,00,00,00,00'\nMX_HEXTABLE DC    C'0123456789abcdef'\n*\n         LTORG ,                          Literals in PDSRCMM\n         DS    0D                         End of PDSRCMM\n*\n** Calculate length of module\n*\n#PDSRCMM      EQU    *-PDSRCMM\n#PDSRCMM_LEFT EQU 4096-#PDSRCMM\n         DROP  R12,R11\n*\n** Map the Message Exit Parmeter List (passed to the msg exit)\n*\nMXPL          DSECT ,\nMXPL_USERDATA DS    F                     -> Pointer to userdata\nMXPL_BUFFER   DS    F                     -> Pointer to Buffer\nMXPL_LINECNT  DS    F                     -> Pointer to Line count\nMXPL_CHARCNT  DS    F                     -> Pointer to Line length\nMXPL_MSGNUM   DS    F                     -> Pointer to Message number\nMXPL_SEVCODE  DS    F                     -> Pointer to Severity code\nMXPL_REASON   DS    F                     -> Pointer to Reason code\nMXPL_RC       DS    F                     -> Pointer to Return code\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Interal DSECTs\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Compiler XREF DSECT\n*\nCXREF        DSECT ,\nCXREF_TRANT  DS    XL(TRANTL)             T_TRANT entry (if there)\nCXREF_TYPE   DS    X                      Type of entry\n$CXREFT_S    EQU   0                      ..Static (from T_TRANT)\n$CXREFT_D    EQU   1                      ..Dynamic (added when found)\n             DS    0F\nCXREF_COUNTT DS    F                      Total count\nCXREF_COUNTL DS    F                      Library count\nCXREFL       EQU   *-CXREF                Length of entry\n*\n** Map the output CSECT line\n*\nOCL           DSECT ,\n              DS    C                     FBA\nOCL_MEMBER    DS    CL8\nOCL_ALIAS     DS    CL2\n              DS    C\nOCL_CSECT     DS    CL10\n              DS    C\nOCL_OFFSET    DS    CL8\n              DS    C\nOCL_LENGTH    DS    CL8\n              DS    C\nOCL_VARIABLE  EQU   *\n*\nOCL_TRAN      EQU   *\nOCL_TRANDATE  DS    C'06-MAR-1962'\n              DS    C\nOCL_TRANID    DS    XL(L'IDL_PID_ID)\n              DS    C\nOCL_TRANVER   DS    CL2\nOCL_TRANDOT   DS    C'.'\nOCL_TRANMOD   DS    CL2\n              DS    C\nOCL_TRANNAME  DS    XL(L'TRANT_NAME)\nOCL_TRANL     EQU   *-OCL_TRAN\nOCLSL         EQU   *-OCL\n*\n              ORG   OCL_VARIABLE\nOCL_HIST      EQU   *\nOCL_HISTDATE  DS    C'06-MAR-1962'\n              DS    C\nOCL_HISTDATA  DS    XL(L'IDU_DATA)\n              ORG   ,\n              ORG   OCL_VARIABLE+40\nOCL_AMODE     DS    C'AMODE ANY'\n              DS    CL2\nOCL_RMODE     DS    C'RMODE ANY'\nOCL_AML       EQU   *-OCL_AMODE\n              DS    CL4\nOCL_ALIGN     DS    C'Double Word'\n              ORG   ,\nOCLL          EQU   *-OCL\n              ORG   ,\n*\n** FLATOUT Memory (eyecatcher, RECFM=VB Record Desc Word and record)\n*\nFOM           DSECT ,\nFOM_EC        DS    CL8'FLATOUTR'\nFOM_RDW       DS    F\nFOM_RECORD    EQU   *\n*\n** FLATOUT record\n*\n#FLATOUT_Open   EQU X'01'\n#FLATOUT_Member EQU X'02'\n*\nFOR           DSECT ,\nFOR_TYPE      DS    C' '                  Type of record:\n$FORTYPE_C    EQU   C'C'                  ..CSECT\n$FORTYPE_D    EQU   C'D'                  ..DSN\n$FORTYPE_M    EQU   C'M'                  ..Member\n$FORTYPE_H    EQU   C'H'                  ..Header (ID) line\n$FORTYPE_DB   EQU   C'*'                  ..Debugging line\nFOR_SPACE1    DS    C' '\nFOR_LIBN      DS    C'999'                Overflow if over 999!!!\nFOR_SPACE2    DS    C' '\nFOR_START     EQU   *\n*\nFORC          EQU   *                     - - - - - - - - CSECT\nFORC_OCL      DS    XL(OCLSL-1)           CSECT info (static only)\nFORC_SPACE1   DS    C' '\nFORC_CSECT256 DS    XL256                 Up to first 256 bytes\nFORCL         EQU   *-FOR\n*\n              ORG   FOR_START\nFORH          EQU   *                     - - - - - - - - DSN\nFORH_NAME     DS    C'DA$PDSR'\nFORH_SPACE1   DS    C' '\nFORH_VER      DS    C'V&DAVER'\nFORH_SPACE2   DS    C' '\nFORH_ADATE    DS    C'&ASMDATE'\nFORH_SPACE3   DS    C' '\nFORH_ATIME    DS    C'&SYSTIME'\nFORHL         EQU   *-FOR\n              ORG   ,\n*\n              ORG   FOR_START\nFORD          EQU   *                     - - - - - - - - DSN\nFORD_VOL      DS    CL6\nFORD_SPACE1   DS    C' '\nFORD_DSN      DS    CL44\nFORDL         EQU   *-FOR\n              ORG   ,\n*\n              ORG   FOR_START\nFORM          EQU   *                     - - - - - - - - Member\nFORM_NAME     DS    CL8' '\nFORM_SPACE1   DS    C' '\nFORM_SIZE     DS    XL(L'DET_LSIZE)\nFORM_SPACE2   DS    C' '\nFORM_AMODET   DS    C'AMODE'\nFORM_AMODE    DS    CL2\nFORM_SPACE3   DS    C' '\nFORM_RMODET   DS    C'RMODE'\nFORM_RMODE    DS    CL3\nFORM_SPACE4   DS    C' '\nFORM_DATET    DS    C'DATE: '\nFORM_DATE     DS    XL(L'DET_LTD_DATE)\nFORM_SPACE5   DS    C' '\nFORM_ATTRT    DS    C'ATTR: '\nFORM_ATTR     DS    XL(L'DET_LATTR)\nFORML         EQU   *-FOR\n              ORG   ,\n*\n              ORG   FOR_START\nFORDB         EQU   *                     - - - - - - - - Debugging\nFORDB_TYPE    DS    CL8'Type'\nFORDB_VAR     EQU   *\nFORDBL        EQU   *-FOR\n              ORG   ,\n*\n** Map the PDSRCM Data area\n*\nPDSRCMD          DSECT ,\nPDSRCMD_RSA      DS    18F                Register Save Area\nPDSRCMD_ID       DS    CL8'PDSRCMD'       ID for dumps\nPDSRCMD_SUBRSA   DS    18F                Register Save Area 4 subs\n* = = = = = = = = = = = = = = = = = = = = Start of external fields.....\n*\n** These fields are modified by callers of PDSRCM\n*\nPDSRCMD_CALLT    DS    C' '               Call type:\n$PDSRCMD_CT_INIT EQU   C'I'               ..Initialization\n$PDSRCMD_CT_MEM  EQU   C'M'               ..Member call\n$PDSRCMD_CT_LIBS EQU   C'S'               ..Library Start\n$PDSRCMD_CT_LIBE EQU   C'E'               ..Library End\n$PDSRCMD_CT_TERM EQU   C'T'               ..Termination\nPDSRCMD_ALIAS    DS    C'-A'              ALIAS information\nPDSRCMD_FLAG1    DS    B'00000000'        Flag byte 1\n$PDSRCMD_F1TRAN  EQU   B'10000000'        ..Translator report?\n$PDSRCMD_F1HIST  EQU   B'01000000'        ..History report?\n$PDSRCMD_F1TEXT  EQU   B'00100000'        ..Looking at TEXT?\n*\n$PDSRCMD_F1DCB   EQU   B'00000001'        ..Use DCB not INCLLIB/MODNAME\n                 DS    0F\nPDSRCMD_PDS2     DS    F                  Address of PDS2 member area\nPDSRCMD_SUBRSAP  DS    F                  Address of SUBRSA\nPDSRCMD_PSRAREA  DS    F                  Print_Sysprint_Record Area\nPDSRCMD_DSNAME   DS    XL4                Dataset name for rpt heading\nPDSRCMD_VOLSER   DS    XL4                Volser for rpt heading\nPDSRCMD_INCLLIB  DS    H'8',CL8' '        DDNAME\nPDSRCMD_MODNAME  DS    H'8',CL8' '        Member name\nPDSRCMD_DCBPTR   DS    XL4                DCB pointer\nPDSRCMD_DEPTR    DS    XL4                Directory Entry Pointer\nPDSRCMD_DATE     DS    XL4                DA$DATE structure - Date\nPDSRCMD_TIME     DS    XL4                DA$DATE structure - Time\n*\n** These fields are modified by PDSRCM\n*\n                 DS    0F\nPDSRCMD_BINDER   DS    XL4                Binder entry pointer\nPDSRCMD_MZAPCNT  DS    XL4                Zap count for current member\nPDSRCMD_CSECTS   DS    XL4                Number of CSECTs\n* = = = = = = = = = = = = = = = = = = = = End of external fields.......\n*-Note: The rest of the fields in PDSRCM are \"Internal\" and should not\n*-be referenced/changed outside of PDSRCM.\n*\n                 DS    0F                 Message exit list:\nPDSRCMD_FUNC     DS    CL8' '             Current function\nPDSRCMD_WKTOKENI DS    CL8' WTOKEN='\nPDSRCMD_WKTOKEN  DS    XL8                Workmod Token\nPDSRCMD_DTOKENI  DS    CL8' DTOKEN='\nPDSRCMD_DTOKEN   DS    XL8                Dialog Token\nPDSRCMD_RETCODEI DS    CL4' RC='\nPDSRCMD_RETCODE  DS    XL4                Return code\nPDSRCMD_RSNCODEI DS    CL4'RSN='\nPDSRCMD_RSNCODE  DS    XL4                Reason code\nPDSRCMD_B_ESD    DS    H'5',C'B_ESD'      Class name for ESD\nPDSRCMD_B_IDRL   DS    H'6',C'B_IDRL'     Class name for IDR translator\nPDSRCMD_B_IDRU   DS    H'6',C'B_IDRU'     Class name for IDR user\nPDSRCMD_B_IDRZ   DS    H'6',C'B_IDRZ'     Class name for IDR Zap\nPDSRCMD_B_IDRB   DS    H'6',C'B_IDRB'     Class name for Binder ID\nPDSRCMD_B_TEXT   DS    H'6',C'B_TEXT'     Class name for TEXT\n                 DS    0F\nPDSRCMD_LIBC     DS    F                  Library count\nPDSRCMD_TRUNCC   DS    F                  Truncated CSECT count\nPDSRCMD_IGWASMS  DS    F                  EPA of IGWASMS routine\nPDSRCMD_FOA      DS    2F                 //FLATOUT record area\n                 DS    0F                 Message exit list:\nPDSRCMD_MESSAGE  DS    F                  ..Exit routine entry point\n                 DS    F                  ..User data for exit routine\n                 DS    F                  ..Message exit severity level\nPDSRCMD_EXITLIST DS    XL(CEXITLL)        Exit list\n                 DS    0F                 GETN for section names\nPDSRCMD_COUNTN   DS    F                  ..Number of sections returned\nPDSRCMD_COUNTNC  DS    F                  ..Current section processed\nPDSRCMD_CURSORN  DS    F                  ..Cursor value for GETN call\nPDSRCMD_TCOUNT   DS    F                  ..Total number of sections\n                 DS    0F                 GETD for ESD entries\nPDSRCMD_COUNTDE  DS    F                  ..Count of ESD entries\nPDSRCMD_COUNTDL  DS    F                  ..Count of IDL entries\nPDSRCMD_COUNTDU  DS    F                  ..Count of IDU entries\nPDSRCMD_CURSORDE DS    F                  ..Cursor value for GETD/ESD\nPDSRCMD_CURSORDL DS    F                  ..Cursor value for GETD/IDL\nPDSRCMD_CURSORDU DS    F                  ..Cursor value for GETD/IDU\n                 DS    0F                 Saved Registers:\nPDSRCMD_SAVEESD  DS    2F                 ..IEWBESD area\nPDSRCMD_SAVEBNL  DS    2F                 ..IEWBBNL area\nPDSRCMD_SAVEIDL  DS    2F                 ..IEWBIDL area\nPDSRCMD_SAVEIDU  DS    2F                 ..IEWBIDU area\nPDSRCMD_SAVEIDZ  DS    2F                 ..IEWBIDZ area\nPDSRCMD_SAVEIDB  DS    2F                 ..IEWBIDB area\nPDSRCMD_SAVETXT  DS    2F                 ..IEWBTXT area\n                 DS    0F                 Print_Report_Record:\nPDSRCMD_PRRRA    DS    F                  ..Return Address\nPDSRCMD_PRRHL    DS    CL133              ..Heading record\n                 DS    0F                 ..Translator Report:\nPDSRCMD_TRPRRPC  DS    F                    ..Page count\n                 DS    0F                   ..Max CSECT size:\nPDSRCMD_TRMSIZE  DS    F                      ..Size\nPDSRCMD_TRMSIZEN DS    CL8                    ..CSECT name\nPDSRCMD_TRMSIZEM DS    CL8                    ..Member name\n                 DS    0F                   ..Oldest CSECT:\nPDSRCMD_TRODATE  DS    XL(L'IDL_DATE_PROCESSED) Date\nPDSRCMD_TRODATEN DS    XL(L'OCL_CSECT)        ..CSECT name\nPDSRCMD_TRODATEM DS    CL8                    ..Member name\n*\nPDSRCMD_TRPRRLC  DS    X                    ..Line count\n                 DS    0F                 ..History Report:\nPDSRCMD_HIPRRPC  DS    F                    ..Page count\nPDSRCMD_HIPRRLC  DS    X                    ..Line count\n                 DS    0F                 $Member_Translator routine:\nPDSRCMD_MTRA     DS    F                  ..Return address\nPDSRCMD_MTSREG   DS    6F                 ..Save Regs 4,5,6,7,8,9\nPDSRCMD_MTRCXREF DS    2F                 ..Cross Reference table\n                 DS    0F                 $Member_History routine:\nPDSRCMD_MHIA     DS    F                  ..Return address\nPDSRCMD_MHSREG   DS    4F                 ..Save Regs 4,5,6,7\nPDSRCMD_MHCOUNTU DS    F                  ..Count of user entries\nPDSRCMD_MHCOUNTZ DS    F                  ..Count of zap entries\n                 DS    0F                 EditFullWordFlush\nPDSRCMD_EDITRA   DS    F                  ..Return address\n                 DS    0D                 Misc work areas:\nPDSRCMD_DOUBLE   DS    D                  ..Double word work area\nPDSRCMD_DOUBLE2  DS    2D                 ..Double Double word area\nPDSRCMD_PARMLIST DS    256X               Parameter list for calls\n                 DS    0F                 Msgexit (PDSRCMM):\nPDSRCMD_MXSAVE   DS    18F                ..Register Save Area\nPDSRCMD_MXREC    DS    CL133              ..Output record\n                 DS    0F                 Dump_Entry:\nPDSRCMD_DERA     DS    F                  ..Return address\nPDSRCMD_DESREG   DS    2F                 ..Save register\nPDSRCMD_DESREGA  DS    F                    ..Address of area\nPDSRCMD_DESREGL  DS    F                    ..Length of area\nPDSRCMD_DESREGI  DS    F                    ..ID string address\nPDSRCMD_DEREC    DS    CL133              ..Output record\n                 DS    0F\nPDSRCMD_DCBT     DS    XL(PDSRCMCDL)      DCB for DD=TRANRPT\nPDSRCMD_DCBH     DS    XL(PDSRCMCDL)      DCB for DD=HISTRPT\nPDSRCMD_DCBF     DS    XL(CMFMDCBVL)      DCB for DD=FLATOUT\nPDSRCMD_DFARELS  DS    XL(L'DFARELS)      DFSMS/MVS release level\nPDSRCMD_IFLAG    DS    C'IFLG'            Set for dumps\nPDSRCMD_IFLAG1   DS    B'00000000'        Internal Flag byte 1\n$PDSRCMD_IF1BDB  EQU   B'10000000'        ..Binder Debug Mode?\n$PDSRCMD_IF1INIT EQU   B'01000000'        ..Did we initialize?\n$PDSRCMD_IF1TRM  EQU   B'00100000'        ..Found Translator member?\n$PDSRCMD_IF1HIM  EQU   B'00010000'        ..Found History member?\n$PDSRCMD_IF1DMPA EQU   B'00001000'        ..Dump Areas?\n$PDSRCMD_IF1FT   EQU   B'00000100'        ..First translator?\n$PDSRCMD_IF1THR  EQU   B'00000010'        ..Printed Heading record?\n$PDSRCMD_IF1TTO  EQU   B'00000001'        ..Translator Table Overflow?\nPDSRCMD_IFLAG2   DS    B'00000000'        Internal Flag byte 2\n$PDSRCMD_IF2FSEC EQU   B'10000000'        ..First section?\n$PDSRCMD_IF2SD   EQU   B'01000000'        ..Did a good STARTD?\n$PDSRCMD_IF2EMSG EQU   B'00100000'        ..First error message?\n$PDSRCMD_IF2MEM  EQU   B'00010000'        ..Processed a member yet?\n$PDSRCMD_IF2MXDB EQU   B'00001000'        ..MSGEXIT debug?\n$PDSRCMD_IF2UDCB EQU   B'00000100'        ..Use DCB?\n$PDSRCMD_IF2TSOV EQU   B'00000010'        ..TSO viewing?\n$PDSRCMD_IF2FO   EQU   B'00000001'        ..//FLATOUT processing?\nPDSRCMD_IFLAG3   DS    B'00000000'        Internal Flag byte 2\n$PDSRCMD_IF3EC   EQU   B'10000000'        ..Eyecatcher Report?\n$PDSRCMD_IF3STR  EQU   B'01000000'        ..Simulate TranRpt?\n$PDSRCMD_IF3IVC  EQU   B'00100000'        ..Vendor CSECT?\n*\nPDSRCMD_RECOUT   DS    CL133              Output record\n                 DS    CL64               Slack\n                 DS    0H\nPDSRCMD_CSPRIVC  DS    XL2\nPDSRCMD_OCLCSECT DS    XL(L'OCL_CSECT)    Output CSECT name\n                 DS    0H\nPDSRCMD_SECTION  DS    H,1024X            Section Name\n                 DS    0D\nPDSRCMDL         EQU   *-PDSRCMD\n*\n.CCMX    ANOP ,\n         EJECT\n***********************************************************************\n***\n**       GETMAINed work area\n***\n***********************************************************************\n             SPACE 2\nWORKDS       DSECT ,\n             DS    18F                    Register Save Area\nSUBRSA       DS    18F                    Locate subroutine RSA\n             DS    0F                     Process_PDS\nPP_TMEM      DS    F                      ..Total members\nPP_NLIBS     DS    F                      ..Number of libraries\nPP_FMCOUNT   DS    F                      ..Find-Member count\nPP_REGS      EQU   *                      ..Registers\nPP_TIOTEL    DS    F                      ..TIOT entry length\nPP_TIOTEA    DS    F                      ..TIOT entry address\nPP_PDSBUF    DS    2F                     ..PDS Buffer length & addr\nPP_PDDN      DS    CL16' '                ..Processing File Name\nPP_ADDN      DS    CL8' '                 ..Allocated DDNAME\nPP_CCCNT     DS    F                      ..ConCatenation Count\nPP_DSUMA     DS    F                      ..Dataset Summary Area\n*                                         ..Orphan table\nPP_OT        DS    2F                       ..length, address\nPP_OTCP      DS    F                        ..Current position\nPP_OTLE      DS    F                        ..last entry\n*                                         ..Translator Table\nPP_TT        DS    2F                       ..length, address\nPP_TTLE      DS    F                        ..Last entry\nPP_FLAG1     DS    B'00000000'            ..Flag 1\n$PP_F1TIOT     EQU B'10000000'            ....TIOT processing?\n$PP_F1LNKLST   EQU B'01000000'            ....LNKLST?\n$PP_F1LPALST   EQU B'00100000'            ....LPALST?\n*\n             DS    0F                     Print_Report_Record\nPRR_RA       DS    F                      ..Return Address\nPRR_PC       DS    F                      ..Page Count\nPRR_LC       DS    H                      ..Line Count\nPRR_TITLE1   DS    CL133                  ..Title line 1\nPRR_TITLE2   DS    CL133                  ..Title line 2\nPRR_IHEAD1   DS    CL133                  ..ISPF heading line 1\nPRR_IHEAD2   DS    CL133                  ..ISPF heading line 2\nPRR_LHEAD1   DS    CL133                  ..Load heading line 1\nPRR_LHEAD2   DS    CL133                  ..Load heading line 2\nPRR_LHEAD3   DS    CL133                  ..Load heading line 3\n               DS    0F                   Read_BKLIDS_File\nRBF_PTR        DS    F                    ..Pointer to BKL C.B.\n*\n** DCB and file work areas\n*\n             DS    0F\nREPORT       DS    XL(C_DCBOL)            Report (DD=REPORT)\nZAPRPT       DS    XL(C_DCBOL)            Report (DD=ZAPRPT)\nECRPT        DS    XL(C_DCBOL)            Report (DD=ECRPT)\nCOBCRPT      DS    XL(C_DCBOL)            Report (DD=COBCRPT)\nSYSMEM       DS    XL(C_DCBML)            Member access\nSYSLIB       DS    XL(C_DCBDL)            Directory\nWRKFILE1     DS    XL(C_DCBOL)            Work file 1\nWRKFILE2     DS    XL(C_DCBOL)            Work file 2\nWRKFILE3     DS    XL(C_DCBOL)            Work file 3\n             DS    0F                     Process_Load_Module\nPLM_RA       DS    F                      ..Return Address\nPLM_DECB     DS    XL(C_DECBML)           ..DECB\n             DS    0F                     Sort_File\nSF_RA        DS    F\nA_PDSRCMD    DS    2F                     Addr & length of work area\n             DS    0F                     Ensure_Printable_Member\nEPM_REGS     DS    2F                     ..Save register area\n             DS    0F                     Print_Sysprint_Record\nPSR_RA       DS    F                      ..Return Address\nPSRAREA      DS    18F                    ..Save Area\nSYSPRINT     DS    XL(C_DCBOL)            ..Messages (DD=SYSPRINT)\nPSR_PC       DS    F                      ..Page count\nPSR_LC       DS    H                      ..Line count\nPSR_TITLE    DS    CL133                  ..Title line\n             DS    0F\nPARMLIST     DS    20F                    Parameter list\nDOUBLE       DS    D                      Double word\nDOUBLE2      DS    2D                     Double word * 2\n             ORG   DOUBLE2\nRACF_ENTRYL  DS    X                      ..Entry Length\nRACF_ENTRY   DS    CL8                    ..Entry\n             ORG   ,\n             DS    0F                     Ignore_Vendor_CSECT\nIVC_AREA     DS    2F                     ..Area length and address\n             DS    0F                     Entry Point:\nEP_DA$DATE   DS    F                      ..DA$DATE - Date Routine\nEP_DA$MXD    DS    F                      ..DA$MXD  - Hex dump routine\n*\n** DA#DATE work areas\n*\n             DS    0F\nW_ODGEUR11   DA#DATE DPE,OPREFIX=W_ODGEUR11,OSTR=YES,                  @\n               OSTRL=$DA#DATE_ODGEUR11,OTYPE=$DA#DATE_ODGEUR\nW_OTIMES8    DA#DATE DPE,OPREFIX=W_OTIMES8,OSTR=YES,                   @\n               OSTRL=$DA#DATE_OTIMES8,OTYPE=$DA#DATE_OTIMES\n             DS    0F\nW_IDJULC7    DA#DATE DPE,OPREFIX=W_IDJULC7,OSTR=YES,OSTRL=4\n             DS    0F\nEJ_IDJULP4   DA#DATE DPE,OPREFIX=EJ_IDJULP4,OSTR=YES,                  @\n               OSTRL=$DA#DATE_IDJULP4\nEJ_ODGEUR11A DA#DATE DPE,OPREFIX=EJ_ODGEUR11A,OSTR=YES,OSTRL=4\nEJ_ODDOW3A   DA#DATE DPE,OPREFIX=EJ_ODDOW3A,OSTR=YES,OSTRL=4\n*\n** Fields to zero out for each new PDS\n*\n*                                         Process_PDS_Directory\n             DS    0D\nPPD_CLR      EQU   *\nPPD_DIRBLKS  DS    F                      ..Directory blocks\nPPD_DIRBLKSU DS    F                      ..Directory blocks (Unused)\nPPD_RA       DS    F                      ..Process_PDS_Directory\nPPD_EOB      DS    F                      ..End of block\nPPD_NMEM     DS    F                      ..Number of members\nPPD_NEX      DS    F                      ..Number: non-executable\nPPD_NNSSTAT  DS    F                      ..Number: No ISPF Stats\nPPD_NAPF     DS    F                      ..Number: APF\nPPD_NLERR    DS    F                      ..Number: Load Errors\nPPD_NALIAS   DS    F                      ..Number: Aliases\nPPD_NUMEC    DS    F                      ..Number: Standard Eyecatcher\nPPD_NUMCOBCE DS    F                      ..Number: COBOL CICS Error\nPPD_NUMZAP   DS    F                      ..Number: Zapped modules\nPPD_NUMIVTM  DS    F                      ..Number: Int Vendor tbl mat\nPPD_SIZE     DS    F                      ..Total number of bytes/Lines\nPPD_IINIT    DS    F                      ..ISPF: Initial lines\nPPD_IMODL    DS    F                      ..ISPF: Modified lines\nPPD_TRKA     DS    F                      ..Allocated tracks\nPPD_ABEND    DS    F                      ..LOAD ABEND\nPPD_ABENDR   DS    F                      ..LOAD ABEND reason\nPPD_DIRENTL  DS    H                      ..Length of directory entry\nPPD_LSYS     DS    XL3                    ..Last system processed\nPPD_TTR      DS    XL3                    ..TTR for member access\nPPD_FLAG1      DS  B'00000000'            ..Flag 1\n$PPD_F1APF     EQU B'10000000'              ..APF library\n$PPD_F1ISPF    EQU B'01000000'              ..ISPF type processing?\n$PPD_F1LOAD    EQU B'00100000'              ..Load Library\n$PPD_F1CHKDUP  EQU B'00010000'              ..Check for duplicates?\n$PPD_F1MEMXREF EQU B'00001000'              ..Check for duplicates?\n$PPD_F1NEWHEAD EQU B'00000100'              ..Need new heading?\n$PPD_F1BLDLF   EQU B'00000010'              ..Need new heading?\n$PPD_F1RBF     EQU B'00000001'              ..Read BKLIDS file?\nPPD_FLAG2      DS  B'00000000'            ..Flag 2\n$PPD_F2SYNAD   EQU B'10000000'              ..SYNAD error on member?\n$PPD_F2LOADERR EQU B'01000000'              ..Load error?\n$PPD_F2BLKCNT  EQU B'00100000'              ..Just counting blocks?\n$PPD_F2NBLINFO EQU B'00010000'              ..Need Binder/LKED info?\n*\nPPD_CLRL     EQU   *-PPD_CLR\n*\nPPD_PDS        DS   0H                    ..BLDL area\nPPD_PDS_FF     DS   X'00,00'                ..Total number of entries\nPPD_PDS_LL     DS   X'00,00'                ..Length of the area\nPPD_PDS_ENTRY  DS   XL(#PDSENT)             ..Length of a pds entry\n#PDSENT        EQU  PDS2USRD-PDS2           ..-> Length of an entry\nPPD_PDS_USERD  DS   CL62                    ..User data\nPPD_PDS_ENTRYL EQU  *-PPD_PDS_ENTRY         ..Length of PDS entry\nPPD_PDSL       EQU  *-PPD_PDS               ..Length of PDS area\nPPD_PODCB      DS   XL(C_DCBPOL)         ..BLDL library\n*\n** Check for Duplicates\n*\n             ORG   PPD_CLR                Reuse area\n*                                         Check_For Duplicates\nCFD_NUM      DS    F                      ..Type\nCFD_MEMBER   DS    CL8                    ..Member name\nCFD_TYPE     DS    X                      ..Type\nCFD_FIRST    DS    X                      ..First time?\n             DS    0F                     Areas not in reused area\nCFD_RECOUT   DS    XL(SORTRECL)           Previous record\n             ORG   ,\n*\n** Returned data areas\n*\nWORKAREA     DS    0D\nAREAJFCB     DS    XL(JFCBLGTH)           JFCB return area\nAREADSCB     DS    CL96                   DSCB return area\nAREABLDL     DS    XL(BLDLAL)\nSYNADMSG     DS    CL78                   Error message from SYNAD\nWORKAREAL    EQU   *-WORKAREA\n*\n** Flags\n*\nLASTCC       DS    X                      Last Condition Code\n$WARN        EQU   4                      ..Warning\n$SEVERE      EQU   20                     ..Severe\nMAXCC        DS    X                      Maximum Condition Code\n*\n** Parse_Parameter_Card\n*\n                DS    0F\nPPC_R1ENTRY     DS    F                   R1 upon entry to DA$PDSR\nPPC_FLAG1       DS    B'00000000'         Parse Flag 1\n$PPC_F1NODET    EQU   B'10000000'         ..No Detail report records?\n$PPC_F1DATONLY  EQU   B'01100000'         ..Data only, no headings?\n$PPC_F1NOBREAK  EQU   B'00100000'         ..No break between systems?\n$PPC_F1CHKDUP   EQU   B'00001000'         ..Check for Duplicates?\n$PPC_F1MEMXREF  EQU   B'00000100'         ..Member Cross Reference?\n$PPC_F1SIMULATE EQU   B'00000010'         ..Simulate?\nPPC_FLAG2       DS    B'00000000'         Parse Flag 2\n$PPC_F2HELP     EQU   B'10000000'         ..Help information wanted?\n$PPC_F2LNKLST   EQU   B'01000000'         ..LNKLST?\n$PPC_F2LPALST   EQU   B'00100000'         ..LPALST?\n$PPC_F2DUMPDSCB EQU   B'00010000'         ..Dump DSCB?\n$PPC_F2DUMPBLDL EQU   B'00001000'         ..Dump BLDL results?\n$PPC_F2DUMPDIRE EQU   B'00000100'         ..Dump Directory entry?\n*-Put all LOADMOD flags in FLAG3 and only LOADMOD flags.\nPPC_FLAG3       DS    B'00000000'         Parse Flag 3\n$PPC_F3LOADMOD  EQU   B'10000000'         ..LOAD each module?\n$PPC_F3ECRPT    EQU   B'11000000'         ..EC report?     Need LOADMOD\n$PPC_F3COBCRPT  EQU   B'10100000'         ..COBOL CICS report?\n$PPC_F3ZAPRPT   EQU   B'10010000'         ..Zap report?\nPPC_FLAG4       DS    B'00000000'         Parse Flag 4\n$PPC_F4NTRANID  EQU   B'10000000'         ..No Translator ID convert?\n$PPC_F4TRANR    EQU   B'01000000'         ..CSECT Report?\n$PPC_F4HISTR    EQU   B'00100000'         ..History Report?\n$PPC_F4NOSMS    EQU   B'00010000'         ..Don't use DFSMS/MVS code?\n$PPC_F4ONLYF    EQU   B'00001000'         ..Only proccess by FINDMEM?\n$PPC_F4TSOVIEW  EQU   B'00000100'         ..TSO viewing (dumps mostly)?\n$PPC_F4NOSYSIN  EQU   B'00000010'         ..Don't try to read SYSIN?\n$PPC_F4FLATOUT  EQU   B'00000001'         ..Output to //FLATOUT?\nPPC_FLAG5       DS    B'00000000'         Parse Flag 5\n$PPC_F5IVCSECTS EQU   B'10000000'         ..Ignore Vendor CSECT stats?\n$PPC_F5IVCSECTF EQU   B'11000000'         ..Ignore Vendor CSECT full?\n$PPC_F5NVENDORL EQU   B'00100000'         ..No vendor list wanted\n$PPC_F5NIVENDOR EQU   B'00010000'         ..No internal Vendor Table?\n$PPC_F5NOEAGLE  EQU   B'00001000'         ..No Eagle?\n$PPC_F5EODC     EQU   B'00000100'         ..Report on EndOfDataCond?\n$PPC_F5CALLRACF EQU   B'00000010'         ..Report on EndOfDataCond?\n*\nPPC_IFLAG1      DS    B'00000000'         Internal Flag 1\n$PPC_IF1FMG     EQU   B'10000000'         ..FINDMEM was generic?\n$PPC_IF1DATEUS  EQU   B'01000000'         ..Date format: US?\n$PPC_IF1DATEISO EQU   B'00100000'         ..Date Format: ISO?\n$PPC_IF1DATEERR EQU   B'00010000'         ..Date Format error?\n$PPC_IF1DATESET EQU   B'00001000'         ..Date Format set?\n*\nPPC_DDPL        DS    X                   DDNAME prefix Length\nPPC_DDP         DS    CL7                 DDNAME prefix Value\n*\nPPC_FML         DS    X                   Find member (length)\nPPC_FM          DS    CL8                 Find member value\nPPC_WUNIT       DS    CL8                 Work unit for sort file\n                DS    0H\nPPC_LINECNT     DS    H                   Line count for files\nPPC_COL         DS    H                   Error column number\nPPC_NUM         DS    H                   Number of errors in parm\n                DS    0F                  OPEN exit\nOX_EXLST        DS    F                   ..EXLST\nOX_CODE         DS    F                   ..Abend Code\n                DS    0F                  Format_Open_ABEND_MSG\nFOAM_RA         DS    F                   ..Return Address\n*\n** Misc global areas\n*\nW_BCPLEVEL   DS    XL(L'CVTPRODN)         MVS (BCP) level\nW_DFARELS    DS    XL(L'DFARELS)          DFSMS/MVS release level\n             DS    0F                     Work\nW_FLAG1      DS    B'00000000'            ..Flag 1\n$W_F1REPORT  EQU   B'10000000'            ....Report file opened?\n$W_F1LRDATE  EQU   B'01000000'            ....Loaded DA$DATE?\n$W_F1LRMXD   EQU   B'00100000'            ....Loaded DA$MXD?\n$W_F1DFSMS   EQU   B'00010000'            ....DFSMS/MVS?\n$W_F1NOSMS   EQU   B'00001000'            ....DFSMS/MVS turned off?\n$W_F1LOADLIB EQU   B'00000100'            ....Processed any loadlibs?\n$W_F1APFLSTD EQU   B'00000010'            ....Processed any loadlibs?\n$W_F1APFDYN  EQU   B'00000001'            ....Found Dynamic APF?\nW_FLAG2      DS    B'00000000'            ..Flag 2\n$W_F2PDSUM   EQU   B'10000000'            ....Print Dataset Summary?\n$W_F2PDSUM1  EQU   B'01000000'            ....Print Dataset Sum: 1st?\n             DS    0D\nW_AREA       DS    XL512                  ..Work area\n             ORG   W_AREA                   ..Reuse area for $PPC\nPPC_RC       DS    F                          ..Return code\nPPC_BUFFER   DS    2F                         ..Buffer length and addr\nPPC_DATEFL   DS    X                          ..Date format Length\nPPC_DATEFV   DS    CL3                        ..Date format value\nPPC_OPTION   DS    X                          ..Option\nPPCSI_FLAG1  DS    B'00000000'                ..Flag 1\n$PPCSI_F1OIF EQU   B'10000000'                  ..Opened Input file?\n             DS    0H\nPPCSI_COL    DS    H                          ..first error column\nPPCSI_NUM    DS    H                          ..Number of errors\n             DS    0F\nPPCSI_DCB    DS    XL(C_DCBIL)                ..DCB for SYSIN\n             ORG   ,                        ..End of work area\nAPF_DYN      DS    2F\n             ORG   W_AREA\nAPF_LRETCODE DS    F\nAPF_LRSNCODE DS    F\n             ORG   ,\n             DS    0D                     Make GETMAIN/FREEMAIN Happy\n*\n** Output record\n*\n             DS    0D\nSORTREC      EQU   *                      Sort record\nSR_MEMBER    DS    CL8                    ..Number of library\n*\nSR_INIT      EQU   *                      ..Initialization area\nSR_NLIB      DS    XL2                    ..Number of library\nSR_DDNAME    DS    XL16                   ..DDNAME\nSR_VOLSER    DS    CL6                    ..Volume Serial\nSR_DSN       DS    CL44                   ..DSN\nSR_FLAG1     DS    X                      ..PPD_FLAG2 from detail rec\nSR_FLAG2     DS    X                      ..PPD_FLAG2 from detail rec\nSR_INITL     EQU   *-SORTREC              ..Length to initialize\nRECOUT       DS    CL133                  Detail record area\nSORTRECL     EQU   *-SORTREC\nSLACKR       DS    CL133                  Slack if we get carried away\nSLACKR2      DS    CL133                  Even more slack\n             DS    0D\nWORKDSL      EQU   *-WORKDS\n             EJECT ,\n***********************************************************************\n***\n**        Internal DSECTs\n***\n***********************************************************************\n         SPACE 2\n*\n** Map TRANTAB\n*\nPPTTR        DSECT ,\nPPTTR_FIRST  DS    CL8                    First member\n             DS    CL2\nPPTTR_LAST   DS    CL8                    Last member\n             DS    CL2\nPPTTR_COUNT  DS    CL6                    Count\nPPTTR_COUNTE EQU   *\nPPTTR_UL     EQU   *-PPTTR                Length to underline\n             DS    CL2\nPPTTR_ID     DS    CL8                    Translator ID\n             DS    CL2\n             DS    CL2\nPPTTR_NAME   EQU   *\nPPTTRL       EQU   *-PPTTR                Length of entry\n*\n** Map Orphan table\n*\nORPT         DSECT ,\nORPT_ANAME   DS    CL8\nORPT_ATTR    DS    XL3\nORPT_RNAME   DS    CL8\nORPT_RTTR    DS    XL3\nORPTL        EQU   *-ORPT\n*\n** Dataset Summary report line definition\n*\nDSUMH         DSECT ,                     Headers\nDSUMH_NAME    DS    C'DSUM'               ..Eyecatcher for dumps\nDSUMH_LEN     DS    F                     ..Length of area\nDSUMH_CURR    DS    F                     ..Current entry address\nDSUMH_I       EQU   *                     ..Init\nDSUMH_LLE     DS    F                       ..LNKLST extents\nDSUMH_NUM     DS    F                       ..Total number so far\nDSUMH_CNTTRKA DS    F                       ..Total tracks allocated\nDSUMH_CNTTRKU DS    F                       ..Total tracks used\nDSUMH_CNTMEM  DS    F                       ..Total members\nDSUMH_IL      EQU   *-DSUMH_I             ..Init length\nDSUMHL        EQU   *-DSUMH\n*\nDSUME         DSECT ,\nDSUME_MEMBERS DS    CL6\n              DS    C\nDSUME_TRKA    DS    CL6\n              DS    CL2\nDSUME_TRKU    DS    CL6\n              DS    C\nDSUME_EXTENTS DS    CL2\n              DS    C\nDSUME_ATTR    DS    CL7\n              DS    C\nDSUME_DSN     DS    CL44\n              DS    C\nDSUME_VOL     DS    CL6\n              DS    C\nDSUME_RECFM   DS    CL3\n              DS    C\nDSUME_DDNAME  DS    XL(L'PP_PDDN)\nDSUMEL        EQU   *-DSUME\n*\n** Output Detail line\n*\nDET          DSECT ,\nDETMEM       DS    CL8\n             DS    CL1\nDETALIAS     DS    CL11'SD 12345678'\n             DS    CL1\nDETADDR      DS    CL7\n             DS    CL1\n*\nDET_L        EQU   *\nDET_LSIZE    DS    CL6\n             DS    CL1\nDET_LTRAN    EQU   *\nDET_LTD      EQU   *\nDET_LTD_DATE DS    C'06-MAR-1962'\n             DS    CL1\nDET_LTD_DOW  DS    CL3\nDET_LTDL     EQU   *-DET_LTD\n             DS    CL1\nDET_LSSI     DS    CL8\n             DS    CL1\nDET_LMULT    EQU   *\nDET_LTNAME   DS    CL16\nDET_LTNAMEL  EQU   *-DET_LTNAME\n             DS    CL1\nDET_LMODE    EQU   *\nDET_LMODEA   DS    C'ADDR'\n             DS    CL1\nDET_LMODER   DS    C'RES'\nDET_LMODEL   EQU   *-DET_LMODE\n             DS    CL1\nDET_LCSECT   DS    CL8\n             DS    CL1\nDET_LATTR    DS    CL16\n             DS    CL1\nDET_LZAP     DS    CL4\n             DS    CL1\nDET_LEPA     DS    CL6\n             DS    CL1\nDET_LCODE    DS    CL4\nDET_LMULTL   EQU   *-DET_LMULT\n*\n             ORG   DET_LMULT\nDET_LMULTD   DS    C'|'\n             DS    C\nDET_LDD      DS    CL16\n             DS    C\nDET_LVOL     DS    CL6\n             DS    C\nDET_LDSN     EQU   *\nDET_LDSNL    EQU   132-(DET_LDSN-DET)\n             ORG   ,\n             ORG   DET_L\nDET_I        EQU   *\nDET_IVER     DS    C'00'\nDET_IVMD     DS    C'.'\nDET_IMOD     DS    C'00'\nDET_IVVMML   EQU   *-DET_IVER\n             DS    CL1\nDET_ICDATE   DS    C'06-MAR-1962 '\nDET_ICDATED  DS    C'DOW'\nDET_ICDATEL  EQU   *-DET_ICDATE\n             DS    CL1\nDET_ILDATE   DS    C'06-MAR-1962 '\nDET_ILDATED  DS    C'DOW'\nDET_IMULT    EQU   *+1\nDET_ILTIME   DS    C' HH:MM'\nDET_ILTODL   EQU   *-DET_ILDATE\n             DS    CL1\nDET_ISIZE    DS    CL6\n             DS    CL1\nDET_IINIT    DS    CL6\n             DS    CL1\nDET_IMODL    DS    CL6\n             DS    CL1\nDET_IUID     DS    CL7\nDET_IMULTL   EQU   *-DET_IMULT\nDET_IL       EQU   *-DET\n             ORG   DET_IMULT\n             DS    C\nDET_IMULTD   DS    C'|'\n             DS    C\nDET_IDD      DS    CL16\n             DS    CL1\nDET_IVOL     DS    CL6\n             DS    CL1\nDET_IDSN     EQU   *\nDET_IDSNL    EQU   132-(DET_IDSN-DET)\n             ORG   ,\n*\n** User Data: ISPF statistics (input)\n*\n**\nUDISPF       DSECT ,\nUDISPF_VER   DS    X                     Version\nUDISPF_MOD   DS    X                     Modification\n             DS    X'00,00'              Not used\nUDISPF_CDATE DS    X'00,00,00,00'        Creation Date\nUDISPF_LDATE DS    X'00,00,00,00'        Last Updated Date\nUDISPF_LTIME DS    X'00,00'              Last Updated time\nUDISPF_SIZE  DS    X'00,00'              Current size of member\nUDISPF_INIT  DS    X'00,00'              Initial size of member\nUDISPF_MODL  DS    X'00,00'              Number of modified lines\nUDISPF_UID   DS    CL7                   Userid\n*\n** BLDL area, See \"GC26-4014 Data Adminstration\" for more information\n*\nBLDLA        DSECT ,                     BLDL work area\nBLDLA_FF     DS    X'00,00'              ..Total number of entries\nBLDLA_LL     DS    X'00,00'              ..Length of the area\nBLDLA_NAME   DS    CL8' '                ..Name of module\nBLDLA_TTR    DS    X'00,00,00'           ..TTR\nBLDLA_K      DS    X'00'                 ..Count\nBLDLA_Z      DS    X'00'\nBLDLA_C      DS    X'00'\nBLDLA_UDATA  DS    CL62' '               ..User Data\nBLDLAL       EQU   *-BLDLA               Length of work area\n*\n** Print Summary Record - Title line\n*\nPSRT         DSECT ,\nPSRT_FBA     DS    C' '\nPSRT_PGM     DS    C'DA$PDSR'\n             DS    C' '\nPSRT_D1      DS    C'--'\n             DS    C' '\nPSRT_DESC    DS    XL(L'C_PSRTD)\n             DS    C' '\nPSRT_D2      DS    C'--'\n             DS    C' '\nPSRT_SIDD    DS    C'SYSID='\nPSRT_SID     DS    XL(L'CVTSNAME)\n             DS    C' '\nPSRT_D3      DS    C'--'\n             DS    C' '\nPSRT_TIME    DS    C'07:05 PM'\n             DS    C' '\nPSRT_DATE    DS    C'06-MAR-1990'\n             DS    C' '\nPSRT_D4      DS    C'--'\n             DS    C' '\nPSRT_PAGE    DS    C'Page'\n*\n** IDR Zap entry\n*\nIDRZAPE        DSECT ,\n               DS    X\nIDRZAPE_DATE   DS    X'89101F'\nIDRZAPE_NAME   EQU   *                   IDRDATA name\n*\n** COBCRPT output line\n*\nCOBCR          DSECT ,\n               DS    X\nCOBCR_MEMBER   DS    CL8' '\n               DS    C\nCOBCR_ALIAS    DS    C'-A'\n               DS    C\nCOBCR_TYPE     DS    C'VS_COBOL_II'\n               DS    CL3\nCOBCR_ERROR    DS    C'Error:'\n               DS    C\nCOBCR_INFO     EQU   *\n         END\n         EJECT\n***********************************************************************\n***\n**        Linkage editor cards - ASM.PARM='BATCH,...'\n***\n***********************************************************************\n         SPACE 2\n PUNCH ' ENTRY   DA$PDSR          '       Entry point\n PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Subroutine: Date routine\n PUNCH ' INCLUDE SYSLMOD(DA$MXD)  '       Subroutine: Mini-Hex-Dump\n PUNCH ' NAME    DA$PDSR(R)       '       Name of load module\n         END ,\n./ ADD NAME=DA$PDSRR 0100-02191-02191-1109-00657-00657-00000-DALCOCK\n/* REXX\n |\n | Name: DA$PDSRR\n |\n | Author: David Alcock\n |         dave@planetmvs.com\n |\n | Written: 13-JAN-1998\n |\n | Purpose: Process the \"FLATOUT\" file from the DA$PDSR assembler\n |          program.  This exec is intended for use in a batch job\n |          that processes the FLATOUT file created in a previous\n |          job step.  The information in the FLATOUT file is subject\n |          to being out of date. Although this also means that you\n |          could save a \"FLATOUT\" file as a snapshot for later\n |          comparison.\n |\n | Requirements:\n | - Output from the DA$PDSR assembler program: the sequential (flat)\n |   file cleverly called FLATOUT.\n | - The DISASM option requires an external disassembler, this exec\n |   currently has code for the IBM High Level Assembler Toolkit\n |   disassembler and the one from file 171 of the CBT tape.  Don't\n |   you like my \"off the shelf\" approach?\n |\n | Sample syntax:\n | - DA$PDSRR                    /* With no options does little now */\n | - DA$PDSRR DISASM AI=STCK     /* Assembler Instruction */\n | - DA$PDSRR DISASM AI=SVC___11 /* Search for \"SVC   11\" */\n | - DA$PDSRR DISASM MC=0A0B     /* Machine Code */\n | - DA$PDSRR DISASMT=HLASMT     /* override inst. default */\n | - DA$PDSRR DISASMT=CBT171     /* override inst. default */\n | - DA$PDSRR VERBOSE            /* override inst. default */\n |\n | Options:\n | - DISASM   - Invoke the disassembler. You should also supply one\n |              of the other disassembly options like AI=, MC=, etc\n |              so we have something to do.\n |\n |              As with all disassemblers, on any platform, they have\n |              some intelligence to figure out of in-line data. There\n |              is always a chance that a computer instruction could\n |              be missed.\n |\n |              The disassembler should be available in the LPA/LNKLST\n |              JOBLIB or STEPLIB...\n |\n | - DISASMT= - Override the installation default for the disassembler\n |              to invoke.  Currently \"HLASMT\" or \"CBT171\".\n |\n | - AI=xxx   - Assembler Instruction to search for in the disassembly\n |              listing.  You can put as many AI= parms as is needed\n |              but they do not take multiple args.\n |\n |              To search for complete assembler instructions, use an\n |              underscore where you want a space.  Since the CBT171\n |              disassembler doesn't use \"standard\" spacing you have\n |              to use different search strings for the two\n |              disassemblers.  Some examples for the TIME SVC:\n |\n |              - HLASMT disassembler: AI=SVC___11_\n |              - CBT171 disassembler: AI=SVC____11_\n |\n |                Note: Apply the trailing \"_\" to ensure that in the\n |                      example above, you don't trap \"SVC   119\".\n |\n | - MC=xxx   - Machine Code to search for in the disassembly listing.\n |              You can put as many MC= parms as is needed but they do\n |              not take multiple args.\n |\n |              When compared, the machine code from the disassembly has\n |              the spaces removed. So to search for \"58E4 0004\",\n |              specify \"MC=58E40004\".\n | - VERBOSE  - Be a Chatty Kathy\n */\n\nxdate = translate(date(),'-',' ')\nxtime = time()\nsay \"%DA$PDSRR - Starting execution on \"xdate\" at \"xtime\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Installation defaults\n ------------------------------------------------------------------- */\n\nworkunit = \"SYSDA\"       /* Unit name for work files */\nsysallda = \"SYSALLDA\"    /* Unit to get to every load library */\n\ndisasm_dtype = \"CBT171\"  /* Set default disassembler */\ndisasm_brc  = 0          /* Number of bad RCs           */\ndisasm_mbrc = 2          /* Max number of bad RCs       */\nxlibs.0 = 0\n\n/*---------------------------------------------------------------------\n | Global vars that are not installation or user specified\n ------------------------------------------------------------------- */\n\nxrc = 0            /* exit return code */\ndsname = \"\"        /* No SYSLIB allocated as yet */\nhlasm_type = \"\"    /* not set yet */\n\n/*---------------------------------------------------------------------\n | Check out the options\n ------------------------------------------------------------------- */\n\narg options\n\nopt_debug  = 0            /* debug = no */\nopt_disasm = 0            /* disasm = no */\nopt_verbose = 0           /* verbose = no */\nopt_echo    = 0           /* echo (disassembly output) = no */\ndisasm_mc = \"\"            /* machine code to search for */\ndisasm_ai = \"\"            /* assembler instructions to search for */\n\ndo i = 1 to words(options)\n\n   select\n     when word(options,i) == \"DISASM\"   then opt_disasm = 1\n     when word(options,i) == \"DEBUG\"    then opt_debug = 1\n     when word(options,i) == \"VERBOSE\"  then opt_verbose = 1\n     when word(options,i) == \"ECHO\"     then opt_echo = 1\n\n     when substr(word(options,i),1,8)  == \"DISASMT=\" then do\n          parse value word(options,i) with \"DISASMT=\" instr\n          disasm_type = instr\n          opt_disasm = 1 /* assume they want a disassembly */\n          end\n\n     when substr(word(options,i),1,3)  == \"AI=\" then do\n          parse value word(options,i) with \"AI=\" instr\n          disasm_ai = disasm_ai\" \"instr\n          end\n\n     when substr(word(options,i),1,3)  == \"MC=\" then do\n          parse value word(options,i) with \"MC=\" instr\n          disasm_mc = disasm_mc\" \"instr\n          end\n\n     otherwise\n          say \"%DA$PDSR - Unknown option was bypassed:\" ,\n              word(options,i)\n     end /* of select */\n\n   end /* of \"do i = 1 to words(options)\" */\n\n/*---------------------------------------------------------------------\n | Disassembly initializations\n ------------------------------------------------------------------- */\n\nif opt_disasm <> 1 then signal disasmx  /* avoid long DO...END */\n\n/*\n | Verify and set the disassembler type\n */\n\nif disasm_type == \"\" then disasm_type = hlasm_dtype\n\nselect\n  when disasm_type == \"HLASMT\" then do\n       disasm_ldd  = \"SYSLIB\"\n       disasm_mc = \"\" /* HLASMT doesn't give us machine code */\n       end\n  when disasm_type == \"CBT171\" then do\n       disasm_ldd  = \"DISMOD\"\n       end\n  otherwise\n     say \"%DA$PDSRR - The disassembler type is unrecognized, we\" ,\n         \"support:\"\n     say \"            - HLASMT ... High Level Assembler Toolkit\"\n     say \"            - CBT171 ... From the CBT tape, file 171\"\n     say \"%DA$PDSRR - Terminating without processing FLATIN\"\n     xrc = 8\n     signal theend\n  end /* of select */\n\n/*\n | Ensure that we have something to search for in the Disassembly\n | listing.\n */\n\nselect\n  when disasm_ai <> \"\" then nop\n  when disasm_mc <> \"\" then nop\n  otherwise\n     say \"%DA$PDSRR - You specified option DISASM but did not\" ,\n         \"provide either:\"\n     say \"            - AI=xxx ... Assembler Instructions\"\n     say \"            - MC=xxx ... Machine Code\"\n     say \"%DA$PDSRR - Hint: The High Level Assembler Toolkit doesn't\"\n     say \"            give us machine code along with the assembler\"\n     say \"            code so you can only supply assembler\" ,\n                      \"instructions.\"\n     say \" \"\n     say \"%DA$PDSRR - Terminating without processing FLATIN\"\n     xrc = 8\n     signal theend\n  end /* of select */\n\n/*\n | Inform the user what we are planning to do\n */\n\nsay \"%DA$PDSRR - Will invoke the \"disasm_type\" disassembler\" ,\n    \"and search for:\"\nif disasm_mc <> \"\" then ,\n   say \"          - Machine Codes:\" disasm_mc\nif disasm_ai <> \"\" then ,\n   say \"          - Assembler Instructions:\" disasm_ai\n\ndisasmx:\n/*---------------------------------------------------------------------\n | Map offset and lengths of fields in the input FLATIN record\n ------------------------------------------------------------------- */\n\n/*\n | These REXX statements created by program DA$ADATA\n | > assembly on 19-MAY-1997 at 06.56 PM\n | > output created on 31-JAN-1998 at 03:40 PM\n */\no_$FORTYPE_C = 195      /* x'000000C3' */\nl_$FORTYPE_C = 1\no_$FORTYPE_D = 196      /* x'000000C4' */\nl_$FORTYPE_D = 1\no_DUMMY = 0        /* x'00000000' */\nl_DUMMY = 1\no_FOM = 0        /* x'00000000' */\nl_FOM = 1\no_FOM_EC = 0        /* x'00000000' */\nl_FOM_EC = 8\no_FOM_RDW = 8        /* x'00000008' */\nl_FOM_RDW = 4\no_FOM_RECORD = 12       /* x'0000000C' */\nl_FOM_RECORD = 1\no_FOR = 0        /* x'00000000' */\nl_FOR = 1\no_FOR_LIBN = 2        /* x'00000002' */\nl_FOR_LIBN = 3\no_FOR_SPACE1 = 1        /* x'00000001' */\nl_FOR_SPACE1 = 1\no_FOR_SPACE2 = 5        /* x'00000005' */\nl_FOR_SPACE2 = 1\no_FOR_START = 6        /* x'00000006' */\nl_FOR_START = 1\no_FOR_TYPE = 0        /* x'00000000' */\nl_FOR_TYPE = 1\no_FORC = 6        /* x'00000006' */\nl_FORC = 1\no_FORC_CSECT256 = 84       /* x'00000054' */\nl_FORC_CSECT256 = 256\no_FORC_OCL = 6        /* x'00000006' */\nl_FORC_OCL = 77\no_FORC_SPACE1 = 83       /* x'00000053' */\nl_FORC_SPACE1 = 1\no_FORCL = 340      /* x'00000154' */\nl_FORCL = 1\no_FORD = 6        /* x'00000006' */\nl_FORD = 1\no_FORD_DSN = 13       /* x'0000000D' */\nl_FORD_DSN = 44\no_FORD_SPACE1 = 12       /* x'0000000C' */\nl_FORD_SPACE1 = 1\no_FORD_VOL = 6        /* x'00000006' */\nl_FORD_VOL = 6\no_FORDL = 57       /* x'00000039' */\nl_FORDL = 1\no_IDL_PID_ID = 0        /* x'00000000' */\nl_IDL_PID_ID = 10\no_OCL = 0        /* x'00000000' */\nl_OCL = 1\no_OCL_ALIAS = 9        /* x'00000009' */\nl_OCL_ALIAS = 2\no_OCL_CSECT = 12       /* x'0000000C' */\nl_OCL_CSECT = 10\no_OCL_LENGTH = 32       /* x'00000020' */\nl_OCL_LENGTH = 8\no_OCL_MEMBER = 1        /* x'00000001' */\nl_OCL_MEMBER = 8\no_OCL_OFFSET = 23       /* x'00000017' */\nl_OCL_OFFSET = 8\no_OCL_TRAN = 41       /* x'00000029' */\nl_OCL_TRAN = 1\no_OCL_TRANDATE = 41       /* x'00000029' */\nl_OCL_TRANDATE = 11\no_OCL_TRANDOT = 66       /* x'00000042' */\nl_OCL_TRANDOT = 1\no_OCL_TRANID = 53       /* x'00000035' */\nl_OCL_TRANID = 10\no_OCL_TRANL = 37       /* x'00000025' */\nl_OCL_TRANL = 1\no_OCL_TRANMOD = 67       /* x'00000043' */\nl_OCL_TRANMOD = 2\no_OCL_TRANNAME = 70       /* x'00000046' */\nl_OCL_TRANNAME = 8\no_OCL_TRANVER = 64       /* x'00000040' */\nl_OCL_TRANVER = 2\no_OCL_VARIABLE = 41       /* x'00000029' */\nl_OCL_VARIABLE = 1\no_OCLL = 78       /* x'0000004E' */\nl_OCLL = 1\no_OCLSL = 78       /* x'0000004E' */\nl_OCLSL = 1\no_TRANT_NAME = 10       /* x'0000000A' */\nl_TRANT_NAME = 8\n\n/*---------------------------------------------------------------------\n | Read the FLATIN file\n ------------------------------------------------------------------- */\n\n\"EXECIO * DISKR FLATIN (FINIS STEM flatin.\"\n\nsay \" \"\n\ndo f = 1 to flatin.0\n\n   rtype = substr(flatin.f,o_FOR_TYPE+1,1)\n\n   select\n     when rtype == \"M\" then iterate\n     when rtype == \"D\" then call flatout_dataset\n     when rtype == \"C\" then call flatout_csect\n     otherwise\n          say \"%DA$PDSRR - Unknown input //FLATOUT record, seq=\"f ,\n              \"record type=\"rtype\n          say \"          - Record:\" left(flatin.f,80)\n   end\n\n   end /* of \"do f = 1 to flatin.0\" */\n\nif dsname <> \"\" then \"FREE DA(\"dsname\")\"\n\n/*---------------------------------------------------------------------\n | Produce a summary of what we saw before going\n ------------------------------------------------------------------- */\n\nsay \" \"\nsay left(\"-\",80,\"-\")\nsay left(\"-\",80,\"-\")\nsay left(\"-\",80,\"-\")\nsay \" \"\nsay \" \"\nsay \"%DA$PDSRR -                         S u m m a r y\"\nsay \" \"\ndo i = 1 to xlibs.0\n   sdsn = word(xlibs.i,1)\n   svol = word(xlibs.i,2)\n   say \" \"\n   say \"DSNAME:\" left(sdsn,44) \"Volume:\" svol\n   say \" \"\n   if disasm_fmem.i <> \"\" then do\n      say \"  Search string matches:\"\n      say \" \"\n      k = words(disasm_fmem.i) / 2\n      do j = 1 to k by 2\n         say \"    Member=\"left(word(disasm_fmem.i,j),8) ,\n             \" CSECT=\"word(disasm_fmem.i,j+1)\n         end\n      end\n   end\n\nsignal theend\n\n/*---------------------------------------------------------------------\n | Flatout record type is Dataset\n ------------------------------------------------------------------- */\n\nflatout_dataset:\n\nsay \" \"\nsay left(\"-\",80,\"-\")\n\naddress TSO\nif dsname <> \"\" then \"FREE DA(\"dsname\")\"\n\ndsname = \"'\"strip(substr(flatin.f,o_FORD_DSN+1,l_FORD_DSN))\"'\"\nvolume = strip(substr(flatin.f,o_FORD_VOL+1,l_FORD_VOL))\nlibn   = strip(substr(flatin.f,o_FOR_LIBN+1,l_FOR_LIBN))\n\nx = xlibs.0\nx = x + 1\nxlibs.0 = x\nxlibs.x = dsname volume\ndisasm_fmem.x = \"\"\ndisasm_fmemc.x = 0\n\nsay \"%DA$PDSRR - Processing members for DSN=\"dsname \"on volume=\"volume\n\nif opt_disasm == 1 then do\n   \"ALLOCATE FILE(\"disasm_ldd\") DA(\"dsname\") SHR REUSE\" ,\n   \"         UNIT(\"sysallda\") VOLUME(\"volume\")\"\n   darc = rc\n   if darc <> 0 then do\n      say \"%DA$PDSRR - Allocation of load library failed, rc=\"darc\n      dsname = \"\"\n      end\n   end\n\nreturn\n\n/*---------------------------------------------------------------------\n | Flatout record type is CSECT\n ------------------------------------------------------------------- */\n\nflatout_CSECT:\n\nocl = substr(flatin.f,o_FORC_OCL+1,l_FORC_OCL)\nmember = substr(ocl,o_OCL_MEMBER,l_OCL_MEMBER)\ncsect  = substr(ocl,o_OCL_CSECT,l_OCL_CSECT)\n\nif opt_disasm == 1 then do\n   select\n     when disasm_type == \"HLASMT\" then call invoke_hlasmt_disasm\n     when disasm_type == \"CBT171\" then call invoke_cbt171_disasm\n     otherwise\n       nop /* should not happen as type has already been verified */\n       end\n   end\n\nreturn\n\n/*---------------------------------------------------------------------\n | Invoke the \"High Level Assembler\" disassembler\n |\n | Input: vars \"member\" and \"csect\" have our victims names\n ------------------------------------------------------------------- */\n\ninvoke_hlasmt_disasm:\n\nif dsname == \"\" then return   /* no dataset, no way */\n\nsay \"%DA$PDSRR - Calling the disassembler for member=\"member ,\n    \"CSECT=\"csect\naddress TSO\n\"NEWSTACK\"\nqueue member csect\nqueue \"\"\n\"EXECIO * DISKW SYSIN (FINIS\"\n\"DELSTACK\"\n\nhlasmt_parm = \"COPYRIGHTOK\"           /* Disassembler parameter      */\naddress ATTCHMVS \"ASMDASM\" hlasmt_parm\ndisasm_rc = rc\nif disasm_rc <> 0 | opt_verbose == 1 then ,\n   say \"%DA$PDSRR - Disassembler RC=\"disasm_rc \"for\" member csect\n\n\"EXECIO * DISKR SYSPRINT (FINIS STEM sysprint.\"\nif disasm_rc == 0 then do\n\n   found_code = 0\n\n   do i = 1 to sysprint.0\n      if found_code == 1 then do\n\n         if disasm_ai <> \"\" then do\n            do j = 1 to words(disasm_ai)\n               tai = word(disasm_ai,j)\n               ai = translate(tai,' ','_')\n               ail = length(ai)\n               if ai == substr(sysprint.i,11,ail) then do\n                  say \"%DA$PDSRR - Found assembler instruction: \"ai\n                  if opt_verbose == 1 then do\n                     say substr(sysprint.i,2,length(sysprint.i)-1)\n                     say \" \"\n                     end\n                  call update_found_list\n                  end\n               end\n            end\n\n         iterate\n         end\n\n      if substr(sysprint.i,11,5) == \"CSECT\" then do\n         found_code = 1\n         end\n\n      end\n\n   end\nelse do\n     if disasm_rc > 12 then disasm_brc = disasm_brc + 1\n     if disasm_rc < 0  then disasm_brc = disasm_brc + 1\n\n     if disasm_brc > disasm_mbrc then do\n        say \" \"\n        say \"%DA$PDSRR - Hit max number of disassembler bad return\" ,\n            \"codes, terminating exec\"\n        xrc = 12\n        signal theend\n        end\n\n     end\n\nif opt_echo == 1 then do\n   outdd = \"ECHO\"random()\n   \"allocate file(\"outdd\")\" ,\n             \"sysout(X) lrecl(137) blksize(1410) recfm(V B A)\"\n   arc = rc\n   if arc <> 0 then say \"%DA$PDSRR - allocate of DD=\"outdd \"failed\"\n   \"NEWSTACK\"\n   found_code = 0\n   do i = 1 to sysprint.0\n      if substr(sysprint.i,11,5) == \"CSECT\" then found_code = 1\n      if found_code == 1 then queue sysprint.i\n      end\n   \"EXECIO * DISKW \"outdd\" (FINIS\"\n   \"DELSTACK\"\n   end\nsay \" \"\nreturn\n\n/*---------------------------------------------------------------------\n | Invoke the \"CBT tape, file 171\" disassembler\n |\n | Input: vars \"member\" and \"csect\" have our victims names\n ------------------------------------------------------------------- */\n\ninvoke_cbt171_disasm:\n\nif dsname == \"\" then return   /* no dataset, no way */\nsay \"%DA$PDSRR - Calling the disassembler for member=\"member ,\n    \"CSECT=\"csect\n\naddress TSO\n\"NEWSTACK\"\nqueue \"LINES    55\"\nqueue \"MODULE   \"member\nqueue \"CSECT    \"csect\nqueue \"\"\n\"EXECIO * DISKW DISIN (FINIS\"\n\"DELSTACK\"\n\naddress ATTCHPGM DISASM\ndisasm_rc = rc\nif disasm_rc <> 0 | opt_verbose == 1 then ,\n   say \"%DA$PDSRR - Disassembler RC=\"disasm_rc \"for\" member csect\n\n\"EXECIO * DISKR DISPRINT (FINIS STEM disprint.\"\nif disasm_rc == 0 then do\n\n   found_code = 0\n\n   do i = 1 to disprint.0\n      if found_code == 1 then do\n         if substr(disprint.i,2,1) == \" \" then iterate\n         if substr(disprint.i,2,1) == \"DISASM\" then iterate\n\n         if disasm_mc <> \"\" then do\n            do j = 1 to words(disasm_mc)\n               imc = strip(word(disasm_mc,j))\n               imcl = length(imc)\n               fmc = strip(substr(disprint.i,12,14),'B')\n               if imc == substr(fmc,1,imcl) then do\n                  say \"%DA$PDSRR - Found machine code requested: \"imc\n                  if opt_verbose == 1 then do\n                     say substr(disprint.i,2,length(disprint.i)-1)\n                     say \" \"\n                     end\n                  call update_found_list\n                  end\n               end\n            end\n\n         if disasm_ai <> \"\" then do\n            do j = 1 to words(disasm_ai)\n               tai = word(disasm_ai,j)\n               ai = translate(tai,' ','_')\n               ail = length(ai)\n               if ai == substr(disprint.i,40,ail) then do\n                  say \"%DA$PDSRR - Found assembler instruction: \"ai\n                  if opt_verbose == 1 then do\n                     say substr(disprint.i,2,length(disprint.i)-1)\n                     say \" \"\n                     end\n                  call update_found_list\n                  end\n               end\n            end\n\n         iterate\n         end\n\n      if substr(disprint.i,4,4) == \"DISP\" then do\n         found_code = 1\n         end\n\n      end\n\n   end\nelse do\n     if disasm_rc > 12 then disasm_brc = disasm_brc + 1\n     if disasm_rc < 0  then disasm_brc = disasm_brc + 1\n\n     if disasm_brc > disasm_mbrc then do\n        say \" \"\n        say \"%DA$PDSRR - Hit max number of disassembler bad return\" ,\n            \"codes, terminating exec\"\n        xrc = 12\n        signal theend\n        end\n\n     end\n\n\nif opt_echo == 1 then do\n   outdd = \"ECHO\"random()\n   \"allocate file(\"outdd\")\"  ,\n             \"sysout(X) lrecl(137) blksize(1410) recfm(V B A)\"\n   \"NEWSTACK\"\n   found_code = 0\n   do i = 1 to disprint.0\n      if substr(disprint.i,4,4) == \"DISP\" then found_code = 1\n      if found_code then queue disprint.i\n      end\n   \"EXECIO * DISKW \"outdd\" (FINIS\"\n   \"DELSTACK\"\n   end\n\nsay \" \"\nreturn\n\n/*---------------------------------------------------------------------\n | Update found list - input vars: member csect\n |\n | For the current expectations of this exec, we just save a short\n | list of matchs we found and not detailed information so we try\n | to eliminate duplicates.\n ------------------------------------------------------------------- */\n\nupdate_found_list:\n\nx = xlibs.0\nz = words(disasm_fmem.x) / 2\ntmem = strip(member)\ndo y = 1 to z by 2\n   mem = strip(word(disasm_fmem.x,y))\n   if mem == tmem then return\n   end\ndisasm_fmem.x = disasm_fmem.x member csect\n\nreturn\n/*---------------------------------------------------------------------\n | Normal exit from the DA$PDSRR rexx exec\n ------------------------------------------------------------------- */\n\ntheend:\n\nxdate = translate(date(),'-',' ')\nxtime = time()\nsay \" \"\nsay \"%DA$PDSRR - Ending execution on \"xdate\" at \"xtime \"RC=\"xrc\nexit xrc\n\n/* | ---------EEEEEEEE---------NN-----NN---------DDDDDDD--------- |\n   | ---------EE---------------NNNN---NN---------DD----DD-------- |\n   | ---------EEEEE------------NN-NN--NN---------DD----DD-------- |\n   | ---------EE---------------NN---NNNN---------DD----DD-------- |\n   | ---------EEEEEEEE---------NN----NNN---------DDDDDDD--------- | */\n./ ADD NAME=DA$PDSRT 0100-01266-01266-1821-00163-00163-00000-DAVE\n/* REXX\n |\n | Name: DA$PDSRT\n |\n | Author: David Alcock\n |\n | Purpose: Read the DA$PDSR //FLATOUT file, and generate relinks\n |          JCL when a csect match is found\n |\n | Requirements: Output from the DA$PDSR program and the availablity\n |               of the PDS command from the CBT tape\n |\n | Disclaimer: This exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 2001+ by David Alcock\n |             All rights reserved.\n */\n\n/*---------------------------------------------------------------------\n | Validate input parameters\n ------------------------------------------------------------------- */\n\narg rcsect rlib rmem\nif rcsect == \"\" then do\n   say \"%DA$PDSRT - Replacing CSECT value not given, terminating\"\n   exit 12\n   end\nif rlib   == \"\" then do\n   say \"%DA$PDSRT - Replacing library value not given, terminating\"\n   exit 12\n   end\nif rmem == \"\" then do\n   say \"%DA$PDSRT - Replacing member value not given, terminating\"\n   exit 12\n   end\nrcsect = strip(rcsect)\nrlib   = strip(rlib)\nrmem   = strip(rmem)\n\naddress TSO\n\n\"NEWSTACK\"\n\n/*---------------------------------------------------------------------\n | If the user has given us some jobcard lines, add them at the front\n ------------------------------------------------------------------- */\n\n\"EXECIO * DISKR JOBCARD (FINIS STEM jobcard.\"\n\ndo i = 1 to jobcard.0\n   line = strip(jobcard.i,'L')\n   queue line\n   end\n\n/*---------------------------------------------------------------------\n | Read the //FLATOUT file from DA$PDSR and process entries\n ------------------------------------------------------------------- */\n\n\"EXECIO * DISKR SYSUT1 (FINIS STEM sysut1_file.\"\n\nldsn = \"\"\nlvol = \"\"\nstepnum = 0\ncompt = 0\ncompn = 0\n\ndo i = 1 to sysut1_file.0\n   select\n     when word(sysut1_file.i,1) == \"D\" then do\n          lvol = word(sysut1_file.i,3)\n          ldsn = word(sysut1_file.i,4)\n          say \"Found new library:\" ldsn \"on\" lvol\n          end\n     when word(sysut1_file.i,1) == \"C\" then do\n          lmem = word(sysut1_file.i,3)\n          lcsect = strip(word(sysut1_file.i,4))\n          say \"Comparing CSECTS: '\"rcsect\"' with '\"lcsect\"'\"\n          if rcsect = lcsect then do\n\n             compn = compn + 1\n             if compn == 20 then do\n                compn = 0\n                compt = compt + 1\n                queue \"//*\"\n                queue \"//** Compress the library\"\n                queue \"//*\"\n                queue \"//COMP\"left(compt,4) \"EXEC PGM=IEBCOPY\"\n                queue \"//SYSPRINT DD SYSOUT=*\"\n                queue \"//PDS      DD DISP=SHR,DSN=\"ldsn\n                queue \"//SYSIN    DD *\"\n                queue \" COPY INDD=PDS,OUTDD=PDS\"\n                queue \"/*\"\n                end\n\n             x = outtrap(\"XMSG.\",\"*\")\n             address TSO \"PDSE '\"ldsn\"' VOLUME(\"lvol\")\" ,\n                         \"MAP \"lmem\" RELINK\"\n             x = outtrap(\"off\")\n             if xmsg.0 = 0 then  do\n                say \"!!! no pdse output found for\" lmem\n                iterate\n                end\n             else say \"Found match! calling the freeware PDS command\"\n\n             do j = 1 to xmsg.0\n                if strip(xmsg.j) == \"\" then iterate\n                if substr(xmsg.j,1,2) == \"**\" then iterate\n                if substr(xmsg.j,1,8) == \"//SYSLIB\" then do\n                   queue \"//NEWLIB   DD  DISP=SHR,DSN=\"rlib\n                   end\n                if substr(xmsg.j,1,7) == \"//LKED \" then do\n                   stepnum = stepnum + 1\n                   queue \"//*\"\n                   queue \"//** New relink: \"lmem\n                   queue \"//*\"\n                   queue \"//LKED\"stepnum\"   EXEC  PGM=IEWL,\"\n                   iterate\n                   end\n\n                queue xmsg.j\n\n                if substr(xmsg.j,1,8) == \"//SYSLIN\" then do\n                   queue \" INCLUDE NEWLIB(\"rmem\")\"\n                   end\n\n                end\n             end\n          end\n     otherwise\n          say \"Skipping unhandled record for type: \" ,\n              word(sysut1_file.i,1)\n          end\n   end\n\n\n/*---------------------------------------------------------------------\n | Add a step to display that we actually did replace the CSECT\n ------------------------------------------------------------------- */\n\nqueue \"//*\"\nqueue \"//** Look in the //TRANRPT to ensure that CSECT \"rcsect\nqueue \"//** has the correct date\"\nqueue \"//*\"\nqueue \"//REPORT   EXEC PGM=DA$PDSR,TIME=1439,\"\nqueue \"//         PARM='TRANRPT,DATE=ISO'\"\nqueue \"//SYSPRINT DD SYSOUT=*\"\nqueue \"//REPORT   DD SYSOUT=*\"\nqueue \"//TRANRPT  DD SYSOUT=*\"\nqueue \"//BINDEROU DD DUMMY\"\nqueue \"//BINDERPR DD DUMMY\"\nqueue \"//SYSLIB01 DD DISP=SHR,DSN=\"ldsn\n\n/*---------------------------------------------------------------------\n | Finish things up and leave\n ------------------------------------------------------------------- */\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW SYSUT2 (FINIS\"\naddress TSO \"DELSTACK\"\n./ ADD NAME=DA$SPF2D 0100-01266-01266-1821-00889-00889-00000-DAVE\n***********************************************************************\n***                                                                 ***\n** Name: DA$SPF2D                                                    **\n**                                                                   **\n** Author = David Alcock :: dave@planetmvs.com\n**                                                                   **\n** Date: 03-JAN-1985                                                 **\n**                                                                   **\n** Attributes: Non-Reentrant, Non-Reusable, Non-Authorized           **\n**                                                                   **\n** Purpose: This program reads an ISPF panel source (non-CUA) and    **\n**          *attempts* to convert it to 3270 data stream.  The       **\n**          output is an complete assembler program that includes:   **\n**                                                                   **\n**            - Code to display the 3270 screen on a TSO terminal    **\n**            - The 3270 screen in Assembler format                  **\n**                                                                   **\n**          Once the program is run and an ISPF panel has been       **\n**          converted to 3270 data stream.  You should call the      **\n**          program on TSO to verify that it looks correct.  You     **\n**          can then copy the contents between SCRN1 and SCRN1L for  **\n**          use in your assembler program for the generated 3270     **\n**          code.                                                    **\n**                                                                   **\n**                                                                   **\n** Warning:  : This program *assumes* (yes ASSUMES) that the input   **\n**             ISPF panel has been thoughly debugged and verified    **\n**             in ISPF 7.2.                                          **\n**                                                                   **\n**             This program isn't meant to convert every kind of     **\n**             ISPF panel.  It is intended to be used by those       **\n**             who want to prototype a 3270 datastream via ISPF.     **\n**             I use it mainly for new non-SNA USS screens. Other    **\n**             types of text screens like help screens would also    **\n**             be ideal for prototyping in ISPF and then converted.  **\n**                                                                   **\n**             It doesn't attempt to exploit the all of the          **\n**             features of the \")INIT\", \")ATTR\", and \")PROC\"         **\n**             sections.                                             **\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n** Regrets: If I was starting to write this today, it would have     **\n**          been written in REXX - David Alcock                      **\n**                                                                   **\n** Non-IBM assembler MACROs:                                         **\n** o DA#ENTER...Entry housekeeping                                   **\n** o DA#LEAVE...Termination housekeeping                             **\n** o DA#EYEC....Build standard O/S module eyecatcher                 **\n**              (invoked by the DA#ENTER)                            **\n** o DA#REGS....Define registers (invoked by DA#ENTER)               **\n**                                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**                                                                   **\n** Sample JCL:\n**\n**       //SPF2DS   EXEC PGM=DA$SPF2D                                **\n**       //STEPLIB  DD DISP=SHR,DSN=MY.STEPLIB                       **\n**  IN:  //SYSUT1   DD DISP=SHR,DSN=MY.ISPPLIB(NEWUSS)               **\n**  OUT: //SYSUT2   DD DISP=SHR,DSN=MY.PDS.ASM(NEWUSS)               **\n**       //SYSPRINT DD SYSOUT=*                                      **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n&DAVER   SETC  '1.3'\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   30-NOV-1996 1.3 Renamed to DA$SPF2D;\n** DGAlcock   27-JUN-1995 1.2 Fix S0C4 (Parse_Label needed to save\n**                        regs); Some spagetti-logic refined; Put\n**                        debugging output to SYSPRINT;\n** DGAlcock   19-JUN-1995 1.1 Misc changes for lower case support;\n** DGAlcock   03-JAN-1985 1.0 Initial program created;\n***\n***********************************************************************\n         EJECT ,\n*\n** Define local macro INITFLD\n*\n MACRO ,\n INITFLD  &NAME,&VALUE\n MVI &NAME,&VALUE\n MVC &NAME+1(L'&NAME.-1),&NAME\n MEND ,\n         EJECT\n***********************************************************************\n***\n**   Module start\n***\n***********************************************************************\n         SPACE 2\nDA$SPF2D DA#ENTER 'V&DAVER Utility: Convert ISPF panel to 3270 D.S.',  @\n               RENT=YES,LV=DSAL,BASE=(12,11,10)\n         USING DSA,R13           ADDRESSABILITY TO WORK AREA\n*\n** Initialize areas and open files\n*\n         MVI   X_FLAG1,0                 INITIALIZE EXECUTION FLAG\n         XC    LINECTR(4),LINECTR        INITIALIZE LINE COUNTER\n         MVC   ATTRTAB(ATMASKL),ATMASK   INITIALIZE ATTRIBUTE TABLE\n*\n         OPEN  (SYSUT1,(INPUT))\n         OPEN  (SYSUT2,(OUTPUT))\n         OPEN  (SYSPRINT,(OUTPUT))\n*\n** Someone with a little ambition could do something like parse\n** PARM='NAME=screennme' or do a RDJFCB and get the input\n** member name (if any).  I'll just put something boring like\n** \"SCRN1\" by default.\n*\n         MVC   SCRNNAME(8),=CL8'SCRN1'\n*\n** Print \"Execution begins\" message on SYSPRINT\n*\n         INITFLD LINEOUT,C' '\n         MVC   LINEOUT+1(18),=C'Start of execution'\n         MVC   LINEOUT+1+18+1(L'DA$SPF2D_ECNAME),DA$SPF2D_ECNAME\n         LA    R15,LINEOUT+1+18+1+L'DA$SPF2D_ECNAME+1\n         MVC   0(10,R15),=C'Assembled:'\n         LA    R15,11(R15)\n#ECTODL  EQU   L'DA$SPF2D_ECDATE+L'DA$SPF2D_ECTIME\n         MVC   0(#ECTODL,R15),DA$SPF2D_ECDATE\n         PUT   SYSPRINT,LINEOUT\n         INITFLD LINEOUT,C' '\n         PUT   SYSPRINT,LINEOUT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Read input ISPF panel records (ISPPLIB)                     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nGETREC   EQU   *\n         GET   SYSUT1\n         LR    R2,R1                     SAve address of input record\n         INITFLD LINEOUT,C' '            Initialize\n         MVC   LINEOUT+12(80),0(R2)      Put input record on output\n         MVI   LINEOUT+10,C'>'           Indicate it\n*\n         CLI   X_TYPE,$XT_END            Hit the END?\n         BE    GR$SKIP                   Yes, ignore the rest\n*\n** Check for section types\n*\n         CLI   0(R2),C')'                Hit a new section?\n         BNE   GR$CSX\n         MVC   LINEOUT+1(7),=C'Section'\n         MVC   DOUBLE(4),1(R2)           Get \"xxxx\" from \")xxxx\"\n         OC    DOUBLE(4),=CL4' '         Convert to uppercase\n*\n         CLC   DOUBLE(4),=C'ATTR'\n         BNE   GR$CS$ATTRX\n         MVI   X_TYPE,$XT_ATTR\n* Note: could parse for \"default(???)\" here\n         B     GETRECB\nGR$CS$ATTRX DS 0H\n         CLC   DOUBLE(4),=C'BODY'\n         BNE   GR$CS$BODYX\n         MVI   X_TYPE,$XT_BODY\n         B     GETRECB\nGR$CS$BODYX DS 0H\n         CLC   DOUBLE(4),=C'PROC'\n         BNE   GR$CS$PROCX\n         MVI   X_TYPE,$XT_PROC\n         B     GETRECB\nGR$CS$PROCX DS 0H\n         CLC   DOUBLE(4),=C'END '\n         BNE   GR$CS$ENDX\n         MVI   X_TYPE,$XT_END\n         B     GETRECB\nGR$CS$ENDX DS 0H\n         MVI   X_TYPE,$XT_SKIP           Other kind we don't care about\n         B     GETRECB\nGR$CSX   EQU   *\n*\n** Process this input record by section type\n*\n         CLI   X_TYPE,$XT_PROC\n         BE    GR$PROC\n         CLI   X_TYPE,$XT_SKIP\n         BE    GR$SKIP\n         CLI   X_TYPE,$XT_BODY\n         BE    BODY\n         CLI   X_TYPE,$XT_ATTR\n         BE    GR$ATTR\n         MVI   X_TYPE,$XT_BODY           < WE ONLY REACH THIS POINT IF\n         B     BODY                      < THERE IS NO )ATTR SECTION\nGR$SKIP  EQU   *\n         MVC   LINEOUT+1(7),=C'Skipped'\n         B     GETRECB\nGR$PROC  EQU   *\n         MVC   LINEOUT+1(4),=C'Proc'\n         B     GETRECB\nGR$INIT  EQU   *\n         MVC   LINEOUT+1(4),=C'Init'\n         B     GETRECB\nGR$ATTR  EQU   *\n         MVC   LINEOUT+1(4),=C'Attr'\n* Note: could parse \"? TYPE(type) COLOR(colour)\" here...\n         B     GETRECB\n*\n** Bump to next record - print SYSPRINT first though\n*\nGETRECB  EQU   *\n         PUT   SYSPRINT,LINEOUT          Print record\n         B     GETREC\nEOF      EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Termination                                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n         INITFLD RECOUT,C' '                  -------|\n         MVC   LABEL(7),SCRNNAME                     |  PRINT\n         LA    R14,7                                 |  ENDING\n         LA    R15,LABEL                             |  LABEL\nENDLOOP  EQU   *                                     |  WITH\n         CLI   0(R15),X'40'                          |  LENGTH\n         BE    ENDLOOPX                              |  OF\n         LA    R15,1(R15)                            |  SCREEN\n         BCT   R14,ENDLOOP                           |  GENERATED\nENDLOOPX EQU   *                                     |  AS\n         MVI   0(R15),C'L'                           |  SCREEN-\n         MVC   OPER(3),EQU                           |  NAME\n         MVC   DATA(2),=C'*-'                        |  PLUS\n         MVC   DATA+2(7),SCRNNAME                    |  \"L\"\n         PUT   SYSUT2,RECOUT                   ------|\n         INITFLD RECOUT,C' '                          ----+\n         MVC   OPER(3),=C'END'                            | THE END\n         PUT   SYSUT2,RECOUT                          ----+\n*\n** Print ending on SYSPRINT\n*\n         INITFLD LINEOUT,C' '\n         PUT   SYSPRINT,LINEOUT\n*\n         LA    R15,LINEOUT+1\n         MVC   0(7,R15),=C'Trivia:'\n         LA    R15,8(R15)\n         L     R1,PSC_CC                   Get count\n         BAS   R9,EDITFWF\n         MVC   1(16,R15),=C'bytes compressed'\n         PUT   SYSPRINT,LINEOUT\n*\n         INITFLD LINEOUT,C' '\n         LA    R15,LINEOUT+1\n         MVC   0(21,R15),=C'Number of body lines:'\n         LA    R15,22(R15)\n         L     R1,X_BODYC                  Get count\n         BAS   R9,EDITFWF\n         PUT   SYSPRINT,LINEOUT\n*\n         INITFLD LINEOUT,C' '\n         MVC   LINEOUT+1(16),=C'End of execution'\n         PUT   SYSPRINT,LINEOUT\n*\n** Close files\n*\n         CLOSE (SYSUT1)\n         CLOSE (SYSUT2)\n         CLOSE (SYSPRINT)\n*\n** Exit housekeeping - return to caller\n*\n         DA#LEAVE ,                      Goodbye Cruel World\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       \")BODY\" PROCESSING                                          **\n**       R8: COLUMN NUMBER,  R3: LINE LOCATION PTR                   **\n***                                                                 ***\n***********************************************************************\n         SPACE  2\nBODY     DS    0H\n         L     R1,X_BODYC\n         LA    R1,1(R1)\n         ST    R1,X_BODYC\n*\n         MVC   LINEOUT+1(4),=C'Body'\n         MVC   PSC_LA(2),=X'00,00'         Init it out\n         XC    PSC_LAC(4),PSC_LAC          zero it out\n*\n** If this is the first time, put out TSO demo invocation code\n*\n         TM    X_FLAG1,$XF1_B1ST            First time ?\n         BO    B$1STX                       No, leave\n         OI    X_FLAG1,$XF1_B1ST            Mark it\n*\n         INITFLD RECOUT,C' '\n         MVI   LABEL,STAR\n         MVC   LABEL+3(HORNL),HORN\n         PUT   SYSUT2,RECOUT\n*\n         INITFLD RECOUT,C' '                         -----+\n         MVC   LABEL(6),=C'SCREEN'                        |\n         MVC   OPER(10),=C'DA#ENTER ,'                    |\n         MVC   COMMENT(18),=C'Entry Housekeeping'         |\n         PUT   SYSUT2,RECOUT                              |\n         INITFLD RECOUT,C' '                              |  DISPLAY\n         MVC   OPER(23),=C'STFSMODE ON,INITIAL=YES'       |\n         MVC   COMMENT(12),=C'Clear Screen'               |\n         PUT   SYSUT2,RECOUT                              |\n         INITFLD RECOUT,C' '                              |\n         MVC   OPER(25),=C'TPUT SCRN1,SCRN1L,FULLSCR'     |    THE\n         PUT   SYSUT2,RECOUT                              |\n         INITFLD RECOUT,C' '                              |\n         MVC   OPER(13),=C'TGET REPLY,50'                 |\n         PUT   SYSUT2,RECOUT                              |\n         INITFLD RECOUT,C' '                              |  SCREEN\n         MVC   OPER(12),=C'STFSMODE OFF'                  |\n         MVC   COMMENT(12),=C'Clear Screen'               |\n         PUT   SYSUT2,RECOUT                              |\n         INITFLD RECOUT,C' '                              |\n         MVC   OPER(13),=C'TPUT REPLY,50'                 |\n         PUT   SYSUT2,RECOUT                              |\n         INITFLD RECOUT,C' '                              |\n         MVC   OPER(10),=C'DA#LEAVE ,'                    |\n         MVC   COMMENT(17),=C'Exit Housekeeping'          |\n         PUT   SYSUT2,RECOUT                           ---+\n         INITFLD RECOUT,C' '                              |\n         MVC   LABEL(18),=C'REPLY    DS   CL50'           |\n         PUT   SYSUT2,RECOUT                           ---+\n*\n         INITFLD RECOUT,C' '             ------|\n         MVI   LABEL,STAR                      |  PRINT\n         PUT   SYSUT2,RECOUT                   |  3\n         MVC   LABEL+5(14),=C'Converted Scrn'  |  Comment\n         PUT   SYSUT2,RECOUT                   |  LINES\n         MVI   LABEL+5,C' '                    |\n         MVC   LABEL+6(13),LABEL+5             |\n         PUT   SYSUT2,RECOUT             ------|\n*\n         INITFLD RECOUT,C' '               -------|\n         MVC   LABEL(8),SCRNNAME                  |  PRINT\n         MVC   OPER(2),DS                         |   SCREEN NAME\n         MVC   DATA(2),=C'0H'                     |     EQUATE\n         PUT   SYSUT2,RECOUT               -------|\n         INITFLD RECOUT,C' '            --------|\n         MVC   OPER(2),DC                       |\n         MVI   DATA,C'X'                        |  PRINT\n         MVI   DATA+1,TICK                      |   COMMAND\n         MVC   DATA+2(2),=C'F5'                 |     TYPE\n         MVI   DATA+4,TICK                      |\n         MVC   COMMENT(11),=CL11'Erase/write'   |\n         PUT   SYSUT2,RECOUT            --------|\n         INITFLD RECOUT,C' '                   -------|\n         MVC   OPER(2),DC                             |\n         MVI   DATA,C'X'                              |  PRINT\n         MVI   DATA+1,TICK                            |  WRITE\n         MVC   DATA+2(2),=C'C3'                       |  CONTROL\n         MVI   DATA+4,TICK                            |  CHARACTER\n         MVC   COMMENT(3),=CL3'WCC'                   |\n         PUT   SYSUT2,RECOUT                    ------|\n         INITFLD RECOUT,C' '                      -------|\n         MVC   OPER(2),DC                                |\n         MVI   DATA,C'X'                                 |  ERASE\n         MVI   DATA+1,TICK                               |  THE\n         MVC   DATA+2(20),=C'11,40,40,3C,40,40,00'       |  SCREEN\n         MVI   DATA+22,TICK                              |  COMMAND\n         MVC   COMMENT(16),=C'Erase the screen'          |\n         PUT   SYSUT2,RECOUT                       ------|\nB$1STX   EQU   *\n*\n** Initialize\n*\n         L      R1,LINECTR                 Get line count\n         LA     R1,1(R1)                   Increment line count\n         ST     R1,LINECTR                 Save line count\n         LA     R3,BPL                     Get number of bytes per line\n         LR     R4,R2                      Locate input location\n*\n** Process the input record\n*\nB$RRL    EQU    *\n         CLI    0(R4),C' '                 CHECK FOR INITIAL SPACE\n         BNE    B$RRLX                     NO, NOT A BLANK, MOVE ON\n         LA     R4,1(R4)                   BUMP UP TO NEXT BYTE\n         BCT    R3,B$RRL                   SKIP THIS BYTE\n         B      BODYX                      WHOLE RECORD WAS BLANK...\nB$RRLX   EQU    *\n         LA     R8,BPL                     GET NUMBER OF BYTES PER LINE\n         LA     R8,1(R8)                   INCREMENT TO GET OUR OFFSET\n         SR     R8,R3                      BPL - LOCATION = COLUMN\n         INITFLD RECOUT,C' '               --|\n         MVI    RECOUT,STAR                  | PRINT COMMENT LINE\n         PUT    SYSUT2,RECOUT              --|\n         INITFLD RECOUT,C' '               BLANK OUT OUTPUT RECORD\n         BAS    R14,PUT_SBA                Spit out SBA\n*\n** TRIM TRAILING BLANKS OFF THE END OF LINE\n*\n         LA     R14,BPL                    GET BYTES PER LINE\n         LA     R15,BPL(R2)                POINT TO END OF LINE\n         BCTR   R15,0                      NEED TO START ONE BACK\nTRIMLOOP EQU    *\n         CLI    0(R15),X'40'               IS THIS BYTE A BLANK\n         BNE    TRIMX                      NO, MOVE ON\n         BCTR   R15,0                      YES, IGNORE HIM\n         BCT    R14,TRIMLOOP                    AND GO TEST NEXT ONE\nTRIMX    EQU    *\n         LA     R15,BPL                    GET BYTES PER LINE\n         SR     R15,R14                    R15 = BPL - TRAILING BLANKS\n         SR     R3,R15                     R3 = BYTES REMAINING ON LINE\n*\n** Process good part of line\n*\n         INITFLD RECOUT,C' '               BLANK OUT RECORD\nPBYTE1   EQU    *\n         LA     R9,40                      PRINT ONLY FIRST 40 BYTES\n         LA     R7,DATA+2                  PLACE TO PUT OUTPUT STUFF\n         NI     X_FLAG1,255-$XF1_OUTW    TURN OFF flag\n         NI     X_FLAG1,255-$XF1_ATTR    TURN OFF flag\nPBYTE2   EQU    *\n         BAL    R14,PROCESS_SPECIAL_CHARACTERS\n         LTR    R3,R3                      END OF THIS LINE?\n         BNP    BODYX                      YES, LEAVE\n         TM     X_FLAG1,$XF1_ATTR          WAS THERE AN ATTRIBUTE FOUND\n         BO     PBYTE1                     YES, REINITIALIZE\n         OI     X_FLAG1,$XF1_OUTW          TURN ON OUTPUT FLAG\n         MVC    0(1,R7),0(R4)              MOVE OUT A BYTE AT A TIME\n         LA     R4,1(R4)                   INCREMENT TO NEXT BYTE\n         LA     R7,1(R7)                   BUMP UP TO NEXT OUTPUT BYTE\n         BCTR   R3,0                       DECREMENT BYTE\n         LTR    R3,R3                      ARE WE OUT OF BUD?\n         BNP    BODYX                      YES, GUESS WE'RE OUT OF BEER\n         BCT    R9,PBYTE2                  GET NEXT BYTE\n         BAL    R5,PRTDATA                 PRINT THIS DATA RECORD\n         B      PBYTE1\nBODYX    EQU    *\n         BAL    R5,PRTDATA\n         B      GETRECB\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       PROCESS SPECIAL CHARACTERS                                  **\n***                                                                 ***\n***********************************************************************\nPROCESS_SPECIAL_CHARACTERS DS 0H\n         ST     R14,PSC_RA\n         LA     R6,ATTRTAB                 ADDR OF ATTRIBUTE TABLE\nPSC$L    EQU    *\n         CLI    0(R6),X'FF'                ARE WE AT THE END?\n         BE     PSC$X                      YES, GO TO EXIT\n         CLI    0(R4),TICK                 ---+\n         BNE    PSC$TX                        |  PROCESS\n         MVI    0(R7),TICK                    |    TICK\n         LA     R7,1(R7)                      |    MARKS\n         B      PSC$X                      ---+\nPSC$TX   EQU    *\n         CLI    0(R4),C'&&'                ---+\n         BNE    PSC$AX                        |\n         CLI    1(R4),C'&&'                   |\n         BNE    PSC$AT                        |    PROCESS\n         LA     R4,1(R4)                      |\n         BCTR   R3,0                          |    AMPERSAND\n         LTR    R3,R3                         |\n         BNP    PSC$X                         |    CHARACTERS\n         BAL    R14,PARSE_LABEL               |\n         B      PSC$X                         |\nPSC$AT   EQU    *                             |\n         MVI    0(R7),C'&&'                   |\n         LA     R7,1(R7)                      |\n         B      PSC$X                      ---+\nPSC$AX   EQU    *\n         CLC    0(1,R6),0(R4)              IS BYTE IN TABLE\n         BNE    PSC$LB                     NO, MOVE ON\n         TM     X_FLAG1,$XF1_OUTW          IS OUTPUT FLAG ON\n         BNO    PSC$PDX                    NO, MOVE ON\n*\n** See if it makes sense to put SBA bytes instead of a bunch of spaces\n*\n         LR     R15,R7                     Get output location\n         SH     R15,=H'4'                  Backup 4 bytes\n         CLC    0(4,R15),=CL8' '           Have at least 4 bytes?\n         BNE    PSC$CX                     No, don't bother\n         OI     X_FLAG1,$XF1_COMP          Turn on flag\n*        MVC    0(12,R7),=C'<-Compressed'\n         LR     R15,R7                     Re-init location\n         BCTR   R15,0                      Start out one below\n         LR     R14,R15                    Get End\n         LA     R1,DATA+3                  Get Start\n         SR     R14,R1                     Length = End - Start\nPSC$CL   EQU    *\n         CLI    0(R15),C' '                Blank?\n         BNE    PSC$CLX                    No, continue\n         L      R1,PSC_CC                  Get count\n         LA     R1,1(R1)                   Increment count by 1\n         ST     R1,PSC_CC                  Save count\n         BCTR   R15,0                      Yes, decrement by 1\n         BCT    R14,PSC$CL                 and process next byte\nPSC$CLX  EQU    *\n         MVI    1(R15),TICK                Insert ending tick\nPSC$CX   EQU    *\n*\n** Print current line\n*\n         BAL    R5,PRTDATA                 Print current data\n         TM     X_FLAG1,$XF1_COMP          Compressed?\n         BNO    PSC$PDX                    No, continue\n         NI     X_FLAG1,255-$XF1_COMP      Turn off flag\n         LR     R8,R4                      Get input byte\n         SR     R8,R2                      Calculate column\n         LA     R8,1(R8)                   Add one - not base 0\n         A      R8,PSC_LAC                 Add in attributes skipped\n         BAS    R14,PUT_SBA                Put SBA line\nPSC$PDX  EQU    *\n*\n** Put out attribute character\n*\n         CLI    3(R6),C'I'                  Input field\n         BE     PSC$SKT                     Yes, continue\n         CLC    PSC_LA(2),1(R6)             Same as previous?\n         BE     PSC$SKA                     Yes, skip it\nPSC$SKT  EQU    *\n*        MVC    PSC_LA(2),1(R6)             Save attribute byte\n         INITFLD RECOUT,C' '                BLANK OUT RECORD\n         MVC    OPER(2),DC                  MOVE IN ASM STUFF\n         MVI    DATA,C'X'                   HEX FIELD INDICATOR\n         MVI    DATA+1,TICK                 MOVE IN ASM STUFF\n         MVC    DATA+2(2),=CL2'1D'          ATTRIBUTE BYTE\n         MVI    DATA+4,C','                 GET COMMA BETWEEN HEX CHARS\n         MVC    DATA+5(2),1(R6)             MOVE IN BYTE FROM TABLE\n         MVI    DATA+7,TICK                 GET ENDING TICK\n         MVC    COMMENT(COMMENTL),3(R6)     DONT FORGET COMMENT\n         PUT    SYSUT2,RECOUT               PRINT THIS GUY\n         INITFLD RECOUT,C' '                BLANK OUT RECORD\n         B      PSC$SKX\nPSC$SKA  EQU    *\n         L      R1,PSC_LAC                  Get count\n         LA     R1,1(R1)                    Increment by 1\n         ST     R1,PSC_LAC                  Save it\nPSC$SKX  EQU    *\n         LA     R4,1(R4)                    Bump past attribute byte\n         BCTR   R3,0\n         LTR    R3,R3\n         BNP    PSC$X\n         OI     X_FLAG1,$XF1_ATTR          TURN ON OUTPUT FLAG\n         CLI    3(R6),C'I'                  INPUT RECORD?\n         BNE    PSC$X                       YES, MOVE ON\n*\n** Insert cursor\n*\n         TM     X_FLAG1,$XF1_HOME         Found home?\n         BO     PSC$HFX\n         OI     X_FLAG1,$XF1_HOME         We found our way home...\n         MVC    OPER(2),DC                  MOVE IN ASM STUFF\n         MVI    DATA,C'X'                   HEX FIELD INDICATOR\n         MVI    DATA+1,TICK                 MOVE IN ASM STUFF\n         MVC    DATA+2(2),=CL2'13'          ATTRIBUTE BYTE\n         MVI    DATA+4,TICK                 GET COMMA BETWEEN HEX CHARS\n         MVC    COMMENT(13),=C'Insert Cursor'\n         PUT    SYSUT2,RECOUT               PRINT THIS GUY\n         INITFLD RECOUT,C' '                BLANK OUT RECORD\nPSC$HFX  EQU    *\n*\n** Parse label\n*\n         BAL    R14,PARSE_LABEL             PUT LABEL ON DATA FIELD\n         B      PSC$X                       GOTO EXIT\nPSC$LB   EQU    *\n         LA     R6,ATENTRYL(R6)             BUMP UP TO NEXT ENTRY\n         B      PSC$L                       TEST NEXT BYTE\n*\n** Common exit from Process_Special_Characters\n*\nPSC$X    EQU    *                           COMMON EXIT\n         L      R14,PSC_RA\n         BR     R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       PARSE LABEL                                                 **\n***                                                                 ***\n***********************************************************************\nPARSE_LABEL DS 0H\n         ST     R14,PL_RA                 SAVE RETURN ADDRESS\n         STM    R5,R7,PL_SREGS            Save registers\n*\n** Put out line with field name\n*\n         LA     R5,RECOUT\n         XR     R6,R6\n         LA     R7,8\nPLL1     EQU    *\n         CLI    0(R4),C'+'                 IS THIS AN ENDING CHARACTER\n         BE     PLX                        YES, WE GOT WHAT WE WANT\n         LA     R6,1(R6)                   ADD 1 TO BYTE COUNT\n         MVC    0(1,R5),0(R4)              MOVE OUT A BYTE AT A TIME\n         LA     R4,1(R4)                   NEXT BYTE ON INPUT LINE\n         BCTR   R3,0                       ---+\n         LTR    R3,R3                         |  CHECK FOR END-OF-INPUT\n         BNP    PLX                        ---+\n         BCTR   R7,0                       -------+\n         LTR    R7,R7                             | PAST 8 BYTE NAME?\n         BNP    PLL1                       -------+\n         LA     R5,1(R5)                   NEXT BYTE ON OUTPUT LINE\n         B      PLL1\nPLX      EQU    *\n         OC     RECOUT(8),=CL8' '       Make label uppercase\n         MVC    OPER(2),DS              DEFINE STORAGE\n         MVC    DATA(2),CL              ..OF CHARACTER LENGTH ???\n         CVD    R6,DOUBLE               CHANGE TO RIGHT FORMAT 4 EDIT\n         MVC    WRKFLD(12),EDPAT        GET THE EDIT PATTERN\n         LA     R1,WRKFLD+11            FIND THE SIGNIFICANT DIGIT\n         EDMK   WRKFLD,DOUBLE+2         EDIT THE PACKED FIELD\n         LA     R2,WRKFLD+12            FIND THE END OF WRKFLD\n         SR     R2,R1                   GET LENGTH W/O LEADING SPACES\n         BCTR   R2,0                    DECREMENT FOR EX INSTRUCTION\n         EX     R2,MOVELEN              MOVE THE LENGTH TO\n         PUT    SYSUT2,RECOUT           PRINT VARIABLE OUTPUT\n         INITFLD RECOUT,C' '            BLANK OUT RECORD\n         LM     R5,R7,PL_SREGS          Restore registers\n         L      R14,PL_RA               GET RETURN ADDRESS\n         BR     R14                     RETURN TO SENDER\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Insert new SBA code                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPUT_SBA  EQU   *\n         ST     R14,PSBA_RA\n*\n         INITFLD SBALINE,C' '\n         MVC    SBALINE+O_OPER(2),DC       MOVE IN OPERATION TYPE\n         MVI    SBALINE+O_DATA,C'X'        TELL ASSEMBLER THIS IS HEX\n         MVI    SBALINE+O_DATA+1,TICK      PUT IN APOSTROPHE\n         MVC    SBALINE+O_DATA+2(2),=C'11' DATASTREAM ADDRESS\n         L      R1,LINECTR\n         LR     R15,R1                     GET ROW NUMBER\n         BCTR   R15,0                      DECREMENT BY ONE\n         MH     R15,=H'80'                 GET NUMBER OF BYTES PER LINE\n         LR     R14,R8                     GET COLUMN NUMBER\n         BCTR   R14,0                      DECREMENT TO GET RITE ADDR\n         AR     R15,R14                    R15 <- BINARY OFFSET\n*\n         LR     R14,R15                    MOVE TO WORK REGISTER\n         STC    R14,OFFREL0+1              SAVE FOR LATER\n         SRL    R14,6\n         STC    R14,OFFREL0\n         NI     OFFREL0+1,X'3F'\n         TR     OFFREL0(2),TAB             FIND OUT DATASTREAM ADDRESS\n         LA     R15,OFFREL0                GET PURE HEX VALUES\n         UNPK   DOUBLE(5),0(3,R15)         INITIALIZE FOR CONVERSION\n         MVZ    DOUBLE(8),=XL8'0'          CLEAR OUT\n         TR     DOUBLE(8),HEXTAB           CONVERT TO PRINTABLE HEX\n         MVI    SBALINE+O_DATA+4,C','      GET FIRST COMMA B4 LOCATION\n         MVC    SBALINE+O_DATA+5(2),DOUBLE GET FIRST HEX CHARACTERS\n         MVI    SBALINE+O_DATA+7,C','      PUT IN COMMA AFTER FIRST HEX\n         MVC    SBALINE+O_DATA+8(2),DOUBLE+2 GET SECOND HEX CHARACTERS\n         MVI    SBALINE+O_DATA+10,TICK     PUT ENDING TICK\n*\n         LA     R15,SBALINE+O_COMM         Locate output\n         MVC    0(6,R15),=C'Locate'        Move in text\n         LA     R15,7(R15)                 Bump past it\n         L      R1,LINECTR                 Get line number\n         BAS    R9,EDITFWF                 Edit line number\n         MVI    0(R15),C','                Put in comma\n         LA     R15,2(R15)                 Bump past comma\n         LR     R1,R8                      Get column\n         BAS    R9,EDITFWF                 Edit column number\n*\n         PUT    SYSUT2,SBALINE             Print line\n*\n** Return to caller\n*\n         L      R14,PSBA_RA\n         BSM    0,R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Print Data                                                  **\n**                                                                   **\n**       Input: R7 has place on output line                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPRTDATA  EQU    *\n         MVC    OPER(2),DC                 Get DC\n         MVI    DATA,C'C'                  Character\n         MVI    DATA+1,TICK                Starting tick\n         TM     X_FLAG1,$XF1_COMP          Compressed?\n         BO     PD$TICKX                   Yes, already have tick...\n         MVI    0(R7),TICK                 Move in ending tick\nPD$TICKX EQU    *\n         CLI    DATA+2,TICK                ---+\n         BNE    PD$OUT                        | Did we actually\n         CLI    DATA+3,TICK                   | produce a good line?\n         BNE    PRTDATAX                   ---+\nPD$OUT   EQU    *\n         PUT    SYSUT2,RECOUT                   PRINT THIS RECORD\nPRTDATAX EQU    *\n         INITFLD RECOUT,C' '\n         BR     R5\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Misc Internal subroutines                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      Check for zero\n         BZ    EDITFWF0                   Yes, save cpu time\n         CVD   R1,DOUBLE                  No, convert to packed\n         LA    R1,DOUBLE2+14              Locate Sig digit\n         MVC   DOUBLE2(15),EDITFWFP       Move in edit pattern\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,EDITFWFM               Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '                Insert space after number\n         BSM   0,R9                       Return to caller\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Insert zero\n         LA    R15,1(R15)                 Bump past zero\n         BSM   0,R9                       Return to caller\n*\n** Point Register 15 to the first blank in a string\n** Input:  R0  - Maximum length of the string\n**         R15 - String\n** Output: R15 - First space in the string\n*\nLOCATE_FIRST_SPACE DS 0H\n         CLI   0(R15),C' '                Blank?\n         BE    LFS$X                      Yes, leave\n         LA    R15,1(R15)                 No, bump to next byte\n         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat\nLFS$X    EQU   *\n         BSM   0,R14                      Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants and equates                                       **\n***                                                                 ***\n***********************************************************************\n         SPACE  2\nHORN     DC    C'This source was created by the DA$SPF2D program'\nHORNL    EQU   *-HORN\nDC       DC    CL2'DC'\nDS       DC    CL2'DS'\nCL       DC    CL2'CL'\nEQU      DC    CL3'EQU'\nMOVELEN  MVC   DATA+2(0),0(R1)\nHEXTAB   DC    C'0123456789ABCDEF'\nEDPAT    DC    X'40,20,20,20,20,20,20,20,20,20,21,20'\n*\n*        THIS TABLE COPIED FROM PAGE 7-14, MANUAL NUMBER: GA23-0061-0\n*        \"3274 CONTROL UNIT DESCRIPTION AND PROGRAMMER'S GUIDE\"\n*\nTAB      EQU   *\n         DC    X'40,C1,C2,C3,C4,C5,C6,C7,C8,C9'\n         DC    X'4A,4B,4C,4D,4E,4F'\n         DC    X'50,D1,D2,D3,D4,D5,D6,D7,D8,D9'\n         DC    X'5A,5B,5C,5D,5E,5F'\n         DC    X'60,61,E2,E3,E4,E5,E6,E7,E8,E9'\n         DC    X'6A,6B,6C,6D,6E,6F'\n         DC    X'F0,F1,F2,F3,F4,F5,F6,F7,F8,F9'\n         DC    X'7A,7B,7C,7D,7E,7F'\n*\n*        ATTRIBUTE TABLE MASK\n*\nATMASK   EQU   *                    ....+....1....+....2\n         DC    C'%',C'E8',C'O',CL20'ATTR: Prot high int'\n         DC    C'+',C'E4',C'O',CL20'ATTR: Prot Low int'\n         DC    C'_',C'C5',C'I',CL20'ATTR: Unprotected'\n         DC    X'FF'\nATMASKL  EQU   (*-ATMASK)\nCOMMENTL EQU   20\nATENTRYL EQU   COMMENTL+4\n         EJECT\n*\n*        PROGRAM EQUATES\n*\nTICK     EQU   X'7D'\nSTAR     EQU   C'*'\nBPL      EQU   80\n*\nO_LABEL  EQU   0\nO_OPER   EQU   9\nO_DATA   EQU   15\nO_COMM   EQU   49\n*\nLABEL    EQU   RECOUT+O_LABEL\nOPER     EQU   RECOUT+O_OPER\nDATA     EQU   RECOUT+O_DATA\nCOMMENT  EQU   RECOUT+O_COMM\n*\n** Files - Variable area\n*\nSYSUT1   DCB   DDNAME=SYSUT1,                                        ...\n               DSORG=PS,MACRF=(GL),EODAD=EOF\nSYSUT2   DCB   DDNAME=SYSUT2,                                        ...\n               DSORG=PS,MACRF=(PM),LRECL=80,RECFM=FB\nSYSPRINT DCB   DDNAME=SYSPRINT,                                      ...\n               DSORG=PS,MACRF=(PM),LRECL=133,RECFM=FB\n*\n** Literals\n*\n         PRINT DATA\nLTORG    LTORG ,\nLTORGL   EQU   *-LTORG\n         PRINT NODATA\n*\n** Calculate length of main CSECT\n*\n          DS    0D                        End on double word boundry\nDA$SPF2DL EQU   *-DA$SPF2D                Length of program\nDA$SPF2DB EQU   (3*4096)-DA$SPF2DL        Bytes left addressable\n         DS    0D\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAINed Work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE  2\nDSA      DSECT ,\n         DS    18F                      Register Save Area\nWORK     DS    F                        WORK FIELD\nDOUBLE   DS    D                        DOUBLE WORK FIELD\nDOUBLE2  DS    2D                       DOUBLE WORK FIELD\n         DS    0F                       PUT_SBA\nPSBA_RA  DS    F                        ..Return address\n         DS    0F                       Parse_Label\nPL_SREGS DS    3F                       ..Save registers\nPL_RA    DS    F                        ..Return address\n         DS    0F                       Process_Special_Characters\nPSC_RA   DS    F                        ..Return address\nPSC_CC   DS    F                        ..Compression count\nPSC_LA   DS    2C                       ..Last attribute bytes\nPSC_LAC  DS    F                        ..Last attribute bytes count\n*\nATLOC    DS    F                        ATTRIBUTE TABLE LOCATION\nLINECTR  DS    F                        LINE COUNTER SAVE AREA\nOFFREL0  DS    CL2                      OFFSET RELATIVE TO ZERO\nWRKFLD   DS    CL12                     WORK FIELD FOR EDIT MASK\nSCRNNAME DS    CL8\n*\nX_FLAG1   DS   B'00000000'              Execution flag 1\n$XF1_ATTR EQU  B'10000000'              ..Attribute byte?\n$XF1_HOME EQU  B'01000000'              ..Found home\n$XF1_OUTW EQU  B'00100000'              ..Output mode\n$XF1_B1ST EQU  B'00010000'              ..First time in BODY section\n$XF1_COMP EQU  B'00001000'              ..Compressed?\n*\nX_TYPE   DS    C                        Type of input record\n$XT_ATTR EQU   C'A'\n$XT_BODY EQU   C'B'\n$XT_PROC EQU   C'P'\n$XT_END  EQU   C'E'\n$XT_SKIP EQU   C'S'\n*\n         DS    0F\nX_BODYC  DS    F\n*\nSBALINE  DS    CL80                     OUTPUT RECORD\nRECOUT   DS    CL80                     OUTPUT RECORD\nREVERSE  DS    CL80                     INPUT RECORD REVERSED\nATTRTAB  DS    CL500                    ATTRIBUTE TABLE\nLINEOUT  DS    CL133\n         DS    0D                       ALIGN DOUBLE WORD\nDSAL     EQU   *-DSA                    LENGTH OF DSECT AREA\n         END\n./ ADD NAME=DA$WDATE 0104-01266-01283-1352-01634-01625-00000-DALCOCK\nDA$WDATE TITLE 'Date convertion ISPF application'\n* =================================================================== *\n*\n* Name: DA$WDATE\n*\n* Author = David Alcock :: dave@planetmvs.com\n*\n* Purpose: This is an ISPF dialog for performing Date conversions\n*          of Julian and Gregorian dates.  Calendars of the\n*          previous, current and next month of the date are shown.\n*\n*          This application was created primarily to verify that the\n*          DA$DATE date routine works properly.\n*\n* Limitations: ASSUMES, yes assumes, United States format of Gregorian\n*              dates: mm/dd/yy (Month then Day of month)\n*\n* Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 2001+ by David Alcock\n*             All rights reserved.\n*\n* Non-IBM External programs:\n* o DA$DATE....Date routine\n*\n* Non-IBM assembler MACROs:\n* o DA#ENTER...Entry housekeeping\n* o DA#LEAVE...Termination housekeeping\n* o DA#EYEC....Build standard O/S module eyecatcher\n*              (invoked by the DA#ENTER)\n* o DA#REGS....Define registers (invoked by DA#ENTER)\n* o DA#DATE....Equates and DSECTs for the date routine\n*\n* ISPF panels:\n* o DA$WDATM...Main panel\n* o DA$WDATT...Tutorial panel\n* o DA$WDATY...Year on a Page (okay, a half a year on a page)\n*\n* Enhancement queue:\n* o After I get the PTF on and support in DA$DATE, add 64-bit TOD\n* =================================================================== *\n  SPACE 2\n* =================================================================== *\n*\n* My OS/390 R6 system (maybe all ISPF V4) allows you to Julian to\n* Gregorian conversions by moving your cursor to the day of the year\n* on the main ISPF menu and hit enter.  You will see this:\n*\n*    +--------------------------------------------------------------+\n*    |                                                              |\n*    |  Enter the day and year below:                               |\n*    |                                                              |\n*    |  Day . . . . 365   (Between 1 and 365 or 366 if leap year)   |\n*    |  Year  . . . 1999  (Between 1801 and 2099)                   |\n*    |                                                              |\n*    |  Day  365  of year  1999  is  Friday        ,  1999/12/31    |\n*    |                                                              |\n*    +--------------------------------------------------------------+\n*\n* =================================================================== *\n         SPACE 2\n&DAVER   SETC  '2.1'\n* =================================================================== *\n*           M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ----------------------------------------------\n* DGAlcock   2001-10-10  v2.2: Dynamic LIBDEF Rexx written: WHATDATE;\n* DGAlcock   14-SEP-1999 v2.1:\n*                        - Added checking input parm for date;\n*                        - Instead of forcing the user to input either\n*                          a Gregorian or Julian date, we have one\n*                          input field and parse it;\n*                        - Input 32-bit TOD stamp;\n* DGAlcock   09-SEP-1999 v2.0:\n*                        - Changed name of program to DA$WDATE\n*                        - Converted from GUIDE ISPF macros to native\n*                          calls to ISPLINK;\n*                        - Added ISO 8601 date input and output;\n* DGAlcock   07-JUL-1995 v1.0 Original program written;\n* =================================================================== *\n         EJECT ,\nDA$WDATE DA#ENTER 'V&DAVER ISPF Application: Date conversions',        @\n               AMODE=31,RMODE=ANY,        ..Residency                  @\n               BASE=(12,11,10),           ..Base registers             @\n               LV=DSAL,RENT=YES           ..Dynamic Save Area\n         USING DSA,R13                    Get addressability\n         ST    R1,R1SAVE                  Save R1 on entry\n         MVC   PIP_CURSOR(8),=CL8'IDATE'  Set field\n         EJECT ,\n***********************************************************************\n***\n**       Misc initializations\n***\n***********************************************************************\n         SPACE 2\n*\n** Locate ISPLINK module.  We intentionally fail miserably if we\n** can't find ISPLINK in the normal search order.\n*\n         LA    R8,=CL8'ISPLINK'           Locate module name\n         LOAD  EPLOC=(8)                  Load it\n         ST    R0,EP_ISPLINK              Save entry point address\n*\n** Control errors return\n*\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'CONTROL',       Control                      @\n               =CL8'ERRORS',              ..Errors                     @\n               =CL8'RETURN'),             ..Return                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n** Define our ISPF message variables\n*\n*->    VDEFINE '(ZERRSM)',ZERRSM,CHAR,=F'24',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(ZERRSM)',              ..Name                       @\n               ZERRSM,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'24'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->    VDEFINE '(ZERRLM)',ZERRLM,CHAR,=F'79',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(ZERRLM)',              ..Name                       @\n               ZERRLM,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'79'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->    VDEFINE '(ZERRHM)',ZERRHM,CHAR,=F'8',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(ZERRHM)',              ..Name                       @\n               ZERRHM,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->    VDEFINE '(ZERRALRM)',ZERRALRM,CHAR,=F'3',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(ZERRALRM)',            ..Name                       @\n               ZERRALRM,                  ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'3'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->\n         MVC   ZERRHM(8),=CL8' '          Help member\n         MVC   ZERRALRM(3),=CL3'YES'      There is cause for Alarm?\n*\n** Locate DA$DATE module\n*\n         ICM   R0,B'1111',=V(DA$DATE)     Is it linked into us?\n         BNZ   I$DADS                     Yes, use it\n         LA    R8,=CL8'DA$DATE'           Locate module name\n         LOAD  EPLOC=(8),ERRET=I$DADE     Load it\n         OI    FLAG1,$F1LDAD              Indicate we loaded it\n         B     I$DADS\nI$DADE   DS    0H\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(MS07L,R14),MS07          Get short message\n         MVC   0(ML07L,R15),ML07          Get long message prefix\n         LA    R8,MS07L                   Set short message length\n         BAS   R9,MSG_SET                 Set the message up\n         B     EXIT\nI$DADS   DS    0H\n         ST    R0,EP_DA$DATE              Save entry point address\nI$DADX   EQU   *\n*\n** Define application ISPF variables\n*\n*->      VDEFINE '(IDATE)',IDATE,CHAR,32,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(IDATE)',               ..Name                       @\n               IDATE,                     ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'32'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(OGDATE)',OGDATE,CHAR,29,MF=E   freeform\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(OGDATE)',              ..Name                       @\n               OGDATE,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'29'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(OIDATE)',OIDATE,CHAR,10,MF=E   freeform\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(OIDATE)',              ..Name                       @\n               OIDATE,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'10'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(OJDATE)',OJDATE,CHAR,8,MF=E    \"ccyy.ddd\"\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(OJDATE)',              ..Name                       @\n               OJDATE,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'8'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      VDEFINE '(OTIME)',OTIME,CHAR,11,MF=E    \"hh:mm:ss.th\"\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(OTIME)',               ..Name                       @\n               OTIME,                     ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'11'),                   ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n**       VDEFINE '(CAL1)',W_ODCAL1_STR,CHAR,      Calendar 1          @\n**             =AL4($DA#DATE_ODCALC),MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(CAL1)',                ..Name                       @\n               W_ODCAL1_STR,              ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =AL4($DA#DATE_ODCALC)),    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n**       VDEFINE '(CAL2)',W_ODCAL2_STR,CHAR,      Calendar 2          @\n**             =AL4($DA#DATE_ODCALC),MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(CAL2)',                ..Name                       @\n               W_ODCAL2_STR,              ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =AL4($DA#DATE_ODCALC)),                                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n**       VDEFINE '(CAL3)',W_ODCAL3_STR,CHAR,      Calendar 3          @\n**             =AL4($DA#DATE_ODCALC),MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(CAL3)',                ..Name                       @\n               W_ODCAL3_STR,              ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =AL4($DA#DATE_ODCALC)),                                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n*->      VDEFINE '(LISTLINE)',LISTLINE,CHAR,=F'160',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(LISTLINE)',            ..Name                       @\n               LISTLINE,                  ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'160'),                  ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         MVC   PLL_CC(8),=CL8' '\n         EJECT ,\n***********************************************************************\n***\n**  Have initial screen showing today's date\n***\n***********************************************************************\n         SPACE 2\nPROCESS_PARAMETER EQU *\n         L     R1,R1SAVE                  Restore R1 on entry\n         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?\n         BNO   PP$NC                      No, need to look at CBUF\n*\n** We were called, it has a Batch type (EXEC) parameter\n*\n         L     R2,0(R1)                   Get address of parm\n         SLR   R3,R3                      Clear register\n         ICM   R3,B'0011',0(R2)           Get length of parm\n         BZ    PP$X                       None, leave\n         LA    R2,2(R2)                   Bump past parm length HW\n         B     PP$PARSE                   Parse the input\n*\n** We were not called, it is a \"Command Processor\"\n*\nPP$NC    DS    0H\n         L     R2,CPPLCBUF-CPPL(R1)       Locate Command Buffer\n         SLR   R3,R3                      Clear register\n         ICM   R3,B'0011',0(R2)           Get total CBUF length\n         SLR   R0,R0                      Clear register\n         ICM   R0,B'0011',2(R2)           Get total Command name length\n         LA    R15,4                      Length of header\n         AR    R2,R15                     Bump past header\n         SR    R3,R15                     Decrement for header length\n         AR    R2,R0                      Bump past Command length\n         SR    R3,R0                      Length of data\n*\n** Look thru command buffer/parameter for our commands\n** Input: R2 - Address of command-buffer/Parameter\n**        R3 - Length of command-buffer/Parameter\n*\nPP$PARSE DS    0H\n         LTR   R3,R3                      Check out length\n         BZ    PP$X                       Length = Zero: Leave\n         BM    PP$X                       Length < Zero: Leave\n         CH    R3,=AL2(L'IDATE)           Over length\n         BNH   PP$SDATE\n*-Note: Need to do this in an ISPF compatible way.\n MVC PARMLIST(18),=C'Invalid Input date'\n TPUT PARMLIST,18\n B    PP$X\nPP$SDATE DS    0H\n         MVC   IDATE(L'IDATE),=CL32' '    Ensure trailing blanks\n         BCTR  R3,0\n         EX    R3,PP$MDATE\n         B     PIP$PARSE\nPP$MDATE MVC   IDATE(0),0(R2)\nPP$X     DS    0H\n         EJECT ,\n***********************************************************************\n***\n**  Have initial screen showing today's date\n***\n***********************************************************************\n         SPACE 2\n*\n** Message that we've started off on today's date\n*\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(MS01L,R14),MS01          Get short message\n         MVC   0(ML01L,R15),ML01          Get long message prefix\n         LA    R8,MS01L                   Set short message length\n         BAS   R9,MSG_SET                 Set the message up\n*\n** Get calendar for the current day\n*\n         MVC   W_ODGUS29(C_ODGUS29L),C_ODGUS29\n         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8\n         MVC   W_ODGUS10(C_ODGUS10L),C_ODGUS10\n         MVC   W_ODISO10(C_ODISO10L),C_ODISO10\n         MVC   W_OTIMEM11(C_OTIMEM11L),C_OTIMEM11\n         MVC   W_ODCAL2(C_ODCALCL),C_ODCALC Initialize area\n         L     R15,EP_DA$DATE             Locate date routine\n         CALL  (15),                      Call date routine            @\n               (W_ODGUS29,                ..output gregorian           @\n               W_ODJUL8,                  ..output gregorian           @\n               W_ODGUS10,                 ..output gregorian           @\n               W_ODISO10,                 ..output ISO date            @\n               W_OTIMEM11,                ..output Time                @\n               W_ODCAL2),                 ..output calendar            @\n               VL,MF=(E,PARMLIST)         ..execution area\n         MVC   OGDATE(29),W_ODGUS29_STR\n         MVC   OIDATE(10),W_ODISO10_STR\n         MVC   OJDATE(8),W_ODJUL8_STR\n*\n         TM    FLAG1,$F1TOD               Need time of day?\n         BO    PIP$UT1\n         MVC   OTIME(11),=CL32' '\n         B     PIP$UT1X\nPIP$UT1  DS    0H\n         MVC   OTIME(11),W_OTIMEM11_STR\n         NI    FLAG1,255-$F1TOD           Turn off time of day\nPIP$UT1X DS    0H\n*\n         MVC   PIP_LGDATE(10),W_ODGUS10_STR  Save it\n         MVC   PIP_LJDATE(8),W_ODJUL8_STR    Save it\n*\n         MVI   IVARS,C' '\n         MVC   IVARS+1(IVARSL-1),IVARS\n         MVC   IDATE(10),W_ODGUS10_STR\n*\n         MVI   PC_OATTR,#_WHITE           Get output attribute\n         MVC   PC_DATECC(4),W_ODGUS10_STR+6 Get \"CCYY\" -  \"mm/dd/CCYY\"\n*        MVC   PC_DATEYY(2),W_ODGUS10_STR+8 Get \"YY\" from \"mm/dd/ccYY\"\n         MVC   PC_DATEMM(2),W_ODGUS10_STR   Get \"MM\" from \"MM/dd/ccyy\"\n         MVC   PC_DATEDD(2),W_ODGUS10_STR+3 Get \"DD\" from \"mm/DD/ccyy\"\n*\n         LA    R7,W_ODCAL2_STR            Locate calendar\n         OI    PC_FLAG1,$PCF1_TODAY       It's for today!\n         BAS   R14,PROCESS_CALENDAR       Process the calendar\n         NI    PC_FLAG1,255-$PCF1_TODAY   It's over for today\n         BAS   R14,PROCESS_OTHER_CALENDARS  Process the other ones\n         EJECT ,\n***********************************************************************\n***\n**       Process the input panel\n***\n***********************************************************************\n         SPACE 2\nPROCESS_INPUT_PANEL EQU *\nPIP$L    EQU   *\n*->      DISPLAY PANEL==CL8'DA$WDATM',CURSOR=PIP_CURSOR,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'DISPLAY',       Service: DISPLAY             @\n               =CL8'DA$WDATM',            ..Panel name                 @\n               =CL8'        ',            ..MSGID                      @\n               PIP_CURSOR),               ..Field Name                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         LTR   R15,R15\n         BNZ   PIP$X\n*\n** Did we get Scrolled?\n*\n*->      VCOPY '(ZVERB)',ZVERBL,ZVERBA,LOCATE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(ZVERB)',               ..Name                       @\n               ZVERBL,                    ..Length                     @\n               ZVERBA,                    ..Location                   @\n               =CL8'LOCATE'),             ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         ICM   R1,B'1111',ZVERBA\n         BZ    PIP$SCX\n         ICM   R0,B'1111',ZVERBL\n         BZ    PIP$SCX\n         CH    R0,=H'2'                   At least 2?\n         BL    PIP$SCX\n         CLC   0(2,R1),=C'LE'             Left?\n         BE    PIP$SLE\n         CLC   0(2,R1),=C'RI'             Right?\n         BE    PIP$SRI\n         CLC   0(2,R1),=C'UP'             UP?\n         BE    PIP$SUP\n         CLC   0(2,R1),=C'DO'             Down?\n         BE    PIP$SDO\n         B     PIP$SCX\n*                               01234567\nPIP$SUP  EQU   *    PIP_LJDATE=\"yyyy.ddd'\n         PACK  DOUBLE(8),PIP_LJDATE+5(3)  Get day of the year\n         CVB   R15,DOUBLE                 Make it binary\n         SH    R15,=H'1'                  Reelin' in the years\n         LTR   R15,R15                    Too far down?\n         BP    PIP$SDOC                   No, it's okay\n         LA    R15,365                    Oops no leap year check!!\n         PACK  DOUBLE(8),PIP_LJDATE(4)    Make century.year packed\n         CVB   R14,DOUBLE                 Make it binary\n         SH    R14,=H'1'                  Reelin' in the years\n         CVD   R14,DOUBLE                 Convert back to packed\n         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned\n         OI    DOUBLE2+3,C'0'             Fix sign byte\n         MVC   PIP_LJDATE(4),DOUBLE2      Set new year\n         B     PIP$SDOC\n*                               01234567\nPIP$SDO  EQU   *    PIP_LJDATE=\"yyyy.ddd'\n         PACK  DOUBLE(8),PIP_LJDATE+5(3)  Get day of the year\n         CVB   R15,DOUBLE                 Make it binary\n         LA    R15,1(R15)                 Reelin' in the years\n         CH    R15,=H'365'                Oops, no leap year check!\n         BNH   PIP$SDOC                   No, it's okay\n         LA    R15,1                      Start at \"yyyy.001\"\n         PACK  DOUBLE(8),PIP_LJDATE(4)    Make century.year packed\n         CVB   R14,DOUBLE                 Make it binary\n         LA    R14,1(R14)                 Happy New Year!\n         CVD   R14,DOUBLE                 Convert back to packed\n         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned\n         OI    DOUBLE2+3,C'0'             Fix sign byte\n         MVC   PIP_LJDATE(4),DOUBLE2      Set new year\nPIP$SDOC EQU   *\n         CVD   R15,DOUBLE                 Convert back to packed\n         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned\n         OI    DOUBLE2+3,C'0'             Fix sign byte\n         LA    R2,W_IDJULC8               Locate output\n         MVC   0(C_IDJULC8L,R2),C_IDJULC8 Initialize\n         MVC   W_IDJULC8_STR(8),PIP_LJDATE Get last date\n         MVC   W_IDJULC8_STR+5(3),DOUBLE2+1\n         MVC   IDATE(32),=CL32' '\n         MVC   IDATE(8),W_IDJULC8_STR     Reset new input date\n         B     PIP$DATE\n*                               0123456\nPIP$SRI  EQU   *    PIP_LGDATE=\"mm/dd/ccyy\"\n         PACK  DOUBLE(8),PIP_LGDATE+6(4)  Make century.year packed\n         CVB   R15,DOUBLE                 Make it binary\n         LA    R15,1(R15)                 Reelin' in the years\n         B     PIP$SLEC\nPIP$SLE  EQU   *\n         PACK  DOUBLE(8),PIP_LGDATE+6(4)  Make century.year packed\n         CVB   R15,DOUBLE                 Make it binary\n         SH    R15,=H'1'                  Reelin' in the years\nPIP$SLEC EQU   *\n         CVD   R15,DOUBLE                 Convert back to packed\n         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned\n         OI    DOUBLE2+3,C'0'             Fix sign byte\n         LA    R2,W_IDGUS10               Locate output\n         MVC   0(C_IDGUS10L,R2),C_IDGUS10 Initialize\n         MVC   W_IDGUS10_STR(10),PIP_LGDATE Get last date\n         MVC   W_IDGUS10_STR+6(4),DOUBLE2\n         MVC   IDATE(32),=CL32' '\n         MVC   IDATE(10),W_IDGUS10_STR   Reset new input date\n         B     PIP$DATE\nPIP$SCX  EQU   *\n*\n** See if the user specifed a command we should process in ZCMD\n*\n*->      VCOPY '(ZCMD)',ZCMDL,ZCMDA,LOCATE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(ZCMD)',                ..Name                       @\n               ZCMDL,                     ..Length                     @\n               ZCMDA,                     ..Location                   @\n               =CL8'LOCATE'),             ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n         ICM   R2,B'1111',ZCMDL           Get command length\n         BZ    PIP$ZCX                    None, display table again\n         L     R3,ZCMDA                   Get command address\n*\n         LA    R14,T_ZCMDV                Locate Verb table\n         LA    R15,T_ZCMDVN               Get number of entries\nPIP$ZCL  EQU   *\n         SLR   R8,R8                      Clear register\n         IC    R8,TZCC_MINL-TZCC(R14)     Get minimum length\n         CR    R8,R2                      Okay?\n         BH    PIP$ZCLB                   No, don't even consider\n         EX    R8,PIP$ZCLC                Match?\n         BE    PIP$ZCLX                   Yes, leave\nPIP$ZCLB EQU   *\n         LA    R14,TZCCL(R14)             Bump to next entry\n         BCT   R15,PIP$ZCL                Process it\n*\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(MS05L,R14),MS05\n         EX    R2,PIP$ZCMM\n         LA    R15,2(R2,R15)\n         MVC   0(10,R15),=C'is invalid'\n         LA    R8,MS05L                   Length of short message\n         BAS   R9,MSG_SET                 Set the message up\n         B     PIP$ZCRA\nPIP$ZCLX EQU   *\n         LA    R3,1(R8,R3)                Bump past \"VERB \"\n         SR    R2,R8                      Decrement length\n*\nPIP$ZCO2L EQU  *                          Ignore blanks...\n         CLI   0(R3),C' '                 Blank?\n         BNE   PIP$ZCO2LX                 Nope, found 2nd operand\n         LA    R3,1(R3)                   Bump to next byte\n         BCT   R2,PIP$ZCO2L               Process it\nPIP$ZCO2LX EQU *\n         SLR   R9,R9                      Clear register\n         ICM   R9,B'0011',TZCC_ROUTO-TZCC(R14) Get routine offset\n         AR    R9,R12                     Locate routine\n         BSM   0,R9                       Branch to routine\nPIP$ZCRA EQU   *\n         B     PIP$L                      Continue on my wayward son\nPIP$ZCMM MVC   0(0,R15),0(R3)\nPIP$ZCLC CLC   0(0,R3),TZCC_VERB-TZCC(R14)\nPIP$ZCX  EQU   *\n*\n** Look at input dates\n*\nPIP$INPUT DS   0H\n         CLC   IDATE(L'IDATE),=CL32' '    Have an input date?\n         BNE   PIP$PARSE                  Yes, look at it\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(MS02L,R14),MS02          Get short message\n         MVC   0(ML02L,R15),ML02          Get long message prefix\n         LA    R8,MS02L                   Set short message length\n         BAS   R9,MSG_SET                 Set the message up\n         B     PIP$L\n*\n** Parsing:\n** > Gregorian:    \"mm/dd/yy\"     \"mm/dd/ccyy\"\n**                  0....+..=8     0....+....=10\n**\n** > ISO:          \"ccyy-mm-dd\"\n**                  0....+....=10\n**\n** > Julian:       \"ccyy.ddd\"      \"yy.ddd\"\n**                  0....+..=8      0....+=6\n**\n** > 32-bit TOD:   \"B361183F47FFFFFF\" 1999-12-31 23:59\n** > 32-bit TOD:   \"B361183F48000000\" 2000-01-01 00:00\n**\n*\nPIP$PARSE DS 0H\n*-Weed out 32-bit TOD stamps\n         LA    R0,16\n         LA    R1,IDATE\nPIP$T32L DS    0H\n         CLI   0(R1),X'81'         Below \"a\"\n         BL    PIP$T32X\n         CLI   0(R1),X'87'         In \"a-f\"\n         BL    PIP$T32B\n         CLI   0(R1),X'C1'         Below \"A\"\n         BL    PIP$T32X\n         CLI   0(R1),X'C7'         In \"A-F\"\n         BL    PIP$T32B\n         CLI   0(R1),X'F0'         Below \"0\"\n         BL    PIP$T32X\n         CLI   0(R1),X'F9'         In \"0-9\"\n         BH    PIP$T32X\nPIP$T32B DS    0H\n         LA    R1,1(R1)\n         BCT   R0,PIP$T32L\n         CLI   0(R1),C' '          Blank?\n         BE    PIP$TOD32\nPIP$T32X DS    0H\n*-Weed out Julian\n         CLI   IDATE+4,C'.'        Julian?\n         BE    PIP$J\n         CLI   IDATE+2,C'.'        Julian?\n         BE    PIP$J\n*-Must be some type of Gregorian (or invalid)\n*\n** Gregorian Date: \"mm/dd/yy \"    \"mm/dd/ccyy\"  \"ccyy-mm-dd\"\n*                   0....+....    0....+....1    0....+....\nPIP$G    EQU   *\n         CLI   IDATE+4,C'-'               ISO date?\n         BE    PIP$GISO\n         CLI   IDATE+2,C'-'               Looks good?\n         BE    PIP$G2X                    Yes, alternative format\n         CLI   IDATE+2,C'/'               Looks good?\n         BNE   PIP$EFMT                   No, gripe about it\nPIP$G2X  DS    0H\n         CLI   IDATE+5,C'-'               Looks good?\n         BE    PIP$G5X                    Yes, alternative format\n         CLI   IDATE+5,C'/'               Looks good?\n         BNE   PIP$EFMT                   No, gripe about it\nPIP$G5X  DS    0H\n         CLI   IDATE+8,C' '               Shorter date?\n         BE    PIP$GS\n         LA    R2,W_IDGUS10               Locate output\n         MVC   0(C_IDGUS10L,R2),C_IDGUS10 Initialize\n         MVC   W_IDGUS10_STR(10),IDATE    Get input\n         B     PIP$DATE\nPIP$GS   EQU   *\n         LA    R2,W_IDGUS8                Locate output\n         MVC   0(C_IDGUS8L,R2),C_IDGUS8   Initialize\n         MVC   W_IDGUS8_STR(8),IDATE      Get input\n         B     PIP$DATE\nPIP$GISO EQU   *\n         CLI   IDATE+7,C'-'               ISO date?\n         BNE   PIP$EFMT                   Nope...\n*-Note: I need to change this to use ISO Input format\n         LA    R2,W_IDISO10               Locate output\n         MVC   0(C_IDISO10L,R2),C_IDISO10 Initialize\n         MVC   W_IDISO10_STR(10),IDATE    Get input\n         B     PIP$DATE\n*\n** Julian Date: \"yy.ddd \" or \"ccyy.ddd'\n*                0....+.     0....+....\nPIP$J    EQU   *\n         CLI   IDATE+6,C' '               Shorter date?\n         BE    PIP$JS\n         CLI   IDATE+4,C'.'               Looks good?\n         BNE   PIP$EFMT                   No, gripe about it\n         CLC   IDATE+5(3),=C'001'         Valid date?\n         BL    PIP$EFMT                   No...\n*-Need Leap year check here...\n         CLC   IDATE+5(3),=C'366'         Valid date?\n         BH    PIP$EFMT                   No...\n         LA    R2,W_IDJULC8               Locate input date area\n         MVC   0(C_IDJULC8L,R2),C_IDJULC8 Initialize\n         MVC   W_IDJULC8_STR(8),IDATE     Get input\n         B     PIP$DATE\nPIP$JS   EQU   *\n         CLI   IDATE+2,C'.'               Looks good?\n         BNE   PIP$EFMT                   No, gripe about it\n         CLC   IDATE+3(3),=C'001'         Valid date?\n         BL    PIP$EFMT                   No...\n*-Need Leap year check here...\n         CLC   IDATE+3(3),=C'366'         Valid date?\n         BH    PIP$EFMT                   No...\n         LA    R2,W_IDJULC6               Locate input date area\n         MVC   0(C_IDJULC6L,R2),C_IDJULC6 Initialize\n         MVC   W_IDJULC6_STR(6),IDATE     Get input\n         B     PIP$DATE\n*\n** Input date is a 32-bit TOD stamp\n*\nPIP$TOD32 DS   0H\n         OI    FLAG1,$F1TOD               Need time of day...\n         LA    R2,W_ISTMPC16              Locate input date area\n         MVC   0(C_ISTMPC16L,R2),C_ISTMPC16 Initialize\n         MVC   W_ISTMPC16_STR(16),IDATE    Get input\n         B     PIP$DATE\n*\n** Error: Format error\n*\nPIP$EFMT EQU   *\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(MS04L,R14),MS04          Get short message\n         MVC   0(ML04L,R15),ML04          Get long message prefix\n         LA    R8,MS04L                   Set short message length\n         BAS   R9,MSG_SET                 Set the message up\n         B     PIP$L\n*\n** Error: Date routine returned error\n*\nPIP$EDR  EQU   *\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(MS04L,R14),MS04          Get short message\n         MVC   0(30,R15),=C'DA$DATE routine passed error:'\n         LA    R15,31(R15)\n         TM    DA#DATED_FLAG-DA#DATED(R2),$DA#DATE_EITYPE\n         BO    PIP$EDR1                   Continue\n         TM    DA#DATED_FLAG-DA#DATED(R2),$DA#DATE_EISTRL\n         BO    PIP$EDR2                   Continue\n         TM    DA#DATED_FLAG-DA#DATED(R2),$DA#DATE_EISTR\n         BO    PIP$EDR3                   Continue\n         MVC   0(7,R15),=C'Unknown'\n         LA    R15,8(R15)\n         B     PIP$EDRX                   Continue\nPIP$EDR1 EQU   *\n         MVC   0(12,R15),=C'Invalid type'\n         LA    R15,13(R15)\n         B     PIP$EDRX                   Continue\nPIP$EDR2 EQU   *\n         MVC   0(13,R15),=C'String length'\n         LA    R15,14(R15)\n         B     PIP$EDRX                   Continue\nPIP$EDR3 EQU   *\n         MVC   0(16,R15),=C'Format of string'\n         LA    R15,17(R15)\n         B     PIP$EDRX                   Continue\nPIP$EDRX EQU   *\n         MVI   0(R15),C'\"'\n         LA    R15,1(R15)\n         SLR   R1,R1\n         IC    R1,DA#DATED_STRL-DA#DATED(R2)\n         BCTR  R1,0\n         EX    R1,PIP$EDM\n         LA    R15,1(R1,R15)\n         MVI   0(R15),C'\"'\n*\n         LA    R8,MS04L                   Set short message length\n         BAS   R9,MSG_SET                 Set the message up\n         B     PIP$L\nPIP$EDM  MVC   0(0,R15),DA#DATED_STR-DA#DATED(R2)\n*\n** Get date\n*\nPIP$DATE EQU   *\n         MVC   PIP_CDATE(32),0(R2)        Save current date for SHOWDTE\n         MVC   W_ODGUS29(C_ODGUS29L),C_ODGUS29\n         MVC   W_ODJUL8(C_ODJUL8L),C_ODJUL8\n         MVC   W_ODGUS10(C_ODGUS10L),C_ODGUS10\n         MVC   W_ODISO10(C_ODISO10L),C_ODISO10\n         MVC   W_OTIMEM11(C_OTIMEM11L),C_OTIMEM11\n         MVC   W_ODCAL2(C_ODCALCL),C_ODCALC Initialize area\n         L     R15,EP_DA$DATE             Locate date routine\n         CALL  (15),                      Call date routine            @\n               ((2),                      ..Input date                 @\n               W_ODGUS29,                 ..output gregorian           @\n               W_ODJUL8,                  ..output Julian              @\n               W_ODGUS10,                 ..output gregorian           @\n               W_ODISO10,                 ..output ISO date            @\n               W_OTIMEM11,                ..output Time                @\n               W_ODCAL2),                 ..output calendar            @\n               VL,MF=(E,PARMLIST)         ..execution area\n         LTR   R15,R15                    Looks okay?\n         BNZ   PIP$EFMT                   No, continue\n         CLI   DA#DATED_FLAG-DA#DATED(R2),0  Looks okay?\n         BNE   PIP$EDR                    No, continue\n         MVC   OGDATE(29),W_ODGUS29_STR\n         MVC   OIDATE(10),W_ODISO10_STR\n         MVC   OJDATE(8),W_ODJUL8_STR\n*\n         TM    FLAG1,$F1TOD               Need time of day?\n         BO    PIP$UT2\n         MVC   OTIME(11),=CL32' '\n         B     PIP$UT2X\nPIP$UT2  DS    0H\n         MVC   OTIME(11),W_OTIMEM11_STR\n         NI    FLAG1,255-$F1TOD           Turn off time of day\nPIP$UT2X DS    0H\n*\n         MVC   PIP_LGDATE(10),W_ODGUS10_STR  Save it\n         MVC   PIP_LJDATE(8),W_ODJUL8_STR    Save it\n*\n         MVI   PC_OATTR,#_WHITE           Get output attribute\n         MVC   PC_DATECC(4),W_ODGUS10_STR+6 Get \"CCYY\" -  \"mm/dd/CCYY\"\n*        MVC   PC_DATEYY(2),W_ODGUS10_STR+8 Get \"YY\" from \"mm/dd/ccYY\"\n         MVC   PC_DATEMM(2),W_ODGUS10_STR   Get \"MM\" from \"MM/dd/ccyy\"\n         MVC   PC_DATEDD(2),W_ODGUS10_STR+3 Get \"DD\" from \"mm/DD/ccyy\"\n*\n         LA    R7,W_ODCAL2_STR            Locate calendar\n         BAS   R14,PROCESS_CALENDAR       Process the calendar\n         BAS   R14,PROCESS_OTHER_CALENDARS  Process the other ones\n         B     PIP$L\n*\n** Common exit from Process_Input_Panel processing\n*\nPIP$X    EQU   *\n         EJECT ,\n***********************************************************************\n***\n**       Termination section\n***\n***********************************************************************\n         SPACE 2\nEXIT     DS    0H\n*\n** Delete modules from memory\n*\n         TM    FLAG1,$F1LDAD              Did we load it?\n         BNO   X$DATEX                    No, leave\n         ICM   R0,B'1111',EP_DA$DATE      -> Program Loaded?\n         BZ    X$DATEX                    No, continue\n         DELETE EPLOC==CL8'DA$DATE'       Delete from V/S\nX$DATEX  EQU   *\n*\n         DELETE EPLOC==CL8'ISPLINK'       Delete from V/S\n*\n** Exit housekeeping\n*\n         DA#LEAVE ,                       Exit housekeeping\n         EJECT ,\n***********************************************************************\n***\n**       Misc Internal subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Print line on the list dataset\n*\nPRINT_LISTLINE EQU *\n         L     R15,EP_ISPLINK             EPA of ISPLINK\n         CALL  (15),                      Call ISPLINK                 @\n               (=CL8'LIST',               ..List Dataset call          @\n               =CL8'LISTLINE',            ..Variable name              @\n               =F'160',                   ..Length to output           @\n               =CL8'  ',                  ..PAGE                       @\n               =CL8'  ',                  ..SINGLE                     @\n               =CL8'  ',                  ..OVERSTRK                   @\n               PLL_CC),                   ..Control Character          @\n               VL,MF=(E,PARMLIST)\n         BSM   0,R9\n*\n** Clear our messages\n*\nMSG_CLEAR EQU  *\n         LA    R14,ZERRSM\n         MVI   0(R14),C' '\n         MVC   1(L'ZERRSM-1,R14),0(R14)\n*\n         LA    R15,ZERRLM\n         MVI   0(R15),C' '\n         MVC   1(L'ZERRLM-1,R15),0(R15)\n         BSM   0,R9\n*\n** Set message ISRZ002 which uses ZERRSM and ZERRLM\n*\nMSG_SET  EQU   *\n         ST    R8,ZERRSML                 Set short message length\n*->      VDEFINE '(ZERRSM)',ZERRSM,CHAR,ZERRSML,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(ZERRSM)',              ..Name                       @\n               ZERRSM,                    ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               ZERRSML),                  ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*->      SETMSG MSG='ISRZ002',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'SETMSG',        Set message                  @\n               =CL8'ISRZ002'),            ..Name                       @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         BSM   0,R9\n         EJECT\n***********************************************************************\n***\n**       Show assembly date of DA$WDATE and DA$DATE\n***\n***********************************************************************\n         SPACE 2\nSHOW_ASM_DATE EQU *\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(8,R15),DA$WDATE_ECNAME   Get \"DA$WDATE\"\n         LA    R15,9(R15)                 Bump past it\n         MVC   0(4,R15),31(R12)           Get \"Vx.x\" from eyecatcher\n         LA    R15,5(R15)\n         MVC   0(4,R15),=C'asm('\n         LA    R15,4(R15)                 Bump past it\n         MVC   0(L'DA$WDATE_ECDATE,R15),DA$WDATE_ECDATE\n         LA    R15,L'DA$WDATE_ECDATE+1(R15) Bump past it\n         MVC   0(L'DA$WDATE_ECTIME,R15),DA$WDATE_ECTIME\n         LA    R15,L'DA$WDATE_ECTIME(R15) Bump past it\n         MVI   0(R15),C')'\n         LA    R15,3(R15)\n*\n         L     R14,EP_DA$DATE             Locate date routine\n         MVC   0(8,R15),DA$WDATE_ECNAME-DA$WDATE(R14)\n         LA    R15,9(R15)                 Bump past it\n         MVC   0(4,R15),=C'asm('\n         LA    R15,4(R15)                 Bump past it\n         MVC   0(L'DA$WDATE_ECDATE,R15),DA$WDATE_ECDATE-DA$WDATE(R14)\n         LA    R15,L'DA$WDATE_ECDATE+1(R15) Bump past it\n         MVC   0(L'DA$WDATE_ECTIME,R15),DA$WDATE_ECTIME-DA$WDATE(R14)\n         LA    R15,L'DA$WDATE_ECTIME(R15) Bump past it\n         MVI   0(R15),C')'\n*\n         LA    R8,0                       No short message length\n         BAS   R9,MSG_SET                 Set the message up\n         B     PIP$ZCRA\n         EJECT\n***********************************************************************\n***\n**       Show all date routine output types\n***\n***********************************************************************\n         SPACE 2\nSHOW_ALL_DR EQU *\n         BAS   R2,SOD$S\nT_SOA    DS    0H\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS29)\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS23)\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS18)\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS12)\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS10)\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS8T)\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS8)\n         DC    CL8'ODGUS   ',AL2($DA#DATE_ODGUS,$DA#DATE_ODGUS6)\n*\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR29)\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR23)\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR18)\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR11)\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR10)\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR8T)\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR8)\n         DC    CL8'ODGEUR  ',AL2($DA#DATE_ODGEUR,$DA#DATE_ODGEUR6)\n*\n         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL8)\n         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL6)\n         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL5)\n         DC    CL8'ODJUL   ',AL2($DA#DATE_ODJUL,$DA#DATE_ODJUL3)\n*\n         DC    CL8'ODISO   ',AL2($DA#DATE_ODISO,$DA#DATE_ODISO10)\nT_SOAN   EQU   (*-T_SOA)/TSOAL\nSOD$S    DS    0H\n         LA    R3,T_SOAN\n         MVC   PLL_CC(2),TSOA_T-TSOA(R2)   Get line break value\nSOD$L    DS    0H\n         LA    R4,W_ODGUS29\n         MVC   DA#DATED_TYPE-DA#DATED(2,R4),TSOA_T-TSOA(R2)\n         XC    DA#DATED_FLAG-DA#DATED(1,R4),DA#DATED_FLAG-DA#DATED(R4)\n         MVC   DA#DATED_STRL-DA#DATED(1,R4),TSOA_L+1-TSOA(R2)\n         L     R15,EP_DA$DATE             Locate date routine\n         CALL  (15),                      Call date routine            @\n               (PIP_CDATE,                ..Input date entry           @\n               W_ODGUS29),                ..Output date entry          @\n               VL,MF=(E,PARMLIST)         ..execution area\n         LA    R15,LISTLINE\n         MVI   0(R15),C' '\n         MVC   1(78,R15),0(R15)\n         MVC   0(L'TSOA_N,R15),TSOA_N-TSOA(R2)\n         LA    R15,L'TSOA_N+1(R15)\n         MVC   0(7,R15),=C'Length='\n         LA    R15,7(R15)\n         SLR   R1,R1\n         ICM   R1,B'0011',TSOA_L-TSOA(R2)\n         BAS   R9,EDITFWF\n*\n         LA    R15,LISTLINE+20\n         MVC   0(5,R15),=C'Flag='\n         LA    R15,5(R15)\n         UNPK  0(3,R15),DA#DATED_FLAG-DA#DATED(2,R4)\n         MVZ   0(2,R15),=8X'00'\n         TR    0(2,R15),=C'0123456789ABCDEF'\n         MVI   2(R15),C' '\n         LA    R15,3(R15)\n*\n         SLR   R1,R1\n         IC    R1,DA#DATED_STRL-DA#DATED(R4)\n         BCTR  R1,0\n         EX    R1,SOD$M\n         TPUT  LISTLINE,79\n         LA    R2,TSOAL(R2)\n         CLC   TSOA_T-TSOA(2,R2),PLL_CC\n         BE    SOD$B\n         MVI   LISTLINE,C' '\n         TPUT  LISTLINE,1\n         MVC   PLL_CC(2),TSOA_T-TSOA(R2)   Get line break value\nSOD$B    DS    0H\n         BCT   R3,SOD$L\n         B     PIP$ZCRA\nSOD$M    MVC   0(0,R15),DA#DATED_STR-DA#DATED(R4)\n         EJECT\n***********************************************************************\n***\n**       Produce a YOAP - a UNIX weenie thing\n***\n***********************************************************************\n         SPACE 2\nYEAR_ON_A_PAGE EQU *\n         MVC   YOAP_DATE(8),PC_DATE       Save current year\n         MVC   PC_DATE(4),W_ODJUL8_STR    Ensure the year is right\n*\n** Are we going to be normal or sideways\n*\n         LTR   R2,R2                      Anything there?\n         BZ    YOAP$ISX                   No, assume normal\n         BM    YOAP$ISX                   No, assume normal\n         CLI   0(R3),C'S'                 Looks like \"YOAP SIDEWAYS\"?\n         BNE   YOAP$ISX                   No, continue\n         OI    YOAP_F1,$YF1_SIDEW         Yes, set flag\nYOAP$ISX EQU   *\n*\n** Create headings for sideways calendar printing\n*\n         TM    YOAP_F1,$YF1_SIDEW         Sideways?\n         BNO   YOAP$SHX                   No, continue\n         MVI   LISTLINE,C' '\n         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE\n         MVC   LISTLINE(13),=C'1Calendar for'\n         MVC   LISTLINE+14(4),PC_DATECC\n         MVC   PLL_CC(2),=C'CC'\n         BAS   R9,PRINT_LISTLINE\n         MVC   PLL_CC(2),=CL8' '\n*\n         MVI   LISTLINE,C' '\n         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE\n         BAS   R9,PRINT_LISTLINE\n*\n         MVI   LISTLINE,C' '\n         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE\n         LA    R15,LISTLINE+5\n         LA    R1,$DA#DATE_ODCALC_WEEKN-3\n         LA    R14,W_ODCAL1_STR+$DA#DATE_ODCALC_WEEKL\nYOAP$HL  EQU   *\n         MVC   0($DA#DATE_ODCALC_WEEKL,R15),0(R14)\n         LA    R15,$DA#DATE_ODCALC_WEEKL(R15)\n         BCT   R1,YOAP$HL\n         BAS   R9,PRINT_LISTLINE\n         B     YOAP$LS\nYOAP$SHX EQU   *\nYOAP$Y   EQU   *\n*\n** Initialize for regular YOAP\n*\n         LA    R4,YOAP_MONTHS             Locate table\n         MVI   PC_OATTR,#_BLUE            Get output attribute\n         OI    PC_FLAG1,$PCF1_POC         POC mode\n*->      VDEFINE '(YEAR)',PC_DATECC,CHAR,4,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               =C'(YEAR)',                ..Name                       @\n               PC_DATECC,                 ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =F'4'),                    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n*\n** Loop thru months for the year\n*\nYOAP$LS  EQU   *\n         LA    R2,T_MONTH\n         LA    R3,1\nYOAP$L   EQU   *\n         MVC   W_IDGUS8(C_IDGUS8L),C_IDGUS8\n         MVC   W_IDGUS8_STR(2),TMD_MM-TMD(R2)\n         MVC   W_IDGUS8_STR+2(2),=C'01'\n         MVC   W_IDGUS8_STR+4(4),PC_DATECC\n         MVC   W_ODCALY(C_ODCALCNDL),C_ODCALCND Initialize area\n         L     R15,EP_DA$DATE             Locate date routine\n         CALL  (15),                      Call date routine            @\n               (W_IDGUS8,                 ..Input date                 @\n               W_ODCALY),                 ..output calendar            @\n               VL,MF=(E,PARMLIST)         ..execution area\n*\n         TM    YOAP_F1,$YF1_SIDEW         Sideways?\n         BNO   YOAP$LSX                   No, continue\n#YOAPDO  EQU   2*$DA#DATE_ODCALC_WEEKL\n#YOAPML  EQU   $DA#DATE_ODCALC-$DA#DATE_ODCALC_WEEKL\n         MVI   LISTLINE,C' '\n         MVC   LISTLINE+1(L'LISTLINE-1),LISTLINE\n         MVC   LISTLINE+1(3),W_ODCALY_STR+1 Get month name\n         OC    LISTLINE+1(3),=C'   '        Make upper case\n         MVC   LISTLINE+5(#YOAPML),W_ODCALY_STR+#YOAPDO\n         BAS   R9,PRINT_LISTLINE\n         B     YOAP$LB                     Continue\nYOAP$LSX EQU   *\n         CVD   R3,DOUBLE                  Convert month to packed\n         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned\n         OI    DOUBLE2+3,C'0'             Fix sign byte\n         MVC   PC_DATEMM(2),DOUBLE2+2     Get new month\n         STM   R2,R4,YOAP_SREGS           Save registers\n         LA    R7,W_ODCALY_STR            Locate calendar\n         BAS   R14,PROCESS_CALENDAR       Process the calendar\n         LM    R2,R4,YOAP_SREGS           Restore registers\n         MVC   0($DA#DATE_ODCALC,R4),W_ODCALY_STR\n         MVC   $DA#DATE_ODCALC_WEEKL-4(4,R4),=CL8' ' Blank out year\n         LA    R4,$DA#DATE_ODCALC(R4)     Bump to next month\n*\nYOAP$LB  EQU   *\n         LA    R2,TMDL(R2)                Process next month\n         LA    R3,1(R3)                   Continue\n         CH    R3,=H'12'                  At the end?\n         BNH   YOAP$L\n*\n** Termination for Sideways print\n*\n         TM    YOAP_F1,$YF1_SIDEW         Sideways?\n         BNO   YOAP$STX                   No, continue\n         BAS   R9,MSG_CLEAR               Initialize message areas\n         MVC   0(MS06L,R14),MS06          Get short message\n         MVC   0(ML06L,R15),ML06          Get long message prefix\n         LA    R8,MS06L                   Set short message length\n         BAS   R9,MSG_SET                 Set the message up\n         B     YOAP$X                     Leave this party\nYOAP$STX EQU   *\n*\n** Normal YOAP\n*\n         NI    PC_FLAG1,255-$PCF1_POC     POC mode\n         OI    YOAP_F1,$YF1_TOP           At the top of the calendar\nYOAP$DT  EQU   *\n         LA    R4,YOAP_MONTHS\nYOAP$DTX EQU   *\n         LA    R2,6\n         LA    R3,=C'(CALY1)(CALY2)(CALY3)(CALY4)(CALY5)(CALY6)'\nYOAP$DSL EQU   *\n*        VDEFINE 0(R3),0(R4),CHAR,                Calendar            @\n*              =AL4($DA#DATE_ODCALC),MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VDEFINE',       Define variable              @\n               (3),                       ..Name                       @\n               (4),                       ..Location                   @\n               =CL8'CHAR',                ..Format                     @\n               =AL4($DA#DATE_ODCALC)),    ..Length                     @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         LA    R3,7(R3)                   Bump to next \"(CALY?)\"\n         LA    R4,$DA#DATE_ODCALC(R4)     Bump to next month\n         BCT   R2,YOAP$DSL\nYOAP$DL  EQU   *\n*->      DISPLAY PANEL==CL8'DA$WDATY',MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'DISPLAY',       Service: Display             @\n               =CL8'DA$WDATY'),           ..Panel name                 @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         LTR   R15,R15\n         BNZ   YOAP$X\n*\n*->      VCOPY '(ZVERB)',ZVERBL,ZVERBA,LOCATE,MF=E\n         L     R15,EP_ISPLINK             -> EPA ISPLINK\n         CALL  (15),(=CL8'VCOPY',         Service: VCOPY               @\n               =C'(ZVERB)',               ..Name                       @\n               ZVERBL,                    ..Length                     @\n               ZVERBA,                    ..Location                   @\n               =CL8'LOCATE'),             ..Type: Move or copy         @\n               VL,MF=(E,PARMLIST)         ..Execute from here\n         ICM   R1,B'1111',ZVERBA\n         BZ    YOAP$DL\n         ICM   R0,B'1111',ZVERBL\n         BZ    YOAP$DL\n         CH    R0,=H'2'                   At least 2?\n         BL    YOAP$DL\n         CLC   0(2,R1),=C'UP'             UP?\n         BE    YOAP$DLU\n         CLC   0(2,R1),=C'DO'             Down?\n         BE    YOAP$DLD\n         CLC   0(2,R1),=C'RI'             Right?\n         BE    YOAP$DRI\n         CLC   0(2,R1),=C'LE'             Left?\n         BE    YOAP$DLE\n         B     YOAP$DL\nYOAP$DLU EQU   *\n         TM    YOAP_F1,$YF1_TOP           Already there?\n         BO    YOAP$DL                    Yes, continue\n         OI    YOAP_F1,$YF1_TOP           Set at the top\n         B     YOAP$DT                    And show the top\nYOAP$DLD EQU   *\n         TM    YOAP_F1,$YF1_TOP           At the top?\n         BNO   YOAP$DL                    No, we are at the bottom\n         NI    YOAP_F1,255-$YF1_TOP       Set at the top\n         LA    R4,YOAP_MONTHS+(6*$DA#DATE_ODCALC) Locate last 6 months\n         B     YOAP$DTX\nYOAP$DRI EQU   *\n         PACK  DOUBLE(8),PC_DATECC(4)     Make century.year packed\n         CVB   R15,DOUBLE                 Make it binary\n         LA    R15,1(R15)                 Reelin' in the years\n         B     YOAP$DLEC\nYOAP$DLE EQU   *\n         PACK  DOUBLE(8),PC_DATECC(4)     Make century.year packed\n         CVB   R15,DOUBLE                 Make it binary\n         SH    R15,=H'1'                  Reelin' in the years\nYOAP$DLEC EQU  *\n         CVD   R15,DOUBLE                 Convert back to packed\n         UNPK  DOUBLE2(4),DOUBLE+4(4)     Convert packed to zoned\n         OI    DOUBLE2+3,C'0'             Fix sign byte\n         MVC   PC_DATECC(4),DOUBLE2\n         B     YOAP$Y\n*\n** End of YOAP processing\n*\nYOAP$X   EQU   *\n         MVC   PC_DATE(8),YOAP_DATE       Restore date on entry\n         B     PIP$ZCRA\n         EJECT ,\n***********************************************************************\n***\n**       Process other calendars\n***\n***********************************************************************\n         SPACE 2\nPROCESS_OTHER_CALENDARS EQU *\n         ST    R14,POC_RA\n         MVC   POC_DATE(8),PC_DATE        Save current year\n         OI    PC_FLAG1,$PCF1_POC         POC mode\n*\n** Find month in table\n*\n         LA    R1,T_MONTH                 Locate month table\n         LA    R0,12-1                    Number of months in year\nPOC$L    EQU   *\n         CLC   TMD_MM-TMD(2,R1),PC_DATEMM Match?\n         BE    POC$LX                     Yes, continue\n         LA    R1,TMDL(R1)                No, continue\n         BCT   R0,POC$L                   Process next month\nPOC$LX   EQU   *\n*\n** Process previous month\n*\n         SH    R1,=AL2(TMDL)              Backup to previous month\n         MVC   PC_DATEMM(2),TMD_MM-TMD(R1) Save new month\n         CLI   TMD_YEAR-TMD(R1),C'C'      Current year?\n         BE    POC$C1YX                   Yes, continue\n         PACK  DOUBLE(8),PC_DATECC(4)     Make packed\n         CVB   R15,DOUBLE                 Make it binary\n         SH    R15,=H'1'                  Reelin' in the years\n         CVD   R15,DOUBLE                 Convert back to packed\n         UNPK  PC_DATECC(4),DOUBLE+4(4)   Convert packed to zoned\n         OI    PC_DATECC+3,C'0'           Fix sign byte\n         MVC   PC_DATEMM(4),=C'1201'      Fix month date\nPOC$C1YX EQU   *\n         AH    R1,=AL2(2*TMDL)\n         ST    R1,POC_NEXT\n         MVC   W_IDGUS10(C_IDGUS10L),C_IDGUS10 Initialize\n*              \"MM/DD/CCYY\"      \"CCYYMMDD\"\n         MVC   W_IDGUS10_STR+6(4),PC_DATECC\n*        MVC   W_IDGUS10_STR+8(2),PC_DATEYY\n         MVC   W_IDGUS10_STR(2),PC_DATEMM\n         MVC   W_IDGUS10_STR+3(2),PC_DATEDD\n         MVI   W_IDGUS10_STR+2,C'/'\n         MVI   W_IDGUS10_STR+5,C'/'\n         MVC   W_ODCAL1(C_ODCALCNDL),C_ODCALCND Initialize area\n*TPUT PC_DATE,8\n*TPUT W_IDGUS10_STR,10\n         L     R15,EP_DA$DATE             Locate date routine\n         CALL  (15),                      Call date routine            @\n               (W_IDGUS10,                ..output gregorian           @\n               W_ODCAL1),                 ..output calendar            @\n               VL,MF=(E,PARMLIST)         ..execution area\n         MVI   PC_OATTR,#_BLUE            Get output attribute\n         LA    R7,W_ODCAL1_STR            Locate calendar\n         BAS   R14,PROCESS_CALENDAR       Process the calendar\n*\n** Process next month\n*\n         L     R1,POC_NEXT                Locate next month entry\n         MVC   PC_DATE(4),POC_DATE        Start with a good year\n         MVC   PC_DATEMM(2),TMD_MM-TMD(R1)\n         CLI   TMD_YEAR-TMD(R1),C'C'      Current year?\n         BE    POC$C2YX\n         PACK  DOUBLE(8),PC_DATECC(4)     Make packed\n         CVB   R15,DOUBLE                 Make it binary\n         AH    R15,=H'1'                  Happy new year\n         CVD   R15,DOUBLE                 Convert back to packed\n         UNPK  PC_DATECC(4),DOUBLE+4(4)   Convert packed to zoned\n         OI    PC_DATECC+3,C'0'           Fix sign byte\n         MVC   PC_DATEMM(4),=C'0101'      Fix month date\nPOC$C2YX EQU   *\n         MVC   W_IDGUS10(C_IDGUS10L),C_IDGUS10 Initialize\n*              \"MM/DD/CCYY\"      \"CCYYMMDD\"\n         MVC   W_IDGUS10_STR+6(4),PC_DATECC\n*        MVC   W_IDGUS10_STR+8(2),PC_DATEYY\n         MVC   W_IDGUS10_STR(2),PC_DATEMM\n         MVC   W_IDGUS10_STR+3(2),PC_DATEDD\n         MVI   W_IDGUS10_STR+2,C'/'\n         MVI   W_IDGUS10_STR+5,C'/'\n         MVC   W_ODCAL3(C_ODCALCNDL),C_ODCALCND Initialize area\n*TPUT PC_DATE,8\n*TPUT W_IDGUS10_STR,10\n         L     R15,EP_DA$DATE             Locate date routine\n         CALL  (15),                      Call date routine            @\n               (W_IDGUS10,                ..output gregorian           @\n               W_ODCAL3),                 ..output calendar            @\n               VL,MF=(E,PARMLIST)         ..execution area\n         LA    R7,W_ODCAL3_STR            Locate calendar\n         BAS   R14,PROCESS_CALENDAR       Process the calendar\n*\n** Return to caller\n*\n         NI    PC_FLAG1,255-$PCF1_POC     POC mode\n         MVC   PC_DATE(8),POC_DATE        Restore\n         L     R14,POC_RA                 Get return address\n         BSM   0,R14                      Return to caller\n         EJECT ,\n***********************************************************************\n***\n**       Misc subroutines\n***\n***********************************************************************\n         SPACE 2\n*\n** Process Calendar for days\n** Input: R7 has address of the calendar from DA$DATE\n*\nPROCESS_CALENDAR DS 0H\n*-Code removed 02-SEP-1999  This code use to process the calendar\n*-and indicate IPL dates, company holidays, etc.\n         BSM   0,R14\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      Check for 0\n         BZ    EDITFWF0                   Yes, put zero\n         CVD   R1,DOUBLE                  No, convert to packec\n         LA    R1,DOUBLE2+14              Locate sig digit\n         MVC   DOUBLE2(15),EDITFWFP\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for ex\n         EX    R14,EDITFWFM               Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '\n         BSM   0,R9                       Return to caller\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Put in zero\n         LA    R15,1(R15)                 Bump pointer past zero\n         BSM   0,R9                       Return to caller\n         EJECT ,\n***********************************************************************\n***\n**       Constants\n***\n***********************************************************************\n         SPACE 2\n*\n** Months\n*\n         DC    C'12',C'P'\nT_MONTH  DS    0H\n         DC    C'01',C'C'\n         DC    C'02',C'C'\n         DC    C'03',C'C'\n         DC    C'04',C'C'\n         DC    C'05',C'C'\n         DC    C'06',C'C'\n         DC    C'07',C'C'\n         DC    C'08',C'C'\n         DC    C'09',C'C'\n         DC    C'10',C'C'\n         DC    C'11',C'C'\n         DC    C'12',C'C'\n         DC    C'01',C'N'\n         DS    0H\n*\n** ZCMD Verb table\n**\n** The max verb length is 7 given the current logic (trailing blank)\n*\nT_ZCMDV  EQU   *\n         DC    AL1(4-1),CL8'YOAP   ',AL2(YEAR_ON_A_PAGE-DA$WDATE)\n         DC    AL1(3-1),CL8'YOP    ',AL2(YEAR_ON_A_PAGE-DA$WDATE)\n         DC    AL1(4-1),CL8'YEAR   ',AL2(YEAR_ON_A_PAGE-DA$WDATE)\n         DC    AL1(8-1),CL8'ASMDATE',AL2(SHOW_ASM_DATE-DA$WDATE)\n         DC    AL1(8-1),CL8'SHOWALL',AL2(SHOW_ALL_DR-DA$WDATE)\nT_ZCMDVN EQU   (*-T_ZCMDV)/TZCCL\n*\n** Messages\n*\nMS00     EQU   * ....+....1....+....2....|        Maximum short length\nMS01     DC    C'Today''s Date'\nMS01L    EQU   *-MS01\nML01     DC    C'Today''s date is shown below'\nML01L    EQU   *-ML01\nMS02     DC    C'Input date not given'\nMS02L    EQU   *-MS02\nML02     DC    C'You must give an input date: Gregorian, Julian, etc'\nML02L    EQU   *-ML02\nMS03     DC    C' '    <- Ready for use\nMS03L    EQU   *-MS03\nML03     DC    C' '    <- Ready for use\nML03L    EQU   *-ML03\nMS04     DC    C'Input format error'\nMS04L    EQU   *-MS04\nML04     DC    C'The input field is formatted incorrectly, check '\n         DC    C'the template for format'\nML04L    EQU   *-ML04\nMS05     DC    C'Verb Invalid'\nMS05L    EQU   *-MS05\nMS06     DC    C'Calendar created'\nMS06L    EQU   *-MS06\nML06     DC    C'Your calendar is in the LIST ISPF dataset'\nML06L    EQU   *-ML06\nMS07     DC    C'Routine error'\nMS07L    EQU   *-MS07\nML07     DC    C'Could not find or load the required date routine: '\n         DC    CL8'DA$DATE'\nML07L    EQU   *-ML07\n*\n** Date routine\n*\nC_ODCALC   DA#DATE DPE,OPREFIX=C_ODCALC,OSTR=NO,                       @\n               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL\nC_ODCALCND DA#DATE DPE,OPREFIX=C_ODCALCND,OSTR=NO,                     @\n               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCALND\nC_IDJULP4A DA#DATE DPE,OPREFIX=C_IDJULP4A,                             @\n               OSTR=NO,OFLAG=$DA#DATE_ADDR,                            @\n               OSTRL=$DA#DATE_IDJULP4,OTYPE=$DA#DATE_IDJULP\nC_ODGUS10  DA#DATE DPE,OPREFIX=C_ODGUS10,OSTR=NO,                      @\n               OSTRL=$DA#DATE_ODGUS10,OTYPE=$DA#DATE_ODGUS\nC_IDGUS10  DA#DATE DPE,OPREFIX=C_IDGUS10,OSTR=NO,                      @\n               OSTRL=$DA#DATE_IDGUS10,OTYPE=$DA#DATE_IDGUS\nC_ODISO10  DA#DATE DPE,OPREFIX=C_ODISO10,OSTR=NO,                      @\n               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO\nC_IDISO10  DA#DATE DPE,OPREFIX=C_IDISO10,OSTR=NO,                      @\n               OSTRL=$DA#DATE_IDISO10,OTYPE=$DA#DATE_IDISO\nC_IDGUS8   DA#DATE DPE,OPREFIX=C_IDGUS8,OSTR=NO,                       @\n               OSTRL=$DA#DATE_IDGUS8,OTYPE=$DA#DATE_IDGUS\nC_ODGUS29  DA#DATE DPE,OPREFIX=C_ODGUS29,OSTR=NO,                      @\n               OSTRL=$DA#DATE_ODGUS29,OTYPE=$DA#DATE_ODGUS\nC_ODJUL8   DA#DATE DPE,OPREFIX=C_ODJUL8,OSTR=NO,                       @\n               OSTRL=$DA#DATE_ODJUL8,OTYPE=$DA#DATE_ODJUL\nC_IDJULC6  DA#DATE DPE,OPREFIX=C_IDJULC6,OSTR=NO,                      @\n               OSTRL=$DA#DATE_IDJULC6,OTYPE=$DA#DATE_IDJULC\nC_IDJULC8  DA#DATE DPE,OPREFIX=C_IDJULC8,OSTR=NO,                      @\n               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC\nC_ISTMPC16 DA#DATE DPE,OPREFIX=C_ISTMPC16,OSTR=NO,                     @\n               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC\nC_OTIMEM11 DA#DATE DPE,OPREFIX=C_OTIMEM11,OSTR=NO,                     @\n               OSTRL=$DA#DATE_OTIMEM11,OTYPE=$DA#DATE_OTIMEM\n             DS  0F\n*\n** Literals\n*\nLTORG    EQU   *\n         LTORG ,\nLTORGL   EQU   *-LTORG\n         DS    0D                         End of CSECT\n*\n** Determine length left addressible in main (DA$WDATE) CSECT\n*\n#DA$WDATE EQU  *-DA$WDATE                 Bytes used\n#DA$WDATE_LEFT EQU (4096*3)-#DA$WDATE     Bytes left\n         EJECT ,\n***********************************************************************\n***\n**       Dynamic Save Area\n***\n***********************************************************************\n SPACE 2\nDSA         DSECT ,\n            DS    18F                     Register Save Area\n            DS    0D\nDOUBLE2     DS    2D                      Double word work area * 2\nDOUBLE      DS    D                       Double word work area\nPARMLIST    DS    20F                     Parameter list for calls\nR1SAVE      DS    F\n            DS    0F                      Process_Calendar\nPC_RA       DS    F                       ..Return address\nPC_DATE     EQU   *                       ..Current date\nPC_DATECC   DS    C'CC'                   ....Century\nPC_DATEYY   DS    C'YY'                   ....Year\nPC_DATEMM   DS    C'MM'                   ....Month\nPC_DATEDD   DS    C'DD'                   ....Day\nPC_IPLD     DS    C'mm/dd/CCYY'           ..IPL Date\nPC_OATTR    DS    X                       ..Output attribute: #_????\nPC_FLAG1    DS    B'00000000'             ....Flag 1\n$PCF1_ID    EQU   B'10000000'             ....IPL Date formated?\n$PCF1_F     EQU   B'01000000'             ....IPL Date found?\n$PCF1_POC   EQU   B'00100000'             ....POC mode?\n$PCF1_TODAY EQU   B'00010000'             ....POC mode?\n            DS    0F                      Process_Other_Calendars\nPOC_RA      DS    F                       ..Return address\nPOC_NEXT    DS    F                       ..Next TMD entry\nPOC_DATE    DS    C'ccyymmdd'             ..Date on entry\n            DS    0F                      Year_On_A_Page\nYOAP_SREGS  DS    3F                      ..Save registers\nYOAP_DATE   DS    C'ccyymmdd'             ..Date on entry\nYOAP_F1     DS    B'00000000'             ..Flag 1\n$YF1_SIDEW  EQU   B'10000000'             ....Sideways Calendar?\n$YF1_TOP    EQU   B'01000000'             ....Top of calendars?\nYOAP_MONTHS DS    XL(12*$DA#DATE_ODCALC)  ..Months for calendar\n            DS    0H                      Print_ListLine\nPLL_CC      DS    CL8' '                  ..Control Character?\n            DS    0F                      Process_Input_Panel\nPIP_CDATE   DS    XL32                    ..Current date pointer\nPIP_CURSOR  DS    CL8                     ..Cursor field name\nPIP_LGDATE  DS    CL10'mm/dd/ccyy'        ..Last gregorian date\nPIP_LJDATE  DS    CL8'yyyy.ddd'           ..Last Julian date\n            DS    0F                      Entry_Point\nEP_DA$DATE  DS    F                      ..DA$DATE\nEP_ISPLINK  DS    F                      ..DA$DATE\n*\n** Flag\n*\nFLAG1       DS    B'00000000'             Flag 1\n$F1LDAD     EQU   B'10000000'             ..Loaded DA$DATE\n$F1TOD      EQU   B'01000000'             ..TOD (need output time?)\n*\n** ISPF variables\n*\nIVARS       EQU   *\nIDATE       DS    CL32' '                 Input date\nIVARSL      EQU   *-IVARS\n*\nOGDATE      DS    CL32' '                 Output full date\nOJDATE      DS    C'ccyy.ddd'             Output julian date\nOTIME       DS    C'hh:mm:ss.th'          Output julian date\nOIDATE      DS    C'ccyy-mm-dd'           Output ISO date\n*\nZERRSML     DS    F                       Short error message length\nZERRSM      DS    CL24                    Short error message\nZERRLM      DS    CL160                   Long error message\nZERRHM      DS    CL8                     Message help member\nZERRALRM    DS    CL3                     Alarm\n            DS    0F\nZVERBA      DS    F                       Address of ZVERB variable\nZVERBL      DS    F                       Length of ZVERB variable\n*\nZCMDL       DS    F                       ZCMD length\nZCMDA       DS    F                       ZCMD address\n*\n** Date routine areas\n*\n         DS    0F\nW_ODCAL1    DA#DATE DPE,OPREFIX=W_ODCAL1,OSTR=YES,                     @\n               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL\nW_ODCAL2    DA#DATE DPE,OPREFIX=W_ODCAL2,OSTR=YES,                     @\n               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL\nW_ODCAL3    DA#DATE DPE,OPREFIX=W_ODCAL3,OSTR=YES,                     @\n               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL\nW_ODCALY    DA#DATE DPE,OPREFIX=W_ODCALY,OSTR=YES,                     @\n               OSTRL=$DA#DATE_ODCALC,OTYPE=$DA#DATE_ODCAL\nW_IDJULP4A  DA#DATE DPE,OPREFIX=W_IDJULP4A,OSTR=YES,OSTRL=4\nW_ODGUS10   DA#DATE DPE,OPREFIX=W_ODGUS10,OSTR=YES,                    @\n               OSTRL=$DA#DATE_ODGUS10,OTYPE=$DA#DATE_ODGUS\nW_IDGUS10   DA#DATE DPE,OPREFIX=W_IDGUS10,OSTR=YES,                    @\n               OSTRL=$DA#DATE_IDGUS10,OTYPE=$DA#DATE_IDGUS\nW_ODISO10   DA#DATE DPE,OPREFIX=W_ODISO10,OSTR=YES,                    @\n               OSTRL=$DA#DATE_ODISO10,OTYPE=$DA#DATE_ODISO\nW_IDISO10   DA#DATE DPE,OPREFIX=W_IDISO10,OSTR=YES,                    @\n               OSTRL=$DA#DATE_IDISO10,OTYPE=$DA#DATE_IDISO\nW_IDGUS8    DA#DATE DPE,OPREFIX=W_IDGUS8,OSTR=YES,                     @\n               OSTRL=$DA#DATE_IDGUS8,OTYPE=$DA#DATE_IDGUS\nW_ODGUS29   DA#DATE DPE,OPREFIX=W_ODGUS29,OSTR=YES,                    @\n               OSTRL=$DA#DATE_ODGUS29,OTYPE=$DA#DATE_ODGUS\nW_ODJUL8    DA#DATE DPE,OPREFIX=W_ODJUL8,OSTR=YES,                     @\n               OSTRL=$DA#DATE_ODJUL8,OTYPE=$DA#DATE_ODJUL\nW_IDJULC6   DA#DATE DPE,OPREFIX=W_IDJULC6,OSTR=YES,                    @\n               OSTRL=$DA#DATE_IDJULC6,OTYPE=$DA#DATE_IDJULC\nW_IDJULC8   DA#DATE DPE,OPREFIX=W_IDJULC8,OSTR=YES,                    @\n               OSTRL=$DA#DATE_IDJULC8,OTYPE=$DA#DATE_IDJULC\nW_ISTMPC16  DA#DATE DPE,OPREFIX=W_ISTMPC16,OSTR=YES,                   @\n               OSTRL=$DA#DATE_ISTMPC16,OTYPE=$DA#DATE_ISTMPC\nW_OTIMEM11 DA#DATE DPE,OPREFIX=W_OTIMEM11,OSTR=NO,                     @\n               OSTRL=$DA#DATE_OTIMEM11,OTYPE=$DA#DATE_OTIMEM\n*\nLISTLINE    DS    CL160\n            DS    CL512\n*\n** End of the DSECT\n*\n         DS    0D                         Alignment for FREEMAIN\nDSAL     EQU   *-DSA\n         EJECT ,\n***********************************************************************\n***\n**       DSECTs and equates\n***\n***********************************************************************\n         SPACE 2\n*\n** Map T_MONTH table\n*\nTMD      DSECT ,\nTMD_MM   DS    CL2\nTMD_YEAR DS    C\nTMDL     EQU   *-TMD\n*\n** Map T_HCALD\n*\nTHCAL        DSECT ,\nTHCAL_CC     DS    C'CC'\nTHCAL_YY     DS    C'YY'\nTHCAL_MM     DS    C'MM'\nTHCAL_DD     DS    C'DD'\nTHCAL_COLOR  DS    X                      ..Colour\nTHCAL_DESC   DS    AL2(*-*)               ..Offset of description str\nTHCALL       EQU   *-THCAL\n*\n** T_ZCMDV table entry mapping\n*\nTZCC        DSECT ,\nTZCC_MINL   DS    X                       Minimum length: \"Verb oper\"\nTZCC_VERB   DS    CL8                     Verb\nTZCC_ROUTO  DS    AL2                     Routine offset\nTZCCL       EQU   *-TZCC\n*\n** Colors on DA$WDAT_ ISPF panels\n*\n#_BLUE   EQU 01                           Colour: blue\n#_WHITE  EQU 02                           Colour: white\n#_YELLOW EQU 03                           Colour: yellow\n#_TURQ   EQU 04                           Colour: turq\n#_RED    EQU 05                           Colour: red\n#_GREEN  EQU 06                           Colour: red\n*\n#_BLUEB  EQU 11                           Colour: blue   Attr: Blink\n#_WHITEB EQU 12                           Colour: white  Attr: Blink\n#_YELLOWB EQU 13                          Colour: yellow Attr: Blink\n#_TURQB  EQU 14                           Colour: turq   Attr: Blink\n#_REDB   EQU 15                           Colour: red    Attr: Blink\n#_GREENB EQU 16                           Colour: Green  Attr: Blink\n*\n** Map the T_SOA table\n*\nTSOA     DSECT ,\nTSOA_N   DS    CL8'        '\nTSOA_T   DS    XL2\nTSOA_L   DS    XL2\nTSOAL    EQU   *-TSOA\n*\n** Non-IBM DSECTs and equates\n*\n         DA#DATE ,                        Date routine\n*\n** IBM DSECTs and equates\n*\n         CVT   DSECT=YES,LIST=NO          MVS CVT\n         IEESMCA ,                        SMF control area\n         IKJCPPL ,\n         END   ,\n         SPACE 2\n***********************************************************************\n***\n**        Linkage editor cards - ASM.PARM='BATCH,...'\n***\n***********************************************************************\n         SPACE 2\n PUNCH ' ENTRY   DA$WDATE         '       Entry point\n PUNCH ' INCLUDE SYSLMOD(DA$DATE) '       Subroutine: Date routine\n PUNCH ' NAME    DA$WDATE(R)      '       Name of load module\n         END ,\n./ ADD NAME=DA$WDATM 0102-01283-01283-1344-00060-00055-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: DA$WDATM                                                   */\n /* Application: WHATDATE (DA$WDATE)                                 */\n /* Author: David Alcock                                             */\n /* Purpose: Do date conversions                                     */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n \u00a6 area(dynamic) scroll(on)\n ? area(dynamic)\n 01 type(dataout) color(blue)\n 02 type(dataout) color(white)  intens(high)\n 03 type(dataout) color(yellow) intens(high)\n 04 type(dataout) color(turq)   intens(high)\n 05 type(dataout) color(red)    intens(high)\n 06 type(dataout) color(green)  intens(high)\n 0B type(dataout) color(blue)                 hilite(blink)\n 0C type(dataout) color(white)  intens(high)  hilite(blink)\n 0D type(dataout) color(yellow) intens(high)  hilite(blink)\n 0E type(dataout) color(turq)   intens(high)  hilite(blink)\n 0F type(dataout) color(red)    intens(high)  hilite(blink)\n 10 type(dataout) color(green)  intens(high)  hilite(blink)\n)body\n%----------------------------\u00ac Date conversion %-------------------------------+\n%Option ===>_ZCMD\n\n`Input Date%===>_IDATE                           \u00a2\n\n\u00a2Formats:       ~mm/dd/yy mm/dd/ccyy ccyy-mm-dd yy.ddd ccyy.ddd\n                ~mm-dd-yy mm-dd-ccyy\n%-------------------------------------------------------------------------------\n\n                          {OGDATE\n                          {OIDATE\n                          }OJDATE\n                          {OTIME\n %Previous month                                                   %Next month\n                          \u00ac                          +\n~?CAL1               ?    \u00ac `?CAL2               ? \u00ac +  ~?CAL3               ?\n+?                   ?    \u00ac %?                   ? \u00ac +  +?                   ?\n+?                   ?    \u00ac %?                   ? \u00ac +  +?                   ?\n+?                   ?    \u00ac %?                   ? \u00ac +  +?                   ?\n+?                   ?    \u00ac %?                   ? \u00ac +  +?                   ?\n+?                   ?    \u00ac %?                   ? \u00ac +  +?                   ?\n+?                   ?    \u00ac %?                   ? \u00ac +  +?                   ?\n+?                   ?    \u00ac %?                   ? \u00ac +  +?                   ?\n    \u00a6D\u00a6                   \u00ac                          +\n)init\n .HELP = DA$WDATT\n &ZCMD = &ZNULL\n)reinit\n &ZCMD = &ZNULL\n)proc\n)end\n./ ADD NAME=DA$WDATT 0101-01283-01283-1336-00035-00035-00000-DALCOCK\n)ATTR\n # TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n \u00a2 TYPE(TEXT) INTENS(HIGH) COLOR(green)\n \u00a6 TYPE(TEXT) INTENS(HIGH) COLOR(pink)\n @ TYPE(TEXT) INTENS(HIGH) COLOR(green) hilite(reverse)\n \u00ac TYPE(TEXT) INTENS(HIGH) COLOR(red)\n ` TYPE(TEXT) INTENS(HIGH) COLOR(turq)\n ~ TYPE(TEXT) INTENS(low) COLOR(turq)\n)BODY EXPAND(\\\\)\n\u00a6TUTORIAL \\-\\  Date Conversion \\-\\ TUTORIAL\n%Option ===>_ZCMD                                                              +\n%\n+This ISPF application converts between Gregorian and Julian date formats.\n+\n+Either specify a Gregorian, Julian or 32-bit TOD formats.\n+\n\u00a2Primary Commands:\n+\n  #ASMDATE+-`Display the ISPF application and date routine assembly date\n  #SHOWALL+-`Display all output date formats that DA$DATE does\n  #YEAR   +-`Show the full calendar year\n  #YEAR Sideways +-`Puts a full calendar year in your current ISPF list\n                   `dataset in the ever so useful \"sideways\" format.\n+\n\u00a2PFKeys to quickly move the current date around:\n+\n  #PF7    +-`Backup one day in the year\n  #PF8    +-`Advance one day in the year\n  #PF10   +-`Backup one year\n  #PF11   +-`Advance one year\n+\n+Hit the#END+key to return to the Date Conversion ISPF application.\n)INIT\n)PROC\n)END\n./ ADD NAME=DA$WDATY 0101-01283-01283-1336-00054-00054-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: DA$WDATY                                                   */\n /* Application: WHATDATE (DA$WDATE)                                 */\n /* Author: David Alcock                                             */\n /* Purpose: Show Calendars for a year                               */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n \u00a6 area(dynamic) scroll(on)\n ? area(dynamic)\n 01 type(dataout) color(blue)\n 02 type(dataout) color(white)  intens(high)\n 03 type(dataout) color(yellow) intens(high)\n 04 type(dataout) color(turq)   intens(high)\n 05 type(dataout) color(red)    intens(high)\n 06 type(dataout) color(green)  intens(high)\n 0B type(dataout) color(blue)                 hilite(blink)\n 0C type(dataout) color(white)  intens(high)  hilite(blink)\n 0D type(dataout) color(yellow) intens(high)  hilite(blink)\n 0E type(dataout) color(turq)   intens(high)  hilite(blink)\n 0F type(dataout) color(red)    intens(high)  hilite(blink)\n 10 type(dataout) color(green)  intens(high)  hilite(blink)\n)body\n%----------------------------------\u00ac &YEAR%------------------------------------+\n%Option ===>_ZCMD\n\n~?CALY1              ?      ~?CALY2              ?      ~?CALY3              ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n\n~?CALY4              ?      ~?CALY5              ?      ~?CALY6              ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n+?                   ?      +?                   ?      +?                   ?\n    \u00a6D\u00a6\n\u00a2Scroll using the#UP\u00a2and#DOWN\u00a2keys or hit the#END\u00a2key to return to main screen.\n)init\n)proc\n)end\n./ ADD NAME=DA#COBOL 0100-01266-01266-1821-00178-00178-00000-DAVE\n         MACRO ,\n         DA#COBOL ,\n.**********************************************************************\n.***                                                                ***\n.** These DSECTs were taken from the COMPILE program by              **\n.**                                                                  **\n.** Author:       Roland Schiradin (Systematics Service GmbH,         *\n.**               Hamburg Germany)                                    *\n.**                                                                  **\n.***                                                                ***\n.**********************************************************************\n*============================================================*\n* COBOL/370 DCL\n*============================================================*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  excatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-X_FLAG1S Bitmask\nCEE_FLAG2           DS X    Member X_FLAG1s for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    PGT-Address\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\n                    DS F    available word\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of programm\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\n                    DS F    available word\n                    DS F    available word\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\n*============================================================*\n* COBOL2 DCL\n*============================================================*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of programm\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\n                   DS A\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n*\nADV      EQU   B'10000000'\nAPOST    EQU   B'01000000'\nDATA31   EQU   B'00100000'\nDECK     EQU   B'00010000'\nDUMP     EQU   B'00001000'\nDYNAM    EQU   B'00000100'\nFASTSRT  EQU   B'00000010'\nFDUMP    EQU   B'00000001'\nLIB      EQU   B'10000000'\nLIST     EQU   B'01000000'\nMAP      EQU   B'00100000'\nNUM      EQU   B'00010000'\nOBJ      EQU   B'00001000'\nOFFSET   EQU   B'00000100'\nOPTIMIZE EQU   B'00000010'\nDDNAME   EQU   B'00000001'\nNUMPROC  EQU   B'10000000'\nRENT     EQU   B'01000000'\nRES      EQU   B'00100000'\nSEQUENCE EQU   B'00010000'\nSIZE     EQU   B'00001000'\nSOURCE   EQU   B'00000100'\nSSRANGE  EQU   B'00000010'\nTERM     EQU   B'00000001'\nTEST     EQU   B'10000000'\nTRUNC    EQU   B'01000000'\nUSERW    EQU   B'00100000'\nVBREF    EQU   B'00010000'\nXREF     EQU   B'00001000'\nZWB      EQU   B'00000100'\nNAME     EQU   B'00000010'\nCMPR2    EQU   B'00000001'\nNUMPROCM EQU   B'10000000'\nNUMCLASS EQU   B'01000000'\nDBCS     EQU   B'00100000'\nAWO      EQU   B'00010000'\nTRUNCB   EQU   B'00001000'\nEVENTS   EQU   B'00000100'\nCURRENCY EQU   B'00000010'\n         MEND  ,\n./ ADD NAME=DA#DATE  0100-01266-01266-1821-00226-00226-00000-DAVE\n         MACRO ,\n         DA#DATE &ITYPE,                  Type of macro invocation     @\n               &OPREFIX=DA#DATED,         Parameter: Prefix            @\n               &OFLAG=0,                  Parameter: Flag              @\n               &OSTR=NO,                  Parameter: Generate area?    @\n               &OSTRL=0,                  Parameter: Length of area    @\n               &OTYPE=0,                  Parameter: Type constant     @\n               &MF=L\n.**********************************************************************\n.***                                                                ***\n.**  Name: DA#DATE                                                   **\n.**                                                                  **\n.**  Purpose: Provide external interface equates and DSECTs for      **\n.**           DA#DATE routine.                                       **\n.***                                                                ***\n.**********************************************************************\n.*\n.** Branch table\n.*\n AIF   ('&ITYPE' EQ '').EQU\n AIF   ('&ITYPE' EQ 'EQU').EQU\n AIF   ('&ITYPE' EQ 'EQUATE').EQU\n AIF   ('&ITYPE' EQ 'EQUATES').EQU\n AIF   ('&ITYPE' EQ 'DPE').DPE\n AIF   ('&ITYPE' EQ 'STRLOC').STRLOC      Locate String?\n AIF   ('&ITYPE' EQ 'STRLEN').STRLEN      Calculate length of string?\n MNOTE 8,'DA#DATE-01E &ITYPE is invalid'\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**       Calculate string length                                    **\n.***                                                                ***\n.**********************************************************************\n.STRLEN ANOP ,\n LR    R14,R15                            Save address on string\n.STRLOC ANOP ,\n TM    &OPREFIX._FLAG,$DA#DATE_ADDR       Address type string?\n BO    SL&SYSNDX.A                        Yes, locate output location\n LA    R15,&OPREFIX._STR                  No, output at this label\n B     SL&SYSNDX.B                        Move on\nSL&SYSNDX.A EQU *\n L     R15,&OPREFIX._STR                  Locate string\nSL&SYSNDX.B EQU *\n AIF   ('&ITYPE' NE 'STRLEN').SLX         .Check invocation type\n SR    R14,R15                            Length = End - Begining\n STC   R14,&OPREFIX._STRL                 Save length\n.SLX ANOP ,\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**       Map the input parameter format                             **\n.***                                                                ***\n.**********************************************************************\n.EQU     ANOP  ,\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** DA#DATE Parameter Entry\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n.DPE ANOP ,\n&OPREFIX.         EQU *\n&OPREFIX._TYPE    DC  AL2(&OTYPE)\n&OPREFIX._FLAG    DC  AL1(&OFLAG)\n&OPREFIX._STRL    DC  AL1(&OSTRL)\n AIF ('&OSTR' EQ 'NO').DPEA\n&OPREFIX._STR     DC  XL(&OSTRL.)'00'\n AGO  .DPEAX\n.DPEA    ANOP ,\n&OPREFIX._STR     EQU *\n.DPEAX   ANOP ,\n&OPREFIX.L        EQU  *-&OPREFIX.\n AIF   ('&ITYPE' NE 'DPE').DPEX\n MEXIT ,\n.DPEX ANOP ,\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** DA#DATE Equates\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n*                                         DA#DATED_FLAG\n*                                         ..Error\n$DA#DATE_EITYPE   EQU B'10000000'           ..Invalid type\n$DA#DATE_EISTRL   EQU B'01000000'           ..Invalid String Length\n$DA#DATE_EISTR    EQU B'00100000'           ..Invalid String\n$DA#DATE_EEXEC    EQU B'00010000'           ..Execution Error\n$DA#DATE_ENOSAVE  EQU B'00001000'           ..No Saved entry\n$DA#DATE_ROUTINE1 EQU B'00000001'           ..For use for routines\n*                                         ..Input options\n$DA#DATE_ADDR     EQU B'00000001'           ..Use address\n$DA#DATE_ELASPED  EQU B'00000010'           ..Elasped time/date\n*\n$DA#DATE_INVALID EQU X'FF'                Invalid \"S_\" address\n*\n** Time zones - Need to have offset from GMT...\n*\n$DA#DATE_TZ_PST   EQU C'PST'              ..Pacific  Standard Time 1\n$DA#DATE_TZ_MST   EQU C'MST'              ..Mountian Standard Time 2\n$DA#DATE_TZ_CST   EQU C'CST'              ..Central  Standard Time 3\n$DA#DATE_TZ_EST   EQU C'EST'              ..Eastern  Standard Time 4\n$DA#DATE_TZ_AST   EQU C'AST'              ..Atlantic Standard Time 5\n SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n*                           Output\n*                           ..Date\n$DA#DATE_ODGUS    EQU 1       ..Gregorian (US)\n$DA#DATE_ODGUS29      EQU 29    ..dayofweek, mmmmmmmmm dd, ccyy\n$DA#DATE_ODGUS23      EQU 23    ..dow, mmmmmmmmm dd, ccyy\n$DA#DATE_ODGUS18      EQU 18    ..mmmmmmmmm dd, ccyy\n$DA#DATE_ODGUS12      EQU 11    ..mmm dd ccyy\n$DA#DATE_ODGUS10      EQU 10    ..mm/dd/ccyy\n$DA#DATE_ODGUS8T      EQU 9     ..mmddccyy    (Output length = 8...)\n$DA#DATE_ODGUS8       EQU 8     ..mm/dd/yy\n$DA#DATE_ODGUS6       EQU 6     ..mmddyy\n*\n$DA#DATE_ODGEUR   EQU 2       ..Gregorian (European)\n$DA#DATE_ODGEUR29     EQU 29    ..dayofweek, dd-mmmmmmmmm-ccyy\n$DA#DATE_ODGEUR23     EQU 23    ..dow, dd-mmmmmmmmm-ccyy\n$DA#DATE_ODGEUR18     EQU 18    ..dd-mmmmmmmmm-ccyy\n$DA#DATE_ODGEUR11     EQU 11    ..dd-mmm-ccyy\n$DA#DATE_ODGEUR10     EQU 10    ..dd/mm/ccyy\n$DA#DATE_ODGEUR8T     EQU 9     ..ddmmccyy    (Output length = 8...)\n$DA#DATE_ODGEUR8      EQU 8     ..dd/mm/yy\n$DA#DATE_ODGEUR6      EQU 6     ..ddmmyy\n*\n$DA#DATE_ODJUL    EQU 3       ..Julian (IBM)\n$DA#DATE_ODJUL8       EQU 8     ..19YY.DDD\n$DA#DATE_ODJUL6       EQU 6     ..YY.DDD\n$DA#DATE_ODJUL5       EQU 5     ..YYDDD\n$DA#DATE_ODJUL3       EQU 3     ..DDD\n*\n$DA#DATE_ODGJUL   EQU 4       ..Gregoran.Julian: MM/DD/YY.DDD\n$DA#DATE_OUS      EQU 5       ..US: Date/Time string\n$DA#DATE_OEUR     EQU 6       ..Europe: Date/Time String\n$DA#DATE_ODDOW    EQU 7       ..Day of week (Sunday, Monday, ...)\n$DA#DATE_ODDOW1       EQU 1     ..Number (Binary):\n$DA#DATE_ODDOW1SUN        EQU 0   ..Sunday\n$DA#DATE_ODDOW1MON        EQU 1   ..Monday\n$DA#DATE_ODDOW1TUE        EQU 2   ..Tuesday\n$DA#DATE_ODDOW1WED        EQU 3   ..Wednesday\n$DA#DATE_ODDOW1THU        EQU 4   ..Thursday\n$DA#DATE_ODDOW1FRI        EQU 5   ..Friday\n$DA#DATE_ODDOW1SAT        EQU 6   ..Saturday\n$DA#DATE_ODDOW3       EQU 3     ..WED\n$DA#DATE_ODDOW9       EQU 9     ..Wednesday\n$DA#DATE_ODMONTHN EQU 8       ..Month Name\n$DA#DATE_ODMONTHN3    EQU 3     ..SEP\n$DA#DATE_ODMONTHN9    EQU 9     ..September\n$DA#DATE_ODDOM    EQU 9       ..Day of the month\n$DA#DATE_ODYEAR   EQU 10      ..Year\n*                           ..Time\n$DA#DATE_OTIMES   EQU 11      ..Time standard: 01:00 PM\n$DA#DATE_OTIMES14     EQU 14    ..HH:MM:SS.th am\n$DA#DATE_OTIMES11     EQU 11    ..HH:MM:SS am\n$DA#DATE_OTIMES8      EQU 8     ..HH:MM am\n$DA#DATE_OTIMES5      EQU 5     ..HH:MM\n*                           ..Time\n$DA#DATE_OTIMEM   EQU 12      ..Time military: 13:00:00\n$DA#DATE_OTIMEM11     EQU 11    ..HH:MM:SS.th\n$DA#DATE_OTIMEM8      EQU 8     ..HH:MM:SS\n$DA#DATE_OTIMEM6C     EQU 6     ..HHMMSS  (compressed)\n$DA#DATE_OTIMEM5      EQU 5     ..HH:MM\n*                           ..Time\n$DA#DATE_OETD     EQU 13      ..Elasped Time/Date\n$DA#DATE_OETD30       EQU 30    ..XXX Years, 5 Days, HH:MM:SS.th\n*                           ..Calendar\n$DA#DATE_ODCAL    EQU 14      ..Calendar Character format\n$DA#DATE_ODCALC       EQU 8*(3*7)  ..Length of Calendar area\n$DA#DATE_ODCALC_WEEKN     EQU 8      ..Number of \"weeks\" w/2 headings\n$DA#DATE_ODCALC_WEEKL     EQU 3*7    ..Length of a week\n$DA#DATE_ODCALC_DATEEL    EQU 3      ..Length of each day in a week\n$DA#DATE_ODCALV       EQU 42\n$DA#DATE_ODCALND  EQU 15      ..Calendar Character format, no \"**\"\n*\n$DA#DATE_ODISO    EQU 16   ..ISO (standard date)\n$DA#DATE_ODISO10      EQU 10  ..ccyy-mm-dd\n SPACE 2\n*                           Input\n*                           ..Date\n$DA#DATE_IDJULC   EQU 93      ..Julian (character)\n$DA#DATE_IDJULC8      EQU 8     ..CCYY.DDD - where CC is Century\n$DA#DATE_IDJULC7      EQU 7     ..CCYYDDD  - where CC is Century\n$DA#DATE_IDJULC6      EQU 6     ..YY.DDD\n$DA#DATE_IDJULC5      EQU 5     ..YYDDD\n*\n$DA#DATE_IDJULP   EQU 94      ..Julian (packed)\n$DA#DATE_IDJULP4      EQU 4     ..CCYYDDDF\n$DA#DATE_IDJULP3      EQU 3     ..YYDDDF\n*\n$DA#DATE_IDGUS    EQU 95      ..Gregorian (US)\n$DA#DATE_IDGUS12      EQU 12    ..MMM DD, 19YY\n$DA#DATE_IDGUS10      EQU 10    ..MM/DD/19YY\n$DA#DATE_IDGUS8       EQU 8     ..MM/DD/YY\n$DA#DATE_IDGUS6       EQU 6     ..MMDDYY\n*\n$DA#DATE_IDGEUR   EQU 96      ..Gregorian (Europe)\n$DA#DATE_IDJFCB   EQU 97      ..Job file Control Block\n*                               JFCBXPDT year bytes represents a year\n*                               offset from 1900, thus X'FF' is 2155\n$DA#DATE_IDTLABEL EQU 98      ..Tape label\n*                               1 - century: blank: 19, 0=20, 1=21\n*                           ..TIME\n$DA#DATE_ITBIN    EQU 99      ..Binary\n$DA#DATE_ITBIN4       EQU 4     ..F'######'\n*\n$DA#DATE_ISTMPC   EQU 100     ..System Time Stamp character\n$DA#DATE_ISTMPC16     EQU 16    ..Hex character string (IDCAMS)\n*\n$DA#DATE_ISTMPV   EQU 101     ..System Time Stamp Value\n$DA#DATE_ISTMPV8      EQU 8     ..Double word value\n*\n$DA#DATE_ITIMES   EQU 102     ..Time standard: 01:00 PM\n$DA#DATE_ITIMES14     EQU 14    ..HH:MM:SS.th am\n$DA#DATE_ITIMES11     EQU 11    ..HH:MM:SS am\n$DA#DATE_ITIMES8      EQU 8     ..HH:MM am\n$DA#DATE_ITIMES6      EQU 6     ..HH:MMa\n$DA#DATE_ITIMES5      EQU 5     ..HHMMa\n*\n$DA#DATE_ITIMEM   EQU 103     ..Time military: 13:00:00\n$DA#DATE_ITIMEM11     EQU 11    ..HH:MM:SS.th\n$DA#DATE_ITIMEM8      EQU 8     ..HH:MM:SS\n$DA#DATE_ITIMEM6      EQU 6     ..HHMMSS\n$DA#DATE_ITIMEM5      EQU 5     ..HH:MM\n$DA#DATE_ITIMEM4      EQU 4     ..HHMM\n*\n$DA#DATE_ITDEC    EQU 104     ..Decimal (like from TIME macro)\n$DA#DATE_ITDEC4       EQU 4     ..F'######'\n*\n$DA#DATE_IDISO    EQU 105  ..ISO (standard date)\n$DA#DATE_IDISO10      EQU 10  ..ccyy-mm-dd\n MEND  ,\n./ ADD NAME=DA#ENTER 0100-01266-01266-1821-00331-00331-00000-DAVE\n         MACRO\n&LABEL   DA#ENTER &MSG,         Eye catcher for load module            @\n               &BASE=12,        Base register                          @\n               &FLOAT=NO,       Equate floating point registers        @\n               &GPR=YES,        Equate general purpose registers       @\n               &LOC=RES,        Getmain location in virtual storage    @\n               &LV=72,          Length of getmained area (default)     @\n               &ORG=C,          Location counter                       @\n               &PL=,            Global flag                            @\n               &RENT=NO,        Re-entrant?                            @\n               &AMODE=24,       Addressing mode for CSECT              @\n               &RMODE=24,       Residency mode for CSECT               @\n               &CLEAR=YES,      Clear Getmained area to binary zeros   @\n               &GMTYPE=R,       Getmain register type: R, RU, RC       @\n               &ASMINFO=YES,    Have DA#EYEC insert Assemble info?     @\n               &DATEFMT=ISO,    Date format used by DA#EYEC            @\n               &RSA=,           Register save area                     @\n               &SP=0            Getmain subpool number\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*  MACNAME:  ENTER                                                  *\n.*  MACAUTH:  Skip Abadie                                            *\n.*  MACDATE:  12/01/80                                               *\n.*  MACUPTE:  David Alcock                                           *\n.*                                                                   *\n.*  May be used in conjuntion with LEAVE macro.                      *\n.*  Registers R0 and R1 are restored to entry values prior to exit.  *\n.*                                                                   *\n.*  This macro automatically invokes the REQUATE (register equate)   *\n.*  macro unless global flag &REGS is set to one.                    *\n.*                                                                   *\n.*  This macro conditionally invokes the DA#EYEC macro in order to   *\n.*  build a standard OS format module identifier.  If global flag    *\n.*  &PROLOG is set to one, or if &PL=NO is specified, the DA#EYEC    *\n.*  MACRO is not invoked.                                            *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*                                                                   *\n.*  MSG  'TEXT STRING'                                               *\n.*       THIS OPTIONAL PARAMETER WILL OVERRIDE THE DEFAULT STANDARD  *\n.*       OS FORMAT MODULE IDENTIFIER GENERATED BY THE DA#EYEC MACRO. *\n.*       DA#ENTER USES DA#EYEC TO GENERATE THE MODULE IDENTIFIER.    *\n.*       SEE THE DESCRIPTION OF THE MSG PARAMETER IN THE PROLOGUE    *\n.*       MACRO FOR CODING DETAILS.                                   *\n.*                                                                   *\n.*  BASE={REG\u00a6(REG0,REG1,...,REGN)\u00a6NO}                               *\n.*       BASE REGISTER:  REGISTER SPECIFIED WILL BE USED AS A BASE   *\n.*       REGISTER.  DEFAULT IS REGISTER 12.  RANGE 2 - 12.  IF THE   *\n.*       LIST FORM OF THE OPERAND IS USED, A USING STATEMENT HAVING  *\n.*       ALL THE INDICATED REGISTERS WILL BE GENERATED.  IN THE LIST *\n.*       FORM, THE FIRST REGISTER IS CONSIDERED TO BE THE FIRST BASE *\n.*       REGISTER.  ALL BASE REGISTERS ARE INITIALIZED.  NO BASE     *\n.*       REGISTER IS ESTABLISHED IF BASE=NO IS CODED; ALL OTHER      *\n.*       ACTIONS OCCUR AS DESCRIBED.                                 *\n.*  LV={LITERAL\u00a6EXPRESSION}                                          *\n.*       THIS PARAMETER IS APPLICABLE ONLY IF RENT=YES IS CODED.     *\n.*       THE VALUE OF THE LITERAL OR EXPRESSION IS USED IN AN R-FORM *\n.*       GETMAIN.  THE FIRST 72 BYTES OF THE AREA ARE USED FOR A     *\n.*       REGISTER SAVE AREA.  REGISTER 13 WILL BE LOADED WITH THE    *\n.*       ADDRESS OF THE AREA.                                        *\n.*       LITERAL:  A VALUE FROM 72 TO 4096 INCLUSIVE.                *\n.*       EXPRESSION:  ANY VALID ASSEMBLER EXPRESSION OF ANY VALUE.   *\n.*  RENT={YES\u00a6NO}                                                    *\n.*       YES:  GENERATE GETMAIN TO ACQUIRE SAVE AREA.  RENT=YES WILL *\n.*       FACILITATE THE USE OF REENTRANT CODING TECHNIQUES.          *\n.*       NO:   GENERATE STANDARD IN-LINE 18 WORD SAVE AREA.          *\n.*  ORG={L\u00a6C}                                                        *\n.*       L:  USE CURRENT LOCATION COUNTER VALUE IN USING STATEMENT   *\n.*       (E.G.,   USING *,R12   ).                                   *\n.*       C:  USE CSECT LABEL (&SYSECT) AS ORIGIN FOR USING STATEMENT *\n.*       (E.G.,   USING &SYSECT,R12   ).                             *\n.*  PL={ \u00a6NO}                                                        *\n.*       NO:   THE PROLOG GLOBAL FLAG IS NOT CHECKED, AND THE        *\n.*       DA#EYEC MACRO IS NOT INVOKED.   THIS PARAMETER SHOULD ONLY  *\n.*       BE SPECIFIED WHEN NO MESSAGE AND CSECT GENERATION IS        *\n.*       REQUIRED, AND/OR NO DA#EYEC MACRO HAS BEEN INVOKED,         *\n.*       DIRECTLY OR INDIRECTLY, SINCE THE LAST OCCURRENCE OF ENTER. *\n.*                                                                   *\n.*** AMODE, RMODE,  ADDED FOR MVS/XA SUPPORT 85.122 -DGA-          ***\n.*                                                                   *\n.*  AMODE={ \u00a624\u00a631\u00a6ANY}                                              *\n.*       24:  THE PROGRAM IS DESIGNED TO RECEIVE CONTROL IN 24-BIT   *\n.*            MODE.                                                  *\n.*       31:  THE PROGRAM IS DESIGNED TO RECEIVE CONTROL IN 31-BIT   *\n.*            MODE.                                                  *\n.*       ANY: THE PROGRAM IS DESIGNED TO RECEIVE CONTROL IN EITHER   *\n.*            24-BIT OR 31-BIT MODE.                                 *\n.*  RMODE={ \u00a624\u00a631\u00a6ANY}                                              *\n.*       24:  THE PROGRAM IS DESIGNED TO RESIDE BELOW THE 16-MEG     *\n.*            LINE.                                                  *\n.*       ANY: THE PROGRAM IS DESIGNED TO RESIDE IN ANY VIRTUAL       *\n.*            STORAGE LOCATION, EITHER ABOVE OR BELOW THE 16-MEG     *\n.*            LINE.                                                  *\n.*** LOC  ADDED FOR MVS/XA SUPPORT 1985.210 -DGA-                  ***\n.*                                                                   *\n.*  LOC ={BELOW \u00a6 (BELOW,ANY) \u00a6 ANY \u00a6 (ANY,ANY) \u00a6 RES \u00a6 (RES,ANY)}   *\n.*  LOCATION IN VIRTUAL AND REAL STORAGE TO ALLOCATE.                *\n.*  (SEE GC28-1154 MVS/XA SUPERVISOR SERVICES AND MACRO INSTRUCTIONS *\n.*   GETMAIN ... OPERAND LOC)\n.*            LINE.                                                  *\n.*                                                                   *\n.*** SP - Getmain sub-pool                                         ***\n.*          See SYSTEM MACROs manual for more info                   *\n.*                                                                   *\n.*** GMTYPE={R, RU, RC}                                            ***\n.*          Getmain Register Type (See SYSTEM MACROS)                *\n.*                                                                   *\n.*** CLEAR={YES \u00a6 NO}                                              ***\n.*         Clear getmained area to binary zeros.  R2,R3,R4 and R5    *\n.*         are modified.                                             *\n.*                                                                   *\n.*** RSA=                                                          ***\n.*         Use Register Save Area at the location pointed to by      *\n.*         this field.                                               *\n.*                                                                   *\n.*** DATEFMT= DA#EYEC parm                                         ***\n.*** ASMINFO= DA#EYEC parm                                         ***\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*                                                                   *\n.*  EXAMPLES:                                                        *\n.*                                                                   *\n.* TEST1 DA#ENTER BASE=8,LV=300,RENT=YES                             *\n.*     . R8 IS BASE, GETMAIN 300 BYTES, CSECT NAME IS TEST1,         *\n.*                                                                   *\n.* TEST2 DA#ENTER                                                    *\n.*     . R12 IS BASE, IN-LINE SAVEAREA, CSECT NAME IS TEST2,         *\n.*                                                                   *\n.*       DA#ENTER 'VERSION 1',BASE=(10,11),RENT=YES,LV=WORKEND-WORK  *\n.*     . R10,R11 ARE BASES, GETMAIN AL4(WORKEND-WORK) BYTES,         *\n.*     . CSECT NAME DEFAULTS TO MAIN                                 *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   07-FEB-1996 Renamed to DA#ENTER from ENTER            **\n.***                                                                ***\n.**********************************************************************\n.*\n.*  DEFINE GLOBAL AND LOCAL SET SYMBOLS\n.*\n         GBLC  &VIRT\n         GBLB  &RE,&REGS,&PROLOG,&ENTER31\n.*\n         LCLA  &B1,&BCT,&BICT\n         LCLB  &ALV,&CLV,&BT(16),&OT\n         LCLC  &BO,&LAB\n.*\n.**********************************************************************\n.***                                                                ***\n.**      \"DA#EYEC\" MACRO PROCESSING                                  **\n.***                                                                ***\n.**********************************************************************\n.*\n.*\n.** SET GLOBAL FOR LEAVE MACRO IF WE ARE FOR 31-BIT MODE\n.*\n         AIF   ('&AMODE' NE '31').NO31MDE\n&ENTER31 SETB  1                 SET GLOBAL ENTER 31-BIT FLAG\n.NO31MDE ANOP  ,\n.*\n.** GENERATE MODULE IDENTIFICATION Prologue.\n.*\n&LAB     SETC  '&SYSECT'         SET CSECT NAME\n         AIF   ((&PROLOG) OR ('&PL' EQ 'NO')).E000A SKIP PROLOGUE\n&LAB     SETC  '&LABEL'          SET CSECT TO LABEL NAME\n         AIF   ('&LABEL' NE '').E000  GEN PROLOGUE IF &LABEL EXISTS\n         MNOTE 0,'CSECT NAME OMMITED - CSECT NAME DEFAULTS TO MAIN'\n&LAB     SETC  'MAIN'            SET CSECT TO MAIN\n.E000    ANOP  ,\n         DA#EYEC &LAB,&MSG,RMODE=&RMODE,AMODE=&AMODE,                  @\n               ASMINFO=&ASMINFO,DATEFMT=&DATEFMT\n.*\n.**********************************************************************\n.***                                                                ***\n.**      EXPAND REGISTERS AND SET CONSTANTS                          **\n.***                                                                ***\n.**********************************************************************\n.*\n.*\n.** GENERATE STANDARD REGISTER EQUATES IF GLOBAL FLAG &REGS = 0\n.*\n.E000A   ANOP\n&PROLOG  SETB  0                 RESET GLOBAL PROLOGUE FLAG\n         DA#REGS GPR=&GPR,FLOAT=&FLOAT\n.*\n.*       SET CONSTANTS AND LOGICAL SWITCHES\n.*\n.E001    ANOP  ,\n&OT      SETB  ('&ORG' EQ 'L')               SET ORIGIN TYPE FLAG\n&RE      SETB  ('&RENT' EQ 'YES')            SET REENTRANT FLAG\n&BCT     SETA  N'&BASE                       SET NUMBER OF BASE REGS\n&BICT    SETA  1                             SET BASE REG COUNTER\n&ALV     SETB  (('&LV' GE '72') AND ('&LV' LE '4096')) SET LV FLAG\n&CLV     SETB  ('&LV'(1,1) LE '0')           SET LV FLAG\n.*\n.** IF BOTH RENT AND RSA ARE CHOSEN, USE ONLY RSA...\n.*\n         AIF   (NOT &RE).EIRX             .RENT SPECIFIED?\n         AIF   ('&RSA' EQ '').EIRX        .BOTH SPECIFIED?\n&RE      SETB  0                          SET REENTRANT FLAG\n.EIRX    ANOP  ,\n.*\n.*  SAVE CALLER'S REGISTERS\n.*\n         STM   R14,R12,12(R13)            SAVE CALLER'S REGISTERS\n.*\n.**********************************************************************\n.***                                                                ***\n.**      HANDLE BASE REGISTERS                                       **\n.***                                                                ***\n.**********************************************************************\n.*\n.E002    ANOP\n         AIF   ('&BASE' EQ 'NO').E003        SKIP, IF NO BASE REG\n         AIF   (&BCT NE 1).E002B             DECIDE WHICH BASE REG RTN\n.*\n.*  SINGLE BASE REGISTER SPECIFIED\n.*\n.E002A   ANOP\n&B1      SETA  &BASE\n&BO      SETC  '&B1'                    SET STRING FOR USING\n         AIF   ((&B1 GE 2) AND (&B1 LE 12)).E002A1\n         MNOTE 4,'BASE REGISTER SPECIFIED IS INVALID - USING R12'\n&B1      SETA  12\n.E002A1  ANOP\n         AIF   (&OT).E002A2\n         LR    R&B1,R15                   LOAD BASE REGISTER\n         USING &LAB,R&B1                  GET ADDRESSIBLITY\n         AGO   .E003\n.E002A2  ANOP\n         BALR  R&B1,0                     LOAD BASE REGISTER\n         USING *,R&B1                     GET ADDRESSIBLITY\n         AGO   .E003\n.*\n.*  MULTIPLE BASE REGISTERS SPECIFIED\n.*\n.E002B   ANOP\n&B1      SETA  &BASE(&BICT)\n         AIF   (NOT &BT(&B1+1)).E002C        CHECK REDUNDANCY\n         MNOTE 8,'REG &B1 REDUNDANTLY SPECIFIED - GEN SUPPRESSED'\n         MEXIT\n.E002C   ANOP\n&BT(&B1+1) SETB  1                           SET REG USE BIT\n         AIF   ((&B1 GE 2) AND (&B1 LE 12)).E002D\n         MNOTE 8,'INVALID SECONDARY BASE REGISTER - GEN SUPPRESSED'\n         MEXIT\n.E002D   ANOP\n&BICT    SETA  &BICT+1\n         AIF   (&BICT LE &BCT).E002B      .CHECK NEXT BASE REG\n&BO      SETC  '&BASE'(2,K'&BASE-2)       .DONE, SET STRING FOR USING\n&BICT    SETA  1                          .SET LOOP CONTROL\n         AIF   (&OT).E002E1\n         LR    R&BASE(1),R15              LOAD BASE REGISTER\n         USING &LAB,&BO                   GET ADDRESSIBILITY\n         AGO   .E002E\n.E002E1  ANOP\n         BALR  R&BASE(1),0                LOAD BASE REGISTER\n         USING *,&BO                      GET ADDRESSIBILITY\n.E002E   ANOP\n&BICT    SETA  &BICT+1                    .INCREMENT LOOP CONTROL\n&B1      SETA  &BASE(&BICT)\n         AIF   (NOT &BT(&B1+1)).E002E\n         LA    R&B1.,4095                 SECONDARY\n         LA    R&B1.,1(R&B1.,R&BASE(&BICT-1)) BASE REGISTER\n         AIF   (&BICT LT &BCT).E002E         SET UP NEXT BASE REG\n.*\n.**********************************************************************\n.***                                                                ***\n.**      SET UP SAVE AREA                                            **\n.***                                                                ***\n.**********************************************************************\n.*\n.E003    ANOP\n         AIF   (NOT &RE).E003B            .NOT REENTRANT?\n.*\n.*  RENT=YES:  ISSUE GETMAIN FOR REENTRANT PROG\n.*\n&VIRT    SETC  '&LV'\n         AIF   (&ALV OR &CLV).E003A\n         MNOTE 4,'LV SPECIFIED IS INVALID - USING 72 BYTES'\n&VIRT    SETC  '72'\n.E003A   ANOP\n         MNOTE  '         GETMAIN &GMTYPE,LV=&VIRT,LOC=&LOC,SP=&SP'\n         GETMAIN &GMTYPE,LV=&VIRT,LOC=&LOC,SP=&SP\n         AIF   ('&CLEAR' NE 'YES').E004\n*\n         LR    R2,R1                      ADDRESS OF GETMAINED AREA\n         LR    R3,R0                      LENGTH OF GETMAINED AREA\n         SLR   R5,R5                      SET PAD AND LENGTH\n         MVCL  R2,R4                      CLEAR GETMAINED AREA TO 0\n*\n         AGO   .E004                      SKIP RENT=NO PROCESSING\n.*\n.** RENT=NO:  ESTABLISH DS TYPE SAVE AREA IF RSA= FIELD NOT SPECIFIED\n.*\n.E003B   ANOP\n         AIF   ('&RSA' NE '').ERSA        .IS RSA SUPPLIED?\n         CNOP  0,4                        ALIGN FULL WORD\n         BAL   R1,*+76                    BRANCH AROUND PROGRAM RSA\n         DS    18F                        RSA (REGISTER SAVE AREA)\n         AGO   .E004                      .MOVE ON\n.*\n.ERSA    ANOP  ,\n         AIF   ('&RSA'(1,1) EQ '(').ERSAR .REGISTER FORM?\n         LA    R1,&RSA                    LOCATE SUPPLIED SAVE AREA\n         AGO   .E004                      .MOVE ON\n.ERSAR   ANOP  ,\n         LR    R1,&RSA(1)                 LOCATE SUPPLIED SAVE AREA\n.ERSARX  ANOP  ,\n.*\n.**********************************************************************\n.***                                                                ***\n.**    COMPLETE MACRO: SET UP FORWARD/BACKWARD CHAIN POINTERS        **\n.***                                                                ***\n.**********************************************************************\n.*\n.E004    ANOP\n         ST    R1,8(,R13)                 SET FORWARD RSA POINTER\n         ST    R13,4(,R1)                 SET BACKWARD RSA POINTER\n         LR    R13,R1                     GET PROGRAM RSA ADDRESS\n         L     R1,4(,R1)                  GET CALLER'S RSA ADDRESS\n         AIF   (NOT &RE).E004A            DON'T RECOVER R0 IF NOT REENT\n         LM    R0,R1,20(R1)               RESTORE REGISTERS 0, 1\n         MEXIT ,\n.E004A   ANOP\n         L     R1,24(,R1)                 RESTORE REGISTER 1\n.*\n         MEND\n./ ADD NAME=DA#EYEC  0100-01266-01266-1821-00270-00270-00000-DAVE\n         MACRO\n         DA#EYEC &CSECT,        CSECT name                             @\n               &MSG,            Eye catcher message                    @\n               &DATEFMT=ISO,    Date format defaults to ISO format     @\n               &TIMEFMT=STD,    Time format defaults to standard       @\n               &ASMINFO=YES,    Insert Assembly date and time?         @\n               &USING=15,       Register used during eyecatcher branch @\n               &AMODE=24,       Addressing mode                        @\n               &RMODE=24        Residency mode\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*  MACNAME:  PROLOGUE                                               *\n.*  MACAUTH:  Skip Abadie                                            *\n.*  MACDATE:  4/2/81                                                 *\n.*  MACUPTE:  David Alcock                                           *\n.*                                                                   *\n.*  May be used to generate CSECT Cards and standard format module   *\n.*  eye-catchers.  Both the CSECT and module eye-catchers are        *\n.*  optional.  See operand descriptions and examples below.          *\n.*                                                                   *\n.*  This macro is conditionally invoked by macro DA#ENTER. If flag   *\n.*  &PROLOG is not set to one, DA#ENTER invokes DA#EYEC. Note that   *\n.*  the DA#ENTER macro always sets the global flag &PROLOG to zero so*\n.*  that subsequent DA#EYEC or DA#ENTER macros will expand properly. *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*                                                                   *\n.*  CSECT                                                            *\n.*       IF SPECIFIED, THIS POSITIONAL PARAMETER WILL GENERATE A     *\n.*       CSECT CARD USING THE SPECIFIED NAME.  IF IT IS OMITTED BY   *\n.*       CODING A COMMA, THEN NO CSECT CARD IS GENERATED.  IN EITHER *\n.*       CASE, THE FOLLOWING CARDS WILL BE GENERATED:                *\n.*                USING *,15                                         *\n.*                CNOP  0,4                                          *\n.*                B     Past-Eyecatcher                              *\n.*                DC    AL1(Length-of-EyeCatcher)                    *\n.*                                                                   *\n.*  ASMINFO=YES|NO                                                   *\n.*       Generate the eyecatcher with the date and time of the       *\n.*       assembly?                                                   *\n.*                                                                   *\n.*  TIMEFMT=STD | CON                                                *\n.*                                                                   *\n.*       - STD: hh:mm                                                *\n.*       - CON: \"hh:mm AM\" or \"hh:mm PM\"                             *\n.*                                                                   *\n.*  DATEFMT=ISO | EUR | OLD                                          *\n.*                                                                   *\n.*       - ISO: ccyy-mm-dd                                           *\n.*       - EUR: dd-mon-ccyy                                          *\n.*       - OLD: mm/dd/yy      (Required if not HLASM)                *\n.*                                                                   *\n.*  MSG                                                              *\n.*       Text to be added to the standard MVS module eyecatcher      *\n.*       which will consist of:                                      *\n.*       - CSECT name                                                *\n.*       - Date of assembly - Converted to Day-Month-Year            *\n.*       - Time of assembly - Converted to standard time             *\n.*       - The &MSG parameter (if any)                               *\n.*                                                                   *\n.*  AMODE                                                            *\n.*       IF SPECIFIED, THIS  PARAMETER WILL GENERATE THE AMODE       *\n.*       CARD FOR THE ASSEMBLER H.  AMODE IS A PROGRAM ATTRIBUTE     *\n.*       WHICH CAN BE SET TO GIVE ADDRESSING MODE.\n.*                                                                   *\n.*  RMODE                                                            *\n.*       IF SPECIFIED, THIS PARAMETER WILL GENERATE THE RMODE        *\n.*       CARD FOR THE ASSEMBLER H.  RMODE IS A PROGRAM ATTRIBUTE     *\n.*       WHICH CAN BE SET TO GIVE RESIDENCY MODE.                    *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.**********************************************************************\n.***\n.**           M o d i f i c a t i o n   H i s t o r y\n.**\n.** Person     Date        Description\n.** ---------- ----------- --------------------------------------------\n.** DGAlcock   2000-09-09  Change time to be standard;\n.** DGAlcock   2000-03-02  Fix hardcoded century;\n.** DGAlcock   07-FEB-1996 Renamed to DA#EYEC from PROLOGUE\n.** DGAlcock   15-SEP-1994 Added ASMINFO= operand and changed to get\n.** DGAlcock   20-FEB-1991 Added fancy date and time;\n.** DGAlcock   ??-???-198? Added AMODE and RMODE operands;\n.***\n.**********************************************************************\n.*\n.**  DEFINE GLOBAL AND LOCAL SET SYMBOLS\n.*\n         GBLB  &PROLOG\n         LCLC  &CS,&ECDATE,&ECTIME,&YEAR\n         LCLA  &L1,&L2,&L3\n&PROLOG  SETB  1\n.*\n         AIF   (T'&CSECT NE 'O').P001\n&CS      SETC  '&SYSECT'\n         AGO   .P002\n.*\n.** GENERATE CSECT, AMODE, AND RMODE CARDS\n.*\n.P001    ANOP\n&CS      SETC  '&CSECT'\n&CS      CSECT ,\n.P002    ANOP  ,\n.*-> MNOTE ' *** CSECT=&CSECT CS=&CS PROLOG=&PROLOG'\n.*\n.** AMODE and RMODE\n.*\n         AIF   ('&AMODE' EQ '').AMODEX\n&CS      AMODE &AMODE\n.AMODEX  AIF   ('&RMODE' EQ '').RMODEX\n&CS      RMODE &RMODE\n.RMODEX  ANOP  ,\n AIF  ('&ASMINFO' NE 'YES').TIMEX           .Want date and time info?\n.*\n.** Get Date\n.*\n AIF  ('&DATEFMT' EQ 'ISO').DATEISO         Want \"ccyy-mm-dd\"?\n AIF  ('&DATEFMT' EQ 'OLD').DATEOLD         Want \"mm/dd/yy\"?\n&ECDATE SETC '&SYSDATE'(4,2)'-'             .Get Day of month\n.*\n&YEAR  SETC '&SYSDATC'(1,4)                   .Grab century from HLASM\n.*\n AIF  ('&SYSDATE'(1,2) EQ '01').DATEM01\n AIF  ('&SYSDATE'(1,2) EQ '02').DATEM02\n AIF  ('&SYSDATE'(1,2) EQ '03').DATEM03\n AIF  ('&SYSDATE'(1,2) EQ '04').DATEM04\n AIF  ('&SYSDATE'(1,2) EQ '05').DATEM05\n AIF  ('&SYSDATE'(1,2) EQ '06').DATEM06\n AIF  ('&SYSDATE'(1,2) EQ '07').DATEM07\n AIF  ('&SYSDATE'(1,2) EQ '08').DATEM08\n AIF  ('&SYSDATE'(1,2) EQ '09').DATEM09\n AIF  ('&SYSDATE'(1,2) EQ '10').DATEM10\n AIF  ('&SYSDATE'(1,2) EQ '11').DATEM11\n AIF  ('&SYSDATE'(1,2) EQ '12').DATEM12\n MNOTE 'DA#EYEC-01E Invalid month'\n AGO  .DATEMX\n.*\n.DATEM01 ANOP ,\n&ECDATE SETC '&ECDATE'.'JAN-&YEAR'\n AGO  .DATEMX\n.DATEM02 ANOP ,\n&ECDATE SETC '&ECDATE'.'FEB-&YEAR'\n AGO  .DATEMX\n.DATEM03 ANOP ,\n&ECDATE SETC '&ECDATE'.'MAR-&YEAR'\n AGO  .DATEMX\n.DATEM04 ANOP ,\n&ECDATE SETC '&ECDATE'.'APR-&YEAR'\n AGO  .DATEMX\n.DATEM05 ANOP ,\n&ECDATE SETC '&ECDATE'.'MAY-&YEAR'\n AGO  .DATEMX\n.DATEM06 ANOP ,\n&ECDATE SETC '&ECDATE'.'JUN-&YEAR'\n AGO  .DATEMX\n.DATEM07 ANOP ,\n&ECDATE SETC '&ECDATE'.'JUL-&YEAR'\n AGO  .DATEMX\n.DATEM08 ANOP ,\n&ECDATE SETC '&ECDATE'.'AUG-&YEAR'\n AGO  .DATEMX\n.DATEM09 ANOP ,\n&ECDATE SETC '&ECDATE'.'SEP-&YEAR'\n AGO  .DATEMX\n.DATEM10 ANOP ,\n&ECDATE SETC '&ECDATE'.'OCT-&YEAR'\n AGO  .DATEMX\n.*\n.DATEM11 ANOP ,\n&ECDATE SETC '&ECDATE'.'NOV-&YEAR'\n AGO  .DATEMX\n.*\n.DATEM12 ANOP ,\n&ECDATE SETC '&ECDATE'.'DEC-&YEAR'\n.*AGO .DATEMX\n.DATEMX  ANOP ,\n AGO .DATEX\n.*\n.DATEOLD ANOP  ,               If not HLASM or higher\n&ECDATE  SETC  '&SYSDATE'\n AGO .DATEX\n.*\n.DATEISO ANOP  ,\n&ECDATE  SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n.DATEX ANOP\n.*\n.** Time\n.*\n AIF  ('&TIMEFMT' EQ 'STD').TIMESTD         Want \"hh:mm\"\n AIF  ('&SYSTIME'(1,2) LT '12').TIMEN\n AIF  ('&SYSTIME'(1,2) EQ '12').TIMEH12\n AIF  ('&SYSTIME'(1,2) EQ '13').TIMEH13\n AIF  ('&SYSTIME'(1,2) EQ '14').TIMEH14\n AIF  ('&SYSTIME'(1,2) EQ '15').TIMEH15\n AIF  ('&SYSTIME'(1,2) EQ '16').TIMEH16\n AIF  ('&SYSTIME'(1,2) EQ '17').TIMEH17\n AIF  ('&SYSTIME'(1,2) EQ '18').TIMEH18\n AIF  ('&SYSTIME'(1,2) EQ '19').TIMEH19\n AIF  ('&SYSTIME'(1,2) EQ '20').TIMEH20\n AIF  ('&SYSTIME'(1,2) EQ '21').TIMEH21\n AIF  ('&SYSTIME'(1,2) EQ '22').TIMEH22\n AIF  ('&SYSTIME'(1,2) EQ '23').TIMEH23\n AIF  ('&SYSTIME'(1,2) EQ '24').TIMEH24\n AGO  .TIMEX\n.TIMEH12 ANOP ,\n&ECTIME SETC '12.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH13 ANOP ,\n&ECTIME SETC '01.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH14 ANOP ,\n&ECTIME SETC '02.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH15 ANOP ,\n&ECTIME SETC '03.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH16 ANOP ,\n&ECTIME SETC '04.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH17 ANOP ,\n&ECTIME SETC '05.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH18 ANOP ,\n&ECTIME SETC '06.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH19 ANOP ,\n&ECTIME SETC '07.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH20 ANOP ,\n&ECTIME SETC '08.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH21 ANOP ,\n&ECTIME SETC '09.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH22 ANOP ,\n&ECTIME SETC '10.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH23 ANOP ,\n&ECTIME SETC '11.'.'&SYSTIME'(4,2)' PM'\n AGO  .TIMEX\n.TIMEH24 ANOP ,\n&ECTIME SETC '12.'.'&SYSTIME'(4,2)' AM'\n AGO  .TIMEX\n.TIMEN  ANOP ,\n&ECTIME SETC '&SYSTIME'(1,5)' AM'         .Get Day of month\n AGO .TIMEX\n.TIMESTD ANOP ,\n&ECTIME SETC '&SYSTIME'                   .Standard time from ASMblr\n.TIMEX ANOP\n.*\n.** Generate Eye Catcher\n.*\n                USING *,&USING            Get addressibility\n                CNOP  0,4                 Full word alignment\n                B     &CS._ECX            Branch around Eyecatcher\n&CS._ECLEN      DC    AL1(&CS._ECL-1)\n&CS._ECNAME     DC    CL8'&CS'\n                DC    C' '\n AIF ('&ASMINFO' NE 'YES').ECDTX          .Want date and time info?\n&CS._ECDATE     DC    C'&ECDATE'\n                DC    C' '\n&CS._ECTIME     DC    C'&ECTIME'\n                DC    C' '\n.ECDTX          ANOP  ,\n AIF ('&MSG' EQ '').ECMSGX\n&CS._ECMSG      DC    C&MSG\n.ECMSGX         ANOP  ,\n&CS._ECL        EQU   *-&CS._ECLEN\n&CS._ECX        DS    0H\n                DROP  &USING\n MEND  ,\n./ ADD NAME=DA#LEAVE 0100-01266-01266-1821-00236-00236-00000-DAVE\n         MACRO ,\n&LABEL   DA#LEAVE &RC=0,                  Return code                  @\n               &LV=,                      Level to freemain            @\n               &RR=,                      Return registers             @\n               &FMTYPE=R,                 FREEMAIN type                @\n               &RENT=NO,                  Re-entrant?                  @\n               &GPR=YES,                  General Purpose registers?   @\n               &SP=0                      Sub-pool to freemain\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*  MACNAME:  LEAVE                                                  *\n.*  MACAUTH:  Skip Abadie                                            *\n.*  MACDATE:  12/01/80                                               *\n.*  MACUPTE:  David Alcock                                           *\n.*                                                                   *\n.*  May be used in conjuntion with DA#ENTER macro.                   *\n.*                                                                   *\n.*  DA#ENTER and DA#LEAVE macros may be nested in an assembly,       *\n.*  however, the LV and RENT parms must be explicitly given          *\n.*  in this case.                                                    *\n.*                                                                   *\n.*  This macro automatically invokes the REQUATE (register equate)   *\n.*  macro unless global flag &REGS is set to one.                    *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*                                                                   *\n.*  RC={LITERAL\u00a6(REG)}                                               *\n.*       RETURN CODE:  SPECIFY LITERAL 0 - 4095 OR SINGLE REGISTER   *\n.*       (2) - (12) OR (15), TO BE RETURNED TO CALLER IN R15.        *\n.*       DEFAULT RETURN CODE IS ZERO.                                *\n.*                                                                   *\n.*  RR={(REG,...,REGN)}                                              *\n.*       RETURN REGISTER:  CONTENTS OF REGISTERS IN LIST WILL BE     *\n.*       RETURNED TO CALLER (I.E.,  CALLERS REGISTERS CORRESPONDING  *\n.*       TO REGISTERS SPECIFIED IN LIST WILL NOT BE RESTORED).       *\n.*       SPECIFY REGISTERS 2 - 12 OR 0.  CAPABILITY TO RETURN R0 IS  *\n.*       PROVIDED FOR FORTRAN FUNCTION COMPATIBILITY.  IT SHOULD BE  *\n.*       NOTED THAT IF RR=(0) AND RENT=YES ARE BOTH SELECTED, THEN   *\n.*       THE CONTENTS OF R0 MUST BE STORED IN, AND SUBSEQUENTLY      *\n.*       RESTORED FROM, THE CALLERS SAVE AREA, SINCE THE FREEMAIN    *\n.*       SVC ALTERS THE CONTENTS OF R0.                              *\n.*                                                                   *\n.*  LV={LITERAL}                                                     *\n.*       LITERAL VALUE:  IF RENT=YES IS CODED, THE LITERAL VALUE IS  *\n.*       THE SIZE OF THE AREA TO BE FREED BY THE FREEMAIN SVC.       *\n.*       PARAMETER LV IS NOT REQUIRED IF DA#ENTER MACRO HAS          *\n.*       PREVIOUSLY BEEN USED.  IT IS OBTAINED THROUGH GLOBAL        *\n.*       VARIABLE &VIRT.  IF RENT=NO IS CODED OR ALLOWED TO DEFAULT, *\n.*       THE LV PARAMETER IS IGNORED.                                *\n.*                                                                   *\n.*  RENT={YES\u00a6NO}                                                    *\n.*       YES:  GENERATE FREEMAIN TO FREE STORAGE ACQUIRED BY DA#ENTER*\n.*       MACRO.  IF THE LEAVE MACRO IS BEING USED TO FREE AN AREA    *\n.*       THAT WAS NOT ACQUIRED BY THE DA#ENTER MACRO, THEN THE LV    *\n.*       PARAMETER MUST ALSO BE SPECIFIED.                           *\n.*       NO:   NO FREEMAIN SVC REQUIRED.                             *\n.*                                                                   *\n.*  GPR={YES\u00a6NO}                                                     *\n.*       YES:  INVOKE REQUATE TO EQUATE REGISTERS                    *\n.*       NO:   DON'T INVOKE REQUATE TO EQUATE REGISTERS              *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*  ADDED MVS/XA (31-BIT RETURN) SUPPORT -DGA-85.224                 *\n.*  ADDED GPR OPERAND -DGA-@04/19/86                                 *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*                                                                   *\n.*  EXAMPLES:                                                        *\n.*       DA#LEAVE RC=32,RR=(9,4),LV=300,RENT=YES                     *\n.*       DA#LEAVE RR=(0),RENT=YES                                    *\n.*       DA#LEAVE RC=(5),RR=(6)                                      *\n.*       DA#LEAVE                                                    *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   07-FEB-1996 Renamed to DA#LEAVE from LEAVE            **\n.***                                                                ***\n.**********************************************************************\n.*\n.*  DEFINE GLOBAL AND LOCAL SET SYMBOLS\n.*\n         GBLC  &VIRT\n         GBLB  &RE,&REGS,&ENTER31\n.*\n         LCLA  &R1,&R2,&RRT,&RICT\n         LCLB  &ALV,&CLV,&RT(16),&RCR,&CC15\n         LCLC  &DISP,&CC,&CCT,&NDX,&LAB\n.*\n.** REGISTER EQUATES\n.*\n         AIF   ('&GPR' EQ 'NO').L000\n         AIF   ('&GPR' EQ 'YES').REQ00\n         MNOTE ,'GPR=&GPR. IS INVALID, YES ASSUMED'\n.REQ00   ANOP  ,\n         AIF   (&REGS).L000\n         DA#REGS ,                        EQUATE GENERAL PURPOSE REG\n.L000    ANOP\n.*\n.*  SET CONSTANTS AND LOGICAL SWITCHES\n.*\n&RCR     SETB  ('&RC'(1,1) EQ '(')           SET RETURN CODE TYPE FLAG\n&RRT     SETA  N'&RR                         SET NUMBER OF RETRN REGS\n&RICT    SETA  1                             SET RETURN REG COUNTER\n&ALV     SETB  (('&LV' GE '72') AND ('&LV' LE '4096'))   SET LV FLAG\n&CLV     SETB  ('&LV' LE '0')                SET LV FLAG\n&DISP    SETC  '20242832364044485256606468081216' STANDARD S.A. DISPLS\n.*\n.*  SET RT FLAGS FOR REGISTERS INCLUDED IN RR PARAMETER\n.*\n         AIF   (&RRT EQ 0).L002\n.L001    ANOP\n&R1      SETA  &RR(&RICT)\n         AIF   (NOT &RT(&R1+1)).L001A        CHECK REDUNDANCY\n         MNOTE 8,'REG &R1 REDUNDANTLY SPECIFIED - GEN SUPPRESSED'\n         MEXIT\n.L001A   ANOP\n&RT(&R1+1) SETB  1                           SET REG USE BIT\n         AIF   (((&R1 GE 2) AND (&R1 LE 12)) OR (&R1 EQ 0)).L001B\n         MNOTE 8,'RETURN REG &R1 NOT PERMITTED - GEN SUPPRESSED'\n         MEXIT\n.L001B   ANOP\n&RICT    SETA  &RICT+1\n         AIF   (&RICT LE &RRT).L001\n.*\n.*  CHAIN BACK TO CALLERS SAVE AREA\n.*\n.L002    ANOP\n&LAB     SETC  '&LABEL'\n         AIF   ((NOT &RE) AND ('&RENT' EQ 'NO')).L002C\n&LAB     LR    R1,R13                   OUR RSA ADDR\n&LAB     SETC  ''\n.L002C   ANOP\n&LAB     L     R13,4(,R13)                Caller's RSA address\n.*\n.*  INITIALIZE RETURN CODE REGISTER (R15)\n.*\n         AIF   (&RCR).L002B\n&CCT     SETC  'A'                         SET RETURN CODE TYPE\n         AIF   ((&RC GE 0) AND (&RC LE 4095)).L002A\n         MNOTE 4,'INVALID RETURN CODE - USING 4095'\n&CC      SETC  '4095'                      SET RETURN CODE LITERAL\n         AGO   .L003\n.L002A   ANOP\n&CC      SETC  '&RC'                       SET RETURN CODE LITERAL\n         AGO   .L003\n.L002B   ANOP\n&CCT     SETC  'R'                         SET RETURN CODE TYPE\n&CC      SETC  'R'.'&RC'(2,K'&RC-2)        SET RETURN CODE REGISTER\n&CC15    SETB  ('&CC' EQ 'R15')            SET CC15 FLAG\n         AIF   ((('&CC' GE 'R2') AND ('&CC' LE 'R12')) OR (&CC15)).L003\n         MNOTE 4,'INVALID RETURN CODE REGISTER - USING LITERAL 4095'\n&CCT     SETC  'A'                         SET RETURN CODE TYPE\n&CC      SETC  '4095'                      SET RETURN CODE LITERAL\n.*\n.*  ISSUE FREEMAIN TO FREE OWN SAVE AREA (IF RENT=YES OR &RE ON)\n.*\n.L003    ANOP\n         AIF   ((NOT &RE) AND ('&RENT' EQ 'NO')).L004\n         AIF   (NOT &RT(1)).L003A          IF R0 NOT AN RR PARM, CONT.\n*    ** WARNING **\n*    RR=(0) WITH RENT=YES NECESSITATES MODIFYING THE CALLERS SAVE\n*    AREA (R0 SLOT) BECAUSE THE FREEMAIN SVC ALTERS R0.\n         ST    R0,20(,R13)        ** SAVE R0 IN CALLER'S RSA **\n.L003A   ANOP\n         AIF   (NOT &CC15).L003A1           IF NOT RC=(15), CONTINUE\n*    ** WARNING **\n*    RC=(15) WITH RENT=YES NECESSITATES MODIFYING THE CALLERS SAVE\n*    AREA (R15 SLOT) BECAUSE THE FREEMAIN SVC ALTERS R15.\n         ST    R15,16(,R13)       ** SAVE R15 IN CALLER'S RSA **\n&CCT     SETC  ''                    * SET UP\n&CC      SETC  '16(,R13)'            *   TO FORCE\n&CC15    SETB  0                     *      LOAD ON R15\n.L003A1  ANOP\n         AIF   ('&VIRT' NE '0').L003C      USE VIRT IF NOT ZERO\n         AIF   (&ALV OR &CLV).L003B        ELSE USE LV IF VALID\n         MNOTE 8,'LV SPECIFIED IS INVALID - GEN SUPPRESSED'\n         MEXIT\n.L003B   ANOP\n&VIRT    SETC  '&LV'\n.L003C   ANOP\n         MNOTE '         FREEMAIN &FMTYPE,LV=&VIRT,A=(1),SP=&SP'\n         FREEMAIN &FMTYPE,LV=&VIRT,A=(1),SP=&SP\n         AIF   (NOT &RT(1)).L004        IF R0 NOT AN RR PARM, CONT.\n&RT(1)   SETB  0                        TURN OFF RETURN REG FLAG FOR R0\n.*\n.*  RESTORE 14, LOAD 15\n.*\n.L004    ANOP\n         AIF   (&CC15).L004A            NO NEED TO LOAD R15 IF CC15 SET\n         L&CCT R15,&CC                    Return code\n.L004A   ANOP\n         L     R14,12(,R13)               Return address\n         AIF   (&RRT GT 0).L005\n         LM    R0,R12,20(R13)             Restore caller's registers\n         AGO   .L006\n.*\n.*  RESTORE REGS NOT INCLUDED IN RR PARAMETER\n.*\n.L005    ANOP\n&RICT    SETA  0                        SET LOOP CONTROL\n.L005A   ANOP\n&R1      SETA  &RICT\n&RICT    SETA  &RICT+1                  INCREMENT LOOP CONTROL\n         AIF   ((&RT(&R1+1)) AND (&R1 LE 12)).L005A\n         AIF   ((NOT &RT(&R1+2)) AND (&R1 LE 12)).L005B\n         AIF   (NOT (&R1 LE 12)).L006\n&CC      SETC  '&DISP'((&R1*2+1),2)\n         L     R&R1.,&CC.(,R13)\n         AGO   .L005A\n.L005B   ANOP\n&R2      SETA  &RICT\n&RICT    SETA  &RICT+1                  INCREMENT LOOP CONTROL\n         AIF   ((NOT &RT(&R2+1)) AND (&R2 LE 12)).L005B\n&R2      SETA  &R2-1\n&CC      SETC  '&DISP'((&R1*2+1),2)\n         AIF   (&R1 EQ &R2).L005C\n         LM    R&R1.,R&R2.,&CC.(R13)    RESTORE REGS\n         AGO   .L005D\n.L005C   ANOP\n         L     R&R1.,&CC.(,R13)\n.L005D   ANOP\n         AIF   (&RICT LE 12).L005A\n.*\n.*  COMMON END FOR DA#LEAVE MACRO - GENERATE RETURN INSTRUCTION\n.*\n.L006    ANOP\n         AIF   (&ENTER31).L007\n.*       BR    R14\n         BSM   0,R14                      Return to caller\n         MEXIT ,\n.L007    ANOP  ,\n         BSM   0,R14                      Return to caller\n         MEND\n./ ADD NAME=DA#MXD   0100-01266-01266-1821-00040-00040-00000-DAVE\n MACRO\n DA#MXD &ITYPE\n AIF ('&ITYPE' EQ 'CSECT').CSECT\n AIF ('&ITYPE' EQ 'DSECT').DSECT\n AIF ('&ITYPE' EQ '').DSECT\n MNOTE 'DA#MXD - Invalid ITYPE: &ITYPE'\n MEXIT ,\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*                                                                   *\n.* Name: DA#MXD                                                      *\n.*                                                                   *\n.* Purpose: Produce DSECTs and Equates for the DA#MXD,               *\n.*          Mini-Hex Dump, program                                   *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*\n** Input to DA#MXD external subroutine\n*\n.CSECT        ANOP  ,\nCMXD          DS    0F\n AGO          .DSECTX\n.DSECT        ANOP  ,\nCMXD          DSECT ,\n.DSECTX       ANOP  ,\nCMXD_RSA      DS    18F                   Register Save Area\nCMXD_LIT      DS    C'CMXD'               Literal for dumps\nCMXD_ADDRESS  DS    F                     -> Address\nCMXD_LENGTH   DS    F                     Length\nCMXD_OUTPUT   DS    F                     -> Output\nCMXD_OUTPUTL  DS    H                     Output length (Default=80)\nCMXD_OFFSET   DS    F                     Current Offset\nCMXD_TRTAB    DS    F                     -> User Trans table or Zero\nCMXD_FLAG1    DS    B'00000000'           Flag\n$CMXD_F1ADDR  EQU   B'10000000'           ..Insert Address?\n$CMXD_F1CAPS  EQU   B'01000000'           ..No lower case in char dump?\n$CMXD_F1MOFF  EQU   B'00100000'           ..Max offset to full 8 bytes?\nCMXD_VAR      DS    XL(CMXD_VARL)         Internal usage by DA#MXD\nCMXD_VARL     EQU   CMXDL-(CMXD_VAR-CMXD) Length of internal area\nCMXDL         EQU   256                   Total length of area\n              MEND  ,\n./ ADD NAME=DA#REGS  0100-01266-01266-1821-00067-00067-00000-DAVE\n         MACRO\n         DA#REGS &GPR=YES,      Equate General Purpose Registers?      @\n               &FLOAT=NO        Equate Floating Point Registers?\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*  MACNAME:  REQUATE                                                *\n.*  MACAUTH:  Skip Abadie                                            *\n.*  MACDATE:  12/01/80                                               *\n.*  MACUPTE:  David Alcock                                           *\n.*                                                                   *\n.*  MACRO DA#REGS MAY BE USED TO EQUATE SYMBOLIC NAMES TO THE        *\n.*  GENERAL PURPOSE REGISTERS.                                       *\n.*                                                                   *\n.*  THIS MACRO IS AUTOMATICALLY INVOKED BY MACROS ENTER AND LEAVE.   *\n.*  WHEN INVOKED FOR THE FIRST TIME, DA#REGS SETS THE GLOBAL FLAG    *\n.*  &REGS TO ONE.  IF THIS FLAG IS SET, DA#REGS WILL EXIT WITHOUT    *\n.*  ANY EXPANSION.                                                   *\n.*                                                                   *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*  CHANGED DA#REGS TO USE STATIC NUMBER OF REGISTERS AND ADDED      *\n.*  FLOATING POINT REGISTERS ... DAVID ALCOCK @85.171                *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   07-FEB-1996 Renamed to DA#REGS from REQUATE           **\n.***                                                                ***\n.**********************************************************************\n         GBLB  &REGS,&FPREGS\n.*\n         AIF   ('&GPR' EQ 'NO').CHKFLT    SEE IF WE WANT GPR(S)\n         AIF   (&REGS).CHKFLT             HAVE WE BEEN HERE BEFORE?\n&REGS    SETB  1                          SET REQUATE GLOBAL FLAG\n         SPACE 1\nR0       EQU   0                               *\nR1       EQU   1                              ***\nR2       EQU   2                             *****\nR3       EQU   3                            **   **\nR4       EQU   4                           **     **\nR5       EQU   5                          **       **\nR6       EQU   6                         ** General **\nR7       EQU   7                        *** Purpose ***\nR8       EQU   8                         **  Regs   **\nR9       EQU   9                          **       **\nR10      EQU   10                          **     **\nR11      EQU   11                           **   **\nR12      EQU   12                            *****\nR13      EQU   13                             ***\nR14      EQU   14                              *\nR15      EQU   15\n         SPACE 1\n.*\n.CHKFLT  ANOP  ,\n         AIF   ('&FLOAT' EQ 'NO').MACEND  SEE IF WE WANT FLOATING PT\n         AIF   (&FPREGS).MACEND         HAVE WE BEEN HERE BEFORE?\n         AIF   (&REGS).NOSPC            DID WE SPACED AFTER GPR?\n         SPACE 1\n.NOSPC   ANOP  ,\n&FPREGS  SETB  1                        SET GLOBAL FLAG\nFPR0     EQU   0                        FLOATING\nFPR2     EQU   2                        ..POINT\nFPR4     EQU   4                        ....REGISTER\nFPR6     EQU   6                        ......EQUATES\n         SPACE 1\n.MACEND  MEND\n./ ADD NAME=DA#SMODE 0100-01266-01266-1821-00035-00035-00000-DAVE\n         MACRO ,\n&LABEL   DA#SMODE &MODE,              24 \u00a6 31                          @\n               &WREG=1                WORK REGISTER\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.*  MACNAME:  DA#SMODE                                               *\n.*  MACAUTH:  DAVID ALCOCK --- (I REALLY \"LIBERATED\" IT FROM SDSF)   *\n.*  MACDATE:  6/27/85                                                *\n.*                                                                   *\n.*  MACRO DA#SMODE MAY BE USED TO CHANGE THE ADDRESSING MODE, BY     *\n.*  CHANGING THE PSW A-MODE BIT.  SEE PAGE 25 OF GC28-1158           *\n.*  MVS/XA SPL: 31-BIT ADDRESSING                                    *\n.*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   07-FEB-1996 Renamed to DA#SMODE from SETMODE          **\n.***                                                                ***\n.**********************************************************************\n         AIF   ('&MODE' EQ '24').XAOFF\n         AIF   ('&MODE' EQ '31').XAON\n         MNOTE 8,'INVALID ADDRESSING MODE SPECIFIED - &MODE'\n         MEXIT ,\n.XAON    ANOP ,                    GO TO 31 BIT MODE\n         CNOP  2,4                 FORCE FULL WORD ALIGNMENT\n         LA    &WREG,*+14          POINT TO AMODE = 31 CODE\n         O     &WREG,*+6           TURN ON AMODE = 31 BIT\n         BSM   0,&WREG             BRANCH TO AMODE = 31 CODE\n         DC    X'80000000'         AMODE = 31 BIT\n         MEXIT ,\n.XAOFF   LA    &WREG,*+6           POINT TO AMODE = 24 CODE\n         BSM   0,&WREG             BRANCH TO AMODE = 24 CODE\n         MEND\n./ ADD NAME=DA#STR   0100-01266-01266-1821-00023-00023-00000-DAVE\n MACRO\n DA#STR &VALUE,&L=MINUS1\n.*\n.** Figure out the label problem\n.*\n LCLC &OLAB\n&OLAB SETC '&SYSLIST(0)'\n AIF ('&OLAB' NE '').OLABX\n&OLAB SETC 'LZ&SYSNDX'\n.OLABX ANOP ,\n.*\n.** Create a character string: Length, character value\n.*\n AIF ('&L' EQ 'TOTAL').TOTAL\n&OLAB DC AL1(&OLAB.L-2)\n AGO .TOTALX\n.TOTAL ANOP ,\n&OLAB DC AL1(&OLAB.L-1)\n.TOTALX ANOP ,\n.*\n DC C&VALUE\n&OLAB.L EQU *-&OLAB\n MEND\n./ ADD NAME=DA#TSOS  0100-01266-01266-1821-00951-00951-00000-DAVE\n         MACRO ,\n      DA#TSOS &ITYPE,                     Type of invocation           @\n               &WA,                       Field to initialize          @\n               &CPPL=,                    Address of the CPPL          @\n               &STAX=,                    Address of the STAX Attn X   @\n               &WRKREG=R1,                Work Register for GET funct. @\n               &PCPPL=YES,                Process the CPPL? (Test it)  @\n               &PCL=,                     Parameter Control List addr  @\n               &PNAME=,                   Program name address         @\n               &PNAMEL=7,                 Program name length          @\n               &EPUTL=,                   ERROR routine for PUTLINE    @\n               &EITERM=,                  ERROR: Invalid Terminal      @\n               &ENTERM=,                  ERROR: Not Terminal          @\n               &CSOREG=,                  CALCSBA: Output Register     @\n               &CSCREG=,                  CALCSBA: Column Register     @\n               &CSRREG=,                  CALCSBA: Row Register        @\n               &OFFSET=,                  Message offset               @\n               &OUTPUT=,                  Output location              @\n               &NAME=,                    IKJPARMD field name          @\n               &TYPE=,                    Type: CHAR etc               @\n               &RJUST=,                   Right Justify                @\n               &ERRET=,                   Error routine                @\n               &RET=,                     Return address               @\n               &MSG=,                     Messages for inserts         @\n               &MF=E                      Macro Form\n.**********************************************************************\n.***                                                                ***\n.**   Name: DA#TSOS                                                  **\n.**                                                                  **\n.**   Author: David G. Alcock                                        **\n.**                                                                  **\n.**   Purpose: TSO specific code generation                          **\n.**            - Verify the CPPL                                     **\n.**            - Initialize for PUTLINE                              **\n.**            - Process TSO Parse                                   **\n.**            - Full Screen (3270) processing                       **\n.**            - Process parse and PUTLINE message inserts           **\n.***                                                                ***\n.**********************************************************************\n.*\n.** Decision table\n.*\n         AIF   ('&ITYPE' EQ '').DSECT\n         AIF   ('&ITYPE' EQ 'DSECT').DSECT\n         AIF   ('&ITYPE' EQ 'EQU').EQU\n.*\n         AIF   ('&ITYPE' EQ 'IOTABLE').IOTABLE I/O table wanted?\n         AIF   ('&ITYPE' EQ 'AIDTAB').AIDTAB   Aid table + Description\n         AIF   ('&ITYPE' EQ 'EQUATES').EQU     3270 equates?\n         AIF   ('&ITYPE' EQ 'AID').AID         Just PFKs\n.*\n         AIF   ('&ITYPE' EQ 'EDITR1').EDITR1\n         AIF   ('&ITYPE' EQ 'DPE2INS').DPE2INS\n         AIF   ('&ITYPE' EQ 'TRIM').TRIM\n.*\n         AIF   ('&WA' EQ '').EWA\n         AIF   ('&ITYPE' EQ 'INIT').INIT\n         AIF   ('&ITYPE' EQ 'FSINIT').FSINIT\n.*\n         AIF   ('&ITYPE' EQ 'PDE2STR').PDE2STR\n         AIF   ('&ITYPE' EQ 'PDE2NUM').PDE2NUM\n.*\n         AIF   ('&ITYPE' EQ 'INITMSG').INITMSG\n         AIF   ('&ITYPE' EQ 'PRTMSG').PRTMSG\n.*\n         AIF   ('&ITYPE' EQ 'CALCSBA').CALCSBA\n.*\n         AIF   ('&ITYPE' EQ 'GETROW').GROW\n         AIF   ('&ITYPE' EQ 'GETCOL').GCOL\n         AIF   ('&ITYPE' EQ 'GETCPPL').GCPPL\n         AIF   ('&ITYPE' EQ 'GETSCRA').GSCRA\n         AIF   ('&ITYPE' EQ 'GETSCRL').GSCRL\n         AIF   ('&ITYPE' EQ 'GETANS').GANS\n         AIF   ('&ITYPE' EQ 'TSTQRY').TSTQRY\n.*\n         AIF   ('&ITYPE' EQ 'TERM').TERM\n.*\n.** Error routines\n.*\n MNOTE 8,'RTSO-01E &ITYPE is invalid, macro can not be expanded'\n MEXIT ,\n.EWA     ANOP  ,\n MNOTE 8,'RTSO-02E Work area not given'\n MEXIT ,\n.EPNAME  ANOP  ,\n MNOTE 8,'RTSO-03E PNAME= not given'\n MEXIT ,\n.EPNAMEL ANOP  ,\n MNOTE 8,'RTSO-04E PNAMEL= not given'\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**            Convert PDE to Binary output                          **\n.***                                                                ***\n.**********************************************************************\n.PDE2NUM ANOP ,\n DA#Z01 &SYSLIST(0)                       Generate Label (if any)\n L     R15,&WA+DA#TSOSD_ANS-DA#TSOSD      -> Answer Area\n ICM   R1,B'1111',&NAME.-IKJPARMD(R15)    Locate PDE\n BZ    P$&SYSNDX.O                        IF zero then set output to 0\n.*\n.** The Number in the PDE can be of different formats\n.*\n AIF   ('&TYPE' EQ 'CHAR').P2NTC\n AGO   .EITYPE\n.*\n.** Character input number\n.*\n.P2NTC ANOP ,\n LH    R14,&NAME.-IKJPARMD+4(R15)         Obtain length of number\n BCTR  R14,0                              Decrement for EX\n PACK  DOUBLE(8),0(0,R1)                  ** Executed **\n EX    R14,*-6                            Make the number packed\n CVB   R1,DOUBLE                          Convert the number to binary\n.*\n.** Save the output in the approiate location\n.*\nP$&SYSNDX.O EQU *\n DA#Z00 &OUTPUT,REG=15                    Locate output\n ST    R1,0(R15)                          Save the number\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**            Convert PDE to String                                 **\n.***                                                                ***\n.**********************************************************************\n.PDE2STR ANOP ,\n DA#Z01 &SYSLIST(0)                       Generate Label (if any)\n L     R15,&WA+DA#TSOSD_ANS-DA#TSOSD      -> Answer Area\n SLR   R14,R14                            Clear length (in case none)\n ICM   R1,B'1111',&NAME.-IKJPARMD(R15)    Locate PDE\n BZ    P$&SYSNDX.X                        IF zero then set output to 0\n LH    R14,&NAME.-IKJPARMD+4(R15)         Obtain length of number\n BCTR  R14,0                              Decrement for EX\n DA#Z00 &OUTPUT,REG=15                    Locate output\n.*\n.** Right Justification\n.*\n AIF   ('&RJUST' NE 'YES').P2SM           .Right Justification?\n LA    R15,&RJUSTL.-1(R15)                Point past string\n SR    R15,R14                            Back up to right just addr\n.*\n.** Move the string into the program's data area\n.*\n.P2SM ANOP ,\n MVC   0(0,R15),0(R1)                     ** Executed **\n EX    R14,*-6                            Make the number packed\nP$&SYSNDX.X EQU *\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**      Trim trailing blanks from a insert structure (data part)    **\n.***                                                                ***\n.**********************************************************************\n.TRIM ANOP ,\n DA#Z00 &MF(2),REG=15                     .Locate message insert\n LH    R1,0(R15)                          Obtain current length\n LA    R14,0(R1,R15)                      Locate past it\nT&SYSNDX.L EQU *\n BCTR  R14,0                              Backup up one\n CLI   0(R14),C' '                        Blank?\n BNE   T&SYSNDX.LX                        Nope, leave loop\n BCT   R1,T&SYSNDX.L                      Decrement length\n B     T&SYSNDX.X                         Ah oh- don't update it\nT&SYSNDX.LX EQU *\n CH    R1,=H'5'                           Minimum length?\n BNL   T&SYSNDX.S                         Okay, move on\n LA    R1,5                               Set to minimum length\nT&SYSNDX.S  EQU *\n STH   R1,0(R15)                          Save new length of insert\nT&SYSNDX.X  EQU *\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**        Convert DA#DATE  (Date routine) result into a TSO insert  **\n.***                                                                ***\n.**********************************************************************\n.DPE2INS ANOP ,\n DA#Z00 &MF(2)\n SLR   R14,R14                            Clear register\n IC    R14,DA#TSOSD_STRL-DA#TSOSD(R1) Get length\n LA    R14,4(R14)                         Increment by header\n STH   R14,0(R1)                          Save into header\n LA    R14,&OFFSET                        Locate offset\n STH   R14,2(R1)                          Save into offset location\n DA#Z05 &RET                              .Return to caller\n MEXIT  ,\n.**********************************************************************\n.***                                                                ***\n.**          Initialize the IOPL for GETLINE and PUTLINE             **\n.***                                                                ***\n.**********************************************************************\n.EDITR1 ANOP ,\n DA#Z01 &SYSLIST(0)                       Generate Label (if any)\n LTR   R1,R1                              Is input number zero?\n BZ    D5E&SYSNDX.0                       Yes, leave\n DA#Z00 &MF(2),REG=15                     Locate output location\n CVD   R1,0(R15)                          Make number\n LA    R14,8(R15)                         Locate edited output\n LA    R1,11(R14)                         Locate past sig. digit\n MVC   0(12,R14),=X'40,20,20,20,20,20,20,20,20,20,21,20'\n EDMK  0(12,R14),2(R15)                   Edit the number\n LA    R14,12(R14)                        Locate past the number\n SR    R14,R1                             Length = End - Start\n DA#Z00 &OUTPUT,REG=15                    Locate output location\n BCTR  R14,0                              Decrement for EX\n MVC   4(0,R15),0(R1)                     ** Executed **\n EX    R14,*-6                            Move number to output\n LA    R14,4+1(R14)                       Bump up for Header + EX\n STH   R14,0(R15)                         Save length of number\n B     D5E&SYSNDX.X                       Leave\nD5E&SYSNDX.0 EQU *\n DA#Z00 &OUTPUT,REG=15                    Locate output location\n LA    R1,5                               Length of header + number\n STH   R1,0(R15)                          Save it into header\n MVI   4(R15),C'0'                        Insert number\nD5E&SYSNDX.X EQU *\n DA#Z05 &RET                              .Return to caller\n MEXIT ,\n.*\n.**********************************************************************\n.***                                                                ***\n.**     Generate AID table with 7 byte description                   **\n.***                                                                ***\n.**********************************************************************\n.*\n.CALCSBA ANOP  ,\n DA#Z01 &SYSLIST(0)                       Generate Label (if any)\n         MVI   0(&CSOREG),$DA#TSOS_SBA    Move in SBA byte\n         LA    &CSOREG,1(&CSOREG)         Bump past it\n*\n** Calculate binary offset: ((ROW-1) X WIDTH) + COLUMN-1)\n*\n         BCTR  &CSRREG,0                  Get Row relative to zero\n         MH    &CSRREG,&WA+DA#TSOSD_SCRCOL-DA#TSOSD+2\n         BCTR  &CSCREG,0                  Get Column relative to zero\n         AR    &CSRREG,&CSCREG            Add to columns\n*\n** Convert Binary offset to 3270 Buffer Address\n*\n         SLR   &CSCREG,&CSCREG            Clear register\n         C     &CSRREG,=F'4095'           Bigger screen?\n         BH    CSB&SYSNDX                 Yes, move on\n         SLDL  &CSCREG,26                 Shift first byte\n         SRL   &CSRREG,26                 Shift back flush\n         IC    R15,RTSO_DS3270T(&CSCREG) Pick up 1ST address byte\n         SLL   R15,8                      Make room for 2ND Byte\n         IC    R15,RTSO_DS3270T(&CSRREG) Pick up 2ND address byte\n         STH   R15,0(&CSOREG)             Save SBA\n         B     CSX&SYSNDX                 Leave\nCSB&SYSNDX EQU *\n         SLDL  &CSCREG,24                 Shift first byte\n         SRL   &CSRREG,24                 Shift back flush\n         STC   &CSCREG,0(&CSOREG)         Save SBA byte 1\n         STC   &CSRREG,1(&CSOREG)         Save SBA byte 2\n         B     CSX&SYSNDX                 Branch past table\n         AGO   .IOTABLE                   .Get table\n.CSIOTX  ANOP  ,\nCSX&SYSNDX DS  0H\n         LA    &CSOREG,2(&CSOREG)         Bump past SBA bytes\n         MEXIT ,\n.*\n.**********************************************************************\n.***                                                                ***\n.**     Generate AID table with 7 byte description                   **\n.***                                                                ***\n.**********************************************************************\n.*\n.AIDTAB  ANOP  ,\n*\n**  Attention IDentification Table\n*\nRTSOA EQU     *\n         DC   AL1($DA#TSOS_AIDNO),CL7'NOAID-D'\n         DC   AL1($DA#TSOS_AIDNOP),CL7'NOAID-P'\n         DC   AL1($DA#TSOS_AIDSELA),CL7'LT PEN'\n         DC   AL1($DA#TSOS_AIDENT),CL7'Enter  '\n         DC   AL1($DA#TSOS_AIDPF1),CL7'PFK1   '\n         DC   AL1($DA#TSOS_AIDPF2),CL7'PFK2   '\n         DC   AL1($DA#TSOS_AIDPF3),CL7'PFK3   '\n         DC   AL1($DA#TSOS_AIDPF4),CL7'PFK4   '\n         DC   AL1($DA#TSOS_AIDPF5),CL7'PFK5   '\n         DC   AL1($DA#TSOS_AIDPF6),CL7'PFK6   '\n         DC   AL1($DA#TSOS_AIDPF7),CL7'PFK7   '\n         DC   AL1($DA#TSOS_AIDPF8),CL7'PFK8   '\n         DC   AL1($DA#TSOS_AIDPF9),CL7'PFK9   '\n         DC   AL1($DA#TSOS_AIDPF10),CL7'PFK10   '\n         DC   AL1($DA#TSOS_AIDPF11),CL7'PFK11   '\n         DC   AL1($DA#TSOS_AIDPF12),CL7'PFK12   '\n         DC   AL1($DA#TSOS_AIDPF13),CL7'PFK13   '\n         DC   AL1($DA#TSOS_AIDPF14),CL7'PFK14   '\n         DC   AL1($DA#TSOS_AIDPF15),CL7'PFK15   '\n         DC   AL1($DA#TSOS_AIDPF16),CL7'PFK16   '\n         DC   AL1($DA#TSOS_AIDPF17),CL7'PFK17   '\n         DC   AL1($DA#TSOS_AIDPF18),CL7'PFK18   '\n         DC   AL1($DA#TSOS_AIDPF19),CL7'PFK19   '\n         DC   AL1($DA#TSOS_AIDPF20),CL7'PFK20   '\n         DC   AL1($DA#TSOS_AIDPF21),CL7'PFK21   '\n         DC   AL1($DA#TSOS_AIDPF22),CL7'PFK22   '\n         DC   AL1($DA#TSOS_AIDPF23),CL7'PFK23   '\n         DC   AL1($DA#TSOS_AIDPF24),CL7'PFK24   '\n         DC   AL1($DA#TSOS_AIDPA1),CL7'PA1    '\n         DC   AL1($DA#TSOS_AIDPA2),CL7'PA2    '\n         DC   AL1($DA#TSOS_AIDPA3),CL7'PA3    '\n         DC   AL1($DA#TSOS_AIDCLR),CL7'Clear  '\n         DC   AL1($DA#TSOS_AIDREQ),CL7'TestReq'\n         DC   AL1($DA#TSOS_AIDOPID),CL7'OperID'\nRTSOAE EQU     ((*-RTSOA)/RTSOAL)            Number of entries\nRTSOAL EQU     1+7                           Length of each entry\n         DC   AL1(0),CL7'Unknown'\n MEXIT ,\n.*\n.**********************************************************************\n.***                                                                ***\n.**         3270 Data Stream control character equates               **\n.***                                                                ***\n.**********************************************************************\n.*\n.EQU     ANOP  ,\n*\n** Buffer orders\n*\n$DA#TSOS_SF  EQU X'1D'                    Start Field\n$DA#TSOS_SBA EQU X'11'                    Set Buffer Address\n$DA#TSOS_IC  EQU X'13'                    Insert Cursor\n$DA#TSOS_PT  EQU X'05'                    Program Tab\n$DA#TSOS_RA  EQU X'3C'                    Repeat to Address\n$DA#TSOS_SFE EQU X'29'                    Start Field Extended\n$DA#TSOS_EUA EQU X'12'                    Repeat Unprotected to Address\n$DA#TSOS_MF  EQU X'2C'                    Modify Field\n$DA#TSOS_SA  EQU X'28'                    Set Attribute\n*\n** Extended Highlighting\n*\n$DA#TSOS_XHILITE    EQU X'41'              Extended Highlighting\n$DA#TSOS_XH_DEFAULT EQU X'00'              ..Select default\n$DA#TSOS_XH_BLINK   EQU X'F1',X'10'        ..Blink\n$DA#TSOS_XH_RVIDEO  EQU X'F2',X'20'        ..Reverse Video\n$DA#TSOS_XH_USCORE  EQU X'F4',X'30'        ..Underscore\n*\n** Extended Color\n*\n$DA#TSOS_XCOLOR     EQU X'42'              Extended Color\n$DA#TSOS_XC_DEFAULT EQU X'00'              ..Select default\n$DA#TSOS_XC_BLUE    EQU X'F1',X'01'        ..Blue\n$DA#TSOS_XC_RED     EQU X'F2',X'02'        ..Red\n$DA#TSOS_XC_PINK    EQU X'F3',X'03'        ..Pink\n$DA#TSOS_XC_GREEN   EQU X'F4',X'04'        ..Green\n$DA#TSOS_XC_TURQ    EQU X'F5',X'05'        ..Turquoise\n$DA#TSOS_XC_YELLOW  EQU X'F6',X'06'        ..Yellow\n$DA#TSOS_XC_WHITE   EQU X'F7',X'07'        ..White\n*\n** Attribute character equates\n**\n**  A...Prefix for attributes          H...High intensity\n**  U...Unprotected field              E...Select pen detectable\n**  P...Protected field                I...Non-Display\n**  N...Numerics only                  M...Modified data tag on\n**  S...Automatic skip\n*\n$DA#TSOS_AU     EQU X'40',X'FF' UNPROT\n$DA#TSOS_AUM    EQU X'C1'    UNPROT,MDT ON\n$DA#TSOS_AUE    EQU X'C4'    UNPROT,SEL PEN\n$DA#TSOS_AUEM   EQU X'C5'    UNPROT,SEL PEN,MDT ON\n$DA#TSOS_AUHE   EQU X'C8'    UNPROT,HIGH INTENS,SEL PEN\n$DA#TSOS_AUHEM  EQU X'C9',X'FE' UNPROT,HIGH INTENS,SEL PEN,MDT ON\n$DA#TSOS_AUI    EQU X'4C'    UNPROT,NON-DISP\n$DA#TSOS_AUIM   EQU X'4D'    UNPROT,NON-DISP,MDT ON\n$DA#TSOS_AUN    EQU X'50'    UNPROT,NUMERIC\n$DA#TSOS_AUNM   EQU X'D1'    UNPROT,NUMERIC,MDT ON\n$DA#TSOS_AUNE   EQU X'D4'    UNPROT,NUMERIC,SEL PEN\n$DA#TSOS_AUNEM  EQU X'D5'    UNPROT,NUMERIC,SEL PEN,MDT ON\n$DA#TSOS_AUNHE  EQU X'D8'    UNPROT,NUMERIC,HIGH INTENS,SEL PEN\n$DA#TSOS_AUNHEM EQU X'D9'    UNPROT,NUMERIC,HIGH INTENS,SEL PEN,MDT ON\n$DA#TSOS_AUNI   EQU X'5C'    UNPROT,NUMERIC,NON-DISP\n$DA#TSOS_AUNIM  EQU X'5D'    UNPROT,NUMERIC,NON-DISP,MDT ON\n$DA#TSOS_AP     EQU X'60'    PROT\n$DA#TSOS_APM    EQU X'61'    PROT,MDT ON\n$DA#TSOS_APE    EQU X'E4'    PROT,SEL PEN\n$DA#TSOS_APEM   EQU X'E5'    PROT,SEL PEN,MDT ON\n$DA#TSOS_APHE   EQU X'E8'    PROT,HIGH INTENS,SEL PEN\n$DA#TSOS_APHEM  EQU X'E9'    PROT,HIGH INTENS,SEL PEN,MDT ON\n$DA#TSOS_API    EQU X'6C'    PROT,NON-DISP\n$DA#TSOS_APIM   EQU X'6D'    PROT,NON-DISP,MDT ON\n$DA#TSOS_APS    EQU X'F0'    PROT,AUTO SKIP\n$DA#TSOS_APSM   EQU X'F1'    PROT,AUTO SKIP,MDT ON\n$DA#TSOS_APSE   EQU X'F4'    PROT,AUTO SKIP,SEL PEN\n$DA#TSOS_APSEM  EQU X'F5'    PROT,AUTO SKIP,SEL PEN,MDT ON\n$DA#TSOS_APSHE  EQU X'F8'    PROT,AUTO SKIP,HIGH INTENS,SEL PEN\n$DA#TSOS_APSHEM EQU X'F9'    PROT,AUTO SKIP,HIGH INTENS,SEL PEN,MDT ON\n$DA#TSOS_APSI   EQU X'7C'    PROT,AUTO SKIP,NON-DISP\n$DA#TSOS_APSIM  EQU X'7D'    PROT,AUTO SKIP,NON-DISP,MDT ON\n*\n**  Command codes\n*\n$DA#TSOS_CCW   EQU X'F1'  WRITE\n$DA#TSOS_CCEW  EQU X'F5'  ERASE/WRITE\n$DA#TSOS_CCEWA EQU X'7E'  ERASE/WRITE ALTERNATE\n$DA#TSOS_CCRB  EQU X'F2'  READ BUFFER\n$DA#TSOS_CCRM  EQU X'F6'  READ MODIFIED\n$DA#TSOS_CCRMA EQU X'6E'  READ MODIFIED ALL\n$DA#TSOS_CCEAU EQU X'6F'  ERASE ALL UNPROTECTED\n$DA#TSOS_CCWSF EQU X'F3'  WRITE STRUCTURED FIELD\n*\n**  Write Control Character\n*\n$DA#TSOS_WCCM  EQU X'C1'   RESET MDT'S\n$DA#TSOS_WCCK  EQU X'C2'   KEYBOARD RESTORE\n$DA#TSOS_WCCKM EQU X'C3'   KEYBOARD RESTORE,RESET MDT'S\n*\n**  InBound Structured Fields\n*\n$DA#TSOS_AIDISF EQU X'C1'        Inbound Structured Field\n$DA#TSOS_AISF_IB3270 EQU X'80'   ..InBound 3270DS\n$DA#TSOS_AISF_QR   EQU X'81'     ..Query Reply\n$DA#TSOS_AISF_QRCOLOR  EQU X'86'   ..Color\n*\n**  Attention IDentification\n*\n.AID     ANOP  ,\n$DA#TSOS_AIDNO   EQU X'60'  NO AID GENERATED (DISPLAY)\n$DA#TSOS_AIDNOP  EQU X'E8'  NO AID GENERATED (PRINTER)\n$DA#TSOS_AIDSELA EQU X'7E'  SELECTOR LIGHT-PEN ATTENTION SPACE NULL\n$DA#TSOS_AIDENT  EQU X'7D'  ENTER KEY AND SEL PEN ATTENTION\n$DA#TSOS_AIDPF1  EQU X'F1'  PF 1 KEY\n$DA#TSOS_AIDPF2  EQU X'F2'  PF 2 KEY\n$DA#TSOS_AIDPF3  EQU X'F3'  PF 3 KEY\n$DA#TSOS_AIDPF4  EQU X'F4'  PF 4 KEY\n$DA#TSOS_AIDPF5  EQU X'F5'  PF 5 KEY\n$DA#TSOS_AIDPF6  EQU X'F6'  PF 6 KEY\n$DA#TSOS_AIDPF7  EQU X'F7'  PF 7 KEY\n$DA#TSOS_AIDPF8  EQU X'F8'  PF 8 KEY\n$DA#TSOS_AIDPF9  EQU X'F9'  PF 9 KEY\n$DA#TSOS_AIDPF10 EQU X'7A'  PF 10 KEY\n$DA#TSOS_AIDPF11 EQU X'7B'  PF 11 KEY\n$DA#TSOS_AIDPF12 EQU X'7C'  PF 12 KEY\n$DA#TSOS_AIDPF13 EQU X'C1'  PF 13 KEY\n$DA#TSOS_AIDPF14 EQU X'C2'  PF 14 KEY\n$DA#TSOS_AIDPF15 EQU X'C3'  PF 15 KEY\n$DA#TSOS_AIDPF16 EQU X'C4'  PF 16 KEY\n$DA#TSOS_AIDPF17 EQU X'C5'  PF 17 KEY\n$DA#TSOS_AIDPF18 EQU X'C6'  PF 18 KEY\n$DA#TSOS_AIDPF19 EQU X'C7'  PF 19 KEY\n$DA#TSOS_AIDPF20 EQU X'C8'  PF 20 KEY\n$DA#TSOS_AIDPF21 EQU X'C9'  PF 21 KEY\n$DA#TSOS_AIDPF22 EQU X'4A'  PF 22 KEY\n$DA#TSOS_AIDPF23 EQU X'4B'  PF 23 KEY\n$DA#TSOS_AIDPF24 EQU X'4C'  PF 24 KEY\n$DA#TSOS_AIDPA1  EQU X'6C'  PA 1 KEY\n$DA#TSOS_AIDPA2  EQU X'6E'  PA 2 KEY\n$DA#TSOS_AIDPA3  EQU X'6B'  PA 3 KEY\n$DA#TSOS_AIDCLR  EQU X'6D'  CLEAR KEY\n$DA#TSOS_AIDREQ  EQU X'F0'  TEST REQ AND SYS REQ KEY\n$DA#TSOS_AIDOPID EQU X'E6'  OPERATOR IDENTIFICATION\n MEXIT ,\n.*\n.**********************************************************************\n.***                                                                ***\n.**      Generate an I/O table (see 3274 programming guide)          **\n.***                                                                ***\n.**********************************************************************\n.*\n.IOTABLE ANOP ,\n*\n** 3270 Control character I/O codes\n*\nDA#TSOS_DS3270T EQU *\n DC X'40,C1,C2,C3,C4,C5,C6,C7,C8,C9,4A,4B,4C,4D,4E,4F'\n DC X'50,D1,D2,D3,D4,D5,D6,D7,D8,D9,5A,5B,5C,5D,5E,5F'\n DC X'60,61,E2,E3,E4,E5,E6,E7,E8,E9,6A,6B,6C,6D,6E,6F'\n DC X'F0,F1,F2,F3,F4,F5,F6,F7,F8,F9,7A,7B,7C,7D,7E,7F'\n.IOTX    ANOP  ,\n         AIF   ('&ITYPE' EQ 'CALCSBA').CSIOTX\n         MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**      Full Screen Initialization                                  **\n.***                                                                ***\n.**********************************************************************\n.FSINIT  ANOP ,\n*\n** Ensure that the terminal meets minimum requirements\n*\n         LA    R14,&WA                    Locate work area\n         CLI   DA#TSOSD_SCRROW-DA#TSOSD+3(R14),24 Columns => 24\n         BL    &EITERM                    No, invalid\n         CLI   DA#TSOSD_SCRCOL-DA#TSOSD+3(R14),80 Rows => 80\n         BL    &EITERM                    No, invalid\n*\n** Establish a Full screen environment\n*\n MNOTE ' STFSMODE ON,INITIAL=YES          Start full screen mode '\n         STFSMODE ON,INITIAL=YES          Start full screen mode\n         LTR   R15,R15                    Was it successfull\n         BNZ   &ENTERM                    No, fullscreen not available\n MNOTE ' STTMPMD ON                       Give control to the cmd proc'\n         STTMPMD ON                       Give control to the cmd proc\n MNOTE ' STLINENO LINE=1                  Tell VTAM where to go'\n         STLINENO LINE=1                  Tell VTAM where to go\n         OI    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_FS\n*\n** Clear Queues\n*\n MNOTE ' TCLEARQ INPUT                    Clear Input queue'\n         TCLEARQ INPUT                    Clear Input queue (terminal)\n MNOTE ' TCLEARQ OUTPUT                   Clear Output queue'\n         TCLEARQ OUTPUT                   Clear Output queue (terminal)\n         AIF   ('&STAX' EQ '').FSISX      .Do Stax processing?\n*\n** Create an attention exit\n*\n LA  R14,&WA+DA#TSOSD_STAXR13-DA#TSOSD    Locate DSA pointer\n ST  R13,0(R14)                           Save address of DSA\n LA  R1,&WA+DA#TSOSD_RECOUT-DA#TSOSD      Locate parameter list area\n MVC 0(I&SYSNDX.L,R1),I&SYSNDX            Copy STAX Parm List\n L   R15,&STAX                            Locate STAX routine\n MNOTE ' STAX  (R15),                     Address of STAX routine @'\n MNOTE '       USADDR=(R14),              Address of WORKDS       @'\n MNOTE '       MF=(E,(R1))                Execute from here        '\n         STAX  (R15),                     Address of STAX routine      @\n               USADDR=(R14),              Address of WORKDS            @\n               MF=(E,(R1))                Execute from here\n         OI    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_STAX\n         B     I&SYSNDX.X EQU *           Branch past constant\n MNOTE 'I&SYSNDX STAX MF=L '\nI&SYSNDX STAX *-*,MF=L\nI&SYSNDX.L EQU *-I&SYSNDX\nI&SYSNDX.X EQU *\n.FSISX   ANOP  ,\n*\n** Obtain an area to build the screen buffer\n*\n         SPACE 2\n         SLR   R0,R0                      Clear register for mulitply\n         L     R1,&WA+DA#TSOSD_SCRROW-DA#TSOSD\n         MH    R1,&WA+DA#TSOSD_SCRCOL-DA#TSOSD+2\n         LA    R1,256(R1)                 Add header + slack\n         LR    R0,R1                      Put into getmain register\n MNOTE ' GETMAIN R,                       Obtain storage      @'\n MNOTE '       LV=(0)                     Length of screen     '\n         GETMAIN R,                       Obtain storage               @\n               LV=(0)                     Length of screen\n         ST    R0,&WA+DA#TSOSD_SCRL-DA#TSOSD >Length\n         ST    R1,&WA+DA#TSOSD_SCRA-DA#TSOSD >Address\n         MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**      Get fields from Work Area                                   **\n.***                                                                ***\n.**********************************************************************\n.GANS    ANOP  ,\n         L     &WRKREG,&WA+DA#TSOSD_ANS-DA#TSOSD\n         MEXIT ,\n.GCPPL   ANOP  ,\n         L     &WRKREG,&WA+DA#TSOSD_CPPL-DA#TSOSD\n         MEXIT ,\n.GROW    ANOP  ,\n         L     &WRKREG,&WA+DA#TSOSD_SCRROW-DA#TSOSD\n         MEXIT ,\n.GCOL    ANOP  ,\n         L     &WRKREG,&WA+DA#TSOSD_SCRCOL-DA#TSOSD\n         MEXIT ,\n.GSCRA   ANOP  ,\n         L     &WRKREG,&WA+DA#TSOSD_SCRA-DA#TSOSD\n         MEXIT ,\n.GSCRL   ANOP  ,\n         L     &WRKREG,&WA+DA#TSOSD_SCRL-DA#TSOSD\n         MEXIT ,\n.TSTQRY  ANOP  ,\n         TM    &WA+DA#TSOSD_AFLAG4-DA#TSOSD,$DA#TSOSD_AF4QUERY\n         BNO   &ERRET\n         MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**      Initialization                                              **\n.***                                                                ***\n.**********************************************************************\n.INIT    ANOP ,\n LA    R1,&WA                     Save address of storage\n MVI   0(R1),X'00'\n MVC   1(DA#TSOSD_RECOUT-DA#TSOSD,R1),0(R1)\n.*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Obtain terminal information\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n MNOTE ' GTSIZE ,'\n GTSIZE ,\n ST    R0,&WA+DA#TSOSD_SCRROW-DA#TSOSD\n ST    R1,&WA+DA#TSOSD_SCRCOL-DA#TSOSD\n*\n MNOTE ' GTTERM PRMSZE=&WA+DA#TSOSD_PRMSIZE-DA#TSOSD, '\n MNOTE '       ALTSZE=&WA+DA#TSOSD_ALTSIZE-DA#TSOSD,  '\n MNOTE '       ATTRIB=&WA+DA#TSOSD_ATTRIB-DA#TSOSD,   '\n MNOTE '       MF=(E,&WA+DA#TSOSD_RECOUT-DA#TSOSD     '\n         GTTERM PRMSZE=&WA+DA#TSOSD_PRMSIZE-DA#TSOSD,                  @\n               ALTSZE=&WA+DA#TSOSD_ALTSIZE-DA#TSOSD,                   @\n               ATTRIB=&WA+DA#TSOSD_ATTRIB-DA#TSOSD,                    @\n               MF=(E,&WA+DA#TSOSD_RECOUT-DA#TSOSD)\n XC &WA+DA#TSOSD_RECOUT-DA#TSOSD(12),&WA+DA#TSOSD_RECOUT-DA#TSOSD\n SPACE 2\n.*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n.** CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL CPPL\n.*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n         AIF   ('&PCPPL' EQ 'NO').CPPLX\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** CPPL processing\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n SPACE 2\n L     R1,&CPPL                   Locate the CPPL\n ST    R1,&WA+DA#TSOSD_CPPL-DA#TSOSD Save the current CPPL\n TM    CPPLCBUF-CPPL(R1),B'10000000' Were we called?\n BNO   DA#TSOS_CPPLX_I&SYSNDX     No, CPPL is good\n*\n** Build Fake CPPL, CBUF for called \"Command Processor\"\n*\n LA    R0,DA#TSOSFL               Get Control block length\n L     R14,0(R1)                  Locate parameter list\n AH    R0,0(R14)                  Obtain the length\n MNOTE ' GETMAIN R,LV=(0)'\n GETMAIN R,LV=(0)                 Obtain storage\n*\n STM   R0,R1,&WA+DA#TSOSD_FCPPLVS-DA#TSOSD\n XC    0(DA#TSOSFL,R1),0(R1)              Clear work area\n*\n** Initialize the command buffer header and save location into CPPL\n*\n LA    R15,DA#TSOSF_CBUF_H-DA#TSOSF(R1) Locate CBUF\n ST    R15,CPPLCBUF-CPPL(R1)      Save address of CBUF\n MVC   DA#TSOSF_CBUF_H+2-DA#TSOSF(2,R1),=AL2(&PNAMEL)\n LA    R14,&PNAMEL-1              Get program Name length\n LA    R15,DA#TSOSF_CBUF_B-DA#TSOSF(R1) Locate CBUF buffer\n*\n** Place program name into buffer\n*\n AIF   ('&PNAME' EQ '').EPNAME          .Program name address?\n AIF   ('&PNAMEL' EQ '').EPNAMEL        .Program Name length?\n.*\n AIF   ('&PNAME'(1,1) EQ '(').IPNAMER   .Register format?\n MVC   0(0,R15),&PNAME\n AGO   .IPNAMEX                         .Move on\n.IPNAMER ANOP  ,\n MVC   0(0,R15),0(&PNAME(1))\n.IPNAMEX ANOP  ,\n EX    R14,*-6                    Move program name out\n LA    R15,1(R14,R15)             Bump past program name\n MVI   0(R15),C' '                Ensure blanks\n LA    R15,1(R15)                 Bump past it\n*\n** If there is something passed to us in the Batch style parm, place\n** it into the CBUF\n*\n L     R14,&CPPL                          Locate parameter start\n L     R14,0(R14)                         Locate address\n SLR   R1,R1                              Clear register\n ICM   R1,B'0011',0(R14)                  Obtain the length\n BZ    ICPPL$CBX                          Zero, leave\n BCTR  R1,0                               Decrement for EX\n MVC   0(0,R15),2(R14)                    ** Executed **\n EX    R1,*-6                             Move parameter to our CBUF\n LA    R15,1(R1,R15)                      Bump past it\nICPPL$CBX EQU *\n L     R1,&WA+DA#TSOSD_CPPL-DA#TSOSD      -> DA#TSOSF\n LA    R14,DA#TSOSF_CBUF_H-DA#TSOSF(R1)   Locate start of CBUF\n SR    R15,R14                            Length = End - Begining\n STH   R15,DA#TSOSF_CBUF_H-DA#TSOSF(R1)   Save length\n*\n** Locate Control Blocks (PSCB & UPT) and place into fake CPPL\n*\n L     R15,PSATOLD-PSA            -> TCB\n L     R15,TCBJSCB-TCB(,R15)      -> JSCB\n L     R15,JSCBPSCB-IEZJSCB(,R15) -> PSCB\n ST    R15,CPPLPSCB-CPPL(R1)      Save address of PSCB\n*\n L     R15,PSCBUPT-PSCB(R15)      -> UPT\n ST    R15,CPPLUPT-CPPL(R1)       Save address of UPT\n*\n L     R15,PSAAOLD-PSA            -> ASCB\n L     R15,ASCBASXB-ASCB(,R15)    -> ASXB\n L     R15,ASXBLWA-ASXB(R15)      -> LWA\n L     R15,LWAPECT-LWA(,R15)      -> ECT\n ST    R15,CPPLECT-CPPL(R1)       Save address of ECT\nDA#TSOS_CPPLX_I&SYSNDX EQU *\n.CPPLX   ANOP  ,\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Initialize PUTLINE routine\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n LA    R15,&WA                            Locate Work area\n L     R1,DA#TSOSD_CPPL-DA#TSOSD(R15)     Locate CPPL\n L     R14,CPPLUPT-CPPL(,R1)              Get UPT location\n ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLUPT-IOPL(R15)\n L     R14,CPPLECT-CPPL(,R1)              Get ECT location\n ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLECT-IOPL(R15)\n.*\n LA    R14,DA#TSOSD_PLECB-DA#TSOSD(R15) Locate ECB\n ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLECB-IOPL(R15)\n LA    R14,DA#TSOSD_PTPB-DA#TSOSD(R15)    Locate PTPB\n ST    R14,DA#TSOSD_IOPL-DA#TSOSD+IOPLIOPB-IOPL(R15)\n MVC   0(DA#TSOS_PUTLC_I&SYSNDX.L,R14),DA#TSOS_PUTLC_I&SYSNDX\n B     DA#TSOS_PUTLC_I&SYSNDX.X EQU * Branch past constant\n*\n MNOTE 'DA#TSOS_PUTLC_I&SYSNDX PUTLINE OUTPUT=(0,TERM,SINGLE,...'\nDA#TSOS_PUTLC_I&SYSNDX PUTLINE OUTPUT=(*-*,TERM,SINGLE,INFOR),MF=L\nDA#TSOS_PUTLC_I&SYSNDX.L EQU *-DA#TSOS_PUTLC_I&SYSNDX\nDA#TSOS_PUTLC_I&SYSNDX.X EQU *\n*\n LA    R15,&WA                            Locate work area\n LA    R1,1                               || Put line number\n ST    R1,DA#TSOSD_PLNUM-DA#TSOSD(R15)    ||\n.*\n LA    R1,DA#TSOSD_RECHEAD-DA#TSOSD(R15) ||| Putline address\n XC    2(2,R1),0(R1)                      |||\n ST    R1,DA#TSOSD_PLADR-DA#TSOSD(R15)    |||\n.*\n LA    R1,DA#TSOSD_PLNUM-DA#TSOSD(R15)\n ST    R1,DA#TSOSD_PTPB-DA#TSOSD+PTPBOPUT-PTPB(R15)\n.*\n AIF   ('&PCL' EQ '').IPARSEX       .Do PARSE processing\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Initialize PARSE routine\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n LA    R15,&WA                      Locate Work area\n L     R14,DA#TSOSD_CPPL-DA#TSOSD(R15) -> CPPL\n L     R1,CPPLUPT-CPPL(,R14)\n ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLUPT-PPL(R15)\n L     R1,CPPLECT-CPPL(,R14)\n ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLECT-PPL(R15)\n LA    R1,DA#TSOSD_PARSECB-DA#TSOSD(R15)\n ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLECB-PPL(R15)\n L     R1,&PCL\n ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLPCL-PPL(R15)\n LA    R1,DA#TSOSD_ANS-DA#TSOSD(R15)\n ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLANS-PPL(R15)\n L     R1,CPPLCBUF-CPPL(,R14)\n ST    R1,DA#TSOSD_PPL-DA#TSOSD+PPLCBUF-PPL(R15)\n*\n** Call the TSO PARSE routine\n*\n LA    R1,&WA\n LA    R1,DA#TSOSD_PPL-DA#TSOSD(R1)\n MNOTE ' CALLTSSR EP=IKJPARS,MF=(E,(1)) '\n CALLTSSR EP=IKJPARS,MF=(E,(1))\n CH    R15,=H'0'                          Parse Successful?\n BE    DA#TSOS_PARSEX_I&SYSNDX            No, continue\n CH    R15,=H'4'\n BE    DA#TSOS_PARSEE_I&SYSNDX\n CH    R15,=H'20'\n BE    DA#TSOS_PARSEE_I&SYSNDX\n*\n LA    R1,&WA+DA#TSOSD_RECOUT+4-DA#TSOSD\n XC    0(GFLENGF,R1),0(R1)                Clear the Parm list\n ST    R15,GFRCODE-GFCBPTR(,R1)           Save Parse RC\n LA    R15,GFPARSE                        Indicate Parse error\n STH   R15,GFCALLID-GFCBPTR(R1)           Save into parm list\n L     R15,&WA+DA#TSOSD_CPPL-DA#TSOSD     Get Address of the CPPL\n ST    R15,GFCPPLP-GFCBPTR(R1)            Save into parm list\n*\n ST    R1,&WA+DA#TSOSD_RECOUT-DA#TSOSD\n LINK  EP=IKJEFF19,MF=(E,&WA+DA#TSOSD_RECOUT-DA#TSOSD)\nDA#TSOS_PARSEE_I&SYSNDX EQU *\n OI    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_PARSEE\n B     &ERRET\nDA#TSOS_PARSEX_I&SYSNDX EQU *\n.IPARSEX ANOP  ,\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**      Initialize Message for Putline                              **\n.***                                                                ***\n.**********************************************************************\n.INITMSG ANOP ,\n*\n** Initialize message for TSO putline processing\n** Output: R15 will point to record\n*\n DA#Z01 &SYSLIST(0)               Generate Label (if any)\n LA   R1,&WA\n LA   R15,DA#TSOSD_RECOUT-DA#TSOSD(R1)\n MVI  0(R15),C' '\n MVC  1(L'DA#TSOSD_RECOUT-1,R15),0(R15)\n DA#Z05 &RET\n SPACE 3\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**      Print Message                                               **\n.***                                                                ***\n.**********************************************************************\n.PRTMSG  ANOP ,\n DA#Z01 &SYSLIST(0)                       Generate Label (if any)\n LA    R1,&WA\n XC    DA#TSOSD_PLECB-DA#TSOSD(4,R1),DA#TSOSD_PLECB-DA#TSOSD(R1)\n AIF   ('&MSG' EQ '').PMSING\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.** Insert mode\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n LA    R14,DA#TSOSD_PLNUM-DA#TSOSD(R1)    Locate Output Line Desc.\n LCLA  &MLC,&MLO                          .Declare variables\n&MLC   SETA  1                            .Initialize to one\n&MLO   SETA  4                            .Initialize offset\n.MPL   ANOP  ,                            .Loop start\n AIF   ('&MSG(&MLC)'(1,1) EQ '(').MPR     .Register Format?\n LA    R15,&MSG(&MLC)                     Locate parameter\n ST    R15,&MLO.(R14)                     Save it into parm list\n AGO   .MPRX\n.MPR   ANOP ,\n ST    &MSG(&MLC,1).,&MLO.(R14)           Save location into parm list\n.MPRX  ANOP ,\n AIF   (&MLC EQ 32).MOVER\n&MLC   SETA  &MLC+1                       .Locate next one\n AIF   ('&MSG(&MLC)' EQ '').MPE           .Is there another one?\n&MLO   SETA  &MLO+4                       .Locate next one\n AGO   .MPL\n.MOVER ANOP ,\n MNOTE 4,'RTSO-20W Overflow: Only first 32 inserts used'\n.MPE   ANOP  ,                            .Exit from PARAM= processing\n&MLC   SETA  &MLC-1                       .Decrement by 1\n LA    R15,&MLC                           Get number of messages\n ST    R15,0(R14)                         Save number of messages\n AGO   .PMCOM\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.** Single mode\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.PMSING  ANOP  ,\n* Input: R15 must point at last byte in the message (+1)\n LA    R14,DA#TSOSD_RECHEAD-DA#TSOSD(R1) Locate beginning\n SR    R15,R14                            Length = End - start\n STH   R15,DA#TSOSD_RECHEAD-DA#TSOSD(R1) Save length\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.** Common Code (no cure for it)\n.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n.PMCOM   ANOP  ,\n LA    R1,DA#TSOSD_IOPL-DA#TSOSD(R1)      Locate the IOPL\n MNOTE ' PUTLINE MF=(E,(1)) '\n PUTLINE MF=(E,(1))\n DA#Z02 &EPUTL                            .Do error routine\n DA#Z05 &RET\n SPACE 3\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**      Terminate                                                   **\n.***                                                                ***\n.**********************************************************************\n.TERM    ANOP ,\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** CPPL termination section\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n LM    R0,R1,&WA+DA#TSOSD_FCPPLVS-DA#TSOSD\n LTR   R0,R0                      Any length?\n BZ    DA#TSOS_CPPLX_T&SYSNDX     None, move on\n MNOTE '         FREEMAIN R,LV=(0),A=(1)'\n FREEMAIN R,LV=(0),A=(1)          Obtain storage\nDA#TSOS_CPPLX_T&SYSNDX EQU *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** PUTLINE termination section\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nDA#TSOS_PUTLX_T&SYSNDX EQU *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** PARSE termination section\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n TM    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_PARSEE\n BO    DA#TSOS_PARSEX_T&SYSNDX\n ICM   R1,B'1111',&WA+DA#TSOSD_ANS-DA#TSOSD\n BZ    DA#TSOS_PARSEX_T&SYSNDX             None, leave\n MNOTE ' IKJRLSA (1)'\n IKJRLSA (1)                               Free storage\nDA#TSOS_PARSEX_T&SYSNDX EQU *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Free The Screen Buffer Area\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n ICM   R1,B'1111',&WA+DA#TSOSD_SCRA-DA#TSOSD\n BZ    B&SYSNDX                        No Address, move on\n L     R0,&WA+DA#TSOSD_SCRL-DA#TSOSD Get length\n FREEMAIN R,LV=(0),A=(1)               Release the storage\nB&SYSNDX EQU   *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n** Full Screen Terminations\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n TM    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_FS\n BNO   FS&SYSNDX\n STLINENO LINE=1,MODE=ON          Clear screen before exiting\n STFSMODE OFF                     Exit Full screen mode\n STTMPMD OFF                      Return to display term mgr\nFS&SYSNDX EQU  *\n TM    &WA+DA#TSOSD_F1-DA#TSOSD,$DA#TSOSD_F1_STAX\n BNO   FSS&SYSNDX\n STAX  ,                          Turn off Attention exit\nFSS&SYSNDX EQU *\n MEXIT ,\n.**********************************************************************\n.***                                                                ***\n.**   Map tso TSO services work area                                 **\n.***                                                                ***\n.**********************************************************************\n.DSECT   ANOP  ,\n*\n** Main DSECT for TSO services\n*\nDA#TSOSD         DSECT ,\nDA#TSOSD_FCPPLVS DS    2F                 Fake CPPL Length, Address\nDA#TSOSD_CPPL    EQU   *-4                Address of CPPL\nDA#TSOSD_SCRA    DS    F                  Screen Buffer Address\nDA#TSOSD_SCRL    DS    F                  Screen Buffer Length\nDA#TSOSD_SCRROW DS     F                  Screen Rows\nDA#TSOSD_SCRCOL DS     F                  Screen Columns\n*\nDA#TSOSD_PRMSIZE DS    XL2                Screen primary Screen\nDA#TSOSD_ALTSIZE DS    XL2                Screen Alternate screen\nDA#TSOSD_ATTRIB     EQU   *     0XL4      Terminal Attribute\nDA#TSOSD_AFLAG1     DS    B'00000000'     ..Flag 1\nDA#TSOSD_AFLAG2     DS    B'00000000'     ..Flag 2\n$DA#TSOSD_AF2DBCS   EQU   B'10000000'       ..DBCS?\n$DA#TSOSD_AF2AENG   EQU   B'00000001'       ..American English?\n$DA#TSOSD_AF2KATAK EQU    B'00010001'       ..Katakana?\nDA#TSOSD_AFLAG3     DS    B'00000000'     ..Flag3\n$DA#TSOSD_AF3ASCII7 EQU   B'00000000'       ..ASCII-7 device code\n$DA#TSOSD_AF3ASCII8 EQU   B'00000100'       ..ASCII-8 device code\nDA#TSOSD_AFLAG4     DS    B'00000000'     ..Flag4\n$DA#TSOSD_AF4ASCII EQU    B'00000010'       ..ASCII terminal?\n$DA#TSOSD_AF4QUERY EQU    B'00000001'       ..Queriable terminal?\n*\nDA#TSOSD_STAXR13 DS    F                  Stax R13\nDA#TSOSD_PPL     DS    XL(#PPL)           Mapped by IKJPPL\nDA#TSOSD_PARSECB DS    F                  Event Control Block\nDA#TSOSD_ANS     DS    F                  ANS\nDA#TSOSD_PCL     DS    F                  Parameter Control List\nDA#TSOSD_IOPL    DS    XL(#IOPL)          PUTLINE IOPL\n MNOTE 'DA#TSOSD_PTPB    PUTLINE MF=L             PUTLINE PTPB'\nDA#TSOSD_PTPB    PUTLINE MF=L             PUTLINE PTPB\nDA#TSOSD_PLECB   DS    F                  PUTLINE Event Control Block\nDA#TSOSD_PLNUM   DS    F'1'               PUTLINE number of messages\nDA#TSOSD_PLADR   DS    A                  PUTLINE message address\nDA#TSOSD_RECHEAD DS    F'0'               PUTLINE message heading\nDA#TSOSD_RECOUT DS     CL256              PUTLINE message area\nDA#TSOSD_F1         DS  B'00000000'       Flag 1\n$DA#TSOSD_F1_STAX   EQU B'10000000'       ..STAX performed?\n$DA#TSOSD_F1_FS     EQU B'01000000'       ..Full Screen Mode?\n$DA#TSOSD_F1_PARSEE EQU B'00100000'       ..Parse error?\n                 DS    0F\nDA#TSOSDL        EQU   *-DA#TSOSD         Length of DA#TSOSD\n*\n** \"Fake\" CPPL getmained area\n*\nDA#TSOSF         DSECT ,\nDA#TSOSF_CPPL    DS    XL(#CPPL)          Command Processor Parm List\n*                                         Command buffer\nDA#TSOSF_CBUF_H  DS    CL4                ..Header\nDA#TSOSF_CBUF_B  DS    CL8                ..Body\nDA#TSOSF_CBUFL   EQU   *-DA#TSOSF_CBUF_H  Length of command buffer\nDA#TSOSFL        EQU   *-DA#TSOSF\n MEND ,\n./ ADD NAME=DA#Z00   0100-01266-01266-1821-00038-00038-00000-DAVE\n         MACRO ,\n         DA#Z00 &VAR,                     Variable to process          @\n               &REG=1,                    Register to use              @\n               &CLEAR=NO,                 Clear if not found?          @\n               &CODE=LA,                  ASM to locate field          @\n               &MF=E\n.**********************************************************************\n.***                                                                ***\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.** DA#Zxx macros are used for easy macro coding                     **\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.**                                                                  **\n.**  Locate operand regardless of type, for example:                 **\n.**                                                                  **\n.**  DA#Z00 (2)                                                      **\n.** +LR   R1,R2                                                      **\n.**                                                                  **\n.**  DA#Z00 LABEL                                                    **\n.** +LA   R1,LABEL                                                   **\n.***                                                                ***\n.**********************************************************************\n AIF   ('&VAR' EQ '').EVAR                .Have a variable?\n AIF   ('&VAR'(1,1) EQ '(').CLRPLR        .Register format?\n &CODE &REG,&VAR                          Locate field\n AGO   .CLRPLX                            .Leave\n.CLRPLR ANOP ,                            .Register format found\n AIF   ('&VAR(1)' EQ '&REG').CLRPLX       .Registers match?\n AIF   (&VAR(1) EQ &REG).CLRPLX           .Registers match?\n LR    &REG,&VAR(1)                       Locate field\n.CLRPLX ANOP ,\n MEXIT ,\n.EVAR ANOP ,\n AIF  ('&CLEAR' EQ 'YES').CLRIT\n MNOTE 8,'DA#Z00-01E Missing required operand'\n MEXIT ,\n.CLRIT ANOP ,\n SLR   &REG,&REG                          Operand missing, clear reg.\n MEND\n./ ADD NAME=DA#Z01   0100-01266-01266-1821-00014-00014-00000-DAVE\n MACRO\n DA#Z01 &LABEL\n.**********************************************************************\n.***                                                                ***\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.** DA#Zxx macros are used for easy macro coding                     **\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.**                                                                  **\n.**    GENERATE A LABEL IF THE &LABEL OPERAND IS USED                **\n.***                                                                ***\n.**********************************************************************\n AIF   ('&LABEL' EQ '').MEND\n&LABEL DS 0H\n.MEND MEND\n./ ADD NAME=DA#Z02   0100-01266-01266-1821-00017-00017-00000-DAVE\n MACRO\n DA#Z02 &LABEL,&TEST=YES,&CODE=BNZ\n.**********************************************************************\n.***                                                                ***\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.** DA#Zxx macros are used for easy macro coding                     **\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.**                                                                  **\n.**     GENERATE TEST AND BRANCH IF THE &LABEL VALUE IS SPECIFIED    **\n.***                                                                ***\n.**********************************************************************\n AIF   ('&LABEL' EQ '').MEND\n AIF   ('&TEST' EQ 'NO').TESTX\n LTR   R15,R15\n.TESTX ANOP ,\n &CODE &LABEL\n.MEND MEND\n./ ADD NAME=DA#Z04   0100-01266-01266-1821-00039-00039-00000-DAVE\n MACRO\n DA#Z04 &PARAM,&MF=\n.**********************************************************************\n.***                                                                ***\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.** DA#Zxx macros are used for easy macro coding                     **\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.**                                                                  **\n.** Generate a parameter list (like the CALL macro)                  **\n.***                                                                ***\n.**********************************************************************\n AIF   ('&PARAM' EQ '').CPX\n DA#Z00 &MF(2)                            .Locate variable\n LCLA  &CPLC,&CPLO                        .Declare variables\n&CPLC  SETA  1                            .Initialize to one\n&CPLO  SETA  0                            .Initialize to one\n.CPL   ANOP  ,                            .Loop start\n AIF   ('&PARAM(&CPLC)'(1,1) EQ '(').CPR  .Register Format?\n LA    R15,&PARAM(&CPLC)                  Locate parameter\n ST    R15,&CPLO.(R1)                     Save it into parm list\n AGO   .CPRX\n.CPR   ANOP ,\n ST    &PARAM(&CPLC,1).,&CPLO.(R1)        Save location into parm list\n.CPRX  ANOP ,\n&CPLC  SETA  &CPLC+1                      .Locate next one\n AIF   ('&PARAM(&CPLC)' EQ '').CPE        .Is there another one?\n&CPLO  SETA  &CPLO+4                      .Locate next one\n AGO   .CPL\n.CPE   ANOP  ,                            .Exit from PARAM= processing\n OI    &CPLO.(R1),B'10000000'             Indicate last parm entry\n.CPX   ANOP  ,                            .Exit from PARAM= processing\n.*\n.** Handle MF=(G,?,label)\n.*\n AIF   ('&MF(1)' NE 'G').GENX\n AIF   ('&MF(3)' EQ '').GENX\n&MF(3). EQU &CPLO+4\n.GENX ANOP ,\n MEND ,\n./ ADD NAME=DA#Z05   0100-01266-01266-1821-00015-00015-00000-DAVE\n MACRO\n DA#Z05 &RET\n.**********************************************************************\n.***                                                                ***\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.** DA#Zxx macros are used for easy macro coding                     **\n.** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  **\n.**                                                                  **\n.**  GENERATE A BRANCH IF THE &RET OPERAND IS SPECIFED               **\n.***                                                                ***\n.**********************************************************************\n AIF ('&RET' EQ '').MEND\n BSM   0,&RET\n.MEND ANOP ,\n MEND\n./ ADD NAME=I$EREP   0100-01266-01266-1821-00751-00751-00000-DAVE\n>< ADD NAME=LRS$EIN\n)attr\n /********************************************************************/\n /* Name: LRS$EIN                                                    */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Display information about LOGREC table entry            */\n /********************************************************************/\n $ type(text)   intens(high) color(yellow) caps(off)\n ` type(output) intens(low)  color(turq)   caps(off)\n ~ type(output) intens(low)  color(green)  caps(off)\n \u00a2 type(text)   intens(low)  color(blue)   caps(off)\n \u00ac type(text)   intens(low)  color(blue)   caps(off)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Event Information !-!\n%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +\n+\n\u00a2Dump taken:\n$Date:    `LRSDATEG   `LRSDAY    $Julian:    `LRSDATEJ\n$Time:    `LRSTIME\n\n\u00a2Detail:\n$Type:    `LRSTYPE               $Component: `LRSCOMP\n$JobName: `LRSJOBN               $CSECT:     `LRSCSCT\n$CPU:     `LRSCPU                $Reason:    `LRSREAS\n                                 $LOGREC Seq:`LRSSEQN\n\n`LRSDESC\n\n\n\n\n\u00acHit the%ENTER\u00ackey to return to LOGREC event table\n)init\n .HELP = LRS$T1\n &AMT = PAGE\n)end\n>< ADD NAME=LRS$ETDL\n)attr\n /********************************************************************/\n /* Name: LRS$ETDL                                                   */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Table display for long (more than one line) models      */\n /*          Doesn't have the scan stuff - normal display            */\n /********************************************************************/\n ` type(output) intens(low)  color(turq)   caps(off)\n $ type(output) intens(high) color(yellow) caps(off)\n ~ type(output) intens(low)  color(green)  caps(off) just(asis)\n # type(output) intens(low)  color(blue)   caps(off) just(asis)\n \u00ac type(output) intens(low)  color(green)  caps(off) just(asis)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Events !-!\n%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +\n+\n#LRSRANGE\n+\n\u00acLRST1                                                                       ! !\n\u00acLRST2                                                                       ! !\n\u00acLRST3                                                                       ! !\n)model\n&LRSMOD1\n&LRSMOD2\n)init\n .HELP = LRS$T1\n &AMT = PAGE\n)end\n>< ADD NAME=LRS$ETDS\n)attr\n /********************************************************************/\n /* Name: LRS$ETDS                                                   */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Table display for LOGREC entries (only 1 model line)    */\n /*          Doesn't have the scan stuff - normal display            */\n /********************************************************************/\n ` type(output) intens(low)  color(turq)   caps(off)\n $ type(output) intens(high) color(yellow) caps(off)\n ~ type(output) intens(low)  color(green)  caps(off) just(asis)\n # type(output) intens(low)  color(blue)   caps(off) just(asis)\n \u00ac type(output) intens(low)  color(green)  caps(off) just(asis)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Events !-!\n%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +\n+\n#LRSRANGE\n+\n\u00acLRST1                                                                       ! !\n\u00acLRST2                                                                       ! !\n)model\n&LRSMOD1\n)init\n .HELP = LRS$T1\n &AMT = PAGE\n)end\n>< ADD NAME=LRS$ETSL\n)attr\n /********************************************************************/\n /* Name: LRS$ETSL                                                   */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Table display for long (more than one line) models      */\n /*          This has the scan stuff - keep in sync with LRS$ETDL    */\n /********************************************************************/\n ` type(output) intens(low)  color(turq)   caps(off)\n $ type(output) intens(high) color(yellow) caps(off)\n ~ type(output) intens(low)  color(green)  caps(off) just(asis)\n # type(output) intens(low)  color(blue)   caps(off) just(asis)\n \u00ac type(output) intens(low)  color(green)  caps(off) just(asis)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Events !-!\n%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +\n+\n#LRSRANGE\n+\n\u00acLRST1                                                                       ! !\n\u00acLRST2                                                                       ! !\n\u00acLRST3                                                                       ! !\n)model rows(scan)\n&LRSMOD1\n&LRSMOD2\n)init\n .HELP = LRS$T1\n &AMT = PAGE\n)end\n>< ADD NAME=LRS$ETSS\n)attr\n /********************************************************************/\n /* Name: LRS$ETSS                                                   */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Table display for LOGREC entries (only 1 model line)    */\n /*          This has the scan stuff - keep in sync with LRS$ETDS    */\n /********************************************************************/\n ` type(output) intens(low)  color(turq)   caps(off)\n $ type(output) intens(high) color(yellow) caps(off)\n ~ type(output) intens(low)  color(green)  caps(off) just(asis)\n # type(output) intens(low)  color(blue)   caps(off) just(asis)\n \u00ac type(output) intens(low)  color(green)  caps(off) just(asis)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Events !-!\n%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +\n+\n#LRSRANGE\n+\n\u00acLRST1                                                                       ! !\n\u00acLRST2                                                                       ! !\n)model rows(scan)\n&LRSMOD1\n)init\n .HELP = LRS$T1\n &AMT = PAGE\n)end\n>< ADD NAME=LRS$LOGO\n)attr\n /********************************************************************/\n /* Name: LRS$LOGO                                                   */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Display Logo while we are reading LOGREC file           */\n /********************************************************************/\n # type(output) intens(high) color(yellow) caps(off)\n @ type(output) intens(low)  color(green)  caps(off)\n | type(text)   intens(low)  color(red)\n ~ type(text)   intens(low)  color(turq)   hilite(blink)\n ` type(text)   intens(high) color(green)\n \u00a2 type(text)   intens(high) color(blue)\n \u00ac type(text)   intens(low)  color(turq)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Application#Z    %!-!\n%\n! !   `LL         \u00a2OOOOOOOO  `GGGGGGGG \u00a2RRRRRRRRR `EEEEEEEEEE \u00a2CCCCCCCC      ! !\n! !   `LL\u00ac\\      \u00a2OOOOOOOOOO`GGGGGGGGGG\u00a2RRRRRRRRRR`EEEEEEEEEE\u00a2CCCCCCCCCC     ! !\n! !   `LL\u00ac\\      \u00a2OO\u00ac\\   \u00a2OO`GG\u00ac\\   `GG\u00a2RR\u00ac\\   \u00a2RR`EE\u00ac\\      \u00a2CC\u00ac\\   \u00a2CC\u00ac\\   ! !\n! !   `LL\u00ac\\      \u00a2OO\u00ac\\   \u00a2OO`GG\u00ac\\      \u00a2RR\u00ac\\   \u00a2RR`EE\u00ac\\      \u00a2CC\u00ac\\           ! !\n! !   `LL\u00ac\\      \u00a2OO\u00ac\\   \u00a2OO`GG\u00ac\\      \u00a2RRRRRRRRRR`EEEEEE\u00ac   \u00a2CC\u00ac\\           ! !\n! !   `LL\u00ac\\      \u00a2OO\u00ac\\   \u00a2OO`GG\u00ac\\`GGGGG\u00a2RRRRRRRRR `EEEEEE\u00ac\\  \u00a2CC\u00ac\\           ! !\n! !   `LL\u00ac\\      \u00a2OO\u00ac\\   \u00a2OO`GG\u00ac\\`GGGGG\u00a2RR \u00a2RR\u00ac\\  `EE\u00ac\\\\\\\\   \u00a2CC\u00ac\\           ! !\n! !   `LL\u00ac\\      \u00a2OO\u00ac\\   \u00a2OO`GG\u00ac\\   `GG\u00a2RR\u00ac\\ \u00a2RR\u00ac\\`EE\u00ac\\      \u00a2CC\u00ac\\   \u00a2CC\u00ac    ! !\n! !   `LLLLLLLLLL\u00a2OOOOOOOOOO`GGGGGGGGGG\u00a2RR\u00ac\\  \u00a2RR `EEEEEEEEEE\u00a2CCCCCCCCCC\u00ac\\   ! !\n! !   `LLLLLLLLLL\u00a2 OOOOOOOO\u00ac\\`GGGGGGGG \u00a2RR\u00ac\\   \u00a2RR`EEEEEEEEEE \u00a2CCCCCCCC\u00ac\\    ! !\n! !   \u00ac \\\\\\\\\\\\\\\\\\   \\\\\\\\\\\\\\\\   \\\\\\\\\\\\\\\\  \\\\      \\\\ \\\\\\\\\\\\\\\\\\\\  \\\\\\\\\\\\\\\\     ! !\n%\n! ! |Note:#STATUS                                                            ! !\n! !       ~Please be patient: Work in process_OK                             ! !\n%\n@INFO1\n@INFO2\n@INFO3\n@INFO4\n\n)init\n.ZVARS = 'LRSVER'\n)proc\n)end\n>< ADD NAME=LRS$ONLY\n)attr\n /********************************************************************/\n /* Name: LRS$ONLY                                                   */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Allow the user to be prompted when he neglects to enter */\n /*          an operand on the ONLY command.                         */\n /********************************************************************/\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n # type(text) intens(low)  color(green)\n)body\n%----------------------------`ONLY+syntax error%--------------------------------\n%Command%===>_ZCMD\n+\n+You neglected to specify a positional parameter for the`ONLY+command. Please\n+specify a field and value to limit the table display.\n+\n~Field%===>_FIELD   +\n~Value%===>_VALUE\n\n+The~Field+area may be one of the following types:\n`DATE TIME JULIAN RECTYPE JOBNAME REASON MODULE CSECT CPU SEQNO DESC\n+\n+The~Value+area must not be blank\n+\n+\n+If you wish to show all records, change the~Field+to OFF\n+\n+\n+\n+\n+\n+\n+Enter the`ONLY+operands or hit the%END+key to terminate`ONLY+request.\n)init\n &field = ''\n &value = ''\n)proc\n ver (&field,list,DATE,TIME,JULIAN,RECTYPE,JOBNAME,REASON,MODULE,CSECT,CPU,\n                  SEQNO,DESC,DESCRIPTION,OFF)\n if (&field \u00ac= 'OFF')\n    ver (&value,nonblank)\n)end\n>< ADD NAME=LRS$STD\n)attr\n /********************************************************************/\n /* Name: LRS$STD                                                    */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Table display for summary of LOGREC entries             */\n /********************************************************************/\n \u00ac type(output) intens(low)  color(green)  caps(off)\n ~ type(output) intens(high) color(yellow) caps(off)\n ` type(output) intens(low)  color(turq)   caps(off)\n # type(output) intens(low)  color(blue)   caps(off) just(asis)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Event Summary !-!\n%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +\n+\n#LRSRANGE\n+\n\u00acSUMT1\n\u00acSUMT2\n)model\n&SUMMOD1\n)init\n .HELP = LRS$TS1\n &AMT = PAGE\n)end\n>< ADD NAME=LRS$STTD\n)attr\n /********************************************************************/\n /* Name: LRS$ETDS                                                   */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Table display for LOGREC entries (only 1 model line)    */\n /********************************************************************/\n ` type(output) intens(low)  color(turq)   caps(off) just(asis)\n $ type(output) intens(high) color(yellow) caps(off)\n \u00ac type(output) intens(low)  color(green)  caps(off) just(asis)\n # type(output) intens(low)  color(blue)   caps(off) just(asis)\n)body expand(!!) width(&zscreenw)\n%!-! LOGREC Software Event Statistics !-!\n%Command ===>_ZCMD                                         ! !%Scroll ===>_AMT +\n+\n#LRSRANGE\n+\n)model\n\u00acLINE                                                                        ! !\n)init\n .HELP = LRS$TL1\n &AMT = PAGE\n)end\n>< ADD NAME=LRS$TL1\n)attr\n /********************************************************************/\n /* Name: LRS$TL1                                                    */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 1 for statistics table display            */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog Statistics !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n+You are viewing a statistics of the LOGREC table entries by CPU.  This is\n+a nice overview of record types in a matrix.  In addition, if there are any\n+records in the LOGREC database that we do not handle, they will be listed\n+along with any error messages under the total line.\n+\n+\n~The following commands can be entered on the primary command line.\n+\n@REPORT\n+\n+This command is generates a report consisting of the statistics table into the\n+ISPF list file.\n+\n+\n~There are no line commands for the statistics table display\n+\n+\n+\n+\n+Hit the%END+key to complete this tutorial and return to the statistics table.\n)init\n &ZCMD = &Z\n &CONT = LRS$TS2\n)end\n>< ADD NAME=LRS$TS1\n)attr\n /********************************************************************/\n /* Name: LRS$TS1                                                    */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 1 for summary table display               */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog Summary !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n+You are viewing a summary of the LOGREC table entries.  Each entry in the\n+summary table is a match by`Module CSECT+and`Reason.+Initially the table is\n+sort by descending count.\n+\n+\n~The following commands can be entered on the primary command line.\n+\n@L#value+\n+\n+This command is used to locate a value in the current sort field which is the\n+highlighted field in the table display.  When the date is the sort field,\n+only the gregorian date (like format &ZDATE) is considered.\n+\n@REPORT\n+\n+This command is generates a report consisting of the summary table into the\n+ISPF list file.\n+\n+\n+Hit the%ENTER+key to continue with this tutorial\n)init\n &ZCMD = &Z\n &CONT = LRS$TS2\n)end\n>< ADD NAME=LRS$TS2\n)attr\n /********************************************************************/\n /* Name: LRS$TS2                                                    */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 2 for summary table display               */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog Summary (cont) !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n@SORT#field\n+\n+This command is sorts the tables by a field.  Use the column headings for\n+field names.  Changing the sort field allows locating within that field.\n+\n@STATS+\n+\n+This command is shows statistics on the entries shown as a matrix by CPU\n+and LOGREC entry type.\n+\n~There are no line commands for the summary table.\n+\n+\n+\n+\n+\n+\n+\n+\n+Hit the%END+key to return to the summary table\n)init\n &ZCMD = &Z\n)end\n>< ADD NAME=LRS$T1\n)attr\n /********************************************************************/\n /* Name: LRS$T1                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 1                                         */\n /********************************************************************/\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n # type(text) intens(low)  color(green)\n)body\n%TUTORIAL --------- SOFTLOG - LOGREC Software Event History ----------- TUTORIAL\n%Command ===>_ZCMD\n+\nSOFTLOG provides a facility for examining a data base of system software\nfailures. The data base consists of software, IPL, and EOD records extracted\nfrom`SYS1.LOGREC+ which has a history of the last 31 days.\n\nEach software record documents a system ABEND and contains the`SDWA+(System\nDiagnostic Work Area). Note that records are often created without a\ncorresponding system dump. A flag in the`SDWA+indicates whether or not a system\ndump was requested.\n\nThe display contains one line for each record in the data base.  The entries are\nsorted by date and time.  This makes it easy to obtain a quick overview of all\nproblems which have occurred over a period of time.\n\nThe%scroll+keys may be used to position the display as in Browse.  The initial\ndisplay will be positioned to the current date or at the top of the table if\nthe current date is not in the database.\n\nSee the`EREP+manual for more information on`LOGREC.\n\nHit the%ENTER+key to continue with the Tutorial\n)init\n &ZCMD = &Z\n &CONT = LRS$T2\n)end\n>< ADD NAME=LRS$T2\n)attr\n /********************************************************************/\n /* Name: LRS$T2                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 2                                         */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog - Primary Commands  !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n~The following commands can be entered on the primary command line.\n+\n@DSAVERPT+\n+\n+This command is used to indicate that EREP reports are not to be saved past\n+SOFTLOG sessions.  This is the default option.  EREP reports can be saved\n+via the@SAVERPT+command.\n+\n@L#value+\n+\n+This command is used to locate a value in the current sort field which is the\n+highlighted field in the table display.  When the date is the sort field,\n+only the gregorian date (like format &ZDATE) is considered.\n+\n@LONG+\n+\n+This command is used to change the table display to show all fields available\n+by expanding the entry to two lines.  Use the@SHORT+command to change back.\n+\n+Hit the%ENTER+key to continue with tutorial\n)init\n &ZCMD = &Z\n &CONT = LRS$T3\n)end\n>< ADD NAME=LRS$T3\n)attr\n /********************************************************************/\n /* Name: LRS$T3                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 3                                         */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog - Primary Commands (cont)  !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n@ONLY#field`value\n+\n+This command allows you to display table entries that have the`value+that\n+matches the#field+specified.  For example, if you wanted to display only those\n+table entries that are record type`ABEND+use:@ONLY#RECTYPE`ABEND\n+\n+The@ONLY+command allows you to stack limiting pairs. For example, you\n+could limit the table display entries to job name`TSO,+record type`ABEND+and\n+limited to#CPU`W+use:@ONLY#JOBNAME`TSO#RECTYPE`ABEND#CPU`W\n+\n+Use the table column headings to get the valid#field+names.\n+\n+\n@ONLY#OFF\n+\n+This command turns table display limiting by fields. After this command is\n+entered, all table rows will be displayed.\n+\n+\n+Hit the%ENTER+key to continue with tutorial\n)init\n &ZCMD = &Z\n &CONT = LRS$T4\n)end\n>< ADD NAME=LRS$T4\n)attr\n /********************************************************************/\n /* Name: LRS$T4                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 4                                         */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog - Primary Commands (cont)  !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n@REPORT\n+\n+Generate a report consisting of the table display to the ISPF LIST dataset.\n+The \"LIST\" ISPF command can then be used to retrieve the output which can\n+be sent to a printer or a dataset.  Don't confuse this with the EREP report\n+function. This is a list of the table entries only, not detailed information\n+on the individual entry.\n+\n@SAVERPT+\n+\n+This command is used to indicate that EREP reports are to be saved past\n+SOFTLOG sessions.  EREP reports can be set to be deleted after the SOFTLOG\n+session via the@SAVERPT+command.\n+\n@SORT#field\n+\n+This command is sorts the tables by a field.  Use the column headings for\n+field names.  Changing the sort field allows locating within that field.\n+\n+Hit the%ENTER+key to continue with tutorial\n)init\n &ZCMD = &Z\n &CONT = LRS$T5\n)end\n>< ADD NAME=LRS$T5\n)attr\n /********************************************************************/\n /* Name: LRS$T5                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 5                                         */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog - Primary Commands (cont)  !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n@SHORT\n+\n+Put the ISPF table of entries into a short (one-line) display. The@LONG+\n+command can be used to change the table display to a two line display.\n+\n@STATS+\n+\n+This command is shows statistics on the entries shown as a matrix by CPU\n+and LOGREC entry type.\n+\n@SUM+or@SUMM\n+\n+Show a summary table display of the entries.  This table is by entries which\n+have the same module/component, CSECT and Reason. The count of hits is a\n+valuable tool to help diagnose how serious a problem you have.\n+\n+\n+\n+\n+Hit the%ENTER+key to continue with tutorial (Line commands are next)\n)init\n &ZCMD = &Z\n &CONT = LRS$T6\n)end\n>< ADD NAME=LRS$T6\n)attr\n /********************************************************************/\n /* Name: LRS$T6                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 6                                         */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n \u00ac type(text) intens(high) color(red)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog - Line Commands  !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n~The following line commands can be used on the main table display:\n+\n@S+\n+\n+Select the entry for processing by EREP into a report. The may be more entries\n+other than the one selected if multiple entries occur in the same minute. You\n+will be placed into ISPF browse on the EREP report. When you are browsing the\n+dataset, you can use the following commands:\n     #BPRINT+- Invoke the Rockwell RPRINT function for the browse dataset.\n     #BRCOPY+- Copy the browse dataset    #BRP   +- Print the browse dataset\n+\n@T+\n+\n+Browse the EREP \"TOURIST\" file for control statment information and errors.\n+\n@?+\n+\n+Show all table entry fields available on a single screen\n+\n+Hit the%ENTER+key to continue with this tutorial (field descriptions are next)\n)init\n &ZCMD = &Z\n &CONT = LRS$T7\n)end\n>< ADD NAME=LRS$T7\n)attr\n /********************************************************************/\n /* Name: LRS$T7                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 7                                         */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n \u00ac type(text) intens(high) color(red)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog - Field descriptions !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n~The table entries for each LOGREC record have the following fields:\n+\n@DATE     +The date in gregorian form when the LOGREC record was written\n@TIME     +The time when the LOGREC record was written\n@JULIAN   +The date in IBM Julian format when the LOGREC record was written\n          \u00acNote:+This field is only displayed when in@LONG+display format\n@RECTYPE  +The LOGREC record type:\n          #ABEND  ~- A system error recovery: an ABEND occurred.\n          #EOD    ~- The system was terminated normally under program control\n                  ~  or at the request of an operator.\n          #IPL    ~- The system has gone thru operating system initialization.\n          #LostRec~- The LOGREC dataset was full and there were lost records.\n          #ProgInt~- A system error recovery: a Program Interrupt.\n          #Symptom~- When a module detects a programming failure, it contructs\n                     a symptom record containing a description of the failure.\n@JOBNAME  +The jobname that caused the LOGREC Record to be created. This only\n          +applies to#ABEND+and#ProgInt+records.\n@REASON   +The reason code\n\n+Hit the%ENTER+key to continue with this tutorial\n)init\n &ZCMD = &Z\n &CONT = LRS$T8\n)end\n>< ADD NAME=LRS$T8\n)attr\n /********************************************************************/\n /* Name: LRS$T8                                                     */\n /* Author: David Alcock                                             */\n /* Application: Software LOGREC Application                         */\n /* Purpose: Tutorial page 8                                         */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(high) color(green)\n | type(text) intens(high) color(pink)\n @ type(text) intens(high) color(green)\n ` type(text) intens(high) color(turq)\n ~ type(text) intens(low)  color(turq)\n \u00ac type(text) intens(high) color(red)\n)BODY EXPAND(!!)\n|TUTORIAL !-!  Softlog - Field descriptions (cont) !-!|TUTORIAL\n%Command ===>_ZCMD\n+\n@MODULE   +The module or component that caused the LOGREC record to be written\n@CSECT    +The CSECT that caused the LOGREC record to be written\n@CPU      +The CPU name (if available) or serial number where the LOGREC record\n          +was written.\n@SEQNO    +The software sequence number. This is only for#ABEND+or#ProgInt\n          +records.\n          \u00acNote:+This field is only displayed when in@LONG+display format\n@DESC     +Description of the LOGREC record or the first 128 bytes of the EBCDIC\n          +Variable Recording Area (VRA) of the SDWA from#ABEND+and#ProgInt\n          +records.\n          \u00acNote:+This field is only displayed when in@LONG+display format\n\n\n\n\n\n\n\n+Hit the%ENTER+key to start over with this tutorial\n)init\n &ZCMD = &Z\n &CONT = LRS$T1\n)end\n>< ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 20:05 ON 97/02/25\n./ ADD NAME=WHATDATE 0100-01283-01283-1354-00014-00014-00000-DALCOCK\n/* rexx */\n/*trace i*/\n/*********************************************************************/\n/* This exec invokes Dave's WHATDATE dialog                          */\n/*********************************************************************/\nparse arg ztrail\ndaload = \"IBMUSER.DA.LOAD\"     /* DA$WDATE is asm & linked here */\ndasrc  = \"IBMUSER.DA.SOURCE\"   /* Dave's source library */\naddress ispexec\n\"LIBDEF ISPLLIB DATASET ID('\"daload\"') STACK\"\n\"LIBDEF ISPPLIB DATASET ID('\"dasrc\"') STACK\"\n\"SELECT PGM(DA$WDATE) NEWAPPL(DA) PASSLIB\"\n\"LIBDEF ISPPLIB\"\n\"LIBDEF ISPLLIB\"\n./ ADD NAME=X$ADATA  0100-01266-01266-1821-00028-00028-00000-DAVE\n-- PUT JOBCARD HERE --\n//*********************************************************************\n//***                                                               ***\n//**  SAMPLE JOB TO INVOKE THE HLASM AND ANALYZE THE ADATA FILE      **\n//***                                                               ***\n//*********************************************************************\n//*\n//** ASSEMBLE A DSECT AND GET A ADATA FILE\n//*\n//DA$DATE  EXEC HLASMC,PARM.C='ADATA'\n//C.SYSIN  DD *\n         PRINT DATA\n         PRINT GEN\n         CVT LIST=YES,DSECT=YES\n         END ,\n//C.SYSADATA DD DSN=&&SYSADATA,\n//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),\n//            DISP=(,CATLG),UNIT=SYSTS,\n//            SPACE=(CYL,(5,2),RLSE)\n//*\n//** INVOKE THE BOOTSTRAP PROGRAM TO ANALYZE THE ADATA FILE\n//*\n//SMPADATA EXEC PGM=DA$ADATA\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=FA)\n//REXXOUT  DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=F)\n//SYSUDUMP DD SYSOUT=*\n//SYSADATA DD DISP=SHR,DSN=&&SYSADATA\n./ ADD NAME=X$ASMHA1 0100-01266-01266-1821-00366-00366-00000-DAVE\n//*     - JOB CARD HERE -\n//*********************************************************************\n//***                                                               ***\n//**     MVS Data Area Handbook                                      **\n//***                                                               ***\n//*********************************************************************\n//*\n//DHB      PROC MBR=,APARM=''\n//DAHANDBK EXEC PGM=DA$ASMHA,COND=EVEN,\n//         PARM='NOLOGO,NOCDASH,ASMPARM(NOXREF,NOESD)&APARM'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//REPORT   DD DISP=SHR,DSN=IBMUSER.MVS.DHB(&MBR)\n//ASMIN    DD DDNAME=SYSIN\n//ASMLIB   DD DISP=SHR,DSN=SYS1.MACLIB,UNIT=3390,VOL=SER=ESA43R\n//         DD DISP=SHR,DSN=SYS1.MODGEN,UNIT=3390,VOL=SER=ESA43R\n//ASMPUNCH DD DUMMY\n//ASMLIN   DD DUMMY\n//ASMTERM  DD SYSOUT=*\n//ASMPRINT DD DISP=SHR,DSN=IBMUSER.MVS.ASMLIST(&MBR)\n//ASMUT1   DD UNIT=SYSDA,SPACE=(CYL,(10,5)),DSN=&&SYSUT1\n//DHB      PEND\n//*\n//** Delete old libraries\n//*\n//DEL$OLD  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE 'IBMUSER.MVS.DHB'\n DELETE 'IBMUSER.MVS.ASMLIST'\n SET MAXCC=0\n//*\n//** Allocate new libraries\n//*\n//LOCATE   EXEC PGM=IEFBR14\n//DHB      DD DSN=IBMUSER.MVS.DHB,\n//            DISP=(,CATLG),UNIT=SYSDA,\n//            DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA),\n//            SPACE=(CYL,(15,5,64))\n//ASMLIST  DD DSN=IBMUSER.MVS.ASMLIST,\n//            DISP=(,CATLG),UNIT=SYSDA,\n//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBM),\n//            SPACE=(CYL,(15,5,64))\n//*\n//** Generate Data Area Hand Books for various MVS control blocks.\n//**\n//** The JCL below was modified from Gilbert Saint-flour's file 183\n//** HANDBOOK member at CBT v409 @1996-08-31\n//**\n//** I will be modifying this to do the ISPF PACK to save DASD space.\n//*\n//ACB    EXEC DHB,MBR=ACB\n         IFGACB\n         END\n//ACEE   EXEC DHB,MBR=ACEE\n         IHAACEE\n         END\n//ASCB   EXEC DHB,MBR=ASCB\n         IHAASCB DSECT=YES,LIST=YES\n         END\n//ASVT   EXEC DHB,MBR=ASVT\n         IHAASVT DSECT=YES,LIST=YES\n         END\n//ASSB   EXEC DHB,MBR=ASSB\n         IHAASSB LIST=YES\n         END\n//ASXB   EXEC DHB,MBR=ASXB\n         IHAASXB DSECT=YES,LIST=YES\n         END\n//ATTACH EXEC DHB,MBR=ATTACH\n         IEZATTCH LIST=YES\n         END\n//BASEA  EXEC DHB,MBR=BASEA\n         IEEBASEA\n         END\n//CDE    EXEC DHB,MBR=CDE\n         IHACDE\n         END\n//CSCB   EXEC DHB,MBR=CSCB\n         IEECHAIN\n         END\n//CSD    EXEC DHB,MBR=CSD\n         IHACSD DSECT=YES\n         END\n//CVT    EXEC DHB,MBR=CVT\n         CVT DSECT=YES,LIST=YES,PREFIX=YES\n         END\n//DCB    EXEC DHB,MBR=DCB\n         DCBD  DSORG=PS\n         END\n//DCBDA  EXEC DHB,MBR=DCBDA\n         DCBD  DSORG=DA\n         END\n//DCE    EXEC DHB,MBR=DCE\n         IECDDCE\n         END\n//DECB   EXEC DHB,MBR=DECB\n         IHADECB DSECT=YES\n         END\n//DFA    EXEC DHB,MBR=DFA\n         IHADFA DSECT=YES\n         END\n//DSAB   EXEC DHB,MBR=DSAB\n         IHADSAB\n         END\n//DSCB1  EXEC DHB,MBR=DSCB1\nDSCB1    DSECT ,\n         IECSDSL1 1\n         END\n//DSCB4  EXEC DHB,MBR=DSCB4\nDSCB4    DSECT ,\n         DS    44X'04'\n         IECSDSL1 4\n         END\n//DYNALL EXEC DHB,MBR=DYNALLOC\n*STATUS      OLD=01   MOD=02    NEW=04    SHR=08\n*DISP    UNCATLG=01 CATLG=02 DELETE=04   KEEP=08\n*SPACE                ALX=02   MXIG=04 CONTIG=08\n*LABEL        NL=01    SL=02    NSL=04            SUL=0A\n*             BLP=10  LTM=21     AL=40    AUL=48\n         IEFZB4D0\n         IEFZB4D2\n         END\n//DEB    EXEC DHB,MBR=DEB\n         IEZDEB LIST=YES\n         END\n//DVA    EXEC DHB,MBR=DVA\n         IHADVA DSECT=YES\n         END\n//DVCT   EXEC DHB,MBR=DVCT\n         IHADVCT DSECT=YES\n         END\n//ECT    EXEC DHB,MBR=ECT\n         IKJECT\n         END\n//ECVT   EXEC DHB,MBR=ECVT\n         IHAECVT LIST=YES\n         END\n//EPIE   EXEC DHB,MBR=EPIE\n         IHAEPIE\n         END\n//GDA    EXEC DHB,MBR=GDA,APARM=',NAMEL=24'\n         IHAGDA\n         END\n//IOB    EXEC DHB,MBR=IOB\n         IEZIOB DSECT=YES\n         END\n//IOCOM  EXEC DHB,MBR=IOCOM\n         IECDIOCM\n         END\n//JCT    EXEC DHB,MBR=JCT\nJCT      DSECT\n         IEFAJCTB\n         END\n//JCTX   EXEC DHB,MBR=JCTX\nJCTX     DSECT\n         IEFJCTX\n         END\n//JESCT  EXEC DHB,MBR=JESCT\n         IEFJESCT\n         END\n//JFCB   EXEC DHB,MBR=JFCB\nJFCB     DSECT\n         IEFJFCBN LIST=YES\n         END\n//JMR    EXEC DHB,MBR=JMR\n         IEFJMR\n         END\n//JSAB   EXEC DHB,MBR=JSAB\n         IAZJSAB LIST=YES\n         END\n//JSCB   EXEC DHB,MBR=JSCB\n         IEZJSCB\n         END\n//JSCVT  EXEC DHB,MBR=JSCVT\n         IEFJSCVT\n         END\n//LCCA   EXEC DHB,MBR=LCCA\n         IHALCCA DSECT=YES,LIST=YES\n         END\n//LCT    EXEC DHB,MBR=LCT\nLCT      DSECT ,\n         IEFALLCT\n         END\n//LDA    EXEC DHB,MBR=LDA\n         IHALDA\n         END\n//LLE    EXEC DHB,MBR=LLE\n         IHALLE\n         END\n//LPDE   EXEC DHB,MBR=LPDE\n         IHALPDE\n         END\n//LWA    EXEC DHB,MBR=LWA\n         IKJEFLWA\n         END\n//OCE    EXEC DHB,MBR=OCE\nOCE      DSECT ,\n         IECDSECS\n         IECDSECT\n         END\n//OUCB   EXEC DHB,MBR=OUCB\n         IRAOUCB DSECT=YES\n         END\n//PCCA   EXEC DHB,MBR=PCCA\n         IHAPCCA DSECT=YES\n         END\n//PDS2   EXEC DHB,MBR=PDS2\n         IHAPDS DSECT=YES,PDSBLDL=YES\n         END\n//PSA    EXEC DHB,MBR=PSA\n         IHAPSA DSECT=YES,LIST=YES\n         END\n//PSCB   EXEC DHB,MBR=PSCB\n         IKJPSCB\n         END\n//RCE    EXEC DHB,MBR=RCE\n         IARRCE  ,              RSM CONTROL AND ENUMERATION AREA\n         END\n//RD     EXEC DHB,MBR=RD\n         IHARD   ,              REGION DESCRIPTOR\n         END\n*/SAMB   EXEC DHB,MBR=SAMB\n*        IGGSAMB DSECT=YES\n*        END\n//RB     EXEC DHB,MBR=RB\n         IKJRB DSECT=YES,LIST=YES\n         END\n//REXX   EXEC DHB,MBR=REXX,APARM=',NAMEL=24'\n         IRXARGTB\n         IRXCMPTB ,            COMPILER TABLE TSO/E 2.3.1\n         IRXDSIB\n         IRXEFPL\n         IRXENVB               ENVIRONMENT BLOCK\n         IRXENVT               ENVIRONMENT TABLE (IRXANCHR)\n         IRXEVALB\n         IRXEXECB\n         IRXEXTE\n         IRXFPDIR\n         IRXINSTB\n         IRXMODNT\n         IRXPACKT\n         IRXPARMB\n         IRXSHVB\n         IRXSUBCT\n         IRXWORKB\n         END\n//RIB    EXEC DHB,MBR=RIB\n         ISGRIB\n         END\n//RPL    EXEC DHB,MBR=RPL\n         IFGRPL\n         IDARMRCD ,                RECORD MGMT ERROR CODES\n         END\n//SCA    EXEC DHB,MBR=SCA\n         IHASCA\n         END\n//SCB    EXEC DHB,MBR=SCB\n         IHASCB DSECT=YES\n         END\n//SCT    EXEC DHB,MBR=SCT\nSCT      DSECT\n         IEFASCTB\n         END\n//SCTX   EXEC DHB,MBR=SCTX\n         IEFSCTX DSECT=YES\n         END\n//SCVT   EXEC DHB,MBR=SCVT\n         IHASCVT DSECT=YES,LIST=YES\n         END\n//SDWA   EXEC DHB,MBR=SDWA\n         IHASDWA DSECT=YES,VRAMAP=YES\n         END\n//SIOT   EXEC DHB,MBR=SIOT\nSIOT     DSECT\n         IEFASIOT\n         END\n//SMCA   EXEC DHB,MBR=SMCA\n         IEESMCA\n         END\n//SNAP   EXEC DHB,MBR=SNAP\n         IHASNAP DSECT=YES\n         END\n//SPIE   EXEC DHB,MBR=SPIE\n         IHASCA                 SPIE/ESPIE CONTROL AREA\n         IHAEPIE                EXTENDED PROGRAM INTERRUPT ELEMENT\n         IHAPIE                 PROGRAM INTERRUPT ELEMENT\n         IHAPICA                PROGRAM INTERRUPTION CONTROL AREA\n         END\n//SPQE   EXEC DHB,MBR=SPQE\n         IHASPQE                SP Q ELEMENT\n         IHAFBQE                FREE BLOCK\n         IHASPQA                SP Q DESCRIPTOR\n         IHADQE                 DESCRIPTOR Q ELEMENT\n         IHAFQE                 FREE Q ELEMENT\n         IHASPT                 CSA\n         END\n//SSOB   EXEC DHB,MBR=SSOB\n         IEFJSSOB (AL,SO)\n         END\n//SSIB   EXEC DHB,MBR=SSIB\n         IEFJSSIB\n         END\n//SSSA   EXEC DHB,MBR=SSSA\n         IEFSSSA\n         END\n//SSVT   EXEC DHB,MBR=SSVT\n         IEFJSSVT\n         END\n//STCB   EXEC DHB,MBR=STCB\n         IHASTCB LIST=YES\n         END\n//SVT    EXEC DHB,MBR=SVT\n         IHASVT LIST=YES\n         END\n//SWB    EXEC DHB,MBR=SWB\n         IEFSWB\n         END\n//TAXE   EXEC DHB,MBR=TAXE\n         IKJTAXE\n         END\n//TCAS   EXEC DHB,MBR=TCAS\n         IKTTCAST DSECT=YES\n         END\n//TCB    EXEC DHB,MBR=TCB\n         IKJTCB DSECT=YES,LIST=YES\n         END\n//TCT    EXEC DHB,MBR=TCT\n         IEFTCT\n         END\n//TIOT   EXEC DHB,MBR=TIOT\nTIOT     DSECT\n         IEFTIOT1\n         END\n//TMPWA  EXEC DHB,MBR=TMPWA\n         IKJTMPWA\n         END\n//TPC    EXEC DHB,MBR=TPC\n         IEAVVTPC\n         END\n//TQE    EXEC DHB,MBR=TQE\n         IHATQE\n         END\n//TSB    EXEC DHB,MBR=TSB\n         IKJTSB LIST=YES,EXT=YES\n         END\n//TSVT   EXEC DHB,MBR=TSVT\n         IKJTSVT\n         END\n//UCB    EXEC DHB,MBR=UCB\n**       IEFUCBOB LIST=YES,PREFIX=YES,SSMD=YES\n         IEFUCBOB LIST=YES,PREFIX=YES\n         END\n//UCM    EXEC DHB,MBR=UCM\n         IEECUCM LIST=YES,DSECT=YES\n         END\n//UPT    EXEC DHB,MBR=UPT\n         IKJUPT\n         END\n//VLD    EXEC DHB,MBR=IGDVLD\n         IGDVLD\n         END\n//XL     EXEC DHB,MBR=XL\n         IHAXTLST\n         END\n./ ADD NAME=X$ASMHA2 0100-01266-01266-1821-00071-00071-00000-DAVE\n//* - PUT JOB CARD HERE -\n//*\n//** ASSEMBLE THE DA$ASMHA PROGRAM (GOOD BECAUSE IT HAS SOME\n//** INSTRUCTIONS THAT TRY TO LOOK/MODIFY LOW CORE WHICH OCCUR\n//** BECAUSE OF MISSING COMMAS AND THE LIKE).  THE //PASS3 OUTPUT\n//** SHOULD SHOW YOU THE BAD INSTRUCTIONS AS IEV$P3 (PASS 3) MESSAGES.\n//*\n//ASMH    EXEC ASMHC\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//SYSPUNCH DD DUMMY\n//SYSPRINT DD DSN=&&ASMLIST,DISP=(NEW,PASS),UNIT=VIO,\n//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBM),\n//            SPACE=(TRK,(15,15))\n//SYSIN    DD DISP=SHR,DSN=IBMUSER.DA.SOURCE(DA$ASMHA)\n//*\n//** INVOKE DA$ASMHA WITH DEFAULT -AND- PASS3 FILE\n//**\n//** HINT: LOOK FOR IEV$P3 MESSAGES!!!!\n//*\n//SAMP1   EXEC PGM=DA$ASMHA\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST\n//SYSPRINT DD SYSOUT=*\n//PASS3    DD SYSOUT=*              <- MODIFIED ASSEMBLER H LISTING\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD SYSOUT=*\n//*\n//** INVOKE DA$ASMHA WITH DEFAULT -AND- PASS3 FILE -AND- SHOWING\n//** THE STARTING ADDRESS MODE (GOOD FOR DEBUGGING AND LOOKING AT\n//** DUMPS)\n//*\n//SAMP2   EXEC PGM=DA$ASMHA,\n//        PARM='ADDR=0000FC00'      <- PUT PROGRAM EPA HERE\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST\n//SYSPRINT DD SYSOUT=*\n//PASS3    DD SYSOUT=*              <- MODIFIED ASSEMBLER H LISTING\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD SYSOUT=*\n//*\n//** INVOKE DA$ASMHA AND CREATE DATA AREA HANDBOOKS\n//*\n//SAMP3   EXEC PGM=DA$ASMHA\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST\n//SYSPRINT DD SYSOUT=*\n//INDEX    DD SYSOUT=*              <- INDEX OF DSECTS IN DHB!\n//REPORT   DD SYSOUT=*              <- DATA AREA HANDBOOKS\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD SYSOUT=*\n//*\n//** INVOKE DA$ASMHA AND CREATE DCF OUTPUT\n//*\n//SAMP4   EXEC PGM=DA$ASMHA,PARM='DCF'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*              <- DCF OUTPUT HERE\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD SYSOUT=*\n//*\n//** ABENDED: NO WAY, I DON'T WRITE PROGRAMS THAT ABEND!\n//*\n//PRINTIT EXEC PGM=IEBGENER,COND=ONLY\n//SYSUT1   DD DISP=SHR,DSN=&&ASMLIST\n//SYSUT2   DD SYSOUT=*\n//SYSPRINT DD DUMMY\n//SYSIN    DD DUMMY\n//\n./ ADD NAME=X$BRODC1 0100-01266-01266-1821-00012-00012-00000-DAVE\n// -PUT JOBCARD HERE-\n//*\n//** SCAN SYS1.BRODSCAN AND REPORT ON USAGE\n//*\n//JUSTDOIT EXEC PGM=DA$BRODC\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//BRODCAST DD DISP=SHR,DSN=SYS1.BRODCAST,\n//            DCB=BUFNO=16\n//SYSPRINT DD SYSOUT=*\n//INDEX    DD SYSOUT=*\n//MAIL     DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n./ ADD NAME=X$BRODC2 0100-01266-01266-1821-00031-00031-00000-DAVE\n//*\n//** SCAN SYS1.BRODSCAN, REPORT ON USAGE, AND SAVE LOST MAIL\n//*\n//JUSTDOIT EXEC PGM=DA$BRODC\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//BRODCAST DD DISP=SHR,DSN=SYS1.BRODCAST,\n//            DCB=BUFNO=16\n//*           UNIT=3390,VOL=SER=VOLUME\n//*\n//SYSPRINT DD SYSOUT=*\n//INDEX    DD SYSOUT=*\n//MAIL     DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD SYSOUT=*      FORCE IBM (NORMAL) DUMP\n//*\n//BKLIDS   DD DISP=SHR,DSN=ACF.PRI.BKLIDS           ** OPTIONAL **\n//*\n//IEBUPDTE DD DSN=&&UPDTE,                          ** OPTIONAL **\n//            DISP=(,PASS),UNIT=SYSDA,\n//            DCB=(LRECL=80,BLKSIZE=6320,RECFM=FB),\n//            SPACE=(CYL,(2,2),RLSE)\n//*\n//** PROCESS THE IEBUPDTE INPUT RECORDS AND CREATE PDS WITH MAIL...\n//*\n//UPDATE   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DSN=SYS2.LOSTMAIL,\n//            DISP=(,CATLG),UNIT=SYSTS,\n//            DCB=(LRECL=80,BLKSIZE=23200,RECFM=FB),\n//            SPACE=(TRK,(30,15,64),RLSE)\n//SYSIN    DD DISP=(OLD,DELETE),DSN=&&UPDTE\n./ ADD NAME=X$BRODC3 0100-01266-01266-1821-00057-00057-00000-DAVE\n/*********************************************************************\n*                                                                    *\n* Name: LOSTMAIL                                                     *\n*                                                                    *\n* Author: David Alcock :: davea@planetmvs.com                        *\n*                                                                    *\n* Purpose: Show mail lost when SYS1.BRODCAST was reformated. The     *\n*          PDS was created from output from the DA$BRODC utility     *\n*                                                                    *\n*********************************************************************/\n\narg user\nif user == \"\" then user = sysvar(sysuid)\ndsn = \"'SYS2.LOSTMAIL(\"strip(user)\")'\"\n\nif SYSVAR(SYSISPF) <> 'ACTIVE' then do\n\n   /* if you don't have the LIST command, put a error message\n      here and an exit */\n\n   say \"Using the LIST command, type 'QUIT' to end after\" ,\n       \"hitting enter\"\n   address TSO \"LIST \"dsn  /* Invoke Applied Software's LIST */\n   exit\n   end\n\ncall Browse_Dataset\n\nexit\n\n/*********************************************************************\n*  Browse the dataset in variable DSN and handle error conditions    *\n*********************************************************************/\n\nBrowse_Dataset:\nx = LISTDSI(dsn)\n\nif x = 0 then do\n   address ISPEXEC \"CONTROL ERRORS RETURN\"\n   address ISPEXEC \"CONTROL DISPLAY SAVE\"\n   address ISPEXEC \"BROWSE DATASET(\"dsn\")\"\n   br_rc = rc\n   if br_rc <> 0 then do\n      zedsmsg = \"No Mail\"\n      zedlmsg = \"No mail for user: \"user\n      address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      end\n   address ISPEXEC \"CONTROL DISPLAY RESTORE\"\n   address ISPEXEC \"CONTROL ERRORS CANCEL\"\n   end\nelse do\n     zedsmsg = \"No Mail\"\n     zedlmsg = \"No mail for user: \"user\n     address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n     end\n\nreturn\n./ ADD NAME=X$COBR   0100-01266-01266-1821-00014-00014-00000-DAVE\n//*********************************************************************\n//***                                                               ***\n//**   TELL ME EVERYTHING ABOUT A COBOL MODULE'S COMPILE OPTIONS     **\n//***                                                               ***\n//*********************************************************************\n//SOURCEC  EXEC PGM=DA$COBR,PARM='COBEMAIL'\n//*\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DAVE.LOAD\n//         DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//*\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//\n./ ADD NAME=X$DISKR  0100-01266-01266-1821-00028-00028-00000-DAVE\n- JOB CARD HERE -\n//*\n//** DISK REPORTING UTILITY\n//*\n//DASDCONF EXEC PGM=DA$DISKR,DPRTY=(15,15),TIME=1439\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//VATLST   DD DISP=SHR,DSN=SYS1.PARMLIB(VATLST00)\n//*\n//SYSPRINT DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=133,RECFM=FBA)\n//REPORT   DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)\n//VTOCRPT  DD SYSOUT=*,DCB=(LRECL=133,BLKSIZE=1330,RECFM=FBA)\n//SYSUDUMP DD SYSOUT=*\n//*\n//WRKFILE1 DD DISP=(,PASS),DSN=&&WRKFILE1,UNIT=SYSDA,\n//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),\n//            SPACE=(CYL,(5,5))\n//WRKFILE2 DD DISP=(,PASS),DSN=&&WRKFILE2,UNIT=SYSDA,\n//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),\n//            SPACE=(CYL,(20,20))\n//WRKFILE3 DD DISP=(,PASS),DSN=&&WRKFILE3,UNIT=SYSDA,\n//            DCB=(LRECL=512,BLKSIZE=5120,RECFM=FB),\n//            SPACE=(CYL,(20,20))\n//WRKFILE4 DD DISP=(,PASS),DSN=&&WRKFILE4,UNIT=SYSDA,\n//            DCB=(LRECL=80,BLKSIZE=80,RECFM=FB),\n//            SPACE=(CYL,(5,5))\n//WRKFILE5 DD DISP=(,PASS),DSN=&&WRKFILE5,UNIT=SYSDA,\n//            DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA),\n//            SPACE=(CYL,(5,5))\n./ ADD NAME=X$EREP   0100-01266-01266-1821-00106-00106-00000-DAVE\n//*********************************************************************\n//***                                                               ***\n//**    GET LOGREC ENTRIES FROM THE CURRENTLY ACTIVE LOGRECS         **\n//***                                                               ***\n//*********************************************************************\n//*\n//** CURRENT LOGREC ON SYSTEM SMFID=XYZ1\n//*\n//LR$XYZ1  EXEC PGM=IFCEREP1,\n//         REGION=4096K,\n//         PARM=('ZERO=N,ACC=Y,TABSIZE=256K,LINECT=60,TYPE=OTIEDHS',\n//         'DEV=(N3725,N2501,N3211),PRINT=PS')\n//SERLOG   DD DISP=SHR,DSN=SYS1.LOGREC,\n//            UNIT=SYSALLDA,VOL=SER=XA1CAT <- XYZ1\n//ACCDEV   DD DSN=&&LRXYZ1,UNIT=SYSDA,\n//            DISP=(,PASS,DELETE),\n//            SPACE=(CYL,(2,2),RLSE),\n//            DCB=(RECFM=VB,BLKSIZE=6144,LRECL=2000)\n//TOURIST  DD SYSOUT=*,DCB=BLKSIZE=133\n//EREPPT   DD SYSOUT=*,DCB=BLKSIZE=133\n//SRSUDUMP DD SYSOUT=*\n//SYSIN    DD DUMMY\n//*\n//** CURRENT LOGREC ON SYSTEM SMFID=XYZ5\n//*\n//LR$XYZ5  EXEC PGM=IFCEREP1,\n//         REGION=4096K,\n//         PARM=('ZERO=N,ACC=Y,TABSIZE=256K,LINECT=60,TYPE=OTIEDHS',\n//         'DEV=(N3725,N2501,N3211),PRINT=PS')\n//SERLOG   DD DISP=SHR,DSN=SYS1.LOGREC,\n//            UNIT=SYSALLDA,VOL=SER=SYS5C1 <- XYZ5\n//ACCDEV   DD DSN=&&LRXYZ5,UNIT=SYSDA,\n//            DISP=(,PASS,DELETE),\n//            SPACE=(CYL,(2,2),RLSE),\n//            DCB=(RECFM=VB,BLKSIZE=6144,LRECL=2000)\n//TOURIST  DD SYSOUT=*,DCB=BLKSIZE=133\n//EREPPT   DD SYSOUT=*,DCB=BLKSIZE=133\n//SYSUDUMP DD SYSOUT=*\n//SYSIN    DD DUMMY\n//*********************************************************************\n//***                                                               ***\n//* CAPTURE THE LAST 31 DAYS OF SOFTWARE RECORDS FOR SOFTLOG PROCES   *\n//***                                                               ***\n//*********************************************************************\n//*\n//** CREATE A DATE CARD RANGE TO LIMIT LOGREC\n//*\n//SOFTLOGR EXEC PGM=IKJEFT01,PARM='%EREP31D'\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC  DD DISP=SHR,DSN=IBMUSER.DAVE.EXEC\n//DATEDD   DD DISP=(,PASS),UNIT=SYSDA,DSN=&&DATE,SPACE=(TRK,1),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=0)\n//SYSTSIN  DD DUMMY,DCB=BLKSIZE=80\n//*\n//** INVOKE EREP TO GET THE LAST 30 DAYS FROM THE MONTHLY TAPE\n//*\n//SOFTLOGT EXEC PGM=IFCEREP1,REGION=6000K,\n// PARM='CARD'\n//SYSUDUMP DD SYSOUT=*\n//ACCIN    DD DISP=SHR,DSN=DS.LOGREC1(-1)\n//         DD DISP=SHR,DSN=DS.LOGREC1(0)\n//ACCDEV   DD DISP=(NEW,PASS),DSN=&&SOFTLOG,\n//            UNIT=SYSDA,\n//            DCB=(RECFM=VB,LRECL=2000,BLKSIZE=2004),\n//            SPACE=(TRK,(300,300))\n//DIRECTWK DD UNIT=SYSDA,SPACE=(CYL,(30,15),,CONTIG)\n//TOURIST  DD SYSOUT=*\n//SYSIN    DD *\nLINECT=60\nTABSIZE=900K\nACC=Y\nHIST=Y\nPRINT=NO\nTYPE=SIE\nZERO=N\n//   DD DISP=(OLD,DELETE),DSN=&&DATE\n//EREPPT DD DUMMY\n//*********************************************************************\n//***                                                               ***\n//** MERGE THE HISTORY LOGREC WITH THE CURRENT LOGREC ENTRIES        **\n//***                                                               ***\n//*********************************************************************\n//*\n//** DELETE EXISTING SOFTLOG LIBRARY\n//*\n//SOFTLOGD EXEC PGM=IEFBR14\n//ACCDEV   DD DSN=SYS9.SYS.LOGREC.SOFTLOG,UNIT=SYSALLDA,\n//            DISP=(MOD,DELETE,DELETE),\n//            SPACE=(TRK,(300,300),RLSE)\n//*\n//** SORT SOFTLOG LIBRARY\n//*\n//SOFTLOGS EXEC PGM=SORT,REGION=4000K\n//SORTIN   DD DISP=(OLD,DELETE,DELETE),DSN=&&SOFTLOG\n//         DD DISP=(OLD,DELETE,DELETE),DSN=&&LRXYZ1\n//         DD DISP=(OLD,DELETE,DELETE),DSN=&&LRXYZ5\n//SORTOUT  DD DISP=(NEW,CATLG,DELETE),DSN=SYS9.SYS.LOGREC.SOFTLOG,\n//            UNIT=3380,VOL=SER=XA1CAT,\n//            DCB=(RECFM=VB,LRECL=2000,BLKSIZE=2004),\n//            SPACE=(TRK,(300,300),RLSE)\n//SYSOUT   DD SYSOUT=*\n//SORTMSG  DD SYSOUT=*\n//SYSIN    DD *\n         SORT  FIELDS=(14,7,BI,A),FILSZ=E3100,DYNALLOC=SYSDA\n         RECORD LENGTH=(,,,,500)\n/*\n./ ADD NAME=X$EREPU  0100-01266-01266-1821-00008-00008-00000-DAVE\n// JOB CARD HERE\n//UPDATE   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DSN=ibmuser.EREP.PANELS,\n//            DISP=(,CATLG),UNIT=SYSTS,\n//            DCB=(LRECL=80,BLKSIZE=8800,RECFM=FB),\n//            SPACE=(TRK,(5,5,8))\n//SYSIN    DD DISP=SHR,DSN=ibmuser.DA.SOURCE(I$EREP)\n./ ADD NAME=X$IDC    0100-01266-01266-1821-00013-00013-00000-DAVE\n//*\n//** IDCAMS POST PROCESSOR\n//*\n//IDCAMS   EXEC PGM=DA$IDC\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//RECAP    DD SYSOUT=*        DA$IDC: Recap of IDCAMS\n//*DATAONLY DD DUMMY          DA$IDC: NO HEADINGS ON //RECAP?\n//ERROR    DD SYSOUT=*        DA$IDC: Error code\n//*//$$DEBUG  DD SYSOUT=*     DA$IDC: Debugging mode\n//SYSUDUMP DD SYSOUT=*\n//SYSIN    DD *\n LISTCAT LEVEL('SYS1') ALL\n./ ADD NAME=X$PDSR   0100-01266-01266-1821-00161-00161-00000-DAVE\n- JOB CARD HERE -\n//* SAMPLE INVOCATIONS OF DA$PDSR.  THIS JOBSTREAM DOES NOT EXERCISE\n//* ALL OF THE OPTIONS BUT WILL GET YOU STARTED.  USE THE PARM=HELP\n//* EXAMPLE TO SEE ALL OF THE OPTIONS AVAILABLE.\n//*********************************************************************\n//***                                                               ***\n//**   DO LINKAGE AND ISPF STATISTICS REPORT FOR ALL DDNAMES         **\n//**   WHICH BEGIN WITH SYSLIB                                       **\n//***                                                               ***\n//*********************************************************************\n//STATS    EXEC PGM=DA$PDSR\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*\n//SYSLIB00 DD DISP=SHR,DSN=SYS1.PARMLIB    <- ISPF STATS\n//SYSLIB01 DD DISP=SHR,DSN=SYS1.LINKLIB    <- LOAD LIBRARY INFO\n//*********************************************************************\n//***                                                               ***\n//**   PERFORM A HISTORY AND TRANSLATOR REPORT FOR ALL DDNAMES       **\n//**   WHICH BEGIN WITH SYSLIB, THE DATE FORMAT WILL BE US.          **\n//**                                                                 **\n//**   ADDITIONAL PARAMETERS ARE SPECIFIED IN THE SYSIN FILE RATHER  **\n//**   THAN THE PARM CARD.                                           **\n//**                                                                 **\n//**   THE PDS DIRECTORY ENTRIES WILL BE DUMPED TO SYSPRINT.         **\n//***                                                               ***\n//*********************************************************************\n//TRHIST   EXEC PGM=DA$PDSR,TIME=1439,\n//         PARM='HISTRPT,DATE=US'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//SYSIN    DD *\nTRANRPT,DUMPDIRE\n//*\n//TRANRPT  DD SYSOUT=*\n//HISTRPT  DD SYSOUT=*\n//BINDEROU DD DUMMY\n//BINDERPR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*\n//SYSLIB01 DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//*\n//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)\n//*********************************************************************\n//***                                                               ***\n//**   PERFORM A HISTORY AND TRANSLATOR REPORT FOR ALL DDNAMES       **\n//**   WHICH BEGIN WITH SYSLIB. ONLY THE MEMBERS THAT BEGIN WITH     **\n//**   \"IEF\" WILL BE PROCESSED.                                      **\n//***                                                               ***\n//*********************************************************************\n//TRHISTSE EXEC PGM=DA$PDSR,TIME=1439,\n//         PARM='HISTRPT,TRANRPT,FINDMEM=IEF*,ONLYFIND'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//*\n//TRANRPT  DD SYSOUT=*\n//HISTRPT  DD SYSOUT=*\n//BINDEROU DD DUMMY\n//BINDERPR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*\n//SYSLIB01 DD DISP=SHR,DSN=SYS1.LINKLIB\n//*\n//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)\n//*\n//*********************************************************************\n//***                                                               ***\n//**   PRINT THE F1-DSCB FOR SYS1.NUCLEUS AS WE PROCESS IT; USE THE  **\n//**   ISODATE FORMAT WHEN DATES ARE SHOWN IN THE REPORT;            **\n//***                                                               ***\n//*********************************************************************\n//NUCLEUS  EXEC PGM=DA$PDSR,PARM='DUMPDSCB,DATE=ISO'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*\n//SYSLIB00 DD DISP=SHR,DSN=SYS1.NUCLEUS\n//*********************************************************************\n//***                                                               ***\n//**   GET A EYECATCHER REPORT FOR ALL LIBRARIES THAT START WITH     **\n//**   SYSLIB                                                        **\n//***                                                               ***\n//*********************************************************************\n//ECRPT    EXEC PGM=DA$PDSR,PARM='ECRPT'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//ECRPT    DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*\n//SYSLIB00 DD DISP=SHR,DSN=SYS1.LPALIB\n//*********************************************************************\n//***                                                               ***\n//**   GET A ZAP REPORT FOR ALL LIBRARIES THAT START WITH            **\n//**   SYSLIB                                                        **\n//***                                                               ***\n//*********************************************************************\n//ZAPRPT   EXEC PGM=DA$PDSR,PARM='ZAPRPT'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//ZAPRPT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*\n//SYSLIB00 DD DISP=SHR,DSN=SYS1.NUCLEUS\n//*********************************************************************\n//***                                                               ***\n//**   SHOW HELP INFORMATION FOR DA$PDSR                             **\n//***                                                               ***\n//*********************************************************************\n//HELP     EXEC PGM=DA$PDSR,PARM='HELP'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*********************************************************************\n//***                                                               ***\n//**   CHECK FOR DUPLICATE MODULES IN THE LINKLIST                   **\n//***                                                               ***\n//*********************************************************************\n//LNKLST   EXEC PGM=DA$PDSR,PARM='LNKLST,CHKDUP,NODETAIL',\n//         TIME=1439\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)\n//*********************************************************************\n//***                                                               ***\n//**   CHECK FOR DUPLICATE MODULES IN THE LPALST                     **\n//***                                                               ***\n//*********************************************************************\n//LPALST   EXEC PGM=DA$PDSR,PARM='LPALST,CHKDUP,NODETAIL',\n//         TIME=1439\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//WRKFILE1 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE2 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,25)\n//WRKFILE3 DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(TRK,15)\n./ ADD NAME=X$PDSRJ  0100-01266-01266-1821-00029-00029-00000-DAVE\n//* - PUT JOB CARD HERE -\n//*********************************************************************\n//***                                                               ***\n//**   THIS JOBSTREAM VERIFIES THAT YOUR JES2 JCL WILL NOT HAVE AN   **\n//**   ERROR AT JES2 STARTUP.  EXECUTING YOUR JES2 JCL THRU DA$PDSR  **\n//**   WILL ENSURE THAT THE JCL IS OKAY AND THAT ALL //PROCXX FILES  **\n//**   CAN BE PROCESSED VIA AN MVS OPEN.                             **\n//**                                                                 **\n//**   YOU *MUST* HAVE A VARIABLE TO ALLOW AN OVERRIDE FOR THE       **\n//**   PROGRAM NAME IN YOUR JES2 PROC.  PROGRAM NAMES CAN NOT BE     **\n//**   OVERRIDEN LIKE OTHER EXEC PARAMETERS.                         **\n//**                                                                 **\n//**   IF YOU DON'T WANT TO ADD A VARIABLE TO YOUR PRODUCTION JES2   **\n//**   PROC, COPY IT INSTREAM AND AT LEAST VERIFY THE PROCLIB        **\n//**   CONCATENATIONS.                                               **\n//**                                                                 **\n//**   EVEN IF YOU DON'T USE DA$PDSR, I WOULD RECOMMEND THAT YOU     **\n//**   RUN YOUR JES2 PROC THRU PGM=IEFBR14, CA-JCLCHECK, ETC WHEN    **\n//**   IT GETS MODIFIED.  YOU ALWAYS WANT JES2 TO START.             **\n//***                                                               ***\n//*********************************************************************\n//JES2     EXEC JES2,\n//         ENTRY='DA$PDSR',                     <- PDS REPORT PROGRAM\n//         PARM='PREFIX=PROC'                   <- READ //PROCXX FILES\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n./ ADD NAME=X$PDSRP  0100-01266-01266-1821-00043-00043-00000-DAVE\n//*********************************************************************\n//***\n//**   THIS JOBSTREAM IS AN EXAMPLE OF RELINKING A MODULE WHEN A\n//**   CSECT IS FOUND.  IN THIS CASE THE PL/I DATE ROUTINE.\n//***\n//*********************************************************************\n//*\n//** EXECUTE DA$PDSR TO GET A CSECT REPORT OUT TO //FLATOUT\n//*\n//SOURCEC  EXEC PGM=DA$PDSR,TIME=1439,\n//         PARM='HISTRPT,TRANRPT,FLATOUT,DATE=ISO'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//TRANRPT  DD DUMMY\n//HISTRPT  DD DUMMY\n//FLATOUT  DD DSN=&&FLATOUT,\n//            DISP=(,CATLG),UNIT=SYSTS,\n//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),\n//            SPACE=(CYL,(50,50),RLSE)\n//BINDEROU DD DUMMY CAN BE SYSOUT=*\n//BINDERPR DD DUMMY\n//*\n//SYSLIB01 DD DISP=SHR,DSN=SEP.PGMLIB\n//*\n//** INVOKE THE PDSE COMMAND FOR EACH MEMBER THAT TO BE RELINKED\n//*\n//IPDS    EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,REGION=9M\n//SYSEXEC  DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//SYSUT1   DD DISP=SHR,DSN=&&FLATOUT\n//SYSUT2   DD DSN=IBMUSER.RELINK.SEP.PGMLIB,\n//            DISP=(,CATLG),UNIT=SYSTS,\n//            DCB=(LRECL=80,BLKSIZE=6320,RECFM=FB),\n//            SPACE=(CYL,(5,5),RLSE)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n %DA$PDSRT IBMBJDT1 SYS2P.SYS.PL1.PLILINK IBMBJDTA\n//JOBCARD  DD *\n //IBMUSERL  JOB  (X,Y,Z,ABC),\n //          'PL/1 RELINK JOB     ',\n //          NOTIFY=IBMUSER,REGION=4M,\n //          MSGCLASS=X,CLASS=U,TIME=1439\n/*\n./ ADD NAME=X$PDSRR  0100-02191-02191-1111-00107-00107-00000-DALCOCK\n.. JOB CARD HERE ..\n//*********************************************************************\n//***\n//**  INVOKE THE DISASSEMBLER TO FIND ALL USAGES OF AN ASSEMBLER\n//**  INSTRUCTION.\n//***\n//*********************************************************************\n//SOURCEC  EXEC PGM=DA$PDSR,TIME=1439,\n//*        PARM='HISTRPT,TRANRPT,FLATOUT'\n//         PARM='HISTRPT,TRANRPT,FLATOUT,FINDMEM=A*,ONLYFIND'\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//REPORT   DD SYSOUT=*\n//TRANRPT  DD SYSOUT=*\n//HISTRPT  DD SYSOUT=*\n//FLATOUT  DD DSN=&&FLATOUT,\n//            DISP=(,PASS),UNIT=SYSDA,\n//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),\n//            SPACE=(CYL,(5,5))\n//BINDEROU DD DUMMY\n//BINDERPR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//*\n//SYSLIB01 DD DISP=SHR,DSN=IBMUSER.DAVE.LOAD\n//*\n//** INVOKE THE DA$PDSRR REXX EXEC TO REPORT ON THE FLATOUT FILE\n//** USES THE HIGH LEVEL ASSEMBLER TOOLKIT DISASSEMBLER\n//*\n//RPTDISH EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,REGION=8M\n//STEPLIB  DD DISP=SHR,DSN=SYS1.SASMMOD2       <- IBM HLASM TOOLKIT\n//SYSEXEC  DD DISP=SHR,DSN=IBMUSER.DAVE.EXEC\n//SYSUDUMP DD SYSOUT=*\n//*\n//FLATIN   DD DISP=(OLD,PASS),DSN=&&FLATOUT\n//SYSPUNCH DD DSN=&&SYSPUNCH,\n//            DISP=(,PASS),UNIT=SYSDA,\n//            SPACE=(CYL,(100,100))\n//SYSPRINT DD DSN=&&SYSPRINT,\n//            DISP=(,PASS),UNIT=SYSDA,\n//            SPACE=(CYL,(100,100))\n//SYSIN    DD DSN=&&SYSIN,\n//            DISP=(,PASS),UNIT=SYSDA,\n//            DCB=(LRECL=80,BLKSIZE=80,RECFM=F),\n//            SPACE=(TRK,(1,1))\n//*\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%DA$PDSRR DISASMT=HLASMT AI=SVC___13_  ECHO\n//\nDELETE SPFTEMP1.FLATOUT\n//*\n//** INVOKE THE DA$PDSRR REXX EXEC TO REPORT ON THE FLATOUT FILE\n//** USES THE CBT TAPE, FILE 171 DISASSEMBLER\n//*\n//RPTDISC EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,REGION=8M,COND=EVEN\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DAVE.LOAD    <- CBT 171 DISASSEMBLER\n//SYSEXEC  DD DISP=SHR,DSN=IBMUSER.DAVE.EXEC\n//*\n//FLATIN   DD DISP=(OLD,PASS),DSN=&&FLATOUT\n//* ------------------------------------------------------------------*\n//*        ASSEMBLER DD'S                                             *\n//* ------------------------------------------------------------------*\n//SYSPRINT DD DSN=&&PRT,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12100)\n//SYSIN    DD DSN=&&IN,DISP=(NEW,PASS),\n//            UNIT=SYSDA,\n//            SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSPUNCH DD DUMMY\n//* ------------------------------------------------------------------*\n//*        DIS-ASSEMBLER DD'S                                         *\n//* ------------------------------------------------------------------*\n//DISPUNCH DD DUMMY\n//DISPRINT DD DSN=&&DISPRINT,\n//            DISP=(,PASS),UNIT=SYSDA,\n//            SPACE=(CYL,(100,100))\n//DISIN    DD DSN=&&DISIN,\n//            DISP=(,PASS),UNIT=SYSDA,\n//            DCB=(LRECL=80,BLKSIZE=80,RECFM=F),\n//            SPACE=(TRK,(1,1))\n//* ------------------------------------------------------------------*\n//*        TSO DD'S                                                   *\n//* ------------------------------------------------------------------*\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n%DA$PDSRR DISASMT=CBT171 AI=SVC___48_ AI=SVC___64_  AI=SVC___56_ ECHO\n//\n%DA$PDSRR DISASMT=CBT171 AI=SVC____11_ AI=STCK\n\n//*\n//** SAVE FLATOUT FILE SO CAN BROWSE OUTPUT\n//*\n//GENFLAT  EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=(OLD,PASS),DSN=&&FLATOUT\n//SYSUT2   DD DSN=IBMUSER.SPFTEMP1.FLATOUT,\n//            DISP=(,CATLG),UNIT=SYSDA,\n//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),\n//            SPACE=(CYL,(5,5))\n//\n./ ADD NAME=X$SPF2D  0100-01266-01266-1821-00059-00059-00000-DAVE\n- JOB CARD HERE -\n//*********************************************************************\n//***                                                               ***\n//**  This job reads a sample ISPF screen and creates an assembler   **\n//**  program to display it using 3270 data stream on TSO.           **\n//***                                                               ***\n//*********************************************************************\n//*\n//** Convert the input ISPF screen to 3270 datastream\n//*\n//SPF2DS   EXEC PGM=DA$SPF2D\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.DA.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//SYSUT1   DD *\n)attr\n /* Sample prototype screen - used in ISPF 7.2 */\n)body\n+xxIPADDR       +        %Company Name here     +                  +TCP/IP v3.1\n\n     +Production         +Test                      +Misc\n+P1 -%CICS(DCC/WTU) +T1 -%CICS (DCC/WTU)    +PROFS -%OfficeVision\n+P2 -%CICS(CPL)     +T2 -%CICS (CPL)        +IP    -%Infopac\n+P3 -%CICS(PSO/TOK) +T3 -%CICS (PSO/TOK)    +TPX   -%Mult-Session Manager\n+P4 -%CICS(SWEPCO)  +T4 -%CICS (SWEPCO)\n+P5 -%IDMS-CV11\n+P6 -%ROSCOE                 +WARNING:%The access to and use of this computer,\n+P7 -%TSO                             %its data and its programs are restricted\n                                      %by a security system.  Any unauthorized\n                                      %access may be a violation of law and\n+Enter Application keyword:           %could result in CRIMINAL PROSECUTION.\n_Input                                                                         +\n)init\n)proc\n)end\n//SYSUT2   DD DSN=IBMUSER.SPFTEMP1.#3270DS,\n//            DISP=(,CATLG),UNIT=SYSTS,\n//            DCB=(LRECL=80,BLKSIZE=6320,RECFM=FB),\n//            SPACE=(CYL,(5,0),RLSE)\n//*\n//** ASSEMBLE AND LINK THE NEWLY CREATED 3270 DATASTREAM SOURCE\n//*\n//DA$PDSR EXEC HLASMCL\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=IBMUSER.DA.SOURCE\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.SPFTEMP1.#3270DS\n//L.SYSLMOD DD DISP=SHR,DSN=IBMUSER.DA.LOAD(#3270DS)\n//*\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//** Now to view on TSO: CALL 'IBMUSER.DA.LOAD(#3270DS)'\n//*\n./ ADD NAME=X$W4TCP  0100-01266-01266-1821-00007-00007-00000-DAVE\n//*\n//** Wait for the \"TCPIP\" stack to come active\n//**\n//** Change \"TCPIP\" to the name of your TCP/IP stack\n//*\n//WAIT4TCP EXEC PGM=DA$W4TCP,PARM='TCPIP'\n//SYSUDUMP DD SYSOUT=*\n./ ADD NAME=Z$DISKR  0100-01266-01266-1821-00032-00032-00000-DAVE\n> CLC   DS1LSTAR,=X'000000'    /* Are all 3-bytes Nulls?     */\n> BE    NOADDONE               /* Empty File                 */\n> ICM   R15,B'0011',DS1LSTAR   /* ICM non-alignd hword (TT)  */\n> CLI   DS1LSTAR+2,X'00'       /* Round up by one?     (R)   */\n> BE    NOADDONE               /* No                         */\n> A     R15,FWD1               /* Add 1 to \"# of Trks\"       */\n> NOADDONE DS    0H                     /* -------------------------- */\n> CVD   R15,DWORD              /* Pack it                    */\n\nSubject:  Re: Space Used\nFrom:  Bruce Black <bblack@FDRINNOVATION.COM>\nDate:  Tue, 24 Jul 2001 15:12:46 -0400\n\nJim Moore wrote:\n\n> CLC   DS1LSTAR,=X'000000'    /* Are all 3-bytes Nulls?     */\n> BE    NOADDONE               /* Empty File                 */\n> ICM   R15,B'0011',DS1LSTAR   /* ICM non-alignd hword (TT)  */\n> CLI   DS1LSTAR+2,X'00'       /* Round up by one?     (R)   */\n> BE    NOADDONE               /* No                         */\n> A     R15,FWD1               /* Add 1 to \"# of Trks\"       */\n\nWarning!  If you have SMS-managed volumes, you might have\nDSORG=PSE (sequential extended format) datasets which can exceed\n64K tracks.  if the extended format flag is on (DS1STRP in\nDS1SMSFG), then DS1TRBAL becomes an additional TT value.  You\nhave to prefix DS1TRBAL onto DS1LSTAR to get a TTTTR value, so\nthat TTTT can exceed 64K.\n\nAlthough other dataset types (VSAM, PDSE and HFS) can exceed 64K\ntracks, even on non-SMS volumes, DS1LSTAR and DS1TRBAL are not\nmaintained for them.\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 18:16 ON 02/11/02\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASRCV": {"ttr": 20225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x01\\x00\\x04\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18C\\x03a\\x03a\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.01", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:43:04", "lines": 865, "newlines": 865, "modlines": 0, "user": "IBMUSER"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "DIVER": {"ttr": 20486, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x01\\x00A\\x00\\x99\\x06\\x0f\\x01\\x020o\\x13C\\x02\\xb9\\x02\\xb4\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.01", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T13:43:41", "lines": 697, "newlines": 692, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 0100-02306-02306-1337-00010-00010-00000-DAVE\nThis is a very useless ISPF applications that shows an animation of a\nstick figure known as \"Mr. Ascii\" diving into a pool.  I did NOT create\nthe artwork.  I only packaged the various \"screens\" into ISPF screens\nwhich are displayed by the $REXX member.  To use:\n\n1) Unload the diver rexx exec and panels into a library\n\n2) Execute the \"DIVER\" DRIVER (rexx exec) from said library, For example:\n\n   EXEC 'ibmuser.SPFTEMP1.DIVER(DIVER)'\n./ ADD NAME=DIVER    0100-02306-02306-1337-00124-00124-00000-DAVE\n/* REXX */\nparse source a b c d dmxlib .  /* Obtain execution lib name */\naddress TSO \"ISPEXEC LIBDEF ISPPLIB DATASET    ID('\"dmxlib\"')\"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER01)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER02)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER03)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER04)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER05)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER06)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER07)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER08)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER09)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER10)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER11)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER12)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER13)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER14)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER15)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER16)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER17)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER18)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER19)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER20)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER21)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER22)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER23)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER24)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER25)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER26)\"\n\"REMPOP\" ; CALL Wait\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER27)\"\n\"REMPOP\" ; CALL Wait\n\"ADDPOP\"\n\"DISPLAY PANEL(DIVER28)\"\n\"REMPOP\" ; CALL Wait\naddress TSO \"ISPEXEC LIBDEF ISPPLIB DATASET\"\nexit 0\n\n/* Here we try to add a short wait */\nWait:\ndo i = 1 to 50000\n   NOP\n   end\nreturn\n./ ADD NAME=DIVER01  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n       o  ___\n       |=/___\\_______\n _____/>/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER02  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n        o\n        |=___\n       /|/___\\_______\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER03  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n           o\n          /|\\\n         //_\\\\_______\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER04  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n            o\n          _/|\\\n         /_/_\\_______\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER05  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n              o\n          ___/|\\\n         /___/_\\_____\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER06  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n               o\n          ___ /|\\\n         /___\\/_\\____\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER07  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n                o\n          ___  /|\\\n         /___\\_/_\\___\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER08  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n                 o\n          ___   /|\\\n         /___\\__/_\\__\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER09  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n                   o\n          ___     /|\\\n         /___\\____/_\\\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER10  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n                    o\n          ___       |=\n         /___\\______|\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER11  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___       o\n         /___\\__    |=\n _______/____|_ ---_>\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER12  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n                    o\n          ___       |=\n         /___\\______>\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER13  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n                      o\n                     /=\n          ___       _>\n         /___\\___---\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER14  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n                        o\n                       /=\n                      /\n          ___\n         /___\\_______\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER15  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n                         __o\n                        /  \\\n          ___\n         /___\\_____\n _______/____|_    --\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER16  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n                         ____o\n          ___                \\\n         /___\\_______\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER17  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n                          __\n          ___               \\o\n         /___\\_______        \\\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER18  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___                \\\n         /___\\_______         \\o\n _______/____|_                \\\n              |\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER19  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______           \\\n _______/____|_                  \\\n              |                  |o\n              |\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER20  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_                  \\|\n              |                   |\n              |                   |o\n              |~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER21  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |                   \\|\n              |                  ' |..'\n              |~~~~~~~~~~~~~~~~~~~/o'~~~~~~\n\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER22  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |                     .'..''..\n              |                     . .'.' '\n              |~~~~~~~~~~~~~~~~~~~~~~;|/,~~\n                                    _o/\n                                    /\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER23  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |                        . .\n              |                     ..'.'.\n              |~~~~~~~~~~~~~~~~~~~~~~;,;~~~\n                                  _o__/'\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER24  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |\n              |                      . .\n              |~~~~~~~~~~~~~~~~~~~~~~~;~~~~\n                              o__// ''\n                             //\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER25  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |\n              |\n              |~~~~~~~~~~~~o~~~~~~~~~~~~~~~\n                           |\\__\n                             \\\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER26  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |\n              |          o\n              |~~~~~~~~~/|\\~~~~~~~~~~~~~~~~~~\n                        / \\\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER27  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |\n              |          o/\n              |~~~~~~~~~/|~~~~~~~~~~~~~~~~~\n                        / \\\n\n\n\n)init\n)proc\n)end\n./ ADD NAME=DIVER28  0100-02306-02306-1337-00019-00019-00000-DAVE\n)attr default(\u00ac\u00a2$)\n)body window(45,14)\n\n\n\n\n          ___\n         /___\\_______\n _______/____|_\n              |             , Bye!\n              |          o/\n              |~~~~~~~~~/|~~~~~~~~~~~~~~\n                        / \\\n\n\n\n)init\n)proc\n)end\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 13:43 ON 02/11/02\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "D2SEQN": {"ttr": 20743, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00C\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18%\\x00r\\x00r\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:25:43", "lines": 114, "newlines": 114, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: D2SEQN (Death To Sequence Numbers)\n |\n | Author: David Alcock :: dave@planetmvs\n |\n | Purpose: This utility is a filter that copies files from SYSUT1\n |          to SYSUT2 sans sequence numbers.  It will also remove\n |          IBM APAR strings like \"@THX1138\" when found as the\n |          last word on a line.\n |\n |          The primary purpose of this exec is to print source\n |          code without the dang sequence numbers. This makes it\n |          easier to read source code and write comments on the\n |          end of the line.\n |\n |          Hint: This exec can also be used to copy from RECFM=F to\n |          RECFM=V files.\n |\n | Sample JCL:\n |\n |        //PRINT2  EXEC PGM=IKJEFT01,PARM='%D2SEQN',\n |        //        DYNAMNBR=100,REGION=9M,TIME=1439\n |        //SYSTSIN  DD DUMMY\n |        //SYSTSPRT DD SYSOUT=*\n |        //SYSEXEC  DD DISP=SHR,DSN=IBMUSER.DAVE.EXEC\n |        //SYSUT1   DD DISP=SHR,DSN=SYS1.V1R1M0.SHASSRC(HASMMODL)\n |        //SYSUT2   DD SYSOUT=A ,OUTPUT=*.PORTRAIT\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code provided.\n |             It is copyright 1999-2002+ by David Alcock.  All rights\n |             reserved.\n */\n\n/* --------------------------------------------------------------------\n |          M o d i f i c a t i o n   H i s t o r y\n |\n | Person     Date        Description\n | ---------- ----------- ---------------------------------------------\n | DGAlcock   01-MAR-1999 v1.0 Original utility written;\n +------------------------------------------------------------------ */\n\nvrm = '1.0'\n\nmtype = address()\nPARSE SOURCE s1 s2 s3 s4 s5 s6 s7 s8 s9\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then systemid = mvsvar(syssmfid)\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        systemid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse systemid = \"\"\n\nsay \"D2SEQN - version \"vrm \"- Freeware - Death to Sequence Numbers\"\nsay \"Copyright 1999 by David Alcock. All rights reserved.\"\nsay \" \"\nsay \". Executing in Environment: \"s1 \"-\" mtype\nif systemid <> \"\" then say \". Executing on system: \"systemid\nsay \" \"\n\n/* --------------------------------------------------------------------\n | Read SYSUT1 records and write to SYSUT2\n +------------------------------------------------------------------ */\n\naddress TSO\n\"EXECIO * DISKR SYSUT1 (FINIS STEM sysut1_file.\"\n\"NEWSTACK\"   /* Place to put SYSUT2 output */\n\ndo i = 1 to sysut1_file.0\n\n   record = sysut1_file.i\n\n   if length(record) == 80 then do\n      record = substr(record,1,72)\n      /* add elimnation of IBM apar stuff like \"@THX1138\" */\n      c = substr(record,72,1) /* Save continuation character if any */\n      w = words(record)\n      if w > 0 then do\n         if substr(word(record,w),1,1) == \"@\" then do\n            say \"Deleted word (\"left(word(record,w),10)\") from: \" ,\n                record\n            record = delword(record,w)\n            end\n         end\n      if c <> \" \" then record = overlay(c,record,72)\n      end\n\n   if record == \"\" then record = \" \"\n\n   queue record\n\n   end\n\n/* --------------------------------------------------------------------\n | Close SYSUT2 and leave\n +------------------------------------------------------------------ */\n\nqueue ''      /* add null line to indicate End-Of-File */\n\"EXECIO * DISKW SYSUT2 (FINIS\"\n\"DELSTACK\"\nsay \" \"\nsay \"That's all folks...\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDMOD": {"ttr": 20746, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\"\\x01\\x020o\\x01\\x020o\\x18&\\x05\\xcc\\x05\\xc2\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T18:26:22", "lines": 1484, "newlines": 1474, "modlines": 0, "user": "IBMUSER"}, "text": "FINDMOD  TITLE 'Find a module - search LPA, LNKLST, Nuc, etc'\n* =================================================================== *\n*\n* Name: FINDMOD\n*\n* Author: David Alcock\n*\n* Purpose: Search for a module everywhere! To wit:\n*          o JPAQ\n*          o //ISPLLIB\n*          o LPA\n*          o Static or Dynamic LNKLSTs\n*          o Nucleus\n*          o SVCLIB\n*\n* Attributes: Non-reentrant, Non-Authorized\n*\n*  Disclaimer: This program is FREEWARE.  Use at your own risk.  It\n*              is provided for your enjoyment and neither David\n*              Alcock or his employer provides any warranty for it's\n*              use.  I'd like to hear how it works on your system.\n*\n*              This software is not in the public domain but is\n*              available free of charge and with source code\n*              provided.  It is copyright 2002+ by David Alcock\n*              All rights reserved.\n*\n* =================================================================== *\n         SPACE 2\n&DAVER   SETC  '1.0'\n*======================================================================\n*\n*             M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date       VRM Description\n* ---------- ---------- --- -------------------------------------------\n* DGAlcock   2002-09-26 1.0 Initial program started;\n*\n*======================================================================\n         EJECT ,\n*\n** Map IBM DSECTs\n*\n         EJECT ,\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=NO          Communications Vector Table\n         IHAPDS PDSBLDL=YES               PDS Directory entry\n         IHAASCB ,\n         IHAASSB ,\n         DCBD  DSORG=PS,DEVD=DA           Data Control Block\n         IEFTIOT1 ,                       Task I/O Table\n         IEFJFCBN ,                       Job File Control Block\n         IEFJESCT ,                       JES communication area\n         IHAPSA ,                         Prefixed Save Area\n         IKJTCB ,                         Task Control Block\n         IHAECVT ,                        Extended CVT\n         IEFZB4D0 ,                       SVC 99 - RB\n         IEFZB4D2 ,                       SVC 99 - Text Equates\n         IEFZB505 LOCEPAX=YES             EPA mapping for SWAREQ\n         IEFQMIDS ,                       Equates for SWA requests\n         IHALDA ,                         Local Data Area\n         IHAGDA ,                         VSM Global Data Area\n         CSVDLCB TITLE=NO                 Dynamic LNKLST\n         CSVDLAA ,                        Dynamic LNKLST\n         IHACDE  ,                        Contents Directory Entry\n         IKJCPPL ,                        Command Processor Parm List\n         IKJIOPL ,                        I/O Parm List\n#IOPL    EQU   *-IOPL\n*        IHALLT &DSECT=YES             LNKLST/LPALST tables\nLLT      DSECT\nLLTID    DS    C'LLT '                 BLOCK ACRONYM\nLLTCOUNT DS    F                       NUMBER OF ENTRIES\nLLTENTRY DS    0CL45                   DSNAME ENTRY\nLLTDSLTH DS    FL1                     DSNAME LENGTH AFTER TRUNCATION\nLLTDSN   DS    CL44                    DATA SET NAME\nLLTNEXT  EQU   *                       NEXT ENTRY\n\n         YREGS ,                          Equate registers\n         PRINT GEN\n*\n** Convert assembly date from format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n*\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***\n**       Module start\n***\n***********************************************************************\n         SPACE 2\nFINDMOD  CSECT ,\nFINDMOD  AMODE 31\nFINDMOD  RMODE ANY\n*\n** Standard O/S eyecatcher\n*\nFM_EC    B    FM_ECL(0,R15)             Bump past EyeCatcher\n         DC   AL1(FM_ECE-FM_ECV)        Length of eyecatcher\nFM_ECV   DC   C'FINDMOD  &ASMDATE &SYSTIME V&DAVER '\n         DC   C'TSO/IPCS command: Find module in storage'\nFM_ECE   EQU  *\n         DS   0H\nFM_ECL   EQU  *-FM_EC\n*\n** Standard ESA entry housekeeping code\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         LAE   R11,2048(,R12)           Set up for second base reg\n         LA    R11,2048(,R11)           Locate 4096 past R12\n         USING FINDMOD,R12,R11          Set module base\n*\n** Obtain Dynamic Save Area\n*\n         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage\n         LR    R13,R1                   Point to Save Area\n*\n         LR    R14,R13                  To: Address\n         L     R15,=AL4(WORKDSL)        To: Length\n         SLR   R1,R1                    From: Set length and pad\n         MVCL  R14,R0                   Zero out area\n*\n         MVC   4(4,R13),=C'F1SA'        Indicate stack SA\n         USING WORKDS,R13               Get addressibility to area\n         EJECT ,\n***********************************************************************\n***\n**  Process the input parm to get the module name and any options\n***\n***********************************************************************\n         SPACE 2\nPROCESS_PARAMETER EQU *\n         EREG  R1,R1                      Restore R1 on entry\n         TM    CPPLCBUF-CPPL(R1),X'80'    Was this command called?\n         BNO   PP$NC                      No, need to look at CBUF\n*\n** We were called, it has a Batch type (EXEC) parameter\n*\n         L     R2,0(R1)                   Get address of parm\n         SLR   R3,R3                      Clear register\n         ICM   R3,B'0011',0(R2)           Get length of parm\n         BZ    PP$NULL                    None, leave\n         LA    R2,2(R2)                   Bump past parm length HW\n         B     PP$PARSE                   Parse the input\n*\n** We were not called, it is a \"Command Processor\"\n*\nPP$NC    DS    0H\n         oi    flag1,$f1_tsocp            We are a TSO command processor\n\n         mvc   pm_PBLK(C_PutLineL),C_PutLine Initialize IOPL\n         la    r14,pm_IOPL                Locate Our IPOL\n         mvc   IOPLUPT-IOPL(4,r14),CPPLUPT-CPPL(r1)\n         mvc   IOPLECT-IOPL(4,r14),CPPLECT-CPPL(r1)\n         la    r15,pm_ECB                 Locate ECB\n         st    r15,IOPLECB-IOPL(r14)      Fill it in\n\n         L     R2,CPPLCBUF-CPPL(R1)       Locate Command Buffer\n         SLR   R3,R3                      Clear register\n         ICM   R3,B'0011',0(R2)           Get total CBUF length\n         SLR   R0,R0                      Clear register\n         ICM   R0,B'0011',2(R2)           Get total Command name length\n         LA    R15,4                      Length of header\n         AR    R2,R15                     Bump past header\n         SR    R3,R15                     Decrement for header length\n         AR    R2,R0                      Bump past Command length\n         SR    R3,R0                      Length of data\n*\n** Look thru command buffer/parameter for our commands\n** Input: R2 - Address of command-buffer/Parameter\n**        R3 - Length of command-buffer/Parameter\n*\nPP$PARSE DS    0H\n         LTR   R3,R3                      Check out length\n         BZ    PP$NULL                    Length = Zero: Leave\n         BM    PP$NULL                    Length < Zero: Leave\n         B     PP$SAVE\nPP$NULL  DS    0H\n         LA    R2,=C'IEFBR14'           Set default module name\n         LA    R3,7\nPP$SAVE  DS    0H\n         STM   R2,R3,PP_PARMS           Save parm addr & length\n         EJECT\n***********************************************************************\n***\n**       Startup messages\n***\n***********************************************************************\n         SPACE 2\n\n* Print startup message\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG00L,R15),MSG00\n         LA    R15,MSG00L(R15)\n         BAS   R14,Print_Message          Print message\n\n* Print the system name from the CVT and O/S info\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG03L,R15),MSG03\n         LA    R15,MSG03L+1(R15)\n         L     R1,CVTPTR\n         MVC   0(L'CVTSNAME,R15),CVTSNAME-CVTMAP(R1)\n         LA    R0,L'CVTSNAME\n         BAS   R14,LOCATE_FIRST_SPACE\n         MVC   0(MSG03BL,R15),MSG03B      Get more text\n         LA    R15,MSG03BL+1(R15)\n         L     R1,CVTPTR                  Locate CVT\n         L     R1,CVTECVT-CVTMAP(R1)      -> ECVT\n         MVC   0(L'ECVTPNAM,R15),ECVTPNAM-ECVT(R1)\n         LA    R0,L'ECVTPNAM\n         BAS   R14,Locate_First_Space\n         MVC   1(2,R15),=c'at'\n         LA    R15,1+2+1(R15)\n         MVC   0(L'ECVTPVER,R15),ECVTPVER-ECVT(R1)\n         MVI   L'ECVTPVER(R15),C'.'       Move in dot\n         LA    R15,L'ECVTPVER+1(R15)\n         MVC   0(L'ECVTPREL,R15),ECVTPREL-ECVT(R1)\n         MVI   L'ECVTPREL(R15),C'.'       Move in dot\n         LA    R15,L'ECVTPREL+1(R15)\n         MVC   0(L'ECVTPMOD,R15),ECVTPMOD-ECVT(R1)\n         LA    R15,L'ECVTPMOD(R15)\nI$M3X    DS    0H\n         BAS   R14,Print_Message          Print Message\n*\n         BAS   R14,Initialize_Message     Clear output area\n         LA    R15,1(R15)\n         BAS   R14,Print_Message          Print Message\n         EJECT\n***********************************************************************\n***\n**  Validate module name, search, print results and terminate\n***\n***********************************************************************\n         SPACE 2\n\n* Ensure Module name is okay (length and padded with spaces)\n\n         LA    R1,ModuleName              Locate module name area\n         CH    R3,=H'8'                   Max length?\n         BH    EM$Error                   Over length\n         MVI   0(R1),C' '                 Get space\n         MVC   1(7,R1),0(R1)              ..Propagate it\n         BCTR  R3,0                       Get ready for EX\n         EX    R3,EM$SAVEM                Move to our area\n         OC    ModuleName(8),=CL8' '      Ensure uppercase\n\n         TRT   ModuleName(8),TableOfGenerics\n         BZ    EM$X                       None...\n*        OI    Flag1,$F1_Generics\n*        B     EM$X\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG98L,R15),MSG98\n         LA    R15,MSG98L(R15)\n         BAS   R14,Print_Message          Print Message\n         MVI   MaxCC,8\n         B     Exit\n\nEM$SAVEM MVC   0(*-*,R1),0(R2)            ** Executed **\nEM$Error DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG01L,R15),MSG01        Get error txt\n         LA    R15,MSG01L(R15)\n         BAS   R14,Print_Message          Print message\n         MVI   MaxCC,12\n         B     Exit\nEM$X     DS    0H\n\n* Search the areas for module\n\n         BAS   R14,Search_JPAQ            Search JPAQ\n         BAS   R14,Search_ISPLLIB         Search ISPF tasklib\n         BAS   R14,Search_Active_LPAQ     Search Active LPA Queue\n         BAS   R14,Search_LPA             Search the LPA\n         BAS   R14,Search_LNKLST          Search the LNKLST\n         BAS   R14,Search_NUCLEUS         Search the Nucleus\n         BAS   R14,Search_SVCLIB          Search the SVCLIB !\n*\n** Free resources and terminate\n*\nEXIT     DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         BAS   R14,Print_Message          Print Message\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG99L,R15),MSG99\n         MVC   MSG99N-MSG99(8,R15),ModuleName\n         LA    R15,MSG99L+1(R15)\n         ICM   R1,B'1111',ModuleCnt       Get count\n         BZ    X$NF\n         MVC   0(5,R15),=c'found'\n         LA    R15,6(R15)\n         BAS   R9,EDITFWF\n         MVC   1(4,R15),=c'time'\n         LA    R15,1+4(R15)\n         CLC   ModuleCnt(4),=f'1'\n         BE    X$NFX\n         mvi   0(R15),c's'\n         LA    R15,1(R15)\n         B     X$NFX\nX$NF     DS    0H\n         MVC   0(13,R15),=c'not found :-('\n         LA    R15,13(R15)\nX$NFX    DS    0H\n         BAS   R14,Print_Message          Print Message\n*-Free Storage whilst retaining return code\n         LR    R2,R13                     Get storage address\n         SLR   R3,R3\n         IC    R3,MAXCC\n         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage\n         LR    R15,R3                     Set return code\n*-Return to caller\n         PR    ,                          Return to caller\n         EJECT\n***********************************************************************\n***\n** Search the SVCLIB\n***\n***********************************************************************\n         SPACE 2\nSearch_SVCLIB DS 0H\n         ST    R14,SR_RA                  Save return code\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05SVC,R15),MSG05SVC\n         LA    R15,L'MSG05SVC(R15)\n         BAS   R14,Print_Message          Print message\n\n         L     R4,CVTPTR                  -> CVT\n         L     R4,CVTSVDCB-CVTMAP(R4)     Locate SVCLIB DCB\n         LA    R1,ModuleName              Locate module name\n         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module\n         LTR   R15,R15                    Found?\n         BNZ   SSVC$NF\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L(R15)\n         BAS   R14,Print_Message          Print message\n         BAS   R14,Initialize_Message     Clear output area\n         LA    R15,2(R15)\n         BAS   R14,Append_Module_Attributes\n         BAS   R14,Print_Message          Print message\n         B     SSVC$X\n\nSSVC$NF  DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(L'MSG05NF,R15),MSG05NF\n         LA    R15,L'MSG05NF(R15)\n         BAS   R14,Print_Message          Print message\n*\n** Common exit from Search_SVCLIB\n*\nSSVC$X   DS    0H\n         L     R14,SR_RA                  Get return address\n         BSM   0,R14                      Continue\n         EJECT\n***********************************************************************\n***\n** Search the ISPF Task lib\n***\n***********************************************************************\n         SPACE 2\nSearch_ISPLLIB DS 0H\n         ST    R14,SR_RA                  Save return code\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05ITL,R15),MSG05ITL\n         LA    R15,L'MSG05ITL(R15)\n         BAS   R14,Print_Message          Print message\n\n         DEVTYPE =CL8'ISPLLIB',DOUBLE     allocated?\n         LTR   R15,R15\n         BNZ   SITL$NA                    No, leave\n\n         LA    R4,W_TSKDCB             Locate tasklib DCB\n         MVC   0(C_TSKDCBL,R4),C_TSKDCB Initialize DCB\n         MVC   DCBDDNAM-IHADCB(8,R4),=CL8'ISPLLIB'\n         MVC   PARMLIST(C_LSTIL),C_LSTI      Move in list\n         OPEN  ((4),(INPUT)),MF=(E,PARMLIST) Open the tasklib\n         LTR   R15,R15                 Test open...\n         BNZ   SITL$NF                 Oops, leave\n\n         LA    R1,ModuleName              Locate module name\n         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module\n         LR    R5,R15                     Save rc\n\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((4)),MF=(E,PARMLIST)   Close the file\n         FREEPOOL (4)\n\n         LTR   R5,R5                      Module in //ISPLLIB?\n         BNZ   SITL$NF                    No...\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L+1(R15)\n         LA    R1,=CL8'ISPLLIB'           Set DDNAME\n         BAS   R14,Append_Concatenation\n         BAS   R14,Print_Message          Print message\n         BAS   R14,Initialize_Message     Clear output area\n         LA    R15,2(R15)\n         BAS   R14,Append_Module_Attributes\n         BAS   R14,Print_Message          Print message\n         B     SITL$X\n\nSITL$NF  DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(L'MSG05NF,R15),MSG05NF\n         LA    R15,L'MSG05NF(R15)\n         BAS   R14,Print_Message          Print message\n         B     SITL$X\n*\n** //ISPLLIB not allocated\n*\nSITL$NA  DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG02L,R15),MSG02\n         LA    R15,MSG02L(R15)\n         BAS   R14,Print_Message          Print message\n*\n** Common exit from Search_ISPLLIB\n*\nSITL$X   DS    0H\n         L     R14,SR_RA                  Get return address\n         BSM   0,R14                      Continue\n         EJECT\n***********************************************************************\n***\n** Search the active LPA queue\n***\n***********************************************************************\n         SPACE 2\nSearch_Active_LPAQ DS 0h\n         ST    R14,SR_RA                  Save return code\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05ALQ,R15),MSG05ALQ\n         LA    R15,L'MSG05ALQ(R15)\n         BAS   R14,Print_Message          Print message\n\n* Start at the first LPA queue entry we can\n\n         L     R1,CVTPTR                  -> CVT\n         TM    CVTOSLV2-CVTMAP(R1),CVTDYLPA Dynamic LPA available?\n         BNO   SAL$MO                     Nope, Start elsewhere\n         L     R14,CVTECVT-CVTMAP(R1)      -> ECVT\n         ICM   R3,B'1111',ECVTDLPF-ECVT(R14) Any queue to check?\n         BNZ   SAL$MX\nSAL$MO   DS    0H\n         L     R1,CVTQLPAQ-CVTMAP(R1)\nSAL$MX   DS    0H\n\n* Process the CDEs\n\nSAL$L    DS    0H\n         CLC   CDNAME-CDENTRY(8,R3),ModuleName\n         BNE   SAL$LB\n\n         OI    Flag1,$F1_Found            We found at least one\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L+1(R15)\n         MVC   0(4,R15),=C'EPA='\n         LA    R15,4(R15)\n         UNPK  0(9,r15),CDENTPT-CDENTRY(5,R3)\n         mvz   0(8,r15),=8x'00'\n         tr    0(8,r15),=c'0123456789ABCDEF'\n*        mvi   8(r15),c' '\n         LA    R15,8(R15)\n         BAS   R14,Print_Message          Print message\n\nSAL$LB   DS    0H\n         ICM   R3,B'1111',CDCHAIN-CDENTRY(R3)\n         BNZ   SAL$L\n         TM    Flag1,$F1_Found            We found at least one\n         BO    SAL$X\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(L'MSG05NF,R15),MSG05NF\n         LA    R15,L'MSG05NF(R15)\n         BAS   R14,Print_Message          Print message\n*\n** Common exit from Search_Active_LPAQ\n*\nSAL$X    DS    0H\n         NI    Flag1,255-$F1_Found        Ensure good for next routine\n         L     R14,SR_RA                  Get return address\n         BSM   0,R14                      Continue\n         EJECT\n***********************************************************************\n***\n** Search the JPAQ\n***\n***********************************************************************\n         SPACE 2\nSearch_JPAQ DS  0H\n         ST    R14,SR_RA                  Save return code\n*\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05JPAQ,R15),MSG05JPAQ\n         LA    R15,L'MSG05LPA(R15)\n         BAS   R14,Print_Message          Print message\n\n         CSVQUERY INEPNAME=ModuleName,    Search for module            @\n               SEARCH=JPA,                ..in the LPA only            @\n               OUTVALID=LPA_VALID,        ..valid information          @\n               OUTEPA=LPA_EPA,            ..address of module          @\n               OUTLENGTH=LPA_LENGTH,      ..length of module           @\n               OUTMJNM=LPA_MJNM,                                       @\n               MF=(E,PARMLIST)\n         LTR   R15,R15\n         BNZ   SJPAQ$NF\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L+1(R15)\n         MVC   0(4,R15),=C'EPA='\n         LA    R15,4(R15)\n         UNPK  0(9,r15),LPA_EPA(5)\n         mvz   0(8,r15),=8x'00'\n         tr    0(8,r15),=c'0123456789ABCDEF'\n         MVC   8(2,R15),=c' ('\n         LA    R15,10(r15)\n         LA    R1,LPA_EPA\n         BAS   R14,Retrieve_VSLOC\n         AR    R15,R0                     Bump past description\n         MVI   0(R15),C')'\n         LA    R15,1(R15)\n         BAS   R14,Print_Message          Print message\n         B     SJPAQ$X\n\nSJPAQ$NF DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(L'MSG05NF,R15),MSG05NF\n         LA    R15,L'MSG05NF(R15)\n         BAS   R14,Print_Message          Print message\n         B     SLPA$X\n*\n** Common exit from Search_JPAQ\n*\nSJPAQ$X  DS    0H\n         L     R14,SR_RA\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***\n** Search the LPA\n***\n***********************************************************************\n         SPACE 2\nSearch_LPA DS 0H\n         ST    R14,SR_RA                  Save return code\n*\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05LPA,R15),MSG05LPA\n         LA    R15,L'MSG05LPA(R15)\n         BAS   R14,Print_Message          Print message\n\n         CSVQUERY INEPNAME=ModuleName,    Search for module            @\n               SEARCH=LPA,                ..in the LPA only            @\n               OUTVALID=LPA_VALID,        ..valid information          @\n               OUTEPA=LPA_EPA,            ..address of module          @\n               OUTLENGTH=LPA_LENGTH,      ..length of module           @\n               OUTMJNM=LPA_MJNM,                                       @\n               MF=(E,PARMLIST)\n         LTR   R15,R15\n         BNZ   SLPA$NF\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L+1(R15)\n         MVC   0(4,R15),=C'EPA='\n         LA    R15,4(R15)\n         UNPK  0(9,r15),LPA_EPA(5)\n         mvz   0(8,r15),=8x'00'\n         tr    0(8,r15),=c'0123456789ABCDEF'\n         MVC   8(2,R15),=c' ('\n         LA    R15,10(r15)\n         LA    R1,LPA_EPA\n         BAS   R14,Retrieve_VSLOC\n         AR    R15,R0                     Bump past description\n         MVI   0(R15),C')'\n         LA    R15,1(R15)\n         BAS   R14,Print_Message          Print message\n         B     SLPA$X\n\nSLPA$NF  DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(L'MSG05NF,R15),MSG05NF\n         LA    R15,L'MSG05NF(R15)\n         BAS   R14,Print_Message          Print message\n         B     SLPA$X\n*\n** Common exit from Search_LPA\n*\nSLPA$X   DS    0H\n         L     R14,SR_RA\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***\n** Search the LNKLST\n***\n***********************************************************************\n         SPACE 2\n\nSearch_LNKLST DS 0H\n         ST    R14,SR_RA                  Save return code\n\n         L     R1,CVTPTR\n         TM    CVTOSLV1-CVTMAP(R1),CVTH6603 Have Dynamic LNKLST?\n         bo    SLNK$D\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05LNKI,R15),MSG05LNKI\n         LA    R15,L'MSG05LNKI(R15)\n         BAS   R14,Print_Message          Print message\n\n         L     R3,CVTPTR\n         L     R3,CVTLLTA-CVTMAP(R3)\n         L     R7,LLTCOUNT-LLT(R3)\n         LA    R3,LLTENTRY-LLT(R3)\nSLNK$OL  DS    0H\n         LA    R2,LLTDSN-LLTENTRY(R3)\n         SLR   R9,R9                      No VOLUME\n         BAS   R14,Dynamic_Allocation\n         LTR   R15,R15\n         BZ    SLNK$OLO\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG07L,R15),MSG07\n         LA    R15,MSG07L(R15)\n         MVC   0(L'LLTDSN,R15),LLTDSN-LLTENTRY(R3)\n         LA    R15,L'LLTDSN(R15)\n         BAS   R14,Print_Message          Print message\n         B     SLNK$OLB\nSLNK$OLO DS    0H\n         LA    R4,W_TSKDCB             Locate tasklib DCB\n         MVC   0(C_TSKDCBL,R4),C_TSKDCB Initialize DCB\n         MVC   DCBDDNAM-IHADCB(8,R4),0(R1)   Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI      Move in list\n         OPEN  ((4),(INPUT)),MF=(E,PARMLIST) Open the tasklib\n         LTR   R15,R15                 Test open...\n         BNZ   SLNK$OLB                Oops, leave\n\n         LA    R1,ModuleName              Locate module name\n         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module\n         LR    R5,R15                     Save rc\n\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((4)),MF=(E,PARMLIST)   Close the file\n         FREEPOOL (4)\n\n         LTR   R5,R5                      Module in this library?\n         BNZ   SLNK$OLB                   No...\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L(R15)\n         MVC   1(7,R15),=c'in DSN='\n         LA    R15,8(R15)\n         MVC   0(L'LLTDSN,R15),LLTDSN-LLTENTRY(R3)\n         LA    R0,L'LLTDSN\n         BAS   R14,Locate_First_Space\n         BAS   R14,Print_Message          Print message\n         BAS   R14,Initialize_Message     Clear output area\n         LA    R15,2(R15)\n         BAS   R14,Append_Module_Attributes\n         BAS   R14,Print_Message          Print message\nSLNK$OLB DS    0H\n         LA    R3,LLTNEXT-LLTENTRY(R3)\n         BCT   R7,SLNK$OL\n         B     SLNK$X\n\n* Dynamic LNKLSTs\n\nSLNK$D   DS    0H\n#SLNK$LEN EQU  64*1024\n         L     R0,=A(#SLNK$LEN)\n         GETMAIN R,LV=(0)\n         STM   R0,R1,SLNK_Area\n         LR    R8,R1\n         USING DLAAHDR,R8\n         CSVDYNL REQUEST=LIST,                                         X\n               ANSAREA=DLAAHDR,                                        X\n               ANSLEN==A(#SLNK$LEN),                                   X\n               USERINFO=YES,                                           X\n               MF=(E,CSVDYNL)\n         ICM   R15,B'1111',DLAAH#REM\n         BNZ   SLNK$DX                   Hmmm, errors?\n         L     R7,DLAAHFIRSTLSADDR     Address of first DLAALS\nSLNK$DSL DS    0H\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05LNKS,R15),MSG05LNKS\n         LA    R15,L'MSG05LNKS(R15)\n         MVC   0(L'DLAALSNAME,R15),DLAALSNAME-DLAALS(R7)\n         LA    R0,L'DLAALSNAME\n         BAS   R14,Locate_First_Space\n         TM    DLAALSFLAGS-DLAALS(R7),DLAALSCURRENT\n         BNO   SLNK$DSCX\n         MVC   0(8,R15),=c',Current'\n         LA    R15,8(R15)\nSLNK$DSCX DS   0H\n         MVI   0(R15),C')'\n         LA    R15,2(R15)\n         BAS   R14,Print_Message          Print message\n\n         L     R3,DLAALSFIRSTDSADDR-DLAALS(R7)\nSLNK$DDL DS    0H\n         LA    R2,DLAADSNAME-DLAADS(R3)\n         LA    R9,DLAADSVOLID-DLAADS(R3)\n         BAS   R14,Dynamic_Allocation\n         LTR   R15,R15\n         BZ    SLNK$DDLO\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG07L,R15),MSG07\n         LA    R15,MSG07L(R15)\n         MVC   0(L'DLAADSNAME,R15),DLAADSNAME-DLAADS(R3)\n         LA    R0,L'DLAADSNAME\n         BAS   R14,Locate_First_Space\n         MVC   1(9,R15),=c'on volume'\n         LA    R15,1+9+1(R15)\n         MVC   0(L'DLAADSVOLID,R15),DLAADSVOLID-DLAADS(R3)\n         LA    R15,L'DLAADSVOLID(R15)\n         BAS   R14,Print_Message          Print message\n         B     SLNK$DDLB\nSLNK$DDLO DS   0H\n         LA    R4,W_TSKDCB             Locate tasklib DCB\n         MVC   0(C_TSKDCBL,R4),C_TSKDCB Initialize DCB\n         MVC   DCBDDNAM-IHADCB(8,R4),0(R1)   Get DDNAME\n         MVC   PARMLIST(C_LSTIL),C_LSTI      Move in list\n         OPEN  ((4),(INPUT)),MF=(E,PARMLIST) Open the tasklib\n         LTR   R15,R15                 Test open...\n         BNZ   SLNK$DDLB               Oops, leave\n\n         LA    R1,ModuleName              Locate module name\n         BAS   R14,ISSUE_BLDL_WDCB        Do BLDL for module\n         LR    R5,R15                     Save rc\n\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((4)),MF=(E,PARMLIST)   Close the file\n         FREEPOOL (4)\n\n         LTR   R5,R5                      Module in this library?\n         BNZ   SLNK$DDLB                  No...\n\n         OI    Flag1,$F1_Found\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L(R15)\n         MVC   1(7,R15),=c'in DSN='\n         LA    R15,8(R15)\n         MVC   0(L'DLAADSNAME,R15),DLAADSNAME-DLAADS(R3)\n         LA    R0,L'DLAADSNAME\n         BAS   R14,Locate_First_Space\n         MVC   1(9,R15),=c'on volume'\n         LA    R15,1+9+1(R15)\n         MVC   0(L'DLAADSVOLID,R15),DLAADSVOLID-DLAADS(R3)\n         LA    R15,L'DLAADSVOLID(R15)\n         BAS   R14,Print_Message          Print message\n         BAS   R14,Initialize_Message     Clear output area\n         LA    R15,2(R15)\n         BAS   R14,Append_Module_Attributes\n         BAS   R14,Print_Message          Print message\n\nSLNK$DDLB DS   0H\n         ICM   R3,B'1111',DLAADSNEXTADDR-DLAADS(R3) Next Library\n         BNZ   SLNK$DDL\n\nSLNK$DSLB DS   0H\n         ICM   R7,B'1111',DLAALSNEXTADDR-DLAALS(R7) Next LNKLST set\n         BNZ   SLNK$DSL\n         LM    R0,R1,SLNK_Area\n         FREEMAIN R,LV=(0),A=(1)\n         DROP  R8\nSLNK$DX  DS    0H\n\n         TM    Flag1,$F1_Found            In any LNKLST?\n         BO    SLNK$X\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(L'MSG05NF,R15),MSG05NF\n         LA    R15,L'MSG05NF(R15)\n         BAS   R14,Print_Message          Print message\n         B     SLNK$X\n*\n** Common exit from Search_LNKLST\n*\nSLNK$X   DS    0H\n         NI    Flag1,255-$F1_Found        Ensure good for next routine\n         L     R14,SR_RA\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***\n** Search the Nucleus\n***\n***********************************************************************\n         SPACE 2\nSearch_Nucleus DS 0H\n         ST    R14,SR_RA                  Save return code\n*\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG05L,R15),MSG05\n         LA    R15,MSG05L+1(R15)\n         MVC   0(L'MSG05NUC,R15),MSG05NUC\n         LA    R15,L'MSG05NUC(R15)\n         BAS   R14,Print_Message          Print message\n\n         NUCLKUP  BYNAME,                 Locate Nucleus module        @\n               NAME=ModuleName,           ..Name to search for         @\n               ADDR=LPA_EPA               ..Return Address here\n         LTR   R15,R15\n         BNZ   SNUC$NF\n\n         L     R1,ModuleCnt\n         LA    R1,1(R1)\n         ST    R1,ModuleCnt\n\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(MSG06L,R15),MSG06\n         MVC   MSG06N-MSG06(8,R15),ModuleName\n         LA    R15,MSG06L+1(R15)\n         MVC   0(4,R15),=C'EPA='\n         LA    R15,4(R15)\n         UNPK  0(9,r15),LPA_EPA(5)\n         mvz   0(8,r15),=8x'00'\n         tr    0(8,r15),=c'0123456789ABCDEF'\n         MVC   8(2,R15),=c' ('\n         LA    R15,10(r15)\n         LA    R1,LPA_EPA\n         BAS   R14,Retrieve_VSLOC\n         AR    R15,R0                     Bump past description\n         MVI   0(R15),C')'\n         LA    R15,1(R15)\n         BAS   R14,Print_Message          Print message\n         B     SNUC$X\n\nSNUC$NF  DS    0H\n         BAS   R14,Initialize_Message     Clear output area\n         MVC   0(L'MSG05NF,R15),MSG05NF\n         LA    R15,L'MSG05NF(R15)\n         BAS   R14,Print_Message          Print message\n         B     SNUC$X\n*\n** Common exit from Search_Nucleus\n*\nSNUC$X   DS    0H\n         L     R14,SR_RA\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***\n** Dynamically allocate file\n**\n** Input: R2 has DSNAME\n**        R9 has volume or zero for none\n**\n** Output: R1 has pointer to DDNAME\n***\n***********************************************************************\n         SPACE 2\n\nDynamic_Allocation ds 0h\n         ST    R14,DA_RA                  Get return address\n* Format Request block\n\n         LA    R4,PARMLIST                Get address of work area\n         ST    R4,DOUBLE                  Save address\n         OI    DOUBLE,S99RBPND            Indicate last one\n         XC    0(S99RBEND-S99RB,R4),0(R4) Clear Request Block area\n         MVI   S99RBLN-S99RB(R4),S99RBEND-S99RB Length of REQUEST BLK\n         LA    R5,S99RBEND-S99RB(R4)      Locate Text Units Pointers\n         ST    R5,S99TXTPP-S99RB(R4)      STORE ADDR OF Text Unit PTRs\n         LA    R6,24(R5)    6*4=24        Bump past Text pointers\n\n** The address of each of the text Units will be stored in the\n** request block text PTR area as they are being defined,\n** Active registers are: R5 - Address in text unit pointers\n**                       R6 - Address in text unit define area\n\n         MVI   S99VERB-S99RB(R4),S99VRBAL    Verb = ALLOCATE\n***-------------------------------------- DDNAME=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALRTDDN                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,8                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         LA    R1,S99TUPAR-S99TUNIT(R6)     Locate DDNAME\n         ST    R1,DOUBLE2                   Save Addr: Returned DDNAME\n*\n         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit\n***-------------------------------------- DISP=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALSTATS                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,1                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVI   S99TUPAR-S99TUNIT(R6),8      DISP=SHR\n*\n         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit\n***-------------------------------------- Free=Close\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALCLOSE                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,0                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,0                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n*\n         LA    R6,S99TUPAR-S99TUNIT+2(R6)   Bump past this Text Unit\n***-------------------------------------- UNIT=SYSALLDA\n         LTR   R9,R9\n         BZ    DA$VOLX\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALUNIT                  Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,8                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVC   S99TUPAR-S99TUNIT(8,R6),=CL8'SYSALLDA'\n*\n         LA    R6,S99TUPAR-S99TUNIT+8(R6)   Bump past this Text Unit\n***-------------------------------------- VOL=SER=xxxxx\n         ST    R6,0(R5)                     Save Address of Text Unit\n         LA    R5,L'S99TUPTR(R5)            Bump to next entry\n*\n         LA    R14,DALVLSER                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,6                        Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVC   S99TUPAR-S99TUNIT(6,R6),0(R9)\n*\n         LA    R6,S99TUPAR-S99TUNIT+6(R6)   Bump past this Text Unit\nDA$VOLX  DS    0H\n***-Last--------------------------------- DSN=\n         ST    R6,0(R5)                     Save Address of Text Unit\n         OI    S99TUPTR-S99TUPL(R5),S99TUPLN End of parm indication\n*\n         LA    R14,DALDSNAM                 Generate Key Value\n         STH   R14,S99TUKEY-S99TUNIT(R6)    Store Key\n         LA    R14,1                        Number of entries\n         STH   R14,S99TUNUM-S99TUNIT(R6)    Store Number\n         LA    R14,44                       Length of First Entry\n         STH   R14,S99TULNG-S99TUNIT(R6)    Store Length\n         MVC   S99TUPAR-S99TUNIT(44,R6),0(R2)\n***-------------------------------------- Complete and make request\n\n* Perform dynamic allocation\n\n         LA    R1,DOUBLE                  Get address of Request BLK\n         DYNALLOC ,                       Invoke SVC 99\n         L     R1,DOUBLE2                 Locate the DDNAME\n         L     R14,DA_RA                  Get return address\n         BSM   0,R14                      Return to caller\n         EJECT\n***********************************************************************\n***\n**       Misc internal subroutines\n***\n***********************************************************************\n         SPACE 2\n\n* Append load module attributes from the BLDL area into the print line\n\nAppend_Concatenation DS 0H\n         ST    R14,AC_RA\n         ST    R15,AC_SREG\n\n         L     R14,PSATOLD-PSA            -> TCB\n         L     R14,TCBTIO-TCB(,R14)       -> TIOT\n         LA    R14,TIOENTRY-TIOT1(R14)    Locate first DD entry\nAC$L     DS    0H\n         SLR   R0,R0                      Set register to zero\n         ICM   R0,B'0001',TIOELNGH-TIOENTRY(R14) Get length of entry\n         BZ    AC$X                       None, end of the TIOT\n         CLC   TIOEDDNM-TIOENTRY(8,R14),0(R1) Found it?\n         BE    AC$F                       Yes, continue\n         AR    R14,R0                     Bump to next DD entry\n         B     AC$L\nAC$F     DS    0H\n         LA    R2,BLDLA_ENTRY\n         LA    R1,0\nAC$CL    DS    0H\n         CLM   R1,B'0001',PDS2CNCT-PDS2(R2)\n         BE    AC$CLX\n         SLR   R0,R0                      Set register to zero\n         ICM   R0,B'0001',TIOELNGH-TIOENTRY(R14) Get length of entry\n         BZ    AC$X                       None, end of the TIOT\n         LA    R1,1(R1)                   Increase concat number\n         AR    R14,R0\n         B     AC$CL\nAC$CLX   DS    0H\n         LA    R1,AC_SWAEPAX             Locate start of EPA\n         ST    R1,DOUBLE                  Save address\n         XC    0(L'SWAEPAX,R1),0(R1)      Initialize to binary zeros\n         MVC   SWVA-ZB505(3,R1),TIOEJFCB-TIOENTRY(R14) JFCB token\n         MVI   SWBLKID-ZB505(R1),SWJFCBID Indicate we need JFCB\n         MVC   PARMLIST(C_SWAREQL),C_SWAREQ Initialize Parameter List\n         SWAREQ EPA=DOUBLE,UNAUTH=YES,MF=(E,PARMLIST) Get control block\n         LTR   R15,R15                    Successful?\n         BNZ   AC$X                       No, leave\n         LA    R1,AC_SWAEPAX             Locate start of EPA\n         ICM   R1,B'1111',SWBLKPTR-ZB505(R1) locate JFCB\n         BZ    AC$X\n         L     R15,AC_SREG\n         MVC   1(7,R15),=C'in DSN='\n         LA    R15,8(R15)\n         MVC   0(L'JFCBDSNM,R15),JFCBDSNM-INFMJFCB(R1)\n         LA    r0,L'JFCBDSNM\n         BAS   R14,Locate_First_Space\n         L     R14,AC_RA\n         BSM   0,R14\nAC$X     DS    0H\n         L     R15,AC_SREG\n         L     R14,AC_RA\n         BSM   0,R14\n\n* Append load module attributes from the BLDL area into the print line\n\nAppend_Module_Attributes ds 0h\n         ST    R14,AMA_RA\n         LA    R2,BLDLA_ENTRY\n         MVC   1(5,R15),=c'Size='\n         LA    R15,6(R15)\n         UNPK  0(7,R15),PDS2STOR-PDS2(4,R2)\n         MVZ   0(6,R15),=8x'00'\n         TR    0(6,R15),=C'0123456789ABCDEF'\n         MVI   6(R15),C' '\n         LA    R15,7(R15)\n\n* Need to check macro level and test for 64 bitness here!\n         MVC   0(5,R15),=c'Rmode'\n         LA    R15,5(R15)\n         TM    PDS2FTB2-PDS2(R2),PDSLRMOD\n         BO    AMA$RAny\n         MVC   0(2,R15),=C'24'\n         LA    R15,3(R15)\n         B     AMA$Rx\nAMA$RAny DS    0H\n         MVC   0(3,R15),=C'Any'\n         LA    R15,4(R15)\nAMA$RX   DS    0H\n*\n         MVC   0(5,R15),=c'Amode'\n         LA    R15,5(R15)\n         TM    PDS2FTB2-PDS2(R2),PDSMAMOD  Both on?\n         BO    AMA$AANY                   Yes, its ANY\n         TM    PDS2FTB2-PDS2(R2),BIT6     Just one?\n         BO    AMA$A31                    Yes, its 31\n         MVC   0(2,R15),=C'24'\n         LA    R15,3(R15)\n         B     AMA$AX\nAMA$A31  DS    0H\n         MVC   0(2,R15),=C'31'\n         LA    R15,3(R15)\n         B     AMA$AX\nAMA$AANY DS    0H\n         MVC   0(3,R15),=C'Any'\n         LA    R15,4(R15)\nAMA$AX   DS    0H\n\n         TM    PDS2ATR1-PDS2(R2),PDS2RENT\n         BNO   AMA$RENTX\n         MVC   0(9,R15),=C'Reentrant'\n         LA    R15,10(R15)\nAMA$RENTX DS   0H\n         TM    PDS2ATR1-PDS2(R2),PDS2REUS\n         BNO   AMA$REUSX\n         MVC   0(8,R15),=C'Reusable'\n         LA    R15,9(R15)\nAMA$REUSX DS   0H\n\n         L     R14,AMA_RA\n         BSM   0,R14\n\n*\n** Determine V/S location of input 31-bit memory (below the Bar)\n**\n** R1 has the address of a fullword with the address (binary) to lookup\n** R15 has the output location of the V/S area\n*\n\nRetrieve_VSLOC ds 0h\n stm   r2,r4,RV_REGS\n\n mvc   DOUBLE2(4),0(R1)                 Get input fullword\n ni    DOUBLE2,255-X'80'                Ensure high order is off\n la    r1,double2\n\n L     R2,CVTPTR                          -> CVT\n L     R3,CVTGDA-CVTMAP(R2)               -> GDA\n L     R2,CVTSMEXT-CVTMAP(R2)             -> CVT Virtual Storage Ext.\n\n clc   0(4,R1),=X'7FFFFFFF'               Upper limit?\n bnl   rv$invalid\n clc   0(4,R1),GDAEPVT-GDA(R3)            In Ext Private?\n bnl   RV$XPVT\n clc   0(4,R1),GDAECSA-GDA(R3)            In Ext CSA?\n bnl   RV$XCSA\n icm   R0,B'1111',CVTEMLPS-CVTVSTGX(R2)   Get starting addr of xmlpa\n BZ    RV$CXMLPAX                         Zero: Area not being used\n clc   0(4,R1),CVTEMLPS-CVTVSTGX(R2)      In Ext-MLPA?\n bnl   RV$XMLPA\nRV$CXMLPAX ds 0h\n icm   R0,B'1111',CVTEFLPS-CVTVSTGX(R2)   Get starting addr of xflpa\n BZ    RV$CXFLPAX                         Zero: Area not being used\n clc   0(4,R1),CVTEFLPS-CVTVSTGX(R2)      In Ext-FLPA?\n bnl   RV$XFLPA\nRV$CXFLPAX ds 0h\n clc   0(4,R1),CVTEPLPS-CVTVSTGX(R2)      In Ext-PLPA?\n bnl   RV$XPLPA\n clc   0(4,R1),GDAESQA-GDA(R3)            In Ext SQA?\n bnl   RV$XSQA\n clc   0(4,R1),CVTERWNS-CVTVSTGX(R2)      In Ext-R/W Nuc?\n bnl   RV$XRWNUC\n clc   0(4,R1),=X'01000000'               In Ext-R/O Nuc?\n bnl   RV$XRONUC\n clc   0(4,R1),CVTRONS-CVTVSTGX(R2)       In R/O Nuc?\n bnl   RV$RONUC\n clc   0(4,R1),CVTRWNS-CVTVSTGX(R2)       In R/W Nuc?\n bnl   RV$RWNUC\n clc   0(4,R1),GDASQA-GDA(R3)             In SQA?\n bnl   RV$SQA\n clc   0(4,R1),CVTPLPAS-CVTVSTGX(R2)      In PLPA?\n bnl   RV$PLPA\n ICM   R0,B'1111',CVTFLPAS-CVTVSTGX(R2)   Get starting address\n BZ    RV$CFLPAX                          Zero: Area not used\n clc   0(4,R1),CVTFLPAS-CVTVSTGX(R2)      In FLPA?\n bnl   RV$FLPA\nRV$CFLPAX ds 0h\n ICM   R0,B'1111',CVTMLPAS-CVTVSTGX(R2)   Get starting address\n BZ    RV$CMLPAX                          Zero: Area not used\n clc   0(4,R1),CVTMLPAS-CVTVSTGX(R2)      In MLPA?\n bnl   RV$MLPA\nRV$CMLPAX ds 0h\n\n clc   0(4,R1),GDACSA-GDA(R3)             In CSA?\n bnl   RV$CSA\n L     R4,PSAAOLD-PSA                     -> PSA\n L     R4,ASCBLDA-ASCB(,R4)               -> LDA\n clc   0(4,R1),LDASTRTA-LDA(R4)           In private region?\n bnl   RV$PVT\n MVC   0(10,R15),=C'PSA+System'\n LA    R0,10\n B     RV$X\nRV$invalid ds 0h\n MVC   0(3,R15),=c'n/a'\n LA    R0,3\n B     RV$X\nRV$XPVT ds 0h\n MVC   0(11,R15),=c'Ext-Private'\n LA    R0,11\n B     RV$X\nRV$XCSA ds 0h\n MVC   0(7,R15),=c'Ext-CSA'\n LA    R0,7\n B     RV$X\nRV$XFLPA ds 0h\n MVC   0(8,R15),=c'Ext-FLPA'\n LA    R0,8\n B     RV$X\nRV$XMLPA ds 0h\n MVC   0(8,R15),=c'Ext-MLPA'\n LA    R0,8\n B     RV$X\nRV$XPLPA ds 0h\n MVC   0(8,R15),=c'Ext-PLPA'\n LA    R0,8\n B     RV$X\nRV$XSQA  ds 0h\n MVC   0(7,R15),=c'Ext-SQA'\n LA    R0,7\n B     RV$X\nRV$XRWNUC ds 0h\n MVC   0(15,R15),=c'Ext-R/W Nucleus'\n LA    R0,15\n B     RV$X\nRV$XRONUC ds 0h\n MVC   0(15,R15),=c'Ext-R/O Nucleus'\n LA    R0,15\n B     RV$X\nRV$RONUC ds 0h\n MVC   0(11,R15),=c'R/O Nucleus'\n LA    R0,11\n B     RV$X\nRV$RWNUC ds 0h\n MVC   0(11,R15),=c'R/W Nucleus'\n LA    R0,11\n B     RV$X\nRV$SQA ds 0h\n MVC   0(3,R15),=c'SQA'\n LA    R0,3\n B     RV$X\nRV$PLPA ds 0h\n MVC   0(4,R15),=c'PLPA'\n LA    R0,4\n B     RV$X\nRV$FLPA ds 0h\n MVC   0(4,R15),=c'FLPA'\n LA    R0,4\n B     RV$X\nRV$MLPA ds 0h\n MVC   0(4,R15),=c'MLPA'\n LA    R0,4\n B     RV$X\nRV$CSA ds 0h\n MVC   0(3,R15),=c'CSA'\n LA    R0,3\n B     RV$X\nRV$PVT ds 0h\n MVC   0(7,R15),=c'Private'\n LA    R0,7\n B     RV$X\nRV$X ds 0h\n lm    r2,r4,RV_REGS\n BSM   0,R14\n*\n** Edit full word in Register 1 flush at location in Register 15\n** INPUT: R1 - Register to print\n**        R15 - Address to put number\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      Check for 0\n         BZ    EDITFWF0                   Yes, put zero\n         CVD   R1,DOUBLE                  No, convert to packec\n         LA    R1,DOUBLE2+14              Locate sig digit\n         MVC   DOUBLE2(15),EDITFWFP\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save place\n         LA    R14,DOUBLE2+16             Locate last possible byte + 1\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for ex\n         EX    R14,EDITFWFM               Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '\n         BSM   0,R9                       Return to caller\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITFWFP DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Put in zero\n         LA    R15,1(R15)                 Bump pointer past zero\n         BSM   0,R9                       Return to caller\n*\n** Point Register 15 to the first blank in a string\n** Input:  R0  - Maximum length of the string\n**         R15 - String\n** Output: R15 - First space in the string\n*\nLOCATE_FIRST_SPACE EQU *\n         CLI   0(R15),C' '                Blank?\n         BE    LFS$X                      Yes, leave\n         LA    R15,1(R15)                 No, bump to next byte\n         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat\nLFS$X    EQU   *\n         BSM   0,R14                      Return to caller\n*\n** Issue BLDL (with DCB)\n**\n** Input: R1 has address of 8 byte module to look for\n**        R4 has address of the DCB\n** Output: R15 has return code from BLDL\n*\nISSUE_BLDL_WDCB DS  0H\n         ST    R14,DOUBLE                 Save return address\n         XC    BLDLA(BLDLAL),BLDLA        Clear to zeros\n         MVC   BLDLA_FF(2),=AL2(1)        Set number of members\n         MVC   BLDLA_LL(2),=AL2(BLDLA_ENTRYL) Move in entry length\n         MVC   BLDLA_ENTRY+(PDS2NAME-PDS2)(8),0(R1)\n         BLDL  (4),BLDLA                  Perform BLDL\n         L     R14,DOUBLE\n         BSM   0,R14\n*\n** Subroutine: Clear Message to blanks\n*\nInitialize_Message EQU *\n         MVI   Message,C' '               Get space\n         MVC   Message+1(L'Message-1),Message ..Propagate it\n         LA    R15,Message                Point to blank msg area\n         BSM   0,R14                      Return to caller\n*\n** Subroutine: Print message to IPCS or to TSO screen\n*\nPrint_Message EQU *\n         ST    R14,PM_RA                  Save Return address\n         TM    Flag1,$F1_TSOCP            TSO command processor?\n         BNO   PM$TPUT\n         la    r1,MessageH                Locate start\n         sr    r15,r1                     Length = end - start\n         sth   R15,MessageH               Save length\n         PUTLINE PARM=pm_PBLK,                                         @\n               OUTPUT=(MessageH,TERM,SINGLE,DATA),                     @\n               MF=(E,pm_IOPL)\n         l     r14,pm_ra\n         bsm   0,r14                      Return to caller\nPM$TPUT  DS    0H\n         TPUT  Message,79\n         L     R14,PM_RA\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***\n** Constants\n***\n***********************************************************************\n         SPACE 2\n         LTORG ,\n*\n** Messages\n*\nMSG00    DC    C'FINDMOD  - version &DAVER - '\n         DC    C'TSO module search command'\nMSG00L   EQU   *-MSG00\nMSG01    DC    C'Module name too long.  Must be 1-8 characters'\nMSG01L   EQU   *-MSG01\nMSG02    DC    C'..ISPLLIB not allocated'\nMSG02L   EQU   *-MSG02\nMSG03    DC    C'The system name is'\nMSG03L   EQU   *-MSG03\nMSG03B   DC    C'. Operating system is'\nMSG03BL  EQU   *-MSG03B\nMSG05    DC    C'Searching: '\nMSG05L   EQU   *-MSG05\nMSG05NF  DC    C'..Not found'\nMSG05JPAQ DC   C'JPAQ'\nMSG05ITL DC    C'ISPLLIB (ISPF Task library)'\nMSG05ALQ DC    C'Active LPA Queue'\nMSG05LNKI DC    C'LNKLST (IPL)'\nMSG05LNKS DC    C'LNKLST Set ('\nMSG05SVC DC    C'SVCLIB'\nMSG05LPA DC    C'LPA'\nMSG05NUC DC    C'Nucleus'\nMSG06    DC    C'>> Module '\nMSG06N   DC    CL8'********'\n         DC    C' found'\nMSG06L   EQU   *-MSG06\nMSG07    DC    C'.. Could not allocate DSN='\nMSG07L   EQU   *-MSG07\nMSG98    DC    C'Sorry but Generics are not supported yet'\nMSG98L   EQU   *-MSG98\nMSG99    DC    C'Module '\nMSG99N   DC    C'xxxxxxxx'\n         DC    C' was'\nMSG99L   EQU   *-MSG99\n*\nC_Putline PUTLINE MF=L\nC_Putlinel equ *-C_PutLine\nC_LSTI    OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL   EQU   *-C_LSTI\nC_TSKDCB  DCB   DSORG=PO,MACRF=R,DDNAME=CTASKDCB\nC_TSKDCBL EQU   *-C_TSKDCB\nC_CLOSE   CLOSE (*-*),MF=L\nC_CLOSEL  EQU   *-C_CLOSE\nC_SWAREQ  SWAREQ FCODE=RL,EPA=*-*,MF=L\nC_SWAREQL EQU *-C_SWAREQ\n\nTableOfGenerics DC 256X'00'\n         ORG   TableOfGenerics+C'*'\n         DC    C'*'\n         ORG   TableOfGenerics+C'%'\n         DC    C'%'\n         ORG   ,\n         DS    0D\nFINDMOD_length EQU *-FINDMOD\n         EJECT\n***********************************************************************\n***\n**  Dynamic Save Area\n***\n***********************************************************************\n\nWORKDS       DSECT ,\n             DS    18F                Register Save Area\nDOUBLE       DS    D                  Double word work area\nDOUBLE2      DS    2D                 Double word work area\nPARMLIST     DS    256X               Parameter list for calls\nSR_RA        DS    F                  Search Routine Return addr\nPP_PARMS     DS    2F                 Parse parms\nModuleName   DS    CL8                Module Name\nModuleCNT    DS    F                  Module Count\nDA_RA        ds    F                  Return Address\nAMA_RA       ds    F                  Return Address\nAC_SWAEPAX   DS    XL(L'SWAEPAX)      SWAEPAX area\nAC_RA        DS    F                  Return Address\nAC_SREG      DS    F                  Save register for routine\nSLNK_Area    DS    2F                 Getmained area\nRV_REGS      DS    3F                 Regs saved for Retrieve_VSLOC\n             ds    0f                 Print_Message routine:\nPM_RA        ds    F                  ..Return Address\npm_IOPL      ds    xl(#IOPL)          ..Input/Output Parm List\npm_PBLK      ds    xl(C_PutLineL)     ..PUTLINE block\npm_ECB       ds    f                  ..Input/Output Parm List\nMessageH     ds    xl4                Header for PUTLINE\nMessage      ds    CL133              Message area\n\nLPA_MJNM     DS    CL8\nLPA_EPA      DS    F\nLPA_VALID    DS    F\nLPA_LENGTH   DS    F\nLPA_MINOR    DS    X\n*\nBLDLA        DS    0F                 BLDL area\nBLDLA_FF     DS    X'00,00'           ..Total number of entries\nBLDLA_LL     DS    X'00,00'           ..Length of the area\nBLDLA_ENTRY  DS    XL(PDS2USRD-PDS2)  ..Start of user data\nBLDLA_USERD  DS    CL62               ..User data (enough for ISPF)\nBLDLA_ENTRYL EQU   *-BLDLA_ENTRY      ..Length of PDS entry\nBLDLAL       EQU   *-BLDLA            ..Length of PDS area\n             DS    0D\nW_TSKDCB     DS    XL(C_TSKDCBL)      Task DCB\n             CSVDYNL MF=(L,CSVDYNL)\n*\nFLAG1        DS    B'00000000'        Flag 1\n$F1_Found    EQU   B'10000000'        ..Found one in this area?\n$F1_TSOCP    EQU   B'01000000'        ..TSO command processor?\n$F1_Generics EQU   B'00100000'        ..Generic char in modname?\nMAXCC        DS    X                  Maximum condition code\n             DS    0D                 End of DSECT\nWORKDSL      EQU   *-WORKDS\n             END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HLASMTR": {"ttr": 21508, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00\\t\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18C\\x00\\xb7\\x00\\xb7\\x00\\x00\\xc4\\xc1\\xd3\\xc3\\xd6\\xc3\\xd2@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:43:09", "lines": 183, "newlines": 183, "modlines": 0, "user": "DALCOCK"}, "text": "/* REXX\n |\n | Name: HLASMTR\n |\n | Author: David Alcock\n |\n | Purpose: Trim HLASM non-essential output lines\n |\n | Note: John Ehrman, the Father of the HLASM, says that all\n |       screen scrappers (and this is one) are living in sin!\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code provided.\n |             It is copyright 1998-2002+ by David Alcock.\n |             All rights reserved.\n */\n\n/* --------------------------------------------------------------------\n |          M o d i f i c a t i o n   H i s t o r y\n |\n | Person     Date        Description\n | ---------- ----------- ---------------------------------------------\n | DGAlcock   14-NOV-1998 v1.1 Added check for option S\n +------------------------------------------------------------------ */\n\nvrm = '1.1'\n\nmtype = address()\nPARSE SOURCE s1 s2 s3 s4 s5 s6 s7 s8 s9\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then systemid = mvsvar(syssmfid)\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        systemid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse systemid = \"\"\n\nif substr(systemid,1,3) == \"XYZ\" then \"cls\" /* clear screen for Dave */\n\nsay \"HLASMTR - version \"vrm \"- Freeware - HLASM listing trimmer\"\nsay \"Copyright 1998 by David Alcock. All rights reserved.\"\nsay \" \"\nsay \". Executing in Environment: \"s1 \"-\" mtype\nif systemid <> \"\" then say \". Executing on system: \"systemid\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Locate args\n ------------------------------------------------------------------- */\n\naddress TSO\narg sysut1_dsn sysut2_dsn options\n\n/*---------------------------------------------------------------------\n | Set options\n ------------------------------------------------------------------- */\n\nin_good_stuff = 0\n\nif translate(options) == \"S\" then in_good_stuff = 1\n\n/*---------------------------------------------------------------------\n | Verify the input dataset and read it in\n ------------------------------------------------------------------- */\n\nif sysut1_dsn == \"\" then do\n   say \"Missing input dataset\"\n   exit 12\n   end\n\nx = LISTDSI(sysut1_dsn)\nif x <> 0 then do\n   say \"Error accessing DSN:\" sysut1_dsn\n   say \"> \"sysmsglvl1\n   say \"> \"sysmsglvl2\n   say \"> SYSREASON: \"sysreason\n   exit\n   end\n\nsysut1_pdsn = sysdsname\nparse value sysut1_dsn with . \"(\" member \")\" .\nif member <> \"\" then do\n   sysut1_pdsn = sysut1_pdsn\"(\"strip(member)\")\"\n   end\nsay \"%HLASMTR - Processing input file \"sysut1_pdsn\n\nsysut1_dd = \"SYU1\"random()\naddress TSO \"ALLOCATE FILE(\"sysut1_dd\") DA('\"sysut1_pdsn\"') SHR REUSE\"\n\"EXECIO * DISKR \"sysut1_dd\" (FINIS STEM sysut1_file.\"\naddress TSO \"FREE FILE(\"sysut1_dd\")\"\n\n/*---------------------------------------------------------------------\n | Verify the output dataset and create it if needed\n ------------------------------------------------------------------- */\n\nif sysut2_dsn == \"\" then do\n   sysut2_dsn = \"SPFTEMP1.HLASM.TRIMMED\"\n   end\n\nsysut2_dd = \"SYU2\"random()\n\nx = LISTDSI(sysut2_dsn)\nif x <> 0 then do\n   say \"Creating output file: \"sysut2_dsn\n   \"ALLOCATE FILE(\"sysut2_dd\") DA(\"sysut2_dsn\")\",\n            \"UNIT(SYSDA) NEW REUSE SPACE(30 30) TRACKS\",\n            \"LRECL(137) BLKSIZE(1410) RECFM(V B)\"\n   \"FREE FILE(\"sysut2_dd\")\"\n   y = LISTDSI(sysut2_dsn)\n   if y <> 0 then do\n      say \"Internal error after allocate of SYSUT2 file, terminating\"\n      exit 20\n      end\n   end\n\nsysut2_pdsn = sysdsname\nparse value sysut2_dsn with . \"(\" member \")\" .\nif member <> \"\" then do\n   sysut2_pdsn = sysut2_pdsn\"(\"strip(member)\")\"\n   end\n\n\"ALLOCATE FILE(\"sysut2_dd\") DA('\"sysut2_pdsn\"') SHR REUSE\"\n\n\n/*---------------------------------------------------------------------\n | Read the HLASM SYSPRINT output and trim out ANSI bytes and titles\n ------------------------------------------------------------------- */\n\nr = 0\ndo i = 1 to sysut1_file.0\n\n   if in_good_stuff == 0 then do\n      if substr(sysut1_file.i,4,4) == \"Loc \" then ,\n         in_good_stuff = 1\n      iterate\n      end\n\n   if substr(sysut1_file.i,1,1) == \"1\" then do\n      if word(sysut1_file.i,2) == \"Ordinary\"   then do\n         i = sysut1_file.0\n         say \"Found 'Ordinary' stopping\"\n         end\n      if word(sysut1_file.i,2) == \"Diagnostic\" then do\n         i = sysut1_file.0\n         say \"Found 'Diagnostic' stopping\"\n         end\n      if word(sysut1_file.i,2) == \"Macro\"      then do\n         i = sysut1_file.0\n         say \"Found 'Macro' stopping\"\n         end\n      iterate\n      end\n   if substr(sysut1_file.i,4,6) == \"Active\" then iterate\n   if substr(sysut1_file.i,4,4) == \"Loc \"   then iterate\n\n   line = substr(sysut1_file.i,2,length(sysut1_file.i)-1)\n   if strip(line) == \"\" then line = \" \"\n   queue line\n   r = r + 1\n\n   end\nSay \" \"\nSay \"Wrote \"r\" records from file with \"sysut1_file.0\" records\"\nSay \" \"\nSay \"That's all folks...\"\n\n/*********************************************************************\n* That's all folks...\n*********************************************************************/\n\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW \"sysut2_dd\" (FINIS\"\naddress TSO \"DELSTACK\"\naddress TSO \"FREE FILE(\"sysut2_dd\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMGCOPY": {"ttr": 21512, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x00H\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18&\\x00\\x7f\\x00w\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:26:48", "lines": 127, "newlines": 119, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: IMGCOPY (Image Copy)\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Written: 11-FEB-1998\n |\n | Purpose: Copy file SYSUT1 to file SYSUT2 with all bytes written\n |\n |          Can be used to copy .GIF and .JPG files from a\n |          larger blocksize dataset (like RECFM=VB LRECL=32756)\n |          to a smaller blocksize dataset (like RECFM=FB LRECL=10)\n |\n |          It should be used with care.  It is useful for PC\n |          files which are byte oriented and not record oriented.\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1998-2002+ by David Alcock\n |             All rights reserved.\n */\n\nxgdate = translate(date(),'-',' ')\nxjdate = substr(date('s'),1,4)\".\"substr(date('j'),3,3)\nxtime = time()\nsay \"%IMGCOPY - Execution starts - \"xgdate\" - \"xjdate\" - \"xtime\nsay \" \"\n\n/*---------------------------------------------------------------------\n |   Ensure our input and output files look okay\n ------------------------------------------------------------------- */\n\nx = LISTDSI('SYSUT1' 'FILE')\nif x <> 0 then do\n   say \"%IMGCOPY - Error with input SYSUT1 file\"\n   say \"           > \"sysmsglvl1\n   say \"           > \"sysmsglvl2\n   say \"           > SYSREASON: \"sysreason\n   exit\n   end\n\nx = LISTDSI('SYSUT2' 'FILE')\nif x <> 0 then do\n   say \"%IMGCOPY - Error with output SYSUT2 file\"\n   say \"           > \"sysmsglvl1\n   say \"           > \"sysmsglvl2\n   say \"           > SYSREASON: \"sysreason\n   exit\n   end\n\nsay \"%IMGCOPY - Output SYSUT2 file has LRECL=\"syslrecl\n\n/*---------------------------------------------------------------------\n |   Read SYSUT1 into a variable called \"FILE\" that will have a\n |   complete representation of the file\n ------------------------------------------------------------------- */\n\n\"EXECIO * DISKR SYSUT1 (FINIS STEM sysut1_file.\"\n\nfile = \"\"\ndo i = 1 to sysut1_file.0\n   file = file\"\"sysut1_file.i\n   drop sysut1_file.i\n   end\n\nsay \"%IMGCOPY - Found \"sysut1_file.0\" lines in input SYSUT1 file\"\n\n/*---------------------------------------------------------------------\n | Create the output file\n ------------------------------------------------------------------- */\n\n/*\n |   Queue up the records from the input file into the output file\n |   according to the lrecl of the output file.\n */\n\naddress TSO \"NEWSTACK\"   /* Place to put SYSUT2 output */\n\nk = length(file)\nj = k / syslrecl\nm = 1\n\ndo i = 1 to j\n   record = substr(file,m,syslrecl)\n   queue record\n   m = m + syslrecl\n   k = k - syslrecl\n   end\n\nif k <> 0 then do\n   record = left(substr(file,m,k),syslrecl,'00'x)\n   queue record\n   say \"%IMGCOPY - Last line had \"k\" good bytes\"\n   say \"           truncated with \"syslrecl-k \"binary zero bytes\"\n   end\n\nsay \"%IMGCOPY - Wrote \"j\" output lines to SYSUT2\"\n\n/*\n |   Write out the SYSUT2 file\n */\n\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW SYSUT2 (FINIS\"\nrc2 = rc\naddress TSO \"DELSTACK\"\n\nif rc2 <> 0 then ,\n   say \"%IMGCOPY - Error writing to SYSUT2, RC=\"rc2\n\n/*---------------------------------------------------------------------\n | Termination for IMGCOPY\n ------------------------------------------------------------------- */\n theend:\n\n xgdate = translate(date(),'-',' ')\n xjdate = substr(date('s'),1,4)\".\"substr(date('j'),3,3)\n xtime = time()\n say \" \"\n say \"%IMGCOPY - Execution ends - \"xgdate\" - \"xjdate\" - \"xtime\n exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMGINFO": {"ttr": 21515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x14\\x02\\x00\\x11\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18'\\x02\\x9f\\x02\\x9c\\x00\\x00\\xc4\\xc1\\xd3\\xc3\\xd6\\xc3\\xd2@@@\"", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:27:11", "lines": 671, "newlines": 668, "modlines": 0, "user": "DALCOCK"}, "text": "/* REXX\n |\n | Name: IMGINFO\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Display graphic file information for GIF and JPEG files\n |          suitable for HTML web page specifications\n |\n | Syntax:\n |\n | - PC:\n |   - IMGINFO name.gif\n |   - IMGINFO name.gif debug\n |   - IMGINFO name.gif debug verbose\n |   - IMGINFO c:\\directory\\name.gif\n |\n | - VM:\n |   - IMGINFO name gif\n |   - IMGINFO name gif w ( DEBUG\n |   - IMGINFO name gif w ( DEBUG VERBOSE\n |\n | - TSO (online or batch):\n |   - IMGINFO 'file.name.with.GIF.or.JPEG'\n |   - IMGINFO 'file.name.with.GIF.or.JPEG' CUT\n |   - IMGINFO 'file.name.with.GIF.or.JPEG' DEBUG\n |   - IMGINFO 'file.name.with.GIF.or.JPEG' DEBUG VERBOSE\n |\n | - Batch MVS (non-TSO batch):\n |\n |      //STEP1   EXEC PGM=IRXJCL,PARM='IMGINFO'\n |      //SYSUT1   DD DISP=SHR,DSN=IBMUSER.GIF(TREXX)\n |      //SYSTSIN  DD DUMMY\n |      //SYSTSPRT DD SYSOUT=*\n |      //SYSEXEC  DD DISP=SHR,DSN=IBMUSER.EXEC\n |\n |      //STEP1   EXEC PGM=IRXJCL,PARM='IMGINFO NAME TREXX'\n |      //SYSUT1   DD DISP=SHR,DSN=IBMUSER.GIF(TREXX)\n |      //SYSTSIN  DD DUMMY\n |      //SYSTSPRT DD SYSOUT=*\n |      //SYSEXEC  DD DISP=SHR,DSN=IBMUSER.EXEC\n |\n | Note: The CUT option is only available for online TSO.\n |\n |       The CUT option uses the method used by IBM ISRCUT and ISRPASTE\n |       edit macros supplied in the ISPF sample library.  After\n |       doing an \"IMGINFO dsn CUT\", you can then use the ISRPASTE\n |       command to put the \"<img ...>\" line into your edit dataset.\n |\n |       More than likely, ISRCUT and ISRPASTE have been copied as\n |       as commands CUT and PASTE at your shop.  If the PASTE\n |       command does not add a \"<img ...>\" line into your edit\n |       dataset, you may be using a different CUT and PASTE.  You\n |       will then want to copy ISRPASTE into your SYSPROC or\n |       SYSEXEC concatenation (as something other than PASTE like\n |       IPASTE or ISRPASTE) to get this CUT function.\n |\n | Verified: This REXX exec has been verified in April 1997 on:\n |           OS/390-TSO/E 2.5; VM/ESA 1.1; OS/2 Warp 3.0; and\n |           Object Windows beta (6.00 6 Aug 1996);\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1997-2002+ by David Alcock\n |             All rights reserved.\n |\n | More notes:\n | - GIF comments will only be displayed if it is in one of the \"GIF\n |   extension blocks\" immediately following the global color map.\n | - GIF terms mostly taken from GIF 87a standards which was easier\n |   to follow.\n */\n\n/**********************************************************************\n*           M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ---------------------------------------------\n* DGAlcock   21-APR-1998 v1.4 - Misc cleanup;\n* DGAlcock   21-NOV-1997 v1.3 - Allow Batch REXX execution;\n* DGAlcock   16-SEP-1997 v1.2 - Change to use CECP 1047 code page\n*                        translate table for ASCII translation on\n*                        EBCDIC systems;\n* DGAlcock   03-APR-1997 v1.1 Corrected CUT problem and added message;\n* DGAlcock   01-APR-1997 v1.0 Added GIF pixel, animation and comment\n*                        display; Added VERBOSE and DEBUG options;\n* DGAlcock   31-MAR-1997 v0.9 Initial exec written;\n**********************************************************************/\n\nvrm = '1.4'\n\nmtype = address()\nPARSE SOURCE s1 s2 s3 s4 s5 s6 s7 s8 s9\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then systemid = mvsvar(syssmfid)\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        systemid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse systemid = \"\"\n\nsay \"IMGINFO - version \"vrm \"- Freeware - Image file info utility\"\nsay \"Copyright 1997-1998 by David Alcock. All rights reserved.\"\nsay \" \"\nsay \". Executing in Environment: \"s1 \"-\" mtype\nif systemid <> \"\" then say \". Executing on system: \"systemid\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Read in the input file based on the environment\n ------------------------------------------------------------------- */\n\nebcdic = 0\n\nselect\n\n  /*--------------------------------------------------------------\n   | PC: OS/2, Windows 95, Windows NT, etc.\n   ------------------------------------------------------------ */\n\n  when mtype == \"CMD\" | mtype == \"COMMAND\" then do\n\n       arg imgfile options\n       filesize = chars(imgfile)\n       if filesize == 0 then do\n          say \"Error reading input file: \"imgfile\n          exit\n          end\n       file = charin(imgfile,1,filesize)\n       name = strip(imgfile)\n       end\n\n  /*--------------------------------------------------------------\n   | MVS (PGM=IRXJCL)\n   ------------------------------------------------------------ */\n\n  when mtype == \"MVS\" then do\n\n       arg options\n\n       ebcdic = 1\n\n       \"EXECIO * DISKR SYSUT1 (FINIS STEM imgfile.\"\n       erc = rc\n       if erc <> 0 then do\n          say \"Error reading //SYSUT1 file\"\n          exit\n          end\n       if imgfile.0 == 0 then do\n          say \"//SYSUT1 file is empty\"\n          exit\n          end\n\n       name = \"SYSUT1\"\n\n    end\n\n  /*--------------------------------------------------------------\n   | TSO (but not batch \"MVS\")\n   ------------------------------------------------------------ */\n\n  when mtype == \"TSO\" then do\n       ebcdic = 1\n       arg imgfile_dsn options\n\n       if imgfile_dsn == \"\" then do\n          \"Missing input dataset name, terminating\"\n          exit\n          end\n\n       x = LISTDSI(imgfile_dsn)\n       if x <> 0 then do\n          say \"Error accessing DSN:\" imgfile_dsn\n          say \"> \"sysmsglvl1\n          say \"> \"sysmsglvl2\n          say \"> SYSREASON: \"sysreason\n          exit\n          end\n       imgfile_pdsn = sysdsname\n       parse value imgfile_dsn with . \"(\" member \")\" .\n       if member <> \"\" then do\n          imgfile_pdsn = imgfile_pdsn\"(\"strip(member)\")\"\n          end\n\n       say \"Processing input file \"imgfile_pdsn\n       imgfile_dd = \"SYU1\"random()\n       address TSO \"ALLOCATE FILE(\"imgfile_dd\")\" ,\n                   \"DA('\"imgfile_pdsn\"') SHR REUSE\"\n\n       \"EXECIO * DISKR \"imgfile_dd ,\n               \"(FINIS STEM imgfile.\"\n       erc = rc\n       address TSO \"FREE FILE(\"imgfile_dd\")\"\n       if erc <> 0 then do\n          say \"Error reading input file: \"imgfile_pdsn\n          exit\n          end\n       if imgfile.0 == 0 then do\n          say \"Input file is empty: \"imgfile_pdsn\n          exit\n          end\n\n       if member == \"\" then name = \"UNKNOWN\"\n       else name = member\n       end\n\n  /*--------------------------------------------------------------\n   | VM files\n   ------------------------------------------------------------ */\n\n  when mtype == \"CMS\" then do\n       ebcdic = 1\n\n       parse arg fn ft fm \"(\" options\n\n       fn = strip(fn)\n       ft = strip(ft)\n       fm = strip(fm)\n       if fm == \"\" then fm = \"A\"\n\n       address command\n       \"STATE\" fn ft fm\n       if rc <> 0 then do\n          upper fn ft fm\n          \"STATE\" fn ft fm\n          if rc <> 0 then do\n             say \"File\" fn ft fm \"not found\"\n             exit\n             end\n          end\n\n       vmfclear\n       \"FINIS\" fn ft fm\n\n       \"EXECIO * DISKR \"fn ft fm\" (STEM IMGFILE. FINIS\"\n       erc = rc\n       if erc <> 0 then do\n          say \"Error reading input file: \"fn ft fm\n          exit\n          end\n       if imgfile.0 == 0 then do\n          say \"Input file is empty: \"fn ft fm\n          exit\n          end\n\n       name = fn\".\"ft\n       end\n\n  /*--------------------------------------------------------------\n   | Other systems that we don't support\n   ------------------------------------------------------------ */\n\n  otherwise\n       say \"Not written to support system type: \"mtype\n       say \"We do support: COMMAND, CMD, CMS, MVS and TSO\"\n       exit\n  end /* of \"select\" */\n\n/*---------------------------------------------------------------------\n | Parse options\n ------------------------------------------------------------------- */\n\ndebug = 0\ncut = 0\nverbose = 0\noptions = translate(options)\ndo i = 1 to words(options)\n   select\n     when word(options,i) == \"DEBUG\"   then debug   = 1\n     when word(options,i) == \"VERBOSE\" then verbose = 1\n     when word(options,i) == \"CUT\"     then cut     = 1\n     when word(options,i) == \"NAME\"    then do\n          j = i + 1\n          if j > words(options) then ,\n             say \"Name not given\"\n          else do\n               name = word(options,j)\n               i = j\n               end\n          end\n     otherwise\n          say \"Option '\"word(options,i)\"'\",\n              \"unknown and was ignored\"\n     end /* of select */\n   end\n\n/*---------------------------------------------------------------------\n | Perform functions for Mainframe environments\n ------------------------------------------------------------------- */\n\nif ebcdic then do\n\n   /*\n    |  ISO 8859-1 to CECP 1047 (Extended de-facto EBCDIC):\n    */\n\n   toEBCDIC =           '00010203372D2E2F1605250B0C0D0E0F'x  /* 00 */\n   toEBCDIC = toEBCDIC||'101112133C3D322618193F271C1D1E1F'x  /* 10 */\n   toEBCDIC = toEBCDIC||'405A7F7B5B6C507D4D5D5C4E6B604B61'x  /* 20 */\n   toEBCDIC = toEBCDIC||'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'x  /* 30 */\n   toEBCDIC = toEBCDIC||'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'x  /* 40 */\n   toEBCDIC = toEBCDIC||'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'x  /* 50 */\n   toEBCDIC = toEBCDIC||'79818283848586878889919293949596'x  /* 60 */\n   toEBCDIC = toEBCDIC||'979899A2A3A4A5A6A7A8A9C04FD0A107'x  /* 70 */\n   toEBCDIC = toEBCDIC||'202122232415061728292A2B2C090A1B'x  /* 80 */\n   toEBCDIC = toEBCDIC||'30311A333435360838393A3B04143EFF'x  /* 90 */\n   toEBCDIC = toEBCDIC||'41AA4AB19FB26AB5BBB49A8AB0CAAFBC'x  /* A0 */\n   toEBCDIC = toEBCDIC||'908FEAFABEA0B6B39DDA9B8BB7B8B9AB'x  /* B0 */\n   toEBCDIC = toEBCDIC||'6465626663679E687471727378757677'x  /* C0 */\n   toEBCDIC = toEBCDIC||'AC69EDEEEBEFECBF80FDFEFBFCBAAE59'x  /* D0 */\n   toEBCDIC = toEBCDIC||'4445424643479C485451525358555657'x  /* E0 */\n   toEBCDIC = toEBCDIC||'8C49CDCECBCFCCE170DDDEDBDC8D8EDF'x  /* F0 */\n\n   hextable =             '000102030405060708090A0B0C0D0E0F'x   /* 00 */\n   hextable = hextable || '101112131415161718191A1B1C1D1E1F'x   /* 10 */\n   hextable = hextable || '202122232425262728292A2B2C2D2E2F'x   /* 20 */\n   hextable = hextable || '303132333435363738393A3B3C3D3E3F'x   /* 30 */\n   hextable = hextable || '404142434445464748494A4B4C4D4E4F'x   /* 40 */\n   hextable = hextable || '505152535455565758595A5B5C5D5E5F'x   /* 50 */\n   hextable = hextable || '606162636465666768696A6B6C6D6E6F'x   /* 60 */\n   hextable = hextable || '707172737475767778797A7B7C7D7E7F'x   /* 70 */\n   hextable = hextable || '808182838485868788898A8B8C8D8E8F'x   /* 80 */\n   hextable = hextable || '909192939495969798999A9B9C9D9E9F'x   /* 90 */\n   hextable = hextable || 'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'x   /* A0 */\n   hextable = hextable || 'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'x   /* B0 */\n   hextable = hextable || 'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'x   /* C0 */\n   hextable = hextable || 'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'x   /* D0 */\n   hextable = hextable || 'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'x   /* E0 */\n   hextable = hextable || 'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'x   /* F0 */\n\n   filesize = 0\n   file = \"\"\n   do i = 1 to imgfile.0\n      file = file||imgfile.i\n      filesize = filesize + length(imgfile.i)\n      drop imgfile.i\n      end\n   drop imgfile.0\n   /* After here, imgfile.x vars are not needed and aren't valid */\n\n  end\n\n/*---------------------------------------------------------------------\n | Determine file type and call image routine\n ------------------------------------------------------------------- */\n\ncl1 = \"\"\nselect\n  when substr(file,1,3) == '474946'x then ,\n       call Show_Gif_info /* ---------------- 'GIF' in ASCII */\n  when substr(file,7,4) == '4A464946'x then ,\n       call Show_JPEG_info /* -------------- 'JFIF' in ASCII */\n  /* We could add PNG, XBM, etc file types here */\n  otherwise\n       say \"Unknown file type\"\n       end\n\n/*---------------------------------------------------------------------\n | If the CUT option is specified, save the cut line for later PASTE\n ------------------------------------------------------------------- */\n\nif cut then do\n   if mtype <> \"TSO\" then do\n      say \"CUT ignored for non-TSO environments\"\n      exit\n      end\n\n   if cl1 == \"\" then exit\n\n   if sysvar(sysispf) <> \"ACTIVE\" then do\n      say \"Can't cut <img> line since we are not in ISPF\"\n      exit\n      end\n\n   address ispexec\n   /* Attempt to delete old profile vars */\n   'VGET (CUTCNT) PROFILE'\n   if cutcnt == \"\" then cutcnt = 0\n   do i = 1 to cutcnt\n      'VERASE (CL'i') PROFILE'\n      end\n\n   /* Save our new cut line */\n   cutcnt = 1\n   address ispexec\n   'VPUT (CUTCNT) PROFILE'\n   'VPUT (CL1) PROFILE'\n   vputrc = rc\n   if vputrc == 0 then say \"<IMG.. line cut and is\" ,\n      \"ready for paste\"\n   end\n\nexit\n\n/*---------------------------------------------------------------------\n | Show JPEG information\n |\n | JPEG stands for Joint Photographic Experts Group\n |\n | The logic to look inside the JPEG file was modeled after the PERL\n | script written by Alex Knowles (alex@ed.ac.uk) found at URL:\n | http://www.avs.com/~ark/wwwis/\n |\n |    Sample JPEG Header:\n |\n |            Marker: FFD8\n |                 ?: FFE00010\n |                    J F I F           (JPEG File Interchange Format)\n |                ID: 4A464946          (Remember: this is in ASCII)\n |\n | <img width=102 height=36 src=\"sample.jpg\" alt=\"sample\">\n ------------------------------------------------------------------- */\n\nShow_JPEG_Info:\n\nsay \"JPEG file found\"\ncall Show_Byte_Count\n\nwidth = 0\ndo i = 1 to length(file)\n   if substr(file,i,1) == 'ff'x then do\n      /* debug: say \"Found marker=\"c2x(substr(file,i,2)) */\n      j = i + 1\n      if substr(file,j,1) >= 'C0'x then ,\n         if substr(file,j,1) <= 'C3'x then do\n            /* debug: say \"Found length marker=\"c2x(substr(file,i,16)) */\n            width = substr(file,i+7,2)\n            height = substr(file,i+5,2)\n         end\n      end\n   end\nif mtype == \"TSO\" | mtype == \"MVS\"  then name = name\".JPG\"\n\nif width == 0 then  say \"JPEG length marker not found\"\nelse do\n     say \"HTML JPEG specification:\"\n     cl1 = '<img width='c2d(width) ,\n           'height='c2d(height) ,\n           'src=\"'name'\"' ,\n           'alt=\"put text here\">'\n     say '          ' cl1\n     end\nreturn\n\n/*---------------------------------------------------------------------\n | Show GIF information\n |\n | GIF stands for Graphic Interchange Format\n |\n | Remember that GIF uses \"little endian\" format so the binary values\n | like for Screen_Width are \"backwards\".  This is also known as LSB,\n | Least Significant Byte.  INTEL processors use this byte addressing\n | scheme. Examples of computers that use the alternative \"big endian\"\n | byte addressing format are IBM mainframes and Apple Macintoshs\n | (both PowerPC and 68K).\n |\n | <img width=102 height=36 src=\"sample.gif\" alt=\"sample\">\n |\n |    GIF file format:\n |\n |                    G I F 8 7 a\n |     GIF Signature: 474946383761      (Remember: this is in ASCII)\n |\n | Screen Descriptor -----------------------------------------------+\n |      Screen_Width: 6600              (should be '0066'x = 102)   |\n |      Screen_Depth: 2400              (should be '0024'x = 36)    |\n |       Global_Flag: F7                                            |\n |  Background_Color: 00                                            |\n |        Header_End: 00                (should always be zero      |\n |                    ----------------------------------------------+\n |\n |  Global Color Map (optional, based on Global_Flag having x'80' on)\n |\n | Image Descriptor  ---- +\n |   Local Color Map ---- |  Repeated 1 to n times\n |       Raster Data ---- +\n |\n |    GIF Terminator\n |\n ------------------------------------------------------------------- */\n\nShow_Gif_Info:\n\nGIF_Signature = substr(file,1,6)\nif ebcdic then ,\n   GIF_Signature = translate(GIF_Signature,toEBCDIC,hextable)\n\nScreen_Descriptor = substr(file,7,7)\nw1 = substr(Screen_Descriptor,1,1)\nw2 = substr(Screen_Descriptor,2,1)\nscreen_width = w2||w1\n\nh1 = substr(Screen_Descriptor,3,1)\nh2 = substr(Screen_Descriptor,4,1)\nscreen_depth = h2||h1\n\nsay \"GIF file found - Signature: \"GIF_Signature\ncall Show_Byte_Count\nif mtype == \"TSO\" | mtype == \"MVS\"  then name = name\".GIF\"\n\nsay \"HTML GIF specification:\"\ncl1 = '<img width='c2d(screen_width) ,\n      'height='c2d(screen_depth) ,\n      'src=\"'name'\"' ,\n      'alt=\"put text here\">'\nsay ' '\nsay '          ' cl1\n\n/* The rest of this code is not needed for the <img> output */\n\nsay ' '\nif debug then call Hex_Dump 1 13 'GIF signature and Screen Descriptor'\nGlobal_Flag = substr(Screen_Descriptor,5,1)\nif debug then say \"Global_Flag=\"c2x(Global_Flag)\n\nif bitand(Global_Flag,'80'x) = '80'x then m = 1\nelse m = 0\n\nbits = 0\nif bitand(Global_Flag,'04'x) = '04'x then bits = bits + 4\nif bitand(Global_Flag,'02'x) = '02'x then bits = bits + 2\nif bitand(Global_Flag,'01'x) = '01'x then bits = bits + 1\nbits = bits + 1\npixels = 2 ** bits\n/* Note: The pixels value is NOT necessarily the number of pixels\n   in the GIF, this is used for the calculation of the Global\n   Color Map length */\nif debug then say \"Number of pixels is \"pixels ,\n   \"bits=\"bits \"(Global Color Map)\"\n\ncurloc = 6 + 7 + 1\ngcmlen = 0\nif m == 1 then do\n   gcmlen = pixels * 3\n   if debug then ,\n      if verbose then ,\n         call Hex_Dump curloc gcmlen 'Global Color Map'\n   end\ncurloc = curloc + gcmlen\neblkl = 0\n\nhave_extensions = 1\ndo while have_extensions\n   /* See if we have a GIF extension block */\n   if substr(file,curloc,1) == '21'x then do\n      if debug then say \"Found GIF Extension Block -\",\n         \"code=\"c2x(substr(file,curloc+1,1))\n\n      /* Note: Do I need a test for \"Netscape\" (mixed case) here? */\n      agifc ='4E45545343415045322E30'x /* \"NETSCAPE2.0\" in ASCII */\n      select\n         when substr(file,curloc+1,1) == 'ff'x then do\n              if substr(file,curloc+3,11) == agifc  then do\n                 say \"This is an Animated GIF\"\n                 say \" \"\n                 end\n              end\n         when substr(file,curloc+1,1) == 'fe'x then do\n              say \"GIF comments found:\"\n              say \" \"\n              clen = c2d(substr(file,curloc+2,1))\n              line = \"\"\n              off = curloc + 3\n              do i = 1 to clen\n                 if substr(file,off,2) == '0D0A'x then do\n                    if ebcdic then line = translate(line,toEBCDIC,hextable)\n                    say line\n                    line = \"\"\n                    i = i + 1\n                    off = off + 2\n                    end\n                 else do\n                      line = line\"\"substr(file,off,1)\n                      off = off + 1\n                      end\n                 end\n\n              if line <> \"\" then do\n                 if ebcdic then line = translate(line,toEBCDIC,hextable)\n                 say line\n                 end\n              say \" \"\n\n              end\n         otherwise\n              nop\n         end\n\n      eblkl = 3\n      eblko = curloc + 2\n      bc = 1\n      do while bc <> 0\n         bc = c2d(substr(file,eblko,1))\n         eblkl = eblkl + bc\n         eblko = eblko + bc + 1\n         end\n      eblkl = eblkl + 1\n      if debug then call Hex_Dump curloc eblkl 'GIF Extension Block'\n      end\n   else do\n        if debug then call Hex_Dump curloc 32 'Next Section'\n        have_extensions = 0\n        end\n   curloc = (curloc + eblkl) + 1\n   end\nreturn\n\n/*---------------------------------------------------------------------\n | Hex dump of portions of the file\n ------------------------------------------------------------------- */\n\nHex_Dump:\n\nparse arg dstart dlen dtitle\nsay  ' '\nsay  'Dump of: 'dtitle\nsay  '+offset 0 1 2 3  4 5 6 7  8 9 a b  c d e f'\ndoffset = dstart\ndleft = dlen\ndo h = 1 to dlen by 16\n   doff = '+'right(d2x(doffset-1),6,'0')\n   if dleft < 16 then dgrab = dleft\n   else dgrab = 16\n   dline = substr(file,doffset,dgrab)\n   dhex = \"\"\n   do dj = 1 to dgrab\n      if dj == 4 | dj == 8 | dj == 12 then dspace = \" \"\n      else dspace = \"\"\n      dhex = dhex\"\"c2x(substr(dline,dj,1))\"\"dspace\n      end\n   if ebcdic then do\n      dchars = translate(dline,toEBCDIC,hextable)\n      dchars = translate(dchars,copies('.',32),xrange('00'x,'1f'x))\n      end\n   else dchars = translate(dline,copies('.',32),xrange('00'x,'1f'x))\n\n   say doff left(dhex,35) \"*\"left(dchars,16)\"*\"\n   doffset = doffset + 16\n   dleft = dleft - 16\n   end\n\nreturn\n\n/*---------------------------------------------------------------------\n | Show byte count\n |\n | Question: Should I use 1000 or 1024????????\n ------------------------------------------------------------------- */\n\nShow_Byte_Count:\n\nif filesize < 1000 then say \"Byte count:\" filesize\nelse do\n     filesizek = filesize % 1000\n     say \"Byte count:\" filesizek\"k (\"filesize\")\"\n     end\n\nreturn\n\n/*---------------------------------------------------------------------\n | END END END END END - End of IMGINFO exec - END END END END END\n ------------------------------------------------------------------- */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISGECMOM": {"ttr": 21769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00\\x10\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18(\\x02J\\x02F\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:28:10", "lines": 586, "newlines": 582, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 1000-97157-97157-1412-00062-00062-00000-DAVE\n ISGECMOM - an enhancement to IBM's sample program ISGECMON - June 1997\n\n This package contains directions to modify your copy of IBM's\n ISGECMON, a program that comes with MVS v4.3 and higher that informs\n TSO users about enqueue problems in real time.  ISGECMON is no\n where as nice as the MIM product from Legent (oops CA).\n\n IBM's version of ISGECMON isn't too fancy so this enhancer was\n written (which only adds modest functions). Some of the things it adds:\n\n   - Stopping of the ISGECMON via \"P ISGECMON\" and \"F ISGECMON,STOP\"\n     I think that ALL started tasks should have this capability.\n\n   - Show some statistics about errors number of notifies sent via\n     command: \"F ISGECMON,STAT\"\n\n Other functions could be added to this never ending task.  Remember\n that modify and stop commands will not be immediate since ISGECMON\n has an user specified interval where \"he\" is asleep.\n\n File contents:\n\n $$README ... This member\n $ASM     ... Sample JCL to assemble ISGECMON and ISGECMOM\n $CHANGES ... Changes needed to ISGECMON\n ISGECMOM ... Program called by the modifed verision of ISGECMON\n\n Installation directions:\n\n 1) Copy 'SYS1.SAMPLIB(ISGECMON)' into this library as member ISGECMON.\n\n 2) Make the changes to ISGECMON as shown in the $CHANGES member. I\n    don't distribute a modified ISGECMON since it is IBM software.\n\n 3) Assemble and link ISGECMON and ISGECMOM into a LNKLST dataset\n    using the $ASMLINK member.\n\n 4) Create the started task JCL proc as described in the comments in\n    IBM's ISGECMON.  I would suggest adding \",TIME=1440\" to the EXEC\n    card.\n\n 5) Start the ISGECMON started task and issue commands to it as needed.\n\n =====================================================================\n\n\n Disclaimer: This modification is FREEWARE.  Use at your own risk.  It\n             is provided for your enjoyment and neither David\n             Alcock or his employer provides any warranty for it's\n             use.  I'd like to hear how it works on your system.\n\n             This software is not in the public domain but is\n             available free of charge and with source code\n             provided.  It is copyright 1997-2002+ by David Alcock\n             All rights reserved.\n\nDavid Alcock :: dave@planetmvs.com\n\n =====================================================================\n./ ADD NAME=$ASMLINK 1000-97157-97157-1412-00040-00040-00000-DAVE\n  -- PUT JOBCARD HERE --\n//*********************************************************************\n//***                                                               ***\n//**  ASSEMBLE AND LINK THE ISGECMON/ISGECMOM PACKAGE                **\n//***                                                               ***\n//*********************************************************************\n//*\n//** ASSEMBLE ISGECMOM\n//*\n//ISGECMOM EXEC HLASMC\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSLIN DD DSN=&&MOM,SPACE=(TRK,(5,5)),\n//            DISP=(MOD,PASS),UNIT=SYSDA,\n//            DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.PACKAGE.ISGECMOM.V10(ISGECMOM)\n//*\n//** ASSEMBLE ISGECMON\n//*\n//ISGECMON EXEC HLASMC\n//C.SYSLIB DD\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSIN  DD DISP=SHR,DSN=IBMUSER.PACKAGE.ISGECMOM.V10(ISGECMON)\n//*\n//** LINK IT ALL TOGETHER\n//*\n// IF (RC < 8) THEN\n//LINKEDIT EXEC  PGM=IEWL,REGION=5000K,\n//         PARM='XREF,LET,NCAL,RENT,REUS,AC=1'\n//SYSPRINT  DD SYSOUT=*\n//SYSUT1    DD UNIT=SYSDA,SPACE=(CYL,(5,2))\n//SYSLMOD   DD DISP=SHR,DSN=YOUR.LINKLIB,      <- CHANGE THIS!!!!!\n//             UNIT=3390,VOL=SER=XXXXXX        <- CHANGE THIS!!!!!\n//SYSLIN    DD DISP=SHR,DSN=&&OBJ  (ISGECMON)\n//          DD DISP=SHR,DSN=&&MOM  (ISGECMOM)\n//          DD *\n  ENTRY ISGECMON\n  ORDER ISGECMON,ISGECMOM\n  NAME ISGECMON(R)\n// ENDIF\n./ ADD NAME=$CHANGES 1000-97157-97157-1412-00061-00061-00000-DAVE\n !!! Here are the changes that are needed to the ISGECMON program !!!\n\n\n !!! -> Right after the INIT label, add this code:\n\n*-INIT-start - - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n#MOMPARM EQU   72                         ISGECMOM's field I_PARM   MOM\n#MOMERR  EQU   72+4                       ISGECMOM's field W_COUNT  MOM\n#MOMNOT  EQU   72+8                       ISGECMOM's field W_NOTIFY MOM\n#MOMOPT  EQU   72+12                      ISGECMOM's field I_OPTION MOM\n         ICM   R15,B'1111',=V(ISGECMOM)   Locate MOM                MOM\n         BZ    MOM$IX                     Not found, leave          MOM\n         MVC   MOM_EC(8),=CL8'MOMWA'      Set eyecatcher            MOM\n         MVI   MOM_WA+#MOMOPT,C'I'        Set entry code: INIT      MOM\n         LA    R1,SAVE1                   Locate parmlist for call  MOM\n         ST    R1,MOM_WA+#MOMPARM         Save input parm list addr MOM\n         LA    R14,INTERVAL               Locate interval           MOM\n         ST    R14,SAVE1                  Save address              MOM\n         LA    R14,=AL4(MAXMSGS,MAXOWNER,AREASIZE) Locate parms     MOM\n         ST    R14,SAVE1+4                Save address              MOM\n         LA    R1,MOM_WA                  Point to work area        MOM\n         BALR  R14,R15                    Call ISGEC-MOM            MOM\nMOM$IX   DS    0H                                                   MOM\n*-INIT-end - - - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n\n !!! -> Right after the ERROR label, add this code:\n\n*-ERROR-start- - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n         L     R1,MOM_WA+#MOMERR       Get current count            MOM\n         LA    R1,1(R1)                Increase by one              MOM\n         ST    R1,MOM_WA+#MOMERR       Save new count               MOM\n*-ERROR-end- - - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n\n !!! -> Right after the WAIT label, add this code:\n\nWAIT     EQU    *\n*-WAIT-start - - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n         ICM   R15,B'1111',=V(ISGECMOM)   Locate MOM                MOM\n         BZ    MOM$WX                     Not found, leave          MOM\n         MVI   MOM_WA+#MOMOPT,C'W'        Set entry code: INIT      MOM\n         LA    R1,MOM_WA                  Point to work area        MOM\n         BALR  R14,R15                    Call ISGEC-MOM            MOM\n         CLI   MOM_WA+#MOMOPT,X'FF'       Time to go?               MOM\n         BE    COMPLETE\nMOM$WX   DS    0H                                                   MOM\n*-WAIT-end - - - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n\n !!! -> Right _before_ the NOSEND label, add this code:\n\n*-SENDMSG-start- - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n         L     R1,MOM_WA+#MOMNOT       Get current count            MOM\n         LA    R1,1(R1)                Increase by one              MOM\n         ST    R1,MOM_WA+#MOMNOT       Save new count               MOM\n*-SENDMSG-end- - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n\n !!! -> Right after the SAVEAREA field/label, add this code:\n\n*-DYNA-start - - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\nMOM_EC   DS     CL8'MOMWA'             Eyecatcher for dumps         MOM\nMOM_WA   DS     18F,XL512              Work area for ISGECMOM       MOM\n*-DYNA-end - - - - - - - - - - - - - - - - - - - - - - - - - - - - -MOM\n./ ADD NAME=ISGECMOM 1000-97157-97157-1412-00418-00418-00000-DAVE\n***********************************************************************\n***                                                                 ***\n** Name: ISGECMOM                                                    **\n**                                                                   **\n** Purpose: Enhancement to IBM's bare bones ISGECMON, this code      **\n**          will act as ISGECMON's MOM and run it's life.  This      **\n**          program is called at various points from the slightly    **\n**          modified ISGECMON that comes from IBM.                   **\n**                                                                   **\n**          This program adds these features:                        **\n**          - Allow operator communication for modifies and stops    **\n**          - Show errors and the number of notifies                 **\n**                                                                   **\n** Input: R0 has the input code: I=INIT W=WAIT                       **\n**        R1 points to a RSA and work area                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   06-JUN-1997 Made statistics a subroutine that is also  **\n**                        called at termination;                     **\n** DGAlcock   25-FEB-1997 Initial program created;                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\n         IEFJESCT ,                       JES Communications Table\n         CVT DSECT=YES,LIST=NO,PREFIX=YES Communications Vector Tbl\n         DSECT ,\n         IEZCOM ,                         Communications parameter list\n         DSECT ,\n         IEZBITS ,                        Generate Bit settings\n         IEZCIB ,                         Command Input Buffer\n         YREGS ,\n         PRINT GEN\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY/MM/DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Initialization, control passing and termination             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nISGECMOM CSECT ,\nISGECMOM AMODE 31\nISGECMOM RMODE ANY\n*\n** Create a standard O/S eyecatcher\n*\nEC       B     ECL(0,R15)               Bump past Eyecatcher\n         DC    AL1(L'ECLIT)             Length of eyecatcher\nECLIT    DC    C'ISGECMOM &ASMDATE &SYSTIME - Enhancement to ISGECMON'\n         DS    0H                       Ensure halfword alignment\nECL      EQU   *-EC\n*\n** Entry housekeeping\n*\n         BAKR  R14,0                    Save registers\n         LAE   R12,0(R15,0)             Get base register\n         LAE   R11,2048(,R12)           Set up for second base reg\n         LA    R11,2048(,R11)           Locate 4096 past R12\n         USING ISGECMOM,R12,R11         Set module base\n         SAC   0\n         SYSSTATE ASCENV=P\n         LR    R13,R1                   Locate input area\n         USING DSA,R13                  Get addressability to it\n         MVC   4(4,R13),=C'F1SA'        Set up Register Save Area\n*\n** Why are we here?\n*\n         CLI   I_OPTION,C'I'            Initialization?\n         BE    MOM$INIT                 Yes, do it\n         CLI   I_OPTION,C'W'            Before ISGECMON's wait?\n         BE    MOM$WAIT                 Yes, do it\n*\n** Exit\n*\nEXIT     DS    0H\n         PR    ,                        Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Call is for INIT option                                     **\n**                                                                   **\n** I_PARM points to a parmlist:                                      **\n** - Fullword 1 - Address of interval (fullword)                     **\n** - Fullword 2 - Address of:                                        **\n**   - MAXMSGS (fullword)\n**   - MAXOWNER (fullword)\n**   - AREASIZE (fullword)\n***                                                                 ***\n***********************************************************************\n SPACE 2\nMOM$INIT DS 0H\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG01L,R15),MSG01      Get message\n         WTO   ,MF=(E,WTOAREA)\n*\n** Print Interval value\n*\n         L     R2,I_PARM                Get input parameter list addr\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG02L,R15),MSG02      Get message\n         LA    R15,MSG02L+1(R15)\n         L     R1,0(R2)                 Get address of Interval\n         L     R1,0(R1)                 Get interval\n         SLR   R0,R0                    Clear for divide\n         D     R0,=F'100'               Convert to normal\n         BAS   R14,EDITFWF              Edit number\n         MVC   1(7,R15),=C'seconds'\n         WTO   ,MF=(E,WTOAREA)\n*\n** Print some of the variable information that ISGECMON was assembled\n*\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG03L,R15),MSG03      Get message\n         WTO   ,MF=(E,WTOAREA)\n*\n         L     R2,4(R2)                 Locate to assemble fullwords\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(3,R15),MSG03           Get \"03I\"\n         LA    R15,4(R15)               Bump past \"03I \"\n         MVC   0(8,R15),=C'MAXMSGS='    Insert text\n         LA    R15,8(R15)               Bump past text\n         L     R1,0(R2)                 Get value\n         BAS   R14,EDITFWF              Edit it out\n         MVC   0(11,R15),=C', MAXOWNER=' Insert text\n         LA    R15,11(R15)              Bump past text\n         L     R1,4(R2)                 Get value\n         BAS   R14,EDITFWF              Edit it out\n         MVC   0(11,R15),=C', AREASIZE=' Insert text\n         LA    R15,11(R15)              Bump past text\n         L     R1,8(R2)                 Get value\n         BAS   R14,EDITFWF              Edit it out\n         WTO   ,MF=(E,WTOAREA)\n*\n** Set up to receive \"P jobname\" and \"F jobname,command\"\n*\n         LA    R9,WR_COMMA              Locate return area\n         MVC   DOUBLE(C_EXTL),C_EXT     Initialize parm list\n         EXTRACT (9),FIELDS=COMM,       Locate communication field     @\n               MF=(E,DOUBLE)            Will overflow from DOUBLE-...\n         L     R9,WR_COMMA              Locate return area\n*\n         L     R1,COMCIBPT-COMLIST(R9)  Locate first CIB\n         MVC   WR_CONID(1),CIBCONID-CIBNEXT(R1)   Save console ID\n*\n         LA    R0,COMCIBPT-COMLIST(R9)  Locate first CIB\n         QEDIT ORIGIN=(0),CIBCTR=7      Accept 7 modifies\n*\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG04L,R15),MSG04      Get message\n         WTO   ,MF=(E,WTOAREA)          Issue message\n         B     EXIT\n         EJECT\n***********************************************************************\n***                                                                 ***\n** This code gets invoked when ISGECMON goes to its Wait routine     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMOM$WAIT DS    0H\n*\n** See if the operator wants us to stop or has something he wants us\n** to do\n*\nWR$OPR   DS    0H\n         L     R8,WR_COMMA              -> Communications area\n         ICM   R9,B'1111',COMCIBPT-COMLIST(R8) Obtain address of CIB\n         BZ    WR$OPRX                  None, continue\nWR$OL    DS    0H\n         CLI   CIBVERB-CIBNEXT(R9),CIBSTOP Operator stopped us?\n         BNE   WR$OLSX                  No, continue\n         MVC   WR_CONID(1),CIBCONID-CIBNEXT(R9)   Save console ID\nWR$OSTP  DS    0H\n         BAS   R7,PRINT_STATS           Print stats\n         MVI   I_OPTION,X'FF'           Indicate STOP\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG99L,R15),MSG99      Get message\n         LA    R15,MSG99L(R15)          Bump past it\n         SLR   R1,R1                    Clear register\n         IC    R1,WR_CONID              Get console ID\n         BAS   R14,EDITFWF              Edit it\n         BAS   R14,APPEND_CONSOLE_NAME  Append console name\n         WTO   ,MF=(E,WTOAREA)          Issue message\n         B     EXIT\nWR$OLM   MVC   0(0,R15),0(R1)           Move field out\nWR$OLSX  DS    0H\n*\n         CLI   CIBVERB-CIBNEXT(R9),CIBMODFY Modify?\n         BNE   WR$OMX                   No, continue\n         MVC   WR_CONID(1),CIBCONID-CIBNEXT(R9)   Save console ID\n         LH    R14,CIBDATLN-CIBNEXT(R9) Get length of cmd\n         LA    R1,CIBDATA-CIBNEXT(R9)   Locate the command\n*\n         CH    R14,=H'4'                Length for \"STOP\"\n         BL    WR$OMSX                  Not enough room\n         CLC   0(4,R1),=C'STOP'         Operator asked for stop?\n         BE    WR$OSTP                  Yes, do it\nWR$OMSX  DS    0H\n*\n         CH    R14,=H'2'                Minimum length of \"ABEND\"\n         BL    WR$OMABX                 No, move on\n         CLC   0(2,R1),=C'AB'           ABEND?\n         BNE   WR$OMABX                 No, continue\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG96L,R15),MSG96      Get message\n         WTO   ,MF=(E,WTOAREA)          Issue message\n         DC    A(0)                     Cause S0C1 ABEND\nWR$OMABX DS    0H\n*\n         CH    R14,=H'3'                Minimum length of \"STATUS\"\n         BL    WR$OMSTX                 No, move on\n         CLC   0(3,R1),=C'STA'          Is it status?\n         BNE   WR$OMSTX                 No, continue\n*\n         BAS   R7,PRINT_STATS           Print stats\n         B     WR$OML                   Continue\nWR$OMSTX DS    0H\n*\n         ST    R14,DOUBLE2              Save length\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG98L,R15),MSG98      Get message\n         LA    R15,MSG98L(R15)          Bump past it\n         L     R14,DOUBLE2              Restore length\n         CH    R14,=H'9'                More than max to display?\n         BL    WR$M98                   No, it's okay\n         LA    R14,9                    Truncate to 8 characters\nWR$M98   DS    0H\n         BCTR  R14,0                    Decrement for EX\n         EX    R14,WR$OLM               Move out bad command\n         LA    R15,1(R14,R15)           Bump past it\n         MVC   0(24,R15),=C'\" received from console=' Insert text\n         LA    R15,24(R15)              Bump past text\n         SLR   R1,R1                    Clear register\n         IC    R1,WR_CONID              Get console ID\n         BAS   R14,EDITFWF              Edit it\n         BAS   R14,APPEND_CONSOLE_NAME  Append console name\n         WTO   ,MF=(E,WTOAREA)          Issue message\n*\nWR$OML   DS    0H\n         LA    R0,COMCIBPT-COMLIST(R8)  Locate it\n         QEDIT ORIGIN=(0),BLOCK=(9)     Free CIB in R9\nWR$OMX   DS    0H\n*\n         ICM   R9,B'1111',CIBNEXT-CIBNEXT(R9)  Any more CIBs?\n         BNZ   WR$OL                    Yes, continue\nWR$OPRX  DS    0H\n         B     EXIT                     Leave\n         EJECT\n***********************************************************************\n***                                                                 ***\n**     Misc subroutines                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Print stats\n*\nPRINT_STATS DS 0H\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(MSG97L,R15),MSG97      Get message\n         LA    R15,MSG97L(R15)          Bump past it\n*\n         MVC   1(7,R15),=C'Notify='     Move in text\n         LA    R15,1+7(R15)             Bump past it\n         L     R1,W_NOTIFY              Get number\n         BAS   R14,EDITFWF              Edit it\n         MVC   0(9,R15),=C', Errors='   Move in text\n         LA    R15,9(R15)               Bump past it\n         L     R1,W_ERROR               Get number\n         BAS   R14,EDITFWF              Edit it\n         WTO   ,MF=(E,WTOAREA)          Issue message\n         BSM   0,R7\n*\n** Format the message area for a WTO\n*\nFORMAT_MSG DS 0H\n         LA    R15,WTOAREA              Locate area\n         MVC   0(C_WTOL,R15),C_WTO      Initialize area\n         MVC   4(9,R15),=C'ISGEC-MOM'   Get ID\n         LA    R15,4+9(R15)             Bump past area\n         BSM   0,R14\n*\n** Edit register 1 flush\n** Input: R1 - Value to edit\n**        R15 - Where edited value is to be put\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                    CHECK FOR 0\n         BZ    EDITFWF0                 YES, PUT ZERO\n         ST    R14,EF_RA                Save return address\n         CVD   R1,DOUBLE                NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14            LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\nEF$EDMK  EQU   *\n         EDMK  DOUBLE2(15),DOUBLE+2     EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16           LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                   LENGTH = END - START\n         BCTR  R14,0                    DECREMENT FOR EX\n         EX    R14,EDITFWFM             MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)           BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '              Fix unprintable character\n         L     R14,EF_RA                Get return address\n         BSM   0,R14                    RETURN TO CALLER\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'              PUT IN ZERO\n         LA    R15,1(R15)               BUMP POINTER PAST ZERO\n         BSM   0,R14                    RETURN TO CALLER\n*\n** Append console name to message if there is a CIB extension\n*\nAPPEND_CONSOLE_NAME EQU *\n         ST    R14,DOUBLE\n         L     R1,WR_COMMA              -> Communications area\n         ICM   R1,B'1111',COMCIBPT-COMLIST(R1) Obtain address of CIB\n         SLR   R14,R14                  Clear register\n         ICM   R14,B'0011',CIBXOFF-CIBNEXT(R1)  Locate offset\n         BZ    ACN$X                    No offset, not at SP4\n         AR    R1,R14                   Locate to Extension\n         MVI   0(R15),C'/'              Insert text\n         MVC   1(8,R15),CIBXCNNM-CIBX(R1) Move in console name\n         LA    R15,1+8(R15)             Bump past \"/consname\"\nACN$X    EQU   *\n         L     R14,DOUBLE\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n SPACE 2\nMSG01    DC    C'01I Starting - ISGECMOM last asembled on '\n         DC    C'&ASMDATE at &SYSTIME'\nMSG01L   EQU   *-MSG01\nMSG02    DC    C'02I ISGECMON was invoked using an interval of'\nMSG02L   EQU   *-MSG02\nMSG03    DC    C'03I ISGECMON was assembled using these values:'\nMSG03L   EQU   *-MSG03\nMSG04    DC    C'04I Accepting operator commands'\nMSG04L   EQU   *-MSG04\nMSG96    DC    C'96I Scheduling S0C1 ABEND as requested'\nMSG96L   EQU   *-MSG96\nMSG97    DC    C'97I Status:'\nMSG97L   EQU   *-MSG97\nMSG98    DC    C'98W Unknown command \"'\nMSG98L   EQU   *-MSG98\nMSG99    DC    C'99I Operator has stopped us, console='\nMSG99L   EQU   *-MSG99\n*\nC_WTO    WTO   '                                                       @\n                                         ',MF=L\nC_WTOL   EQU   *-C_WTO\n*\nC_EXT    EXTRACT *-*,'S',FIELDS=COMM,MF=L\nC_EXTL   EQU   *-C_EXT\n*\n** Literals\n*\nLTORG    EQU   *\n         LTORG ,\nLTORGL   EQU   *-LTORG\n         DS    0D\n*\n** Determine length left addressible in ISGECMOM CSECT\n*\n#ISGECMOM EQU  *-ISGECMOM               Bytes used\n#ISGECMOM_LEFT EQU (4096*2)-#ISGECMOM   Bytes left\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Area passed to us in R1                                     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDSA      DSECT ,\n         DS    18F                      Register Save Area\nI_PARM   DS    F                        Parmlist on entry\nW_ERROR  DS    F                        Number of errors\nW_NOTIFY DS    F                        Number of notifies\nI_OPTION DS    X                        Call option\nX_FLAG1  DS    B'00000000'              Flags\n         DS    0F\n* - - - - - - - - - - - - - - - - - - - End of ISGECMON static areas\nEF_RA    DS    F                        EDITFWF return address\n         DS    0D\nDOUBLE   DS    D                        Double word work area\nDOUBLE2  DS    2D                       Double word work area * 2\nWTOAREA  DS    XL(C_WTOL)               Reserve area\n         DS    0F                       Wait routine\nWR_COMMA DS    F                        ..Communication field\nWR_CONID DS    X                        ..Console ID\n*\nDSAL     EQU   *-DSA\n#DSAL    EQU   512\n         END   ,\n./ ADD NAME=ISGECMON 1000-97157-97157-1412-00002-00002-00000-DAVE\n--> You must copy 'SYS1.SAMPLIB(ISGECMON)' here and then modify it\n    via the comments in the $CHANGES member.\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 15:12 ON 98/01/16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPFVAR": {"ttr": 22025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00C\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18(\\x00\\x87\\x00}\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:28:43", "lines": 135, "newlines": 125, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: ISPFVAR\n |\n | Author: David Alcock\n |\n | Purpose: Show the IBM ISPF system variables.\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1998-2002+ by David Alcock\n |             All rights reserved.\n */\naddress ISPEXEC\n\nvars =         \"ZACCTNUM \"\nvars = vars || \"ZAPLCNT \"\nvars = vars || \"ZAPPLID \"\nvars = vars || \"ZAPPTTL \"\nvars = vars || \"ZASPECT \"\nvars = vars || \"ZCOLORS \"\nvars = vars || \"ZCS     \"\nvars = vars || \"ZCSDLL  \"\nvars = vars || \"ZDATE   \"\nvars = vars || \"ZDATEF  \"\nvars = vars || \"ZDATEFD \"\nvars = vars || \"ZDAY    \"\nvars = vars || \"ZDBCS   \"\nvars = vars || \"ZDECS   \"\nvars = vars || \"ZDEVNAM \"\nvars = vars || \"ZENTKTXT \"\nvars = vars || \"ZENVIR  \"\nvars = vars || \"ZFAMPRT \"\nvars = vars || \"ZFKA    \"\nvars = vars || \"ZGE     \"\nvars = vars || \"ZGUI    \"\nvars = vars || \"ZHILITE \"\nvars = vars || \"ZISPFRC \"\nvars = vars || \"ZJDATE  \"\nvars = vars || \"ZKEYHELP \"\nvars = vars || \"ZKEYS   \"\nvars = vars || \"ZKLAPPL \"\nvars = vars || \"ZKLNAME \"\nvars = vars || \"ZKLTYPE \"\nvars = vars || \"ZKLUSE  \"\nvars = vars || \"ZLANG   \"\nvars = vars || \"ZLOGO   \"\nvars = vars || \"ZLOGON  \"\nvars = vars || \"ZMONTH  \"\nvars = vars || \"ZOS390RL \"\nvars = vars || \"ZPFCTL  \"\nvars = vars || \"ZPFFMT  \"\nvars = vars || \"ZPFLxx  \"\nvars = vars || \"ZPFSET  \"\nvars = vars || \"ZPFSHOW \"\nvars = vars || \"ZPLACE  \"\nvars = vars || \"ZPREFIX \"\nvars = vars || \"ZPRIKEYS \"\nvars = vars || \"ZPROFAPP \"\nvars = vars || \"ZSCBR   \"\nvars = vars || \"ZSCED   \"\nvars = vars || \"ZSCML   \"\nvars = vars || \"ZSCRCUR \"\nvars = vars || \"ZSCREEN \"\nvars = vars || \"ZSCREEND \"\nvars = vars || \"ZSCREENW \"\nvars = vars || \"ZSCRMAX \"\nvars = vars || \"ZSCRMAXD \"\nvars = vars || \"ZSCRMAXW \"\nvars = vars || \"ZSCROLLA \"\nvars = vars || \"ZSCROLLD \"\nvars = vars || \"ZSCROLLN \"\nvars = vars || \"ZSCTPREF \"\nvars = vars || \"ZSCTSRCH \"\nvars = vars || \"ZSPLIT  \"\nvars = vars || \"ZSTDYEAR \"\nvars = vars || \"ZSYSID  \"\nvars = vars || \"ZTEMPF  \"\nvars = vars || \"ZTEMPN  \"\nvars = vars || \"ZTERM   \"\nvars = vars || \"ZTERMCID \"\nvars = vars || \"ZTERMCP \"\nvars = vars || \"ZTERMCS \"\nvars = vars || \"ZTHS    \"\nvars = vars || \"ZTIME   \"\nvars = vars || \"ZTIMEL  \"\nvars = vars || \"ZTS     \"\nvars = vars || \"ZTSICMD \"\nvars = vars || \"ZTSSCMD \"\nvars = vars || \"ZUCTPREF \"\nvars = vars || \"ZUSER   \"\nvars = vars || \"ZVERB   \"\nvars = vars || \"ZWINTTL \"\nvars = vars || \"ZWSCDPG \"\nvars = vars || \"ZWSCON  \"\nvars = vars || \"ZWSOPSYS \"\nvars = vars || \"ZYEAR   \"\n\ndo j = 1 to words(vars)\n   \"VGET \"word(vars,j)\n   vgrc = rc\n   interpret \"value = \"word(vars,j)\n   if vgrc == 0 then say left(word(vars,j),20,'-')value\n   if word(vars,j) == \"ZPFFMT\" then call show_keys\n   end\n\nexit\n\nshow_keys:\ndo i = 1 to zkeys\n   if i < 10 then do\n      \"VGET ZPF0\"i\n      \"VGET ZPFL0\"i\n      interpret \"value=zpf0\"i\n      interpret \"label=zpfl0\"i\n      if label <> \"\" then label = \"- \"label\n      pfk = \"> ZPF0\"i\n      say left(pfk,20,'-')value label\n      end\n   else do\n        \"VGET ZPF\"i\n        \"VGET ZPFL\"i\n        interpret \"value=zpf\"i\n        interpret \"label=zpfl\"i\n        if label <> \"\" then label = \"- \"label\n        pfk = \"> ZPF\"i\n        say left(pfk,20,'-')value label\n        end\n   end\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPF34L": {"ttr": 22273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x00\\x16\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18C\\x07}\\x04\\xde\\x00\\x00\\xc4\\xc1\\xd3\\xc3\\xd6\\xc3\\xd2@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:43:16", "lines": 1917, "newlines": 1246, "modlines": 0, "user": "DALCOCK"}, "text": "/* REXX\n | bug: 17sep1998 - fdr move for CSI gets *VSAM for volume\n |\n |\n | Name: ISPF34L\n |\n | Author: David Alcock\n |         dave@planetmvs.com\n |\n | Purpose: Read the dataset list from the ISPF 3.4 SPFx.LIST and\n |          create utility control cards and other functions.\n |\n |          This is a \"Quick and dirty\" utility designed to quickly\n |          create control cards and perform other functions on\n |          datasets found in a ISPF 3.4 listing.  It doesn't look\n |          pretty but it is handy.\n |\n | Note: Some of the oldest code uses \"PUSH\" and does things backwards.\n |       Please do all new code with \"QUEUE\" so we have clear logic.\n |\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code provided.\n |             It is copyright 1998-2002+ by David Alcock.  All rights\n |             reserved.\n */\n\nvrm = '1.9'\n\n/**********************************************************************\n***\n**           M o d i f i c a t i o n   H i s t o r y\n**\n** Person     Date        Description\n** ---------- ----------- ------------------------------------------\n** DGAlcock   2001-09-21  1.9 - If no volser given, don't generate\n**                        a JCL line with UNIT=,VOL=SER= (fileaid srch)\n** DGAlcock   2001-05-17  1.8 - Add VTS volume insert thingy;\n** DGAlcock   2000-10-05  1.7\n**                        - Add symbolics to IDCAMS_catalogs_SYSRES;\n**                        - Prompt for catalog and noscratch for\n**                          IDCAMS_delete;\n** DGAlcock   2000-08-06  1.6\n**                        - Add Generate_FTPGET function;\n**                        - Allow different LRECL/BLKSIZE/RECFM for CC;\n**                        - Prompt for new dsname creation method in\n**                          XMIT function;\n** DGAlcock   2000-07-27  1.5\n**                        - Add NOVERIFY to FDR_Move function\n**                        - Add IDCAMS_LISTCAT function\n**                        - Add delete and catalog prompts to idc_cat\n** DGAlcock   2000-03-11  1.4\n**                        - HLQ analysis\n**                        - Handle the extra volume lines if invoked\n**                          for a volser instead of \"Dsname Level\"\n** DGAlcock   2000-03-01  1.3 - Add creation of XMIT job;\n** DGAlcock   1999-11-22  1.2 - IEBCOPY with replace\n** DGAlcock   16-MAY-1998 1.1 - Two of the IDCAMS functions were NOT\n**                        generating the IDCAMS step JCL;\n** DGAlcock   21-APR-1998 1.0 - released on the Internet;\n** DGAlcock   15-MAR-1998 Added IEHPROGM deletes (scratches);\n**                        Made IEHPROGM renames use queue; Redesign\n**                        of main menu;\n** DGAlcock   04-MAR-1998 Added SYSLIBxx DDNAME create;\n** DGAlcock   05-FEB-1998 Added JOBINFO on comment after jobcard;\n**                        Added creating DSAT output command\n** DGAlcock   21-JAN-1998 Strip out non-dataset lines from input;\n**                        Add better checking for FDR move and copy;\n**                        Add edit of sysut2 file at the end;\n** DGAlcock   28-OCT-1997 Add jobstep for IEHPROGM_rename;\n** DGAlcock   10-OCT-1997 Enhanced FDR_RENAMEs and added jobcard;\n**                        Generate_IDCAMS_step was added;\n** DGAlcock   26-SEP-1997 Added Write_out_Volser function and\n**                        enhanced the DSAT function; Added sysut2_>\n**                        _dsn on the command line;\n** DGAlcock   25-SEP-1997 Added FDR Copy function;\n** DGAlcock   03-JUL-1995 Initial exec created;\n***\n**********************************************************************/\n\narg sysut1_dsn sysut2_dsn\n\nuser = sysvar(sysuid)\n\nif sysut2_dsn == \"\" then sysut2_dsn = \"@CNTLCRD\"\njobinfo = \"\"\njctype = \"q\"\nuserid = sysvar(sysuid)\n\nmtype = address()\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then smfid = mvsvar(syssmfid)\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        smfid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse do\n     say \"This exec is intended for use on an IBM mainframe running \"\n         \"MVS (but OS/390 is okay)\"\n     exit 12\n     end\n\n/***********************************************************************\n* Installation dependant code:\n*\n* 1) Set the comand to clear screen: Use the command for your site!!!!!\n*\n* 2) Generate a job card.  This code uses the SHOWTSO installation\n*    command to obtain ACF2 information: \"programmer name\", UID\n*    string and default sysout destination.\n*\n*    There is a version of SHOWTSO on the CBT tape from Rockwell\n*    International - I think it's on the overflow tape now.\n*\n*    If you don't have a SHOWTSO or another way of getting these\n*    values, you could prompt for them.\n*\n* 3) Set the Migration volume name as set by your installation's disk\n*    management system.  In ISPF v4, the volume will have a migration\n*    level appended, but we will only check the first 6 bytes\n***********************************************************************/\n\ncmd_cls = \"CLS\"     /* TSO command to clear the screen */\ncmd_pds = \"PDSE\"    /* TSO command for PDS (or Serena's product) */\n\nacct = \"?,?,?,???\"\ndest = \"LOCAL\"\n\njc.1 = \"//\"userid\"I JOB  (\"acct\"),\"\njc.2 = \"//          '\"name\"',\"\njc.3 = \"//          NOTIFY=\"userid\",REGION=8M,MSGCLASS=X,\"\njc.4 = \"//          CLASS=U,TIME=1439\"\njc.5 = \"//BANNER    OUTPUT DEFAULT=YES,JESDS=ALL,DEST=\"dest\njc.0 = 5\n\n/*\n | Set values for IBM's HSM\n */\nmigvol  = \"MIGRAT\"              /* migration volume name */\nmigtype = \"migrated\"            /* migration type for this product */\nmigprod = \"HSM\"                 /* migration product name */\n\n/*\n | Set values for DMS (SAMS:Disk)\n */\nmigvol  = \"ARCIVE\"              /* migration volume name */\nmigtype = \"archived\"            /* migration type for this product */\nmigprod = \"DMS (SAMS:Allocate)\" /* migration product name */\n\n /* Note: last one of the migvol/migtype/migprod will be used */\n\n/*---------------------------------------------------------------------\n | Set misc program defaults\n ------------------------------------------------------------------- */\n\nccl = \"80\"   /* LRECL(\"ccl\") BLKSIZE(\"ccb\") RECFM(\"ccf\")\" */\nccb = \"8800\" /* LRECL(\"ccl\") BLKSIZE(\"ccb\") RECFM(\"ccf\")\" */\nccf = \"F B\"  /* LRECL(\"ccl\") BLKSIZE(\"ccb\") RECFM(\"ccf\")\" */\n\n/***********************************************************************\n | Verify that the input dataset exists\n |\n | The SPF*.LIST file is a 3.4 dataset list.\n **********************************************************************/\n\nif sysut1_dsn == \"\" then do\n   say \"Input SPF*.LIST dataset was not given, terminating\"\n   exit 12\n   end\n\nx = LISTDSI(sysut1_dsn)\nif x <> 0 then do\n   say \"Error accessing DSN:\" sysut1_dsn\n   say \"> \"sysmsglvl1\n   say \"> \"sysmsglvl2\n   say \"> SYSREASON: \"sysreason\n   exit\n   end\n\nsysut1_pdsn = sysdsname\nparse value sysut1_dsn with . \"(\" member \")\" .\nif member <> \"\" then do\n   sysut1_pdsn = sysut1_pdsn\"(\"strip(member)\")\"\n   end\nsysut1_num = \"*\"\n\nsysut1_dd = \"I34L\"random()\naddress TSO \"ALLOCATE FILE(\"sysut1_dd\") DA('\"sysut1_pdsn\"') SHR REUSE\"\narc = rc\nif arc <> 0 then do\n   say \"Error allocating input file: '\"sysut1_pdsn\"', RC=\"arc\n   exit 12\n   end\n\n\"EXECIO \"sysut1_num\" DISKR \"sysut1_dd\" (FINIS STEM sysut1_file.\"\nerc = rc\n\nif erc <> 0 then do\n   say \"Error reading input file: '\"sysut1_pdsn\"', RC=\"arc\n   exit 12\n   end\naddress TSO \"FREE FILE(\"sysut1_dd\")\"\n\n/***********************************************************************\n* Weed out the non-dataset lines from the input file                   *\n***********************************************************************/\n\nlistver = 0\nweeded = 0\nmigcnt = 0\ninvolumestuff = 0\n\ndo i = 1 to sysut1_file.0\n\n   if involumestuff == 1 then do\n      if word(sysut1_file.i,1) == \"DATA\" then involumestuff = 0\n      /* say \"Skipping volume line:\" sysut1_file.i */\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n\n   if word(sysut1_file.i,1) == \"VOLUME\" then do\n      /* say \"Skipping volume line:\" sysut1_file.i */\n      sysut1_file.i = \"\"\n      involumestuff = 1\n      weeded = weeded + 1\n      iterate\n      end\n\n   if substr(sysut1_file.i,1,22) == \"1 LISTING OF DATA SETS\" then do\n      listver = 3\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n   if substr(sysut1_file.i,1,22) == \"1 Listing of Data Sets\" then do\n      listver = 4\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n   if substr(sysut1_file.i,1,18) == \"     DATA SET NAME\" then do\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n   if substr(sysut1_file.i,1,18) == \"  ----------------\" then do\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n\n   if strip(sysut1_file.i) == \"\" then do\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n\n   if word(sysut1_file.i,1) == \"PAGE:\" then do\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n   if word(sysut1_file.i,1) == \"TIME:\" then do\n      sysut1_file.i = \"\"\n      weeded = weeded + 1\n      iterate\n      end\n\n   volume = word(sysut1_file.i,2)\n   if substr(volume,1,6) == migvol then migcnt = migcnt + 1\n   end\n\n/***********************************************************************\n* Show the menu\n***********************************************************************/\n\naddress TSO cmd_cls\n\nsay \"ISPF34L - version \"vrm \"- Freeware - ISPF 3.4 list processor\"\n/* Please keep the next line in the code but it's okay to leave it\n   commented out: */\n/* say \"Copyright 1995-1998 by David Alcock. All rights reserved.\" */\nsay \" \"\n\nif weeded == 0 then say \"No input lines were weeded out\"\nelse say weeded \"lines were weeded out of \"sysut1_file.0\" input lines\"\n\nif migcnt == 0 then say \"No \"migtype\" datasets found in input\"\nelse say \"Found \"migcnt\" files \"migtype\" to \"migprod\n\nsay \" \"\nsay \"Select one of the following:               SMF ID: \"smfid\nsay \" \"\nsay \"I1 - IDCAMS alias             M1 - Show PDS directory info\"\nsay \"I2 - IDCAMS catalogs_SYSRES   M2 - Invoke DSAT Command    \"\nsay \"I3 - IDCAMS catalogs          M3 - Write out volser       \"\nsay \"I4 - IDCAMS renames           M4 - //DDnames cards        \"\nsay \"I5 - IDCAMS deletes           M5 - RESTORE JCL cards      \"\nsay \"I6 - IDCAMS LISTCAT           M6 - IEBCOPY replaces       \"\nsay \"I7 - IDCAMS VTS inserts       M7 - XMIT job               \"\nsay \"                              M8 - XMIT commands          \"\nsay \"D1 - DMS Archive              M9 - HLQ analysis           \"\nsay \"                              M10 - FTPGET MS/DOS bat file\"\nsay \"F1 - FDR Renames              M11 - PROG (APFLST entries) \"\nsay \"F2 - FDR moves                                            \"\nsay \"F3 - FDR Copies                                           \"\nsay \"                              PM1 - IEHPROGM renames      \"\nsay \"FA1- FileAid Search           PM2 - IEHPROGM deletes      \"\nsay \" \"\npull option\nselect\n  when option = \"I1\"  then call Generate_IDCAMS_alias\n  when option = \"I2\"  then call Generate_IDCAMS_catalogs_SYSRES\n  when option = \"I3\"  then call Generate_IDCAMS_catalogs\n  when option = \"I4\"  then call Generate_IDCAMS_renames\n  when option = \"I5\"  then call Generate_IDCAMS_deletes\n  when option = \"I6\"  then call Generate_IDCAMS_listcat\n  when option = \"I7\"  then call Generate_IDCAMS_VTS_inserts\n\n  when option = \"M1\"  then call Show_directory_information\n  when option = \"M2\"  then call Invoke_DSAT\n  when option = \"M3\"  then call Write_out_Volser\n  when option = \"M4\"  then call Generate_DDNAMES\n  when option = \"M5\"  then call Generate_RESTORE_JCL_cards\n  when option = \"M6\"  then call Generate_IEBCOPY_REPLACE\n  when option = \"M7\"  then call Generate_XMIT_JOB\n  when option = \"M8\"  then call Generate_XMIT_Commands\n  when option = \"M9\"  then call Do_HLQ_Analysis\n  when option = \"M10\" then call Generate_FTPGET\n  when option = \"M11\" then call Generate_APFLST\n  when option = \"D1\"  then call Generate_DMS_archives\n  when option = \"F1\"  then call Generate_FDR_Renames\n  when option = \"F2\"  then call Generate_FDR_MOVEs\n  when option = \"F3\"  then call Generate_FDR_COPIES\n  when option = \"PM1\" then call Generate_IEHPROGM_renames\n  when option = \"PM2\" then call Generate_IEHPROGM_deletes\n  when option = \"FA1\" then call Generate_FileAid_Search\n  otherwise\n       say \"Invalid option, terminating\"\n       exit\n       end\n\nexit\n\n/*********************************************************************\n* Insert the jobcard - either queue it or push it...\n*********************************************************************/\n\nGenerate_jobcard:\n\njdate = substr(date('s'),1,4)\".\"substr(date('j'),3,3) /* ccyy.ddd */\nisodate = substr(date('s'),1,4)\"-\"substr(date('o'),4,2)|| ,\n          \"-\"substr(date('o'),7,2) /* ccyy-mm-dd */\nif jctype == \"q\" then do\n   do j = 1 to jc.0\n      queue jc.j\n      end\n   queue '//*'\n   queue '//** This job was generated by the %ISPF34L exec'\n   queue '//** on 'isodate ' ('jdate' Julian) at' time()\n   queue '//**'\n   if jobinfo <> \"\" then do\n      queue '//**' jobinfo\n      queue '//*'\n      end\n   end\nelse do\n     push '//*'\n     push '//**' jobinfo\n     if jobinfo <> \"\" then do\n        push '//**'\n        push '//** on 'isodate ' ('jdate' Julian) at' time()\n        push '//** This job was generated by the %ISPF34L exec'\n        end\n     push '//*'\n     do j = jc.0 to 1 by -1\n        push jc.j\n        end\n     end\nreturn\n\n/*********************************************************************\n* Generate IDCAMS job step\n*********************************************************************/\n\nGenerate_IDCAMS_step:\n\nif jctype == \"q\" then do\n   queue \"//JUSTDOIT EXEC PGM=IDCAMS\"\n   queue \"//SYSPRINT DD SYSOUT=*\"\n   queue \"//SYSIN    DD *\"\n   end\nelse do\n     push \"//SYSIN    DD *\"\n     push \"//SYSPRINT DD SYSOUT=*\"\n     push \"//JUSTDOIT EXEC PGM=IDCAMS\"\n     end\nreturn\n\n/*********************************************************************\n* Initialize for control card library output\n*********************************************************************/\n\ninit_control_card:\n\nif substr(sysut2_dsn,1,1) <> \"'\" then ,\n   sysut2_dsn = sysvar(sysuid)\".\"sysut2_dsn\n\nsay \"Writing to DSN=\"sysut2_dsn\ncall \"OUTTRAP\" \"dummy.\",\"*\"\naddress TSO \"DELETE '\"sysut2_dsn\"'\"\ncall \"OUTTRAP\" \"OFF\"\naddress TSO \"ALLOCATE FILE(SYSUT2) DA('\"sysut2_dsn\"')\",\n            \"UNIT(SYSDA) NEW REUSE SPACE(5 5) TRACKS\",\n            \"LRECL(\"ccl\") BLKSIZE(\"ccb\") RECFM(\"ccf\")\"\n\naddress TSO \"NEWSTACK\"   /* Place to put SYSUT2 output */\nreturn\n\n/*********************************************************************\n* Terminate control card processing\n*********************************************************************/\n\nterm_control_card:\n\nQUEUE ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW SYSUT2 (FINIS\"\nerc = rc\nif erc <> 0 then ,\n   say \"%ISPF34L - Terminating, EXECIO rc=\"erc\naddress TSO \"FREE FILE(SYSUT2)\"\naddress TSO \"DELSTACK\"\n\nif sysvar(sysispf) == \"ACTIVE\" then do\n   sysut2_dsn = strip(sysut2_dsn)\n   address ISPEXEC\n   \"CONTROL ERRORS RETURN\"\n   \"EDIT DATASET('\"sysut2_dsn\"')\"\n   erc = rc\n   if erc > 4 then ,\n      say \"%ISPF34L - Could not edit \"sysut2_dsn \"rc=\"erc\n   \"CONTROL ERRORS CANCEL\"\n   end\nreturn\n\n/***********************************************************************\n* FDR copy with rename\n*\n*    COPY TYPE=DSF,DSNENQ=NONE\n*    SELECT DSN=SYS3.SYS.ACF2.CLIST,\n*           NEWNAME=SYS2.SYS.ACF2.CLIST\n*\n*    MOVE TYPE=DSF\n*    SELECT DSN=SYS3.SYS.ACF2.CLIST,\n*           NEWNAME=SYS2.SYS.ACF2.CLIST\n*\n***********************************************************************/\nGenerate_FDR_Renames:\n\nsay \"Executing: Generate_FDRDSF_Renames\"\n\nsay \"Please enter new volume:\"\npull newvol\nif newvol == \"\" then newvol = \"bozo01\"\nnewvol = translate(newvol)\n\ncall init_control_card\ncall generate_jobcard\n\nlastvol = \"\"\nnum = 0\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   if volume == newvol then do\n      say \"Skipping dataset=\"dsname\n      say \"           (already on \"newvol\")\"\n      iterate\n      end\n\n   if volume <> lastvol then do\n\n      lastvol = volume\n      num = num + 1\n      queue '//* ==============================================='\n      queue '//COPY'num' EXEC PGM=FDRCOPY,REGION=9M,TIME=1439'\n      queue '//SYSPRINT  DD SYSOUT=*'\n      queue '//SYSPRIN1  DD SYSOUT=*'\n      queue '//SYSUDUMP  DD SYSOUT=*'\n      queue '//ABNLDUMP  DD DUMMY'\n      queue '//DISK1     DD DISP=SHR,UNIT=SYSALLDA,VOL=SER='volume\n      queue '//TAPE1     DD DISP=SHR,UNIT=SYSALLDA,VOL=SER='newvol\n      queue '//SYSIN     DD *'\n      queue ' COPY TYPE=DSF,DSNENQ=NONE'\n      end\n\n   dsname = strip(dsname)\n   ndsname = translate(dsname,' ','.')\n   ndsname = delword(ndsname,1,1)\n   ndsname = \"SYS2.\"ndsname             /* Change new prefix ! */\n   ndsname = translate(ndsname,'.',' ')\n\n   queue '      SELECT DSN='dsname\",\"\n   queue '             NEWNAME='ndsname\n   end\n\ncall term_control_card\n\nreturn /* from Generate_FDR_Renames */\n\n\n\n/*---------------------------------------------------------------------\n | Generate FDR MOVE statements\n |\n | The only time you should be using NOVERIFY is when the dataset\n | is catalogued on another system and you can't use LISTDSI.\n ------------------------------------------------------------------- */\nGenerate_FDR_MOVEs:\n\nsay \"Executing: Generate_FDRDSF_Moves\"\n\nverdsn = \"\"\n\n/*\n |  Get new volume name\n */\n\nsay \"Please enter new volume:\"\npull newvolr\nnewvol = word(newvolr,1)\nif newvol == \"\" then newvol = \"bozo01\"\nnewvol = translate(newvol)\nif words(newvol) > 1 then do\n   say \"%ISPF34L - You entered a more words than expected for volume\"\n   say \"%ISPF34L - Using first one: \"word(newvol,1)\n   newvol = word(newvol,1)\n   end\n/* Here we allow for: 'BOZO01 NOVERIFY' for reducing prompting */\ndo i = 2 to words(newvolr)\n   select\n     when translate(word(newvolr,i)) == \"VERIFY\"   then verdsn = \"Y\"\n     when translate(word(newvolr,i)) == \"NOVERIFY\" then verdsn = \"N\"\n     otherwise\n          say \"Ignoring '\"word(newvolr,i)\"'\"\n          end\n   end\n\n/*\n |  Prompt for dataset verification via LISTDSI\n */\n\nif verdsn == \"\" then do\n   say \"Verify dataset exists (Y/N)\"\n   pull verdsnr\n   verdsnr = translate(verdsnr)\n   select\n    when substr(verdsnr,1,1) == \"Y\" then verdsn = \"Y\"\n    when substr(verdsnr,1,1) == \"N\" then verdsn = \"N\"\n    otherwise\n         say \"Invalid response, going to verify dataset\"\n         verdsn = \"Y\"\n         end\n    end\n\nif verdsn = \"Y\" then say \"Will verify dataset exists\"\nelse say \"Will NOT verify dataset exists\"\n\n/*\n |  Here's where we do the dirty work\n */\n\ncall init_control_card\ncall generate_jobcard\n\nlastvol = \"\"\nnum = 0\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   if volume == \"??????\" then do\n      say \"Skipping DSN=\"left(dsname,44) \"(volume=??????)\"\n      iterate\n      end\n\n   if verdsn == \"Y\" then do\n      fq_dsname = \"'\"strip(dsname)\"'\"\n      rc = LISTDSI(fq_dsname)\n      select\n        when rc == 0 then do\n             say \"Select:  DSN=\"left(dsname,44) \"Unit=\"sysunit\n             end\n        when sysreason == \"0008\" then do\n             say \"Skipping DSN=\"left(dsname,44) \"(tape)\"\n             iterate\n             end\n        when sysreason == \"0012\" then do\n             ndsn = translate(dsname,' ','.')\n             last_node = word(ndsn,words(ndsn))\n             if last_node == \"DATA\" | last_node == \"INDEX\" then do\n                say \"Skipping DSN=\"left(dsname,44) \"(VSAM Comp)\"\n                iterate\n                end\n             say \"Select:  DSN=\"left(dsname,44) sysdsorg\n             end\n        otherwise\n             say \"Error:   DSN=\"dsname\n             say \"           > \"sysmsglvl1\n             say \"           > \"sysmsglvl2\n             say \"           > SYSREASON: \"sysreason\n             iterate\n             end\n      end\n\n   if volume == newvol then do\n      say \"Skipping DSN=\"left(dsname,44) ,\n          \"(already on \"newvol\")\"\n      iterate\n      end\n\n   if volume <> lastvol then do\n\n      lastvol = volume\n      num = num + 1\n      queue '//* ==============================================='\n      queue '//MOVE'num' EXEC PGM=FDRCOPY,REGION=9M,TIME=1439'\n      queue '//SYSPRINT  DD SYSOUT=*'\n      queue '//SYSPRIN1  DD SYSOUT=*'\n      queue '//SYSUDUMP  DD SYSOUT=*'\n      queue '//ABNLDUMP  DD DUMMY'\n      queue '//DISK1     DD DISP=SHR,UNIT=SYSALLDA,VOL=SER='volume\n      queue '//TAPE1     DD DISP=SHR,UNIT=SYSALLDA,VOL=SER='newvol\n      queue '//SYSIN     DD *'\n      queue ' MOVE TYPE=DSF,DSNENQ=NONE'\n      end\n   queue '      SELECT DSN='dsname\n   end\n\ncall term_control_card\nreturn /* from Generate_FDR_Moves */\n\n/***********************************************************************\n* Write the FDR Copy JCL and select statements\n***********************************************************************/\nGenerate_FDR_COPIES:\n\nsay \"Executing: Generate_FDRDSF_Copies\"\n\nsay \"Please enter new volume:\"\npull newvol\nif newvol == \"\" then newvol = \"bozo01\"\nnewvol = translate(newvol)\nif words(newvol) > 1 then do\n   say \"%ISPF34L - You entered a more words than expected for volume\"\n   say \"%ISPF34L - Using first one: \"word(newvol,1)\n   newvol = word(newvol,1)\n   end\n\ncall init_control_card\ncall generate_jobcard\n\nlastvol = \"\"\nnum = 0\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   if volume == \"??????\" then do\n      say \"Skipping DSN=\"left(dsname,44) \"(volume=??????)\"\n      iterate\n      end\n\n   fq_dsname = \"'\"strip(dsname)\"'\"\n   rc = LISTDSI(fq_dsname)\n   select\n     when rc == 0 then do\n          say \"Select:  DSN=\"left(dsname,44) \"Unit=\"sysunit\n          end\n     when sysreason == \"0008\" then do\n          say \"Skipping DSN=\"left(dsname,44) \"(tape)\"\n          iterate\n          end\n\n     when sysreason == \"0012\" then do\n          ndsn = translate(dsname,' ','.')\n          last_node = word(ndsn,words(ndsn))\n          if last_node == \"DATA\" | last_node == \"INDEX\" then do\n             say \"Skipping DSN=\"left(dsname,44) \"(VSAM Comp)\"\n             iterate\n             end\n          say \"Select:  DSN=\"left(dsname,44) sysdsorg\n          end\n     otherwise\n          say \"Error:   DSN=\"dsname\n          say \"           > \"sysmsglvl1\n          say \"           > \"sysmsglvl2\n          say \"           > SYSREASON: \"sysreason\n          iterate\n          end\n\n\n   if volume == newvol then do\n      say \"Skipping DSN=\"left(dsname,44) ,\n          \"(already on \"newvol\")\"\n      iterate\n      end\n\n   if volume <> lastvol then do\n\n      lastvol = volume\n      num = num + 1\n      queue '//* ==============================================='\n      queue '//COPY'num' EXEC PGM=FDRCOPY,REGION=9M,TIME=1439'\n      queue '//SYSPRINT  DD SYSOUT=*'\n      queue '//SYSPRIN1  DD SYSOUT=*'\n      queue '//SYSUDUMP  DD SYSOUT=*'\n      queue '//ABNLDUMP  DD DUMMY'\n      queue '//DISK1     DD DISP=SHR,UNIT=SYSALLDA,VOL=SER='volume\n      queue '//TAPE1     DD DISP=SHR,UNIT=SYSALLDA,VOL=SER='newvol\n      queue '//SYSIN     DD *'\n      queue ' COPY TYPE=DSF,DSNENQ=NONE,NOCAT'\n      end\n   queue '      SELECT DSN='dsname\n   end\n\ncall term_control_card\nreturn /* from Generate_FDR_COPIES */\n\n/***********************************************************************\n* File Aid Search\n***********************************************************************/\nGenerate_FileAid_Search:\n\nsay \"Executing: Generate_FileAid_Search\"\n\nirc = 0\ndo while irc == 0\n   say \"Please enter search string\"\n   pull ss\n   if strip(ss) == \"\" then do\n      say \"I need a search string\"\n      irc = 0\n      end\n   else irc = 1\n   end\n\ncall init_control_card\ncall generate_jobcard\n\njobs = 1\nnum = 0\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   num = num + 1\n   if num = 256 then do\n      jobs = jobs + 1\n      call generate_jobcard\n      num = 1\n      end\n\n   volume = strip(volume)\n   comma = \",\"\n   if volume == \"\" then comma = \"\"\n\n   queue \"//* ===============================================\"\n   queue \"//STEP\"num\" EXEC PGM=FILEAID\"\n   queue \"//SYSPRINT DD DUMMY\"\n   queue \"//SYSLIST  DD SYSOUT=*\"\n   queue \"//SYSTOTAL DD SYSOUT=*\"\n   queue \"//DD01     DD DISP=SHR,DSN=\"strip(dsname)||comma\n   if volume <> \"\" then ,\n      queue \"//            UNIT=SYSALLDA,VOL=SER=\"volume\n   queue \"//SYSIN    DD *\"\n   queue \"$$DD01 LIST IF=(1,0,C'\"ss\"')\"\n   end\n\nsay \"Number of jobs created instream:\" jobs\ncall term_control_card\nreturn /* from Generate_FileAid_Search */\n\n/***********************************************************************\n* IEHPROGM renameds\n*\n*   RENAME DSNAME=datasetname,\n*                 NEWNAME=prefix.suffix,\n*                 VOL=3390=SYSTRS\n*\n***********************************************************************/\nGenerate_IEHPROGM_renames:\n\nsay \"Executing: Generate_IEHPROGM_renames\"\nsay \" \"\nsay \"Enter device type: 3380 or 3390\"\npull dtype\ndtype = strip(dtype)\nselect\n  when dtype == \"3380\" then nop\n  when dtype == \"3390\" then nop\n  when dtype == \"\"     then do\n       dtype = \"3390\"\n       say \"Device type not given, using 3390\"\n       end\n  otherwise\n     say \"Unknown device type accepted:\" dtype\n  end\n\ncall init_control_card\ncall generate_jobcard\n\nqueue \"//PROGM   EXEC PGM=IEHPROGM\"\n\nlvol = \"\"\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n   if volume == \"\" then iterate\n   if volume == \"*VSAM*\" then iterate\n   if lvol <> volume then do\n      queue \"//\"left(volume,8)\" DD\" ,\n            \"DISP=SHR,VOL=SER=\"volume\",UNIT=\"dtype\n      lvol = volume\n      end\n\n   end\n\nqueue \"//VDSBYPAS DD DUMMY\"\nqueue \"//SYSPRINT DD SYSOUT=*\"\nqueue \"//SYSIN    DD *\"\n\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n   if volume == \"\" then volume == \"<volume>\"\n   if volume == \"*VSAM*\" then do\n      say \"Skipping VSAM dataset: \"dsname\n      iterate\n      end\n\n   dsname = strip(dsname)\n   ndsname = translate(dsname,' ','.')\n   ndsname = delword(ndsname,1,1)\n   ndsname = \"SYS2.\"ndsname\",\"\n   ndsname = translate(ndsname,'.',' ')\n   dsname = dsname\",\"\n\n            /*....+....1....+....2....+....3 */\n   lineout = \" RENAME DSNAME=oldname,\n   lineout = overlay(dsname,lineout,16)\n   queue lineout\n\n            /*....+....1....+....2....+....3 */\n   lineout = \"               NEWNAME=newname,\n   lineout = overlay(ndsname,lineout,24)\n   queue lineout\n\n   lineout = \"               VOL=\"dtype\"=\"volume\n   queue lineout\n\n   end\n\n\ncall term_control_card\n\nreturn /* from Generate_IEHPROGM_renames */\n\n/***********************************************************************\n | IEHPROGM deletes\n |\n | SCRATCH DSNAME=dsname,VOL=dtype=volume,PURGE\n |\n | SCRATCH DSNAME=BOZO.CLOWNLIB,VOL=3390=CIRCUS,PURGE\n |\n **********************************************************************/\nGenerate_IEHPROGM_deletes:\n\nsay \"Executing: Generate_IEHPROGM_deletes\"\nsay \" \"\nsay \"Enter device type: 3380 or 3390\"\npull dtype\ndtype = strip(dtype)\nselect\n  when dtype == \"3380\" then nop\n  when dtype == \"3390\" then nop\n  when dtype == \"\"     then do\n       dtype = \"3390\"\n       say \"Device type not given, using 3390\"\n       end\n  otherwise\n     say \"Unknown device type accepted:\" dtype\n  end\n\ncall init_control_card\ncall generate_jobcard\n\nqueue \"//PROGM   EXEC PGM=IEHPROGM\"\n\nlvol = \"\"\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n   if volume == \"\" then iterate\n   if volume == \"*VSAM*\" then iterate\n   if lvol <> volume then do\n      queue \"//\"left(volume,8)\" DD\" ,\n            \"DISP=SHR,VOL=SER=\"volume\",UNIT=\"dtype\n      lvol = volume\n      end\n\n   end\n\nqueue \"//VDSBYPAS DD DUMMY\"\nqueue \"//SYSPRINT DD SYSOUT=*\"\nqueue \"//SYSIN    DD *\"\n\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   if volume == \"\" then volume == \"<volume>\"\n   if volume == \"*VSAM*\" then do\n      say \"Skipping VSAM dataset: \"dsname\n      iterate\n      end\n\n   dsname = strip(dsname)\n   queue  \" SCRATCH DSNAME=\"dsname\",VOL=\"dtype\"=\"volume\",PURGE\"\n\n   end\n\n\ncall term_control_card\n\nreturn /* from Generate_IEHPROGM_deletes */\n\n/***********************************************************************\n* IDCAMS VTS Inserts                                                   *\n***********************************************************************/\n\nGenerate_IDCAMS_VTS_inserts:\n\nsay \"Executing: Generate_IDCAMS_VTS_inserts\"\n\ncall init_control_card\njctype = \"q\"\ncall generate_jobcard\ncall generate_IDCAMS_step\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with volume .\n\n   queue \"CREATE VOLUMEENTRY( -\"\n   queue \"                    NAME(V\"volume\") -\"\n   queue \"                    LIBRARYNAME(XVTS102) -\"\n   queue \"                    STORAGEGROUP(SGVTS) LOCATION(LIBRARY) -\"\n   queue \"                    MEDIATYPE(MEDIA2) USEATTRIBUTE(PRIVATE) -\"\n   queue \"                  )\"\n   queue \" \"\n   end\n\ncall term_control_card\n\nreturn /* from Generate_IDCAMS_listcat */\n\n/***********************************************************************\n* IDCAMS LISTCAT                                                       *\n***********************************************************************/\n\nGenerate_IDCAMS_listcat:\n\nsay \"Executing: Generate_IDCAMS_listcat\"\n\nsay \"Specify Master Catalog or null for none...\"\npull scat\nscat = translate(scat)\nif strip(scat) <> \"\" then say \"Thanks for the catalog: \"scat\n\ncall init_control_card\njctype = \"q\"\ncall generate_jobcard\ncall generate_IDCAMS_step\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   if scat == \"\" then do\n      queue \" LISTCAT ENTRY('\"dsname\"')\"\n      end\n   else do\n        queue \" LISTCAT ENTRY('\"dsname\"') - \"\n        queue \"         CATALOG('\"scat\"') ALL\"\n        end\n\n   end\n\ncall term_control_card\n\nreturn /* from Generate_IDCAMS_listcat */\n\n/***********************************************************************\n* IDCAMS deletes                                                       *\n***********************************************************************/\n\nGenerate_IDCAMS_deletes:\n\naddress TSO cmd_cls\nsay \"Executing: Generate_IDCAMS_deletes\"\n\nsay \" \"\nsay \"To perform NOSCRATCH hit enter (null)\"\npull scratchr\nif scratchr = \"\" then scratch = \"NOSCRATCH\"\nelse scratch = \"\"\n\nselect\n  when smfid == \"XYZ1\" then tocat = \"CATALOG.MASTER1\"\n  when smfid == \"XYZ2\" then tocat = \"CATALOG.MASTER2\"\n  when smfid == \"XYZ5\" then tocat = \"CATALOG.MASTER5\"\n  otherwise\n       tocat = \"n/a\"\n       end\n\nloop = 1\ndo while loop = 1\n   say \" \"\n   say \"Catalog Resolution needed, select options below:\"\n   say \"1 - Use default catalog\" tocat\n   say \"2 - I want to be prompted for new catalog name\"\n   say \"3 - No catalog desired\"\n   say \"X - exit\"\n   pull tocatr\n   select\n     when tocatr == \"1\" then leave\n     when tocatr == \"2\" then do\n                             say \"Enter catalog\"\n                             pull tocat\n                             leave\n                             end\n     when tocatr == \"3\" then do\n                             tocat = \"\"\n                             leave\n                             end\n     when translate(tocatr) == \"X\" then exit\n     otherwise\n          say \"Invalid option: \"tocatr\n          end\n     end\n\njobinfo = \"Delete NonVSAM datasets\"\n\ncall init_control_card\njctype = \"q\"\ncall generate_jobcard\ncall generate_IDCAMS_step\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   if tocat <> \"\" then cont = \"-\"\n   else cont = \"\"\n\n   queue \" DELETE '\"dsname\"'\" scratch cont\n   if tocat <> \"\" then queue \"        CATALOG('\"tocat\"')\"\n\n   end\n\ncall term_control_card\n\nreturn /* from Generate_IDCAMS_deletes */\n\n/***********************************************************************\n* IDCAMS catalogs\n*\n*   DEFINE NONVSAM( -\n*                   NAME(ndsname) -\n*                   VOLUMES(volume) -\n*                   DEVICETYPES(3380) -\n*                 )\n***********************************************************************/\n\nGenerate_IDCAMS_catalogs:\n\nsay \"Executing: Generate_IDCAMS_catalogs\"\n\n\n/*\n |  Prompt for dataset verification via LISTDSI\n */\n\ndelem = \"N\"\nsay \"UnCatalogue as well (Y OR N)\"\npull delemr\ndelemr = translate(delemr)\nselect\n when substr(delemr,1,1) == \"Y\" then delem = \"Y\"\n when substr(delemr,1,1) == \"N\" then delem = \"N\"\n otherwise\n      say \"Invalid response, not going to delete\"\n      end\n\nif delem = \"Y\" then say \"Will delete datasets prior to define\"\nelse say \"Will NOT delete dataset prior to define\"\n\nsay \"Specify Master Catalog or null for none...\"\npull scat\nscat = translate(scat)\nif strip(scat) <> \"\" then say \"Thanks for the catalog: \"scat\n\ncall init_control_card\ncall generate_jobcard\ncall generate_IDCAMS_step\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   /*\n    |      dsname = strip(dsname)\n    |      ndsname = translate(dsname,' ','.')\n    |      ndsname = delword(ndsname,1,1)\n    |      ndsname = \"HPS.\"ndsname\n    |      ndsname = translate(ndsname,'.',' ')\n    */\n\n   if delem == \"Y\" then do\n      if scat == \"\" then ,\n         QUEUE \" DELETE \"dsname \" NOSCRATCH \"\n      else do\n           QUEUE \" DELETE \"dsname \" NOSCRATCH - \"\n           QUEUE \"        CATALOG(\"scat\")\"\n           end\n      end\n\n   QUEUE \" DEFINE NONVSAM( - \"\n   QUEUE \"                 NAME(\"dsname\") - \"\n   QUEUE \"                 VOLUMES(\"volume\") - \"\n   QUEUE \"                 DEVICETYPES(3390) - \"\n\n   if scat == \"\" then QUEUE \"               )\"\n   else do\n        QUEUE \"                 ) -\"\n        QUEUE \"                 CATALOG(\"scat\")\"\n        end\n\n   /*\n    |  QUEUE ' DEFINE ALIAS( -               '\n    |  QUEUE '               NAME(OS390R6U.'ndsname') - '\n    |  QUEUE '               RELATE('ndsname') - '\n    |  QUEUE '             ) -'\n    |  QUEUE '             CATALOG(CATALOG.OS390R6U)'\n    */\n\n   end\n\ncall term_control_card\n\nreturn /* from Generate_IDCAMS_catalogs */\n\n/***********************************************************************\n* IDCAMS catalogs for datasets on the SYSRES\n*\n*   DEFINE NONVSAM( -\n*                   NAME(ndsname) -\n*                   VOLUMES(******) -\n*                   DEVICETYPES(3380) -\n*                 )\n***********************************************************************/\n\nGenerate_IDCAMS_catalogs_SYSRES:\n\naddress TSO cmd_cls\nsay \"Executing: Generate_IDCAMS_catalogs for SYSRES/Symbolics\"\n\nsay \" \"\nsay \"Specify symbolic name or hit enter (null) to use ******\"\npull tovol\nif tovol = \"\" then tovol = \"******\"\n\nselect\n  when smfid == \"XYZ1\" then tocat = \"CATALOG.MASTER1\"\n  when smfid == \"XYZ2\" then tocat = \"CATALOG.MASTER2\"\n  when smfid == \"XYZ5\" then tocat = \"CATALOG.MASTER5\"\n  otherwise\n       tocat = \"master.catalog.name.goes.here\"\n       end\nsay \" \"\nsay \"Default Master Catalog:\" tocat\nsay \" \"\nsay \"Specify master catalog name or hit enter (null) for default\"\npull tocatr\nif tocatr <> \"\" then tocat = tocatr\n\njobinfo = \"NonVSAM catalogs to volume \"tovol\" in \"tocat\n\ncall init_control_card\ncall generate_jobcard\ncall generate_IDCAMS_step\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   queue \" DEFINE NONVSAM( - \"\n   queue \"                 NAME(\"dsname\") - \"\n   queue \"                 VOLUMES(\"tovol\") - \"\n   queue \"                 DEVICETYPES(0000) - \"\n   queue \"               ) -\"\n   queue \"               CATALOG(CATALOG.MASTER5)\"\n\n   end\n\ncall term_control_card\n\nreturn /* from Generate_IDCAMS_catalogs_SYSRES */\n\n/***********************************************************************\n* IDCAMS dataset renames\n*\n* ALTER datasetname -\n*       NEWNAME(newdatasetname)\n***********************************************************************/\n\nGenerate_IDCAMS_renames:\n\nsay \"Executing: Generate_IDCAMS_renames\"\n\ncall init_control_card\ncall generate_jobcard\ncall generate_IDCAMS_step\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   dsname = strip(dsname)\n   ndsname = translate(dsname,' ','.')\n   ndsname = delword(ndsname,1,1)\n   ndsname = \"HPS.\"ndsname\n   ndsname = translate(ndsname,'.',' ')\n\n   lineout = \" ALTER \"dsname\" - \"\n   QUEUE lineout\n   lineout = \"       NEWNAME(\"ndsname\")\"\n\n   /*\n    | QUEUE ' IF LASTCC = 0 THEN - '\n    | QUEUE '    DEFINE ALIAS( -               '\n    | QUEUE '    NAME(OS390R6M.'ndsname') - '\n    | QUEUE '    REL('ndsname')) -          '\n    | QUEUE '    CAT(CATALOG.OS390R6M)         '\n    */\n\n   end\n\ncall term_control_card\n\nreturn /* from Generate_IDCAMS_renames */\n\n/***********************************************************************\n |    Create IDCAMS alias control cards\n |\n |    DEFINE ALIAS ( -\n |                   NAME(newname) -\n |                   RELATE(current.name ) -\n |                 ) -\n |                 CATALOG(CATALOG.MASTER5)\n **********************************************************************/\n\nGenerate_IDCAMS_alias:\n\nsay \"Executing: Generate_IDCAMS_alias\"\nsay \"--> It is assumed that the input has the current name and\" ,\n    \"and new.names as the first and second 'words' of the file\"\n\ncall init_control_card\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with cname nname .\n\n   cname = translate(strip(cname)) /* uppercase + strip */\n   nname = translate(strip(nname))\n\n   push \"             CATALOG(CATALOG.MASTER5)\"\n   push \"             ) -\"\n   push \"               RELATE(\"cname\") -\"\n   push \"               NAME(\"nname\") -\"\n   push \"DEFINE ALIAS ( -\"\n\n   end\n\njctype = \"p\"\ncall generate_IDCAMS_step\ncall generate_jobcard\ncall term_control_card\n\nreturn /* from Generate_IDCAMS_alias */\n\n/***********************************************************************\n* Generate DMS (SAMS:DISK) archive control cards out\n*\n* ARCHIVE DSN=dsname,RETPD=700,SCRATCH\n***********************************************************************/\n\nGenerate_DMS_archives:\n\ncall init_control_card\n\nsay \"Executing: Generate_DMS_archives\"\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   dsname = strip(dsname)\n   ndsname = translate(dsname,' ','.')\n   ndsname = delword(ndsname,1,1)\n   ndsname = \"HPS.\"ndsname\n   ndsname = translate(ndsname,'.',' ')\n\n   lineout = \" ARCHIVE DSN=\"dsname\",SCRATCH,RECATALOG\"\n   PUSH lineout\n\n   end\n\n   lineout = \"//SYSIN  DD  *\"\n   PUSH lineout\n   lineout = \"//           S='*'\"\n   PUSH lineout\n   lineout = \"//         EXEC  ARCHIVE,\"\n   PUSH lineout\n   lineout = \"//jobname JOB card,TIME=1439,CLASS=U\"\n   PUSH lineout\n\ncall term_control_card\n\nreturn /* from Generate_DMS_archives */\n\n/***********************************************************************\n* Generate Restore job stream\n*\n* This can be used to get all datasets recalled back on DASD\n***********************************************************************/\n\nGenerate_RESTORE_JCL_cards:\n\nsay \"Executing: Generate_Restore-JCL-Cards\"\n\ncall init_control_card\ncall generate_jobcard\n\nqueue '//****************************************************'\nqueue '//**   ACCESS A DATASET IN BATCH TO RECALL IT'\nqueue '//****************************************************'\nqueue '//RESTORE  PROC DSN='\nqueue '//PDS      EXEC PGM=IEBGENER,COND=EVEN'\nqueue '//SYSIN    DD DUMMY'\nqueue '//SYSPRINT DD SYSOUT=*'\nqueue '//SYSUDUMP DD SYSOUT=*'\nqueue '//ABNLDUMP DD DUMMY'\nqueue '//SYSUT1   DD DISP=SHR,DSN=&DSN'\nqueue '//SYSUT2   DD DISP=(,DELETE),UNIT=SYSDA,SPACE=(CYL,10)'\nqueue '// PEND'\nqueue '//* --------------------------------------------------'\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   dsname = strip(dsname)\n\n   queue \"//#\"i\" EXEC RESTORE,DSN='\"dsname\"'\"\n   end\n\ncall term_control_card\n\nreturn /* from Generate_RESTORE_JCL_cards */\n\n/***********************************************************************\n* Generate IEBCOPY with replace\n***********************************************************************/\n\nGenerate_IEBCOPY_Replace:\n\nsay \"Executing: Generate_IEBCOPY_Replace\"\n\nsay \" \"\nsay \"Specify to volume or hit enter for 'bozo'\"\npull tovol\nif tovol = \"\" then tovol = \"BOZO\"\n\ncall init_control_card\ncall generate_jobcard\n\nn = 0\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   dsname = strip(dsname)\n   n = n + 1\n\n   queue \"//*\"\n   queue \"//** Process library:\" dsname\n   queue \"//*\"\n   queue \"//CLR\"n\"  EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,REGION=9M\"\n   queue \"//SYSUDUMP DD SYSOUT=*\"\n   queue \"//SYSTSPRT DD SYSOUT=*\"\n   queue \"//SYSTSIN  DD *\"\n   queue \" \"cmd_pds\" '\"dsname\"' VOLUME(\"tovol\")\"\n   queue \"      DELETE  :\"\n   queue \"      COMPRESS SHR\"\n   queue \"      END\"\n   queue \"/*\"\n   queue \"//*\"\n   queue \"//COPY\"n\"  EXEC PGM=IEBCOPY,TIME=1439,REGION=9M\"\n   queue \"//VDSBYPAS DD DUMMY\"\n   queue \"//SYSPRINT DD SYSOUT=*\"\n   queue \"//IN1      DD DISP=SHR,DSN=\"dsname\",\"\n   queue \"//            UNIT=SYSALLDA,VOL=SER=\"volume\n   queue \"//OUT1     DD DISP=SHR,DSN=\"dsname\",\"\n   queue \"//            UNIT=SYSALLDA,VOL=SER=\"tovol\n   queue \"//SYSUDUMP DD SYSOUT=*\"\n   queue \"//SYSIN    DD *\"\n   queue \"  COPY INDD=((IN1,R),OUTDD=OUT1\"\n   queue \"/*\"\n\n   end\n\ncall term_control_card\n\nreturn /* from Generate_RESTORE_JCL_cards */\n\n/***********************************************************************\n* Show PDS directory information\n***********************************************************************/\n\nShow_directory_information:\n\nsay \"Directory information:\"\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   fq_dsname = \"'\"strip(dsname)\"'\"\n   say \"Processing dsn=\"fq_dsname\n\n   x = LISTDSI(fq_dsname)\n   if x <> 0 then do\n      say \"> Could not find DSN:\" fq_dsname\n      say \"  > \"sysmsglvl1\n      say \"  > \"sysmsglvl2\n      say \"  > SYSREASON: \"sysreason\n      iterate\n      end\n\n    if sysdsorg == \"PO\" then do\n       x = LISTDSI(fq_dsname \"DIRECTORY\") /* get directory bl   ks */\n       say   \"> Directory used....\"sysudirblk\n       say   \"> Directory alloc...\"sysadirblk\n       end\n    else say \"> Skipping dataset, Not a PDS\"\n   end /* of select */\n\nreturn /* from Show_Directory_information */\n\n/***********************************************************************\n* Invoke DSAT to show information on cataloged version of these datasets\n* The volume field is ignored\n*\n* In case the user wants the \"DSAT\" command generated for use elsewhere\n* (like to rerun in batch to get the output), we put the command out.\n***********************************************************************/\n\nInvoke_DSAT:\n\naddress TSO \"CLS\"\nsay \"Showing Dataset information for cataloged versions:\"\n\ncall init_control_card\njobinfo = \"Invoke the DSAT command\"\ncall generate_jobcard\nqueue '//DSATING EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100'\nqueue '//SYSTSPRT DD SYSOUT=*'\nqueue '//SYSTSIN  DD *'\n\nd = 0\n\nfdsn = \"\"\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   /* Here we try to get rid of a trailing comma.  This is goodnes\n      if we are processing sys1.parmlib(LPALSTxx) */\n   dsname = translate(dsname,\" \",\",\")\n\n   fdsn = fdsn ||\" '\"strip(dsname)\"'\"\n\n   d = d + 1\n   select\n     when d == 1 then queue \" DSAT ('\"strip(dsname)\"' +\"\n     when i == sysut1_file.0 then queue \"       '\"strip(dsname)\"')\"\n     otherwise\n        queue \"       '\"strip(dsname)\"' +\"\n        end\n\n   end\n\ncall \"OUTTRAP\" \"dsat.\",\"*\"\naddress TSO \"DSAT (\"fdsn\")\"\ncall \"OUTTRAP\" \"OFF\"\n\nqueue '//'\nqueue '//* Output from DSAT:'\nqueue '//* '\ndo i = 1 to dsat.0\n   queue left('//* 'dsat.i,71)\n   end\n\ncall term_control_card\n\nreturn /* from Invoke_DSAT */\n\n/***********************************************************************\n* Write out volser\n***********************************************************************/\n\nWrite_out_Volser:\n\nsay \"Writing out volser information:\"\n\ncall init_control_card\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   fq_dsname = \"'\"strip(dsname)\"'\"\n   say \"Processing dsn=\"fq_dsname\n\n   x = LISTDSI(fq_dsname)\n   if x <> 0 then do\n      say \"          > Could not find DSN:\" fq_dsname\n      say \"            > \"sysmsglvl1\n      say \"            > \"sysmsglvl2\n      say \"            > SYSREASON: \"sysreason\n      sysvolume = \"??????\"\n      end\n   queue dsname sysvolume\n\n   end\n\ncall term_control_card\nreturn /* from Write_out_Volser */\n\n/***********************************************************************\n* Generate DDNAMEs - good for use with the DA$PDSR utility\n***********************************************************************/\n\nGenerate_DDNAMEs:\n\nsay \"Writing out //DDNAMEs:\"\n\ncall init_control_card\n\nn = 0\njc = 0\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volser .\n\n   dsname = translate(strip(dsname))\n   if volser == \"\" then comma = \"\"\n   else comma = \",\"\n\n   jc = jc + 1\n   if jc == 999 then do\n      queue '//*---> jobcard and new step jcl needed here'\n      jc = 0\n      n = 0\n      end\n\n   if n < 100 then ,\n      queue \"//SYSLIB\"right(n,2,'0')\" DD DISP=SHR,DSN=\"dsname||comma\n   else queue \"//SYSLI\"right(n,3,'0')\" DD DISP=SHR,DSN=\"dsname||comma\n   if comma <> \"\" then ,\n      queue \"              UNIT=SYSALLDA,VOL=SER=\"volser\n\n   n = n + 1\n   end\n\ncall term_control_card\nreturn /* from Generate_DDNAMEs */\n\n/***********************************************************************\n* Generate PROGxx style APFLST\n***********************************************************************/\n\nGenerate_APFLST:\n\nsay \"Writing out new PROGxx APFLST\"\n\ncall init_control_card\n\nn = 0\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   dsname = translate(strip(dsname))\n   volume = translate(strip(volume))\n\n   apfadd = \"APF ADD DSNAME(\"dsname\")\"\n   queue left(apfadd,56)\" VOLUME(\"volume\")\"\n\n   n = n + 1\n   end\n\ncall term_control_card\nreturn /* from Generate_APFLST */\n\n/***********************************************************************\n* Generate XMIT commands or job\n***********************************************************************/\nGenerate_XMIT_Commands:\njcl = 0\nsignal gxjStart\n\nGenerate_XMIT_job:\njcl = 1\n\nsay \"Executing: Generate_XMIT_Job\"\ngxjStart:\nsay \" \"\n\nsay \"Enter XMIT output dataset method\"\nsay \"1 userid.SPFTEMP7.whatever (-1 first node) <-- Default\"\nsay \"2 userid.SPFTEMP7.whatever (-2 first nodes)\"\nsay \"3 userid.whatever\"\nsay \"4 userid.B.whatever\"\nsay \"5 SYS2.whatever\"\npull methodr\nmethodr = strip(methodr)\nselect\n   when methodr == \"\"  then method = \"1\"\n   when methodr == \"1\" then method = \"1\"\n   when methodr == \"2\" then method = \"2\"\n   when methodr == \"3\" then method = \"3\"\n   when methodr == \"4\" then method = \"4\"\n   when methodr == \"5\" then method = \"5\"\n   otherwise\n        say \"Unrecognized method number, using option 1\"\n        method = 1\n        end\ndlist.0 = 0\n\ncall init_control_card\nif jcl = 1 then call generate_jobcard\nn = 0\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   dsname = strip(dsname)\n   n = n + 1\n\n   dsname = strip(dsname)\n   select\n     when method = \"1\" then do\n          ndsname = translate(dsname,' ','.')\n          ndsname = delword(ndsname,1,1)\n          ndsname = userid\".SPFTEMP7.\"ndsname\".XMI\"\n          ndsname = translate(ndsname,'.',' ')\n          end\n     when method = \"2\" then do\n          ndsname = translate(dsname,' ','.')\n          ndsname = delword(ndsname,1,1)\n          ndsname = delword(ndsname,1,1)\n          ndsname = userid\".SPFTEMP7.\"ndsname\".XMI\"\n          ndsname = translate(ndsname,'.',' ')\n          end\n     when method = \"3\" then do\n          ndsname = sysvar('sysuid')\".\"dsname\".XMI\"\n          j = dlist.0\n          j = j + 1\n          dlist.j = ndsname\n          dlist.0 = j\n          end\n     when method = \"4\" then do\n          ndsname = sysvar('sysuid')\".B.\"dsname\".XMI\"\n          j = dlist.0\n          j = j + 1\n          dlist.j = ndsname\n          dlist.0 = j\n          end\n     when method = \"5\" then do\n          ndsname = \"SYS2.\"dsname\".XMI\"\n          j = dlist.0\n          j = j + 1\n          dlist.j = ndsname\n          dlist.0 = j\n          end\n     otherwise\n          ndsname = \"Internal.error.in.ispf34l.exec\"\n          nop\n          end\n\n   if length(ndsname) > 43 then do\n      say \"Warning: DSN generated over 44 characters:\"\n      say \"DSN=\"ndsname\n      end\n\n   if jcl = 1 then do\n      queue \"//*\"\n      queue \"//** XMIT: \"dsname\n      queue \"//*\"\n      queue \"//XMIT#\"n\" EXEC PGM=IKJEFT01,\"|| ,\n            \"TIME=1439,DYNAMNBR=100,REGION=9M\"\n      queue \"//SYSUDUMP DD SYSOUT=*\"\n      queue \"//SYSTSPRT DD SYSOUT=*\"\n      queue \"//SYSTSIN  DD *\"\n      queue \" /* ==================================================\" ,\n            \"#\" n \"*/\"\n\n      queue \" DSAT '\"dsname\"'\"\n      queue \" \"\n      end\n   queue \" XMIT A.B DA('\"dsname\"') +\"\n   queue \"      OUTDATASET('\"ndsname\"')\"\n   if length(ndsname) > 43 then do\n      g = \"....+....1....+....2....+....3....+....4....\"\n      queue \" /* Fix via:      \"g \"*/\"\n      end\n   if jcl = 1 then queue \"/*\"\n   end\n\nif jcl = 1 then ,\n   do j = 1 to dlist.0\n      queue \"//* DELETE '\"dlist.j\"'\"\n      end\n\ncall term_control_card\n\nreturn /* from Generate_XMIT_job */\n\n/***********************************************************************\n* Do HLQ analysis\n***********************************************************************/\n\nDo_HLQ_Analysis:\n\nsay \"Executing: Do_HLQ_Analysis\"\nsay \" \"\ncall init_control_card\nlasthlq = \"\"\n\nn = 0\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname .\n\n   dsname = strip(dsname)\n   n = n + 1\n\n   dsname = strip(dsname)\n   ndsname = translate(dsname,' ','.')\n\n   hlq = word(ndsname,1)\n   if hlq <> lasthlq then do\n      queue hlq\n      lasthlq = hlq\n      end\n\n   end\n\ncall term_control_card\nreturn /* from Do_HLQ_Analysis */\n\n\n/*---------------------------------------------------------------------\n | FTP MS/DOS batch file\n |\n | On the PC, the syntax is \"batchfile password\"\n | where \"password\" is the password for the userid\n ------------------------------------------------------------------- */\n\nGenerate_FTPGET:\n\nsay \"Writing out MS/DOS FTP GET batch file\"\n\nttype = \"\"\nsay \"Do you want a binary transfer? (Yes or No)\"\npull ttyper\nttyper = translate(ttyper)\nselect\n  when substr(ttyper,1,1) == \"Y\" then ttype = \"binary\"\n  when substr(ttyper,1,1) == \"N\" then ttype = \"ascii\"\n  otherwise\n       say \"Response not Yes or No, assuming Binary\"\n       ttype = \"binary\"\n       end\n\nmvsuser = sysvar('sysuid')\nsay \"Enter null to use userid=\"mvsuser\" or enter userid\"\npull mvsuserr\nif strip(mvsuserr) <> \"\" then mvsuser = mvsuserr\n\ndelwordr = 1\nsay \"How many nodes to delete at front of XMIT dataset?\"\nsay \"> Null = 2\"\npull delwordr\nselect\n   when delwordr = \"1\" then delword = 1\n   when delwordr = \"2\" then delword = 2\n   when delwordr = \"3\" then delword = 3\n   otherwise\n        say \"Invalid node deletion value, terminating\"\n        say \"Using 2\"\n        end\n\nccl = \"255\"   /* LRECL(\"ccl\") BLKSIZE(\"ccb\") RECFM(\"ccf\")\" */\nccb = \"32760\" /* LRECL(\"ccl\") BLKSIZE(\"ccb\") RECFM(\"ccf\")\" */\nccf = \"V B\"   /* LRECL(\"ccl\") BLKSIZE(\"ccb\") RECFM(\"ccf\")\" */\ncall init_control_card\n\nqueue \"@echo off\"\nqueue \"echo open \"sysvar('sysnode')\">t\"\nqueue \"echo user \"mvsuser \"%1>>t\"\nqueue \"echo \"ttype\">>t\"\n\nn = 0\n\ndo i = 1 to sysut1_file.0\n   if sysut1_file.i == \"\" then iterate /* skip null lines */\n\n   parse value sysut1_file.i with dsname volume .\n\n   dsname = translate(strip(dsname))\n   dsname = strip(dsname)\n   ndsname = translate(dsname,' ','.')\n   do j = 1 to delword\n      ndsname = delword(ndsname,1,1)\n      end\n   ndsname = translate(ndsname,'.',' ')\n\n   queue \"echo get '\"dsname\"' \"ndsname\">>t\"\n\n   n = n + 1\n   end\n\nqueue \"echo quit>>t\"\nqueue \"ftp -n -s:t\"\nqueue \"del t\"\n\ncall term_control_card\nreturn /* from Generate_APFLST */\n\n/***********************************************************************\n* The end of ISPF34L exec\n***********************************************************************/\n\n/* | ---------EEEEEEEE---------NN-----NN---------DDDDDDD--------- |\n   | ---------EE---------------NNNN---NN---------DD----DD-------- |\n   | ---------EEEEE------------NN-NN--NN---------DD----DD-------- |\n   | ---------EE---------------NN---NNNN---------DD----DD-------- |\n   | ---------EEEEEEEE---------NN----NNN---------DDDDDDD--------- | */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JES2EXIT": {"ttr": 23043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x01\\x00\\x00\\x00\\x99\\x06\\x0f\\x01\\x020o\\x13F\\x0b\\xdd\\x0b\\xe1\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.01", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T13:46:00", "lines": 3037, "newlines": 3041, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 0100-98016-98016-1800-00019-00019-00000-DALCOCK\n The contents of this file are FREEWARE. Use at your own risk. It\n is provided for your enjoyment and neither David Alcock or his\n employer provides any warranty for their use.  I'd like to hear how\n they work on your system:\n\n    David Alcock :: dave@planetmvs.com\n\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n This is collection of my JES2 exits. I have attempted to remove all\n the installation code and have changed our company prefix for messages\n and such to \"XYZ\".  Please run on your test machine first.  It is quite\n possible that during my edit I could have deleted something useful.\n\n Probably the only one worth your while is my JES2 Exit 6.\n./ ADD NAME=XYZJ2#02 0100-98016-98016-1800-00056-00056-00000-DALCOCK\n MACRO\n XYZJ2#02\n.**********************************************************************\n.***                                                                ***\n.**  Name: XYZJ2#02                                                  **\n.**                                                                  **\n.**  Purpose: External mappings for XYZ JES2 exit 2, XYZJ2X02, for   **\n.**           data in the XYZJ2#02 module.                           **\n.**                                                                  **\n.**  Note: The XYZJ2#02 module is a part of the XYZJ2X02 load module **\n.**        that is available to other programs via the alias to      **\n.**        CSECT XYZJ2#02.                                           **\n.***                                                                ***\n.**********************************************************************\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   24-AUG-1995 Created this mapping macro to be used by  **\n.**                        JES2 exit XYZJ2X02 and external programs  **\n.**                        that read the XYZJ2#02 module;            **\n.***                                                                ***\n.**********************************************************************\n*\n** External data (XYZJ2#02) mappings\n*\nJ2X02ED        DSECT ,\nJ2X02EDH       EQU   *                 Module header\nJ2X02EDH_J2VS  DS    X'00,04,02,00'    ..JES2 version (short)\nJ2X02EDH_J2VER DS    CL8'SP 4.2.0'     ..JES2 version\nJ2X02EDH_ID    DS    CL8'XYZJ2#02'     ..Module name\nJ2X02EDH_ASMD  DS    CL10'1962/03/06'  ..Assembly date\nJ2X02EDH_ASMT  DS    CL6'21:00'        ..Assembly time\nJ2X02EDH_DBJOB DS    CL8'jobname'      ..debugging jobname\nJ2X02EDHL      EQU   *-J2X02EDH\n*\nJ2X02EDE       EQU   *                 Data area entry\nJ2X02EDE_TYPE  DS    CL2               ..Data area Type\n$J2X02EDE_TSS  EQU   C'SS'             ..Job Name table\nJ2X02EDE_OFF   DS    XL2               ..Offset to data area\nJ2X02EDEL      EQU   *-J2X02EDE        Data area entry\n#J2X02EDE_END  EQU   X'FF'             End of table\n*\n** Jobname Table\n*\nJ2X02SS        DSECT ,\nJ2X02SS_JNAMEL DS    X                 Jobname length\nJ2X02SS_JNAME  DS    CL8               Jobname value\nJ2X02SS_CLASS  DS    C                 Class to be assigned\nJ2X02SSL       EQU   *-J2X02SS\n.*\n.** End of macro\n.*\n MEND ,\n./ ADD NAME=XYZJ2#06 0100-98016-98016-1800-00090-00090-00000-DALCOCK\n MACRO\n XYZJ2#06\n.**********************************************************************\n.***                                                                ***\n.**  Name: XYZJ2#06                                                  **\n.**                                                                  **\n.**  Purpose: External mappings for XYZ JES2 exit 6, XYZJ2X06, for   **\n.**           data in the XYZJ2#06 module.                           **\n.**                                                                  **\n.**  Note: The XYZJ2#06 module is a part of the XYZJ2X06 load module **\n.**        that is available to other programs via the alias to      **\n.**        CSECT XYZJ2#06.                                           **\n.***                                                                ***\n.**********************************************************************\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   16-SEP-1994 Created this mapping macro to be used by  **\n.**                        JES2 exit XYZJ2X06 and external programs  **\n.**                        that read the XYZJ2#06 module;            **\n.***                                                                ***\n.**********************************************************************\n*\n** External data (XYZJ2#06) mappings\n*\nJ2X06ED        DSECT ,\nJ2X06EDH       EQU   *                 Module header\nJ2X06EDH_J2VS  DS    X'00,04,02,00'    ..JES2 version (short)\nJ2X06EDH_J2VER DS    CL8'SP 4.2.0'     ..JES2 version\nJ2X06EDH_ID    DS    CL8'XYZJ2#06'     ..Module name\nJ2X06EDH_ASMD  DS    CL10'1962/03/06'  ..Assembly date\nJ2X06EDH_ASMT  DS    CL6'21:00'        ..Assembly time\nJ2X06EDH_DBJOB DS    CL8'jobname'      ..debugging jobname\nJ2X06EDHL      EQU   *-J2X06EDH\n*\nJ2X06EDE       EQU   *                 Data area entry\nJ2X06EDE_TYPE  DS    CL2               ..Data area Type\n$J2X06EDE_TJC  EQU   C'JC'             ..Job Class rules (T_RULES)\n$J2X06EDE_TFQ  EQU   C'FQ'             ..Frequency (T_FREQ)\n$J2X06EDE_TNP  EQU   C'NP'             ..Non-Production jobname\n$J2X06EDE_TTU  EQU   C'TU'             ..Table unit table\nJ2X06EDE_OFF   DS    XL2               ..Offset to data area\nJ2X06EDEL      EQU   *-J2X06EDE        Data area entry\n#J2X06EDE_END  EQU   X'FF'             End of table\n*\n** Frequency\n*\nJ2X06FQ        DSECT ,\nJ2X06FQ_VALUE  DS    C                 Frequency value\nJ2X06FQ_DESC   DS    XL2               Description string offset\nJ2X06FQL       EQU   *-J2X06FQ\n*\n** Tape unit names\n*\nJ2X06TU        DSECT ,\nJ2X06TU_VALUE  DS    CL8'tape'         Tape unit name\nJ2X06TUL       EQU   *-J2X06TU\n*\n** Non-production jobname\n*\nJ2X06NP        DSECT ,\nJ2X06NP_VALUE  DS    CL6\nJ2X06NP_LENGTH DS    X\nJ2X06NP_START  DS    X\nJ2X06NP_DESC   DS    XL2\nJ2X06NPL       EQU   *-J2X06NP\n*\n** JCL rules (by job class)\n*\nJ2X06JC        DSECT ,\nJ2X06JC_CLASS  DS    CL1                Job class\nJ2X06JC_TIME   DS    0CL8               Time\nJ2X06JC_TIMEM  DS    CL6'000000'        ..Minutes\nJ2X06JC_TIMES  DS    CL2'00'            ..Seconds\n$J2X06JC_TIMEUT1 EQU C' '               ..Time is Unlimited - test 1\n$J2X06JC_TIMEUT2 EQU C'*'               ..Time is Unlimited - test 2\nJ2X06JC_TAPE   DS    C' '                Allow Tapes?\n$J2X06JC_TAPEY EQU   C'Y'                ..Yes\n$J2X06JC_TAPEN EQU   C'N'                ..No\nJ2X06JC_DESC   DS    XL2                 Offset to description string\nJ2X06JCL       EQU   *-J2X06JC           Length of entry\n#J2X06JC_DTL   EQU   10                  Length of Turnaround part\n#J2X06JC_DDO   EQU   3  ' | '            Offset past ' | '\n.*\n.** End of macro\n.*\n MEND ,\n./ ADD NAME=XYZJ2X02 0100-98016-98016-1800-00325-00325-00000-DALCOCK\nXYZJ2X02 TITLE 'JES2 EXIT 2 - JOB statement scan'\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n** Name: XYZJ2X02                                                    **\n**                                                                   **\n** Author: David Alcock                                              **\n**         1616 Woodall Rodgers Freeway                              **\n**         Dallas, Tx 75266                                          **\n**         (214) 777-1816                                            **\n**                                                                   **\n**         Modified from earlier XYZ source                          **\n**                                                                   **\n** Purpose: Change some started task default output class.           **\n**                                                                   **\n** Non-standard macros:                                              **\n** - XYZJ2X02....Mapping macro for DSECTs that we make available in  **\n**               CSECT/module XYZJ2#02.                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   14-APR-1996 JES2 4.3 changes;                          **\n** DGAlcock   17-JAN-1996 Add ES01DDEL to class=Z;                   **\n** DGAlcock   24-AUG-1995 Add EDMMGR* to class F; Change to use      **\n**                        external table XYZJX#02                    **\n** DGAlcock   15-DEC-1994 Add NSITE* to class F; IDMS to class N;    **\n** DGAlcock   01-APR-1993 Added DMSAR started task to null;          **\n** DGAlcock   08-FEB-1993 Added IDMS STCs to Class F (Infopac);      **\n** DGAlcock   15-SEP-1992 Coverted to JES2 SP4.2;                    **\n***                                                                 ***\n***********************************************************************\n         EJECT\n*\n** XYZ macros\n*\n         PRINT GEN\n         XYZJ2#02 ,                       Get our mapping DSECTs\n*\n** Global stuff\n*\n         GBLC  &DBGJNME                Generate global variable\n&DBGJNME SETC  'ibmuserZ'              ..Jobname for debugging info\n         EJECT ,\n         COPY  $HASPGBL\nXYZJ2X02 $MODULE ENVIRON=JES2,                                         @\n               RMODE=ANY,                                              @\n               IBMJES2=SAMPLE,                                         @\n               TITLE='JES2 EXIT 2 - JOB statement scan',               @\n               $HASPEQU,                                               X\n               $BUFFER,                                                X\n               $CAT,                                                   X\n               $COMWORK,                                               X\n               $HCT,                                                   X\n               $PADDR,                                                 X\n               $JCT,                                                   X\n               $JOE,                                                   X\n               $JQE,                                                   X\n               $MIT,                                                   X\n               $PCE,                                                   X\n               $RDRWORK,                                               X\n               RPL,                                                    X\n               RESPA\n         PRINT ON\n***********************************************************************\n*                                                                     *\n* OVERVIEW:                                                           *\n*                                                                     *\n*        THIS EXIT IS TAKEN FROM HASPRDR AFTER JES2 HAS OBTAINED      *\n*        AND INITIALIZED THE JCT BUT BEFORE PERFORMING THE            *\n*        STANDARD JOB STATEMENT PROCESSING.  ANY CHANGES TO THE       *\n*        JCT WILL BE CHANGED LATER BY THE JOB STATEMENT SCAN IF       *\n*        JOB STATEMENT HAS A PARAMETER CODED THAT OVERRIDES THE       *\n*        DEFAULT.                                                     *\n*                                                                     *\n*        THE STATEMENT ITSELF IS LOCATED IN THE IMAGE BUFFER          *\n*        (ADDRESS AT R1 + 0) AND CAN BE ALTERED BY EXIT2 BEFORE       *\n*        RETURNING TO HASPRDR FOR JOB STATEMENT PROCESSING.           *\n*                                                                     *\n* LINKAGE:                                                            *\n*                                                                     *\n*        BRANCH ENTERED FROM THE JES2 EXIT EFFECTOR                   *\n*                                                                     *\n* ENVIRONMENT:                                                        *\n*                                                                     *\n*        JES2 MAINTASK                                                *\n*                                                                     *\n* RECOVERY:                                                           *\n*                                                                     *\n*        NONE                                                         *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n* INPUT   R0  = A CODE INDICATING THE TYPE OF JOB STATEMENT BEING     *\n*               SCANNED                                               *\n*               0  INDICATES AN INITIAL JOB STATEMENT IMAGE           *\n*               4  INDICATES A SUBSEQUENT JOB CONTINUATION STATEMENT  *\n*                                                                     *\n*         R1  = ADDRESS OF A 3-WORD PARAMETER LIST WITH THE FOLLOWING *\n*               STRUCTURE:                                            *\n*               WORD 1 (+0) POINTS TO THE JOB STATEMENT IMAGE BUFFER  *\n*               WORD 2 (+4) POINTS TO THE EXIT FLAG BYTE,             *\n*                           RDWFLAGX, IN THE PCE                      *\n*               WORD 3 (+8) POINTS TO THE JCTXWRK FIELD IN THE JCT    *\n*                                                                     *\n*         R2-R9 = N/A                                                 *\n*         R10 = ADDRESS OF JCT                                        *\n*         R11 = ADDRESS OF HCT                                        *\n*         R12 = N/A                                                   *\n*         R13 = ADDRESS OF PCE                                        *\n*         R14 = RETURN ADDRESS                                        *\n*         R15 = ADDRESS OF ENTRY POINT                                *\n*                                                                     *\n* OUTPUT  R15 = RETURN CODE                                           *\n*         (ALL OTHERS UNCHANGED)                                      *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE (INTERNAL): R0-R7   = WORK REGISTERS                 *\n*                            R8      = JOB STATEMENT IMAGE BUFFER     *\n*                            R9      = NOT USED                       *\n*                            R10     = ADDRESS OF THE JCT             *\n*                            R11     = ADDRESS OF THE HCT             *\n*                            R12     = EXIT2 ADDRESSABILITY           *\n*                            R13     = ADDRESS OF PCE                 *\n*                            R14-R15 = WORK AND LINKAGE REGISTER      *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT):                                         *\n*                                                                     *\n*        0  -  TELLS JES2 THAT IF THERE ARE ANY OTHER ROUTINES        *\n*              ASSOCIATED WITH THIS EXIT, CALL THE NEXT EXIT.         *\n*              IF THERE ARE NO OTHER ROUTINES, CONTINUE WITH          *\n*              NORMAL HASPRDR PROCESSING.                             *\n*                                                                     *\n*        4  -  TELLS JES2 TO IGNORE ANY ADDITIONAL EXITS ASSOCIATED   *\n*              WITH THIS EXIT AND CONTINUE WITH NORMAL HASPRDR        *\n*              PROCESSING.                                            *\n*                                                                     *\n*        8  -  TELLS JES2 TO CANCEL THE JOB; ANY OUTPUT (THE JCL      *\n*              IMAGE LISTING) IS PRODUCED.                            *\n*                                                                     *\n*        12 -  TELLS JES2 TO PURGE JOB; NO OUTPUT IS PRODUCED.        *\n*                                                                     *\n*                                                                     *\n* OTHER CONSIDERATIONS:                                               *\n*                                                                     *\n*        SEE NOTES.                                                   *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*      THIS EXIT2 ROUTINE WILL BE ENTERED FOR FOR JOBS FROM THE       *\n*      FOLLOWING SOURCES:                                             *\n*                                                                     *\n*        - LOCAL CARD READER                                          *\n*        - REMOTE (RJE) CARD READER                                   *\n*        - TSO LOGONS                                                 *\n*        - STARTED TASKS                                              *\n*        - INTERNAL READERS ALLOCATED TO BATCH JOBS                   *\n*        - INTERNAL READERS ALLOCATED TO STARTED TASKS                *\n*        - INTERNAL READERS ALLOCATED TO TSO USER (TSO SUBMIT)        *\n*        - NJE JOB RECEIVERS                                          *\n*        - SPOOL OFFLOAD JOB RECEIVERS                                *\n*        - EXECUTION BATCH MONITOR (XBM) JOBLET                       *\n*                                                                     *\n*      UPON ENTERING WE WILL:                                         *\n*                                                                     *\n*        1.  TURN OFF THE EXIT2 BIT POSITION OF THE JOB EXIT MASK     *\n*            SO THAT WE DO NOT ENTER FOR SUBSEQUENT JOB CONTINUATION  *\n*            STATEMENTS.                                              *\n*                                                                     *\n*        2.  For started tasks: we will search thru a table and       *\n*            if found, change the default sysout class to the value   *\n*                                                                     *\n***********************************************************************\n         EJECT ,\nEXIT02   $ENTRY BASE=R12\n         $SAVE ,                          Save caller's registers\n         LR    R12,R15                    Load our base register\n         USING JCT,R10                    Get addressibility to JCT\n         LTR   R10,R10                    JCT available?\n         BZ    EXIT0                      No, leave\n*\n** Set it so we don't get called again for this job\n*\n*->      NI    JCTXMASK,B'11011111'    TURN OFF JOB'S EXIT2 EXIT MASK\n*                         ||||||||       SO WE DO NOT ENTER THIS EXIT\n*                 EXITS = 01234567         AGAIN FOR CONTINUATION\n*                                            STATEMENTS\n         SPACE 2\n*\n** Search thru table of started tasks that we change the default\n** SYSOUT class for.\n*\n         CLI   JCTJOBID,C'S'              Started task?\n         BNE   EXIT0                      Yes, continue\n         LA    R0,TABLE#SS                Number in table\n         L     R1,=V(XYZJ2#02)            Locate CSECT\n         LA    R1,TABLE_SS-XYZJ2#02(R1)   Locate table in CSECT\nPST$L    EQU   *\n         CLI   J2X02SS_JNAMEL-J2X02SS(R1),#J2X02EDE_END\n         BE    EXIT0                      Yes, continue\n         SLR   R14,R14                    Clear register\n         IC    R14,J2X02SS_JNAMEL-J2X02SS(R1) Get length to compare\n         EX    R14,PST$C                  Compare jobnames\n         BE    PST$F                      Yes, continue\n         LA    R1,J2X02SSL(R1)            Bump to next entry\n         BCT   R0,PST$L                   And process it\n         B     EXIT0                      Leave, not found in table\nPST$C    CLC   JCTJNAME(0),J2X02SS_JNAME-J2X02SS(R1)\nPST$F    EQU   *\n         MVC   JCTMCLAS(1),J2X02SS_CLASS-J2X02SS(R1)\n*\n** Termination from EXIT02 processing\n*\nEXIT0    EQU   *\n         $RETURN RC=0                     Return to JES2\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LTORG ,                          Literals used in EXIT02\nAPARNUM  DC    CL8'NONE'                  APAR Number\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Tables and data that we will let be externally referenced   **\n**                                                                   **\n**   Note: The H_J2VS/J2X02EDH_J2VS at offset 0 is done to simulate  **\n**         the ADRRELVL and ICKRELVL modules.                        **\n**                                                                   **\n**   Note: You *must* keep the format of this CSECT in sync with the **\n**         XYZJ2X#02 macro or other program that process this module **\n**         will faile.                                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LCLC  &ASMDATE\n* In High-Level-Assembler, &SYSDATC is \"YYYYMMDD\"\n&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n*&ASMDATE SETC  '&SYSDATE'                                        ASM-H\n*\n** Start of CSECT\n*\nXYZJ2#02 CSECT ,\nXYZJ2#02 AMODE 31\nXYZJ2#02 RMODE ANY\n*\nHEADER   EQU   *\nH_J2VS   DC    X'00,04,02,00'                 JES2 short version: 420\nH_J2VER  DC    CL8'&VERSION'                  JES2 version long\nH_ID     DC    CL8'XYZJ2#02'                  Module name\nH_ASMD   DC    CL10'&ASMDATE'                 ASM date: \"1994/03/06\"\nH_ASMT   DC    CL6'&SYSTIME'                  ASM time: \"hh:mm\"\nH_DBJOB  DC    CL8'&DBGJNME'                  Debugging jobname\nHEADERL  EQU   *-HEADER                       Must match J2X02EDHL\nHEADERT  EQU   J2X02EDHL                      Match?  !!!!\n*\n** Offsets for external programs (mapped by J2X02EDE)\n*\nENTRIES  EQU   *\n         DC    AL2($J2X02EDE_TSS,TABLE_SS-XYZJ2#02)   Job table\n         DC    AL1(#J2X02EDE_END)                     End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      Jobname table for started task output class changes        ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\nTABLE_SS DS    0H\n         DC    AL1(4-1),CL8'IDMS    ',C'N'\n         DC    AL1(5-1),CL8'NSITE   ',C'F'\n         DC    AL1(6-1),CL8'EDMMGR  ',C'F'\n*\n         DC    AL1(5-1),CL8'TCPIP   ',C'X'\n         DC    AL1(8-1),CL8'FTPSERVE',C'X'\n         DC    AL1(4-1),CL8'SNMP    ',C'X'\n         DC    AL1(7-1),CL8'LPSERVE ',C'X'\n         DC    AL1(7-1),CL8'PORTMAP ',C'X'\n         DC    AL1(7-1),CL8'WEB3270 ',C'X'\n         DC    AL1(6-1),CL8'GOPHER  ',C'X'\n*\n         DC    AL1(8-1),CL8'ES01DDEL',C'Z'    Eyespy dump processor\n         DC    AL1(5-1),CL8'INIT    ',C'Z'\n         DC    AL1(6-1),CL8'DCCRDR  ',C'Z'\n         DC    AL1(5-1),CL8'DMSAR   ',C'Z'\n         DC    AL1(8-1),CL8'RECALLO ',C'Z'\n         DC    AL1(2-1),CL8'X       ',C'Z'\n         DC    AL1(#J2X02EDE_END),CL8'????????',C'Z'  End of table\n*\n         DC    AL1(8-1),CL8'UNUSED1 ',C'Z'            Zap to use\n         DC    AL1(8-1),CL8'UNUSED2 ',C'Z'            Zap to use\n         DC    AL1(8-1),CL8'UNUSED3 ',C'Z'            Zap to use\nTABLE#SS EQU   (*-TABLE_SS)/J2X02SSL\n         DC    AL1(#J2X02EDE_END),CL8'????????',C'Z'  End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      End of XYZJ2#02 CSECT                                      ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         DC    C'ENDOFXYZJ2#02'           Eyecatcher\n         DS    0D\nXYZJ2L02 EQU   *-XYZJ2#02                 Length (for trivia)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       End of XYZJ2X02 module                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n        $MODEND ,                         Generate end of module\nEXIT02L  EQU   *-EXIT02                   Length of EXIT02\nEXIT02F  EQU   8192-EXIT02L               Bytes free under base regs\n         END   ,\n./ ADD NAME=XYZJ2X04 0100-98016-98016-1800-00239-00239-00000-DALCOCK\nXYZJ2X04 TITLE 'JES2 USER EXIT 4 -- PROLOG (MODULE COMMENT BLOCK)'\n***********************************************************************\n*                                                                     *\n* MODULE NAME : XYZJ2X04                                              *\n*                                                                     *\n* DESCRIPTIVE NAME : JES2 USER EXIT 4  -  JCL/JECL SCAN ROUTINE       *\n*                                                                     *\n* FUNCTION : This exit allows JES2 4.2 to act like previous releases  *\n*            of JES2 and comments out /*ROUTE PRINT njenode for       *\n*            jobs with MSGCLASS=X.                                    *\n*                                                                     *\n* ENVIRONMENT : JES2 MAIN TASK                                        *\n*                                                                     *\n*    ATTRIBUTES = NON-REENTRANT, RMODE(24), AMODE(24/31)              *\n*                                                                     *\n* ENTRY POINTS : EXIT04                                               *\n*                                                                     *\n* REGISTER USAGE (ENTRY/EXIT) :                                       *\n*                                                                     *\n*    REG       VALUE ON ENTRY             VALUE ON EXIT               *\n*                                                                     *\n*    R0        A CODE PASSED TO THE       UNCHANGED                   *\n*              ROUTINE BY JES2:                                       *\n*                0  INDICATES JECL                                    *\n*                4  INDICATES JCL                                     *\n*    R1        ADDRESS OF 3-WORD          UNCHANGED                   *\n*              PARAMETER LIST:                                        *\n*               +0  ADDRESS OF IMAGE BUFFER                           *\n*               +4  ADDRESS OF RDWFLAGX                               *\n*               +8  ADDRESS OF JCTXWRK                                *\n*    R2-R9     N/A                        UNCHANGED                   *\n*    R10       ADDRESS OF THE JCT OR ZERO UNCHANGED                   *\n*    R11       ADDRESS OF THE HCT         UNCHANGED                   *\n*    R12       N/A                        UNCHANGED                   *\n*    R13       ADDRESS OF THE PCE         UNCHANGED                   *\n*    R14       RETURN ADDRESS             UNCHANGED                   *\n*    R15       ENTRY ADDRESS              RETURN CODE                 *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT)                                          *\n*                                                                     *\n*       0  TELLS JES2 THAT IF THERE ARE ANY ADDITIONAL EXIT ROUTINES  *\n*          ASSOCIATED WITH THIS EXIT, CALL THE NEXT CONSECUTIVE       *\n*          EXIT ROUTINE.  IF THERE ARE NO OTHER EXIT ROUTINES ASSO-   *\n*          CIATED WITH THIS EXIT, CONTINUE WITH NORMAL PROCESSING.    *\n*                                                                     *\n*       4  TELLS JES2 THAT EVEN IF THERE ARE ADDITIONAL EXIT ROUTINES *\n*          ASSOCIATED WITH THIS EXIT, IGNORE THEM.  CONTINUE WITH     *\n*          NORMAL PROCESSING.                                         *\n*                                                                     *\n*       8  FOR JES2 CONTROL STATEMENTS, TELLS JES2 NOT TO PERFORM     *\n*          STANDARD HASPRCCS PROCESSING; INSTEAD, IMMEDIATELY         *\n*          CONVERT THE STATEMENT TO A COMMENT (//*) WITH THE NULL-    *\n*          ON-INPUT FLAG SET TO ONE AND WRITE THE STATEMENT TO THE    *\n*          JCL DATA SET.  FOR JCL STATEMENTS, TELLS JES2 TO PERFORM   *\n*          STANDARD HASPRDR PROCESSING.                               *\n*                                                                     *\n*      12  TELLS JES2 TO CANCEL THE JOB BECAUSE AN ILLEGAL CONTROL    *\n*          STATEMENT HAS BEEN DETECTED; OUTPUT IS PRODUCED.           *\n*                                                                     *\n*      16  TELLS JES2 TO PURGE THE JOB; NO OUTPUT IS PRODUCED.        *\n*                                                                     *\n***********************************************************************\n*\n         TITLE 'JES2 USER EXIT 4 -- PROLOG ($HASPGBL)'\n         COPY  $HASPGBL\n         TITLE 'JES2 USER EXIT 4 -- PROLOG ($MODULE)'\nXYZJ2X04 $MODULE ENVIRON=JES2,                                         @\n               RMODE=ANY,                                              @\n               IBMJES2=SAMPLE,                                         @\n               TITLE='JES2 EXIT 4 - JCL/JECL scan',                    @\n               $BUFFER,            GENERATE HASP I/O BUFFER DSECT      C\n               $CADDR,             GENERATE HASP CADDR DSECT           C\n               $CAT,               GENERATE HASP CAT DSECT             C\n               $CMB,               GENERATE HASP CMB DSECT             C\n               $DCT,               GENERATE HASP DCT DSECT             C\n               $DTE,               GENERATE HASP DTE DSECT             C\n               $ERA,               GENERATE HASP ERA DSECT             C\n               $HASPEQU,           GENERATE HASP EQUATES DSECT         C\n               $HCT,               GENERATE HASP HCT DSECT             C\n               $JCT,               GENERATE HASP JCT DSECT             C\n               $JQE,               GENERATE HASP JQE DSECT             C\n               $KIT,               GENERATE HASP KIT DSECT             C\n               $MIT,               GENERATE HASP MIT DSECT             C\n               $PADDR,             GENERATE HASP PADDR DSECT           C\n               $PARMLST,           GENERATE HASP PARMLST DSECT         C\n               $PCE,               GENERATE HASP PCE DSECT             C\n               $PIT,               GENERATE HASP PIT DSECT             C\n               $PSV,               GENERATE HASP PSV DSECT             C\n               $RDRWORK,           GENERATE HASP RDRWORK DSECT         C\n               $TQE,               GENERATE HASP TQE DSECT             C\n               $USERCBS,           GENERATE HASP USERCBS DSECT         C\n               $XECB,              GENERATE HASP XECB DSECT            C\n               $XIT                GENERATE HASP XIT DSECT\n         TITLE 'JES2 USER EXIT 4 -- JCL/JECL SCAN'\n***********************************************************************\n*                                                                     *\n*        EXIT4 - INSTALLATION EXIT 4 ROUTINE                          *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE (INTERNAL)                                           *\n*                                                                     *\n*    REG       VALUE                                                  *\n*                                                                     *\n*    R0        PARAMETER FROM JES2                                    *\n*    R1-R9     WORK REGISTERS                                         *\n*    R10       JCT ADDRESSABILITY                                     *\n*    R11       HCT ADDRESSABILITY                                     *\n*    R12       EXIT4 ADDRESSABILITY                                   *\n*    R13       PCE ADDRESSABILITY                                     *\n*    R14       LINK/WORK REGISTER                                     *\n*    R15       LINK/WORK REGISTER                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nEXIT04  $ENTRY  BASE=R12           Provice exit routine entry point\n        $SAVE                      Save caller's registers\n         USING JCT,R10             Establish JCT addressability\n         LR    R12,R15             Establish base register for exit\n*\n         LTR   R10,R10             Check for JCT\n         BZ    X4RC00              None, leave right now\n         LR    R6,R0               Save R0 on entry\n         LR    R7,R1               Save R1 on entry\n*\n** Are we being invoked for a JECL with MSGCLASS=X?\n*\n         CLI   JCTMCLAS,C'X'       MSGCLASS=X?\n         BNE   X4RC00              No, leave\n*\n         LTR   R6,R6               JECL?\n         BNZ   X4RC00              No, leave\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Look for /*ROUTE PRINT nodename                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nROUTE_NODE EQU *\n         L     R5,0(R7)            Locate JECL image\n*\n** Debugging information for debugging job\n*\nRN$DEBUG EQU   *\n         CLC   JCTJNAME(8),=CL8'ibmuserZ'  Debugging jobname?\n         BNE   RN$DEBUGX                   No, continue\n        $WTO   JMSG1,L'JMSG1,JOB=YES,ROUTE=$LOG+$TP+$MAIN,             C\n               CLASS=$ALWAYS,PRI=$ST\nRN$DEBUGX EQU  *\n*\n** /*ROUTE processing\n*\n         CLC   0(8,R5),=C'/*ROUTE '       Route?\n         BNE   RN$ROUTEX                  No, continue\n         LA    R1,8(R5)                   bump past \"/*ROUTE\"\n         LA    R0,71-5-1\nRN$PRTL  EQU   *\n         CLC   0(6,R1),=C'PRINT '         Found the print operand\n         BE    RN$PRTLX                   Yes, continue\n         LA    R1,1(R1)                   No, bump to next byte\n         BCT   R0,RN$PRTL\n         B     RN$ROUTEX                  Give up\nRN$PRTLX EQU   *\n         LA    R1,6(R1)                   Bump past \"PRINT \"\n         SH    R0,=H'6'                   Take 6 off the total scan\nRN$NSPL  EQU   *\n         CLI   0(R1),C' '                 Space?\n         BNE   RN$NSPLX                   No, found destination\n         LA    R1,1(R1)                   Yes, search for destination\n         BCT   R0,RN$NSPL                      and try it out\n         B     RN$ROUTEX                  Opps, no Destination found\nRN$NSPLX EQU   *\n         LA    R14,T_NODES                Locate node table\n         LA    R15,T_NODESN               Get number in table\nRN$NODEL EQU   *\n         CLC   0(8,R1),0(R14)             Routing to PSO in MSGCLASS=X?\n         BE    RN$SUPIT                   Nope, continue\n         LA    R1,8(R1)                   Bump to next node in table\n         CLI   0(R1),X'FF'                End of table?\n         BE    RN$ROUTEX                  Yes, continue\n         BCT   R15,RN$NODEL               Continue with node search\n         B     RN$ROUTEX                  Leave - destination not found\nRN$SUPIT EQU   *\n         MVI   JCTUSERB,C'X'              Set flag for XYZJ2X06\n         B     X4RC08                     and ignore this puppy\nRN$ROUTEX EQU  *\n*\n** Exit from Route_Node processing\n*\nRN$X     EQU   *\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    EXIT4 COMMON RETURN ROUTINE                                      *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nX4RC00   LA    R15,0               SET RC=0\n         B     RRET                BRANCH TO RETURN WITH RC SET\n         SPACE 1\nX4RC04   LA    R15,4               SET RC=4\n         B     RRET                BRANCH TO RETURN WITH RC SET\n         SPACE 1\nX4RC08   LA    R15,8               SET RC=8\n         B     RRET                BRANCH TO RETURN WITH RC SET\n         SPACE 1\nX4RC12   LA    R15,12              SET RC=12\n         SPACE 1\nRRET    $RETURN RC=(R15)           SAVE RETURN CODE\n         EJECT\n***********************************************************************\n*                                                                     *\n*       EXIT2 Constants                                               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n*\n** Exit messages\n*\nT_NODES  EQU   *\n         DC    CL8'TULSA1'\n         DC    8X'FF'             Entry to zap\n         DC    8X'FF'             Entry to zap\n         DC    8X'FF'             Entry to zap\nT_NODESN EQU   (*-T_NODES)/8\n         DC    X'FF',C'END'\n*\n** Exit messages\n*\nJMSG1   $MSG   999,' XYZJ2X04 Processing JECL card - Last assembled on @\n               &SYSDATE at &SYSTIME'\n         ORG   ,\n*\n** Literals and module end\n*\n         LTORG ,\n        $MODEND\nAPARNUM  DC    CL8'NONE'           APAR NUMBER\n         END   ,                   END OF XYZJ2X04\n./ ADD NAME=XYZJ2X06 0100-98016-98016-1800-01797-01797-00000-DALCOCK\nXYZJ2X06 TITLE 'XYZ - JES2 Exit 6'\n***********************************************************************\n***                                                                 ***\n** Module name = XYZJ2X06                                            **\n**                                                                   **\n** Author = David Alcock                                             **\n**                                                                   **\n** Descriptive Name = HASP Exit 6 Converter/Interpreter (C/I) text   **\n**                    module                                         **\n**                                                                   **\n** Function = This JES2 exit scans C/I text as generated by the MVS  **\n**            Converter subtask and performs XYZ JCL standards       **\n**            verification.                                          **\n**                                                                   **\n**            The XYZ manual, Information Services Reference Manual, **\n**            is the \"bible\" for installation JCL standards.         **\n**                                                                   **\n** Non-standard macros:                                              **\n** - XYZJ2X06....Mapping macro for DSECTs that we make available in  **\n**               CSECT/module XYZJ2#06.                              **\n** - STR.........Build a Pascal-like string with a length byte       **\n**               followed by a text value.                           **\n**                                                                   **\n** Reference manuals:                                                **\n** - LY28-1029 JES2 Customization                                    **\n** - GC28-1637 Installation Exits (Section 4: MVS C/I Text Format)   **\n**                                                                   **\n** Undocumented Interfaces:                                          **\n** - This exit uses the field names from mapping DSECT $DTECNV:      **\n**   DCNVPARM, DCNVUWAA, DCNVP2A, DCNVDTEA, DCNJCTA and DCNVCNMB     **\n**   to map the 5-word parameter list passed to us in register 1.    **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n* INPUT   R0  = A CODE INDICATING THE STATUS OF CONVERSION PROCESSING *\n*               0  INDICATES THAT A JCL STATEMENT HAS BEEN CONVERTED  *\n*                  TO AN C/I TEXT IMAGE                               *\n*               4  INDICATES THAT ALL OF THE JCL FOR A PARTICULAR     *\n*                  JOB HAS BEEN CONVERTED TO C/I TEXT.                *\n*                                                                     *\n*         R1  = ADDRESS OF A 4-WORD PARAMETER LIST WITH THE           *\n*               FOLLOWING STRUCTURE:                                  *\n*               WORD 1 (+0) = ADDR OF 16-BYTE WORK AREA               *\n*                             Word 1 (+0) Address of 16 byte wrk area *\n*                             Word 2 (+4) Passed field                *\n*                             Word 3 (+8) Address of the $DTE         *\n*                             Word 4 (+12) Address of the $JCT        *\n*                             Word 5 (+16) Zero pointer (CNMB)        *\n*               WORD 2 (+4) = If the code passed in R0 is:            *\n*                             0 - This word points to the address of  *\n*                                 a 8192 byte buffer that contains the*\n*                                 C/I text of the converted JCL       *\n*                                 statement                           *\n*                             4 - This word contains the address of   *\n*                                 converter's return code             *\n*               WORD 3 (+8) = ADDRESS OF THE DTE                      *\n*               WORD 4 (+12) = ADDRESS OF THE JCT                     *\n*               WORD 4 (+16) = N/A on entry; used to store the        *\n*                              IEFCNMB if gotten in exit              *\n*         R2-R10 = N/A                                                *\n*         R11 = ADDRESS OF HCT                                        *\n*         R12 = N/A                                                   *\n*         R13 = ADDRESS OF AN 18-WORD OS-STYLE SAVE AREA              *\n*         R14 = RETURN ADDRESS                                        *\n*         R15 = ADDRESS OF ENTRY POINT                                *\n*                                                                     *\n* OUTPUT  R15 = RETURN CODE                                           *\n*         (ALL OTHERS UNCHANGED)                                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   03-NOV-1996 Added check for SYSMDUMP;                  **\n** DGAlcock   09-MAY-1996 Changed GETMAIN in SAVE_MESSAGE routine to **\n**                        use the MVS GETMAIN macro instead of the   **\n**                        JES2 $GETMAIN macro - refer to OY56218;    **\n** DGAlcock   07-NOV-1995 Added classes 0, 7, 8 to TABLE_JC;         **\n** DGAlcock   17-OCT-1994 Add description string to TABLE_JC;        **\n** DGAlcock   16-SEP-1994 Allow SCIS* jobs to use numeric job class; **\n**                        Move tables to CSECT that will have an     **\n**                        external reference (via ALIAS) which will  **\n**                        allow us to see actual processing rules;   **\n** DGAlcock   04-JAN-1994 Check for DISP=MOD and DCB override;       **\n**                        Correct Time logic for class; Add check    **\n**                        for label=(,NL/BLP) and DCB override;      **\n** DGAlcock   30-NOV-1993 Added \"xCISxxxx\" as valid userid jobname;  **\n** DGAlcock   11-NOV-1993 Moved JCL standards validation from SMF    **\n**                        exit IEFUJV to XYZJ2X06:                   **\n**                        - Jobname validation                       **\n**                          - Valid company id           D           **\n**                          - Valid Application code     SYS         **\n**                          - Valid series               000         **\n**                          - Valid Frequency            A           **\n**                        - Account code validation                  **\n**                          - Valid company              D,D,D       **\n**                          - Valid application code     SYS         **\n** DGAlcock   29-SEP-1993 Add //STEPCAT & JOBCAT Detection; Added    **\n**                        detection of using DCB info after create;  **\n**                        Detect use of DSN=AS./ in production job;  **\n**                        Change selection of \"production\" jobname;  **\n** DGAlcock   09-JUN-1993 Add full CPU time enforcement (JOB Card);  **\n** DGAlcock   04-AUG-1992 Added check for JCTUSERB set in XYZJ2X04   **\n**                        to print about /*ROUTE PRINT nodename for  **\n**                        MSGCLASS=X jobs;                           **\n** DGAlcock   28-JUL-1992 Created new source based on earlier XYZ    **\n**                        functions and IBM sample SP4.2 exit; This  **\n**                        Exit is at the JES2 4.2 level;             **\n***                                                                 ***\n***********************************************************************\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Internal DSECTs                                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Life of Convert Area\n*\nLCA      DSECT ,\nLCAEYEC  DS    CL8                        Eyecatcher for dumps\nLCAJNAME DS    CL8                        Jobname for dumps\nLCAJOBID DS    CL8                        JOBID for dumps\n         DS    0D\nDOUBLE   DS    D                          Double word work area\nLCAPARM  DS    XL(C_LOCATEL)              Locate Parameter list\nWORKDSNL DS    F                          Length of DSNAME\nWORKDSN  DS    CL56                       Build DSNAME here\n         ORG   WORKDSN                    Reuse WORKDSN area\nPJC_TM   DS    C'000000'                  CPU minutes on job card\nPJC_TS   DS    C'00'                      CPU seconds on job card\n         DS    0F\nPJC_ACCT DS    4F                         Account field pointers\nPJC_TBL  DS    F                          Address of APPLTBL\n         ORG   ,\n         DS    0D\nW_CAMLST DS    XL265                      CAMLST Locate area\n         ORG   W_CAMLST                   Reuse W_CAMLST area\nWORKMSG  DS    XL(CNMBMAXL)               Work CNMB message area\n         ORG   ,\n*\nLCAI     DS    0F                         Start of area to initialize\nLCA_CLS  DS    C                          Job class\nLCA_CLSR DS    XL(J2X06JCL)               TABLE_JC entry for Class\nMAXCC    DS    X                          Maximum Condition Code\nFLAG1    DS    B'00000000'                Flag 1\n$F1_FLCA EQU   B'10000000'                ..Free LCA\n$F1_DBUG EQU   B'01000000'                ..Debugging job?\n$F1_ASMP EQU   B'00100000'                ..Automated Storage problem?\n$F1_PROD EQU   B'00010000'                ..Production jobname?\n$F1_STND EQU   B'00001000'                ..Violates standards?\nLCAIL    EQU   (*-LCAI)                   Length of area to initialize\n         DS    0F                         Stuff set for each invocation\nA_PARM   DS    A                          Address of parm list on entry\nA_CNMB   DS    A                          Last CNMB\nLASTCC   DS    X                          Last Condition Code\nFLAGI1   DS    B'00000000'                Invocation flag 1\n$FLAGI1_G EQU  B'10000000'                ..GDG?\n$FLAGI1_T EQU  B'01000000'                ..Found TIME= on jobcard?\n$FLAGI1_D EQU  B'00100000'                ..DCB info with DISP <> NEW\n$FLAGI1_C EQU  B'00010000'                ..Invalid company on jobname\n$FLAGI1_J EQU  B'00001000'                ..No jobname on jobcard\n         DS    0D                         Alignment for FREEMAIN\nLCAL     EQU   *-LCA                      Length of area\n*\n** User Work Area (Pointed to by first word (DCNVUWAA) in the 5-word\n** parameter list passed to this exit).\n*\nUWA      DSECT ,\nUWALCA   DS    F                          Pointer to LCA work area\n         DS    3F                         Not used yet\nUWAL     EQU   *-UWA                      Must be 16-dec or 10-hex\n*\n** CAMLST Locate Area maping\n*\nCLA      DSECT ,\nCLA_NUM  DS    XL2                        Number of units\nCLA_ENT  DS    0H                         Entry\nCLA_UNIT DS    0XL4                       ..Unit type\nCLA_UT1  DS    X                            ..Type byte 1\nCLA_UT2  DS    X                            ..Type byte 2\nCLA_UT3  DS    X                            ..Type byte 3\nCLA_UT4  DS    X                            ..Type byte 4\nCLA_VOL  DS    CL6                        ..Volume serial\nCLA_SEQ  DS    XL2                        ..Sequence number\nCLA_ENTL EQU   *-CLA_ENT                  Entry length='12'd or '0C'x\n*\n         PRINT GEN\n         XYZJ2#06 ,                    Get external mapping\n*\n** Global stuff\n*\n         GBLC  &DBGJNME                Generate global variable\n&DBGJNME SETC  'ibmuserZ'              ..Jobname for debugging info\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Ask JES2 for some mapping DSECTs and equates                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         COPY  $HASPGBL            Copy HASP globals\nXYZJ2X06 $MODULE ENVIRON=SUBTASK,                                      @\n               RMODE=ANY,                                              @\n               IBMJES2=SAMPLE,                                         @\n               TITLE='JES2 EXIT 6 - JCL standards enforcement',        @\n               CNMB,               IEFCNMB - Converter message buffer  C\n               DEB,                Generate MVS IEZDEB                 C\n               (KEYS,GEN),         Generate MVS IEFVKEYS and list them C\n               RPL,                GENERATE MVS IFGRPL                 C\n               SAFP,               ICHSAFP - SAF PARAMETER LIST        C\n               (TEXT,GEN),         GENERATE MVS IEFTXTFT AND LIST THEM C\n               TOKEN,              ICHRUTKN - SAF TOKEN MAPPING        C\n               WPL,                GENERATE MVS IEXWPL                 C\n               $BUFFER,            BUFFER DSECT                        C\n               $CADDR,             COMMON STORAGE ADDRESS LIST         C\n               $CMB,               CONSOLE MESSAGE BUFFER              C\n               $DTE,               DAUGHTER TASK ELEMENT               C\n               $DTECNV,            DTE EXTENSION FOR CONVERSION        C\n               $ERA,               ERROR RECOVERY AREA                 C\n               $HASPEQU,           GENERAL EQUATES                     C\n               $HCCT,              COMMON STORAGE CONTROL TABLE        C\n               $HCT,               PRIVATE STORAGE CONTROL TABLE       C\n               $HFAME,             FILE ALLOCATION MAP ELEMENT         C\n               $JCT,               JOB CONTROL TABLE                   C\n               $JQE,               JOB QUEUE ELEMENT                   C\n               $MIT,               MODULE INFORMATION TABLE            C\n               $MITETBL,           $MIT TABLE ENTRY                    C\n               $PADDR,             PRIVATE STORAGE ADDRESS LIST        C\n               $PARMLST,           PARAMETER LIST MAPPING              C\n               $PCE,               PROCESSOR CONTROL ELEMENT           C\n               $PDDB,              DATA SET DEFINITION BLOCK           C\n               $PSV,               PROCESSOR SAVE AREA                 C\n               $SCAT,              SYSOUT CLASS ATTRIBUTE TABLE        C\n               $TQE,               TIMER QUEUE ELEMENT                 C\n               $USERCBS,           USER CONTROL BLOCKS                 C\n               $XECB,              EXTENDED ECB                        C\n               $XIT                EXIT INFORMATION TABLE\n         TITLE 'XYZ - JES2 Exit 6'\n***********************************************************************\n***                                                                 ***\n**       Entry Housekeeping                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT GEN\nEXIT06  $ENTRY BASE=(R12,R10)             Entry point to module\n        $SAVE  NAME=EXIT06                Save registers\n         LR    R12,R15                    Load base register\n         LA    R10,4095                   Get 4096-1\n         LA    R10,1(R10,R12)             Addressability: 2nd base reg\n*\n** Are we to process this job type?\n*\n         SLR   R15,R15                    Clear return code\n         L     R14,DCNVJCTA-DCNVPARM(R1)  Locate JCT for this job\n         TM    JCTJOBFL-JCT(R14),JCTSTCJB Started Task?\n         BO    X$RETURN                   Yes, leave\n         TM    JCTJOBFL-JCT(R14),JCTTSUJB TSO user?\n         BO    X$RETURN                   Yes, leave\n*\n** Obtain life-of-convert Work Area (if first time)\n*\n         L     R4,DCNVUWAA-DCNVPARM(R1)   Locate 16-byte Work area\n         ICM   R5,B'1111',UWALCA-UWA(R4)  Already have LCA storage?\n         BNZ   I$LCAX                     Yes, continue\n*\n         LR    R2,R0                      Save R0 (type) upon entry\n         LR    R3,R1                      Save R1 (parm) upon entry\n       GETMAIN R,                         Obtain storage for LCA       @\n               LV=LCAL,                   ..Length                     @\n               SP=251                     ..Subpool (\u00acfreed on abend)\n         LR    R5,R1                      Get address of LCA\n         USING LCA,R5                     Get addressibility to it\n         ST    R5,UWALCA-UWA(R4)          Save LCA address...\n*\n         LA    R15,LCAI                   Locate to initialization area\n         XC    0(LCAIL,R15),0(R15)        Initialize area to zero\n         MVC   LCAEYEC(8),=CL8'XYZJ2X06'  Diagnostic info for dumps\n         L     R15,DCNVJCTA-DCNVPARM(R3)  Locate JCT from parmlist\n         MVC   LCAJNAME(8),JCTJNAME-JCT(R15) Diagnostic info for dumps\n         MVC   LCAJOBID(8),JCTJOBID-JCT(R15) Diagnostic info for dumps\n*\n         CLC   LCAJNAME(8),=CL8'&DBGJNME' Debugging job?\n         BNE   I$LCADX                    No, continue\n         OI    FLAG1,$F1_DBUG             Turn on flag\n         WTO   ,MF=(E,MSG475)             Issue message\nI$LCADX  DS    0H\n*\n         L     R1,=V(XYZJ2#06)            Locate CSECT\n         CLC   LCAJNAME(4),NPTE1-XYZJ2#06(R1)    CIS-type jobname?\n         BE    I$PRODJX                          Yes, not production?\n         CLC   LCAJNAME+1(3),NPTE2-XYZJ2#06(R1)  Contractor jobname?\n         BE    I$PRODJX                          Yes, not production?\n         CLC   LCAJNAME+1(3),NPTE3-XYZJ2#06(R1)  TSO user?\n         BE    I$PRODJX                          Yes, not production\n         CLC   LCAJNAME+1(4),NPTE4-XYZJ2#06(R1)  Firecall?\n         BE    I$PRODJX                          Yes, not production\n         CLI   LCAJNAME+1,C'Z'            Has a numeric not alpha?\n         BH    I$PRODJX                   Yes, an employee number type\nI$PRODJ  DS    0H\n         OI    FLAG1,$F1_PROD             This is a production jobname\nI$PRODJX DS    0H\n*\n         LR    R0,R2                      Restore Exit type\n         LR    R1,R3                      Restore Exit parameter list\nI$LCAX   DS    0H\n*\n         ST    R1,A_PARM                  Save address of exit parm\n         MVI   LASTCC,0                   Initialize lastcc\n         MVI   FLAGI1,0                   Initialize invocation flag 1\n         XC    A_CNMB(4),A_CNMB           New list needed for messages\n         EJECT\n***********************************************************************\n***                                                                 ***\n**    Test for type of invocation and branch to routine              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LTR   R0,R0                      What type of call?\n         BNZ   END_OF_CONVERT             End of the JCL convert\n*\n         L     R2,4(R1)                   Locate TEXT location\n         USING TEXT,R2                    Get addressibility to it\n*\n** Invoke routine based on JCL type\n*\n         TM    STRINDCS,JOBSTR            JOB?\n         BO    PROCESS_JOB_CARD\n         TM    STRINDCS,DDSTR             DD?\n         BO    PROCESS_DD_STATEMENT\n*        TM    STRINDCS,EXECSTR           EXEC?\n*        BO    PROCESS_EXEC_STATEMENT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Exit housekeeping - restore registers, free work area       **\n**       and return to the MVS converter                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Return to C/I\n*\nEXIT     DS    0H\n         SLR   R15,R15                    Clear return code to zero\n         IC    R15,LASTCC                 Get condition code for exit\n*\n         CLC   LASTCC(1),MAXCC            Need to update max cc?\n         BNH   X$CCX                      No, continue\n         MVC   MAXCC(1),LASTCC            Save max cc\nX$CCX    DS    0H\n*\n** Free the LCA if last call\n*\n         TM    FLAG1,$F1_FLCA             Free LCA?\n         BNO   X$FMX                      No, leave\n      FREEMAIN R,                         Free LCA storage             @\n               LV=LCAL,                   ..Length                     @\n               A=(5),                     ..Address                    @\n               SP=251                     ..Subpool\n         SLR   R15,R15                    Get return code\nX$FMX    DS    0H\n*\n** Return to caller\n*\nX$RETURN DS    0H\n        $RETURN RC=(15)                   Return\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       The job has completed conversion                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEND_OF_CONVERT DS 0H\n         OI    FLAG1,$F1_FLCA             Free the LCA!\n*\n** Print WTO message if XYZJ2X04 JES2 exit found a special /*ROUTE card\n*\n         L     R1,A_PARM                  Locate parameter list\n         L     R14,DCNVJCTA-DCNVPARM(R1)  Locate JCT for this job\n         CLI   JCTUSERB-JCT(R14),C'X'     XYZJ2X04 found node /*ROUTE?\n         BNE   EOC$EZPX                   No, continue\n         MVC   WORKMSG(MSG499L),MSG499       Initialize message area\n         MVC   WORKMSG+MSG499A(8),LCAJNAME   Get jobname (for SYSLOG)\n         WTO   ,MF=(E,WORKMSG)            Issue message\nEOC$EZPX DS    0H\n*\n** Print WTO message if we found some ASM violations, but okay\n*\n         TM    FLAG1,$F1_ASMP             Found problems?\n         BNO   EOC$ASMPX                  No, continue\n         MVC   WORKMSG(MSG498L),MSG498       Initialize message area\n         MVC   WORKMSG+MSG498A(8),LCAJNAME   Get jobname (for SYSLOG)\n         WTO   ,MF=(E,WORKMSG)            Issue message\n         WTO   ,MF=(E,MSG497)             Issue message\nEOC$ASMPX EQU  *\n*\n** Print WTO message if we found some standards Violations, but okay\n*\n         TM    FLAG1,$F1_STND             Found problems?\n         BNO   EOC$STNDX                  No, continue\n         MVC   WORKMSG(MSG496L),MSG496       Initialize message area\n         MVC   WORKMSG+MSG496A(8),LCAJNAME   Get jobname (for SYSLOG)\n         WTO   ,MF=(E,WORKMSG)            Issue message\n         WTO   ,MF=(E,MSG497)             Issue message\nEOC$STNDX EQU  *\n*\n** Issue message if there was a problem, else leave quietly\n*\n         CLI   MAXCC,0                    Did we have any problems\n         BE    EXIT                       No, just leave\n         WTO   ,MF=(E,MSG460)             Issue WTO message\n         B     EXIT                       Leave\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process the Job card                                        **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPROCESS_JOB_CARD EQU *\n         XC    PJC_TBL(4),PJC_TBL         Clear table address\n*\n** Load Job account table into memory\n*\n         LA    R6,=CL8'APPLTBL'           Get Application Table name\n         LOAD  EPLOC=(6),ERRET=PJC$LATE   Load table into storage\n         ST    R0,PJC_TBL                 Save address of table\n         B     PJC$LATX\nPJC$LATE DS    0H\n         LA    R0,MSG478L                 Get message length\n         LA    R1,MSG478                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$LATX DS    0H\n*\n** Process the positional items on the jobcard:\n** //jobname JOB account,programer-name\n**\n** //A JOB (D,D,D,SYS),'?'\n** Translates to: B4 03 01 C1 84 01 C4 01 C4 01 C4 03 E2E8E2 14 6F40...\n**\n**                B4 = JOBK\n**                03 = Number of parameters: JOBNAME, ACCOUNT, PROGN\n**                01 = Length of jobname\n**                C1 = jobname\n**                84 = First nibble is account Second is # of accts\n**                01 = Length of account field 1\n**                C4 = Value of account field 1\n**                01 = Length of account field 2\n**                C4 = Value of account field 2\n**                01 = Length of account field 3\n**                C4 = Value of account field 3\n**                03 = Length of account field 4\n**                E2E8E2 = Value of account field 4\n**                14 = Length of programmer name\n**                6F = Value of Programmer name\n**\n** //A JOB ,'??'\n** Translates to: B4 03 01 C1 00 14 CF4040404040404040...\n**\n**                B4 = JOBK\n**                03 = Number of parameters: JOBNAME, ACCOUNT, PROGN\n**                07 = Length of jobname\n**                C1 = jobname\n**                00 = No Account fields!\n**                14 = Length of programmer name\n**                6F = Value of Programmer name\n*\nPJC$ACCT  EQU *\n         LA    R0,JOBK                    Setup to find JOB string\n         LA    R1,STRJKEY                 First key sequence\n        $CALL  XINTKEY,ERRET=PJC$ACCTX    Find keyword\n         LR    R7,R1                      Save start of original unit\n*\n         CLI   1(R7),X'03'                Looks like something we know?\n         BNE   PJC$A$IJS                  No, internal error\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0001',2(R7)           Get length of jobname\n         BZ    PJC$A$NJN                  None, no jobname...\n         LA    R7,3(R1,R7)                Bump past jobname\n         CLI   0(R7),X'00'                Any account fields\n         BE    PJC$A$NAF                  No account fields found\n         CLI   0(R7),X'84'                Right number of fields?\n         BNE   PJC$A$WNF                  No account fields found\n         LA    R7,1(R7)                   Bump past field number byte\n*\n         XC    PJC_ACCT(16),PJC_ACCT      Clear area\n*\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R7)                  Get length of 1st field\n         LA    R7,1(R7)                   Bump to 1st field\n         ST    R7,PJC_ACCT+0              Save address of 1st field\n         AR    R7,R14                     Locate to next one\n*\n         IC    R14,0(R7)                  Get length of 2nd field\n         LA    R7,1(R7)                   Bump to 2nd field\n         ST    R7,PJC_ACCT+4              Save address of 2nd field\n         AR    R7,R14                     Locate to next one\n*\n         IC    R14,0(R7)                  Get length of 3rd field\n         LA    R7,1(R7)                   Bump to 3rd field value\n         ST    R7,PJC_ACCT+8              Save address of 3rd field\n         AR    R7,R14                     Locate to next one\n*\n         CLI   0(R7),X'03'                Application code length 3?\n         BE    PJC$AALX                   Yes, continue\n         BL    PJC$AALL                   No, less...\n         LA    R0,MSG483L                 Get message length\n         LA    R1,MSG483                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         B     PJC$AALX\nPJC$AALL DS    0H\n         MVI   LASTCC,8                   Cancel this job...\n         LA    R0,MSG488L                 Get message length\n         LA    R1,MSG488                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$AALX DS    0H\n*\n         LA    R7,1(R7)                   Bump to 4th field value\n         ST    R7,PJC_ACCT+12             Save address of 4th field\n*\n         LA    R3,PJC_ACCT                Locate account field pointers\n         LA    R4,3                       Number of company codes\n         LA    R6,=C'123'                 Locate Account field number\nPJC$A$FL DS    0H\n         L     R15,0(R3)                  Get address of company code\n         BAS   R9,PJC$CHECK_CC            Verify company code\n         LTR   R15,R15                    Valid?\n         BNZ   PJC$A$FLB                  Yes, continue\n         MVI   LASTCC,8                   Cancel this job...\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG476L,R1),MSG476       Move in message\n         L     R15,0(R3)                  Get address of company code\n         MVC   MSG476CC-MSG476(1,R1),0(R15) Get company code\n         MVC   MSG476FN-MSG476(1,R1),0(R6)  Get field number\n         LA    R0,MSG476L                 Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$A$FLB EQU  *\n         LA    R3,4(R3)                   Locate to next pointer\n         LA    R6,1(R6)                   Bump to next field value\n         BCT   R4,PJC$A$FL                Process next company code\n         TM    FLAGI1,$FLAGI1_C           Invalid company code?\n         BO    PJC$ACCTX                  Forget about app code...\n         L     R15,0(R3)                  Locate Application code\n         BAS   R9,PJC$CHECK_APCODE        Check Application code\n         LTR   R15,R15                    Okay?\n         BNZ   PJC$ACCTX                  Yes, continue\n         L     R15,0(R3)                  Locate Application code\n         MVI   LASTCC,8                   Cancel this job...\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG477L,R1),MSG477       Move in message\n         MVC   MSG477AP-MSG477(3,R1),0(R15) Get application code\n         MVC   MSG477CC-MSG477(1,R1),LCAJNAME Get company code\n         LA    R0,MSG477L                 Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\n         B     PJC$ACCTX                  Continue\nPJC$A$NAF EQU  *\n         LA    R0,MSG479L                 Get message length\n         LA    R1,MSG479                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         MVI   LASTCC,8                   Fail job because of it\n         B     PJC$ACCTX\nPJC$A$WNF EQU  *\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG480L,R1),MSG480       Move in message\n         MVC   MSG480F1-MSG480(1,R1),LCAJNAME Get company code\n         MVC   MSG480F2-MSG480(1,R1),LCAJNAME Get company code\n         MVC   MSG480F3-MSG480(1,R1),LCAJNAME Get company code\n         LA    R0,MSG480L                 Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\n         MVI   LASTCC,8                   Fail job because of it\n         B     PJC$ACCTX\nPJC$A$NJN EQU  *\n         OI    FLAGI1,$FLAGI1_J           No jobname\n         LA    R0,MSG481L                 Get message length\n         LA    R1,MSG481                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         MVI   LASTCC,8                   Fail job because of it\n         B     PJC$ACCTX\nPJC$A$IJS EQU *\n         LA    R0,MSG482L                 Get message length\n         LA    R1,MSG482                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         B     PJC$ACCTX\n*\nPJC$ACCTX EQU *\n*\n** Validate the jobname\n*\n**\n*B PJC$JNZX          TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*DC CL8'JOBNAME '    TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\nPJC$JNZX EQU *       TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*NOP PJC$JNX         TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n**\n         TM    FLAG1,$F1_PROD             Production jobname?\n         BNO   PJC$JNX                    No, continue\n         TM    FLAGI1,$FLAGI1_J           Have a jobname?\n         BO    PJC$JNX                    No, continue\n*\n         LA    R15,LCAJNAME               Locate company code in jname\n         BAS   R9,PJC$CHECK_CC            Verify company code\n         LTR   R15,R15                    Valid?\n         BNZ   PJC$JNCCX                  Yes, continue\n         OI    FLAGI1,$FLAGI1_C           Invalid company code...\n         MVI   LASTCC,8                   Cancel this job...\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG484L,R1),MSG484       Move in message\n         MVC   MSG484CC-MSG484(1,R1),LCAJNAME Get company code\n         LA    R0,MSG484L                 Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$JNCCX EQU  *\n*\n         TM    FLAGI1,$FLAGI1_C           Invalid company code?\n         BO    PJC$JNAPX                  Forget about app code...\n         LA    R15,LCAJNAME+1             Locate Application code\n         BAS   R9,PJC$CHECK_APCODE        Check Application code\n         LTR   R15,R15                    Okay?\n         BNZ   PJC$JNAPX                  Yes, continue\n*->      MVI   LASTCC,8                   Cancel this job...\n         OI    FLAG1,$F1_STND             Turn on flag\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG485L,R1),MSG485       Move in message\n         MVC   MSG485AP-MSG485(3,R1),LCAJNAME+1 Get application code\n         MVC   MSG485CC-MSG485(1,R1),LCAJNAME Get company code\n         LA    R0,MSG485L                 Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$JNAPX EQU  *\n*\n* Note: I *ASSUME* that the user can't submit a job with a character\n*       that is above X'F9' with the following logic...\n         CLI   LCAJNAME+4,C'0'            Valid number?\n         BL    PJC$JNNE                   No, continue\n         CLI   LCAJNAME+5,C'0'            Valid number?\n         BL    PJC$JNNE                   No, continue\n         CLI   LCAJNAME+6,C'0'            Valid number?\n         BNL   PJC$JNNX                   No, continue\nPJC$JNNE DS    0H\n*->      MVI   LASTCC,8                   Cancel this job...\n         OI    FLAG1,$F1_STND             Turn on flag\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG486L,R1),MSG486       Move in message\n         MVC   MSG486AN-MSG486(3,R1),LCAJNAME+4 Get app number\n         LA    R0,MSG486L                 Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$JNNX DS    0H\n*\n         LA    R0,TABLE#FQ                Number in table\n         L     R1,=V(XYZJ2#06)            Locate CSECT\n         LA    R1,TABLE_FQ-XYZJ2#06(R1)   Locate table in CSECT\nPJC$JNFL DS    0H\n         CLC   LCAJNAME+7(1),J2X06FQ_VALUE-J2X06FQ(R1)\n         BE    PJC$JNX                    Yes, continue\n         LA    R1,J2X06FQL(R1)            Bump to next entry\n         BCT   R0,PJC$JNFL                And process it\n         OI    FLAG1,$F1_STND             Turn on flag\n*->      MVI   LASTCC,8                   Cancel this job...\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG487L,R1),MSG487       Move in message\n         MVC   MSG487F-MSG487(1,R1),LCAJNAME+7 Get frequency\n         L     R14,=V(XYZJ2#06)           Locate CSECT\n         LA    R14,TABLE_FQ-XYZJ2#06(R14) Locate to table\n         LA    R15,MSG487L+1(R1)          Locate to output area\n         LA    R0,TABLE#FQ                Get number to move\nPJC$JNML DS    0H\n         MVC   0(1,R15),J2X06FQ_VALUE-J2X06FQ(R14)  Get frequency\n         MVI   L'J2X06FQ_VALUE(R15),C','  Get delimiter\n         LA    R15,L'J2X06FQ_VALUE+1(R15) Bump to next output location\n         LA    R14,J2X06FQL(R14)          Bump to next input table ent.\n         BCT   R0,PJC$JNML                Process next table entry\n         BCTR  R15,0                      Backup one on output\n         MVI   0(R15),C' '                Rub out trailing comma\n         LA    R0,MSG487L+1+(TABLE#FQ*2)  Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$JNX  DS    0H\n*\n** Obtain JOB execution class\n*\nPJC$CLS  DS    0H\n         LA    R0,CLASSJK                 Setup to find \"CLASS=\"\n         LA    R1,STRJKEY                 First key sequence\n        $CALL  XINTKEY,ERRET=PJC$CLSE     Find keyword\n         SLR   R15,R15                    Clear register\n         ICM   R15,B'0001',2(R1)          Get length of job class\n         BZ    PJC$CLSE                   None, continue\n         MVC   LCA_CLS(1),3(R1)           Save job class for later\n         CLI   LCA_CLS,0                  Specified?\n         BE    PJC$CLSE                   No, continue\n*\n         L     R14,=V(XYZJ2#06)           Locate to table CSECT\n         LA    R14,TABLE_JC-XYZJ2#06(R14) Locate rules table\n         LA    R15,TABLE#JC               Set number in table\nPJC$CLSL DS    0H\n         CLC   J2X06JC_CLASS-J2X06JC(1,R14),LCA_CLS Class Match?\n         BE    PJC$CLSM                   Yes, continue\n         LA    R14,J2X06JCL(R14)          Bump to next table entry\n         BCT   R15,PJC$CLSL               Continue HIS ENTRY\n*\n         LA    R0,MSG464L                 Get message length\n         LA    R1,WORKMSG                 Get message address\n         MVC   0(MSG464L,R1),MSG464       Initialize message area\n         MVC   MSG464C-MSG464(1,R1),LCA_CLS Get offending job class\n         BAS   R9,SAVE_MESSAGE            Save message\n         MVI   LASTCC,8                   Set maximum condition code\n         XC    LCA_CLSR(J2X06JCL),LCA_CLSR Ensure entry is zeroed out\n         B     PJC$CLSX\n*\nPJC$CLSM DS    0H\n         MVC   LCA_CLSR(J2X06JCL),0(R14)  Save winning entry\n*\n         CLI   LCA_CLS,C'0'               Non-numeric?\n         BL    PJC$CLSN                   Yes, continue\n         CLC   LCAJNAME(4),=C'SCIS'       CIS-type jobname?\n         BE    PJC$CLSN                   Yes, continue\n         TM    FLAG1,$F1_PROD             Production jobname?\n         BO    PJC$CLSN                   Yes, continue\nPJC$CLSP DS    0H\n         LA    R0,MSG463L                 Get message length\n         LA    R1,MSG463                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         MVI   LASTCC,8                   Set maximum condition code\nPJC$CLSN DS    0H\n         TM    FLAG1,$F1_DBUG             Debugging information?\n         BNO   PJC$CLSX                   No, bump past message\n         LA    R1,WORKMSG                 Locate work message\n         MVC   0(MSG467L,R1),MSG467       Move in message prefix\n         LA    R15,LCA_CLSR               Locate class rules\n         MVC   MSG467C-MSG467(1,R1),J2X06JC_CLASS-J2X06JC(R15)\n         MVC   MSG467T-MSG467(1,R1),J2X06JC_TAPE-J2X06JC(R15)\n         MVC   MSG467TM-MSG467(6,R1),J2X06JC_TIMEM-J2X06JC(R15)\n         MVC   MSG467TS-MSG467(2,R1),J2X06JC_TIMES-J2X06JC(R15)\n         LA    R0,MSG467L                 Get length\n         BAS   R9,SAVE_MESSAGE            Move message out to CNMB\n         B     PJC$CLSX                   Continue\n*\nPJC$CLSE DS    0H\n         LA    R0,MSG462L                 Get message length\n         LA    R1,MSG462                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         MVI   LASTCC,8                   Set maximum condition code\n         XC    LCA_CLSR(J2X06JCL),LCA_CLSR Ensure entry is zeroed out\nPJC$CLSX DS    0H\n*\n** Locate TIME= (if on jobcard)\n**\n** TIME=(1,30)  translates to: A90201F102F3F0\n** TIME=(,30)   translates to: A9020002F3F0\n** TIME=1439    translates to: A90104F1F4F3F9\n** TIME=1440    translates to: A90104F1F4F3F9\n** TIME=NOLIMIT translates to: A90107D5D6D3C9D4C9E3\n** TIME=MAXIMUM translates to: A90107D4C1E7C9D4E4D4\n*\nPJC$TIME DS    0H\n         LA    R0,TIMEJK                  Setup to find \"TIME=\"\n         LA    R1,STRJKEY                 First key sequence\n        $CALL  XINTKEY,ERRET=PJC$TIMEX    Find keyword\n         LR    R7,R1                      Save start of original unit\n         OI    FLAGI1,$FLAGI1_T           We have a TIME= on job card\n*\n         CLI   1(R7),X'01'                One parm?\n         BNE   PJC$TIME_MAXX              No, continue\n         CLI   2(R7),X'07'                Length is 7?\n         BNE   PJC$TIME_MAXX              No, continue\n         CLC   3(7,R7),=C'MAXIMUM'        Is it \"TIME=MAXIMUM\"?\n         BE    PJC$TIME_MAXF              Yep\n         CLC   3(7,R7),=C'NOLIMIT'        Is it \"TIME=NOLIMIT\"?\n         BNE   PJC$TIME_MAXX              No, continue\nPJC$TIME_MAXF  EQU *\n         MVI   LASTCC,8                   Set CC to cancel job\n         LA    R0,MSG469L                 Get message length\n         LA    R1,MSG469                  Get message address\n         MVC   MSG469V-MSG469(7,R1),3(R7) Move in value\n         BAS   R9,SAVE_MESSAGE            Save message\n         B     PJC$TIMEX                  Bump past numeric checks\nPJC$TIME_MAXX  EQU *\n*\n         MVC   PJC_TM(6),=C'000000'       Initialize minutes\n         MVC   PJC_TS(2),=C'00'           Initialize seconds\n         CLC   1(2,R7),=X'02,00'          Only seconds, no minutes?\n         BE    PJC$TCSS                   Yes, skip to seconds\n         CLI   2(R7),X'06'                Length of minutes = 4?\n         BNE   PJC$TCM5                   No, continue\n         MVC   PJC_TM(6),3(R7)            Get minutes\n         B     PJC$TCSS                   and then get seconds\nPJC$TCM5 DS    0H\n         CLI   2(R7),X'05'                Length of minutes = 4?\n         BNE   PJC$TCM4                   No, continue\n         MVC   PJC_TM+1(5),3(R7)          Get minutes\n         B     PJC$TCSS                   and then get seconds\nPJC$TCM4 DS    0H\n         CLI   2(R7),X'04'                Length of minutes = 4?\n         BNE   PJC$TCM3                   No, continue\n         MVC   PJC_TM+2(4),3(R7)          Get minutes\n         B     PJC$TCSS                   and then get seconds\nPJC$TCM3 DS    0H\n         CLI   2(R7),X'03'                Length of minutes = 3?\n         BNE   PJC$TCM2                   No, continue\n         MVC   PJC_TM+3(3),3(R7)          Get minutes\n         B     PJC$TCSS                   and then get seconds\nPJC$TCM2 DS    0H\n         CLI   2(R7),X'02'                Length of minutes = 2?\n         BNE   PJC$TCM1                   No, continue\n         MVC   PJC_TM+4(2),3(R7)          Get minutes\n         B     PJC$TCSS                   and then get seconds\nPJC$TCM1 DS    0H\n         CLI   2(R7),X'01'                Length of minute = 1?\n         BNE   PJC$TCSS                   No, continue\n         MVC   PJC_TM+5(1),3(R7)          Get minute\n*\nPJC$TCSS DS    0H\n         CLI   1(R7),X'01'                Any seconds? (One subparm)\n         BE    PJC$TCSX                   No, skip\n         CLI   1(R7),X'02'                Looks right? (Two Subparms)\n         BNE   PJC$TCSX                   No, skip\n         SLR   R1,R1                      Clear register\n         IC    R1,2(R7)                   Get length of hours\n         LA    R15,3(R7)                  Locate to start of hours\n         AR    R15,R1                     Locate past hours\n         CLI   0(R15),X'02'               Length of seconds is 2?\n         BNE   PJC$TCS1                   No, continue\n         MVC   PJC_TS(2),1(R15)           Get seconds\n         B     PJC$TCSX\nPJC$TCS1 DS    0H\n         CLI   0(R15),X'01'               Length of seconds is 2?\n         BNE   PJC$TCSX                   No, continue\n         MVC   PJC_TS+1(1),1(R15)         Get second\nPJC$TCSX DS    0H\n**\n*B PJC$TCZAPX        TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*DC CL8'TIMECHK '    TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\nPJC$TCZAPX EQU *     TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*NOP PJC$TCX         TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n**\n* Note: We grab minutes and seconds on everybody (regardless of CPU\n*       checking for class) to detect TIME=1440 usage\n         CLC   LCA_CLSR+J2X06JC_TIMEM-J2X06JC(6),=6C'*' Unlimited CPU?\n         BE    PJC$TCX                    Yes, don'd need to verify\n         CLC   LCA_CLSR+J2X06JC_TIMEM-J2X06JC(6),=6C' ' Production?\n         BE    PJC$TCX                    No, continue\n         CLC   PJC_TM(6),LCA_CLSR+J2X06JC_TIMEM-J2X06JC Minutes okay?\n         BE    PJC$TCS                             Yes, check seconds\n         CLC   PJC_TM(6),LCA_CLSR+J2X06JC_TIMEM-J2X06JC Minutes okay?\n         BL    PJC$TCX                             No, error\n*\nPJC$TCE  DS    0H\n         MVI   LASTCC,8                   Cancel this job...\n         LA    R1,WORKMSG                 Locate work area\n         MVC   0(MSG470L,R1),MSG470       Move in message\n         MVC   MSG470JM-MSG470(6,R1),PJC_TM Get minutes\n         MVC   MSG470JS-MSG470(2,R1),PJC_TS Get seconds\n         LA    R15,LCA_CLSR               Locate class entry\n         MVC   MSG470CM-MSG470(6,R1),J2X06JC_TIMEM-J2X06JC(R15)\n         MVC   MSG470CS-MSG470(2,R1),J2X06JC_TIMES-J2X06JC(R15)\n         MVC   MSG470C-MSG470(1,R1),J2X06JC_CLASS-J2X06JC(R15)\n         LA    R0,MSG470L                 Get message length\n         BAS   R9,SAVE_MESSAGE            Save message\n         B     PJC$ITIMEX\n*\nPJC$TCS  DS    0H\n         CLC   PJC_TS(2),LCA_CLSR+J2X06JC_TIMES-J2X06JC Seconds okay?\n         BH    PJC$TCE\n*\nPJC$TCX  DS    0H\n         CLC   PJC_TM(6),=C'001440'       Special not-timed value?\n         BNE   PJC$TIME_1440X             No, continue\n         CLC   PJC_TS(2),=C'00'           Still special?\n         BNE   PJC$TIME_1440X             No, continue\n         CLI   2(R7),X'06'                Length is 6?\n         BNE   PJC$TIME_1440$6X           No, continue\n         MVC   3+4(2,R7),=C'39'           Yes, make \"001440\" \"001439\"\n         B     PJC$TIME_1440M             And issue message\nPJC$TIME_1440$6X EQU *\n         CLI   2(R7),X'05'                Length is 5?\n         BNE   PJC$TIME_1440$5X           No, continue\n         MVC   3+3(2,R7),=C'39'           Yes, make \"01440\" \"01439\"\n         B     PJC$TIME_1440M             And issue message\nPJC$TIME_1440$5X EQU *\n         CLI   2(R7),X'04'                Length is 4?\n         BNE   PJC$TIME_1440X             No, continue\n         MVC   3+2(2,R7),=C'39'           Yes, make \"1440\" \"1439\"\nPJC$TIME_1440M EQU *\n         LA    R0,MSG461L                 Get message length\n         LA    R1,MSG461                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\nPJC$TIME_1440X EQU *\nPJC$TIMEX EQU  *\n*\n** Insert TIME parameter into Text unit area for jobs which do not\n** specify it on the jobcard\n*\n         TM    FLAGI1,$FLAGI1_T           We had a TIME= on job card?\n         BO    PJC$ITIMEX                 Yes, leave\n         CLC   LCA_CLSR+J2X06JC_TIMEM-J2X06JC(6),=6C' ' Production?\n         BE    PJC$ITIMEX                 Yes, don't fill it in\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0011',STRLTH          Get length of text\n         LR    R15,R2                     Locate beginning of text\n         AR    R15,R1                     Locate end of text area\n         BCTR  R15,0                      Backup to locate ENDK\n         CLI   0(R15),ENDK                Did we find it?\n         BE    PJC$IT_ES                  Yes, continue\n         LA    R0,MSG471L                 Get message length\n         LA    R1,MSG471                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         B     PJC$ITIMEX                 Leave\nPJC$IT_ES EQU *\n         MVC   0(C_TIMEL,R15),C_TIME      Move in model time text unit\n         CLC   LCA_CLSR+J2X06JC_TIMEM-J2X06JC(6),=6C'*' Unlimited CPU?\n         BE    PJC$IT_FX                  Yes, use default time\n         LA    R14,LCA_CLSR               Locate class entry\n         MVC   C_TIMEM-C_TIME(6,R15),J2X06JC_TIMEM-J2X06JC(R14)\n         MVC   C_TIMES-C_TIME(2,R15),J2X06JC_TIMES-J2X06JC(R14)\nPJC$IT_FX EQU *\n         MVI   C_TIMEL(R15),ENDK          Move in new ENDK\n         AH    R1,=AL2(C_TIMEL)           Add new text unit length\n         STCM  R1,B'0011',STRLTH          Save new length\nPJC$ITIMEX EQU *\n*\n** Normal Exit from Process_Job_Card processing\n*\nPJC$X    DS    0H\n         ICM   R1,B'1111',PJC_TBL         Get address of table\n         BZ    PJC$XX                     Didn't loaded it...\n         LA    R6,=CL8'APPLTBL'           Locate module name\n         DELETE EPLOC=(6)                 Delete the module\nPJC$XX   DS    0H\n         B     EXIT\n*\n** Validate Application code passed in register 15\n** -> Return 0 in R15 if the Application code isn't valid\n*\nPJC$CHECK_APCODE EQU *\n         ICM   R1,B'1111',PJC_TBL         Get address of appl table\n         BZ    PJC$CAX                    None, have to think its good\n         SLR   R14,R14                    Clear register\n         IC    R14,LCAJNAME               Get company code from field\n         SLL   R14,2                      Multiply by 4\n         LA    R14,0(R14,R1)              Locate to company appl ptr\n         ICM   R1,B'1111',0(R14)          Get appl list address\n         BZ    PJC$CAE                    Okay, valid company\nPJC$CAL  DS    0H\n         CLC   0(3,R15),0(R1)             Code correct?\n         BE    PJC$CAX                    Yes, leave\n         LA    R1,3(R1)                   No, bump to next one\n         CLI   0(R1),X'FF'                End of table yet?\n         BNE   PJC$CAL                    Yes, leave\nPJC$CAE  DS    0H\n         SLR   R15,R15                    Set return code to error\nPJC$CAX  DS    0H\n         BSM   0,R9                       Return to caller\n*\n** Validate Company Code passed in register 15\n** -> Return 0 in R15 if the company code isn't valid\n*\nPJC$CHECK_CC EQU *\n         ICM   R1,B'1111',PJC_TBL         Get address of appl table\n         BZ    PJC$CCCX                   None, have to say its good\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R15)                 Get company code from field\n         SLL   R14,2                      Multiply by 4\n         LA    R14,0(R14,R1)              Locate to company appl ptr\n         ICM   R1,B'1111',0(R14)          Get appl list address\n         BNZ   PJC$CCCX                   Okay, valid company\n         SLR   R15,R15                    Set return code to error\nPJC$CCCX DS    0H\n         BSM   0,R9                       Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process a DD Statement                                      **\n**                                                                   **\n**       Note: Put all code that is used for determining if a        **\n**             tape is used in a non-tape class between labels       **\n**             PDS$TAPE and PDS$TAPEX.                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPROCESS_DD_STATEMENT EQU *\n*\n** Look at the DDNAME:\n**\n** - Detect usage of SYSMDUMP to SYSOUT.  Sometimes users mistakenly\n**   use SYSMDUMP when they mean SYSUDUMP.  Putting SYSMDUMP to SYSOUT\n**   puts a meaningless string of garbage to SYSOUT.  SYSMDUMP should\n**   be put to a disk dataset.  It is only useful when read by IPCS.\n**\n** - Detect usage of obsolete DDNAMEs\n**\n**                           0 1 2 3 4 5 6 7 8 9\n**                           TU##llS T E P C A T\n** //STEPCAT translates into 6E0107E2E3C5D7C3C1E3\n*\n         LA    R0,DDK                     Get DD value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$DDX      Locate key\n         LR    R3,R1                      Save address of text unit\n*\n         CLI   1(R3),1                    Number of DDNAMES looks ok?\n         BNE   PDS$DDX                    Nope, move on\n*\n         CLI   2(R3),8                    Length for our value?\n         BNE   PDS$DD8X                   No, continue\n         CLC   3(8,R3),=C'SYSMDUMP'       DD=SYSMDUMP?\n         BNE   PDS$DD8X                   No, continue\n         TM    STRDINDC,DTXSYOUT          SYSOUT?\n         BNO   PDS$DDX                    No, continue\n         LA    R0,MSG489L                 Get message length\n         LA    R1,MSG489                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\n         MVI   3+3(R3),C'U'               Change SYSMDUMP to SYSUDUMP\n         B     PDS$X                      Leave\nPDS$DD8X DS    0H\n*\n         CLI   2(R3),6                    Length for our value?\n         BNE   PDS$DD6X                   No, continue\n         CLC   3(6,R3),=C'JOBCAT'         Using Stepcat?\n         BE    PDS$DDE                    Yes, gripe about it\nPDS$DD6X DS    0H\n         CLI   2(R3),7                    Length for our value?\n         BNE   PDS$DD7X                   No, continue\n         CLC   3(7,R3),=C'STEPCAT'        Using Stepcat?\n         BE    PDS$DDE                    Yes, gripe about it\nPDS$DD7X DS    0H\n         B     PDS$DDX                    Continue\nPDS$DDEM MVC   MSG472L(0,R1),3(R3)        Executed: move ddname to msg\nPDS$DDE  EQU *\n         OI    FLAG1,$F1_ASMP             Turn on flag\n         LA    R1,WORKMSG                 Locate work area\n         LA    R0,MSG472L                 Get message length\n         MVC   0(MSG472L,R1),MSG472       Move in message\n         SLR   R15,R15                    Clear register\n         IC    R15,2(R3)                  Get length of DDNAME\n         AR    R0,R15                     Set new message length\n         SH    R15,=H'1'                  Decrement for EX\n         EX    R15,PDS$DDEM               Move DDNAME to message\n         LR    R14,R1                     Locate start of message\n         AR    R14,R0                     Locate end of message\n         MVC   0(L'MSG472PR,R14),MSG472PR Tack on \", Please Remove\"\n         AH    R0,=AL2(L'MSG472PR)        Add length of tacked on stuff\n         BAS   R9,SAVE_MESSAGE            Save message\nPDS$DDX  DS    0H\n*\n** Leave if the DD card is for SYSIN/SYSOUT and we are not debugging\n*\n         TM    FLAG1,$F1_DBUG             Debugging information?\n         BO    PDS$DBCX                   Yes, process to get DSName\n         TM    STRDINDC,DTXSYSIN          SYSIN?\n         BO    PDS$X                      Yes, Skip this DD card\n         TM    STRDINDC,DTXSYOUT          SYSOUT?\n         BO    PDS$X                      Yes, Skip this DD card\nPDS$DBCX DS    0H\n*\n** Locate the Dataset name\n*\n         MVI   WORKDSN,0                  Zero DSNAME for checks\n         LA    R0,DSNAMEK                 Get DSN= value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$DSNE     Locate key\n         MVI   WORKDSN,C' '               Get space\n         MVC   WORKDSN+1(L'WORKDSN-1),WORKDSN Propagate it\n         LR    R3,R1                      Save address of text unit\n         SLR   R15,R15                    Clear register\n         ICM   R15,B'0001',2(R3)          Get DSN length\n         BZ    PDS$DSNX                   None?\n         BNM   PDS$DSN$STD                Standard Dataset?\n         CLI   4(R3),C'*'                 Refer back?\n         BE    PDS$X                      Yes, skip this Dataset...\n*\n         LA    R3,3(R3)                   Bump past part stuff\n         SLR   R14,R14                    Clear register\n         IC    R14,0(R3)                  Get length of first part\n         LA    R0,44                      Check for maximum\n         CR    R14,R0                     In guide lines?\n         BL    PDS$DSN$NSM                Yes, use actual length\n         LR    R14,R0                     No, truncate to 44\nPDS$DSN$NSM EQU *\n         BCTR  R14,0                      Decrement by 1\n         EX    R14,PDS$DSNN               Move dataset name out\n         LA    R14,1(R14)                 Increment for real length\n         ST    R14,WORKDSNL               Save length\n         LA    R15,WORKDSN                Locate work dataset name\n         AR    R15,R14                    Locate to end\n         MVI   0(R15),C'('                Insert open paren.\n         LA    R15,1(R15)                 Bump past it\n*\n         LA    R3,1(R14,R3)               Point to start of 2nd part\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0001',0(R3)          Get length of part\n         LA    R0,8                       Check for maximum\n         CR    R14,R0                     In guide lines?\n         BL    PDS$DSN2                   Yes, use actual length\n         LR    R14,R0                     No, truncate to 44\nPDS$DSN2 DS    0H\n         BCTR  R14,0                      Decrement by 1\n         EX    R14,PDS$DSNO               Move gdg/member out\n         LA    R15,1(R14,R15)             Bump past it\n         MVI   0(R15),C')'                Move in ending paren.\n         LA    R15,1(R15)                 bump past it\n         LA    R1,WORKDSN                 Locate start\n         SR    R15,R1                     Calculate length: end-start\n         ST    R15,WORKDSNL               Save new length of DSN\n         B     PDS$DSNK\n*\nPDS$DSN$STD EQU *                         << Standard (1 part) dsn >>\n         CLC   3(8,R3),=CL8'NULLFILE'     Nullfile?\n         BE    PDS$DSNX                   Yes, skip...\n         LA    R0,44                      Check for maximum\n         CR    R15,R0                     In guide lines?\n         BL    PDS$DSN$STDM               Yes, use actual length\n         LR    R15,R0                     No, truncate to 44\nPDS$DSN$STDM EQU *\n         BCTR  R15,0                      Decrement by 1\n         EX    R15,PDS$DSNM               Move dataset name out\n         LA    R15,1(R15)                 Increment for real length\n         ST    R15,WORKDSNL               Save length\n*\nPDS$DSNK DS    0H                         << Print DSNAME for Debug >>\n         TM    FLAG1,$F1_DBUG             Debugging information?\n         BNO   PDS$DSNX                   No, bump past message\n         LA    R1,WORKMSG                 Locate work message\n         MVC   0(MSG466L,R1),MSG466       Move in message prefix\n         L     R14,WORKDSNL               Get length of DSNAME\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,PDS$DSNP               Move dsn to message area\n         LA    R14,MSG466L+1(R14)         Add length of message\n         LR    R0,R14                     Get length\n         BAS   R9,SAVE_MESSAGE            Move message out to CNMB\n         B     PDS$DSNX                   Continue\n*\nPDS$DSNE DS    0H                         << No dataset found >>\n         TM    FLAG1,$F1_DBUG             Debugging information?\n         BNO   PDS$DSNX                   No, bump past message\n         LA    R0,MSG465L                 Get message length\n         LA    R1,MSG465                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\nPDS$DSNX DS    0H\n*\n** Detect usage of DCB after create of dataset.  This is done to alert\n** the user that he could destroy his dataset by writting over it with\n** different DCB values than when he/she created it.\n**\n**                               0 1 2 3 4 5\n**                               TU##llS H R\n** DISP=SHR      translates into 460103E2C8D9\n** DISP=(,CATLG) translates into 46020005C3C1E3D3C7\n*\n**\n*B PDS$DCBCZX        TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*DC CL8'DCBCHK  '    TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\nPDS$DCBCZX EQU *     TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*NOP PDS$DCBCX       TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n**\n         LA    R0,DISPK                   Get DISP= value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$DCBCX    Locate key\n         LR    R3,R1                      Save address of text unit\n*\n         CLI   2(R3),3                    Length of Status ok?\n         BNE   PDS$DCBCX                  No, probably not coded\n         CLC   3(3,R3),=C'NEW'            DISP=NEW?\n         BE    PDS$DCBCX                  Yes, skip checks\n         CLC   3(3,R3),=C'MOD'            DISP=MOD?\n         BNE   PDS$DCBMODX                Yes, skip checks\n         CLI   WORKDSN,C'&&'              Temporary Dataset?\n         BE    PDS$DCBCX                  Yes, let him do anything!\n         MVC   LCAPARM(C_LOCATEL),C_LOCATE Initialize parm list\n         LA    R1,WORKDSN                 Locate the Data Set Name\n         ST    R1,LCAPARM+4               Save into parmeter list\n         LA    R1,W_CAMLST                Locate the work area\n         ST    R1,LCAPARM+12              Save into parmeter list\n         LOCATE LCAPARM                   Get catalog information\n         LTR   R15,R15                    Catalogued?\n         BNZ   PDS$DCBCX                  No, not found, okay to mod\nPDS$DCBMODX EQU *\n*\n         LA    R0,LRECLMK                 Get LRECL= value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$DCBC$LX  Locate key\n         OI    FLAGI1,$FLAGI1_D           We have a DCB field!\nPDS$DCBC$LX EQU *\n         LA    R0,BLKSIZMK                Get BLKSIZE= value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$DCBC$BX  Locate key\n         OI    FLAGI1,$FLAGI1_D           We have a DCB field!\nPDS$DCBC$BX EQU *\n         LA    R0,RECFMMK                 Get RECFM= value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$DCBC$RX  Locate key\n         OI    FLAGI1,$FLAGI1_D           We have a DCB field!\nPDS$DCBC$RX EQU *\n*\n         TM    FLAGI1,$FLAGI1_D           We have a DCB field?\n         BNO   PDS$DCBCX                  No continue...\n         LA    R0,LABELK                  Get Label= value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$DCBC$LTX Locate key\n         LR    R3,R1                      Save address of text unit\n         CLI   1(R3),X'02'                Enough operands there?\n         BL    PDS$DCBC$LTX               No, assume standard labels\n         SLR   R1,R1                      Clear register\n         IC    R1,2(R3)                   Get length of file number\n         LA    R14,3(R3)                  Bump to start of file number\n         AR    R14,R1                     Bump past file number\n         CLC   1(2,R14),=C'NL'            Non-Labeled tape?\n         BE    PDS$DCBCX                  Yes, we NEED DCB info!!!!\n         CLC   1(3,R14),=C'BLP'           Bypass Labels?\n         BE    PDS$DCBCX                  Yes, foriegn tape...\nPDS$DCBC$LTX EQU *\n         LA    R0,MSG473L                 Get message length\n         LA    R1,MSG473                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\nPDS$DCBCX EQU  *\n*\n** Detect usage of AS./ datasets in production job class\n*\n**\n*B PDS$ASDSNZX       TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*DC CL8'ASDSN   '    TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\nPDS$ASDSNZX EQU *    TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n*NOP PDS$ASDSNX      TEMP CODE FOR EASY ZAPING !!!!!!!!!!!!!!!!\n**\n         TM    FLAG1,$F1_PROD             Production jobname?\n         BNO   PDS$ASDSNX                 No continue...\n         CLC   WORKDSN(3),=C'AS.'         Is this an DSN=AS./\n         BNE   PDS$ASDSNX                 No, continue\n         OI    FLAG1,$F1_ASMP             Turn on flag\n         LA    R0,MSG474L                 Get message length\n         LA    R1,MSG474                  Get message address\n         BAS   R9,SAVE_MESSAGE            Save message\nPDS$ASDSNX EQU *\n*\n** Only need tape checking if the job class forbids it's usage\n*\n         CLI   LCA_CLSR+J2X06JC_TAPE-J2X06JC,$J2X06JC_TAPEY Tapes ok?\n         BE    PDS$TAPEX                  Yes, skip tape checking\nPDS$TAPE EQU  *                           << Start of tape checking >>\n*\n** See if the unit name is for a tape device\n*\n         LA    R0,UNITK                   Get UNIT= value\n         LA    R1,STRDKEY                 Locate text\n        $CALL  XINTKEY,ERRET=PDS$UNITX    Locate key\n         LR    R3,R1                      Save address of text unit\n*\n         SLR   R15,R15                    Clear register\n         ICM   R15,B'0001',2(R3)          Get length of unitname\n         BZ    PDS$UNITX                  None?\n         BCTR  R15,0                      Decrement for EX\n         MVC   DOUBLE(8),=CL8' '          Get some trailing blanks\n         EX    R15,PDS$UM                 Move unit name to work area\n*\n         L     R1,=V(XYZJ2#06)            Locate CSECT\n         LA    R1,TABLE_TU-XYZJ2#06(R1)   Locate tape table\n         LA    R0,TABLE#TU                Get number in table\nPDS$UNITL EQU  *\n         CLC   DOUBLE(8),0(R1)            Unit name match?\n         BE    PDS$UNITE                  Mr Bill says \"Oh Noooooo\"\n         LA    R1,8(R1)                   Bump to next entry\n         BCT   R0,PDS$UNITL               ..and process it\n         B     PDS$UNITX                  Passed the UNIT check\n*\nPDS$UNITE EQU *\n         MVI   LASTCC,8                   Set CC to cancel job\n         LA    R1,WORKMSG                 Locate work message\n         MVC   0(MSG468L,R1),MSG468       Move in message prefix\n         MVC   MSG468C-MSG468(1,R1),LCA_CLS Get job class\n         MVC   MSG468L(5,R1),=C'UNIT='    Move in reason type\n         MVC   MSG468L+5(8,R1),DOUBLE     Move offending unit name\n         LA    R0,MSG468L+5+8             Get length\n         BAS   R9,SAVE_MESSAGE            Move message out to CNMB\nPDS$UNITX EQU *\n*\n** Perform locate on Tape dataset\n*\nPDS$DSNV DS    0H                         << Locate in tape DSNs >>\n         MVC   LCAPARM(C_LOCATEL),C_LOCATE Initialize parm list\n         LA    R1,WORKDSN                 Locate the Data Set Name\n         ST    R1,LCAPARM+4               Save into parmeter list\n         LA    R1,W_CAMLST                Locate the work area\n         ST    R1,LCAPARM+12              Save into parmeter list\n         LOCATE LCAPARM                   Get catalog information\n         LTR   R15,R15                    Catalogued?\n         BZ    PDS$DSNV$CHK               Yes, check it out\n         TM    FLAGI1,$FLAGI1_G           Already did GDG test?\n         BO    PDS$DSNV$CHKX              Yes, give up\n         CH    R15,=H'8'                  Possible GDG?\n         BNE   PDS$DSNV$CHKX              No, continue\n         LTR   R0,R0                      Still think so?\n         BNZ   PDS$DSNV$CHKX              No, continue\n         OI    FLAGI1,$FLAGI1_G           Let's try for a GDG\n         LA    R15,WORKDSN                Locate DSNAME\n         A     R15,WORKDSNL               Locate end of DSNAME\n         MVC   0(3,R15),=C'(0)'           Create a GDG name\n         B     PDS$DSNV                   Retry LOCATE with GDG\nPDS$DSNV$CHK EQU *\n         CLI   W_CAMLST+CLA_UT3-CLA,X'80' TAPE dataset?\n         BNE   PDS$DSNV$CHKX              No, continue\n         MVI   LASTCC,8                   Set CC to cancel job\n         LA    R1,WORKMSG                 Locate work message\n         MVC   0(MSG468L,R1),MSG468       Move in message prefix\n         MVC   MSG468C-MSG468(1,R1),LCA_CLS Get job class\n         MVC   MSG468L(11,R1),=C'DSN OPERAND' Get reason type\n         LA    R0,MSG468L+11              Get length\n         BAS   R9,SAVE_MESSAGE            Move message out to CNMB\nPDS$DSNV$CHKX  EQU *\nPDS$TAPEX EQU  *                          << End of tape checking >>\n*\n** Normal Exit from Process_DD_Statement processing\n*\nPDS$X    DS    0H\n         B     EXIT\n*\n** Executed instructions\n*\nPDS$DSNM MVC   WORKDSN(0),3(R3)\nPDS$DSNN MVC   WORKDSN(0),1(R3)\nPDS$DSNO MVC   0(0,R15),1(R3)\nPDS$DSNP MVC   MSG466L(0,R1),WORKDSN\nPDS$UM   MVC   DOUBLE(0),3(R3)            Move in truncated unit\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process a EXEC statement                                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPROCESS_EXEC_STATEMENT EQU *\n*\n** Normal Exit from Process_EXEC_Statement processing\n*\nPES$X    DS    0H\n         B     EXIT\n         EJECT\n***********************************************************************\n***                                                                 ***\n** Pass message back to the C/I to be placed into the JCLMSG dataset **\n** via the CNMB control block. The CNMB will be freed by C/I.        **\n**                                                                   **\n** Input: R0 has length of the message                               **\n**        R1 has address of the message                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nSAVE_MESSAGE EQU *\n         STM   R0,R1,DOUBLE               Save msg length and address\n*\n       GETMAIN RU,                        Obtain storage for CNMB      @\n               SP=SM$SUBP,                ..SubPool                    @\n               LV=SM$CNMBL,               ..Length                     @\n               LOC=BELOW                  ..Must be below the line\n*\n         XC    0(SM$CNMBL,R1),0(R1)       Clear CNMB to binary zeros\n         MVC   CNMBID-CNMB(4,R1),=AL4(CNMBCID)  Move in \"CNMB\"\n         MVI   CNMBVER-CNMB(R1),CNMBCVER  Get the version\n         MVI   CNMBSUBP-CNMB(R1),SM$SUBP  Set subpool\n         LA    R0,SM$CNMBL                Get CNMB buffer length\n         STH   R0,CNMBLEN-CNMB(R1)        Set length and save\n         LM    R14,R15,DOUBLE             Get length and address\n         STC   R14,CNMBMLEN-CNMB(R1)      Set length\n         BCTR  R14,0                      Decrement by 1\n         EX    R14,SM$MOVE                Move message out\n*\n         ICM   R15,B'1111',A_CNMB         First time?\n         BNZ   SM$SFX                     No, continue\n         L     R14,A_PARM                 Locate parameter list\n         ST    R1,DCNVCNMB-DCNVPARM(R14)  Save pointer to first\n         B     SM$X\nSM$SFX   DS    0H\n         ST    R1,CNMBNPTR-CNMB(R15)     Save pointer to last one\nSM$X     DS    0H\n         ST    R1,A_CNMB                  Save CNMB pointer\n         BSM   0,R9                       Return to C/I\n*\nSM$MOVE  MVC   CNMBMSG-CNMB(0,R1),0(R15)  EXecuted instruction\nSM$CNMBL EQU   CNMBSIZE+CNMBMAXL          Get length of CNMB\nSM$SUBP  EQU   230                        Subpool of CNMB area\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nC_LOCATE CAMLST NAME,*-*,,*-*\nC_LOCATEL EQU  *-C_LOCATE\n*\nC_TIME   DS    0H\n         DC    AL1(TIMEJK)               Verb type is JOB Card Time\n         DC    X'02'                     Number of subparms\n         DC    X'06'                     Length of subparm 1\nC_TIMEM  DC    CL6'000005'               Subparm 1 = CPU minutes\n         DC    X'02'                     Length of subparm 2\nC_TIMES  DC    CL2'00'                   Subparm 2 = CPU seconds\nC_TIMEL  EQU   *-C_TIME\n*\n** Messages\n*\nMSG460   WTO   'XYZ460E JCL standards not followed, job terminated',   @\n               MF=L\n*\nMSG461   DC    C'XYZ461I '\n         DC    C'TIME=1440 was internally changed to TIME=1439, '\n         DC    C'this job will be timed'\nMSG461L  EQU   *-MSG461\nMSG462   DC    C'XYZ462E '\n         DC    C'Job class must be specified on the job card'\nMSG462L  EQU   *-MSG462\nMSG463   DC    C'XYZ463E '\n         DC    C'Numeric job classes can only be used by '\n         DC    C'production job names'\nMSG463L  EQU   *-MSG463\nMSG464   DC    C'XYZ464E '\n         DC    C'Job class \"'\nMSG464C  DC    C'?\" is not valid'\nMSG464L  EQU   *-MSG464\nMSG465   DC    C'XYZ465W Dataset name could not be determined'\nMSG465L  EQU   *-MSG465\nMSG466   DC    C'XYZ466I '\n         DC    C'Using DSN='\nMSG466L  EQU   *-MSG466\nMSG467   DC    C'XYZ467I '\n         DC    C'Job class='\nMSG467C  DC    C'C'\n         DC    C' tapes='\nMSG467T  DC    C'C'\n         DC    C' Time=('\nMSG467TM DC    C'123456'\n         DC    C','\nMSG467TS DC    C'12'\n         DC    C')'\nMSG467L  EQU   *-MSG467\nMSG468   DC    C'XYZ468E '\n         DC    C'Tape usage not authorized for job class='\nMSG468C  DC    C'?'\n         DC    C' - '\nMSG468L  EQU   *-MSG468\nMSG469   DC    C'XYZ469E '\n         DC    C'TIME='\nMSG469V  DC    C'NOLIMIT'\n         DC    C' is not allowed'\nMSG469L  EQU   *-MSG469\n*\nMSG470   DC    C'XYZ470E TIME=('\nMSG470JM DC    C'123456'\n         DC    C','\nMSG470JS DC    C'12'\n         DC    C') is over limit of Time=('\nMSG470CM DC    C'123456'\n         DC    C','\nMSG470CS DC    C'12'\n         DC    C') for job class='\nMSG470C  DC    C'a'\nMSG470L  EQU   *-MSG470\n*\nMSG471   DC    C'XYZ471W Internal error in '\n         DC    C'JES2 exit XYZJ2X06 (&SYSTIME &SYSDATE) - '\n         DC    C'ENDK not found'\nMSG471L  EQU   *-MSG471\n*\nMSG472   DC    C'XYZ472E Using obsolete DDNAME='\nMSG472L  EQU   *-MSG472\nMSG472PR DC    C', Please remove!'\n*\nMSG473   DC    C'XYZ473W DCB values found on existing dataset, '\n         DC    C'data corruption or unpredictable results may occur'\nMSG473L  EQU   *-MSG473\n*\nMSG474   DC    C'XYZ474E Use of DSN=AS.* is not allowed in production '\n         DC    C'jobs'\nMSG474L  EQU   *-MSG474\n*\nMSG475   WTO   'XYZ475I XYZJ2X06 assembled on &SYSDATE at &SYSTIME',   @\n               MF=L\n*\nMSG476   DC    C'XYZ476E First character of accounting field '\nMSG476FN DC    C' '\n         DC    C' has \"'\nMSG476CC DC    C' '\n         DC    C'\" (not a valid company code)'\nMSG476L  EQU   *-MSG476\n*\nMSG477   DC    C'XYZ477E Application code \"'\nMSG477AP DC    C'xyz'\n         DC    C'\" in accounting field 4 is not valid for company '\nMSG477CC DC    C' '\n         DC    C'\"'\nMSG477L  EQU   *-MSG477\n*\nMSG478   DC    C'XYZ478W Load of application table failed, call the '\n         DC    C'Help desk at 8 + 594-2797 (XYZ Net)'\nMSG478L  EQU   *-MSG478\n*\nMSG479   DC    C'XYZ479E No accounting fields found, job terminated'\nMSG479L  EQU   *-MSG479\n*\nMSG480   DC    C'XYZ480E Job has wrong number of accounting fields, '\n         DC    C'must be 4, for example: ('\nMSG480F1 DC    C'D,'\nMSG480F2 DC    C'D,'\nMSG480F3 DC    C'D,'\n         DC    C'AAA)'\nMSG480L  EQU   *-MSG480\n*\nMSG481   DC    C'XYZ481E Jobname is missing, job terminated'\nMSG481L  EQU   *-MSG481\n*\nMSG482   DC    C'XYZ482W Not prepared for system created job string, '\n         DC    C'call the help desk'\nMSG482L  EQU   *-MSG482\n*\nMSG483   DC    C'XYZ483W Application code longer than 3 Characters in '\n         DC    C'accounting field 4, only first 3 used'\nMSG483L  EQU   *-MSG483\n*\nMSG484   DC    C'XYZ484E First character of the jobname '\n         DC    C'is not a valid company code: \"'\nMSG484CC DC    C'x'\n         DC    C'\"'\nMSG484L  EQU   *-MSG484\n*\nMSG485   DC    C'XYZ485E Application code \"'\nMSG485AP DC    C'xyz'\n         DC    C'\" in the jobname is not valid for company '\nMSG485CC DC    C' '\nMSG485L  EQU   *-MSG485\n*\nMSG486   DC    C'XYZ486E Application number \"'\nMSG486AN DC    C'000'\n         DC    C'\" in the jobname has non-numeric characters'\nMSG486L  EQU   *-MSG486\n*\nMSG487   DC    C'XYZ487E Frequency \"'\nMSG487F  DC    C'f'\n         DC    C'\" in the jobname is invalid, should be one of the'\n         DC    C' following: '\nMSG487L  EQU   *-MSG487\n*\nMSG488   DC    C'XYZ488E Application code in accounting field 4 must '\n         DC    C'be at least 3 characters in length'\nMSG488L  EQU   *-MSG488\n*\nMSG489   DC    C'XYZ489I DD=SYSMDUMP detected going to SYSOUT, it was '\n         DC    C'changed to DD=SYSUDUMP'\nMSG489L  EQU   *-MSG489\n*\nMSG496   WTO   'XYZ496W JOB XXXXXXXX has JCL that violates ISRM standar@\n               ds',                                                    @\n               MF=L\nMSG496L  EQU   *-MSG496\nMSG496A  EQU   4+12                       LOCATE \"XXXXXXXX\" IN MSG498\n*\nMSG497   WTO   'XYZ497W This job may not be allowed to run in the futur@\n               e if the JCL is not corrected',                         @\n               MF=L\n*\nMSG498   WTO   'XYZ498W JOB XXXXXXXX has JCL that violates automated st@\n               orage management project directives',                   @\n               MF=L\nMSG498L  EQU   *-MSG498\nMSG498A  EQU   4+12                       LOCATE \"XXXXXXXX\" IN MSG498\n*               0....+....1....+....2....+....3\nMSG499   WTO   'XYZ499I JOB XXXXXXXX using /*ROUTE PRINT <NODE> FOR MSG@\n               CLASS=X - route to node was ignored',                   @\n               MF=L\nMSG499L  EQU   *-MSG499\nMSG499A  EQU   4+12                       LOCATE \"XXXXXXXX\" IN MSG499\n*\n** Literals used in program\n*\n         LTORG ,\nAPARNUM  DC    CL8'NONE'                  APAR Number\n         DS    0D                         End of EXIT06\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Tables and data that we will let be externally referenced   **\n**                                                                   **\n**   Note: The H_J2VS/J2X06EDH_J2VS at offset 0 is done to simulate  **\n**         the ADRRELVL and ICKRELVL modules.                        **\n**                                                                   **\n**   Note: You *must* keep the format of this CSECT in sync with the **\n**         XYZJ2X#06 macro or other program that process this module **\n**         will faile.                                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LCLC  &ASMDATE\n* In High-Level-Assembler, &SYSDATC is \"YYYYMMDD\"\n&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n*&ASMDATE SETC  '&SYSDATE'                                        ASM-H\n*\n** Start of CSECT\n*\nXYZJ2#06 CSECT ,\nXYZJ2#06 AMODE 31\nXYZJ2#06 RMODE ANY\n*\nHEADER   EQU   *\nH_J2VS   DC    X'00,04,02,00'                 JES2 short version: 420\nH_J2VER  DC    CL8'&VERSION'                  JES2 version long\nH_ID     DC    CL8'XYZJ2#06'                  Module name\nH_ASMD   DC    CL10'&ASMDATE'                 ASM date: \"1994/03/06\"\nH_ASMT   DC    CL6'&SYSTIME'                  ASM time: \"hh:mm\"\nH_DBJOB  DC    CL8'&DBGJNME'                  Debugging jobname\nHEADERL  EQU   *-HEADER                       Must match J2X06EDHL\nHEADERT  EQU   J2X06EDHL                      Match?  !!!!\n*\n** Offsets for external programs (mapped by J2X06EDE)\n*\nENTRIES  EQU   *\n         DC    AL2($J2X06EDE_TJC,TABLE_JC-XYZJ2#06)   Job class\n         DC    AL2($J2X06EDE_TFQ,TABLE_FQ-XYZJ2#06)   Frequency\n         DC    AL2($J2X06EDE_TNP,TABLE_NP-XYZJ2#06)   Non-production\n         DC    AL2($J2X06EDE_TTU,TABLE_TU-XYZJ2#06)   Tape unit\n         DC    AL1(#J2X06EDE_END)                     End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      Non-Prodution jobnames                                     ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\nTABLE_NP DS    0H\nNPTE1    DC    CL6'SCIS  ',AL1(4,0),AL2(D_NPTE1-XYZJ2#06)\nNPTE2    DC    CL6'CON   ',AL1(3,1),AL2(D_NPTE2-XYZJ2#06)\nNPTE3    DC    CL6'TSO   ',AL1(3,1),AL2(D_NPTE3-XYZJ2#06)\nNPTE4    DC    CL6'FIRE  ',AL1(4,1),AL2(D_NPTE4-XYZJ2#06)\nNPTE5    DC    CL6'######',AL1(6,1),AL2(D_NPTE5-XYZJ2#06)\n         DC    AL1(#J2X06EDE_END)         End of table\n*\n** Description strings for non-production job types\n*\nD_NPTE1  STR   'Swepco CIS jobs'\nD_NPTE2  STR   'Contractor'\nD_NPTE3  STR   'TSO user'\nD_NPTE4  STR   'Firecall'\nD_NPTE5  STR   'Employee number'\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      Job run frequency                                          ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         DC    CL8'JOB FREQ'\nTABLE_FQ DS    0H\n         DC    C'A',AL2(TFQ_DA-XYZJ2#06)\n         DC    C'B',AL2(TFQ_DB-XYZJ2#06)\n         DC    C'D',AL2(TFQ_DD-XYZJ2#06)\n         DC    C'M',AL2(TFQ_DM-XYZJ2#06)\n         DC    C'Q',AL2(TFQ_DQ-XYZJ2#06)\n         DC    C'R',AL2(TFQ_DR-XYZJ2#06)\n         DC    C'S',AL2(TFQ_DS-XYZJ2#06)\n         DC    C'T',AL2(TFQ_DT-XYZJ2#06)\n         DC    C'W',AL2(TFQ_DW-XYZJ2#06)\n         DC    C'X',AL2(TFQ_DX-XYZJ2#06)\nTABLE#FQ EQU   (*-TABLE_FQ)/(J2X06FQL)\n         DC    AL1(#J2X06EDE_END)         End of table\n*\nTFQ_DA   STR   'Annual'\nTFQ_DB   STR   'Bi-weekly'\nTFQ_DD   STR   'Daily'\nTFQ_DM   STR   'Monthly'\nTFQ_DQ   STR   'Quarterly'\nTFQ_DR   STR   'Request'\nTFQ_DS   STR   'Semi-annual'\nTFQ_DT   STR   'Test/development'\nTFQ_DW   STR   'Weekly'\nTFQ_DX   STR   'System'\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**       JCL rules table - mapped by the J2X06JC DSECT               **\n***                                                                 ***\n** Job-Class, Time-Minutes, Time-Seconds, Tapes-Allowed?, Desc Str   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         DC    CL8'JOB CLASS'\nTABLE_JC DS    0H\n         DC    CL1'A',CL6'000000',CL2'15',C'N',AL2(0)\n         DC    CL1'B',CL6'000000',CL2'15',C'Y',AL2(0)\n         DC    CL1'C',CL6'000000',CL2'45',C'Y',AL2(0)\n         DC    CL1'D',CL6'******',CL2'**',C'Y',AL2(0)\n         DC    CL1'E',CL6'000000',CL2'15',C'N',AL2(0)\n         DC    CL1'F',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'G',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'H',CL6'******',CL2'**',C'Y',AL2(TJC_DH-XYZJ2#06)\n         DC    CL1'I',CL6'******',CL2'**',C'Y',AL2(TJC_DI-XYZJ2#06)\n         DC    CL1'J',CL6'000000',CL2'45',C'Y',AL2(TJC_DJ-XYZJ2#06)\n         DC    CL1'K',CL6'******',CL2'**',C'Y',AL2(TJC_DK-XYZJ2#06)\n         DC    CL1'L',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'M',CL6'******',CL2'**',C'Y',AL2(0)\n         DC    CL1'N',CL6'******',CL2'**',C'Y',AL2(TJC_DN-XYZJ2#06)\n         DC    CL1'O',CL6'******',CL2'**',C'Y',AL2(0)\n         DC    CL1'P',CL6'000000',CL2'05',C'N',AL2(TJC_DP-XYZJ2#06)\n         DC    CL1'Q',CL6'000000',CL2'15',C'N',AL2(0)\n         DC    CL1'R',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'S',CL6'000000',CL2'15',C'Y',AL2(TJC_DS-XYZJ2#06)\n         DC    CL1'T',CL6'000002',CL2'00',C'Y',AL2(TJC_DT-XYZJ2#06)\n         DC    CL1'U',CL6'******',CL2'**',C'Y',AL2(0)\n         DC    CL1'V',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'W',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'X',CL6'      ',CL2'  ',C'Y',AL2(TJC_DX-XYZJ2#06)\n         DC    CL1'Y',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'Z',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'0',CL6'      ',CL2'  ',C'Y',AL2(0) Added: Nov95\n         DC    CL1'1',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'2',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'3',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'4',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'5',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'6',CL6'      ',CL2'  ',C'Y',AL2(0)\n         DC    CL1'7',CL6'      ',CL2'  ',C'Y',AL2(0) Added: Nov95\n         DC    CL1'8',CL6'      ',CL2'  ',C'Y',AL2(TJC_D8-XYZJ2#06)\n         DC    CL1'9',CL6'      ',CL2'  ',C'Y',AL2(TJC_D9-XYZJ2#06)\nTABLE#JC EQU   (*-TABLE_JC)/J2X06JCL\n         DC    AL1(#J2X06EDE_END)         End of table\n*\n** Description strings\n**\n** Note: This exit doesn't use this description string, it is used\n**       by external users of this table.\n*\n*               Turnaround   Description\nTJC_DH   STR   'By 7:00am  | Production IDMS - night'\nTJC_DI   STR   '           | Test IDMS'\nTJC_DJ   STR   '2 hours    |  '\nTJC_DK   STR   '           | Single threaded'\nTJC_DN   STR   'By 7:00am  | Night only'\nTJC_DO   STR   '           | Special Assignment'\nTJC_DP   STR   '10 minutes |  '\nTJC_DQ   STR   '15 minutes |  '\nTJC_DS   STR   '1 hour     |  '\nTJC_DT   STR   '2 hours    |  '\nTJC_DU   STR   '24 hours   | Unlimited CPU'\nTJC_DX   STR   '           | Reserved for Automated Scheduler'\nTJC_D8   STR   '           | Reserved for EDI'\nTJC_D9   STR   '           | Reserved for Indus'\nTJC_DTTL EQU 10 1234567890\nTJC_DTLT EQU   #J2X06JC_DTL                  <-- Match with TJC_DTL?\nTJC_DDO  EQU   3                             Length of \" | \"\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      Table units                                                ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n*\n** Tape unit names (As determined by Omegamon on 05-NOV-1996)\n*\nTABLE_TU EQU   *\n         DC    CL8'3480X   '\n         DC    CL8'3400-6  '\n         DC    CL8'TAPE    '\n         DC    CL8'TAPE1   '\n         DC    CL8'3480    '\n         DC    CL8'3400-9  '\n         DC    CL8'3400-5  '\n         DC    CL8'3400-3  '\n         DC    CL8'2400-3  '\n         DC    CL8'SYS3480R'\n         DC    CL8'SYS348XR'\nTABLE#TU EQU   (*-TABLE_TU)/8\n         DC    AL1(#J2X06EDE_END)         End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      End of XYZJ2#06 CSECT                                      ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         DC    C'ENDOFXYZJ2#06'           Eyecatcher\n         DS    0D\nXYZJ2L06 EQU   *-XYZJ2#06                 Length (for trivia)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       End of XYZJ2X06 module                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n        $MODEND ,                         Generate end of module\nEXIT06L  EQU   *-EXIT06                   Length of EXIT06\nEXIT06F  EQU   8192-EXIT06L               Bytes free under base regs\n         END   ,\n./ ADD NAME=XYZJ2X13 0100-98016-98016-1800-00195-00195-00000-DALCOCK\nXYZJ2X13 TITLE 'JES2 Exit 13 -- Netmail screening and notification'\n***********************************************************************\n***                                                                 ***\n**  Name = XYZJ2X13                                                  **\n**                                                                   **\n**  Author = David Alcock                                            **\n**                                                                   **\n**  Title = IDTF Interactive Data Transmit Faclity Screening and     **\n**          notification JES2 exit                                   **\n**                                                                   **\n**  Purpose = This exit sets RC=8 so JES2 will issue $HASP549 every  **\n**            time a user has a file waiting to be received.         **\n**                                                                   **\n**  Entry Points = Exit 13 - EXIT13 (IDTF Notify)                    **\n**                                                                   **\n**  Register contents upon entry to EXIT13:                          **\n**                                                                   **\n**  - R0 Not applicable                                              **\n**                                                                   **\n**  - R1 Pointer to a 5 word parameter list                          **\n**       - Word 1 (+0)  - Address of the Network Job header          **\n**       - Word 2 (+4)  - Address of the Network Data Set header     **\n**       - Word 3 (+8)  - Address of the Peripheral Data definition  **\n**                        block ($PDDB) built for the received file  **\n**       - Word 4 (+12) - Address of a 1-byte binary field containing**\n**                        the SYSID value of the MAS member the user **\n**                        is currently logged onto.                  **\n**       - Word 5 (+16) - Address of a 70-byte message area for      **\n**                        $HASP598;                                  **\n**                                                                   **\n**  - R10 Address of the $JCT                                        **\n**  - R11 Address of the $HCT                                        **\n**  - R13 Address of the $PCE                                        **\n**  - R14 Return address                                             **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   08-SEP-1996 Check for Zeke mail and reroute to credit  **\n**                        card administrator;                        **\n** DGAlcock   18-MAY-1993 Use the Network Data Header for RSCS info; **\n**                        Added debugging message for assemble info; **\n** DGAlcock   15-MAR-1993 Change RSCS ZEKE output to Z;              **\n** DGAlcock   30-JUL-1992 Converted to JES2 SP4.2; Changed to class  **\n**                        B, a good ole punch class;                 **\n** DGAlcock   08-NOV-1991 Initial exit created;                      **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         GBLC  &DBJOBN\n         GBLC  &CCAUSER\n         GBLC  &VMNODEI\n*\n** Set the global assembly options\n*\n&DBJOBN  SETC  'ibmuserZ'                 Debugging job name\n&CCAUSER SETC  'ibmuser'                  Userid on VMPROFS\n&VMNODEI SETC  '9'                        VM node ID\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       JES2 Macros                                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         COPY $HASPGBL                    Copy HASP Globals\n         EJECT\nXYZJ2X13 $MODULE ENVIRON=JES2,                                         @\n               RMODE=ANY,                                              @\n               SYSP=(GEN,GEN,DATA,GEN,GEN),                            @\n               IBMJES2=SAMPLE,                                         @\n               TITLE='JES2 Exit13 TSO/E Notify Exit -- Prologue',      @\n               $CADDR,                    Common address routine table @\n               $DTE,                      Daughter task element        @\n               $ERA,                      Error recovery area          @\n               $HASPEQU,                  JES2 Equates                 @\n               $HCT,                      Communication table          @\n               $JCT,                      Job Control table            @\n               $MIT,                      Module information table     @\n               $NHD,                      Network Headers              @\n               $PADDR,                    Private Area routine table   @\n               $PARMLST,                  Inline parameter list        @\n               $PCE,                      Processor control element    @\n               $PDDB,                     Peripheral Data Def. Block   @\n               $PSV,                      Process save Area            @\n               $TQE,                      Termination/Recovery Cntrl   @\n               $USERCBS,                  User Control Block           @\n               $XECB                      Extended ECB element\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Exit 13 processing                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Entry housekeeping\n*\nEXIT13  $ENTRY BASE=R12                   Exit routine entry point\n        $SAVE  ,                          Save Caller's registers\n         LR    R12,R15                    Get CSECT address\n         LR    R4,R1                      Save parameter address\n         L     R3,8(,R4)                  Locate Netmail PDDB\n         L     R5,0(,R4)                  Locate Network Job Header\n         L     R6,4(,R4)                  Locate Network DataSet Header\n*\n** Debugging jobname?\n*\n         CLC   NDHGRMT-NDH(8,R6),=CL8'&DBJOBN.'  Debugging userid?\n         BNE   DBMSGX                            No, skip\n        $WTO   MSGDB,L'MSGDB,JOB=YES,CLASS=$TRIVIA Issue message\nDBMSGX   DS    0H\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** RSCS checking for Zeke returns and those to simply purge          **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         CLC   NJHGJNAM-NJH(4,R5),=CL4'RSCS'      Came from RSCS?\n         BNE   RSCS$X                             No, skip this & next\n*\n** Set junk coming back from RSCS to bogus userids to the null class\n*\nRSCS$CHK DS    0H\n         CLC   NDHGRMT-NDH(8,R6),=CL8'DROS001'    Bogus ID?\n         BNE   RSCS$X\nRSCS$P   DS    0H\n         MVI   PDBCLASS-PDB(R3),C'Z'      Set to NULL (Trash) sysout\n        $WTO   MSGRSCS,L'MSGRSCS,JOB=YES,CLASS=$TRIVIA Issue message\n         B     RETURN0\nRSCS$X   DS    0H\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Ensure that NETMAIL goes into class B                             **\n** Our RSCS (XYZ) sends in CLASS A resulting in mail being lost      **\n**                                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         CLI   PDBCLASS-PDB(R3),C'B'      NETMAIL in class B?\n         BE    NETMAILX                   Yes, continue\n         MVI   PDBCLASS-PDB(R3),C'B'      Set NETMAIL to class B\n        $WTO   MSGNETM,L'MSGNETM,JOB=YES,CLASS=$TRIVIA Issue message\nNETMAILX DS    0H\n*\n** Is the user Logged on?\n*\n         L     R3,12(R4)                  -> SYSID value for MAS\n         TM    0(R3),B'00000111'          User logged on?\n         BNZ   LOGON                      Yes, continue\n         MVC   0(1,R3),$SIDBUSY           No, use this member's SID\nLOGON    DS    0H\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Termination                                                       **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Exit housekeeping\n*\nRETURN8  DS    0H\n        $RETURN RC=8                      Return to caller w/notify\n*\nRETURN0  DS    0H\n        $RETURN RC=0                      Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSGDB   $MSG   900,'XYZJ2X13 last assembled on &SYSDATE at &SYSTIME '\nMSGNETM $MSG   901,'NETMAIL changed to class B by exit XYZJ2X13'\nMSGRSCS $MSG   902,'NETMAIL from RSCS for invalid userid changed to SYS@\n               OUT CLASS=Z by exit XYZJ2X13'\n*\n** Literals\n*\n         LTORG ,                          Literals used in EXIT13\n*\n         DS    0D                         End of EXIT13\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       XYZJ2X13 End                                                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n        $MODEND ,\n         END\n./ ADD NAME=XYZJ2X20 0100-98016-98016-1800-00106-00106-00000-DALCOCK\nXYZJ2X20 TITLE 'JES2 Exit 20 -- End of Input'\n***********************************************************************\n***                                                                 ***\n**  Name = XYZJ2X20                                                  **\n**                                                                   **\n**  Author = David Alcock                                            **\n**                                                                   **\n**  Title = End of input                                             **\n**                                                                   **\n**  Purpose = This exit sets the input priority for batch jobs       **\n**                                                                   **\n**  Entry Points = Exit 20 - EXIT20 (End of Input)                   **\n**                                                                   **\n**  Register contents upon entry to EXIT20:                          **\n**                                                                   **\n**  - R0 A code:                                                     **\n**       - 0 = Normal end of input                                   **\n**       - 4 = Job has a JES2 control statement error                **\n**                                                                   **\n**  - R10 Address of the $JCT                                        **\n**  - R11 Address of the $HCT                                        **\n**  - R13 Address of the HASPRDR PCE                                 **\n**  - R14 Return address                                             **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   09-NOV-1996 JES2 4.3;                                  **\n** DGAlcock   11-NOV-1993 Change *ALL* input PRTY to 3;              **\n** DGAlcock   06-OCT-1993 Don't change input prty for job classes    **\n**                        W and K (single threaded) per W. Dunn;     **\n** DGAlcock   01-APR-1993 Corrected priority changing in SP4.2;      **\n** DGAlcock   04-AUG-1992 Converted to JES2 SP4.2;                   **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         COPY $HASPGBL                    Copy HASP Globals\n         EJECT\nXYZJ2X20 $MODULE ENVIRON=JES2,                                         @\n               RMODE=ANY,                                              @\n               IBMJES2=SAMPLE,                                         @\n               TITLE='JES2 EXIT 20 - End of input',                    @\n               $BUFFER,                   ..Buffers                    @\n               $CAT,                      ..Class Attribute Table      @\n               $HASPEQU,                  ..JES2 Equates               @\n               $HCT,                      ..HASP Communications Table  @\n               $JCT,                      ..Job Control Table          @\n               $JQE,                      ..Job Queue Element          @\n               $MIT,                      ..Module Information Table   @\n               $PADDR,                    ..Private Address Storage Tb @\n               $PCE,                      ..Processor Control Element  @\n               $RDRWORK,                  ..HASP Input PCE             @\n               RPL                        ..Request Parameter list\n         TITLE 'XYZ JES2 exit 20 - End of Input'\n***********************************************************************\n***                                                                 ***\n**       Priority                                                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         USING HCT,R11                    Addressibility to HCT\n         USING JCT,R10                    Addressibility to JCT\n*\n** Entry housekeeping\n*\nEXIT20  $ENTRY BASE=R12,CSECT=YES         Entry mon frair\n        $SAVE ,                           Save registers\n         LR    R12,R15                    Load base register\n*\n** Processing this one?\n*\n         TM    JCTJOBFL,JCTBATCH          Batch Job?\n         BNO   EXIT0                      No, leave right now\n*\n** Set input priority\n*\n         MVI   JCTIPRIO,X'30'             Set priority\n*\n** Exit housekeeping\n*\nEXIT0    DS    0H\n        $RETURN RC=0                      Return to JES2\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Data constants                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LTORG ,                          Literals for XYZJ2X20\nAPARNUM  DC    CL8'NONE'                  APAR Number\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Generate end of module                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n        $MODEND ,\n         END\n./ ADD NAME=XYZJ2X36 0100-98016-98016-1800-00204-00204-00000-DALCOCK\nXYZJ2X36 TITLE 'JES2 Exit 36 -- Pre-Security Authorization Call'\n***********************************************************************\n***                                                                 ***\n**  Name = XYZJ2X36                                                  **\n**                                                                   **\n**  Author = David Alcock                                            **\n**                                                                   **\n**  Title = Pre-Security Authorization call - JES2 exit 36           **\n**                                                                   **\n**  Purpose = Provide performance improvement in the JES2 address    **\n**            space.  This exit implements a suggestion by Computer  **\n**            Associates to reduce JESSPOOL overhead by eliminating  **\n**            a call to ACF2 for system datasets.  This suggestion   **\n**            was made in PIB# GI21127 issued in Fall 1993.          **\n**                                                                   **\n**  Entry Points = Exit 36 - EXIT36                                  **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   09-NOV-1996 JES2 4.3;                                  **\n** DGAlcock   01-FEB-1994 Initial exit created;                      **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         TITLE 'JES2 Exit 36 (PRE SAF CALL) -- PROLOG ($HASPGBL)'\n         COPY  $HASPGBL\n         TITLE 'RACHECK MAPPING MACRO DSECT'\n         ICHACHKL DSECT=YES\n         TITLE 'RACINIT MAPPING MACRO DSECT'\n         IRRPRIPL\n         TITLE 'JES2 Exit 36 (PRE SAF CALL) -- PROLOG ($MODULE)'\nXYZJ2X36 $MODULE ENVIRON=USER,                                         @\n               RMODE=ANY,                                              @\n               IBMJES2=SAMPLE,                                         @\n               TITLE='JES2 EXIT 36 - SAF stuff',                       @\n               SAFP,               SAF ICHSAFP - parm list mapping     C\n               TOKEN,              SAF ICHRUTKN - TOKEN mapping        C\n               $CADDR,             Common storage address list         C\n               $DTE,               Daughter task element               C\n               $ERA,               Erorr recovery area                 C\n               $HASPEQU,           General EQUATES                     C\n               $HCCT,              Common storage control table        C\n               $HCT,               Private storage control table       C\n               $HFAME,             HASP file allocation map element    C\n               $MIT,               Module information table            C\n               $PADDR,             Private storage address list        C\n               $PARMLST,           Parameter list values/equates       C\n               $PCE,               Processor control element           C\n               $PSV,               Processor save area                 C\n               $SCAT,              SYSOUT class attribute table        C\n               $XECB,              Extended ECB                        C\n               $WAVE,              Work access verification element    C\n               $XIT,               Exit information table              C\n               ($XPL,GEN)          Exit parameter list\n         TITLE 'BYPASS CREATE/DELETE SAF CALLS -- (ROUTINE NOCREDEL)'\n***********************************************************************\n*                                                                     *\n*        NOCREDEL - Bypass SAF calls for create/delete of spool       *\n*                   data set authorization checking.                  *\n*                                                                     *\n* FUNCTION :                                                          *\n*                                                                     *\n*        This routine checks the function code (FUNCODE) for          *\n*        SYSIN data set create ($SEASIC), SYSOUT data set create      *\n*        ($SEASOC), or SYSIN/SYSOUT data set deleteion ($SEADEL).     *\n*        For these function codes, the SAF call will be bypassed.     *\n*        A zero return cdoe will be set so that any other exit 36     *\n*        routines will be taken.                                      *\n*                                                                     *\n*        One reason for taking this exit is to cut down on the        *\n*        overhead of the implied RACINITs for these JESSPOOL checks.  *\n*        This should be a performance boost while still controlling   *\n*        the TSO OUTPUT command through the JESSPOOL class.           *\n*                                                                     *\n* LINKAGE :                                                           *\n*                                                                     *\n*        This routine is entered via a BASR R14,R15 from the USERSUB  *\n*        routine in the HASCSIRQ CSECT of the HASPSSSM load module.   *\n*        Control is returned via BSM.                                 *\n*                                                                     *\n* OPERATION :                                                         *\n*                                                                     *\n*        LOADMOD(XYZJ2X36) STORAGE=CSA                                *\n*        EXIT(36)  ROUTINES=EXIT36,STATUS=ENABLED                     *\n*                                                                     *\n* ENVIRONMENT :                                                       *\n*                                                                     *\n*        Either subtask or user address space                         *\n*                                                                     *\n* RECOVERY :                                                          *\n*                                                                     *\n*        Default recovery provided by caller.                         *\n*                                                                     *\n* REGISTER USAGE (ENTRY/EXIT) :                                       *\n*                                                                     *\n*    REG       VALUE ON ENTRY             VALUE ON EXIT               *\n*                                                                     *\n*    R0        N/A                        Unchanged                   *\n*    R1        Address of parm list       Unchanged                   *\n*    R2-R10    N/A                        Unchanged                   *\n*    R11       HCCT address               Unchanged                   *\n*    R12       N/A                        Unchanged                   *\n*    R13       Save area                  Unchanged                   *\n*    R14       Return address             Unchanged                   *\n*    R15       Routine address            Return code                 *\n*                                                                     *\n* PARAMETER LIST :                                                    *\n*                                                                     *\n*        See $XPL expansion                                           *\n*                                                                     *\n* REGISTER USAGE (INTERNAL) :                                         *\n*                                                                     *\n*    REG       VALUE                                                  *\n*                                                                     *\n*    R0        N/A                                                    *\n*    R1        XPL (parameter list addr)                              *\n*    R2-R10    N/A                                                    *\n*    R11       HCCT address                                           *\n*    R12       Routine base address                                   *\n*    R13       Available save area                                    *\n*    R14       Linkage                                                *\n*    R15       Return code                                            *\n*                                                                     *\n* DATA AREA USAGE (INTERNAL) :                                        *\n*                                                                     *\n*    NAME          VALUE                                              *\n*                                                                     *\n*    $SEADEL       The FUNCODE for a spool data set delete            *\n*    $SEASIC       The FUNCODE for a SYSIN spool data set create      *\n*    $SEASOC       The FUNCODE for a SYSOUT spool data set create     *\n*                                                                     *\n*    XPLIND        Exit parameter list indicator byte - FUNCODE value *\n*    XPLRESP       Exit parameter list response byte - exit decision  *\n*    X036BYPS      Response byte value to bypass SAF call             *\n*    X036NORC      Response byte value to use exit supplied ret code  *\n*    X036RETC      User exit supplied return code                     *\n*    X036RSNC      User exit supplied reason code                     *\n*                                                                     *\n* RETURN CODES (R15 ON EXIT) :                                        *\n*                                                                     *\n*         0 - NORMAL PROCESSING                                       *\n*         4 - DO NOT INVOKE NEXT ROUTINE                              *\n*                                                                     *\n* OTHER CONSIDERATIONS :                                              *\n*                                                                     *\n*         N/A                                                         *\n*                                                                     *\n***********************************************************************\n         TITLE 'BYPASS CREATE/DELETE SAF CALLS -- NOCREDEL'\n         USING XPL,R1              XPL  addressability\n         USING HCCT,R11            HCCT addressability\n         SPACE 1\nEXIT36   $ENTRY BASE=R15\n         SPACE 1\n         CLI   XPLIND,$SEASSOC     Was the call for system data set cr?\n         BE    BYPASS              Yes, then bypass\n         CLI   XPLIND,$SEADEL      Was the call for delete?\n         BE    BYPASS              Yes, then bypass\n         CLI   XPLIND,$SEASIC      Was the call for SYSIN create?\n         BE    BYPASS              Yes, then bypass\n         CLI   XPLIND,$SEASOC      Was the call for SYSOUT create?\n         BNE   EXIT                No, then exit\n         EJECT\n***********************************************************************\n*                                                                     *\n*        Bypass the SAF call, and indicate to use the exit supplied   *\n*        return code as the return code from SAF.                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nBYPASS   OI     XPLRESP,X036BYPS   Indicate to bypass SAF call\n         OI     XPLRESP,X036NORC   Indicate to use exit 36 return codes\n         XC     X036RETC,X036RETC  Simulate zero return code from SAF\n         XC     X036RSNC,X036RSNC  Simulate zero reason code from SAF\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        Return to caller with a zero return code.                    *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nEXIT     SLR    R15,R15            Always return zero return code\n         BSM    0,R14              Return\n         SPACE 1\n         DROP   R1,R11,R15         Drop addressability\n         SPACE 1\n         LTORG\nAPARNUM  DC    CL8'NONE'           APAR NUMBER\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Module end                                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n        $MODEND ,\n         END   ,                   END OF XYZJ2X36\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 18:01 ON 98/01/16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LASTUSE": {"ttr": 24321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x000\\x01\\x020o\\x01\\x020o\\x18)\\x00\\x84\\x00{\\x00\\x00\\xc4\\xc1\\xd3\\xc3\\xd6\\xc3\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T18:29:30", "lines": 132, "newlines": 123, "modlines": 0, "user": "DALCOCK"}, "text": "/* REXX\n |\n | Name: LASTREF\n |\n | Author: David Alcock\n |\n | Purpose: Display the last use/reference information that the DMS\n |          DASD Management System (program product from Sterling\n |          Software) places in the Format 1 DSCB.\n |\n | Dependencies: DMS (Sterling Software) SVC and LISTDS (IBM) output\n |               format\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1992-2002+ by David Alcock\n |             All rights reserved.\n */\narg dsn volser\n\nif dsn == \"\" then do\n   say \"%LASTUSE - No dataset given\"\n   exit\n   end\n\nif volser <> \"\" then do\n   address TSO \"ALLOCATE FILE(LASTUSE) DA(\"dsn\") \" ,\n               \"UNIT(SYSALLDA) VOLUME(\"volser\") SHR REUSE\"\n   arc = rc\n   if arc <> 0 then do\n      say \"%LASTUSE - Error allocating dataset:\"\n      say \"> DSN=\"dsn\n      say \"> VOLSER=\"volser\n      exit\n      end\n   end\n/*\n **** Invoke the LISTDS (IBM TSO COMMAND) to obtain info\n */\n\ncall \"OUTTRAP\" \"listds_line.\",\"*\"\naddress TSO \"LISTDS \"dsn \"LABEL\"\nlistds_rc = rc\ncall \"OUTTRAP\" \"OFF\"\n\n/*\n **** If there were problems in LISTDS, display output and term\n */\n\nif listds_rc <> 0 then do\n   do i = 1 to listds_line.0\n      say listds_line.i\n      end\n   exit\n   end\n\n/*\n **** If the dataset is not fully qualified, make it so\n */\n\nif substr(dsn,1,1) <> \"'\" then do\n   x = LISTDSI(dsn)\n   if x = 0 then dsn = SYSDSNAME\n   else do\n        say sysdsn(dsn)\n        exit\n        end\n   end\n\n/*\n **** Skip thru the output from LISTDS and look for the F1 DSCB\n */\n\naddress TSO \"CLRSCRN\"\ndo i = 1 to listds_line.0\n   if word(listds_line.i,1) == \"F1\" then do\n      parse value listds_line.i with \"F1 \" volume \" \" trash1 \" \",\n                  trash2 \" \" trash3 \" \" trash4 \" \" trash5 \" \",\n                  trash6 \" \" dms1 .\n      j = i + 1\n      parse value listds_line.j with dms2 \" \" trash1 \" \" trash2 \" \",\n                  trash3 \" \" trash4 \" \" trash5 \" \" trash6 \" \",\n                  trash7 \" \" trash8 \" \" trash9 \" \" trash10 \" \",\n                  trash11 \" \" dms3 .\n\n      if substr(dms3,1,1) <> \"F\" then do\n         say \"Last reference information not available for \"dsn\n         exit\n         end\n      dms2 = substr(dms2,1,6)\n\n      say \"Dataset name . . . . .\"dsn\n      say \"Last used Jobname. . .\"x2c(substr(dms1,1,16))\n      say \"Last Used Date . . . .\"dscbdate(dms2)\n\n      end\n   end\nif volser <> \"\" then ,\n   address TSO \"FREE FILE(LASTUSE)\"\nexit 0\n/*-------------------------------------------------------------------*/\n/* The following routine was taken from Doug Nadel's DSCB command    */\n/* which had the following comment:                                  */\n/*                                                                   */\n/* Thanks to Gary Gindler ggindler@yahoo.com for date code!          */\n/*-------------------------------------------------------------------*/\n/* GG */\ndscbdate: Procedure\n\n Arg dscb_date\n If dscb_date=\"000000\" Then Return dscb_date\n yyyy = x2d(substr(dscb_date,1,2)) + 1900\n ddd  = x2d(substr(dscb_date,3,4))\n\n jul_date = yyyy||.||right(ddd,3,'0')\n yyyy_0101 = yyyy || 0101\n base_date = date('B',yyyy_0101,'S') + ddd - 1\n normal_date = date('N',base_date,'B')\n days_ago = date('B') - base_date\n date_string = jul_date normal_date \"(\"\n If days_ago >= 0 Then\n   date_string = date_string||days_ago \"days ago)\"\n Else\n   date_string = date_string||abs(days_ago) \"days from today)\"\n\n Return date_string\n/* GG */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MPFEXITS": {"ttr": 24324, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x00 \\x00\\x99\\x06\\x0f\\x01\\x020o\\x18B\\x05h\\x05j\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:42:20", "lines": 1384, "newlines": 1386, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$README  0102-98240-98240-1449-00042-00018-00000-DALCOCK\n\n The contents of this file are FREEWARE. Use at your own risk. It\n is provided for your enjoyment and neither David Alcock or his\n employer provides any warranty for their use.  I'd like to hear how\n they work on your system:\n\n    David Alcock :: dave@planetmvs.com\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nShort description of the MPF exits I use at my shop:\n\nDA$MPF01 - Append the current date to the message passed\nDA$MPF02 - Answer WTOR with \"W\"\nDA$MPF03 - Makes message IEF450I IEF451I IEF452I\n           and IEF453I desc=2 for production jobs.\n           this prevents 'job abend' and 'jcl\n           error' messages from rolling off\n           the console for production jobs.\nDA$MPF04 - Reply \"M\" to IEC709I\nDA$MPF05 - Suppress WTO from JES2 JOB LOG - It will still go to the\n           SYSLOG\nDA$MPF06 - Answer \"U\" to a WTOR\nDA$MPF07 - Answer \"BYPASS\" to a WTOR\nDA$MPF08 - Notify user in real time of a critical WTO message from a\n           batch job that he submitted.\nDA$MPF09 - Put a message in the JOB LOG when message CSV019I is for\n           an ABENDAID module.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n3 of the MPF exits use Enter and Exit housekeeping macros: DA#ENTER\nand DA#LEAVE.  Either obtain them from:\n\n   . File 311 on the CBT tape version 418 or higher in the DASRC member\n   . http://www.ticnet.com/davea/mvs/freeware/dasrc.zip\n\nor replace with your favorite macro that does this or with straight\nassembler.  DA$MPF08 is a newer MPF exit that uses ESA housekeeping\nentry and exit assembler code (no macro) that you could insert into\nthe ones that use the macro.\n./ ADD NAME=DA$MPF01 0102-97056-98240-1033-00270-00259-00000-DALCOCK\nDA$MPF01 TITLE '                     Append the date to some messages'\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = DA$MPF01                                   **\n**                                                                   **\n**    Descriptive Name  = Append the current date to some messages.  **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Activated by      = Specifed in active MPF member of Parmlib:  **\n**                        - SET MPF=XX                               **\n**                        - WHERE XX IS A MEMBER IN PARMLIB:         **\n**                          'SYS1.PARMLIB(MPFLSTXX)'                 **\n**                        - REFERENCE IN MPFLSTXX:                   **\n**                       IEF403I,SUP(NO),USEREXIT(DA$MPF01)          **\n**                       IEF404I,SUP(NO),USEREXIT(DA$MPF01)          **\n**                      $HASP373,SUP(NO),USEREXIT(DA$MPF01)          **\n**                      $HASP395,SUP(NO),USEREXIT(DA$MPF01)          **\n**                                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**                                                                   **\n**    Change:                                                        **\n**                                                                   **\n**      IEF403I DALCOCKP - STARTED - TIME=16.38.17                   **\n**      IEF404I DALCOCKP - ENDED - TIME=16.38.23                     **\n**                                                                   **\n**    To:                                                            **\n**                                                                   **\n**      IEF403I DALCOCKP - STARTED - TIME=16.38.17 - 25-FEB-1997     **\n**      IEF404I DALCOCKP - ENDED - TIME=16.38.23 - 25-FEB-1997       **\n**                                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**                                                                   **\n**  If \"MONITOR JOBNAMES\" is not active, then we update these as     **\n**  well:                                                            **\n**                                                                   **\n**      $HASP373 DALCOCKZ STARTED - INIT    1 - CLASS U - SYS DA$5   **\n**      $HASP395 DALCOCKZ ENDED                                      **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         IEZVX100 ,                       WTO exit parameter list\n         PRINT NOGEN\n         IHAPSA ,                         Prefixed Save Area\n         IHAASCB ,                        Address Space Control Block\n         IHAASSB ,                        ASCB Secondard block\n         IAZJSAB ,                        Job Schedular Address spc\n         YREGS ,                          Equate registers to R0-R15\n         PRINT GEN\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY/MM/DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Intialization                                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDA$MPF01 CSECT ,\nDA$MPF01 AMODE 31\nDA$MPF01 RMODE ANY\n*\n** Create a standard O/S eyecatcher\n*\nEC       B     ECL(0,R15)               Bump past Eyecatcher\n         DC    AL1(L'ECLIT)             Length of eyecatcher\nECLIT    DC    C'DA$MPF01 &ASMDATE &SYSTIME - Echo message to TSO user'\n         DS    0H                       Ensure halfword alignment\nECL      EQU   *-EC\n*\n** Standard ESA entry housekeeping\n*\n         BAKR R14,0                     Save regs\n         LAE   R12,0(R15,0)             Get base register\n         USING DA$MPF01,R12             Get addressibility\n         SAC  0\n         SYSSTATE ASCENV=P\n         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage\n         LR   R13,R1                    Point to Save Area\n         MVC  4(4,R13),=C'F1SA'         Indicate stack SA\n         USING WORKDS,R13               Get addressibility to area\n*\n** Locate MPF exit parameter list and message area\n*\n         EREG  R0,R1                    Restore regs 0 and 1\n         L     R2,0(R1)                 Get CTXT Address\n         ICM   R3,B'1111',CTXTTXPJ-CTXT(R2) Locate Major\n         BZ    EXIT                     Shouldn't happen, but leave\n*\n** See we want to touch these guys\n*\n         TM    CTXTMTY1-CTXT(R2),CTXTMTYA  Monitor jobnames active?\n         BNO   TEST$X                   No, hit the JES2 start/stop\n         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'$HASP373'\n         BE    EXIT\n         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'$HASP395'\n         BE    EXIT\nTEST$X   DS    0H\n*\n** Append the current date onto the end of the message\n*\n         TIME  BIN                      Get current time and date\n         STM   R0,R1,DOUBLE             Save time and date\n         LA    R15,CTXTTMSG-CTXTATTR(R3) Locate to start of message\n         SLR   R14,R14                  Clear register\n         ICM   R14,B'0011',CTXTTLEN-CTXTATTR(R3) Get length\n         AR    R15,R14\n         MVC   0(3,R15),=C' - '\n         LA    R15,3(R15)\n         LM    R0,R1,DOUBLE             Save time and date\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\n         LA    R14,CTXTTMSG-CTXTATTR(R3) Locate to start of message\n         SR    R15,R14\n         STCM  R15,B'0011',CTXTTLEN-CTXTATTR(R3) Set new length\n         OI    CTXTRFB1-CTXT(R2),CTXTRCMT  Say we changed it\n*\n** Release resources and return to caller\n*\nEXIT     DS    0H\n         LR    R2,R13                     Get storage address\n         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage\n         SLR   R15,R15                    Set return code\n         PR                               Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n** Convert input binary time and packed decimal julian date to a     **\n** fancy output string of \"dd-mmm-ccyy hh:mm:ss pm\"                  **\n**                                                                   **\n** Input: R0 - Time in binary                                        **\n**        R1 - Date in packed decimal                                **\n**        R15 - points to the output area                            **\n**                                                                   **\n** Output: the area in R15 will be filled in and R15 updated with    **\n**         address just past the filled in area.                     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nCONVERT_TO_TODSTRING DS 0H\n         ST    R15,CTT_OUT                Save output area address\n         ST    R14,CTT_RA                 Save return address\n*\n** Get the input time (binary) and date (packed decimal) and convert\n** it to a STCK TOD format\n*\n         LA    R14,CTT_CIN                Locate routine Time/Date area\n         XC    0(CTAREAL,R14),0(R14)      Clear to binary zeros\n         STCM  R0,B'1111',CTAREA_TIME-CTAREA(R14) Save Time\n         STCM  R1,B'1111',CTAREA_DATE-CTAREA(R14) Save Date\n*\n         CONVTOD CONVVAL=CTT_CIN,         Convert this Time/Date       @\n               TODVAL=CTT_TOD,            ..To TOD format              @\n               TIMETYPE=BIN,              ..Time is binary format      @\n               DATETYPE=YYDDD,            ..Date is julian 0CYYDDDf    @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    CONVTOD worked?\n         BNZ   CTT$JUL                    Failed, do primitive way\n*\n** Convert the TOD stamp into time and date formats\n*\n         STCKCONV STCKVAL=CTT_TOD,        Convert this TOD Stamp       @\n               CONVVAL=CTT_SOUT,          ..Into these date/time areas @\n               TIMETYPE=DEC,              ..Output time format         @\n               DATETYPE=DDMMYYYY,         ..Output Date format         @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    CONVTOD worked?\n         BNZ   CTT$JUL                    Failed, do primitive way\n*\n** Format the date\n*\n         L     R15,CTT_OUT                Locate output area\n*                               D  D  -  M  M  -  C  C  Y  Y\n         MVC   0(11,R15),=X'40,20,20,60,20,20,60,20,20,20,20'\n         ED    0(11,R15),CTT_SOUT+8       Edit it to \" dd-mm-ccyy\"\n         MVC   0(3,R15),1(R15)            Move \"dd-\" over \"dd-...-ccyy\"\n         PACK  DOUBLE(8),4(2,R15)         Get month in decimal\n         CVB   R14,DOUBLE                 Convert to binary\n         BCTR  R14,0                      Make relative to zero\n         MH    R14,=H'3'                  Multiply for month offset\n         LA    R1,=C'JanFebMarAprMayJunJulAugSepOctNovDec'\n         AR    R1,R14                     Locate month entry\n         MVC   3(3,R15),0(R1)             Move \"mmm\" to \"dd-mmm-ccyy\"\n         OI    0(R15),X'F0'               Ensure leading zero\n         LA    R15,11(R15)                Bump past date\n*\n         MVC   0(3,R15),=C' - '\n         LA    R15,3(R15)\nCTT$JUL  DS    0H\n         UNPK  DOUBLE2(9),#CTTPMD(5)           *\n         MVZ   DOUBLE2(8),=8X'00'              ** Hex convert\n         TR    DOUBLE2(8),=C'0123456789ABCDEF' *\n*\n         CLI   #CTTPMD,0                  Century = 19xx?\n         BE    CTT$Y19\n         CLI   #CTTPMD,1                  Century = 20xx?\n         BE    CTT$Y20\n         CLI   #CTTPMD,2                  Century = 21xx?\n         BNE   CTT$YX\n         MVC   0(2,R15),=C'22'\n         LA    R15,2(R15)\n         B     CTT$YX\nCTT$Y19  DS    0H\n         MVC   0(2,R15),=C'19'\n         LA    R15,2(R15)\n         B     CTT$YX\nCTT$Y20  DS    0H\n         MVC   0(2,R15),=C'20'\n         LA    R15,2(R15)\nCTT$YX   DS    0H\n         MVC   0(2,R15),DOUBLE2+2         Get yy from \"0cyydddf\"\n         MVI   2(R15),C'.'                Insert dot\n         MVC   3(3,R15),DOUBLE2+4         Get ddd from \"0cyydddf\"\n         LA    R15,6(R15)                 Locate past \"yy.ddd'\n         L     R14,CTT_RA                 Get return address\n         BSM   0,R14                      Return to caller\n#CTTPMD  EQU   CTT_CIN+(CTAREA_DATE-CTAREA)    Generate offset\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LTORG ,\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAINed work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                    Register Save Area\nDOUBLE   DS    D\nDOUBLE2  DS    2D\nPARMLIST DS    10F\n         DS    0D\nCTT_TOD  DS    D                        ..TOD (STCK) area\nCTT_OUT  DS    F                        ..Output area address\nCTT_RA   DS    F                        ..Return address\nCTT_CIN  DS    XL(CTAREAL)              ..CONVTOD input area\nCTT_SOUT DS    XL16                     ..STCKCON output area\n         DS    0D\nWORKDSL  EQU   *-WORKDS\n*\n** Map CONVTOD area\n*\nCTAREA          DSECT ,\nCTAREA_TIME     DS    XL4\n                DS    XL4\nCTAREA_DATE     DS    XL4\n                DS    XL4\nCTAREAL         EQU   *-CTAREA\n         END\n./ ADD NAME=DA$MPF02 0104-91360-98240-1443-00119-00119-00000-DALCOCK\nDA$MPF02 TITLE '                  Answer WTOR with \"W\" '\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = DA$MPF02                                   **\n**                                                                   **\n**    Descriptive Name  = Communications task user exit to answer    **\n**                        WTORs with \"W\"                             **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Activated by      = SET MFP=XX  (MVS operator command)         **\n**                        - Where XX is a member in 'SYS1.PARMLIB':  **\n**                          'SYS1.PARMLIB(MPFLSTXX)'                 **\n**                        - REFERENCE IN MPFLSTXX:                   **\n**                       ERB306D,SUP(NO),USEREXIT(DA$MPF02)          **\n**                       CICS...,SUP(NO),USEREXIT(DA$MPF02)          **\n***                                                                 ***\n***********************************************************************\n         EJECT\nDA$MPF02 DA#ENTER 'WTO EXIT: REPLY W TO A WTOR',                       @\n               AMODE=31,RMODE=ANY,                                     @\n               RENT=YES,LV=WORKDSL,SP=230,GMTYPE=RU,LOC=BELOW\n         USING WORKDS,R13\n*\n         L     R2,0(R1)                   Get CTXT Address\n         L     R3,CTXTTXPJ-CTXT(R2)       Find Message attributes\n         TM    CTXTTFB1-CTXTATTR(R3),CTXTTFWR  WTOR?\n         BNO   EXIT                       No, ignore it\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Reply to the WTOR with a \"W\"                                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Issue WTO message for an Audit Trail\n*\n         LA    R15,WTO                    Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Copy in WTO\n         LA    R15,4(R15)                 Bump past header\n         MVC   0(MSG1L,R15),MSG1          Move in message\n         LA    R15,MSG1L(R15)             Bump past it\n         MVC   0(2,R15),CTXTRPID-CTXT(R2) Get reply number\n         WTO   ,MF=(E,WTO)                Issue the WTO\n*\n** Answer the WTOR: \"R xx,W\"\n*\n         LA    R14,REPLY                 Locate reply area\n         XC    0(MGCRLTH,R14),0(R14)     Clear it to binary zeros\n*\n         LA    R15,MGCRTEXT-MGCRPL(R14)  Locate reply area\n         MVC   0(2,R15),=C'R '           Move in Text\n         LA    R15,2(R15)                Bump past it\n         MVC   0(2,R15),CTXTRPID-CTXT(R2) Get reply number\n         LA    R15,2(R15)                Bump past the number\n         MVC   0(2,R15),=C',W'           Complete the message\n         LA    R15,2(R15)                Bump past the suffix\n*\n         SR    R15,R14                   Length = end - Beginning\n         STC   R15,MGCRLGTH-MGCRPL(R14)  Save length\n*\n         SLR   R0,R0                     Clear register\n         MGCR  REPLY                     Issue reply\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Termination section                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n         DA#LEAVE SP=230,FMTYPE=RU\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSG1     DC    C'DA$202I WTOR Answered with W, Reply='\nMSG1L    EQU   *-MSG1\n         DS    0D\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               ROUTCDE=(11,14),DESC=7,MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\n*\n** Literals\n*\n         LTORG ,\n         DS    0D\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Getmained work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                    Register Save Area\nREPLY    DS    XL(MGCRLTH)            Reply (operator command)\nWTO      DS    XL(C_WTOL)             Write to operator\n         DS    0D\nWORKDSL  EQU   *-WORKDS\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Equates and DSECTs                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         REQUATE ,                    Equate our registers\n         IEZVX100 ,                   WTO User WTO exit parm list\n         IEZMGCR  DSECT=NO            SVC 34 Parameter List\n         END\n./ ADD NAME=DA$MPF03 0103-92113-98240-1440-00096-00093-00000-DALCOCK\nDA$MPF03 TITLE 'Change selected message route codes'\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = DA$MPF03                                   **\n**                                                                   **\n**    Descriptive Name  = Change route codes                         **\n**                                                                   **\n**    Functions         = To Wit:                                    **\n**                        - MAKES MESSAGE IEF450I IEF451I IEF452I    **\n**                          AND IEF453I DESC=2 FOR PRODUCTION JOBS.  **\n**                          THIS PREVENTS 'JOB ABEND' AND 'JCL       **\n**                          ERROR' MESSAGES FROM ROLLING OFF THE FOR **\n**                          A PRODUCTION JOB.  A PRODUCTION JOB IS   **\n**                          ANY JOB THAT DOES NOT HAVE 'TSO' IN      **\n**                          POSITIONS 2 TO 4 OF THE JOB NAME AND     **\n**                          DOES HAVE A 'D' IN POSITION 1 OF THE JOB **\n**                          NAME MEANING DALLAS JOBS.  IT ALSO       **\n**                          CHANGES THE ROUTE CODE TO (1,2,3,4).     **\n**                          IEF451I IS A CONDTION CODE MESSAGE.  THE **\n**                          CONDTION CODE HAS TO BE IN THE JOBCARD   **\n**                          FOR THIS MESSAGE TO BE PRODUCED.  IF A   **\n**                          CONDITION CODE IS SATISFIED ON AN EXEC   **\n**                          CARD, FLUSH MESSAGES WILL BE ISSUED AND  **\n**                          NOT IEF451I, PREVENTING THIS EXIT FROM   **\n**                          CHANGING ROUTE AND DESCRIPTOR.           **\n**                                                                   **\n**                        - IT ALSO CHANGES THE SPOOL OFFLOAD        **\n**                          WRITER WAITING FOR MESSAGE 'IEF176I'     **\n**                          TO BE HIGH-LIGHTED.                      **\n**                                                                   **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Activated by      = SET MFP=XX  (MVS operator command)         **\n**                        - Where XX is a member in 'SYS1.PARMLIB':  **\n**                          'SYS1.PARMLIB(MPFLSTXX)'                 **\n**                        - REFERENCE IN MPFLSTXX:                   **\n**                          IEF176I,SUP(NO),USEREXIT(DA$MPF03)       **\n**                          IEF450I,SUP(NO),USEREXIT(DA$MPF03)       **\n**                          IEF451I,SUP(NO),USEREXIT(DA$MPF03)       **\n**                          IEF452I,SUP(NO),USEREXIT(DA$MPF03)       **\n**                          IEF453I,SUP(NO),USEREXIT(DA$MPF03)       **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***\n**           M o d i f i c a t i o n   H i s t o r y\n**\n** Person     Date        Description\n** ---------- ----------- ------------------------------------------\n** DGAlcock   28-AUG-1998 For CBT tape and Internet distribution,\n**                        our installation checks were disabled,\n**                        See the lines marked \"*Check->\";\n** DGAlcock   22-APR-1992 Changed from IEAVMXT1 to new DA$MPF03 name;\n***\n***********************************************************************\nDA$MPF03 CSECT\nDA$MPF03 RMODE ANY\nDA$MPF03 AMODE 31\n         SAVE  (14,12),,DA$MPF03_&SYSDATE._&SYSTIME\n         LR    R10,R15          R10 = BASE REG\n         USING DA$MPF03,R10\n*\n** Locate control blocks\n*\n         L     R1,0(,R1)        R1 ---> ADDRESS OF CTXT PARAMETER LIST\n         L     R2,8(,R1)        R2 ---> ADDRESS OF TEXT OF MESSAGE\n         L     R3,36(,R1)       R3 ---> ADDRESS OF DESCRIPTOR CODES\n         L     R4,32(,R1)       R4 ---> ADDRESS OF ROUTE CODES\nIEAVM020 DS    0H\n*Check-> CLC   15(3,R2),=C'TSO'     IS THIS A TEST JOB ?\n*Check-> BE    IEAVM100             YES DO NOT PROCESS.\n*Check-> CLC   14(3,R2),=C'WTR'     IS THIS A SPOOL OFFLOAD MSG?\n*Check-> BE    IEAVM030             YES PROCESS.\n*Check-> CLC   14(1,R2),=C'D'       IS THIS A DALLAS JOB ?\n*Check-> BNE   IEAVM100             NO - DO NOT PROCESS.\n         MVI   48(R1),B'01100000'   NOTIFY TO CHANGE DESCRIPTOR & ROUTE\n         OI    0(R4),X'F0'          SET ALL ROUTE CODES (1,2,3,4)\n         MVI   0(R3),B'01000000'    SET DESC=2\n         B     IEAVM100             YES DO NOT PROCESS.\nIEAVM030 MVI   48(R1),B'01100000'   NOTIFY TO CHANGE DESCRIPTOR & ROUTE\n         OI    0(R4),X'F0'          SET ALL ROUTE CODES (1,2,3,4)\n         MVI   0(R3),B'01000000'    SET DESC=2\nIEAVM100 DS    0H\n*\n** Return to caller\n*\n         RETURN (14,12)             SET UP RETURN\n*\n** Data constants\n*\n         LTORG ,\n         YREGS ,                    Register Equates\n         END\n./ ADD NAME=DA$MPF04 0103-92123-98240-1034-00136-00096-00000-DALCOCK\n*   DATA SET DA$ IEAVMSIT AT LEVEL 001 AS OF 05/16/86\n   TITLE '  *** DA$MPF04   OS/VS2 MVS TAPE INIT WTOR RESPONSE EXIT '\n***********************************************************************\n*   DA$MPF04                                                          *\n*                                                                     *\n*       THIS EXIT SCANS ALL WTO THAT GO THROUGH MPF.  MPFLST00        *\n*       IN SYS1.PARMLIB CONTAINES THE MESSAGES TO BE SCANNED AND      *\n*       THE EXIT TO TAKE.                                             *\n*                                                                     *\n*       THIS ROUTINE:                                                 *\n*                                                                     *\n*         1.  REPLYS TO MESSAGE IEC709I WTOR FOR A TMS TAPE INIT.     *\n*             IT WILL REPLY 'M' TO ALL IEC709I MESSAGES ISSUED        *\n*             BY INIT JOB.                                            *\n*                                                                     *\n*         2.  MVS/XA SPL USER EXITS GC28-1147-3  P49-54               *\n*                                                                     *\n*                                                                     *\n***********************************************************************\nDA$MPF04 CSECT\nDA$MPF04 RMODE ANY\nDA$MPF04 AMODE 31\nREG0     EQU   0\nREG1     EQU   1\nREG2     EQU   2\nREG3     EQU   3\nREG4     EQU   4\nCTXTPTR  EQU   5\nREG11    EQU   11\nREG12    EQU   12\nREG13    EQU   13\nREG14    EQU   14\nREG15    EQU   15\nSPINPRVT EQU   230\n         STM   REG14,REG12,12(REG13)\n         BALR  REG12,REG0       ESTABLISH MODULE BASE\n         USING *,REG12          REGISTER\n         L     CTXTPTR,0(REG1) EXTABLISH ADDRESSABILITY\n         USING CTXT,CTXTPTR    TO THE CTXT\n***************************************************************\n*        DYNAMIC STORAGE FOR THIS MODULE IS BEING OBTAINED BELOW\n*        THE 16-MEG LINE BECAUSE SVC 34 REQUIRES THE MGCR PARAMETER\n*        LIST TO BE IN 24-BIT ADDRESSABLE STORAGE.\n***************************************************************\n         GETMAIN  RU,LV=DATAEND,SP=SPINPRVT,LOC=BELOW  OBTAIN DYNAMIC\n*                                                      STORAGE\n         LR    REG11,REG1       ADDRESS RETURNED IN REG1\n         USING DATAAREA,REG11  ADDRESSABILITY TO DYNAMIC STORAGE\n         ST    REG13,SAVEAREA+4 SET BACKWARD PTR\n         LA    REG15,SAVEAREA   GET ADDRESS OF SAVE AREA\n         ST    REG15,8(REG13)   SET FORWARD PTR\n         LR    REG13,REG15      SET REG13 TO POINT TO STANDARD\n*                               SAVE AREA\n*\n***************************************************************\n*        PICK OUT MESSAGE IEC701D\n***************************************************************\n*\n         L     REG2,CTXTTXPJ    EXTABLISH ADDRESSABILITY\n         USING CTXTATTR,REG2    TO THE MSG ATTRIBUTES\n         LA    REG4,CTXTTMSG    ADDRESS OF TEXT AREA\n         USING MSGTEXT,REG4     BASE TEST MAPPING\n         CLC   MSGID,IEC701D    MESSAGE IEC701D\n         BNE   FINISHED         NOT IEC701D\n*\n***************************************************************\n*        WORKING WITH MESSAGE IEC701D THEREFORE REPLY TO THE\n*        MESSAGE.\n***************************************************************\n*\nMSG701D  EQU   *\n         BAL   REG14,ISSUMGCR   REPLY TO IEC701D 'XX,M'\n*\n***************************************************************\n*        STANDARD EXIT LINKAGE\n***************************************************************\n*\nFINISHED EQU   *\n         L     REG13,4(REG13)   RESTORE REG13\n         FREEMAIN  RU,LV=DATAEND,A=(REG11),SP=SPINPRVT FREE THE STORAGE\n         LM    REG14,REG12,12(REG13)   RESTORE CALLER'S REGISTERS\n         BR    REG14             RETURN TO CALLER\n*\n***************************************************************\n*        PROCEDURE: ISSUMSGCR\n*        FUNCTION:  REPLIES TO MESSAGE IEC701D WITH 'M'\n*        INPUT:     NONE\n*        OUTPUT:    A REPLY COMMAND IS ISSUED VIA SVC 34\n*        NOTES:     THE MGCR MACRO CAN BE USED TO ISSUE A REPLY CMD.\n***************************************************************\n*\nISSUMGCR EQU   *\n         XC    MGCRPL(MGCRLTH),MGCRPL  CLEAR THE PARAMETER LIST\n         MVC   MGCRTEXT(L'TXTINSRT),TXTINSRT  MOVE IN THE REPLY BUFFER\n         MVC   REPLY,CTXTRPID          INSERT THE REPLY ID\n         LA    REG1,(MGCRTEXT-MGCRPL)+L'TXTINSRT    GET MGCRPL LENGTH\n         STC   REG1,MGCRLGTH          SAVE LENGTH IN THE MGCRPL\n         SR    REG0,REG0              CLEAR REGISTER ZERO\n         MGCR  MGCRPL                 ISSUE THE COMMAND\n         BR    REG14                  RETURN TO CALLER\n*\n***************************************************************\n*        CHARACTER CONSTANTS\n***************************************************************\n*\nIEC701D  DC    CL8'IEC701D '          MESSAGE IEC701D\nTXTINSRT DC    CL10'REPLY XX,M'      WROR REPLY\n*\n***************************************************************\n*        STORAGE DEFINITIONS\n***************************************************************\n*\nDATAAREA DSECT\n         DS    0F\nSAVEAREA DS    18F              STANDARD SAVE AREA\n         DS    0F\nMGCR     IEZMGCR  DSECT=NO\n         ORG   MGCRTEXT\nCOMMAND  DS    CL6              THE REPLY COMMAND\nREPLY    DS    CL2              REPLY ID\nREPLYMSG DS    CL1              WTOR RESPONSE\n         ORG\nDATAEND  EQU   *-DATAAREA\n*\n***************************************************************\n*        MAPPING OF THE MESSAGE TEXT\n***************************************************************\n*\nMSGTEXT  DSECT\nMSGID    DS    CL8              MESSAGE ID\nJOBDATA  DS    CL8              JOB DATA(ID AND NAME)\n         ORG   MSGTEXT\n         DS    CL4\nWTORID   DS    CL8\n         IEZVX100\n         END   DA$MPF04\n./ ADD NAME=DA$MPF05 0102-92267-92284-1329-00057-00071-00000-DALCOCK\nXYZMPF05 TITLE 'Suppress WTO on the JES2 JOB LOG'\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = XYZMPF05                                   **\n**                                                                   **\n**    Descriptive Name  = Suppress WTO from JES2 JOB LOG             **\n**                                                                   **\n**                        The message will still go to the SYSLOG.   **\n**                                                                   **\n**                        ** You must be at JES2 3.1.3 or higher **  **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Activated by      = Specifed in active MPF member of Parmlib:  **\n**                        - SET MPF=XX                               **\n**                        - Where XX is a member in SYS1.PARMLIB as  **\n**                          in 'SYS1.PARMLIB(MPFLSTXX)'              **\n**                        - Reference IN MPFLSTXX:                   **\n**                       XYZ106I,SUP(NO),USEREXIT(XYZMPF05)          **\n**                       XYZ107I,SUP(NO),USEREXIT(XYZMPF05)          **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         EJECT\nXYZMPF05 CSECT ,\nXYZMPF05 AMODE 31\nXYZMPF05 RMODE ANY\n*\n** Entry Housekeeping\n*\n         SAVE  (14,12),,XYZMPF05_WTOEXIT_SUPJESLOG_&SYSDATE._&SYSTIME\n         LR    R12,R15                    Load Base register\n         USING XYZMPF05,R12               Get CSECT addressability\n         L     R2,0(R1)                   Get CTXT Address\n*\n** Check for any exceptions\n*\n         CLC   CTXTJBNM-CTXT(8,R2),=CL8'DALCOCKZ' Special job?\n         BE    EXIT                       Yes, skip suppression\n*\n** Set flag to suppress the message from the JES JOB Log\n*\n         OI    CTXTERF3-CTXT(R2),CTXTESJL Suppress that puppy\n*\n** Exit Housekeeping\n*\nEXIT     EQU   *\n         RETURN (14,12),RC=0              Return to caller\n*\n** Literals and DSECTs\n*\n         LTORG ,                          Literals used in XYZMPF05\n         DS    0D                         End of XYZMPF05 WTO exit\n         YREGS ,                          Generate register equates\n         IEZVX100 ,                       Commun. Task User exit parms\n         END   ,\n./ ADD NAME=DA$MPF06 0103-92137-98240-1442-00118-00118-00000-DALCOCK\nDA$MPF06 TITLE '                  Answer WTOR with \"U\" '\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = DA$MPF06                                   **\n**                                                                   **\n**    Descriptive Name  = Communications task user exit to answer    **\n**                        WTORs with \"U\"                             **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Activated by      = SET MFP=XX  (MVS operator command)         **\n**                        - Where XX is a member in 'SYS1.PARMLIB':  **\n**                          'SYS1.PARMLIB(MPFLSTXX)'                 **\n**                        - REFERENCE IN MPFLSTXX:                   **\n**                       ICK003D,SUP(NO),USEREXIT(DA$MPF06)          **\n***                                                                 ***\n***********************************************************************\n         EJECT\nDA$MPF06 DA#ENTER 'WTO EXIT: REPLY U TO A WTOR',                       @\n               AMODE=31,RMODE=ANY,                                     @\n               RENT=YES,LV=WORKDSL,SP=230,GMTYPE=RU,LOC=BELOW\n         USING WORKDS,R13\n*\n         L     R2,0(R1)                   Get CTXT Address\n         L     R3,CTXTTXPJ-CTXT(R2)       Find Message attributes\n         TM    CTXTTFB1-CTXTATTR(R3),CTXTTFWR  WTOR?\n         BNO   EXIT                       No, ignore it\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Reply to the WTOR with a \"W\"                                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Issue WTO message for an Audit Trail\n*\n         LA    R15,WTO                    Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Copy in WTO\n         LA    R15,4(R15)                 Bump past header\n         MVC   0(MSG1L,R15),MSG1          Move in message\n         LA    R15,MSG1L(R15)             Bump past it\n         MVC   0(2,R15),CTXTRPID-CTXT(R2) Get reply number\n         WTO   ,MF=(E,WTO)                Issue the WTO\n*\n** Answer the WTOR: \"R xx,U\"\n*\n         LA    R14,REPLY                 Locate reply area\n         XC    0(MGCRLTH,R14),0(R14)     Clear it to binary zeros\n*\n         LA    R15,MGCRTEXT-MGCRPL(R14)  Locate reply area\n         MVC   0(2,R15),=C'R '           Move in Text\n         LA    R15,2(R15)                Bump past it\n         MVC   0(2,R15),CTXTRPID-CTXT(R2) Get reply number\n         LA    R15,2(R15)                Bump past the number\n         MVC   0(2,R15),=C',U'           Complete the message\n         LA    R15,2(R15)                Bump past the suffix\n*\n         SR    R15,R14                   Length = end - Beginning\n         STC   R15,MGCRLGTH-MGCRPL(R14)  Save length\n*\n         SLR   R0,R0                     Clear register\n         MGCR  REPLY                     Issue reply\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Termination section                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n         DA#LEAVE SP=230,FMTYPE=RU\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSG1     DC    C'DA$2XXI WTOR Answered with U, Reply='\nMSG1L    EQU   *-MSG1\n         DS    0D\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               ROUTCDE=(11,14),DESC=7,MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\n*\n** Literals\n*\n         LTORG ,\n         DS    0D\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Getmained work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                    Register Save Area\nREPLY    DS    XL(MGCRLTH)            Reply (operator command)\nWTO      DS    XL(C_WTOL)             Write to operator\n         DS    0D\nWORKDSL  EQU   *-WORKDS\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Equates and DSECTs                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         REQUATE ,                    Equate our registers\n         IEZVX100 ,                   WTO User WTO exit parm list\n         IEZMGCR  DSECT=NO            SVC 34 Parameter List\n         END\n./ ADD NAME=DA$MPF07 0103-96032-98240-1443-00118-00118-00000-DALCOCK\nDA$MPF07 TITLE '                  Answer WTOR with \"BYPASS\" '\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = DA$MPF07                                   **\n**                                                                   **\n**    Descriptive Name  = Communications task user exit to answer    **\n**                        WTORs with \"BYPASS\"                        **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Activated by      = SET MFP=XX  (MVS operator command)         **\n**                        - Where XX is a member in 'SYS1.PARMLIB':  **\n**                          'SYS1.PARMLIB(MPFLSTXX)'                 **\n**                        - REFERENCE IN MPFLSTXX:                   **\n**                       IECTMS0,SUP(NO),USEREXIT(DA$MPF07)          **\n***                                                                 ***\n***********************************************************************\n         EJECT\nDA$MPF07 DA#ENTER 'WTO EXIT: REPLY U TO A WTOR',                       @\n               AMODE=31,RMODE=ANY,                                     @\n               RENT=YES,LV=WORKDSL,SP=230,GMTYPE=RU,LOC=BELOW\n         USING WORKDS,R13\n*\n         L     R2,0(R1)                   Get CTXT Address\n         L     R3,CTXTTXPJ-CTXT(R2)       Find Message attributes\n         TM    CTXTTFB1-CTXTATTR(R3),CTXTTFWR  WTOR?\n         BNO   EXIT                       No, ignore it\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Reply to the WTOR with a \"BYPASS\"                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Issue WTO message for an Audit Trail\n*\n         LA    R15,WTO                    Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Copy in WTO\n         LA    R15,4(R15)                 Bump past header\n         MVC   0(MSG1L,R15),MSG1          Move in message\n         LA    R15,MSG1L(R15)             Bump past it\n         MVC   0(2,R15),CTXTRPID-CTXT(R2) Get reply number\n         WTO   ,MF=(E,WTO)                Issue the WTO\n*\n** Answer the WTOR: \"R xx,BYPASS\"\n*\n         LA    R14,REPLY                 Locate reply area\n         XC    0(MGCRLTH,R14),0(R14)     Clear it to binary zeros\n*\n         LA    R15,MGCRTEXT-MGCRPL(R14)  Locate reply area\n         MVC   0(2,R15),=C'R '           Move in Text\n         LA    R15,2(R15)                Bump past it\n         MVC   0(2,R15),CTXTRPID-CTXT(R2) Get reply number\n         LA    R15,2(R15)                Bump past the number\n         MVC   0(7,R15),=C',BYPASS'      Complete the message\n         LA    R15,7(R15)                Bump past the suffix\n*\n         SR    R15,R14                   Length = end - Beginning\n         STC   R15,MGCRLGTH-MGCRPL(R14)  Save length\n*\n         SLR   R0,R0                     Clear register\n         MGCR  REPLY                     Issue reply\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Termination section                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n         DA#LEAVE SP=230,FMTYPE=RU\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSG1     DC    C'DA$2XXI MPF EXIT 07 answered with BYPASS, Reply='\nMSG1L    EQU   *-MSG1\n         DS    0D\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               ROUTCDE=(11,14),DESC=7,MCSFLAG=HRDCPY,MF=L\nC_WTOL   EQU   *-C_WTO\n*\n** Literals\n*\n         LTORG ,\n         DS    0D\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Getmained work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                    Register Save Area\nREPLY    DS    XL(MGCRLTH)            Reply (operator command)\nWTO      DS    XL(C_WTOL)             Write to operator\n         DS    0D\nWORKDSL  EQU   *-WORKDS\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Equates and DSECTs                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         REQUATE ,                    Equate our registers\n         IEZVX100 ,                   WTO User WTO exit parm list\n         IEZMGCR  DSECT=NO            SVC 34 Parameter List\n         END\n./ ADD NAME=DA$MPF08 0107-97055-98240-1035-00214-00179-00000-DALCOCK\nDA$MPF08 TITLE '                   Real time User notification of WTO'\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = DA$MPF08                                   **\n**                                                                   **\n**    Descriptive Name  = Notify user in real time of a critical     **\n**                        WTO message from a batch job that he       **\n**                        submitted.                                 **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Activated by      = Specifed in active MPF member of Parmlib:  **\n**                        - SET MPF=XX                               **\n**                        - WHERE XX IS A MEMBER IN PARMLIB:         **\n**                          'SYS1.PARMLIB(MPFLSTXX)'                 **\n**                        - REFERENCE IN MPFLSTXX:                   **\n**                       IEF861I,SUP(NO),USEREXIT(DA$MPF08)          **\n**                       IEF863I,SUP(NO),USEREXIT(DA$MPF08)          **\n**                       IEF099I,SUP(NO),USEREXIT(DA$MPF08)          **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         IEZVX100 ,                       WTO exit parameter list\n         PRINT NOGEN\n         IHAPSA ,                         Prefixed Save Area\n         IHAASCB ,                        Address Space Control Block\n         IHAASSB ,                        ASCB Secondard block\n         IAZJSAB ,                        Job Schedular Address spc\n         YREGS ,                          Equate registers to R0-R15\n         PRINT GEN\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY/MM/DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Intialization                                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDA$MPF08 CSECT ,\nDA$MPF08 AMODE 31\nDA$MPF08 RMODE ANY\n*\n** Create a standard O/S eyecatcher\n*\nEC       B     ECL(0,R15)               Bump past Eyecatcher\n         DC    AL1(L'ECLIT)             Length of eyecatcher\nECLIT    DC    C'DA$MPF08 &ASMDATE &SYSTIME - Echo message to TSO user'\n         DS    0H                       Ensure halfword alignment\nECL      EQU   *-EC\n*\n** Standard ESA entry housekeeping\n*\n         BAKR R14,0                     Save regs\n         LAE   R12,0(R15,0)             Get base register\n         USING DA$MPF08,R12             Get addressibility\n         SAC  0\n         SYSSTATE ASCENV=P\n         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage\n         LR   R13,R1                    Point to Save Area\n         MVC  4(4,R13),=C'F1SA'         Indicate stack SA\n         USING WORKDS,R13               Get addressibility to area\n*\n** Locate MPF exit parameter list and message area\n*\n         EREG  R0,R1                    Restore regs 0 and 1\n         L     R2,0(R1)                 Get CTXT Address\n         ICM   R3,B'1111',CTXTTXPJ-CTXT(R2) Locate Major\n         BZ    EXIT                     Shouldn't happen, but leave\n*\n** Determine if we should be trying to echo the message to the TSO\n** user:\n**\n** - Find the JSAB, there will be none for non-JES managed addr spaces\n** - Ensure that we are being invoked for a batch job\n** - If we have a userid, save it for later else leave\n*\n         L     R4,PSAAOLD-PSA           -> ASCB\n         ICM   R4,B'1111',ASCBASSB-ASCB(R4) -> ASSB\n         BZ    EXIT\n         ICM   R4,B'1111',ASSBJSAB-ASSB(R4) -> JSAB\n         BZ    EXIT\n*\n         CLC   JSABJBID-JSAB(3,R4),=C'JOB' Is this a batch job?\n         BNE   EXIT\n         CLI   JSABUSID-JSAB(R4),C' '   Looks valid?\n         BE    EXIT\n         CLI   JSABUSID-JSAB(R4),0      Looks valid?\n         BE    EXIT\n*\n         MVC   USERID(8),JSABUSID-JSAB(R4) Get notify user\n*\n** For some messages, skip the warning and blank line\n**\n** For example, I've always seen these three messages come together,\n** so we will only print our warning message and blank line for IEF861I\n**\n**  IEF861I FOLLOWING RESERVED DATA SET NAMES UNAVAILABLE TO DALCOCKZ\n**  IEF863I DSN = DALCOCK.DAVE.LOAD DALCOCKZ\n** *IEF099I JOB DALCOCKZ WAITING FOR DATA SETS\n*\n         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'IEF863I'\n         BE    ECHO\n         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'IEF099I'\n         BE    ECHO\n*\n** Tell user whats comming\n*\n         LA    R15,MESSAGE              Locate message start\n         MVC   0(MSG1L,R15),MSG1        Get message start\n         MVC   MSG1NAME-MSG1(L'JSABJBNM,R15),JSABJBNM-JSAB(R4)\n         MVC   MSG1ID-MSG1(L'JSABJBID,R15),JSABJBID-JSAB(R4)\n         LA    R0,MSG1L                 Set message length\n         TPUT  MESSAGE,                 Issue message to user          @\n               (0),                       ..Length of message          @\n               EDIT,                      ..Remove extra stuff         @\n               NOWAIT,                    ..Return control immed.      @\n               NOHOLD,                    ..Return control immed.      @\n               NOBREAK,                   ..No precedence over input   @\n               HIGHP,                     ..This guy must get through  @\n               USERIDL=USERID             ..To this userid\n         LTR   R15,R15                    Maybe not logged on...\n         BNZ   EXIT\n*\n** Print a blank line, Remember that ALL parameters to TPUT must reside\n** below the line or your WILL get a S15D ABEND.\n*\n         LA    R0,1                     Set message length\n         MVI   MESSAGE,C' '             Insert a blank\n         TPUT  MESSAGE,                 Issue message to user          @\n               (0),                       ..Length of message          @\n               EDIT,                      ..Remove extra stuff         @\n               NOWAIT,                    ..Return control immed.      @\n               NOHOLD,                    ..Return control immed.      @\n               NOBREAK,                   ..No precedence over input   @\n               HIGHP,                     ..This guy must get through  @\n               USERIDL=USERID             ..To this userid\n*\n** Now echo the actual message\n*\nECHO     DS    0H\n         LA    R15,MESSAGE                Locate message start\n         SLR   R14,R14                    Clear register\n         ICM   R14,B'0011',CTXTTLEN-CTXTATTR(R3) Get length\n         CH    R14,=H'128'                Larger than we want?\n         BL    ECHO$LX                    No, continue\n         LA    R14,128                    Yes, truncate to 128\nECHO$LX  DS    0H\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,X$MSGM                 Move message to TPUT area\n         LA    R15,1(R14,R15)             Locate end\n         LA    R1,MESSAGE                 Locate message start\n         LR    R0,R15                     Locate message end\n         SR    R0,R1                      Length = End - Begin\n*\n         TPUT  MESSAGE,                   Send message                 @\n               (0),                       ..Length of message          @\n               EDIT,                      ..Remove extra stuff         @\n               NOWAIT,                    ..Return control immed.      @\n               NOHOLD,                    ..Return control immed.      @\n               NOBREAK,                   ..No precedence over input   @\n               HIGHP,                     ..This guy must get through  @\n               USERIDL=USERID             ..To this userid\n*\n** Release resources and return to caller\n*\nEXIT     DS    0H\n         LR    R2,R13                     Get storage address\n         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage\n         SLR   R15,R15                    Set return code\n         PR                               Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants and executed instructions                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nX$MSGM   MVC   0(0,R15),CTXTTMSG-CTXTATTR(R3)\n*\nMSG1     DC    C'DA$M81I Batch job '\nMSG1NAME DC    CL8'jobname ',C' '\nMSG1ID   DC    CL8'JOBxxxxx',C' has the following action message:'\nMSG1L    EQU   *-MSG1\n         LTORG ,\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAINed work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                    Register Save Area\nUSERID   DS    CL8                    Userid to send message to\nMESSAGE  DS    CL256                  Message to issue\n         DS    0D\nWORKDSL  EQU   *-WORKDS\n         END\n./ ADD NAME=DA$MPF09 0107-97124-98240-1035-00205-00160-00000-DALCOCK\nDA$MPF09 TITLE '                   Enhance CSV019I error for ABENDAID'\n***********************************************************************\n***                                                                 ***\n** Name: DA$MPF09                                                    **\n**                                                                   **\n** Author: David Alcock                                              **\n**         dalcock@XYZ.com                                           **\n**                                                                   **\n** Purpose: MPF exit -- Enhance CSV019I message if for ABENDAID      **\n**          module.  This message looks like:                        **\n**                                                                   **\n**            CSV019I REQUESTED MODULE #XAAINTR NOT ACCESSED, IS IN  **\n**                    NON-APF LIBRARY/CONCATENATION                  **\n**                                                                   **\n**          This is a normal message if an authorized program ABENDs **\n**          and ABENDAID gets control.  If you have ABENDAID         **\n**          installed correctly, it will get this error when an APF  **\n**          authorized program ABENDs and you have not turned off    **\n**          ABENDAID for that step.                                  **\n**                                                                   **\n** Attributes: Reentrant, Reusable, must be in LNKLST.               **\n**                                                                   **\n** Requirements:                                                     **\n** - Assembler H or higher                                           **\n** - MVS 4.1 and higher (for WTO TEXT= (I think))                    **\n**                                                                   **\n** Activated by:                                                     **\n** - SET MPF=xx                                                      **\n**   (Where xx is a member in parmlib, MPFLSTxx)                     **\n** - Reference in MPFLSTXX:                                          **\n**  CSV019I,SUP(NO),USEREXIT(DA$MPF09)                               **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         IEZVX100 ,                       WTO exit parameter list\n         PRINT NOGEN\n         YREGS ,                          Equate registers to R0-R15\n         PRINT GEN\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY/MM/DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Intialization                                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDA$MPF09 CSECT ,\nDA$MPF09 AMODE 31\nDA$MPF09 RMODE ANY\n*\n** Create a standard O/S eyecatcher\n*\nEC       B     ECL(0,R15)               Bump past Eyecatcher\n         DC    AL1(ECLITL)              Length of eyecatcher\nECLIT    DC    C'DA$MPF09 &ASMDATE &SYSTIME'\n         DC    C'- MPF EXIT: Enhance message CSV019I'\nECLITL   EQU   *-ECLIT\n         DS    0H                       Ensure halfword alignment\nECL      EQU   *-EC\n*\n** Standard ESA entry housekeeping\n*\n         BAKR R14,0                     Save regs\n         LAE   R12,0(R15,0)             Get base register\n         USING DA$MPF09,R12             Get addressibility\n         SAC  0\n         SYSSTATE ASCENV=P\n*\n** Locate input parms\n*\n         EREG  R0,R1                    Restore regs 0 and 1\n         L     R2,0(R1)                 Get CTXT Address\n         ICM   R3,B'1111',CTXTTXPJ-CTXT(R2) Locate Major\n         BZ    QUICKOUT                 Shouldn't happen, but leave\n*\n** Ensure that the message is the right one and for ABENDAID module:\n**\n** 0....+....1....+....2....+....\n** CSV019I REQUESTED MODULE #XAAINTR NOT ACCESSED, IS IN\n**         NON-APF LIBRARY/CONCATENATION\n*\n         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'CSV019I'\n         BNE   QUICKOUT\n         CLC   CTXTTMSG+25-CTXTATTR(8,R3),=C'#XAAINTR'\n         BNE   QUICKOUT\n*\n** We need a valid RSA since we are about to issue some WTOs\n*\n         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage\n         LR    R13,R1                   Point to Save Area\n         MVC   4(4,R13),=C'F1SA'        Indicate stack SA\n         USING WORKDS,R13               Get addressibility to area\n*\n** Leave some messages in the joblog regarding the CSV message. This is\n** a multi-line WTO.\n*\n         XR    R0,R0                    Clear reg 0 before multiline\n         MVC   PARMLIST(C_WTO1L),C_WTO1\n         WTO   TEXT=((MSG1,D),(MSGB,D),(MSG2,D),(MSG3,D),(MSG4,D),     @\n               (MSG5,D),(MSG6,D),(MSG7,D),(MSG8,D),(MSGB,DE)),         @\n               MF=(E,PARMLIST)\n*\n         XR    R0,R0                    Clear reg 0 before multiline\n         MVC   PARMLIST(C_WTO2L),C_WTO2\n         WTO   TEXT=((MSG9,D),(MSGB,D),(MSG10,D),(MSG11,D),            @\n               (MSGB,DE)),                                             @\n               MF=(E,PARMLIST)\n*\n** Release resources and return to caller\n*\nEXIT     DS    0H\n         LR    R2,R13                     Get storage address\n         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage\nQUICKOUT DS    0H\n         SLR   R15,R15                    Set return code\n         PR                               Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nC_WTO1   WTO   TEXT=((MSG1,D),(MSGB,D),(MSG2,D),(MSG3,D),(MSG4,D),     @\n               (MSG5,D),(MSG6,D),(MSG7,D),(MSG8,D),(MSGB,DE)),MF=L\nC_WTO1L  EQU   *-C_WTO1\n*\nC_WTO2   WTO   TEXT=((MSG9,D),(MSGB,D),(MSG10,D),(MSG11,D),            @\n               (MSGB,DE)),MF=L\nC_WTO2L  EQU   *-C_WTO2\n*\nMSGB     DC    AL2(1),C' '\nMSG1     DC    AL2(60),60C' '\nMSG2     DC    AL2(60),60C' '\nMSG3     DC    AL2(60),60C' '\nMSG4     DC    AL2(60),60C' '\nMSG5     DC    AL2(60),60C' '\nMSG6     DC    AL2(60),60C' '\nMSG7     DC    AL2(60),60C' '\nMSG8     DC    AL2(60),60C' '\nMSG9     DC    AL2(60),60C' '\nMSG10    DC    AL2(60),60C' '\nMSG11    DC    AL2(60),60C' '\n*\n*\n* Note: This is pretty goofy but it makes the text easier to read\n*       when composing the text.\n*\n*        ....+....1....+....2....+....3....+....4....+....5....+.....6\n ORG   MSG1+2\n DC    C'DA$MPF09-01I '\n ORG   MSG2+2\n DC    C'The CSV019I message below was issued because'\n ORG   MSG3+2\n DC    C'ABENDAID was invoked for an APF-authorized program.'\n ORG   MSG4+2\n DC    C'ABENDAID can''t handle APF-authorized programs.  Please add'\n ORG   MSG5+2\n DC    C'a \"//ABNLIGNR DD DUMMY\" line to the JCL to prevent this'\n ORG   MSG6+2\n DC    C'error.  Your ABEND did not occur because of problems with'\n ORG   MSG7+2\n DC    C'#XAAINTR, this program is an ABENDAID program that got'\n ORG   MSG8+2\n DC    C'invoked to process the original ABEND.'\n*\n ORG   MSG9+2\n DC    C'DA$MPF09-02I '\n ORG   MSG10+2\n DC    C'Please consult the ABENDAID install manual for more details'\n ORG   MSG11+2\n DC    C'on this problem if needed.'\n ORG   ,\n*\n** Literals\n*\n         LTORG ,\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAINed work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                    Register Save Area\nPARMLIST DS    XL(C_WTO1L)\n         DS    0D\nWORKDSL  EQU   *-WORKDS\n         END\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 15:37 ON 98/08/28\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MVSVAR": {"ttr": 24838, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x00\"\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18C\\x000\\x00,\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:43:22", "lines": 48, "newlines": 44, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: MVSVAR\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Show the current values from the MVSVAR IBM function\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1998-2002+ by David Alcock\n |             All rights reserved.\n */\n\nif sysvar(systsoe) < \"2050\" then do\n   say \"The MVSVAR function is not available\",\n       \"in TSO release \"sysvar(systsoe)\n   exit\n   end\n\nsay \"         MVSVAR output:\"\nsay \" \"\nsay \"sysdfp------------(\"mvsvar('sysdfp')\")\"\nsay \"sysmvs------------(\"mvsvar('sysmvs')\")\"\nsay \"sysname-----------(\"mvsvar('sysname')\")\"\nsay \"sysseclab---------(\"mvsvar('sysseclab')\")\"\nsay \"syssmfid----------(\"mvsvar('syssmfid')\")\"\nsay \"syssms------------(\"mvsvar('syssms')\")\"\nsay \"sysclone----------(\"mvsvar('sysclone')\")\"\nsay \"sysplex-----------(\"mvsvar('sysplex')\")\"\nsay \"symdef,sysclone---(\"mvsvar('symdef','sysclone')\")\"\nsay \"symdef,sysname----(\"mvsvar('symdef','sysname')\")\"\n\nif substr(mvsvar('sysname'),1,3) == \"XYZ\" then do\n   say \" \"\n   say \"XYZ defined:\"\n   say \"  symdef,instname-(\"mvsvar('symdef','instname')\")\"\n   say \"  symdef,psuffix--(\"mvsvar('symdef','psuffix')\")\"\n   say \" \"\n   end\n\nsay \" ### the next one may fail with some ugly msgs ### \"\nsay \"sysappclu---------(\"mvsvar('sysappclu')\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NEWISPF": {"ttr": 24840, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x01\\x00\\x10\\x00\\x99\\x06\\x0f\\x01\\x020o\\x181\\x00>\\x006\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.01", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:31:10", "lines": 62, "newlines": 54, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: NEWISPF\n |\n | Author: Bruce Gillispie (modified by David Alcock)\n |\n | Purpose: Make ISPF v4 work/look more like ISPF v2 or v3\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.\n */\nif SYSVAR(SYSISPF) <> 'ACTIVE' then do\n   say \"%NEWISPF - This command can only be used in ISPF\"\n   exit 12\n   end\n\naddress ispexec\n'vget (zenvir)'\nif substr(zenvir,1,6) <> \"ISPF 4\" then do\n   say \"%NEWISPF - Invalid version of ISPF: \"zenvir\n   exit\n   end\n\n/*\n |  Make the changes to ISPF options\n */\n\n'select pgm(ispopt) parm(JUMP(ON))'\nrc1 = rc\n'select pgm(ispopt) parm(ABTAB(OFF))'\nrc2 = rc\n'select pgm(ispopt) parm(PSTAB(OFF))'\nrc3 = rc\n'select pgm(ispopt) parm(LMSG(ON))'\nrc4 = rc\n'select pgm(ispopt) parm(SESM(ON))'\nrc5 = rc\n'select pgm(ispopt) parm(EDPRT(OFF))'\nrc6 = rc\n'select pgm(ispopt) parm(SPLTLINE(OFF))'\nrc7 = rc\n\nzplace = 'ASIS'\n'vput (zplace) profile'\n\n/*\n |  Say we did something and leave\n */\n\ntest = rc1 + rc2 + rc3 + rc4 + rc5 + rc6 + rc7\nif test <> 0 then say \"%NEWISPF - One or more changes failed\"\nsay \"%NEWISPF - Changes have been made to make ISPF v4 more like \" ,\n    \"older releases\"\nsay \" \"\nsay \"%NEWISPF - Please leave ISPF and get back in to complete changes\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OSCMD": {"ttr": 24842, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x020o\\x01\\x020o\\x14\\x07\\x005\\x005\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T14:07:29", "lines": 53, "newlines": 53, "modlines": 0, "user": "IBMUSER"}, "text": "/* Rexx\n |\n | Name: OSCMD\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Issue operator command and show on TSO screen\n |\n | Restrictions: You must have security system (RACF ACF2, etc)\n |               access to the CONSOLE command.\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 2001-2002+ by David Alcock\n |             All rights reserved.\n */\n\narg cmd\nif cmd == \"\" then cmd = \"D IPLINFO\"\nname = sysvar('sysuid')\"O\"\n\ndisplay = 1\nif substr(cmd,1,7) == \"NODISP \"   then do\n   cmd = delstr(cmd,1,7)\n   display = 0\n   end\n\nADDRESS TSO\n\"CONSPROF SOLDISP(NO) UNSOLDISP(NO) SOLNUM(400)\"\ncrc = rc\nif crc <> 0 then exit\n\"CONSOLE ACTIVATE NAME(\"name\")\"\ncrc = rc\nif crc <> 0 then exit\n\nADDRESS CONSOLE cmd\nGETCODE = GETMSG('CONMSG.','SOL',,,100)\n\nADDRESS TSO\nsay \"RC=\"getcode \"for\" cmd\n\nif display == 1 then ,          /* Echo output */\n   do i = 1 to conmsg.0\n      say conmsg.i\n      end\n\n\"CONSOLE DEACTIVATE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PROGXX": {"ttr": 24844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x01\\x00\\x12\\x00\\x99\\x06\\x0f\\x01\\x020o\\x13G\\x04$\\x04&\\x00\\x00\\xc4\\xc1\\xd3\\xc3\\xd6\\xc3\\xd2@@@'", "ispf": {"version": "20.01", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T13:47:12", "lines": 1060, "newlines": 1062, "modlines": 0, "user": "DALCOCK"}, "text": "./ ADD NAME=$CHANGES 1200-97137-97137-1812-00009-00009-00000-DALCOCK\n- Tutorial panels (not very extensive)\n- Use NoRecall on LISTDSI\n- Parse SysReason for better LISTDSI error messages\n- Detect comments that don't have blanks by the asterisks\n- Use dynamic areas on the status popup panel so the msgs text areas stand\n  out\n- Handle multiple parms\n- The REPORT command (in the table list) puts an APFLST report on your\n  ISPF list file.\n./ ADD NAME=PROGXX   1200-97137-97137-1812-00903-00903-00000-DALCOCK\n/* REXX\n |\n | Name: PROGxx\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: This edit macro processes a SYS1.PARMLIB(PROGxx) member that\n |          consists of APF entries (and only APF entries) and performs\n |          these functions:\n |\n |          - puts note and msg lines into the edit datasets for errors\n |          - parm of SORT puts a sorted version of the PROGxx\n |            member into \"USERID.SPFTEMP1.SORTED.PROGXX\"\n |          - parm of TLIST shows a table list of all of the entries\n |            in the APFLST and allows browsing or invoking the PDS\n |            command for that dataset.\n |\n |          You can process the whole member or use the SS range line\n |          line commands to select a few entries to process.\n |\n |          This exec expects valid PROGxx APF entries. We stop when\n |          we find bad entries.\n |\n |          Although easy enough, we don't filter out the non-APF\n |          entries and you will get a syntax error on them.\n |\n |          You can keep your SYS1.PARMLIB(PROGxx)' entries separate\n |          via 'IEASYSxx' statement PROG=(AA,EE,LL) where PROGAA\n |          has your APFLST entries, EE has your EXITs and LL has\n |          your LNKLST entries.\n |\n | Modifications: You *MUST* use the correct attributes for the\n | binary fields that are defined in the PROGXXS panel\n | for the output to look correct.\n |\n | Sample invocations:\n |\n |   PROGXX\n |   PROGXX SORT\n |   PROGXX TLIST\n |   PROGXX LIST\n |   PROGXX LIST NOVERIFY\n |\n | Hints: If you have only added/modified a few or even just one entry\n |        to a PROGxx member, use the \"SS\" line commands to do the\n |        processing for only the lines changed for quicker response.\n */\n\n/**********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Ver  Description                           **\n** ---------- ----------- ---- ------------------------------------- **\n** DGAlcock   12-MAR-1997 v1.2 Tutorial panels; Use NoRecall; Parse  **\n**                             SysReason for better LISTDSI error;   **\n**                             Detect comments that don't have blanks**\n**                             by the asterisks; Use dynamic areas   **\n**                             on the status popup panel so the msgs **\n**                             text areas stand out; Handle multiple **\n**                             parms; Added Report option;           **\n** DGAlcock   10-MAR-1997 v1.1 Parse comments correctly;             **\n**                             Added Master Catalog volume support;  **\n**                             Added SMS-managed keyword support;    **\n**                             Better header on sorted file;         **\n**                             Save type of APFLST format if found;  **\n**                             Added parm alias of LIST for TLIST;   **\n**                             Corrected incorrect panel name;       **\n** DGAlcock   10-MAR-1997 v1.0 Initial REXX exec created             **\n***                                                                 ***\n**********************************************************************/\n\ndebug = 0\n\naddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nparms = translate(parms)\nif parms == '?' | parms = \"HELP\" then do\n   address ISPEXEC \"DISPLAY PANEL(PROGXXH0)\"\n   exit\n   end\n\n/*---------------------------------------------------------------------\n | Process line commands for S/SS/S99999\n ------------------------------------------------------------------- */\n\n'PROCESS RANGE S'\nselect\n  when rc = 0 then do\n       '(CMD) = RANGE_CMD'          /* Get the command    */\n       '(LINE1) = LINENUM .ZFRANGE' /* Get first in range */\n       '(LINE2) = LINENUM .ZLRANGE' /* Get last in range  */\n       end\n  when rc <= 4 then do /* No S or SS entered, use entire file     */\n       '(CMD) = RANGE_CMD'          /* Get the command    */\n       '(LINE1) = LINENUM .ZFIRST'  /* Get first in range */\n       '(LINE2) = LINENUM .ZLAST'   /* Get last in range  */\n       end\n  otherwise  /* Line command conflict - Edit will create message  */\n       exit 12\nend /* of \"select\" */\n\nmsg1 = '02'x time() '01'x \"Starting processing of APFLST\"\nmsg2 = \" \"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(PROGXXS)\"\n\"REMPOP\"\n\n/*---------------------------------------------------------------------\n | Process the parms\n ------------------------------------------------------------------- */\n\no_list = 0\no_noverify = 0\no_sort = 0\n\ndo i = 1 to words(parms)\n   select\n     when word(parms,i) == \"LIST\"     then o_list = 1\n     when word(parms,i) == \"TLIST\"    then o_list = 1\n     when word(parms,i) == \"NOVERIFY\" then o_noverify = 1\n     when word(parms,i) == \"SORT\"     then o_sort = 1\n     otherwise\n          say \"Unknown option '\"word(parms,i)\" was ignored\"\n          end\n   end\n\n/*---------------------------------------------------------------------\n | Initialize variables\n ------------------------------------------------------------------- */\n\nentry_started = 0\napflist.1 = \"\"\nformat_type = \"\"\napfsrc.1 = 0\na = 1\ncomment = 0\nfirsterr = 0\nmcatvol = \"\"\nwarn_num = 0\ndsn_errcount = 0\nSyntax_errcount = 0\n\n/*---------------------------------------------------------------------\n | Process the selected lines for apf entries\n ------------------------------------------------------------------- */\n\naddress ISREDIT\n\"(ICAPS) = CAPS\"  /* save caps type upon entry */\n\"CAPS = OFF\"      /* Ensure mixed case for note/msg lines */\n\n\"(SRCDSN) = DATASET\"\n\"(SRCMEM) = MEMBER\"\n\"(DID) = DATAID\"\naddress ISPEXEC \"LMQUERY DATAID(\"DID\") VOLUME(SRCVOL)\"\nlmq_rc = rc\nif lmq_rc == 0 then srcvol = \"n/a\"\naddress ISREDIT\n\nif  member <> '' then srcdsn = srcdsn||\"(\"||srcmem||\")\"\n\ntline = line2 - line1\n\ndo i = line1 to line2\n   '(LINEVAL) = LINE' i   /* Get edit line */\n\n   if debug then say \"#\"i \">\" lineval\n\n   if (i // 10) == 0 then do\n      msg1 = '04'x \"Reading APFLST edit line\"||'03'x i '04'x \"of\" ,\n             '03'x tline\n      msg2 = '02'x time() '06'x dsname '01'x volume\n      address ISPEXEC\n      \"CONTROL DISPLAY LOCK\"\n      \"ADDPOP\"\n      \"DISPLAY PANEL(PROGXXS)\"\n      \"REMPOP\"\n      address ISREDIT\n      end\n\n   do j = 1 to words(lineval)\n\n      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n       | Comment start and end detection\n       |\n       | Note: Since not all comments end on a \" @/\", we need to\n       | extract the last two bytes of every word and test them@/\n       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n      wl = length(word(lineval,j))\n      if wl > 2 then ws = substr(word(lineval,j),wl-1,2)\n\n      if comment then do\n         if word(lineval,j) == \"*/\" | ws == \"*/\" then ,\n            comment = 0\n         iterate\n         end\n      else if word(lineval,j) == \"/*\" | ,\n              substr(word(lineval,j),1,1) == \"/*\" then do\n              comment = 1\n              iterate\n              end\n\n      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n       | Start of an APF entry\n       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n      if word(lineval,j) == \"APF\" then do\n\n         /* Ignore the \"APF FORMAT(type)\" line */\n         k = j + 1\n         if k == words(lineval) | k < words(lineval)  then do\n            if word(lineval,k) == \"FORMAT(STATIC)\" then do\n               format_type = \"STATIC\"\n               iterate\n               end\n            if word(lineval,k) == \"FORMAT(DYNAMIC)\" then do\n               format_type = \"DYNAMIC\"\n               iterate\n               end\n            end\n\n         if entry_started then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Found new APF entry before the end of the previous one'\"\n            Syntax_errcount = Syntax_errcount + 1\n            end\n\n         entry_started = 1\n         apfsrc.a = i\n         end\n\n      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n       | We don't do anything with the ADD word, skip to next word\n       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n      if word(lineval,j) == \"ADD\" then iterate\n\n      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n       | DSNAME() parameter\n       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n      if substr(word(lineval,j),1,7) == \"DSNAME(\" then do\n         if length(apflist.a) == 44 then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Duplicate DSNAME() parameter found for APF entry'\"\n            Syntax_errcount = Syntax_errcount + 1\n            end\n\n         parse value word(lineval,j) with \"(\"dsname\")\"\n         if dsname == \"\" then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Parse of DSNAME() parameter failed, check syntax'\"\n            Syntax_errcount = Syntax_errcount + 1\n            dsname = left('?',44,'?')\n            end\n         dsname = left(dsname,44)\n\n         if apflist.a == \"\" then do\n            apflist.a = dsname\n            iterate\n            end\n\n         if length(apflist.a) <> 6 then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Expecting VOLUME() or SMS parameter but did not find it'\"\n            apflist.a = \"??????\"\n            Syntax_errcount = Syntax_errcount + 1\n            end\n\n         apflist.a = dsname\"\"apflist.a\n         error.a = \"\"\n         a = a + 1\n         apflist.a = \"\"\n         apfsrc.a = 0\n         entry_started = 0\n         iterate\n         end\n\n      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n       | VOLUME() parameter\n       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n      if substr(word(lineval,j),1,7) == \"VOLUME(\" then do\n         if length(apflist.a) == 6 then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Duplicate VOLUME() parameter found for APF entry'\"\n            Syntax_errcount = Syntax_errcount + 1\n            end\n\n         parse value word(lineval,j) with \"(\"volume\")\"\n         if volume == \"\" then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Parse of VOLUME() parameter failed, check syntax'\"\n            volume = \"?????\"\n            Syntax_errcount = Syntax_errcount + 1\n            end\n         volume = left(volume,6)\n\n         if apflist.a == \"\" then do\n            apflist.a = volume\n            iterate\n            end\n\n         if length(apflist.a) <> 44 then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Expecting DSNAME() parameter but did not find it'\"\n            Syntax_errcount = Syntax_errcount + 1\n            apflist.a = left('?',44,'?')\n            end\n\n         apflist.a = apflist.a\"\"volume\n         error.a = \"\"\n         a = a + 1\n         apflist.a = \"\"\n         apfsrc.a = 0\n         entry_started = 0\n         iterate\n         end\n\n      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n       | SMS parameter\n       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n      if substr(word(lineval,j),1,3) == \"SMS\" then do\n         if length(apflist.a) == 6 then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Duplicate VOLUME()/SMS found for APF entry'\"\n            Syntax_errcount = Syntax_errcount + 1\n            end\n\n         volume = \"---SMS\"  /* Our special name for SMS volume */\n\n         if apflist.a == \"\" then do\n            apflist.a = volume\n            iterate\n            end\n\n         if length(apflist.a) <> 44 then do\n            if firsterr = 0 then firsterr = i\n            \"LOCATE\" i   /* locate to this bad line */\n            \"LINE_AFTER \"i\" = INFOLINE \" ,\n            \"'Expecting DSNAME() parameter but did not find it'\"\n            apflist.a = left('?',44,'?')\n            Syntax_errcount = Syntax_errcount + 1\n            end\n\n         apflist.a = apflist.a\"\"volume\n         error.a = \"\"\n         a = a + 1\n         apflist.a = \"\"\n         apfsrc.a = 0\n         entry_started = 0\n         iterate\n         end\n\n      end /* of \"do j = 1 to words(lineval)\" - - - - - - - - - - - */\n\n   end /* of \"do i = line1 to line 2\" - - - - - - - - - - - - - - - */\n\na = a - 1\nif a == 0 then do\n   zedsmsg = \"\"\n   zedlmsg = \"Error: Did not find any valid APF entries in input\"\n   address ISPEXEC 'SETMSG MSG(ISRZ001)'\n   exit 12\n   end\n\nif Syntax_errcount <> 0 then do\n   if Syntax_errcount > 0 then terr = \"errors\"\n   else terr = \"error\"\n   msg1 = '02'x time() '01'x||\"Warning: Found\" ,\n          '03'x||Syntax_errcount||'01'x||\"syntax \"terr\n   msg2 = '0f'x \"(Please hit ENTER)\"\n   address ISPEXEC\n   \"ADDPOP\"\n   \"DISPLAY PANEL(PROGXXS)\"\n   \"REMPOP\"\n   address ISREDIT\n   end\n\n/*---------------------------------------------------------------------\n | Get the SYSRES\n |\n | Note: This code *may* not work if the SYSRES is on a 4 digit\n |       UCB - untested in that environment.\n ------------------------------------------------------------------- */\n\ncvt    = storage(10,4)                         /* -> CVT             */\ndcvt   = c2d(cvt)                              /* Convert to decimal */\nsysad  = storage(c2x(d2c(DCVT+x2d(30))),4)     /* -> CVTSYSAD        */\ndsysad = c2d(sysad)                            /* convert to decimal */\nsysres = storage(c2x(d2c(dsysad+x2d(1C))),6)   /* Get SYSRES volser  */\n\n/* address TSO \"SHOWTSO SYSRES\"  <- Installation may have this */\n\n/*--------------------------------------------------------------------\n | Verify the APFLST, put the results in the file\n ------------------------------------------------------------------- */\n\n\nif o_noverify == 0 then do\n\n   stime = time()\n\n   do i = 1 to a\n      cdsn = \"'\"strip(word(apflist.i,1))\"'\"\n      cvol = strip(word(apflist.i,2))\n      cvols = cvol\n      error.i = \"\"\n      j = apfsrc.i\n\n      if ((i // 10) == 0) | i = 1 then do\n         msg1 = '04'x \"Processing APFLST entry\"||'03'x i '04'x \"of\" ,\n                '03'x a '04'x \"Started:\" '02'x stime\n         msg2 = '02'x time() '06'x left(cdsn,44) '01'x cvol\n         address ISPEXEC\n         \"CONTROL DISPLAY LOCK\"\n         \"ADDPOP\"\n         \"DISPLAY PANEL(PROGXXS)\"\n         \"REMPOP\"\n         address ISREDIT\n         end\n\n      if cvol == \"---SMS\" then do\n         x = LISTDSI(cdsn norecall)\n         cvol = sysvolume\n         end\n      else do\n           select\n              when cvol == \"******\" then cvol = sysres\n              when cvol == \"*MCAT*\" then do\n                   if mcatvol == \"\" then call return_mcatvol\n                   cvol = mcatvol\n                   end\n              otherwise\n                   nop\n                   end\n           x = LISTDSI(cdsn \"VOLUME(\"cvol\")\" norecall)\n           end\n\n      if x <> 0 then do\n         warn_num = warn_num + 1\n\n         if j <> 0 then do\n\n            if firsterr = 0 then firsterr = j\n            dsn_errcount = dsn_errcount + 1\n            call return_listdsi_reason   /* Set error.i to sysreason */\n\n            address ISREDIT\n            \"LINE_AFTER \"j\" = MSGLINE\" ,\n            \"'         \"error.i\"'\"\n            \"LINE_AFTER \"j\" = NOTELINE\" ,\n            \"'Warning: DSN=\"cdsn\"'\"\n            end\n\n         else say \"Error: \"cdsn\n\n         end /* of \"if x <> 0\" - - - - - - - - - - - - - - - */\n\n      end /* of \"do i = 1 to a\" - - - - - - - - - - - - - - - - */\n\n   end /* of \"if o_noverify...\" - - - - - - - - - - - - - - - - - - */\n\naddress ISREDIT \"CAPS = \"icaps /* Restore CAPS state upon entry */\n\n/*--------------------------------------------------------------------\n | Do the common task of creating an ISPF table of the APF list entries\n | for the SORT and TLIST functions\n ------------------------------------------------------------------- */\n\n table_created = 0\n\n if o_sort == 1 | o_list == 1  then do\n\n    address ISPEXEC\n\n    msg1 = '02'x time() '01'x \"Creating ISPF Table\"\n    msg2 = \"\"\n    \"CONTROL DISPLAY LOCK\"\n    \"ADDPOP\"\n    \"DISPLAY PANEL(PROGXXS)\"\n    \"REMPOP\"\n\n    tablenm = \"PXX\"random()\n    \"TBCREATE \"tablenm\" NOWRITE NAMES(DSN VOL ERR NUM)\"\n    tbc_rc = rc\n    if tbc_rc == 0 then table_created = 1\n    else do\n         say \"Create of ISPF table for APFLST failed, rc=\"tbc_rc\n         signal theend\n         end\n\n    do i = 1 to a\n       num = i\n       dsn = strip(word(apflist.i,1))\n       vol = strip(word(apflist.i,2))\n       err = error.i\n       \"TBADD \"tablenm\n       end\n\n    end /* of \"if o_sort == 1 | o_list == 1\" ------  */\n\n/*--------------------------------------------------------------------\n | Display the APFlist entries in an ISPF table display\n ------------------------------------------------------------------- */\n\nsortffn = \"Original order\"\n\nif o_list == 1 then do\n\n   address ISPEXEC \"TBTOP \"tablenm\n   tsel = \"\"\n   nrc = 0\n\n   do while nrc == 0\n\n      address ISPEXEC \"TBDISPL \"tablenm\" PANEL(PROGXXAT)\"\n      nrc = rc\n\n      if nrc == 0 then do\n\n         if zcmd <> \"\" then do\n            tsel = \"\"\n            zcmd = translate(zcmd)\n            if word(zcmd,1) == \"SORT\" then do\n               sortf = \"NUM\"  /* assume original order */\n               if words(zcmd) == 2 then ,\n                  select\n                    when word(zcmd,2) == \"D\"      then sortf = \"DSN\"\n                    when word(zcmd,2) == \"DSN\"    then sortf = \"DSN\"\n                    when word(zcmd,2) == \"DSNAME\" then sortf = \"DSN\"\n                    when word(zcmd,2) == \"V\"      then sortf = \"VOL\"\n                    when word(zcmd,2) == \"VOL\"    then sortf = \"VOL\"\n                    when word(zcmd,2) == \"VOLUME\" then sortf = \"VOL\"\n                    when word(zcmd,2) == \"VOLSER\" then sortf = \"VOL\"\n                    when word(zcmd,2) == \"E\"      then sortf = \"ERR\"\n                    when word(zcmd,2) == \"ERR\"    then sortf = \"ERR\"\n                    when word(zcmd,2) == \"ERRORS\" then sortf = \"ERR\"\n                    when word(zcmd,2) == \"NUM\"    then sortf = \"NUM\"\n                    otherwise\n                         nop\n                         end\n               select\n                  when sortf == \"NUM\" then sortffn = \"Original Order\"\n                  when sortf == \"DSN\" then sortffn = \"Dataset\"\n                  when sortf == \"VOL\" then sortffn = \"Volser\"\n                  when sortf == \"ERR\" then sortffn = \"Errors\"\n                  otherwise\n                       nop\n                       end\n\n               if sortf == \"NUM\" then sortt = \"N\"\n               else sortt = \"C\"\n\n               \"TBSORT\" tablenm \"FIELDS(\"sortf\",\"sortt\",A)\"\n               \"TBTOP\" tablenm\n               iterate\n               end\n\n            if word(zcmd,1) == \"REPORT\" then do\n               call Generate_Report\n               iterate\n               end\n\n            zedsmsg = \"\"\n            zedlmsg = \"Invalid command: \"left(zcmd,60)\n            address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n            end /* of \"if zcmd <> \"\"\"   */\n\n         tsel = translate(tsel)\n         select\n\n           /*------------------------------------------------------\n            | Browse the dataset\n            ------------------------------------------------------*/\n\n           when tsel == 'S' | tsel = 'B' then do\n                if vol == \"******\" then vol = sysres\n                if vol == \"*MCAT*\" then vol = mcatvol\n                call Browse_Library\n                end\n\n           /*------------------------------------------------------\n            | Invoke the PDS, PDSE, StarTools command for this lib\n            |\n            | Note: The PDS command name may differ from shop to shop\n            ------------------------------------------------------*/\n\n           when tsel == 'P' then do\n                address ISPEXEC \"CONTROL ERRORS RETURN\"\n                address ISPEXEC \"CONTROL DISPLAY SAVE\"\n\n                address TSO \"PDSE '\"dsn\"' VOLUME(\"vol\")\"\n\n                address ISPEXEC \"CONTROL DISPLAY RESTORE\"\n                address ISPEXEC \"CONTROL ERRORS CANCEL\"\n                end\n\n           /*------------------------------------------------------\n            | Incorrect option\n            ------------------------------------------------------*/\n           otherwise\n                zedlmsg = \"Unknown selection option:\" tsel\n                zedsmsg = \"\"\n                address ISPEXEC 'SETMSG MSG(ISRZ001)'\n            end\n         /*------------------------------------------------------\n          | End of table row selection\n          ------------------------------------------------------*/\n         tsel = \"\"\n         end\n      end\n\n   end /* of \"if o_list == 1\"  */\n\n/*--------------------------------------------------------------------\n | Sort the table and create a new PROGxx member with the sorted\n | version\n ------------------------------------------------------------------- */\n\n if o_sort == 1 then do\n\n    address ISPEXEC\n\n    msg1 = '02'x time() '01'x \"Sorting APFLST\"\n    msg2 = \"\"\n    \"CONTROL DISPLAY LOCK\"\n    \"ADDPOP\"\n    \"DISPLAY PANEL(PROGXXS)\"\n    \"REMPOP\"\n\n    \"TBSORT\" tablenm \"FIELDS(DSN,C,D)\"\n    \"TBTOP\" tablenm\n\n    progxxs_dsn = \"SPFTEMP1.SORTED.PROGXX\"\n    progxxs_ddn = \"PXX\"random()\n    address TSO\n    x = outtrap(\"XMSG.\",\"*\")\n    \"DELETE \"progxxs_dsn\n    x = outtrap(\"off\")\n    \"ALLOCATE FILE(\"progxxs_ddn\") DA(\"progxxs_dsn\")\",\n    \"UNIT(SYSDA) NEW REUSE SPACE(15 15) TRACKS\",\n    \"LRECL(80) BLKSIZE(8800) RECFM(F B)\"\n    newstack\n\n    address ISPEXEC\n    src = 0\n    do while src == 0\n       \"TBSKIP\" tablenm\n       src = rc\n       if src == 0 then do\n          if err <> \"\" then err = \"/* Warning: \"err\" */\"\n\n          push \"    VOLUME(\"vol\")   \"err\n          push \"    DSNAME(\"dsn\")\"\n          push \"APF ADD\"\n          end\n       end\n\n    if format_type <> \"\" then push \"APF FORMAT(\"format_type\")\"\n\n    h.1 = \"This sorted APFLST was created by the PROGXX edit macro\"\n    h.2 = \"on \"date()\" at \"time()\" from:\"\n    h.3 = \"DSN=\"SRCDSN\n    h.0 = 3\n\n    push \"/* \"left(\"-\",65,\"-\")\" */\"\n    do t = h.0 to 1 by -1\n       push \"/* \"center(h.t,65)\" */\"\n       end\n    push \"/* \"left(\"-\",65,\"-\")\" */\"\n\n    queue '' /* indicate end of file */\n    address TSO \"EXECIO * DISKW \"progxxs_ddn\" (FINIS\"\n    address TSO \"FREE FILE(\"progxxs_ddn\")\"\n    address TSO \"delstack\"\n\n    msg1 = '02'x time() '01'x \"A sorted version of the APFLST \" ,\n           \"was placed into:\"\n    msg2 = '04'x \"DSN='\"sysvar(sysuid)\".\"progxxs_dsn\"'\" ,\n           '0f'x \"(Please hit ENTER)\"\n    address ISPEXEC\n    \"ADDPOP\"\n    \"DISPLAY PANEL(PROGXXS)\"\n    \"REMPOP\"\n    end /* of \"if o_sort == 1\" -------------------------------  */\n\n/*--------------------------------------------------------------------\n | Now position us to the first error (if any) and exit with a msg\n ------------------------------------------------------------------- */\n\ntheend:\nif o_noverify == 0 then do\n   if warn_num == 0 then ,\n      zedlmsg = \"Didn't find any problems with the APFLST\" ,\n                \"entries selected\"\n   else do\n        zedlmsg = \"Found \"warn_num\" APFLST entries in error for\" ,\n                  \"those lines which were selected\"\n        \"ISREDIT LOCATE\" firsterr\n        end\n   zedsmsg = \"\"\n   address ISPEXEC 'SETMSG MSG(ISRZ001)'\n   end\n\nif table_created then address ISPEXEC \"TBCLOSE \"tablenm\nexit\n\n/*--------------------------------------------------------------------\n | Browse the library with control on errors\n ------------------------------------------------------------------- */\n\nBrowse_Library:\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress ISPEXEC \"CONTROL DISPLAY SAVE\"\nif vol == \"---SMS\" then ,\n   address ISPEXEC \"BROWSE DATASET('\"dsn\"')\"\nelse address ISPEXEC \"BROWSE DATASET('\"dsn\"') VOLUME(\"vol\")\"\nbrc = rc\nif brc <> 0 then do\n   zedsmsg = \"\"\n   zedlmsg = \"Browse to dataset failed: \"dsn \"on\" vol\n   address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   end\naddress ISPEXEC \"CONTROL DISPLAY RESTORE\"\naddress ISPEXEC \"CONTROL ERRORS CANCEL\"\nreturn\n\n/*--------------------------------------------------------------------\n | Return the sysreson type in error.i\n |\n | I'd rather have an array but sysreason is a string and not numeric\n ------------------------------------------------------------------- */\n\nreturn_listdsi_reason:\n\ns = sysreason\nselect\n when s=\"0001\" then e=\"Internal error\"\n when s=\"0002\" then e=\"Dynamic allocation processing error\"\n when s=\"0003\" then e=\"Invalid dataset type\"\n when s=\"0004\" then e=\"Error determining UNIT name\"\n when s=\"0005\" then e=\"Data set not cataloged\"\n when s=\"0006\" then e=\"Error obtaining the data set name\"\n when s=\"0007\" then e=\"Error finding device type\"\n when s=\"0008\" then e=\"The data set does not reside on a DASD\"\n when s=\"0009\" then e=\"DFHSM migrated the data setand NORECALL set\"\n when s=\"0010\" then e=\"Unknown error\"\n when s=\"0011\" then e=\"Directory information was request but\" ,\n                      \"you didn't have authority to dataset\"\n when s=\"0012\" then e=\"VSAM data sets are not supported\"\n when s=\"0013\" then e=\"The data set could not be opened\"\n when s=\"0014\" then e=\"Device type not found in UCB tables\"\n when s=\"0017\" then e=\"System or user abend occurred\"\n when s=\"0018\" then e=\"Partial data set information was obtained\"\n when s=\"0019\" then e=\"Data set resides on multiple volumes\"\n when s=\"0020\" then e=\"Device type not found in eligible\" ,\n                      \"device table (EDT)\"\n when s=\"0021\" then e=\"Catalog error trying to locate the data set\"\n when s=\"0022\" then e=\"Volume %VVVVV not mounted\"\n when s=\"0023\" then e=\"Permanent I/O error on volume %VVVVVV\"\n when s=\"0024\" then e=\"Dataset not found on volume %VVVVV\"\n when s=\"0025\" then e=\"Dataset migrated to non-DASD device\"\n when s=\"0027\" then e=\"No volume serial is allocated to the \" ,\n                      \"data set\"\n when s=\"0029\" then e=\"Dataset name or ddname must be specified\"\n otherwise\n      e = \"LISTDSI SysReason=\"s\n      end\n\ny = lastpos('%VVVVV',e)\nif y <> 0 then e = overlay(cvol,e,y,6)\n\nerror.i = e\n\nreturn\n\n/*--------------------------------------------------------------------\n | Generate a report on the SPF list file\n ------------------------------------------------------------------- */\nGenerate_Report:\n\naddress ISPEXEC\n\"CONTROL DISPLAY SAVE\"\npagenum = 0\nlinenum = 99\n\n\n\"TBTOP\" tablenm\nrrc = 0\ndo while rrc == 0\n\n   \"TBSKIP\" tablenm\n   rrc = rc\n   if rrc <> 0 then leave\n\n   linenum = linenum + 1\n\n   if linenum > 50 then do\n      pagenum = pagenum + 1\n      O = \"1APFLST Report generated by the PROGxx edit macro -\" ,\n          date() \"-\" time() \"- Page:\" pagenum\n      address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n      O = \" \"\n      address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n      if srcvol == \"n/a\" then slv = \"\"\n      else slv = \"Volume: \"srcvol\n      O = \" Source library: \"srcdsn slv\n      address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n      O = \" \"\n      address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n      O = \" Data Set Name                                Volume Error\"\n      address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n      O = \" -------------------------------------------- ------ -----\"\n      address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n      linenum = 1\n      end\n\n   O = \" \"left(dsn,44) left(vol,6) err\n   address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n   end\n\npagenum = pagenum + 1\nO = \"1APFLST Report summary - Page: \"pagenum\naddress ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\nO = \" \"\naddress ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\nO = \" Source: \"SRCDSN\naddress ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\nO = \" \"\naddress ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n\nif mcatvol <> \"\" then O = \" We used volume \"mcatvol\" for the master \",\n   \"catalog volume. \"\nO = O||sysres \"was used for the SYSRES\"\naddress ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\nif Syntax_errcount <> 0 then do\n   O = \" Number of Syntax Errors:\" Syntax_errcount\n   address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n   end\nif dsn_errcount <> 0 then do\n   O = \" Number of Dataset Errors:\" dsn_errcount\n   address ISPEXEC \"LIST BUFNAME(O) LINELEN(\"length(O)\") CC\"\n   end\n\nzedsmsg = \"Report Created\"\nzedlmsg = \"The APFLST report was written to your SPF list file\"\naddress ISPEXEC \"SETMSG MSG(ISRZ001)\"\n\n\"CONTROL DISPLAY RESTORE\"\nreturn\n\n/*--------------------------------------------------------------------\n | Return the master catalog volume serial\n |\n | There is probably an easier way to do this other than assuming the\n | SYS1.LINKLIB is in the master catalog and doing the overhead to\n | invoke LISTCAT, parsing the output and then obtaining the volume\n | via LISTDSI\n ------------------------------------------------------------------- */\n\nreturn_mcatvol:\ncall \"OUTTRAP\" \"LISTCAT.\",\"*\"\naddress TSO \"LISTCAT ENTRY('SYS1.LINKLIB') ALL\"\nidcams_rc = rc\ncall \"OUTTRAP\" \"OFF\"\n\nif idcams_rc <> 0 then do\n   mcatvol = \"-Error\"\n   end\nelse do\n     do l = 1 to listcat.0 by 1\n        if word(listcat.l,1) == \"IN-CAT\" then do\n           mcatdsn = \"'\"word(listcat.l,3)\"'\"\n           iterate\n           end\n        end\n     x = listdsi(mcatdsn)\n     if x <> 0 then mcatvol = sysvolume\n     else mcatvol = \"-Error\"\n     end /* of \"else do\" */\nreturn\n./ ADD NAME=PROGXXAT 1200-97137-97137-1812-00030-00030-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: PROGXXAT                                                   */\n /* Author: David Alcock                                             */\n /* Application: PROGxx                                              */\n /* Purpose: Table display of APFLST entries                         */\n /********************************************************************/\n ! type(output) intens(low)  color(turq)    caps(off)\n \u00ac type(output) intens(high) color(yellow)  caps(off)\n # type(output) intens(low)  color(green)   caps(off)\n @ type(output) intens(high) color(turq)    caps(off)\n | type(output) intens(high) color(blue)    caps(off)\n \u00a2 type(output) intens(high) color(red)\n \u00a6 type(text)   intens(high) color(red)\n ` type(text)   intens(low)  color(green)\n)body expand(\\\\)\n%-\\-\\- APFLST entries %-\\-\\-\n%Command ===>_ZCMD                                 \\ \\%Scroll ===>_amt +\n%\n%               `Sorted by|sortffn\n+S+DSName                                       Volume Errors\n%- -------------------------------------------- ------ -\\-\\-\n)Model\n_Z\u00acDSN                                         #vol   \u00a2err                  \\ \\\n)init\n  .Help = PROGXXA0\n  .ZVARS = '(TSEL)'\n  &AMT = PAGE\n)proc\n)end\n./ ADD NAME=PROGXXA0 1200-97137-97137-1812-00040-00040-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: PROGXXA0                                                   */\n /* Author: David Alcock                                             */\n /* Application: PROGxx                                              */\n /* Purpose: Tutorial panel for the PROGxxAT panel                   */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n)body expand(!!)\n%Tutorial !-! PROGxx Edit macro !-! Tutorial\n%Command ===>_ZCMD                                                             +\n+\nThis panels shows a list of the APF entries we found.  It accepts these primary\ncommands on the command line:\n\n  `SORT\u00a2Sort the table by one of these operands:~DSN VOL ERR NUM\n\n  `REPORT\u00a2Generate a report showing the Dataset name, volume and error and write\n         \u00a2it to the ISPF list file.  It will be written in the current sort\n         \u00a2order.\n+\nOn each table entry for each APF library, you can enter one of these line\ncommands:\n\n  `S\u00a2Select the dataset for browse\n\n  `B\u00a2Select the dataset for browse\n\n  `P\u00a2Invoke the~PDS\u00a2command on the dataset on that volume\n+\nNote: Multiple row selection is not supported.\n)init\n)proc\n)end\n./ ADD NAME=PROGXXH0 1200-97137-97137-1812-00039-00039-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: PROGXXH0                                                   */\n /* Author: David Alcock                                             */\n /* Application: PROGxx                                              */\n /* Purpose: Top Tutorial panel for the PROGxx application           */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n)body expand(!!)\n%Tutorial !-! PROGxx Edit macro !-! Tutorial\n%Command ===>_ZCMD                                                             +\n+\nThe`PROGxx+edit macro allows you to maintain your SYS1.PARMLIB(PROGxx) APF\nentries easily.  Some features:\n\n-\u00a2Check the APFLST for syntax errors and see which entries are not\n  on the volumes specified as note and msg lines in the edit dataset.+\n-\u00a2Get a Table list for easy browsing and invoking the PDS command.+\n-\u00a2Sort the APFLST into an output dataset in PROGxx format.  Comments\n  are not preserved (future objective).\n+\nYou can select a smaller part of the APFLST using the SS range command.\n+\nSyntax:\n\n `PROGXX             +Syntax and volume checking only\n `PROGXX~LIST        +Syntax and volume checking.  The APFLST entries are placed\n                     +into an ISPF table for easy selection.\n `PROGXX~SORT        +Syntax and volume checking. The APFLST entries are sorted\n                     +and placed into a dataset in PROGxx format.\n)init\n)proc\n)end\n./ ADD NAME=PROGXXS  1200-97137-97137-1812-00033-00033-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: PROGXXS                                                    */\n /* Author: David Alcock                                             */\n /* Application: PROGxx                                              */\n /* Purpose: Status of processing the APFLST                         */\n /********************************************************************/\n #  type(text)   intens(high) color(yellow)\n \u00a2  type(text)   intens(low)  color(green)\n \u00ac  type(text)   intens(low)  color(green) hilite(reverse)\n `  type(text)   intens(high) color(yellow)\n {  type(output) intens(high) color(yellow) caps(off)\n }  type(output) intens(high) color(turq)   caps(off)\n ? area(dynamic)\n 01 type(dataout) color(blue)\n 02 type(dataout) color(white)  intens(high)\n 03 type(dataout) color(yellow) intens(high)\n 04 type(dataout) color(turq)   intens(high)\n 05 type(dataout) color(red)    intens(high)\n 06 type(dataout) color(green)  intens(high)\n 0B type(dataout) color(blue)                 hilite(blink)\n 0C type(dataout) color(white)  intens(high)  hilite(blink)\n 0D type(dataout) color(yellow) intens(high)  hilite(blink)\n 0E type(dataout) color(turq)   intens(high)  hilite(blink)\n 0F type(dataout) color(red)    intens(high)  hilite(blink)\n 10 type(dataout) color(green)  intens(high)  hilite(blink)\n)body window(70,3) expand(!!)\n?MSG1                                                               ?\n+\n?MSG2                                                               ?\n)init\n)proc\n)end\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 14:24 ON 98/01/16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SASGIF1": {"ttr": 25351, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x00\\x00 \\x00\\x99\\x06\\x0f\\x00\\x99\\x06\\x0f\\x14\\x14\\x00I\\x00I\\x00\\x00\\xc4\\xc1\\xe5\\xc5\\xc1@@@@@'", "ispf": {"version": "20.00", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "1999-03-01T14:14:20", "lines": 73, "newlines": 73, "modlines": 0, "user": "DAVEA"}, "text": "This sample job:\n- Creates an output GIF library large enough for a SAS-generated GIF\n  file\n- Invokes SAS to create a GIF file of the state of TEXAS using a\n  background of SAS's choosing\n\nTo use:\n- Change \"ibmuser\" to your userid\n\n// job card here\n//*----->   JCLLIB ORDER=(SAS609.TS450.PROCLIB)\n//*\n//** Create a new library for the SAS GIF file\n//*\n//NEWONE   EXEC PGM=IEFBR14\n//SYSUT2   DD DSN=ibmuser.SPFTEMP1.GIF,\n//            DISP=(,CATLG),UNIT=SYSDA,\n//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),\n//            SPACE=(CYL,(1,1,8))\n//*\n//** Invoke SAS to write out a GIF file of the Map of Texas\n//*\n// EXEC SAS609\n//MAPS  DD DISP=SHR,DSN=SAS.MAPS\n//SYSIN DD *\n     /*\n      | The IMGSIZE macro lets you modify the size of the image area\n      |    in pixel units.\n      |\n      |    Notes:\n      |       1. The dots per inch value (dpi) should be the same as\n      |          that used by the driver (dpi=xpixels/xmax).\n      |\n      |       2. The maximum width and height values specified as\n      |          parameters should not exceed the xmax and ymax values\n      |          of the device used. The default values used below\n      |          are arbitrary.\n      */\n     %macro IMGSIZE(w=1280, h=1024, dpi=95, rows=43, cols=83);\n\n        %if &dpi<=0 %then\n           %put DPI must be greater than zero.;\n        %else %do;\n           goptions hsize=%sysevalf(&w/&dpi)in vsize=%sysevalf(&h/&dpi)in\n                    hpos=&cols                 vpos=&rows;\n        %end;\n     %mend IMGSIZE;\n\n     filename out 'ibmuser.spftemp1.gif(texas)';\n     goptions dev=gif gsfname=out gsfmode=replace;\n     %imgsize(w=300, h=200, dpi=95, rows=30, cols=50);\ndata loc;\n     input st $ 1-2 loc;\n     state=stfips(st);\n     cards;\nTX   40\n     ;\ndata refiv;\n     set maps.states;\n     if state=stfips('TX');\nproc gproject data=refiv out=refiv;\n     id state;\nproc gmap data=loc map =refiv;\n     choro loc/levels=4;\n     id state;\n     pattern1 v=mempty c=green;\n     title .h=2 .c=blue .f=complex T E X A S;\n     footnote .h=2 .c=red .f=simplex The Lone Star State;\n/*\n//*\n//*\n//* At this point 'ibmuser.spftemp1.gif(texas)' has a GIF file\n//* generated by SAS that is ready for download to a PC.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SASGIF2": {"ttr": 25354, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x00\\x007\\x00\\x99\\x06\\x0f\\x00\\x99\\x06\\x0f\\x14\\x14\\x00_\\x00_\\x00\\x00\\xc4\\xc1\\xe5\\xc5\\xc1@@@@@'", "ispf": {"version": "20.00", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "1999-03-01T14:14:37", "lines": 95, "newlines": 95, "modlines": 0, "user": "DAVEA"}, "text": "This sample job:\n- Creates an output GIF library large enough for a SAS-generated GIF\n  file\n- Invokes SAS to create a GIF file of the state of TEXAS using a\n  transparent background\n\nTo use:\n- Change \"ibmuser\" to your userid\n\n// job card here\n//*-------> JCLLIB ORDER=(SAS609.TS450.PROCLIB)\n//*\n//** Create a new library for the SAS GIF file\n//*\n//DELIT    EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n DELETE 'ibmuser.SPFTEMP1.GIF'\n//*\n//** Create a new library for the SAS GIF file\n//*\n//NEWONE   EXEC PGM=IEFBR14\n//SYSUT2   DD DSN=ibmuser.SPFTEMP1.GIF,\n//            DISP=(,CATLG),UNIT=SYSDA,\n//            DCB=(LRECL=32756,BLKSIZE=32760,RECFM=VB),\n//            SPACE=(CYL,(1,1,8))\n//*\n//** Invoke SAS to write out a GIF file of the Map of Texas\n//*\n// EXEC SAS609\n//MAPS  DD DISP=SHR,DSN=SAS.MAPS\n//SYSIN DD *\n\n /*\n  | Ensure we have a transparent gif device around\n  */\n\n   libname gdevice0 'ibmuser.sas.data';\n   proc gdevice\n        catalog=gdevice0.devices\n        nofs;\n   copy gif from=sashelp.devices newname=giftrans;\n   mod giftrans ucc='01'x\n       description='GIF with Transparency';\n   list giftrans;\n   end;\n\n /*\n  | The IMGSIZE macro lets you modify the size of the image area\n  |    in pixel units.\n  |\n  |    Notes:\n  |       1. The dots per inch value (dpi) should be the same as\n  |          that used by the driver (dpi=xpixels/xmax).\n  |\n  |       2. The maximum width and height values specified as\n  |          parameters should not exceed the xmax and ymax values\n  |          of the device used. The default values used below\n  |          are arbitrary.\n  */\n     %macro IMGSIZE(w=1280, h=1024, dpi=95, rows=43, cols=83);\n\n        %if &dpi<=0 %then\n           %put DPI must be greater than zero.;\n        %else %do;\n           goptions hsize=%sysevalf(&w/&dpi)in vsize=%sysevalf(&h/&dpi)in\n                    hpos=&cols                 vpos=&rows;\n        %end;\n     %mend IMGSIZE;\n\n     filename out 'ibmuser.spftemp1.gif(texast)';\n     goptions dev=giftrans gsfname=out gsfmode=replace;\n     %imgsize(w=300, h=200, dpi=95, rows=30, cols=50);\ndata loc;\n     input st $ 1-2 loc;\n     state=stfips(st);\n     cards;\nTX   40\n     ;\ndata refiv;\n     set maps.states;\n     if state=stfips('TX');\nproc gproject data=refiv out=refiv;\n     id state;\nproc gmap data=loc map =refiv;\n     choro loc/levels=4;\n     id state;\n     pattern1 v=mempty c=green;\n     title .h=2 .c=blue .f=complex T E X A S;\n     footnote .h=2 .c=red .f=simplex The Lone Star State;\n/*\n//*\n//*\n//* At this point 'ibmuser.spftemp1.gif(texast)' has a GIF file\n//* generated by SAS that is ready for download to a PC.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWFDR": {"ttr": 25357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00H\\x01\\x020o\\x01\\x020o\\x144\\x00@\\x00\\x04\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T14:34:48", "lines": 64, "newlines": 4, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=SHOWFDR  0100-02306-02306-1337-00010-00010-00000-DAVE\n/* rexx */\naddress ispexec\n\"select panel(showfdrp)\"\nexit 0\n./ ADD NAME=SHOWFDRP 0100-02306-02306-1337-00010-00010-00000-DAVE\n)attr default(%+_)\n /********************************************************************/\n /* Name: SHOWFDRP                                                   */\n /* Author: David Alcock                                             */\n /* Purpose: Invoke the undocumented FDRDEBUG program from           */\n /*          Innovation (the FDR people).                            */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n ! type(text) intens(high) color(pink)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq) caps(off)\n \u00a6 type(output) intens(high) color(blue) caps(off)\n \\ type(text)   intens(high) color(red) hilite(blink)\n | area(scrl) extend(on)\n)body\n%------------------------------- \u00ac SHOWFDR % -----------------------------------\n%Option ===>_ZCMD                                                              +\n\n|menu                                                 | `Time     -~&ZTIME     +\n|                                                     | `Date     -~&ZDATE     +\n|                                                     |\n|                                                     |\n|                                                     |\n|                                                     |\n|                                                     |\n|                                                     |\n|                                                     |\n|                                                     |\n|                                                     |\n|                                                     |\n+\n~Enter an option above or use the#END~key to terminate application\n)Area menu\n# 1\u00a2SYS      -+System information\n# 2\u00a2LLA      -+LNKLST and LPALST information\n# 3\u00a2APF      -+APFLST\n# 4\u00a2LA       -+List Allocations\n# 5\u00a2LPA      -+LPA modules list\n# 6\u00a2NUC      -+Nucleus modules list\n)init\n)proc\n  if (&zcmd = &z)\n  &zsel = trans( trunc (&zcmd,'.')\n   /* All selections start here */\n        1,'cmd(FDRDEBUG VER)'\n        2,'cmd(FDRDEBUG LLA)'\n        3,'cmd(FDRDEBUG APF)'\n        4,'cmd(FDRDEBUG LA )'\n        5,'cmd(FDRDEBUG LPA)'\n        6,'cmd(FDRDEBUG NUC)'\n        x,'exit'\n        *,'?' )\n  &ztrail = .trail\n)end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWMRO": {"ttr": 25359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x00Y\\x00\\x99\\x06\\x0f\\x01\\x020o\\x181\\x01\\xd8\\x01\\x84\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:31:59", "lines": 472, "newlines": 388, "modlines": 0, "user": "IBMUSER"}, "text": "SHOWMRO TITLE  'Show the currently active MRO regions'\n*\n* Name: SHOWMRO\n*\n* Author: David Alcock :: dave@planetmvs.com\n*\n* Written: 1997-11-11\n*\n* Purpose: TSO command that shows all of the current CICS MRO regions.\n*\n* Reference:\n* - LY33-6082 CICS/ESA Diagnosis Reference Version 4 Release 1\n* - CICS.SDFHSRC(DFHIRPD) macro source. It is not used by this program\n*   for these reasons:\n*   - Assembly error for field MCNTL and I didn't look into why\n*   - Less things to be dependant on. Don't have to worry when IBM\n*     Changes the MACRO at release levels.\n*\n* Requirements:\n* - High Level Assembler\n* - MVS version 3 and higher (for entry and exit housekeeping)\n* - MVS version 4 and higher (for jobname information and STCKCON)\n* - CICS at 4.1.0 and higher\n*\n         SPACE 2\n&DAVRM   SETC  '1.2'\n*======================================================================\n*\n*             M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date       Ver Description\n* ---------- ---------- --- -------------------------------------------\n* DGAlcock   2000-07-31 1.2 Convert TOD stamp to local time&date;\n*                           Remove msgids;\n* RSchiradin 2000-04-25 1.1 Fix for CICS 5.3/CICS Transaction Server\n*                           version 1.3 (thanks to Roland Schiradin);\n* DGAlcock   1997-11-11 1.0 Initial program written;\n*======================================================================\n         PRINT NOGEN\n*\n** IBM DSECTs\n*\n         CVT   DSECT=YES,LIST=NO          Communications Vector Table\n         IEFJESCT                         JES Communications Table\n         IEFJSCVT ,                       Subsystem Comm. Vector table\n         IEFJSSVT ,                       Subsystem Vector Table\n         IHAASVT ,                        Address Space Vector Table\n         IHAASCB ,                        Address Space Control Block\n         IHAASSB ,                        Address Space Sec. Block\n         IAZJSAB ,\n         YREGS ,\n         PRINT GEN\n*\n** CICS: DFHSAB - CICS subsystem Anchor Block\n** (Based on CICS 4.1)\n*\nSAB      DSECT ,\nSABCDD   DS    F                          Addr of CEC 'inop' data\nSABSCTE  DS    F                          Addr of SCTE\nSAB_ID   DS    C'DFHSAB'                  Eyecatcher\n         ORG   SAB+X'18'\nSABMAPPT DS    F                          Addr of bit map: act CICS\n         ORG   ,\nSABL     EQU   32\n*\n** CICS: SCTE - Subsystem Control Table Extension\n** (Based on CICS 4.1)\n*\nSCTE     DSECT ,\nSCTELACB DS    F\n         DS    F\n         DS    F\nSCTESVC  DS    X'0A00'\n         DS    X'0000'\nSCTEL    EQU   *-SCTE\n*\n** CICS: LCB - Logon Control Block\n** (Based on CICS 4.1, updated for 5.3)\n*\nLCB      DSECT ,\n         ORG   LCB+X'60'\nLCBAPPLD53 DS  CL8' '\n         ORG   ,\n         ORG   LCB+X'7C'\nLCBAPPLD41 DS  CL8' '\n         ORG   ,\nLCBLNGTH EQU   X'D8'\n*\n** CICS: LACB - Logon Address Space Control Block\n** (Based on CICS 4.1, updated for 5.3)\n*\nLACB     DSECT ,\n         ORG   LACB+X'08'                                        RS0400\nLACBSUD2 DS    F               SUDB ptr for CICS 5.3/CTS 1.3     RS0400\nLACBSUDB DS    F               SUDB ptr for CICS 4.1\nLACBL    EQU   X'58'\n*\nLACBE    DSECT ,\nLACBENM  DS    CL8\nLACBELEN EQU   X'14'\n*\n** CICS: SUDB - SubSystem User Definition Control Block\n** (Based on CICS 4.1)\n*\nSUDB     DSECT ,\nSUDBCHN  DS    A\nSUDBLACB DS    A\n         ORG   SUDB+X'0E'\n         DS    H\n         DS    F\nSUDBASCB DS    F\nSUDBJSB  DS    F\nSUDBAWS  DS    F\nSUDBLCB  DS    F\n         ORG   ,\nSUDBLEN  EQU   X'58'\n*\n** Convert assembly date from format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n*\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***\n**       Entry housekeeping\n***\n***********************************************************************\n         SPACE 2\nSHOWMRO  CSECT ,\nSHOWMRO  AMODE 31\nSHOWMRO  RMODE ANY\n*\n** Standard O/S eyecatcher\n*\nSM_EC    B    SM_ECL(0,R15)             Bump past EyeCatcher\n         DC   AL1(SM_ECE-SM_ECV)        Length of eyecatcher\nSM_ECV   DC   C'SHOWMRO v&DAVRM - &ASMDATE &SYSTIME - '\n         DC   C'TSO command: Show CICS MRO regions via C.B.s'\nSM_ECE   EQU  *\n         DS   0H\nSM_ECL   EQU  *-SM_EC\n*\n** Standard ESA entry housekeeping\n*\n         BAKR  R14,0                    Save regs\n         LAE   R12,0(R15,0)             Get base register\n         USING SHOWMRO,R12              Get addressibility\n         SAC   0\n         SYSSTATE ASCENV=P\n*\n** Obtain Dynamic Save Area for Registers and work areas.\n*\n         STORAGE OBTAIN,LENGTH=DSAL,LOC=BELOW Obtain storage\n         LR    R13,R1                   Point to Save Area\n         MVC   4(4,R13),=C'F1SA'        Indicate stack SA\n         USING DSA,R13                  Get addressibility to area\n         MVI   FLAG1,0                  Ensure flags are not set\n         EJECT\n***********************************************************************\n***\n**   Locate to the first SUDB\n***\n***********************************************************************\n         SPACE 2\n*\n** Find the CICS subsystem and get the SSCTSUSE (DFHSAB) in R4\n*\n         L     R4,CVTPTR                  -> CVT\n         L     R4,CVTJESCT-CVTMAP(R4)     -> JESCT\n         L     R4,JESSSCT-JESCT(R4)       -> SSCVT\nFSS$L    DS    0H\n         CLC   SSCTSNAM-SSCT(4,R4),=C'CICS'  SubSystem Match?\n         BE    FSS$LX                        Yes, leave loop\n         ICM   R4,B'1111',SSCTSCTA-SSCT(R4)  Check next one out\n         BNZ   FSS$L                         Got one, repeat performanc\n         B     E$NSS                         SubSystem not found...\nFSS$LX   DS    0H                            SubSystem found\n         ICM   R4,B'1111',SSCTSUSE-SSCT(R4)  -> DFHSAB\n*\n** Locate the SCTE and issue the starting message (w/SVC number)\n*\n         ICM   R5,B'1111',SABSCTE-SAB(R4) Locate SCTE\n         BZ    E$NSCTE\n         MVC   MSG(MSG0L),MSG0\n         TPUT  MSG,MSG0L\n         MVI   MSG,C' '\n         TPUT  MSG,1\n         MVC   MSG(MSG1L),MSG1\n* Note: The SVC is in the machine code format \"0Axx\" or SVC xx\n         SLR   R1,R1\n         IC    R1,SCTESVC+1-SCTE(R5)      Get the SVC\n         CVD   R1,DOUBLE\n         UNPK  MSG+MSG1SVCD-1-MSG1(4),DOUBLE+6(2)\n         OI    MSG+MSG1SVCD+2-MSG1,C'0'\n         MVI   MSG+MSG1SVCD-1-MSG1,C'='\n*\n         UNPK  MSG+MSG1SVCH-MSG1(3),SCTESVC+1-SCTE(2,R5)\n         MVZ   MSG+MSG1SVCH-MSG1(2),=8X'00'\n         TR    MSG+MSG1SVCH-MSG1(2),=C'0123456789abcdef'\n         MVI   MSG+MSG1SVCF-MSG1,C')'\n*\n         L     R1,CVTPTR                  -> CVT\n         MVC   MSG+MSG1SYS-MSG1(L'CVTSNAME),CVTSNAME-CVTMAP(R1)\n         TPUT  MSG,MSG1L\n         MVI   MSG,C' '\n         TPUT  MSG,1\n*\n** Locate the LACB (Logon Address Space Control Block)\n*\n         ICM   R6,B'1111',SCTELACB-SCTE(R5)  Locate LACB\n         BZ    E$NLACB\n*\n** Locate the first SUDB\n*\n         ICM   R7,B'1111',LACBSUDB-LACB(R6) Locate SUDB\n         BZ    E$NSUDB\n         CLC   4(4,R6),=F'0'                CICS 5.3/CTS 1.3?  RS0400\n         BNE   FSS$LXX                      No                 RS0400\n         OI    FLAG1,$F1_53                 Turn on Flag\n         ICM   R7,B'1111',LACBSUD2-LACB(R6) Locate SUDB        RS0400\n         BZ    E$NSUDB                      None!              RS0400\nFSS$LXX  DS    0H                                              RS0400\n* Note: After this point R4, R5, R6 are freed up. Only R7 matters.\n         EJECT\n***********************************************************************\n***\n**       Process all of the SUDBs\n***\n***********************************************************************\n         SPACE 2\n         XC    PS_MROC(4),PS_MROC           Ensure we start at zero\nPS$L     DS    0H\n         ICM   R1,B'1111',SUDBCHN-SUDB(R7)  On the last one?\n         BZ    PS$X                         Yes, Leave\n*\n         ICM   R8,B'1111',SUDBLCB-SUDB(R7)  LCB pointer\n         BZ    PS$LB                        None, skip this entry\n*\n         L     R1,PS_MROC                   Get MRO region count\n         LA    R1,1(R1)                     Bump by one\n         ST    R1,PS_MROC                   Save for later\n*\n         LA    R15,MSG\n         MVC   0(MSG2L,R15),MSG2\n*\n         ST    R7,SAVEREGS\n         UNPK  MSG2SUDB-MSG2(9,R15),SAVEREGS(5)\n         MVZ   MSG2SUDB-MSG2(8,R15),=8X'00'\n         TR    MSG2SUDB-MSG2(8,R15),=C'0123456789ABCDEF'\n         MVI   MSG2SUDB-MSG2+8(R15),C' '\n*\n         ICM   R9,B'1111',SUDBASCB-SUDB(R7) ASCB pointer\n         L     R9,ASCBASSB-ASCB(,R9)        -> ASSB\n         L     R9,ASSBJSAB-ASSB(,R9)        -> JSAB\n         MVC   MSG2JOBI-MSG2(8,R15),JSABJBID-JSAB(R9)\n         MVC   MSG2JOBN-MSG2(8,R15),JSABJBNM-JSAB(R9)\n*\n         TM    FLAG1,$F1_53                 At 5.3 or higher?\n         BO    M2A53\n         MVC   MSG2APPL-MSG2(8,R15),LCBAPPLD41-LCB(R8)\n         B     M2A53X\nM2A53    DS    0H\n         MVC   MSG2APPL-MSG2(8,R15),LCBAPPLD53-LCB(R8)\nM2A53X   DS    0H\n*\n** Get the CICS region start time and date\n*\n         STM   R2,R7,SAVEREGS      We eat up dem registers!\n         ICM   R9,B'1111',SUDBASCB-SUDB(R7) ASCB pointer\n         LM    R2,R3,ASCBINTS-ASCB(R9) Get start time\n*\n** Adjust the TOD stamp for GMT\n*\n*-This code was \"liberated\" from SYS1.V2R5M0.SHASSRC(HASCSRIC):\n*        LR    R2,R0               Save high order TOD value\n*        LR    R3,R1               Save low order TOD value\n         SPACE 1\n         L     R5,CVTPTR           Get CVT addressability\n         L     R5,CVTEXT2-CVT(,R5)  Get address of extension\n         LM    R14,R15,CVTLDTO-CVTXTNT2(R5)  Time zone diff\n         LM    R6,R7,CVTLSO-CVTXTNT2(R5)  Get leap seconds\n         SPACE 1\n         ALR   R3,R15              Add low order time offset\n         BC    12,PS$ATODV         Branch if no overflow\n         AL    R2,=F'1'            Carry the 1\nPS$ATODV ALR   R2,R14              Add high order words\n         SPACE 1\n         SLR   R3,R7               Subtract low-order leap seconds\n         BC    3,PS$ATODB          Branch if no borrow\n         BCTR  R2,0                Subtract one for borrow\nPS$ATODB SLR   R2,R6               Subtract high-order leap seconds\n         STM   R2,R3,PS_TOD        Save adjusted time\n*ST R8,DOUBLE\n*LA R15,MSG+MSG2APPL-MSG2\n*UNPK 0(9,R15),DOUBLE(5)\n*MVZ 0(8,R15),=8X'00'\n*TR  0(8,R15),=C'0123456789ABCDEF'\n*MVI 8(R15),C' '\n         LM    R2,R7,SAVEREGS\n*\n** Convert the region start time and date\n*\n         STCKCONV STCKVAL=PS_TOD,         Convert this TOD Stamp       @\n               CONVVAL=PS_SOUT,           ..Into these date/time areas @\n               TIMETYPE=DEC,              ..Output time format         @\n               DATETYPE=YYYYMMDD,         ..Output Date format         @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    STCKCONV worked?\n         BNZ   PS$SCE                     Failed: give up\n         LA    R15,MSG+(MSG2DATE-MSG2)\n*                            0  1  2  3  4  5  6  7  8  9  0\n*                               Y  Y  Y  Y  -  M  M  -  D  D\n         MVC   0(11,R15),=X'40,21,20,20,20,60,20,20,60,20,20'\n         ED    0(11,R15),PS_SOUT+8        Edit it to \" ccyy-mm-dd\"\n         OI    6(R15),X'F0'               Ensure leading zero\n         OI    9(R15),X'F0'               Ensure leading zero\n         LA    R15,MSG+(MSG2TIME-MSG2)\n*                             H H : M M\n         MVC   0(6,R15),=X'F021207A2020'\n         ED    0(6,R15),PS_SOUT\n         MVI   0(R15),C' '\n         B     PS$SCX\nPS$SCE   DS    0H\n         LA    R15,MSG+MSG2L              Locate output area\n         MVI   0(R15),C' '\n         MVC   1(21,R15),0(R15)\nPS$SCX   DS    0H\n*\n** Print message\n*\n         TPUT  MSG,MSG2L\n*\n** Bump to next SUDB\n*\nPS$LB    DS    0H\n         ICM   R7,B'1111',SUDBCHN-SUDB(R7)\n         BNZ   PS$L\n*\n** The end of the SUDB chain - print number of MRO regions found\n*\nPS$X     DS    0H\n         MVI   MSG,C' '\n         TPUT  MSG,1\n         MVC   MSG(MSG3L),MSG3\n         LA    R15,MSG+MSG3L-1\n         ICM   R1,B'1111',PS_MROC\n         CVD   R1,DOUBLE\n         UNPK  0(4,R15),DOUBLE+6(2)\n         OI    3(R15),C'0'\n         MVI   MSG+MSG3L-1,C'='\n         TPUT  MSG,MSG3L+3\n         EJECT\n***********************************************************************\n***\n**       Exit Housekeeping\n**\n**       Release resources and return to caller\n***\n***********************************************************************\n         SPACE 2\nEXIT     DS    0H\n         LR    R2,R13                     Get storage address\n         STORAGE RELEASE,LENGTH=DSAL,ADDR=(R2) Release storage\n         SLR   R15,R15                    Set return code\n         PR                               Return to caller\n         EJECT ,\n***********************************************************************\n***\n**       Error routines\n***\n***********************************************************************\n         SPACE 2\n*\n** SUDB not found\n*\nE$NSUDB  DS    0H\n         MVC   MSG(MSG96L),MSG96\n         TPUT  MSG,MSG96L\n         B     EXIT\n*\n** LACB not found\n*\nE$NLACB  DS    0H\n         MVC   MSG(MSG97L),MSG97\n         TPUT  MSG,MSG97L\n         B     EXIT\n*\n** SCTE not found\n*\nE$NSCTE  DS    0H\n         MVC   MSG(MSG98L),MSG98\n         TPUT  MSG,MSG98L\n         B     EXIT\n*\n** Sub system for CICS not found\n*\nE$NSS    DS    0H\n         MVC   MSG(MSG99L),MSG99\n         TPUT  MSG,MSG99L\n         B     EXIT\n         EJECT\n***********************************************************************\n***\n**       Constants\n***\n***********************************************************************\n         SPACE 2\n         LTORG ,\nMSG0     DC    C'SHOWMRO - V&DAVRM - Freeware! - Show CICS MRO '\n         DC    C'regions'\nMSG0L    EQU   *-MSG0\n*\nMSG1     DC    C'CICS SRB SVC '\nMSG1SVCD DC    C'xxx'\n         DC    C' ('\nMSG1SVCH DC    C'xx'\nMSG1SVCF DC    C')  - System=' '\nMSG1SYS  DS    CL(L'CVTSNAME)\n         DC    C' - active MRO regions:'\nMSG1L    EQU   *-MSG1\n*\nMSG2     EQU   *\nMSG2JOBI DC    CL8' '\n         DC    C' '\nMSG2JOBN DC    CL8' '\n         DC    C' - APPL='\nMSG2APPL DC    CL8' '\n         DC    C' -'\nMSG2DATE DC    C' 2000-07-31'\nMSG2TIME DC    C' HH:MM'\n         DC    C' - SUDB='\nMSG2SUDB DC    CL8' '\nMSG2L    EQU   *-MSG2\n*\nMSG3     DC    C'The number of MRO regions='\nMSG3L    EQU   *-MSG3\n*\nMSG96    DC    C'Error: SUDB not found '\nMSG96L   EQU   *-MSG96\n*\nMSG97    DC    C'Error: LACB not found '\nMSG97L   EQU   *-MSG97\n*\nMSG98    DC    C'Error: SCTE not found '\nMSG98L   EQU   *-MSG98\n*\nMSG99    DC    C'Error: CICS subsystem not found '\nMSG99L   EQU   *-MSG99\n         EJECT\n***********************************************************************\n***\n**       GETMAINed work area\n***\n***********************************************************************\n         SPACE 2\nDSA      DSECT ,\n         DS    18F                      Register Save Area\nPARMLIST DS    XL64                     Work area for parm lists\n         DS    0D                       Process_SUDBs:\nPS_TOD   DS    D                        ..TOD (STCK) area\nPS_SOUT  DS    XL16                     ..STCKCON output area\nPS_MROC  DS    F                        ..Count of MRO regions\nSAVEREGS DS    6F                       Save registers for routine\n         DS    0D\nDOUBLE   DS    D                        Work area\nFLAG1    DS    B'00000000'              Flag 1\n$F1_53   EQU   B'10000000'              ..At 5.3?\n*\nMSG      DS    79C' '                   Message area\n         DS    0D\nDSAL     EQU   *-DSA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWSYM": {"ttr": 25608, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x14\\x03\\x00'\\x00\\x99\\x06\\x0f\\x01\\x020o\\x183\\x01\\xfd\\x01\\xe6\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:33:27", "lines": 509, "newlines": 486, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 1000-97137-97137-1812-00038-00038-00000-DALCOCK\n SHOWSYM edit macro v1.0 - 22-MAR-1997\n\n This package contains an edit macro that can be used to show the\n symbol substitutions that are in MVS v5 and higher.  You will\n need to assemble program RYSYMBM *BEFORE* executing SHOWSYM.\n\n File contents:\n\n $$README ... This member\n SHOWSYM  ... Edit macro - place in your SYSPROC or SYSEXEC\n RYSYMBM  ... Assembler program that invokes IBM's ASASYMBM program\n SAMPLE   ... A sample member that has some symbols that can be used\n              to test SHOWSYM\n Z$EXAMP1 ... Sample assembler program that is based on example 1\n              ASASYMBM program found in the MVS 5.2.2 Assembler guide\n              manual.\n\n I *MAY* convert program RYSYMBM to a REXX function. At that time it\n will be renamed to RXSYMBM.\n\n =====================================================================\n\n The contents of this file are FREEWARE.  Use at your own risk.  It\n is provided for your enjoyment and neither David Alcock or his\n employer provides any warranty for their use.  I'd like to hear\n feedback on how they work on your system:\n\n    David Alcock :: dave@planetmvs.com\n\n =====================================================================\n./ ADD NAME=RYSYMBM  1000-97137-97137-1812-00180-00180-00000-DALCOCK\n*\n* Name: RySYMBM\n*\n* Author: David Alcock :: dave@planetmvs.com\n*\n* Date Written: 22-MAR-1997 - (a Saturday, get a life Dave)\n*\n* Purpose: Invokes IBM's ASASYMBM, symbol substitution routine\n*\n*          Temp: Get value from parm list and return to var RYSYMBM\n*          Perm: REXX function (and rename this to RXSYMBM)\n*\n* Disclaimer: This progam is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 1997-2002+ by David Alcock\n*             All rights reserved.\n*\n         ASASYMBP   ,                     Mapping of SYMBP area\n         PRINT NOGEN\n         CVT DSECT=YES,LIST=NO            Commuications Vector Table\n         IKJCPPL ,                        IBM: Cmd Processor Parm List\n         IKJTSVT ,                        TSO Vector Table\n         YREGS ,\n         PRINT GEN\n*\n** Standard housekeeping (ESA and higher)\n*\nRYSYMBM  CSECT ,\nRYSYMBM  AMODE 31\nRYSYMBM  RMODE ANY\n         BAKR R14,R0\n         LR   R12,R15\n         USING RYSYMBM,R12\n         SAC  0\n         SYSSTATE ASCENV=P\n         STORAGE OBTAIN,LENGTH=DSAL,LOC=BELOW Obtain storage\n         LR   R13,R1                    Point to Save Area\n         MVC  4(4,R13),=C'F1SA'         Indicate stack SA\n         USING DSA,R13\n*\n** Get the input text\n*\nPROCESS_PARAMETER DS 0H\n EREG  R0,R1                            Restore regs 0 and 1\n TM    CPPLCBUF-CPPL(R1),X'80'            Was this command called?\n BNO   PP$NC                              No, need to look at CBUF\n*-We were called, it has a Batch type (EXEC) parameter\n L     R2,0(R1)                           Get address of parm\n SLR   R3,R3                              Clear register\n ICM   R3,B'0011',0(R2)                   Get length of parm\n BZ    NOINPUT                            None, leave\n LA    R2,2(R2)                           Bump past parm length HW\n B     PP$PARSE                           Parse the input\n*-We are a TSO command processor\nPP$NC EQU   *\n L     R2,CPPLCBUF-CPPL(R1)               Locate Command Buffer\n SLR   R3,R3                              Clear register\n ICM   R3,B'0011',0(R2)                   Get total CBUF length\n SLR   R0,R0                              Clear register\n ICM   R0,B'0011',2(R2)                   Get total Command name length\n LA    R15,4                              Length of header\n AR    R2,R15                             Bump past header\n SR    R3,R15                             Decrement for header length\n AR    R2,R0                              Bump past Command length\n SR    R3,R0                              Length of data\n*-R2 - Address of command-buffer/Parameter\n*-R3 - Length of command-buffer/Parameter\nPP$PARSE EQU *\n LTR   R3,R3                              Check out length\n BZ    NOINPUT                            Length = Zero: Leave\n BM    NOINPUT                            Length < Zero: Leave\n*\n** Load in the routine\n*\n         LOAD EPLOC==CL8'ASASYMBM',ERRET=LOADERR Load routine\n         ST   R0,EP_ASASYMBM            Save entry point\n*\n** Setup parameter list and call ASASYMBM\n*\n         LA    R1,MYSYMBP\n         USING SYMBP,R1\n         XC    SYMBP(SYMBP_LEN),SYMBP   Initialize to zero\n         ST    R2,SYMBPPATTERN@         Save input text address\n         ST    R3,SYMBPPATTERNLENGTH    Save input text length\n         LA    R14,TARGET               Address of target\n         MVI   0(R14),C' '\n         MVC   1(L'TARGET-1,R14),0(R14)\n         ST    R14,SYMBPTARGET@         Save in SYMBP area\n         LA    R14,L'TARGET             Get length of target area\n         ST    R14,TARGETLENGTH        Save it\n         LA    R14,TARGETLENGTH         Address of target length\n         ST    R14,SYMBPTARGETLENGTH@   Save in SYMBP area\n         LA    R14,RETURNCODE           Address of return code\n         ST    R14,SYMBPRETURNCODE@     Save in SYMBP area\n         DROP  R1\n         L     R15,EP_ASASYMBM          Get EPA of routine\n         BASR  R14,R15                  Call it\n*\n** If everything looks okay, update the target REXX variable\n*\n         ICM   R15,B'1111',RETURNCODE   Get ASASYMBM return code\n         BNZ   EXIT                     Oops...\n*\n         LA    R14,TARGET+L'TARGET-1      Locate last byte\nSUBL     DS    0H\n         CLI   0(R14),C' '                Blank?\n         BNE   SUBLX                      No, end of the line\n         BCTR  R14,0                      Yes, backup one more\n         B     SUBL                       ..and try next byte\nSUBLX    DS    0H\n         LA    R15,TARGET                 Locate start\n         LA    R14,1(R14)                 Don't make relative to 0\n         SR    R14,R15                    Length = end - start\n*\n         LA    R1,PV_NAMEV                Locate varable name\n         MVC   0(7,R1),=C'RYSYMBM'        Get value\n         ST    R1,PV_NAMEP                Save pointer\n         MVC   PV_NAMEL(4),=F'7'          Set variable name length\n         LA    R1,TARGET                  Locate value\n         ST    R1,PV_VALUEP               Save value pointer\n         ST    R14,PV_VALUEL              Save value length\n         L     R15,CVTPTR                 -> CVT\n         L     R15,CVTTVT-CVTMAP(R15)     -> TSVT\n         L     R15,TSVTVACC-TSVT(,R15)    -> CLIST Variable routine\n         CALL  (15),(=A(TSVEUPDT),        Call IKJCT441: Variable updt @\n               PV_NAMEP,                  ..Pointer to name            @\n               PV_NAMEL,                  ..Length of name             @\n               PV_VALUEP,                 ..Pointer to variable value  @\n               PV_VALUEL,                 ..Length of variable         @\n               PV_TOKEN),                 ..Token (not used by us)     @\n               VL,MF=(E,PARMLIST)\n         LTR   R15,R15\n         BZ    EXIT\n         MVC   RETURNCODE(4),=F'1001'     Set RC that var create failed\n*\n** Termination\n*\nEXIT     DS    0H\n         DELETE EPLOC==CL8'ASASYMBM'\nX$NMOD   DS    0H\n         LR    R2,R13                     Get storage address\n         L     R3,RETURNCODE            Get ASASYMBM return code\n         STORAGE RELEASE,LENGTH=DSAL,ADDR=(R2) Release storage\n         LR    R15,R3                     Get Return code of ASASYMBM\n         PR    ,                          Return to caller\n*\n** Error: Could not find the routine, should not happen in MVS 5.2.2\n**        and higher\n*\nLOADERR  DS    0H\n         MVC   RETURNCODE(4),=F'1000'\n         B     X$NMOD\n*\n** Error: No input to program\n*\nNOINPUT  DS    0H\n         MVC   RETURNCODE(4),=F'1002'\n         B     X$NMOD\n*\n** Literals\n*\n         LTORG ,\n*\n** Dynamic Save Area\n*\nDSA          DSECT\n             DS    18F\nEP_ASASYMBM  DS    F\nPARMLIST     DS    10F\n** CLIST Variable Set/Create routine\nPV_TOKEN     DS    F                      Return code\nPV_VALUEP    DS    F                      Value pointer\nPV_VALUEL    DS    F                      Value length\nPV_NAMEP     DS    F                      Pointer to CLIST Var name\nPV_NAMEL     DS    F                      Name length\nPV_NAMEV     DS    CL8'RXSYMBM'           Name value\n*\nMYSYMBP      DS    CL(SYMBP_LEN)       SYMBP area\nRETURNCODE   DS    F                   Return code\nTARGETLENGTH DS    F                   Length of target\nTARGET       DS    CL256\nDSAL         EQU   *-DSA\n         END   ,\n./ ADD NAME=SAMPLE   1000-97137-97137-1812-00022-00022-00000-DALCOCK\nThis is a sample member that you can use to test SHOWSYM.\n\nThe sysplex name is &SYSPLEX\nThe sysclone is &SYSCLONE\nThe sysname is &SYSNAME\n\n&DAY.       &LDAY.\n&HHMMSS.    &LHHMMSS.\n&HR.        &LHR.\n&JDAY.      &LJDAY.\n&MIN.       &LMIN.\n&MON.       &LMON\n&SEC.       &LSEC.\n&WDAY.      &LWDAY.\n&YR2.       &LYR2.\n&YR4.       &LYR4.\n&YYMMDD.    &LYYMMDD.\n\n&JOBNAME.\n&SEQ.\n\nThis line has some 'Single quotes' which we can't insert &SYSPLEX\n./ ADD NAME=SHOWSYM  1000-97137-97137-1812-00121-00121-00000-DALCOCK\n/* REXX\n |\n | Name: SHOWSYM\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: This edit macro processes line input which is selected by\n |          a single \"s\", range \"ss\" or the whole dataset and calls\n |          IBM's symbol substitution routine ASASYMBP.\n |\n |          The results of the substitution (if it was done) will be\n |          shown in the edit/view dataset as message lines.\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1997-2002+ by David Alcock\n |             All rights reserved.\n */\n\n/**********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Ver  Description                           **\n** ---------- ----------- ---- ------------------------------------- **\n** DGAlcock   22-MAR-1997 v1.0 Initial REXX exec created             **\n***                                                                 ***\n**********************************************************************/\n\ndebug = 0\n\naddress ISREDIT\n'MACRO (PARMS) NOPROCESS'\nparms = translate(parms)\nif parms == '?' | parms = \"HELP\" then do\n   say \"SHOWSYM shows symbol substition for ISPF edit lines\"\n   exit\n   end\n\n/*---------------------------------------------------------------------\n | Process line commands for S/SS/S99999\n ------------------------------------------------------------------- */\n\n'PROCESS RANGE S'\nselect\n  when rc = 0 then do\n       '(CMD) = RANGE_CMD'          /* Get the command    */\n       '(LINE1) = LINENUM .ZFRANGE' /* Get first in range */\n       '(LINE2) = LINENUM .ZLRANGE' /* Get last in range  */\n       end\n  when rc <= 4 then do /* No S or SS entered, use entire file     */\n       '(CMD) = RANGE_CMD'          /* Get the command    */\n       '(LINE1) = LINENUM .ZFIRST'  /* Get first in range */\n       '(LINE2) = LINENUM .ZLAST'   /* Get last in range  */\n       end\n  otherwise  /* Line command conflict - Edit will create message  */\n       exit 12\nend /* of \"select\" */\n\n/*---------------------------------------------------------------------\n | Process the selected lines for apf entries\n ------------------------------------------------------------------- */\n\naddress ISREDIT\n\"(ICAPS) = CAPS\"  /* save caps type upon entry */\n\"CAPS = OFF\"      /* Ensure mixed case for note/msg lines */\n\nfirstone = 0\nsub_number = 0\nsquote = \"'\"\ndquote = '\"'\n\ndo i = line1 to line2\n   '(LINEVAL) = LINE' i   /* Get edit line */\n\n   lineval = strip(lineval)\n   if lineval == \"\" then iterate   /* Don't bother if nothing there */\n\n   address TSO \"RYSYMBM \"lineval\n   asasymbm_rc = rc\n\n   if asasymbm_rc <> 0 then do\n      say \"Call to RYSYMBM had an error on line \"i\n      if asasymbm_rc < 1000 then say \"> ASASYMBM rc=\"asasymbm_rc\n      else select\n              when asasymbm_rc == 1000 then ,\n                   say \"> ASASYMBM routine could not be loaded\"\n              when asasymbm_rc == 1001 then ,\n                   say \">RYSYMBM pgm could not create variable RYSYMBM\"\n              when asasymbm_rc == 1002 then ,\n                   say \"> You didn't give any input to pgm RYSYMBM\"\n              otherwise\n                   say \"> Unknown RYSYMBM rc=\"asasymbm_rc\n            end\n      iterate\n      end\n\n  if rysymbm <> lineval then do\n     if firstone = 0 then firstone = i\n     sub_number = sub_number + 1\n     if lastpos(squote,rysymbm) <> 0 then do\n        say \"here\"\n        rysymbm = translate(rysymbm,dquote,squote)\n        \"LINE_AFTER \"i\" = NOTELINE \" ,\n        \"'The input line had a single quote which was \" ,\n        \"changed to a double quote.'\"\n        end\n     \"LINE_AFTER \"i\" = MSGLINE '\"rysymbm\"'\"\n     end\n\n   end /* of \"do i = line1 to line 2\" - - - - - - - - - - - - - - - */\n\n\"CAPS = \"icaps /* Restore CAPS state upon entry */\nif sub_number <> 0 then do\n   zedsmsg = \"\"\n   zedlmsg = \"Symbols were substituted on \"sub_number\" lines\"\n   address ISPEXEC 'SETMSG MSG(ISRZ001)'\n   \"LOCATE\" firstone  /* locate to first substition line */\n   end\nelse do\n     zedsmsg = \"\"\n     zedlmsg = \"None of the input lines had any substitions\"\n     address ISPEXEC 'SETMSG MSG(ISRZ001)'\n     end\nexit\n./ ADD NAME=Z$EXAMP1 1000-97137-97137-1812-00124-00124-00000-DALCOCK\n*\n* Name: #SYMBM1\n*\n* Purpose: Sample invocation of IBM's ASASYMBM, symbol substitution.\n*          Based on Example 1 in GC28-1466 (MVS 5.2.2 assembler guide)\n*\n*          This program is meant to be executed on TSO\n*\n* Disclaimer: This progam is FREEWARE.  Use at your own risk.  It\n*             is provided for your enjoyment and neither David\n*             Alcock or his employer provides any warranty for it's\n*             use.  I'd like to hear how it works on your system.\n*\n*             This software is not in the public domain but is\n*             available free of charge and with source code\n*             provided.  It is copyright 1997-2002+ by David Alcock\n*             All rights reserved.\n*\n         ASASYMBP   ,              Mapping of SYMBP area\n         YREGS ,\n*\n** Standard housekeeping (ESA and higher)\n*\n#SYMBM1  CSECT ,\n#SYMBM1  AMODE 31\n#SYMBM1  RMODE ANY\n         BAKR R14,R0\n         LR   R12,R15\n         USING #SYMBM1,R12\n         SAC  0\n         SYSSTATE ASCENV=P\n         STORAGE OBTAIN,LENGTH=DSAL,LOC=BELOW Obtain storage\n         LR   R13,R1                    Point to Save Area\n         MVC  4(4,R13),=C'F1SA'         Indicate stack SA\n         USING DSA,R13\n*\n** Load in the routine\n*\n         LOAD EPLOC==CL8'ASASYMBM',ERRET=LOADERR Load routine\n         ST   R0,EP_ASASYMBM            Save entry point\n*\n** Setup parameter list and call ASASYMBM\n*\n         LA    3,MYSYMBP\n         USING SYMBP,3\n         XC    SYMBP(SYMBP_LEN),SYMBP   Initialize to zero\n         LA    4,PATTERN                Address of pattern\n         ST    4,SYMBPPATTERN@          Save in SYMBP area\n         LA    4,L'PATTERN              Length of pattern\n         ST    4,SYMBPPATTERNLENGTH     Save in SYMBP area\n         LA    4,TARGET                 Address of target\n         ST    4,SYMBPTARGET@           Save in SYMBP area\n         MVC   TARGETLENGTH,=A(L'TARGET)  Set length of target\n         LA    4,TARGETLENGTH           Address of target length\n         ST    4,SYMBPTARGETLENGTH@     Save in SYMBP area\n         LA    4,RETURNCODE             Address of return code\n         ST    4,SYMBPRETURNCODE@       Save in SYMBP area\n         DROP  3\n         LA    1,MYSYMBP                Locate area\n         L     R15,EP_ASASYMBM          Get EPA of routine\n         BASR  R14,R15                  Call it\n*\n** Print ASASYMBM return code\n*\n         LA    R15,MSGAREA\n         MVC   0(MSG3L,R15),MSG3\n         LA    R15,MSG3L(R15)\n         UNPK  0(9,R15),RETURNCODE(5)\n         MVZ   0(8,R15),=8X'00'\n         TR    0(8,R15),=C'0123456789ABCDEF'\n         TPUT  MSGAREA,MSG3L+8\n*\n** If everything looks okay, print the before and after messsages\n*\n         ICM   R15,B'1111',RETURNCODE   Get ASASYMBM return code\n         BNZ   EXIT                     Oops...\n         MVC   MSGAREA(MSG1L),MSG1\n         TPUT  MSGAREA,MSG1L\n         MVC   MSGAREA(L'MSG2),MSG2\n         MVC   MSGAREA+L'MSG2(L'PATTERN),TARGET\n         TPUT  MSGAREA,MSG2L\n*\n** Termination\n*\nEXIT     DS    0H\n         DELETE EPLOC==CL8'ASASYMBM'\nX$NMOD   DS    0H\n         LR    R2,R13                     Get storage address\n         STORAGE RELEASE,LENGTH=DSAL,ADDR=(R2) Release storage\n         PR                               Return to caller\n*\n** Error: Could not find the routine, should not happen in MVS 5.2.2\n**        and higher\n*\nLOADERR  DS    0H\n         MVC   MSGAREA(MSG4L),MSG4\n         TPUT  MSGAREA,MSG4L\n         B     X$NMOD\n*\n** Literals\n*\n         LTORG ,\n*\n* Note that to avoid the assembler substituting\n* for &SYSNAME, &YYMMDD, &HHMMSS, two ampersands are specified.\n* The resulting pattern, then, is actually\n*      USERID.&SYSNAME..D&YYMMDD..T&HHMMSS\n*\nMSG1         DC    C'Before: '\nPATTERN      DC    C'USERID.&&SYSNAME..D&&YYMMDD..T&&HHMMSS'\nMSG1L        EQU   *-MSG1\nMSG2         DC    C'After:  '\nMSG2L        EQU   L'MSG2+L'PATTERN\nMSG3         DC    C'#SYMBM1 - Call to ASASYMBM RC='\nMSG3L        EQU   *-MSG3\nMSG4         DC    C'#SYMBM1 - Could not load ASASYMBM'\nMSG4L        EQU   *-MSG4\n*\n** Dynamic Save Area\n*\nDSA          DSECT\n             DS    18F\nEP_ASASYMBM  DS    F\nMYSYMBP      DS    CL(SYMBP_LEN)       SYMBP area\nRETURNCODE   DS    F                   Return code\nTARGETLENGTH DS    F                   Length of target\nTARGET       DS    CL80 An area big enough to hold the target no\n*                       matter what is substituted. Since &DATE\n*                       and &TIME are not used, it need be no\n*                       longer than the pattern area.\nMSGAREA      DS    CL79\nDSAL         EQU   *-DSA\n         END   ,\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 14:32 ON 98/01/16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMFEXIT": {"ttr": 25863, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00\\x02\\x00\\x99\\x06\\x0f\\x01\\x020o\\x184\\x0f\\xef\\x0f\\xf3\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:34:02", "lines": 4079, "newlines": 4083, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 0100-98016-98016-1800-00022-00022-00000-DALCOCK\n The contents of this file are FREEWARE. Use at your own risk. It\n is provided for your enjoyment and neither David Alcock or his\n employer provides any warranty for their use.  I'd like to hear how\n they work on your system:\n\n    David Alcock :: dave@planetmvs.com\n\n    http://www.planetmvs.com/\n\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n This is collection of my SMF exits. I have attempted to remove all\n the installation code and have changed our company prefix for messages\n and such to \"XYZ\".  Please run on your test machine first.  It is quite\n possible that during my edit I could have deleted something useful.\n\n See the $SAMPLE member for a sample of the \"flower boxes\" created\n by my IEFACTRT routine.  I am strange one that likes to collect\n other peoples IEFACTRT \"flower boxes\" and have created mine based on\n what I have liked on others I've seen.\n./ ADD NAME=$SAMPLE  0100-98016-98016-1800-00068-00068-00000-DALCOCK\nXYZ120I ------------------------------------------------------------------------\n                       S t e p   E n d   S t a t i s t i c s\n\nStep Name: PHONE2W        Cond Code: S322         Start: 14-Jan-1998 10:12:02 AM\nStep  Num: 13             PGM  Name: IKJEFT01     End:   14-Jan-1998 10:40:37 AM\nCPU (TCB): 00:15:00.98                            Storage below 16M:        264k\nCPU (SRB): 00:00:00.03                            Storage above 16M:      4,356k\nTrans Act: 00:28:34.59                            Service Units:      33,376,337\nTape Mnts: 0                                      Total EXCPs:               532\n\nUnit-- DDName-- EXCP Count-- Blksize        Unit-- DDName-- EXCP Count-- Blksize\n0E24 D SYSEXEC             3  25,504        046A D SYU1802            59  32,600\n0EE2 D SYI1723            89   6,320        0EEC D OUT               162  25,550\n\nTotal DASD EXCPs:                313        Total Tape EXCPs:                  0\n\n---------------Paging---------------        ---------------Paging---------------\nPages In:                      1,271        Pages Out:                         0\nVIO Reclaims:                      0        Pages Stolen:                  5,604\n\nXYZ121I ------------------------------------------------------------------------\nXYZ111I-------------------------Start of ABEND information from MVS/Quickref\n\n   System ABEND: S322\n\n   Description:  This ABEND occurred because execution of a job, job step,\n                 or cataloged procedure step took more CPU time than was\n                 specified in the TIME parameter of an EXEC or JOB\n                 statement or the defaulted time set by the JES2 or JES3\n                 system.\n\n   User Action:  Correct the looping condition that caused excessive CPU\n                 time to be consumed.  If you think no loop exists,\n                 increase the CPU time limit value via the TIME= parameter\n                 and rerun the job.\n\nXYZ112I---------------------------End of ABEND information from MVS/Quickref\nIEF373I STEP /PHONE2W / START 1998014.1012\nIEF374I STEP/PHONE2W /STOP  1998014.1040 CPU   15MIN 00.98SEC SRB    0MIN 00.03S\nIEF272I ibmuser$ PHONE2D - STEP WAS NOT EXECUTED.\nIEF373I STEP /PHONE2D / START 1998014.1040\nIEF374I STEP/PHONE2D /STOP  1998014.1040 CPU    0MIN 00.00SEC SRB    0MIN 00.00S\nIEF272I ibmuser$ PHONE2C - STEP WAS NOT EXECUTED.\nIEF373I STEP /PHONE2C / START 1998014.1040\nIEF374I STEP/PHONE2C /STOP  1998014.1040 CPU    0MIN 00.00SEC SRB    0MIN 00.00S\nXYZ120I ------------------------------------------------------------------------\n                        J o b   E n d   S t a t i s t i c s\n\nJob  Name: ibmuser$       System ID: XYZ1        Submit: 14-Jan-1998 09:30:01 AM\nJob JESID: JOB03057       MVS level: SP6.0.2     Start:  14-Jan-1998 10:00:15 AM\nJob Class: Q                                     End:    14-Jan-1998 10:40:38 AM\nCPU (TCB): 00:15:42.97                           Storage below 16M:       1,588k\nCPU (SRB): 00:00:02.57                           Storage above 16M:      12,160k\nTrans Act: 00:40:11.85                           Service Units:       35,086,709\nTape Mnts: 2                                     Total EXCPs:             40,051\n\n---------------Paging---------------        ---------------Paging---------------\nVIO In:                            0        VIO Out:                           0\nPages In:                      1,271        Pages Out:                     1,271\nCommon (LPA+CSA):                  2        Hiperspace:                        0\nVIO Reclaims:                      0        Pages Stolen:                  8,069\n\nACF2 User: ibmuser                          Programmer: ALCOCK, DAVID\nAcct Info: D,D,D,SYS\n\nXYZ122I ------------------------------------------------------------------------\nIEF375I  JOB /ibmuser$/ START 1998014.1000\nIEF376I  JOB/ibmuser$/STOP  1998014.1040 CPU   15MIN 42.97SEC SRB    0MIN 02.57S\n./ ADD NAME=IEFACTRT 0100-98016-98016-1800-02463-02463-00000-DALCOCK\n** Needs ESTAEX !!!!!!\nIEFACTRT TITLE 'XYZ - Job/Step Termination SMF exit'\n***********************************************************************\n***                                                                 ***\n** Name = IEFACTRT                                                   **\n**                                                                   **\n** Author = David Alcock :: dave@planetmvs.com                       **\n**                                                                   **\n** Purpose = SMF step and job termination exit.                      **\n**                                                                   **\n**           This is an installation IEFACTRT that get invoked       **\n**           by SMF at step and job termination, it:                 **\n**           - Print step condition codes on the MVS console for     **\n**             operations.                                           **\n**           - Print TSO session information at logoff time          **\n**           - Print step and Job end statistics on the JES2 SYSMSGS **\n**             dataset - known as \"flower boxes\".                    **\n**           - Invoke MVS/Quickref to print system ABEND information **\n**             on the JES2 SYSMSGS dataset.  We will bypass QUICKREF **\n**             if a \"//ABNLIGNR DD DUMMY\" is found.                  **\n**                                                                   **\n**           Although invoked for other SMF record types, this exit  **\n**           only reacts to SMF 30 records.                          **\n**                                                                   **\n**  Reference:                                                       **\n**  - MVS v2  = GC28-1153 MVS/XA SPL System Management Facilities    **\n**  - MVS v4  = GC28-1637 MVS/ESA Installation Exits                 **\n**              GC28-1628 MVS/ESA System Management Facilities       **\n**                                                                   **\n**  Note = IBM states to tell IEFYS the SMB line address and length  **\n**         via this code:                                            **\n**                                                                   **\n**           MVC   36(4,12),MSGADDR  MOVE MESSAGE ADDRESS AND        **\n**           MVC   42(2,12),MSGLEN   LENGTH TO SYSTEM TABLE          **\n**                                                                   **\n**         This exit uses the actual DSECT to put the message address**\n**         and length into the LCT control block fields:             **\n**                                                                   **\n**                 LCTPARM1   DS A(0) - instead of 36(4,R12)         **\n**                 LCTPARM2+2 DS XL2  - instead of 42(2,R12)         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   13-JAN-1998 Use 4 digit year for TSO logon/logoff info **\n**                        lines; Check for MVS/Quickref version;     **\n** DGAlcock   28-FEB-1997 Add check for //ABNLIGNR DD DUMMY and      **\n**                        bypass MVS/QUICKREF if found;              **\n** DGAlcock   30-JAN-1997 Added step and job end statistics - known  **\n**                        as \"flower boxes\".                         **\n** DGAlcock   23-APR-1996 Print MVS/Quickref information for system  **\n**                        ABENDs on the SYSMSGS JES datasets;        **\n** DGAlcock   11-FEB-1996 MVS 4.3 upgrade and reassemble;            **\n** DGAlcock   17-SEP-1994 Don't print WTO for continuation records;  **\n**                        Change debugging TSO message by proc;      **\n** DGAlcock   01-SEP-1994 Added Novell-like login/logout messages at **\n**                        TSO logoff;                                **\n** DGAlcock   01-MAR-1994 Corrected SWAPS text length; Added debug   **\n**                        message XYZ109I; Added HiperSpace, LPA and **\n**                        VIO paging counts at TSO logoff time;      **\n** DGAlcock   20-MAY-1992 Added XYZ106I and XYZ107I to show step and **\n**                        job end messages on the operator console;  **\n** DGAlcock   08-APR-1992 Created this new version of IEFACTRT to    **\n**                        support Komand and the largely unmodified  **\n**                        IBM supplied version of IEFACTRT;          **\n***                                                                 ***\n***********************************************************************\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       IBM DSECTs                                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         PRINT NOGEN\nLCTD     DSECT ,\n         IEFALLCT                         Linkage Control Table\nSMSCT    DSECT ,\n         IEFASCTB ,                       Step Control Table\n         IEZWPL ,                         WTO Parameter List\n         IEFJMR ,                         Job management record\n         IEFUCBOB LIST=YES                Unit Control block\n         CVT    DSECT=YES,LIST=NO         Communications Vector Table\n         PRINT GEN\n         IFASMFR (30)                     SMF 30 record mapping\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Entry housekeeping                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Save registers and establish base registers\n*\nIEFACTRT CSECT ,\nIEFACTRT AMODE 31\nIEFACTRT RMODE ANY\n         SAVE  (14,12),,XYZ_SMFEXIT_IEFACTRT_&ASMDATE._&SYSTIME\n         LR    R11,R15                  Load program base register\n         LA    R10,4095                 Get 4096-1\n         LA    R10,1(R10,R11)           Addressability: 2nd base reg\n         LA    R9,4095                  Get 4096-1\n         LA    R9,1(R9,R10)             Addressability: 2nd base reg\n         USING IEFACTRT,R11,R10,R9      Establish base for program\n         USING LCTD,R12                 Establish LCT base\n*\n** Determine address space type and leave if we don't need this type\n*\n         L     R8,@ACTRT_SUBS-@ACTRT(R1)  Locate subsystem type\n         CLC   0(4,R8),=C'ASCH'           APPC?\n         BE    X$QUICKOUT\n         CLC   0(3,R8),=C'SYS'            System Address Space?\n         BE    X$QUICKOUT\n*\n** Determine if the reason we are called is worth pursuing:\n** - Must be for SMF 30 record (not other types)\n** - Leave for continuation records which we don't care about\n** - Ensure that IBM is giving us a subsystem section\n** - Leave if the subtype isn't 4 (Step Term) or 5 (Job Term)\n** - If a subtype 4 (step termination) then leave if TSO user\n*\n         L     R8,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         CLI   SMF30RTY-SMF30RPS(R8),30 Combined end?\n         BNE   X$QUICKOUT               No, Continue\n*\n         SLR   R14,R14                  Clear register for ICM\n         ICM   R14,B'0011',SMF30UON-SMF30RPS(R8) Continuation record?\n         BZ    X$QUICKOUT               Yes, don't process this record\n*\n         ICM   R14,B'0011',SMF30SON-SMF30RPS(R8) Num: Subsystem sects\n         BZ    X$QUICKOUT               Zero, Ignore record\n         ICM   R14,B'0011',SMF30SLN-SMF30RPS(R8) Len: SubSystem\n         BZ    X$QUICKOUT               Zero, Ignore record\n         ICM   R14,B'1111',SMF30SOF-SMF30RPS(R8) Offset: SubSystem\n         BZ    X$QUICKOUT               Zero, Ignore record\n         AR    R14,R8                   Locate Subsystem section\n*\n         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(4) Step Termination?\n         BNE   I$STEPX                  No, continue\n         L     R14,@ACTRT_JMR-@ACTRT(R1) Locate JMR\n         TM    JMRINDC-JMR(R14),JMRFIND TSO User (Foreground)?\n         BO    X$QUICKOUT               Yes, Leave\n         B     I$JOBX                   Continue (good record)\nI$STEPX  DS    0H\n         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(5) Job Termination?\n         BNE   X$QUICKOUT               No, leave\nI$JOBX   DS    0H\n*-At this point we have a SMF 30 record of subtype 4 or 5\n*\n         LR    R2,R0                    Save entry code\n         LR    R3,R1                    Save input parm list address\n*\n** Obtain Dynamic Storage Area (work area for IEFACTRT)\n*\n         L     R0,=A(DSAL)              Get length of area\n       GETMAIN RU,                      Obtain storage                 @\n               LV=(0),                  ..Length of area               @\n               SP=$DSA_SP,              ..Low private                  @\n               LOC=BELOW                ..Must be below the line\n*\n         XC    DSA_IS-DSA(DSA_IL,R1),DSA_IS-DSA(R1) Init to zeros\n*\n** Perform Forward/Backward RSA (Register Save Area) chaining\n*\n         ST    R13,4(,R1)               Save caller's RSA pointer\n         ST    R1,8(,R13)               Save our RSA pointer\n         LR    R13,R1                   Locate DSA/our RSA\n*\n         USING DSA,R13                  Establish addressability\n         MVC   DSAEC(16),=C'IEFACTRTWORKAREA' Eyecatcher for dumps\n         ST    R0,DSAGLEN               Save length of GETMAIN'd area\n         STM   R2,R3,IREGS              Save input registers R0 and R1\n*\n** Obtain fields needed by all SMF30 routines\n*\n         BAS   R14,R30CPU               Get CPU: T_TCB and T_SRB\n*-Locate ID section in the SMF30 record (if any)\n         SLR   R1,R1                    Clear for ICM\n         ICM   R1,B'0011',SMF30ILN-SMF30RPS(R8) Get length\n         BZ    I$IDX                    None, don't have it\n         ICM   R1,B'0011',SMF30ION-SMF30RPS(R8) Number of ID sections\n         BZ    I$IDX                    None, don't have any\n         ICM   R15,B'1111',SMF30IOF-SMF30RPS(R8) Get offset to ID sect\n         BZ    I$IDX                    No offset = no ID section\n         AR    R15,R8                   Locate section\n         ST    R15,A_IDSECT             Save address of ID section\nI$IDX    DS    0H\n*-Locate Storage section in the SMF30 record (if there)\n         SLR   R1,R1\n         ICM   R1,B'0011',SMF30RLN-SMF30RPS(R8) Length of section\n         BZ    I$STX                    Zero, Ignore it\n         ICM   R1,B'0011',SMF30RON-SMF30RPS(R8) Number of sections\n         BZ    I$STX                    Zero, Ignore it\n         ICM   R15,B'1111',SMF30ROF-SMF30RPS(R8) Offset\n         BZ    I$STX\n         AR    R15,R8                   Locate section\n         ST    R15,A_STSECT             Save address of Storage sect\nI$STX    DS    0H\n*-Locate Performance section in the SMF30 record (if there)\n         SLR   R1,R1\n         ICM   R1,B'0011',SMF30PLN-SMF30RPS(R8) Length of section\n         BZ    I$PERFX                  Zero, Ignore it\n         ICM   R1,B'0011',SMF30PON-SMF30RPS(R8) Number of sections\n         BZ    I$PERFX                  Zero, Ignore it\n         ICM   R15,B'1111',SMF30POF-SMF30RPS(R8) Offset\n         BZ    I$PERFX\n         AR    R15,R8                   Locate section\n         ST    R15,A_PRSECT             Save address of Storage sect\nI$PERFX  DS    0H\n*\n** Set the message area and length for the remainder of the step code\n** (except the MVS/Quickref code - but we exit after it)\n*\n         LA    R15,WLINE                Locate message area\n         ST    R15,LCTPARM1-LCTD(,R12)  Save msg location into LCT\n         LA    R15,80                   Get msg length\n         STH   R15,LCTPARM2+2-LCTD(,R12) Save msg length\n*\n** Process according to input SMF record type\n*\n         ICM   R14,B'1111',SMF30SOF-SMF30RPS(R8) Offset: SubSystem sect\n         AR    R14,R8                   Locate subsystem section\n         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(4) Step Termination?\n         BE    R30STEP                  Yes, continue\n         CLC   SMF30TYP-SMF30PSS(2,R14),=AL2(5) Job Termination?\n         BE    R30JOB                   Yes, continue\n         SPACE 2\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Common exit from IEFACTRT                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     DS    0H\n         L     R0,DSAGLEN               Get DSA length\n         LR    R1,R13                   Get DSA address\n         L     R13,4(,R1)               Load caller's RSA address\n*\n** Free GETMAINed work area\n*\n     FREEMAIN  RU,                      Free the storage               @\n               LV=(0),                  ..Length                       @\n               A=(1),                   ..Address                      @\n               SP=$DSA_SP               ..Subpool\n*\n** Return to caller\n*\nX$QUICKOUT DS  0H\n         LM    R14,R12,12(R13)          Load caller's registers\n         SLR   R15,R15                  Set return code - no cancel\n         SLR   R1,R1                    Write the dang record\n         BSM   0,R14                    Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       SMF 30 - Step Termination - non-TSO code                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nR30STEP  EQU   *\n         BAS   R14,FORMAT_COND_CODE     Format the Condition code\n         CLC   FCC_CDE(5),=C'FLUSH'     Step executed?\n         BE    EXIT                     No, continue\n*\n         BAS   R14,IGNORE_JOB           Ignore this job?\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Step End Statistics\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nR30_STEP_END_STATS DS 0H\n         ICM   R15,B'1111',=V(IEFYS)    Have the IBM SMB routine?\n         BZ    EXIT                     No, give up\n*\n** Print heading lines\n*\n         MVC   WLINE(MSG120L),MSG120    Get message\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*-\"S t e p   E n d   S t a t i s t i c s\"\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n         MVC   WLINE+23(C_ENDSTSL),C_ENDSTS Move in \"step end stat\"\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*-Blank line\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*\n** Data line 1\n*\n         MVC   WLINE_SESIC1D(10),=C'Step Name:'\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_STEPNAME-@ACTRT(R1) Locate step name\n         MVC   WLINE_SESIC1V(8),0(R1)    Get step name\n*\n         MVC   WLINE_SESIC2D(10),=C'Cond Code:'\n         MVC   WLINE_SESIC2V(5),FCC_CDE    Get condition code\n*\n         ICM   R14,B'1111',A_IDSECT     Locate ID section\n         BZ    R30SES$STODX             None?\n         MVC   WLINE_SESIC3DT(6),=C'Start:'\n         LA    R15,WLINE_SESIC3VT\n         ICM   R0,B'1111',SMF30SIT-SMF30ID(R14) <- Time\n         ICM   R1,B'1111',SMF30STD-SMF30ID(R14) <- Date\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\nR30SES$STODX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 2\n*\n         ICM   R14,B'1111',A_IDSECT     Locate ID section\n         BZ    R30SES$SNX               None?\n         MVC   WLINE_SESIC1D(10),=C'Step  Num:'\n         LA    R15,WLINE_SESIC1V        Locate to output area\n         SLR   R1,R1                    Clear register for ICM\n         ICM   R1,B'0011',SMF30STN-SMF30ID(R14) Get the step number\n         BAS   R14,EDITFWF              Edit the step number\n         LA    R15,WLINE\nR30SES$SNX DS  0H\n*\n         ICM   R14,B'1111',A_IDSECT     Locate ID section\n         BZ    R30SES$PNX               None?\n         MVC   WLINE_SESIC2D(10),=C'PGM  Name:'\n         MVC   WLINE_SESIC2V(8),SMF30PGM-SMF30ID(R14)\nR30SES$PNX DS  0H\n*\n         TIME  BIN                      Don't trust SMF record yet\n         MVC   WLINE_SESIC3DT(4),=C'End:'\n         LA    R15,WLINE_SESIC3VT\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 3\n*\n         LA    R15,WLINE_SESIC1V-2      Location for \"  hh:mm:ss.th\"\n         L     R1,T_TCB                 Get CPU time to edit\n         BAS   R14,FORMAT_CPUTIME       Format CPU time\n         MVC   WLINE_SESIC1D(10),=C'CPU (TCB):'\n*\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30SES$SBX               None, continue\n         L     R1,SMF30URB-SMF30SAP(R4) Get Storage below 16M\n         SRL   R1,10                    Get by 1024\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_SESIC3VS-1(12),EDPAT12 Get edit mask\n         ED    WLINE_SESIC3VS-1(12),DOUBLE+3 Edit storage\n         MVC   WLINE_SESIC3DST(18),=C'Storage below 16M:'\n         MVI   WLINE_SESIC3VSK,C'k'\nR30SES$SBX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 4\n*\n         LA    R15,WLINE_SESIC1V-2      Location for \"  hh:mm:ss.th\"\n         L     R1,T_SRB                 Get CPU time to edit\n         BAS   R14,FORMAT_CPUTIME       Format CPU time\n         MVC   WLINE_SESIC1D(10),=C'CPU (SRB):'\n*\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30SES$SAX               None, continue\n         L     R1,SMF30EUR-SMF30SAP(R4) Get storage above 16M\n         SRL   R1,10                    Get by 1024\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_SESIC3VS-1(12),EDPAT12 Get edit pattern\n         ED    WLINE_SESIC3VS-1(12),DOUBLE+3 Edit it\n         MVC   WLINE_SESIC3DST(18),=C'Storage above 16M:'\n         MVI   WLINE_SESIC3VSK,C'k'\nR30SES$SAX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 5\n*\n         ICM   R4,B'1111',A_PRSECT      Have a performance section?\n         BZ    R30SES$DL5X              No, continue\n*\n         SLR   R0,R0\n         ICM   R1,B'1111',SMF30TAT-SMF30PRF(R4)  Get trans active\n         SLDL  R0,10\n         BAS   R14,CONVERT_MICRO_SECONDS Convert micro seconds\n*                                          h h : m m : s s . t h\n*                                      0 1 2 3 4 5 6 7 8 9 0 1 2\n         MVC   WLINE_SESIC1V-2(13),=X'402120207A20207A20204B2020'\n         ED    WLINE_SESIC1V-2(13),DOUBLE+1\n         MVC   WLINE_SESIC1D(10),=C'Trans Act:'\n*\n         L     R1,SMF30SRV-SMF30PRF(R4) Get service units\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_SESIC3VS(12),EDPAT12\n         ED    WLINE_SESIC3VS(12),DOUBLE+3\n         MVC   WLINE_SESIC3DST(14),=C'Service Units:'\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\nR30SES$DL5X DS 0H\n*\n** Data line 6\n*\n         LA    R1,0                     Default number of tape mounts\n         L     R7,IR_PARML              Get IEFACTRT parm list\n         L     R7,@ACTRT_SMFREC-@ACTRT(R7) Locate SMF record\n         SLR   R2,R2                    Clear register for ICM\n         ICM   R2,B'0011',SMF30OLN-SMF30RPS(R7) Length of section\n         BZ    R30SES$OPX               Zero, Ignore it\n         ICM   R2,B'0011',SMF30OON-SMF30RPS(R7) Number of sections\n         BZ    R30SES$OPX               Zero, Ignore it\n         ICM   R4,B'1111',SMF30OOF-SMF30RPS(R7) Get offset to I/O sect\n         BZ    R30SES$OPX               Zero, Ignore it\n         AR    R4,R7                    Locate operator section\n         L     R1,SMF30PTM-SMF30OPS(R4) Get Non-specific tape mounts\n         A     R1,SMF30TPR-SMF30OPS(R4) Get specific tape mounts\nR30SES$OPX DS 0H\n         LR    R2,R1                    Save tape mount total\n*\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         SLR   R14,R14                  Clear register for ICM\n         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section\n         BZ    R30SES$EXX               Zero, Ignore it\n         ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections\n         BZ    R30SES$EXX               Zero, Ignore it\n         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1) Get offset to I/O sect\n         BZ    R30SES$EXX               Zero, Ignore it\n         AR    R4,R1                    Locate it\n         L     R1,SMF30TEP-SMF30URA(R4) Obtain EXCP count\nR30SES$EXX DS 0H\n         LTR   R2,R2                    Tape mounts = 0?\n         BNZ   R30SES$DL6P              No, print line\n         LTR   R1,R1                    Were the EXCPs also zero?\n         BZ    R30SES$DL6X              Yes, skip printing line\nR30SES$DL6P DS 0H\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_SESIC3VS(12),EDPAT12\n         ED    WLINE_SESIC3VS(12),DOUBLE+3\n         MVC   WLINE_SESIC3DST(12),=C'Total EXCPs:'\n*\n         LR    R1,R2                    Get tape mount total\n         LA    R15,WLINE_SESIC1V        Locate output area\n         BAS   R14,EDITFWF              Edit number of tape mounts\n         MVC   WLINE_SESIC1D(10),=C'Tape Mnts:'\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\nR30SES$DL6X DS 0H\n*\n** Print EXCP lines\n*\nR30SES$EXCP DS  0H\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write blankl line out\n*-Locate EXCP Section information (if any)\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         SLR   R2,R2                    Clear register\n         ICM   R2,B'0011',SMF30ELN-SMF30RPS(R1) Length: EXCP section\n         BZ    R30SES$EN                None, continue\n*\n         ICM   R3,B'1111',SMF30EOF-SMF30RPS(R1) Offset: EXCP section\n         BZ    R30SES$EN                None, continue\n         AR    R3,R1                    Locate EXCP section\n*\n         SLR   R6,R6                    Clear register for ICM\n         ICM   R6,B'0011',SMF30EON-SMF30RPS(R1) Number of EXCP sect.\n         BZ    R30SES$EN                None, continue\n*-DD NAME LINE LOOP\nR30SES$ES DS   0H\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\n         LA    R15,WLINE                Locate for first EXCP output\n         LA    R7,2                     Num of output entries on line\nR30SES$EL DS   0H\n         ICM   R1,B'1111',SMF30BLK-SMF30EXP(R3) Get EXCP count\n         BZ    R30SES$EZ                Oops, none...\n*\n         TM    FLAG1,$F1_EXCP           First time thru?\n         BO    R30SES$ETX               No, continue\n         OI    FLAG1,$F1_EXCP           Say that we've been thru here\n         ST    R15,PARMLIST             Save output location\n#SES$EC2 EQU   (80/2)+((80-(EOEL*2))/2)\n         MVC   WLINE(EOEL),C_EXCPT      Get title for first column\n         MVC   WLINE+#SES$EC2(EOEL),C_EXCPT Get title for second column\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n         L     R15,PARMLIST             Reload output location\n         ICM   R1,B'1111',SMF30BLK-SMF30EXP(R3) Restore EXCP count\nR30SES$ETX DS 0H\n*\n         CLI   SMF30DEV-SMF30EXP(R3),0  Non-Device type I/O?\n         BE    R30SES$EC                Yes, don't do UCB edit\n         UNPK  EOE_UNIT-EOE(5,R15),SMF30CUA-SMF30EXP(3,R3)\n         MVZ   EOE_UNIT-EOE(4,R15),=X'00,00,00,00'\n         TR    EOE_UNIT-EOE(4,R15),=C'0123456789ABCDEF'\n         MVI   EOE_UNIT+4-EOE(R15),C' ' Fix byte after UNPK/MVZ/TR\n         B     R30SES$ECX               Continue\nR30SES$EZ DS   0H\n         LA    R7,1(R7)                 We didn't do anything: fix cnt\n*-Use the ABENDAID DDNAME to check to turn off Quickref as well. This\n*-ASSUMES that there was no I/O to //ABNLIGNR which should be DUMMY.\n         CLI   SMF30DDN-SMF30EXP(R3),C'A' Does the DDNAME start with A\n         BNE   R30SES$ELB               No, continue\n         CLC   SMF30DDN-SMF30EXP(8,R3),=C'ABNLIGNR' Turn ABENDAID off\n         BNE   R30SES$ELB               No, continue\n         OI    FLAG1,$F1_NQW            Yes, turn off Quickref\n         B     R30SES$ELB               Continue\nR30SES$EC DS   0H\n         CLC   SMF30CUA-SMF30EXP(2,R3),=X'7F,FF' VIO?\n         BE    R30SES$ECV               Yes, do it\nR30SES$ECJ DS  0H\n         MVC   EOE_UNIT-EOE(3,R15),=C'JES' JES dataset\n         B     R30SES$ECX               Continue\nR30SES$ECV DS  0H\n         MVC   EOE_UNIT-EOE(3,R15),=C'VIO' VIO Dataset\nR30SES$ECX DS  0H\n         MVC   EOE_DDNAME-EOE(L'SMF30DDN,R15),SMF30DDN-SMF30EXP(R3)\n*\n         CLI   SMF30DEV-SMF30EXP(R3),UCB3TAPE Tape device?\n         BE    R30SES$E_TAPE\n         CLI   SMF30DEV-SMF30EXP(R3),UCB3DACC DASD device?\n         BNE   R30SES$E_TAPEX\n         L     R14,T_DASD               Get current DASD count\n         AR    R14,R1                   Add for this DD\n         ST    R14,T_DASD               Save new DASD count\n         MVI   EOE_TYPE-EOE(R15),C'D'   Set as type: DASD\n         B     R30SES$E_TAPEX           Continue\nR30SES$E_TAPE DS 0H\n         L     R14,T_TAPE               Get current TAPE count\n         AR    R14,R1                   Add for this DD\n         ST    R14,T_TAPE               Save new TAPE count\n         MVI   EOE_TYPE-EOE(R15),C'T'   Set as type: Tape\nR30SES$E_TAPEX DS 0H\n*\n         CVD   R1,DOUBLE                Convert EXCP count to decimal\n         MVC   EOE_COUNT-EOE(12,R15),EDPAT12   Get edit pattern\n         ED    EOE_COUNT-EOE(12,R15),DOUBLE+3  Edit the count\n*\n         LH    R1,SMF30BSZ-SMF30EXP(R3) Get block size\n         N     R1,=XL4'00007FFF'        zero high order bit\n         CVD   R1,DOUBLE                Convert block size to decimal\n         MVC   EOE_BLKSIZE-EOE(7,R15),=X'4020206B202120'\n         ED    EOE_BLKSIZE-EOE(7,R15),DOUBLE+5\n         TM    SMF30BSZ-SMF30EXP(R3),X'80' Changed?\n         BNO   R30SES$BZX               No, continue\n         MVI   EOE_BLKSIZE+8-EOE(R15),C'*' Mark changed BLKSIZE\nR30SES$BZX DS  0H\n#SES$ENL EQU   (80-(EOEL*2))\n         LA    R15,EOEL+#SES$ENL(R15)\n*\nR30SES$ELB DS 0H\n         LA    R3,0(R2,R3)              Locate next EXCP section\n         BCTR  R6,0                     Decrement section count\n         LTR   R6,R6                    Get count\n         BZ    R30SES$DDPX              Zero: end of sections\n         BM    R30SES$DDPX              Minus?: should not happen\n         BCT   R7,R30SES$EL             Do next entry\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         B     R30SES$ES                Continue with next line\n*\nR30SES$DDPX DS 0H\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*\n         ICM   R1,B'1111',T_DASD        Get total DASD EXCPs\n         BNZ   R30SES$ETDTS\n         ICM   R0,B'1111',T_TAPE        Get total Tape EXCPs\n         BZ    R30SES$ETDTX\nR30SES$ETDTS DS 0H\n         LA    R15,WLINE                Locate first column start\n         MVC   0(17,R15),=C'Total DASD EXCPs:' Get text\n         CVD   R1,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(17,R15),=C'Total Tape EXCPs:' Get text\n         L     R0,T_TAPE                Get tape count\n         CVD   R0,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30SES$ETDTX DS 0H\n*\n         TM    FLAG1,$F1_EXCP           Found any EXCPs?\n         BO    R30SES$EXCPX\n*                           ....+....1....+....2....+...\n         MVC   WLINE(25),=C'No I/O activity was found'\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write Blank line\n         B     R30SES$EXCPX\n*\nR30SES$C1VM MVC WLINE_SESIC1V(0),0(R5)\n*\n*-No I/O activity for this step\nR30SES$EN DS   0H           ....+....1....+....2....+...\n         MVC   WLINE(28),=C'No device entries were found'\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write Blank line\nR30SES$EXCPX DS 0H\n*\n** Print fields in the Storage section\n*\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30SES$STX               None, continue\n*\n         ICM   R2,B'1111',SMF30VPI-SMF30SAP(R4) Get VIO ins\n         BNZ   R30SES$VIOS\n         ICM   R3,B'1111',SMF30VPO-SMF30SAP(R4) Get VIO outs\n         BZ    R30SES$VIOX\nR30SES$VIOS DS 0H\n         BAS   R14,R30SES$STT           Get title line first time\n         LA    R15,WLINE                Locate first column start\n         MVC   0(7,R15),=C'VIO In:'     Get text\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(8,R15),=C'VIO Out:'    Get text\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30SES$VIOX DS 0H\n*\n         ICM   R2,B'1111',SMF30PSI-SMF30SAP(R4) Get Pages swapped in\n         BNZ   R30SES$PAGES\n         ICM   R3,B'1111',SMF30PSO-SMF30SAP(R4) Get Pages swapped out\n         BZ    R30SES$PAGEX\nR30SES$PAGES DS 0H\n         BAS   R14,R30SES$STT           Get title line first time\n         LA    R15,WLINE                Locate first column start\n         MVC   0(9,R15),=C'Pages In:'   Get text\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(10,R15),=C'Pages Out:' Get text\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30SES$PAGEX DS 0H\n*\n         ICM   R2,B'1111',SMF30CPI-SMF30SAP(R4) Get Common (lpa+csa)\n         BNZ   R30SES$MISC1S\n         ICM   R3,B'1111',SMF30HPI-SMF30SAP(R4) Get Hiperspace\n         BZ    R30SES$MISC1X\nR30SES$MISC1S DS 0H\n         BAS   R14,R30SES$STT           Get title line first time\n         LA    R15,WLINE                Locate first column start\n         MVC   0(17,R15),=C'Common (LPA+CSA):'\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(11,R15),=C'Hiperspace:'\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30SES$MISC1X DS 0H\n*\n         ICM   R2,B'1111',SMF30VPR-SMF30SAP(R4) Vio reclaims\n         BNZ   R30SES$MISC2S\n         ICM   R3,B'1111',SMF30PST-SMF30SAP(R4) Pages stolen\n         BZ    R30SES$MISC2X\nR30SES$MISC2S DS 0H\n         BAS   R14,R30SES$STT           Get title line first time\n         LA    R15,WLINE                Locate first column start\n         MVC   0(13,R15),=C'VIO Reclaims:'\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(13,R15),=C'Pages Stolen:'\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30SES$MISC2X DS 0H\n         B     R30SES$STX               Leave\n*\n#EOLM    EQU   (EOEL/2)-3               Center \"Paging\"\nR30SES$STT DS  0H\n         TM    FLAG1,$F1_PAGT           Printed title line yet?\n         BO    R30SES$STTX              Yeessss\n         ST    R14,PARMLIST             Nope, save return address\n         OI    FLAG1,$F1_PAGT           Set flag that we did it...\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  print blank line\n         LA    R15,WLINE                Locate output line\n         MVI   0(R15),C'-'              Get dash\n         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it\n         MVC   #EOLM(6,R15),=C'Paging'  Move in title\n         LA    R15,#SES$EC2(R15)        Locate to next section\n         MVI   0(R15),C'-'              Get dash\n         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it\n         MVC   #EOLM(6,R15),=C'Paging'  Move in title\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n         L     R14,PARMLIST             Restore return address\nR30SES$STTX DS 0H\n         BSM   0,R14\n*\nR30SES$STX DS  0H\n*\n** Print ending messages\n*\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*\n         MVC   WLINE(MSG120L),MSG120    Get message\n         MVI   WLINE+5,C'1'             Change \"XYZ120\" to \"XYZ121\"\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         EJECT\n***********************************************************************\n***                                                                 ***\n** Call MVS/Quickref (from ChicagoSoft) to print information on      **\n** system ABENDs in the SYSMSGS (3rd JES SYSOUT dataset).            **\n**                                                                   **\n** This code has been tested at MVS 4.3 and MVS/Quickref 4.2 & 4.3.  **\n**                                                                   **\n** You must update the MVS/Quickref options table with the global    **\n** database names or (this is untested and I wouldn't do it) put     **\n** the MVS/Quickref databases in the INIT JCL.                       **\n**                                                                   **\n** See #TEXTL and #RTRAL equates for the hardcoded length of a       **\n** MVS/Quickref text line and the maximum number of lines that we    **\n** are going to print.                                               **\n***                                                                 ***\n***********************************************************************\n SPACE 2\n#TEXTL EQU   78                         Quickref text line length\n#MAXL  EQU   50                         Max number of text lines 2 prt\n#RTRAL EQU   #TEXTL*#MAXL               Length of Quickref return area\n SPACE 2\n CLI   FCC_CDE,C'S'                     System ABEND\n BNE   EXIT                             No, continue\n TM    FLAG1,$F1_NQW                    Don't do MVS/Quickref\n BO    EXIT                             Yes, skip MVS/Quickref\n XC    QW_REPA(4),QW_REPA               Ensure it's zeros\n*\n** Load entry point to MVS/Quickref program interface module\n*\n LOAD  EPLOC==CL8'QWIKREF1',ERRET=EXIT  Get entry point\n ST    R0,QW_REPA                       Save entry point\n*\n** At release 5.0, ChicagoSoft changed the programming interface\n** so we need a way of doing things differently based on the version.\n*\n#ECNAME EQU X'2E',8                     C'QWIKREF1'\n#ECVER  EQU X'37',4                     x.xx\n#ECVERD EQU X'38',1                      .\n#ECLEN  EQU X'57'-X'37'                 Total length of EC text\n*\n XC    QW_VER(4),QW_VER                 Ensure version\n LR    R1,R0                            Locate epa of QWIKREF1\n CLC   #ECNAME(L'#ECNAME,R1),=CL8'QWIKREF1' Looks right?\n BNE   CMQ$VERE\n CLI   #ECVERD(R1),C'.'                 Have a dot?\n BE    CMQ$VERO                         Looking goood!\nCMQ$VERE DS 0H                          Error: Eyecatcher invalid\n MVC   WLINE(C_WTOL),C_WTO              Get WTO constant\n MVC   WLINE+4(MSG116L),MSG116          Get message text\n WTO   ,MF=(E,WLINE)                    Issue WTO\n B     EXIT\nCMQ$VERO DS 0H\n MVC   QW_VER(L'#ECVER),#ECVER(R1)      Obtain the \"x.xx\" level\n CLI   QW_VER,C'5'                      At version 5?\n BL    CMQ$VERX                         No, continue\n MVC   WLINE(C_WTOL),C_WTO              Get WTO constant\n MVC   WLINE+4(MSG117L),MSG117          Get message text\n MVC   WLINE+4+MSG117L+1(L'QW_VER),QW_VER Insert Quickref Version\n WTO   ,MF=(E,WLINE)                    Issue WTO\n B     EXIT\nCMQ$VERX DS 0H\n*\n** Invoke MVS/Quickref to search on the ABEND on this job step.\n** We build a search argument of \"M=Sxxx\".\n*\n LA    R1,PARMLIST                      Locate parameter list\n LA    R14,FCC_QW                       Locate Quickref parm area\n MVC   0(2,R14),=X'00,06'               Length of \"M=Sxxx\"\n MVC   2(2,R14),=C'M='                  Set as MVS QW DB item\n ST    R14,0(R1)                        Save address of command buf.\n LA    R14,QW_RTEXT                     Locate control block\n ST    R14,4(R1)                        Save length of area\n L     R14,=A(#RTRAL)                   Get length of text area\n ST    R14,8(R1)                        Save length\n OI    8(R1),X'80'                      Last parmlist entry!\n L     R15,QW_REPA                      Load entry point of routine\n BASSM R14,R15                          Call MVS/Quickref\n LR    R3,R15                           Save return code\n ST    R15,PARMLIST                     Save return code for afterwards\n*\n** Check for errors\n*\n LTR   R3,R3                            Check return code\n BZ    CMQ$FOUND                        Okay, continue\n CH    R3,=H'4'                         Partial success...\n BE    CMQ$FOUND                        Yes, continue\n MVC   WLINE(C_WTOL),C_WTO              Get WTO constant\n MVC   WLINE+4(MSG110L),MSG110          Get message text\n LA    R15,WLINE+4+MSG110L              Locate past message text\n CVD   R3,DOUBLE                        Convert return code\n MVC   0(4,R15),EDPAT4                  Get edit pattern\n ED    0(4,R15),DOUBLE+6                Edit RC\n LA    R15,4(R15)                       Bump past it\n MVC   0(6,R15),=C', CMD:'              Insert text\n LA    R15,7(R15)                       Bump past it\n MVC   0(2+4,R15),2(R5)                 Get QW command: \"M=Sxxx\"\n WTO   ,MF=(E,WLINE)                    Issue WTO\n B     CMQ$X\n*\n** Print header line in SYSMSGS\n*\nCMQ$FOUND EQU *\n LA    R15,MSG111                       Locate message area\n ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT\n LA    R15,MSG111L                      Get msg length\n STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length\n L     R15,=V(IEFYS)                    Locate SMB write routine\n BALR  R14,R15                          Write line out\n*\n LA    R15,=C' '                        Locate blank\n ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT\n LA    R15,1                            Get msg length\n STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length\n L     R15,=V(IEFYS)                    Locate SMB write routine\n BALR  R14,R15                          Write line out\n*\n** Loop thru all of the messages that Quickref returns to us and\n** put them in the SYSMSGS\n**\n** Note: Instead of moving via \"MVC WLINE(#TEXTL),0(R2)\", tell IEFYS\n**       where the Quickref Line is located in the area returned by\n**       Quickref for a little better performance.\n*\n LA    R15,#TEXTL                       Get length of Quickref line\n STH   R15,LCTPARM2+2-LCTD(,R12)        Save line length\nCMQ$SMSG EQU *\n LA    R2,QW_RTEXT                      Locate control block\n ICM   R3,B'1111',PARMLIST+8            Get returned length\n LA    R3,0(R3)                         Take off the edge\nCMQ$SML EQU *\n*\n CLI   0(R2),C'*'                       Looks like a start/end line?\n BNE   CMQ$SMLD                         No, continue\n CLC   1(36,R2),=C'******************************** TOP'  Start line?\n BE    CMQ$SMLB                         Yes, skip it\n CLC   1(34,R2),=C'****************************** BOT'\n BE    CMQ$SMLB                         Yes, skip it\nCMQ$SMLD EQU *\n*\n ST    R2,LCTPARM1-LCTD(,R12)           Save record location into LCT\n L     R15,=V(IEFYS)                    Locate SMB write routine\n BALR  R14,R15                          Write SMB line out\nCMQ$SMLB EQU *\n LA    R2,#TEXTL(R2)                    Bump to next text\n SH    R3,=AL2(#TEXTL)                  Subtract length of line\n LTR   R3,R3                            Check out remaining length\n BP    CMQ$SML                          Still have some then do it\n*\n** End of the Quickref messages - print ending line\n*\n LA    R15,=C' '                        Locate blank\n ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT\n LA    R15,1                            Get msg length\n STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length\n L     R15,=V(IEFYS)                    Locate SMB write routine\n BALR  R14,R15                          Write SMB line out\n*\n LA    R15,MSG112                       Locate message area\n ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT\n LA    R15,MSG112L                      Get msg length\n STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length\n L     R15,=V(IEFYS)                    Locate SMB write routine\n BALR  R14,R15                          Write SMB line out\n*\n** Error - Area not large enough - Usually on purpose as we don't\n**         need to print a book - only the first x number of lines.\n*\n CLI   PARMLIST+3,4                     RC=4 from Quickref?\n BNE   CMQ$PSX                          No, skip the lecture\n LA    R15,MSG113                       Locate message area\n ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT\n LA    R15,MSG113L                      Get msg length\n STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length\n L     R15,=V(IEFYS)                    Locate SMB write routine\n BALR  R14,R15                          Write SMB line from WLINE\n*\n LA    R15,MSG114                       Locate message area\n ST    R15,LCTPARM1-LCTD(,R12)          Save msg location into LCT\n LA    R15,MSG114L                      Get msg length\n STH   R15,LCTPARM2+2-LCTD(,R12)        Save msg length\n L     R15,=V(IEFYS)                    Locate SMB write routine\n BALR  R14,R15                          Write SMB line from WLINE\nCMQ$PSX EQU *\n*\n** Print WTO message that we put some information in SYSMSGS\n*\n MVC   WLINE(C_WTOL),C_WTO              Get WTO constant\n MVC   WLINE+4(MSG115L),MSG115          Get message\n WTO   ,MF=(E,WLINE)                    Issue WTO\n*\n** Delete module from memory\n*\nCMQ$X  EQU *\n ICM   R0,B'1111',QW_REPA               Get entry point\n BZ    CMQ$DMX                          None, leave\n DELETE EPLOC==CL8'QWIKREF1'            Delete module from memory\nCMQ$DMX EQU *\n B     EXIT                             Leave\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Job termination (Non-TSO only)                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nR30JOB   EQU   *\n*\n** Do different processing for TSO users\n*\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_JMR-@ACTRT(R1) Locate JMR\n         TM    JMRINDC-JMR(R1),JMRFIND  TSO User (Foreground)?\n         BO    R30JOB_TSO               Yes, do its stuff\n*\n** Do we need to ignore this job (for some common started tasks we\n** don't care about getting Trivia reports)\n*\n         BAS   R14,IGNORE_JOB           Ignore this job?\n*\n** Write out the job ended message to the operator console.  A MPF\n** exit will ensure that the message is suppressed from the user's\n** JES2 JOB LOG and only sent to the MCS console.\n*\n         MVC   WLINE(C_WTOL),C_WTO      Get WTO constant\n         LA    R15,WLINE+4              Locate to text area\n         MVC   0(18,R15),=C'XYZ107I JOB ENDED:' Insert message prefix\n         LA    R15,18+2(R15)            Bump past it\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_JMR-@ACTRT(R1) Locate JMR\n         MVC   0(8,R15),JMRJOB-JMR(R1)  Get Jobname\n         LA    R15,8+1(R15)             Bump past it\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_PGRMNAME-@ACTRT(R1) Locate Programmer name\n         MVC   0(20,R15),0(R1)          Get programmer name\nR30J$IW  EQU   *\n         WTO   ,MF=(E,WLINE)            Issue WTO\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** Job End Statistics\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nR30JOB_END_STATS DS 0H\n         ICM   R15,B'1111',=V(IEFYS)    Have the IBM SMB routine?\n         BZ    EXIT                     No, give up\n*\n** Print heading lines\n*\n         MVC   WLINE(MSG120L),MSG120    Get message\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*-\"J o b  E n d   S t a t i s t i c s\"\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n         MVC   WLINE+24(5),=C'J o b'    It a tough JOB but somebody...\n         MVC   WLINE+32(C_ENDSTL),C_ENDST Get \"end stats\"\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*-Print blank line\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*\n** Data line 1\n*\n         MVC   WLINE_JESIC1D(10),=C'Job  Name:'\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_JMR-@ACTRT(R1) Locate JMR\n         MVC   WLINE_JESIC1V(L'JMRJOB),JMRJOB-JMR(R1)\n*\n         MVC   WLINE_JESIC2D(10),=C'System ID:'\n         L     R14,IR_PARML             Get IEFACTRT parm list\n         L     R14,@ACTRT_SMFREC-@ACTRT(R14) Locate SMF record\n         MVC   WLINE_JESIC2V(L'SMF30SID),SMF30SID-SMF30RPS(R14)\n*\n         MVC   WLINE_JESIC3DT(7),=C'Submit:'\n         ICM   R14,B'1111',A_IDSECT     Locate ID section\n         BZ    R30JES$RTODX             None?\n         LA    R15,WLINE_JESIC3VT       Output location\n         ICM   R0,B'1111',SMF30RST-SMF30ID(R14) <- Time\n         ICM   R1,B'1111',SMF30RSD-SMF30ID(R14) <- Date\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\nR30JES$RTODX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 2\n*\n         MVC   WLINE_JESIC1D(10),=C'Job JESID:'\n         ICM   R1,B'1111',A_IDSECT      Locate ID section\n         BZ    R30JES$JIX               None?\n         MVC   WLINE_JESIC1V(8),SMF30JNM-SMF30ID(R1)\nR30JES$JIX DS  0H\n*\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         ICM   R14,B'1111',SMF30SOF-SMF30RPS(R1) Offset: SubSystem\n         BZ    R30JES$OSLX              Not there...\n         AR    R14,R1                   Locate Subsystem section\n         MVC   WLINE_JESIC2D(10),=C'MVS level:'\n         MVC   WLINE_JESIC2V(L'SMF30OSL),SMF30OSL-SMF30PSS(R14)\nR30JES$OSLX DS 0H\n*\n         MVC   WLINE_JESIC3DT(6),=C'Start:'\n         ICM   R14,B'1111',A_IDSECT     Locate ID section\n         BZ    R30JES$STODX             None?\n         LA    R15,WLINE_JESIC3VT       Output location\n         ICM   R0,B'1111',SMF30SIT-SMF30ID(R14) <- Time\n         ICM   R1,B'1111',SMF30STD-SMF30ID(R14) <- Date\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\nR30JES$STODX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 3\n*\n*\n         ICM   R1,B'1111',A_IDSECT      Locate ID section\n         BZ    R30JES$JCX               None?\n         MVC   WLINE_JESIC1D(10),=C'Job Class:'\n         MVC   WLINE_JESIC1V(1),SMF30CL8-SMF30ID(R1)\nR30JES$JCX DS  0H\n*\n         MVC   WLINE_JESIC3DT(4),=C'End:'\n         TIME  BIN                      Get the time and date NOW!\n         LA    R15,WLINE_JESIC3VT       Output location\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\nR30JES$ETODX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 4\n*\n         LA    R15,WLINE_JESIC1V-2      Location for \"  hh:mm:ss.th\"\n         L     R1,T_TCB                 Get CPU time to edit\n         BAS   R14,FORMAT_CPUTIME       Format CPU time\n         MVC   WLINE_JESIC1D(10),=C'CPU (TCB):'\n*\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30JES$SBX               None, continue\n         L     R1,SMF30URB-SMF30SAP(R4) Get storage length\n         SRL   R1,10                    Get by 1024\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_JESIC3VS-1(12),EDPAT12 Get edit mask\n         ED    WLINE_JESIC3VS-1(12),DOUBLE+3 Edit the storage\n         MVC   WLINE_JESIC3DST(18),=C'Storage below 16M:'\n         MVI   WLINE_JESIC3VSK,C'k'\nR30JES$SBX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 5\n*\n         LA    R15,WLINE_JESIC1V-2      Location for \"  hh:mm:ss.th\"\n         L     R1,T_SRB                 Get CPU time to edit\n         BAS   R14,FORMAT_CPUTIME       Format CPU time\n         MVC   WLINE_JESIC1D(10),=C'CPU (SRB):'\n*\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30JES$SAX               None, continue\n         L     R1,SMF30EUR-SMF30SAP(R4) Get storage length\n         SRL   R1,10                    Get by 1024\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_JESIC3VS-1(12),EDPAT12 Get edit pattern\n         ED    WLINE_JESIC3VS-1(12),DOUBLE+3 Edit it\n         MVC   WLINE_JESIC3DST(18),=C'Storage above 16M:'\n         MVI   WLINE_JESIC3VSK,C'k'\nR30JES$SAX DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Data line 6\n*\n         ICM   R4,B'1111',A_PRSECT      Have a performance section?\n         BZ    R30JES$DL6X              No, continue\n*\n         SLR   R0,R0\n         ICM   R1,B'1111',SMF30TAT-SMF30PRF(R4)  Get trans active\n         SLDL  R0,10\n         BAS   R14,CONVERT_MICRO_SECONDS Convert micro seconds\n*                                          h h : m m : s s . t h\n*                                      0 1 2 3 4 5 6 7 8 9 0 1 2\n         MVC   WLINE_JESIC1V-2(13),=X'402120207A20207A20204B2020'\n         ED    WLINE_JESIC1V-2(13),DOUBLE+1\n         MVC   WLINE_JESIC1D(10),=C'Trans Act:'\n*\n         L     R1,SMF30SRV-SMF30PRF(R4) Get service units\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_JESIC3VS(12),EDPAT12\n         ED    WLINE_JESIC3VS(12),DOUBLE+3\n         MVC   WLINE_JESIC3DST(14),=C'Service Units:'\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\nR30JES$DL6X DS 0H\n*\n** Data line 7\n*\n         LA    R1,0                     Default number of tape mounts\n         L     R7,IR_PARML              Get IEFACTRT parm list\n         L     R7,@ACTRT_SMFREC-@ACTRT(R7) Locate SMF record\n         SLR   R2,R2                    Clear register for ICM\n         ICM   R2,B'0011',SMF30OLN-SMF30RPS(R7) Length of section\n         BZ    R30JES$OPX               Zero, Ignore it\n         ICM   R2,B'0011',SMF30OON-SMF30RPS(R7) Number of sections\n         BZ    R30JES$OPX               Zero, Ignore it\n         ICM   R4,B'1111',SMF30OOF-SMF30RPS(R7) Get offset to I/O sect\n         BZ    R30JES$OPX               Zero, Ignore it\n         AR    R4,R7                    Locate operator section\n         L     R1,SMF30PTM-SMF30OPS(R4) Get Non-specific tape mounts\n         A     R1,SMF30TPR-SMF30OPS(R4) Get specific tape mounts\nR30JES$OPX DS 0H\n         LR    R2,R1                    Save tape mount total\n*\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         SLR   R14,R14                  Clear register for ICM\n         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section\n         BZ    R30JES$EXX               Zero, Ignore it\n         ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections\n         BZ    R30JES$EXX               Zero, Ignore it\n         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1) Get offset to I/O sect\n         BZ    R30JES$EXX               Zero, Ignore it\n         AR    R4,R1                    Locate it\n         L     R1,SMF30TEP-SMF30URA(R4) Obtain EXCP count\nR30JES$EXX DS 0H\n         LTR   R2,R2                    Tape mounts = 0?\n         BNZ   R30JES$DL7P              No, print line\n         LTR   R1,R1                    Were the EXCPs also zero?\n         BZ    R30JES$DL7X              Yes, skip printing line\nR30JES$DL7P DS 0H\n         CVD   R1,DOUBLE                Convert to packed\n         MVC   WLINE_JESIC3VS(12),EDPAT12\n         ED    WLINE_JESIC3VS(12),DOUBLE+3\n         MVC   WLINE_JESIC3DST(12),=C'Total EXCPs:'\n*\n         LR    R1,R2                    Get tape mount total\n         LA    R15,WLINE_JESIC1V        Locate output area\n         BAS   R14,EDITFWF              Edit number of tape mounts\n         MVC   WLINE_JESIC1D(10),=C'Tape Mnts:'\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\nR30JES$DL7X DS 0H\n*\n** Print blank line\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*\n** Print fields in the Storage section\n**\n** For the Job end statistics, print all lines even if fields are zero.\n*\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30JES$STX               None, continue\n         LA    R15,WLINE                Locate output line\n         MVI   0(R15),C'-'              Get dash\n         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it\n         MVC   #EOLM(6,R15),=C'Paging'  Move in title\n         LA    R15,#SES$EC2(R15)        Locate to next section\n         MVI   0(R15),C'-'              Get dash\n         MVC   1(EOEL-1,R15),0(R15)     ..Propagate it\n         MVC   #EOLM(6,R15),=C'Paging'  Move in title\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n         ICM   R2,B'1111',SMF30VPI-SMF30SAP(R4) Get VIO ins\n***      BNZ   R30JES$VIOS\n         ICM   R3,B'1111',SMF30VPO-SMF30SAP(R4) Get VIO outs\n***      BZ    R30JES$VIOX\nR30JES$VIOS DS 0H\n         LA    R15,WLINE                Locate first column start\n         MVC   0(7,R15),=C'VIO In:'     Get text\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(8,R15),=C'VIO Out:'    Get text\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30JES$VIOX DS 0H\n*\n         ICM   R2,B'1111',SMF30PSI-SMF30SAP(R4) Get Pages swapped in\n***      BNZ   R30JES$PAGES\n         ICM   R3,B'1111',SMF30PSO-SMF30SAP(R4) Get Pages swapped out\n***      BZ    R30JES$PAGEX\nR30JES$PAGES DS 0H\n         LA    R15,WLINE                Locate first column start\n         MVC   0(9,R15),=C'Pages In:'   Get text\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(10,R15),=C'Pages Out:' Get text\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30JES$PAGEX DS 0H\n*\n         ICM   R2,B'1111',SMF30CPI-SMF30SAP(R4) Get Common (lpa+csa)\n***      BNZ   R30JES$MISC1S\n         ICM   R3,B'1111',SMF30HPI-SMF30SAP(R4) Get Hiperspace\n***      BZ    R30JES$MISC1X\nR30JES$MISC1S DS 0H\n         LA    R15,WLINE                Locate first column start\n         MVC   0(17,R15),=C'Common (LPA+CSA):'\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(11,R15),=C'Hiperspace:'\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30JES$MISC1X DS 0H\n*\n         ICM   R2,B'1111',SMF30VPR-SMF30SAP(R4) Vio reclaims\n***      BNZ   R30JES$MISC2S\n         ICM   R3,B'1111',SMF30PST-SMF30SAP(R4) Pages stolen\n***      BZ    R30JES$MISC2X\nR30JES$MISC2S DS 0H\n         LA    R15,WLINE                Locate first column start\n         MVC   0(13,R15),=C'VIO Reclaims:'\n         CVD   R2,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit the count\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(13,R15),=C'Pages Stolen:'\n         ICM   R0,B'1111',SMF30PST-SMF30SAP(R4) Pages stolen\n         CVD   R3,DOUBLE                Convert to decimal\n         LA    R15,EOEL-12(R15)         Locate output for number\n         MVC   0(12,R15),EDPAT12        Get edit pattern\n         ED    0(12,R15),DOUBLE+3       Edit count\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..Propagate it\nR30JES$MISC2X DS 0H\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Print blank line\nR30JES$STX DS  0H\n*\n** Print trailer line 1\n*\n         ICM   R14,B'1111',A_IDSECT     Locate ID section\n         BZ    R30JES$AUX               None?\n         MVC   WLINE_JESIC1D(10),=C'ACF2 User:'\n         MVC   WLINE_JESIC1V(L'SMF30RUD),SMF30RUD-SMF30ID(R14)\nR30JES$AUX DS 0H\n*\n         LA    R15,WLINE+#SES$EC2       Locate second column start\n         MVC   0(11,R15),=C'Programmer:' Insert description\n         LA    R15,12(R15)              Locate past description\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_PGRMNAME-@ACTRT(R1) Locate programmer name\n         MVC   0(20,R15),0(R1)\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Print trailer line 2\n*\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         ICM   R14,B'1111',SMF30AOF-SMF30RPS(R1) Offset: SubSystem\n         BZ    R30JES$TL2X\n         AR    R14,R1                   Locate accounting field\n         SLR   R2,R2                    Clear register for ICM\n         ICM   R2,B'0011',SMF30AON-SMF30RPS(R1) Get number of fields\n         BZ    R30JES$TL2X              None: leave\n         MVC   WLINE_JESIC1D(10),=C'Acct Info:' Set description\n         LA    R15,WLINE_JESIC1V        Locate to start of value out\nR30JES$TL2L DS 0H\n         SLR   R1,R1                    Clear for IC\n         IC    R1,0(R14)                Get length of field\n         BCTR  R1,0                     Decrement by 1 for EX\n         EX    R1,R30JES$TL2M           Move account field out\n         LA    R1,1(R1)                 Add 1 back to field length\n         AR    R15,R1                   Bump past field on output\n         MVI   0(R15),C','              Insert delimiter\n         LA    R15,1(R15)               Bump past delimiter\n         LA    R14,1(R1,R14)            Bump past field on input\n         BCT   R2,R30JES$TL2L           Process next field\n         BCTR  R15,0                    Backup past last delimiter\n         MVI   0(R15),C' '              Erase trailing comma\nR30JES$TL2X DS 0H\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         MVI   WLINE,C' '               Get blank\n         MVC   WLINE+1(79),WLINE        ..propagate it\n*\n** Print ending lines\n*\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n*\n         MVC   WLINE(MSG120L),MSG120    Get message\n         MVI   WLINE+5,C'2'             Change \"XYZ120\" to \"XYZ122\"\n         L     R15,=V(IEFYS)            Locate SMB write routine\n         BALR  R14,R15                  Write SMB line out\n         B     EXIT\n*\n** Executed instructions\n*\nR30JES$C MVC   WLINE_JESIC1V(0),0(R5)\nR30JES$TL2M MVC 0(0,R15),1(R14)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       SMF 30 - Job Termination - TSO user code                    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nR30JOB_TSO DS  0H\n         L     R3,T_TCB                 Get TCB time\n         A     R3,T_SRB                 Add in the SRB time\n         BAS   R14,EDIT_CPU_TIME        Edit CPU time: R5=addr R6=Len\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**      Print the first message                                      **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Print message prefix\n*\n         LA    R15,WLINE                Locate message area\n         MVI   0(R15),C' '              Get space\n         MVC   1(79,R15),0(R15)         Propagate spaces\n         MVC   0(23,R15),=C'XYZ104I Your session on'\n         LA    R15,24(R15)              Bump past text\n*\n** Print system ID\n*\n         L     R1,CVTPTR                -> CVT\n         MVC   0(8,R15),CVTSNAME-CVTMAP(R1) Obtain System Name\n         LA    R0,8                     Length of string\n         BAS   R14,LOCATE_FIRST_SPACE   Locate first space\n*\n** Print CPU information\n*\n         MVC   1(4,R15),=C'used'        Insert text\n         LA    R15,6(R15)               Bump past it\n         EX    R6,R30JT$CPU             Move in CPU time\n         LA    R15,1(R6,R15)            Bump past it\n         MVC   1(11,R15),=C'CPU seconds' Insert text\n         LA    R15,12(R15)              Bump past it\n*\n** Locate I/O Section\n**\n** We assume that the check SMF30UON was checked for zero eariler\n*\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         SLR   R14,R14                  Clear register for ICM\n         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section\n         BZ    R30JT$EXX                Zero, Ignore it\n*        ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections\n*        BZ    R30JT$EXX                Zero, Ignore it\n         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1) Get offset to I/O sect\n         BZ    R30JT$EXX                If not available, leave\n         AR    R4,R1                    Locate it\n*\n** Print EXCPS\n*\n         MVC   1(3,R15),=C'and'         Insert text\n         LA    R15,5(R15)               Bump past it\n         L     R1,SMF30TEP-SMF30URA(R4) Obtain EXCP count\n         BAS   R14,EDITFWF              Edit it\n         MVC   1(5,R15),=C'EXCPs'       Insert text\n         LA    R15,6(R15)               Bump past it\nR30JT$EXX EQU  *\n*\n** Print message\n*\n         LA    R1,WLINE                 Locate beginning of message\n         LR    R0,R15                   Locate end\n         SR    R0,R1                    Length = End - Beginning\n         TPUT  (1),(0)                  Print message on TSO terminal\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**      Print second message with performance trivia                 **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n*\n** Format message header\n*\n         LA    R15,WLINE                Locate message area\n         MVI   0(R15),C' '              Get space\n         MVC   1(79,R15),0(R15)         Propagate spaces\n         LA    R15,8(R15)               Bump past \"XYZ104I \" area\n*\n** Print fields in the I/O section\n*\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         SLR   R14,R14                  Clear register for ICM\n         ICM   R14,B'0011',SMF30ULN-SMF30RPS(R1) Length of section\n         BZ    R30JT$IOX                Zero, Ignore it\n*        ICM   R14,B'0011',SMF30UON-SMF30RPS(R1) Number of sections\n*        BZ    R30JT$IOX                Zero, Ignore it\n         ICM   R4,B'1111',SMF30UOF-SMF30RPS(R1)\n         BZ    R30JT$IOX                Zero, Ignore it\n         AR    R4,R1                    Locate section\n*\n         MVC   0(5,R15),=C'TGET:'\n         LA    R15,6(R15)\n         L     R1,SMF30TGT-SMF30URA(R4)\n         BAS   R14,EDITFWF\n*\n         MVC   1(5,R15),=C'TPUT:'\n         LA    R15,7(R15)\n         L     R1,SMF30TPT-SMF30URA(R4)\n         BAS   R14,EDITFWF\nR30JT$IOX EQU  *\n*\n** Print fields in the Storage Section\n*\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30JT$SSX\n*\n         L     R1,SMF30PSI-SMF30SAP(R4) Get Swap in count\n         A     R1,SMF30PSO-SMF30SAP(R4) Add Swap out count\n         LTR   R1,R1                    Do any swapping?\n         BZ    R30JT$SWX                No, continue\n         MVC   0(8,R15),=C' Swaps: '    Insert text\n         LA    R15,8(R15)               Bump past text\n         BAS   R14,EDITFWF              Edit swap count\nR30JT$SWX EQU  *\n*\n         L     R1,SMF30VPI-SMF30SAP(R4) Get VIO in count\n         A     R1,SMF30VPO-SMF30SAP(R4) Add VIO out count\n         LTR   R1,R1                    Do any VIO paging?\n         BZ    R30JT$VIX                No, continue\n         MVC   0(6,R15),=C' VIO: '      Insert text\n         LA    R15,6(R15)               Bump past text\n         BAS   R14,EDITFWF              Edit VIO count\nR30JT$VIX EQU  *\n*\n         L     R1,SMF30HPI-SMF30SAP(R4) Get hiperspace in count\n         A     R1,SMF30HPO-SMF30SAP(R4) Add Hiperspace out count\n         LTR   R1,R1                    Any hiperpace activity?\n         BZ    R30JT$HPX                No, continue\n         MVC   0(13,R15),=C' HiperSpace: ' Insert text\n         LA    R15,13(R15)              Bump past text\n         BAS   R14,EDITFWF              Edit swap count\nR30JT$HPX EQU  *\n*\n         ICM   R1,B'1111',SMF30LPI-SMF30SAP(R4) Get LPA count\n         BZ    R30JT$LPX                No, continue\n         MVC   1(4,R15),=C'LPA:'        Insert text\n         LA    R15,6(R15)               Bump past text\n         BAS   R14,EDITFWF              Edit count\nR30JT$LPX EQU  *\n*\nR30JT$SSX EQU  *                        End of Storage Section stuff\n*\n** print terminal name if ID section is around\n*\n         ICM   R4,B'1111',A_IDSECT      Locate ID section\n         BZ    R30JT$TX\n         CLC   SMF30TID-SMF30ID(3,R4),=C'TPX'  Useless info?\n         BE    R30JT$TX                 Yes, not the real name...\n         MVC   1(9,R15),=C'Terminal:'   Get text\n         LA    R15,11(R15)              Bump past it\n         MVC   0(8,R15),SMF30TID-SMF30ID(R4) Move in Terminal ID\n         LA    R15,8(R15)               Bump past it\nR30JT$TX DS    0H\n*\n** Print the message\n*\n         LA    R1,WLINE                   Locate message start\n         LR    R0,R15                     Get end\n         SR    R0,R1                      Length = End - Beginning\n         CH    R0,=H'8'                   Anything there?\n         BE    R30JT$L2X                  Nope, leave\n         TPUT  (1),(0)                    Print TSO message\nR30JT$L2X EQU  *\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**      Print storage information                                    **\n**                                                                   **\n**      Storage used: xk (below 16 megs) xk (above 16 megs)          **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         ICM   R4,B'1111',A_STSECT      Get storage section\n         BZ    R30JT$RSX                None, continue\n*\n** Print blank line\n*\n         LA    R1,WLINE                 Locate message area\n         MVI   0(R1),C' '               Get blank\n         LA    R0,1                     Length of line\n         TPUT  (1),(0)                  Print blank line\n*\n** Format message header\n*\n         LA    R15,WLINE                Locate message area\n         MVI   0(R15),C' '              Get space\n         MVC   1(79,R15),0(R15)         Propagate spaces\n         LA    R15,8(R15)               Bump past \"XYZ104I \" area\n         MVC   0(13,R15),=C'Storage used:'\n         LA    R15,14(R15)\n*\n         L     R1,SMF30URB-SMF30SAP(R4) Get Storage below 16M\n         SRL   R1,10                    Get by 1024\n         CVD   R1,DOUBLE                Convert to packed\n         BAS   R14,EDITFWF\n         MVI   0(R15),C'k'\n         LA    R15,2(R15)\n         MVC   0(15,R15),=C'(below 16 megs)'\n         LA    R15,17(R15)\n*\n         L     R1,SMF30EUR-SMF30SAP(R4) Get storage above 16M\n         SRL   R1,10                    Get by 1024\n         CVD   R1,DOUBLE                Convert to packed\n         BAS   R14,EDITFWF\n         MVI   0(R15),C'k'\n         LA    R15,2(R15)\n         MVC   0(15,R15),=C'(above 16 megs)'\n         LA    R15,17(R15)\n*\n** Print the message\n*\n         LA    R1,WLINE                   Locate message start\n         LR    R0,R15                     Get end\n         SR    R0,R1                      Length = End - Beginning\n         TPUT  (1),(0)                    Print TSO message\nR30JT$RSX DS 0H\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**      Print Novell-like login and logout lines                     **\n**                                                                   **\n**      Logon:  1962.065 06-MAR-1962 07:05:02 pm\n**      Logoff: 20??.??? ??-???-???? 12:59:59 pm\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\n         ICM   R4,B'1111',A_IDSECT      Locate ID section\n         BZ    R30JT$LIX                None, skip this\n*\n** Print blank line\n*\n         LA    R1,WLINE                 Locate message area\n         MVI   0(R1),C' '               Get blank\n         LA    R0,1                     Length of line\n         TPUT  (1),(0)                  Print blank line\n*\n** Print logon time and date\n*\n         LA    R15,WLINE                Locate message area\n         MVI   0(R15),C' '              Get space\n         MVC   1(79,R15),0(R15)         Propagate spaces\n         MVC   0(16,R15),=C'XYZ105I Logon:  ' Get text\n         LA    R15,16(R15)              Bump past text\n*\n         SLR   R1,R1                    Clear register\n         IC    R1,SMF30STD-SMF30ID(R4)  Get century offset from 1900\n         AH    R1,=H'19'                Get the actual century\n         CVD   R1,DOUBLE                Save century as Decimal\n         UNPK  0(2,R15),DOUBLE+6(2)     Convert to human readable\n         OI    1(R15),C'0'              Fix sign byte\n         LA    R15,2(R15)               Bump past century\n*\n         UNPK  DOUBLE2(9),SMF30STD-SMF30ID(5,R4)\n         MVZ   DOUBLE2(8),=8X'00'\n         TR    DOUBLE2(8),=C'0123456789ABCDEF'\n         MVC   0(2,R15),DOUBLE2+2       Get yy from \"0cyydddf\"\n         MVI   2(R15),C'.'              Insert dot\n         MVC   3(3,R15),DOUBLE2+4       Get ddd from \"0cyydddf\"\n         LA    R15,7(R15)\n*\n         ICM   R0,B'1111',SMF30SIT-SMF30ID(R4) <- Time\n         ICM   R1,B'1111',SMF30STD-SMF30ID(R4) <- Date\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\n         MVI   0(R15),C' '\n         LA    R1,WLINE                 Locate message start\n         LR    R0,R15                   Get end\n         SR    R0,R1                    Length = End - Beginning\n         TPUT  (1),(0)                  Print TSO message\n*\n** Print logoff time and date\n*\n         TIME  BIN                      Don't trust SMF record yet\n         STM   R0,R1,DOUBLE             Save Time and Date\n*\n         LA    R15,WLINE                Locate message area\n         MVI   0(R15),C' '              Get space\n         MVC   1(79,R15),0(R15)         Propagate spaces\n         LA    R15,8(R15)               Bump past \"XYZ105I \" area\n         MVC   0(8,R15),=C'Logoff: '    Move in text\n         LA    R15,8(R15)               Bump past text\n*\n         SLR   R1,R1                    Clear register\n         IC    R1,DOUBLE+4              Get century offset from 1900\n         AH    R1,=H'19'                Get the actual century\n         CVD   R1,DOUBLE2               Save century as Decimal\n         UNPK  0(2,R15),DOUBLE2+6(2)    Convert to human readable\n         OI    1(R15),C'0'              Fix sign byte\n         LA    R15,2(R15)               Bump past century\n*\n         UNPK  DOUBLE2(9),DOUBLE+4(5)\n         MVZ   DOUBLE2(8),=8X'00'\n         TR    DOUBLE2(8),=C'0123456789ABCDEF'\n         MVC   0(2,R15),DOUBLE2+2       Get yy from \"0cyydddf\"\n         MVI   2(R15),C'.'              Insert dot\n         MVC   3(3,R15),DOUBLE2+4       Get ddd from \"0cyydddf\"\n         LA    R15,7(R15)\n*\n         LM    R0,R1,DOUBLE             Get Time and Date\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\n         MVI   0(R15),C' '\n         LA    R1,WLINE                 Locate message start\n         LR    R0,R15                   Get end\n         SR    R0,R1                    Length = End - Beginning\n         TPUT  (1),(0)                  Print TSO message\nR30JT$LIX DS   0H\n         SPACE 3\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**      Common Exit from R30JOB_TSO section                          **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n         SPACE 2\nR30JT$X  EQU   *\n         B     EXIT                       Leave\nR30JT$CPU MVC  0(0,R15),0(R5)             ** Executed **\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Misc internal subroutines                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Convert binary time to printable format \" hh:mm:ss\"\n**\n** Input: R1  - Time to convert\n**        R15 - Output location\n*\nCONVERT_BINARY_TIME EQU *\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'100'                 DIVIDE OUT 100THS OF SECOND\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'60'                  DIVIDE OUT SECONDS\n         CVD   R0,DOUBLE                  CONVERT SECONDS TO PACKED\n         UNPK  6(3,R15),DOUBLE+6(2)       SAVE SECONDS\n         OI    6+2(R15),C'0'              FIX SIGN BYTE\n         MVI   6(R15),C':'                COLON\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'60'                  DIVIDE OUT MINUTES\n         CVD   R0,DOUBLE                  CONVERT MINUTES TO PACKED\n         UNPK  3(3,R15),DOUBLE+6(2)       SAVE MINUTES\n         OI    3+2(R15),C'0'              FIX SIGN BYTE\n         MVI   3(R15),C':'                COLON\n         CVD   R1,DOUBLE                  CONVERT MINUTES TO PACKED\n         UNPK  0(3,R15),DOUBLE+6(2)       SAVE HOURS\n         OI    0+2(R15),C'0'              FIX SIGN BYTE\n         MVI   0(R15),C' '                LEADING SPACE\n         BSM   0,R14                      Return to caller\n*\n** Point Register 15 to the first blank in a string\n** Input:  R0  - Maximum length of the string\n**         R15 - String\n** Output: R15 - First space in the string\n*\nLOCATE_FIRST_SPACE DS 0H\n         CLI   0(R15),C' '                Blank?\n         BE    LFS$X                      Yes, leave\n         LA    R15,1(R15)                 No, bump to next byte\n         BCT   R0,LOCATE_FIRST_SPACE      ..Repeat\nLFS$X    DS    0H\n         BSM   0,R14                      Return to caller\n*\n** Convert micro seconds\n**\n** Input: R0-R1 containing value in microseconds\n**\n** Note: this routine borrowed from S.V. Petersen's IEFACTRT\n*\nCONVERT_MICRO_SECONDS DS 0H\n         AL    R1,F5MSEC           round by 5 milliseconds\n         BC    12,*+8\n         AL    R0,FONE\n         D     R0,F60MIL                       (R1) holds minutes\n         CVD   R0,DOUBLE           microseconds to decimal <= 59999999\n         LTR   R1,R1\n         BZR   R14                 only seconds in result\n         C     R1,F60\n         BL    CVTMICS7            no hours in result\n         SLR   R15,R15\n         SLR   R0,R0\n         C     R1,F1440\n         BL    CVTMICS3            no days  in result\n         D     R0,F1440                        (R1) holds days\n         LR    R15,R1\n         MH    R15,H100            ddd00\n         SRDL  R0,32               remainder minutes back down to R1\nCVTMICS3 D     R0,F60              (R1) = hh   (R0) = mm\n         ALR   R1,R15                  dddhh        (in binary)\n         MH    R1,H100                 dddhh00\n         ALR   R1,R0                   dddhhmm\nCVTMICS7 CVD   R1,DOUBLE2              dddhhmmC (now in decimal)\n         SRP   DOUBLE2,8,0         shift 8 digits to left\n         AP    DOUBLE,DOUBLE2      and combine with microseconds\n         BSM   0,R14               (DOUBLE) = PL8'dddhhmmssthtxxxC'\n         SPACE 2\nF60MIL   DC    F'60000000'         microseconds/minute\nF60HND   DC    F'6000'             centiseconds/minute\nF5MSEC   DC    F'5000'             5 milliseconds in microseconds\nFONE     DC    F'1'\nF60      DC    F'60'               minutes/hour\nF1440    DC    F'1440'             minutes/day\nH10000   DC    H'10000'\nH100     DC    H'100'\n         DS    0H\n*\n** Format the CPU time in \"hh:mm:ss.th\" format\n**\n** Input: R1 has CPU time\n**        R15 has output location\n*\nFORMAT_CPUTIME DS 0H\n         ST    R15,DOUBLE2                Save output location\n         SLR   R0,R0                      Clear for divide\n         D     R0,=F'6000'                (R1) = mins\n         LR    R15,R0                     centiseconds ssth  (binary)\n         SLR   R0,R0                      Clear for divide\n         D     R0,=F'60'                  (R0) mins (R1) = hours\n         MH    R1,=H'100'                 hh00\n         AR    R1,R0                      hhmm\n         MH    R1,=H'10000'               hhmm0000\n         ALR   R1,R15                     hhmmssth  (binary)\n         CVD   R1,DOUBLE                  =PL8'0000000hhmmssthC'\n         L     R15,DOUBLE2                Restore output location\n         MVC   0(13,R15),=X'402120207A20207A20204B2020'\n         ED    0(13,R15),DOUBLE+3         Edit the cpu time\n         BSM   0,R14                      Return to caller\n*\n** Edit CPU time in IPOACTRT/SDSF format\n** Input: R3 - CPU Time\n** Output: R5 - Address of edited CPU time\n**         R6 - Length of edited CPU time\n*\nEDIT_CPU_TIME EQU *\n         CVD   R3,DOUBLE                  Convert CPU time to packed\n         MVC   DOUBLE2(15),ECT$EPAT       Get edit pattern\n         LA    R1,DOUBLE2+12              Locate past significant byte\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit and save start\n         LA    R6,DOUBLE2+15              Locate end of time\n         SR    R6,R1                      Length = end - start\n         BCTR  R6,0                       Decrement for EX\n         LR    R5,R1                      Save address of CPU time\n         CLI   0(R5),C'.'                 Less than 1\n         BNE   ECT$X                      No, continue\n         BCTR  R5,0                       Backup 1\n         LA    R6,1(R6)                   Increment length for \"0\"\n         MVI   0(R5),C'0'                 Make cpu time \"0.xx\"\nECT$X    DS    0H\n         BSM   0,R14                      Return to caller\nECT$EPAT DC    X'40,20,20,20,6B,20,20,20,6B,20,20,21,4B,20,20'\n         DS    0H\n*\n** Obtain the Total CPU time from the SMF30 record: SRB+TCB\n**\n** Output:\n** - T_TCB ... CPU (TCB)\n** - T_SRB ... CPU (SRB)\n** - R3    ... Total CPU (TCB+SRB)\n*\nR30CPU   EQU   *\n         L     R1,IR_PARML              Get IEFACTRT parm list\n         L     R1,@ACTRT_SMFREC-@ACTRT(R1) Locate SMF record\n         SLR   R3,R3\n         ICM   R3,B'0011',SMF30CLN-SMF30RPS(R1) Length of section\n         BZ    R30C$X                     Not there, leave\n         SLR   R3,R3                      Clear total\n         ICM   R5,B'1111',SMF30COF-SMF30RPS(R1) Get offset to section\n         BZ    R30C$X                     Not there, leave\n         AR    R5,R1                      Get offset to CPU section\n         SLR   R4,R4                      Clear Register\n         ICM   R4,B'0011',SMF30CON-SMF30RPS(R1) # of CPU sections\n         BZ    R30C$X                     No, exit\nR30C$L   EQU   *\n         A     R3,SMF30CPT-SMF30CAS(R5)   Add TCB CPU time\n         L     R1,T_TCB\n         A     R1,SMF30CPT-SMF30CAS(R5)\n         ST    R1,T_TCB\n*\n         A     R3,SMF30CPS-SMF30CAS(R5)   Add SRB CPU time\n         L     R1,T_SRB\n         A     R1,SMF30CPS-SMF30CAS(R5)\n         ST    R1,T_SRB\n*\n         LA    R5,SMF30IDT-SMF30CAS+L'SMF30IDT(R5) Locate next section\n         BCT   R4,R30C$L                 Until no more...\nR30C$X   EQU   *\n         BSM   0,R14\n*\n** Edit register 1 flush\n** Input: R1 - Value to edit\n**        R15 - Where edited value is to be put\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      CHECK FOR 0\n         BZ    EDITFWF0                   YES, PUT ZERO\n         ST    R14,EF_RA                  Save return address\n         CVD   R1,DOUBLE                  NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14              LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\nEF$EDMK  EQU   *\n         EDMK  DOUBLE2(15),DOUBLE+2       EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16             LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                     LENGTH = END - START\n         BCTR  R14,0                      DECREMENT FOR EX\n         EX    R14,EDITFWFM               MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)             BUMP POINTER PAST NUMBER\n         MVI   0(R15),C' '                Fix unprintable character\n         L     R14,EF_RA                  Get return address\n         BSM   0,R14                      RETURN TO CALLER\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                PUT IN ZERO\n         LA    R15,1(R15)                 BUMP POINTER PAST ZERO\n         BSM   0,R14                      RETURN TO CALLER\n*\n** See if we are to ignore this job for Step/Job end messages\n*\nIGNORE_JOB EQU *\n         CLI   FCC_CDE,C'S'               System ABEND?\n         BE    IJ$X                       Let operator know...\n         CLI   FCC_CDE,C'U'               User ABEND?\n         BE    IJ$X                       Let operator know...\n         LA    R1,IJ_TAB                  Locate table\n         LA    R0,IJ_TABN                 Get number in table\n         L     R15,IR_PARML             Get IEFACTRT parm list\n         L     R15,@ACTRT_JMR-@ACTRT(R15)\nIJ$L     EQU   *\n         CLC   0(8,R1),JMRJOB-JMR(R15)    Jobname match?\n         BE    EXIT                       Yes, skip to exit...\n         LA    R1,8(R1)                   No, bump to next entry\n         BCT   R0,IJ$L                        and process it\nIJ$X     DS    0H\n         BSM   0,R14                      Return to caller\n*\nIJ_TAB   EQU   *\n         DC    CL8'DCCRDR  '              DCC job reader\n         DC    CL8'DEALLOC '              Dealloc\n         DC    CL8'DMSAR   '              DMS Auto Recall\n         DC    CL8'INIT    '              JES2 Initiators\n         DC    CL8'RECALLO '              FDR recall\n         DC    CL8'X       '              Dealloc\n         DC    CL8'JES2    '              Don't mess with JES2!\nIJ_TABN  EQU   (*-IJ_TAB)/8\n         DS    0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n** Convert input binary time and packed decimal julian date to a     **\n** fancy output string of \"dd-mmm-ccyy hh:mm:ss pm\"                  **\n**                                                                   **\n** Input: R0 - Time in binary                                        **\n**        R1 - Date in packed decimal                                **\n**        R15 - points to the output area                            **\n**                                                                   **\n** Output: the area in R15 will be filled in and R15 updated with    **\n**         address just past the filled in area.                     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nCONVERT_TO_TODSTRING DS 0H\n         ST    R15,CTT_OUT                Save output area address\n         ST    R14,CTT_RA                 Save return address\n*\n** Get the input time (binary) and date (packed decimal) and convert\n** it to a STCK TOD format\n*\n         LA    R14,CTT_CIN                Locate routine Time/Date area\n         XC    0(CTAREAL,R14),0(R14)      Clear to binary zeros\n         STCM  R0,B'1111',CTAREA_TIME-CTAREA(R14) Save Time\n         STCM  R1,B'1111',CTAREA_DATE-CTAREA(R14) Save Date\n*\n         CONVTOD CONVVAL=CTT_CIN,         Convert this Time/Date       @\n               TODVAL=CTT_TOD,            ..To TOD format              @\n               TIMETYPE=BIN,              ..Time is binary format      @\n               DATETYPE=YYDDD,            ..Date is julian 0CYYDDDf    @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    CONVTOD worked?\n         BNZ   CTT$ERRC                   Failed, do primitive way\n*\n** Convert the TOD stamp into time and date formats\n*\n         STCKCONV STCKVAL=CTT_TOD,        Convert this TOD Stamp       @\n               CONVVAL=CTT_SOUT,          ..Into these date/time areas @\n               TIMETYPE=DEC,              ..Output time format         @\n               DATETYPE=DDMMYYYY,         ..Output Date format         @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    CONVTOD worked?\n         BNZ   CTT$ERRS                   Failed, do primitive way\n*\n** Format the date\n*\n         L     R15,CTT_OUT                Locate output area\n*                               D  D  -  M  M  -  C  C  Y  Y\n         MVC   0(11,R15),=X'40,20,20,60,20,20,60,20,20,20,20'\n         ED    0(11,R15),CTT_SOUT+8       Edit it to \" dd-mm-ccyy\"\n         MVC   0(3,R15),1(R15)            Move \"dd-\" over \"dd-...-ccyy\"\n         PACK  DOUBLE(8),4(2,R15)         Get month in decimal\n         CVB   R14,DOUBLE                 Convert to binary\n         BCTR  R14,0                      Make relative to zero\n         MH    R14,=H'3'                  Multiply for month offset\n         LA    R1,=C'JanFebMarAprMayJunJulAugSepOctNovDec'\n         AR    R1,R14                     Locate month entry\n         MVC   3(3,R15),0(R1)             Move \"mmm\" to \"dd-mmm-ccyy\"\n         OI    0(R15),X'F0'               Ensure leading zero\n         LA    R15,11(R15)                Bump past date\n*\n** Format the Time: \" hh:mm:ss AM\"\n*\nCTT$TIME DS    0H\n         L     R1,CTT_CIN+(CTAREA_TIME-CTAREA) Get time\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'100'                 DIVIDE OUT 100THS OF SECOND\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'60'                  DIVIDE OUT SECONDS\n         CVD   R0,DOUBLE                  CONVERT SECONDS TO PACKED\n         UNPK  6(3,R15),DOUBLE+6(2)       SAVE SECONDS\n         OI    6+2(R15),C'0'              FIX SIGN BYTE\n         MVI   6(R15),C':'                COLON\n         SLR   R0,R0                      CLEAR REGISTER\n         D     R0,=F'60'                  DIVIDE OUT MINUTES\n         CVD   R0,DOUBLE                  CONVERT MINUTES TO PACKED\n         UNPK  3(3,R15),DOUBLE+6(2)       SAVE MINUTES\n         OI    3+2(R15),C'0'              FIX SIGN BYTE\n         MVI   3(R15),C':'                COLON\n         MVC   10(2,R15),=C'AM'           Set default\n         CH    R1,=H'12'                  In AM range?\n         BNH   CBT$PMX                    Yes, continue\n         MVI   10(R15),C'P'               Make it \"PM\"\n         SH    R1,=H'12'                  Standard = Military - 12\nCBT$PMX  DS    0H\n         CVD   R1,DOUBLE                  CONVERT MINUTES TO PACKED\n         UNPK  0(3,R15),DOUBLE+6(2)       SAVE HOURS\n         OI    0+2(R15),C'0'              FIX SIGN BYTE\n         MVI   0(R15),C' '                LEADING SPACE\n         LA    R15,12(R15)                Bump past time\n*\n** Return to caller\n*\nCTT$X    DS    0H\n         L     R14,CTT_RA                 Get return address\n         BSM   0,R14                      Return to caller\n*\n** Error: either the CONVTOD or STCKCON failed, so display the\n** date in julian\n*\nCTT$ERRC DS    0H\n         L     R15,CTT_OUT                Locate output area\n         MVI   10(R15),C'C'               Let the sysprog know failer\n         B     CTT$ERR\nCTT$ERRS DS    0H\n         L     R15,CTT_OUT                Locate output area\n         MVI   10(R15),C'S'               Let the sysprog know failer\nCTT$ERR  DS    0H\n         UNPK  DOUBLE2(9),#CTTPMD(5)           *\n         MVZ   DOUBLE2(8),=8X'00'              ** Hex convert\n         TR    DOUBLE2(8),=C'0123456789ABCDEF' *\n         MVC   0(2,R15),DOUBLE2+2         Get yy from \"0cyydddf\"\n         MVI   2(R15),C'.'                Insert dot\n         MVC   3(3,R15),DOUBLE2+4         Get ddd from \"0cyydddf\"\n         LA    R15,12(R15)                Locate past date area\n         B     CTT$TIME                   Format the time as usual\n#CTTPMD  EQU   CTT_CIN+(CTAREA_DATE-CTAREA)    Generate offset\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**   Format condition code for SMF 30 records into FCC_CDE field     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nFORMAT_COND_CODE EQU *\n         MVC   FCC_CDE(5),=CL5'n/a'       If something goes wrong...\n*\n** Locate record\n*\n         L     R15,IR_PARML             Get IEFACTRT parm list\n         L     R15,@ACTRT_SMFREC-@ACTRT(R15) Locate SMF Record\n         SLR   R1,R1                      Clear register\n         ICM   R1,B'0011',SMF30TON-SMF30RPS(R15)  Number of comp. sect.\n         BZ    FCC$X                      Zero? ignore it\n         ICM   R1,B'0011',SMF30TLN-SMF30RPS(R15)  Length of comp. sect.\n         BZ    FCC$X                      Zero? ignore it\n         ICM   R4,B'1111',SMF30TOF-SMF30RPS(R15)  OFFSET TO COMP SECT\n         BZ    FCC$X                      Zero? ignore it\n         AR    R4,R15                     LOCATE COMP SECTION\n*\n** Flushed?\n*\n         TM    SMF30STI-SMF30CMP(R4),SMF30FLH Was the step flushed\n         BNO   FCC$FX                     No, continue\n         MVC   FCC_CDE(5),=C'FLUSH'       Set field\n         B     FCC$X                      LEAVE\nFCC$FX   EQU   *\n*\n         SLR   R0,R0\n         ICM   R0,B'0011',SMF30SCC-SMF30CMP(R4)  Get Condition code\n*\n** Process non-ABENDs\n*\n         TM    SMF30STI-SMF30CMP(R4),SMF30ABD Did it ABEND?\n         BO    FCC$ABND                   Yes, print ABEND code\n         N     R0,=A(X'FFF')              Zero unused portion\n         CVD   R0,DOUBLE                  Convert condcode to Packed\n         MVC   FCC_CDE-2(6),=X'40,21,20,20,20,20'\n         ED    FCC_CDE-2(6),DOUBLE+5\n         B     FCC$X                      Leave\n*\n** Format ABENDs\n*\nFCC$ABND EQU   *\n         TM    SMF30SCC-SMF30CMP(R4),X'80' User ABEND?\n         BNO   FCC$SAB                    No, System ABEND\n         N     R0,=A(X'FFF')              Turn off unneeded bits\n         CVD   R0,DOUBLE                  Convert to packed decimal\n         MVC   FCC_CDE-1(L'FCC_CDE+1),=X'40,21,20,20,20,20'\n         ED    FCC_CDE-1(L'FCC_CDE+1),DOUBLE+5\n         MVI   FCC_CDE,C'U'               Make it a user ABEND\n         B     FCC$X                      Leave\n*\nFCC$SAB  EQU   *\n         STH   R0,DOUBLE                  Save system ABEND code\n         UNPK  FCC_CDE+1(4),DOUBLE(3)\n         MVZ   FCC_CDE+1(3),=X'00,00,00'\n         TR    FCC_CDE+1(3),=C'0123456789ABCDEF'\n         MVI   FCC_CDE+4,C' '             Fix overflow\n         MVI   FCC_CDE,C'S'               Make it a system ABEND\n*\n** Common Exit from FORMAT_CONDITION_CODE\n*\nFCC$X    EQU   *\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSG110   DC    C'XYZ110E Error calling MVS/Quickref, RC:'\nMSG110L  EQU   *-MSG110\nMSG111   DC    C'XYZ111I',25C'-'\n         DC    C'Start of ABEND information from MVS/Quickref'\nMSG111L  EQU   *-MSG111\nMSG112   DC    C'XYZ112I',27C'-'\n         DC    C'End of ABEND information from MVS/Quickref'\nMSG112L  EQU   *-MSG112\nMSG113   DC    C'XYZ113W Hit MVS/Quickref output limit: '\n         DC    C'not all lines shown. '\nMSG113L  EQU   *-MSG113\nMSG114   DC    C'XYZ114I Refer to the IBM \"MVS Systems and Codes\" '\n         DC    C'manual or MVS/Quickref online (TSO and Roscoe) '\n         DC    C'for more information.'\nMSG114L  EQU   *-MSG114\nMSG115   DC    C'XYZ115I ABEND information from MVS/Quickref '\n         DC    C'was written to SYSMSGS'\nMSG115L  EQU   *-MSG115\nMSG116   DC    C'XYZ116I MVS/Quickref version could not be determined'\nMSG116L  EQU   *-MSG116\n*\nMSG117   DC    C'XYZ117I IEFACTRT does not yet support MVS/Quickref at'\nMSG117L  EQU   *-MSG117\n*\nMSG120   DC    C'XYZ120I ',72C'-'    Step End stats - Start\nMSG120L  EQU   *-MSG120\nMSG121   EQU   *-*                   Step End stats - End\nMSG122   EQU   *-*                   Job End Stats - End\n*\nEDPAT4   DC    X'40,20,20,20'\nEDPAT12  DC    X'40,20,20,20,6B,20,20,20,6B,20,21,20'\n*\nC_WTO    WTO   '                                                       @\n                                         ',MF=L\nC_WTOL   EQU   *-C_WTO\n*\nC_EXCPT  DC    CL(EOEL)' '\n         ORG   C_EXCPT+(EOE_UNIT-EOE)\n         DC    C'Unit--'\n         ORG   C_EXCPT+(EOE_DDNAME-EOE)\n         DC    C'DDName--'\n         ORG   C_EXCPT+(EOE_COUNT-EOE)\n         DC    C'EXCP Count--'\n         ORG   C_EXCPT+(EOE_BLKSIZE-EOE)\n         DC    C'Blksize'\n         ORG   ,\nC_EXCPTL EQU   *-C_EXCPT\n#EOETL   EQU   EOEL                     Test length against C_EXCPTL\n*\nC_ENDSTS  DC   C'S t e p   '\nC_ENDST   DC   C'E n d   S t a t i s t i c s'\nC_ENDSTL  EQU  *-C_ENDST\nC_ENDSTSL EQU  *-C_ENDSTS\n*\n** Literals\n*\nLTORG    EQU   *\n         LTORG ,\nLTORGL   EQU   *-LTORG\n         DS    0D\n*\n** Determine length left addressible in IEFACTRT CSECT\n*\n#IEFACTRT EQU  *-IEFACTRT               Bytes used\n#IEFACTRT_LEFT EQU (4096*3)-#IEFACTRT   Bytes left\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       IEFACTRT GETMAINed work area                                **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n$DSA_SP  EQU   252                      Sub-pool: Low private\nDSA      DSECT ,\n         DS    18F                      Register Save Area\nDSAEC    DS    CL16\nDSAGLEN  DS    F                        Length of DSA work area\nIREGS    DS    0F                       Input registers\nIR_CODE  DS    F                        ..Code\nIR_PARML DS    F                        ..CEPA address\nEF_RA    DS    F                        EDITFWF return address\n         DS    0D\nDOUBLE   DS    D                        Double word work area\nDOUBLE2  DS    2D                       Double word work area * 2\nPARMLIST DS    XL128                    Work area for parm lists\n*\n** The following area from DSA_IS to DSA_IL is intialized to binary\n** zeros at startup.\n*\nDSA_IS   EQU   *                        Start of area to init to zero\n         DS    0D                       Convert_To_TODSTring\nCTT_TOD  DS    D                        ..TOD (STCK) area\nCTT_OUT  DS    F                        ..Output area address\nCTT_RA   DS    F                        ..Return address\nCTT_CIN  DS    XL(CTAREAL)              ..CONVTOD input area\nCTT_SOUT DS    XL16                     ..STCKCON output area\n*\n         DS    0F\nQW_REPA  DS    F                        Entry point for Quickref pgm\nQW_VER   DS    C'x.xx'                  Version of Quickref\nA_IDSECT DS    F                        Address of SMF30 ID section\nA_STSECT DS    F                        Address of SMF30 Stor section\nA_PRSECT DS    F                        Address of SMF30 Perf section\nT_SRB    DS    F                        Total: SRB CPU time\nT_TCB    DS    F                        Total: TCB CPU time\nT_DASD   DS    F                        Total: DASD EXCPs\nT_TAPE   DS    F                        Total: Tape EXCPs\nFLAG1    DS    B'00000000'              Flag 1\n$F1_EXCP EQU   B'10000000'              ..Found a good EXCP section?\n$F1_PAGT EQU   B'01000000'              ..Paging title?\n$F1_NQW  EQU   B'00100000'              ..No Quickref?\n*                                       Format_Condition_Code\nFCC_QW   DS    XL2                      ..Quickref length\nFCC_PREC DS    CL2                      ..Needed for WRCODE + Quickref\nFCC_CDE  DS    CL5                      ..Return code\nDSA_IL   EQU   *-DSA_IS\n*\n** Misc work areas\n*\nWLINE    DS    CL132                    Work area for IEFYS and WTOs\nWLINEL   EQU   *-WLINE\n         ORG   WLINE                    Reuse work area\nQW_RTEXT DS    XL(#RTRAL+64)            Text return area + slack\n         ORG   ,\n         DS    0D\nDSAL     EQU   *-DSA\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Program Equates                                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Standard register equates\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n** Area passed to IEFACTRT\n*\n@ACTRT          DSECT ,\n@ACTRT_JMR      DS    F          Parm  1 -> Common Exit Parm: JMR\n@ACTRT_STEPNAME DS    F          Parm  2 -> Step name\n@ACTRT_PGRMNAME DS    F          Parm  3 -> Programmer Name\n@ACTRT_JOBTIME  DS    F          Parm  4 -> Job CPU time / # Acct\n@ACTRT_JOBACCT  DS    F          Parm  5 -> Job Account information\n@ACTRT_STEPTIME DS    F          Parm  6 -> Step CPU time  / # acct\n@ACTRT_STEPACCT DS    F          Parm  7 -> Step Account information\n@ACTRT_JOBFLAG  DS    F          Parm  8 -> Flags\n@ACTRT_TERMCODE DS    F          Parm  9 -> Termination Status\n@ACTRT_SMFREC   DS    F          Parm 10 -> SMF record\n@ACTRT_JCPUT4   DS    F          Parm 11 -> Job CPU time\n@ACTRT_SCPUT4   DS    F          Parm 12 -> Step CPU time\n@ACTRT_SUBS     DS    F          Parm 13 -> Name of subsystem\n*\n** Output area for Step End Statistics Information\n*\nSESI            DSECT ,\nSESIC1          EQU   *\nSESIC1D         DS    C'Step Name: '\nSESIC1V         DS    CL8' '\n                DS    CL7' '\nSESIC2          EQU   *\nSESIC2D         DS    C'Cond Code: '\nSESIC2V         DS    CL8' '\nSESIC2L         EQU   *-SESIC2\n                DS    CL5' '\nSESIC3          EQU   *\nSESIC3DT        DS    C'Start: '\nSESIC3VT        DS    C'06-MAR-1962 07:05:02 PM'\nSESIC3L         EQU   *-SESIC3\n                ORG   SESIC3\nSESIC3DST       DS    C'Storage '\nSESIC3DSL       DS    C'above '\nSESIC3DSM       DS    C'16M:'\nSESIC3VS        DS    CL11'xxxxxxxxxxx'\nSESIC3VSK       DS    C'k'\n                ORG   ,\nWLINE_SESIC1D   EQU   WLINE+(SESIC1D-SESI)\nWLINE_SESIC1V   EQU   WLINE+(SESIC1V-SESI)\nWLINE_SESIC2D   EQU   WLINE+(SESIC2D-SESI)\nWLINE_SESIC2V   EQU   WLINE+(SESIC2V-SESI)\nWLINE_SESIC2L   EQU   WLINE+(SESIC2L-SESI)\nWLINE_SESIC3DT  EQU   WLINE+(SESIC3DT-SESI)\nWLINE_SESIC3VT  EQU   WLINE+(SESIC3VT-SESI)\nWLINE_SESIC3DST EQU   WLINE+(SESIC3DST-SESI)\nWLINE_SESIC3DSL EQU   WLINE+(SESIC3DSL-SESI)\nWLINE_SESIC3DSM EQU   WLINE+(SESIC3DSM-SESI)\nWLINE_SESIC3VS  EQU   WLINE+(SESIC3VS-SESI)\nWLINE_SESIC3VSK EQU   WLINE+(SESIC3VSK-SESI)\n*\n** Output area for Job End Statistics Information\n*\nJESI            DSECT ,\nJESIC1          EQU   *\nJESIC1D         DS    C'Job  Name: '\nJESIC1V         DS    CL11'00:00:00.00'\n                DS    CL4' '\nJESIC2          EQU   *\nJESIC2D         DS    C'System ID: '\nJESIC2V         DS    CL8' '\nJESIC2L         EQU   *-JESIC2\n                DS    CL4' '\nJESIC3          EQU   *\nJESIC3DT        DS    C'Submit: '\nJESIC3VT        DS    C'06-MAR-1962 19:05:02:15'\nJESIC3L         EQU   *-JESIC3\n                ORG   JESIC3\nJESIC3DST       DS    C'Storage '\nJESIC3DSL       DS    C'above '\nJESIC3DSM       DS    C'16M:'\n                DS    C\nJESIC3VS        DS    CL11'xxxxxxxxxxx'\nJESIC3VSK       DS    C'k'\n                ORG   ,\nWLINE_JESIC1D   EQU   WLINE+(JESIC1D-JESI)\nWLINE_JESIC1V   EQU   WLINE+(JESIC1V-JESI)\nWLINE_JESIC2D   EQU   WLINE+(JESIC2D-JESI)\nWLINE_JESIC2V   EQU   WLINE+(JESIC2V-JESI)\nWLINE_JESIC2L   EQU   WLINE+(JESIC2L-JESI)\nWLINE_JESIC3    EQU   WLINE+(JESIC3-JESI)\nWLINE_JESIC3DT  EQU   WLINE+(JESIC3DT-JESI)\nWLINE_JESIC3VT  EQU   WLINE+(JESIC3VT-JESI)\nWLINE_JESIC3DST EQU   WLINE+(JESIC3DST-JESI)\nWLINE_JESIC3DSL EQU   WLINE+(JESIC3DSL-JESI)\nWLINE_JESIC3DSM EQU   WLINE+(JESIC3DSM-JESI)\nWLINE_JESIC3VS  EQU   WLINE+(JESIC3VS-JESI)\nWLINE_JESIC3VSK EQU   WLINE+(JESIC3VSK-JESI)\n*\n** Map CONVTOD area\n*\nCTAREA          DSECT ,\nCTAREA_TIME     DS    XL4\n                DS    XL4\nCTAREA_DATE     DS    XL4\n                DS    XL4\nCTAREAL         EQU   *-CTAREA\n*\n** Map EXCP Output Entry\n*\nEOE             DSECT ,\nEOE_UNIT        DS    C'00B1'           Obi-Wan\n                DS    C\nEOE_TYPE        DS    C\n                DS    C\nEOE_DDNAME      DS    CL8'Kenobi'\n                DS    C\nEOE_COUNT       DS    CL12\n                DS    C\nEOE_BLKSIZE     DS    CL7\nEOEL            EQU   *-EOE\n*\n** End of IEFACTRT\n*\n                END   ,\n./ ADD NAME=IEFUJV   0100-98016-98016-1800-00267-00267-00000-DALCOCK\nIEFUJV   TITLE 'SMF Job validation SMF exit'\nIEFUJV   CSECT ,\nIEFUJV   AMODE 31\nIEFUJV   RMODE ANY\n***********************************************************************\n***                                                                 ***\n**  Name: IEFUJV                                                     **\n**                                                                   **\n**  Description: SMF Job Validation Exit                             **\n**                                                                   **\n**  Purpose: Selectively place SWA control blocks above the line     **\n**           for some jobs.                                          **\n**                                                                   **\n**           Fill in company code of Account fields if \"_\"           **\n**           - For example:   //DTSO666D JOB (_,_,_,SYS)             **\n**             Changed to:    //DTSO666D JOB (D,D,D,SYS)             **\n**           - Note: The C/I doesn't allow JES2 EXIT 6 to fill in    **\n**                   these underscores so we do them here.           **\n**                                                                   **\n**  Limitations:                                                     **\n**  Uses equates from IEFTXTFT and IEFNEL for equates. They          **\n**  match but the SMF manual does not specify to use it:             **\n**     o Parm 3 points to STRINDCS in MACRO IEFTXTFT                 **\n**     o Parm 4 points to NELPARMO in MACRO IEFNEL                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n**                                                                   **\n** Date        Person   Description                                  **\n** ----------- -------- -------------------------------------------- **\n** 27-JUN-1996 DAlcock  Add Roscoe to the SWA=ABOVE;                 **\n** 11-NOV-1993 DAlcock  Move JCL standards validation to JES2 exit 6;**\n**                      This exit performs the following:            **\n**                      > Fill in company code in account field of   **\n**                        job card if underscore                     **\n**                      > Place SWA above the line for selected jobs;**\n***                                                                 ***\n***********************************************************************\n         EJECT ,\n         SAVE  (14,12),,XYZ_SMFEXIT_IEFUJV_&SYSDATE._&SYSTIME\n         USING IEFUJV,R12                 Set up addressability\n         LR    R12,R15                    Get our base register\n         SLR   R15,R15                    Set default return code\n*\n*    R3 = Address of Common Parameter Exit Area (IEFJMR)\n*    R4 = Address of 80 byte JCL text area\n*    R5 = Address of entry code byte (STRINDCS in IEFTXTFT)\n*    R6 = Address of JES initialization parms (NELPARMO in IEFNEL)\n*\n         LM    R3,R6,0(R1)                Load input parameters\n         USING JMR,R3                     Set addressability to JMR\n*\n** Branch on type of JCL statement\n*\n         CLI   0(R5),JOBSTR               Is this a job card?\n         BE    PROCESS_JOB_CARD           Yes, continue\n*\n** Common exit from USRUJI\n*\nEXIT     EQU   *\n         RETURN (14,12),RC=(15)           Return to caller\n         DS    0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Process job card JCL statements                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPROCESS_JOB_CARD EQU *\n         CLI   2(R4),C' '                 Job card continuation?\n         BE    PJC$X                      Yes, don't process...\n         TM    JMRINDC,JMRFIND            TSO?\n         BO    PJC$X                      Yes, verification by ACF2\n         SLR   R10,R10                    Set flag register to zeros\n*\n** Check for debugging job\n*\n         CLC   JMRJOB(8),=C'ibmuserZ'     Debugging job?\n         BNE   PJC$DBCX                   No, continue\n         ICM   R10,B'1000',=X'FF'         We need a message...\nPJC$DBCX EQU   *\n*\n** Fill in company codes in accounting fields that have underscores\n*\n         LR    R1,R4                      Locate paren addr after TRT\n         TRT   0(80,R4),T_PAREN           Look for an open paren\n         BM    PJC$UPF                    Found it?\n         B     PJC$UX                     No, leave\nPJC$UPF  EQU   *\n         LA    R1,1(R1)                   Locate past open paren\n         BAS   R14,PJC$FILL               Fill in underscore if found\n         LA    R7,79(R4)                  Locate end of card\n         SR    R7,R4                      Set length for rest of card\n         EX    R7,PJC$COMC                Locate next comma\n         LA    R1,1(R1)                   Bump past comma\n         BAS   R14,PJC$FILL               Fill in underscore if found\n         LA    R7,79(R4)                  Locate end of card\n         SR    R7,R1                      Set length for rest of card\n         EX    R7,PJC$COMC                Locate next comma\n         LA    R1,1(R1)                   Bump past comma\n         BAS   R14,PJC$FILL               Fill in underscore if found\nPJC$UX   EQU   *\n*\n** Search for jobs that need SWA control blocks allocated above the\n** 16 meg line\n*\nPJC$SCLS EQU   *\n         LA    R7,T_SWA                   Locate SWA table\n         LA    R8,T_SWAN                  Get number in table\n         SLR   R9,R9                      Clear register\nPJC$SCL  EQU   *\n         IC    R9,0(R7)                   Get length\n         EX    R9,PJC$SCCJ                Match?\n         BE    PJC$SCLX                   Yes, leave\n         LA    R7,1+8(R7)                 No, Bump to next entry\n         BCT   R8,PJC$SCL                 Do it\n*                                         Job is not in table -------\n         CLM   R10,B'1000',=X'FF'         Debugging job?\n         BE    PJC$WTO                    Yes, need WTO anyway\n         B     PJC$X                      No, leave\n*\nPJC$SCCJ CLC   1(0,R7),JMRJOB             ** Executed **\n*\nPJC$SCLX EQU   *\n         OI    0(R6),NELXA2               Set SWA Above\n         ICM   R10,B'0100',=X'FF'         We need a message...\n*\n** Initialize work area\n*\nPJC$WTO  EQU   *\n         GETMAIN R,LV=DSAL,SP=241         Obtain storage\n         LR    R11,R1                     Locate work area\n         USING DSA,R11                    Get addressibility to it\n         ST    R13,SAVEAREA+4             Chain save area\n         ST    R11,8(,R13)                Save save area\n         LR    R13,R11                    Locate new Save area\n*\n** Issue WTO message for debugging job\n*\n         CLM   R10,B'1000',=X'FF'         Debugging job?\n         BNE   PJC$DBMX                   Yes, need WTO anyway\n         WTO   E,MF=(E,MSG169)            Yes, issue message\nPJC$DBMX EQU   *\n*\n** Print WTO to say we changed the SWA to above the line\n*\n         CLM   R10,B'0100',=X'FF'         Changed SWA?\n         BNE   PJC$SMX                    No, continue\n         WTO   E,MF=(E,MSG168)            Yes, issue message\nPJC$SMX  EQU   *\n*\n** Free work area\n*\n         L     R13,SAVEAREA+4             Unchain work area\n         FREEMAIN R,LV=DSAL,SP=241,A=(11) Free work area\n         SLR   R15,R15                    Set return code to zero\n*\n** Common exit (if no GETMAIN) from Process_Job_Card processing\n*\nPJC$X    EQU   *\n         B     EXIT                       Let's end this party\n*\n** Fill in underscores with the first character of the jobname\n*\nPJC$FILL EQU   *\n         CLI   0(R1),C'_'\n         BNE   PJC$FILLX\n         MVC   0(1,R1),JMRJOB\nPJC$FILLX EQU  *\n         BSM   0,R14\n*\nPJC$COMC TRT   0(*-*,R1),T_COMMA          TRT for commas in acct field\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** SWA above the line table\n*\nT_SWA    EQU   *\n         DC    AL1(8-1),CL8'ibmuserZ'     David Alcock test job\n         DC    AL1(8-1),CL8'ibmuserX'     David Alcock test job\n         DC    AL1(4-1),CL8'DIDM'         IDMS CVs\n         DC    AL1(4-1),CL8'IDMS'         IDMS CVs\n         DC    AL1(6-1),CL8'ROSCOE'       Roscoe\nT_SWAN   EQU   (*-T_SWA)/9\n         DS    0H                         Half word boundry\n*\n** Constants\n*\nMSG168   WTO   'XYZ168I SWA Control Blocks will be placed above the lin@\n               e',                                                     @\n               ROUTCDE=(12),MCSFLAG=HRDCPY,MSGTYP=JOBNAMES,MF=L\nMSG169   WTO   'XYZ169I IEFUJV assembled on &SYSDATE at &SYSTIME',     @\n               ROUTCDE=(12),MCSFLAG=HRDCPY,MSGTYP=JOBNAMES,MF=L\n*\n** Translate tables for parsing\n*\n         DS    0D\nT_PAREN  DC    256XL1'00'\n         ORG   T_PAREN+C'('\n         DC    C'('\n         ORG\nT_COMMA  DC    256XL1'00'\n         ORG   T_COMMA+C','\n         DC    C','\n         ORG\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Dynamic Save Area                                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDSA      DSECT ,\nSAVEAREA DS    18F                        Register Save Area\n*\n*-> Put other fields here\n*\n         DS    0D\nDSAL     EQU   *-DSA                      End of DSA area\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Equates                                                     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Register Equates\n*\nR0       EQU   00                      REGISTER 0\nR1       EQU   01                      REGISTER 1\nR2       EQU   02                      REGISTER 2\nR3       EQU   03                      REGISTER 3\nR4       EQU   04                      REGISTER 4\nR5       EQU   05                      REGISTER 5\nR6       EQU   06                      REGISTER 6\nR7       EQU   07                      REGISTER 7\nR8       EQU   08                      REGISTER 8\nR9       EQU   09                      REGISTER 9\nR10      EQU   10                      REGISTER 10\nR11      EQU   11                      REGISTER 11\nR12      EQU   12                      REGISTER 12\nR13      EQU   13                      REGISTER 13\nR14      EQU   14                      REGISTER 14\nR15      EQU   15                      REGISTER 15\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       External DSECTs                                             **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         CVT   DSECT=YES,LIST=NO         CVT\n         IEFJMR ,                        CEPA - Job Management Record\n         IEFNEL SUBCOM=C                  Converter Parameters\n         IEFTXTFT                         Converter Text format\n         END   ,\n./ ADD NAME=IEFUSI   0100-98016-98016-1800-00543-00543-00000-DALCOCK\nIEFUSI   TITLE 'Step initialization SMF exit'\n***********************************************************************\n***                                                                 ***\n** Name = IEFUSI                                                     **\n**                                                                   **\n** Author = David Alcock                                             **\n**          Central and South West Services                          **\n**                                                                   **\n** Purpose = SMF step initialization exit                            **\n**                                                                   **\n** Reference = GC28-1637 MVS/ESA Installation Exits                  **\n**                                                                   **\n** Input: R1 points to:                                              **\n**        +00 Address of common parameter exit (JMR)                 **\n**        +04 Address of 8-BYTE area containing job step name        **\n**        +08 Address of 8-BYTE area containing program name         **\n**        +12 Address of area containing accounting information      **\n**        +16 Address of Six-word area containing region limits      **\n**        +20 Address of word containing performance group number    **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   20-DEC-1997 Added extra entries and debugging code;    **\n** DGAlcock   14-MAR-1997 Added check for the program name to be     **\n**                        passed to IEFUTL;  Add check for job type  **\n**                        for quickouts for APPC and SYS addr spaces;**\n** DGAlcock   30-MAR-1996 Added Data Space and HiperSpace processing **\n**                        (no production users yet);                 **\n** DGAlcock   11-NOV-1994 Moved region table to separate CSECT for   **{\n**                        external program perusal;                  **\n** DGAlcock   20-OCT-1993 Set region size for large users;           **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         XYZMFX ,                         Map XYZ SMFexit area\n         IEFUSI#T ,                       Map IEFUSI#T CSECT areas\n         IEFJMR ,                         Job Management Record\n         YREGS ,                          Register Equates\n*\n** Generate debugging job name\n*\n         GBLC  &DBGJNME                Generate global variable\n&DBGJNME SETC  'ibmuserZ'              ..Jobname for debugging info\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Entry                                                       **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nIEFUSI   CSECT ,\nIEFUSI   AMODE 31\nIEFUSI   RMODE ANY\n*\n** Entry housekeeping\n*\n         SAVE  (14,12),,XYZ_SMFEXIT_IEFUSI_&ASMDATE._&SYSTIME\n         LR    R12,R15                    Load program base register\n         USING IEFUSI,R12                 Establish base for program\n*\n         LR    R3,R1                      Save address of parms\n         USING @USI,R3                    Get addressiblity to map\n*\n** Determine address space type and leave if we don't need this type\n*\n         L     R14,@USI_SUBS              Locate subsystem type\n         CLC   0(4,R14),=C'ASCH'          APPC?\n         BE    X$QUICKOUT\n         CLC   0(3,R14),=C'SYS'           System Address Space?\n         BE    X$QUICKOUT\n*\n** Obtain dynamic storage area for IEFUSI use only.\n*\n         LA    R0,DSAL                    Generate length\n       GETMAIN RU,                        Get Dynamic work area        @\n               LV=(0),                    ..Length                     @\n               SP=$DSA_SP,                ..Subpool: Low Private       @\n               LOC=BELOW                  ..Below the line\n*\n         ST    R13,4(,R1)                 Save caller's RSA pointer\n         ST    R1,8(,R13)                 Save my RSA pointer\n         LR    R13,R1                     Locate storage for exit usage\n         USING DSA,R13                    Establish addressability\n         ST    R0,DSAGLEN                 Save length GETMAINed\n*\n         L     R2,@USI_JMR                -> JMR\n         USING JMR,R2                     Get addressiblity to map\n*\n** Issue message for debugging job\n*\n         CLI   JMRSTEP,1                  First step?\n         BNE   I$DBX                      No, continue\n         CLC   JMRJOB(8),=C'&DBGJNME'     Debugging job?\n         BNE   I$DBX                      No, continue\n         LA    R15,WTOAREA                Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area\n         LA    R15,4(R15)                 Bump past WTO overhead\n         MVC   0(MSG192L,R15),MSG192      Get WTO text\n         ST    R12,DOUBLE                 Save IEFUSI EP for later\n         UNPK  MSG192EP-MSG192(9,R15),DOUBLE(5)\n         MVZ   MSG192EP-MSG192(8,R15),=8X'00'\n         TR    MSG192EP-MSG192(8,R15),=C'0123456789ABCDEF'\n         MVI   MSG192EP+8-MSG192(R15),C','\n         L     R1,=V(IEFUSI#T)            Locate CSECT\n         LA    R1,ZAPENTRY-IEFUSI#T(R1)   Locate to first zap entry\n         ST    R1,DOUBLE\n         UNPK  MSG192Z-MSG192(9,R15),DOUBLE(5)\n         MVZ   MSG192Z-MSG192(8,R15),=8X'00'\n         TR    MSG192Z-MSG192(8,R15),=C'0123456789ABCDEF'\n         MVI   MSG192Z+8-MSG192(R15),C' '\n         WTO   ,MF=(E,WTOAREA)            Issue the WTO message\nI$DBX    EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n** Set flag for IEFUTL.  IEFUTL doesn't operate in the normal job    **\n** environment so we do the unlimited CPU program name check here    **\n** and pass our results in the JMRUCOM for IEFUTL.                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LA    R1,JMRUCOM                 Locate area\n         USING XYZMFX,R1                  Map it\n         XC    XYZMFX_INIT(XYZMFX_INITL),XYZMFX_INIT\n*\n         L     R14,@USI_PGM               Locate program name\n         CLC   0(8,R14),=CL8'IEBCOPY'     Needs Unlimited CPU?\n         BE    UTL$SP\n         CLC   0(8,R14),=CL8'GIMSMP'      Needs Unlimited CPU?\n         BNE   UTL$X\nUTL$SP   DS    0H\n         MVI   XYZMFX_EXTENDP,1           Say we want unlimited CPU\n         DROP  R1\nUTL$X    DS    0H\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Set region information                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nSET_REGION_VALUES EQU *\n         L     R1,@USI_VRFLG              Locate V=R flag\n         TM    0(R1),X'80'                V=R?\n         BO    EXIT                       Yes, Skip remaining code\n*\n** See if we need to set different region values for this jobname\n*\n         L     R5,=V(IEFUSI#T)            Locate CSECT\n         LA    R5,TABLE_RS-IEFUSI#T(R5)   Locate region table\n         LA    R0,TABLE_RSN               Get number in table\nSRV$L    EQU   *\n         CLC   IEFUSIRS_JNAME-IEFUSIRS(8,R5),JMRJOB Match?\n         BE    SRV$LX                     Yes, continue\n         LA    R5,IEFUSIRSL(R5)           No, bump to next entry\n         BCT   R0,SRV$L                       and process it\n         CLC   JMRJOB(8),=C'&DBGJNME'     Debugging job?\n         BE    SRV$MSG                    No, continue\n         B     SRV$X                      Don't mess with Texas\nSRV$LX   EQU   *\n*\n** Set the different region values for this jobname\n*\n         L     R4,@USI_RGN                -> Region area\n         ICM   R1,B'1111',REGSZREQ-REGION(R4) Get requested region size\n         BZ    SRV$ZR                     Zero: use default values\n         OI    REGFLAGS-REGION(R4),X'80'  We are control freaks\n         AL    R1,=F'65536'               Add 64K\n         ST    R1,REGLIMB-REGION(R4)      Set as region limit below\n         MVC   REGSIZB-REGION(4,R4),REGSZREQ-REGION(R4) Region below\n         MVC   REGSIZA-REGION(4,R4),IEFUSIRS_RGNSZ-IEFUSIRS(R5) Size\n         MVC   REGLIMA-REGION(4,R4),IEFUSIRS_RGNSZ-IEFUSIRS(R5) Limst\n*\n** Issue message saying what we did\n*\nSRV$MSG  EQU   *\n         CLI   JMRSTEP,1                  First step?\n         BNE   SRV$X                      No, continue\n         LA    R15,WTOAREA                Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area\n         LA    R15,4(R15)                 Bump past WTO overhead\n         MVC   0(MSG190L,R15),MSG190      Get WTO text\n         LA    R15,MSG190L+1(R15)         Bump past message\n*\n         SLR   R0,R0                      Clear register for divide\n         L     R1,@USI_RGN                -> Region area\n         L     R1,REGSIZA-REGION(R1)      Get region size above\n         D     R0,=AL4(#IEFUSIRS_AMEG)    Divide to get number\n         BAS   R9,EDITFWF                 Edit (r1) full word flush\n*\n         MVC   1(MSG190SL,R15),MSG190S    Move in suffix\n         WTO   ,MF=(E,WTOAREA)            Issue the WTO message\n         B     SRV$X\n*\n** Issue message griping about REGION=0K in JCL and in table\n*\nSRV$ZR   EQU   *\n         LA    R15,WTOAREA                Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area\n         LA    R15,4(R15)                 Bump past WTO overhead\n         MVC   0(MSG191L,R15),MSG191      Get WTO text\n         WTO   ,MF=(E,WTOAREA)            Issue the WTO message\n*\n** Common exit from Set_Region_Values\n*\nSRV$X    EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Set Data Space and HiperSpace values                        **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nSET_DSHS_VALUES EQU *\n*\n** See if we need to set different region values for this jobname\n*\n         L     R5,=V(IEFUSI#T)            Locate CSECT\n         LA    R5,TABLE_DS-IEFUSI#T(R5)   Locate region table\n         LA    R0,TABLE_DSN               Get number in table\nSDV$L    EQU   *\n         CLC   IEFUSIDS_JNAME-IEFUSIDS(8,R5),JMRJOB Match?\n         BE    SDV$LX                     Yes, continue\n         LA    R5,IEFUSIDSL(R5)           No, bump to next entry\n         BCT   R0,SDV$L                       and process it\n         CLC   JMRJOB(8),=C'&DBGJNME'     Debugging job?\n         BE    SDV$MSG                    No, continue\n         B     SDV$X                      Don't mess with Texas\nSDV$LX   EQU   *\n*\n** Set the new size and ensure that it's not over the limit\n*\n         L     R1,@USI_DSHS               Locate area\n         MVC   DSHS_DEFSIZE-DSHS(4,R1),IEFUSIDS_SIZE-IEFUSIDS(R5)\n         CLC   DSHS_DEFSIZE-DSHS(4,R1),=X'0002D980'\n         BNH   SDV$SETX\n         MVC   DSHS_DEFSIZE-DSHS(4,R1),=X'0002D980' Set to maximum\nSDV$SETX EQU   *\n*\n** Print message saying what we did!\n*\nSDV$MSG  EQU   *\n         CLI   JMRSTEP,1                  First step?\n         BNE   SDV$X                      No, continue\n         LA    R15,WTOAREA                Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area\n         LA    R15,4(R15)                 Bump past WTO overhead\n         MVC   0(MSG193L,R15),MSG193      Get WTO text\n         LA    R15,MSG193L+1(R15)         Bump past message\n         L     R1,@USI_DSHS               Locate area\n         L     R1,DSHS_DEFSIZE-DSHS(R1)   Get the size we set\n         MH    R1,=AL2(4)                 Multiply by 4\n         BAS   R9,EDITFWF                 Edit (r1) full word flush\n         MVI   0(R15),C'K'                Set to value\n         WTO   ,MF=(E,WTOAREA)            Issue the WTO message\n*\n** Common exit from Set_DSHS_Values\n*\nSDV$X    EQU   *\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Exit from IEFUSI processing                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     DS    0H\n*\n** Free storage obtained for IEFUSI work area\n*\n         L     R0,DSAGLEN               Get storage area length\n         LR    R1,R13                   Get storage address\n         L     R13,4(,R1)               Save caller's RSA address\n      FREEMAIN RU,                      Free storage                   @\n               LV=(0),                  ..Length                       @\n               A=(1),                   ..Address                      @\n               SP=$DSA_SP               ..Subpool\n*\n** QUICKOUT is an exit point for jobs not processed by this exit\n*\nX$QUICKOUT EQU *\n         LM    R14,R12,12(R13)          Restore registers\n         SLR   R15,R15                  Clear register - (return code)\n         BSM   0,R14                    Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Misc internal subroutines                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Edit register 1 flush\n** Input: R1 - Value to edit\n**        R15 - Where edited value is to be put\n*\nEDITFWF  EQU   *\n         LTR   R1,R1                      Check for zero\n         BZ    EDITFWF0                   Yes, cut cpu cycles\n         CVD   R1,DOUBLE                  Convert number to packed\n         LA    R1,DOUBLE2+14              Locate significant digit\n         MVC   DOUBLE2(15),EDITP15        Get edit pattern\n         EDMK  DOUBLE2(15),DOUBLE+2       Edit number and save end\n         LA    R14,DOUBLE2+16             Locate past last byte\n         SR    R14,R1                     Length = end - start\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,EDITFWFM               Move edit number to output\n         LA    R15,0(R14,R15)             Bump pointer past number\n         MVI   0(R15),C' '                Fix binary zero\n         BSM   0,R9                       Return to caller\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'                Insert \"0\"\n         LA    R15,1(R15)                 Bump past it\n         BSM   0,R9                       Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Constants                                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSG190   DC    C'XYZ190I Region limit set to'\nMSG190L  EQU   *-MSG190\nMSG190S  DC    C'megabytes (above the line) for all steps'\nMSG190SL EQU   *-MSG190S\n*\nMSG191   DC    C'XYZ191W Region not set for job in table because '\nMSG191T  DC    C'REGION=0K in JCL'\nMSG191L  EQU   *-MSG191\n*\nMSG192   DC    C'XYZ192I IEFUSI Assembled on '\n         DC    C'&ASMDATE'\n         DC    C' at '\n         DC    C'&SYSTIME'\n         DC    C' - EPA='\nMSG192EP DC    C'xxxxxxxx'\n         DC    C', 1ZapEntry='\nMSG192Z  DC    C'xxxxxxxx'\nMSG192L  EQU   *-MSG192\n*\nMSG193   DC    C'XYZ193I Default user Data Space and Hiperspace size:'\nMSG193L  EQU   *-MSG193\n*\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',                                              @\n               MCSFLAG=HRDCPY,                                         @\n               MF=L\nC_WTOL   EQU   *-C_WTO\n*\n** Literals\n*\n         LTORG ,\n         DS    0D\nIEFUSIL  EQU   *-IEFUSI                       Length of IEFUSI CSECT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Tables and data that we will let be externally referenced   **\n**                                                                   **\n**   Note: The H_J2VS/J2X06EDH_J2VS at offset 0 is done to simulate  **\n**         the ADRRELVL and ICKRELVL modules.                        **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Start of CSECT\n*\nIEFUSI#T CSECT ,\nIEFUSI#T AMODE 31\nIEFUSI#T RMODE ANY\n*\nHEADER   EQU   *\nH_ID     DC    CL8'IEFUSI#T'                  Module name\nH_ASMD   DC    CL10'&ASMDATE'                 ASM date: \"1994/03/06\"\nH_ASMT   DC    CL6'&SYSTIME'                  ASM time: \"hh:mm\"\nH_DBJOB  DC    CL8'&DBGJNME'                  Debugging jobname\nHEADERL  EQU   *-HEADER                       Must match IEFUSIEDHL\nHEADERT  EQU   IEFUSIEDHL                     Match?  !!!!\n*\n** Offsets for external programs (mapped by IEFUSI#T)\n*\nENTRIES  EQU   *\n         DC    AL2($IEFUSIEDE_TRS,TABLE_RS-IEFUSI#T)  Region Size\n         DC    AL2($IEFUSIEDE_TDS,TABLE_DS-IEFUSI#T)  Data/hip-spc\n         DC    AL1(#IEFUSIEDE_END)                    End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***  Region size assigned by jobname                                ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         PRINT DATA\nTABLE_RS DS    0F\n         DC    CL8'NET     ',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'NETVIEW1',A(64*#IEFUSIRS_AMEG)\n*\n         DC    CL8'DB2DDBM1',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'DB2PDBM1',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'DB2DMSTR',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'DB2PMSTR',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'IRLDPROC',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'IRLPPROC',A(64*#IEFUSIRS_AMEG)\n*\n         DC    CL8'TPX1    ',A(66*#IEFUSIRS_AMEG)\n         DC    CL8'TPX2    ',A(66*#IEFUSIRS_AMEG)\n         DC    CL8'TPX3    ',A(66*#IEFUSIRS_AMEG)\n         DC    CL8'TPX4    ',A(66*#IEFUSIRS_AMEG)\n         DC    CL8'TPX5    ',A(66*#IEFUSIRS_AMEG)\n         DC    CL8'TPX6    ',A(66*#IEFUSIRS_AMEG)\n         DC    CL8'TPX9    ',A(66*#IEFUSIRS_AMEG)\n* 4.1\n         DC    CL8'CICS1   ',A(192*#IEFUSIRS_AMEG)\n         DC    CL8'CICS2   ',A(192*#IEFUSIRS_AMEG)\n*\n         DC    CL8'TCPIP   ',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'TCPIPRF ',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'TCPIPT  ',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'TCPIPTRF',A(64*#IEFUSIRS_AMEG)\n*\n         DC    CL8'EDMMGR  ',A(256*#IEFUSIRS_AMEG)\n*\n         DC    CL8'ibmuserL',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'ibmuserZ',A(64*#IEFUSIRS_AMEG)\n*\nZAPENTRY EQU   * - - - - - - - - - - - - - - - - - - -Zappable entries\n         DC    CL8'ZAP256A ',A(256*#IEFUSIRS_AMEG)\n         DC    CL8'ZAP256B ',A(256*#IEFUSIRS_AMEG)\n         DC    CL8'ZAP192A ',A(192*#IEFUSIRS_AMEG)\n         DC    CL8'ZAP192B ',A(192*#IEFUSIRS_AMEG)\n         DC    CL8'ZAP128A ',A(128*#IEFUSIRS_AMEG)\n         DC    CL8'ZAP128B ',A(128*#IEFUSIRS_AMEG)\n         DC    CL8'ZAP64A  ',A(64*#IEFUSIRS_AMEG)\n         DC    CL8'ZAP64B  ',A(64*#IEFUSIRS_AMEG)\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\nTABLE_RSN EQU  ((*-TABLE_RS)/IEFUSIRSL)\n         DC    AL1(#IEFUSIEDE_END)                    End of table\n         PRINT NODATA\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***  Default Data Space and Hiper Space size                        ***\n***                                                                  **\n***  Note: maximum is 186742                                         **\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         PRINT DATA\nTABLE_DS DS    0F\n         DC    CL8'ibmuserL',A(512)\nTABLE_DSN EQU  ((*-TABLE_DS)/IEFUSIDSL)\n         DC    AL1(#IEFUSIEDE_END)                    End of table\n         PRINT NODATA\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      End of IEFUSI#T CSECT                                      ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         DC    C'ENDOFIEFUSI#T'           Eyecatcher\n         DS    0D\nIEFUSI$T EQU   *-IEFUSI                   Length (for trivia)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**                 Dynamic Save Area                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n$DSA_SP  EQU   252                        SubPool = Low Private\nDSA      DSECT ,\n         DS    18F                        Register Save Area\nDSAGLEN  DS    F                          Length of DSA\nDOUBLE   DS    D                          Double word work area\nDOUBLE2  DS    2D                         Double word work area * 2\nWTOAREA  DS    XL(C_WTOL)                 WTO work area\n         DS    0D\nDSAL     EQU   *-DSA\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       DSECTs and Equates                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Parameter list passed to us in register 1 upon entry\n*\n@USI       DSECT ,\n@USI_JMR   DS    XL4            1         -> CEPA (JMR)\n@USI_STEPN DS    XL4            2         -> 8 byte Step name\n@USI_PGM   DS    XL4            3         -> 8 byte Program name\n@USI_ACCT  DS    XL4            4         -> Account information\n@USI_RGN   DS    XL4            5         -> Region information\n@USI_VRFLG DS    XL4            6         -> V=R flag address\n@USI_DSHS  DS    XL4            7         -> Data Spaces & Hiperspaces\n@USI_SUBS  DS    XL4            8         -> Subsystem name\n*\n** Map the 6 word area pointed to by @USI_RGN (+16) in R1\n**\n** Copied from the sample IEFUSI exit in IPO1.SAMPLIB (MVS 4.2.2)\n*\nREGION   DSECT ,\nREGFLAGS DS    F                          FLAG WORD\nREGSZREQ DS    F                          REGION SIZE REQUESTED\nREGLIMB  DS    F                          REGION LIMIT BELOW 16MB\nREGSIZB  DS    F                          REGION SIZE BELOW 16MB\nREGLIMA  DS    F                          REGION LIMIT ABOVE 16MB\nREGSIZA  DS    F                          REGION SIZE ABOVE 16MB\n*\n** Map the 3 word area pointed to by @USI_DSHS (word 7) in R1 on entry\n*\nDSHS           DSECT ,\nDSHS_DEFSIZE   DS    XL4\nDSHS_MAXSIZE   DS    XL4\nDSHS_MAXNUM    DS    XL4\n         END\n./ ADD NAME=IEFUSI#T 0100-98016-98016-1800-00062-00062-00000-DALCOCK\n MACRO\n IEFUSI#T\n.**********************************************************************\n.***                                                                ***\n.**  Name: IEFUSI#T                                                  **\n.**                                                                  **\n.**  Purpose: External mappings for XYZ SMF exit IEFUSI to map data  **\n.**           in the IEFUSI#T CSECT/module.                          **\n.**                                                                  **\n.**  Note: The IEFUSI#T module is a part of the IEFUSI load module   **\n.**        that is available to other programs via the alias to      **\n.**        CSECT IEFUSI#T.                                           **\n.***                                                                ***\n.**********************************************************************\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   11-NOV-1994 Created this mapping macro to be used by  **\n.**                        SMF exit IEFUSI and external programs     **\n.**                        that read the IEFUSI#T module;            **\n.***                                                                ***\n.**********************************************************************\n*\n** External data (IEFUSI#T) mappings\n*\nIEFUSIED       DSECT ,\nIEFUSIEDH      EQU   *                 Module header\nIEFUSIEDH_ID   DS    CL8'IEFUSI#T'     ..Module name\nIEFUSIEDH_ASMD DS    CL10'1962/03/06'  ..Assembly date\nIEFUSIEDH_ASMT DS    CL6'21:05'        ..Assembly time\nIEFUSIEDH_DBJOB DS   CL8'jobname'      ..debugging jobname\nIEFUSIEDHL     EQU   *-IEFUSIEDH\n*\nIEFUSIEDE      EQU   *                 Data area entry\nIEFUSIEDE_TYPE DS    CL2               ..Data area Type\n$IEFUSIEDE_TRS EQU   C'RS'               ..Region Size\n$IEFUSIEDE_TDS EQU   C'DS'               ..Data Space and Hiperspace\nIEFUSIEDE_OFF  DS    XL2               ..Offset to data area\nIEFUSIEDEL     EQU   *-IEFUSIEDE       Data area entry\n#IEFUSIEDE_END EQU   X'FF'             End of table\n*\n** Region size table\n*\nIEFUSIRS       DSECT ,\nIEFUSIRS_JNAME DS    CL8'jobname'      Job name/TSO user name\nIEFUSIRS_RGNSZ DS    XL4               Region size\nIEFUSIRSL      EQU   *-IEFUSIRS\n#IEFUSIRS_AMEG EQU   1024*1024\n*\n** Data space and Hiperspace table\n*\nIEFUSIDS       DSECT ,\nIEFUSIDS_JNAME DS    CL8'jobname'      Job name/TSO user name\nIEFUSIDS_SIZE  DS    XL4               Data Space and HiperSpace size\nIEFUSIDSL      EQU   *-IEFUSIDS\n.*\n.** End of macro\n.*\n MEND ,\n./ ADD NAME=IEFUTL   0100-98016-98016-1800-00570-00570-00000-DALCOCK\nIEFUTL   TITLE 'XYZ - IEFUTL - SMF EXIT - Time Limit Exit'\n***********************************************************************\n***                                                                 ***\n** Name = IEFUTL                                                     **\n**                                                                   **\n** Author: David Alcock                                              **\n**         Rewritten based on earlier XYZ source                     **\n**                                                                   **\n** Purpose = SMF Time limit exit                                     **\n**           - CPU time extensions                                   **\n**           - WAIT time extensions                                  **\n**                                                                   **\n** Reference = GC28-1153 MVS/XA SPL System Management Facilities     **\n**                                                                   **\n** Warning = A system interlock occurs anytime IEFUTL enqueues on    **\n**           a resource already enqueued on by the job. For example  **\n**           do not use the Write-To-Programmer WTO route code.      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n***********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   14-MAR-1997 Moved XYZSMFX field to the JMRUCOM;        **\n** DGAlcock   26-JUN-1992 Let all TSO users enjoy 1 hours wait;      **\n** DGAlcock   16-MAR-1992 Rewritten from earlier XYZ source;  Made   **\n**                        AMODE31 (TPUTs below the line) for MVS/ESA;**\n**                        All started tasks will be driven thru      **\n**                        wait and CPU checking and need not be in   **\n**                        the various tables.                        **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         IEFUTL#T ,                       Map IEFUTL#T CSECT areas\n         XYZSMFX ,                        XYZ SMF exit common stuff\n         IEFJMR ,                         Job Management Record\n         YREGS ,                          Equate registers\n         PRINT NOGEN\n         IHAPSA ,                         Prefixed Save Area\n         IKJTCB ,                         Task Control Block\n         IEZJSCB ,                        Job Step Control Block\n         IEFJSSIB ,                       SubSystem Identification Blk\n*\n** Global stuff\n*\n         GBLC  &DBGJNME                Generate global variable\n&DBGJNME SETC  'ibmuserZ'              ..Jobname for debugging info\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY-MM-DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'-'.'&SYSDATC'(5,2).'-'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Entry                                                       **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nIEFUTL   CSECT ,\nIEFUTL   AMODE 31\nIEFUTL   RMODE ANY\n*\n** Entry Housekeeping\n*\n         SAVE  (14,12),,XYZ_SMFEXIT_IEFUTL_&ASMDATE._&SYSTIME\n         LR    R12,R15                    Get Base register\n         USING IEFUTL,R12                 Obtain addressiblity to CSECT\n*\n         LR    R6,R0                      Save Expired Time limit code\n         L     R10,0(R1)                  => Common Exit parameter list\n         USING JMR,R10                    Get addressibility to it\n*\n** Obtain storage for our work area\n*\n         LA    R0,DSAL                    Length of area\n       GETMAIN RU,                        Obtain storage               @\n               LV=(0),                    ..Length                     @\n               SP=$DSA_SP,                ..Subpool - Low private      @\n               LOC=BELOW                  ..Location: Below the line\n*\n** Forward/Backword chaining\n*\n         ST    R13,4(,R1)                 Save Backward RSA Pointer\n         ST    R1,8(,R13)                 Save Forward RSA Pointer\n         LR    R13,R1                     Get DSA/RSA Address\n         USING DSA,R13                    Get Addressiblity to it\n*\n         MVI   RCODE,$RCODE0              Set Default Return Code\n*\n** Branch to routine based on binary value (set in R0 upon entry)\n*\n         CH    R6,=H'0'                   Job CPU time exceeded\n         BE    CPUTIME\n         CH    R6,=H'4'                   Step CPU time exceeded\n         BE    CPUTIME\n         CH    R6,=H'8'                   Wait time exceeded\n         BE    WAITTIME\n*\n         B     EXIT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**  Return to caller                                                 **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXTEND   DS    0H\n         MVI   RCODE,$RCODE8              Set Extend RC (Seconds)\n*\n** If we branch directly to \"EXIT\", the time is not extended...\n*\nEXIT     DS    0H\n         SLR   R4,R4                      Clear register\n         IC    R4,RCODE                   Load return code\n         LR    R1,R13                     Get our RSA/DSA\n         L     R13,4(,R1)                 Get caller's RSA\n*\n** Free DSA area\n*\n         LA    R0,DSAL                    Length of area\n      FREEMAIN RU,                        Free storage                 @\n               LV=(0),                    ..Length                     @\n               A=(1),                     ..Address                    @\n               SP=$DSA_SP                 ..Subpool\n*\n** Exit housekeeping\n*\n         LR    R15,R4                     Restore return code\n         LR    R1,R5                      Set time extension\n*\n         L     R14,12(,R13)               Get return address\n         L     R0,20(,R13)                Get caller's register zero\n         LM    R2,R12,28(R13)             Restore rest of registers\n         BSM   0,R14                      Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       CPU Time Exceeded                                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nCPUTIME  EQU   *\n*\n** Check for TSO users not be be cancelled\n*\n         TM    JMRINDC,JMRFIND            TSO user?\n         BNO   CT$TSOX                    No, continue\n*\n         L     R1,=V(IEFUTL#T)            Locate CSECT\n         LA    R1,TABLE_CT-IEFUTL#T(R1)   Locate table\n         LA    R0,TABLE_CTN               Number of entries in table\nCT$TSOL  EQU   *\n         CLC   JMRJOB(8),0(R1)            USERID match?\n         BE    CT$TSOE                    Yes, grant extension\n         LA    R1,8(R1)                   No, bump to next entry\n         BCT   R0,CT$TSOL                     and process it\n*\n         LA    R1,JMRUCOM                 Locate XYZSMFX area\n         CLI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' First time?\n         BE    CT$TSOK                    No, kill it (no more given)\n         MVI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' Set that we've done it\n         MVC   WTO(MSG156L),MSG156        Get the message\n         TPUT  WTO,MSG156L                Issue the message to TSO\nCT$TSOE  EQU   *\n         MVC   WTO(MSG150L),MSG150        Get the message\n         MVI   WTO+(MSG150A-MSG150),C'0'  Set to \"05\" minutes\n         TPUT  WTO,MSG150L                Issue the message to TSO\n         L     R5,=AL4(5*60)              5 minutes\n         B     EXTEND                     Extend for 5 minutes\nCT$TSOK  EQU   *                          Kill Your Television\n         MVC   WTO(MSG157L),MSG157        Get the message\n         TPUT  WTO,MSG157L                Issue the message to TSO\n         B     EXIT                       Grant no extension...\n*\nCT$TSOX  EQU   *\n*\n** Check for jobs not to be cancelled because of CPU being exceeded\n*\n         L     R1,=V(IEFUTL#T)\n         LA    R1,TABLE_CJ-IEFUTL#T(R1)   Locate table\n         LA    R0,TABLE_CJN               Number of entries in table\nCT$JOBL  EQU   *\n         CLC   JMRJOB(8),0(R1)            JobName match?\n         BE    CT$JOBE                    Yes, grant extension\n         LA    R1,8(R1)                   No, bump to next entry\n         BCT   R0,CT$JOBL                     and process it\n         B     CT$PGMS\n*\nCT$JOBE  EQU   *\n         LA    R15,WTO                    Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area\n         MVC   4(MSG150L,R15),MSG150      Move in message\n         LA    R15,4+MSG150L+1(R15)       Bump past message\n         BAS   R14,INSERT_JOBID           Get job ID\n         WTO   ,MF=(E,WTO)                Issue the WTO\n         L     R5,=AL4(15*60)             15 minutes in seconds\n         B     EXTEND                     Extend that puppy\n*\n** Check for programs not to be cancelled\n*\nCT$PGMS  DS    0H\n         LA    R1,JMRUCOM                 Locate XYZSMFX area\n         CLI   XYZSMFX_EXTENDP-XYZSMFX(R1),X'01' Program needs expand\n         BNE   EXIT                       Nope, leave\n         LA    R15,WTO                    Locate WTO work area\n         MVC   0(C_WTOL,R15),C_WTO        Initialize WTO area\n         MVC   4(MSG150L,R15),MSG150      Move in message\n         LA    R15,4+MSG150L+1(R15)       Bump past message\n         BAS   R14,INSERT_JOBID           Get job ID\n         MVC   1(8,R15),=C'for PGM='      Tell why we're doing this\n         LA    R15,1+8(R15)               Bump past text\n         MVC   0(8,R15),0(R4)             Insert program name\n         WTO   ,MF=(E,WTO)                Issue the WTO\n         L     R5,=AL4(15*60)             15 minutes in seconds\n         B     EXTEND                     Extend that puppy\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Wait Time Exceeded                                          **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nWAITTIME EQU   *\n         TM    JMRINDC,JMRFIND            TSO user?\n         BNO   WT$TSOX                    No, continue\n*\n** Check for TSO users to be extended, Basically we extend all\n** TSO users:\n**\n** - Default is 30 minutes (except for PSO which gets 60 minutes)\n** - If in the table, get 2 hours\n*\n         L     R1,=V(IEFUTL#T)            Locate CSECT\n         LA    R1,TABLE_WT-IEFUTL#T(R1)   Locate table\n         LA    R0,TABLE_WTN               Number of entries in table\nWT$TSOL  EQU   *\n         CLC   JMRJOB(8),0(R1)            USERID match?\n         BE    WT$TSOE                    Yes, grant extension\n         LA    R1,8(R1)                   No, bump to next entry\n         BCT   R0,WT$TSOL                     and process it\n*\n         LA    R1,JMRUCOM                 Locate XYZSMFX area\n         CLI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' First time?\n         BE    WT$TSOK                    No, kill it (no more given)\n         MVI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' Set that we did it\n*\n         CLI   JMRJOB,C'P'                PSO?\n         BE    WT$TSOP                    Yes, only 30 minutes\n         L     R5,=AL4(60*60)             1 hours in seconds\n         B     EXTEND                     Extend for 1 hour\nWT$TSOP  EQU   *                          PSO users only get 30 minutes\n*\n         L     R5,=AL4(30*60)             30 minutes in seconds\n         B     EXTEND                     Extend for 1 hour\nWT$TSOK  EQU   *                          Kill Your Television\n         MVC   WTO(MSG153L),MSG153        Get the message\n         TPUT  WTO,MSG153L                Issue the message to TSO\n         B     EXIT                       Grant no extension...\n*\nWT$TSOE  EQU   *\n         LA    R1,JMRUCOM                 Locate XYZSMFX area\n         CLI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' First time?\n         BE    WT$TSOK                    No, kill it (no more given)\n         MVI   XYZSMFX_EXTENDC-XYZSMFX(R1),X'01' Set that we did it\n         L     R5,=AL4(120*60)            2 Hours in seconds\n         B     EXTEND                     Extend for 2 hours\nWT$TSOX  EQU   *\n*\n** Check for jobs not to be cancelled\n*\n         L     R1,=V(IEFUTL#T)            Locate CSECT\n         LA    R1,TABLE_WJ-IEFUTL#T(R1)   Locate table\n         LA    R0,TABLE_WJN               Number of entries in table\nWT$JOBL  EQU   *\n         CLC   JMRJOB(8),0(R1)            JobName match?\n         BE    WT$JOBE                    Yes, grant extension\n         LA    R1,8(R1)                   No, bump to next entry\n         BCT   R0,WT$JOBL                     and process it\n*\n         LA    R0,MSG151L                 Get length of WTOR text\n         LA    R1,MSG151                  Get address of WTOR text\n         BAS   R9,ISSUE_WTOR              Issue the WTOR\n*\n         OI    WTOREPLY,X'40'             Ensure uppercase\n         CLI   WTOREPLY,C'N'              Operator said \"No way, Jose\"?\n         BE    WT$JOBC                    Yes: goodbye Columbus\n         MVC   WTO(C_WTOL),C_WTO          Initialize WTO area\n         MVC   WTO+4(MSG155L),MSG155      Move in message\n         LA    R15,WTO+4+MSG155L+1        Locate to end of message\n         MVC   0(1,R15),=C'5'             Insert minutes\n         MVC   2(16,R15),=C'minutes given to' Insert text\n         LA    R15,2+16+1(R15)            Bump past minutes & text\n         BAS   R14,INSERT_JOBID           Get job ID\n         WTO   ,MF=(E,WTO)                Issue the WTO\n         L     R5,=AL4(5*60)              5 minutes in seconds\n         B     EXTEND                     Extend for 5 minutes\n*\nWT$JOBC  EQU   *\n         MVC   WTO(C_WTOL),C_WTO          Initialize WTO area\n         MVC   WTO+4(MSG154L),MSG154      Move in message\n         LA    R15,WTO+4+MSG154L+1        Locate to end of message\n         BAS   R14,INSERT_JOBID           Get job ID\n         WTO   ,MF=(E,WTO)                Issue the WTO\n         B     EXIT                       Leave\n*\nWT$JOBE  EQU   *\n         MVC   WTO(C_WTOL),C_WTO          Initialize WTO area\n         MVC   WTO+4(MSG155L),MSG155      Move in message\n         LA    R15,WTO+4+MSG155L+1        Locate to end of message\n         MVC   0(2,R15),=C'60'            Insert minutes\n         MVC   3(16,R15),=C'minutes given to' Insert text\n         LA    R15,3+16+1(R15)            Bump past minutes & text\n         BAS   R14,INSERT_JOBID           Get job ID\n         WTO   ,MF=(E,WTO)                Issue the WTO\n         L     R5,=AL4(60*60)             60 minutes in seconds\n         B     EXTEND                     Extend for 60 minutes\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Issue WTOR                                                  **\n**                                                                   **\n**       Input: R0 - Length (-message ID suffix)                     **\n**              R1 - Address of message                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nISSUE_WTOR EQU *\n         LA    R15,WTOR                   Locate work area\n         MVC   0(C_WTORL,R15),C_WTOR      Initialize WTOR\n         LA    R15,12(R15)                Bump past overhead bytes\n         MVC   0(3,R15),MSG150            Get message prefix of \"XYZ\"\n         MVC   3(4,R15),0(R1)             Get message ID\n         LA    R15,3+4+1(R15)             Bump past \"XYZxxxA \"\n         BAS   R14,INSERT_JOBID           Insert job name/id stuff\n         LR    R14,R0                     Get length to move\n         BCTR  R14,0                      Decrement for EX\n         EX    R14,IW_MMSG                Move message out\n*\nIW$WTOR  EQU   *\n         LA    R2,WTOREPLY                Locate WTOR reply area\n         LA    R3,WTORECB                 Locate WTOR ECB\n         LA    R4,WTOR                    Locate WTOR to execute\n         XC    0(4,R3),0(R3)              Clear ECB to zeros\n         WTOR  ,(2),                      Issue WTOR                   @\n               L'WTOREPLY,                ..Length of reply            @\n               (3),                       ..ECB address                @\n               MF=(E,(4))                 ..parameter list\n*\n         WAIT  1,                         Wait                         @\n               ECB=(3),                   ..Address of ECB             @\n               LONG=YES                   ..Don't time out!\n*\n         BSM   0,R9                       Return to caller\n*\nIW_MMSG  MVC   0(0,R15),4(R1)             Move message to WTOR\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Misc internal subroutines                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Insert \"JOB jobname (jobid)\" at R15\n*\nINSERT_JOBID EQU *\n         MVC   0(3,R15),=C'Job'           Set JOB\n         LA    R15,3+1(R15)               Bump past it\n         MVC   0(8,R15),JMRJOB            Move in the job name\n         LA    R15,9(R15)\n         BSM   0,R14\n         EJECT\n***********************************************************************\n***                                                                 ***\n**                    C o n s t a n t s                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMSG150   DC    C'XYZ150I CPU time extension of '\nMSG150A  DC    C'15 minutes given to'\nMSG150L  EQU   *-MSG150\n*\nMSG151   DC    C'151A'\nMSG151S  DC    C'has exceeded the WAIT time limit, '\n         DC    C'reply \"N\" to cancel'\nMSG151L  EQU   *-MSG151S\n*\nMSG153   DC    C'XYZ153I TSO WAIT time exceeded, your TSO session is '\n         DC    C'being cancelled'\nMSG153L  EQU   *-MSG153\n*\nMSG154   DC    C'XYZ154I Operator did not extend wait time for'\nMSG154L  EQU   *-MSG154\n*\nMSG155   DC    C'XYZ155I WAIT time extension of'\nMSG155L  EQU   *-MSG155\n*\nMSG156   DC    C'XYZ156I CPU time exceeded, you will be granted '\n         DC    C'one 5 minute extension'\nMSG156L  EQU   *-MSG156\n*\nMSG157   DC    C'XYZ157I CPU time exceeded, your TSO session is '\n         DC    C'being cancelled'\nMSG157L  EQU   *-MSG157\n*\nMSG158   DC    C'XYZ158I IEFUTL entered - '\n         DC    C'assembled on &ASMDATE at &SYSTIME'\nMSG158L  EQU   *-MSG158\n*\nC_WTOR   WTOR  '                                                       @\n                                                                       @\n                       ',MF=L\nC_WTORL  EQU    *-C_WTOR\n*\nC_WTO    WTO   '                                                       @\n                                                                       @\n                       ',MF=L\nC_WTOL   EQU   *-C_WTO\n*\n** Literals used in IEFUTL\n*\n         LTORG ,\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Tables and data that we will let be externally referenced   **\n**                                                                   **\n**   Note: The H_J2VS/J2X06EDH_J2VS at offset 0 is done to simulate  **\n**         the ADRRELVL and ICKRELVL modules.                        **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Start of CSECT\n*\nIEFUTL#T CSECT ,\nIEFUTL#T AMODE 31\nIEFUTL#T RMODE ANY\n*\nHEADER   EQU   *\nH_ID     DC    CL8'IEFUTL#T'                  Module name\nH_ASMD   DC    CL10'&ASMDATE'                 ASM date: \"1994/03/06\"\nH_ASMT   DC    CL6'&SYSTIME'                  ASM time: \"hh:mm\"\nH_DBJOB  DC    CL8'&DBGJNME'                  Debugging jobname\nHEADERL  EQU   *-HEADER                       Must match IEFUTLEDHL\nHEADERT  EQU   IEFUTLEDHL                     Match?  !!!!\n*\n** Offsets for external programs (mapped by IEFUTL#T)\n*\nENTRIES  EQU   *\n         DC    AL2($IEFUTLEDE_TCJ,TABLE_CJ-IEFUTL#T)  CPU - Jobname\n         DC    AL2($IEFUTLEDE_TCP,TABLE_CP-IEFUTL#T)  CPU - Program\n         DC    AL2($IEFUTLEDE_TCT,TABLE_CT-IEFUTL#T)  CPU - TSO user\n         DC    AL2($IEFUTLEDE_TWJ,TABLE_WJ-IEFUTL#T)  Wait - Jobname\n         DC    AL2($IEFUTLEDE_TWT,TABLE_WT-IEFUTL#T)  Wait - TSO user\n         DC    AL1(#IEFUTLEDE_END)                    End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***  Jobs that are not cancelled if the CPU time is exceeded        ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\nTABLE_CJ DS    0F\n         DC    CL8'STCNAME1'        PRODUCTION CICS\n         DC    CL8'STCNAME2'        PRODUCTION CICS\nTABLE_CJN EQU  ((*-TABLE_CJ)/8)     -> Number of entries in table\n         DC    AL1(#IEFUTLEDE_END)                    End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***  Programs not to be cancelled if the CPU time is exceeded       ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\nTABLE_CP DS    0F\n         DC    CL8'GIMSMP'                SMP/E PROGRAM\n         DC    CL8'IEBCOPY'               IEBCOPY\nTABLE_CPN EQU  ((*-TABLE_CP)/8)     -> Number of entries in table\n         DC    AL1(#IEFUTLEDE_END)                    End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***  TSO users that are not cancelled if the CPU time is exceeded   ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\nTABLE_CT DS    0F\n         DC    CL8'TSOUSR01'\n         DC    CL8'TSOUSR99'\nTABLE_CTN EQU  ((*-TABLE_CT)/8)     -> Number of entries in table\n         DC    AL1(#IEFUTLEDE_END)                    End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***  Jobs not to be cancelled if the Wait time is exceeded          ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\nTABLE_WJ DS    0F\n         DC    CL8'JOBNAME1'        NOSP KEY PROCESSOR\n         DC    CL8'ROSCOE  '        PRODUCTION ROSCOE\n         DC    CL8'ROSCOET '        Test ROSCOE\nTABLE_WJN EQU  ((*-TABLE_WJ)/8)     -> Number of entries in table\n         DC    AL1(#IEFUTLEDE_END)                    End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***  Jobs not to be cancelled if the Wait time is exceeded          ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n*\n** TSO Users that will get 2 hours of wait time\n*\nTABLE_WT DS    0F\n         DC    CL8'TSOUSR01'\n         DC    CL8'TSOUSR99'\n*\nTABLE_WTN EQU  ((*-TABLE_WT)/8)     -> Number of entries in table\n         DC    AL1(#IEFUTLEDE_END)                    End of table\n         SPACE 2\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n**                                                                   **\n***      End of IEFUTL#T CSECT                                      ***\n**                                                                   **\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n         DC    C'ENDOFIEFUTL#T'           Eyecatcher\n         DS    0D\nIEFUTL$T EQU   *-IEFUTL                   Length (for trivia)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       IEFUTL Getmained work area                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n$DSA_SP  EQU   252                        Subpool: Low private\nDSA      DSECT\n         DS    18F                        Register Save Area\nDOUBLE   DS    D\nWTO      EQU   *\nWTORECB  DS    F                          ..ECB\nWTOR     DS    CL256                      ..Work area\nWTOREPLY DS    CL3                        ..Reply\nWTOL     EQU   *-WTO\n*\nRCODE    DS    X                          IEFUTL Return code\n$RCODE0  EQU   X'00'                      ..Cancel job\n$RCODE4  EQU   X'04'                      ..Continue job w/Timer units\n$RCODE8  EQU   X'08'                      ..Continue job w/Seconds\n*\n         DS    0D                         Set for alignment\nDSAL     EQU   *-DSA\n         END\n./ ADD NAME=IEFUTL#T 0100-98016-98016-1800-00057-00057-00000-DALCOCK\n MACRO\n IEFUTL#T\n.**********************************************************************\n.***                                                                ***\n.**  Name: IEFUTL#T                                                  **\n.**                                                                  **\n.**  Purpose: External mappings for XYZ SMF exit IEFUTL to map data  **\n.**           in the IEFUTL#T CSECT/module.                          **\n.**                                                                  **\n.**  Note: The IEFUTL#T module is a part of the IEFUTL load module   **\n.**        that is available to other programs via the alias to      **\n.**        CSECT IEFUTL#T.                                           **\n.***                                                                ***\n.**********************************************************************\n.**********************************************************************\n.***                                                                ***\n.**           M o d i f i c a t i o n   H i s t o r y                **\n.**                                                                  **\n.** Person     Date        Description                               **\n.** ---------- ----------- ----------------------------------------- **\n.** DGAlcock   24-JUL-1996 Added program table                       **\n.** DGAlcock   20-SEP-1994 Created this mapping macro to be used by  **\n.**                        SMF exit IEFUTL and external programs     **\n.**                        that read the IEFUTL#T module;            **\n.***                                                                ***\n.**********************************************************************\n*\n** External data (IEFUTL#T) mappings\n*\nIEFUTLED       DSECT ,\nIEFUTLEDH      EQU   *                 Module header\nIEFUTLEDH_ID   DS    CL8'IEFUTL#T'     ..Module name\nIEFUTLEDH_ASMD DS    CL10'1962/03/06'  ..Assembly date\nIEFUTLEDH_ASMT DS    CL6'21:05'        ..Assembly time\nIEFUTLEDH_DBJOB DS   CL8'jobname'      ..debugging jobname\nIEFUTLEDHL     EQU   *-IEFUTLEDH\n*\nIEFUTLEDE      EQU   *                 Data area entry\nIEFUTLEDE_TYPE DS    CL2               ..Data area Type\n$IEFUTLEDE_TCJ EQU   C'CJ'             ..CPU for jobs\n$IEFUTLEDE_TCT EQU   C'CT'             ..CPU for TSO users\n$IEFUTLEDE_TCP EQU   C'CP'             ..CPU for program names\n$IEFUTLEDE_TWJ EQU   C'WJ'             ..Wait time for jobs\n$IEFUTLEDE_TWT EQU   C'WT'             ..Wait time for TSO users\nIEFUTLEDE_OFF  DS    XL2               ..Offset to data area\nIEFUTLEDEL     EQU   *-IEFUTLEDE       Data area entry\n#IEFUTLEDE_END EQU   X'FF'             End of table\n*\n** Generic jobname entry\n*\nIEFUTLJN       DSECT ,\nIEFUTLJN_VALUE DS    CL8'jobname'      Job name/TSO user name\nIEFUTLJNL      EQU   *-IEFUTLJN\n.*\n.** End of macro\n.*\n MEND ,\n./ ADD NAME=XYZSMFX  0100-98016-98016-1800-00021-00021-00000-DALCOCK\n MACRO ,\n XYZSMFX ,\n*\n** Map the usage of the JMRUCOM (4 byte) area which is used by IEFUSI\n** and IEFUTL.\n**\n** If we needed more data areas more room, we could obtain a data\n** area and save address in first four bytes.\n**\n** See IBM's sample IEFACTRT for how the first byte is\n** set.\n*\nXYZSMFX          DSECT ,\n                 DS    X         Used by IPOACTRT (IBM's IEFACTRT)\nXYZSMFX_INIT     EQU   *\nXYZSMFX_EXTENDW  DS    X         IEFUTL has already extended for wait\nXYZSMFX_EXTENDC  DS    X         IEFUTL has already extended for CPU\nXYZSMFX_EXTENDP  DS    X         Set by IEFUSI if program should get   @\n                                 unlimited CPU - Checked by IEFUTL\nXYZSMFX_INITL    EQU   *-XYZSMFX_INIT\n MEND ,\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 18:01 ON 98/01/16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPEPP": {"ttr": 27651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00\\x05\\x00\\x99\\x06\\x0f\\x01\\x020o\\x186\\x04\\xbb\\x04\\xaf\\x00\\x00\\xc4\\xc1\\xd3\\xc3\\xd6\\xc3\\xd2@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:36:05", "lines": 1211, "newlines": 1199, "modlines": 0, "user": "DALCOCK"}, "text": "./ ADD NAME=$README  1200-98062-98062-2029-00027-00027-00000-DAVEA\n   The SMP/E Post-Processing ISPF application\n\nYou would use the SMPEPP rexx exec to process the SMP/E output of an\nAPPLY-Check.  This application makes it easier to view hold data for an\nAPPLY before you run an APPLY with BYPASS.\n\nContents:\n\n- REXX exec:\n  - SMPEPP.....This REXX exec\n  - SMPEPPB....Batch processing version\n\n- ISPF Panels:\n  - SMPEPPS....options settings\n  - SMPEPPST...tutorial for SMPEPPS\n  - SMPEPPW....Work in progress\n  - SMPEPPT....Table display of PTFs found\n  - SMPEPPTT...tutorial for SMPEPPT\n\nTo use, invoke with SMPEPP as either a normal REXX exec or as an\nedit macro for the current edit dataset.  The SMPEPP exec can be used\nin SDSF when the job is selected with the \"SE\" line command.\n\n Disclaimer: This package is FREEWARE.  Use at your own risk.  It\n             is provided for your enjoyment and neither David\n             Alcock or his employer provides any warranty for it's\n             use.  I'd like to hear how it works on your system.\n\n             This software is not in the public domain but is\n             available free of charge and with source code\n             provided.  It is copyright 1996-2002+ by David Alcock\n             All rights reserved.\n./ ADD NAME=SMPEPP   1200-98062-98062-2029-00717-00717-00000-DAVEA\n/* REXX\n |\n | Name: SMPEPP ... SMP/E Post-Processor\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Process a SMP/E SMPOUT listing to aid in maintenance\n |          investigation. The GIM42001W messages are processed and the\n |          SMPPTS ++HOLD text is displayed. This allows the programmer\n |          to easily see all of the hold information for faster\n |          SMP/E PTF resolution.\n |\n | Note: This exec can work as a regular EXEC or an ISPF edit macro.\n |       If invoked in ISPF EDIF mode as an edit macro (such as in\n |       SDSF when the job is selected with a \"SE\"), this exec will\n |       process the lines from the current edit session.\n |\n |\n | This application consists of:\n |\n | - REXX exec:\n |   - SMPEPP.....This REXX exec\n |   - SMPEPPB....Batch processing version\n | - Panels:\n |   - SMPEPPS....options settings\n |   - SMPEPPST...tutorial for SMPEPPS\n |   - SMPEPPW....Work in progress\n |   - SMPEPPT....Table display of PTFs found\n |   - SMPEPPTT...tutorial for SMPEPPT\n |\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1996-2002+ by David Alcock\n |             All rights reserved.\n */\n\nspp@ver = \"v1.2\"\n\n/* ================================================================= *\n |\n |           M o d i f i c a t i o n   H i s t o r y\n |\n | Person     Date        Description\n | ---------- ----------- --------------------------------------------\n | DGAlcock   03-MAR-1998 v1.2:\n |                        - Added processing of message GIM35966I\n |                          which is needed at OS/390 2.4 SMP/E and\n |                          higher (thanks to Mike Theys for sending\n |                          this to me!);\n |                        - Added version number to panels;\n |                        - Variable for SMFID on working panel was\n |                          not being created by the exec;\n |                        - Added capture of SMP level;\n |                        - Corrected bug where last line was NOT\n |                          being processed;\n | DGAlcock   11-OCT-1996 Added batch submission; Added SMPCNTL\n |                        statement creation;  Added edit macro\n |                        invocation;\n | DGAlcock   30-SEP-1995 Initial exec written;\n * ================================================================= */\n\n\n   /* !!! The following statements are installation dependent !!! */\n\nparse source a b c d sppxlib .  /* Obtain execution lib name */\nif sppxlib == \"?\" then sppxlib = \"ibmuser.EXEC\"      /* Installation */\n\ntemp_dsn_prefix = sysvar(sysuid)\".SPFTEMP1.SMPEPP\"   /* Installation */\nsmpe_proclib    = \"SYS2.SYS.MVS.PROCLIB\"             /* Installation */\n\n/*********************************************************************\n* Figure out how we were invoked\n*********************************************************************/\n\nif address() <> \"TSO\" then do\n   say \"%SMPEPP - must be executed under TSO\"\n   exit 12\n   end\n\nif sysvar(\"SYSISPF\") <> \"ACTIVE\" then do\n   arg options\n   address TSO \"%SMPEPPB \"options\n   exit 0\n   end\n\n\ndsntype = \"n\"   /* Normal */\naddress ISREDIT \"MACRO (PARMS) NOPROCESS\"\nif rc <> 0 then do\n   ispfmode = \"notem\"\n   arg dsn\n   if dsn <> \"\" then ovdsn = dsn\n   else ovdsn = \"\"\n   end\nelse do\n     ispfmode = \"em\"\n     address ISREDIT \"(OVDSN) = DATASET\"\n     address ISREDIT \"(MEMBER) = MEMBER\"\n     if member <> '' then ovdsn = \"'\"ovdsn||\"(\"||member||\")'\"\n     else ovdsn = \"'\"ovdsn\"'\"\n     if ovdsn == \"''\" then do\n        ovdsn = \"<Current Edit (EDIF)>\"\n        dsntype = \"e\"   /* ABE-Normal: EDIF */\n        end\n     end\n\n/*********************************************************************\n | Get SMFID (shown on \"work in progress\" screen\n ********************************************************************/\n\nif sysvar(systsoe) > \"2040\" then ,             /* At v2.5 or higher? */\n   SPP@SMF = mvsvar(syssmfid)                  /* Yes, use IBM func  */\nelse do\n     cvt    = storage(10,4)\n     dcvt   = c2d(cvt)\n     smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n     dsmca  = c2d(smca)\n     SPP@SMF = storage(c2x(d2c(dsmca+x2d(10))),4)\n     end\naddress ispexec \"vput (SPP@SMF) shared\"\n\n/*********************************************************************\n* Display options panel\n*********************************************************************/\n\naddress ISPEXEC\n\"VGET (SPPNUM SPPDSN SPPPTS SPPFILE SPPMODE\" ,\n      \"SPPJCL1 SPPJCL2 SPPJCL3 SPPJCL4) PROFILE\"\n\nif sppdsn  == \"\" then sppdsn = \"Your.SDSF.output(JOBNAME)\"\nif spppts  == \"\" then spppts = \"'SMPEPP.SMPPTS'\"\nif sppnum  == \"\" then sppnum = \"9999\"\n\nselect\n when sppfile == \"DELETE\" then nop\n when sppfile == \"KEEP\"   then nop\n otherwise\n      sppfile = \"DELETE\"\nend /* of \"select\" */\n\nselect\n when sppmode == \"F\" then nop\n when sppmode == \"B\" then nop\n otherwise\n      sppmode = \"F\"     /* set to default type: F=Foreground */\nend /* of \"select\" */\n\nif dsntype = \"n\" then ,\n   if substr(sppdsn,1,1) == \"<\" then ,\n      sppdsn = \"YOUR.SDSF.OUTPUT(JOBNAME)\"\n\nif sppjcl1 == \"\" then sppjcl1 = \"//\"sysvar(sysuid)\"S JOB (acct)\"\n\nif ovdsn <> \"\" then sppdsn = ovdsn /* Get override datasetname */\n\nsppcur = \"sppdsn\"\ndrc = 1\ndo while drc <> 0\n\n   \"DISPLAY PANEL(SMPEPPS) CURSOR(\"sppcur\")\"\n   drc = rc\n\n   if drc == 8 then do\n      zedsmsg = \"Cancelled\"\n      zedlmsg = \"Processing of SMPOUT dataset cancelled, have a nice day\"\n      \"SETMSG MSG(ISRZ001)\"\n      exit\n      end\n\n     y = LISTDSI(spppts)\n     if y <> 0 then do\n        zedsmsg = \"SMPPTS Error\"\n        zedlmsg = \"Error with DSN: \"spppts \"-\" y\n        \"SETMSG MSG(ISRZ001)\"\n        sppcur = \"SPPPTS\"\n        drc = 1\n        end\n     else do\n          if dsntype == \"n\" then do\n             x = LISTDSI(sppdsn)\n             if x <> 0 then do\n                zedsmsg = \"SMPOUT Error\"\n                zedlmsg = \"Error with DSN: \"sppdsn \"-\" y\n                \"SETMSG MSG(ISRZ001)\"\n                sppcur = \"SPPDSN\"\n                drc = 1\n                end\n             end\n          end\n     /* Note: we fall thru with this last LISTDSI used in next section */\n\n   end /* of \"do while drc = 0\" */\n\nsppmode = translate(sppmode)\n\"VPUT (SPPNUM SPPDSN SPPPTS SPPFILE SPPMODE\" ,\n      \"SPPJCL1 SPPJCL2 SPPJCL3 SPPJCL4) PROFILE\"\n\n/*********************************************************************\n* If we are an Edit Macro and have a EDIF dataset, then we need to\n* handle it\n*********************************************************************/\nif dsntype = \"e\" then do\n\n   address ISREDIT\n   'PROCESS RANGE S'\n   select\n     when rc = 0 then do\n          '(CMD) = RANGE_CMD'          /* Get the command    */\n          '(LINE1) = LINENUM .ZFRANGE' /* Get first in range */\n          '(LINE2) = LINENUM .ZLRANGE' /* Get last in range  */\n          end\n     when rc <= 4 then do /* No S or SS entered, use entire file     */\n          '(CMD) = RANGE_CMD'          /* Get the command    */\n          '(LINE1) = LINENUM .ZFIRST'  /* Get first in range */\n          '(LINE2) = LINENUM .ZLAST'   /* Get last in range  */\n          if (line2 - line1) > sppnum then line2 = line2 - sppnum\n          end\n     otherwise  /* Line command conflict - Edit will create message  */\n          exit 12\n   end /* of \"select\" */\n\n\n   if sppmode == \"B\" then do\n      function = \"Copying SMPOUT from your Edit session\"\n      address ISPEXEC \"CONTROL DISPLAY LOCK\"\n      address ISPEXEC \"DISPLAY PANEL(SMPEPPW)\"\n      smpout_bdd  = \"SPP\"random()\n      smpout_bdsn = \"'\"temp_dsn_prefix\".SMPOUT.OFEDIF'\"\n      address TSO\n      x = outtrap(\"XMSG.\",\"*\")\n      \"DELETE \"smpout_bdsn\n      x = outtrap(\"off\")\n      \"ALLOCATE FILE(\"smpout_bdd\") DA(\"smpout_bdsn\")\",\n      \"UNIT(SYSDA) NEW REUSE SPACE(15 15) TRACKS\",\n      \"LRECL(255) BLKSIZE(2550) RECFM(F B)\"\n      newstack\n\n      address ISREDIT\n      do i = line2 to line1 by -1\n         '(LINEVAL) = LINE' i\n         push lineval\n         end\n      queue '' /* indicate end of file */\n      address TSO \"EXECIO * DISKW \"smpout_bdd\" (FINIS\"\n      address TSO \"delstack\"\n      address TSO \"FREE FILE(\"smpout_bdd\")\"\n      sppdsn = smpout_bdsn\n      end\n\n   end\n/***********************************************************************\n* Create job to run the job in the background\n***********************************************************************/\n\nif sppmode == \"B\" then do\n   function = \"Creating job\"\n   address ISPEXEC \"CONTROL DISPLAY LOCK\"\n   address ISPEXEC \"DISPLAY PANEL(SMPEPPW)\"\n   /*\n   *** Create library for batch job JCL and insert job\n   */\n   address TSO\n   sppcdd  = \"SPP\"random()\n   sppclib = temp_dsn_prefix\".JOB\"\n   x = outtrap(\"XMSG.\",\"*\")\n   \"DELETE '\"sppclib\"'\"\n   x = outtrap(\"off\")\n   \"ALLOCATE FILE(\"sppcdd\") DA('\"sppclib\"')\",\n               \"UNIT(SYSDA) NEW REUSE SPACE(5 5) TRACKS\",\n               \"LRECL(80) BLKSIZE(8800) RECFM(F B)\"\n\n   \"newstack\"\n\n   push \"//SMPCNTL  DD SYSOUT=*\"\n   push \"/*\"\n   push \"         \" spppts\n   push \" %SMPEPPB\" sppdsn \"+\"\n   push \"//SYSTSIN  DD *\"\n   push \"//SYSTSPRT DD SYSOUT=*\"\n   push \"//SYSEXEC  DD DISP=SHR,DSN=\"sppxlib\n   push \"//JUSTDOIT EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100\"\n   push \"//*\"\n   push \"//** at\" time()\". It prints the hold data found for PTFs.\"\n   push \"//** This job created by the SMPEPP application on\" date()\n   push \"//*\"\n   if sppjcl4 <> \"\" then push sppjcl4\n   if sppjcl3 <> \"\" then push sppjcl3\n   if sppjcl2 <> \"\" then push sppjcl2\n   if sppjcl1 <> \"\" then push sppjcl1\n\n   queue ''      /* add null line to indicate End-Of-File */\n   \"EXECIO * DISKW \"sppcdd\" (FINIS\"\n   \"DELSTACK\"\n\n   address ISPEXEC\n   zedsmsg = \"\"\n   zedlmsg = \"Verify this job and submit it or END to cancel\"\n   \"SETMSG MSG(ISRZ001)\"\n\n   \"EDIT DATASET('\"sppclib\"')\"\n\n   x = outtrap(\"XMSG.\",\"*\")\n   address TSO \"DELETE '\"sppclib\"'\"\n   x = outtrap(\"off\")\n\n   exit /* Terminate utility */\n   end\n\n/***********************************************************************\n* Read the input dataset into storage and create ISPF table\n***********************************************************************/\n\nfunction = \"Reading SMPOUT\"\naddress ISPEXEC \"CONTROL DISPLAY LOCK\"        /* Lock the next screen */\naddress ISPEXEC \"DISPLAY PANEL(SMPEPPW)\"      /* LOGO (in Progress)   */\n\nif dsntype = \"e\" then do\n   address ISREDIT\n   do i = line1 to line2\n      '(LINEVAL) = LINE' i\n      sppfile.i = lineval\n      end\n   sppfile.0 = (line2 - line1) + 1\n   end\nelse do\n     smpout_dsn = sysdsname\n     parse value sppdsn with . \"(\" member \")\" .\n     if member <> \"\" then do\n        smpout_dsn = smpout_dsn\"(\"strip(member)\")\"\n        end\n\n     smpout_ddname = \"SPP\"random()\n\n     address TSO\n     \"ALLOCATE FILE(\"smpout_ddname\") DA('\"smpout_dsn\"') SHR REUSE\"\n     \"EXECIO \"sppnum\" DISKR \"smpout_ddname\" (FINIS STEM sppfile.\"\n     end\n\ntable = \"SPP\"random()\naddress ISPEXEC \"TBCREATE \"table ,\n        \"NOWRITE NAMES(TYPES LAST) KEYS(MEMBER)\"\n\n/*********************************************************************\n* Process the SMPOUT file and add entries into the table\n*********************************************************************/\n\nfunction = \"Processing SMPOUT\"\naddress ISPEXEC \"CONTROL DISPLAY LOCK\"     /* Lock the next screen */\naddress ISPEXEC \"DISPLAY PANEL(SMPEPPW)\"   /* LOGO (in Progress) */\n\ngim42001w_count = 0 /* Number of GIM42001W messages processed */\nspprc = \"Not Found\"\ngimlvl = \"n/a\"\ntypes = \"\"\nmember = \"\"\nlast = \"\"\nsmpcntl.0 = 0\ncsiname = \"SMPE.GLOBAL.CSI\"   /* Default to a name */\n\ndo i = 1 to sppfile.0\n   select\n     when word(sppfile.i,1) == \"GIM20502I\" then do\n          parse value sppfile.i with . \"RETURN CODE WAS\" spprc \".\" .\n          parse value sppfile.i with . \"LEVEL\" vv \".\" rr \".\" .\n          gimlvl = vv\".\"rr\n          leave\n          end\n\n     when word(sppfile.i,1) == \"GIM42001W\" then do\n          gim42001w_count = gim42001w_count + 1\n\n          if member <> \"\" then do\n             types = strip(types)\n             address ISPEXEC \"TBADD \"table\n             types = \"\"\n\n             c = smpcntl.0\n             c = c + 1\n             smpcntl.0 = c\n             smpcntl.c = member\n             end\n\n          parse value sppfile.i with . \"SYSMOD\" member .\n          member = strip(member)\n          end\n\n     when word(sppfile.i,1) == \"GIM35935I\" then do\n          parse value sppfile.i with . \"HOLD\" type \"WAS\" .\n          types = types\" \"left(type,8)\n          end\n\n     when word(sppfile.i,1) == \"GIM35966I\" then do /* OS/390 v2r4 */\n         parse value sppfile.i with . \"HOLD\" type \"ORIGINATED\" .\n         types = types\" \"left(type,8)\n         end\n\n     when word(sppfile.i,1) == \"SMPCSI\" then do\n          if word(sppfile.i,2) == \"PERM\" then ,\n             csiname = word(sppfile.i,3)\n          end\n     otherwise\n          nop\n     end /* of \"select\" */\n\n   end /* of \"do i = 1 to sppfile.0\" */\n\nif member <> \"\" then do\n   types = strip(types)\n   address ISPEXEC \"TBADD \"table\n   c = smpcntl.0\n   c = c + 1\n   smpcntl.0 = c\n   smpcntl.c = member\n   end\n\nif gim42001w_count == 0 then do\n   zedsmsg = \"No Action Items\"\n   zedlmsg = \"No GIM42001W messages in '\"smpout_dsn\"' - SMP RC:\"spprc\n   if length(zedlmsg) > 78 then zedlmsg = substr(zedlmsg,1,78)\n   address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   address ISPEXEC \"TBCLOSE \"table\" \"\n   exit\n   end\n\nif spprc == \"Not Found\" then do\n   zedsmsg = \"\"\n   zedlmsg = \"Warning: The SMPOUT processing number\" ,\n             \"may be too low: \"sppnum\n   address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   end\n else do\n      zedsmsg = \"SMP RC=\"spprc\n      zedlmsg = \"Processing of SMPOUT was successful\"\n      address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      end\n\n/*********************************************************************\n*  Process the table for commands\n*********************************************************************/\nProcess_Table:\n\nsmppts_dsn = strip(spppts,\"B\",\"'\")\n\naddress ISPEXEC\n\"vput (GIMLVL SPP@VER) shared\"\n\"TBTOP \"table\nTSEL = \"\"\nNRC = 0\ndo while NRC == 0\n   \"TBDISPL \"table\" PANEL(SMPEPPT)\"\n   NRC = rc\n   if NRC == 0 then do\n\n      verb = \"\"\n      if zcmd <> '' then do\n         parse value zcmd with verb \" \" action\n         zcmd = ''\n         select\n           when translate(verb) == 'SMPCNTL' then call generate_smpcntl\n           when translate(verb) == 'KEEP'    then do\n                if sppfile == \"KEEP\" then do\n                   zedsmsg = \"Already Keep\"\n                   zedlmsg = \"The file disposition is already keep\"\n                   \"SETMSG MSG(ISRZ001)\"\n                   end\n                else do\n                     sppfile = \"KEEP\"\n                     zedsmsg = \"Set to KEEP\"\n                     zedlmsg = \"All new datasets created will be \" ,\n                               \"not deleted. (This session only)\"\n                     \"SETMSG MSG(ISRZ001)\"\n                     end\n                end /* of \"when translate(verb) == 'KEEP'\" */\n           when translate(verb) == 'DELETE'  then do\n                if sppfile == \"DELETE\" then do\n                   zedsmsg = \"Already DELETE\"\n                   zedlmsg = \"The file disposition is already DELETE\"\n                   \"SETMSG MSG(ISRZ001)\"\n                   end\n                else do\n                     sppfile = \"DELETE\"\n                     zedsmsg = \"Set to DELETE\"\n                     zedlmsg = \"All new datasets created will be\",\n                               \"deleted. (This session only)\"\n                     \"SETMSG MSG(ISRZ001)\"\n                     end\n                end /* of \"when translate(verb) == 'KEEP'\" */\n           otherwise\n             ZEDSMSG = \"Unknown verb\"\n             ZEDLMSG = \"Use: SMPCNTL\"\n             \"SETMSG MSG(ISRZ001)\"\n         end /* of \"select\" */\n\n         end /* of \"if zcmd <> ''\" */\n\n      tsel = translate(tsel)\n      select\n        /**************************************************************\n        *  Handle situations where we did a zcmd thing\n        **************************************************************/\n        when verb <> \"\" then NOP\n        /**************************************************************\n        * The user just hit the enter key and nothing else...\n        **************************************************************/\n        when tsel == \"\" then NOP\n        /**************************************************************\n        *  Select the dataset and show only the HOLD stuff\n        **************************************************************/\n        when TSEL == 'S' then do\n             dsn = smppts_dsn\"(\"member\")\"\n             last = \"Show ++ HOLD\"\n             call Process_Dataset\n             address ISPEXEC\n             \"TBMOD \"table\n             end\n        /**************************************************************\n        * Browse the dataset\n        **************************************************************/\n        when TSEL == 'B' then do\n             dsn = smppts_dsn\"(\"member\")\"\n             call Browse_Dataset\n             last = \"Browsed\"\n             address ISPEXEC\n             \"TBMOD \"table\n             end\n        when TSEL == '/' then do\n             dsn = smppts_dsn\"(\"member\")\"\n             call Browse_Dataset\n             last = \"Browsed\"\n             address ISPEXEC\n             \"TBMOD \"table\n             end\n        /**************************************************************\n        * specifed an incorrect option\n        **************************************************************/\n        when TSEL == '' then nop\n        /**************************************************************\n        * specifed an incorrect option\n        **************************************************************/\n        otherwise\n         zedsmsg = \"Not Processed\"\n         zedlmsg = \"Table selection item \"TSEL\" not supported\"\n         \"SETMSG MSG(ISRZ001)\"\n         end\n      /****************************************************************\n      * End of command processing\n      ****************************************************************/\n      tsel = \"\"\n      end\n   end\n\"TBCLOSE \"table\" \"\nreturn\n/*********************************************************************\n* Generate SMPCNTL statements to an output file\n**********************************************************************/\ngenerate_smpcntl:\n\nif smpcntl.0 == 0 then do\n   zedsmsg = \"No members\"\n   zedlmsg = \"SMP control statments not created\"\n   address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   return\n   end\n\nfunction = \"Generating SMPCNTL statements\"\n\"CONTROL DISPLAY LOCK\"\n\"DISPLAY PANEL(SMPEPPW)\"\n\naddress TSO\nsppcdd  = \"SPP\"random()\nsppclib = temp_dsn_prefix\".SMPCNTL\"\nx = outtrap(\"XMSG.\",\"*\")\n\"DELETE '\"sppclib\"'\"\nx = outtrap(\"off\")\n\"ALLOCATE FILE(\"sppcdd\") DA('\"sppclib\"')\",\n            \"UNIT(SYSDA) NEW REUSE SPACE(15 15) TRACKS\",\n            \"LRECL(80) BLKSIZE(8800) RECFM(F B)\"\n\n\"newstack\"\npush \"            ) HOLDDATA HOLDSYSTEM .\"\n\ndo c = smpcntl.0 to 1 by -1\n   push \"              \"smpcntl.c\n   end\n\npush \" LIST SYSMOD(\"\npush \" SET BDY(GLOBAL).\"\npush \"//SMPCNTL  DD *\"\npush \"//SMPLOG   DD DUMMY\"\npush \"//SMPLOGA  DD DUMMY\"\npush \"//LISTZONE EXEC SMPE,CSI='\"csiname\"'\"\npush \"//*\"\npush \"//** at\" time()\". It list SMP/E hold data.\"\npush \"//** This job created by the SMPEPP application on\" date()\npush \"//*\"\npush \"//PROCLIB JCLLIB ORDER=(\"smpe_proclib\")\"\nif sppjcl4 <> \"\" then push sppjcl4\nif sppjcl3 <> \"\" then push sppjcl3\nif sppjcl2 <> \"\" then push sppjcl2\nif sppjcl1 <> \"\" then push sppjcl1\n\nqueue ''      /* add null line to indicate End-Of-File */\n\"EXECIO * DISKW \"sppcdd\" (FINIS\"\n\"DELSTACK\"\n\naddress ISPEXEC \"EDIT DATASET('\"sppclib\"')\"\n\nif sppfile == \"DELETE\" then do\n   x = outtrap(\"XMSG.\",\"*\")\n   address TSO \"DELETE '\"sppclib\"'\"\n   x = outtrap(\"off\")\n   end\n\naddress ISPEXEC\nreturn\n/*********************************************************************\n* Browse the dataset with error recovery\n**********************************************************************/\nBrowse_Dataset:\n\"CONTROL ERRORS RETURN\"\n\"CONTROL DISPLAY SAVE\"\n\"BROWSE DATASET('\"dsn\"')\"\nBDRC = rc\nif BDRC <> 0 then do\n   zedsmsg = SYSDSN(dsn)\n   zedlmsg = \"Browse to dataset failed, DSN=\"dsn\n   \"SETMSG MSG(ISRZ001)\"\n   end\n\"CONTROL DISPLAY RESTORE\"\n\"CONTROL ERRORS CANCEL\"\nreturn\n/**********************************************************************\n* Process the dataset for ++ HOLD stuff\n**********************************************************************/\nProcess_Dataset:\n\"CONTROL DISPLAY SAVE\"\n\ntdsn = \"'\"dsn\"'\"\nx = LISTDSI(tdsn)\nif x <> 0 then do\n   zedsmsg = x\n   zedlmsg = \"Error with DSN: \"tdsn\n   \"SETMSG MSG(ISRZ001)\"\n   last = \"Failed ++ HOLD\"\n   \"CONTROL DISPLAY RESTORE\"\n   return\n   end\n\nidd = \"SPPI\"random()\naddress TSO \"ALLOCATE FILE(\"idd\") DA('\"dsn\"') SHR REUSE\"\naddress TSO \"EXECIO * DISKR \"idd\" (FINIS STEM idd.\"\n\npline.0 = 0\nsaving = 0\ndo i = 1 to idd.0\n   if substr(idd.i,1,2) == \"++\" then do\n      saving = 0\n      if substr(idd.i,3,4) == \"HOLD\" then saving = 1\n      if substr(word(idd.i,2),1,4) == \"HOLD\" then saving = 1\n      end\n    if saving then do\n       pline.0 = pline.0 + 1\n       j = pline.0\n       pline.j = idd.i\n       end\n   end\n\nif pline.0 == 0 then do\n   zedsmsg = \"No ++HOLD elements\"\n   zedlmsg = \"No ++HOLD elements in '\"dsn\"'\"\n   address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   address ISPEXEC \"CONTROL DISPLAY RESTORE\"\n   call Browse_Dataset\n   last = \"Browsed\"\n   return\n   end\n\n/* If we need to worry about invoking this application on more */\n/* than one screen and keeping the dataset, then do the VGET below */\n/* and then append it on the pdsn */\n/* address ISPEXEC \"VGET (ZSCREEN)\" */\npdsn = temp_dsn_prefix\".\"member\n\nx = outtrap(\"XMSG.\",\"*\")\naddress TSO \"DELETE \"pdsn\nx = outtrap(\"off\")\npdd = \"SPPP\"random()\naddress TSO \"ALLOCATE FILE(\"pdd\") DA(\"pdsn\")\",\n            \"UNIT(SYSDA) NEW REUSE SPACE(5 5) TRACKS\",\n            \"LRECL(80) BLKSIZE(6320) RECFM(F B)\"\n\naddress TSO \"NEWSTACK\"\ndo i = pline.0 to 1 by -1\n   push pline.i\n   end\nqueue ''      /* add null line to indicate End-Of-File */\naddress TSO \"EXECIO * DISKW \"pdd\" (FINIS\"\naddress TSO \"DELSTACK\"\n\naddress ISPEXEC \"BROWSE DATASET(\"pdsn\")\"\n\nif sppfile == \"DELETE\" then do\n   x = outtrap(\"XMSG.\",\"*\")\n   address TSO \"DELETE \"pdsn\n   x = outtrap(\"off\")\n   end\n\naddress ISPEXEC \"CONTROL DISPLAY RESTORE\"\nreturn\n\n/* | ---------EEEEEEEE---------NN-----NN---------DDDDDDD--------- |\n   | ---------EE---------------NNNN---NN---------DD----DD-------- |\n   | ---------EEEEE------------NN-NN--NN---------DD----DD-------- |\n   | ---------EE---------------NN---NNNN---------DD----DD-------- |\n   | ---------EEEEEEEE---------NN----NNN---------DDDDDDD--------- | */\n./ ADD NAME=SMPEPPB  1200-98062-98062-2029-00253-00253-00000-DAVEA\n/* REXX\n |\n | Name: SMPEPPB\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Process a SMP/E SMPOUT listing to aid in maintenance\n |          investigation. The GIM42001W messages are processed and the\n |          SMPPTS ++HOLD text is displayed. This allows the programmer\n |          to easily see all of the hold information for faster\n |          SMP/E PTF resolution.\n |\n |          This exec is meant to run in batch.  Use the SMPEPP\n |          REXX exec for online processing of SMP/E output.\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1996-2002+ by David Alcock\n |             All rights reserved.\n */\n\nspp@ver = \"v1.2\"\n\n/* ================================================================= *\n |\n |           M o d i f i c a t i o n   H i s t o r y\n |\n | Person     Date        Description\n | ---------- ----------- --------------------------------------------\n | DGAlcock   03-MAR-1998 V1.2:\n |                        - Added processing of message GIM35966I\n |                          which is needed at OS/390 2.4 SMP/E and\n |                          higher (thanks to Mike Theys for sending\n |                          this to me!);\n |                        - Added version number to start message\n | DGAlcock   11-OCT-1996 Initial exec written;\n * ================================================================= */\n\narg sppdsn spppts\nsppnum = \"*\"  /* read the whole dataset in batch */\n\nsay \" \"\nsay \"%SMPEPPB - \"spp@ver\" FREEWARE! written by David Alcock\"\nsay \"%SMPEPPB - Execution started at \"time()\" on \"date()\nsay \" \"\nsay \"%SMPEPPB - Processing SMP/E output in DSN=\"sppdsn\nsay \"         - using SMPPTS DSN=\"spppts\n\nif sppdsn == \"\" then do\n   say \"%SMPEPPB - Missing dataset name to process\"\n   signal theend\n   end\n\nif spppts == \"\" then do\n   say \"%SMPEPPB - Missing SMPPTS name to process\"\n   signal theend\n   end\n\n/***********************************************************************\n* Read the input dataset into storage and create ISPF table\n***********************************************************************/\n\nsmpout_ddname = \"SYSUT1\"\nsmpout_dsn    = sppdsn\naddress TSO\n\"ALLOCATE FILE(\"smpout_ddname\") DA(\"smpout_dsn\") SHR REUSE\"\narc = rc\nif arc <> 0 then do\n   say \"%SMPEPPB - Error allocating dsn=\"smpout_dsn \"RC=\"arc\n   signal theend\n   exit\n   end\n\n\"EXECIO \"sppnum\" DISKR \"smpout_ddname\" (FINIS STEM sppfile.\"\nerc = rc\nif erc <> 0 then do\n   say \"%SMPEPPB - Error reading dsn=\"smpout_dsn \"RC=\"arc\n   signal theend\n   exit\n   end\n\n/*********************************************************************\n* Process the SMPOUT file and print SMPPTS ++HOLD information\n*********************************************************************/\n\ngim42001w_count = 0 /* Number of GIM42001W messages processed */\nspprc = \"Not Found\"\ntypes = \"\"\nmember = \"\"\nlast = \"\"\nsmpcntl.0 = 0\nsmppts_dsn = strip(spppts,\"B\",\"'\")\n\ndo i = 1 to sppfile.0\n   select\n     when word(sppfile.i,1) == \"GIM20502I\" then do\n          parse value sppfile.i with . \"RETURN CODE WAS\" spprc \".\" .\n          leave\n          end\n\n     when word(sppfile.i,1) == \"GIM42001W\" then do\n          gim42001w_count = gim42001w_count + 1\n\n          if member <> \"\" then do\n             types = strip(types)\n             dsn = smppts_dsn\"(\"member\")\"\n             call process_dataset dsn\n             end\n\n          parse value sppfile.i with . \"SYSMOD\" member .\n          member = strip(member)\n          end\n\n     when word(sppfile.i,1) == \"GIM35935I\" then do\n          parse value sppfile.i with . \"HOLD\" type \"WAS\" .\n          types = types\" \"left(type,8)\n          end\n\n     when word(sppfile.i,1) == \"GIM35966I\" then do /* OS/390 v24 */\n         parse value sppfile.i with . \"HOLD\" type \"ORIGINATED\" .\n         types = types\" \"left(type,8)\n         end\n     otherwise\n          nop\n          end /* of \"otherwise\" */\n\n   end /* of \"do i = 1 to sppfile.0\" */\n\nif member <> \"\" then do\n   types = strip(types)\n   dsn = smppts_dsn\"(\"member\")\"\n   call process_dataset dsn\n   end\n\nif gim42001w_count == 0 then do\n   say \"%SMPEPPB - No Action Items (GIM42001W messages) in \"\n       smpout_dsn\" - SMP RC:\"spprc\n   end\n\n/*********************************************************************\n* Put out the SMP control statements for those who want to list the\n* hold data the approved way\n*********************************************************************/\n\nif smpcntl.0 <> 0 then do\n\n   \"newstack\"\n   push \"            ) HOLDDATA HOLDSYSTEM .\"\n\n   do c = smpcntl.0 to 1 by -1\n      push \"              \"smpcntl.c\n      end\n\n   push \" LIST SYSMOD(\"\n   push \" SET BDY(GLOBAL).\"\n\n   queue ''      /* add null line to indicate End-Of-File */\n   \"EXECIO * DISKW SMPCNTL (FINIS\"\n   \"DELSTACK\"\n   end\n\n/*********************************************************************\n* All good things must come to an end\n*********************************************************************/\n\ntheend:\nsay \" \"\nsay \"%SMPEPPB - Execution terminating at \"time() \"on\" date()\nexit\n\n/**********************************************************************\n* Process the dataset for ++ HOLD stuff\n**********************************************************************/\nProcess_Dataset:\n\nc = smpcntl.0\nc = c + 1\nsmpcntl.0 = c\nsmpcntl.c = member\n\ntdsn = \"'\"dsn\"'\"\nx = LISTDSI(tdsn)\nif x <> 0 then do\n   say \"%SMPEPPB - Error reading SMPPTS member \"\n   say \"         > DSN: \"tdsn\n   return\n   end\n\nidd = \"SPPI\"random()\naddress TSO \"ALLOCATE FILE(\"idd\") DA('\"dsn\"') SHR REUSE\"\naddress TSO \"EXECIO * DISKR \"idd\" (FINIS STEM idd.\"\n\nsay \" \"\nsay \" \"\nsay \"%SMPEPPB - Elements in dsn='\"dsn\"':\"\nsay \" \"\nmod.0 = 0\nnone_found = 1\nsaving = 0\n\ndo j = 1 to idd.0\n   if substr(idd.j,1,2) == \"++\" then do\n      saving = 0\n\n      if substr(idd.j,3,4) == \"HOLD\" then saving = 1\n      if substr(idd.j,3,4) == \"HOLD\" then saving = 1\n      if substr(word(idd.j,2),1,4) == \"HOLD\" then saving = 1\n\n      modfound = 0\n      if substr(idd.j,3,3) == \"MOD\" then modfound = 1\n      if substr(idd.j,3,3) == \"MOD\" then modfound = 1\n      if substr(word(idd.j,2),1,3) == \"MOD\" then modfound = 1\n      if modfound then do\n         m = mod.0\n         m = m + 1\n         parse value idd.j with . \"(\" module \")\" .\n         mod.m = module\n         mod.0 = m\n         end\n\n      end\n    if saving then do\n       say \">\" idd.j\n       none_found = 0\n       end\n   end\n\nif none_found then ,\n   say \"%SMPEPPB - Error: No ++HOLD elements found in dsn='\"dsn\"'\"\n\nif mod.0 <> 0 then do\n   say \"%SMPEPPB - Modules found: in \"dsn\":\"\n   line = \"\"\n   say \" \"\n   do m = 1 to mod.0\n      line = line\" \"mod.m\n      if length(line) > 68 then do\n         say \">\" line\n         line = \"\"\n         end\n      end\n   if line <> \"\" then say \">\" line\n   end\n\nreturn\n\n/* | ---------EEEEEEEE---------NN-----NN---------DDDDDDD--------- |\n   | ---------EE---------------NNNN---NN---------DD----DD-------- |\n   | ---------EEEEE------------NN-NN--NN---------DD----DD-------- |\n   | ---------EE---------------NN---NNNN---------DD----DD-------- |\n   | ---------EEEEEEEE---------NN----NNN---------DDDDDDD--------- | */\n./ ADD NAME=SMPEPPS  1200-98062-98062-2029-00043-00043-00000-DAVEA\n)Attr Default(%+_)\n /********************************************************************/\n /* Name: SMPEPPS                                                    */\n /* Author: David Alcock                                             */\n /* Application: SMPEPP                                              */\n /* Purpose: Obtain dataset names to process and the SMP/E PTS name  */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n)body expand(!!)\n%!-! \u00acSMP/E SMPOUT Processing Options % !-!\n%Command ===>_ZCMD\n+\n~Before processing the SMP/E output, please verify the options below\n~and hit the#ENTER~key to continue or hit~the#END~key to cancel.\n+\n+SMPOUT %===>_sppdsn                                        +\n             \u00a2SMPOUT dataset to process\n+SMPPTS %===>_spppts                                        +\n             \u00a2SMPPTS to be used to get information about your hold data\n\n+Number %===>_sppnum  \u00a2Number of lines to process in the SMPOUT dataset\n+Files  %===>_sppfile+\u00a2KEEP or DELETE the files generated by this application\n+Mode   %===>_z+      \u00a2Process in +F\u00a2(foreground) or+B\u00a2(background)\n\n+JCL:\n%===>_sppjcl1\n%===>_sppjcl2\n%===>_sppjcl3\n%===>_sppjcl4\n)init\n  .HELP = SMPEPPST\n .ZVARS = '(SPPMODE)'\n)proc\n  VER (&SPPNUM,RANGE,1,999999)\n  VER (&SPPFILE,LIST,DELETE,KEEP)\n  VER (&SPPMODE,LIST,F,B)\n)end\n./ ADD NAME=SMPEPPST 1200-98062-98062-2029-00040-00040-00000-DAVEA\n)attr default(%\u00a6_)\n /********************************************************************/\n /* Name: SMPEPPST                                                   */\n /* Author: David Alcock                                             */\n /* Application: SMPEPP                                              */\n /* Purpose: Tutorial for SMPEPPS (selection menu)                   */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n)body expand(!!)\n%Tutorial !-! SMP/E SMPOUT Post-Processing !-! Tutorial\n%Command ===>_ZCMD                                                             \u00a6\n\u00a6\n\u00a6This ISPF dialog automates the verification of a SMP/E\u00a2APPLY CHECK\u00a6output run\n\u00a6by automating the perusal of\u00a2++ HOLD\u00a6elements from the SMPPTS dataset for PTFs\n\u00a6and APARs which would go on because of a BYPASS option.\n\u00a6\n\u00a6The selection panel allows you to specify the:\n\u00a6\n   #SMPOUT  ~The dataset that has the output from the SMP/E APPLY CHECK.\n            ~Usually you will use SDSF to place the output from the SMPOUT file\n            ~to a DISK dataset for use by this application.\n\u00a6\n   #Number  ~Number of lines to process.  This is used to limit the number of\n            ~lines initially read from the dataset for performance reasons. It\n            ~must be high enough to read all of the SMPOUT file.\n\u00a6\n   #SMPPTS  ~The dataset name of the SMPPTS to obtain the HOLD information from.\n\u00a6\n\u00a6This application does not automate all aspects of verification of SMP/E\n\u00a6maintenance, it only automates a portion of it.  This application has only\n\u00a6been tested with output from SMP/E \"GIMSMP LVL 18.03\".\n)init\n)proc\n)end\n./ ADD NAME=SMPEPPT  1200-98062-98062-2029-00032-00032-00000-DAVEA\n)Attr Default(%\u00a6_)\n /********************************************************************/\n /* Name: SMPEPPT                                                    */\n /* Author: David Alcock                                             */\n /* Application: SMPEPP                                              */\n /* Purpose: Table display of PTFs from the SMPOUT listing which     */\n /*          need some verification                                  */\n /********************************************************************/\n ! type(output) intens(low) caps(off) color(turq)\n \u00ac type(output) intens(high) caps(off) color(yellow)\n # type(output) intens(low) caps(off) color(green)\n \u00a2 type(output) intens(high) color(green)\n ` type(text) intens(high)  color(turq)\n ~ type(text) intens(low) color(green)\n { type(text) intens(low) color(red)\n)Body Expand(\\\\) Width(&ZSCREENW)\n%-\\-\\- SMPOUT action items %-\\-\\-\n%Command ===>_ZCMD                                 \\ \\%Scroll ===>_amt \u00a6\n%\n~S`Show only \"++ HOLD\" SMP/E elements                 {SMPEPP level: \u00acSPP@VER\n~B`Browse the complete member                         {SMP/E level:  \u00acGIMLVL\n\u00a6\n  \u00a6Member   Types                                              Last processing\n%- -------- -------------------------------------------------- -\\-\\\n)Model\n_Z\u00acMEMBER  #TYPES                                             !LAST         \\ \\\n)Init\n  .HELP = SMPEPPTT\n  .ZVARS = '(TSEL)'\n  &AMT = PAGE\n)Proc\n)End\n./ ADD NAME=SMPEPPTT 1200-98062-98062-2029-00036-00036-00000-DAVEA\n)attr default(%\u00a6_)\n /********************************************************************/\n /* Name: SMPEPPTT                                                   */\n /* Author: David Alcock                                             */\n /* Application: SMPEPP                                              */\n /* Purpose: Tutorial for SMPEPPT (table)                            */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n @ type(text) intens(low)  color(red)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n)body expand(!!)\n%Tutorial !-! SMP/E SMPOUT Post-Processing !-! Tutorial\n%Command ===>_ZCMD                                                             \u00a6\n\u00a6\n\u00a6This is a list of the PTFs that have hold conditions which you should\n\u00a6investigate before applying.  The options for the table rows are:\n\u00a6\n   #S       ~Select the PTF and browse ONLY the ++HOLD information from the\n            ~SMPPTS dataset.\n\u00a6\n   #B       ~Browse the member in SMPPTS for this PTF.\n\u00a6\n   @Sorry but multiple row selections are not supported yet\n\u00a6\n\u00a6The following commands are available from the command line:\n\u00a6\n   #SMPCNTL ~Generate a job that will invoke SMP/E in batch to list all of the\n            ~hold data for all of the PTFs in the list.\n)init\n)proc\n)end\n./ ADD NAME=SMPEPPW  1200-98062-98062-2029-00042-00042-00000-DAVEA\n)attr\n /********************************************************************/\n /* Name: SMPEPPW                                                    */\n /* Author: David Alcock                                             */\n /* Applicatoni: SMPEPP                                              */\n /* Purpose: Logo - in process - panel                               */\n /********************************************************************/\n # TYPE(TEXT)   INTENS(LOW)  COLOR(TURQ)\n \u00a6 TYPE(TEXT)   INTENS(HIGH) COLOR(GREEN)  HILITE(BLINK)\n \u00a2 TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n ( TYPE(TEXT)   INTENS(HIGH) COLOR(RED)\n ) TYPE(OUTPUT) INTENS(HIGH) COLOR(PINK) JUST(ASIS)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n)Body Expand(!!) Width(&ZSCREENW)\n\u00a6WW        WW  OOOOOOOOOOOO  RRRRRRRRRRR   KK        KK    `Time     -~&ZTIME\n\u00a6WW        WW  OOOOOOOOOOOO  RRRRRRRRRRRR  KK       KK     `Date     -~&ZDATE\n\u00a6WW        WW  OO        OO  RR        RR  KK      KK      `Julian   -~&ZJDATE\n\u00a6WW        WW  OO        OO  RR        RR  KK     KK       `System   -~&SPP@VER\n\u00a6WW        WW  OO        OO  RR        RR  KK    KK\n\u00a6WW        WW  OO        OO  RRRRRRRRRRRR  KKKKKKK       ------------\n\u00a6WW   WW   WW  OO        OO  RRRRRRRRRRR   KKKKKKK       ------------\n\u00a6WW  WWWW  WW  OO        OO  RR    RR      KK    KK\n\u00a6WW WW  WW WW  OO        OO  RR     RR     KK     KK\n\u00a6WWWW    WWWW  OO        OO  RR      RR    KK      KK\n\u00a6WWW      WWW  OOOOOOOOOOOO  RR       RR   KK       KK\n\u00a6WW        WW  OOOOOOOOOOOO  RR        RR  KK        KK\n                                       \u00a6IIIIIIIIII   NN        NN   GGGGGGGGGG\n                                      \u00a6IIIIIIIIII   NNN       NN  GGGGGGGGGGGG\n                                         \u00a6II       NNNN      NN  GG        GG\n(Please be patient, performing:         \u00a6II       NN NN     NN  GG\n)FUNCTION                              \u00a6II       NN  NN    NN  GG\n                                      \u00a6II       NN   NN   NN  GG\n                                     \u00a6II       NN    NN  NN  GG     GGGGG\n                                    \u00a6II       NN     NN NN  GG     GGGGG\n                                   \u00a6II       NN      NNNN  GG        GG\n                                  \u00a6II       NN       NNN  GG        GG\n                             \u00a6IIIIIIIIII   NN        NN  GGGGGGGGGGGG\n`SMP/E SMPOUT processing    \u00a6IIIIIIIIII   NN         N   GGGGGGGGGG\n)init\n)proc\n)end\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 19:50 ON 98/05/28\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPELLCHK": {"ttr": 28163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00H\\x00\\x99\\x06\\x0f\\x01\\x020o\\x186\\x01y\\x01r\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:36:48", "lines": 377, "newlines": 370, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 1000-97140-97140-1745-00011-00011-00000-DALCOCK\n\"Spell Check\" ISPF application v1.0\n\nRequirements: SAS\n\nTo install:\n\n1) Copy member SPELLCHK into your //SYSPROC or //SYSEXEC concatenation\n\n2) Copy the other SPELLCKS members into your //ISPPLIB concatenation\n\nInvoke in ISPF edit as primary command SPELLCHK\n./ ADD NAME=SPELLCHK 1000-97140-97140-1745-00332-00332-00000-DALCOCK\n/* REXX\n |\n | Name: SpellChk - ISPF Edit Macro\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Perform a Spell Check on the current dataset or selected\n |          lines using SAS. It puts the unrecognized and suggested\n |          words (if any) into the edit dataset as NOTE lines.\n |\n | Needs: ISPF panel \"SPELLCKS\"\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1997-2002+ by David Alcock\n |             All rights reserved.\n */\n\nseqid = random()\naddress ISREDIT\n'MACRO (PARM1) NOPROCESS'\nparm1 = translate(parm1)\nif parm1 = '?' then do\n   msg1 = \"The SPELLCHK edit macro can be use to perform a spell check\"\n   msg2 = \"on all or part of the dataset being edited (via S/SS on the\"\n   msg3 = \"line).  Saving the file first is suggested\"\n   address ISPEXEC\n   \"ADDPOP\"\n   \"DISPLAY PANEL(SPELLCKS)\"\n   \"REMPOP\"\n   exit\n   end\n\n/*********************************************************************\n* Process line commands, check if S or SS was specified\n*********************************************************************/\n\n'PROCESS RANGE S'\nselect\n  when rc = 0 then do\n       '(CMD) = RANGE_CMD'          /* Get the command    */\n       '(LINE1) = LINENUM .ZFRANGE' /* Get first in range */\n       '(LINE2) = LINENUM .ZLRANGE' /* Get last in range  */\n       typesel = \"slines\"\n       msg2 = time() \"Processing lines \"line1\" through \"line2\n       end\n  when rc <= 4 then do /* No S or SS entered, use entire file     */\n       '(CMD) = RANGE_CMD'          /* Get the command    */\n       '(LINE1) = LINENUM .ZFIRST'  /* Get first in range */\n       '(LINE2) = LINENUM .ZLAST'   /* Get last in range  */\n       typesel = \"file\"\n       msg2 = time() \"Processing the whole file\"\n       end\n  otherwise  /* Line command conflict - Edit will create message  */\n       exit 12\nend /* of \"select\" */\n\nmsg1 = time() \"Spelling checking started\"\nmsg3 = \" \"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(SPELLCKS)\"\n\"REMPOP\"\n\n/*********************************************************************\n* Copy the lines selected to a temporary dataset\n*\n* We use the maximum lrecl of ISPF edit of 255, we might need a larger\n* output space parameter by multiplying the number of lines selected\n* by the input record size and using a block allocation.\n*********************************************************************/\n\nif typesel == \"slines\" then do\n   spellin_dsn = \"spftemp1.spellchk.#\"seqid\"i\"\n   address TSO\n   x = outtrap(\"XMSG.\",\"*\")\n   \"DELETE \"spellin_dsn\n   x = outtrap(\"off\")\n   \"ALLOCATE FILE(spellin) DA(\"spellin_dsn\")\",\n   \"UNIT(SYSDA) NEW REUSE SPACE(15 15) TRACKS\",\n   \"LRECL(255) BLKSIZE(2550) RECFM(F B)\"\n   newstack\n\n   address ISREDIT\n   do i = line2 to line1 by -1\n      '(LINEVAL) = LINE' i\n      push lineval\n      end\n   queue '' /* indicate end of file */\n   address TSO \"EXECIO * DISKW spellin (FINIS\"\n   address TSO \"delstack\"\n\n   /* Note: the LMINIT/BROWSE/LMFREE here is just for debugging */\n   /*       to see which lines were selected         */\n   /*      address ISPEXEC                           */\n   /*      'LMINIT DATAID(BROWSE) DDNAME(SPELLIN)'   */\n   /*      'BROWSE DATAID('BROWSE')'                 */\n   /*      'LMFREE DATAID('BROWSE')'                 */\n\n   end\nelse do /* We are doing the whole thing */\n     address ISREDIT\n     \"(TDSN) = DATASET\"\n     \"(TMEM) = MEMBER\"\n     if member <> '' then spellin_dsn = tdsn||\"(\"||tmem||\")\"\n     else spellin_dsn = tdsn\n     address TSO \"ALLOC F(SPELLIN) DA('\"spellin_dsn\"') SHR REUSE\"\n     end\n\n/*********************************************************************\n* Create the output and log datasets\n*********************************************************************/\n\nmsg3 = time() \"Creating temporary I/O datasets\"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(SPELLCKS)\"\n\"REMPOP\"\n\nspellout_dsn = \"spftemp1.spellchk.#\"seqid\"o\"\naddress TSO\nx = outtrap(\"XMSG.\",\"*\")\n\"DELETE \"spellout_dsn\nx = outtrap(\"off\")\n\"ALLOCATE FILE(SPELLOUT) DA(\"spellout_dsn\")\",\n\"         UNIT(SYSDA) NEW REUSE SPACE(5 5) TRACKS\",\n\"         LRECL(255) BLKSIZE(2550) RECFM(F B)\"\n\nspelllog_dsn = \"spftemp1.spellchk.#\"seqid\"l\"\nx = outtrap(\"XMSG.\",\"*\")\n\"DELETE \"spelllog_dsn\nx = outtrap(\"off\")\n\"ALLOCATE FILE(SPELLlog) DA(\"spelllog_dsn\")\",\n\"         UNIT(SYSDA) NEW REUSE SPACE(5 5) TRACKS\",\n\"         LRECL(255) BLKSIZE(2550) RECFM(F B)\"\n\n/*********************************************************************\n* Create the SAS program datasets.  We create them instream to allow\n* (future) selection of user-defined SAS word files and to keep this\n* program self-contained.   The member name is randomly generated to\n* reduce the potential of a duplicated member with base SAS.\n*********************************************************************/\n\nmsg1 = msg2\nmsg2 = msg3\nmsg3 = time() \"Creating SAS program files\"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(SPELLCKS)\"\n\"REMPOP\"\n\nspellsas1_dsn = \"spftemp1.spellchk.#\"seqid\"s1\"\nspellsas2_dsn = \"spftemp1.spellchk.#\"seqid\"s2\"\n\naddress TSO\nx = outtrap(\"XMSG.\",\"*\")\n\"DELETE \"spellsas2_dsn\nx = outtrap(\"off\")\n\"ALLOCATE FILE(SPEL\"seqid\"2) DA(\"spellsas2_dsn\"(spel\"seqid\"))\",\n\"         UNIT(SYSDA) NEW REUSE SPACE(1 1) TRACKS DIR(1)\",\n\"         LRECL(80) BLKSIZE(8800) RECFM(F B)\"\n\nx = outtrap(\"XMSG.\",\"*\")\n\"DELETE \"spellsas1_dsn\nx = outtrap(\"off\")\n\"ALLOCATE FILE(SPEL\"seqid\"1) DA(\"spellsas1_dsn\")\",\n\"         UNIT(SYSDA) NEW REUSE SPACE(1 1) TRACKS\",\n\"         LRECL(80) BLKSIZE(8800) RECFM(F B)\"\n\nnewstack\npush \"%include sasautos(spel\"seqid\"); \"\npush \"options nosource nosource2 ;\"\nqueue '' /* indicate end of file */\naddress TSO \"EXECIO * DISKW SPEL\"seqid\"1 (FINIS\"\naddress TSO \"delstack\"\n\nnewstack\npush \"        RUN ;\"\npush \"                          SASHELP.BASE.CNTRIES) ;\"\npush \"                          SASHELP.BASE.CITIES\"\npush \"                          SASHELP.BASE.STATES\"\npush \"              DICTIONARY=(SASHELP.BASE.NAMES\"\npush \" PROC   SPELL IN=SPELLIN  VERIFY SUGGEST\"\nqueue '' /* indicate end of file */\naddress TSO \"EXECIO * DISKW SPEL\"seqid\"2 (FINIS\"\naddress TSO \"delstack\"\n\n/*********************************************************************\n* Invoke SAS to perform the Spell check\n*********************************************************************/\n\nmsg1 = msg2\nmsg2 = msg3\nmsg3 = time() \"Invoking SAS to perform Spell check\"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(SPELLCKS)\"\n\"REMPOP\"\n\naddress TSO\n\"%SAS INPUT('\"spellsas1_dsn\"')\" ,\n\"     SASAUTOS('\"spellsas2_dsn\"')\" ,\n\"     OPTIONS ('NOSOURCE NOSOURCE2 PRINT=SPELLOUT LOG=SPELLLOG')\"\nsasrc = rc\n\nif sasrc <> 0 then do\n   address ISPEXEC\n   zedsmsg = \"\"\n   zedlmsg = \"SAS Spell Check RC=\"sasrc ,\n             \"review this log and hit PF3\"\n   'SETMSG MSG(ISRZ001)'\n   'LMINIT DATAID(BROWSE) DDNAME(SPELLLOG)'\n   'BROWSE DATAID('BROWSE')'\n   'LMFREE DATAID('BROWSE')'\n   msg2 = msg3\n   msg3 = time() \"SAS Spell check RC=\"sasrc\n   signal cleanup\n   end\n\nmsg1 = msg2\nmsg2 = msg3\nmsg3 = time() \"SAS Spell check RC=\"sasrc\" processing output\"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(SPELLCKS)\"\n\"REMPOP\"\n\n/*********************************************************************\n* Process the SAS output from the Spell check and save words & sug.\n*********************************************************************/\n\naddress TSO\nspellco_dd = \"SPELC\"seqid\n\"ALLOCATE FILE(\"spellco_dd\") \" ,\n\"         DA(\"spellout_dsn\") SHR REUSE\"\n\"EXECIO * DISKR \"spellco_dd\" (FINIS STEM spellco.\"\n\"FREE FILE(\"spellco_dd\")\"\n\nw = 0                              /* Current word number */\nright_part = 0                     /* In the right part?  */\n\ndo i = 1 to spellco.0\n   if right_part then do\n      if word(spellco.i,1) == \"The\" then do /* heading line */\n         right_part = 0\n         iterate\n         end\n      if substr(spellco.i,4,1) <> \" \" then do\n         parse value spellco.i with mword freq lines\n         w = w + 1\n         wordline.w = translate(lines,\" \",\",\")\n         wordline.w = translate(wordline.w,\" \",\"(\")\n         wordline.w = translate(wordline.w,\" \",\")\")\n         wordval.w  = strip(mword)\n         wordsug.w = \"\"\n         iterate\n         end\n      if word(spellco.i,1) == \"Suggestions:\" then do\n         wordsug.w = strip(spellco.i)\n         iterate\n         end\n      if substr(spellco.i,23,1) <> \" \" then do\n         wordsug.w = wordsug.w || strip(spellco.i)\n         iterate\n         end\n      contlines = substr(spellco.i,45,1)\n      if contlines <> \" \" then do\n         if datatype(contlines,'N') then do /* looks like a number? */\n            wordline.w = wordline.w || strip(spellco.i)\n            wordline.w = translate(wordline.w,\" \",\",\")\n            wordline.w = translate(wordline.w,\" \",\"(\")\n            wordline.w = translate(wordline.w,\" \",\")\")\n            wordval.w  = strip(mword)\n            end\n         end\n      end\n   else do\n        if word(spellco.i,1) == \"Unrecognized\" then right_part = 1\n        end\n\n   end /* of \"do i = 1 to spellco.0\" */\n\n/*********************************************************************\n* Insert the words and suggestions into the EDIT session as note lines\n*********************************************************************/\n\naddress ISPEXEC\ndo i = 1 to w\n   do j = 1 to words(wordline.i)\n      k = line1 + word(wordline.i,j) - 1\n      /* Could try to intelligently split the suggestions here */\n      if wordsug.i <> \"\" then do\n         text = left(wordsug.i,65)\n         \"ISREDIT LINE_AFTER \"k\" = NOTELINE '\"text\"'\"\n         end\n      text = \"Unrecognized word: \"wordval.i\n      \"ISREDIT LINE_AFTER \"k\" = NOTELINE '\"text\"'\"\n      end\n   end\n\n/*********************************************************************\n* Clean up and leave\n*********************************************************************/\n\ncleanup:\nmsg1 = msg2\nmsg2 = msg3\nmsg3 = time() \"Cleaning up work datasets\"\naddress ISPEXEC\n\"CONTROL DISPLAY LOCK\"\n\"ADDPOP\"\n\"DISPLAY PANEL(SPELLCKS)\"\n\"REMPOP\"\n\nx = outtrap(\"XMSG.\",\"*\")\naddress TSO\nif typesel == \"slines\" then \"DELETE \"spellin_dsn\nelse \"FREE FILE(SPELLIN)\"\n\"DELETE \"spellout_dsn\n\"DELETE \"spelllog_dsn\n\"DELETE \"spellsas1_dsn\n\"DELETE \"spellsas2_dsn\nx = outtrap(\"off\")\n\nif sasrc == 0 then do\n   zedsmsg = w \"found\"\n   zedlmsg = \"There were \"w\" words that were unrecognized\"\n   address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   end\n\nexit\n./ ADD NAME=SPELLCKS 1000-97140-97140-1745-00021-00021-00000-DALCOCK\n)attr default(%+_)\n /********************************************************************/\n /* Name: SPELLCKS                                                   */\n /* Author: David Alcock                                             */\n /* Application: SPELLCHK                                            */\n /* Purpose: status of spelling check                                */\n /********************************************************************/\n # type(text) intens(high) color(yellow)\n \u00a2 type(text) intens(low)  color(green)\n \u00ac type(text) intens(low)  color(green) hilite(reverse)\n ` type(text) intens(high) color(yellow)\n ~ type(text) intens(low)  color(turq)\n { type(output) intens(high) color(yellow) caps(off)\n } type(output) intens(high) color(turq)   caps(off)\n)body window(65,3) expand(!!)\n+&MSG1\n+&MSG2\n+&MSG3\n)init\n)proc\n)end\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 14:40 ON 98/01/16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBME": {"ttr": 28170, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x020o\\x01\\x020o\\x16\"\\x00/\\x00/\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-02T00:00:00", "modifydate": "2002-11-02T16:22:37", "lines": 47, "newlines": 47, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: SUBME\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Edit macro that submits the current dataset/member to the\n |          Job Entry subsystem.  Use this when ISPF's submit fails\n |          due to ISPF work dataset space problem.\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1991-2002+ by David Alcock\n |             All rights reserved.\n */\naddress ISREDIT \"MACRO (PARMS) NOPROCESS\"\nif rc <> 0 then do\n   ZEDSMSG = \"Not an EDIT macro\"\n   ZEDLMSG = \"This command can only be issued as an ISPF EDIT macro\"\n   address ISPEXEC \"SETMSG MSG(ISRZ001)\"\n   exit 12\n   end\nparms = translate(parms)\naddress ISREDIT \"(THEDSN) = DATASET\"\naddress ISREDIT \"(MEMBER) = MEMBER\"\nif member <> '' then thedsn = thedsn||\"(\"||member||\")\"\n\naddress TSO \"SUBMIT '\"thedsn\"'\"\nsubrc = rc\nif subrc == 0 then do\n   SDate = Date()                    /* Get submit Date             */\n   if length(SDate) == 10 ,          /* Short Date: \"4 Jul 1990\"?   */\n      then SDate = \"0\"SDate          /* ..Yes make it \"04 Jul 1990\" */\n   SDate = Overlay('-',SDate,3)      /* Insert \"04-Jul 1990\"        */\n   SDate = Overlay('-',SDate,7)      /* Insert \"04-Jul-1990\"        */\n   say \"          at \"TIME() \"on\" SDate\n   say \"..from dsn='\"thedsn\"'\"\n   end\nelse do\n     say \"%SUBME - Submit failed, rc=\"subrc\" +\"\n     say \"       > dsn='\"thedsn\"'\"\n     end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSVAR": {"ttr": 28172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x00\"\\x00\\x99\\x06\\x0f\\x01\\x020o\\x187\\x00>\\x006\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:37:22", "lines": 62, "newlines": 54, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: SYSVAR\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Show all of the SYSVAR() variables\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1998-2002+ by David Alcock\n |             All rights reserved.\n */\naddress TSO \"CLRSCRN\"   /* Installation dependant */\nsay \"SYSVAR():\"\nsay \"  User:\"\nsay \"    syspref---\"sysvar(syspref)\nsay \"    sysproc---\"sysvar(sysproc)\nsay \"    sysuid----\"sysvar(sysuid)\nsay \"  Terminal:\"\nsay \"    syslterm--\"sysvar(syslterm)\nsay \"    syswterm--\"sysvar(syswterm)\nsay \"  Exec:\"\nsay \"    sysenv----\"sysvar(sysenv)\nsay \"    sysicmd---\"sysvar(sysicmd)\nsay \"    sysispf---\"sysvar(sysispf)\nsay \"    sysnest---\"sysvar(sysnest)\nsay \"    syspcmd---\"sysvar(syspcmd)\nsay \"    sysscmd---\"sysvar(sysscmd)\nsay \"  System:\"\nsay \"    syscpu----\"sysvar(syscpu)\nsay \"    syshsm----\"sysvar(syshsm)\nsay \"    syslracf--\"sysvar(syslracf)\nsay \"    sysracf---\"sysvar(sysracf)\nsay \"    syssrv----\"sysvar(syssrv)\nsay \"    systsoe---\"sysvar(systsoe)\nif sysvar(systsoe) > \"2040\" then do\n   say \"    sysjes----\"sysvar(sysjes)\n   say \"    sysnode---\"sysvar(sysnode)\n   say \"    systermid-\"sysvar(systermid)\n   end\nsay \"  Language:\"\nsay \"    sysdterm--\"sysvar(sysdterm)\nsay \"    syskterm--\"sysvar(syskterm)\nsay \"    sysplang--\"sysvar(sysplang)\nsay \"    sysslang--\"sysvar(sysslang)\nsay \" \"\n\nif sysvar(systsoe) > \"2040\" then do\n   say \"non-SYSVAR:\"\n   x = syscpus(cpus.)\n   if x == 0 then do\n      do i = 1 to cpus.0\n         say \"  syscpus.\"i\" ... \"cpus.i\n         end\n      end\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TOD": {"ttr": 28174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x14\\x03\\x00'\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18C\\x03\\x9f\\x03\\xa1\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:43:27", "lines": 927, "newlines": 929, "modlines": 0, "user": "IBMUSER"}, "text": "./ ADD NAME=$$README 1100-97081-97081-1322-00078-00078-00000-DALCOCK\nTime Of Day Package v1.1 - 22-MAR-1997\n\nThis package consists of an MPF exit and a started task that hopefully\nincreases productivity by reducing the effort needed to determine the\ndate when browsing a JES job log.\n\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\nThis package is OBSOLETE with OS/390 JES2 which has both functions!!!\n\nMPF exit\n--------\nThis MPF exit appends the date onto a WTO message.  When used on the\njob start and end messages, you can easily tell when a job ran by\nonly looking at the job log.\n\nNEWDAY started task\n-------------------\nThe NEWDAY started task should be started by your automated operations\nsystem right after midnight.  It sends a message containing the date\nto every started task's job log.\n\nSample:\n------\n                     J E S 2  J O B  L O G  --  S Y S T E M  C S W 1  --  N O D\n\n  06.46.59 STC02311 IEF695I START TCPIPT   WITH JOBNAME TCPIPT   IS ASSIGNED TO\n  06.46.59 STC02311 $HASP373 TCPIPT   STARTED\n  06.46.59 STC02311 ACF9CCCD USERID TCPIPT   IS ASSIGNED TO THIS JOB - TCPIPT\n  06.46.59 STC02311 XYZ190I Region limit set to 64 megabytes (above the line) fo\n> 06.46.59 STC02311 IEF403I TCPIPT - STARTED - TIME=06.46.59 - 13-Mar-1997 - 199\n  06.47.01 STC02311 EZY1876I TCPIP started with parameter TCPIP,ERRFILE(SYSERR),\n> 00.01.18 STC02311 MSG FROM OPER:  '----- DATE: 14-MAR-1997 - 1997.073 '\n  11.40.02 STC02311 EZB5948E Telnet server: Conn 1: StKillConn- TcpClose failed:\n\nNotice that IEF403I has the date and that right after midnight, the\ncurrent date was inserted into the job log.\n\nTo install:\n----------\n\nYou can install only the pieces you want, maybe only the MPF exit is\nall you really want.\n\n1) Assemble and link member MPFEXIT into your LNKLST as rent and reus.\n   For the example below, the name MPFEXTOD was used.\n\n2) Update your MPFLSTxx member with:\n\n           IEF403I,SUP(NO),USEREXIT(MPFEXTOD)\n           IEF404I,SUP(NO),USEREXIT(MPFEXTOD)\n\n3) Copy member NEWDAYP into a JES PROCLIB, I use member name NEWDAY.\n   Change the SYSEXEC library name to your REXX library.\n\n4) Copy member NEWDAYE into your REXX Library.  You will need to update\n   the REXX exec to issue command the way your installation allows them.\n   I have included my OSCMD assembler program if you don't have one.\n   You should put security in your OSCMD to prevent authorized use.\n\nNote: If you have Automate/MVS, the NEWDAY EXEC could be executed\nwithout needing a started task.  Other automated operations packages\nmay be able to execute REXX code also.\n\n =====================================================================\n\n The contents of this file are FREEWARE.  Use at your own risk.  It\n is provided for your enjoyment and neither David Alcock or his\n employer provides any warranty for their use.  I'd like to hear\n feedback on how they work on your system:\n\n    David Alcock :: dave@planetmvs.com\n\n =====================================================================\n./ ADD NAME=MPFEXIT  1100-97081-97081-1322-00278-00278-00000-DALCOCK\nMPFEXTOD TITLE '                     Append the date to some messages'\n***********************************************************************\n***                                                                 ***\n**                                                                   **\n**    Module Name       = MPFEXTOD                                   **\n**                                                                   **\n**    Author            = David Alcock                               **\n**                        dave@planetmvs.com                         **\n**                                                                   **\n**    Descriptive Name  = Append the current date to some messages.  **\n**                                                                   **\n**    Reference         = GC28-1147 MVS-XA SPL: User Exits           **\n**                                                                   **\n**    Attributes        = Reentrant, Reusable, Authorized            **\n**                                                                   **\n**    Activated by      = Specifed in active MPF member of Parmlib:  **\n**                        - SET MPF=XX                               **\n**                          where XX is a member in parmlib:         **\n**                          'SYS1.PARMLIB(MPFLSTXX)'                 **\n**                        - Reference in MPFLSTXX:                   **\n**                       IEF403I,SUP(NO),USEREXIT(MPFEXTOD)          **\n**                       IEF404I,SUP(NO),USEREXIT(MPFEXTOD)          **\n**                                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**                                                                   **\n**    Change:                                                        **\n**                                                                   **\n**      IEF403I JOBNAME1 - STARTED - TIME=16.38.17                   **\n**      IEF404I JOBNAME1 - ENDED - TIME=16.38.23                     **\n**                                                                   **\n**    To:                                                            **\n**                                                                   **\n**      IEF403I JOBNAME1 - STARTED - TIME=16.38.17 - 25-FEB-1997     **\n**      IEF404I JOBNAME1 - ENDED - TIME=16.38.23 - 25-FEB-1997       **\n**                                                                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n**                                                                   **\n**  If \"MONITOR JOBNAMES\" is not active, then we update these as     **\n**  well:                                                            **\n**                                                                   **\n**      $HASP373 JOBNAME2 STARTED - INIT    1 - CLASS U - SYS XYZ5   **\n**      $HASP395 JOBNAME2 ENDED                                      **\n**                                                                   **\n**  And update your MPFLSTxx with:                                   **\n**                                                                   **\n**                      $HASP373,SUP(NO),USEREXIT(MPFEXTOD)          **\n**                      $HASP395,SUP(NO),USEREXIT(MPFEXTOD)          **\n**                                                                   **\n**  I've noticed that the checks I do to only append either          **\n**  IEF40xI or $HASP3xx and not both only work on my test machine    **\n**  (where there is only one console).  In production, I only        **\n**  have the MPF exit on the IEF40xI messages and hope that          **\n**  \"MONITOR JOBNAMES\" is always active.                             **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         EJECT\n         IEZVX100 ,                       WTO exit parameter list\n         YREGS ,                          Equate registers to R0-R15\n*\n** Using the official ASMH/HLASM distinction trick, simulate the\n** SYSVER and SYSDATEC variables of HLASM when assembled under\n** ASMH...Taken from Gilbert Saint-flour's SHOWMVS.\n*\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n         AIF   ('&SYSDATC' LT '20500000').ASMH1X\n&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\n*-Convert assembly date from SYSDATC format \"YYYYMMDD\" to \"YYYY/MM/DD\"\n         LCLC  &ASMDATE\n&ASMDATE SETC  '&SYSDATC'(1,4).'/'.'&SYSDATC'(5,2).'/'.'&SYSDATC'(7,2)\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Intialization                                               **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMPFEXTOD CSECT ,\nMPFEXTOD AMODE 31\nMPFEXTOD RMODE ANY\n*\n** Create a standard O/S eyecatcher\n*\nEC       B     ECL(0,R15)               Bump past Eyecatcher\n         DC    AL1(L'ECLIT)             Length of eyecatcher\nECLIT    DC    C'MPFEXTOD &ASMDATE &SYSTIME - Echo message to TSO user'\n         DS    0H                       Ensure halfword alignment\nECL      EQU   *-EC\n*\n** Standard ESA entry housekeeping\n*\n         BAKR R14,0                     Save regs\n         LAE   R12,0(R15,0)             Get base register\n         USING MPFEXTOD,R12             Get addressibility\n         SAC  0\n         SYSSTATE ASCENV=P\n         STORAGE OBTAIN,LENGTH=WORKDSL,LOC=BELOW Obtain storage\n         LR   R13,R1                    Point to Save Area\n         MVC  4(4,R13),=C'F1SA'         Indicate stack SA\n         USING WORKDS,R13               Get addressibility to area\n*\n** Locate MPF exit parameter list and message area\n*\n         EREG  R0,R1                    Restore regs 0 and 1\n         L     R2,0(R1)                 Get CTXT Address\n         ICM   R3,B'1111',CTXTTXPJ-CTXT(R2) Locate Major\n         BZ    EXIT                     Shouldn't happen, but leave\n*\n** See we want to touch these guys\n*\n         TM    CTXTMTY1-CTXT(R2),CTXTMTYA  Monitor jobnames active?\n         BNO   TEST$X                   No, hit the JES2 start/stop\n         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'$HASP373'\n         BE    EXIT\n         CLC   CTXTTMSG-CTXTATTR(7,R3),=C'$HASP395'\n         BE    EXIT\nTEST$X   DS    0H\n*\n** Append the current date onto the end of the message\n*\n         TIME  BIN                      Get current time and date\n         STM   R0,R1,DOUBLE             Save time and date\n         LA    R15,CTXTTMSG-CTXTATTR(R3) Locate to start of message\n         SLR   R14,R14                  Clear register\n         ICM   R14,B'0011',CTXTTLEN-CTXTATTR(R3) Get length\n         AR    R15,R14\n         MVC   0(3,R15),=C' - '\n         LA    R15,3(R15)\n         LM    R0,R1,DOUBLE             Save time and date\n         BAS   R14,CONVERT_TO_TODSTRING Convert the time and date\n         LA    R14,CTXTTMSG-CTXTATTR(R3) Locate to start of message\n         SR    R15,R14\n         STCM  R15,B'0011',CTXTTLEN-CTXTATTR(R3) Set new length\n         OI    CTXTRFB1-CTXT(R2),CTXTRCMT  Say we changed it\n*\n** Release resources and return to caller\n*\nEXIT     DS    0H\n         LR    R2,R13                     Get storage address\n         STORAGE RELEASE,LENGTH=WORKDSL,ADDR=(R2) Release storage\n         SLR   R15,R15                    Set return code\n         PR                               Return to caller\n         EJECT\n***********************************************************************\n***                                                                 ***\n** Convert input binary time and packed decimal julian date to a     **\n** fancy output string of \"dd-mmm-ccyy hh:mm:ss pm\"                  **\n**                                                                   **\n** Input: R0 - Time in binary                                        **\n**        R1 - Date in packed decimal                                **\n**        R15 - points to the output area                            **\n**                                                                   **\n** Output: the area in R15 will be filled in and R15 updated with    **\n**         address just past the filled in area.                     **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nCONVERT_TO_TODSTRING DS 0H\n         ST    R15,CTT_OUT                Save output area address\n         ST    R14,CTT_RA                 Save return address\n*\n** Get the input time (binary) and date (packed decimal) and convert\n** it to a STCK TOD format\n*\n         LA    R14,CTT_CIN                Locate routine Time/Date area\n         XC    0(CTAREAL,R14),0(R14)      Clear to binary zeros\n         STCM  R0,B'1111',CTAREA_TIME-CTAREA(R14) Save Time\n         STCM  R1,B'1111',CTAREA_DATE-CTAREA(R14) Save Date\n*\n         CONVTOD CONVVAL=CTT_CIN,         Convert this Time/Date       @\n               TODVAL=CTT_TOD,            ..To TOD format              @\n               TIMETYPE=BIN,              ..Time is binary format      @\n               DATETYPE=YYDDD,            ..Date is julian 0CYYDDDf    @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    CONVTOD worked?\n         BNZ   CTT$JUL                    Failed, do primitive way\n*\n** Convert the TOD stamp into time and date formats\n*\n         STCKCONV STCKVAL=CTT_TOD,        Convert this TOD Stamp       @\n               CONVVAL=CTT_SOUT,          ..Into these date/time areas @\n               TIMETYPE=DEC,              ..Output time format         @\n               DATETYPE=DDMMYYYY,         ..Output Date format         @\n               MF=(E,PARMLIST)\n         LTR   R15,R15                    CONVTOD worked?\n         BNZ   CTT$JUL                    Failed, do primitive way\n*\n** Format the date\n*\n         L     R15,CTT_OUT                Locate output area\n*                               D  D  -  M  M  -  C  C  Y  Y\n         MVC   0(11,R15),=X'40,20,20,60,20,20,60,20,20,20,20'\n         ED    0(11,R15),CTT_SOUT+8       Edit it to \" dd-mm-ccyy\"\n         MVC   0(3,R15),1(R15)            Move \"dd-\" over \"dd-...-ccyy\"\n         PACK  DOUBLE(8),4(2,R15)         Get month in decimal\n         CVB   R14,DOUBLE                 Convert to binary\n         BCTR  R14,0                      Make relative to zero\n         MH    R14,=H'3'                  Multiply for month offset\n         LA    R1,=C'JanFebMarAprMayJunJulAugSepOctNovDec'\n         AR    R1,R14                     Locate month entry\n         MVC   3(3,R15),0(R1)             Move \"mmm\" to \"dd-mmm-ccyy\"\n         OI    0(R15),X'F0'               Ensure leading zero\n         LA    R15,11(R15)                Bump past date\n*\n         MVC   0(3,R15),=C' - '\n         LA    R15,3(R15)\nCTT$JUL  DS    0H\n         UNPK  DOUBLE2(9),#CTTPMD(5)           *\n         MVZ   DOUBLE2(8),=8X'00'              ** Hex convert\n         TR    DOUBLE2(8),=C'0123456789ABCDEF' *\n*\n         CLI   #CTTPMD,0                  Century = 19xx?\n         BE    CTT$Y19\n         CLI   #CTTPMD,1                  Century = 20xx?\n         BE    CTT$Y20\n         CLI   #CTTPMD,2                  Century = 21xx?\n         BNE   CTT$YX\n         MVC   0(2,R15),=C'22'\n         LA    R15,2(R15)\n         B     CTT$YX\nCTT$Y19  DS    0H\n         MVC   0(2,R15),=C'19'\n         LA    R15,2(R15)\n         B     CTT$YX\nCTT$Y20  DS    0H\n         MVC   0(2,R15),=C'20'\n         LA    R15,2(R15)\nCTT$YX   DS    0H\n         MVC   0(2,R15),DOUBLE2+2         Get yy from \"0cyydddf\"\n         MVI   2(R15),C'.'                Insert dot\n         MVC   3(3,R15),DOUBLE2+4         Get ddd from \"0cyydddf\"\n         LA    R15,6(R15)                 Locate past \"yy.ddd'\n         L     R14,CTT_RA                 Get return address\n         BSM   0,R14                      Return to caller\n#CTTPMD  EQU   CTT_CIN+(CTAREA_DATE-CTAREA)    Generate offset\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Constants                                                   **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         LTORG ,\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       GETMAINed work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         DS    0D\nWORKDS   DSECT ,\n         DS    18F                    Register Save Area\nDOUBLE   DS    D\nDOUBLE2  DS    2D\nPARMLIST DS    10F\n         DS    0D\nCTT_TOD  DS    D                        ..TOD (STCK) area\nCTT_OUT  DS    F                        ..Output area address\nCTT_RA   DS    F                        ..Return address\nCTT_CIN  DS    XL(CTAREAL)              ..CONVTOD input area\nCTT_SOUT DS    XL16                     ..STCKCON output area\n         DS    0D\nWORKDSL  EQU   *-WORKDS\n*\n** Map CONVTOD area\n*\nCTAREA          DSECT ,\nCTAREA_TIME     DS    XL4\n                DS    XL4\nCTAREA_DATE     DS    XL4\n                DS    XL4\nCTAREAL         EQU   *-CTAREA\n         END\n./ ADD NAME=NEWDAYE  1100-97081-97081-1322-00316-00316-00000-DALCOCK\n/* REXX\n |\n | Name: NEWDAY\n |\n | Author: David Alcock\n |         dave@planetmvs.com\n |         (based on LSTJOBS written by Paul S. Waterhouse)\n |\n | Purpose: Send a message with the current date right after midnight to\n |          the job log of started tasks to make it easy to know what\n |          day a message was issued.\n |\n |          This exec builds the command to send messages using a\n |          JES2 command.  It would need to be modified for JES3.\n |\n | Requirements: You must have a way to succesfully issue MCS operator\n |               commands via a REXX exec.\n |\n |               Your automated operations task should start this REXX\n |               right after midnight.\n */\n\n/**********************************************************************\n***                                                                 ***\n**           M o d i f i c a t i o n   H i s t o r y                 **\n**                                                                   **\n** Person     Date        Description                                **\n** ---------- ----------- ------------------------------------------ **\n** DGAlcock   22-MAR-1997 Add checking of JES2 command prefix;       **\n** DGAlcock   01-MAR-1997 Added: debug mode, jobname check;          **\n** DGAlcock   25-FEB-1997 Initial REXX exec written based on Paul    **\n**                        Waterhouse's execellent LSTJOBS exec;      **\n***                                                                 ***\n**********************************************************************/\n\n  arg debug\n\n  xgdate = translate(date(),'-',' ')\n  xjdate = substr(date('s'),1,4)\".\"substr(date('j'),3,3)\n  say \"%NEWDAY - Execution begins - \"xgdate\" - \"xjdate\" - \"time()\n\n  mcs_cmd = \"@C OSCMD \"   /* Installation dependant */\n  jes2_cp = \"$\"\n\n /*-----------------------------------------------------------------+\n  |  Let's only do this if if it makes sense.  This command was     |\n  |  designed to be executed right after midnight to put a new      |\n  |  date message in the job log of long running tasks.             |\n  *-----------------------------------------------------------------*/\n\n  if translate(debug) == \"DEBUG\" then test = 1\n  else test = 0\n\n  address TSO mcs_cmd \"D T\"  /* Test the waters */\n  say \"%NEWDAY - Issued command 'D T' - RC=\"rc\n\n  if substr(time(),1,4) <> \"00:0\" then do\n     say \"%NEWDAY - Processing at \"time()\" doesn't make sense\"\n     if test then say \"%NEWDAY - Continuing in test mode, \" ,\n        \"but no commands will be issued\"\n     else signal quickout\n     end\n\n /*-----------------------------------------------------------------+\n  |  Set numeric digits to accomodate BIG hex numbers in decimal    |\n  *-----------------------------------------------------------------*/\n\n  numeric digits 15\n\n /*-----------------------------------------------------------------+\n  |  get address pointers                                           |\n  |    CVT (real loc 16)                                            |\n  |    ASVT (CVT+22C)                                               |\n  *-----------------------------------------------------------------*/\n\n   cvt_ptr = get_ptr(10,0)\n   asvt_ptr = get_ptr(cvt_ptr,'22c')\n\n /*-----------------------------------------------------------------+\n  |  get system id * REQUIRES GETSMFID FUNCTION *                   |\n  *-----------------------------------------------------------------*/\n\nif sysvar(systsoe) > \"2040\" then ,             /* At v2.5 or higher? */\n   c_sys_smfid = mvsvar(syssmfid)              /* Yes, use IBM func  */\nelse do\n     cvt    = storage(10,4)\n     dcvt   = c2d(cvt)\n     smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n     dsmca  = c2d(smca)\n     c_sys_smfid = storage(c2x(d2c(dsmca+x2d(10))),4)\n     end\n\nif substr(c_sys_smfid,1,3) == \"XYZ\" then ,\n   jes2_cp = \"/\"           /* XYZ uses / instead of $ */\n\n /*-----------------------------------------------------------------+\n  |  Get MASTER (ASID1) values.                                     |\n  |                                                                 |\n  |  In the ASVT table (starts at ASVT+X'210') master is always     |\n  |  one.                                                           |\n  |                                                                 |\n  |  If the high bit is on and address is that of masters ASVT entry|\n  |  then the ASVT entry is for an unusebale ASVT entry.            |\n  |                                                                 |\n  *-----------------------------------------------------------------*/\n\n  c_end_of_list = '80000000'                    /* Constant      */\n\n  c_curr_asvt = d2x(x2d(asvt_ptr) + x2d(210))   /* Curreny Entry */\n\n  c_mstr_asvt = d2x(x2d(c_end_of_list) + x2d(c_curr_asvt)) /*unuse*/\n\n  c_ascb_unuse_count = 0\n\n /*-----------------------------------------------------------------+\n  |  Scan ASVT routine                                              |\n  |                                                                 |\n  |  High order bit on and masters address means unuseable.         |\n  |  High order bit on and another address means its free.          |\n  |  High order bit not on means its in use (active).               |\n  |  End of chain is x'80000000'.                                   |\n  |                                                                 |\n  *-----------------------------------------------------------------*/\n\n  do forever\n\n     c_curr_asvt = d2x(x2d(c_curr_asvt) + x2d(4))  /* Next Entry    */\n\n     ascb_ptr = get_ptr(c_curr_asvt,0,4)           /* Pointer Value */\n\n     select\n\n         /*--------------------------------------------+\n          |  End of list check                         |\n          *--------------------------------------------*/\n\n           when ascb_ptr = c_end_of_list then\n                do\n                  leave\n                end\n\n         /*--------------------------------------------+\n          |  Unuseable check                           |\n          *--------------------------------------------*/\n\n           when ascb_ptr = c_mstr_asvt then\n                do\n                  c_ascb_unuse_count = c_ascb_unuse_count + 1\n                  iterate\n                end\n\n         /*--------------------------------------------+\n          |  x'80' is decimal 128 - this checks for    |\n          |  not in use.                               |\n          *--------------------------------------------*/\n\n           when x2d(substr(ascb_ptr,1,1)) > 128 | ,\n                x2d(substr(ascb_ptr,1,1)) = 128 then\n                do\n                  iterate\n                end\n\n         /*--------------------------------------------+\n          |  We got a live one!                        |\n          |  Falls out of this select.                 |\n          *--------------------------------------------*/\n\n     otherwise\n              do\n                nop\n              end\n     end\n\n /*-----------------------------------------------------------------+\n  |  Live one found!!!!!!!                                          |\n  |                                                                 |\n  |     (1) Check to make sure that ASCB pointer is valid.          |\n  |         first four characters at that address must be \"ASCB\"    |\n  |                                                                 |\n  |     (2) Get ASID and JOBNAME from ASCB:                         |\n  |         ASID = ASCB+X'24' H = ASCBASID                          |\n  |         JOBN = ASCB+X'AC' H = ASCBJBNI (Initiated Job)          |\n  |           or = ASCB+X'B0' H = ASCBJBNS (STC/TSO)                |\n  |                                                                 |\n  |      If we got one still, add it to table.                      |\n  |      and get next.                                              |\n  |                                                                 |\n  |      NOTE: No serialization is done, so system can change       |\n  |            this data while we are running. DO NOT USE DATA      |\n  |            extracted from this routine WITHOUT CHECKING IT      |\n  |            FIRST!!!!!!!!!!!!!                                   |\n  |                                                                 |\n  *-----------------------------------------------------------------*/\n\n     if \"ASCB\" \u00ac= get_data(ascb_ptr,0,4) then\n        do\n          iterate\n        end\n\n     c_jbni = get_ptr(ascb_ptr,'AC')\n     c_jbns = get_ptr(ascb_ptr,'B0')\n     c_asid = get_hlf(ascb_ptr,'24')\n\n     if c_jbni = 0 then\n        do\n          jobn_ptr = c_jbns\n        end\n      else\n        do\n          jobn_ptr = c_jbni\n        end\n\n     c_jobn = get_data(jobn_ptr,0,8)\n\n    /*--------------------------------------------------------------*\n     | This code issues a command based on:                         |\n     | - if this is a JES-managed address space (has a job log)     |\n     | - if this is a started task                                  |\n     | - the started task it not to be excluded based on jobname    |\n     *--------------------------------------------------------------*/\n\n     assb_ptr = get_ptr(ascb_ptr,'150')\n     t_jsab = get_full(assb_ptr,'A8')\n\n     if t_jsab <> \"00000000\" then do\n\n        jsab_ptr = get_ptr(assb_ptr,'A8')\n        c_jobid = get_data(jsab_ptr,'14',8)\n\n        if substr(c_jobid,1,3) == \"STC\" then do\n           say \"> Name:\" c_jobn \"JOBID:\" c_jobid\n\n           /* Put the stc names here that we don't want to send msg */\n           select\n             when c_jobn == \"INIT    \" then execute_command = 0\n             when c_jobn == \"xxxxxxxx\" then execute_command = 0\n             otherwise\n                  execute_command = 1\n           end /* of select */\n\n           if execute_command then do\n              num = substr(c_jobid,4,5) /* stcxxxxx */\n              opercmd = jes2_cp\"dms\"num\",'----- Date:\" ,\n                        xgdate \"-\" xjdate \"'\"\n              say \"        Command: \"opercmd\n\n              if test == 0 then do\n                 address TSO mcs_cmd opercmd\n                 orc = rc\n                 say \"        Command RC=\"orc\n                 end\n\n              end /* of \"if execute_command\" */\n           else do\n                say \"        Command was not issued based on jobname\"\n                end\n           say \" \"\n\n           end /* of \"if substr(c_jobid,1,3) == STC\" */\n        end /* if t_jsab <> \"00000000\" */\n\n  end\n\n /*-----------------------------------------------------------------+\n  |  End of REXX exec                                               |\n  *-----------------------------------------------------------------*/\n\n  say \"%NEWDAY - Unusable ASIDS:\" c_ascb_unuse_count\n  quickout:\n  say \"%NEWDAY - Execution ends\"\n  exit\n\nget_ptr: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte pointer as hexadecimal |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_full: procedure\n    /* +-----------------------------------------+\n       | returns a 4 byte field as hexadecimal   |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,4))\n  exit\n\nget_hlf: procedure\n    /* +-----------------------------------------+\n       | returns a 2 byte field as hexadecimal   |\n       | string at address addr+offset.          |\n       | ADDR and OFFSET must be HEX strings.    |\n       +-----------------------------------------+ */\n  arg addr, offset\n  temp = d2x(x2d(addr) + x2d(offset))\n  return c2x(storage(temp,2))\n  exit\n\nget_data: procedure\n    /* +-----------------------------------------+\n       | returns LENGTH bytes at ADDR+OFFSET as  |\n       | an EBCDIC string.                       |\n       | ADDR and OFFSET must be HEX strings.    |\n       | LENGTH must be a decimal string.        |\n       +-----------------------------------------+ */\n  arg addr, offset, length\n  temp = d2x(x2d(addr) + x2d(offset))\n  return storage(temp,length)\n  exit\n./ ADD NAME=NEWDAYP  1100-97081-97081-1322-00014-00014-00000-DALCOCK\n//NEWDAY  PROC\n//*********************************************************************\n//***                                                               ***\n//** THIS PROC IS A STARTED TASK SENDS MESSAGES TO ALL STARTED TASKS **\n//** SO AN ENTRY IN THE JOBLOG SHOWS A NEW DAY HAS STARTED.  THIS    **\n//** MAKES IT EASIER TO LOOK THRU A JOB LOG AND KNOW WHAT DAY        **\n//** A MESSAGE CAME OUT ON.                                          **\n//***                                                               ***\n//*********************************************************************\n//IEFPROC EXEC PGM=IKJEFT01,TIME=1439,DYNAMNBR=100,\n//        PARM='%NEWDAY'       (rename the NEWDAYE member to this)\n//SYSTSPRT DD SYSOUT=X\n//SYSTSIN  DD DUMMY\n//SYSPROC  DD DISP=SHR,DSN=your.rexx.library\n./ ADD NAME=OSCMD    1100-97081-97081-1322-00234-00234-00000-DALCOCK\n Note: replace ENTER and LEAVE with your Entry and exit housekeeping.\n***********************************************************************\n***                                                                 ***\n** Name: OSCMD                                                       **\n**                                                                   **\n** Author: David G. Alcock                                           **\n**                                                                   **\n** Purpose: Issue operator command from TSO/CLIST or via batch.      **\n**                                                                   **\n** Attributes: Reentrant, Reusable, and APF authorized               **\n**                                                                   **\n***                                                                 ***\n***********************************************************************\n         EJECT\nOSCMD    ENTER 'ISSUE OPERATOR COMMANDS',                              @\n               LV=DSAL,RENT=YES,                                       @\n               AMODE=31,RMODE=ANY\n         USING DSA,R13                    Get addressiblity to area\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Initialization                                              **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         ST    R1,R1SAVE                  Save address of input parms\n*\n** Must be APF authorized\n*\n         TESTAUTH FCTN=1                 Check for APF Authorization\n         LTR   R15,R15                   Are we?\n         BNZ   E$APF                     No, leave\n*\n** User authorized to use this command?\n*\nVERIFY_TECH_SUPPORT EQU *\n         L     R1,PSATOLD-PSA       -> TCB\n         L     R1,TCBTIO-TCB(R1)    -> TIOT\n         CLC   TIOCNJOB-TIOT1(8,R1),=CL8'CLEAR'  Clear started task\n         BE    PROCEED              Yes...\n         CLC   TIOCNJOB-TIOT1(8,R1),=CL8'CLEARBC' CLEARBC started task?\n         BE    PROCEED              Yes...\n         CLC   TIOCNJOB-TIOT1(8,R1),=CL8'NEWDAY' Newday\n         BE    PROCEED              Yes...\n* Put other checks here like looking at ACF2 LID...\n         B     E$NAUTH\nPROCEED EQU *\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Process input parameters from CBUF or O/S parameter         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nPROCESS_PARAMETER EQU *\n L     R1,R1SAVE                          -> CPPL\n TM    CPPLCBUF-CPPL(R1),X'80'            Was this command called?\n BNO   PP$NC                              No, need to look at CBUF\n*\n** We were called, it has a Batch type (EXEC) parameter\n*\n L     R2,0(R1)                           Get address of parm\n SLR   R3,R3                              Clear register\n ICM   R3,B'0011',0(R2)                   Get length of parm\n BZ    EXIT                               None, leave\n LA    R2,2(R2)                           Bump past parm length HW\n B     PP$X                               Parse the input\n*\n** DGAT902 was not called, it is a \"Command Processor\"\n*\nPP$NC EQU   *\n L     R2,CPPLCBUF-CPPL(R1)               Locate Command Buffer\n SLR   R3,R3                              Clear register\n ICM   R3,B'0011',0(R2)                   Get total CBUF length\n SLR   R0,R0                              Clear register\n ICM   R0,B'0011',2(R2)                   Get total Command name length\n LA    R15,4                              Length of header\n AR    R2,R15                             Bump past header\n SR    R3,R15                             Decrement for header length\n AR    R2,R0                              Bump past Command length\n SR    R3,R0                              Length of data\n LTR   R3,R3\n BZ    EXIT\n*\n** R2 - Address of command-buffer/Parameter\n** R3 - Length of command-buffer/Parameter\n*\nPP$X     EQU   *\n         BCTR  R3,0                       Decrement for EX\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Issue the command                                           **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n*\n** Issue WTO for audit trail\n*\n         BAS   R9,FORMAT_WTO              Format the WTO\n         MVC   0(MSG1L,R15),MSG1          Move in message\n         LA    R15,MSG1L+1(R15)           Bump past the message\n         EX    R3,MOVEWTO                 Move the command to WTO area\n         LA    R15,1(R3,R15)              Bump past the message\n         BAS   R9,ISSUE_WTO               Issue the WTO\n*\n** Issue the command\n*\n         LA    R14,COMMAND               Locate Command area\n         XC    0(MGCRLTH,R14),0(R14)     Clear it to binary zeros\n*\n         LA    R15,MGCRTEXT-MGCRPL(R14)  Locate Command area\n         EX    R3,MOVECMD                Move command to buffer area\n         LA    R15,1(R3,R15)             Bump past it\n*\n         SR    R15,R14                   Length = end - Beginning\n         STC   R15,MGCRLGTH-MGCRPL(R14)  Save length\n*\n         MODESET KEY=ZERO,MODE=SUP       Get into Key Zero\n*\n         SLR   R0,R0                     Clear register\n         MGCR  COMMAND                   Issue command\n*\n         MODESET KEY=NZERO,MODE=PROB     Get out of Key Zero\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       Termination section                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nEXIT     EQU   *\n         LEAVE ,                                  Return to caller\nE$NAUTH  WTO   'OSCMD-99E You are not authorized to use this command'\n         B     EXIT\nE$APF    WTO   'OSCMD-98E This command must be APF authorized'\n         B     EXIT\n         EJECT\n***********************************************************************\n***                                                                 ***\n**                 Dynamic WTO Processing                            **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** FORMAT THE WTO AND INITIALIZE THE PREFIX AREA                     **\n** INPUT: R1 - ADDRESS OF MESSAGE NUMBER TO BE FILLED IN (3 BYTES)   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\nFORMAT_WTO EQU *\n*\n** INITIALIZE THE WTO\n*\n         LA    R15,WTO                    LOCATE WORK AREA\n         XC    0(WPLTXT-WPL,R15),0(R15)   CLEAR COMMON SECTION\n         OI    WPLMCSF1-WPL(R15),WPLMCSFA ROUTE CODE/DESC PRESENT\n         OI    WPLMCSF1-WPL(R15),WPLMCSFG ONLY QUEUE TO HARD COPY\n*        OI    WPLMCSF2-WPL(R15),WPLMCSFI NO TIME STAMP\n         LA    R15,WPLTXT-WPL(R15)        LOCATE MESSAGE TEXT AREA\n         MVI   0(R15),C' '                MOVE BLANK INTO TEXT AREA\n         MVC   1(124,R15),0(R15)          ..PROPAGATE BLANK\n*\n** Message Prefix Stuff\n*\n         MVC   0(5,R15),5(R12)            Move in \"OSCMD\"\n         MVI   5(R15),C'-'\n         LA    R15,5+1(R15)               BUMP PAST IT\n*\n         BSM   0,R9                       RETURN TO CALLER\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\n** COMPLETE THE WTO AND ISSUE IT                                     **\n** INPUT: R15 - ADDRESS PAST LAST BYTE OF WTO TEXT                   **\n** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - **\nISSUE_WTO EQU *\n*\n** COMPLETE THE WTO DESC/ROUT\n*\n         XC    0(WPLQID-WPLFLGS,R15),0(R15)     CLEAR FLAG BYTES\n         OI    WPLDESC1-WPLFLGS(R15),WPLDESCG   REGULAR MESSAGE\n         OI    WPLROUT2-WPLFLGS(R15),WPLROUTN   ROUTCDE=14\n         LA    R15,L'WPLDESC+L'WPLROUT(R15)     BUMP PAST ROUT/DESC\n*\n** COMPUTE THE LENGTH: TEXT + ROUT/DESC\n*\n         LA    R1,WTO+WPLTXT-WPL          LOCATE BEGINNING OF TEXT\n         SR    R15,R1                     LENGTH = END - BEGINNING\n         STCM  R15,B'0011',WTO+WPLLGH-WPL SAVE LENGTH\n         WTO   ,MF=(E,WTO)                ISSUE THE WTO\n*\n         BSM   0,R9                       RETURN TO CALLER\n         EJECT\n***********************************************************************\n***                                                                 ***\n**        Constants                                                  **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nMOVEWTO  MVC   0(0,R15),0(R2)             ** Executed **\nMOVECMD  MVC   0(0,R15),0(R2)            ** Executed **\n*\nMSG1     DC    C'01I Command issued:'\nMSG1L    EQU   *-MSG1\n         LTORG ,                              Literals\n         DS    0D\n         EJECT\n***********************************************************************\n***                                                                 ***\n**       Getmained Work area                                         **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\nDSA      DSECT ,\n         DS    18F                        Register Save Area\nR1SAVE   DS    F                          R1 at entry\nWTO      DS    XL(#WPL)                   WTO work area\nCOMMAND  DS    XL(MGCRLTH)                Operator Command work area\nNJECMD   DS    XL(MGCRLTH)                Operator Command work area\n         DS    0D\nDSAL     EQU   *-DSA                      Length of DSA\n         EJECT ,\n***********************************************************************\n***                                                                 ***\n**       DSECTS                                                      **\n***                                                                 ***\n***********************************************************************\n         SPACE 2\n         IKJCPPL ,                        Cmd Processor Parm List\n         IEZMGCR  DSECT=NO                SVC 34 Parameter List\n         IHAPSA ,                         Prefixed Save Area\n         IKJTCB ,\n         IEFTIOT1 ,\n         IHAASCB ,                        Address Space Control Block\n         IEZWPL ,\n#WPL     EQU    L'WPLLGH+L'WPLMCSF+L'WPLTXT+L'WPLDESC+L'WPLROUT\n         END ,\n./ ENDUP       \"REVIEW\" PDS MEMBER OFFLOAD AT 15:16 ON 98/01/16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSMAP": {"ttr": 28678, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x02\\x00\\x08\\x00\\x99\\x06\\x0f\\x01\\x020o\\x188\\x01-\\x01\\t\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.02", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:38:08", "lines": 301, "newlines": 265, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n | This thing needs work in V=R and R10 larger PSA!!!!\n |\n | Name: VSMAP\n |\n | Author: David Alcock\n |\n | Purpose: Show the Virtual Storage Map of a OS/390 (MVS)\n |\n | Written: 21 November 1997\n |\n | Update:  30 August 1999 - Howard Sherman\n |          Added \"Length\" field\n |          Removed \"Private Region Below The Line\" comment\n |\n | Tested: OS/390 v1.2 (should work MVS/XA and higher)\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code\n |             provided.  It is copyright 1997-2002+ by David Alcock\n |             All rights reserved.\n */\n\nNUMERIC DIGITS 10\n\ncall get_vsmap        /* Call inline routine and obtain V/S map */\n\nif vsmap.0 == 0 then do\n   say \"%VSMAP is OS/390 (MVS) dependent and can't run on \"address()\n   exit\n   end\n\nif address() == \"TSO\" then ,\n/* \"clrscrn\"      Installation dependant - Clear the screen */\n\ncall get_smfid /* Call inline routine to obtain the SMFID */\n\nsay \"Virtual Storage Map - SMFID=\"smfid\nsay \" \"\nsay left(\"Start\",8) left(\"End\",8) left(\"Name\",15) left(\"Length\",9)\nsay left(\"-\",8,\"-\") left(\"-\",8,\"-\") left(\"-\",15,\"-\") left(\"-\",9,\"-\")\ndo i = vsmap.0 to 1 by -1\n   if vsmap.i == \"\" then iterate\n   if word(vsmap.i,2) <> 0 then ,\n      say word(vsmap.i,1) word(vsmap.i,2) ,\n          left(word(vsmap.i,3),15),\n          get_length(vsmap.i)\n   if i = 12 then say \"--------- 16 Meg line -----------\"\n   end\n\n/*gdapvtsz = c2d(storage(d2x(cvtgda + o_GDAPVTSZ),4))      */\n/*gdapvtsz = gdapvtsz/1024                                 */\n/*say \" \"                                                  */\n/*say \"The Private region below the line:\" gdapvtsz\"K\"     */\nexit\n\n/*---------------------------------------------------------------------\n | Routine: Get SMFID\n | Author: David Alcock dalcock@csw.com davea@ticnet.com\n | Returns: smfid in variable smfid\n ------------------------------------------------------------------- */\nGet_SMFID:\n\nif address() == \"TSO\" then ,\n   if sysvar(systsoe) > \"2040\" then do         /* At v2.5 or higher? */\n      smfid = mvsvar(syssmfid)                 /* Yes, use IBM func  */\n      return\n      end\n\ncvt    = storage(10,4)\ndcvt   = c2d(cvt)\nsmca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\ndsmca  = c2d(smca)\nsmfid  = storage(c2x(d2c(dsmca+x2d(10))),4)\n\nreturn\n\n/*---------------------------------------------------------------------\n | Routine: Get Virtual Storage Map\n | Author: David Alcock @20-Nov-1997 dalcock@csw.com davea@ticnet.com\n | Returns: vsmap. array with VSM storage areas\n ------------------------------------------------------------------- */\nget_vsmap:\n\nselect\n  when address() == \"TSO\" then nop\n  when address() == \"MVS\" then nop\n  otherwise\n     vsmap.0 = 0\n     return\n     end\n\nvsmap.0 = 19 /* number of VSM areas */\n\n/*\n | Set offsets in control blocks (taken from DA$ADATA output)\n */\n\no_CVTGDA = 560    ;   o_CVTSMEXT = 1196\no_CVTMLPAS = 8    ;   o_CVTMLPAE = 12\no_CVTEMLPE = 76   ;   o_CVTEMLPS = 72\no_CVTEFLPE = 68   ;   o_CVTEFLPS = 64\no_CVTEPLPE = 60   ;   o_CVTEPLPS = 56\no_CVTERWNE = 52   ;   o_CVTERWNS = 48\no_CVTRWNE = 36    ;   o_CVTRWNS = 32\no_CVTRONE = 44    ;   o_CVTRONS = 40\no_CVTPLPAE = 28   ;   o_CVTPLPAS = 24\no_CVTFLPAE = 20   ;   o_CVTFLPAS = 16\no_CVTREAL = 284\n\no_GDAEPVT = 168   ;   o_GDAEPVTS = 172\no_GDAECSA = 124   ;   o_GDAECSAS = 128\no_GDACSA = 108    ;   o_GDACSASZ = 112\no_GDAESQA = 152   ;   o_GDAESQAS = 156\no_GDASQA = 144    ;   o_GDASQASZ = 148\no_GDAVR = 192     ;   o_GDAPVTSZ = 164\n\n/*\n | Locate global areas\n */\n\ncvt      = c2d(storage(10,4))                    /* -> CVT */\ncvtgda   = c2d(storage(D2X(cvt + o_CVTGDA),4))   /* -> GDA */\ncvtsmext = c2d(storage(D2X(cvt + o_CVTSMEXT),4)) /* -> CVTSMEXT */\n\n/*\n |  Area number 19 - Ext-Private\n */\n\ngdaepvt  = c2d(storage(D2X(cvtgda + o_GDAEPVT),4))\nvsmap.19 = right(D2X(gdaepvt),8,'0') \"7FFFFFFF\" ,\n           'Ext-Private'\n\n/*\n |  Area number 18 - Ext-CSA\n */\n\ngdaecsa  = c2d(storage(D2X(cvtgda + o_GDAECSA),4))\nend = (gdaecsa + c2d(storage(D2X(cvtgda + o_GDAECSAS),4))) - 1\nvsmap.18 = right(D2X(gdaeCSA),8,'0') right(d2x(end),8,'0') ,\n           'Ext-CSA'\n\n/*\n |  Area number 17 - Ext-MLPA\n */\ncvtemlps = c2d(storage(D2X(cvtsmext + o_CVTEMLPS),4))\ncvtemlpe = c2d(storage(d2x(cvtsmext + o_CVTEMLPE),4))\nvsmap.17 = right(d2x(cvtemlps),8,'0') right(d2x(cvtemlpe),8,'0') ,\n           'Ext-MLPA'\n\n/*\n |  Area number 16 - Ext-FLPA\n */\ncvteflps = c2d(storage(D2X(cvtsmext + o_CVTEFLPS),4))\ncvteflpe = c2d(storage(d2x(cvtsmext + o_CVTEFLPE),4))\nvsmap.16 = right(d2x(cvteflps),8,'0') right(d2x(cvteflpe),8,'0') ,\n           'Ext-FLPA'\n\n/*\n |  Area number 15 - Ext-PLPA\n */\ncvteplps = c2d(storage(D2X(cvtsmext + o_CVTEPLPS),4))\ncvteplpe = c2d(storage(d2x(cvtsmext + o_CVTEPLPE),4))\nvsmap.15 = right(d2x(cvteplps),8,'0') right(d2x(cvteplpe),8,'0') ,\n           'Ext-PLPA'\n\n/*\n |  Area number 14 - Ext-SQA\n */\ngdaesqa  = c2d(storage(D2X(cvtgda + o_GDAESQA),4))\nend = (gdaesqa + c2d(storage(D2X(cvtgda + o_GDAESQAS),4))) - 1\nvsmap.14 = right(D2X(gdaesqa),8,'0') right(d2x(end),8,'0') ,\n           'Ext-SQA'\n\n/*\n |  Area number 13 - Ext-R/W Nucleus\n */\n\ncvterwns = c2d(storage(D2X(cvtsmext + o_CVTERWNS),4))\ncvterwne = c2d(storage(d2x(cvtsmext + o_CVTERWNE),4))\nvsmap.13 = right(d2x(cvterwns),8,'0') right(d2x(cvterwne),8,'0') ,\n           'Ext-R/W_Nucleus'\n\n/*\n |  Area number 12 - Ext-R/O Nucleus\n */\n\nend = cvterwns - 1\nvsmap.12 = \"01000000\" right(d2x(end),8,'0') ,\n           'Ext-R/O_Nucleus'\n\n/*\n |  Area number 11 - R/O Nucleus\n */\ncvtrons = c2d(storage(D2X(cvtsmext + o_CVTRONS),4))\ncvtrone = c2d(storage(d2x(cvtsmext + o_CVTRONE),4))\nvsmap.11 = right(d2x(cvtrons),8,'0') \"00FFFFFF\" ,\n           'R/O-Nucleus'\n\n/*\n |  Area number 10 - R/W Nucleus\n */\ncvtrwns = c2d(storage(D2X(cvtsmext + o_CVTRWNS),4))\ncvtrwne = c2d(storage(d2x(cvtsmext + o_CVTRWNE),4))\nvsmap.10 = right(d2x(cvtrwns),8,'0') right(d2x(cvtrwne),8,'0') ,\n           'R/W-Nucleus'\n\n/*\n |  Area number 9  - SQA\n */\n\ngdasqa   = c2d(storage(D2X(cvtgda + o_GDASQA),4))\nend = (gdasqa + c2d(storage(D2X(cvtgda + o_GDASQASZ),4))) - 1\nvsmap.9  = right(D2X(gdasqa),8,'0') right(d2x(end),8,'0') ,\n           'SQA'\n\n/*\n |  Area number 8  - PLPA\n */\ncvtplpas = c2d(storage(D2X(cvtsmext + o_CVTPLPAS),4))\ncvtplpae = c2d(storage(D2X(cvtsmext + o_CVTPLPAE),4))\nvsmap.8  = right(D2X(cvtplpas),8,'0') right(d2x(cvtplpae),8,'0') ,\n           'PLPA'\n\n/*\n |  Area number 7  - FLPA\n */\ncvtflpas = c2d(storage(D2X(cvtsmext + o_CVTFLPAS),4))\ncvtflpae = c2d(storage(D2X(cvtsmext + o_CVTFLPAE),4))\nvsmap.7  = right(D2X(cvtflpas),8,'0') right(d2x(cvtflpae),8,'0') ,\n           'FLPA'\n\n/*\n |  Area number 6  - MLPA\n */\ncvtmlpas = c2d(storage(D2X(cvtsmext + o_CVTMLPAS),4))\ncvtmlpae = c2d(storage(D2X(cvtsmext + o_CVTMLPAE),4))\nvsmap.6  = right(D2X(cvtmlpas),8,'0') right(d2x(cvtmlpae),8,'0') ,\n           'MLPA'\n\n/*\n |  Area number 5  - CSA\n */\ngdacsa   = c2d(storage(D2X(cvtgda + o_GDACSA),4))\nend = (gdacsa + c2d(storage(D2X(cvtgda + o_GDACSASZ),4))) - 1\nvsmap.5  = right(D2X(gdacsa),8,'0') right(d2x(end),8,'0') ,\n           'CSA'\n\n/*\n |  Area number 4  - Private\n */\ngdavr    = c2d(storage(D2X(cvtgda + o_GDAVR),4))\nend      = (gdacsa-1)\nvsmap.4  = right(D2X(gdavr),8,'0') right(d2x(end),8,'0') ,\n           'Private'\n\n/*\n |  Area number 3  - Private V=R\n */\n\n/*\ncvtreal  = c2d(storage(D2X(cvt + o_CVTREAL),4))\nend = cvtreal - 1\nvsmap.3  = right(D2X(gdavr),8,'0') right(d2x(end),8,'0') ,\n           'Private_(V=R)'\n*/\nvsmap.3 = \"\"\n/*\n |  Area number 2  - System Area\n */\nvsmap.2  = \"00001000\" \"00004FFF\" \"System_Area\"\n\n/*\n |  Area number 1  - PSA\n */\nvsmap.1  = \"00000000\" \"00000FFF\" \"PSA\"\n\nreturn\n\nget_length:\nARG start end comment\nlength = (X2D(end) - X2D(start) + 1) % 1024\nreturn RIGHT(length\"K\",9)\n\n/*---------------------------------------------------------------------\n | END END END END END - End of VSMAP exec - END END END END END\n ------------------------------------------------------------------- */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMITINFO": {"ttr": 28684, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x03\\x002\\x00\\x99\\x06\\x0f\\x01\\x020o\\x18C\\x03\\xbf\\x03\\xc1\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "20.03", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "2002-11-02T18:43:32", "lines": 959, "newlines": 961, "modlines": 0, "user": "IBMUSER"}, "text": "/* REXX\n |\n | Name: XMITINFO\n |\n | Author: David Alcock :: dave@planetmvs.com\n |\n | Purpose: Display information about a TSO XMIT file\n |\n |          TSO XMIT files are a convienent way to ship MVS files\n |          from one system to another.\n |\n |          The XMIT file specifications can be found in the TSO/E\n |          Customization manual.\n |\n | Syntax:\n |\n | - PC:\n |   - XMITINFO name.XMI\n |   - XMITINFO name.XMI debug\n |   - XMITINFO name.XMI debug dump\n |\n | - TSO (online or batch):\n |   - XMITINFO 'xmit.file'\n |   - XMITINFO 'xmit.file' debug\n |   - XMITINFO 'xmit.file' dump\n |\n | - Batch MVS via IRXJCL:\n |\n |   //JUSTDOIT EXEC PGM=IRXJCL,PARM='XMITINFO'\n |   //SYSTSPRT DD SYSOUT=*\n |   //SYSEXEC  DD DISP=SHR,DSN=your.rexx.library\n |   //SYSUT1   DD DISP=SHR,DSN=your.xmit.file\n |\n | - VM:\n |   - XMITINFO name xmit\n |   - XMITINFO name xmit w ( DEBUG\n |   - XMITINFO name xmit w ( DEBUG dump\n |\n |   Note: My VM machine is VM/ESA 1.1 and so the \"DUMP\" option\n |         fails there - David Alcock @21-APR-1998\n |\n | Disclaimer: This REXX exec is FREEWARE.  Use at your own risk.  It\n |             is provided for your enjoyment and neither David\n |             Alcock or his employer provides any warranty for it's\n |             use.  I'd like to hear how it works on your system.\n |\n |             This software is not in the public domain but is\n |             available free of charge and with source code provided.\n |             It is copyright 1997-2002+ by David Alcock.  All rights\n |             reserved.\n */\n\n/**********************************************************************\n*           M o d i f i c a t i o n   H i s t o r y\n*\n* Person     Date        Description\n* ---------- ----------- ---------------------------------------------\n* DGAlcock   21-APR-1997 v1.0 Extract_Text_Unit routine created;\n* DGAlcock   20-APR-1997 v0.7 Added text unit value type; Added dsorg\n*                             and recfm detection; misc other changes;\n* DGAlcock   18-APR-1997 v0.6 Added processing of a few text units in\n*                             INMR01 and INMR02 records;\n* DGAlcock   06-APR-1997 v0.5 Initial exec written - This base version\n*                             processes segments and outputs hex dumps;\n**********************************************************************/\n\nvrm = '1.0'\n\nmtype = address()\nPARSE SOURCE s1 s2 s3 s4 s5 s6 s7 s8 s9\n\nif mtype == \"TSO\" | mtype == \"MVS\" then ,\n   if sysvar(systsoe) > \"2040\" then systemid = mvsvar(syssmfid)\n   else do\n        cvt    = storage(10,4)\n        dcvt   = c2d(cvt)\n        smca   = storage(c2x(d2c(dcvt+x2d(c5))),3)\n        dsmca  = c2d(smca)\n        systemid = storage(c2x(d2c(dsmca+x2d(10))),4)\n        end\nelse systemid = \"\"\n\nif substr(systemid,1,3) == \"XYZ\" then \"cls\" /* clear screen for Dave */\n\nsay \"XMITINFO - version \"vrm \"- Freeware - TSO XMIT file utility\"\nsay \"Copyright 1998 by David Alcock. All rights reserved.\"\nsay \" \"\nsay \". Executing in Environment: \"s1 \"-\" mtype\nif systemid <> \"\" then say \". Executing on system: \"systemid\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Read in the input file based on the environment\n ------------------------------------------------------------------- */\n\nebcdic = 0\n\nselect\n\n  /*--------------------------------------------------------------\n   | PC: OS/2, Windows 95, Windows NT, etc.\n   ------------------------------------------------------------ */\n\n  when mtype == \"CMD\" | mtype == \"COMMAND\" then do\n\n       arg xmitfile_name options\n\n       filesize = chars(xmitfile_name)\n       if filesize == 0 then do\n          say \"Error reading input file: \"xmitfile_name\n          exit 12\n          end\n\n       end\n\n  /*--------------------------------------------------------------\n   | MVS (PGM=IRXJCL)\n   ------------------------------------------------------------ */\n\n  when mtype == \"MVS\" then do\n\n       arg options\n       ebcdic = 1\n       xmitfile_dd = \"SYSUT1\"\n       xmitfile_name = \"//SYSUT1\"\n\n    end\n\n  /*--------------------------------------------------------------\n   | TSO\n   ------------------------------------------------------------ */\n\n  when mtype == \"TSO\" then do\n       ebcdic = 1\n       arg xmitfile_dsn options\n\n       if xmitfile_dsn == \"\" then do\n          \"Missing input dataset name, terminating\"\n          exit 12\n          end\n\n       x = LISTDSI(xmitfile_dsn)\n       if x <> 0 then do\n          say \"Error accessing DSN:\" xmitfile_dsn\n          say \"> \"sysmsglvl1\n          say \"> \"sysmsglvl2\n          say \"> SYSREASON: \"sysreason\n          exit 12\n          end\n\n       xmitfile_name = sysdsname\n       parse value xmitfile_dsn with . \"(\" member \")\" .\n       if member <> \"\" then do\n          xmitfile_name = xmitfile_name\"(\"strip(member)\")\"\n          end\n\n       xmitfile_dd = \"XI\"random()\n       address TSO \"ALLOCATE FILE(\"xmitfile_dd\")\" ,\n                   \"DA('\"xmitfile_name\"') SHR REUSE\"\n\n       end\n\n  /*--------------------------------------------------------------\n   | VM files\n   ------------------------------------------------------------ */\n\n  when mtype == \"CMS\" then do\n       ebcdic = 1\n\n       parse arg fn ft fm \"(\" options\n\n       fn = strip(fn)\n       ft = strip(ft)\n       fm = strip(fm)\n       if fm == \"\" then fm = \"A\"\n\n       address command\n       \"STATE\" fn ft fm\n       if rc <> 0 then do\n          upper fn ft fm\n          \"STATE\" fn ft fm\n          if rc <> 0 then do\n             say \"%XMITINFO - File\" fn ft fm \"not found\"\n             exit\n             end\n          end\n\n       vmfclear\n       \"FINIS\" fn ft fm\n\n\n       xmitfile_name = fn ft fm\n       end\n\n  /*--------------------------------------------------------------\n   | Other systems that we don't support\n   ------------------------------------------------------------ */\n\n  otherwise\n       say \"XMITINFO does not support system type: \"mtype\n       say \"It does support: COMMAND, CMD, CMS, MVS and TSO\"\n       exit 12\n  end /* of \"select\" */\n\nsay \"Processing XMIT file: \"xmitfile_name\nsay \" \"\n\n/*---------------------------------------------------------------------\n | Parse options\n ------------------------------------------------------------------- */\n\ndebug = 0\ndump = 0\noptions = translate(options)\n\ndo i = 1 to words(options)\n   select\n     when word(options,i) == \"DEBUG\"   then debug   = 1\n     when word(options,i) == \"DUMP\"    then dump    = 1\n     otherwise\n          say \"Option '\"word(options,i)\"'\",\n              \"unknown and was ignored\"\n     end /* of select */\n   end\n\n\n/*---------------------------------------------------------------------\n | Perform functions for non-EBCDIC environments\n ------------------------------------------------------------------- */\n\nif ebcdic <> 1  then do\n\n   /*\n    |  ISO 8859-1 to CECP 1047 (Extended de-facto EBCDIC):\n    */\n\n   toEBCDIC =           '00010203372D2E2F1605250B0C0D0E0F'x  /* 00 */\n   toEBCDIC = toEBCDIC||'101112133C3D322618193F271C1D1E1F'x  /* 10 */\n   toEBCDIC = toEBCDIC||'405A7F7B5B6C507D4D5D5C4E6B604B61'x  /* 20 */\n   toEBCDIC = toEBCDIC||'F0F1F2F3F4F5F6F7F8F97A5E4C7E6E6F'x  /* 30 */\n   toEBCDIC = toEBCDIC||'7CC1C2C3C4C5C6C7C8C9D1D2D3D4D5D6'x  /* 40 */\n   toEBCDIC = toEBCDIC||'D7D8D9E2E3E4E5E6E7E8E9ADE0BD5F6D'x  /* 50 */\n   toEBCDIC = toEBCDIC||'79818283848586878889919293949596'x  /* 60 */\n   toEBCDIC = toEBCDIC||'979899A2A3A4A5A6A7A8A9C04FD0A107'x  /* 70 */\n   toEBCDIC = toEBCDIC||'202122232415061728292A2B2C090A1B'x  /* 80 */\n   toEBCDIC = toEBCDIC||'30311A333435360838393A3B04143EFF'x  /* 90 */\n   toEBCDIC = toEBCDIC||'41AA4AB19FB26AB5BBB49A8AB0CAAFBC'x  /* A0 */\n   toEBCDIC = toEBCDIC||'908FEAFABEA0B6B39DDA9B8BB7B8B9AB'x  /* B0 */\n   toEBCDIC = toEBCDIC||'6465626663679E687471727378757677'x  /* C0 */\n   toEBCDIC = toEBCDIC||'AC69EDEEEBEFECBF80FDFEFBFCBAAE59'x  /* D0 */\n   toEBCDIC = toEBCDIC||'4445424643479C485451525358555657'x  /* E0 */\n   toEBCDIC = toEBCDIC||'8C49CDCECBCFCCE170DDDEDBDC8D8EDF'x  /* F0 */\n\n\n   /*\n    | Hex table to aid in translating all 8-bit characters\n    */\n\n   hextable =             '000102030405060708090A0B0C0D0E0F'x   /* 00 */\n   hextable = hextable || '101112131415161718191A1B1C1D1E1F'x   /* 10 */\n   hextable = hextable || '202122232425262728292A2B2C2D2E2F'x   /* 20 */\n   hextable = hextable || '303132333435363738393A3B3C3D3E3F'x   /* 30 */\n   hextable = hextable || '404142434445464748494A4B4C4D4E4F'x   /* 40 */\n   hextable = hextable || '505152535455565758595A5B5C5D5E5F'x   /* 50 */\n   hextable = hextable || '606162636465666768696A6B6C6D6E6F'x   /* 60 */\n   hextable = hextable || '707172737475767778797A7B7C7D7E7F'x   /* 70 */\n   hextable = hextable || '808182838485868788898A8B8C8D8E8F'x   /* 80 */\n   hextable = hextable || '909192939495969798999A9B9C9D9E9F'x   /* 90 */\n   hextable = hextable || 'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'x   /* A0 */\n   hextable = hextable || 'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'x   /* B0 */\n   hextable = hextable || 'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'x   /* C0 */\n   hextable = hextable || 'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'x   /* D0 */\n   hextable = hextable || 'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'x   /* E0 */\n   hextable = hextable || 'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'x   /* F0 */\n\n   end\n\n/*---------------------------------------------------------------------\n | Verify that this looks like an XMIT file\n ------------------------------------------------------------------- */\n\n EOF = 0            /* End of File = No */\n file = \"\"          /* Current contents of XMIT file */\n filelen = 0        /* Current file length */\n call get_record 1  /* Read in the first record */\n\n segmentc = substr(file,3,6)\n if ebcdic == 0 then segmentc = translate(segmentc,hextable,toEBCDIC)\n\n if segmentc <> \"INMR01\" then do\n    if ebcdic == 0 then e = \"(EBCDIC)\"\n    else e = \"\"\n    say \"This does not appear to be a TSO XMIT file!\"\n    say \"> CRI (bytes 2-7) of the first record is not\" ,\n        \"INMR01\" e\n    if dump == 1 then ,\n       call Hex_Dump 1 80 \"First record of file\"\n\n    signal theend\n    end\n\n/*---------------------------------------------------------------------\n | Equate the text units - from SYS1.MACLIB(INMTEXTU)\n |\n | TSO/E 2.5 - OS/390 1.2\n ------------------------------------------------------------------- */\n\n/* KEYS FOR NETWORK USER IDENTIFICATION (INMR01 RECORD) */\n\nINMTNODE = '1001'x /* TARGET NODE NAME               */\nINMTUID  = '1002'x /* TARGET USERID                  */\nINMFNODE = '1011'x /* ORIGIN NODE NAME               */\nINMFUID  = '1012'x /* ORIGIN NODE NAME               */\nINMFVERS = '1023'x /* ORIGIN VERSION NUMBER          */\nINMFTIME = '1024'x /* ORIGIN TIME STAMP              */\nINMTTIME = '1025'x /* DESTINATION TIME STAMP         */\nINMNUMF  = '102F'x /* # OF FILES IN TRANSMISSION     */\n\n/* KEYS FOR GENERAL CONTROL */\n\nINMFACK  = '1026'x /* ACKNOWLEDGEMENT REQUEST        */\nINMERRCD = '1027'x /* RECEIVE ERROR CODE             */\nINMUTILN = '1028'x /* NAME OF UTILITY PROGRAM        */\nINMUSERP = '1029'x /* USER PARAMETER STRING          */\nINMRECCT = '102A'x /* TRANSMITTED RECORD COUNT       */\n\n/* KEYS FOR DATASET IDENTIFICATION (INMR02, INMR03 RECORDS) */\n\nINMDDNAM = '0001'x /* DDNAME FOR FILE                */\nINMDSNAM = '0002'x /* DATASET NAME FOR FILE          */\nINMMEMBR = '0003'x /* TRANSMITTED MEMBER LIST        */\nINMSECND = '000B'x /* SECONDARY SPACE QUANTITY       */\nINMDIR   = '000C'x /* DIRECTORY SPACE QUANTITY       */\nINMEXPDT = '0022'x /* EXPIRATION DATE                */\nINMTERM  = '0028'x /* TERMINAL ALLOCATION            */\nINMBLKSZ = '0030'x /* BLOCKSIZE                      */\nINMDSORG = '003C'x /* DATA SET ORGANIZATION          */\nINMLRECL = '0042'x /* LOGICAL RECORD  LENGTH         */\nINMRECFM = '0049'x /* RECORD FORMAT                  */\nINMLREF  = '1020'x /* LAST REFERENCE DATE            */\nINMLCHG  = '1021'x /* LAST CHANGE DATE               */\nINMCREAT = '1022'x /* CREATION DATE                  */\nINMSIZE  = '102C'x /* FILE SIZE IN BYTES             */\nINMTYPE  = '8012'x /* DATA SET TYPE                  */\n\n/*---------------------------------------------------------------------\n | Process the segments in the XMIT file\n ------------------------------------------------------------------- */\n\nfileptr = 1\ninmr03_count = 0\ninmr01_numf = 0\n\ndo while fileptr < filelen\n   segmentl = c2d(substr(file,fileptr,1))\n\n   needrecs = segmentl % 80\n   if needrecs <> 0 then do\n      needrecr = segmentl // 80\n      if needrecr <> 0 then needrecs = needrecs + 1\n      call get_record needrecs\n      end\n\n   segment = substr(file,fileptr,segmentl)\n   segmentd = substr(file,fileptr+1,1)\n   segmentc = substr(segment,3,6)\n   if ebcdic == 0 then ,\n      segmentc = translate(segmentc,hextable,toEBCDIC)\n\n   if dump == 1 then do\n      /* This code will fail on a VM/ESA 1.1 system (and before)\n         because the x2b() function is not available */\n      segmentdb = x2b(d2x(c2d(substr(file,fileptr+1,1))))\n      call Hex_Dump fileptr segmentl \"Segment flags=\"segmentdb\n      end\n\n   if bitand(segmentd,'20'x) = '20'x then , /* Control Record */\n      select\n         when segmentc == \"INMR01\" then call handle_inmr01\n         when segmentc == \"INMR02\" then call handle_inmr02\n         when segmentc == \"INMR03\" then do\n              call handle_inmr03\n              /* If we aren't dumping all segs, stop on last inmr03 */\n              if dump == 0 then ,\n                 if inmr03_count = inmr01_numf then do\n                    EOF = 1\n                    fileptr = filelen\n                    iterate\n                    end\n              end\n         when segmentc == \"INMR04\" then call handle_inmr04\n         when segmentc == \"INMR06\" then do\n              if debug == 1 then say \"Debug: Found INMR06\"\n              EOF = 1\n              fileptr = filelen\n              iterate\n              end\n         when segmentc == \"INMR07\" then call handle_inmr07\n         otherwise\n              if debug == 1 then do\n                 if substr(segmentc,1,3) == \"INM\" then do\n                    say \"Debug: Found unhandled CRI=\"segmentc\n                    end\n                 end\n\n        end /* of select */\n\n   fileptr = fileptr + segmentl\n\n   call get_record 1\n   end\n\n/*---------------------------------------------------------------------\n | Termination\n ------------------------------------------------------------------- */\n\ntheend:\n\nselect\n  when mtype == \"TSO\" | mtype == \"MVS\" then do\n       \"EXECIO 0 DISKR \"xmitfile_dd\" (FINIS\"\n       if mtype == \"TSO\" then ,\n          address TSO \"FREE FILE(\"xmitfile_dd\")\"\n       end\n  otherwise\n       nop\n       end\n\nexit 0\n\n/*---------------------------------------------------------------------\n | Handle inmr01 segment -- Header Record\n ------------------------------------------------------------------- */\n\nhandle_inmr01:\n\nif debug == 1 then do\n   say \" \"\n   say left('-',79,'-')\n   say \"Debug: Found INMR01 -- Header Record\"\n   end\n\ninmr01_TNODE = \"n/a\"\ninmr01_TUID = \"n/a\"\ninmr01_FNODE = \"n/a\"\ninmr01_FUID = \"n/a\"\ninmr01_FVERS = \"n/a\"\ninmr01_FTIME = \"n/a\"\ninmr01_TTIME = \"n/a\"\ninmr01_LRECL = \"n/a\"\n\nptr = 9\ntextend = segmentl - 9\n\ndo while ptr < textend\n\n      call Extract_Text_Unit\n\n   select\n     when textui = INMLRECL then inmr01_lrecl = c2d(value.1)\n     when textui = INMNUMF  then inmr01_numf  = c2d(value.1)\n     when textui = INMFNODE then inmr01_fnode = value.1\n     when textui = INMFUID  then inmr01_fuid  = value.1\n     when textui = INMTNODE then inmr01_tnode = value.1\n     when textui = INMTUID  then inmr01_tuid  = value.1\n     when textui = INMFTIME then inmr01_ftime = value.1\n     otherwise\n          if debug == 1 then ,\n             say \"       > Note: we don't handle this text unit\"\n     end /* of select */\n\n\n   ptr = ptr + textut\n   end\n\nif ebcdic == 0 then do\n   inmr01_fnode = translate(inmr01_fnode,hextable,toEBCDIC)\n   inmr01_fuid  = translate(inmr01_fuid,hextable,toEBCDIC)\n   inmr01_tnode = translate(inmr01_tnode,hextable,toEBCDIC)\n   inmr01_tuid  = translate(inmr01_tuid,hextable,toEBCDIC)\n   inmr01_ftime = translate(inmr01_ftime,hextable,toEBCDIC)\n   end\n\ntod = inmr01_ftime           /* 12345678901234 */\nif length(tod) == 14 then do /* yyyymmddhhmmss */\n   tod = substr(inmr01_ftime,1,4)\"-\"substr(inmr01_ftime,5,2)\"-\"\n   tod = tod||substr(inmr01_ftime,7,2)\" at \"substr(inmr01_ftime,9,2)\":\"\n   tod = tod||substr(inmr01_ftime,11,2)\":\"substr(inmr01_ftime,13,2)\n   end\n\nsay \"Sent from node=\"left(inmr01_fnode,8)\" userid=\"inmr01_fuid\nsay \"       to node=\"left(inmr01_tnode,8)\" userid=\"inmr01_tuid\nsay \"       on \"tod\n\nif inmr01_numf == 0 then do\n   inmr01_numf = 1\n   if debug == 1 then ,\n      say \"Number of files not defined in INMR01 record, assuming 1\"\n   end\nelse if debug == 1 then ,\n        say \"Number of files contained in this XMIT file is\" inmr01_numf\n\nif inmr01_lrecl <> 80 then ,\n   if debug == 1 then ,\n      say \"Note: LRECL not 80, found:\" inmr01_lrecl\n\nreturn\n\n/*---------------------------------------------------------------------\n | Handle inmr02 segment -- File Utility Control Record\n ------------------------------------------------------------------- */\n\nhandle_inmr02:\n\nif debug == 1 then do\n   say \" \"\n   say left('-',79,'-')\n   say \"Debug: Found INMR02  -- File Utility Control Record\"\n   end\n\ninmr02_utiln = \"n/a\"\ninmr02_size = 0\ninmr02_dsorg = 0\ninmr02_lrecl = 0\ninmr02_recfm = 0\ninmr02_blksz = 0\ninmr02_dsnam = \"\"\ninmr02_dir   = 0\ninmr02_mail  = 0\n\nptr = 13\ntextend = segmentl - 13\n\ndo while ptr < textend\n\n   call Extract_Text_Unit\n\n   select\n     when textui = INMSIZE  then inmr02_size  = c2d(value.1)\n     when textui = INMLRECL then inmr02_lrecl = c2d(value.1)\n     when textui = INMDSORG then inmr02_dsorg = value.1\n     when textui = INMRECFM then inmr02_recfm = value.1\n     when textui = INMBLKSZ then inmr02_blksz = c2d(value.1)\n     when textui = INMDIR   then inmr02_dir   = c2d(value.1)\n     when textui = INMTERM  then inmr02_mail  = 1\n     when textui = INMUTILN then inmr02_utiln = value.1\n     when textui = INMDSNAM then do\n          do j = 1 to value.0\n             if ebcdic == 0 then ,\n                inmr02_dsnam = inmr02_dsnam\".\"translate(value.j, ,\n                               hextable,toEBCDIC)\n             else inmr02_dsnam = inmr02_dsnam\".\"strip(value.j)\n             end\n          inmr02_dsnam = strip(inmr02_dsnam,'L','.')\n          end\n     otherwise\n          if debug == 1 then ,\n             say \"       > Note: we don't handle this text unit\"\n     end /* of select */\n\n\n   ptr = ptr + textut\n   end\n\nif ebcdic == 0 then do\n   inmr02_utiln = translate(inmr02_utiln,hextable,toEBCDIC)\n   end\n\nif inmr02_dsnam <> \"\" then do\n   say \" \"\n   say \"File: DSN=\"inmr02_dsnam\n\n   if inmr02_blksz <> 0 then blk = \"BLKSIZE=\"inmr02_blksz\n   else blk = \"\"\n\n   if inmr02_dsorg <> 0 then dsorg = \"DSORG=\"set_dsorg(inmr02_dsorg)\n   else dsorg = \"\"\n\n   if inmr02_recfm <> 0 then recfm = \"RECFM=\"set_recfm(inmr02_recfm)\n   else recfm = \"\"\n\n   say \"      \"dsorg\" LRECL=\"inmr02_lrecl blk recfm\n   say \"      Approximate Size in bytes:\" inmr02_size\n   end\nelse if inmr02_mail == 1 then do\n     say \" \"\n     say \"File: Mail message\"\n     end\n\nreturn\n\n/*---------------------------------------------------------------------\n | Handle inmr03 segment -- Data Control Record\n ------------------------------------------------------------------- */\n\nhandle_inmr03:\n\nif debug == 1 then do\n   say \" \"\n   say left('-',79,'-')\n   say \"Debug: Found INMR03 -- Data Control Record\"\n   end\n\ninmr03_count = inmr03_count + 1\n\nptr = 9\ntextend = segmentl - 9\n\ndo while ptr < textend\n\n   call Extract_Text_Unit\n\n   /* Insert code here to look at text unit keys - when needed */\n   /* The debug option prints text units found in INMR03 record */\n\n   ptr = ptr + textut\n   end\n\nreturn\n\n/*---------------------------------------------------------------------\n | Handle inmr04 segment -- User Control Record\n ------------------------------------------------------------------- */\n\nhandle_inmr04:\n\nif debug == 1 then do\n   say \" \"\n   say left('-',79,'-')\n   say \"Debug: Found INMR04 -- User Control Record\"\n   end\n\nreturn\n\n/*---------------------------------------------------------------------\n | Handle inmr07 segment -- Notification Control Record\n ------------------------------------------------------------------- */\n\nhandle_inmr07:\n\nif debug == 1 then do\n   say \" \"\n   say left('-',79,'-')\n   say \"Debug: Found INMR07 -- Notification Control Record\"\n   end\n\nreturn\n\n\n/*---------------------------------------------------------------------\n | Extract text unit\n ------------------------------------------------------------------- */\n\nExtract_Text_Unit:\n\ntextui = substr(segment,ptr,2)\ntextun = c2d(substr(segment,ptr+2,2))\ntextul = c2d(substr(segment,ptr+4,2))\ntextut = 4                    /* set starting length of text unit */\n\nif textun == 0 then do  /* got a \"null\" text unit */\n   value.1 = \"\"\n   value.0 = 1\n   end\nelse do\n     tpos = ptr + 4          /* get temp position in segment */\n     do j = 1 to textun\n        tlen = c2d(substr(segment,tpos,2))\n        value.j = substr(segment,tpos+2,tlen)\n        tpos = tpos + tlen + 2\n        textut = textut + 2 + tlen\n        end\n     value.0 = textun\n     end\n\nif debug == 1 then do\n   call get_textui\n   say \"Debug: Text Unit key=\"c2x(textui)\" - \"tuk\n   if value.0 == 0 then say \"       > Null text unit\"\n   else do j = 1 to value.0\n           if tuvt == \"H\" then v = c2x(value.j)\n           else do\n                v = value.j\n                if ebcdic == 0 then ,\n                   v = translate(v,hextable,toEBCDIC)\n                end\n           say \"       > Length=\"length(value.j) \"value: \"v\n           end\n   end\nreturn\n\n/*---------------------------------------------------------------------\n | Get record from input XMIT file\n ------------------------------------------------------------------- */\n\nget_record:\n\narg num\n\nif EOF == 1 then return  /* check for End-Of-File */\n\nselect\n  when mtype == \"CMD\" | mtype == \"COMMAND\" then do\n       iolen = num * 80\n       fileloc = filelen + 1\n       file = file||charin(xmitfile_name,fileloc,iolen)\n       filelen = filelen + iolen\n       if filelen = filesize then EOF = 1\n       if filelen > filesize then EOF = 1\n       end\n\n  when mtype == \"TSO\" | mtype == \"MVS\" then do\n       \"EXECIO \"num\" DISKR \"xmitfile_dd \"(STEM xmitfile.\"\n       erc = rc\n\n       if erc <> 0 then EOF = 1\n       else do n = 1 to xmitfile.0\n               file = file||xmitfile.n\n               filelen = filelen + 80\n               end\n       end\n\n  when mtype == \"CMS\" then do\n       \"EXECIO \"num\" DISKR \"fn ft fm\" (STEM XMITFILE.\"\n       erc = rc\n       if erc <> 0 then EOF = 1\n       else do n = 1 to xmitfile.0\n               file = file||xmitfile.n\n               filelen = filelen + 80\n               end\n       end\n\n  otherwise\n       nop\n       end\n\nreturn\n\n\n/*---------------------------------------------------------------------\n | Set recfm\n ------------------------------------------------------------------- */\n\nset_recfm: procedure\n\narg r\n\nr1 = substr(r,1,1)\nr2 = substr(r,2,1)\n\nit = \"\"\n\nif bitand(r1,'C0'x) = 'C0'x then it = \"U\"\nelse do\n     if bitand(r1,'80'x) = '80'x then it = \"F\"\n     if bitand(r1,'40'x) = '40'x then it = \"V\"\n     end\n\nif bitand(r1,'10'x) = '10'x then it = it\"B\"\nif bitand(r1,'04'x) = '04'x then it = it\"A\"\nif bitand(r1,'02'x) = '02'x then it = it\"M\"\n\nreturn it\n\n/*---------------------------------------------------------------------\n | Set dsorg\n ------------------------------------------------------------------- */\n\nset_dsorg: procedure\n\narg dsorg\n\nselect\n  when dsorg = '0008'x then it = 'AM'\n  when dsorg = '0200'x then it = 'PO'\n  when dsorg = '4000'x then it = 'PS'\n  otherwise\n       it = \"??\"\n       end\n\nreturn it\n/*---------------------------------------------------------------------\n | Hex dump of portions of the file\n ------------------------------------------------------------------- */\n\nHex_Dump:\n\nparse arg dstart dlen dtitle\nsay  ' '\nsay  'Dump of: 'dtitle '- length: 'dlen\nsay  '+offset 0 1 2 3  4 5 6 7  8 9 a b  c d e f'\ndoffset = dstart\ndleft = dlen\ndo h = 1 to dlen by 16\n   doff = '+'right(d2x(doffset-1),6,'0')\n   if dleft < 16 then dgrab = dleft\n   else dgrab = 16\n   dline = substr(file,doffset,dgrab)\n   dhex = \"\"\n   do dj = 1 to dgrab\n      if dj == 4 | dj == 8 | dj == 12 then dspace = \" \"\n      else dspace = \"\"\n      dhex = dhex\"\"c2x(substr(dline,dj,1))\"\"dspace\n      end\n   if ebcdic == 0 then do\n      dchars = translate(dline,hextable,toEBCDIC)\n      dchars = translate(dchars,copies('.',32),xrange('00'x,'1f'x))\n      end\n   else dchars = translate(dline,copies('.',32),xrange('00'x,'1f'x))\n\n   say   doff left(dhex,35) \"*\"left(dchars,16)\"*\"\n   doffset = doffset + 16\n   dleft = dleft - 16\n   end\n\nreturn\n\n/*---------------------------------------------------------------------\n | Get meaningful name for this text unit\n |\n | input: textui\n | output: tuk (Text Unit Key)\n |         tuvt (Text Unit value type: H for hex and C for character)\n ------------------------------------------------------------------- */\n\nget_textui:\n\nselect\n   when textui = INMBLKSZ then do\n        tuk = \"INMBLKSZ - File block size\"\n        tuvt = \"H\"\n        end\n   when textui = INMCREAT then do\n        tuk = \"INMCREAT - Creation date\"\n        tuvt = \"C\"\n        end\n   when textui = INMDDNAM then do\n        tuk = \"INMDDNAM - DDNAME associated with the file\"\n        tuvt = \"C\"\n        end\n   when textui = INMDIR   then do\n        tuk = \"INMDIR - Number of directory blocks\"\n        tuvt = \"H\"\n        end\n   when textui = INMDSNAM then do\n        tuk = \"INMDSNAM - File name\"\n        tuvt = \"C\"\n        end\n   when textui = INMDSORG then do\n        tuk = \"INMDSORG - File organization\"\n        tuvt = \"H\"\n        end\n   when textui = INMERRCD then do\n        tuk = \"INMERRCD - Error indication for the receive operation\"\n        tuvt = \"C\"\n        end\n   when textui = INMEXPDT then do\n        tuk = \"INMEXPDT - Expiration date\"\n        tuvt = \"C\"\n        end\n   when textui = INMFACK  then do\n        tuk = \"INMFACK - Notification ID\" ,\n        \"-OR- Receipt notification requested\"\n        tuvt = \"C\"\n        end\n   when textui = INMFFM   then do\n        tuk = \"INMFFM - Filemode number of a CMS file\"\n        tuvt = \"C\"\n        end\n   when textui = INMFM    then do\n        tuk = \"INMFM - Filemode number\"\n        tuvt = \"H\"\n        end\n   when textui = INMFNODE then do\n        tuk = \"INMFNODE - Origin node name\"\n        tuvt = \"C\"\n        end\n   when textui = INMFTIME then do\n        tuk = \"INMFTIME - Origin timestamp\"\n        tuvt = \"C\"\n        end\n   when textui = INMFUID  then do\n        tuk = \"INMFUID - Origin user ID\"\n        tuvt = \"C\"\n        end\n   when textui = INMFVERS then do\n        tuk = \"INMFVERS - Origin version number\"\n        tuvt = \"H\"\n        end\n   when textui = INMLCHG  then do\n        tuk = \"INMLCHG - Last change date\"\n        tuvt = \"C\"\n        end\n   when textui = INMLRECL then do\n        tuk = \"INMLRECL - Length of physical control record segments\" ,\n        \"-OR- Logical record length\"\n        tuvt = \"H\"\n        end\n   when textui = INMLREF  then do\n        tuk = \"INMLREF - Last reference date\"\n        tuvt = \"H\"\n        end\n   when textui = INMMEMBR then do\n        tuk = \"INMMEMBR - Member name list\"\n        tuvt = \"C\"\n        end\n   when textui = INMNUMF  then do\n        tuk = \"INMNUMF - Number of files in this transmission\"\n        tuvt = \"H\"\n        end\n   when textui = INMRECCT then do\n        tuk = \"INMRECCT - Number of records transmitted\"\n        tuvt = \"H\"\n        end\n   when textui = INMRECFM then do\n        tuk = \"INMRECFM - Record format\"\n        tuvt = \"H\"\n        end\n   when textui = INMSIZE  then do\n        tuk = \"INMSIZE - Approximate size of file in bytes\" ,\n        \"-OR- Size of file in bytes\"\n        tuvt = \"H\"\n        end\n   when textui = INMTERM  then do\n        tuk = \"INMTERM - Data transmitted as a message\" ,\n        \"-OR- Mail file\"\n        tuvt = \"H\"\n        end\n   when textui = INMTNODE then do\n        tuk = \"INMTNODE - Target node name\"\n        tuvt = \"C\"\n        end\n   when textui = INMTTIME then do\n        tuk = \"INMTTIME - The time the transmission was received,\" ,\n              \"in standard format\"\n        tuvt = \"C\"\n        end\n   when textui = INMTUID  then do\n        tuk = \"INMTUID - Target user ID\"\n        tuvt = \"C\"\n        end\n   when textui = INMUSERP then do\n        tuk = \"INMUSERP - User parameter string\"\n        tuvt = \"H\"\n        end\n   when textui = INMUTILN then do\n        tuk = \"INMUTILN - Utility program name\"\n        tuvt = \"C\"\n        end\n   otherwise\n        tuk = \"INM???? - Unknown (unhandled) text unit\"\n        tuvt = \"H\"\n        end\n\nreturn\n\n/*---------------------------------------------------------------------\n | END END END END END - End of XMITINFO exec - END END END END END\n ------------------------------------------------------------------- */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Y2K": {"ttr": 29190, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14\\x00\\x00\\x00\\x00\\x99\\x06\\x0f\\x00\\x99\\x06\\x0f\\x14\\x14\\x00)\\x00)\\x00\\x00\\xc4\\xc1\\xe5\\xc5\\xc1@@@@@'", "ispf": {"version": "20.00", "flags": 0, "createdate": "1999-03-01T00:00:00", "modifydate": "1999-03-01T14:14:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "DAVEA"}, "text": "/* REXX\n |\n | Name: Y2K\n |\n | Author: David Alcock\n |\n | Written: 15 October 1997\n |\n | Purpose: Show the time remaining until the Year 2000\n |\n */\n\n cyear = substr(date('s'),1,4)\n\n if cyear > 2000 | cyear == 2000 then do\n    say \"Congratulations: you have survived the Year 2000, \" ,\n        \"Today: \"date('w') date('u')\n    exit\n    end\n\n cday = date('D')\n\n if (1999 - cyear) > 1 then ,\n    fyears = 1999 - cyear \"years\"\n else fyears = \"\"\n if cyear == \"1998\" then ,\n    fyears = \"1 year\"\n\n if cday == 365 then fdays = \"\"\n else fdays = 365 - cday \"days\"\n\n chh = substr(TIME(),1,2)\n cmm = substr(TIME(),4,2)\n\n /* say \"chh='\"chh\"' cmm='\"cmm\"'  css='\"css\"'\" time() */\n\n timel = fyears fdays ( 23 - chh) \"hours\" (59 - cmm) \"minutes\"\n\n say center(\"Time left until the Year 2000:\",79)\n say center(\"------------------------------\",79)\n say center(timel,79)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT311/FILE311.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT311", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}