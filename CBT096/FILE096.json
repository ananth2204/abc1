{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011228000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 764218, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE096.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE096.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\r\\t'", "DS1TRBAL": "b'C\\x12'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xa9\\x00\\x0b\\x00\\xaa\\x00\\t\\x00\\x0e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$DOC": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " This dataset contains several utilities and system exits used at the\n University of Missouri Hospital and Clinics.\n\n The mods in this dataset have been used successfully and to the\n best of our knowledge they are operational, however, no warranty\n is made as to the accuracy of these programs or related material\n and no responsibility is assumed for any problems caused directly\n or indirectly by the use of these mods.  It is the users responsibility\n to evaluate the applicability of this material to their own\n installation.\n\n I would welcome any questions, suggestions, or comments you might\n have regarding this material.  Should you run into problems either\n installing or running these mods, give me a call or drop me a line:\n\n                 Bill Warriner\n                 Information Services  DCO 17.00\n                 University of Missouri Hospital and Clinics\n                 1400 Rock Quarry Road\n                 Columbia,\n                 Missouri  65212\n\n                 phone: (314) 882-3773\n\n For the modifications for which SMP/E USERMODS are supplied, these\n mods can be installed by performing a RECEIVE and APPLY for the\n appropriate USERMODS (this will cause an assembly of the modules).\n DD statement requirements are as follows:\n    DDname   Library description\n    -------- -------------------\n    SOURCE   FB-80 byte records.  Target source library (should NOT\n             be this library).\n    ASOURCE  FB-80 byte records.  Distribution source library\n             (not needed unless USERMOD is ACCEPTed).\n    SYSMODS  Load module library.  Distribution library for USERMOD\n             modules.\n    LINKLIB, LPALIB, etc. - standard IBM usage.\n    CBTLIB   This library.  It is used as a TXLIB, and should also be\n             included in the SYSLIB DD statement for the assemblies.\n\n If you prefer to perform your own assemblies, be sure to include\n this library and SYS1.AMODGEN in your assembler SYSLIB DD statement.\n Assembler H should be used (though some modules may assemble with\n assembler F).\n\n The source shown here is \"dual-language,\" i.e., it may assemble\n differently for XA and non-XA macro libraries.  If you wish an\n object-compatible output, you should assemble it using 370 macro\n libraries or insert the following macro at the start of each module:\n      SPLEVEL SET=1\n\n These modules require APAR OZ61611 to assemble correctly using MVS/370\n macro libraries.  If you do not have this APAR you should provide your\n own version of the SPLEVEL macro to set assembler global SETC &SYSSPLV\n to \"1\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$INDEX": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " The following utilities are included in this dataset:\n\n           ***** DASD ALLOCATION/RENAME CONTROL *****\n\n   HCCDADSM - exit to restrict dasd dataset allocations by dsname,\n              volume, and user RACF authority.\n   IGGPRE00 - dadsm exit to conditionally link to HCCDADSM only if\n              it is present.\n   INIDADSM - program to process parameters and setup HCCDADSM\n              control block (DADSMBLK)\n   INITNCT  - program to build user cvt (we call this control block\n              the network control table or NCT) and place its address\n              in the cvtuser field.  This control block is used as\n              the anchor for the DADSMBLK above.\n              *NOTE* This program must run APF-AUTHORIZED.\n   IPLDATE  - TSO cp to extract and format the last IPL date and time\n              from the NCT (since the NCT is created fairly late\n              in the IPL, this is a better approximation of the\n              actual \"system available\" date and time than that\n              in the SMCA).\n   DADSMMOD - TSO cp to allow authorized users to temporarily modify\n              dadsm protection attributes in DADSMBLK.\n              *NOTE* This must run as an APF-AUTHORIZED TSO CP.\n   @DADSMMD - TSO help for DADSMMOD command.\n   @INIDASD - sample initialization parameters for INIDADSM above.\n   @DADSM   - sample JCL for DADSM started task to set up DADSMBLK.\n   @INITSYS - sample JCL for INITSYS started task to set up NCT.\n   @NCTDOC  - general comments about the NCT, when/how it is created,\n              etc.\n\n                   ***** RETURN CODE CHECKER *****\n\n   HCCRCCK  - program to force an abend on a bad return code, allowing\n              conditional DISP to be taken for data sets.\n              *NOTE* This program must run APF-AUTHORIZED.\n   ATTCHATH - ATTACH/REAUTH subroutine used by HCCRCCK.\n   @HCCRCCK - sample JCL for executing the HCCRCCK program.\n\n              ***** JES2 CHECKPOINT PERFORMANCE MONITOR ****\n\n   HJUX2530 - sample JES exit 253 to cut SMF records for JES2\n              checkpoint performance monitoring.\n   TSJESSMF - PL/1 program to reduce and analyze SMF records\n              produced by HJUX2530 above.\n   PDUMP    - Subroutine for TSJESSMF (PL/1 data area formatted dump)\n   @JESSMF  - sample JCL to execute the TSJESSMF program.\n   @JESPARM - sample JES2 initialization parameters for HJUX2530.\n   @JESCKPT - various stuff about JES2 checkpoint processing\n\n              ***** JCL PRESCAN AND REPLACEMENT ****\n\n   IEFUJV   - SMF exit to scan and conditionally replace certain\n              symbolic parameters in JCL prior to conversion\n              (e.g., host name, day of week, date, etc. can be\n              placed in appropriate places in your JCL prior to\n              conversion).\n   @IEFUJV  - instructions for using iefujv module as shipped.\n\n              ***** VARIOUS PL/1 STUFF ****\n\n   PLIARRV  - Macro to generate PL/1 standard entry point to assembly\n              language subroutines.\n   PLIRETN  - Macro to generate PL/1 standard return sequence for\n              assembly language subroutines.\n   DSAD     - Macro to generate a DSECT describing the PL/1 dynamic\n              storage area (DSA).\n   TRIM     - Assembly language subroutine to chop leading and trailing\n              blanks from a character string.\n   FINDCHR  - Assembly language subroutine to locate the first character\n              in a string matching any character in an index string.\n\n              ***** SMP/E SUPPORT FOR ABOVE FUNCTIONS ****\n\n   MDL0101  - SMP/E USERMOD to install HCCDADSM/IGGPRE00 into your\n              (MVS/SP 1.3.6) system.\n   MDL0103  - SMP/E USERMOD to install HCCDADSM/IGGPRE00 into your\n              (MVS/SP 2.2) system.\n   MJL1401  - SMP/E USERMOD to install exit points for exit 253 into\n              your JES2 (1.3.6) HASPCKPT module.\n   MJL1501  - SMP/E USERMOD to add knowledge of HJUX2530 (exit 253)\n              to your JES2 (1.3.6) system.\n   MSL0101  - SMP/E USERMOD to add knowledge of IEFUJV into your\n              MVS (1.3.6) system.\n   MSL0103  - SMP/E USERMOD to add knowledge of IEFUJV into your\n              MVS (2.2) system.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$COPYRT": {"ttr": 521, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " This material is copyright (c) 1986, 1987, 1988 by the Curators of\n the University of Missouri, a public corporation.\n\n Permission is granted to use this material in your installation\n without charge.  Permission is not granted to license, sell, or\n otherwise distribute any part or all of this material for profit.\n This notice must accompany all copies of this material.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@DADSM": {"ttr": 523, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//* TECHNICAL SERVICES                                    01/22/87  WJW\n//INIDADSM PROC CLASS='D',M=00\n//*\n//DADSM   EXEC PGM=INIDADSM\n//SYSUDUMP DD  SYSOUT=&CLASS\n//IEFPARM  DD  DDNAME=IEFRDER\n//IEFRDER  DD  DSN=SYS1.PARMLIB(DADSMP&M),DISP=SHR\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@DADSMMD": {"ttr": 525, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": ")F FUNCTION -\n   The DADSMMOD command provides authorized TSO users access to DASD\n   restriction parameters.\n)X SYNTAX -\n   DADSMMOD function\n            VOLUMES(old-volume-list) NEWVOLUMES(new-volume-list)\n            MIGVOL/NOMIGVOL UIDCK/NOUIDCK GLOBALCK/NOGLOBALCK\n            TEMPDS/NOTEMPDS\n\n   REQUIRED - PROTECT, NOPROTECT, HSMPROTECT, NOHSMPROTECT, or ZAPVOL.\n              VOLUMES is required if ZAPVOL is specified.\n              At least one of NEWVOLUMES, MIGVOL, NOMIGVOL, UIDCK,\n              NOUIDCK, GLOBALCK, NOGLOBALCK, TEMPDS, or NOTEMPDS\n              is required if ZAPVOL is specified.\n\n   NOTE:      VOLUMES, NEWVOLUMES, MIGVOL, NOMIGVOL, UIDCK, NOUIDCK,\n              GLOBALCK, NOGLOBALCK, TEMPDS, and NOTEMPDS are valid\n              only if ZAPVOL is specified; they will be ignored\n              otherwise.\n\n              In addition to the normal TSO short forms, the following\n              abbreviations are recognized:\n                 VOLUMES      - VOLSERS\n                 NEWVOLUMES   - NVOLUMES, NVOLSERS, NV\n                 NOMIGVOL     - NM\n                 NOUIDCK      - NU, NORACHECK, NORACF, NR\n                 UIDCK        - RACHECK, RACF\n                 NOGLOBALCK   - NG\n                 NOTEMPDS     - NT\n)O OPERANDS -\n)P         \"function\" - Specify the desired function to be\n            performed.  Value may be any one of the following:\n  PROTECT - Turn on DADSM protection for all volumes as defined in\n            the existing parms.  This is a reversal of the NOPROTECT\n            function.\n  NOPROTECT - turn off DADSM protection for all volumes without\n            otherwise changing the existing volume protection list.\n            In addition to the normal TSO abbreviations, any valid\n            abbreviation of any of the following may be used:\n            NPROTECT\n  HSMPROTECT - Disallow HSM access to any RACF-protected volume, and\n            enforce prefix restrictions to HSM, on all volumes not\n            defined as HSM migration volumes.  This is a reversal\n            of the NOHSMPROTECT function.\n            In addition to the normal TSO abbreviations, any valid\n            abbreviation of any of the following may be used:\n            HPROTECT\n  NOHSMPROTECT - Allow HSM to perform any function on any volume,\n            whether or not that volume is defined as a MIGVOL.\n            In addition to the normal TSO abbreviations, any valid\n            abbreviation of any of the following may be used:\n            NHSMPROTECT, NOHPROTECT, NHPROTECT\n  DEBUG   - Turn debug mode on for all DADSM functions.\n  NODEBUG - Turn debug mode off for all DADSM functions.\n            In addition to the normal TSO abbreviations, any valid\n            abbreviation of any of the following may be used:\n            NDEBUG\n  ZAPVOL  - Change the attributes of one or a list of volume serial\n            numbers.\n))VOLUMES(old-volser-list) - Supplies a list of volume serials whose\n            protection attributes are to be ZAPped.\n  old-volser-list - a list of volume serial numbers, separated by\n            commas, whose volume protection attributes are to be\n            ZAPped.  Each volume serial in the list must exist.\n))NEWVOLUMES(new-volser-list) - Supplies a list of new volume serial\n            numbers.  Each volume serial number in the VOLUMES list\n            will be changed to the number in the corresponding\n            position in the NEWVOLUMES list.  Entries which are not\n            to be renamed should be signified by an \"*\" in the\n            corresponding position in the NEWVOLUMES list.\n  new-volser-list - the list of new volume serial numbers and/or\n            asterisks (\"*\").  This list must have exactly the same\n            number of entries as the VOLUMES list.\n))MIGVOL  - Specifies that all volumes in the VOLUMES list should have\n            the MIGVOL attribute set in their volume protection profile.\n))NOMIGVOL - Specifies that all volumes in the VOLUMES list should have\n            the MIGVOL attribute removed from their volume protection\n            profile.\n))UIDCK   - Specifies that all volumes in the VOLUMES list should have\n            the \"RACF-check\" attribute turned on in their volume\n            protection profile.\n))NOUIDCK - Specifies that all volumes in the VOLUMES list should have\n            the \"RACF-check\" attribute turned off in their volume\n            protection profile.\n))GLOBALCK - Specifies that all volumes in the VOLUMES list should have\n            the \"also check GLOBAL restrictions\" attribute turned on\n            in their volume protection profile.\n))NOGLOBALCK - Specifies that all volumes in the VOLUMES list should\n            have the \"also check GLOBAL restrictions\" attribute turned\n            off in their volume protection profile.\n))TEMPDS  - Specifies that all volumes in the VOLUMES list should have\n            the \"allow temporary dataset allocations\" attribute turned\n            on in their volume protection profile.\n))NOTEMPDS - Specifies that all volumes in the VOLUMES list should have\n            the \"allow temporary dataset allocations\" attribute turned\n            off in their volume protection profile.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@HCCRCCK": {"ttr": 528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//HCCRCCK JOB 1\n//STEP1   EXEC PGM=HCCRCCK,REGION=4096K,\n//             PARM='PGM=SORT,MAXCC=0/SIZE=MAX'\n//SORTIN   DD  DSN=SORT.INPUT.FILE,DISP=OLD\n//SORTOUT  DD  DSN=SORT.OUTPUT.FILE,DISP=(NEW,CATLG,DELETE),\n//             UNIT=SYSDA,SPACE=(CYL,(50,10),RLSE),DCB=*.SORTIN\n//SORTWK01 DD  UNIT=SYSDA,SPACE=(CYL,(50,1))\n//SORTWK02 DD  UNIT=SYSDA,SPACE=(CYL,(50,1))\n//SORTWK03 DD  UNIT=SYSDA,SPACE=(CYL,(50,1))\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@IEFUJV": {"ttr": 530, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " The IEFUJV exit supplied will perform symbolic substitution in JCL\n prior to conversion.  Each non-comment JCL card image will be scanned\n for special tokens, and the tokens will be replaced with values as\n follows:\n    TOKEN      VALUE\n    -----      -----\n    ?SYSXAMODE \"XA\" if system is in XA mode, \"\" (null string) otherwise\n    ?SYSSPLV   \"1\" if system is 370 mode, \"2\" if xa mode\n    ?SYSSMF    4-character system SMF id (from SMCA)\n    ?SYSID     last character of system SMF id\n    ?SYSTSO    translation of \"?SYSID\" (A->H, B->I, C->J, other->#)\n    ?SYSZONE   translation of \"?SYSID\" (A->B, B->B, C->A, other->#)\n    ?SYSSUBA   Host VTAM subarea (2-digit number with leading 0's)\n    ?SYSYEAR   Current year (YYYY)\n    ?SYSDATE   Current date (YYMMDD)\n    ?SYSYY     Current year (YY)\n    ?SYSMM     Current month (MM)\n    ?SYSDD     Current day of the month (DD)\n    ?SYSJDATE  Current date in julian (YYDDD)\n    ?SYSWD     Current day of week (1-7, 1=Sunday)\n    ?SYSWKDY   Current day of week (SUN, MON, TUE, WED, THU, or FRI)\n    ?SYSMONTH  Current month (JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG,\n               SEP, OCT, NOV, or DEC)\n\n These tokens can be used either in instream JCL or in (instream or\n library) PROCedures, however, if a token is included as a value or\n part of a value for symbolic substitution in an EXEC PROC statement,\n the value MUST be enclosed in tic marks, e.g.:\n     //  EXEC  MYPROC,SYS=?SYSSMF      is invalid, but\n     //  EXEC  MYPROC,SYS='?SYSSMF'    will work.\n\n Two values are used to determine the tokens to be substituted:\n assembly global &KWDCHAR is set to the initial character, which\n must be the same for all tokens.  I chose \"?\" as it is not normally\n encountered in JCL.  The remainder of the tokens are defined at\n label KWDTAB by means of the KEYWORD macro.  The syntax of this\n macro is:\n        KEYWORD  token,label,dsect\n where \"token\" is the complete token, \"label\" is the address of a\n data area which contains the replacement value, and \"dsect\" is the\n name of the control block which contains data area \"label.\"\n The table is terminated by the following (which is required):\n        KEYWORD  END-OF-TABLE\n\n If you wish to change the list of tokens to be replaced, you should:\n   1) Add any required data fields to the SYSAREA DSECT.\n   2) Add logic to initialize these data fields following label VTAM020.\n   3) Add/remove any required entries in the table following label\n      KWDTAB.  This table is in order by token length, longest first.\n      This order is necessary if any token is a substring of any\n      other token (e.g., \"?ABC\" and \"?ABCDE\") - if the shorter token\n      precedes the longer in the table, the longer will never be\n      found.  Be sure the keyword table is terminated with a\n      KEYWORD END-OF-TABLE macro call.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@INIDASD": {"ttr": 532, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " /********************************************************************/\n /*  MEMBER:  DADSMP00  SYSSHR.PARMLIB  ALL MACHINES                 */\n /*                                                                  */\n /*  FUNCTION:  DEFINES RESTRICTIONS BY VOLUME FOR DASD ALLOCATIONS  */\n /*                                                                  */\n /********************************************************************/\n  PROTECT HCC820,UIDCK   /* HC4B SYSRES */\n  PROTECT HCC821,UIDCK   /* HC4B MASTER CAT */\n  PROTECT HCC822,UIDCK   /* HC4B PAGING & SMP/E */\n  PROTECT HCC823,OVERRIDE(#*)\n  PROTECT HCC824,UIDCK   /* HC4B PAGING */\n  PROTECT HCC825,UIDCK   /* ARTS FILES */\n  PROTECT HCC830,UIDCK   /* HC4A SYSRES */\n  PROTECT HCC831,UIDCK   /* HC4A MASTER CAT */\n  PROTECT HCC832,UIDCK   /* HC4A PAGING */\n  PROTECT HCC833,UIDCK   /* DLIBS, ALTRES, JES CHECKPOINT */\n  PROTECT HCC841,MIGVOL,UIDCK,NOGLOBALCK\n  PROTECT HCC842,PREFIX(PFAS,PFPS,CICSSHR,HSMSHR),NOGLOBALCK\n  PROTECT HCC843,PREFIX(PFAS,PFPS,CICSSHR,HSMSHR),NOGLOBALCK\n  PROTECT HCC844,PREFIX(PFAS,PFPS,CICSSHR,HSMSHR),NOGLOBALCK\n  PROTECT HCC845,OVERRIDE(HIR*,HIF*,HIM*,PIMB,PIMP,TPMB)\n  PROTECT HCC847,PREFIX(SSDB,HSMSHR),NOGLOBALCK\n  PROTECT HCC850,OVERRIDE(TFPS,TFAS)\n  PROTECT HCC851,PREFIX(SSDB,HSMSHR),NOGLOBALCK\n  PROTECT HCC852,PREFIX(PFAS,PFPS,CICSSHR,HSMSHR),NOGLOBALCK\n  PROTECT HCC854,PREFIX(PFAS,PFPS,CICSSHR,HSMSHR),NOGLOBALCK\n  PROTECT HCC855,OVERRIDE(TFPS)\n  PROTECT HCC857,UIDCK,PREFIX(HSMSHR,SYSSHR,PCSSHR,HCTSSHR,ADRSHR,\n          ADRA),NOGLOBALCK\n  PROTECT HCC860,UIDCK\n  PROTECT HCC862,UIDCK\n  PROTECT HCC870,UIDCK\n  PROTECT HCC872,OVERRIDE(#*)\n  PROTECT HCC874,UIDCK\n  PROTECT HCC875,UIDCK\n  PROTECT HCC876,UIDCK\n  PROTECT HCC877,UIDCK\n  PROTECT GLOBAL,NOPREFIX(#*,$*,PCS,PFPS,HIR*,HIF*,HIM*,PIMB,PIMP,TFPS,\n          TFAS,TPMB)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@INITSYS": {"ttr": 534, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//* TECHNICAL SERVICES                                    10/30/86  WJW\n//INITSYS PROC CLASS='D',SID='0',INIT=NCT\n//*\n//NCT     EXEC PGM=INIT&INIT,PARM='&SID'\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@JESCKPT": {"ttr": 536, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  JES2 V 1.3.7 is (one of) the JES's run at our installation.\n  We run a 2-system shared spool, with very high TSO/batch activity\n  (>100 remote printers!) and, even with only 2 systems sharing the\n  spool, we found checkpoint contention between them caused noticeable\n  performance problems.\n\n  Since that release of JES2 does not have any good way to measure\n  checkpoint performance, we resolved to create one.  Very simple\n  measurements were found to suffice.  We measure three intervals:\n      - the interval between the request for the checkpoint lock\n        and its being obtained (WAIT time),\n      - the interval between the obtaining of the checkpoint lock\n        and its being released (HOLD time), and\n      - the interval between the release of the checkpoint lock\n        and the next request for it (DORMANCY time).\n\n  These intervals are measured by cutting an SMF record at these\n  three points in each checkpoint cycle.  Because of the critical\n  nature of this path in performance, modules were kept to a\n  minimum in size.  After tuning, the usermod was removed but no\n  appreciable difference was found in performance.  We currently\n  run production with this usermod on our system.\n\n  The JES2 parameters that affect checkpoint processing are specified\n  on the MASDEF initialization statement.  They are:\n      HOLD - even if all outstanding checkpoints have been processed,\n         the checkpoint lock will not be released until this time limit\n         has expired.  This is intended to reduce having an excessive\n         number of very short checkpoint cycles.  The value you specify\n         is in 1/100 seconds.  NOTE that the default of 999999.99\n         seconds will LOCK OUT all other members of the complex for\n         about 11 1/2 DAYS.\n      DORMANCY (first positional operand) - after releasing control\n         of the queues, this system will not request it again until\n         this time limit has expired.  This is intended to allow other\n         systems in the MAS complex access to the queues.  The value\n         given is in 1/100 seconds.\n      DORMANCY (second positional operand) - even if there is no work\n         to be checkpointed, this system will start a new checkpoint\n         cycle when this time limit has expired.  This is intended to\n         allow a lightly loaded system to periodically examine the\n         queues to determine if any eligible work has been entered\n         by another system in the MAS complex.  Since this parameter\n         has little effect unless you have a very lightly loaded\n         system, I will not discuss it further, and future references\n         to \"DORMANCY\" will refer to the first positional operand.\n\n  Notice that there is no installation control on the maximum hold\n  time:  once the checkpoint processor has started running, it will\n  continue until ALL changed blocks are checkpointed (however long\n  that may take).  Thus, if there is a significant delay in obtaining\n  access to the queues, work may \"pile up\" causing an excessively\n  long hold time (and thus causing other systems in the complex to have\n  significant delays in obtaining access to the queues, etc., etc.,\n  etc.)  HOLD and DORMANCY interact with each other, both within and\n  across systems sharing JES queues!\n\n  Because of the interaction of these controls with each other and\n  with similar controls on other systems in the complex, a \"cut and\n  try\" approach was used.  This need not be excessively time-consuming\n  as both HOLD and DORMANCY can be changed via the $T MASDEF operator\n  command (if you are running an earlier release of JES2, the Mellon\n  Bank JES modifications on the SHARE tape allow a similar command\n  to be issued for the equivalent parameters $MINHOLD and $MINDORM).\n  It took us about a week to tune our checkpoint to \"best\" performance,\n  but major performance gains were obtained in less than 2 days.  With\n  more systems in the complex, this process might take longer.\n\n  As shipped, the TSJESSMF program will produce a graph of WAIT, HOLD,\n  and DORMANCY times showing minimum, maximum, and average values\n  over 15 minute intervals (15 minutes was chosen for no particularly\n  essential reason).  It can also provide the same data in tabular\n  form (along with the number of cycles represented) and a detail\n  report of each SMF record processed.  To suppress a given report\n  or graph, simply omit the corresponding DD statement (see comments\n  at the start of the program).  If the input data contains records\n  from more than one JES and/or more than one SMF SYSID, an input\n  parameter should be specified, e.g.:\n      //  EXEC  PGM=TSJESSMF,PARM=MVSAJESA\n  would select only those records from SMF system MVSA and JES2\n  system JESA.  If this is not done, the first SMF/JES2 combination\n  encountered in the input data will be used.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@JESPARM": {"ttr": 539, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*  THE FOLLOWING TWO STATEMENTS SHOULD BE INCLUDED IN YOUR          */\n/*  JES2 INITIALIZATION PARAMETER DECK:                              */\nEXIT253   ENABLE,            /* HASPCKPT MONITOR                     */\n          ROUTINE=EXIT253A,  /* ENTRY POINT IS EXIT253A              */\n          TRACE=NO           /*                                      */\nLOAD=HJUX2530                /* LOAD MODULE FOR EXIT253A ROUTINE     */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@JESSMF": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//@JESSMF  JOB  1\n//*\n//* PROGRAM TSJESSMF PRINTS CHECKPOINT PERFORMANCE STATISTICS FROM\n//* SMF DATA.  IF ANY OF THE DDNAMES SUMMARY, DETAIL, WAITTIME,\n//* HOLDTIME, OR DORMTIME ARE NOT PRESENT NO ERROR IS POSTED,\n//* THE CORRESPONDING REPORT OR PLOT IS NOT GENERATED.\n//*\n//SYSA    EXEC PGM=TSJESSMF,REGION=1024K\n//SYSPRINT  DD SYSOUT=*\n//SUMMARY   DD SYSOUT=A\n//*DETAIL    DD SYSOUT=A         IF NOT PRESENT NO DETAIL RECS PRINTED\n//SMFIN     DD DSN=SYSA.SMFDUMPD(+0),DISP=OLD\n//WAITTIME  DD SYSOUT=A\n//HOLDTIME  DD SYSOUT=A\n//DORMTIME  DD SYSOUT=A\n//*\n//SYSB    EXEC PGM=TSJESSMF,REGION=1024K\n//SYSPRINT  DD SYSOUT=*\n//SUMMARY   DD SYSOUT=A\n//*DETAIL    DD SYSOUT=A         IF NOT PRESENT NO DETAIL RECS PRINTED\n//SMFIN     DD DSN=SYSB.SMFDUMPD(+0),DISP=OLD\n//WAITTIME  DD SYSOUT=A\n//HOLDTIME  DD SYSOUT=A\n//DORMTIME  DD SYSOUT=A\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@NCTDOC": {"ttr": 771, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  The NCT or Network Control Table was originally (many, many years\n  ago) set up to support our security system and some TCAM applications.\n  Since that time we have turned to RACF instead of our home-grown\n  security system, and TCAM is no longer supported at our installation.\n  The NCT, however, is still utilized by several of our system mods,\n  for example, our TSO logon preprompt exit IKJEFLD, DADSM exit\n  IGGPRE00, and by some other system functions.  It is a handy place\n  to anchor various common-area control blocks, and has also allowed\n  us to dynamically change certain exit functions.  For example, by\n  creating only a \"stub\" with the name ICHPWX01 (which \"stub\" issues\n  a BALR or BASSM to an address contained in the NCT) the RACF password\n  exit can be dynamically changed without an IPL by 1) placing a new\n  copy of the exit in the common area then 2) refreshing the address in\n  the NCT.  We have successfully used this technique with several\n  exits (IKJEFLD, IGGPRE00, ICHPWX01, etc.)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ATTCHATH": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "ATCH     TITLE 'ATTCHATH - ATTACH-REAUTHORIZE FUNCTION           '\nATTCHATH CSECT\n         GBLC  &WORKSP,&SYSSPLV\n         SPLEVEL TEST\n&WORKSP  SETC  '0'        WORK AREA SUBPOOL\n***********************************************************************\n* ATTCHATH - ATTACH/REAUTH SUBROUTINE                                 *\n*                                                                     *\n*  PARM LIST:                                                         *\n*         R1 SHOULD POINT TO A LIST OF ADDRESSES, AS FOLLOWS:         *\n*                                                                     *\n*         +00 = A(8-CHARACTER ENTRY POINT NAME TO BE ATTACHED)        *\n*         +04 = A(PARM LIST FOR ATTACHED ROUTINE OR 0)                *\n*         +08 = A(OPEN DCB FOR ATTACH OR 0 FOR STANDARD SEARCH)       *\n*         +0C = A(OPEN DCB FOR TASKLIB OR 0 FOR PROPOGATION)          *\n*                                                                     *\n*         ONLY THE FIRST OF THESE IS REQUIRED.  THE END OF THE        *\n*         PARM LIST FOR THIS ROUTINE SHOULD BE INDICATED BY SETTING   *\n*         THE HIGH-ORDER BIT OF THE LAST ENTRY PASSED.                *\n*         YOU WILL NOT RECEIVE CONTROL BACK UNTIL THE ASSOCIATED      *\n*         TASK HAS COMPLETED.                                         *\n*                                                                     *\n*         ALL PARMS MUST RESIDE IN 24-BIT ADDRESSABLE STORAGE.        *\n*                                                                     *\n*  ATTRIBUTES:  REENTRANT, AMODE=ANY, RMODE=24, AC=1                  *\n*                                                                     *\n*   RETURN CODES:                                                     *\n*         R15 WILL CONTAIN THE RETURN CODE FROM THE ATTACHED TASK OR  *\n*             THE RETURN CODE FOR ATTACH IF ATTACH WAS UNSUCCESSFUL.  *\n*         R0  WILL CONTAIN 0 IF ATTACH RETURNED A 0 RETURN CODE       *\n*             OR THE SAME VALUE AS R15 IF ATTACH WAS UNSUCCESSFUL.    *\n*                                                                     *\n*             IF THE ATTACHED TASK ABENDS WITH A SYSTEM CODE OR A     *\n*             DUMP OPTION, THE SAME ABEND WILL BE RE-ISSUED FOR THE   *\n*             CURRENT TASK.  IF THE ATTACHED TASK RETURNS A RETURN    *\n*             CODE OF 1000 OR GREATER IT WILL BE ASSUMED TO BE A      *\n*             USER ABEND CODE AND WILL BE RE-ISSUED.  USER ABENDS     *\n*             WILL BE RE-ISSUED ONLY IF THE DUMP OPTION IS SPECIFIED  *\n*             OR THE ABEND CODE IS 1000 OR GREATER.                   *\n*                                                                     *\n***********************************************************************\n         EJECT\nATTCHATH CSECT ,               CONTINUE CSECT\n         CONNECT WORKSIZE,WRKDSECT,BASE=R12,PARM=R2,CLEAR=YES,         X\n               AMODE=ANY,LOC=BELOW,SP=&WORKSP,COPYRT=1987\n         USING PSA,R0\n         L     R4,PSATOLD              GET OUR TCB ADDRESS\n         USING TCB,R4\n         L     R3,FLCCVT               GET CVT ADDRESS\n         USING CVT,R3\n         L     R6,TCBJSCB              GET THE JSCB ADDRESS\n         USING IEZJSCB,R6\n         MODESET MF=(E,SUPVKEY0)       GET IN SUPERVISOR STATE\n         SETAMODE 31\n         MVC   WRKSVOPT,JSCBOPTS       SAVE THE JSCBOPTS FLAG\n         NI    WRKSVOPT,JSCBAUTH       SAVE ONLY APF AUTH FLAG\n         NI    JSCBOPTS,X'FF'-JSCBAUTH RESET APF AUTH FLAG IN JSCB\n         SETAMODE 24\n         MODESET MF=(E,SUPVKEY8)\n         SR    R9,R9\n         SR    R10,R10\n         L     R8,0(,R2)               GET ENTRY POINT NAME ADDRESS\n         LTR   R8,R8                   IS THERE A PARM FOR THE TASK?\n         BM    PARMDONE\n         MVC   WRKPARM,4(R2)           SAVE PARM LIST ADDRESS\n         NI    WRKPARM,X'7F'           CLEAR HI ORDER BIT\n         TM    4(R2),X'80'             IS THERE A SEARCH DCB?\n         BNZ   PARMDONE\n         ICM   R9,7,9(R2)              GET SEARCH DCB ADDRESS\n         TM    8(R2),X'80'\n         BNZ   PARMDONE\n         ICM   R10,7,13(R2)            GET TASKLIB DCB ADDRESS\nPARMDONE DS    0H\n         LA    R7,WRKECB               ECB FOR ATTACHED TASK\n         MVC   WRKATTPM(LENATTPM),DMYATTPM   COPY IN DUMMY PARM LIST\n         L     R1,WRKPARM              GET PARM LIST ADDRESS\n         STM   R14,R12,12(R13)         SAVE REGISTERS JUST IN CASE\n         ATTACH EPLOC=(R8),DCB=(R9),ECB=(R7),TASKLIB=(R10),            X\n               SF=(E,WRKATTPM)\n         ST    R15,WRKATTRC\n         ST    R1,WRKTCB\n         NI    WRKTCB,X'7F'            INSURE 0 HI ORDER BIT\n         LTR   R15,R15                 WAS THE ATTACH SUCCESSFUL?\n         BZ    TASKWAIT\n         ST    R15,WRKECB              SAVE THE RETURN CODE HERE, TOO\n         B     ATTDONE\nTASKWAIT DS    0H\n         STM   R14,R12,12(R13)         SAVE REGISTERS JUST IN CASE\n         WAIT  ECB=WRKECB              WAIT FOR SUBTASK COMPLETION\n         NI    WRKECB,X'3F'            ZERO OUT WAIT AND POST BITS\n         L     R4,WRKTCB               GET TCB ADDRESS\n         TM    TCBFLGS1,TCBFA          ABEND ISSUED?\n         BNZ   TASKABND\n         CLC   TCBCMP,=A(1000)         ABEND ISSUED?\n         BL    DETACH                  NO ...\nTASKABND DS    0H\n         L     R1,TCBCMP               SAVE SUBTASK ABEND CODE\n         AIF   ('&SYSSPLV' EQ '1').NOTXA3\n         L     R15,TCBARC              SAVE SUBTASK ABEND REASON CODE\n         AGO   .XA3DONE\n.NOTXA3  SR    R15,R15                 WE HAVE NO ABEND REASON CODE\n.XA3DONE SVC   13                      THEN RE-ISSUE ABEND\nDETACH   DS    0H\n         LA    R1,WRKTCB\n         DETACH (1)\nATTDONE  DS    0H\n         MODESET  MF=(E,SUPVKEY0)\n         SETAMODE 31\n         OC    JSCBOPTS,WRKSVOPT       RESET JSCBAUTH BIT\n         SETAMODE 24\n         MODESET  MF=(E,PROBMODE)\n         L     R2,WRKATTRC             GET ATTACH RETURN CODE\n         L     R7,WRKECB               GET TASK RETURN CODE\n         RELEASE  WORKSIZE,RC=(R7),SP=&WORKSP,R0=(R2),RI=BR\n         EJECT\nDMYATTPM ATTACH EPLOC=0,SZERO=NO,JSTCB=NO,SM=PROB,SVAREA=YES,          X\n               KEY=PROP,DISP=YES,RSAPF=YES,SF=L\nSUPVKEY0 MODESET KEY=ZERO,MODE=SUP,MF=L\nSUPVKEY8 MODESET KEY=NZERO,MODE=SUP,MF=L\nPROBMODE MODESET KEY=NZERO,MODE=PROB,MF=L\n         LTORG\n         EJECT\nWRKDSECT DSECT\n         DS    18F\nWRKATTRC DS    F                       RETURN CODE FROM ATTACH\nWRKATTPM ATTACH EPLOC=0,SZERO=NO,JSTCB=NO,SM=PROB,SVAREA=YES,          X\n               KEY=PROP,DISP=YES,RSAPF=YES,SF=L\nLENATTPM EQU   *-WRKATTPM\nWRKPARM  DS    A                       PARM ADDRESS FOR SUBTASK\nWRKECB   DS    A                       ECB FOR SUBTASK\nWRKTCB   DS    A                       TCB ADDRESS FOR SUBTASK\nWRKSVOPT DS    XL1                     SAVE THE JSCBAUTH FLAG\n         DS    0D\nWORKSIZE EQU   *-WRKDSECT\n         EJECT\n         EQUREGS\n         PRINT NOGEN\n         IHAPSA DSECT=YES\n         CVT   DSECT=YES\n         IEZJSCB\n         IKJTCB DSECT=YES\n         PRINT GEN\n         END   ATTCHATH\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONNECT": {"ttr": 777, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    CONNECT  &L,&D,&CPPL=NO,&BASE=,&PARM=,&CLEAR=,&LI=LA,&R0=,    W\n               &MODESET=,&SAVE=YES,&ID=,&ENTRY=,&ENTREG=15,            W\n               &SP=0,&MODSET=YES,                              01/06/78W\n               &COPYRT=,&EQUREGS=NO,                           11/21/86W\n               &LOC=BELOW,                                     12/08/86W\n               &AMODE=,&RMODE=,&MODSAVE=,                      12/08/86W\n               &REGSAVE=(14,12)                                04/12/77\n.*\n.*       THIS MACRO GENERATES CSECT START-UP LINKAGE.\n.*\n.*                                                             01/06/78\n.*  CHANGES:                                                   01/06/78\n.*                                                             01/06/78\n.*       01/06/78 - ADD &SP (SUBPOOL SUPPORT)                  01/06/78\n.*       11/21/86 - ADD &COPYRT (COPYRIGHT DATE) SUPPORT       11/21/86\n.*       12/08/86 - ADD &LOC (LOCATION) SUPPORT FOR XA         12/08/86\n.*                  ALSO ADDED AMODE/RMODE MODE SWITCH SUPPORT 01/06/78\n.*       12/11/87 - ADDED SUPPORT FOR \"COPYRT=NO\"              12/11/87\n.*       03/09/88 - ADDED DUAL XA/NONXA SUPPORT                03/09/88\n.*                                                             01/06/78\n         GBLC  &SYSSPLV                                        03/09/88\n         LCLA  &I,&J,&K,&N,&R                                  04/12/77\n         LCLC  &CNAME,&XRNAME,&LITLBL,&MODSAV                  04/12/77\n         LCLC  &AMODLBL,&AMOD1,&RMOD1                          01/06/78\n         LCLC  &CPYYR,&PSTCNS                                  11/21/86\n&LITLBL  SETC  'LIT&SYSNDX'\n&PSTCNS  SETC  'PST&SYSNDX'\n         SPLEVEL TEST\n         AIF   ('&SYSSPLV' EQ '1').NOMOD\n&AMOD1   SETC  '&AMODE'\n&RMOD1   SETC  '&RMODE'\n         AIF   ('&AMODE' EQ '').RMODQQ\n         AIF   ('&AMODE' EQ '24').RMOD24\n         AIF   ('&AMODE' EQ '31').RMODANY\n         AIF   ('&AMODE' EQ 'ANY').RMOD24\n         MNOTE 12,'** INVALID AMODE, &AMODE, SPECIFIED **'\n         MEXIT\n.RMODQQ  ANOP\n         AIF   ('&RMODE' EQ '').NOMOD\n         AIF   ('&RMODE' EQ 'ANY').AMOD31\n         AIF   ('&RMODE' EQ '24').AMOD24\n         MNOTE 12,'** INVALID RMODE, &RMODE, SPECIFIED **'\n         MEXIT\n.AMOD31  ANOP\n&AMOD1   SETC  '31'\n         AGO   .RMODDUN\n.AMOD24  ANOP\n&AMOD1   SETC  '24'\n         AGO   .RMODDUN\n.RMODANY ANOP\n         AIF   ('&RMODE' EQ 'ANY').RMODDUN\n         AIF   ('&RMODE' NE '').RMOD24\n&RMOD1   SETC  'ANY'\n         AGO   .RMODDUN\n.RMOD24  ANOP\n         AIF   ('&RMODE' EQ '24').RMODDUN\n         AIF   ('&RMODE' NE '').RMODERR\n&RMOD1   SETC  '24'\n         AGO   .RMODDUN\n.RMODERR MNOTE 12,'** INVALID RMODE OR AMODE/RMODE COMBINATION **'\n         MNOTE *,'** REQUESTED AMODE=&AMODE, RMODE=&RMODE **'\n         MEXIT\n.NOMOD   ANOP\n&AMOD1   SETC  ''\n&RMOD1   SETC  ''\n.RMODDUN ANOP\n         AIF   ('&COPYRT' EQ '').NOCPYRT                       11/21/86\n         AIF   ('&COPYRT' EQ 'NO').SKIPCPR                     12/11/87\n         AIF   (('&COPYRT'(1,1) EQ ''''(1,1) OR '&COPYRT'(1,1) EQ '(') +\n               AND K'&COPYRT GE 3).TRIMCPY\n&CPYYR   SETC  '&COPYRT'                                       11/21/86\n         AGO   .COPYSET                                        11/21/86\n.TRIMCPY ANOP\n&CPYYR   SETC  '&COPYRT'(2,K'&COPYRT-2)\n.SKIPCPR ANOP                                                  12/11/87\n         AGO   .SETNAME                                        12/11/87\n.NOCPYRT ANOP                                                  11/21/86\n&CPYYR   SETC  '&SYSDATE'(7,2)                                 11/21/86\n&CPYYR   SETC  '19&CPYYR'                                      11/21/86\n.COPYSET ANOP                                                  11/21/86\n.SETNAME ANOP                                                  12/11/87\n&CNAME   SETC  '&SYSECT'\n         AIF   ('&AMOD1' EQ '' AND '&RMOD1' EQ '').NOMOD2\n&CNAME   AMODE &AMOD1\n&CNAME   RMODE &RMOD1\n.NOMOD2  ANOP\n         AIF   (T'&ENTRY EQ 'O').XANOP1\n&CNAME   SETC  '&ENTRY(1)'\n.XANOP1  ANOP\n&N       SETA  N'&BASE\n         AIF   (T'&ID EQ 'O').XIDLEN\n&K       SETA  K'&ID-2\n&K       SETA  ((&K+1)/2)*2\n.XIDLEN  ANOP\n         PUSH  USING\n         USING *,&ENTREG               TEMP ADDRESSABILITY\n&NAME    B     &PSTCNS                  BRANCH AROUND ID       05/24/77\n         DROP  &ENTREG\n         POP   USING\n         DC    AL1(23)                  ID LENGTH\n         DC    CL9'&CNAME'              CSECT NAME\n         DC    CL8'&SYSDATE'            ASSEMBLY DATE\n         DC    CL6' &SYSTIME'           ASSEMBLY TIME\n         AIF   ('&COPYRT' EQ 'NO').SKIPCP2                     12/11/87\n         DC    C'COPYRIGHT (C)&CPYYR. BY THE CURATORS OF THE UNIVERSITY+\n                OF MISSOURI, A PUBLIC CORPORATION'             11/21/86\n.SKIPCP2 ANOP                                                  12/11/87\n         AIF   (T'&ID EQ 'O').XSAVE\n         DC    CL&K&ID\n.XSAVE   ANOP\n&PSTCNS  DS    0H\n         AIF   ('&SAVE' EQ 'NO').XBASECK\n         AIF   (T'&REGSAVE(1) NE 'N').XSAVERR\n         AIF   (&REGSAVE(1) GE 14 OR &REGSAVE(1) LE 2).XSAVE2\n         STM   14,15,12(13)             SAVE ENTRY REGISTERS\n&I       SETA  &REGSAVE(1)*4+20\n         AIF   (N'&REGSAVE NE 2).XSAVE3\n         STM   &REGSAVE(1),&REGSAVE(2),&A.(13)  SAVE REGISTERS\n         AGO   .XBASECK\n.XSAVE3  AIF   (N'&REGSAVE NE 1).XSAVERR\n         ST    &REGSAVE(1),&A.(,13)     SAVE REGISTER\n         AGO   .XBASECK\n.XSAVE2  AIF   (N'&REGSAVE NE 2).XSAVE4\n         STM   14,&REGSAVE(2),12(13)    SAVE REGISTERS\n         AGO   .XBASECK\n.XSAVE4  AIF   (N'&REGSAVE NE 1).XSAVERR\n         STM   14,&REGSAVE(1),12(13)    SAVE REGISTERS\n         AGO   .XBASECK\n.XSAVERR MNOTE 8,'** INVALID REGISTER LIST, &REGSAVE, (14,12) ASSUMED '\n.XSAVE0  ANOP\n         STM   14,12,12(13)             SAVE REGISTERS\n.XBASECK AIF   (&N EQ 0).XCPPL\n         LR    &BASE(1),&ENTREG         INITIALIZE BASE REGISTER\n         USING &CNAME,&BASE(1)\n         AIF   (&N LE 1).XCPPL\n&I       SETA  2\n.XBASE   ANOP\n&J       SETA  &I-1\n         LA    &BASE(&I),2048(&BASE(&J))\n         LA    &BASE(&I),2048(&BASE(&I))\n&K       SETA  &J*4096\n         USING &CNAME+&K,&BASE(&I)\n&I       SETA  &I+1\n         AIF   (&I LE &N).XBASE\n.XCPPL   AIF   ('&CPPL' EQ 'NO').XPARM\n         LR    &CPPL,1                  CPPL ADDRESS\n         USING CPPL,&CPPL\n         AGO   .XMODE\n.XPARM   AIF   (T'&PARM EQ 'O').XREG0\n         LR    &PARM(1),1               SAVE PARAMETER REGISTER\n         AIF   (N'&PARM NE 2).XREG0\n         USING &PARM(2),&PARM(1)        DSECT ADDRESSABILITY\n.XREG0   AIF   (T'&R0 EQ 'O').XMODE\n         LR    &R0,R0\n.XMODE   AIF   (T'&MODESET EQ 'O').XWORK\n         MODESET MF=(E,&MODESET)\n.XWORK   AIF   ('&SAVE' EQ 'NO').AMOD030 QUIT IF SAVE=NO\n         AIF   ('&SAVE' EQ 'YES').XGETM IF SAVE=YES, THEN GETMAIN\n         LA    15,&SAVE                 LOAD UP ADDRESS OF SAVE AREA\n         ST    13,4(15)                 START CHAINING SAVE AREAS\n         ST    15,8(13)                 FINISH CHAINING\n         LR    13,15                    NEW SAVE AREA ADDRESS\n         AGO   .AMOD020                 WE IS ALL THRU......\n.XGETM   AIF   (T'&L EQ 'O').AMOD020\n         &LI   R0,&L\n         AIF   ('&SYSSPLV' EQ '1').NOTXA1                      03/09/88\n         MNOTE *,'       GETMAIN RU,LV=(0),SP=&SP,LOC=&LOC  '\n         GETMAIN RU,LV=(0),SP=&SP,LOC=&LOC                     12/08/86\n         AGO   .XAJOIN1                                        03/09/88\n.NOTXA1  ANOP  ,                                               03/09/88\n         ICM   R0,8,=AL1(&SP)                                  03/09/88\n         MNOTE *,'       GETMAIN R,LV=(0)                   '  03/09/88\n         GETMAIN R,LV=(0)                                      03/09/88\n.XAJOIN1 ANOP  ,                                               03/09/88\n         ST    13,4(1)                  CONNECT SAVEAREAS\n         ST    1,8(13)\n         LR    13,1\n         AIF   (T'&D EQ 'O').XCLEAR\n         USING &D,13\n.XCLEAR  AIF   (T'&CLEAR EQ 'O').AMOD020\n         XC    0(4,13),0(13)\n         LA    R0,8(13)\n         AIF   ('&LI' EQ 'LA').XCLA\n         &LI   1,&L\n         S     1,=F'8'\n         AGO   .XCLB\n.XCLA    LA    1,&L-8\n.XCLB    SLR   14,14\n         SLR   15,15\n         MVCL  R0,14                    ZERO WORKAREA\n.AMOD020 ANOP\n         AIF   ('&SYSSPLV' EQ '1').CKREGS\n         AIF   ('&MODSET' EQ 'NO' OR '&MODSET' EQ 'N').CKREGS\n         AIF   ('&AMOD1' EQ '').CKREGS\n         AIF   ('&MODSAVE' NE '').SETMSAV\n.DFTMSAV AIF   ('&SAVE' EQ 'NO').NOMSAVE\n         L     1,4(13)                  GO GET PREVIOUS SAVE AREA\n&MODSAV  SETC  '12(1)'\n         AGO   .MSAVSET\n.SETMSAV AIF   ('&MODSAVE' EQ 'NO').NOMSAVE\n         AIF   ('&MODSAVE' EQ 'YES').DFTMSAV\n&MODSAV  SETC  '&MODSAVE'\n.MSAVSET ANOP\n         SETAMODE &AMOD1,SAVE=&MODSAV   SET NEW AMODE AND SAVE OLD ONE.\n         AGO   .CKREGS\n.NOMSAVE AIF   ('&AMOD1' EQ 'ANY').CKREGS\n         SETAMODE &AMOD1\n.CKREGS  ANOP\n         B     &LITLBL\n         LTORG ,                        INSURE ADDRESSABILITY TO CNSTS.\n&LITLBL  DS    0H\n         AIF   ('&EQUREGS' NE 'YES' AND '&EQUREGS' NE 'Y').MEND\n&I       SETA  0\n.CKRLOOP AIF   (&I GT 15).MEND\nR&I      EQU   &I\n&I       SETA  &I+1\n         AGO   .CKRLOOP\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DADSMBLK": {"ttr": 782, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         DADSMBLK &TYPE=DSECT\nDADSMPRM TYPE  &TYPE\nDSMPSPLN DS    0A                    SUBPOOL, BLOCK LENGTH\nDSMPSP   DC    AL1(DADSMSP)          SUBPOOL\nDSMPLEN  DC    AL3(0)                BLOCK LENGTH\nDSMPID   DC    CL8'DADSMBLK'\nDSMPNENT DC    AL2(0)                NUMBER OF ENTRIES IN TABLE\nDSMPFLAG DS    0XL2                  FLAGS\nDSMPFLG1 DC    X'00'                 FLAG BYTE 1:\nDSMPNRST EQU   X'80'                 - DO NOT ENFORCE ANY RESTRICTIONS\nDSMPNHSM EQU   X'40'                 - DO NOT ENFORCE HSM RESTRICTIONS\nDSMPDBUG EQU   X'20'                 - OPERATE IN DEBUG MODE\nDSMPFLG2 DC    X'00'                 FLAG BYTE 2: (RESERVED)\n         DC    2A(0)                 RESERVED\nDSMPSTRT EQU   *                     START OF ENTRIES\n         SPACE 3\nDADSMENT TYPE  &TYPE\nDSMENEXT DC    A(0)                  ADDRESS OF NEXT ENTRY OR 0\nDSMEVOLI DC    CL6'      '           VOLUME SERIAL NUMBER\nDSMEFLAG DS    0XL2                  FLAGS\nDSMEFLG1 DC    X'00'                 FLAG BYTE 1:\nDSMECKPF EQU   X'80'                 DSN PREFIX RESTRICTIONS SUPPLIED\nDSMEXCPF EQU   X'40'                 PREFIXES ARE EXCLUDE TYPE\nDSMENTMP EQU   X'20'                 TEMPORARY DATASETS NOT ALLOWED\nDSMECKUS EQU   X'10'                 RACF USERID RESTRICTIONS ENFORCED\nDSMENGBL EQU   X'08'                 DO NOT PERFORM GLOBAL CHECKING\nDSMEHSMP EQU   X'04'                 HSM MIG PACK - BYPASS HSM RESTR.\nDSMEFLG2 DC    X'00'                 RESERVED\nDSMELPFX DC    AL2(0)                TOTAL LENGTH OF PREFIX LIST\nDSMENOVR DC    AL1(0)                # OF OVERRIDES SUPPLIED\nDSMENPFX DC    AL1(0)                # OF PREFIX ENTRIES SUPPLIED\nDSMEPLST EQU   *                     START OF PREFIX LIST\n         SPACE 3\nDSMPFXE  TYPE  &TYPE\nDSMPFXL  DC    AL1(0)                LENGTH OF FOLLOWING PREFIX\nDSMPFXC  EQU   *,,C'C'               PREFIX VALUE\nDADSMSP  EQU   231                   GLOBAL, FETCH PROTECTED STG.\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DADSMMOD": {"ttr": 784, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "DMOD     TITLE 'DADSMMOD - TSO/E COMMAND TO MODIFY DADSM PARAMETER BLOCX\n               K'\nDADSMMOD CSECT\n         GBLC  &SYSSPLV\n***********************************************************************\n*  D A D S M M O D  -  TSO COMMAND TO MODIFY DADSM PROTECTION FLAGS   *\n*                                                                     *\n*  USE:  SEE HELP MEMBER.                                             *\n*                                                                     *\n*  ATTRIBUTES:  AMODE(31), RMODE(ANY), RENT, REUS, REFR, AC=1         *\n*                                                                     *\n*  TSO SERVICE ROUTINES USED:  IKJPARS, IKJEFF02, CALLTSSR            *\n*                                                                     *\n*  FUNCTION:  ALLOWS AN AUTHORIZED TSO USER TO MODIFY THE DADSM       *\n*       PROTECTION FLAGS OR VOLUME PROTECTION PROFILE.                *\n*       FUNCTIONS PERFORMED ARE:  DISABLE/ENABLE DADSM PROTECTION,    *\n*       DISABLE/ENABLE HSM RESTRICTIONS, DISABLE/ENABLE DEBUG MODE,   *\n*       AND CHANGE VOLUME PROTECTION PROFILE(S).                      *\n*                                                                     *\n*       VOLUME PROTECTION PROFILE(S) CAN BE CHANGED IN THE            *\n*       FOLLOWING MANNER:  RENAME, DISABLE/ENABLE HSM RESTRICTIONS,   *\n*       DISABLE/ENABLE TEMPORARY DATASET ALLOCATIONS, DISABLE/ENABLE  *\n*       RACF CHECKING FOR ALLOCATIONS, AND DISABLE/ENABLE GLOBAL      *\n*       PREFIX CHECKING FOR THE VOLUME.                               *\n*                                                                     *\n*  RESTRICTIONS:  NO FUNCTION WHICH CHANGES THE LENGTH OF THE DADSM   *\n*       PARAMETER BLOCK IS ALLOWED.  THIS INCLUDES:  ADDING/REMOVING  *\n*       VOLUME PROTECTION PROFILES AND ADDING/REMOVING DATASET NAME   *\n*       PREFIXES FROM VOLUME PROTECTION PROFILES.                     *\n*                                                                     *\n*       THE TSO USER MUST BE AUTHORIZED VIA RACF TO USE THIS COMMAND. *\n*       THE PROFILE REQUIRED IS TCMD.DADSMMOD IN CLASS $SPECIAL,      *\n*       AND AUTHORIZATION AT UPDATE LEVEL IS REQUIRED.                *\n*                                                                     *\n*       THIS COMMAND MUST EXECUTE AUTHORIZED, AND MUST THEREFORE      *\n*       BE PRESENT IN THE IKJEFTE2 CSECT.                             *\n*                                                                     *\n*  WRITTEN ON 8/12/87 BY BILL WARRINER, UMCHC.                        *\n*                                                                     *\n*  UPDATE HISTORY:                                                    *\n*     MM/DD/YY                                                        *\n*                                                                     *\n***********************************************************************\n         EJECT\n         CONNECT WORKSIZE,WORK,BASE=R12,PARM=(R3,CPPL),EQUREGS=YES,    X\n               AMODE=31,RMODE=ANY,LOC=ANY,        XA PARMS             X\n               COPYRT=1987,CLEAR=YES\n         L     R11,STATIC@             GET STATIC ADDRESS\n         USING DADSMM01,R11\n         BAL   R14,GETAUTH             TEST RACF AUTHORIZATION\n         L     R10,16\n         ICM   R10,15,CVTUSER-CVT(R10) GET NCT ADDRESS\n         BZ    NONCT\n         USING NCT,R10\n         CLC   NCTDAPRM,=A(0)          IS THERE A DADSM PARM?\n         BE    NODAPRM\n         BAL   R14,GETLOCK             LOCK IT FROM UPDATES\n         L     R8,NCTDAPRM             GET DADSM PARM BLOCK ADDRESS\n         USING DADSMPRM,R8\n         LA    R1,PARSLST\n         USING PPL,R1\n         MVC   PPLPCL,=A(PARSPCL)\n         LA    R0,PARSPDL@\n         ST    R0,PPLANS\n         MVC   PPLCBUF,CPPLCBUF        COMMAND BUFFER ADDRESS\n         ST    R13,PPLUWA              SAVE IN USER WORK AREA\n         MVC   PPLUPT,CPPLUPT          USER PROFILE TABLE ADDRESS\n         MVC   PPLECT,CPPLECT          ENVIR. CTL. TABLE ADDRESS\n         XC    PARSECB,PARSECB\n         LA    R0,PARSECB\n         ST    R0,PPLECB\n         DROP  R1\n         CALLTSSR  EP=IKJPARS,MF=(E,PARSLST)\n         LTR   R15,R15                 PARSE GOOD?\n         BNZ   BADPARSE\n         OI    PROCFLAG,PARSFLAG\n         MODESET  MF=(E,SUPVMODE)\n         OI    PROCFLAG,MODEFLAG\n         L     R2,PARSPDL@\n         USING IKJPARMD,R2\n         L     R1,=A(PARSPCL)          GET PCL ADDRESS\n         LH    R1,FUNCTION+4-PARSPCL(,R1) GET OFFSET TO PDE IN PDL\n         LH    R1,IKJPARMD+4(R1)       GET KEYWORD NUMBER FROM PDL\n         MH    R1,=H'4'\n         B     *+4(R1)\n         B     BADFUNC                 NONE SPECIFIED\n         B     ZAPVOL\n         B     ZAPVOL\n         B     ZAPVOL\n         B     ZAPVOL\n         B     ZAPVOL\n         B     ZAPVOL\n         B     ZAPVOL\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     NPROTECT\n         B     PROTECT\n         B     PROTECT\n         B     PROTECT\n         B     PROTECT\n         B     PROTECT\n         B     PROTECT\n         B     PROTECT\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     NHSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     HSMPRO\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     NDEBUG\n         B     DEBUG\n         B     DEBUG\n         B     DEBUG\n         B     DEBUG\n         B     DEBUG\nBADFUNC  DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'01'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\nNONCT    DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'02'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\n         EJECT\nNPROTECT DS    0H\n         OI    DSMPFLG1,DSMPNRST      SET \"NO RESTRICTIONS\"\n         B     RETNGOOD\nPROTECT  DS    0H\n         NI    DSMPFLG1,X'FF'-DSMPNRST  SET \"RESTRICTIONS\"\n         B     RETNGOOD\nNDEBUG   DS    0H\n         NI    DSMPFLG1,X'FF'-DSMPDBUG SET \"NO DEBUG MODE\"\n         B     RETNGOOD\nDEBUG    DS    0H\n         OI    DSMPFLG1,DSMPDBUG       SET \"DEBUG MODE\"\n         B     RETNGOOD\nNHSMPRO  DS    0H\n         OI    DSMPFLG1,DSMPNHSM      SET \"ALLOW HSM\"\n         B     RETNGOOD\nHSMPRO   DS    0H\n         NI    DSMPFLG1,X'FF'-DSMPNHSM  SET \"FORBID HSM\"\n         B     RETNGOOD\nZAPVOL   DS    0H\n         CLC   ZVOLUME,=H'1'\n         BNE   BADZAP\n         LA    R1,ZVSERO\n         ST    R1,CURVSERO             SAVE AS \"CURRENT\"\n         BAL   R14,VSERCNT             COUNT THE VOLSERS\n         STH   R0,VSEROCNT\n         CLC   ZNEWVOL,=H'1'\n         BNE   VOLLOOP\n         LA    R1,ZVSERN\n         ST    R1,CURVSERN\n         BAL   R14,VSERCNT\n         STH   R0,VSERNCNT\n         CLC   VSEROCNT,VSERNCNT       SAME COUNT?\n         BNE   BADNVSER\nVOLLOOP  DS    0H\n         L     R1,CURVSERO             CURRENT VOLSER\n         CLM   R1,7,=AL3(0)            PRESENT?\n         BE    VOLEND\n         CLC   =A(0),0(R1)             PRESENT?\n         BE    NEXTVOL\n         TM    6(R1),X'80'\n         BZ    NEXTVOL\n         LH    R14,4(R1)\n         L     R15,0(R1)\n         MVC   OLDVSER,BLANKS\n         LA    R9,OLDVSER\n         EX    R14,COPYVSER\n         CLC   DSMPNENT,=H'0'          ANY ENTRIES?\n         BE    BADOVOL\n         LA    R4,DSMPSTRT             POINT TO FIRST ENTRY\n         USING DADSMENT,R4\nFVLOOP   DS    0H\n         LTR   R4,R4\n         BZ    BADOVOL\n         CLC   OLDVSER,DSMEVOLI        SAME VOLSER?\n         BE    FOUNDVOL\n         L     R4,DSMENEXT\n         B     FVLOOP\nFOUNDVOL DS    0H\n         ST    R4,CURRENT              SAVE FOR LATER USE\n         CLC   ZUIDCK,=H'1'            UIDCK/NOUIDCK SPECIFIED?\n         BH    UIDSET\n         BL    UIDDONE\nUIDRSET  DS    0H                      TURN UIDCK OFF\n         NI    DSMEFLG1,X'FF'-DSMECKUS\n         B     UIDDONE\nUIDSET   DS    0H                      TURN UIDCK ON\n         OI    DSMEFLG1,DSMECKUS\nUIDDONE  DS    0H\n         CLC   ZMIGVOL,=H'1'           MIGVOL/NOMIGVOL SPECIFIED?\n         BH    MIGSET\n         BL    MIGDONE\nMIGRSET  DS    0H                      TURN MIGVOL OFF\n         NI    DSMEFLG1,X'FF'-DSMEHSMP\n         B     MIGDONE\nMIGSET   DS    0H                      TURN MIGVOL ON\n         OI    DSMEFLG1,DSMEHSMP\nMIGDONE  DS    0H\n         CLC   ZGLOBAL,=H'1'           GLOBALCK/NOGLOBALCK SPEC'D?\n         BH    GLOSET\n         BL    GLODONE\nGLORSET  DS    0H                      TURN GLOBALCK OFF\n         OI    DSMEFLG1,DSMENGBL\n         B     GLODONE\nGLOSET   DS    0H                      TURN GLOBALCK ON\n         NI    DSMEFLG1,X'FF'-DSMENGBL\nGLODONE  DS    0H\n         CLC   ZTEMPDS,=H'1'           TEMPDS/NOTEMPDS SPECIFIED?\n         BH    TMPSET\n         BL    TMPDONE\nTMPRSET  DS    0H                      TURN TEMPDS OFF\n         OI    DSMEFLG1,DSMENTMP\n         B     TMPDONE\nTMPSET   DS    0H                      TURN TEMPDS ON\n         NI    DSMEFLG1,X'FF'-DSMENTMP\nTMPDONE  DS    0H\n         CLC   VSERNCNT,VSEROCNT       NEW VOLSERS?\n         BNE   NEXTVOL\nNVOLLOOP DS    0H\n         L     R1,CURVSERN\n         CLM   R1,7,=AL3(0)            PRESENT?\n         BE    NEXTNVOL                NO ???!!???\n         CLC   =A(0),0(R1)             PRESENT?\n         BE    NEXTNVOL\n         TM    6(R1),X'80'\n         BZ    NEXTNVOL\n         LH    R14,4(R1)               GET NEW VOLUME LENGTH ...\n         MVC   NEWVSER,BLANKS          INITIALIZE NEW VOLSER\n         L     R15,0(R1)\n         LA    R9,NEWVSER\n         EX    R14,COPYVSER\n         CLC   NEWVSER,=CL6'*'         SKIP THIS NEW VSER?\n         BE    NEXTNVOL\n         LA    R14,DSMPSTRT\nFNVLOOP  DS    0H\n         LTR   R14,R14\n         BZ    NVOLOK\n         CLC   NEWVSER,DSMEVOLI-DADSMENT(R14)\n         BE    BADNVOL\n         L     R14,DSMENEXT-DADSMENT(,R14)\n         B     FNVLOOP\nNVOLOK   DS    0H\n         MVC   DSMEVOLI,NEWVSER        CHANGE THE VOLSER\n         B     NEXTNVOL\nBADNVOL  DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'04'\n         MVI   MTLEN-MTDSECTD+MTPARMS,L'NEWVSER\n         LA    R0,NEWVSER\n         STCM  R0,B'0111',MTADDR-MTDSECTD+MTPARMS\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\nNEXTNVOL DS    0H\n         MVC   CURVSERN,8(R1)\n         B     NEXTVOL\nBADOVOL  DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'03'\n         MVI   MTLEN-MTDSECTD+MTPARMS,L'OLDVSER\n         LA    R0,OLDVSER\n         STCM  R0,B'0111',MTADDR-MTDSECTD+MTPARMS\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\nNEXTVOL  DS    0H\n         LH    R0,VOLCOUNT\n         AH    R0,=H'1'\n         STH   R0,VOLCOUNT\n         L     R1,CURVSERO\n         MVC   CURVSERO,8(R1)\n         B     VOLLOOP\nVOLEND   DS    0H\n         CLC   VOLCOUNT,=H'0'\n         BE    BADZAP\n         B     RETNGOOD\nBADZAP   DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'09'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\nNODAPRM  DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'10'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\nBADPARSE DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'07'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\nBADNVSER DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'08'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\nRETNGOOD DS    0H\n         SR    R15,R15\n         B     ALLDONE\nRETNBAD  DS    0H\n         LA    R15,12\nALLDONE  DS    0H\n         TM    PROCFLAG,MODEFLAG\n         BZ    MODEDONE\n         MODESET  MF=(E,PROBMODE)\n         NI    PROCFLAG,X'FF'-MODEFLAG\nMODEDONE DS    0H\n         TM    PROCFLAG,PARSFLAG\n         BZ    PARSDONE\n         LA    R6,PARSPDL@\n         IKJRLSA  (R6)\n         NI    PROCFLAG,X'FF'-PARSFLAG\nPARSDONE DS    0H\n         RELEASE  WORKSIZE,WORK,RC=(R15)\n         EJECT\nVSERCNT  DS    0H\n         SR    R0,R0                   INITIALIZE COUNTER\nVSERCLLP DS    0H\n         CLM   R1,7,=AL3(0)            IS THIS ENTRY HERE?\n         BZR   R14\n         CLC   =A(0),0(R1)\n         BE    VSERCNXT\n         TM    6(R1),X'80'\n         BZ    VSERCNXT\n         A     R0,=F'1'\nVSERCNXT DS    0H\n         L     R1,8(,R1)\n         B     VSERCLLP\n         EJECT\nGETAUTH  DS    0H\n         LR    R6,R14\n         AIF   ('&SYSSPLV' EQ '1').NOTXA1\n         LA    R4,RACWORK\n         MVC   RACPARM,RACHECK\n         RACROUTE  REQUEST=AUTH,WORKA=(R4),                            X\n               MF=(E,RACPARM)\n         AGO   .XA1DONE\n.NOTXA1  RACHECK  MF=(E,RACHECK)\n.XA1DONE LTR   R15,R15\n         BZR   R6\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'05'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\n         EJECT\nMTSETUP  DS    0H                      BUILD IKJEFF02 PARM LIST\n         XC    MTPARMS,MTPARMS         CLEAR PARM LIST\n         LA    R1,MTPARMS              POINT TO PARM BLOCK\n         USING MTDSECTD,R1\n         LA    R0,MTCSECTP\n         ST    R0,MTPLPTR\n         LA    R0,CPPL\n         ST    R0,MTCPPLP\n         L     R0,=A(DADSMM02)\n         ST    R0,MTCSECTP\n         MVI   MTSW1,MTPUTLSW\n         AIF   ('&SYSSPLV' EQ '1').XADONE2\n         MVI   MTSW2,MTFMT             FOR XA USE ONLY\n.XADONE2 BR    R14\n         DROP  R1\n         EJECT\nGETLOCK  DS    0H                      OBTAIN LOCK ON DADSM BLOCK\n         LR    R6,R14                  SAVE RETURN ADDRESS\n         LA    R7,NCTDAPRM             GET DADSM BLOCK ADDRESS PTR\n         MVC   ENQPARM,ENQDMMY         COPY IN ENQ STUFF\n         ENQ   (QNAME,(R7),E,4,SYSTEM),MF=(E,ENQPARM)\n         LTR   R15,R15                 RESOURCE AVAILABLE?\n         BNZ   ENQBAD\n         OI    PROCFLAG,ENQFLAG        FLAG RESOURCE AS ENQD.\n         BR    R6\nENQBAD   DS    0H\n         BAL   R14,MTSETUP\n         MVC   MTMSGID-MTDSECTD+MTPARMS(4),=CL4'06'\n         CALLTSSR  EP=IKJEFF02,MF=(E,MTPARMS)\n         B     RETNBAD\nFREELOCK DS    0H                      RELEASE LOCK ON DADSM BLOCK\n         LR    R6,R14                  SAVE RETURN ADDRESS\n         TM    PROCFLAG,ENQFLAG        IS RESOURCE ENQD?\n         BZR   R6                      NO - JUST RETURN.\n         LA    R7,NCTDAPRM             GET ENQD. ADDRESS\n         MVC   DEQPARM,DEQDMMY         COPY IN DEQ STUFF\n         DEQ   (QNAME,(R7),4,SYSTEM),MF=(E,DEQPARM)\n         NI    PROCFLAG,X'FF'-ENQFLAG\n         BR    R6\nSTATIC@  DC    V(DADSMM01)\nDADSMM01 CSECT\nDADSMM01 RMODE ANY\nDADSMM01 AMODE 31\nQNAME    DC    CL8'DADSMBLK'\nENQDMMY  ENQ   (QNAME,0,E,4,SYSTEM),MF=L,RET=USE\nENQLEN   EQU   *-ENQDMMY\nDEQDMMY  DEQ   (QNAME,0,4,SYSTEM),MF=L\nDEQLEN   EQU   *-DEQDMMY\n         AIF   ('&SYSSPLV' EQ '1').NOTXA3\nRACHECK  RACROUTE REQUEST=AUTH,ENTITY=THISPROG,CLASS=$SPECIAL,         X\n               WORKA=0,ATTR=UPDATE,RELEASE=1.7,MF=L\nRACPARML EQU   *-RACHECK\n$SPECIAL DC    AL1(8),CL8'$SPECIAL'\n         AGO   .XA3DONE\n.NOTXA3  ANOP\nRACHECK  RACHECK  ENTITY=THISPROG,CLASS='$SPECIAL',ATTR=UPDATE,MF=L\n.XA3DONE ANOP\nTHISPROG DC    CL39'TCMD.DADSMMOD'\nSUPVMODE MODESET  MODE=SUP,KEY=ZERO,MF=L\nPROBMODE MODESET  MODE=PROB,KEY=NZERO,MF=L\nCOPYVSER MVC   0(*-*,R9),0(R15)\nBLANKS   DC    CL32' '\n         LTORG\n         EJECT\nDADSMM02 CSECT\nDADSMM02 RMODE ANY\nDADSMM02 AMODE 31\n         IKJTSMSG ('NCT2001E ILLEGAL FUNCTION SPECIFIED +'),01A\n         IKJTSMSG ('NCT2001E FUNCTION TO BE PERFORMED NOT RECOGNIZED'),X\n               01,01A\n         IKJTSMSG ('NCT2002E SYSTEM NOT INITIALIZED +'),02A\n         IKJTSMSG ('NCT2002E NCT WAS NOT FOUND'),02,02A\n         IKJTSMSG ('NCT2003E NO VOLUME PROFILE ENTRY FOUND FOR VOLUME 'X\n               ,,', VOLUME SKIPPED'),03\n         IKJTSMSG ('NCT2004E VOLUME ',,' ALREADY HAS A PROFILE ENTRY, RX\n               ENAME NOT PERFORMED +'),04A\n         IKJTSMSG ('NCT2004E CANNOT RENAME VOLUME PROFILE TO AN ALREADYX\n                EXISTING ENTRY'),04,04A\n         IKJTSMSG ('NCT2005E USER NOT AUTHORIZED TO PERFORM FUNCTION'),X\n               05\n         IKJTSMSG ('NCT2006E DADSM PARAMETERS NOT AVAILABLE +'),06A\n         IKJTSMSG ('NCT2006E PARAMETERS ARE CURRENTLY BEING UPDATED BY X\n               ANOTHER JOB OR USER'),06,06A\n         IKJTSMSG ('NCT2007E ERROR DURING PARSE, COMMAND ABORTED'),07\n         IKJTSMSG ('NCT2008E INCORRECT NEWVOLUME LIST +'),08A\n         IKJTSMSG ('NCT2008E NEWVOLUME LIST MUST CONTAIN EXACTLY ONE ENX\n               TRY FOR EACH ENTRY IN THE VOLUME LIST'),08,08A\n         IKJTSMSG ('NCT2009E NO VOLUMES SPECIFIED +'),09A\n         IKJTSMSG ('NCT2009E AT LEAST ONE VOLUME MUST BE SPECIFIED FOR X\n               THE ZAPVOL FUNCTION'),09,09A\n         IKJTSMSG ('NCT2010E DADSM RESTRICTIONS NOT INITIALIZED +'),10A\n         IKJTSMSG ('NCT2010E NO DADSM PARAMETER BLOCK EXISTS'),10,10A\n         IKJTSMSG\n         EJECT\nPARSPCL  IKJPARM\nPARSPCL  RMODE ANY\nPARSPCL  AMODE 31\nFUNCTION IKJTERM  'FUNCTION',UPPERCASE,TYPE=CNST,RSVWD=FNCLST1,        X\n               PROMPT='FUNCTION',                                      X\n               HELP=('DADSM PROTECTION FUNCTION TO BE PERFORMED')\nZVOLUME  IKJKEYWD\n         IKJNAME  'VOLUMES',SUBFLD=SUBFD2,                             X\n               ALIAS=('V','VO','VOL','VOLU','VOLUM','VOLUME','VOLS',   X\n               'VOLSE','VOLSER','VOLSERS')\nZNEWVOL  IKJKEYWD\n         IKJNAME  'NEWVOLUMES',ALIAS=('N','NE','NEW','NEWV','NEWVO',   X\n               'NEWVOL','NEWVOLU','NV','NVO','NVOL','NVOLU','NVOLUM',  X\n               'NVOLUME','NEWVOLSERS','NEWVOLSE','NEWVOLS','NVOLS',    X\n               'NVOLSE','NVOLSER','NVOLSERS'),                         X\n               SUBFLD=SUBFD3\nZMIGVOL  IKJKEYWD\n         IKJNAME  'NOMIGVOL',ALIAS=('NOM','NOMI','NOMIG','NOMIGV',     X\n               'NOMIGVO','NM')\n         IKJNAME  'MIGVOL',ALIAS=('M','MI','MIG','MIGV','MIGVO')\nZUIDCK   IKJKEYWD\n         IKJNAME  'NOUIDCK',ALIAS=('NOU','NOUI','NOUID','NOUIDC','NU', X\n               'NORACHECK','NORACHEC','NORACHE','NORACH','NORAC',      X\n               'NORA','NOR','NR','NORACF')\n         IKJNAME  'UIDCK',ALIAS=('U','UI','UID','UIDC','RACHECK',      X\n               'RACHEC','RACHE','RACH','RAC','RA','R','RACF')\nZGLOBAL  IKJKEYWD\n         IKJNAME  'NOGLOBALCK',ALIAS=('NOG','NOGL','NOGLO','NOGLOB',   X\n               'NOGLOBA','NOGLOBAL','NOGLOBALC','NG')\n         IKJNAME  'GLOBALCK',ALIAS=('G','GL','GLO','GLOB','GLOBA',     X\n               'GLOBAL','GLOBALC')\nZTEMPDS  IKJKEYWD\n         IKJNAME  'NOTEMPDS',ALIAS=('NOT','NOTE','NOTEM','NOTEMP',     X\n               'NOTEMPD','NT')\n         IKJNAME  'TEMPDS',ALIAS=('T','TE','TEM','TEMP','TEMPD')\nFNCLST1  IKJRSVWD\n         IKJNAME  'ZAPVOLS'\n         IKJNAME  'ZAPVOL'\n         IKJNAME  'ZAPVO'\n         IKJNAME  'ZAPV'\n         IKJNAME  'ZAP'\n         IKJNAME  'ZA'\n         IKJNAME  'Z'\n         IKJNAME  'NOPROTECT'\n         IKJNAME  'NOPROTEC'\n         IKJNAME  'NOPROTE'\n         IKJNAME  'NOPROT'\n         IKJNAME  'NOPRO'\n         IKJNAME  'NOPR'\n         IKJNAME  'NOP'\n         IKJNAME  'NPROTECT'\n         IKJNAME  'NPROTEC'\n         IKJNAME  'NPROTE'\n         IKJNAME  'NPROT'\n         IKJNAME  'NPRO'\n         IKJNAME  'NPR'\n         IKJNAME  'NP'\n         IKJNAME  'PROTECT'\n         IKJNAME  'PROTEC'\n         IKJNAME  'PROTE'\n         IKJNAME  'PROT'\n         IKJNAME  'PRO'\n         IKJNAME  'PR'\n         IKJNAME  'P'\n         IKJNAME  'NOHSMPROTECT'\n         IKJNAME  'NOHSMPROTEC'\n         IKJNAME  'NOHSMPROTE'\n         IKJNAME  'NOHSMPROT'\n         IKJNAME  'NOHSMPRO'\n         IKJNAME  'NOHSMPR'\n         IKJNAME  'NOHSMP'\n         IKJNAME  'NOHSM'\n         IKJNAME  'NOHS'\n         IKJNAME  'NOH'\n         IKJNAME  'NHSMPROTECT'\n         IKJNAME  'NHSMPROTEC'\n         IKJNAME  'NHSMPROTE'\n         IKJNAME  'NHSMPROT'\n         IKJNAME  'NHSMPRO'\n         IKJNAME  'NHSMPR'\n         IKJNAME  'NHSMP'\n         IKJNAME  'NHSM'\n         IKJNAME  'NHS'\n         IKJNAME  'NH'\n         IKJNAME  'NHPROTECT'\n         IKJNAME  'NHPROTEC'\n         IKJNAME  'NHPROTE'\n         IKJNAME  'NHPROT'\n         IKJNAME  'NHPRO'\n         IKJNAME  'NHPR'\n         IKJNAME  'NHP'\n         IKJNAME  'HSMPROTECT'\n         IKJNAME  'HSMPROTEC'\n         IKJNAME  'HSMPROTE'\n         IKJNAME  'HSMPROT'\n         IKJNAME  'HSMPRO'\n         IKJNAME  'HSMPR'\n         IKJNAME  'HSMP'\n         IKJNAME  'HSM'\n         IKJNAME  'HS'\n         IKJNAME  'H'\n         IKJNAME  'HPROTECT'\n         IKJNAME  'HPROTEC'\n         IKJNAME  'HPROTE'\n         IKJNAME  'HPROT'\n         IKJNAME  'HPRO'\n         IKJNAME  'HPR'\n         IKJNAME  'HP'\n         IKJNAME  'NODEBUG'\n         IKJNAME  'NODEBU'\n         IKJNAME  'NODEB'\n         IKJNAME  'NODE'\n         IKJNAME  'NOD'\n         IKJNAME  'NDEBUG'\n         IKJNAME  'NDEBU'\n         IKJNAME  'NDEB'\n         IKJNAME  'NDE'\n         IKJNAME  'ND'\n         IKJNAME  'DEBUG'\n         IKJNAME  'DEBU'\n         IKJNAME  'DEB'\n         IKJNAME  'DE'\n         IKJNAME  'D'\nSUBFD2   IKJSUBF\nZVSERO   IKJIDENT 'OLD VOLSER',UPPERCASE,LIST,                         X\n               MAXLNTH=6,FIRST=ALPHANUM,OTHER=ALPHANUM,CHAR,           X\n               PROMPT='VOLUME ENTRY TO BE ZAPPED'\nSUBFD3   IKJSUBF\nZVSERN   IKJIDENT 'NEW VOLSER',UPPERCASE,LIST,ASTERISK,                X\n               MAXLNTH=6,FIRST=ALPHANUM,OTHER=ALPHANUM,CHAR,           X\n               PROMPT='NEW VOLUME ENTRY NAME'\n         IKJENDP\n         EJECT\nWORK     DSECT\n         DS    18F\nPARSPDL@ DS    A\nPARSECB  DS    A\nPARSLST  DS    7A\nCURVSERO DS    A\nCURVSERN DS    A\nCURRENT  DS    A\nENQPARM  DS    CL(ENQLEN)\n         ORG   ENQPARM\nDEQPARM  DS    CL(DEQLEN)\n         ORG\n         DS    0D\nMTPARMS  DS    CL(MTLENMT)\n         AIF   ('&SYSSPLV' EQ '1').XADONE4\n         DS    0D\nRACWORK  DS    CL512\nRACPARM  DS    CL(RACPARML)\n.XADONE4 ANOP\nVOLCOUNT DS    H\nVSEROCNT DS    H\nVSERNCNT DS    H\nOLDVSER  DS    CL6\nNEWVSER  DS    CL6\nPROCFLAG DS    XL1\nPARSFLAG EQU   X'80'\nMODEFLAG EQU   X'40'\nENQFLAG  EQU   X'20'\n         DS    0D\nWORKSIZE EQU   *-WORK\n         CVT   DSECT=YES\nNCT      NCT\n         DADSMBLK\n         IKJPPL\n         IKJCPPL\n         AIF   ('&SYSSPLV' EQ '1').NOTXA5\n         IKJEFFMT MTNINST=1,MTDSECT=YES,MTFORMAT=NEW\n         AGO   .XADONE5\n.NOTXA5  IKJEFFMT MTNINST=1,MTDSECT=YES\n.XADONE5 ANOP\n         END   DADSMMOD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSAD": {"ttr": 1281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   DSAD\n.**********************************************************************\n.*    DSAD MACRO:                                                     *\n.* FUNCTION - GENERATES A DSECT DESCRIBING THE FIRST 88 BYTES OF A    *\n.*   PL/1 DYNAMIC STORAGE AREA (DSA).  THE NAME OF THE DSECT IS THE   *\n.*   LABEL ON THE MACRO INVOKATION, OR \"DSADSECT\" BY DEFAULT.         *\n.*                                                                    *\n.*   ALL LABELS GENERATED START WITH THE FIRST 3 CHARACTERS OF THE    *\n.*   DSECT LABEL (\"DSA\" BY DEFAULT).  LABELS ARE:                     *\n.*                                                                    *\n.*       XXXFLAG1 - PL/1 ERROR HANDLING FLAGS (DESCRIBE THIS DSA).    *\n.*       XXXOLD@  - ADDRESS OF PREVIOUS DSA (CHAINBACK).              *\n.*       XXXREGS  - REGISTER SAVE AREA (R14 THRU R12).                *\n.*       XXXR0S   - SAVE AREA FOR REGISTER 0                          *\n.*       XXXR1S   - SAVE AREA FOR REGISTER 1                          *\n.*                .                                                   *\n.*                .                                                   *\n.*                .                                                   *\n.*       XXXR15S  - SAVE AREA FOR REGISTER 15                         *\n.*       XXXLWS@  - ADDRESS OF LIBRARY WORK SPACE (LWS)               *\n.*       XXXNAB   - ADDRESS OF NEXT AVAILABLE BYTE IN LIFO STORAGE    *\n.*       XXXFLAG2 - MORE PL/1 FLAGS.                                  *\n.*                                                                    *\n.*  THIS IS THE END OF THE BASE DSA OF 88 BYTES.                      *\n.**********************************************************************\n         LCLA  &N\n         LCLC  &RN,&PREF,&LAB,&L2\n         AIF   ('&LABEL' EQ '').NOLAB\n&LAB     SETC  '&LABEL'\n&N       SETA  K'&LABEL\n         AIF   (&N LT 3).SMALLAB\n&PREF    SETC  '&LABEL'(1,3)\n         AGO   .LABDONE\n.SMALLAB ANOP\n&PREF    SETC  '&LABEL'\n         AGO   .LABDONE\n.NOLAB   ANOP\n&LAB     SETC  'DSADSECT'\n&PREF    SETC  'DSA'\n.LABDONE ANOP\n         SPACE 2\n&LAB     DSECT                           PL/1 DSA DESCRIPTION\n         SPACE 1\n***********************************************************************\n*     MAP OF DYNAMIC STORAGE AREA (DSA), POINTED TO BY R13.           *\n***********************************************************************\n         SPACE 1\n&L2      SETC  '&PREF.FLAG1'\n&L2      DS    F                         PL/1 FLAGS\n&L2      SETC  '&PREF.OLD@'\n&L2      DS    AL4                       PREVIOUS DSA ADDRESS (OLD R13)\n         DS    F                         (CHAIN FORWARD NOT USED)\n&L2      SETC  '&PREF.REGS'\n&L2      DS    0F                        REGISTER SAVE AREA\n&L2      SETC  '&PREF.R14S'\n&L2      DS    F\n&L2      SETC  '&PREF.R15S'\n&L2      DS    F\n&N       SETA  0\n.RLOOP   ANOP\n         AIF   (&N GT 12).XRLOOP\n&RN      SETC  '&PREF.R&N.S'\n&RN      DS    F\n&N       SETA  &N+1\n         AGO   .RLOOP\n.XRLOOP  ANOP\n&L2      SETC  '&PREF.LWS@'\n&L2      DS    AL4                       LIBRARY WORK SPACE ADDRESS.\n&L2      SETC  '&PREF.NAB'\n&L2      DS    AL4                       NEXT AVAILABLE BYTE IN LIFO.\n&L2      SETC  '&PREF.FLAG2'\n&L2      DS    2F                        PL/1 FLAGS.\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EQUREGS": {"ttr": 1284, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         EQUREGS\n         LCLA  &I\n&I       SETA  0\n.LOOP    ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LT 16).LOOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDCHR": {"ttr": 1286, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "FINDCHR  PLIARRV CSECT=ONLY,COPYRT=(1982,1985)\n***********************************************************************\n*                       FINDCHR - ASSEMBLER FUNCTION                  *\n*                                                                     *\n*  FUNCTION - FOR USE IN A PL/1 ROUTINE ONLY.  RETURNS THE POSITION   *\n*     OF THE FIRST CHARACTER IN THE BASE STRING THAT MATCHES ANY      *\n*     CHARACTER IN THE INDEX STRING.  IF EITHER STRING IS NULL, A 0   *\n*     IS RETURNED.                                                    *\n*                                                                     *\n*  USE:                                                               *\n*     DCL FINDCHR ENTRY(*,*) RETURNS(FIXED BIN(15));                  *\n*         .                                                           *\n*         .                                                           *\n*         .                                                           *\n*     I = FINDCHR(STRING1,STRING2);                                   *\n*                                                                     *\n*  WHERE STRING1 IS THE BASE STRING AND STRING2 IS THE INDEX STRING.  *\n*  EITHER STRING MAY BE FIXED OR VARYING LENGTH CHARACTER STRINGS.    *\n*                                                                     *\n*  MACROS USED: EQUREGS, PLIARRV, PLIRETN.                            *\n*                                                                     *\n*  LOGIC:                                                             *\n*    THE INDEX STRING IS READ AND USED TO SET UP A TRT TRANSLATE      *\n*    TABLE.  THE BASE STRING IS THEN LOOPED THROUGH UNTIL A NONZERO   *\n*    FUNCTION BYTE IS RETURNED BY TRT.  THE LOCATION OF THIS BYTE     *\n*    IS THEN RETURNED.  IF NO NONZERO FUNCTION BYTE IS FOUND, A 0 IS  *\n*    RETURNED.                                                        *\n*                                                                     *\n* THIS SUBROUTINE WAS WRITTEN ON APRIL 12, 1982 BY BILL WARRINER,     *\n*    D-205 VETERINARY MEDICAL DIAGNOSTIC LABORATORY, UMC, 882-6811.   *\n*                                                                     *\n* UPDATE HISTORY:                                                     *\n*    05/06/85 BILL WARRINER - MODIFIED TO USE TRT INSTEAD OF NESTED   *\n*             LOOPS.                                                  *\n*                                                                     *\n***********************************************************************\n         EJECT\nFINDCHR  PLIARRV   CSECT=YES,MULTEP=NO,DSASIZE=DSALEN\n         EJECT\n*        PROLOGUE DONE.  PROCESS PARAMTER LOCATOR/DESCRIPTORS.\n         SPACE 1\n         USING FINDCHR,R3                SET UP ADDRESSABILITY\n         USING DSADSECT,R13              SET UP ADDRESSABILITY\n         L     R10,8(R1)                 SAVE RETURN FIELD ADDRESS\n         SPACE 2\n*        SECOND PARM = INDEX STRING.\n         SPACE 1\n         XC    TRTABLE,TRTABLE           ZERO OUT TRT TABLE\n         L     R9,4(R1)                  LOCATOR/DESCRIPTOR ADDRESS\n         L     R5,0(R9)                  STRING ADDRESS\n         MVC   STRLEN,4(R9)              GET MAX. STRING LENGTH\n         TM    6(R9),X'80'               VARYING LENGTH STRING?\n         BZ    NOTVAR2                   BRANCH IF NO.\n         MVC   STRLEN,0(R5)              USE LENGTH PREFIX.\n         LA    R5,2(R5)                  BUMP PAST LENGTH FIELD.\nNOTVAR2  DS    0H\n         SPACE 2\n*        NOW, READ INDEX STRING AND SET UP TRANSLATE TABLE.\n         SPACE 1\n         LH    R8,STRLEN                 GET STRING LENGTH.\n         CH    R8,=H'0'                  NULL STRING?\n         BNH   RETN0                     IF SO, RETURN 1 (FIRST CHAR.)\n         SR    R2,R2                     INITIALIZE WORK REGISTER\n         BCTR  R5,0                      DECREMENT START-STRING PTR.\nLOOP2    DS    0H\n         IC    R2,0(R8,R5)               PICK UP CHARACTER\n         LA    R9,TRTABLE(R2)            TRT TABLE OFFSET ADDRESS.\n         MVI   0(R9),X'01'               SET NONZERO FUNCTION BYTE.\n         BCT   R8,LOOP2                  THEN GO GET NEXT BYTE.\n         SPACE 2\n         L     R9,0(R1)                  @ OF BASE LOCATOR/DESCRIPTOR\n         L     R5,0(R9)                  @ OF BASE STRING.\n         MVC   STRLEN,4(R9)              COPY MAX. LENGTH\n         TM    6(R9),X'80'               VARYING LENGTH?\n         BZ    NOTVAR1                   (NO)\n         MVC   STRLEN,0(R5)              USE LENGTH PREFIX\n         LA    R5,2(R5)                  BUMP PAST LENGTH PREFIX\nNOTVAR1  DS    0H\n         LA    R4,256                    MAX FOR 1 ITERATION.\n         LH    R8,STRLEN                 MAX LENGTH.\n         LTR   R8,R8                     TEST FOR NULL STRING\n         BNP   RETN0                     IF NULL: RETURN 0\n         BCTR  R8,0                      DECREMENT FOR TRT\n         SR    R1,R1                     INITIALIZE FOR TRT\n         LA    R5,0(R5)                  ZERO OUT FIRST BIT\n         LR    R6,R5                     SAVE INITIAL ADDRESS\nLOOP1    DS    0H\n         CR    R8,R4                     TOO MANY FOR 1 TRT?\n         BL    LASTTRT                   (NO.)\n         TRT   0(256,R5),TRTABLE\n         BNE   TRTFOUND                  (NONZERO FUNCTION FOUND)\n         AR    R5,R4                     NEW STARTING POINT\n         SR    R8,R4                     LENGTH LEFT\n         B     LOOP1\nLASTTRT  DS    0H\n         EX    R8,TRTSKEL                EX THE FINAL TRT\n         BNE   TRTFOUND                  RESULT IS 0.\nRETN0    DS    0H                        RETURN A 0 (NO CHAR. FOUND)\n         SR    R1,R1\n         B     RETURN\nTRTFOUND DS    0H\n         LA    R1,1(R1)                  \"FOUND\" ADDRESS + 1\n         SR    R1,R6                     - STARTING ADDRESS\nRETURN   DS    0H                        = RETURN VALUE\n         STH   R1,0(R10)                 SAVE RESULT IN RETURN FIELD\n         PLIRETN\n         EJECT\nTRTSKEL  TRT   0(*-*,R5),TRTABLE         SKELETON FOR TRT INSTR.\n         LTORG\n         SPACE 2\n         EQUREGS\n         EJECT\nDSADSECT DSAD\nSTRLEN   DS    H\nTRTABLE  DS    XL256\n         DS    0D\nDSALEN   EQU   *-DSADSECT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HCCDADSM": {"ttr": 1289, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "DADSM    TITLE 'HCCDADSM - HCC ROUINE FOR ALL DADSM EXIT FUNCTIONS'\n***********************************************************************\n* H C C D A D S M  - DADSM EXIT ROUTINE FOR IGGPRE00/IGGPOST0         *\n*                                                                     *\n* FUNCTION - THIS ROUTINE PERFORMS ALL FUNCTIONS FOR THE IGGPRE00     *\n*     AND IGGPOST0 EXITS.  THE ACTUAL IGGPRE00/IGGPOST0 ROUTINES      *\n*     SIMPLY BALR TO THIS ROUTINE VIA ITS ADDRESS IN THE NCT.         *\n*                                                                     *\n* ATTRIBUTES:  RENT, REUS, REFR, KEY 0, SUPERVISOR STATE, AMODE=ANY,  *\n*              RMODE=24.                                              *\n*                                                                     *\n* ENTRY ENVIRONMENT:                                                  *\n*     R0=0 IF A PREPROCESSING EXIT IS BEING TAKEN,                    *\n*     R0=4 IF A POSTPROCESSING EXIT IS BEING TAKEN.                   *\n*     AMODE=31 ON ENTRY.                                              *\n*     R1=ADDRESS OF PREPL, THE DADSM EXIT PARAMETER LIST.             *\n*     R13=SAVE AREA ADDRESS                                           *\n*     R14=RETURN ADDRESS                                              *\n*     R15=ENTRY POINT ADDRESS                                         *\n*                                                                     *\n* EXIT ENVIRONMENT:                                                   *\n*     R0-R14=SAME AS WHEN ENTERED.                                    *\n*     R15=0 TO ALLOW FUNCTION ON CURRENT VOLUME,                      *\n*     R15=4 TO DISALLOW FUNCTION ON CURRENT VOLUME BUT ALLOW DADSM    *\n*           PROCESSING TO CONTINUE WITH OTHER VOLUMES, OR             *\n*     R15=8 TO DISALLOW FUNCTION ON CURRENT VOLUME AND ABORT DADSM    *\n*           PROCESSING.                                               *\n*                                                                     *\n* REASON CODES GIVEN:                                                 *\n*     REASON=0004 - TEMPORARY DATA SET ALLOCATION ATTEMPTED, BUT      *\n*           THE CURRENT VOLUME HAS BEEN DEFINED TO EXCLUDE TEMPORARY  *\n*           DATA SET ALLOCATIONS (ONLY GIVEN ON \"ALLOCATE\" CALLS).    *\n*                                                                     *\n*     REASON=0008 - DATA SET NAME IS INVALID; THE HIGH LEVEL          *\n*           QUALIFIER IS IN THE \"EXCLUDE\" LIST OR IS NOT IN THE       *\n*           \"INCLUDE\" LIST, EITHER FOR THE CURRENT VOLUME OR THE      *\n*           GLOBAL LIST.                                              *\n*                                                                     *\n*     REASON=000C - THE VOLUME IS DEFINED AS BEING RACF-PROTECTED,    *\n*           AND THE USER IS NOT AUTHORIZED TO PERFORM THE SPECIFIED   *\n*           FUNCTION.  NOTE THAT JOBS AND STARTED TASKS WHOSE NAME    *\n*           STARTS WITH \"HSM\" ARE AUTHORIZED FOR ANY FUNCTION ON      *\n*           ANY VOLUME DEFINED AS A \"MIGVOL\", AND ARE NOT AUTHORIZED  *\n*           FOR ANY FUNCTION ON ANY OTHER VOLUME DEFINED AS           *\n*           RACF-PROTECTED (UNLESS SPECIFICALLY PERMITTED).           *\n*                                                                     *\n*  ONLY ALLOCATE AND RENAME CALLS ARE EXAMINED.  ALL FUNCTIONS ARE    *\n*  CONTROLLED BY A CONTROL BLOCK BUILT BY PROGRAM INIDADSM.  THIS     *\n*  CONTROL BLOCK ADDRESS IS KEPT IN THE NCT AND MAY BE IN EXTENDED    *\n*  STORAGE ON AN XA SYSTEM.  THE CONTROL BLOCK IS MAPPED BY MACRO     *\n*  DADSMBLK.                                                          *\n*                                                                     *\n*  WRITTEN ON 02/12/87 BY BILL WARRINER, UMCHC.                       *\n*                                                                     *\n*  UPDATE HISTORY:                                                    *\n*    02/25/88  WJW - ADDED OVERRIDE FOR GLOBAL CHECKS.                *\n*                                                                     *\n***********************************************************************\n         EJECT\nHCCDADSM CSECT\n         CONNECT  WORKSIZE,WORK,BASE=R12,PARM=R2,R0=R3,CLEAR=YES,      X\n               AMODE=ANY,RMODE=24,LOC=BELOW,COPYRT=1987\n         LTR   R3,R3               PRE- OR POST-PROCESSING?\n         BNZ   RETN00              IF POST, JUST RETURN.\n         USING PREPL,R2            ADDRX. OF PARM LIST\n         USING PSA,R0\n         L     R3,FLCCVT           GET CVT ADDRESS\n         ICM   R3,X'F',CVTUSER-CVT(R3)  GET NCT ADDRX IF PRESENT\n         BZ    RETN00              BRANCH IF NOT THERE.\n         ICM   R3,X'F',NCTDAPRM-NCT(R3) GET DADSM PARM BLOCK ADDRX\n         BZ    RETN00              NO RESTRICTIONS IF NOT THERE.\n         USING DADSMPRM,R3         ADDRESSABILITY TO PARM BLOCK\n         TM    DSMPFLG1,DSMPNRST   \"NO RESTRICTIONS\" MODE?\n         BO    RETN00\n         L     R1,PSAAOLD          GET ADDRESS OF CURRENT ASCB\n         ICM   R4,X'F',ASCBJBNI-ASCB(R1)  GET POINTER TO JOBNAME\n         BNZ   CKHSM010\n         L     R4,ASCBJBNS-ASCB(R1) GET POINTER TO JOBNAME\nCKHSM010 DS    0H\n         CLC   =C'HSM',0(R4)       HSM ?\n         BE    YESHSM\n         CLC   =C'HSM',8(R4)       HSM ?\n         BNE   NOTHSM\nYESHSM   DS    0H\n         OI    WKFLAG1,HSMFLAG     INDICATE HSM\n         TM    DSMPFLG1,DSMPNHSM   \"NO HSM\" RESTRICTIONS?\n         BO    RETN00\n         B     HSMDONE\nNOTHSM   DS    0H\n         NI    WKFLAG1,X'FF'-HSMFLAG  INDICATE NOT HSM\nHSMDONE  DS    0H\n         TM    DSMPFLG1,DSMPDBUG   OPERATE IN DEBUG MODE?\n         BZ    NOTDEBUG\n         CLC   =CL8'@@DADSM',0(R4) IS THIS A DEBUG JOB?\n         BE    YESDEBUG\n         CLC   =CL8'@@DADSM',8(R4) IS THIS A DEBUG JOB?\n         BNE   NOTDEBUG\nYESDEBUG DS    0H\n         OI    WKFLAG1,DEBUGFG\n         B     DBGDONE\nNOTDEBUG DS    0H\n         NI    WKFLAG1,X'FF'-DEBUGFG\nDBGDONE  DS    0H\n         MVI   CURRDSN,C' '\n         MVC   CURRDSN+1(L'CURRDSN-1),CURRDSN\n         CLI   IEXFUNC,IEXALL      TEST FUNCTION:  ALLOCATE?\n         BE    ALLOC8\n         CLI   IEXFUNC,IEXREN      TEST FUNCTION:  RENAME?\n         BE    RENAME\n         B     RETN00              ELSE ALLOW NORMAL PROCESSING.\n         EJECT\nALLOC8   DS    0H                  ALLOCATE A NEW DATASET.\n         ICM   R1,X'F',IEXUCB      GET UCB ADDRESS\n         BZ    RETN00              IF NO UCB, IT IS A VIO, SO O.K.\n         TM    UCBTBYT3-UCB(R1),UCB3DACC  IS IT A DASD DEVICE?\n         BZ    RETN00              NO ...\n         MVC   WKVOLID,UCBVOLI-UCB(R1)  SAVE VOLUME SERIAL\n         LA    R1,UCBVOLI-UCB(R1)  POINT TO VOLUME SERIAL ...\n         BAL   R14,FINDVOL         LOCATE VOLUME ENTRY IN DADSM PARMS\n         LTR   R15,R15             VOLUME ENTRY FOUND?\n         BNZ   ALOC0800            NO - JUST DO GLOBAL CHECKING.\n         USING DADSMENT,R4         POINT TO VOLUME ENTRY\n         TM    DSMEFLG1,DSMEHSMP   HSM MIGRATION VOLUME?\n         BZ    ALOC0002            NO -- BYPASS HSM CHECK\n         TM    WKFLAG1,HSMFLAG     IS IT HSM WHO CALLED?\n         BO    RETN00              YES -- ALWAYS ALLOW CALL.\nALOC0002 DS    0H\n         L     R1,IEXDSN           GET DSN ADDRESS\n         BAL   R14,DSNSCAN         GET DSN HIGH-LEVEL QUALIFIER\n         TM    WKFLAG1,DEBUGFG     DEBUG FLAG?\n         BZ    ALOC002A\n         WTO   MF=(E,WTODBG1)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTODBG1+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\nALOC002A DS    0H\n         TM    IEXFLAG,IEXVIO      IS THIS A VIO DATASET?\n         BNZ   TEMPDS\n         CLC   =C'SYS8',PREFIX     IS DSN A TEMPORARY?\n         BE    TEMPDS\n         CLC   =C'SYS9',PREFIX\n         BE    TEMPDS\n         CLI   PREFIX,C'*'\n         BE    TEMPDS\n         TM    DSMEFLG1,DSMECKPF   IS PREFIX TO BE CHECKED?\n         BZ    ALOC0010            BRANCH IF NO ...\n         CLC   =CL8'SYS1',PREFIX   IS IT A SYS1 DATASET?\n         BE    ALOC0010            YES ... SYS1 ALWAYS ALLOWED.\n         SR    R14,R14\n         IC    R14,DSMENPFX        GET # OF PREFIX ENTRIES\n         LA    R15,DSMEPLST        POINT TO FIRST PREFIX ENTRY\n         STM   R14,R15,PFXPARM     SAVE PARMS FOR SUBROUTINE.\n         BAL   R14,CKPREFIX\n         TM    DSMEFLG1,DSMEXCPF   IS PREFIX \"EXCLUDE\" TYPE?\n         BZ    ALOC0005            NO ...\n         LTR   R15,R15\n         BZ    PRFXBAD\n         B     ALOC0010\nALOC0005 DS    0H\n         LTR   R15,R15\n         BNZ   PRFXBAD\nALOC0010 DS    0H\n         TM    DSMEFLG1,DSMECKUS   IS USERID TO BE CHECKED?\n         BZ    ALOC0020            NO ...\n         BAL   R14,CKUSERID\n         LTR   R15,R15\n         BNZ   USIDBAD\nALOC0020 DS    0H\n         B     ALOC0900\nALOC0800 DS    0H\n         L     R1,IEXDSN           GET DSN ADDRESS\n         BAL   R14,DSNSCAN         GET DSN HIGH-LEVEL QUALIFIER\n         CLC   =C'SYS8',PREFIX     IS DSN A TEMPORARY?\n         BE    RETN00\n         CLC   =C'SYS9',PREFIX\n         BE    RETN00\n         CLI   PREFIX,C'*'\n         BE    RETN00\n         B     ALOC0902\nALOC0900 DS    0H\n         TM    DSMEFLG1,DSMENGBL\n         BNZ   RETN00              BYPASS GLOBAL CHECKING HERE ...\n         SR    R14,R14\n         IC    R14,DSMENOVR        GET NUMBER OF OVERRIDE ENTRIES\n         LA    R15,DSMEPLST        POINT TO FIRST PREFIX ENTRY\n         LH    R0,DSMELPFX         LENGTH OF ALL PREFIX ENTRIES\n         ALR   R15,R0              POINT TO FIRST OVERRIDE ENTRY\n         STM   R14,R15,PFXPARM\n         BAL   R14,CKPREFIX\n         LTR   R15,R15             PREFIX OVERRIDDEN ON VOLUME?\n         BZ    RETN00              YES - BYPASS GLOBAL CHECKING.\nALOC0902 DS    0H\n         LA    R1,=CL6'GLOBAL'\n         BAL   R14,FINDVOL\n         LTR   R15,R15\n         BNZ   RETN00\n         TM    WKFLAG1,DEBUGFG     DEBUG FLAG?\n         BZ    ALOC902A\n         WTO   MF=(E,WTODBG2)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTODBG2+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\nALOC902A DS    0H\n         TM    DSMEFLG1,DSMECKPF\n         BZ    RETN00\n         SR    R14,R14\n         IC    R14,DSMENPFX        GET # OF PREFIX ENTRIES ...\n         LA    R15,DSMEPLST        POINT TO FIRST PREFIX ENTRY\n         STM   R14,R15,PFXPARM     SAVE PARMS FOR SUBROUTINE.\n         BAL   R14,CKPREFIX\n         TM    DSMEFLG1,DSMEXCPF   IS PREFIX \"EXCLUDE\" TYPE?\n         BZ    ALOC0905            NO ...\n         LTR   R15,R15\n         BZ    PRFXBAD\n         B     RETN00\nALOC0905 DS    0H\n         LTR   R15,R15\n         BNZ   PRFXBAD\n         B     RETN00\nTEMPDS   DS    0H\n         TM    WKFLAG1,DEBUGFG     DEBUG FLAG?\n         BZ    TEMP002A\n         WTO   MF=(E,WTODBG3)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTODBG3+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\nTEMP002A DS    0H\n         TM    DSMEFLG1,DSMENTMP   TEMP DATA SETS ALLOWED?\n         BZ    RETN00\n         MVC   IEXREASN,=AL2(NOTEMPDS)  SET REASON CODE\n         B     RETN04\nPRFXBAD  DS    0H\n         MVC   WTOPARM(WTOXPFXL),WTOXPFX\n         MVC   WTOPARM+WTOXPVOL(6),WKVOLID\n         MVC   WTOPARM+WTOXPPFX(8),PREFIX\n         WTO   MF=(E,WTOPARM)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTOXPFX+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\n         MVC   IEXREASN,=AL2(BADDSN)    SET REASON CODE\n         B     RETN04\nUSIDBAD  DS    0H\n         MVC   WTOPARM(WTOUIDXL),WTOUIDX\n         MVC   WTOPARM+WTOUXVOL(6),WKVOLID\n         WTO   MF=(E,WTOPARM)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTOUIDX+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\n         MVC   IEXREASN,=AL2(BADUID)    SET REASON CODE\n         B     RETN04\n         EJECT\nRENAME   DS    0H\n         L     R6,IEXPTR1          GET USER RENAME PARM LIST\n         L     R7,12(R6)           GET ENTIRE VOLUME LIST\n         LH    R8,0(R7)            GET # OF ENTRIES IN VOLUME LIST\n         CH    R8,=H'0'            ANY ENTRIES?\n         BNH   RETN00              NO ???!!??\n         LA    R7,2(R7)            BUMP PAST #ENTRIES\n         ICM   R1,X'F',IEXUCB      GET UCB ADDRESS\n         BZ    RETN00              IF NO UCB, IT IS A VIO???!!??\n         TM    UCBTBYT3-UCB(R1),UCB3DACC  IS IT A DASD DEVICE?\n         BZ    RETN00              NO???!!??\n         CLC   UCBVOLI-UCB(6,R1),4(R7)  IS THIS THE FIRST VOLSER?\n         BNE   RETN00              NO - ALREADY BEEN ALLOWED.\n         XC    GBLADDR,GBLADDR\n         LA    R1,=CL6'GLOBAL'\n         BAL   R14,FINDVOL\n         LTR   R15,R15\n         BNZ   *+8\n         ST    R4,GBLADDR          SAVE ADDRX OF GLOBAL ENTRY\n         L     R1,8(R6)            ADDRX OF NEW DATA SET NAME\n         BAL   R14,DSNSCAN         GET PREFIX\n         TM    WKFLAG1,DEBUGFG     DEBUG FLAG?\n         BZ    RENA002A\n         WTO   MF=(E,WTODBG4)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTODBG4+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\nRENA002A DS    0H\nVOLLOOP  DS    0H\n         MVC   WKVOLID,4(R7)\n         LA    R1,WKVOLID          POINT TO VOLSER IN LIST\n         BAL   R14,FINDVOL         LOCATE VOLUME ENTRY IN DADSM PARMS\n         LTR   R15,R15             VOLUME ENTRY FOUND?\n         BNZ   ENDVOL              NO - JUST GLOBAL CHECK\n         TM    DSMEFLG1,DSMEHSMP   HSM MIGRATION VOLUME?\n         BZ    RENA0002            NO -- BYPASS HSM CHECK.\n         TM    WKFLAG1,HSMFLAG     IS IT HSM WHO CALLED?\n         BO    NEXTVOL             YES -- BYPASS ALL CHECKS.\nRENA0002 DS    0H\n         TM    DSMEFLG1,DSMECKPF   PREFIX TO BE CHECKED?\n         BZ    RENA0010\n         SR    R14,R14\n         IC    R14,DSMENPFX        GET # OF PREFIX ENTRIES ...\n         LA    R15,DSMEPLST        POINT TO FIRST PREFIX ENTRY\n         STM   R14,R15,PFXPARM     SAVE PARMS FOR SUBROUTINE.\n         BAL   R14,CKPREFIX\n         TM    DSMEFLG1,DSMEXCPF   IS PREFIX \"EXCLUDE\" TYPE?\n         BZ    RENA0005            NO ...\n         LTR   R15,R15\n         BZ    RENXPRFX\n         B     RENA0010\nRENA0005 DS    0H\n         LTR   R15,R15\n         BNZ   RENXPRFX\nRENA0010 DS    0H\n         TM    DSMEFLG1,DSMECKUS   IS USERID TO BE CHECKED?\n         BZ    RENA0020            NO ...\n         BAL   R14,CKUSERID\n         LTR   R15,R15\n         BNZ   RENXUSID\nRENA0020 DS    0H\n         TM    DSMEFLG1,DSMENGBL   GLOBAL CHECK THIS VOLUME?\n         BNZ   NEXTVOL             NO ...\nENDVOL   DS    0H\n         SR    R14,R14\n         IC    R14,DSMENOVR        GET NUMBER OF OVERRIDES\n         LA    R15,DSMEPLST        POINT TO FIRST PREFIX ENTRY\n         LH    R0,DSMELPFX         LENGTH OF ALL PREFIX ENTRIES\n         ALR   R15,R0              POINT TO FIRST OVERRIDE ENTRY\n         STM   R14,R15,PFXPARM\n         BAL   R14,CKPREFIX\n         LTR   R15,R15             PREFIX OVERRIDDEN ON VOLUME?\n         BZ    NEXTVOL             YES - BYPASS GLOBAL CHECKING.\n         ICM   R4,X'F',GBLADDR     PICK UP GLOBAL ENTRY ADDRX\n         BZ    NEXTVOL\n         TM    DSMEFLG1,DSMECKPF\n         BZ    NEXTVOL\n         SR    R14,R14\n         IC    R14,DSMENPFX        GET # OF PREFIX ENTRIES ...\n         LA    R15,DSMEPLST        POINT TO FIRST PREFIX ENTRY\n         STM   R14,R15,PFXPARM     SAVE PARMS FOR SUBROUTINE\n         BAL   R14,CKPREFIX\n         TM    DSMEFLG1,DSMEXCPF   IS PREFIX \"EXCLUDE\" TYPE?\n         BZ    EVOL0010            NO ...\n         LTR   R15,R15\n         BZ    RENXPRFX\n         B     NEXTVOL\nEVOL0010 DS    0H\n         LTR   R15,R15\n         BNZ   RENXPRFX\n         B     NEXTVOL\nNEXTVOL  DS    0H\n         LA    R7,12(R7)           POINT TO NEXT VOLUME ENTRY\n         BCT   R8,VOLLOOP          AND CONTINUE.\n         B     RETN00              ALL VOLUMES CHECKED OUT O.K.\nRENXPRFX DS    0H\n         MVC   WTOPARM(WTOXPFXL),WTOXPFX\n         MVC   WTOPARM+WTOXPVOL(6),WKVOLID\n         MVC   WTOPARM+WTOXPPFX(8),PREFIX\n         WTO   MF=(E,WTOPARM)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTOXPFX+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\n         MVC   IEXREASN,=AL2(BADDSN)    SET REASON CODE\n         B     RETN08\nRENXUSID DS    0H\n         MVC   WTOPARM(WTOUIDXL),WTOUIDX\n         MVC   WTOPARM+WTOUXVOL(6),WKVOLID\n         WTO   MF=(E,WTOPARM)\n         MVC   WTOPARM(WTODSNL),WTODSN\n         MVC   WTOPARM+WTODSNI(L'WTODSNI),WTOUIDX+WTODSNI\n         MVC   WTOPARM+WTODSNA(L'CURRDSN),CURRDSN\n         WTO   MF=(E,WTOPARM)\n         MVC   IEXREASN,=AL2(BADUID)    SET REASON CODE\n         B     RETN08\n         EJECT\nRETN00   DS    0H\n         SR    R15,R15\n         B     RETURN\nRETN04   DS    0H\n         L     R15,=F'4'\n         B     RETURN\nRETN08   DS    0H\n         L     R15,=F'8'\nRETURN   DS    0H\n         RELEASE  WORKSIZE,RC=(R15)\n         EJECT\nFINDVOL  DS    0H                  FIND VOLUME ENTRY IN DADSM PARM BLK\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         ST    R13,SUBSAVE+4\n         LA    R0,SUBSAVE\n         ST    R0,8(R13)\n         LR    R13,R0\n         DROP  R13\n         USING SUBSAVE,R13\n         CLC   DSMPNENT,=H'0'\n         BE    VNOTFND             NO ENTRIES, SO, NOT FOUND ...\n         LA    R4,DSMPSTRT         START WITH FIRST ENTRY ...\nFVLOOP   DS    0H\n         CLC   DSMEVOLI,0(R1)      VOLUME MATCH?\n         BE    VOLFND              YES ...\n         ICM   R4,X'F',DSMENEXT    NO, TRY NEXT VOLUME\n         BNZ   FVLOOP\nVNOTFND  DS    0H\n         XC    VOLENTRY,VOLENTRY\n         L     R15,=F'4'           SET BAD RC ...\n         B     FVRETURN\nVOLFND   DS    0H\n         ST    R4,VOLENTRY\n         SR    R15,R15\nFVRETURN DS    0H\n         DROP  R13\n         L     R13,4(R13)\n         USING WORK,R13\n         XC    8(4,R13),8(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         L     R4,VOLENTRY\n         BR    R14\n         EJECT\nDSNSCAN  DS    0H                  PARSE HIGH LEVEL QUALIFIER OF DSN\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         ST    R13,SUBSAVE+4\n         LA    R0,SUBSAVE\n         ST    R0,8(R13)\n         LR    R13,R0\n         DROP  R13\n         USING SUBSAVE,R13\n         MVI   PREFIX,C' '\n         MVC   PREFIX+1(L'PREFIX-1),PREFIX   INITIALIZE TO BLANKS\n         LA    R14,1\n         LA    R15,L'PREFIX\n         LA    R11,1\n         MVC   CURRDSN,0(R1)       SAVE CURRENT DATA SET NAME\nDSNSLOOP DS    0H\n         LA    R2,0(R11,R1)\n         CLI   0(R2),C'.'\n         BE    DSNSLEND\n         BXLE  R11,R14,DSNSLOOP\nDSNSLEND DS    0H\n         BCTR  R11,0\n         EX    R11,PRFXMVC\nDSNDONE  DS    0H\n         L     R13,4(R13)\n         LM    R14,R12,12(R13)\n         BR    R14\nPRFXMVC  MVC   PREFIX(*-*),0(R1)\n         DROP  R13\n         USING WORK,R13\n         EJECT\nCKPREFIX DS    0H                  TEST DSN PREFIX AGAINST VALID LIST\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         ST    R13,SUBSAVE+4\n         LA    R0,SUBSAVE\n         ST    R0,8(R13)\n         LR    R13,R0\n         DROP  R13\n         USING SUBSAVE,R13\n         LM    R2,R3,PFXPARM       GET PARMS ...\n         CH    R2,=H'0'            ARE THERE ANY PREFIX ENTRIES?\n         BNH   NOMATCH\n         SR    R1,R1               ZERO FOR IC OF LENGTH\nCKP0010  DS    0H\n         LA    R15,0               START OF SCAN\n         ICM   R1,B'0001',0(R3)    LENGTH OF SCAN\n         BZ    NEXTPFX\nCKP0020  DS    0H\n         LA    R14,PREFIX(R15)     CHAR. TO TEST\n         LA    R8,1(R15,R3)        PREFIX ENTRY TEST\n         CLI   0(R8),C'*'          WILDCARD?\n         BE    MATCHOK\n         CLI   0(R8),C'?'          WILDCARD?\n         BE    NEXTCHAR\n         CLC   0(1,R8),0(R14)      CHARS MATCH?\n         BE    NEXTCHAR\n         B     NEXTPFX\nNEXTCHAR DS    0H\n         LA    R15,1(R15)\n         CR    R15,R1\n         BL    CKP0020             GO TRY NEXT CHARACTER\n         CH    R1,=H'8'            MAX LENGTH?\n         BNL   MATCHOK\n         LA    R14,PREFIX(R1)      INSURE NO EXTRA CHARS.\n         CLI   0(R14),C' '         IS IT BLANK?\n         BE    MATCHOK             NO - TRY THE NEXT PREFIX.\nNEXTPFX  DS    0H\n         LA    R3,1(R1,R3)         BUMP TO NEXT ENTRY\n         BCT   R2,CKP0010          GO TRY NEXT ENTRY\n         B     NOMATCH\nMATCHOK  DS    0H\n         SR    R15,R15\n         B     CKP9999\nNOMATCH  DS    0H\n         LA    R15,4\nCKP9999  DS    0H\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         DROP  R13\n         USING WORK,R13\n         EJECT\nCKUSERID DS    0H                  USE RACF TO TEST USERID AGAINST VOL\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         ST    R13,SUBSAVE+4\n         LA    R0,SUBSAVE\n         ST    R0,8(R13)\n         LR    R13,R0\n         DROP  R13\n         USING SUBSAVE,R13\n         TM    WKFLAG1,HSMFLAG     DID HSM CALL CVAF?\n         BO    UIDC0100            YES - FAIL THE REQUEST\n         MVC   RACPRPFX,RPPFXDMY\n         MVC   RACVOLID,DSMEVOLI   COPY TO 24-BIT STORAGE\n         MVC   RACPRSFX,RPSFXDMY\n         MVC   RACCLASS,RACCLDMY   COPY TO 24-BIT STORAGE\n         MVC   RACKPRM(RACKLEN),RACKDMY\n         LA    R7,RACPROF          POINT TO PROFILE\n         LA    R8,RACCLASS+1       POINT TO CLASSNAME\n         SETAMODE 24\n         RACHECK ENTITY=((R7)),CLASS=(R8),MF=(E,RACKPRM)\n         SETAMODE 31,R=R14\n         LTR   R15,R15\n         BZ    UIDISOK             USER IS AUTHORIZED\nUIDC0100 DS    0H\n         LA    R15,8               NOT AUTHORIZED.\n         B     UIDC999\nUIDISOK  DS    0H\n         SR    R15,R15\nUIDC999  DS    0H\n         L     R13,4(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         DROP  R13\n         USING WORK,R13\n         EJECT\nRACKDMY  RACHECK ENTITY=(0),CLASS=0,ATTR=UPDATE,MF=L\nRACCLDMY DC    AL2(8)\n         DC    CL8'$SPECIAL'\nRPPFXDMY DC    C'DASD.'\nRVOLDMY  DC    CL6'VVVVVV'\nRPSFXDMY DC    CL(39-L'RPPFXDMY-L'RVOLDMY)' '\nWTODSN   WTO   'MMMMMMM  DSN=----+----1----+----2----+----3----+----4--X\n               --  ',ROUTCDE=(11),DESC=(7),MF=L\nWTODSNL  EQU   *-WTODSN\nWTODSNI  EQU   4,7,C'C'\nWTODSNA  EQU   17,44,C'C'\nWTOXPFX  WTO   'HCC601E  DADSM - PREFIX PPPPPPPP IS INVALID ON VOLUME VX\n               VVVVV  ',ROUTCDE=(11),DESC=(7),MF=L\nWTOXPFXL EQU   *-WTOXPFX\nWTOXPPFX EQU   28,8,C'C'\nWTOXPVOL EQU   58,6,C'C'\nWTOUIDX  WTO   'HCC602E  DADSM - USER NOT AUTHORIZED FOR VOLUME VVVVVV X\n                ',ROUTCDE=(11),DESC=(7),MF=L\nWTOUIDXL EQU   *-WTOUIDX\nWTOUXVOL EQU   52,6,C'C'\nWTODBG1  WTO   'HCC699I  DADSM DEBUG - FUNCTION CALLED IS: ALLOCATE  ',X\n               ROUTCDE=(11),DESC=(7),MF=L\nWTODBG2  WTO   'HCC699I  DADSM DEBUG - ALLOCATE - GLOBAL VOLUME CHECK',X\n               ROUTCDE=(11),DESC=(7),MF=L\nWTODBG3  WTO   'HCC699I  DADSM DEBUG - ALLOCATE - TEMP DATASET CHECK ',X\n               ROUTCDE=(11),DESC=(7),MF=L\nWTODBG4  WTO   'HCC699I  DADSM DEBUG - FUNCTION CALLED IS: RENAME    ',X\n               ROUTCDE=(11),DESC=(7),MF=L\n         LTORG\nNOTEMPDS EQU   4\nBADDSN   EQU   8\nBADUID   EQU   12\n         SPACE 3\nWORK     DSECT\nREGSAVE  DS    18F\nSUBSAVE  DS    18F\nPFXPARM  DS    2A\nGBLADDR  DS    A\nVOLENTRY DS    A\nWKVOLID  DS    CL6\nPREFIX   DS    CL8\nWTOPARM  WTO   '----+----1----+----2----+----3----+----4----+----5----+X\n               ----6----+----7----+----8',                             X\n               ROUTCDE=(11),DESC=(7),MF=L\nRACKPRM  RACHECK ENTITY=(0),CLASS=0,ATTR=UPDATE,MF=L\nRACKLEN  EQU   *-RACKPRM\nRACCLASS DS    XL10\nRACPROF  DS    0CL39\nRACPRPFX DS    CL(L'RPPFXDMY)\nRACVOLID DS    CL(L'RVOLDMY)\nRACPRSFX DS    CL(39-L'RPPFXDMY-L'RVOLDMY)\nWKFLAG1  DS    XL1\nHSMFLAG  EQU   X'80'\nDEBUGFG  EQU   X'08'\nCURRDSN  DS    CL44\n         DS    0D\nWORKSIZE EQU   *-WORK\n         EJECT\n         EQUREGS\nNCT      NCT   TYPE=DSECT\n         PRINT NOGEN\n         IHAPSA DSECT=YES\n         CVT   DSECT=YES\nUCB      DSECT\n         IEFUCBOB\n         IHAASCB DSECT=YES\n         PRINT GEN\n         IECIEXPL\n         DADSMBLK\n         END   HCCDADSM\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HCCRCCK": {"ttr": 1542, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "HCCRCCK  TITLE 'HCCRCCK  - PROGRAM TO ABEND ON A BAD RC'\nHCCRCCK  CSECT\nDSASP    EQU   0                        SUBPOOL FOR DSA OF THIS PGM\n***********************************************************************\n*   HCCRCCK  -  RETURN CODE CHECKER                                   *\n*                                                                     *\n*   FUNCTION:  THIS PROGRAM IS DESIGNED TO ATTACH SOME OTHER PROGRAM  *\n*       TEST ITS RETURN CODE AND FORCE AN ABEND IF THE RETURN CODE    *\n*       IS NOT IN ACCEPTABLE RANGE.  THIS ALLOWS JCL CONDITIONAL      *\n*       DISP FOR DD STATEMENTS OR COND=ONLY FOR EXEC STATEMENTS       *\n*       TO BE IMPLEMENTED FOR ANY PROGRAM.  THE ATTACHED PROGRAM      *\n*       WILL BE ATTACHED AUTHORIZED IF IT IS AUTHORIZED AND IN AN     *\n*       AUTHORIZED LIBRARY, OR NON AUTHORIZED OTHERWISE.              *\n*                                                                     *\n*       STANDARD SEARCH ORDER IS USED TO FIND THE PROGRAM TO ATTACH.  *\n*                                                                     *\n*   USE:                                                              *\n*         //STEP1  EXEC  PGM=HCCRCCK,                                 *\n*         //  PARM='PGM=PROGRAM,MAXCC=MAX-RETURN-CODE/PARMS'          *\n*                                                                     *\n*         WHERE:  \"PROGRAM\" IS THE PROGRAM TO BE ATTACHED,            *\n*                 \"MAX-RETURN-CODE\" IS THE LARGEST RETURN CODE        *\n*                     VALUE NOT TO BE CONVERTED TO AN ABEND CODE,     *\n*                 AND \"PARMS\" ARE OPTIONAL AND ARE ANY PARAMETERS     *\n*                     TO BE PASSED TO THE ATTACHED PROGRAM.  IF       *\n*                     \"PARMS\" ARE OMITTED, THE \"/\" MAY ALSO BE        *\n*                     OMITTED.                                        *\n*                                                                     *\n*   ATTRIBUTES:                                                       *\n*         REENTRANT, AMODE=24, RMODE=24, AC=1.                        *\n*                                                                     *\n*   INPUTS:                                                           *\n*         PARAMETER AS DESCRIBED ABOVE.                               *\n*                                                                     *\n*   OUTPUTS:                                                          *\n*         NONE.                                                       *\n*                                                                     *\n*  WRITTEN BY BILL WARRINER, UMCHC                                    *\n*                                                                     *\n*  UPDATE HISTORY:                                                    *\n*    12/30/87 WJW  -  MODIFIED TO USE USER ATTACH-REAUTH ROUTINE.     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         CONNECT DSALEN,RCCKDSA,LI=L,BASE=R12,PARM=R11,CLEAR=YES,      X\n               AMODE=24,RMODE=24,LOC=BELOW,COPYRT=(1986,1987)\n         LA    R0,DEFAULTS              SETUP DEFAULT VALUES\n         LA    R1,DFTLEN\n         LA    R14,INITSTG              IN INITIALIZED STORAGE\n         LA    R15,INITLEN\n         MVCL  R14,R0                   COPY IN DEFAULT VALUES\n         LTR   R11,R11                  ANY PARM PASSED?\n         BZ    PASSPARM                 IF NOT, JUST USE DEFAULTS\n         L     R3,0(R11)                GET POINTER TO STRING\n         LTR   R3,R3                    ANY STRING?\n         BZ    PASSPARM                 IF NOT, JUST USE DEFAULTS\n         LH    R4,0(R3)                 GET STRING LENGTH\n         CH    R4,=H'0'                 ANY STRING?\n         BNH   PASSPARM                 IF NOT, PASS UNCHANGED.\n         LA    R5,2(R3)                 POINT TO START OF STRING\nPARMCK   DS    0H\n         CLI   0(R5),C','               DELIMITER?\n         BE    PARMBUMP\n         CLI   0(R5),C' '               DELIMITER?\n         BNE   NODLIM\nPARMBUMP DS    0H\n         LA    R5,1(R5)                 BUMP PAST DELIMITER\n         SH    R4,=H'1'                 DEX LENGTH FIELD\n         BNP   NOPARM                   ALL DONE - NO CHARS. LEFT\n         B     PARMCK\nNODLIM   DS    0H\n         CLI   0(R5),C'/'               END OF PARMS?\n         BE    PARMEND\n         CLC   0(6,R5),=C'MAXCC='       OVERRIDE CONDITION CODE?\n         BE    SETCC\n         CLC   0(4,R5),=C'PGM='         GIVE PGM NAME?\n         BE    SETPGM\nBADPARM  DS    0H\n         WTO   MF=(E,TSCC001A)\n         B     PASSPARM                 PASS PARM UNCHANGED\nSETCC    DS    0H\n         LA    R5,6(R5)                 BUMP PAST KEYWORD\n         SH    R4,=H'6'                 AND DEX COUNT FIELD\n         BNP   BADPARM                  IF NONE LEFT, ERROR\n         LR    R14,R4                   GET LENGTH FIELD,\n         BCTR  R14,0                    DEX FOR TRT, AND\n         SR    R2,R2                    INITIALIZE FOR TRT\n         EX    R14,CCTRT                FIND END OF CC FIELD.\n         BC    B'0110',CCEND            FOUND END OF CC FIELD.\n         LA    R1,0(R4,R5)              (POINT PAST END).\n         IC    R2,=X'02'                (END OF STRING)\nCCEND    DS    0H\n         CH    R2,=H'2'                 TEST DELIMITER\n         BH    BADPARM\n         SR    R1,R5                    GET STRING LENGTH\n         LR    R2,R1                    SAVE FOR LATER USE\n         CH    R2,=H'5'                 TOO LONG?\n         BNL   BADPARM\n         BCTR  R1,0                     DEX FOR TRT\n         EX    R1,CCPACK                CONVERT TO PACKED\n         CVB   R1,PACKWORK              THEN TO BINARY.\n         ST    R1,CONDCODE              SAVE FOR LATER USE.\n         AR    R5,R2                    BUMP PAST COND CODE\n         SR    R4,R2                    SET NEW LENGTH\n         BNP   NOPARM                   IF NO CHARS. LEFT, NO PARM.\n         B     PARMCK                   TRY NEXT KEYWORD\nSETPGM   DS    0H\n         LA    R5,4(R5)                 BUMP PAST KEYWORD\n         SH    R4,=H'4'                 DEX LENGTH FIELD\n         BNP   BADPARM\n         LR    R14,R4                   SAVE FOR TRT\n         BCTR  R14,0                    DEX FOR TRT\n         SR    R2,R2                    ZERO FOR TRT\n         EX    R14,PGMTRT               FIND END OF PGMNAME\n         BC    B'0110',PGMEND           FOUND END OF CC FIELD.\n         LA    R1,0(R4,R5)              (POINT PAST END).\n         IC    R2,=X'02'                (END OF STRING)\nPGMEND   DS    0H\n         CH    R2,=H'2'                 CHECK DELIMITER\n         BH    BADPARM\n         SR    R1,R5                    GET STRING LENGTH\n         LR    R2,R1                    SAVE FOR LATER USE\n         CH    R2,=H'8'                 PARM TOO LONG?\n         BH    BADPARM\n         BCTR  R1,0                     DEX FOR TRT\n         EX    R1,PGMMVC                CONVERT TO PACKED\n         AR    R5,R2                    BUMP PAST PGM NAME\n         SR    R4,R2                    SET NEW LENGTH\n         BNP   NOPARM                   IF NO CHARS. LEFT, NO PARM.\n         B     PARMCK                   TRY NEXT KEYWORD\n         EJECT\nPARMEND  DS    0H\n         LA    R5,1(R5)                 BUMP PAST \"/\"\n         SH    R4,=H'1'                 DEX CHARACTER COUNT.\n         BNP   NOPARM\n         LR    R1,R4\n         BCTR  R1,0                     DEX FOR MVC\n         EX    R1,PARMMVC\n         STH   R4,PARMLEN\n         LA    R1,PARMLEN               POINT TO LENGTH FIELD\n         ST    R1,PARMLST\n         OI    PARMLST,X'80'            FLAG AS LAST(ONLY) PARM\n         LA    R1,PARMLST               POINT TO PARM LIST\n         B     LINKPGM\nPASSPARM DS    0H\n         MVC   PARMLST,0(R11)\n         LA    R1,PARMLST               POINT TO PARM LIST\n         B     LINKPGM\nNOPARM   DS    0H\n         LA    R1,NULLPARM              INDICATE NO PARM LIST\nLINKPGM  DS    0H\n         CLI   PGMNAME,C' '             PROGRAM SPECIFIED?\n         BE    NOPGM\n         LA    R0,PGMNAME               GET PARM ADDRESS ...\n         STM   R0,R1,LINKPRM            AND SAVE IN PARM LIST\n         OI    LINKPRM+4,X'80'          FLAG END OF LIST\n         LA    R1,LINKPRM\n         L     R15,=V(ATTCHATH)         CALL ATTACH-REAUTH ROUTINE\n         BALR  R14,R15\n         LTR   R0,R0                    WAS THE ATTACH SUCCESFUL?\n         BNZ   ATTFAIL\n         C     R15,CONDCODE             GOOD CONDITION CODE?\n         BNH   RETURN\nABENDIT  DS    0H\n         LR    R1,R15                   GET CONDITION CODE\n         ABEND (1),,,USER\nATTFAIL  DS    0H\n         LR    R2,R0                    SAVE REASON CODE\n         WTO   MF=(E,TSCC024U)\n         LR    R0,R2                    RESTORE REASON CODE\n         ABEND 24,DUMP,,,USER\nNOPGM    DS    0H\n         WTO   MF=(E,TSCC020U)\n         ABEND 20,DUMP,,USER\nRETURN   DS    0H\n         RELEASE DSALEN,RC=(R15),LI=L\n         EJECT\nDEFAULTS DS    0D\n         DC    F'4'                     DEFAULT CONDITION CODE\n         DC    CL8' '                   DEFAULT PROGRAM NAME\nDFTLEN   EQU   *-DEFAULTS\nTSCC001A WTO   'TSCC001A  ERRONEOUS PARM OPTION HAS BEEN IGNORED',     X\n               ROUTCDE=(11),MF=L\nTSCC020U WTO   'TSCC020U  NO PROGRAM NAME SPECIFIED',                  X\n               ROUTCDE=(11),MF=L\nTSCC024U WTO   'TSCC021U  ATTACH OF USER PROGRAM FAILED',              X\n               ROUTCDE=(11),MF=L\nDSALEN   DS    0F\n         DC    AL1(DSASP),AL3(DSASIZE)  SUBPOOL AND SIZE FOR GETMAIN\nPARMMVC  MVC   PARMCHRS(*-*),0(R5)      SKELETON FOR EX\nCCTRT    TRT   0(*-*,R5),CCTRTAB        SKELETON FOR EX\nCCPACK   PACK  PACKWORK,0(*-*,R5)\nPGMTRT   TRT   0(*-*,R5),PGMTRTAB       SKELETON FOR EX\nPGMMVC   MVC   PGMNAME(*-*),0(R5)       SKELETON FOR EX\nCCTRTAB  DS    0XL256                   DIGIT TRT TABLE\n         DC    256XL1'03'\n         ORG   CCTRTAB+C' '\n         DC    XL1'01'\n         ORG   CCTRTAB+C','\n         DC    XL1'01'\n         ORG   CCTRTAB+C'/'\n         DC    XL1'01'\n         ORG   CCTRTAB+C'0'\n         DC    10XL1'00'\n         ORG\nPGMTRTAB DS    0XL256                   PGM NAME TRT TABLE\n         DC    256XL1'00'\n         ORG   PGMTRTAB+X'00'\n         DC    63XL1'03'\n         ORG   PGMTRTAB+C' '\n         DC    XL1'01'\n         ORG   PGMTRTAB+C','\n         DC    XL1'01'\n         ORG   PGMTRTAB+C'/'\n         DC    XL1'01'\n         ORG\n         CNOP  2,4\nZEROPRM  DC    H'0'\nNULLPARM DC    AL1(X'80'),AL3(ZEROPRM)\n         LTORG\n         EQUREGS\n         EJECT\nRCCKDSA  DSECT\nREGSAVE  DS    18F                      OS-STANDARD REGISTER SAVE AREA\nINITSTG  DS    0D\nCONDCODE DC    F'4'                     DEFAULT CONDITION CODE\nPGMNAME  DC    CL8' '                   DEFAULT PROGRAM NAME\nLINKPRM  DS    2A\nPARMLST  DS    A                        PARM LIST ADDRESS\nPACKWORK DS    D\n         CNOP  2,4\nPARMLEN  DS    H\nPARMCHRS DS    CL100\n         DS    0D\nINITLEN  EQU   *-INITSTG\nDSASIZE  EQU   *-RCCKDSA\n         END   HCCRCCK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HJUX2530": {"ttr": 1547, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "***********************************************************************\n*    IN THIS MODULE ARE THE EXITS FOR JES2;\n*       EXIT253 - HCC-INSTALLED CHECKPOINT LOCK EXIT\n***********************************************************************\n*\n***********************************************************************\n         COPY  $HASPGBL\n         MACRO\n         $USERCBS\nSMFUSER  DSECT ,                    FORMAT OF SMF USER RECORD\nSMFURDW  DC    AL2(SMFRECLN),AL2(0) RDW (LL,BB)\nSMFUSYS  DS    AL1(SMFSVS2+SMFSXA)  SET BY SVC83???\nSMFSXA   EQU   X'04'                XA SYSTEM\nSMFSVS2  EQU   X'02'                VS/2 SYSTEM\nSMFSVS1  EQU   X'01'                VS/1 SYSTEM\nSMFUTYPE DC    AL1(SMFRECTP)        SMF RECORD TYPE\nSMFUDTTM DS    0XL8                 DATE,TIME\nSMFUTIME DS    XL4                  BINARY 1/100 SECS. SINCE MIDNIGHT\nSMFUDATE DS    PL4                  PACKED JULIAN 00YYDDDF\nSMFUSMFN DS    CL4                  SMF SYSID\nSMFUJESN DS    CL4                  JES2 SYSID\nSMFUENT  DS    CL4\nSMFRECLN EQU   *-SMFUSER            LENGTH OF SMF RECORD\nSMFRECTP EQU   253                  SMF RECORD TYPE\n         DS    0D                   ALIGN TO DOUBLEWORD\nWORKLEN  EQU   *-SMFUSER\n         PRINT NOGEN\n         IEESMCA\n         MEND\nHJUX2530 $MODULE $BUFFER,$CAT,$DCT,$HASPEQU,$HCT,$JCT,$JOE,            X\n               $JQE,$MIT,$PCE,$PDDB,$PPPWORK,$NHD,$NIT,                X\n               $RDRWORK,RPL,CVT,$USERCBS,                              X\n               ENVIRON=JES2\nHJUX2530 AMODE 31\nHJUX2530 RMODE 24\n         TITLE 'CHECKPOINT LOCK ACTIVITY - EXIT 253'\n***********************************************************************\n*    EXIT253 - CKPT LOCK (HCC INSTALLED)\n*    R0  - 0=LOCK REQUESTED, 4=LOCK OBTAINED, 8=LOCK RELEASED.\n*    R1  - N/A\n*    R2  - N/A\n*    R3  - N/A\n*    R4  - N/A\n*    R5  - N/A\n*    R6  - N/A\n*    R7  - N/A\n*    R8  - N/A\n*    R10 - N/A\n*    R11 - HCT\n*    R12 - CODE BASE\n*    R13 - PCE\n*\n*   THIS EXIT DOES THE FOLLOWING;\n*       WRITE OUT AN SMF RECORD (TYPE=253) FOR JES2 CHECKPOINT\n*       RESERVE/RELEASE ACTIVITY.\n*\n*   NOTE: THIS EXIT USES THE PCEUSER0 FIELD OF THE CHECKPOINT\n*   PROCESSOR.\n*\n***********************************************************************\n         EJECT\n***********************************************************************\n* EXIT253 ENTRY POINT\n***********************************************************************\n         SPACE 3\nEXIT253A $ENTRY BASE=R12\n         $SAVE                      SAVE CALLER'S REGISTERS\n         USING HCT,R11              SET UP ADDRESSABILITY TO HCT\n         USING PCE,R13\n         LR    R12,R15\n         LR    R2,R0                SAVE ENTRY CODE\n         ICM   R5,15,PCEUSER0       SMF RECORD ADDRESS?\n         BNZ   GOTMAIN\n         GETMAIN  R,LV=WORKLEN      GET BUFFER FOR SMF RECORD\n         LR    R5,R1                POINTER TO BUFFER\n         ST    R1,PCEUSER0          SAVE FOR LATER CALLS\nGOTMAIN  DS    0H\n         USING SMFUSER,R5           POINT TO IT.\n         XC    SMFUSER(WORKLEN),SMFUSER\n         STCM  R2,X'F',SMFUENT      SAVE DATA (INITIAL R0)\n         TIME  BIN\n         STCM  R1,X'F',SMFUDATE     SAVE IMMEDIATE DATE\n         STCM  R0,X'F',SMFUTIME     SAVE IMMEDIATE TIME\n         LA    R0,SMFRECLN\n         STH   R0,SMFURDW           SAVE LL OF RDW\n         MVI   SMFUTYPE,SMFRECTP    COPY IN RECORD TYPE\n         MVI   SMFUSYS,SMFSVS2+SMFSXA  SET \"XA+VS2\" SYSTEM\n         MVC   SMFUJESN,$SID        COPY SYSID FOR JES2\n         L     R1,16                GET CVT ADDRESS\n         L     R1,CVTSMCA-CVT(,R1)  GET SMF CONTROL AREA ADDRESS\n         MVC   SMFUSMFN,SMCASID-SMCABASE(R1)  COPY SMF SYSID\n         SMFWTM (R5)                THEN WRITE OUT SMF RECORD\nJX253LVE DS    0H\n         XR    R15,R15              SET RETURN CODE=0\n         $RETURN RC=(R15)\n         EJECT\n         LTORG ,\n         TITLE 'COMPLETES MODULE INFO TABLE'\n         $MODEND\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEFUJV": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "IEFUJV   TITLE 'MVS READER EXIT TO PERFORM SYMBOLIC SUBSTITUTION  '\nIEFUJV   CSECT\n         GBLC  &SYSSPLV,&KWDCHAR\n         SPLEVEL TEST              XA EXPANSION?\n&KWDCHAR SETC  '?'                 STARTING CHAR. FOR EACH KEYWORD\n**********************************************************************\n* FUNCTION - PERFORMS SYMBOLIC SUBSTITUTION ON JCL PASSED TO         *\n*    THE CONVERTER/INTERPRETER.  SUBSTITUTION IS DONE FROM VARIOUS   *\n*    MVS CONTROL BLOCKS.  SEVERAL KEYWORDS STARTING WITH &KWDCHAR ARE*\n*    SUBSTITUTED WITH VALUES SUCH AS DATE, DAY OF WEEK, SYSTEM ID,   *\n*    VTAM SUBAREA, ETC.                                              *\n*                                                                    *\n* ATTRIBUTES:  RENT, REUS, REFR                                      *\n* RUNS:  KEY 1, SUPERVISOR STATE, ENABLED.                           *\n*                                                                    *\n* MACROS: GETMAIN, FREEMAIN, KEYWORD, SPLEVEL, ESTAE                 *\n*                                                                    *\n* MAPPING MACROS:  IEFJMR, KWDTABLE, EQUREGS, IHASDWA                *\n*                                                                    *\n* THIS ROUTINE SHOULD ASSEMBLE IN BOTH XA AND NON-XA ENVIRONMENTS.   *\n* IN A NON-XA ENVIRONMENT, HOWEVER, A MACRO \"SPLEVEL\" SHOULD BE      *\n* PROVIDED WHICH WILL SIMPLY SET THE VALUE OF GLOBAL SETC SYMBOL     *\n* &SYSSPLV TO '1'.  IF THIS IS NOT DONE, ASSEMBLY ERRORS WILL        *\n* RESULT.                                                            *\n*                                                                    *\n* FOR A LIST OF KEYWORDS SUBSTITUTED, SEE LABEL \"KEYWORDS\"           *\n*                                                                    *\n* AUTHOR:  BILL WARRINER                                             *\n*          UMC HOSPITAL AND CLINICS                                  *\n*          SYSTEM PROGRAMMING SERVICES DC017.00                      *\n*          1400 ROCK QUARRY ROAD                                     *\n*          COLUMBIA, MO  65212                                       *\n*          (314) 882-3773                                            *\n*                                                                    *\n* UPDATE HISTORY:                                                    *\n*                                                                    *\n*                                                                    *\n**********************************************************************\n         TITLE 'ENTRY POINT DEFINITION'\nIEFUJV   CSECT\n         USING IEFUJV,R15\n         B     PASTCONS\n         DC    AL1(L'EPID)\nEPID     DC    C'IEFUJV_V2.0_&SYSDATE._&SYSTIME.'\n         DC    C'COPYRIGHT(C) 1988 BY THE CURATORS OF THE UNIVERSITY OFX\n                MISSOURI, A PUBLIC CORPORATION'\nPASTCONS DS    0H\n         STM   R14,R12,12(R13)\n         DROP  R15\n         LR    R12,R15\n         USING IEFUJV,R12\n         LR    R3,R1               SAVE PARAMETER REGISTER\n         L     R1,8(R3)            GET FLAG BYTE ADDRESS\n         CLI   0(R1),16            TEST FLAG BYTE\n         BH    RETURN0             UNSUPPORTED FUNCTION.\n         BE    KILLAREA            ALL DONE, JUST FREEMAIN AND GO AWAY.\n         LA    R0,WORKSIZE\n         AIF   ('&SYSSPLV' EQ '1').NOTXA0\nIEFUJV   AMODE 31\nIEFUJV   RMODE ANY\n         GETMAIN  RU,LV=(0),SP=WRKSP,LOC=(ANY,ANY)\n         AGO   .XA0JOIN\n.NOTXA0  ICM   R0,8,=AL1(WRKSP)\n         GETMAIN  R,LV=(0)\n.XA0JOIN ST    R1,8(R13)           CHAIN ...\n         ST    R13,4(R1)           ... CHAIN AREAS ...\n         LR    R13,R1              ... TOGETHER.\n         LA    R0,8(R13)           START OF AREA TO CLEAR\n         LA    R1,WORKSIZE-8       LENGTH OF AREA TO CLEAR\n         SR    R15,R15\n         MVCL  R0,R14              CLEAR THE WORK AREA\n         USING WORK,R13\n         TITLE 'MVS READER EXIT TO PERFORM SYMBOLIC SUBSTITUTION  '\n         MVC   WRKESTAW(LESTAEL),ESTAEL MOVE IN ESTAE PARM LIST\n         LA    R0,RTRYRTN1         RETRY ROUTINE - NO SDWA\n         LA    R1,RTRYRTN2         RETRY ROUTINE - SDWA\n         STM   R0,R1,WRKESTAP\n         STM   R12,R13,WRKESTAP+8\n         ESTAE RECOVERY,CT,PARAM=WRKESTAP,MF=(E,WRKESTAW) SETUP ESTAE\n         L     R2,0(R3)            GET JMR ADDRESS\n         USING JMR,R2\n         L     R4,4(R3)            GET JCL IMAGE ADDRESS\n         L     R5,JMRUCOM          GET USER FIELD\n         LTR   R5,R5               AREA ALREADY ALLOCATED?\n         BNZ   AREAGOT\n         LA    R0,SYSLEN\n         AIF   ('&SYSSPLV' EQ '1').NOTXA1\n         GETMAIN  RU,LV=(0),SP=SYSSP,LOC=(ANY,ANY)\n         MVC   SYSKWDTB-SYSAREA(KWDFRLEN,R1),KEYWORDS\n         MVC   SYSXA-SYSAREA(2,R1),=C'XA' FOR XA SYSTEM\n         MVI   SYSSPLV-SYSAREA(R1),C'2'   FOR XA SYSTEM\n         L     R15,16               CVT ADDRESS:\n         TM    116(R15),X'80'       IS IT REALLY XA?\n         BO    KWD010\n         MVI   SYSSPLV-SYSAREA(R1),C'1'   NON XA SYSTEM RIGHT NOW...\nKWD010   DS    0H\n         AGO   .XA1JOIN\n.NOTXA1  ICM   R0,8,=AL1(SYSSP)\n         GETMAIN  R,LV=(0)\n         MVC   SYSKWDTB-SYSAREA(KWDFRLEN,R1),KEYWORDS\n         MVI   SYSSPLV-SYSAREA(R1),C'1'   FOR NON-XA SYSTEM\n         MVI   KWDFLEN-KWDTABLE+SYSKWDTB-SYSAREA(R1),X'00'  NON-XA\n.XA1JOIN LR    R5,R1\n         ST    R5,JMRUCOM          SAVE AREA ADDRESS\n         USING SYSAREA,R5\nSMF000   DS    0H\n*\n*   FILL IN DATA CAPTURED FROM SMF\n*\n         MVC   SYSSMF,JMRCPUID     SAVE SMF SYSID\n         MVC   SYSID,JMRCPUID+3    SAVE SYSTEM ID (1-BYTE)\n         MVC   SYSTSO,SYSID\n         MVC   SYSZONE,SYSID\n         TR    SYSTSO,TSOXLATE     TRANSLATE TO TSO\n         TR    SYSZONE,ZONEXLAT    TRANSLATE TO ZONE\n         DROP  R2                  ALL DONE WITH JMR\nDATE000  DS    0H\n*\n*  FILL IN DATE/TIME DATA\n*\n         TIME  DEC                 GET CURRENT DATE\n         ST    R1,WRKPACK+4        SAVE IT\n         MVC   SYSJDATE,=X'2120202020'\n         ED    SYSJDATE,WRKPACK+5\n         MVC   WRKYRTAB,YEARTAB    CREATE YEAR TABLE\n         TM    WRKPACK+5,X'01'     LEAP YEAR?\n         BO    DATE010             NO ...\n         TM    WRKPACK+5,X'12'     REALLY A LEAP YEAR?\n         BM    DATE010             NO ...\n         MVI   WRKFEB,29           ELSE FEBRUARY HAS 29 DAYS.\nDATE010  DS    0H\n         AP    WRKPACK+4(4),=PL4'1900000'  CONVERT 0CYY TO YYYY\n         MVC   SYSYEAR,=X'21202020'\n         ED    SYSYEAR,WRKPACK+4   MOVE IN THE YEAR\n         MVC   WRKPACK(6),=XL6'00' BLANK OUT THE YEAR\n         ZAP   WRKDAYP,WRKPACK     SAVE PACKED DAY-OF-YEAR\n         SR    R0,R0\n         SR    R14,R14\n         CVB   R1,WRKPACK          CONVERT DAYS TO BINARY\n         LA    R15,WRKYRTAB-4      AND SCAN THE YEAR TABLE:\nDATE020  DS    0H\n         SLR   R1,R0               DECREMENT \"DAYS REMAINING\"\n         LA    R15,4(,R15)         NEXT YEAR TABLE ENTRY (MONTH)\n         LA    R14,1(,R14)         KEEP A MONTH COUNTER\n         IC    R0,0(,R15)          DAYS IN CURRENT MONTH\n         CLR   R0,R1               PAST END OF MONTH?\n         BL    DATE020             NO - GO TRY NEXT ENTRY.\n         CVD   R1,WRKPACK          CONVERT DAYS LEFT\n         UNPK  SYSDD,WRKPACK+6(2)  ... UNPACK IT ...\n         OI    SYSDD+1,X'F0'       ... SET THE SIGN.\n         MVC   SYSMONTH,1(R15)     MOVE IN THE MONTH NAME\n         CVD   R14,WRKPACK         CONVERT MONTH NUMBER\n         UNPK  SYSMM,WRKPACK+6(2)  ... UNPACK IT ...\n         OI    SYSMM+1,X'F0'       ... SET THE SIGN.\n         PACK  WRKPACK,SYSYEAR     RE-PACK THE FULL YEAR.\n         SP    WRKPACK,=PL8'1984'    SUBTRACT BASE YEAR\n         DP    WRKPACK,=PL1'4'     NUMBER OF LEAP YEARS BETWEEN\n         MP    WRKPACK(7),=P'1461' BASE NUMBER OF DAYS ...\n         CP    WRKPACK+7(1),=PL1'0'  ANY YEARS LEFT OVER?\n         BNH   DATE040\nDATE030  DS    0H\n         AP    WRKPACK(7),=PL7'365'  LEFTOVER DAYS ...\n         SP    WRKPACK+7(1),=PL1'1'\n         BP    DATE030\nDATE040  DS    0H\n         AP    WRKPACK(7),WRKDAYP   ADD TODAY IN JULIAN ...\n         DP    WRKPACK(7),=PL1'7'    DIVIDE BY DAYS IN THE WEEK ...\n         MVC   WRKPACK+7(1),WRKPACK+6\n         MVC   WRKPACK(7),=XL7'00'\n         CVB   R1,WRKPACK          CONVERT TO BINARY\n         ALR   R1,R1\n         ALR   R1,R1               MULT BY ENTRY LENGTH (4).\n         LA    R1,DAYTABLE(R1)\n         MVC   SYSWD,0(R1)         MOVE IN DAY NUMBER.\n         MVC   SYSWKDY,1(R1)       MOVE IN DAY NAME.\nVTAM000  DS    0H\n*\n*   FILL IN DATA FROM VTAM\n*\n         L     R1,1032             GET VTAM ATCVT ADDRESS,\n         L     R1,1080(,R1)        GET VTAM SUBAREA ADDRESS,\n         C     R1,=F'99'           SUBAREA OUT OF BOUNDS?\n         BNH   VTAM010             NO - CONTINUE ON.\n         MVC   SYSSUBA,=C'##'      ELSE INDICATE OVERFLOW\n         B     VTAM020\nVTAM010  DS    0H\n         CVD   R1,WRKPACK          CONVERT TO DECIMAL ...\n         UNPK  SYSSUBA-1(3),WRKPACK+6(2)   ... THEN TO CHARACTER\n         OI    SYSSUBA+1,X'F0'             ... THEN SET THE SIGN.\nVTAM020  DS    0H\n         EJECT\n*\n*   WE HAVE OBTAINED AND INITIALIZED AN AREA WITH THE VALUES TO\n*   REPLACE FOR KEYWORDS.  IT IS NOW TIME TO SCAN FOR KEYWORDS\n*   AND IF ANY ARE FOUND, TO REPLACE THEM WITH THEIR VALUES.\n*\nAREAGOT  DS    0H\n         LA    R0,KWDTAB\n         ST    R0,SYSKWDTB+KWDNEXT-KWDTABLE\n         LA    R0,WRK512           ADDRESS OF KWDREPL WORK AREA\n         ST    R0,WRKPARMS\n         LA    R14,70(R4)          END OF JCL IMAGE\n         LA    R15,SYSKWDTB        KEYWORD TABLE ADDRESS\n         LR    R0,R5               FIELD VALUE DSECT\n         STM   R14,R0,WRKPARMS+8   SAVE FOR KWDREPL PARAMETERS\n         LR    R9,R14              SAVE ENDING POSITION\n         LA    R10,0(R4)           STARTING POSITION\nSCANJCL  DS    0H\n         LR    R6,R9               ENDING ADDRESS - STARING ADDRESS\n         SR    R6,R10              = (LENGTH-1) FOR TRT.\n         BM    RETURN1             IF NO CHARS LEFT, WE ARE DONE.\n         EX    R6,SCANTRT          FIND KWDCHAR\n         BC    B'1011',RETURN1     -THERE IS NO KWDCHAR\n         LR    R10,R1              SAVE THE KWDCHAR POSITION\n         ST    R1,WRKPARMS+4       ADDRESS OF THE KWDCHAR\n         LA    R1,WRKPARMS         POINT TO PARM LIST\n         L     R15,=V(KWDREPL)     AND CALL ...\n         BALR  R14,R15             ... THE REPLACEMENT ROUTINE.\n         C     R15,=F'4'           VALID KEYWORD REPLACEMENT?\n         BL    SCANJCL             YES -GO RESCAN IT.\n         LA    R10,1(,R10)         BUMP PAST NON-KEYWORD KWDCHAR\n         B     SCANJCL\nSCANTRT  TRT   0(*-*,R10),QUESTTRT\nKILLAREA DS    0H\n         L     R3,0(,R3)           GET JMR ADDRESS\n         USING JMR,R3\n         ICM   R1,15,JMRUCOM       IS THERE AN AREA?\n         BZ    RETURN0             NO - SO DONT FREE IT.\n         LA    R0,SYSLEN\n         AIF   ('&SYSSPLV' EQ '1').NOTXA2\n         FREEMAIN RU,LV=(0),A=(1),SP=SYSSP\n         AGO   .XA2JOIN\n.NOTXA2  ICM   R0,8,=AL1(SYSSP)\n         FREEMAIN R,LV=(0),A=(1)\n.XA2JOIN XC    JMRUCOM,JMRUCOM     CLEAR THE ADDRESS TOO\n         B     RETURN0\n         DROP  R3                  FINISHED WITH JMR\nRETURN1  DS    0H                  FREE WORKAREA AND RETURN\n         ESTAE 0                   CANCEL ESTAE EXIT\n         B     RTRYRTN2\nRTRYRTN1 DS    0H\n         LM    R12,R13,8(R1)  LOAD REGS FOR ESTAE PARM LIST\nRTRYRTN2 DS    0H\n         LR    R1,R13              SAVE WORKAREA ADDRESS\n         L     R13,4(R13)          CHAIN BACK SAVE AREA\n         LA    R0,WORKSIZE         GET AREA LENGTH\n         AIF   ('&SYSSPLV' EQ '1').NOTXA3\n         FREEMAIN RU,LV=(0),A=(1),SP=WRKSP\nRETURN0  DS    0H                  RETURN WITH NO WORKAREA\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         SR    R15,R15             SET RC=0\n         BSM   0,R14               RETURN XA-STYLE\n         AGO   .XA3JOIN\n.NOTXA3  ICM   R0,8,=AL1(WRKSP)    ... AND SUBPOOL\n         FREEMAIN  R,LV=(0),A=(1)\nRETURN0  DS    0H\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         SR    R15,R15             SET RC=0\n         BR    R14                 RETURN 370-STYLE\n.XA3JOIN ANOP\n         TITLE 'ESTAE RECOVERY ROUTINE '\n         DROP\nRECOVERY DS    0H           COMMON ENTRY POINT\n         USING *,R12\n         LR    R12,R15\n         LR    R10,R14      SAVE RETURN ADDRESS\n         LA    R4,4\n         CR    R0,R4        IS THERE A SDWA?\n         BNE   HAVESDWA     YES - BR TO PROCESS WITH SDWA\n         SDUMP MF=(E,SDUMPL) TAKE SVC DUMP\n         L     R0,0(R2)      LOAD RETRY ROUTINE ADDRESS\n         LA    R15,4         SET RETCODE TO RETRY ADDR IN R0\n         LR    R14,R10       RESTORE RETURN ADDRESS\n         BR    R14\nHAVESDWA DS    0H\n         ST    R14,12(R13)   SAVE RETURN ADDRESS\n         LR    R10,R1\n         USING SDWA,R10\n         SDUMP MF=(E,SDUMPL)  TAKE AN SVC DUMP\n         L     R2,SDWAPARM    LOAD PARAM LIST ADDR FROM SDWA\n         MVC   SDWASR12,8(R2) RESTORE BASE REG\n         MVC   SDWASR13,12(R2) RESTORE BASE REG\n         SETRP RC=4,RETADDR=(2),RETREGS=YES,FRESDWA=YES,REGS=(14),     X\n               WKAREA=(10)    RETURN WITH RETRY\n*        BR    14             GENERATED BY SETRP EXPANSION\nSDUMPL   SDUMP HDRAD=SDUMPH,SDATA=(LPA,RGN,CSA),MF=L\nSDUMPH   DC    AL1(L'SDUMPT)\nSDUMPT   DC    C'IEFUJV  -- SMF USER EXIT ABEND '\n         TITLE 'CONSTANTS '\n         LTORG\nESTAEL   ESTAE MF=L                MODEL ESTAE PARM LIST\nLESTAEL  EQU   *-ESTAEL\nZONEXLAT DC    256C'#'             (INVALID DASD ZONES)\n         ORG   ZONEXLAT+C'A'\n         DC    C'BBA'              VALID ZONES\n         ORG   ,\nTSOXLATE DC    256C'#'             (INVALID TSO NAMES)\n         ORG   TSOXLATE+C'A'\n         DC    C'HIJ'              VALID TSO\nYEARTAB  DC    AL1(31),C'JAN',AL1(28),C'FEB',AL1(31),C'MAR'\n         DC    AL1(30),C'APR',AL1(31),C'MAY',AL1(30),C'JUN'\n         DC    AL1(31),C'JUL',AL1(31),C'AUG',AL1(30),C'SEP'\n         DC    AL1(31),C'OCT',AL1(30),C'NOV',AL1(255),C'DEC'\nDAYTABLE DC    C'7SAT1SUN2MON3TUE4WED5THU6FRI'\nQUESTTRT DC    256X'00'            TRT TABLE TO FIND \"?\"\n         ORG   QUESTTRT+C'&KWDCHAR'\n         DC    X'04'\n         ORG   ,\n         TITLE 'KEYWORD TABLE FOR SYMBOLIC SUBSTITUTION '\nKEYWORDS DS    0A\n         KEYWORD &KWDCHAR.SYSXAMODE,SYSXA,SYSAREA \"XA\" IN XA, NULL O.W.\n         KEYWORD END-OF-TABLE\nKWDFRLEN EQU   *-KEYWORDS\nKWDTAB   DS    0A\n         KEYWORD &KWDCHAR.SYSSPLV,SYSSPLV,SYSAREA \"1\" IF 370, \"2\" IF XA\n         KEYWORD &KWDCHAR.SYSSMF,SYSSMF,SYSAREA SYSTEM SMF ID (4-CHAR)\n         KEYWORD &KWDCHAR.SYSID,SYSID,SYSAREA LAST CHAR. OF SMF ID\n         KEYWORD &KWDCHAR.SYSTSO,SYSTSO,SYSAREA TSOXLATE SYSID\n         KEYWORD &KWDCHAR.SYSZONE,SYSZONE,SYSAREA ZONEXLAT SYSID\n         KEYWORD &KWDCHAR.SYSSUBA,SYSSUBA,SYSAREA VTAM HOST SUBAREA\n         KEYWORD &KWDCHAR.SYSYEAR,SYSYEAR,SYSAREA YEAR (YYYY)\n         KEYWORD &KWDCHAR.SYSDATE,SYSDATE,SYSAREA DATE (YYMMDD)\n         KEYWORD &KWDCHAR.SYSYY,SYSYY,SYSAREA YEAR (YY)\n         KEYWORD &KWDCHAR.SYSMM,SYSMM,SYSAREA MONTH (MM)\n         KEYWORD &KWDCHAR.SYSDD,SYSDD,SYSAREA DAY OF MONTH (DD)\n         KEYWORD &KWDCHAR.SYSJDATE,SYSJDATE,SYSAREA JULIAN DATE (YYDDD)\n         KEYWORD &KWDCHAR.SYSWD,SYSWD,SYSAREA WEEKDAY (1-DIGIT, 1-7)\n         KEYWORD &KWDCHAR.SYSWKDY,SYSWKDY,SYSAREA WEEKDAY (3-CHAR)\n         KEYWORD &KWDCHAR.SYSMONTH,SYSMONTH,SYSAREA MONTH (3-CHAR)\n         KEYWORD END-OF-TABLE\n         TITLE 'DSECTS, AND EQUATES '\nSYSAREA  DSECT\nSYSSP    EQU   230                 SUBPOOL FOR SYS AREA\nSYSKWDTB DS    0A\n         KEYWORD &KWDCHAR.SYSXAMODE,SYSSPLV,SYSAREA\n         KEYWORD END-OF-TABLE\nSYSSMF   DS    CL4                 SMF NAME\nSYSID    DS    CL1                 SYSTEM SUFFIX\nSYSTSO   DS    CL1                 TSO SUFFIX\nSYSZONE  DS    CL1                 DASD SUFFIX\n         DS    CL1                 FILLER\nSYSSUBA  DS    CL2                 VTAM SUBAREA\nSYSYEAR  DS    0CL4                YEAR (YYYY)\n         DS    CL2                 CENTURY\nSYSDATE  DS    0CL6                DATE (YYMMDD)\nSYSYY    DS    CL2                 YEAR\nSYSMM    DS    CL2                 MONTH\nSYSDD    DS    CL2                 DAY\nSYSJDATE DS    CL5                 JULIAN DATE (YYDDD)\nSYSWD    DS    CL1                 WEEKDAY (1-7)\nSYSWKDY  DS    CL3                 WEEKDAY (ABBREV.)\nSYSMONTH DS    CL3                 MONTH\nSYSSPLV  DS    CL1                 \"1\" OR \"2\"\nSYSXA    DS    CL2                 \"XA\" OR NULL\n         DS    0D\nSYSLEN   EQU   *-SYSAREA\n         SPACE 3\nWORK     DSECT\nWRKSP    EQU   230                 SUBPOOL FOR WORK AREA\n         DS    18F                 STANDARD SAVE AREA\nWRKPACK  DS    D\nWRKESTAW DS    XL(LESTAEL)         ESTAE PARM LIST AREA\nWRKESTAP DS    4F                  PARM LIST TO RETRY ROUTINE\n*              RETRY ROUTINE ADDRESS  NO SDWA OBTAINED\n*              RETRY ROUTINE ADDRESS  SDWA OBTAINED\n*              BASE REGISTER R12\n*              DATA REGISTER R13\nWRKPARMS DS    5F                  PARMS FOR KWDREPL\nWRKYRTAB DS    XL(4*12)\nWRKFEB   EQU   WRKYRTAB+4\nWRKDAYP  DS    PL2\n         DS    0D\nWRK512   DS    512X'00'\n         DS    0D\nWORKSIZE EQU   *-WORK\n         SPACE 3\n         KWDTABLE\n         SPACE 3\nJMR      DSECT\n         IEFJMR\n         IHASDWA\n         EQUREGS\n         END   IEFUJV\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IGGPRE00": {"ttr": 1800, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PRE00    TITLE 'IGGPRE00 - DADSM PRE-PROCESSING EXIT'\n***********************************************************************\n* IGGPRE00  -  DADSM PRE-PROCESSING EXIT                              *\n*                                                                     *\n*  FUNCTION:  THIS EXIT TESTS FOR PRESENCE OF HCCDADSM ROUTINE AND    *\n*             LINKS TO IT IF IT IS PRESENT.                           *\n*                                                                     *\n*  ATTRIBUTES: KEY 0, SUPERVISOR, ENABLED, REENTRANT, NO LOCKS HELD.  *\n*              AMODE=ANY, RMODE=24                                    *\n*                                                                     *\n*  WRITTEN ON 01/20/87 BY BILL WARRINER, UMCHC                        *\n*                                                                     *\n***********************************************************************\n         GBLC  &SYSSPLV\n         EJECT\nIGGPRE00 CSECT\n         CONNECT  WORKSIZE,WORK,BASE=R12,PARM=R11,CLEAR=YES,           X\n               COPYRT=1987,AMODE=ANY,RMODE=24,LOC=BELOW\n         L     R1,16               GET CVT ADDRESS\n         ICM   R1,X'F',CVTUSER-CVT(R1) NCT ADDRESS IF PRESENT\n         BZ    RETN00              IF NOT PRESENT, ALLOW REQUEST.\n         ICM   R15,X'F',NCTDADSM-NCT(R1) IS HCCDADSM PRESENT?\n         BZ    RETN00              IF NOT PRESENT, ALLOW REQUEST.\n         LR    R1,R11              RESTORE PARM POINTER\n         L     R0,R0PRE            SET R0 TO INDICATE PRE-PROCESS\n         AIF   ('&SYSSPLV' EQ '1').NOTXA1\n         BASSM R14,R15             LINK TO ROUTINE XA-STYLE\n         AGO   .XA1DONE\n.NOTXA1  BALR  R14,R15\n.XA1DONE B     RETURN\nRETN00   DS    0H\n         SR    R15,R15             SET R15=0\nRETURN   DS    0H\n         RELEASE WORKSIZE,RC=(R15)\n         SPACE 3\nR0PRE    DC    A(0)                R0=0 IF PRE-PROCESS EXIT\nR0POST   DC    A(4)                R0=4 IF POST-PROCESS EXIT\n         LTORG\nWORK     DSECT\nREGSAVE  DS    18F\n         DS    0D\nWORKSIZE EQU   *-WORK\n         EQUREGS\nNCT      NCT   TYPE=DSECT\n         CVT   DSECT=YES\n         END   IGGPRE00\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INIDADSM": {"ttr": 1802, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "INID     TITLE 'INIDADSM - BUILDS  PARAMETER BLOCK FOR HCCDADSM '\nINIDADSM CSECT\n         GBLC  &SYSSPLV\n***********************************************************************\n*  I N I D A D S M  -  PGM TO SETUP HCCDADSM PARAMETER BLOCK          *\n*                                                                     *\n*  FUNCTION - SCANS A PARMLIB MEMBER AND USES THE INITIALIZATION      *\n*             STATEMENTS TO BUILD A PARAMETER BLOCK FOR USE BY THE    *\n*             HCCDADSM ROUTINE.                                       *\n*                                                                     *\n*  JCL:       //DADSM   PROC  M=00      DEFAULT MEMBER NAME           *\n*             //DADSM   EXEC  PGM=INIDADSM                            *\n*             //IEFPARM DD    DDNAME=IEFRDER                          *\n*             //IEFRDER DD    DSN=SYS1.PARMLIB(DADSMP&M),DISP=SHR     *\n*             //*                                                     *\n*                                                                     *\n*            (NOTE THE PROGRAM RUNS AUTHORIZED OUT OF THE LINK LIST). *\n*                                                                     *\n*  ATTRIBUTES:  RENT, REUS, REFR, AC(1)                               *\n*                                                                     *\n*  MAPPING MACROS:  NCT, CVT, DCBD, IHAPSA, IHAWSAVT, DADSMBLK.       *\n*                                                                     *\n*  OTHER MACROS: CONNECT, RELEASE, OPEN, CLOSE, GETMAIN, FREEMAIN,    *\n*                GET, WTO, SETLOCK, MODESET.                          *\n*                                                                     *\n*  WRITTEN 1/27/87 BY BILL WARRINER, UMCHC                            *\n*                                                                     *\n*  UPDATE HISTORY:                                                    *\n*     03/09/88  WJW - MODIFIED TO SUPPORT 'OVERRIDE' PREFIX LIST.     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         MACRO\n&LABEL   GETREC\n&LABEL   SETAMODE 24\n         GET   IEFPARM\n         SETAMODE 31\n         MEND\n         SPLEVEL TEST\nINIDADSM CSECT\n         CONNECT  =A(WORKSIZE),WORK,BASE=(R12,R11),COPYRT=(1987,1988), X\n               LI=L,AMODE=ANY,RMODE=24,LOC=BELOW\n         LA    R0,DSA\n         L     R1,=A(DSALEN)\n         LA    R14,DSADMY\n         L     R15,=A(DSADMYLN)\n         MVCL  R0,R14                  INITIALIZE DYNAMIC STORAGE\n         L     R1,16\n         CLC   CVTUSER-CVT(4,R1),=A(0)  IS THERE AN NCT?\n         BE    NONCT\n         SETAMODE 24\n         OPEN  (IEFPARM,(INPUT)),MF=(E,OPENLST)\n         SETAMODE 31\n         LA    R1,IEFPARM\n         TM    DCBOFLGS-IHADCB(R1),DCBOFOPN   OPEN SUCCESSFUL?\n         BNZ   PARMOPEN\n         WTO   MF=(E,WTOPNOPN)\n         MVC   RETCODE,=H'12'\n         B     RETURN\nPARMOPEN DS    0H\nCARDLOOP DS    0H                  LOOP THROUGH CARD IMAGES\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nCHARLOOP DS    0H\n         CLI   0(R2),C' '          LEADING BLANK?\n         BE    BLANK1\n         CLC   =C'/*',0(R2)        COMMENT?\n         BE    COMMENT1\n         CLC   =C'PROTECT ',0(R2)  PROTECT STATEMENT?\n         BE    PROTECT1\n         WTO   MF=(E,WTOBCTL)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nBLANK1   DS    0H\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    CHARLOOP\n         B     CARDLOOP\nCOMMENT1 DS    0H\n         BAL   R14,COMMENTX\n         CR    R2,R3\n         BL    CHARLOOP\n         B     CARDLOOP\nPROTECT1 DS    0H\n         MVC   VOLSER,=CL6' '\n         XC    VOLFGS,VOLFGS\n         XC    VOLNPFX,VOLNPFX\n         XC    VOLNOVR,VOLNOVR\n         LA    R0,VOLPFX\n         LA    R1,EVOLPFX-VOLPFX\n         SR    R15,R15\n         ICM   R15,X'8',=C' '\n         MVCL  R0,R14\n         LA    R2,8(R2)\n         CR    R2,R3\n         BL    PROT020\nPROT010  DS    0H\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nPROT020  DS    0H\n         CLI   0(R2),C' '\n         BE    BLANK2\n         CLC   =C'/*',0(R2)\n         BE    COMMENT2\n         SR    R15,R15\n         B     PROT030\nBLANK2   DS    0H\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    PROT020\n         B     PROT010\nCOMMENT2 DS    0H\n         BAL   R14,COMMENTX\n         CR    R2,R3\n         BL    PROT020\n         B     PROT010\nPROT030  DS    0H\n         LA    R15,1(R15)\n         CH    R15,=H'6'\n         BNH   PROT032\n         WTO   MF=(E,WTOBVSER)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nPROT032  DS    0H\n         LA    R14,VOLSER-1(R15)\n         MVC   0(1,R14),0(R2)\n         LA    R2,1(R2)\n         CR    R2,R3\n         BNL   PROT035\n         CLI   0(R2),C','\n         BE    PROT040\n         CLI   0(R2),C' '\n         BNE   PROT030\nPROT035  DS    0H\n         WTO   MF=(E,WTONPROT)\n         CLC   RETCODE,=H'4'\n         BH    *+10\n         MVC   RETCODE,=H'4'\n         B     CARDLOOP\nPROT040  DS    0H\n         CLI   0(R2),C' '\n         BE    PROT900\n         CLI   0(R2),C','\n         BE    PROT050\n         CLC   =C'/*',0(R2)\n         BE    COMMENT3\n         LA    R0,4(R2)\n         CR    R0,R3\n         BNL   PROT042\n         CLC   =C'UIDCK',0(R2)\n         BE    UID1\n         LA    R0,5(R2)\n         CR    R0,R3\n         BNL   PROT042\n         CLC   =C'TEMPDS',0(R2)\n         BE    TEMP1\n         CLC   =C'MIGVOL',0(R2)\n         BE    MIGV1\n         LA    R0,6(R2)\n         CR    R0,R3\n         BNL   PROT042\n         CLC   =C'PREFIX(',0(R2)\n         BE    PREFIX1\n         CLC   =C'NOUIDCK',0(R2)\n         BE    NOUID1\n         LA    R0,7(R2)\n         CR    R0,R3\n         BNL   PROT042\n         CLC   =C'NOTEMPDS',0(R2)\n         BE    NOTEMP1\n         CLC   =C'GLOBALCK',0(R2)\n         BE    GLOB1\n         CLC   =C'NOMIGVOL',0(R2)\n         BE    NOMIGV1\n         LA    R0,8(R2)\n         CR    R0,R3\n         BNL   PROT042\n         CLC   =C'NOPREFIX(',0(R2)\n         BE    NOPRFX1\n         CLC   =C'OVERRIDE(',0(R2)\n         BE    OVRPRF1\n         LA    R0,9(R2)\n         CR    R0,R3\n         BNL   PROT042\n         CLC   =C'NOGLOBALCK',0(R2)\n         BE    NOGLOB1\nPROT042  DS    0H\n         WTO   MF=(E,WTOBKWD)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nPROT050  DS    0H\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    PROT055\nPROT051  DS    0H\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nPROT052  DS    0H\n         CLI   0(R2),C' '\n         BNE   PROT040\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    PROT052\nPROT055  DS    0H\n         CLI   0(R2),C' '\n         BE    PROT051\n         B     PROT040\nCOMMENT3 DS    0H\n         BAL   R14,COMMENTX\n         B     PROT900\nPROT900  DS    0H\n         ICM   R4,X'F',ANCHOR\n         BZ    PROT950             NOT FOUND\nPROT910  DS    0H\n         CLC   VOLSER,8(R4)        DUPLICATE VOLUME?\n         BE    PROT920\n         CLC   =A(0),0(R4)         ANOTHER CHAIN?\n         BE    PROT950\n         L     R4,0(R4)\n         B     PROT910\nPROT920  DS    0H\n         WTO   MF=(E,WTO2VSER)\n         MVC   RETCODE,=H'8'\n         B     PROT990\nPROT950  DS    0H\n         LA    R0,TMPPFXST-TEMPDSCT\n         SR    R15,R15\n         IC    R15,VOLNPFX\n         MH    R15,=H'9'\n         STH   R15,VOLPFXL\n         AR    R0,R15\n         SR    R15,R15\n         IC    R15,VOLNOVR\n         MH    R15,=H'9'\n         AR    R0,R15\n         A     R0,=F'7'\n         C     R0,=A(X'00FFFFFF')  TOO LARGE?\n         BNH   PROT960\n         WTO   MF=(E,WTOVSIZE)\n         MVC   RETCODE,=H'8'\n         B     PROT990\nPROT960  DS    0H\n         N     R0,=A(X'00FFFFF8')  ROUND TO NEXT MULTIPLE OF 8\n         ST    R0,VOLLEN\n         GETMAIN  R,LV=(0)\n         L     R4,ANCHOR            CHAIN OF TEMP AREAS\n         ST    R1,ANCHOR            -ADD TO CHAIN.\n         ST    R4,0(R1)             ...\n         LR    R4,R1\n         LA    R0,4(R4)\n         L     R1,VOLLEN\n         S     R1,=F'4'\n         SR    R15,R15\n         MVCL  R0,R14               CLEAR THE NEW BLOCK\n         USING TEMPDSCT,R4\n         MVC   TMPLENG,VOLLEN\n         MVC   TMPVSER,VOLSER\n         MVC   TMPFLGS,VOLFGS\n         MVC   TMPNPFX,VOLNPFX\n         MVC   TMPNOVR,VOLNOVR\n         LH    R15,VOLPFXL        GET LENGTH OF PREFIX STRING\n         STH   R15,TMPLPFX        SAVE LENGTH OF PREFIX STRING\n         CH    R15,=H'0'\n         BNH   PROT980\n         LA    R14,TMPPFXST\n         LA    R0,VOLPFX\n         LR    R1,R15\n         MVCL  R14,R0\nPROT980  DS    0H\n         SR    R15,R15\n         IC    R15,VOLNOVR\n         CH    R15,=H'0'\n         BNH   PROT985\n         MH    R15,=H'9'\n         LH    R1,TMPLPFX\n         LA    R14,TMPPFXST(R1)\n         LA    R0,VOLOVR\n         LR    R1,R15\n         MVCL  R14,R0\nPROT985  DS    0H\nPROT990  DS    0H\n         B     CARDLOOP\n         DROP  R4\nNOPRFX1  DS    0H\n         TM    VOLFG2,PREFIXSP\n         BNO   NPRF010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nNPRF010  DS    0H\n         OI    VOLFG2,PREFIXSP\n         OI    VOLFG1,DSMEXCPF\n         LA    R2,9(R2)\n         B     PREF011\nPREFIX1  DS    0H                  \"PREFIX\" SPECIFIED\n         TM    VOLFG2,PREFIXSP     ALREADY SPEC'D?\n         BNO   PREF010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nPREF010  DS    0H\n         OI    VOLFG2,PREFIXSP\n         NI    VOLFG1,X'FF'-DSMEXCPF\n         LA    R2,7(R2)\nPREF011  DS    0H\n         CR    R2,R3\n         BL    PREF020\nPREF015  DS    0H\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nPREF020  DS    0H\n         CLI   0(R2),C')'          RIGHT PAREN?\n         BE    PREF900\n         CLI   0(R2),C','          COMMA?\n         BE    PREF050\n         CLC   =C'/*',0(R2)        COMMENT?\n         BE    COMMENT4\n         SR    R1,R1\n         IC    R1,VOLNPFX\n         CH    R1,=Y(255)\n         BL    PREF022\n         WTO   MF=(E,WTONPFX)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nCOMMENT4 DS    0H\n         BAL   R14,COMMENTX\n         CR    R2,R3\n         BL    PREF020\n         B     PREF060\nPREF022  DS    0H\n         MH    R1,=H'9'            STARTING OFFSET\n         SR    R15,R15             CHARACTER COUNT\nPREF030  DS    0H\n         LA    R15,1(R15)\n         CH    R15,=H'8'           PREFIX TOO LONG?\n         BNH   PREF032\n         WTO   MF=(E,WTOLPFX)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nPREF032  DS    0H\n         LA    R14,VOLPFX(R1)\n         LA    R14,0(R14,R15)\n         MVC   0(1,R14),0(R2)\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    PREF036\n         WTO   MF=(E,WTOBCONT)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nPREF036  DS    0H\n         CLI   0(R2),C','          END OF PREFIX?\n         BE    PREF040\n         CLI   0(R2),C')'          END OF PREFIX?\n         BE    PREF040\n         CLI   0(R2),C' '          BLANK IS ALSO END, BUT INVALID\n         BNE   PREF030\n         WTO   MF=(E,WTOCOMMA)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nPREF040  DS    0H\n         LA    R14,VOLPFX(R1)\n         STC   R15,0(R14)          SAVE LENGTH FIELD\n         SR    R15,R15\n         IC    R15,VOLNPFX\n         LA    R15,1(,R15)\n         STC   R15,VOLNPFX\n         CLI   0(R2),C')'          END OF ALL PREFIXES?\n         BE    PREF900\nPREF050  DS    0H\n         LA    R2,1(R2)\n         CR    R2,R3\n         BNL   PREF060\n         CLI   0(R2),C' '\n         BNE   PREF020\nPREF060  DS    0H\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nPREF064  DS    0H\n         CLI   0(R2),C' '\n         BNE   PREF020\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    PREF064\n         BCTR  R2,0                BACKUP TO BLANK\nPREF900  DS    0H\n         CLI   0(R2),C')'\n         BE    PREF920\n         WTO   MF=(E,WTOPAREN)\n         CLC   RETCODE,=H'4'\n         BNL   *+10\n         MVC   RETCODE,=H'4'\n         BCTR  R2,0\nPREF920  DS    0H\n         LA    R2,1(R2)\n         B     KWDEND\n         EJECT\nOVRPRF1  DS    0H                  \"OVERRIDE\" SPECIFIED\n         TM    VOLFG2,OVERSP       ALREADY SPEC'D?\n         BNO   OVER010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nOVER010  DS    0H\n         OI    VOLFG2,OVERSP\n         LA    R2,9(R2)\nOVER011  DS    0H\n         CR    R2,R3\n         BL    OVER020\nOVER015  DS    0H\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nOVER020  DS    0H\n         CLI   0(R2),C')'          RIGHT PAREN?\n         BE    OVER900\n         CLI   0(R2),C','          COMMA?\n         BE    OVER050\n         CLC   =C'/*',0(R2)        COMMENT?\n         BE    COMMENT5\n         SR    R1,R1\n         IC    R1,VOLNOVR\n         CH    R1,=Y(255)\n         BL    OVER022\n         WTO   MF=(E,WTONOVR)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nCOMMENT5 DS    0H\n         BAL   R14,COMMENTX\n         CR    R2,R3\n         BL    OVER020\n         B     OVER060\nOVER022  DS    0H\n         MH    R1,=H'9'            STARTING OFFSET\n         SR    R15,R15             CHARACTER COUNT\nOVER030  DS    0H\n         LA    R15,1(R15)\n         CH    R15,=H'8'           PREFIX TOO LONG?\n         BNH   OVER032\n         WTO   MF=(E,WTOLOVR)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nOVER032  DS    0H\n         LA    R14,VOLOVR(R1)\n         LA    R14,0(R14,R15)\n         MVC   0(1,R14),0(R2)\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    OVER036\n         WTO   MF=(E,WTOBCONT)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nOVER036  DS    0H\n         CLI   0(R2),C','          END OF PREFIX?\n         BE    OVER040\n         CLI   0(R2),C')'          END OF PREFIX?\n         BE    OVER040\n         CLI   0(R2),C' '          BLANK IS ALSO END, BUT INVALID\n         BNE   OVER030\n         WTO   MF=(E,WTOCOMMA)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nOVER040  DS    0H\n         LA    R14,VOLOVR(R1)\n         STC   R15,0(R14)          SAVE LENGTH FIELD\n         SR    R15,R15\n         IC    R15,VOLNOVR\n         LA    R15,1(,R15)\n         STC   R15,VOLNOVR\n         CLI   0(R2),C')'          END OF ALL PREFIXES?\n         BE    OVER900\nOVER050  DS    0H\n         LA    R2,1(R2)\n         CR    R2,R3\n         BNL   OVER060\n         CLI   0(R2),C' '\n         BNE   OVER020\nOVER060  DS    0H\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nOVER064  DS    0H\n         CLI   0(R2),C' '\n         BNE   OVER020\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    OVER064\n         BCTR  R2,0                BACKUP TO BLANK\nOVER900  DS    0H\n         CLI   0(R2),C')'\n         BE    OVER920\n         WTO   MF=(E,WTOPAREN)\n         CLC   RETCODE,=H'4'\n         BNL   *+10\n         MVC   RETCODE,=H'4'\n         BCTR  R2,0\nOVER920  DS    0H\n         LA    R2,1(R2)\n         B     KWDEND\n         EJECT\nUID1     DS    0H\n         TM    VOLFG2,UIDSP        ALREADY SPEC'D?\n         BNO   UID010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nUID010   DS    0H\n         LA    R2,5(R2)\n         OI    VOLFG2,UIDSP\n         OI    VOLFG1,DSMECKUS\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   UID020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'UIDCK'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    UID020\n         MVC   RETCODE,=H'4'\nUID020   DS    0H\n         B     KWDEND\n         EJECT\nNOUID1   DS    0H\n         TM    VOLFG2,UIDSP        ALREADY SPEC'D?\n         BNO   NOU010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nNOU010   DS    0H\n         LA    R2,7(R2)\n         OI    VOLFG2,UIDSP\n         NI    VOLFG1,X'FF'-DSMECKUS\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   NOU020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'NOUIDCK'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    NOU020\n         MVC   RETCODE,=H'4'\nNOU020   DS    0H\n         B     KWDEND\n         EJECT\nMIGV1    DS    0H\n         TM    VOLFG2,MIGVSP       ALREADY SPEC'D?\n         BNO   MIG010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nMIG010   DS    0H\n         LA    R2,6(R2)\n         OI    VOLFG2,MIGVSP\n         OI    VOLFG1,DSMEHSMP\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   MIG020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'MIGVOL'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    MIG020\n         MVC   RETCODE,=H'4'\nMIG020   DS    0H\n         B     KWDEND\n         EJECT\nNOMIGV1  DS    0H\n         TM    VOLFG2,MIGVSP       ALREADY SPEC'D?\n         BNO   NOMG010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nNOMG010  DS    0H\n         LA    R2,8(R2)\n         OI    VOLFG2,MIGVSP\n         NI    VOLFG1,X'FF'-DSMEHSMP\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   NOMG020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'NOMIGVOL'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    NOMG020\n         MVC   RETCODE,=H'4'\nNOMG020  DS    0H\n         B     KWDEND\n         EJECT\nTEMP1    DS    0H\n         TM    VOLFG2,TEMPSP       ALREADY SPEC'D?\n         BNO   TMP010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nTMP010   DS    0H\n         LA    R2,6(R2)\n         OI    VOLFG2,TEMPSP\n         NI    VOLFG1,X'FF'-DSMENTMP\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   TMP020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'TEMPDS'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    TMP020\n         MVC   RETCODE,=H'4'\nTMP020   DS    0H\n         B     KWDEND\n         EJECT\nNOTEMP1  DS    0H\n         TM    VOLFG2,TEMPSP       ALREADY SPEC'D?\n         BNO   NTM010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nNTM010   DS    0H\n         LA    R2,8(R2)\n         OI    VOLFG2,TEMPSP\n         OI    VOLFG1,DSMENTMP\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   NTM020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'NOTEMPDS'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    NTM020\n         MVC   RETCODE,=H'4'\nNTM020   DS    0H\n         B     KWDEND\n         EJECT\nGLOB1    DS    0H\n         TM    VOLFG2,GLOBSP       ALREADY SPEC'D?\n         BNO   GBL010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nGBL010   DS    0H\n         LA    R2,8(R2)\n         OI    VOLFG2,GLOBSP\n         NI    VOLFG1,X'FF'-DSMENGBL\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   GBL020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'GLOBALCK'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    GBL020\n         MVC   RETCODE,=H'4'\nGBL020   DS    0H\n         B     KWDEND\n         EJECT\nNOGLOB1  DS    0H\n         TM    VOLFG2,GLOBSP       ALREADY SPEC'D?\n         BNO   NGB010\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\nNGB010   DS    0H\n         LA    R2,10(R2)\n         OI    VOLFG2,GLOBSP\n         OI    VOLFG1,DSMENGBL\n         CLC   VOLSER,=CL6'GLOBAL'\n         BNE   NGB020\n         MVC   WTOGEN(WTOGKLN),WTOGKWD\n         MVC   WTOGEN+14(8),=CL10'NOGLOBALCK'\n         WTO   MF=(E,WTOGEN)\n         CLC   RETCODE,=H'4'\n         BH    NGB020\n         MVC   RETCODE,=H'4'\nNGB020   DS    0H\n         B     KWDEND\n         EJECT\nKWDEND   DS    0H\n         CR    R2,R3\n         BNL   PROT900\n         CLI   0(R2),C' '\n         BE    PROT900\n         CLI   0(R2),C','\n         BE    PROT040\n         WTO   MF=(E,WTOKCON)\n         MVC   RETCODE,=H'8'\n         B     CARDLOOP\n         EJECT\nCOMMENTX DS    0H\n         ST    R14,RETSAVE\n         LA    R2,1(R2)\nCOMM010  DS    0H\n         LA    R2,1(R2)\n         CR    R2,R3\n         BL    COMM020\n         GETREC\n         LR    R2,R1               SAVE STARTING ADDRESS\n         MVC   WTOCARD,0(R1)\n         WTO   MF=(E,WTOLIST)      ECHO CARD TO CONSOLE\n         LA    R3,72(R2)           SAVE ENDING ADDRESS\nCOMM020  DS    0H\n         CLC   =C'*/',0(R2)\n         BNE   COMM010\n         LA    R2,2(R2)\n         L     R14,RETSAVE\n         BR    R14\n         EJECT\nEODAD    DS    0H\n         CLOSE (IEFPARM),MF=(E,OPENLST)\n         SETAMODE 31\n         CLC   RETCODE,=H'8'\n         BL    EOD005\n         WTO   MF=(E,WTOPSKIP)\n         B     RETURN\nEOD005   DS    0H\n         SR    R1,R1                  COUNT OF CHARACTERS NEEDED\n         SR    R3,R3                  NUMBER OF ENTRIES\n         ICM   R2,X'F',ANCHOR\n         BZ    FREEITP\n         USING TEMPDSCT,R2\nEODLOOP  DS    0H\n         SR    R5,R5               COUNT OF PREFIX CHARS.\n         LA    R3,1(R3)            KEEP COUNT OF ENTRIES ALSO\n         SR    R15,R15\n         IC    R15,TMPNPFX         GET # OF PREFIXES:\n         CH    R15,=H'0'\n         BNH   EOD010\n         LA    R14,TMPPFXST        POINT TO FIRST ENTRY\nPFXLOOP  DS    0H\n         SR    R4,R4\n         IC    R4,0(R14)           PICK UP LENGTH\n         LA    R5,1(R5,R4)\n         LA    R14,9(R14)\n         BCT   R15,PFXLOOP         GO TRY NEXT PREFIX\n         B     EOD020\nEOD010   DS    0H\n         XC    TMPNPFX,TMPNPFX\n         SR    R5,R5\nEOD020   DS    0H\n         ST    R5,WORKA            SAVE NUMBER OF PREFIX BYTES\n         SR    R5,R5\n         SR    R15,R15\n         IC    R15,TMPNOVR\n         CH    R15,=H'0'\n         BNH   EOD030\n         LH    R4,TMPLPFX\n         LA    R14,TMPPFXST\n         ALR   R14,R4              POINT TO START OF OVERRIDES\nOVRLOOP  DS    0H\n         SR    R4,R4\n         IC    R4,0(R14)           PICK UP LENGTH\n         LA    R5,1(R5,R4)         ADD IT IN\n         LA    R14,9(R14)          GO TRY NEXT OVERRIDE\n         BCT   R15,OVRLOOP\n         B     EOD040\nEOD030   DS    0H\n         XC    TMPNOVR,TMPNOVR\n         SR    R5,R5\nEOD040   DS    0H\nEOD090   DS    0H\n         A     R5,WORKA            ADD IN NUMBER OF PREFIX BYTES\n         LA    R1,DSMEPLST-DADSMENT+3(R5,R1)\n         N     R1,=A(X'00FFFFFC')  ALLOW PADDING TO FULLWORD\n         ICM   R2,X'F',TMPCHAIN    GO GET NEXT ONE\n         BNZ   EODLOOP\n         DROP  R2\n         STH   R3,NENTRIES\n         LA    R1,DSMPSTRT-DADSMPRM+7(R1)\n         C     R1,=A(X'00FFFFFF')\n         BNH   EOD095\n         WTO   MF=(E,WTOPSIZE)\n         MVC   RETCODE,=H'12'\n         B     RETURN\nEOD095   DS    0H\n         N     R1,=A(X'00FFFFF8')\n         ST    R1,GMLEN\n         LR    R9,R1\n         MODESET  MF=(E,SUPERVIS)\n         AIF   ('&SYSSPLV' EQ '1').NOTXA1\nSET1     SETLOCK  OBTAIN,TYPE=CPU,REGS=USE,RELATED=FREE1\n         GETMAIN  RU,LV=(9),BNDRY=PAGE,KEY=0,SP=DADSMSP,               X\n               BRANCH=(YES,GLOBAL),LOC=(ANY,ANY)\n         LR    R10,R1              AND SAVE ITS ADDRESS\nFREE1    SETLOCK  RELEASE,TYPE=CPU,REGS=USE,RELATED=SET1\n         AGO   .XAJOIN1\n.NOTXA1  ANOP\nSET1     SETLOCK  OBTAIN,TYPE=SALLOC,REGS=USE,RELATED=FREE1,           X\n               MODE=UNCOND\n         GETMAIN  RU,LV=(9),BNDRY=PAGE,KEY=0,SP=DADSMSP,               X\n               BRANCH=(YES,GLOBAL)\n         LR    R10,R1              AND SAVE ITS ADDRESS\nFREE1    SETLOCK  RELEASE,TYPE=SALLOC,REGS=USE,RELATED=SET1\n.XAJOIN1 ANOP\n         ST    R10,NEWBLK\n         LR    R0,R10\n         L     R1,GMLEN\n         SR    R15,R15\n         MVCL  R0,R14\n         L     R2,NEWBLK\n         USING DADSMPRM,R2\n         MVC   DSMPLEN,GMLEN+1\n         MVI   DSMPSP,DADSMSP\n         MVC   NEWSPLN,DSMPSP\n         MVC   DSMPID,=CL8'DADSMPRM'\n         LH    R5,NENTRIES\n         STH   R5,DSMPNENT\n         LA    R2,DSMPSTRT\n         DROP  R2\n         USING DADSMENT,R2\n         SR    R4,R4\n         ICM   R1,X'F',ANCHOR\n         BZ    COPYDONE\n         USING TEMPDSCT,R1\nCOPYLOOP DS    0H\n         MVC   DSMEVOLI,TMPVSER\n         MVC   DSMEFLG1,TMPFLGS\n         MVC   DSMENPFX,TMPNPFX\n         MVC   DSMENOVR,TMPNOVR\n         LA    R3,TMPPFXST\n         LA    R14,DSMEPLST\n         SR    R5,R5               ACCUM PREFIX CHARACTERS\n         SR    R15,R15\n         IC    R15,DSMENPFX\n         CH    R15,=H'0'\n         BNH   CPFXNONE\nCPFXLOOP DS    0H\n         IC    R4,0(R3)\n         CH    R4,=H'0'            ANY CHARS?\n         BNH   CPFX010\n         STC   R4,0(R14)\n         LA    R5,1(R4,R5)         BUMP UP CURRENT COUNT\n         BCTR  R4,0\n         EX    R4,CPFXMVC\n         LA    R14,2(R4,R14)       BUMP TO NEXT FIELD\n         LA    R3,9(R3)\n         B     CPFX020\nCPFX010  DS    0H\n         SR    R0,R0\n         IC    R0,DSMENPFX\n         SH    R0,=H'1'\n         STC   R0,DSMENPFX\n         BNP   CPFXNONE\nCPFX020  DS    0H\n         BCT   R15,CPFXLOOP\n         B     CPFXDONE\nCPFXNONE DS    0H\n         LA    R14,DSMEPLST\n         XC    DSMENPFX,DSMENPFX\n         XC    DSMELPFX,DSMELPFX\n         NI    DSMEFLG1,X'FF'-(DSMECKPF+DSMEXCPF)\n         B     COPYOVER\nCPFXDONE DS    0H\n         OI    DSMEFLG1,DSMECKPF   IF SO, FLAG AS \"PREFIX-CHECK\" ENTRY\n         STH   R5,DSMELPFX\nCOPYOVER DS    0H\n         LA    R3,TMPPFXST\n         LH    R0,TMPLPFX          GET OFFSET TO OVERRIDES\n         ALR   R3,R0               POINT TO START OF OVERRIDES\n         SR    R15,R15\n         IC    R15,DSMENOVR\n         CH    R15,=H'0'\n         BNH   COVRNONE\nCOVRLOOP DS    0H\n         SR    R4,R4\n         IC    R4,0(R3)\n         CH    R4,=H'0'\n         BNH   COVR010\n         STC   R4,0(R14)          SAVE LENGTH FIELD\n         BCTR  R4,0\n         EX    R4,CPFXMVC\n         LA    R14,2(R4,R14)       BUMP TO NEXT FIELD\n         LA    R3,9(R3)\n         B     COVR020\nCOVR010  DS    0H\n         SR    R0,R0\n         IC    R0,DSMENOVR\n         SH    R0,=H'1'\n         STC   R0,DSMENOVR\n         BNP   COVRNONE\nCOVR020  DS    0H\n         BCT   R15,COVRLOOP\n         B     COVRDONE\nCOVRNONE DS    0H\n         LA    R14,DSMEPLST\n         LH    R0,DSMELPFX\n         ALR   R14,R0\n         XC    DSMENOVR,DSMENOVR\nCOVRDONE DS    0H\nCOPYNEXT DS    0H\n         LA    R14,3(R14)\n         N     R14,=A(X'7FFFFFFC') ALIGN TO FULLWORD\n         ST    R14,DSMENEXT        POINT TO NEXT ENTRY\n         LR    R6,R2               SAVE LAG POINTER\n         LR    R2,R14\n         ICM   R1,X'F',TMPCHAIN\n         BNZ   COPYLOOP\nCOPYDONE DS    0H\n         DROP  R1\n         LR    R2,R6               RESTORE \"LAST ONE\" POINTER\n         XC    DSMENEXT,DSMENEXT\n         B     FREEIT\n         DROP  R2\nFREEITP  DS    0H\n         MODESET  MF=(E,SUPERVIS)\nFREEIT   DS    0H\n         L     R1,16\n         ICM   R10,X'F',CVTUSER-CVT(R1)\n         BZ    NCTERR\n         LA    R8,NCTDAPRM-NCT(R10)\n         MVC   ENQPARM,ENQDMMY\n         ENQ   (QNAME,(R8),E,4,SYSTEM),MF=(E,ENQPARM)\n         MVC   OLDBLK,NCTDAPRM-NCT(R10)\n         MVC   NCTDAPRM-NCT(4,R10),NEWBLK\n         LA    R8,OLDBLK\n         MVC   DEQPARM,DEQDMMY\n         DEQ   (QNAME,(R8),4,SYSTEM),MF=(E,DEQPARM)\n         L     R10,OLDBLK\n         LTR   R10,R10\n         BZ    FREEDONE\n         MVC   OLDSPLN,DSMPSP-DADSMPRM(R10)\n         SR    R8,R8\n         ICM   R8,B'0001',OLDSPLN   GET SUBPOOL NUMBER\n         SR    R9,R9\n         ICM   R9,B'0111',OLDSPLN+1 GET LENGTH\n         AIF   ('&SYSSPLV' EQ '1').NOTXA3\nSET2     SETLOCK  OBTAIN,TYPE=CPU,REGS=USE,RELATED=FREE2\n         AGO   .XAJOIN3\n.NOTXA3  ANOP\nSET2     SETLOCK  OBTAIN,TYPE=SALLOC,REGS=USE,RELATED=FREE2,           X\n               MODE=UNCOND\n.XAJOIN3 ANOP\n         FREEMAIN RC,A=(10),KEY=0,LV=(9),BRANCH=(YES,GLOBAL),SP=(8)\n         AIF   ('&SYSSPLV' EQ '1').NOTXA4\nFREE2    SETLOCK  RELEASE,TYPE=CPU,REGS=USE,RELATED=SET2\n         AGO   .XAJOIN4\n.NOTXA4  ANOP\nFREE2    SETLOCK  RELEASE,TYPE=SALLOC,REGS=USE,RELATED=SET2\n.XAJOIN4 ANOP\nFREEDONE DS    0H\n         MODESET  MF=(E,PROBLEM)\n         CLC   NEWBLK,=A(0)\n         BE    TSTFREE\n         MVC   WTOGEN(ALOCWTOL),ALOCWTO\n         UNPK  ALOCW@@(9),NEWBLK(5)\n         TR    ALOCW@@,HEXLATE\n         MVI   ALOCW@@+8,C' '\n         UNPK  ALOCWSL(9),NEWSPLN(5)\n         TR    ALOCWSL,HEXLATE\n         MVI   ALOCWSL+8,C' '\n         WTO   MF=(E,WTOGEN)\nTSTFREE  DS    0H\n         CLC   OLDBLK,=A(0)\n         BE    RETURN\n         MVC   WTOGEN(FREEWTOL),FREEWTO\n         UNPK  FREEW@@(9),OLDBLK(5)\n         TR    FREEW@@,HEXLATE\n         MVI   FREEW@@+8,C' '\n         UNPK  FREEWSL(9),OLDSPLN(5)\n         TR    FREEWSL,HEXLATE\n         MVI   FREEWSL+8,C' '\n         WTO   MF=(E,WTOGEN)\n         B     RETURN\nNCTERR   DS    0H\n         MODESET  MF=(E,PROBLEM)\nNONCT    DS    0H\n         WTO   MF=(E,WTONONCT)\n         MVC   RETCODE,=H'16'\nRETURN   DS    0H\n         L     R2,ANCHOR\nRETNLOOP DS    0H\n         LTR   R1,R2\n         BZ    RETNWTO\n         L     R2,0(R1)\n         L     R0,4(R1)\n         FREEMAIN  R,LV=(0),A=(1)\n         B     RETNLOOP\nRETNWTO  DS    0H\n         MVC   WTOGEN(TERMWTOL),TERMWTO\n         UNPK  WTOGEN+48(5),RETCODE(3)\n         TR    WTOGEN+48(4),HEXLATE\n         MVI   WTOGEN+52,C' '\n         WTO   MF=(E,WTOGEN)\n         LH    R15,RETCODE\n         RELEASE =A(WORKSIZE),RC=(R15),LI=L\n         EJECT\nCPFXMVC  MVC   1(*-*,R14),1(R3)    SKELETON FOR EX\nENQDMMY  ENQ   (QNAME,0,E,4,SYSTEM),MF=L\nENQLEN   EQU   *-ENQDMMY\nDEQDMMY  DEQ   (QNAME,0,4,SYSTEM),MF=L\nDEQLEN   EQU   *-DEQDMMY\nQNAME    DC    CL8'DADSMBLK'\nWTONONCT WTO   'INID001S  INIDADSM UNABLE TO LOCATE NCT',              X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTOPNOPN WTO   'INID002S  INIDADSM UNABLE TO OPEN IEFPARM FILE',       X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTOBCTL  WTO   'INID003E  INVALID  CONTROL CARD IS IGNORED',           X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTOBVSER WTO   'INID004E  INVALID  VOLUME SERIAL, CARD IGNORED',       X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTONPROT WTO   'INID005W  NO PROTECTION ATTRIBUTES ASSIGNED, CONTROL CAX\n               RD IGNORED',ROUTCDE=(2),DESC=(4),MF=L\nWTOBKWD  WTO   'INID006E  INVALID KEYWORD - CONTROL CARD IGNORED',     X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTO2VSER WTO   'INID007E  DUPLICATE VOLSER - CONTROL CARD IGNORED',    X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTOVSIZE WTO   'INID008E  VOLSER ENTRY SIZE OVERFLOW - CONTROL CARD IGNX\n               ORED',ROUTCDE=(2),DESC=(4),MF=L\nWTOKCON  WTO   'INID009E  KEYWORD CONFLICT - CONTROL CARD IGNORED',    X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTONPFX  WTO   'INID010E  TOO MANY PREFIXES SPECIFIED - CONTROL CARD IGX\n               NORED',ROUTCDE=(2),DESC=(4),MF=L\nWTOLPFX  WTO   'INID011E  PREFIX TOO LONG - CONTROL CARD IGNORED',     X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTONOVR  WTO   'INID010E  TOO MANY OVERRIDE PREFIXES SPECIFIED - CONTROX\n               L CARD NORED',ROUTCDE=(2),DESC=(4),MF=L\nWTOLOVR  WTO   'INID011E  OVERRIDE PREFIX TOO LONG - CONTROL CARD IGNORX\n               ED',ROUTCDE=(2),DESC=(4),MF=L\nWTOBCONT WTO   'INID012E  INVALID CONTINUATION - CONTROL CARD IGNORED',X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTOCOMMA WTO   'INID013E  COMMA OR RIGHT PAREN MISSING - CONTROL CARD IX\n               GNORED',ROUTCDE=(2),DESC=(4),MF=L\nWTOPAREN WTO   'INID014W  ENDING PAREN ASSUMED ON CONTROL CARD',       X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTOGKWD  WTO   'INID015W  XXXXXXXXXX KEYWORD ON GLOBAL DEFINITION IGNORX\n               ED',ROUTCDE=(2),DESC=(4),MF=L\nWTOGKLN  EQU   *-WTOGKWD\nWTOPSIZE WTO   'INID016E  INIDADSM PARM BLOCK SIZE OVERFLOW, PROCESSINGX\n               TERMINATED',ROUTCDE=(2),DESC=(4),MF=L\nALOCWTO  WTO   'INID000I  NEW DADSMBLK ALLOCATED AT XXXXXXXX YYYYYYYY  X\n               ',ROUTCDE=(2),DESC=(4),MF=L\nALOCW@@  EQU   WTOGEN+40,8,C'C'\nALOCWSL  EQU   WTOGEN+49,8,C'C'\nALOCWTOL EQU   *-ALOCWTO\nFREEWTO  WTO   'INID000I  DADSMBLK AT XXXXXXXX YYYYYYYY REPLACED ',    X\n               ROUTCDE=(2),DESC=(4),MF=L\nFREEW@@  EQU   WTOGEN+26,8,C'C'\nFREEWSL  EQU   WTOGEN+35,8,C'C'\nFREEWTOL EQU   *-FREEWTO\nWTOPSKIP WTO   'INID017E  INIDADSM PROCESSING SKIPPED DUE TO PREVIOUS EX\n               RRORS',ROUTCDE=(2),DESC=(4),MF=L\nTERMWTO  WTO   'INID099I  INIDADSM PROCESSING COMPLETED, RC=XXXX ',    X\n               ROUTCDE=(2),DESC=(4),MF=L\nTERMWTOL EQU   *-TERMWTO\nSUPERVIS MODESET  KEY=ZERO,MODE=SUP,MF=L\nPROBLEM  MODESET  KEY=NZERO,MODE=PROB,MF=L\nDSADMY   DS    0D\n         DCB   DSORG=PS,EODAD=EODAD,MACRF=GL,RECFM=FB,LRECL=80,        X\n               DDNAME=IEFPARM\n         OPEN  (0,(INPUT)),MF=L\n         WTO   '          ----+----1----+----2----+----3----+----4----+X\n               ----5----+----6----+----7----+----8',                   X\n               ROUTCDE=(2),DESC=(4),MF=L\nDSADMYLN EQU   *-DSADMY\nHEXLATE  EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n         EJECT\nWORK     DSECT\nREGSAVE  DS    18F\nDSA      DS    0D\nIEFPARM  DCB   DSORG=PS,EODAD=EODAD,MACRF=GL,RECFM=FB,LRECL=80,        X\n               DDNAME=IEFPARM\nOPENLST  OPEN  (0,),MF=L\nWTOLIST  WTO   '          ----+----1----+----2----+----3----+----4----+X\n               ----5----+----6----+----7----+----8',                   X\n               ROUTCDE=(2),DESC=(4),MF=L\nWTOCARD  EQU   WTOLIST+14,80,C'C'\nWTOGEN   WTO   '          ----+----1----+----2----+----3----+----4----+X\n               ----5----+----6----+----7----+----8----+----9----+----0'X\n               ,ROUTCDE=(2),DESC=(4),MF=L\nRETSAVE  DC    A(0)\nENQPARM  DS    CL(ENQLEN)\n         ORG   ENQPARM\nDEQPARM  DS    CL(DEQLEN)\n         ORG\nRETCODE  DC    H'0'\nNENTRIES DC    H'0'\nGMLEN    DC    F'0'\nNEWBLK   DC    A(0)\nNEWSPLN  DC    A(0)\nOLDBLK   DC    A(0)\nOLDSPLN  DC    A(0)\nANCHOR   DC    A(0)\nWORKA    DC    A(0)\nVOLSER   DC    CL6' '\nVOLNPFX  DC    X'0'\nVOLNOVR  DC    X'0'\nVOLLEN   DC    F'0'\nVOLFGS   DS    0XL2\nVOLFG1   DC    X'00'\nVOLFG2   DC    X'00'\nPREFIXSP EQU   X'80'\nUIDSP    EQU   X'40'\nTEMPSP   EQU   X'20'\nGLOBSP   EQU   X'10'\nMIGVSP   EQU   X'08'\nOVERSP   EQU   X'04'\nVOLPFXL  DC    H'0'\nVOLPFX   DC    (255)CL9' '\nEVOLPFX  DS    0X\nVOLOVR   DC    (255)CL9' '\nEVOLOVR  DS    0X\n         DS    0D\nDSALEN   EQU   *-DSA\nWORKSIZE EQU   *-WORK\nTEMPDSCT DSECT\nTMPCHAIN DS    A                     CHAIN TO NEXT TEMP DSECT\nTMPLENG  DS    F                     LENGTH OF THIS DSECT\nTMPVSER  DS    CL6                   VOLUME SERIAL\nTMPFLGS  DS    XL2                   FLAGS\nTMPNOVR  DS    XL1                   # OVERRIDE ENTRIES\nTMPNPFX  DS    XL1                   # PREFIX ENTRIES\nTMPLPFX  DS    AL2                   LENGTH OF PREFIX STRING (HERE)\nTMPHDRLN EQU   *-TEMPDSCT            LENGTH OF TEMP DSECT HEADER\nTMPPFXST DS    0X                    START OF PREFIX STRING\n*                                    OVERRIDE STRING IMMED. FOLLOWS.\n         EQUREGS\nNCT      NCT   TYPE=DSECT\n         DADSMBLK\n         PRINT NOGEN\n         CVT   DSECT=YES\n         DCBD\n         IHAPSA DSECT=YES\n         IHAWSAVT DSECT=YES,CLASS=GLOBAL\n         END   INIDADSM\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INITNCT": {"ttr": 2312, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "INITNCT  TITLE 'INITNCT - PROGRAM TO INITIALIZE NCT AFTER IPL'\nINITNCT  CSECT\n***********************************************************************\n* FUNCTION - OBTAINS COMMON STORAGE FOR THE NETWORK CONTROL TABLE     *\n*     THEN INITIALIZES IT.  THE NCT IS A USER CVT (ADDRESSED FROM     *\n*     THE CVTUSER FIELD IN THE MVS CVT) USED TO ANCHOR VARIOUS        *\n*     CONTROL BLOCKS/MODULES.                                         *\n*                                                                     *\n*     IF AN NCT ALREADY EXISTS, THE OPERATOR WILL BE PROMPTED TO      *\n*     \"R\" (RELOAD) OR \"B\" (BYPASS INITIALIZATION).  IF THE REPLY      *\n*     IS \"R\", ALL LOAD MODULE ADDRESSES IN THE NCT WILL BE REFRESHED. *\n*     NOTE THAT ALL MODULES ADDRESSED VIA THE NCT MUST RESIDE IN      *\n*     COMMON STORAGE.                                                 *\n*                                                                     *\n*     ATTRIBUTES:  AC=1                                               *\n*                                                                     *\n*     FOR A LIST OF LOAD MODULES ADDRESSED FROM THE NCT, SEE          *\n*     LABEL \"LOADMODS\".                                               *\n*                                                                     *\n*     MACROS:  MODESET, SETLOCK, GETMAIN, FREEMAIN, SPLEVEL           *\n*                                                                     *\n*     WRITTEN ON 05/15/86 BY BILL WARRINER, UMC HOSPITAL AND CLINICS. *\n*                                                                     *\n***********************************************************************\nINITNCT  CSECT\nINITNCT  AMODE 31\nINITNCT  RMODE 24\n         GBLC  &SYSSPLV\n         SPLEVEL TEST\n         USING INITNCT,R15\n         B     PASTCONS\n         DC    AL1(L'EPID)\nEPID     DC    C'INITNCT &SYSDATE..&SYSTIME.  '\n         DC    C'COPYRIGHT(C) 1986 BY THE CURATORS OF THE UNIVERSITY OFX\n                MISSOURI'\nPASTCONS DS    0H\n         DROP  R15\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R8,R15\n         USING INITNCT,R8          SETUP BASE REGISTER\n         ST    R1,PARMADDR         SAVE PARAMETER ADDRESS\n         LA    R1,REGSAVE\n         XC    MAXCC,MAXCC\n         ST    R13,4(R1)\n         ST    R1,8(R13)\n         LR    R13,R1\n         L     R7,16\n         USING CVT,R7\n         L     R6,CVTUSER\n         C     R6,=A(0)            IS THERE ALREADY AN NCT?\n         BNE   ALLOC\n         MODESET  KEY=ZERO,MODE=SUP\n         AIF   ('&SYSSPLV' EQ '1').NOTXA1\nSET1     SETLOCK  OBTAIN,TYPE=CPU,REGS=USE,                            X\n               RELATED=FREE1\n         GETMAIN  RU,LV=NCTLEN,SP=NCTSP,KEY=0,BRANCH=(YES,GLOBAL),     X\n               BNDRY=PAGE,LOC=BELOW\n         LA    R9,0(,R1)\nFREE1    SETLOCK RELEASE,TYPE=CPU,REGS=USE,RELATED=SET1\n         AGO   .XA1DONE\n.NOTXA1  ANOP\nSET1     SETLOCK  OBTAIN,TYPE=SALLOC,REGS=USE,MODE=UNCOND,             X\n               RELATED=FREE1\n         GETMAIN  RU,LV=NCTLEN,SP=NCTSP,KEY=0,BRANCH=(YES,GLOBAL),     X\n               BNDRY=PAGE\n         LA    R9,0(,R1)\nFREE1    SETLOCK RELEASE,TYPE=SALLOC,REGS=USE,RELATED=SET1\n.XA1DONE USING NCT,R9\n         XC    0(NCTLEN,R9),0(R9)\n         MVC   NCTSPLN,TSTSPLN       COPY IN SUBPOOL,LENGTH\n         MVC   NCTIDBLK,=CL4'NCT'\n         MVC   NCTID,=CL4'HCC'\n         TIME  DEC\n         ST    R1,NCTIPLDT\n         ST    R0,NCTIPLTM\n         ICM   R1,X'F',CVTSMCA\n         BZ    SMFDONE\n         USING SMCABASE,R1\n         MVC   NCTCPUID,SMCASID\n         DROP  R1\nSMFDONE  DS    0H\n         BAL   R4,LOADNCT\nNCTDONE  DS    0H\n         CS    R6,R9,CVTUSER      SAVE NCT ADDRESS IN CVTUSER FIELD\n         BC    SWAPFAIL,ALLOC2\n         MODESET  KEY=NZERO,MODE=PROB\n         WTO   'NCT000I  NCT INITIALIZATION COMPLETED',                X\n               ROUTCDE=(2),DESC=(4)\n         SR    R15,R15\n         B     RETURN\nALLOC2   DS    0H\n         BAL   R4,ERASENCT        ERASE AND DELETE LOAD MODULE ADDRXS\n         MODESET  KEY=NZERO,MODE=PROB\n         B     NOALLOC\nREALLOC  DS    0H\n         LR    R9,R6\n         CLC   NCTSPLN,TSTSPLN\n         BNE   NEEDIPL\n         MODESET  KEY=ZERO,MODE=SUP\n         BAL   R4,LOADNCT         RELOAD NCT LOAD MODULES\n         MODESET  KEY=NZERO,MODE=PROB\n         SR    R15,R15\n         B     RETURN\nNEEDIPL  DS    0H\n         WTO   'NCT009E  IPL REQUIRED TO REFORMAT NCT',                X\n               ROUTCDE=(2),DESC=(4)\n         B     NOALLOC\nALLOC    DS    0H\n         XC    WTORECB,WTORECB\n         WTOR  'NCT002A  NCT FOUND, REPLY ''R'' TO RELOAD OR ''B'' TO BX\n               YPASS INITIALIZATION',WTOREPLY,1,WTORECB,ROUTCDE=(1)\n         WAIT  ECB=WTORECB,LONG=YES\n         CLI   WTOREPLY,C'R'\n         BE    REALLOC\n         CLI   WTOREPLY,C'B'\n         BNE   ALLOC\nNOALLOC  DS    0H\n         WTO   'NCT001E  NCT INITIALIZATION ERROR, NCT ALREADY PRESENT'X\n               ,ROUTCDE=(2),DESC=(4)\n         MVC   MAXCC,=H'8'\nRETURN   DS    0H\n         LH    R15,MAXCC\n         L     R13,4(R13)\n         XC    8(4,R13),8(R13)\n         L     R14,12(R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         EJECT\nLOADNCT  DS    0H\n         ST    R4,RETNSUB1\n         LA    R4,LOADMODS        GET LOAD MODULE LIST\nLOADLOOP DS    0H\n         CLI   0(R4),X'FF'        END OF LIST?\n         BE    LOADDONE\n         LOAD  EPLOC=0(R4),GLOBAL=YES,ERRET=NOLOAD,SF=(E,LOADPRM)\nLOADOK   DS    0H\n         SR    R1,R1\n         ICM   R1,B'0111',9(R4)   GET OFFSET IN NCT\n         ST    R0,NCT(R1)         SAVE ENTRY POINT ADDRESS\n         MVC   WTOLOAD+20(8),0(R4)\n         WTO   MF=(E,WTOLOAD)\n         B     LOADNEXT\nNOLOAD   DS    0H\n         SR    R1,R1\n         ICM   R1,B'0111',9(R4)\n         LA    R1,NCT(R1)\n         XC    0(4,R1),0(R1)\n         MVC   NCT003E+20(8),0(R4)\n         WTO   MF=(E,NCT003E)\nLOADNEXT DS    0H\n         LA    R4,LMODELNG(R4)    POINT TO NEXT ENTRY\n         B     LOADLOOP           AND GO LOAD IT.\nLOADDONE DS    0H                 ALL MODULES LOADED\n         XC    NCTSMASK,NCTSMASK  INITIALIZE SYSTEM MASK ...\n         ICM   R4,X'F',PARMADDR   PICKUP PARAMETER ...\n         BZ    TSODONE\n         L     R4,0(,R4)          GET ADDRESS ...\n         LH    R1,0(R4)           GET LENGTH\n         CH    R1,=H'0'           IS THERE A PARM?\n         BNH   TSODONE\n         CH    R1,=H'3'           TOO LONG?\n         BH    BADPARM\n         MVC   SMASKCHR,=CL3'000'\n         LA    R15,SMASKCHR+2\n         BCTR  R1,0               DEX FOR MVC\n         SR    R15,R1             BACKUP TO PLACE\n         EX    R1,PARMCOPY        COPY PARM INTO TSOPREFIX\n         TRT   SMASKCHR,NUMTAB    IS IT NUMERIC?\n         BNZ   BADPARM\n         PACK  SMASKPAK,SMASKCHR\n         CP    SMASKPAK,=P'255'   IS IT IN RANGE?\n         BH    BADPARM\n         CVB   R1,SMASKPAK\n         STC   R1,NCTSMASK\n         UNPK  NCT004I+32(3),NCTSMASK(2)\n         TR    NCT004I+32(2),HEXLATE\n         MVI   NCT004I+34,C' '\n         WTO   MF=(E,NCT004I)\n         B     TSODONE\nBADPARM  DS    0H\n         MVC   NCT005E+31(8),=CL8'        '\n         LH    R1,0(R4)           GET THE PARAMETER LENGTH\n         CH    R1,=H'0'\n         BNH   ISSU005E\n         CH    R1,=H'8'\n         BNH   *+8\n         LH    R1,=H'8'\n         BCTR  R1,0\n         EX    R1,PRMECOPY\nISSU005E DS    0H\n         WTO   MF=(E,NCT005E)\n         CLC   MAXCC,=H'8'\n         BH    TSODONE\n         MVC   MAXCC,=H'8'\nTSODONE  DS    0H\n         CLI   NCTSMASK,0\n         BNE   MASKOK\n         WTO   MF=(E,NCT006W)\n         CLC   MAXCC,=H'4'\n         BH    MASKOK\n         MVC   MAXCC,=H'4'\nMASKOK   DS    0H\n         L     R4,RETNSUB1\n         BR    R4\nPARMCOPY MVC   0(*-*,R15),2(R4)\nPRMECOPY MVC   NCT005E+31(*-*),2(R4)\n         EJECT\nERASENCT DS    0H\n         STM   R4,R5,RETNSUB1\n         LA    R4,LOADMODS\nERASLOOP DS    0H\n         CLI   0(R4),X'FF'        END OF LIST?\n         BE    ERASDONE\n         SR    R5,R5\n         ICM   R5,B'0111',9(R4)   GET NCT OFFSET OF ADDRESS\n         LA    R5,NCT(R5)         POINT TO ADDRESS FIELD\n         CLC   =A(0),0(R5)        WAS IT LOADED?\n         BE    ERASNEXT           NO - SKIP THIS ENTRY.\n         XC    0(4,R5),0(R5)      ZERO OUT THE ADDRESS\nERASNEXT DS    0H\n         LA    R4,LMODELNG(R4)\n         B     ERASLOOP\nERASDONE DS    0H\n         AIF   ('&SYSSPLV' EQ '1').NOTXA2\nERASSET  SETLOCK  OBTAIN,TYPE=CPU,REGS=USE,                            X\n               RELATED=ERASFREE\n         LA    R1,NCT\n         FREEMAIN  RU,LV=NCTLEN,SP=NCTSP,KEY=0,BRANCH=(YES,GLOBAL),    X\n               A=(1)\nERASFREE SETLOCK RELEASE,TYPE=CPU,REGS=USE,RELATED=ERASSET\n         AGO   .XA2DONE\n.NOTXA2  ANOP\nERASSET  SETLOCK  OBTAIN,TYPE=SALLOC,REGS=USE,MODE=UNCOND,             X\n               RELATED=ERASFREE\n         LA    R1,NCT\n         FREEMAIN  RU,LV=NCTLEN,SP=NCTSP,KEY=0,BRANCH=(YES,GLOBAL),    X\n               A=(1)\nERASFREE SETLOCK RELEASE,TYPE=SALLOC,REGS=USE,RELATED=ERASSET\n.XA2DONE LM    R4,R5,RETNSUB1\n         BR    R4\n         DROP  R8\nSWAPFAIL EQU   B'0111'\nLOADMODS DS    0F\n         DC    CL8'HCCDADSM'\n         DC    AL1(0)          FLAGS\n         DC    AL3(NCTDADSM-NCT)\nLMODELNG EQU   *-LOADMODS\n*\n         DC    XL1'FF'         FLAG END-OF-LIST\nWTOLOAD  WTO   'NCT000I  MODULE XXXXXXXX NOW REPLACED IN NCT',         X\n               ROUTCDE=(2),DESC=(4),MF=L\nNCT003E  WTO   'NCT003E  MODULE XXXXXXXX NOT IN NCT - MODULE NOT FOUND X\n                OR NOT AUTHORIZED',ROUTCDE=(1),DESC=(3),MF=L\nNCT004I  WTO   'NCT004I  SYSTEM MASK SET TO XX ',                      X\n               ROUTCDE=(2),DESC=(4),MF=L\nNCT005E  WTO   'NCT005E  INVALID PARAMETER,         , IGNORED.',       X\n               ROUTCDE=(1),DESC=(3),MF=L\nNCT006W  WTO   'NCT006W  SYSTEM MASK IS 0, TSO LOGONS WILL NOT BE ALLOWX\n               ED UNTIL IT IS RESET',ROUTCDE=(1),DESC=(3),MF=L\nLOADPRM  LOAD  EPLOC=0,GLOBAL=YES,ERRET=NOLOAD,SF=L\n         LTORG\nTSTSPLN  DC    AL1(NCTSP),AL3(NCTLEN)\n         DS    0D\nREGSAVE  DS    18F\nPARMADDR DS    A\nRETNSUB1 DS    2F\nWTORECB  DC    A(0)\nSMASKPAK DC    PL8'0'\nMAXCC    DC    H'0'\nWTOREPLY DS    CL1\nSMASKCHR DC    CL3'000'\nNUMTAB   DC    256XL1'01'\n         ORG   NUMTAB+C'0'\n         DC    10XL1'00'\n         ORG\nHEXLATE  EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n         EQUREGS\n         IHAPSA  DSECT=YES\n         IHAWSAVT  DSECT=YES,CLASS=GLOBAL\nNCT      NCT\n         CVT   DSECT=YES\n         IEESMCA\n         END   INITNCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPLDATE": {"ttr": 2564, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "IPLD     TITLE 'IPLDATE - PROGRAM TO EXTRACT AND DISPLAY LAST IPL DATE'\n         PUNCH '  ALIAS  IPLTIME  '\nIPLDATE  CSECT\n***********************************************************************\n* IPLDATE - TSO CP TO EXTRACT LAST IPL DATE/TIME FROM THE NCT AND     *\n*     DISPLAY IT TO THE USERS TERMINAL.                               *\n*                                                                     *\n*  MACROS - CONNECT, RELEASE, NCT, CVT                                *\n*                                                                     *\n*  ATTRIBUTES - RENT, REUS, REFR.                                     *\n*                                                                     *\n*  WRITTEN ON 06/03/87 BY BILL WARRINER, UMC HOSPITAL AND CLINICS     *\n*                                                                     *\n***********************************************************************\n         EJECT\n         CONNECT  WORKSIZE,WORK,BASE=R12,CLEAR=YES,EQUREGS=YES,        X\n               LOC=BELOW,AMODE=24,RMODE=24,    XA PARMS                X\n               COPYRT=1987\n         L     R11,16                  GET CVT ADDRESS\n         USING CVT,R11\n         L     R10,CVTUSER             GET NCT ADDRESS\n         LTR   R10,R10                 IS THERE AN NCT?\n         BZ    NONCT\n         USING NCT,R10\n         MVI   DECTIME+4,X'0F'         INSERT SIGN INTO TIME\n         MVO   DECTIME,NCTIPLTM\n         MVC   DECDAY,NCTIPLDT+2       GET DECIMAL DAYS INTO YEAR\n         MVC   MONTHTAB,MONTHDMY       COPY IN STATIC MONTHS TABLE\n         MVI   DECYEAR+1,X'0F'         INSERT SIGN INTO YEAR\n         MVO   DECYEAR,NCTIPLDT+1(1)\n         ZAP   TESTYEAR,DECYEAR        COPY FOR DIVISION\n         DP    TESTYEAR,=PL1'4'        IS IT LEAP YEAR?\n         CP    TESTYEAR+2(1),=P'0'     TEST REMAINDER\n         BNE   NOTLEAP\n         MVC   MONTHTAB+2(2),=PL2'29'  YES ... SET FEB. DAYS\nNOTLEAP  DS    0H\n         LA    R1,MONTHTAB\n         ZAP   DECMONTH,=P'1'          INITIAL MONTH\nMNTHLOOP DS    0H\n         CP    DECDAY,0(2,R1)          PAST END OF THIS MONTH?\n         BNH   MNTHEND\n         SP    DECDAY,0(2,R1)\n         AP    DECMONTH,=P'1'\n         LA    R1,2(,R1)\n         B     MNTHLOOP\nMNTHEND  DS    0H\n         MVC   TPUTMSG,TPUTDMY\n         MVC   TPUTSID,NCTCPUID\n         MVC   EDITFLDS,EDITSPEC\n         ED    EDITJDAT,NCTIPLDT       CONVERT JULIAN DATE TO DECIMAL\n         ED    EDITGDMM,DECMONTH       ALSO GREGORIAN DATE: MM\n         ED    EDITGDDD,DECDAY         DD ...\n         ED    EDITGDYY,DECYEAR        YY\n         ED    EDITTIME,DECTIME\n         MVC   TPUTJDAT,EDITJDAT+3     COPY INTO MESSAGE\n         MVC   TPUTGDMM,EDITGDMM+1\n         MVC   TPUTGDDD,EDITGDDD+1\n         MVC   TPUTGDYY,EDITGDYY+1\n         MVC   TPUTTIME,EDITTIME+2\n         TPUT  TPUTMSG,TPUTLEN\n         B     RETURN\nNONCT    DS    0H\n         TPUT  BADMSG,L'BADMSG\nRETURN   DS    0H\n         RELEASE  WORKSIZE,WORK,RC=0\n         EJECT\nBADMSG   DC    C'NCT1002E  NCT NOT FOUND, IPL DATE NOT AVAILABLE'\nTPUTDMY  DC    C'NCT1001I  SYSTEM '\nTPOFSID  EQU   *-TPUTDMY\n         DC    C'XXXX LAST IPL WAS ON '\nTPOFGDMM EQU   *-TPUTDMY\n         DC    C'MM/'\nTPOFGDDD EQU   *-TPUTDMY\n         DC    C'DD/'\nTPOFGDYY EQU   *-TPUTDMY\n         DC    C'YY ('\nTPOFJDAT EQU   *-TPUTDMY\n         DC    C'YY.DDD) AT '\nTPOFTIME EQU   *-TPUTDMY\n         DC    C'HH:MM:SS.TT '\nTPUTLEN  EQU   *-TPUTDMY\nEDITSPEC DC    X'212020'               YEAR\n         DC    X'212020'               MONTH\n         DC    X'212020'               DAY\n         DC    X'40202120204B202020'   JULIAN\n         DC    X'402021207A20207A20204B2020'   TIME OF DAY\nEDITLEN  EQU   *-EDITSPEC\nMONTHDMY DC    PL2'31'                 JANUARY\n         DC    PL2'28'                 FEBRUARY\n         DC    PL2'31'                 MARCH\n         DC    PL2'30'                 APRIL\n         DC    PL2'31'                 MAY\n         DC    PL2'30'                 JUNE\n         DC    PL2'31'                 JULY\n         DC    PL2'31'                 AUGUST\n         DC    PL2'30'                 SEPTEMBER\n         DC    PL2'31'                 OCTOBER\n         DC    PL2'30'                 NOVEMBER\n         DC    PL2'31'                 DECEMBER\nMONTHLEN EQU   *-MONTHDMY\n         LTORG\n         EJECT\nWORK     DSECT\n         DS    18F\nMONTHTAB DS    CL(MONTHLEN)\nDECYEAR  DS    PL2\nDECTIME  DS    PL5\nDECDAY   DS    PL2\nDECMONTH DS    PL2\nTESTYEAR DS    PL3\nEDITFLDS DS    0CL(EDITLEN)\nEDITGDYY DC    X'212020'               YEAR\nEDITGDMM DC    X'212020'               MONTH\nEDITGDDD DC    X'212020'               DAY\nEDITJDAT DC    X'40202120204B202020'   JULIAN\nEDITTIME DC    X'402021207A20207A20204B2020'   TIME OF DAY\nTPUTMSG  DS    CL(TPUTLEN)\nTPUTSID  EQU   TPUTMSG+TPOFSID,4,C'C'\nTPUTGDMM EQU   TPUTMSG+TPOFGDMM,2,C'C'\nTPUTGDDD EQU   TPUTMSG+TPOFGDDD,2,C'C'\nTPUTGDYY EQU   TPUTMSG+TPOFGDYY,2,C'C'\nTPUTJDAT EQU   TPUTMSG+TPOFJDAT,6,C'C'\nTPUTTIME EQU   TPUTMSG+TPOFTIME,11,C'C'\n         DS    0D\nWORKSIZE EQU   *-WORK\n         EJECT\n         CVT   DSECT=YES\n         SPACE 2\nNCT      NCT\n         END   IPLDATE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KEYWORD": {"ttr": 2567, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         KEYWORD  &KEYWORD,&FIELD,&DSECT\n.*\n.*  FUNCTION - DEFINES A KEYWORD TABLE FOR USE OF ROUTINE \"KWDREPL\"\n.*\n.*      3 POSITIONAL PARMS:\n.*          (1) - THE CHARACTER VALUE OF THE KEYWORD BEING DEFINED.\n.*                THIS MUST NOT INCLUDE BLANKS, COMMAS, TIC MARKS, ETC.\n.*          (2) - THE NAME OF THE FIELD CONTAINING THE DATA TO BE\n.*                SUBSTITUTED.  IT MAY BE OF THE FORM \"(NAME,LENGTH)\"\n.*                OR (OFFSET,LENGTH),  OR JUST \"NAME.\" IF \"LENGTH\" IS\n.*                NOT SUPPLIED, IT WILL DEFAULT TO THE ASSEMBLED LENGTH\n.*                OF \"NAME\"\n.*          (3) - THE NAME OF THE DSECT CONTAINING THE FIELD NAMED IN\n.*                #2 ABOVE.  IF AN OFFSET IS SUPPLIED IN #2,\n.*                THIS PARM SHOULD BE SPECIFIED AS \"0\"\n.*\n         GBLC  &KWDTBL(255),&OFFTBL(255),&LBLTBL(255),&LENTBL(255)\n         GBLA  &KWDCNT,&KWDLEN(255)\n         LCLC  &FLDNAM,&FLDLEN\n         LCLC  &KWDTEMP,&OFFTEMP,&LBLTEMP,&LENTEMP\n         LCLA  &KLNTEMP,&I,&J\n         AIF   ('&KEYWORD' EQ 'END-OF-TABLE').ENDTAB\n         AIF   (&KWDCNT LE 253).GENKWD\n         MNOTE 8,'** TOO MANY KEYWORDS IN TABLE, &KEYWORD IGNORED'\n         MEXIT\n.GENKWD  ANOP\n&KWDCNT  SETA  &KWDCNT+1\n         AIF   (N'&FIELD LT 2).DFLTLEN\n&FLDNAM  SETC  '&FIELD(1)'\n&FLDLEN  SETC  '&FIELD(2)'\n         AGO   .SETVAR\n.DFLTLEN ANOP\n&FLDNAM  SETC  '&FIELD(1)'\n&FLDLEN  SETC  'L''&FLDNAM'\n.SETVAR  ANOP\n&LBLTBL(&KWDCNT) SETC 'KWD&SYSNDX'\n&OFFTBL(&KWDCNT) SETC '&FLDNAM-&DSECT'\n&KWDTBL(&KWDCNT) SETC '&KEYWORD'\n&KWDLEN(&KWDCNT) SETA K'&KEYWORD\n&LENTBL(&KWDCNT) SETC '&FLDLEN'\n         MEXIT\n.ENDTAB  ANOP\n.*\n.*    FIRST, SORT IN ORDER BY LONGEST KEYWORD FIRST\n.*\n&I       SETA  1\n.LOOP1   AIF   (&I GE &KWDCNT).SORTED\n&J       SETA  &I+1\n.LOOP2   AIF   (&J GT &KWDCNT).XLOOP2\n         AIF   (&KWDLEN(&I) GE &KWDLEN(&J)).NEXT2\n&KWDTEMP SETC  '&KWDTBL(&I)'\n&OFFTEMP SETC  '&OFFTBL(&I)'\n&LBLTEMP SETC  '&LBLTBL(&I)'\n&LENTEMP SETC  '&LENTBL(&I)'\n&KLNTEMP SETA  &KWDLEN(&I)\n&KWDTBL(&I) SETC '&KWDTBL(&J)'\n&OFFTBL(&I) SETC '&OFFTBL(&J)'\n&LBLTBL(&I) SETC '&LBLTBL(&J)'\n&LENTBL(&I) SETC '&LENTBL(&J)'\n&KWDLEN(&I) SETA &KWDLEN(&J)\n&KWDTBL(&J) SETC '&KWDTEMP'\n&OFFTBL(&J) SETC '&OFFTEMP'\n&LBLTBL(&J) SETC '&LBLTEMP'\n&LENTBL(&J) SETC '&LENTEMP'\n&KWDLEN(&J) SETA &KLNTEMP\n.NEXT2   ANOP\n&J       SETA  &J+1\n         AGO   .LOOP2\n.XLOOP2  ANOP\n&I       SETA  &I+1\n         AGO   .LOOP1\n.SORTED  ANOP\n&LBLTBL(&KWDCNT+1) SETC '0'\n&I       SETA  1\n.DCLOOP  AIF   (&I GT &KWDCNT).DCDONE\n&LBLTBL(&I) DC  A(&LBLTBL(&I+1))\n         DC    A(&OFFTBL(&I))\n         DC    AL1(&LENTBL(&I))\n         DC    AL1(&KWDLEN(&I))\n         DC    C'&KWDTBL(&I)'\n&I       SETA  &I+1\n         AGO   .DCLOOP\n.DCDONE  ANOP\n&KWDCNT  SETA  0\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KWDREPL": {"ttr": 2570, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "KWDREPL  TITLE 'KWDREPL - SUBROUTINE TO REPLACE KEYWORDS WITH VALUES'\nKWDREPL  CSECT\nKWDREPL  AMODE 31\nKWDREPL  RMODE ANY\n***********************************************************************\n*                                                                     *\n* FUNCTION - TO PERFORM SYMBOLIC REPLACEMENT ON A KEYWORD WITHIN      *\n*       A (FIXED-LENGTH) AREA.  TEXT WITHIN THE AREA WILL BE          *\n*       SHIFTED TO ACCOMODATE LENGTH CHANGES CAUSED BY THE REPLACEMENT*\n*                                                                     *\n*       A KEYWORD TABLE BUILT BY THE \"KEYWORD\" MACRO IS A REQUIRED    *\n*       PARAMETER TO THIS SUBROUTINE.  A 512-BYTE WORK AREA SHOULD    *\n*       BE PROVIDED FOR THE USE OF THIS SUBROUTINE.  THE SUBROUTINE   *\n*       DOES NOT SCAN FOR A KEYWORD WITHIN THE AREA, BUT RATHER       *\n*       CONDITIONALLY REPLACES A KEYWORD WITH A VALUE.                *\n*                                                                     *\n*  ATTRIBUTES:  RENT                                                  *\n*                                                                     *\n*  MACROS: NONE.                                                      *\n*  MAPPING MACROS:  KWDTABLE, EQUREGS                                 *\n*                                                                     *\n*  PARMS:                                                             *\n*                                                                     *\n*   R1  = PTR TO A 5-WORD PARAMETER LIST WITH THE FOLLOWING FORMAT:   *\n*        +00 - ADDR(512-BYTE WORK AREA)                               *\n*        +04 - ADDR(WORD-TO-TEST-FOR-SUBSTITUTION)                    *\n*        +08 - ADDR(END-OF-SUBSTITUTION-AREA)                         *\n*        +0C - ADDR(KEYWORD-TABLE)                                    *\n*        +10 - ADDR(FIELD-VALUE-DSECT)                                *\n*   R13 = PTR TO OS-STYLE SAVE AREA                                   *\n*   R14 = RETURN ADDRESS                                              *\n*   R15 = ENTRY POINT ADDRESS                                         *\n*                                                                     *\n*  ON RETURN:                                                         *\n*   R1  = ADDRESS OF KEYWORD TABLE ENTRY.                             *\n*   R15 = RETURN CODE:                                                *\n*        +00 - TEST WORD WAS A KEYWORD, SUBSTITUTION HAS BEEN DONE.   *\n*        +04 - TEST WORD WAS NOT A KEYWORD (R0 HAS 0).                *\n*                                                                     *\n*                                                                     *\n* AUTHOR:  BILL WARRINER                                              *\n*          UMC HOSPITAL AND CLINICS                                   *\n*          SYSTEM PROGRAMMING SERVICES DC017.00                       *\n*          1400 ROCK QUARRY ROAD                                      *\n*          COLUMBIA, MO  65212                                        *\n*          (314) 882-3773                                             *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         USING KWDREPL,R15\n         B     PASTCONS\n         DC    AL1(L'EPID)\nEPID     DC    C'KWDREPL_V1.0_&SYSDATE._&SYSTIME.'\n         DC    C'COPYRIGHT(C) BY THE CURATORS OF THE UNIVERSITY OF MISSX\n               OURI, A PUBLIC CORPORATION'\nPASTCONS DS    0H\n         STM   R14,R12,12(R13)\n         DROP  R15\n         LR    R12,R15\n         USING KWDREPL,R12\n         L     R2,0(R1)            GET WORK AREA ADDRESS\n         ST    R2,8(R13)           CHAIN\n         ST    R13,4(R2)             SAVE AREAS\n         LR    R13,R2                  TOGETHER\n         LM    R3,R6,4(R1)         GET BASE REGISTERS\n         LA    R0,8(R13)           CLEAR\n         LA    R1,504                 OUT\n         SR    R15,R15                   WORK\n         MVCL  R0,R14                       AREA\n         USING WORK,R13\n         LA    R3,0(R3)\n         LA    R4,0(R4)\n         USING KWDTABLE,R5\n         LTR   R5,R5               IS THERE A KEYWORD TABLE?\n         BZ    NOTFOUND            NO - THEREFORE NO MATCH\n         SR    R1,R1               SETUP FOR IC\nSCAN     DS    0H\n         IC    R1,KWDKLEN          GET KEYWORD LENGTH\n         SH    R1,=H'1'            DEX FOR CLC\n         BM    SCANNEXT            IF LENGTH<1 SKIP THIS ENTRY.\n         LA    R10,0(R1,R3)        WILL THE KEYWORD FIT IN HERE?\n         CLR   R10,R4\n         BH    SCANNEXT\n         EX    R1,SCANCLC          COMPARE KEYWORD:\n         BE    FOUNDIT              - WE FOUND IT!\nSCANNEXT DS    0H\n         ICM   R5,15,KWDNEXT       ELSE GO CHECK THE NEXT ONE.\n         BNZ   SCAN\n         B     NOTFOUND\nSCANCLC  CLC   0(*-*,R3),KWDKEYWD\nFOUNDIT  DS    0H\n         SR    R0,R0               SETUP FOR IC\n         IC    R0,KWDFLEN          GET FIELD LENGTH\n         SH    R0,=H'1'            IS THERE ANY DATA?\n         BM    ERASEIT             IF NOT, JUST ERASE THE KEYWORD.\n         CR    R0,R1               CHECK LENGTHS:\n         BE    MOVEFLD             - EQUAL - JUST MOVE THE FIELDS\n         BH    TRUNCATE            - DATA LONGER THAN KEYWORD\n         B     PAD                 - DATA SHORTER THAN KEYWORD\nERASEIT  DS    0H                  - SPECIAL CASE: DATA LEN=0\n         OI    WRKFLAG,WRKNOMVC\nPAD      DS    0H\n         LR    R14,R0              GET DATA LEN ...\n         LA    R14,1(R14,R3)       CALCULATE TARGET ADDRESS\n         LR    R10,R1              GET KEYWORD LEN ...\n         LA    R10,1(R10,R3)       CALCULATE SOURCE ADDRESS\n         LR    R15,R4              CALCULATE ...\n         SR    R15,R3              ... REAL FIELD LENGTH ...\n         LR    R11,R15             ... FOR BOTH SOURCE ...\n         SR    R15,R0              ... AND TARGET.\n         BM    ERROR\n         SR    R11,R1\n         BM    ERROR\n         ICM   R11,8,=C' '         SET THE PAD CHARACTER\n         MVCL  R14,R10             SHIFT AND PAD\n         B     MOVEFLD             NOW GO COPY THE DATA.\nTRUNCATE DS    0H\n         LR    R10,R1              GET KEYWORD LEN ...\n         LA    R10,1(R10,R3)       ... AND CALCULATE SOURCE ADDRESS.\n         LR    R11,R4\n         SR    R11,R3\n         SR    R11,R1              GET SOURCE LENGTH.\n         BM    ERROR\n         C     R11,=A(L'WRKSVE2)   IS IT TOO LONG?\n         BH    ERROR\n         ST    R11,WRKSVE1         SAVE THE LENGTH.\n         LA    R14,WRKSVE2\n         LR    R15,R11\n         MVCL  R14,R10             COPY TO A TEMPORARY\n         LR    R14,R0              GET DATA LEN ...\n         LA    R14,1(R14,R3)       CALCULATE TARGET ADDRESS\n         CR    R14,R4              TARGET PAST END OF STRING?\n         BH    TRUNCAT2            YES - USE SPECIAL MOVE.\n         LR    R15,R4\n         SR    R15,R3\n         SR    R15,R0              CALCULATE TARGET LENGTH\n         BM    ERROR\n         LA    R10,WRKSVE2\n         L     R11,WRKSVE1\n         MVCL  R14,R10             COPY WITH TRUNCATION\nMOVEFLD  DS    0H                  MOVE IN THE DATA:\n         TM    WRKFLAG,WRKNOMVC    (IS THERE ANY TO MOVE?)\n         BNZ   DONE                NO - ALL FINISHED.\n         LR    R1,R0               GET DATA LENGTH-1\n         AL    R6,KWDFIELD         GET DATA ADDRESS\n         EX    R1,MOVEMVC          AND COPY DATA IN.\n         B     DONE\nTRUNCAT2 DS    0H                  SPECIAL MOVE - TRUNCATE DATA TOO.\n         LR    R1,R4               CALCULATE THE\n         SR    R1,R3               ... AVAILABLE LENGTH-1\n         AL    R6,KWDFIELD         START OF SOURCE ...\n         EX    R1,MOVEMVC          COPY IN WHATEVER WILL FIT.\n         B     DONE\nMOVEMVC  MVC   0(*-*,R3),0(R6)\nERROR    DS    0H\n         LA    R15,8               INDICATE SEVERE ERROR\n         SR    R5,R5\n         B     RETURN\nNOTFOUND DS    0H\n         LA    R15,4\n         SR    R5,R5\n         B     RETURN\nDONE     DS    0H\n         SR    R15,R15\nRETURN   DS    0H\n         LR    R1,R5\n         L     R13,4(R13)          BACKUP 1 SAVE AREA\n         XC    8(4,R13),8(R13)     AND UNCHAIN\n         L     R14,12(R13)         RESTORE\n         L     R0,20(R13)             REGISTERS\n         LM    R2,R12,28(R13)           FOR RETURN\n         BR    R14                 RETURN TO CALLER.\n         EJECT\n         LTORG\n         KWDTABLE\nWORK     DSECT\n         DS    18F\nWRKSVE1  DS    A\nWRKFLAG  DS    X\nWRKNOMVC EQU   X'80'\nWRKSVE2  DS    CL256\n         DS    0D\nWORKSIZE EQU   *-WORK                 MUST BE LESS THAN 512\n         EQUREGS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KWDTABLE": {"ttr": 2574, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         KWDTABLE\nKWDTABLE DSECT\nKWDNEXT  DS    A                   ADDRESS OF NEXT ENTRY\nKWDFIELD DS    A                   OFFSET FROM START OF TAB TO FIELD\nKWDFLEN  DS    X                   LENGTH OF FIELD\nKWDKLEN  DS    X                   LENGTH OF KEYWORD\nKWDKEYWD DS    0C                  START OF KEYWORD\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MDL0101": {"ttr": 2576, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++ USERMOD (MDL0101) .\n++ VER (Z038)    FMID(HDQ1102).\n++ JCLIN .\n//LINKIT  EXEC PGM=IEWL,PARM='RENT,REFR,REUS'\n//SYSPRINT DD  SYSOUT=A\n//SYSMODS  DD  DSN=SYSS.SYSMODS,DISP=SHR\n//SYSLMOD  DD  DSN=SYS1.LPALIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(5,1))\n//SYSLIN   DD  *\n  INCLUDE SYSMODS(HCCDADSM)\n  NAME HCCDADSM(R)\n  INCLUDE SYSMODS(IGGPRE00)\n  NAME IGGPRE00(R)\n/*\n++ SRC (HCCDADSM) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n++ SRC (IGGPRE00) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MDL0103": {"ttr": 2578, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++ USERMOD (MDL0103) .\n++ VER (Z038)    FMID(HDP2230).\n++ JCLIN .\n//LINKIT  EXEC PGM=IEWL,PARM='RENT,REFR,REUS,AMODE=ANY,RMODE=24'\n//SYSPRINT DD  SYSOUT=A\n//SYSMODS  DD  DSN=SYSS.SYSMODS,DISP=SHR\n//SYSLMOD  DD  DSN=SYS1.LPALIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(5,1))\n//SYSLIN   DD  *\n  INCLUDE SYSMODS(HCCDADSM)\n  NAME HCCDADSM(R)\n  INCLUDE SYSMODS(IGGPRE00)\n  NAME IGGPRE00(R)\n/*\n++ SRC (HCCDADSM) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n++ SRC (IGGPRE00) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MJL1401": {"ttr": 2580, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++USERMOD(MJL1401) /*    SHARED SPOOL PERFORMANCE MONITORING\n                         THIS SYSMOD ALLOWS TIME STAMPING RESERVE/\n                         RELEASE ACTIVITY ON JES2 CKPT. DATASET   */.\n++VER(Z038) FMID(HJE1367) PRE(UY01247,UY03645,UZ44815,UZ82297)\n   REQ(MJL1501).\n++SRCUPD(HASPCKPT) DISTLIB(HASPSRC).\n./ CHANGE NAME=HASPCKPT\nKGLEXIT1 LA    R0,0       SET \"ATTEMPTING TO OBTAIN LOCK\"      @MJL1401\n        $EXIT  253        THEN TAKE EXIT POINT                 @MJL1401\nKGLEXIT2 LA    R0,4       SET \"LOCK OBTAINED\"                  @MJL1401\n        $EXIT  253        THEN TAKE EXIT POINT                 @MJL1401\nKRLEXIT  LA    R0,8       SET \"LOCK RELEASED\"                  @MJL1401\n        $EXIT  253        THEN TAKE EXIT POINT                 @MJL1401\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MJL1501": {"ttr": 2817, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++     USERMOD (MJL1501) .\n++         VER (Z038) FMID(HJE1367) REQ(MJL1401).\n++         JCLIN .\n//LINKIT  EXEC PGM=IEWL,PARM='RENT,REFR,REUS'\n//SYSPRINT DD  SYSOUT=A\n//SYSMODS  DD  DSN=SYSS.SYSMODS,DISP=SHR\n//SYSLMOD  DD  DSN=SYS1.LINKLIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(5,1))\n//SYSLIN   DD  *\n  INCLUDE SYSMODS(HJUX2530)\n  NAME HJUX2530(R)\n/*\n++ SRC (HJUX2530) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MSL0101": {"ttr": 2819, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++ USERMOD (MSL0101) .\n++ VER (Z038)    FMID(JBB1326).\n++ JCLIN .\n//LINKIT  EXEC PGM=IEWL,PARM='RENT,REFR,REUS'\n//SYSPRINT DD  SYSOUT=A\n//SYSMODS  DD  DSN=SYSS.SYSMODS,DISP=SHR\n//SYSLMOD  DD  DSN=SYS1.LPALIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(5,1))\n//SYSLIN   DD  *\n  INCLUDE SYSMODS(IEFUJV)\n  INCLUDE SYSMODS(KWDREPL)\n  NAME IEFUJV(R)\n/*\n++ SRC (IEFUJV) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n++ SRC (KWDREPL) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MSL0103": {"ttr": 2821, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "++ USERMOD (MSL0103) .\n++ VER (Z038)    FMID(HBB2102).\n++ JCLIN .\n//LINKIT  EXEC PGM=IEWL,PARM='RENT,REFR,REUS,AMODE=31,RMODE=ANY'\n//SYSPRINT DD  SYSOUT=A\n//SYSMODS  DD  DSN=SYSS.SYSMODS,DISP=SHR\n//SYSLMOD  DD  DSN=SYS1.LPALIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,(5,1))\n//SYSLIN   DD  *\n  INCLUDE SYSMODS(IEFUJV)\n  INCLUDE SYSMODS(KWDREPL)\n  NAME IEFUJV(R)\n/*\n++ SRC (IEFUJV) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n++ SRC (KWDREPL) DISTLIB(ASOURCE) SYSLIB(SOURCE) TXLIB(CBTLIB).\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NCT": {"ttr": 2823, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    NCT   &TYPE=DSECT,&PREFIX=NCT\n.*\n.*       CHANGE LOG\n.*       05/13/81  MARTIN M L - ADD NCTU84 IN SUPPORT OF SMFU84\n.*                              FOR SP1\n.*10/30/86  W J WARRINER - CHANGED FORMAT FOR HCC USE\n.*\n         LCLC  &P\n&P       SETC  '&PREFIX'\n.*\n.*       THIS MACRO GENERATES THE NETWORK CONTROL TABLE(NCT).\n.*       THE NCT IS BUILT AT SYSTEM INITIALIZATION TIME.\n.*\n*\n*        NETWORK COMMUNICATIONS TABLE\n*\n&NAME    TYPE  &TYPE\n&P.SPLN  DS    0A\n&P.SIZE  EQU   *\n&P.POOL  DC    AL1(&P.SP)               SUBPOOL\n&P.LGTH  DC    AL3(&P.LEN)              LENGTH\n&P.IDBLK DC    CL4'NCT '                BLOCK TYPE IDENTIFIER\n&P.CPUID DS    CL4                      CPU ID (SMF ID)\n&P.ID    DC    CL4'HCC '                INSTALLATION ID\n*        THE TIME AND DATE BELOW ARE ACTUALLY THOSE\n*        VALUES WHEN THE FIRST NCT WAS CREATED.\n*        THEY ARE COPIED FORWARD IF A NEW NCT IS CREATED.\n&P.IPLDT DS    PL4                      IPL DATE\n&P.IPLTM DS    XL4                      IPL TIME\n&P.NAC   DC    A(0)                     ACCOUNT CONTROL DATA AREA\n&P.ACCT  DC    A(0)                     ACCT LMOD ADDRESS\n&P.DSVER DS    A(0)                     DATASET VERIFICATION ROUTINE\n&P.TCMTM DS    2F                       TCAM STARTUP TIME      02/28/78\n&P.NTT   DS    A                        NETWORK TCAM TABLE\n&P.DADSM DS    A                        HCCDADSM ENTRY ADDRESS\n&P.DAPRM DS    A                        A(DADSM PARM FIELD)\n&P.XMEM  EQU   *                        START OF CROSS-MEMORY AREA\n&P.WCVT  DS    A                        ADDR WORST CVT\n&P.WASCB DS    A                        ADDR WORST ASCB\n&P.SMASK DS    XL1                      SYSTEM MASK (AUTH ALLOWED)\n         DS    XL3                      RESERVED FOR FUTURE EXPANSION\n         DS    3A(0)                    RESERVED           MLG-11/09/82\n         DS    0D                       INSURE ALIGNMENT TO DOUBLEWORD\n&P.SP    EQU   241                      SUBPOOL NUMBER FOR NCT\n&P.LEN   EQU   *-&P.SIZE                LENGTH OF NCT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDUMP": {"ttr": 2825, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " PDUMP:    PROC(PTR,LEN,TITLE) REORDER;\n PDUMPNP:  ENTRY(PTR,LEN,TITLE);\n %SKIP;\n /********************************************************************/\n /* P D U M P      -  EXTERNAL PL/I SUBROUTINE                       */\n /* P D U M P N P  -  EXTERNAL PL/I SUBROUTINE                       */\n /* P D U M P S P  -  EXTERNAL PL/I SUBROUTINE                       */\n /*                                                                  */\n /* FUNCTION - PRODUCES A FORMATTED, LABELED DUMP OF AN AREA TO FILE */\n /*   SYSPRINT.                                                      */\n /*                                                                  */\n /* PARAMETERS:                                                      */\n /*   PTR - POINTER - POINTS TO THE START OF THE AREA TO BE DUMPED.  */\n /*   LEN - FIXED BIN(31) - THE LENGTH OF THE AREA TO BE DUMPED.     */\n /*   TITLE - CHAR(*) - THE TITLE TO BE PLACED AT THE TOP OF EACH    */\n /*         PAGE OF THE DUMP.                                        */\n /*                                                                  */\n /* LOGIC - THE STARTING ADDRESS (PTR) IS TRANSLATED TO HEXADECIMAL  */\n /*   AND PRINTED FIRST.  THE AREA IS TREATED AS A BASED CHARACTER   */\n /*   STRING AND IS TRANSLATED TO HEXADECIMAL AND DUMPED, 32 CHARS.  */\n /*   PER LINE.  EACH LINE OF THE DUMP IS PRECEDED BY THE OFFSET OF  */\n /*   THE FIRST CHARACTER IN THAT LINE FROM THE STARTING LOCATION,   */\n /*   IN HEXADECIMAL.                                                */\n /*                                                                  */\n /* NOTE: UNLIKE A SNAP DUMP, THE STARTING LOCATION OF EACH LINE     */\n /*   HAS NO RELATION TO DOUBLEWORD BOUNDARIES.  THE FIRST LINE      */\n /*   STARTS AS OFFSET 0 AS THE LEFTMOST CHARACTER.  CHARACTERS      */\n /*   FOLLOWING THE RIGHTMOST POSITION ARE NOT PRINTED NOR ADDRESSED.*/\n /*   THE RIGHTHAND SIDE OF THE PAGE WILL CONTAIN ONLY PRINTABLE     */\n /*   CHARACTERS (UPPER AND LOWER CASE) WITH ALL OTHERS REPRESENTED  */\n /*   AS PERIODS.                                                    */\n /*                                                                  */\n /* WRITTEN DECEMBER 1981 BY BILL WARRINER, VETERINARY DIAGNOSTIC    */\n /*   LAB, UNIVERSITY OF MISSOURI, 882-6811.                         */\n /*                                                                  */\n /* UPDATED 4/25/84 BY BILL WARRINER, UMCHC COMPUTER CENTER - ADDED  */\n /*   PDUMPSP ENTRY POINT AND TRANSLATION OF CHARACTER DUMP TO       */\n /*   PRINTABLE CHARACTERS ONLY.                                     */\n /*                                                                  */\n /********************************************************************/\n %PAGE;\n           DCL PTR POINTER;\n           DCL LEN FIXED BIN(31);\n           DCL TITLE CHAR(*);\n           DCL STRING1 CHAR(16) BASED(S1PTR);\n           DCL STRING2 CHAR(16) BASED(S2PTR);\n           DCL LASTSTR CHAR(32) INIT((32)' ');\n           DCL (S1PTR,S2PTR) POINTER;\n           DCL FAKEOUT FIXED BIN(31) BASED(ADDR(PTR2));\n           DCL FAKEOUT1 FIXED BIN(31) BASED(ADDR(PTR));\n           DCL MASK CHAR(1) BASED(ADDR(PTR2));\n           DCL PTR2 POINTER;\n           DCL FAKE1 FIXED BIN(31) BASED(ADDR(S1PTR));\n           DCL FAKE2 FIXED BIN(31) BASED(ADDR(S2PTR));\n           DCL (ADDR,SUBSTR,LENGTH,LOW,TRANSLATE) BUILTIN;\n           DCL I FIXED BIN(15);\n           DCL SYSPRINT FILE PRINT STREAM OUTPUT EXT;\n           DCL POSITION FIXED BIN(31);\n           DCL $POS(4) CHAR(1) BASED(ADDR(POSITION));\n           DCL IPG FIXED DEC(4,0) STATIC INIT(1);\n           DCL (SAME1,SAME2) CHAR(8) INIT((8)' ');\n           DCL PRTCHARS CHAR(256) STATIC INIT('.........................\n ....................................... .........\u00a2.<(+|&.........!$*);\u00ac\n -/........\u00a6,%_>?..........:#@''=\".abcdefghi.......jklmnopqr.......~stuv\n wxyz......................{ABCDEFGHI......}JKLMNOPQR......\\.STUVWXYZ...\n ...0123456789......');\n  %SKIP(2);\n           ON ENDPAGE(SYSPRINT) BEGIN;\n               PUT FILE(SYSPRINT) PAGE EDIT(TITLE,'PAGE',IPG)\n                 (A,COL(110),A(5),F(4));\n               PUT FILE(SYSPRINT) SKIP(2);\n               IPG = IPG + 1;\n               END;\n           SIGNAL ENDPAGE(SYSPRINT);\n           GO TO DMPSTRT;\n %PAGE;\n PDUMPSP:  ENTRY(PTR,LEN,TITLE);\n %SKIP;\n /********************************************************************/\n /* P D U M P S P  -  ALTERNATE ENTRY POINT TO PDUMP                 */\n /*                                                                  */\n /* FUNCTION - PRODUCES THE SAME DUMP AS DOES PDUMP, BUT DOES NOT    */\n /*   START THE DUMP ON A NEW PAGE.                                  */\n /*                                                                  */\n /********************************************************************/\n  %SKIP(2);\n           ON ENDPAGE(SYSPRINT) BEGIN;\n               PUT FILE(SYSPRINT) PAGE EDIT(TITLE,'PAGE',IPG)\n                 (A,COL(110),A(5),F(4));\n               PUT FILE(SYSPRINT) SKIP(2);\n               IPG = IPG + 1;\n               END;\n           PUT FILE(SYSPRINT) SKIP(3) EDIT(TITLE)(A);\n %SKIP(2);\n DMPSTRT:  POSITION = FAKEOUT1;\n           PUT FILE(SYSPRINT) SKIP(2) EDIT('### STARTING POSITION IS ',\n             'HEX ''',XPOS,'''.')(A,A,A,A);\n           POSITION = 0;\n           PUT FILE(SYSPRINT) SKIP(2);\n           PTR2 = PTR;\n           MASK = LOW(1);\n XSTART:   FAKE1 = FAKEOUT + POSITION; /* FIRST CHARACTER */\n           IF (FAKEOUT+LEN)<(FAKE1+32) THEN GO TO LASTPRT;\n           FAKE2 = FAKE1 + 16; /* START OF 2D. HALF PAGE */\n           IF LASTSTR=STRING1||STRING2\n           THEN IF SAME1=(8)' '\n                THEN SAME1 = XPOS;\n                ELSE SAME2 = XPOS;\n           ELSE DO;\n               IF SAME1\u00ac=(8)' '\n               THEN IF SAME2\u00ac=(8)' '\n                    THEN PUT FILE(SYSPRINT) SKIP EDIT('LINES ',SAME1,\n                      ' - ',SAME2,' SAME AS ABOVE.')(X(11),(5)A);\n                    ELSE PUT FILE(SYSPRINT) SKIP EDIT('LINE ',SAME1,\n                      ' SAME AS ABOVE.')(X(11),(3)A);\n               ELSE;\n               SAME1,SAME2 = (8)' ';\n               LASTSTR = STRING1 || STRING2;\n               PUT FILE(SYSPRINT) SKIP EDIT(XPOS,\n                 XCHARS(STRING1),XCHARS(STRING2),\n                 ' *',TRANSLATE(STRING1,PRTCHARS),\n                 TRANSLATE(STRING2,PRTCHARS),'*')\n                 (A(8),X(3),A(36),X(2),A(36),A(2),A(16),A(16),A(1));\n               END;\n           POSITION = POSITION + 32; /* NEXT 32 CHARACTERS */\n           GO TO XSTART;\n LASTPRT:  IF SAME1\u00ac=(8)' '\n           THEN IF SAME2\u00ac=(8)' '\n                THEN PUT FILE(SYSPRINT) SKIP EDIT('LINES ',SAME1,\n                  ' - ',SAME2,' SAME AS ABOVE.')(X(11),(5)A);\n                ELSE PUT FILE(SYSPRINT) SKIP EDIT('LINE ',SAME1,\n                  ' SAME AS ABOVE.')(X(11),(3)A);\n           ELSE;\n           I = LEN - POSITION; /* # OF CHARS LEFT TO PRINT */\n           IF I<1 THEN GO TO ALLDONE;\n           IF I>16 THEN DO;\n               FAKE2 = FAKE1 + 16;\n               PUT FILE(SYSPRINT) SKIP EDIT(XPOS,\n                 XCHARS(STRING1),XCHARS(SUBSTR(STRING2,1,I-16)),\n                 ' *',TRANSLATE(STRING1,PRTCHARS),\n                 TRANSLATE(SUBSTR(STRING2,1,I-16),PRTCHARS),'*')\n                 (A(8),X(3),A(36),X(2),A(36),A(2),A(16),A(16),A(1));\n               END;\n           ELSE\n             PUT FILE(SYSPRINT) SKIP EDIT(XPOS,\n               XCHARS(SUBSTR(STRING1,1,I)),' *',\n               TRANSLATE(SUBSTR(STRING1,1,I),PRTCHARS),'*')\n               (A(8),X(3),A(36),X(2),X(36),A(2),A(16),X(16),A(1));\n ALLDONE:  PUT FILE(SYSPRINT) SKIP;\n           RETURN;\n  %PAGE;\n XCHARS:   PROC(STRING) RETURNS(CHAR(36)) REORDER;\n %SKIP;\n /********************************************************************/\n /* X C H A R S  -  INTERNAL PL/I FUNCTION (INTERNAL TO PDUMP)       */\n /*                                                                  */\n /* FUNCTION - TRANSLATES A CHARACTER STRING TO HEXADECIMAL DUMP     */\n /*    FORMAT.                                                       */\n /*                                                                  */\n /********************************************************************/\n %SKIP(3);\n           DCL STRING CHAR(*);\n           DCL XSTRING CHAR(36) VAR INIT('');\n           DCL TRANSLATE BUILTIN;\n           DCL T1 CHAR(256) INIT('00000000000000001111111111111111222222\n 22222222223333333333333333444444444444444455555555555555556666666666666\n 666777777777777777788888888888888889999999999999999AAAAAAAAAAAAAAAABBBB\n BBBBBBBBBBBBCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEFFFFFFFFFFF\n FFFFF') STATIC;\n           DCL T2 CHAR(256) INIT((16)'0123456789ABCDEF') STATIC;\n           DCL ARRY(16) CHAR(1) DEF STRING POS(1);\n           DCL (I,L) FIXED BIN(15);\n           DCL (LENGTH,SUBSTR,REPEAT) BUILTIN;\n %PAGE;\n           L = LENGTH(STRING);\n           IF L=0 THEN RETURN((36)' ');\n           IF L>16 THEN L = 16;\n           DO I=1 TO L;\n               XSTRING = XSTRING || TRANSLATE(ARRY(I),T1) ||\n                 TRANSLATE(ARRY(I),T2);\n               SELECT(I);\n                   WHEN(4,8,12,16) XSTRING = XSTRING || ' ';\n                   OTHERWISE;\n                   END;\n               END;\n           IF L<16 THEN DO I=L+1 TO 16;\n               SELECT(I);\n                   WHEN(4,8,12,16) XSTRING = XSTRING || '   ';\n                   OTHERWISE XSTRING = XSTRING || '  ';\n                   END;\n               END;\n           RETURN(XSTRING);\n           %SKIP(3);\n XPOS:     ENTRY RETURNS(CHAR(8));\n %SKIP;\n /********************************************************************/\n /* X P O S  -  PL/I INTERNAL ENTRY POINT (INTERNAL TO PDUMP)        */\n /*                                                                  */\n /* FUNCTION - TRANSLATES A FULLWORD BINARY INTEGER TO HEXADECIMAL.  */\n /*                                                                  */\n /********************************************************************/\n %SKIP(3);\n           XSTRING = '';\n           DO I=1 TO 4;\n               XSTRING = XSTRING || TRANSLATE($POS(I),T1) ||\n                 TRANSLATE($POS(I),T2);\n               END;\n           RETURN(XSTRING);\n           END XCHARS;\n  %SKIP(3);\n           END PDUMP;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLIARRV": {"ttr": 2830, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   PLIARRV  &CSECT=NO,&DSASIZE=,&MULTEP=YES,&ALIAS=,             X\n               &GETMTHD=PLI,&COPYRT=\n.**********************************************************************\n.*                      PLIARRV MACRO                                 *\n.*                                                                    *\n.*   FUNCTION - PERFORMS \"HOUSEKEEPING\" CHORES ON ENTRY TO AN         *\n.*     ASSEMBLER LANGUAGE SUBROUTINE IN THE PL/1 ENVIRONMENT,         *\n.*     ALLOCATES A DSA IN PL/1 LIFO STORAGE, GENERATES A CSECT        *\n.*     STATEMENT (OPTIONALLY) FOLLOWING PL/1 NAMING CONVENTIONS.      *\n.*     PL/1 ERROR HANDLING IS SET UP, AND THE ENTRY POINT NAME WILL   *\n.*     PRINT ON PL/1 ERROR MESSAGES (EXCEPT THAT THE BASE LABEL WILL  *\n.*     PRINT OUT WHEN ALIAS NAMES ARE SPECIFIED FOR A GIVEN ENTRY     *\n.*     POINT).                                                        *\n.*                                                                    *\n.*   THIS MACRO GENERATES ENTRY CODE SIMILAR TO THAT DESCRIBED IN     *\n.*   THE \"OS PL/I OPTIMIZING COMPILER: PROGRAMMER'S GUIDE\"            *\n.*   (SC33-0006), PAGES 212-213.  NOTE THAT REGISTER 12 MUST BE       *\n.*   PRESERVED IN YOUR ASSEMBLY LANGUAGE SUBROUTINE.  PL/1 ERROR      *\n.*   HANDLING WILL BE RETAINED IN THE ASSEMBLY LANGUAGE SUBROUTINE.   *\n.*                                                                    *\n.*  FOR DEBUGGING PURPOSES, ALL ENTRY POINTS START WITH THE SAME      *\n.*  CODE:                                                             *\n.*             DC    CL7'ENTRY-POINT-NAME'  (LEFT PADDED WITH BLANKS) *\n.*             DC    AL1(L'ENTRY-POINT-NAME)                          *\n.* ENTRY-POINT STM   14,12,12(13)                                     *\n.*             USING ENTRY-POINT,15                                   *\n.*             B     *+12                                             *\n.*             DC    V(MAIN-ENTRY-POINT)                              *\n.*             DC    A(REQUIRED-DSA-SIZE)                             *\n.*             L     3,*-8             FOR PLIINIT ADDRESSABILITY     *\n.*             L     0,*-8             GET DSA SIZE                   *\n.*                                                                    *\n.*     STARTING AT OFFSET 24 FROM ANY ENTRY POINT, CODE GENERATED     *\n.*     GENERATED DEPENDS ON WHETHER THERE ARE MULTIPLE ENTRY POINTS,  *\n.*     AND, IF SO, WHETHER THIS IS THE FIRST OF THESE.  A ROUTINE IS  *\n.*     GENERATED (PLIINIT) WHICH IS CALLED AS AN INTERNAL SUBROUTINE  *\n.*     BY THE SECOND AND SUBSEQUENT ENTRY POINTS TO SET UP THE DSA.   *\n.*     THE PARAMETER (DSA SIZE) IS PASSED IN REGISTER 0, REGISTER 3   *\n.*     MUST POINT TO THE MAIN ENTRY POINT, AND THE LINK REGISTER IS   *\n.*     REGISTER 4.                                                    *\n.*                                                                    *\n.*   KEYWORDS:                                                        *\n.*     CSECT=YES - USED TO REQUEST A CSECT STATEMENT BE GENERATED     *\n.*        FOR THE SUBROUTINE.                                         *\n.*     CSECT=NO - USED IF A CSECT STATEMENT IS NOT TO BE GENERATED.   *\n.*        THIS IS THE DEFAULT.                                        *\n.*     CSECT=ONLY - USED IF A CSECT STATEMENT IS THE ONLY STATEMENT   *\n.*        TO BE GENERATED.                                            *\n.*     NOTE: IF A CSECT STATEMENT IS GENERATED, THE CSECT NAME WILL   *\n.*        BE OF THE FORM \"#...#EP1\", WHERE \"EP\" IS THE ENTRY POINT    *\n.*        NAME, \"1\" IS THE CHARACTER 1, AND \"#...#\" ARE SUFFICIENT    *\n.*        \"#\" SYMBOLS (0 TO 6) TO MAKE THE ENTIRE CSECT NAME EXACTLY  *\n.*        8 CHARACTERS LONG (PL/I GENERATED CSECT NAMES FOR PL/I      *\n.*        SUBROUTINES ARE OF THE SIMILAR FORM \"*...*EP1\" FOR THE      *\n.*        PROGRAM CSECT AND \"*...*EP2\" FOR THE STATIC DATA CSECT).    *\n.*                                                                    *\n.*     MULTEP=YES - USED TO REQUEST CODE FOR MULTIPLE ENTRY POINTS    *\n.*        TO BE GENERATED ON THE FIRST USE OF THIS MACRO (IGNORED ON  *\n.*        LATER USES).  THIS IS THE DEFAULT.                          *\n.*     MULTEP=NO - USED FOR MORE EFFICIENT CODE GENERATION IF THE     *\n.*        FIRST ENTRY POINT DEFINED BY THIS MACRO IS THE ONLY ENTRY   *\n.*        POINT SO DEFINED.  IGNORED ON THE SECOND AND LATER USES OF  *\n.*        THE MACRO.  IF MULTEP=NO IS SPECIFIED ON THE FIRST USE      *\n.*        OF THIS MACRO, THE MACRO SHOULD NOT BE USED AGAIN IN THE    *\n.*        SAME CSECT.                                                 *\n.*                                                                    *\n.*     ALIAS=(LIST) - USED TO INDICATE ALIAS NAMES FOR THE ENTRY POINT*\n.*        DEFINED.  THESE NAMES WILL BE KNOWN TO THE LINKAGE EDITOR,  *\n.*        AND START AT THE SAME POINT AS DOES THE ENTRY POINT DEFINED.*\n.*        THIS SHOULD ALWAYS BE SPECIFIED AS A SUBLIST.  DEFAULT IS   *\n.*        NULL (I.E., NO ALIASES).                                    *\n.*                                                                    *\n.*     DSASIZE='SIZE' - USED TO ESTABLISH THE DSA.  'DSA SIZE' MAY    *\n.*        CHANGE FROM ENTRY POINT TO ENTRY POINT. THE SMALLEST DSA IS *\n.*        88 BYTES, AND THIS IS THE DEFAULT IF NO DSA SIZE IS GIVEN   *\n.*        ON THE FIRST INVOKATION OF PLIARRV.  ON THE SECOND AND      *\n.*        SUBSEQUENT INVOKATIONS, THE DEFAULT DSA SIZE IS THAT USED   *\n.*        ON THE PREVIOUS INVOKATION.  THE DSA SIZE MUST BE A MULTIPLE*\n.*        OF 8 BYTES, AND BE SPECIFIED AS A DECIMAL NUMBER.           *\n.*                                                                    *\n.*     GETMTHD=PLI - USED TO DETERMINE THE METHOD TO BE USED TO GET   *\n.*        STORAGE FOR THE DSA.  THIS INDICATES PL/1 STORAGE MANAGEMENT*\n.*        ROUTINES ARE TO BE USED.  THIS IS THE DEFAULT.  THIS        *\n.*        STORAGE MUST NOT BE FREED BY THE USER - THE RETURN SEQUENCE *\n.*        FOR ROUTINES USING THIS METHOD IS AS FOLLOWS:               *\n.*                                                                    *\n.*               L     13,4(,13)      CHAIN BACK 1 SAVE AREA          *\n.*               LM    14,12,12(13)   RESTORE REGISTERS               *\n.*               BR    14             RETURN TO CALLER                *\n.*                                                                    *\n.*     GETMTHD=GETMAIN - IF SPECIFIED, WILL CAUSE AN R-FORM GETMAIN   *\n.*        TO BE ISSUED TO OBTAIN STORAGE FOR THE DSA.  IN THIS CASE,  *\n.*        THE CODE GENERATED REQUIRES ONLY STANDARD LINKAGE           *\n.*        CONVENTIONS BE FOLLOWED, HOWEVER, A GETMAIN WILL ALWAYS BE  *\n.*        ISSUED.  THIS IS PROVIDED FOR COMPATABILTY WITH OTHER       *\n.*        LANGUAGES AS WELL AS PL/1.  NOTE THAT THIS CODE SHOULD      *\n.*        NEVER BE USED WITH A CICS ROUTINE (\"GETMTHD=PLI\" IS         *\n.*        COMPATIBLE WITH CICS, HOWEVER).  IT IS THE USER'S           *\n.*        RESPONSIBILITY TO FREE THIS STORAGE WHEN IT IS NO LONGER    *\n.*        NEEDED.                                                     *\n.*                                                                    *\n.*     NOTE: IF MULTIPLE ENTRY POINTS ARE USED, THE FIRST MUST BE     *\n.*       DEFINED BY THIS MACRO.  THE BASE REGISTER IS SET BY ALL      *\n.*       OTHER USES OF THIS MACRO TO THE ADDRESS OF THIS FIRST ENTRY  *\n.*       POINT WHEN THE MACRO IS LEFT, REGARDLESS OF THE ENTRY POINT  *\n.*       USED TO INVOKE THE SUBROUTINE.                               *\n.*                                                                    *\n.*     IT IS THE USER'S RESPONSIBILITY TO MAKE CERTAIN THAT THE CODE  *\n.*        GENERATED BY THIS MACRO CAN ONLY BE ENTERED BY AN EXTERNAL  *\n.*        CALL TO THE ENTRY POINT BY A PL/1 ROUTINE.  MOST ESPECIALLY,*\n.*        EXECUTION SHOULD NOT \"FLOW INTO\" THIS CODE AS RESULTS WILL  *\n.*        BE UNPREDICTABLE (PROBABLY AN 0C1 OR 0C4 ABEND).            *\n.*                                                                    *\n.*     ON EXIT FROM THIS MACRO, REGISTER R3 WILL CONTAIN THE ADDRESS  *\n.*        OF THE FIRST (MAIN) ENTRY POINT DEFINED BY THIS MACRO (OR   *\n.*        THE FIRST SINCE THE LAST USE OF THE \"PLIEND\" MACRO), R15    *\n.*        WILL CONTAIN THE ADDRESS OF THE CURRENT ENTRY POINT, AND    *\n.*        R1 WILL CONTAIN WHATEVER IT HAD WHEN THE ENTRY POINT WAS    *\n.*        CALLED.  THE \"USING\" STATUS WILL BE WHATEVER IT WAS BEFORE  *\n.*        THE MACRO WAS USED, ALTHOUGH IT WILL PROBABLY BE INCORRECT. *\n.*                                                                    *\n.*     THERE MUST BE A ONE TO SEVEN CHARACTER LABEL ON THE MACRO      *\n.*        REFERENCE.  THIS LABEL IS USED AS THE ENTRY POINT TO THE    *\n.*        SUBROUTINE.                                                 *\n.*                                                                    *\n.*     THE FOLLOWING LABELS ARE OR MAY BE GENERATED BY THIS MACRO, AND*\n.*        SHOULD THEREFORE NOT BE USED IN THE ASSEMBLER ROUTINE:      *\n.*          PLIINIT, PROLGEND, AND THE CSECT NAME (SEE ABOVE).        *\n.*                                                                    *\n.*   THIS MACRO IS COPYRIGHT (C) 1983 BY THE CURATORS OF THE          *\n.*   UNIVERSITY OF MISSOURI, A PUBLIC CORPORATION.                    *\n.*                                                                    *\n.**********************************************************************\n         LCLA  &LEN                      LENGTH OF ENTRY POINT NAME\n         LCLA  &ACNT                     NUMBER OF ALIAS NAMES.\n         LCLB  &CSSKIP                   SKIP CSECT GENERATION?\n         LCLA  &BLANKS                   ALIGNMENT OF LABEL\n         LCLC  &LABEL1                   FOR ENTRY POINT NAME\n         LCLC  &LABEL2                   FOR ALIAS NAMES.\n         LCLC  &CPYYR                    COPYRIGHT YEAR.\n         GBLC  &LDSA                     DSA SIZE OR NULL.\n         GBLC  &CSNAME                   CSECT NAME\n         GBLC  &MAINEP                   LAST BASE ADDRESS.\n         GBLB  &INIT                     INITIALIZATION ROUTINE WRITTEN\n         GBLB  &CPYGEN                   1 IF ALREADY COPYRIGHTED\n         GBLB  &MENTRY                   1 IF MULTEP=YES, 0 O.W.\n.* VERIFY VALID GETMTHD\n         AIF   ('&GETMTHD' EQ 'PLI' OR '&GETMTHD' EQ 'GETMAIN').MTHDOK\n         MNOTE 8,'INVALID GETMTHD PARM, ''PLI'' ASSUMED'\n.MTHDOK  ANOP\n         AIF   (&CPYGEN).NOCPYRT\n&CPYYR   SETC  '&SYSDATE'(7,2)\n&CPYYR   SETC  '19&CPYYR'\n         AIF   ('&COPYRT' EQ '').NOCPYRT\n&CPYYR   SETC  '&COPYRT'\n.NOCPYRT ANOP\n.* CHECK DSA SIZE AND ADDRESS\n         AIF   ('&DSASIZE' EQ '').NODSA\n&LDSA    SETC  '&DSASIZE'\n         AGO   .GOODDSA\n.NODSA   ANOP\n         AIF   ('&LDSA' NE '').GOODDSA\n&LDSA    SETC  '88'\n.GOODDSA ANOP\n.*  GENERATE CSECT STATEMENT?\n         AIF   (&INIT).NOCSECT\n         AIF   ('&CSECT' EQ 'NO').NOCSECT\n         AIF   ('&CSECT' EQ 'YES').OK2\n         AIF   ('&CSECT' EQ 'ONLY').OK2\n         AGO   .ERR2\n.OK2     ANOP\n&CSSKIP  SETB  0\n         AGO   .GOCSECT\n.NOCSECT ANOP\n&CSSKIP  SETB  1\n.GOCSECT ANOP\n.* VERIFY VALID LABEL AND USE TO GENERATE  CSECT LABEL\n         AIF   ('&LABEL' EQ '').ERR1\n&LABEL1  SETC  '&LABEL'\n&LEN     SETA  K'&LABEL\n         AIF   (&LEN LE 7).CKCSSKP\n         MNOTE 4,'EXTERNAL ENTRY POINT NAME SHORTENED TO 7 CHARACTERS'\n&LABEL1  SETC  '&LABEL'(1,4).'&LABEL'(&LEN-2,3)\n&LEN     SETA  7\n.CKCSSKP AIF   (&CSSKIP).CG1\n&CSNAME  SETC  ''\n.CG1     ANOP\n&BLANKS  SETA  (K'&LABEL+1)/4\n&BLANKS  SETA  &BLANKS*4\n&BLANKS  SETA  K'&LABEL+1-&BLANKS\n&BLANKS  SETA  4-&BLANKS\n         AIF   (&CSSKIP).CG3\n.LOOPA   AIF   (&LEN GT 6).DCLA\n&CSNAME  SETC  '&CSNAME.#'\n&LEN     SETA  &LEN+1\n         AGO   .LOOPA\n.DCLA    ANOP\n&CSNAME  SETC  '&CSNAME.&LABEL1.1'\n&CSNAME  CSECT\n         AIF   (&CPYGEN).NODCCPY\n         DC    C'COPYRIGHT (C)&CPYYR BY THE CURATORS OF THE UNIVERSITY X\n               OF MISSOURI'\n&CPYGEN  SETB  1\n.NODCCPY ANOP\n.CG3     ANOP\n         AIF   ('&CSECT' NE 'ONLY').CG4\n         MEXIT\n.CG4     ANOP\n         DS    0D                        INSURE ALIGNMENT\n         PUSH  USING\n.* ENTRY STATEMENT\n         ENTRY &LABEL1\n         AIF   (&BLANKS EQ 4).NOBPAD\n         DC    CL&BLANKS' '              INSURE ALIGNMENT\n.NOBPAD  ANOP\n         DC    C'&LABEL'                 EYECATCHER FOR PL/1 TRACE\n&LEN     SETA  K'&LABEL                  RESET TO PROPER LENGTH.\n         DC    AL1(&LEN)                 FOR PL/1 TRACE IF NEEDED.\n&LABEL1  DS    0H                        REAL ENTRY POINT.\n         AIF   ('&ALIAS' EQ '').NOALIAS\n&ACNT    SETA  N'&ALIAS\n.ALOOP   ANOP\n         AIF   (&ACNT LT 1).NOALIAS\n&LABEL2  SETC  '&ALIAS(&ACNT)'\n&LEN     SETA  K'&LABEL2\n         AIF   (&LEN LE 8).ALIOK\n         MNOTE 4,'EXTERNAL ENTRY POINT NAME SHORTENED TO 7 CHARACTERS'\n&LABEL2  SETC  '&LABEL2'(1,4).'&LABEL2'(&LEN-2,3)\n.ALIOK   ANOP\n         ENTRY &LABEL2\n&LABEL2  EQU   *                         ALIAS ENTRY POINT.\n&ACNT    SETA  &ACNT-1\n         AGO   .ALOOP\n.NOALIAS ANOP\n         STM   14,12,12(13)              SAVE REGISTERS IN OLD DSA\n         AIF   (&INIT).MENTR2B\n&MAINEP  SETC  '&LABEL1'                 THE SAME CODE.\n         AIF   ('&MULTEP' EQ 'YES').MENTR2\n&MENTRY  SETB  0\n         AGO   .MENTR2B\n.MENTR2  ANOP\n&MENTRY  SETB  1\n.MENTR2B ANOP\n         B     16(,15)                   BRANCH AROUND CONSTANTS\n         DC    A(&MAINEP)                MAIN ENTRY POINT ADDRESS IN R3\n         DC    A(&LDSA)                  DSA SIZE REQUIRED.\n         L     3,8(,15)                  R3 IS THE STATIC BASE\n         L     0,12(,15)                 GET DSA SIZE NEEDED INTO R0.\n         USING &MAINEP,3                 INIT. ADDRESSABILITY\n         SPACE 1\n         AIF   (&INIT).NEWEP\n&INIT    SETB  1                         NEXT USE WILL NOT GENERATE\n         AIF   ('&MULTEP' EQ 'NO').EPONE4\n         LA    4,PROLGEND                SET UP RETURN REGISTER\n*  START OF INITIALIZATION FOR ALL ENTRY POINTS\nPLIINIT  EQU   *\n.EPONE4  ANOP\n         AIF   ('&GETMTHD' EQ 'GETMAIN').NOTPLI1\n         L     1,76(13)                  GET NEXT AVAIL. BYTE\n         ALR   0,1                       CALCULATE NEW NAB\n         CL    0,12(12)                  WILL NEW DSA FIT?\n         BNH   *+10                      (YES) - BRANCH AROUND CALL.\n         L     15,116(12)                DSA WILL NOT FIT - USE PL/1\n         BALR  14,15                     ROUTINES TO GET MORE CORE\n         ST    0,76(1)                   SAVE NEW NAB IN NEW DSA\n         AGO   .PLIOK1\n.NOTPLI1 ANOP\n         GETMAIN  R,LV=(0)               ACQUIRE STORAGE FOR DSA\n         MVC   76(4,1),76(13)            COPY FORWARD NAB FIELD ...\n.PLIOK1  ANOP\n         ST    13,4(1)                   SAVE OLD DSA @ IN NEW DSA\n         MVC   72(4,1),72(13)            COPY LWS ADDRESS INTO NEW DSA\n         LR    13,1                      POINT R13 TO NEW DSA\n         MVI   0(13),X'80'               SET FLAGS IN NEW DSA TO\n         MVI   1(13),X'00'               PRESERVE THE PL/1\n         MVI   86(13),X'91'              ERROR HANDLING IN\n         MVI   87(13),X'C0'              THE ASSEMBLER ROUTINE\n         AIF   ('&MULTEP' EQ 'NO').MEP02\n         BR    4                         RETURN AFTER SETUP\nPROLGEND EQU   *                         END OF PROLOGUE CODE\n.MEP02   ANOP\n         SPACE 1\n         DROP  3                         DROP TEMP. BASE R3, AND\n         POP   USING                     RESTORE OLD ADDRESSABILITY.\n         L     1,4(13)                   RESTORE ORIGINAL VALUES OF\n         L     15,16(1)                  R15 (ENTRY POINT) AND\n         L     1,24(1)                   OF R1 (PARM LIST).\n         SPACE 2\n         MEXIT\n.NEWEP   ANOP\n         AIF   (&MENTRY).GOODEP\n         AGO   .ERR3\n.GOODEP  ANOP\n         BAL   4,PLIINIT                 LINK TO PLI INIT. ROUTINE\n         AGO   .MEP02\n.ERR1    MNOTE 16,'INVALID ENTRY POINT LABEL'\n         MEXIT\n.ERR2    MNOTE 16,'INVALID VALUE FOR \"CSECT\" KEYWORD'\n         MEXIT\n.ERR3    MNOTE 16,'\"MULTEP=NO\" WAS SPECIFIED FOR MULTIPLE ENTRIES'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLIRETN": {"ttr": 3076, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   PLIRETN  &RC=\n.**********************************************************************\n.*  PLIRETN MACRO  -           BILL WARRINER, UMC-VMDL, 882-6811.     *\n.*                                                                    *\n.* FUNCTION - TERMINATES AN ASSEMBLER SUBROUTINE AND RESTORES THE OLD *\n.*    PL/1 ENVIRONMENT, RELEASING LIFO STORAGE REQUIRED BY THE ASM    *\n.*    ROUTINE.                                                        *\n.*                                                                    *\n.* PARMS:                                                             *\n.*    &RC   - THE RETURN CODE TO BE SET IN REGISTER 15.  IF OMITTED,  *\n.*            NO RETURN CODE WILL BE SET AND REGISTER 15 WILL BE      *\n.*            RESTORED TO ITS VALUE ON ENTRY TO THE ROUTINE           *\n.*            (THE DEFAULT FOR ROUTINES NOT DECLARED WITH             *\n.*            \"OPTIONS(ASM,RETCODE)\").  IF SPECIFIED, IT SHOULD BE    *\n.*            EITHER \"(15)\" TO INDICATE THE RETURN CODE IS ALREADY    *\n.*            SET OR A VALUE TO BE USED IN A LA INSTRUCTION OR A      *\n.*            REGISTER IN STANDARD REGISTER NOTATION.                 *\n.*                                                                    *\n.*                                                                    *\n.**********************************************************************\n&LABEL   L     13,4(,13)                 RECOVER @ OF OLD DSA\n         AIF   ('&RC' EQ '').NORC\n         AIF   ('&RC' EQ '(15)' OR '&RC' EQ '(R15)').NOLD\n         AIF   ('&RC'(1,1) EQ '(').NOLA\n         LA    15,&RC                    SET RETURN CODE\n         AGO   .NOLD\n.NOLA    LR    15,&RC(1)                 SET RETURN CODE\n.NOLD    L     14,12(,13)                RESTORE RETURN ADDRESS\n         LM    0,12,20(13)               RESTORE OTHER REGISTERS\n         BR    14                        RETURN TO CALLER\n         MEXIT\n.NORC    LM    14,12,12(13)              RESTORE REGISTERS\n         BR    14\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RELEASE": {"ttr": 3078, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    RELEASE &L,&RC=0,&LI=LA,&WORKREG=14,&FREE=YES,        05/08/77W\n               &SP=0,&RI=                                      01/06/78\n.*\n.*       RELEASE UNDOES WHAT CONNECT DID.  I.E., IT FREEMAINS\n.*       ANY SAVEAREA AFTER DISCONNECTING IT, RESTORES REGISTERS,\n.*       AND RETURNS.\n.*\n.*  CHANGES:                                                   05/08/77\n.*                                                             05/08/77\n.*       05/08/77 - ADD &WORKREG,&FREE,AND CHECK &RC           05/08/77\n.*       05/25/77 - FIXUP CODE FROM 05/08/77 TO SET RC         05/25/77\n.*       01/06/78 - ADD &SP (SUBPOOL SUPPORT)                  01/06/78\n.*       12/08/86 - CHANGED TO SUPPORT XA (BSM RETURN)         12/08/86\n.*                                                             05/08/77\n         GBLC  &SYSSPLV\n         LCLC  &RIN\n         LCLB  &CODE                                           05/08/77\n         SPLEVEL TEST\n&RIN     SETC  '&RI'\n         AIF   ('&RI' EQ 'BR' OR '&RI' EQ 'BSM' OR '&RI' EQ '').RIOK\n         MNOTE 8,'INVALID OPTION, RI=&RI, RI=,  (NULL) ASSUMED '\n         AGO   .NULLRI\n.RIOK    AIF   ('&RI' NE '').SETCODE\n.NULLRI  ANOP\n&RIN     SETC  'BSM'\n         AIF   ('&SYSSPLV' NE '1').SETCODE\n&RIN     SETC  'BR'\n.SETCODE ANOP\n&CODE    SETB  ('&RC' EQ '(15)' OR '&RC' EQ '(R15)')           05/08/77\n&CODE    SETB  (&CODE OR '&RC' EQ '(0)' OR '&RC' EQ '(R0)')    05/08/77\n&CODE    SETB  (&CODE OR '&RC' EQ '(1)' OR '&RC' EQ '(R1)')    05/08/77\n         AIF   ('&FREE' EQ 'NO').XNAME                         05/08/77\n         AIF   (T'&L EQ 'O').XNOFREE\n.XNAME   ANOP                                                  05/08/77\n&NAME    LR    1,13\n         L     13,4(,13)\n         XC    8(4,13),8(13)\n         AIF   ('&L' EQ 'NOFREE' OR '&FREE' EQ 'NO').XRC       05/08/77\n         AIF   (NOT &CODE).XLI                                 05/08/77\n         LR    &WORKREG,&RC(1)          SAVE RETURN CODE       05/08/77\n.XLI     &LI   0,&L                     WORKAREA LENGTH\n         AIF   ('&SYSSPLV' EQ '1').NOTXA1\n         MNOTE *,'       FREEMAIN RU,LV=(0),A=(1),SP=&SP  '\n         FREEMAIN RU,LV=(0),A=(1),SP=&SP\n         AGO   .XAJOIN1\n.NOTXA1  ANOP\n         ICM   R0,8,=AL1(&SP)\n         MNOTE *,'       FREEMAIN R,LV=(0),A=(1)          '\n         FREEMAIN R,LV=(0),A=(1)\n.XAJOIN1 ANOP\n         AIF   (NOT &CODE).XRC                                 05/25/77\n         LR    15,&WORKREG              SET THE RETURN CODE    05/08/77\n         AGO   .XRC\n.XNOFREE AIF   (T'&NAME EQ 'O').XRC\n&NAME    DS    0H\n.XRC     AIF   (T'&RC NE 'O').RCHK\n         LM    14,12,12(13)\n         AGO   .CKRETN\n.RCHK    AIF   ('&RC' EQ '0').RLA\n         AIF   ('&RC'(1,1) NE '(').RLA\n         AIF   ('&RC(1)' EQ '15' OR '&RC(1)' EQ 'R15').RETURN  05/08/77\n         AIF   (&CODE).RETURN                                  06/01/77\n         LR    15,&RC(1)\n         AGO   .RETURN\n.RLA     LA    15,&RC\n.RETURN  L     14,12(,13)\n         LM    0,12,20(13)\n.CKRETN  AIF   ('&RIN' EQ 'BR').BRRETN\n.BSMRETN ANOP\n         BSM   0,14\n         MEXIT\n.BRRETN  ANOP\n         BR    14\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETAMODE": {"ttr": 3081, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   SETAMODE  &AMOD,&R=15,&SAVE=,&TESTCVT=NO\n         GBLC  &SYSSPLV\n         LCLC  &TARGET,&REG\n         AIF   ('&AMOD' EQ '31' OR '&AMOD' EQ '24').AMODOK\n         AIF   ('&AMOD' EQ 'ANY' OR '&AMOD' EQ 'TEST').AMODOK\n         MNOTE 12,'** INVALID AMODE, &AMOD'\n         MEXIT\n.AMODOK  AIF   ('&LABEL' EQ '').NOLAB\n&LABEL   DS    0H\n.NOLAB   ANOP\n         SPLEVEL TEST\n         AIF   ('&SYSSPLV' NE '1').YESXA1\n         MEXIT\n.YESXA1  ANOP\n&TARGET  SETC  'AMOD&SYSNDX'\n         AIF   ('&TESTCVT' EQ 'NO' OR '&TESTCVT' EQ 'N').TSTDONE\n         AIF   ('&TESTCVT' EQ 'YES' OR '&TESTCVT' EQ 'Y').TSTCVT\n         MNOTE 8,'** INVALID VALUE, TESTCVT=&TESTCVT, NO ASSUMED'\n         AGO   .TSTDONE\n.TSTCVT  ANOP\n         L     &R,16\n         TM    CVTMVSE-CVT(&R),CVTMVSE   XA MODE?\n         BZ    &TARGET                   BRANCH IF NO.\n.TSTDONE ANOP\n         AIF   ('&SAVE' EQ '').NOSAVE\n         AIF   ('&SAVE'(1,1) EQ '(').REGSAVE\n         LA    &R,*+6\n         BASSM &R,&R         GET CURRENT AMODE\n         LTR   &R,&R\n         BNM   *+12          BRANCH IF NOT AMODE=31\n         OI    &SAVE,X'80'   ELSE SET AMODE BIT\n         B     *+8\n         NI    &SAVE,X'7F'   RESET AMODE BIT\n         AGO   .NOSAVE\n.REGSAVE ANOP\n         AIF   (K'&SAVE LT 3).SAVEBAD\n         AIF   ('&SAVE'(K'&SAVE,1) NE ')').SAVEBAD\n&REG     SETC  '&SAVE'(2,K'&SAVE-2)\n         LA    &R,*+6\n         BASSM &REG,&R       GET CURRENT AMODE\n         N     &REG,=A(X'80000000')  SAVE ONLY THE AMODE BIT\n         AGO   .NOSAVE\n.SAVEBAD MNOTE 8,'** INVALID AMODE SAVE REGISTER, &SAVE, IGNORED **'\n         MEXIT\n.NOSAVE  ANOP\n         AIF   ('&AMOD' EQ 'ANY' OR '&AMOD' EQ 'TEST').EXIT\n         LA    &R,&TARGET\n         AIF   ('&AMOD' EQ '31').ORIT\n         N     &R,=A(X'7FFFFFFF')\n         AGO   .REJOIN\n.ORIT    ANOP\n         O     &R,=A(X'80000000')\n.REJOIN  ANOP\n         BSM   0,&R\n.EXIT    ANOP\n&TARGET  DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRIM": {"ttr": 3083, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "TRIM     PLIARRV CSECT=ONLY,COPYRT=(1982,1984)\nTRIM     TITLE   'PL/1 STRING TRIM SUBROUTINE'\n         SPACE   1\n***********************************************************************\n*                    TRIM  -  ASSEMBLER SUBROUTINE                    *\n*                                                                     *\n*  FUNCTION - TRIMS OFF PRECEDING AND TRAILING BLANKS (HEX'40') AND/OR*\n*    NULLS (HEX'00') FROM A CHARACTER ARGUMENT FOR A PL/1 PROCEDURE.  *\n*    THIS ROUTINE MUST NOT BE DECLARED AS \"OPTIONS(ASM)\" AS IT        *\n*    USES THE PL/1 STRING LOCATOR/DESCRIPTORS FOR THE ARGUMENTS       *\n*    PASSED TO DETERMINE THE STRING TYPE (FIXED OR VARYING LENGTH).   *\n*                                                                     *\n*  THE ADVANTAGE TO USING THIS SUBROUTINE IS THAT STRING LENGTHS OF   *\n*    UP TO 32767 CAN BE ACCOMODATED FOR THE RETURN FIELD.  ALSO, IT   *\n*    IS MORE EFFICIENT THAN THE CORRESPONDING PL/1 ROUTINE.           *\n*                                                                     *\n*  USE: (IN A PL/1 PROCEDURE)                                         *\n*       USE THIS (WHERE THE LENGTH OF THE RETURN FIELD MAY VARY):     *\n*    DCL TRIM ENTRY(*,CHAR(*) VAR);                                   *\n*         .                                                           *\n*         .                                                           *\n*         .                                                           *\n*   CALL TRIM(STRING1,STRING2);  /* STRING1 CAN BE EITHER A FIXED  */ *\n*                                /* OR VARYING LENGTH CHAR. STRING,*/ *\n*                                /* STRING2 MUST BE VARYING, BUT   */ *\n*                                /* CAN BE IDENTICAL TO STRING1.   */ *\n*       USE THIS (WHERE THE MAXIMUM LENGTH OF THE RETURN FIELD IS     *\n*         KNOWN TO BE \"MAXLEN\"):                                      *\n*   DCL TRIM ENTRY(*) RETURNS(CHAR(\"MAXLEN\") VAR);                    *\n*         .                                                           *\n*         .                                                           *\n*         .                                                           *\n*   STRING2 = TRIM(STRING1);    /* STRING1 AND STRING2 AS ABOVE */    *\n*                                                                     *\n*                                                                     *\n*  NOTE:  THE STRING PASSED MUST BE A CHARACTER STRING, AND CAN       *\n*    BE DECLARED (REPLACE THE \"*\" WITH EITHER \"CHAR(*)\" OR            *\n*    \"CHAR(*) VAR\") IF DESIRED.                                       *\n*                                                                     *\n*  THE SUBROUTINE CAN ONLY BE USED IN ONE OF THE MANNERS SHOWN ABOVE  *\n*    IN ANY GIVEN PL/1 PROCEDURE OR BEGIN BLOCK.  TO GET AROUND THIS, *\n*    TWO ADDITIONAL ENTRY POINTS (\"TRIM1\" AND \"TRIM2\") ARE DEFINED,   *\n*    AND MAY BE USED AS ABOVE.  IN PL/1 ERROR MESSAGES, HOWEVER,      *\n*    THE ENTRY POINT WILL BE GIVEN AS \"TRIM\", REGARDLESS OF THE ALIAS *\n*    USED.                                                            *\n*                                                                     *\n*  THE ENTRY POINT MUST NOT BE DECLARED AS AN ASSEMBLER ENTRY POINT   *\n*    (I.E., DO NOT USE \"OPTIONS(ASM)\" OR \"OPTIONS(ASSEMBLER)\").       *\n*                                                                     *\n* MACROS:                                                             *\n*   PLIARRV, PLIRETN, EQUREGS.                                        *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*   R0, R1 - GENERAL WORK REGISTERS USED IN PROLOGUE CODE ONLY.       *\n*   R2 - NOT USED.                                                    *\n*   R3 - BASE REGISTER, ALWAYS POINTS TO ENTRY POINT \"TRIM\".          *\n*   R4 - POINTS TO SOURCE STRING LOCATOR/DESCRIPTOR.                  *\n*   R5 - POINTS TO DESTINATION STRING LOCATOR/DESCRIPTOR.             *\n*   R6 - POINTS TO FIRST CHARACTER (OR FIRST NONBLANK) IN SOURCE      *\n*        STRING.                                                      *\n*   R7 - CONTAINS THE NUMBER OF CHARACTERS BETWEEN THE FIRST AND LAST *\n*        NONBLANK CHARACTERS IN THE SOURCE STRING, INCLUSIVE.         *\n*   R8 - POINTS TO START OF DESTINATION STRING.                       *\n*   R9 - LENGTH OF DESTINATION STRING.                                *\n*   R10 - CONSTANT 1 FOR LOOP.                                        *\n*   R11 - POINTS TO LAST NONBLANK CHARACTER IN SOURCE STRING.         *\n*   R12 - PL/1 USE (NOT CHANGED BY THIS ROUTINE).                     *\n*   R13 - POINTS TO THE DSA                                           *\n*   R14 - LINK REGISTER.                                              *\n*   R15 - LINK REGISTER.                                              *\n*                                                                     *\n* THIS ROUTINE WAS WRITTEN ON 01/08/82 BY BILL WARRINER, VETERINARY   *\n*   DIAGNOSTIC LABORATORY, ROOM D-104, UMC CAMPUS (882-6811).         *\n* MODIFIED 02/05/82 TO ALLOW UNALIGNED CHARACTER STRINGS TO BE        *\n*   HANDLED.                                                          *\n* MODIFIED 03/12/84 TO USE MVCL INSTRUCTION INSTEAD OF BAL TO         *\n*   IELCGMV SUBROUTINE.                                               *\n*                                                                     *\n***********************************************************************\n         EJECT\nTRIM     PLIARRV CSECT=YES,MULTEP=NO,ALIAS=(TRIM1,TRIM2),DSASIZE=96\n         SPACE 1\n*        PROLOGUE DONE (DSA SET UP, BASE REGISTER SET, ETC.)\n         SPACE 1\n         USING TRIM,R3                   ESTABLISH ADDRESSABILITY\n         EJECT\n         L     R4,0(R1)                  @ OF L/D FOR SOURCE STRING\n         L     R5,4(R1)                  @ OF L/D FOR DEST. STRING\n         L     R6,0(R4)                  ADDRESS OF SOURCE STRING.\n         LH    R11,4(R4)                 SET COUNTER TO STRING LENGTH.\n         TM    6(R4),X'80'               IS STRING VARYING?\n         BZ    SRCNTVAR                  BRANCH IF NOT.\n         MVC   88(2,R13),0(R6)           USE CURRENT LENGTH (COPY IN\n         LH    R11,88(R13)               CASE NOT ALIGNED).\n         LA    R6,2(R6)                  BUMP PAST LENGTH FIELD.\nSRCNTVAR LTR   R11,R11                   ANY CHARS. IN SOURCE?\n         BNP   RETN0                     RETURN NULL STRING IF NO.\n         EJECT\n         LA    R10,1                     SET UP LOOP #1.\n         AR    R11,R6                    CALCULATE ADDRESS OF LAST\n         BCTR  R11,0                     CHAR. IN SOURCE (IN R11).\n*                                        CALCULATION: # OF CHARS. +\n*                                        @(FIRST CHAR.) - 1 =\n*                                        @(LAST CHAR.)\n         SPACE 2\n*** FIRST LOOP - FIND FIRST NONBLANK CHARACTER IN SOURCE STRING.    ***\n*** IN THIS LOOP, R6 POINTS AT THE CURRENT CHARACTER, R10 IS THE    ***\n*** INCREMENT REGISTER (SET TO 1), AND R11 IS THE LIMIT REGISTER.   ***\n*** FUNCTION IS TO FIND THE FIRST NONBLANK, AND SET ITS ADDRESS     ***\n*** IN REGISTER R6.                                                 ***\n         SPACE 1\nLOOP     CLI   0(R6),X'40'               TEST CHAR. FOR BLANK\n         BE    TRYNXT1                   IF IT IS, GO TO NEXT CHAR.\n         CLI   0(R6),X'00'               TEST CHAR. FOR NULL\n         BNE   NBLANK1                   IF NOT, FOUND FIRST CHAR.\nTRYNXT1  BXLE  R6,R10,LOOP               CHECK NEXT CHARACTER.\n***                                      (END OF FIRST LOOP).       ***\n         B     RETN0                     NO NONBLANK CHARS - RETURN\n*                                        A NULL STRING.\n         SPACE 5\n*** SECOND LOOP - FIND LAST NONBLANK CHARACTER IN SOURCE STRING.    ***\n*** IN THIS LOOP, R11 POINTS AT THE CURRENT CHARACTER, -1 IS THE    ***\n*** INCREMENT (CONSTANT), AND 0 IS THE LIMIT (CONSTANT).            ***\n*** FUNCTION IS TO FIND THE LAST NONBLANK, AND SET ITS ADDRESS      ***\n*** IN REGISTER R11.                                                ***\n         SPACE 1\nNBLANK1  CLI   0(R11),X'40'              IS THIS CHAR. BLANK?\n         BE    TRYNXT2                   IF YES, TRY NEXT CHAR.\n         CLI   0(R11),X'00'              IS IT NULL?\nTRYNXT2  BNE   NBLANK2                   (NO. LEAVE LOOP).\n         BCT   R11,NBLANK1               DECREMENT R11 AND TRY AGAIN.\n***                                      (END OF SECOND LOOP).      ***\n         SPACE 2\n*** (NO CHARACTERS TO COPY - RETURN A NULL OR BLANK STRING)         ***\nRETN0    SR    R7,R7                     0 CHARS. TO COPY.\n         B     MOVECOMP                  TO COMPARE & COPY STRING.\n         SPACE 1\n***  (NOW PERFORM THE COPY OPERATION FROM FIRST TO LAST NONBLANK)   ***\n         SPACE 1\nNBLANK2  LR    R7,R11                    CALC. # OF CHARS. TO COPY\n         SR    R7,R6                     IN R7 (END CHAR. LOCN. -\n         LA    R7,1(R7)                  START CHAR. LOCN. + 1)\nMOVECOMP C     R6,0(R5)                  ANY COPY TO PERFORM?\n         BNE   MOVECHRS                  IF YES, GO DO IT.\n         SPACE 1\n*** AT THIS POINT, A \"TRIM IN PLACE\" WAS REQUESTED BUT NOT REQUIRED.***\n*** SIMPLY SET THE LENGTH FIELD AND RETURN.                         ***\n         SPACE 1\n         L     R8,0(R5)                  @ OF DEST. STRING LENGTH FIELD\n         STH   R7,88(R13)                SAVE NEW LENGTH VALUE VIA DSA\n         MVC   0(2,R8),88(R13)           (IN CASE UNALIGNED), AND\n         B     RETURN                    RETURN TO CALLER (ALL DONE).\n         SPACE 3\n*** AT THIS POINT, THE TRIMMED STRING WILL BE COPIED INTO THE DEST. ***\n*** STRING.                                                         ***\n         SPACE 1\nMOVECHRS EQU   *\n         LH    R9,4(R5)                  MAX. DEST. LENGTH\n         CR    R9,R7                     ENOUGH SPACE TO COPY?\n         BNL   *+6                       BRANCH IF YES.\n         LR    R7,R9                     TRUNCATE IF NECESSARY.\n         L     R8,0(R5)                  ADDRESS OF DEST.\n         STH   R7,88(R13)                SET LENGTH FIELD.\n         MVC   0(2,R8),88(R13)            (USE MVC IN CASE UNALIGNED).\n         LR    R9,R7                     DO NOT PAD.\n         LA    R8,2(R8)                  BUMP PAST LENGTH FIELD.\n         MVCL  R8,R6                     COPY STRING.\n         SPACE 1\nRETURN   PLIRETN                         RETURN TO CALLER\n         SPACE 4\n         EQUREGS\n         SPACE 4\n         LTORG                           LITERAL POOL\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSJESSMF": {"ttr": 3087, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": " /* TSJESSMF - PL/1 PROGRAM TO PRINT JES2 SMF CKPT RECORDS  */\n %SKIP(1);\n TSJESSMF: PROC(PARM) OPTIONS(MAIN) REORDER;\n %SKIP(1);\n /********************************************************************/\n /* T S J E S S M F  -  PL/1 PROGRAM TO REPORT JES2 SMF CKPT RECORDS */\n /*                                                                  */\n /* FUNCTION - PRODUCES REPORTS FROM JES2 SMF CHEKPOINT RECORDS.     */\n /*    REPORTS MAY BE SUMMARY, DETAIL, OR BOTH.                      */\n /*    DETAIL LISTS EACH RECORD AS ENCOUNTERED ON SMFIN FILE.        */\n /*    SUMMARY PROVIDES SUMMARY DATA, OVER 15-MINUTE INTERVALS,      */\n /*    OF CHECKPOINT ACTIVITY.  EACH SUMMARY LINE SHOWS THE AVERAGE  */\n /*    AND PERCENTAGE TIME SPENT DURING THAT INTERVAL IN EACH OF THE */\n /*    3 STATES DURING A CHECKPOINT CYCLE (DESCRIBED BELOW).         */\n /*                                                                  */\n /*    CHECKPOINT CYCLES ARE ASSUMED TO BE MONITORED VIA SMF USER    */\n /*    TYPE 253 RECORDS.  RECORDS HAVE 3 POSSIBLE VALUES OF          */\n /*    \"JESFLAG\" (LAST 4 BYTES IN RECORD) (VALUES ARE BINARY):       */\n /*         0 = RECORD WRITTEN WHEN CONTROL OF QUEUES IS FIRST       */\n /*             REQUESTED.                                           */\n /*         4 = RECORD WRITTEN WHEN CONTROL OF QUEUES IS OBTAINED.   */\n /*         8 = RECORD WRITTEN WHEN CONTROL OF QUEUES IS RELEASED.   */\n /*                                                                  */\n /*      THE 3 INTERVALS REPORTED ARE:  TIME FROM REC0 TO REC4 =     */\n /*      \"WAIT\" TIME, TIME FROM REC4 TO REC8 = \"HOLD\" TIME, AND      */\n /*      TIME FROM REC8 TO NEXT REC0 = \"DORMANCY\" TIME.              */\n /*                                                                  */\n /*  PARAMETER: A PARAMETER MAY BE PASSED TO THIS PROGRAM IN         */\n /*        THE FORM OF A 4 OR 8-CHARACTER STRING.  THE FIRST 4       */\n /*        CHARACTERS OF THE STRING INDICATE THE SMF SYSID TO        */\n /*        SELECT FOR THIS RUN AND THE NEXT 4 CHARACTERS INDICATE    */\n /*        THE JES2 SYSID TO SELECT FOR THIS RUN.  IF EITHER OR      */\n /*        BOTH ARE OMITTED OR SPECIFIED AS BLANKS, THE FIRST        */\n /*        SMF AND/OR JES2 SYSID ENCOUNTERED IN THE INPUT DATA       */\n /*        WILL BE USED.                                             */\n /*                                                                  */\n /*  FILES USED:                                                     */\n /*        SYSPRINT - ERROR MESSAGES, ETC.                           */\n /*        SMFIN - SMF INPUT DATA                                    */\n /*        DETAIL - DETAIL REPORT OF CHECKPOINT PERFORMANCE          */\n /*        SUMMARY - SUMMARY REPORT OF CHECKPOINT PERFORMANCE        */\n /*        WAITTIM - PLOT OF WAIT TIME BY INTERVAL.                  */\n /*        HOLDTIM - PLOT OF HOLD TIME BY INTERVAL.                  */\n /*        DORMTIM - PLOT OF DORM TIME BY INTERVAL.                  */\n /*                                                                  */\n /*   WHERE: \"WAIT TIME\" IS THE TIME BETWEEN A REQUEST FOR THE       */\n /*        CHECKPOINT LOCK AND THE TIME THE LOCK IS OBTAINED,        */\n /*          \"HOLD TIME\" IS THE TIME BETWEEN THE CHECKPOINT LOCK     */\n /*        IS OBTAINED AND THE TIME IT IS RELEASED, AND              */\n /*          \"DORM TIME\" IS THE TIME BETWEEN THE RELEASE OF THE      */\n /*        CHECKPOINT LOCK AND THE NEXT REQUEST TO OBTAIN IT.        */\n /*                                                                  */\n /*   WRITTEN ON 05/01/87 BY BILL WARRINER, UMCHC                    */\n /*                                                                  */\n /*   UPDATE HISTORY:                                                */\n /*      MM/DD/YY                                                    */\n /*                                                                  */\n /********************************************************************/\n %PAGE;\n           DCL COPYRT CHAR(64) STATIC EXTERNAL\n             INIT('COPYRIGHT (C) 1987 BY THE CURATORS OF THE UNIVERSITY\n OF MISSOURI');\n           DCL PARM CHAR(100) VAR;\n           DCL (SELECT_JESID,SELECT_SMFID) CHAR(4) INIT('    ');\n           DCL SMFIN FILE RECORD INPUT SEQL ENV(VBS RECSIZE(32760));\n           DCL (SYSPRINT,DETAIL,SUMMARY) FILE PRINT STREAM OUTPUT;\n           DCL (WAITTIM,HOLDTIM,DORMTIM) FILE PRINT STREAM OUTPUT;\n           DCL (SMFREC_PTR,LAST_DETAIL_REC_PTR,LAST_SUMMARY_REC_PTR)\n             POINTER;\n           DCL 1 LAST_DETAIL_REC,\n                 3 SMFFLAG BIT(8) ALIGNED INIT('00000000'B),\n                 3 SMFTYPE BIT(8) ALIGNED INIT('00000000'B),\n                 3 SMFTIME FIXED BIN(31) INIT(0),\n                 3 SMFDATE FIXED DEC(7,3) INIT(0),\n                 3 SMFSID CHAR(4) INIT((4)' '),\n                 3 JESSID CHAR(4) INIT((4)' '),\n                 3 JESTYPE FIXED BIN(31) INIT(0);\n           DCL 1 LAST_SUMMARY_REC LIKE LAST_DETAIL_REC;\n           DCL 1 SMFREC BASED(SMFREC_PTR) UNALIGNED\n             LIKE LAST_DETAIL_REC;\n           DCL SMFREC_OVLY CHAR(22) BASED;\n           DCL DETAIL_LINE CHAR(120) INIT((120)' ');\n           DCL 1 DETAIL_STRUC DEF DETAIL_LINE POS(1),\n                 3 SPACE1 CHAR(5),\n                 3 RECDATE PIC'99V.999',\n                 3 SPACE2  CHAR(1),\n                 3 RECHH   PIC'99',\n                 3 COLON1  CHAR(1),\n                 3 RECMM   PIC'99',\n                 3 COLON2  CHAR(1),\n                 3 RECSS   PIC'99.99',\n                 3 SPACE3  CHAR(2),\n                 3 DIFF_SECS PIC'ZZZZ9.99',\n                 3 SPACE4  CHAR(5),\n                 3 REC_SMFID CHAR(4),\n                 3 SPACE5  CHAR(2),\n                 3 REC_JESID CHAR(4),\n                 3 SPACE6  CHAR(2),\n                 3 REC_FUNCT CHAR(24),\n                 3 FILLER CHAR(46);  /* TO MAKE 100 CHARS */\n           DCL RECDATE_OVLY CHAR(6) DEF DETAIL_LINE POS(6);\n           DCL DIFFTIME_OVLY CHAR(8) DEF DETAIL_LINE POS(26);\n           DCL SUMMARY_LINE CHAR(120) INIT((120)' ');\n           DCL SUMM_DXX_OVLY CHAR(8) DEF SUMMARY_LINE POS(40);\n           DCL 1 SUMMARY_STRUC DEF SUMMARY_LINE POS(1),\n                 3 SPACE1 CHAR(5),\n                 3 SUMM_SDATE PIC'99V.999',\n                 3 SPACE1A CHAR(2),\n                 3 SUMM_SHH PIC'99',\n                 3 COLON3 CHAR(1),\n                 3 SUMM_SMM PIC'99',\n                 3 COLON4 CHAR(1),\n                 3 SUMM_SSS PIC'99.99',\n                 3 SPACE2 CHAR(2),\n                 3 SUMM_EHH PIC'99',\n                 3 COLON5 CHAR(1),\n                 3 SUMM_EMM PIC'99',\n                 3 COLON6 CHAR(1),\n                 3 SUMM_ESS PIC'99.99',\n                 3 SPACE2A CHAR(2),\n                 3 SUMM_DMM PIC'999',\n                 3 COLON7 CHAR(1),\n                 3 SUMM_DSS PIC'99.99',\n                 3 SPACE3 CHAR(4),\n                 3 SUMM_WAIT PIC'Z9.99V9',\n                 3 LPAREN1 CHAR(1),\n                 3 SUMM_WAIT_PCT PIC'ZZ9V.9',\n                 3 RPAREN1 CHAR(1),\n                 3 SPACE4 CHAR(2),\n                 3 SUMM_HOLD PIC'Z9.99V9',\n                 3 LPAREN2 CHAR(1),\n                 3 SUMM_HOLD_PCT PIC'ZZ9V.9',\n                 3 RPAREN2 CHAR(1),\n                 3 SPACE5 CHAR(2),\n                 3 SUMM_DORM PIC'Z9.99V9',\n                 3 LPAREN3 CHAR(1),\n                 3 SUMM_DORM_PCT PIC'ZZ9V.9',\n                 3 RPAREN3 CHAR(1),\n                 3 SPACE6 CHAR(2),\n                 3 SUMM_COUNT PIC'ZZZZZ9',\n                 3 SPACE7 CHAR(2),\n                 3 SUMM_SMFID CHAR(4),\n                 3 SPACE8 CHAR(2),\n                 3 SUMM_JESID CHAR(4),\n                 3 FILLER CHAR(5);\n           DCL (RECS_READ,RECS_USED,RECS_ERR) FIXED BIN(31) INIT(0);\n           DCL TRUE BIT(1) STATIC INIT('1'B);\n           DCL FIRST_DETAIL_LINE BIT(1) INIT('1'B);\n           DCL FIRST_SUMMARY_REC BIT(1) INIT('1'B);\n           DCL (FIRST_WAIT_GRAPH,FIRST_HOLD_GRAPH,FIRST_DORM_GRAPH)\n             BIT(1) INIT('1'B);\n           DCL (PRINT_DETAIL,PRINT_SUMMARY) BIT(1) INIT('0'B);\n           DCL (PRINT_WAITTIM,PRINT_HOLDTIM,PRINT_DORMTIM)\n             BIT(1) INIT('0'B);\n           DCL JES2_SMF_RECTYPE BIT(8) ALIGNED STATIC\n             INIT('11111101'B);\n           DCL SUMMARY_INTVL FIXED BIN(31) STATIC INIT(90000);\n           DCL END_SUMMARY_INTVL FIXED BIN(31) INIT(0);\n           DCL END_SUMMARY_DATE FIXED DEC(7,3) INIT(0);\n           DCL (SUM_WAIT_CKPT,SUM_HOLD_CKPT,SUM_NOHOLD_CKPT)\n             FIXED BIN(31) INIT(0);\n           DCL (COUNT_WAIT_CKPT,COUNT_HOLD_CKPT,COUNT_NOHOLD_CKPT)\n             FIXED BIN(15) INIT(0);\n   /***    DCL (SUMSQ_WAIT_CKPT,SUMSQ_HOLD_CKPT,SUMSQ_NOHOLD_CKPT)\n             FLOAT DEC(6) INIT(0);  ***/\n           DCL (MIN_WAIT_CKPT,MIN_HOLD_CKPT,MIN_NOHOLD_CKPT)\n             FIXED BIN(31) INIT(2147483647);\n           DCL (MAX_WAIT_CKPT,MAX_HOLD_CKPT,MAX_NOHOLD_CKPT)\n             FIXED BIN(31) INIT(0);\n           DCL (ADDR,MOD,MIN,MAX,FLOAT) BUILTIN;\n %PAGE;\n           ON ENDFILE(SMFIN) GO TO EODAD;\n           OPEN FILE(SYSPRINT);\n           ON UNDEFINEDFILE(DETAIL) GO TO NODETAIL;\n           OPEN FILE(DETAIL) LINESIZE(120) PAGESIZE(60);\n           PRINT_DETAIL = '1'B;\n NODETAIL:\n           ON UNDEFINEDFILE(SUMMARY) GO TO NOSUMMARY;\n           OPEN FILE(SUMMARY) LINESIZE(120) PAGESIZE(60);\n           PRINT_SUMMARY = '1'B;\n           ON UNDEFINEDFILE(WAITTIM) GO TO NOWAITTM;\n           OPEN FILE(WAITTIM) LINESIZE(120) PAGESIZE(60)\n             TITLE('WAITTIME');\n           PRINT_WAITTIM = '1'B;\n           ON ENDPAGE(WAITTIM) BEGIN;\n               PUT FILE(WAITTIM) PAGE EDIT(\n                 'CHECKPOINT WAIT TIME STATISTICS BY INTERVAL',\n                 ' .150',' .300',' .450',' .600',' .750',' .900',\n                 '1.050','1.200','1.350','1.500',\n                 (10)'----+----|','MIN','MAX','CNT')\n                 (SKIP,X(38),A,SKIP,(10)(X(5),A(5)),SKIP,A(100),X(2),\n                 A(6),X(1),A(6),X(1),A(4));\n               PUT FILE(WAITTIM) SKIP;\n               END;\n NOWAITTM:\n           ON UNDEFINEDFILE(HOLDTIM) GO TO NOHOLDTM;\n           OPEN FILE(HOLDTIM) LINESIZE(120) PAGESIZE(60)\n             TITLE('HOLDTIME');\n           PRINT_HOLDTIM = '1'B;\n           ON ENDPAGE(HOLDTIM) BEGIN;\n               PUT FILE(WAITTIM) PAGE EDIT(\n                 'CHECKPOINT HOLD TIME STATISTICS BY INTERVAL',\n                 ' .150',' .300',' .450',' .600',' .750',' .900',\n                 '1.050','1.200','1.350','1.500',\n                 (10)'----+----|','MIN','MAX','CNT')\n                 (SKIP,X(38),A,SKIP,(10)(X(5),A(5)),SKIP,A(100),X(2),\n                 A(6),X(1),A(6),X(1),A(4));\n               PUT FILE(HOLDTIM) SKIP;\n               END;\n NOHOLDTM:\n           ON UNDEFINEDFILE(DORMTIM) GO TO NOSUMMARY;\n           OPEN FILE(DORMTIM) LINESIZE(120) PAGESIZE(60)\n             TITLE('DORMTIME');\n           PRINT_DORMTIM = '1'B;\n           ON ENDPAGE(DORMTIM) BEGIN;\n               PUT FILE(DORMTIM) PAGE EDIT(\n                 'CHECKPOINT DORMANCY TIME STATISTICS BY INTERVAL',\n                 ' 1.500',' 3.000',' 4.500',' 6.000',' 7.500',' 9.000',\n                 '10.500','12.000','13.500','15.000',\n                 (10)'----+----|','MIN','MAX','CNT')\n                 (SKIP,X(36),A,SKIP,(10)(X(4),A(6)),SKIP,A(100),X(2),\n                 A(6),X(1),A(6),X(1),A(4));\n               PUT FILE(DORMTIM) SKIP;\n               END;\n NOSUMMARY:\n           LAST_DETAIL_REC_PTR = ADDR(LAST_DETAIL_REC);\n           COLON1, COLON2, COLON3, COLON4, COLON5, COLON6, COLON7 = ':';\n           LPAREN1, LPAREN2, LPAREN3 = '(';\n           RPAREN1, RPAREN2, RPAREN3 = ')';\n           IF PARM\u00ac='' THEN DO;\n               SELECT_SMFID = SUBSTR(PARM||(8)' ',1,4);\n               SELECT_JESID = SUBSTR(PARM||(8)' ',5,4);\n               END;\n SMFLOOP:  DO WHILE(TRUE);\n               READ FILE(SMFIN) SET(SMFREC_PTR);\n               RECS_READ = RECS_READ + 1;\n               IF SMFREC.SMFTYPE=JES2_SMF_RECTYPE &\n                  SMFREC_PTR->SMFREC_OVLY \u00ac=\n                  LAST_DETAIL_REC_PTR->SMFREC_OVLY\n               THEN DO;\n                   RECS_USED = RECS_USED + 1;\n                   IF SELECT_SMFID='    '\n                   THEN SELECT_SMFID = SMFREC.SMFSID;\n                   IF SELECT_JESID='    '\n                   THEN SELECT_JESID = SMFREC.JESSID;\n                   IF PRINT_DETAIL\n                   THEN CALL PRINT_DETAIL_LINE;\n                   IF SELECT_SMFID=SMFREC.SMFSID &\n                     SELECT_JESID=SMFREC.JESSID &\n                     PRINT_SUMMARY\n                   THEN CALL ADD_SUMMARY_REC;\n                   LAST_DETAIL_REC = SMFREC;\n                   END;\n NEXTREC:      END SMFLOOP;\n EODAD:\n           IF PRINT_SUMMARY & \u00acFIRST_SUMMARY_REC\n           THEN CALL PRINT_SUMMARY_LINE;  /* PRINT THE LAST LINE */\n           PUT FILE(SYSPRINT) SKIP(2) EDIT(\n             RECS_READ,' RECORDS READ, ',RECS_USED,' RECORDS REPORTED',\n             RECS_ERR,' RECORDS IN ERROR')((3)(F(10),A));\n           RETURN;\n %PAGE;\n PRINT_DETAIL_LINE:  PROC REORDER;\n %SKIP;\n           DCL (DIFFTIME,WORKTIME) FIXED BIN(31);\n %SKIP;\n           ON ERROR SNAP BEGIN;\n               ON ERROR SNAP SYSTEM;\n               DCL PDUMP ENTRY(PTR,FIXED BIN(31),CHAR(*));\n               DCL PDUMPSP ENTRY(PTR,FIXED BIN(31),CHAR(*));\n               PUT FILE(SYSPRINT) SKIP(2) EDIT('ERROR ENCOUNTERED, ',\n                 'DETAIL RECORD SKIPPED:')(A,A);\n               CALL PDUMPSP(SMFREC_PTR,32,'*** RECORD IN ERROR ***');\n               RECS_ERR = RECS_ERR + 1;\n               GO TO PRTDONE;\n               END;\n           ON ENDPAGE(DETAIL) BEGIN;\n               PUT FILE(DETAIL) PAGE EDIT('SYS','SYS',' ','SMF','JES2',\n                 'FUNCTION','DATE','TIME','INTERVAL',\n                 'SYSID','SYSID','PERFORMED')\n                 ((2)(SKIP,X(5),A(6),X(1),A(11),X(2),A(8),X(5),\n                 A(5),X(1),A(5),X(1),A));\n               PUT FILE(DETAIL) SKIP(2);\n               RECDATE = SMFREC.SMFDATE;\n               END;\n           WORKTIME = SMFREC.SMFTIME/6000;\n           RECHH = WORKTIME/60;  /* HOURS SINCE MIDNIGHT */\n           RECMM = MOD(WORKTIME,60);\n           RECSS = MOD(SMFREC.SMFTIME,6000);\n           SELECT(SMFREC.JESTYPE);\n               WHEN(0) REC_FUNCT = 'CKPT REQUESTED';\n               WHEN(4) REC_FUNCT = 'CKPT OBTAINED';\n               WHEN(8) REC_FUNCT = 'CKPT RELEASED';\n               OTHERWISE REC_FUNCT = '??? UNKNOWN ???';\n               END;\n           IF LAST_DETAIL_REC.SMFTYPE\u00ac='00000000'B\n           THEN DO;\n               DIFFTIME = SMFREC.SMFTIME-LAST_DETAIL_REC.SMFTIME;\n               DO WHILE(DIFFTIME<0);\n                   DIFFTIME = DIFFTIME + 8640000;\n                   END;\n               END;\n           ELSE DIFFTIME = 0;\n           IF FIRST_DETAIL_LINE\n           THEN DO;\n               PUT FILE(DETAIL) EDIT('SYS','SYS',' ','SMF','JES2',\n                 'FUNCTION','DATE','TIME','INTERVAL',\n                 'SYSID','SYSID','PERFORMED')\n                 ((2)(SKIP,X(5),A(6),X(1),A(11),X(2),A(8),X(5),\n                 A(5),X(1),A(5),X(1),A));\n               PUT FILE(DETAIL) SKIP;\n               RECDATE = SMFREC.SMFDATE;\n               END;\n           ELSE RECDATE_OVLY = '      ';\n           IF DIFFTIME=0\n           THEN DIFFTIME_OVLY = '        ';\n           ELSE DIFF_SECS = DIFFTIME;\n           PUT FILE(DETAIL) SKIP EDIT(DETAIL_LINE)(A);\n           FIRST_DETAIL_LINE = '0'B;\n PRTDONE:  END PRINT_DETAIL_LINE;\n %PAGE;\n ADD_SUMMARY_REC: PROC REORDER;\n %SKIP;\n           DCL (DIFFTIME,WORKTIME) FIXED BIN(31);\n %SKIP;\n           ON ERROR SNAP BEGIN;\n               ON ERROR SNAP SYSTEM;\n               DCL PDUMP ENTRY(PTR,FIXED BIN(31),CHAR(*));\n               DCL PDUMPSP ENTRY(PTR,FIXED BIN(31),CHAR(*));\n               PUT FILE(SYSPRINT) SKIP(2) EDIT('ERROR ENCOUNTERED, ',\n                 'DETAIL RECORD SKIPPED:')(A,A);\n               CALL PDUMPSP(SMFREC_PTR,32,'*** RECORD IN ERROR ***');\n               RECS_ERR = RECS_ERR + 1;\n               GO TO SUMDONE;\n               END;\n           IF FIRST_SUMMARY_REC\n           THEN DO;\n               PUT FILE(SUMMARY) EDIT(\n                 'INTVAL','INTERVAL','INTERVAL',' ','AVERAGE','AVERAGE',\n                 'AVERAGE','TIMES',' ',' ',\n                 'START','STARTING','ENDING','INTERVAL','WAIT FOR',\n                 'HOLD','DORMANCY','QUEUES','SMF','JES',\n                 'DATE','TIME','TIME','LENGTH','CONTROL (%)',\n                 'TIME (%)','TIME (%)','HELD','SYSID','SYSID')\n                 ((3)(SKIP,X(5),A(6),X(2),A(11),X(2),A(11),X(2),A(9),\n                 X(4),A(13),X(2),A(13),X(2),A(13),X(2),A(6),X(2),\n                 A(5),X(1),A(5)));\n               PUT FILE(SUMMARY) SKIP;\n               CALL START_SUMMARY_INTERVAL;\n               SUMM_SMFID = SMFREC.SMFSID;\n               SUMM_JESID = SMFREC.JESSID;\n               FIRST_SUMMARY_REC = '0'B;\n               LAST_SUMMARY_REC = SMFREC;\n               RETURN;\n               END;\n           IF SMFREC.SMFDATE>END_SUMMARY_DATE |\n              (SMFREC.SMFDATE=END_SUMMARY_DATE &\n               SMFREC.SMFTIME>END_SUMMARY_INTVL)\n           THEN CALL PRINT_SUMMARY_LINE;\n           DIFFTIME = SMFREC.SMFTIME-LAST_SUMMARY_REC.SMFTIME;\n           DO WHILE(DIFFTIME<0);\n               DIFFTIME = DIFFTIME + 8640000;\n               END;\n           SELECT;\n               WHEN(LAST_SUMMARY_REC.JESTYPE=0 & SMFREC.JESTYPE=4) DO;\n                   SUM_WAIT_CKPT = SUM_WAIT_CKPT + DIFFTIME;\n    /***           SUMSQ_WAIT_CKPT = SUMSQ_WAIT_CKPT +\n                     (DIFFTIME * DIFFTIME);  ***/\n                   MIN_WAIT_CKPT = MIN(MIN_WAIT_CKPT,DIFFTIME);\n                   MAX_WAIT_CKPT = MAX(MAX_WAIT_CKPT,DIFFTIME);\n                   COUNT_WAIT_CKPT = COUNT_WAIT_CKPT + 1;\n                   END;\n               WHEN(LAST_SUMMARY_REC.JESTYPE=4 & SMFREC.JESTYPE=8) DO;\n                   SUM_HOLD_CKPT = SUM_HOLD_CKPT + DIFFTIME;\n    /***           SUMSQ_HOLD_CKPT = SUMSQ_HOLD_CKPT +\n                     (DIFFTIME * DIFFTIME);  ***/\n                   MIN_HOLD_CKPT = MIN(MIN_HOLD_CKPT,DIFFTIME);\n                   MAX_HOLD_CKPT = MAX(MAX_HOLD_CKPT,DIFFTIME);\n                   COUNT_HOLD_CKPT = COUNT_HOLD_CKPT + 1;\n                   END;\n               WHEN(LAST_SUMMARY_REC.JESTYPE=8 & SMFREC.JESTYPE=0) DO;\n                   SUM_NOHOLD_CKPT = SUM_NOHOLD_CKPT + DIFFTIME;\n    /***           SUMSQ_NOHOLD_CKPT = SUMSQ_NOHOLD_CKPT +\n                     (DIFFTIME * DIFFTIME);  ***/\n                   MIN_NOHOLD_CKPT = MIN(MIN_NOHOLD_CKPT,DIFFTIME);\n                   MAX_NOHOLD_CKPT = MAX(MAX_NOHOLD_CKPT,DIFFTIME);\n                   COUNT_NOHOLD_CKPT = COUNT_NOHOLD_CKPT + 1;\n                   END;\n               OTHERWISE;\n               END;\n           LAST_SUMMARY_REC = SMFREC;\n SUMDONE:  END ADD_SUMMARY_REC;\n %PAGE;\n PRINT_SUMMARY_LINE: PROC REORDER;\n %SKIP;\n           DCL (WORKTIME,DIFFTIME) FIXED BIN(31);\n           DCL (XXXX_WAIT,XXXX_HOLD,XXXX_DORM) FLOAT DEC(6);\n %SKIP;\n           ON ERROR SNAP BEGIN;\n               ON ERROR SNAP SYSTEM;\n               DCL PDUMP ENTRY(PTR,FIXED BIN(31),CHAR(*));\n               DCL PDUMPSP ENTRY(PTR,FIXED BIN(31),CHAR(*));\n               PUT FILE(SYSPRINT) SKIP(2) EDIT('ERROR ENCOUNTERED, ',\n                 'DETAIL RECORD SKIPPED:')(A,A);\n               CALL PDUMPSP(SMFREC_PTR,32,'*** RECORD IN ERROR ***');\n               RECS_ERR = RECS_ERR + 1;\n               GO TO SUMDONE;\n               END;\n           ON ENDPAGE(SUMMARY) BEGIN;\n               PUT FILE(SUMMARY) PAGE EDIT(\n                 'INTVAL','INTERVAL','INTERVAL',' ','AVERAGE','AVERAGE',\n                 'AVERAGE','TIMES',' ',' ',\n                 'START','STARTING','ENDING','INTERVAL','WAIT FOR',\n                 'HOLD','DORMANCY','QUEUES','SMF','JES',\n                 'DATE','TIME','TIME','LENGTH','CONTROL (%)',\n                 'TIME (%)','TIME (%)','HELD','SYSID','SYSID')\n                 ((3)(SKIP,X(5),A(6),X(2),A(11),X(2),A(11),X(2),A(9),\n                 X(4),A(13),X(2),A(13),X(2),A(13),X(2),A(6),X(2),\n                 A(5),X(1),A(5)));\n               PUT FILE(SUMMARY) SKIP(2);\n               END;\n           WORKTIME = LAST_SUMMARY_REC.SMFTIME/6000;\n           SUMM_EHH = WORKTIME/60;  /* HOURS SINCE MIDNIGHT */\n           SUMM_EMM = MOD(WORKTIME,60);\n           SUMM_ESS = MOD(LAST_SUMMARY_REC.SMFTIME,6000);\n           IF COUNT_WAIT_CKPT>0\n           THEN XXXX_WAIT = FLOAT(SUM_WAIT_CKPT)/COUNT_WAIT_CKPT;\n           ELSE XXXX_WAIT = 0;\n           SUMM_WAIT = XXXX_WAIT;\n           IF COUNT_HOLD_CKPT>0\n           THEN XXXX_HOLD = FLOAT(SUM_HOLD_CKPT)/COUNT_HOLD_CKPT;\n           ELSE XXXX_HOLD = 0;\n           SUMM_HOLD = XXXX_HOLD;\n           IF COUNT_NOHOLD_CKPT>0\n           THEN XXXX_DORM = FLOAT(SUM_NOHOLD_CKPT)/COUNT_NOHOLD_CKPT;\n           ELSE XXXX_DORM = 0;\n           SUMM_DORM = XXXX_DORM;\n           SUMM_COUNT = COUNT_HOLD_CKPT;\n           DIFFTIME = SUM_WAIT_CKPT + SUM_HOLD_CKPT + SUM_NOHOLD_CKPT;\n           WORKTIME = DIFFTIME/6000;\n           IF WORKTIME<1000\n           THEN DO;\n               SUMM_DMM = WORKTIME;\n               SUMM_DSS = MOD(DIFFTIME,6000);\n               END;\n           ELSE SUMM_DXX_OVLY = '**:**.*';\n           SUMM_WAIT_PCT = (100.0*SUM_WAIT_CKPT)/DIFFTIME;\n           SUMM_HOLD_PCT = (100.0*SUM_HOLD_CKPT)/DIFFTIME;\n           SUMM_DORM_PCT = (100.0*SUM_NOHOLD_CKPT)/DIFFTIME;\n           PUT FILE(SUMMARY) SKIP EDIT(SUMMARY_LINE)(A);\n           IF PRINT_WAITTIM & FIRST_WAIT_GRAPH\n           THEN DO;\n               PUT FILE(WAITTIM) EDIT(\n                 'CHECKPOINT WAIT TIME STATISTICS BY INTERVAL',\n                 ' .150',' .300',' .450',' .600',' .750',' .900',\n                 '1.050','1.200','1.350','1.500',\n                 (10)'----+----|','MIN','MAX','CNT')\n                 (SKIP,X(38),A,SKIP,(10)(X(5),A(5)),SKIP,A(100),X(2),\n                 A(6),X(1),A(6),X(1),A(4));\n               PUT FILE(WAITTIM) SKIP;\n               FIRST_WAIT_GRAPH = '0'B;\n               END;\n           IF PRINT_HOLDTIM & FIRST_HOLD_GRAPH\n           THEN DO;\n              PUT FILE(HOLDTIM) EDIT(\n                 'CHECKPOINT HOLD TIME STATISTICS BY INTERVAL',\n                 ' .150',' .300',' .450',' .600',' .750',' .900',\n                 '1.050','1.200','1.350','1.500',\n                 (10)'----+----|','MIN','MAX','CNT')\n                 (SKIP,X(38),A,SKIP,(10)(X(5),A(5)),SKIP,A(100),X(2),\n                 A(6),X(1),A(6),X(1),A(4));\n               PUT FILE(HOLDTIM) SKIP;\n               FIRST_HOLD_GRAPH = '0'B;\n               END;\n           IF PRINT_DORMTIM & FIRST_DORM_GRAPH\n           THEN DO;\n               PUT FILE(DORMTIM) EDIT(\n                 'CHECKPOINT DORMANCY TIME STATISTICS BY INTERVAL',\n                 ' 1.500',' 3.000',' 4.500',' 6.000',' 7.500',' 9.000',\n                 '10.500','12.000','13.500','15.000',\n                 (10)'----+----|','MIN','MAX','CNT')\n                 (SKIP,X(36),A,SKIP,(10)(X(4),A(6)),SKIP,A(100),X(2),\n                 A(6),X(1),A(6),X(1),A(4));\n               PUT FILE(DORMTIM) SKIP;\n               FIRST_DORM_GRAPH = '0'B;\n               END;\n           IF PRINT_WAITTIM\n           THEN CALL GRAPHIT('WAIT',WAITTIM,1.5E+2,XXXX_WAIT,\n             MIN_WAIT_CKPT,MAX_WAIT_CKPT,COUNT_WAIT_CKPT);\n           IF PRINT_HOLDTIM\n           THEN CALL GRAPHIT('HOLD',HOLDTIM,1.5E+2,XXXX_HOLD,\n             MIN_HOLD_CKPT,MAX_HOLD_CKPT,COUNT_HOLD_CKPT);\n           IF PRINT_DORMTIM\n           THEN CALL GRAPHIT('DORM',DORMTIM,1.5E+3,XXXX_DORM,\n             MIN_NOHOLD_CKPT,MAX_NOHOLD_CKPT,COUNT_NOHOLD_CKPT);\n           CALL START_SUMMARY_INTERVAL;\n SUMDONE:  END PRINT_SUMMARY_LINE;\n %PAGE;\n START_SUMMARY_INTERVAL: PROC REORDER;\n %SKIP;\n           DCL WORKTIME FIXED BIN(31);\n %SKIP;\n           WORKTIME = SMFREC.SMFTIME/6000;\n           SUMM_SHH = WORKTIME/60;  /* HOURS SINCE MIDNIGHT */\n           SUMM_SMM = MOD(WORKTIME,60);\n           SUMM_SSS = MOD(SMFREC.SMFTIME,6000);\n           SUMM_SDATE = SMFREC.SMFDATE;\n           SUM_WAIT_CKPT, SUM_HOLD_CKPT, SUM_NOHOLD_CKPT = 0;\n           COUNT_WAIT_CKPT, COUNT_HOLD_CKPT, COUNT_NOHOLD_CKPT = 0;\n           END_SUMMARY_INTVL = SMFREC.SMFTIME + SUMMARY_INTVL;\n           END_SUMMARY_DATE = SMFREC.SMFDATE;\n           DO WHILE(END_SUMMARY_INTVL>8640000);\n               END_SUMMARY_DATE = END_SUMMARY_DATE + .001;\n               END_SUMMARY_INTVL = END_SUMMARY_INTVL - 8640000;\n               END;\n /***      SUMSQ_WAIT_CKPT, SUMSQ_HOLD_CKPT, SUMSQ_NOHOLD_CKPT = 0; ***/\n           MAX_WAIT_CKPT, MAX_HOLD_CKPT, MAX_NOHOLD_CKPT = 0;\n           MIN_WAIT_CKPT, MIN_HOLD_CKPT, MIN_NOHOLD_CKPT = 2147483647;\n           END START_SUMMARY_INTERVAL;\n %PAGE;\n GRAPHIT:  PROC(DESC,FILEOUT,HIVAL,VAL,MIN,MAX,COUNT) REORDER;\n %SKIP;\n           DCL DESC CHAR(*);\n           DCL FILEOUT FILE;\n           DCL (MIN,MAX) FIXED BIN(31);\n           DCL (HIVAL,VAL) FLOAT DEC(6);\n           DCL COUNT FIXED BIN(15);\n           DCL LINEOUT CHAR(120) INIT((120)' ');\n           DCL 1 LINESTRUC DEF LINEOUT POS(1),\n                 3 OUTCHAR(100) CHAR(1),\n                 3 SPACE1 CHAR(2),\n                 3 LINE_LOW_VAL PIC'ZZ9.99',\n                 3 SPACE2 CHAR(1),\n                 3 LINE_HIGH_VAL PIC'ZZ9.99',\n                 3 SPACE3 CHAR(1),\n                 3 LINE_COUNT_VAL PIC'ZZZ9';\n           DCL (I,J) FIXED BIN(15);\n %SKIP;\n           LINE_COUNT_VAL = 0;\n           LINE_LOW_VAL, LINE_HIGH_VAL = 0;\n           IF COUNT<=0\n           THEN GO TO PUTLINE;\n           LINE_LOW_VAL = MIN;\n           LINE_HIGH_VAL = MAX;\n           LINE_COUNT_VAL = COUNT;\n           J = (100*VAL)/HIVAL + 0.5;\n           IF J>100\n           THEN DO;\n               OUTCHAR(98), OUTCHAR(99), OUTCHAR(100) = '+';\n               J = 97;\n               END;\n           IF J>0\n           THEN DO I=1 TO J;\n               OUTCHAR(I) = '*';\n               END;\n PUTLINE:  PUT FILE(FILEOUT) SKIP EDIT(LINEOUT)(A);\n           END GRAPHIT;\n %SKIP(2);\n           END TSJESSMF;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TYPE": {"ttr": 3336, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    TYPE  &TYPE\n         AIF   ('&TYPE' NE 'DSECT').CS\n&NAME    DSECT\n         MEXIT\n.CS      AIF   ('&TYPE' NE 'CSECT').OM\n&NAME    CSECT\n         MEXIT\n.OM      AIF   (T'&TYPE NE 'O').DS\n&NAME    DS    0F\n         MEXIT\n.DS      ANOP\n&NAME    DS    &TYPE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT096/FILE096.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT096", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}