{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012229000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE506.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE506.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\t'", "DS1TRBAL": "b'W\\x86'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xd3\\x00\\x0b\\x03\\xd3\\x00\\x0e\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\t/\\x01\\x01\\t/\\x15\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-04-02T00:00:00", "modifydate": "2001-04-02T15:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 433    FILE:  506\n\n    ORIGINAL DSNAME:  WSBG.CBT433.FILE506\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    6160    PO\n\n\n   PDS117I 7 MEMBERS COUNTED; CUMULATIVE SIZE IS 854 RECORDS\n\nTIME THIS PDS WAS SHIPPED:   04/02/01    15:00:47    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x04\\x7f\\x01\\x01\\x04\\x7f\\x12\\x04\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xc1\\xd9\\xc5\\xe8@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-16T00:00:00", "modifydate": "2001-02-16T12:04:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CAREY"}, "text": "Contents:\n\nESOGTHLD --  Find and print HOLDDATA for PTFs held for a reason\n\nESOREALC --  Realloc/copy datasets as required by HOLD(ACTION) PTFs\n\nGETPTF   --  Download/unterse a PTF from IBM's FTP server\n\nDetails about using individual execs are in comment blocks in the code.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x05\\x0f\\x01\\x01\\x05\\x0f \\x17\\x00$\\x00$\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-19T00:00:00", "modifydate": "2001-02-19T20:17:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "WSBG"}, "text": "Subject:   Contribution for CBT Tape\n   Date:   Mon, 19 Feb 2001 13:56:03 -0500\n   From:   Jim Blalock <carey@CLEMSON.EDU>\n    To:    sbgolob@attglobal.net\n\n\nHi Sam,\n\nAttached is a PDS containing 3 Rexx execs and a $$INDEX member.\nThese are tools for dealing with PTFs.  $$INDEX contains:\n\nContents:\n\nESOGTHLD --  Find and print HOLDDATA for PTFs held for a reason\n\nESOREALC --  Realloc/copy datasets as required by HOLD(ACTION) PTFs\n\nGETPTF   --  Download/unterse a PTF from IBM's FTP server\n\nDetails about using individual execs are in comment blocks in the code.\n\n\nIf you've been following IBM-MAIN recently, you know the history.\n\n\n Attached file:\n\n   ptftools.xmt\n\n        Name:    ptftools.xmt\n\n\n-- Jim Blalock\n    MVS Systems, Clemson University\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE506": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x01\\x02_\\x01\\x01\\x05/\\x08)\\x00\\x15\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2001-02-21T08:29:00", "lines": 21, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 506 is from Jim Blalock of Clemson University, and        *   FILE 506\n//*           contains several REXX execs that are very useful      *   FILE 506\n//*           in dealing with SMP/E APPLY and ACCEPT processing--   *   FILE 506\n//*           especially in dealing with HOLDDATA.                  *   FILE 506\n//*                                                                 *   FILE 506\n//*           email:   Jim Blalock <carey@CLEMSON.EDU>              *   FILE 506\n//*                                                                 *   FILE 506\n//*      CONTENTS:                                                  *   FILE 506\n//*                                                                 *   FILE 506\n//*           ESOGTHLD --  Find and print HOLDDATA for PTFs         *   FILE 506\n//*                        held for a reason                        *   FILE 506\n//*                                                                 *   FILE 506\n//*           ESOREALC --  Realloc/copy datasets as required        *   FILE 506\n//*                        by HOLD(ACTION) PTFs                     *   FILE 506\n//*                                                                 *   FILE 506\n//*           GETPTF   --  Download/unterse a PTF from IBM's        *   FILE 506\n//*                        FTP server                               *   FILE 506\n//*                                                                 *   FILE 506\n//*           Details about using individual execs are in           *   FILE 506\n//*           comment blocks in the code.                           *   FILE 506\n//*                                                                 *   FILE 506\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ESOGTHLD": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x01\\x01\\x05\\x0f\\x01\\x01\\x05/\\x08 \\x00\\xc5\\x00\\xc5\\x00\\x00\\xc3\\xc1\\xd9\\xc5\\xe8@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-02-19T00:00:00", "modifydate": "2001-02-21T08:20:00", "lines": 197, "newlines": 197, "modlines": 0, "user": "CAREY"}, "text": "/*---------------------------( rexx )---------------------------------*/\n/*                                                                    */\n/* Exec Name:  ESOGTHLD                                               */\n/*                                                                    */\n/*   Purpose:  Find and print HOLDDATA for PTFs held for a reason     */\n/*             (specified by user) by SMP/E during an APPLY CHECK.    */\n/*                                                                    */\n/*   Details:  If you have to apply huge numbers of PTFs (like an     */\n/*             ESO package), you'll probably have some number of      */\n/*             HOLD(ACTION, etc) to resolve.  This exec will eat      */\n/*             the SMPOUT output from an APPLY CHECK, then for each   */\n/*             PTF that had a HOLD of the requested type, the exec    */\n/*             finds the PTF in SMPPTS and prints out the holddata.   */\n/*             Supported HOLD types:  DOC,ACTION,DEP,EC,AO.           */\n/*                                                                    */\n/*    To Use:  1) Run an APPLY CHECK or ACCEPT CHECK for your stuff:  */\n/*                  SET BDY(target/dlib).                             */\n/*                  APPLY CHECK BYPASS(HOLDSYS(type)) ..other stuff.. */\n/*             2) Save //SMPOUT output to a file. ESOGTHLD assumes    */\n/*                'userid.SMP.OUTPUT', but you can tell it what to    */\n/*                look for (or change the default).                   */\n/*             3) Run ESOGTHLD for the type of system hold you want:  */\n/*                  %ESOGTHLD HOLD(ACTION)                            */\n/*                If you're doing something big like an ESO package,  */\n/*                you may want to run this under a batch TMP.         */\n/*                                                                    */\n/*    Syntax:  ESOGTHLD HOLD(holdtype) [ SMPRPT(dsname) ]             */\n/*     Where:  . HOLD(holdtype) is the type of HOLD to scan for       */\n/*               (ACTION, EC, DOC, ERROR, etc).  Required.            */\n/*             . SMPRPT(dsname) is the file containing //SMPOUT from  */\n/*               an APPLY CHECK.  Defaults to 'userid.SMP.OUTPUT'.    */\n/*                                                                    */\n/*     Notes:  . Yeah sure, it depends on what SMP's messages look    */\n/*               like, but you do what you gotta do :-)               */\n/*             . The exec will allocate/open/close/free each PTF      */\n/*               member in SMPPTS that it needs to look at.  If you   */\n/*               have lots and lots of held PTFs, it takes a while.   */\n/*             . Suggestions welcome.                                 */\n/*                                                                    */\n/*                                                                    */\n/*   History:  09/06/2000 jcb - New                                   */\n/*             01/02/2001 jcb - Fix for PTFs held by other PTFs that  */\n/*                              appear on ++HOLD but are not received */\n/*                              (see UR52435/UR52072 for an example). */\n/*                              See comments in the scan code below.  */\n/*             02/19/2001 jcb - Added summary of all HOLD types found */\n/*                              in smp.output.  Could be useful.      */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\n/* Constants.                                                         */\n/*--------------------------------------------------------------------*/\nptsdsn = \"SMPE.OS390.V2R6M0.MVS.SMPPTS\";    /* DSN of SMPPTS          */\nsmprpt = \" \";                               /* userid.SMP.OUTPUT      */\nholdtype = \" \";                             /* Type HOLD to look for  */\n/*--------------------------------------------------------------------*/\n/* Parse the command line.                                            */\n/*--------------------------------------------------------------------*/\narg 'HOLD(' holdtype ')' ,\n  1 'SMPRPT(' smprpt ')';\nif wordpos(holdtype, \"ACTION DOC EC DEP AO\") = 0 ,\n  then signal usage;\nif smprpt = \" \" then smprpt = \"SMP.REPORT\";\n/*--------------------------------------------------------------------*/\n/* Alloc and read the SMP report.                                     */\n/*--------------------------------------------------------------------*/\n\"FREE FI(SMPIN SMPPTS)\";\n\"ALLOC FI(SMPIN) DA(\" || smprpt || \")\";\nif rc > 0 then signal no_smpin;\n\"EXECIO * DISKR SMPIN (STEM smp. FINIS)\";\nif rc > 0 then signal execio_error;\n/*--------------------------------------------------------------------*/\n/* Scan the SMP report for message GIM42001/GIM35966.                 */\n/*--------------------------------------------------------------------*/\nselected = 0;\nholdlist.0 = 0;\ndo i = 1 to smp.0;\n /*-------------------------------------------------------------------*/\n /* OK, this is weird.  A SYSMOD's HOLD can be originated by another  */\n /* SYSMOD.  The way this is done is by coding the second SYSMOD on   */\n /* the ++HOLD card.  If this is the case, two different SYSMOD names */\n /* will appear on GIM42001 'The Following ...' and GIM35966I 'System */\n /* HOLD reason Originated By...'.  This can happen even if the second*/\n /* SYSMOD is not in the global zone/SMPPTS.  If we aren't careful to */\n /* go after the first SYSMOD, this can cause 013-18's for trying to  */\n /* access a nonexistent member.                                      */\n /*                                                                   */\n /* This sequence depends on the order that SMP issues messages in.   */\n /* (I don't like it either, but what are you gonna do...)            */\n /*-------------------------------------------------------------------*/\n parse upper var smp.i  msgid therest;\n if msgid = 'GIM42001W' then do;   /* we'll believe this one  */\n   parse upper var smp.i,\n     msgid 'THE FOLLOWING CONDITIONS FOR SYSMOD' sysmod1 therest;\n end;\n else if msgid = 'GIM35966I' then do;\n   parse upper var smp.i,\n     msgid 'SYSTEM HOLD' holdtest 'ORIGINATED BY SYSMOD' ,\n        sysmod2 therest;\n   sysmod = sysmod1;\n   if holdtest = holdtype then do;\n     selected = selected + 1;\n     sysmod_list.selected = sysmod;\n     say \"Selected HELD(\" || holdtest || \") sysmod \" || sysmod || \".\";\n   end;\n   /*-----------------------------------------------------------------*/\n   /* As long as we're here, count the occurrences of each HOLD type. */\n   /*-----------------------------------------------------------------*/\n   foundhold = 0;\n   do j = 1 to holdlist.0;\n     if holdtest = holdlist.j then do;    /* if in the list  */\n       foundhold = 1;                     /*  flag it        */\n       ptr = j;\n       j = holdlist.0;                    /*  stop searching */\n     end;\n   end;\n   if foundhold = 0 then do;              /* if not flagged  */\n     j = holdlist.0 + 1;\n     holdlist.j = holdtest;\n     holdcnt.j  = 1;\n     holdlist.0 = j;\n   end;\n   else do;                               /* Else (got one): */\n     holdcnt.ptr = holdcnt.ptr + 1;      /* Count it.       */\n   end;\n end;\nend;\nsay selected \"SYSMODs selected for HOLD(\" || holdtype || \").\";\nif holdlist.0 > 0 then do;\n  say \"The following SYSTEM HOLD types were found:\";\n  do i = 1 to holdlist.0;\n    type = strip(holdlist.i) || ' ---------------';\n    type = substr(type,1,15);\n    say \"     \" type \"  \" holdcnt.i;\n  end;\nend;\nsysmod_list.0 = selected;\n/*--------------------------------------------------------------------*/\n/* We got a list of PTFs to look up.  Loop thru the PTF members in    */\n/* SMPPTS and print out the HOLD(ACTION) statements.                  */\n/*--------------------------------------------------------------------*/\ndo i = 1 to sysmod_list.0;\n  \"ALLOC FI(SMPPTS) DA('\" || ptsdsn || \"(\" || sysmod_list.i || \")'\";\n  if rc > 0 then signal no_smppts;\n  \"EXECIO * DISKR SMPPTS (STEM ptf. FINIS)\";\n  if rc > 0 then signal execio_error;\n  /*------------------------------------------------------------------*/\n  /* Scan the PTF for the HOLD card we want, then print everything    */\n  /* until the next MCS (++) statement.                               */\n  /*------------------------------------------------------------------*/\n  do j = 1 to ptf.0;\n    ptfid = \" \"; ptfrsn = \" \";\n    parse var ptf.j \"++\" \"HOLD(\" ptfid \")\" \"REASON(\" ptfrsn \")\";\n    if ptfrsn = holdtype then do;\n      say \" \";\n      say \"-------------------------------- (\" ,\n          sysmod_list.i ,\n          \") --------------------------------\";\n      say \" \";\n      do k = j to ptf.0;\n        if (k > j) & substr(ptf.k,1,2) = '++' then do;\n          j = k - 1;               /* Leave print loop if we see new  */\n          leave k;                 /* ++ card, but keep scanning PTF. */\n        end;\n        say ptf.k;\n      end;                         /* this is where \"leave k\" goes    */\n    end;\n  end;\n  \"FREE FI(SMPPTS)\";\nend;\n/*--------------------------------------------------------------------*/\n/* We made it!  Reward the caller with RC zero.                       */\n/*--------------------------------------------------------------------*/\nexit 0;\n/*--------------------------------------------------------------------*/\n/* Error routines                                                     */\n/*--------------------------------------------------------------------*/\nusage:\n  say \" \";\n  say \"Syntax for ESOGTHLD:\"\n  say \" \";\n  say \"  ESOGTHLD HOLD(holdtype) < SMPRPT(report.dsname) >  \";\n  say \" \";\n  say \"Where:  . HOLD(holdtype) is the type of HOLD to scan for\";\n  say \"          (ACTION, EC, DOC, ERROR, etc).  Required.\";\n  say \"        . SMPRPT(dsname) is the file containing //SMPOUT from\";\n  say \"          an APPLY CHECK.  Defaults to 'userid.SMP.OUTPUT'.\";\n  say \" \";\n  exit 8;\nno_smpin:\n  say \"Unable to allocate to SMPPTS for input.\";\n  exit 8;\nno_smppts:\n  say \"Unable to allocate to SMP report file for input.\";\n  exit 8;\nexecio_error:\n  say \"Unable to read SMP report file.\";\n  exit 8;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ESOREALC": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x01\\x04\\x7f\\x01\\x01\\x04\\x7f\\x11\"\\x01d\\x01d\\x00\\x00\\xc3\\xc1\\xd9\\xc5\\xe8@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-02-16T00:00:00", "modifydate": "2001-02-16T11:22:00", "lines": 356, "newlines": 356, "modlines": 0, "user": "CAREY"}, "text": "/*-----------------------------( rexx )-------------------------------*/\n/*                                                                    */\n/* ESOREALC -- Realloc/copy datasets as required by HOLD(ACTION) PTFs */\n/*                                                                    */\n/* Function:  ESOREALC can be used to increase the size and/or number */\n/*            of directory blocks of datasets that will need it due   */\n/*            to HOLD(ACTION) PTFs.                                   */\n/*                                                                    */\n/*                                                                    */\n/* Usage:  ESOREALC dsname VOL(volser) < BLOCKS(blks) > < DIR(dir) >  */\n/*                  < RENAME(newdsn) >                                */\n/*                                                                    */\n/*    Where:  \"dsname\" is the dataset to operate on                   */\n/*            \"volser\" is the volser where \"dataset\" lives            */\n/*            \"blks\"   is the number of blocks to add to dataset      */\n/*            \"dir\"    is the number of directory blocks to add       */\n/*            \"newdsn\" is the dsname to rename the dataset to.        */\n/*                                                                    */\n/*            BLOCKS() and DIR() are both optional, but one must be   */\n/*            specified or no action is taken.                        */\n/*                                                                    */\n/* Notes:  .. The dataset to operate on is assumed to be uncataloged. */\n/*            This will cause VOL(******) entries to be left alone.   */\n/*            For this reason ESOREALC won't work right on an SMS-    */\n/*            managed volume.                                         */\n/*         .. ESOREALC doesn't do unmoveable datasets, or VSAM.       */\n/*         .. Some datasets may require renaming, since they may be   */\n/*            in use by MVS or an application.  You may have to zap a */\n/*            VTOC or do something similarly creative to do a rename  */\n/*            before you run ESOREALC.                                */\n/*         .. If you had to rename the dataset before using ESOREALC, */\n/*            use the RENAME() operand to rename it back to its old   */\n/*            name after realloc, copy, etc were successful.  The     */\n/*            exec renames the file with IEHPROGM, which doesn't      */\n/*            follow the normal rules.                                */\n/*         .. The exec uses a local command (CALLSYS) to call stuff   */\n/*            in the linklist like IEBCOPY.  You should change the    */\n/*            refs to CALLSYS to CALL 'SYS1.LINKLIB(...)' instead.    */\n/*                                                                    */\n/*                                                                    */\n/* History:   01/03/2001 jcb -- New                                   */\n/*                                                                    */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\n\n/*--------------------------------------------------------------------*/\n/* Parse the command first;  do a USAGE if it's not right.            */\n/*--------------------------------------------------------------------*/\ncmd_dsname = \" \";\ncmd_volser = \" \";\ncmd_blocks = 0;\ncmd_dirblk = 0;\ncmd_rename = \" \";\narg cmd_dsname 'VOL(' cmd_volser ')' ,\n  1 'BLOCKS(' cmd_blocks   ')' ,\n  1 'DIR('    cmd_dirblk   ')' ,\n  1 'RENAME(' cmd_rename   ')';\nif cmd_dsname = \" \" | cmd_volser = \" \" then signal usage;\nif cmd_blocks = 0 & cmd_dirblk = 0 then signal usage;\n\n/*--------------------------------------------------------------------*/\n/* Get info about the dataset's current attributes.                   */\n/*--------------------------------------------------------------------*/\ncmd_qdsname = \"'\" || strip(cmd_dsname) || \"'\";\nx = LISTDSI( cmd_qdsname \"VOL(\" cmd_volser \") DIRECTORY\" );\nif x > 0 then signal listdsi_error;\ncurrent_dirblk = sysadirblk;\nif sysunits \u00ac= \"BLOCK\" then do;\n  say \"Warning: \" cmd_dsname \" on\" cmd_volser ,\n      \" is allocated in\" sysunits \" units.\";\n  if sysunits = \"CYLINDER\" then do;\n    new_primary = cmd_blocks + (sysprimary * sysblkstrk * systrkscyl);\n    new_seconds = sysseconds * sysblkstrk * systrkscyl;\n  end;\n  else if sysunits = \"TRACK\" then do;\n    new_primary = cmd_blocks + (sysprimary * sysblkstrk);\n    new_seconds = sysseconds * sysblkstrk;\n  end;\n  else signal terminated;\nend;\nelse do;\n  new_primary = sysprimary + cmd_blocks;\n  new_seconds = sysseconds;\nend;\nif current_dirblk = \"NO_LIM\" then do;\n  say \"Warning: \" cmd_dsname \" on\" cmd_volser \" is a PDSE.\";\n  say \"Directory block increase will be ignored.\";\nend;\n\n/*--------------------------------------------------------------------*/\n/* Issue messages about stuff that we don't do. Some are terminating. */\n/*--------------------------------------------------------------------*/\nif sysdsorg = 'POU' | sysdsorg = 'PSU' | sysdsorg = 'DAU' then do;\n  say cmd_dsname \"is allocated as an unmoveable dataset.\";\n  signal terminate;\nend;\nif sysdsorg = 'VS' then do;\n  say cmd_dsname \"is a VSAM dataset.\";\n  signal terminate;\nend;\nif sysdsorg \u00ac= 'PO' & cmd_dirblk > 0 then do;\n  say cmd_dsname \"is not a PDS; directory blocks ignored.\";\n  cmd_dirblk = 0;\nend;\n\nnew_blocks = sysprimary + cmd_blocks;\nnew_dirblk = sysadirblk + cmd_dirblk;\n\n/*--------------------------------------------------------------------*/\n/* We got this far;  tell caller what we plan to do.                  */\n/*--------------------------------------------------------------------*/\nsay \" \";\nsay cmd_dsname \"on\" cmd_volser \"now uses (\" sysprimary sysseconds ,\n\") blocks and\" sysadirblk \"directory blocks.\";\nsay cmd_dsname \"on\" cmd_volser \"will be reallocated with (\" ,\nnew_blocks sysseconds \") blocks and\" new_dirblk \"directory blocks.\";\nsay \" \";\n\n/*--------------------------------------------------------------------*/\n/* Rename the dataset to a temporary name.                            */\n/*--------------------------------------------------------------------*/\ncmd_dsname = strip(cmd_dsname);\ntemp_dsname = cmd_dsname || \".TEMP\";\nx = function_rename(cmd_dsname,temp_dsname);\nif x > 0 then signal rename_error;\n\n/*--------------------------------------------------------------------*/\n/* Allocate the new dataset by the original name.  Don't catalog it.  */\n/*--------------------------------------------------------------------*/\ncmd_recfm = substr(sysrecfm,1,1) || \" \" || substr(sysrecfm,2,1);\ncmd = \"ALLOC DA(\" || cmd_qdsname || \") NEW KEEP UNIT(DISK) SPACE(\" || ,\n      new_primary new_seconds || \") BLOCK(\" || sysblksize || ,\n      \") DSORG(\" || sysdsorg || \") DIR(\" || new_dirblk || ,\n      \") RECFM(\" || cmd_recfm || \") VOL(\" || cmd_volser || ,\n      \") LRECL(\" || syslrecl || \")\";\nx = issue_command(cmd);\nif x > 0 then signal command_error;\n\n/*--------------------------------------------------------------------*/\n/* Copy the contents from the tempnamed dataset to the new larger one */\n/*--------------------------------------------------------------------*/\n\nx = function_copylib(temp_dsname,cmd_dsname);\nif x > 0 then signal utility_error;\n\n/*--------------------------------------------------------------------*/\n/* If asked, rename the larger dataset to its original name.          */\n/* (The rename routine was lifted from the BACKSYS exec.)             */\n/*--------------------------------------------------------------------*/\nif cmd_rename \u00ac= \" \" then do;\n  x = function_rename(cmd_dsname,cmd_rename);\n  if x > 0 then signal rename_error;\nend;\n\n/*--------------------------------------------------------------------*/\n/* Delete the tempnamed dataset and exit.                             */\n/*--------------------------------------------------------------------*/\ntemp_qdsname = \"'\" || strip(temp_dsname) || \"'\";\ncmd = \"ALLOC DA(\" || temp_qdsname || \") VOL(\" || cmd_volser ,\n      || \") OLD\";\nx = issue_command(cmd);\nif x > 0 then signal command_error;\ncmd = \"FREE DA(\" || temp_qdsname || \") DELETE\";\nx = issue_command(cmd);\nif x > 0 then signal command_error;\n\nexit 0;\n\n/*--------------------------------------------------------------------*/\n/* Terminated: General error exit.  Caller says what's wrong.         */\n/*--------------------------------------------------------------------*/\nterminated:\n  say \" \";\n  say \"ESOREALC terminated.\";\n  say \" \";\n  exit 8;\n/*--------------------------------------------------------------------*/\n/* Usage:  Tell caller the syntax if they didn't get syntax right.    */\n/*--------------------------------------------------------------------*/\nusage:\n  say \" \";\n  say \"Usage:  ESOREALC dsname VOL(volser)                          \";\n  say \"             < BLOCKS(blks) >                                \";\n  say \"             < DIR(dir) >                                    \";\n  say \"             < RENAME(newdsn) >                              \";\n  say \"                                                             \";\n  say \"Where:  'dsname' is the dataset to operate on                \";\n  say \"        'volser' is the volser where \"dataset\" lives         \";\n  say \"        'blks'   is the number of blocks to add to dataset   \";\n  say \"        'dir'    is the number of directory blocks to add    \";\n  say \"        'newdsn' is the dsname to rename the                 \";\n  say \"                                                             \";\n  say \"        BLOCKS() and DIR() are both optional, but one must   \";\n  say \"        be specified or no action is taken.                  \";\n  say \" \";\n  exit 8;\n\n/*--------------------------------------------------------------------*/\n/* Listdsi_Error:  Report failures from LISTDSI.                      */\n/*--------------------------------------------------------------------*/\nlistdsi_error:\n  say \" \";\n  say \"LISTDSI error processing\" cmd_dsname \" on\" cmd_volser \":\";\n  say sysmsglvl1;\n  say sysmsglvl2;\n  say \" \";\n  exit 8;\n\n/*--------------------------------------------------------------------*/\n/* Command_Error:  Report failures from TSO commands.                 */\n/*--------------------------------------------------------------------*/\ncommand_error:\n  say \" \";\n  say \"TSO command failed.\";\n  say \" \";\n  exit 8;\n\n/*--------------------------------------------------------------------*/\n/* Utility_Error:  Report failures from IEBCOPY.                      */\n/*--------------------------------------------------------------------*/\nutility_error:\n  say \" \";\n  say \"IEBCOPY utility failed.\";\n  say \" \";\n  exit 8;\n/*--------------------------------------------------------------------*/\n/* Rename_Error:  Report failures from IEHPROGM.                      */\n/*--------------------------------------------------------------------*/\nrename_error:\n  say \" \";\n  say \"IEHPROGM utility failed.\";\n  say \" \";\n  exit 8;\n\n/*--------------------------------------------------------------------*/\n/*                                                                   */\n/*  Subroutine:  Function_RENAME                                     */\n/*  Purpose:     Rename the named dataset to its target dataset on   */\n/*               the named volume using IEHPROGM.                    */\n/*  To call:     x = function_rename(old_dsn, new_dsn);              */\n/*  Notes:     . It is assumed that an IEHPROGM RC of 0 is OK.       */\n/*             . Adapted from SYSTEMS.BACKSYS.SOURCE(BACKSYS).       */\n/*                                                                   */\n/*--------------------------------------------------------------------*/\nfunction_rename: procedure expose(cmd_volser)\n  /* trace results; */\n  blanks = \"                                                         \";\n  arg old_name, new_name;\n  old_name = strip(old_name,\"B\",\"'\");      /* nuke the quotes if any */\n  old_name = strip(old_name,\"B\",\" \");      /* blanks too             */\n  new_name = strip(new_name,\"B\",\"'\");\n  new_name = strip(new_name,\"B\",\" \");\n  target_volume = strip(cmd_volser);\n  x = issue_command( ,\n    \"ALLOC FI(SYSIN) NEW SPACE(2 2) TRACK LRECL(80) RECFM(F B)\");\n  if rc > 0 then signal rename_bad_alloc;\n  iehline.0 = 2;   /* 2! */\n  iehline.1 = \" RENAME DSNAME=\" || old_name || ,\n              \",VOL=3390=\" || target_volume || \",\";\n  x = overlay(\"$\",blanks,72-length(iehline.1));\n  iehline.1 = strip(iehline.1 || x,TRAILING);\n  iehline.2 = \"               NEWNAME=\" || new_name;\n  \"EXECIO * DISKW SYSIN (STEM iehline. FINIS)\";\n  if rc > 0 then signal rename_bad_execio;\n  x = issue_command(\"ALLOC FI(SYSPRINT) SYSOUT(A) HOLD\");\n  x = issue_command( ,\n    \"ALLOC FI(\" || target_volume || \") UNIT(DISK) VOL(\" || ,\n        target_volume || \") NEW SPACE(1) TRACK\");\n  if rc > 0 then signal rename_bad_alloc;\n  \"CALLSYS IEHPROGM\";\n  if rc > 4 then signal rename_bad_rename;\n  say old_name \"renamed successfully to\" new_name || \".\";\n  x = issue_command(\"FREE FI(SYSIN SYSPRINT \" || target_volume || \")\");\n  return 0;\n/* ----------------------------------------------------------------- */\n/* RENAME's error routines                                           */\n/* ----------------------------------------------------------------- */\nrename_bad_alloc:\n  say \"*** Error: ALLOC failed during RENAME.\"\n  exit 12\nrename_bad_execio:\n  say \"*** Error: EXECIO failed during RENAME.\"\n  exit 12\nrename_bad_rename:\n  say \"*** Error: IEHPROGM failed during RENAME.\"\n  exit 12\n\n/* ----------------------------------------------------------------- */\n/*                                                                   */\n/*  Function issue_command:  Log and issue a TSO command.            */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\nissue_command: procedure\n  arg command_string\n  echo_commands = 'TRUE';\n  if echo_commands = 'TRUE' then ,\n    say \"Command:\"  command_string\n  command_string;\n  result = rc;\n  return(result);\n/* ----------------------------------------------------------------- */\n/*                                                                   */\n/*  Subroutine:  Function_COPYLIB                                    */\n/*  Purpose:     Copy the named dataset to its target dataset on     */\n/*               the named volume.                                   */\n/*  Syntax:      backsys copylib dsname.to.copy targetvolume         */\n/*  Notes:     . All mainline variables are available.  There are    */\n/*               no local variables used.                            */\n/*             . It is assumed that an IEBCOPY rc of 0 or 4 is OK.   */\n/*             . COPYLIB works on non-loadlib PDSes.  For loadlibs   */\n/*               use function_COPYMOD.                               */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\nfunction_copylib: procedure expose(cmd_volser)\n  /* trace results */\n  arg input_lib, output_lib;\n  target_volume = strip(cmd_volser);\n  x = issue_command( ,\n    \"ALLOC FI(SYSIN) DUMMY\" );\n  x = issue_command( ,\n    \"ALLOC FI(SYSPRINT) SYSOUT(A) HOLD\" );\n  x = issue_command( ,\n    \"ALLOC FI(SYSUT1) DA('\" || input_lib || ,\n       \"') VOL(\" || target_volume || \")\" );\n  if rc > 0 then signal copylib_no_libout;\n  x = issue_command( ,\n    \"ALLOC FI(SYSUT2) DA('\" || output_lib || \"') VOL(\" ,\n        || target_volume || \") UNIT(DISK)\" );\n  if rc > 0 then signal copylib_no_libout;\n  x = issue_command( ,\n    \"ALLOC F(SYSUT3) NEW UNIT(DISK) SPACE(50) CYL\" );\n  if rc > 0 then signal copylib_no_sysutx;\n  x = issue_command( ,\n    \"ALLOC F(SYSUT4) NEW UNIT(DISK) SPACE(50) CYL\" );\n  if rc > 0 then signal copylib_no_sysutx;\n  x = issue_command( \"CALLSYS IEBCOPY 'COPY,WORK=5M'\" );\n  if rc > 4 then signal copylib_bad_copy;\n  say input_lib \"copied successfully into\" output_lib || \".\";\n  x = issue_command( ,\n    \"FREE FI(SYSIN SYSPRINT SYSUT1 SYSUT2 SYSUT3 SYSUT4)\" );\n  return 0;\n/* ----------------------------------------------------------------- */\n/* COPYLIB's error routines                                          */\n/* ----------------------------------------------------------------- */\ncopylib_no_sysutx:\n  say \"*** Error: Unable to create SYSUTx work file.\";\n  exit 12\ncopylib_no_libout:\n  say \"*** Error: Unable to allocate to output library\" output_lib \".\"\n  exit 12\ncopylib_no_libin:\n  say \"*** Error: Unable to allocate to input library\" input_lib \".\"\n  exit 12\ncopylib_bad_copy:\n  say \"*** Error: IEBCOPY failed while copying\" input_lib \".\"\n  exit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETPTF": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x00\\x01\\x01\\x04\\x7f\\x01\\x01\\x04\\x7f\\x11'\\x00\\xdf\\x00\\xdf\\x00\\x00\\xc3\\xc1\\xd9\\xc5\\xe8@@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-02-16T00:00:00", "modifydate": "2001-02-16T11:27:00", "lines": 223, "newlines": 223, "modlines": 0, "user": "CAREY"}, "text": "/*----------------------------( rexx )------------------------------*/\n/*                                                                  */\n/*  Exec:    GETPTF                                                 */\n/*                                                                  */\n/*  Purpose: This exec will download and unterse a single PTF file  */\n/*           from IBM's ServiceLink FTP server.                     */\n/*                                                                  */\n/*  Author:  Jim Blalock, Clemson University   (carey@clemson.edu)  */\n/*                                                                  */\n/*  Format:  %GETPTF ORDER(<order>) USER(<user>) PASS(<pass>)       */\n/*           where:                                                 */\n/*             <order> is the SRD 9-digit order number.             */\n/*             <user> is the userid to log onto IBM's PTF site.     */\n/*                    This is usually the same as your IBMlink ID.  */\n/*             <pass> is the password for the PTF site.  Refer to   */\n/*                    your order status in SRD.                     */\n/*            The parms can be in any order;  all are required.     */\n/*                                                                  */\n/*  Inputs:  Parameters from command line                           */\n/*                                                                  */\n/*  Workfiles: DDname INPUT is dynamically allocated and loaded     */\n/*             with FTP commands.  This uses a temporary dataset.   */\n/*                                                                  */\n/*  Outputs: . PTF files created;  error messages otherwise.        */\n/*             .. mlst0123.servlink  -> userid.mlst0123.txt         */\n/*             .. mptf0123.servlink  -> userid.mptf0123.ptf         */\n/*           . userid.mptf0123.tersed is also created, and left in  */\n/*             place for debugging if needed.                       */\n/*           . Various success or failure messages as needed.       */\n/*                                                                  */\n/*  Dependencies:                                                   */\n/*     IBM's FTP server name (see \"global variables\")               */\n/*     IBM's filename conventions for files to be downloaded        */\n/*     Location, name & parms for unterse program (see \"globals\")   */\n/*     Length of order number string (forced to 9 at present)       */\n/*     Userid, password and filenames on FTP server are forced      */\n/*       to lowercase                                               */\n/*     ALLOC commands generated by the exec may need to be changed  */\n/*       to reflect local DFSMS environments.                       */\n/*     Developed and tested using TCP/IP For MVS 3.1 and TSO/E 2.5. */\n/*                                                                  */\n/*                                                                  */\n/*  History: 08/20/1997 - New                                       */\n/*           01/22/1998 JCB - Changed SRD filenames from            */\n/*                        *.SERVLINK to MLST*.TXT and MPTF*.BIN.    */\n/*                        If this needs to be changed again, look   */\n/*                        for lines marked @C1.                     */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\n/*------------------------------------------------------------------*/\n/* Global variables.                                                */\n/*------------------------------------------------------------------*/\nftp_server= \"ptf.software.ibm.com\";           /* IBM's FTP server   */\nterseprog = \"'SYS2.EXPEDITE.TERSE.LOADLIB(TRSUNPCK)'\";\nterseparm = \"'UNPACK'\";\nchangedate = \"22 Jan 1998\"\n\n/*------------------------------------------------------------------*/\n/* Say hello.                                                       */\n/*------------------------------------------------------------------*/\nsay \" \";\nsay \"GETPTF exec version 1.0 - last updated \" || changedate || \".\"\nsay \" \";\n\n/*------------------------------------------------------------------*/\n/*  Parse command line and sanitize input.                          */\n/*------------------------------------------------------------------*/\norder = \" \";\nuser  = \" \";\npass  = \" \";\nparse upper arg \"ORDER(\" order \")\" ,\n        1 \"USER(\" user \")\" ,\n        1 \"PASS(\" pass \")\";\nif order = \" \" | user = \" \" | pass = \" \" ,\n  then signal usage;\nif length(order) \u00ac= 9 ,\n  then signal usage;\nuser = lower(user);                      /* Must be on a Unix box;  */\npass = lower(pass);                      /* everything's lowercase  */\nordernum = substr(order,6,4);\n\n/*------------------------------------------------------------------*/\n/*  Generate dataset names.                                         */\n/*------------------------------------------------------------------*/\nuserid = SYSVAR(\"sysuid\");\nmlst = \"MLST\" || ordernum;\nmptf = \"MPTF\" || ordernum;\nmlstsrc   = mlst || \".TXT\";  mlstsrc = lower(mlstsrc);         /*@C1*/\nmptfsrc   = mptf || \".BIN\";  mptfsrc = lower(mptfsrc);         /*@C1*/\nmlstdest  = \"'\" || userid || \".\" || mlst || \".LST'\";\nmptfdest  = \"'\" || userid || \".\" || mptf || \".PTF'\";\nmptfterse = \"'\" || userid || \".\" || mptf || \".TERSED'\";\n\n/*------------------------------------------------------------------*/\n/*  Clean up existing datasets, if they exist.                      */\n/*------------------------------------------------------------------*/\nif listdsi(mlstdest)  = 0   then x = command(\"DELETE \" mlstdest);\nif listdsi(mptfdest)  = 0   then x = command(\"DELETE \" mptfdest);\nif listdsi(mptfterse) = 0   then x = command(\"DELETE \" mptfterse);\n\n/*------------------------------------------------------------------*/\n/*  Create FTP commands in DDname //INPUT, then call FTP.           */\n/*------------------------------------------------------------------*/\n\"FREE FI(INPUT)\";\n\"ALLOC FI(INPUT) SPACE(1 1) TRACK LRECL(80) BLKSIZE(7200) RECFM(F B)\";\nif rc > 0 then signal alloc_failed;\nftpcmd.0 = 7; /* <<< */\nftpcmd.1 = user;\nftpcmd.2 = pass;\nftpcmd.3 = \"CD /\" || order;\n/* ftpcmd.4 = \"LOCSITE LRECL=80 BLK=7200 RECFM=FB PRI=1 SEC=3 TRACKS\";*/\n/* ftpcmd.5 = \"GET \" || mlstsrc mlstdest; */\nftpcmd.4 = \"BINARY\";\nftpcmd.5 = \"LOCSITE LRECL=1024 BLK=10240 RECFM=FB PRI=25 SEC=99 TRACKS\";\nftpcmd.6 = \"GET \" || mptfsrc mptfterse;\nftpcmd.7 = \"QUIT\";\n\"EXECIO * DISKW input (STEM ftpcmd. FINIS)\";\n\n/*------------------------------------------------------------------*/\n/* Need to see the FTP commands?  Uncomment the following.          */\n/*------------------------------------------------------------------*/\n/*   say \"Generated FTP commands:\"                                  */\n/*   do i = 1 to ftpcmd.0;                                          */\n/*     say \"*** \" || ftpcmd.i;                                      */\n/*   end;                                                           */\n/*------------------------------------------------------------------*/\n\nx = command(\"FTP\" ftp_server);     /* Hard stuff's done; go get it! */\n\n/*------------------------------------------------------------------*/\n/*  We should have something in MLSTDEST and MPTFTERSE.  The        */\n/*  MPTFTERSE dataset needs to be run through the UNTERSE utility.  */\n/*------------------------------------------------------------------*/\n/*x = listdsi(mlstdest); */\n/*if x > 0 then signal dataset_not_created; */\nx = listdsi(mptfterse);\nif x > 0 then signal dataset_not_created;\nx = command(\"ALLOC FI(INFILE) DA(\" || mptfterse || \")\");\nx = command(\"ALLOC FI(OUTFILE) DA(\" || mptfdest || \") NEW CAT \" ,\n  \"SPACE(100 200) TRACK LRECL(80) BLKSIZE(7200) RECFM(F B) RELEASE\");\nx = command(\"CALL \" || terseprog || \" \" || terseparm);\nif x \u00ac= 0 then signal dataset_not_unpacked;\n\n/*------------------------------------------------------------------*/\n/* Looks like we did it.  Say something congratulatory and quit.    */\n/*------------------------------------------------------------------*/\nx = cleanup();\nsay \" \";\nsay \"GETPTF exec ended.  Your PTF is in \" || mptfdest || \".\";\nsay \" \";\nexit 0;\n\n/*------------------------------------------------------------------*/\n/*  Error routines.                                                 */\n/*------------------------------------------------------------------*/\nusage:\n  say \"                                                       \";\n  say \"Usage:\";\n  say \"                                                       \";\n  say \"   GETPTF USER(<user>) PASS(<password>) ORDER(<order>) \";\n  say \"                                                       \";\n  say \"Where:\";\n  say \"                                                       \";\n  say \"   <user> is the userid to use at the IBM FTP server   \";\n  say \"   <pass> is the password for <user>                   \";\n  say \"   <order> is the 9-digit order number from SRD.       \";\n  say \"                                                       \";\n  say \"If you are missing any of this info, look your order up\";\n  say \"under SRD and note the userid, password and order number.\";\n  exit 8;\n\nalloc_failed:\n  say \"TSO ALLOCATE command failed.\";\n  x = cleanup();\n  exit 8;\n\ndataset_not_created:\n  say \"Dataset not created by FTP.\";\n  x = cleanup();\n  exit 8;\n\ndataset_not_unpacked:\n  say \"Dataset not unpacked by UNTERSE utility.\";\n  x = cleanup();\n  exit 8;\n\ncleanup: procedure;                /* Free potentially alloc'd DDs. */\n  x = command(\"FREE FI(INPUT)\");\n  x = command(\"FREE FI(INFILE)\");\n  x = command(\"FREE FI(OUTFILE)\");\n  return(0);\n\n/*---------------------------------------------------------------*/\n/* Function to lowercase a string.  Dunno why it's not standard. */\n/*---------------------------------------------------------------*/\nlower: procedure;\n  arg string;\n  tablein  = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  tableout = \"abcdefghijklmnopqrstuvwxyz\";\n  lstring = translate(string,tableout,tablein);\n  return(lstring);\n\n/*---------------------------------------------------------------*/\n/*   Simple function to execute a TSO command (maybe).  It       */\n/*   returns the command's return code, as follows:              */\n/*      x = command(\"command string\")                            */\n/*      if x \u00ac= 0 then say \"Command blew up\", etc.               */\n/*---------------------------------------------------------------*/\ncommand: procedure;\n  issue_commands = TRUE;            /* Set to FALSE for testing. */\n  arg command_string;\n  if issue_commands = TRUE then prefix = \"  Command: \";\n  else prefix = \"  Testing: \";\n  say prefix command_string;\n  if issue_commands = TRUE then do;\n    command_string;\n    result = rc;\n  end;\n  else result = 0;\n  return(result);\n\n/*------------------------( the end )----------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT506/FILE506.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT506", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}