{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013323000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE894.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE894.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\x0b'", "DS1TRBAL": "b'\\x9a\\x10'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\x81\\x00\\x00\\x08\\x81\\x00\\n\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x00\\x02\\x01\\x13$O\\x01\\x13$O!0\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-09-01T00:00:00", "modifydate": "2013-09-01T21:30:02", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-487"}, "text": "REGULAR CBT TAPE - VERSION 487    FILE:  894\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT487.FILE894\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 32 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,798 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/01/13    21:30:02    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$CONTENT": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00)\\x01\\x13\"?\\x01\\x13$O! \\x00=\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2013-08-11T00:00:00", "modifydate": "2013-09-01T21:20:29", "lines": 61, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "                    Some of Rob Zenuk's stuff\n                    ---- -- --- ------- -----\n\n Note:  Rob probably puts his execs into the SYSEXEC DD concatenation.\n        If you put them into the SYSPROC concatenation, you have to\n        put a /*  REXX  */ comment in the FIRST line of the exec.\n\n      UNIXCMDB - TSO command to execute UNIX commands and to\n                 display the results.\n\n                 A version of an exec by John McKown.  Purpose\n                 is to execute UNIX commands from TSO, without\n                 using a UNIX shell.  I made this name longer\n                 because there were several variants posted on\n                 the MVS-OE list, but this one (or whichever\n                 variant you really use) should be renamed to\n                 be called UNIX.\n\n      USSFILMT - TSO command to list UNIX files and how they\n                 are mounted.\n\n      USSGETMT - TSO command to display all mounted files\n                 under UNIX.\n\n                  FULL LIST OF MEMBERS IN THIS PDS                      FILE 894\n                  ---- ---- -- ------- -- ---- ---                      FILE 894\n                                                                        FILE 894\n            $CONTENT  01.02  2013/08/11 17:29     24 SBGOLOB            FILE 894\n            $LSTHZFL  01.00  2013/08/11 19:27     26 SBGOLOB            FILE 894\n            @FILE894  01.03  2013/09/01 21:07      2 SBGOLOB            FILE 894\n            BPXEXIST  01.01  2013/09/01 18:02     77 SBGOLOB            FILE 894\n            BPXJCL    01.11  2013/08/14 23:40    245 SBGOLOB            FILE 894\n            BPXJCL@   01.00  2013/08/14 23:56     27 SBGOLOB            FILE 894\n            BPXJCL01  01.18  2013/08/14 23:42    218 SBGOLOB            FILE 894\n            BPXJCL02  01.01  2013/08/15 14:54     23 SBGOLOB            FILE 894\n            BPXSPOOL  01.01  2013/08/15 14:15    282 SBGOLOB            FILE 894\n            BPXWGDG   01.00  2013/08/14 22:55     54 SBGOLOB            FILE 894\n            BPXWUNIX  01.01  2013/08/13 14:11    297 SBGOLOB            FILE 894\n            EZAZTSAB  01.00  2012/07/08 13:33     12 SHOW721            FILE 894\n            EZAZTSEB  01.00  2012/07/08 13:33     44 SHOW721            FILE 894\n            FINDSTR   01.00  2013/08/15 11:27     82 SBGOLOB            FILE 894\n            GETSTAC@  01.00  2013/08/14 12:01     42 SBGOLOB            FILE 894\n            GETSTACK  01.00  2013/08/14  0:30      8 SBGOLOB            FILE 894\n            MNTCKDOC  01.00  2013/08/16 13:29     69 SBGOLOB            FILE 894\n            MVSREXX   01.00  2013/08/15  0:07     92 SBGOLOB            FILE 894\n            PDSSPLI@  01.02  2013/08/13 15:08   1203 RZENUK             FILE 894\n            PDSSPLIJ  01.02  2013/08/13 15:18     24 JCL                FILE 894\n            PDSSPLIT  01.01  2013/08/13 15:08   1098 EXEC               FILE 894\n            QUICKXMI  01.00  2013/08/14 21:03     61 SBGOLOB            FILE 894\n            RESTJOB   01.00  2013/08/16  9:39     60 SBGOLOB            FILE 894\n            REXECX    01.00  2013/08/14 22:08    131 SBGOLOB            FILE 894\n            SDSF2ZFS  01.00  2013/08/11 17:47    154 RZENUK             FILE 894\n            SYMREP    01.02  2013/08/14 22:10    164 SBGOLOB            FILE 894\n            UNIXCMD$  01.00  2013/08/11 15:29     32 SBGOLOB            FILE 894\n            UNIXCMDB  01.01  2013/08/11 15:13     18 RZENUK             FILE 894\n            USSFILM$  01.00  2013/08/11 19:18      9 SBGOLOB            FILE 894\n            USSFILMT  01.00  2013/08/11 14:39      8 RZENUK             FILE 894\n            USSGETMT  01.04  2013/08/11 14:27     89 RZENUK             FILE 894\n                                                                        FILE 894\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$LSTHZFL": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x13\"?\\x01\\x13\"?\\x19\\'\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-11T00:00:00", "modifydate": "2013-08-11T19:27:07", "lines": 26, "newlines": 26, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: How to list the content of an HFS or zFS file\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     6/10/2011 7:42 PM\n\nSo, these are currently not mounted and you are just curious what\nis in them...  If so, MOUNT each HFS to the same mountpoint\ndirectory and ls -l the contents from the \"root\" directory (or\nuse ISHELL).  Even though you do not have ISPF 3.17, you should\nhave ISHELL (type ISHELL from TSO option 6).\n\nProcess:\n\nCreate (mkdir) a common mountpoint directory (like\n\"/what_is_this\" off the root)\n\n    1.  MOUNT HFS DSN to the common mountpoint directory\n        (mentioned above)\n    2.  Use ISHELL to check its contents (using the common\n        mountpoint directory as the starting point)\n    3.  UNMOUNT HFS\n    4.  Rinse and repeat for each HFS in question\n\nAfter done, remove (rm) your common mountpoint directory.\n\nHope this helps,\nRob\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE894": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04W\\x00P\\x01\\x13$O\\x01\\x13$O!)\\x00J\\x00J\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf7@@@'", "ispf": {"version": "04.87", "flags": 0, "createdate": "2013-09-01T00:00:00", "modifydate": "2013-09-01T21:29:50", "lines": 74, "newlines": 74, "modlines": 0, "user": "CBT-487"}, "text": "//***FILE 894 is from Robert Zenuk by way of Sam Golob.  This       *   FILE 894\n//*           collection of members was taken from several years'   *   FILE 894\n//*           worth of posts to the MVS-OE listserv group, under    *   FILE 894\n//*           Rob's name.  The code he posted, or the piece of      *   FILE 894\n//*           thread which he wrote, which covered an issue, with   *   FILE 894\n//*           a problem solved, is brought here as a single         *   FILE 894\n//*           member, or several.                                   *   FILE 894\n//*                                                                 *   FILE 894\n//*           It is up to the user to see if he/she can benefit     *   FILE 894\n//*           from this code and these posts.  They were brought    *   FILE 894\n//*           here to help those who might need it.                 *   FILE 894\n//*                                                                 *   FILE 894\n//*           email:  Rob Zenuk <Robzenuk@AOL.COM>                  *   FILE 894\n//*                                                                 *   FILE 894\n//*           email:  Sam Golob <sbgolob@cbttape.org>               *   FILE 894\n//*                             <sbgolob@attglobal.net>             *   FILE 894\n//*                                                                 *   FILE 894\n//*                  Some of Rob Zenuk's stuff                      *   FILE 894\n//*                  ---- -- --- ------- -----                      *   FILE 894\n//*                                                                 *   FILE 894\n//*    UNIXCMDB - TSO command to execute UNIX commands and to       *   FILE 894\n//*               display the results.                              *   FILE 894\n//*                                                                 *   FILE 894\n//*               A version of an exec by John McKown.  Purpose     *   FILE 894\n//*               is to execute UNIX commands from TSO, without     *   FILE 894\n//*               using a UNIX shell.  I made this name longer      *   FILE 894\n//*               because there were several variants posted on     *   FILE 894\n//*               the MVS-OE list, but this one (or whichever       *   FILE 894\n//*               variant you really use) should be renamed to      *   FILE 894\n//*               be called UNIX.                                   *   FILE 894\n//*                                                                 *   FILE 894\n//*               model:  TSO UNIX unixcmd                          *   FILE 894\n//*                                                                 *   FILE 894\n//*    USSFILMT - TSO command to list UNIX files and how they       *   FILE 894\n//*               are mounted.                                      *   FILE 894\n//*                                                                 *   FILE 894\n//*    USSGETMT - TSO command to display all file mounts            *   FILE 894\n//*               under UNIX.                                       *   FILE 894\n//*                                                                 *   FILE 894\n//*               FULL LIST OF MEMBERS IN THIS PDS                  *   FILE 894\n//*               ---- ---- -- ------- -- ---- ---                  *   FILE 894\n//*                                                                 *   FILE 894\n//*         $CONTENT  01.02  2013/08/11 17:29     24 SBGOLOB        *   FILE 894\n//*         $LSTHZFL  01.00  2013/08/11 19:27     26 SBGOLOB        *   FILE 894\n//*         @FILE894  01.03  2013/09/01 21:07      2 SBGOLOB        *   FILE 894\n//*         BPXEXIST  01.01  2013/09/01 18:02     77 SBGOLOB        *   FILE 894\n//*         BPXJCL    01.11  2013/08/14 23:40    245 SBGOLOB        *   FILE 894\n//*         BPXJCL@   01.00  2013/08/14 23:56     27 SBGOLOB        *   FILE 894\n//*         BPXJCL01  01.18  2013/08/14 23:42    218 SBGOLOB        *   FILE 894\n//*         BPXJCL02  01.01  2013/08/15 14:54     23 SBGOLOB        *   FILE 894\n//*         BPXSPOOL  01.01  2013/08/15 14:15    282 SBGOLOB        *   FILE 894\n//*         BPXWGDG   01.00  2013/08/14 22:55     54 SBGOLOB        *   FILE 894\n//*         BPXWUNIX  01.01  2013/08/13 14:11    297 SBGOLOB        *   FILE 894\n//*         EZAZTSAB  01.00  2012/07/08 13:33     12 SHOW721        *   FILE 894\n//*         EZAZTSEB  01.00  2012/07/08 13:33     44 SHOW721        *   FILE 894\n//*         FINDSTR   01.00  2013/08/15 11:27     82 SBGOLOB        *   FILE 894\n//*         GETSTAC@  01.00  2013/08/14 12:01     42 SBGOLOB        *   FILE 894\n//*         GETSTACK  01.00  2013/08/14  0:30      8 SBGOLOB        *   FILE 894\n//*         MNTCKDOC  01.00  2013/08/16 13:29     69 SBGOLOB        *   FILE 894\n//*         MVSREXX   01.00  2013/08/15  0:07     92 SBGOLOB        *   FILE 894\n//*         PDSSPLI@  01.02  2013/08/13 15:08   1203 RZENUK         *   FILE 894\n//*         PDSSPLIJ  01.02  2013/08/13 15:18     24 JCL            *   FILE 894\n//*         PDSSPLIT  01.01  2013/08/13 15:08   1098 EXEC           *   FILE 894\n//*         QUICKXMI  01.00  2013/08/14 21:03     61 SBGOLOB        *   FILE 894\n//*         RESTJOB   01.00  2013/08/16  9:39     60 SBGOLOB        *   FILE 894\n//*         REXECX    01.00  2013/08/14 22:08    131 SBGOLOB        *   FILE 894\n//*         SDSF2ZFS  01.00  2013/08/11 17:47    154 RZENUK         *   FILE 894\n//*         SYMREP    01.02  2013/08/14 22:10    164 SBGOLOB        *   FILE 894\n//*         UNIXCMD$  01.00  2013/08/11 15:29     32 SBGOLOB        *   FILE 894\n//*         UNIXCMDB  01.01  2013/08/11 15:13     18 RZENUK         *   FILE 894\n//*         USSFILM$  01.00  2013/08/11 19:18      9 SBGOLOB        *   FILE 894\n//*         USSFILMT  01.00  2013/08/11 14:39      8 RZENUK         *   FILE 894\n//*         USSGETMT  01.04  2013/08/11 14:27     89 RZENUK         *   FILE 894\n//*                                                                 *   FILE 894\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BPXEXIST": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x13\"\\x8f\\x01\\x13$O\\x18\\x02\\x00K\\x00M\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-16T00:00:00", "modifydate": "2013-09-01T18:02:56", "lines": 75, "newlines": 77, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: IDCAMS\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     3/30/2006 1:42 PM\n\nYup.  The JCL PATH statement is the \"magic\".  You could do this\nwith any program like IEFBR14, IEBGENER, IKJEFT01, IDCAMS,\nBPXBATCH, etc.  Any program that uses QSAM to write to a file can\nuse a DD with a PATH statement.  Just incorporate your PATH DD\ninto whatever program will be used to\nload/read/update/delete/whatever the file.\n\nWe use a lot of NFS and wanted to know in the JCL if the file was\nsuccessfully created before being written to.  This was a technique\nincorporated to minimize the impact and complexity of job restarts\nif a permissions problem (or other unexpected problem) was\nencountered.  To accomplish this we used a small REXX utility that\nsimply checked to see if the file exists after PATH DD allocation\nand returns a non-zero return code (RC=1) since IEFBR14 does not do\nthis.  This step is usually strategically placed at the beginning\nof the jobstream.\n\nHere is the REXX EXEC:\n\n/****************************** REXX *********************************/\n/*  Purpose: Use BPXWUNIX to check if a file exists                  */\n/*-------------------------------------------------------------------*/\n/*  Syntax:  BPXEXIST  file                                          */\n/*-------------------------------------------------------------------*/\n/*  Parms: file       - Full path to the file to look for            */\n/*                                                                   */\n/*  Notes: RC=0         File  exists                                 */\n/*         RC=1         File does not  exist                         */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   ---------------------------------------- */\n/*  R.  Zenuk    Mar 2004   Initial  Creation                        */\n/*                                                                   */\n/*********************************************************************/\nparse  arg  file\ncommand = 'ls'  file\nsay mvsvar('SYSNAME') mvsvar('SYMDEF','JOBNAME') date()  time()\nsay\nsay 'Executing command:'  command\nsay\nexit  BPXWUNIX(command,'DD:stdin','DD:stdout','DD:stderr','0')\n\nHere is some sample JCL to run it:\n\n//jobcard\n//*******************************************************************\n//*  EXECUTE BPXEXIST TO SEE IF A FILE EXISTS                       *\n//* RC=0, FILE  EXISTS                                              *\n//* RC=1, FILE DOES NOT  EXIST                                      *\n//*******************************************************************\n//EXISTS   PROC  FILE=\n//BPXEXIST EXEC PGM=IKJEFT01,PARM='BPXEXIST  &FILE'\n//SYSEXEC  DD    DSN=your.exec.pds,DISP=SHR\n//SYSTSPRT DD    SYSOUT=*\n//SYSTSIN  DD    DUMMY\n//STDOUT   DD    SYSOUT=*\n//STDERR   DD    SYSOUT=*\n//STDIN    DD    DUMMY\n//FILE     DD    PATH='&FILE',\n//          PATHOPTS=(OWRONLY,OCREAT),PATHDISP=(KEEP,DELETE),\n//          PATHMODE=(SIRWXU,SIRWXG,SIRWXO),FILEDATA=TEXT\n//         PEND\n//CHECK    EXEC  EXISTS,FILE='/u/your/yournewfile.txt'\n\n\nHope This Helps,\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXJCL": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x13\\x01\\x13\"o\\x01\\x13\"o#@\\x00\\xf3\\x00\\xf5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T23:40:13", "lines": 243, "newlines": 245, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: BPXBATCH STDPARM wish\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     10/5/2008 6:21 PM\n\nI wrote one of those...  I posted my quick and dirty BPXJCL a few\nyears ago.  Since then, the same requirements you post here surfaced\nin our shop.  So, BPXJCL grew to meet the challenge.  Here is the\nupdated code (sorry about any indenting issues if they occur).\n\n/****************************** REXX *********************************/\n/*  Purpose: Use BPXWUNIX to redirect STDOUT and STDERR to SYSOUT    */\n/*-------------------------------------------------------------------*/\n/*  Syntax:  BPXJCL  command                                         */\n/*-------------------------------------------------------------------*/\n/*  Parms: command    - Any USS command OR VAR=VALUE  pairs          */\n/*                                                                   */\n/* Basic JCL  Example:                                               */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*        //         PARM='BPXJCL cd /;echo  Directory:;pwd'         */\n/*        //SYSEXEC   DD   DSN=your.rexx.pds,DISP=SHR                */\n/*        //SYSTSPRT  DD   SYSOUT=*                                  */\n/*        //STDOUT    DD   SYSOUT=*                                  */\n/*        //STDERR    DD   SYSOUT=*                                  */\n/*        //SYSTSIN   DD   DUMMY                                     */\n/*        //STDIN     DD   DUMMY                                     */\n/*                                                                   */\n/* Basic JCL Example results:                                        */\n/*                                                                   */\n/*         Directory:                                                */\n/*         /                                                         */\n/*                                                                   */\n/* Notes: Continuation in LONGCMD is supported.  The default  char   */\n/*        is  '\\'.  Change cchar if a different character is desired */\n/*        If a LONGCMD DD is found, anything in it is concatentated  */\n/*        to the end of the PARM field (if present).                 */\n/*                                                                   */\n/* Concatenation JCL  Example:                                       */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*        //         PARM='BPXJCL wc  -l;echo'                       */\n/*        //SYSEXEC  DD    DSN=your.rexx.pds,DISP=SHR                */\n/*        //SYSTSPRT DD    SYSOUT=*                                  */\n/*        //STDOUT   DD    SYSOUT=*                                  */\n/*        //STDERR   DD    SYSOUT=*                                  */\n/*        //SYSTSIN  DD    DUMMY                                     */\n/*        //LONGCMD  DD    *                                         */\n/*         111111\\                                                   */\n/*         222222                                                    */\n/*         333333                                                    */\n/*         444444\\                                                   */\n/*         555555                                                    */\n/*        //STDIN     DD    *                                        */\n/*         aaaaaaaaaaaaaaaaaa                                        */\n/*         bbbbbbbbbbbbbbbbbb                                        */\n/*         cccccccccccccccccc                                        */\n/*         dddddddddddddddddd                                        */\n/*         eeeeeeeeeeeeeeeeee                                        */\n/*                                                                   */\n/* Concatenation JCL Example  Results:                               */\n/*                                                                   */\n/*               5                                                   */\n/*        111111222222 333333  444444555555                          */\n/*                                                                   */\n/* Notes: VAR=VALUE pairs only work when the LONGCMD DD is present   */\n/*        and the first character of the parm string is '?' followed */\n/*        by space delimited VAR=VALUE pairs (no syntax checking).   */\n/*        Imbedded \"symbols\" follow strict JCL Symbolic rules and    */\n/*        must begin with a '&' and end with a '.' ('?', '&' and '.' */\n/*        can be changed in the default settings).                   */\n/*                                                                   */\n/* Symbolic Substitution JCL  Example:                               */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*        //         PARM='BPXJCL ?A=9 B=8 C=7'                      */\n/*        //SYSEXEC   DD   DSN=your.rexx.pds,DISP=SHR                */\n/*        //SYSTSPRT  DD   SYSOUT=*                                  */\n/*        //STDOUT    DD   SYSOUT=*                                  */\n/*        //STDERR    DD   SYSOUT=*                                  */\n/*        //SYSTSIN   DD   DUMMY                                     */\n/*        //LONGCMD   DD   *                                         */\n/*        wc  -l;                                                    */\n/*        echo  \\                                                    */\n/*         11&A.1&A.1\\                                               */\n/*         222222                                                    */\n/*         33&B.3&B.3                                                */\n/*         4&A.4&B.&C.\\                                              */\n/*         555&C.&C.55;                                              */\n/*        //STDIN     DD    *                                        */\n/*         aaaaaaaaaaaaaaaaaa                                        */\n/*         bbbbbbbbbbbbbbbbbb                                        */\n/*         cccccccccccccccccc                                        */\n/*         dddddddddddddddddd                                        */\n/*         eeeeeeeeeeeeeeeeee                                        */\n/*                                                                   */\n/* Symbolic Substitution JCL Example results:                        */\n/*                                                                   */\n/*               5                                                   */\n/*        119191222222 338383  4444445557755                         */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   ---------------------------------------- */\n/*  R. Zenuk    Jan 2005   Initial Creation                          */\n/*  R. Zenuk    01/16/07   Added STDIN and LONGCMD support           */\n/*  R. Zenuk    01/26/07   Added LONGCMD continuation support ('\\')  */\n/*  R. Zenuk    02/08/07   Added Symbolic substitution support       */\n/*                                                                   */\n/*********************************************************************/\n/*  Accept  command                                                  */\n/*********************************************************************/\nparse  arg command\nsay mvsvar('SYSNAME') mvsvar('SYMDEF','JOBNAME') date()  time()\n/*********************************************************************/\n/*  Set  defaults                                                    */\n/*********************************************************************/\nsub   =  'NO'              /* Default to no symbolic substitution    */\ncont  =  'NO'              /* Start value for continuations          */\ncchar =  '\\'               /* Default continuation character         */\nschar =  '?'               /* Default substitution signal character  */\nvchar =  '&'               /* Default symbol begin character         */\ntchar =  '.'               /* Default symbol termination character   */\n/*********************************************************************/\n/*  Check if there is any STDIN  data                                */\n/*********************************************************************/\nLRC  = listdsi('STDIN' 'FILE')\nif LRC = 0 | (LRC <> 0 & sysreason  = 3) then\ndo\n\"EXECIO * DISKR STDIN  (STEM STDIN. FINIS\"\nif stdin.0 <> 0  then\ndo\nsay\nsay 'STDIN contents  ('stdin.0' lines):'\nsay\ndo i=1 to  stdin.0\nsay stdin.i\nend\nend\nend\n/*********************************************************************/\n/*  Check if there is a LONGCMD  DD                                  */\n/*********************************************************************/\nLRC  = listdsi('LONGCMD' 'FILE')\nif LRC = 0 | (LRC <> 0 &  sysreason = 3) then\ndo\n/*********************************************************************/\n/*  Determine if Symbolic Substitution is required                   */\n/*********************************************************************/\nif left(command,1) = schar then\ndo\ncommand =  right(command,length(command)-1)\nvars = words(command)\nsub =  'YES'\nsay\nsay 'Symbol substitution  is progress:'\nsay\ndo v=1 to  vars\nvarpair =  word(command,v)\nparse var varpair var.v '=' value.v  .\nsay  var.v 'will be replaced with'  value.v\nend\nsay\ncommand =  ''\nend\n/*********************************************************************/\n/*  Read LONGCMD DD  input                                           */\n/*********************************************************************/\n\"EXECIO * DISKR LONGCMD (STEM LONGCMD. FINIS\"\nif  longcmd.0 <> 0 then\ndo\nsay\nsay 'Original LONGCMD  contents:'\nsay\ndo l=1 to  longcmd.0\n/*********************************************************************/\n/*  Continuation  support                                            */\n/*********************************************************************/\nif left(reverse(strip(longcmd.l)),1) = cchar  then\ndo\nprev =  cont\ncont =  'YES'\nend\nelse\ndo\nprev =  cont\ncont =  'NO'\nend\n/*********************************************************************/\n/*  Determine how to concatenate the lines (flush or  space)         */\n/*********************************************************************/\nselect\nwhen prev = 'YES' & cont = 'YES'  then\ncommand =  command||strip(strip(longcmd.l),'T',cchar)\nwhen prev = 'NO' & cont = 'YES'  then\ncommand = command  strip(strip(longcmd.l),'T',cchar)\nwhen prev = 'YES' & cont = 'NO'  then\ncommand =  command||strip(longcmd.l)\notherwise\ncommand = command  strip(longcmd.l)\nend\nsay  longcmd.l\nend\nend\nend\n/*********************************************************************/\n/*  Perform Symbolic Substitution if appropriate                     */\n/*********************************************************************/\nif  sub = 'YES' then\ndo s=1 to  vars\ncommand =  chgstr(command,value.s,vchar||var.s||tchar)\nend\n/*********************************************************************/\n/*  Command being executed                                           */\n/*********************************************************************/\nsay\nsay  'Executing command ('length(command) 'bytes):'  command\nsay\nexit  BPXWUNIX(command,'DD:stdin','DD:stdout','DD:stderr','0')\n/*********************************************************************/\n/*  Change symbolic to value                                         */\n/*********************************************************************/\nchgstr:  procedure\nif arg() <>  3 then\nreturn 'chgstr: missing args, must have string, new and  old'\nstring =  arg(1)\nnew =  arg(2)\nold =  arg(3)\nlnew =  length(new)\nlold =  length(old)\nx =  1\ndo  forever\nif  pos(old,string,x) = 0 then return  string\nx =  pos(old,string,x)\nstring =  insert(new,delstr(string,x,lold),x-1,lnew)\nx = x + length(new)\nend\n\n\nHope this helps,\n\nRob\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXJCL@": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x13\"o\\x01\\x13\"o#V\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T23:56:36", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Free alternative to BPXBATCH/AOPBATCH\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     2/8/2007 11:53 PM\n\nHere is another free alternative to BPXBATCH/AOPBATCH.  This is\nan extension to something I posted a while back called BPXJCL.\nIt still provides a valid return code in JCL that can be used in\nJCL IF and COND processing (the original requirement).  Recently,\nour internal requirements changed and the basic BPXJCL REXX EXEC\nI posted has grown in size and features.  We needed a way to\nexecute long and/or multiple commands in JCL.  This was first\nprovided to implement long (greater that 100 character)\nsemi-colon separated commands.  Right after this was provided, we\nalso needed to run long pipeline commands, so a continuation\ncharacter was provided.  After both of these were done, it was\nrequested to provide PROC support so reusable \"command members\"\ncould be implemented.\n\nHere is the latest iteration of BPXJCL.  Have fun.  No warranties.\nHowever, if you find any bugs let me know and I will try to fix\nthem as I have time.  Hopefully, the comments are sufficient to\nuse it.  All I can say is it works for us...  There is a more\nextensive example at the end of this email that was used as an\nexample and a training tool for our programmers.\n\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXJCL01": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00E\\x01\\x13\"o\\x01\\x13\"o#B\\x00\\xd8\\x00\\xda\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T23:42:45", "lines": 216, "newlines": 218, "modlines": 0, "user": "SBGOLOB"}, "text": "/****************************** REXX *********************************/\n/*  Purpose: Use BPXWUNIX to redirect STDOUT and STDERR to SYSOUT    */\n/*-------------------------------------------------------------------*/\n/*  Syntax:  BPXJCL  command                                         */\n/*-------------------------------------------------------------------*/\n/*  Parms: command    - Any USS command OR VAR=VALUE  pairs          */\n/*                                                                   */\n/* Notes: Continuation in LONGCMD is supported.  The default  char   */\n/*        is  '\\'.  Change cchar if a different character is desired */\n/*        If a LONGCMD DD is found, anything in it is concatentated  */\n/*        to the end of the PARM field (if present).                 */\n/*                                                                   */\n/* Basic JCL  Example:                                               */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*        //         PARM='BPXJCL wc  -l;echo'                       */\n/*        //SYSEXEC  DD    DSN=your.rexx.pds,DISP=SHR                */\n/*        //SYSTSPRT DD    SYSOUT=*                                  */\n/*        //STDOUT   DD    SYSOUT=*                                  */\n/*        //STDERR   DD    SYSOUT=*                                  */\n/*        //SYSTSIN  DD    DUMMY                                     */\n/*        //LONGCMD  DD    *                                         */\n/*         111111\\                                                   */\n/*         222222                                                    */\n/*         333333                                                    */\n/*         444444\\                                                   */\n/*         555555                                                    */\n/*        //STDIN     DD    *                                        */\n/*         aaaaaaaaaaaaaaaaaa                                        */\n/*         bbbbbbbbbbbbbbbbbb                                        */\n/*         cccccccccccccccccc                                        */\n/*         dddddddddddddddddd                                        */\n/*         eeeeeeeeeeeeeeeeee                                        */\n/*                                                                   */\n/* Basic JCL Example  results:                                       */\n/*                                                                   */\n/*               5                                                   */\n/*        111111222222 333333  444444555555                          */\n/*                                                                   */\n/*        VAR=VALUE pairs only work when the LONGCMD DD is present   */\n/*        and the first character of the parm string is '?' followed */\n/*        by space delimited VAR=VALUE pairs (no syntax checking).   */\n/*        Imbedded \"symbols\" follow strict JCL Symbolic rules and    */\n/*        must begin with a '&' and end with a '.' ('?', '&' and '.' */\n/*        can be changed in the default settings).                   */\n/*                                                                   */\n/* Symbolic Substitution JCL  Example:                               */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*        //         PARM='BPXJCL ?A=9 B=8 C=7'                      */\n/*        //SYSEXEC   DD   DSN=your.rexx.pds,DISP=SHR                */\n/*        //SYSTSPRT  DD   SYSOUT=*                                  */\n/*        //STDOUT    DD   SYSOUT=*                                  */\n/*        //STDERR    DD   SYSOUT=*                                  */\n/*        //SYSTSIN   DD   DUMMY                                     */\n/*        //LONGCMD   DD   *                                         */\n/*        wc  -l;                                                    */\n/*        echo  \\                                                    */\n/*         11&A.1&A.1\\                                               */\n/*         222222                                                    */\n/*         33&B.3&B.3                                                */\n/*         444444\\                                                   */\n/*         555&C.&C.55;                                              */\n/*        //STDIN     DD    *                                        */\n/*         aaaaaaaaaaaaaaaaaa                                        */\n/*         bbbbbbbbbbbbbbbbbb                                        */\n/*         cccccccccccccccccc                                        */\n/*         dddddddddddddddddd                                        */\n/*         eeeeeeeeeeeeeeeeee                                        */\n/*                                                                   */\n/* Symbolic Substitution JCL Example results:                        */\n/*                                                                   */\n/*               5                                                   */\n/*        119191222222 338383  4444445557755                         */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   ---------------------------------------- */\n/*  R. Zenuk    Jan 2005   Initial Creation                          */\n/*  R. Zenuk    01/16/07   Added STDIN and LONGCMD support           */\n/*  R. Zenuk    01/26/07   Added LONGCMD continuation support ('\\')  */\n/*  R. Zenuk    02/08/07   Added Symbolic substitution support       */\n/*                                                                   */\n/*********************************************************************/\n/*  Accept  command                                                  */\n/*********************************************************************/\nparse  arg command\nsay mvsvar('SYSNAME') mvsvar('SYMDEF','JOBNAME') date()  time()\n/*********************************************************************/\n/*  Set  defaults                                                    */\n/*********************************************************************/\nsub   =  'NO'              /* Default to no symbolic substitution    */\ncont  =  'NO'              /* Start value for continuations          */\ncchar =  '\\'               /* Default continuation character         */\nschar =  '?'               /* Default substitution signal character  */\nvchar =  '&'               /* Default symbol begin character         */\ntchar =  '.'               /* Default symbol termination character   */\n/*********************************************************************/\n/*  Check if there is any STDIN  data                                */\n/*********************************************************************/\nLRC  = listdsi('STDIN' 'FILE')\nif LRC = 0 | (LRC <> 0 & sysreason  = 3) then\ndo\n\"EXECIO * DISKR STDIN  (STEM STDIN. FINIS\"\nif stdin.0 <> 0  then\ndo\nsay\nsay 'STDIN contents  ('stdin.0' lines):'\nsay\ndo i=1 to  stdin.0\nsay stdin.i\nend\nend\nend\n/*********************************************************************/\n/*  Check if there is a LONGCMD  DD                                  */\n/*********************************************************************/\nLRC  = listdsi('LONGCMD' 'FILE')\nif LRC = 0 | (LRC <> 0 &  sysreason = 3) then\ndo\n/*********************************************************************/\n/*  Determine if Symbolic Substitution is required                   */\n/*********************************************************************/\nif left(command,1) = schar then\ndo\ncommand =  right(command,length(command)-1)\nvars = words(command)\nsub =  'YES'\nsay\nsay 'Symbol substitution  is progress:'\nsay\ndo v=1 to  vars\nvarpair =  word(command,v)\nparse var varpair var.v '=' value.v  .\nsay  var.v 'will be replaced with'  value.v\nend\nsay\ncommand =  ''\nend\n/*********************************************************************/\n/*  Read LONGCMD DD  input                                           */\n/*********************************************************************/\n\"EXECIO * DISKR LONGCMD (STEM LONGCMD. FINIS\"\nif  longcmd.0 <> 0 then\ndo\nsay\nsay 'Original LONGCMD  contents:'\nsay\ndo l=1 to  longcmd.0\n/*********************************************************************/\n/*  Continuation  support                                            */\n/*********************************************************************/\nif left(reverse(strip(longcmd.l)),1) = cchar  then\ndo\nprev =  cont\ncont =  'YES'\nend\nelse\ndo\nprev =  cont\ncont =  'NO'\nend\n/*********************************************************************/\n/*  Determine how to concatenate the lines (flush or  space)         */\n/*********************************************************************/\nselect\nwhen prev = 'YES' & cont = 'YES'  then\ncommand =  command||strip(strip(longcmd.l),'T',cchar)\nwhen prev = 'NO' & cont = 'YES'  then\ncommand = command  strip(strip(longcmd.l),'T',cchar)\nwhen prev = 'YES' & cont = 'NO'  then\ncommand =  command||strip(longcmd.l)\notherwise\ncommand = command  strip(longcmd.l)\nend\nsay  longcmd.l\nend\nend\nend\n/*********************************************************************/\n/*  Perform Symbolic Substitution if appropriate                     */\n/*********************************************************************/\nif  sub = 'YES' then\ndo s=1 to  vars\nvar =  vchar||var.s||tchar\ncommand =  chgstr(command,value.s,var)\nend\n/*********************************************************************/\n/*  Command being executed                                           */\n/*********************************************************************/\nsay\ncmdlen  = length(command)\nsay 'Executing command ('cmdlen 'bytes):'  command\nsay\nexit  BPXWUNIX(command,'DD:stdin','DD:stdout','DD:stderr','0')\n/*********************************************************************/\n/*  Change symbolic to value                                         */\n/*********************************************************************/\nchgstr:  procedure\nif arg() <>  3 then\nreturn 'chgstr: missing args, must have string, new and  old'\nstring =  arg(1)\nnew =  arg(2)\nold =  arg(3)\nlnew =  length(new)\nlold =  length(old)\nx =  1\ndo  forever\nif  pos(old,string,x) = 0 then return  string\nx =  pos(old,string,x)\nstring =  insert(new,delstr(string,x,lold),x-1,lnew)\nx = x + length(new)\nend\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXJCL02": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x13\"\\x7f\\x01\\x13\"\\x7f\\x14T\\x00\\x15\\x00\\x17\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-15T00:00:00", "modifydate": "2013-08-15T14:54:44", "lines": 21, "newlines": 23, "modlines": 0, "user": "SBGOLOB"}, "text": "/****************************** REXX *********************************/\n/*  Purpose: Use BPXWUNIX to redirect STDOUT and STDERR to  SYSOUT   */\n/*-------------------------------------------------------------------*/\n/*  Syntax:  BPXJCL  command                                         */\n/*-------------------------------------------------------------------*/\n/*  Parms: command    - Any USS  command                             */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   -----------------------------------------*/\n/*  R.  Zenuk    Jan 2005   Initial  Creation                        */\n/*                                                                   */\n/*********************************************************************/\nparse  arg  command\nsay mvsvar('SYSNAME') mvsvar('SYMDEF','JOBNAME') date()  time()\nsay\nsay 'Executing command:'  command\nsay\nexit  BPXWUNIX(command,'DD:stdin','DD:stdout','DD:stderr','0')\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BPXSPOOL": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x13\"\\x7f\\x01\\x13\"\\x7f\\x14\\x15\\x012\\x01\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-15T00:00:00", "modifydate": "2013-08-15T14:15:31", "lines": 306, "newlines": 282, "modlines": 0, "user": "SBGOLOB"}, "text": "In a recent note, McKown, John said:\n\n Date:         Fri, 11 Aug 2006 08:08:08 -0500\n\n I just checked the z/OS v1.8 book. It states that stdout and\n stderr can be allocated to a legacy dataset, but that stdin must\n be allocated to an UNIX file (not a legacy dataset).\n\n http://publibz.boulder.ibm.com/cgi-bin/bookmgr_OS390/BOOKS ...\n /bpxza570/TSOECMDS.TSOBPXBATCH.2\n\nHas anyone ever wondered why the residual restriction?\n\nOr, you can search the archives of this list for Rob Zenuk's\nBPXSPOOL, a simple Rexx EXEC that bypasses the restriction.\n\n-- gil\n--\nStorageTek\nINFORMATION made POWERFUL\n\n------------------------------------------------------------------\nand here it is .......\n\nApproved-By:  Robzenuk@AOL.COM\nMessage-ID:  <1d4.1e8f4406.2da6da14@aol.com>\nDate:         Thu, 8 Apr 2004 12:38:44 EDT\nReply-To:     MVS OpenEdition <MVS-OE@VM.MARIST.EDU>\nSender:       MVS OpenEdition <MVS-OE@VM.MARIST.EDU>\nFrom:         Robert Zenuk <Robzenuk@aol.com>\nSubject:      Re: File copy in OMVS\n\nAs already mentioned BPXBATCH will do the trick if you want to do\nthis from JCL.  If you want to issue any command from inside\nREXX, you can call BPXBATCH inside your REXX EXEC.\n\n/* rexx */\n parse arg usscmd\n\"BPXBATCH SH\" usscmd\n exit RC\n\nUsing either approach requires the use of the standard streams\nSTDOUT and STDERR if you want to actually see what happened.  You\ncan ALLOC these in your JCL (using the DD PATH statements) or you\ncan ALLOC them in your EXEC, either works.  If you do not ALLOC\nSTDOUT or STDERR your command may or may not work and you have no\nvisibility either way.\n\nHere is some basic BPXBATCH JCL:\n\n//jobcard...\n//***************************************************************\n//* RUN BPXBATCH TO EXECUTE A UNIX COMMAND OR SCRIPT            *\n//***************************************************************\n//BPXBATCH EXEC PGM=BPXBATCH,PARM='SH cp /u/user1/* /u/user2'\n//STDOUT   DD   PATH='/tmp/bpxbatch.stdout',PATHOPTS=(OWRONLY,OCREAT),\n//         PATHMODE=SIRWXU\n//STDERR   DD   PATH='/tmp/bpxbatch.stderr',PATHOPTS=(OWRONLY,OCREAT),\n//         PATHMODE=SIRWXU\n\nIf you want the output to be readable in the SPOOL after the run\nthen you must use an IEBGENER step (or OCOPY or, or ,or) to read\nthe HFS file to a viewable SYSOUT.\n\nHere is some JCL demonstrating a BPXBATCH approach using JCL IF\nand IEBGENER to print:\n\n//jobcard...\n//***************************************************************\n//* NOTE: Since Unix is case sensitive, it is mandatory that    *\n//*       The JCL members be editted with CAPS OFF to insure    *\n//*       the correct commands will be executed.                *\n//***************************************************************\n/*JOBPARM SYSAFF=*\n//***************************************************************\n//* RUN BPXBATCH TO EXECUTE A UNIX COMMAND OR SCRIPT            *\n//***************************************************************\n//BPXBATCH EXEC PGM=BPXBATCH,PARM='SH cp /u/user1/* /u/user2'\n//STDOUT   DD   PATH='/tmp/bpxbatch.stdout',PATHOPTS=(OWRONLY,OCREAT),\n//         PATHMODE=SIRWXU\n//STDERR   DD   PATH='/tmp/bpxbatch.stderr',PATHOPTS=(OWRONLY,OCREAT),\n//         PATHMODE=SIRWXU\n//***************************************************************\n//* PRINT STDOUT IF BPXBATCH GETS RC=0                          *\n//***************************************************************\n//         IF   (BPXBATCH.RC = 0) THEN\n//***************************************************************\n//PRTOUT   EXEC PGM=IEBGENER\n//SYSPRINT DD   SYSOUT=Z\n//SYSUT1   DD   PATH='/tmp/bpxbatch.stdout',PATHOPTS=(ORDONLY),\n//         FILEDATA=TEXT,BLKSIZE=255,PATHDISP=(DELETE,DELETE)\n//SYSUT2   DD   SYSOUT=*\n//SYSIN    DD   DUMMY\n//***************************************************************\n//* PRINT STDOUT IF BPXBATCH GETS RC^=0                         *\n//***************************************************************\n//         ELSE\n//***************************************************************\n//PRTERR   EXEC PGM=IEBGENER\n//SYSPRINT DD   SYSOUT=Z\n//SYSUT1   DD   PATH='/tmp/bpxbatch.stderr',PATHOPTS=(ORDONLY),\n//         FILEDATA=TEXT,BLKSIZE=255,PATHDISP=(DELETE,DELETE)\n//SYSUT2   DD   SYSOUT=*\n//SYSIN    DD   DUMMY\n//***************************************************************\n//         ENDIF\n\nIn REXX you can run commands from the IBM provided OSHELL REXX\nEXEC found in SYS1.SBPXEXEC.  This works in batch and foreground.\n\nIf the REXX EXEC will be running in TSO foreground, then you\ncould EXECIO the HFS file into a temporary dataset and\nEDIT/VIEW/BROWSE it or use the USS provided OBROWSE or OEDIT\nservices to work with the HFS file in ISPF Browse or ISPF Edit\n(requires the SBPXEXEC and SPBXPENU datasets to be allocated).\n\nHere is a generic EXEC to run any USS command and browse the results:\n\n/******************************* REXX ********************************/\n/* Purpose: Execute USS commands from TSO and browse results         */\n/*                                                                   */\n/* Syntax: USSCMD cmd                                                */\n/*                                                                   */\n/* Parms: cmd      - Any UNIX Systems Services Command               */\n/*                                                                   */\n/* Notes: Will execute USS commands, shell scripts and REXX EXECs    */\n/*                                                                   */\n/*                           Change Log                              */\n/* Name           Purpose                                  date      */\n/* -------------  ---------------------------------------  --------  */\n/* R. Zenuk       Initial creation                         Nov 2000  */\n/* R. Zenuk       Will display USS REXX output             07/11/01  */\n/* R. Zenuk       Added test for a valid ISPF environment  07/18/01  */\n/* R. Zenuk       Streamlined code                         07/20/01  */\n/* R. Zenuk       Added ACTIVATE in case SPBXEXEC missing  07/21/01  */\n/*                                                                   */\n/*********************************************************************/\n/* Test for a valid ISPF environment                                 */\n/*********************************************************************/\n\"ISPQRY\"\nif RC <> 0 then\n    do\n     say 'A valid ISPF environment does not exist'\n     exit(99)\n    end\n/*********************************************************************/\n/* Accept USS Command (retain lower case)                            */\n/*********************************************************************/\nparse arg cmd\nif cmd = '' then\n    do\n     zedlmsg = 'A valid Unix System Services command must be entered'\n     address ISPEXEC\n    \"SETMSG MSG(ISRZ000)\"\n     exit(98)\n    end\n/*********************************************************************/\n/* Allocate the BPX EXEC PDS                                         */\n/*********************************************************************/\n\"ALLOC F(SYSUEXEC) DA('SYS1.SBPXEXEC') SHR REU\"\n\"ALTLIB ACTIVATE USER(EXEC)\"\naddress ISPEXEC \"LIBDEF ISPPLIB DATASET ID('SYS1.SBPXPENU') STACK\"\n/*********************************************************************/\n/* Command prefix                                                    */\n/*********************************************************************/\ncmdpfx = 'BPXBATCH SH'\n/*********************************************************************/\n/* Set STDOUT and STDERR file names                                  */\n/*********************************************************************/\nstdout = '/tmp/'||userid()||'-bpxbatch-stdout-'||time('s')\nstderr = '/tmp/'||userid()||'-bpxbatch-stderr-'||time('s')\n/*********************************************************************/\n/* Allocate STDOUT and STDERR for messages and errors                */\n/*********************************************************************/\nif ussalloc(\"STDOUT\" stdout) <> 0 then exit(97)\nif ussalloc(\"STDERR\" stderr) <> 0 then exit(96)\n/*********************************************************************/\n/* Use BPXBATCH to execute the requested UNIX System Services CMD    */\n/*********************************************************************/\ncmdpfx cmd\nEXITRC = RC / 256\n/*********************************************************************/\n/* If RC <> 0 BROWSE STDERR to determine the error (if not empty)    */\n/*********************************************************************/\nif EXITRC <> 0 then\n    do\n/*********************************************************************/\n/* If STDERR is not empty, set the OBROWSE file to STDERR            */\n/*********************************************************************/\n     if filectr(\"TESTERR\" stderr) > 0 then\n        do\n         zedlmsg = 'Error during execution of command:' cmd 'RC='EXITRC\n         viewfile = stderr\n        end\n     else\n/*********************************************************************/\n/* If STDERR is empty and RC>0 use STDOUT (could be a REXX EXEC)     */\n/*********************************************************************/\n        do\n         zedlmsg = 'USS REXX EXEC or an error with:' cmd 'RC='EXITRC\n         viewfile = stdout\n        end\n    end\nelse\n/*********************************************************************/\n/* If RC=0 browse STDOUT to review the output                        */\n/*********************************************************************/\n    do\n     zedlmsg = 'Successful execution of command:' cmdpfx cmd\n     viewfile = stdout\n    end\n/*********************************************************************/\n/* Display message and OBROWSE the correct output file               */\n/*********************************************************************/\naddress ISPEXEC\n\"SETMSG MSG(ISRZ000)\"\naddress TSO\n\"OBROWSE\" viewfile\n/*********************************************************************/\n/* Shutdown                                                          */\n/*********************************************************************/\nShutdown: nop\n/*********************************************************************/\n/* Free and remove STDOUT and STDERR files                           */\n/*********************************************************************/\n           call ussfree \"STDOUT\" stdout\n           call ussfree \"STDERR\" stderr\n/*********************************************************************/\n/* Free SYSUEXEC                                                     */\n/*********************************************************************/\n          \"ALTLIB DEACTIVATE USER(EXEC)\"\n          \"FREE F(SYSUEXEC)\"\n           address ISPEXEC \"LIBDEF ISPPLIB\"\n           exit EXITRC\n/*********************************************************************/\n/* Allocate STDxxx files                                             */\n/*********************************************************************/\nussalloc: parse arg dd file\n          \"ALLOCATE FILE(\"dd\") PATH('\"file\"')\",\n          \"PATHOPTS(OWRONLY,OCREAT,OTRUNC) PATHMODE(SIRWXU)\"\n           ALLOCRC = RC\n           if ALLOCRC <> 0 then say dd 'ALLOC Error RC='ALLOCRC\n           return ALLOCRC\n/*********************************************************************/\n/* Free and remove STDxxx files                                      */\n/*********************************************************************/\nussfree: parse arg dd file\n         \"FREE F(\"dd\")\"\n          FREERC = RC\n          if FREERC <> 0 then say dd 'FREE Error RC='FREERC\n         \"BPXBATCH SH rm -f\" file\n          return RC\n/*********************************************************************/\n/* Count the records in a USS file                                   */\n/*********************************************************************/\nfilectr: parse arg dd file\n          if ussalloc(dd file) <> 0 then return 0\n/*********************************************************************/\n/* Read all the lines of STDERR                                      */\n/*********************************************************************/\n         \"EXECIO * DISKR\" dd \"(STEM LINES. FINIS\"\n          EXECIORC = RC\n          if EXECIORC <> 0 then\n             do\n              say dd 'EXECIO DISKR Error RC='EXECIORC\n              return 0\n             end\n         \"FREE F(\"dd\")\"\n          return lines.0\n\nThis is basic stuff that works on any z/OS release and back to\nOS/390 2.5 (I didn't test it with anything before that).  Once\nyou get to z/OS 1.4, there were some modules added to the base\nthat you used to have to download from the z/OS USS Tips and\nTricks page.  One in particular is BPXWUNIX.  This allows you to\nredirect STDOUT and STDERR to a SYSOUT dataset.  This makes life\na lot easier.  Here is a little EXEC that wraps BPXWUNIX that I\nthink makes it easy to use:\n\n/* BPXSPOOL - redirects STDOUT and STDERR to the JES2 Spool from JCL */\nparse arg command\nif syscalls('ON') <> 0 then exit(RC)\nEXITRC = BPXWUNIX(command,'DD:stdin','DD:stdout','DD:stderr','0')\nexit(EXITRC)\n\nAnd JCL to run it:\n\n//jobcard...\n//*******************************************************************\n//* EXECUTE A USS COMMAND USING BPXSPOOL                            *\n//*******************************************************************\n//USSCMD   EXEC PGM=IKJEFT01,PARM='BPXSPOOL cp /u/user1/* /u/user2'\n//SYSEXEC  DD   DSN=your.exec.pds,DISP=SHR\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   DUMMY\n//STDOUT   DD   SYSOUT=*\n//STDERR   DD   SYSOUT=*\n//STDIN    DD   DUMMY\n\nYou would need to add a //STEPLIB to the downloaded version of\nBPXWUNIX if you are not a z/OS 1.4 or above.\n\nHope This Helps,\n\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXWGDG": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x13\"o\\x01\\x13\"o\"U\\x006\\x006\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T22:55:19", "lines": 54, "newlines": 54, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: BPXWDYN gdg(+1)\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     4/19/2007 3:28 PM\n\nIf you can do this in a REXX EXEC (on the MVS side), here is a\nroutine that resolves a relative GDG to an absolute GDG...  If I\nget some more time, I'll see if I can create a reasonable tool\nfor the USS side.\n\n arg dsn\nsay goovoo(dsn)\nexit 0\ngoovoo: arg  dsn\nif dsn = '' then  exit(99)\nparse var dsn  gdgbase '(' relgdg ')'\nif  relgdg = '' | relgdg > 0 then relgdg =  0\ncall outtrap  'lines.'\n\"LISTCAT ENT('\"gdgbase\"')  GDG ALL\"\ngdg =  0\ndo l=1 to  lines.0\nline = translate(lines.l,'  ','-')\nif  word(line,1) = 'NONVSAM'  then\ndo\ngdg = gdg +  1\nparse var line .  gds.gdg\nend\nend\nabsgdg = gdg +  relgdg\nif abs(relgdg) >  gdg - 1  then\nreturn 'INVALID'\nelse\nreturn gds.absgdg\n\n\nIn a message dated 4/19/2007 10:06:12 AM US Mountain Standard Time,\nMark.Gibbons@nordstrom.com writes:\n\nI'd like  to cp hfsfile //mvs.gdg(+1) from an mvs unix shell but cp\nexplicitly  doesn't support that syntax.\n\nCan BPXWDYN be used to allocate a +1  generation of a GDG?  Then I might\nbe able to cp hfs //dd:gdgdd.   Doesn't look like it to me.  I've tried\nbut get obscure dynalloc  return codes.\n\ntodsn from dovetail looks like it has the same  restrictions as bpxwdyn.\n\nDoes anyone have any other method? I was  hoping for something already\nexisting.  I could write an assembler  routine to do the allocation, but\nI'd rather  not.\n\n\nthanks,\nMark\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BPXWUNIX": {"ttr": 1026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x14\\x01\\x13\"_\\x01\\x13\"_\\x14\\x11\\x01\\'\\x01)\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-13T00:00:00", "modifydate": "2013-08-13T14:11:14", "lines": 295, "newlines": 297, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: How to set job step rc from rexx shell script ??\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     3/1/2010 11:15 PM\n\nHere is a utility I wrote to execute shell commands from batch,\nsupports command strings longer than 100 characters, returns usable\nreturn codes and can pass symbolic parameters into the command\nstring.\n\nLet me know if you need a better copy since the indentation will\nprobably get lost...  The EXEC is first and then some sample JCL\nshowing a more sophisticated usage.\n\n\n/****************************** REXX *********************************/\n/*  Purpose: Use BPXWUNIX to redirect STDOUT and STDERR to  SYSOUT   */\n/*-------------------------------------------------------------------*/\n/*  Syntax:  BPXJCL  command                                         */\n/*-------------------------------------------------------------------*/\n/*  Parms: command    - Any USS command OR VAR=VALUE  pairs          */\n/*                                                                   */\n/* Basic JCL  Example:                                               */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*         //         PARM='BPXJCL cd /;echo  Directory:;pwd'        */\n/*        //SYSEXEC   DD    DSN=your.rexx.pds,DISP=SHR               */\n/*        //SYSTSPRT DD    SYSOUT=*                                  */\n/*        //STDOUT    DD    SYSOUT=*                                 */\n/*        //STDERR    DD    SYSOUT=*                                 */\n/*        //SYSTSIN   DD    DUMMY                                    */\n/*        //STDIN     DD    DUMMY                                    */\n/*                                                                   */\n/* Basic JCL Example  results:                                       */\n/*                                                                   */\n/*         Directory:                                                */\n/*         /                                                         */\n/*                                                                   */\n/* Notes: Continuation in LONGCMD is supported.  The default  char   */\n/*        is  '\\'.  Change cchar if a different character is desired */\n/*        If a LONGCMD DD is found,  anything in it is concatentated */\n/*        to the end of the PARM field  (if  present).               */\n/*                                                                   */\n/* Concatenation JCL  Example:                                       */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*         //         PARM='BPXJCL wc  -l;echo'                      */\n/*        //SYSEXEC   DD    DSN=your.rexx.pds,DISP=SHR               */\n/*        //SYSTSPRT DD    SYSOUT=*                                  */\n/*        //STDOUT    DD    SYSOUT=*                                 */\n/*        //STDERR    DD    SYSOUT=*                                 */\n/*        //SYSTSIN   DD    DUMMY                                    */\n/*        //LONGCMD   DD    *                                        */\n/*         111111\\                                                   */\n/*         222222                                                    */\n/*         333333                                                    */\n/*         444444\\                                                   */\n/*         555555                                                    */\n/*        //STDIN     DD    *                                        */\n/*         aaaaaaaaaaaaaaaaaa                                        */\n/*         bbbbbbbbbbbbbbbbbb                                        */\n/*         cccccccccccccccccc                                        */\n/*         dddddddddddddddddd                                        */\n/*         eeeeeeeeeeeeeeeeee                                        */\n/*                                                                   */\n/* Concatenation JCL Example  Results:                               */\n/*                                                                   */\n/*               5                                                   */\n/*        111111222222 333333  444444555555                          */\n/*                                                                   */\n/* Notes: VAR=VALUE pairs only work when the LONGCMD DD is  present  */\n/*        and the  first character of the parm string is '?' followed */\n/*        by space delimited VAR=VALUE  pairs (no syntax checking).   */\n/*        Imbedded \"symbols\" follow  strict JCL Symbolic rules and    */\n/*        must begin with a '&' and  end with a '.' ('?', '&' and '.' */\n/*        can be changed in the default  settings).                   */\n/*                                                                   */\n/* Symbolic Substitution JCL  Example:                               */\n/*                                                                   */\n/*        //BPXJCL   EXEC  PGM=IKJEFT01,                             */\n/*         //         PARM='BPXJCL ?A=9 B=8  C=7'                    */\n/*        //SYSEXEC   DD    DSN=your.rexx.pds,DISP=SHR               */\n/*        //SYSTSPRT DD    SYSOUT=*                                  */\n/*        //STDOUT    DD    SYSOUT=*                                 */\n/*        //STDERR    DD    SYSOUT=*                                 */\n/*        //SYSTSIN   DD    DUMMY                                    */\n/*        //LONGCMD   DD    *                                        */\n/*        wc  -l;                                                    */\n/*        echo  \\                                                    */\n/*         11&A.1&A.1\\                                               */\n/*         222222                                                    */\n/*         33&B.3&B.3                                                */\n/*         4&A.4&B.&C.\\                                              */\n/*         555&C.&C.55;                                              */\n/*        //STDIN     DD    *                                        */\n/*         aaaaaaaaaaaaaaaaaa                                        */\n/*         bbbbbbbbbbbbbbbbbb                                        */\n/*         cccccccccccccccccc                                        */\n/*         dddddddddddddddddd                                        */\n/*         eeeeeeeeeeeeeeeeee                                        */\n/*                                                                   */\n/* Symbolic Substitution JCL Example  results:                       */\n/*                                                                   */\n/*               5                                                   */\n/*        119191222222 338383  4444445557755                         */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   ---------------------------------------- */\n/*  R.  Zenuk    Jan 2005   Initial  Creation                        */\n/*  R. Zenuk    01/16/07   Added STDIN and  LONGCMD support          */\n/*  R. Zenuk    01/26/07   Added LONGCMD  continuation support  ('\\') */\n/*  R. Zenuk     02/08/07   Added Symbolic substitution  support     */\n/*                                                                   */\n/*********************************************************************/\n/*  Accept  command                                                  */\n/*********************************************************************/\nparse  arg command\nsay mvsvar('SYSNAME') mvsvar('SYMDEF','JOBNAME') date()  time()\n/*********************************************************************/\n/*  Set  defaults                                                    */\n/*********************************************************************/\nsub    =  'NO'              /* Default to no symbolic substitution   */\ncont  =  'NO'              /* Start value for continuations          */\ncchar =  '\\'               /* Default continuation character         */\nschar =  '?'                /* Default substitution signal character */\nvchar =  '&'               /* Default symbol begin character         */\ntchar =  '.'               /* Default symbol termination character   */\n/*********************************************************************/\n/*  Check if there is any STDIN  data                                */\n/*********************************************************************/\nLRC  = listdsi('STDIN' 'FILE')\nif LRC = 0 | (LRC <> 0 & sysreason  = 3) then\ndo\n\"EXECIO * DISKR STDIN  (STEM STDIN. FINIS\"\nif stdin.0 <> 0  then\ndo\nsay\nsay 'STDIN contents  ('stdin.0' lines):'\nsay\ndo i=1 to  stdin.0\nsay stdin.i\nend\nend\nend\n/*********************************************************************/\n/*  Check if there is a LONGCMD  DD                                  */\n/*********************************************************************/\nLRC  = listdsi('LONGCMD' 'FILE')\nif LRC = 0 | (LRC <> 0 &  sysreason = 3) then\ndo\n/*********************************************************************/\n/*  Determine if Symbolic Substitution is  required                  */\n/*********************************************************************/\nif left(command,1) = schar then\ndo\ncommand =  right(command,length(command)-1)\nvars = words(command)\nsub =  'YES'\nsay\nsay 'Symbol substitution  is progress:'\nsay\ndo v=1 to  vars\nvarpair =  word(command,v)\nparse var varpair var.v '=' value.v  .\nsay  var.v 'will be replaced with'  value.v\nend\nsay\ncommand =  ''\nend\n/*********************************************************************/\n/*  Read LONGCMD DD  input                                           */\n/*********************************************************************/\n\"EXECIO * DISKR LONGCMD (STEM LONGCMD. FINIS\"\nif  longcmd.0 <> 0 then\ndo\nsay\nsay 'Original LONGCMD  contents:'\nsay\ndo l=1 to  longcmd.0\n/*********************************************************************/\n/*  Continuation  support                                            */\n/*********************************************************************/\nif left(reverse(strip(longcmd.l)),1) = cchar  then\ndo\nprev =  cont\ncont =  'YES'\nend\nelse\ndo\nprev =  cont\ncont =  'NO'\nend\n/*********************************************************************/\n/*  Determine how to concatenate the lines (flush or  space)         */\n/*********************************************************************/\nselect\nwhen prev = 'YES' & cont = 'YES'  then\ncommand =  command||strip(strip(longcmd.l),'T',cchar)\nwhen prev = 'NO' & cont = 'YES'  then\ncommand = command  strip(strip(longcmd.l),'T',cchar)\nwhen prev = 'YES' & cont = 'NO'  then\ncommand =  command||strip(longcmd.l)\notherwise\ncommand = command  strip(longcmd.l)\nend\nsay  longcmd.l\nend\nend\nend\n/*********************************************************************/\n/*  Perform Symbolic Substitution if  appropriate                    */\n/*********************************************************************/\nif  sub = 'YES' then\ndo s=1 to  vars\ncommand =  chgstr(command,value.s,vchar||var.s||tchar)\nend\n/*********************************************************************/\n/*  Command being  executed                                          */\n/*********************************************************************/\nsay\nsay  'Executing command ('length(command) 'bytes):'  command\nsay\nexit  BPXWUNIX(command,'DD:stdin','DD:stdout','DD:stderr','0')\n/*********************************************************************/\n/*  Change symbolic to  value                                        */\n/*********************************************************************/\nchgstr:  procedure\nif arg() <>  3 then\nreturn 'chgstr: missing args, must have string, new and  old'\nstring =  arg(1)\nnew =  arg(2)\nold =  arg(3)\nlnew =  length(new)\nlold =  length(old)\nx =  1\ndo  forever\nif  pos(old,string,x) = 0 then return  string\nx =  pos(old,string,x)\nstring =  insert(new,delstr(string,x,lold),x-1,lnew)\nx = x + length(new)\nend\n\n\n\n//OPSROZBJ JOB   (0000),'BPXJCL',NOTIFY=&SYSUID,REGION=0M,CLASS=O\n/*JOBPARM  SYSAFF=*\n//*******************************************************************\n//*  EXECUTE A USS COMMAND USING  BPXJCL                            *\n//*******************************************************************\n//BPXJCL    EXEC PGM=IKJEFT01,\n//    PARM='BPXJCL ?DIR=/users/opsroz/  FILE=my_file SFX1=txt SFX2=trig'\n//SYSEXEC  DD    DSN=OPSROZ.EXEC,DISP=SHR\n//SYSTSPRT DD    SYSOUT=*\n//STDOUT   DD   SYSOUT=*\n//STDERR    DD   SYSOUT=*\n//SYSTSIN  DD    DUMMY\n//LONGCMD  DD   *\nstartdir=&DIR.;\ncd  ${startdir};\necho Directory is  ${startdir};\necho;\nfile=&FILE.;\nsuffix1=_YYYYMMDDHHMMSS.&SFX1.;\nsuffix2=_YYYYMMDDHHMMSS.&SFX2.;\nfilename1=${file}${suffix1};\nfilename2=${file}${suffix2};\necho  File 1 is ${filename1};\necho File 2 is ${filename2};\necho;\ntouch  ${filename1};\ntouch ${filename2};\nls -l | grep  ${file};\necho;\nts=`date +%Y%m%d%H%M%S`;\necho Timestamp is  ${ts};\necho;\nnewsuffix1=_${ts}.&SFX1.;\nnewsuffix2=_${ts}.&SFX2.;\nnewname1=${file}${newsuffix1};\nnewname2=${file}${newsuffix2};\nmv  ${filename1} ${newname1};\nmv ${filename2} ${newname2};\necho New name 1 is  ${newname1};\necho New name 2 is ${newname2};\necho;\nls -l | grep  ${file}\n//STDIN    DD   DUMMY\n\n\nHope This Helps,\n\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EZAZTSAB": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x19\\x0f\\x01\\x12\\x19\\x0f\\x133\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-08T00:00:00", "modifydate": "2012-07-08T13:33:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHOW721"}, "text": "         MACRO\n         EZAZTSAB\nTSAB         DSECT                                               RS0100\nTSABEYEC     DS  CL4                   eyecatcher 'TSAB'         RS0100\nTSAB_LENGTH  DS  H                     length TSAB               RS0100\n             DS  H                     Version of TSAB ??        RS0100\n             DS  CL8                   ?                         RS0100\nTSAB_TSREQ_P DS  F                     EZATSREQ entry point      RS0100\nTSABCSVT     DS  F                     CSVT pointer              RS0100\n             DS  CL40                                            RS0100\nTSAB_L       EQU *-TSAB                length of TSAB_header     RS0100\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EZAZTSEB": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x19\\x0f\\x01\\x12\\x19\\x0f\\x133\\x00,\\x00,\\x00\\x00\\xe2\\xc8\\xd6\\xe6\\xf7\\xf2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-08T00:00:00", "modifydate": "2012-07-08T13:33:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "SHOW721"}, "text": "         MACRO\n         EZAZTSEB\nTSEB         DS  0H                    one per TCPIP stack       RS0100\n*                                      max 8 entries             RS0100\nTSEBEYEC     DS  CL4                   eyecatcher 'TSEB'         RS0100\nTSEB_Length  DS  H                     length TSEB               RS0100\nTSEB_Version DS  H                     Version of TSAB           RS0100\nTSEB_Access  DS  0H\n             ORG TSEB_Access\nTSEB_Flags   DS  0H\nTSEB_Status  DS  X                     IP-Status                 RS0100\nTSEB_ACTIVE  EQU X'80'                 Active\nTSEB_TERM    EQU X'40'                 Terminating\nTSEB_DOWN    EQU X'20'                 Down\nTSEB_STOP    EQU X'10'                 Stoped\n             DS  CL3                   more flags\n             DS  F                     ?\nTSEB_TcpIp_Name DS  CL8                Name of TCPIP stack\nTSEB_SI      DS  X                     ?\n             DS  C                     ?\nTSEB_TCPIP_Version DS  XL2             Version (internal)\n*                                      X'0302' TCP V3R2\n*                                      X'0305' TCP V3R5 OS V2R6\nTSEB_Tsdb    DS  F                     TSDB pointer              RS0100\nTSEB_Lx      DS  F                     Lx\nTSEB_TCA     DS  F                     TCA pointer               RS0100\nTSEB_TRACE   DS  F                     Trace Settings            RS0100\nTSEB_Pvg_Addr DS  F                    ?\nTSEB_Pvg_Len DS  F                     ?\nTSEB_Events  DS  F                     ?\nTSEB_Asid    DS  H                     TCPIP Asid\n             DS CL2\nTSEB_SAddr   DS  F                     ?\nTSEB_EAddr   DS  F                     ?\nTSEB_Stream_Op DS F                    pointer to EZBSKSTO\nTSEB_EZBITDCR  DS F                    pointer to EZBITDCR\nTSEB_itCvt     DS F                    itCvt-pointer\nTSEB_s_Flags   DS F\nTSEB_Duaf      DS F\nTSEB_TokenId   DS F\nTSEB_Tcmt      DS F                    TCMT-Pointer\nTSEB_COM_Len   DS F\n               DS 7F                   ?\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FINDSTR": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x13\"\\x7f\\x01\\x13\"\\x7f\\x11\\'\\x00R\\x00R\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-15T00:00:00", "modifydate": "2013-08-15T11:27:52", "lines": 82, "newlines": 82, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Search a dataset for a string from JCL using *grep*\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     12/11/2006 11:08 AM\n\nHow large is the input dataset?  A quick and dirty REXX EXEC could\naccomplish this easily.\n\n/****************************** REXX *********************************/\n/*  Purpose: Find a string and put in the OUTPUT dataset             */\n/*-------------------------------------------------------------------*/\n/*  Syntax:  FINDSTR string                                          */\n/*-------------------------------------------------------------------*/\n/*  Parms: STRING     - Any string                                   */\n/*                                                                   */\n/*  Notes: RC      00 - Everything worked                            */\n/*                 12 - TSO command error                            */\n/*                 13 - INPUT read  error                            */\n/*                 14 - OUTPUT write error                           */\n/*                                                                   */\n/*  Sample JCL:                                                      */\n/*                                                                   */\n/*   //FINDSTR  EXEC PGM=IKJEFT01,PARM='FINDSTR  ALLOC'              */\n/*   //SYSEXEC   DD   DSN=your.rexx.pds,DISP=SHR                     */\n/*   //INPUT     DD   DSN=your.input,DISP=SHR                        */\n/*   //OUTPUT    DD   DSN=your.output,DISP=(,CATLG),REFDD=*.INPUT,   */\n/*   //          DSORG=PS,SPACE=(TRK,(1,20))                         */\n/*   //SYSTSPRT  DD   SYSOUT=*                                       */\n/*   //SYSTSIN   DD   DUMMY                                          */\n/*                                                                   */\n/*********************************************************************/\n/*   Change  Log                                                     */\n/*                                                                   */\n/*   Author       Date      Reason                                   */\n/*  --------     ---------  ---------------------------------------- */\n/*  R. Zenuk     Dec 2006   Initial Creation                         */\n/*                                                                   */\n/*********************************************************************/\n/*  Accept input string                                              */\n/*********************************************************************/\nparse  arg string\nsay 'Search string:'  string\n/*********************************************************************/\n/*  Read input file into the input stem                              */\n/*********************************************************************/\n\"EXECIO  * DISKR INPUT (STEM INPUT. FINIS\"\nif RC <> 0 then exit 13\nilrc =  listdsi('INPUT' 'FILE')\nsay input.0 'records found in the INPUT dataset'  sysdsname\n/*********************************************************************/\n/*  Loop through all the input records                               */\n/*********************************************************************/\no  = 0\ndo i=1 to  input.0\n/*********************************************************************/\n/*  Exclude all comments (REXX and *)                                */\n/*********************************************************************/\nif left(strip(input.i),2) <> '/*' &,\nleft(strip(input.i),1) <> '*'  then\ndo\n/*********************************************************************/\n/*  Match all records using the pos built-in and copy to output stem */\n/*********************************************************************/\nif pos(string,input.i) <> 0 then\ndo\no = o  + 1\noutput.o = input.i\nend\nend\nend\n/*********************************************************************/\n/*  Write all the matching records from the output stem              */\n/*********************************************************************/\n\"EXECIO  * DISKW OUTPUT (STEM OUTPUT. FINIS\"\nif RC <> 0 then exit 14\nolrc =  listdsi('OUTPUT' 'FILE')\nsay o 'matching records written to the OUTPUT  dataset' sysdsname\nexit 0\n\n\nHope This Helps,\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETSTAC@": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x13\"o\\x01\\x13\"o\\x12\\x01\\x00*\\x00*\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T12:01:34", "lines": 42, "newlines": 42, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Getting the name of the TCPIP stack with affinity\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     8/17/2008 7:25 PM\n\nI found this code in an ISPF/CS article that chases down the TSEB\nand lists all the stacks found.\n\n  http://gsf-soft.com/Documents/ISPF-CS.html\n\nCVT-->ECVT-->TSAB-->TSEB\n\n/* REXX - GETSTACK */\ncvt  =  c2d(storage(10,4))\necvt = c2d(storage(d2x(cvt+140),4))\ntsab =  c2d(storage(d2x(ecvt+176),4))\ndo i=1 to  8\ntseb = tsab + 64 +  (i-1)*128\nsay  'Stack' i  storage(d2x(tseb+16),8)\nend\n\nHowever, I could not find the mapping macros for the TSAB or the\nTSEB.  Hopefully, they can identify which stack is being used by\nthe address space...\n\nNote from SBG:  These macros are supplied from CBT File 492\n                which is the SHOWzOS macro library.\n                EZAZTSAB and EZAZTSEB.\nRob\n\nIn a message dated 8/15/2008 4:43:18 P.M. US Mountain Standard Time,\nkirk@dovetail.com writes:\n\nThanks, but I don't think that any of these calls get the current\nstack (aka \"image\") name.\n\nFWIW - getibmopt() seems promising - it returns an array of the\ncurrent stack names on the system.  Unfortunately, it doesn't\nseem to indicate which stack is the current/default stack for the\nprocess.\n\nKirk\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETSTACK": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x13\"o\\x01\\x13\"o\\x000\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T00:30:12", "lines": 8, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "/* REXX - GETSTACK */    /* Care of Gilbert Saint-flour */\ncvt  =  c2d(storage(10,4))\necvt = c2d(storage(d2x(cvt+140),4))\ntsab =  c2d(storage(d2x(ecvt+176),4))\ndo i=1 to  8\ntseb = tsab + 64 +  (i-1)*128\nsay  'Stack' i  storage(d2x(tseb+16),8)\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MNTCKDOC": {"ttr": 1043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x13\"\\x8f\\x01\\x13\"\\x8f\\x13)\\x00E\\x00E\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-16T00:00:00", "modifydate": "2013-08-16T13:29:16", "lines": 69, "newlines": 69, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: NFS Mount\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     10/12/2007 12:07 PM\n\nWe have what we consider to be a large number of NFS mounts (in\nthe hundreds with thousands of users).  We had a strategic project\nto eliminate NDM and use NFS for all internal transfers.\nThousands of batch jobs were affected.  We found it much more\nconvenient to mount using a process outside of BPXPRMxx.  Since we\nhave so many users of NFS the change and IPL rate was going to be\nway too high.  Additionally, the operational need to dynamically\nmount, unmount/remount due to stale mounts, unanticipated network\nissues and planned NAS maintenance pushed us into developing a\nbatch utility that we had all develolpers incorporate in every NFS\nbatch job.\n\nThe REXX utility is called MNTCHECK.  It has grown from an\noriginal 200 line EXEC to almost 2000 lines.  Its original\npurpose was simply to check to see if the requested mount was in\nthe mount table.  If so, simply return RC=0 and exit.  If the\nmount was missing, it would use the input in the required MOUNT\nDD to execute the supplied mount command and return RC=0 if it\nworked and RC=???  if it didn't.  If it failed, there was an\nattempt to explain in English what the problem was.\n\nAs expected very few mainframe folks are NFS aware.  The chore of\nwriting a successful and standardized MOUNT command was too much\nfor the average programmer (even with training and\ndocumentation).  After seeing a gazillion different ways people\ncoded mount commands, we had to do something.  MNTCHECK evolved\nto enforce our standards (regardless of what the user coded).\nThe utility also evovled to do extensive testing to determine if\nthe mount was capable of being successful (ping the server,\nconfirm the mount point directory existed, confirm the user had\nthe correct permission, confirm the target directory on the NAS\nexists, confirm the correct permission are in place to access it,\nconfirm the /etc/exports contains the directory (or root),\nconfirm the /etc/netgroup contains the group (if used) and a few\nothers I am sure I am forgetting.\n\nThe bottom-line, is this approach has given us tremendous\nflexibility in our mainframe NFS inplementation.  We can unmount\nany NFS mount at anytime it is not in use and the next job\nrequiring the mount will remount it.  We have our weekly unmount\njob that runs during a specific time when we tend to coordinate\nmainframe and NAS maintenance so things are cleanly decoupled.\n\nDuring the IPL, we also have a started task that runs that can\nmount all NFS mounts required very early in the IPL process\n(usually by other STC's).  This STC is another REXX EXEC that\nsimply reads a PDS full of mount commands and executes the same\nMNTCHECK utility against each member.\n\nHope This Helps,\n\nRob\n\n------------------------------------------------------------------\n\nIn a message dated 10/12/2007 6:20:09 AM US Mountain Standard Time,\nrogerske@us.ibm.com writes:\n\nA client wants to mount a shared disk of their Windows LAN to USS\nin Read/Write mode.  I am pretty sure they can do this, but I was\nwondering if it was better to put the mount in BPXPRMxx or a\noperations automation process, after IPL?  Where is the best\nplace to learn NFS set up?  The Redbook links I tried today were\nall broken.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MVSREXX": {"ttr": 1282, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x13\"\\x7f\\x01\\x13\"\\x7f\\x00\\x07\\x00\\\\\\x00\\\\\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-15T00:00:00", "modifydate": "2013-08-15T00:07:05", "lines": 92, "newlines": 92, "modlines": 0, "user": "SBGOLOB"}, "text": "In a message dated 1/9/2007 6:49:18 PM US Mountain Standard Time,\nkirk@dovetail.com writes:\n\nWhat I can't do is call the TSO/E-address-space-only function LISTDSI.\nLISTD with outtrap works under ADDRESS TSO in USS however, but I don't\nthink that I can distinguish a true PDSE.  Any other ideas and\ntechniques would be appreciated.\n\n-----------------------------------------------------------------------\n\nSubject:  Re: Checking for loadmodule PDSE from USS REXX shell script\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     1/9/2007 11:45 PM\n\nHere is a technique that has worked for me.  On the USS side, I\nhave a REXX EXEC that lets me use TSO services on the MVS side.\n\n/*                              REXX                                 */\n/* Purpose: Execute an MVS REXX EXEC from the USS  side              */\n/*-------------------------------------------------------------------*/\n/*  Syntax: mvsrexx dsn mem  parms                                   */\n/*-------------------------------------------------------------------*/\n/*  Parms: dsn        - REXX EXEC PDS to allocate  to SYSEXEC        */\n/*         mem        - The REXX EXEC to  execute                    */\n/*         parms      - Parms to pass to the  EXEC                   */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   -----------------------------------------*/\n/*  R.  Zenuk    Oct 2002   Initial  Creation                        */\n/*                                                                   */\n/*********************************************************************/\n/*  Accept DSN, MEM and  PARMS                                       */\n/*********************************************************************/\nparse  arg dsn mem  parms\ndsn =  translate(dsn)\nmem =  translate(mem)\n/*********************************************************************/\n/*  Display a startup  message                                       */\n/*********************************************************************/\nsay  'EXEC:' mem 'executing from:' dsn 'using parms:'  parms\n/*********************************************************************/\n/*  Address the SHELL to ALLOC SYSEXEC and execute the TSO command   */\n/*********************************************************************/\naddress  'SH'  'TSOALLOC=SYSEXEC',\n'SYSEXEC=\"ALLOC  DSN('''dsn''') SHR REUSE  MSG(2)\"',\n'tso \"%'mem  parms'\"'\nEXITRC =  RC\n/*********************************************************************/\n/*  Display a shutdown  message                                      */\n/*********************************************************************/\nshutdown:  say 'EXEC:' mem 'executed from:' dsn  'RC='EXITRC\n            exit(EXITRC)\n\nThis allocates a REXX PDS on the MVS side and identifies an EXEC\nto run and passes the required parms to the EXEC.  In this\nexample, I am executing an EXEC called LISTDSI that (you guessed\nit) runs LISTDSI.  Here is the LISTDSI EXEC:\n\n/* rexx  */\narg  dsn\ndsn =  \"'\"dsn\"'\"\nx =  listdsi(dsn)\nsay  sysdsname\nsay  sysvolume\nsay  syscreate\nsay sysdsorg  sysdssms\nsay dsn sysextents sysseconds sysunits sysalloc sysprimary\n\nHere is the output from the Putty session where I ran it:\n\n\n$ mvsrexx.rex my.exec listdsi my.pdse\nEXEC: LISTDSI executing from:  MY.EXEC using parms: opsroz.pdse\nIGD01008I DEFAULT STORAGE  CLASS\n\nIGD01010I DEFAULT STORAGE GROUP  ASSIGNED\n\n%LISTDSI my.pdse\nMY.PDSE\nTTS912\n2007/009\nPO LIBRARY\n'MY.PDSE'  1 1 CYLINDER 1 1\nEXEC: LISTDSI executed from: MY.EXEC RC=0\n$\n\nHope  This Helps,\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSSPLI@": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00I\\x01\\x13\"_\\x01\\x13\"_\\x15\\x08\\x04\\xb1\\x04\\xb3\\x00\\x00\\xd9\\xe9\\xc5\\xd5\\xe4\\xd2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-08-13T00:00:00", "modifydate": "2013-08-13T15:08:49", "lines": 1201, "newlines": 1203, "modlines": 0, "user": "RZENUK"}, "text": "Splitting PDSs\n\n\n\n//jobcard\u009f\n//***************************************************************\n//* SPLIT A PDS                                                 *\n//*                                                             *\n//* OPTION=ALPHA     1 DSN FOR EACH UNIQUE FIRST CHARACTER OF   *\n//*                  THE MEMBER NAME                            *\n//* OPTION=EVEN      SPLIT INTO 10 EQUAL DSNS (SAME AS EVEN 10) *\n//* OPTION='EVEN NN' SPLIT INTO 'NN' EQUAL DSNS                 *\n//* OPTION=NN        SPLIT INTO DSNS EACH HOLDING NN MEMBERS    *\n//***************************************************************\n//PDSSPLIT PROC\n//PDSSPLIT EXEC PGM=IKJEFT01,DYNAMNBR=99,PARM='PDSSPLIT &OPTION'\n//SYSEXEC  DD   DSN=yourid.EXEC,DISP=SHR\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   DUMMY\n//DIAGMSGS DD   SYSOUT=*\n//INPUT    DD   DSN=&PDS,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//         PEND\n//ALPHA    EXEC PDSSPLIT,PDS=yourid.JCL,OPTION=ALPHA\n//EVEN10   EXEC PDSSPLIT,PDS=yourid.JCL,OPTION=EVEN\n//EVEN3    EXEC PDSSPLIT,PDS=yourid.JCL,OPTION='EVEN 3'\n//P100     EXEC PDSSPLIT,PDS=yourid.JCL,OPTION=100\n\n\nJOBNAME        PDSSPLIT started 23 Sep 2004 22:54:30 on SY01        JOBNAME\n\n    6 $* members copied to YOURID.@001$006.YOURID.JCL RC=0\n    1 #* members copied to YOURID.@002#001.YOURID.JCL RC=0\n   25 @* members copied to YOURID.@003@025.YOURID.JCL RC=0\n    7 A* members copied to YOURID.@004A007.YOURID.JCL RC=0\n   20 B* members copied to YOURID.@005B020.YOURID.JCL RC=0\n   44 C* members copied to YOURID.@006C044.YOURID.JCL RC=0\n   48 D* members copied to YOURID.@007D048.YOURID.JCL RC=0\n   13 E* members copied to YOURID.@008E013.YOURID.JCL RC=0\n    8 F* members copied to YOURID.@009F008.YOURID.JCL RC=0\n    6 G* members copied to YOURID.@010G006.YOURID.JCL RC=0\n    4 H* members copied to YOURID.@011H004.YOURID.JCL RC=0\n   24 I* members copied to YOURID.@012I024.YOURID.JCL RC=0\n    6 J* members copied to YOURID.@013J006.YOURID.JCL RC=0\n    1 K* members copied to YOURID.@014K001.YOURID.JCL RC=0\n   16 L* members copied to YOURID.@015L016.YOURID.JCL RC=0\n   20 M* members copied to YOURID.@016M020.YOURID.JCL RC=0\n   19 N* members copied to YOURID.@017N019.YOURID.JCL RC=0\n   15 P* members copied to YOURID.@018P015.YOURID.JCL RC=0\n    3 Q* members copied to YOURID.@019Q003.YOURID.JCL RC=0\n   24 R* members copied to YOURID.@020R024.YOURID.JCL RC=0\n   50 S* members copied to YOURID.@021S050.YOURID.JCL RC=0\n   27 T* members copied to YOURID.@022T027.YOURID.JCL RC=0\n    2 U* members copied to YOURID.@023U002.YOURID.JCL RC=0\n    4 V* members copied to YOURID.@024V004.YOURID.JCL RC=0\n    7 W* members copied to YOURID.@025W007.YOURID.JCL RC=0\n    4 X* members copied to YOURID.@026X004.YOURID.JCL RC=0\n    1 Y* members copied to YOURID.@027Y001.YOURID.JCL RC=0\n   24 Z* members copied to YOURID.@028Z024.YOURID.JCL RC=0\n\n  429 members copied\n   28 datasets created\n\n JOBNAME    PDSSPLIT ended 23 Sep 2004 22:54:38 8.5 on SY01 RC=0      JOBNAME\n\n\nJOBNAME        PDSSPLIT started 23 Sep 2004 22:54:38 on SY01        JOBNAME\n\n   43 members copied to YOURID.@001#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@002#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@003#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@004#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@005#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@006#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@007#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@008#043.YOURID.JCL RC=0\n   43 members copied to YOURID.@009#043.YOURID.JCL RC=0\n   42 members copied to YOURID.@010#042.YOURID.JCL RC=0\n\n  429 members copied\n   10 datasets created\n\n JOBNAME    PDSSPLIT ended 23 Sep 2004 22:54:42 3.8 on SY01 RC=0      JOBNAME\n\n\nJOBNAME        PDSSPLIT started 23 Sep 2004 22:54:44 on SY01        JOBNAME\n\n 100 members copied to YOURID.@001#100.YOURID.JCL RC=0\n 100 members copied to YOURID.@002#100.YOURID.JCL RC=0\n 100 members copied to YOURID.@003#100.YOURID.JCL RC=0\n 100 members copied to YOURID.@004#100.YOURID.JCL RC=0\n  29 members copied to YOURID.@005#029.YOURID.JCL RC=0\n\n 429 members copied\n   5 datasets created\n\nJOBNAME    PDSSPLIT ended 23 Sep 2004 22:54:47 2.5 on SY01 RC=0      JOBNAME\n\n\n/****************************** REXX *********************************/\n/* Purpose: Copy a PDS to multiple output PDSs based on criteria     */\n/*                                                                  */\n/* Syntax:  pdssplit criteria                                        */\n/*                                                                  */\n/* Parms: approach   - number or ALPHA or EVEN                       */\n/*                                                                   */\n/* Use a number to create multiple PDSs with that number of members  */\n/* Use ALPHA to create a PDS for each letter of the alphabet         */\n/* Use EVEN nn to create nn PDSs with an even portion of members     */\n/*                                                                   */\n/* Known issue: a single member copy does not work (creates PS DSN?) */\n/*********************************************************************/\n/*                      Change Log                                   */\n/*                                                                   */\n/*  Author       Date      Reason                                    */\n/*                                                             */\n/*                                                                   */\n/*********** @REFRESH BEGIN START    2004/03/06 13:16:32 *************/\n/* Standard housekeeping activities                                  */\n/*********************************************************************/\n call time 'r'\n parse arg parms\n signal on syntax name trap\n signal on failure name trap\n signal on novalue name trap\n probe = 'NONE'\n modtrace = 'NO'\n modspace = ''\n call stdentry 'DIAGMSGS'\n module = 'MAINLINE'\n push trace() time('L') module 'From:' 0 'Parms:' parms\n if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n call modtrace 'START' 0\n/*********************************************************************/\n/* Set local estoeric names                                          */\n/*********************************************************************/\n @vio   = 'VIO'\n @sysda = 'SYSDA'\n/*********** @REFRESH END   START    2004/03/06 13:16:32 *************/\n/* Accept and validate parms                                         */\n/*********************************************************************/\n arg parm evencount .\n if parm = '' then\n    parm = 'ALPHA'\n select\n   when datatype(parm,'W') = 1 then parm = parm\n   when parm = 'ALPHA' then parm = 'ALPHA'\n   when parm = 'EVEN' then\n        do\n         parm = 'EVEN'\n         if evencount = '' then evencount = 10\n        end\n   otherwise\n      call rcexit 20 'Invalid parm:' parm', whole number, \"ALPHA\"',\n          'or \"EVEN\"'\n end\n call saydd msgdd 1 'Parm used:' parm\n/*********************************************************************/\n/* Make sure the INPUT DD exists                                     */\n/*********************************************************************/\n call ddcheck 'INPUT'\n source = sysdsname\n/*********************************************************************/\n/* Set initial defaults                                              */\n/*********************************************************************/\n totcount = 0\n check = 1\n last = ''\n sets = -1\n/*********************************************************************/\n/* Get member names from the PDS                                     */\n/*********************************************************************/\n call outtrap 'mem.'\n\"LISTDS '\"source\"' MEMBERS\"\n x = outtrap('off')\n/*********************************************************************/\n/* Set option specific defaults                                      */\n/*********************************************************************/\n select\n   when parm = 'ALPHA' then mcount = 0\n   when parm = 'EVEN' then\n        do\n         parm = format(((mem.0-7)/evencount),,0)\n         mcount = parm + 1\n        end\n   otherwise mcount = parm + 1\n end\n/*********************************************************************/\n/* Process the members                                               */\n/*********************************************************************/\n do i=7 to mem.0\n    totcount = totcount + 1\n    member = strip(mem.i)\n/*********************************************************************/\n/* Process ALPHA                                                     */\n/*********************************************************************/\n    if parm = 'ALPHA' then\n       do\n        char1 = substr(member,1,1)\n        if char1 = last then\n           do\n            mcount = mcount + 1\n            sysin.mcount = cont('                 'member',')\n           end\n        else\n           do\n            sets = sets + 1\n            if i <> 7 then\n               do\n                target = dsalloc(source right(sets,3,0),\n                         right(mcount-1,3,0) parm mem.0-7)\n                say right(mcount-1,4) last'* members copied to' target,\n                   'RC='copymem(source target)\n               end\n            sysin.1  = '  COPY INDD=SOURCE,OUTDD=TARGET'\n            sysin.2  = cont('  SELECT MEMBER=('member',')\n            last = char1\n            mcount = 2\n           end\n       end\n/*********************************************************************/\n/* Process Numeric and EVEN                                          */\n/*********************************************************************/\n    if datatype(parm,'W') = 1 then\n       do\n        if mcount <= parm then\n           do\n            mcount = mcount + 1\n            sysin.mcount = cont('                 'member',')\n           end\n        else\n           do\n            sets = sets + 1\n            if i <> 7 then\n               do\n                target = dsalloc(source right(sets,3,0),\n                         right(mcount-1,3,0) parm mem.0-7)\n                say right(mcount-1,4) 'members copied to' target,\n                   'RC='copymem(source target)\n               end\n            sysin.1  = '  COPY INDD=SOURCE,OUTDD=TARGET'\n            sysin.2  = cont('  SELECT MEMBER=('member',')\n            mcount = 2\n           end\n       end\n end\n/*********************************************************************/\n/* Process the last group                                            */\n/*********************************************************************/\n sets = sets + 1\n target = dsalloc(source right(sets,3,0),\n          right(mcount-1,3,0) parm mem.0-7)\n if parm = 'ALPHA' then\n    say right(mcount-1,4) last'* members copied to' target,\n       'RC='copymem(source target)\n else\n    say right(mcount-1,4) 'members copied to' target,\n       'RC='copymem(source target)\n/*********************************************************************/\n/* Print stats                                                       */\n/*********************************************************************/\n say\n say right(totcount,4) 'members copied'\n say right(sets,4) 'datasets created'\n/*********************************************************************/\n/* Shutdown                                                          */\n/*********************************************************************/\n shutdown: nop\n/*********************************************************************/\n/* Put unique shutdown logic before the call to stdexit              */\n/*********** @REFRESH BEGIN STOP     2002/08/03 08:42:33 *************/\n/* Shutdown message and terminate                                    */\n/*********************************************************************/\n           call stdexit time('e')\n/*********** @REFRESH END   STOP     2002/08/03 08:42:33 *************/\n/* Internal Subroutines - not refreshable                            */\n/*                                                                   */\n/* DSALLOC  - Allocate the new DSN                                   */\n/* COPYMEM  - Invoke IEBCOPY to copy members                         */\n/* CONT     - Append line with a continuation in column 72           */\n/*                                                                   */\n/*********************************************************************/\n/* DSALLOC  - Allocate the new DSN                                   */\n/*********************************************************************/\n dsalloc: arg olddsn num memnum parm totmem\n          if parm = 'ALPHA' then\n             clonetype = last\n          else\n             clonetype = '#'\n          newdsn = userid()'.@'num||clonetype||memnum'.'olddsn\n          dirblks = format(memnum/4,,0)\n          pmem = memnum/totmem\n          prispace = format(pmem*(sysused/sysblkstrk/systrkscyl),,0)\n          if prispace = 0 then prispace = 1\n          secspace = prispace * 5\n          if sysrecfm = 'U' then\n             do\n              call tsotrap \"ALLOC F(CLONE) DA(\"qdsn(newdsn)\")\",\n                           \"LIKE(\"qdsn(olddsn)\") DIR(\"dirblks\")\",\n                           \"SPACE(\"prispace secspace\") CYLINDERS\",\n                           \"BLKSIZE(\"sysblksize\")\"\n             end\n           else\n             do\n              call tsotrap \"ALLOC F(CLONE) DA(\"qdsn(newdsn)\")\",\n                           \"LIKE(\"qdsn(olddsn)\") DIR(\"dirblks\")\",\n                           \"SPACE(\"prispace secspace\") CYLINDERS\",\n                           \"LRECL(\"syslrecl\") BLKSIZE(\"sysblksize\")\"\n             end\n          call tsotrap \"FREE F(CLONE)\"\n          return newdsn\n/*********************************************************************/\n/* COPYMEM  - Invoke IEBCOPY to copy members                         */\n/*********************************************************************/\n copymem: arg olddsn newdsn\n          close = mcount + 1\n          sysin.close = '                )'\n          call tsotrap \"ALLOC F(SOURCE) DA(\"qdsn(olddsn)\") SHR REUSE\"\n          call tsotrap \"ALLOC F(TARGET) DA(\"qdsn(newdsn)\") SHR REUSE\"\n          call viodd 'SYSIN'\n          address TSO \"CALL *(IEBCOPY)\"\n          call rcexit RC 'IEBCOPY error copying' olddsn 'to' newdsn\n          call tsotrap \"FREE F(SOURCE TARGET SYSIN)\"\n          drop sysin.\n          return 0\n/*********************************************************************/\n/* CONT     - Append line with a continuation in column 72           */\n/*********************************************************************/\n cont: parse arg string\n       contstring = string copies(' ',70-length(string))||'X'\n       return contstring\n/*********** @REFRESH BEGIN SUBBOX   2004/03/10 01:25:03 *************/\n/*                                                                   */\n/* 20 Internal Subroutines provided in PDSSPLIT                      */\n/*                                                                   */\n/* Last Subroutine REFRESH was 29 Jul 2004 20:55:33                  */\n/*                                                                   */\n/* RCEXIT   - Exit on non-zero return codes                          */\n/* TRAP     - Issue a common trap error message using rcexit         */\n/* ERRMSG   - Build common error message with failing line number    */\n/* STDENTRY - Standard Entry logic                                   */\n/* STDEXIT  - Standard Exit logic                                    */\n/* MSG      - Determine whether to SAY or ISPEXEC SETMSG the message */\n/* DDCHECK  - Determine whether a required DD is allocated           */\n/* DDLIST   - Returns number of DDs and populates DDLIST variable    */\n/* DDDSNS   - Returns number of DSNs in a DD and populates DDDSNS    */\n/* QDSN     - Make sure there are only one set of quotes             */\n/* TSOTRAP  - Capture the output from a TSO command in a stem        */\n/* SAYDD    - Print messages to the requested DD                     */\n/* JOBINFO  - Get job-related data from control blocks               */\n/* PTR      - Pointer to a storage location                          */\n/* STG      - Return the data from a storage location                */\n/* VIODD    - EXECIO a stem into a sequential dataset                */\n/* MODTRACE - Module Trace                                           */\n/*                                                                   */\n/*********** @REFRESH END   SUBBOX   2004/03/10 01:25:03 *************/\n/*********** @REFRESH BEGIN RCEXIT   2003/05/14 12:24:50 *************/\n/* RCEXIT   - Exit on non-zero return codes                          */\n/*                                                                  */\n/* EXITRC   - Return code to exit with (if non zero)                 */\n/* ZEDLMSG  - Message text for it with for non zero EXITRC's         */\n/*********************************************************************/\n rcexit: parse arg EXITRC zedlmsg\n         if EXITRC <> 0 then\n            do\n             trace 'o'\n/*********************************************************************/\n/* If execution environment is ISPF then VPUT ZISPFRC                */\n/*********************************************************************/\n             if execenv = 'TSO' | execenv = 'ISPF' then\n                do\n                 if ispfenv = 'YES' then\n                    do\n                     zispfrc = EXITRC\n/*********************************************************************/\n/* Does not call ISPWRAP to avoid obscuring error message modules    */\n/*********************************************************************/\n                     address ISPEXEC \"VPUT (ZISPFRC)\"\n                    end\n                end\n/*********************************************************************/\n/* If a message is provided, wrap it in date, time and EXITRC        */\n/*********************************************************************/\n             if zedlmsg <> '' then\n                do\n                 zedlmsg = time('L') execname zedlmsg 'RC='EXITRC\n                 call msg zedlmsg\n                end\n/*********************************************************************/\n/* Write the contents of the Parentage Stack                         */\n/*********************************************************************/\n             stacktitle = 'Parentage Stack Trace ('queued()' entries):'\n/*********************************************************************/\n/* Write to MSGDD if background and MSGDD exists                     */\n/*********************************************************************/\n             if tsoenv = 'BACK' then\n                do\n                 if subword(zedlmsg,9,1) = msgdd then\n                    do\n                     say zedlmsg\n                     signal shutdown\n                    end\n                 else\n                    do\n                     call saydd msgdd 1 zedlmsg\n                     call saydd msgdd 1 stacktitle\n                    end\n                end\n             else\n/*********************************************************************/\n/* Write to the ISPF Log if foreground                               */\n/*********************************************************************/\n                do\n                 zerrlm = zedlmsg\n                 address ISPEXEC \"LOG MSG(ISRZ003)\"\n                 zerrlm = center(' 'stacktitle' ',78,'-')\n                 address ISPEXEC \"LOG MSG(ISRZ003)\"\n                end\n/*********************************************************************/\n/* Unload the Parentage Stack                                        */\n/*********************************************************************/\n             do queued()\n                pull stackinfo\n                if tsoenv = 'BACK' then\n                   do\n                    call saydd msgdd 0 stackinfo\n                   end\n                else\n                   do\n                    zerrlm = stackinfo\n                    address ISPEXEC \"LOG MSG(ISRZ003)\"\n                   end\n             end\n/*********************************************************************/\n/* Put a terminator in the ISPF Log for the Parentage Stack          */\n/*********************************************************************/\n             if tsoenv = 'FORE' then\n                do\n                 zerrlm = center(' 'stacktitle' ',78,'-')\n                 address ISPEXEC \"LOG MSG(ISRZ003)\"\n                end\n/*********************************************************************/\n/* Signal SHUTDOWN.  SHUTDOWN label MUST exist in the program        */\n/*********************************************************************/\n             signal shutdown\n            end\n         else\n            return\n/*********** @REFRESH END   RCEXIT   2003/05/14 12:24:50 *************/\n/*********** @REFRESH BEGIN TRAP     2002/08/07 11:48:14 *************/\n/* TRAP     - Issue a common trap error message using rcexit         */\n/*                                                                  */\n/* PARM     - N/A                                                    */\n/*********************************************************************/\n trap: traptype = condition('C')\n       if traptype = 'SYNTAX' then\n          msg = errortext(RC)\n       else\n          msg = condition('D')\n       trapline = strip(sourceline(sigl))\n       msg = traptype 'TRAP:' msg', Line:' sigl '\"'trapline'\"'\n       call rcexit 666 msg\n/*********** @REFRESH END   TRAP     2002/08/07 11:48:14 *************/\n/*********** @REFRESH BEGIN ERRMSG   2002/08/10 16:53:04 *************/\n/* ERRMSG   - Build common error message with failing line number    */\n/*                                                                  */\n/* ERRLINE  - The failing line number passed by caller from SIGL     */\n/* TEXT     - Error message text passed by caller                    */\n/*********************************************************************/\n errmsg: nop\n         parse arg errline text\n         return 'Error on statement' errline',' text\n/*********** @REFRESH END   ERRMSG   2002/08/10 16:53:04 *************/\n/*********** @REFRESH BEGIN STDENTRY 2004/04/07 19:17:48 *************/\n/* STDENTRY - Standard Entry logic                                   */\n/*                                                                  */\n/* MSGDD    - Optional MSGDD used only in background                 */\n/*********************************************************************/\n stdentry: module = 'STDENTRY'\n           if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n           parse arg sparms\n           push trace() time('L') module 'From:' sigl 'Parms:' sparms\n           arg msgdd\n           parse upper source . . execname . execdsn . . execenv .\n/*********************************************************************/\n/* Start-up values                                                   */\n/*********************************************************************/\n           EXITRC = 0\n           MAXRC = 0\n           ispfenv = 'NO'\n           popup = 'NO'\n           lockpop = 'NO'\n           headoff = 'NO'\n           hcreator = 'NO'\n           keepstack = 'NO'\n           lpar = mvsvar('SYSNAME')\n           zedlmsg = 'Default shutdown message'\n/*********************************************************************/\n/* Determine environment                                             */\n/*********************************************************************/\n           if substr(execenv,1,3) <> 'TSO' & execenv <> 'ISPF' then\n              tsoenv = 'NONE'\n           else\n              do\n               tsoenv = sysvar('SYSENV')\n               signal off failure\n              \"ISPQRY\"\n               ISPRC = RC\n               if ISPRC = 0 then\n                  do\n                   ispfenv = 'YES'\n/*********************************************************************/\n/* Check if HEADING ISPF table exists already, if so set HEADOFF=YES */\n/*********************************************************************/\n                   call ispwrap \"VGET (ZSCREEN)\"\n                   if tsoenv = 'BACK' then\n                      htable = jobinfo(1)||jobinfo(2)\n                   else\n                      htable = userid()||zscreen\n                   TBCRC = ispwrap(8 \"TBCREATE\" htable \"KEYS(HEAD)\")\n                   if TBCRC = 0 then\n                      do\n                       headoff = 'NO'\n                       hcreator = 'YES'\n                      end\n                   else\n                      do\n                       headoff = 'YES'\n                      end\n                  end\n               signal on failure name trap\n              end\n/*********************************************************************/\n/* MODTRACE must occur after the setting of ISPFENV                  */\n/*********************************************************************/\n           call modtrace 'START' sigl\n/*********************************************************************/\n/* Start-up message (if batch)                                       */\n/*********************************************************************/\n           startmsg = execname 'started' date() time() 'on' lpar\n           if tsoenv = 'BACK' & sysvar('SYSNEST') = 'NO' &,\n              headoff = 'NO' then\n              do\n               jobname = mvsvar('SYMDEF','JOBNAME')\n               jobinfo = jobinfo()\n               parse var jobinfo jobtype jobnum .\n               say jobname center(' 'startmsg' ',61,'-') jobtype jobnum\n               say\n               if ISPRC = -3 then\n                  do\n                   call saydd msgdd 1 'ISPF ISPQRY module not found,',\n                                      'ISPQRY is usually in the LINKLST'\n                   call rcexit 20 'ISPF ISPQRY module is missing'\n                  end\n/*********************************************************************/\n/* If MSGDD is provided, write the STARTMSG and SYSEXEC DSN to MSGDD */\n/*********************************************************************/\n               if msgdd <> '' then\n                  do\n                   call ddcheck msgdd\n                   call saydd msgdd 1 startmsg\n                   call ddcheck 'SYSEXEC'\n                   call saydd msgdd 0 execname 'loaded from' sysdsname\n/*********************************************************************/\n/* If there are PARMS, write them to the MSGDD                       */\n/*********************************************************************/\n                   if parms <> '' then\n                      call saydd msgdd 0 'Parms:' parms\n/*********************************************************************/\n/* If there is a STEPLIB, write the STEPLIB DSN MSGDD                */\n/*********************************************************************/\n                   if listdsi('STEPLIB' 'FILE') = 0 then\n                      do\n                       steplibs = dddsns('STEPLIB')\n                       call saydd msgdd 0 'STEPLIB executables loaded',\n                           'from' word(dddsns,1)\n                       if dddsns('STEPLIB') > 1 then\n                          do\n                           do stl=2 to steplibs\n                              call saydd msgdd 0 copies(' ',31),\n                                   word(dddsns,stl)\n                           end\n                          end\n                      end\n                  end\n              end\n/*********************************************************************/\n/* If foreground, save ZFKA and turn off the FKA display             */\n/*********************************************************************/\n           else\n              do\n               fkaset = 'OFF'\n               call ispwrap \"VGET (ZFKA) PROFILE\"\n               if zfka <> 'OFF' & tsoenv = 'FORE' then\n                  do\n                   fkaset = zfka\n                   fkacmd = 'FKA OFF'\n                   call ispwrap \"CONTROL DISPLAY SAVE\"\n                  call ispwrap \"DISPLAY PANEL(ISPBLANK) COMMAND(FKACMD)\"\n                   call ispwrap \"CONTROL DISPLAY RESTORE\"\n                  end\n              end\n/*********************************************************************/\n           pull tracelvl . module . sigl . sparms\n           call modtrace 'STOP' sigl\n           interpret 'trace' tracelvl\n           return\n/*********** @REFRESH END   STDENTRY 2004/04/07 19:17:48 *************/\n/*********** @REFRESH BEGIN STDEXIT  2003/11/16 22:46:29 *************/\n/* STDEXIT  - Standard Exit logic                                    */\n/*                                                                  */\n/* ENDTIME  - Elapsed time                                           */\n/* Note: Caller must set KEEPSTACK if the stack is valid             */\n/*********************************************************************/\n stdexit: module = 'STDEXIT'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          arg endtime\n          endmsg = execname 'ended' date() time() format(endtime,,1)\n/*********************************************************************/\n/* if MAXRC is greater then EXITRC then set EXITRC to MAXRC          */\n/*********************************************************************/\n          if MAXRC > EXITRC then EXITRC = MAXRC\n          endmsg = endmsg 'on' lpar 'RC='EXITRC\n          if tsoenv = 'BACK' & sysvar('SYSNEST') = 'NO' &,\n             headoff = 'NO' then\n             do\n              say\n              say jobname center(' 'endmsg' ',61,'-') jobtype jobnum\n/*********************************************************************/\n/* Make sure this isn't a MSGDD missing error then log to MSGDD      */\n/*********************************************************************/\n              if msgdd <> '' & subword(zedlmsg,9,1) <> msgdd then\n                 do\n                  call saydd msgdd 1 execname 'ran in' endtime 'seconds'\n                  call saydd msgdd 0 endmsg\n                 end\n             end\n/*********************************************************************/\n/* If foreground, reset the FKA if necessary                         */\n/*********************************************************************/\n          else\n             do\n              if fkaset <> 'OFF' then\n                 do\n                  fkafix = 'FKA'\n                  call ispwrap \"CONTROL DISPLAY SAVE\"\n                  call ispwrap \"DISPLAY PANEL(ISPBLANK) COMMAND(FKAFIX)\"\n                  if fkaset = 'SHORT' then\n                     call ispwrap \"DISPLAY PANEL(ISPBLANK)\",\n                                  \"COMMAND(FKAFIX)\"\n                  call ispwrap \"CONTROL DISPLAY RESTORE\"\n                 end\n             end\n/*********************************************************************/\n/* Clean up the temporary HEADING table                              */\n/*********************************************************************/\n          if ispfenv = 'YES' & hcreator = 'YES' then\n             call ispwrap \"TBEND\" htable\n/*********************************************************************/\n/* Remove STDEXIT and MAINLINE Parentage Stack entries, if there     */\n/*********************************************************************/\n          call modtrace 'STOP' sigl\n          if queued() > 0 then pull . . module . sigl . sparms\n          if queued() > 0 then pull . . module . sigl . sparms\n          if tsoenv = 'FORE' & queued() > 0 & keepstack = 'NO' then\n             pull . . module . sigl . sparms\n/*********************************************************************/\n/* if the Parentage Stack is not empty, display its contents         */\n/*********************************************************************/\n          if queued() > 0 & keepstack = 'NO' then\n             do\n              say queued() 'Leftover Parentage Stack Entries:'\n              say\n              do queued()\n                 pull stackundo\n                 say stackundo\n              end\n              EXITRC = 1\n             end\n/*********************************************************************/\n/* Exit                                                              */\n/*********************************************************************/\n          exit(EXITRC)\n/*********** @REFRESH END   STDEXIT  2003/11/16 22:46:29 *************/\n/*********** @REFRESH BEGIN MSG      2002/09/11 01:35:53 *************/\n/* MSG      - Determine whether to SAY or ISPEXEC SETMSG the message */\n/*                                                                  */\n/* ZEDLMSG  - The long message variable                              */\n/*********************************************************************/\n msg: module = 'MSG'\n      parse arg zedlmsg\n      if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n      parse arg sparms\n      push trace() time('L') module 'From:' sigl 'Parms:' sparms\n      call modtrace 'START' sigl\n/*********************************************************************/\n/* If this is background or OMVS use SAY                             */\n/*********************************************************************/\n      if tsoenv = 'BACK' | execenv = 'OMVS' then\n         say zedlmsg\n      else\n/*********************************************************************/\n/* If this is foreground and ISPF is available, use SETMSG           */\n/*********************************************************************/\n         do\n          if ispfenv = 'YES' then\n/*********************************************************************/\n/* Does not call ISPWRAP to avoid obscuring error message modules    */\n/*********************************************************************/\n             address ISPEXEC \"SETMSG MSG(ISRZ000)\"\n          else\n             say zedlmsg\n         end\n      pull tracelvl . module . sigl . sparms\n      call modtrace 'STOP' sigl\n      interpret 'trace' tracelvl\n      return\n/*********** @REFRESH END   MSG      2002/09/11 01:35:53 *************/\n/*********** @REFRESH BEGIN DDCHECK  2002/09/11 01:08:30 *************/\n/* DDCHECK  - Determine if a required DD is allocated                */\n/*                                                                  */\n/* DD       - DDNAME to confirm                                      */\n/*********************************************************************/\n ddcheck: module = 'DDCHECK'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          arg dd\n          dderrmsg = 'OK'\n          LRC = listdsi(dd \"FILE\")\n/*********************************************************************/\n/* Allow sysreason=3 to verify SYSOUT DD statements                  */\n/*********************************************************************/\n          if LRC <> 0 & strip(sysreason,'L',0) <> 3 then\n             do\n              dderrmsg = errmsg(sigl 'Required DD' dd 'is missing')\n              call rcexit LRC dderrmsg sysmsglvl2\n             end\n          pull tracelvl . module . sigl . sparms\n          call modtrace 'STOP' sigl\n          interpret 'trace' tracelvl\n          return\n/*********** @REFRESH END   DDCHECK  2002/09/11 01:08:30 *************/\n/*********** @REFRESH BEGIN DDLIST   2002/12/15 04:54:32 *************/\n/* DDLIST   - Returns number of DDs and populates DDLIST variable    */\n/*                                                                  */\n/* N/A      - None                                                   */\n/*********************************************************************/\n ddlist: module = 'DDLIST'\n         if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n         parse arg sparms\n         push trace() time('L') module 'From:' sigl 'Parms:' sparms\n         call modtrace 'START' sigl\n/*********************************************************************/\n/* Trap the output from the LISTA STATUS command                     */\n/*********************************************************************/\n         call outtrap 'lines.'\n         address TSO \"LISTALC STATUS\"\n         call outtrap 'off'\n         ddnum = 0\n/*********************************************************************/\n/* Parse out the DDNAMEs and concatenate into a list                 */\n/*********************************************************************/\n         ddlist = ''\n         do ddl=1 to lines.0\n            if words(lines.ddl) = 2 then\n               do\n                parse upper var lines.ddl ddname .\n                ddlist = ddlist ddname\n                ddnum = ddnum + 1\n               end\n            else\n               do\n                iterate\n               end\n         end\n/*********************************************************************/\n/* Return the number of DDs                                          */\n/*********************************************************************/\n         pull tracelvl . module . sigl . sparms\n         call modtrace 'STOP' sigl\n         interpret 'trace' tracelvl\n         return ddnum\n/*********** @REFRESH END   DDLIST   2002/12/15 04:54:32 *************/\n/*********** @REFRESH BEGIN DDDSNS   2002/09/11 00:37:36 *************/\n/* DDDSNS   - Returns number of DSNs in a DD and populates DDDSNS    */\n/*                                                                  */\n/* TARGDD   - DD to return DSNs for                                  */\n/*********************************************************************/\n dddsns: module = 'DDDSNS'\n         if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n         parse arg sparms\n         push trace() time('L') module 'From:' sigl 'Parms:' sparms\n         call modtrace 'START' sigl\n         arg targdd\n         if targdd = '' then call rcexit 77 'DD missing for DDDSNS'\n/*********************************************************************/\n/* Trap the output from the LISTA STATUS command                     */\n/*********************************************************************/\n         x = outtrap('lines.')\n         address TSO \"LISTALC STATUS\"\n         dsnnum = 0\n         ddname = '$DDNAME$'\n/*********************************************************************/\n/* Parse out the DDNAMEs, locate the target DD and concatentate DSNs */\n/*********************************************************************/\n         do ddd=1 to lines.0\n            select\n               when words(lines.ddd) = 1 & targdd = ddname &,\n                    lines.ddd <> 'KEEP' then\n                    dddsns = dddsns strip(lines.ddd)\n               when words(lines.ddd) = 1 & strip(lines.ddd),\n                    <> 'KEEP' then\n                    dddsn.ddd = strip(lines.ddd)\n               when words(lines.ddd) = 2 then\n                    do\n                     parse upper var lines.ddd ddname .\n                     if targdd = ddname then\n                        do\n                         fdsn = ddd - 1\n                         dddsns = lines.fdsn\n                        end\n                    end\n               otherwise iterate\n            end\n         end\n/*********************************************************************/\n/* Get the last DD                                                   */\n/*********************************************************************/\n         ddnum = ddlist()\n         lastdd = word(ddlist,ddnum)\n/*********************************************************************/\n/* Remove the last DSN from the list if not the last DD or SYSEXEC   */\n/*********************************************************************/\n         if targdd <> 'SYSEXEC' & targdd <> lastdd then\n            do\n             dsnnum = words(dddsns) - 1\n             dddsns = subword(dddsns,1,dsnnum)\n            end\n/*********************************************************************/\n/* Return the number of DSNs in the DD                               */\n/*********************************************************************/\n         pull tracelvl . module . sigl . sparms\n         call modtrace 'STOP' sigl\n         interpret 'trace' tracelvl\n         return dsnnum\n/*********** @REFRESH END   DDDSNS   2002/09/11 00:37:36 *************/\n/*********** @REFRESH BEGIN QDSN     2002/09/11 01:15:23 *************/\n/* QDSN     - Make sure there are only one set of quotes             */\n/*                                                                  */\n/* QDSN     - The DSN                                                */\n/*********************************************************************/\n qdsn: module = 'QDSN'\n       if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n       parse arg sparms\n       push trace() time('L') module 'From:' sigl 'Parms:' sparms\n       call modtrace 'START' sigl\n       parse arg qdsn\n       qdsn = \"'\"strip(qdsn,\"B\",\"'\")\"'\"\n       pull tracelvl . module . sigl . sparms\n       call modtrace 'STOP' sigl\n       interpret 'trace' tracelvl\n       return qdsn\n/*********** @REFRESH END   QDSN     2002/09/11 01:15:23 *************/\n/*********** @REFRESH BEGIN TSOTRAP  2002/12/15 05:18:45 *************/\n/* TSOTRAP  - Capture the output from a TSO command in a stem        */\n/*                                                                  */\n/* VALIDRC  - Optional valid RC, defaults to zero                    */\n/* TSOPARM  - Valid TSO command                                      */\n/*********************************************************************/\n tsotrap: module = 'TSOTRAP'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          parse arg tsoparm\n/*********************************************************************/\n/* If the optional valid_rc parm is present use it, if not assume 0  */\n/*********************************************************************/\n          parse var tsoparm valid_rc tso_cmd\n          if datatype(valid_rc,'W') = 0 then\n             do\n              valid_rc = 0\n              tso_cmd = tsoparm\n             end\n          call outtrap 'tsoout.'\n          tsoline = sigl\n          address TSO tso_cmd\n          CRC = RC\n          call outtrap 'off'\n/*********************************************************************/\n/* If RC = 0 then return                                             */\n/*********************************************************************/\n          if CRC <= valid_rc then\n             do\n              pull tracelvl . module . sigl . sparms\n              call modtrace 'STOP' sigl\n              interpret 'trace' tracelvl\n              return CRC\n             end\n          else\n             do\n              trapmsg = center(' TSO Command Error Trap ',78,'-')\n              terrmsg = errmsg(sigl 'TSO Command:')\n/*********************************************************************/\n/* If RC <> 0 then format output depending on environment            */\n/*********************************************************************/\n              if tsoenv = 'BACK' | execenv = 'OMVS' then\n                 do\n                  say trapmsg\n                  do c=1 to tsoout.0\n                     say tsoout.c\n                  end\n                  say trapmsg\n                  call rcexit CRC terrmsg tso_cmd\n                 end\n              else\n/*********************************************************************/\n/* If this is foreground and ISPF is available, use the ISPF LOG     */\n/*********************************************************************/\n                 do\n                  if ispfenv = 'YES' then\n                     do\n                      zedlmsg = trapmsg\n/*********************************************************************/\n/* Does not call ISPWRAP to avoid obscuring error message modules    */\n/*********************************************************************/\n                      address ISPEXEC \"LOG MSG(ISRZ000)\"\n                      do c=1 to tsoout.0\n                         zedlmsg = tsoout.c\n                         address ISPEXEC \"LOG MSG(ISRZ000)\"\n                      end\n                      zedlmsg = trapmsg\n                      address ISPEXEC \"LOG MSG(ISRZ000)\"\n                      call rcexit CRC terrmsg tso_cmd,\n                          ' see the ISPF Log (Option 7.5) for details'\n                     end\n                  else\n                     do\n                      say trapmsg\n                      do c=1 to tsoout.0\n                         say tsoout.c\n                      end\n                      say trapmsg\n                      call rcexit CRC terrmsg tso_cmd\n                     end\n                 end\n             end\n/*********** @REFRESH END   TSOTRAP  2002/12/15 05:18:45 *************/\n/*********** @REFRESH BEGIN SAYDD    2004/03/29 23:48:37 *************/\n/* SAYDD    - Print messages to the requested DD                     */\n/*                                                                  */\n/* MSGDD    - DDNAME to write messages to                            */\n/* MSGLINES - number of blank lines to put before and after          */\n/* MESSAGE  - Text to write to the MSGDD                             */\n/*********************************************************************/\n saydd: module = 'SAYDD'\n        if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n        parse arg sparms\n        push trace() time('L') module 'From:' sigl 'Parms:' sparms\n        call modtrace 'START' sigl\n        parse arg msgdd msglines message\n        if words(msgdd msglines message) < 3 then\n           call rcexit 33 'Missing MSGDD or MSGLINES'\n        if datatype(msglines) <> 'NUM' then\n           call rcexit 34 'MSGLINES must be numeric'\n/*********************************************************************/\n/* If this is not background then bypass                             */\n/*********************************************************************/\n        if tsoenv <> 'BACK' then\n           do\n            pull tracelvl . module . sigl . sparms\n            call modtrace 'STOP' sigl\n            interpret 'trace' tracelvl\n            return\n           end\n/*********************************************************************/\n/* Confirm the MSGDD exists                                          */\n/*********************************************************************/\n        call ddcheck msgdd\n/*********************************************************************/\n/* If a number is provided, add that number of blank lines before    */\n/* the message                                                       */\n/*********************************************************************/\n        msgb = 1\n        if msglines > 0 then\n           do msgb=1 to msglines\n              msgline.msgb = ' '\n           end\n/*********************************************************************/\n/* If the linesize is too long break it into multiple lines and      */\n/* create continuation records                                       */\n/*********************************************************************/\n        msgm = msgb\n        if length(message) > 60 & substr(message,1,2) <> '@@' then\n           do\n            messst = lastpos(' ',message,60)\n            messseg = substr(message,1,messst)\n            msgline.msgm = date() time() strip(messseg)\n            message = strip(delstr(message,1,messst))\n            do while length(message) > 0\n               msgm = msgm + 1\n               if length(message) > 55 then\n                  messst = lastpos(' ',message,55)\n               if messst > 0 then\n                  messseg = substr(message,1,messst)\n               else\n                  messseg = substr(message,1,length(message))\n               msgline.msgm = date() time() 'CONT:' strip(messseg)\n               message = strip(delstr(message,1,length(messseg)))\n            end\n           end\n        else\n/*********************************************************************/\n/* Build print lines. Default strips and prefixes date and timestamp */\n/* @BLANK - Blank line, no date and timestamp                        */\n/* @      - No stripping, retains leading blanks                     */\n/* @@     - No stripping, No date and timestamp                      */\n/*********************************************************************/\n           do\n            select\n               when message = '@BLANK@' then msgline.msgm = ' '\n               when word(message,1) = '@' then\n                    do\n                     message = substr(message,2,length(message)-1)\n                     msgline.msgm = date() time() message\n                    end\n               when substr(message,1,2) = '@@' then\n                    do\n                     message = substr(message,3,length(message)-2)\n                     msgline.msgm = message\n                    end\n               otherwise msgline.msgm = date() time() strip(message)\n            end\n           end\n/*********************************************************************/\n/* If a number is provided, add that number of blank lines after     */\n/* the message                                                       */\n/*********************************************************************/\n        if msglines > 0 then\n           do msgt=1 to msglines\n              msge = msgt + msgm\n              msgline.msge = ' '\n           end\n/*********************************************************************/\n/* Write the contents of the MSGLINE stem to the MSGDD               */\n/*********************************************************************/\n        call tsotrap \"EXECIO * DISKW\" msgdd \"(STEM MSGLINE. FINIS\"\n        drop msgline. msgb msgt msge\n        pull tracelvl . module . sigl . sparms\n        call modtrace 'STOP' sigl\n        interpret 'trace' tracelvl\n        return\n/*********** @REFRESH END   SAYDD    2004/03/29 23:48:37 *************/\n/*********** @REFRESH BEGIN JOBINFO  2002/09/11 01:12:59 *************/\n/* JOBINFO  - Get job related data from control blocks               */\n/*                                                                  */\n/* ITEM     - Optional item number desired, default is all           */\n/*********************************************************************/\n jobinfo: module = 'JOBINFO'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          arg item\n/*********************************************************************/\n/* Chase control blocks                                              */\n/*********************************************************************/\n          tcb      = ptr(540)\n          ascb     = ptr(548)\n          tiot     = ptr(tcb+12)\n          jscb     = ptr(tcb+180)\n          ssib     = ptr(jscb+316)\n          asid     = c2d(stg(ascb+36,2))\n          jobtype  = stg(ssib+12,3)\n          jobnum   = strip(stg(ssib+15,5),'L',0)\n          stepname = stg(tiot+8,8)\n          procstep = stg(tiot+16,8)\n          program  = stg(jscb+360,8)\n          jobdata  = jobtype jobnum stepname procstep program asid\n/*********************************************************************/\n/* Return job data                                                   */\n/*********************************************************************/\n          if item <> '' & (datatype(item,'W') = 1) then\n             do\n              pull tracelvl . module . sigl . sparms\n              call modtrace 'STOP' sigl\n              interpret 'trace' tracelvl\n              return word(jobdata,item)\n             end\n          else\n             do\n              pull tracelvl . module . sigl . sparms\n              call modtrace 'STOP' sigl\n              interpret 'trace' tracelvl\n              return jobdata\n             end\n/*********** @REFRESH END   JOBINFO  2002/09/11 01:12:59 *************/\n/*********** @REFRESH BEGIN PTR      2002/07/13 15:45:36 *************/\n/* PTR      - Pointer to a storage location                          */\n/*                                                                  */\n/* ARG(1)   - Storage Address                                        */\n/*********************************************************************/\n ptr: return c2d(storage(d2x(arg(1)),4))\n/*********** @REFRESH END   PTR      2002/07/13 15:45:36 *************/\n/*********** @REFRESH BEGIN STG      2002/07/13 15:49:12 *************/\n/* STG      - Return the data from a storage location                */\n/*                                                                  */\n/* ARG(1)   - Location                                               */\n/* ARG(2)   - Length                                                 */\n/*********************************************************************/\n stg: return storage(d2x(arg(1)),arg(2))\n/*********** @REFRESH END   STG      2002/07/13 15:49:12 *************/\n/*********** @REFRESH BEGIN VIODD    2004/06/08 11:17:36 *************/\n/* VIODD    - EXECIO a stem into a sequential dataset                */\n/*                                                                  */\n/* VIODD    - The member to create                                   */\n/* VIOLRECL - The LRECL for the VIODD (defaults to 80)               */\n/*********************************************************************/\n viodd: module = 'VIODD'\n        if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n        parse arg sparms\n        push trace() time('L') module 'From:' sigl 'Parms:' sparms\n        call modtrace 'START' sigl\n        arg viodd violrecl viorecfm\n        if viodd = '' then call rcexit 88 'VIODD missing'\n        if violrecl = '' then violrecl = 80\n        if viorecfm = '' then viorecfm = 'F B'\n/*********************************************************************/\n/* If DD exists, FREE it                                             */\n/*********************************************************************/\n        if listdsi(viodd 'FILE') = 0 then\n           call tsotrap \"FREE F(\"viodd\")\"\n/*********************************************************************/\n/* ALLOCATE a VIO DSN                                                */\n/*********************************************************************/\n        call tsotrap \"ALLOC F(\"viodd\") UNIT(\"@vio\") SPACE(1 5)\",\n                     \"LRECL(\"violrecl\") BLKSIZE(0) REUSE\",\n                     \"RECFM(\"viorecfm\") CYLINDERS\"\n/*********************************************************************/\n/* Write the stem variables into the VIO DSN                         */\n/*********************************************************************/\n        call tsotrap \"EXECIO * DISKW\" viodd \"(STEM\" viodd\". FINIS\"\n/*********************************************************************/\n/* DROP the stem variable                                            */\n/*********************************************************************/\n        interpret 'drop' viodd'.'\n        pull tracelvl . module . sigl . sparms\n        call modtrace 'STOP' sigl\n        interpret 'trace' tracelvl\n        return\n/*********** @REFRESH END   VIODD    2004/06/08 11:17:36 *************/\n/*********** @REFRESH BEGIN MODTRACE 2003/12/31 21:56:54 *************/\n/* MODTRACE - Module Trace                                           */\n/*                                                                  */\n/* TRACETYP - Type of trace entry                                    */\n/* SIGLINE  - The line number called from                            */\n/*********************************************************************/\n modtrace: if modtrace = 'NO' then return\n           arg tracetyp sigline\n           tracetyp = left(tracetyp,5)\n           sigline = left(sigline,5)\n/*********************************************************************/\n/* Adjust MODSPACE for START                                         */\n/*********************************************************************/\n           if tracetyp = 'START' then\n              modspace = substr(modspace,1,length(modspace)+1)\n/*********************************************************************/\n/* Set the trace entry                                               */\n/*********************************************************************/\n           traceline = modspace time('L') tracetyp module sigline sparms\n/*********************************************************************/\n/* Adjust MODSPACE for STOP                                          */\n/*********************************************************************/\n           if tracetyp = 'STOP' then\n              modspace = substr(modspace,1,length(modspace)-1)\n/*********************************************************************/\n/* Determine where to write the traceline                            */\n/*********************************************************************/\n           if ispfenv = 'YES' & tsoenv = 'FORE' then\n/*********************************************************************/\n/* Write to the ISPF Log, do not use ISPWRAP here                    */\n/*********************************************************************/\n              do\n               zedlmsg = traceline\n               address ISPEXEC \"LOG MSG(ISRZ000)\"\n              end\n           else\n              say traceline\n/*********************************************************************/\n/* SAY to SYSTSPRT                                                   */\n/*********************************************************************/\n           return\n/*********** @REFRESH END   MODTRACE 2003/12/31 21:56:54 *************/\n\nRobert Zenuk\nSystems Programmer (USA) c Xephon 2005\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSSPLIJ": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x01\\x13\"_\\x01\\x13\"_\\x15\\x18\\x00\\x1b\\x00\\x18\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-08-13T00:00:00", "modifydate": "2013-08-13T15:18:17", "lines": 27, "newlines": 24, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBS JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//***************************************************************\n//* SPLIT A PDS                                                 *\n//*                                                             *\n//* OPTION=ALPHA     1 DSN FOR EACH UNIQUE FIRST CHARACTER OF   *\n//*                  THE MEMBER NAME                            *\n//* OPTION=EVEN      SPLIT INTO 10 EQUAL DSNS (SAME AS EVEN 10) *\n//* OPTION='EVEN NN' SPLIT INTO 'NN' EQUAL DSNS                 *\n//* OPTION=NN        SPLIT INTO DSNS EACH HOLDING NN MEMBERS    *\n//***************************************************************\n//PDSSPLIT PROC\n//PDSSPLIT EXEC PGM=IKJEFT01,DYNAMNBR=99,PARM='PDSSPLIT &OPTION'\n//SYSEXEC  DD   DSN=SBGOLOB.CLIST,DISP=SHR\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   DUMMY\n//DIAGMSGS DD   SYSOUT=*\n//INPUT    DD   DSN=&PDS,DISP=SHR\n//SYSPRINT DD   SYSOUT=*\n//         PEND\n//ALPHA    EXEC PDSSPLIT,PDS=SBGOLOB.CBTDOC.PDS,OPTION=ALPHA\n//\n//EVEN10   EXEC PDSSPLIT,PDS=SBGOLOB.CBTDOC.PDS,OPTION=EVEN\n//EVEN3    EXEC PDSSPLIT,PDS=SBGOLOB.CBTDOC.PDS,OPTION='EVEN 3'\n//P100     EXEC PDSSPLIT,PDS=SBGOLOB.CBTDOC.PDS,OPTION=100\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSSPLIT": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x13\"_\\x01\\x13\"_\\x15\\x08\\x04J\\x04J\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-13T00:00:00", "modifydate": "2013-08-13T15:08:22", "lines": 1098, "newlines": 1098, "modlines": 0, "user": "EXEC"}, "text": "/****************************** REXX *********************************/\n/* Purpose: Copy a PDS to multiple output PDSs based on criteria     */\n/*                                                                  */\n/* Syntax:  pdssplit criteria                                        */\n/*                                                                  */\n/* Parms: approach   - number or ALPHA or EVEN                       */\n/*                                                                   */\n/* Use a number to create multiple PDSs with that number of members  */\n/* Use ALPHA to create a PDS for each letter of the alphabet         */\n/* Use EVEN nn to create nn PDSs with an even portion of members     */\n/*                                                                   */\n/* Known issue: a single member copy does not work (creates PS DSN?) */\n/*********************************************************************/\n/*                      Change Log                                   */\n/*                                                                   */\n/*  Author       Date      Reason                                    */\n/*                                                             */\n/*                                                                   */\n/*********** @REFRESH BEGIN START    2004/03/06 13:16:32 *************/\n/* Standard housekeeping activities                                  */\n/*********************************************************************/\n call time 'r'\n parse arg parms\n signal on syntax name trap\n signal on failure name trap\n signal on novalue name trap\n probe = 'NONE'\n modtrace = 'NO'\n modspace = ''\n call stdentry 'DIAGMSGS'\n module = 'MAINLINE'\n push trace() time('L') module 'From:' 0 'Parms:' parms\n if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n call modtrace 'START' 0\n/*********************************************************************/\n/* Set local estoeric names                                          */\n/*********************************************************************/\n @vio   = 'VIO'\n @sysda = 'SYSDA'\n/*********** @REFRESH END   START    2004/03/06 13:16:32 *************/\n/* Accept and validate parms                                         */\n/*********************************************************************/\n arg parm evencount .\n if parm = '' then\n    parm = 'ALPHA'\n select\n   when datatype(parm,'W') = 1 then parm = parm\n   when parm = 'ALPHA' then parm = 'ALPHA'\n   when parm = 'EVEN' then\n        do\n         parm = 'EVEN'\n         if evencount = '' then evencount = 10\n        end\n   otherwise\n      call rcexit 20 'Invalid parm:' parm', whole number, \"ALPHA\"',\n          'or \"EVEN\"'\n end\n call saydd msgdd 1 'Parm used:' parm\n/*********************************************************************/\n/* Make sure the INPUT DD exists                                     */\n/*********************************************************************/\n call ddcheck 'INPUT'\n source = sysdsname\n/*********************************************************************/\n/* Set initial defaults                                              */\n/*********************************************************************/\n totcount = 0\n check = 1\n last = ''\n sets = -1\n/*********************************************************************/\n/* Get member names from the PDS                                     */\n/*********************************************************************/\n call outtrap 'mem.'\n\"LISTDS '\"source\"' MEMBERS\"\n x = outtrap('off')\n/*********************************************************************/\n/* Set option specific defaults                                      */\n/*********************************************************************/\n select\n   when parm = 'ALPHA' then mcount = 0\n   when parm = 'EVEN' then\n        do\n         parm = format(((mem.0-7)/evencount),,0)\n         mcount = parm + 1\n        end\n   otherwise mcount = parm + 1\n end\n/*********************************************************************/\n/* Process the members                                               */\n/*********************************************************************/\n do i=7 to mem.0\n    totcount = totcount + 1\n    member = strip(mem.i)\n/*********************************************************************/\n/* Process ALPHA                                                     */\n/*********************************************************************/\n    if parm = 'ALPHA' then\n       do\n        char1 = substr(member,1,1)\n        if char1 = last then\n           do\n            mcount = mcount + 1\n            sysin.mcount = cont('                 'member',')\n           end\n        else\n           do\n            sets = sets + 1\n            if i <> 7 then\n               do\n                target = dsalloc(source right(sets,3,0),\n                         right(mcount-1,3,0) parm mem.0-7)\n                say right(mcount-1,4) last'* members copied to' target,\n                   'RC='copymem(source target)\n               end\n            sysin.1  = '  COPY INDD=SOURCE,OUTDD=TARGET'\n            sysin.2  = cont('  SELECT MEMBER=('member',')\n            last = char1\n            mcount = 2\n           end\n       end\n/*********************************************************************/\n/* Process Numeric and EVEN                                          */\n/*********************************************************************/\n    if datatype(parm,'W') = 1 then\n       do\n        if mcount <= parm then\n           do\n            mcount = mcount + 1\n            sysin.mcount = cont('                 'member',')\n           end\n        else\n           do\n            sets = sets + 1\n            if i <> 7 then\n               do\n                target = dsalloc(source right(sets,3,0),\n                         right(mcount-1,3,0) parm mem.0-7)\n                say right(mcount-1,4) 'members copied to' target,\n                   'RC='copymem(source target)\n               end\n            sysin.1  = '  COPY INDD=SOURCE,OUTDD=TARGET'\n            sysin.2  = cont('  SELECT MEMBER=('member',')\n            mcount = 2\n           end\n       end\n end\n/*********************************************************************/\n/* Process the last group                                            */\n/*********************************************************************/\n sets = sets + 1\n target = dsalloc(source right(sets,3,0),\n          right(mcount-1,3,0) parm mem.0-7)\n if parm = 'ALPHA' then\n    say right(mcount-1,4) last'* members copied to' target,\n       'RC='copymem(source target)\n else\n    say right(mcount-1,4) 'members copied to' target,\n       'RC='copymem(source target)\n/*********************************************************************/\n/* Print stats                                                       */\n/*********************************************************************/\n say\n say right(totcount,4) 'members copied'\n say right(sets,4) 'datasets created'\n/*********************************************************************/\n/* Shutdown                                                          */\n/*********************************************************************/\n shutdown: nop\n/*********************************************************************/\n/* Put unique shutdown logic before the call to stdexit              */\n/*********** @REFRESH BEGIN STOP     2002/08/03 08:42:33 *************/\n/* Shutdown message and terminate                                    */\n/*********************************************************************/\n           call stdexit time('e')\n/*********** @REFRESH END   STOP     2002/08/03 08:42:33 *************/\n/* Internal Subroutines - not refreshable                            */\n/*                                                                   */\n/* DSALLOC  - Allocate the new DSN                                   */\n/* COPYMEM  - Invoke IEBCOPY to copy members                         */\n/* CONT     - Append line with a continuation in column 72           */\n/*                                                                   */\n/*********************************************************************/\n/* DSALLOC  - Allocate the new DSN                                   */\n/*********************************************************************/\n dsalloc: arg olddsn num memnum parm totmem\n          if parm = 'ALPHA' then\n             clonetype = last\n          else\n             clonetype = '#'\n          newdsn = userid()'.@'num||clonetype||memnum'.'olddsn\n          dirblks = format(memnum/4,,0)\n          pmem = memnum/totmem\n          prispace = format(pmem*(sysused/sysblkstrk/systrkscyl),,0)\n          if prispace = 0 then prispace = 1\n          secspace = prispace * 5\n          if sysrecfm = 'U' then\n             do\n              call tsotrap \"ALLOC F(CLONE) DA(\"qdsn(newdsn)\")\",\n                           \"LIKE(\"qdsn(olddsn)\") DIR(\"dirblks\")\",\n                           \"SPACE(\"prispace secspace\") CYLINDERS\",\n                           \"BLKSIZE(\"sysblksize\")\"\n             end\n           else\n             do\n              call tsotrap \"ALLOC F(CLONE) DA(\"qdsn(newdsn)\")\",\n                           \"LIKE(\"qdsn(olddsn)\") DIR(\"dirblks\")\",\n                           \"SPACE(\"prispace secspace\") CYLINDERS\",\n                           \"LRECL(\"syslrecl\") BLKSIZE(\"sysblksize\")\"\n             end\n          call tsotrap \"FREE F(CLONE)\"\n          return newdsn\n/*********************************************************************/\n/* COPYMEM  - Invoke IEBCOPY to copy members                         */\n/*********************************************************************/\n copymem: arg olddsn newdsn\n          close = mcount + 1\n          sysin.close = '                )'\n          call tsotrap \"ALLOC F(SOURCE) DA(\"qdsn(olddsn)\") SHR REUSE\"\n          call tsotrap \"ALLOC F(TARGET) DA(\"qdsn(newdsn)\") SHR REUSE\"\n          call viodd 'SYSIN'\n          address TSO \"CALL *(IEBCOPY)\"\n          call rcexit RC 'IEBCOPY error copying' olddsn 'to' newdsn\n          call tsotrap \"FREE F(SOURCE TARGET SYSIN)\"\n          drop sysin.\n          return 0\n/*********************************************************************/\n/* CONT     - Append line with a continuation in column 72           */\n/*********************************************************************/\n cont: parse arg string\n       contstring = string copies(' ',70-length(string))||'X'\n       return contstring\n/*********** @REFRESH BEGIN SUBBOX   2004/03/10 01:25:03 *************/\n/*                                                                   */\n/* 20 Internal Subroutines provided in PDSSPLIT                      */\n/*                                                                   */\n/* Last Subroutine REFRESH was 29 Jul 2004 20:55:33                  */\n/*                                                                   */\n/* RCEXIT   - Exit on non-zero return codes                          */\n/* TRAP     - Issue a common trap error message using rcexit         */\n/* ERRMSG   - Build common error message with failing line number    */\n/* STDENTRY - Standard Entry logic                                   */\n/* STDEXIT  - Standard Exit logic                                    */\n/* MSG      - Determine whether to SAY or ISPEXEC SETMSG the message */\n/* DDCHECK  - Determine whether a required DD is allocated           */\n/* DDLIST   - Returns number of DDs and populates DDLIST variable    */\n/* DDDSNS   - Returns number of DSNs in a DD and populates DDDSNS    */\n/* QDSN     - Make sure there are only one set of quotes             */\n/* TSOTRAP  - Capture the output from a TSO command in a stem        */\n/* SAYDD    - Print messages to the requested DD                     */\n/* JOBINFO  - Get job-related data from control blocks               */\n/* PTR      - Pointer to a storage location                          */\n/* STG      - Return the data from a storage location                */\n/* VIODD    - EXECIO a stem into a sequential dataset                */\n/* MODTRACE - Module Trace                                           */\n/*                                                                   */\n/*********** @REFRESH END   SUBBOX   2004/03/10 01:25:03 *************/\n/*********** @REFRESH BEGIN RCEXIT   2003/05/14 12:24:50 *************/\n/* RCEXIT   - Exit on non-zero return codes                          */\n/*                                                                  */\n/* EXITRC   - Return code to exit with (if non zero)                 */\n/* ZEDLMSG  - Message text for it with for non zero EXITRC's         */\n/*********************************************************************/\n rcexit: parse arg EXITRC zedlmsg\n         if EXITRC <> 0 then\n            do\n             trace 'o'\n/*********************************************************************/\n/* If execution environment is ISPF then VPUT ZISPFRC                */\n/*********************************************************************/\n             if execenv = 'TSO' | execenv = 'ISPF' then\n                do\n                 if ispfenv = 'YES' then\n                    do\n                     zispfrc = EXITRC\n/*********************************************************************/\n/* Does not call ISPWRAP to avoid obscuring error message modules    */\n/*********************************************************************/\n                     address ISPEXEC \"VPUT (ZISPFRC)\"\n                    end\n                end\n/*********************************************************************/\n/* If a message is provided, wrap it in date, time and EXITRC        */\n/*********************************************************************/\n             if zedlmsg <> '' then\n                do\n                 zedlmsg = time('L') execname zedlmsg 'RC='EXITRC\n                 call msg zedlmsg\n                end\n/*********************************************************************/\n/* Write the contents of the Parentage Stack                         */\n/*********************************************************************/\n             stacktitle = 'Parentage Stack Trace ('queued()' entries):'\n/*********************************************************************/\n/* Write to MSGDD if background and MSGDD exists                     */\n/*********************************************************************/\n             if tsoenv = 'BACK' then\n                do\n                 if subword(zedlmsg,9,1) = msgdd then\n                    do\n                     say zedlmsg\n                     signal shutdown\n                    end\n                 else\n                    do\n                     call saydd msgdd 1 zedlmsg\n                     call saydd msgdd 1 stacktitle\n                    end\n                end\n             else\n/*********************************************************************/\n/* Write to the ISPF Log if foreground                               */\n/*********************************************************************/\n                do\n                 zerrlm = zedlmsg\n                 address ISPEXEC \"LOG MSG(ISRZ003)\"\n                 zerrlm = center(' 'stacktitle' ',78,'-')\n                 address ISPEXEC \"LOG MSG(ISRZ003)\"\n                end\n/*********************************************************************/\n/* Unload the Parentage Stack                                        */\n/*********************************************************************/\n             do queued()\n                pull stackinfo\n                if tsoenv = 'BACK' then\n                   do\n                    call saydd msgdd 0 stackinfo\n                   end\n                else\n                   do\n                    zerrlm = stackinfo\n                    address ISPEXEC \"LOG MSG(ISRZ003)\"\n                   end\n             end\n/*********************************************************************/\n/* Put a terminator in the ISPF Log for the Parentage Stack          */\n/*********************************************************************/\n             if tsoenv = 'FORE' then\n                do\n                 zerrlm = center(' 'stacktitle' ',78,'-')\n                 address ISPEXEC \"LOG MSG(ISRZ003)\"\n                end\n/*********************************************************************/\n/* Signal SHUTDOWN.  SHUTDOWN label MUST exist in the program        */\n/*********************************************************************/\n             signal shutdown\n            end\n         else\n            return\n/*********** @REFRESH END   RCEXIT   2003/05/14 12:24:50 *************/\n/*********** @REFRESH BEGIN TRAP     2002/08/07 11:48:14 *************/\n/* TRAP     - Issue a common trap error message using rcexit         */\n/*                                                                  */\n/* PARM     - N/A                                                    */\n/*********************************************************************/\n trap: traptype = condition('C')\n       if traptype = 'SYNTAX' then\n          msg = errortext(RC)\n       else\n          msg = condition('D')\n       trapline = strip(sourceline(sigl))\n       msg = traptype 'TRAP:' msg', Line:' sigl '\"'trapline'\"'\n       call rcexit 666 msg\n/*********** @REFRESH END   TRAP     2002/08/07 11:48:14 *************/\n/*********** @REFRESH BEGIN ERRMSG   2002/08/10 16:53:04 *************/\n/* ERRMSG   - Build common error message with failing line number    */\n/*                                                                  */\n/* ERRLINE  - The failing line number passed by caller from SIGL     */\n/* TEXT     - Error message text passed by caller                    */\n/*********************************************************************/\n errmsg: nop\n         parse arg errline text\n         return 'Error on statement' errline',' text\n/*********** @REFRESH END   ERRMSG   2002/08/10 16:53:04 *************/\n/*********** @REFRESH BEGIN STDENTRY 2004/04/07 19:17:48 *************/\n/* STDENTRY - Standard Entry logic                                   */\n/*                                                                  */\n/* MSGDD    - Optional MSGDD used only in background                 */\n/*********************************************************************/\n stdentry: module = 'STDENTRY'\n           if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n           parse arg sparms\n           push trace() time('L') module 'From:' sigl 'Parms:' sparms\n           arg msgdd\n           parse upper source . . execname . execdsn . . execenv .\n/*********************************************************************/\n/* Start-up values                                                   */\n/*********************************************************************/\n           EXITRC = 0\n           MAXRC = 0\n           ispfenv = 'NO'\n           popup = 'NO'\n           lockpop = 'NO'\n           headoff = 'NO'\n           hcreator = 'NO'\n           keepstack = 'NO'\n           lpar = mvsvar('SYSNAME')\n           zedlmsg = 'Default shutdown message'\n/*********************************************************************/\n/* Determine environment                                             */\n/*********************************************************************/\n           if substr(execenv,1,3) <> 'TSO' & execenv <> 'ISPF' then\n              tsoenv = 'NONE'\n           else\n              do\n               tsoenv = sysvar('SYSENV')\n               signal off failure\n              \"ISPQRY\"\n               ISPRC = RC\n               if ISPRC = 0 then\n                  do\n                   ispfenv = 'YES'\n/*********************************************************************/\n/* Check if HEADING ISPF table exists already, if so set HEADOFF=YES */\n/*********************************************************************/\n                   call ispwrap \"VGET (ZSCREEN)\"\n                   if tsoenv = 'BACK' then\n                      htable = jobinfo(1)||jobinfo(2)\n                   else\n                      htable = userid()||zscreen\n                   TBCRC = ispwrap(8 \"TBCREATE\" htable \"KEYS(HEAD)\")\n                   if TBCRC = 0 then\n                      do\n                       headoff = 'NO'\n                       hcreator = 'YES'\n                      end\n                   else\n                      do\n                       headoff = 'YES'\n                      end\n                  end\n               signal on failure name trap\n              end\n/*********************************************************************/\n/* MODTRACE must occur after the setting of ISPFENV                  */\n/*********************************************************************/\n           call modtrace 'START' sigl\n/*********************************************************************/\n/* Start-up message (if batch)                                       */\n/*********************************************************************/\n           startmsg = execname 'started' date() time() 'on' lpar\n           if tsoenv = 'BACK' & sysvar('SYSNEST') = 'NO' &,\n              headoff = 'NO' then\n              do\n               jobname = mvsvar('SYMDEF','JOBNAME')\n               jobinfo = jobinfo()\n               parse var jobinfo jobtype jobnum .\n               say jobname center(' 'startmsg' ',61,'-') jobtype jobnum\n               say\n               if ISPRC = -3 then\n                  do\n                   call saydd msgdd 1 'ISPF ISPQRY module not found,',\n                                      'ISPQRY is usually in the LINKLST'\n                   call rcexit 20 'ISPF ISPQRY module is missing'\n                  end\n/*********************************************************************/\n/* If MSGDD is provided, write the STARTMSG and SYSEXEC DSN to MSGDD */\n/*********************************************************************/\n               if msgdd <> '' then\n                  do\n                   call ddcheck msgdd\n                   call saydd msgdd 1 startmsg\n                   call ddcheck 'SYSEXEC'\n                   call saydd msgdd 0 execname 'loaded from' sysdsname\n/*********************************************************************/\n/* If there are PARMS, write them to the MSGDD                       */\n/*********************************************************************/\n                   if parms <> '' then\n                      call saydd msgdd 0 'Parms:' parms\n/*********************************************************************/\n/* If there is a STEPLIB, write the STEPLIB DSN MSGDD                */\n/*********************************************************************/\n                   if listdsi('STEPLIB' 'FILE') = 0 then\n                      do\n                       steplibs = dddsns('STEPLIB')\n                       call saydd msgdd 0 'STEPLIB executables loaded',\n                           'from' word(dddsns,1)\n                       if dddsns('STEPLIB') > 1 then\n                          do\n                           do stl=2 to steplibs\n                              call saydd msgdd 0 copies(' ',31),\n                                   word(dddsns,stl)\n                           end\n                          end\n                      end\n                  end\n              end\n/*********************************************************************/\n/* If foreground, save ZFKA and turn off the FKA display             */\n/*********************************************************************/\n           else\n              do\n               fkaset = 'OFF'\n               call ispwrap \"VGET (ZFKA) PROFILE\"\n               if zfka <> 'OFF' & tsoenv = 'FORE' then\n                  do\n                   fkaset = zfka\n                   fkacmd = 'FKA OFF'\n                   call ispwrap \"CONTROL DISPLAY SAVE\"\n                  call ispwrap \"DISPLAY PANEL(ISPBLANK) COMMAND(FKACMD)\"\n                   call ispwrap \"CONTROL DISPLAY RESTORE\"\n                  end\n              end\n/*********************************************************************/\n           pull tracelvl . module . sigl . sparms\n           call modtrace 'STOP' sigl\n           interpret 'trace' tracelvl\n           return\n/*********** @REFRESH END   STDENTRY 2004/04/07 19:17:48 *************/\n/*********** @REFRESH BEGIN STDEXIT  2003/11/16 22:46:29 *************/\n/* STDEXIT  - Standard Exit logic                                    */\n/*                                                                  */\n/* ENDTIME  - Elapsed time                                           */\n/* Note: Caller must set KEEPSTACK if the stack is valid             */\n/*********************************************************************/\n stdexit: module = 'STDEXIT'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          arg endtime\n          endmsg = execname 'ended' date() time() format(endtime,,1)\n/*********************************************************************/\n/* if MAXRC is greater then EXITRC then set EXITRC to MAXRC          */\n/*********************************************************************/\n          if MAXRC > EXITRC then EXITRC = MAXRC\n          endmsg = endmsg 'on' lpar 'RC='EXITRC\n          if tsoenv = 'BACK' & sysvar('SYSNEST') = 'NO' &,\n             headoff = 'NO' then\n             do\n              say\n              say jobname center(' 'endmsg' ',61,'-') jobtype jobnum\n/*********************************************************************/\n/* Make sure this isn't a MSGDD missing error then log to MSGDD      */\n/*********************************************************************/\n              if msgdd <> '' & subword(zedlmsg,9,1) <> msgdd then\n                 do\n                  call saydd msgdd 1 execname 'ran in' endtime 'seconds'\n                  call saydd msgdd 0 endmsg\n                 end\n             end\n/*********************************************************************/\n/* If foreground, reset the FKA if necessary                         */\n/*********************************************************************/\n          else\n             do\n              if fkaset <> 'OFF' then\n                 do\n                  fkafix = 'FKA'\n                  call ispwrap \"CONTROL DISPLAY SAVE\"\n                  call ispwrap \"DISPLAY PANEL(ISPBLANK) COMMAND(FKAFIX)\"\n                  if fkaset = 'SHORT' then\n                     call ispwrap \"DISPLAY PANEL(ISPBLANK)\",\n                                  \"COMMAND(FKAFIX)\"\n                  call ispwrap \"CONTROL DISPLAY RESTORE\"\n                 end\n             end\n/*********************************************************************/\n/* Clean up the temporary HEADING table                              */\n/*********************************************************************/\n          if ispfenv = 'YES' & hcreator = 'YES' then\n             call ispwrap \"TBEND\" htable\n/*********************************************************************/\n/* Remove STDEXIT and MAINLINE Parentage Stack entries, if there     */\n/*********************************************************************/\n          call modtrace 'STOP' sigl\n          if queued() > 0 then pull . . module . sigl . sparms\n          if queued() > 0 then pull . . module . sigl . sparms\n          if tsoenv = 'FORE' & queued() > 0 & keepstack = 'NO' then\n             pull . . module . sigl . sparms\n/*********************************************************************/\n/* if the Parentage Stack is not empty, display its contents         */\n/*********************************************************************/\n          if queued() > 0 & keepstack = 'NO' then\n             do\n              say queued() 'Leftover Parentage Stack Entries:'\n              say\n              do queued()\n                 pull stackundo\n                 say stackundo\n              end\n              EXITRC = 1\n             end\n/*********************************************************************/\n/* Exit                                                              */\n/*********************************************************************/\n          exit(EXITRC)\n/*********** @REFRESH END   STDEXIT  2003/11/16 22:46:29 *************/\n/*********** @REFRESH BEGIN MSG      2002/09/11 01:35:53 *************/\n/* MSG      - Determine whether to SAY or ISPEXEC SETMSG the message */\n/*                                                                  */\n/* ZEDLMSG  - The long message variable                              */\n/*********************************************************************/\n msg: module = 'MSG'\n      parse arg zedlmsg\n      if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n      parse arg sparms\n      push trace() time('L') module 'From:' sigl 'Parms:' sparms\n      call modtrace 'START' sigl\n/*********************************************************************/\n/* If this is background or OMVS use SAY                             */\n/*********************************************************************/\n      if tsoenv = 'BACK' | execenv = 'OMVS' then\n         say zedlmsg\n      else\n/*********************************************************************/\n/* If this is foreground and ISPF is available, use SETMSG           */\n/*********************************************************************/\n         do\n          if ispfenv = 'YES' then\n/*********************************************************************/\n/* Does not call ISPWRAP to avoid obscuring error message modules    */\n/*********************************************************************/\n             address ISPEXEC \"SETMSG MSG(ISRZ000)\"\n          else\n             say zedlmsg\n         end\n      pull tracelvl . module . sigl . sparms\n      call modtrace 'STOP' sigl\n      interpret 'trace' tracelvl\n      return\n/*********** @REFRESH END   MSG      2002/09/11 01:35:53 *************/\n/*********** @REFRESH BEGIN DDCHECK  2002/09/11 01:08:30 *************/\n/* DDCHECK  - Determine if a required DD is allocated                */\n/*                                                                  */\n/* DD       - DDNAME to confirm                                      */\n/*********************************************************************/\n ddcheck: module = 'DDCHECK'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          arg dd\n          dderrmsg = 'OK'\n          LRC = listdsi(dd \"FILE\")\n/*********************************************************************/\n/* Allow sysreason=3 to verify SYSOUT DD statements                  */\n/*********************************************************************/\n          if LRC <> 0 & strip(sysreason,'L',0) <> 3 then\n             do\n              dderrmsg = errmsg(sigl 'Required DD' dd 'is missing')\n              call rcexit LRC dderrmsg sysmsglvl2\n             end\n          pull tracelvl . module . sigl . sparms\n          call modtrace 'STOP' sigl\n          interpret 'trace' tracelvl\n          return\n/*********** @REFRESH END   DDCHECK  2002/09/11 01:08:30 *************/\n/*********** @REFRESH BEGIN DDLIST   2002/12/15 04:54:32 *************/\n/* DDLIST   - Returns number of DDs and populates DDLIST variable    */\n/*                                                                  */\n/* N/A      - None                                                   */\n/*********************************************************************/\n ddlist: module = 'DDLIST'\n         if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n         parse arg sparms\n         push trace() time('L') module 'From:' sigl 'Parms:' sparms\n         call modtrace 'START' sigl\n/*********************************************************************/\n/* Trap the output from the LISTA STATUS command                     */\n/*********************************************************************/\n         call outtrap 'lines.'\n         address TSO \"LISTALC STATUS\"\n         call outtrap 'off'\n         ddnum = 0\n/*********************************************************************/\n/* Parse out the DDNAMEs and concatenate into a list                 */\n/*********************************************************************/\n         ddlist = ''\n         do ddl=1 to lines.0\n            if words(lines.ddl) = 2 then\n               do\n                parse upper var lines.ddl ddname .\n                ddlist = ddlist ddname\n                ddnum = ddnum + 1\n               end\n            else\n               do\n                iterate\n               end\n         end\n/*********************************************************************/\n/* Return the number of DDs                                          */\n/*********************************************************************/\n         pull tracelvl . module . sigl . sparms\n         call modtrace 'STOP' sigl\n         interpret 'trace' tracelvl\n         return ddnum\n/*********** @REFRESH END   DDLIST   2002/12/15 04:54:32 *************/\n/*********** @REFRESH BEGIN DDDSNS   2002/09/11 00:37:36 *************/\n/* DDDSNS   - Returns number of DSNs in a DD and populates DDDSNS    */\n/*                                                                  */\n/* TARGDD   - DD to return DSNs for                                  */\n/*********************************************************************/\n dddsns: module = 'DDDSNS'\n         if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n         parse arg sparms\n         push trace() time('L') module 'From:' sigl 'Parms:' sparms\n         call modtrace 'START' sigl\n         arg targdd\n         if targdd = '' then call rcexit 77 'DD missing for DDDSNS'\n/*********************************************************************/\n/* Trap the output from the LISTA STATUS command                     */\n/*********************************************************************/\n         x = outtrap('lines.')\n         address TSO \"LISTALC STATUS\"\n         dsnnum = 0\n         ddname = '$DDNAME$'\n/*********************************************************************/\n/* Parse out the DDNAMEs, locate the target DD and concatentate DSNs */\n/*********************************************************************/\n         do ddd=1 to lines.0\n            select\n               when words(lines.ddd) = 1 & targdd = ddname &,\n                    lines.ddd <> 'KEEP' then\n                    dddsns = dddsns strip(lines.ddd)\n               when words(lines.ddd) = 1 & strip(lines.ddd),\n                    <> 'KEEP' then\n                    dddsn.ddd = strip(lines.ddd)\n               when words(lines.ddd) = 2 then\n                    do\n                     parse upper var lines.ddd ddname .\n                     if targdd = ddname then\n                        do\n                         fdsn = ddd - 1\n                         dddsns = lines.fdsn\n                        end\n                    end\n               otherwise iterate\n            end\n         end\n/*********************************************************************/\n/* Get the last DD                                                   */\n/*********************************************************************/\n         ddnum = ddlist()\n         lastdd = word(ddlist,ddnum)\n/*********************************************************************/\n/* Remove the last DSN from the list if not the last DD or SYSEXEC   */\n/*********************************************************************/\n         if targdd <> 'SYSEXEC' & targdd <> lastdd then\n            do\n             dsnnum = words(dddsns) - 1\n             dddsns = subword(dddsns,1,dsnnum)\n            end\n/*********************************************************************/\n/* Return the number of DSNs in the DD                               */\n/*********************************************************************/\n         pull tracelvl . module . sigl . sparms\n         call modtrace 'STOP' sigl\n         interpret 'trace' tracelvl\n         return dsnnum\n/*********** @REFRESH END   DDDSNS   2002/09/11 00:37:36 *************/\n/*********** @REFRESH BEGIN QDSN     2002/09/11 01:15:23 *************/\n/* QDSN     - Make sure there are only one set of quotes             */\n/*                                                                  */\n/* QDSN     - The DSN                                                */\n/*********************************************************************/\n qdsn: module = 'QDSN'\n       if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n       parse arg sparms\n       push trace() time('L') module 'From:' sigl 'Parms:' sparms\n       call modtrace 'START' sigl\n       parse arg qdsn\n       qdsn = \"'\"strip(qdsn,\"B\",\"'\")\"'\"\n       pull tracelvl . module . sigl . sparms\n       call modtrace 'STOP' sigl\n       interpret 'trace' tracelvl\n       return qdsn\n/*********** @REFRESH END   QDSN     2002/09/11 01:15:23 *************/\n/*********** @REFRESH BEGIN TSOTRAP  2002/12/15 05:18:45 *************/\n/* TSOTRAP  - Capture the output from a TSO command in a stem        */\n/*                                                                  */\n/* VALIDRC  - Optional valid RC, defaults to zero                    */\n/* TSOPARM  - Valid TSO command                                      */\n/*********************************************************************/\n tsotrap: module = 'TSOTRAP'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          parse arg tsoparm\n/*********************************************************************/\n/* If the optional valid_rc parm is present use it, if not assume 0  */\n/*********************************************************************/\n          parse var tsoparm valid_rc tso_cmd\n          if datatype(valid_rc,'W') = 0 then\n             do\n              valid_rc = 0\n              tso_cmd = tsoparm\n             end\n          call outtrap 'tsoout.'\n          tsoline = sigl\n          address TSO tso_cmd\n          CRC = RC\n          call outtrap 'off'\n/*********************************************************************/\n/* If RC = 0 then return                                             */\n/*********************************************************************/\n          if CRC <= valid_rc then\n             do\n              pull tracelvl . module . sigl . sparms\n              call modtrace 'STOP' sigl\n              interpret 'trace' tracelvl\n              return CRC\n             end\n          else\n             do\n              trapmsg = center(' TSO Command Error Trap ',78,'-')\n              terrmsg = errmsg(sigl 'TSO Command:')\n/*********************************************************************/\n/* If RC <> 0 then format output depending on environment            */\n/*********************************************************************/\n              if tsoenv = 'BACK' | execenv = 'OMVS' then\n                 do\n                  say trapmsg\n                  do c=1 to tsoout.0\n                     say tsoout.c\n                  end\n                  say trapmsg\n                  call rcexit CRC terrmsg tso_cmd\n                 end\n              else\n/*********************************************************************/\n/* If this is foreground and ISPF is available, use the ISPF LOG     */\n/*********************************************************************/\n                 do\n                  if ispfenv = 'YES' then\n                     do\n                      zedlmsg = trapmsg\n/*********************************************************************/\n/* Does not call ISPWRAP to avoid obscuring error message modules    */\n/*********************************************************************/\n                      address ISPEXEC \"LOG MSG(ISRZ000)\"\n                      do c=1 to tsoout.0\n                         zedlmsg = tsoout.c\n                         address ISPEXEC \"LOG MSG(ISRZ000)\"\n                      end\n                      zedlmsg = trapmsg\n                      address ISPEXEC \"LOG MSG(ISRZ000)\"\n                      call rcexit CRC terrmsg tso_cmd,\n                          ' see the ISPF Log (Option 7.5) for details'\n                     end\n                  else\n                     do\n                      say trapmsg\n                      do c=1 to tsoout.0\n                         say tsoout.c\n                      end\n                      say trapmsg\n                      call rcexit CRC terrmsg tso_cmd\n                     end\n                 end\n             end\n/*********** @REFRESH END   TSOTRAP  2002/12/15 05:18:45 *************/\n/*********** @REFRESH BEGIN SAYDD    2004/03/29 23:48:37 *************/\n/* SAYDD    - Print messages to the requested DD                     */\n/*                                                                  */\n/* MSGDD    - DDNAME to write messages to                            */\n/* MSGLINES - number of blank lines to put before and after          */\n/* MESSAGE  - Text to write to the MSGDD                             */\n/*********************************************************************/\n saydd: module = 'SAYDD'\n        if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n        parse arg sparms\n        push trace() time('L') module 'From:' sigl 'Parms:' sparms\n        call modtrace 'START' sigl\n        parse arg msgdd msglines message\n        if words(msgdd msglines message) < 3 then\n           call rcexit 33 'Missing MSGDD or MSGLINES'\n        if datatype(msglines) <> 'NUM' then\n           call rcexit 34 'MSGLINES must be numeric'\n/*********************************************************************/\n/* If this is not background then bypass                             */\n/*********************************************************************/\n        if tsoenv <> 'BACK' then\n           do\n            pull tracelvl . module . sigl . sparms\n            call modtrace 'STOP' sigl\n            interpret 'trace' tracelvl\n            return\n           end\n/*********************************************************************/\n/* Confirm the MSGDD exists                                          */\n/*********************************************************************/\n        call ddcheck msgdd\n/*********************************************************************/\n/* If a number is provided, add that number of blank lines before    */\n/* the message                                                       */\n/*********************************************************************/\n        msgb = 1\n        if msglines > 0 then\n           do msgb=1 to msglines\n              msgline.msgb = ' '\n           end\n/*********************************************************************/\n/* If the linesize is too long break it into multiple lines and      */\n/* create continuation records                                       */\n/*********************************************************************/\n        msgm = msgb\n        if length(message) > 60 & substr(message,1,2) <> '@@' then\n           do\n            messst = lastpos(' ',message,60)\n            messseg = substr(message,1,messst)\n            msgline.msgm = date() time() strip(messseg)\n            message = strip(delstr(message,1,messst))\n            do while length(message) > 0\n               msgm = msgm + 1\n               if length(message) > 55 then\n                  messst = lastpos(' ',message,55)\n               if messst > 0 then\n                  messseg = substr(message,1,messst)\n               else\n                  messseg = substr(message,1,length(message))\n               msgline.msgm = date() time() 'CONT:' strip(messseg)\n               message = strip(delstr(message,1,length(messseg)))\n            end\n           end\n        else\n/*********************************************************************/\n/* Build print lines. Default strips and prefixes date and timestamp */\n/* @BLANK - Blank line, no date and timestamp                        */\n/* @      - No stripping, retains leading blanks                     */\n/* @@     - No stripping, No date and timestamp                      */\n/*********************************************************************/\n           do\n            select\n               when message = '@BLANK@' then msgline.msgm = ' '\n               when word(message,1) = '@' then\n                    do\n                     message = substr(message,2,length(message)-1)\n                     msgline.msgm = date() time() message\n                    end\n               when substr(message,1,2) = '@@' then\n                    do\n                     message = substr(message,3,length(message)-2)\n                     msgline.msgm = message\n                    end\n               otherwise msgline.msgm = date() time() strip(message)\n            end\n           end\n/*********************************************************************/\n/* If a number is provided, add that number of blank lines after     */\n/* the message                                                       */\n/*********************************************************************/\n        if msglines > 0 then\n           do msgt=1 to msglines\n              msge = msgt + msgm\n              msgline.msge = ' '\n           end\n/*********************************************************************/\n/* Write the contents of the MSGLINE stem to the MSGDD               */\n/*********************************************************************/\n        call tsotrap \"EXECIO * DISKW\" msgdd \"(STEM MSGLINE. FINIS\"\n        drop msgline. msgb msgt msge\n        pull tracelvl . module . sigl . sparms\n        call modtrace 'STOP' sigl\n        interpret 'trace' tracelvl\n        return\n/*********** @REFRESH END   SAYDD    2004/03/29 23:48:37 *************/\n/*********** @REFRESH BEGIN JOBINFO  2002/09/11 01:12:59 *************/\n/* JOBINFO  - Get job related data from control blocks               */\n/*                                                                  */\n/* ITEM     - Optional item number desired, default is all           */\n/*********************************************************************/\n jobinfo: module = 'JOBINFO'\n          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n          parse arg sparms\n          push trace() time('L') module 'From:' sigl 'Parms:' sparms\n          call modtrace 'START' sigl\n          arg item\n/*********************************************************************/\n/* Chase control blocks                                              */\n/*********************************************************************/\n          tcb      = ptr(540)\n          ascb     = ptr(548)\n          tiot     = ptr(tcb+12)\n          jscb     = ptr(tcb+180)\n          ssib     = ptr(jscb+316)\n          asid     = c2d(stg(ascb+36,2))\n          jobtype  = stg(ssib+12,3)\n          jobnum   = strip(stg(ssib+15,5),'L',0)\n          stepname = stg(tiot+8,8)\n          procstep = stg(tiot+16,8)\n          program  = stg(jscb+360,8)\n          jobdata  = jobtype jobnum stepname procstep program asid\n/*********************************************************************/\n/* Return job data                                                   */\n/*********************************************************************/\n          if item <> '' & (datatype(item,'W') = 1) then\n             do\n              pull tracelvl . module . sigl . sparms\n              call modtrace 'STOP' sigl\n              interpret 'trace' tracelvl\n              return word(jobdata,item)\n             end\n          else\n             do\n              pull tracelvl . module . sigl . sparms\n              call modtrace 'STOP' sigl\n              interpret 'trace' tracelvl\n              return jobdata\n             end\n/*********** @REFRESH END   JOBINFO  2002/09/11 01:12:59 *************/\n/*********** @REFRESH BEGIN PTR      2002/07/13 15:45:36 *************/\n/* PTR      - Pointer to a storage location                          */\n/*                                                                  */\n/* ARG(1)   - Storage Address                                        */\n/*********************************************************************/\n ptr: return c2d(storage(d2x(arg(1)),4))\n/*********** @REFRESH END   PTR      2002/07/13 15:45:36 *************/\n/*********** @REFRESH BEGIN STG      2002/07/13 15:49:12 *************/\n/* STG      - Return the data from a storage location                */\n/*                                                                  */\n/* ARG(1)   - Location                                               */\n/* ARG(2)   - Length                                                 */\n/*********************************************************************/\n stg: return storage(d2x(arg(1)),arg(2))\n/*********** @REFRESH END   STG      2002/07/13 15:49:12 *************/\n/*********** @REFRESH BEGIN VIODD    2004/06/08 11:17:36 *************/\n/* VIODD    - EXECIO a stem into a sequential dataset                */\n/*                                                                  */\n/* VIODD    - The member to create                                   */\n/* VIOLRECL - The LRECL for the VIODD (defaults to 80)               */\n/*********************************************************************/\n viodd: module = 'VIODD'\n        if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'\n        parse arg sparms\n        push trace() time('L') module 'From:' sigl 'Parms:' sparms\n        call modtrace 'START' sigl\n        arg viodd violrecl viorecfm\n        if viodd = '' then call rcexit 88 'VIODD missing'\n        if violrecl = '' then violrecl = 80\n        if viorecfm = '' then viorecfm = 'F B'\n/*********************************************************************/\n/* If DD exists, FREE it                                             */\n/*********************************************************************/\n        if listdsi(viodd 'FILE') = 0 then\n           call tsotrap \"FREE F(\"viodd\")\"\n/*********************************************************************/\n/* ALLOCATE a VIO DSN                                                */\n/*********************************************************************/\n        call tsotrap \"ALLOC F(\"viodd\") UNIT(\"@vio\") SPACE(1 5)\",\n                     \"LRECL(\"violrecl\") BLKSIZE(0) REUSE\",\n                     \"RECFM(\"viorecfm\") CYLINDERS\"\n/*********************************************************************/\n/* Write the stem variables into the VIO DSN                         */\n/*********************************************************************/\n        call tsotrap \"EXECIO * DISKW\" viodd \"(STEM\" viodd\". FINIS\"\n/*********************************************************************/\n/* DROP the stem variable                                            */\n/*********************************************************************/\n        interpret 'drop' viodd'.'\n        pull tracelvl . module . sigl . sparms\n        call modtrace 'STOP' sigl\n        interpret 'trace' tracelvl\n        return\n/*********** @REFRESH END   VIODD    2004/06/08 11:17:36 *************/\n/*********** @REFRESH BEGIN MODTRACE 2003/12/31 21:56:54 *************/\n/* MODTRACE - Module Trace                                           */\n/*                                                                  */\n/* TRACETYP - Type of trace entry                                    */\n/* SIGLINE  - The line number called from                            */\n/*********************************************************************/\n modtrace: if modtrace = 'NO' then return\n           arg tracetyp sigline\n           tracetyp = left(tracetyp,5)\n           sigline = left(sigline,5)\n/*********************************************************************/\n/* Adjust MODSPACE for START                                         */\n/*********************************************************************/\n           if tracetyp = 'START' then\n              modspace = substr(modspace,1,length(modspace)+1)\n/*********************************************************************/\n/* Set the trace entry                                               */\n/*********************************************************************/\n           traceline = modspace time('L') tracetyp module sigline sparms\n/*********************************************************************/\n/* Adjust MODSPACE for STOP                                          */\n/*********************************************************************/\n           if tracetyp = 'STOP' then\n              modspace = substr(modspace,1,length(modspace)-1)\n/*********************************************************************/\n/* Determine where to write the traceline                            */\n/*********************************************************************/\n           if ispfenv = 'YES' & tsoenv = 'FORE' then\n/*********************************************************************/\n/* Write to the ISPF Log, do not use ISPWRAP here                    */\n/*********************************************************************/\n              do\n               zedlmsg = traceline\n               address ISPEXEC \"LOG MSG(ISRZ000)\"\n              end\n           else\n              say traceline\n/*********************************************************************/\n/* SAY to SYSTSPRT                                                   */\n/*********************************************************************/\n           return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QUICKXMI": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x13\"o\\x01\\x13\"o!\\x03\\x00=\\x00=\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T21:03:06", "lines": 61, "newlines": 61, "modlines": 0, "user": "SBGOLOB"}, "text": "In a message dated 5/4/2007 8:05:50 AM US Mountain Standard Time,\ngilmap@unix.stortek.com writes:\n\nAnd I dearly wish I could make \"address TSO RECEIVE\" work from\nthe UNIX Rexx environment, especially with no terminal\ninteraction, as I can achieve by queueing the response in the TSO\nRexx environment.  Is this one of the things that does a TGET\nwhen it would better do a GETLINE?\n\nSubject:  Re: REXX / OE calling REXX on MVS\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     5/4/2007 11:29 AM\n\nI was able to get TSO RECEIVE to work in a telnet session using a\nREXX wrapper.  The QUICKXMI and QUICKREC EXEC's live in a PDS and\nthe MVSTSO.REX is in a directory.  I launched the QUICKREC using\nmy MVSTSO.REX EXEC in a telnet session (see below).  I also have\na LISTDSI wrapper that returns LISTDSI values.  I run it the same\nway.  What additional benefit would you get from doing address\nTSO RECEIVE?\n\n/* rexx -  QUICKXMI */\narg  dsn\ndsn =  strip(dsn,'B',\"'\")\nxmidsn =  dsn'.XMIT'\ndsn =  \"'\"dsn\"'\"\nxmidsn =  \"'\"xmidsn\"'\"\n\"TRANSMIT\" sysvar('SYSNODE')'.'userid()  \"DSNAME(\"dsn\")\",\n\"OUTDSNAME(\"xmidsn\") SYSOUT(Z)  NOLOG\"\n\n/* rexx -  QUICKREC */\narg  xmidsn\nsay 'Make sure the XMI dataset was uploaded in FB80  format'\nxmidsn =  strip(xmidsn,'B',\"'\")\nif  pos('.XMIT',xmidsn) <> 0  then\nparse var xmidsn dsn  '.XMIT'\ndsn =  \"'\"dsn\"'\"\nxmidsn =  \"'\"xmidsn\"'\"\nprompt_on =  prompt('on')\nqueue  \"DSNAME(\"dsn\")\"\nqueue  \"SYSOUT(Z)\"\n\"RECEIVE INDSNAME(\"xmidsn\")  NODISPLAY\"\n\n/* rexx -  MVSTSO.REX */\narg rexxmem rexxdsn  rexxparms\naddress TSO \"EX '\"rexxdsn\"(\"rexxmem\")' '\"rexxparms\"'\"\n\ntelnet command:\n\n$ mvstso.rex quickrec my.exec my.c.test.xmit\nMake sure the XMI dataset was uploaded in FB80 format\nINMR901I Dataset  MY.C.TEST from MY on N001\nINMR906A Enter restore parameters or 'DELETE'  or 'END' +\nINMR908A The input file attributes are: DSORG=PARTITIONED,\nRECFM=FB, BLKSIZE=11440, LRECL=80, File size=58K bytes +\nINMR909A You may  enter DSNAME, SPACE, UNIT, VOL, OLD/NEW, or\nRESTORE/COPY/DELETE/END\nINMR001I  Restore successful to dataset 'MY.C.TEST'\n\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESTJOB": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01\\x13\"\\x8f\\x01\\x13$O!%\\x00<\\x00<\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-16T00:00:00", "modifydate": "2013-09-01T21:25:13", "lines": 60, "newlines": 60, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: IDCAMS\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     3/31/2006 1:45 AM\n\nThis was created for production control/job scheduling purposes.\nWhen this is the first step of a job (or any step that would\ncreate restart instructions requiring anything other than \"rerun\nfrom the top\"), a FLUSH is just as effective as a non-zero return\ncode.\n\nThe logic behind using a step that confirms the file does exist\nand provides a testable return code gives the production control\nperson proof the file was successfully created and removes the\npossibility of an NFS mount problem from the mix.  We also put a\nMNTCHECK step (another homegrown utility that confirms the\nrequired mount is valid and/or mounts it if missing) before every\nNFS file using job (and some HFS users when the mounts are not in\nBPXPRMxx).  These steps help whittle down the list of potential\nproblems and allows the production control person to pass on to\nthe support personnel what did work as well as what failed during\nthe job to speed up the problem determination.  We also have some\nJCL standards where we like to create everything needed for the\njob up front and hang additional processing on a successful\npredecessor step in our production jobs.\n\nAs far as eliminating the JCL ERROR, here is another version to\neliminate that if you prefer.  The difference here is the ALLOC\nis put inside the EXEC and the FILE DD is removed from the\nJCL/PROC.  This puts the error messages in the SYSTSPRT SYSOUT of\nthe step instead of the JOBLOG.  It does limit the flexibility of\nusing more PATH DD options.  The name BPXEXIST doesn't seem to be\naccurate anymore, so call it what you want if you want to use it.\n\n/**************************** REXX ***********************************/\n/*  Accept  filename                                                 */\n/*********************************************************************/\nparse  arg file  access\nif file = '' then exit  20\nif access = ''  then\naccess =  'SIRWXU,SIRWXG,SIRWXO'\n/*********************************************************************/\n/*  Heading                                                          */\n/*********************************************************************/\nsay  mvsvar('SYSNAME') mvsvar('SYMDEF','JOBNAME') date()  time()\nsay\n/*********************************************************************/\n/*  Attempt to ALLOC the  file                                       */\n/*********************************************************************/\n\"ALLOC  F(FILE) PATH('\"file\"')  PATHOPTS(OWRONLY,OCREAT)\",\n\"PATHMODE(\"access\")  PATHDISP(KEEP,DELETE)\"\nif RC <> 0 then exit  1\n/*********************************************************************/\n/*  Confirm file is  there                                           */\n/*********************************************************************/\n command = 'ls'  file\nexit  BPXWUNIX(command,'DD:stdin','DD:stdout','DD:stderr','0')\n\n\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXECX": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x13\"o\\x01\\x13\"o\"\\x08\\x00\\x83\\x00\\x83\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T22:08:35", "lines": 131, "newlines": 131, "modlines": 0, "user": "SBGOLOB"}, "text": "In a message dated 4/24/2007 8:44:17 AM US Mountain Standard Time,\nfabrice.vallet@mpsa.com writes:\n\nWe try to use RSH in batch to execute commande on Unix remote\nsystem with:\n\n//RSH31 EXEC PGM=RSH\n//      PARM='/-d -l p723487  ylai0057 ls -ali PASLA*  '\n\nIt's ok but we want to trap a non zero return code?\n\nThe RSH always return 00 whereas in the sysprint we have a\nmessage with:\n\nEZA5046I  rsh invoked;\nData socket = 1   Control socket = 3\nls: 0653-341 The file PASLA* does not exist.\nEZA5048I  rsh complete\n\nDo you have some an idea  ?\n---------------------------------------------------------------\n\nSubject:  Re: RSH return code\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     4/24/2007 12:53 PM\n\nRSH and REXEC only give the RC for the RSH or REXEC process\nitself.  Was it able to connect and send the command?  If so,\nRC=0.  Nice to know, but usually not what you want.  The only way\nthat I know to do this is to scrape the SYSPRINT with a REXX\nEXEC.  This is not foolproof, but can work and may require some\ntailoring for specific commands.\n\nThe REXECX REXX EXEC is designed to work with REXEC, but could\neasily be changed to RSH.  It appends a ';echo RC=$?' to end of\nany command.  The REXX EXEC then looks for the eyecatcher 'RC='\nto find the RC and exits with that value so your JCL reports the\ncorrect RC.\n\nREXECX REXX EXEC\n\n/****************************** REXX *********************************/\n/*  Purpose: REXEC in batch to return a valid RC from the Remote CMD */\n/*-------------------------------------------------------------------*/\n/*  Syntax:  REXECX host  command                                    */\n/*-------------------------------------------------------------------*/\n/*  Parms: HOST       - IP Address or DNS name for  target host      */\n/*        COMMAND    -  Command to execute on the remote  host       */\n/*                                                                   */\n/* Notes: Requires a valid NETRC file in the  JCL                    */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   ---------------------------------------- */\n/*  R.  Zenuk    Sep 2004   Initial  Creation                        */\n/*                                                                   */\n/*********************************************************************/\n/*  Accept  parms                                                    */\n/*********************************************************************/\nparse  arg host  command\n/*********************************************************************/\n/*  If NETRC is allocated, open and  parse                           */\n/*********************************************************************/\nif  listdsi(\"NETRC\" \"FILE\") = 0 then\ndo\n\"EXECIO * DISKR NETRC (STEM NETRC. FINIS\"\ndo n=1 to  netrc.0\nparse var netrc.n .  hostname . uid . pw .\nif hostname  = host then leave\nend\nend\nelse\ndo\nsay  'NETRC file is missing RC=20'\nexit  20\nend\n/*********************************************************************/\n/*  Format the REXEC command and append the ECHO  RC=$?              */\n/*********************************************************************/\n\"REXEC  -l\" uid \"-p\" pw host command\";echo RC=$?\"\nif RC <> 0 then exit  RC\n/*********************************************************************/\n/*  Read the contents of the OUTPUT DD (Remote  output)              */\n/*********************************************************************/\n\"EXECIO  * DISKR OUTPUT (STEM OUTPUT.  FINIS\"\n/*********************************************************************/\n/*  Display the  output                                              */\n/*********************************************************************/\ndo  o=1 to output.0\nsay  strip(output.o)\nend\n/*********************************************************************/\n/*  Check last line for RC= string and EXIT with the CMDRC value ($?) */\n/*********************************************************************/\nlast  = output.0\nif left(output.last,3) = 'RC=' then\ndo\nparse var output.last 'RC=' cmdrc  .\nexit cmdrc\nend\nelse\ndo\nsay  'Error: Did not find RC= in the last line'\nsay 'Last  line was:' output.last\nexit 12\nend\n\n\nSample JCL:\n\n//jobcard...\n//***************************************************************\n//*  REXEC  COMMANDS                                            *\n//***************************************************************\n//REXEC     EXEC  PGM=IKJEFT01,\n//         PARM='REXECX  yourserverdsnname ls -ali PASLA*'\n//SYSEXEC  DD    DSN=your.EXEC,DISP=SHR\n//OUTPUT   DD    UNIT=VIO,SPACE=(TRK,(1,10),RLSE),RECFM=VB,LRECL=1000\n//NETRC     DD   DSN=your.NETRC(yourmem),DISP=SHR\n//SYSPRINT DD    SYSOUT=*\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD    DUMMY\n\nLet me know if this came through without the indentation (I hate\nit when that happens) and I'll send you a copy directly.\n\nHope This Helps,\nRob\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDSF2ZFS": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x13\"?\\x01\\x13\"?\\x17G\\x00\\x9a\\x00\\x9a\\x00\\x00\\xd9\\xe9\\xc5\\xd5\\xe4\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-11T00:00:00", "modifydate": "2013-08-11T17:47:11", "lines": 154, "newlines": 154, "modlines": 0, "user": "RZENUK"}, "text": "/******************************* REXX ********************************/\n/* Purpose: Select specific spool output and write it to unique dirs */\n/*-------------------------------------------------------------------*/\n/* Syntax:  SDSF2ZFS                                                 */\n/*-------------------------------------------------------------------*/\n/* Parms: PATTERN   - Valid SDSF PREFIX value (def: current jobname) */\n/*        LPAR      - Valid SDSF SYSNAME value (def: all LPAR's)     */\n/*        PATH      - Path to output location                        */\n/*        MODE      - Path mode (i.e. rwx=644)                       */\n/*                                                                   */\n/* Return Codes: 00 - Good                                           */\n/*               12 - Probable TSO command error                     */\n/*               16 - SDSF errors                                    */\n/*               20 - Path missing                                   */\n/*               21 - Root path exists and is not a directory        */\n/*               98 - USS Dubbing error                              */\n/*               99 - SDSF initialization error                      */\n/*                                                                   */\n/*********************************************************************/\n/*                      Change Log                                   */\n/*                                                                   */\n/*  Author       Date      Reason                                    */\n/*  --------    ---------  ----------------------------------------- */\n/*  R. Zenuk    Sep 2012   Initial Creation                          */\n/*                                                                   */\n/*********************************************************************/\n/* Accept the JOB prefix                                             */\n/*********************************************************************/\n parse arg pattern lpar path mode .\n if pattern = '' then\n    pattern = mvsvar('SYMDEF','JOBNAME')\n if lpar = '' then\n    lpar = '*'\n if path = '' then\n    do\n     say 'PATH missing, RC=20'\n     exit 20\n    end\n if mode = '' then\n    mode = '644'\n isfprefix  = pattern\n isfsysname = lpar\n out.0 = 0\n/*********************************************************************/\n/* Dub the address space                                             */\n/*********************************************************************/\n if syscalls('ON') > 1 then exit 98\n/*********************************************************************/\n/* Check if the root path exists                                     */\n/*********************************************************************/\n path = strip(path,'T','/')\n RETVAL = ussapi('stat' path 'stat.')\n select\n/*********************************************************************/\n/* If missing create it                                              */\n/*********************************************************************/\n   when RETVAL <> 0 | ERRNO <> 0 | ERRNOJR <> 0 then\n        fd = ussapi('mkdir' path '777')\n/*********************************************************************/\n/* If not a directory exit RC=21                                     */\n/*********************************************************************/\n   when stat.ST_TYPE <> S_ISDIR then\n        do\n         say '\"root\"' path 'exists and is not a directory, RC=21'\n         exit 21\n        end\n   otherwise nop\n end\n/*********************************************************************/\n/* Invoke SDSF DA using the prefix                                   */\n/*********************************************************************/\n if isfcalls('ON') <> 0 then exit 99\n call sdsfapi \"ISFEXEC H\"\n/*********************************************************************/\n/* Find the matching jobnames                                        */\n/*********************************************************************/\n do j=1 to isfrows\n/*********************************************************************/\n/* Select the jobname and allocate all the output sysout datasets    */\n/*********************************************************************/\n    say jname.j jobid.j\n    call sdsfapi \"ISFACT H TOKEN('\"token.j\"') PARM(NP ?) (PREFIX $\"\n/*********************************************************************/\n/* Create the target directory                                       */\n/*********************************************************************/\n    jobpath = path'/'jname.j':'jobid.j\n    fd = ussapi('mkdir' jobpath mode)\n/*********************************************************************/\n/* Read the DD list for each job                                     */\n/*********************************************************************/\n    do d=1 to $ddname.0\n       call sdsfapi \"ISFACT H TOKEN('\"$token.d\"') PARM(NP SA)\"\n/*********************************************************************/\n/* Read each SYSOUT                                                  */\n/*********************************************************************/\n       say jname.j $ddname.d isfddname.d isfdsname.d\n       address TSO \"EXECIO * DISKR\" isfddname.1 \"(STEM OUT. FINIS\"\n       say jname.j $ddname.d isfddname.1 isfdsname.1 'RECORDS='out.0\n/*********************************************************************/\n/* Write the output file                                             */\n/*********************************************************************/\n       filepath = jobpath'/'$ddname.d\n       fd = ussapi('writefile' filepath mode 'out.')\n       drop out.\n    end\n end\n say\n call isfcalls 'OFF'\n exit 0\n/*********************************************************************/\n/* SDSF error conditions                                             */\n/*********************************************************************/\n sdsfapi: parse arg sdsfcall\n          address SDSF sdsfcall\n          select\n/*********************************************************************/\n/* Ignorable conditions                                              */\n/*********************************************************************/\n            when isfmsg = '' then return\n            when isfmsg = 'DATA SET ALLOCATED' then return\n/*********************************************************************/\n/* Real errors - always RC=16                                        */\n/*********************************************************************/\n            otherwise\n                 do\n                  say isfmsg\n                  say\n                  do e=1 to isfmsg2.0\n                     say sdsfcall right(e,2)':' isfmsg2.e\n                  end\n                  exit 16\n                 end\n          end\n/*********************************************************************/\n/* USS API subroutine                                                */\n/*********************************************************************/\n ussapi: parse arg usscmd\n         address SYSCALL usscmd\n         say 'RETVAL='RETVAL 'ERRNO='ERRNO 'ERRNOJR='ERRNOJR,\n             'CMD='usscmd\n         if ERRNO <> 0 | ERRNOJR <> 0 then\n            do\n             say center(' 'usscmd' ',76,'-')\n             address SYSCALL 'strerror' ERRNO ERRNOJR 'err.'\n             say\n             say err.SE_ERRNO\n             say\n             parse var err.SE_REASON . '15'x errmsg\n             say errmsg\n             say\n             say err.SE_ACTION\n             say center(' 'usscmd' ',76,'-')\n            end\n         return RETVAL\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYMREP": {"ttr": 2316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00#\\x01\\x13\"o\\x01\\x13\"o\"\\x10\\x00\\xa2\\x00\\xa4\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-08-14T00:00:00", "modifydate": "2013-08-14T22:10:23", "lines": 162, "newlines": 164, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Using system symbol to form a filename to be FTP-ed\nFrom:     Aitor San Juan <asanjuan@bolsabilbao.es>\nDate:     6/22/2007 3:05 AM\n\nOh, thanks a lot, Robert. That's been very kind of you.\nThanks also to Roland.\n\nI think my colleagues will use my JCL inside another bigger JCL\nskeleton which will be passed the necessary parameters through a\nCList, as they don't use REXX in this installation.  However,\nI'll bear in mind Robert's approach using REXX to simulate the\nsystem's symbolic substitution.\n\nI thought that getting today's date in a simple JCL was more\nstraightforward.  Anyways, I'm very thankful to both of you.\n\nRegards,\nAitor.\n\n-----Original message-----\nDe: MVS OpenEdition [mailto:MVS-OE@VM.MARIST.EDU]En nombre de Robert\nZenuk\nEnviado el: jueves, 21 de junio de 2007 18:00\nPara: MVS-OE@VM.MARIST.EDU\nAsunto: Re: Using system symbol to form a filename to be FTP-ed\n\nThere are a couple issues here.  First, you can not use symbolics\nin any \"DD *\" input.  This is not valid JCL substitution syntax\nbut the JES  Converter/Interpreter does not produce a JCL error.\nThe \"DD *\" input is just passed \"as is\" to the program (by\ndesign).  Symbolics can only be used on lines (after the\njbocard) that begin with \"//\".  Second, normal batch jobs can not\nuse the  system symbols (except &SYSUID), only Started Tasks can\nuse them.\n\nIt was mentioned to use REXX.  Here is a quick and dirty way to\naccomplish  what you want, by using a SYSIN massager and passing\nthe results as a temporary dataset.  The SYMREP REXX EXEC will\nlook for all MVSVAR's in an input file  and replace them with\ntheir actual values.  The symbol syntax must use the trailing\n\".\" to work.\n\nSample JCL:\n\n//***************************************************************\n//*  SYMREP                                                     *\n//***************************************************************\n//SYMREP    EXEC  PGM=IKJEFT01,PARM=SYMREP\n//SYSEXEC  DD    DSN=OPSROZ.EXEC,DISP=SHR\n//SYSTSPRT DD    SYSOUT=*\n//SYSTSIN  DD    DUMMY\n//INPUT    DD    *\n10.1.2.3\nUSERID  PASSWD\nCD  /USERID/LOG\nPUT '&SYSNAME..S0001.RECORD.CSV'  &LYYMMDD._SESSION.CSV\nQUIT\n//OUTPUT   DD    DSN=&INPUT,DISP=(,PASS),UNIT=VIO,SPACE=(TRK,1)\n//***************************************************************\n//*  PRINT                                                      *\n//***************************************************************\n//PRINT     EXEC  PGM=IEBGENER\n//SYSPRINT DD    SYSOUT=Z\n//SYSUT1   DD    DSN=&INPUT,DISP=(OLD,DELETE)\n//SYSUT2   DD    SYSOUT=*\n//SYSIN    DD    DUMMY\n\nSYMREP REXX EXEC (if it loses the indentation and you want good\ncopy, let me  know OFFLIST):\n\n/****************************** REXX *********************************/\n/*  Purpose: Read input and replace all the  MVSVAR's                */\n/*-------------------------------------------------------------------*/\n/*  Syntax:   SYMREP                                                 */\n/*-------------------------------------------------------------------*/\n/*  Parms: N/A        -  N/A                                         */\n/*                                                                   */\n/* Notes: All System Symbols MUST use strict syntax  (&xxx.          */\n/*        JCL MUST include INPUT and  OUTPUT  DD's                   */\n/*                                                                   */\n/* Sample  JCL:                                                      */\n/*                                                                   */\n/* //SYMREP   EXEC  PGM=IKJEFT01,PARM=SYMREP                         */\n/* //SYSEXEC  DD    DSN=OPSROZ.EXEC,DISP=SHR                         */\n/* //SYSTSPRT DD    SYSOUT=*                                         */\n/* //SYSTSIN  DD    DUMMY                                            */\n/* //INPUT    DD    *                                                */\n/*  10.1.2.3                                                         */\n/* USERID  PASSWD                                                    */\n/* CD  /USERID/LOG                                                   */\n/* PUT '&SYSNAME..S0001.RECORD.CSV'  &LYYMMDD._SESSION.CSV           */\n/*  QUIT                                                             */\n/* //OUTPUT   DD    DSN=&INPUT,DISP=(,PASS),UNIT=VIO,SPACE=(TRK,1)   */\n/*                                                                   */\n/*********************************************************************/\n/*                       Change  Log                                 */\n/*                                                                   */\n/*  Author        Date       Reason                                  */\n/*  --------    ---------   ---------------------------------------- */\n/*  R.  Zenuk    Jun 2007   Initial  Creation                        */\n/*                                                                   */\n/*********************************************************************/\n/*  Read  input                                                      */\n/*********************************************************************/\n\"EXECIO  * DISKR INPUT (STEM INPUT.  FINIS\"\n/*********************************************************************/\n/*  Pass each line through the  substitution                         */\n/*********************************************************************/\ndo  i=1 to input.0\noutput.i =  symsub(input.i)\nend\n/*********************************************************************/\n/*  Write the new  output                                            */\n/*********************************************************************/\n\"EXECIO  * DISKW OUTPUT (STEM OUTPUT. FINIS\"\nexit  0\n/*********************************************************************/\n/*  Replace a system symbol in a string using  MVSVAR                */\n/*********************************************************************/\nsymsub:  procedure\nparse arg  string\nstart =  1\ndo  forever\namper =  pos('&',string,start)\nif amper <> 0  then\ndo\nperiod =  pos('.',string,amper)\nif period <> 0  then\ndo\nsym =  substr(string,amper,period-amper+1)\nsb  =  amper+1\nse  =  period-amper-1\nval =  mvsvar('SYMDEF',substr(string,sb,se))\nstring =  chgstr(string,val,sym)\nend\nelse\nreturn  string\nend\nelse\nreturn string\nend\n/*********************************************************************/\n/*  Replace a string with another  string                            */\n/*********************************************************************/\nchgstr:  procedure\nif arg() < 3  then\nreturn 'chgstr: missing args, must have string, new and  old'\nparse arg string, new,  old, style\nlnew =  length(new)\nlold =  length(old)\nx =  1\ndo  forever\nif  pos(old,string,x) = 0 then return  string\nx =  pos(old,string,x)\nstring =  insert(new,delstr(string,x,lold),x-1,lnew)\nx = x + length(new)\nend\n\n\nHope This Helps,\n\nRob\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNIXCMD$": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x13\"?\\x01\\x13\"?\\x15)\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-11T00:00:00", "modifydate": "2013-08-11T15:29:30", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: Useful (to me) little TSO REXX program\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     7/27/2011 1:40 AM\n\nHere is another version that uses ISPF BROWSE for the output...\n(Note. The original version came from John McKown.)\n(Note. I changed UNIT(VIO) to UNIT(SYSDA) on my system. SBG)\n\nThis is a way to execute UNIX commands under TSO and to see the\nresults.  This command should probably be renamed as UNIX.\n\n\n/* rexx - unixcmd  */\n parse arg  unixcmd\n if syscalls('ON') <> 0 then 'say Error setting up  SYSCALLS env'\n URC =  BPXWUNIX(unixcmd,,stdout.,stderr.,'0')\n if stdout.0 > 0 then call output  stdout\n if stderr.0 > 0 then call output  stderr\n exit  URC\n output: arg dd  .\n         zedlmsg =  \"'\"unixcmd\"', RC=\"URC \"- output from\" dd\n         outdsn =  userid()'.UNIX.'dd\n         if  sysdsn(\"'\"outdsn\"'\") = 'OK' then DELETE \"'\"outdsn\"'\"\n        \"ALLOC F(\"dd\")  DA('\"outdsn\"') UNIT(VIO) SPACE(1 10)  CYL\",\n         \"LRECL(133)\"\n        \"EXECIO * DISKW\" dd  \"(STEM\" dd\".  FINIS\"\n         address ISPEXEC  \"SETMSG  MSG(ISRZ000)\"\n         address ISPEXEC  \"BROWSE  DATASET('\"outdsn\"')\"\n        \"FREE F(\"dd\")  DELETE\"\n          return\n\nRob\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNIXCMDB": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x13\"?\\x01\\x13\"?\\x15\\x13\\x00\\x12\\x00\\x12\\x00\\x00\\xd9\\xe9\\xc5\\xd5\\xe4\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-08-11T00:00:00", "modifydate": "2013-08-11T15:13:32", "lines": 18, "newlines": 18, "modlines": 0, "user": "RZENUK"}, "text": "/* rexx - unixcmd  */\n parse arg  unixcmd\n if syscalls('ON') <> 0 then 'say Error setting up  SYSCALLS env'\n URC =  BPXWUNIX(unixcmd,,stdout.,stderr.,'0')\n if stdout.0 > 0 then call output  stdout\n if stderr.0 > 0 then call output  stderr\n exit  URC\n output: arg dd  .\n         zedlmsg =  \"'\"unixcmd\"', RC=\"URC \"- output from\" dd\n         outdsn =  userid()'.UNIX.'dd\n         if  sysdsn(\"'\"outdsn\"'\") = 'OK' then DELETE \"'\"outdsn\"'\"\n        \"ALLOC F(\"dd\")  DA('\"outdsn\"') UNIT(SYSDA) SPACE(1 10) CYL\",\n         \"LRECL(133)\"\n        \"EXECIO * DISKW\" dd  \"(STEM\" dd\".  FINIS\"\n         address ISPEXEC  \"SETMSG  MSG(ISRZ000)\"\n         address ISPEXEC  \"BROWSE  DATASET('\"outdsn\"')\"\n        \"FREE F(\"dd\")  DELETE\"\n          return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USSFILM$": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x13\"?\\x01\\x13\"?\\x19\\x18\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-11T00:00:00", "modifydate": "2013-08-11T19:18:33", "lines": 9, "newlines": 9, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Re: How to list the content of an HFS or zFS file\nFrom:     Robert Zenuk <Robzenuk@aol.com>\nDate:     6/10/2011 7:33 PM\n\nHere is a quick little REXX EXEC that lists all the mountpoints\nand HFS/zFS files...  This will find them regardless of whether\nthey were mounted by BPXPRMxx, Automount or user entered MOUNT\ncommands.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USSFILMT": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x13\"?\\x01\\x13\"?\\x149\\x00\\x08\\x00\\x08\\x00\\x00\\xd9\\xe9\\xc5\\xd5\\xe4\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-08-11T00:00:00", "modifydate": "2013-08-11T14:39:08", "lines": 8, "newlines": 8, "modlines": 0, "user": "RZENUK"}, "text": "/* rexx  */\n if syscalls('ON') <> 0  then\n    say 'Error dubbing'  mvsvar('SYMDEF',JOBNAME)\n address SYSCALL 'getmntent'  'm.'\n do i=1 to  m.0\n    if m.MNTE_FSTYPE.i = 'HFS' |   m.MNTE_FSTYPE.i = 'ZFS' then\n        say m.MNTE_FSTYPE.i m.MNTE_FSNAME.i m.MNTE_PATH.i\n  end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "USSGETMT": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\"\\x01\\x13\"\\x0f\\x01\\x13\"?\\x14\\'\\x00N\\x00Y\\x00\\x00\\xd9\\xe9\\xc5\\xd5\\xe4\\xd2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2013-08-08T00:00:00", "modifydate": "2013-08-11T14:27:22", "lines": 78, "newlines": 89, "modlines": 0, "user": "RZENUK"}, "text": "/****************************** REXX *********************************/\n/* Purpose: Print the Mount Table with selected details              */\n/*-------------------------------------------------------------------*/\n/* Syntax:  USSGETMT                                                 */\n/*-------------------------------------------------------------------*/\n/* Parms: N/A        - N/A                                           */\n/*                                                                   */\n/*********************************************************************/\n/*                      Change Log                                   */\n/*                                                                   */\n/*  Author       Date      Reason                                    */\n/*  --------    ---------  ----------------------------------------- */\n/*  R. Zenuk    Dec 2001   Initial Creation                          */\n/*                                                                   */\n/*********************************************************************/\n/* Dub the address space                                             */\n/*********************************************************************/\n EXITRC = 0\n if syscalls('ON') <> 0 then\n    do\n     EXITRC = RC\n     msg = 'Error dubbing RC='EXITRC\n     say msg\n    end\n/*********************************************************************/\n/* GETMNTENT                                                         */\n/*********************************************************************/\n EXITRC = ussapi('getmntent' 'mnt.')\n/*********************************************************************/\n/* Loop through all mounts                                           */\n/*********************************************************************/\n do i=1 to mnt.0\n/*********************************************************************/\n/* Make MODE readable                                                */\n/*********************************************************************/\n    mntmode = mnt.MNTE_MODE.i\n    select\n      when mntmode = MNT_MODE_RDWR       then mode = 'RDWR'\n      when mntmode = MNT_MODE_RDONLY     then mode = 'RDONLY'\n      when mntmode = MNT_MODE_AUNMOUNT   then mode = 'AUNMOUNT'\n      when mntmode = MNT_MODE_CLIENT     then mode = 'CLIENT'\n      when mntmode = MNT_MODE_EXPORT     then mode = 'EXPORT'\n      when mntmode = MNT_MODE_NOAUTOMOVE then mode = 'NOAUTOMOVE'\n      when mntmode = MNT_MODE_NOSEC      then mode = 'NOSEC'\n      when mntmode = MNT_MODE_NOSETID    then mode = 'NOSETID'\n      otherwise mode = 'Unknown='mntmode\n    end\n/*********************************************************************/\n/* Print                                                             */\n/*********************************************************************/\n    say strip(mnt.MNTE_SYSNAME.i),\n        strip(mnt.MNTE_FSTYPE.i),\n        left(mode,10),\n        strip(mnt.MNTE_FSNAME.i),\n        strip(mnt.MNTE_PATH.i),\n        strip(mnt.MNTE_PARM.i)\n end\n exit(EXITRC)\n/*********************************************************************/\n/* USS API subroutine                                                */\n/*********************************************************************/\n ussapi: parse arg usscmd\n         say center(' Before' usscmd' ',76,'-')\n         address SYSCALL usscmd\n         say 'RETVAL='RETVAL 'ERRNO='ERRNO 'ERRNOJR='ERRNOJR\n         if ERRNO <> 0 | ERRNOJR <> 0 then\n            do\n             address SYSCALL 'strerror' ERRNO ERRNOJR 'err.'\n             say\n             say err.SE_ERRNO\n             say\n             parse var err.SE_REASON . '15'x errmsg\n             say errmsg\n             say\n             say err.SE_ACTION\n            end\n         say center(' After' usscmd' ',76,'-')\n         return RETVAL\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT894/FILE894.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT894", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}