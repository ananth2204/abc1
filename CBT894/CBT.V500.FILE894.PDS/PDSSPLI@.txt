Splitting PDSs



//jobcardÂŸ
//***************************************************************
//* SPLIT A PDS                                                 *
//*                                                             *
//* OPTION=ALPHA     1 DSN FOR EACH UNIQUE FIRST CHARACTER OF   *
//*                  THE MEMBER NAME                            *
//* OPTION=EVEN      SPLIT INTO 10 EQUAL DSNS (SAME AS EVEN 10) *
//* OPTION='EVEN NN' SPLIT INTO 'NN' EQUAL DSNS                 *
//* OPTION=NN        SPLIT INTO DSNS EACH HOLDING NN MEMBERS    *
//***************************************************************
//PDSSPLIT PROC
//PDSSPLIT EXEC PGM=IKJEFT01,DYNAMNBR=99,PARM='PDSSPLIT &OPTION'
//SYSEXEC  DD   DSN=yourid.EXEC,DISP=SHR
//SYSTSPRT DD   SYSOUT=*
//SYSTSIN  DD   DUMMY
//DIAGMSGS DD   SYSOUT=*
//INPUT    DD   DSN=&PDS,DISP=SHR
//SYSPRINT DD   SYSOUT=*
//         PEND
//ALPHA    EXEC PDSSPLIT,PDS=yourid.JCL,OPTION=ALPHA
//EVEN10   EXEC PDSSPLIT,PDS=yourid.JCL,OPTION=EVEN
//EVEN3    EXEC PDSSPLIT,PDS=yourid.JCL,OPTION='EVEN 3'
//P100     EXEC PDSSPLIT,PDS=yourid.JCL,OPTION=100


JOBNAME        PDSSPLIT started 23 Sep 2004 22:54:30 on SY01        JOBNAME

    6 $* members copied to YOURID.@001$006.YOURID.JCL RC=0
    1 #* members copied to YOURID.@002#001.YOURID.JCL RC=0
   25 @* members copied to YOURID.@003@025.YOURID.JCL RC=0
    7 A* members copied to YOURID.@004A007.YOURID.JCL RC=0
   20 B* members copied to YOURID.@005B020.YOURID.JCL RC=0
   44 C* members copied to YOURID.@006C044.YOURID.JCL RC=0
   48 D* members copied to YOURID.@007D048.YOURID.JCL RC=0
   13 E* members copied to YOURID.@008E013.YOURID.JCL RC=0
    8 F* members copied to YOURID.@009F008.YOURID.JCL RC=0
    6 G* members copied to YOURID.@010G006.YOURID.JCL RC=0
    4 H* members copied to YOURID.@011H004.YOURID.JCL RC=0
   24 I* members copied to YOURID.@012I024.YOURID.JCL RC=0
    6 J* members copied to YOURID.@013J006.YOURID.JCL RC=0
    1 K* members copied to YOURID.@014K001.YOURID.JCL RC=0
   16 L* members copied to YOURID.@015L016.YOURID.JCL RC=0
   20 M* members copied to YOURID.@016M020.YOURID.JCL RC=0
   19 N* members copied to YOURID.@017N019.YOURID.JCL RC=0
   15 P* members copied to YOURID.@018P015.YOURID.JCL RC=0
    3 Q* members copied to YOURID.@019Q003.YOURID.JCL RC=0
   24 R* members copied to YOURID.@020R024.YOURID.JCL RC=0
   50 S* members copied to YOURID.@021S050.YOURID.JCL RC=0
   27 T* members copied to YOURID.@022T027.YOURID.JCL RC=0
    2 U* members copied to YOURID.@023U002.YOURID.JCL RC=0
    4 V* members copied to YOURID.@024V004.YOURID.JCL RC=0
    7 W* members copied to YOURID.@025W007.YOURID.JCL RC=0
    4 X* members copied to YOURID.@026X004.YOURID.JCL RC=0
    1 Y* members copied to YOURID.@027Y001.YOURID.JCL RC=0
   24 Z* members copied to YOURID.@028Z024.YOURID.JCL RC=0

  429 members copied
   28 datasets created

 JOBNAME    PDSSPLIT ended 23 Sep 2004 22:54:38 8.5 on SY01 RC=0      JOBNAME


JOBNAME        PDSSPLIT started 23 Sep 2004 22:54:38 on SY01        JOBNAME

   43 members copied to YOURID.@001#043.YOURID.JCL RC=0
   43 members copied to YOURID.@002#043.YOURID.JCL RC=0
   43 members copied to YOURID.@003#043.YOURID.JCL RC=0
   43 members copied to YOURID.@004#043.YOURID.JCL RC=0
   43 members copied to YOURID.@005#043.YOURID.JCL RC=0
   43 members copied to YOURID.@006#043.YOURID.JCL RC=0
   43 members copied to YOURID.@007#043.YOURID.JCL RC=0
   43 members copied to YOURID.@008#043.YOURID.JCL RC=0
   43 members copied to YOURID.@009#043.YOURID.JCL RC=0
   42 members copied to YOURID.@010#042.YOURID.JCL RC=0

  429 members copied
   10 datasets created

 JOBNAME    PDSSPLIT ended 23 Sep 2004 22:54:42 3.8 on SY01 RC=0      JOBNAME


JOBNAME        PDSSPLIT started 23 Sep 2004 22:54:44 on SY01        JOBNAME

 100 members copied to YOURID.@001#100.YOURID.JCL RC=0
 100 members copied to YOURID.@002#100.YOURID.JCL RC=0
 100 members copied to YOURID.@003#100.YOURID.JCL RC=0
 100 members copied to YOURID.@004#100.YOURID.JCL RC=0
  29 members copied to YOURID.@005#029.YOURID.JCL RC=0

 429 members copied
   5 datasets created

JOBNAME    PDSSPLIT ended 23 Sep 2004 22:54:47 2.5 on SY01 RC=0      JOBNAME


/****************************** REXX *********************************/
/* Purpose: Copy a PDS to multiple output PDSs based on criteria     */
/*                                                                  */
/* Syntax:  pdssplit criteria                                        */
/*                                                                  */
/* Parms: approach   - number or ALPHA or EVEN                       */
/*                                                                   */
/* Use a number to create multiple PDSs with that number of members  */
/* Use ALPHA to create a PDS for each letter of the alphabet         */
/* Use EVEN nn to create nn PDSs with an even portion of members     */
/*                                                                   */
/* Known issue: a single member copy does not work (creates PS DSN?) */
/*********************************************************************/
/*                      Change Log                                   */
/*                                                                   */
/*  Author       Date      Reason                                    */
/*                                                             */
/*                                                                   */
/*********** @REFRESH BEGIN START    2004/03/06 13:16:32 *************/
/* Standard housekeeping activities                                  */
/*********************************************************************/
 call time 'r'
 parse arg parms
 signal on syntax name trap
 signal on failure name trap
 signal on novalue name trap
 probe = 'NONE'
 modtrace = 'NO'
 modspace = ''
 call stdentry 'DIAGMSGS'
 module = 'MAINLINE'
 push trace() time('L') module 'From:' 0 'Parms:' parms
 if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
 call modtrace 'START' 0
/*********************************************************************/
/* Set local estoeric names                                          */
/*********************************************************************/
 @vio   = 'VIO'
 @sysda = 'SYSDA'
/*********** @REFRESH END   START    2004/03/06 13:16:32 *************/
/* Accept and validate parms                                         */
/*********************************************************************/
 arg parm evencount .
 if parm = '' then
    parm = 'ALPHA'
 select
   when datatype(parm,'W') = 1 then parm = parm
   when parm = 'ALPHA' then parm = 'ALPHA'
   when parm = 'EVEN' then
        do
         parm = 'EVEN'
         if evencount = '' then evencount = 10
        end
   otherwise
      call rcexit 20 'Invalid parm:' parm', whole number, "ALPHA"',
          'or "EVEN"'
 end
 call saydd msgdd 1 'Parm used:' parm
/*********************************************************************/
/* Make sure the INPUT DD exists                                     */
/*********************************************************************/
 call ddcheck 'INPUT'
 source = sysdsname
/*********************************************************************/
/* Set initial defaults                                              */
/*********************************************************************/
 totcount = 0
 check = 1
 last = ''
 sets = -1
/*********************************************************************/
/* Get member names from the PDS                                     */
/*********************************************************************/
 call outtrap 'mem.'
"LISTDS '"source"' MEMBERS"
 x = outtrap('off')
/*********************************************************************/
/* Set option specific defaults                                      */
/*********************************************************************/
 select
   when parm = 'ALPHA' then mcount = 0
   when parm = 'EVEN' then
        do
         parm = format(((mem.0-7)/evencount),,0)
         mcount = parm + 1
        end
   otherwise mcount = parm + 1
 end
/*********************************************************************/
/* Process the members                                               */
/*********************************************************************/
 do i=7 to mem.0
    totcount = totcount + 1
    member = strip(mem.i)
/*********************************************************************/
/* Process ALPHA                                                     */
/*********************************************************************/
    if parm = 'ALPHA' then
       do
        char1 = substr(member,1,1)
        if char1 = last then
           do
            mcount = mcount + 1
            sysin.mcount = cont('                 'member',')
           end
        else
           do
            sets = sets + 1
            if i <> 7 then
               do
                target = dsalloc(source right(sets,3,0),
                         right(mcount-1,3,0) parm mem.0-7)
                say right(mcount-1,4) last'* members copied to' target,
                   'RC='copymem(source target)
               end
            sysin.1  = '  COPY INDD=SOURCE,OUTDD=TARGET'
            sysin.2  = cont('  SELECT MEMBER=('member',')
            last = char1
            mcount = 2
           end
       end
/*********************************************************************/
/* Process Numeric and EVEN                                          */
/*********************************************************************/
    if datatype(parm,'W') = 1 then
       do
        if mcount <= parm then
           do
            mcount = mcount + 1
            sysin.mcount = cont('                 'member',')
           end
        else
           do
            sets = sets + 1
            if i <> 7 then
               do
                target = dsalloc(source right(sets,3,0),
                         right(mcount-1,3,0) parm mem.0-7)
                say right(mcount-1,4) 'members copied to' target,
                   'RC='copymem(source target)
               end
            sysin.1  = '  COPY INDD=SOURCE,OUTDD=TARGET'
            sysin.2  = cont('  SELECT MEMBER=('member',')
            mcount = 2
           end
       end
 end
/*********************************************************************/
/* Process the last group                                            */
/*********************************************************************/
 sets = sets + 1
 target = dsalloc(source right(sets,3,0),
          right(mcount-1,3,0) parm mem.0-7)
 if parm = 'ALPHA' then
    say right(mcount-1,4) last'* members copied to' target,
       'RC='copymem(source target)
 else
    say right(mcount-1,4) 'members copied to' target,
       'RC='copymem(source target)
/*********************************************************************/
/* Print stats                                                       */
/*********************************************************************/
 say
 say right(totcount,4) 'members copied'
 say right(sets,4) 'datasets created'
/*********************************************************************/
/* Shutdown                                                          */
/*********************************************************************/
 shutdown: nop
/*********************************************************************/
/* Put unique shutdown logic before the call to stdexit              */
/*********** @REFRESH BEGIN STOP     2002/08/03 08:42:33 *************/
/* Shutdown message and terminate                                    */
/*********************************************************************/
           call stdexit time('e')
/*********** @REFRESH END   STOP     2002/08/03 08:42:33 *************/
/* Internal Subroutines - not refreshable                            */
/*                                                                   */
/* DSALLOC  - Allocate the new DSN                                   */
/* COPYMEM  - Invoke IEBCOPY to copy members                         */
/* CONT     - Append line with a continuation in column 72           */
/*                                                                   */
/*********************************************************************/
/* DSALLOC  - Allocate the new DSN                                   */
/*********************************************************************/
 dsalloc: arg olddsn num memnum parm totmem
          if parm = 'ALPHA' then
             clonetype = last
          else
             clonetype = '#'
          newdsn = userid()'.@'num||clonetype||memnum'.'olddsn
          dirblks = format(memnum/4,,0)
          pmem = memnum/totmem
          prispace = format(pmem*(sysused/sysblkstrk/systrkscyl),,0)
          if prispace = 0 then prispace = 1
          secspace = prispace * 5
          if sysrecfm = 'U' then
             do
              call tsotrap "ALLOC F(CLONE) DA("qdsn(newdsn)")",
                           "LIKE("qdsn(olddsn)") DIR("dirblks")",
                           "SPACE("prispace secspace") CYLINDERS",
                           "BLKSIZE("sysblksize")"
             end
           else
             do
              call tsotrap "ALLOC F(CLONE) DA("qdsn(newdsn)")",
                           "LIKE("qdsn(olddsn)") DIR("dirblks")",
                           "SPACE("prispace secspace") CYLINDERS",
                           "LRECL("syslrecl") BLKSIZE("sysblksize")"
             end
          call tsotrap "FREE F(CLONE)"
          return newdsn
/*********************************************************************/
/* COPYMEM  - Invoke IEBCOPY to copy members                         */
/*********************************************************************/
 copymem: arg olddsn newdsn
          close = mcount + 1
          sysin.close = '                )'
          call tsotrap "ALLOC F(SOURCE) DA("qdsn(olddsn)") SHR REUSE"
          call tsotrap "ALLOC F(TARGET) DA("qdsn(newdsn)") SHR REUSE"
          call viodd 'SYSIN'
          address TSO "CALL *(IEBCOPY)"
          call rcexit RC 'IEBCOPY error copying' olddsn 'to' newdsn
          call tsotrap "FREE F(SOURCE TARGET SYSIN)"
          drop sysin.
          return 0
/*********************************************************************/
/* CONT     - Append line with a continuation in column 72           */
/*********************************************************************/
 cont: parse arg string
       contstring = string copies(' ',70-length(string))||'X'
       return contstring
/*********** @REFRESH BEGIN SUBBOX   2004/03/10 01:25:03 *************/
/*                                                                   */
/* 20 Internal Subroutines provided in PDSSPLIT                      */
/*                                                                   */
/* Last Subroutine REFRESH was 29 Jul 2004 20:55:33                  */
/*                                                                   */
/* RCEXIT   - Exit on non-zero return codes                          */
/* TRAP     - Issue a common trap error message using rcexit         */
/* ERRMSG   - Build common error message with failing line number    */
/* STDENTRY - Standard Entry logic                                   */
/* STDEXIT  - Standard Exit logic                                    */
/* MSG      - Determine whether to SAY or ISPEXEC SETMSG the message */
/* DDCHECK  - Determine whether a required DD is allocated           */
/* DDLIST   - Returns number of DDs and populates DDLIST variable    */
/* DDDSNS   - Returns number of DSNs in a DD and populates DDDSNS    */
/* QDSN     - Make sure there are only one set of quotes             */
/* TSOTRAP  - Capture the output from a TSO command in a stem        */
/* SAYDD    - Print messages to the requested DD                     */
/* JOBINFO  - Get job-related data from control blocks               */
/* PTR      - Pointer to a storage location                          */
/* STG      - Return the data from a storage location                */
/* VIODD    - EXECIO a stem into a sequential dataset                */
/* MODTRACE - Module Trace                                           */
/*                                                                   */
/*********** @REFRESH END   SUBBOX   2004/03/10 01:25:03 *************/
/*********** @REFRESH BEGIN RCEXIT   2003/05/14 12:24:50 *************/
/* RCEXIT   - Exit on non-zero return codes                          */
/*                                                                  */
/* EXITRC   - Return code to exit with (if non zero)                 */
/* ZEDLMSG  - Message text for it with for non zero EXITRC's         */
/*********************************************************************/
 rcexit: parse arg EXITRC zedlmsg
         if EXITRC <> 0 then
            do
             trace 'o'
/*********************************************************************/
/* If execution environment is ISPF then VPUT ZISPFRC                */
/*********************************************************************/
             if execenv = 'TSO' | execenv = 'ISPF' then
                do
                 if ispfenv = 'YES' then
                    do
                     zispfrc = EXITRC
/*********************************************************************/
/* Does not call ISPWRAP to avoid obscuring error message modules    */
/*********************************************************************/
                     address ISPEXEC "VPUT (ZISPFRC)"
                    end
                end
/*********************************************************************/
/* If a message is provided, wrap it in date, time and EXITRC        */
/*********************************************************************/
             if zedlmsg <> '' then
                do
                 zedlmsg = time('L') execname zedlmsg 'RC='EXITRC
                 call msg zedlmsg
                end
/*********************************************************************/
/* Write the contents of the Parentage Stack                         */
/*********************************************************************/
             stacktitle = 'Parentage Stack Trace ('queued()' entries):'
/*********************************************************************/
/* Write to MSGDD if background and MSGDD exists                     */
/*********************************************************************/
             if tsoenv = 'BACK' then
                do
                 if subword(zedlmsg,9,1) = msgdd then
                    do
                     say zedlmsg
                     signal shutdown
                    end
                 else
                    do
                     call saydd msgdd 1 zedlmsg
                     call saydd msgdd 1 stacktitle
                    end
                end
             else
/*********************************************************************/
/* Write to the ISPF Log if foreground                               */
/*********************************************************************/
                do
                 zerrlm = zedlmsg
                 address ISPEXEC "LOG MSG(ISRZ003)"
                 zerrlm = center(' 'stacktitle' ',78,'-')
                 address ISPEXEC "LOG MSG(ISRZ003)"
                end
/*********************************************************************/
/* Unload the Parentage Stack                                        */
/*********************************************************************/
             do queued()
                pull stackinfo
                if tsoenv = 'BACK' then
                   do
                    call saydd msgdd 0 stackinfo
                   end
                else
                   do
                    zerrlm = stackinfo
                    address ISPEXEC "LOG MSG(ISRZ003)"
                   end
             end
/*********************************************************************/
/* Put a terminator in the ISPF Log for the Parentage Stack          */
/*********************************************************************/
             if tsoenv = 'FORE' then
                do
                 zerrlm = center(' 'stacktitle' ',78,'-')
                 address ISPEXEC "LOG MSG(ISRZ003)"
                end
/*********************************************************************/
/* Signal SHUTDOWN.  SHUTDOWN label MUST exist in the program        */
/*********************************************************************/
             signal shutdown
            end
         else
            return
/*********** @REFRESH END   RCEXIT   2003/05/14 12:24:50 *************/
/*********** @REFRESH BEGIN TRAP     2002/08/07 11:48:14 *************/
/* TRAP     - Issue a common trap error message using rcexit         */
/*                                                                  */
/* PARM     - N/A                                                    */
/*********************************************************************/
 trap: traptype = condition('C')
       if traptype = 'SYNTAX' then
          msg = errortext(RC)
       else
          msg = condition('D')
       trapline = strip(sourceline(sigl))
       msg = traptype 'TRAP:' msg', Line:' sigl '"'trapline'"'
       call rcexit 666 msg
/*********** @REFRESH END   TRAP     2002/08/07 11:48:14 *************/
/*********** @REFRESH BEGIN ERRMSG   2002/08/10 16:53:04 *************/
/* ERRMSG   - Build common error message with failing line number    */
/*                                                                  */
/* ERRLINE  - The failing line number passed by caller from SIGL     */
/* TEXT     - Error message text passed by caller                    */
/*********************************************************************/
 errmsg: nop
         parse arg errline text
         return 'Error on statement' errline',' text
/*********** @REFRESH END   ERRMSG   2002/08/10 16:53:04 *************/
/*********** @REFRESH BEGIN STDENTRY 2004/04/07 19:17:48 *************/
/* STDENTRY - Standard Entry logic                                   */
/*                                                                  */
/* MSGDD    - Optional MSGDD used only in background                 */
/*********************************************************************/
 stdentry: module = 'STDENTRY'
           if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
           parse arg sparms
           push trace() time('L') module 'From:' sigl 'Parms:' sparms
           arg msgdd
           parse upper source . . execname . execdsn . . execenv .
/*********************************************************************/
/* Start-up values                                                   */
/*********************************************************************/
           EXITRC = 0
           MAXRC = 0
           ispfenv = 'NO'
           popup = 'NO'
           lockpop = 'NO'
           headoff = 'NO'
           hcreator = 'NO'
           keepstack = 'NO'
           lpar = mvsvar('SYSNAME')
           zedlmsg = 'Default shutdown message'
/*********************************************************************/
/* Determine environment                                             */
/*********************************************************************/
           if substr(execenv,1,3) <> 'TSO' & execenv <> 'ISPF' then
              tsoenv = 'NONE'
           else
              do
               tsoenv = sysvar('SYSENV')
               signal off failure
              "ISPQRY"
               ISPRC = RC
               if ISPRC = 0 then
                  do
                   ispfenv = 'YES'
/*********************************************************************/
/* Check if HEADING ISPF table exists already, if so set HEADOFF=YES */
/*********************************************************************/
                   call ispwrap "VGET (ZSCREEN)"
                   if tsoenv = 'BACK' then
                      htable = jobinfo(1)||jobinfo(2)
                   else
                      htable = userid()||zscreen
                   TBCRC = ispwrap(8 "TBCREATE" htable "KEYS(HEAD)")
                   if TBCRC = 0 then
                      do
                       headoff = 'NO'
                       hcreator = 'YES'
                      end
                   else
                      do
                       headoff = 'YES'
                      end
                  end
               signal on failure name trap
              end
/*********************************************************************/
/* MODTRACE must occur after the setting of ISPFENV                  */
/*********************************************************************/
           call modtrace 'START' sigl
/*********************************************************************/
/* Start-up message (if batch)                                       */
/*********************************************************************/
           startmsg = execname 'started' date() time() 'on' lpar
           if tsoenv = 'BACK' & sysvar('SYSNEST') = 'NO' &,
              headoff = 'NO' then
              do
               jobname = mvsvar('SYMDEF','JOBNAME')
               jobinfo = jobinfo()
               parse var jobinfo jobtype jobnum .
               say jobname center(' 'startmsg' ',61,'-') jobtype jobnum
               say
               if ISPRC = -3 then
                  do
                   call saydd msgdd 1 'ISPF ISPQRY module not found,',
                                      'ISPQRY is usually in the LINKLST'
                   call rcexit 20 'ISPF ISPQRY module is missing'
                  end
/*********************************************************************/
/* If MSGDD is provided, write the STARTMSG and SYSEXEC DSN to MSGDD */
/*********************************************************************/
               if msgdd <> '' then
                  do
                   call ddcheck msgdd
                   call saydd msgdd 1 startmsg
                   call ddcheck 'SYSEXEC'
                   call saydd msgdd 0 execname 'loaded from' sysdsname
/*********************************************************************/
/* If there are PARMS, write them to the MSGDD                       */
/*********************************************************************/
                   if parms <> '' then
                      call saydd msgdd 0 'Parms:' parms
/*********************************************************************/
/* If there is a STEPLIB, write the STEPLIB DSN MSGDD                */
/*********************************************************************/
                   if listdsi('STEPLIB' 'FILE') = 0 then
                      do
                       steplibs = dddsns('STEPLIB')
                       call saydd msgdd 0 'STEPLIB executables loaded',
                           'from' word(dddsns,1)
                       if dddsns('STEPLIB') > 1 then
                          do
                           do stl=2 to steplibs
                              call saydd msgdd 0 copies(' ',31),
                                   word(dddsns,stl)
                           end
                          end
                      end
                  end
              end
/*********************************************************************/
/* If foreground, save ZFKA and turn off the FKA display             */
/*********************************************************************/
           else
              do
               fkaset = 'OFF'
               call ispwrap "VGET (ZFKA) PROFILE"
               if zfka <> 'OFF' & tsoenv = 'FORE' then
                  do
                   fkaset = zfka
                   fkacmd = 'FKA OFF'
                   call ispwrap "CONTROL DISPLAY SAVE"
                  call ispwrap "DISPLAY PANEL(ISPBLANK) COMMAND(FKACMD)"
                   call ispwrap "CONTROL DISPLAY RESTORE"
                  end
              end
/*********************************************************************/
           pull tracelvl . module . sigl . sparms
           call modtrace 'STOP' sigl
           interpret 'trace' tracelvl
           return
/*********** @REFRESH END   STDENTRY 2004/04/07 19:17:48 *************/
/*********** @REFRESH BEGIN STDEXIT  2003/11/16 22:46:29 *************/
/* STDEXIT  - Standard Exit logic                                    */
/*                                                                  */
/* ENDTIME  - Elapsed time                                           */
/* Note: Caller must set KEEPSTACK if the stack is valid             */
/*********************************************************************/
 stdexit: module = 'STDEXIT'
          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
          parse arg sparms
          push trace() time('L') module 'From:' sigl 'Parms:' sparms
          call modtrace 'START' sigl
          arg endtime
          endmsg = execname 'ended' date() time() format(endtime,,1)
/*********************************************************************/
/* if MAXRC is greater then EXITRC then set EXITRC to MAXRC          */
/*********************************************************************/
          if MAXRC > EXITRC then EXITRC = MAXRC
          endmsg = endmsg 'on' lpar 'RC='EXITRC
          if tsoenv = 'BACK' & sysvar('SYSNEST') = 'NO' &,
             headoff = 'NO' then
             do
              say
              say jobname center(' 'endmsg' ',61,'-') jobtype jobnum
/*********************************************************************/
/* Make sure this isn't a MSGDD missing error then log to MSGDD      */
/*********************************************************************/
              if msgdd <> '' & subword(zedlmsg,9,1) <> msgdd then
                 do
                  call saydd msgdd 1 execname 'ran in' endtime 'seconds'
                  call saydd msgdd 0 endmsg
                 end
             end
/*********************************************************************/
/* If foreground, reset the FKA if necessary                         */
/*********************************************************************/
          else
             do
              if fkaset <> 'OFF' then
                 do
                  fkafix = 'FKA'
                  call ispwrap "CONTROL DISPLAY SAVE"
                  call ispwrap "DISPLAY PANEL(ISPBLANK) COMMAND(FKAFIX)"
                  if fkaset = 'SHORT' then
                     call ispwrap "DISPLAY PANEL(ISPBLANK)",
                                  "COMMAND(FKAFIX)"
                  call ispwrap "CONTROL DISPLAY RESTORE"
                 end
             end
/*********************************************************************/
/* Clean up the temporary HEADING table                              */
/*********************************************************************/
          if ispfenv = 'YES' & hcreator = 'YES' then
             call ispwrap "TBEND" htable
/*********************************************************************/
/* Remove STDEXIT and MAINLINE Parentage Stack entries, if there     */
/*********************************************************************/
          call modtrace 'STOP' sigl
          if queued() > 0 then pull . . module . sigl . sparms
          if queued() > 0 then pull . . module . sigl . sparms
          if tsoenv = 'FORE' & queued() > 0 & keepstack = 'NO' then
             pull . . module . sigl . sparms
/*********************************************************************/
/* if the Parentage Stack is not empty, display its contents         */
/*********************************************************************/
          if queued() > 0 & keepstack = 'NO' then
             do
              say queued() 'Leftover Parentage Stack Entries:'
              say
              do queued()
                 pull stackundo
                 say stackundo
              end
              EXITRC = 1
             end
/*********************************************************************/
/* Exit                                                              */
/*********************************************************************/
          exit(EXITRC)
/*********** @REFRESH END   STDEXIT  2003/11/16 22:46:29 *************/
/*********** @REFRESH BEGIN MSG      2002/09/11 01:35:53 *************/
/* MSG      - Determine whether to SAY or ISPEXEC SETMSG the message */
/*                                                                  */
/* ZEDLMSG  - The long message variable                              */
/*********************************************************************/
 msg: module = 'MSG'
      parse arg zedlmsg
      if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
      parse arg sparms
      push trace() time('L') module 'From:' sigl 'Parms:' sparms
      call modtrace 'START' sigl
/*********************************************************************/
/* If this is background or OMVS use SAY                             */
/*********************************************************************/
      if tsoenv = 'BACK' | execenv = 'OMVS' then
         say zedlmsg
      else
/*********************************************************************/
/* If this is foreground and ISPF is available, use SETMSG           */
/*********************************************************************/
         do
          if ispfenv = 'YES' then
/*********************************************************************/
/* Does not call ISPWRAP to avoid obscuring error message modules    */
/*********************************************************************/
             address ISPEXEC "SETMSG MSG(ISRZ000)"
          else
             say zedlmsg
         end
      pull tracelvl . module . sigl . sparms
      call modtrace 'STOP' sigl
      interpret 'trace' tracelvl
      return
/*********** @REFRESH END   MSG      2002/09/11 01:35:53 *************/
/*********** @REFRESH BEGIN DDCHECK  2002/09/11 01:08:30 *************/
/* DDCHECK  - Determine if a required DD is allocated                */
/*                                                                  */
/* DD       - DDNAME to confirm                                      */
/*********************************************************************/
 ddcheck: module = 'DDCHECK'
          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
          parse arg sparms
          push trace() time('L') module 'From:' sigl 'Parms:' sparms
          call modtrace 'START' sigl
          arg dd
          dderrmsg = 'OK'
          LRC = listdsi(dd "FILE")
/*********************************************************************/
/* Allow sysreason=3 to verify SYSOUT DD statements                  */
/*********************************************************************/
          if LRC <> 0 & strip(sysreason,'L',0) <> 3 then
             do
              dderrmsg = errmsg(sigl 'Required DD' dd 'is missing')
              call rcexit LRC dderrmsg sysmsglvl2
             end
          pull tracelvl . module . sigl . sparms
          call modtrace 'STOP' sigl
          interpret 'trace' tracelvl
          return
/*********** @REFRESH END   DDCHECK  2002/09/11 01:08:30 *************/
/*********** @REFRESH BEGIN DDLIST   2002/12/15 04:54:32 *************/
/* DDLIST   - Returns number of DDs and populates DDLIST variable    */
/*                                                                  */
/* N/A      - None                                                   */
/*********************************************************************/
 ddlist: module = 'DDLIST'
         if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
         parse arg sparms
         push trace() time('L') module 'From:' sigl 'Parms:' sparms
         call modtrace 'START' sigl
/*********************************************************************/
/* Trap the output from the LISTA STATUS command                     */
/*********************************************************************/
         call outtrap 'lines.'
         address TSO "LISTALC STATUS"
         call outtrap 'off'
         ddnum = 0
/*********************************************************************/
/* Parse out the DDNAMEs and concatenate into a list                 */
/*********************************************************************/
         ddlist = ''
         do ddl=1 to lines.0
            if words(lines.ddl) = 2 then
               do
                parse upper var lines.ddl ddname .
                ddlist = ddlist ddname
                ddnum = ddnum + 1
               end
            else
               do
                iterate
               end
         end
/*********************************************************************/
/* Return the number of DDs                                          */
/*********************************************************************/
         pull tracelvl . module . sigl . sparms
         call modtrace 'STOP' sigl
         interpret 'trace' tracelvl
         return ddnum
/*********** @REFRESH END   DDLIST   2002/12/15 04:54:32 *************/
/*********** @REFRESH BEGIN DDDSNS   2002/09/11 00:37:36 *************/
/* DDDSNS   - Returns number of DSNs in a DD and populates DDDSNS    */
/*                                                                  */
/* TARGDD   - DD to return DSNs for                                  */
/*********************************************************************/
 dddsns: module = 'DDDSNS'
         if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
         parse arg sparms
         push trace() time('L') module 'From:' sigl 'Parms:' sparms
         call modtrace 'START' sigl
         arg targdd
         if targdd = '' then call rcexit 77 'DD missing for DDDSNS'
/*********************************************************************/
/* Trap the output from the LISTA STATUS command                     */
/*********************************************************************/
         x = outtrap('lines.')
         address TSO "LISTALC STATUS"
         dsnnum = 0
         ddname = '$DDNAME$'
/*********************************************************************/
/* Parse out the DDNAMEs, locate the target DD and concatentate DSNs */
/*********************************************************************/
         do ddd=1 to lines.0
            select
               when words(lines.ddd) = 1 & targdd = ddname &,
                    lines.ddd <> 'KEEP' then
                    dddsns = dddsns strip(lines.ddd)
               when words(lines.ddd) = 1 & strip(lines.ddd),
                    <> 'KEEP' then
                    dddsn.ddd = strip(lines.ddd)
               when words(lines.ddd) = 2 then
                    do
                     parse upper var lines.ddd ddname .
                     if targdd = ddname then
                        do
                         fdsn = ddd - 1
                         dddsns = lines.fdsn
                        end
                    end
               otherwise iterate
            end
         end
/*********************************************************************/
/* Get the last DD                                                   */
/*********************************************************************/
         ddnum = ddlist()
         lastdd = word(ddlist,ddnum)
/*********************************************************************/
/* Remove the last DSN from the list if not the last DD or SYSEXEC   */
/*********************************************************************/
         if targdd <> 'SYSEXEC' & targdd <> lastdd then
            do
             dsnnum = words(dddsns) - 1
             dddsns = subword(dddsns,1,dsnnum)
            end
/*********************************************************************/
/* Return the number of DSNs in the DD                               */
/*********************************************************************/
         pull tracelvl . module . sigl . sparms
         call modtrace 'STOP' sigl
         interpret 'trace' tracelvl
         return dsnnum
/*********** @REFRESH END   DDDSNS   2002/09/11 00:37:36 *************/
/*********** @REFRESH BEGIN QDSN     2002/09/11 01:15:23 *************/
/* QDSN     - Make sure there are only one set of quotes             */
/*                                                                  */
/* QDSN     - The DSN                                                */
/*********************************************************************/
 qdsn: module = 'QDSN'
       if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
       parse arg sparms
       push trace() time('L') module 'From:' sigl 'Parms:' sparms
       call modtrace 'START' sigl
       parse arg qdsn
       qdsn = "'"strip(qdsn,"B","'")"'"
       pull tracelvl . module . sigl . sparms
       call modtrace 'STOP' sigl
       interpret 'trace' tracelvl
       return qdsn
/*********** @REFRESH END   QDSN     2002/09/11 01:15:23 *************/
/*********** @REFRESH BEGIN TSOTRAP  2002/12/15 05:18:45 *************/
/* TSOTRAP  - Capture the output from a TSO command in a stem        */
/*                                                                  */
/* VALIDRC  - Optional valid RC, defaults to zero                    */
/* TSOPARM  - Valid TSO command                                      */
/*********************************************************************/
 tsotrap: module = 'TSOTRAP'
          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
          parse arg sparms
          push trace() time('L') module 'From:' sigl 'Parms:' sparms
          call modtrace 'START' sigl
          parse arg tsoparm
/*********************************************************************/
/* If the optional valid_rc parm is present use it, if not assume 0  */
/*********************************************************************/
          parse var tsoparm valid_rc tso_cmd
          if datatype(valid_rc,'W') = 0 then
             do
              valid_rc = 0
              tso_cmd = tsoparm
             end
          call outtrap 'tsoout.'
          tsoline = sigl
          address TSO tso_cmd
          CRC = RC
          call outtrap 'off'
/*********************************************************************/
/* If RC = 0 then return                                             */
/*********************************************************************/
          if CRC <= valid_rc then
             do
              pull tracelvl . module . sigl . sparms
              call modtrace 'STOP' sigl
              interpret 'trace' tracelvl
              return CRC
             end
          else
             do
              trapmsg = center(' TSO Command Error Trap ',78,'-')
              terrmsg = errmsg(sigl 'TSO Command:')
/*********************************************************************/
/* If RC <> 0 then format output depending on environment            */
/*********************************************************************/
              if tsoenv = 'BACK' | execenv = 'OMVS' then
                 do
                  say trapmsg
                  do c=1 to tsoout.0
                     say tsoout.c
                  end
                  say trapmsg
                  call rcexit CRC terrmsg tso_cmd
                 end
              else
/*********************************************************************/
/* If this is foreground and ISPF is available, use the ISPF LOG     */
/*********************************************************************/
                 do
                  if ispfenv = 'YES' then
                     do
                      zedlmsg = trapmsg
/*********************************************************************/
/* Does not call ISPWRAP to avoid obscuring error message modules    */
/*********************************************************************/
                      address ISPEXEC "LOG MSG(ISRZ000)"
                      do c=1 to tsoout.0
                         zedlmsg = tsoout.c
                         address ISPEXEC "LOG MSG(ISRZ000)"
                      end
                      zedlmsg = trapmsg
                      address ISPEXEC "LOG MSG(ISRZ000)"
                      call rcexit CRC terrmsg tso_cmd,
                          ' see the ISPF Log (Option 7.5) for details'
                     end
                  else
                     do
                      say trapmsg
                      do c=1 to tsoout.0
                         say tsoout.c
                      end
                      say trapmsg
                      call rcexit CRC terrmsg tso_cmd
                     end
                 end
             end
/*********** @REFRESH END   TSOTRAP  2002/12/15 05:18:45 *************/
/*********** @REFRESH BEGIN SAYDD    2004/03/29 23:48:37 *************/
/* SAYDD    - Print messages to the requested DD                     */
/*                                                                  */
/* MSGDD    - DDNAME to write messages to                            */
/* MSGLINES - number of blank lines to put before and after          */
/* MESSAGE  - Text to write to the MSGDD                             */
/*********************************************************************/
 saydd: module = 'SAYDD'
        if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
        parse arg sparms
        push trace() time('L') module 'From:' sigl 'Parms:' sparms
        call modtrace 'START' sigl
        parse arg msgdd msglines message
        if words(msgdd msglines message) < 3 then
           call rcexit 33 'Missing MSGDD or MSGLINES'
        if datatype(msglines) <> 'NUM' then
           call rcexit 34 'MSGLINES must be numeric'
/*********************************************************************/
/* If this is not background then bypass                             */
/*********************************************************************/
        if tsoenv <> 'BACK' then
           do
            pull tracelvl . module . sigl . sparms
            call modtrace 'STOP' sigl
            interpret 'trace' tracelvl
            return
           end
/*********************************************************************/
/* Confirm the MSGDD exists                                          */
/*********************************************************************/
        call ddcheck msgdd
/*********************************************************************/
/* If a number is provided, add that number of blank lines before    */
/* the message                                                       */
/*********************************************************************/
        msgb = 1
        if msglines > 0 then
           do msgb=1 to msglines
              msgline.msgb = ' '
           end
/*********************************************************************/
/* If the linesize is too long break it into multiple lines and      */
/* create continuation records                                       */
/*********************************************************************/
        msgm = msgb
        if length(message) > 60 & substr(message,1,2) <> '@@' then
           do
            messst = lastpos(' ',message,60)
            messseg = substr(message,1,messst)
            msgline.msgm = date() time() strip(messseg)
            message = strip(delstr(message,1,messst))
            do while length(message) > 0
               msgm = msgm + 1
               if length(message) > 55 then
                  messst = lastpos(' ',message,55)
               if messst > 0 then
                  messseg = substr(message,1,messst)
               else
                  messseg = substr(message,1,length(message))
               msgline.msgm = date() time() 'CONT:' strip(messseg)
               message = strip(delstr(message,1,length(messseg)))
            end
           end
        else
/*********************************************************************/
/* Build print lines. Default strips and prefixes date and timestamp */
/* @BLANK - Blank line, no date and timestamp                        */
/* @      - No stripping, retains leading blanks                     */
/* @@     - No stripping, No date and timestamp                      */
/*********************************************************************/
           do
            select
               when message = '@BLANK@' then msgline.msgm = ' '
               when word(message,1) = '@' then
                    do
                     message = substr(message,2,length(message)-1)
                     msgline.msgm = date() time() message
                    end
               when substr(message,1,2) = '@@' then
                    do
                     message = substr(message,3,length(message)-2)
                     msgline.msgm = message
                    end
               otherwise msgline.msgm = date() time() strip(message)
            end
           end
/*********************************************************************/
/* If a number is provided, add that number of blank lines after     */
/* the message                                                       */
/*********************************************************************/
        if msglines > 0 then
           do msgt=1 to msglines
              msge = msgt + msgm
              msgline.msge = ' '
           end
/*********************************************************************/
/* Write the contents of the MSGLINE stem to the MSGDD               */
/*********************************************************************/
        call tsotrap "EXECIO * DISKW" msgdd "(STEM MSGLINE. FINIS"
        drop msgline. msgb msgt msge
        pull tracelvl . module . sigl . sparms
        call modtrace 'STOP' sigl
        interpret 'trace' tracelvl
        return
/*********** @REFRESH END   SAYDD    2004/03/29 23:48:37 *************/
/*********** @REFRESH BEGIN JOBINFO  2002/09/11 01:12:59 *************/
/* JOBINFO  - Get job related data from control blocks               */
/*                                                                  */
/* ITEM     - Optional item number desired, default is all           */
/*********************************************************************/
 jobinfo: module = 'JOBINFO'
          if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
          parse arg sparms
          push trace() time('L') module 'From:' sigl 'Parms:' sparms
          call modtrace 'START' sigl
          arg item
/*********************************************************************/
/* Chase control blocks                                              */
/*********************************************************************/
          tcb      = ptr(540)
          ascb     = ptr(548)
          tiot     = ptr(tcb+12)
          jscb     = ptr(tcb+180)
          ssib     = ptr(jscb+316)
          asid     = c2d(stg(ascb+36,2))
          jobtype  = stg(ssib+12,3)
          jobnum   = strip(stg(ssib+15,5),'L',0)
          stepname = stg(tiot+8,8)
          procstep = stg(tiot+16,8)
          program  = stg(jscb+360,8)
          jobdata  = jobtype jobnum stepname procstep program asid
/*********************************************************************/
/* Return job data                                                   */
/*********************************************************************/
          if item <> '' & (datatype(item,'W') = 1) then
             do
              pull tracelvl . module . sigl . sparms
              call modtrace 'STOP' sigl
              interpret 'trace' tracelvl
              return word(jobdata,item)
             end
          else
             do
              pull tracelvl . module . sigl . sparms
              call modtrace 'STOP' sigl
              interpret 'trace' tracelvl
              return jobdata
             end
/*********** @REFRESH END   JOBINFO  2002/09/11 01:12:59 *************/
/*********** @REFRESH BEGIN PTR      2002/07/13 15:45:36 *************/
/* PTR      - Pointer to a storage location                          */
/*                                                                  */
/* ARG(1)   - Storage Address                                        */
/*********************************************************************/
 ptr: return c2d(storage(d2x(arg(1)),4))
/*********** @REFRESH END   PTR      2002/07/13 15:45:36 *************/
/*********** @REFRESH BEGIN STG      2002/07/13 15:49:12 *************/
/* STG      - Return the data from a storage location                */
/*                                                                  */
/* ARG(1)   - Location                                               */
/* ARG(2)   - Length                                                 */
/*********************************************************************/
 stg: return storage(d2x(arg(1)),arg(2))
/*********** @REFRESH END   STG      2002/07/13 15:49:12 *************/
/*********** @REFRESH BEGIN VIODD    2004/06/08 11:17:36 *************/
/* VIODD    - EXECIO a stem into a sequential dataset                */
/*                                                                  */
/* VIODD    - The member to create                                   */
/* VIOLRECL - The LRECL for the VIODD (defaults to 80)               */
/*********************************************************************/
 viodd: module = 'VIODD'
        if wordpos(module,probe) <> 0 then trace 'r'; else trace 'n'
        parse arg sparms
        push trace() time('L') module 'From:' sigl 'Parms:' sparms
        call modtrace 'START' sigl
        arg viodd violrecl viorecfm
        if viodd = '' then call rcexit 88 'VIODD missing'
        if violrecl = '' then violrecl = 80
        if viorecfm = '' then viorecfm = 'F B'
/*********************************************************************/
/* If DD exists, FREE it                                             */
/*********************************************************************/
        if listdsi(viodd 'FILE') = 0 then
           call tsotrap "FREE F("viodd")"
/*********************************************************************/
/* ALLOCATE a VIO DSN                                                */
/*********************************************************************/
        call tsotrap "ALLOC F("viodd") UNIT("@vio") SPACE(1 5)",
                     "LRECL("violrecl") BLKSIZE(0) REUSE",
                     "RECFM("viorecfm") CYLINDERS"
/*********************************************************************/
/* Write the stem variables into the VIO DSN                         */
/*********************************************************************/
        call tsotrap "EXECIO * DISKW" viodd "(STEM" viodd". FINIS"
/*********************************************************************/
/* DROP the stem variable                                            */
/*********************************************************************/
        interpret 'drop' viodd'.'
        pull tracelvl . module . sigl . sparms
        call modtrace 'STOP' sigl
        interpret 'trace' tracelvl
        return
/*********** @REFRESH END   VIODD    2004/06/08 11:17:36 *************/
/*********** @REFRESH BEGIN MODTRACE 2003/12/31 21:56:54 *************/
/* MODTRACE - Module Trace                                           */
/*                                                                  */
/* TRACETYP - Type of trace entry                                    */
/* SIGLINE  - The line number called from                            */
/*********************************************************************/
 modtrace: if modtrace = 'NO' then return
           arg tracetyp sigline
           tracetyp = left(tracetyp,5)
           sigline = left(sigline,5)
/*********************************************************************/
/* Adjust MODSPACE for START                                         */
/*********************************************************************/
           if tracetyp = 'START' then
              modspace = substr(modspace,1,length(modspace)+1)
/*********************************************************************/
/* Set the trace entry                                               */
/*********************************************************************/
           traceline = modspace time('L') tracetyp module sigline sparms
/*********************************************************************/
/* Adjust MODSPACE for STOP                                          */
/*********************************************************************/
           if tracetyp = 'STOP' then
              modspace = substr(modspace,1,length(modspace)-1)
/*********************************************************************/
/* Determine where to write the traceline                            */
/*********************************************************************/
           if ispfenv = 'YES' & tsoenv = 'FORE' then
/*********************************************************************/
/* Write to the ISPF Log, do not use ISPWRAP here                    */
/*********************************************************************/
              do
               zedlmsg = traceline
               address ISPEXEC "LOG MSG(ISRZ000)"
              end
           else
              say traceline
/*********************************************************************/
/* SAY to SYSTSPRT                                                   */
/*********************************************************************/
           return
/*********** @REFRESH END   MODTRACE 2003/12/31 21:56:54 *************/

Robert Zenuk
Systems Programmer (USA) c Xephon 2005
