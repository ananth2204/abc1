{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "RICHARD", "INMTNODE": "SY2", "INMTUID": "RICHARD", "INMFTIME": "20060505102801000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 8000, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "RTI.SOURCE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"RTI.SOURCE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 8000, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 2227, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "060121", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x00'", "DS1LSTAR": "b'\\x00\\x06\\x03'", "DS1TRBAL": "b'\\xb5\\x06'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\n\\x80\\x00\\x04\\x98\\xb0@'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\n\\x80\\x00\\x04\\x98\\xb0@'", "b'P\\xf4+p\\x00\\x00\\x01R\\x00\\x00\\x01T\\x00\\x0e\\x00-'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"#PUTMSG": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00F\\x00\\x92\\t\\x1f\\x00\\x962o\\x17\\x15\\x00j\\x00\\x9b\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1992-03-31T00:00:00", "modifydate": "1996-11-21T17:15:46", "lines": 106, "newlines": 155, "modlines": 0, "user": "RICHARD"}, "text": "         TITLE '#PUTMSG - PRINT A MESSAGE'\n***********************************************************************\n*                                                                     *\n* MODULE NAME : #PUTMSG                                               *\n*                                                                     *\n*                                                                     *\n* DESCRIPTIVE NAME : PRINT A MESSAGE                                  *\n*                                                                     *\n*                                                                     *\n* FUNCTION :  SCAN MESSAGE TABLE, E.G. #GENMSG, USING THE USER        *\n*             PROVIDED MESSAGE ID, OUTPUT BUFFER AND FILE, AND        *\n*             WRITE TO THE USER-SPECIFIED OUTPUT FILE.                *\n*                                                                     *\n* ENTRY: FROM OS                                                      *\n*                                                                     *\n* EXIT:  RETURN TO OS                                                 *\n*                                                                     *\n*                                                                     *\n* INPUT:                                                              *\n*                                                                     *\n*    PARMS:     WORD-1 = MESSAGE ID                                   *\n*               WORD-2 = ADDRESS OF MESSAGE TABLE                     *\n*               WORD-3 = ADDRESS OF OUTPUT DCB                        *\n*               WORD-4 = ADDRESS OF OUTPUT BUFFER                     *\n*               WORD-5 = LENGTH OF OUTPUT BUFFER                      *\n*                                                                     *\n*                                                                     *\n* OUTPUT: NONE                                                        *\n*                                                                     *\n*                                                                     *\n* ABENDS:                                                             *\n*                                                                     *\n*   SEE MESSAGES (IF ANY)                                             *\n*                                                                     *\n*--PROPRIETARY_STATEMENT----------------------------------------------*\n*                                                                     *\n*  THIS PROGRAM IS THE SOLE PROPERTY OF RICHARD TSUJIMOTO, INC.       *\n*                                                                     *\n***********************************************************************\n         EJECT\n         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R11                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         EJECT\n$PRMLST1 #PUTMSG MF=DSECT\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\n#PUTMSG  #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         #OWNER VER=V1R0M0\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         L     R8,@PARM           POINT TO PARM LIST\n         USING $PRMLST1,R8        SET ADDR\n         SPACE 1\n         L     R1,#PMSGNO         MESSAGE ID\n         L     R4,#PMSGTAA        POINT TO MESSAGE TABLE\n         L     R5,#POTDCBA        POINT TO OUTPUT DCB\n         L     R6,#POTBUFA        POINT TO OUTPUT BUFFER\n         L     R7,#POTBUFL        LENGTH OF OUTPUT BUFFER\n         SPACE 1\n         BCTR  R7,0               MACHINE LENGTH\n         BCTR  R7,0               MACHINE LENGTH\n         MVI   0(R6),X'40'        SET OUTPUT AREA\n         EX    R7,SETOBLNK        TO BLANKS\n         SPACE 1\n         SLL   R1,2               MULTIPLY MSG. NO BY 4\n         S     R4,=F'4'           PT TO MESSAGE TABLE - 4\n         LA    R4,0(R1,R4)        PT TO PROPER ENTRY\n         XR    R1,R1              CLEAR WORK REG\n         IC    R1,0(,R4)          LENGTH OF MESSAGE TEXT\n         BCTR  R1,0               MACHINE LENGTH\n         ICM   R2,B'0111',1(R4)   PT TO MESSAGE\n         EX    R1,MOVEMESG        MOVE MSG TO OUTPUT BUFFER\n         SPACE 1\n         PUT   (R5),(R6)\n         SPACE 1\nRETURN   DS    0H\n         L     R13,SAVEAREA+4     POINT TO CALLER'S SAVE AREA\n         RETURN (14,12),RC=0      FINIS\n         SPACE 1\n         DROP  R8\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nMOVEMESG MVC   0(*-*,R6),0(R2)    SUBJECT OF EX INSTR\nSETOBLNK MVC   1(*-*,R6),0(R6)    SUBJECT OF EX INSTR\n         SPACE 1\nSAVEAREA DS    18F                REGISTER SAVE AREA\n@PARM    DS    A                  ADDR OF PARM LIST\n         SPACE 1\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@INTRPRT": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00(\\x01\\x05\\x18\\x7f\\x01\\x05\\x18\\x8f\\x10@\\x01\\x1a\\x01\\x13\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2005-07-06T00:00:00", "modifydate": "2005-07-07T10:40:28", "lines": 282, "newlines": 275, "modlines": 0, "user": "RICHARD"}, "text": "         TITLE '@INTRPRT - SCAN STACK AND INTERPRET INPUT STRING'\n***********************************************************************\n*                                                                     *\n* MODULE NAME : @INTRPRT                                              *\n*                                                                     *\n*                                                                     *\n* DESCRIPTIVE NAME : SCAN STACK AND INTERPRET INPUT STRING            *\n*                                                                     *\n*                                                                     *\n* FUNCTION :  SCAN THE STACK CREATED BY @PARSE AND \"INTERPRET\"        *\n*             THE INPUT STRING BY PASSING CONTROL TO USER-SPECIFIED   *\n*             EXITS AS EACH KEYWORD TOKEN AND/OR ARGUMENTS ARE        *\n*             ENCOUNTERED.  THE USER EXIT PROCESSES THE TOKEN AND,    *\n*             IF SUCCESSFUL, RETURNS WITH R15=0; ELSE, R15=4 AND      *\n*             AN ERROR MESSAGE IS STORED IN THE BUFFER PROVIDED TO    *\n*             THE EXIT.  INTERPRETATION OF THE INPUT STRING IS        *\n*             GOVERNED BY THE USER-PROVIDED SYNTAX TABLE.             *\n*                                                                     *\n* ENTRY: FROM CALLER                                                  *\n*                                                                     *\n* EXIT:  RETURN TO CALLER                                             *\n*                                                                     *\n*                                                                     *\n* INPUT:                                                              *\n*                                                                     *\n*    PARMS:     WORD-1 = ADDR OF USER'S SYNTAX TABLE                  *\n*               WORD-2 = LENGTH OF TOKEN IN ERROR                     *\n*               WORD-3 = ADDRESS OF TOKEN IN ERROR                    *\n*               WORD-4 = ADDR OF 100-BYTE ERROR MESSAGE               *\n*                                                                     *\n* OUTPUT:                                                             *\n*                                                                     *\n*    PARMS:     WORD-2 = LENGTH OF TOKEN IN ERROR                     *\n*               WORD-3 = ADDRESS OF TOKEN IN ERROR                    *\n*               WORD-4 = ADDR OF 100-BYTE ERROR MESSAGE               *\n*                                                                     *\n*    RETURN CODE:  0 = OK                                             *\n*                  4 = ADDR OF USER'S SYNTAX TABLE IS ZERO, OR        *\n*                      ADDR OF MESSAGE BUFFER IS ZERO                 *\n*                  8 = ERROR DETECTED BY USER'S EXIT                  *\n*                                                                     *\n*                                                                     *\n* ABENDS:                                                             *\n*                                                                     *\n*   SEE MESSAGES (IF ANY)                                             *\n*                                                                     *\n*--PROPRIETARY_STATEMENT----------------------------------------------*\n*                                                                     *\n*  THIS PROGRAM IS THE SOLE PROPERTY OF RICHARD TSUJIMOTO, INC.       *\n*                                                                     *\n***********************************************************************\n* CHANGE HISTORY:                                                     *\n* --------------                                                      *\n* 2005-JUL-06 RXT CREATED                                             *\n*                                                                     *\n***********************************************************************\n         EJECT\n         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R12                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         EJECT\n         @TOKEN   MF=ALL\n         EJECT\n$PRMLST1 @INTRPRT MF=DSECT\n         EJECT\nEXITPMAP @INTRPRT MF=EXITPARM\n         EJECT\n#SYNTXTB @RULE    MF=DSECT\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\n@INTRPRT #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         #OWNER VER=V1R0M0\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         BAL   LINKREG,INIT       INITIALIZE STACK, BUFFERS, ETC.\n         SPACE 1\n         BAL   LINKREG,CHKPARM    VALIDATE PARAMETERS\n         CLI   STATFLAG,ERROR     OK ?\n         BE    EXIT               NO, CONTINUE\n         SPACE 1\n         BAL   LINKREG,INTRPTIT   INTERPRET THE INPUT STRING\n         SPACE 1\nEXIT     DS    0H\n         L     R13,SAVEAREA+4     PT TO CALLER'S REG SAVEAREA\n         L     R15,RETCODE        RETURN CODE\n         SPACE 1\n         RETURN (14,12),RC=(15)   THAT'S ALL FOLKS!\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - INITIALIZE BUFFERS, COUNTERS, ETC.                   *\n*                                                                     *\n***********************************************************************\nINIT     DS    0H\n         LR    R5,LINKREG         COPY RETURN REG\n         SPACE 1\n         #STACK STACK=STACK,LEVELS=4,ACTION=INIT  INIT REG STACK\n         SPACE 1\n         XC    RETCODE,RETCODE    RESET RETURN CODE\n         XC    STATFLAG,STATFLAG  RESET STATUS FLAG\n         LR    LINKREG,R5         RESTORE LINK REG\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - CHECK PARAMETERS                                     *\n*                                                                     *\n***********************************************************************\nCHKPARM  DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         L     R2,@PARM           POINT TO PARM LIST\n         USING $PRMLST1,R2        SET ADDR\n         SPACE 1\n         ICM   R1,B'1111',@ISYNTXB  NON-ZERO SYNTAX TABLE ADDRESS?\n         BZ    CHKPARM_BADPTR     NO, CONTINUE\n         SPACE 1\n         ICM   R1,B'1111',@IERRMSG  NON-ZERO MESSAGE BUFFER ADDRESS?\n         BNZ   CHKPARM_SETPTRS    YES, CONTINUE\n         SPACE 1\nCHKPARM_BADPTR  DS    0H\n         MVI   STATFLAG,ERROR     SET ERROR FLAG\n         MVC   RETCODE,RC_4       SET RETURN CODE\n         B     CHKPARM_EXIT       GET OUT\n         SPACE 1\nCHKPARM_SETPTRS DS    0H\n         L     R1,@PARSWRK        POINT TO @PARSER WORK AREA\n         LA    R1,@TOKENXL(,R1)   POINT TO BEGINNING OF STACK\n         ST    R1,@CURSTKE        SAVE IT\n         SPACE 1\nCHKPARM_EXIT  DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\n         DROP  R2\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - INTERPRET THE INPUT STRING                           *\n*                                                                     *\n*                R0-R3 = WORK REGS                                    *\n*                R4-R6 NOT USED                                       *\n*                R7 = @INTRPRT PARAMETER LIST                         *\n*                R8 = ADDR OF USER'S SYNTAX TABLE/CONTINUATION RULE   *\n*                R9 = ADDR OF CURRENT TOKEN STACK ENTRY               *\n*                R10-R11 NOT USED                                     *\n*                                                                     *\n***********************************************************************\nINTRPTIT DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         L     R7,@PARM           POINT TO PARM LIST\n         USING $PRMLST1,R7        SET ADDR\n         SPACE 1\n         ICM   R8,B'1111',@CONTRUL ARE WE IN THE MIDST OF CONTINUATION?\n         BZ    INTRPTIT_TBL_PTR   NO, COONTINUE\n         SPACE 1\n         XC    @CONTRUL,@CONTRUL  RESET CONTINUATION ADDRESS\n         B     INTRPTIT_STK_PTR   CONTINUE\n         SPACE 1\nINTRPTIT_TBL_PTR DS 0H\n         L     R8,@ISYNTXB        POINT TO USER'S SYNTAX TABLE\n         USING #SYNTXTB,R8        SET ADDR\n         SPACE 1\nINTRPTIT_STK_PTR DS 0H\n         L     R9,@CURSTKE        POINT TO CURRENT STACK ENTRY\n         USING @TOKEN,R9          SET ADDR\n         SPACE 1\nINTRPTIT_LOOP_01 DS 0H\n         CLC   @SYNTOKN,=AL2(LASTRULE)  LAST SYNTAX RULE?\n         BE    INTRPTIT_EXIT      YES, GET OUT\n         SPACE 1\n         CLC   @SYNTOKN,=AL2(CONTRULE) STATEMENT CONTINUATION?\n         BNE   INTRPTIT_TST_GOTO  NO, CONTINUE\n         SPACE 1\n         MVC   @CONTRUL,@SYNNXTA  FETCH ADDR OF CONTINUATION RULE\n         B     INTRPTIT_GET_NXTRULE  CONTINUE\n         SPACE 1\nINTRPTIT_TST_GOTO  DS 0H\n         CLC   @SYNTOKN,=AL2(GOTORULE)  GOTO RULE?\n         BNE   INTRPTIT_TST_TOKNS  NO, CONTINUE\n         SPACE 1\n         L     R8,@SYNNXTA        GET NEXT RULE ADDR\n         SPACE 1\nINTRPTIT_TST_TOKNS DS 0H\n         CLC   @SYNTOKN,@TOKNTYP  MATCHING TOKEN TYPE?\n         BNE   INTRPTIT_GET_NXTRULE  NO, CONTINUE\n         SPACE 1\n         ICM   R2,B'1111',@SYNKYWA  IS THERE A KEYWORD TO COMPARE?\n         BZ    INTRPTIT_TST_UEXIT  NO, CONTINUE\n         SPACE 1\n         CLC   @TOKENLN,0(R2)     DO STRINGS HAVE SAME LENGTHS?\n         BNE   INTRPTIT_GET_NXTRULE  NO, CONTINUE\n         SPACE 1\n         L     R3,@TOKENAD        ADDR OF TOKEN\n         XR    R1,R1              CLEAR WORK REG\n         IC    R1,@TOKENLN        LENGTH OF TOKEN\n         BCTR  R1,R0              MACHINE LENGTH\n         EX    R1,COMPTOKN        IS IT A MATCH?\n         BNE   INTRPTIT_GET_NXTRULE  NO, CONTINUE\n         SPACE 1\nINTRPTIT_TST_UEXIT DS 0H\n         ICM   R15,B'1111',@SYNACTA  USER EXIT SPECIFIED?\n         BZ    INTRPTIT_NXTRULE_NXTTOKN  NO, CONTINUE\n         SPACE 1\n         LA    R1,UEXITPRM        POINT TO USER EXIT PARM LIST\n         USING EXITPMAP,R1        SET ADDR\n         SPACE 1\n         MVC   @IXTOKAD,@TOKENAD  SAVE ADDR OF CURRENT TOKEN\n         XR    R2,R2              CLEAR WORK REG\n         IC    R2,@TOKENLN        LENGTH OF TOKEN\n         ST    R2,@IXTOKLN        SAVE LENGTH OF CURRENT TOKEN\n         L     R2,@IERRMSG        POINT TO MESSAGE BUFFER\n         MVI   0(R2),X'40'        RESET MESSAGE BUFFER\n         MVC   1(@IXERRML-1,R2),0(R2)  TO BLANKS\n         ST    R2,@IXERRMG        STORE ADDR OF MESSAGE BUFFER\n         BALR  R14,R15            CALL USER'S EXIT\n         SPACE 1\n         LTR   R15,R15            DID USER'S EXIT DETECT A PROBLEM?\n         BZ    INTRPTIT_NXTRULE_NXTTOKN  NO, CONTINUE\n         SPACE 1\n         MVC   @ITOKLEN,@IXTOKLN  STORE TOKEN LENGTH\n         MVC   @ITOKNAD,@IXTOKAD  STORE ADDR OF TOKEN\n         MVC   RETCODE,RC_8       SET RETURN CODE\n         B     INTRPTIT_EXIT      GET OUT\n         SPACE 1\n         DROP  R1\n         SPACE 1\nINTRPTIT_NXTRULE_NXTTOKN DS 0H\n         L     R8,@SYNNXTA        GET ADDR OF NEXT RULE\n         LA    R9,@TOKENL(,R9)    POINT TO NEXT TOKEN\n         B     INTRPTIT_LOOP_01   CONTINUE\n         SPACE 1\nINTRPTIT_GET_NXTRULE DS 0H\n         LA    R8,@SYNTOKN_LEN(,R8) POINT TO NEXT RULE\n         B     INTRPTIT_LOOP_01   CONTINUE\n         SPACE 1\nINTRPTIT_EXIT DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\nCOMPTOKN CLC   0(*-*,R3),1(R2)    ** SUBJECT OF EX INSTR **\n         SPACE 1\n         DROP  R7,R8,R9\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nSAVEAREA DS    18F                REGISTER SAVE AREA\n@PARM    DS    A                  OS PARM ADDR\nRETCODE  DS    F                  RETURN CODE\n*\nRC_4     DC    F'4'               RC = 4\nRC_8     DC    F'8'               RC = 8\n*\nSTACK    #STACK STACK=STACK,LEVELS=4,ACTION=GEN  DEFINE STACK AREA\n*\nSTATFLAG DS    X                  STATUS FLAG\nERROR    EQU   X'80'              ERROR\n*\n@PARSWRK DC    V(TOKNSTAK)        ADDR OF PARSER WORK AREA\n@CURSTKE DS    A                  ADDR OF CURRENT STACK ENTRY\n@CONTRUL DC    A(0)               ADDR OF SYNTAX RULE TO RESUME FROM\n*\nUEXITPRM DS    0F\n         DS    CL(@IXPRMLN)       USER EXIT PARM LIST\n*\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@PARSE": {"ttr": 546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x008\\x01\\x05(\\x7f\\x01\\x05)\\x0f\\x12\\x05\\x01n\\x01I\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2005-10-14T00:00:00", "modifydate": "2005-10-17T12:05:38", "lines": 366, "newlines": 329, "modlines": 0, "user": "RICHARD"}, "text": "         TITLE '@PARSE - PERFORM LEXICAL SCAN AND CREATE TOKENS'\n***********************************************************************\n*                                                                     *\n* MODULE NAME : @PARSE                                                *\n*                                                                     *\n*                                                                     *\n* DESCRIPTIVE NAME : PERFORM LEXICAL SCAN AND CREATE TOKENS           *\n*                                                                     *\n*                                                                     *\n* FUNCTION :  PERFORMA A LEXICAL SCAN OF A CHARACTER STRING, CREATE   *\n*             TOKENS, AND STORE THEM ON A FIFO STACK.                 *\n*                                                                     *\n*             THE CRITERIA FOR A TOKEN ARE AS FOLLOWS:                *\n*                                                                     *\n*             1) IF A CHARACTER MATCHES AN ENTRY IN THE DELIMITER     *\n*                TABLE, AND THE DELIMITER IS MARKED ACTIVE, THE       *\n*                CHARACTER IS REPRESENTED BY A SINGLE (DELIMITER)     *\n*                TOKEN.                                               *\n*                                                                     *\n*             2) CONTIGUOUS ALPHAMERIC CHARACTERS THAT DO NOT CONTAIN *\n*                ANY ACTIVE DELIMITERS ARE TREATED AS A SINGLE ENTITY *\n*                AND IS REPRESENTED BY A SINGLE (DATA) TOKEN.         *\n*                                                                     *\n*             3) CONTIGUOUS NUMERIC DIGITS ARE TREATED AS A SINGLE    *\n*                ENTITY AND IS REPRESENTED BY A SINGLE (NUMERIC)      *\n*                TOKEN.                                               *\n*                                                                     *\n*             4) A SPECIAL TOKEN IS ADDED TO THE END OF THE STACK     *\n*                THAT SERVES AS AN END-OF-STACK MARKER.               *\n*                                                                     *\n* ENTRY: FROM CALLER                                                  *\n*                                                                     *\n* EXIT:  RETURN TO CALLER                                             *\n*                                                                     *\n*                                                                     *\n* INPUT:                                                              *\n*                                                                     *\n*    PARMS:     WORD-1 = ADDR OF CHARACTER STING                      *\n*               WORD-2 = STRING LENGTH                                *\n*               WORD-3 = ADDR OF DELIMITER ARRAY                      *\n*                                                                     *\n* OUTPUT:                                                             *\n*                                                                     *\n*    RETURN CODE:  0 = OK                                             *\n*                  4 = ADDR FOR COMMAND STRING IS ZERO                *\n*                  8 = INVALID STRING LENGTH                          *\n*                 12 = ADDR FOR DELIMITER ARRAY IS ZERO               *\n*                                                                     *\n*                                                                     *\n* ABENDS:                                                             *\n*                                                                     *\n*   SEE MESSAGES (IF ANY)                                             *\n*                                                                     *\n*--PROPRIETARY_STATEMENT----------------------------------------------*\n*                                                                     *\n*  THIS PROGRAM IS THE SOLE PROPERTY OF RICHARD TSUJIMOTO, INC.       *\n*                                                                     *\n***********************************************************************\n* CHANGE HISTORY:                                                     *\n* --------------                                                      *\n* 2005-OCT-17 RXT CHANGE BRANCH LABEL FROM PARSEIT_NOTONLY TO         *\n*                 PARSEIT_ONLY                                        *\n* 2005-OCT-14 RXT FOLLOWING CHANGES MADE:                             *\n*                 1. CHECK FOR TOGGLE FLAG IN A GIVEN DELIMITER, IF   *\n*                    ON TOGGLE LOCAL TOGGLE FLAG                      *\n*                 2. IF DELIMITER IS PTPAD (E.G. BLANK), THE DECISION *\n*                    TO TOKENIZE IT IS DEPENDENT ON THE LOCAL TOGGLE  *\n*                    FLAG                                             *\n*                 3. STORE EOS TOKEN WITH ALL ATTRIBUTES SET, E.G.    *\n*                    TOKEN TYPE, TOKEN SIZE, ADDR OF EOS IN INPUT     *\n*                 4. CHECK IF EOS IS THE ONLY TOKEN ON THE STACK      *\n* 2005-JUN-27 RXT CREATED                                             *\n***********************************************************************\n         EJECT\n         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R12                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         EJECT\n         @TOKEN  MF=ALL\n         EJECT\n$PRMLST1 @PARSE  MF=DSECT\n         SPACE 2\n$DELIMTB @DELIM  MF=DSECT\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\n@PARSE   #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         #OWNER VER=V1R0M0\n         SPACE 1\n         ENTRY TOKNSTAK\n         SPACE 1\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         BAL   LINKREG,INIT       INITIALIZE STACK, BUFFERS, ETC.\n         SPACE 1\n         BAL   LINKREG,CHKPARM    VALIDATE PARAMETERS\n         CLI   STATFLAG,ERROR     OK ?\n         BE    EXIT               NO, CONTINUE\n         SPACE 1\n         BAL   LINKREG,PARSEIT    PARSE THE STRING\n         SPACE 1\nEXIT     DS    0H\n         L     R13,SAVEAREA+4     PT TO CALLER'S REG SAVEAREA\n         L     R15,RETCODE        RETURN CODE\n         SPACE 1\n         RETURN (14,12),RC=(15)   THAT'S ALL FOLKS!\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - INITIALIZE BUFFERS, COUNTERS, ETC.                   *\n*                                                                     *\n***********************************************************************\nINIT     DS    0H\n         LR    R5,LINKREG         COPY RETURN REG\n         SPACE 1\n         #STACK STACK=STACK,LEVELS=4,ACTION=INIT  INIT REG STACK\n         SPACE 1\n         XC    RETCODE,RETCODE    RESET RETURN CODE\n         XC    STATFLAG,STATFLAG  RESET STATUS FLAG\n         XC    TOGGLEFG,TOGGLEFG  RESET TOGGLE FLAG\n         SPACE 1\n         LA    R0,TOKNSTAK        POINT TO WORK AREA\n         LA    R1,TOKNSTAKLN      LENGTH OF WORK AREA\n         LR    R2,R1              SOURCE AND TARGET THE SAME\n         XR    R3,R3              PAD BYTE = X'00'\n         MVCL  R0,R2              CLEAR WORK AREA TO NULLS\n         MVC   TOKNSTAK,=CL12'*PARSE STAK*'  STORE EYE-CATCHER\n         SPACE 1\n         LR    LINKREG,R5         RESTORE LINK REG\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - VALIDATE PARAMETERS                                  *\n*                                                                     *\n***********************************************************************\nCHKPARM  DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         L     R3,@PARM           POINT TO PARM LIST\n         USING $PRMLST1,R3        SET ADDR\n         SPACE 1\n         OC    @PCMDADR,@PCMDADR  DID USER SPECIFY COMMAND STRING?\n         BZ    CHKPARM_ERR1       NO, CONTINUE\n         SPACE 1\n         ICM   R1,B'1111',@PCMDLEN IS STRING LENGTH ZERO?\n         BZ    CHKPARM_ERR2       YES, CONTINUE\n         SPACE 1\n         LTR   R1,R1              IS IT LESS THAN 1?\n         BM    CHKPARM_ERR2       YES, CONTINUE\n         SPACE 1\n         C     R1,=A(@PCMDMXL)    IS IT TOO LARGE?\n         BH    CHKPARM_ERR2       YES, CONTINUE\n         SPACE 1\n         OC    @PDELIMA,@PDELIMA  DID USER SPECIFY DELIMITER ARRAY?\n         BZ    CHKPARM_ERR3       NO, CONTINUE\n         SPACE 1\n         B     CHKPARM_EXIT       GET OUT\n         SPACE 1\nCHKPARM_ERR1  DS    0H\n         MVI   STATFLAG,ERROR     SET FLAG\n         MVC   RETCODE,CMDADDR_ERR  SET RETURN CODE\n         B     CHKPARM_EXIT       GET OUT\n         SPACE 1\nCHKPARM_ERR2  DS    0H\n         MVI   STATFLAG,ERROR     SET FLAG\n         MVC   RETCODE,STRLEN_ERR   SET RETURN CODE\n         B     CHKPARM_EXIT       GET OUT\n         SPACE 1\nCHKPARM_ERR3  DS    0H\n         MVI   STATFLAG,ERROR     SET FLAG\n         MVC   RETCODE,DLMTADDR_ERR SET RETURN CODE\n         SPACE 1\nCHKPARM_EXIT  DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\n         DROP  R3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - PARSE STRING AND CREATE TOKENS                       *\n*                                                                     *\n*   REGISTER USAGE:                                                   *\n*      R0-R2 WORK                                                     *\n*      R3    POINTS TO START OF (SUB)STRING                           *\n*      R4    POINTS TO NEXT CHAR IN (SUB)STRING POINTED TO BY R3      *\n*      R5    POINTS TO CURRENT ENTRY IN TOKEN STACK                   *\n*      R6    POINTS TO END OF INPUT STRING                            *\n*      R7    POINTS TO DELIMITER ARRAY                                *\n*      R8    POINTS TO CALLER'S PARAMETER LIST                        *\n*      R9    TOKEN TYPE VALUE                                         *\n*      R10   WORK                                                     *\n*      R11   WORK                                                     *\n*                                                                     *\n***********************************************************************\nPARSEIT  DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         L     R8,@PARM           POINT TO PARM LIST\n         USING $PRMLST1,R8        SET ADDR\n         SPACE 1\n         L     R3,@PCMDADR        POINT TO INPUT STRING\n         LR    R4,R3              POINT TO INPUT STRING\n         L     R1,@PCMDLEN        STRING LENGTH\n         LA    R6,0(R1,R4)        POINT TO END OF STRING\n         LA    R1,TOKNSTAK        POINT TO WORK AREA\n         LA    R5,@TOKENXL(,R1)   POINT TO FIRST STACK ENTRY\n         USING @TOKEN,R5          SET ADDR\n         SPACE 1\nPARSEIT_NXTCHAR DS    0H\n         L     R7,@PDELIMA        POINT TO ARRAY OF DELIMITERS\n         USING $DELIMTB,R7        SET ADDR\n         SPACE 1\n         L     R9,=F'1'           INIT COUNTER\n         SPACE 1\nPARSEIT_CHKDELIM  DS    0H\n         CLI   @DLMITER,@DLMLAST  END OF DELIMITER ARRAY?\n         BE    PARSEIT_BMP_CHAR   YES, CONTINUE\n         SPACE 1\n         CLC   0(1,R4),@DLMITER   IS INPUT CHAR A DELIMITER?\n         BNE   PARSEIT_BMP_DELIM  NO, CONTINUE\n         SPACE 1\n         TM    @DLMSTAT,@DLMACTV  IS THE DELIMITER MARKED ACTIVE?\n         BO    PARSEIT_PRVTOKN    YES, CONTINUE\n         SPACE 1\nPARSEIT_BMP_DELIM  DS    0H\n         LA    R7,@DLMTBLN(,R7)   POINT TO NEXT ARRAY ENTRY\n         LA    R9,1(,R9)          SET NEXT TOKEN TYPE VALUE\n         B     PARSEIT_CHKDELIM   CONTINUE\n         SPACE 1\nPARSEIT_PRVTOKN DS    0H\n         LR    R0,R4              END OF PREV.STRING\n         SR    R0,R3              COMPUTE PREV.STRING LENGTH\n         LTR   R0,R0              IS THIS A DELIMITER?\n         BZ    PARSEIT_DELIM_TOKN  YES, CONTINUE\n         SPACE 1\n         ST    R3,@TOKENAD        STORE ADDR OF PREV.STRING IN TOKEN\n         STC   R0,@TOKENLN        STORE PREV.STRING LENGTH IN TOKEN\n         LA    R11,TOK_IS_DATA    ASSUME STRING IS ALPHAMERIC\n         LR    R10,R0             COPY LENGTH\n         BCTR  R10,0              MACHINE LENGTH\n         EX    R10,CHECKNUM       IS IT NUMERIC?\n         BNZ   PARSEIT_ASSIGN1    NO, CONTINUE\n         SPACE 1\n         LA    R11,TOK_IS_NUM     STRING IS NUMERIC\n         SPACE 1\nPARSEIT_ASSIGN1 DS    0H\n         STCM  R11,B'0011',@TOKNTYP  STORE TOKEN TYPE IN TOKEN\n         LA    R5,@TOKENL(,R5)    POINT TO NEXT STACK ENTRY\n         SPACE 1\nPARSEIT_DELIM_TOKN DS    0H\n         TM    @DLMSTAT,@DLMTOGL  IS PTPAD TOGGLE ON?\n         BNO   PARSEIT_DELIM_NOTOGL  NO, CONTINUE\n         SPACE 1\n         XI    TOGGLEFG,TOGGL_ON  TOGGLE THE FLAG\n         SPACE 1\nPARSEIT_DELIM_NOTOGL DS 0H\n         C     R9,=A(TOK_IS_BLANK)  IS THIS PTPAD?\n         BNE   PARSEIT_SET_SAVDELIM  NO, CONTINUE\n         SPACE 1\n         CLI   TOGGLEFG,TOGGL_ON  TOKENIZE PTPAD?\n         BNE   PARSEIT_SET_NEXTCHAR  NO, CONTINUE\n         SPACE 1\nPARSEIT_SET_SAVDELIM DS 0H\n         STCM  R9,B'0011',@TOKNTYP  STORE DELIMITER TYPE IN TOKEN\n         MVI   @TOKENLN,X'01'     STORE DELIMITER LENGTH IN TOKEN\n         ST    R4,@TOKENAD        STORE ADDR OF DELIMITER IN TOKEN\n         LA    R5,@TOKENL(,R5)    POINT TO NEXT STACK ENTRY\n         SPACE 1\nPARSEIT_SET_NEXTCHAR DS 0H\n         LA    R3,1(,R4)          BUMP BEGIN.STRING PTR\n         SPACE 1\nPARSEIT_BMP_CHAR  DS    0H\n         LA    R4,1(,R4)          POINT TO NEXT CHAR IN INPUT STRING\n         CR    R4,R6              END OF THE STRING ?\n         BNE   PARSEIT_NXTCHAR    NO, CONTINUE\n         SPACE 1\n         LR    R0,R4              END OF PREV.STRING\n         SR    R0,R3              COMPUTE PREV.STRING LENGTH\n         LTR   R0,R0              IS THIS THE END-POINT?\n         BZ    PARSEIT_ENDTOKN    YES, CONTINUE\n         SPACE 1\n         ST    R3,@TOKENAD        STORE ADDR OF LAST.STRING IN TOKEN\n         STC   R0,@TOKENLN        STORE LAST.STRING LENGTH  IN TOKEN\n         LA    R11,TOK_IS_DATA    ASSUME STRING IS ALPHAMERIC\n         LR    R10,R0             COPY LENGTH\n         BCTR  R10,0              MACHINE LENGTH\n         EX    R10,CHECKNUM       IS IT NUMERIC?\n         BNZ   PARSEIT_ASSIGN2    NO, CONTINUE\n         SPACE 1\n         LA    R11,TOK_IS_NUM     STRING IS NUMERIC\n         SPACE 1\nPARSEIT_ASSIGN2 DS    0H\n         STCM  R11,B'0011',@TOKNTYP  STORE TOKEN TYPE IN TOKEN\n         LA    R5,@TOKENL(,R5)    POINT TO NEXT STACK ENTRY\n         SPACE 1\nPARSEIT_ENDTOKN DS    0H\n         MVC   @TOKNTYP,=AL2(TOK_IS_EOS)  STORE END-OF-STRING MARKER\n         MVI   @TOKENLN,X'01'     STORE EOS LENGTH IN TOKEN\n         L     R10,@PCMDADR       ASSUME EOS IS ONLY TOKEN ON STACK\n         LA    R11,TOKNSTAK       POINT TO WORK AREA\n         LA    R11,@TOKENXL(,R11)  POINT TO FIRST STACK ENTRY\n         CR    R11,R5             IS EOS THE ONLY TOKEN ON THE STACK?\n         BE    PARSEIT_ONLY       YES, CONTINUE\n         SPACE 1\n         LR    R1,R5              COPY ADDR OF CURRENT STACK ENTRY\n         S     R1,=A(@TOKENL)     BACKUP TO PREVIOUS STACK ENTRY\n         L     R10,@TOKENAD-@TOKEN(,R1)  GET ADDR OF PREV.STRING\n         XR    R11,R11            CLEAR WORK REG\n         IC    R11,@TOKENLN-@TOKEN(,R1)  GET LENGTH OF PREV.STRING\n         AR    R10,R11            POINT TO LOC. OF EOS\n         SPACE 1\nPARSEIT_ONLY DS 0H\n         ST    R10,@TOKENAD       STORE ADDR OF EOS IN TOKEN\n         SPACE 1\nPARSEIT_EXIT  DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\nCHECKNUM TRT   0(*-*,R3),NUMTAB   ** SUBJECT OF EX INSTR **\n         SPACE 1\n         DROP  R5,R7,R8\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nSAVEAREA DS    18F                REGISTER SAVE AREA\n@PARM    DS    A                  OS PARM ADDR\nRETCODE  DS    F                  RETURN CODE\nDUBLWORK DS    D                  DOUBLEWORD WORK AREA\n*\nSTACK    #STACK STACK=STACK,LEVELS=4,ACTION=GEN  DEFINE STACK AREA\n*\nSTATFLAG DS    X                  STATUS FLAG\nERROR    EQU   X'80'              ERROR\n*\nCMDADDR_ERR  DC    F'4'           ADDR FOR COMMAND STRING IS ZERO\nSTRLEN_ERR   DC    F'8'           INVALID STRING LENGTH\nDLMTADDR_ERR DC    F'12'          ADDR FOR DELIMITER TABLE IS ZERO\n*\nTOGGLEFG DS    X                  TOGGLE PTPAD FLAG\nTOGGL_ON EQU   X'80'                 ON\n*\nNUMTAB   DC    256X'FF'           TRT TABLE FOR NUMERIC VALUES\n         ORG   NUMTAB+C'0'\n         DC    10X'00'            0-9\n         ORG   ,\n*\nTOKNSTAK @PARSE MF=GENWORK        @PARSE WORK AREA\nTOKNSTAKLN EQU *-TOKNSTAK         LENGTH OF WORK AREA\n*\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@SYNTXCK": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x05(\\x7f\\x01\\x05(\\x7f\\x11I\\x01\\x0b\\x01\\x0b\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-10-14T00:00:00", "modifydate": "2005-10-14T11:49:58", "lines": 267, "newlines": 267, "modlines": 0, "user": "RICHARD"}, "text": "         TITLE '@SYNTXCK - PERFORM SYNTAX CHECK ON CHARACTER STRING'\n***********************************************************************\n*                                                                     *\n* MODULE NAME : @SYNTXCK                                              *\n*                                                                     *\n*                                                                     *\n* DESCRIPTIVE NAME : PERFORM SYNTAX CHECK ON CHARACTER STRING         *\n*                                                                     *\n*                                                                     *\n* FUNCTION :  PROCESS TOKENS STORED ON A STACK THAT WAS CREATED BY    *\n*             @PARSE, VALIDATING THE SYNTAX OF THE CHARACTER STRING   *\n*             THE SYNTAX RULES ARE PROVIDED BY THE USER, USING THE    *\n*             @RULE MACRO.                                            *\n*                                                                     *\n* ENTRY: FROM CALLER                                                  *\n*                                                                     *\n* EXIT:  RETURN TO CALLER                                             *\n*                                                                     *\n*                                                                     *\n* INPUT:                                                              *\n*                                                                     *\n*    PARMS:     WORD-1 = ADDR OF USER'S SYNTAX TABLE                  *\n*               WORD-2 = LENGTH OF TOKEN IN ERROR                     *\n*               WORD-3 = ADDRESS OF TOKEN IN ERROR                    *\n*                                                                     *\n* OUTPUT:                                                             *\n*                                                                     *\n*    RETURN CODE:  0 = OK                                             *\n*                  4 = ADDR OF USER'S SYNTAX TABLE IS ZERO            *\n*                  8 = SYNTAX ERROR DETECTED                          *\n*                 12 = MISSING \"NEXT RULE\" INDEX                      *\n*                                                                     *\n* ABENDS:                                                             *\n*                                                                     *\n*   SEE MESSAGES (IF ANY)                                             *\n*                                                                     *\n*--PROPRIETARY_STATEMENT----------------------------------------------*\n*                                                                     *\n*  THIS PROGRAM IS THE SOLE PROPERTY OF RICHARD TSUJIMOTO, INC.       *\n*                                                                     *\n***********************************************************************\n* CHANGE HISTORY:                                                     *\n* --------------                                                      *\n* 2005-OCT-14 RXT BACKOUT CHANGE OF 2005-AUG-19; TREAT EOS AS A VALID *\n*                 TOKEN; IF ENCOUNTERED PREMATURELY, PROCESS IT AS    *\n*                 A SYNTAX ERROR                                      *\n* 2005-AUG-19 RXT ADD TEST IF TOKEN TYPE IS TOK_IS_EOS, AND BACKUP    *\n*                 TO PRIOR TOKEN AND PROCESS AS A SYNTAX ERROR        *\n* 2005-JUL-26 RXT REMOVE STATEMENT BACKING UP TO PRIOR TOKEN WHEN A   *\n*                 SYNTAX ERROR IS ENCOUNTERED                         *\n* 2005-JUN-30 RXT CREATED                                             *\n***********************************************************************\n         EJECT\n         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R12                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         EJECT\n         @TOKEN   MF=ALL\n         EJECT\n#SYNTMAP @SYNTXCK MF=DSECT\n         EJECT\n#SYNTXTB @RULE    MF=DSECT\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\n@SYNTXCK #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         #OWNER VER=V1R0M0\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         BAL   LINKREG,INIT       INITIALIZE STACK, BUFFERS, ETC.\n         SPACE 1\n         BAL   LINKREG,CHKPARM    VALIDATE PARAMETERS\n         CLI   STATFLAG,ERROR     OK ?\n         BE    EXIT               NO, CONTINUE\n         SPACE 1\n         BAL   LINKREG,SYNTXCHK   VALIDATE STRING'S SYNTAX\n         SPACE 1\nEXIT     DS    0H\n         L     R13,SAVEAREA+4     PT TO CALLER'S REG SAVEAREA\n         L     R15,RETCODE        RETURN CODE\n         SPACE 1\n         RETURN (14,12),RC=(15)   THAT'S ALL FOLKS!\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - INITIALIZE BUFFERS, COUNTERS, ETC.                   *\n*                                                                     *\n***********************************************************************\nINIT     DS    0H\n         LR    R5,LINKREG         COPY RETURN REG\n         SPACE 1\n         #STACK STACK=STACK,LEVELS=4,ACTION=INIT  INIT REG STACK\n         SPACE 1\n         XC    RETCODE,RETCODE    RESET RETURN CODE\n         XC    STATFLAG,STATFLAG  RESET STATUS FLAG\n         LR    LINKREG,R5         RESTORE LINK REG\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - CHECK PARAMETERS                                     *\n*                                                                     *\n***********************************************************************\nCHKPARM  DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         L     R2,@PARM           POINT TO PARM LIST\n         USING #SYNTMAP,R2        SET ADDR\n         SPACE 1\n         ICM   R1,B'1111',@SYSYNTB  NON-ZERO SYNTAX TABLE ADDRESS?\n         BNZ   CHKPARM_SETPTRS    YES, CONTINUE\n         SPACE 1\n         MVI   STATFLAG,ERROR     SET ERROR FLAG\n         MVC   RETCODE,RC_4       SET RETURN CODE\n         B     CHKPARM_EXIT       GET OUT\n         SPACE 1\nCHKPARM_SETPTRS DS    0H\n         L     R1,@PARSWRK        POINT TO @PARSER WORK AREA\n         LA    R1,@TOKENXL(,R1)   POINT TO BEGINNING OF STACK\n         ST    R1,@CURSTKE        SAVE IT\n         SPACE 1\nCHKPARM_EXIT  DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\n         DROP  R2\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - CHECK SYNTAX OF INPUT STRING                         *\n*                                                                     *\n*                R0-R3 = WORK REGS                                    *\n*                R4-R6 NOT USED                                       *\n*                R7 = @SYNTXCK PARAMETER LIST                         *\n*                R8 = ADDR OF USER'S SYNTAX TABLE/CONTINUATION RULE   *\n*                R9 = ADDR OF CURRENT TOKEN STACK ENTRY               *\n*                R10-R11 NOT USED                                     *\n*                                                                     *\n***********************************************************************\nSYNTXCHK DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         L     R7,@PARM           POINT TO PARM LIST\n         USING #SYNTMAP,R7        SET ADDR\n         SPACE 1\n         ICM   R8,B'1111',@CONTRUL ARE WE IN THE MIDST OF CONTINUATION?\n         BZ    SYNTXCHK_TBL_PTR   NO, COONTINUE\n         SPACE 1\n         XC    @CONTRUL,@CONTRUL  RESET CONTINUATION ADDRESS\n         B     SYNTXCHK_STK_PTR   CONTINUE\n         SPACE 1\nSYNTXCHK_TBL_PTR DS 0H\n         L     R8,@SYSYNTB        POINT TO USER'S SYNTAX TABLE\n         USING #SYNTXTB,R8        ADDR IT\n         SPACE 1\nSYNTXCHK_STK_PTR DS 0H\n         L     R9,@CURSTKE        POINT TO CURRENT STACK ENTRY\n         USING @TOKEN,R9          ADDR IT\n         SPACE 1\nSYNTXCHK_LOOP_01 DS 0H\n         CLC   @SYNTOKN,=AL2(LASTRULE)  LAST SYNTAX RULE?\n         BE    SYNTXCHK_EXIT      YES, GET OUT\n         SPACE 1\n         CLC   @SYNTOKN,=AL2(SYNTAXERR) SYNTAX ERROR?\n         BE    SYNTXCHK_SYNTAXERR YES, CONTINUE\n         SPACE 1\n         CLC   @SYNTOKN,=AL2(CONTRULE) STATEMENT CONTINUATION?\n         BNE   SYNTXCHK_TST_GOTO  NO, CONTINUE\n         SPACE 1\n         ICM   R1,B'1111',@SYNNXTA  NON-ZERO NEXT RULE ADDR?\n         BZ    SYNTXCHK_BADRULE   NO, CONTINUE\n         SPACE 1\n         ST    R1,@CONTRUL        SET CONTINUATION ADDRESS\n         B     SYNTXCHK_GET_NXTRULE CONTINUE\n         SPACE 1\nSYNTXCHK_TST_GOTO  DS 0H\n         CLC   @SYNTOKN,=AL2(GOTORULE) GOTO RULE?\n         BNE   SYNTXCHK_TST_TOKNS NO, CONTINUE\n         SPACE 1\n         ICM   R8,B'1111',@SYNNXTA  NON-ZERO NEXT RULE ADDR?\n         BZ    SYNTXCHK_BADRULE   NO, CONTINUE\n         SPACE 1\nSYNTXCHK_TST_TOKNS DS 0H\n         CLC   @SYNTOKN,@TOKNTYP  TOKEN MATCH SYNTAX RULE TOKEN TYPE?\n         BNE   SYNTXCHK_GET_NXTRULE NO, CONTINUE\n         SPACE 1\n         ICM   R2,B'1111',@SYNKYWA  IS THERE A KEYWORD TO COMPARE?\n         BZ    SYNTXCHK_NXTRULE_NXTTOKN NO, CONTINUE\n         SPACE 1\n         CLC   @TOKENLN,0(R2)     DO THE STRINGS HAVE SAME LENGTHS?\n         BNE   SYNTXCHK_GET_NXTRULE NO, CONTINUE\n         SPACE 1\n         L     R3,@TOKENAD        ADDR OF TOKEN\n         XR    R1,R1              CLEAR WORK REG\n         IC    R1,@TOKENLN        LENGTH OF TOKEN\n         BCTR  R1,R0              MACHINE LENGTH\n         EX    R1,COMPTOKN        DOES THE TOKEN MATCH THE KEYWORD?\n         BNE   SYNTXCHK_GET_NXTRULE NO, CONTINUE\n         SPACE 1\nSYNTXCHK_NXTRULE_NXTTOKN DS 0H\n         ICM   R1,B'1111',@SYNNXTA  NON-ZERO NEXT RULE ADDR?\n         BZ    SYNTXCHK_BADRULE   NO, CONTINUE\n         SPACE 1\n         LR    R8,R1              SET NEXT RULE ADDR\n         LA    R9,@TOKENL(,R9)    POINT TO NEXT TOKEN\n         B     SYNTXCHK_LOOP_01   CONTINUE\n         SPACE 1\nSYNTXCHK_GET_NXTRULE DS 0H\n         LA    R8,@SYNTOKN_LEN(,R8) POINT TO NEXT RULE\n         B     SYNTXCHK_LOOP_01   CONTINUE\n         SPACE 1\nSYNTXCHK_SYNTAXERR DS 0H\n         XC    @CONTRUL,@CONTRUL  RESET CONTINUATION ADDRESS\n         XR    R1,R1              CLEAR WORK REG\n         IC    R1,@TOKENLN        LENGTH OF TOKEN\n         ST    R1,@SYTOKLN        SAVE IT\n         MVC   @SYTOKAD,@TOKENAD  ADDR OF TOKEN\n         MVC   RETCODE,RC_8       SET BAD RETURN CODE\n         B     SYNTXCHK_EXIT      GET OUT\n         SPACE 1\nSYNTXCHK_BADRULE DS    0H\n         XC    @CONTRUL,@CONTRUL  RESET CONTINUATION ADDRESS\n         ST    R8,@SYTBRAD        STORE ADDR OF INVALID RULE\n         MVC   RETCODE,RC_12      SET BAD RETURN CODE\n         SPACE 1\nSYNTXCHK_EXIT DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\nCOMPTOKN CLC   0(*-*,R3),1(R2)    ** SUBJECT OF EX INSTR **\n         SPACE 1\n         DROP  R7,R8,R9\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nSAVEAREA DS    18F                REGISTER SAVE AREA\n@PARM    DS    A                  OS PARM ADDR\nRETCODE  DS    F                  RETURN CODE\nRC_4     DC    F'4'               RC = 4\nRC_8     DC    F'8'               RC = 8\nRC_12    DC    F'12'              RC = 12\n*\nSTATFLAG DS    X                  STATUS FLAG\nERROR    EQU   X'80'              ERROR\n*\n@PARSWRK DC    V(TOKNSTAK)        ADDR OF PARSER WORK AREA\n@CURSTKE DS    A                  ADDR OF CURRENT STACK ENTRY\n@CONTRUL DC    A(0)               ADDR OF SYNTAX RULE TO RESUME FROM\n*\nSTACK    #STACK STACK=STACK,LEVELS=5,ACTION=GEN  DEFINE STACK AREA\n*\n         SPACE 1\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T@INTRPT": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x009\\x01\\x05\\x18\\x7f\\x01\\x05 o\\x14Y\\x01G\\x01\\xd5\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2005-07-06T00:00:00", "modifydate": "2005-07-25T14:59:39", "lines": 327, "newlines": 469, "modlines": 0, "user": "RICHARD"}, "text": "         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R11                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         EJECT\n#PARSMAP @PARSE MF=DSECT\n         SPACE 2\n#SYNTMAP @SYNTXCK MF=DSECT\n         SPACE 2\n#INTRMAP @INTRPRT MF=DSECT\n         SPACE 2\n#EXITMAP @INTRPRT MF=EXITPARM\n         SPACE 2\n         @TOKEN MF=ALL\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\nT@INTRPT #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         BAL   LINKREG,INIT       INITIALIZE STACK, BUFFERS, ETC.\n         SPACE 1\nNEXTCARD DS    0H\n         GET   SYSIN,INBUFF\n         SPACE 1\n         MVC   INCARD,INBUFF      COPY INPUT\n         LA    R1,ECHOCARD        ECHO INPUT\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         SPACE 1\n         BAL   LINKREG,PARSEIT    PARSE INPUT STRING\n         CLI   STATFLAG,ERROR     OK ?\n         BE    EXIT               NO, GET OUT\n         SPACE 1\n         BAL   LINKREG,SYNTXCHK   CHECK SYNTAX OF INPUT STRING\n         CLI   SYNFLAG,SYNTXERR   OK ?\n         BE    NEXTCARD           NO, CONTINUE\n         SPACE 1\n         BAL   LINKREG,INTRPTIT   PROCESS INPUT STRING\n         SPACE 1\n         B     NEXTCARD           CONTINUE\n         SPACE 1\nEOF      DS    0H\nEXIT     DS    0H\n         L     R13,SAVEAREA+4     PT TO CALLER'S REG SAVEAREA\n         SPACE 1\n         RETURN (14,12),RC=0      THAT'S ALL FOLKS!\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - INITIALIZE BUFFERS, COUNTERS, ETC.                   *\n*                                                                     *\n***********************************************************************\nINIT     DS    0H\n         LR    R5,LINKREG         COPY RETURN REG\n         SPACE 1\n         #STACK STACK=STACK,LEVELS=4,ACTION=INIT  INIT REG STACK\n         SPACE 1\n         XC    STATFLAG,STATFLAG  RESET STATUS FLAG\n         SPACE 1\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n         SPACE 1\n         LR    LINKREG,R5         RESTORE LINK REG\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - PARSE INPUT STRING                                   *\n*                                                                     *\n***********************************************************************\nPARSEIT  DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LA    R3,PARMLST1        POINT TO PARM LIST\n         SPACE 1\n         @PARSE MF=(E,R3)\n         SPACE 1\n         LTR   R15,R15            OK ?\n         BZ    PARSEIX            YES, GET OUT\n         SPACE 1\n         MVI   STATFLAG,ERROR     SET FLAG\n         C     R15,=F'4'          INVALID STRING LENGTH ?\n         BNE   PARSEER            NO, CONTINUE\n         SPACE 1\n         LA    R1,BADLEN          INVALID STRING LENGTH\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         B     PARSEIX            GET OUT\n         SPACE 1\nPARSEER  DS    0H\n         LA    R1,GETMERR         GETMAIN ERROR\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         SPACE 1\nPARSEIX  DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - CHECK SYNTAX OF INPUT STRING                         *\n*                                                                     *\n***********************************************************************\nSYNTXCHK DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         XC    SYNFLAG,SYNFLAG    RESET FLAG\n         LA    R2,PARMLST1        POINT TO @PARSE PARM LIST\n         USING #PARSMAP,R2        SET ADDR\n         SPACE 1\n         LA    R3,PARMLST2        POINT TO #SYNTXCK PARM LIST\n         USING #SYNTMAP,R3        SET ADDR\n         SPACE 1\n         MVC   @SYSYNTB,@SYNTXTB  COPY ADDR OF MY SYNTAX TABLE\n         SPACE 1\n         @SYNTXCK MF=(E,R3)\n         SPACE 1\n         LTR   R15,R15            OK ?\n         BZ    SYNTXCH1           YES, GET OUT\n         SPACE 1\n         MVC   INCARD,=80C' '     CLEAR BUFFER\n         L     R15,@SYTOKAD       POINT TO TOKEN\n         LA    R0,INBUFF          POINT TO INPUT STRING\n         SR    R15,R0             RELATIVE LOC. OF ERROR\n         LA    R1,INCARD          POINT TO OUTPUT BUFFER\n         LA    R1,0(R15,R1)       RELATIVE LOC. OF ERROR FLAG\n         MVI   0(R1),C'$'         STORE ERROR FLAG\n         LA    R1,ECHOCARD        DISPLAY ERROR FLAG\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         LA    R1,SYNERR          SYNTAX ERROR\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         LA    R1,BLNKLNE         BLANK LINE\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         B     SYNTXCHX           GET OUT\n         SPACE 1\nSYNTXCH1 DS    0H\n         LA    R1,SYNOK           SYNTAX IS GOOD\n         BAL   LINKREG,PUTMSG     DISPLAY MESSAGE\n         SPACE 1\nSYNTXCHX DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\n         DROP  R2,R3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - PROCESS INPUT STRING                                 *\n*                                                                     *\n***********************************************************************\nINTRPTIT DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LA    R1,UEXITPRM        POINT TO GLOBALS FOR USER EXITS\n         L     R15,@USREXIT       POINT TO USER EXITS\n         BALR  R14,R15            PASS GLOBALS TO USER EXITS\n         SPACE 1\n         LA    R2,PARMLST1        POINT TO @PARSE PARM LIST\n         USING #PARSMAP,R2        SET ADDR\n         SPACE 1\n         LA    R3,PARMLST4        POINT TO #INTRPTR PARM LIST\n         USING #INTRMAP,R3        SET ADDR\n         SPACE 1\n         MVC   @ISYNTXB,@SYNTXTB  COPY ADDR OF MY SYNTAX RULES\n         SPACE 1\n         @INTRPRT MF=(E,R3)\n         SPACE 1\n         LTR   R15,R15            OK?\n         BZ    INTRPTIT_SHOWDATA  YES, CONTINUE\n         SPACE 1\n         CVD   R15,DUBLWORK       CONVERT TO DECIMAL\n         OI    DUBLWORK+7,X'0F'   MAKE UNSIGNED\n         UNPK  NUMWORK,DUBLWORK+6(2)  CONVERT TO DISPLAY\n         MVC   IBADRC+16(L'NUMWORK),NUMWORK  STORE IN MESSAGE\n         LA    R1,IBDRC           MSG ID\n         BAL   LINKREG,PUTMSG     DISPLAY RC\n         L     R1,@IERRMSG        POINT TO ERROR MESSAGE\n         MVC   IERRMSG(100),0(R1) COPY IT\n         LA    R1,IERR            MSG ID\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         B     INTRPTIT_EXIT      GET OUT\n         SPACE 1\nINTRPTIT_SHOWDATA DS    0H\n         LA    R1,SHOWVAL1        MSG ID\n         BAL   LINKREG,PUTMSG     DISPLAY \"NAME=\" VALUE\n         LA    R1,SHOWSCR1        MSG ID\n         BAL   LINKREG,PUTMSG     DISPLAY 1ST \"SCORES=\" VALUE\n         LA    R1,SHOWSCR2        MSG ID\n         BAL   LINKREG,PUTMSG     DISPLAY 2ND \"SCORES=\" VALUE\n         SPACE 1\n         MVC   NAMEV+5(8),=CL8' '\n         MVC   SCOREV1+8(8),=CL8' '\n         MVC   SCOREV2+8(8),=CL8' '\n         SPACE 1\nINTRPTIT_EXIT DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\n         DROP  R2,R3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - DISPLAY MESSAGE                                      *\n*                                                                     *\n***********************************************************************\nPUTMSG   DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LR    R4,R1              SAVE MESSAGE ID IN PARM LIST\n         LA    R3,PARMLST3        POINT TO #PUTMSG PARM LIST\n         SPACE 1\n         #PUTMSG MF=(E,R3),MSGID=(R4)\n         SPACE 1\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nSAVEAREA DS    18F                REGISTER SAVE AREA\nSUBSAVE  DS    18F                REGISTER SAVE AREA FOR SUBROUTINES\n@PARM    DS    A                  OS PARM ADDR\nDUBLWORK DS    D                  DOUBLE WORD\nRETCODE  DS    F                  RETURN CODE\n*\n@PARSWRK DC    V(TOKNSTAK)        ADDRESS OF TOKEN STACK\n@SYNTXTB DC    V(T@SYNTBL)        ADDR OF MY SYNTAX RULES\n@USREXIT DC    V(T@UEXITS)        ADDR OF USER EXITS\n*\nSTATFLAG DS    X                  STATUS FLAG\nERROR    EQU   X'80'              ERROR\n*\nSYNFLAG  DS    X                  SYNTAX STATUS FLAG\nSYNTXERR EQU   X'80'              SYNTAX ERROR\n*\nNUMWORK  DS    CL2                NUMERIC WORK AREA\n*\nSTACK    #STACK STACK=STACK,LEVELS=4,ACTION=GEN  DEFINE STACK AREA\n*\nPARMLST1 @PARSE MF=L,CMDLINE=INBUFF,CMDLEN=L'INBUFF,DELIMTB=DELIMTAB\n*\nPARMLST2 @SYNTXCK MF=L\n*\nPARMLST3 #PUTMSG MSGTBAD=#MSGTABL,OTDCBAD=SYSPRINT,OTBUFAD=MSGOBUFF,   +\n               OTBUFLN=L'MSGOBUFF,MF=L\n*\nPARMLST4 @INTRPRT MF=L,ERRMSG=IERRMSG\n*\nDELIMTAB @DELIM MF=GEN,PTDASH=NO,PTUBAR=NO,PTPOUND=NO,PTSLASH=NO,      +\n               PTCOLON=NO,PTPERIOD=NO,PTDOLLAR=NO\n*\nUEXITPRM DS    0A                 ALIGNMENT\n         DC    A(NAMEV)           ADDR OF NAME\n         DC    A(SCOREV1)         ADDR OF SCOREV1\n         DC    A(SCOREV2)         ADDR OF SCOREV2\n*\nINBUFF   DS    CL80               INPUT  BUFFER\nMSGOBUFF DS    CL120              OUTPUT BUFFER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   MESSAGES                                                          *\n*                                                                     *\n***********************************************************************\n#MSGTABL #GENMSG TYPE=INITIAL\n         #GENMSG TYPE=ENTRY,MSGID=BADLEN,                              +\n               MSGTXT='*** INVALID STRING LENGTH(S) ***'\n         #GENMSG TYPE=ENTRY,MSGID=GETMERR,                             +\n               MSGTXT='*** GETMAIN FAILED ***'\nINCARD   #GENMSG TYPE=ENTRY,MSGID=ECHOCARD,                            +\n               MSGTXT='                                                +\n                                               '\nIBADRC   #GENMSG TYPE=ENTRY,MSGID=IBDRC,                               +\n               MSGTXT='*** @INTRPRT RC=XX'\nIERRMSG  #GENMSG TYPE=ENTRY,MSGID=IERR,                                +\n               MSGTXT='123456789012345678901234567890123456789012345678+\n               9012345678901234567890123456789012345678901234567890'\n         #GENMSG TYPE=ENTRY,MSGID=SYNERR,                              +\n               MSGTXT='*** SYNTAX ERROR ***'\n         #GENMSG TYPE=ENTRY,MSGID=BLNKLNE,                             +\n               MSGTXT='  '\n         #GENMSG TYPE=ENTRY,MSGID=SYNOK,                               +\n               MSGTXT='+++ ABOVE CARD IS SYNTACTICALLY CORRECT +++'\nNAMEV    #GENMSG TYPE=ENTRY,MSGID=SHOWVAL1,                            +\n               MSGTXT='NAME=        '\nSCOREV1  #GENMSG TYPE=ENTRY,MSGID=SHOWSCR1,                            +\n               MSGTXT='SCORE-1=        '\nSCOREV2  #GENMSG TYPE=ENTRY,MSGID=SHOWSCR2,                            +\n               MSGTXT='SCORE-2=        '\n         #GENMSG TYPE=LAST\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SYNTAX RULES                                                      *\n*                                                                     *\n*       MYCMD NAME=YOURNAME, SCORES=(NUM1,NUM2)                       *\n*                                                                     *\n*                 - OR -                                              *\n*                                                                     *\n*       MYCMD NAME=YOURNAME, +                                        *\n*             SCORES=(NUM1,MUM2)                                      *\n*                                                                     *\n*   SYNTAX TABLE IS A CSECT CALLED T@SYNTBL                           *\n*                                                                     *\n***********************************************************************\n         PRINT NOGEN\n*        COPY  SYNTXTBL\n         EJECT\n***********************************************************************\n*                                                                     *\n*   DATA SET DEFINITIONS                                              *\n*                                                                     *\n***********************************************************************\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=EOF\n         SPACE 1\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=F,BLKSIZE=120\n         SPACE 1\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T@PARSE": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00B\\x01\\x05\\x17O\\x01\\x05 o\\x14T\\x00\\xda\\x01\\n\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2005-06-23T00:00:00", "modifydate": "2005-07-25T14:54:42", "lines": 218, "newlines": 266, "modlines": 0, "user": "RICHARD"}, "text": "         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R11                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         EJECT\n         @TOKEN   MF=ALL\n         EJECT\n$PARSMAP @PARSE   MF=DSECT\n         EJECT\n$SYNTMAP @SYNTXCK MF=DSECT\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\nT@PARSE  #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         BAL   LINKREG,INIT       INITIALIZE STACK, BUFFERS, ETC.\n         SPACE 1\nNEXTCARD DS    0H\n         GET   SYSIN,STRING       GET TEST STRING\n         SPACE 1\n         MVI   MSGOBUFF,X'40'     RESET OUTPUT BUFFER\n         MVC   MSGOBUFF+1(L'MSGOBUFF-1),MSGOBUFF  TO BLANKS\n         MVC   MSGOBUFF(L'STRING),STRING  COPY INPUT TO OUTPUT BUFFER\n         PUT   SYSPRINT,MSGOBUFF  ECHO INPUT\n         SPACE 1\n         BAL   LINKREG,PARSEIT    PARSE INPUT STRING\n         CLI   STATFLAG,ERROR     OK ?\n         BE    NEXTCARD           NO, CONTINUE\n         SPACE 1\n         BAL   LINKREG,PRNTTOKN   PRINT CONTENTS OF TOKEN ENTRY\n         B     NEXTCARD           NO, CONTINUE\n         SPACE 1\nEOF      DS    0H\nEXIT     DS    0H\n         L     R13,SAVEAREA+4     PT TO CALLER'S REG SAVEAREA\n         SPACE 1\n         RETURN (14,12),RC=0      THAT'S ALL FOLKS!\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - INITIALIZE BUFFERS, COUNTERS, ETC.                   *\n*                                                                     *\n***********************************************************************\nINIT     DS    0H\n         LR    R5,LINKREG         COPY RETURN REG\n         SPACE 1\n         #STACK STACK=STACK,LEVELS=4,ACTION=INIT  INIT REG STACK\n         SPACE 1\n         XC    STATFLAG,STATFLAG  RESET STATUS FLAG\n         SPACE 1\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n         SPACE 1\n         LR    LINKREG,R5         RESTORE LINK REG\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - PARSE INPUT STRING                                   *\n*                                                                     *\n***********************************************************************\nPARSEIT  DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LA    R3,PARMLST1        POINT TO PARM LIST\n         SPACE 1\n         @PARSE MF=(E,R3)\n         SPACE 1\n         LTR   R15,R15            OK ?\n         BZ    PARSEIX            YES, GET OUT\n         SPACE 1\n         MVI   STATFLAG,ERROR     SET FLAG\n         LA    R1,BADLEN          INVALID STRING LENGTH\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         SPACE 1\nPARSEIX  DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - DISPLAY MESSAGE                                      *\n*                                                                     *\n***********************************************************************\nPRNTTOKN DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LA    R7,PARMLST1        POINT TO PARM LIST\n         USING $PARSMAP,R7        SET ADDR\n         SPACE 1\n         L     R7,@PARSWRK        POINT TO @PARSER WORK AREA\n         LA    R7,@TOKENXL(,R7)   POINT TO BEGINNING OF STACK\n         USING @TOKEN,R7          SET ADDR\n         SPACE 1\nPRNTTOKV DS    0H\n         MVC   TOKN+26(10),=CL10' '  RESET OUTPUT AREA\n         XR    R2,R2              RESET WORK REG\n         ICM   R2,B'0011',@TOKNTYP  TOKEN ID\n         SLL   R2,4               MAKE ROOM FOR DUMMY SIGN\n         XC    DUBLWORK,DUBLWORK  RESET WORK AREA\n         ST    R2,DUBLWORK+4      SAVE TOKEN ID\n         OI    DUBLWORK+7,X'0F'   MAKE UNSIGNED\n         UNPK  WTOKNID(4),DUBLWORK+5(3)  UNPACK IT\n         TR    WTOKNID,HEXTAB     CONVERT TO DISPLAYABLE HEX\n         MVC   TOKN+6(4),WTOKNID  COPY TOKEN ID TO OUTPUT AREA\n         XR    R1,R1              RESET WORK REG\n         IC    R1,@TOKENLN        TOKEN LENGTH\n         LR    R3,R1              COPY IT\n         CVD   R3,DUBLWORK        CONVERT TO DECIMAL\n         OI    DUBLWORK+7,X'0F'   MAKE IT UNSIGNED\n         UNPK  TOKN+16(2),DUBLWORK+6(2)  COPY LENGTH TO OUTPUT AREA\n         LTR   R1,R1              DOES TOKEN EXIST?\n         BZ    PRNTTOKP           NO, CONTINUE\n         SPACE 1\n         BCTR  R1,R0              MACHINE LENGTH\n         L     R2,@TOKENAD        ADDR OF TOKEN\n         EX    R1,COPYTOKN        COPY TOKEN TO OUTPUT AREA\n         SPACE 1\nPRNTTOKP DS    0H\n         LA    R1,SHOWTOKN        MSG ID\n         BAL   LINKREG,PUTMSG     DISPLAY TOKEN ENTRY FIELDS\n         CLC   @TOKNTYP,=AL2(TOK_IS_EOS)  END OF STACK ?\n         BE    PRNTTOKX           YES, GET OUT\n         SPACE 1\n         LA    R7,@TOKENL(,R7)    POINT TO NEXT TOKEN ENTRY\n         B     PRNTTOKV           CONTINUE\n         SPACE 1\nPRNTTOKX DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\nCOPYTOKN MVC   TOKN+26(*-*),0(R2) ** SUBJECT OF EXT INSTR **\n         SPACE 1\n         DROP  R7\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - DISPLAY MESSAGE                                      *\n*                                                                     *\n***********************************************************************\nPUTMSG   DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LR    R4,R1              SAVE MESSAGE ID IN PARM LIST\n         LA    R3,PARMLST3        POINT TO #PUTMSG PARM LIST\n         SPACE 1\n         #PUTMSG MF=(E,R3),MSGID=(R4)\n         SPACE 1\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nSAVEAREA DS    18F                REGISTER SAVE AREA\n@PARM DS       A                  OS PARM ADDR\nRETCODE  DS    F                  RETURN CODE\nDUBLWORK DS    D                  DOUBLEWORD WORK AREA\n*\nSTATFLAG DS    X                  STATUS FLAG\nERROR    EQU   X'80'              ERROR\n*\n@PARSWRK DC    V(TOKNSTAK)        ADDRESS OF TOKEN STACK\n*\nSTACK    #STACK STACK=STACK,LEVELS=4,ACTION=GEN  DEFINE STACK AREA\n*\nPARMLST1 @PARSE MF=L,CMDLINE=STRING,CMDLEN=L'STRING,DELIMTB=DELIMTAB\n*\nDELIMTAB @DELIM MF=GEN,PTDASH=NO,PTUBAR=NO,PTPOUND=NO,PTSLASH=NO,      +\n               PTCOLON=NO,PTPERIOD=NO,PTDOLLAR=NO\n*\nWTOKNID  DS    CL4                DISPLAY HEX WORK AREA\nHEXTAB   DC    256AL1(*-HEXTAB)   BINARY-TO-DISPLAY HEX TRANSLATE TBL\n         ORG   HEXTAB+X'FA'\n         DC    C'ABCDEF'\n         ORG   ,\n*\nMAXLEN   EQU   80                 MAX STRING LENGTH\nSTRING   DS    CL80               INPUT STRING\n*\nPARMLST3 #PUTMSG MSGTBAD=#MSGTABL,OTDCBAD=SYSPRINT,OTBUFAD=MSGOBUFF,   +\n               OTBUFLN=L'MSGOBUFF,MF=L\n*\nMSGOBUFF DS    CL120              OUTPUT BUFFER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   MESSAGES                                                          *\n*                                                                     *\n***********************************************************************\n#MSGTABL #GENMSG TYPE=INITIAL\n         #GENMSG TYPE=ENTRY,MSGID=BADLEN,                              +\n               MSGTXT='*** INVALID STRING LENGTH ***'\nTOKN     #GENMSG TYPE=ENTRY,MSGID=SHOWTOKN,                            +\n               MSGTXT='++ ID=    , LEN=  , TOKEN=           ++'\n         #GENMSG TYPE=LAST\n         EJECT\n***********************************************************************\n*                                                                     *\n*   DATA SET DEFINITIONS                                              *\n*                                                                     *\n***********************************************************************\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=F,BLKSIZE=120\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=EOF\n         SPACE 1\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "T@SYNTBL": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x18\\x01\\x05)\\x0f\\x01\\x05)\\x0f\\x15\\x15\\x00@\\x00@\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2005-10-17T00:00:00", "modifydate": "2005-10-17T15:15:18", "lines": 64, "newlines": 64, "modlines": 0, "user": "RICHARD"}, "text": "***********************************************************************\n*                                                                     *\n*   T@SYNTBL - SYNTAX TABLE USED BY T@SYNTXC AND T@INTRPT             *\n*                                                                     *\n***********************************************************************\n         @TOKEN MF=ALL\n         EJECT\nT@SYNTBL CSECT\n         @RULE TYPE=INITIAL,EXITLOC=EXTERNAL\n*\nPC0010   @RULE TOK_IS_DATA,NEXT=CMD1010,STRING=MYCMD\n         @RULE SYNTAXERR\n*\nCMD1010  @RULE TOK_IS_DATA,NEXT=CMD2010,STRING=NAME\n         @RULE SYNTAXERR\n*\nCMD2010  @RULE TOK_IS_EQUAL,NEXT=CMD3010\n         @RULE SYNTAXERR\n*\nCMD3010  @RULE TOK_IS_DATA,NEXT=CMD4010,EXIT=EXT1\n         @RULE SYNTAXERR\n*\nCMD4010  @RULE TOK_IS_COMMA,NEXT=CMD5010\n         @RULE SYNTAXERR\n*\nCMD5010  @RULE TOK_IS_DATA,NEXT=CMD5210,STRING=SCORES\n         @RULE TOK_IS_PLUS,NEXT=CMD5020\n         @RULE SYNTAXERR\n*\nCMD5020  @RULE CONTRULE,NEXT=CMD5030\n         @RULE GOTORULE,NEXT=FLUSH\n         @RULE SYNTAXERR\n*\nCMD5030  @RULE TOK_IS_DATA,NEXT=CMD5210,STRING=SCORES\n         @RULE SYNTAXERR\n*\nCMD5210  @RULE TOK_IS_EQUAL,NEXT=CMD6010\n         @RULE SYNTAXERR\n*\nCMD6010  @RULE TOK_IS_LPAREN,NEXT=CMD7010\n         @RULE SYNTAXERR\n*\nCMD7010  @RULE TOK_IS_NUM,NEXT=CMD8010,EXIT=EXT2\n         @RULE SYNTAXERR\n*\nCMD8010  @RULE TOK_IS_RPAREN,NEXT=FLUSH\n         @RULE TOK_IS_COMMA,NEXT=CMD9010\n         @RULE SYNTAXERR\n*\nCMD9010  @RULE TOK_IS_NUM,NEXT=CMDA010,EXIT=EXT3\n         @RULE SYNTAXERR\n*\nCMDA010  @RULE TOK_IS_RPAREN,NEXT=FLUSH\n         @RULE SYNTAXERR\n*\n*   RULES TO VALIDATE THAT REMAINDER OF COMMAND STRING IS BLANK\n*\nFLUSH    @RULE TOK_IS_EOS,NEXT=THE_END\n         @RULE SYNTAXERR\n*\nTHE_END  @RULE LASTRULE\n         @RULE TYPE=FINAL\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "T@SYNTXC": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x01\\x05\\x18\\x1f\\x01\\x05 o\\x14V\\x00\\xe6\\x018\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-06-30T00:00:00", "modifydate": "2005-07-25T14:56:00", "lines": 230, "newlines": 312, "modlines": 0, "user": "RICHARD"}, "text": "         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R11                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         EJECT\n         @TOKEN   MF=ALL\n         EJECT\n$PARSMAP @PARSE   MF=DSECT\n         EJECT\n$SYNTMAP @SYNTXCK MF=DSECT\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\nT@SYNTXC #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         BAL   LINKREG,INIT       INITIALIZE STACK, BUFFERS, ETC.\n         SPACE 1\nNEXTCARD DS    0H\n         GET   SYSIN,INBUFF\n         SPACE 1\n         MVC   INCARD,INBUFF      COPY INPUT\n         LA    R1,ECHOCARD        ECHO INPUT\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         SPACE 1\n         BAL   LINKREG,PARSEIT    PARSE INPUT STRING\n         CLI   STATFLAG,ERROR     OK ?\n         BE    NEXTCARD           NO, CONTINUE\n         SPACE 1\n         BAL   LINKREG,SYNTXCHK   CHECK SYNTAX OF INPUT STRING\n         SPACE 1\n         B     NEXTCARD           NO, CONTINUE\n         SPACE 1\nEOF      DS    0H\nEXIT     DS    0H\n         L     R13,SAVEAREA+4     PT TO CALLER'S REG SAVEAREA\n         SPACE 1\n         RETURN (14,12),RC=0      THAT'S ALL FOLKS!\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - INITIALIZE BUFFERS, COUNTERS, ETC.                   *\n*                                                                     *\n***********************************************************************\nINIT     DS    0H\n         LR    R5,LINKREG         COPY RETURN REG\n         SPACE 1\n         #STACK STACK=STACK,LEVELS=4,ACTION=INIT  INIT REG STACK\n         SPACE 1\n         XC    STATFLAG,STATFLAG  RESET STATUS FLAG\n         SPACE 1\n         OPEN  (SYSIN,(INPUT),SYSPRINT,(OUTPUT))\n         SPACE 1\n         LR    LINKREG,R5         RESTORE LINK REG\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - PARSE INPUT STRING                                   *\n*                                                                     *\n***********************************************************************\nPARSEIT  DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LA    R3,PARMLST1        POINT TO PARM LIST\n         SPACE 1\n         @PARSE MF=(E,R3)\n         SPACE 1\n         LTR   R15,R15            OK ?\n         BZ    PARSEIX            YES, GET OUT\n         SPACE 1\n         MVI   STATFLAG,ERROR     SET FLAG\n         LA    R1,BADLEN          INVALID STRING LENGTH\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         SPACE 1\nPARSEIX  DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - CHECK SYNTAX OF INPUT STRING                         *\n*                                                                     *\n***********************************************************************\nSYNTXCHK DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LA    R2,PARMLST1        POINT TO @PARSE PARM LIST\n         USING $PARSMAP,R2        SET ADDR\n         SPACE 1\n         LA    R3,PARMLST2        POINT TO @SYNTXCK PARM LIST\n         USING $SYNTMAP,R3        SET ADDR\n         SPACE 1\n         MVC   @SYSYNTB,@SYNTXTB  COPY ADDR OF MY SYNTAX TABLE\n         SPACE 1\n         @SYNTXCK MF=(E,R3)\n         SPACE 1\n         LTR   R15,R15            OK ?\n         BZ    SYNTXCH1           YES, GET OUT\n         SPACE 1\n         MVC   INCARD,=80C' '     CLEAR BUFFER\n         L     R15,@SYTOKAD       POINT TO TOKEN\n         LA    R0,INBUFF          POINT TO INPUT STRING\n         SR    R15,R0             RELATIVE LOC. OF ERROR\n         LA    R1,INCARD          POINT TO OUTPUT BUFFER\n         LA    R1,0(R15,R1)       RELATIVE LOC. OF ERROR FLAG\n         MVI   0(R1),C'$'         STORE ERROR FLAG\n         LA    R1,ECHOCARD        DISPLAY ERROR FLAG\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         LA    R1,SYNERR          SYNTAX ERROR\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         LA    R1,BLNKLNE         BLANK LINE\n         BAL   LINKREG,PUTMSG     DISPLAY ERROR MESSAGE\n         B     SYNTXCHX           GET OUT\n         SPACE 1\nSYNTXCH1 DS    0H\n         LA    R1,SYNOK           SYNTAX IS GOOD\n         BAL   LINKREG,PUTMSG     DISPLAY MESSAGE\n         SPACE 1\nSYNTXCHX DS    0H\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         SPACE 1\n         DROP  R2,R3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - DISPLAY MESSAGE                                      *\n*                                                                     *\n***********************************************************************\nPUTMSG   DS    0H\n         #PUSH STACK=STACK        SAVE CALLER'S REGS\n         SPACE 1\n         LR    R4,R1              SAVE MESSAGE ID IN PARM LIST\n         LA    R3,PARMLST3        POINT TO #PUTMSG PARM LIST\n         SPACE 1\n         #PUTMSG MF=(E,R3),MSGID=(R4)\n         SPACE 1\n         #POP  STACK=STACK        RESTORE CALLER'S REGS\n         BR    LINKREG            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nSAVEAREA DS    18F                REGISTER SAVE AREA\n@PARM DS       A                  OS PARM ADDR\nRETCODE  DS    F                  RETURN CODE\nDUBLWORK DS    D                  DOUBLEWORD WORK AREA\n*\nSTATFLAG DS    X                  STATUS FLAG\nERROR    EQU   X'80'              ERROR\n*\n@SYNTXTB DC    V(T@SYNTBL)        ADDR OF SYNTAX TABLE\n@USREXIT DC    V(T@UEXITS)        ADDR OF USER EXITS\n@PARSWRK DC    V(TOKNSTAK)        ADDRESS OF TOKEN STACK\n*\nSTACK    #STACK STACK=STACK,LEVELS=4,ACTION=GEN  DEFINE STACK AREA\n*\nPARMLST1 @PARSE MF=L,CMDLINE=INBUFF,CMDLEN=L'INBUFF,DELIMTB=DELIMTAB\n*\nPARMLST2 @SYNTXCK MF=L\n*\nPARMLST3 #PUTMSG MSGTBAD=#MSGTABL,OTDCBAD=SYSPRINT,OTBUFAD=MSGOBUFF,   +\n               OTBUFLN=L'MSGOBUFF,MF=L\n*\nDELIMTAB @DELIM MF=GEN,PTDASH=NO,PTUBAR=NO,PTPOUND=NO,PTSLASH=NO,      +\n               PTCOLON=NO,PTPERIOD=NO,PTDOLLAR=NO\n*\nINBUFF   DS    CL80               INPUT  BUFFER\nMSGOBUFF DS    CL120              OUTPUT BUFFER\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SYNTAX RULES                                                      *\n*                                                                     *\n*       MYCMD NAME=YOURNAME, SCORES=(NUM1,NUM2)                       *\n*                                                                     *\n*                 - OR -                                              *\n*                                                                     *\n*       MYCMD NAME=YOURNAME, +                                        *\n*             SCORES=(NUM1,MUM2)                                      *\n*                                                                     *\n*   SYNTAX TABLE IS A CSECT CALLED T@SYNTBL                           *\n*                                                                     *\n***********************************************************************\n*        PRINT NOGEN\n*        COPY  SYNTXTBL\n         EJECT\n***********************************************************************\n*                                                                     *\n*   MESSAGES                                                          *\n*                                                                     *\n***********************************************************************\n#MSGTABL #GENMSG TYPE=INITIAL\n         #GENMSG TYPE=ENTRY,MSGID=BADLEN,                              +\n               MSGTXT='*** INVALID STRING LENGTH(S) ***'\n         #GENMSG TYPE=ENTRY,MSGID=GETMERR,                             +\n               MSGTXT='*** GETMAIN FAILED ***'\nINCARD   #GENMSG TYPE=ENTRY,MSGID=ECHOCARD,                            +\n               MSGTXT='                                                +\n                                               '\n         #GENMSG TYPE=ENTRY,MSGID=SYNERR,                              +\n               MSGTXT='*** SYNTAX ERROR ***'\n         #GENMSG TYPE=ENTRY,MSGID=BLNKLNE,                             +\n               MSGTXT='  '\n         #GENMSG TYPE=ENTRY,MSGID=SYNOK,                               +\n               MSGTXT='+++ ABOVE CARD IS SYNTACTICALLY CORRECT +++'\n         #GENMSG TYPE=LAST\n         EJECT\n***********************************************************************\n*                                                                     *\n*   DATA SET DEFINITIONS                                              *\n*                                                                     *\n***********************************************************************\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=F,BLKSIZE=120\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=EOF\n         SPACE 1\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "T@UEXITS": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x05 o\\x01\\x05 o\\x118\\x00\\xb7\\x00<\\x00\\x00\\xd9\\xc9\\xc3\\xc8\\xc1\\xd9\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-07-25T00:00:00", "modifydate": "2005-07-25T11:38:34", "lines": 183, "newlines": 60, "modlines": 0, "user": "RICHARD"}, "text": "         COPY  #REGS\n         SPACE 2\nBASEREG  EQU   R11                BASE REGISTER\nLINKREG  EQU   R14                SUBROUTINE LINK REG\n         SPACE 2\n#EXITMAP @INTRPRT MF=EXITPARM\n         SPACE 2\nGLOBAL   DSECT\n#NAMEV   DS   A                   ADDR OF NAMEV\n#SCOREV1 DS   A                   ADDR OF SCOREV1\n#SCOREV2 DS   A                   ADDR OF SCOREV2\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PERFORM INITIAL HOUSEKEEPING                                      *\n*                                                                     *\n***********************************************************************\nT@UEXITS #ENTRY BASEREG=BASEREG,SAVEAREA=SAVEAREA,PARM=@PARM\n         SPACE 1\n         ENTRY EXT1\n         ENTRY EXT2\n         ENTRY EXT3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   START OF MAIN PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nBEGIN    DS    0H\n         L     R2,@PARM           GET ADDR OF PARM LIST\n         USING GLOBAL,R2          SET ADDR\n         SPACE 1\n         MVC   @NAMEV,#NAMEV      STORE ADDR OF NAMEV\n         MVC   @SCOREV1,#SCOREV1  STORE ADDR OF SCOREV1\n         MVC   @SCOREV2,#SCOREV2  STORE ADDR OF SCOREV2\n         SPACE 1\nEXIT     DS    0H\n         L     R13,SAVEAREA+4     PT TO CALLER'S REG SAVEAREA\n         SPACE 1\n         RETURN (14,12),RC=0      THAT'S ALL FOLKS!\n         SPACE 1\n         DROP  R2\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - ROUTINE TO EXTRACT AND DISPLAY VALUE FOR \"NAME=\"     *\n*                                                                     *\n***********************************************************************\nEXT1     DS    0H\n         PUSH  USING\n         SAVE  (14,12)            SAVE CALLER'S REGS\n         SPACE 1\n         LR    BASEREG,R15        PRIME BASE REG\n         USING EXT1,BASEREG       SET ADDR\n         SPACE 1\n         ST    R13,SUBSAVE+4      SAVE PTR TO CALLER'S REG. SAVE AREA\n         LA    R13,SUBSAVE        PRIME SAVE AREA PTR\n         LR    R7,R1              PARM ADDR\n         USING #EXITMAP,R7        SET ADDR\n         SPACE 1\n         L     R8,@NAMEV          PT TO NAMEV\n         MVC   5(8,R8),=C'        '   RESET OUTPUT FIELD\n         SPACE 1\n         L     R2,@IXTOKAD        ADDR OF TOKEN\n         L     R4,@IXTOKLN        TOKEN LENGTH\n         BCTR  R4,R0              MACHINE LENGTH\n         EX    R4,COPYNAMV        COPY COMMAND KEYWORD TO BUFFER\n         SPACE 1\nEXT1X    DS    0H\n         L     R13,SUBSAVE+4      PT TO CALLER'S REG SAVEAREA\n         SPACE 1\n         RETURN (14,12),RC=0      GO BACK TO @INTRPRT\n         SPACE 1\nCOPYNAMV MVC   5(*-*,R8),0(R2)  ** SUBJECT OF EX INSTR **\n         SPACE 1\n         DROP  R7\n         POP   USING\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - EXTRACT AND DISPLAY 1ST VALUE FOR \"SCORES=\"          *\n*                                                                     *\n***********************************************************************\nEXT2     DS    0H\n         PUSH  USING\n         SAVE  (14,12)            SAVE CALLER'S REGS\n         SPACE 1\n         LR    BASEREG,R15        PRIME BASE REG\n         USING EXT2,BASEREG       SET ADDR\n         SPACE 1\n         XR    R15,R15            CLEAR RC\n         ST    R13,SUBSAVE+4      SAVE PTR TO CALLER'S REG. SAVE AREA\n         LA    R13,SUBSAVE        PRIME SAVE AREA PTR\n         LR    R7,R1              PARM ADDR\n         USING #EXITMAP,R7        SET ADDR\n         SPACE 1\n         L     R8,@SCOREV1        PT TO SCOREV1\n         MVC   8(8,R8),=C'        '   RESET OUTPUT FIELD\n         SPACE 1\n         L     R2,@IXTOKAD        ADDR OF TOKEN\n         L     R4,@IXTOKLN        TOKEN LENGTH\n         BCTR  R4,R0              MACHINE LENGTH\n         EX    R4,COPYSCR1        COPY COMMAND KEYWORD TO BUFFER\n         EX    R4,PACKSCR1        CONVERT TO DECIMAL\n         CP    EXT2WD,=P'0'       VALID NUMERIC?\n         BNE   EXT2X              YES, CONTINUE\n         SPACE 1\n         L     R1,@IXERRMG        POINT TO MESSAGE BUFFER\n         MVC   0(16,R1),=C'>>> 0 IS INVALID'\n         LA    R15,4              INDICATE AN ERROR\n         SPACE 1\nEXT2X    DS    0H\n         L     R13,SUBSAVE+4      PT TO CALLER'S REG SAVEAREA\n         SPACE 1\n         RETURN (14,12),RC=(15)   GO BACK TO @INTRPRT\n         SPACE 1\nEXT2WD   DS    D                  DOUBLE WORD\nPACKSCR1 PACK  EXT2WD,8(*-*,R8) ** SUBJECT OF EX INSTR **\nCOPYSCR1 MVC   8(*-*,R8),0(R2)  ** SUBJECT OF EX INSTR **\n         SPACE 1\n         DROP  R7\n         POP   USING\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE - EXTRACT AND DISPLAY 2ND VALUE FOR \"SCORES=\"          *\n*                                                                     *\n***********************************************************************\nEXT3     DS    0H\n         PUSH  USING\n         SAVE  (14,12)            SAVE CALLER'S REGS\n         SPACE 1\n         LR    BASEREG,R15        PRIME BASE REG\n         USING EXT3,BASEREG       SET ADDR\n         SPACE 1\n         ST    R13,SUBSAVE+4      SAVE PTR TO CALLER'S REG. SAVE AREA\n         LA    R13,SUBSAVE        PRIME SAVE AREA PTR\n         LR    R7,R1              PARM ADDR\n         USING #EXITMAP,R7        SET ADDR\n         SPACE 1\n         L     R8,@SCOREV2        PT TO SCOREV2\n         MVC   8(8,R8),=C'        '   RESET OUTPUT FIELD\n         SPACE 1\n         L     R2,@IXTOKAD        ADDR OF TOKEN\n         L     R4,@IXTOKLN        TOKEN LENGTH\n         BCTR  R4,R0              MACHINE LENGTH\n         EX    R4,COPYSCR2        COPY COMMAND KEYWORD TO BUFFER\n         SPACE 1\nEXT3X    DS    0H\n         L     R13,SUBSAVE+4      PT TO CALLER'S REG SAVEAREA\n         SPACE 1\n         RETURN (14,12),RC=0      GO BACK TO @INTRPRT\n         SPACE 1\nCOPYSCR2 MVC   8(*-*,R8),0(R2)  ** SUBJECT OF EX INSTR **\n         SPACE 1\n         DROP  R7\n         POP   USING\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CONSTANTS, WORK AREAS, ETC.                                       *\n*                                                                     *\n***********************************************************************\nSAVEAREA DS    18F                REGISTER SAVE AREA\nSUBSAVE  DS    18F                REGISTER SAVE AREA FOR SUBROUTINES\n@PARM    DS    A                  OS PARM ADDR\nDUBLWORK DS    D                  DOUBLE WORD\nRETCODE  DS    F                  RETURN CODE\n*\nSTATFLAG DS    X                  STATUS FLAG\nERROR    EQU   X'80'              ERROR\n*\nNUMWORK  DS    CL2                NUMERIC WORK AREA\n*\n@NAMEV   DC    A(0)               ADDR OF NAMEV\n@SCOREV1 DC    A(0)               ADDR OF SCOREV1\n@SCOREV2 DC    A(0)               ADDR OF SCOREV2\n*\nMSGOBUFF DS    CL120              OUTPUT BUFFER\n         SPACE 1\n         LTORG *\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT746/CBT.V500.FILE746.PDS/SOURCE.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT746/CBT.V500.FILE746.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}