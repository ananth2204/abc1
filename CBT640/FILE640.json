{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012518000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 646646, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE640.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE640.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0b\\x05'", "DS1TRBAL": "b'\\x90\\xe6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x93\\x00\\n\\x04\\x94\\x00\\x06\\x00\\x0c'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x04(\\x9f\\x01\\x04(\\x9f\\x11\\x14\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-10-15T00:00:00", "modifydate": "2004-10-15T11:14:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-467"}, "text": "REGULAR CBT TAPE - VERSION 467    FILE:  640\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT467.FILE640\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 7 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,727 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/15/04    11:14:39    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x01\\x03\\x16O\\x01\\x04(\\x9f\\x100\\x01\\xa6\\x01\\x98\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2003-06-13T00:00:00", "modifydate": "2004-10-15T10:30:00", "lines": 422, "newlines": 408, "modlines": 0, "user": "FAJA"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$$NOTE1": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x03\\x17\\x8f\\x01\\x03\\x17\\x8f\\x10X\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-06-27T00:00:00", "modifydate": "2003-06-27T10:58:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "Hi Sam,\n\nHere is a contribution that may be useful for users of Levi, Ray\n& Shoup's VPS printing software.\n\nIt is a template-based separator page exit that allows VPS users\nto:\n\n - print spectacular full-color separator pages,\n - initialise printers,\n - display information on a printer's LCD about the currently\n   printing job etc.\n\nCheers,\nAndrew Armstrong\na.armstrong@optusnet.com.au\n\nBTW, I've changed by email address from andrew_armstrong@bigpond.com\nto a.armstrong@optusnet.com.au (in case you are maintaining a\ndatabase of contributers).\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE640": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04C\\x00\\x00\\x01\\x04(\\x9f\\x01\\x04(\\x9f\\x11\\x14\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf7@@@'", "ispf": {"version": "04.67", "flags": 0, "createdate": "2004-10-15T00:00:00", "modifydate": "2004-10-15T11:14:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "CBT-467"}, "text": "//***FILE 640 is from Andrew Armstrong and contains his VPSSEP      *   FILE 640\n//*           package to help users of Levi Ray and Shoup's VPS     *   FILE 640\n//*           software to print better pages, as described below.   *   FILE 640\n//*           Of course, you have to be licensed for VPS first,     *   FILE 640\n//*           to use this package as an add-on.                     *   FILE 640\n//*                                                                 *   FILE 640\n//*      Short description:                                         *   FILE 640\n//*                                                                 *   FILE 640\n//*      This is a template-based separator page exit that          *   FILE 640\n//*      allows VPS users to:                                       *   FILE 640\n//*                                                                 *   FILE 640\n//*       - print spectacular full-color separator pages,           *   FILE 640\n//*       - initialise printers,                                    *   FILE 640\n//*       - display information on a printer's LCD about the        *   FILE 640\n//*         currently printing job etc.                             *   FILE 640\n//*                                                                 *   FILE 640\n//*      Cheers,                                                    *   FILE 640\n//*      Andrew Armstrong                                           *   FILE 640\n//*      a.armstrong@optusnet.com.au                                *   FILE 640\n//*      aarmstrong@mail.fairfax.com.au                             *   FILE 640\n//*                                                                 *   FILE 640\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GPL": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x03\\x12\\x9f\\x01\\x03\\x17\\x8f\\x14S\\x01\\x1c\\x01\\x1c\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-05-09T00:00:00", "modifydate": "2003-06-27T14:53:00", "lines": 284, "newlines": 284, "modlines": 0, "user": "FAJA"}, "text": "            GNU GENERAL PUBLIC LICENSE\n               Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\n            GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n             END OF TERMS AND CONDITIONS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VPSSEP": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x04(\\x9f\\x01\\x04(\\x9f\\x10$\\n\\x9a\\n\\x9a\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-10-15T00:00:00", "modifydate": "2004-10-15T10:24:00", "lines": 2714, "newlines": 2714, "modlines": 0, "user": "FAJA"}, "text": "/**REXX****************************************************************\n*                                                                     *\n* VPSSEP v1.2 - VPS Dynamic Separator Page Printer                    *\n*                                                                     *\n* Copyright (C) 1998-2004 Andrew J. Armstrong                         *\n* a.armstrong@optusnet.com.au                                         *\n* HPO Computer Services Pty Ltd                                       *\n*                                                                     *\n* This program is free software; you can redistribute it and/or modify*\n* it under the terms of the GNU General Public License as published by*\n* the Free Software Foundation; either version 2 of the License, or   *\n* (at your option) any later version.                                 *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License for more details.                        *\n* You should have received a copy of the GNU General Public License   *\n* along with this program; if not, write to the Free Software         *\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307*\n*                                                                     *\n**********************************************************************/\n/**REXX****************************************************************\n**                                                                   **\n** NAME     - VPSSEP                                                 **\n**                                                                   **\n** FUNCTION - Converts a binary PCL file to an editable format.      **\n**            The resulting template is read by the VPS separator    **\n**            page exit in order to print the separator page on a    **\n**            PCL or Postscript printer.                             **\n**                                                                   **\n**            As the exit scans the template, it substitutes any     **\n**            variables with their current values before sending the **\n**            resulting text to the printer.  The variables are      **\n**            described in the OUTPUT section below.                 **\n**                                                                   **\n**            NOTE: A Postscript file can also be processed, but the **\n**            resulting template will be a series of text records    **\n**            with no special formating of any embedded variables.   **\n**            If you want to create a separator page for a Postscript**\n**            printer then you will have to manually edit the        **\n**            template to ensure that any variables begin in column1.**\n**                                                                   **\n**                                                                   **\n** SYNTAX   - VPSSEP \u00ddindsn \u00ddoutdsn\u00a8\u00a8 \u00dd(options...\u00a8                  **\n**                                                                   **\n**            Where,                                                 **\n**                                                                   **\n**            indsn  = Input dataset containing PCL driver binary    **\n**                     output.                                       **\n**                                                                   **\n**            outdsn = Output dataset to contain the template.       **\n**                     Both the input and output dataset names are   **\n**                     remembered across invocations so you do not   **\n**                     have to re-specify them each time.            **\n**                                                                   **\n**                     If you initially specify a PDS dataset and    **\n**                     member name - e.g. MY.PDS(INPUT1) - then you  **\n**                     can specify just a member name the next time  **\n**                     - e.g. INPUT2 - and the last PDS will be      **\n**                     used.                                         **\n**                                                                   **\n**                     You can ask to be prompted for a dataset name **\n**                     by specifying '..' for indsn or outdsn.       **\n**                                                                   **\n**                     You can ask that the last dataset be used     **\n**                     by specifying '.' for indsn or outdsn.        **\n**                                                                   **\n**                     A typical session might look like:            **\n**                                                                   **\n**                     1. Upload PCL file to a.b.c(m1), then:        **\n**                        tso vpssep                                 **\n**                        Enter input dataset name:                  **\n**                        a.b.c(m1)                                  **\n**                        Converting a.b.c(m1) to a.b.c(m1$)         **\n**                        Building PCL command table...              **\n**                        Reading a.b.c(m1)...                       **\n**                        a.b.c(m1) contains 142 bytes of data       **\n**                        Processing...                              **\n**                        Processed 0%                               **\n**                        Processed 88%                              **\n**                        Processed 92%                              **\n**                        Done                                       **\n**                        ***                                        **\n**                                                                   **\n**                                                                   **\n**                     2. Upload another PCL file to a.b.c(m2), then:**\n**                        tso vpssep m2                              **\n**                        Converting a.b.c(m2) to a.b.c(m2$)         **\n**                        Building PCL command table...              **\n**                        Reading a.b.c(m2)...                       **\n**                        a.b.c(m2) contains 111 bytes of data       **\n**                        Processing...                              **\n**                        Processed 0%                               **\n**                        Processed 88%                              **\n**                        Processed 92%                              **\n**                        Done                                       **\n**                        ***                                        **\n**                                                                   **\n**                                                                   **\n**            options= ASM    - Emit assembly language source code   **\n**                     COM    - Emit * records documenting font      **\n**                              headers and HP/GL2 PE commands       **\n**                     DRAW   - Emit * records that draw each font   **\n**                              character definition (pclxl only).   **\n**                     HEX    - Emit * records for binary data (in   **\n**                              printable hex)                       **\n**                     SPACE  - Emit blank lines                     **\n**                     TRACE  - Trace conversion process             **\n**                     VAR    - Emit & record for variable names     **\n**                     X      - Emit X (printable hex) records rather**\n**                              than B (binary) records for binary   **\n**                              data.                                **\n**                                                                   **\n**                     Prefix any option with 'NO' to negate it.     **\n**                     For example, NOSPACE to supress blank lines.  **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1.  You can create the output file manually, or you can**\n**                speed up the process considerably by using the     **\n**                following procedure:                               **\n**                                                                   **\n**                1.  Use a PC-based program such as MS Word to      **\n**                    create a mock-up banner page.                  **\n**                    Variables may be included in the mock-up (see  **\n**                    SYNTAX below for a list of variables).         **\n**                                                                   **\n**                2.  Select a PCL printer driver for the printer on **\n**                    which the separator page will ulimately be     **\n**                    printed.  Print the mock-up banner page to a   **\n**                    PC file.                                       **\n**                                                                   **\n**                3.  Upload the PC file to a mainframe partitioned  **\n**                    dataset called sFile (see below) to a member   **\n**                    name of your choice.  The sFile                **\n**                    dataset *MUST* be RECFM=VB and can be any      **\n**                    LRECL, but it has been found that a workable   **\n**                    LRECL is around 256.  ISPF edit switches to    **\n**                    browse mode if the record length is too big    **\n**                    because it has to allocate a full record buffer**\n**                    for each record regardless of individual       **\n**                    record lengths...so LRECL=27994 rapidly uses   **\n**                    up memory.                                     **\n**                                                                   **\n**                4.  Run this Rexx procedure, specifying the input  **\n**                    member name and, optionally, the output member **\n**                    name.  If you dont specify the output member   **\n**                    name then the default name is the input member **\n**                    name with a '$' suffix.                        **\n**                                                                   **\n**                5.  Check that the output member looks OK - there  **\n**                    is always room to optimise the output from a   **\n**                    PCL print driver.  The following section       **\n**                    describes the syntax of the output file (ie    **\n**                    this file).                                    **\n**                                                                   **\n**            2.  To get VPS to print this separator page for a      **\n**                particular printer, specify the following in the   **\n**                printer definition member:                         **\n**                                                                   **\n**                SEPAR=(B,exitname,...)                             **\n**                DEVTYPE=member                                     **\n**                                                                   **\n**                Where, exitname  is the name of the separator page **\n**                                 exit WHICH READS THE OUTPUT OF    **\n**                                 THIS REXX PROCEDURE.              **\n**                       member    is the name of the separator page **\n**                                 created by this Rexx procedure.   **\n**                                                                   **\n**            3.  You must also have the sFile dataset (see below)   **\n**                allocated in the VPS started task with a DD name   **\n**                of SEPAR.  The separator page exit will read the   **\n**                member sepcified by DEVTYPE from the partitioned   **\n**                dataset defined by the SEPAR DD.                   **\n**                                                                   **\n**            4.  If you want to run this rexx code on a PC, you can **\n**                install Regina Rexx (free) from:                   **\n**                                                                   **\n**                http://regina-rexx.sourceforge.net/                **\n**                                                                   **\n**                This code has been tested with Regina 3.2.         **\n**                                                                   **\n** INPUT    - A dataset containing raw PCL5, PCLXL (PCL6) or         **\n**            Postscript datastream...'raw' means all ASCII code     **\n**            points must NOT have been translated to EBCDIC.        **\n**            This datastream is typically the output from a Windows **\n**            PCL printer driver directed to a file and uploaded to  **\n**            the mainframe *without* ASCII/EBCDIC conversion.       **\n**                                                                   **\n** OUTPUT   - A dataset that contains either:                        **\n**                                                                   **\n**            1. A special editable version of the input file that   **\n**               is readable by the VPS separator page exit. This is **\n**               called a template.                                  **\n**               For example: TSO VPSSEP indsn                       **\n**                                                                   **\n**               or,                                                 **\n**                                                                   **\n**            2. IBM High Level Assembler source statements that     **\n**               can be assembled into a load module using HLASM.    **\n**               You specify the ASM option to create this format.   **\n**               For example: TSO VPSSEP indsn (ASM                  **\n**                                                                   **\n**            When the ASM option is NOT specified, then column 1 is **\n**            a record type indicator and is used as follows:        **\n**                                                                   **\n**            Col1 Usage                                             **\n**            ---- ------------------------------------------------  **\n**             *   Signifies a comment line.  The entire record is   **\n**                 ignored.                                          **\n**                                                                   **\n**             B   Signifies that the following text is binary data  **\n**                 and is to be appended to the data stream to be    **\n**                 sent to the printer 'as is'.  That is, the data   **\n**                 is not translated to ASCII.                       **\n**                                                                   **\n**             C   Signifies that the following text is binary data  **\n**                 and is to be appended to the data stream to be    **\n**                 sent to the printer 'as is' AFTER REMOVING THE    **\n**                 TRAILING X'FF'.  Apparently, MVS removes trailing **\n**                 blanks (X'40' code points) from each record before**\n**                 it is written to a RECFM=V partitioned dataset    **\n**                 member.  The C record is identical to the B       **\n**                 record except that the C record has X'FF' appended**\n**                 before it is written.  So, if a block of binary   **\n**                 data would end in X'40', a C record is written,   **\n**                 else a B record is written.                       **\n**                                                                   **\n**             X   Signifies that the following text is binary data  **\n**                 in printable hex format. The data stream to be    **\n**                 converted to binary before being sent to the      **\n**                 printer.                                          **\n**                                                                   **\n**             E   Signifies that the following text is a PCL escape **\n**                 sequence (excluding the escape character). The    **\n**                 remaining text up to, but not including, the      **\n**                 first blank is translated to ASCII and appended   **\n**                 to the PCL escape character (X'1B').              **\n**                 The resulting escape sequence is appended to the  **\n**                 data stream to be sent to the printer.            **\n**                 Any characters after the first blank are treated  **\n**                 as comments and are ignored.                      **\n**                                                                   **\n**             &   Signifies that the following text is the name of  **\n**                 a variable.                                       **\n**                 The current content of the variable is translated **\n**                 to ASCII and appended to the data stream. The     **\n**                 first blank after the & indicates the end of the  **\n**                 variable name.                                    **\n**                 Any characters after the first blank are treated  **\n**                 as comments and are ignored.                      **\n**                                                                   **\n**             Any other character in column 1 is the delimiter for  **\n**             the following text.  The text bounded by these        **\n**             delimiters is translated to ASCII and appended to the **\n**             data stream to be sent to the printer.                **\n**                                                                   **\n** NOTES    - 1.  Lines beginning with two blanks are ignored        **\n**                because blank is the delimiter and there is no     **\n**                text between the first and second blanks.          **\n**                                                                   **\n**            2.  Variable names are defined by the VAR parameters   **\n**                below.  Variable names are not case-sensitive. For **\n**                example, the following names are all equivalent:   **\n**                                                                   **\n**                     &USERNAME                                     **\n**                     &username                                     **\n**                     &UserName                                     **\n**                                                                   **\n**            3.  Substrings of the variables can be specified with  **\n**                the following syntax:                              **\n**                                                                   **\n**                &varname(firstchar,numchars)                       **\n**                                                                   **\n**                For example, &REPCDATE(1,4) returns the first four **\n**                characters of the report creation date (ie yyyy).  **\n**                                                                   **\n**                If numchars is omitted then the remainder of the   **\n**                variable starting with firstchar is printed.       **\n**                                                                   **\n**                The syntax does not enforce the use of '(' or ','. **\n**                Any non-blank non-digit may be used to delimit the **\n**                firstchar and numchars values.  Parsing for values **\n**                stops at the first blank encountered.              **\n**                                                                   **\n**                For example, the following are all equivalent:     **\n**                                                                   **\n**                   &REPCDATE(1,4)                                  **\n**                   &REPCDATE=1:4                                   **\n**                   &REPCDATE-FROM-POSITION-1-FOR-4-CHARACTERS      **\n**                                                                   **\n**                This feature is useful when you only want a fixed  **\n**                number of characters printed for a variable.  The  **\n**                &username variable is a good candidate for trunc-  **\n**                ation since user names can be quite long.  To      **\n**                truncate the &username to, say, 20 characters, you **\n**                should specify: &username(1,20)                    **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <a.armstrong@optusnet.com.au>      **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date     By Reason (most recent at the top please)     **\n**            ------- --- ------------------------------------------ **\n**           20041015 AJA Added some new GL2 commands.               **\n**           20040412 AJA Support for running on a PC using Regina   **\n**                        Rexx (see http://regina-rexx.sf.net).      **\n**                        Improved (marginally) option handling.     **\n**           20030613 AJA Packaged for distribution via cbttape.org  **\n**           20010928 AJA Added loop detection and disk full check.  **\n**           20000322 AJA Create IBM HLASM source file as output.    **\n**           19980421 AJA Allow PCL5 commands to have null values.   **\n**           19971216 AJA Added record type C                        **\n**           19970204 AJA Original version                           **\n**                                                                   **\n**********************************************************************/\n\n  parse arg sFileIn sFileOut' ('sOptions')'\n  parse source g.!SYSTEM . sMe .\n  say sMe': VPS Dynamic Separator Page Generator v1.1'\n\n  g.!ALLOPTIONS = 'ASM COM DRAW HEX SPACE TRACE VAR X'\n  g.!DESC.ASM   = 'emit assembly language source code'\n  g.!DESC.COM   = 'emit * records documenting font ' ||,\n                  'headers and HP/GL2 PE commands'\n  g.!DESC.DRAW  = 'emit * records to draw (PCLXL) soft font characters'\n  g.!DESC.HEX   = 'emit * records for binary data (in printable hex)'\n  g.!DESC.SPACE = 'emit blank lines'\n  g.!DESC.TRACE = 'trace conversion process'\n  g.!DESC.VAR   = 'emit & record for variable names'\n  g.!DESC.X     = 'emit X record type for binary data (in printable hex)'\n\n/*--------------------------------------------------------------------*\n * Determine the input and output file names                          *\n *-------------------------------------------------------------------*/\n\n  if g.!SYSTEM = 'TSO'\n  then do\n    address TSO 'CLEAR'\n    g.!LINES = 0\n    address ISPEXEC\n    parse arg sInDSN sOutDSN' ('sOptions')'\n    'VGET (VPSSEPI VPSSEPO) PROFILE'\n    sFileIn  = getDSN('Enter input dataset name:' ,sInDSN,  VPSSEPI)\n\n    if sOutDSN = ''\n    then do\n       parse var sFileIn sDataset'('sMember')'\n       if VPSSEPO <> ''\n       then parse var VPSSEPO sDataset'('\n       sOutDSN = sDataset'('strip(left(sMember,7))'$)'\n    end\n    sFileOut = getDSN('Enter output dataset name:',sOutDSN, VPSSEPO)\n\n    VPSSEPI = sFileIn\n    VPSSEPO = sFileOut\n  end\n\n  call parseOptions sOptions\n\n  if sFileIn = ''\n  then do\n    say\n    say 'Syntax:' sMe 'inputfile \u00ddoutputfile\u00a8 \u00dd(options\u00a8'\n    exit 4\n  end\n\n\n/*--------------------------------------------------------------------*\n *                                                                    *\n *-------------------------------------------------------------------*/\n\n  numeric digits 20\n\n  say 'Converting' sFileIn 'to' sFileOut\n\n  g.!bLastWasBlank = 0\n  g.!bModeGL2   = 0 /* 1=HP-GL/2 mode, 0=Not HP-GL/2 mode */\n  g.!bPCLXL     = 0 /* 1=PCLXL mode,   0=Not PCLXL mode   */\n  g.!bText      = 0 /* 1=Print text,   0=Print binary     */\n  g.!bData      = 0 /* 1=Print data,   0=Dont print data  */\n  g.!UNITSIZE   = 1 /* For PCLXL command values */\n  s. = ''\n  u. = ''\n  v. = ''\n  call Prolog\n\n  g.!hFileIn = openFile(sFileIn,'INPUT')\n  g.!hFileOut = openFile(sFileOut,'OUTPUT')\n\n/*--------------------------------------------------------------------*\n *  Insert function box in the output file...                         *\n *--------------------------------------------------------------------*/\n\n  select\n    when g.!OPTION.ASM then queue 'VPSSEP   CSECT'\n    otherwise nop\n  end\n\n\n  do i = 1 by 1 while sourceline(i) <> '/*BOX'\n  end\n\n  nFirstLine = i + 1\n\n  do i = nFirstLine while sourceline(i) <> '//'\n    sLine = sourceline(i)\n    select\n      when sLine = '&name' then,\n           queue '** NAME     -' left(sFileOut,55)'**'\n      when sLine = '&title' then do\n           sData = 'SEPARATOR PAGE FOR',\n                   '<insert printer type here>'\n           queue '** TITLE    -' left(sData,55)'**'\n      end\n      when sLine = '&date' then,\n           queue '**           ' left(date('SORTED'),\n                                      left(userid(),8),\n                                     'Initial version.',55)'**'\n      otherwise queue sLine\n    end\n  end\n\n  call DoComment 'Generated on' date() 'by' userid()\n\n  call putQueued g.!hFileOut\n\n  if g.!OPTION.ASM\n  then do\n    call Log '*    ' left('Hex Data',16) ' CharData Explanation'\n    call Log '*    ' copies('-',     16) ' --------' copies('-',38)\n  end\n\n/*--------------------------------------------------------------------*\n *  Read the binary input file into a single REXX variable...         *\n *--------------------------------------------------------------------*/\n\n  say 'Reading' sFileIn'...'\n  sData = getEntireFile(g.!hFileIn)\n\n  call closeFile g.!hFileIn\n\n  nTotalBytes = length(sData)\n  say sFileIn 'contains' nTotalBytes 'bytes of data'\n\n/*--------------------------------------------------------------------*\n *  Convert the binary data into editable-PCL format...               *\n *--------------------------------------------------------------------*/\n\n  say 'Processing...'\n  nCheckPoint = 0\n  do while length(sData) > 0\n\n    if length(sData) = nCheckPoint\n    then do\n      call Log 'Loop detected at' nTotalBytes - length(sData)\n      call Log c2x(substr(sData,1,32))\n      call Abort 'Loop detected'\n    end\n    nCheckPoint = length(sData)\n\n    nBytesDone = nTotalBytes - length(sData)\n    nPercent   = trunc(nBytesDone/nTotalBytes * 100)\n    nSlot      = trunc(nPercent/10)\n    if nSlot <> nSlotLast\n    then do\n      say 'Processed' nPercent'%'\n      nSlotLast = nSlot\n    end\n\n    if g.!OPTION.TRACE then say '+'nTotalBytes - length(sData)\n    if g.!bPCLXL\n    then call DoPCLXL\n    else do\n      parse var sData sText '1b'x sData\n\n     /*-----------------------------------------------------------------*\n      *  Output text or binary data, if any                             *\n      *-----------------------------------------------------------------*/\n\n      if length(sText) > 0\n      then do\n        if g.!bModeGL2\n        then call LogGL2 ' ',sText\n        else call DoText\n        if g.!bPCLXL\n        then do      /* Reconstruct data stream and treat it as PCLXL */\n          sData = sText || '1b'x || sData\n        end\n      end\n\n     /*-----------------------------------------------------------------*\n      *  Output PCL command                                             *\n      *-----------------------------------------------------------------*/\n\n      if \\g.!bPCLXL & length(sData) > 0 then call DoPCL5\n    end\n  end\n\n/*--------------------------------------------------------------------*\n *  Output end-of-file comment                                        *\n *--------------------------------------------------------------------*/\n\n  call DoComment 'End of File'\n\n  select\n    when g.!OPTION.ASM then queue '         END'\n    otherwise nop\n  end\n\n  call putQueued g.!hFileOut\n\n  call Epilog\nexit\n\n/*-------------------------------------------------------------------*\n * Parse commmand-line options\n *-------------------------------------------------------------------*/\n\nparseOptions: procedure expose g.\n  arg sOptions\n  call setOptions 'NOASM COM NODRAW HEX SPACE NOTRACE VAR NOX'\n  if sOptions <> ''\n  then say 'User specified options:' sOptions\n  call setOptions sOptions\n  say 'Options in effect:'\n  call showOptions\nreturn\n\nshowOptions: procedure expose g.\n  do i = 1 to words(g.!ALLOPTIONS)\n    sOption = word(g.!ALLOPTIONS,i)\n    if g.!OPTION.sOption\n    then say right(sOption,8),\n      translate(left(g.!DESC.sOption,1))substr(g.!DESC.sOption,2)\n    else say right('NO'sOption,8) 'Do not' g.!DESC.sOption\n  end\nreturn\n\nsetOptions: procedure expose g.\n  arg sOptions\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n    if left(sOption,2) = 'NO'\n    then sBaseOption = substr(sOption,3)\n    else sBaseOption = sOption\n    g.!OPTION.sBaseOption = left(sOption,2) <> 'NO'\n    sNoBaseOption = 'NO'sBaseOption\n    g.!OPTION.sNoBaseOption = \\g.!OPTION.sBaseOption\n  end\nreturn\n\n/*-------------------------------------------------------------------*\n * Open a file\n *-------------------------------------------------------------------*/\n\nopenFile: procedure expose g.\n  parse arg sFile,sOptions\n  hFile = ''\n  select\n    when g.!SYSTEM = 'TSO' then do\n      parse var sFile sDataset'('sMember')'\n      if sMember <> '' then sFile = sDataset\n      if wordpos('OUTPUT',sOptions) = 0 /* if not opening for output */\n      then 'LMINIT  DATAID(hFile) DATASET(&sFile)'\n      else 'LMINIT  DATAID(hFile) DATASET(&sFile) ENQ(EXCLU)'\n      g.!OPTIONS.hFile = sOptions\n      'LMOPEN  DATAID(&hFile) OPTION(INPUT)' /* Input initially */\n      if sMember <> ''\n      then do\n        g.!MEMBER.hFile = sMember\n        'LMMFIND DATAID(&hFile) MEMBER('sMember') STATS(YES)'\n        if wordpos('OUTPUT',sOptions) > 0\n        then do\n          if rc = 0\n          then g.!STATS.hFile = zlvers','zlmod','zlc4date\n          else g.!STATS.hFile = '1,0,0000/00/00'\n          'LMCLOSE DATAID(&hFile)'\n          'LMOPEN  DATAID(&hFile) OPTION(&sOptions)'\n        end\n      end\n      g.!rc = rc\n    end\n    when g.!SYSTEM = 'WIN32' then do\n      if wordpos('OUTPUT',sOptions) > 0\n      then junk = stream(sFile,'COMMAND','OPEN WRITE REPLACE')\n      else junk = stream(sFile,'COMMAND','OPEN READ')\n      hFile = sFile\n      if stream(sFile,'STATUS') = 'READY'\n      then g.!rc = 0\n      else g.!rc = 4\n    end\n    otherwise call Abort,\n      'Do not know how to open files on system type:' g.!SYSTEM\n  end\nreturn hFile\n\n/*-------------------------------------------------------------------*\n * Read a line from the specified file\n *-------------------------------------------------------------------*/\n\ngetLine: procedure expose g.\n  parse arg hFile\n  sLine = ''\n  select\n    when g.!SYSTEM = 'TSO' then do\n      'LMGET DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN(nLine) MAXLEN(32768)'\n      g.!rc = rc\n      sLine = strip(sLine,'TRAILING')\n      if sLine = '' then sLine = ' '\n    end\n    when g.!SYSTEM = 'WIN32' then do\n      g.!rc = 0\n      if chars(hFile) > 0\n      then sLine = linein(hFile)\n      else g.!rc = 4\n    end\n    otherwise nop\n  end\nreturn sLine\n\n/*-------------------------------------------------------------------*\n * Append a line to the specified file\n *-------------------------------------------------------------------*/\n\nputLine: procedure expose g.\n  parse arg hFile,sLine\n  if g.!OPTION.NOSPACE & sLine = ''\n  then return 0\n  select\n    when g.!SYSTEM = 'TSO' then do\n      g.!LINES = g.!LINES + 1\n      if sLine = '' then sLine = ' '\n      'LMPUT DATAID(&hFile) MODE(INVAR)',\n            'DATALOC(sLine) DATALEN('length(sLine)')'\n    end\n    when g.!SYSTEM = 'WIN32' then do\n      junk = lineout(hFile,sLine)\n      rc = 0\n    end\n    otherwise nop\n  end\nreturn rc\n\n/*-------------------------------------------------------------------*\n * Close the specified file\n *-------------------------------------------------------------------*/\n\ncloseFile: procedure expose g.\n  parse arg hFile\n  rc = 0\n  select\n    when g.!SYSTEM = 'TSO' then do\n      if g.!MEMBER.hFile <> '',\n      & wordpos('OUTPUT',g.!OPTIONS.hFile) > 0 /* if opened for output */\n      then do\n        parse value date('STANDARD') with yyyy +4 mm +2 dd +2\n        parse var g.!STATS.hFile zlvers','zlmod','zlc4date\n        zlcnorc  = min(g.!LINES,65535)   /* Number of lines   */\n        nVer = right(zlvers,2,'0')right(zlmod,2,'0')  /* vvmm */\n        nVer = right(nVer+1,4,'0')       /* vvmm + 1          */\n        parse var nVer zlvers +2 zlmod +2\n        if zlc4date = '0000/00/00'\n        then zlc4date = yyyy'/'mm'/'dd   /* Creation date     */\n        zlm4date = yyyy'/'mm'/'dd        /* Modification date */\n        zlmtime  = time()                /* Modification time */\n        zluser   = userid()              /* Modification user */\n        'LMMREP DATAID(&hFile) MEMBER('g.!MEMBER.hFile') STATS(YES)'\n      end\n      'LMCLOSE DATAID(&hFile)'\n      'LMFREE  DATAID(&hFile)'\n    end\n    when g.!SYSTEM = 'WIN32' then do\n      if stream(hFile,'COMMAND','CLOSE') = 'UNKNOWN'\n      then rc = 0\n      else rc = 4\n    end\n    otherwise nop\n  end\nreturn rc\n\nputQueued: procedure expose g.\n  parse arg hFile\n  do queued() until rc <> 0\n    parse pull sLine\n    rc = putLine(hFile,sLine)\n  end\nreturn rc\n\ngetEntireFile: procedure expose g.\n  parse arg hFile\n  sData = ''\n  select\n    when g.!SYSTEM = 'TSO' then do\n      sLine = getLIne(hFile)\n      do i = 1 by 1 while g.!RC = 0\n        sData = sData || sLine\n        sLine = getLIne(hFile)\n      end\n    end\n    when g.!SYSTEM = 'WIN32' then do\n      g.!rc = 0\n      if chars(hFile) > 0\n      then sData = charin(hFile,1,chars(hFile))\n      else g.!rc = 4\n    end\n    otherwise nop\n  end\nreturn sData\n\nEpilog:\n  say 'Done'\n  if g.!SYSTEM = 'TSO'\n  then do\n    'VPUT (VPSSEPI VPSSEPO) PROFILE'\n  end\n  call closeFile g.!hFileOut\nreturn\n\n/*\n* Prompt the user if necessary for a dataset name and return only\n* if the dataset exists. The user can force the use of the last\n* dataset by specifying '.' and can ask to be prompted for a new\n* dataset by specifying '..'.\n*\n*/\ngetDSN: procedure\n  parse arg sPrompt,sArg,sVar\n\n  select\n    when sArg = ''   then sDSN = sVar\n    when sArg = '.'  then sDSN = sVar\n    when sArg = '..' then sDSN = ''\n    otherwise             sDSN = sArg\n  end\n\n  if sDSN = ''\n  then do                  /* Prompt if no current value */\n    say sPrompt\n    pull sDSN\n    if sDSN = '' then exit /* Abandon if user supplies no value */\n  end\n  else do\n    if isMemberName(sDSN) & pos('(',sVar) > 0\n    then do                /* Use new member in same PDS */\n      parse var sVar sDataset'('\n      sDSN = sDataset'('sDSN')'\n    end\n  end\n\n  sResult = SYSDSN(sDSN)\n\n  select\n    when sResult = 'OK'               then return sDSN\n    when sResult = 'MEMBER NOT FOUND' then return sDSN\n    otherwise say sDSN':' sResult\n  end\nexit\n\nisMemberName: procedure\n  arg sMember\n  if length(sMember) > 8 then return 0\n  if length(sMember) = 0 then return 0\n  if datatype(left(sMember,1),'WHOLE') then return 0\nreturn datatype(substr(sMember,2),'ALPHANUMERIC')\n\nDoComment: procedure expose g.\n  parse arg sComment\n  queue\n  queue '*'copies('-',69)'*'\n  queue '*        'left(sComment,61)'*'\n  queue '*'copies('-',69)'*'\n  queue\nreturn\n\nDoPCLXL:\n/*\nThe general PCLXL data stream format seems to a repeated sequence of:\n     <operand><operand>...<command>\nWhere,\n     <operand> begins with 'C0'x to 'FF'x and is followed by a value\n               All values are in little-endian format.\n               For example: C0xx        - 1-byte value\n                            C1xxxx      - 2-byte value\n                            C2xxxxxxxx  - 4-byte value\n                            C5xxyyxxyy  - 1-byte coord pair(x1,y1,x2,y2)\n                            C8          - 1-byte data units follow\n                            C9          - 2-byte unicode values follow\n                            CB          - 2-byte data units follow\n                            D0wwhh      - 1-byte dimension (w x h)\n                            D1wwwwhhhh  - 2-byte dimension (w x h)\n                            D3xxxxyyyy  - 2-byte coordinate (x,y)\n                            D5xxxxxxxxyyyyyyyy  - 2-byte coordinate\n                            E3xxxxyyyyxxxxyyyy  - 2-byte coordinate pair\n                            EBxxyyzz    - 3-byte triplet\n                            29          - comment terminated by LF\n                            FAxxxxxxxx  - 4-byte length followed by data\n                            FBxx        - 1-byte length followed by data\n\n     <command> begins with 'F8'x and is followed by a command byte\n               For example: F8ccmmmmmm  - 1-byte command optionally\n                                          followed by modifier bytes\n\n*/\n  say 'PCLXL processing...'\n  say\n\n  /* Log the LF (or whatever) before the first PCLXL command first...*/\n  i = verify(sData,xrange('C0'x,'FF'x)'29'x,'MATCH')\n  nLen = i - 1\n  if nLen > 0\n  then do\n    parse var sData sChunk +(nLen) sData\n    call LogBinary sChunk\n  end\n\n  do while length(sData) > 0\n    c = left(sData,1)\n    select\n      when c = '1b'x then do\n        g.!bPCLXL = 0\n        say 'PCLXL mode ended'\n        return\n      end\n      when c = 'F8'x then do  /* Escape code... */\n        cc = substr(sData,2,1)\n        select\n          when cc = '04'x then sCommand = 'SetFill (0=Off,1=On)'\n          when cc = '05'x then sCommand = 'SetOutline (0=Off,1=On)'\n          when cc = '06'x then sCommand = 'SetColorSpace'\n          when cc = '09'x then sCommand = 'SetColor'\n          when cc = '25'x then sCommand = 'SetPaperSize'\n          when cc = '26'x then sCommand = 'SetPaperSource'\n          when cc = '27'x then sCommand = 'SetPaperStock'\n          when cc = '28'x then sCommand = 'SetOrientation (0=Pt,1=Ls,2=1800)'\n          when cc = '2A'x then sCommand = 'SetPageScale'\n          when cc = '2B'x then sCommand = '?SetPageDimension'\n          when cc = '31'x then sCommand = 'SetCopyCount'\n          when cc = '42'x then sCommand = 'DrawRectangle'\n          when cc = '45'x then sCommand = 'DrawLine'\n          when cc = '48'x then sCommand = '?SetEllipse (0=Off,1=On)'\n          when cc = '4B'x then sCommand = 'SetPenWidth'\n          when cc = '4C'x then sCommand = 'SetCursorXY'\n          when cc = '4D'x then sCommand = 'SetPolyLineCount'\n          when cc = '50'x then sCommand = 'DrawPolyLine'\n          when cc = '67'x then sCommand = 'SetImageSize'\n          when cc = '6D'x then sCommand = 'ImageData'\n          when cc = '89'x then sCommand = 'SetResolution'\n          when cc = 'A1'x then sCommand = '?ResetTextBuffer'\n          when cc = 'A2'x then sCommand = 'SetCharacterIndex'\n          when cc = 'A3'x then sCommand = 'DefineCharacter'\n          when cc = 'A7'x then sCommand = 'SetSoftFontDataLength'\n          when cc = 'A8'x then sCommand = 'SetFont'\n          when cc = 'AB'x then sCommand = 'SetText'\n          when cc = 'AF'x then sCommand = 'SetTextWidths'\n          otherwise            sCommand = '?'\n        end\n        i = verify(sData,xrange('C0'x,'FF'x)'1b'x,'MATCH', 2)\n        nLen = i - 1\n        if nLen > 0\n        then parse var sData sChunk +(nLen) sData\n        else parse var sData sChunk sData\n        call LogPCL6Cmd sChunk,'Command',c2x(sChunk),sCommand\n      end\n\n      when c = 'C0'x then do  /* 1-Byte value */\n        parse var sData sChunk +2 2 cXX +1 sData\n        call LogPCL6Arg sChunk,'1-byte Value','C0',c2d(cXX)\n      end\n\n      when c = 'C1'x then do  /* 2-Byte byte-reversed length*/\n        if substr(sData,4,1) <> 'F8'x\n        then do  /* print command C1xxxx and xxxx data units */\n          parse var sData 2 sLen +2\n          nCount = d(sLen)\n          nLen = nCount * g.!UNITSIZE\n          parse var sData sChunk +3 sChunk2 +(nLen) sData\n          call LogPCL6Arg sChunk,'2-byte Count','C1',nCount\n          if g.!OPTION.NOX\n          then call Log '*       'nCount' x 'g.!UNITSIZE'-byte values...'\n          if g.!UNITSIZE = 1 & IsPrintable(sChunk2)\n          then call LogText a2e(sChunk2)\n          else call LogBinary sChunk2\n        end\n        else do  /* just print the command: C1xxxx */\n          parse var sData sChunk +3 2 sLen +2 sData\n          nValue = d(sLen)\n          call LogPCL6Arg sChunk,'2-byte Value','C1',nValue\n        end\n      end\n\n      when c = 'C2'x then do  /* 4-byte byte-reversed value */\n        parse var sData sChunk +5 2 sX +4 sData\n        call LogPCL6Arg sChunk,'4-byte Value','C2',d(sX)\n      end\n\n      when c = 'C3'x then do  /* 2-byte byte-reversed value */\n        parse var sData sChunk +3 2 sX +2 sData\n        call LogPCL6Arg sChunk,'2-byte Value','C3',d(sX)\n      end\n\n      when c = 'C5'x then do  /* xxyyxxyy rectangle */\n        parse var sData sChunk +5 2 s1 +1 s2 +1 s3 +1 s4 +1 sData\n        sRect = '('c2d(s1)','c2d(s2)','c2d(s3)','c2d(s4)')'\n        call LogPCL6Arg sChunk,'1-byte Rectangle','C5',sRect\n      end\n\n      when c = 'C8'x then do  /* Array unit size = 1 byte values */\n        g.!UNITSIZE = 1\n        parse var sData sChunk +1 sData\n        call LogPCL6Arg sChunk,'Array unit size','C8','1-byte'\n      end\n\n      when c = 'C9'x then do  /* Array of 2-byte Unicode values */\n        g.!UNITSIZE = 2\n        parse var sData sChunk +1 sData\n        call LogPCL6Arg sChunk,'Array of Unicode values','CB','2-byte'\n      end\n\n      when c = 'CB'x then do  /* Array unit size = 2 byte values */\n        g.!UNITSIZE = 2\n        parse var sData sChunk +1 sData\n        call LogPCL6Arg sChunk,'Array unit size','CB','2-byte'\n      end\n\n      when c = 'D0'x then do  /* xxyy 1-byte w x h dimension */\n        parse var sData sChunk +3 2 sX +1 sY +1 sData\n        sDim = d(sX) 'x' d(sY)\n        call LogPCL6Arg sChunk,'1-byte Dimension','D0',sDim\n      end\n\n      when c = 'D1'x then do  /* xxxxyyyy byte-reversed dimension */\n        parse var sData sChunk +5 2 sX +2 sY +2 sData\n        sDim = d(sX) 'x' d(sY)\n        call LogPCL6Arg sChunk,'2-byte Dimension','D1',sDim\n      end\n\n      when c = 'D3'x then do  /* xxxxyyyy byte-reversed co-ord */\n        parse var sData sChunk +5 2 sX +2 sY +2 sData\n        sCoord = d(sX)','d(sY)\n        call LogPCL6Arg sChunk,'2-byte Coordinate','D3',sCoord\n      end\n\n      when c = 'D5'x then do  /* xxxxyyyyxxxxyyyy byte-reversed rect*/\n        parse var sData sChunk +9 2 sX +2 sY +2 sX2 +2 sY2 +2 sData\n        sRect = '('d(sX)','d(sY)','d(sX2)','d(sY2)')'\n        call LogPCL6Arg sChunk,'2-byte Rectangle','D5',sRect\n      end\n\n      when c = 'E3'x then do  /* xxxxyyyyxxxxyyyy byte-reversed rect*/\n        parse var sData sChunk +9 2 sX +2 sY +2 sX2 +2 sY2 +2 sData\n        sRect = '('d(sX)','d(sY)','d(sX2)','d(sY2)')'\n        call LogPCL6Arg sChunk,'2-byte Rectangle','E3',sRect\n      end\n\n      when c = 'EB'x then do  /* xxyyzz */\n        parse var sData sChunk +4 sData\n        sValue = c2x(substr(sChunk,2))\n        call LogPCL6Arg sChunk,'3-byte Value','EB',sValue\n      end\n\n      when c = '29'x then do  /* )...comment...LF */\n        parse var sData sComment '0a'x sData\n        if g.!OPTION.NOX\n        then call Log '*       Comment (29)...'\n        call LogText a2e(sComment)\n        call LogBinary '0a'x\n      end\n\n      when c = 'FA'x then do  /* xxxxxxxx byte-reversed length, data*/\n        parse var sData sChunk +5 2 sLen +4\n        nLen = d(sLen)\n        call LogPCL6Arg sChunk,'4-byte Count','FA',nLen\n        if g.!OPTION.NOX\n        then call Log '*       'nLen 'bytes of data...'\n        parse var sData 6 sChunk +(nLen) sData\n        if cc = 'A3'x & g.!OPTION.DRAW\n        then call drawCharacter sChunk\n        call LogBinary sChunk\n        i = verify(sData,xrange('C0'x,'FF'x),'MATCH')\n        if i > 1\n        then do\n          i = i - 1\n          parse var sData sChunk +(i) sData\n          if g.!OPTION.NOX\n          then call Log '*       Modifiers...'\n          call LogBinary sChunk\n        end\n      end\n\n      when c = 'FB'x then do  /* xx bytes of data */\n        parse var sData sChunk +2 2 sLen +1 sData\n        nLen = d(sLen)\n        call LogPCL6Arg sChunk,'1-byte Count','FB',nLen\n        if g.!OPTION.NOX\n        then call Log '*       'nLen 'bytes of data...'\n        parse var sData sChunk +(nLen) sData\n        if cc = 'A3'x & g.!OPTION.DRAW\n        then call drawCharacter sChunk\n        call LogBinary sChunk\n        i = verify(sData,xrange('C0'x,'FF'x),'MATCH')\n        if i > 1\n        then do\n          i = i - 1\n          parse var sData sChunk +(i) sData\n          call LogPCL6Arg sChunk,'Modifiers of','FB'\n        end\n      end\n\n      otherwise do\n        parse var sData sChunk +1 sData\n        call LogPCL6Arg sChunk,'Unknown PCLXL data type',c2x(sChunk)\n        say 'Unknown PCLXL data type:' c2x(sChunk)\n      end\n    end\n  end\nreturn\n\nd: procedure\n  parse arg s\nreturn c2d(reverse(s))\n\ndrawCharacter: procedure expose g.\n  parse arg 1 sType +2 7 sBitsPerRow +2 9 sRows +2 sCharDef\n  if sType <> '0000'x then return\n  nRows = c2d(sRows)\n  nBytesPerRow = trunc(c2d(sBitsPerRow)/8)\n  do i = 1 to nRows\n    sRow = substr(sCharDef,(i-1)*nBytesPerRow+1,nBytesPerRow)\n    call Log '*' translate(x2b(c2x(sRow)),' X','01')\n  end\nreturn\n\nLogPCL6Arg: procedure expose g.\n  parse arg sChunk,sType,xCmd,sValue\n  select\n    when g.!OPTION.ASM then do\n      call LogASM sChunk,,sType '=' sValue\n    end\n    when g.!OPTION.X then do\n      call Log 'o'left(c2x(sChunk),18) sType '=' sValue\n    end\n    otherwise do\n      call Log '*      ' sType '('xCmd') =' sValue'...'\n      call LogBinary sChunk\n    end\n  end\nreturn\n\nLogPCL6Cmd: procedure expose g.\n  parse arg sChunk,sType,xCmd,sValue\n  select\n    when g.!OPTION.ASM then do\n      call LogASM sChunk,,sType '=' sValue\n      call Log\n    end\n    when g.!OPTION.X then do\n      call Log 'c'left(c2x(sChunk),18) sValue\n      call Log\n    end\n    otherwise do\n      call Log '*      ' sType '('xCmd') =' sValue'...'\n      call LogBinary sChunk\n    end\n  end\nreturn\n\n\n\n\nDoPCL5:\n  c = left(sData,1)\n  c = a2e(c)\n  if pos(c,'=EYZ9') > 0   /* ...commands without values */\n  then do\n    select\n      when g.!OPTION.ASM then call LogASM '1B'x || left(sData,1),'.'c,s.c\n      otherwise call Log left('E'c,g.!nMargin) s.c\n    end\n    sData = substr(sData,2)\n  end\n  else do\n    /* A capital letter is the end of a set of PCL commands */\n    i = verify(sData,g.!sTerminators,'MATCH')\n    if i <> 0 /* i is the first capital letter (ie end of command) */\n    then do\n      if substr(sData,i,1) = '1b'x\n      then i = i - 1              /* lower-case terminated in error */\n      parse var sData sCmd +(i) sData\n      sCmd = a2e(sCmd)            /* ...command set */\n      parse var sCmd 1 c1 +1 2 c2 +1\n      sSuffix = right(sCmd,1)\n      if pos(c1,'()') > 0,        /* If 1st char is ( or ) */\n       & pos(c2,'0123456789') > 0,/* and 2nd char is a number */\n       & pos(sSuffix,'@X') = 0    /* and last char is not @ or X */\n      then do                     /* Font selection */\n        sID = '(I '\n        sComment = s.sID\n        sValue   = substr(sCmd,2)\n        sValueForComment = strip(sValue,'LEADING','0')\n        sComment = sComment '=' sValueForComment u.sID\n        sIDValue = sID || sValueForComment\n        sMeaning = s.sIDValue\n        if sMeaning <> ''\n        then sComment = sComment '('sMeaning')'\n        select\n          when g.!OPTION.ASM then,\n            call LogASM '1B'x || e2a(sCmd),'.'sCmd,sComment\n          otherwise call Log left('E'sCmd,g.!nMargin) sComment\n        end\n      end\n      else do                     /* ccnnnxnnnxnnnX */\n        if pos(c2,'0123456789') > 0,/* If 2nd char is a number      */\n         | (c1 = '%' & c2 <> '-')   /* Sodding sodding sodding...   */\n        then nPrefix = 1            /* Then prefix is 1 char long   */\n        else nPrefix = 2            /* Else prefix is 2 chars long  */\n        sPrefix = left(sCmd,nPrefix)\n        sCmd = substr(sCmd,nPrefix+1)\n        cSuffix = right(sCmd,1)     /* Pick off last character */\n        if pos(cSuffix,'@'xrange('A','Z')) = 0\n        then do /* command is not terminated by an upper case letter */\n          sComment = 'WARNING:    INVALID PCL COMMAND TERMINATOR',\n                                '<'sCmd'>'\n          say sComment\n          call Log '*                'sComment\n        end\n        sTemp  = sCmd              /* For example: 1vt2G */\n        do j = 1 by 1 while length(sTemp) > 0\n          sValue = ''\n          sOrder = ''\n          nValue = verify(sTemp,g.!sNumerics,'MATCH')\n          nAlpha = verify(sTemp,g.!sAlphas, 'MATCH')\n          select\n            when nValue = 0 then do\n              sOrder = substr(sTemp,nAlpha,1)\n              sTemp  = substr(sTemp,nAlpha+1)\n            end\n            when nValue < nAlpha then do\n              sValue = substr(sTemp,nValue,nAlpha-nValue)\n              sOrder = substr(sTemp,nAlpha,1)\n              sTemp  = substr(sTemp,nAlpha+1)\n            end\n            when nValue > nAlpha then do\n              sOrder = substr(sTemp,nAlpha,1)\n              sTemp  = substr(sTemp,nAlpha+1)\n            end\n            otherwise nop\n          end\n          call DoCommand j sPrefix sOrder sValue\n        end\n      end\n    end\n  end\nreturn\n\n\n\n\nDoCommand:\n  parse arg nCommand sPrefix sSuffix sValue\n  sSuffixUpper = sSuffix\n  upper sSuffixUpper\n  sID = sPrefix || sSuffixUpper\n  sComment = s.sID\n  if sComment = ''\n  then do\n    sComment = 'ERROR:      UNKNOWN PCL COMMAND',\n                  '<'sPrefix || sValue || sSuffix'>'\n    say sComment\n    call Log '*                'sComment\n  end\n  sValueForComment = sValue\n  if sValue = '' then sValueForComment = '0'\n  if datatype(sValueForComment,'NUMBER')\n  then sValueForComment = format(sValueForComment)\n  if left(sValue,1) = '+'\n  then sValueForComment = '+'sValueForComment\n  sComment = sComment '=' sValueForComment u.sID\n  sIDValue = sID || sValueForComment\n  sMeaning = s.sIDValue\n  if sID = '*cE' /* Font Create, Character Code */\n  then sMeaning = \"Hex='\"d2x(sValueForComment,2)\"'\",\n                 \"Char='\"d2c(sValueForComment)\"'\"\n  if sMeaning <> ''\n  then sComment = sComment '('sMeaning')'\n\n  if sID = '%A' then call Log /* If we are leaving HP-GL/2 mode...*/\n\n  if nCommand = 1 /* If this is the first command after an escape...*/\n  then do\n    sCmd = sPrefix || sValue || sSuffix\n    select\n      when g.!OPTION.ASM then call LogASM '1B'x || e2a(sCmd),'.'sCmd,sComment\n      otherwise call Log left('E'sCmd,max(length(sCmd)+1,g.!nMargin)) sComment\n    end\n  end\n  else do\n    sCmd = sValue || sSuffix\n    select\n      when g.!OPTION.ASM then call LogASM e2a(sCmd),sCmd,sComment\n      otherwise call Log left(' 'sCmd,max(length(sCmd)+1,g.!nMargin)) sComment\n    end\n  end\n\n  /* Special processing for some PCL commands */\n\n  select\n    when sID = '%B' then do\n      g.!bModeGL2 = 1 /* Enter HP-GL/2 mode */\n      call Log\n    end\n    when sID = '%A' then do\n      g.!bModeGL2 = 0 /* Enter PCL mode     */\n    end\n    when sID = '%-X' then do /* Universal Exit Language */\n      g.!bModeGL2 = 0 /* Enter PCL mode     */\n    end\n         /* PCL commands with binary data operands... */\n    when sSuffix = 'W' | sID = '&pX' | sID = '*bV' then do\n      nBytes = sValue\n      if nBytes > 0\n      then do\n        parse var sData sBinary +(nBytes) sData\n        call LogBinary sBinary   /* Write binary data */\n        if sID = ')sW' & g.!OPTION.COM /* Font Header */\n        then call showFontHeader sBinary\n        if sID = '(sW' & g.!OPTION.DRAW /* Character Data */\n        then call showCharacterData sBinary\n      end\n    end\n\n    when sID = '&fX' & sValueForComment = '1' then do\n      call Log     /* Add a blank line after end of macro definition */\n    end\n\n    otherwise nop\n  end\n\nreturn\n\nshowFontHeader: procedure expose g. s.\n  parse arg         sSize         +2,\n                    sFormat       +1,\n                    sType         +1,\n                    sStyleMSB     +1,\n                    sReserved     +1,\n                    sBaselinePos  +2,\n                    sCellWidth    +2,\n                    sCellHeight   +2,\n                    sOrientation  +1,\n                    sSpacing      +1,\n                    sSymbolSet    +2,\n                    sPitch        +2,\n                    sHeight       +2,\n                    sxHeight      +2,\n                    sWidthType    +1,\n                    sStyleLSB     +1,\n                    sWeight       +1,\n                    sTypefaceLSB  +1,\n                    sTypefaceMSB  +1,\n                    sSerifStyle   +1,\n                    sQuality      +1,\n                    sPlacement    +1,\n                    sUnderlineW   +1,\n                    sUnderlineH   +1,\n                    sTextHeight   +2,\n                    sTextWidth    +2\n  call Log '*--------------------------- Font descriptor'\n  call LogFont\n  call LogFont sSize       ,'Font Descriptor Size'\n  nFormat = c2d(sFormat)\n  call LogFont sFormat     ,'Header Format',g.!FONTFORMAT.nFormat\n  call LogFont sType       ,'Font Type'\n  call LogFont sStyleMSB   ,'Style MSB'\n  call LogFont sReserved   ,'Reserved'\n  call LogFont sBaselinePos,'Baseline Position'\n  call LogFont sCellWidth  ,'Cell Width'\n  call LogFont sCellHeight ,'Cell Height'\n  call LogFont sOrientation,'Orientation'\n  sIDValue = '(sP'c2d(sSpacing)\n  call LogFont sSpacing    ,'Spacing',s.sIDValue\n  call LogFont sSymbolSet  ,'Symbol Set'\n  call LogFont sPitch      ,'Pitch (Default HMI)'\n  call LogFont sHeight     ,'Height'\n  call LogFont sxHeight    ,'x-Height'\n  call LogFont sWidthType  ,'Width Type'\n  call LogFont sStyleLSB   ,'Style LSB'\n  sIDValue = '(sB'c2d(sWeight)\n  call LogFont sWeight     ,'Stroke Weight',s.sIDValue\n  call LogFont sTypefaceLSB,'Typeface LSB'\n  call LogFont sTypefaceMSB,'Typeface MSB'\n  call LogFont sSerifStyle ,'Serif Style'\n  call LogFont sQuality    ,'Quality'\n  call LogFont sPlacement  ,'Placement'\n  call LogFont sUnderlineW ,'Underline Position'\n  call LogFont sUnderlineH ,'Underline Thickness'\n  call LogFont sTextHeight ,'Text Height'\n  call LogFont sTextWidth  ,'Text Width'\n  call Log '*--------------------------- End of common part'\n  call Log\nreturn\n\nLogFont: procedure expose g.\n  parse arg sItem,sDesc,sValue\n  if sItem = ''\n  then do\n    g.!LogFontOffset = 0\n    return\n  end\n  nOffset = g.!LogFontOffset\n  xItem = c2x(sItem)\n  if sValue = ''\n  then sValue = c2d(sItem)\n  else sValue = c2d(sItem) '('sValue')'\n  call Log '*   +'right(nOffset,2,'0') left(xItem,20) sDesc '=' sValue\n  g.!LogFontOffset = g.!LogFontOffset + length(sItem)\nreturn\n\nshowCharacterData: procedure expose g.\n  parse arg         sFormat       +1,\n                    sCont         +1,\n                    sSize         +1,\n                    sClass        +1,\n                    sOrientation  +1,\n                    sReserved     +1,\n                    sLeftOffset   +2,\n                    sTopOffset    +2,\n                    sCharWidth    +2,\n                    sCharHeight   +2,\n                    sDeltaX       +2,\n                    sRasterData\n  select\n    when sFormat = '04'x then do /* LaserJet Family (raster) */\n      if sCont <> '00'x then return /* coninuation: bail out! */\n      nCharWidth = c2d(sCharWidth)\n      nCharHeight = c2d(sCharHeight)\n      nBytesPerRaster = trunc((nCharWidth+7)/8)\n      select\n        when sClass = '01'x then do /* Uncompressed Bitmap */\n          do i = 1 to nCharHeight\n            sRaster = substr(sRasterData,(i-1)*nBytesPerRaster+1,nBytesPerRaster\n            call Log '*' translate(x2b(c2x(sRaster)),' X','01')\n          end\n        end\n        when sClass = '02'x then nop /* Compressed Bitmap */\n        when sClass = '03'x then nop /* Contour (Intellifont Scalable) */\n        when sClass = '04'x then nop /* Compound Contour (Intellifont) */\n        when sClass = '0f'x then nop /* TrueType Scalable */\n        otherwise nop\n      end\n    end\n    when sFormat = '0A'x then nop /* Intellifont Scalable */\n    when sFormat = '0F'x then nop /* TrueType Scalable */\n    otherwise nop\n  end\nreturn\n\nDoText:\n  nMaxLen = length(sText) + 1\n  n = 1\n  do while n < nMaxLen\n\n    iNextBinary = verify(sText, xrange('00'x,'1f'x), 'MATCH',   n)\n    iNextAlpha  = verify(sText, xrange('00'x,'1f'x), 'NOMATCH', n)\n    if iNextAlpha  = 0 then iNextAlpha  = nMaxLen\n    if iNextBinary = 0 then iNextBinary = nMaxLen\n\n    if iNextAlpha < iNextBinary\n    then do                 /* EXTRACT NEXT PRINTABLE STRING */\n      nLen = iNextBinary - iNextAlpha\n      sChunk = substr(sText, n, nLen)\n      n = iNextBinary\n      sChunk = a2e(sChunk)\n      call LogText sChunk\n      if left(sChunk,4) = '@PJL'\n      then do\n        parse var sChunk 'LANGUAGE' '=' sLanguage .\n        if sLanguage = 'PCLXL'\n        then do\n          say 'PCLXL detected'\n          g.!bPCLXL = 1\n          sText = substr(sText,n)\n          return\n        end\n      end\n    end\n    else do                 /* EXTRACT NEXT BINARY STRING */\n      nLen = iNextAlpha - iNextBinary\n      sChunk = substr(sText, n, nLen)\n      n = iNextAlpha\n      call LogBinary sChunk\n    end\n\n  end\nreturn\n\nLogText:\n  parse arg sOut\n  call Log\n  if g.!OPTION.NOVAR\n  then do /* Do not scan text for variable names */\n    call LogTextChunks sOut\n  end\n  else do /* Scan text for variable names */\n    do while pos('&',sOut) > 0\n      parse var sOut sBeforeVar'&'sVar sOut\n      if length(sBeforeVar) > 0\n      then call LogTextChunks sBeforeVar\n      sVar = '&'sVar\n      parse upper var sVar sVarName'(' /* todo: fix this kludge */\n      if v.sVarName <> ''     /* If it is a known variable name */\n      then do\n        select\n          when g.!OPTION.ASM then,\n            call Log left('*'sVar,g.!nMargin) 'Variable   ' v.sVarName\n          otherwise call Log left(sVar,g.!nMargin) 'Variable   ' v.sVarName\n        end\n      end\n      else do\n        sErrorMessage = 'ERROR:      INVALID VARIABLE NAME',\n                        '<'sVarName'>'\n        say sErrorMessage\n        call Log left('*'sVar,16) sErrorMessage\n        call Log '* Valid variable names are:'\n        do i = 1 by 1 while v.i <> ''\n          call Log sValid.i  /* Name and desc of variable i */\n        end\n      end\n    end\n    if length(sOut) > 0\n    then call LogTextChunks sOut\n  end\n  call Log\nreturn\n\nLogTextChunks: procedure expose g.\n  parse arg sOut\n  /* Log the text data diced into n-byte chunks */\n  nOut = length(sOut)\n  nChunk = 70 /* Maximum width of a text chunk */\n  do i = 1 by nChunk while i+nChunk < nOut\n    sChunk = substr(sOut,i,nChunk)    /* Get a full chunk */\n    call LogTextChunk sChunk          /* Log it           */\n  end\n  sChunk = substr(sOut,i)         /* ...either null, or a short chunk */\n  if length(sChunk) > 0           /* if not null... */\n  then call LogTextChunk sChunk /* then log the short chunk */\nreturn\n\nLogTextChunk: procedure expose g.\n  parse arg sOut\n  i = verify(g.!sDelimiters,sOut,'NOMATCH') /* Use one not in text*/\n  if i = 0 then i = 1 /* else use the first one and hope for the best*/\n  cDelimiter = substr(g.!sDelimiters,i,1)\n  select\n    when g.!OPTION.ASM\n    then do\n      if length(sOut) > 8\n      then call Log '*' sOut\n      call LogASM e2a(sOut),sOut\n    end\n    otherwise call Log cDelimiter || sOut || cDelimiter\n  end\nreturn\n\nLogASM: procedure expose g.\n  parse arg sOut,sTxt,sCom\n/*\n Format into blocks of 8 bytes...\n\n DC X'aabbccddeeffgghh' abcdefgh comment up to column 71...............\n DC X'aabbccddee'       abcde    comment continued.....................\n*                                comment continued.....................\n*/\n  nOut = length(sOut)\n  nCom = length(sCom)\n  nChunk = 8 /* Maximum width of a text chunk */\n  nComment = 38 /* Maximum width of a comment chunk */\n  j = 1\n  do i = 1 by nChunk while i+nChunk <= nOut\n    sChunk = substr(sOut,i,nChunk)    /* Get a full chunk */\n    sText  = substr(sTxt,i,nChunk)\n    sComm  = substr(sCom,j,nComment)\n    j = j + nComment\n    call LogASMChunk sChunk,sText,sComm\n  end\n  sChunk = substr(sOut,i)         /* ...either null, or a short chunk */\n  sText  = substr(sTxt,i)\n  sComm  = substr(sCom,j,nComment)\n  if length(sChunk) > 0           /* if not null... */\n  then call LogASMChunk sChunk,sText,sComm /* log the short chunk */\n  j = j + nComment\n  do while j <= nCom\n    sComm  = substr(sCom,j,nComment)\n    call LogASMChunk ,,sComm\n    j = j + nComment\n  end\n  if nOut > nChunk /* Insert blank line after multiline data */\n  then call Log\nreturn\n\nLogASMChunk: procedure expose g.\n  parse arg sOut,sTxt,sCom\n  if length(sOut) = 0\n  then call Log left('*'                 ,23) left(sTxt,8) strip(sCom)\n  else call Log left(\" DC X'\"c2x(sOut)\"'\",23) left(sTxt,8) strip(sCom)\nreturn\n\nLog: procedure expose g.\n  parse arg sOut\n  if sOut = '' & g.!bLastWasBlank then return\n  g.!bLastWasBlank = sOut = ''\n  if g.!OPTION.TRACE then say '<'translate(sOut,'?',xrange('00'x,'3f'x))'>'\n  if g.!OPTION.ASM\n  then queue left(sOut,71) /* Do not invade column 72 onwards */\n  else queue sOut\n  rc = putQueued(g.!hFileOut)\n  if rc <> 0\n  then call Abort 'Aborted during write to file' g.!hFileOut 'rc='rc\nreturn\n\nAbort: procedure\n  parse arg sMsg\n  say sMsg\n  call Epilog\nexit\n\nLogGL2: procedure expose g. s. u.\n  parse arg cPrefix,sOut\n  do while length(sOut) > 0\n    if pos(left(sOut,1),g.!sGLTerminators) > 0\n    then do\n      j = verify(sOut, g.!sGLTerminators, 'NOMATCH')\n      if j > 0\n      then do\n        j = j - 1\n        parse var sOut sGLTerminators +(j) sOut\n        call LogBinary sGLTerminators /* Dump excess terminators */\n      end\n    end\n\n    parse var sOut sCmd +2 sOut\n    sCmd = a2e(sCmd)\n\n    select\n      when sCmd = 'CO' then do /* Lexmark GL/2 comment */\n        cDelimiter = left(sOut,1)\n        parse var sOut (cDelimiter) sComment (cDelimiter) sOut\n        cDelimiter = a2e(cDelimiter)\n        sComment   = a2e(sComment)\n        call Log ' CO'cDelimiter\n        call Log cDelimiter || sComment || cDelimiter\n        call Log ' 'cDelimiter\n      end\n      when sCmd = 'PE' then do /*  Polyline Encoded command...*/\n        parse var sOut sOperands '3B'x sOut\n        call Log\n        if g.!OPTION.ASM\n        then call LogASM e2a(sCmd),sCmd,s.sCmd\n        else call Log ' 'left('PE',g.!nMargin)s.sCmd\n        call LogBinary sOperands || '3B'x\n        if sOperands <> '' & g.!OPTION.COM /* If we want GL2 decoded... */\n        then call DoPE sOperands /* ...decode GL2 as comment lines */\n        call Log\n      end\n      when pos(left(sOut,1),g.!sGLOperands) > 0 then do\n        /* If cmd has operands...*/\n        j = verify(sOut, g.!sGLOperands, 'NOMATCH')\n        if j = 0\n        then j = length(sOut)\n        else j = j - 1\n        parse var sOut sOperands +(j) sOut\n        sComment  = s.sCmd\n        if sCmd = 'RF' & g.!OPTION.NOASM /* Decode the fill pattern neatly */\n        then do /* RF command with operands... */\n          sOperandsRF = translate(a2e(sOperands),' ',',')\n          parse var sOperandsRF nIndexRF nWidthRF nHeightRF sPatternRF';'\n          sCmdAll = sCmd || nIndexRF','nWidthRF','nHeightRF','\n          call Log left(cPrefix || sCmdAll,g.!nMargin) sComment\n          nOperandsRF = nWidthRF * nHeightRF\n          do nWord = 1 to nOperandsRF by nWidthRF\n            call Log cPrefix ||,\n                     space(subword(sPatternRF,nWord,nWidthRF),1,',')','\n          end\n          call Log cPrefix';'\n        end\n        else do /* other commands with operands... */\n          sOperands = a2e(sOperands)\n          sCmdAll   = sCmd || sOperands\n          if cPrefix = '*' | g.!OPTION.NOASM\n          then do\n            if length(sCmdAll) < g.!nMargin\n            then call Log left(cPrefix || sCmdAll,g.!nMargin) sComment\n            else do /* else log the operands in chunks */\n              call Log left(cPrefix || sCmd,g.!nMargin) sComment\n              call LogTextChunks sOperands\n            end\n          end\n          else call LogASM e2a(sCmdAll),sCmdAll,s.sCmd\n        end\n      end\n      otherwise do /* command with no operands... */\n        if cPrefix = '*' | g.!OPTION.NOASM\n        then call Log,\n            left(cPrefix||sCmd,max(length(sCmd)+1,g.!nMargin)) s.sCmd\n        else call LogASM e2a(sCmd),sCmd,s.sCmd\n      end\n    end\n  end\nreturn\n\n/*--------------------------------------------------------------------*\n * Decode the HP/GL2 Polyline Encoded (PE) command...                 *\n *-------------------------------------------------------------------*/\n\nDoPE: procedure expose g. s. u.\n  parse arg sOperands\n\n  parse value '1 2 3' with SP FRAC COORD\n  bBase32 = 0\n  bBase64 = 1\n  nFracBits = 0\n  nDecimals = 0\n  nFracDiv = 1\n  bPU = 0; bLastPU = '';\n  bPA = 0; bLastPA = '';\n  nValue = 0\n  nValueType = 0\n  nMult = 1\n\n  do i = 1 to length(sOperands)\n    c = substr(sOperands,i,1)\n    c7bit = bitand(c,'01111111'b)\n    e7bit = a2e(c7bit)\n    select\n      when e7bit = ':' then do\n        nValueType = SP\n      end\n      when e7bit = '<' then do\n        bPU = 1\n      end\n      when e7bit = '>' then do\n        nValueType = FRAC\n      end\n      when e7bit = '=' then do\n        bPA = 1\n      end\n      when e7bit = '7' then do\n        bBase64 = 0\n        bBase32 = 1\n      end\n\n      when bBase64 then do\n        n = c2d(c)\n        select\n          when n >= 63 & n <= 126 then do\n            nValue = nValue + nMult * (n - 63)\n            nMult = nMult * 64\n          end\n          when n >= 191 & n <= 254 & bBase64 then do\n            nValue = nValue + nMult * (n - 191)\n            call LogValue nValue\n            nMult = 1\n            nValue = 0\n          end\n          otherwise nop\n        end\n      end\n\n      when bBase32 then do\n        n = c2d(c7bit)\n        select\n          when n >= 63 & n <= 94 then do\n            nValue = nValue + nMult * (n - 63)\n            nMult = nMult * 32\n          end\n          when n >= 95 & n <= 126 then do\n            nValue = nValue + nMult * (n - 95)\n            call LogValue nValue\n            nMult = 1\n            nValue = 0\n          end\n          otherwise nop\n        end\n      end\n\n      otherwise nop /* ignore c */\n    end\n\n  end /* next c */\nreturn\n\nLogValue:\n  if nValue // 2\n  then nValue = -(nValue % 2)\n  else nValue = +(nValue % 2)\n  if nFracBits <> 0\n  then nValue = format(nValue / nFracDiv,,nDecimals)\n  select\n    when nValueType = SP then do\n      call LogGL2 '*',e2a('SP'nValue)\n      nValueType = 0\n    end\n    when nValueType = COORD then do\n      nValueY = nValue\n      sPlotCmd = ''\n      if bPU <> bLastPU\n      then do\n        if bPU\n        then sPlotCmd = 'PU'\n        else sPlotCmd = 'PD'\n      end\n      if bPA <> bLastPA\n      then do\n        if bPA\n        then sPlotCmd = sPlotCmd || 'PA'\n        else sPlotCmd = sPlotCmd || 'PR'\n      end\n      if sPlotCmd <> ''\n      then do\n        sPlotCmd = sPlotCmd || nValueX','nValueY\n        call LogGL2 '*',e2a(sPlotCmd)\n      end\n      else call Log '*'nValueX','nValueY\n      bLastPU = bPU\n      bLastPA = bPA\n      bPU = 0\n      bPA = 0\n      nValueType = 0\n    end\n    when nValueType = FRAC then do\n      nFracBits = nValue\n      nDecimals = trunc((nValue * 3) / 10)\n      nFracDiv = 2 ** nValue\n      nValueType = 0\n    end\n    otherwise do\n      nValueX = nValue\n      nValueType  = COORD\n    end\n  end\nreturn\n\n\nLogBinary: procedure expose g.\n  parse arg sOut\n  call Log\n  nOut = length(sOut)\n\n  /* First...log the binary data diced into n-byte chunks */\n  if g.!OPTION.NOASM  /* ...if not ASM output */\n  then do\n    nChunk = 128\n    do i = 1 by nChunk while i+nChunk < nOut\n      sChunk = substr(sOut,i,nChunk)    /* Get a full chunk */\n      call LogBinaryChunk sChunk        /* Log it           */\n    end\n    sChunk = substr(sOut,i)         /* ...either null, or a short chunk */\n    if length(sChunk) > 0           /* if not null... */\n    then call LogBinaryChunk sChunk /* then log the short chunk */\n  end\n\n  if g.!OPTION.HEX | g.!OPTION.ASM\n  then do /* ...log the hex translation as comments */\n    do i = 1 by 32 while i+32 < nOut\n      sChunk = substr(sOut,i,32)\n      xChunk = c2x(sChunk)\n      nOffset = right(i-1,5,'0')\n      if g.!OPTION.ASM\n      then call LogASM sChunk\n      else call Log '*+'nOffset c2x(sChunk)\n    end\n    sChunk = substr(sOut,i)\n    if length(sChunk) > 0\n    then do\n      if g.!OPTION.ASM\n      then call LogASM sChunk\n      else call Log '*+'right(i-1,5,'0') c2x(sChunk)\n    end\n  end\n  call Log\nreturn\n\nLogBinaryChunk: procedure expose g.\n  parse arg sChunk\n  if IsPrintable(sChunk)\n  then call LogTextChunk a2e(sChunk)\n  else do\n    if g.!OPTION.X\n    then do\n      call Log 'X'c2x(sChunk)      /* Log binary as printable hex */\n    end\n    else do\n      if right(sChunk,1) == ' '    /* If last byte is an EBCDIC blank */\n      then call Log 'C'sChunk'ff'x /* append x'ff' */\n      else call Log 'B'sChunk      /* log as-is    */\n    end\n  end\nreturn\n\n\n\nProlog:\n  g.!nMargin = 16\n  say 'Building PCL command table...'\n  do i = 1 by 1 while left(sourceline(i),3) <> 'PCL'\n  end\n\n  nFirstLine = i\n  nVar = 0\n\n  do i = nFirstLine while sourceline(i) <> '//'\n    sLine = strip(sourceline(i))\n    sRecordType = left(sLine,3)\n    select\n      when sRecordType = 'PCL' then do\n        sEntry = sLine\n        do j = i+1 until sourceline(j) = ''\n          sEntry = sEntry || strip(sourceline(j))';'\n        end\n        i = j\n        call AddEntry strip(sEntry,'TRAILING',';')\n      end\n      when sRecordType = 'GL2' then do\n        call AddEntry sLine\n      end\n      when sRecordType = 'VAR' then do\n        parse var sLine . sVarName sVarDesc\n        nVar = nVar + 1 /* Number of variables */\n        v.nVar = substr(sLine,5) /* &varname   description... */\n        sVarDesc = strip(sVarDesc)\n        sValid.nVar = '*'substr(sVarName,2,8) ||,\n                      '        Variable    'sVarDesc\n        upper sVarName\n        v.sVarName = sVarDesc\n      end\n      otherwise nop\n    end\n  end\n\n  g.!sTerminators = xrange('40'x,'5a'x) || '1b'x /* '@' and 'A'...'Z' */\n  g.!sAlphas   = xrange('a','z') || xrange('A','Z') || '@'\n  g.!sNumerics = '0123456789.-+'\n  if g.!OPTION.ASM\n  then g.!sDelimiters = \"'\"\n  else g.!sDelimiters = \" '\" || '\"/|!\\$#@-.+=:'\n  g.!sGLOperands = '303132333435363738392E2C2D2B3B'x\n                 /*  0 1 2 3 4 5 6 7 8 9 . , - + ; */\n  g.!sGLTerminators = '00090A0D203B'x\n\n  g.!sEBCDIC = xrange('81'x,'89'x) ||,\n               xrange('91'x,'99'x) ||,\n               xrange('A2'x,'A9'x) ||,\n               xrange('C1'x,'C9'x) ||,\n               xrange('D1'x,'D9'x) ||,\n               xrange('E2'x,'E9'x) ||,\n               xrange('F0'x,'F9'x) ||,\n               ' !\"#$%&''()*+,-./' ||,\n               ':;<=>?@'           ||,\n               '(\\)\u00ac_`'            ||, /* LSB, BACKSLASH, RSB, HAT */\n               '{|}~'              ||,\n               xrange('00'x,'FF'x)     /* all others as is */\n\n  g.!sASCII  = xrange('61'x,'69'x) ||,\n               xrange('6A'x,'72'x) ||,\n               xrange('73'x,'7A'x) ||,\n               xrange('41'x,'49'x) ||,\n               xrange('4A'x,'52'x) ||,\n               xrange('53'x,'5A'x) ||,\n               xrange('30'x,'39'x) ||,\n               xrange('20'x,'2F'x) ||,\n               xrange('3A'x,'40'x) ||,\n               xrange('5B'x,'60'x) ||,\n               xrange('7B'x,'7E'x) ||,\n               xrange('00'x,'FF'x)     /* all others as is */\n\n  /* The following is a list of all characters which are present in\n     both the EBCDIC and ASCII character set and which print the\n     same symbol in both character sets.  That is, you can translate\n     in both directions and not bugger anything up visually...\n  */\n  g.!sPrintable = xrange('20'x,'5a'x) || '5c'x || xrange('5f'x,'7e'x)\n\n  g.!FONTFORMAT.0  = 'PCL Bitmapped'\n  g.!FONTFORMAT.10 = 'Intellifont Bound Scalable'\n  g.!FONTFORMAT.11 = 'Intellifont Unbound Scalable'\n  g.!FONTFORMAT.15 = 'TrueType Scalable'\n  g.!FONTFORMAT.20 = 'Resolution-Specified Bitmapped'\nreturn\n\nAddEntry: procedure expose s. u.\n  parse arg 1 sRecordType +3,\n            5 sPrefix     +2,\n           12 sSuffix     +1,\n           22 sMeaning','sUnit','sValues\n  sMeaning = strip(sMeaning)\n  if sRecordType = 'GL2'\n  then do /* HP-GL/2 data */\n    s.sPrefix = sMeaning\n  end\n  else do /* PCL command */\n    if sPrefix <> ''\n    then sID = strip(sPrefix) || sSuffix\n    else sID = strip(sSuffix)\n    s.sID = sMeaning\n    u.sID = sUnit\n    do while sValues <> '' /* 1=meaning;2=meaning;...;n=meaning; */\n      parse var sValues sValue'='sMeaning';'sValues\n      sIDValue = sID || sValue\n      s.sIDValue = sMeaning\n    end\n  end\nreturn\n\n\na2e: PROCEDURE EXPOSE g.\n  parse arg sData\n  if g.!SYSTEM = 'TSO'\n  then sData = translate(sData,g.!sEBCDIC,g.!sASCII,'.')\nreturn sData\n\ne2a: PROCEDURE EXPOSE g.\n  parse arg sData\n  if g.!SYSTEM = 'TSO'\n  then sData = translate(sData,g.!sASCII,g.!sEBCDIC,'.')\nreturn sData\n\nIsPrintable: procedure expose g.\n  parse arg sTextData\nreturn verify(sTextData,g.!sPrintable) = 0\n\n/*BOX\n***********************************************************************\n**                                                                   **\n&name\n**                                                                   **\n&title\n**                                                                   **\n** FUNCTION - This member is read by the VPS separator page exit in  **\n**            order to print a separator page.  As the exit scans the**\n**            member it will substitute any variables with their     **\n**            current values before sending the resulting text to    **\n**            the printer.                                           **\n**                                                                   **\n** NOTES    - 1.  See the comments at the start of the VPSSEP Rexx   **\n**                procedure for instructions on how to create this   **\n**                member.                                            **\n**                                                                   **\n**            2.  Summary of column 1 record codes:                  **\n**                 *  =  Comment                                     **\n**                 E  =  Escape, PCL command, then comment           **\n**                 &  =  Variable name, then comment                 **\n**                 B  =  Binary data only (no comment allowed)       **\n**                 C  =  Binary data with X'FF' appended             **\n**                 X  =  Binary data in printable hex format         **\n**             other  =  Delimiter delimiting text (eg 'text')       **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date     By       Reason (most recent at the top please**\n**            -------- -------- -------------------------------------**\n&date\n**                                                                   **\n**                                                                   **\n***********************************************************************\n//\n***********************************************************************\n**                                                                   **\n** TITLE    - PCL AND HP-GL/2 COMMAND DESCRIPTION FILE               **\n**                                                                   **\n** FUNCTION - This describes the PCL5 and HP-GL/2 command set.       **\n**                                                                   **\n** NOTES    - PCL6 commands (XLO and XLC entries) are for doco only  **\n**            and are not actually processed.                        **\n**                                                                   **\n** SYNTAX   - Each record has the following format:                  **\n**                                                                   **\n**            Columns Meaning                                        **\n**            ------- ---------------------------------------------- **\n**            1 to 2  PCL command prefix, or HP-GL/2 command, or a   **\n**                    comment record if '**' is present.             **\n**                                                                   **\n**            5       PCL command value (either a particular number, **\n**                    or any number if '#' is present).              **\n**                                                                   **\n**            8       PCL command suffix (a single uppercase letter),**\n**                    or indicates this is an HP-GL/2 command if '.' **\n**                    is present.                                    **\n**                                                                   **\n**            18...   A description of the command, its unit if any, **\n**                    and the meanings of any or all of its valid    **\n**                    command values.  The following syntax applies: **\n**                                                                   **\n**                    description,unit,value=meaning;value=meaning...**\n**                                                                   **\n**                    description: Brief meaning of the command      **\n**                                                                   **\n**                    unit: The unit applying to the PCL command     **\n**                          value (for example 'rows').  May be      **\n**                          omitted if the value has no unit.        **\n**                                                                   **\n**                    value=meaning: A list of value/meaning pairs.  **\n**                          Each pair must be terminated by a semi-  **\n**                          colon.  This is used to list the meanings**\n**                          of each value which may appear in this   **\n**                          PCL command (for example, for the style  **\n**                          0=Upright;1=Italic...).                  **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date    By  Reason (most recent at the top please)     **\n**            ------- --- ------------------------------------------ **\n**           19980130 AJA Added *c # W.                              **\n**           19970303 AJA Initial version.                           **\n**                                                                   **\n***********************************************************************\n\n*---------------------------------------------------------------------*\n*  PCL5 COMMAND CODES, CATEGORIES, MEANINGS AND TYPICAL VALUES        *\n*---------------------------------------------------------------------*\n\n*...+...10....+...20....+...30....+...40....+...50....+...60....+...70..\nPCL &b  #  M         Color       Monochrome print mode,,\n        0=Print in mixed render algorithm mode\n        1=Print everything in gray equivalent\n\nPCL &p  #  C         Color       Palette control,,\n        0=Delete all palettes except those in the stack\n        1=Delete all palettes in stack\n        2=Delete palette\n        6=Copy active palette\n\nPCL &p  #  I         Color       Palette control ID\n\nPCL &p  #  S         Color       Select pallette\n\nPCL *i  #  W (data)  Color       Viewing illuminant,bytes\n\nPCL *l  #  W (data)  Color       Color lookup tables,bytes\n\nPCL *m  #  W (data)  Color       Download dither matrix,bytes\n\nPCL *p  #  P         Color       Push/pop palette,,\n        0=Push\n        1=Pop\n\nPCL *r  #  U         Color       Simple color,,\n       -3=3 planes, device CMY palette\n        1=Single plane, B/W palette\n        3=3 planes, device RGB palette\n\nPCL *t  #  I         Color       Gamma correction\n\nPCL *t  #  J         Color       Render algorithm\n\nPCL *v  #  A         Color       Color component one\n\nPCL *v  #  B         Color       Color component two\n\nPCL *v  #  C         Color       Color component three\n\nPCL *v  #  I         Color       Assign color index\n\nPCL *v  #  S         Color       Foreground color\n\nPCL *v  #  W (data)  Color       Configure image data,bytes\n\nPCL        =         Cursor      Vertical = 1 half line-feed\n\nPCL &a  #  C         Cursor      Horizontal,columns\n\nPCL &a  #  H         Cursor      Horizontal,decipoints\n\nPCL &a  #  R         Cursor      Vertical,rows\n\nPCL &a  #  V         Cursor      Vertical,decipoints\n\nPCL &f  #  S         Cursor      Push/pop cursor position,,\n        0=Push\n        1=Pop\n\nPCL &k  #  G         Cursor      Line Termination,,\n        0=CR=CR,LF=LF,FF=FF\n        1=CR=CR+LF,LF=LF,FF=FF\n        2=CR=CR,LF=CR+LF,FF=CR+LF\n        3=CR=CR+LF,LF=CR+LF,FF=CR+LF\n\nPCL *p  #  X         Cursor      Horizontal,PCL units\n\nPCL *p  #  Y         Cursor      Vertical,PCL units\n\nPCL        Y         Debug       Display functions (enable)\n\nPCL        Z         Debug       Display functions (disable)\n\nPCL &s  #  C         Debug       End-of-line wrap\n\nPCL (s  #  W (data)  FontCreate  Character descriptor/data,bytes\n\nPCL *c  #  E         FontCreate  Character code\n\nPCL )s  #  W (data)  FontCreate  Font descriptor/data,bytes\n\nPCL &n  #  W (data)  FontManage  Alphanumeric ID,bytes\n\nPCL *c  #  D         FontManage  Font ID #\n\nPCL *c  #  F         FontManage  Font control,,\n        0=Delete all soft fonts\n        1=Delete all temporary soft fonts\n        2=Delete soft font\n        3=Delete character code\n        4=Make soft font temporary\n        5=Make soft font permanent\n        6=Copy/assign current invoked font as temporary\n\nPCL (   #  X         FontSelect  Primary Soft font ID #\n\nPCL (s  #  B         FontSelect  6/10 Primary Stroke weight,,\n       -7=Ultra thin\n       -6=Extra thin\n       -5=Thin\n       -4=Extra light\n       -3=Light\n       -2=Demi light\n       -1=Semi light\n        0=Medium\n        1=Semi bold\n        2=Demi bold\n        3=Bold\n        4=Extra bold\n        5=Black\n        6=Extra black\n        7=Ultra black\n\nPCL (s  #  H         FontSelect  3/10 Primary Pitch,chars/inch\n\nPCL (s  #  P         FontSelect  2/10 Primary Spacing,,\n        0=Fixed\n        1=Proportional\n\nPCL (s  #  S         FontSelect  5/10 Primary Style,,\n        0=Upright\n        1=Italic\n        4=Condensed\n        5=Condensed italic\n        8=Compressed extra condensed\n       24=Expanded\n       32=Outline\n       64=Inline\n      128=Shadowed\n      160=Outline shadowed\n\nPCL (s  #  T         FontSelect  7/10 Primary Typeface,,\n        0=Line Printer\n        3=Courier\n        4=Helvetica\n        6=Gothic\n        7=Script\n        8=Prestige\n     4099=Courier\n     4101=CG Times\n     4102=Letter Gothic\n     4113=CG Omega\n     4116=Coronet\n     4140=Clarendon\n     4148=Univers\n     4168=Antique Olive\n     4197=Garamond\n     4297=Marigold\n     4362=Albertus\n    16602=Arial\n    16901=Times New\n    24579=CourierPS\n    24580=Helvetica\n    24591=Palatino\n    24607=ITC Avant Garde Gothic\n    24623=ITC Bookman\n    24703=New Century Schoolbook\n    25093=Times Roman\n\nPCL (s  #  V         FontSelect  4/10 Primary Height,points\n\nPCL (ID              FontSelect  1/10 Primary Symbol set,,\n       8M=HP Math-8\n       8U=HP Roman-8\n      10U=PC-8\n       0N=ISO 8859-1 Latin 1\n       0O=OCR A\n       0U=ASCII\n      19U=Windows 3.1 Latin 1\n       9U=Windows 3.0 Latin 1\n       6J=Microsoft Publishing\n\nPCL (3     @         FontSelect  Primary Select default font\n\nPCL &d     @         FontSelect  Underline,,\n        0=Off\n\nPCL &d  #  D         FontSelect  Underline,,\n        0=On\n        3=Floating\n\nPCL &p  #  X (data)  FontSelect  Transparent print data,bytes\n\nPCL )   #  X         FontSelect  Secondary Soft font ID #\n\nPCL )s  #  B         FontSelect  6/10 Secondary Stroke weight,,\n       -7=Ultra thin\n       -6=Extra thin\n       -5=Thin\n       -4=Extra light\n       -3=Light\n       -2=Demi light\n       -1=Semi light\n        0=Medium\n        1=Semi bold\n        2=Demi bold\n        3=Bold\n        4=Extra bold\n        5=Black\n        6=Extra black\n        7=Ultra black\n\nPCL )s  #  H         FontSelect  3/10 Secondary Pitch,chars/inch\n\nPCL )s  #  P         FontSelect  2/10 Secondary Spacing,,\n        0=Fixed\n        1=Proportional\n\nPCL )s  #  S         FontSelect  5/10 Secondary Style,,\n        0=Upright\n        1=Italic\n        4=Condensed\n        5=Condensed italic\n        8=Compressed extra condensed\n       24=Expanded\n       32=Outline\n       64=Inline\n      128=Shadowed\n      160=Outline shadowed\n\nPCL )s  #  T         FontSelect  7/10 Secondary Typeface,,\n        0=Line Printer\n        3=Courier\n        4=Helvetica\n        6=Gothic\n        7=Script\n        8=Prestige\n     4099=Courier\n     4101=CG Times\n     4102=Letter Gothic\n     4148=Univers\n     4197=Garamond Antiqua\n    16602=Arial\n    16901=Times New\n\nPCL )s  #  V         FontSelect  4/10 Secondary Height,points\n\nPCL )ID              FontSelect  1/10 Secondary Symbol set,,\n      8M=HP Math-8\n      8U=HP Roman-8\n     10U=PC-8 0N=ISO 8859-1 Latin 1\n      0O=OCR A\n      0U=ASCII\n     19U=Windows 3.1 Latin 1\n      9U=Windows 3.0 Latin 1\n      6J=Microsoft Publishing\n\nPCL )3     @         FontSelect  Secondary Select default font\n\nPCL        E         JobCntl     Printer reset\n\nPCL &a  #  G         JobCntl     Duplex page side selection,,\n        0=Next side\n        1=Front side\n        2=Back side\n\nPCL &b  #  W (data)  JobCntl     Configuration (I/O),bytes\n\nPCL &l  #  G         JobCntl     Output bin,,\n        0=Auto\n        1=Upper\n        2=Rear\n        3=High Capacity\n        4=High Capacity 1\n        5=High Capacity 2\n        6=High Capacity 3\n        7=High Capacity 4\n        8=High Capacity 5\n        9=High Capacity 6\n        10=High Capacity 7\n        11=High Capacity 8\n\nPCL &l  #  S         JobCntl     Printer mode,,\n        0=Simplex\n        1=Duplex long-edge\n        2=Duplex short-edge\n\nPCL &l  #  U         JobCntl     Long-edge offset registration,decipoints\n\nPCL &l  #  X         JobCntl     Number of copies\n\nPCL &l  #  Z         JobCntl     Short-edge offset registration,decipoints\n\nPCL &l  1  T         JobCntl     Toggle job separation mechanism\n\nPCL &u  #  D         JobCntl     Unit-of-measure,units/inch\n\nPCL %-12345X         JobCntl     Universal exit language,,\n      12345=Reset printer\n\nPCL &f  #  X         Macros      Macro control,,\n        0=Start macro definition\n        1=Stop macro definition\n        2=Execute macro\n        3=Call macro\n        4=Enable macro for automatic overlay\n        5=Disable automatic overlay\n        6=Delete all macros\n        7=Delete all temporary macros\n        8=Delete macro\n        9=Make macro temporary\n       10=Make macro permanent\n\nPCL &f  #  Y         Macros      Set macro ID #\n\nPCL        9         PageCntl    Clear horizontal margins\n\nPCL &a  #  L         PageCntl    Left margin column\n\nPCL &a  #  M         PageCntl    Right margin column\n\nPCL &a  #  P         PageCntl    Print direction,degrees\n\nPCL &c  #  T         PageCntl    Character text path direction,,\n        0=Horizontal\n       -1=Vertical rotated\n\nPCL &k  #  H         PageCntl    Horizontal motion index,x 1/120 inch\n\nPCL &l  #  A         PageCntl    Page size,,\n        1=Executive\n        2=Letter\n        3=Legal\n        6=Ledger\n       25=A5\n       26=A4\n       27=A3\n       45=JIS B5\n       46=JIS B4\n       71=Hagaki postcard\n       72=Oufuku-Hagaki postcard\n       80=Monarch envelope\n       81=Commercial envelope\n       90=DL envelope\n       91=C5 envelope\n      100=B5 envelope\n\nPCL &l  #  C         PageCntl    Vertical motion index,x 1/48 inch\n\nPCL &l  #  D         PageCntl    Line spacing,lines/inch\n\nPCL &l  #  E         PageCntl    Top margin,lines\n\nPCL &l  #  F         PageCntl    Text length,lines\n\nPCL &l  #  H         PageCntl    Paper source,,\n        0=Print current page\n        1=Main\n        2=Manual\n        3=Manual envelope\n        4=Alternate\n        5=Optional large\n        6=Envelope feeder\n        7=Autoselect\n        8=Tray 1\n        20=High Capacity 1\n        21=High Capacity 2\n        22=High Capacity 3\n        23=High Capacity 4\n        24=High Capacity 5\n        25=High Capacity 6\n        26=High Capacity 7\n        27=High Capacity 8\n\nPCL &l  #  L         PageCntl    Perforation skip,,\n        0=Disabled\n        1=Enabled\n\nPCL &l  #  O         PageCntl    10/10 Orientation,,\n        0=Portrait\n        1=Landscape\n        2=Reverse portrait\n        3=Reverse landscape\n\nPCL &l  #  P         PageCntl    Page length,lines (obsolete)\n\nPCL &t  #  P         PageCntl    Text parsing method\n\nPCL %   #  A         PictFrame   Enter PCL mode,,\n        0=Restore old PCL cursor position\n        1=Set PCL cursor to GL2 pen position\n\nPCL %   #  B         PictFrame   Enter HP-GL/2 mode,,\n        0=Use old GL2 pen position\n        1=Use PCL cursor position\n        2=Use PCL dot coord and old GL2 pen position\n        3=Use PCL dot coord and cursor position\n\nPCL *c  #  K         PictFrame   HP-GL/2 plot horz size,inches\n\nPCL *c  #  L         PictFrame   HP-GL/2 plot vert size,inches\n\nPCL *c  #  X         PictFrame   Picture frame horz size,decipoints\n\nPCL *c  #  Y         PictFrame   Picture frame vert size,decipoints\n\nPCL *c  0  T         PictFrame   Set picture frame anchor point\n\nPCL *c  #  G         PrintModel  Pattern (area fill) ID\n\nPCL *c  #  Q         PrintModel  Pattern control,,\n        0=Delete all patterns\n        1=Delete all temporary patterns\n        2=Delete pattern\n        4=Make pattern temporary\n        5=Make pattern permanent\n\nPCL *c  #  W (data)  PrintModel  User-defined pattern,bytes\n\nPCL *l  #  O         PrintModel  Logical (ROP3) operation\n\nPCL *l  #  R         PrintModel  Pixel placement,,\n        0=Grid intersection\n        1=Grid centered\n\nPCL *p  #  R         PrintModel  Set pattern reference point\n\nPCL *v  #  N         PrintModel  Source transparency mode,,\n        0=Transparent\n        1=Opaque\n\nPCL *v  #  O         PrintModel  Pattern transparency mode,,\n        0=Transparent\n        1=Opaque\n\nPCL *v  #  T         PrintModel  Select current pattern,,\n        0=Solid black\n        1=Solid white\n        2=Shading pattern\n        3=Cross-hatch pattern\n        4=User-defined pattern\n\nPCL *v  #  W (data)  PrintModel  User-defined pattern,bytes\n\nPCL *b  #  M         Raster      Set compression method,,\n        0=Unencoded\n        1=Run-length\n        2=TIFF\n        3=Delta row\n        5=Adaptive\n\nPCL *b  #  V (data)  Raster      Transfer raster data by plane,bytes\n\nPCL *b  #  W (data)  Raster      Transfer raster data by row/block,bytes\n\nPCL *b  #  Y         Raster      Y offset,raster lines\n\nPCL *r     B         Raster      End raster graphics\n\nPCL *r     C         Raster      End raster graphics\n\nPCL *r  #  A         Raster      Start raster graphics,,\n        0=Set left graphics margin at X-position 0\n        1=Set left graphics margin to current X-position\n        2=Turn on scale mode/logical left\n        3=Turn on scale mode/cursor position\n\nPCL *r  #  F         Raster      Presentation,,\n        0=Current print direction\n        3=Along width of physical page\n\nPCL *r  #  S         Raster      Source raster width,pixels\n\nPCL *r  #  T         Raster      Source raster height,rows\n\nPCL *t  #  H         Raster      Destination raster width,decipoints\n\nPCL *t  #  K         Raster      Scale algorithm,,\n        0=Light background\n        1=Dark background\n\nPCL *t  #  R         Raster      8/10 Raster resolution,dots/inch\n\nPCL *t  #  V         Raster      Destination raster height,decipoints\n\nPCL *c  #  A         RectArea    Horz rectangle size,dots\n\nPCL *c  #  B         RectArea    Vert rectangle size,dots\n\nPCL *c  #  H         RectArea    Horz rectangle size,decipoints\n\nPCL *c  #  P         RectArea    Fill rectangular area,,\n        0=Solid area fill\n        1=Solid white area fill\n        2=Shading fill\n        3=Cross-hatch pattern fill\n        4=User-defined pattern\n        5=Current pattern\n\nPCL *c  #  V         RectArea    Vert rectangle size,decipoints\n\nPCL &r  #  F         Status      Flush all pages,,\n        0=Flush all complete pages\n        1=Flush all pages\n\nPCL *s  #  I         Status      Inquire entity,,\n        0=Font\n        1=Macro\n        2=User-defined pattern\n        3=Symbol set\n        4=Font extended\n\nPCL *s  #  T         Status      9/10 Set location type,,\n        0=Invalid\n        1=Currently selected\n        2=All locations\n        3=Internal\n        4=Download entity\n        5=Cartridge\n        7=SIMMs\n\nPCL *s  #  U         Status      Set location unit within location type\n\nPCL *s  #  X         Status      Echo\n\nPCL *s  1  M         Status      Free space\n\nPCL (f  #  W (data)  SymbolSet   Define symbol set,bytes\n\nPCL *c  #  R         SymbolSet   Symbol set ID code\n\nPCL *c  #  S         SymbolSet   Symbol set control,,\n        0=Delete all user-defined symbol sets\n        1=Delete all temporary symbol sets\n        2=Delete symbol set\n        4=Make symbol set temporary\n        5=Make symbol set permanent\n\n*---------------------------------------------------------------------*\n*  HP-GL/2 COMMAND CODES                                              *\n*---------------------------------------------------------------------*\n\nGL2 DF               Config      Default values\nGL2 IN               Config      Initialize\nGL2 IP               Config      Input P1 and P2\nGL2 IR               Config      Input relative P1 and P2\nGL2 IW               Config      Input window\nGL2 RO               Config      Rotate coordinate system\nGL2 SC               Config      Scale\nGL2 AA               Vector      Arc absolute\nGL2 AR               Vector      Arc relative\nGL2 AT               Vector      Absolute arc three point\nGL2 BZ               Vector      Bezier absolute\nGL2 BR               Vector      Bezier relative\nGL2 CI               Vector      Circle\nGL2 PA               Vector      Plot absolute\nGL2 PD               Vector      Pen down\nGL2 PE               Vector      Polyline Encoded...\nGL2 PR               Vector      Plot relative\nGL2 PU               Vector      Pen up\nGL2 RT               Vector      Relative arc three point\nGL2 EA               Polygon     Edge rectangle absolute\nGL2 ER               Polygon     Edge rectangle relative\nGL2 EW               Polygon     Edge wedge\nGL2 EP               Polygon     Edge polygon\nGL2 FP               Polygon     Fill polygon\nGL2 PM               Polygon     Polygon mode\nGL2 RA               Polygon     Fill rectangle absolute\nGL2 RR               Polygon     Fill rectangle relative\nGL2 WG               Polygon     Fill wedge\nGL2 AC               Attrib      Anchor corner\nGL2 FT               Attrib      Fill type\nGL2 LA               Attrib      Line attributes\nGL2 LT               Attrib      Line type\nGL2 PW               Attrib      Pen width\nGL2 RF               Attrib      Raster fill definition\nGL2 SM               Attrib      Symbol mode\nGL2 SP               Attrib      Select pen\nGL2 SV               Attrib      Screened vectors\nGL2 TR               Attrib      Transparency mode\nGL2 UL               Attrib      User defined line type\nGL2 WU               Attrib      Pen width unit selection\nGL2 AD               Char        Alternate font definition\nGL2 CF               Char        Character fill mode\nGL2 CP               Char        Character plot\nGL2 DI               Char        Absolute label direction\nGL2 DR               Char        Relative label direction\nGL2 DT               Char        Define label terminator\nGL2 DV               Char        Define variable text path\nGL2 ES               Char        Extra space\nGL2 FI               Char        Select primary font ID\nGL2 FN               Char        Select secondary font ID\nGL2 LB               Char        Label text\nGL2 LO               Char        Label origin\nGL2 LM               Char        Label mode\nGL2 SA               Char        Select alternate font\nGL2 SB               Char        Scalable or bitmap fonts\nGL2 SD               Char        Standard font definition\nGL2 SI               Char        Absolute character size\nGL2 SL               Char        Character slant\nGL2 SR               Char        Relative character size\nGL2 SS               Char        Select standard font\nGL2 TD               Char        Transparent data\nGL2 MC               TechDraw    Merge control\nGL2 PP               TechDraw    Pixel placement\nGL2 PC               TechDraw    Pen color\nGL2 NP               TechDraw    Number of pens\nGL2 CR               TechDraw    Color range\n\n*---------------------------------------------------------------------*\n*  PCL/XL OPERANDS (zero or more precede each 'F8'x command indicator)*\n*---------------------------------------------------------------------*\n\nXLO 29                           comment terminated by LF\nXLO C0 xx                        1-byte value\nXLO C1 xxxx                      2-byte value\nXLO C2 xxxxxxxx                  4-byte value\nXLO C5 xxyyxxyy                  1-byte coord pair(x1,y1,x2,y2)\nXLO C8                           1-byte data units follow\nXLO CB                           2-byte data units follow\nXLO D0 wwhh                      1-byte dimension (w x h)\nXLO D1 wwwwhhhh                  2-byte dimension (w x h)\nXLO D3 xxxxyyyy                  2-byte coordinate (x,y)\nXLO D5 xxxxxxxxyyyyyyyy          2-byte coordinate\nXLO E3 xxxxyyyyxxxxyyyy          2-byte coordinate pair\nXLO EB xxyyzz                    3-byte triplet\nXLO FA xxxxxxxx                  4-byte length followed by data\nXLO FB xx                        1-byte length followed by data\n\n*---------------------------------------------------------------------*\n*  PCL/XL COMMANDS (following 'F8'x) ...and followed by modifier bytes*\n*---------------------------------------------------------------------*\n\nXLC 04                           SetFill (0=Off,1=On)\nXLC 05                           SetOutline (0=Off,1=On)\nXLC 06                           SetColorSpace\nXLC 09                           SetColor\nXLC 25                           SetPaperSize\nXLC 26                           SetPaperSource\nXLC 27                           SetPaperStock\nXLC 28                           SetOrientation (1=Ls,0=Pt)\nXLC 2A                           SetPageScale\nXLC 2B                           SetPageDimension\nXLC 31                           SetCopyCount\nXLC 42                           DrawRectangle\nXLC 45                           DrawLine\nXLC 48                           SetEllipse (0=Off,1=On)\nXLC 4B                           SetPenWidth\nXLC 4C                           SetCursorXY\nXLC 67                           SetImageSize\nXLC 6D                           ImageData\nXLC 89                           SetResolution\nXLC A1                           ResetTextBuffer\nXLC A8                           SetFont\nXLC AB                           SetText\nXLC AF                           SetTextWidths\n\n\n*---------------------------------------------------------------------*\n*  VARIABLES                                                          *\n*---------------------------------------------------------------------*\n\n* VPS fields...\nVAR &Banner   Contains either START or END or CONT\n\n* Job fields...\nVAR &JobID    Job number (eg JOBnnnnn or STCnnnnn)\nVAR &JobName  Job name\n\n* Printer fields...\nVAR &PrtMemb  Printer VPS definition member name\nVAR &PrtName  Printer name (luname, IP addr or hostname)\n\n* Report fields...\nVAR &RepClass Report sysout class\nVAR &RepCDate Report creation date (yyyy/mm/dd hh:mm:ss)\nVAR &RepDest  Report destination name\nVAR &RepPDate Report print date (yyyy/mm/dd hh:mm:ss)\n\n* Userid fields...\nVAR &Userid   User logon id\nVAR &UserName User name\n\n* OUTPUT statement fields...\nVAR &OutAddr1 OUTPUT card Address line 1\nVAR &OutAddr2 OUTPUT card Address line 2\nVAR &OutAddr3 OUTPUT card Address line 3\nVAR &OutAddr4 OUTPUT card Address line 4\nVAR &OutBuild OUTPUT card Building\nVAR &OutClass OUTPUT card Class\nVAR &OutDept  OUTPUT card Department\nVAR &OutDest  OUTPUT card Destination\nVAR &OutJesDS OUTPUT card JES Dataset type\nVAR &OutGroup OUTPUT card Output group\nVAR &OutName  OUTPUT card Name\nVAR &OutRoom  OUTPUT card Room\nVAR &OutTitle OUTPUT card Title\n\n*---------------------------------------------------------------------*\n*  END OF FILE (MUST BE INDICATED BY '//')                            *\n*---------------------------------------------------------------------*\n//\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VPSSEPX": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x01\\x01\"/\\x01\\x03\\x17\\x8f\\x14S\\x08\\xcd\\x08\\xa5\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2001-08-10T00:00:00", "modifydate": "2003-06-27T14:53:00", "lines": 2253, "newlines": 2213, "modlines": 0, "user": "FAJA"}, "text": "         MACRO\n&LABEL   VAR   &TYPE=CSECT,&LBL,&KEYWORD\n         LCLA  &LEN\n         AIF   ('&TYPE' EQ 'CSECT').CSECT\n.*--------------------------------------------------------------------*\n.*       Emit DSECT mapping Variable Name Table entry                 *\n.*--------------------------------------------------------------------*\n&LABEL   DSECT\nVTABNAME DS    CL8              Name of variable\nVTABNAML DS    H                Length of variable name\nVTABLA   DS    X'4120',S        Load Address instruction to point\nVTABVARL DS    H                Length of the variable value\nVTABENTL EQU   *-&LABEL         Length of a table entry\n         MEXIT\n.*--------------------------------------------------------------------*\n.*       Emit Variable Name Table entry                               *\n.*--------------------------------------------------------------------*\n.CSECT   ANOP\n         AIF   ('&LBL' EQ '').END\n&LEN     SETA  K'&KEYWORD-1\n&LABEL   DC    CL8'&KEYWORD',AL2(&LEN),X'4120',S(&LBL),AL2(L'&LBL)\n         MEXIT\n.END     ANOP\n         DC    X'FF'\n         MEND\nVPSSEP   TITLE 'VPS SEPARATOR PAGE ROUTINE'\n***********************************************************************\n*                                                                     *\n* VPSSEP v1.0 - VPS Dynamic Separator Page Printer                    *\n*                                                                     *\n* Copyright (C) 1998-2003 Andrew J. Armstrong                         *\n* a.armstrong@optusnet.com.au                                         *\n* HPO Computer Services Pty Ltd                                       *\n*                                                                     *\n* This program is free software; you can redistribute it and/or modify*\n* it under the terms of the GNU General Public License as published by*\n* the Free Software Foundation; either version 2 of the License, or   *\n* (at your option) any later version.                                 *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License for more details.                        *\n* You should have received a copy of the GNU General Public License   *\n* along with this program; if not, write to the Free Software         *\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307*\n*                                                                     *\n***********************************************************************\n***********************************************************************\n**                                                                   **\n** NAME     - VPSSEP                                                 **\n**                                                                   **\n** TITLE    - VPS SEPARATOR PAGE EXIT                                **\n**                                                                   **\n** FUNCTION - This exit prints separator pages.                      **\n**                                                                   **\n**            The separator page is retrieved from a member in a     **\n**            partitioned dataset identified by the SEPAR DD in the  **\n**            VPS started task JCL.  As the exit scans the member it **\n**            will substitute any variables (jobname, userid etc)    **\n**            with their current values before sending the resulting **\n**            datastream to the printer.                             **\n**                                                                   **\n**            The member name is specified on the DEVTYPE=member     **\n**            printer definition statement.                          **\n**                                                                   **\n**            For PCL and Postscript printers you should specify     **\n**            DEVTYPE=member.  The specified member will be read,    **\n**            scanned for variables and sent to the printer.         **\n**                                                                   **\n**            For other printers you should specify DEVTYPE=LINEMODE.**\n**            This will result in a separator page being printed in  **\n**            block letters similar to the JES separator page.       **\n**                                                                   **\n**            To suppress printing a separator page, you should      **\n**            specify DEVTYPE= or not code DEVTYPE at all.           **\n**                                                                   **\n**            The format of the separator page member is defined in  **\n**            the SYNTAX section below.                              **\n**                                                                   **\n**            Instructions on how to create a separator page member  **\n**            are in the NOTES section below.                        **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1.  HOW TO CREATE A SEPARATOR PAGE MEMBER              **\n**                                                                   **\n**                You can create the member manually using TSO/EDIT  **\n**                or you can speed up the process by using the       **\n**                following procedure:                               **\n**                                                                   **\n**                1.  Use a PC-based program such as MS Word to      **\n**                    create a mock-up banner page.                  **\n**                    Variables (for example, &userid) may appear in **\n**                    the mock-up (see SYNTAX below for a list of    **\n**                    variable names that you can use).              **\n**                    The advantage of doing this is that 'what you  **\n**                    see is what you get'.                          **\n**                                                                   **\n**                                                                   **\n**                2.  Select a PCL printer driver (for the printer   **\n**                    type on which the separator page is to be      **\n**                    printed) and print the mock-up to a file.      **\n**                                                                   **\n**                                                                   **\n**                3.  Upload the file to a mainframe partitioned     **\n**                    dataset called your.separ.cntl into a member   **\n**                    name of your choice.  Use a BINARY transfer    **\n**                    (that is, no ASCII to EBCDIC translation).     **\n**                    If using IND$FILE, ensure that ASCII and CRLF  **\n**                    options are NOT specified.  If using TCP/IP    **\n**                    FTP, specify BINARY before the GET or PUT.     **\n**                    your.separ.cntl must be RECFM VB and it should **\n**                    be LRECL 256.  Although bigger LRECLs can be   **\n**                    specified, the ISPF editor can easily run out  **\n**                    of memory if the LRECL is too big.             **\n**                                                                   **\n**                4.  Run the Rexx proc called VPSSEP, specifying    **\n**                    the input member name and, optionally, the     **\n**                    output member name.  If you dont specify the   **\n**                    output member name then the default name is    **\n**                    the input member name with a '$' suffix.       **\n**                                                                   **\n**                    For example: TSO VPSSEP HPLJ4 HPLJ4$           **\n**                                                                   **\n**                5.  Check that the output member looks OK - there  **\n**                    is always room to optimise the output from     **\n**                    the PCL print driver.  The following section   **\n**                    describes the syntax of the output file (ie    **\n**                    this file).                                    **\n**                    In particular, check that all of the variable  **\n**                    names (for example, &jobname) are not broken   **\n**                    across lines.  The PCL printer driver treats   **\n**                    these variable names as text and tries to kern **\n**                    the letters.  The result is that you may see   **\n**                    '&jobna', followed by a PCL command to adjust  **\n**                    the current cursor position, and then 'me',    **\n**                    instead of just '&jobname'.                    **\n**                                                                   **\n**                6.  Now that you have a clean editable version of  **\n**                    the binary separator page, you can delete the  **\n**                    binary version.  The VPS separator page exit   **\n**                    will be reading the editable version each time **\n**                    a separator page is to be printed.             **\n**                                                                   **\n**            2.  To get VPS to print this separator page for a      **\n**                particular printer, specify the following in that  **\n**                printer's printer definition member:               **\n**                                                                   **\n**                SEPAR=(S,VPSSEP,...)                               **\n**                DEVTYPE=membername                                 **\n**                                                                   **\n**                Where...                                           **\n**                                                                   **\n**                  SEPAR specifies the name of the VPS separator    **\n**                      page exit.                                   **\n**                                                                   **\n**                  DEVTYPE specifies the name of a member in        **\n**                      your.separ.cntl which contains the PCL       **\n**                      definition of the separator page for this    **\n**                      printer (different PCL printer types may     **\n**                      need to have different PCL data streams sent **\n**                      to them).  Omitting DEVTYPE causes no        **\n**                      separator pages to be printed.  Specifying   **\n**                      a member which does not exist will cause VPS **\n**                      to place the printer into EDRAINED status.   **\n**                      Specifiying DEVTYPE=LINEMODE causes the JES  **\n**                      block letter separators to be printed.       **\n**                      The DEVTYPE keyword is not used by any VPS   **\n**                      system code - it is soley for use by user    **\n**                      exits.                                       **\n**                                                                   **\n**            3.  You must also have the your.separ.cntl dataset     **\n**                allocated in the VPS started task with a DD name   **\n**                of SEPAR.  The separator page exit (VPSSEP) reads  **\n**                from the file allocated to the SEPAR DD name and   **\n**                expects it to be a PDS with RECFM=VB.  For example,**\n**                                                                   **\n**                //SEPAR DD DISP=SHR,DSN=your.separ.cntl            **\n**                                                                   **\n**                                                                   **\n**                                                                   **\n** SYNTAX   - The syntax of the file created by the VPSSEP Rexx      **\n**            procedure and read by the VPSSEP separator page exit   **\n**            is as follows:                                         **\n**                                                                   **\n**            Column 1 is a record type indicator.                   **\n**            Columns 2 to the maximum record length contain data    **\n**            specific to the record type.                           **\n**                                                                   **\n**            Col1 Usage                                             **\n**            ---- ------------------------------------------------  **\n**             *   Signifies a comment line.  The entire record is   **\n**                 ignored.                                          **\n**                                                                   **\n**             B   Signifies that the following text is binary data  **\n**                 that is to be appended to the data stream to be   **\n**                 sent to the printer.  This data is appended 'asis'**\n**                 ...it is not translated to ASCII.  Binary data is **\n**                 typically used to print a graphic (for example,   **\n**                 a company logo).                                  **\n**                                                                   **\n**             C   Signifies that the following text is binary data  **\n**                 and is to be appended to the data stream to be    **\n**                 sent to the printer 'as is' AFTER REMOVING THE    **\n**                 TRAILING X'FF'.  Apparently, MVS removes trailing **\n**                 blanks (X'40' code points) from each record before**\n**                 it is written to a RECFM=V partitioned dataset    **\n**                 member.  The C record is identical to the B       **\n**                 record except that the C record has X'FF' appended**\n**                 before it is written.  So, if a block of binary   **\n**                 data would end in X'40', a C record is written,   **\n**                 else a B record is written.                       **\n**                                                                   **\n**             E   Signifies that the following text is a PCL escape **\n**                 sequence (excluding the escape character). The    **\n**                 remaining text up to, but not including, the      **\n**                 first blank is translated to ASCII and appended   **\n**                 to the PCL escape character (X'1B').              **\n**                 The resulting escape sequence is appended to the  **\n**                 data stream to be sent to the printer.            **\n**                 Any characters after (and including) the first    **\n**                 blank are treated as comments and are ignored.    **\n**                                                                   **\n**             &   Signifies that the following text is the name of  **\n**                 a variable.                                       **\n**                 The current content of the variable is translated **\n**                 to ASCII and appended to the data stream. The     **\n**                 first blank after the & indicates the end of the  **\n**                 variable name.                                    **\n**                 Any characters after the first blank are treated  **\n**                 as comments and are ignored.                      **\n**                                                                   **\n**             Any other character in column 1 (including a blank)   **\n**             is the delimiter for the following text.  The text    **\n**             bounded by these delimiters is translated into ASCII  **\n**             and appended to the data stream to be sent to the     **\n**             printer.  Hence, if the text consists of a single     **\n**             word, then column 1 will be a blank and the word will **\n**             be terminated by the next blank.                      **\n**             For example,                                          **\n**                                                                   **\n**             Column 1                                              **\n**             |                                                     **\n**             V                                                     **\n**              text             ...comment...                       **\n**                                                                   **\n**             If the text contains embedded blanks, then column 1   **\n**             will be a single quote (') and the text will be term- **\n**             inated by another single quote.  For example:         **\n**                                                                   **\n**             'text containing embedded blanks' ...comment...       **\n**                                                                   **\n**             Any other delimiter may be chosen, so long as the     **\n**             delimiter character itself does not appear in the     **\n**             text.  The following examples are equivalent:         **\n**                                                                   **\n**              text             ...comment...                       **\n**             'text'            ...comment...                       **\n**             \"text\"            ...comment...                       **\n**             /text/            ...comment...                       **\n**             (text(            ...comment...                       **\n**                                                                   **\n**                                                                   **\n** SYNTAX                                                            **\n** NOTES    - 1.  Lines beginning with two blanks are ignored        **\n**                because blank is the delimiter and there is no     **\n**                text between the first and second blanks.          **\n**                                                                   **\n**            2.  Variable names are as follows:                     **\n**                                                                   **\n**                &BANNER   Contains either START or END or CONT     **\n**                &JOBID    Job number (eg JOBnnnnn or STCnnnnn)     **\n**                &JOBNAME  Job name                                 **\n**                &PRTMEMB  Printer VPS definition member name       **\n**                &PRTNAME  Printer name (luname, IP addr or hostname**\n**                &REPCLASS Report sysout class                      **\n**                &REPCDATE Report creation date (yyyy/mm/dd hh:mm:ss**\n**                &REPDEST  Report destination name                  **\n**                &REPPDATE Report print date (yyyy/mm/dd hh:mm:ss)  **\n**                &USERID   User user id                             **\n**                &USERNAME User full name (lastname, firstname)     **\n**                &OUTADDR1 Address line 1                           **\n**                &OUTADDR2 Address line 2                           **\n**                &OUTADDR3 Address line 3                           **\n**                &OUTADDR4 Address line 4                           **\n**                &OUTBUILD Building                                 **\n**                &OUTCLASS Class                                    **\n**                &OUTDEPT  Department                               **\n**                &OUTDEST  Destination                              **\n**                &OUTJESDS JES Dataset type (ALL,JCL,LOG or MSG)    **\n**                &OUTGROUP Output group                             **\n**                &OUTNAME  Name                                     **\n**                &OUTROOM  Room                                     **\n**                &OUTTITLE Title                                    **\n**                &OUTWTR   Writer name                      20000211**\n**                &FLASH    Flash overlay name               20010720**\n**                                                                   **\n**                The names are case-insensitive.  For example, the  **\n**                following names are all equivalent:                **\n**                                                                   **\n**                     &USERNAME                                     **\n**                     &username                                     **\n**                     &UserName                                     **\n**                                                                   **\n**                Other variables can be defined - but this          **\n**                requires changing the VPSSEP separator page exit   **\n**                and the VPSSEP Rexx procedure as well.             **\n**                                                                   **\n**            3.  Substrings of the variables can be specified       **\n**                with the following syntax:                         **\n**                                                                   **\n**                &varname(firstchar,numchars)                       **\n**                                                                   **\n**                For example, &REPCDATE(1,4) returns the first four **\n**                characters of the report creation date (ie yyyy).  **\n**                                                                   **\n**                If numchars is omitted then the remainder of the   **\n**                variable starting with firstchar is printed.       **\n**                                                                   **\n**                The syntax does not enforce the use of '(' or ','. **\n**                Any non-blank non-digit may be used to delimit the **\n**                firstchar and numchars values.  Parsing for values **\n**                stops at the first blank encountered.              **\n**                                                                   **\n**                For example, the following are all equivalent:     **\n**                                                                   **\n**                   &REPCDATE(1,4)                                  **\n**                   &REPCDATE=1:4                                   **\n**                   &REPCDATE-FROM-POSITION-1-FOR-4-CHARACTERS      **\n**                                                                   **\n**                This feature is useful when you only want a fixed  **\n**                number of characters printed for a variable.  The  **\n**                &username variable is a good candidate for trunc-  **\n**                ation since user names can be quite long.  To      **\n**                truncate the &username to, say, 20 characters, you **\n**                should specify: &username(1,20)                    **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R1  - Parameter list address                           **\n**            R14 - Return address                                   **\n**            R15 - Entry point address                              **\n**                                                                   **\n** ON EXIT  -                                                        **\n**                                                                   **\n** AUTHOR   - Andrew J. Armstrong <a.armstrong@optusnet.com.au>      **\n**                                                                   **\n** HISTORY - Date     By  Reason (most recent at the top please)     **\n**           -------- --- -----------------------------------------  **\n**           20030613 AJA Packaged for distribution via cbttape.org  **\n**           20030124 AJA Load unsigned max line length safely.      **\n**           20010810 AJA Added DCBE to allow a 31-bit EODAD to be   **\n**                        used. Otherwise reading until end-of-file  **\n**                        will cause a S0C4 (the workaround was to   **\n**                        stop reading when '//' was read).          **\n**           20010720 AJA Added FLASH variable and let DD writer name**\n**                        override the OUTPUT writer name.           **\n**           20000211 AJA Added OUTWTR variable and changed code to  **\n**                        use the new immediate/relative instructions.*\n**           19981011 AJA Allowed for ISPF editor hack: it will not  **\n**                        write an 8-byte record to a RECFM=V dataset.*\n**           19980409 AJA Enhanced to support Postscript printers.   **\n**                        Now, a separator will be sent to the       **\n**                        printer as long as DEVTYPE=member is       **\n**                        specified...regardless of whether the      **\n**                        printer supports PCL or not.  Also, if a   **\n**                        separator is required for a line-mode      **\n**                        printer (ie no PCL or Postscript support)  **\n**                        then specify DEVTYPE=LINEMODE.             **\n**           19971210 AJA Initial version.                           **\n**                                                                   **\n***********************************************************************\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*   REGISTER USAGE:                                                   *\n*                                                                     *\n*      ON ENTRY:                                                      *\n*         R0 ==>  REQUEST CODE.                                       *\n*                 00 - START-JOB SEPARATOR PAGE REQUEST               *\n*                 04 - END-JOB   SEPARATOR PAGE REQUEST               *\n*                 08 - CLEAN-UP  REQUEST                              *\n*                                                                     *\n*         R1 ==>  ADDRESS OF PARAMETER LIST.                          *\n*        R13 ==>  ADDRESS OF CALLERS SAVEAREA.                        *\n*        R14 ==>  RETURN ADDRESS.                                     *\n*        R15 ==>  ENTRY  ADDRESS.                                     *\n*                                                                     *\n*      DURING EXECUTION:                                              *\n*         R0 ==>  WORK REG.                                           *\n*         R1 ==>  WORK REG.                                           *\n*         R2 ==>  WORK REG.                                           *\n*         R3 ==>  WORK REG.                                           *\n*         R4 ==>  POINTER TO SYSTEM ATTRIBUTES.                       *\n*         R5 ==>  POINTER TO PRINTER ATTRIBUTES.                      *\n*         R6 ==>  POINTER TO JOB STATISTICS.                          *\n*         R7 ==>  POINTER TO USER AREA.                               *\n*         R8 ==>  POINTER TO LINE WORK AREA.                          *\n*         R9 ==>  POINTER TO SEPARATOR INFO AREA.                     *\n*        R10 ==>  WORK REG.\n*    R11-R12 ==>  VPSSEP BASE REGISTERS.\n*        R13 ==>  ADDRESS OF WORK AREA DSECT (INCLUDES SAVE AREA).    *\n*        R14 ==>  WORK REG.                                           *\n*        R15 ==>  WORK REG.                                           *\n*                                                                     *\n*      ON EXIT:                                                       *\n*         ALL REGISTERS WILL BE RESTORED TO ENTRY CONDITIONS, EXCEPT  *\n*      R15, WHICH WILL CONTAIN THE RETURN CODE.                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*   PARAMETER LIST FORMAT:                                            *\n*                                                                     *\n*      A(SYSTEM ATTRIBUTES)  - MAPPING MACRO: VPSSSYAT                *\n*      A(USER WORKAREA)      - MAPPING MACRO: N/A                     *\n*      A(PRINTER ATTRIBUTES) - MAPPING MACRO: VPSSPRAT                *\n*      A(JOB STATISTICS)     - MAPPING MACRO: VPSSJSTA                *\n*      A(SEPARATOR WORKAREA) - MAPPING MACRO: N/A                     *\n*      A(LINE WORKAREA)      - MAPPING MACRO: VPSSLINE                *\n*      A(SEPARATOR INFO)     - MAPPING MACRO: VPSSSEPI                *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   RETURN CODES:                                                     *\n*                                                                     *\n*     00 - SEPARATOR LINE AVAILABLE TO PRINT & CALL US AGAIN          *\n*     04 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *\n*     08 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *\n*     12 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *\n*     16 - DISASTROUS ERROR, NOTHING TO PRINT & DON'T CALL US AGAIN   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         R E G I S T E R S                           *\n*                                                                     *\n***********************************************************************\n\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           M A I N L I N E                           *\n*                                                                     *\n***********************************************************************\n\nVPSSEP   CSECT\n         GBLC  &SYSSPLV\n         SPLEVEL TEST\n         AIF   ('&SYSSPLV' EQ '1').UXIT000\nVPSSEP   AMODE ANY\nVPSSEP   RMODE ANY\n.UXIT000 ANOP\n         USING VPSSEP,R11,R12       ESTABLISH PROGRAM BASE\n*        --------------------\n         J     Start                BRANCH AROUND CONSTANTS.\n         DC    CL8'VPSSEP'          Module name\n         DC    CL8'&SYSDATC'        Assembly date (yyyymmdd)\n         DC    CL8'&SYSTIME'        Assembly time (hh:mm)\nStart    DS    0H\n         STM   R14,R12,12(R13)      SAVE CALLERS REGISTERS.\n         LR    R11,R15              LOAD 1ST PROGRAM BASE REGISTER.\n         LA    R12,2048(,R11)       LOAD 2ND...\n         LA    R12,2048(,R12)            PROGRAM BASE REGISTER.\n\n         LR    R2,R0                SAVE SEPARATOR REQUEST CODE.\n\n         L     R4,0(,R1)\n         LM    R5,R9,8(R1)\n\n         USING SYADSECT,R4        Map System Attributes\n*        -----------------\n         USING PRADSECT,R5        Map Printer Attributes\n*        -----------------\n         USING JSTDSECT,R6        Map Job Statistics\n*        -----------------\n         USING SEPUSER,R7         Map User Area\n*        ----------------\n         USING LINEDSCT,R8        Map Line Work Area\n*        -----------------\n         USING SEPDSECT,R9        Map Separator Info Area\n*        -----------------\n         USING WORKAREA,R10       Map Work Area (retained across calls)\n*        ------------------\n         USING SEPRDSCT,R13       Map Work Area (not retained)\n*        ------------------\n         EJECT\n*---------------------------------------------------------------------*\n*        Obtain a work area and clear it                              *\n*---------------------------------------------------------------------*\n\n         GETMAIN RU,LV=SEPRDSLN     ACQUIRE WORK AREA.\n\n         ST    R1,8(,R13)           FORWARD CHAIN SAVE AREAS.\n         ST    R13,4(,R1)           BACK CHAIN.\n         LR    R13,R1               LOAD WORK DSECT BASE REGISTER.\n\n         LA    R0,8(,R1)            RECEIVING FIELD FOR MVCL.\n         LA    R1,SEPRDSLN-8        RECEIVING FIELD LENGTH FOR MVCL.\n         SR    R14,R14              SENDING   FIELD FOR MVCL.\n         SR    R15,R15              SENDING   FIELD LENGTH FOR MVCL.\n         MVCL  R0,R14               INITIALIZE WORK AREA.\n\n*---------------------------------------------------------------------*\n*        Branch to appropriate routine based on the request code      *\n*---------------------------------------------------------------------*\n\n*=====================================================================*\n*                                                                     *\n*     00 - START-JOB SEPARATOR REQUEST                                *\n*     04 - END-JOB   SEPARATOR REQUEST                                *\n*     08 - CLEAN-UP  REQUEST - SOME TYPE OF ERROR HAS OCCURRED IN A   *\n*                    VPS TASK. THE SEPARATOR ROUTINE SHOULD CLOSE ANY *\n*                    OPEN FILES, FREE ANY ACQUIRED STORAGE, ETC.      *\n*                                                                     *\n*                    THIS SEPARATOR ROUTINE SIMPLY EXITS ON A         *\n*                    CLEAN-UP CALL SINCE IT OPENS NO FILES OR LEAVES  *\n*                    ANY STORAGE ACQUIRED ACROSS CALLS.               *\n*                                                                     *\n* SEPARATOR EXIT RETURN CODE (R15) MEANINGS:                          *\n*                                                                     *\n*     00 - SEPARATOR LINE AVAILABLE TO PRINT & CALL US AGAIN          *\n*     04 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *\n*     08 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *\n*     12 - NOTHING TO PRINT & DON'T CALL US AGAIN                     *\n*     16 - DISASTROUS ERROR, NOTHING TO PRINT & DON'T CALL US AGAIN   *\n*                                                                     *\n*---------------------------------------------------------------------*\n\n         MVC   nRetCode,=F'0'       ZERO OUT THE RETURN CODE\n         ST    R2,nRequest          SAVE THE REQUEST CODE\n\n         B     *+4(R2)              (00 = START-JOB, 04 = END-JOB).\n         J     StartJob             BRANCH TO START-JOB SEPARATOR.\n         J     StartJob             BRANCH TO END-JOB SEPARATOR\n         J     CleanUp              BRANCH TO CLEAN-UP.\n         EJECT\n***********************************************************************\n*                                                                     *\n*              START-JOB AND END-JOB SEPARATOR PROCESSING             *\n*                                                                     *\n***********************************************************************\n\n*---------------------------------------------------------------\n*        Obtain storage for a workarea if not already done\n*---------------------------------------------------------------\n\nStartJob DS    0H\n         L     R10,pWorkArea      -> Work area\n         LTR   R10,R10              Workarea obtained already?\n         JNZ   Primed               Yes, branch\n\n         STORAGE OBTAIN,LENGTH=WORKAREA#,LOC=BELOW,ADDR=(R10)\n         ST    R10,pWorkArea        Save workarea address\n\n*---------------------------------------------------------------------*\n*        Initialise work area variables                               *\n*---------------------------------------------------------------------*\n\n         ST    R5,pPRAT             -> VPSSPRAT\n\n         LA    R0,sVars             -> Target\n         LHI   R1,sVars#            L'Target\n         SLR   R14,R14              -> Source (not used)\n         SLR   R15,R15              L'Source (0 forces pad)\n         ICM   R15,B'1000',sBlanks  Pad byte is a blank\n         MVCL  R0,R14               Initialise variables to blanks\n\n         LA    R0,sRACFWork         -> Target\n         LHI   R1,L'sRACFWork       L'Target (pad in high order byte)\n         SLR   R14,R14              -> Source (not used)\n         SLR   R15,R15              L'Source (0 forces pad)\n*                                   Pad byte is a null\n         MVCL  R0,R14               Initialise variables to nulls\n\n*---------------------------------------------------------------------*\n*        Get userid                                                   *\n*---------------------------------------------------------------------*\n\n         L     R14,SEPXMA         -> XMA data from VPS exit 15\n         LTR   R14,R14            Is VPS exit 15 active?\n         JZ    FromJob            No, get userid from job name\n\n         USING XMADSECT,R14\n*        ------------------\n         MVC   sFlsh,XMAFLASH     Get flash overlay name       20010720\n         MVC   sOutW,XMAWTR       Get writer name from DD      20010720\n         MVC   sUsrI,XMAJOWNR     Get user id\n         L     R14,XMAORAT        -> OUTPUT card fields\n         DROP  R14\n*        ---------\n\n         LTR   R14,R14            Any OUTPUT card fields?\n         JZ    NoOutput           No, branch\n\n         USING ORADSECT,R14\n*        ------------------\n         MVC   sOut1,ORAADDR1     Get address line 1\n         MVC   sOut2,ORAADDR2     Get address line 2\n         MVC   sOut3,ORAADDR3     Get address line 3\n         MVC   sOut4,ORAADDR4     Get address line 4\n         MVC   sOutB,ORABLDG      Get building name\n         MVC   sOutC,ORACLS       Get class\n         MVC   sOutO,ORADEPT      Get department name\n         MVC   sOutD,ORADEST      Get destination name\n         MVC   sOutJ,ORAJESDS     Get JES dataset type\n         MVC   sOutG,ORAGRP       Get output group\n         MVC   sOutN,ORANAME      Get user name\n         MVC   sOutR,ORAROOM      Get room name\n         MVC   sOutT,ORATITLE     Get output title\n\n         CLC   sOutW,=XL8'00'     Writer specified on DD?      20010720\n         JNE   NoWriter           No, jump                     20010720\n         MVC   sOutW,ORAWTR       Get writer name              20000211\nNoWriter DS    0H                                              20010720\n\n         CLC   sFlsh,=XL8'00'     Flash overlay on DD?         20010720\n         JNE   NoFlash            No, jump                     20010720\n         MVC   sFlsh,ORAFLASH     Get flash name from OUTPUT   20010720\nNoFlash  DS    0H                                              20010720\n\n         DROP  R14\n*        ---------\n\nNoOutput DS    0H\n\n         MVC   sRACFUsr,sUsrI     Set userid for RACF\n         LHI   R14,L'sRACFUsr     Maximum userid length\n         LA    R15,sRACFUsr       -> Start of userid\nNextU    DS    0H\n         CLI   0(R15),C' '        Found first blank in userid?\n         JE    FoundU             Yes, branch\n         LA    R15,1(,R15)        -> next byte in userid\n         BRCT  R14,NextU          ...until end of userid\nFoundU   DS    0H\n\n         LHI   R15,L'sRACFUsr     Maximum userid length\n         SR    R15,R14            Compute actual length of userid\n         JNP   FromJob            ...get userid from job if length NBG\n\n         STC   R15,cRACFLen       Set length of userid for RACF\n         J     GotUser\n\n*---------------------------------------------------------------------*\n*        Get userid from job name (this is installation-specific)     *\n*---------------------------------------------------------------------*\n\nULEN     EQU   4    <- SET THIS TO THE INSTALLATION'S USERID LENGTH\n\nFromJob  DS    0H\n         MVC   sUsrI,JSTJOBNM     Get user id from job name\n         MVC   sUsrI+ULEN(L'sUsrI-ULEN),sBlanks\n         MVC   sRACFUsr,JSTJOBNM  Get user id from job name\n         MVI   cRACFLen,ULEN      Set user id length for SAF\n\n*---------------------------------------------------------------------*\n*        Create an ACEE for the userid                                *\n*---------------------------------------------------------------------*\n\nGotUser  DS    0H\n         MVC   sVerify(sVerify#),kVerify Copy plist to workarea\n\n         RACROUTE MF=(E,sVerify),                                      X\n               REQUEST=VERIFY,                                         X\n               ACEE=pACEE,        -> Accessor Control Element          X\n               ENVIR=CREATE,      Create ACEE                          X\n               USERID=sRACFUID,   -> AL1(len),CL(len)'userid'          X\n               PASSCHK=NO,        Do not verify the users password     X\n               WORKA=sRACFWork,   -> RACF workarea                     X\n               RELEASE=2.4\n\n         LTR   R15,R15            Did it work?\n         JNZ   RACFDone           No, branch\n\n*---------------------------------------------------------------------*\n*        Extract the user name field from the ACEE                    *\n*---------------------------------------------------------------------*\n\n         L     R3,pACEE\n         USING ACEE,R3\n*        -------------\n         L     R2,ACEEUNAM        ->AL1(len+1),CL(len)'user name'\n         DROP  R3\n*        --------\n         SLR   R3,R3\n         IC    R3,0(R2)           Get L'Programmer Name\n         BCTR  R3,*-*\n         LHI   R1,L'sUsrN         Get maximum length allowed\n         CR    R3,R1              Will extracted field fit in target?\n         JNL   UsrOK              Yes, branch\n         LR    R1,R3              No, truncate to size of target\nUsrOK    DS    0H\n\n         BCTR  R1,*-*             -1 for EX\n         LTR   R1,R1              Is length 0 or negative?\n         JM    ExtrDone           Yes, don't use it\n\nCopyUser MVC   sUsrN(*-*),1(R2)   Copy field to target\n         EX    R1,CopyUser\n\nExtrDone DS    0H\n\n*---------------------------------------------------------------------*\n*        Issue RACROUTE to delete the ACEE just created               *\n*---------------------------------------------------------------------*\n\n         MVC   sVerify(sVerify#),kVerify Copy plist to  workarea\n\n         RACROUTE MF=(E,sVerify),                                      X\n               REQUEST=VERIFY,                                         X\n               ACEE=pACEE,        -> Accessor Control Element          X\n               ENVIR=DELETE,      Delete ACEE                          X\n               WORKA=sRACFWork,   -> RACF workarea                     X\n               RELEASE=2.4\n\nRACFDone DS    0H\n\n*---------------------------------------------------------------------*\n*        Prime all system variables with their current values         *\n*---------------------------------------------------------------------*\n\nPrime    DS    0H\n         MVC   sBann,=CL5'START'\n         CLC   nRequest,=F'0'     Is this a start separator?\n         JE    BannerOK           Yes, branch\n         MVC   sBann,=CL5'END'\nBannerOK DS    0H\n\n         MVC   sJobI,JSTJOBID     Get job id\n         MVC   sJobN,JSTJOBNM     Get job name\n         MVC   sPrtM,PRAMNAME     Get printer member name\n\n         MVC   sPrtN(8),PRATNAME  Get LU name\n\n*----->  CLI   PRALUTYP,$PRALUT   Is this a TCP/IP printer?\n*----->  JNE   NameOK             No, branch\n\n         TM    PRADEVF4,$PRADLPD+$PRADSOK Is this a TCP/IP printer?\n*                       $PRADLPD = TCP/IP Line Printer Daemon (LPD)\n*                       $PRADSOK = TCP/IP Direct Sockets (port 9100)\n         JZ    NameOK             No, branch\n\n         MVC   sPrtN,PRATCPHS     Get IP address or hostname\n\nNameOK   DS    0H\n         MVC   sRepC,SEPCLASS     Get report class\n\n*                                 Get report spooled date...\n         MVC   sRepS,=C'yyyy/mm/dd hh:mm:ss day'\n         MVC   sRepS+00(04),JSTORDGC+4 yyyy\n         MVC   sRepS+05(02),JSTORDGC+0 mm\n         MVC   sRepS+08(02),JSTORDGC+2 dd\n         MVC   sRepS+11(02),JSTORTME+0 hh\n         MVC   sRepS+14(02),JSTORTME+2 mm\n         MVC   sRepS+17(02),JSTORTME+4 ss\n         MVC   sRepS+20(03),JSTORDAY   day\n\n         MVC   sRepD,SEPDEST      Get report destination\n\n*                                 Get report printed date...\n         MVC   sRepP,=C'yyyy/mm/dd hh:mm:ss day'\n         MVC   sRepP+00(04),JSTOPDGC+4 yyyy\n         MVC   sRepP+05(02),JSTOPDGC+0 mm\n         MVC   sRepP+08(02),JSTOPDGC+2 dd\n         MVC   sRepP+11(02),JSTOPTME+0 hh\n         MVC   sRepP+14(02),JSTOPTME+2 mm\n         MVC   sRepP+17(02),JSTOPTME+4 ss\n         MVC   sRepP+20(03),JSTOPDAY   day\n\n         MVC   sMember,sBlanks    Prime member name\n\n*---------------------------------------------------------------------*\n*        If this is a PCL printer, then build PCL buffer...           *\n*---------------------------------------------------------------------*\n\n         CLC   =CL8'LINEMODE',PRATDEVT Is a linemode printer?  19980409\n         JE    LineMode           Yes, no page-mode separator  19980409\n\n         XC    pPCL,pPCL          -> PCL buffer = 0\n\n*        Was DEVTYPE keyword specified?\n         CLI   PRATDEVT,0\n         JE    Primed             No, dont print a PCL separator\n\n         MVC   sDCBE(sDCBE#),kDCBE    Copy plist to work area  20010810\n         MVC   sFile(sFile#),kFile    Copy plist to work area\n         LA    R15,sDCBE              -> DCBE in work area     20010810\n         ST    R15,sFile              Make DCB point to DCBE   20010810\n         MVC   sOpen(sOpen#),kOpen    Copy plist to work area\n         MVC   sClose(sClose#),kClose Copy plist to work area\n\n*        Open partitioned dataset\n         OPEN  (sFile,INPUT),MF=(E,sOpen),MODE=31\n         LTR   R15,R15            Did it work?\n         JNZ   CloseFile          No, branch\n\n*        Extract member name from DEVTYPE keyword\n         MVC   sMember,PRATDEVT   Copy member name from DEVTYPE field\n\n*        find member\nFindIt   DS    0H\n         FIND  sFile,sMember,D\n         LTR   R15,R15            Member found?\n         JNZ   CloseFile          No, branch\n         J     FirstBlk           Yes, read first block of records\n\n         PUSH  USING\n         USING RECORD,R5\n*        ---------------\n*        Get next record\nNext     DS    0H\n         SLR   R1,R1\n         ICM   R1,B'0011',hRecLen Get length of current record\n         AR    R5,R1              -> Next record in block\n         C     R5,pBlockEnd       Processed last record in block?\n         JL    GotRec\n\nFirstBlk DS    0H\n         READ  sDECB,SF,sFile,sBlock,MF=E\n         CHECK sDECB\n\n         LA    R5,sBlock          -> X'LLBB',XL(LL)'block data'\n         SLR   R1,R1\n         ICM   R1,B'0011',hBlock  Get length of block\n         AR    R5,R1              -> Byte after end of block\n         ST    R5,pBlockEnd       -> Save for Next pass\n         LA    R5,sBlockData      -> First data record in block\n\n*        do while not eof\n*          select\n\nGotRec   DS    0H\n\n*---------------------------------------------------------------------*\n*        Process comment records (eg * This is a comment)             *\n*---------------------------------------------------------------------*\n\n*            when col1='*' then nop\n         CLC   hRecLen,=AL2(4+2)  At least 2 bytes of data?\n         JL    Next               No, branch\n\n         CLI   cRecType,C'*'      Is this a comment record?\n         JE    Next               Yes, branch\n\n*---------------------------------------------------------------------*\n*        Process PCL escape sequence records (eg E*t300r)             *\n*---------------------------------------------------------------------*\n\n*            when col1='E' then do\n         CLI   cRecType,C'E'      Is this a PCL ESCAPE record?\n         JNE   WhenBin            No, branch\n\n*              append x'1B'\n         MVI   cRecType,X'1B'     Change 'E' to real PCL escape char\n*              find first blank\n         LA    R1,sRecData        -> First byte after 'E'\n         SLR   R0,R0\n         ICM   R0,B'0011',hRecLen L'Record (including record type)\n         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type\n\nNext1    DS    0H\n         CLI   0(R1),C' '         End of PCL command?\n         JE    End1               Yes, branch\n\n         TR    0(1,R1),sToASCII   Translate byte to ASCII\n         LA    R1,1(,R1)          -> Next source byte\n         BRCT  R0,Next1           ...until source is exhausted\n\nEnd1     DS    0H\n         LA    R0,sRecData        -> PCL command operands\n         SR    R1,R0              L'PCL command operands\n\n*              append remaining record\n         LA    R0,1(,R1)          Length of PCL command (incl. X'1b')\n         LA    R1,cRecType        -> X'1b' followed by PCL command\n         BRAS  R14,Append\n*            end\n         J     Next\n\n\n\n*---------------------------------------------------------------------*\n*        Process binary data records (eg B...binary..data...)         *\n*---------------------------------------------------------------------*\n\n*            when col1='B' then do\nWhenBin  DS    0H\n         CLI   cRecType,C'B'      Is this a binary data record?\n         JNE   WhenBin2           No, branch\n*              append remaining record as is\n         LA    R1,sRecData        -> Binary data\n\n*                           cRecType=C'B'\n*                                  |\n*                         hRecLen  |sRecData\n*                              |   ||\n*                              --  VV\n*                            C'llbbtxxxxx........xx'\n*                              <----hRecLen------->\n*                                   <- hRecLen-5 ->\n\n         SLR   R0,R0\n         ICM   R0,B'0011',hRecLen L'Record (including record type)\n         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type byte\n\n*              If the binary data ends in a blank (x'40') then 19981110\n*              ignore the blank...any data which really does   19981110\n*              have a trailing blank should be represented     19981110\n*              by a type 'C' record which is terminated by a   19981110\n*              trailing x'FF' (see WhenBin2 below).            19981110\n         LA    R14,sRecData-1     -> Binary data - 1           19981110\n         ALR   R14,R0             -> Last byte of binary data  19981110\n         CLI   0(R14),X'40'       Trailing blank?              19981110\n         JNE   BinOK                                           19981110\n         BCTR  R0,*-*             Length of binary data - 1    19981110\nBinOK    DS    0H                                              19981110\n\n*              append remaining record as is\n         BRAS  R14,Append\n*            end\n         J     Next\n\n\n*---------------------------------------------------------------------*\n*        Process binary data records (eg C...binary..data...x'ff')    *\n*---------------------------------------------------------------------*\n\n*            when col1='C' then do\nWhenBin2 DS    0H\n         CLI   cRecType,C'C'      Is this a binary data record?\n         JNE   WhenVar            No, branch\n*              append remaining record as is\n         LA    R1,sRecData        -> Binary data\n         SLR   R0,R0\n         ICM   R0,B'0011',hRecLen L'Record (including record type)\n         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type byte\n         BCTR  R0,*-*             -1 to strip trailing x'ff'\n         BRAS  R14,Append\n*            end\n         J     Next\n\n\n\n*---------------------------------------------------------------------*\n*        Process variable name records (eg &JobName )                 *\n*---------------------------------------------------------------------*\n\n*            when col1='&' then do\nWhenVar  DS    0H\n         CLI   cRecType,C'&&'     Is this a variable name record?\n         JNE   Other              No, branch\n\n*              find varname in vartab\n         MVC   sVar,sRecData      Copy variable name for massaging\n         OC    sVar,sBlanks       Convert it to upper case\n         LA    R1,VARTAB          -> First entry in table\n         USING VARTABD,R1\n*        ----------------\n\nNext3    DS    0H\n         LH    R2,VTABNAML        No, get length of name from table\n         EX    R2,Check3          Variable name found?\n         JE    SubVar             Yes, branch\n         LA    R1,VTABENTL(,R1)   -> Next entry in table\n         CLI   VTABNAME,X'FF'     End of variable name table?\n         JNE   Next3              No, keep looking\n\n*              Input:  '&JUNKVARNAME Comments...'\n         MVC   sVar,cRecType      Copy variable name out of harms way\n         MVC   sRecData(L'sVar),sVar Now copy name back\n         MVI   cRecType,C' '      Insert a leading blank delimiter\n         MVI   sRecData+L'sVar,C' ' Insert a trailing blank delimiter\n*              Output: ' &JUNKVARNAME Comments...'\n         J     Other              ...print just '&JUNKVARNAME'\nCheck3   CLC   sVar(*-*),VTABNAME\n\n*              Get current value of varname into sVar...\nSubVar   DS    0H\n         LA    R2,X'20'           Nominate R2 to receive address\n         EX    R2,VTABLA          -> LA R2,xxx(0,y)  (current value)\n         MVC   sVar,0(R2)         Copy to a work area for translation\n         TR    sVar,sToASCII      Translate to ASCII\n         LH    R0,VTABVARL        L'String (from table entry)\n         STH   R0,hVarLen         Save for later\n         LH    R2,VTABNAML        Get length of name from table again\n         AHI   R2,1+1             +1, +1 to skip over '&' at front\n         DROP  R1\n*        --------\n\n*              Get first number (if any) before the first blank\n         LA    R1,cRecType        -> &varname(index,length) comment\n         AR    R1,R2                      -> (index,length) comment\n         SLR   R0,R0\n         ICM   R0,B'0011',hRecLen L'Record (including record type)\n         SR    R0,R2              Less L'&varname\n         BRAS  R14,c2b            Is substring index present?\n         JNZ   Full               No, append the full string\n         STH   R2,hSubBeg         Save substring start index\n\n*              Get next number (if any) before the first blank\n         BRAS  R14,c2b            Get substring length if present\n         STH   R2,hSubLen         Save substring length (or 0)\n\n         LA    R1,sVar            -> Full string\n         AH    R1,hSubBeg         -> Start of substring + 1\n         BCTR  R1,*-*             -> Start of substring\n\n         LH    R0,hSubLen         L'Substring\n         LTR   R0,R0              Was a substring length supplied?\n         JNZ   AppStr             Yes, append the substring\n\n         LH    R0,hVarLen         No, compute length of remainder\n         SH    R0,hSubBeg         L'remainder - 1\n         AHI   R0,1               L'remainder\n         J     NoTrail            Strip trailing blanks though\n\n*                append full value\nFull     DS    0H\n         LH    R0,hVarLen        L'String (from table entry)\n         LA    R1,sVar           -> String to append\n\nNoTrail  DS    0H                R1->String, R0=L'String\n         LR    R2,R1             ->String\n         LR    R3,R0             L'String\n         AR    R1,R0             -> Last byte of string + 1\nNextF    DS    0H\n         BCTR  R1,*-*            -> Previous byte\n         CLI   0(R1),X'20'       Is it a trailing (ASCII) blank?\n         JNE   FullDone          No, append string up to here\n         BRCT  R3,NextF          ...until no more chars to check\n         J     Next              ...string is all blank, so ignore it\n\nFullDone DS    0H\n         LR    R1,R2             -> Start of string to append\n         LR    R0,R3             L'String (sans trailing blanks)\n\n*                append substring of value\nAppStr   DS    0H\n         BRAS  R14,Append\n*              end\n*              else append varname /* for debugging */\n*            end\n         J     Next\n\n\n\n*---------------------------------------------------------------------*\n*        Process string records (eg 'Job Name:')                      *\n*---------------------------------------------------------------------*\n\n*            Otherwise do\nOther    DS    0H\n*              if length of data between the two delimiters is zero\n         CLC   cRecType(1),cRecType+1 Is it a null record? eg ''\n*              then ignore record\n         JE    Next\n\n*              find next occurrence of col1 char (the delimiter)\n         LA    R1,sRecData        -> First byte of string\n         SLR   R0,R0\n         ICM   R0,B'0011',hRecLen L'Record (including first delimiter)\n         AHI   R0,-(4+1)          -4 for LLBB, -1 for record type byte\n\nNext2    DS    0H\n         CLC   cRecType,0(R1)     End delimiter found?\n         JE    End2               Yes, branch\n\n         TR    0(1,R1),sToASCII   Translate byte to ASCII\n         LA    R1,1(,R1)          -> Next source byte\n         BRCT  R0,Next2           ...until source is exhausted\n\nEnd2     DS    0H\n         LA    R0,sRecData        -> String\n         SR    R1,R0              L'String\n         JNP   Next               Ignore delimiter by itself\n\n*              append remaining record\n         LR    R0,R1              L'String (excluding end delimiter)\n         LA    R1,sRecData        -> First byte of string\n         BRAS  R14,Append\n         J     Next\n*            end /* Otherwise */\n*          end /* select */\n*        end /* while not eof */\n\n         POP   USING\n\n*        Close separator member\nEOF      DS    0H\n         CLOSE (sFile),MF=(E,sClose),MODE=31\n         MVC   pPCLNext,pPCL      -> Next chunk to be printed\n         J     Primed\n\n*---------------------------------------------------------------------*\n*        Error reading PDS                                            *\n*---------------------------------------------------------------------*\n\nCloseFile DS   0H\n         CLOSE (sFile),MF=(E,sClose),MODE=31  Close PDS\n         J     SetRC16              ...and dont come back\n\n*---------------------------------------------------------------------*\n*        Work area has been obtained and filled in...                 *\n*---------------------------------------------------------------------*\n\nPrimed   DS    0H                 Work area is Primed\n         L     R5,pPRAT           -> VPSSPRAT\n\n*---------------------------------------------------------------------*\n*        Print the next item in the PCL data buffer                   *\n*---------------------------------------------------------------------*\n\n*        INPUT PCL DATA BUFFER FORMAT\n\n*             pPCL   pPCLNext     pPCLData                  pPCLMax\n*              |        |            |                            |\n*              v     ...v...         v                            v\n*             .--------------------------------------------------.\n* PCL buffer: |data to be printed...|                            |\n*             '--------------------------------------------------'\n*              <---- nPCLData ------>\n*              <--------------------- nPCL ---------------------->\n\n         CLC   pPCLNext,pPCLData  Anything left to print?\n         JNL   SetRC4             No, release storage; dont come back\n\n*        CLI   PRALUTYP,$PRALUT   Is this a TCP/IP printer?\n*        JE    TCP                Yes, branch\n         TM    PRADEVF4,$PRADLPD+$PRADSOK Is this a TCP/IP printer?\n*                       $PRADLPD = TCP/IP Line Printer Daemon (LPD)\n*                       $PRADSOK = TCP/IP Direct Sockets (port 9100)\n         JNZ   TCP                Yes, branch\n\n*---------------------------------------------------------------------*\n*        Build PCL chunk to be sent to an SNA printer...              *\n*---------------------------------------------------------------------*\n\n*        OUTPUT PCL CHUNK BUFFER FORMAT FOR SNA\n\n*        LINELNC (Carriage control byte which is ignored)\n*         | LINELND (SNA Transparency character)\n*         |  |  .---(SNA Transparency length byte)\n*         V  V  V\n*        .------------------------------------------------------.\n*        |CC|35|LL|         ...PCL Data Chunk...        |       |\n*        '------------------------------------------------------'\n*        <--------------------- LINELNL ---------------->\n*        <--------------------- LINELNLM ----------------------->\n\n*        Set VPS print line flags...\n         MVI   LINELNF,$LINECCP   Skip carriage control processing\n*                                 Line does not have carriage control\n         MVI   LINELNF2,$LINEBXL+$LINEBTU+$LINEBTB\n*                       $LINEBXL  Bypass translation...\n*                       $LINEBTU  Bypass standard truncation...\n*                       $LINEBTB  Bypass trailing blank truncation...\n\n*        Compute length of chunk...\n         SLR   R2,R2                                           20030124\n         ICM   R2,B'0011',LINELNLM  Max line length (incl. CC) 20030124\n         CLC   LINELNLM,=H'258'   Bigger than max SNA trans. seq?\n         JNH   NotMax             No, branch\n         LHI   R2,258             Yes, limit to 1+1+1+255 (for SNA)\nNotMax   DS    0H\n\n*        Build SNA transparency escape sequence...\n         MVI   LINELND,X'35'      SNA transparency character\n\n         L     R1,pPCLData        -> Next free byte in buffer\n         SL    R1,pPCLNext        -> Next chunk (=length remaining)\n         AHI   R2,-3              -1 for CC\n*                                 -1 for SNA transparency char\n*                                 -1 for length byte\n         CR    R2,R1              Print complete chunk?\n         JNH   SNAChunk           Yes, branch\n\n         LR    R2,R1              No, print residual\n\n*        Get next chunk to be printed...\nSNAChunk DS    0H\n         STC   R2,LINELND+1       SNA transparency length\n\n         LA    R0,LINELND+2       -> Target\n         LR    R1,R2              L'Target = L'Source\n         L     R14,pPCLNext       -> Source\n         LR    R15,R2             L'Source\n         MVCL  R0,R14             Copy source to target\n\n*        Point to the next source chunk...\n         L     R14,pPCLNext       -> This source chunk\n         AR    R14,R2             + L'chunk printed\n         ST    R14,pPCLNext       -> Next source chunk\n\n*        Set the line length for VPS...\n         AHI   R2,3               +3 for (CC, SNA esc, SNA length)\n         STH   R2,LINELNL         Set line length (incl. CC)\n\n         MVC   nRetCode,=F'0'     Print target and come back\n         J     Return\n\n*---------------------------------------------------------------------*\n*        Build PCL chunk to be sent to a TCPIP printer                *\n*---------------------------------------------------------------------*\n\n*        OUTPUT PCL CHUNK BUFFER FORMAT FOR TCP\n\n*        LINELNC (Carriage control byte which is ignored)\n*         | LINELND\n*         |  |\n*         V  V\n*        .------------------------------------------------------.\n*        |CC|             ...PCL Data Chunk...          |       |\n*        '------------------------------------------------------'\n*        <--------------------- LINELNL ---------------->\n*        <--------------------- LINELNLM ----------------------->\n\nTCP      DS    0H\n*        Set VPS print line flags...\n         MVI   LINELNF,$LINECCP   Skip carriage control processing\n*                                 Line does not have carriage control\n         MVI   LINELNF2,$LINEBXL+$LINEBTU+$LINEBTB\n*                       $LINEBXL  Bypass translation...\n*                       $LINEBTU  Bypass standard truncation...\n*                       $LINEBTB  Bypass trailing blank truncation...\n\n*        Compute length of chunk...\n         SLR   R2,R2                                           20030124\n         ICM   R2,B'0011',LINELNLM  Max line length (incl. CC) 20030124\n\n         L     R1,pPCLData        -> Next free byte in buffer\n         SL    R1,pPCLNext        -> Next chunk (=length remaining)\n         BCTR  R2,*-*             -1 for CC\n         CR    R2,R1              Print complete chunk?\n         JNH   TCPChunk           Yes, branch\n\n         LR    R2,R1              No, print residual\n\n*        Get next chunk to be printed...\nTCPChunk DS    0H\n         LA    R0,LINELND         -> Target\n         LR    R1,R2              L'Target = L'Source\n         L     R14,pPCLNext       -> Source\n         LR    R15,R2             L'Source\n         MVCL  R0,R14             Copy source to target\n\n*        Point to the next source chunk...\n         L     R14,pPCLNext       -> This source chunk\n         AR    R14,R2             + L'chunk printed\n         ST    R14,pPCLNext       -> Next source chunk\n\n*        Set the line length for VPS...\n         AHI   R2,1               +1 for CC\n         STH   R2,LINELNL         Set line length (incl. CC)\n\n         MVC   nRetCode,=F'0'     Print target and come back\n         J     Return\n\n***********************************************************************\n*                                                                     *\n*                         LINE-MODE PRINTERS                          *\n*                                                                     *\n***********************************************************************\n\nLineMode DS    0H\n         L     R10,pWorkArea      -> Workarea\n\n         LH    R1,hSepLine        Current separator line number\n         AHI   R1,1               +1\n         STH   R1,hSepLine        Update separator line number\n\n         LHI   R0,54              Maximum lines for separator\n         CR    R1,R0              Current line number greater than max?\n         JH    SetRC4             Yes, quit and dont return\n\n         LHI   R2,133               INITIALIZE LINE LENGTH TO 133.\n         STH   R2,LINELNL           STORE LENGTH IN LINE AREA.\n\n         MVI   WORKLNC,$ASSP        INITIALIZE ASA CHAR TO SINGLE SPACE\n         LA    R0,WORKLND           LOAD R0 W/ ADDR OF WORK LINE DATA.\n         LHI   R1,132               LOAD R1 W/ LEN  OF WORK LINE DATA.\n         SR    R14,R14              CLEAR R14.\n         L     R15,=A(X'40000000')  WE'LL PROPAGATE SPACES.\n         MVCL  R0,R14               CLEAR LINE DATA AREA.\n\n*---------------------------------------------------------------------*\n*        Determine which lines are being built                        *\n*---------------------------------------------------------------------*\n\n         CLC   hSepLine,=H'1'       Line 1?\n         JNE   Not1\n         MVI   cSepOffset,+11       Initialise centering offset\n\nNot1     DS    0H\n         CLC   hSepLine,=H'12'      Lines  1 - 12?\n         JNH   BLK#JOB              Yes, job name\n\n         CLC   hSepLine,=H'15'      Lines 13 - 15?\n         JNH   SetRC0               Yes, blank\n\n         CLC   hSepLine,=H'27'      Line 27?\n         JNE   Not27\n         MVI   cSepOffset,+11       Initialise centering offset\n\nNot27    DS    0H\n         CLC   hSepLine,=H'27'      Lines 16 - 27?\n         JNH   BLK#ID               Yes, job id and class\n\n         CLC   hSepLine,=H'30'      Lines 28 - 30?\n         JNH   SetRC0               Yes, blank\n\n         CLC   hSepLine,=H'42'      Lines 31 - 42?\n         JNH   BLK#015              Yes, blank\n\n         CLC   hSepLine,=H'44'      Lines 43 - 44?\n         JNH   SetRC0               Yes, blank\n         J     BLK#015              No, blank lines 45+\n\nBLK#015  EQU   *\n         CLC   hSepLine,=H'51'      Lines 43 - 51?\n         JNH   SetRC0               Yes, blank line\n         CLC   hSepLine,=H'52'      Line 52?\n         JNH   BLK#200              Yes, print last line\n         J     SetRC4               Exit and dont come back\n\n         EJECT\n*---------------------------------------------------------------------*\n*        Set up block letters for Job id and Sysout class             *\n*---------------------------------------------------------------------*\n\nBLK#ID   DS    0H\n         L     R10,pWorkArea        Address workarea\n         MVC   sAsIs(1),sJobI       SAVE THE 1ST POSITION OF JOB ID\n         MVC   sAsIs+1(5),sJobI+3   SAVE THE DIGITS OF JOB ID\n         MVI   sAsIs+6,X'40'        MOVE IN ONE BLANK\n         MVC   sAsIs+7(1),sRepC     SAVE THE SYSOUT CLASS\n         MVC   sTrans,sAsIs         SAVE JOB ID/CLASS FOR TRANSLATION\n         OC    sTrans,=8X'C0'       TURN ON 2 HIGH-ORDER BITS\n         TR    sTrans,INDEXTAB-192 TRANSLATE TO INDEX VALUE\n         MVI   bSlant,C'N'\n         MVI   bCentre,C'Y'\n         LA    R2,WORKLND           START AT 1ST PRINT POSITION.      *\n         J     CHKCENTR             GO FORM THE BLOCK LETTERS.\n         EJECT\n*---------------------------------------------------------------------*\n*        Set up block letters for job name                            *\n*---------------------------------------------------------------------*\n\nBLK#JOB  DS    0H\n         CLC   hSepLine,=H'1'       IS THIS THE FIRST LINE?\n         JNE   BLK#JOBA             NO, BRANCH AROUND NEXT INST\n         MVI   WORKLNC,$ACH1        SKIP TO CHANNEL-1 ASA CHARACTER.\n\nBLK#JOBA DS    0H\n         MVC   sAsIs,sJobN          SAVE THE JOB NAME\n         MVC   sTrans,sJobN         SAVE THE JOB NAME FOR TRANSLATION\n         OC    sTrans,=8X'C0'       TURN ON 2 HIGH-ORDER BITS\n         TR    sTrans,INDEXTAB-192 TRANSLATE TO INDEX VALUE\n\n         MVI   bSlant,C'Y'\n         MVI   bCentre,C'Y'\n         LA    R2,WORKLND           START AT 1ST PRINT POSITION\n         J     CHKCENTR             GO FORM THE BLOCK LETTERS.\n\n*---------------------------------------------------------------\n*        Check if text is to be centred\n*---------------------------------------------------------------\n\nCHKCENTR DS    0H\n         CLI   bCentre,C'Y'\n         JNE   CHKSLANT\n         LHI   R1,7                 SET R1 TO LENGTH OF FIELD - 1\n\nBLK#110  EQU   *\n         LA    R15,sAsIs(R1)        POINT R15 TO LAST CHARACTER\n         CLI   0(R15),C' '          IS THIS CHARACTER BLANK?\n         JNE   BLK#115              NO, WE HAVE THE LENGTH\n         BRCT  R1,BLK#110           DECREMENT R1 AND CHECK AGAIN\n\nBLK#115  EQU   *\n         AHI   R1,1                 BUMP R1 BY 1 TO GET ACTUAL # BYTES\n\n         MHI   R1,14                MULTIPLY BY # POSITIONS IN 1 LETTER\n         LHI   R15,132              PUT MAX VALUE INTO R15\n         SR    R15,R1               SUBTRACT OCCUPIED SPACE\n         SRL   R15,1                DIVIDE BY 2\n         LA    R2,WORKLND(R15)      POINT R2 TO STARTING POSITION\n\n*---------------------------------------------------------------\n*        Check if text is to be slanted\n*---------------------------------------------------------------\n\nCHKSLANT DS    0H\n         CLI   bSlant,C'Y'          Slant text?\n         JNE   OFFSET0              No, branch\n\n         SLR   R1,R1\n         IC    R1,cSepOffset        R1 = Column offset to be applied\n         AR    R2,R1                R2 = Start + Offset\n         BCTR  R1,*-*               Decrement offset\n         LTR   R1,R1                Gone negative?\n         JM    OFFSET0              Yes, leave it at zero\n         STC   R1,cSepOffset        No, save for next line\nOFFSET0  DS    0H\n\n*---------------------------------------------------------------------*\n*        Build block letters                                          *\n*---------------------------------------------------------------------*\n\nBLK#140  EQU   *\n         MVC   hCharNo,=H'0'        SET CHARACTER COUNTER TO ZERO\n\nBLK#145  EQU   *\n         LH    R15,hCharNo          PUT CHARACTER COUNTER VALUE IN R15\n         LA    R3,sAsIs(R15)        POINT R3 TO APPROPRIATE CHARACTER\n         MVC   cSaved(1),0(R3)      SAVE THAT CHARACTER FOR MOVES\n\n         CLI   cSaved,C'.'          Is it a fullstop?\n         JE    BLK#145A             Yes, replace with '*'\n         CLI   cSaved,C','          Is it a comma?\n         JNE   BLK#145B             No, branch\nBLK#145A DS    0H\n         MVI   cSaved,C'*'          Use '*' to make it show up\nBLK#145B DS    0H\n         LA    R3,sTrans(R15)       POINT R3 TO INDEX CHARACTER\n         SLR   R15,R15              CLEAR R15\n         ICM   R15,B'0001',0(R3)    PUT INDEX CHARACTER INTO R15\n         JZ    BLK#175              IF ZERO, GO DIRECTLY TO MOVE\n\n         BCTR  R15,*-*              MAKE IT RELATIVE TO ZERO\n         MHI   R15,24               MULTIPLY BY LENGTH OF ONE ENTRY\n         LH    R3,hSepLine          PUT LINE NUMBER IN R3\n         BCTR  R3,*-*               SUBTRACT 1\n\n         CLC   hSepLine,=H'13'      ARE WE WORKING ON JOB NAME?\n         JL    BLK#150              YES, USE LINE NUMBER AS IS\n\n         AHI   R3,-15               MAKE IT RELATIVE TO LINE 1\n         CHI   R3,15                Are we working on 3rd row?\n         JL    BLK#150              No, use line number as is\n         AHI   R3,-15               Make it relative to line 1\n\nBLK#150  EQU   *\n         SLL   R3,1                 MULTIPLY BY 2\n         AR    R15,R3               BUMP TO CORRECT LINE NUMBER\n         LA    R15,WIDEA(R15)       POINT R15 TO APPROPRIATE BITS\n         ICM   R15,B'1100',0(R15)   PUT BITS INTO R15\n\nBLK#175  EQU   *\n         LHI   R1,12                PUT WIDTH OF BLOCK LETTER IN R1\n\nBLK#185  EQU   *\n         ALR   R15,R15              ADD R15 TO ITSELF\n         BRC   12,BLK#190           HIGH-ORDER BIT WAS OFF, SKIP MOVE\n         MVC   0(1,R2),cSaved       MOVE IN SAVED CHARACTER\n\nBLK#190  EQU   *\n         LA    R2,1(,R2)            BUMP POINTER TO NEXT PRINT POSITION\n         BRCT  R1,BLK#185           CONTINUE UNTIL LETTER IS BUILT\n\n         LA    R2,2(,R2)            TWO SPACES BETWEEN LETTERS\n\n         LH    R15,hCharNo          PUT CHARACTER COUNTER INTO R15\n         AHI   R15,1                BUMP R15 BY 1\n         STH   R15,hCharNo          PUT RESULT BACK INTO CHAR COUNTER\n\n         CH    R15,=H'8'            HAVE WE MOVED ALL CHARACTERS?\n         JL    BLK#145              NO, GO THROUGH PROCESS AGAIN\n\n         J     SetRC0               -EXIT.\n\n*---------------------------------------------------------------------*\n*        Move in the data which is the same for start and end         *\n*---------------------------------------------------------------------*\n\nBLK#200  EQU   *\n         MVI   WASTER1,C'*'\n         MVC   WCLASS1,sRepC                MOVE IN SYSOUT CLASS\n         MVC   WJOBID1,sJobI                MOVE IN JOB ID\n         MVC   WJOBNAME,sJobN               MOVE IN JOB NAME\n         MVC   WDEST,sRepD                  MOVE IN JOB DEST\n         MVC   WNAME,sUsrN        User's name\n         MVC   WJOBID2,sJobI                MOVE IN JOB ID\n         MVC   WCLASS2,sRepC                MOVE IN SYSOUT CLASS\n         MVI   WASTER2,C'*'\n\n\n         CLC   nRequest,=F'0'               IS THE REQUEST FOR START?\n         JNE   BLK#END                      NO, GO MOVE IN END DATA\n\n*---------------------------------------------------------------------*\n*        Move in the data which is unique to START separators         *\n*---------------------------------------------------------------------*\n\nBLK#BEG  DS    0H\n         TM    SEPFLAG1,$SEPINTR            INTERRUPTED DATASET?\n         JZ    BLK#212                      NO, GO MOVE IN \"START\"\n\n         MVC   WSTATUS1,=CL5'CONT '         CONT INDICATOR\n         MVC   WSTATUS2,WSTATUS1            CONT INDICATOR\n         J     BLK#214                      GO MOVE IN OTHER INFO\n\nBLK#212  DS    0H\n         MVC   WSTATUS1,=CL5'START'         START INDICATOR\n         MVC   WSTATUS2,WSTATUS1            START INDICATOR\n\nBLK#214  DS    0H\n         MVC   WDATE,sRepP\n         J     SetRC0               -EXIT.\n\n*---------------------------------------------------------------------*\n*        Move in the data which is unique to END separators           *\n*---------------------------------------------------------------------*\n\nBLK#END  DS    0H\n         MVC   WSTATUS1,=CL5'END'           \"END\" INDICATOR\n         MVC   WSTATUS2,WSTATUS1            \"END\" INDICATOR\n         MVC   WDATE,sRepP\n         J     SetRC0               -EXIT.\n         EJECT\n*---------------------------------------------------------------------*\n*        Exit from separator routine                                  *\n*---------------------------------------------------------------------*\n\n* Appropriate return code must be set:\n*       00 = Print separator line that has been built and come back\n*       04 = Processing complete, don't come back\n*       16 = Disastrous error, EDRAIN printer, don't come back\n\nSetRC16  DS    0H\n         MVC   nRetCode,=F'16'    Disastrous error.  EDRAIN printer\n         J     Release\n\nSetRC4   DS    0H\n         MVC   nRetCode,=F'4'     Dont print and dont come back\n         J     Reset\n\nSetRC0   DS    0H\n         MVC   nRetCode,=F'0'     Print and come back\n\n         CLC   LINELNL,LINELNLM   IS LINE LONGER THAN MAX ALLOWED?\n         JNH   NoTrunc            NO, GO MOVE FULL LINE.\n         MVC   LINELNL,LINELNLM   TRUNCATE LENGTH TO MAX ALLOWED.\nNoTrunc  DS    0H\n\n         LA    R0,LINELNC         -> Target\n         SLR   R1,R1\n         ICM   R1,B'0011',LINELNL L'Target\n         LA    R14,WORKLINE       -> Source\n         LR    R15,R1             L'Source = L'Target\n         MVCL  R0,R14             Copy source to target\n         J     Return\n\nCleanUp  DS    0H                 Reset line number and exit\nReset    DS    0H\n         XC    hSepLine,hSepLine  RESET SEPARATOR LINE NO.\n\nRelease  DS    0H\n         L     R10,pWorkArea      -> Workarea to be released\n         LTR   R10,R10              Is it zero?\n         JZ    Return               Yes, dont try to release it\n\n         L     R1,pPCL            -> PCL buffer\n         LTR   R1,R1\n         JZ    RelWork\n\n         L     R0,nPCL            L'PCL buffer\n         STORAGE RELEASE,LENGTH=(R0),ADDR=(R1)\n\nRelWork  DS    0H\n         STORAGE RELEASE,LENGTH=WORKAREA#,ADDR=(R10)\n         XC    pWorkArea,pWorkArea  Zero workarea address\n         J     Return\n\nReturn   DS    0H\n         L     R2,nRetCode        SAVE RETURN CODE IN R2.\n         LR    R1,R13             ADDRESS OF AREA TO RELEASE.\n         L     R13,4(,R13)        ADDRESS OF CALLERS SAVEAREA.\n         ST    R2,16(R13)         SET RETURN CODE.\n\n         FREEMAIN RU,LV=SEPRDSLN,A=(1)  FREE WORK AREA.\n\n         LM    R14,R12,12(R13)    RESTORE CALLERS REGISTERS.\n         BR    R14                RETURN TO VPS.\n\n*=========================== END OF ROUTINE ==========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Appends the specified data to the PCL buffer.          **\n**            Automatically allocates the PCL buffer if it is not    **\n**            already allocated.  Automatically inflates the PCL     **\n**            buffer if it is not big enough to hold the new data.   **\n**            Automatically prangs if it is all too much.            **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R1 -> Data to be appended to PCL buffer                **\n**            R0  = Length of data to be appended                    **\n**                                                                   **\n**            pPCL     pPCLNext   pPCLData                  pPCLMax  **\n**             |          |          |                            |  **\n**             v       ...v...       v                            v  **\n**            .--------------------------------------------------.   **\n**            |xxxxxxxxxxxxxxxxxxxxx|                            |   **\n**            '--------------------------------------------------'   **\n**             <---- nPCLData ------>                                **\n**             <--------------------- nPCL ---------------------->   **\n**                                                                   **\n**            pPCL     -> PCL buffer                                 **\n**            nPCL     = Length of PCL buffer                        **\n**            pPCLMax  -> Byte after PCL buffer                      **\n**            nPCLData = Length of data in PCL buffer                **\n**            pPCLData -> Next free byte in PCL buffer               **\n**            pPCLNext -> Next chunk to print                        **\n**                                                                   **\n**                                                                   **\n** ON EXIT  - Data appended and pointers/lengths updated.            **\n**                                                                   **\n***********************************************************************\n\nAppend   DS    0H\n         STM   R0,R15,nRegs\n\n         CLC   pPCL,=A(0)           Do we have a buffer?\n         JNE   AppData              Yes, branch to append to it\n\n         XC    nPCLData,nPCLData    No, set PCL data length = 0\n         LHI   R0,2048              Initial length of PCL buffer\n         J     AppObt               Obtain initial buffer\n\n*---------------------------------------------------------------------*\n*        Inflate the size of the existing PCL buffer                  *\n*---------------------------------------------------------------------*\n\nAppNew   DS    0H\n*        Compute length of new buffer\n         L     R0,nPCL              Get current buffer length\n         AR    R0,R0                Double it\n\n*---------------------------------------------------------------------*\n*        Obtain a new buffer (length specified by R0)                 *\n*---------------------------------------------------------------------*\n\nAppObt   DS    0H\n         LR    R6,R0                Save length of new buffer\n         STORAGE OBTAIN,LENGTH=(6),LOC=BELOW,ADDR=(1)\n         LTR   R15,R15              Did it work?\n         JZ    AppGot               Yes, branch\n         LM    R0,R15,nRegs         No, restore registers\n         J     CloseFile            ...and exit stage left\n\nAppGot   DS    0H\n         LR    R7,R1                Save address of new buffer\n\n*        Check whether we have an old buffer to copy\n         L     R4,pPCL              ->Source (old buffer)\n         LTR   R4,R4                Do we have an old buffer?\n         JZ    AppUpd               No, dont copy or release it\n\n*        Copy the old buffer to the new buffer\n         LR    R2,R1                ->Target (new buffer)\n         L     R3,nPCL              L'Target = L'Source\n         LR    R5,R3                L'Source\n         MVCL  R2,R4                Copy old buffer to new buffer\n\n*        Release the old buffer\n         L     R0,nPCL\n         L     R1,pPCL\n         STORAGE RELEASE,LENGTH=(0),ADDR=(1)  Release old buffer\n\n*        Update pointers\nAppUpd   DS    0H\n         ST    R7,pPCL              -> PCL buffer\n         ST    R6,nPCL              L'PCL buffer\n\n         AR    R7,R6                -> PCL buffer + L'PCL buffer\n         ST    R7,pPCLMax           -> Byte after end of buffer\n\n         L     R7,pPCL              -> PCL buffer\n         AL    R7,nPCLData          + L'Data in the buffer\n         ST    R7,pPCLData          -> Next free byte in PCL buffer\n\n*---------------------------------------------------------------------*\n*        Append data to the PCL buffer                                *\n*---------------------------------------------------------------------*\n\nAppData  DS    0H\n         L     R3,nRegs+0         L'Source (R0 on entry)\n         L     R2,nRegs+4         ->Source (R1 on entry)\n         L     R1,pPCLData        ->Target\n         AR    R1,R3              ->Target+L'Source\n         C     R1,pPCLMax         Buffer too small?\n         JH    AppNew             Yes, inflate it\n\n         L     R4,nPCLData        Get L'data in buffer\n         AR    R4,R3              Add L'data to be appended\n         ST    R4,nPCLData        Save updated length\n\n         L     R4,pPCLData        ->Target\n         LR    R5,R3              L'Target = L'Source\n         MVCL  R4,R2              Append source to PCL buffer\n\n         ST    R4,pPCLData        ->Next free byte in PCL buffer\n\n*---------------------------------------------------------------------*\n*        Return                                                       *\n*---------------------------------------------------------------------*\n\n         LM    R0,R15,nRegs\n         BR    R14\n\n*=========================== END OF ROUTINE ==========================*\n         EJECT\n***********************************************************************\n**                                                                   **\n** FUNCTION - Convert first number found in the source field to      **\n**            binary and return it in R2.  Sets the condition code   **\n**            to indicate whether a number was found or not.         **\n**                                                                   **\n**                                                                   **\n** ON ENTRY - R0  =  Length of remaining data to scan                **\n**            R1  -> Start of data to scan                           **\n**            R14 = Return address                                   **\n**                                                                   **\n** ON EXIT  - R0  =  Length of remaining data to scan                **\n**            R1  -> Start of remaining data to scan                 **\n**            R2  =  Binary value of first number found (if CC = 0)  **\n**                =  Zero (if CC <> 0)                               **\n**                                                                   **\n***********************************************************************\n\nc2b      DS    0H\n         STM   R3,R5,nReg3to5\n\n*---------------------------------------------------------------------*\n*        Skip any leading non-numerics...                             *\n*---------------------------------------------------------------------*\n\n         BCTR  R1,*-*             -> Source text - 1\n\nc2bLBL   DS    0H\n         LA    R1,1(,R1)          -> Next source byte\n         CLI   0(R1),C' '         End-of-data found?\n         JE    c2bNBG             Yes, no number found\n         CLI   0(R1),C'1'         Is digit < C'1'?\n         JL    c2bSkip            Yes, skip it (includes zeros)\n         CLI   0(R1),C'9'         Is digit > C'9'?\n         JNH   c2bFirst           Yes, process first non-zero digit\nc2bSkip  DS    0H\n         BRCT  R0,c2bLBL          No, skip it...\n         J     c2bNBG             ...unless all are non-numerics\n\nc2bFirst DS    0H\n         SLR   R4,R4              Count of digits found = 0\n         LR    R5,R1              -> First numeric character\n         J     c2bDigit\n\n*---------------------------------------------------------------------*\n*        Ensure following characters are decimal digits               *\n*---------------------------------------------------------------------*\n\nc2bNext  DS    0H\n         LA    R1,1(,R1)          -> Next source byte\n         CLI   0(R1),C' '         Terminating blank?\n         JE    c2bDig             Yes, branch\n\nc2bDigit DS    0H\n         CLI   0(R1),C'0'         Is digit < C'0'?\n         JL    c2bDig             Yes, branch\n         CLI   0(R1),C'9'         Is digit > C'9'?\n         JH    c2bDig             Yes, branch\n         AHI   R4,1               Increment digit count\n         BRCT  R0,c2bNext         Continue checking until...\n         J     c2bDig             ...all characters are digits\n\n*---------------------------------------------------------------------*\n*        Convert source string to packed decimal                      *\n*---------------------------------------------------------------------*\n\nc2bDig   DS    0H\n         CL    R4,=F'10'          Is it longer than 10 digits?\n         JH    c2bNBG             Yes, invalid number\n\n         BCTR  R4,*-*             -1 for EX\nc2bPack  PACK  dWork,0(*-*,R5)\n         EX    R4,c2bPack         Convert source to packed decimal\n\n*---------------------------------------------------------------------*\n*        Check that it is between -2147483648 and +2147483647         *\n*---------------------------------------------------------------------*\n\nc2bPos   DS    0H\n         CP    dWork,=P'2147483647' Is number too positive?\n         JH    c2bNBG             Yes, branch\n\n         CVB   R2,dWork           Convert packed decimal to binary\n         J     c2bOK\n\n*---------------------------------------------------------------------*\n*        Set condition code 1.  Number is invalid.  R1 = 0            *\n*---------------------------------------------------------------------*\n\nc2bNBG   DS    0H\n         LM    R3,R5,nReg3to5\n         SLR   R2,R2              Number = 0\n         CLI   *,0                Set condition code 1\n         BR    R14\n\n*---------------------------------------------------------------------*\n*        Set condition code 0.  Number is valid.    R1 = number       *\n*---------------------------------------------------------------------*\n\nc2bOK    DS    0H\n         LM    R3,R5,nReg3to5\n         CLI   *+1,0              Set condition code 0\n         BR    R14\n\n*=========================== END OF ROUTINE ==========================*\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           L I T E R A L S                           *\n*                                                                     *\n***********************************************************************\n\n         LTORG ,\n\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          C O N S T A N T S                          *\n*                                                                     *\n***********************************************************************\n\n\n*---------------------------------------------------------------------*\n*        Skeletons to be copied to WORKAREA before use                *\n*---------------------------------------------------------------------*\n\nkVerify  RACROUTE MF=L,            Parameter list for RACROUTE         X\n               REQUEST=VERIFY,                                         X\n               RELEASE=2.4\n\n         DS    0D\nkFile    DCB   DDNAME=SEPAR,                                           X\n               DSORG=PO,                                               X\n               RECFM=VB,                                               X\n               LRECL=sBlock#-4,   See below                            X\n               MACRF=(R),                                              X\n               BLKSIZE=sBlock#,   See below                            X\n               DCBE=kDCBE,                                     20010810X\n               KEYLEN=0\n\nkDCBE    DCBE  EODAD=EOF                                       20010810\n\nkOpen    OPEN  (kFile,INPUT),MODE=31,MF=L\n\nkClose   CLOSE (kFile),MODE=31,MF=L\n\n*---------------------------------------------------------------------*\n*        Miscellaneous constants                                      *\n*---------------------------------------------------------------------*\n\nsBlanks  DC    CL(L'sVar)' '\n\n*---------------------------------------------------------------------*\n*        Translation tables for block letters                         *\n*---------------------------------------------------------------------*\n\nINDEXTAB DS    0D\n*                C0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'00010203040506070809002800000000'   A-I .\n         DC    X'000A0B0C0D0E0F101112001300000000'   J-R $\n         DC    X'00001415161718191A1B002900000000'   S-Z ,\n         DC    X'1C1D1E1F202122232425002627000000'   0-9 # @\n\nWIDEA    DC    X'7FE0FFF0C030C030C030FFF0FFF0C030C030C030C030C030'\nWIDEB    DC    X'FFE0FFF0C030C030C060FFC0FFC0C060C030C030FFF0FFE0'\nWIDEC    DC    X'7FE0FFF0C030C000C000C000C000C000C000C030FFF07FE0'\nWIDED    DC    X'FF80FFC0C060C030C030C030C030C030C030C060FFC0FF80'\nWIDEE    DC    X'FFF0FFF0C000C000C000FF00FF00C000C000C000FFF0FFF0'\nWIDEF    DC    X'FFF0FFF0C000C000C000FF00FF00C000C000C000C000C000'\nWIDEG    DC    X'7FE0FFF0C030C000C000C000C1F0C1F0C030C030FFF07FE0'\nWIDEH    DC    X'C030C030C030C030C030FFF0FFF0C030C030C030C030C030'\nWIDEI    DC    X'7FE07FE0060006000600060006000600060006007FE07FE0'\nWIDEJ    DC    X'3FF03FF0030003000300030003000300C300C300FF007E00'\nWIDEK    DC    X'C030C060C0C0C180C300FE00FE00C300C180C0C0C060C030'\nWIDEL    DC    X'C000C000C000C000C000C000C000C000C000C000FFF0FFF0'\nWIDEM    DC    X'C030E070F0F0D9B0CF30C630C030C030C030C030C030C030'\nWIDEN    DC    X'C030E030F030D830CC30C630C330C1B0C0F0C070C030C010'\nWIDEO    DC    X'FFF0FFF0C030C030C030C030C030C030C030C030FFF0FFF0'\nWIDEP    DC    X'FFE0FFF0C030C030C030FFF0FFE0C000C000C000C000C000'\nWIDEQ    DC    X'7FE0FFF0C030C030C030C030C030C330C1B0C0F0FFE07FB0'\nWIDER    DC    X'FFE0FFF0C030C030C030FFF0FFE0C300C180C0C0C060C030'\nWIDE$    DC    X'06007FE0FFF0C630E6007FC03FE00670C630FFF07FE00600'\nWIDES    DC    X'7FE0FFF0C030C000E0007FC03FE000700030C030FFF07FE0'\nWIDET    DC    X'FFF0FFF00600060006000600060006000600060006000600'\nWIDEU    DC    X'C030C030C030C030C030C030C030C030C030C030FFF07FE0'\nWIDEV    DC    X'C030C030C030C030C030C030C030606030C019800F000600'\nWIDEW    DC    X'C030C030C030C030C030C030C630CF30D9B0F0F0E070C030'\nWIDEX    DC    X'C030C030606030C019800F000F00198030C06060C030C030'\nWIDEY    DC    X'C030C030606030C019800F00060006000600060006000600'\nWIDEZ    DC    X'FFF0FFF0006000C001801FC01FC00C00180030007FF0FFF0'\nWIDE0    DC    X'3FC07FE0C0F0C1B0C330C630CC30D830F030E0307FE03FC0'\nWIDE1    DC    X'06000E001E0006000600060006000600060006007FE07FE0'\nWIDE2    DC    X'7FE0FFF0C0300030003000600180060018006000FFF0FFF0'\nWIDE3    DC    X'7FE0FFF0C0300030003001E001E000300030C030FFF07FE0'\nWIDE4    DC    X'038007800D80198031807FF0FFF001800180018001800180'\nWIDE5    DC    X'FFF0FFF0C000C000C000FF80FFC0006000300030FFF0FFE0'\nWIDE6    DC    X'7FE0FFF0C030C000C000FFE0FFF0C030C030C030FFF07FE0'\nWIDE7    DC    X'FFF0FFE0C0C0018003000600060006000600060006000600'\nWIDE8    DC    X'7FE0FFF0C030C03060603FC03FC06060C030C030FFF07FE0'\nWIDE9    DC    X'7FE0FFF0C030C030C030FFF0FFF000300030C030FFF07FE0'\nWIDE#    DC    X'30C030C0FFF0FFF030C030C030C030C0FFF0FFF030C030C0'\nWIDE@    DC    X'3FC07FE0C030003000301E303F306330C330C3307FE03FC0'\nWIDEFSTOP DC   X'000000000000000000000000000000000F000F000F000F00'\nWIDECOMMA DC   X'000000000000000000000000000000000F000E000C000800'\n\nMASK$    DC  X'402020202020206B2021204B2020' MASK FOR DOLLAR VA\n\n*---------------------------------------------------------------------*\n*        EBCDIC to ASCII translation table                            *\n*---------------------------------------------------------------------*\n\nsToASCII DS   0D\n*                0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC   X'000102030405060708090A0B0C0D0E0F' 0x\n         DC   X'101112131415161718191A1B1C1D1E1F' 1x\n         DC   X'202122232425262728292A2B2C2D2E2F' 2x\n         DC   X'303132333435363738393A3B3C3D3E3F' 3x\n         DC   X'204142434445464748494A2E3C282B4F' 4x\n         DC   X'2651525354555657585921242A293B5F' 5x\n         DC   X'2D2F62636465666768697C2C255F3E3F' 6x\n         DC   X'707172737475767778793A2340273D22' 7x\n         DC   X'806162636465666768698A8B8C8D8E8F' 8x\n         DC   X'906A6B6C6D6E6F7071729A9B9C9D9E9F' 9x\n         DC   X'A07E737475767778797AAAABACADAEAF' Ax\n         DC   X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF' Bx\n         DC   X'7B414243444546474849CACBCCCDCECF' Cx\n         DC   X'7D4A4B4C4D4E4F505152DADBDCDDDEDF' Dx\n         DC   X'5CE1535455565758595AEAEBECEDEEEF' Ex\n         DC   X'30313233343536373839FAFBFCFDFEFF' Fx\n         EJECT\n\n*---------------------------------------------------------------------*\n*        VariableName to VariableValue table                          *\n*---------------------------------------------------------------------*\n\n         PRINT DATA\n*              Value,Name\nVARTAB   DS    0D\n\n*              VPS fields...\n         VAR   sBann,BANNER   Contains either START or END or CONT\n\n*              Job fields...\n         VAR   sJobI,JOBID    Job number (eg JOBnnnnn or STCnnnnn)\n         VAR   sJobN,JOBNAME  Job name\n\n*              Printer fields...\n         VAR   sPrtM,PRTMEMB  Printer VPS definition member name\n         VAR   sPrtN,PRTNAME  Printer name\n\n*              Report fields...\n         VAR   sRepC,REPCLASS Report sysout class\n         VAR   sRepS,REPCDATE Report creation (spooled) date\n         VAR   sRepD,REPDEST  Report destination name\n         VAR   sRepP,REPPDATE Report print date\n\n*              Userid fields...\n         VAR   sUsrI,USERID   User id\n         VAR   sUsrN,USERNAME User full name\n\n*              OUTPUT card fields...\n         VAR   sOut1,OUTADDR1 Address line 1\n         VAR   sOut2,OUTADDR2 Address line 2\n         VAR   sOut3,OUTADDR3 Address line 3\n         VAR   sOut4,OUTADDR4 Address line 4\n         VAR   sOutB,OUTBUILD Building\n         VAR   sOutC,OUTCLASS Class\n         VAR   sOutO,OUTDEPT  Department\n         VAR   sOutD,OUTDEST  Destination\n         VAR   sOutJ,OUTJESDS JES Dataset type (ALL,JCL,LOG or MSG)\n         VAR   sOutG,OUTGROUP Output group\n         VAR   sOutN,OUTNAME  Name\n         VAR   sOutR,OUTROOM  Room\n         VAR   sOutT,OUTTITLE Title\n         VAR   sOutW,OUTWTR   Writer name                      20000211\n\n         VAR   sFlsh,FLASH    Flash overlay name               20010720\n         VAR   ,         End-of-table marker\n         PRINT NODATA\n         EJECT\n***********************************************************************\n*                                                                     *\n*                            E Q U A T E S                            *\n*                                                                     *\n***********************************************************************\n\n$ACH1    EQU   X'F1'                   CHANNEL-1 ASA CHARACTER.\n$ANSP    EQU   X'4E'                   SUPPRESS SPACE ASA CHARACTER.\n$ASSP    EQU   X'40'                   SINGLE   SPACE ASA CHARACTER.\n$ADSP    EQU   X'F0'                   DOUBLE   SPACE ASA CHARACTER.\n$ATSP    EQU   X'60'                   TRIPLE   SPACE ASA CHARACTER.\n         EJECT\n***********************************************************************\n*                                                                     *\n*                             D S E C T S                             *\n*                                                                     *\n***********************************************************************\n\n*---------------------------------------------------------------------*\n*        VariableName to CurrentValue table entry                     *\n*---------------------------------------------------------------------*\n\nVARTABD  VAR   TYPE=DSECT\n\n*---------------------------------------------------------------------*\n*        Separator work area (transient)                              *\n*---------------------------------------------------------------------*\n\n*--------> SEPRDSCT IS POINTED TO BY R13\n*--------> It is obtained once at each START/END entry point\n*--------> and is NOT retained across calls for each print line\n\nSEPRDSCT DSECT\nSAVEAREA DS    18F                Savearea (MUST be first)\nnRetCode DS    F'0'\nnRequest DS    F'0'\nsAsIs    DS    CL8' '\nsTrans   DS    CL8' '\nhCharNo  DS    H'0'               RELATIVE CHARACTER NUMBER.\ncSaved   DS    C' '               SAVED CHARACTER FOR MOVES.\nbSlant   DS    C'N'               Slant? N=No, Y=Yes\nbCentre  DS    C'Y'               Centre? N=No, Y=Yes\n\n*---------------------------------------------------------------------*\n*        Block letter print line                                      *\n*---------------------------------------------------------------------*\n\nWORKLINE DS    0CL133             Print line\nWORKLNC  DS    CL1' '             Carriage control byte\nWORKLND  DS    CL132              Print data\n         ORG   WORKLND\nWASTER1  DS    C'*'\nWCLASS1  DS    C'A'\n         DS    C' '\nWSTATUS1 DS    CL5'START'         START, END or CONT\n         DS    C' '\nWJOBID1  DS    CL8'JOBnnnnn'      Job or STC number\n         DS    C' '\nWJOBNAME DS    CL8'jobname'       Job or STC number\n         DS    C' '\nWDEST    DS    CL8'destid'        Destination name\n         DS    C' '\nWNAME    DS    CL20'ANDREW J ARMSTRONG  ' User's name\n         DS    C' '\n         DS    CL35\n         DS    C' '\nWDATE    DS    C'YYYY/MM/DD HH:MM:SS DAY'\n         DS    C' '\nWJOBID2  DS    CL8'JOBnnnnn'      Job or STC number\n         DS    C' '\nWSTATUS2 DS    CL5'START'         START, END or CONT\n         DS    C' '\nWCLASS2  DS    C'A'\nWASTER2  DS    C'*'\n         ORG   ,\n         DS    0D                      ALIGN ON A DOUBLEWORD BOUNDARY.\nSEPRDSLN EQU   *-SEPRDSCT              LENGTH OF DSECT.\n\n*---------------------------------------------------------------------*\n*        Separator scratch pad area                                   *\n*---------------------------------------------------------------------*\n\n*        These two words may be used as a separator scratch pad area.\n*        The contents will not be changed between calls to the start-\n*        job routine, or calls to the end-job routine.  Upon entry to\n*        either routine, BOTH words will be binary zeroes.\n\nSEPUSER  DSECT\nhSepLine   DS  H                  Current separator line no.\n           DS  X                  Unused\ncSepOffset DS  AL1                Offset for centred text\npWorkArea  DS  A                  -> WORKAREA (see below)\n\n*---------------------------------------------------------------------*\n*        Other VPS DSECTs                                             *\n*---------------------------------------------------------------------*\n\n         VPSSJSTA\n         VPSSLINE\n         VPSSPRAT\n         VPSSSEPI\n         VPSSSYAT\n         VPSSXMAT\n         VPSSORAT\n\n         TITLE ' '\n***********************************************************************\n*                                                                     *\n*                           W O R K A R E A                           *\n*                                                                     *\n***********************************************************************\n\n*---------------------------------------------------------------------*\n*        Separator work area (saved across calls)                     *\n*---------------------------------------------------------------------*\n\n*        WORKAREA IS POINTED TO BY SEPADDR\n*        It is obtained once at each START/END entry point\n*        and is retained across calls for each print line\n\nWORKAREA DSECT\nnRegs    DS    16F\nnReg3to5 DS    3F\ndWork    DS    D                  Double word work area\npPRAT    DS    A                  -> VPSSPRAT\n\n*---------------------------------------------------------------------*\n*        RACF stuff                                                   *\n*---------------------------------------------------------------------*\n\nsRACFUID DS    0CL9               Userid length/data\ncRACFLen DS    CL1                Userid length prefix\nsRACFUsr DS    CL8                Userid proper\n\npACEE    DS    A                  -> RACF ACEE built by RACROUTE\n\n         DS    0D                 MUST ALIGN ON FULLWORD BOUNDARY5JAN93\nsRACFWork DS   CL512\n\nsVerify RACROUTE MF=L,             Parameter list for RACROUTE         X\n               REQUEST=VERIFY,                                         X\n               RELEASE=2.4\nsVerify# EQU   *-sVerify\n\n*---------------------------------------------------------------------*\n*        System variable storage area                                 *\n*---------------------------------------------------------------------*\n\nhVarLen  DS    H             L'String in sVar\nhSubBeg  DS    H             Index of first substring\nhSubLen  DS    H             L'Substring\n\nsVars    EQU   *\nsBann    DS    CL05'START'\nsJobI    DS    CL08'JOBnnnnn'\nsJobN    DS    CL08\nsPrtM    DS    CL08\nsPrtN    DS    CL35'255.255.255.255' ...or hostname\nsRepC    DS    CL01'A'\nsRepS    DS    C'yyyy/mm/dd hh:mm:ss day'\nsRepD    DS    CL08'HDPSPR1'\nsRepP    DS    C'yyyy/mm/dd hh:mm:ss day'\nsUsrI    DS    CL08\nsUsrN    DS    CL20\nsOut1    DS    CL(L'ORAADDR1)\nsOut2    DS    CL(L'ORAADDR2)\nsOut3    DS    CL(L'ORAADDR3)\nsOut4    DS    CL(L'ORAADDR4)\nsOutB    DS    CL(L'ORABLDG)\nsOutC    DS    CL(L'ORACLS)\nsOutO    DS    CL(L'ORADEPT)\nsOutD    DS    CL(L'ORADEST)\nsOutJ    DS    CL(L'ORAJESDS)\nsOutG    DS    CL(L'ORAGRP)\nsOutN    DS    CL(L'ORANAME)\nsOutR    DS    CL(L'ORAROOM)\nsOutT    DS    CL(L'ORATITLE)\nsOutW    DS    CL(L'ORAWTR)                                    20000211\nsFlsh    DS    CL(L'XMAFLASH)                                  20010720\nsVars#   EQU   *-sVars\n\nsVar     DS    CL80 Length is the MAXIMUM sized field in sVars\n\n*---------------------------------------------------------------------*\n*        Buffer and macros to read separator PDS member               *\n*---------------------------------------------------------------------*\n\nsMember  DS    CL8\n\nsDECB    DS    4D\n\nsOpen    OPEN  (sFile,INPUT),MODE=31,MF=L\nsOpen#   EQU   *-sOpen\n\nsClose   CLOSE (sFile),MODE=31,MF=L\nsClose#  EQU   *-sClose\n\n         DS    0D\nsFile    DCB   DDNAME=SEPAR,                                           X\n               DSORG=PO,                                               X\n               RECFM=VB,                                               X\n               LRECL=sBlock#-4,   See below                            X\n               MACRF=(R),                                              X\n               BLKSIZE=sBlock#,   See below                            X\n               DCBE=kDCBE,                                     20010810X\n               KEYLEN=0\nsFile#   EQU   *-sFile\n\nsDCBE    DCBE  EODAD=EOF          End-of-file routine          20010810\nsDCBE#   EQU   *-sDCBE                                         20010810\n\npPCL     DS    A                  ->PCL buffer to be sent to printer\nnPCL     DS    F                  Length of PCL buffer\npPCLData DS    A                  ->Next free byte in PCL buffer\nnPCLData DS    F                  Length of data in PCL buffer\npPCLMax  DS    A                  ->Byte after end of PCL buffer\npPCLNext DS    A                  ->Next chunk to be printed\n\npBlockEnd DS   A                  -> Byte after end of this block\n\nsBlock   DS    0D\nhBlock   DS    H                  LL (block length)\n         DS    H                  BB\nsBlockData DS  XL32756\nsBlock#  EQU   *-sBlock\n\nWORKAREA# EQU  *-WORKAREA\n\n*---------------------------------------------------------------------*\n*        Map a record in the block read from disk                     *\n*---------------------------------------------------------------------*\n\nRECORD   DSECT\nhRecLen  DS    H                  LL (record length)\n         DS    H                  BB\ncRecType DS    C                  Record type ('*','E','&','B', etc)\nsRecData DS    0C                 Record data (maximum record length)\n\n*---------------------------------------------------------------------*\n*        Map the Accessor Control Element Entry                       *\n*---------------------------------------------------------------------*\n\n         IHAACEE\n\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT640/FILE640.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT640", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}