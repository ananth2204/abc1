{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20170615172527000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "T311LBD.CHKIKJ.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.CHKIKJ.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "170166", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x1e'", "DS1LSTAR": "b'\\x00\\x03\\x03'", "DS1TRBAL": "b'8\\x0c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c\\xf0\\x00\\x04\\x98\\xa0`'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c\\xf0\\x00\\x04\\x98\\xa0`'", "b'X\\x9f\\x84`\\x00\\x00\\x02v\\x00\\x00\\x02v\\x00\\x05\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 3, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x03\\x01\\x16(\\x7f\\x01\\x17\\x04\\x7f\\x11X\\x00\\x1e\\x00\\x0b\\x00\\x00\\xc9\\xd2\\xd1\\xe3\\xe2\\xd6@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2016-10-13T00:00:00", "modifydate": "2017-02-16T11:58:03", "lines": 30, "newlines": 11, "modlines": 0, "user": "IKJTSO"}, "text": "CHKIKJ is a quick/dirty ispf dialog to compare the ibm samplib\nversion of ikjtso00 to what is actually running on the active lpar.\n\nWhy use it?\n\n    1. To determine what changes IBM has made in their sample IKJTSO00\n       that SHOULD be reflected in the production IKJTSOxx\n    2. To review the active IKJTSOxx to audit for modules that are\n       defined (and thus authorized) and which may not be required\n       any longer in the list.\n\nThe ISPF panels (panel and tutorial) that is used is contained within\nthe REXX code.\n\nThe tail end of the exec, started at the >DATA record, are the\nmodule descriptions that are used in the report.\n\nThis pds contains the rexx exec CHKIKJ and the $DOC (that you're reading)\n\nThe requirements are:\n1. Must have STEMEDIT installed and available if not specifying a report\n   dataset name.  STEMEDIT can be found on CBTTape File 183.\n2. Must be able to read SYS1.SAMPLIB\n2. Must be able to invoke the TSO PARMLIB command\n\nThe report isn't pretty but it works\n\nNo warranty, expressed or implied, accompanies this code. It is\nprovided AS-IS and the user assumes all risks and responsibilities\nfor its use.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHKIKJ": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x17\\x01\\x16(\\x8f\\x01\\x17\\x16o\\x12%\\x03\\x9e\\x02?\\x00\\x00\\xc3\\xc8\\xd2\\xc9\\xd2\\xd1@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2016-10-14T00:00:00", "modifydate": "2017-06-15T12:25:17", "lines": 926, "newlines": 575, "modlines": 0, "user": "CHKIKJ"}, "text": "/* --------------------  rexx procedure  -------------------- */\n ver = '1.4'\n/* Name:      chkikj                                          |\n |                                                            |\n | Function:  ispf dialog to compare the ibm provided         |\n |            sys1.samplib(ikjtso00) to the active            |\n |            ikjtsoxx                                        |\n |                                                            |\n | Syntax:    %chkikj                                         |\n |                                                            |\n | Usage Notes: 1. Dynamically load ISPF Panel (end of        |\n |                 this code)                                 |\n |              2. Will display an ISPF panel to:             |\n |                 - verify/update ibm samplib ikjtso00       |\n |              3. Then invoke TSO PARMLIB command and        |\n |                 capture results                            |\n |              4. If a report dataset name is specified      |\n |                 on the panel then the report will be       |\n |                 written to it and then Viewed.             |\n |                 Otherwise STEMEDIT will be called to       |\n |                 View the report.                           |\n |                                                            |\n | Dependencies: 1. STEMEDIT (CBT File 183)                   |\n |               2. Find >DATA and maintain list of           |\n |                  descriptions                              |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |     v1.4   06/15/17 - Add EDIT commands to find differences|\n |                     - Change alloc: ... blksize(0) reu ... |\n |                     - Change alloc: ... blksize(0) ISPF dsn|\n |                     - bug fix if no entry for ptype found  |\n |                     - bug fix in sort routine if string='' |\n |     v1.3   02/16/17 - Add descriptions                     |\n |     v1.2   02/16/17 - Fix sort and fix missing PLATPGM     |\n |     v1.1   02/15/17 - Clean up report                      |\n |     v1.0   02/15/17 - Enhancements per BK                  |\n |            10/17/16 - Many improvements                    |\n |            10/14/16 - Moved panel inline and use the       |\n |                       loadispf routine to load it.         |\n |                     - Generate a report showing all        |\n |                       commands and where found.            |\n |            10/13/16 - Change from Console command to       |\n |                       use Parmlib command                  |\n |            10/13/16 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n\n parse value '' with null type types ibm. site.\n\n/* --------------------------------------------- *\n | Get into ISPExec mode and load the ISPF Panel |\n * --------------------------------------------- */\n Address ISPExec\n load_info = loadispf()\n 'vget (ibmsamp ikjrpt) profile'\n\n/* ---------------------- *\n | Display the ISPF Panel |\n * ---------------------- */\n 'Display Panel(chkikjp)'\n if rc > 0 then do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n    exit\n    end\n\n/* -------------------------------------- *\n | Fixup the report dataset name if blank |\n * -------------------------------------- */\n if ikjrpt = null then do\n    if sysvar('syspref') = null ,\n       then do\n            hlq = sysvar('sysuid')\n            end\n       else do\n            hlq = sysvar('syspref')\n            end\n       lpar = mvsvar('sysname')\n       ikjrpt = \"'\"hlq\".IKJTSO.\"lpar\".COMPARE'\"\n    end\n 'vput (ibmsamp ikjrpt) profile'\n\n/* ------------------------------------------------------ *\n | Process the >DATA section to get the descriptions that |\n | will be used for the report.                           |\n * ------------------------------------------------------ */\n desc. = null\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">DATA \" then leave\n    parse value line with data '/*' desc '*/' .\n    do id = 1 to words(data)\n       iw = word(data,id)\n       desc.iw = strip(desc)\n       end\n    end\n\n Address TSO\n/* --------------------------------- *\n | Issue PARMLIB command and trap it |\n * --------------------------------- */\n call outtrap 't.'\n 'parmlib LIST(ALL)'\n call outtrap 'off'\n\n/* ----------------------------------- *\n | Process the Console Command results |\n * ----------------------------------- */\n hit = 0\n ptypes = 'PLATCMD PLATPGM AUTHCMD AUTHPGM AUTHTSF NOTBKGND'\n do i = 1 to t.0\n    select\n      when ( pos('CURRENT PARMLIB SETTINGS FOR',t.i) > 0 ) ,\n        then do\n                parse value t.i with x1 x2 x3 x4 type':' .\n                if wordpos(type,ptypes) > 0 then hit = 1\n                                            else hit = 0\n                if hit = 0 then iterate\n                if wordpos(type,types) = 0 then\n                   types = strip(types) type\n                iterate\n             end\n      when ( pos('THERE ARE NO ',t.i) > 0 ) ,\n        then do\n                parse value t.i with . . . type .\n                types = strip(types) type\n                hit = 0\n             end\n      otherwise nop\n    end /* end select */\n    if hit = 1 then site.type = strip(site.type) strip(t.i)\n end\n\n/* ------------------------------- *\n | Read in the IBM Sample IKJTSO00 |\n * ------------------------------- */\n ddn = 'IBMS'random(999)\n 'Alloc f('ddn') shr reuse ds('ibmsamp')'\n 'Execio * diskr' ddn '(finis stem samp.'\n 'Free f('ddn')'\n\n/* ---------------------------------- *\n | Process the IBM Sample into a stem |\n * ---------------------------------- */\n hit = 0\n do i = 1 to samp.0\n    parse value samp.i with data '/*' comment .\n    if strip(data) = null then iterate\n    if hit = 1 then\n       if pos(')',data) > 0 then do\n          hit = 0\n          parse value data with data')'\n          if strip(data) = null then iterate\n          ibm.type = strip(ibm.type) strip(data)\n          end\n    if pos('NAMES(',data) > 0 then do\n       hit = 1\n       type = word(data,1)\n       if wordpos(type,types) = 0 then\n          types = strip(types) type\n       parse value data with 'NAMES('data\n       end\n    if hit = 1 then ibm.type = strip(ibm.type) strip(data)\n    end\n\n/* ---------------------------- *\n | Now report in tabular format |\n * ---------------------------- */\n do i = 1 to words(types)\n    type = word(types,i)\n    commands.type = null\n    do iw = 1 to words(ibm.type)\n       w = word(ibm.type,iw)\n       commands.type = commands.type w\n       end\n    do iw = 1 to words(site.type)\n       w = word(site.type,iw)\n       if wordpos(w,commands.type) = 0 then\n          commands.type = commands.type w\n       end\n    end\n\n/* ---------------- *\n | Sort the strings |\n * ---------------- */\n types = sort(types)\n do i = 1 to words(types)\n    type = word(types,i)\n    commands.type = sort(commands.type)\n    end\n\n address ispexec \"vget (zdel)\"\n _ecmd_ = \"x all\"zdel\" f 1 8 all '------('\"zdel\n c = 0\n c=c+1\n summ.c = 'Report comparing IBM SAMPLIB IKJTSO00 to Site IKJTSOxx - Ver:' ver\n c=c+1\n summ.c = center('Sysplex:' mvsvar('sysplex') 'Lpar:' mvsvar('sysname'),57)\n c=c+1\n summ.c = center(date() time(),57)\n c=c+1\n summ.c=\"\"copies(\"-\",68)\n c=c+1\n summ.c=\"   Find all differences with these EDIT commands:\"\n c=c+1\n summ.c=\"   - IBM:    \"_ecmd_\" f all 13 22 'X         '\"\n c=c+1\n summ.c=\"   - site:   \"_ecmd_\" f all 13 22 '         X'\"\n c=c+1\n summ.c=\"\"copies(\"-\",68)\n\n wt = words(types)\n do i = 1 to wt\n    type = word(types,i)\n    c = c + 1\n    summ.c = ' '\n    c = c + 1\n    summ.c = '------(' type ')------'\n    c = c + 1\n    summ.c = ' '\n    c = c + 1\n    summ.c = left('Module',10) left('IBM',7) left('Site',10) ,\n             left('Description',30)\n    c = c + 1\n    summ.c = left('--------',10) left('---',7,) left('----',10) left('-',30,'-')\n    wct = words(commands.type)\n    do iw = 1 to wct\n       cmd = word(commands.type,iw)\n       if wordpos(cmd,ibm.type) > 0 then ibmf = 'X'\n                                  else ibmf = ' '\n       if wordpos(cmd,site.type) > 0 then sitef = 'X'\n                                   else sitef = ' '\n       c = c + 1\n       summ.c = left(cmd,11) left(ibmf,8) left(sitef,8) desc.cmd\n       end\n    end\n    summ.0 = c\n\n/* ------------------------------------------------------------- *\n | If ikjrpt (optional report dataset) is null then use          |\n | stemedit to view the report.                                  |\n |                                                               |\n | Otherwise write out to a report dataset, after allocating it, |\n | and then view it.                                             |\n * ------------------------------------------------------------- */\n if ikjrpt = 'TSO' then do\n    title = 'Report comparing IBM SAMPLIB IKJTSO00 to Site IKJTSOxx'\n    CALL stemview 'view','summ.',,,title,,80\n    end\n else do\n      call outtrap 'x.'\n      'Delete' ikjrpt\n      call outtrap 'off'\n      tdd = 'IKJRPT'random(99)\n      'Alloc f('tdd') ds('ikjrpt') new spa(1,1) tr recfm(f b)' ,\n            'lrecl(80) blksize(0) reuse'\n      'Execio * diskw' tdd '(finis stem summ.'\n      'Free f('tdd')'\n      Address ISPExec 'Edit Dataset('ikjrpt')'\n      end\n\n/* -------------- *\n | Exit this code |\n * -------------- */\n Exit\n\n/* ------------ *\n | Sort routine |\n * ------------ */\n Sort: Procedure\n parse arg string\n null = ''\n if strip(string) = null then return null\n do i = 1 to words(string)\n    stem.i = word(string,i)\n    end\n stem.0 = words(string)\n/* rexx command to sort a stem variable\n   Simple bubble sort of \"stem' by stem.1\n   Ken Singer, Shell Oil, Houston\n ********************************************************/\n  if stem.0 = 1 then return /* simple sort !*/\n  ctr =  stem.0\n  do y = 1 to  ctr - 1\n     do x = y+1 to ctr\n        if stem.x = null then leave\n        if stem.x < stem.y then do\n            /* swap these 2 entries */\n            t1 = stem.y ;\n            stem.y = stem.x\n            stem.x = t1\n        end\n     end x\n  end y\n  string = null\n  do i = 1 to stem.0\n     string = strip(string) stem.i\n     end\n drop stem.\n return string\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd ALTLIBC)\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd ALTLIBE)\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd ISPMLIB)\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd ISPPLIB)\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd ISPSLIB)\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n Select\n    When type = \"Clist\" then\n         \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n         \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n         \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n         \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n         \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n    end\n type = null\n return\n\n/* ------------------------------ *\n * Allocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(f b) lrecl(80) blksize(0)\"\n return\n\n/* ---------------------------------------------- *\n | Here is the location of the inline ISPF panels |\n | that will be dynamically loaded and activated  |\n | using LIBDEF.                                  |\n * ---------------------------------------------- */\n>START - start of inline data\n>PANEL CHKIKJP\n)Attr Default(%+_)\n/* + type(text  ) intens(low )                   information only  */\n   $ type( input) intens(high) caps(on ) just(left ) hilite(uscore)\n   @ type(text) intens(high) color(blue ) hilite(reverse)\n)Body expand(\\\\)\n%-\\-\\-@Compare IKJTSOxx to IBM Sample%-\\-\\-\n%Command ===>_zcmd\n+\n+IBM SAMPLIB Dataset:$ibmsamp                                       +\n+\n+Report Dataset     :$ikjrpt                                        +\n+                    TSO to view in temporary dataset\n+\n+NOTE: You must have the authority to issue the TSO PARMLIB command\n+      to use this dialog.\n+\n+Press Enter to continue or PF3 to cancel\n)Init\n .cursor = ibmsamp\n .help   = #chkikj\n if (&ibmsamp = &Z)\n     &ibmsamp = '''sys1.samplib(ikjtso00)'''\n)Proc\n  ver (&ibmsamp,dsnamepq)\n  ver (&ikjrpt,dsnamepq)\n)End\n>PANEL #CHKIKJ\n)ATTR DEFAULT(%+_)\n   %   TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n   +   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(GREEN)\n   _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) HILITE(USCORE)\n)BODY EXPAND(\\\\)\n%Tutorial+-\\-\\-(%CHKIKJ - IKJTSO Comparison+)-\\-\\-%Tutorial\n%Command ===>_ZCMD\n+\n+CHKIKJ is a ISPF application that will compare the active IKJTSOxx settings\n+to the IBM Samplib IKJTSO00. This helps to highlight changes that IBM has\n+made which may not be reflected in the production IKJTSOxx.\n+\n+The production IKJTSOxx settings are found using the TSO PARMLIB command,\n+which means the individual using this application must have authorization to\n+use the PARMLIB command.\n+\n+If the report name is blank then it will default to userid.IKJTSO.lpar.COMPARE\n+or it may be specified using standard ISPF dataset naming conventions. If it\n+is TSO then the STEMEDIT REXX function (CBT Tape file 183) will be used.\n+\n+On the Panel point to the IBM SAMPLIB IKJTSO00 - e.g. SYS1.SAMPLIB(IKJTSO00)\n+and either blank out the report dataset name, change it, or use it.\n+\n+When ready to execute press Enter or PF3 to cancel.\n)PROC\n)END\n>END   - end of all inline data (optional if last)\n\n/* ------------------------------------------------ *\n | What follows after the >DATA are the load module |\n | descriptions that will be used in the report.    |\n |                                                  |\n | The format is:                                   |\n |                                                  |\n | 1-8    Load module name                          |\n | 9-n    Description (limited to 30 chars)         |\n |        enclosed between /* and */                |\n * ------------------------------------------------ */\n>DATA\n ACLSERV              /* ACL FOR OS/390 */\n AD ADDSD             /* RACF PROTECT NEW DATASET */\n ADRDSSU              /* IBM DFDSS Backup/Restore */\n ADYOPCMD             /* DAE/IPCS SEE APAR OW14720 */\n AESCNETS             /* AES/TCP MONITORING */\n AEST049              /* AES/TCP MONITORING */\n AG ADDGROUP          /* RACF DEFINE GROUP PROFILE */\n ALD ALTDSD           /* RACF ALTER DATASET PROFILE */\n ALG ALTGROUP         /* RACF ALTER GROUP */\n ALLOCATE ALLOC       /* TSO ALLOCATE DATASET */\n ALTER                /* IDCAMS ALTER COMMAND */\n ALTLIB IKJADLIB      /* TSO ALTERNATE CLIST/EXEC LIB */\n ALU ALTUSER          /* RACF ALTER USER PROFILE */\n AMASPZAP             /* MVS BASE */\n AOPCMND              /* IBM IP PRINTWAY START/STOP PRINTER */\n ARMAUTH              /* BMC RECOVER MGR */\n ATTRIB ATTR          /* TSO ATTRIBUTE COMMAND */\n AU ADDUSER           /* RACF ADD USER */\n BBSDTCPA             /* BMC SOFTWARE, INC */\n BINDDATA BDATA       /* MANAGE CACHE DEVICES */\n BLKUPD               /* RACF MODIFY BLOCKS */\n BUDDSN               /* STORAGE GUARD / BUDGET DASD*/\n BUDGET               /* STORAGE GUARD / BUDGET DASD*/\n CADU4804             /* CA-DOCVIEW/VPE */\n CADU4805             /* CA-DOCVIEW/VPE */\n CAE$BQRY             /* CA-COMMON SERVICES */\n CALL IKJEFG00        /* TSO CALL A PROGRAM */\n CAS9UDTN             /* CA-ENF */\n CAZ2CTSO             /* CA-JCLCHECKER */\n CDELPAIR             /* PPRC TSO CMDS */\n CDELPATH             /* PPRC TSO CMDS */\n CESTPAIR             /* PPRC TSO CMDS */\n CESTPATH             /* PPRC TSO CMDS */\n CGROUP               /* PPRC TSO CMDS */\n CO CONNECT           /* RACF CONNECT TO GROUP */\n COFDMON              /* HIPERBATCH MONITOR */\n CONSOLE              /* MVS CONSOLE COMMAND */\n CONSPROF             /* TSO CONSOLE PROFILE */\n COSRCALR             /* BMC SOFTWARE, INC */\n CQUERY               /* PPRC TSO CMDS */\n CRECOVER             /* PPRC TSO CMDS */\n CSFDAUTH             /* ICSF CRYPTO IBM */\n CSFDPKDS             /* ICSF CRYPTO IBM */\n CSUSPEND             /* PPRC TSO CMDS */\n DD DELDSD            /* RACF DELETE DATASET PROFILE */\n DDTTAUTH             /* OPERTUNE */\n DEF                  /* IDCAMS DEFINE */\n DEFINE               /* IDCAMS DEFINE */\n DG DELGROUP          /* RACF DELETE GROUP PROFILE */\n DIAGNOSE             /* EMCAGENT */\n DISKMAP              /* CBT DISKMAP */\n DU DELUSER           /* RACF DELETE USER PROFILE */\n EDGAUD               /* DFSSMrmm Security/Audit Reports */\n EDGBKUP              /* DFSSMrmm Backup and Restore */\n EDGHSKP              /* DFSSMrmm utility */\n EDGRPTD              /* DFSSMrmm Inventory reports */\n EDGUPDT              /* DFSSMrmm update utility */\n EDGUTIL              /* DFSSMrmm utility */\n EDVAPI               /* ENDEVOR */\n EJESIENV             /* EJESENVx Inventory Query */\n EJESPOPT             /* Options Policy Manager */\n EJESPSEC             /* Internal Security Policy Mgr */\n EMCSNAP              /* EMC TIMEFINDER */\n EMCTF                /* EMC TIMEFINDER */\n EMCTFA               /* EMC TIMEFINDER */\n EMCTFU               /* EMC TIMEFINDER */\n EQACUOCM             /* DEBUG TOOL MONITOR INTERFAC*/\n ESTLIB               /* ES DYNAMIC STEPLIB */\n ESTLIBA              /* ES DYNAMIC STEPLIB */\n ESTLIBX              /* ES DYNAMIC STEPLIB */\n EXAMINE              /* IDCAMS Examine VSAM */\n EXCACCTX             /* TSO ACCOUNTING */\n EXCSHARD SHARDISK    /* ENQUE DSN WITHOUT DISP=OLD */\n EXEC EX IKJEXC2      /* TSO EXECUTE A CLIST/EXEC */\n EXPORT EXP           /* IDCAMS EXPORT DATA */\n EYU9XENF             /* CPSM COMMANDS */\n FCESTABL             /* FLASH COPY CMDS */\n FCQUERY              /* FLASH COPY CMDS */\n FCWITHDR             /* FLASH COPY CMDS */\n FDRCPK               /* FDR Compaktor */\n FDREPORT             /* FDR Reporting */\n FDRQUERY             /* FDR Query */\n FDRSRSA              /* FDR */\n FIND                 /* FIND MEMBER */\n FREE UNALLOC         /* TSO FREE ALLOCATION */\n FTP                  /* TCP/IP FILE TRANSFER FTP */\n GENJISPF             /* HOTSITE MARKASWEGAN */\n GIMSMP               /* SMPE */\n GVBACTV              /* HYPER-BUF ACTIVATE */\n GVBSDACT             /* HYPER-BUF DEACTIVATE*/\n HZSPRNT              /* HEALTH CHECK PGM */\n IAMRECVR             /* IAM ISPF */\n ICADCFGS             /* FIREWALL IBM'S SECUREWAY */\n ICADCT               /* FIREWALL IBM'S SECUREWAY */\n ICADDCT              /* FIREWALL IBM'S SECUREWAY */\n ICADFTPD             /* FIREWALL IBM'S SECUREWAY */\n ICADIKED             /* FIREWALL IBM'S SECUREWAY */\n ICADPFTP             /* FIREWALL IBM'S SECUREWAY */\n ICADSLOG             /* FIREWALL IBM'S SECUREWAY */\n ICADSOCK             /* FIREWALL IBM'S SECUREWAY */\n ICADSOXD             /* FIREWALL IBM'S SECUREWAY */\n ICADSTAK             /* FIREWALL IBM'S SECUREWAY */\n ICHDSM00             /* RACF DATASET MONITOR PGM */\n ICHUT100             /* RACF CROSS-REFERENCE PGM */\n ICHUT200             /* RACF DATABASE VERIFY PGM */\n ICHUT400             /* RACF DATABASE SPLIT/MERGE */\n ICKDSF               /* DSF */\n ICQASLI0             /* IBM APPC */\n IDCAMS               /* IBM IDCAMS */\n IEFBR14              /* DO NOTHING PROGRAM */\n IEHPROGM             /* DFSMS/MVS */\n IHVUUSD              /* IHV ENTRY */\n IKJEFF76             /* COMMAND AUTHORIZATION CHECK*/\n IKJEHDS1             /* LISTDS COMMAND PROCESSOR */\n IMP                  /* IDCAMS IMPORT */\n IMPORT               /* IDCAMS IMPORT */\n IOEAGFMT             /* DFS */\n IOEAGSLV             /* DFS */\n IOEBAK               /* DFS */\n IOEBOS               /* DFS */\n IOECM                /* DFS */\n IOEDCEER             /* DFS */\n IOEDFSXP             /* DAEMON PER IBM */\n IOEFTS               /* DFS */\n IOEGRWAG             /* DFS */\n IOEMAPID             /* DFS */\n IOENEWAG             /* DFS */\n IOESALVG             /* DFS */\n IOESCOUT             /* DFS */\n IOEUDBG              /* DFS */\n IOEZADM              /* DFS */\n IRRDPI00             /* RACF DYNAMIC PARSE */\n IRRDSC00             /* RACF DATABASE RESTRUCTURE */\n IRRUT100             /* RACF CROSS-REFERENCE PGM */\n IRRUT200             /* RACF DATABASE VERIFY PGM */\n IRRUT400             /* RACF DATABASE SPLIT/MERGE */\n IRRXUTI2             /* RACF UTILITY */\n ITPENTER             /* IBM    WORKLOAD SIMULATOR */\n IXCMIAPU             /* IBM LOGREC VIEWER */\n JCLCHECK EDCHEK      /* CA-JCLCHECKER */\n JCPAUT42             /* SEA JCLPLUS */\n JCPAUT43             /* SEA JCLPLUS */\n LD LISTDSD           /* RACF DISPLAY DATASET PROFILE */\n LG LISTGRP           /* RACF LIST GROUP PROFILE */\n LISTB LISTBC         /* LIST BRODCAST MESSAGES */\n LISTD LISTDS         /* LIST DATASET INFO COMMAND */\n LISTDATA LDATA       /* LIST CACHE DEVICE INFO */\n LPQ                  /* TCP/IP LINE PRINT QUERY */\n LPR                  /* LPR */\n LPRM                 /* TCP/IP LINE PRINT REMOVE JOB */\n LU LISTUSER          /* RACF DISPLAY USER PROFILE */\n MCR01IKB             /* MAINSTAR CR */\n MODDVIPA             /* VIPA CREATE/DELETE */\n MVPXDISP             /* TCP/IP DEBUG AID */\n MXITSF               /* MXI EXCUTL.MXI.** CBT409/10*/\n NAVGRAPH             /* BMC PARAMOUNT */\n NDVRC1               /* ENDEVOR */\n OPER                 /* TSO OPERATOR COMMAND */\n OPERATOR             /* TSO OPERATOR COMMAND */\n OPSCMD OC            /* CA-OSP/MVS II */\n OPSCONSL             /* CA-OSP/MVS II */\n OPSOSCMD             /* CA-OSP/MVS II */\n OPSREPLY             /* CA-OSP/MVS II */\n OPSWTO               /* CA-OSP/MVS II */\n PARMLIB IKJPRMLB     /* LIST ACTIVE PARMLIB TSO INFO */\n PASSWORD PW          /* RACF CHANGE PASSWORD */\n PDSCLEAN             /* PDSCLEAN - CBTTAPE FILE 693*/\n PE PERMIT            /* RACF PERMISSIONS */\n PHRASE               /* RACF ASSIGN PASS-PHRASE */\n PING                 /* TCP/IP PING */\n PMGLAUTH             /* BMC RESOLVE PERFORMANCE MONITOR*/\n PRCALTSR             /* BMC SOFTWARE, INC */\n PRINT                /* IDCAMS PRINT */\n PRINTDS PR           /* TSO PRINT DATASET */\n IKJEFY50             /* TSO PRINT DATASET */\n PROFILE PROF         /* TSO PROFILE DISPLAY */\n PTLTSRB              /* PLATINUM DB2 */\n QQD$AUTH             /* SAMS:DEFRAG */\n RACDCERT             /* RACF MANAGE CERTS */\n RACLINK              /* RACF MANAGE LINKS */\n RACMAP               /* RACF MAP COMMAND */\n RACONVRT             /* CONVERT UADS TO RACF FORMAT*/\n RACPRIV              /* RACF PRIVILEGE DISPLAY */\n RALT RALTER          /* RACF ALTER */\n RDEF RDEFINE         /* RAC PROTECT RESOURCES AND GAC */\n RDEL RDELETE         /* RACF REMOVE RESOURCES AND GAC */\n RE REMOVE            /* RACF DELETE USERS FROM GROUP */\n RECEIVE              /* RECEIVE JES SPOOL DATA */\n REPRO                /* IDCAMS COPY/REPRO COMMAND */\n REVVSAM              /* REVIEW VSAM CBT F134/135 */\n RL RLIST             /* RACF DISPLAY RESOURCE PROFILE */\n RMM                  /* IBM RMM PRIMARY COMMAND */\n RQUERY               /* PPRC CMNDS */\n RSDTASK              /* RSD: EOS INTERFACE MODU LE */\n RSESSION             /* PPRC CMNDS */\n RSH                  /* TSO REMOTE COMMAND */\n RSI250               /* BMC SOFTWARE, INC */\n RVARY                /* RACF CONTROL RACF OPERATION */\n RVOLUME              /* PPRC CMNDS */\n SARSMFT              /* CAVIEW */\n SCCAUTH              /* BMC RECOVER MGR */\n SE SEND              /* SEND USER MESSAGE COMMAND */\n SETCACHE SETC        /* MANAGE CACHE DEVICES */\n SETR SETROPTS        /* RACF SET OPTIONS */\n SGCFINTF             /* BMC SOFTWARE, INC */\n SGZILLA              /* BMC SOFTWARE, INC */\n SHCDS                /* VSAM RLS */\n SHOWZOS              /* Z/OS INFO DISPLAY CBT 492 */\n SI067DC0             /* CATALOG RECOVERY PLUS */\n SR SEARCH            /* RACF SEARCH PROFILES */\n STATUS ST IKJEFFCA   /* TSO STATUS OF JOBS */\n STEPLIB              /* DYNAMIC STEPLIB - CBT 452 */\n SUBMIT SUB           /* TSO SUBMIT JCL */\n SYNC                 /* SYNC UADS AND BRODCAST DSNS*/\n SYSPROG              /* BMC */\n TERM                 /* TSO TERMINAL COMMAND */\n TERMINAL             /* TSO TERMINAL COMMAND */\n TESTAUTH TESTA       /* TEST AUTHORIZED CMDS/PGMS */\n TMSIOCAP             /* CA-1 TMS */\n TMSSCR               /* CA-1 TMS */\n TRACERTE             /* TRACE TCP/IP ROUTE */\n TRANSMIT XMIT        /* JES DATASET TRANSMIT CMD */\n TSS                  /* TOP SECRET */\n USTATUS              /* FDR UPSTREAM */\n USTCMD               /* FDR UPSTREAM */\n USTDUPRT             /* FDR UPSTREAM */\n USTMONA              /* FDR UPSTREAM */\n USTRPORT             /* FDR UPSTREAM */\n VERIFY               /* TSO VERIFY COMMAND */\n VFY                  /* TSO VERIFY COMMAND */\n VHCR190$             /* HIPER-CACHE */\n VLFNOTE              /* notify VLF of update */\n VMCF60               /* VPS MON & CON FAC */\n VMCF62               /* VPS MON & CON FAC */\n VPEHSAUT             /* CA-DOCVIEW/VPE */\n VSAMASST             /* Rocket Software VSAM Assist */\n XADDPAIR             /* XRC CMNDS */\n XADVANCE             /* XRC CMNDS */\n XCOUPLE              /* XRC CMNDS */\n XDELPAIR             /* XRC CMNDS */\n XEND                 /* XRC CMNDS */\n XQUERY               /* XRC CMNDS */\n XRECOVER             /* XRC CMNDS */\n XSET                 /* XRC CMNDS */\n XSTART               /* XRC CMNDS */\n XSTATUS              /* XRC CMNDS */\n XSUSPEND             /* XRC CMNDS */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/CBT.V500.FILE312.PDS/CHKIKJ.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312/CBT.V500.FILE312.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}