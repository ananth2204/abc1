{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20170426145040000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 32720, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "T311LBD.REXXFORM.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.REXXFORM.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 32720, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 65520, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "170116", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x0f'", "DS1LSTAR": "b'\\x00\\x02\\x08'", "DS1TRBAL": "b'O\\xd2'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0e \\x00\\x04\\x97\\xc0`'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0e \\x00\\x04\\x97\\xc0`'", "b'X\\x97u\\x08\\x00\\x00\\x00\\xdf\\x00\\x07\\x00\\xdf\\x00\\t\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$README": {"ttr": 519, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x03 !\\x01\\x17\\x10\\x7f\\x01\\x17\\x11o\\tP\\x00\\r\\x00\\x0b\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xc6\\xd6\\xd9\\xd4\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.03", "flags": 32, "createdate": "2017-04-17T00:00:00", "modifydate": "2017-04-26T09:50:21", "lines": 13, "newlines": 11, "modlines": 0, "user": "REXXFORM"}, "text": "This PDS contains the XEDIT REXXFORM command that has been\nconverted to work as an ISPF Edit command.\n\nThe members are:\n\n   HELP     - TSO Help for REXXFORM\n              Copy into a HELP dataset and name it REXXFORM\n   REXXFORM - The ISPF Edit command\n              Copy into a dataset in the SYSEXEC library\n   #RXFM*   - ISPF Tutorial Panels - called with REXXFORM ?\n              Copy into ISPF Panels library\n\nUsage - under ISPF Edit or View\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#RXFM": {"ttr": 515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00 \\x01\\x17\\x10\\x7f\\x01\\x17\\x11O\\tA\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xc6\\xd6\\xd9\\xd4@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-04-17T00:00:00", "modifydate": "2017-04-24T09:41:20", "lines": 31, "newlines": 31, "modlines": 0, "user": "REXXFORM"}, "text": ")ATTR DEFAULT(%+_)\n   %   TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n   +   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(GREEN)\n   _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) HILITE(USCORE)\n)BODY EXPAND(\\\\)\n%Tutorial+-\\-\\-(%REXXFORM - Edit Macro+)-\\-\\-%Tutorial\n%Command ===>_ZCMD\n+\n% REXXFORM+is an ISPF edit macro used to format REXX EXECs by indenting\n+ DO and SELECT groups and left-justifying lines at a selected column.\n+ REXXFORM also checks for unbalanced DO and SELECT statements.\n+\n+Syntax: %REXXFORM left-margin indent ( options\n+\n%  left-margin  +The column where all lines are left justified.\n+                Default 4\n+\n%  Indent       +The column DO and SELECT statements are indented\n+                from the left-margin.\n+                Default 3\n+\n+Options:\n+\n%  CI           +Justify comments records to the left-margin column\n%  CJ           +Justify comments records to the column 1\n+\n+\n+ \\ \\ (press%ENTER+to continue) \\ \\\n)PROC\n &ZCONT = #RXFM1\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "#RXFM1": {"ttr": 517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x01\\x17\\x11O\\x01\\x17\\x11O\\tG\\x00\\x1f\\x00 \\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xc6\\xd6\\xd9\\xd4@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2017-04-24T00:00:00", "modifydate": "2017-04-24T09:47:14", "lines": 31, "newlines": 32, "modlines": 0, "user": "REXXFORM"}, "text": ")ATTR DEFAULT(%+_)\n   %   TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n   +   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(GREEN)\n   _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) HILITE(USCORE)\n)BODY EXPAND(\\\\)\n%Tutorial+-\\-\\-(%REXXFORM - Edit Macro+)-\\-\\-%Tutorial\n%Command ===>_ZCMD\n+\n+  Record ranges may be selected by using:\n+\n%  S            +Select a single record to format\n%  SS/SS        +Select a range of records to format\n%  S#           +Select current record for # -1 (S4 is current plus 3)\n+\n+ %SS+      'Process Range S'\n+  000050   \"(startl) = linenum .zfrange\"\n+ %SS+      \"(endl) = linenum .zlrange\"\n+\n+ %S3+      'Process Range S'\n+  000050   \"(startl) = linenum .zfrange\"\n+  000051   \"(endl) = linenum .zlrange\"\n+\n+\n+\n+\n+\n+\n+ \\ \\ (press%ENTER+to continue) \\ \\\n)PROC\n &ZUP = #RXFM\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HELP": {"ttr": 18, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x06 \\t\\x01\\x17\\x10\\x9f\\x01\\x17\\x10\\x9f\\x063\\x00`\\x00`\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xc6\\xd6\\xd9\\xd4\\x00\\x00\\x00`\\x00\\x00\\x00`\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.06", "flags": 32, "createdate": "2017-04-19T00:00:00", "modifydate": "2017-04-19T06:33:09", "lines": 96, "newlines": 96, "modlines": 0, "user": "REXXFORM"}, "text": ")F REXXFORM\n\n  REXXFORM is an ISPF edit macro used to format REXX EXECs by indenting\n  DO and SELECT groups and left-justifying lines at a selected column.\n  It also checks for unbalanced DO or SELECT statements.  One use of\n  this ISPF edit macro is to uniformly restructure REXX files after\n  composing them without regard for any particular format or standard\n  coding style.\n\n)X Syntax\n\n  REXXFORM <left-margin indent>  <( <CJ> <CI> >\n\n)O Operands\n\n))Left-Margin\n\n   Specifies that all lines are either left-justified at this column, or\n   indented one or more columns to the right of this column.  The column\n   given by this argument must be a positive number not exceeding the\n   width of the file.  If not given, it is assumed to be 4.\n\n))Indent\n\n   Specifies how many columns each DO or SELECT group is to be indented\n   to the right of the left-margin given by the first argument.  As each\n   DO or SELECT is encountered, the margin is moved \"indent\" to the\n   right.  As each END is encountered, the margin is moved \"indent\" to\n   the left.  If \"indent\" is not given, it is assumed to be 3.  If\n   \"indent\" is 0, the set of specified lines is left-justified at the\n   column \"left-margin\".\n\n))Options\n\n  Comment lines and lines that are part of a comment are not shifted\n  unless CJ or CI is given.  The option CI causes these lines to be\n  indented like all other lines, and CJ causes them to be left-justified\n  at column 1.\n\n))USAGE NOTES:\n\n  The TRUNC setting is the active right boundary as determined by the\n  ISPF BNDS setting. This can be viewed by entering BNDS on any lines\n  record number. The default is the current record length, taking into\n  considerations if numbering is enabled.\n\n  If REXXFORM attempts to indent a line past the current TRUNC setting,\n  it will first see if the line contains a REXX comment, and if so, try\n  to shift the comment left. Thus if the line:\n\n     a = 23                         /* Set our initial hamster value */\n\n  must be indented six spaces, and the end of the comment is already at\n  the TRUNC setting, REXXFORM would produce this:\n\n         a = 23                     /* Set our initial hamster value */\n\n  If REXXFORM cannot indent the comment far enough (or the line does not\n  contain a comment), it will not indent the line, but will instead\n  issue a warning message including the line number.\n\n  When REXXFORM completes, it will display the line numbers of lines\n  containing unbalanced DOs, SELECTs, or ENDs.  In some cases, it will\n  detect that a comment or string is unbalanced (terminal '*/' or ending\n  quote-mark missing).\n\n  REXXFORM without arguments is equivalent to \"REXXFORM 4 3\".\n\n  REXX labels are indented one level to the left (if possible) to make\n  the program more legible.\n\n  REXXFORM does not check keyword syntax.  Thus, any unquoted and\n  uncommented DO, SELECT or END word will affect the indentation.  In\n  addition, quoted strings that exceed the maximum limit are not\n  detected.  To check such syntactical constructs, use the initial REXX\n  instruction \"trace scan\".  The worst that can happen is that the\n  indentation will not be consistent throughout the unsaved file with an\n  message display about some unbalanced DO, SELECT, or END construct.\n\n  This macro only reformats the specified lines by adding or deleting\n  leading blanks according to the arguments given.  No new lines are\n  added and no data other than leading blanks are affected.  In\n  particular, non-leading blanks are not affected.  However, as for any\n  macro that changes your active file, you may wish to make a temporary\n  copy if you are not sure that the result will be acceptable.\n\n)Origin\n\n  This command and help file were converted from the XEDIT version to\n  run as an ISPF edit macro and TSO help file.\n\n  Original author: Jeffery Almoney\n  Other Updates:   Robert Fowles\n                   Phil Smith III\n                   Denis J. Audet\n  ISPF Conversion: Lionel B. Dyck\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXFORM": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00Q\\x01\\x17\\x10O\\x01\\x17\\x11o\\tB\\x01F\\x01$\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xc6\\xd6\\xd9\\xd4@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2017-04-14T00:00:00", "modifydate": "2017-04-26T09:42:51", "lines": 326, "newlines": 292, "modlines": 0, "user": "REXXFORM"}, "text": "  /*********************** rexx ****************************************\n   *\n   *   ROUTINE:      REXXFORM\n   *\n   *   PURPOSE:      Structure/indent REXX execs\n   *\n   *   AUTHOR:       Robert Fowles, 02/04/84\n   *                 (based on original exec by Jeffery Almoney)\n   *                 Pennsylvania State University\n   *                 Center for Academic Computing\n   *                 107 Computer Building\n   *                 University Park, PA  16802\n   *                 814 865-4774\n   *                 SHARE Installation code: PSU\n   *                 Bitnet: RBF@PSUVM\n   *                 Internet: RBF@PSUVM.PSU.EDU\n   *\n   *   REVISIONS:\n   *    11/20/90 RBF Include changes made in 07/25/85 by Denis J. Audet,\n   *                 Computing Centre, Univ of Ottawa: refine\n   *                 detection of comments and quotes across split\n   *                 lines, prevent truncation.  Make changes based on\n   *                 ideas from PHS3@WATDCS.\n   *    11/20/90 RBF Change syntax to allow: reformatting of selected\n   *                 parts of file; left margin for all lines.  Move\n   *                 Help info to Help File.\n   *    12/16/90 RBF Change name to REXXFORM (old name REXFORM).\n   *    03/17/91 RBF Add more syntax checking.\n   *    06/04/99 PHS Fix continuation detection after end-of-line comment;\n   *                 try to adjust end-of-line comments to make lines fit;\n   *                 mark unfittable lines via SET SELECT.\n   *    06/15/02 PHS Fix lines starting with literal ending in \":\"\n   *    04/14/17 LBD Update to work as an ISPF Edit Macro\n   *    04/17/17 LBD Clean up and change ? to call ISPF Tutorial Panel\n   *                 Remove target\n   *                 Fix not processing the last record\n   *                 Change messages to ispf message lines\n   *                 Add max line length to report out\n   *    04/18/17 LBD Add message about options in use\n   *                 Use right boundary for truncation instead of lrecl\n   *    04/24/17 LBD Support record selection S/SS/S#\n   *********************************************************************/\n   Address ISREdit\n   'macro NOPROCESS (a)'\n\n   if a='?' then call Help\n   signal on syntax\n\n   'Process Range S'\n   \"(startl) = linenum .zfrange\"\n   \"(endl) = linenum .zlrange\"\n   'reset'\n   startl = startl + 0\n   endl   = endl   + 0\n   '(left truncl) = bounds'\n   maxlinel = 0\n   docnt = 0;selcnt = 0;endcnt = 0;trunccnt = 0\n   truncrec = ''\n\n   cj=0; ci=0;\n   call ScanOpts\n   com=0; dqu=0; squ=0; indent=0; cont=0; unbal=''; lines=0;\n   ds='';   /* Line-number stack for DO's and SELECT's.              */\n   es='';   /* Line-number stack for END's.                          */\n   do i=startl to endl\n      lines=lines+1\n      '(line) = line' i\n      line = strip(line,'T')\n      sline=strip(line,'L')\n      if sline=' ' then iterate i\n      w1=' 'translate(word(sline,1))\n      parse var w1 w1 \"'\"\n      parse var w1 w1 '\"'\n      lw=translate(word(line,words(sline)))\n      j = Lscan(sline)\n      if j>0 then lastdo=i\n      else if j<0 then indent=indent+j\n      if indent<0 then indent=1\n      if dqu > 0 | squ > 0 then do\n         if dqu = 2 then dqu = 0\n         if squ = 2 then squ = 0\n         iterate\n      end\n      else do\n         if com>0 then do\n            if cj then repline= sline\n            else if ci then repline=,\n              substr(' ',1,lm+(indent)*in) || sline\n            else repline= line\n            if com>1 then com=0\n         end\n         else\n         if (substr(w1,length(w1),1)=':' | word(line,2)=':') &,\n           index(w1, \"'\") = 0\n         then repline=substr(' ',1,max(0,lm+(indent-1)*in))||sline\n         else\n         repline= substr(' ',1,lm+cont+indent*in)||sline\n         if length(repline) > truncl then        /* It won't fit ... */\n         if right(line, 2) == '*/' then do          /* Try to fix it */\n            xyzzy = length(repline) - length(line) /* Get l'overflow */\n            plugh = index(repline, copies(' ', xyzzy)' /* ') /* Cmt? */\n            if plugh > 0 then     /* Got comment start & end, fix it */\n            repline = delstr(repline, plugh, xyzzy) /* Delete blanks */\n         end\n\n         if length(repline) > truncl then do /* It still won't fit */\n            'line_after' i ,\n              '= msgline  \">> Above record would be truncated <<\"'\n            trunccnt = trunccnt + 1\n            truncrec = truncrec i\n         end\n         else if repline == line then nop\n         else 'line' i ' = (repline)'\n         if maxlinel < length(repline)\n         then maxlinel = length(repline)\n         if com == -1 then com = 1\n         else if dqu == -1 then dqu = 1\n         else if squ == -1 then squ = 1\n         else if substr(lw,length(lw))=',' then cont=2\n         else cont=0\n      end\n      if j>0 then indent=indent+j\n   end\n\n   'up m'\n   if startl > 1 then 'down' startl - 1\n\n   'line_before' startl ' = msgline \"REXXFORM REXX Code Reformat Command\"'\n   hopt = ''\n   if ci then hopt = 'and CI'\n   if cj then hopt = 'and Cj'\n   'line_before' startl ' = msgline \"Options:  Left:' lm+1 'Indent:' in ,\n     hopt '\"'\n   if es<>'' then do\n      'line_before' startl ' = msgline \"Unbalanced ENDs at lines:' es '\"'\n   end\n   if ds<>'' then do\n      nds=''\n      do i=1 to words(ds)\n         nds=word(ds,i) nds\n         'line_after' word(ds,i) '= msgline' ,\n           '\">> Above record is unbalanced DO or SELECT <<\"'\n      end\n      'line_before' startl ,\n        ' = msgline \"Unbalanced DOs or SELECTs at lines:' nds '\"'\n   end\n   if com>0 then\n   'line_before' startl ' = msgline \"Unbalanced comment\"'\n   if squ+dqu>0 then\n   'line_before' startl ' = msgline \"Unbalanced string comment\"'\n   if trunccnt > 0 then\n   'line_before' startl ' = msgline \"Potential Truncation' ,\n     'at lines:' truncrec '\"'\n   'line_before' startl ' = msgline \"Lines restructured from' ,\n     startl 'to' endl'\"'\n   'line_before' startl ' = msgline \"Longest record of' maxlinel '\"'\n   'line_before' startl ' = msgline \"Counts Do:' docnt ,\n     'Select:' selcnt 'End:' endcnt '\"'\n   exit 0\n\nScanOpts:\n   a = translate(a)\n   i=pos('(',a)\n   if i>0 then if pos('(',a,i+1)>0\n   then call Errstop 'Left parentheses not allowed operandss'\n   parse var a lm in r '(' opts\n   if lm = '' then lm = 4\n   if in = '' then in = 3\n   if datatype(lm,'W')=0 | datatype(in,'W')=0 then call Errstop,\n     'Left margin and Indent values must be whole numbers'\n   if lm<0 | in<0 then call Errstop,\n     'Left margin and Indent values cannot be negative'\n   if r<>'' then call Errstop 'Incorrect arguments'\n   if lm+in>truncl then call Errstop,\n     'Left margin plus Indent value cannot exceed the TRUNC setting'\n   if lm=0 then call Errstop 'Left margin value must be greater than 0'\n   if lm>truncl\n   then call Errstop 'Left margin can''t exceed TRUNC setting'\n   lm=lm-1\n   do i=1 to words(opts)\n      s=word(opts,i)\n      select\n         when s='CJ' then cj=1\n         when s='CI' then ci=1\n         otherwise call ErrStop 'Incorrect arguments'\n      end\n   end\n   'up m'\n   return\n\nLscan: Procedure expose com dqu squ i ds es lw ,\n     docnt selcnt endcnt trunccnt\n   arg s\n   Select\n      when com=1 then do\n         k= pos('*/',s)\n         if k>0 then do\n            s= substr(s,k+2)\n            com=2\n         end\n         else return 0\n      end\n      when dqu=1 then do\n         k= pos('\"',s)\n         if k>0 then do\n            s= substr(s,k+1)\n            dqu=2\n         end\n         else return 0\n      end\n      when squ=1 then do\n         k= pos(\"'\",s)\n         if k>0 then do\n            s= substr(s,k+1)\n            squ=2\n         end\n         else return 0\n      end\n      otherwise nop\n   End\n   qu = 0\n   do until s2 = '' | s = ' '\n      ls = 1+length(s)\n      kcom = pos('/*',s)\n      if kcom=0 then kcom=ls\n      kdqu = pos('\"',s)\n      if kdqu=0 then kdqu=ls\n      ksqu = pos(\"'\",s)\n      if ksqu=0 then ksqu=ls\n      select\n         when kcom<kdqu & kcom<ksqu then do\n            if pos('*/',s,kcom+2) = 0 then do\n               com = com-1\n               parse var s s '/*'\n               s2 = ''\n            end\n            else do\n               parse var s s1 '/*' s2 '*/' s3\n               s2 = '*'\n               s=s1 s3\n               /* The following is to fix continuation detection when\n               the line ends in a comment.\n               */\n               if s <> '' then            /* If we have anything ... */\n               lw=translate(word(s,words(s)))   /* ...reset lastword */\n            end\n            iterate\n         end\n         when ksqu<kdqu then do\n            qu = 1\n            if pos(\"'\",s,ksqu+1) = 0 then do\n               squ = squ-1\n               parse var s s \"'\"\n               s2 = ''\n            end\n            else do\n               parse var s s1 \"'\" s2 \"'\" s3\n               s2 = '*'\n               s=s1 s2 s3\n            end\n            iterate\n         end\n         when kdqu<ksqu then do\n            qu = 1\n            if pos('\"',s,kdqu+1) = 0 then do\n               dqu = dqu-1\n               parse var s s '\"'\n               s2 = ''\n            end\n            else do\n               parse var s s1 '\"' s2 '\"' s3\n               s2 = '*'\n               s=s1 s2 s3\n            end\n            iterate\n         end\n         otherwise s2 = ''\n      end\n   end\n   if s = '' then do\n      if qu=0 & com<1 & dqu=squ then com = com + 2\n      return 0\n   end\n   k = 0\n   s=translate(s,' ',';')\n   do j=1 to words(s)\n      w=word(s,j)\n      select\n         when w='DO' then do\n            docnt = docnt + 1\n            k=k+1; ds=i ds;\n         end\n         when w='SELECT' then do\n            selcnt = selcnt + 1\n            k=k+1; ds=i ds;\n         end\n         when w='END' then do\n            endcnt = endcnt + 1\n            k=k-1;\n            if ds='' then do\n               es=es i\n               'line_after' i ,\n                 '= msgline  \">> Above record is unbalanced END <<\"'\n            end\n            ds=delword(ds,1,1);\n         end\n         otherwise nop\n      end\n   end\n   return k\n\nErrstop:\n   parse arg m\n   say m\n   exit 16\n\nHelp:\n   Address ISPExec 'Select PGM(ISPTUTOR) Parm(#RXFM)'\n   exit 0\n\nSyntax:\n   rr = rc\n   say 'REXXFORM LINE:' sigl sourceline(sigl)\n   say '+++' errortext(rr)\n   say '>>> error at file line 'i\n   exit 16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/CBT.V500.FILE312.PDS/REXXFORM.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312/CBT.V500.FILE312.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}