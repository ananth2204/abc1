{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20180214134752000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "T311LBD.PRINT.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.PRINT.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "180045", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x02'", "DS1LSTAR": "b'\\x00\\x07\\x05'", "DS1TRBAL": "b'G\\xda'"}, "COPYR2": {"deb": "b'\\x04\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x13 \\x00\\x04\\x98;\\xd8'", "extents": ["b'\\x04\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x13 \\x00\\x04\\x98;\\xd8'", "b'X\\x9f\\x8d\\xc0\\x00\\x00\\x01\\xd6\\x00\\n\\x01\\xd6\\x00\\x0c\\x00\\x03'", "b'X\\x9f\\x8d\\xc0\\x00\\x00\\x01\\xd6\\x00\\r\\x01\\xd6\\x00\\x0e\\x00\\x02'", "b'X\\x9f\\x8d\\xc0\\x00\\x00\\x00\\xc5\\x00\\x02\\x00\\xc5\\x00\\x03\\x00\\x02'", "b\"X\\x9f\\x8d\\xc0\\x00\\x00\\x01'\\x00\\x00\\x01'\\x00\\x01\\x00\\x02\"", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x000\\x00\\x99\\x06\\x8f\\x01\\x18\\x04_\\x07E\\x00\\x1b\\x00\\x1b\\x00\\x00\\xd7\\xd9\\xc9\\xd5\\xe3@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-09T00:00:00", "modifydate": "2018-02-14T07:45:30", "lines": 27, "newlines": 27, "modlines": 0, "user": "PRINT"}, "text": "This dataset contains 2 ISPF dialogs and an ISPF Edit Command:\n\nLPREDIT  - ISPF Edit command to invoke LPRPRINT on the current\n           data (be sure to save first)\nLPRPRINT - used to print using the z/OS TCP/IP LPR command to\n           any system with a LPD server.  This includes intelligent\n           printers which have LPD built-in.  All ISPF Elements are\n           inline within the EXEC.\nPSPRINT  - used to format host output for printing on a PostScript\n           printer and then invoke LPRPRINT.  Options include Portrait,\n           Landscape, and 2UP printing.\n\nThe members of this dataset are in IEBUPDTE format.\n\n$DOC     - What you are reading\nEXEC     - The above 2 rexx execs which are the entry points to the dialogs\nMSGS     - ISPF messages for PSPRINT\nPANELS   - ISPF panels, including brief tutorials, for PSPRINT\n\nNo warranty comes with these dialogs - use them at your own risk.  They\nmay require customization to work in your environment.\n\nComments, suggestion, and an occasional (not too many) complaints are\nwelcome to the author:\n\nLionel B. Dyck\ne-mail: lbdyck@gmail.com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXEC": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x00\\x99\\x06\\x8f\\x01\\x18\\x04_\\x07\\x14\\x04b\\x01\\xef\\x00\\x00\\xd7\\xd9\\xc9\\xd5\\xe3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-09T00:00:00", "modifydate": "2018-02-14T07:14:41", "lines": 1122, "newlines": 495, "modlines": 0, "user": "PRINT"}, "text": "./ ADD NAME=LPRPRINT\n/* ---------------------  rexx procedure  ---------------------- *\n * Name:      LPRPrint                                           *\n *                                                               *\n * Function:  Invoked by the user or via another ISPF dialog     *\n *            to invoke the LPRPRINT ISPF Panel and then use     *\n *            the TCP/IP LPR command to print the specified      *\n *            data set on a TCP/IP connected printer.            *\n *                                                               *\n *            Note that the specified Host must have LPD active  *\n *            to receive the data.                               *\n *                                                               *\n * Syntax:    %lprprint dsname                                   *\n *                                                               *\n *            dsname is optional                                 *\n *                                                               *\n * Author:    Lionel B. Dyck                                     *\n *                                                               *\n * History:                                                      *\n *            02/14/18 - Update to Tutorial panel adding &ZCONT  *\n *                     - recurse into APPL(ISR) if not           *\n *            11/03/17 - Make this a self-contained exec         *\n *                       by imbedding the panels and messages    *\n *            04/30/15 - update to add lprcopy to ispf profile   *\n *                       thx to Peter Giles who found this       *\n *            03/20/97 - save inds in profile                    *\n *            01/10/95 - Remove ack as tcp/ip 3.1 doesn't        *\n *            08/29/94 - update for Postscript option            *\n *            06/23/94 - fix parse for pds dsname                *\n *            01/21/94 - fix for pds input w/member name         *\n *            01/18/94 - add support for member selection if     *\n *                       dsname is pds and no member given       *\n *            01/17/94 - fix for invalid dsn and for messages    *\n *            01/07/94 - add option for additional user specified*\n *                       parameters other than what is directly  *\n *                       supported                               *\n *            01/04/94 - add entry optional parameter of dsn     *\n *                       and support ACK option                  *\n *            01/03/94 - updated to cleanup invocation           *\n *            12/22/93 - creation of application                 *\n *                                                               *\n * ------------------------------------------------------------- */\n\n arg inds\n\n/* ----------------------------- *\n | Get into ISPF Addressing mode |\n * ----------------------------- */\n Address ISPExec\n\n/* -------------------------------------------------- *\n * Test for our ISPF Applid and if not then:          *\n * - re-invoke ourselves with our APPLID              *\n * - upon return exit                                 *\n * -------------------------------------------------- */\n \"Vget (Zapplid)\"\n \"Control Errors Return\"\n if zapplid <> \"ISR\" then do\n     \"Select CMD(%\"sysvar('sysicmd') inds \") Newappl(ISR)\" ,\n         \"Passlib\"\n    exit 0\n    end\n\n/* --------------------------------------------- *\n | Dynamically load the ISPF Panels and Messages |\n * --------------------------------------------- */\n load_info = loadispf()\n\n/* ------------------------------------- *\n | Display the LPRPRINT Panel until Exit |\n * ------------------------------------- */\n do forever\n/* ---------------------------------- *\n | Get the variables from the profile |\n * ---------------------------------- */\n   \"VGET (lprdest lprhost lprbin lprcc lprntfy lprlcnt lprhead \",\n         \"lprcopy lprburst lprntfy lprps lpruopt lprpinds) Profile\"\n    if length(inds) > 0 then lprpinds = inds\n    \"Display Panel(LPRPRINT)\"\n    if rc > 3 then call do_exit\n/* --------------------------------- *\n | Svae the variables in the profile |\n * --------------------------------- */\n   \"VPUT (lprdest lprhost lprbin lprcc lprntfy lprlcnt lprhead \",\n         \"lprcopy lprburst lprntfy lprps lpruopt lprpinds) Profile\"\n\n/* ------------------------------- *\n | Validate the input dataset name |\n * ------------------------------- */\n if sysdsn(lprpinds) <> \"OK\" then do\n    lprsmsg = \"Error\"\n    lprlmsg = \"Specified data set does not exist:\" lprpinds\n    \"Vput (lprsmsg lprlmsg)\"\n    \"SETMSG MSG(LPR002)\"\n    end\n else do\n     /* ------------------------------------ *\n      | DSN Valid - now setup for Processing |\n      * ------------------------------------ */\n      parse value \"\" with binary cc mail line_count header burst,\n                     copies postscr\n      if lprbin   = \"Yes\" then binary = \"Binary\"\n      if lprcc    = \"Yes\" then cc     = \"CC\"\n                          else cc     = \"NOCC\"\n      if lprntfy  = \"Yes\" then mail   = \"Mail\"\n      if lprhead  = \"No\"  then header = \"NoHeader\"\n      if lprburst = \"No\"  then burst  = \"NoBurst\"\n      if lprcopy  > 1     then copies = \"Copies\" lprcopy\n      if lprlcnt  > 0     then line_count = \"Linecount\" lprlcnt\n      if lprps    = \"Portrait\"  then postscr = \"Postscript\"\n      if lprps    = \"Landscape\" then postscr = \"Landscape\"\n\n      x = listdsi(lprpinds)\n      if pos(\"(\",lprpinds) > 0 then sysdsorg = \"PS\"\n      Select\n        When sysdsorg = \"PS\" | pos(\"(\",lprpinds) > 1\n             then call do_lpr lprpinds\n        When sysdsorg = \"PO\"\n             then call do_pds\n        Otherwise nop;\n      end\n      end\n end\n\n/* --------------------------------------------- *\n | If a PDS and no Member then prompt for Member |\n * --------------------------------------------- */\n do_pds:\n    \"Lminit Dataid(dataid) Dataset(\"lprpinds\") Enq(Shrw)\"\n    \"Lmopen Dataid(\"dataid\") Option(Input)\"\n    \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n      \"Commands(Any) Panel(LPRPM)\"\n      do while rc == 0\n         Call process_selection\n        \"Lmmdisp Dataid(\"dataid\") Option(Get)\"\n         if rc == 8\n            then \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n                 \"Commands(Any) Panel(LPRPM)\"\n      end\n      \"Lmmdisp Dataid(\"dataid\") Option(Free)\"\n      \"Lmclose Dataid(\"dataid\")\"\n      \"Lmfree  Dataid(\"dataid\")\"\n    return\n\n process_selection:\n    if left(lprpinds,1) = \"'\"\n       then parse value lprpinds with \"'\" w_dsn \"'\"\n       else w_dsn = sysvar(\"syspref\")\".\"lprpinds\n    zlmember = strip(zlmember)\n    Select\n    When zllcmd = \"/\" | zllcmd = \"S\"\n    Then do\n      \"Lmmdisp Dataid(\"dataid\") Option(Put) Member(\"zlmember\")\",\n          \"Zludata(printed)\"\n      call do_lpr \"'\"w_dsn\"(\"zlmember\")'\"\n      end\n    When zllcmd = \"B\"\n    Then \"Browse Dataid(\"dataid\") Member(\"zlmember\")\"\n    Otherwise nop;\n    End\n    return\n\n/* ------------------------------------------------- *\n | Execute the LPR command to do the actual printing |\n * ------------------------------------------------- */\n do_lpr:\n    arg dsn\n   cmd = \"LPR\" dsn \"(Printer\" lprdest \"Host\" lprhost \"Type\",\n         binary cc mail line_count header burst copies ,\n         postscr lpruopt\n   Address TSO  cmd\n   if sysdsorg <> \"PS\" then return\n   lprsmsg = \"\"\n   lprlmsg = lprpinds \"printed to\" lprdest \"at\" lprhost\n  \"Vput (lprsmsg lprlmsg)\"\n  \"SETMSG MSG(LPR002)\"\n   return\n\n/* ------------ *\n | Exit routine |\n * ------------ */\n Do_Exit:\n    Address ISPEXEC\n    do until length(load_info) = 0\n       parse value load_info with dd libd load_info\n       \"libdef\" libd\n       address tso \"free f(\"dd\")\"\n       end\n    exit\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n Select\n    When type = \"Clist\" then\n         \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n         \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n         \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n         \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n         \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n    end\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n return\n/*\n>START\n>PANEL LPRPH0\n)Attr Default(@+_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type(text) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   $ type(output) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(turq)\n   @ type(text) intens(high)\n   + type(text  ) intens(low )\n     skip(on)\n   # area(SCRL) Extend(ON)\n)Body\n+------------------! Print Data via TCP/IP LPR Information +--------------------\n@Command ===>_zcmd\n@\n+\n#help -------------------------------------------------------------------------#\n)Area Help\n`    Information on Printing to TCP/IP Connected Printers using LPR\n~\n~    This ISPF application provides an easy to use interface for printing\n~    user data on printers that are remotely attached via the TCP/IP network.\n~\n~    LPR is the TCP/IP Line Printer client command that prints the user\n~    information on a remote printer connected via the TCP/IP network.  It\n~    communicates to the LPD (Line Printer server) on a remote Host on\n~    which the requested printer is attached.\n~\n~    The information that is asked for on the panel is:\n~\n`    Input Data Set      ===>\n~\n~    This is the data set name that contains the information that is to be\n~    printed on the remote printer.  The format is:\n~\n~              user.data\n~              user.data(member)\n~              'prefix.user.data'\n~\n`    Printer Name        ===>\n~\n~    This is the name of the printer as it is identified to the Host\n~    on which the printer is attached.\n~\n~       e.g.   lpt1\n~              IBM4019L\n~\n`    Host Name (node)    ===>\n~\n~    This is the TCP/IP Host Name on which the LPD (Line Printer server)\n~    is active that owns the specified printer.\n~\n~       e.g.   iscprint.rockwell.com\n~\n`    Binary              ===>\n~\n~    Used to specify if the user data is to be translated from EBCDIC\n~    to ASCII.  Specify`Yes~if the data is already in ASCII format and\n~    is not to be translated by the LPR command.\n~\n`    Carriage Control    ===>\n~\n~    Specify`Yes~if the data to be printed contains carriage control\n~    and the DCB of the data set does not indicate this fact.  Otherwise\n~    specify`No~.  If the DCB contains carriage control then it will be\n~    used.\n~\n`    Copies              ===>\n~\n~    Indicates the number of copies of the data to be printed.\n~\n`    Lines per Page      ===>\n~\n~    Indicates the number of lines of data per page to be printed before\n~    a new page is forced.  By specifying 0 the maximum number of lines\n~    per page allowed by the printer will be printed.\n~\n`    Header Info         ===>\n~\n~    Indicates if you want a header printed with the name of the data set\n~    being printed on the top of every page.  Only for No Binary and No CC.\n~\n`    Burst Page          ===>\n~\n~    Indicates if you want a banner page to be printed before your\n~    data.  This page is used as a separator page between multiple\n~    print requests and contains the ISPF Host Name, TSO Userid, and\n~    the data set name being printed.\n~\n`    Notify Complete     ===>\n~\n~    This option will request that an electronic mail message be generated\n~    to you when the data has completed printing on the printer.\n~    !Note:`this is not supported by all versions of LPD so even if you\n~          `request the message, you may not receive it.\n~\n`    PostScript          ===>\n~\n~    This option may be Portrait, Landscape, or No.  If 'no' is specified then\n~    no Postscript control headers will be generated for printing on a Postscrpt\n~    printer.  Portrait and Landscape will cause the appropriate headers to be\n~    inserted into the data stream. `Do not use this on a true Postscript file.\n~\n`    Other Options       ===>\n~\n~    This option will allow the user to enter other LPR options that are not\n~    directly supported by this dialog.\n+\n!Note:`Use the Enter key to just scroll down this tutorial or\n`      Use key $LEFT`to scroll down and key $RIGHT`to scroll up.\n)Init\n  .cursor = zcmd\n  &left  = PFK(LEFT)\n  &right = PFK(RIGHT)\n)Proc\n &ZCONT = LPRPH0\n)end\n>PANEL LPRPRINT\n)Attr\n   @ type( input) intens(high) caps(off) just(left ) pad('_')\n     color(blue)\n   ! type( input) intens(high) caps(off) just(left ) color(blue)\n   _ type( input) intens(high) caps(on ) just(left )\n   ^ type(text) intens(low ) caps(off) just(asis ) color(blue)\n         hilite(uscore)\n   | type(text) intens(high) caps(off) just(asis ) color(blue)\n         hilite(uscore)\n   # type(text) intens(high) caps(on) just(left ) color(yellow)\n         hilite(uscore)\n   ` type(text) intens(high) caps(off) just(asis ) color(turq)\n   ~ type(text) intens(low ) caps(off) just(asis ) color(turq)\n   % type(text) intens(low ) caps(off) just(asis ) color(blue)\n)Body\n+--------------------% Print Data via TCP/IP LPR Command +----------------------\n%Command ===>_zcmd\n`\n`Enter/Verify:\n`    Input Data Set    %===>_lprpinds                                         +\n%\n`    Printer Name      %===>!lprdest                                          +\n`    Host Name (node)  %===>!lprhost                                          +\n%\n`    Binary            %===>!lprbin+   Use if the file is already ASCII\n`    Carriage Control  %===>!lprcc+    Honor Carriage Control in Column 1\n`    Copies            %===>!lprcopy+\n`    Lines per Page    %===>!lprlcnt+  Lines per page if no CC or (0=default)\n`    Header Info       %===>!lprhead+  Generate header information\n`    Burst Page        %===>!lprburst+ Generate a burst page on the printer\n`    Notify Complete   %===>!lprntfy+  Send Mail when print complete\n`    PostScript        %===>!lprps    +Portrait, Landscape, or No\n`    Other Options     %===>@lpruopt                                           +\n`\n)Init\n .HELP = lprph0\n .cursor  = lprpinds\n &lprbin  = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcopy = trans(&lprcopy &z,1 *,*)\n &lprlcnt = trans(&lprlcnt &z,0 *,*)\n &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No\n                                  p,Portrait, l,Landscape n,No &z,No)\n)Reinit\n .cursor = lprpinds\n &lprbin  = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcopy = trans(&lprcopy &z,1 *,*)\n &lprlcnt = trans(&lprlcnt &z,0 *,*)\n &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No\n                                  p,Portrait, l,Landscape n,No &z,No)\n)Proc\n &lprbin = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No *,*)\n &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No *,*)\n &lprcopy = trans(&lprcopy &z,1 *,*)\n &lprlcnt = trans(&lprlcnt &z,0 *,*)\n &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No *,*)\n &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No\n                                  p,Portrait, l,Landscape n,No &z,No *,*)\n ver (&lprpinds,nonblank,dsname,msg=lpr001)\n ver (&lprdest,nb)\n ver (&lprhost,nb)\n ver (&lprbin,nb,list,Yes,No)\n ver (&lprcc,nb,list,Yes,No)\n ver (&lprcopy,nb,num)\n ver (&lprlcnt,nb,num)\n ver (&lprhead,nb,list,Yes,No)\n ver (&lprburst,nb,list,Yes,No)\n ver (&lprntfy,nb,list,Yes,No)\n ver (&lprps,nb,list,Portrait,Landscape,No)\n)End\n>PANEL LPRPM\n)ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)\n  | AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n  + TYPE(TEXT) INTENS(LOW)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) PAD(0)\n 01 TYPE(DATAIN) INTENS(HIGH) CAPS(ON)\n 02 TYPE(DATAOUT) INTENS(LOW)\n 03 TYPE(DATAIN)  INTENS(HIGH) CAPS(ON)\n 04 TYPE(DATAOUT)  INTENS(LOW)\n 05 TYPE(DATAOUT)  INTENS(HIGH)\n 06 TYPE(DATAOUT)  INTENS(LOW)\n)BODY WIDTH(80)\n%Member List -- &ZDSN --------------------------------------%ROW\u00a2ZMLCR%OF\u00a2ZMLTR+\n%Command ===>_ZCMD                                            %Scroll ===>_Z   +\n%Commands:      LOCATE, RESET, SELECT, SORT, HELP                              +\n%Line commands: / or S = Select, B = Browse                                    +\n&ZMLCOLS\n|ZDATA ------------------------------------------------------------------------|\n|                                                                              |\n| -----------------------------------------------------------------------------|\n)INIT\n  .ZVARS = 'ZSCML'         /* SCROLL AMT VARIABLE NAME  */\n  .HELP = ISR01130\n)PROC\n  VPUT (ZSCML) PROFILE\n)END\n /*  $M1= MEMLIST   M230     860923   158590 : FUNCTION TEST          */\n /*   PTM00000184                                                     */\n /*                                                                   */\n /*   CHANGED 3 LINES                                            3@M1C*/\n/* 5665-402 (C) COPYRIGHT IBM CORP 1980, 1989 */\n>MSG LPR00\nLPR001\n'Input data set name must be specified and must be a valid dsname'\nLPR002  '&LPRSMSG' .WINDOW=NORESP .TYPE=NOTIFY\n'&LPRLMSG'\n>END   */\n./ ADD NAME=LPREDIT\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LPREDIT                                         *\n *                                                            *\n * Function:  ISPF Edit macro to invoke LPRPRINT              *\n *            on the active data set                          *\n *                                                            *\n * Syntax:    LPREDIT                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            02/14/18 - Add NEWAPPL                          *\n *            03/20/14 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n Address ISREdit\n 'Macro'\n \"(currdsn)  = DATASET\"\n \"(currmem) = MEMBER\"\n\n if length(currmem) = 0\n    then mem = ''\n    else mem = '('currmem')'\n\n dataset = \"'\"currdsn\"\"mem\"'\"\n\n Address ISPExec 'Select cmd(%lprprint' dataset ') newappl(isr)'\n./ ADD NAME=PSPRINT\n        /* ---------------------  rexx procedure  ---------------------- *\n         * Name:      PSPRINT                                            *\n         *                                                               *\n         * Function:  Convert a text file into a PostScript print        *\n         *            stream.                                            *\n         *                                                               *\n         * Syntax:    %PSPRINT input-file output-file / options          *\n         *                                                               *\n         * where:                                                        *\n         *        input-file is the data set name of the input text file *\n         *        output-file is optional and is the data set name that  *\n         *           will contain the postscript results.                *\n         *           - if not specified this is dynamically generated.   *\n         *           - if specified the output file will not be deleted  *\n         *             at the end of processing.                         *\n         *           - if specified as @ then the ISPF dialog will be    *\n         *             invoked for additional prompting.                 *\n         *       / is the delimeter used to offset the options           *\n         *       options are optional values which may be:               *\n         *           PORT, WIDE, LAND, or 2UP for print orientation      *\n         *           DEBUG to cause tracing of the rexx program          *\n         *             during execution                                  *\n         *           NOLPR to prevent the execution of the LPRPRINT exec.*\n         *                                                               *\n         * If no parameters are entered then the ISPF Dialog is invoked. *\n         *                                                               *\n         * Defaults:                                                     *\n         *            PORT orientation and delete the output file after  *\n         *            invoking the lprprint procedure.                   *\n         *                                                               *\n         * Author:    Lionel B. Dyck                                     *\n         *            Rockwell International                             *\n         *            P.O. Box 2515                                      *\n         *            Seal Beach, California 90740                       *\n         *            (310) 797-1125                                     *\n         *            IBMMail:  USROKNTN                                 *\n         *            Internet: lbd@osreq48.rockwell.com                 *\n         *            IBMLINK:  ROK2027                                  *\n         *                                                               *\n         * History:                                                      *\n         *           02/22/96 - display dialog even if dsname provided   *\n         *           09/26/94 - minor bug fix in parse                   *\n         *           09/02/94 - Reset LPRPRINT lprps to no               *\n         *           08/25/94 - Fix test for options                     *\n         *           04/27/94 - Add prompt option                        *\n         *           01/26/94 - updated to support non-ISPF usage        *\n         *           01/20/94 - created for TSO/ISPF                     *\n         *                                                               *\n         * Originally based upon the PSPRINT.cmd                         *\n         * Written by Michael Perks (10/31/92)                           *\n         * (c) Copyright IBM Corp. 1992 All Rights Reserved              *\n         * modified to allow an option of lptn                           *\n         *                                                               *\n         * modified to run under MVS TSO/E by Lionel Dyck                *\n         * to use PostScript programming by Carl J. Lydick               *\n         * of CalTech picked up from comp.lang.postscript.               *\n         *                                                               *\n         * This eliminates the calculation of line placement and         *\n         * page ejects and provides the following options:               *\n         *                                                               *\n         * PORT -  Portrait 80 characters by 60 lines in 11 pt. Courier  *\n         * WIDE -  Portrait 132 characters by 103 lines in 6 pt. Courier *\n         * LAND -  Landscape 132 characters by 60 lines in 9 pt. Courier *\n         * 2UP  -  2 pages 80 characters by 66 lines side by side        *\n         *         in landscape in 6 pt. Courier                         *\n         *                                                               *\n         * ------------------------------------------------------------- */\n\n        parse arg psinds outname \"/\" options\n\n        outname = translate(strip(outname))\n\n        if length(psinds) >= 0 then prompt = 1\n        if outname        = \"@\" then prompt = 1\n           else if length(outname) > 0 then prompt = 0\n        if length(options) > 0 then prompt = 0\n\n        cmd = sysvar(\"sysicmd\")\n        spf = sysvar(\"sysispf\")\n\n        if prompt = 1 then do forever\n           if spf <> \"ACTIVE\" then do\n              say cmd\": Not running under ISPF and no parameters specified\"\n              say cmd\": terminating - review the documentation and retry.\"\n              exit 8\n              end\n           Address ISPEXEC\n           \"Display Panel(PSPRINT)\"\n           if rc > 3 then exit\n           if lpr = \"No\" then lpr = \"NOLPR\"\n                         else lpr = \"\"\n           if \"OK\" <> sysdsn(psinds) then do\n               smsg = \"Error\"\n               lmsg = sysdsn(psinds)\n               \"Vput (Smsg Lmsg)\"\n               \"Setmsg Msg(Pspr002)\"\n                end\n           else call test_pds\n        end\n\n        if length(options) > 0 then\n           options = translate(options)\n\n        /* test options for debug */\n        if wordpos(\"DEBUG\",options) > 1 then do\n           trace \"?i\"\n           x = wordpos(\"DEBUG\",options)\n           new_opt = delword(options,x,1)\n           options = new_opt\n           end\n\n        /* test options for nolpr */\n        if wordpos(\"NOLPR\",options) > 1 then do\n           no_lpr = \"on\"\n           no_del = \"on\"\n           x = wordpos(\"NOLPR\",options)\n           new_opt = delword(options,x,1)\n           options = new_opt\n           end\n\n        if spf <> \"ACTIVE\" then no_lpr = \"on\"\n\n        if length(outname) = 0 then do\n           d = date(u)\n           date = substr(d,7,2)substr(d,1,2)substr(d,4,2)\n           s = time(\"L\")  /* get the current time hh:mm:ss.th */\n           t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)\n           prefix = sysvar(syspref)\n           pscript_dsn = \"'\"prefix\".pscript.D\"date\".T\"t\".ps'\"\n           end\n        else do\n             pscript_dsn = outname\n             no_del = \"on\"\n             end\n\n        out. = \"\"\n\n        Select\n          When options = \"PORT\" then call do_port\n          When options = \"WIDE\" then call do_wide\n          When options = \"LAND\" then call do_land\n          When options = \"2UP\"  then call do_2up\n          Otherwise call do_port\n          end\n\n        /* test the existence of the input data set */\n        if \"OK\" <> sysdsn(psinds) then\n        do\n            smsg = \"Error\"\n            lmsg = sysdsn(psinds)\n            call do_msg\n            exit\n        end\n\n        x = listdsi(psinds)\n        if pos(\"(\",psinds) > 0 then sysdsorg = \"PS\"\n        if sysdsorg = \"PO\" then do\n           if spf <> \"ACTIVE\" then do\n              say cmd\": Has specified a partitioned data set:\",\n                        psinds\n              say cmd\": which is not supported by this command\",\n                     \"outside of the ISPF enviornment.\"\n              say cmd\": Terminating processing.  Specify a member\",\n                     \"name and retry.\"\n              exit\n              end\n           Address ISPEXEC\n           call do_pds\n           exit\n           end\n\n        /* generate a ddname and dynamically allocate the output\n           data set. */\n        pscript_odd = \"PSXO\"random()\n        \"Alloc f(\"pscript_odd\") ds(\"pscript_dsn\") New Spa(30,30) Tr\",\n              \"Recfm(V B) Lrecl(255) Blksize(0) Dsorg(PS)\"\n\n        /* read each line, quote characters and then output */\n        pscript_idd = \"PSXi\"random()\n        \"Alloc f(\"pscript_idd\") ds(\"psinds\") Shr\"\n        \"Execio * diskr\" pscript_idd \"(Finis stem in.\"\n        \"Free f(\"pscript_idd\")\"\n\n        \"Execio * diskw\" pscript_odd \"(stem out.\"\n        \"Execio * diskw\" pscript_odd \"(Finis stem in.\"\n        \"Free f(\"pscript_odd\")\"\n\n        drop out. in.\n\n        if no_lpr <> \"on\" then do\n          if spf = \"ACTIVE\" then do\n             Address ISPEXEC \"Vget (lprps) Profile\"\n             hold_lprps = lprps\n             lprps = \"No\"\n             Address ISPEXEC \"Vput (lprps) Profile\"\n             end\n          \"%lprprint\" pscript_dsn\n          lprps = hold_lprps\n          if spf = \"ACTIVE\" then\n             Address ISPEXEC \"Vput (lprps) Profile\"\n          end\n\n        x = msg(\"OFF\")\n        if no_del <> \"on\" then\n          \"Delete\" pscript_dsn\n          else do\n            smsg = \"\"\n            lmsg = \"Output dsname is:\" pscript_dsn\n            call do_msg\n            end\n\n        exit\n\n        do_msg:\n            if spf = \"ACTIVE\" then do\n               Address ISPEXEC\n               \"Vput (Smsg Lmsg)\"\n               \"Setmsg Msg(Pspr002)\"\n               end\n            else do\n                 say smsg\n                 say lmsg\n                 end\n            return\n\n        do_port:\n\n        do_port:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 11 scalefont setfont\"\n        out.6 = \"/P {showpage /H 750 def} def\"\n        out.7 = \"/Q { 36 H moveto dup length 80 gt {0 80 getinterval}\",\n                \" if show /H H 12 sub def\"\n        out.8 = \"   H 30 le {P} if} def\"\n        out.9 = \"/R 0 def\"\n        out.10 = \"/S 512 string def\"\n        out.11 = '/T {(\", FF, \") search {R 0 ne {Q pop P} {pop pop /R 1 def}',\n                \" ifelse T} if} def\"\n        out.12 = \"/L {/H 750 def {currentfile S readline not {exit} if T Q}\",\n                \" loop showpage} def\"\n        out.13 = \"L\"\n        out.0 = 13\n        return\n\n        do_wide:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 6 scalefont setfont\"\n        out.6 = \"/P {showpage /H 750 def} def\"\n        out.7 = \"/Q { 36 H moveto dup length 132 gt {0 132 getinterval}\",\n                \" if show /H H 7 sub def\"\n        out.8 = \"   H 30 le {P} if} def\"\n        out.9 = \"/R 0 def\"\n        out.10 = \"/S 512 string def\"\n        out.11 = '/T {(\", FF, \") search {R 0 ne {Q pop P}',\n                 \" {pop pop /R 1 def} ifelse T} if} def\"\n        out.12 = \"/L {/H 750 def {currentfile S readline not\",\n                 \" {exit} if T Q} loop showpage} def\"\n        out.13 = \"L\"\n        out.0 = 13\n        return\n\n        do_land:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 9 scalefont setfont\"\n        out.6 = \"/P {showpage 90 rotate 0 -618 translate /H 594 def} def\"\n        out.7 = \"/Q {36 H moveto dup length 132 gt {0 132 getinterval}\",\n                \" if show /H H 9.5 sub def\"\n        out.8 = \"    H 30 le {P} if} def\"\n        out.9 = \"/R 0 def\"\n        out.10 = \"/S 512 string def\"\n        out.11 = '/T {(\", FF, \") search {R 0 ne {Q pop P}',\n                 \" {pop pop /R 1 def} ifelse T} if} def\"\n        out.12 = \"/L {90 rotate 0 -618 translate /H 594 def\",\n                 \" {currentfile S readline not {exit} if\"\n        out.13 = \" T Q} loop showpage} def\"\n        out.14 = \"L\"\n        out.0 = 14\n        return\n\n        do_2up:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 6 scalefont setfont\"\n        out.6 = \"/N {showpage 90 rotate 0 -618 translate /H 538\",\n                \" def /V 71 def} def\"\n        out.7 = \"/O {/H 538 def /V 431 def} def\"\n        out.8 = \"/P {V 431 ne {O} {N} ifelse} def\"\n        out.9 = \"/Q { V H moveto dup length 80 gt {0 80 getinterval}\",\n                \" if show /H H 7 sub def\"\n        out.10 = \"   H 79 le {P} if} def\"\n        out.11 = \"/R 0 def\"\n        out.12 = \"/S 512 string def\"\n        out.13 = '/T {(\", FF, \") search {R 0 ne {Q pop P} {pop pop',\n                 \" /R 1 def} ifelse T} if} def\"\n        out.14 = \"/L {90 rotate 0 -618 translate /H 538 def /V 71 def\"\n        out.15 = \"   {currentfile S readline not {exit} if T Q}\",\n                 \" loop showpage} def\"\n        out.16 = \"L\"\n        out.0 = 16\n        return\n\n        test_pds:\n              x = listdsi(psinds)\n              if pos(\"(\",psinds) > 0 then sysdsorg = \"PS\"\n              Select\n                When sysdsorg = \"PS\" | pos(\"(\",psinds) > 1\n                     then\n                     \"Select Cmd(%\"cmd  psinds psopds \"/\" pstype lpr \")\"\n                When sysdsorg = \"PO\"\n                     then call do_pds\n                Otherwise nop;\n              end\n        return\n\n        do_pds:\n            \"Lminit Dataid(dataid) Dataset(\"psinds\") Enq(Shrw)\"\n            \"Lmopen Dataid(\"dataid\") Option(Input)\"\n            \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n              \"Commands(Any) Panel(PsprM)\"\n              do while rc == 0\n                 Call process_selection\n                \"Lmmdisp Dataid(\"dataid\") Option(Get)\"\n                 if rc == 8\n                    then \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n                         \"Commands(Any) Panel(LPRPM)\"\n              end\n              \"Lmmdisp Dataid(\"dataid\") Option(Free)\"\n              \"Lmclose Dataid(\"dataid\")\"\n              \"Lmfree  Dataid(\"dataid\")\"\n            return\n\n         process_selection:\n            if left(psinds,1) = \"'\"\n               then parse value psinds with \"'\" w_dsn \"'\"\n               else w_dsn = sysvar(\"syspref\")\".\"psinds\n            zlmember = strip(zlmember)\n            Select\n            When zllcmd = \"/\" | zllcmd = \"S\"\n            Then do\n              \"Lmmdisp Dataid(\"dataid\") Option(Put) Member(\"zlmember\")\",\n                  \"Zludata(printed)\"\n              \"Select Cmd(%\"cmd  \"'\"w_dsn\"(\"zlmember\")'\",\n                  psopds \"/\" pstype lpr \")\"\n              end\n            When zllcmd = \"B\"\n            Then \"Browse Dataid(\"dataid\") Member(\"zlmember\")\"\n            Otherwise nop;\n            End\n            return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGS": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x18\\x04_\\x01\\x18\\x04_\\x06\\x19\\x00\\x07\\x00\\x07\\x00\\x00\\xd7\\xd9\\xc9\\xd5\\xe3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-02-14T00:00:00", "modifydate": "2018-02-14T06:19:08", "lines": 7, "newlines": 7, "modlines": 0, "user": "PRINT"}, "text": "./ ADD NAME=PSPR00\nPSPR001\n'Input data set name must be specified and must be a valid dsname'\nPSPR002 '&SMSG' .WINDOW=NORESP .TYPE=NOTIFY\n'&LMSG'\nPSPR003\n'Output data set name, if specified, must be a valid dsname'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PANELS": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x04_\\x01\\x18\\x04_\\x06\\x19\\x00\\xa0\\x00\\xa0\\x00\\x00\\xd7\\xd9\\xc9\\xd5\\xe3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-02-14T00:00:00", "modifydate": "2018-02-14T06:19:00", "lines": 160, "newlines": 160, "modlines": 0, "user": "PRINT"}, "text": "./ ADD NAME=PSPRH0   0100-1994025-1994025-1028-00071-00071-00000-$A1238\n)Attr Default(@+_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type(text) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   $ type(output) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(turq)\n   @ type(text) intens(high)\n   + type(text  ) intens(low )\n     skip(on)\n   # area(SCRL) Extend(ON)\n)Body\n+------------------------! Convert Text to PostScript +-------------------------\n@Command ===>_zcmd\n@\n+\n#help -------------------------------------------------------------------------#\n)Area Help\n`    Information on Converting text to PostScript\n~\n~    This ISPF application will convert text data into a data stream that\n~    can be printed on a PostScript printer.\n~\n~    To print this data stream you must send the data to an application\n~    that will convert it from EBCDIC (the MVS character set) to ASCII\n~    and then direct the data stream to a PostScript printer.  The most\n~    common technique for this is to use the LPR TCP/IP TSO command.\n~\n~    The information that is asked for on the panel is:\n~\n`    Input Data Set      ===>\n~\n~    This is the data set name that contains the information that is to be\n~    converted to PostScript.  The format of this field is:\n~\n~              user.data\n~              user.data(member)\n~              'prefix.user.data'\n~\n`    Print Orientation   ===>\n~\n~    This is the orientation of the resulting printed output.  The valid\n~    options are:\n~\n         PORT -  Portrait 80 characters by 60 lines in 11 pt. Courier\n         WIDE -  Portrait 132 characters by 103 lines in 6 pt. Courier\n         LAND -  Landscape 132 characters by 60 lines in 9 pt. Courier\n         2UP  -  2 pages 80 characters by 66 lines side by side\n                 in landscape in 6 pt. Courier\n~\n`    Invoke LPRPRINT     ===>\n~\n~    This allows you to inform the application that the ISPF LPRPRINT Dialog\n~    is not to be automatically invoked.  If`no~is selected then the converted\n~    data stream will be saved into a data set (either the specified output\n~    data set or a dynamically generated data set).\n~\n`    Output Data Set     ===>\n~\n~    This field is optional and defines an output data set into which\n~    the converted PostScript data stream will be stored.\n+\n!Note:`Use the Enter key to just scroll down this tutorial or\n`      Use key $LEFT`to scroll down and key $RIGHT`to scroll up.\n)Init\n  .cursor = zcmd\n  &left  = PFK(LEFT)\n  &right = PFK(RIGHT)\n)Proc\n)end\n./ ADD NAME=PSPRINT  0107-1994025-1996003-1024-00055-00047-00000-SYSLBD\n)Attr\n   @ type( input) intens(high) caps(off) just(left ) pad('_')\n     color(white)\n   ! type( input) intens(high) caps(off) just(left ) color(white)\n   _ type( input) intens(high) caps(on ) just(left ) color(white)\n   \u00ac type(text) intens(low ) caps(off) just(asis ) color(white)\n         hilite(uscore)\n   | type(text) intens(high) caps(off) just(asis ) color(white)\n         hilite(uscore)\n   # type(text) intens(high) caps(on) just(left ) color(yellow)\n         hilite(uscore)\n   ` type(text) intens(high) caps(off) just(asis ) color(turq)\n   ~ type(text) intens(low ) caps(off) just(asis ) color(turq)\n   % type(text) intens(low ) caps(off) just(asis ) color(white)\n)Body\n+------------------------% Convert text to PostScript +-------------------------\n%Command ===>_zcmd\n\n`Enter/Verify:\n`\n`    Input Data Set      %===>_psinds\n%\n`    Print orientation   %===>!pstype+    see list below\n%\n`    Invoke LPRPRINT     %===>!lpr+       Yes or No\n`\n`    Output Data Set     %===>_psopds\n`    (optional)\n`\n`    Valid orientations:\n`          PORT+-  Portrait 80 characters by 60 lines in 11 pt. Courier\n`          WIDE+-  Portrait 132 characters by 103 lines in 6 pt. Courier\n`          LAND+-  Landscape 132 characters by 60 lines in 9 pt. Courier\n`          2UP +-  2 pages 80 characters by 66 lines side by side\n`              +   in landscape in 6 pt. Courier\n)Init\n .HELP = psprh0\n .cursor  = psinds\n &pstype= trans(trunc(&pstype,1)\n            P,Port p,Port L,Land l,Land, W,Wide w,Wide 2,2UP &z,Port)\n &lpr     = trans(trunc(&lp,1) Y,Yes N,No y,Yes n,No &z,Yes)\n)Reinit\n .cursor  = psinds\n &pstype= trans(trunc(&pstype,1)\n            P,Port p,Port L,Land l,Land, W,Wide w,Wide 2,2UP &z,Port)\n &lpr     = trans(trunc(&lp,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n)Proc\n &pstype= trans(trunc(&pstype,1) P,Port p,Port L,Land l,Land,\n                                     W,Wide w,Wide 2,2UP &z,Port *,*)\n &lpr     = trans(trunc(&lp,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n ver (&psinds,nonblank,dsname,msg=pspr001)\n ver (&pstype,nb,list,Port,Land,Wide,2UP)\n ver (&lpr,nb,list,Yes,No)\n ver (&psopds,dsname,msg=pspr003)\n)End\n./ ADD NAME=PSPRM    0101-1994013-1994018-0732-00031-00030-00000-$A1238\n)ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)\n  | AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n  + TYPE(TEXT) INTENS(LOW)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) PAD(0)\n 01 TYPE(DATAIN) INTENS(HIGH) CAPS(ON)\n 02 TYPE(DATAOUT) INTENS(LOW)\n 03 TYPE(DATAIN)  INTENS(HIGH) CAPS(ON)\n 04 TYPE(DATAOUT)  INTENS(LOW)\n 05 TYPE(DATAOUT)  INTENS(HIGH)\n 06 TYPE(DATAOUT)  INTENS(LOW)\n)BODY WIDTH(80)\n%Member List -- &ZDSN --------------------------------------%ROW\u00a2ZMLCR%OF\u00a2ZMLTR+\n%Command ===>_ZCMD                                            %Scroll ===>_Z   +\n%Commands:      LOCATE, RESET, SELECT, SORT, HELP                              +\n%Line commands: / or S = Select, B = Browse                                    +\n&ZMLCOLS\n|ZDATA ------------------------------------------------------------------------|\n|                                                                              |\n| -----------------------------------------------------------------------------|\n)INIT\n  .ZVARS = 'ZSCML'         /* SCROLL AMT VARIABLE NAME  */\n  .HELP = ISR01130\n)PROC\n  VPUT (ZSCML) PROFILE\n)END\n /*  $M1= MEMLIST   M230     860923   158590 : FUNCTION TEST          */\n /*   PTM00000184                                                     */\n /*                                                                   */\n /*   CHANGED 3 LINES                                            3@M1C*/\n/* 5665-402 (C) COPYRIGHT IBM CORP 1980, 1989 */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/CBT.V500.FILE312.PDS/LPRPRINT.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312/CBT.V500.FILE312.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}