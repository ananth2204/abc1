{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20170829133638000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "T311LBD.FASTPATH.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.FASTPATH.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "170241", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x02'", "DS1LSTAR": "b'\\x00\\x05\\x02'", "DS1TRBAL": "b'\\xd4\\x80'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c\\xc0\\x00\\x04\\x98\\x10P'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0c\\xc0\\x00\\x04\\x98\\x10P'", "b'X\\xf4\\x8e\\xe0\\x00\\x00\\x0c\\xfb\\x00\\x07\\x0c\\xfb\\x00\\n\\x00\\x04'", "b'X\\xf4\\x8e\\xe0\\x00\\x00\\x02w\\x00\\r\\x02w\\x00\\x0e\\x00\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x001\\x01\\x03\\x14\\x0f\\x01\\x17$\\x0f\\x129\\x00\\x1b\\x00\\x0c\\x00\\x00\\xc6\\xc1\\xe2\\xe3\\xd7@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2003-05-20T00:00:00", "modifydate": "2017-08-28T12:39:31", "lines": 27, "newlines": 12, "modlines": 0, "user": "FASTP"}, "text": "This partitioned dataset contains the FASTPATH ISPF command dialog package.\n\nThe members of this file are:\n    $DOC       What you are reading\n    CHANGES    Change History\n    FASTPATH   Fastpath REXX Exec\n    EXTISPF    Edit macro to extract the ISPF Panels from the FASTPATH\n               Exec\n\nInstallation recommendations:\n\n1. copy the fastpath from the exec into a exec library concatenated to\n   your sysexec or sysproc dd\n2. review the fastpath customization option (find *custom*)\n   - do you want to leave the ISPF Panels imbedded in the exec or\n     do you want to extract them\n     - copy the EXTISPF exec into your exec/clist library\n     - edit the fastpath member and enter EXTISPF hlq on the command line\n       - hlq is where the panels pds will be created\n         hlq.PANELS\n       - copy the hlq.PANELS members into your ISPPLIB dataset\n       - Edit FastPath to change the customization variable to 0 to\n         disable loading the panels dynamically\n3. Copy the FASTPATH exec into your production rexx or clist library\n4. update an ispf command table:\n   Verb      T  Action\n   FASTPATH  5  SELECT CMD(%FASTPATH)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHANGES": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00X\\x01\\x03\\x14\\x0f\\x01\\x17$\\x1f\\x085\\x00%\\x00\\x0c\\x00\\x00\\xe3\\xf3\\xf1\\xf1\\xd3\\xc2\\xc4@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2003-05-20T00:00:00", "modifydate": "2017-08-29T08:35:58", "lines": 37, "newlines": 12, "modlines": 0, "user": "T311LBD"}, "text": "Change History for FASTPATH\n\n  08/29/17 Incorporate updates from Hartmut\n           - use ISPBLANK to invoke ISPF commands which now enables\n             alias entries\n           - Return to the command table after execution\n           - Additional cleanup\n  08/28/17 - Insert inline the ISPF Panels\n           - Turn off Keylist\n  08/14/17 - Make action in FASTPDSP scrollable\n           - Change packaging to use xmit format for exec\n  08/07/17 - Changes from Al Ferguson with appreciation\n           - Update Build_Table to include Command table ApplID in\n             display.\n           - Refactor \"Do_Msg\"\n           - Refactor \"test_for_help\" into \"HELP_PANEL_EXISTS\" Function.\n           - Use hpan in all locations vs h_pan in some location\n             (prevented finding correct Help Panel).\n            -Minor refactoring to aid in debugging\n           - Change FASTPATH ISPF Panel HELP from FASTPATH (same name!) to\n             $FASTPAT & create dummy $FASTPAT Help Panel\n  08/04/17 Support Site and User tables 2 & 3\n  06/29/17 Update to support multiple of the same commands in the list\n  04/15/16 Update FASTPATH Panel to support point and shoot\n  04/11/16 Update to not include the RFIND from\n           the FASTCMDS table (added by this exec\n  03/14/16 Corrected repeat find\n  05/20/03  correct command table search order\n  09/02/97  minor cleanup for ispcmds\n  08/22/97  Support current appl command table\n  02/26/97  Support System Command Table Search order\n  02/24/97  Add support for System and User command tables (ISPF V4)\n  03/16/95  Upper case zctact\n  01/10/95  Clear our usrrfind variable on exit\n  01/17/94  Add Help for option\n  02/23/93  Add 'Locate' option\n  02/17/93  Created.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXTISPF": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x17$\\x0f\\x01\\x17$\\x0f\\x12@\\x00\\xb9\\x00\\xb9\\x00\\x00\\xc6\\xc1\\xe2\\xe3\\xd7@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-08-28T00:00:00", "modifydate": "2017-08-28T12:40:57", "lines": 185, "newlines": 185, "modlines": 0, "user": "FASTP"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      EXTISPF                                         |\n |                                                            |\n | Function:  ISPF Edit Macro to extract imbedded ISPF        |\n |            elements into target PDS datasets               |\n |                                                            |\n |            All elements will be extracted from the         |\n |            active EXEC into datasets prefixed by           |\n |            the provided HLQ:                               |\n |                                                            |\n |            hlq.CLIST                                       |\n |            hlq.EXEC                                        |\n |            hlq.MSGS                                        |\n |            hlq.PANELS                                      |\n |            hlq.SKELS                                       |\n |                                                            |\n |            These datasets will be dynamically allocated    |\n |            using the DCB of the active dataset.            |\n |                                                            |\n | Syntax: EXTISPF hlq                                        |\n |                                                            |\n | Usage Notes:                                               |\n | 1. Requires a target PDS HLQ as the only parm              |\n | 2. The HLQ must be a full HLQ without quotes               |\n |    e.g. userid.EXTRACT                                     |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            08/28/17 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro (targhlq)'\n\n/* ------------------- *\n | Define our defaults |\n * ------------------- */\n  parse value '' with null clist exec msgs panels skels type\n\n/* ------------------------------------------ *\n | First validate the Target PDS Dataset Name |\n * ------------------------------------------ */\n  if targhlq = null then do\n    zedsmsg = 'Error'\n    zedlmsg = 'EXTISPF requires a target-hlq'\n    Address ISPExec 'Setmsg msg(isrz001)'\n    exit 8\n  end\n\n/* ------------------------------------------------- *\n | Get the DCB characteristics of the source dataset |\n * ------------------------------------------------- */\n  '(dataset) = dataset'\n  call listdsi \"'\"dataset\"'\"\n\n/* ------------------------------------------ *\n | Now Extract each Element to the Target PDS |\n * ------------------------------------------ */\n  '(last) = linenum .zlast'\n  hit = 0\n  rec = 0\n  dd = 'EP'random(9999)\n  do i = 1 to last\n    '(data) = line' i\n    if translate(left(data,6)) = '>END' then do\n      call write_it_out\n      exit 0\n    end\n    if left(data,1) = '>' then do\n      if hit = 1 then call write_it_out\n      hit = 0\n    end\n    if hit = 1 then do\n      rec = rec + 1\n      member.rec = data\n    end\n    Select\n      When translate(left(data,6)) = '>CLIST' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'CLIST'\n      end\n      When translate(left(data,5)) = '>EXEC' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'EXEC'\n      end\n      When translate(left(data,5)) = '>MSGS' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'MSGS'\n      end\n      When translate(left(data,6)) = '>PANEL' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'PANELS'\n      end\n      When translate(left(data,5)) = '>SKEL' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'SKELS'\n      end\n      Otherwise nop\n    end\n  end\n  exit\n\n/* ------------------------------------------------ *\n | Write out the element                            |\n |                                                  |\n | if the target type pds has not been created then |\n | create it.                                       |\n * ------------------------------------------------ */\nWrite_It_Out:\n  hit = 0\n  Address TSO\n  Select\n    When type = 'CLIST' then do\n      if clist = null then do\n        clist = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(clist) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('clist')'\n          'Free ds('clist')'\n        end\n      end\n    end\n    When type = 'EXEC' then do\n      if exec = null then do\n        exec = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(exec) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('exec')'\n          'Free ds('exec')'\n        end\n      end\n    end\n    When type = 'MSGS' then do\n      if msgs = null then do\n        msgs = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(msgs) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('msgs')'\n          'Free ds('msgs')'\n        end\n      end\n    end\n    When type = 'PANELS' then do\n      if panels = null then do\n        panels = \"'\"targhlq\".\"type\"'\"\ntrace '?i'\n        if sysdsn(panel) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('panels')'\n          'Free ds('panels')'\n        end\n      end\n    end\n    When type = 'SKELS' then do\n      if skels = null then do\n        skels = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(skel) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('skels')'\n          'Free ds('skels')'\n        end\n      end\n    end\n  Otherwise nop\n  end\n    member.0 = rec\n    say \"Creating element: '\"targhlq\".\"type\"(\"member\")'\"\n    \"Alloc f(\"dd\") ds('\"targhlq\".\"type\"(\"member\")') shr reuse\"\n    'Execio * diskw' dd '(finis stem member.'\n    'Free f('dd')'\n    drop member.\n    rec = 0\n    Address ISREdit\n    return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FASTPATH": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x17$\\x0f\\x01\\x17$\\x1f\\x085\\x03\\xe4\\x03\\xad\\x00\\x00\\xe3\\xf3\\xf1\\xf1\\xd3\\xc2\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2017-08-28T00:00:00", "modifydate": "2017-08-29T08:35:24", "lines": 996, "newlines": 941, "modlines": 0, "user": "T311LBD"}, "text": "/* ---------------------  rexx procedure  ---------------------- *\n * Name:      Fastpath                                           *\n *                                                               *\n * Function:  Display a selection list of all Selectable         *\n *            commands in the ISPCMDS ISPF Command Table         *\n *            and in the System and User command tables          *\n *            along with the commands in the current application *\n *            command table.  This command will:                 *\n *                                                               *\n *            1.  Provide the user with information on           *\n *                fast path commands available.                  *\n *            2.  Simplify access to fast path commands.         *\n *            3.  Provide a pseudo-menu to ISPF command          *\n *                functions.                                     *\n *            4.  If a tutorial panel exists for the command     *\n *                of the format $ followed by the first 7        *\n *                characters of the command name, it will be     *\n *                displayed if the user selects the command      *\n *                with 'H' or via PF1(Help) on the pop-up        *\n *                menu if the command has options.               *\n *                                                               *\n * Syntax:    %Fastpath                                          *\n *                                                               *\n * Author:    Lionel B. Dyck                                     *\n *Updated:    Al Ferguson (AJF)                                  *\n *                                                               *\n * History:                                                      *\n * LBD:       08/29/17 Incorporate updates from Hartmut          *\n *                     - use ISPBLANK to invoke ISPF commands    *\n *                       which now enables alias entries         *\n *                     - Return to the command table after       *\n *                       execution                               *\n *                     - Additional cleanup                      *\n * LBD:       08/28/17 Insert inline the ISPF Panels             *\n *                     Turn off Keylist                          *\n * AJF:       08/07/17 Update Build_Table to include Command     *\n *                     table ApplID in display.                  *\n * AJF:       08/07/17 Refactor \"Do_Msg\"                         *\n * AJF:       08/07/17 Refactor \"test_for_help\" into             *\n *                     \"HELP_PANEL_EXISTS\" Function.             *\n * AJF:       08/07/17 Use hpan in all locations vs h_pan in     *\n *                     some location (prevented finding correct  *\n *                     Help Panel).                              *\n * AJF:       08/07/17 Minor refactoring to aid in debugging     *\n * AJF:       08/07/17 Change FASTPATH ISPF Panel HELP from      *\n *                     FASTPATH (same name!) to $FASTPAT &       *\n *                     create dummy $FASTPAT Help Panel          *\n *            08/04/17 Support Site and User tables 2 & 3        *\n *            06/29/17 Update to support multiple of the same    *\n *                     commands in the list                      *\n *            04/11/16 Update to not include the RFIND from      *\n *                     the FASTCMDS table (added by this exec    *\n *            03/14/16 Corrected repeat find                     *\n *            05/20/03 correct command table search order        *\n *                     add current application command table     *\n *            09/02/97 minor cleanup for ispcmds                 *\n *            08/22/97 Support current appl command table        *\n *            02/26/97 Support System Command Table Search order *\n *            02/24/97 Add support for System and User command   *\n *                     tables (ISPF V4)                          *\n *            03/16/95 Upper case zctact                         *\n *            01/10/95 Clear our usrrfind variable on exit       *\n *            01/17/94 Add Help for option                       *\n *            02/23/93 Add 'Locate' option                       *\n *            02/17/93 Created.                                  *\n *                                                               *\n * ------------------------------------------------------------- */\n\n  signal on novalue name sub_novalue\n/* ------------------------------------------------------------- *\n * Verify entry under ISPF                                       *\n * ------------------------------------------------------------- */\nIF \"ACTIVE\" <> SYSVAR('SYSISPF') THEN EXIT 4\n\nparse arg options\nparse value '' with _debug_ row null\n\nPARSE VALUE '1 0 0 0' WITH crp rowcrp last_find new_counter\n\nADDRESS ISPEXEC\n\"Control Errors Return\"\n\n/* -------------------------------------------------- *\n * Test for our ISPF Applid and if not then:          *\n * - create an ISPF Commands Table so we can change   *\n *   RFIND to PASSTHRU so we can process it           *\n * - re-invoke ourselves with our APPLID              *\n * - upon return end the ISPF Commands Table and exit *\n * -------------------------------------------------- */\n ADDRESS \"ISPEXEC\"\n \"VGET (Zapplid)\"\n IF zapplid <> \"FAST\" THEN DO\n     \"TBCREATE fastcmds NAMES(zctverb zcttrunc zctact zctdesc)\",\n              \"REPLACE SHARE NOWRITE\"\n     zctverb = \"RFIND\"\n     zcttrunc = 0\n     zctact = \"&USRRFIND\"\n     zctdesc = \"RFIND for FastPath Dialog\"\n     \"TBADD fastcmds\"\n     \"SELECT CMD(%\"SYSVAR('SYSICMD') options\") NEWAPPL(FAST) PASSLIB\"\n     \"TBEND fastcmds\"\n     EXIT 0\n  END\n\n/* ------------------ *\n | Deactivate KeyList |\n * ------------------ */\n \"SELECT PGM(ISPKLU) PARM(OFF) SCRNAME(SETTINGS)\"\n\n/* ---------------------------------------------------- *\n |  *Custom*                                            |\n |                                                      |\n |  dyn_panel values                                    |\n |      0 - Disable inline panels (requires all panels  |\n |          to be installed into ISPPLIB                |\n |      1 - Enable inline panels                        |\n * ---------------------------------------------------- */\n dyn_panels = 1\n\n/* --------------------------------------- *\n | Dynamically load the inline ISPF Panels |\n * --------------------------------------- */\n if dyn_panels = 1 then\n    load_info = loadispf()\n\n/* -------------------------- *\n * Create ispf table          *\n * -------------------------- */\n fastcmds = \"fast\"RANDOM()\n \"TBCREATE\" fastcmds ,\n           \"NAMES(fpcmd fpdesc fpaction fpappl fptrunc fptable)\" ,\n           \"Replace Share\"\n IF RC = 8 THEN DO\n   if build_rc8 = 'on' then do\n      CALL Do_Mst \"Error\", \"Fastpath dialog error - contact systems\"\n      EXIT 8\n      END\n   \"TBend\" fastcmds\n   build_rc8 = 'on'\n   signal build_table\n   END\n\n\"VGET (ZSCTPREF ZSCTSRCH ZUCTPREF ZAPPLID)\"\n\"VGET (zsctpre2 zsctpre3 zuctpre2 zuctpre3)\"\n\nlocal_table = strip(zapplid)\"CMDS\"\nif local_table <> \"ISPCMDS\" then do\n   \"Tbquery\" local_table\n   fpappl = \"**\"\n   if rc = 0 then do\n      if local_table /= \"FASTCMDS\" then\n         call Build_Table zapplid\n      end\n   end\n\nfpappl = null\nif length(zsctsrch) = 0 then\n   call Build_Table \"ISP\"\n   else do\n        if zsctsrch = \"A\" then\n           call Build_Table \"ISP\"\n\n        if length(zsctpref) > 0 then\n           call Build_Table zsctpref\n\n        if length(zsctpre2) > 0 then\n           call Build_Table zsctpre2\n\n        if length(zsctpre3) > 0 then\n           call Build_Table zsctpre3\n\n        if zsctsrch = \"B\" then\n           call Build_Table \"ISP\"\n\n        if length(zuctpref) > 0 then\n           call Build_Table zuctpref\n\n        if length(zuctpre2) > 0 then\n           call Build_Table zuctpre2\n\n        if length(zuctpre3) > 0 then\n           call Build_Table zuctpre3\n        end\n\"Vget (zapplid)\"\nif zapplid <> \"ISP\" then\n   call Build_Table zapplid\n\n\"TBSort \"fastcmds\" Fields(fpcmd)\"\n\"TBTop\" fastcmds\n\n/* User_Display - not a label, more a comment */\n  src = \"\"  /* initialize variable src */\n  DO FOREVER\n     usrrfind = \"PASSTHRU\"\n\n     if src = 4 then \"TBDispl\" fastcmds\n        else do\n             \"TBTOP\" fastcmds\n             \"TBSKIP \"fastcmds\" NUMBER(\"crp\")\"\n             if rowcrp = 0 then\n                \"TBDISPL \"fastcmds\" PANEL(FASTPATH)\"\n                else\n                \"TBDISPL \"fastcmds\" PANEL(FASTPATH)\",\n                        \"CSRROW(\"rowcrp\") AUTOSEL(NO)\"\n             end\n     src = rc\n     if src > 4 then signal Out_A_Here /* leave */\n\n     crp = ztdtop\n     rowcrp = null\n\n     if row <> null & row > 0 then do\n          \"TBTop\" fastcmds\n          \"TBSkip \"fastcmds\" NUMBER(\"row\")\"\n          end\n\n     PARSE VALUE null WITH zcmd_ok x_rc\n\n     SELECT\n       WHEN WORDS(ZCMD) > 1  THEN DO\n            parse value zcmd with o1 o2\n            if abbrev(\"L\",o1,1) = 1 then call Loc_It\n            if abbrev(\"FIND\",o1,1) = 1 then call Find_It\n            if zcmd_ok <> \"ok\" then\n               CALL Do_Msg \"Error\", \"Invalid command:\" zcmd\n            END\n       WHEN ZCMD = \"RFIND\"   THEN DO\n            if lcmd = \"LOC\" then do\n                zcmd = \"RLOC\" o2\n                call Loc_it\n                end\n            else do\n                 zcmd = \"RFIND\" o2\n                 call Find_It\n                 end\n            END\n       WHEN LENGTH(ZCMD) = 0 THEN DO\n            if zsel = \"S\" then do\n               if pos(\"&ZPARM\",fpaction) > 0 then do\n                  pos = pos(\"&ZPARM\",fpaction)\n                  left_act  = left(fpaction,pos-1)\n                  right_act = substr(fpaction,pos+6)\n                  opt = words(left_act)\n                  parse value word(left_act,opt) with fpopt \"(\" .\n                  fpinput = null\n                  if fpopt = \"OPT\" then do\n                                        fpaction\n                                        x_rc = 0\n                                        end\n                     else do\n                          hpan = strip(\"$\"left(fpcmd,7))\n                          IF HELP_PANEL_EXISTS(hpan) ,\n                          THEN fpan = \"Fastproh\"\n                          ELSE fpan = \"Fastprom\"\n                          \"Addpop\"\n                          \"Display Panel(\"fpan\")\"\n                          x_rc = rc\n                          \"REMPOP\"\n                          /*\n                          IF x_rc = 0 THEN left_act\"\"fpinput\"\"right_act\n                          */\n                          IF x_rc = 0 THEN ,\n                             _junk_ = ISPF_command(fpcmd\" \"fpaction)\n                          x_rc = 4 /* redisplay list */\n                     end\n                  end\n              else do\n                   x_rc = 0\n                   _junk_ = ISPF_command(fpcmd\" \"fpaction)\n                   x_rc = 4 /* redisplay list */\n                   end\n            end\n            if zsel = \"H\" then do\n               /* display the help panel if one exists */\n               hpan = strip(\"$\"left(fpcmd,7))\n               IF HELP_PANEL_EXISTS(hpan) THEN\n                  ADDRESS ISPEXEC \"SELECT PGM(ISPTUTOR) PARM(\"hpan\")\"\n               ELSE DO\n                  CALL Do_Msg \"No Help\",,\n                              \"There is no help panel for command:\",\n                              fpcmd\n                  end\n               END\n            if zsel = \"V\" then do\n               \"Addpop\"\n               \"Display Panel(fastpdsp)\"\n               \"Rempop\"\n               end\n            IF x_rc = 0 THEN leave\n        /*  IF x_rc = 0 THEN SIGNAL Out_A_Here   */\n            END\n     OTHERWISE; NOP; END\n  END\n  SIGNAL Out_A_Here\n exit\n\n/* ------------------------------------------------------------- *\n * Execute the selected ISPF command                             *\n * Use panel ISPBLANK to execute the ISPF command to support     *\n * all ISPF commands, ALIAS entries included.                    *\n * ------------------------------------------------------------- */\nISPF_command: procedure\n  parse arg ispf_command ispf_action\n\n  ispf_command = ispf_command\n  ispf_action  = ispf_action\n  \"VGET (ZDEL)\"\n  com = \"\"\n  com = ispf_command\n  \"DISPLAY PANEL(ISPBLANK)\" ,\n          \"COMMAND(COM) RETBUFFR(RETBUFR)\"\n  retbufr = retbufr\n return 0\n\n/* ------------------------------------------------------------- *\n * Find_it routine to search the table entries for the           *\n * specified character string.  The search is done using         *\n * REXX instead of using the ISPF TBSCAN which is very limited.  *\n * ------------------------------------------------------------- */\nFind_It:\n  lcmd = \"FIND\"\n  zcmd_ok = \"ok\"\n  parse value zcmd with o1 argument\n  upper argument\n  argument = strip(argument)\n  zsel = null\n  crp = ztdtop\n  find_loop = null\n  search = null\n  rowid = crp\n  if o1 = \"RFIND\" then do\n     last_find = last_find + 1\n     \"TBTOP \" fastcmds\n     \"TBSKIP \"fastcmds\" Position(ROWID) Number(\"Last_find\")\"\n     end\n     else do\n          \"TBSKIP \"fastcmds\" Position(ROWID)\"\n          end\n  if rc = 8 then do\n                 s_smsg = \"Wrapped\"\n                 \"TBTOP \" fastcmds\n                 \"TBSKIP \"fastcmds\" Position(ROWID)\"\n                 end\n            else s_smsg = \"Found\"\n\n  /* perform search */\n\n  do forever\n     search = translate(fpcmd fpdesc)\n     if pos(argument,search) > 0 then do\n        crp = rowid + 0\n        rowcrp = crp\n        last_find = crp\n        CALL Do_Msg s_smsg, argument \"found during search in row:\" crp\n        RETURN\n        END\n     \"TBSKIP \"fastcmds\" POSITION(Rowid)\"\n     if rc = 8 then do\n           \"TBTOP\" fastcmds\n            s_smsg = \"Wrapped\"\n        if find_loop = \"on\" then do\n            CALL Do_Msg \"Not Found\", argument \"Not found during search\"\n            rowid = crp\n            RETURN\n            END\n            else find_loop = \"on\"\n        end\n     zsel = null\n     end\nRETURN\n\n/* ------------------------------------------------------------- *\n * Loc_it routine to search the table fpcmd entries for the      *\n * specified character string.  The search is done using         *\n * REXX instead of using the ISPF TBSCAN which is very limited.  *\n * ------------------------------------------------------------- */\nLoc_It:\n  lcmd = \"LOC\"\n  zcmd_ok = \"ok\"\n  parse value zcmd with o1 argument\n  upper argument\n  argument = strip(argument)\n  arg_len = length(argument)\n  zsel = null\n  crp = ztdtop\n  find_loop = null\n  search = null\n  rowid = crp\n  if o1 = \"RLOC\" then do\n     last_find = last_find + 1\n     \"TBTOP \" fastcmds\n     \"TBSKIP \"fastcmds\" Position(ROWID) Number(\"Last_find\")\"\n     end\n     else do\n          \"TBSKIP \"fastcmds\" Position(ROWID)\"\n          end\n  if rc = 8 then do\n                 s_smsg = \"Wrapped\"\n                 \"TBTOP \" fastcmds\n                 \"TBSKIP \"fastcmds\" Position(ROWID)\"\n                 end\n            else s_smsg = \"Found\"\n\n  /* perform search */\n\n  DO FOREVER\n     search = translate(fpcmd)\n     if left(search,arg_len) = argument then do\n        crp = rowid + 0\n        rowcrp = crp\n        last_find = crp\n            CALL Do_Msg s_smsg, argument \"found during search in row:\" crp\n        RETURN\n        END\n     \"TBSKIP \"fastcmds\" POSITION(Rowid)\"\n     IF RC = 8 THEN DO\n           \"TBTOP\" fastcmds\n            s_smsg = \"Wrapped\"\n        if find_loop = \"on\" then do\n            CALL Do_Msg \"Not Found\", argument \"Not found during search\"\n            rowid = crp\n            RETURN\n            END\n            else find_loop = \"on\"\n        end\n     zsel = null\n     end\nRETURN\n\n/* ------------------------------------------------------------- *\n * Build table of fast path commands...................          *\n * ------------------------------------------------------------- */\nBuild_Table:\nARG fpappl .\n  fptable = fpappl\"CMDS\"\n  \"Tbquery\" fptable \"Rownum(rows)\"\n  \"Tbtop\" fptable\n  DO i=1 TO ROWS\n     \"TBSkip\" fptable\n        IF RC > 0 THEN LEAVE i\n     fpcmd    = zctverb\n     fpdesc   = zctdesc\n     fpaction = zctact\n     fptrunc  = zcttrunc\n     \"TBAdd\" fastcmds\n  END\nRETURN\n\n/* ------------------------------------------------------------- *\n * Do_msg routine is used to issue the ISPF Message....          *\n * ------------------------------------------------------------- */\nDo_Msg:\nARG zedsmsg, zedlmsg\n   \"Setmsg Msg(ISRZ000)\"\nRETURN\n\nOut_A_Here:\n  usrrfind = null\n  \"TBEND\" fastcmds\n  \"LIBDEF Fasttabl\"\n  if dyn_panels = 0 then exit\n  do until length(load_info) = 0\n     parse value load_info with dd libd load_info\n     if left(libd,6) = \"ALTLIB\" then do\n        if libd = \"ALTLIBC\" then lib = \"CLIST\"\n                            else lib = \"EXEC\"\n        Address TSO,\n          \"Altlib Deact Application(\"lib\")\"\n        end\n     else \"libdef\" libd\n     address tso \"free f(\"dd\")\"\n     end\nEXIT 0\n\n/* ----------------------------------------- *\n * Test for a help panel for the application *\n * ----------------------------------------- */\nHELP_PANEL_EXISTS: PROCEDURE\nARG panel .\n  IF panel = \"\" THEN RETURN 0\n  Found=0; Cnt=0; Dsn.=\"\"; Dsn.0=Cnt\n  DO i=1 UNTIL List \\= 0\n     x = BPXWDYN(\"INFO INRELNO(\"i\") INRTDDN(Ddn) INRTDSN(Dsn) INRTLST(List)\")\n     SELECT\n       WHEN Ddn = \"\" & \\(Found)            THEN ITERATE i\n       WHEN Ddn=\"\" | ABBREV(Ddn,\"ISPPLIB\") THEN DO\n          Found=1; Cnt=1+Cnt; Dsn.Cnt = \"ISPPLIB\" Dsn; Dsn.0=Cnt\n         END\n       WHEN Ddn\\=\"\" & \\(Found)             THEN ITERATE i\n     OTHERWISE; LEAVE i; END\n  END\n  /* --------------------------------- *\n   * Now test for the panel in ISPPLIB *\n   * --------------------------------- */\n  prc=0\n  DO i=1 TO Dsn.0\n     IF \"OK\" = SYSDSN(\"'\"WORD(dsn.i,2)\"(\"panel\")'\") THEN DO\n         prc=1; LEAVE i\n     END\n  END\nRETURN prc\n\n/* ----------------------------------------------------------------- */\n\n/*********************************************/\n/* Trap uninitialized variables              */\n/*********************************************/\nsub_novalue:\n  Say \" \"\n  Say \"Variable\" condition(\"Description\") ,\n      \"undefined in line\" sigl\":\"\n  Say \" \"\n  Say sourceline(sigl)\n  Say \" \"\n  if sysvar(\"sysenv\") <> \"FORE\" then exit 8\n  say \"Report the error in this application\",\n      \"along with the syntax used.\"\n exit 8\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd \"ALTLIBC\")\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd \"ALTLIBE\")\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd \"ISPMLIB\")\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd \"ISPPLIB\")\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd \"ISPSLIB\")\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n Select\n    When type = \"Clist\" then\n         \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n         \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n         \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n         \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n         \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n    end\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(27920)\"\n return\n\n/*\n>Start\n>panel $FASTPAT\n)PANEL KEYLIST(ISPHELP,FAST)\n)ATTR DEFAULT(%+_)\n/* % TYPE(TEXT  ) INTENS(HIGH)              DEFAULTS DISPLAYED FOR */\n/* + TYPE(TEXT  ) INTENS(LOW )                   INFORMATION ONLY  */\n/* _ TYPE( INPUT) INTENS(HIGH) CAPS(ON ) JUST(LEFT )               */\n   ! TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS ) COLOR(WHITE)\n   ~ TYPE(TEXT) INTENS(HIGH) COLOR(BLUE) HILITE(REVERSE)\n   ` TYPE(TEXT) INTENS(HIGH) COLOR(RED)\n   % TYPE(TEXT) INTENS(HIGH)\n   # AREA(SCRL) EXTEND(ON)\n)BODY  EXPAND(\\\\)\n%-\\-\\-~ISPF Fast Path Commands Help%-\\-\\-\n%Command ===>_zcmd \\ \\+\n%\n+                                                                %Up F10 Dn F11\n#HELP -------------------------------------------------------------------------#\n)AREA HELP\n+\n+  Function: Display a selection list of all Selectable commands in the\n+     ISPCMDS ISPF Command Table and in the System and User command\n+     tables along with the commands in the current application command\n+     table.  This command will:\n+\n+     1. Provide the user with information on ISPF Commands available.\n+     2. Simplify access to fast path commands.\n+     3. Provide a pseudo-menu to ISPF command functions.\n+     4. If a tutorial panel exists for the command of the format:\n+           $ plus 7 Left most Command Name Characters\n+        it will be displayed if the user selects the command with 'H'\n+        or via PF1(Help) on the pop-up menu if the command has options.\n+\n)INIT\n  .CURSOR = ZCMD\n)PROC\n)END\n>panel FASTPATH\n)ATTR DEFAULT(%+_)\n/* % TYPE(TEXT  ) INTENS(HIGH)              DEFAULTS DISPLAYED FOR */\n/* + TYPE(TEXT  ) INTENS(LOW )                   INFORMATION ONLY  */\n/* _ TYPE( INPUT) INTENS(HIGH) CAPS(ON ) JUST(LEFT )               */\n   @ TYPE( INPUT) INTENS(HIGH) CAPS(ON ) JUST(LEFT ) PAD('_') COLOR(TURQ)\n   ! TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS ) COLOR(WHITE)\n   ` TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(ASIS ) COLOR(YELLOW)\n   ~ TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(ASIS ) COLOR(TURQ)\n   % TYPE(TEXT)   INTENS(HIGH)\n   | TYPE(TEXT)   INTENS(HIGH) HILITE(USCORE)\n   + TYPE(TEXT  ) INTENS(LOW ) SKIP(ON)\n   # TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS ) COLOR(YELLOW)\n   $ TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) JUST(ASIS ) COLOR(TURQ)\n)BODY EXPAND(\\\\)\n%\\-\\`ISPF Fast Path Commands+\\-\\\n%Command ===>_zcmd \\ \\%Scroll ===>_mamt+\n%\n`Command Options: %Find~xxx   %Locate~xxx\n`Line Options:    %S~-Execute command %H~-Display help %V~-View entry\n+\n%Sel|Command +|Description                                               +|AppId\n)MODEL\n+ @z!z       +#z                                                         +$z   +\n)INIT\n  .ZVARS = '(ZSEL fpcmd fpdesc fpappl)'\n  .Help  = $fastpat\n  &zsel  = &z\n  &mamt  = CSR\n)PROC\n IF (&ZCMD = &Z)\n     IF (&ztdsels = 0000)\n        &row = .csrrow\n        IF (&row \u00ac= &z)\n            IF (&zsel = &z)\n                &zsel = S\n     IF (&ztdsels \u00ac= 0000)\n          &row = &z\n     IF (&ZSEL \u00ac= &Z)\n        IF (&Zsel = '=')\n           &Zsel = &osel\n     &osel = &zsel\n     VER (&zsel,LIST,S,H,V)\n)END\n>panel FASTPDSP\n)ATTR DEFAULT(%+_)\n/* _ TYPE( INPUT) INTENS(HIGH) CAPS(ON ) JUST(LEFT )               */\n   % TYPE(TEXT)   INTENS(HIGH)\n   # TYPE(OUTPUT) INTENS(Low ) CAPS(OFF) JUST(ASIS )\n   @ TYPE(OUTPUT) INTENS(Low ) CAPS(OFF) JUST(ASIS ) Hilite(uscore)\n   ` TYPE(TEXT)   INTENS(HIGH) CAPS(OFF) JUST(ASIS ) COLOR(TURQ)\n)BODY WINDOW(66,12) EXPAND(\\\\)\n%\\-\\`Fast Path Command View%\\-\\\n%Command ===>_zcmd\n%\n%   Cmd:#fpcmd\n% Table:#fptable\n% Trunc:#fptrunc\n%  Desc:#fpdesc\n%\n\\ \\`Action+\\ \\\n%\n#z @fpaction\n%\n)INIT\n  .CURSOR = &ZCMD\n  .zvars = '(zind)'\n)PROC\n)Field\n Field(fpaction) ind(zind,'<>') len(255) scale(lr1sc)\n)END\n>panel FASTPROH\n)Attr Default(%+_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   @ type( input) intens(high) caps(on ) just(left ) pad('_') color(turq)\n   ! type(output) intens(high) caps(off) just(asis ) color(white)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(turq)\n   % type(text) intens(high)\n   + type(text  ) intens(low )\n     skip(on)\n   # type(output) intens(high) caps(off) just(asis ) color(yellow)\n)Body Window(60,13)\n%---------------+ Fast Path Command Prompt +---------------\n%Command ===>_zcmd\n%\n%  #fpcmd\n%\n%  This command supports a parameter which may or may not\n%  be optional.  Fill in the parameter field and then\n%  press Enter to continue or press &END %to cancel this\n%  request.\n%\n% #fpopt   %value  : ===>_fpinput\n%\n% #fpdesc\n)Init\n  .cursor = &fpinput\n  .help   = &hpan\n  &end = pfk(END)\n)Proc\n)End\n>panel FASTPROM\n)Attr Default(%+_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   @ type( input) intens(high) caps(on ) just(left ) pad('_') color(turq)\n   ! type(output) intens(high) caps(off) just(asis ) color(white)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(turq)\n   % type(text) intens(high)\n   + type(text  ) intens(low )\n     skip(on)\n   # type(output) intens(high) caps(off) just(asis ) color(yellow)\n)Body Window(60,16)\n%---------------+ Fast Path Command Prompt +---------------\n%Command ===>_zcmd\n%\n%  #fpcmd\n%\n%  This command supports a parameter which may or may not\n%  be optional.  Fill in the parameter field and then\n%  press Enter to continue or press &END %to cancel this\n%  request.\n%\n% #fpopt   %value  : ===>_fpinput\n%\n% #fpdesc\n%\n% No help is available for this command\n)Init\n  .cursor = &fpinput\n  &end = pfk(END)\n)Proc\n)End\n>End */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/CBT.V500.FILE312.PDS/FASTPATH.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312/CBT.V500.FILE312.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}