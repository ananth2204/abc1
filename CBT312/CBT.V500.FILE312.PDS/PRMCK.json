{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SLBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20200514180845000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "SLBD.PRMCK.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SLBD.PRMCK.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 10017, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200135", "DS1SCEXT": "b'\\x80m\\x10'", "DS1SCALO": "b'P\\x00\\x00\\x03'", "DS1LSTAR": "b'\\x00\\x13\\x03'", "DS1TRBAL": "b'F\\xca'"}, "COPYR2": {"deb": "b'\\x08\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x12`\\x00\\x04y\\xcb\\x98'", "extents": ["b'\\x08\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x12`\\x00\\x04y\\xcb\\x98'", "b'X{<\\x10\\x00\\x00\\x0c\\xe0\\x00\\x08\\x0c\\xe0\\x00\\r\\x00\\x06'", "b'X{<\\x10\\x00\\x00\\x01\\xbd\\x00\\x0c\\x01\\xbd\\x00\\r\\x00\\x02'", "b'X{<\\x10\\x00\\x00\\x00(\\x00\\t\\x00(\\x00\\n\\x00\\x02'", "b'X{<\\x10\\x00\\x00\\x16\\xd7\\x00\\x00\\x16\\xd7\\x00\\x01\\x00\\x02'", "b'X{<\\x10\\x00\\x00\\x0c\\xe0\\x00\\x01\\x0c\\xe0\\x00\\x02\\x00\\x02'", "b'X{<\\x10\\x00\\x00\\x03\\x9f\\x00\\r\\x03\\x9f\\x00\\x0e\\x00\\x02'", "b'X{<\\x10\\x00\\x00\\x03\\xf2\\x00\\t\\x03\\xf2\\x00\\n\\x00\\x02'", "b'X{<\\x10\\x00\\x00\\x03\\xf2\\x00\\x0b\\x03\\xf2\\x00\\x0c\\x00\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00E\\x00\\x99)\\x0f\\x01 \\x07\\x0f\\x05E\\x005\\x00\\x14\\x00\\x00\\xd7\\xd9\\xd4\\xc3\\xd2@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1999-10-17T00:00:00", "modifydate": "2020-03-10T05:45:45", "lines": 53, "newlines": 20, "modlines": 0, "user": "PRMCK"}, "text": "PARMLIB Check\n\nThis consists of two EXEC's:\n\n   PRMCK     - ISPF Edit Command\n   PRMCKBAT  - Batch front end to PRMCK by Hartmut Beckmann\n\nPRMCK Edit Command\n\n  This application consists of a REXX Exec with imbedded ISPF Panels.\n  To use this you need to copy the exec into a library in your SYSPROC\n  or SYSEXEC concatenation.\n\n  Usage is to Edit the desired member of SYS1.PARMLIB and enter the\n  command PRMCK.\n\n  Syntax: PRMCK cat sysres -debug -notran\n\n  valid options are:\n        ?   - will prompt for catalog and sysres\n        cat - is a name that will be used in the master\n              catalog lookup (find *custom* below) and\n              if not found will be used as the master\n              catalog name (enter without quotes).\n        sysres is the volser of the system ipl volume\n              to be checked when a volser of ****** is\n              coded.\n        -debug - will turn on tracing\n        -help  - display short ispf tutorial\n        -nowarn  - will ignore all warnings\n        -noerror - will ignore all errors\n        -report  - will create a report and put you into browse\n                   ** this data set will *not* be deleted when done\n\n  Support for PROGxx member statements\n     - LNKLST\n     - APF\n     - LPA\n     - SYSLIB\n  Support for LNKLSTxx and LPALSTxx members\n\n  Note that the tutorial panel will be displayed if the member type is\n  not recognized.\n\n  Verification is not 100% the same as the system will perform when\n  used but it does a fair amount of verification.  Errors and Warnings\n  are inserted into the Edit display as non-saveable messages.\n\nPRMCKBAT - Batch Front End\n\nThis is code that will inovke the PRMCK exec in batch.\n\nSee the BATJCL for a sample JCL to run this exec.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BATJCL": {"ttr": 10, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00T\\x01\\x18%_\\x01\\x18%o\\x10\\x17\\x008\\x003\\x00\\x00\\xd7\\xd9\\xd4\\xc3\\xd2@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-09-12T00:00:00", "modifydate": "2018-09-13T10:17:54", "lines": 56, "newlines": 51, "modlines": 0, "user": "PRMCK"}, "text": "//PRMCKBAT JOB ('ABC'),'Batch Parmckeck',\n//        NOTIFY=&SYSUID,MSGCLASS=A\n//OUT   OUTPUT DEFAULT=YES,JESDS=ALL,OUTDISP=(HOLD,HOLD)\n//* ---------------------------------------------------------------- *\n//* Make the appropriate changes and verifications                   *\n//* ---------------------------------------------------------------- *\n//   SET HLQ=SYS1.                               <==== Verify\n//   SET VIO=VIO                                 <==== Verify\n//   SET EXC=PRMCK.PDS                           <==== Verify\n//* ---------------------------------------------------------------- *\n//BATCHPDF EXEC PGM=IKJEFT01,DYNAMNBR=128\n//SYSEXEC  DD  DISP=SHR,DSN=&EXC\n//*\n//ISPTLI0  DD  DISP=(NEW,DELETE),UNIT=&VIO,SPACE=(TRK,(1,1,1)),\n//             DCB=(BLKSIZE=27920,LRECL=80,RECFM=FB,DSORG=PO)\n//*\n//ISPMLIB  DD  DISP=SHR,DSN=&HLQ.SISPMENU        <==== Verify LLQ\n//ISPPLIB  DD  DISP=SHR,DSN=&HLQ.SISPPENU        <==== Verify LLQ\n//ISPSLIB  DD  DISP=SHR,DSN=&HLQ.SISPSENU        <==== Verify LLQ\n//ISPTLIB  DD  DISP=(SHR,PASS),DSN=*.ISPTLI0,VOL=REF=*.ISPTLI0\n//         DD  DISP=SHR,DSN=&HLQ.SISPTENU        <==== Verify LLQ\n//*\n//ISPPROF  DD  DISP=(NEW,PASS),UNIT=&VIO,SPACE=(TRK,(1,1,1)),\n//             DCB=(BLKSIZE=27920,LRECL=80,RECFM=FB,DSORG=PO)\n//ISPTABL  DD  DISP=(SHR,PASS),DSN=*.ISPTLI0,VOL=REF=*.ISPTLI0\n//*\n//ISPCTL0  DD  DISP=(NEW,DELETE),SPACE=(TRK,(10,10)),UNIT=&VIO,\n//             DCB=(LRECL=80,BLKSIZE=0,DSORG=PS,RECFM=FB)\n//ISPWRK1  DD  DISP=(NEW,DELETE),SPACE=(TRK,(10,10)),UNIT=&VIO,\n//             DCB=(LRECL=80,BLKSIZE=0,DSORG=PS,RECFM=FB)\n//ISPLST1  DD  DISP=(NEW,DELETE),SPACE=(TRK,(10,10)),\n//             DCB=(LRECL=133,BLKSIZE=0,DSORG=PS,RECFM=VB)\n//ISPLOG   DD  SYSOUT=*,\n//             DCB=(LRECL=120,BLKSIZE=2400,DSORG=PS,RECFM=FB)\n//ISPLIST  DD  SYSOUT=*,DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA)\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN        DD *\n  ISPSTART CMD(%PRMCKBAT)\n/*\n//REPORT   DD  SYSOUT=(*)\n//REPPROG  DD  SYSOUT=(*)\n//REPLPA   DD  SYSOUT=(*)\n//REPLNK   DD  SYSOUT=(*)\n//PARMLIB  DD  DISP=(SHR),DSN=SYS1.PARMLIB\n//PARMIN   DD  *\n#MACRO    PRMCK                             # DEFAULT: PRMCK\n#MACPARMS -REPORT                           # DEFAULT: -REPORT\n* COMMENT STARTING WITH * OR #\n# COMMENT STARTING WITH # OR *\n#NCL     PROG*    LNKLST*  LPALST*          # PRMCK DEFAULTS\nINCL     PROGLK  PROG00   LNKLST00 LPALST00\nEXCL     *BU\nPARMLIB  PARMLIB\n/*\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRMCK": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x001\\x01 \\x06O\\x01 \\x13_\\x13\\x08\\x07K\\x07\\x1c\\x00\\x00\\xd7\\xd9\\xd4\\xc3\\xd2@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2020-03-04T00:00:00", "modifydate": "2020-05-14T13:08:31", "lines": 1867, "newlines": 1820, "modlines": 0, "user": "PRMCK"}, "text": "/* ---------------------  rexx procedure  -------------------- *\n * Name:      PRMCK (ParmLib Check)                            *\n *                                                             *\n * Function:  Parmlib Member Validation                        *\n *            Support for PROGxx member statements             *\n *               - LNKLST                                      *\n *               - APF                                         *\n *               - LPA                                         *\n *               - SYSLIB                                      *\n *            Support for LNKLSTxx and LPALSTxx members        *\n *                                                             *\n *  Syntax: PRMCK cat sysres -debug -nowarn -noerror           *\n *                                                             *\n *  valid options are:                                         *\n *        -HELP will display a Tutorial Panel                  *\n *        ?   - will prompt for catalog and sysres             *\n *        cat - is a name that will be used in the master      *\n *              catalog lookup (find *custom* below) and       *\n *              if not found will be used as the master        *\n *              catalog name (enter without quotes).           *\n *        sysres is the volser of the system ipl volume        *\n *              to be checked when a volser of ****** is       *\n *              coded.                                         *\n *        -DEBUG   - turn on tracing                           *\n *        -NOWARN  - turn off warning messages                 *\n *        -NOERROR - turn off error messages                   *\n *        -NOSEC   - turn off secondary allocation warnings    *\n *        -REPORT  - create a report data set                  *\n *                                                             *\n *  System symbolics are supported in PROGxx for the volser    *\n *  at this time.  Future support will be there for them in    *\n *  the dataset name and elsewhere.                            *\n *                                                             *\n *  The member validation is a rough validation which verifies *\n *  that the keywords used are valid.  Not necessarily that the*\n *  right keywords are used together.  Dataset names are also  *\n *  validated, including existence in the catalog and on the   *\n *  volume.  Multiple occurances of a keyword are not checked  *\n *  nor are inappropriate uses of keywords (e.g. delete and add*\n *  in the same statement).  However this process has been used*\n *  and has caught the majority of the errors that we make.    *\n *                                                             *\n * Syntax:    ISPF Edit command PRMCK                          *\n *                                                             *\n * Author:    Lionel B. Dyck                                   *\n *            Internet: lbdyck'gmail.com                       *\n *                                                             *\n * History:                                                    *\n *            05/14/20 - Correct oversight test volser syms    *\n *                       for PROGxx                            *\n *            03/10/20 - Clean up typos                        *\n *            03/04/20 - Check for valid dsname (routine)      *\n *            11/16/18 - add var xdsnsave to check more precise*\n *                       - original dsname with symbols and vol*\n *            11/02/18 - clean up duplicate warning            *\n *            10/29/18 - add DD check for PRMCKDBG to enable   *\n *                       MACRO debug (only SYSENV='BACK')      *\n *                     - bug fix: initialize all variables for *\n *                       keywords SYSLIB and LPA like LNKLST   *\n *            10/05/18 - Correct if 2 line entry w/error to    *\n *                       display the full record (lbd)         *\n *            10/01/18 - BATCH: gather also line(s) with       *\n *                       leading blanks                        *\n *                     - bug fix: rpt_line was not added to    *\n *                       report if rpt_line2 is used.          *\n *            09/13/18 - ADD function mode to get values for   *\n *                       VERSION and DEFAULTS                  *\n *            09/10/18 - EDIT macro \"batchified\"               *\n *            06/25/18 - Corrections for handling system       *\n *                       symbols                               *\n *                     - Clean up code for SMS (thx HB)        *\n *            06/21/18 - Correction for SMS test (thx Gene Pate*\n *            05/09/18 - Display Tutorial Panel if NOT under   *\n *                       ISPF Edit or incorrect Member         *\n *            05/08/18 - Add -Help                             *\n *            05/07/18 - Turn off/restore PFSHOW               *\n *            04/27/18 - Multiple updates                      *\n *                     - move panels inline for easier distro  *\n *                     - check for load lib for apf/link/lpa   *\n *                       recfm=u                               *\n *            02/29/16 - Multiple updates                      *\n *                     - clean up displaying error lines       *\n *                     - get the master catalog info           *\n *                       dynamically                           *\n *                     - support for PROGxx DEFAULTS statement *\n *            02/28/16 - Update Extent warning for LNKLST      *\n *            08/09/10 - Correct if apf dsn ends with a .      *\n *                       Thanks to W. Jensen                   *\n *            03/29/04 - Correct bug with comments             *\n *                     - Put summary at top of file as notes   *\n *                     - Add -REPORT option                    *\n *            03/28/04 - Correct bug reprocessing last stmt    *\n *                     - add Age counter                       *\n *            03/25/04 - Fix missing quote on racf message     *\n *                     - Add warning if APF libraries have not *\n *                       been used for over 365 days.          *\n *            03/23/04 - Update for flip error/warning lines   *\n *                       Mathew E Goldstein of the IRS         *\n *            03/19/04 - Add Linklist Extent Checking          *\n *                       Mathew E Goldstein of the IRS         *\n *            03/18/04 - Add RACF checking and more thx to     *\n *                       Mathew E Goldstein of the IRS         *\n *            03/16/04 - Update for SMS vol from               *\n *                       Mathew E Goldstein of the IRS         *\n *                     - Added duplciate checking              *\n *            11/20/03 - Enhanced to support comments better\\  *\n *            10/17/03 - Add -NOWARN and -NOERROR options      *\n *                     - Change (DEBUG to -DEBUG               *\n *            10/25/02 - change to exclude lines not in error  *\n *            09/20/01 - minor fixes from Mathew Goldstein     *\n *            02/21/01 - minor corrections                     *\n *            09/11/00 - fix after check                       *\n *            09/05/00 - fix from  Herman  R. Stocker (HRS)    *\n *            11/19/99 - fixed dup msg if ext and sec > 0      *\n *            11/08/99 - fixed &SYSR1                          *\n *            11/04/99 - fixed SYSLIB checking                 *\n *            11/03/99 - find missing parenthesis              *\n *            10/20/99 - add support for vol of *mcat* (apf)   *\n *            10/19/99 - make lookup table more generic        *\n *            10/19/99 - if not on vol - find where cataloged  *\n *            10/18/99 - add lookup table and other options    *\n *            09/30/99 - additional cleanup                    *\n *            09/28/99 - extent and symbolic support           *\n *                     - changed name to PRMCK                 *\n *            09/27/99 - add lnklstxx and lpalstxx support     *\n *            09/26/99 - creation                              *\n *                                                             *\n * ----------------------------------------------------------- *\n * Copyright (c) 1999-2020 by Lionel B. Dyck                   *\n * ----------------------------------------------------------- */\n  _version_ = \"2.0 2018-09-13\"\n  _version_ = \"2.1 2018-10-01\"\n  _version_ = \"2.2 2018-10-05\"\n  _version_ = \"2.3 2018-10-29\"\n  _version_ = \"2.4 2018-11-02\"\n  _version_ = \"2.5 2018-11-16\"\n  _version_ = \"2.6 2020-03-04\"\n  _version_ = \"2.7 2020-03-10\"\n\n  _junk_ = sub_init()\n\n  if _sysenv_ = \"BACK\" ,\n    then do\n    _junk_ = MSG(\"OFF\")\n    \"ALLOC FI(PRMCKDBG) DATA(*)\"\n    rcode = rc\n    if rcode = 0 ,\n      then do\n      \"FREE FI(PRMCKDBG)\"\n    end\n    else do\n      _junk_ = trace(\"R\")\n      nop\n    end\n    _junk_ = MSG(\"ON\")\n  end\n\n  mem_patterns = \"LNKLST* LPALST* PROG*\"\n\n  if rexxinv = \"FUNCTION\" ,\n    then do\n    parse upper arg _parms_\n    parse var _parms_ word1 .\n    select\n      when ( word1 = \"VERSION\"  ) then _str_ = \"0 \"_version_\n      when ( word1 = \"DEFAULTS\" ) then _str_ = \"0 \"mem_patterns\n      otherwise                        _str_ = 4\n    end\n    return _str_\n  end\n  Address ISREDIT\n  \"MACRO (parm) NOPROCESS\"\n  rcode = rc\n  _junk_ = sub_check_edit_environment(rcode\" \"parm)\n  \"Reset\"\n\n  \"(dataset) = Dataset\"\n  \"(volume)  = volume\"\n  \"(member) = MEMBER\"\n\n/* -------------------- *\n | Load the ISPF Panels |\n * -------------------- */\n  load_info = loadispf()\n\n  Select\n    When left(member,6) = \"LNKLST\" then nop\n    When left(member,6) = \"LPALST\" then nop\n    When left(member,4) = \"PROG\" then nop\n    Otherwise do\n      Address ISPExec ,\n        'Select pgm(isptutor) parm(prmckh)'\n      call free_panels\n      exit 4\n    end\n  end\n\n/* ------------------------------------ *\n | Save the CAPS state and reset to OFF |\n * ------------------------------------ */\n  \"(savecaps) = CAPS\"\n  if savecaps = \"ON\" then\n  \"CAPS = OFF\"\n\n  parse value \"\" with null dsname volser sms cards_flipped ,\n    cont lnklpaxx_dsname report ,\n    master_cat sysres paren tdsnf ,\n    nowarn noerror nosec dupdsns stype\n  errors   = 0\n  warnings = 0\n  dups     = 0\n  aged     = 0\n  rprofs   = 0\n  extents  = 0\n  cmt_card = 0\n  parse value \"\" with editmsg\n  editrc    = 0\n  editmsg.0 = 0\n  process_loglevel = 0\n\n  If SYSVAR(SYSRACF) = 'AVAILABLE' Then\n  racf = sysvar('syslracf')\n  else racf = null\n\n/* ----------------------------------------------------- *\n * Process the parm                                      *\n * ----------------------------------------------------- */\n  parm = translate(parm)\n  if abbrev(\"-HELP\",parm,2) = 1 then do\n    Address ISPExec ,\n      'Select pgm(isptutor) parm(prmckh)'\n    call free_panels\n    exit 0\n  end\n  if wordpos(\"-DEBUG\",parm)   > 0 then trace \"?i\"\n  if wordpos(\"-NOWARN\",parm)  > 0 then nowarn = 1\n  if wordpos(\"-NOERROR\",parm) > 0 then noerror = 1\n  if wordpos(\"-NOSEC\",parm) > 0 then nosec = 1\n  if wordpos(\"-REPORT\",parm)  > 0 then do\n    report = 1\n    reportdd  = \"RPT\"random(99999)\n    reportdsn = \"PRMCK.\"reportdd\".LIST\"\n    n=0\n    if _sysenv_ = \"BACK\" ,\n      then do\n      n=n+1;report.n=\" \"\n      n=n+1;report.n=copies(\"=\",76)\n    end\n    minll = 20\n    if length(dataset) > minll ,\n      then _ll_ = length(dataset)\n    else _ll_ = minll\n    n=n+1;report.n = \"Report for Dataset:\" ,\n      left(dataset,_ll_) ,\n      \"Member: \"left(member,8)\" on Volser: \"volume\n    n=n+1;report.n = \" \"\n    report.0 = n\n    reportc   = n\n  end\n  parse value parm with cat res .\n  cat = word(parm,1)\n  res = word(parm,2)\n  if left(cat,1) = \"-\" then cat = null\n  if left(res,1) = \"-\" then res = null\n  if cat = \"?\" then do\n    cat = null\n    Address ISPExec\n    \"Addpop column(11) row(2)\"\n    call pfshow 'off'\n    \"Display Panel(PRMCKP)\"\n    call pfshow 'reset'\n    \"Rempop\"\n    Address ISREdit\n  end\n  if res <> null then\n  sysres = res\n\n/* ----------------------------------------------------- *\n *  Find the master catalog and set variable             *\n * ----------------------------------------------------- */\n  call outtrap \"cat.\"\n  address tso,\n    \"Listc ent('sys1.linklib')\"\n  call outtrap \"off\"\n  master_cat = word(cat.2,3)\n\n/* ----------------------------------------------------- *\n * Get sysres volser                                     *\n * ----------------------------------------------------- */\n  if sysres = null then\n  sysres = mvsvar('symdef','sysr1')\n\n/* ----------------------------------------------------- *\n * Get master catalog name                               *\n * ----------------------------------------------------- */\n  if master_cat = null then do\n    call outtrap \"cat.\"\n    Address TSO,\n      \"Listc ent('sys1.linklib')\"\n    call outtrap \"off\"\n    master_cat = word(cat.2,3)\n  end\n\n/* ----------------------------------------------------- *\n * Get master catalog volser                             *\n * ----------------------------------------------------- */\n  call outtrap \"cat.\"\n  Address TSO,\n    \"Listc ent('\"master_cat\"') volume\"\n  call outtrap \"off\"\n  last = cat.0\n  parse value cat.last with \"VOLSER------------\" master_vol .\n\n/* ----------------------------------------------------- *\n * Process all card images in the edit dataset(member)   *\n * ----------------------------------------------------- */\n  \"(last) = linenum .zl\"\n  last = last + 0\n  first_card = 1\n  \"EXCLUDE All\"\n\n  call pfshow 'off'\n  do card = 1 to last\n    \"(line)  = line\" card\n    new_card = 0\n    if left(line,2) <> \"  \" then do\n      save_first = first_card\n      first_card = card\n    end\n    else save_card = card\n    line = left(strip(line),72)\n    if pos(\"/*\",line) > 0 then call strip_comments\n    if length(line) > 0 then call test_card\n  end\n  save_first = first_card\n  call pfshow 'reset'\n  if tdsnf = 1 then dsname = null\n  if dsname <> null then do\n    card = card - 1\n    if dsname <> lnklpaxx_dsname then call test_dsname\n  end\n  if extents > 255 then call excess_extents\n\n  zedsmsg = null\n  if errors + warnings = 0 then \"flip .zf .zl\"\n\n  if report <> null then\n  call do_report \"  \"\n\n  if errors = 0 then errors = \"No\"\n  zedlmsg = \"Status:\" errors \"errors were encountered. \"\n  call edline \"line_before 1 = msgline '\"zedlmsg\"'\"\n  call do_report zedlmsg\n\n  if warnings = 0 then warnings = \"No\"\n  zedlmsg = \"With \"warnings ,\n    \"warnings encountered.\"\n  call edline \"line_before 1 = msgline '\"zedlmsg\"'\"\n  call do_report zedlmsg\n\n  if dups = 0 then zedlmsg = \"With No duplicates.\"\n  else\n  zedlmsg = \"With\" dups \"duplicates.\"\n  call edline \"line_before 1 = msgline '\"zedlmsg\"'\"\n  call do_report zedlmsg\n\n  if aged = 0 then zedlmsg = \"With No Aged data sets.\"\n  else\n  zedlmsg = \"With\" aged \"aged data sets.\"\n  call edline \"line_before 1 = msgline '\"zedlmsg\"'\"\n  call do_report zedlmsg\n\n  if rprofs = 0 then zedlmsg = \"With No Missing RACF Profiles.\"\n  else\n  zedlmsg = \"With\" rprofs \"missing RACF Profiles.\"\n  call edline \"line_before 1 = msgline '\"zedlmsg\"'\"\n  call do_report zedlmsg\n\n  if extents > 0 then do\n    zedlmsg = \"Linklist Extents:\" extents\n    call edline \"line_before 1 = msgline '\"zedlmsg\"'\"\n    call do_report zedlmsg\n  end\n/* ---------------------------------- *\n * Create the Report and then View It *\n * ---------------------------------- */\n  if report <> null then do\n    if _sysenv_ = \"BACK\" ,\n      then do\n      select\n        when ( abbrev(member,\"PROG\") = 1 ) ,\n          then do\n          address tso ,\n            \"Execio * diskw REPPROG  ( stem report. )\"\n          execio_rc = rcode\n        end\n        when ( abbrev(member,\"LNK\")  = 1 ) ,\n          then do\n          address tso ,\n            \"Execio * diskw REPLNK   ( stem report. )\"\n          execio_rc = rcode\n        end\n        when ( abbrev(member,\"LPA\")  = 1 ) ,\n          then do\n          address tso ,\n            \"Execio * diskw REPLPA   ( stem report. )\"\n          execio_rc = rcode\n        end\n        otherwise execio_rc = 4\n      end\n      if execio_rc <> 0 ,\n        then do\n        address tso ,\n          \"Execio * diskw REPORT   ( stem report. )\"\n        execio_rc = rcode\n      end\n    end\n    else do\n      alloc_parm = \"new Spa(15,15) tr DS(\"reportdsn\")\" ,\n        \"Recfm(v b) Lrecl(84) Blksize(0)\"\n      Address TSO\n      \"Alloc f(\"reportdd\") \"alloc_parm\n      \"Execio * diskw\" reportdd \"(finis stem report.\"\n      \"Free f(\"reportdd\")\"\n      Address ISPExec ,\n        \"View Dataset(\"reportdsn\")\"\n    end\n    Address ISREdit\n  end\n\n  if imacrunning = 1 ,\n    then do\n    \"Up Max\"\n  end\n\n  \"CAPS =\" savecaps\n  Call free_panels\n  if _sysenv_ = \"BACK\" ,\n    then do\n    \"END\"\n  end\n  select\n    when ( errors   > 0 ) then editrc = 8\n    when ( warnings > 0 ) then editrc = 4\n    otherwise                  editrc = 0\n  end\n  if editmsg.0 > 0 ,\n    then do\n    do idx = 1 to editmsg.0\n      editmsg = editmsg\"<MSG.\"idx\">\"editmsg.idx\"</MSG.\"idx\">\"\n    end\n    editmsg = \"<MSG.0>\"editmsg.0\"</MSG.0>\"editmsg\n  end\n  address ispexec \"vput (editrc editmsg)\"\n  Exit 0\n\n/* ----------------------------------------------------------------- */\nsub_init:\n  /* to get the correct name for MYMSGID don't use other cmds before */\n  parse source ,\n    rexxenv rexxinv rexxname rexxdd rexxdsn . rexxtype addrspc .\n  myname = rexxname\n  if myname = \"?\" ,\n    then do ;\n    myname = sysvar(\"sysicmd\")\n    if length(myname) = 0 ,\n      then  myname = sysvar(\"syspcmd\")\n  end;\n  mymsgid = left(myname\":\",10)\n\n  _sysenv_ = SYSVAR(\"SYSENV\")\n  parse value \"\" with dispmsg dispmsg_old\n  return 0\n\nsub_check_edit_environment:\n  parse arg _rc_ _parm_\n  ineditmacro = 0\n  imacrunning = 0\n\n  ineditmacro = (_rc_ = 0)\n  if ineditmacro ,\n    then do\n        /*\n           according to the ISPF Edit and Edit Macros manual,\n           Chapter 2. Controlling the edit environment, the section\n           Initial macros, under the Notes section:\n              2. Remember that commands referencing display values\n                 (DISPLAY_COLS , DISPLAY_LINES, DOWN, LEFT, RIGHT,\n                 UP, LOCATE) are invalid in an initial macro because\n                 no data has been displayed.\n        */\n    address ispexec \"CONTROL ERRORS RETURN\"\n    address isredit \"up m\"\n    imacrunning = (rc <> 0)\n  end\n /*\n say mymsgid\"ineditmacro         \"ineditmacro\n say mymsgid\"Initial Edit Macro  \"imacrunning\n say mymsgid\"Macro parms ......  \"_parm_\n say \" \"\n */\n  return 0\n\n/* --------------------------- *\n | Turn off and Restore PFSHOW |\n * --------------------------- */\npfshow:\n  if _sysenv_ = \"BACK\" then return 0\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    Address ISPExec ,\n      'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    Address ISPExec ,\n      'vget (zpfshow)'\n    pfkeys = zpfshow\n    Address ISPExec ,\n      'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n\n/* --------------------------------------- *\n * line_after or say (BATCH)               *\n * --------------------------------------- */\n /*                                               */\n /*  \"line_after\" card \"= msgline '\"rpt_line\"'\"   */\n /*  \"line_before 1 = msgline '\"zedlmsg\"'\"        */\n /*                                               */\nedline:\n  parse arg _data_\n  parse var _data_ 1 editcmd editdata                     ,\n    1 . \"=\" . _data_\n  if _sysenv_ = \"BACK\" ,\n    then do\n    _data_ = strip(_data_)\n    if left(_data_,1)\"-\"right(_data_,1) = \"'-'\" ,\n      then _data_ = substr(_data_,2,length(_data_)-2)\n    key_word = translate(word(_data_,1))\n    select\n      when ( left(_data_,05)       = \"     \"  ) ,\n        then gather_message = \"YES\"\n      when ( translate(\"WARNING:\") = key_word ) ,\n        then gather_message = \"YES\"\n      when ( translate(\"ERROR:\")   = key_word ) ,\n        then gather_message = \"YES\"\n      otherwise gather_message = \"NO\"\n    end\n    if gather_message = \"YES\" ,\n      then do\n      editidx   = editmsg.0 + 1\n      editmsg.0 = editidx\n      editmsg.editidx = _data_\n    end\n           /*\n           say left(_data_,60)\"\"left(member,8)\" - EDL \"\n           */\n    say      _data_\n  end\n  else do\n    \"\"editcmd\" \" editdata\n  end\n  return 0\n\n/* --------------------------------------- *\n * line_after or say (BATCH)               *\n * --------------------------------------- */\nDo_line_after:\n  parse arg _data_\n  if _sysenv_ = \"BACK\" ,\n    then do\n    parse var _data_ 1 . \"=\" . _data_\n    say \"DBG: \"_data_\n  end\n  else do\n    \"line_after\" _data_\n  end\n  return 0\n\n/* --------------------------------------- *\n * Add to the Report stem if Report active *\n * --------------------------------------- */\nDo_Report:\n  parse arg data\n  if report = null then return\n  reportc = reportc + 1\n  report.reportc = data\n  return\n\n/* ---------------------------------- *\n * Strip all comments from the record *\n * ---------------------------------- */\nStrip_comments:\n  parse value line with left\"/*\" . \"*/\"right\n  line = left right\n  return\n\n/* ----------------------------------------------------- *\n * Test for various control statements                   *\n * ----------------------------------------------------- */\nTest_Card:\n  val   = 0\n  tdsnf = 0\n  do word = 1 to words(line)\n    call test_word word(line,word)\n    if val = 1 then call invalid_keyword\n    val = 0\n    if new_card = 1 then leave\n  end\n\n/* ----------------------------------------------------- *\n * Now test for missing paren's                          *\n * ----------------------------------------------------- */\n  data = strip(line)\n  lp = 0 ; rp = 0\n  do c = 1 to length(data)\n    if substr(data,c,1) = \"(\" then\n    lp = lp + 1\n    if substr(data,c,1) = \")\" then\n    rp = rp + 1\n  end\n  if lp <> rp then\n  call missing_paren\n  return\n\n/* ----------------------------------------------------- *\n * Test specific keyword                                 *\n * ----------------------------------------------------- */\nTest_Word:\n  arg keyword\n  Select\n    When left(member,4) = \"PROG\" then do\n      call Test_Prog\n    end\n    When left(member,6) = \"LNKLST\" then do\n      type = \"LNKLST\"\n      call Test_LNKLPAxx\n    end\n    When left(member,6) = \"LPALST\" then do\n      type = \"LPA\"\n      call Test_LNKLPAxx\n    end\n    otherwise val = 1\n  end\n  if new_card = 0 then cmt_card = 0\n  return\n\n/* ----------------------------------------------------- *\n * Process ongoing process message                       *\n * ----------------------------------------------------- */\nDisp_Process:\n  if _sysenv_ = \"BACK\" ,\n    then do\n    if dispmsg = null ,\n      then nop\n    else do\n      if dispmsg = dispmsg_old ,\n        then nop\n      else do\n        dispmsg_old = dispmsg\n        if process_loglevel > 0 ,\n          then say \"process ... \"dispmsg\n      end\n    end\n    return 0\n  end\n  Address ISPEXec\n  \"Control Display Lock\"\n  \"Addpop column(11) row(2)\"\n  \"Display Panel(PRMCK)\"\n  \"Rempop\"\n  Address ISREdit\n  return\n\n/* ----------------------------------------------------- *\n * Test LNKLSTxx and LPALSTxx members                    *\n * ----------------------------------------------------- */\nTest_LnkLpaxx:\n  mcat_test = 1\n  cardk     = card\n  new_card  = 1\n  if cont = 0 then call Cont_After_End\n  if right(keyword,1) = \",\" then cont = 1\n  else cont = 0\n  if pos(\"(\",keyword) > 0 then\n  parse value keyword with dsname \"(\" volser \")\" .\n  else do\n    parse value keyword with dsname \",\" .\n    volser = null\n  end\n  lnklpaxx_dsname = dsname\n  dispmsg = dsname\n  call Disp_Process\n  call test_dsname\n  return\n\n/* ----------------------------------------------------- *\n * Test PROGxx member of SYS1.PARMLIB                    *\n * ----------------------------------------------------- */\nTest_Prog:\n  call fix_volser\n  Select\n    when word(line,1) = \"DEFAULTS\" then do\n      new_card = 1\n      call test_defaults\n    end\n    When keyword = \"EXIT\" then do\n      type    = \"EXIT\"\n      parse value \"\" with dsname volser sms dsname dupdsns\n      cardk   = card\n      mcat_test = 0\n    end\n    When keyword = \"APF\" then do\n      type    = \"APF\"\n      if stype <> type then do\n        parse value \"\" with dsname volser sms dsname dupdsns\n        stype   = type\n      end\n      mcat_test = 0\n      if dsname <> null then do\n        card = card - 1\n        call test_dsname\n        card = card + 1\n      end\n      parse value \"\" with dsname volser sms\n      cardk   = card\n    end\n    When keyword = \"LNKLST\" then do\n      type    = \"LNKLST\"\n      if stype <> type then do\n        parse value \"\" with dsname volser sms dsname dupdsns\n        stype   = type\n      end\n      mcat_test = 1\n      if dsname <> null then do\n        card = card - 1\n        call test_dsname\n        card = card + 1\n      end\n      parse value \"\" with dsname volser\n      cardk   = card\n    end\n    When keyword = \"SYSLIB\" then do\n      type    = \"SYSLIB\"\n      if stype <> type then do\n        parse value \"\" with dsname volser sms dsname dupdsns\n        stype   = type\n      end\n      mcat_test = 1\n      if dsname <> null then do\n        card = card - 1\n        call test_dsname\n        card = card + 1\n      end\n      parse value \"\" with dsname volser\n      cardk   = card\n    end\n    When keyword = \"LPA\" then do\n      type    = \"LPA\"\n      if stype <> type then do\n        parse value \"\" with dsname volser sms dsname dupdsns\n        stype   = type\n      end\n      mcat_test = 1\n      if dsname <> null then do\n        card = card - 1\n        call test_dsname\n        card = card + 1\n      end\n      parse value \"\" with dsname volser\n      cardk   = card\n    end\n    otherwise do\n      call Disp_Process\n      Select\n        when type = \"APF\" then call test_apf\n        when type = \"EXIT\" then call test_exit\n        when type = \"LNKLST\" then call test_lnklst\n        when type = \"LPA\" then call test_lpa\n        when type = \"SYSLIB\" then call test_syslib\n        when type = \"SYSLIB\" then call test_syslib\n        otherwise val = 1\n      end\n    end\n  end\n  return\n\n/* ------------------------------ *\n * Test DEFAULTS keyword (Progxx) *\n * ------------------------------ */\nTest_Defaults:\n  defdata = subword(line,3)\n  dtype = word(line,2)\n  keyword = ''\n  defdata = translate(defdata,' ','()')\n  do idw = 1 to words(defdata)\n    Select\n      When dtype = \"LNKLST\" then do\n        if wordpos(word(defdata,idw),\"REQCOPYFROM NOREQCOPYFROM\" ,\n          \" COPYFROMCUR NOCOPYFROMCUR\") = 0 then do\n          val = 1\n          keyword = keyword word(defdata,idw)\n        end\n      end\n      When dtype = \"LPA\" then do\n        if wordpos(word(defdata,idw),\"ADDALIAS \" ,\n          \"NOADDALIAS\") = 0 then do\n          val = 1\n          keyword = keyword word(defdata,idw)\n        end\n      end\n      When dtype = \"EXIT\" then do\n        if wordpos(word(defdata,idw),\"EXITTYPE ALL \" ,\n          \"INSTALLATION NOTPROGRAM\") = 0 then do\n          val = 1\n          keyword = keyword word(defdata,idw)\n        end\n      end\n    Otherwise nop\n    end\n  end\n  return\n\n/* ----------------------------------------------------- *\n * Test APF keywords (Progxx)                            *\n * ----------------------------------------------------- */\nTest_APF:\n  volser = null\n  Select\n    When keyword = \"ADD\" then nop\n    When keyword = \"DELETE\" then nop\n    When keyword = \"SMS\" then sms = \"SMS\"\n    When left(keyword,7) = \"DSNAME(\" then do\n      parse value keyword with \"DSNAME(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n    end\n    When left(keyword,4) = \"DSN(\" then do\n      parse value keyword with \"DSN(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n    end\n    When left(keyword,4) = \"VOL(\" then\n    parse value keyword with \"VOL(\" volser \")\"\n    When left(keyword,7) = \"VOLUME(\" then\n    parse value keyword with \"VOLUME(\" volser \")\"\n    When left(keyword,7) = \"VOLSER(\" then\n    parse value keyword with \"VOLSER(\" volser \")\"\n    When left(keyword,7) = \"FORMAT(\" then do\n      parse value keyword with \"FORMAT(\" format \")\"\n      if wordpos(format,\"DYNAMIC STATIC\") = 0 then val = 1\n    end\n    otherwise val = 1\n  end\n  call fix_volser\n  return\n\n/* ----------------------------------------------------- *\n * Test EXIT keywords (Progxx)                           *\n * ----------------------------------------------------- */\nTest_Exit:\n  Select\n    When keyword = \"ADD\"      then nop\n    When keyword = \"DELETE\"   then nop\n    When keyword = \"ATTRIB\"   then nop\n    When keyword = \"UNDEFINE\" then nop\n    When keyword = \"ABENDNUM\" then nop\n    When keyword = \"MODIFY\"   then nop\n    When keyword = \"FIRST\"    then nop\n    When keyword = \"LAST\"     then nop\n    When left(keyword,9) = \"EXITNAME(\" then nop\n    When left(keyword,7) = \"KEEPRC(\" then nop\n    When left(keyword,8) = \"JOBNAME(\" then nop\n    When left(keyword,8) = \"MODNAME(\" then do\n      parse value keyword with \"MODNAME(\" modname \")\"\n      dispmsg = \"Modname\" modname\n      call Disp_Process\n    end\n    When left(keyword,9) = \"EXITNAME(\" then do\n      parse value keyword with \"EXITNAME(\" exitname \")\"\n      dispmsg = \"Exitname\" exitname\n      call Disp_Process\n    end\n    When left(keyword,7) = \"DSNAME(\" then do\n      parse value keyword with \"DSNAME(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      call test_dsname\n    end\n    When left(keyword,6) = \"STATE(\" then do\n      parse value keyword with \"STATE(\" state \")\"\n      if wordpos(state,\"ACTIVE INACTIVE\") = 0 then val = 1\n    end\n    When left(keyword,6) = \"FORCE(\" then do\n      parse value keyword with \"FORCE(\" force \")\"\n      if wordpos(force,\"YES NO\") = 0 then val = 1\n    end\n    otherwise val = 1\n  end\n  return\n\n/* ----------------------------------------------------- *\n * Test LNKLST keywords (progxx)                         *\n * ----------------------------------------------------- */\nTest_LNKLST:\n  volser = null\n  Select\n    When keyword = \"ACTIVATE\"   then nop\n    When keyword = \"ADD\"        then nop\n    When keyword = \"ATBOTTOM\"   then nop\n    When keyword = \"ATTOP\"      then nop\n    When keyword = \"DEFINE\"     then nop\n    When keyword = \"DELETE\"     then nop\n    When keyword = \"NOCHECK\"    then nop\n    When keyword = \"UNALLOCATE\" then nop\n    When keyword = \"UNDEFINE\"   then nop\n    When keyword = \"UPDATE\"     then nop\n    When keyword = \"SMS\" then sms = \"SMS\"\n    When left(keyword,6) = \"AFTER(\" then do\n      parse value keyword with \"AFTER(\" aftdsn \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n    end\n    When left(keyword,4) = \"JOB(\" then nop\n    When left(keyword,5) = \"ASID(\" then nop\n    When left(keyword,9) = \"COPYFROM(\" then nop\n    When left(keyword,4) = \"DSN(\" then do\n      parse value keyword with \"DSN(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n    end\n    When left(keyword,7) = \"DSNAME(\" then do\n      parse value keyword with \"DSNAME(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n    end\n    When left(keyword,5) = \"NAME(\" then\n    parse value keyword with \"NAME(\" name \")\"\n    When left(keyword,4) = \"VOL(\" then\n    parse value keyword with \"VOL(\" volser \")\"\n    When left(keyword,7) = \"VOLSER(\" then\n    parse value keyword with \"VOLSER(\" volser \")\"\n    When left(keyword,7) = \"VOLUME(\" then\n    parse value keyword with \"VOLUME(\" volser \")\"\n    otherwise val = 1\n  end\n  call fix_volser\n  return\n\n/* ----------------------------------------------------- *\n * Test LPA keywords    (progxx)                         *\n * ----------------------------------------------------- */\nTest_LPA:\n  volser = null\n  Select\n    When keyword = \"ADD\"        then nop\n    When keyword = \"CURRENT\"    then nop\n    When keyword = \"DELETE\"     then nop\n    When keyword = \"FIXED\"      then nop\n    When keyword = \"OLDEST\"     then nop\n    When keyword = \"PAGEABLE\"   then nop\n    When keyword = \"PAGEPROTPAGE\" then nop\n    When left(keyword,7) = \"CSALIM(\" then nop\n    When left(keyword,5) = \"MASK(\" then nop\n    When left(keyword,8) = \"MODNAME(\" then nop\n    When left(keyword,6) = \"FORCE(\" then do\n      parse value keyword with \"FORCE(\" force \")\"\n      if force <> \"YES\" then val = 1\n    end\n    When left(keyword,7) = \"DSNAME(\" then do\n      parse value keyword with \"DSNAME(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n      if dsname = \"LNKLST\" then dsname = null\n    end\n    When left(keyword,4) = \"DSN(\" then do\n      parse value keyword with \"DSNAME(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n      if dsname = \"LNKLST\" then dsname = null\n    end\n    When left(keyword,7) = \"VOLSER(\" then\n    parse value keyword with \"VOLSER(\" volser \")\"\n    otherwise val = 1\n  end\n  call fix_volser\n  return\n\n/* ----------------------------------------------------- *\n * Test SYSLIB keywords (progxx)                         *\n * ----------------------------------------------------- */\nTest_SYSLIB:\n  Select\n    When left(keyword,7) = \"LPALIB(\" then do\n      parse value keyword with \"LPALIB(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n      call test_dsname\n      dsname = null\n    end\n    When left(keyword,7) = \"MIGLIB(\" then do\n      parse value keyword with \"MIGLIB(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n      call test_dsname\n      dsname = null\n    end\n    When left(keyword,7) = \"CSSLIB(\" then do\n      parse value keyword with \"CSSLIB(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n      call test_dsname\n      dsname = null\n    end\n    When left(keyword,8) = \"LINKLIB(\" then do\n      parse value keyword with \"LINKLIB(\" dsname \")\"\n      if right(keyword,1) <> \")\" then\n      if word(line,word+1) = \")\" then word = word + 1\n      dispmsg = dsname\n      call Disp_Process\n      call test_dsname\n      dsname = null\n    end\n    otherwise val = 1\n  end\n  return\n\n/* ----------------------------------------------------- *\n * Test validity of the dataset name                     *\n * ----------------------------------------------------- */\nTest_Dsname:\n  dsname_save = dsname\n  lmvol = null\n  tdsnf = 1\n  do forever\n    if pos(\"&\",dsname) > 0 then call fix_symdef\n    else leave\n  end\n  dsnok = dsnvalid(dsname)\n  if dsnok = 'NO' then do\n    call not_valid\n    return\n  end\n  Select\n    When sms = \"SMS\" then call test_sms\n    When volser = null then\n    call test_catalog\n    When volser <> null then do\n      if volser = \"******\" then volser = sysres\n      call fix_volser\n      lmvol = \"Vol(\"volser\")\"\n      call test_volume\n    end\n    Otherwise nop\n  end\n  if racf <> null then call test_racf\n  call test_dsndcb\n  call test_dsnVALID\n  xdsn = dsname\"/\"volser\n  xdsnsave = dsname_save\"/\"volser\n  if type <> \"EXIT\" then\n /*if wordpos(xdsn,dupdsns) > 0 then do */\n  if wordpos(xdsnsave,dupdsns) > 0 then do\n    if nowarn = 1 then return\n    parse var xdsnsave 1 xdsnname \"/\" xdsnvol\n    if strip(xdsnvol) = \"\" ,\n      then xdsnsave_info = strip(xdsnname)\n    else xdsnsave_info = strip(xdsnsave)\n    rpt_line = \"Warning: \"xdsnsave_info,\n      \"appears to be a duplicate.\"\n    call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n     /* Comment Start\n     call Do_line_after card \"= msgline '\"rpt_line\"'\"\n        Comment End */\n    call flip_line\n    dups = dups + 1\n    warnings = warnings + 1\n  end\n  else do\n    dupdsns = strip(dupdsns\" \"xdsnsave)\n  end\n  return\n\n/* ----------------------------------------------------- *\n * Fixup dsname found with system symbolics              *\n * ----------------------------------------------------- */\nFix_Symdef:\n  parse value dsname with . '&' symbol '.' .\n  if pos(\"&\",symbol) > 0 then\n  parse value dsname with symbol '&' .\n  p1 = pos(\"&\"symbol,dsname)\n  p1l = length(symbol)\n  newdsnl = left(dsname,p1-1)\n  p1r = p1l + p1\n  newdsnr = right(dsname,length(dsname)-p1r)\n  if left(newdsnr,2) = \"..\" then\n  newdsnr = substr(newdsnr,1)\n  if left(newdsnr,1) = \".\" then\n  newdsnr = substr(newdsnr,2)\n  newdsn = newdsnl\"\"mvsvar('symdef',symbol)\"\"newdsnr\n  newdsn = strip(newdsn,'t','.')   /* W.Jensen */\n  dsname = newdsn\n  return\n\n/* ----------------------------------------------------- *\n * Fixup volser found with system symbolics              *\n * ----------------------------------------------------- */\nFix_volser:\n  if pos('&',volser) = 0 then return\n  parse value volser with . '&' symbol '.' .\n  p1 = pos(\"&\"symbol,volser)\n  p1l = length(symbol)\n  newvoll = left(volser,p1-1)\n  p1r = p1l + p1\n  newvolr = right(volser,length(volser)-p1r)\n  if left(newvolr,2) = \"..\" then\n  newvolr = substr(newvolr,1)\n  if left(newvolr,1) = \".\" then\n  newvolr = substr(newvolr,2)\n  newvol = newvoll\"\"mvsvar('symdef',symbol)\"\"newvolr\n  newvol = strip(newvol,'t','.')\n  volser = newvol\n  return\n\n /* ----------------------------------------------------- *\n  * Test RACF Status of dataset                           *\n  * ----------------------------------------------------- */\nTest_RACF:\n  call listdsi \"'\"dsname\"'\" norecall\n  if sysracfa = 'NONE' then Do\n    if nowarn = 1 then return\n    rpt_line = \"Warning:\" dsname,\n      \"No RACF profile\"\n    call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n    rprofs = rprofs + 1\n    warnings = warnings + 1\n    call flip_line\n  End\n  return\n\n/* -------------------------------------------- *\n * Test to see if the dataset is a load library *\n * RECFM=U and DSORG=PO or POE                  *\n * -------------------------------------------- */\nTest_DSNDCB:\n  x=listdsi(\"'\"dsname\"' Vol(\"volser\")\")\n  if left(sysdsorg,2) /= 'PO' then call Not_PO\n  if sysrecfm         /= 'U'  then call Not_LOAD\n  return\n\n/* ----------------------------------------------------- *\n * Test existence  of dataset                            *\n * ----------------------------------------------------- */\nTest_DSNVALID:\n  IF listdsi(\"'\"dsname\"'\") > 0 & sysreason=1 THEN\n  call Not_VALID\n  return\n\n/* ----------------------------------------------------- *\n * Test SMS Status of dataset                            *\n * ----------------------------------------------------- */\nTest_SMS:\n  call listdsi \"'\"dsname\"' norecall smsinfo\"\n  select\n    when ( sysreason = 5 )     then call Not_Catalog  /*gp*/\n    when ( sysreason = 9 )     then call Migrate_Msg\n    otherwise do\n      if sysstorclass = null then call Not_SMS\n    end\n  end\n  return\n\n/* ----------------------------------------------------- *\n * Test Catalog status of datasets                       *\n * ----------------------------------------------------- */\nTest_Catalog:\n  call outtrap \"cat.\"\n  Address TSO \"Listc ent('\"dsname\"') vol\"\n  cat_rc = rc\n  call outtrap \"off\"\n  x = cat.0\n  volser = substr(cat.x,26,6)\n  if cat_rc > 0 then do\n    call Not_Catalog\n    return\n  end\n  if Mcat_Test = 1 then do\n    call outtrap \"c.\"\n    Address TSO \"Listc ent('\"dsname\"') cat('\"master_cat\"')\"\n    c_rc = rc\n    call outtrap \"off\"\n    if c_rc > 0 then call Not_Master_Cat\n  end\n  if volser = \"******\" then volser = sysres\n  call fix_volser\n  lmvol = \"Vol(\"volser\")\"\n  volser = sysres\n  call test_volume\n  return\n\n/* ----------------------------------------------------- *\n * Test dataset on volume                                *\n * ----------------------------------------------------- */\nTest_Volume:\n  sysvolume = null\n  call listdsi \"'\"dsname\"'\" lmvol\n  if sysreason > 0 then do\n    call listdsi \"'\"dsname\"'\"\n    if sysvolume <> null then\n    found_vol = sysvolume\n    else found_vol = null\n    call Not_OnVolume\n  end\n  else do\n    if wordpos(type,\"LNKLST\") = 1 then do\n      extents = extents + 1\n      if sysused <> 'N/A' Then Do\n        if sysextents > 1 then Do\n          extents = extents + sysextents - 1\n          call mult_extents\n        end\n        else if sysseconds > 0 then call mult_seconds\n      end\n    end\n    if sms <> null then\n    if volser <> null then do\n      call listdsi \"'\"dsname\"' smsinfo\"\n      if sysmgmtclass <> null then call not_defined_sms\n    end\n  end\n  if sysrefdate = null then return\n  if sysrefdate = 0 then sysrefdate = syscreate\n  parse value sysrefdate with ryear\"/\"rdays\n  refdate = right(ryear,2)right(rdays+1000,3)\n  refdate = date('b',refdate,'j')\n  today   = date('b')\n  if (today - refdate) > 365 then call Long_Time\n  return\n\n/* ----------------------------------------------------- *\n * Set messages                                          *\n * ----------------------------------------------------- */\nMissing_Paren:\n  if nowarn = 1 then return\n  rpt_line = \"Error: Missing parenthesis\",\n    \"on the previous statement.\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nCont_After_End:\n  if noerror = 1 then return\n  rpt_line = \"Error: Invalid Continuation \"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nMigrate_Msg:\n  if nowarn = 1 then return\n  rpt_line = \"Error: Dataset Migrated\",\n    \"unable to determine SMS Status\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nNot_Catalog:\n  if noerror = 1 then return\n  rpt_line = \"Error:\" dsname \"Not Cataloged\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nNot_Master_Cat:\n  if noerror = 1 then return\n  rpt_line = \"Error:\" dsname ,\n    \"Not Cataloged in the Master Catalog\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nNot_OnVolume:\n  if noerror = 1 then return\n  rpt_line2 = null\n  if found_vol <> null then do\n    rpt_line2 = \"       was found on:\" found_vol\n    call edline \"line_after\" card \"= msgline '\"rpt_line2\"'\"\n  end\n  rpt_line = \"Error:\" dsname \"Not on\" volser\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  found_vol = null\n  call do_report rpt_line\n  if rpt_line2 <> null then\n  call do_report rpt_line2\n  call flip_line\n  '(check) = line' card\n  if pos(' ',check) = 1 then do\n    scard = card\n    card = card -1\n    call flip_line\n    card = scard\n  end\n  return\n\nNot_SMS:\n  if nowarn = 1 then return\n  rpt_line = \"Warning:\" dsname,\n    \"Not SMS Managed\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  warnings = warnings + 1\n  call flip_line\n  return\n\nNot_Load:\n  if nowarn = 1 then return\n  rpt_line = \"Error:\" dsname ,\n    'Not a Load Library.'\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nNot_VALID:\n  if nowarn = 1 then return\n  rpt_line = \"Error:\" dsname ,\n    'IS INVALID|'\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nNot_PO:\n  if nowarn = 1 then return\n  rpt_line = \"Error:\" dsname ,\n    'Not a Partitioned Dataset'\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nLong_Time:\n  if type <> \"APF\" then return\n  if nowarn = 1 then return\n  rpt_line = \"Warning:\" dsname,\n    \"last referenced\" ,\n    date(,refdate,'b')\".\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  warnings = warnings + 1\n  aged     = aged + 1\n  call flip_line\n  return\n\nNot_Defined_SMS:\n  if nowarn = 1 then return\n  rpt_line2 = \"         volume:\" volser\n  call edline \"line_after\" card \"= msgline '\"rpt_line2\"'\"\n  rpt_line = \"Warning:\" dsname,\n    \"SMS Managed but defined to\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  warnings = warnings + 1\n  call flip_line\n  call do_report rpt_line\n  if rpt_line2 <> null then\n  call do_report rpt_line2\n  return\n\nMult_Extents:\n  if nowarn = 1 then return\n  rpt_line = \"Warning:\" dsname ,\n    \"has\" sysextents \"used extents\"\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  warnings = warnings + 1\n  call flip_line\n  return\n\nMult_Seconds:\n  if nowarn = 1 then return\n  if nosec = 1 then return\n  warn = \"Warning:\"\n  if sysextents > 1 then do\n    rpt_line = \"         Using\" sysextents \" extents\"\n    call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n    warn = \"Error:\"\n  end\n  rpt_line = warn dsname ,\n    \"has secondary allocation of\" sysseconds\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  if sysextents = 1 ,\n    then warnings = warnings + 1\n  else errors = errors + 1\n  call flip_line\n  return\n\nInvalid_Keyword:\n  if noerror = 1 then return\n  if words(keyword) > 1 then kw = \"keywords\"\n  else kw = \"keyword\"\n  rpt_line = \"Error:\",\n    \"record has a syntax error in\" kw \":\" ,\n    keyword\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\nExcess_Extents:\n  if noerror = 1 then return\n  card = card - 1\n  rpt_line = \"Error: link list\",\n    extents\" extents exceeds the maximum 255\",\n    keyword\n  call edline \"line_after\" card \"= msgline '\"rpt_line\"'\"\n  errors = errors + 1\n  call flip_line\n  return\n\n/* ----------------------------------------------------------- *\n * This routine will flip (un-hide) the current record. Since  *\n * this routine may be called multiple times the record number *\n * is saved and tested to prevent un-hiding and then hiding.   *\n * ----------------------------------------------------------- */\nFlip_Line:\n  if wordpos(card,cards_flipped) > 0 then return\n  \"Label\" card \"= .rec\"\n  'flip .rec'\n  cards_flipped = cards_flipped card\n  return\n\nFree_Panels:\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\ndsnvalid: Procedure Expose null\n  /* Tests for a 'potentially valid' z/OS datasetname */\n  parse arg val_dsn\n  if strip(val_dsn) = null then return 'NO'\n  val_dsn = strip(val_dsn,'B',\"'\")\n  upp = TRANSLATE(val_dsn,\".ABCDEFGHIJKLMNOPQRSTUVWXYZ\",,\n    \".abcdefghijklmnopqrstuvwxyz\")\n  tdsn = translate(val_dsn,' ','.')\n  retval = 'OK'   /* asssume good */\n  do i = 1 to words(tdsn)\n    w = word(tdsn,i)\n    if length(w) > 8 then retval = 'NO'\n    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'\n    w = translate(w,left(' ',39,' '), ,\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')\n    w = strip(w)\n    if w /= null then retval = 'NO'\n  end\n  if retval /= 'NO' then\n  if upp = val_dsn then do\n    smsg = msg()\n    call msg 'OFF'\n    if sysdsn(\"'\"val_dsn\"'\") = \"OK\" | ,\n       sysdsn(\"'\"val_dsn\"'\") = \"DATASET NOT FOUND\"\n    then retval = 'OK'\n    else retval = \"NO\"\n    call msg smsg\n  end\n  return retval\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n /*\n>START\n>Panel PRMCK\n)Attr Default(%+_)\n/* + type(text  ) intens(low )                   information only  */\n  _ type( input) intens(high) caps(off) just(left )\n  # type(output) intens(high)  caps(off) just(left ) color(yellow)\n  \u00dd type(output) intens(high)  caps(off) just(right) color(yellow)\n   % type(text) intens(high)\n   $ type(text) intens(high) color(blue) hilite(reverse)\n)Body Window(43,5)\n+Processing: #dispmsg\n+Statement:  \u00ddcard +out of\u00ddlast   +\n+Warnings:\u00ddwarnings+Errors:       \u00dderrors +\n+Dups:    \u00dddups    +RACF Profiles:\u00ddrprofs +\n+Aged:    \u00ddaged    +\n)Init\n &zwinttl = 'Parmlib Validation Progress'\n)Proc\n)End\n>Panel PRMCKH\n)Attr Default(%+_)\n/* + type(text  ) intens(low )                   information only  */\n _ type( input) intens(high) caps(on) just(left )\n # type(output) intens(high)  caps(off) just(left ) color(yellow)\n % type(text) intens(high)\n $ type(text) intens(high) color(blue) hilite(reverse)\n)Body expand(//)\n%-/-/$Parmlib Verification Help%/-/-\n+Command ===>_zcmd\n+\n%PRMCK+is an%ISPF Edit Command+that will check the syntax\n+of%PROGxx, LNKLSTxx, LPALSTxx members.\n+\n%Syntax:+PRMCK cat sysres -debug -nowarn -noerror\n+\n+     ?   - will prompt for catalog and sysres\n+     cat - is a name that will be used in the master\n+           catalog lookup (find *custom* below) and\n+           if not found will be used as the master\n+           catalog name (enter without quotes).\n+     sysres is the volser of the system ipl volume\n+           to be checked when a volser of ****** is\n+           coded.\n+     -DEBUG   - turn on tracing\n+     -Help    - display this tutorial panel\n+     -NOWARN  - turn off warning messages\n+     -NOERROR - turn off error messages\n+     -NOSEC   - turn off secondary allocation warnings\n+     -REPORT  - create a report data set\n)Proc\nver (&cat,dsname)\n&zcont = prmckh\n)End\n>Panel PRMCKP\n)Attr Default(%+_)\n/* + type(text  ) intens(low )                   information only  */\n  _ type( input) intens(high) caps(on) just(left )\n  \u00dd type( input) intens(high) caps(on) just(left ) pad(_) color(green)\n  # type(output) intens(high)  caps(off) just(left ) color(yellow)\n   % type(text) intens(high)\n   $ type(text) intens(high) color(blue) hilite(reverse)\n)Body Window(64,2) Expand(//)\n+Master Catalog: \u00ddcat                                          +\n+Sysres:         \u00ddres   +\n)Init\n &zwinttl = 'Parmlib Verification Setup'\n)Proc\n ver (&cat,dsname)\n)End\n>End\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRMCKBAT": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00E\\x01\\x18'\\x8f\\x01\\x18'\\x8f\\x081\\x02\\xe5\\x02\\xe5\\x00\\x00\\xd7\\xd9\\xd4\\xc3\\xd2@@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-10-05T00:00:00", "modifydate": "2018-10-05T08:31:45", "lines": 741, "newlines": 741, "modlines": 0, "user": "PRMCK"}, "text": "/* REXX **************************************************************/\n/*                                                                   */\n/*  member name:    PRMCKBAT                                         */\n/*                                                                   */\n/*  member type:                                                     */\n/*                                                                   */\n/*  Author:         Hartmut                        DATE: 2018-09-05  */\n/*                                                                   */\n/*  Description:    Interface to LBD's EDIT macro PRMCK ___________  */\n/*                  _______________________________________________  */\n/*                  _______________________________________________  */\n/*                  _______________________________________________  */\n/*                                                                   */\n/*  History:  (most recent on top)                                   */\n/*  ver  ___date___ who comment                                      */\n/*  1.3  2018-10-01 HB  - cosmetics                                  */\n/*  1.2  2018-09-13 HB  - get mem_patterns = PRMCK('DEFAULTS')       */\n/*                        (requires PRMCK version 2.*)               */\n/*                      - bug fix: check listdsi rc                  */\n/*                      - check active ISPF environment (initial)    */\n/*  1.1  2018-09-12 HB  - add ZISPFRC                                */\n/*  1.0  2018-09-05 HB  _initial_                                    */\n/*                                                                   */\n/*********************************************************************/\n/* PARMS:  PARMIN(ddname)  - default PARMIN                          */\n/*********************************************************************/\n/* testrun                 ///DEBUG(ON)                              */\n/* testrun PARMIN(DD01)    ///DEBUG(ON)                              */\n/*                                                                   */\n/*********************************************************************/\n/* WISH(es):                                                         */\n/*   ISPFSTATS for PARMLIB members                                   */\n/*********************************************************************/\n  MyVersion = \"1.2  2018-09-13\"\n  MyVersion = \"1.3  2018-10-01\"\n\n  MyDesc    = \"Interface to LBD's EDIT macro PRMCK\"\n\n  _junk_ = TRACE(\"N\")\n\n  signal on novalue name sub_novalue\n  _junk_ = sub_init()\n  if sysispf = \"ACTIVE\" ,\n  then nop\n  else do\n           say \" \"\n           say \"\"mymsgid\"Error\" ,\n               \"- an ACTIVE ISPF environment is required.\"\n           say \" \"\n           exit 20\n       end\n  rcode = 0\n  maxcc = 0\n  parse upper arg all_parms\n  parse var   all_parms 1 arg_parms \"///\" run_parms\n  parse var   run_parms 1 . ,\n                        1 . \"DEBUG(\"   _debug_   \")\" . ,\n                          .\n  if _debug_ = \"ON\" ,\n  then do\n          SAY \"\"mymsgid\"DEBUG - started ... (version: \"MyVersion\")\"\n          say \" \"\n          _junk_ = TRACE(\"R\")\n       end\n\n  _timestamp_ = timestamp()\n  say mymsgid\"\"_timestamp_\" - started ...\",\n                          \"(version: \"MyVersion\")\"\n  say mymsgid\"\"_timestamp_\"   (\"MyDesc\")\"\n  say \" \"\n  if pos(\"?\",all_parms) > 0 ,\n  then do\n          _junk_ = sub_help()\n          maxcc = 1\n       end\n  if maxcc = 0 ,\n  then do\n          rcode = sub_parameter_check(arg_parms)\n          maxcc = max(maxcc,rcode)\n       end\n  if maxcc = 0 ,\n  then do\n          rcode = sub_main()\n          maxcc = max(maxcc,rcode)\n       end\n  if maxcc = 0 ,\n  then do\n          /* rcode = sub_xyz()        */\n          /* maxcc = max(maxcc,rcode) */\n       end\n\n\n  _timestamp_ = timestamp()\n  say \" \"\n  if maxcc = 0 ,\n  then nop\n  else do\n          say mymsgid\"\"_timestamp_\" - please check message(s)\"\n       end\n  say mymsgid\"\"_timestamp_\" - ending with MAXCC=\"maxcc\n  say \" \"\n  if ispfback = \"YES\" ,\n  then do\n          zispfrc = maxcc\n          address ispexec \"VPUT (ZISPFRC)\"\n       end\n exit maxcc\n\n/* ----------------------------------------------------------------- */\n/*  main-section                                                     */\n/* ----------------------------------------------------------------- */\nsub_main:\n  rcode = 0\n  /* ... your code ...   */\n  n=0\n  do idx = 1 to words(parmlibs)\n     n=n+1;parmlib.n = word(parmlibs,idx)\n     parmlib.0 = n\n  end\n  do idx = 1 to parmlib.0\n     parmdd = parmlib.idx\n     parse value \"\" with listdsi_rc sysreason sysdsname sysvolume\n     parse value \"\" with SYSMSGLVL1 SYSMSGLVL2\n     listdsi_rc = listdsi(parmdd\" FILE\")\n     parmlib.idx.1 = parmdd\n     parmlib.idx.2 = listdsi_rc\n     parmlib.idx.3 = sysdsname\n     parmlib.idx.4 = sysvolume\n     _msgtxt_ = left(\"############\",03) ,\n                left(\" RC         \",04) ,\n                left(\"DDNAME      \",08) ,\n                left(\"DSNAME      \",35) ,\n                left(\"VOLSER      \",06) ,\n                \"\"\n     say mymsgid\"\"_msgtxt_\n     _msgtxt_ = left(copies(\"-\",30),03) ,\n                left(copies(\"-\",30),04) ,\n                left(copies(\"-\",30),08) ,\n                left(copies(\"-\",30),35) ,\n                left(copies(\"-\",30),06) ,\n                \"\"\n     say mymsgid\"\"_msgtxt_\n     _msgtxt_ = right(idx,3,0) ,\n                right(parmlib.idx.2,04) ,\n                left(parmlib.idx.1,08) ,\n                left(parmlib.idx.3,35) ,\n                left(parmlib.idx.4,06) ,\n                \"\"\n     say mymsgid\"\"_msgtxt_\n     maxcc = max(maxcc,parmlib.idx.2)\n     if parmlib.idx.2 = 0 ,\n     then do\n             rcode = sub_get_members_to_be_processed(parmdd)\n             maxcc = max(maxcc,rcode)\n          end\n  end\n return rcode\n\n\n/* ----------------------------------------------------------------- */\n/*  sub-procedures                                                   */\n/* ----------------------------------------------------------------- */\nsub_init:\n  /* to get the correct name for MYMSGID don't use other cmds before */\n  parse source ,\n              rexx_env                  ,\n              rexx_inv                  ,\n              rexx_name                 ,\n              rexx_dd                   ,\n              rexx_dsn                  ,\n              rexx_invokename           ,\n              rexx_initial_host_com_env ,\n              rexx_addrspc              ,\n              rexx_user_token           ,\n              rexx_unknown\n\n  rexx_program_type = \"EXEC\"\n  select\n    when ( rexx_name                             <> \"?\" ) then nop\n    when ( rexx_dd                               <> \"?\" ) then nop\n    when ( rexx_dsn                              <> \"?\" ) then nop\n    when ( rexx_invokename                       <> \"?\" ) then nop\n    otherwise rexx_program_type = \"LMOD\"\n  end\n  myname = rexx_name\n  if myname = \"?\" ,\n  then do ;\n           myname = sysvar(\"sysicmd\")\n           if length(myname) = 0 ,\n           then  myname = sysvar(\"syspcmd\")\n       end;\n  mymsgid = left(myname\":\",10)\n\n  parse value \"\" with _null_\n\n  sysname   = MVSVAR(\"SYSNAME\")\n  sysplex   = MVSVAR(\"SYSPLEX\")\n  jobname   = MVSVAR(\"SYMDEF\",\"JOBNAME\")\n  lpar      = MVSVAR(\"SYMDEF\",\"LPAR\")\n  sysispf   = SYSVAR(\"SYSISPF\")              /* ACTIVE or NOT ACTIVE */\n  sysenv    = SYSVAR(\"SYSENV\")               /* FORE   or BACK       */\n  sysnest   = SYSVAR(\"SYSNEST\")              /* YES    or NO         */\n  sysoslvl  = MVSVAR(\"SYMDEF\",\"SYSOSLVL\")    /* Z1020200 - 02.02.00  */\n\n  if sysispf\"-\"sysenv = \"ACTIVE-BACK\" ,\n  then ispfback = \"YES\"\n  else ispfback = \"NO\"\n\n  parmin.0   = 0\n  myparmin.0 = 0\n  member.0   = 0\n  summary.0  = 0\n  global_vars = \"myname   mymsgid  \" ,\n                \"maxcc             \" ,\n                \"_null_            \" ,\n                \"parmin. myparmin. \" ,\n                \"default_MEMBINCL  MEMBINCL MEMBEXCL \" ,\n                \"EDITMACN EDITMACP \" ,\n                \"member.           \" ,\n                \"\"\n  global_vars = space(global_vars,1)\n return 0\n\n/* ----------------------------------------------------------------- */\ntimestamp: procedure\n  _time_  = time(\"N\")\n  /*\n  _time_  = time(\"L\")\n  */\n  _dates_ = date(\"S\")\n  dateiso = translate(\"1234-56-78\",_dates_,\"12345678\")\n  _str_ = dateiso\" \"_time_\n return _str_\n\n/* ----------------------------------------------------------------- */\nsub_help:\n  SAY \"Sorry, HELP is not available.\"\n  SAY \"... perhaps in future ...\"\n  /*\n  PARMDSN SYS1.PARMLIB\n  PARMDSN SYS1.PARMLIB CAT (default) or SYS1.PARMLIB . (place holder)\n  PARMDSN SYS1.PARMLIB . VOL001 ...\n  */\n return 0\n\n/* ----------------------------------------------------------------- */\nsub_parameter_check:\n  rcode = sub_parm_defaults(\"INIT\")\n  parmin_default = \"PARMIN\"\n  parse arg parms_to_check\n  parse var parms_to_check 1 . ,\n            1 . \"PARMIN(\"   _parmin_   \")\" . ,\n              .\n  if   _parmin_ = _null_ ,\n  then _parmin_ = parmin_default\n  _parmin_      = strip(_parmin_)\n\n  read_parmin = \"YES\"\n  listdsi_rc = listdsi(_parmin_\" FILE\")\n  listdsi_rc = listdsi_rc + 0\n  sysreason  = sysreason  + 0\n  if listdsi_rc\"#\"sysreason = \"16#2\" ,\n  then read_parmin = \"NO\"\n  if read_parmin = \"YES\"  ,\n  then do\n          say mymsgid\"read from DD \"_parmin_\" ...\"\n          rcode = sub_parameter_read(_parmin_)\n          if rcode = 0 ,\n          then do\n                   rcode = sub_parameter_analyze()\n               end\n       end\n  else do\n          say mymsgid\"use default values\"\n          rcode = 0\n       end\n  rcode = sub_parm_defaults(\"SET\")\n return rcode\n\n/* ----------------------------------------------------------------- */\nsub_parameter_read:\n  parse arg ddname .\n  address TSO\n  \"EXECIO * DISKR \"ddname\" (STEM parmin. FINIS)\"\n  read_rc = rc\n  if read_rc = 0 ,\n  then do\n          if parmin.0 = 0 ,\n          then do\n                  say mymsgid\"no lines(s)  read from \"ddname\n               end\n          else do\n                  column_line = \"\"\n                  do cidx = 1 to 8\n                     column_line = column_line\"----+----\"cidx\n                  end\n                  column_line = left(column_line,72)\n                  say mymsgid\"show parm(s) read from \"ddname\n                /*\n                  say left(\"#####\",3)\"\"copies(\" \",3)\"\"copies(\"-\",72)\n                */\n                  say left(\"#####\",3)\"\"copies(\" \",3)\"\"column_line\n                  do idx = 1 to parmin.0\n                     parmin.idx = strip(left(parmin.idx,72),\"T\")\n                     say right(idx,3,0)\"   \"parmin.idx\n                  end\n                  say left(\"-----\",3)\"\"copies(\" \",3)\"\"copies(\"-\",72)\n                  say \" \"\n               end\n       end\n  else do\n          say \" \"\n          say mymsgid\"EXECIO read error - DD \"left(ddname,8)\"\",\n                     \"- RC=\"read_rc\n          rcode = 512\n       end\n return rcode\n\n/* ----------------------------------------------------------------- */\n/* MACRO    PRMCK                                                    */\n/* MACPARMS REPORT                                                   */\n/* * COMMENT STARTING WITH * OR #                                    */\n/* # COMMENT STARTING WITH # OR *                                    */\n/* #        12345678 12345678 12345678                               */\n/* INCL     PROG*    LNKLST*  LPALST*       # strip comment          */\n/* EXCL     *BU                                                      */\n/* #                                                                 */\n/* PARMLIB                                                           */\n/* PARMLIBS                                                          */\n/* PARMDSN                                                           */\n/* PARMDSNS                                                          */\n/*                                                                   */\n/* LOGLEVEL 0 - 3    (default 1 )                                    */\n/* ISPFSTAT YES / NO (default)                                       */\n/*                                                                   */\n/* ----------------------------------------------------------------- */\nsub_parameter_analyze:\n  n=0\n  do idx = 1 to parmin.0\n     _parmin_ = strip(parmin.idx)\n     select\n       when (left(_parmin_,1) = \"*\" ) then iterate\n       when (left(_parmin_,1) = \"#\" ) then iterate\n       otherwise do\n                   parse var _parmin_ 1 _parmin_ \"#\" .\n                   _parmin_ = strip(left(_parmin_,72),\"T\")\n                   n=n+1 ; myparmin.n = _parmin_\n                   myparmin.0=n\n                 end\n     end\n  end\n  do idx = 1 to myparmin.0\n     parm_line = myparmin.idx\n     parse var parm_line _key_ _val_\n     _key_ = strip(_key_)\n     _val_ = space(strip(_val_),1)\n     if left(_val_,1) = \"=\" ,\n     then do\n             parse var _val_ 1 . \"=\" _val_\n             _val_ = space(strip(_val_),1)\n          end\n     select\n       when ( _key_ = \"MACRO\"     ) then EDITMACN = word(_val_,1)\n       when ( _key_ = \"MACPARMS\"  ) then EDITMACP =      _val_\n       when ( _key_ = \"MEMBINCL\"  ) then MEMBINCL = MEMBINCL\"\"_val_\" \"\n       when ( _key_ = \"MEMBEXCL\"  ) then MEMBEXCL = MEMBEXCL\"\"_val_\" \"\n       when ( _key_ = \"INCL\"      ) then MEMBINCL = MEMBINCL\"\"_val_\" \"\n       when ( _key_ = \"EXCL\"      ) then MEMBEXCL = MEMBEXCL\"\"_val_\" \"\n       when ( _key_ = \"PARMLIB\"   ) then PARMLIBS = PARMLIBS\"\"_val_\" \"\n       when ( _key_ = \"PARMLIBS\"  ) then PARMLIBS = PARMLIBS\"\"_val_\" \"\n       when ( _key_ = \"PARMDSN\"   ) then nop\n       when ( _key_ = \"PARMDSNS\"  ) then nop\n       when ( _key_ = \"PARMDSN\"   ) then PARMDSNS = PARMDSNS\"\"_val_\" \"\n       when ( _key_ = \"PARMDSNS\"  ) then PARMDSNS = PARMDSNS\"\"_val_\" \"\n       when ( _key_ = \"ISPFSTAT\"  ) then nop\n       when ( _key_ = \"LOGLEVEL\"  ) then nop\n       otherwise do\n           say mymsgid\"\"left(\"WARNING   \",10)\"\"left(\"parms   \",14),\n                      \"unsupported keyword: \"_key_\n           say \" \"\n           rcode = max(rcode,8)\n         end\n     end\n  end\n return rcode\n\n/* ----------------------------------------------------------------- */\nsub_parm_defaults:\n  parse upper arg _mode_ .\n  select\n    when ( _mode_ = \"INIT\" ) ,\n      then do\n              n=0\n              n=n+1;defaults.n.1 = \"LOGLEVEL\" ;defaults.n.2=1\n              n=n+1;defaults.n.1 = \"ISPFSTAT\" ;defaults.n.2=\"NO\"\n              n=n+1;defaults.n.1 = \"PARMDSNS\" ;defaults.n.2=\"\"\n              n=n+1;defaults.n.1 = \"PARMLIBS\" ;defaults.n.2=\"PARMLIB\"\n              n=n+1;defaults.n.1 = \"MACRO\"    ;defaults.n.2=\"PRMCK\"\n              n=n+1;defaults.n.1 = \"MACPARMS\" ;defaults.n.2=\"REPORT\"\n              n=n+1;defaults.n.1 = \"MEMBEXCL\" ;defaults.n.2=\"*BU\"\n              n=n+1;defaults.n.1 = \"MEMBINCL\" ;\n                      defaults.n.2 = \"PROG* LNKLST* LPALST*\"\n              defaults.0 = n\n              default_LOGLEVEL = 1\n              default_ISPFSTAT = \"NO\"\n              default_PARMDSNS = \"\"\n              default_PARMLIBS = \"PARMLIB\"\n              default_EDITMACN = \"PRMCK\"\n              default_EDITMACP = \"-REPORT\"\n              default_MEMBEXCL = \"*BU\"\n              default_MEMBINCL = \"PROG* LNKLST* LPALST*\"\n              do idx = 1 to words(default_MEMBINCL)\n                 default_MEMBINCL.idx = word(default_MEMBINCL,idx)\n                 default_MEMBINCL.0   = idx\n              end\n              LOGLEVEL = _null_\n              ISPFSTAT = _null_\n              PARMDSNS = _null_\n              PARMLIBS = _null_\n              EDITMACN = _null_\n              EDITMACP = _null_\n              MEMBINCL = _null_\n              MEMBEXCL = _null_\n              rcode = 0\n           end\n    when ( _mode_ = \"SET\"  ) ,\n      then do\n             if LOGLEVEL = _null_ then LOGLEVEL = default_LOGLEVEL\n             if ISPFSTAT = _null_ then ISPFSTAT = default_ISPFSTAT\n             if PARMDSNS = _null_ then PARMDSNS = default_PARMDSNS\n             if PARMLIBS = _null_ then PARMLIBS = default_PARMLIBS\n             if EDITMACN = _null_ then EDITMACN = default_EDITMACN\n             if EDITMACP = _null_ then EDITMACP = default_EDITMACP\n             if MEMBEXCL = _null_ then MEMBEXCL = default_MEMBEXCL\n             if MEMBINCL = _null_ ,\n             then do\n                     MEMBINCL = default_MEMBINCL\n                     _cmd_ = \"_str_ = \"EDITMACN\"('VERSION')\"\n                     interpret _cmd_\n                     _cmd_ = \"_str_ = \"EDITMACN\"('DEFAULTS')\"\n                     interpret _cmd_\n                     parse var _str_ 1 _rc_ mem_patterns\n                     if _rc_ = 0 ,\n                     then do\n                              if  mem_patterns <> _null_ ,\n                              then MEMBINCL = mem_patterns\n                          end\n                  end\n\n             LOGLEVEL = strip(word(LOGLEVEL,1))\n             PARMDSNS = space(PARMDSNS,1)\n             PARMLIBS = space(PARMLIBS,1)\n             EDITMACN = space(EDITMACN,1)\n             EDITMACP = space(EDITMACP,1)\n             MEMBINCL = space(MEMBINCL,1)\n             MEMBEXCL = space(MEMBEXCL,1)\n             PARMDSNS = \"(not supported yet)\"\n             ISPFSTAT = \"(not supported yet)\"\n             LOGLEVEL = \"(not supported yet)\"\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"PARMLIBS DD(s) \"PARMLIBS\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"MEMBINCL       \"MEMBINCL\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"MEMBEXCL       \"MEMBEXCL\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"EDITMACN       \"EDITMACN\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"EDITMACP       \"EDITMACP\n             say \" \"\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"PARMDSNS DSNs  \"PARMDSNS\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"ISPFSTAT       \"ISPFSTAT\n             say mymsgid\"\"left(\"PARM-INFO\",10)\"LOGLEVEL       \"LOGLEVEL\n             select\n               when ( pos(\"*\",parmlibs) > 0 ) then _msg_ = \"P1\"\n               when ( pos(\"?\",parmlibs) > 0 ) then _msg_ = \"P1\"\n               when ( pos(\"%\",parmlibs) > 0 ) then _msg_ = \"P1\"\n               otherwise _msg_ = _null_\n             end\n             select\n               when ( _msg_ = \"P1\" ) ,\n                 then do\n                         say \" \"\n                         say mymsgid\"\"left(\"ERROR    \",10)\"PARMLIBS\",\n                           \"    - generic values not allowed\"\n                         rcode = 8\n                      end\n               otherwise nop\n             end\n           end\n    otherwise rcode = 504\n  end\n\n  membexcl.0 = 0\n  membincl.0 = 0\n  if rcode = 0 ,\n  then do\n          say \" \"\n          /* now check, if member patterns are allowed         */\n          /* MEMBINCL defaults must be considered, not shorter */\n          if membexcl <> _null_ ,\n          then do\n                   do idx = 1 to words(membexcl)\n                      _word_ = word(membexcl,idx)\n                      membexcl.idx = _word_\n                      membexcl.0   = idx\n                      if left(_word_,1) = \"*\" ,\n                      then nop\n                      else do\n                      xcode = sub_check_pattern_membincl(_word_)\n                      rcode = max(rcode,xcode)\n                           end\n                   end\n               end\n          if membincl <> _null_ ,\n          then do\n                   do idx = 1 to words(membincl)\n                      _word_ = word(membincl,idx)\n                      membincl.idx = _word_\n                      membincl.0   = idx\n                      xcode = sub_check_pattern_membincl(_word_)\n                      rcode = max(rcode,xcode)\n                   end\n               end\n       end\n return rcode\n\n/* ----------------------------------------------------------------- */\nsub_check_pattern_membincl: procedure expose default_MEMBINCL. ,\n                                             default_MEMBINCL  ,\n                                      (global_vars)\n  rcode = 0\n  parse arg _pattern_ .\n  _ll_ = length(_pattern_)\n  select\n    when ( right(_pattern_,1) = \"*\" ) ,\n      then do\n              word_base = left(_pattern_,_ll_-1)\n           end\n    otherwise word_base = _pattern_\n  end\n  if rcode = 0 ,\n  then do\n          pattern_invalid = \"YES\"\n          do defidx = 1 to default_MEMBINCL.0\n             def_word = default_MEMBINCL.defidx\n             _dl_ = length(def_word)\n             parse var def_word 1 def_word_base \"*\" .\n             select\n               when (        def_word_base=word_base      ) ,\n                 then do\n                         pattern_invalid = \"NO\"\n                         leave\n                      end\n               when ( abbrev(def_word_base,word_base) = 1 ) ,\n                 then do\n                         pattern_invalid = \"NO\"\n                         leave\n                      end\n               when ( abbrev(word_base,def_word_base) = 1 ) ,\n                 then do\n                         pattern_invalid = \"NO\"\n                         leave\n                      end\n               otherwise nop\n             end\n          end\n          if pattern_invalid = \"YES\" ,\n          then do\n                         say mymsgid\"\"left(\"ERROR    \",10)\"invalid\",\n                           \"pattern   - reason: \" ,\n                           \"\"left(_pattern_,10)\" not beginning like\" ,\n                           \"PRMCK requirement: \"default_MEMBINCL\n                         rcode = 8\n               end\n       end\n  if rcode = 0 ,\n  then do\n          do defidx = 1 to default_MEMBINCL.0\n             def_word = default_MEMBINCL.defidx\n             _dl_ = length(def_word)\n             select\n               when ( _pattern_ = def_word ) then nop\n               when ( abbrev(def_word,word_base) = 1 ) ,\n                 then do\n                         say mymsgid\"\"left(\"ERROR    \",10)\"invalid\",\n                           \"pattern   - reason: \" ,\n                           \"\"left(_pattern_,10)\" < \"left(def_word,10),\n                           \"- PRMCK requires at least \"def_word\n                         rcode = 8\n                      end\n               otherwise do\n                 end\n             end\n          end\n       end\n  /*\n  */\n return rcode\n\n/* ----------------------------------------------------------------- */\nsub_get_members_to_be_processed: procedure expose (global_vars)\n /*********************************************************************/\n /* Loop through all members in the PDS, issuing the EDIT service for */\n /* each.  The macro specified on the ISRMBRS invocation is passed as */\n /* an initial macro on the EDIT service call.                        */\n /*********************************************************************/\n  parse arg _ddname_ .\n  address ispexec\n  \"LMINIT DATAID(data1)    DDNAME(\"_ddname_\") enq(shr)\"\n  memall.0 = 0\n  \"LMOPEN DATAID(\"data1\") OPTION(INPUT)\"\n  lmrc = rc\n  Do While lmrc = 0\n     \"LMMLIST DATAID(\"data1\") OPTION(LIST)\" ,\n              \"MEMBER(MEMBER) STATS(NO)\"\n     lmrc = rc\n     If lmrc = 0 ,\n     Then Do\n              member = strip(member)\n              do jjj = 1 to words(default_MEMBINCL)\n                 _pattern_ = word(default_MEMBINCL,jjj)\n                 parse var _pattern_ 1 _pattern_ \"*\" .\n                 if abbrev(member,_pattern_) = 1 ,\n                 then do\n                          jj     = memall.0 + 1\n                          memall.0 = jj\n                          memall.jj = member\n                      end\n              end\n          End\n  End\n  \"LMCLOSE DATAID(\"data1\") \"\n  say \" \"\n  say \" \"\n  _junk_ = sub_member_include_exclude()\n  say \" \"\n  \"LMFREE DATAID(\"data1\")\"\n return 0\n\n/* ----------------------------------------------------------------- */\nsub_member_include_exclude:\n  excluded.0 = 0\n  member.0   = 0\n  /* MEMBINCL MEMBEXCL   */\n  do idx = 1 to memall.0\n     _member_ = strip(memall.idx)\n     _flag_    = \"OK\"\n     if _flag_ = \"OK\" ,\n     then do\n             do jjj = 1 to words(MEMBEXCL)\n               _pattern_ = word(MEMBEXCL,jjj)\n                select\n                  when (      _pattern_    = _member_  ) ,\n                    then do\n                                    _flag_ = \"EXCLUDE\"\n                         end\n                  when ( left(_pattern_,1) = \"*\" ) ,\n                    then do\n                            parse var _pattern_ 1 . \"*\" patt_base\n                            patt_base = strip(patt_base)\n                            ll_pb = length(patt_base)\n                            if right(_member_,ll_pb) = patt_base ,\n                            then    _flag_ = \"EXCLUDED\"\n                         end\n                  otherwise nop\n                end\n                if _flag_ = \"OK\" ,\n                then nop\n                else leave\n             end\n          end\n     if _flag_ = \"OK\" ,\n     then do\n             do jjj = 1 to words(MEMBINCL)\n               _pattern_ = word(MEMBINCL,jjj)\n                select\n                  when (      _pattern_    = _member_  ) ,\n                    then            _flag_ = \"INCLUDED\"\n                  when ( right(_pattern_,1) = \"*\" ) ,\n                    then do\n                            parse var _pattern_ 1 patt_base \"*\" .\n                            patt_base = strip(patt_base)\n                            ll_pb = length(patt_base)\n                            if left(_member_,ll_pb) = patt_base ,\n                            then    _flag_ = \"INCLUDED\"\n                         end\n                  otherwise nop\n                end\n                if _flag_ = \"OK\" ,\n                then nop\n                else leave\n             end\n          end\n     if _flag_ = \"INCLUDED\" ,\n     then do\n              memidx          = member.0 + 1\n              member.0        = memidx\n              member.memidx   = _member_\n              _msgtxt_ = copies(\"=\",74)\n              say mymsgid\"\"_msgtxt_\n              _msgtxt_ = \"MEMBER \"left(_member_,8)\" - EDIT starting ...\"\n              say mymsgid\"\"_msgtxt_\n              say \" \"\n              EDITMACP = \"-REPORT\"\n              Address ispexec ,\n                       \"EDIT DATAID(\"data1\") MEMBER(\"_member_\")\" ,\n                       \"PARM(EDITMACP)\" ,\n                       \"MACRO(\"EDITMACN\")\"\n              rcode = rc\n              /* Return codes                     */\n              /*  4 - Data not saved              */\n              address ispexec \"vget (editrc editmsg)\"\n              if rcode = 4 then rcode = 0\n              if datatype(editrc) = \"NUM\" ,\n              then rcode = max(rcode,editrc)\n              if editrc = 0 ,\n              then nop\n              else do\n                      /*\n                       say editmsg\n                      */\n                   end\n              _msgtxt_ = \"MEMBER \"left(_member_,8)\" - RC=\"rcode\n              say mymsgid\"\"_msgtxt_\n              maxcc = max(maxcc,rcode)\n              say \" \"\n          end\n  end\n return 0\n\n/* ----------------------------------------------------------------- */\n/*********************************************/\n/* Trap uninitialized variables              */\n/*********************************************/\nsub_novalue:\n  Say \" \"\n  Say \"Variable\" condition(\"Description\") ,\n      \"undefined in line\" sigl\":\"\n  Say \" \"\n  Say sourceline(sigl)\n  Say \" \"\n  if sysvar(\"sysenv\") <> \"FORE\" then exit 8\n  say \"Report the error in this application\",\n      \"along with the syntax used.\"\n exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/CBT.V500.FILE312.PDS/PRMCK.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312/CBT.V500.FILE312.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}