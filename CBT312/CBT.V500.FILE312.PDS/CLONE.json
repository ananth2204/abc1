{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "T311LBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20160601184745000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "T311LBD.LIONEL.EXECFB", "INMMEMBR": "T311LBD.LIONEL.EXECFB", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"T311LBD.LIONEL.EXECFB": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "160153", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x1e'", "DS1LSTAR": "b'\\x00(\\x02'", "DS1TRBAL": "b'\\xcc\\x88'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x17\\xa0\\x00\\x04\\x94\\xa0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x17\\xa0\\x00\\x04\\x94\\xa0\\xd8'", "b'X\\x9f\\x89@\\x00\\x00\\x08\\xaf\\x00\\x08\\x08\\xb2\\x00\\x08\\x00.'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"CLONE": {"ttr": 9987, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00Y\\x01\\x16\\x15?\\x01\\x16\\x15?\\x13F\\x01\\x9b\\x01\\x9b\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2016-06-01T00:00:00", "modifydate": "2016-06-01T13:46:59", "lines": 411, "newlines": 411, "modlines": 0, "user": "SYSLBD"}, "text": "/**  REXX -- CREATE ANOTHER VERSION OF A D/S UNDER ISPF 3.4  **/\n/* FROM CBTTAPE FILE 357 */\n/* ----------------------------------------------------------- *\n * UPDATE 06/01/2016 TO SUPPORT PDSE DATASETS WITH GENERATIONS *\n *                                                             *\n * NOTE: AT THIS POINT IN TIME THERE IS NO WAY TO COPY THE     *\n *       GENERATIONS                                           *\n *                                                             *\n * BY LIONEL B. DYCK                                           *\n * ----------------------------------------------------------- */\n\n/* ------------- Start of Doc--------------------------------- *\n CLONE  NEWDSN  ( # | +# | -# )  ( EMPTY )  ( RELEASE ) ( Q# )\n\n       creates a new data set with the same attributes as the one\n       overtyped. Sequential, partitioned data sets extended\n       (PDSE's) or partitioned data sets (PDS's) may be\n       duplicated. NEWDSN may be fully qualified with quotes,\n       e.g.  'SYS4.MACLIB', or allowed to take on the user\n       prefix, e.g. TEST.DATA. Please note you must have\n       sufficient access authority to create a dataset under\n       whatever security system is in use.\n\n       The original name may be used as a prefix by typing an\n       equal sign (=) followed by the intended suffix in place of\n       NEWDSN.  Overtyping SYS4.MACLIB with =.BKUP will produce a\n       new data set named SYS4.MACLIB.BKUP; the new data set name\n       must not exist and should be a legitimate name for the\n       invoking user to create.\n\n       The original data set may be used as a suffix by typing\n       the intended prefix followed by an equal sign (=).\n+                          ___________\n       Overtyping SYS4.MACLIB with YOURUID.= will create a new\n       data set named YOURID.SYS4.MACLIB.\n\n       Using either the above mentioned prefixing or suffixing\n       options will always cause the resultant new data set name\n       to be fully qualified, i.e. as if it were input within\n       quotes. Use a blank following the new data set choice if\n       there is any doubt about how it will be \"seen\" by the\n       system.\n\n       An option of Q# will reduce the initial qualifiers of the\n       original data set by # for prefixed XXX= or the final\n       qualifiers for suffixed =XXX new data set names.  Given\n       the preceding example, a Q1 will cause YOURUID.MACLIB to\n       be created.\n\n       Optionally, EMPTY may be specified with the new name to\n       not cause data to be copied.\n\n       Optionally, RELEASE may be specified to release unused\n       space following copying data (useful for back up\n       versions).\n\n       You may also specify a change to directory blocks; for\n       partitioned data sets only, a new number or an\n       increment/decrement may be specified (no sign means\n       replace, a '+' causes that number to be added and a '-' to\n       be subtracted).  The new number may not be below the\n       currently used directory size when causing data to be\n       copied.\n\n       So, if SYS1.MACLIB is the data set shown in the data set\n       list, entering the command over ot of\n\n          CLONE  +17  RUBBER.DUCKY  EMPTY\n\n       will create a new PDS under your ID (assuming your prefix\n       is the default) with the name RUBBER.DUCKY with no members\n       and with 17 more directory blocks then the original.\n\n       For sequential data sets, specifying a number or a number\n       prefixed by a plus(+) or minus(-) will cause a change to\n       the logical record length. An unsigned number will cause\n       the resultant data set to have that number as its LRECL. A\n       plus value, +#, will cause # to be added to the LRECL; a\n       minus value, -#, will cause that # to be subtracted from\n       the LRECL. If the new record length is greater then the\n       old, blanks will be used to pad on the right. Variable\n       lengths are the LRECL, so for a maximum 1,000 bytes of\n       data, specify 1004.\n\n       If the following were overtyped on SYS1.MACLIB\n\n          CLONE  'SYS2.MACLIB'\n\n       a new PDS named SYS2.MACLIB would be created and all the\n       SYS1.MACLIB members copied to it.\n\n       Entering\n\n          CLONE  +90  =X\n\n       on SYS1.MACLIB, a new PDS named SYS1.MACLIBX would be\n       created with 90 more directory blocks then the current\n       allocation of SYS1.MACLIB and all the SYS1.MACLIB members\n       copied to it.\n\n       Entering an equal sign on subsequent data set lines under\n       DS List would cause the same command to be executed\n       against them. This is useful if you want to create back up\n\n * ------------- End of Doc ---------------------------------- */\n\n   PARSE ARG PARMS\n   MSG = MSG(OFF)\n   PARMS = TRANSLATE(PARMS)\n\n   ZINPDSN = \"\"\n   ZNEWDSN = \"\"\n   OPTION  = \"\"\n   NUMOPT  = \"\"\n   NUMCHG  = \"\"\n   RELOPT  = \"\"\n   Q       = 0\n\n   IF WORD(PARMS,2) = \"\" | WORD(PARMS,1) = \"?\"\n      THEN SIGNAL DISPDOC\n\n   DO II = 1 TO 9\n      TOKEN = WORD(PARMS,II)\n      IF TOKEN = \"\" THEN LEAVE\n      IF TOKEN = \"EMPTY\" THEN OPTION = TOKEN\n      ELSE IF TOKEN = \"RELEASE\" THEN RELOPT = \"RELEASE\"\n      ELSE IF SUBSTR(TOKEN,1,1) = \"+\" | SUBSTR(TOKEN,1,1) = \"-\"\n         THEN DO\n            NUMOPT = \"CHG\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF DATATYPE(TOKEN,'W')\n         THEN DO\n            NUMOPT = \"NEW\"\n            NUMCHG = TOKEN\n         END\n      ELSE IF SUBSTR(TOKEN,1,1) = \"=\",\n            | SUBSTR(TOKEN,LENGTH(TOKEN),1) = \"=\"\n         THEN ZNEWDSN = TOKEN\n      ELSE IF SUBSTR(TOKEN,1,1) = \"Q\" & DATATYPE(SUBSTR(TOKEN,2),'W')\n         THEN Q = SUBSTR(TOKEN,2)\n      ELSE DO\n         IF ZNEWDSN = \"\" THEN ZNEWDSN = TOKEN\n                         ELSE ZINPDSN = TOKEN\n      END\n   END II\n\n   IF SUBSTR(ZNEWDSN,1,1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = SUBSTR(ZINPDSN,1,LENGTH(ZINPDSN)-1),\n         || SUBSTR(ZNEWDSN,2) || \"'\"\n      ELSE DO\n         NN = LENGTH(ZINPDSN) - 1\n         DO PP = 1 TO Q\n            DO II = NN TO 1 BY -1 WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II - 1\n         END PP\n         ZNEWDSN = SUBSTR(ZINPDSN,1,NN) || SUBSTR(ZNEWDSN,2) || \"'\"\n      END\n   END\n   ELSE IF SUBSTR(ZNEWDSN,LENGTH(ZNEWDSN),1) = \"=\" THEN DO\n      IF Q = 0 THEN ZNEWDSN = \"'\",\n         || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1) || SUBSTR(ZINPDSN,2)\n      ELSE DO\n         NN = 2\n         DO PP = 1 TO Q\n            DO II = NN TO LENGTH(ZINPDSN)-1,\n                  WHILE(SUBSTR(ZINPDSN,II,1) <> \".\")\n            END II\n            NN = II + 1\n         END PP\n         ZNEWDSN = \"'\" || SUBSTR(ZNEWDSN,1,LENGTH(ZNEWDSN)-1),\n            || SUBSTR(ZINPDSN,NN,LENGTH(ZINPDSN)-NN+1)\n      END\n   END\n\n   IF LENGTH(ZNEWDSN) > 46 THEN DO\n      SAY \"***> NEW DATA SET NAME TOO LONG (\"ZNEWDSN\")\"\n      EXIT(1)\n   END\n   IF SYSDSN(ZNEWDSN) = \"OK\" THEN DO\n      SAY \"***> NEW DATA SET ALREADY EXISTS\"\n      EXIT(1)\n   END\n\n   IF OPTION <> \"EMPTY\" THEN DO\n      ADDRESS TSO\n      \"FREE  DD(SORTIN SORTOUT SYSPRINT SYSIN SORTLIST)\"\n      LDSI = LISTDSI(ZINPDSN DIRECTORY)\n      \"ALLOC DD(SORTIN) DSN(\"ZINPDSN\") SHR\"\n      \"ALLOC DD(SYSPRINT) DUMMY\"\n\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            ADDRESS ISPEXEC 'DSINFO DATASET('ZINPDSN')'\n            IF ZDSNGEN > 0 THEN DO\n               MAXGEN = 'MAXGENS('STRIP(ZDSNGEN)')'\n               LIB    = 'LIBRARY,2'\n               END\n            ELSE DO\n                 LIB = 'LIBRARY'\n                 MAXGEN = ''\n                 END\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(\"LIB\") DD(SORTOUT) UNIT(SYSDA)\" MAXGEN\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               IF DIRCNT < SYSUDIRBLK THEN DO\n                  SAY \"***> NEW NUMBER OF DIRECTORY BLOCKS (\"DIRCNT\")\",\n                     \"MAY NOT\"\n                  SAY \"***> BE LESS THEN THE NUMBER CURRENTLY IN USE\",\n                     \"(\"SYSUDIRBLK\")\"\n                  EXIT(1)\n               END\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n         \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n              \" LRECL(80) BLKSIZE(800) RECFM(F B)\"\n         QUEUE \" COPY INDD=SORTIN,OUTDD=SORTOUT\"\n         \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n         \"CALL *(IEBCOPY)\"\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DD(SORTLIST) DUMMY\"\n         IF NUMOPT = \"\" THEN DO\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") DD(SORTOUT)\",\n               \"UNIT(SYSDA)\" RELOPT\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n            \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n                 \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n            QUEUE \" SORT FIELDS=COPY\"\n            \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n            \"CALL *(SORT)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> COPY OF DATA FAILED W/ RC =\" RC\n               SAY \"***> \" ZNEWDSN \" BUT EMPTY...\"\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            LDSI = LISTDSI(ZINPDSN)\n            IF NUMOPT = \"NEW\" THEN NEWLRECL = NUMCHG\n            ELSE NEWLRECL = SYSLRECL + NUMCHG\n            IF SYSRECFM = \"VB\"\n               THEN NEWBLKSIZE = SYSBLKSIZE\n               ELSE NEWBLKSIZE = NEWLRECL * (27998%NEWLRECL)\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") DD(SORTOUT)\",\n               \"UNIT(SYSDA)\" RELOPT,\n               \"LRECL(\"NEWLRECL\") BLKSIZE(\"NEWBLKSIZE\")\"\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n            \"ALLOC DD(SYSIN) NEW TRACKS SPACE(1) UNIT(SYSDA)\",\n                 \"LRECL(80) BLKSIZE(800) RECFM(F B)\"\n            QUEUE \" SORT FIELDS=COPY \"\n            IF NEWLRECL > SYSLRECL & INDEX(SYSRECFM,'F') <> 0 THEN DO\n               PAD = NEWLRECL - SYSLRECL\n               OUTREC_STR = \" OUTREC FIELDS=(1,\" || SYSLRECL,\n                  || \",\" || PAD || \"X)\"\n               QUEUE OUTREC_STR\n            END\n            \"EXECIO\" QUEUED() \"DISKW SYSIN (FINIS\"\n            \"CALL *(SORT)\"\n            IF RC <> 0 THEN DO\n               SAY \"***> COPY OF DATA FAILED W/ RC =\" RC\n               SAY \"***> \" ZNEWDSN \" BUT EMPTY...\"\n               EXIT(1)\n            END\n         END\n      END\n      \"FREE  DD(SORTIN SORTOUT SYSPRINT SYSIN SORTLIST)\"\n      \"ALLOC DD(SYSPRINT) DSN(*)\"\n      \"ALLOC DD(SYSIN) DSN(*)\"\n   END\n   ELSE DO\n      ADDRESS TSO\n      LDSI = LISTDSI(ZINPDSN DIRECTORY)\n      IF SYSDSORG = PO THEN DO\n         IF SYSADIRBLK = \"NO_LIM\" THEN DO\n            ADDRESS ISPEXEC 'DSINFO DATASET('ZINPDSN')'\n            IF ZDSNGEN > 0 THEN DO\n               MAXGEN = 'MAXGENS('STRIP(ZDSNGEN)')'\n               LIB    = 'LIBRARY,2'\n               END\n            ELSE DO\n                 LIB = 'LIBRARY'\n                 MAXGEN = ''\n                 END\n            \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n               \"DSNTYPE(\"LIB\") DD(SORTOUT) UNIT(SYSDA)\" MAXGEN\n            IF RC <> 0 THEN DO\n               SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n               SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n               EXIT(1)\n            END\n         END\n         ELSE DO\n            IF NUMOPT = \"\" THEN DO\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"SYSADIRBLK\") UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n            ELSE DO\n               IF NUMOPT = \"NEW\" THEN DIRCNT = NUMCHG\n               ELSE DIRCNT = SYSADIRBLK + NUMCHG\n               \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\")\" RELOPT,\n                  \"DIR(\"DIRCNT\") DD(SORTOUT) UNIT(SYSDA)\"\n               IF RC <> 0 THEN DO\n                  SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n                  SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n                  EXIT(1)\n               END\n            END\n         END\n      END\n      ELSE IF SYSDSORG = \"PS\" | SYSDSORG = \"PS-E\" THEN DO\n         \"ALLOC DSN(\"ZNEWDSN\") NEW LIKE(\"ZINPDSN\") UNIT(SYSDA)\"\n         IF RC <> 0 THEN DO\n            SAY \"***> ALLOCATION FAILED W/ RC =\" RC\n            SAY \"***> UNABLE TO CREATE\" ZNEWDSN\n            EXIT(1)\n         END\n      END\n   \"FREE  DSN(\"ZNEWDSN\")\"\n   END\n\n   IF OPTION = \"EMPTY\"\n      THEN SAY ZINPDSN \"CLONED TO\" ZNEWDSN \"WITHOUT COPYING DATA\"\n      ELSE SAY ZINPDSN \"COPIED TO\" ZNEWDSN\n   EXIT(0)\n\nDISPDOC:\n   ADDRESS TSO \"CLEAR\"\n   SAY \"                                                             \"\n   SAY \"  CLONE         MAKES A COPY OF A DATA SET UNDER ISPF 3.4    \"\n   SAY \"                SIMILAR TO THE ONE POINTED TO EITHER         \"\n   SAY \"                COPYING THE DATA OR NOT. SIMPLY TYPE 'CLONE' \"\n   SAY \"                FOLLOWED BY THE NEW NAME AND, OPTIONALLY,    \"\n   SAY \"                THE KEYWORD 'EMPTY' AND/OR DIRECTORY COUNT   \"\n   SAY \"                AND/OR THE 'RELEASE' KEYWORD. EXITS IF NEW   \"\n   SAY \"                DATA SET EXISTS (SEE CLONER).                \"\n   SAY \"                                                             \"\n   SAY \"  SYNTAX:  CLONE  NEW-DATASET-NAME                           \"\n   SAY \"                      <EMPTY>  <#>  <RELEASE>  <Q#>          \"\n   SAY\n   SAY \"             NEW-DATASET-NAME   IS THE NAME OF THE DATA SET  \"\n   SAY \"                TO BE CREATED. IT MAY BE QUALIFIED (WITH     \"\n   SAY \"                QUOTES) OR UNQUALIFIED (ASSUMES YOUR USER-   \"\n   SAY \"                ID AT THE FRONT). IT MAY ALSO BE OF THE FORM \"\n   SAY \"                =XXX WHERE XXX IS SUFFIXED TO THE ORIGINAL   \"\n   SAY \"                NAME OR OF THE FORM XXX= WHERE XXX IS        \"\n   SAY \"                PREFIXED TO THE ORIGINAL NAME. THE Q# OPTION \"\n   SAY \"                MAY BE USED TO REMOVE # LEVELS OF QUALIFIERS \"\n   SAY \"                AT THE BACK OR FRONT OF THE ORIGINAL NAME.   \"\n   SAY\n   SAY \"            <EMPTY>  IS AN OPTIONAL PARAMETER TO INDICATE    \"\n   SAY \"                NO DATA IS TO BE COPIED FROM THE ORIGINAL    \"\n   SAY \"                FILE.                                        \"\n   SAY\n   SAY \"            <#> IS AN OPTIONAL CHANGE TO THE NUMBER OF       \"\n   SAY \"                DIRECTORY BLOCKS IF THE DATA SET IS A PDS.   \"\n   SAY \"                A WHOLE NUMBER IS USED AS IS; PREFIXED BY A +\"\n   SAY \"                IS ADDED; BY A - IS SUBTRACTED. NEVER ALLOWS \"\n   SAY \"                BELOW USED BLOCKS. IF THE DATA SET IS        \"\n   SAY \"                SEQUENTIAL, THE NUMBER BECOMES THE LRECL; A +\"\n   SAY \"                PREFIX ADDS BYTES; A - PREFIX SUBTRACTS.     \"\n   SAY\n   SAY \"            <RELEASE> IS AN OPTION THAT WILL RELEASE ANY     \"\n   SAY \"                UNUSED SPACE IN THE RESULTANT FILE           \"\n   SAY\n   SAY \"            <Q#> IS AN OPTION TO REMOVE THAT MANY (#) LEVEL  \"\n   SAY \"                QUALIFIERS OF THE ORIGINAL DATA SET EITHER   \"\n   SAY \"                PREFIXING IT WITH THE XXX FROM THE XXX= INPUT\"\n   SAY \"                OR SUFFIXING IT WITH THE XXX FROM THE =XXX.  \"\n   SAY\n   EXIT(1)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/CBT.V500.FILE312.PDS/CLONE.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312/CBT.V500.FILE312.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}