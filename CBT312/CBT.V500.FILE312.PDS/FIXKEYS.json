{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SLBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20191230145846000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "SLBD.FIXKEYS.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SLBD.FIXKEYS.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 10017, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "190364", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x1e'", "DS1LSTAR": "b'\\x00\\x04\\x02'", "DS1TRBAL": "b'\\xaf\\xfa'"}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x100\\x00\\x04zmP'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x100\\x00\\x04zmP'", "b'X{l\\x10\\x00\\x00\\x05\\xb8\\x00\\x07\\x05\\xb8\\x00\\t\\x00\\x03'", "b'X{l\\x10\\x00\\x00\\x0f>\\x00\\t\\x0f?\\x00\\x0e\\x00\\x15'", "b'X{l\\x10\\x00\\x00\\r\\x87\\x00\\x00\\r\\x87\\x00\\x08\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$README": {"ttr": 275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00D\\x01\\x19\\x02O\\x01\\x19\\x02\\x9f\\t\\x13\\x00\\x14\\x00\\n\\x00\\x00\\xc6\\xc9\\xe7\\xd2\\xc5\\xe8\\xe2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-01-24T00:00:00", "modifydate": "2019-01-29T09:13:44", "lines": 20, "newlines": 10, "modlines": 0, "user": "FIXKEYS"}, "text": "This package will allow the user to change the ISPF Key defaults\nfor up to 8 PFKeys across ALL ISPF Profiles (except ISPSPROF which\nis reserved).\n\nSyntax:  TSO %FIXKEYS\n\nBoth the FIXKEYS and FIXKEYST exec's need to be in the users SYSPROC\nor SYSEXEC library.\n\nThe dialog will:\n\n1. Prompt the user for up to 8 PF Keys to change\n2. Make a backup of the users ISPF Profile data set\n3. Change the PF Keys for all Profiles found in the users\n   ISPF Profile data set\n4. In support of SDSF, which just likes to be different,\n   RETRIEVE will be changed to CRETRIEV and RFIND will be\n   changed to IFIND.\n\nCopyleft (c) 2019\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIXKEYS": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00Q\\x01\\x19\\x02_\\x01\\x196O\\x08U\\x02\\x83\\x02d\\x00\\x00\\xc6\\xc9\\xe7\\xd2\\xc5\\xe8\\xe2@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2019-01-25T00:00:00", "modifydate": "2019-12-30T08:55:51", "lines": 643, "newlines": 612, "modlines": 0, "user": "FIXKEYS"}, "text": "/* --------------------  rexx procedure  -------------------- */\n  ver = '1.6'\n/* Name:      FixKeys                                         |\n |                                                            |\n | Function:  Fix PF Keys for all ISPF Profiles               |\n |                                                            |\n | Syntax:    %fixkeys                                        |\n |                                                            |\n | Usage Notes: Only works for ISPF Profiles that are         |\n |              active in the users ISPF Profile              |\n |                                                            |\n |              Calls FixKeysT with the profile applid        |\n |              to perform the update. Passes the update      |\n |              info on the call.                             |\n |                                                            |\n | Dependencies: none                                         |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |            Bruce Koss                                      |\n |                                                            |\n | History:  (most recent on top)                             |\n |       1.6  12/30/19 - Small update to tutorial panel       |\n |       1.5  01/30/19 - Add profile name to report           |\n |       1.4  01/29/19 - Check for SDSF Profile and change    |\n |                       RFINE to IFIND                       |\n |       1.3  01/28/19 - Check for SDSF Profile and change    |\n |                       RETREIEVE to CRETRIEVE               |\n |       1.2  01/28/19 - Clean up backup dsname               |\n |       1.1  01/27/19 - Add Final Report of Status           |\n |       1.0  01/25/19 - Add status pop and tutorial          |\n |                     - Numerous other fixes                 |\n |       0.1  01/24/19 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n  Address ISPExec\n\n/* ------------------------------- *\n | Dynamically load the ISPF Panel |\n * ------------------------------- */\n  load_info = loadispf()\n\n/* --------------- *\n | Define Defaults |\n * --------------- */\n  parse value '' with null dc mc sc\n  rpt = 0\n  sep = '\\'\n\n/* ------------------------ *\n | Display the prompt panel |\n * ------------------------ */\n  do forever\n    ok = 0\n    'Display Panel(fixkey)'\n    IF (RC = 08) then call done\n    update = null\n    call test_update k1 kv1\n    call test_update k2 kv2\n    call test_update k3 kv3\n    call test_update k4 kv4\n    call test_update k5 kv5\n    call test_update k6 kv6\n    call test_update k7 kv7\n    call test_update k8 kv8\n    if update /= null then\n    leave\n  end\n\n/* -------------------------------------------------- *\n | Find the dsname of the active ISPF Profile Dataset |\n * -------------------------------------------------- */\n  call outtrap 'k.'\n  Address TSO ,\n    'listalc sta'\n  call outtrap 'off'\n  do i = 1 to k.0\n    if word(k.i,1) = 'ISPPROF' then leave\n  end\n  i = i - 1\n  profile = \"'\"word(k.i,1)\"'\"\n  drop k.\n\n/* ----------------------------------------------- *\n | Backup PROFILE dataset                          |\n * ----------------------------------------------- */\n  parse value time() with hh \":\" MM \":\" SS\n  hlqtime  = \"T\"hh\"\"mm\n  hlqdate  = \"D\"substr(date(\"S\"),3)\n  profbkp  = strip(profile,,\"'\")\n  profleng = length(profile)\n  profbkp = strip(translate(profile,' ',\"'.\"))\n  profbkp = \"'\"profbkp\".BK.\"hlqdate\".\"hlqtime\"'\"\n  profbkp = translate(profbkp,'.',' ')\n  x = listdsi(profile\" DIRECTORY SMSINFO\")\n  recfmlen = length(sysrecfm)\n  select\n    when (recfmlen = 2) then\n    recfm = substr(sysrecfm,1,1)\" \"substr(sysrecfm,2,1)\n    when (recfmlen = 3) then\n    recfm = substr(sysrecfm,1,1)\" \"substr(sysrecfm,2,1),\n      substr(sysrecfm,3,1)\n    otherwise\n    recfm = recfm\n  end\n\n  call add_report  \"FIXKEYS - ISPF Profile Update Utility - Version\" ver\n  call add_report ' '\n  call add_report  \"Updated Profile:\" profile\n  call add_report  \"Backup dataset: \" profbkp\n  call add_report ' '\n\n  if sysstorclass /= null then\n  sc = 'StorClas('sysstorclass')'\n  if sysdataclass /= null then\n  dc = 'DataClas('sysdataclass')'\n  if sysmgmtclass /= null then\n  mc = 'MgmtClas('sysmgmtclass')'\n  if datatype(sysadirblk) = \"NUM\" then\n  dir = \"DIR(\"sysadirblk\")\"\n  else do\n    \"dsinfo dataset(\"profile\")\"\n    dir = \"DSNTYPE(LIBRARY,\"ZDSDSNV\")\"\n    if (ZDSNGEN <> 0) then\n    dir = dir\" MAXGENS(\"ZDSNGEN\")\"\n  end\n  ADDRESS TSO \"ALLOC FI(FIXKEYS) DA(\"profbkp\")\",\n    \"NEW REUSE \"sysunits\" SPACE(\"sysprimary sysseconds\")\",\n    sc mc dc \"RECFM(\"recfm\") DSORG(\"SYSDSORG\") \"dir,\n    \"LRECL(\"syslrecl\") BLKSIZE(\"sysblksize\")\"\n  ADDRESS TSO \"FREE FI(FIXKEYS)\"\n\n  \"lminit dataid(indd1) dataset(\"profile\")\"\n  \"lminit dataid(outdd1) dataset(\"profbkp\")\"\n  \"lmcopy fromid(\"indd1\") todataid(\"outdd1\")\",\n    \"frommem(*) replace\"\n  \"lmfree dataid(\"indd1\")\"\n  \"lmfree dataid(\"outdd1\")\"\n\n/* ------------------------------------ *\n | Report Out the PF Keys being updated |\n * ------------------------------------ */\n  test = update\n  call add_report 'Changed PF Keys:'\n  call add_report '  ' left('Key',8) center('Command',50)\n  call add_report '  ' left('-',8,'-') center('-',50,'-')\n  do until test = null\n    parse value test with z1 z2 (sep) test\n    call add_report '  ' left('PF' z1,8) z2\n  end\n  call add_report ' '\n  call add_report 'Updated ISPF Profile Members:'\n\n/* ----------------------------------------------- *\n | Now get all of the active PROFILE *PROF members |\n * ----------------------------------------------- */\n  call outtrap 'k.'\n  Address TSO ,\n    'listd' profile 'mem'\n  call outtrap 'off'\n  do i = 7 to k.0\n    if right(word(k.i,1),4) /= 'PROF' then iterate\n    fixprof = word(k.i,1)\n    if fixprof = 'ISPSPROF' then iterate\n    msg1 = center(\"Updating ISPF profile member:\",44)\n    msg2 = center(fixprof,44)\n    call add_report '   ' fixprof\n    \"addpop column(12) row(8)\"\n    \"control display lock\"\n    \"display panel(status)\"\n    \"rempop\"\n    call Fix_Prof\n  end\n\n/* ----------------------------------------- *\n | Done with processing so free up and leave |\n * ----------------------------------------- */\nDone:\n  drc = rc\n  rc = dropispf(load_info)\n  if drc = 8 then exit 0\n  report.0 = rpt\n  fxk_dd = \"C\"random()\n  Address TSO\n  \"Allocate File(\"fxk_dd\") Reuse Unit(sysallda) Space(1 1)\" ,\n    \"tracks Dsorg(ps) Recfm(f b) Lrecl(80)\"\n  \"Execio * Diskw\" fxk_dd \"(Stem report. Finis)\"\n  Address ISPExec\n  \"LMinit Dataid(dataid) DDname(\"fxk_dd\")\"\n  \"Browse Dataid(\"dataid\")\"\n  \"LMfree Dataid(\"dataid\")\"\n  Address TSO\n  \"Free File(\"fxk_dd\")\"\n  Exit 0\n\nAdd_Report:\n  parse arg text\n  rpt = rpt + 1\n  report.rpt = text\n  return\n\n/* --------------- *\n | Test PFK Update |\n * --------------- */\nTest_Update:\n  arg v1 v2\n  if datatype(v1) /= 'NUM' then return null\n  if v2 = null then return null\n  update = update v1 v2 sep\n  return\n\n/* -------------------------- *\n | Fix up the profile PF Keys |\n * -------------------------- */\nFix_Prof:\n  parse value fixprof with appl'PROF' .\n  testlist = update\n  if fixprof = 'ISFPROF' then\n  do while testlist /= ''\n    parse value testlist with xx test (sep) testlist\n    if test = 'RETRIEVE' then\n        call add_report left(' ',5) ,\n             '>SDSF Profile Update - RETRIEVE replaced with CRETRIEV'\n    if test = 'RFIND' then\n        call add_report left(' ',5) ,\n             '>SDSF Profile Update - RFIND replaced with IFIND'\n     end\n  'select cmd(%fixkeyst' update') newappl('appl')'\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n\n>Start\n>Panel fixkey\n)ATTR DEFAULT(%+_)\n   %   TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n   +   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(GREEN)\n   !   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(BLUE)\n   _   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT) HILITE(USCORE)\n)BODY EXPAND(\\\\)\n+-\\-\\(%FixKeys+)-\\-\\\n%Command ===>_ZCMD\n+\n+ Enter the function keys to be updated (1 to 24) and the new value.\n+\n%   Key    Value\n!  PF_k1+ _kv1                                                              +\n!  PF_k2+ _kv2                                                              +\n!  PF_k3+ _kv3                                                              +\n!  PF_k4+ _kv4                                                              +\n!  PF_k5+ _kv5                                                              +\n!  PF_k6+ _kv6                                                              +\n!  PF_k7+ _kv7                                                              +\n!  PF_k8+ _kv8                                                              +\n+\n+ Press%PF3+to terminate,%ENTER+to process updates.\n+\n)INIT\n .Help = FixKeyT\n)PROC\n ver (&k1,range,1,24)\n if (&k1 NE &Z)\n    ver (&k1,range,1,24)\n if (&k2 NE &Z)\n    ver (&k2,range,1,24)\n if (&k3 NE &Z)\n    ver (&k3,range,1,24)\n if (&k4 NE &Z)\n    ver (&k4,range,1,24)\n if (&k5 NE &Z)\n    ver (&k5,range,1,24)\n if (&k6 NE &Z)\n    ver (&k6,range,1,24)\n if (&k7 NE &Z)\n    ver (&k7,range,1,24)\n if (&k8 NE &Z)\n    ver (&k8,range,1,24)\n)END\n>Panel fixkeyt\n)ATTR DEFAULT(%+_)\n   %   TYPE(TEXT)  INTENS(HIGH) SKIP(ON)\n   +   TYPE(TEXT)  INTENS(LOW)  SKIP(ON) COLOR(GREEN)\n   _   TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT) HILITE(USCORE)\n)BODY EXPAND(\\\\)\n%Tutorial+-\\-\\-(%FixKeys+)-\\-\\-%Tutorial\n%Command ===>_ZCMD\n+\n%FIXKEYS+will update from 1 to 8 Program Function Keys across ALL\n+ISPF Profiles that are defined in the users ISPF Profile data set.\n+\n+In the%Key+field enter the Function Key number from 1 to 24.\n+\n+In the%Value+field enter the new Command to be executed when\n+the Function Key is pressed.\n+\n+A backup of the ISPF profile dataset will be created prior to making\n+the updates.\n+\n%Notes:+1. Will not affect products that use KEYLISTs\n+       2. Does not affect profiles added after it is run\n+           - so it may need to be run again\n+       3. For the SDSF Profile change RETRIEVE to CRETRIEV\n+          and RFIND to IFIND\n+\n+Press%F3+to return to the application.\n+\n)PROC\n  &ZUP     = fixkeyt\n  &ZCONT   = fixkeyt\n)END\n>Panel status\n)ATTR DEFAULT(%+_)\n)BODY WINDOW(47,4)\n+\n% &MSG1\n% &MSG2\n+\n)INIT\n  &ZWINTTL = &Z\n)END\n>end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXKEYST": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\t\\x01\\x19\\x02O\\x01\\x19\\x02\\x9f\\t\\x11\\x00\\x97\\x00\\x8b\\x00\\x00\\xc6\\xc9\\xe7\\xd2\\xc5\\xe8\\xe2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2019-01-24T00:00:00", "modifydate": "2019-01-29T09:11:09", "lines": 151, "newlines": 139, "modlines": 0, "user": "FIXKEYS"}, "text": "/*%NOcomment ----------  rexx procedure  -------------------- *\n | Name:      FixKeysT                                        |\n |                                                            |\n | Function:  Called by FIXKEYS to update PF Key defaults     |\n |                                                            |\n | Syntax:    %fixkeyst update_list                           |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            01/29/19 - If ISFPROF and key is RFIND          |\n |                       change to IFIND                     |\n |            01/28/19 - If ISFPROF and key is RETRIEVE       |\n |                       change to CRETRIEV                   |\n |            01/24/19 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n  arg key_list\n  Address ISPExec\n  'vget (zapplid)'\n  sep = '\\'\n  do while key_list /= ''\n    parse value key_list with key value (sep) key_list\n    if zapplid = 'ISF' then do\n       if value = 'RETRIEVE' then do\n          value = 'CRETRIEV'\n          end\n       if value = 'RFIND' then do\n          value = 'IFIND'\n          end\n          end\n    Select\n      When key = 01 then do\n        zpf01 = value\n        key01def = value\n        'vput (zpf01 key01def) profile'\n      end\n      When key = 02 then do\n        zpf02 = value\n        key02def = value\n        'vput (zpf02 key02def) profile'\n      end\n      When key = 03 then do\n        zpf03 = value\n        key03def = value\n        'vput (zpf03 key03def) profile'\n      end\n      When key = 04 then do\n        zpf04 = value\n        key04def = value\n        'vput (zpf04 key04def) profile'\n      end\n      When key = 05 then do\n        zpf05 = value\n        key05def = value\n        'vput (zpf05 key05def) profile'\n      end\n      When key = 06 then do\n        zpf06 = value\n        key06def = value\n        'vput (zpf06 key06def) profile'\n      end\n      When key = 07 then do\n        zpf07 = value\n        key07def = value\n        'vput (zpf07 key07def) profile'\n      end\n      When key = 08 then do\n        zpf08 = value\n        key08def = value\n        'vput (zpf08 key08def) profile'\n      end\n      When key = 09 then do\n        zpf09 = value\n        key09def = value\n        'vput (zpf09 key09def) profile'\n      end\n      When key = 10 then do\n        zpf10 = value\n        key10def = value\n        'vput (zpf10 key10def) profile'\n      end\n      When key = 11 then do\n        zpf11 = value\n        key11def = value\n        'vput (zpf11 key11def) profile'\n      end\n      When key = 12 then do\n        zpf12 = value\n        key12def = value\n        'vput (zpf12 key12def) profile'\n      end\n      When key = 13 then do\n        zpf13 = value\n        key13def = value\n        'vput (zpf13 key13def) profile'\n      end\n      When key = 14 then do\n        zpf14 = value\n        key14def = value\n        'vput (zpf14 key14def) profile'\n      end\n      When key = 15 then do\n        zpf15 = value\n        key15def = value\n        'vput (zpf15 key15def) profile'\n      end\n      When key = 16 then do\n        zpf16 = value\n        key16def = value\n        'vput (zpf16 key16def) profile'\n      end\n      When key = 17 then do\n        zpf17 = value\n        key17def = value\n        'vput (zpf17 key17def) profile'\n      end\n      When key = 18 then do\n        zpf18 = value\n        key18def = value\n        'vput (zpf18 key18def) profile'\n      end\n      When key = 19 then do\n        zpf19 = value\n        key19def = value\n        'vput (zpf19 key19def) profile'\n      end\n      When key = 21 then do\n        zpf21 = value\n        key21def = value\n        'vput (zpf21 key21def) profile'\n      end\n      When key = 22 then do\n        zpf22 = value\n        key22def = value\n        'vput (zpf22 key22def) profile'\n      end\n      When key = 23 then do\n        zpf23 = value\n        key23def = value\n        'vput (zpf23 key23def) profile'\n      end\n      When key = 24 then do\n        zpf24 = value\n        key24def = value\n        'vput (zpf24 key24def) profile'\n      end\n      Otherwise nop\n    end\n  end\n  Exit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/CBT.V500.FILE312.PDS/FIXKEYS.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312/CBT.V500.FILE312.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}