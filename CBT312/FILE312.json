{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011723000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 9758476, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 27, "INMDSNAM": "CBT.V500.FILE312.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 9758476, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 9758476, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE312.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x98\\t'", "DS1TRBAL": "b'-\\xb0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x024\\x00\\n\\x02>\\x00\\x0c\\x00\\x99'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00S\\x01 4O\\x01 4O\\x12)\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-09T00:00:00", "modifydate": "2020-12-09T12:29:53", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  312\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE312\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    12000   PO\n\n   PDS117I 128 MEMBERS COUNTED; CUMULATIVE SIZE IS 92,098 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/09/20    12:29:53    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00#\\x00\\x99\\x18?\\x01\\x14\\x08/\\t\\x07\\x00\\x0f\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1999-07-02T00:00:00", "modifydate": "2014-03-23T09:07:23", "lines": 15, "newlines": 16, "modlines": 0, "user": "SYSLBD"}, "text": "To RECEIVE members of this dataset, some of which are in TSO TRANSMIT\n(or XMIT) format, do the following:  Under TSO, say:\n\n     RECEIVE INDS(this.dataset(member))\n\nand either press ENTER at the prompt, or supply DSN(  ) and/or\nVOL(  ) keywords, to control the output dataset name, and where it\nwill be placed.\n\n\nThese tools are provided by:\n  Lionel B. Dyck\n  email:   lbdyck@gmail.com\n  website: www.lbdsoftware.com\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE312": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00H\\x01 4O\\x01 4O\\x12)\\x03\\xbe\\x03\\xbe\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-09T00:00:00", "modifydate": "2020-12-09T12:29:48", "lines": 958, "newlines": 958, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 312 is from Lionel Dyck in Austin, Texas and contains     *   FILE 312\n//*           quite a few ISPF interface packages, and other        *   FILE 312\n//*           stuff.                                                *   FILE 312\n//*                                                                 *   FILE 312\n//*           The member list probably more accurately reflects     *   FILE 312\n//*           the contents of this file, than does the description  *   FILE 312\n//*           of some details, below.  This file is constantly      *   FILE 312\n//*           being revised.  For reference, please see Lionel's    *   FILE 312\n//*           web site at:   http://www.lbdsoftware.com             *   FILE 312\n//*                                                                 *   FILE 312\n//*           email:  lbdyck@gmail.com                              *   FILE 312\n//*                                                                 *   FILE 312\n//*    Lionel Dyck's large collection of utilities has now been     *   FILE 312\n//*    divided between Files 312, 313, 314, and 969.  All member    *   FILE 312\n//*    names beginning with A-R are on File 312.  Names beginning   *   FILE 312\n//*    with S-TS are on File 313.  Names from TX-Z are on File      *   FILE 312\n//*    314.  File 969 contains the PDSEGEN ISPF application to      *   FILE 312\n//*    exploit the capabilities of using PDSE Version 2 member      *   FILE 312\n//*    generations.                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*    These four files contain quite a few separate utility        *   FILE 312\n//*    packages which are unrelated to each other.  You can tell    *   FILE 312\n//*    which members of these files belong to the same utility      *   FILE 312\n//*    package, by the similarities in their member names.          *   FILE 312\n//*                                                                 *   FILE 312\n//*    Some utility packages will have several member names         *   FILE 312\n//*    associated with them.  But these should all be similar       *   FILE 312\n//*    to each other, letting you know that they belong to the      *   FILE 312\n//*    same utility package.  You can see this, by looking at       *   FILE 312\n//*    the member list shown below, so you can get the idea         *   FILE 312\n//*    about how this packaging arrangement works.                  *   FILE 312\n//*                                                                 *   FILE 312\n//*    Documentation files which are in WORD format, or PDF         *   FILE 312\n//*    format, have been included to make the use of the package    *   FILE 312\n//*    associated with the doc, easier.  Usually a doc file in      *   FILE 312\n//*    FB-80 EBCDIC text, has been included too.  To use the        *   FILE 312\n//*    WORD or PDF format documentation, you have to download the   *   FILE 312\n//*    member in BINARY to a PC, and look at the resulting file     *   FILE 312\n//*    on the PC, using Microsoft WORD, or Adobe ACROBAT reader,    *   FILE 312\n//*    respectively.                                                *   FILE 312\n//*                                                                 *   FILE 312\n//*    DSN=CBT500.FILE312   (fairly up to date for Version 500)     *   FILE 312\n//*                                                                 *   FILE 312\n//*       NAME       VER.MOD   LAST MODIFIED     SIZE   ID          *   FILE 312\n//*       $DOC        01.05   2014/03/23 09:07     15 SYSLBD        *   FILE 312\n//*       ALIGN       01.01   2019/12/31 06:41    216 ALIGN         *   FILE 312\n//*       ALLOCGDG    01.00   2003/02/05 14:04    138 SYSLBD        *   FILE 312\n//*       BACKDIR     01.00   2017/07/11 14:14    359 LBD           *   FILE 312\n//*       BISPFJCL    01.01   2016/11/16 10:18    526 SYSLBD        *   FILE 312\n//*       BODY        01.00   2020/02/29 09:16    139 XMIT          *   FILE 312\n//*       CAVXTR$     01.21   2003/06/02 08:27     77 SYSLBD        *   FILE 312\n//*       CAVXTR$$    01.26   2010/05/21 01:24     92 SYSLBD        *   FILE 312\n//*       CAVXTR#     01.26   2010/05/21 01:26   2080 PDF           *   FILE 312\n//*       CAVXTR@     01.26   2010/05/21 01:26   2093 MSWORD        *   FILE 312\n//*       CAVXTRT     01.27   2019/01/23 06:12   2725 CAV           *   FILE 312\n//*       CHKIKJ      01.07   2017/06/15 12:28    977 LBD           *   FILE 312\n//*       CHKLPALK    01.00   2016/11/23 06:51     90 SYSLBD        *   FILE 312\n//*       CHKPDSE     01.01   2016/11/09 07:37     67 FILE312       *   FILE 312\n//*       CLONE       01.00   2016/11/08 09:56    427 SYSLBD        *   FILE 312\n//*       CMDS        01.00   2000/02/16 16:27    588 SYSLBD        *   FILE 312\n//*       CMDSRPT     01.06   2016/03/17 07:47     74 SYSLBD        *   FILE 312\n//*       CMDSRPTO    01.02   2016/03/02 14:50     43 SYSLBD        *   FILE 312\n//*       CMT         03.05   2016/11/09 07:39   1287 FILE312       *   FILE 312\n//*       COMPVTC$    01.01   2001/02/09 12:23     21 WSBG          *   FILE 312\n//*       COMPVTOC    01.00   2001/02/09 12:23     58 SYSLBD        *   FILE 312\n//*       CONCATIT    01.00   2020/08/23 09:08    554 SLBD          *   FILE 312\n//*       CONS        01.04   2016/03/09 13:10    157 SYSLBD        *   FILE 312\n//*       COPYFB      01.02   2016/04/03 15:00     70 SYSLBD        *   FILE 312\n//*       CSVEDIT     01.11   2008/04/15 11:10    542 SYSLBD        *   FILE 312\n//*       CSVEDIT#    01.11   2008/04/15 11:12   2541 PDF           *   FILE 312\n//*       CSVEDIT@    01.11   2008/04/15 11:12   1434 MSWORD        *   FILE 312\n//*       CUTPASTE    01.00   1999/07/06 18:40   1326 SYSLBD        *   FILE 312\n//*       DDLIST      01.00   2003/09/30 09:33   1607 SYSLBD        *   FILE 312\n//*       DDLIST$     01.01   2003/09/29 07:29      6 SYSLBD        *   FILE 312\n//*       DOALL       01.01   2016/11/09 07:44     56 FILE312       *   FILE 312\n//*       DROPISPF    01.00   2018/12/06 07:18     28 LOADISP       *   FILE 312\n//*       DSLIST      01.00   2000/02/15 21:40    106 SYSLBD        *   FILE 312\n//*       DUMPMGMT    01.00   2001/09/25 16:49   1369 SYSLBD        *   FILE 312\n//*       EDITMAC     01.01   2020/07/30 06:28    157 EDITMAC       *   FILE 312\n//*       EDSL        01.44   2020/12/09 08:02   2749 SLBD          *   FILE 312\n//*       EKKO        01.00   2016/11/05 13:57    413 CBTUSER       *   FILE 312\n//*       EKKO$       01.10   2016/11/06 20:21     27 SBGOLOB       *   FILE 312\n//*       EKKOH       01.00   2016/12/02 06:14     78 SBGOLOB       *   FILE 312\n//*       EMAC        01.07   2017/05/31 09:42   1182 LBD           *   FILE 312\n//*       EXTISPF     01.00   2018/05/18 13:56    227 EXTISPF       *   FILE 312\n//*       FASTPATH    01.06   2017/08/29 10:53   1269 LBD           *   FILE 312\n//*       FINDDDM     01.02   2013/10/28 11:21     93 MVSLBD1       *   FILE 312\n//*       FINDDSN     01.04   2019/05/09 08:47     94 SLBD          *   FILE 312\n//*       FIXBOOKP    01.00   2000/05/05 12:18    138 WSBG          *   FILE 312\n//*       FIXKEYS     01.09   2019/12/30 09:02    834 FIXKEYS       *   FILE 312\n//*       FIXKEYS$    01.02   2019/01/29 09:15     20 FIXKEYS       *   FILE 312\n//*       FIXNL       01.01   2016/11/16 10:23     49 SYSLBD        *   FILE 312\n//*       FTPB        02.31   2019/08/22 08:14   5615 FTPB          *   FILE 312\n//*       FTPB$CHG    02.27   2019/08/22 08:14    182 FTPB          *   FILE 312\n//*       FTPB#       02.24   2019/07/02 11:23   4146 PDF           *   FILE 312\n//*       FTPB@       02.24   2019/07/02 11:23    692 MSWORD        *   FILE 312\n//*       FTPFROMZ    01.00   2004/05/23 08:07   1131 SYSLBD        *   FILE 312\n//*       FTPFROZC    01.00   2004/05/23 08:06     22 SYSLBD        *   FILE 312\n//*       GENSUB      01.00   2002/02/19 10:39    188 SYSLBD        *   FILE 312\n//*       GET         01.00   2000/02/16 16:49     88 SYSLBD        *   FILE 312\n//*       HIDELINE    01.00   2016/04/04 11:55     46 SYSLBD        *   FILE 312\n//*       IDLIST      01.00   2016/11/08 10:35     62 SYSLBD        *   FILE 312\n//*       IEBPDSE     01.12   2017/11/01 06:07    591 LBD           *   FILE 312\n//*       IFTHENEL    01.00   2017/04/24 09:07     61 LBDYCK        *   FILE 312\n//*       INEWS       01.09   2017/02/15 13:54   2691 SYSLBD        *   FILE 312\n//*       IPLTCHK     01.00   2018/09/15 10:30    109 IPLTCHK       *   FILE 312\n//*       IPLTCHK$    01.02   2018/09/15 11:59     40 IPLTCHK       *   FILE 312\n//*       ISPFCMDS    01.01   2003/05/23 11:13    388 SYSLBD        *   FILE 312\n//*       ISPFPRO$    01.00   2000/02/28 20:46    101 SYSLBD        *   FILE 312\n//*       ISPFPROD    01.00   2000/08/21 17:40    429 SYSLBD        *   FILE 312\n//*       LDAPMAI$    01.00   2000/11/22 10:54      6 WSBG          *   FILE 312\n//*       LDAPMAIL    01.01   2003/08/27 10:31    344 SYSLBD        *   FILE 312\n//*       LDAPMCHG    01.01   2003/08/26 14:45      6 SYSLBD        *   FILE 312\n//*       LOADISPF    01.05   2019/01/09 06:55    324 ISPF          *   FILE 312\n//*       LOG         01.00   2016/11/08 01:09    304 SYSLBD        *   FILE 312\n//*       LOGARCH     01.01   2016/11/16 10:28    183 SYSLBD        *   FILE 312\n//*       LOGIT       00.05   2004/04/21 08:00    458 SYSLBD        *   FILE 312\n//*       LOGIT$      00.05   2004/04/05 11:18     84 SYSLBD        *   FILE 312\n//*       LOGITCHG    00.05   2004/04/12 07:04     22 SYSLBD        *   FILE 312\n//*       LOWER       01.01   2016/12/21 09:21     15 SYSLBD        *   FILE 312\n//*       LPREDIT     01.01   2014/03/20 22:46     26 LBDYCK        *   FILE 312\n//*       LPRPRINT    01.03   2018/02/14 07:48   1341 PRINT         *   FILE 312\n//*       LPRPROLD    01.00   2014/03/21 10:56    421 LBDYCK        *   FILE 312\n//*       LSTPRC      01.53   2008/11/01 22:12    817 SBGOLOB       *   FILE 312\n//*       LSTPRC$     01.02   2018/02/16 14:32     19 SBGOLOB       *   FILE 312\n//*       LSTPRCO     01.02   2002/08/19 11:04    374 SBGOLOB       *   FILE 312\n//*       LSTPROC     01.52   2008/10/16 08:14    817 SYSLBD        *   FILE 312\n//*       LSTPROC$    01.03   2016/04/19 14:16     10 SBGOLOB       *   FILE 312\n//*       LSTPROC#    01.01   2016/11/16 10:30     24 LSTPROC       *   FILE 312\n//*       LSTPROC@    01.00   2000/10/25 10:36     29 WSBG          *   FILE 312\n//*       LSTPROCO    01.01   2002/08/19 10:56    374 SYSLBD        *   FILE 312\n//*       LSTPROC3    03.04   2018/09/27 14:24    812 FORJES3       *   FILE 312\n//*       MGEN        01.01   2016/11/16 10:31     24 SYSLBD        *   FILE 312\n//*       OMVSCMD     01.02   2016/11/16 10:31    430 SYSLBD        *   FILE 312\n//*       OMVSCOPY    02.18   2018/08/10 06:51   2595 OMVS          *   FILE 312\n//*       OMVSLOG     01.02   2016/11/16 10:34    399 SYSLBD        *   FILE 312\n//*       OMVSMAN     01.06   2018/02/28 06:16   1059 LBD           *   FILE 312\n//*       OMVSPAX     01.02   2020/09/17 06:57   1185 PAX           *   FILE 312\n//*       OMVSSEL     01.04   2018/08/16 07:37    869 OMVS          *   FILE 312\n//*       ONCALL      01.00   2003/12/11 08:04    625 SYSLBD        *   FILE 312\n//*       ONCALL#     01.00   2003/12/02 18:23     11 SYSLBD        *   FILE 312\n//*       ONLY        01.07   2019/12/24 04:10    551 ONLY          *   FILE 312\n//*       PACK        01.00   2016/04/17 18:21    660 TRSMAIN       *   FILE 312\n//*       PDS2SEQ     01.02   2016/07/03 10:19    154 WSYNGUD       *   FILE 312\n//*       PDS2SEQ$    01.01   2016/11/07 23:29     21 SYSLBD        *   FILE 312\n//*       PLPISPF     01.51   2020/02/18 10:16   4364 XMIT          *   FILE 312\n//*       PLPISPF$    01.49   2020/02/18 10:17    217 PLP           *   FILE 312\n//*       PLPISPF#    01.29   2016/04/03 18:42   3369 PDF           *   FILE 312\n//*       PLPISPF@    01.29   2016/04/03 18:42   1172 MSWORD        *   FILE 312\n//*       PNS         01.00   2016/12/08 10:51     93 SYSLBD        *   FILE 312\n//*       PRMCK       01.26   2020/05/14 13:10   2754 PRMCK         *   FILE 312\n//*       PRMCK$      01.09   2018/09/13 05:40     50 PRMCK         *   FILE 312\n//*       PSPRINT     01.02   2015/04/30 16:13    567 LBDYCK        *   FILE 312\n//*       PSPRINTO    01.00   2014/03/21 11:02    553 LBDYCK        *   FILE 312\n//*       QTAB        01.06   2020/12/07 12:19    711 SLBD          *   FILE 312\n//*       RANDSTR     01.02   2018/02/27 06:16    151 LBD           *   FILE 312\n//*       REXXDOC     01.00   2001/01/05 11:31    265 SYSLBD        *   FILE 312\n//*       REXXER      01.10   2020/10/28 05:15    408 SLBD          *   FILE 312\n//*       REXXFORM    01.04   2017/04/26 09:52    515 LBD           *   FILE 312\n//*       REXXTRY     01.00   2000/11/08 18:46    187 REXXTRY       *   FILE 312\n//*       REXXTRY$    01.00   2000/11/08 18:46     78 REXXTRY       *   FILE 312\n//*       REXXTRY#    01.00   2000/11/08 18:56      9 WSBG          *   FILE 312\n//*       REXXTRY@    01.00   2000/11/08 18:46     35 REXXTRY       *   FILE 312\n//*       REXXTRYA    01.00   2000/12/26 17:20     77 REXXTRY       *   FILE 312\n//*       REXXWAIT    01.00   2000/02/16 16:59    207 SBGOLOB       *   FILE 312\n//*       RUNC        06.01   2020/07/30 06:27   8567 RUNC          *   FILE 312\n//*       RUNCPP      01.00   2016/11/06 21:42   3159 POWERPT       *   FILE 312\n//*                                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*       ** Note: WORD members may require replying YES to         *   FILE 312\n//*                Microsoft Word document recovery to open.        *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member $DOC - basic information                                *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member ALIGN - added 12/31/19                                  *   FILE 312\n//*                                                                 *   FILE 312\n//*         ISPF Edit Macro to Align the text on the                *   FILE 312\n//*         specified line or lines.                                *   FILE 312\n//*                                                                 *   FILE 312\n//*          Options:                                               *   FILE 312\n//*          ? display help                                         *   FILE 312\n//*          C ll - strip and center                                *   FILE 312\n//*          F ll - flow text to line length(ll)                    *   FILE 312\n//*          L - strip and left justify                             *   FILE 312\n//*          R - strip and right justify                            *   FILE 312\n//*          V - strip and reverse text                             *   FILE 312\n//*                                                                 *   FILE 312\n//*          Optional for C is ll for line length                   *   FILE 312\n//*          e.g. ALIGN C 65                                        *   FILE 312\n//*               To align center for a width of 65                 *   FILE 312\n//*                                                                 *   FILE 312\n//*          Select row/rows using C/CC                             *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member CONCATIT - added 8/23/2020                              *   FILE 312\n//*                                                                 *   FILE 312\n//*      ALLOCADD and DEALLOC are a combination of REXX exec's      *   FILE 312\n//*      that provide the ability to add a dataset(s), or remove    *   FILE 312\n//*      a dataset from an existing DD allocation.                  *   FILE 312\n//*                                                                 *   FILE 312\n//*      CONCATIT combines ALLOCADD and DEALLOC with a List option  *   FILE 312\n//*      to provide a single exec instead of multiple.              *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member BACKDIR - added 07/11/17                                *   FILE 312\n//*                                                                 *   FILE 312\n//*     OMVS utility written in rexx to backup complete directories *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member BODY    - added 02/29/20                                *   FILE 312\n//*                                                                 *   FILE 312\n//*     ISPF Edit macro to report on the size of the BODY section   *   FILE 312\n//*     of a panel. Also recommends window size and addpop parms.   *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member CAVXTRT                                                 *   FILE 312\n//*         - Updated 1/23/19 for CAView 14.x                       *   FILE 312\n//*                                                                 *   FILE 312\n//*     This dialog is intended as a more user friendly interface   *   FILE 312\n//*     to the reports. The options available with this dialog      *   FILE 312\n//*     are:                                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*             - Broswe a report (using ISPF Browse)               *   FILE 312\n//*             - View a report (using ISPF View)                   *   FILE 312\n//*             - Copy a report to a dataset                        *   FILE 312\n//*             - Mail a report (using XMITIP)                      *   FILE 312\n//*             - Print a report                                    *   FILE 312\n//*             - Transfer a report to a workstation                *   FILE 312\n//*             - Load a report from CA-View tape to CA-View disk   *   FILE 312\n//*                                                                 *   FILE 312\n//*     This code has been tested on OS/390 2.10 and z/OS 1.9       *   FILE 312\n//*     with CA-View and CA-View 11.0. It is slightly (does a       *   FILE 312\n//*     dynamic lookup) dependent upon the report format            *   FILE 312\n//*     generated by SARBCH with the /LIST statement If this        *   FILE 312\n//*     report format changes then the code which parses the        *   FILE 312\n//*     report will have to be changed.                             *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member CHKIKJ (update 06/15/2017)                              *   FILE 312\n//*                                                                 *   FILE 312\n//*     CHKIKJ is a quick/dirty ispf dialog to compare the ibm      *   FILE 312\n//*     samplib version of ikjtso00 to what is actually running     *   FILE 312\n//*     on the active lpar.                                         *   FILE 312\n//*                                                                 *   FILE 312\n//*     TSO Transmit format member (so receive it).                 *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member CHKLPALK                                                *   FILE 312\n//*                                                                 *   FILE 312\n//*     REXX exec to check all LPALIST and LINKLIST datasets for    *   FILE 312\n//*     extents and report on same.                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member CMDS                                                    *   FILE 312\n//*                                                                 *   FILE 312\n//*     This data set contains an ISPF Dialog that simplifies the   *   FILE 312\n//*     processing of the ISPF command tables.                      *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member CSVEDIT                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*     CSVEDIT - an ISPF Edit Macro designed to convert the        *   FILE 312\n//*     current EDIT data set into a comma separated value data     *   FILE 312\n//*     set which can then be imported into a spreadsheet or        *   FILE 312\n//*     database.                                                   *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member CUTPASTE - This member is in TSO XMIT format.           *   FILE 312\n//*                                                                 *   FILE 312\n//*     This member contains 2 REXX execs, CUT and PASTE,           *   FILE 312\n//*     with ISPF panels that go together with them. **Ancient**    *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member DROPISPF (added 12/06/2018)                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     Companion to LOADISPF (thanks to John Kalinich)             *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member EDITMAC (added 07/30/2020)                              *   FILE 312\n//*                                                                 *   FILE 312\n//*        Execute an inline ISPF Edit macro                        *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member EDSL (updated 12/09/2020)                               *   FILE 312\n//*                                                                 *   FILE 312\n//*        ISPF Enhanced Data Set List. Works with Personal         *   FILE 312\n//*        Data Set Lists (DSList, ISPF 3.4) and more.              *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member EMAC (update 5/31/17)                                   *   FILE 312\n//*                                                                 *   FILE 312\n//*        ISPF Edit Macro (command) to display a selection         *   FILE 312\n//*        list of edit macros to the user from which the user      *   FILE 312\n//*        can select to execute the command or display any help.   *   FILE 312\n//*        Cursor placement and/or row selection(s) supported.      *   FILE 312\n//*                                                                 *   FILE 312\n//*        An excellent example of a scrollable data entry field    *   FILE 312\n//*        on the popup for macro parms (thanks John K.).           *   FILE 312\n//*                                                                 *   FILE 312\n//*        The tutorial panel and parm prompt popup panels show     *   FILE 312\n//*        the PF Keys that are defined for Left/Right/ZEXPand.     *   FILE 312\n//*                                                                 *   FILE 312\n//*        Only works under ISPF Edit/View and will display its     *   FILE 312\n//*        tutorial if called otherwise.                            *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member EXTISPF  - added 05/18/2018                             *   FILE 312\n//*                                                                 *   FILE 312\n//*        Can be used to extract the embedded ISPF elements        *   FILE 312\n//*        from the exec's where I use the LOADISPF process.        *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member FASTPATH - updated 8/29/2017                            *   FILE 312\n//*        - new packaging and enhancements                         *   FILE 312\n//*                                                                 *   FILE 312\n//*        Display a selection list of all Selectable               *   FILE 312\n//*        commands in the ISPCMDS ISPF Command Table               *   FILE 312\n//*        and in the System and User command tables                *   FILE 312\n//*        along with the commands in the current application       *   FILE 312\n//*        command table.  This command will:                       *   FILE 312\n//*                                                                 *   FILE 312\n//*        1.  Provide the user with information on                 *   FILE 312\n//*            fast path commands available.                        *   FILE 312\n//*        2.  Simplify access to fast path commands.               *   FILE 312\n//*        3.  Provide a pseudo-menu to ISPF command                *   FILE 312\n//*            functions.                                           *   FILE 312\n//*        4.  If a tutorial panel exists for the command           *   FILE 312\n//*            of the format $ followed by the first 7              *   FILE 312\n//*            characters of the command name, it will be           *   FILE 312\n//*            displayed if the user selects the command            *   FILE 312\n//*            with 'H' or via PF1(Help) on the pop-up              *   FILE 312\n//*            menu if the command has options.                     *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member FINDDDM                                                 *   FILE 312\n//*         - added 5/9/19                                          *   FILE 312\n//*                                                                 *   FILE 312\n//*   Function: Find specified member in the specified DDname       *   FILE 312\n//*             concatenation.                                      *   FILE 312\n//*                                                                 *   FILE 312\n//*   Usage:    called from a rexx or clist                         *   FILE 312\n//*                                                                 *   FILE 312\n//*             library = findddm()                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*             library will contain a count of dsnames found for   *   FILE 312\n//*             the dd followed by the dsnames                      *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member FINDDSN                                                 *   FILE 312\n//*         - added 5/9/19                                          *   FILE 312\n//*                                                                 *   FILE 312\n//* Function: Find the datasets allocted to a specified ddname      *   FILE 312\n//*                                                                 *   FILE 312\n//* Usage:    called from a rexx or clist                           *   FILE 312\n//*                                                                 *   FILE 312\n//*           library = finddsn(ddname)                             *   FILE 312\n//*                                                                 *   FILE 312\n//*           library will contain a count of dsnames found for     *   FILE 312\n//*           the dd followed by the dsnames                        *   FILE 312\n//*                                                                 *   FILE 312\n//*           For example:                                          *   FILE 312\n//*                                                                 *   FILE 312\n//*           xx=finddsn(ispmlib);say xx                            *   FILE 312\n//*            2 ISP.SISPMENU SYS1.PROD.ISPMENU                     *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member FIXKEYS - This member is in TSO XMIT format.            *   FILE 312\n//*                   Updated 12/30/19                              *   FILE 312\n//*                                                                 *   FILE 312\n//*     This is an ISPF command that makes it easy to change PF     *   FILE 312\n//*     Key defaults for ALL current ISPF profiles in the users     *   FILE 312\n//*     ISPF Profile data set. The current Profile data set         *   FILE 312\n//*     is backed up before processing.                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     - supports changing up to 8 PF Keys at once                 *   FILE 312\n//*     - does not affects dialogs with KEYLISTs                    *   FILE 312\n//*     - only changes the keys for profiles in the user            *   FILE 312\n//*       profile data set and thus may need to be run              *   FILE 312\n//*       when new applications (and thus new profiles)             *   FILE 312\n//*       are added.                                                *   FILE 312\n//*     - when changing the SDSF profile change RETREIVE            *   FILE 312\n//*       to CRETRIEV and RFIND to IFIND                            *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member FTPB   - This member is in TSO XMIT format.             *   FILE 312\n//*                  updated 8/22/19 with personal NETRC support    *   FILE 312\n//*                                                                 *   FILE 312\n//*        FTPB - The File Transfer Protocol Batch ISPF Dialog      *   FILE 312\n//*                                                                 *   FILE 312\n//*     This ISPF dialog provides a simple to use ISPF interface    *   FILE 312\n//*     for using the TCP/IP FTP function to transfer data sets     *   FILE 312\n//*     from the current MVS host system to other host systems      *   FILE 312\n//*     that support a TCP/IP FTP Server (e.g.  MVS, VM, OS/2,      *   FILE 312\n//*     most Unix, ...).                                            *   FILE 312\n//*                                                                 *   FILE 312\n//*     The dialog presents the user with a simple ISPF panel       *   FILE 312\n//*     from which to specify the source (original) data set,       *   FILE 312\n//*     the target host, optionally the name of the target data     *   FILE 312\n//*     set if it is different from the source, and signon          *   FILE 312\n//*     information (userid and password).  Once this               *   FILE 312\n//*     information is complete the dialog generates the            *   FILE 312\n//*     necessary JCL and FTP statements to allow the user to       *   FILE 312\n//*     execute the FTP in the foreground (execpt for load          *   FILE 312\n//*     library transfers) or to submit the JCL for a batch         *   FILE 312\n//*     execution of FTP.  Prior to submission the user is          *   FILE 312\n//*     allowed to review and change (edit) the generated JCL       *   FILE 312\n//*     and FTP control statements if they desire.                  *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member IEBPDSE - updated 11/01/17 V1.3                         *   FILE 312\n//*                                                                 *   FILE 312\n//*     A simple ISPF dialog to run IBM's IEBPDSE against your      *   FILE 312\n//*     PDSE datasets.                                              *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member IFTHENEL - ISPF Edit macro                              *   FILE 312\n//*                                                                 *   FILE 312\n//*     Very simple edit macro to display all if/then/else          *   FILE 312\n//*     do/select/when/otherwise/end statements while hiding        *   FILE 312\n//*     all others.                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member INEWS - This member is in IEBUPDTE SYSIN format.        *   FILE 312\n//*                                                                 *   FILE 312\n//*     This ISPF application is designed to simplify the task      *   FILE 312\n//*     of informing users about system changes, updates,           *   FILE 312\n//*     enhancements, etc. each time they logon to TSO and enter    *   FILE 312\n//*     ISPF. This is accomplished by a simple modification to      *   FILE 312\n//*     the first ISPF menu that the user sees (ISR@PRIM if         *   FILE 312\n//*     entry is via command ISPF or ISP@MSTR if entry is via       *   FILE 312\n//*     ISPSTART) as documented below.                              *   FILE 312\n//*                                                                 *   FILE 312\n//*     INEWS is entered by executing the Rexx procedure INEWS      *   FILE 312\n//*     and providing one or more of the valid parameters:          *   FILE 312\n//*                                                                 *   FILE 312\n//*     Syntax:   INEWS parameters                                  *   FILE 312\n//*                                                                 *   FILE 312\n//*     Required Parameters:                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*         NEWS      Defines that INEWS will use the NEWS set      *   FILE 312\n//*                   of tables, panels, and skeletons.             *   FILE 312\n//*         'other'   Must be defined by the installation as        *   FILE 312\n//*                   alternative to NEWS.                          *   FILE 312\n//*                                                                 *   FILE 312\n//*         ***  one of the above is required                       *   FILE 312\n//*                                                                 *   FILE 312\n//*     Optional Parameters:                                        *   FILE 312\n//*         NEW       Display the news ISPF table only if new       *   FILE 312\n//*                   or unread items are in the table for the      *   FILE 312\n//*                   user                                          *   FILE 312\n//*         DEBUG     Used to turn on REXX tracing for              *   FILE 312\n//*                   debugging purposes                            *   FILE 312\n//*         ADMIN     Enable the administration application         *   FILE 312\n//*         TEST      Uses a test news table for testing            *   FILE 312\n//*                   purposes.                                     *   FILE 312\n//*         FORCE     If the table is locked by ADMIN and the       *   FILE 312\n//*                   lock is obsolete (for some reason that        *   FILE 312\n//*                   left the member LOCK in the news data         *   FILE 312\n//*                   set) this option will override the lock       *   FILE 312\n//*                   for administration purposes.                  *   FILE 312\n//*                                                                 *   FILE 312\n//*     See the rexx procedure for more information.                *   FILE 312\n//*                                                                 *   FILE 312\n//*     Updates to ISPF Panels ISR@PRIM and/or ISP@MSTR to          *   FILE 312\n//*     cause this application to be invoked when the user          *   FILE 312\n//*     enters ISPF.                                                *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member IPLTCHK (added 09/14/2018)                              *   FILE 312\n//*                                                                 *   FILE 312\n//*        -------------------------------------------------------  *   FILE 312\n//*        This REXX helps solve the problem of which DASD volumes  *   FILE 312\n//*        connected to your system, contain IPL text, and what     *   FILE 312\n//*        IPL text do they contain?                                *   FILE 312\n//*        -------------------------------------------------------  *   FILE 312\n//*        You don't have to dump Track 0 for ALL of your volumes,  *   FILE 312\n//*        but you can FILTER the volser's for strings with volume  *   FILE 312\n//*        names that you want to look at.  See syntax below.       *   FILE 312\n//*        -------------------------------------------------------  *   FILE 312\n//*                                                                 *   FILE 312\n//*        Function:  Generate ADRDSSU Step and control cards to    *   FILE 312\n//*                   print the first track of the selected disk    *   FILE 312\n//*                   volumes.                                      *   FILE 312\n//*                                                                 *   FILE 312\n//*                   The main purpose is to find the disk          *   FILE 312\n//*                   volumes that have IPL Text installed on       *   FILE 312\n//*                   them and help to identify which type of IPL   *   FILE 312\n//*                   Text using the trusted, real-time,            *   FILE 312\n//*                   reliable, always available, and free          *   FILE 312\n//*                   utility IEB-EYE-BALL to review.               *   FILE 312\n//*                                                                 *   FILE 312\n//*        Syntax:    %ipltchk filter(s)                            *   FILE 312\n//*                                                                 *   FILE 312\n//*                   filters are any strings that must be found    *   FILE 312\n//*                   within the volser to be used.                 *   FILE 312\n//*                                                                 *   FILE 312\n//*        Usage:  Execute with, or without a filter, to generate   *   FILE 312\n//*                the ADRDSSU JCL and control statements to        *   FILE 312\n//*                print track 0 for the requested volumes. At      *   FILE 312\n//*                the end of use the user is placed into ISPF      *   FILE 312\n//*                Edit on the results and may then insert a JOB    *   FILE 312\n//*                card, tailor however they wish, and submit it.   *   FILE 312\n//*                Then review the OUTPUT DD Sysout for the         *   FILE 312\n//*                information.                                     *   FILE 312\n//*                                                                 *   FILE 312\n//*        Dependencies:  DUDASD is required from CBT Tape File 612 *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member ISPFCMDS                                                *   FILE 312\n//*                                                                 *   FILE 312\n//*     ISPFCMDS is a utility ISPF command that eases the task      *   FILE 312\n//*     of adding installation or user commands to an active        *   FILE 312\n//*     ISPF command table. This can eliminaate the requirement     *   FILE 312\n//*     to customize the IBM provided ISPF command table or to      *   FILE 312\n//*     create elaborate Site or User ISPF command table.           *   FILE 312\n//*                                                                 *   FILE 312\n//*   Syntax                                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*     The syntax for calling ISPFCMDS is:                         *   FILE 312\n//*                                                                 *   FILE 312\n//*        %ISPFCMDS table verb truncation action                   *   FILE 312\n//*                                                                 *   FILE 312\n//*     Where:                                                      *   FILE 312\n//*                                                                 *   FILE 312\n//*     table is USER to add the command to the User Command table  *   FILE 312\n//*              SITE to add the command to the Site table          *   FILE 312\n//*              ISPF to add the command to the ISPCMDS table       *   FILE 312\n//*                    note that this option is not recommended     *   FILE 312\n//*              * to add the command to one of the following       *   FILE 312\n//*                        in this order:                           *   FILE 312\n//*                        1) USER                                  *   FILE 312\n//*                        2) SITE                                  *   FILE 312\n//*                        3) the active Application command table  *   FILE 312\n//*                        4) ISPCMDS                               *   FILE 312\n//*                                                                 *   FILE 312\n//*     verb  is the name of the command to add to the table. This  *   FILE 312\n//*                   must be from 1 to 8 alphanumeric characters.  *   FILE 312\n//*                                                                 *   FILE 312\n//*     truncation is the number of characters which the command    *   FILE 312\n//*                   can be abbreviated or 0 to indicate no        *   FILE 312\n//*                   abbreviation                                  *   FILE 312\n//*                                                                 *   FILE 312\n//*     action is a valid ISPF Select command                       *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member LOADISPF  (updated 01/09/2019)                          *   FILE 312\n//*                                                                 *   FILE 312\n//*    LOADISPF is a rexx routine to be copied into your            *   FILE 312\n//*    rexx code that supports placing all ISPF elements            *   FILE 312\n//*    (panels, messages, skeletons, clists, and rexx)              *   FILE 312\n//*    inline in your REXX exec. It will, when called,              *   FILE 312\n//*    scan your source code and dynamically allocate               *   FILE 312\n//*    temporary datasets and then altlib or libdef to              *   FILE 312\n//*    them.                                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member LOWER   - Simple REXX function written in REXX to       *   FILE 312\n//*                   return a string in lowercase:                 *   FILE 312\n//*                                                                 *   FILE 312\n//*                   lcase = lower('STRING')                       *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member LSTPROC - REXX Exec to list PROCLIB libraries and       *   FILE 312\n//*                   invoke ISRDDN.                                *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member LSTPROC3 - version of LSTPROC for JES3 shops            *   FILE 312\n//*                    ** updated 9/27/18 **                        *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member MGEN - simple rexx exec to display the system           *   FILE 312\n//*                maxgen limit. Demonstrates how to find           *   FILE 312\n//*                the value.                                       *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member OMVSCMD - This member is in TSO XMIT format.            *   FILE 312\n//*                                                                 *   FILE 312\n//*    This member, when received using TSO RECEIVE will be a       *   FILE 312\n//*    PDS with member OMVSCMD.  Copy this into a                   *   FILE 312\n//*     REXX library and run it.                                    *   FILE 312\n//*                                                                 *   FILE 312\n//*    Function:  Issue a OMVS command for the passed option        *   FILE 312\n//*               or prompt for a command.  Then display the        *   FILE 312\n//*               results in ISPF Browse.                           *   FILE 312\n//*                                                                 *   FILE 312\n//*               If no command is provided then a popup panel      *   FILE 312\n//*               appears to prompt for the OMVS command.           *   FILE 312\n//*                                                                 *   FILE 312\n//*    Syntax:    %OMVSCMD command                                  *   FILE 312\n//*                                                                 *   FILE 312\n//*    Dependencies:  Dependent on STEMVIEW from CBTtape            *   FILE 312\n//*                                                                 *   FILE 312\n//*    Usage:     Best used when added to the site ISPF             *   FILE 312\n//*               command table:                                    *   FILE 312\n//*                                                                 *   FILE 312\n//*               Verb:   ocmd                                      *   FILE 312\n//*               T:      0                                         *   FILE 312\n//*               Action: select cmd(%OMVSCMD &zparm)               *   FILE 312\n//*                                                                 *   FILE 312\n//*               Then the user can enter:  ocmd xxx                *   FILE 312\n//*                                                                 *   FILE 312\n//*    Member OMVSCOPY - Updated 08/10/2018                         *   FILE 312\n//*                                                                 *   FILE 312\n//*    OMVSCOPY contains the following members:                     *   FILE 312\n//*                                                                 *   FILE 312\n//*    OMVSCOPY  - The ISPF front-end to the TSO OCOPY Command      *   FILE 312\n//*    OCOPYO    - Sample JCL: copy from OMVS file to z/OS data set *   FILE 312\n//*    OCOPYZ    - Sample JCL: copy from z/OS data set to OMVS file *   FILE 312\n//*                                                                 *   FILE 312\n//*    OMVSCOPY is an ISPF front-end to the TSO OCOPY command       *   FILE 312\n//*    designed to make it easy to copy an z/OS data set to an OMVS *   FILE 312\n//*    file and vice versa.  OMVSCOPY supports both foreground and  *   FILE 312\n//*    batch execution. When the Batch option is selected, it will  *   FILE 312\n//*    dynamically generate the batch JCL and allow the user to     *   FILE 312\n//*    Edit it prior to submission, or the user can copy the JCL to *   FILE 312\n//*    a permanent JCL data set for modification and reuse.         *   FILE 312\n//*                                                                 *   FILE 312\n//*    OMVSCOPY is an ISPF front end to the IBM TSO OCOPY command   *   FILE 312\n//*    and will:                                                    *   FILE 312\n//*                                                                 *   FILE 312\n//*    1. copy a z/OS data set to an OMVS file                      *   FILE 312\n//*    2. copy an OMVS file to a z/OS data set                      *   FILE 312\n//*    3. supports an ISPF 3.17 like interface to find and select   *   FILE 312\n//*       the desired OMVS file to copy                             *   FILE 312\n//*    4. supports a ISPF 3.4 like interface to find and select the *   FILE 312\n//*       desired z/OS data set to copy                             *   FILE 312\n//*    5. supports a member selection list interface to find and    *   FILE 312\n//*       select the desired PDS member to copy                     *   FILE 312\n//*    6. Foreground and Batch execution is supported with the      *   FILE 312\n//*       Batch mode generating JCL, presented under ISPF Edit, to  *   FILE 312\n//*       the user to submit or to copy for later use.              *   FILE 312\n//*    7. Support for SuperUser (foreground only)                   *   FILE 312\n//*                                                                 *   FILE 312\n//*    While using the ISPF dialog the input supports               *   FILE 312\n//*    special processing:                                          *   FILE 312\n//*                                                                 *   FILE 312\n//*       - hlq.xxx.*    Results in a selection list of available   *   FILE 312\n//*                      data sets                                  *   FILE 312\n//*       - hlq.xxx.pds  Results in a selection list of members     *   FILE 312\n//*       - /u/          Results in a selection list of OMVS files  *   FILE 312\n//*                      similar to ISPF 3.17                       *   FILE 312\n//*                                                                 *   FILE 312\n//*    When in the OMVS file selection display the user can use L   *   FILE 312\n//*    to open a directory, including using L on the .. directory   *   FILE 312\n//*    to move up one level.  The CD command may also be used to go *   FILE 312\n//*    directy to a directory. And the ~ may be used to indicate    *   FILE 312\n//*    the users home directory.                                    *   FILE 312\n//*                                                                 *   FILE 312\n//*    The sample JCL members are for those who prefer to do the    *   FILE 312\n//*    copy in batch.                                               *   FILE 312\n//*                                                                 *   FILE 312\n//*    Member OMVSMAN - updated 02/28/18                            *   FILE 312\n//*                                                                 *   FILE 312\n//*    OMVSMAN is an ISPF dialog that will list all of the known    *   FILE 312\n//*    OMVS man pages in an ISPF Table. The manpage and description *   FILE 312\n//*    is displayed. The user can select a manpage to be displayed  *   FILE 312\n//*    in ISPF Browse or View.                                      *   FILE 312\n//*                                                                 *   FILE 312\n//*    The REXX code contains the ISPF Panels and Message inline    *   FILE 312\n//*    so this is easy to install and use.                          *   FILE 312\n//*                                                                 *   FILE 312\n//*    Member OMVSPAX - this member is in TSO XMIT format.          *   FILE 312\n//*               ** Updated 09/17/2020                             *   FILE 312\n//*                                                                 *   FILE 312\n//*    This member, when received using TSO RECEIVE, will be a      *   FILE 312\n//*    PDS with the package.  Member $DOC is additional             *   FILE 312\n//*    documentation, Member $RECV will receive the EXEC and        *   FILE 312\n//*    PANELS members to create an EXEC and PANELS library.         *   FILE 312\n//*                                                                 *   FILE 312\n//*    OMVSPAX is a package of three small ISPF dialogs             *   FILE 312\n//*    written in REXX to simplify the backup and restoration       *   FILE 312\n//*    of a omvs directory.                                         *   FILE 312\n//*     The dialogs are:                                            *   FILE 312\n//*                                                                 *   FILE 312\n//*         OMVSPAXB  - backup a omvs directory using pax to a      *   FILE 312\n//*                     z/OS dataset.                               *   FILE 312\n//*         OMVSPAXL  - list the contents of a backup pax z/OS      *   FILE 312\n//*                     dataset.                                    *   FILE 312\n//*         OMVSPAXR  - restore a pax z/OS backup dataset to        *   FILE 312\n//*                     the original omvs directory or another      *   FILE 312\n//*                     directory providing it exists               *   FILE 312\n//*                                                                 *   FILE 312\n//*     To invoke the dialogs:                                      *   FILE 312\n//*                                                                 *   FILE 312\n//*         1. Must be under ISPF                                   *   FILE 312\n//*         2. From ISPF 6 enter %OMVSPAX?   Where ? is B/L/R       *   FILE 312\n//*         3. From any ISPF command line enter:  TSO %OMVSPAX?     *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member OMVSSEL - ISPF REXX Subroutine to Select OMVS Files     *   FILE 312\n//*               ** Updated 08/16/2018                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     Very useful subroutine for use in REXX under ISPF to        *   FILE 312\n//*     select an OMVS file from a ISPF 3.17 like display for       *   FILE 312\n//*     processing.                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member ONCALL - Generate an oncall rotation schedule           *   FILE 312\n//*                                                                 *   FILE 312\n//*    I have a new tool that is on my beta page that you           *   FILE 312\n//*    all might find interesting.  It will generate an             *   FILE 312\n//*    oncall rotation for your group and optionally e-mail         *   FILE 312\n//*    (using xmitip) the rotation list along with an               *   FILE 312\n//*    icalendar file that can be used to add the oncall            *   FILE 312\n//*    information to each individuals calendar.                    *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member ONLY                                                    *   FILE 312\n//*               ** Updated 12/24/2019                             *   FILE 312\n//*                                                                 *   FILE 312\n//*    ISPF Edit ONLY command to hide all records and expose only   *   FILE 312\n//*    those that match the provided criteria.                      *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member PLPISPF - A Dynamic ISPF Menu System                    *   FILE 312\n//*               ** Updated 10/16/2018                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     PLPISPF, or PLP for short, is a dynamic ISPF menuing        *   FILE 312\n//*     system. PLP is short for Product Launch Point. It has       *   FILE 312\n//*     a full ISPF menu driven administrative component that       *   FILE 312\n//*     allows the admin to define the application name, profile,   *   FILE 312\n//*     load library, clist/exec library, other ispf libraries,     *   FILE 312\n//*     and optionally additional DD's to allocate. Then the        *   FILE 312\n//*     call using TSO command, ISPF command, or ISPF Panel.        *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member PNS - a short text document                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     Attempts to document how to use point and shoot fields      *   FILE 312\n//*     in ISPF dialogs.                                            *   FILE 312\n /*                                                                 *   FILE 312\n//*  Member PRINT - This member is in TSO XMIT format.              *   FILE 312\n//*               ** Updated 2/14/18 **                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     This member contains 2 ISPF dialogs:                        *   FILE 312\n//*                                                                 *   FILE 312\n//*     LPREDIT  - ISPF Edit command to invoke LPRPRINT             *   FILE 312\n//*                                                                 *   FILE 312\n//*     LPRPRINT - used to print using the z/OS TCP/IP LPR          *   FILE 312\n//*                command to any system with an LPD server.        *   FILE 312\n//*                This includes intelligent printers which         *   FILE 312\n//*                have LPD build-in. Now with message and panels   *   FILE 312\n//*                inline.                                          *   FILE 312\n//*                                                                 *   FILE 312\n//*     PSPRINT  - used to format host output for printing on a     *   FILE 312\n//*                PostScript printer and then invoke LPRPRINT.     *   FILE 312\n//*                Options include Portrait, Landscape, and 2UP     *   FILE 312\n//*                printing.                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*     The members of this dataset are in IEBUPDTE format.         *   FILE 312\n//*                                                                 *   FILE 312\n//*     $DOC     - What you are reading                             *   FILE 312\n//*     EXEC     - The above 3 rexx execs which are the entry       *   FILE 312\n//*                points to the dialogs                            *   FILE 312\n//*     MSGS     - ISPF messages for PSPRINT                        *   FILE 312\n//*     PANELS   - ISPF panels, including brief tutorials, for      *   FILE 312\n//*                the PSPRINT dialog                               *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member PRMCK - Check the syntax of PARMLIB members.            *   FILE 312\n//*         Updated 05/14/20                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*     PARMLIB Check                                               *   FILE 312\n//*                                                                 *   FILE 312\n//*     This application consists of a REXX Exec and an ISPF        *   FILE 312\n//*     Panel.  To use this you need to copy the exec (choose       *   FILE 312\n//*     the FB or the VB version) into a library in your            *   FILE 312\n//*     SYSPROC or SYSEXEC concatenation.  You then need to         *   FILE 312\n//*     copy the panel into a library in your ISPPLIB               *   FILE 312\n//*     concatenation.                                              *   FILE 312\n//*                                                                 *   FILE 312\n//*     Usage is to Edit the desired member of SYS1.PARMLIB         *   FILE 312\n//*     and enter the command PRMCK.                                *   FILE 312\n//*                                                                 *   FILE 312\n//*     Syntax: PRMCK cat sysres (debug                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     valid options are:                                          *   FILE 312\n//*           ?   - will prompt for catalog and sysres              *   FILE 312\n//*           -H  - display tutorial panel                          *   FILE 312\n//*           cat - is a name that will be used in the master       *   FILE 312\n//*                 catalog lookup (find *custom* below) and        *   FILE 312\n//*                 if not found will be used as the master         *   FILE 312\n//*                 catalog name (enter without quotes).            *   FILE 312\n//*           sysres is the volser of the system ipl volume         *   FILE 312\n//*                 to be checked when a volser of ****** is        *   FILE 312\n//*                 coded.                                          *   FILE 312\n//*           (debug - will turn on tracing                         *   FILE 312\n//*                                                                 *   FILE 312\n//*     Support for PROGxx member statements                        *   FILE 312\n//*        - LNKLST                                                 *   FILE 312\n//*        - APF                                                    *   FILE 312\n//*        - LPA                                                    *   FILE 312\n//*        - SYSLIB                                                 *   FILE 312\n//*     Support for LNKLSTxx and LPALSTxx members                   *   FILE 312\n//*                                                                 *   FILE 312\n//*     Verification is not 100% the same as the system will        *   FILE 312\n//*     perform when used but it does a fair amount of              *   FILE 312\n//*     verification.  Errors and Warnings are inserted into        *   FILE 312\n//*     the Edit display as non-saveable messages.                  *   FILE 312\n//*                                                                 *   FILE 312\n//*     Member QTAB     - Updated 12/07/2020                        *   FILE 312\n//*                                                                 *   FILE 312\n//*     Function:  ISPF Dialog to display all open ISPF tables      *   FILE 312\n//*                with table stats with an option to display       *   FILE 312\n//*                all table rows. Very useful to debug an ISPF     *   FILE 312\n//*                application to see if it leaves any open         *   FILE 312\n//*                tables when it ends.                             *   FILE 312\n//*                                                                 *   FILE 312\n//*     Member RANDSTR  - Updated 02/27/2018                        *   FILE 312\n//*                                                                 *   FILE 312\n//*     Function:  Generate a unique character string for use       *   FILE 312\n//*                in an ISPF Table name, DDName, etc.              *   FILE 312\n//*                                                                 *   FILE 312\n//*                This is for ISPF dialogs that may run            *   FILE 312\n//*                concurrently in either multiple split            *   FILE 312\n//*                screens or stacked so as to prevent duplicate    *   FILE 312\n//*                DD or ISPF table names.                          *   FILE 312\n//*                                                                 *   FILE 312\n//*                Or any length string with or without             *   FILE 312\n//*                lowercase characters.                            *   FILE 312\n//*                                                                 *   FILE 312\n//*                Thus this can be used to generate a random       *   FILE 312\n//*                password or passphrase                           *   FILE 312\n//*                                                                 *   FILE 312\n//*                This may also be used for any other need         *   FILE 312\n//*                to have a unique character string that is        *   FILE 312\n//*                a valid DDName, Member Name, etc.                *   FILE 312\n//*                                                                 *   FILE 312\n//*     Syntax:    x = randstr(n)                                   *   FILE 312\n//*                                                                 *   FILE 312\n//*                Where n is the number of characters to           *   FILE 312\n//*                return, always starting with an alpha.           *   FILE 312\n//*                                                                 *   FILE 312\n//*                The default if not provided is 8                 *   FILE 312\n//*                                                                 *   FILE 312\n//*                If 'n' is preceded by L (e.g. L8) then           *   FILE 312\n//*                50% of the characters will be lowercase          *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member REXXER                                                  *   FILE 312\n//*         - added 10/28/20                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*    Invoke REXX Compiler and only display error messages as      *   FILE 312\n//*    an ISPF Edit Macro.                                          *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member REXXFORM                                                *   FILE 312\n//*                                                                 *   FILE 312\n//*    REXXFORM is the z/OS ISPF Edit macro ported from the         *   FILE 312\n//*    popular z/VM XEDIT REXXFORM command with several minor       *   FILE 312\n//*    enhancements to take advantage of ISPF Edit capabilities.    *   FILE 312\n//*                                                                 *   FILE 312\n//*    REXXFORM is an ISPF edit macro used to format REXX           *   FILE 312\n//*    EXECs by indenting DO and SELECT groups and                  *   FILE 312\n//*    left-justifying lines at a selected column.  It also         *   FILE 312\n//*    checks for unbalanced DO or SELECT statements.  One          *   FILE 312\n//*    use of this ISPF edit macro is to uniformly                  *   FILE 312\n//*    restructure REXX files after composing them without          *   FILE 312\n//*    regard for any particular format or standard coding          *   FILE 312\n//*    style.                                                       *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member REXXTRY                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*    REXXTRY is from IBM's OS/2 and is an interactive             *   FILE 312\n//*    way to experiment with any REXX command you care             *   FILE 312\n//*    to try.                                                      *   FILE 312\n//*                                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*  Member RUNC    - this member is in TSO XMIT format.            *   FILE 312\n//*                   Updated 07/30/2020                            *   FILE 312\n//*                                                                 *   FILE 312\n//*    The RUNC ISPF Edit Command is only used within ISPF Edit     *   FILE 312\n//*    and will execute any TSO commands found on the selected      *   FILE 312\n//*    records within the active ISPF Edit data.                    *   FILE 312\n//*                                                                 *   FILE 312\n//*    No knowledge of CLIST, REXX, or JCL is required to use.      *   FILE 312\n//*    But knowing TSO commands is helpful :-)                      *   FILE 312\n//*                                                                 *   FILE 312\n//*    NEW Capability to execute an Inline ISPF Edit Macro.         *   FILE 312\n//*                                                                 *   FILE 312\n//*    Syntax:  RUNC options                                        *   FILE 312\n//*                                                                 *   FILE 312\n//*    options may be:                                              *   FILE 312\n//*                                                                 *   FILE 312\n//*               blank (default)                                   *   FILE 312\n//*               ? or HELP to display this info                    *   FILE 312\n//*               n - must be the first option and will skip        *   FILE 312\n//*                   the first n characters to find the command    *   FILE 312\n//*               ? or HELP to display help information             *   FILE 312\n//*              -A process all non-excluded command records        *   FILE 312\n//*              -ALL process all non-excluded command records      *   FILE 312\n//*              -B to browse the results using STEMEDIT            *   FILE 312\n//*              -C to display log datasets                         *   FILE 312\n//*              -D to insert messages as data in edit session      *   FILE 312\n//*                 or -D(prefix) to prefix the inserted messages   *   FILE 312\n//*              -L to log to a dataset (default defined in code)   *   FILE 312\n//*              -LD to log to a sequential dataset                 *   FILE 312\n//*              -LP to log to a partitioned dataset                *   FILE 312\n//*              -LX to over-ride logging if defaulted in userdefs  *   FILE 312\n//*              -N to insert messages as notelines in edit session *   FILE 312\n//*              -O to change user default RUNC options             *   FILE 312\n//*              -R to generate report if no messages generated     *   FILE 312\n//*              -S nnn to stop if the return code exceeds nnn      *   FILE 312\n//*              -T to not trap and let the results go to screen    *   FILE 312\n//*              -V to view the results using STEMEDIT              *   FILE 312\n//*                  default is to View                             *   FILE 312\n//*              -W nnn to wrap text for -D/-N to nnn characters    *   FILE 312\n//*                 if nnn is W will wrap to Edit data length       *   FILE 312\n//*              ONLY(string) will search for the string (e.g. xyz) *   FILE 312\n//*                 in the command string and if not found will     *   FILE 312\n//*                 ignore that command.                            *   FILE 312\n//*              PREFIX(string) will append the string to the       *   FILE 312\n//*                 front of each command.                          *   FILE 312\n//*              SUFFIX(string) will append the string to the       *   FILE 312\n//*                 end of each command.                            *   FILE 312\n//*                                                                 *   FILE 312\n//*              ** PREFIX and SUFFIX apply only for TSO commands   *   FILE 312\n//*                                                                 *   FILE 312\n//*   Special control statements:                                   *   FILE 312\n//*              <DOC><TITLE></DOC> for a doc pop up panel          *   FILE 312\n//*              <EXIT rc> to exit if return code >=                *   FILE 312\n//*              <START><END> to define a range of commands         *   FILE 312\n//*                                                                 *   FILE 312\n//*              SET symbolic = value                               *   FILE 312\n//*                                                                 *   FILE 312\n//*    Dependencies: Requires STEMEDIT (copy included in package)   *   FILE 312\n//*                  Optional EKKO (copy included in package)       *   FILE 312\n//*                                                                 *   FILE 312\n//*    Usage Notes: 1. Select records with TSO commands using       *   FILE 312\n//*                    line tags, C, C#, or CC and CC,              *   FILE 312\n//*                    or S, S#, SS and SS.                         *   FILE 312\n//*                 2. Use the command option of -ALL to process    *   FILE 312\n//*                    all non-excluded records for commands        *   FILE 312\n//*                 3. Data lines starting with *, /*, //, or //*   *   FILE 312\n//*                    or all blank will be ignored                 *   FILE 312\n//*                    - use n to skip over *, /* , //, or //*      *   FILE 312\n//*                 4. Excluded lines are also ignored              *   FILE 312\n//*                 5. Commands may be continued on the next        *   FILE 312\n//*                    record by using a + at the end of the        *   FILE 312\n//*                    command for the record                       *   FILE 312\n//*                 6. The data on the line will be executed        *   FILE 312\n//*                    using the Address TSO command as a TSO       *   FILE 312\n//*                    command, or ADDRESS ISPExec for ISPF         *   FILE 312\n//*                    commands.                                    *   FILE 312\n//*                 7. TSO and ISPF SELECT commands can be in any   *   FILE 312\n//*                    record in the data.                          *   FILE 312\n//*                 8. Not all TSO commands are trappable           *   FILE 312\n//*                    - only those that use PUTLINE                *   FILE 312\n//*                    - ISPF commands probably are not             *   FILE 312\n//*                 9. Symbolics are supported in the command       *   FILE 312\n//*                    using the syntax of &symbol. An ISPF         *   FILE 312\n//*                    panel will be generated to prompt for        *   FILE 312\n//*                    the symbolic values.                         *   FILE 312\n//*                10. Use a symbolic at the end to allow entry     *   FILE 312\n//*                    of additional command options                *   FILE 312\n//*                11. Over 20 predefined symbolics supported       *   FILE 312\n//*                                                                 *   FILE 312\n//*     Sample Usage:                                               *   FILE 312\n//*                                                                 *   FILE 312\n//*        LISTD &dsn                                               *   FILE 312\n//*        LISTC ENT(&dsn) ALL                                      *   FILE 312\n//*        PDS &dsn                                                 *   FILE 312\n//*        PDS MY.EXEC                                              *   FILE 312\n//*        SELECT PANEL(&panel)                                     *   FILE 312\n//*        SELECT PANEL(ISR@PRIM) +                                 *   FILE 312\n//*               opt(&opt)                                         *   FILE 312\n//*        BROWSE Dataset(xxx)                                      *   FILE 312\n//*        BROWSE Dataset(xxx) Volume(volser)                       *   FILE 312\n//*        BROWSE Member(xxx)                                       *   FILE 312\n//*        Edit Dataset(xxx)                                        *   FILE 312\n//*        Edit Dataset(xxx) Volume(volser)                         *   FILE 312\n//*        Edit Member(xxx)                                         *   FILE 312\n//*        View Dataset(xxx)                                        *   FILE 312\n//*        View Dataset(xxx) Volume(volser)                         *   FILE 312\n//*        View Member(xxx)                                         *   FILE 312\n//*        Rename dataset volser from-member to-member              *   FILE 312\n//*        Sleep nn                                                 *   FILE 312\n//*        EJES ST                                                  *   FILE 312\n//*        SDSF ST                                                  *   FILE 312\n//*                                                                 *   FILE 312\n//*    Then use the RUNC command on that dataset/member and use the *   FILE 312\n//*    row selection commands to select the record(s) to process.   *   FILE 312\n//*                                                                 *   FILE 312\n//*    Included is the ERC (execute runc) command that is a ispf    *   FILE 312\n//*    command to fast path to the commands dataset or pds member.  *   FILE 312\n//*                                                                 *   FILE 312\n//*    The symbolics in the sample commands will bring up an ISPF   *   FILE 312\n//*    panel that will prompt the user to enter a value for each    *   FILE 312\n//*    symbolic in the order that they are found within the         *   FILE 312\n//*    command.                                                     *   FILE 312\n//*                                                                 *   FILE 312\n//* --------------------------------------------------------------- *   FILE 312\n//*     Lionel B. Dyck                                              *   FILE 312\n//*     email:   lbdyck@gmail.com                                   *   FILE 312\n//*     website: www.lbdsoftware.com                                *   FILE 312\n//* --------------------------------------------------------------- *   FILE 312\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ALIGN": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00(\\x01\\x196_\\x01\\x196_\\x06A\\x00\\xd8\\x00\\x8b\\x00\\x00\\xc1\\xd3\\xc9\\xc7\\xd5@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-12-31T00:00:00", "modifydate": "2019-12-31T06:41:28", "lines": 216, "newlines": 139, "modlines": 0, "user": "ALIGN"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "ALLOCGDG": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x03\\x03o\\x01\\x03\\x03o\\x14\\x04\\x00\\x8a\\x00\\x8a\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-02-05T00:00:00", "modifydate": "2003-02-05T14:04:00", "lines": 138, "newlines": 138, "modlines": 0, "user": "SYSLBD"}, "text": "        /* --------------------  rexx procedure  -------------------- *\n         * Name:      allocgdg                                        *\n         *                                                            *\n         * Function:  Allocate a GDG (input only)                     *\n         *                                                            *\n         * Syntax:    %allocgdg ddn dsname(n)                         *\n         *                                                            *\n         *            if ddn is * then the dsname is returned to      *\n         *            the caller:                                     *\n         *                                                            *\n         *            gdg_dsn = allocgdg(\"* 'hlq.dsname(n)'\")         *\n         *            (no comma between parameters)                   *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Kaiser Permanente Information Technology        *\n         *            Walnut Creek, CA 94598                          *\n         *            (925) 926-5332                                  *\n         *            Internet: lionel.b.dyck@kp.org                  *\n         *                                                            *\n         * History:                                                   *\n         *            02/03/03 - update comments above                *\n         *            05/15/01 - fix if prefix ne userid              *\n         *            05/14/01 - creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- */\n\n         arg ddn dsn\n\n        /* --------------------------------------------------------- *\n         * Validate input                                            *\n         * --------------------------------------------------------- */\n         if length(ddn) = 0 then call badinput 1\n         if length(dsn) = 0 then call badinput 2\n         if pos(\"(\",dsn) = 0 then call badinput 3\n\n        /* --------------------------------------------------------- *\n         * Extract the GDG Base from the provided DSname as well as  *\n         * extracting the relative GDG.                              *\n         * --------------------------------------------------------- */\n         if left(dsn,1) = \"'\" then\n            parse value dsn with \"'\"dsn\"'\"\n         else do\n              if sysvar(syspref) <> sysvar(sysuid)\n                 then dsn = sysvar(syspref)\".\"dsn\n                 else dsn = sysvar(sysuid)\".\"dsn\n                 end\n         parse value dsn with dsn \"(\"gdg\")\"\n         if datatype(gdg) <> \"NUM\" then call badinput 3\n\n        /* --------------------------------------------------------- *\n         * Invoke LISTC Level(gdg-base) to Get List of all GDG's     *\n         * --------------------------------------------------------- */\n         call outtrap \"listc.\"\n         \"listc level('\"dsn\"')\"\n         call outtrap \"off\"\n\n        /* --------------------------------------------------------- *\n         * Place each DSname into the GDG. stem                      *\n         * --------------------------------------------------------- */\n         base = 0\n         do i = 1 to listc.0\n            if word(listc.i,1) <> \"NONVSAM\" then iterate\n            base = base + 1\n            gdg.base = word(listc.i,3)\n            end\n\n        /* --------------------------------------------------------- *\n         * If the gdg is >0 then it must have been created within    *\n         * this batch job and the catalog is not updated yet. This   *\n         * should not be an issue in current levels of OS/390 v2r7+  *\n         * --------------------------------------------------------- */\n         if gdg > 0 then do\n            dsnw = gdg.base\n            dsnw = translate(dsnw,\" \",\".\")\n            goovoo = word(dsnw,words(dsnw))\n            parse value goovoo with \"G\" gen \"V\" ver\n            if gen = 9999 then do\n               gen = 0\n               ver = ver + 1\n               gdg = gdg - 1\n               end\n            gen = gen + gdg\n            dsnt = subword(dsnw,1,words(dsnw)-1)\n            dsnt = dsnt\".G\"right(gen+10000,4)\"V\"right(ver+100,2)\n            dsnt = translate(dsnt,\".\",\" \")\n            gdg.base = dsnt\n            end\n         else do\n              base = base + gdg\n              if base < 1 then call badinput 6\n              end\n\n        /* --------------------------------------------------------- *\n         * Test GDG Dsname for validity                              *\n         * --------------------------------------------------------- */\n         if sysdsn(\"'\"gdg.base\"'\") <> \"OK\" then call badinput 5\n\n        /* --------------------------------------------------------- *\n         * Now Allocate the Dataset to the specified DDN, or if      *\n         * DDN = * then return the dsname to the caller              *\n         * --------------------------------------------------------- */\n         if ddn = \"*\" then return \"'\"gdg.base\"'\"\n         else \"Alloc f(\"ddn\") ds('\"gdg.base\"') shr reuse\"\n         exit 0\n\n        /* --------------------------------------------------------- *\n         * Error routine to inform the user of the reason that we    *\n         * are terminating this execution.                           *\n         * --------------------------------------------------------- */\n         BadInput:\n            arg opt\n            say \"Error invoking\" sysvar(sysicmd)\n            Select\n              When opt = 1 then\n                   say \"no parameters provided.\"\n              When opt = 2 then\n                   say \"two parameters are required.\"\n              When opt = 3 then\n                   say dsn \"is not an apparent gdg.\"\n              When opt = 4 then\n                   say \"generation of\",\n                        gdg \"must be 0 or negative.\"\n              When opt = 5 then do\n                   say \"GDG DSname of\" gdg.base ,\n                        sysdsn(\"'\"gdg.base\"'\")\n                   exit 4\n                   end\n              When opt = 6 then do\n                   say \"Generation of\" gdg ,\n                        \"is not within the range of generations\",\n                        \"for GDG Base DSname\" dsn\n                   exit 4\n                   end\n              Otherwise nop\n              End\n            say \"Correct syntax is:\"\n            say \"%\"sysvar(sysicmd) \"ddname dsname(-n)\"\n            exit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BACKDIR": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x17\\x19/\\x01\\x17\\x19/\\x14\\x14\\x01g\\x01g\\x00\\x00\\xd3\\xc2\\xc4@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-07-11T00:00:00", "modifydate": "2017-07-11T14:14:09", "lines": 359, "newlines": 359, "modlines": 0, "user": "LBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "BISPFJCL": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x161/\\x01\\x162\\x1f\\x10\\x18\\x02\\x0e\\x01q\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2016-11-16T10:18:56", "lines": 526, "newlines": 369, "modlines": 0, "user": "SYSLBD"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      bispfjcl                                        *\n *                                                            *\n * Function:  create ispf batch jcl for tailoring             *\n *            based on the users current allocations          *\n *                                                            *\n *            after creating the jcl the user will be         *\n *            placed into ISPF Edit on them                   *\n *                                                            *\n * Syntax:    %bispfjcl                                       *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * Acknowledgements:  I have 'borrowed' the TIOT exec from    *\n *                    Ken MacKenzie from the CBTTape File 496 *\n *                    as it is much easier to use than LISTA  *\n *                    * this requied one small change (lbd)   *\n *                                                            *\n * History:                                                   *\n *            07/18/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n\n/* ----------------------------- *\n * Define the DD's we care about *\n * ----------------------------- */\n kdds = 'SYSPROC SYSEXEC ISPMLIB ISPPLIB ISPPROF ISPSLIB ISPTLIB ISPLLIB'\n\n/* ------------------------------ *\n * Define our additional defaults *\n * ------------------------------ */\n null = ''\n jcldd = 'JCL'random(99)\n jcl.1 = '//jobname JOB xxx,'\n jcl.2 = '//        MSGLEVEL=(1,1),MSGCLASS=A,NOTIFY='sysvar(sysuid)\n jcl.3 = '//OUT       OUTPUT DEFAULT=YES,JESDS=ALL,OUTDISP=(HOLD,HOLD)'\n jcl.4 = '//BATCHSPF  EXEC PGM=IKJEFT01,DYNAMNBR=50'\n jcl.5 = '//SYSTSPRT  DD   SYSOUT=*'\n jc    = 5\n\n/* ------------------------------------- *\n * Find the datasets to go with the dd's *\n * ------------------------------------- */\n dsnlist = tiot()\n do i = 1 to words(kdds)\n    ddname = word(kdds,i)\n    placeholder = '*'ddname'*'\n    Parse Var dsnlist . (placeholder) dslist '*' .\n    do id = 1 to words(dslist)\n       jc = jc + 1\n       dsn = substr(word(dslist,id),2,length(word(dslist,id))-2)\n       jcl.jc = '//'left(ddname,8) 'DD  DISP=SHR,DSN='dsn\n       ddname = null\n       end\n    end\n\n/* --------------------- *\n * Insert the SYSTSIN DD *\n * --------------------- */\n jc = jc + 1\n jcl.jc = '//SYSTSIN DD *'\n jc = jc + 1\n if sysvar('syspref') = null then pfx = sysvar('sysuid')\n                             else pfx = sysvar('syspref')\n jcl.jc = ' PROFILE PREFIX('pfx')'\n jc = jc + 1\n jcl.jc = '/*'\n jcl.0 = jc\n\n/* -------------------------------------- *\n * Define the working dataset for the JCL *\n * -------------------------------------- */\n jcldsn = \"'\"pfx\".ispfjcl.cntl'\"\n\n/* --------------------------------- *\n * If it exists then delete it first *\n * --------------------------------- */\n if sysdsn('jcldsn') = 'OK' then do\n    call outtrap 'x.'\n    'Delete' jcldsn\n    call outtrap 'off'\n    end\n\n/* ------------------------------------------------- *\n * Allocate the JCL dataset and fill it with our JCL *\n * ------------------------------------------------- */\n 'Alloc f('jcldd') ds('jcldsn') new spa(1,1) tr recfm(f b)' ,\n       'lrecl(80) blksize(23440)'\n 'Execio * diskw' jcldd '(finis stem jcl.'\n\n/* ------------------------------------------------------- *\n * Issue an ISPF Edit message to tell the user to save the *\n * JCL as the JCL dataset will be deleted when existing.   *\n * ------------------------------------------------------- */\n Address ISPExec\n zedsmsg = ''\n zedlmsg = 'Save this to another dataset using the CREATE or REPLACE' ,\n           'Edit commands as this dataset will be deleted when you exit.'\n 'Setmsg msg(isrz001)'\n\n/* -------------------------- *\n * Edit the JCL dataset       *\n * then Delete it to clean up *\n * -------------------------- */\n 'Edit dataset('jcldsn')'\n Address TSO\n 'Free ds('jcldsn') delete'\n\n exit\n\n tiot:\n /**REXX****************************************************************\n *  TIOT exec - Ken MacKenzie - May 1998                               *\n *                                                                     *\n *  This exec will display (or return) a list of all datasets          *\n *  allocated to a particular ddname or all datasets allocated to all  *\n *  ddnames.  If the exec is entered as a command, the results are     *\n *  displayed (using \"STEMDISP\" or \"say\" ) or, if the command is       *\n *  invoked from another exec, the results are returned as a string    *\n *  consisting of the ddname enclosed in asterisks followed by a list  *\n *  of dataset names (individually) enclosed in quotes.  Use of this   *\n *  exec is faster and a lot less messy than using a combination of    *\n *  OUTTRAP and the LISTALC ST H command.  If you don't have STEMDISP  *\n *  at your site, you can obtain a copy of Gilbert Saint-Flour's       *\n *  version via the CBT (file 183).                                    *\n *                                                                     *\n *  Additionally, a TABLE parameter can be supplied.  This is in the   *\n *  form TABLE(table-name dd-var-name dsn-var-name).  If this          *\n *  parameter is supplied, the results are written to an ISPF table    *\n *  which can then be used to drive another process.                   *\n *---------------------------------------------------------------------*\n *  Limited support can be obtained from the author:                   *\n *  ken.mackenzie@bigfoot.com                                          *\n *---------------------------------------------------------------------*\n *  Examples of use can be found at the end of the exec                *\n *---------------------------------------------------------------------*\n *  Amendment History (Latest First)                                   *\n *                                                                     *\n *  19 January   2001 - Ken MacKenzie                                  *\n *                    - Changed TABLE processing to NOWRITE            *\n *                    - Added \"Address TSO\" to VIEWSTEM procedure      *\n *                                                                     *\n *  09 January   2001 - Ken MacKenzie                                  *\n *                    - Added TABLE processing                         *\n *                    - Changed the parameter handling                 *\n *                      (/DEBUG has changed to DEBUG(opt))             *\n *                      and the TABLE() parameter can now be used      *\n *                                                                     *\n *  08 January   2001 - Ken MacKenzie                                  *\n *                    - Simplify detection of the '/DEBUG'             *\n *                      parameter                                      *\n *                    - Use an internal routine to VIEW the            *\n *                      output if STEMDISP isn't available             *\n *                                                                     *\n *  04 January   2001 - Ken MacKenzie                                  *\n *                    - Updated the comments                           *\n *                    - Added a call to STEMDISP                       *\n *                    - SWAREQ coding brought in-line                  *\n *                    - Added Examples of Use                          *\n *                    - Use Numeric Digits 10 to allow for             *\n *                      addresses greater than 3B9AC9FF                *\n *                    - allow a '/DEBUG' parameter to be               *\n *                      supplied                                       *\n *                                                                     *\n *  15 December  2000 - Ken MacKenzie                                  *\n *                    - Turn off tracing                               *\n *                                                                     *\n *  20 May       1998 - Ken MacKenzie                                  *\n *                    - Initial coding                                 *\n **********************************************************************/\n\n /**********************************************************************\n *  Parm handling has been moved to a called routine: Extract_Parms    *\n **********************************************************************/\n   trace_setting = Trace('O')\n   true = 1; false = 0\n   Call Extract_Parms Arg(1)\n   trace_setting = Trace(debug)         /*Set debugging option       */\n   Numeric Digits 10                    /*Allow for big addresses    */\n   Parse Source . calltype .            /*Determine if we were called*/\n   If calltype = 'FUNCTION',            /*as a subroutine and set a  */\n    | calltype = 'SUBROUTINE' Then      /*variable as appropriate    */\n     subroutine = true\n   Else\n     subroutine = true /* false (lbd) */\n\n   If tb_required Then\n     Do\n       Address ISPEXEC\n       \"TBCREATE\" tbnam \"NAMES(\" tbddn tbdsn \") REPLACE\" ,\n       'nowrite'\n     End\n   tcb = C2d(Storage('21c', 4))         /*Address the TCB            */\n   tcb = tcb + 12\n   tcb = d2x(tcb)\n   tiot = c2d(Storage(tcb, 4))          /*Address the TIOT           */\n   tiot = tiot + 24                     /*Address the first DD entry */\n   xlen = 0                             /*bypassing jobname/stepnames*/\n\n   If subroutine Then\n     xstring =\n   Else\n     xstring.0 = 0\n   ddfound = false\n /*******************************************************************\n *  Loop through the TIOT looking for DDnames.                      *\n *  The first byte of each entry contains the length of that entry  *\n *  The first bit of the second byte is on if the entry is not in   *\n *  use.                                                            *\n *  Bytes  5-12 contain the DDname.                                 *\n *  Bytes 13-15 contain the SWA address                             *\n *  If there is a requested DD, we use the ddfound flag to control  *\n *  whether we've found the requested DD.  This is because          *\n *  concatenated files have a blank DDname.                         *\n *******************************************************************/\n   Do Forever\n     tiot = tiot + xlen\n     addr = tiot\n     xlen = C2d(Storage(D2x(addr), 1))\n     If xlen = 0 Then\n       Leave\n     If Bitand(Storage(d2x(addr + 1), 1), '80'x) = '80'x Then\n       iterate\n     addr = tiot + 4\n     ddname = Storage(D2x(addr), 8)\n     Select\n       When reqdd = '' Then\n         ddfound = true\n       When ddname = reqdd Then\n         ddfound = true\n       When ddname = '' Then\n         Nop\n       When ddname \\= reqdd Then\n         If ddfound Then\n           Leave\n       Otherwise\n         Nop\n     End\n     If \\ddfound Then\n       iterate\n     If subroutine Then\n       If ddname \\= '' Then\n         xstring = xstring '*'Strip(ddname,'T')'*'\n     addr = tiot + 12\n /*  dsnaddr = d2x(c2d(Storage(d2x(addr),3)) + 16)*/\n     dsnaddr = d2x(swareq(Storage(d2x(addr),3)))\n     dsname = Strip(Storage(dsnaddr, 44), 'T')\n     If subroutine Then\n       xstring = xstring \"'\"dsname\"'\"\n     Else\n       Do\n         xstring.0 = xstring.0 + 1\n         If ddname \\= '' & xstring.0 \\= 1 Then\n           Do\n             x = Value('xstring.'xstring.0, ' ')\n             xstring.0 = xstring.0 + 1\n           End\n         x = Value('xstring.'xstring.0, ddname dsname)\n       End\n     If tb_required Then\n       Do\n         Address ISPEXEC\n         x = Value(tbddn, ddname)\n         x = Value(tbdsn, dsname)\n         \"TBADD\" tbnam\n       End\n   End\n /********************************************************************\n *  If we're running as a subroutine then we simply return a string  *\n ********************************************************************/\n   If Subroutine Then\n     Return xstring\n /***********************************************************************\n *  If we're running as a command then we have to display the           *\n *  allocations.                                                        *\n *  If we are running under ISPF, we attempt to use \"STEMDISP\" and, if  *\n *  that fails, we use the internal \"VIEWSTEM\" routine; if that fails,  *\n *  we use \"say\" statements.                                            *\n *  If we are running under native TSO, we just use \"say\" statements.   *\n ***********************************************************************/\n   If reqdd = '' Then                   /*Set                         */\n     view_dd = 'all files'              /*    up a                    */\n   Else                                 /*         header             */\n     view_dd = reqdd                    /*                line        */\n   view_header = 'User:' Sysvar(Sysuid) '- file allocations:' view_dd\n   If Sysvar(Sysispf) \\= 'ACTIVE' Then\n     Call Non_Ispf_Display\n   Else\n     Do\n       Signal On Syntax                 /*In case STEMDISP fails      */\n       Call 'STEMDISP'  'VIEW', 'XSTRING.',,, view_header\n       Signal Off Syntax\n     End\n   Return 0\n Syntax:\n /*****************************************************************\n *  We come here in the event of a SYNTAX error.  Basically that  *\n *  means that the call to STEMDISP failed.                       *\n *  So we attempt to use the internal VIEWSTEM.  If that returns  *\n *  \"true\" it worked and we exit; otherwise we continue just      *\n *  with \"say\" statements.                                        *\n *****************************************************************/\n     Address ISPEXEC \"CONTROL DISPLAY LINE START(1)\"\n     If Viewstem() Then\n       Return\n Non_Ispf_Display:\n /*****************************************************************\n *  We come here either by dropping through from the SYNTAX error *\n *  routine (above) or when we are running in native TSO          *\n *****************************************************************/\n   Say view_header\n   Do i = 1 To xstring.0\n     Say xstring.i\n   End\n   Return 0\n /***************************************************************\n  *  The following routine was provided by Gilbert Saint-Flour  *\n  *  I have included it as an internal function because it is   *\n  *  easier to package that way.                                *\n  ***************************************************************/\n /*--------------------------------------------------------------------*\\\n \u00a6*                                                                    *\u00a6\n \u00a6* MODULE NAME = SWAREQ                                               *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6* STATUS = R200                                                      *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *\u00a6\n \u00a6*            convert an SWA Virtual Address (SVA) to a full 31-bit   *\u00a6\n \u00a6*            address which can be used to access SWA control blocks  *\u00a6\n \u00a6*            in the SWA=ABOVE environment.  The input is a 3-byte    *\u00a6\n \u00a6*            SVA; the output value is a 10-digit decimal number.     *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6* AUTHOR   =  Gilbert Saint-flour <gsf@ibm.net>                      *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6* DEPENDENCIES = TSO/E V2                                            *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6* SYNTAX   =  SWAREQ(sva)                                            *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6*             sva must contain a 3-byte SVA.                         *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6* Sample Invocation:                                                 *\u00a6\n \u00a6*                                                                    *\u00a6\n \u00a6*    NUMERIC DIGITS 10                                               *\u00a6\n \u00a6*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *\u00a6\n \u00a6*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *\u00a6\n \u00a6*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *\u00a6\n \u00a6*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *\u00a6\n \u00a6*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *\u00a6\n \u00a6*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *\u00a6\n \u00a6*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *\u00a6\n \u00a6*                                                                    *\u00a6\n \\*--------------------------------------------------------------------*/\n SWAREQ: PROCEDURE\n   IF RIGHT(C2X(ARG(1)),1) \\= 'F' THEN       /* SWA=BELOW ?          */\n     RETURN C2D(ARG(1))+16                   /* yes, return sva+16   */\n   NUMERIC DIGITS 10                         /* allow up to 7FFFFFFF */\n   sva=C2D(ARG(1))                           /* convert to decimal   */\n   tcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */\n   jscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */\n   qmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */\n   qmat = C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT        QMADD    */\n     DO WHILE sva>65536\n       qmat = C2D(STORAGE(D2X(qmat+12),4)) /* next QMAT     QMAT+12  */\n       sva=sva-65536                         /* 010006F -> 000006F   */\n     END\n   RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16\n /*-------------------------------------------------------------------*/\n Viewstem:\n Procedure Expose xstring. view_header\n /********************************************************************\n *  This routine attempts to allocate a temporary file whose DDname  *\n *  is based around the current time (in an effort to be unique).    *\n *  The view header and all xstring. variables are then written to   *\n *  the file and the file is then passed to ISPF view.               *\n *  If everything appeared to work OK, we return TRUE otherwise we   *\n *  return FALSE.                                                    *\n ********************************************************************/\n   Parse Value Time('L') With hh ':' mm ':' ss '.' ths\n   true = 1; false = 0\n   p = substr('ABCDEFGHIJKLMNOPQRSTUVWXY',hh+1,1)\n   viewdd = Left(p || mm || ss || ths, 8)\n\n   Address TSO\n   Signal On Error\n   x = Msg('OFF')\n   \"ALLOC F(\"viewdd\") SPACE(2 2) CYLINDER\"\n   x = Msg(x)\n   Signal Off Error\n   Push View_header\n   \"EXECIO 1 DISKW\" viewdd\n   \"EXECIO * DISKW\" viewdd \"(STEM XSTRING. FINIS\"\n   Address ISPEXEC\n   \"LMINIT DATAID(VIEWID) DDNAME(\"viewdd\")\"\n   \"VIEW DATAID(\"viewid\")\"\n   \"LMFREE DATAID(\"viewid\")\"\n   Address TSO \"FREE FI(\"viewdd\")\"\n   Return true\n Error:\n   Return false\n /*-------------------------------------------------------------------*/\n Extract_Parms:\n /******************************************************************\n *  Extracts parameter information.                                *\n *                                                                 *\n *  Available parameters are:                                      *\n *  - DEBUG(trace-options)                                         *\n *  - TABLE(table-name dd-var-name dsn-var-name)                   *\n *  - required-dd-name                                             *\n *                                                                 *\n *  These parameters can be supplied in any order and the default  *\n *  values are:                                                    *\n *      trace-options:  'O' (no tracing)                           *\n *         table-name:  TIOT                                       *\n *        dd-var-name:  DDNAME                                     *\n *       dsn-var-name:  DSNAME                                     *\n *                                                                 *\n *  My thanks go to Roy Gardiner who helped me to make my          *\n *  parameter processing much more simple than I had managed to    *\n *  do on my own.                                                  *\n ******************************************************************/\n   Arg Argstring\n   If Pos('TABLE(', argstring) \\= 0 Then\n     Do\n       Parse Var argstring p1 'TABLE(' tbnam tbddn tbdsn ')' p2\n       tb_required = true\n       argstring = p1 || p2\n     End\n   Else\n     tb_required = false\n   if pos('DEBUG(',argstring) > 0 Then\n     Do\n       debug_required = true\n       Parse Value argstring With p1 'DEBUG(' debug ')' p2\n     End\n   Else\n     debug_required = false\n   If tb_required | debug_required Then\n     reqdd  = strip(p1 || p2)\n   Else\n     reqdd = argstring\n   If tb_required Then\n     Do\n       If tbnam = '' Then\n         tbnam  = 'TIOT'\n       If tbddn = '' Then\n         tbddn  = 'DDNAME'\n       If tbdsn = '' Then\n         tbdsn  = 'DSNAME'\n     End\n   If \\debug_required Then\n     debug = 'O'\n   Return\n /*---------------------------------------------------------------------\n : Examples of use of the TIOT exec                                    :\n :                                                                     :\n : 1.  From the command line enter TSO TIOT and you will be presented  :\n :     with a list of all ddnames allocated to your session along with :\n :     the associated dsnames.  Each dsname occupies one line.         :\n :     The display will look something like this:                      :\n :           User: userid - file allocations: all files                :\n :           ISPTLIB  SYS1.SISPTENU                                    :\n :                    SYS1.SISFTLIB                                    :\n :                                                                     :\n :           SYSIN    SYS01004.T130908.RA000.MACKEKM.R0579190          :\n :                                                                     :\n :           ISPMLIB  SYS1.SISPMENU                                    :\n :                    SYS1.SISFMLIB                                    :\n :                    .                                                :\n :                    .                                                :\n :                                                                     :\n : 2.  From the command line enter TSO TIOT ISPPLIB and the result     :\n :     will look something like this:                                  :\n :           User: userid - file allocations: ISPPLIB                  :\n :           ISPPLIB  SYS1.SISPPENU                                    :\n :                    SYS1.SISFPLIB                                    :\n :                                                                     :\n : 3.  From another exec, to find what's allocated to ISPMLIB use      :\n :     something like this:                                            :\n :           x = Tiot('ISPMLIB')                                       :\n :     and the variable x will contain something like this:            :\n :           *ISPMLIB* 'SYS1.SISPMENU' 'SYS1.SISFMLIB'                 :\n :                                                                     :\n : 4.  Or, to use it more intelligently use something like this:       :\n :           ddname = 'ISPPLIB'                                        :\n :           placeholder = '*'ddname'*'                                :\n :           Parse Value Tiot(ddname) With (placeholder) dslist        :\n :     and dslist would contain something like this:                   :\n :           'SYS1.SISPPENU' 'SYS1.SISFPLIB'                           :\n :                                                                     :\n : 5.  To get a full list of all allocations and parse them yourself   :\n :     use:                                                            :\n :           y = Tiot()                                                :\n :     and the variable y will contain something like this:            :\n :           *ISPTLIB*  'SYS1.SISPTENU' 'SYS1.SISFTLIB' *SYSIN*        :\n :           'SYS01004.T130908.RA000.MACKEKM.R0579190' *ISPMLIB*       :\n :           'SYS1.SISPMENU' 'SYS1.SISFMLIB'                           :\n :     as one continuous string which you could then parse with:       :\n :           Parse Var dsnlist . '*ISPMLIB*' my_list '*' .             :\n :     and my_list would contain:                                      :\n :           'SYS1.SISPMENU' 'SYS1.SISFMLIB'                           :\n :                                                                     :\n : 6.  To get a full list of all allocations into a table caled RUBBLE :\n :     with the DDname variable set as BARNEY and the DSname variable  :\n :     set as BETTY use:                                               :\n :           TSO TIOT TABLE(RUBBLE BARNEY BETTY)                       :\n :               - or -                                                :\n :           x = TIOT('TABLE(RUBBLE BARNEY BETTY)')                    :\n :                                                                     :\n : 7.  To get a full list of all allocations into a table using the    :\n :     default names of TIOT, DDNAME and DSNAME use:                   :\n :           TSO TIOT TABLE()                                          :\n :               - or -                                                :\n :           x = TIOT('TABLE()')                                       :\n :                                                                     :\n : 8.  To get a list of files allocated to SYSEXEC into a table called :\n :     WONKA with the default variable names of DDNAME & DSNAME use:   :\n :           TSO TIOT TABLE(WONKA) SYSEXEC                             :\n :               - or -                                                :\n :           TSO TIOT SYSEXEC TABLE(WONKA)                             :\n :               - or -                                                :\n :           x = TIOT('TABLE(WONKA)' 'SYSEXEC')                        :\n :               - or -                                                :\n :           x = TIOT('SYSEXEC' 'TABLE(WONKA)')                        :\n ---------------------------------------------------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BODY": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01 \\x06\\x0f\\x01 \\x06\\x0f\\t\\x16\\x00\\x8b\\x00\\x8b\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-02-29T00:00:00", "modifydate": "2020-02-29T09:16:56", "lines": 139, "newlines": 139, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "CAVXTR$": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\"\\x01\\x02\\x04_\\x01\\x03\\x15?\\x08\\'\\x00M\\x00,\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2002-02-14T00:00:00", "modifydate": "2003-06-02T08:27:22", "lines": 77, "newlines": 44, "modlines": 0, "user": "SYSLBD"}, "text": "CAVXTRT - CA-View Extract ISPF Dialog\n\nThis dialog is intended as a more user friendly interface to the CA-View\nreports. The options available with this dialog are:\n\n    - Browse a report (using ISPF Browse)\n    - View a report (using ISPF View)\n    - Copy a report to a dataset\n    - Mail a report (using XMITIP)\n    - Print a report\n    - Transfer a report to a workstation\n    - Load a report from CA-View tape to CA-View disk\n\nThis code has been tested on OS/390 2.10 and z/OS 1.3 with CA-View 2.0\nand is dependent upon the report format generated by SARBCH with the\n/LIST statement. If this report format changes then the code which\nparses the report will have to be changed.\n\n        Syntax:    %cavxtrt option(s)\n\n                   Valid Options:\n                   database - invoke using this specified\n                              CA-View database\n                   /CA     - Invoke the Computer Associates\n                             CA-View ISPF Interface for all\n                             selections.\n                   /LAST   - Use the last CA-View Database\n                             and bypass the database prompt\n\nInstallation:\n\n1. Execute the RECEIVE member of this dataset to expand the EXEC and\n   PANELS members into partitioned datasets.\n\n   e.g.   from ISPF 3.4 on the line where this dataset is\n          ex /(receive)\n\n   This command will also build a member in this dataset called\n   TRYEXEC which can be executed to test out this exec.\n\n2. Update SYS1.PARMLIB member IKJTSOxx for each LPAR to add SARBCH to\n   the AUTHPGM section.  After doing the update you can dynamically\n   implement the change by entering from TSO on each LPAR:\n\n           PARMLIB UPDATE(xx)\n\n3. Customization required\n   The customizations are required in the CAVXTRTD Rexx Exec. This\n   exec must be customized for your environment before use.\n\n   After customization use the TESTCAVX Rexx exec to validate your\n   changes.\n\n   At this point you can try it out by using the TRYEXEC that was\n   created during the RECEIVE process.\n\n   e.g.   from ISPF 3.4 on the line where the install dataset is:\n          ex /(tryexec)\n\n4. Copy the libraries created in (1) into appropriate libraries in your\n   normal TSO/ISPF concatenation.\n\n5. Enter the exec from any ISPF Panel by entering TSO %CAVXTRT\n\nSee the member ANNSAMP for a sample user announcement.\n\nThis code is provided as is, with no warranty or recourse should it\nnot function in your environment.\n\nComments, suggestions, and complaints should be directed to the author at:\n\n  Lionel B. Dyck\n  Kaiser Permanente Information Technology\n  25 N. Via Monte Ave.\n  Walnut Creek, CA 94598\n  (925) 926-5332\n  Internet: lionel.b.dyck@kp.org\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CAVXTR$$": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00D\\x01\\x02\\x05o\\x01\\x10\\x14\\x1f\\x01$\\x00\\\\\\x00\\x07\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2002-02-25T00:00:00", "modifydate": "2010-05-21T01:24:44", "lines": 92, "newlines": 7, "modlines": 0, "user": "SYSLBD"}, "text": "Change History for the CAVXTRT application:\n\n  Version   Date     Details\n  1.26      03/24/10 - Update from Lane Thorne to handle CA-View 11.x\n  1.25      12/04/07 - Corrections to the support for release 11 to\n                       support a more generalized parse of the report\n  1.24      05/14/07 - Update to support both old and new release 11\n                       of CA-View (thanks to Andy White of MetLife)\n                     - Updated distribution library with more doc and\n                       members CAVR11 and CAVR20 to help with planning\n                       local support if the report format changes for\n                       CA-View\n  1.23      07/27/05 - Correction to parsing for dloc and prtlines\n                       for files with a lot of lines\n                     - Change space allocation for very large files for\n                       the work file to use 1/2 of the estimated space\n                       for the primary and also for the secondary.\n  1.22      05/05/04 - Change to allow use in multiple ISPF Sessions\n  1.21      09/09/03 - Change allocation for DD CAVXTRT (used for\n                       extracted file to:\n                       - reduce the primary to 1/2 estimate\n                       - increase secondary\n                       - add unit count (UCOUNT) of 4 to help ensure\n                         the space will be found for large files\n                         only if the primary space is > 1000 tracks\n  1.20      07/08/03 - Correct Jobname in submit message for REORG jobs\n  1.19      06/16/03 - Add Administration authorization via\n                       test of RACF default-group in CAVXTRTD\n                     - If Admin and only a single data base still display\n                       the data base selection table to allow the\n                       R, V, VF options\n                     - Support Sort order\n                       e.g. sort column,order\n                       where order is A (ascend) or D (descend)\n                     - Improve table display for redisplay on\n                       data base display\n                     - Add REORG data base selection option to submit\n                       a batch reorg asynch\n                       - requires ADMIN\n                     - Add report Delete option\n                     - enhanced appropriate panels for new options\n                     - change V to stats and add VF for stats full\n                       on the data base selection panel\n                     - moved 1st jobcard setup to CAVXTRTD\n                     * Elements changed:\n                       EXECs:  CAVXTRT, CAVXTRTD, TESTCAVX\n                       Panels: CAVXTRT, CAVXTRTD, CAVXTRTL, CAVXTRT1, CAVXTRT2\n                               CAVXTRT3\n  1.18      06/02/03 - Change to add data base selection option of V to\n                       display data base usage statistics\n                     * exec changes:  CAVXTRT\n                     * panel changes: CAVXTRT3\n  1.17      01/08/03 - Change to fix REFRESH which was failing on 2nd usage\n                     * exec changes CAVXTRT\n  1.16      01/06/03 - Update to allow Sort on ARCHDATE to sort correctly\n                       using the date and the time\n                     * exec changes CAVXTRT\n  1.15      11/21/02 - Allow TODATE of TODAY (which was the default)\n                     * exec changes CAVXTRT\n                     * panel changes CAVXTRT\n  1.14      10/29/02 - Add TIME to JOB card statement\n                     * exec CAVXTRT changed\n  1.13      09/30/02 - Add option to Sort column on Report Table display\n                     * exec CAVXTRT changed\n                     * panel changes CAVXTRTH, CAVXTRTL, CAVXTRT1, CAVXTRT2\n  1.12      06/18/02 - Make sure the work data sets are deleted for all\n                       situations\n                     - Changed popup panel CAVXTRTW to show print lines\n  1.11c     04/18/02 - Change Panel CAVXTRTD to give more room for description\n  1.11b     04/15/02 - Change Panel CAVXTRTH to show proper release\n  1.11a     03/13/02 - allow selection of S (same as B)\n                     * panel changes\n                       - CAVXTRTL: test for S and change to B\n                       - CAVXTRT2: add option of S\n  1.11      03/11/02 - set suffix for temp d/s to .CAV\n                     - fix if user prefix is null\n                     - translate the database dsns to upper case when\n                       adding them to the table\n  1.10      02/28/02 - Fix job class error on second plus Loads\n                     - Fix to delete temp datasets before allocation\n  1.9       02/28/02 - Add diagnostic report for sarbch rc>0\n  1.8       02/26/02 - Change /PRINT to /LOAD which eliminates the banner\n                       pages in the report.\n  1.7       02/26/02 - Fix missing end statement and add display\n                       save/restore for do_mail routine.\n  1.6       02/25/02 - Split local customization from CAVXTRT into\n                       separate CAVXTRTD Rexx Exec.\n                     - Created TESTCAVX Exec to test local customizations.\n                     - Fixed several minor bugs with /LAST and Refresh\n                     - Updated all the tutorial panels\n  1.5       02/25/02 - Correct work dataset allocations if the userid\n                       does not match the active profile prefix.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CAVXTR#": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x01\\x10\\x14\\x1f\\x01\\x10\\x14\\x1f\\x01&\\x08 \\x08 \\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2010-05-21T00:00:00", "modifydate": "2010-05-21T01:26:00", "lines": 2080, "newlines": 2080, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "CAVXTR@": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x01\\x10\\x14\\x1f\\x01\\x10\\x14\\x1f\\x01&\\x08-\\x08-\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2010-05-21T00:00:00", "modifydate": "2010-05-21T01:26:00", "lines": 2093, "newlines": 2093, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "CAVXTRT": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x16\\x01\\x10\\x14\\x1f\\x01\\x19\\x02?\\x06\\x12\\n\\xa5\\n\\xa1\\x00\\x00\\xc3\\xc1\\xe5@@@@@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2010-05-21T00:00:00", "modifydate": "2019-01-23T06:12:16", "lines": 2725, "newlines": 2721, "modlines": 0, "user": "CAV"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "CHKIKJ": {"ttr": 4358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x07\\x01\\x161\\x1f\\x01\\x17\\x16o\\x12(\\x03\\xd1\\x016\\x00\\x00\\xd3\\xc2\\xc4@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2016-11-06T00:00:00", "modifydate": "2017-06-15T12:28:07", "lines": 977, "newlines": 310, "modlines": 0, "user": "LBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "CHKLPALK": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x162\\x8f\\x01\\x162\\x8f\\x06Q\\x00Z\\x00Z\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-23T00:00:00", "modifydate": "2016-11-23T06:51:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "SYSLBD"}, "text": "/* ---------------------  rexx procedure  ---------------------- */\n\nparse value \"\" with null dsn. lpa. lpaflag\n\ndsn.0 = 11\ndsn.1 = \"-----LPA and LINKLIST Report-----\"\ndsn.2 = \"   \"\ndsn.3 = \"System:\" mvsvar('sysname')  \"Date:\" date('u') time()\ndsn.4 = \"   \"\ndsn.5 = \">  **2** indicates a Secondary Allocation\"\ndsn.6 = \">  Ext: xx indicates using xx extents\"\ndsn.7 = \">  lpa: if link list data set also in lpa\"\ndsn.8 = \"   \"\ndsn.9 = \"System LPA List\"\ndsn.10 = \"---------------------------------------------------------\"\ndsn.11 = left(\"Data Set Name\",50) \"Volser\"\n\n/* REXX - List the current LPALST */\n@CVT    = STORAGE(10,4)                      /* L R1,CVTPTR             */\n@SMEXT  = STORAGE(D2X(C2D(@CVT)+1196),4)     /* L R1,CVTSMEXT-CVTMAP(R1 */\n@EPLPS  = STORAGE(D2X(C2D(@SMEXT)+56),4)     /* L R1,CVTEPLPS-CVTVSTGX( */\nLPAC    = C2D(STORAGE(D2X(C2D(@EPLPS)+4),4)) /* L R1,LPATCNT(R1)     */\n@EPLPS  = D2X(C2D(@EPLPS)+8)                 /* LA R1,LPATNTRY(R1)      */\ndo i = 1 TO LPAC\n   ddw = STORAGE(D2X(X2D(@EPLPS)+1),44)\n   c = dsn.0 + 1\n   dsn.c = strip(ddw)\n   dsn.0 = c\n   lpa.c = strip(ddw)\n   lpa.0 = c\n   call listdsi \"'\"dsn.c\"'\"\n   ext = \"\"\n   sec = \"     \"\n   if sysseconds > 0 then sec = \"**2**\"\n   if sysextents > 1 then ext = \"Ext:\" sysextents\n   dsn.c = left(dsn.c,50) sysvolume sec ext\n   @EPLPS = D2X(X2D(@EPLPS)+45)              /* Bump to next 45 byte ent*/\n   end\n\nc = dsn.0 + 1\ndsn.c = \"   \"\nc = c + 1\ndsn.c = \"System LINK List\"\nc = c + 1\ndsn.c = \"---------------------------------------------------------\"\nc = c + 1\ndsn.c = left(\"Data Set Name\",50) \"Volser\"\ndsn.0 = c\n\nlnkext = 0\n\n/* REXX - List the current LNKLST */\n@CVT    = STORAGE(10,4)                     /* L R1,CVTPTR             */\n@LLTA   = STORAGE(D2X(C2D(@CVT)+1244),4)    /* L R1,CVTLLTA-CVTMAP(R1) */\nLNKC    = C2D(STORAGE(D2X(C2D(@LLTA)+4),4)) /* L R1,LLTCOUNT(R1)     */\n@LLTA   = D2X(C2D(@LLTA)+8)                 /* LA R1,LLTENTRY(R1)      */\ndo i = 1 TO LNKC\n   ddw = storage(d2x(x2d(@llta)+1),44)\n   c = dsn.0 + 1\n   call test_lpa strip(ddw)\n   dsn.c = strip(ddw)\n   dsn.0 = c\n   call listdsi \"'\"dsn.c\"'\"\n   ext = \"\"\n   sec = \"     \"\n   if sysseconds > 0 then sec = \"**2**\"\n   if sysextents > 1 then ext = \"Ext:\" sysextents\n   lnkext = lnkext + sysextents\n   call test_lpa strip(ddw)\n   dsn.c = left(dsn.c,50) sysvolume sec ext lpaflag\n   @LLTA = D2X(X2D(@LLTA)+45)               /* Bump to next 45 byte ent*/\n   end\n\n  do i = 1 to dsn.0\n     say dsn.i\n     end\n\n  say \" \"\n  say \"Total Linklist Extents:\" lnkext\n\nexit 0\n\nTest_lpa:\narg linkdsn\ndo n = 1 to lpa.0\n   if linkdsn = lpa.n then lpaflag = \"lpa\"\n   return\n   end\nlpaflag = null\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHKPDSE": {"ttr": 4868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x161\\x1f\\x01\\x161O\\x077\\x00C\\x004\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf1\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-06T00:00:00", "modifydate": "2016-11-09T07:37:17", "lines": 67, "newlines": 52, "modlines": 0, "user": "FILE312"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      chkpdsem                                        *\n *                                                            *\n * Function:  Utility to run under ISPF (foreground or batch) *\n *            to report on all datasets that are PDSE V2      *\n *            with maxgen > 0                                 *\n *                                                            *\n * Syntax:    %chkpdsem volser                                *\n *                                                            *\n * Dependencies:                                              *\n *            1. The VTOC TSO Command for the list of dsns    *\n *               on the volume                                *\n *            2. ISPF services                                *\n *            2. Only checks cataloged datasets               *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            07/19/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n arg volser\n\n if strip(volser) = '' then do\n    say 'CHKPDSEM requires a volser to process.'\n    say 'Try again .....'\n    exit 16\n    end\n\n if sysvar('sysispf') /= 'ACTIVE' then do\n    say 'CHKPDSEM must be run under ISPF, foreground or batch'\n    say 'Try again .....'\n    exit 16\n    end\n\n call outtrap 'vtoc.'\n 'vtoc' volser 'print(new (dsname volume dso rfm))'\n call outtrap 'off'\n\n say 'Check for PDSE Version 2 with Maxgen > 0' date() time()\n say ' '\n say 'Checking on Volser:' volser\n say ' '\n say left('Dataset',46) 'MaxGen'\n say left('-',44,'-') '  ------'\n\n count = 0\n\n Address ISPExec\n\n do i = 2 to vtoc.0\n    if word(vtoc.i,1) = 'TOTAL' then leave\n    parse value vtoc.i with dsn volume dsorg recfm .\n    if dsorg /= 'PE' then iterate\n    if strip(recfm) = '' then iterate\n    if recfm = 'U' then iterate\n    \"DSINFO dataset('\"dsn\"')\"\n    if zdsngen > 0 then do\n       say left(dsn,46) strip(zdsngen)\n       count = count + 1\n       end\n    end\n\n Say ' '\n say 'Processing completed - ' count 'datasets found with maxgen > 0'\n\n Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLONE": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x161?\\x01\\x161?\\tV\\x01\\xab\\x01\\xab\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-08T00:00:00", "modifydate": "2016-11-08T09:56:22", "lines": 427, "newlines": 427, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "CMDS": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x00\\x04\\x7f\\x01\\x00\\x04\\x7f\\x16'\\x02L\\x02L\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-16T00:00:00", "modifydate": "2000-02-16T16:27:00", "lines": 588, "newlines": 588, "modlines": 0, "user": "SYSLBD"}, "text": "./ ADD NAME=$README  0101-00047-00047-1626-00020-00020-00000-SBGOLOB\nThis data set contains an ISPF Dialog that simplifies the processing\nof the ISPF command tables.\n\nMembers:\n\n   CMDSA     ISPF Panel\n   CMDSB     ISPF Panel\n   CMDS00    ISPF Messages\n   CMDS      ISPF REXX Procedure\n\nThe entry to this dialog is via the CMDS REXX Procedure.\n\nTo use this dialog you will also have to create an ISPF Command\nTable of the name CMDSCMDS.  Enter ISPF 3.9 and enter CMDS as the\nApplication ID and then create a single row like the following:\n\n            Verb      T  Action\n                            Description\n       '''' RFIND     0  PASSTHRU\n                            REPEAT FIND\n./ ADD NAME=CMDS     0104-95006-97112-1541-00469-00469-00000-SYSLBD\n        /**** Rexx Procedure ***************************************************\n        *                                                                      *\n        * ISPF Commands Table Utility                                          *\n        *                                                                      *\n        * This utility is an alternative to ISPF/PDF option 3.9.               *\n        * It supports all the function of option 3.9 plus the following:       *\n        *  (1) Any application ID may be specified, even a currently active    *\n        *      one (including ISP and ISR) -- if a table for an active         *\n        *      application is changed, it is stored on DASD, but the active    *\n        *      copy is not affected;                                           *\n        *  (2) The application ID defaults to the currently active one;        *\n        *  (3) The output table library may be specified (the default is the   *\n        *      data set currently allocated to ISPTABL;                        *\n        *  (4) The following additional commands are supported:                *\n        *      (a) FIND finds a character string within the verb, action or    *\n        *          description fields;                                         *\n        *      (b) LOCATE positions the display by verb;                       *\n        *      (c) RFIND repeats the FIND action;                              *\n        *      (d) SORT sorts by verb, except that all aliases are sorted at   *\n        *          the beginning of the commands table (aliases must precede   *\n        *          the commands they reference) -- the order of duplicate      *\n        *          verbs is preserved.                                         *\n        *                                                                      *\n        * Additional members required:                                         *\n        * Msgs:   CMDS00                                                       *\n        * Panels: CMDSA, CMDSB                                                 *\n        * Tables: CMDSCMDS                                                     *\n        *                                                                      *\n        * Douglas H. Adams                                                     *\n        * Mail code 110-SH28                                                   *\n        * Rockwell International Corporation                                   *\n        * 2201 Seal Beach Boulevard                                            *\n        * P. O. Box 2515                                                       *\n        * Seal Beach, California 90740-1515                                    *\n        *                                                                      *\n        * (213) 797-2618                                                       *\n        *                                                                      *\n        * September 19, 1990                                                   *\n        *                                                                      *\n        ***********************************************************************/\n\n        Signal on novalue\n        Signal on syntax\n        Address ISPEXEC\n        \"CONTROL ERRORS RETURN\"\n        \"VGET (ZAPPLID ZSCREEN)\"\n        File = \"CMDS\"zscreen\n        Sort = \"SORT\"zscreen\n\n        /***********************************************************************\n        * Invoke recursively to use application commands table for RFIND       *\n        ***********************************************************************/\n        Arg applid\n        If applid == \"\"\n        Then do\n           \"SELECT CMD(%CMDS\" zapplid\") NEWAPPL(CMDS) PASSLIB\"\n           Exit 0\n           End\n\n        /***********************************************************************\n        * Display command table selection panel                                *\n        ***********************************************************************/\n        Call listdsi \"ISPTABL FILE\"\n        Tabledsn = \"'\"sysdsname\"'\"\n        \"DISPLAY PANEL(CMDSA)\"\n        Do while rc = 0\n           Applcmds = applid\"CMDS\"\n           Appltemp = applid\"TEMP\"\n           Address TSO \"ALLOCATE FILE(\"file\") DATASET(\"tabledsn\") SHR REUSE\"\n           If rc = 0\n           Then do\n              Call build\n              If result = 0\n              Then call commands\n              \"TBSTATS DUMMY LIBRARY(DUMMY)\"\n              Address TSO \"FREE FILE(\"file\")\"\n              End\n           \"DISPLAY PANEL(CMDSA)\"\n           End\n        Exit 0\n\n        /***********************************************************************\n        * Alias resolution                                                     *\n        ***********************************************************************/\n        Alias: procedure expose appltemp\n\n        \"TBGET\" appltemp \"ROWID(ROWID)\"\n        Parse var zctact action zctverb .\n        Do level = 1 by 1 until action \u00ac== \"ALIAS\" | rc \u00ac= 0\n           \"TBTOP\" appltemp\n           \"TBSCAN\" appltemp \"ARGLIST(ZCTVERB)\"\n           Parse var zctact action zctverb .\n           End level\n        \"TBSKIP\" appltemp \"ROW(\"rowid\") NOREAD\"\n        Return level\n\n        /***********************************************************************\n        * Build temporary command table                                        *\n        ***********************************************************************/\n        Build:\n\n        \"TBCREATE\" appltemp \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\",\n                 \"LIBRARY(\"file\")\"\n        If rc \u00ac= 0\n        Then do\n           \"SETMSG MSG(CMDS003)\"\n           Return 8\n           End\n        Rowcurr = 0\n        \"TBSTATS\" applcmds \"STATUS1(STATUS1) STATUS2(STATUS2)\",\n                 \"ROWCURR(ROWCURR)\"\n        Exist? = status1 = 1\n        Closed? = status2 = 1\n        If \u00ac exist? | rowcurr = 0\n        Then do\n           Zctverb = copies(\"_\",8)\n           Zcttrunc = \"_\"\n           Zctact = copies(\"_\",60)\n           Zctdesc = copies(\"_\",57)\n           \"TBADD\" appltemp\n           End\n        Else do\n           If closed?\n           Then \"TBOPEN\" applcmds \"NOWRITE\"\n           \"TBTOP\" applcmds\n           Do rowcurr\n              \"TBSKIP\" applcmds\n              \"TBADD\" appltemp \"MULT(\"rowcurr\")\"\n              End\n           If closed?\n           Then \"TBEND\" applcmds\n           End\n        \"TBTOP\" appltemp\n        Return 0\n\n        /***********************************************************************\n        * Command Processing                                                   *\n        ***********************************************************************/\n        Commands:\n\n        Parse value \"0\" with csrpos cursor zverb verb operand\n        Changed? = 0\n        \"TBDISPL\" appltemp \"PANEL(CMDSB) POSITION(CRP)\"\n        Do while rc < 8\n           If crp = 0\n           Then crp = ztdtop\n           \"VGET (ZVERB ZSCROLLN)\"\n           Do ztdsels\n              Changed? = 1\n              Parse upper var sel linecmd +1 number\n              If number == \"\"\n              Then number = 1\n              Select\n                 When linecmd == \"D\" then call delete\n                 When linecmd == \"I\" then call insert\n                 When linecmd == \"R\" then call repeat\n                 Otherwise                call update\n                 End\n              If ztdsels > 1\n              Then \"TBDISPL\" appltemp\n              End\n           \"TBTOP\" appltemp\n           \"TBSKIP\" appltemp \"NUMBER(\"ztdtop\")\"\n           Select\n              When verb  == \"CANCEL\" then leave\n              When zverb == \"DOWN\"   then call down\n              When verb  == \"FIND\"   then call find\n              When verb  == \"LOCATE\" then call locate\n              When verb  == \"RFIND\"  then call rfind\n              When verb  == \"SORT\"   then call sort\n              When zverb == \"UP\"     then call up\n              Otherwise nop\n              End\n           \"TBDISPL\" appltemp \"PANEL(CMDSB) CURSOR(\"cursor\") CSRROW(\"crp\")\",\n                   \"CSRPOS(\"csrpos\") AUTOSEL(NO) POSITION(CRP)\"\n\n           End\n        Call end\n        Return 0\n\n        /***********************************************************************\n        * Delete command                                                       *\n        ***********************************************************************/\n        Delete:\n\n        Do number\n           \"TBDELETE\" appltemp\n           \"TBSKIP\" appltemp \"NOREAD\"\n           End\n        If ztdsels = 1\n        Then crp = max(crp-1,0)\n        Return 0\n\n        /***********************************************************************\n        * Down command                                                         *\n        ***********************************************************************/\n        Down:\n\n        \"TBSKIP\" appltemp \"NUMBER(\"zscrolln\") NOREAD\"\n        If rc \u00ac= 0\n        Then \"TBBOTTOM\" appltemp \"NOREAD\"\n        Return 0\n\n        /***********************************************************************\n        * End command                                                          *\n        ***********************************************************************/\n        End:\n\n        If verb == \"CANCEL\" | \u00ac changed?\n        Then do\n           \"TBEND\" appltemp\n           Return 0\n           End\n        \"TBTOP\" appltemp\n        \"TBSKIP\" appltemp\n        Do while rc = 0\n           If translate(zctverb,\" \",\"_\") = \"\"\n           Then \"TBDELETE\" appltemp\n           \"TBSKIP\" appltemp\n           End\n        \"TBQUERY\" appltemp \"ROWNUM(ROWNUM)\"\n        If rownum = 0\n        Then do\n           \"TBERASE\" applcmds \"LIBRARY(\"file\")\"\n           \"TBEND\" appltemp\n           End\n        Else do\n           \"TBQUERY\" appltemp \"ROWNUM(CURSIZE)\"\n           Cursize = format(cursize)\n           Moddate = date(\"Ordered\")\n           Modtime = substr(time(\"Normal\"),1,5)\n           User = sysvar(\"SYSUID\")\n           \"TBCLOSE\" appltemp \"NAME(\"applcmds\") LIBRARY(\"file\")\"\n           \"LMINIT DATAID(DATAID) DDNAME(\"file\")\"\n           \"LMMSTATS DATAID(\"dataid\") MEMBER(\"applcmds\") MODDATE(\"moddate\")\",\n                    \"MODTIME(\"modtime\") CURSIZE(\"cursize\") INITSIZE(\"cursize\")\",\n                    \"USER(\"user\")\"\n           \"LMFREE DATAID(\"dataid\")\"\n           End\n        \"SETMSG MSG(CMDS002)\"\n        Return 0\n\n        /***********************************************************************\n        * Find command                                                         *\n        ***********************************************************************/\n        Find:\n\n        \"TBGET\" appltemp\n        Csrpos = 1\n        Cursor = \"\"\n        Call search\n        Save_operand = operand\n        Save_crp = crp\n        Save_csrpos = csrpos\n        Save_cursor = cursor\n        Return 0\n\n        /***********************************************************************\n        * Insert command                                                       *\n        ***********************************************************************/\n        Insert:\n\n        Call update\n        Zctverb = copies(\"_\",8)\n        Zcttrunc = \"_\"\n        Zctact = copies(\"_\",60)\n        Zctdesc = copies(\"_\",57)\n        Do number\n           \"TBADD\" appltemp \"MULT(\"number\")\"\n           End\n        If ztdsels = 1\n        Then crp = crp+1\n        Return 0\n\n        /***********************************************************************\n        * Locate command                                                       *\n        ***********************************************************************/\n        Locate:\n\n        Zctverb = operand\"*\"\n        \"TBSCAN\" appltemp \"ARGLIST(ZCTVERB) NOREAD POSITION(CRP)\"\n        If rc \u00ac= 0\n        Then do\n           \"TBTOP\" appltemp\n           \"TBSCAN\" appltemp \"ARGLIST(ZCTVERB) NOREAD POSITION(CRP)\"\n           End\n        If rc = 0\n        Then \"TBSKIP\" appltemp \"NUMBER(-1)\"\n        Return 0\n\n        /***********************************************************************\n        * Repeat command                                                       *\n        ***********************************************************************/\n        Repeat:\n\n        Call update\n        Do number\n           \"TBADD\" appltemp \"MULT(\"number\")\"\n           End\n        If ztdsels = 1\n        Then crp = crp+1\n        Return 0\n\n        /***********************************************************************\n        * Rfind command                                                        *\n        ***********************************************************************/\n        Rfind:\n\n        If symbol(\"save_operand\") \u00ac== \"VAR\"\n        Then do\n           \"SETMSG MSG(CMDS004)\"\n           Return 4\n           End\n        Operand = save_operand\n        If crp = save_crp\n        Then do\n           Cursor = save_cursor\n           Csrpos = save_csrpos+1\n           End\n        Else do\n           Cursor = \"\"\n           Csrpos = 1\n           End\n        Call search\n        Save_crp = crp\n        Save_cursor = cursor\n        Save_csrpos = csrpos\n        Return 0\n\n        /***********************************************************************\n        * Search for character string                                          *\n        ***********************************************************************/\n        Search:\n\n        Operand = strip(operand,\"Both\",\"'\")\n        Operand = strip(operand,\"Both\",\"\"\"\")\n        If operand = \"\"\n        Then do\n           \"SETMSG MSG(CMDS000)\"\n           Return 0\n           End\n        Select\n           When cursor == \"ZCTVERB\"\n           Then do\n              Pos_verb = pos(operand,zctverb,csrpos)\n              Pos_act = pos(operand,zctact)\n              Pos_desc = pos(operand,zctdesc)\n              End\n           When cursor == \"ZCTACT\"\n           Then do\n              Pos_verb = 0\n              Pos_act = pos(operand,zctact,csrpos)\n              Pos_desc = pos(operand,zctdesc)\n              End\n           When cursor == \"ZCTDESC\"\n           Then do\n              Pos_verb = 0\n              Pos_act = 0\n              Pos_desc = pos(operand,zctdesc,csrpos)\n              End\n           Otherwise\n              Pos_verb = pos(operand,zctverb)\n              Pos_act = pos(operand,zctact)\n              Pos_desc = pos(operand,zctdesc)\n           End\n        Do while rc = 0 & pos_verb = 0 & pos_act = 0 & pos_desc = 0\n           \"TBSKIP\" appltemp \"POSITION(CRP)\"\n           Pos_verb = pos(operand,zctverb)\n           Pos_act = pos(operand,zctact)\n           Pos_desc = pos(operand,zctdesc)\n           End\n        Select\n           When rc = 0 & pos_verb \u00ac= 0\n           Then do\n              Cursor = \"ZCTVERB\"\n              Csrpos = pos_verb\n              End\n           When rc = 0 & pos_act \u00ac= 0\n           Then do\n              Cursor = \"ZCTACT\"\n              Csrpos = pos_act\n              End\n           When rc = 0 & pos_desc \u00ac= 0\n           Then do\n              Cursor = \"ZCTDESC\"\n              Csrpos = pos_desc\n              End\n           Otherwise do\n              Cursor = \"\"\n              Csrpos = 0\n              \"SETMSG MSG(CMDS001)\"\n              \"TBTOP\" appltemp\n              \"TBSKIP\" appltemp \"NUMBER(\"ztdtop\") POSITION(CRP)\"\n              End\n           End\n        Return 0\n\n        /***********************************************************************\n        * Sort command                                                         *\n        ***********************************************************************/\n        Sort:\n\n        \"TBCREATE\" sort \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC LEVEL ORDER)\",\n                 \"REPLACE LIBRARY(\"file\")\"\n        \"TBSORT\" sort \"FIELDS(LEVEL,N,D ZCTVERB,C,A ORDER,C,A)\"\n        \"TBQUERY\" appltemp \"ROWNUM(ROWNUM)\"\n        \"TBTOP\" appltemp\n        Do rownum\n           \"TBSKIP\" appltemp \"POSITION(ORDER)\"\n           Parse var zctact action .\n           If action == \"ALIAS\"\n           Then level = alias()\n           Else level = 0\n           \"TBADD\" sort \"ORDER MULT(\"rownum\")\"\n           End\n        \"TBTOP\" sort\n        \"TBEND\" appltemp\n        \"TBCREATE\" appltemp \"NAMES(ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)\",\n                 \"LIBRARY(\"file\")\"\n        Do rownum\n           \"TBSKIP\" sort\n           \"TBADD\" appltemp \"MULT(\"rownum\")\"\n           End\n        \"TBEND\" sort\n        \"TBTOP\" appltemp\n        Changed? = 1\n        Return 0\n\n        /***********************************************************************\n        * Up command                                                           *\n        ***********************************************************************/\n        Up:\n\n        \"TBSKIP\" appltemp \"NUMBER(\"||-zscrolln\")\"\n        Return 0\n\n        /***********************************************************************\n        * Update selected row                                                  *\n        ***********************************************************************/\n        Update:\n           Zctverb = translate(zctverb,\" \",\"_\")\n           Zcttrunc = translate(zcttrunc,\" \",\"_\")\n           Zctact = translate(zctact,\" \",\"_\")\n           Zctdesc = translate(zctdesc,\" \",\"_\")\n           \"TBPUT\" appltemp\n        Return 0\n\n        /***********************************************************************\n        * Trap uninitialized variables                                         *\n        ***********************************************************************/\n        Novalue:\n\n        Say \"Uninitialized variable in line\" sigl\":\"\n        Say sourceline(sigl)\n        Trace \"?Results\"\n        Nop\n        Exit 16\n\n        /***********************************************************************\n        * Trap syntax errors                                                   *\n        ***********************************************************************/\n        Syntax:\n\n        Say \"REXX error\" rc \"in line\" sigl\":\"\n        Say sourceline(sigl)\n        Say errortext(rc)\n        Trace \"?Results\"\n        Nop\n        Exit\n./ ADD NAME=CMDSA    0101-90172-90312-0752-00040-00031-00000-$A1238\n%-------------------------  Command Table Utility  -----------------------------\n%Command ===>_ZCMD                                                             +\n%                                                                              +\n+  Application ID       %===>_Z   +                                            +\n+  Output table library %===>_TABLEDSN                                         +\n+\n+\n+The name of the command table to be processed is formed by prefixing\n+the application id to the string 'CMDS'.  For example:\n+  Application ID ===> TST\n+results in a command table name of 'TSTCMDS'.\n+\n+This utility allows you to examine or modify any command table, even those\n+for currently active application IDs (including ISP and ISR).  If a command\n+table is modified, it will be stored in the above \"output table library\".\n+\n+If you sort the table, aliases will be grouped together at the beginning of\n+the table, since they must precede the commands they reference.\n+The order of duplicate verbs will be maintained.\n)Init\n  .ZVARS = '(APPLID)'\n  &ZCMD = &Z\n  If (&ZHTOP = ISR00003)\n    .HELP = ISR39000\n  Else\n    .HELP = ISP39000\n  .CURSOR = APPLID\n)Proc\n  If (.RESP = ENTER)\n    If (&ZVERB \u00ac= ' ')\n      .MSG = ISPZ002\n    Else\n      IF (&ZCMD \u00ac= ' ')\n        .MSG = ISPZ001\n  Ver (&APPLID,nonblank,name,msg=ISPU340)\n  &APPLID = trunc(&APPLID,4)\n  If (.TRAIL \u00ac= ' ')\n    .MSG = ISPU333\n  Ver (&TABLEDSN,nonblank,dsname)\n)End\n./ ADD NAME=CMDSB    0104-90172-94350-0715-00044-00037-00000-SYSLBD\n)Attr\n \u00ac Type(input) intens(high) pad('''') caps(on)\n $ Type(input) intens(high) caps(on)\n \u00a2 Type(input) intens(low) caps(off)\n | Type(text) intens(high) color(blue)\n \u00a6 Type(text) intens(low) hilite(uscore) color(blue)\n)Body\n%Command Table - &APPLID ------------------------------------------------------+\n%Command ===>_ZCMD                                            %Scroll ===>_SCIN+\n%                                                                              +\n+Commands:     %Cancel, End, Find, Locate, Rfind, Sort                         +\n+Line commands:%Dn = Delete, In = Insert, Rn = Repeat\n+                                                                              +\n|     Verb      T  Action                                                      +\n\u00a6                     Description                                              +\n)Model\n\u00acZ   $Z       +$Z+$Z                                                           +\n                     \u00a2Z                                                        +\n)Init\n  .ZVARS = '(SEL ZCTVERB ZCTTRUNC ZCTACT ZCTDESC)'\n  If (&ZHTOP = ISR00003)\n    .HELP = ISR39000\n  Else\n    .HELP = ISP39000\n  If (&SCIN = &Z)\n      &SCIN = 'CSR'\n  &SEL = &Z\n)Proc\n &VERB = trunc(&ZCMD,' ')\n &OPERAND = .TRAIL\n &VERB = trans(trunc(&VERB,1) C,CANCEL E,END F,FIND L,LOCATE R,RFIND S,SORT)\n Ver (&VERB,list,CANCEL,END,FIND,LOCATE,RFIND,SORT)\n If (&ZTDSELS \u00ac= '0000')\n    &TEST = trunc(&SEL,1)\n    &TRAIL = .TRAIL\n    Ver (&TEST,list,D,I,R)\n    Ver (&TRAIL,num)\n    If (&TEST \u00ac= 'D')\n       &ZCTVERB = trunc(&ZCTVERB,'_')\n       Ver (&ZCTTRUNC,num)\n       If (&ZCTTRUNC \u00ac= '0')\n          Ver (&ZCTTRUNC,range,2,8)\n VPUT (SCIN) PROFILE\n)End\n./ ADD NAME=CMDS00   0104-90176-90263-1322-00010-00004-00000-$A1019\nCMDS000 'String missing' .ALARM = YES\n'The FIND/RFIND command requires a target string.\nCMDS001 '&OPERAND not found' .ALARM = YES\n'&OPERAND not found in verb, action, or description'\nCMDS002 '&APPLID.CMDS saved'\n'Commands table &APPLID.CMDS saved in &TABLEDSN'\nCMDS003 '&APPLID not available'\n'Commands table for &APPLID is in use on another screen'\nCMDS004 'Enter a FIND command'\n'The RFIND key works only after a FIND command character string is entered.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDSRPT": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00%\\x01\\x16\\x07\\x7f\\x01\\x16\\x07\\x7f\\x07G\\x00J\\x00J\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2016-03-17T00:00:00", "modifydate": "2016-03-17T07:47:25", "lines": 74, "newlines": 74, "modlines": 0, "user": "SYSLBD"}, "text": "        /* ------------------------ rexx --------------------------- *\n         * Name:  CMDSRPT                                            *\n         *                                                           *\n         * Function:  Report the specified ISPF Commands Table       *\n         *                                                           *\n         * Syntax:   %CMDSRPT   table-name csv                       *\n         *                                                           *\n         * table-name must end in CMDS (or it isn't a command table) *\n         *                                                           *\n         * csv is optional and may be any non-blank character. If    *\n         * specified then the report will be in CSV format.          *\n         *                                                           *\n         * Notes:                                                    *\n         * 1. The table will be sorted by the verb (aka Command)     *\n         *    before it is reported out                              *\n         * 2. The report will be opened in ISPF Edit                 *\n         * 3. The CSV report file dataset name is a variable which   *\n         *    can be changed in the code                             *\n         * 4. Download the CSV file or e-mail it to open in a        *\n         *    spreadsheet tool.                                      *\n         * --------------------------------------------------------- */\n        arg table csv .\n        if length(table) = 0 then exit 16\n        if right(table,4) /= \"CMDS\" then exit 16\n\n        if csv /= '' then do\n           csv = \"CSV\"\n           csvdsn = \"command.\"table\".csv\"\n           end\n\n        Address ISPExec\n        \"TBTop\" table\n        \"TBSort\" table \"fields(zctverb,c,a)\"\n        cnt = 0\n        if csv /= '' then do\n           cnt = 1\n           t.cnt = \"Verb,Trunc,Action,Description\"\n           end\n        do forever\n          \"TBSkip\" table\n          if rc > 0 then leave\n          if csv = '' then do\n             cnt = cnt + 1\n             t.cnt = left(zctverb,10) left(zcttrunc,3) zctact\n             cnt = cnt + 1\n             t.cnt =  left(' ',14) zctdesc\n             end\n          else do\n               cnt = cnt + 1\n               t.cnt = zctverb','zcttrunc',\"'zctact'\",\"'strip(zctdesc)'\"'\n               end\n          end\n          t.0 = cnt\n\n          Address TSO\n          cmd_dd = \"C\"random()\n          if csv = '' then\n          \"Allocate File(\"cmd_dd\") Reuse Unit(vio) Space(1 1)\" ,\n                   \"CYL Dsorg(ps) Recfm(v b) Lrecl(255)\"\n           else do\n           call outtrap 'x.'\n           \"Del\" csvdsn\n           call outtrap 'off'\n          \"Allocate File(\"cmd_dd\") Reuse Unit(sysallda) Space(1 1)\" ,\n                   \"CYL Dsorg(ps) Recfm(v b) Lrecl(255)\" ,\n                   \"DA(\"csvdsn\")\"\n                   end\n          \"Execio * Diskw\" cmd_dd \"(Stem t. Finis)\"\n          Address ISPExec\n          \"LMinit Dataid(dataid) DDname(\"cmd_dd\")\"\n          \"Edit Dataid(\"dataid\")\"\n          \"LMfree Dataid(\"dataid\")\"\n          Address TSO\n          \"Free File(\"cmd_dd\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDSRPTO": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x01\\x16\\x06/\\x01\\x16\\x06/\\x14P\\x00+\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-03-02T00:00:00", "modifydate": "2016-03-02T14:50:15", "lines": 43, "newlines": 10, "modlines": 0, "user": "SYSLBD"}, "text": "        /* ------------------------ rexx --------------------------- *\n         * Name:  CMDSRPT                                            *\n         *                                                           *\n         * Function:  Report the specified ISPF Commands Table       *\n         *                                                           *\n         * Syntax:   %CMDSRPT   table-name                           *\n         *                                                           *\n         * table-name must end in CMDS (or it isn't a command table) *\n         *                                                           *\n         * Notes:                                                    *\n         * 1. The table will be sorted by the verb (aka Command)     *\n         *    before it is reported out                              *\n         * 2. The report will be opened in ISPF Edit                 *\n         * --------------------------------------------------------- */\n        arg table\n        if length(table) = 0 then exit 16\n        if right(table,4) /= \"CMDS\" then exit 16\n\n        Address ISPExec\n        \"TBTop\" table\n        \"TBSort\" table \"fields(zctverb,c,a)\"\n        cnt = 0\n        do forever\n          \"TBSkip\" table\n          if rc > 0 then leave\n          cnt = cnt + 1\n          t.cnt = left(zctverb,10) left(zcttrunc,3) zctact\n          cnt = cnt + 1\n          t.cnt =  left(' ',14) zctdesc\n          end\n          t.0 = cnt\n\n          Address TSO\n          cmd_dd = \"C\"random()\n          \"Allocate File(\"cmd_dd\") Reuse Unit(vio) Space(1 1)\" ,\n                   \"CYL Dsorg(ps) Recfm(v b) Lrecl(255)\"\n          \"Execio * Diskw\" cmd_dd \"(Stem t. Finis)\"\n          Address ISPExec\n          \"LMinit Dataid(dataid) DDname(\"cmd_dd\")\"\n          \"Edit Dataid(\"dataid\")\"\n          \"LMfree Dataid(\"dataid\")\"\n          Address TSO\n          \"Free File(\"cmd_dd\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMT": {"ttr": 5382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x05\\x00C\\x01\\x161?\\x01\\x161O\\x079\\x05\\x07\\x05)\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf1\\xf2@@@'", "ispf": {"version": "03.05", "flags": 0, "createdate": "2016-11-08T00:00:00", "modifydate": "2016-11-09T07:39:43", "lines": 1287, "newlines": 1321, "modlines": 0, "user": "FILE312"}, "text": "/* --------------------  rexx procedure  ------------------------- *\n * Name:      CMT                         Version 3.5    09/16/16  */\n                                          vernbr=\"3.5\"\n/*                                                                 *\n * Function:  Create a documentation 'box' within the object       *\n *            being edited. The syntax of the comment box          *\n *            is based on the object type which is determined by   *\n *            this REXX or set by the user via the popup panel.    *\n *                                                                 *\n * Syntax1:   Entered on Command line to add comments.             *\n *            CMT I,B,text          (all parameters are optional)  *\n *                                  (and must be separated by a ,) *\n *            I = nbr 1-65, C (Center) or R (Right justify)        *\n *                The number of spaces to Indent added text box    *\n *                or if text should be Centered or Right justified.*\n *                (Default is 0)                                   *\n *            B = V,S,F or blank  (BOXSIZE)                        *\n *                V = uses a Variable box based on longest line    *\n *                F = uses a Fixed box size (70 characters long)   *\n *                S = same as F (Fixed) S = a Set size             *\n *                (See Syntax2 for means to set defaults)          *\n *            Text = optional one line of text to include.         *\n *                (Default displays a popup panel for text entry)  *\n *                (and allows an unlimited number of lines.)       *\n *                                                                 *\n * Syntax2:   Entered on Command line to set/change default values *\n *            CMT SET <parm to set> <parm value>                   *\n *                                                                 *\n *            parm to set: INDENT  or abbrev of (set indent value) *\n *                       : BOXSIZE or abbrev of (set box size)     *\n *                       : CHARIZE or abbrev of (set boxing char)  *\n *            parm value : for INDEND either 1 - 65, C or R        *\n *                         for BOXSIZE either F,S or V             *\n *                       : for CHARIZE any character is valid      *\n *                                                                 *\n * Syntax3:   Entered as Line Command (see NOTE below)             *\n *            CMT        (all parameters default, panel displayed) *\n *                                                                 *\n *            NOTE: A line command macro is required to utilize    *\n *            syntax option 3. LINEMAC is include in this package  *\n *            but requires the use of Doug Nagel's LMAC or UMAC.   *\n *            Please see http://www.mindspring.com/~somebody/      *\n *            \"A few ISPF or OS/390 tools and toys\" for a complete *\n *            desciption of how to use and setup either LMAC or    *\n *            UMAC so the LINEMAC macro may be called to process   *\n *            user defined line commands.                          *\n *                                                                 *\n * Author:    Lionel B. Dyck                                       *\n *            Internet: lbdyck@gmail.com                           *\n *                                                                 *\n * Additions: Bill George                                          *\n *            Internet: billgeo@bigfoot.com                        *\n *                                                                 *\n * History:                                                        *\n *            09/16/16 - Change REXX comment char to |             *\n *            Ver 3.5    Lionel B. Dyck                            *\n *                                                                 *\n *            06/14/16 - Add Comment support for Shell Scripts     *\n *            Ver 3.4    Lionel B. Dyck                            *\n *                                                                 *\n *            09/09/13 - Add Comment support for ISPF Skeletons    *\n *            Ver 3.3    Lionel B. Dyck                            *\n *                                                                 *\n *            06/20/07 - Expand width of comments thanks to        *\n *            Ver 3.2    Bill Lambert                              *\n *                                                                 *\n *            06/22/06 - Add support for PLI thanks to             *\n *            Ver 3.1    Hans Geiser                               *\n *                     - Fix undefined variable when using on new  *\n *                       (empty) member                            *\n *                     - Correction for SAS and PLI usage for Var  *\n *                       size comment boxes                        *\n *                                                                 *\n *            01/16/06 - Updated doc and help to indicate that a   *\n *            Ver 3.0    target line must be specified.            *\n *                                                                 *\n *            01/24/03 - Updated to deal with a COBOL profile      *\n *            Ver 2.9    of NUMERS ON COBOL                        *\n *            BG       - changed method of producing in-line       *\n *                       panels. Less error prone method.          *\n *                                                                 *\n *            02/17/01 - Update to check for data type.            *\n *            Ver 2.8  - check for EXEC, CNTL, SAS, and ASM        *\n *            LBD      - Added test for filename                   *\n *                                                                 *\n *            01/30/01 - Updated help for the CMT command.         *\n *            Ver 2.7  - Added   help for the CMT panel.           *\n *            BG       - Added FIXLEN parm. It controls the size   *\n *                       of a Fixed length box. It defaults to 57  *\n *                       and has a max of 60. It may be set via    *\n *                       the panel or CMT SET F # command.         *\n *                                                                 *\n *            01/29/01 - Updated panel to show Fixed option.       *\n *            Ver 2.6    Updated error message if no destination   *\n *            BG         was set to indicate help is available via *\n *                       the CMT HELP command.                     *\n *                                                                 *\n *            01/25/01 - Added F (Fixed) as valid BOXSIZE parm.    *\n *            Ver 2.5    Works same as S, might be more intuitive. *\n *            BG         Updated HELP accordingly.                 *\n *                     - Added C (CENTER) and R (Right Justify)    *\n *                       as valid INDENT parameters.               *\n *                       These comment box placements are calc'ed  *\n *                       off the object's RIGHT BOUNDS setting.    *\n *                     - Added INDENT prompt to panel.             *\n *                     - Added Version number to panel.            *\n *                     - Move the panel definition in-line.        *\n *                       (member CMTPANEL not required now)        *\n *                     - Fixed bug that displayed the Version nbr  *\n *                       When CMT V (variable boxsize) entered.    *\n *                     - Fix bug that didn't set the BOXSIZE parm  *\n *                       correctly in the panel if BOXSIZE sent    *\n *                       with command.  ie, CMT 5,V                *\n *                                                                 *\n *            01/17/01 - Fixed bug in CANCEL process.              *\n *            Ver 2.4  - Added code to allow parms in any order    *\n *            BG       - Adjusted order of some object type tests  *\n *                     - Fixed bug in check for special functions  *\n *                       chgd Pos(functn_ck.. to Wordpos(functn_ck *\n *                     - Added code to add an empty box with one   *\n *                       line if PF3 entered with no text entered. *\n *                     - Added error msg for invalid INDENT value. *\n *                     - Added logic to allow for debugging.       *\n *                     - Added ability to change box outlining char*\n *                       CMT SET CHARBOX (or C) to change default. *\n *                     - Added boxing character and BOXSIZE parms  *\n *                       to the panel for user changing.           *\n *                     - Updated some doco typos and added some    *\n *                       comments on use of LINEMAC macro included *\n *                                                                 *\n *            01/16/01 - Moved Doug Nadel's Linemac into this code *\n *            01/11/01 - Added SAS as an option.                   *\n *            01/08/01 - Added flexibility to create comments in   *\n *                       he proper syntax for different object     *\n *                       types. CLIST,REXX,C,COBOL,DOC,ASM,PANELS  *\n *                     - Added additional box type via a new parm. *\n *                     - Added logic to store default values for   *\n *                       the INDENT and BOXSIZE parms via the      *\n *                       CMT SET <parms> function.                 *\n *                     - Added code to function with Doug Nagel's  *\n *                       LINEMAC line command function so CMT may  *\n *                       be entered as a line command.             *\n *                     - Added a HELP function.                    *\n *                     - Added a VERSION function.                 *\n *            01/03/01 - Convert to use table                      *\n *            12/22/00 - Added. for blank lines in popup           *\n *            12/22/00 - Added # for indent                        *\n *            12/22/00 - Creation                                  *\n * --------------------------------------------------------------- */\n  Address Isredit\n \"MACRO (TEXT) NOPROCESS\"\n  Address Ispexec \"Control Errors Return\"\n /* ----------------------------- *\n  * Check for a debugging request *\n  * ----------------------------- */\n  Parse Var text text '<<' TraceVal\n  if TraceVal > '' then x = Trace(TraceVal)\n  text = Strip(text)\n\n /* -------------------- *\n  * Init Some Variables  *\n  * -------------------- */\n  Parse Value \"\" with null cmt_suf indent boxsize ddname\n  cmt_last = \"*\"\n  valid_box_values = \"F S V\"\n  Panels_Created = 0\n  x_rc = 0\n\n /* --------------------------------------------------------- *\n  * Save the display position so it may be restored when done *\n  * as subsequent processing may do havoc to its position.    *\n  * --------------------------------------------------------- */\n  top = null\n '(top,bot) = DISPLAY_LINES'\n  \"LABEL\" top \"= .SAV 0\"\n \"(holdrow,holdcol) = CURSOR\"                /* save cursor position */\n if top = null then top = 1\n\n /* --------------------------------- *\n  * Check/Arrange entered parameters. *\n  * Process special command if found. *\n  * --------------------------------- */\n  if Length(text) > 0 then do\n     Parse Value text with indent \",\" boxsize \",\" text2\n     Parse Upper VAR indent functn_ck .\n\n    /* -------------------------------------- *\n     * Process special commands.              *\n     * CMT ends if special command processed. *\n     * -------------------------------------- */\n     if functn_ck = \"SET\" then do\n        Call Set_CMT_Default\n        Signal Exit_Macro\n     end\n\n     if Abbrev(\"HELP\",functn_ck,1),\n     |  functn_ck =  \"?\" then do\n        Call Get_Help\n        Signal Exit_Macro\n     end\n\n     if Abbrev(\"VERSION\",functn_ck,2) then do\n        zedsmsg = \"CMT Version\" vernbr\n        zedLmsg = \"CMT Version\" vernbr\n        Address Ispexec \"Setmsg Msg(isrz000)\"\n        Signal Exit_Macro\n     end\n\n    /* ---------------------------------------- *\n     * Arrange parameters into processing order *\n     * of indent,boxsize,test                   *\n     * ---------------------------------------- */\n     Call Arrange_Parameters\n\n     end\n  else\n   /* ----------------------------------------- *\n    * No parameters entered, use default values *\n    * ----------------------------------------- */\n     Call Get_Default_Values\n\n /* ------------------------------------ *\n  * Use defaults for any null parameters *\n  * ------------------------------------ */\n  if indent  = null then indent  = cmtdfInd\n  if boxsize = null then boxsize = cmtdfBox\n  Upper boxsize\n\n /* ------------------------------*\n  * Test for a valid INDENT value *\n  * ------------------------------*/\n  if Datatype(indent) = \"NUM\",\n  &  indent > 65 then do\n     zedsmsg = null\n     zedlmsg = Left(\"ERROR: INDENT value,\" indent \"invalid.\",81),\n             \"Must be between 0 - 65,  C=Center or  R=Right Justify\"\n     Address Ispexec \"Setmsg Msg(isrz000)\"\n     x_rc = 8\n     Signal Exit_Macro\n  end\n\n /* --------------------------------- *\n  * Test for a target destination set *\n  * via an \"A\" or \"B\" line command.   *\n  * --------------------------------- */\n \"PROCESS DEST\"\n  dest_rc = rc\n\n  if dest_rc = 0 then\n    \"(DEST) = LINENUM .ZDEST\"\n\n  else do\n    /* ---------------------------------------------------- *\n     * \"A\" or \"B\" line destination not found, check if      *\n     * called via LINEMAC, (\"PROCESS DEST\" gets a non 0 rc) *\n     * look for a .CMT line LABEL set in LINEMAC.           *\n     * ---------------------------------------------------- */\n    \"Locate .CMT\"\n\n     if rc = 0 then do\n      /* ------------------------------ *\n       * Set the target destination and *\n       * RESET LABEL set in LINEMAC     *\n       * ------------------------------ */\n      \"(DEST) = LINENUM .ZCSR\"\n      \"Reset label\" DEST-1 DEST+1\n       end\n     else do\n        zedsmsg = \"\"\n        zedlmsg =,\n           Left(\"A destination line must be specified, try again.\",81),\n           Left(\"Use an A(After) or B(Before) on a line in your data.\",\n                 ,81),\n                \"For help, enter CMT HELP\"\n        Address Ispexec \"Setmsg Msg(ISRZ001)\"\n        x_rc = 8\n        Signal Exit_Macro\n     end\n  end\n\n  Call Determine_Object_Type\n\n /* ---------------------------------------------------------- *\n  * Send message if object type is not valid for indentation.  *\n  * NOTE: ASM & JCL require chars in column 1 but if an indent *\n  *       value is input, another '*' is placed at the indent  *\n  *       position to start an indented box at that point.     *\n  * ---------------------------------------------------------- */\n  if Pos(mbr_type,\"COBOL\") > 0,\n  &  indent > 0 then do\n     zedsmsg = \"\"\n     zedlmsg = \"Indentation parm of,\" indent,\n               \"is not valid for this mbr type\"\n     Address Ispexec \"Setmsg Msg(isrz000)\"\n  end\n\n /* ------------------------ *\n  * if no TEXT entered then  *\n  * display the popup panel. *\n  * ------------------------ */\n  if Length(text) = 0 then Call Process_Via_Panel\n\n /* ---------------------------------------------------- *\n  * else just add the provided line - (No panel input)   *\n  * ---------------------------------------------------- */\n  else do\n     boxlen = Length(text)\n     Call Setup_Member_Type_Parameters\n     Call do_box first_line\n     Call do_line text\n  end\n\n /* ----------------------------------------- *\n  * Put out the last line of the comment box. *\n  * ----------------------------------------- */\n  Call do_box last_line\n\nExit_Macro:\n\n \"locate .sav\"\n \"(dest) = linenum .ZCSR\"\n \"reset label\" top-1 top+1\n \"cursor = (holdrow,holdcol)\"               /* restore cursor postn */\n /* ------------------------------------- *\n  * Deallocate panel's temporary library. *\n  * ------------------------------------- */\n  if ddname \\= null then do\n     Address Ispexec \"Libdef ispplib\"\n     Address Tso \"Free f(\"ddname\")\"\n  end\n\nExit x_rc\n\n             /*-------------------------------            /* Ge150606 */\n                C A L L E D   R O U T I N E S\n               -------------------------------*/          /* Ge150606 */\n\n/*===========================================================*\n* Routine: Process_Via_Panel:                                *\n*   Display a popup panel for the user to input comments.    *\n*   Process the comments and/or commands enntered.           *\n*===========================================================*/\nProcess_Via_Panel:\n\n   Call Create_Panels\n\n  /* ---------------------- *\n   * Create the ISPF Table  *\n   * and prefill in 150 rows*\n   * ---------------------- */\n   Address Ispexec\n  \"Tbcreate cmt Names(rxline)\"\n   rxline = null\n\n   do i = 1 to 150\n     \"Tbadd cmt\"\n   end\n  \"Tbtop cmt\"\n  \"Addpop\"\n\n  /* ---------------------- *\n   * Now display the table  *\n   * ---------------------- */\n   trc = 0\n   cmt_suf = null\n   do until trc > 4\n     \"Tbdispl cmt Panel(cmtpanel)\"\n      trc = rc\n\n     /* ---------------- *\n      * Test for Cancel  *\n      * ---------------- */\n      if Abbrev(\"CANCEL\",zcmd,1) then do\n        \"Tbend cmt\"\n         Signal Exit_Macro\n      end\n\n     /* ---------------- *\n      * Test for Insert  *\n      * ---------------- */\n      if Abbrev(\"INSERT\",WORD(zcmd,1),1) = 1 then do\n         Parse Value zcmd with x count\n         zcmd   = null\n         rxline = null\n        \"Tbbottom cmt\"\n         do i = 1 to count\n           \"Tbadd cmt\"\n         end\n        \"Tbtop cmt\"\n        \"Tbskip cmt number(\"ztdtop\")\"\n      end\n\n     /* ----------------------------------------------- *\n      * if user requests to use parameters as defaults, *\n      * store the default values in the PROFILE pool.   *\n      * ----------------------------------------------- */\n      if Translate(setdflt) = \"Y\" then do\n         cmtdfInd = indent\n         cmtdfBox = boxsize\n        \"Vput (cmtdfInd cmtdfBox cmtdfChr cmtdfFix) profile\"\n      end\n\n     /* ------------------------------ *\n      * Process multiple rows of text  *\n      * ------------------------------ */\n     \"Tbput cmt\"\n      do i = 1 to ztdsels-1\n        \"Tbdispl cmt\"\n        \"Tbput cmt\"\n      end\n   end\n\n  /* ------------------------------------------------------ *\n   * end of Table Display                                   *\n   * Remove popup and go to top of table.                   *\n   * Check if the member type has been changed by the user. *\n   * ------------------------------------------------------ */\n  \"Rempop\"\n  \"Tbtop cmt\"\n\n   if MbrType /= mbr_type then do\n      mbr_type = MbrType\n      boxlen = Length(text)\n      Call Setup_Member_Type_Parameters\n   end\n\n  /* --------------------------------------------------------- *\n   * Process all entered rows of information by loading a      *\n   * REXX STEM variable with the text lines and checking for   *\n   * the longest line as we go incase a Variable box required. *\n   * --------------------------------------------------------- */\n   cmts. = null\n   Parse Value '0' WITH 1 cnt 1 boxlen 1 blank_cnt\n\n   Do Forever\n     \"Tbskip cmt\"\n      if rc > 0 then Leave\n\n     /* ----------------------------------------------------- *\n      * if text found on line, check if its the longest line. *\n      * Start the blank line count over.                      *\n      * ----------------------------------------------------- */\n      if Length(rxline) > 0 then do\n         len = Length(rxline)\n         if len > boxlen then boxlen = len\n         blank_cnt = 0\n         end\n      else do\n\n        /* ------------------------------------------------------ *\n         * Leave if we have found the 2nd consecutive blank line. *\n         * ------------------------------------------------------ */\n         blank_cnt = blank_cnt + 1\n         if blank_cnt > 1 then do\n            cnt = cnt - 1\n            Leave\n         end\n      end\n     /* --------------------- *\n      * Save the comment text *\n      * --------------------- */\n      cnt = cnt + 1\n      cmts.cnt = rxline\n   end\n\n   if cnt = 0    then cnt = 1\n   if boxlen = 0 then boxlen = 55\n\n  /* -------------------- *\n   * Close out the table  *\n   * -------------------- */\n  \"Tbend cmt\"\n\n  /* ---------------------------------- *\n   * Write out the comment box.         *\n   * Last boarder line for box written  *\n   * out upon RETURN from this routine. *\n   * ---------------------------------- */\n   Address Isredit\n   Call Setup_Member_Type_Parameters\n   Call do_box first_line\n\n   do i = 1 to cnt\n      Call do_line cmts.i\n   end\n\nReturn\n\n/*===========================================================*\n* Routine: Do_Line:                                          *\n* This routine sets up the comment line between * and        *\n* then inserts it into the code.                             *\n*===========================================================*/\nDo_Line:\n\n  Parse Arg data\n  if data = \".\" then data = \" \"\n  data = indent_spc || cmt_chars Left(data,boxlen) cmt_last\"\"cmt_suf\n \"Line_After\" dest \"= (data)\"\n  dest = dest + 1\n\nReturn\n\n/*===========================================================*\n* Routine: Do_Box:                                           *\n* Do_Box Routine is called to output the first and last      *\n* lines of the comment box.                                  *\n*===========================================================*/\nDo_Box:\n  Parse Arg data\n \"Line_After\" dest \"= (data)\"\n  dest = dest + 1\nReturn\n\n/*===========================================================*\n* Routine: Determine_Object_Type:                            *\n*   Determine the type of member being edited                *\n*   so the proper comment syntax may be used.                *\n*============================================================*/\nDetermine_Object_Type:\n\n  mbr_type = null\n /* ----------------------------------------------- *\n  * Check if the member type can be determined from *\n  * the data found in the first line of the member. *\n  * if determined, Exit the routine.                *\n  * ----------------------------------------------- */\n '(line1) = LINE 1'\n  Upper Line1\n  Select\n     When Left(line1,2) = '//'       then mbr_type = 'JCL'\n     When Left(line1,1) = '#'        then mbr_type = 'SHELL'\n     When Wordpos('REXX',line1) > 0  then mbr_type = 'REXX'\n     Otherwise Nop\n  end\n\n  if mbr_type /= null then Signal Type_Exit\n\n /* -------------------------- *\n  * Ad hoc CLIST/PANEL checks  *\n  * -------------------------- */\n \"Find first X'50E2E3D9'\"                          /* &STR(    */\n  if rc = 0 then do\n     mbr_type = 'CLIST'\n     Signal Type_Exit\n  end\n\n \"Find first X'50E2E4C2E2E3D94D'\"                  /* &Substr( */\n  if rc = 0 then do\n     mbr_type = 'CLIST'\n     Signal Type_Exit\n  end\n\n \"Find first X'50D3C1E2E3C3C3'\"                    /* &LASTCC  */\n  if rc = 0 then do\n     mbr_type = 'CLIST'\n     Signal Type_Exit\n  end\n\n \"Find first ')ATTR '\"\n  if rc = 0 then do\n     mbr_type = 'PANEL'\n     Signal Type_Exit\n  end\n\n /* ------------------ *\n  * Ad hoc ASM checks  *\n  * ------------------ */\n \"Find first 'DSECT ' 10 20\"\n  if rc = 0 then do\n     mbr_type = 'ASM'\n     Signal Type_Exit\n  end\n\n \"Find first 'DS  ' 10\"\n  if rc = 0 then do\n     mbr_type = 'ASM'\n     Signal Type_Exit\n  end\n\n \"Find first 'MVC  ' 10\"\n  if rc = 0 then do\n     mbr_type = 'ASM'\n     Signal Type_Exit\n  end\n\n /* ------------------- *\n  * Ad hoc REXX checks  *\n  * ------------------- */\n \"Find first 'Wordpos('\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' Parse v'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' Parse u'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' address i'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n \"Find first ' address t'\"\n  if rc = 0 then do\n     mbr_type = 'REXX'\n     Signal Type_Exit\n  end\n\n /* ------------------- *\n  * Ad hoc COBOL checks *\n  * ------------------- */\n \"Find first 'IDENTIFICATION DIVISION.' 8\"\n  if rc = 0 then do\n     mbr_type = 'COBOL'\n     Signal Type_Exit\n  end\n\n \"Find first ' 01 ' 7\"\n  if rc = 0 then do\n     mbr_type = 'COBOL'\n     Signal Type_Exit\n  end\n\n \"Find first ' PIC X(' 30 60\"\n  if rc = 0 then do\n     mbr_type = 'COBOL'\n     Signal Type_Exit\n  end\n\n /* --------------- *\n  * Ad hoc C checks *\n  * --------------- */\n \"Find first 'stdio.h'\"\n  if rc = 0 then do\n     mbr_type = 'C'\n     Signal Type_Exit\n  end\n\n/* --------------------------- *\n * Test for ISPF Skeleton Type *\n * --------------------------- */\n \"Find first ')CM'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n \"Find first ')DO'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n \"Find first ')I'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n \"Find first ')SE'\"\n if rc = 0 then do\n    mbr_type = \"SKEL\"\n     Signal Type_Exit\n     end\n\n/* --------------------------------------------------------- *\n * Test for SAS Language Type                                *\n * --------------------------------------------------------- */\n \"Find first t'RUN;'\"\n  if rc = 0 then do\n     mbr_type = \"SAS\"\n     Signal Type_Exit\n     end\n\n /* ------------------ *                                  /* Ge150606 */\n  * Ad hoc PLI checks  *                                  /* Ge150606 */\n  * ------------------ */                                 /* Ge150606 */\n \"FIND FIRST 'DCL '\"                                      /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n \"FIND FIRST 'OPTIONS(MAIN'\"                              /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n \"FIND FIRST 'CALL PLIRET'\"                               /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n \"FIND FIRST ' BUILTIN'\"                                  /* Ge150606 */\n  if rc = 0 then do                                       /* Ge150606 */\n     mbr_type = 'PLI'                                     /* Ge150606 */\n     Signal Type_EXIT                                     /* Ge150606 */\n  end                                                     /* Ge150606 */\n                                                          /* Ge150606 */\n /* ----------------------------------------------- *\n  * Check type based on a node of the dataset name  *\n  * ----------------------------------------------- */\n '(dsname) = dataset'\n  if Pos('ASM',dsname)   > 0  then mbr_type = 'ASM'\n  if Pos('CLIST',dsname) > 0  then mbr_type = 'CLIST'\n  if Pos('CNTL',dsname)  > 0  then mbr_type = 'JCL'\n  if Pos('EXEC',dsname)  > 0  then mbr_type = 'REXX'\n  if Pos('REXX',dsname)  > 0  then mbr_type = 'REXX'\n  if Pos('SAS',dsname)   > 0  then mbr_type = 'SAS'\n  if Pos('PLI',dsname)   > 0  then mbr_type = 'PLI'   /* Ge150606 */\n  if Pos('SKEL',dsname)  > 0  then mbr_type = 'SKEL'\n  if mbr_type \\= null then Signal Type_Exit\n\n /* -------------------- *\n  * Default to DOC type  *\n  * -------------------- */\n  mbr_type = 'DOC'\n\nType_Exit:\n 'reset'\n  MbrType = Mbr_Type                       /* Setup panel's disp var */\n\nReturn\n\n/*========================================================*\n* Routine: Setup_Member_Type_Parameters                   *\n*   Setup processing parameters based on the member type. *\n*========================================================*/\nSetup_Member_Type_Parameters:\n\n /* ----------------------------------------------- *\n  * Set 'boxlen' value for a Fixed length box type. *\n  * Set character used for the box outside borders. *\n  * ----------------------------------------------- */\n  if Pos(boxsize,'SF') > 0 then boxlen = cmtdfFix\n  dash_char  = cmtdfChr\n  dash_line  = Left(dash_char,boxlen,dash_char)\n\n /* ------------------------------------------------------ *\n  * if Centering requested, determine indent value to use. *\n  * Centering is based on the objects RIGHT BOUNDS value.  *\n  * ------------------------------------------------------ */\n  if Translate(indent) = 'C' then do\n     Address Isredit \"(,rbnds) = BOUNDS\"\n     indent = (rbnds - boxlen - 6) % 2\n  end\n\n /* ---------------------------------------------------- *\n  * if RIGHT justify requested, determine indent value.  *\n  * Calculation based on the objects RIGHT BOUNDS value. *\n  * ---------------------------------------------------- */\n  right_just = 0\n  if Translate(indent) = 'R' then do\n     right_just = 1\n     Address Isredit \"(,rbnds) = BOUNDS\"\n     indent = rbnds - (boxlen + 6)\n  end\n\n /* --------------------------------------------------------- *\n  * Setup the comment box syntax appropriate for the mbr type *\n  * --------------------------------------------------------- */\n  Select\n     When mbr_type = 'ASM' then do\n          if right_just then indent = indent + 2\n         /* --------------------------------------- *\n          * Setup special indent for assembler type *\n          * --------------------------------------- */\n          if indent > 1 then do\n             cmt_chars  = \"*\"\n             indent_spc = \"*\"Left(null,indent-1)\n             end\n          else do\n             cmt_chars  = null\n             indent_spc = \"*\"\n             end\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n     When mbr_type = 'CLIST',\n        | mbr_type = 'PANEL' then do\n          cmt_chars  = \"/*\"\n          cmt_suf    = \"/\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc\"/*\" dash_line \"*/\"\n          last_line  = indent_spc\"/*\" dash_line \"*/\"\n          end\n     When mbr_type = 'COBOL' then do\n         \"(stat,fmt) = NUMBER\"\n          cmt_chars  = \"*\"\n          if Pos(\"COBOL\",fmt) > 0 then\n             indent_spc = \"*\"Left(null,indent)\n          else\n             indent_spc = \"      *\"Left(null,indent)\n          first_line = indent_spc\"*\" dash_line \"*\"\n          last_line  = first_line\n          end\n     When mbr_type = 'JCL'   then do\n         /* --------------------------------- *\n          * Setup special indent for JCL type *\n          * --------------------------------- */\n          if indent > 3 then do\n             cmt_chars  = \"*\"\n             indent_spc = \"//*\"Left(null,indent-1)\n             end\n          else do\n             cmt_chars  = null\n             indent_spc = \"//*\"\n             end\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n     When mbr_type = 'SKEL'  then do\n         /* ---------------------------------- *\n          * Setup special indent for SKEL type *\n          * ---------------------------------- */\n          cmt_chars  = \"*\"\n          cmt_chars  = null\n          indent_spc = \")CM *\"\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n     When mbr_type = 'REXX',\n        | mbr_type = 'C'     then do\n          cmt_chars  = \" |\"\n          cmt_last   = \"|\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc\"/*\" dash_line \"*\"\n          last_line  = indent_spc\" *\" dash_line \"*/\"\n          end\n     When mbr_type = 'SHELL' then do                    /* lbd */\n          cmt_chars  = \"# \"                             /* lbd */\n          cmt_suf    = \"#\"                              /* lbd */\n          cmt_last   = \"\"                               /* lbd */\n          indent_spc = Left(null,indent)                /* lbd */\n          first_line = indent_spc\"# \" dash_line \"#\"     /* lbd */\n          last_line  = indent_spc\"# \" dash_line \"#\"     /* lbd */\n          end                                           /* lbd */\n     When mbr_type = 'SAS' then do\n          cmt_chars  = \"*\"\n          cmt_suf    = \";\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc\"*\" dash_line \"*;\"\n          last_line  = indent_spc\"*\" dash_line \"*;\"\n          end\n     When mbr_type = 'PLI' then do                        /* Ge150606 */\n          if indent > 1 then do                           /* Ge150606 */\n             cmt_chars  = \" *\"                            /* Ge150606 */\n             indent_spc = Left(null,indent-1)             /* Ge150606 */\n             end                                          /* Ge150606 */\n          else do                                         /* Ge150606 */\n             cmt_chars  = \" *\"                            /* Ge150606 */\n             indent_spc = \" \"                             /* Ge150606 */\n             end                                          /* Ge150606 */\n          first_line = indent_spc\"/*\" dash_line \"*\"       /* Ge150606 */\n          last_line  = indent_spc\" *\" dash_line \"*/\"      /* Ge150606 */\n          end                                             /* Ge150606 */\n     Otherwise do\n          if right_just then indent = indent + 2\n          cmt_chars  = \"*\"\n          indent_spc = Left(null,indent)\n          first_line = indent_spc||cmt_chars dash_line \"*\"\n          last_line  = indent_spc||cmt_chars dash_line \"*\"\n          end\n  end\n\nReturn\n\n/*=========================================================*\n * Routine: Set_CMT_Defaults                               *\n * This routine processes a CMT SET function to set a      *\n * user's default value for the INDENT or BOXSIZE parms.   *\n * if a current setting is not found for these, they are   *\n * defaulted to INDENT = 0 and BOXSIZE = S (Set size)      *\n *=========================================================*/\nSet_CMT_Default:\n\n  Parse Upper VAR indent cmd parm_id hlddfval\n\n  Call Get_Default_Values\n\n  Error = null\n  Address Ispexec\n\n  Select\n  /* ------------------ *\n   * Set INDENT default *\n   * ------------------ */\n     When Left(parm_id,1) = \"I\" then do\n          parm_id  = \"Indent\"\n          if Datatype(hlddfVal) = \"NUM\" then\n             if hlddfInd < 66 then\n                cmtdfInd = hlddfVal\n             else\n                Error=\"value must be a nbr 1-65, C=Center  R=Rt Justify\"\n          else\n            if Pos(hlddfVal,\"CR\") > 0 then\n                cmtdfInd = hlddfVal\n            else\n               Error=\"value must be a nbr 1-65, C=Center  R=Rt Justify\"\n          end /*when*/\n\n  /* ------------------- *\n   * Set BOXSIZE default *\n   * ------------------- */\n     When Left(parm_id,1) = \"B\" then do\n          parm_id  = \"BOXSIZE\"\n          if Pos(hlddfVal,\"FSV\") > 0 then\n             cmtdfBox = hlddfVal\n          else\n             Error = \"must be F or S (Fixed or Set) or V (Variable)\"\n          end\n\n  /* ------------------------ *\n   * Set the BOX CHAR default *\n   * ------------------------ */\n     When Left(parm_id,1) = \"C\" then do\n          parm_id  = \"CHARBOX\"\n          cmtdfChr = hlddfVal\n          end\n\n  /* -------------------------- *\n   * Set the FIX LENGTH default *\n   * -------------------------- */\n     When Left(parm_id,1) = \"F\" then do\n          parm_id  = \"FIXLEN\"\n          if Datatype(hlddfVal) = \"NUM\" then\n             if hlddfInd < 61 then\n                cmtdfFix = hlddfVal\n             else\n                Error = \"value must be a number from 1 - 75\"\n          else\n                Error = \"value must be a number from 1 - 75\"\n          end\n\n  /* ------------------------ *\n   * Error: no SET parameters *\n   * ------------------------ */\n     When parm_id = null then do\n          parm_id = \"<blank>\"\n          Error=\"Invalid parm ID.  Enter Indent, Boxsize, Charbox or\",\n                \"Fixlen\"\n          end\n\n     Otherwise\n          Error=\"Invalid parm ID.  Enter Indent, Boxsize, Charbox or\",\n                \"Fixlen\"\n  end\n\n /* -------------------- *\n  * Set description text *\n  * -------------------- */\n  if Datatype(cmtdfInd) = \"NUM\" then\n     indd = \" (Indent the comment box\" cmtdfInd \"characters)\"\n  if Pos(cmtdfInd,\"cC\") > 0   then\n     indd = \" (Comment box will be CENTERed based on RIGHT BOUNDS)\"\n  if Pos(cmtdfInd,\"rR\") > 0   then\n     indd = \" (Comment box will be RIGHT justified on RIGHT BOUNDS)\"\n\n  if Pos(cmtdfBox,\"FS\") > 0 then boxd =,\n     \" (Box size fixed at\" cmtdfFix \"characters. See FIXLEN setting)\"\n  if cmtdfBox=\"V\" then boxd =,\n  \" (Box size based on longest comment line)\"\n\n  chrd = \" (Box outlining character)\"\n  fixd = \" (Box length When a Fixed/Set BOXSIZE used)\"\n\n /* ----------------- *\n  * Send Good message *\n  * ----------------- */\n  if Error = null then do\n     zedsmsg = null\n     zedlmsg = Left(\"CMT default values were set to:\",81),\n               Left(\".    INDENT :\" Left(cmtdfInd,2) \" \" indd,81),\n               Left(\".    BOXSIZE:\" Left(cmtdfBox,2) \" \" boxd,81),\n               Left(\".    CHARBOX:\" Left(cmtdfChr,2) \" \" chrd,81),\n                    \".    FIXLEN :\" Left(cmtdfFix,2) \" \" fixd\n     end\n  else do\n /* --------------------- *\n  * Send an Error message *\n  * --------------------- */\n     zedsmsg = ' '\n     zedlmsg = Left(\"Error setting default for '\"parm_id\"' \",\n                    \"SYNTAX: CMT SET <parmId> <dflt value>\",81),\n               Left(parm_id Error,81),\n               Left(\"Current CMT defaults are:\",81),\n               Left(\".    INDENT :\" cmtdfInd \" \" indd,81),\n               Left(\".    BOXSIZE:\" cmtdfBox \" \" boxd,81),\n               Left(\".    CHARBOX:\" cmtdfChr \" \" chrd,81),\n                    \".    FIXLEN :\" Left(cmtdfFix,2) \" \" fixd\n     end\n \"Setmsg Msg(isrz000)\"\n /* ---------------------------------------------------- *\n  * Store the default values in the current PROFILE pool *\n  * ---------------------------------------------------- */\n \"Vput (cmtdfInd cmtdfBox cmtdfChr cmtdfFix) profile\"\n\nReturn\n\n/*========================================================*\n * Routine: Arrange_Parameters                            *\n *    Arrange parameters into indent,boxsize,text order,  *\n *    then assign the default to any null parameters.     *\n *    ASSUMPTION: at least one parm (indent) has a value. *\n *========================================================*/\nArrange_Parameters:\n\n  Call Get_Default_Values\n\n  text = text2\n  Parse Value \"\" With indent_save box_save text_save\n\n /* ------------------------------- *\n  * Check the current INDENT value. *\n  * ------------------------------- */\n  if Datatype(indent) = \"NUM\",\n  |  Pos(indent,\"cCrR\") > 0 then Nop\n\n  else\n    /* -------------------------------- *\n     * Move it to appropriate parameter *\n     * since it is NOT the INDENT parm. *\n     * -------------------------------- */\n     if Wordpos(indent,Valid_Box_Values) > 0 then do\n        box_save = indent\n        indent = null\n        end\n     else do\n        text_save = indent\n        indent = null\n     end\n\n /* -------------------------------- *\n  * Check the current BOXSIXE value. *\n  * -------------------------------- */\n  if Wordpos(boxsize,Valid_Box_Values) = 0 then\n    /* -------------------------------- *\n     * Move it to appropriate parameter *\n     * since it is NOT the BOXSIZE parm *\n     * -------------------------------- */\n     if Datatype(boxsize) = \"NUM\",\n     |  Pos(boxsize,\"cCrR\") > 0 then do\n        indent_save = boxsize\n        boxsize = null\n        end\n     else do\n        if boxsize \\= null then do\n           text_save = boxsize\n           boxsize = null\n        end\n     end\n\n /* ----------------------------- *\n  * Check the current TEXT value. *\n  * ----------------------------- */\n  if Wordpos(text,Valid_Box_Values) > 0 then do\n     box_save = text\n     text = null\n     end\n\n  if Datatype(text) = \"NUM\",\n  |  Pos(text,\"cCrR\") > 0 then do\n     indent_save = text\n     text = null\n     end\n\n /* ----------------------------------- *\n  * Move in appropriate values for the  *\n  * parms if they came in out of order. *\n  * ----------------------------------- */\n  if indent_save \\= null then indent  = indent_save\n  if box_save    \\= null then boxsize = box_save\n  if text_save   \\= null then text    = text_save\n\nReturn\n\n/*=============================================================*\n * Retrieve defaults for INDENT, BOXSIZE & CHARBOX  parameters *\n *=============================================================*/\nGet_Default_Values:\n\n  Address Ispexec \"Vget (CmtdfInd CmtdfBox CmtdfChr CmtdfFix) profile\"\n  if CmtdfInd = null then CmtdfInd = 0\n  if CmtdfBox = null then CmtdfBox = 'F'\n  if CmtdfChr = null then CmtdfChr = '-'\n  if CmtdfFix = null then CmtdfFix = 65\n\nReturn\n\n/*==========================*\n * Display HELP information *\n *==========================*/\nGet_Help:\n\n  Call Get_Default_Values\n  Call Create_Panels\n  Address Ispexec\n \"Addpop\"\n \"Display Panel(cmthelp)\"\n \"Rempop\"\n\nReturn\n\n/* ========================================================= *\n * Function: Create_Panels                                   *\n *    The following is a process to define panels in-line.   *\n *    Panels are defined and loaded into a temporary dataset *\n *    and then dataset is Libdef'ed so it is allocated.      *\n *    A deallocation of the Libdef happens in Exit_Macro.    *\n * ========================================================= */\nCreate_Panels:\n\n /* ---------------------------------------- *\n  * If the panels have already been          *\n  * created then bypass additional attempts. *\n  * ---------------------------------------- */\n  if Panels_Created then Return\n\n /* ---------------------------------------------- *\n  * Create temp DS to hold inline panel definition *\n  * ---------------------------------------------- */\n  x = Msg(on)\n  Address Tso\n  prefix = Sysvar('SYSPREF')                  /* tso profile prefix  */\n  uid    = Sysvar('SYSUID')                   /* tso userid          */\n  if prefix =  '' then prefix = uid           /* use uid if null prfx*/\n  if prefix <> '' & prefix <> uid then        /* diff prefix than uid*/\n     prefix = prefix || '.' || uid            /*    use prefix.uid   */\n  ddname = \"$\"Right(Time(S),7,\"0\")\n  flname = prefix\".\"ddname\".ISPPLIB\"\n\n \"Alloc File(\"ddname\") da('\"flname\"') new del tracks space(1,1)\",\n       \"lrecl(80) recfm(f b) blksize(3120) dir(1) reuse\"\n\n/* ------------------------------------ *\n * Three panels are created here.       *\n * CMTPANEL - Main comment entry panel. *\n * CMTHELP  - CMT command Help panel.   *\n * CMTHELPP - CMT panel Help panel.     *\n * ------------------------------------ */\n  Call Create_Main_Panel\n  Call Create_Help_Panels\n\n  Panels_Created = 1\n  Address Ispexec \"libdef ispplib library id(\"ddname\") stack\"\n\nReturn\n\nCreate_Main_Panel:\n  NEWSTACK\n  mbname = \"cmtpanel\"\n\nQueue \")Attr Default(%+{)                                           \"\nQueue \" @ type(input) intens(high) caps(off) just(asis) color(white)\",\n      \"    hilite(uscore)\"\nQueue \" _ type(input) intens(high) caps(on)  just(asis) color(white)\",\n      \"    hilite(uscore)\"\nQueue \" $ type(output) intens(high) just(asis ) color(turq)             \"\nQueue \" ~ type(text)   intens(high) caps(off) just(asis ) color(blue)   \"\nQueue \" + type(text)   intens(low ) skip(on)                            \"\nQueue \" { type(text)   intens(low ) skip(on)  color(green)              \"\nQueue \")Body                                                           \"\nQueue \"+------------------%Comments Entry Ver$Z  +--------------------- \"\nQueue \"+Command ===>_zcmd                             +Scroll ===>_zcsr+\"\nQueue \"+                                                                \"\nQueue \"%Parms:{Indent     :_Z {   Box Size   :_Z{                       \"\nQueue \"+      {Fixed Size :_Z {   Boxing Char:_Z{    Set as defaults:_Z+\"\nQueue \"+                                                                \"\nQueue \"+      {Member Type:_Z    +   %END~add cmt %HELP %CANcel  Insert#\"\nQueue \")Model                                                           \"\nQueue ,\n\"+>@z                                                                +<\"\nQueue \")Init                                                            \"\nQueue \"  &zcsr = CSR                                                    \"\nQueue \"  .ZVARS = '(vernbr indent boxsize cmtdfFix cmtdfChr +           \"\nQueue \"             setdflt mbrtype rxline)'                            \"\nQueue \"  .cursor= mbrtype                                               \"\nQueue \"  .help = cmthelpp                                               \"\nQueue \"  &setdflt = 'N'                                                 \"\nQueue \")Proc                                                            \"\nQueue \" ver (&mbrtype,LIST,'ASM','C','CLIST','COBOL','JCL',             \"\nQueue \"  'PANEL','REXX','DOC','SAS','PLI','SKEL','SHELL')               \"\nQueue \" ver (&boxsize,LIST,'C','F','S','V')                             \"\nQueue \" ver (&cmtdfFix,RANGE,1,65)                                         \"\nQueue \" ver (&setdflt,LIST,'Y','N')                                     \"\nQueue \")End                                                             \"\nQueue \"\"\n\n  Call Write_Panel_Member\n\nReturn\n\nCreate_Help_Panels:\n  NEWSTACK\n  mbname = \"cmthelp\"\n\nQueue \")Attr Default(%+_)                                              \"\nQueue \" ~ type(text)   intens(high) caps(off) just(asis ) color(turq)  \"\nQueue \" @ type(text)   intens(high) caps(off) just(asis ) color(yellow)\"\nQueue \" $ type(output) intens(high) just(asis ) color(turq)             \"\nQueue \" ` type(text)   intens(high) caps(off) just(asis ) color(red)   \"\nQueue \")Body Window(64,20)                                             \"\nQueue \"+-----------------%CMT Command HELP  Ver$Z  +-------------------\"\nQueue \"+Command ===>_zcmd                                              \"\nQueue \"% CMT+is an ISPF edit macro to simplify entry of comments. CMT  \"\nQueue \"+ enters all comments in the syntax of the object being edited  \"\nQueue \"+ and formats them via sent/defaulted user parameters. Defaults \"\nQueue \"+ for execution are set/inquired via the CMT syntax #2, shown   \"\nQueue \"+ below, and some may be overridden via the main CMT syntax #1. \"\nQueue \"` All comments require a target line be defined in your data.   \"\nQueue \"~                                                               \"\nQueue \"~ Syntax 1 to add comment line(s)    +(all parms optional)      \"\nQueue \"% CMT #,B,text  +                                               \"\nQueue \"%     #+=INDENT   %1+-%70, C+(Center) or%R+(Right Justify) box  \"\nQueue \"%     B+=BOXSIZE  %F S+(Fixed$Z +chars) or %V+(Variable size)   \"\nQueue \"%     cmt text+   @blank shows popup panel to enter mult lines. \"\nQueue \"~                                                               \"\nQueue \"~ Syntax 2 to Set CMT defaults @(also may be set on popup panel)\"\nQueue \"% CMT SET <parmId> <parm value>                                 \"\nQueue \"%     parmid    %Indent, Boxsize, Charbox or Fixlength          \"\nQueue \"%     parm value+for I:%#1-70, C or R    +B:%F,S or V           \"\nQueue \"%                   +C:%any character    +F:%1-65               \"\nQueue \")Init                                                           \"\nQueue \"  .ZVARS = '(vernbr cmtdfFix)'                                  \"\nQueue \")End\"\nQueue \"\"\n\n  Call Write_Panel_Member\n\n  NEWSTACK\n  mbname = \"cmthelpp\"\n\nQueue \")Attr Default(%+_)                                              \"\nQueue \" ~ type(text)   intens(high) caps(off) just(asis ) color(turq)  \"\nQueue \" @ type(text)   intens(high) caps(off) just(asis ) color(yellow)\"\nQueue \"   type(output) intens(high)                                    \"\nQueue \" $ type(output) intens(high) just(asis ) color(turq)             \"\nQueue \")Body Window(64,20)                                             \"\nQueue \"+------------------%CMT Panel HELP  Ver$Z  +--------------------\"\nQueue \"+Command ===>_zcmd                                              \"\nQueue \"+ Parameters shown are initially set with your default values.  \"\nQueue \"+ They may be changed as needed for the comments to be added.   \"\nQueue \"+ Enter 'Y' in%Set as defaults+to make the parms your defaults. \"\nQueue \"%Cmds ~End+   text entered on panel is added to the source.     \"\nQueue \"      ~Insert <n>+inserts <n> blank lines into displayed table. \"\nQueue \"      ~Cancel+cancels with no comments added to the source.     \"\nQueue \"%Indent     :+Valid:%1-70+ or %C+(Center box) %R+(Right Justify)\"\nQueue \"            :+Enter how, or number of characters, to indent box.\"\nQueue \"%Box Size   :+Valid:%F+or%S+for a Fixed Size %V+- Variable.     \"\nQueue \"              Fixed - box size set to the \"Fixed Size\" value.   \"\nQueue \"              Variable - size set = to the longest line entered.\"\nQueue \"%Fixed Size :+Valid: nbr from%1-65 +Used ONLY if Box Size fixed.\"\nQueue \"%Boxing Char:+Character used as outside board of the box.       \"\nQueue \"%Member type:+Language syntax to use When comments are added.   \"\nQueue \"%Comments   :+Enter as many lines as needed. 150 lines initially\"\nQueue \"             +given. Use command %Insert <n>+to add lines.      \"\nQueue \"%For CMT command help enter CMT HELP while editing source.      \"\nQueue \")Init                                                           \"\nQueue \"  .ZVARS = '(vernbr)'                                           \"\nQueue \")End\"\nQueue \"\"\n\n  Call Write_Panel_Member\n\nReturn\n\nWrite_Panel_Member:\n\n \"ALLOC File(\"mbname\") SHR REUSE DA('\"flname\"(\"mbname\")')\"\n \"EXECIO * DISKW\" mbname \"(FINIS\"\n \"FREE FI(\"mbname\")\"\n  DELSTACK\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPVTC$": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x10\\x01\\x01\\x04\\x0f\\x01\\x01\\x04\\x0f\\x12#\\x00\\x15\\x00\\x16\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-02-09T00:00:00", "modifydate": "2001-02-09T12:23:10", "lines": 21, "newlines": 22, "modlines": 0, "user": "WSBG"}, "text": "From:   Lionel B Dyck [Lionel.B.Dyck@kp.org]\nSent:   Friday, February 09, 2001 11:54 AM\nSubject:        Bonus: Compare VTOC to Catalog\nAs part of our V2R10 migration we needed to verify that all\ndatasets on the new sysres were in the catalog.  Here is a quick\nlittle rexx tool that I wrote to report those datasets on the\ntarget sysres that are not in the current systems catalog.\n\n\n--------------------------------------------------------------------\nLionel B. Dyck, Systems Software Lead\nKaiser Permanente Information Technology\n25 N. Via Monte Ave\nWalnut Creek, Ca 94598\n\nPhone:   (925) 926-5332\nFax:        (925) 926-5292\n\nE-Mail:    Lionel.B.Dyck@kp.org\nSametime: (use Lotus Notes address)\nAIM:        lbdyck\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMPVTOC": {"ttr": 5895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x04\\x0f\\x01\\x01\\x04\\x0f\\x12#\\x00:\\x00:\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-09T00:00:00", "modifydate": "2001-02-09T12:23:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "SYSLBD"}, "text": "        /* --------------------  rexx procedure  -------------------- *\n         * Name:      compvtoc                                        *\n         *                                                            *\n         * Function:  Compare dsn's on vtoc to catalog                *\n         *                                                            *\n         * Syntax:    %compvtoc volser                                *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Kaiser Permanente Information Technology        *\n         *            Walnut Creek, CA 94598                          *\n         *            (925) 926-5332                                  *\n         *            Internet: lionel.b.dyck@kp.org                  *\n         *                                                            *\n         * History:                                                   *\n         *            02/09/01 - creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- */\n         arg volser\n         if length(volser) = 0 then do\n            say 'Error: no volser provided.'\n            say 'Ending........try again.'\n            exit 8\n            end\n         temp = \"temp.compvtoc\"\n         \"Alloc f(sysin) ds(\"temp\".sysin) new spa(1,1) tr\",\n            \"Recfm(f b) lrecl(80) blksize(0) reuse\"\n         \"Alloc f(sysprint) ds(\"temp\".list) new spa(1,1) tr\" ,\n            \"recfm(f b a) lrecl(121) blksize(0) reuse\"\n         \"Alloc f(\"volser\") unit(3390) vol(\"volser\") reuse shr\",\n            \"ds('sys1.linklib')\"\n         sysin.1 = \" LISTVTOC VOL=3390=\"volser\n         \"Execio * diskw sysin (finis stem sysin.\"\n         \"Call 'sys1.linklib(iehlist)'\"\n         \"Execio * diskr sysprint (finis stem list.\"\n         \"Free f(sysin sysprint) delete\"\n         \"Free f(\"volser\")\"\n         \"Alloc f(sysin) ds(*)\"\n         \"Alloc f(sysprint) ds(*)\"\n         if list.0 = 0 then do\n            say \"Error reading vtoc\"\n            say \"Ending....\"\n            exit 8\n            end\n         say \"Reporting on Volume:\" volser \"on system\" mvsvar(\"sysname\")\n         say \"All data sets on the volume and NOT in the Catalog\" ,\n             \"will be reported.\"\n         say \" \"\n         do i = 1 to list.0\n            if left(list.i,4) = \" ---\" then leave\n            end\n         do j = i+1 to list.0\n            if left(list.j,1) = \"1\" then iterate\n            if left(list.j,2) = \"  \" then iterate\n            parse value list.j with 2 dsname .\n            stat = sysdsn(\"'\"dsname\"'\")\n            if stat = \"OK\" then iterate\n            say \"dsname:\" left(dsname,50)\n            end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONCATIT": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01 #o\\x01 #o\\t\\x08\\x02*\\x02*\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-08-23T00:00:00", "modifydate": "2020-08-23T09:08:39", "lines": 554, "newlines": 554, "modlines": 0, "user": "SLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "CONS": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Q\\x01\\x16\\x06\\x8f\\x01\\x16\\x06\\x9f\\x13\\x10\\x00\\x9d\\x00\\x9d\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2016-03-08T00:00:00", "modifydate": "2016-03-09T13:10:51", "lines": 157, "newlines": 157, "modlines": 0, "user": "SYSLBD"}, "text": "        /* ---- REXX -------------------------------------- *\n         * Name:     CONS                                   *\n         *                                                  *\n         * Function: Invoke a z/OS Console command and      *\n         *           then display the results               *\n         *                                                  *\n         * Usage:    To execute a z/OS command and then     *\n         *           display the results.                   *\n         *                                                  *\n         *           If the command is called under ISPF    *\n         *           directly the resulting messages will   *\n         *           be placed into ISPF Browse.            *\n         *                                                  *\n         *           If called by another commaand (such    *\n         *           as TSOTRAP then the results are        *\n         *           displayed using SAY and are            *\n         *           trapable by OUTTRAP in REXX            *\n         *                                                  *\n         *           This command is best used if it is     *\n         *           added to an ISPF Command Table         *\n         *                                                  *\n         *           This can be done by calling it the     *\n         *           first time each ISPF session with      *\n         *           a parameter of add:                    *\n         *                                                  *\n         *           e.g. TSO %CONS ADD                     *\n         *                                                  *\n         * Notes:    The GETMSG function has a default of   *\n         *           30 seconds to wait for the response    *\n         *           of the z/OS Command.  This is typical  *\n         *           for START commands and perhaps others. *\n         *           If the GETMSG time's out then no data  *\n         *           will be displayed.                     *\n         *                                                  *\n         *           If the command responds before the     *\n         *           wait time is exhausted then the        *\n         *           results are captured and displayed     *\n         *           without waiting for the full wait      *\n         *           time to expire.                        *\n         *                                                  *\n         * History:                                         *\n         *          03/08/2016 - Use STEMVIEW if installed  *\n         *                       (see *custom*)             *\n         *                     - get realistic lrecl based  *\n         *                       on the captured messages   *\n         *          03/07/2016 - Add new option to update   *\n         *                       the ispcmds table          *\n         *          03/01/2016 - cleanup and re-write       *\n         *                                                  *\n         * Author:  Lionel B. Dyck                          *\n         * ------------------------------------------------ */\n\n        /* ------------------------- *\n         * Retrieve the z/OS command *\n         * ------------------------- */\n        arg cmd\n\n        /* -------------------------------------- *\n         * Test to see if a command was provided. *\n         * Exit if not.                           *\n         * -------------------------------------- */\n        if length(cmd) = 0 then do\n           say \"No command passed...\"\n           exit 8\n           end\n\n        /* -------------------------------------------------- *\n         * Test for single word command of ADD and if so then *\n         * add CONS to the ISPCMDS ISPF Command Table.        *\n         * -------------------------------------------------- */\n         if strip(cmd) = \"ADD\" then do\n            zctverb  = sysvar('sysicmd')\n            zcttrunc = length(zctverb)\n            zctact   = \"SELECT CMD(%\"SYSVAR('SYSICMD')\" &ZPARM)\"\n            zctdesc = \"Dynamically added\" date() time()\n            address ISPExec \"TBAdd ISPCMDS\"\n            exit 0\n            end\n\n        /* --------------- *\n         * Define Defaults *\n         * *custom*        *\n         * --------------- */\n         stemview = 1   /* set to 0 if stemview is not installed */\n\n        /* ------------------------------------- *\n         * Setup the CONSOLE command environment *\n         * ------------------------------------- */\n        \"CONSPROF SOLDISP(no) SOLNUM(400) UNSOLDISP(yes)\"\n        \"CONSOLE ACTIVATE\"\n\n        /* --------------------------------- *\n         * Execute the provided z/OS Command *\n         * --------------------------------- */\n        \"CONSOLE SYSCMD(\"cmd\") \"\n\n        /* --------------------------------------------------------------- *\n         * Retrieve the results of the z/OS Command.                       *\n         *                                                                 *\n         * Note that the default wait time is 30 seconds. That value       *\n         * can be changed to any time frame that you need. Be aware that   *\n         * it is a maximum wait time and that if the command ends before   *\n         * that limit is reached then the results will be returned without *\n         * waiting for the wait time to expire.                            *\n         * --------------------------------------------------------------- */\n        rc = GETMSG('t.','sol',,,30)\n\n        /* --------------------------------- *\n         * Close out the CONSOLE environment *\n         * --------------------------------- */\n        \"CONSOLE DEACTIVATE\"\n\n        /* -------------------------------------------------- *\n         * Test the GETMSG returned message stem and if it    *\n         * is not numeric then we know that the wait time was *\n         * exhausted waiting for the results of the z/OS      *\n         * command.                                           *\n         * -------------------------------------------------- */\n        if datatype(t.0) /= \"NUM\" then do\n           say \"Error - the command\" cmd ,\n               \"did not respond within 30 seconds\" ,\n               \"so no data was captured.\"\n               exit 4\n               end\n\n        /* ----------------------------------------- *\n         * Test to see if we were called directly or *\n         * if another command called us.             *\n         * ----------------------------------------- */\n         sayit = 1\n         if sysvar(sysispf) /= \"ACTIVE\" then sayit = 0\n         if sysvar(sysnest) = \"YES\" then sayit = 0\n         if sayit = 0 then\n            do i = 1 to t.0\n               say t.i\n               end\n         if sayit = 1 then do\n            maxl = 0\n            do i = 1 to t.0\n               if maxl < length(t.i) then maxl = length(t.i)\n               end\n            if stemview = 1 then do\n               CALL stemview 'Browse','T.',,,'TSO Console',,maxl\n               end\n            else do\n               cmd_dd = \"C\"random()\n               \"Allocate File(\"cmd_dd\") Reuse Unit(vio) Space(1 1)\" ,\n                        \"CYL Dsorg(ps) Recfm(v b) Lrecl(\"maxl\")\"\n               \"Execio * Diskw\" cmd_dd \"(Stem t. Finis)\"\n               Address ISPExec\n               \"LMinit Dataid(dataid) DDname(\"cmd_dd\")\"\n               \"Browse Dataid(\"dataid\")\"\n               \"LMfree Dataid(\"dataid\")\"\n               Address TSO\n               \"Free File(\"cmd_dd\")\"\n               end\n            end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYFB": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\t\\x01\\x16\\x08\\x1f\\x01\\x16\\tO\\x15\\x00\\x00F\\x00F\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-03-21T00:00:00", "modifydate": "2016-04-03T15:00:09", "lines": 70, "newlines": 70, "modlines": 0, "user": "SYSLBD"}, "text": "        /* --------------------  rexx procedure  -------------------- *\n         * Name:      COPYFB                                          *\n         *                                                            *\n         * Function:  ISPF Edit Macro to Copy the current member      *\n         *            into the predefined FB library.                 *\n         *                                                            *\n         *            This macro invokes the ISPF Edit REPLACE        *\n         *            command to create or replace the member.        *\n         *                                                            *\n         * Syntax:    COPYFB                                          *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *                                                            *\n         * History:                                                   *\n         *            03/21/16 - Creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- */\n         Address ISREdit\n         \"Macro\"\n\n        /* --------------- *\n         * Define defaults *\n         * --------------- */\n         target = \"lionel.execfb\"\n\n        /* ------------------------------------------------- *\n         * Test to see if there is any data beyond column 80 *\n         * and if so let the user know before proceeding.    *\n         * ------------------------------------------------- */\n         \"(lrecl) = LRECL\"\n         \"find p'\u00ac' First 81\" lrecl-4\n         if rc = 0 then do\n            \"Exclude All\"\n            \"find p'\u00ac' ALL 81\" lrecl-4\n            data = \"The following records have data beyond\"\n            \"line_before .zfirst = noteline '\"data\"'\"\n            data = \"column 80 and must be corrected before\"\n            \"line_before .zfirst = noteline '\"data\"'\"\n            data = \"using this macro to copy the member.\"\n            \"line_before .zfirst = noteline '\"data\"'\"\n            exit 4\n            end\n\n        /* ---------------------------------------- *\n         * Test to see if the member already exists *\n         * ---------------------------------------- */\n         \"(member) = Member\"\n         newmem = target\"(\"member\")\"\n\n        /* ----------------------------------------------- *\n         * Perform the Create or Replace using the Replace *\n         * command which will create the member if it does *\n         * not already exist.                              *\n         * ----------------------------------------------- */\n        \"Replace\" newmem .zfirst .zlast\n\n        /* ------------------------------------------- *\n         * Now change the userid for the copied member *\n         * ------------------------------------------- */\n        Address TSO,\n        \"Alloc f(sysut2) ds(\"target\") shr reuse\"\n        Address ISPExec\n        \"LMINIT DATAID(DATAID) DDNAME(SYSUT2)\"\n        \"LMOPEN DATAID(\"dataid\")\"\n        \"LMMSTATS DATAID(\"dataid\") Member(\"member\")\",\n                  \"User(SYSLBD)\"\n        \"LMCLOSE DATAID(\"dataid\")\"\n        \"LMFREE  DATAID(\"dataid\")\"\n        Address TSO,\n        \"free f(sysut2)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSVEDIT": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x01\\x08\\x10o\\x01\\x08\\x10o\\x11\\x10\\x02\\x1e\\x02\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2008-04-15T00:00:00", "modifydate": "2008-04-15T11:10:00", "lines": 542, "newlines": 542, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "CSVEDIT#": {"ttr": 6408, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x01\\x08\\x10o\\x01\\x08\\x10o\\x11\\x12\\t\\xed\\t\\xed\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2008-04-15T00:00:00", "modifydate": "2008-04-15T11:12:00", "lines": 2541, "newlines": 2541, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "CSVEDIT@": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x01\\x08\\x10o\\x01\\x08\\x10o\\x11\\x12\\x05\\x9a\\x05\\x9a\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2008-04-15T00:00:00", "modifydate": "2008-04-15T11:12:00", "lines": 1434, "newlines": 1434, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "CUTPASTE": {"ttr": 8195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x18\\x7f\\x00\\x99\\x18\\x7f\\x18@\\x05.\\x05.\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-07-06T00:00:00", "modifydate": "1999-07-06T18:40:00", "lines": 1326, "newlines": 1326, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "DDLIST": {"ttr": 8708, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x03'?\\x01\\x03'?\\t3\\x06G\\x06G\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-09-30T00:00:00", "modifydate": "2003-09-30T09:33:00", "lines": 1607, "newlines": 1607, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "DDLIST$": {"ttr": 9225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x12\\x01\\x03'/\\x01\\x03'/\\x07)\\x00\\x06\\x00\\x05\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-29T00:00:00", "modifydate": "2003-09-29T07:29:12", "lines": 6, "newlines": 5, "modlines": 0, "user": "SYSLBD"}, "text": "Change History\n\n9/29/2003: Updated with addition on missing DDINFO* panels\n           ** added RECEIVE member to rebuild the installation libraries\n\n           ** major revisions thanks to John Bloniarz\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DOALL": {"ttr": 9227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x00\\x08?\\x01\\x161O\\x07D\\x008\\x00<\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf3\\xf1\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-03-23T00:00:00", "modifydate": "2016-11-09T07:44:49", "lines": 56, "newlines": 60, "modlines": 0, "user": "FILE312"}, "text": "/* ---------------------  rexx procedure  ---------------------- *\n * Name:      DoAll                                              *\n *                                                               *\n * Function:  This rexx exec will process the specified          *\n *            ispf edit macro against every member of the        *\n *            specified partitioned dataset.                     *\n *                                                               *\n *            Only standard system services are used. The        *\n *            LISTD TSO command with the MEMBERS keyword         *\n *            is used to extract the member names.               *\n *                                                               *\n * Syntax:    %DoAll dsname edit-macro                           *\n *                                                               *\n * Sample Edit Macro to change SYS1 to SYS2                      *\n *  * rexx exec chsys1t2 (change sys1 to sys2) *                 *\n *  (the / was removed from the above line to avoid syntax       *\n *   errors in this exec).                                       *\n *  Address ISREDIT                                              *\n *  \"MACRO\"                                                      *\n *  \"CHANGE 'DSN=SYS1.' 'DSN=SYS2.' ALL\"                         *\n *  \"SAVE\"                                                       *\n *  \"END\"                                                        *\n *                                                               *\n * Sample Execution:  %Doall 'sys2.testjcl' chsys1t2             *\n *                                                               *\n * Author:    Lionel B. Dyck                                     *\n *            Internet: lbdyck@gmail.com                         *\n *                                                               *\n * History:   11/30/90 - created                                 *\n *                                                               *\n * ------------------------------------------------------------- */\n\narg dsn exec\n\nif left(dsn,1) <> \"'\" then do\n   dsn = sysvar(syspref)\".\"dsn\n   end\n   else do\n        dsn = substr(dsn,2,length(dsn)-2)\n        end\n\nx = outtrap(\"lm.\",\"*\")\n\n\"LISTD\" \"'\"dsn\"'\" \"MEMBERS\"\n\nx = outtrap(\"off\")\n\ndo i = 1 to lm.0\n   if lm.i = \"--MEMBERS--\" then leave\n   end\n\ndomem:  do j = i+1 to lm.0\n        parse value lm.j with mem extra\n        Address ISPEXEC \"EDIT DATASET('\"dsn\"(\"mem\")')\" ,\n                        \"MACRO(\"exec\")\"\n        end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DROPISPF": {"ttr": 9229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x184\\x0f\\x01\\x184\\x0f\\x07\\x18\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xc9\\xe2\\xd7\\xc6@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-12-06T00:00:00", "modifydate": "2018-12-06T07:18:14", "lines": 28, "newlines": 28, "modlines": 0, "user": "LOADISPF"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\n DropISPF: Procedure\n arg load_info\n Address ISPEXEC\n do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n       if libd = \"ALTLIBC\" then lib = \"CLIST\"\n                           else lib = \"EXEC\"\n       Address TSO,\n         \"Altlib Deact Application(\"lib\")\"\n       end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n    end\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSLIST": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x00\\x04o\\x01\\x00\\x04o!@\\x00j\\x00j\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-15T00:00:00", "modifydate": "2000-02-15T21:40:06", "lines": 106, "newlines": 106, "modlines": 0, "user": "SYSLBD"}, "text": "/* ---------------------  rexx procedure  ---------------------- *\n * Name:      dslist                                             *\n *                                                               *\n * Function:  Invoke ISPF 3.4 with the provided high level index *\n *                                                               *\n * Syntax:    %dslist hlq                                        *\n *                                                               *\n * Installation:                                                 *\n *                                                               *\n *            To install this application do the following:      *\n *                                                               *\n *            1.  Copy this exec into your production clist      *\n *                or exec library                                *\n *                                                               *\n *            2.  Update your ISPCMDS table to add the following *\n *                entry by:                                      *\n *                a. copy your production ISPCMDS into member    *\n *                   TCMDS                                       *\n *                b. use ISPF 3.9 to update applid 'T' and       *\n *                   add the entry:                              *\n *                   Verb:   DSLIST                              *\n *                   T:      3                                   *\n *                   Action: Select CMD(%DSLIST &ZPARM)          *\n *                   Desc:    Data set list (via LMDDISP)        *\n *                c. Rename ISPCMDS to OSPCMDS and TCMDS to      *\n *                   ISPCMDS                                     *\n *                d. Exit ISPF and re-enter ISPF                 *\n *                                                               *\n *            3.  Try it out (e.g. Command ===> DSL SYS1)        *\n *                                                               *\n * Author:    Lionel B. Dyck                                     *\n *                                                               *\n * History:                                                      *\n *            01/10/95 - Strip quotes and add support for        *\n *                       2nd pass with users prefix              *\n *            05/20/94 - additional cleanup                      *\n *            05/20/94 - cleanup and additional doc              *\n *            05/19/94 - created by Lionel Dyck                  *\n *                                                               *\n * ------------------------------------------------------------- */\n\narg hlq\n\norig_hlq = \"\"\nfirst    = 0\n\nhlq = strip(hlq,'b',\"'\")    /* remove any quotes */\n\nBegin_Here:\nAddress ISPExec\n\nif length(hlq) = 0 then do\n   zedsmsg = \"Error\"\n   zedlmsg = \"Invalid syntax for command\"\n   \"Setmsg Msg(isrz000)\"\n   exit 0\n   end\n\ndsl = translate(hlq,\" \",\".\")\nif words(dsl) > 1 then\n   if right(hlq,1) <> \"*\" then\n      if length(word(dsl,words(dsl))) < 8 then hlq = hlq\"*\"\n\n\"Control Errors Return\"\n\n\"LMDINIT LISTID(LISTID) LEVEL(\"hlq\")\"\nl_rc = rc\nif l_rc > 0 then do\n   zedsmsg = \"\"\n   Select\n     When l_rc = 8 then zedlmsg = \"Listid not created for\" hlq\n     When l_rc = 12 then\n          zedlmsg = \"Invalid high level qualifier:\" hlq\n     When l_rc = 16 then\n          zedlmsg = \"Truncation or translation error in dialog\",\n                 \"variables.\"\n     When l_rc = 20 then\n          zedlmsg = \"Severe Error in ISPF Processing\"\n     otherwise\n          zedlmsg = \"Unknown error in LMDINIT\"\n   end\n   zedsmsg = \"\"\n   \"Setmsg Msg(isrz000)\"\n   exit 4\n   end\n\n\"LMDDISP LISTID(\"ListId\") Confirm(Yes)\",\n        \"View(Volume)\"\nl_rc = rc\nif l_rc > 0 then do\n   if first = 0 then do\n      first = 1\n      hlq = sysvar('syspref')\".\"hlq\n      signal begin_here\n      end\n      else hlq = orig_hlq\n   end\n if l_rc > 0 then do\n    zedsmsg = \"Nothing\"\n    zedlmsg = \"No data sets found for index:\" hlq\n   \"Setmsg Msg(isrz000)\"\n    exit 4\n    end\n\n\"LMDFREE LISTID(\"ListId\")\"\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DUMPMGMT": {"ttr": 9476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01&\\x8f\\x01\\x01&\\x8f\\x16I\\x05Y\\x05Y\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-09-25T00:00:00", "modifydate": "2001-09-25T16:49:00", "lines": 1369, "newlines": 1369, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "EDITMAC": {"ttr": 9990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01 !\\x1f\\x01 !/\\x06(\\x00\\x9d\\x00\\x97\\x00\\x00\\xc5\\xc4\\xc9\\xe3\\xd4\\xc1\\xc3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-07-29T00:00:00", "modifydate": "2020-07-30T06:28:03", "lines": 157, "newlines": 151, "modlines": 0, "user": "EDITMAC"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n  | Name:      EDITMAC                                         |\n  |                                                            |\n  | Function:  ISPF Edit Macro to Execute an inline Edit       |\n  |            macro within the active Edit Data               |\n  |                                                            |\n  | Usage Notes: Insert an edit macro inline in the edit data  |\n  |              for processing by the EDITMAC command.        |\n  |                                                            |\n  |              <EM> starts the inline macro                  |\n  |              . . . any rexx edit macro code here           |\n  |              </EM> ends the inline macro                   |\n  |                                                            |\n  |              Placement should probably be as close to      |\n  |              the top of the data as possible.              |\n  |                                                            |\n  |              Suggest making the inline edit macro a        |\n  |              comment for the data it resides in and        |\n  |              use the offset parm if the comment is in      |\n  |              column 1.                                     |\n  |                                                            |\n  | Syntax: EDITMAC <offset>                                   |\n  |                                                            |\n  |         offset is the number of columns to skip to         |\n  |         extract the edit macro code thus ignoring any      |\n  |         comment characters.                                |\n  |                                                            |\n  | Dependencies: none                                         |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            07/29/20 LBD - delete temp d/s in case          |\n  |            07/28/20 LBD - creation                         |\n  |                                                            |\n  * ---------------------------------------------------------- *\n  | Find at https://www.lbdsoftware.com                        |\n  |      or https://github.com/lbdyck                          |\n  * ---------------------------------------------------------- *\n  | NOTE: This function is also available in RUNC that         |\n  |       supports many more capabilities.                     |\n  * ---------------------------------------------------------- */\n  Address ISREdit\n  /* --------------------------------- *\n  | Define ourselves as an Edit Macro |\n  * --------------------------------- */\n  'Macro (offset)'\n\n  /* ------------------------ *\n  | Define default variables |\n  * ------------------------ */\n  null = ''\n  r = 0\n  hit = 0\n\n  /* ------------------------ *\n  | Validate the offset parm |\n  * ------------------------ */\n  if datatype(offset) /= 'NUM'\n  then offset = 1\n  if offset = 0 then offset = 1\n\n  /* ------------------------------------------------- *\n  | Get the last line of the active Edit session data |\n  * ------------------------------------------------- */\n  '(last) = linenum .zlast'\n\n  /* -------------------------------------------------------- *\n  | Process the data records to find the inline edit macro   |\n  | and place the edit macro records into a stem variable.   |\n  |                                                          |\n  | The edit macro starts with <EM> and ends with </EM>      |\n  |                                                          |\n  | The offset is used to skip over text in the records that |\n  | may be comments.                                         |\n  * -------------------------------------------------------- */\n  do i = 1 to last\n    '(data) = line' i\n    /* --------------------------------- *\n    | Extract the record from the data, |\n    | skipping over the offset.         |\n    * --------------------------------- */\n    data = strip(substr(data,offset))\n    /* ------------------------------------------ *\n    | Test for <EM> to start the data collection |\n    | and for </EM> to stop the data collection  |\n    * ------------------------------------------ */\n    if translate(left(data,4)) = '<EM>' then do\n      hit = 1\n      iterate\n    end\n    if translate(left(data,5)) = '</EM>' then do\n      hit = 0\n      leave\n    end\n    /* -------------------------------------------- *\n    | If hit is 0 then we are not collecting data. |\n    | If it is 1 then save the current record for  |\n    | processing.                                  |\n    * -------------------------------------------- */\n    if hit = 0 then iterate\n    r = r + 1\n    rec.r = data\n  end\n  /* ----------------------------------- *\n  | Save the number of records in rec.0 |\n  * ----------------------------------- */\n  rec.0 = r\n\n  /* ------------------------------- *\n  | Was an inline edit macro found? |\n  * ------------------------------- */\n  if r = 0 then do\n    zedsmsg = null\n    zedlmsg = 'EDITMAC did not find any edit macro to execute.' ,\n      'Check to see if an offset should be used.'\n    Address ISPExec 'setmsg msg(isrz001)'\n    exit\n  end\n\n  /* ----------------------------------------------- *\n  | Define a temporary DDname and Dataset name.     |\n  | Allocate the temporary PDS and write the inline |\n  | edit macro's records to it.                     |\n  | Then Altlib the temporary PDS.                  |\n  * ----------------------------------------------- */\n  emdd = 'EMDD'random(4)\n  if sysvar('syspref') /= null\n  then emds = \"'\"sysvar(\"syspref\")\".temp.\"emdd\n  else emds = \"'\"sysvar(\"sysuid\")\".temp.\"emdd\n  emdslib = emds\"'\"\n  call outtrap 'x.'\n  address tso 'delete' emdslib\n  call outtrap 'off'\n  emds = emds\"(edmac)'\"\n  Address TSO\n  'alloc f('emdd') new space(1,1) tr recfm(v b) lrecl(255) blksize(0)' ,\n    'da('emds') dsorg(po) dir(1)'\n  'execio * diskw' emdd '(finis stem rec.'\n  'altlib act app(exec) da('emdslib')'\n\n  /* -------------------------------- *\n  | Setup error environment          |\n  | Now invoke the inline edit macro |\n  * -------------------------------- */\n  Address ISPExec 'control errors return'\n  Address isredit\n  '%edmac'\n\n  /* -------------------------------------------------- *\n  | All done so free up the ALTLIB and Free and Delete |\n  | the temporary PDS.                                 |\n  * -------------------------------------------------- */\n  Address TSO\n  'altlib deact app(exec)'\n  'free f('emdd') delete'\n  Exit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDSL": {"ttr": 9994, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01,\\x00)\\x01 )\\x7f\\x01 4O\\x08\\x02\\n\\xbd\\x06\\x13\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.44", "flags": 0, "createdate": "2020-10-23T00:00:00", "modifydate": "2020-12-09T08:02:29", "lines": 2749, "newlines": 1555, "modlines": 0, "user": "SLBD"}, "text": "  /* --------------------  rexx procedure  ------------------- */\n  ver = '1.46'\n  /* Name:      edsl                                           |\n  |                                                            |\n  | Function:  Enhanced Data Set List ISPF Applications        |\n  |                                                            |\n  | Syntax:    %edsl                                           |\n  |        or  %edsl action member                             |\n  |        or  %edsl action group member                       |\n  |        or  %edsl group  (defaults to Select group)         |\n  |                                                            |\n  | Usage Notes:  1. Non-standard commands only work on        |\n  |                  individual datasets                       |\n  |                                                            |\n  | Dependencies: All ISPF panels are inline                   |\n  |                                                            |\n  | Authors:     Lionel B. Dyck                                |\n  |              John Kalinich                                 |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |    1.46    12/08/20 JK  - Add QREF to / popup              |\n  |    1.45    12/08/20 LBD - Allow O for datasets (D)         |\n  |    1.44    11/18/20 JK  - Add ISPList command (Tree)       |\n  |    1.43    11/16/20 JK  - Add QREF primary command         |\n  |    1.42    11/16/20 JK  - Update header logic (Tree)       |\n  |    1.41    11/14/20 JK  - Add / primary command (Tree)     |\n  |    1.40    11/13/20 JK  - Edit EDSHELP skeleton            |\n  |    1.39    11/12/20 JK  - Add HEL primary command          |\n  |    1.38    11/12/20 LBD - Correct exit after Set change    |\n  |    1.37    11/11/20 JK  - If SET changes view, then branch |\n  |    1.36    11/11/20 JK  - Correct dataset logic (Tree)     |\n  |                         - Update cursor select (Tree)      |\n  |    1.35    11/10/20 LBD - Fix group in tree for dataset    |\n  |                         - Change TBDISPL to TABLE in Set   |\n  |                         - Change tree TABLE to DEBUG       |\n  |                         - Add TABLE to commands in Tree    |\n  |    1.34    11/10/20 JK  - Add callable Version routine     |\n  |                         - Add SET command                  |\n  |    1.33    11/09/20 LBD - Fix add/update of OMVS file      |\n  |                         - Update version prose             |\n  |    1.32    11/08/20 JK  - Add / line command (Tree)        |\n  |                         - Add M/N line commands (Tree)     |\n  |                         - Add VERSION primary cmd (Tree)   |\n  |    1.31    11/01/20 JK  - Colorize nodes (Tree)            |\n  |                         - Add X ALL primary command (Tree) |\n  |                         - Add INSERT primary command (Tree)|\n  |                         - Add E/V/B/S line commands (Tree) |\n  |                         - Add O/I/U/D line commands (Tree) |\n  |                         - Add X toggle line command (Tree) |\n  |                         - Cursor position S line cmd (Tree)|\n  |    1.30    10/27/20 LBD - Add TREE to / Primary popup menu |\n  |                         - right justify rows in tree       |\n  |    1.29    10/27/20 JK  - Add TREE primary command         |\n  |    1.28    10/27/20 LBD - Fix lost dsn during update       |\n  |    1.27    10/27/20 LBD - Correct check of xxx.* entries   |\n  |    1.26    10/26/20 LBD - Check list of datasets and force |\n  |                           to type List if mixed format     |\n  |    1.25    10/26/20 LBD - Correct PNS for Find in popup    |\n  |                         - add find string field to popup   |\n  |                         - improve find results message     |\n  |    1.24    10/23/20 JK  - Add / primary command            |\n  |    1.23    10/23/20 JK  - Change EDSLG pop-up size/location|\n  |    1.22    10/21/20 LBD - Enhance update process           |\n  |    1.21    10/20/20 LBD - Correct panel logic in edslg     |\n  |    1.20    10/20/20 LBD - Set MEMLIST to 9 chars and remove|\n  |                           option from panel and tutorial   |\n  |    1.19    10/20/20 LBD - Correct command line options     |\n  |    1.18    10/20/20 LBD - Fix duplicate action with cmd    |\n  |    1.17    10/20/20 LBD - Use DSN for Group if Group null  |\n  |                           and only 1 dsn                   |\n  |    1.16    10/20/20 LBD - Tutorial cleanup/enhancements    |\n  |    1.15    10/19/20 LBD - Performance/other improvements   |\n  |    1.14    10/19/20 LBD - Add display info to popups       |\n  |    1.13    10/17/20 LBD - Fix reorder check and add popup  |\n  |                           for type null selections         |\n  |    1.12    10/17/20 LBD - Add popups for update/review     |\n  |                         - Add popup for / selection        |\n  |    1.11    10/17/20 LBD - Clean up tutorial panels         |\n  |    1.10    10/16/20 LBD - Enhance Tutorial                 |\n  |                         - Increase from 8 to 16 datasets   |\n  |    1.09    10/16/20 LBD - Enhance Move - and +             |\n  |                         - Improve tutorial                 |\n  |    1.08    10/15/20 LBD - If rows = 0 then do insert       |\n  |                           and issue message about it       |\n  |    1.07    10/15/20 LBD - Add bottom of table ztdmark      |\n  |    1.06    10/13/20 LBD - Allow update of Group only       |\n  |                         - Truncate group name to 8 for     |\n  |                           dslist refname                   |\n  |    1.05    10/10/20 LBD - Tutorial Update for OMVS updates |\n  |                         - Add MD (move down) and M# to     |\n  |                           move to a specific location      |\n  |            10/09/20 LBD - Support OMVS files/directories   |\n  |                           - only 1 per group               |\n  |            10/07/20 LBD - Use 1st 8 usable chars of group  |\n  |                           name for DSList                  |\n  |            09/30/20 LBD - Use Group if provided for 1 dsn  |\n  |            09/29/20 LBD - Cleanup display name             |\n  |                         - Alias C to U for update/change   |\n  |            09/26/20 LBD - Randomize dd name                |\n  |            09/20/20 LBD - Enable row select with Enter     |\n  |                         - Enable any command on type D     |\n  |                         - Allow dsn.* with no group        |\n  |                     JK  - Add History Command to display   |\n  |                           the change history of EDSL       |\n  |            09/11/20 LBD - Save member list size            |\n  |                         - Improve entry with group name    |\n  |            09/09/20 LBD - Support * in dataset names       |\n  |            09/07/20 LBD - Support Find and bug fixes       |\n  |            09/06/20 LBD - Small bug fix if used in SYSPROC |\n  |            09/05/20 LBD - Use Group name for DSLIST        |\n  |            09/04/20 LBD - Make L an alias of U             |\n  |                         - Option O to open in DSList       |\n  |            09/01/20 LBD - Option Memlist Size added        |\n  |                         - Always run applid=ISR            |\n  |            08/30/20 LBD - Use 9 char memlist               |\n  |            08/10/20 LBD - Open table shared                |\n  |            08/04/20 LBD - Support Edit/Browse/View on zcmd |\n  |            08/03/20 LBD - Refinement                       |\n  |            08/01/20 LBD - Creation                         |\n  |                                                            |\n  * ---------------------------------------------------------- */\n\n  arg options\n\n  parse value '' with null called\n  dd = '$'right(time(\"s\"),7,\"0\")     /* create unique ddname */\n\n  signal on failure\n  signal on syntax\n\n  /* ----------------------- *\n  | Define ISPF Environment |\n  * ----------------------- */\n  Address ISPEXEC\n  'control errors return'\n\n  /* ------------------------ *\n  | Always run in applid ISR |\n  * ------------------------ */\n  'vget (zapplid)'\n  if zapplid /= 'ISR' then do\n    parse source with x cmd .\n    'select cmd('cmd options') newappl(isr)'\n    exit\n  end\n\n  /* ---------------------- *\n  | Check for Debug option |\n  * ---------------------- */\n  if options = 'DEBUG' then do\n    trace '?i'\n    options = null\n    end\n\n  /* ---------------------------- *\n  | Open the data set list table |\n  * ---------------------------- */\n  call open_table\n\n  /* ---------------------------- *\n  | Dynamically load ISPF Panels |\n  * ---------------------------- */\n  load_info = loadispf()\n\n  /* --------------------------- *\n  | Process any provide options |\n  * --------------------------- */\n  if options /= null then do\n    if words(options) = 1 then do\n      options = 'S' options\n    end\n    call do_options\n  end\n\n  /* ----------------------- *\n  | Display Selection Table |\n  * ----------------------- */\n  'vget (edsinit)'\n  if edsinit = 'TREE' then do        /* Dynamic--display tree format  */\n    listit = 0\n    call do_tree\n    if listit = 0 then call done\n    end\n  table_top = 1\n  ztdsels = 0\n  do forever\n    'tbquery edsl rownum(rows)'\n    if rows = 0 then call do_insert\n    parse value null with rsel rmem zcmd\n    if ztdsels > 1 then\n    'tbdispl edsl'\n    else do\n      'tbtop edsl'\n      'tbskip edsl number('table_top')'\n      'tbdispl edsl panel(edsl)'\n      table_top = ztdtop\n    end\n    if rc > 4 then call done\n\n    /* --------------------------- *\n    | Process Enter for selection |\n    * --------------------------- */\n    if rowid > 0\n    then if zcmd = null\n    then if rsel = null\n    then do\n      'tbtop edsl'\n      'tbskip edsl number('rowid')'\n      rsel = 'S'\n    end\n\n    /* ---------------------------- *\n    | Process any primary commands |\n    * ---------------------------- */\n    if zcmd /= null then do\n    Select\n      When abbrev('/',zcmd,1) = 1 then do\n        parse value '' with zcmd fstring\n        call pfshow 'off'\n        'Addpop Row(4) column(15)'\n        'Display Panel(edspo)'\n        'rempop'\n        call pfshow 'reset'\n        if zcmd = 'F' then\n           if fstring /= null\n              then zcmd = zcmd fstring\n      end\n      Otherwise nop\n    end\n    Select\n      When abbrev('INSERT',zcmd,1) = 1 then call do_insert '1'\n      When abbrev('FIND',word(zcmd,1),1) = 1 then call do_find\n      When abbrev('TREE',word(zcmd,1),1) = 1 then call do_tree\n      When abbrev('SET',word(zcmd,1),1)  = 1 then do\n        'vget (edsinit)'\n        save_init = edsinit\n        call do_settings\n        if edsinit = 'TREE' &,\n           save_init <> edsinit then do\n          listit = 0\n          call do_tree\n          call done\n          end\n        end\n      When abbrev('VERSION',word(zcmd,1),1) = 1 then call do_version\n      when abbrev(\"QREF\",word(zcmd,1),1) = 1 then do\n        zcmd = ''\n        \"select pgm(isptutor) parm(edsqref)\"\n        end\n      When abbrev(\"HEL\",word(zcmd,1),3) = 1 then call do_help\n      When abbrev(\"HISTORY\",word(zcmd,1),1) = 1 then do\n        zcmd = ''\n        call do_history\n      end\n      When words(zcmd) = 2 | words(zcmd) = 3 then do\n        options = zcmd\n        call do_options\n        parse value '' with options rsel zcmd\n      end\n      Otherwise nop\n    end\n    end\n    else\n    /* ------------------------------- *\n    | Process row selection commands  |\n    | selection value process all     |\n    | selection value null only a few |\n    * ------------------------------- */\n    if rsel = '/' then do\n      call pfshow 'off'\n      'Addpop Row(4) column(15)'\n      if edstype /= null\n      then 'Display Panel(edslo)'\n      else 'Display Panel(edslos)'\n      'rempop'\n      call pfshow 'reset'\n      rsel = zcmd\n      zcmd = null\n    end\n    if rsel /= null then do\n      if edstype /= null then\n      Select\n        When rsel = 'B' then call do_bev\n        When rsel = 'D' then 'tbdelete edsl'\n        When rsel = 'E' then call do_bev\n        When rsel = 'V' then call do_bev\n        When rsel = 'I' then call do_insert\n        When rsel = 'M' then do\n          rsel = 'M-1'\n          call do_MoveRow\n        end\n        When rsel = 'MD' then do\n          rsel = 'M1'\n          call do_MoveRow\n        end\n        when left(rsel,1) = 'M' then call do_MoveRow\n        When rsel = 'O' then call do_OpenDSL\n        When rsel = 'R' then call do_review\n        When rsel = 'S' then call do_bev\n        When rsel = 'U' then call do_update\n        When rsel = 'C' then call do_update\n        Otherwise call do_other\n      end\n      else\n      Select\n        When rsel = 'U' then call do_update\n        When rsel = 'C' then call do_update\n        When rsel = 'D' then 'tbdelete edsl'\n        When rsel = 'I' then call do_insert\n        When rsel = 'M' then do\n          rsel = 'M-1'\n          call do_MoveRow\n        end\n        When rsel = 'MD' then do\n          rsel = 'M1'\n          call do_MoveRow\n        end\n        when left(rsel,1) = 'M' then call do_MoveRow\n        Otherwise call do_other\n      end\n    end\n    rsel = null\n    zcmd = null\n  end\n\n  /* --------------------------------------------------------- *\n  | Done so close the table, free the dynamic ispf resources, |\n  | and then exit.                                            |\n  * --------------------------------------------------------- */\nDone:\n  'tbclose edsl library(isptabl)'\n  x = dropispf(load_info)\n  exit\n\n  /* ------------------------ *\n  | Process the Find command |\n  * ------------------------ */\nDo_Find:\n  fstring = translate(subword(zcmd,2))\n  'tbtop edsl'\n  fhit = 0\n  row = 0\n  do forever\n    'tbskip edsl'\n    row = row + 1\n    if rc > 4 then leave\n    if pos(fstring,translate(edsdisp edsgrp edsdsn)) > 0 then\n    do\n      fhit = 1\n      table_top = row\n      zedsmsg = null\n      zedlmsg = fstring 'found in row' row\n      'setmsg msg(isrz001)'\n      return\n    end\n  end\n  if fhit = 0 then do\n    'tbtop edsl'\n    zedsmsg = 'Not Found'\n    zedlmsg = fstring 'not found in the EDSL table.'\n    'setmsg msg(isrz001)'\n    return\n  end\n\n  /* ------------------------ *\n  | Process unknown commands |\n  * ------------------------ */\nDo_Other:\n  if edstype = null then return\n  if edstype /= 'D' then do\n    zedsmsg = null\n    zedlmsg = rsel 'is invalid on a group.'\n    'setmsg msg(isrz001)'\n    return\n  end\n  else do\n    'control display save'\n    'select cmd('rsel edsdsn')'\n    'control display restore'\n  end\n  return\n\n  /* ------------------------------ *\n  | Process execution time options |\n  * ------------------------------ */\nDo_Options:\n  zcmd = null\n  if words(options) = 3 then do\n    parse value options with rsel rgroup rmem\n    rgroup = translate(rgroup)\n  end\n  if words(options) = 2 then do\n    parse value options with rsel rgroup\n    rmem = null\n  end\n  if length(rsel) > 1 then rsel = left(rsel,1)\n  'tbtop edsl'\n  do forever\n    'tbskip edsl'\n    if rc > 0 then do\n      zedsmsg = null\n      zedlmsg = 'Group' rgroup 'not found...'\n      'setmsg msg(isrz001)'\n      return\n    end\n    if translate(edsgrp) = rgroup then do\n      if length(rmem) < 8\n      then rmem = rmem'*'\n      else rmem = left(rmem,7)'*'\n      Select\n        When pos(rsel,'BEV') > 0 then call do_bev\n        When rsel = 'O' then call do_opendsl\n        When rsel = 'R' then call do_review\n        When rsel = 'C' then call do_update\n        When rsel = 'U' then call do_update\n        Otherwise call do_bev\n      end\n      return\n    end\n  end\n  return\n\n  /* -------------------------------------------------- *\n  | Process Browse, Edit, View commands and            |\n  | if type L (refList) then open as a reference list. |\n  * -------------------------------------------------- */\nDo_BEV:\n  if edstype = 'L' then do\n    call do_openDSL\n    return\n  end\n  if edstype = 'O' then do\n    call do_omvs\n    return\n  end\n  if edstype = 'D' then do\n    cp = pos(rsel,'BEV')\n    if cp = 0 then cp = 2\n    cp = word('Browse Edit View',cp)\n    'control display save'\n    if pos('(',edsdsn) = 0 then do\n      \"lminit dataid(did) dataset(\"edsdsn\")\"\n      if rc > 0 then call do_smsg\n      'Memlist dataid('did') Default('rsel') field(9)'\n      if rc > 0 then call do_smsg\n      'lmfree dataid('did')'\n    end\n    else cp 'Dataset('edsdsn')'\n    'control display restore'\n    return\n  end\n  Address tso ,\n    'alloc f('dd') shr ds('edsdsn') reuse'\n  'control display save'\n  'lminit dataid(did) ddname('dd')'\n  if rc > 0 then call do_smsg\n  if rmem /= null\n  then bev_mem = 'Member('rmem')'\n  else bev_mem = null\n  'Memlist dataid('did') Default('rsel')' bev_mem 'field(9)'\n  'lmfree dataid('did')'\n  address tso 'free f('dd')'\n  'control display restore'\n  return\n\n  /* --------------------------- *\n  | Review an entry (view only) |\n  * --------------------------- */\nDo_Review:\n  save_sgrp = edsgrp\n  call pfshow 'off'           /* make sure pfshow is off */\n  'Addpop row(1) column(40)'\n  'Display Panel(edslg)'\n  'Rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  return\n\n  /* ------------------- *\n  | Process row inserts |\n  * ------------------- */\nDo_Insert:\n  arg loc\n  if datatype(edsloc) /= 'NUM' then edsloc = 0\n  if loc = null\n  then edsloc = edsloc + 10\n  else edsloc = 1\n  parse value null with zcmd edsgrp edsdsn edsdisp\n  call pfshow 'off'           /* make sure pfshow is off */\n  'addpop row(1) column(4)'\n  'display panel(edsle)'\n  drc = rc\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc > 0\n  then if ztdrows = 0 then call done\n  else return\n  call check_type\n  'tbadd edsl'\n  'tbsave edsl library(isptabl)'\n  'tbsort edsl fields(edsloc,n,a)'\n  call re_number_table\n  return\n\n  /* ------------ *\n  | Move selected |\n  * ------------- */\nDo_MoveRow:\n  change = substr(rsel,2)\n  Select\n    When left(change,1) = '-' then change = substr(change,2) * -100\n    When left(change,1) = '+' then change = substr(change,2) * 100\n    otherwise change = change * 100\n  end\n  if change > 0\n  then change = change + 10\n  else change = change - 10\n  edsloc = edsloc + change\n  if edsloc < 1 then edsloc = 999999\n  'tbput edsl'\n  'tbsave edsl library(isptabl)'\n  'tbsort edsl fields(edsloc,n,a)'\n  call re_number_table\n  return\n\n  /* ----------------------------------- *\n  | Renumber the table for easy sorting |\n  * ----------------------------------- */\nRe_Number_Table:\n  'tbtop edsl'\n  loc = 100\n  do forever\n    'tbskip edsl'\n    if rc > 0 then return\n    edsloc = loc\n    'tbput edsl'\n    'tbsave edsl library(isptabl)'\n    loc = loc +100\n  end\n  return\n\n  /* -------------- *\n  | Issue messages |\n  * -------------- */\nDo_SMsg:\n  zedsmsg = zerrsm\n  zedlmsg = zerrlm\n  'setmsg msg(isrz001)'\n  return\n\n  /* ---------------------------------- *\n  | Update the selected row's elements |\n  * ---------------------------------- */\nDo_Update:\n  zcmd = null\n  call pfshow 'off'           /* make sure pfshow is off */\n  do forever\n  'addpop row(1) column(4)'\n  'display panel(edsle)'\n  drc = rc\n  'rempop'\n  call pfshow 'reset'         /* restore pfshow setting */\n  if drc > 0 then return\n  call check_type\n  'tbput edsl'\n  'tbsave edsl library(isptabl)'\n  end\n  return\n\n  /* ---------------------------- *\n  | Process an OMVS File Request |\n  * ---------------------------- */\nDo_OMVS:\n  Select\n    When pos(rsel,'VE') > 0 then\n    Address TSO 'OEdit' \"'\"edsdsn\"'\"\n    Otherwise\n    Address TSO 'OBrowse' \"'\"edsdsn\"'\"\n  end\n  Return\n\n  /* --------------------------------------------- *\n  | Create and then open the ISPF Reference List. |\n  * --------------------------------------------- */\nDo_OpenDSL:\n  if edstype = 'O' then do\n    call do_omvs\n    return\n  end\n  'tbopen isrplist share write'\n  'tbtop isrplist'\n  'tbskip isrplist'\n  refname = 'EDSL'   /* default */\n  if rc = 0 then\n  refname = translate(edsgrp)\n  refname = translate(refname,' ',\"'-\"'\"')\n  if words(refname) > 1 then do\n    parse value refname with g1 g2 g3 g4\n    if length(g1) < 4\n    then refname = left(g1''g2''g3''g4,8)\n    else refname = g1\n    refname = strip(refname)\n  end\n  if refname = '' then refname = 'EDSL'\n  if length(refname) > 8 then refname = left(refname,8)\n  do forever\n    'tbget isrplist'\n    if zcurtb = refname then do\n      'tbdelete isrplist'\n      leave\n    end\n    'tbskip isrplist'\n    if rc > 0 then leave\n  end\n  'tbtop isrplist'\n  'tbvclear isrplist'\n  zcurtb   = refname\n  dsadescp = 'Enhanced DSL List' refname\n  dsapet01 = word(edsdsn,1)\n  dsapet02 = word(edsdsn,2)\n  dsapet03 = word(edsdsn,3)\n  dsapet04 = word(edsdsn,4)\n  dsapet05 = word(edsdsn,5)\n  dsapet06 = word(edsdsn,6)\n  dsapet07 = word(edsdsn,7)\n  dsapet08 = word(edsdsn,8)\n  dsapet09 = word(edsdsn,9)\n  dsapet10 = word(edsdsn,10)\n  dsapet11 = word(edsdsn,11)\n  dsapet12 = word(edsdsn,12)\n  dsapet13 = word(edsdsn,13)\n  dsapet14 = word(edsdsn,14)\n  dsapet15 = word(edsdsn,15)\n  dsapet16 = word(edsdsn,16)\n  dsactime = date('o')\n  if zcurtb /= null then\n  if dsapet01 /= null then do\n    'TBAdd ISRPlist'\n    'TBSave ISRPlist'\n    'TBClose ISRPlist'\n  end\n  'Select Pgm(isrdslst) Parm(DSL' zcurtb') suspend scrname(dslist)'\n  return\n\n  /* --------------------------------- *\n  | History routine                   |\n  * --------------------------------- */\ndo_history:\n  hist. = ''\n  hist.1 = 'Extended DSLIST (EDSL) Change History'\n  hist.2 = ' '\n  line = 1\n  x = sourceline(line)\n  do until pos(' | History:',x) > 0\n    line = line + 1\n    x = sourceline(line)\n    iterate\n  end\n  tail = 3\n  do until pos(' * ----',x) > 0\n    parse value x with '|' hist.tail '|'\n    line = line + 1\n    tail = tail + 1\n    x = sourceline(line)\n  end\n  hist.0 = tail - 1\n  call do_view_stem hist\n  drop hist.\n  return\n\n  /* --------------------------------- *\n  | ISPF View Stem routine            |\n  * --------------------------------- */\ndo_view_stem:\n  parse arg stem\n  Address TSO\n  'alloc f('dd') unit(vio) new reuse space(1,1) tracks',\n    'lrecl(80) recfm(f b) blksize(0) dsorg(ps)'\n  'execio * diskw' dd '(finis stem' stem'.'\n\n  Address ISPExec\n  'lminit dataid(id) ddname('dd') enq(exclu)'\n  if rc /= 0 then do\n    zedsmsg = 'Error'\n    zedlmsg = 'Error.  LMINIT failed for VIO output file'\n    'setmsg msg(isrz001)'\n    exit\n  end\n  'view   dataid('id')'\n  'lmfree dataid('id')'\n  Address TSO 'free f('dd')'\n  return\n\n/* ------------------------------------------------ *\n | Confirm all the entries are the same dsorg/recfm |\n | and if not set to type O                         |\n * ------------------------------------------------ */\nCheck_Type:\n  do cti = 1 to words(edsdsn)\n     if pos(edstype,'OL') > 0 then return\n     if pos('*',word(edsdsn,cti)) > 0 then do\n        edstype = 'L'\n        return\n        end\n     x = listdsi(word(edsdsn,cti))\n     if cti = 1 then do\n        ctdsorg = sysdsorg\n        ctrecfm = sysrecfm\n        end\n     else do\n       if ctdsorg /= sysdsorg then edstype = 'L'\n       if ctrecfm /= sysrecfm then edstype = 'L'\n       if edstype = 'L' then return\n       end\n    end\n    return\n\nopen_table:\n  'tbopen edsl library(isptabl) write share'\n  if rc = 8 then\n  'tbcreate edsl names(edstype edsdisp edsgrp edsdsn edsloc)' ,\n    'write share library(isptabl)'\n  return\n\nFailure:\nSyntax:\n  say 'Error encountered at statement:' sigl\n  say errortext(rc)\n  say sourceline(sigl)\n  return\n\n  /* ------------------------------------------------------ *\n  | The pfshow routine will:                               |\n  | 1. check to see the passed option                      |\n  | 2. if Off then it will save the current pfshow setting |\n  |    - save the current setting                          |\n  |    - turn off pfshow                                   |\n  | 3. if the option is Reset then it will                 |\n  |    - test if pfshow was on and turn it back on         |\n  * ------------------------------------------------------ */\npfshow:\n  if zpfshow = 'OFF' then return\n  arg pfkopt\n  if pfkopt = 'RESET' then do\n    if pfkeys = 'ON' then\n    'select pgm(ispopf) parm(FKA,ON)'\n  end\n  if pfkopt = 'OFF' then do\n    'vget (zpfshow)'\n    pfkeys = zpfshow\n    if pfkeys /= 'OFF' then\n    'select pgm(ispopf) parm(FKA,OFF)'\n  end\n  return\n  /* --------------------------------- *\n  | Dynamic Tree routine              |\n  * --------------------------------- */\nDo_Tree:\n  zcmd  = ''\n  rsel  = ''\n  edsxgrp = ''                              /* Excluded groups        */\n\nTree_Exclude:\n  xgrp   = 'OFF'\n  red    = '01'x                            /* Assign colors to       */\n  blue   = '02'x                            /*     Attribute bytes    */\n  green  = '03'x                            /*     found in the data  */\n  white  = '04'x\n  turq   = '05'x\n  pink   = '06'x\n  yellow = '07'x\n  ndisp  = '09'x                            /*  non-display field     */\n  sel    = '10'x                            /* . line command pad     */\n  selx   = '11'x                            /* + line command pad     */\n  selh   = '12'x                            /*   line command pad     */\n  dyndata  = ''                             /* initialize data        */\n  shadata  = ''                             /* initialize shadow var  */\n  parse value '0 0 0 0 0' with g# o# l# d# h#   /* edstype statistics */\n  maxlines = 0\n\n  Address ISPExec\n  'tbtop edsl'\n  'tbskip edsl'\n  ttn = 1\n  all_groups  = ''\n  do forever                                       /* Build dynamic   */\n    'tbget edsl'                                   /*   area          */\n    if edstype = 'G' then g# = g# + 1\n    if edstype = 'O' then o# = o# + 1\n    if edstype = 'L' then l# = l# + 1\n    if edstype = 'D' then d# = d# + 1\n    if edstype = ' ' then h# = h# + 1\n    tree_tbl.ttn = 'edstype='left(edstype,1)  'edsgrp='left(edsgrp,24),\n                    'edsdsn='edsdsn  'edsloc='edsloc\n    lineno = right(ttn,5,'0')\n    ttn = ttn + 1\n    do\n      if edstype = 'D' then\n        edsgrp = left(edsdisp,24)||ndisp||lineno\n      group = edsgrp\n      all_groups = all_groups left(group,24)       /* Build list of   */\n                                                   /*   groups        */\n      color = blue                                 /* Group           */\n      if edstype = 'D' then                        /* DSNAME          */\n        color = pink\n      if edstype = 'O' then                        /* OMVS            */\n        color = yellow\n      if edstype = 'L' then                        /* DSList          */\n        color = green\n\n      if pos(left(edsgrp,24),edsxgrp) > 0 then do  /* Excluded?       */\n        if edstype = '' then\n          y = selh||' '||white||group              /* Section header  */\n        else\n          y = selx||' '||color||group              /* +=Excluded      */\n        end\n      else\n        if edstype = '' then\n          y = selh||' '||white||group              /* Section header  */\n        else\n          y = sel||' '||color||group\n\n      dyndata=dyndata||left(y,80)\n      maxlines = maxlines + 1\n\n      do num = 1 to 16\n        if pos(left(edsgrp,24),edsxgrp) > 0 then\n          leave\n        if word(edsdsn,num) <> '' then do\n          y = ' '||' '||turq||'   ' word(edsdsn,num)\n          dyndata=dyndata||left(y,80)\n          maxlines = maxlines + 1\n        end\n      end\n    end\n    'tbskip edsl'\n    if rc > 0 then do\n      tree_tbl.0 = ttn - 1\n      leave\n      end\n  end\n  dyndata = dyndata||,                     /* mark bottom             */\n            white||centre(' Bottom of data ',79,'*')\n  usrrfind = 'PASSTHRU'                    /* RFIND                   */\n  'vput (usrrfind)'\n\n/* ------------------------------------------------------------------ */\n/* Doug Nadel scrolling code; ISPF Panels Beyond the Basics, Mar 2000 */\n/* ------------------------------------------------------------------ */\nDoug:\n  dynarea  = ''                            /* initialize data         */\n  dynshad  = ''                            /* initialize shadow var   */\n  curline  = 1                             /* set current line #      */\n  Address ISPExec\n  'vget (zscreend)'                        /* get screen depth        */\n  ht = zscreend                            /* screen height           */\ndo until disprc > 0\n  dynarea = substr(dyndata,1+(curline-1)*80,ht*80) /* set dynamic var */\n  dynshad = ''                                     /* set shadow  var */\n  'display panel(edsdyn)'                  /* display the data        */\n  disprc = rc                              /* save return code        */\n  'vget (zverb,zscrolla,zscrolln)'         /* get scroll values       */\n  select                                   /* process scrolling       */\n    when(zverb = 'UP')   then              /* scroll up               */\n     if zscrolla = 'MAX' then              /*  if scroll was max      */\n      curline = 1                          /*     scroll to top       */\n     else                                  /*  else a number is known */\n      curline = max(1,curline-zscrolln);   /* (maximum is top)        */\n    when(zverb = 'DOWN') then              /* scroll down             */\n     if zscrolla = 'MAX' then              /*  if scroll was max      */\n      curline = maxlines                   /*     scroll to bottom    */\n     else                                  /*  else a number is known */\n      curline = min(maxlines,curline+zscrolln)  /* (max is bottom)    */\n    otherwise                       /* could use left & right too     */\n  end\n/* ------------------------------------------------------------------ */\n/* Doug Nadel scrolling code; end                                     */\n/* ------------------------------------------------------------------ */\n/* --------------------------------- *\n | Cursor Select line command        |\n * --------------------------------- */\nCursor_Pos_Select:\n  if datatype(cpos,'N') = 1 then do\n    if cname = 'DYNAREA' &,                        /* Dynamic area    */\n       (cpos // 80) = 2  &,                        /* Column 2        */\n       substr(dynarea,cpos,1)   <> '*' &,          /* \u00acBottom of data */\n       substr(dynarea,cpos+2,4) <> ' ' then        /* \u00acDSN's          */\n         dynarea = substr(dynarea,1,cpos-1)||'S'||,\n                   substr(dynarea,cpos+1,length(dynarea))\n    end\n/* --------------------------------- *\n | Tree primary commands             |\n * --------------------------------- */\n  zcmd_lower = zcmd\n  zcmd = translate(zcmd)\n  select\n  when abbrev('/',zcmd,1) = 1 then do\n    zcmd = ''\n    call pfshow 'off'\n    'Addpop Row(4) column(15)'\n    'Display Panel(edsdynpo)'\n    'rempop'\n    call pfshow 'reset'\n    end\n  otherwise nop\n  end\n  select\n  when abbrev('TABLE',zcmd,1) = 1 then do\n    listit = 1\n    return\n    end\n  when abbrev('SET',word(zcmd,1),1)   = 1 then do\n       'vget (edsinit)'\n       save_init = edsinit\n       call do_settings\n       if edsinit = 'TABLE' &,\n          save_init <> edsinit then do\n         listit = 1\n         return\n         end\n       end\n  when abbrev(\"FIND\",word(zcmd,1),1) = 1 then do\n    findstr = strip(word(zcmd,2),,\"'\")\n    findstr_lower = strip(word(zcmd_lower,2),,\"'\")\n    zcmd = ''\n    call tree_find\n    end\n  when abbrev(\"RFIND\",word(zcmd,1),2) = 1 then do\n    if curline = maxlines then\n      curline = 0\n    curline = curline + 1\n    zcmd = ''\n    call tree_find\n    end\n  when abbrev(\"REFRESH\",word(zcmd,1),3) = 1 then do\n    zcmd = ''\n    signal do_tree\n    end\n  when word(zcmd,1) = 'X' & word(zcmd,2) = 'ALL' then do\n    zcmd = ''\n    edsxgrp = all_groups\n    signal tree_exclude\n    end\n  when abbrev(\"INSERT\",word(zcmd,1),1) = 1 then do\n    zcmd = ''\n    call do_insert '1'\n    signal do_tree\n    end\n  when abbrev(\"DEBUG\",word(zcmd,1),1) = 1 then do\n    zcmd = ''\n    do x = 1 to tree_tbl.0\n      say tree_tbl.x\n      end\n    end\n  when abbrev(\"ISPLIST\",word(zcmd,1),4) = 1 then do\n    zcmd = ''\n    call do_isplist\n    end\n  When abbrev(\"HEL\",word(zcmd,1),3) = 1 then call do_help\n  when abbrev(\"HISTORY\",word(zcmd,1),1) = 1 then do\n    zcmd = ''\n    call do_history\n    end\n  when abbrev(\"METRICS\",word(zcmd,1),1) = 1 then do\n    zcmd = ''\n    call do_stats\n    end\n  when abbrev(\"QREF\",word(zcmd,1),1) = 1 then do\n    zcmd = ''\n    \"select pgm(isptutor) parm(edsqref)\"\n    end\n  when abbrev(\"VERSION\",word(zcmd,1),1) = 1 then call do_version\n  otherwise nop\n  end\n/* --------------------------------- *\n | Tree line commands                |\n * --------------------------------- */\n  do line = 1 to ht-3\n    grp = substr(dynarea,4+(line-1)*80,24)\n    dsngrp = substr(dynarea,4+(line-1)*80,30)\n    /* Popup line commands */\n    if substr(dynarea,2+(line-1)*80,1) = '/' then do\n      edsdisp = left(grp,24)\n      call pfshow 'off'\n      'Addpop Row(4) column(15)'\n      if substr(dynarea,3+(line-1)*80,1) /= '04'x then    /* \u00acHeader  */\n        'Display Panel(edsdyno)'\n      else\n        'Display Panel(edslos)'                           /* Header   */\n      'rempop'\n      call pfshow 'reset'\n      slash = zcmd\n      if slash = 'R' then\n        slash = ' '\n      dynarea = substr(dynarea,1,1+(line-1)*80,1)||slash||,\n                substr(dynarea,3+(line-1)*80,length(dynarea))\n      zcmd = null\n      end\n    select\n    /* Exclude - toggle */\n    when substr(dynarea,2+(line-1)*80,1) = 'X' then do\n      if substr(dynarea,3+(line-1)*80,1) = '04'x then     /* Header   */\n         leave\n      sel_pos = pos(grp,edsxgrp)\n      if sel_pos > 0 then\n        edsxgrp = delstr(edsxgrp,sel_pos,24)\n      else\n        edsxgrp = edsxgrp left(grp,24)\n      xgrp = 'ON'\n      end\n    /* Edit ,View, Browse, Library, OpenDSL */\n    when substr(dynarea,2+(line-1)*80,1) = 'E' |,\n         substr(dynarea,2+(line-1)*80,1) = 'V' |,\n         substr(dynarea,2+(line-1)*80,1) = 'B' |,\n         substr(dynarea,2+(line-1)*80,1) = 'S' then do\n      if substr(dynarea,3+(line-1)*80,1) = '04'x then     /* Header   */\n         leave\n      if substr(dynarea,3+(line-1)*80,1) = '06'x then do  /* DSN  */\n        rsel = substr(dynarea,2+(line-1)*80,1)\n        edsdsn = substr(dynarea,8+(line)*80,56)     /* DSN next line  */\n        edstype = 'D'\n        edsgrp = ''\n        end\n      else                                          /* Group, DSLIST  */\n        do\n          rsel = substr(dynarea,2+(line-1)*80,1)\n          rmem = null\n          edsgrp = left(grp,24)\n          'tbtop edsl'\n          'tbscan edsl arglist(edsgrp)'\n          end\n      call do_BEV\n      rsel = ''\n      end\n    /* Insert, Delete, OpenDSL, Move Up, Move Dn, Update */\n    when substr(dynarea,2+(line-1)*80,1) = 'I' |,\n         substr(dynarea,2+(line-1)*80,1) = 'D' |,\n         substr(dynarea,2+(line-1)*80,1) = 'O' |,\n         substr(dynarea,2+(line-1)*80,1) = 'M' |,\n         substr(dynarea,2+(line-1)*80,1) = 'N' |,\n         substr(dynarea,2+(line-1)*80,1) = 'U' then do\n      if substr(dynarea,3+(line-1)*80,1) = '04'x &,       /* Header   */\n         pos(substr(dynarea,2+(line-1)*80,1),'O') = 1 then\n        leave\n      if substr(dynarea,3+(line-1)*80,1) = '06'x then do  /* DSN  */\n        rsel = substr(dynarea,2+(line-1)*80,1)\n        skipnum = substr(dsngrp,26,5)          /* Non-display row num */\n        'tbtop edsl'\n        'tbskip edsl number('skipnum')'\n        end\n      else                                          /* Group, DSLIST  */\n        do\n          rsel = substr(dynarea,2+(line-1)*80,1)\n          edsgrp = left(grp,24)\n          'tbtop edsl'\n          'tbscan edsl arglist(edsgrp)'\n        end\n      if pos(rsel,'D') > 0 then do\n        zwinttl = 'Confirm Request'\n        ckey    = ''\n        do until (ckey = 'PF03') | (ckey = 'ENTER')\n          'control nocmd'\n          'addpop'\n          'display panel(edsdync)'\n          'rempop'\n          end\n        if ckey = 'PF03' then do\n          rsel = ''\n          leave\n          end\n        'tbdelete edsl'\n        signal do_tree\n        end\n      if pos(rsel,'I') > 0 then do\n        call do_insert\n        signal do_tree\n        end\n      if pos(rsel,'M') > 0 then do\n        rsel = 'M-1'\n        call do_MoveRow\n        signal do_tree\n        end\n      if pos(rsel,'N') > 0 then do\n        rsel = 'M1'\n        call do_MoveRow\n        signal do_tree\n        end\n      if pos(rsel,'O') > 0 then do\n        call do_OpenDSL\n        end\n      if pos(rsel,'U') > 0 then do\n        call do_update\n        signal do_tree\n        end\n      rsel = ''\n      end\n    otherwise\n    end\n  end\n  if xgrp = 'ON' then\n    signal tree_exclude\nend\nreturn\n/* --------------------------------- *\n | Tree find group with matching     |\n * --------------------------------- */\nTree_Find:\n  do x = curline to maxlines\n    line = substr(dyndata,1+(x-1)*80,80)\n    if pos(findstr,line) > 0 |,\n       pos(findstr_lower,line) > 0 then do\n      zerrsm = \"CHARS '\"findstr\"' found\"\n      zerrlm = \"Search for CHARS '\"findstr\"' was successful.\"\n      zerrhm = 'edslh'\n      zerralrm = 'NO'\n      Address ISPExec 'setmsg msg(isrz002)'\n      curline = x\n      leave x\n      return\n      end\n  end\n  curline = x\n  if curline > maxlines then do\n    curline = maxlines\n    zerrsm = '*Bottom of list reached*'\n    zerrlm = \"CHARS '\"findstr\"' not found. Press RFIND key to\",\n             \"continue the search from the top of the group list.\"\n    zerrhm   = 'edslh'\n    zerralrm = 'NO'\n    Address ISPExec 'setmsg msg(isrz002)'\n    end\n  return\n/* --------------------------------- *\n | Write tree table to ISPLIST       |\n * --------------------------------- */\nDo_ISPList:\n    do x = 1 to tree_tbl.0\n      parse var tree_tbl.x with 'edstype=' typ 'edsgrp=' grp,\n                                'edsdsn='  dsn 'edsloc=' loc\n      d. = ''\n      parse var dsn d.1 d.2  d.3  d.4  d.5  d.6  d.7  d.8,\n                    d.9 d.10 d.11 d.12 d.13 d.14 d.15 d.16\n      if left(typ,1) = 'D' then\n        grp = left(dsn,24)\n      dtl = left(grp,24)\n      'list bufname(dtl) linelen(80) single'\n      do i = 1 to 16\n        if d.i <> '' then do\n          dtl = '    'd.i\n          'list bufname(dtl) linelen(80) single'\n          end\n        end\n      end\n    zerralrm = 'NO'\n    zerrhm = 'edsdynh'\n    zerrsm = tree_tbl.0 'Groups listed'\n    zerrlm = 'Tree table has been successfully listed'\n    'Setmsg msg(isrz002)'\n    return\n/* --------------------------------- *\n | Display EDSL\u00ae version info        |\n * --------------------------------- */\nDo_Version:\n    zcmd = ''\n    zerrsm = ''\n    zerrlm = left('EDSL\u00ae '||ver,73),\n             left('Lionel Dyck and John Kalinich',73),\n             left('The ISPF Cabal - Vive la r\u00e9volution',73),\n             left('Copyleft - GNU GPL v3',73)\n    zerralrm = 'NO'\n    zerrhm = 'edsdynh'\n    Address ISPExec\n    'setmsg msg(isrz002)'\n    return\n/* --------------------------------- *\n | Display EDSL\u00ae settings            |\n * --------------------------------- */\nDo_Settings:\n    zcmd = ''\n    Address ISPExec\n    'Addpop Row(4) column(15)'\n    'Display Panel(edsset)'\n    'rempop'\n    return\n/* --------------------------------- *\n | Display EDSL\u00ae help member         |\n * --------------------------------- */\nDo_Help:\n    findcmd  = word(zcmd,2)\n    zcmd = ''\n    parse var load_info . . . . skeldd .\n    Address ISPExec\n    \"lminit dataid(skel) ddname(\"skeldd\")\"\n    \"view dataid(\"skel\") member(edshelp)\",\n      \"macro(edsfhelp) parm(findcmd)\"\n    \"lmfree dataid(\"skel\")\"\n    return\n/* --------------------------------- *\n | Display EDSL\u00ae row statistics      |\n * --------------------------------- */\nDo_Stats:\n    zerrsm = ''\n    zerrlm = left('Group  = 'right(g#,5),73),\n             left('OMVS   = 'right(o#,5),73),\n             left('DSList = 'right(l#,5),73),\n             left('DSName = 'right(d#,5),73),\n             left('Header = 'right(h#,5),73),\n             left('Total  = 'right(g#+o#+l#+d#+h#,5),73)\n    zerralrm = 'NO'\n    zerrhm = 'edsdynh'\n    Address ISPExec\n    'setmsg msg(isrz002)'\n    return\n/* start of inline elements\n>Start\n>Panel edsdyn\n)ATTR\n  \u00a6 TYPE(INPUT) INTENS(HIGH) CAPS(OFF) COLOR(RED)\n  @ AREA(DYNAMIC)            SCROLL(ON) EXTEND(ON)\n  01 TYPE(DATAOUT)           COLOR(RED)\n  02 TYPE(DATAOUT)           COLOR(BLUE)\n  03 TYPE(DATAOUT)           COLOR(GREEN)\n  04 TYPE(DATAOUT)           COLOR(WHITE)\n  05 TYPE(DATAOUT)           COLOR(TURQ)\n  06 TYPE(DATAOUT)           COLOR(PINK)\n  07 TYPE(DATAOUT)           COLOR(YELLOW)\n  09 TYPE(DATAOUT)           INTENS(NON)\n  10 TYPE(DATAIN) CAPS(ON) PAD('.') PAS(ON) COLOR(RED)\n  11 TYPE(DATAIN) CAPS(ON) PAD('+') PAS(ON) COLOR(RED)\n  12 TYPE(DATAIN) CAPS(ON) PAD(' ') PAS(ON) COLOR(RED)\n  r  TYPE(CHAR) COLOR(RED)   HILITE(REVERSE)\n  g  TYPE(CHAR) COLOR(GREEN) HILITE(REVERSE)\n  b  TYPE(CHAR) COLOR(BLUE)  HILITE(REVERSE)\n  $  TYPE(TEXT)              COLOR(YELLOW)\n  #  TYPE(TEXT)              COLOR(TURQ)\n  \u00dd  TYPE(output)            COLOR(TURQ) just(right) caps(off)\n  ~  TYPE(OUTPUT)            COLOR(TURQ)\n  ?  TYPE(OUTPUT) PAS(ON)    COLOR(YELLOW) CAPS(OFF) HILITE(USCORE)\n  !  TYPE(PS)\n)BODY EXPAND(\\\\)\n%EDSL\u00ae\u00ddver +                 $Tree Display              \u00ddrowline\n%Command ===>\u00a6zcmd                                            %Scroll ===>_Z   +\n+\n@dynarea,dynshad                                                               @\n)INIT\n.zvars = '(zscml)'\n*REXX(* rowline curline maxlines)\nrowline = 'Row' curline 'of' maxlines\n*Endrexx\n.help  = 'edsdynh'\nif (&zscml = ' ') &zscml = 'CSR'\n)PROC\nvput (zscml) profile\n&cpos = .CSRPOS\n&cname = .CURSOR\n)END\n>Panel edsdynh\n)Attr Default(%\u00ac_)\n @ type(output) caps(off) intens(low) color(turq)\n ~ type(text) caps(off) intens(low) color(yellow)\n ` type(text) caps(off) intens(low) color(blue)\n \u00a8 type(text) caps(off) intens(low) color(green)\n \u00dd type(text) caps(off) intens(low) color(pink)\n $ type(input ) hilite(uscore) caps(on) intens(low)\n _ type(input ) hilite(uscore) caps(on) intens(low) intens(low)\n   color(red)\n)Body Expand(\\\\)\n\u00acTutorial\\-\\%Enhanced Data Set List\u00ac\\-\\Tutorial\n%Command ===>_zcmd\n\u00ac\n%Node Colors:  `Group   ~OMVS   \u00a8DSList   \u00ddDSName\n\u00ac\n%Primary Commands:\n    %Find   \u00acto find the provided string\n    %REFresh\u00acto refresh the group tree display\n    %X ALL  \u00acto exclude all group tree nodes\n    %Insert \u00acto insert a row into the table\n    %Table  \u00acto switch to ISPF table view\n    %Set    \u00acto display the settings window\n    %HEL cmd\u00acto display EDSL\u00ae help member\n    %History\u00acto display change history of EDSL\n    %Version\u00acto display EDSL\u00ae version number\n\u00ac\n%Line Commands:\n    %B\u00ac  Browse     %M\u00ac  Move up       %O\u00ac  Open in Dataset List\n    %D\u00ac  Delete     %N\u00ac  Move down     %S\u00ac  Library utility\n    %E\u00ac  Edit       %U\u00ac  Update        %.\u00ac  Cursor select (S)\n    %I\u00ac  Insert     %V\u00ac  View          %X\u00ac  Exclude tree node (toggle)\n    %/\u00ac  Popup menu\n)Init\n)Proc\n &zcont = edsdynh\n)End\n>Panel edsdync\n)attr default(%+_)\n   $  type(output)  intens(low)  caps(off)  color(turq)  just(left)\n   _  type(input)   intens(high) caps(on)   just(left)   hilite(uscore)\n   +  type(text)    intens(low)  skip(on)   color(green)\n)body window(50,6)\n+\n%Confirm delete of Group:$edsgrp\n+\n+Are you sure?\n+\n+Press%ENTER+to process or%END+to exit\n)PROC\n  &ckey = .pfkey\n  if (&ckey = ' ')\n      &ckey = 'ENTER'\n  vput (ckey) shared\n)end\n>Panel edsdynpo\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(on ) just(left ) hilite(uscore)\n  + type(text) intens(low) skip(on)\n  \u00a8 type(output) caps(off) pas(on) intens(high) color(white) hilite(uscore)\n  @ type(output) caps(off)\n)Body Window(49,12)\n%Command ===>_z\n+\n+\u00a8I+Insert   - insert a row into the table\n+\u00a8H+History  - display the change history of EDSL\n+\u00a8Q+Quickref - display command quick reference\n+\u00a8S+Set      - display the settings window\n+\u00a8T+Table    - display the EDSL table\n+\u00a8V+Version  - display EDSL\u00ae version number\n+\u00a8R+Refresh  - refresh the group tree display\n+\u00a8X+Exclude  - exclude all group tree nodes\n+\n           +Or%F3+to cancel\n)Init\n &zwinttl = 'Tree Primary Commands:'\n .zvars = '(zcmd)'\n .cursor = zcmd\n .help = edsdynh\n &I = I\n &H = H\n &Q = Q\n &R = R\n &S = S\n &T = T\n &V = V\n &X = X\n)Proc\n if (&zcmd = 'X')\n   &zcmd = 'X ALL'\n if (&zcmd = 'R')\n   &zcmd = 'REF'\n)PNTS\n FIELD(I)  VAR(ZCMD) VAL('I')\n FIELD(H)  VAR(ZCMD) VAL('H')\n FIELD(Q)  VAR(ZCMD) VAL('Q')\n FIELD(R)  VAR(ZCMD) VAL('REF')\n FIELD(S)  VAR(ZCMD) VAL('S')\n FIELD(T)  VAR(ZCMD) VAL('T')\n FIELD(V)  VAR(ZCMD) VAL('V')\n FIELD(X)  VAR(ZCMD) VAL('X ALL')\n)End\n>Panel edsdyno\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(on ) just(left ) hilite(uscore)\n  + type(text) intens(low) skip(on)\n  \u00a8 type(output) caps(off) pas(on) intens(high) color(white) hilite(uscore)\n  @ type(output) caps(off)\n)Body Window(39,11)\n+Enter Selection:_z+\n+\n+ Group:@edsdisp\n+\n+\u00a8B+Browse            +\u00a8O+Open DSL/UDL\n+\u00a8D+Delete group      +\u00a8S+Select (Open)\n+\u00a8E+Edit              +\u00a8U+Update\n+\u00a8I+Insert            +\u00a8V+View\n+\u00a8M+Move up           +\u00a8X+Exclude\n+\u00a8N+Move dn\n           +Or%F3+to cancel\n)Init\n &zwinttl = 'EDSL Selection Options:'\n .zvars = '(zcmd)'\n .cursor = zcmd\n .help = edslh\n &B = B\n &D = D\n &E = E\n &I = I\n &M = M\n &N = N\n &O = O\n &S = S\n &U = U\n &V = V\n &X = X\n)Proc\n)PNTS\n FIELD(B)  VAR(ZCMD) VAL('B')\n FIELD(D)  VAR(ZCMD) VAL('D')\n FIELD(E)  VAR(ZCMD) VAL('E')\n FIELD(I)  VAR(ZCMD) VAL('I')\n FIELD(M)  VAR(ZCMD) VAL('M')\n FIELD(N)  VAR(ZCMD) VAL('N')\n FIELD(O)  VAR(ZCMD) VAL('O')\n FIELD(S)  VAR(ZCMD) VAL('S')\n FIELD(U)  VAR(ZCMD) VAL('U')\n FIELD(V)  VAR(ZCMD) VAL('V')\n FIELD(X)  VAR(ZCMD) VAL('X')\n)End\n>Panel edsset\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(on ) just(left ) hilite(uscore)\n  + type(text) intens(low) skip(on)\n  \u00a8 type(output) caps(off) pas(on) intens(high) color(white) hilite(uscore)\n  @ type(output) caps(off)\n)Body Window(42,5)\n%Command ===>_z\n+\n%Display view ===>_edsinit+(TABLE or TREE)\n+\n)Init\n &zwinttl = 'EDSL Settings:'\n .zvars = '(zcmd)'\n .cursor = edsinit\n .help = edslh\n if (&edsinit = '')\n   &edsinit = 'TABLE'\n)Proc\n*REXX(*)\n if abbrev('TABLE',edsinit,2) = 1 then edsinit = 'TABLE'\n if abbrev('TREE',edsinit,2)  = 1 then edsinit = 'TREE'\n*ENDREXX\n ver (&edsinit,nb,list,TABLE,TREE)\n vput (edsinit) profile\n)End\n>Panel edsqref\n)Attr Default(`\u00dd_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type(text) intens(high) caps(off) just(asis ) color(white)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(green) hilite(uscore)\n   \u00dd type(text) intens(low ) color(turq)\n   \u00a8 type(text) intens(low ) color(blue)\n     skip(on)\n   \u00ac area(SCRL) Extend(ON)\n)Body Window(62,20)\n\n~Command\u00dd          ~Function\u00dd\n\u00achelp ------------------------------------------------------\u00ac\n)Area Help\n!Find             -\u00ddFind the provided string\n!HEL cmd          -\u00ddDisplay EDSL help for a cmd\n!History          -\u00ddDisplay modification history\n!Insert           -\u00ddInsert a row into the table\n!Qref             -\u00ddWhat you are reading now\n!REFresh          -\u00a8Refresh the group tree display\n!RFind            -\u00a8Repeat find of the provided string\n!Set              -\u00ddDisplay the settings window\n!Table            -\u00a8Switch to ISPF table view\n!Tree             -\u00ddDisplay the group tree view\n!Version          -\u00ddDisplay EDSL\u00ae version number\n!X ALL            -\u00a8Exclude all group tree nodes\n!Debug            -\u00a8Dump table for debugging\n!Metrics          -\u00a8Display EDSTYPE statistics\n!ISPList          -\u00a8Write tree table to ISPLIST\n!/                -\u00ddPopup selection menu\n`B               !-\u00ddBrowse\n`D               !-\u00ddDelete a row\n`E               !-\u00ddEdit\n`I               !-\u00ddInsert a row\n`M               !-\u00ddMove row up one\n`MD              !-\u00ddMove row down one\n`Mx              !-\u00ddMove row up (-#) down(+#)\n`N               !-\u00a8Move row down one\n`/               !-\u00ddPopup Selection menu\n`O               !-\u00ddOpen in Dataset List\n`R               !-\u00ddDisplay the group\n`S               !-\u00ddSelect\n`.               !-\u00ddCursor select (S)\n`U               !-\u00ddUpdate (alias C)\n`V               !-\u00ddView\n`X               !-\u00a8Exclude tree node (toggle)\n`any             !-\u00dd(with Dataset only)\n)Init\n&zwinttl = 'EDSL Quick Reference'\n&zup = EDSQREF\n)Proc\n)End\n>Exec edsfhelp\n/* rexx */\nISREdit 'macro (arg)'\nISREdit 'reset'\nif arg = '' then\n  nop\nelse\n  ISREdit 'find <'arg\n>Panel edsl\n)Attr\n @ type(output) caps(off) intens(low) color(turq)\n $ type(input ) hilite(uscore) caps(on) intens(low)\n _ type(input ) hilite(uscore) caps(on) intens(low)\n)Body Expand(\\\\)\n%EDSL\u00ae@ver +\\-\\%Enhanced Data Set List+\\-\\\n%Command ===>_zcmd                \\ \\%Scroll ===>_edsc+\n+\n%Select     Type   Dataset/Group\n)Model\n$rsel     +  @z + @edsdisp                                              +\n)Init\n .cursor = &zcmd\n .help = edslh\n .zvars = '(edstype)'\n if (&edsc EQ &Z)\n     &edsc = 'CSR'\n if (&ztdrows = 0)\n    &rsel = I\n    &zedsmsg = &z\n    &zedlmsg = 'No groups in the table. Enter one now.'\n    .msg = isrz001\n    .resp = ENTER\n*REXX(* ztdrows ztdmark)\n  ztdmark = center(' (EDSL Bottom of List' ztdrows+0' entries) ',79,'*')\n*ENDREXX\n)Proc\n &rowid = .csrrow\n vput (edsc) profile\n)End\n>Panel edspo\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(on ) just(left ) hilite(uscore)\n  + type(text) intens(low) skip(on)\n  \u00a8 type(output) caps(off) pas(on) intens(high) color(white) hilite(uscore)\n  @ type(output) caps(off)\n)Body Window(49,12)\n%Command ===>_z\n+\n+\u00a8I+Insert   - insert a row into the table\n+\u00a8H+History  - display the change history of EDSL\n+\u00a8Q+Quickref - display command quick reference\n+\u00a8S+Set      - display the settings window\n+\u00a8T+Tree     - display a tree view of the table\n+\u00a8V+Version  - display EDSL\u00ae version number\n+\u00a8F+Find     - find the provided string\n+   Find:_fstring                 +\n+\n           +Or%F3+to cancel\n)Init\n &zwinttl = 'EDSL Primary Commands:'\n .zvars = '(zcmd)'\n .cursor = zcmd\n .help = edslh\n &I = I\n &F = F\n &H = H\n &Q = Q\n &S = S\n &T = T\n &V = V\n)Proc\n if (&zcmd EQ F)\n    ver (&fstring,nb)\n)PNTS\n FIELD(I)  VAR(ZCMD) VAL('I')\n FIELD(F)  VAR(ZCMD) VAL('F')\n FIELD(H)  VAR(ZCMD) VAL('H')\n FIELD(Q)  VAR(ZCMD) VAL('Q')\n FIELD(S)  VAR(ZCMD) VAL('S')\n FIELD(T)  VAR(ZCMD) VAL('T')\n FIELD(V)  VAR(ZCMD) VAL('V')\n)End\n>Panel edslo\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(on ) just(left ) hilite(uscore)\n  + type(text) intens(low) skip(on)\n  \u00a8 type(output) caps(off) pas(on) intens(high) color(white) hilite(uscore)\n  @ type(output) caps(off)\n)Body Window(39,11)\n+Enter Selection:_z+\n+\n+ Group:@edsdisp\n+\n+\u00a8B+Browse            +\u00a8R+Review (List)\n+\u00a8D+Delete group      +\u00a8S+Select (Open)\n+\u00a8E+Edit              +\u00a8U+Update\n+\u00a8I+Insert            +\u00a8V+View\n+\u00a8O+Open DSList/UDList\n+\n           +Or%F3+to cancel\n)Init\n &zwinttl = 'EDSL Selection Options:'\n .zvars = '(zcmd)'\n .cursor = zcmd\n .help = edslh\n &B = B\n &D = D\n &E = E\n &I = I\n &O = O\n &R = R\n &S = S\n &U = U\n &V = V\n)Proc\n)PNTS\n FIELD(B)  VAR(ZCMD) VAL('B')\n FIELD(D)  VAR(ZCMD) VAL('D')\n FIELD(E)  VAR(ZCMD) VAL('E')\n FIELD(I)  VAR(ZCMD) VAL('I')\n FIELD(O)  VAR(ZCMD) VAL('O')\n FIELD(R)  VAR(ZCMD) VAL('R')\n FIELD(S)  VAR(ZCMD) VAL('S')\n FIELD(U)  VAR(ZCMD) VAL('U')\n FIELD(V)  VAR(ZCMD) VAL('V')\n)End\n>Panel edslos\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(on ) just(left ) hilite(uscore)\n  + type(text) intens(low) skip(on)\n  \u00a8 type(output) caps(off) pas(on) intens(high) color(white) hilite(uscore)\n  @ type(output) caps(off)\n)Body Window(39,9)\n+Enter Selection:_z+\n+\n+ Group:@edsdisp\n+\n+\u00a8D+Delete group\n+\u00a8I+Insert\n+\u00a8U+Update\n+\n           +Or%F3+to cancel\n)Init\n &zwinttl = 'EDSL Selection Options:'\n .zvars = '(zcmd)'\n .cursor = zcmd\n .help = edslh\n &D = D\n &I = I\n &U = U\n)Proc\n)PNTS\n FIELD(D)  VAR(ZCMD) VAL('D')\n FIELD(I)  VAR(ZCMD) VAL('I')\n FIELD(U)  VAR(ZCMD) VAL('U')\n)End\n>Panel edslh\n)Attr\n @ type(output) caps(off) intens(low) color(turq)\n $ type(input ) hilite(uscore) caps(on) intens(low)\n _ type(input ) hilite(uscore) caps(on) intens(low)\n)Body Expand(\\\\)\n+Tutorial\\-\\%Enhanced Data Set List+\\-\\Tutorial\n%Command ===>_zcmd\n+\n+The Enhanced Data Set List dialog makes it easy to access\n+\n    %*+individual dataset or OMVS file  (Browse/Edit/View)\n    %*+groups of datasets               (DSList or Browse/Edit/View)\n    %*+OMVS directory                   (UDList)\n+\n+Panel Fields:%Select+       Row selection field\n+\n+             %Type+         Row type:  %D+Dataset\n+                                       %G+Group\n+                                       %L+DSList\n+                                       %O+OMVS\n+\n+             %Dataset/Group+Dataset name, Group name, OMVS Directory/File\n+\n%Note:+ Dataset Groups will create/replace groups within the existing ISPF\n+       Personal Data Set List that is used by ISPF 3.4 (DSList).\n+\n+\\-\\Press%Enter+to continue the Tutorial\\-\\\n)Init\n)Proc\n &zcont = edslh1\n)End\n>Panel edslh1\n)Attr Default(%\u00ac_)\n @ type(output) caps(off) intens(low) color(turq)\n $ type(input ) hilite(uscore) caps(on) intens(low)\n _ type(input ) hilite(uscore) caps(on) intens(low) intens(low)\n)Body Expand(\\\\)\n\u00acTutorial\\-\\%Enhanced Data Set List\u00ac\\-\\Tutorial\n%Command ===>_zcmd\n\u00ac\n%Primary Commands: %Insert \u00ac(abbreviation I) insert a row into the table\n                   %Find   \u00ac(abbreviation F) find the provided string\n                   %HEL cmd\u00ac(abbr HEL)       display EDSL\u00ae help for a cmd\n                   %History\u00ac(abbreviation H) display change history of EDSL\n                   %Set    \u00ac(abbreviation S) display the settings window\n                   %Tree   \u00ac(abbreviation T) display the group tree view\n                   %Version\u00ac(abbreviation V) display EDSL\u00ae version number\n                   %/      \u00acPopup Selection menu\n\u00ac\n%Line Commands:    %B\u00ac  Browse                      %O\u00ac  Open in Dataset List\n                   %D\u00ac  Delete to delete a row      %R\u00ac  To display the group\n                   %E\u00ac  Edit                        %R\u00ac  To review (display)\n                   %I\u00ac  Insert a row                %S\u00ac  Select\n                   %M\u00ac  Move row up one             %U\u00ac  Update (alias C)\n                   %MD\u00ac Move row down one           %V\u00ac  View\n                   %Mx\u00ac Move row up (-#) down(+#)   %any\u00acwith Dataset only\n                   %/\u00ac  Popup Selection menu\n\u00ac\n\u00ac\\-\\Press%Enter\u00acto continue the Tutorial\\-\\\n)Init\n)Proc\n &zcont = edslh2\n)End\n>Panel edslh2\n)Attr Default(%+_)\n @ type(output) caps(off) intens(low) color(turq)\n $ type(input ) hilite(uscore) caps(on) intens(low)\n _ type(input ) hilite(uscore) caps(on) intens(low) intens(low)\n)Body Expand(\\\\)\n+Tutorial\\-\\%Enhanced Data Set List+\\-\\Tutorial\n%Command ===>_zcmd\n+\n%EDSL Invocation Syntax:\n+\n%    TSO EDSL\n+      - Open the EDSL list of groups\n%    TSO EDSL group\n+      - open the specified group using the default selection option\n+        Type    selection option\n        %D+      Member List\n+       %G+      Member List\n+       %L+      DSList\n+       %O+      UDList\n%    TSO EDSL sel group\n+      - open the group using the sel option (e.g. E)\n%    TSO EDSL sel group member+(or member mask)\n+      - open the group using the sel option (e.g. E)\n+\n+    If EDSL has been added to the ISPF Commands table then eliminate the TSO\n+\n+\\-\\Press%Enter+to continue the Tutorial\\-\\\n)Init\n)Proc\n &zcont = edslh3\n)End\n>Panel edslh3\n)Attr Default(%+_)\n @ type(output) caps(off) intens(low) color(turq)\n $ type(input ) hilite(uscore) caps(on) intens(low)\n _ type(input ) hilite(uscore) caps(on) intens(low) intens(low)\n)Body Expand(\\\\)\n+Tutorial\\-\\%Enhanced Data Set List+\\-\\Tutorial\n%Command ===>_zcmd\n+\n%EDSL Notes:+\n+\n+    1. The Group name will be used as the DSList Name when\n+       a Group or List is selected.\n+    2. When opening as a data set list the list will be added\n+       to the Personal Data Set Lists and thus available using\n+       DSLIST and REFOPEND.\n+    3. Any existing Data Set List with the same name will be\n+       replaced.\n+    4. The Group name will be truncated to the first word or\n+       to the first 8 characters for the Data Set List name.\n+    5. Only 1 OMVS File or Directory is allowed in a group and\n+       no z/OS datasets may be included with it.\n+    6. A Group is limited to 16 dataset names as that is the limit\n+       supported by the ISPF MEMLIST service.\n+\n+\n+\n+\\-\\Press%Enter+to continue the Tutorial\\-\\\n)Init\n)Proc\n &zcont = edslh\n)End\n>Panel edsle\n)Attr\n $ type(input ) hilite(uscore) caps(off) intens(low)\n @ type(input ) hilite(uscore) caps(off) intens(low)\n + type(text  )\n _ type(input ) hilite(uscore) caps(on) intens(low)\n)Body Window(64,21) Expand(\\\\)\n%Command ===>_zcmd\n+\n+Enter/Update:\n%Group:@edsgrp                  +\n+\n +$z +>$d1                                                     +\n +$z +>$d2                                                     +\n +$z +>$d3                                                     +\n +$z +>$d4                                                     +\n +$z +>$d5                                                     +\n +$z +>$d6                                                     +\n +$z +>$d7                                                     +\n +$z +>$d8                                                     +\n +$z +>$d9                                                     +\n +$z +>$d10                                                    +\n +$z +>$d11                                                    +\n +$z +>$d12                                                    +\n +$z +>$d13                                                    +\n +$z +>$d14                                                    +\n +$z +>$d15                                                    +\n +$z +>$d16                                                    +\n)Init\n &zwinttl = 'EDSL Dataset(s) or OMVS File/Directory'\n .zvars = '(o1 o2 o3 o4 o5 o6 o7 o8 o9 o10 o11 o12 o13 o14 o15 o16)'\n*Rexx(* edsgrp d1 d2 d3 d4 d5 d6 d7 d8 o1 o2 o3 o4 o5 o6 o7 o8 edsdsn ,\n       o9 o10 o11 o12 o13 o14 o15 o16 d9 d10 d11 d12 d13 d14 d15 d16)\n parse value '1 2 3 4 5 6 7 8' with o1 o2 o3 o4 o5 o6 o7 o8\n parse value '9 10 11 12 13 14 15 16' with o9 o10 o11 o12 o13 o14 o15 o16\n d1 = word(edsdsn,1)\n d2 = word(edsdsn,2)\n d3 = word(edsdsn,3)\n d4 = word(edsdsn,4)\n d5 = word(edsdsn,5)\n d6 = word(edsdsn,6)\n d7 = word(edsdsn,7)\n d8 = word(edsdsn,8)\n d9 = word(edsdsn,9)\n d10 = word(edsdsn,10)\n d11 = word(edsdsn,11)\n d12 = word(edsdsn,12)\n d13 = word(edsdsn,13)\n d14 = word(edsdsn,14)\n d15 = word(edsdsn,15)\n d16 = word(edsdsn,16)\n*EndRexx\n .help = edsleh\n)Proc\n &resp = .resp\n*REXX(* zedsmsg zedlmsg resp edsgrp edsdsn bad edstype edsdisp ,\n      d1 d2 d3 d4 d5 d6 d7 d8 o1 o2 o3 o4 o5 o6 o7 o8 gendsn ,\n      o9 o10 o11 o12 o13 o14 o15 o16 d9 d10 d11 d12 d13 d14 d15 d16)\n  parse value '' with zedsmsg zedlmsg order null bad\n  if resp = 'END' then exit\n  call reorder\n  if edsgrp = '' then\n  if words(edsdsn) > 1 then\n  zedlmsg = 'Error. When group is blank only one dataset name is' ,\n    'allowed.'\n  w = words(d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16)\n  Select\n    When pos('/',d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16) > 0\n      then do\n       edstype = 'O'\n       if words(d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16) > 1\n       then zedlmsg = 'Error. Only one OMVS File/Directory allowed.'\n       else edsdisp = edsgrp\n       end\n    When pos('*',d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 d13 d14 d15 d16) > 0\n      then do\n      edstype = 'L'\n      gendsn = '1'\n      if w = 1 then do\n         if left(d1,1) /= \"'\" then do\n         if sysvar('syspref') = ''\n            then d1 = \"'\"sysvar('sysuid')\".\"d1\"'\"\n            else d1 = \"'\"sysvar('syspref')\".\"d1\"'\"\n         end\n         else d1 = translate(d1)\n         end\n    if edsgrp = null\n       then if w = 1\n            then edsgrp = d1\n    edsdisp = edsgrp\n    end\n    When w = 1 then do\n      edstype = 'D'\n      if edsgrp = ''\n         then edsdisp = edsdsn\n         else edsdisp = edsgrp\n    end\n    When w > 1 then do\n      edstype = 'G'\n      edsdisp = edsgrp\n    end\n    Otherwise do\n      edstype = null\n      edsdisp = edsgrp\n    end\n  end\n  if 1 = 0 then do\n  Reorder:\n    edsdsn = null\n    order. = null\n    order.0 = 0\n    c = 0\n    do i = 1 to 16\n      interpret 'dsn = d'i\n      if dsn /= null then do\n      if pos(left(dsn,1),\"'/\") = 0 then\n        Select\n        When pos('/',dsn) > 0 then nop\n        when pos('*',dsn) = 0 then do\n          x = listdsi(dsn)\n          if x > 0 then do\n            zedlmsg = dsn sysmsglvl2\n            cpos = 'd'i\n            bad = 1\n            leave\n          end\n        end\n        otherwise  dsn = translate(dsn)\n        end\n        c = c + 1\n        interpret 'order.'c '= o'i\n        if left(dsn,1) = \"'\"\n           then if right(dsn,1) /= \"'\"\n           then dsn = translate(dsn)\"'\"\n        order.c = order.c dsn\n        order.0 = c\n      end\n    end\n    do forever\n      ordered = 0\n      do i = 1 to c\n        seq = word(order.i,1)\n        in = i + 1\n        if in > 16 then leave\n        if order.in = null\n        then do forever\n          in = in + 1\n          if in > 16 then leave\n        end\n        nseq = word(order.in,1)\n        if nseq = null then leave\n        if seq <= nseq then iterate\n        ordered = 1\n        swap1 = order.i\n        swap2 = order.in\n        order.i = swap2\n        order.in = swap1\n      end\n      if ordered = 0 then leave\n    end\n    do i = 1 to c\n      dsn = word(order.i,2)\n      if pos(\"/\",dsn) > 0 then do\n         edsdsn = strip(dsn)\n         return\n         end\n      dsn = translate(dsn)\n      if pos('(',dsn) > 0\n      then do\n        parse value dsn with ld'('mem')'rd\n        dsn = ld''rd\n      end\n      else mem = null\n      if pos('/',dsn) = 0 then do\n      if pos('*',dsn) > 0 then do\n        if left(dsn,1) /= \"'\" then do\n            if sysvar('syspref') = ''\n               then pref = sysvar('sysuid')\n               else pref = sysvar('syspref')\n            if left(dsn,length(pref)) /= pref\n               then dsn = pref'.'dsn\n            dsn = \"'\"dsn\"'\"\n            end\n      end\n      else do\n      if pos(\"/\",dsn) = 0 then\n        if pos('*',dsn) = 0 then do\n        x = listdsi(dsn)\n        if mem /= null\n        then sysdsname = sysdsname'('mem')'\n        dsn = \"'\"sysdsname\"'\"\n      end\n      end\n      edsdsn = edsdsn dsn\n    end\n    end\n    edsdsn = strip(edsdsn)\n    return\n  end\n*ENDREXX\n ver (&o1,nb,num)\n ver (&o2,nb,num)\n ver (&o3,nb,num)\n ver (&o4,nb,num)\n ver (&o5,nb,num)\n ver (&o6,nb,num)\n ver (&o7,nb,num)\n ver (&o8,nb,num)\n ver (&o9,nb,num)\n ver (&o10,nb,num)\n ver (&o11,nb,num)\n ver (&o12,nb,num)\n ver (&o13,nb,num)\n ver (&o14,nb,num)\n ver (&o15,nb,num)\n ver (&o16,nb,num)\n if (&zedlmsg EQ &Z)\n    if (&edsgrp EQ &Z)\n       if (&gendsn EQ &Z)\n          ver (&edsdsn,nb,dsname)\n if (&zedlmsg NE &Z)\n    .cursor = &cpos\n    .msg = isrz001\n)End\n>Panel edslg\n)Attr\n $ type(output) caps(off) intens(low)\n @ type(output) caps(off) intens(low)\n + type(text  )\n _ type(input ) hilite(uscore) caps(on) intens(low)\n)Body Window(45,20) Expand(\\\\)\n%Command ===>_zcmd\n+\n+\n +$z +$d1                                 $z\n +$z +$d2                                 $z\n +$z +$d3                                 $z\n +$z +$d4                                 $z\n +$z +$d5                                 $z\n +$z +$d6                                 $z\n +$z +$d7                                 $z\n +$z +$d8                                 $z\n +$z +$d9                                 $z\n +$z +$d10                                $z\n +$z +$d11                                $z\n +$z +$d12                                $z\n +$z +$d13                                $z\n +$z +$d14                                $z\n +$z +$d15                                $z\n +$z +$d16                                $z\n+\n)Init\n*Rexx(zwinttl edsgrp)\n zwinttl = 'EDSL Group:' edsgrp\n*EndRexx\n .zvars = '(o1 sc1 o2 sc2 o3 sc3 o4 sc4 o5 sc5 o6 sc6 o7 sc7 o8 sc8 +\n            o9 sc9 o10 sc10 o11 sc11 o12 sc12 o13 sc13 o14 sc14 +\n            o15 sc15 o16 sc16)'\n*Rexx(* edsgrp d1 d2 d3 d4 d5 d6 d7 d8 o1 o2 o3 o4 o5 o6 o7 o8 edsdsn ,\n       o9 o10 o11 o12 o13 o14 o15 o16 d9 d10 d11 d12 d13 d14 d15 d16)\n parse value '1 2 3 4 5 6 7 8' with o1 o2 o3 o4 o5 o6 o7 o8\n parse value '9 10 11 12 13 14 15 16' with o9 o10 o11 o12 o13 o14 o15 o16\n d1 = word(edsdsn,1)\n d2 = word(edsdsn,2)\n d3 = word(edsdsn,3)\n d4 = word(edsdsn,4)\n d5 = word(edsdsn,5)\n d6 = word(edsdsn,6)\n d7 = word(edsdsn,7)\n d8 = word(edsdsn,8)\n d9 = word(edsdsn,9)\n d10 = word(edsdsn,10)\n d11 = word(edsdsn,11)\n d12 = word(edsdsn,12)\n d13 = word(edsdsn,13)\n d14 = word(edsdsn,14)\n d15 = word(edsdsn,15)\n d16 = word(edsdsn,16)\n*EndRexx\n .help = edsleh\n)Proc\n)FIELD\n  FIELD(d1)  LEN(55) IND(SC1,'<>')\n  FIELD(d2)  LEN(55) IND(SC2,'<>')\n  FIELD(d3)  LEN(55) IND(SC3,'<>')\n  FIELD(d4)  LEN(55) IND(SC4,'<>')\n  FIELD(d5)  LEN(55) IND(SC5,'<>')\n  FIELD(d6)  LEN(55) IND(SC6,'<>')\n  FIELD(d7)  LEN(55) IND(SC7,'<>')\n  FIELD(d8)  LEN(55) IND(SC8,'<>')\n  FIELD(d9)  LEN(55) IND(SC9,'<>')\n  FIELD(d10) LEN(55) IND(SC10,'<>')\n  FIELD(d11) LEN(55) IND(SC11,'<>')\n  FIELD(d12) LEN(55) IND(SC12,'<>')\n  FIELD(d13) LEN(55) IND(SC13,'<>')\n  FIELD(d14) LEN(55) IND(SC14,'<>')\n  FIELD(d15) LEN(55) IND(SC15,'<>')\n  FIELD(d16) LEN(55) IND(SC16,'<>')\n)End\n>Panel edsleh\n)Attr\n @ type(output) caps(off) intens(low) color(turq)\n $ type(input ) hilite(uscore) caps(on) intens(low)\n _ type(input ) hilite(uscore) caps(on) intens(low)\n)Body Expand(\\\\)\n+Tutorial\\-\\%Enhanced Data Set List+\\-\\Tutorial\n%Command ===>_zcmd\n+\n+Enter, or Update, the dataset name or group name and datasets. Or a single\n+OMVS file or directory may be entered (per group).\n+\n+If the%Group+name is blank then only 1 dataset name may be entered.\n+\n+If only a%Group+name is entered without datasets then it functions as a\n+separator row.\n+\n+Each row has a sequence number that may be changed to change the order of the\n+datasets in the group (from 1 to 8).\n+\n+The%Dataset Name+is entered using standard TSO/ISPF conventions. After entry\n+the dataset name will be validated and fully qualified with quotes.\n+\n+A member name may be entered with a dataset name (no masking allowed).\n+\n+If the%Dataset+is entered with an%*+then it will be considered a dataset list\n+and any action selection will open using the ISPF Data Set List dialog.\n+\n)Init\n)Proc\n &zcont = edsleh\n)End\n>Skel edshelp\n Function:\n The EDSL exec invokes the Extended Data Set List dialog.\n\n The Enhanced Data Set List dialog makes it easy to access an individual\n dataset or OMVS file (Browse/Edit/View), groups of datasets (DSList or\n Browse/Edit/View), or an OMVS directory (UDList).\n\n A group will create or replace a list within the existing ISPF Personal\n Data Set List structure after an Open in DSLIST has been issued for the\n group.  The lists can be accessed in ISPF by the REFOPEND command.\n\n ---\n Copyleft (C) 2020, Lionel Dyck and Janko Kalinic\n\n This program is free software: you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n   http://www.gnu.org/licenses/\n\n Syntax:\n\n   %EDSL\n         Open the EDSL list of groups\n   %EDSL group\n         open the specified group using the default selection option\n         Type    selection option\n         D       Member List\n         G       Member List\n         L       DSList\n         O       UDList\n   %EDSL sel group\n         open the group using the sel option (e.g. E)\n   %EDSL sel group member (or member mask)\n         open the group using the sel option (e.g. E)\n\n Aliases  - none.\n Required - none.\n\nOperands:\n  group        - open the specified group using the default selection\n                 option.\n  sel          - selection option\n                 (E=Edit, B=Browse, V=View, O=DSList/UDList)\n  member       - member name or mask.\n\n<PRIMARY><COMMANDS>\n\n    Find    - Find the provided string\n    HEL cmd - Display EDSL help for a cmd\n    History - Display modification history\n    Insert  - Insert a row into the table\n    REFresh - Refresh the group tree display        (Tree)\n    RFind   - Repeat find of the provided string    (Tree)\n    Set     - Display the settings window\n    Table   - Switch to ISPF table view             (Tree)\n    Tree    - Display the group tree view           (Table)\n    Version - Display EDSL\u00ae version number\n    X ALL   - Exclude all group tree nodes          (Tree)\n    Qref    - Display EDSL\u00ae quick reference\n    Debug   - Dump table for debugging              (Tree-undoc)\n    Metrics - Display EDSTYPE statistics            (Tree-undoc)\n    ISPList - Write tree table to ISPLIST           (Tree-undoc)\n    /       - Popup selection menu\n\n<LINE><COMMANDS>\n\n  B   -  Browse\n  D   -  Delete a row\n  E   -  Edit\n  I   -  Insert a row\n  M   -  Move row up one\n  MD  -  Move row down one                 (Table)\n  Mx  -  Move row up (-#) down(+#)         (Table)\n  N   -  Move row down one                 (Tree)\n  /   -  Popup Selection menu\n  O   -  Open in Dataset List\n  R   -  Display the group                 (Table)\n  S   -  Select\n  .   -  Cursor select (S)                 (Tree)\n  U   -  Update (alias C)\n  V   -  View\n  X   -  Exclude tree node (toggle)        (Tree)\n  any -  (with Dataset only)               (Table)\n\n Syntax: line command\n\n<FIND>\n Function:\n\n Find will find the value in the display.\n\n Syntax: Find value\n\n<RFIND>\n Function:\n\n Repeat Find will find the next value in the display.\n\n The ISPF command table must have a user controlled variable for RFIND\n in order for this to work properly.\n\n    Verb      T  Action\n                    Description\n    RFIND     0  &USRRFIND\n                    User controlled variable for RFIND\n    RFIND     0  SETVERB\n                    REPEAT FIND\n\n If you can not update the installation ISPF command table, here is\n a rexx solution you can add to EDSL early on in the exec.\n\n    zctverb  = \"RFIND\"\n    zcttrunc = 0\n    zctact   = \"&USRRFIND\"\n    zctdesc  = \"User controlled variable for RFIND\"\n    'vget (zsctpref)'\n    ctab = zsctpref'cmds'\n    'tbtop' ctab\n    'tbsarg' ctab\n    'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'\n    if rc > 0 then 'tbadd' ctab\n    usrrfind = null\n    'vput (usrrfind)'\n\n Syntax: RFind\n\n<REFRESH>\n Function:\n\n REFresh will refresh the Tree Display by reading the EDSL ISPF\n table.\n\n\n Syntax: REFresh\n\n<SET>\n Function:\n\n Set will display the settings pop-up and allow you to change the\n display view (TABLE or TREE).\n\n Syntax: Set\n\n<INSERT>\n Function:\n\n Insert will insert a row into the table\n\n Syntax: Insert\n\n<TREE>\n Function:\n\n Tree will display the the group tree view when in Table display.\n\n Node Colors:   Group=blue  OMVS=yellow  DSList=green  DSName=pink\n\n  .------------------------------------------------------.\n  | EDSL\u00ae            Tree Display                        |\n  | Command ===>                                         |\n  |                                                      |\n  | . 'TRIDJK.GEN3'                                      |\n  |       'TRIDJK.GEN3'                                  |\n  | . GENS-2                                             |\n  |       'TRIDJK.GEN3'                                  |\n  |       'TRIDJK.GEN7.PDS'                              |\n  |       'AD.RACFADM.*'                                 |\n  | . SequentialDatasetsBIN...                           |\n  |       'TRIDJK.BIN'                                   |\n  |       'TRIDJK.BIN2'                                  |\n  | . RACFADM Version 130                                |\n  |       'ad.racfadm.v130.*'                            |\n  | . g5                                                 |\n  |       'TRIDJK.GEN.CNTL'                              |\n  |       'TRIDJK.GEN3'                                  |\n  |   ------------------------                           |\n  | . Unix                                               |\n  |       /u/tridjk/                                     |\n  .------------------------------------------------------.\n\n Syntax: Tree\n\n<TABLE>\n Function:\n\n Table will display the ISPF table view when in Tree display.\n\n   .-------------------------------------------------------.\n  | EDSL\u00ae ----------- Enhanced Data Set List  1.37       |\n  | Command ===>                                         |\n  |                                                      |\n  | Select     Type   Dataset/Group                      |\n  |              D    'TRIDJK.GEN3'                      |\n  |              L    GENS-2                             |\n  |              G    SequentialDatasetsBIN...           |\n  |              L    RACFADM Version 130                |\n  |              G    g5                                 |\n  |                   ------------------------           |\n  |              O    Unix                               |\n  |              G    aftunix                            |\n  |              G    g11                                |\n  |                   ------------------------           |\n  |              D    'TRIDJK.GEN4'                      |\n  .------------------------------------------------------.\n\n Syntax: Table\n\n<X ALL>\n Function:\n\n X ALL will exclude all dsname lines in the Tree display.\n\n  .------------------------------------------------------.\n  | EDSL\u00ae             Tree Display                       |\n  | Command ===>                                         |\n  |                                                      |\n  | + 'TRIDJK.GEN3'                                      |\n  | + GENS-2                                             |\n  | + SequentialDatasetsBIN...                           |\n  | + RACFADM Version 130                                |\n  | + g5                                                 |\n  |   ------------------------                           |\n  | + Unix                                               |\n  | + aftunix                                            |\n  | + g11                                                |\n  |   ------------------------                           |\n  | + 'TRIDJK.GEN4'                                      |\n  .------------------------------------------------------.\n\n Syntax: X ALL\n\n<VERSION>\n Function:\n\n Version will display the EDSL version in the long message area.\n\n Syntax: Version\n\n  .-------------------------------------.\n  | EDSL\u00ae 1.37                          |\n  | Lionel Dyck and John Kalinich       |\n  | The ISPF Cabal - Vive la r\u00e9volution |\n  | Copyleft - GNU GPL v3               |\n  .-------------------------------------.\n\n</>\n Function:\n\n / will display a point-and-shoot Hotlist Command pop-up panel\n for you to select from.\n\n  .------------ EDSL Primary Commands: --------------.\n  | Command ===>                                     |\n  |                                                  |\n  |  I Insert   - insert a row into the table        |\n  |  H History  - display the change history of EDSL |\n  |  Q Quickref - display command quick reference    |\n  |  S Set      - display the settings window        |\n  |  T Tree     - display a tree view of the table   |\n  |  V Version  - display EDSL\u00ae version number       |\n  |  F Find     - find the provided string           |\n  |    Find:                                         |\n  |                                                  |\n  |            Or F3 to cancel                       |\n  .--------------------------------------------------.\n\n Syntax: /\n\n<HISTORY>\n Function:\n\n History will display a history of EDSL modifications.\n\n Syntax: History\n\n<QREF>\n Function:\n\n Qref will display the PGLITE quick reference card.  Commands that are\n only available in the Tree display view are colored blue.\n\n Syntax: Qref\n\n<ISPLIST>\n Function:\n\nISPList will write out the tree table to the ISPLIST file.\n\n Syntax: ISPList\n\n<HEL>\n Function:\n\n HEL will display the EDSL pseudo TSO Help member that you are\n reading now.\n\n Syntax: HEL command\n\n<MESSAGES>\n Function:\n The MESSAGE HELP entry is provided to document EDSL messages.\n\n EDSL has the following messages:\n\n  CHARS 'chars' found\n   Search for CHARS 'chars' was successful.\n\n  *Bottom of list reached*\n   CHARS 'chars' not found. Press RFIND key to continue the search from\n   the top of the member list.\n\n  EDSL\u00ae version\n   The VERSION command displays the EDSL version information.\n\n  EDSL\u00ae Motto...\n   When you believe an idea, hold true.\n>End */\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EKKO": {"ttr": 11267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x161\\x0f\\x01\\x161\\x0f\\x13W\\x01\\x9d\\x01\\x9d\\x00\\x00\\xc3\\xc2\\xe3\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-05T00:00:00", "modifydate": "2016-11-05T13:57:08", "lines": 413, "newlines": 413, "modlines": 0, "user": "CBTUSER"}, "text": "         TITLE '   E C H O   '\n************************************************************\n*                                                          *\n*        'ECHO' TSO COMMAND                                *\n*                                                          *\n************************************************************\n         SPACE\n* WRITTEN NOVEMBER 5 2016\n* THIS TSO COMMAND ECHOES THE TEXT ON THE COMMAND LINE TO THE SCREEN.\n* IT COULD BE INSTALLED AS 'ECHO', OR ANYTHING ELSE, BUT\n* IF THERE ALREADY IS A COMMAND NAMED 'ECHO' ON THE SYSTEM\n* THEN IT MIGHT BE NECESSARY TO USE A NAME OTHER THAN 'ECHO'.\n*\n* SYNTAX:\n*  ECHO TEXT TO BE DISPLAYED\n*  ECHO 'TEXT TO BE DISPLAYED\n*  ECHO 'TEXT TO BE DISPLAYED'\n*\n* IF NO TEXT IS SPECIFIED, A BLANK LINE IS DISPLAYED.\n* IF THE TEXT BEGINS WITH A QUOTE THEN (1) THE QUOTE IS REMOVED\n* AND (2) AN OPTIONAL TRAILING QUOTE, IF PRESENT, WILL BE REMOVED.\n*\n* A TRAILING QUOTE IS ONLY NEEDED IF THE QUOTED TEXT TO BE DISPLAYED\n* HAS A TRAILING PLUS (+) OR MINUS (-) BECAUSE THEY NORMALLY\n* INDICATE CONTINUATION OF A COMMAND LINE.\n* A TRAILING QUOTE IS NEEDED IN ISPF OUTSIDE A REXX EXEC OR CLIST,\n* IF THE TEXT BEGINS WITH A QUOTE, AS ISPF CHECKS FOR MATCHED QUOTES.\n*\n* TO DISPLAY SOMETHING WITH A LEADING QUOTE, SPECIFY 2 LEADING QUOTES.\n* QUOTES WITHIN A QUOTED STRING DO NOT NEED TO BE DOUBLED, UNLESS\n* THE COMMAND IS RUN IN ISPF OUTSIDE A REXX EXEC OR A CLIST.\n* IF THEY ARE DOUBLED THEN THEY WILL BE DISPLAYED AS A SINGLE QUOTE.\n*\n* UNQUOTED STRINGS THAT ARE INDENTED WILL DISPLAY WITH LEADING SPACES.\n*\n* EXAMPLES:\n*  ECHO THIS IS TEXT\n*  ECHO  THIS IS TEXT WITH A LEADING SPACE\n*  ECHO   THIS IS TEXT WITH 2 LEADING SPACES\n*  ECHO '  THIS IS TEXT WITH 2 LEADING SPACES'\n*  ECHO   '  THIS IS TEXT WITH 2 LEADING SPACES'\n*  ECHO IT'S TEXT WITH A SINGLE QUOTE\n*  ECHO 'IT'S TEXT WITH A SINGLE QUOTE\n*  ECHO 'IT'S TEXT WITH A SINGLE QUOTE'\n*  ECHO 'IT''S TEXT WITH A DOUBLED SINGLE QUOTE'\n*  ECHO 'THIS IS TEXT WITH A TRAILING HYPHEN -'\n*  ECHO 'THIS IS TEXT WITH A TRAILING PLUS SIGN +'\n*  ECHO 'THIS IS TEXT WITH NO TRAILING QUOTE NEEDED\n*  ECHO      (PRINTS BLANK LINE)\n*  ECHO '    (PRINTS BLANK LINE)\n*  ECHO ''   (PRINTS BLANK LINE)\n*  ECHO '''  (PRINTS ONE QUOTE)\n*  ECHO '''' (PRINTS ONE QUOTE)\n*\n* A COMMAND WITH AN UNEVEN NUMBER OF QUOTES, IF ENTERED WITHIN ISPF\n* AND OUTSIDE OF A REXX EXEC OR A CLIST, SUCH AS DIRECTLY ON PANEL 6,\n* WILL BE FAILED BY ISPF WITH THIS MESSAGE:\n*  ISPD289  MISMATCHED QUOTES - THE STRING CONTAINS AN UNEVEN NUMBER\n*           OF QUOTES.\n* THERE IS RARELY A NEED TO RUN THE 'ECHO' COMMAND DIRECTLY,\n* OUTSIDE A REXX EXEC OR A CLIST, IN ISPF, EXCEPT FOR TESTING,\n* BUT MESSAGE ISPD289 CAN BE AVOIDED BY SPECIFYING PAIRS OF QUOTES\n* WHERE ONE OUTPUT QUOTE IS DESIRED. SO INSTEAD OF THESE COMMANDS:\n*  ECHO LET'S BEGIN\n*  ECHO 'LET'S BEGIN'\n* THESE COMMANDS WILL PRODUCE THE SAME DESIRED RESULT:\n*  ECHO LET''S BEGIN\n*  ECHO 'LET''S BEGIN'\n* THE SAME IS TRUE INSIDE A REXX EXEC OR A CLIST, BUT NOT NEEDED.\n         SPACE\n* INTERCEPT 'LINK' MACROS IMBEDDED IN PUTLINE & STACK\n* TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nECHO     START\n         USING *,R12\n         B     @PROLOG-*(,R15)\n         DC    AL1(5),CL5'ECHO'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(R13)\n         LR    R12,R15             BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         LR    R9,R1\n         XC    0(72,R1),0(R1)\n         USING @DATA24,R9\n         ST    R13,4(,R1)          CHAIN SAVEAREA\n         ST    R1,8(,R13)          CHAIN SAVEAREA\n         LR    R13,R1              NEW SAVEAREA\n         SPACE\n         XC    LINKAREA(8),LINKAREA\n         LA    R15,12\n         STH   R15,RETCODE         SET RETCODE = 12\n         MVI   DEBUG,0\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK COMMAND BUFFER POINTED TO BY CPPLCBUF       *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   DEBUG,0\n         BE    NODEBUG1\n         L     R1,CPPLCBUF\n         LH    R0,0(,R1)           GET LENGTH\n         LA    R15,OBUF\n         BAL   R14,TOHEX1\n         LA    R1,OBUF\n         LR    R0,R15\n         SR    R0,R1\n         BAL   R14,PUTLINE\n         SPACE\n         L     R1,CPPLCBUF\n         LH    R0,0(,R1)           GET LENGTH\n         LH    R14,2(,R1)          GET OFFSET\n         LA    R1,4(,R1)           POINT TO COMMAND\n         SH    R0,=H'4'            REDUCE LENGTH BY 4\n         AR    R1,R14              POINT TO OPERAND\n         SR    R0,R14              REDUCE LENGTH BY OFFSET\n         BZ    NODATA              NO OPERAND\n         LA    R15,OBUF\n         BAL   R14,TOHEX1\n         LA    R1,OBUF\n         LR    R0,R15\n         SR    R0,R1\n         BAL   R14,PUTLINE\nNODATA   EQU   *\nNODEBUG1 EQU   *\n         SPACE\n         L     R1,CPPLCBUF\n         LH    R0,0(,R1)           GET LENGTH\n         LH    R14,2(,R1)          GET OFFSET\n         LA    R1,4(,R1)           POINT TO COMMAND\n         SH    R0,=H'4'            REDUCE LENGTH BY 4\n         AR    R1,R14              POINT TO OPERAND\n         SR    R0,R14              REDUCE LENGTH BY OFFSET\n         BZ    NULL                NO OPERAND\n         CLI   0(R1),C''''         IF NOT QUOTED\n         BE    QUOTED\n*              BACK UP TO LAST CHAR OF COMMAND\nLOOP     BCTR  R1,0\n         A     R0,=F'1'\n         CLI   0(R1),C' '\n         BE    LOOP\n*              POINT R1 TO OPERAND OR LEADING BLANKS\n         LA    R1,2(,R1)\n         S     R0,=F'2'\n         BAL   R14,SQUEEZE         CHANGE ALL '' TO '\n         LTR   R0,R0\n         BZ    NULL\n         BAL   R14,PUTLINE\n         B     EXIT0\nNULL     LA    R1,=C' '\n         LA    R0,1\n         BAL   R14,PUTLINE\n         B     EXIT0\nQUOTED   CH    R0,=H'1'            IF NOTHING BUT A SINGLE QUOTE\n         BE    NULL\n         LR    R15,R1\n         AR    R15,R0              POINT PAST LAST CHAR\n         BCTR  R15,0               POINT TO LAST CHAR\n         LA    R1,1(,R1)           POINT PAST LEADING QUOTE\n         BCTR  R0,0                REDUCE LENGTH BY 1\n         CLI   0(R15),C''''        IF STRING ENDS WITH A QUOTE\n         BNE   NOENDQ\n         BCTR  R0,0                REDUCE LENGTH FOR TRAILING QUOTE\n         LTR   R0,R0\n         BZ    NULL\nNOENDQ   EQU   *\n*        CHANGE ALL '' TO '\n         BAL   R14,SQUEEZE\n         LTR   R0,R0\n         BZ    NULL\n         BAL   R14,PUTLINE\n         B     EXIT0\n         SPACE\nSQUEEZE  LR    R4,R14\n         C     R0,=F'256'          IF TOO LONG FOR OBUF AND MYSEG1\n         BNH   *+8                   THEN\n         L     R0,=F'256'            TRUNCATE TEXT\n         LA    R15,OBUF\n         LR    R14,R1\n         AR    R14,R0              POINT PAST LAST CHAR\nSQ1      CR    R1,R14\n         BE    SQX\nSQ2      MVC   0(1,R15),0(R1)      COPY 1 BYTE\n         LA    R15,1(,R15)\n         CLI   0(R1),C''''         IF WE COPIED A QUOTE\n         BE    SQ4                   GO TO SQ4\nSQ3      LA    R1,1(,R1)\n         B     SQ1\nSQ4      LA    R1,1(,R1)           POINT TO CHAR AFTER 1ST QUOTE\n         CR    R1,R14              IF END OF STRING FOLLOWS 1ST QUOTE\n         BE    SQX                   DONE\n         CLI   0(R1),C''''         IF SECOND QUOTE\n         BE    SQ3                   IGNORE IT\n         B     SQ2\nSQX      LA    R1,OBUF\n         LR    R0,R15              POINT TO BYTE AFTER LAST BYTE COPIED\n         SR    R0,R1               COMPUTE LENGTH\n         LR    R14,R4\n         BR    R14\n         SPACE\nTOHEX1   MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX1\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\n         AGO   .SKIP1\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n.SKIP1   ANOP\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        TERMINATE                                         *\n*                                                          *\n************************************************************\n         SPACE\nEXIT0    MVI   RETCODE+1,0\nCLEANUP  EQU   *\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R2,RETCODE\n         SPACE\nEXIT     LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         FREEMAIN R,A=(1),LV=(0)\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\n         AGO   .SKIP2\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n.SKIP2   ANOP\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\nHEXTAB   DC    C'0123456789ABCDEF'\n         LTORG\n         DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA24  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nRETCODE  DS    H\nDEBUG    DS    C\nOBUF     DS    0D,256C\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\n         PRINT NOGEN\n         IKJCPPL\n         SPACE\n         IKJPPL\n         SPACE\n         IKJUPT\n         SPACE\n         IKJIOPL\n         SPACE\n*        IKJPSCB\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EKKO$": {"ttr": 11274, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00S\\x01\\x07\"_\\x01\\x161\\x1f !\\x00\\x1b\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2016-11-06T20:21:53", "lines": 27, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.CBT493.FILE300(EKKO)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,RENT,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   ECHO\n SETSSI  CB493300\n ENTRY   ECHO\n NAME    EKKO(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EKKOH": {"ttr": 11276, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x163\\x7f\\x01\\x163\\x7f\\x06\\x14\\x00N\\x00N\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-02T00:00:00", "modifydate": "2016-12-02T06:14:59", "lines": 78, "newlines": 78, "modlines": 0, "user": "SBGOLOB"}, "text": ")F FUNCTION\n\n     Echo the provided text to the terminal using PUTLINE.\n\n     This allows the text to be captured using REXX OUTTRAP commands.\n\n  The reason for this is that using the REXX SAY while the REXX OUTTRAP\n  are active does not allow the text to be captured. Using EKKO resolves\n  this challenge.\n\n)X SYNTAX\n\n     EKKO TEXT\n     EKKO Text to be Displayed\n     EKKO 'Text To Be Displayed\n     EKKO 'TEXT To be displayed'\n\n)O TEXT\n\n If no text is specified, a blank line is displayed.\n\n If the text begins with a quote then (1) the quote is removed\n and (2) an optional trailing quote, if present, will be removed.\n\n A trailing quote is only needed if the quoted text to be displayed\n has a trailing plus (+) or minus (-) because they normally\n indicate continuation of a command line.\n\n A trailing quote is needed in ispf outside a rexx exec or clist,\n if the text begins with a quote, as ispf checks for matched quotes.\n\n To display something with a leading quote, specify 2 leading quotes.\n quotes within a quoted string do not need to be doubled, unless\n the command is run in ispf outside a rexx exec or a clist.\n If they are doubled then they will be displayed as a single quote.\n\n Unquoted strings that are indented will display with leading spaces.\n\n Examples:\n  ekko this is text\n  ekko  this is text with a leading space\n  ekko   this is text with 2 leading spaces\n  ekko '  this is text with 2 leading spaces'\n  ekko   '  this is text with 2 leading spaces'\n  ekko it's text with a single quote\n  ekko 'it's text with a single quote\n  ekko 'it's text with a single quote'\n  ekko 'it''s text with a doubled single quote'\n  ekko 'this is text with a trailing hyphen -'\n  ekko 'this is text with a trailing plus sign +'\n  ekko 'this is text with no trailing quote needed\n  ekko      (prints blank line)\n  ekko '    (prints blank line)\n  ekko ''   (prints blank line)\n  ekko '''  (prints one quote)\n  ekko '''' (prints one quote)\n\n A command with an uneven number of quotes, if entered within ispf\n and outside of a rexx exec or a clist, such as directly on panel 6,\n will be failed by ispf with this message:\n\n  ISPD289  MISMATCHED QUOTES - THE STRING CONTAINS AN UNEVEN NUMBER\n           OF QUOTES.\n\n There is rarely a need to run the 'ekko' command directly,\n outside a rexx exec or a clist, in ispf, except for testing,\n but message ISPD289 can be avoided by specifying pairs of quotes\n where one output quote is desired. so instead of these commands:\n\n  ekko let's begin\n  ekko 'let's begin'\n\n These commands will produce the same desired result:\n\n  ekko let''s begin\n  ekko 'let''s begin'\n\n The same is true inside a rexx exec or a clist, but not needed.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EMAC": {"ttr": 11521, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x07 S\\x01\\x17\\x11O\\x01\\x17\\x15\\x1f\\tB\\x04\\x9e\\x046\\x00\\x00\\xd3\\xc2\\xc4@@@@@\\x00\\x00\\x04\\x9e\\x00\\x00\\x046\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.07", "flags": 32, "createdate": "2017-04-24T00:00:00", "modifydate": "2017-05-31T09:42:53", "lines": 1182, "newlines": 1078, "modlines": 0, "user": "LBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "EXTISPF": {"ttr": 11786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x008\\x01\\x18\\x13\\x8f\\x01\\x18\\x13\\x8f\\x13V\\x00\\xe3\\x00\\xe3\\x00\\x00\\xc5\\xe7\\xe3\\xc9\\xe2\\xd7\\xc6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-18T00:00:00", "modifydate": "2018-05-18T13:56:38", "lines": 227, "newlines": 227, "modlines": 0, "user": "EXTISPF"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      EXTISPF                                         |\n |                                                            |\n | Function:  ISPF Edit Macro to extract imbedded ISPF        |\n |            elements into target PDS datasets               |\n |                                                            |\n |            All elements will be extracted from the         |\n |            active EXEC into datasets prefixed by           |\n |            the provided HLQ:                               |\n |                                                            |\n |            hlq.CLIST                                       |\n |            hlq.EXEC                                        |\n |            hlq.MSGS                                        |\n |            hlq.PANELS                                      |\n |            hlq.SKELS                                       |\n |                                                            |\n |            These datasets will be dynamically allocated    |\n |            using the DCB of the active dataset.            |\n |                                                            |\n | Syntax: EXTISPF hlq                                        |\n |                                                            |\n | Usage Notes:                                               |\n | 1. Requires a target PDS HLQ as the only parm              |\n | 2. The HLQ must be a full HLQ without quotes               |\n |    e.g. userid.EXTRACT                                     |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            05/18/18 - Major updates                        |\n |            08/28/17 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro (targhlq)'\n\n if targhlq = '' then do\n    say \"A HLQ must be provided - e.g. 'userid.XXX'\" ,\n        \"or just XXX \"\n    exit 8\n    end\n\n/* ------------------- *\n | Define our defaults |\n * ------------------- */\n  parse value '' with null clist exec msgs panels skels type\n\n  targhlq = fixup_dsn(targhlq)\n\n/* ------------------------------------------ *\n | First validate the Target PDS Dataset Name |\n * ------------------------------------------ */\n  if targhlq = null then do\n    zedsmsg = 'Error'\n    zedlmsg = 'EXTISPF requires a target-hlq'\n    Address ISPExec 'Setmsg msg(isrz001)'\n    exit 8\n  end\n\n/* ------------------------------------------------- *\n | Get the DCB characteristics of the source dataset |\n * ------------------------------------------------- */\n  '(dataset) = dataset'\n  call listdsi \"'\"dataset\"'\"\n\n/* ------------------------------------------ *\n | Now Extract each Element to the Target PDS |\n * ------------------------------------------ */\n  '(last) = linenum .zlast'\n  hit = 0\n  rec = 0\n  dd = 'EP'random(9999)\n  do i = 1 to last\n    '(data) = line' i\n    if translate(left(data,6)) = '>END' then do\n      call write_it_out\n      leave\n    end\n    if left(data,1) = '>' then do\n      if hit = 1 then call write_it_out\n      hit = 0\n    end\n    if hit = 1 then do\n      rec = rec + 1\n      member.rec = data\n    end\n    Select\n      When translate(left(data,6)) = '>CLIST' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'CLIST'\n      end\n      When translate(left(data,5)) = '>EXEC' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'EXEC'\n      end\n      When translate(left(data,5)) = '>MSG' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'MSGS'\n      end\n      When translate(left(data,6)) = '>PANEL' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'PANELS'\n      end\n      When translate(left(data,5)) = '>SKEL' then do\n        if hit = 1 then call write_it_out\n        hit = 1\n        member = word(data,2)\n        type = 'SKELS'\n      end\n      Otherwise nop\n    end\n  end\n\n/* -------------------------------- *\n | Now Display the Created Datasets |\n * -------------------------------- */\n  Address ISPExec\n  \"LMDINIT LISTID(LISTID) LEVEL(\"targhlq\")\"\n  \"LMDDISP LISTID(\"ListId\") Confirm(Yes)\",\n    \"View(Volume)\"\n  \"LMDFREE LISTID(\"ListId\")\"\n  exit\n\n/* ------------------------------------------------ *\n | Write out the element                            |\n |                                                  |\n | if the target type pds has not been created then |\n | create it.                                       |\n * ------------------------------------------------ */\nWrite_It_Out:\n  hit = 0\n  Address TSO\n  Select\n    When type = 'CLIST' then do\n      if clist = null then do\n        clist = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(clist) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('clist')'\n          'Free ds('clist')'\n        end\n      end\n    end\n    When type = 'EXEC' then do\n      if exec = null then do\n        exec = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(exec) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('exec')'\n          'Free ds('exec')'\n        end\n      end\n    end\n    When type = 'MSGS' then do\n      if msgs = null then do\n        msgs = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(msgs) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('msgs')'\n          'Free ds('msgs')'\n        end\n      end\n    end\n    When type = 'PANELS' then do\n      if panels = null then do\n        panels = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(panel) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('panels')'\n          'Free ds('panels')'\n        end\n      end\n    end\n    When type = 'SKELS' then do\n      if skels = null then do\n        skels = \"'\"targhlq\".\"type\"'\"\n        if sysdsn(skel) /= 'OK' then do\n          'Alloc new tracks spa(15,15) dir(12) new' ,\n            'dsname('skels')'\n          'Free ds('skels')'\n        end\n      end\n    end\n    Otherwise nop\n  end\n  member.0 = rec\n  say \"Creating element: '\"targhlq\".\"type\"(\"member\")'\"\n  \"Alloc f(\"dd\") ds('\"targhlq\".\"type\"(\"member\")') shr reuse\"\n  'Execio * diskw' dd '(finis stem member.'\n  'Free f('dd')'\n  drop member.\n  rec = 0\n  Address ISREdit\n  return\n\nFixup_dsn: procedure\n  arg cddsn\n  if cddsn = null then return\n  Select\n    When left(cddsn,1) = \"'\" then do\n      wdsn = substr(cddsn,2,length(cddsn)-2)\n    end\n    When left(cddsn,length(sysvar('syspref'))) = sysvar('syspref')\n    then wdsn = cddsn\n    When left(cddsn,length(sysvar('sysuid'))) = sysvar('sysuid')\n    then wdsn = cddsn\n    Otherwise do\n      if sysvar('syspref') = null\n      then do\n        hlq = sysvar('sysuid')\n        wdsn = cddsn\n      end\n      else do\n        hlq = sysvar('syspref')\n        wdsn = hlq'.'cddsn\n      end\n    end\n  end\n  return wdsn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FASTPATH": {"ttr": 12037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x001\\x01\\x16\\x10\\x8f\\x01\\x17$\\x1f\\x10S\\x04\\xf5\\x06Y\\x00\\x00\\xd3\\xc2\\xc4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2016-04-17T00:00:00", "modifydate": "2017-08-29T10:53:31", "lines": 1269, "newlines": 1625, "modlines": 0, "user": "LBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "FINDDDM": {"ttr": 12550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x003\\x01\\x13$/\\x01\\x130\\x1f\\x11!\\x00]\\x00W\\x00\\x00\\xd4\\xe5\\xe2\\xd3\\xc2\\xc4\\xf1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2013-08-30T00:00:00", "modifydate": "2013-10-28T11:21:33", "lines": 93, "newlines": 87, "modlines": 0, "user": "MVSLBD1"}, "text": "/* ------------------------- REXX ---------------------------------- *\n * Name:  findddm                                                    *\n *                                                                   *\n * Function: Find specified member in the specified DDname           *\n *           concatenation.                                          *\n *                                                                   *\n * Usage:    called from a rexx or clist                             *\n *                                                                   *\n *           library = findddm()                                     *\n *                                                                   *\n *           library will contain a count of dsnames found for the   *\n *           dd followed by the dsnames                              *\n *                                                                   *\n *           For example:                                            *\n *                                                                   *\n *           xx=findddm(ispmlib isrz00);say xx                       *\n *            2 ISP.SISPMENU SYS1.PROD.ISPMENU                       *\n *                                                                   *\n * History:                                                          *\n *           Updated 10/28/2013 by Lionel B. Dyck                    *\n *                   - cleanup for COMMAND and FUNCTION              *\n *                     generalization                                *\n *           Updated 5/28/2013 by Lionel B. Dyck                     *\n *                   - add test for function or command invocation   *\n *           Created 5/24/2013 by Lionel B. Dyck                     *\n * ----------------------------------------------------------------- */\n\n/* ----------------------------------------------------------------- *\n * Access variables to be used                                       *\n * ----------------------------------------------------------------- */\n parse source with sourcetype .\n arg dd mem\n\n/* ---------------------------- *\n * Define our working variables *\n * ---------------------------- */\n hit = 0\n results = ''\n\n/* ----------------------------------------------------------------- *\n * Trap list of current allocations                                  *\n * ----------------------------------------------------------------- */\n call outtrap 'trap.'\n Address TSO 'listalc sta'\n call outtrap 'off'\n\n/* ----------------------------------------------------------------- *\n * Process the allocations to find our DD                            *\n *    Skip the 1st record                                            *\n * ----------------------------------------------------------------- */\n do i = 2 to trap.0\n    Select\n      When left(trap.i,1) <> ' '\n           then do\n                dsn = word(trap.i,1)\n                if hit = 1 then call return_dsn\n                end\n      When substr(trap.i,3,1) <> ' '\n           then do\n                ddn = word(trap.i,1)\n                if ddn <> dd\n                   then if hit = 1 then signal dd_done\n                   else iterate\n                hit = 1\n                call return_dsn\n                end\n      Otherwise nop\n    end\n    end\n\n return words(results) results\n\n/* ----------------------------------------------------------------- *\n * Done so get out of here                                           *\n * ----------------------------------------------------------------- */\n dd_done:\n if sourcetype = 'COMMAND' then do\n     say '>>'results'<<'\n     return\n     end\n if length(results) = 0 then return 8\n if sourcetype = 'FUNCTION' then\n    return words(results) results\n\n/* ----------------------------------------------------------------- *\n * Test dsname for member and return all dsn's                       *\n * ----------------------------------------------------------------- */\n return_dsn: Procedure Expose results dsn mem\n   testdsn = \"'\"dsn\"(\"mem\")'\"\n   x = sysdsn(testdsn)\n   if x = \"OK\" then\n      results = strip(results dsn)\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDDSN": {"ttr": 12553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x005\\x00\\x97)O\\x01\\x19\\x12\\x9f\\x08G\\x00^\\x00'\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "1997-10-21T00:00:00", "modifydate": "2019-05-09T08:47:35", "lines": 94, "newlines": 39, "modlines": 0, "user": "SLBD"}, "text": "/* ------------------------- REXX ---------------------------------- *\n * Name:  finddsn                                                    *\n *                                                                   *\n * Function: Find the datasets allocted to a specified ddname        *\n *                                                                   *\n * Usage:    called from a rexx or clist                             *\n *                                                                   *\n *           library = finddsn(ddname)                               *\n *                                                                   *\n *           library will contain a count of dsnames found for the   *\n *           dd followed by the dsnames                              *\n *                                                                   *\n *           For example:                                            *\n *                                                                   *\n *           xx=finddsn(ispmlib);say xx                              *\n *            2 ISP.SISPMENU SYS1.PROD.ISPMENU                       *\n *                                                                   *\n * History:                                                          *\n *           Updated 05/09/2019 improve results                      *\n *           Updated 11/13/2013 by Lionel B. Dyck                    *\n *                   - created from FINDDDN                          *\n *           Updated 10/28/2013 by Lionel B. Dyck                    *\n *                   - cleanup for COMMAND and FUNCTION              *\n *                     generalization                                *\n *           Updated 5/28/2013 by Lionel B. Dyck                     *\n *                   - add test for function or command invocation   *\n *           Created 5/24/2013 by Lionel B. Dyck                     *\n * ----------------------------------------------------------------- */\n\n/* ----------------------------------------------------------------- *\n * Access variables to be used                                       *\n * ----------------------------------------------------------------- */\n parse source with sourcetype .\n arg dd\n\n/* ---------------------------- *\n * Define our working variables *\n * ---------------------------- */\n hit = 0\n results = ''\n\n/* ----------------------------------------------------------------- *\n * Trap list of current allocations                                  *\n * ----------------------------------------------------------------- */\n call outtrap 'trap.'\n Address TSO 'listalc sta'\n call outtrap 'off'\n\n/* ----------------------------------------------------------------- *\n * Process the allocations to find our DD                            *\n *    Skip the 1st record                                            *\n * ----------------------------------------------------------------- */\n do i = 2 to trap.0\n    Select\n      When left(trap.i,1) <> ' '\n           then do\n                dsn = word(trap.i,1)\n                if hit = 1 then call return_dsn\n                end\n      When substr(trap.i,3,1) <> ' '\n           then do\n                ddn = word(trap.i,1)\n                if ddn <> dd\n                   then if hit = 1 then signal dd_done\n                   else iterate\n                hit = 1\n                call return_dsn\n                end\n      Otherwise nop\n    end\n    end\n\n return words(results) results\n\n/* ----------------------------------------------------------------- *\n * Done so get out of here                                           *\n * ----------------------------------------------------------------- */\n dd_done:\n results = subword(results,1,words(results)-1)\n if sourcetype = 'COMMAND' then do\n     say '>>'results'<<'\n     return\n     end\n if length(results) = 0 then return 8\n if sourcetype = 'FUNCTION' then\n    return words(results) results\n\n/* ----------------------------------------------------------------- *\n * Test dsname for member and return all dsn's                       *\n * ----------------------------------------------------------------- */\n return_dsn: Procedure Expose results dsn\n   testdsn = \"'\"dsn\"'\"\n   results = strip(results dsn)\n   return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXBOOKP": {"ttr": 12556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x00\\x12o\\x01\\x00\\x12o\\x12\\x18\\x00\\x8a\\x00\\x8a\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-05-05T00:00:00", "modifydate": "2000-05-05T12:18:16", "lines": 138, "newlines": 138, "modlines": 0, "user": "WSBG"}, "text": "        /* --------------------  rexx procedure  -------------------- *\n         * Name:      FixbookP                                        *\n         *                                                            *\n         * Function:  ISPF Edit Macro to format a BookManager Read/MVS*\n         *            Print for Script/VS Postscript formatting and   *\n         *            printing.                                       *\n         *                                                            *\n         *            To use:                                         *\n         *            1. setup BookManager Read/MVS to print using    *\n         *               the GML starter set (option 2)               *\n         *            2. Print the section or sections you want       *\n         *            3. On the Script/VS panel put a / for browse    *\n         *            4. Put in something for listid (e.g. xx)        *\n         *            5. Change style to PSCRIPT (you may have to     *\n         *               create this style)                           *\n         *               - fontlib to SCRIPT.R40.FONTPS               *\n         *               - Device to PSA                              *\n         *               - Twopass to yes                             *\n         *            6. Split your ISPF screen and on the other 1/2  *\n         *               get into ISPF 3.4 and find the .PRINT        *\n         *               for the book you just printed                *\n         *            7. Edit it using this edit macro                *\n         *            8. save the updated .PRINT                      *\n         *            9. Run the Script/VS                            *\n         *            10. Do a binary download to your workstation    *\n         *                and copy to your printer                    *\n         *            or issue this command                           *\n         *            LPR xx.LISTPS (PRINTER printer HOST host-name   *\n         *                TYPE BINARY NOCC NOHEADER NOBURST           *\n         *            where:                                          *\n         *            host-name is the host name or dotted ip         *\n         *            address of a network postscript printer or a    *\n         *            server where the postscript printer is.         *\n         *            printer is the name of the printer              *\n         *                                                            *\n         * Syntax:    FIXBOOKP                                        *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Kaiser Permanente Information Technology        *\n         *            Walnut Creek, CA 94598                          *\n         *            (925) 926-5332                                  *\n         *            Internet: lionel.b.dyck@kp.org                  *\n         *                                                            *\n         * History:                                                   *\n         *            04/28/00 - created                              *\n         *                                                            *\n         * ---------------------------------------------------------- */\n\n        Address ISREdit\n        \"Macro\"\n\n        /* find book info for title and footing */\n        \"find ':H1' first\"\n        \"(l1) = cursor\"\n        \"(DATA) = LINE\" l1\n        parse value data with x book number .\n        \"Delete\" l1\n\n        \"find ':H2' first\"\n        \"(l1) = cursor\"\n        \"(data) = LINE\" l1\n        parse value data with x title\n        \"Delete\" l1\n\n        /* remove copyright :h2 tag */\n        \"find ':H2' first\"\n        \"(l1) = cursor\"\n        \"Delete\" l1\n\n        /* remove the .oc stuff */\n        \"find '.oc on' first\"\n        x_rc = rc\n        \"(l1) = cursor\"\n        \"find '.oc off'\"\n        y_rc = rc\n        \"(l2) = cursor\"\n        if x_rc = 0\n           then if y_rc = 0\n                then \"delete\" l1 l2\n\n        /* enable page numbers */\n        \"find '.pn' first\"\n        x_rc = rc\n        \"(l1) = cursor\"\n        \"line\" l1 \"= '.pn on'\"\n\n        /* replace .pa with .toc for table of contents */\n        \"find '.pa' first\"\n        x_rc = rc\n        \"(l1) = cursor\"\n        if x_rc = 0 then\n           \"delete\" l1\n\n        /* replace .df mono with usable font definition */\n        \"find '.df mono' first\"\n        x_rc = rc\n        \"(l1) = cursor\"\n        new_line = \".df mono type('courier' 8)\"\n        if x_rc = 0 then do\n           \"Line\" l1 \"=\" '\"'new_line'\"'\n           end\n\n        /* replace .df xmpfont with usable font definition */\n        \"find '.df xmpfont' first\"\n        x_rc = rc\n        \"(l1) = cursor\"\n        new_line = \".df xmpfont type('courier' 8)\"\n        if x_rc = 0 then\n           \"Line\" l1 \"=\" '\"'new_line'\"'\n\n        /* find gdoc and add frontm and toc and body */\n        \"find ':gdoc' first\"\n        x_rc = rc\n        \"(l1) = cursor\"\n        if x_rc = 0 then do\n           \"line_after\" l1 \"= ':frontm.'\"\n           i = 1\n           \"line_after\" l1+i \"= ':titlep.'\"\n           i = i + 1\n           \"line_after\" l1+i \"= ':title.\"title\"'\"\n           i = i + 1\n           \"line_after\" l1+i \"= ':docnum.\"number\"'\"\n           i = i + 1\n           \"line_after\" l1+i \"= ':etitlep.'\"\n           i = i + 1\n           \"line_after\" l1+i \"= ':toc.'\"\n           i = i + 1\n           \"line_after\" l1+i \"= ':body.'\"\n           i = i + 1\n           \"line_after\" l1+i \"= '.rf on'\"\n           i = i + 1\n           \"line_after\" l1+i \"= '.sp'\"\n           \"Scan Off\"\n           i = i + 1\n           \"line_after\" l1+i \"= '.ce\" book \" - &&$PS - \"number\"'\"\n           i = i + 1\n           \"line_after\" l1+i \"= '.rf off'\"\n           end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXKEYS": {"ttr": 12801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x004\\x01\\x19\\x02_\\x01\\x196O\\t\\x02\\x03B\\x03\\x18\\x00\\x00\\xc6\\xc9\\xe7\\xd2\\xc5\\xe8\\xe2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2019-01-25T00:00:00", "modifydate": "2019-12-30T09:02:34", "lines": 834, "newlines": 792, "modlines": 0, "user": "FIXKEYS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "FIXKEYS$": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x19\\x02_\\x01\\x19\\x02\\x9f\\t\\x15\\x00\\x14\\x00\\x11\\x00\\x00\\xc6\\xc9\\xe7\\xd2\\xc5\\xe8\\xe2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-01-25T00:00:00", "modifydate": "2019-01-29T09:15:48", "lines": 20, "newlines": 17, "modlines": 0, "user": "FIXKEYS"}, "text": "This package will allow the user to change the ISPF Key defaults\nfor up to 8 PFKeys across ALL ISPF Profiles (except ISPSPROF which\nis reserved).\n\nSyntax:  TSO %FIXKEYS\n\nBoth the FIXKEYS and FIXKEYST exec's need to be in the users SYSPROC\nor SYSEXEC library.\n\nThe dialog will:\n\n1. Prompt the user for up to 8 PF Keys to change\n2. Make a backup of the users ISPF Profile data set\n3. Change the PF Keys for all Profiles found in the users\n   ISPF Profile data set\n4. In support of SDSF, which just likes to be different,\n   RETRIEVE will be changed to CRETRIEV and RFIND will be\n   changed to IFIND.\n\nCopyleft (c) 2019\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIXNL": {"ttr": 13063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00(\\x01\\x161?\\x01\\x162\\x1f\\x10#\\x001\\x00>\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-08T00:00:00", "modifydate": "2016-11-16T10:23:28", "lines": 49, "newlines": 62, "modlines": 0, "user": "SYSLBD"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      FixNL                                           *\n *                                                            *\n * Function:  ISPF Edit Macro                                 *\n *                                                            *\n *            Correct files that have been downloaded from    *\n *            who knows and uploaded to z/OS with one very    *\n *            long record because the file only had newline   *\n *            characters without the carriage return to cause *\n *            a new record.                                   *\n *                                                            *\n *            The record is parsed and split at the newline   *\n *            x'25' character into unique records             *\n *                                                            *\n * Syntax:    FixNL                                           *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            05/10/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n Address ISREdit\n 'Macro'\n \"(maxl) = linenum .zlast\"\n \"reset\"\n r = 0\n nlc = x2c(25)\n/* ------------------------------------------------- *\n * Loop thru all records but there typically is only *\n * one record to deal with.                          *\n * ------------------------------------------------- */\n do i = 1 to maxl\n    '(data) = line' i\n    do until length(data) = 0\n       parse value data with record(nlc)data\n       r = r + 1\n       out.r = record\n       end\n    end\n do i = 1 to r\n    line = out.i\n    \"Line_Before .zlast = (line)\"\n    end\n/* ----------------------------------------------------- *\n * Delete the last record as that is the original record *\n * that is too long and does not belong here :-)         *\n * ----------------------------------------------------- */\n \"Delete .zlast\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTPB": {"ttr": 13065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1f\\x00&\\x01\\x161/\\x01\\x19#O\\x08\\x14\\x15\\xef\\x15W\\x00\\x00\\xc6\\xe3\\xd7\\xc2@@@@@@'", "ispf": {"version": "02.31", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2019-08-22T08:14:26", "lines": 5615, "newlines": 5463, "modlines": 0, "user": "FTPB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "FTPB$CHG": {"ttr": 15367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x1b\\x00P\\x01\\x01\\x04_\\x01\\x19#O\\x08\\x14\\x00\\xb6\\x00\\x0e\\x00\\x00\\xc6\\xe3\\xd7\\xc2@@@@@@'", "ispf": {"version": "02.27", "flags": 0, "createdate": "2001-02-14T00:00:00", "modifydate": "2019-08-22T08:14:50", "lines": 182, "newlines": 14, "modlines": 0, "user": "FTPB"}, "text": "This member (new with the 1.195 level) documents the changes from\nprior levels.\n\n08/22/2019\n1.232  - Correction from Peter Glanzmann to support NETRC as a PDS\n         member.\n\n08/20/2019\n1.231  - Correct use if no NETRC is specified\n\n07/01/2019\n1.230  - Add support for using a personal NETRC data set\n       - Used REXXFORM to reflow the REXX code\n       - Add DELDSD for the temporary NETRC when it is deleted\n\n03/06/2019\n1.229  - Remove extra blank from parm\n\n01/30/2019\n1.228  - Add Sort option for hosts\n\n02/01/2018\n1.227  - Correct bug with TLS handling and clean up the host panel\n\n05/16/2017\n1.226  - Add Port and TLS options\n\n07/29/2016\n1.225  - Add TLS (Secure FTP) capabilities\n\n05/04/2016\n1.224  - Updates from Bill Smith to clean up the generated JCL\n\n07/10/2009\n1.223  - Updates to support longer names and lower case for HFS\n         thanks to Rick Turnbull\n       - Panels\n         FTPBHF1 - help panel for source dsname\n         FTPB    - main panel with scrollable field\n       - Exec\n         FTPB    - update to handle lower case for hfs\n\n02/17/2009\n1.222  - Test for remote job cancel message\n         eric.hamtiaux@fortis.com\n\n02/10/2009\n1.221  - Update to correct big_load variable (for very large files)\n         eric.hamtiaux@fortis.com\n\n01/27/2009\n1.220  - Update to enable support for PDSE from\n         eric.hamtiaux@fortis.com\n\n07/28/2008\n1.219  - 1 fix if specifying host name\n\n07/07/2008\n1.218  - 1 fix from Eric Hamtiaux\n         if sending pds with 1 mem\n\n06/14/2007\n1.217  - 2 fixes from Bernd Krawczyk\n       - correct if multiple host sel\n       - correct long filename\n       - 1 fix from Larry Belikoff for new BLK allocated files\n\n05/02/2005\n1.216  - Correct Space Allocation for RECFM=VBS under ADRDSSU\n\n04/12/2004\n1.215  - Clean up allocation of NETRC DD\n\n04/09/2004\n1.214  - Add userid to netrc hlq if prefix is /= userid\n\n03/23/2004\n1.213  - Add seucrity for NETRC data set (change to ftpbcust)\n         ** RACF only at this point **\n         Thanks to Dennis Roach\n\n01/26/2004\n1.212  - Improve the FIND routine (minor tweak)\n\n07/30/2003\n1.211  - Correct two panels: FTPBHF3 and FTPBPH0\n       - Correct DSS space allocation for block space\n         thx to Don Ristagno\n\n06/30/2003\n1.210  - Correct space allocation for hfs unload via adrdssu\n\n06/27/2003\n1.209  - Make batch sysexec library dynamically determined.\n         updates to FTPB and FTPBCUST\n\n06/06/2003\n1.208  - Update FTPB exec to support dsntype in reload jcl\n       - Correct space to blksize if in blocks for reload\n       - Correct reload dsn on put to make it fully qualified\n\n05/08/2003\n1.207  - Update Panel FTPB password fields with the SKIP attribute\n         and correct field level help panel reference\n       - Add support for HFS data sets (prior 1.206 support was for\n         files within an HFS).\n       - Use DSINFO for HFS data set support. This requires a minimum\n         level of OS/390 Version 2.10 for HFS data set support.\n       - Correct problem with dsnames hlq in the //DELLOAD step for\n         batch DF/DSS\n\n04/21/2003\n1.206  - Reversion from 1.205 which was a beta level\n       - Add support for tape input and output\n       - For space units to Tracks for DF/DSS xfers\n       - Support for HFS files thanks to Eric Hamtiaux\n       - Add popup prompt for anonymous password\n       - Add option for Remote HLQ for target site for unloads\n       - support both / and \\ for windows and *nix non-MVS targets\n       - correct space allocation for new pds\n       - correct missing save for jc4 variable\n       - for tape input prompt for output info (dcb, space, unit, vol,..)\n       - support hfs files on input and output\n       - support steplib customization option\n       - add passlib to recursive call\n       - support 1 post ftp command\n       - update 2 panels for uss file information syntax\n       - redo RECEIVE exec to prompt for target dsn\n       - rename $changes to changes\n\n10/21/2002\n1.204  - Add data/mgmt/storclas options\n       - add PDSE member to the install pds with doc on how to use FTP\n         to create a PDSE\n\n09/16/2002\n1.203  - Change new pds back to yes or no\n\n09/03/2002\n1.202  - Fix cd that was accidently changed to cd\n       - change ftpb panel to support lowercase target file name\n\n08/29/2002\n1.201  - Change 'new' pds to Create or Replace\n       - Add new delete option to generate delete on create\n\n08/18/2002\n1.200  - Add support for 4 job statements\n       - changed name of FTPBREC to RECEIVE\n\n05/09/2002\n1.199  - fully support output iebcopy dcb on batch reload\n\n02/18/2002\n1.198  - minor fix for find routine\n\n09/04/2001\n1.197 - test for os/390 v2r10\n        which supports ftp of load\n      - fix reload dsn hlq issue\n\n06/22/2001\n1.196 - numerous fixes for noprefix usage\n      - fix residual netrc file if no submit\n\n06/07/2001 (never shipped)\n1.195 - fixes for noprefix usage\n\n02/21/2001\n1.194  - add nodsnopt if no dsns selected\n\n02/14/2001\n1.193  - fix noprefix jcl build\n       - elimate prompt if non-mvs\n       - fix netrc usage to WORK\n       - add no member select option\n         nomemopt variable\nUpdates to Execs: FTPB and FTPBCUST\n\n02/07/2001 (Never Released)\n1.192  - fixed member patter *xx*\nUpdates to Execs: FTPB\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FTPB#": {"ttr": 15371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\t\\x19?\\x01\\x19\\x18?\\x11#\\x102\\t\\xe9\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2009-07-12T00:00:00", "modifydate": "2019-07-02T11:23:00", "lines": 4146, "newlines": 2537, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "FTPB@": {"ttr": 17158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x18\\x00\\x00\\x01\\t\\x19?\\x01\\x19\\x18?\\x11#\\x02\\xb4\\x02\\xe7\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "02.24", "flags": 0, "createdate": "2009-07-12T00:00:00", "modifydate": "2019-07-02T11:23:00", "lines": 692, "newlines": 743, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "FTPFROMZ": {"ttr": 17415, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x14O\\x01\\x04\\x14O\\x08\\x07\\x04k\\x04k\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-05-23T00:00:00", "modifydate": "2004-05-23T08:07:00", "lines": 1131, "newlines": 1131, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "FTPFROZC": {"ttr": 17926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x00\\x00?\\x01\\x04\\x14O\\x08\\x06\\x00\\x16\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-03T00:00:00", "modifydate": "2004-05-23T08:06:52", "lines": 22, "newlines": 33, "modlines": 0, "user": "SYSLBD"}, "text": "                        FTPFromZ Version Change History\n\n    05/21/04 - 1.0 Numerous changes\n             - Support input GDG data sets\n             - Add to report sample FTP JCL statements\n             - Clarify NETRCDD parameter usage\n    05/13/04 - 0.9 Add checks for minimum required keywords\n    04/30/04 - 0.8 Correction for multiple members\n    03/12/04 - 0.7 Correction for blank password\n                   thx to Philippe Septier\n    03/11/04 - 0.6 Correction for Type\n             - Add completion message\n    03/11/04 - 0.5 Add NOPASSWORD option\n             - Add UNIQUE option\n             - Add MEMSUF option\n    03/10/04 - 0.4 Force TYPE to uppercase\n    03/09/04 - 0.3 Add SENDSITE for non-z/OS targets\n    03/08/04 - 0.2 Changes/Enhancements\n             - Add POSTFTP, PREFTP and DEBUG\n             - Change keyword parse processing\n    03/05/04 - 0.1 Creation\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GENSUB": {"ttr": 17928, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x05\\x0f\\x01\\x02\\x05\\x0f\\x109\\x00\\xbc\\x00\\xbc\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-02-19T00:00:00", "modifydate": "2002-02-19T10:39:00", "lines": 188, "newlines": 188, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "GET": {"ttr": 17932, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x00\\x04\\x7f\\x01\\x00\\x04\\x7f\\x16I\\x00X\\x00X\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-16T00:00:00", "modifydate": "2000-02-16T16:49:14", "lines": 88, "newlines": 88, "modlines": 0, "user": "SYSLBD"}, "text": "        /* ---------------------  rexx procedure  -------------------*\n         * Name:      GET                                            *\n         *                                                           *\n         * Function:  ISPF EDIT Macro to copy the specified          *\n         *            data set into the data set currently           *\n         *            being processed by ISPF Edit.                  *\n         *                                                           *\n         * Syntax:    GET dsname                                     *\n         *                                                           *\n         * Author:    Lionel B. Dyck                                 *\n         *            Kaiser Permanente Information Technology       *\n         *            25 N. Via Monte Ave.                           *\n         *            Walnut Creek, CA 94598                         *\n         *            (925) 926-5332                                 *\n         *            Internet: lionel.b.dyck@kp.org                 *\n         *                                                           *\n         * History:                                                  *\n         *            02/11/00 - fix after copy position             *\n         *            02/04/00 - fix width problem                   *\n         *            01/13/92 - created by Lionel Dyck              *\n         *                                                           *\n         * -------------------------------------------------------- */\n\n        Address ISREDIT \"MACRO (DSN) NOPROCESS\"\n\n        Address ISREDIT \"PROCESS DEST\"\n        dest_rc = rc\n\n        /* Insure that a parameter was specified */\n        if words(dsn) = 0 then do\n           zedsmsg = \"Error:\"\n           zedlmsg = \"Correct syntax is: GET dsn\"\n           Address ISPEXEC \"Setmsg Msg(ISRZ000)\"\n           exit 16\n           end\n\n        /* Test to insure the data set exists */\n        x = sysdsn(dsn)\n        if x <> \"OK\" then do\n           zedsmsg = \"\"\n           zedlmsg = \"Error Specified data set:\" dsn x\n           Address ISPEXEC \"Setmsg Msg(ISRZ000)\"\n           exit 16\n           end\n\n        /* Verify that a destination was specified */\n        if dest_rc = 8 then do\n           zedsmsg = \"\"\n           zedlmsg = \"A destination line must be specified\"\n           Address ISPEXEC \"Setmsg Msg(ISRZ000)\"\n           exit 16\n           end\n\n        /* Now read the specified data set */\n        dd_name = \"GET\"random()\n        \"Alloc f(\"dd_name\") shr reuse ds(\"dsn\")\"\n        \"Execio * diskr\" dd_name \"(Finis Stem get.\"\n        \"Free f(\"dd_name\")\"\n\n        /* Now default to Address ISREDIT */\n        Address ISREDIT\n\n        /* get the current width of the data */\n        \"(WIDTH) = DATA_WIDTH\"\n\n        /* Test to see if we have an empty edit data set\n           and if so then set destination as after line 0\n           otherwise get the target line */\n        if dest_rc = 20 then dest = 0\n           else \"(DEST) = LINENUM .ZDEST\"\n        save_dest = dest\n\n        /* Now insert the data */\n        do i = 1 to get.0\n           newline = get.i\n           \"LINE_AFTER\" dest \"= DATALINE (NEWLINE)\"\n           dest = dest + 1\n           if width < length(get.i) then to_long = \"On\"\n           end\n\n        \"UP MAX\"\n        \"Down\" save_dest\n        if to_long = \"On\" then do\n           zedsmsg = \"Truncated?\"\n           zedlmsg = \"Possible truncation of inserted data\"\n           Address ISPEXEC \"SETMSG MSG(ISRZ000)\"\n           end\n        exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HIDELINE": {"ttr": 17935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\t_\\x01\\x16\\t_\\x11U\\x00.\\x00.\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-04-04T00:00:00", "modifydate": "2016-04-04T11:55:37", "lines": 46, "newlines": 46, "modlines": 0, "user": "SYSLBD"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      HideLine                                        *\n *                                                            *\n * Function:  To comment out a rexx line of code so that      *\n *            it will not be processed.                       *\n *                                                            *\n * Usage:     Enter hideline on the ISPF Edit command line    *\n *            and then place the cursor on the line to be     *\n *            \"hidden\" or commented out.                      *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            04/04/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n /* -------------------------------- *\n  * Setup the addressing environment *\n  * -------------------------------- */\n Address ISREdit\n\n /* -------------------------------- *\n  * Tell ISREdit that we are a Macro *\n  * -------------------------------- */\n \"Macro\"\n\n /* ---------------------------- *\n  * Get the row the cursor is on *\n  * ---------------------------- */\n \"(currrow) = CURSOR\"\n\n /* --------------------------------------------- *\n  * Get the data from that record into a variable *\n  * --------------------------------------------- */\n \"(data) = line\" currrow\n\n /* -------------------------------------------------------- *\n  * Strip off trailing blanks and then place comment starter *\n  * and ending characters in the record                      *\n  * -------------------------------------------------------- */\n  newdata = \"/* \" strip(data,T) \" */\"\n\n /* ------------------------- *\n  * Now over-write the record *\n  * ------------------------- */\n \"LINE\" currrow  \" = (newdata)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IDLIST": {"ttr": 18177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x161?\\x01\\x161?\\x105\\x00>\\x00>\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-08T00:00:00", "modifydate": "2016-11-08T10:35:30", "lines": 62, "newlines": 62, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "IEBPDSE": {"ttr": 18179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00G\\x01\\x161/\\x01\\x170_\\x06\\x07\\x02O\\x01\\x12\\x00\\x00\\xd3\\xc2\\xc4@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2017-11-01T06:07:47", "lines": 591, "newlines": 274, "modlines": 0, "user": "LBD"}, "text": "/* --------------------  rexx procedure  -------------------- */\n ver = '1.3'\n/* Name:      IEBPDSE                                         *\n *                                                            *\n * Function:  Invoke the IBM IEBPDSE utility to try to        *\n *            repair a PDSE (or at least report on it)        *\n *                                                            *\n * Syntax:    %iebpdse pdse-dsname iebpdse-parms              *\n *                                                            *\n *            pdse-dsname is the pdse data set name           *\n *            iebpdse-parms are processing parms:             *\n *                                                            *\n *            ANAL      - PDSE analysis                       *\n *            A           Default enabled                     *\n *            BYPASS    - Bypass the IEBPDSE prompt panel     *\n *            B           Default disabled                    *\n *            DUMP      - System Dump if PDSE is corrupt      *\n *            D           Default disabled                    *\n *            FLUSH     - Flush PDSE pages before analysis    *\n *            F           Default enabled                     *\n *            NOANAL    - Do NOT do an analysis               *\n *            NOA         Default disabled                    *\n *            NODUMP    - Do NOT take a System Dump           *\n *            NOD         Default enabled                     *\n *            NOFLUSH   - Do NOT flush any PDSE pages         *\n *            NOF         Default enabled                     *\n *            PERF      - Do a Pending Delete process         *\n *            P           Default enabled                     *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *       1.3  11/01/17 - Add version level                    *\n *       1.2  10/27/17 - Add return code checking and msgs    *\n *                     - Set Flush and Perf as default action *\n *       1.1  10/26/17 - Add runtime parms for IEBPDSE        *\n *       1.0  09/02/16 - Don't force performpendingdeletes    *\n *       0.4  08/31/16 - Enable Point/Shoot                   *\n *       0.3  08/23/16 - Add Alloc for SYSIN DD Dummy         *\n *       0.2  08/19/16 - ISPF Interface added                 *\n *       0.1  03/10/16 - creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n arg pdse pdseopt\n\n/* --------------- *\n * Define defaults *\n * --------------- */\n parse value '' with null zdump zflush zanal zperf zcmd parm bypass\n\n/* ---------------------- *\n | Define Default Actions |\n * ---------------------- */\n zflush = 'F'\n zperf  = 'P'\n zdump  = 'N'\n\n/* ------------------------------------------- *\n | Check for any passed parameters for IEBPDSE |\n * ------------------------------------------- */\n  do i = 1 to words(pdseopt)\n    zopt = word(pdseopt,i)\n    Select\n      When Abbrev('BYPASS',zopt,1)  = 1 then bypass = 'Y'\n      When Abbrev('DUMP',zopt,1)    = 1 then zdump  = 'D'\n      When Abbrev('NODUMP',zopt,3)  = 1 then zdump  = 'N'\n      When Abbrev('FLUSH',zopt,1)   = 1 then zflush = 'F'\n      When Abbrev('NOFLUSH',zopt,3) = 1 then zflush = 'N'\n      When Abbrev('ANAL',zopt,1)    = 1 then zanal  = null\n      When Abbrev('NOANAL',zopt,3)  = 1 then zanal  = 'N'\n      When Abbrev('PERF',zopt,1)    = 1 then do\n        if zperf = 'P' then zperf = null\n        else zperf = 'P'\n      end\n      Otherwise nop\n    end\n  end\n\n/* ------------ *\n * Address ISPF *\n * ------------ */\n Address ISPExec\n\n/* ------------------------------- *\n * Load the ISPF Panel dynamically *\n * ------------------------------- */\n load_info = loadispf()\n\n/* ------------------------------------- *\n * Display the prompting panel until PF3 *\n * ------------------------------------- */\n if bypass = 'Y'\n    then do\n         call doit\n         exit\n         end\n do forever\n    zcmd = null\n    'display panel(iebpdse)'\n    if rc > 0 then do\n       Address ISPEXEC\n       do until length(load_info) = 0\n          parse value load_info with dd libd load_info\n          if left(libd,6) = \"ALTLIB\" then do\n             if libd = \"ALTLIBC\" then lib = \"CLIST\"\n                                 else lib = \"EXEC\"\n             Address TSO,\n               \"Altlib Deact Application(\"lib\")\"\n             end\n          else \"libdef\" libd\n          address tso \"free f(\"dd\")\"\n          end\n        exit\n        end\n    if word(zcmd,1) = 'SET' then do\n       zopt = word(zcmd,2)\n       Select\n         When zopt = 'DUMP'     then zdump  = 'D'\n         When zopt = 'NODUMP'   then zdump  = 'N'\n         When zopt = 'FLUSH'    then zflush = 'F'\n         When zopt = 'NOFLUSH'  then zflush = 'N'\n         When zopt = 'ANAL'     then zanal = 'N'\n         When zopt = 'PERF'     then do\n              if zperf = 'P' then zperf = null\n                             else zperf = 'P'\n              end\n         end\n       zcmd = null\n       iterate\n       end\n    if pdse /= null then call doit\n    end\n\n/* ----------------------------- *\n * Do the actual call to IEBPDSE *\n * ----------------------------- */\n DoIt:\n\n if sysdsn(pdse) /= 'OK' then do\n    zedsmsg = 'Error'\n    zedlmsg = pdse sysdsn(pdse)\n    'Setmsg msg(isrz001)'\n    return\n    end\n\n/* -------------- *\n * Setup the parm *\n * -------------- */\n if zdump = 'D' then parm = 'DUMP'\n                else parm = 'NODUMP'\n if zflush = 'F' then\n    if parm /= null then parm = parm',FLUSH'\n                    else parm = 'FLUSH'\n if zanal = 'N' then\n    if parm /= null then parm = parm',NOANALYSIS'\n                    else parm = 'NOANALYSIS'\n if zperf = 'P' then\n    if parm /= null then parm = parm',PERFORMPENDINGDELETE '\n                    else parm = 'PERFORMPENDINGDELETE '\n\n/* ------------------------------ *\n * Define the temp report dataset *\n * ------------------------------ */\n if sysvar('syspref') = null\n    then rdsn = \"'\"sysvar('sysuid')'.iebpdse.r'random(99999)\"'\"\n    else rdsn = \"'\"sysvar('syspref')'.iebpdse.r'random(99999)\"'\"\n\n/* -------------------- *\n * Call IEBPDSE finally *\n * -------------------- */\n  Address TSO\n  \"alloc f(sysprint) reuse spa(1,1) tr ds(\"rdsn\")\"\n  \"alloc f(syslib) ds(\"pdse\") shr\"\n  \"alloc f(sysin) dummy reuse\"\n  \"call *(iebpdse) '\"parm\"'\"\n  iebpdse_rc = rc\n  \"free f(syslib sysprint)\"\n  \"alloc f(sysprint) ds(*) reuse\"\n  \"alloc f(sysin) ds(*) reuse\"\n\n/* ------------------------------------------------------------------- *\n | Interpret the Return Code                                           |\n |                                                                     |\n | 00 (X'00') Successful completion.                                   |\n | 04 (X'04') The input PDSE is slightly damaged. Processing continues |\n | 08 (X'08') The input PDSE is corrupted. The utility ends.           |\n | 12 (X'0C') The input PDSE could not be opened. The utility ends.    |\n | 16 (X'10') The input data set is not a PDSE. The utility ends.      |\n * ------------------------------------------------------------------- */\n Select\n   When iebpdse_rc = 0 then do\n        zedsmsg = 'Success'\n        zedlmsg = 'Successful completion.'\n        end\n   When iebpdse_rc = 4 then do\n        zedsmsg = 'Warning'\n        zedlmsg = 'The input PDSE is slightly damaged. Processing continues.'\n        end\n   When iebpdse_rc = 8 then do\n        zedsmsg = 'Error'\n        zedlmsg = 'The input PDSE is corrupted. The utility ends.'\n        end\n   When iebpdse_rc = 12 then do\n        zedsmsg = 'Error'\n        zedlmsg = 'The input PDSE could not be opened. The utility ends.'\n        end\n   When iebpdse_rc = 16 then do\n        zedsmsg = 'Error'\n        zedlmsg = 'The input data set is not a PDSE. The utility ends.'\n        end\n   Otherwise do\n        zedsmsg = 'Unknown'\n        zedlmsg = 'Return code' iebpdse_rc 'is an unknown return code.'\n        end\n   end\n   Address ISPExec 'Setmsg msg(isrz001)'\n\n/* ----------------- *\n * Browse the report *\n * ----------------- */\n Address ISPExec ,\n   \"Browse dataset(\"rdsn\")\"\n\n/* --------------------------------------------- *\n * Delete the report file and return for another *\n * --------------------------------------------- */\n call outtrap 'x.'\n 'Delete' rdsn\n call outtrap 'off'\n return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n Select\n    When type = \"Clist\" then\n         \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n         \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n         \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n         \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n         \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n    end\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n return\n\n>Start\n>Panel iebpdse\n)Attr Default(%+_)\n   # type(input ) intens(high) caps(on) just(left) hilite(uscore) skip(off)\n   $ type(output) intens(high) caps(on) just(asis) pas(on) hilite(uscore)\n   | type(text) intens(high) color(blue) hilite(reverse)\n   @ type(output) intens(high) color(blue) hilite(reverse)\n)Body  Expand(\\\\)\n%-\\-\\-|IEBPDSE PDSE Validation Utility@ver%-\\-\\-\n%Command ===>_zcmd\n%\n%PDSE Data Set Name:#pdse                                         +\n\n%IEBPDSE Options:\n\n #z+ $Dump+or$NoDump+        D or N\n      Dump   - the SMSPDSE(1) Address Space if the PDSE is Broken\n      NoDump - do not dump the address space (default)\n\n #z+ $Flush+or$NoFlush+      F or N\n      Flush   - Previously read pages should not be used for validation\n      NoFlush - Use previously read pages for validation\n\n #z+ $anal      +            N or blank\n      Used with PERFORMPENDINGDELETE to bypass PDSE validation\n\n #z+ $perf                +  P or blank\n      Causes all Pending Deletes to be processed.\n\n)Init\n .cursor = pdse\n .zvars = '(zdump zflush zanal zperf)'\n &dump    = 'Dump'\n &nodump  = 'NoDump'\n &flush   = 'Flush'\n &noflush = 'NoFlush'\n &anal    = 'NoAnalysis'\n &perf    = 'PerformPendingDelete'\n if (&zdump = &z)\n     &zdump   = 'N'\n if (&zflush = &z)\n     &zflush  = 'N'\n if (&zanal NE &z)\n     &zanal  = 'N'\n)Proc\n ver (&pdse,dsnameq)\n ver (&zdump,nb,list,D,N)\n ver (&zflush,nb,list,F,N)\n ver (&zanal,list,N)\n ver (&zperf,list,P)\n)Pnts\nFIELD(dump    ) VAR(ZCMD) VAL('SET DUMP')\nFIELD(nodump  ) VAR(ZCMD) VAL('SET NODUMP')\nFIELD(flush   ) VAR(ZCMD) VAL('SET FLUSH')\nFIELD(noflush ) VAR(ZCMD) VAL('SET NOFLUSH')\nFIELD(anal    ) VAR(ZCMD) VAL('SET ANAL')\nFIELD(perf    ) VAR(ZCMD) VAL('SET PERF')\n)End\n>End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IFTHENEL": {"ttr": 18435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x17\\x11O\\x01\\x17\\x11O\\t\\x07\\x00=\\x00=\\x00\\x00\\xd3\\xc2\\xc4\\xe8\\xc3\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-04-24T00:00:00", "modifydate": "2017-04-24T09:07:17", "lines": 61, "newlines": 61, "modlines": 0, "user": "LBDYCK"}, "text": "  /* --------------------  rexx procedure  -------------------- *\n   | Name:      IfThenEl                                        |\n   |                                                            |\n   | Function:  ISPF Edit Macro to Display only REXX statements |\n   |            with If, Then, Else, Do, Select, When, End      |\n   |            and Otherwise.                                  |\n   |                                                            |\n   | Usage Notes: Enter on ISPF Edit or View command line       |\n   |                                                            |\n   | Dependencies: none                                         |\n   |                                                            |\n   | Author:    Lionel B. Dyck                                  |\n   |                                                            |\n   | History:  (most recent on top)                             |\n   |            04/20/17 - Creation                             |\n   |                       inspired by Bill Smith and           |\n   |                       John Kalinich                        |\n   * ---------------------------------------------------------- */\n   Address ISREdit\n   'Macro (options)'\n\n   /* ---------------------------------------- *\n    | First Reset and then Exclude ALL records |\n    * ---------------------------------------- */\n   'reset'\n   'exclude all'\n\n   /* ---------------------------------------------------- *\n    | Now Find all the keywords that we are interested in. |\n    * ---------------------------------------------------- */\n   \"find 'if' word all \"\n   \"find 'then' word all \"\n   \"find 'else' word all \"\n   \"find 'do' word all \"\n   \"find 'end' word all \"\n   \"find 'select' word all \"\n   \"find 'when' word all \"\n   \"find 'otherwise' word all \"\n\n/* ---------------------------------------------------- *\n | Find all the start of comments and then find the     |\n | end of comment and exclude those records.            |\n |                                                      |\n | This hides any of the keywords that are in comments. |\n * ---------------------------------------------------- */\n   opt = 'first'\n   do forever\n      \"find '/*'\" opt\n      if rc > 0 then leave\n      opt = 'next'\n      '(hit) = cursor'\n      \"find '*/'\"\n      '(hitend) = cursor'\n      'label' hit '= .a'\n      if hit /= hitend then\n      'label' hitend '= .b'\n      if hit = hitend\n      then 'exclude .a .a all'\n      else 'exclude .a .b all'\n   end\n   'up m'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INEWS": {"ttr": 18437, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x001\\x01\\x161/\\x01\\x17\\x04o\\x13T\\n\\x83\\t\\xb6\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2017-02-15T13:54:31", "lines": 2691, "newlines": 2486, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "IPLTCHK": {"ttr": 19463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x18%\\x8f\\x01\\x18%\\x8f\\x100\\x00m\\x00m\\x00\\x00\\xc9\\xd7\\xd3\\xe3\\xc3\\xc8\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-09-15T00:00:00", "modifydate": "2018-09-15T10:30:49", "lines": 109, "newlines": 109, "modlines": 0, "user": "IPLTCHK"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      IPLTCHK                                         |\n |                                                            |\n | Function:  Generate ADRDSSU Step and control cards         |\n |            to print the first track of the selected        |\n |            disk volumes.                                   |\n |                                                            |\n |            The main purpose is to find the disk volumes    |\n |            that have IPL Text installed on them and        |\n |            help to identify which type of IPL Text using   |\n |            the trusted, real-time, reliable, always        |\n |            available, and free utility IEB-EYE-BALL to     |\n |            review.                                         |\n |                                                            |\n | Syntax:    %ipltchk filter(s)                              |\n |                                                            |\n |            filters are any strings that must be found      |\n |            within the volser to be used.                   |\n |                                                            |\n | Usage:  Execute with, or without a filter, to generate the |\n |         ADRDSSU JCL and control statements to print track  |\n |         0 for the requested volumes. At the end of use     |\n |         the user is placed into ISPF Edit on the results   |\n |         and may then insert a JOB card, tailor however     |\n |         they wish, and submit it. Then review the OUTPUT   |\n |         DD Sysout for the information.                     |\n |                                                            |\n | Dependencies:  DUDASD is required from CBT Tape File 612   |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | Acknowledgements:  Thanks to Robert Richards for the tip   |\n |                    to use ADRDSSU PRINT.                   |\n |                                                            |\n | History:  (most recent on top)                             |\n |            09/15/18 - Rename to IPLTCHK from IPLCHK        |\n |                     - Make Edit data a temp file           |\n |                     - Add more JCL statements              |\n |            09/14/18 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n  arg filter\n\n/* ---------------------------- *\n | capture volumes using dudasd |\n * ---------------------------- */\n  call outtrap 'v.'\n  'dudasd'\n  call outtrap 'off'\n\n/* --------------------------------------- *\n | Process dudasd to build list of volumes |\n * --------------------------------------- */\n  str = ''\n  do i = 1 to v.0\n    do x = 1 to 4\n      parse value v.i with x1 vol x2 v.i\n      vol = left(vol,6)\n      if strip(filter) = '' then\n      str = str vol\n      else do f = 1 to words(filter)\n        if pos(word(filter,f),vol) > 0 then str = str vol\n      end\n    end\n  end\n\n/* ---------------------------------------- *\n | Now generate the JCL - less the JOB Card |\n * ---------------------------------------- */\n  c = 0\n  call add '//IPLTCHK JOB ... '\n  call add '//OUT   OUTPUT DEFAULT=YES,JESDS=ALL,OUTDISP=(HOLD,HOLD)'\n  call add '//* ----------------------------------------------- '\n  call add '//* Report on the IPL Text on the requested volumes'\n  call add '//* ----------------------------------------------- '\n  call add '//DUMP01   EXEC PGM=ADRDSSU,REGION=4096K'\n  call add '//SYSPRINT DD   SYSOUT=*'\n  call add '//OUTPUT   DD   SYSOUT=*'\n  call add '//SYSIN     DD *'\n  do i = 1 to words(str)\n    vol = word(str,i)\n    call add '  PRINT TRACKS(0,0,0,0) - '\n    call add '     INDYNAM('vol') - '\n    call add '     ADMIN - '\n    call add '     OUTDDNAME(OUTPUT)'\n  end\n  call add '/*'\n  o.0 = c\n  'alloc f(out) spa(5,5) tr recfm(f b) lrecl(80) unit(vio)'\n  'execio * diskw out (finis stem o.'\n\n/* -------------------------- *\n | Done so edit the results |\n * -------------------------- */\n  Address ISPExec\n  \"LMINIT DATAID(ipltchk) DDName(out)\"\n  'edit dataid('ipltchk')'\n  \"LMFree Dataid(\"ipltchk\")\"\n  address TSO 'free  f(out)'\n  exit\n\n/* -------------------------------------------- *\n | Routine to add the record to the output stem |\n * -------------------------------------------- */\nadd:\n  arg opt\n  c = c + 1\n  o.c = opt\n  return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPLTCHK$": {"ttr": 19466, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Y\\x01\\x18%\\x7f\\x01\\x18%\\x8f\\x11Y\\x00(\\x00*\\x00\\x00\\xc9\\xd7\\xd3\\xe3\\xc3\\xc8\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-09-14T00:00:00", "modifydate": "2018-09-15T11:59:59", "lines": 40, "newlines": 42, "modlines": 0, "user": "IPLTCHK"}, "text": "//*  Member IPLTCHK (added 09/14/2018)                              *   FILE 312\n//*                                                                 *   FILE 312\n//*        -------------------------------------------------------  *   FILE 312\n//*        This REXX helps solve the problem of which DASD volumes  *   FILE 312\n//*        connected to your system, contain IPL text, and what     *   FILE 312\n//*        IPL text do they contain?                                *   FILE 312\n//*        -------------------------------------------------------  *   FILE 312\n//*        You don't have to dump Track 0 for ALL of your volumes,  *   FILE 312\n//*        but you can FILTER the volser's for strings with volume  *   FILE 312\n//*        names that you want to look at.  See syntax below.       *   FILE 312\n//*        -------------------------------------------------------  *   FILE 312\n//*                                                                 *   FILE 312\n//*                                                                 *   FILE 312\n//*        Function:  Generate ADRDSSU Step and control cards to    *   FILE 312\n//*                   print the first track of the selected disk    *   FILE 312\n//*                   volumes.                                      *   FILE 312\n//*                                                                 *   FILE 312\n//*                   The main purpose is to find the disk          *   FILE 312\n//*                   volumes that have IPL Text installed on       *   FILE 312\n//*                   them and help to identify which type of IPL   *   FILE 312\n//*                   Text using the trusted, real-time,            *   FILE 312\n//*                   reliable, always available, and free          *   FILE 312\n//*                   utility IEB-EYE-BALL to review.               *   FILE 312\n//*                                                                 *   FILE 312\n//*        Syntax:    %ipltchk filter(s)                            *   FILE 312\n//*                                                                 *   FILE 312\n//*                   filters are any strings that must be found    *   FILE 312\n//*                   within the volser to be used.                 *   FILE 312\n//*                                                                 *   FILE 312\n//*        Usage:  Execute with, or without a filter, to generate   *   FILE 312\n//*                the ADRDSSU JCL and control statements to        *   FILE 312\n//*                print track 0 for the requested volumes. At      *   FILE 312\n//*                the end of use the user is placed into ISPF      *   FILE 312\n//*                Edit on the results and may then insert a JOB    *   FILE 312\n//*                card, tailor however they wish, and submit it.   *   FILE 312\n//*                Then review the OUTPUT DD Sysout for the         *   FILE 312\n//*                information.                                     *   FILE 312\n//*                                                                 *   FILE 312\n//*        Dependencies:  DUDASD is required from CBT Tape File 612 *   FILE 312\n//*                                                                 *   FILE 312\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPFCMDS": {"ttr": 19468, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x03\\x14?\\x01\\x03\\x14?\\x11\\x13\\x01\\x84\\x01\\x84\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-05-23T00:00:00", "modifydate": "2003-05-23T11:13:00", "lines": 388, "newlines": 388, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "ISPFPRO$": {"ttr": 19718, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x05\\x9f\\x01\\x00\\x05\\x9f F\\x00e\\x00e\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-28T00:00:00", "modifydate": "2000-02-28T20:46:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "SYSLBD"}, "text": "            ISPF Product Installation - the Easy Way\n\nTo simplify the installation of products or applications that use\nISPF a new facility is being made available.  This facility is a\nREXX application that utilizes standard interface commands to setup\nthe ISPF environment for your product or application.  What makes\nthis simple is that the various elements of the application do not\nhave to be installed into any pre-existing libraries.  The only\npre-existing library that is updated is the production SYSPROC or\nSYSEXEC where the stub routine is installed.\n\nA caution when using this interface is that you must verify that\nyour product or application will work properly with it as there are\ninstances where this facility does not work and the products or\napplications components must be installed into pre-allocated\nlibraries.\n\nThe stub that is referred to is a small REXX exec or CLIST that\ninvokes this facility which is basically a front-end to the product\nor application.\n\nHere are two examples of the stub used to invoke Fileaid.  Note that\nthe STEP parameter is not used since the Fileaid load library is\ninstalled in the LINKLIST. Example 1 is using all the parameters to\ndefine specific libraries.\n\nExample 1:\n\n/* REXX */\narg options\n\n\"%ispfprod applid(FAXE)\",\n   \"scrname(Fileaid)\",\n   \"table('sysl.fileaid.isptlib')\",\n   \"clist('SYSL.FILEAID.CLIST.VB')\" ,\n   \"panels('SYSL.FILEAID.ISPPLIB')\" ,\n   \"msgs('SYSL.FILEAID.ISPMLIB')\" ,\n   \"skels('SYSL.FILEAID.ISPSLIB')\" ,\n   \"panel(IFAMU01) opt(\"options\")\"\n\nIn Example 2 the use of the PREFIX parameter is demonstrated which\navoids having to code most of the other parms.  Note that the PREFIX\nis coded without quotes as it is the high level qualifier(s) to\nwhich appropriate suffixes will be added and if valid used.\n\nExample 2:\n\n/* REXX */\narg options\n\n\"%ispfprod applid(FAXE)\",\n   \"clist('SYSL.FILEAID.CLIST.VB')\" ,\n   \"prefix(sysl.fileaid)\" ,\n   \"panel(IFAMU01) opt(\"options\")\"\n\nThe PREFIX parameter is a powerful shortcut to creating the stub to\ninvoke your ISPF application.  When used it will automatically find\nand use all the following libraries:\n\n       Suffix    DDNAME\n\n       CLIST     SYSPROC\n       EXEC      SYSEXEC\n       ISPCLIB   SYSPROC\n       ISPPLIB   ISPPLIB\n       ISPSLIB   ISPSLIB\n       ISPTLIB   ISPTLIB\n       LLIB      ISPLLIB\n       LOAD      ISPLLIB\n       PANELS    ISPPLIB\n       SKELS     ISPSLIB\n       STEPLIB   STEPLIB\n       TABLES    ISPTLIB\n\n\nThe syntax for the ISPFPROD facility is:\n\n%ISPFPROD\n    APPLID(ISPF Application ID)\n    SCRNAME(ISPF Screen Name)\n    CLIST(CLIST Library or Libraries)\n    EXEC(REXX Library or Libraries)\n    LLIB(ISPF Load Library or Libraries)\n    STEP(Steplib Library or Libraries)\n    MSGS(ISPF Messages Library or Libraries)\n    PANELS(ISPF Panels Library or Libraries)\n    SKELS(ISPF Skeleton Library or Libraries)\n    TABLE(ISPF Table Library or Libraries)\n    PREFIX(high-level-qualifier for libraries)\n    CMD(command options)\n    or\n    PGM(program) PARM(parm)\n    or\n    PANEL(panel-name) OPT(option)\n\nIf you are using the standard system SYSPROC or SYSEXEC\nconcatenation of libraries then you will find this facility\navailable in all Kaiser OS/390 environments (National Production,\nNational Development, Hawaii, Northern California Production and\nNorthern California Development, as well as NSYS and RSYS/S10D).\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPFPROD": {"ttr": 19721, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00#O\\x01\\x00#O\\x17@\\x01\\xad\\x01\\xad\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-08-21T00:00:00", "modifydate": "2000-08-21T17:40:00", "lines": 429, "newlines": 429, "modlines": 0, "user": "SYSLBD"}, "text": "        /* ---------------------  rexx procedure  ---------------------- *\n         * Name:      ISPFPROD                                           *\n         *                                                               *\n         * Function:  To provide a generalized stub to drive ISPF        *\n         *            applications without requiring the writing of      *\n         *            specific individual clists or execs and without    *\n         *            requiring that the application be installed into   *\n         *            existing allocated libraries.                      *\n         *                                                               *\n         *---------------------------------------------------------------*\n         *            NOTE:                                              *\n         *            Use of Tone's Dynastep or Gilbert Saint-flour's    *\n         *            dynamic STEPLIB command are supported.             *\n         *                                                               *\n         *            Find *custom* to change the default from           *\n         *            Dynastep to Steplib or to none if neither are      *\n         *            installed.                                         *\n         *---------------------------------------------------------------*\n         *                                                               *\n         * Syntax:    %ispfprod options                                  *\n         *            Where the options are:                             *\n         *                                                               *\n         *            APPLID(ISPF Application ID)                        *\n         *            SCRNAME(Screen-name)                               *\n         *            CLIST(CLIST Library or Libraries)      (note 1)    *\n         *            EXEC(Rexx Library or Libraries)        (note 1)    *\n         *            LLIB(ISPF Load Library or Libraries)   (note 1)    *\n         *            STEP(Steplib Library or Libraries)     (note 1)    *\n         *            MSGS(ISPF Messages Library or Libraries)  (note 1) *\n         *            NOCHECK                                   (note 3) *\n         *            PANELS(ISPF Panels Library or Libraries)  (note 1) *\n         *            SKELS(ISPF Skeleton Library or Libraries) (note 1) *\n         *            TABLE(ISPF Table Library or Libraries)    (note 1) *\n         *            PREFIX(library prefix)                    (note 2) *\n         *            CMD(command options)                               *\n         *            or                                                 *\n         *            PGM(program) PARM(parm)                            *\n         *            or                                                 *\n         *            PANEL(panel-name) OPT(option)                      *\n         *                                                               *\n         * Note 1:    Use of PREFIX(hlq.xxxx) will look for and use      *\n         *            datasets which match the prefix plus CLIST,        *\n         *            EXEC, MSGS, PANELS, SKELS, TABLES in lieu of       *\n         *            coding the specific parameter.  LOAD or LLIB       *\n         *            dsname suffixes will be used for the LLIB parm     *\n         *            and STEPLIB will be used for the STEP parm.        *\n         *                                                               *\n         *            Alternately ISPCLIB, ISPLLIB, ISPMLIB, ISPPLIB,    *\n         *                        ISPSLIB, and ISPTLIB will be used      *\n         *                        appropriately for those who like       *\n         *                        these suffixes.                        *\n         *                                                               *\n         * Note 2:    Use of a specific parm will over-ride the PREFIX   *\n         *                                                               *\n         * Note 3:    May be used with CMD or PGM                        *\n         *                                                               *\n         * Author:    Lionel B. Dyck                                     *\n         *            Kaiser Permanente                                  *\n         *            Walnut Creek, CA 94598                             *\n         *            (925) 926-5332                                     *\n         *            Internet: lionel.b.dyck@kp.org                     *\n         *                                                               *\n         * History:                                                      *\n         *            v1.5 - 08/07/00 - add nocheck option               *\n         *            v1.4 - 02/28/00 - add scrname option               *\n         *            v1.3 - 08/19/99 - add prefix option                *\n         *            v1.2 - 08/09/99 - cleanup steplib                  *\n         *            v1.1 - 08/06/99 - more doc and support no steplib  *\n         *            v1.0 - 08/06/99 - release level code (?)           *\n         *            v0.1 - 08/03/99 - creation                         *\n         *                                                               *\n         * ------------------------------------------------------------- */\n\n        arg options\n\n        /* ----------------------------------------------------- *\n         * Define the steplib command being used                 *\n         *    Tone = Tone's Dynastep                             *\n         *    GSF  = Gilbert Saint-flour's Steplib               *\n         *    None = neither installed                           *\n         * ----------------------------------------------------- */\n        /* steplib = \"Tone\" */\n        /* steplib = \"GSF\" */\n        /* steplib = \"None\" */\n        steplib = \"Tone\"\n\n        /* ----------------------------------------------------- *\n         * Test for debug option                                 *\n         * ----------------------------------------------------- */\n        if wordpos(\"DEBUG\",options) > 1 then trace \"?i\"\n\n        /* ----------------------------------------------------- *\n         * Setup defaults                                        *\n         * ----------------------------------------------------- */\n         id = sysvar('sysicmd')\":\"\n         bl = left(\" \",3)\n\n        /* ----------------------------------------------------- *\n         * Test for operands - report if none                    *\n         * ----------------------------------------------------- */\n        if length(options) = 0 then do\n           say id \"Invalid syntax - no options specified\"\n           signal  Invalid_Syntax\n           end\n\n        /* ----------------------------------------------------- *\n         * Clear out variables that we will be using             *\n         * ----------------------------------------------------- */\n        parse value \"\" with null step table skels msgs panels,\n                            applid cmd llib exec clist nocheck ,\n                            pgm parm panel opt sel prefix scrname\n\n        /* ----------------------------------------------------- *\n         * Now process all the keywords that we will use         *\n         * Remove option as processed to find invalid options    *\n         * ----------------------------------------------------- */\n        if pos(\"APPLID(\",options) > 0 then do\n           parse value options with . \"APPLID(\" applid \")\" .\n           p1 = pos(\"APPLID(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"CLIST(\",options) > 0 then do\n           parse value options with . \"CLIST(\" clist \")\" .\n           p1 = pos(\"CLIST(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"CMD(\",options) > 0 then do\n           parse value options with . \"CMD(\" cmd \")\" .\n           p1 = pos(\"CMD(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"EXEC(\",options) > 0 then do\n           parse value options with . \"EXEC(\" exec \")\" .\n           p1 = pos(\"EXEC(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"LLIB(\",options) > 0 then do\n           parse value options with . \"LLIB(\" llib \")\" .\n           p1 = pos(\"LLIB(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"MSGS(\",options) > 0 then do\n           parse value options with . \"MSGS(\" msgs \")\" .\n           p1 = pos(\"MSGS(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"PANEL(\",options) > 0 then do\n           parse value options with . \"PANEL(\" panel \")\" .\n           p1 = pos(\"PANEL(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"PANELS(\",options) > 0 then do\n           parse value options with . \"PANELS(\" panels \")\" .\n           p1 = pos(\"PANELS(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"PARM(\",options) > 0 then do\n           p1 = pos(\"PARM(\",options)\n           if pos(\"PARM((\",options) > 0 then do\n              parse value options with . \" PARM((\" parm \"))\" .\n              pd = 2\n              p2 = pos(\"))\",options,p1)\n              parm = \"(\"parm\")\"\n              end\n           else do\n              pd = 1\n              p2 = pos(\")\",options,p1)\n              parse value options with . \"PARM(\" parm \")\" .\n              end\n           options = delstr(options,p1,p2-p1+pd)\n           end\n        if pos(\"PGM(\",options) > 0 then do\n           parse value options with . \"PGM(\" pgm \")\" .\n           p1 = pos(\"PGM(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"OPT(\",options) > 0 then do\n           parse value options with . \"OPT(\" opt \")\" .\n           p1 = pos(\"OPT(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"SCRNAME(\",options) > 0 then do\n           parse value options with . \"SCRNAME(\" scrname \")\" .\n           p1 = pos(\"SCRNAME(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"SKELS(\",options) > 0 then do\n           parse value options with . \"SKELS(\" skels \")\" .\n           p1 = pos(\"SKELS(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        steplib = translate(steplib)\n        if steplib <> \"NONE\" then\n           if pos(\"STEP(\",options) > 0 then do\n              parse value options with . \"STEP(\" step \")\" .\n              p1 = pos(\"STEP(\",options)\n              p2 = pos(\")\",options,p1)\n              options = delstr(options,p1,p2-p1+1)\n              end\n        if pos(\"TABLE(\",options) > 0 then do\n           parse value options with . \"TABLE(\" table \")\" .\n           p1 = pos(\"TABLE(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if pos(\"PREFIX(\",options) > 0 then do\n           parse value options with . \"PREFIX(\" prefix \")\" .\n           prefix = strip(prefix)\n           p1 = pos(\"PREFIX(\",options)\n           p2 = pos(\")\",options,p1)\n           options = delstr(options,p1,p2-p1+1)\n           end\n        if wordpos(\"NOCHECK\",options) > 0 then do\n           nocheck = \"NOCHECK\"\n           p1 = wordpos(\"NOCHECK\",options)\n           options = delword(options,p1)\n           if length(strip(cmd)) + length(strip(pgm)) = 0\n              then do\n                   say id bl \"Error.\"\n                   say id bl \"NOCHECK is only valid with\",\n                             \"CMD or PGM.\"\n                   say id bl \"Try again.\"\n                   exit 8\n                   end\n           end\n\n        /* ----------------------------------------------------- *\n         * If PREFIX coded find the libraries for it             *\n         * ----------------------------------------------------- */\n        if prefix <> null then do\n           if clist = null then\n              if sysdsn(\"'\"prefix\".CLIST'\") = \"OK\" then\n                 clist = \"'\"prefix\".CLIST'\"\n           if clist = null then\n              if sysdsn(\"'\"prefix\".ISPCLIB'\") = \"OK\" then\n                 clist = \"'\"prefix\".ISPCLIB'\"\n           if exec = null then\n              if sysdsn(\"'\"prefix\".EXEC'\") = \"OK\" then\n                 exec  = \"'\"prefix\".EXEC'\"\n           if msgs = null then\n              if sysdsn(\"'\"prefix\".MSGS'\") = \"OK\" then\n                 msgs  = \"'\"prefix\".MSGS'\"\n           if msgs = null then\n              if sysdsn(\"'\"prefix\".ISPMLIB'\") = \"OK\" then\n                 msgs  = \"'\"prefix\".ISPMLIB'\"\n           if panels = null then\n              if sysdsn(\"'\"prefix\".PANELS'\") = \"OK\" then\n                 panels  = \"'\"prefix\".PANELS'\"\n           if panels = null then\n              if sysdsn(\"'\"prefix\".ISPPLIB'\") = \"OK\" then\n                 panels  = \"'\"prefix\".ISPPLIB'\"\n           if skels = null then\n              if sysdsn(\"'\"prefix\".SKELS'\") = \"OK\" then\n                 skels  = \"'\"prefix\".SKELS'\"\n           if skels = null then\n              if sysdsn(\"'\"prefix\".ISPSLIB'\") = \"OK\" then\n                 skels  = \"'\"prefix\".ISPSLIB'\"\n           if tables = null then\n              if sysdsn(\"'\"prefix\".TABLES'\") = \"OK\" then\n                 tables  = \"'\"prefix\".TABLES'\"\n           if tables = null then\n              if sysdsn(\"'\"prefix\".ISPTLIB'\") = \"OK\" then\n                 tables  = \"'\"prefix\".ISPTLIB'\"\n           if llib = null then\n              if sysdsn(\"'\"prefix\".LLIB'\") = \"OK\" then\n                 llib  = \"'\"prefix\".LLIB'\"\n           if llib = null then\n              if sysdsn(\"'\"prefix\".ISPLLIB'\") = \"OK\" then\n                 llib  = \"'\"prefix\".ISPLLIB'\"\n           if step = null then\n              if sysdsn(\"'\"prefix\".STEPLIB'\") = \"OK\" then\n                 step  = \"'\"prefix\".STEPLIB'\"\n           end\n\n        /* ----------------------------------------------------- *\n         * Test for any unknown options                          *\n         * ----------------------------------------------------- */\n        options = strip(options)\n        if length(options) > 0 then do\n           say id \"Invalid options:\" options\n           signal  Invalid_Syntax\n           end\n\n        /* ----------------------------------------------------- *\n         * Generate the ISPEXEC Select command                   *\n         * ----------------------------------------------------- */\n        select\n          when pgm <> null then do\n               sel = \"PGM(\"pgm\")\"\n               if parm <> null then\n                  sel = sel \"PARM(\"parm\")\"\n               end\n          when panel <> null then do\n               sel = \"PANEL(\"panel\")\"\n               if opt <> null then\n                  sel = sel \"OPT(\"opt\")\"\n               end\n          when cmd <> null then do\n               sel = \"CMD(\"cmd\")\"\n               end\n          otherwise nop\n          end\n\n        if length(nocheck) > 0 then\n           sel = sel \"NOCHECK\"\n\n        if length(scrname) > 0 then\n          sel = sel \"SCRName(\"scrname\")\"\n\n        if length(sel) = 0 then do\n           say id \"Invalid syntax - no CMD, PGM, or PANEL specified.\"\n           signal  Invalid_Syntax\n           end\n\n        if applid <> null then\n           sel = sel \"Newappl(\"applid\") Passlib\"\n\n        /* ----------------------------------------------------- *\n         * Once we have the keywords setup the environment.      *\n         * ----------------------------------------------------- */\n        if length(step) > 0 then call do_steplib\n        if length(clist) > 0 then\n           \"ALTLIB ACTIVATE APPLICATION(clist)\",\n                  \"DATASET(\"clist\")\"\n        if length(exec) > 0 then\n           \"ALTLIB ACTIVATE APPLICATION(exec)\",\n                  \"DATASET(\"exec\")\"\n\n        Address ISPExec\n\n        if length(llib) > 0 then\n           \"Libdef ISPLLIB Dataset id(\"llib\") Stack\"\n        if length(msgs) > 0 then\n           \"Libdef ISPMLIB Dataset id(\"msgs\") Stack\"\n        if length(panels) > 0 then\n           \"Libdef ISPPLIB Dataset id(\"panels\") Stack\"\n        if length(skels) > 0 then\n           \"Libdef ISPSLIB Dataset id(\"skels\") Stack\"\n        if length(table) > 0 then\n           \"Libdef ISPTLIB Dataset id(\"table\") Stack\"\n\n        /* ----------------------------------------------------- *\n         * Invoke the specified application                      *\n         * ----------------------------------------------------- */\n         \"Select\" sel\n\n        /* ----------------------------------------------------- *\n         * Back from the application - now clean up              *\n         * ----------------------------------------------------- */\n        if length(step) > 0 then call free_steplib\n        if length(llib) > 0 then\n           \"Libdef ISPLLIB\"\n        if length(msgs) > 0 then\n           \"Libdef ISPMLIB\"\n        if length(panels) > 0 then\n           \"Libdef ISPPLIB\"\n        if length(skels) > 0 then\n           \"Libdef ISPSLIB\"\n        if length(table) > 0 then\n           \"Libdef ISPTLIB\"\n        if length(clist) > 0 then\n          Address TSO,\n            \"ALTLIB DEACTIVATE APPLICATION(clist)\"\n        if length(exec) > 0 then\n          Address TSO,\n            \"ALTLIB DEACTIVATE APPLICATION(exec)\"\n        exit 0\n\n        /* ----------------------------------------------------- *\n         * Setup the steplib environment                         *\n         * ----------------------------------------------------- */\n        Do_Steplib:\n        if left(steplib,1) = \"T\" then\n             \"DS Add(\"step\") Front Push Nomsg\"\n        if left(steplib,1) = \"G\" then do\n             stepdd = \"step\"random(999)\n             \"Alloc f(\"stepdd\") shr reuse ds(\"step\")\"\n             \"Steplib Set(\"stepdd\")\"\n             end\n        Return\n\n        /* ----------------------------------------------------- *\n         * Free up the steplib environment                       *\n         * ----------------------------------------------------- */\n        Free_Steplib:\n        if left(steplib,1) = \"T\" then\n           Address TSO \"DS Nomsg\"\n        if left(steplib,1) = \"G\" then\n             \"Steplib Close\"\n        Return\n\n        /* ----------------------------------------------------- *\n         * Invalid Syntax                                        *\n         * ----------------------------------------------------- */\n        Invalid_Syntax:\n           say id \" \"\n           say id \"The correct syntax is:\"\n           say id \"%ISPFPROD\"\n           say id bl \"APPLID(ISPF Application ID)\"\n           say id bl \"SCRNAME(ISPF Screen Name)\"\n           say id bl \"CLIST(CLIST Library or Libraries)\"\n           say id bl \"EXEC(Rexx Library or Libraries)\"\n           say id bl \"LLIB(ISPF Load Library or Libraries)\"\n           if steplib <> \"None\" then\n              say id bl \"STEP(Steplib Library or Libraries)\"\n           say id bl \"MSGS(ISPF Messages Library or Libraries)\"\n           say id bl \"PANELS(ISPF Panels Library or Libraries)\"\n           say id bl \"SKELS(ISPF Skeleton Library or Libraries)\"\n           say id bl \"TABLE(ISPF Table Library or Libraries)\"\n           say id bl \"or\"\n           say id bl \"PREFIX(hlq.dsname for libraries)\"\n           say id bl \"CMD(command options) NOCHECK\"\n           say id bl \"or\"\n           say id bl \"PGM(program) PARM(parm) NOCHECK\"\n           say id bl \"or\"\n           say id bl \"PANEL(panel-name) OPT(option)\"\n           exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LDAPMAI$": {"ttr": 19974, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x002\\x7f\\x01\\x002\\x7f\\x10T\\x00\\x06\\x00\\x06\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-11-22T00:00:00", "modifydate": "2000-11-22T10:54:48", "lines": 6, "newlines": 6, "modlines": 0, "user": "WSBG"}, "text": "Attached is a new tool for you to experiment with called\nLDAPMAIL.  It is a simple ISPF dialog for doing a query to a LDAP\nserver.  You provide a name or name pattern and the result is the\ne-mail addresses for that name(s).\n\nJust TSO RECEIVE, customize, and enjoy.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LDAPMAIL": {"ttr": 19976, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x03#\\x9f\\x01\\x03#\\x9f\\x101\\x01X\\x01X\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-08-27T00:00:00", "modifydate": "2003-08-27T10:31:00", "lines": 344, "newlines": 344, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LDAPMCHG": {"ttr": 19982, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x010O\\x01\\x03#\\x8f\\x14E\\x00\\x06\\x00\\x03\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-10-31T00:00:00", "modifydate": "2003-08-26T14:45:18", "lines": 6, "newlines": 3, "modlines": 0, "user": "SYSLBD"}, "text": "Change History:\n\n08/26/2003   Changed LDAPMAIL for query for preferredRfc822Originator=\n             instead of mail=\n\n10/31/2001   Changed LDAPMAIL for a batch mode.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOADISPF": {"ttr": 20225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\"\\x01\\x04\\x17?\\x01\\x19\\x00\\x9f\\x06U\\x01D\\x01+\\x00\\x00\\xc9\\xe2\\xd7\\xc6@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-06-21T00:00:00", "modifydate": "2019-01-09T06:55:22", "lines": 324, "newlines": 299, "modlines": 0, "user": "ISPF"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n Select\n    When type = \"Clist\" then\n         \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n         \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n         \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n         \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n         \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n    end\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\n DropISPF: Procedure\n arg load_info\n Address ISPEXEC\n do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n       if libd = \"ALTLIBC\" then lib = \"CLIST\"\n                           else lib = \"EXEC\"\n       Address TSO,\n         \"Altlib Deact Application(\"lib\")\"\n       end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n    end\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOG": {"ttr": 20231, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x161?\\x01\\x161?\\x01\\t\\x010\\x010\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-08T00:00:00", "modifydate": "2016-11-08T01:09:16", "lines": 304, "newlines": 304, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LOGARCH": {"ttr": 20483, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x01\\x161/\\x01\\x162\\x1f\\x10(\\x00\\xb7\\x00\\xf7\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2016-11-16T10:28:52", "lines": 183, "newlines": 247, "modlines": 0, "user": "SYSLBD"}, "text": "/*                         rexx                               *\n * Name:      logarchive.rex                                  *\n *                                                            *\n * Function:  archive log files by archiving themn to         *\n *            z/OS datasets                                   *\n *                                                            *\n * Syntax:    called from crontab pointing to a parm file     *\n *                                                            *\n * Parm file format:                                          *\n *                                                            *\n *   # log rotation parm file                                 *\n *   #                                                        *\n *   # logfile    logfile-name                                *\n *   # lparname   lpar name (e.g. SYL)                        *\n *   # skipnull   (optional and will skip a null file)        *\n *   # archivezos z/os dataset hlq                            *\n *   #                                                        *\n *                                                            *\n * Sample parm in /usr/local/bin/logarchive.parm              *\n *                                                            *\n * Crontab usage:                                             *\n * 0 0 * * * /usr/local/bin/logarchive.rex /location/parm     *\n *                                                            *\n * where /location/parm is the location and name of the parm  *\n * file                                                       *\n *                                                            *\n * Processing:                                                *\n * 1. Process the parm file                                   *\n * 2. Check for skipnull to ignore empty log files            *\n *    - if no skipnull and the file is empty then             *\n *      write a \"empty log' message to the log file           *\n * 3. Copy the log file to /tmp/                              *\n * 4. cat /dev/nul > log file to empty it                     *\n * 5. Calc space to the z/OS archive file                     *\n * 6. Use CP to copy to z/OS                                  *\n * 7. Delete the /tmp/ copy                                   *\n *                                                            *\n * Notes:                                                     *\n *                                                            *\n * 1. Be careful which log files are processed as some log    *\n *    files are opened by the application and can only be     *\n *    copied AND NOT emptied.                                 *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            10/03/16 - Change mv to cp and rm to cat        *\n *            09/27/16 - Add record for empty log if no       *\n *                       skipnull                             *\n *            09/20/16 - Add error check after CP             *\n *                     - Add space for CP                     *\n *            09/16/16 - Update comments to remove va- prefix *\n *                     - report size (may use in future)      *\n *                     - add parm for null file               *\n *            06/29/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n parse arg parmfile\n\n/* ------------------------------------ *\n * Read in the parm file for processing *\n * ------------------------------------ */\n cmd = 'cat' parmfile\n rc = bpxwunix(cmd,,stdout.,stderr.)\n\n/* -------------------- *\n * Process the parmfile *\n * -------------------- */\n say ' '\n say 'Processing parmfile:' parmfile\n say ' '\n\n/* ------------------------------------- *\n * Set Skipnull to 0 which means to      *\n * archive a log file even if it is null *\n * ------------------------------------- */\n skipnull = 0\n\n do i = 1 to stdout.0\n    if left(stdout.i,1) = '#' then iterate   /* ignore comments */\n    parse value stdout.i with keyword value\n    Select\n      When translate(keyword) = 'LOGFILE' then\n           logfile = strip(value)\n      When translate(keyword) = 'LPARNAME' then\n           lparname = translate(strip(value))\n      When translate(keyword) = 'ARCHIVEZOS' then\n           archivezos = \"'\"translate(strip(value))\"'\"\n      When translate(keyword) = 'SKIPNULL' then\n           skipnull = 1\n      Otherwise nop\n      end\n    end\n\n/* ------------------------ *\n | Log our processing parms |\n * ------------------------ */\n say 'Log rotation parms:'\n say ' '\n say \"logfile:   \" logfile\n say \"lparname:  \" lparname\n say \"archivezos:\" archivezos\n say \"skipnull:  \" skipnull '(0 = process, 1 = skip)'\n\n say ' '\n say 'getting list of log files:'\n say ' '\n cmd = 'ls -la' logfile\n rc = bpxwunix(cmd,,stdout.,stderr.)\n do i = 1 to stdout.0\n    parse value stdout.i with x1 x2 x3 x4 size x6 x7 x8 log\n    if log = '' then iterate\n    say log\n    end\n\n/* ----------------------------------- *\n | Test for skipnull and if non-0 then |\n | check for size of the log file.     |\n * ----------------------------------- */\n if skipnull = 1 then\n    if size = 0 then do\n       say 'Log file:' logfile\n       say 'Log file is null so it will not be archived.'\n       exit 8\n       end\n\n/* -------------------------------------------- *\n | if size is 0 and skipnull is not active then |\n | add record to file to indicate it was empty  |\n * -------------------------------------------- */\n if size = 0 then\n    Address SH 'echo \"Empty file\" >' logfile\n\n/* ------------------------------- *\n | Define the archive dataset name |\n * ------------------------------- */\n yymmdd = right(date('s'),6)\n hhmm = left(time(),2)''substr(time(),4,2)\n archive = archivezos'.'lparname'.D'yymmdd'.T'hhmm\n\n/* ---------------------------------------------- *\n | Calculate space using the size and dividing by |\n | 50000 bytes (using 50k per track) to get the   |\n | number of tracks. Then add 5 for fudge :-)     |\n * ---------------------------------------------- */\n size = size % 50000\n size = (size + 5) % 2\n sec_size = size % 2\n\n/* ------------------------- *\n | Now log what we are doing |\n * ------------------------- */\n say 'Beginning archive'\n say ' '\n say 'Archiving file:' logfile\n say 'Archive file:  ' archive\n say 'Archive size:  ' size\n say ' '\n\n/* ------------------------------ *\n | Now Copy (cp) the file to z/OS |\n * ------------------------------ */\n cmd = \"cp -P 'SPACE=(TRK,(\"size\",\"sec_size\"))'\"  logfile \"//\\'\"archive\"\\'\"\n say cmd\n Address SH cmd\n say 'Copy return code is:' rc\n\n/* -------------------- *\n | Test the return code |\n * -------------------- */\n if rc = 0 then do\n    cmd = 'cat /dev/null >' logfile\n    say cmd\n    Address SH  cmd\n    end\n else do\n      say 'Error in copying.'\n      cmd = 'cp' logfile archive\n      say cmd\n      Address SH cmd\n      end\n\n Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGIT": {"ttr": 20487, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x05\\x00\\x00\\x01\\x04\\x11/\\x01\\x04\\x11/\\x08\\x00\\x01\\xca\\x01\\xca\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "00.05", "flags": 0, "createdate": "2004-04-21T00:00:00", "modifydate": "2004-04-21T08:00:00", "lines": 458, "newlines": 458, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LOGIT$": {"ttr": 20740, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x05\\x00\\x03\\x01\\x04\\t?\\x01\\x04\\to\\x11\\x18\\x00T\\x00\\x06\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "00.05", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-04-05T11:18:03", "lines": 84, "newlines": 6, "modlines": 0, "user": "SYSLBD"}, "text": "LOGIT is a package written in REXX that is intended to be called\nby CLIST or REXX programs to log information.\n\nThe members of this library are:\n\nLOGIT    This is the routine that will add records to a log data set.\nLOGITCPY This routine will copy, and optionally clear out, the log data set.\nSAMPLJOB A sample batch tmp calling Logit.\nSXMITLOG A sample exec to copy and clear a log. This exec will copy\n         the log, using LOGITCPY, to a new hlq appeneding the julian\n         data to the copy data set for uniqueness. It will then clear\n         the log and e-mail the copy using xmitip.\n\nTo install this package copy the members LOGIT and LOGITCPY into a\nlibrary where they can be accessed by the calling applications.\n\nThe log data set allocation recommendation is:\n     RECFM=VB LRECL=255 BLKSIZE=27998\n\nThe primary space allocation should be large enough so that it will\ncontain all the log messages that you anticipate to be generated\nbetween now and the time you copy and clear it. It should have\na secondary space allocation as a precaution.\n\nIt is recommended that the allocation units be in BLOCKS as the\nroutine will not write any data if there is no calculated free\nspace in the data set. The calculation is performed by subtracting\nthe used space from the allocated space (as determined from the\nlistdsi function).\n\n   ** as a precaution to avoid an x37 abend in any production job\n   ** a minimum of 2 free space units (blocks or tracks) is required\n\nThe log data set *must* be defined to your security system so that it\ncan be written to by anyone.\n\n      e.g. ADDSD 'log-dsname' UACC(UPDATE)\n\nIMPORTANT NOTE: Do *NOT* browse the log data set online as that will\n                prevent logging from occuring. Use the LOGITCPY to\n                make a copy to review.\n\nEach routine has documentation in the comments at the beginning of the\ncode so you should review that.\n\nThe basic logic used for LOGIT is:\n\n   1. Process the input options of log data set name and message text.\n   2. If the log data set does not exist then tell someone and exit.\n   3. Test for free space\n      a. If zero then exit\n   4. Attempt to allocate the log data set using DISP=MOD\n      a. if successful write out the message text with header\n      b. if not successful then call the SLEEP routine to sleep\n         for 1 second and then retry the allocation 10 times\n      ** Note that the sleep time and retry count are customizable.\n   5. Free the log data set allocation and exit\n\nThe basic logic used for LOGITCPY is:\n\n   1. Process the input options of log data set name, copy log data set\n      name, and optional clear option.\n   2. If the log data set does not exist then tell someone and exit.\n   3. If the copy log data set exists then tell someone and exit.\n      (the copy data set will be allocated by LOGITCPY)\n   4. Attempt to allocate the log data set using DISP=SHR\n      a. if successful then read in all the log data set records\n      b. if not successful then call the SLEEP routine to sleep\n         for 1 second and then retry the allocation 10 times\n      ** Note that the sleep time and retry count are customizable.\n   5. If the clear option is specified then write out a single\n      record indicating the log has been cleared.\n   6. Free the log data set.\n   6. Allocate and write out the copy log data set, free it and exit.\n\nComments, suggestions, and complaints should be directed to the author\nat:\n\n  Lionel B. Dyck\n  Kaiser Permanente Information Technology\n  25 N. Via Monte Ave.\n  Walnut Creek, CA 94598\n  (925) 926-5332\n  Internet: lionel.b.dyck@kp.org\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOGITCHG": {"ttr": 20743, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x00\\x05\\x00\\x02\\x01\\x04\\t?\\x01\\x04\\x10?\\x07\\x04\\x00\\x16\\x00\\x02\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "00.05", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-04-12T07:04:02", "lines": 22, "newlines": 2, "modlines": 0, "user": "SYSLBD"}, "text": "Change history:\n\n    LOGIT:\n           04/12/04 - 0.5 Correct setting of sleep variable\n           04/05/04 - 0.4 Improve comments\n                    - Require a minimum of 2 free space units to write\n           04/02/04 - 0.3 Change EXIT to RETURN\n                      So step/exec will not terminate\n                    - Add test for remaining space and if none then\n                      exit to avoid a D37 abend\n           04/02/04 - Add version and change jobname/userid\n                      to 8 chars in length\n           04/02/04 - Correct call to Sleep routine\n           04/02/04 - Improve comments and add header\n           04/01/04 - Creation\n\n    LOGITCPY:\n           04/12/04 - Correct setting of sleep variable\n           04/02/04 - Creation\n\n    SXMITLOG:\n           04/05/04 - Added example of using LOGITCPY\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOWER": {"ttr": 20745, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x165o\\x01\\x165o\\t!\\x00\\x0f\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-12-21T00:00:00", "modifydate": "2016-12-21T09:21:00", "lines": 15, "newlines": 14, "modlines": 0, "user": "SYSLBD"}, "text": "/* ------------------------------------- *\n * Name:     Lower                       *\n *                                       *\n * Function: Lowercase the provided data *\n *                                       *\n * Syntax:   x=lower(input)              *\n *                                       *\n * History:                              *\n *           12/21/16: change to use     *\n *                     xrange            *\n *           08/17/07: created           *\n * ------------------------------------- */\n parse arg input\n out = translate(input,xrange('a','z'),xrange('A','Z'))\n return out\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LPREDIT": {"ttr": 20747, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x14\\x07\\x9f\\x01\\x14\\x07\\x9f\"F\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd3\\xc2\\xc4\\xe8\\xc3\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-03-20T00:00:00", "modifydate": "2014-03-20T22:46:50", "lines": 26, "newlines": 26, "modlines": 0, "user": "LBDYCK"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      LPREDIT                                         *\n *                                                            *\n * Function:  ISPF Edit macro to invoke LPRPRINT              *\n *            on the active data set, which is part           *\n *            of the PRINT member of CBT File 312.            *\n *                                                            *\n * Syntax:    LPREDIT                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:   03/20/14 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n Address ISREdit\n 'Macro'\n \"(currdsn)  = DATASET\"\n \"(currmem) = MEMBER\"\n\n if length(currmem) = 0\n    then mem = ''\n    else mem = '('currmem')'\n\n dataset = \"'\"currdsn\"\"mem\"'\"\n\n Address ISPExec 'Select cmd(%lprprint' dataset ')'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LPRPRINT": {"ttr": 20749, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x03\\x01\\x15\\x12\\x0f\\x01\\x18\\x04_\\x07H\\x05=\\x01\\x99\\x00\\x00\\xd7\\xd9\\xc9\\xd5\\xe3@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2015-04-30T00:00:00", "modifydate": "2018-02-14T07:48:03", "lines": 1341, "newlines": 409, "modlines": 0, "user": "PRINT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LPRPROLD": {"ttr": 21257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14\\x08\\x0f\\x01\\x14\\x08\\x0f\\x10V\\x01\\xa5\\x01\\xa5\\x00\\x00\\xd3\\xc2\\xc4\\xe8\\xc3\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-03-21T00:00:00", "modifydate": "2014-03-21T10:56:00", "lines": 421, "newlines": 421, "modlines": 0, "user": "LBDYCK"}, "text": "./ ADD NAME=$DOC     0105-99068-14080-1054-00024-00027-00000-LBDYCK\nThis dataset contains the LPRPRINT ISPF dialog:\n\nLPRPRINT - used to print using the OS/390 (or z/OS) TCP/IP LPR\n           command to any system with a LPD server.  This\n           includes intelligent printers which have LPD built-in.\n\nThe members of this dataset are in IEBUPDTE format.\n\n$DOC     - What you are reading\nLPRPRINT - The above rexx exec which is the entry point to\n           the dialog\nMSGS     - ISPF messages\nLPRPH0   - ISPF panel\nLPRPM    - ISPF panel\nLPRPRIN0 - ISPF panel\n\nNo warranty comes with this dialog - use it at your own risk.  It\nmay require customization to work in your environment.\n\nComments, suggestion, and an occasional (not too many) complaints are\nwelcome to the author:\n\n  Lionel Dyck\n  E-Mail:  lbdyck@gmail.com\n./ ADD NAME=LPREDIT  0101-14079-14079-2246-00026-00026-00000-REXX\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LPREDIT                                         *\n *                                                            *\n * Function:  ISPF Edit macro to invoke LPRPRINT              *\n *            on the active data set, which is part           *\n *            of the PRINT member of CBT File 312.            *\n *                                                            *\n * Syntax:    LPREDIT                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:   03/20/14 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n Address ISREdit\n 'Macro'\n \"(currdsn)  = DATASET\"\n \"(currmem) = MEMBER\"\n\n if length(currmem) = 0\n    then mem = ''\n    else mem = '('currmem')'\n\n dataset = \"'\"currdsn\"\"mem\"'\"\n\n Address ISPExec 'Select cmd(%lprprint' dataset ')'\n./ ADD NAME=LPRPH0   0100-95010-95010-1558-00117-00117-00000-PANEL\n)Attr Default(@+_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type(text) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   $ type(output) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(turq)\n   @ type(text) intens(high)\n   + type(text  ) intens(low )\n     skip(on)\n   # area(SCRL) Extend(ON)\n)Body\n+------------------! Print Data via TCP/IP LPR Information +--------------------\n@Command ===>_zcmd\n@\n+\n#help -------------------------------------------------------------------------#\n)Area Help\n`    Information on Printing to TCP/IP Connected Printers using LPR\n~\n~    This ISPF application provides an easy to use interface for printing\n~    user data on printers that are remotely attached via the TCP/IP network.\n~\n~    LPR is the TCP/IP Line Printer client command that prints the user\n~    information on a remote printer connected via the TCP/IP network.  It\n~    communicates to the LPD (Line Printer server) on a remote Host on\n~    which the requested printer is attached.\n~\n~    The information that is asked for on the panel is:\n~\n`    Input Data Set      ===>\n~\n~    This is the data set name that contains the information that is to be\n~    printed on the remote printer.  The format is:\n~\n~              user.data\n~              user.data(member)\n~              'prefix.user.data'\n~\n`    Printer Name        ===>\n~\n~    This is the name of the printer as it is identified to the Host\n~    on which the printer is attached.\n~\n~       e.g.   lpt1\n~              IBM4019L\n~\n`    Host Name (node)    ===>\n~\n~    This is the TCP/IP Host Name on which the LPD (Line Printer server)\n~    is active that owns the specified printer.\n~\n~       e.g.   iscprint.rockwell.com\n~\n`    Binary              ===>\n~\n~    Used to specify if the user data is to be translated from EBCDIC\n~    to ASCII.  Specify`Yes~if the data is already in ASCII format and\n~    is not to be translated by the LPR command.\n~\n`    Carriage Control    ===>\n~\n~    Specify`Yes~if the data to be printed contains carriage control\n~    and the DCB of the data set does not indicate this fact.  Otherwise\n~    specify`No~.  If the DCB contains carriage control then it will be\n~    used.\n~\n`    Copies              ===>\n~\n~    Indicates the number of copies of the data to be printed.\n~\n`    Lines per Page      ===>\n~\n~    Indicates the number of lines of data per page to be printed before\n~    a new page is forced.  By specifying 0 the maximum number of lines\n~    per page allowed by the printer will be printed.\n~\n`    Header Info         ===>\n~\n~    Indicates if you want a header printed with the name of the data set\n~    being printed on the top of every page.  Only for No Binary and No CC.\n~\n`    Burst Page          ===>\n~\n~    Indicates if you want a banner page to be printed before your\n~    data.  This page is used as a separator page between multiple\n~    print requests and contains the ISPF Host Name, TSO Userid, and\n~    the data set name being printed.\n~\n`    Notify Complete     ===>\n~\n~    This option will request that an electronic mail message be generated\n~    to you when the data has completed printing on the printer.\n~    !Note:`this is not supported by all versions of LPD so even if you\n~          `request the message, you may not receive it.\n~\n`    PostScript          ===>\n~\n~    This option may be Portrait, Landscape, or No.  If 'no' is specified then\n~    no Postscript control headers will be generated for printing on a Postscrpt\n~    printer.  Portrait and Landscape will cause the appropriate headers to be\n~    inserted into the data stream. `Do not use this on a true Postscript file.\n~\n`    Other Options       ===>\n~\n~    This option will allow the user to enter other LPR options that are not\n~    directly supported by this dialog.\n+\n!Note:`Use the Enter key to just scroll down this tutorial or\n`      Use key $LEFT`to scroll down and key $RIGHT`to scroll up.\n)Init\n  .cursor = zcmd\n  &left  = PFK(LEFT)\n  &right = PFK(RIGHT)\n)Proc\n)end\n./ ADD NAME=LPRPM    0101-94013-94018-0732-00031-00030-00000-PANEL\n)ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)\n  | AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n  + TYPE(TEXT) INTENS(LOW)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) PAD(0)\n 01 TYPE(DATAIN) INTENS(HIGH) CAPS(ON)\n 02 TYPE(DATAOUT) INTENS(LOW)\n 03 TYPE(DATAIN)  INTENS(HIGH) CAPS(ON)\n 04 TYPE(DATAOUT)  INTENS(LOW)\n 05 TYPE(DATAOUT)  INTENS(HIGH)\n 06 TYPE(DATAOUT)  INTENS(LOW)\n)BODY WIDTH(80)\n%Member List -- &ZDSN --------------------------------------%ROW\u00a2ZMLCR%OF\u00a2ZMLTR+\n%Command ===>_ZCMD                                            %Scroll ===>_Z   +\n%Commands:      LOCATE, RESET, SELECT, SORT, HELP                              +\n%Line commands: / or S = Select, B = Browse                                    +\n&ZMLCOLS\n|ZDATA ------------------------------------------------------------------------|\n|                                                                              |\n| -----------------------------------------------------------------------------|\n)INIT\n  .ZVARS = 'ZSCML'         /* SCROLL AMT VARIABLE NAME  */\n  .HELP = ISR01130\n)PROC\n  VPUT (ZSCML) PROFILE\n)END\n /*  $M1= MEMLIST   M230     860923   158590 : FUNCTION TEST          */\n /*   PTM00000184                                                     */\n /*                                                                   */\n /*   CHANGED 3 LINES                                            3@M1C*/\n/* 5665-402 (C) COPYRIGHT IBM CORP 1980, 1989 */\n./ ADD NAME=LPRPRINT 0101-14080-14080-1046-00133-00133-00000-REXX\n        /* ---------------------  rexx procedure  ---------------------- *\n         * Name:      LPRPrint                                           *\n         *                                                               *\n         * Function:  Invoked by the user or via another ISPF dialog     *\n         *            to invoke the LPRPRIN0 ISPF Panel and then use     *\n         *            the TCP/IP LPR command to print the specified      *\n         *            data set on a TCP/IP connected printer.            *\n         *                                                               *\n         *            Note that the specified Host must have LPD active  *\n         *            to receive the data.                               *\n         *                                                               *\n         * Syntax:    %lprprint dsname                                   *\n         *                                                               *\n         *            dsname is optional                                 *\n         *                                                               *\n         * Author:    Lionel B. Dyck                                     *\n         *            Kaiser Permanente                                  *\n         *            Walnut Creek, CA 94598                             *\n         *            (510) 926-5332                                     *\n         *            IBMMail:  USKFHLBD                                 *\n         *            Internet: syslbd@ncal.kaiperm.org                  *\n         *                                                               *\n         * History:                                                      *\n         *            03/20/97 - save inds in profile                    *\n         *            01/10/95 - Remove ack as tcp/ip 3.1 doesn't        *\n         *            08/29/94 - update for Postscript option            *\n         *            06/23/94 - fix parse for pds dsname                *\n         *            01/21/94 - fix for pds input w/member name         *\n         *            01/18/94 - add support for member selection if     *\n         *                       dsname is pds and no member given       *\n         *            01/17/94 - fix for invalid dsn and for messages    *\n         *            01/07/94 - add option for additional user specified*\n         *                       parameters other than what is directly  *\n         *                       supported                               *\n         *            01/04/94 - add entry optional parameter of dsn     *\n         *                       and support ACK option                  *\n         *            01/03/94 - updated to cleanup invocation           *\n         *            12/22/93 - creation of application                 *\n         *                                                               *\n         * ------------------------------------------------------------- */\n\n         arg inds\n\n         Address ISPEXEC\n\n         do forever\n           \"VGET (lprdest lprhost lprbin lprcc lprntfy lprlcnt lprhead \",\n                 \"lprburst lprntfy lprps lpruopt lprpinds) Profile\"\n            if length(inds) > 0 then lprpinds = inds\n            \"Display Panel(LPRPRIN0)\"\n            if rc > 3 then exit 0\n           \"VPUT (lprdest lprhost lprbin lprcc lprntfy lprlcnt lprhead \",\n                 \"lprburst lprntfy lprps lpruopt lprpinds) Profile\"\n\n         if sysdsn(lprpinds) <> \"OK\" then do\n            lprsmsg = \"Error\"\n            lprlmsg = \"Specified data set does not exist:\" lprpinds\n            \"Vput (lprsmsg lprlmsg)\"\n            \"SETMSG MSG(LPR002)\"\n            end\n         else do\n              parse value \"\" with binary cc mail line_count header burst,\n                             copies postscr\n              if lprbin   = \"Yes\" then binary = \"Binary\"\n              if lprcc    = \"Yes\" then cc     = \"CC\"\n                                  else cc     = \"NOCC\"\n              if lprntfy  = \"Yes\" then mail   = \"Mail\"\n              if lprhead  = \"No\"  then header = \"NoHeader\"\n              if lprburst = \"No\"  then burst  = \"NoBurst\"\n              if lprcopy  > 1     then copies = \"Copies\" lprcopy\n              if lprlcnt  > 0     then line_count = \"Linecount\" lprlcnt\n              if lprps    = \"Portrait\"  then postscr = \"Postscript\"\n              if lprps    = \"Landscape\" then postscr = \"Landscape\"\n\n              x = listdsi(lprpinds)\n              if pos(\"(\",lprpinds) > 0 then sysdsorg = \"PS\"\n              Select\n                When sysdsorg = \"PS\" | pos(\"(\",lprpinds) > 1\n                     then call do_lpr lprpinds\n                When sysdsorg = \"PO\"\n                     then call do_pds\n                Otherwise nop;\n              end\n              end\n         end\n\n         do_pds:\n            \"Lminit Dataid(dataid) Dataset(\"lprpinds\") Enq(Shrw)\"\n            \"Lmopen Dataid(\"dataid\") Option(Input)\"\n            \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n              \"Commands(Any) Panel(LPRPM)\"\n              do while rc == 0\n                 Call process_selection\n                \"Lmmdisp Dataid(\"dataid\") Option(Get)\"\n                 if rc == 8\n                    then \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n                         \"Commands(Any) Panel(LPRPM)\"\n              end\n              \"Lmmdisp Dataid(\"dataid\") Option(Free)\"\n              \"Lmclose Dataid(\"dataid\")\"\n              \"Lmfree  Dataid(\"dataid\")\"\n            return\n\n         process_selection:\n            if left(lprpinds,1) = \"'\"\n               then parse value lprpinds with \"'\" w_dsn \"'\"\n               else w_dsn = sysvar(\"syspref\")\".\"lprpinds\n            zlmember = strip(zlmember)\n            Select\n            When zllcmd = \"/\" | zllcmd = \"S\"\n            Then do\n              \"Lmmdisp Dataid(\"dataid\") Option(Put) Member(\"zlmember\")\",\n                  \"Zludata(printed)\"\n              call do_lpr \"'\"w_dsn\"(\"zlmember\")'\"\n              end\n            When zllcmd = \"B\"\n            Then \"Browse Dataid(\"dataid\") Member(\"zlmember\")\"\n            Otherwise nop;\n            End\n            return\n\n         do_lpr:\n            arg dsn\n            Address TSO,\n           \"LPR\" dsn \"(Printer\" lprdest \"Host\" lprhost \"Type\",\n                 binary cc mail line_count header burst copies ,\n                 postscr lpruopt\n           if sysdsorg <> \"PS\" then return\n           lprsmsg = \"\"\n           lprlmsg = lprpinds \"printed to\" lprdest \"at\" lprhost\n          \"Vput (lprsmsg lprlmsg)\"\n          \"SETMSG MSG(LPR002)\"\n           return\n./ ADD NAME=LPRPRIN0 0101-95010-99043-1101-00079-00079-00000-PANEL\n)Attr\n   @ type( input) intens(high) caps(off) just(left ) pad('_')\n     color(white)\n   ! type( input) intens(high) caps(off) just(left ) color(white)\n   _ type( input) intens(high) caps(on ) just(left ) color(white)\n   ^ type(text) intens(low ) caps(off) just(asis ) color(white)\n         hilite(uscore)\n   | type(text) intens(high) caps(off) just(asis ) color(white)\n         hilite(uscore)\n   # type(text) intens(high) caps(on) just(left ) color(yellow)\n         hilite(uscore)\n   ` type(text) intens(high) caps(off) just(asis ) color(turq)\n   ~ type(text) intens(low ) caps(off) just(asis ) color(turq)\n   % type(text) intens(low ) caps(off) just(asis ) color(white)\n)Body\n+--------------------% Print Data via TCP/IP LPR Command +----------------------\n%Command ===>_zcmd\n`\n`Enter/Verify:\n`    Input Data Set    %===>_lprpinds                                         +\n%\n`    Printer Name      %===>!lprdest                                          +\n`    Host Name (node)  %===>!lprhost                                          +\n%\n`    Binary            %===>!lprbin+   Use if the file is already ASCII\n`    Carriage Control  %===>!lprcc+    Honor Carriage Control in Column 1\n`    Copies            %===>!lprcopy+\n`    Lines per Page    %===>!lprlcnt+  Lines per page if no CC or (0=default)\n`    Header Info       %===>!lprhead+  Generate header information\n`    Burst Page        %===>!lprburst+ Generate a burst page on the printer\n`    Notify Complete   %===>!lprntfy+  Send Mail when print complete\n`    PostScript        %===>!lprps    +Portrait, Landscape, or No\n`    Other Options     %===>@lpruopt                                           +\n`\n)Init\n .HELP = lprph0\n .cursor  = lprpinds\n &lprbin  = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcopy = trans(&lprcopy &z,1 *,*)\n &lprlcnt = trans(&lprlcnt &z,0 *,*)\n &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No\n                                  p,Portrait, l,Landscape n,No &z,No)\n)Reinit\n .cursor = lprpinds\n &lprbin  = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprcopy = trans(&lprcopy &z,1 *,*)\n &lprlcnt = trans(&lprlcnt &z,0 *,*)\n &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes)\n &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No)\n &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No\n                                  p,Portrait, l,Landscape n,No &z,No)\n)Proc\n &lprbin = trans(trunc(&lprbin,1) Y,Yes N,No y,Yes n,No &z,No *,*)\n &lprcc   = trans(trunc(&lprcc,1) Y,Yes N,No y,Yes n,No &z,No *,*)\n &lprcopy = trans(&lprcopy &z,1 *,*)\n &lprlcnt = trans(&lprlcnt &z,0 *,*)\n &lprhead = trans(trunc(&lprhead,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n &lprburst= trans(trunc(&lprburst,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n &lprntfy = trans(trunc(&lprntfy,1) Y,Yes N,No y,Yes n,No &z,No *,*)\n &lprps   = trans(trunc(&lprps,1) P,Portrait, L,Landscape N,No\n                                  p,Portrait, l,Landscape n,No &z,No *,*)\n ver (&lprpinds,nonblank,dsname,msg=lpr001)\n ver (&lprdest,nb)\n ver (&lprhost,nb)\n ver (&lprbin,nb,list,Yes,No)\n ver (&lprcc,nb,list,Yes,No)\n ver (&lprcopy,nb,num)\n ver (&lprlcnt,nb,num)\n ver (&lprhead,nb,list,Yes,No)\n ver (&lprburst,nb,list,Yes,No)\n ver (&lprntfy,nb,list,Yes,No)\n ver (&lprps,nb,list,Portrait,Landscape,No)\n)End\n./ ADD NAME=LPR00    0105-93356-93356-1227-00004-00004-00000-MSGS\nLPR001\n'Input data set name must be specified and must be a valid dsname'\nLPR002  '&LPRSMSG' .WINDOW=NORESP .TYPE=NOTIFY\n'&LPRLMSG'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPRC": {"ttr": 21511, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x015\\x00\\x03\\x01\\x03\\'\\x9f\\x01\\x080o\"\\x12\\x031\\x02V\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.53", "flags": 0, "createdate": "2003-10-06T00:00:00", "modifydate": "2008-11-01T22:12:03", "lines": 817, "newlines": 598, "modlines": 0, "user": "SBGOLOB"}, "text": "        /* --------------------  rexx procedure  -------------------- */\n         _version_ = \"2.4\"\n        /* Name:      lstproc                                         *\n         *                                                            *\n         * Function:  Display active JES2 proclibs                    *\n         *                                                            *\n         * Syntax:    %lstproc proc                                   *\n         *                                                            *\n         *            Where proc is the name of the JES2 proc or      *\n         *            blank to default to JES2.                       *\n         *                                                            *\n         * Assumptions and Caveats:                                   *\n         *            1. if proc not specified then use JES2          *\n         *            2. only //PROCxx will be looked at              *\n         *            3. comments will be ignored                     *\n         *            4. symbolics are supported (mostly)             *\n         *            5. system symbolics are supported               *\n         *            6. only cataloged datasets are supported        *\n         *            7. JES2 Dynalloc procs are not supported        *\n         *            8. nested symbolics may not work                *\n         *            9. if the mstrjcl or jes2 proc changes that     *\n         *               is what you will see reflected               *\n         *           10. This does NOT report the actual proc usage   *\n         *               but what is found from mstrjcl and the       *\n         *               jes2 proc.                                   *\n         *           11. *IMPORTANT* It is assumed you have RACF      *\n         *               read for the LISTDATA IDCAMS command.        *\n         *               If not find *LISTDATA* and make the          *\n         *               noted changes.  You will then be limited     *\n         *               to the cataloged iplparm dataset.            *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Internet: lbdyck@gmail.com                      *\n         *                                                            *\n         * History:                                                   *\n         *                                                            *\n         *          2008-10-15 - Info about old sysmvs                *\n         *                     - Note:                                *\n         *                       LISTDATA/LDATA in AUTHCMD in IKJTSO00*\n         *                     - substitute vars  left  and  right    *\n         *                               by vars _left_ and _right_   *\n         *                                                            *\n         *          2007-10-16 - If not under ISPF just write         *\n         *                       dd and dsnames to screen             *\n         *                                                            *\n         *          2007-02-20 - Correction from Ian Ramage           *\n         *                       Fix if JES2 Proc in >2 proclib       *\n         *                                                            *\n         *          2006-11-27 - Hartmut Beckmann                     *\n         *                       Changes for better member support    *\n         *                                                            *\n         *          2006-09-25 - Peggy Norton                         *\n         *                       Fix call to subroutine for symbolics *\n         *                                                            *\n         *          2006-05-17 - Jeff Dixon                           *\n         *                       Support //PROCxxxx instead of PROCxx *\n         *                                                            *\n         *          2006-05-11 - Peggy Norton                         *\n         *                       Fix if LOADxx does not have defined  *\n         *                       SYS1.PARMLIB                         *\n         *                                                            *\n         *          2006-01-26 - Ian Ramage                           *\n         *                       Add Numeric Digits 10 to resolve     *\n         *                       issue under z/OS 1.6                 *\n         *                                                            *\n         *          2003-09-02 - John Bloniarz                        *\n         *                       McDonald's Corporation               *\n         *                       630-623-3224                         *\n         *                       john.bloniarz@mcd.com                *\n         *                                                            *\n         *                       make callable as a function from     *\n         *                       REXX to allocate system Parmlibs,    *\n         *                       system Proclibs and/or PROCxx's.     *\n         *                       Changed DD name #PROCMST to          *\n         *                       #PROCLIB when called as a function.  *\n         *                                                            *\n         *          2003-08-28 - John Bloniarz                        *\n         *                       McDonald's Corporation               *\n         *                       630-623-3224                         *\n         *                       john.bloniarz@mcd.com                *\n         *                                                            *\n         *                       add code to resolve all system       *\n         *                       symbols before allocation.           *\n         *                                                            *\n         *          2002-08-19 - correct to work with OS/390 below    *\n         *                       2.10 (broke on 8/18 change)          *\n         *          2002-08-18 - pass ONLY #PROC to ISRDDN            *\n         *                       and bypass former ispf msg           *\n         *          2001-08-15 - support INCLUDE in the Proc          *\n         *          2001-04-25 - fix from Iam Ramage to correctly     *\n         *                       find the parmlib volser.             *\n         *                       ian.ramage@rs-components.com         *\n         *          2001-02-21 - fix if proc symbol has quotes        *\n         *          2000-10-24 - update to get iplparm vol dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *          2000-10-23 - update to get iplparm dsn dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *          2000-06-20 - general release                      *\n         *                     - Change dds to #PROCMST & #PROCnn     *\n         *          2000-06-15 - minor clean up                       *\n         *          2000-06-14 - various changes                      *\n         *                     - add code to dynamically find mstjclxx*\n         *                       from Todd Burrell (zpn6@cdc.gov)     *\n         *          2000-06-13 - creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- *\n         *                                                            *\n         * ---------------------------------------------------------- */\n         signal on novalue name sub_novalue\n        /* ----------------------------------------------------- *\n         * Setup defaults in sub routine                         *\n         * ----------------------------------------------------- */\n         _x_ = sub_init() ;\n        /* -------------------------------------------- *\n         * Check for any passed options. The only       *\n         * supported option at this time is the name of *\n         * the JES2 proc to look for.                   *\n         * -------------------------------------------- */\n         arg options\n\n         ddn = \"JCL\"random(9999)\n         Numeric Digits 10\n\n        /* ----------------------------------------------------- *\n         * test options and use for procname or use JES2         *\n         * ----------------------------------------------------- */\n        if substr(options,1,1) = \".\" then do\n           parse value options with \".\" lstprocm .\n           options = null\n        end\n        if words(options) > 1 then do\n           parse value options with opt1 \" \" opt2 \" \" opt3 \" \" opt4\n           if opt1 = \"*\" then do\n              options = null\n              end\n            else do\n              options = opt1\n              end\n           end\n         else do\n           if options = \"*\" then do\n              options = null\n              end\n           end\n        if options = null then jes2 = \"JES2\"\n                          else jes2 = options\n        isfunc = \"N\"\n        allocdd = null\n        retstr  = null\n        if length(opt2) > 0 then do\n           if abbrev(\"FUNCTION\",opt2,1) = 1 then do\n              isfunc = \"Y\"\n              if length(opt3) > 0 then do\n                 allocdd = opt3\n                 end\n              end\n           end\n\n        /* ----------------------------- *\n         * Test for ISPF and if not then *\n         * set flag to only echo Parmlib *\n         * info to the \"screen\".         *\n         * ----------------------------- */\n         sysispf = sysvar(\"sysispf\")\n         if sysispf = \"ACTIVE\" then ispf = 1\n                               else do\n                                    ispf = 0\n                                    isfunc = \"F\"\n                                    end\n        /* ----------------------------------------------------- *\n         * Code from Todd Burrell to get mstjcl info             *\n         * Enhanced by Ian Ramage                                *\n         * ----------------------------------------------------- */\n        CVT=STORAGE(\"10\",4)\n        CVTECVT=STORAGE(D2X(C2D(CVT)+140),4)\n        /* GET THE IPL LOADPARMS */\n        LOADPARM=STORAGE(D2X(C2D(CVTECVT)+168),8)\n        /* address of IHAIPA control block */\n        CVTIPA=STORAGE(D2X(C2D(CVTECVT)+392),4)\n        /* mstjcl section in IPA */\n        MJC=STORAGE(D2X(C2D(CVTIPA)+2448),4)\n        /* mstjcl section in IPA length */\n        MJCLEN=C2D(STORAGE(D2X(C2D(CVTIPA)+2452),2))\n        /* ieasys source in mstjclxx */\n        MJCSYS=STORAGE(D2X(C2D(CVTIPA)+2454),2)\n        /* mstjcl xx value */\n        MJCXX=STORAGE(D2X(C2D(MJC)+0),MJCLEN)\n        if left(mjcxx,1) = \"(\" then\n            parse value mjcxx with \"(\" mjcxx \")\" .\n\n         /* address of IHAIPA control block */\n         IPLPARM  = Strip(LOADPARM)\n         LOADADR  = Substr(IPLPARM,1,4)\n\n        /* mstjcl section in IPA */\n        ipalpar  = storage(d2x(c2d(cvtipa)+32), 8)\n        ipalpdsn = storage(d2x(c2d(cvtipa)+48),44)\n        parmaddr = storage(d2x(c2d(cvtipa)+92), 4)\n        LOADVOL  = chk_volser(parmaddr)\n        lparm = \"\"strip(IPALPDSN)\"(load\"substr(loadparm,5,2)\")\"\n        lparm = \"\"_apost_\"\"lparm\"\"_apost_\"\"\n\n        /* ----------------------------------------------------- *\n         * Read loadparm member to find parmlibs                 *\n         * ----------------------------------------------------- */\n         if loadvol <> null then\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse volume(\"LOADVOL\")\",\n               \"unit(sysallda)\"\n         else\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse\"\n         \"Execio * diskr\" ddn \"(finis stem in.\"\n         rcode = rc\n         \"Free  f(\"ddn\")\"\n         _LPAR_ = \"true\"\n         do i = 1 to in.0\n            if word(in.i,1) = \"LPARNAME\" then\n               if word(in.i,2) = ipalpar then _LPAR_ = \"true\"\n                                         else _LPAR_ = \"false\"\n            if word(in.i,1) = \"PARMLIB\" & _LPAR_ = \"true\" then\n               parmlibs = parmlibs word(in.i,2)\n            end\n        if parmlibs = null then parmlibs = \"SYS1.PARMLIB\"\n        if wordpos(\"SYS1.PARMLIB\",parmlibs) = 0 then     /* PN */\n           parmlibs = parmlibs\" SYS1.PARMLIB\"            /* PN */\n\n        /* ----------------------------------------------------- *\n         * Alloc all Parmlibs to DD: #PARMLIB (If Appropriate)   *\n         * ----------------------------------------------------- */\n         if isfunc = \"Y\" then do\n            if allocdd = sub_allocdd(\"#PARMLIB\") then do\n               alloc_parms = null\n               do i = 1 to words(parmlibs)\n                  parm  = \"\"_apost_\"\"word(parmlibs,i)\"\"_apost_\"\"\n                  alloc_parms = alloc_parms parm\n                  end\n               if pos(\"&\",alloc_parms) > 0 then do\n                  symtext = alloc_parms\n                  call fix_sym1\n                  alloc_parms = symtext\n                  end\n               RC = msg(\"OFF\")\n               \"Free  f(#PARMLIB)\"\n               RC = msg(\"ON\")\n               \"Alloc f(#PARMLIB) ds(\"alloc_parms\") shr reuse\"\n               retstr = strip(retstr \"#PARMLIB\")\n               end\n            if allocdd <> null &,\n               allocdd = retstr then signal Finish\n            end\n\n        /* ----------------------------------------------------- *\n         * Find PARMLIB with MSTJCLxx                            *\n         * ----------------------------------------------------- */\n         do i = 1 to words(parmlibs)\n            mstrjcl = \"\"strip(word(parmlibs,i))\"(MSTJCL\"mjcxx\")\"\n            mstrjcl = \"\"_apost_\"\"mstrjcl\"\"_apost_\"\"\n            if \"OK\" = sysdsn(mstrjcl) then leave\n            end\n\n        /* ----------------------------------------------------- *\n         * Alloc and read master jcl parmlib member              *\n         * ----------------------------------------------------- */\n        if \"OK\" <> sysdsn(mstrjcl) then do\n           in.0 = 1\n           in.1 = \"//IEFPDSI DSN=SYS1.PROCLIB  \"\n           end\n        else do\n             if pos(\"&\",mstrjcl) > 0 then do\n                symtext = mstrjcl\n                call fix_sym1\n                mstrjcl = symtext\n                end\n             \"Alloc f(\"ddn\") ds(\"mstrjcl\") shr reuse\"\n             \"Execio * diskr\" ddn \"(finis stem in.\"\n             rcode = rc\n             \"Free  f(\"ddn\")\"\n             end\n\n        /* ----------------------------------------------------- *\n         * Find all proclibs in IEFPDSI and save them            *\n         * Updates by ian.ramage@rs-components.com               *\n         * ----------------------------------------------------- */\n        hit = 0\n        do i = 1 to in.0\n          in.i  = TRANSLATE(in.i,\" \",\",\")\n           if hit = 1 then do\n              call fix_sym\n              if substr(in.i,3,1) = \" \"\n                 then do\n                      parse value in.i with . \"DSN=\" dsn \" \" .\n                      proclibs = proclibs dsn\n                      end\n                 else hit = 0\n              end\n           if left(in.i,9) = \"//IEFPDSI\" then do\n              hit = 1\n              parse value in.i with . \"DSN=\" dsn \" \" .\n              dsn = word(strip(dsn),1)                  /* @pn */\n              if pos(\"&\",dsn) > 0 then call fix_sym     /* @pn */\n              proclibs = proclibs dsn\n              end\n           end\n\n        /* ----------------------------------------------------- *\n         * Alloc all Master JCL Proclibs to DD: #PROCMST         *\n         * (or DD: #PROCLIB if called as a function)             *\n         * ----------------------------------------------------- */\n        alloc_procs = null\n        do i = 1 to words(proclibs)\n           proc  = \"\"_apost_\"\"word(proclibs,i)\"\"_apost_\"\"\n           alloc_procs = alloc_procs proc\n           end\n        if pos(\"&\",alloc_procs) > 0 then do\n           symtext = alloc_procs\n           call fix_sym1\n           alloc_procs = symtext\n           end\n        procddn = \"#PROCMST\"\n        if isfunc = \"Y\" then do\n           if allocdd = sub_allocdd(\"#PROCLIB\") then do\n              procddn = \"#PROCLIB\"\n              end\n           end\n        RC = msg(\"OFF\")\n        \"Free  f(\"procddn\")\"\n        RC = msg(\"ON\")\n        if ispf = 1\n           then \"Alloc f(\"procddn\") ds(\"alloc_procs\") shr reuse\"\n           else call echo procddn alloc_procs\n        if isfunc = \"Y\" then do\n           if allocdd = sub_allocdd(\"#PROCLIB\") then do\n              retstr = strip(retstr \"#PROCLIB\")\n              end\n           if allocdd <> null &,\n              allocdd = retstr then signal Finish\n           end\n\n        /* ----------------------------------------------------- *\n         * Now look thru Master JCL Proclibs for JES2 Proc       *\n         * ----------------------------------------------------- */\n         call find_lib\n\n        /* ----------------------------------------------------- *\n         * Now find all //PROCxx and save proc names             *\n         * ----------------------------------------------------- */\n         Start:\n         procs = null\n         hit = 0\n         sym = \"sym\"\n         proc = \"proc\"\n         do i = 1 to in.0\n            if word(in.i,2) = \"INCLUDE\" then do\n               parse value in.i with . \"MEMBER=\"jes2 .\n               in.i = \"//******** replaced \"\n               if pos(\"&\",jes2) > 0 then do\n                  symtext = jes2\n                  call fix_sym1\n                  jes2 = symtext\n                  end\n               call find_lib\n               signal start\n               end\n            if left(in.i,3) = \"//*\" then iterate\n            If hit = 1 then do\n               if substr(in.i,3,1) >= \"A\" then hit = 3\n               end\n            If pos(\" PROC \",in.i) > 0 then hit = 1\n            if hit = 3 then\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) < 9 then\n                      hit = 4\n                  end\n            if hit = 4 then do\n               if left(in.i,6) <> \"//PROC\" then\n                  if substr(in.i,3,1) >= \"A\" then hit = 3\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) > 8 then hit = 3\n                  end\n               if hit = 3 then iterate\n               if left(in.i,6) = \"//PROC\" then do\n                  nn = substr(in.i,7,2)\n                  proc.nn = null\n                  procs = procs nn\n                  end\n               parse value in.i with . \"DSN=\" dsn \",\"\n               dsn = word(strip(dsn),1)\n               if pos(\"&\",dsn) > 0 then call fix_sym\n               if dsn <> null then do\n                  if left(dsn,1) <> _apost_ then ,\n                     dsn = \"\"_apost_\"\"dsn\"\"_apost_\"\"\n                  proc.nn = proc.nn dsn\n                  end\n               end\n            If hit = 1 then do\n               If pos(\" PROC \",in.i) > 0\n                  then test = word(in.i,3)\n                  else test = word(in.i,2)\n               test = translate(test,\" \",\",\")\n               if words(test) > 1 then\n                 do j = 1 to words(test)\n                    parse value word(test,j) with symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                 end\n               else do\n                    parse value test with  symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                    end\n               end\n            if hit >1 then iterate\n            end\n\n        /* ----------------------------------------------------- *\n         * Now alloc DD: #PROCxx                                 *\n         * ----------------------------------------------------- */\n\n        /* ----------------------------------------------------- *\n         * CALL STEMVIEW \"VIEW\",in.,,,\"Debugging mode: STEM IN.\" *\n         * ----------------------------------------------------- */\n           alloc_procs = null\n           do i = 1 to words(procs)\n              if alloc_procs <> null then do\n                 if pos(\"&\",alloc_procs) > 0 then do\n                    symtext = alloc_procs\n                    call fix_sym1\n                    alloc_procs = symtext\n                    end\n                 doalloc = \"N\"\n                 if isfunc = \"Y\" then do\n                    if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                       doalloc = \"Y\"\n                       end\n                    end\n                  else do\n                    doalloc = \"Y\"\n                    end\n                 if doalloc = \"Y\" then do\n                    RC = msg(\"OFF\")\n                    \"Free  f(#PROC\"nn\")\"\n                    RC = msg(\"ON\")\n                    if ispf = 1\n                    then \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                       \"shr reuse\"\n                    else call echo \"#PROC\"nn alloc_procs\n                    end\n                 if isfunc = \"Y\" then do\n                    if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                       retstr = strip(retstr \"#PROC\"nn)\n                       end\n                    if allocdd <> null &,\n                       allocdd = retstr then signal Finish\n                    end\n                 end\n              nn = word(procs,i)\n              alloc_procs = null\n              do j = 1 to words(proc.nn)\n                 pr = word(proc.nn,j)\n                 alloc_procs = alloc_procs pr\n                 end\n              end\n           if alloc_procs <> null then do\n              if pos(\"&\",alloc_procs) > 0 then do\n                 symtext = alloc_procs\n                 call fix_sym1\n                 alloc_procs = symtext\n                 end\n              doalloc = \"N\"\n              if isfunc = \"Y\" then do\n                 if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                    doalloc = \"Y\"\n                    end\n                 end\n               else do\n                 doalloc = \"Y\"\n                 end\n              if doalloc = \"Y\" then do\n                 RC = msg(\"OFF\")\n                 \"Free  f(#PROC\"nn\")\"\n                 RC = msg(\"ON\")\n                 if ispf = 1\n                 then \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                       \"shr reuse\"\n                 else call echo \"#PROC\"nn alloc_procs\n                 end\n              if isfunc = \"Y\" then do\n                 if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                    retstr = strip(retstr \"#PROC\"nn)\n                    end\n                 if allocdd <> null &,\n                    allocdd = retstr then signal Finish\n                 end\n              end\n\n        /* ----------------------------------------------------- *\n         * If not called as a function, invoke ISRDDN to display *\n         * allocations and then free DD names.  if called as a   *\n         * function, simply return the names of the allocated    *\n         * files to the caller.                                  *\n         * ----------------------------------------------------- */\n         Finish:\n           if isfunc = \"N\" then do\n              Address ISPExec\n              lev = mvsvar(\"sysmvs\")\n              lev = substr(lev,3,1)\n              if lev < 6 then do\n                 zedsmsg = null\n                 zedlmsg = \"System and JES2 Proclibs\",\n                           \"have been identified and allocated\",\n                           \"using #PROCMST for the Master JCL\",\n                           \"Proclibs and #PROCxx for the JES2\",\n                           \"Proclibs.               \",\n                           \"Issue ONLY #PROC\",\n                           \"to display only DDs with PROC in the\",\n                           \"ddname.\"\n                 \"Setmsg msg(isrz001)\"\n                 \"Select cmd(isrddn)\"\n                 end\n              else do\n                   \"vget (zdel)\"\n                   zopt = \"Only #PROC\"\n                   if lstprocm /= null then do\n                      zopt = zopt\"\"zdel\"long\"zdel\" member \"lstprocm\n                   end\n                   \"control errors return\"\n                   zmsg000l = _my_env_\"\"copies(\" \",80)\"\"_sysenv_\"\"\n                   \"setmsg msg(ispz000) cond\"\n                   \"Select cmd(isrddn\" zopt\")\"\n                   end\n\n             /* -------------------------- *\n              * Now free all allocations   *\n              * -------------------------- */\n              if ispf = 0 then exit 0\n              Address TSO\n              \"Free f(#PROCMST)\"\n              do i = 1 to words(procs)\n                 \"Free f(#PROC\"word(procs,i)\n                 end\n              retstr = 0\n              end\n            else do\n              if ispf = 0 ,\n              then retstr = 0 ;\n              else do ;\n                      RC = msg(\"OFF\")\n                      \"Free  f(#PROCMST)\"\n                      RC = msg(\"ON\")\n                      if retstr = null then do\n                         retstr = 16\n                         end\n                   end;\n              end\n           Exit retstr\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in the dsname                        *\n         * ----------------------------------------------------- */\n           Fix_Sym: procedure expose (global_vars) ,\n                                     dsn syms sym.\n           do forever\n              parse value dsn with _left_ \"&\" symbol \".\" _right_\n              syssym = mvsvar(\"symdef\",symbol)\n              if syssym <> null then do\n                 dsn = _left_\".\"syssym\"\"_right_\n                 end\n              else do\n                 if wordpos(symbol,syms) = 0 then leave\n                 wp   = wordpos(symbol,syms)\n                 symb = word(syms,wp)\n                 hlq  = sym.symb\n                 if left(hlq,1) = _apost_ then ,\n                    parse value hlq with (_apost_) hlq (_apost_)\n                 dsn  = _left_\"\"hlq\"\"_right_\n                 end\n              if pos(\"&\",dsn) = 0 then leave\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in an expression (symtext)           *\n         * ----------------------------------------------------- */\n           Fix_Sym1:\n           /* shift the symbols and their values to an array */\n           symb.0 = words(syms)\n           do i = 1 to symb.0\n                jj = word(syms,i)\n                symb.i.1 = word(syms,i)\n                symb.i.2 = sym.jj\n           end\n           fixstart = 1\n           srchdone = \"N\"\n           do until srchdone = \"Y\"\n              p1 = pos(\"&\",symtext,fixstart)\n              if p1 > 0 then do\n                 parse value symtext with _left_\"&\"fixsymb\n                 if left(fixsymb,1) = \"&\" then do\n                    p1 = p1 + 1        /* ignore \"&&\" */\n                    end\n                  else do\n                    _right_ = null\n                    symdone = \"N\"\n                    do r=1 to length(fixsymb) until symdone = \"Y\"\n                       if datatype(substr(fixsymb,r,1),\"ALPHA\") = 0 ,\n                       then do\n                          _right_ = substr(fixsymb,r)\n                          if left(_right_,1) = \".\" then do\n                             _right_ = substr(_right_,2)\n                             end\n                          fixsymb = substr(fixsymb,1,r-1)\n                          symdone = \"Y\"\n                          end\n                       end\n                    if length(fixsymb) > 0 then do\n                       syssym = null\n                       do symidx = 1 to symb.0\n                          if fixsymb = symb.symidx.1 ,\n                          then do\n                                   syssym = symb.symidx.2\n                                   leave\n                               end\n                       end\n                       if syssym = null then ,\n                          syssym = mvsvar(\"symdef\",fixsymb)\n                       if syssym <> null then do\n                          symtext = _left_\".\"syssym\"\"_right_\n                          end\n                       end\n                    end\n                 fixstart = p1 + 1\n                 if fixstart > length(symtext) then do\n                    srchdone = \"Y\"\n                    end\n                 end\n               else do\n                 srchdone = \"Y\"\n                 end\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix volser for IPLPARM volume                         *\n         * ----------------------------------------------------- */\n           chk_volser: procedure expose (global_vars)\n           parse arg unitnbr\n           stat. = null\n           dumy = outtrap(\"stat.\")\n               \"LISTDATA STATUS UNITNUMBER(\"strip(UNITNBR)\")\"\n                 parse var stat.3   \"VOLUME\" volser \"DEVICE\" .\n           dumy = outtrap(\"off\")\n           return strip(volser)\n\n        /* --------------------------------------------------------- *\n         * Find Library for Proc                                     *\n         * --------------------------------------------------------- */\n         find_lib:\n         do ip = 1 to words(proclibs)\n            proc  = \"\"_apost_\"\"word(proclibs,ip)\"(\"jes2\")\"_apost_\"\"\n            if pos(\"&\",proc) > 0 then do\n               symtext = proc\n               call fix_sym1\n               proc = symtext\n               end\n            if \"OK\" = sysdsn(proc) then leave\n            end\n\n        /* --------------------------------------------------------- *\n         * Read in the JES2 Proc                                     *\n         * --------------------------------------------------------- */\n        \"Alloc f(\"ddn\") ds(\"proc\") shr reuse\"\n        \"Execio * diskr\" ddn \"(finis stem prc.\"\n        rcode = rc\n        \"Free  f(\"ddn\")\"\n        if in.0 = 0 then\n           do i = 0 to prc.0\n              in.i = prc.i\n              end\n        else do\n             c = in.0\n             do i = 1 to prc.0\n                c = c + 1\n                in.c = prc.i\n                end\n              in.0 = c\n              end\n        return\n\n        /* -------------------------------- *\n         * Echo to the Terminal all DSnames *\n         * -------------------------------- */\n         Echo: Procedure expose (global_vars) ,\n                                echo. _my_env_ _sysenv_\n         Parse Arg dd dsns\n         echo.0 = echo.0 + 1\n         if echo.0 = 1 ,\n         then do ;\n                   hl = 62\n                   _info_    = copies(\"=\",hl)\n                   info.1    = \"*\"left(_info_,hl)\"*\"\n                   _info_    = null\n                   _info_    = _info_\" \"_my_env_\n                   info.2    = \"*\"left(_info_,hl)\"*\"\n                   _info_    = null\n                   _info_    = _info_\" \"_sysenv_\n                   info.3    = \"*\"left(_info_,hl)\"*\"\n                   info.4    = info.1\n                   _info_    = null\n                   _info_    = _info_\"\"left(\"*DD\",10)\"\"\n                   _info_    = _info_\"\"left(\"VOLSER\",10)\"\"\n                   _info_    = _info_\"DSNAME\"\n                   info.5    = _info_\n                   _info_    = null\n                   _info_    = _info_\"\"left(\"*\"copies(\"-\",08),10)\n                   _info_    = _info_\"\"left(copies(\"-\",06),10)\n                   _info_    = _info_\"\"copies(\"-\",44)\n                   info.6    = _info_\n                   info.0    = 6\n                   do i = 1 to info.0\n                      say \"\"info.i\"\"\n                   end\n              end;\n         dsn.0 = words(dsns) ;\n         do i = 1 to dsn.0 ;\n            if i = 1 ,\n            then dsn.i.1 = dd\n            else dsn.i.1 = null\n            dsn.i.2 = word(dsns,i)\n            _rc_ = listdsi(\"\"dsn.i.2\"\")\n            if _rc_ = 0 ,\n            then     dsn.i.3 = sysvolume\n            else     dsn.i.3 = \"N/A\"\n         end\n         do i = 1 to dsn.0 ;\n             say left(dsn.i.1,10)\"\"left(dsn.i.3,10)\"\"dsn.i.2\n         end\n         return\n\n  sub_allocdd: procedure expose (global_vars)\n     parse arg alloc_dd\n     select  ;\n       when ( alloc_dd = alloc_dd_def ) then r_string = alloc_dd ;\n       when ( alloc_dd = null         ) then r_string = alloc_dd ;\n       otherwise do  ;\n                                             r_string = null     ;\n                 end ;\n     end ;\n     return r_string ;\n\n  sub_init:\n         parse value \"\" with null ddn test mstrjcl proclibs,\n                             proc syms procs parmlibs,\n                             opt1 opt2 opt3 opt4 lstprocm\n         _apost_ = \"'\"\n         parse source xenv xtype xmyname xddname xdsname .\n         _sysplex_ = mvsvar(\"sysplex\")\n         _sysname_ = mvsvar(\"sysname\")\n         _sysmvs_  = MVSVAR(\"SYSMVS\")\n         parse value \"\" with _more_ custname custplex LPAR KSYSENV\n         if _sysmvs_ > \"SP7.0.5\" ,\n         then do ;\n                 /* null if not defined           *\n                  *  other variables can be added */\n                 _morevars_ = \"CUSTNAME CUSTPLEX LPAR KSYSENV\"\n                 do _i_ = 1 to words(_morevars_)\n                    _morekey_ = word(_morevars_,_i_)\n                    _moreval_ = mvsvar('symdef',_morekey_)\n                    _valcmd_ = \"\"_morekey_ \"= '\"_moreval_\"' \"\n                    interpret _valcmd_\n                    if _moreval_ /= null ,\n                    then do ;\n                              _more_=\"\"_more_\"\"_morekey_\"=\"_moreval_\" \"\n                         end;\n                 end;\n              end;\n         else do ;\n                 _more_ = \"SYSMVS=\"_sysmvs_\n              end;\n         _more_ = strip(_more_)\n         _sysenv_  = null\n         if custname /= null ,\n         then _sysenv_  = \"\"_sysenv_\"\"custname\": \"\n         _sysenv_  = \"\"_sysenv_\"SYSPLEX=\"_sysplex_\" \"\n         if custplex /= null ,\n         then do;\n                 if custplex  /= _sysplex_ ,\n                 then _sysenv_ = \"\"_sysenv_\"CUSTPLEX=\"custplex\" \"\n              end;\n         if lpar = null ,\n         then lpar = _sysname_\n         if lpar       = _sysname_ ,\n         then do ;\n                  _sysenv_= \"\"_sysenv_\"LPAR/SYSNAME=\"lpar\" \"\n              end;\n         else do ;\n                  _sysenv_= \"\"_sysenv_\"SYSNAME=\"_sysname_\" LPAR=\"lpar\" \"\n              end;\n         _sysenv_  = \"\"_sysenv_\"\"_more_\n         _sysenv_  = strip(_sysenv_)\n         _my_env_  = \"\"xmyname\" \"_version_\"\"\n         echo.0 = 0\n         global_vars = \"null _apost_\"\n     return 0\n\n      /**************************************************************\n      * Trap uninitialized variables                                *\n      ***************************************************************/\n      sub_novalue:\n      Say \"\"\n      Say \"Variable\" ,\n         condition(\"Description\") \"undefined in line\" sigl\":\"\n      Say sourceline(sigl)\n      if sysvar(\"sysenv\") <> \"FORE\" then exit 8\n      say \"Report the error in this application along with the\",\n          \"syntax used.\"\n      exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPRC$": {"ttr": 21770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00C\\x01\\x00\\x16\\x8f\\x01\\x18\\x04\\x7f\\x142\\x00\\x13\\x00\\n\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-06-16T00:00:00", "modifydate": "2018-02-16T14:32:43", "lines": 19, "newlines": 10, "modlines": 0, "user": "SBGOLOB"}, "text": "This version of LSTPROC was modified by me (Sam Golob) to accommodate\nour hokey JES2 proc that has rather awkward symbolics.  I asked Lionel\nto whip me up a version of the LSTPROC he originally sent me, which\nwould handle symbolics.  And he actually did so, in short order (for\nwhich I thank him).  His version was created \"sight unseen\" to our JES2\nproc, and I had to tweak it a bit, so it would put a period in between\n2 qualifiers.  So this version is \"unofficial\".  I just put it here,\nbecause I want to help somebody who needs it.  Just don't blame Lionel\nfor any defects--it isn't exactly what he sent me.\n\nThe exec works by reading your JES2 proc, and allocating ddnames to\nyour TSO session, that correspond to the PROC00 ddnames, etc.  Then\nit invokes ISRDDN, so you can browse the concatenations or edit them\nunder ISPF.  It works, provided that it can read the dataset names\nin your JES2 proc.  Use it in good health!\n\nRegards,    Sam Golob     mailto:sbgolob@cbttape.org\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPRCO": {"ttr": 22017, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00T\\x01\\x02#\\x1f\\x01\\x02#\\x1f\\x11\\x04\\x01v\\x01u\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-08-19T00:00:00", "modifydate": "2002-08-19T11:04:54", "lines": 374, "newlines": 373, "modlines": 0, "user": "SBGOLOB"}, "text": "        /* --------------------  rexx procedure  -------------------- *\n         * Name:      lstproc                                         *\n         *                                                            *\n         * Function:  Display active JES2 proclib's                   *\n         *                                                            *\n         * Syntax:    %lstproc proc                                   *\n         *                                                            *\n         *            Where proc is the name of the JES2 proc or      *\n         *            blank to default to JES2.                       *\n         *                                                            *\n         * Assumptions and Caveats:                                   *\n         *            1. if proc not specified then use JES2          *\n         *            2. only //PROCxx will be looked at              *\n         *            3. comments will be ignored                     *\n         *            4. symbolics are supported (mostly)             *\n         *            5. system symbolics are supported               *\n         *            6. only cataloged datasets are supported        *\n         *            7. JES2 Dynalloc procs are not supported        *\n         *            8. nested symbolics may not work                *\n         *            9. if the mstrjcl or jes2 proc changes that     *\n         *               is what you will see reflected               *\n         *           10. This does NOT report the actual proc usage   *\n         *               but what is found from mstrjcl and the       *\n         *               jes2 proc.                                   *\n         *           11. *IMPORTANT* It is assumed you have RACF      *\n         *               read for the LISTDATA IDCAMS command.        *\n         *               If not find *LISTDATA* and make the          *\n         *               noted changes.  You will then be limited     *\n         *               to the cataloged iplparm dataset.            *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Kaiser Permanente Information Technology        *\n         *            Walnut Creek, CA 94598                          *\n         *            (925) 926-5332                                  *\n         *            Internet: lionel.b.dyck@kp.org                  *\n         *                                                            *\n         * History:                                                   *\n         *            08/18/02 - pass ONLY #PROC to ISRDDN            *\n         *                       and bypass former ispf msg           *\n         *            08/15/01 - support INCLUDE in the Proc          *\n         *            04/25/01 - fix from Iam Ramage to correctly     *\n         *                       find the parmlib volser.             *\n         *                       ian.ramage@rs-components.com         *\n         *            02/21/01 - fix if proc symbol has quotes        *\n         *            10/24/00 - update to get iplparm vol dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *            10/23/00 - update to get iplparm dsn dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *            06/20/00 - general release                      *\n         *                     - Change dd's to #PROCMST & #PROCnn    *\n         *            06/15/00 - minor clean up                       *\n         *            06/14/00 - various changes                      *\n         *                     - add code to dynamically find mstjclxx*\n         *                       from Todd Burrell (zpn6@cdc.gov)     *\n         *            06/13/00 - creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- */\n\n        arg options\n\n        /* ----------------------------------------------------- *\n         * Setup defaults                                        *\n         * ----------------------------------------------------- */\n        parse value \"\" with null ddn test mstrjcl proclibs,\n                            proc syms procs parmlibs\n        ddn = \"JCL\"random(9999)\n\n        /* ----------------------------------------------------- *\n         * test options and use for procname or use JES2         *\n         * ----------------------------------------------------- */\n        if options = null then jes2 = \"JES2\"\n                          else jes2 = options\n\n        /* ----------------------------------------------------- *\n         * Code from Todd Burrell to get mstjcl info             *\n         * Enhanced by Ian Ramage                                *\n         * ----------------------------------------------------- */\n        CVT=STORAGE('10',4)\n        CVTECVT=STORAGE(D2X(C2D(CVT)+140),4)\n        /* GET THE IPL LOADPARMS */\n        LOADPARM=STORAGE(D2X(C2D(CVTECVT)+168),8)\n        /* address of IHAIPA control block */\n        CVTIPA=STORAGE(D2X(C2D(CVTECVT)+392),4)\n        /* mstjcl section in IPA */\n        MJC=STORAGE(D2X(C2D(CVTIPA)+2448),4)\n        /* mstjcl section in IPA length */\n        MJCLEN=C2D(STORAGE(D2X(C2D(CVTIPA)+2452),2))\n        /* ieasys source in mstjclxx */\n        MJCSYS=STORAGE(D2X(C2D(CVTIPA)+2454),2)\n        /* mstjcl xx value */\n        MJCXX=STORAGE(D2X(C2D(MJC)+0),MJCLEN)\n        if left(mjcxx,1) = \"(\" then\n            parse value mjcxx with \"(\" mjcxx \")\" .\n\n         /* address of IHAIPA control block */\n         IPLPARM  = Strip(LOADPARM)\n         LOADADR  = Substr(IPLPARM,1,4)\n\n        /* mstjcl section in IPA */\n        ipalpar  = storage(d2x(c2d(cvtipa)+32), 8)\n        ipalpdsn = storage(d2x(c2d(cvtipa)+48),44)\n        parmaddr = storage(d2x(c2d(cvtipa)+92), 4)\n        LOADVOL  = chk_volser(parmaddr)\n        lparm = \"'\"strip(IPALPDSN)\"(load\"substr(loadparm,5,2)\")'\"\n\n        /* ----------------------------------------------------- *\n         * Read loadparm member to find parmlibs                 *\n         * ----------------------------------------------------- */\n         if loadvol <> null then\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse volume(\"LOADVOL\")\",\n               \"unit(sysallda)\"\n         else\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse\"\n         \"Execio * diskr\" ddn \"(finis stem in.\"\n         \"Free  f(\"ddn\")\"\n         LPAR = true\n         do i = 1 to in.0\n            if word(in.i,1) = \"LPARNAME\" then\n               if word(in.i,2) = ipalpar then LPAR = true\n                                         else LPAR = false\n            if word(in.i,1) = \"PARMLIB\" & LPAR = true then\n               parmlibs = parmlibs word(in.i,2)\n            end\n        if parmlibs = \"\" then parmlibs = \"SYS1.PARMLIB\"\n\n        /* ----------------------------------------------------- *\n         * Find PARMLIB with MSTJCLxx                            *\n         * ----------------------------------------------------- */\n         do i = 1 to words(parmlibs)\n            mstrjcl = \"'\"strip(word(parmlibs,i))\"(MSTJCL\"mjcxx\")'\"\n            if \"OK\" = sysdsn(mstrjcl) then leave\n            end\n\n        /* ----------------------------------------------------- *\n         * Alloc and read master jcl parmlib member              *\n         * ----------------------------------------------------- */\n        if \"OK\" <> sysdsn(mstrjcl) then do\n           in.0 = 1\n           in.1 = \"//IEFPDSI DSN=SYS1.PROCLIB  \"\n           end\n        else do\n             \"Alloc f(\"ddn\") ds(\"mstrjcl\") shr reuse\"\n             \"Execio * diskr\" ddn \"(finis stem in.\"\n             \"Free  f(\"ddn\")\"\n             end\n\n        /* ----------------------------------------------------- *\n         * Find all proclibs in IEFPDSI and save them            *\n         * Updates by ian.ramage@rs-components.com               *\n         * ----------------------------------------------------- */\n        hit = 0\n        do i = 1 to in.0\n          in.i  = TRANSLATE(in.i,\" \",\",\")\n           if hit = 1 then do\n              if substr(in.i,3,1) = \" \"\n                 then do\n                      parse value in.i with . \"DSN=\" dsn \" \" .\n                      proclibs = proclibs dsn\n                      end\n                 else hit = 0\n              end\n           if left(in.i,9) = \"//IEFPDSI\" then do\n              hit = 1\n              parse value in.i with . \"DSN=\" dsn \" \" .\n              proclibs = proclibs dsn\n              end\n           end\n\n        /* ----------------------------------------------------- *\n         * Alloc all Master JCL Proclib's to DD: #PROCMST        *\n         * ----------------------------------------------------- */\n        alloc_procs = null\n        do i = 1 to words(proclibs)\n           proc  = \"'\"word(proclibs,i)\"'\"\n           alloc_procs = alloc_procs proc\n           end\n        \"Alloc f(#PROCMST) ds(\"alloc_procs\") shr reuse\"\n\n        /* ----------------------------------------------------- *\n         * Now look thru Master JCL Proclibs for JES2 Proc       *\n         * ----------------------------------------------------- */\n         call find_lib\n\n        /* ----------------------------------------------------- *\n         * Now find all //PROCxx and save proc names             *\n         * ----------------------------------------------------- */\n         Start:\n         procs = null\n         hit = 0\n         sym = \"sym\"\n         proc = \"proc\"\n         do i = 1 to in.0\n            if word(in.i,2) = \"INCLUDE\" then do\n               parse value in.i with . \"MEMBER=\"jes2 .\n               in.i = \"//******** replaced \"\n               if pos(\"&\",jes2) > 0 then do\n                  parse value jes2 with left\"&\"symbol\n                  syssym = mvsvar('symdef',symbol)\n                  if syssym <> null then do\n                     jes2 = left\"\"syssym\n                     end\n                  end\n               call find_lib\n               signal start\n               end\n            if left(in.i,3) = \"//*\" then iterate\n            If hit = 1 then do\n               if substr(in.i,3,1) >= \"A\" then hit = 3\n               end\n            If pos(\" PROC \",in.i) > 0 then hit = 1\n            if hit = 3 then\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) = 6 then\n                      hit = 4\n                  end\n            if hit = 4 then do\n               if left(in.i,6) <> \"//PROC\" then\n                  if substr(in.i,3,1) >= \"A\" then hit = 3\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) > 6 then hit = 3\n                  end\n               if hit = 3 then iterate\n               if left(in.i,6) = \"//PROC\" then do\n                  nn = substr(in.i,7,2)\n                  proc.nn = null\n                  procs = procs nn\n                  end\n               parse value in.i with . \"DSN=\" dsn \",\"\n               dsn = word(strip(dsn),1)\n               if pos(\"&\",dsn) > 0 then call fix_sym\n               if dsn <> null then do\n                  if left(dsn,1) <> \"'\" then\n                     dsn = \"'\"dsn\"'\"\n                  proc.nn = proc.nn dsn\n                  end\n               end\n            If hit = 1 then do\n               If pos(\" PROC \",in.i) > 0\n                  then test = word(in.i,3)\n                  else test = word(in.i,2)\n               test = translate(test,\" \",\",\")\n               if words(test) > 1 then\n                 do j = 1 to words(test)\n                    parse value word(test,j) with symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                 end\n               else do\n                    parse value test with  symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                    end\n               end\n            if hit >1 then iterate\n            end\n\n        /* ----------------------------------------------------- *\n         * Now alloc DD: #PROCxx                                 *\n         * ----------------------------------------------------- */\n           alloc_procs = null\n           do i = 1 to words(procs)\n              if alloc_procs <> null then\n                 \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                    \"shr reuse\"\n              nn = word(procs,i)\n              alloc_procs = null\n              do j = 1 to words(proc.nn)\n                 pr = word(proc.nn,j)\n                 alloc_procs = alloc_procs pr\n                 end\n              end\n           if alloc_procs <> null then\n              \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                 \"shr reuse\"\n\n        /* ----------------------------------------------------- *\n         * Now invoke ISRDDN to display allocations              *\n         * ----------------------------------------------------- */\n           Address ISPExec\n           lev = mvsvar('sysmvs')\n           lev = substr(lev,3,1)\n           if lev < 6 then do\n              zedsmsg = null\n              zedlmsg = \"System and JES2 Proclib's\",\n                        \"have been identified and allocated\",\n                        \"using #PROCMST for the Master JCL\",\n                        \"Proclibs and #PROCxx for the JES2\",\n                        \"Proclibs.               \",\n                        \"Issue ONLY #PROC\",\n                        \"to display only DD's with PROC in the\",\n                        \"ddname.\"\n              \"Setmsg msg(isrz001)\"\n              \"Select cmd(isrddn)\"\n              end\n           else do\n                zopt = \"Only #PROC\"\n                \"Select cmd(isrddn\" zopt\")\"\n                end\n\n          /* -------------------------- *\n           * Now free all allocations   *\n           * -------------------------- */\n           Address TSO\n           \"Free f(#PROCMST)\"\n           do i = 1 to words(procs)\n              \"Free f(#PROC\"word(procs,i)\n              end\n           Exit 0\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in the dsname                        *\n         * ----------------------------------------------------- */\n           Fix_Sym: procedure expose dsn syms sym. null\n           do forever\n              parse value dsn with left \"&\" symbol \".\" right\n              syssym = mvsvar('symdef',symbol)\n              if syssym <> null then do\n                 dsn = left\"\"syssym\"\".\"\"right\"\"\n                 end\n              else do\n                 if wordpos(symbol,syms) = 0 then leave\n                 wp   = wordpos(symbol,syms)\n                 symb = word(syms,wp)\n                 hlq  = sym.symb\n                 if left(hlq,1) = \"'\" then\n                    parse value hlq with \"'\" hlq \"'\"\n                 dsn  = left\"\"hlq\"\"right\n                 end\n              if pos(\"&\",dsn) = 0 then leave\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix volser for IPLPARM volume                         *\n         * ----------------------------------------------------- */\n           chk_volser: procedure\n           parse arg unitnbr\n           stat. = \"\"\n           dumy = outtrap(\"stat.\")\n               \"LISTDATA STATUS UNITNUMBER(\"strip(UNITNBR)\")\"\n                 parse var stat.3   'VOLUME' volser 'DEVICE' .\n           dumy = outtrap(\"off\")\n           return strip(volser)\n\n        /* --------------------------------------------------------- *\n         * Find Library for Proc                                     *\n         * --------------------------------------------------------- */\n         find_lib:\n         do i = 1 to words(proclibs)\n            proc  = \"'\"word(proclibs,i)\"(\"jes2\")'\"\n            if \"OK\" = sysdsn(proc) then leave\n            end\n\n        /* --------------------------------------------------------- *\n         * Read in the JES2 Proc                                     *\n         * --------------------------------------------------------- */\n        \"Alloc f(\"ddn\") ds(\"proc\") shr reuse\"\n        \"Execio * diskr\" ddn \"(finis stem prc.\"\n        \"Free  f(\"ddn\")\"\n        if in.0 = 0 then\n           do i = 0 to prc.0\n              in.i = prc.i\n              end\n        else do\n             c = in.0\n             do i = 1 to prc.0\n                c = c + 1\n                in.c = prc.i\n                end\n              in.0 = c\n              end\n        return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPROC": {"ttr": 22024, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x014\\x00\\x19\\x01\\x03'\\x9f\\x01\\x08)\\x0f\\x08\\x14\\x031\\x02V\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@\"", "ispf": {"version": "01.52", "flags": 0, "createdate": "2003-10-06T00:00:00", "modifydate": "2008-10-16T08:14:19", "lines": 817, "newlines": 598, "modlines": 0, "user": "SYSLBD"}, "text": "        /* --------------------  rexx procedure  -------------------- */\n         _version_ = \"2.4\"\n        /* Name:      lstproc                                         *\n         *                                                            *\n         * Function:  Display active JES2 proclibs                    *\n         *                                                            *\n         * Syntax:    %lstproc proc                                   *\n         *                                                            *\n         *            Where proc is the name of the JES2 proc or      *\n         *            blank to default to JES2.                       *\n         *                                                            *\n         * Assumptions and Caveats:                                   *\n         *            1. if proc not specified then use JES2          *\n         *            2. only //PROCxx will be looked at              *\n         *            3. comments will be ignored                     *\n         *            4. symbolics are supported (mostly)             *\n         *            5. system symbolics are supported               *\n         *            6. only cataloged datasets are supported        *\n         *            7. JES2 Dynalloc procs are not supported        *\n         *            8. nested symbolics may not work                *\n         *            9. if the mstrjcl or jes2 proc changes that     *\n         *               is what you will see reflected               *\n         *           10. This does NOT report the actual proc usage   *\n         *               but what is found from mstrjcl and the       *\n         *               jes2 proc.                                   *\n         *           11. *IMPORTANT* It is assumed you have RACF      *\n         *               read for the LISTDATA IDCAMS command.        *\n         *               If not find *LISTDATA* and make the          *\n         *               noted changes.  You will then be limited     *\n         *               to the cataloged iplparm dataset.            *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Internet: lbdyck@gmail.com                      *\n         *                                                            *\n         * History:                                                   *\n         *                                                            *\n         *          2008-10-15 - Info about old sysmvs                *\n         *                     - Note:                                *\n         *                       LISTDATA/LDATA in AUTHCMD in IKJTSO00*\n         *                     - substitute vars  left  and  right    *\n         *                               by vars _left_ and _right_   *\n         *                                                            *\n         *          2007-10-16 - If not under ISPF just write         *\n         *                       dd and dsnames to screen             *\n         *                                                            *\n         *          2007-02-20 - Correction from Ian Ramage           *\n         *                       Fix if JES2 Proc in >2 proclib       *\n         *                                                            *\n         *          2006-11-27 - Hartmut Beckmann                     *\n         *                       Changes for better member support    *\n         *                                                            *\n         *          2006-09-25 - Peggy Norton                         *\n         *                       Fix call to subroutine for symbolics *\n         *                                                            *\n         *          2006-05-17 - Jeff Dixon                           *\n         *                       Support //PROCxxxx instead of PROCxx *\n         *                                                            *\n         *          2006-05-11 - Peggy Norton                         *\n         *                       Fix if LOADxx does not have defined  *\n         *                       SYS1.PARMLIB                         *\n         *                                                            *\n         *          2006-01-26 - Ian Ramage                           *\n         *                       Add Numeric Digits 10 to resolve     *\n         *                       issue under z/OS 1.6                 *\n         *                                                            *\n         *          2003-09-02 - John Bloniarz                        *\n         *                       McDonald's Corporation               *\n         *                       630-623-3224                         *\n         *                       john.bloniarz@mcd.com                *\n         *                                                            *\n         *                       make callable as a function from     *\n         *                       REXX to allocate system Parmlibs,    *\n         *                       system Proclibs and/or PROCxx's.     *\n         *                       Changed DD name #PROCMST to          *\n         *                       #PROCLIB when called as a function.  *\n         *                                                            *\n         *          2003-08-28 - John Bloniarz                        *\n         *                       McDonald's Corporation               *\n         *                       630-623-3224                         *\n         *                       john.bloniarz@mcd.com                *\n         *                                                            *\n         *                       add code to resolve all system       *\n         *                       symbols before allocation.           *\n         *                                                            *\n         *          2002-08-19 - correct to work with OS/390 below    *\n         *                       2.10 (broke on 8/18 change)          *\n         *          2002-08-18 - pass ONLY #PROC to ISRDDN            *\n         *                       and bypass former ispf msg           *\n         *          2001-08-15 - support INCLUDE in the Proc          *\n         *          2001-04-25 - fix from Iam Ramage to correctly     *\n         *                       find the parmlib volser.             *\n         *                       ian.ramage@rs-components.com         *\n         *          2001-02-21 - fix if proc symbol has quotes        *\n         *          2000-10-24 - update to get iplparm vol dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *          2000-10-23 - update to get iplparm dsn dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *          2000-06-20 - general release                      *\n         *                     - Change dds to #PROCMST & #PROCnn     *\n         *          2000-06-15 - minor clean up                       *\n         *          2000-06-14 - various changes                      *\n         *                     - add code to dynamically find mstjclxx*\n         *                       from Todd Burrell (zpn6@cdc.gov)     *\n         *          2000-06-13 - creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- *\n         *                                                            *\n         * ---------------------------------------------------------- */\n         signal on novalue name sub_novalue\n        /* ----------------------------------------------------- *\n         * Setup defaults in sub routine                         *\n         * ----------------------------------------------------- */\n         _x_ = sub_init() ;\n        /* -------------------------------------------- *\n         * Check for any passed options. The only       *\n         * supported option at this time is the name of *\n         * the JES2 proc to look for.                   *\n         * -------------------------------------------- */\n         arg options\n\n         ddn = \"JCL\"random(9999)\n         Numeric Digits 10\n\n        /* ----------------------------------------------------- *\n         * test options and use for procname or use JES2         *\n         * ----------------------------------------------------- */\n        if substr(options,1,1) = \".\" then do\n           parse value options with \".\" lstprocm .\n           options = null\n        end\n        if words(options) > 1 then do\n           parse value options with opt1 \" \" opt2 \" \" opt3 \" \" opt4\n           if opt1 = \"*\" then do\n              options = null\n              end\n            else do\n              options = opt1\n              end\n           end\n         else do\n           if options = \"*\" then do\n              options = null\n              end\n           end\n        if options = null then jes2 = \"JES2\"\n                          else jes2 = options\n        isfunc = \"N\"\n        allocdd = null\n        retstr  = null\n        if length(opt2) > 0 then do\n           if abbrev(\"FUNCTION\",opt2,1) = 1 then do\n              isfunc = \"Y\"\n              if length(opt3) > 0 then do\n                 allocdd = opt3\n                 end\n              end\n           end\n\n        /* ----------------------------- *\n         * Test for ISPF and if not then *\n         * set flag to only echo Parmlib *\n         * info to the \"screen\".         *\n         * ----------------------------- */\n         sysispf = sysvar(\"sysispf\")\n         if sysispf = \"ACTIVE\" then ispf = 1\n                               else do\n                                    ispf = 0\n                                    isfunc = \"F\"\n                                    end\n        /* ----------------------------------------------------- *\n         * Code from Todd Burrell to get mstjcl info             *\n         * Enhanced by Ian Ramage                                *\n         * ----------------------------------------------------- */\n        CVT=STORAGE(\"10\",4)\n        CVTECVT=STORAGE(D2X(C2D(CVT)+140),4)\n        /* GET THE IPL LOADPARMS */\n        LOADPARM=STORAGE(D2X(C2D(CVTECVT)+168),8)\n        /* address of IHAIPA control block */\n        CVTIPA=STORAGE(D2X(C2D(CVTECVT)+392),4)\n        /* mstjcl section in IPA */\n        MJC=STORAGE(D2X(C2D(CVTIPA)+2448),4)\n        /* mstjcl section in IPA length */\n        MJCLEN=C2D(STORAGE(D2X(C2D(CVTIPA)+2452),2))\n        /* ieasys source in mstjclxx */\n        MJCSYS=STORAGE(D2X(C2D(CVTIPA)+2454),2)\n        /* mstjcl xx value */\n        MJCXX=STORAGE(D2X(C2D(MJC)+0),MJCLEN)\n        if left(mjcxx,1) = \"(\" then\n            parse value mjcxx with \"(\" mjcxx \")\" .\n\n         /* address of IHAIPA control block */\n         IPLPARM  = Strip(LOADPARM)\n         LOADADR  = Substr(IPLPARM,1,4)\n\n        /* mstjcl section in IPA */\n        ipalpar  = storage(d2x(c2d(cvtipa)+32), 8)\n        ipalpdsn = storage(d2x(c2d(cvtipa)+48),44)\n        parmaddr = storage(d2x(c2d(cvtipa)+92), 4)\n        LOADVOL  = chk_volser(parmaddr)\n        lparm = \"\"strip(IPALPDSN)\"(load\"substr(loadparm,5,2)\")\"\n        lparm = \"\"_apost_\"\"lparm\"\"_apost_\"\"\n\n        /* ----------------------------------------------------- *\n         * Read loadparm member to find parmlibs                 *\n         * ----------------------------------------------------- */\n         if loadvol <> null then\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse volume(\"LOADVOL\")\",\n               \"unit(sysallda)\"\n         else\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse\"\n         \"Execio * diskr\" ddn \"(finis stem in.\"\n         rcode = rc\n         \"Free  f(\"ddn\")\"\n         _LPAR_ = \"true\"\n         do i = 1 to in.0\n            if word(in.i,1) = \"LPARNAME\" then\n               if word(in.i,2) = ipalpar then _LPAR_ = \"true\"\n                                         else _LPAR_ = \"false\"\n            if word(in.i,1) = \"PARMLIB\" & _LPAR_ = \"true\" then\n               parmlibs = parmlibs word(in.i,2)\n            end\n        if parmlibs = null then parmlibs = \"SYS1.PARMLIB\"\n        if wordpos(\"SYS1.PARMLIB\",parmlibs) = 0 then     /* PN */\n           parmlibs = parmlibs\" SYS1.PARMLIB\"            /* PN */\n\n        /* ----------------------------------------------------- *\n         * Alloc all Parmlibs to DD: #PARMLIB (If Appropriate)   *\n         * ----------------------------------------------------- */\n         if isfunc = \"Y\" then do\n            if allocdd = sub_allocdd(\"#PARMLIB\") then do\n               alloc_parms = null\n               do i = 1 to words(parmlibs)\n                  parm  = \"\"_apost_\"\"word(parmlibs,i)\"\"_apost_\"\"\n                  alloc_parms = alloc_parms parm\n                  end\n               if pos(\"&\",alloc_parms) > 0 then do\n                  symtext = alloc_parms\n                  call fix_sym1\n                  alloc_parms = symtext\n                  end\n               RC = msg(\"OFF\")\n               \"Free  f(#PARMLIB)\"\n               RC = msg(\"ON\")\n               \"Alloc f(#PARMLIB) ds(\"alloc_parms\") shr reuse\"\n               retstr = strip(retstr \"#PARMLIB\")\n               end\n            if allocdd <> null &,\n               allocdd = retstr then signal Finish\n            end\n\n        /* ----------------------------------------------------- *\n         * Find PARMLIB with MSTJCLxx                            *\n         * ----------------------------------------------------- */\n         do i = 1 to words(parmlibs)\n            mstrjcl = \"\"strip(word(parmlibs,i))\"(MSTJCL\"mjcxx\")\"\n            mstrjcl = \"\"_apost_\"\"mstrjcl\"\"_apost_\"\"\n            if \"OK\" = sysdsn(mstrjcl) then leave\n            end\n\n        /* ----------------------------------------------------- *\n         * Alloc and read master jcl parmlib member              *\n         * ----------------------------------------------------- */\n        if \"OK\" <> sysdsn(mstrjcl) then do\n           in.0 = 1\n           in.1 = \"//IEFPDSI DSN=SYS1.PROCLIB  \"\n           end\n        else do\n             if pos(\"&\",mstrjcl) > 0 then do\n                symtext = mstrjcl\n                call fix_sym1\n                mstrjcl = symtext\n                end\n             \"Alloc f(\"ddn\") ds(\"mstrjcl\") shr reuse\"\n             \"Execio * diskr\" ddn \"(finis stem in.\"\n             rcode = rc\n             \"Free  f(\"ddn\")\"\n             end\n\n        /* ----------------------------------------------------- *\n         * Find all proclibs in IEFPDSI and save them            *\n         * Updates by ian.ramage@rs-components.com               *\n         * ----------------------------------------------------- */\n        hit = 0\n        do i = 1 to in.0\n          in.i  = TRANSLATE(in.i,\" \",\",\")\n           if hit = 1 then do\n              call fix_sym\n              if substr(in.i,3,1) = \" \"\n                 then do\n                      parse value in.i with . \"DSN=\" dsn \" \" .\n                      proclibs = proclibs dsn\n                      end\n                 else hit = 0\n              end\n           if left(in.i,9) = \"//IEFPDSI\" then do\n              hit = 1\n              parse value in.i with . \"DSN=\" dsn \" \" .\n              dsn = word(strip(dsn),1)                  /* @pn */\n              if pos(\"&\",dsn) > 0 then call fix_sym     /* @pn */\n              proclibs = proclibs dsn\n              end\n           end\n\n        /* ----------------------------------------------------- *\n         * Alloc all Master JCL Proclibs to DD: #PROCMST         *\n         * (or DD: #PROCLIB if called as a function)             *\n         * ----------------------------------------------------- */\n        alloc_procs = null\n        do i = 1 to words(proclibs)\n           proc  = \"\"_apost_\"\"word(proclibs,i)\"\"_apost_\"\"\n           alloc_procs = alloc_procs proc\n           end\n        if pos(\"&\",alloc_procs) > 0 then do\n           symtext = alloc_procs\n           call fix_sym1\n           alloc_procs = symtext\n           end\n        procddn = \"#PROCMST\"\n        if isfunc = \"Y\" then do\n           if allocdd = sub_allocdd(\"#PROCLIB\") then do\n              procddn = \"#PROCLIB\"\n              end\n           end\n        RC = msg(\"OFF\")\n        \"Free  f(\"procddn\")\"\n        RC = msg(\"ON\")\n        if ispf = 1\n           then \"Alloc f(\"procddn\") ds(\"alloc_procs\") shr reuse\"\n           else call echo procddn alloc_procs\n        if isfunc = \"Y\" then do\n           if allocdd = sub_allocdd(\"#PROCLIB\") then do\n              retstr = strip(retstr \"#PROCLIB\")\n              end\n           if allocdd <> null &,\n              allocdd = retstr then signal Finish\n           end\n\n        /* ----------------------------------------------------- *\n         * Now look thru Master JCL Proclibs for JES2 Proc       *\n         * ----------------------------------------------------- */\n         call find_lib\n\n        /* ----------------------------------------------------- *\n         * Now find all //PROCxx and save proc names             *\n         * ----------------------------------------------------- */\n         Start:\n         procs = null\n         hit = 0\n         sym = \"sym\"\n         proc = \"proc\"\n         do i = 1 to in.0\n            if word(in.i,2) = \"INCLUDE\" then do\n               parse value in.i with . \"MEMBER=\"jes2 .\n               in.i = \"//******** replaced \"\n               if pos(\"&\",jes2) > 0 then do\n                  symtext = jes2\n                  call fix_sym1\n                  jes2 = symtext\n                  end\n               call find_lib\n               signal start\n               end\n            if left(in.i,3) = \"//*\" then iterate\n            If hit = 1 then do\n               if substr(in.i,3,1) >= \"A\" then hit = 3\n               end\n            If pos(\" PROC \",in.i) > 0 then hit = 1\n            if hit = 3 then\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) < 9 then\n                      hit = 4\n                  end\n            if hit = 4 then do\n               if left(in.i,6) <> \"//PROC\" then\n                  if substr(in.i,3,1) >= \"A\" then hit = 3\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) > 8 then hit = 3\n                  end\n               if hit = 3 then iterate\n               if left(in.i,6) = \"//PROC\" then do\n                  nn = substr(in.i,7,2)\n                  proc.nn = null\n                  procs = procs nn\n                  end\n               parse value in.i with . \"DSN=\" dsn \",\"\n               dsn = word(strip(dsn),1)\n               if pos(\"&\",dsn) > 0 then call fix_sym\n               if dsn <> null then do\n                  if left(dsn,1) <> _apost_ then ,\n                     dsn = \"\"_apost_\"\"dsn\"\"_apost_\"\"\n                  proc.nn = proc.nn dsn\n                  end\n               end\n            If hit = 1 then do\n               If pos(\" PROC \",in.i) > 0\n                  then test = word(in.i,3)\n                  else test = word(in.i,2)\n               test = translate(test,\" \",\",\")\n               if words(test) > 1 then\n                 do j = 1 to words(test)\n                    parse value word(test,j) with symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                 end\n               else do\n                    parse value test with  symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                    end\n               end\n            if hit >1 then iterate\n            end\n\n        /* ----------------------------------------------------- *\n         * Now alloc DD: #PROCxx                                 *\n         * ----------------------------------------------------- */\n\n        /* ----------------------------------------------------- *\n         * CALL STEMVIEW \"VIEW\",in.,,,\"Debugging mode: STEM IN.\" *\n         * ----------------------------------------------------- */\n           alloc_procs = null\n           do i = 1 to words(procs)\n              if alloc_procs <> null then do\n                 if pos(\"&\",alloc_procs) > 0 then do\n                    symtext = alloc_procs\n                    call fix_sym1\n                    alloc_procs = symtext\n                    end\n                 doalloc = \"N\"\n                 if isfunc = \"Y\" then do\n                    if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                       doalloc = \"Y\"\n                       end\n                    end\n                  else do\n                    doalloc = \"Y\"\n                    end\n                 if doalloc = \"Y\" then do\n                    RC = msg(\"OFF\")\n                    \"Free  f(#PROC\"nn\")\"\n                    RC = msg(\"ON\")\n                    if ispf = 1\n                    then \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                       \"shr reuse\"\n                    else call echo \"#PROC\"nn alloc_procs\n                    end\n                 if isfunc = \"Y\" then do\n                    if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                       retstr = strip(retstr \"#PROC\"nn)\n                       end\n                    if allocdd <> null &,\n                       allocdd = retstr then signal Finish\n                    end\n                 end\n              nn = word(procs,i)\n              alloc_procs = null\n              do j = 1 to words(proc.nn)\n                 pr = word(proc.nn,j)\n                 alloc_procs = alloc_procs pr\n                 end\n              end\n           if alloc_procs <> null then do\n              if pos(\"&\",alloc_procs) > 0 then do\n                 symtext = alloc_procs\n                 call fix_sym1\n                 alloc_procs = symtext\n                 end\n              doalloc = \"N\"\n              if isfunc = \"Y\" then do\n                 if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                    doalloc = \"Y\"\n                    end\n                 end\n               else do\n                 doalloc = \"Y\"\n                 end\n              if doalloc = \"Y\" then do\n                 RC = msg(\"OFF\")\n                 \"Free  f(#PROC\"nn\")\"\n                 RC = msg(\"ON\")\n                 if ispf = 1\n                 then \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                       \"shr reuse\"\n                 else call echo \"#PROC\"nn alloc_procs\n                 end\n              if isfunc = \"Y\" then do\n                 if allocdd = sub_allocdd(\"#PROC\"nn) then do\n                    retstr = strip(retstr \"#PROC\"nn)\n                    end\n                 if allocdd <> null &,\n                    allocdd = retstr then signal Finish\n                 end\n              end\n\n        /* ----------------------------------------------------- *\n         * If not called as a function, invoke ISRDDN to display *\n         * allocations and then free DD names.  if called as a   *\n         * function, simply return the names of the allocated    *\n         * files to the caller.                                  *\n         * ----------------------------------------------------- */\n         Finish:\n           if isfunc = \"N\" then do\n              Address ISPExec\n              lev = mvsvar(\"sysmvs\")\n              lev = substr(lev,3,1)\n              if lev < 6 then do\n                 zedsmsg = null\n                 zedlmsg = \"System and JES2 Proclibs\",\n                           \"have been identified and allocated\",\n                           \"using #PROCMST for the Master JCL\",\n                           \"Proclibs and #PROCxx for the JES2\",\n                           \"Proclibs.               \",\n                           \"Issue ONLY #PROC\",\n                           \"to display only DDs with PROC in the\",\n                           \"ddname.\"\n                 \"Setmsg msg(isrz001)\"\n                 \"Select cmd(isrddn)\"\n                 end\n              else do\n                   \"vget (zdel)\"\n                   zopt = \"Only #PROC\"\n                   if lstprocm /= null then do\n                      zopt = zopt\"\"zdel\"long\"zdel\" member \"lstprocm\n                   end\n                   \"control errors return\"\n                   zmsg000l = _my_env_\"\"copies(\" \",80)\"\"_sysenv_\"\"\n                   \"setmsg msg(ispz000) cond\"\n                   \"Select cmd(isrddn\" zopt\")\"\n                   end\n\n             /* -------------------------- *\n              * Now free all allocations   *\n              * -------------------------- */\n              if ispf = 0 then exit 0\n              Address TSO\n              \"Free f(#PROCMST)\"\n              do i = 1 to words(procs)\n                 \"Free f(#PROC\"word(procs,i)\n                 end\n              retstr = 0\n              end\n            else do\n              if ispf = 0 ,\n              then retstr = 0 ;\n              else do ;\n                      RC = msg(\"OFF\")\n                      \"Free  f(#PROCMST)\"\n                      RC = msg(\"ON\")\n                      if retstr = null then do\n                         retstr = 16\n                         end\n                   end;\n              end\n           Exit retstr\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in the dsname                        *\n         * ----------------------------------------------------- */\n           Fix_Sym: procedure expose (global_vars) ,\n                                     dsn syms sym.\n           do forever\n              parse value dsn with _left_ \"&\" symbol \".\" _right_\n              syssym = mvsvar(\"symdef\",symbol)\n              if syssym <> null then do\n                 dsn = _left_\"\"syssym\"\"_right_\n                 end\n              else do\n                 if wordpos(symbol,syms) = 0 then leave\n                 wp   = wordpos(symbol,syms)\n                 symb = word(syms,wp)\n                 hlq  = sym.symb\n                 if left(hlq,1) = _apost_ then ,\n                    parse value hlq with (_apost_) hlq (_apost_)\n                 dsn  = _left_\"\"hlq\"\"_right_\n                 end\n              if pos(\"&\",dsn) = 0 then leave\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in an expression (symtext)           *\n         * ----------------------------------------------------- */\n           Fix_Sym1:\n           /* shift the symbols and their values to an array */\n           symb.0 = words(syms)\n           do i = 1 to symb.0\n                jj = word(syms,i)\n                symb.i.1 = word(syms,i)\n                symb.i.2 = sym.jj\n           end\n           fixstart = 1\n           srchdone = \"N\"\n           do until srchdone = \"Y\"\n              p1 = pos(\"&\",symtext,fixstart)\n              if p1 > 0 then do\n                 parse value symtext with _left_\"&\"fixsymb\n                 if left(fixsymb,1) = \"&\" then do\n                    p1 = p1 + 1        /* ignore \"&&\" */\n                    end\n                  else do\n                    _right_ = null\n                    symdone = \"N\"\n                    do r=1 to length(fixsymb) until symdone = \"Y\"\n                       if datatype(substr(fixsymb,r,1),\"ALPHA\") = 0 ,\n                       then do\n                          _right_ = substr(fixsymb,r)\n                          if left(_right_,1) = \".\" then do\n                             _right_ = substr(_right_,2)\n                             end\n                          fixsymb = substr(fixsymb,1,r-1)\n                          symdone = \"Y\"\n                          end\n                       end\n                    if length(fixsymb) > 0 then do\n                       syssym = null\n                       do symidx = 1 to symb.0\n                          if fixsymb = symb.symidx.1 ,\n                          then do\n                                   syssym = symb.symidx.2\n                                   leave\n                               end\n                       end\n                       if syssym = null then ,\n                          syssym = mvsvar(\"symdef\",fixsymb)\n                       if syssym <> null then do\n                          symtext = _left_\"\"syssym\"\"_right_\n                          end\n                       end\n                    end\n                 fixstart = p1 + 1\n                 if fixstart > length(symtext) then do\n                    srchdone = \"Y\"\n                    end\n                 end\n               else do\n                 srchdone = \"Y\"\n                 end\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix volser for IPLPARM volume                         *\n         * ----------------------------------------------------- */\n           chk_volser: procedure expose (global_vars)\n           parse arg unitnbr\n           stat. = null\n           dumy = outtrap(\"stat.\")\n               \"LISTDATA STATUS UNITNUMBER(\"strip(UNITNBR)\")\"\n                 parse var stat.3   \"VOLUME\" volser \"DEVICE\" .\n           dumy = outtrap(\"off\")\n           return strip(volser)\n\n        /* --------------------------------------------------------- *\n         * Find Library for Proc                                     *\n         * --------------------------------------------------------- */\n         find_lib:\n         do ip = 1 to words(proclibs)\n            proc  = \"\"_apost_\"\"word(proclibs,ip)\"(\"jes2\")\"_apost_\"\"\n            if pos(\"&\",proc) > 0 then do\n               symtext = proc\n               call fix_sym1\n               proc = symtext\n               end\n            if \"OK\" = sysdsn(proc) then leave\n            end\n\n        /* --------------------------------------------------------- *\n         * Read in the JES2 Proc                                     *\n         * --------------------------------------------------------- */\n        \"Alloc f(\"ddn\") ds(\"proc\") shr reuse\"\n        \"Execio * diskr\" ddn \"(finis stem prc.\"\n        rcode = rc\n        \"Free  f(\"ddn\")\"\n        if in.0 = 0 then\n           do i = 0 to prc.0\n              in.i = prc.i\n              end\n        else do\n             c = in.0\n             do i = 1 to prc.0\n                c = c + 1\n                in.c = prc.i\n                end\n              in.0 = c\n              end\n        return\n\n        /* -------------------------------- *\n         * Echo to the Terminal all DSnames *\n         * -------------------------------- */\n         Echo: Procedure expose (global_vars) ,\n                                echo. _my_env_ _sysenv_\n         Parse Arg dd dsns\n         echo.0 = echo.0 + 1\n         if echo.0 = 1 ,\n         then do ;\n                   hl = 62\n                   _info_    = copies(\"=\",hl)\n                   info.1    = \"*\"left(_info_,hl)\"*\"\n                   _info_    = null\n                   _info_    = _info_\" \"_my_env_\n                   info.2    = \"*\"left(_info_,hl)\"*\"\n                   _info_    = null\n                   _info_    = _info_\" \"_sysenv_\n                   info.3    = \"*\"left(_info_,hl)\"*\"\n                   info.4    = info.1\n                   _info_    = null\n                   _info_    = _info_\"\"left(\"*DD\",10)\"\"\n                   _info_    = _info_\"\"left(\"VOLSER\",10)\"\"\n                   _info_    = _info_\"DSNAME\"\n                   info.5    = _info_\n                   _info_    = null\n                   _info_    = _info_\"\"left(\"*\"copies(\"-\",08),10)\n                   _info_    = _info_\"\"left(copies(\"-\",06),10)\n                   _info_    = _info_\"\"copies(\"-\",44)\n                   info.6    = _info_\n                   info.0    = 6\n                   do i = 1 to info.0\n                      say \"\"info.i\"\"\n                   end\n              end;\n         dsn.0 = words(dsns) ;\n         do i = 1 to dsn.0 ;\n            if i = 1 ,\n            then dsn.i.1 = dd\n            else dsn.i.1 = null\n            dsn.i.2 = word(dsns,i)\n            _rc_ = listdsi(\"\"dsn.i.2\"\")\n            if _rc_ = 0 ,\n            then     dsn.i.3 = sysvolume\n            else     dsn.i.3 = \"N/A\"\n         end\n         do i = 1 to dsn.0 ;\n             say left(dsn.i.1,10)\"\"left(dsn.i.3,10)\"\"dsn.i.2\n         end\n         return\n\n  sub_allocdd: procedure expose (global_vars)\n     parse arg alloc_dd\n     select  ;\n       when ( alloc_dd = alloc_dd_def ) then r_string = alloc_dd ;\n       when ( alloc_dd = null         ) then r_string = alloc_dd ;\n       otherwise do  ;\n                                             r_string = null     ;\n                 end ;\n     end ;\n     return r_string ;\n\n  sub_init:\n         parse value \"\" with null ddn test mstrjcl proclibs,\n                             proc syms procs parmlibs,\n                             opt1 opt2 opt3 opt4 lstprocm\n         _apost_ = \"'\"\n         parse source xenv xtype xmyname xddname xdsname .\n         _sysplex_ = mvsvar(\"sysplex\")\n         _sysname_ = mvsvar(\"sysname\")\n         _sysmvs_  = MVSVAR(\"SYSMVS\")\n         parse value \"\" with _more_ custname custplex LPAR KSYSENV\n         if _sysmvs_ > \"SP7.0.5\" ,\n         then do ;\n                 /* null if not defined           *\n                  *  other variables can be added */\n                 _morevars_ = \"CUSTNAME CUSTPLEX LPAR KSYSENV\"\n                 do _i_ = 1 to words(_morevars_)\n                    _morekey_ = word(_morevars_,_i_)\n                    _moreval_ = mvsvar('symdef',_morekey_)\n                    _valcmd_ = \"\"_morekey_ \"= '\"_moreval_\"' \"\n                    interpret _valcmd_\n                    if _moreval_ /= null ,\n                    then do ;\n                              _more_=\"\"_more_\"\"_morekey_\"=\"_moreval_\" \"\n                         end;\n                 end;\n              end;\n         else do ;\n                 _more_ = \"SYSMVS=\"_sysmvs_\n              end;\n         _more_ = strip(_more_)\n         _sysenv_  = null\n         if custname /= null ,\n         then _sysenv_  = \"\"_sysenv_\"\"custname\": \"\n         _sysenv_  = \"\"_sysenv_\"SYSPLEX=\"_sysplex_\" \"\n         if custplex /= null ,\n         then do;\n                 if custplex  /= _sysplex_ ,\n                 then _sysenv_ = \"\"_sysenv_\"CUSTPLEX=\"custplex\" \"\n              end;\n         if lpar = null ,\n         then lpar = _sysname_\n         if lpar       = _sysname_ ,\n         then do ;\n                  _sysenv_= \"\"_sysenv_\"LPAR/SYSNAME=\"lpar\" \"\n              end;\n         else do ;\n                  _sysenv_= \"\"_sysenv_\"SYSNAME=\"_sysname_\" LPAR=\"lpar\" \"\n              end;\n         _sysenv_  = \"\"_sysenv_\"\"_more_\n         _sysenv_  = strip(_sysenv_)\n         _my_env_  = \"\"xmyname\" \"_version_\"\"\n         echo.0 = 0\n         global_vars = \"null _apost_\"\n     return 0\n\n      /**************************************************************\n      * Trap uninitialized variables                                *\n      ***************************************************************/\n      sub_novalue:\n      Say \"\"\n      Say \"Variable\" ,\n         condition(\"Description\") \"undefined in line\" sigl\":\"\n      Say sourceline(sigl)\n      if sysvar(\"sysenv\") <> \"FORE\" then exit 8\n      say \"Report the error in this application along with the\",\n          \"syntax used.\"\n      exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPROC$": {"ttr": 22283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00 \\x01\\x00\\x17\\x7f\\x01\\x16\\x11\\x0f\\x14\\x16\\x00\\n\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-06-25T00:00:00", "modifydate": "2016-04-19T14:16:20", "lines": 10, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "This is Lionel Dyck's \"official version\" of LSTPROC, to display\nPROCLIB usage and dataset concatenations.\n\nLSTPROCO is the old version that displays all allocations, not just\nproclibs.  LSTPRCO is my version of Lionel's old version.\n\nLSTPROC3 is a version of LSTPROC that works on JES3.  PROC's are\naccessed differently in JES3 than they are in JES2.\nFor more info on LSTPROC3, see member LSTPROC#.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPROC#": {"ttr": 22529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x16\\x11\\x0f\\x01\\x162\\x1f\\x100\\x00\\x18\\x00\\x1a\\x00\\x00\\xd3\\xe2\\xe3\\xd7\\xd9\\xd6\\xc3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-04-19T00:00:00", "modifydate": "2016-11-16T10:30:19", "lines": 24, "newlines": 26, "modlines": 0, "user": "LSTPROC"}, "text": "Subject:  new lstproc for jes3\nFrom:     lionel.dyck@va.gov\nDate:     4/18/2016 8:42 AM\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHere is a version of LSTPROC that works with JES3.  I could have\nmade it by-JES but decided to have a separate one.\n\nLSTPROC3 dynamically determines the system level PARMLIBs, PROCLIBs,\nand JES3 Disk Reader datasets. Allocated them to $... DD's and then\ninvokes ISRDDN with the parm of ONLY $* to just display those DD's.\nUpon return from ISRDDN the DD's are released.  The PROCLIB's and\nDisk Readers are determined by looking in the JES3 initialization\ndeck.\n\nCheers my friend\n\n\n--------------------------------------------------------------\nLionel B. Dyck\nMainframe Systems Programmer\nEnterprise Infrastructure Support (Station 200) (005OP6.3.10)\nVA OI&T Service Delivery & Engineering\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPROC@": {"ttr": 22531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x00)\\x9f\\x01\\x00)\\x9f\\x106\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-10-25T00:00:00", "modifydate": "2000-10-25T10:36:16", "lines": 29, "newlines": 29, "modlines": 0, "user": "WSBG"}, "text": "Subject: Updated LSTPROC exec\nDate: 23 Oct 2000 07:59:12 -0700\nFrom: Lionel B Dyck <Lionel.B.Dyck@kp.org>\n\nHere is an update to the LSTPROC rexx code to dynamically pick\nup the sysx.iplparm dsname.\n\nEnjoy\n\nThis update is thanks to Philippe Richard of IBM France\n\n--------------------------------------------------------------------------------\nLionel B. Dyck, Systems Software Lead\nKaiser Permanente Information Technology\n25 N. Via Monte Ave\nWalnut Creek, Ca 94598\n\nPhone:   (925) 926-5332\nFax:        (925) 926-5292\n\nE-Mail:    Lionel.B.Dyck@kp.org\nSametime: (use Lotus Notes address)\nAIM:        lbdyck\n\n  --------------------------------------------------------------------\n                     Name: lstproc.txt\n   lstproc.txt       Type: Plain Text (text/plain)\n                 Encoding: base64\n              Description: lstproc.txt\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LSTPROCO": {"ttr": 22533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\x02#\\x1f\\x01\\x02#\\x1f\\x10V\\x01v\\x01u\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-08-19T00:00:00", "modifydate": "2002-08-19T10:56:47", "lines": 374, "newlines": 373, "modlines": 0, "user": "SYSLBD"}, "text": "        /* --------------------  rexx procedure  -------------------- *\n         * Name:      lstproc                                         *\n         *                                                            *\n         * Function:  Display active JES2 proclib's                   *\n         *                                                            *\n         * Syntax:    %lstproc proc                                   *\n         *                                                            *\n         *            Where proc is the name of the JES2 proc or      *\n         *            blank to default to JES2.                       *\n         *                                                            *\n         * Assumptions and Caveats:                                   *\n         *            1. if proc not specified then use JES2          *\n         *            2. only //PROCxx will be looked at              *\n         *            3. comments will be ignored                     *\n         *            4. symbolics are supported (mostly)             *\n         *            5. system symbolics are supported               *\n         *            6. only cataloged datasets are supported        *\n         *            7. JES2 Dynalloc procs are not supported        *\n         *            8. nested symbolics may not work                *\n         *            9. if the mstrjcl or jes2 proc changes that     *\n         *               is what you will see reflected               *\n         *           10. This does NOT report the actual proc usage   *\n         *               but what is found from mstrjcl and the       *\n         *               jes2 proc.                                   *\n         *           11. *IMPORTANT* It is assumed you have RACF      *\n         *               read for the LISTDATA IDCAMS command.        *\n         *               If not find *LISTDATA* and make the          *\n         *               noted changes.  You will then be limited     *\n         *               to the cataloged iplparm dataset.            *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Kaiser Permanente Information Technology        *\n         *            Walnut Creek, CA 94598                          *\n         *            (925) 926-5332                                  *\n         *            Internet: lionel.b.dyck@kp.org                  *\n         *                                                            *\n         * History:                                                   *\n         *            08/18/02 - pass ONLY #PROC to ISRDDN            *\n         *                       and bypass former ispf msg           *\n         *            08/15/01 - support INCLUDE in the Proc          *\n         *            04/25/01 - fix from Iam Ramage to correctly     *\n         *                       find the parmlib volser.             *\n         *                       ian.ramage@rs-components.com         *\n         *            02/21/01 - fix if proc symbol has quotes        *\n         *            10/24/00 - update to get iplparm vol dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *            10/23/00 - update to get iplparm dsn dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *            06/20/00 - general release                      *\n         *                     - Change dd's to #PROCMST & #PROCnn    *\n         *            06/15/00 - minor clean up                       *\n         *            06/14/00 - various changes                      *\n         *                     - add code to dynamically find mstjclxx*\n         *                       from Todd Burrell (zpn6@cdc.gov)     *\n         *            06/13/00 - creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- */\n\n        arg options\n\n        /* ----------------------------------------------------- *\n         * Setup defaults                                        *\n         * ----------------------------------------------------- */\n        parse value \"\" with null ddn test mstrjcl proclibs,\n                            proc syms procs parmlibs\n        ddn = \"JCL\"random(9999)\n\n        /* ----------------------------------------------------- *\n         * test options and use for procname or use JES2         *\n         * ----------------------------------------------------- */\n        if options = null then jes2 = \"JES2\"\n                          else jes2 = options\n\n        /* ----------------------------------------------------- *\n         * Code from Todd Burrell to get mstjcl info             *\n         * Enhanced by Ian Ramage                                *\n         * ----------------------------------------------------- */\n        CVT=STORAGE('10',4)\n        CVTECVT=STORAGE(D2X(C2D(CVT)+140),4)\n        /* GET THE IPL LOADPARMS */\n        LOADPARM=STORAGE(D2X(C2D(CVTECVT)+168),8)\n        /* address of IHAIPA control block */\n        CVTIPA=STORAGE(D2X(C2D(CVTECVT)+392),4)\n        /* mstjcl section in IPA */\n        MJC=STORAGE(D2X(C2D(CVTIPA)+2448),4)\n        /* mstjcl section in IPA length */\n        MJCLEN=C2D(STORAGE(D2X(C2D(CVTIPA)+2452),2))\n        /* ieasys source in mstjclxx */\n        MJCSYS=STORAGE(D2X(C2D(CVTIPA)+2454),2)\n        /* mstjcl xx value */\n        MJCXX=STORAGE(D2X(C2D(MJC)+0),MJCLEN)\n        if left(mjcxx,1) = \"(\" then\n            parse value mjcxx with \"(\" mjcxx \")\" .\n\n         /* address of IHAIPA control block */\n         IPLPARM  = Strip(LOADPARM)\n         LOADADR  = Substr(IPLPARM,1,4)\n\n        /* mstjcl section in IPA */\n        ipalpar  = storage(d2x(c2d(cvtipa)+32), 8)\n        ipalpdsn = storage(d2x(c2d(cvtipa)+48),44)\n        parmaddr = storage(d2x(c2d(cvtipa)+92), 4)\n        LOADVOL  = chk_volser(parmaddr)\n        lparm = \"'\"strip(IPALPDSN)\"(load\"substr(loadparm,5,2)\")'\"\n\n        /* ----------------------------------------------------- *\n         * Read loadparm member to find parmlibs                 *\n         * ----------------------------------------------------- */\n         if loadvol <> null then\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse volume(\"LOADVOL\")\",\n               \"unit(sysallda)\"\n         else\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse\"\n         \"Execio * diskr\" ddn \"(finis stem in.\"\n         \"Free  f(\"ddn\")\"\n         LPAR = true\n         do i = 1 to in.0\n            if word(in.i,1) = \"LPARNAME\" then\n               if word(in.i,2) = ipalpar then LPAR = true\n                                         else LPAR = false\n            if word(in.i,1) = \"PARMLIB\" & LPAR = true then\n               parmlibs = parmlibs word(in.i,2)\n            end\n        if parmlibs = \"\" then parmlibs = \"SYS1.PARMLIB\"\n\n        /* ----------------------------------------------------- *\n         * Find PARMLIB with MSTJCLxx                            *\n         * ----------------------------------------------------- */\n         do i = 1 to words(parmlibs)\n            mstrjcl = \"'\"strip(word(parmlibs,i))\"(MSTJCL\"mjcxx\")'\"\n            if \"OK\" = sysdsn(mstrjcl) then leave\n            end\n\n        /* ----------------------------------------------------- *\n         * Alloc and read master jcl parmlib member              *\n         * ----------------------------------------------------- */\n        if \"OK\" <> sysdsn(mstrjcl) then do\n           in.0 = 1\n           in.1 = \"//IEFPDSI DSN=SYS1.PROCLIB  \"\n           end\n        else do\n             \"Alloc f(\"ddn\") ds(\"mstrjcl\") shr reuse\"\n             \"Execio * diskr\" ddn \"(finis stem in.\"\n             \"Free  f(\"ddn\")\"\n             end\n\n        /* ----------------------------------------------------- *\n         * Find all proclibs in IEFPDSI and save them            *\n         * Updates by ian.ramage@rs-components.com               *\n         * ----------------------------------------------------- */\n        hit = 0\n        do i = 1 to in.0\n          in.i  = TRANSLATE(in.i,\" \",\",\")\n           if hit = 1 then do\n              if substr(in.i,3,1) = \" \"\n                 then do\n                      parse value in.i with . \"DSN=\" dsn \" \" .\n                      proclibs = proclibs dsn\n                      end\n                 else hit = 0\n              end\n           if left(in.i,9) = \"//IEFPDSI\" then do\n              hit = 1\n              parse value in.i with . \"DSN=\" dsn \" \" .\n              proclibs = proclibs dsn\n              end\n           end\n\n        /* ----------------------------------------------------- *\n         * Alloc all Master JCL Proclib's to DD: #PROCMST        *\n         * ----------------------------------------------------- */\n        alloc_procs = null\n        do i = 1 to words(proclibs)\n           proc  = \"'\"word(proclibs,i)\"'\"\n           alloc_procs = alloc_procs proc\n           end\n        \"Alloc f(#PROCMST) ds(\"alloc_procs\") shr reuse\"\n\n        /* ----------------------------------------------------- *\n         * Now look thru Master JCL Proclibs for JES2 Proc       *\n         * ----------------------------------------------------- */\n         call find_lib\n\n        /* ----------------------------------------------------- *\n         * Now find all //PROCxx and save proc names             *\n         * ----------------------------------------------------- */\n         Start:\n         procs = null\n         hit = 0\n         sym = \"sym\"\n         proc = \"proc\"\n         do i = 1 to in.0\n            if word(in.i,2) = \"INCLUDE\" then do\n               parse value in.i with . \"MEMBER=\"jes2 .\n               in.i = \"//******** replaced \"\n               if pos(\"&\",jes2) > 0 then do\n                  parse value jes2 with left\"&\"symbol\n                  syssym = mvsvar('symdef',symbol)\n                  if syssym <> null then do\n                     jes2 = left\"\"syssym\n                     end\n                  end\n               call find_lib\n               signal start\n               end\n            if left(in.i,3) = \"//*\" then iterate\n            If hit = 1 then do\n               if substr(in.i,3,1) >= \"A\" then hit = 3\n               end\n            If pos(\" PROC \",in.i) > 0 then hit = 1\n            if hit = 3 then\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) = 6 then\n                      hit = 4\n                  end\n            if hit = 4 then do\n               if left(in.i,6) <> \"//PROC\" then\n                  if substr(in.i,3,1) >= \"A\" then hit = 3\n               if left(in.i,6) = \"//PROC\" then do\n                  parse value in.i with \"//\" w1 .\n                  if length(w1) > 6 then hit = 3\n                  end\n               if hit = 3 then iterate\n               if left(in.i,6) = \"//PROC\" then do\n                  nn = substr(in.i,7,2)\n                  proc.nn = null\n                  procs = procs nn\n                  end\n               parse value in.i with . \"DSN=\" dsn \",\"\n               dsn = word(strip(dsn),1)\n               if pos(\"&\",dsn) > 0 then call fix_sym\n               if dsn <> null then do\n                  if left(dsn,1) <> \"'\" then\n                     dsn = \"'\"dsn\"'\"\n                  proc.nn = proc.nn dsn\n                  end\n               end\n            If hit = 1 then do\n               If pos(\" PROC \",in.i) > 0\n                  then test = word(in.i,3)\n                  else test = word(in.i,2)\n               test = translate(test,\" \",\",\")\n               if words(test) > 1 then\n                 do j = 1 to words(test)\n                    parse value word(test,j) with symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                 end\n               else do\n                    parse value test with  symb \"=\" dsn \",\"\n                    sym.symb = strip(dsn)\n                    syms = syms symb\n                    end\n               end\n            if hit >1 then iterate\n            end\n\n        /* ----------------------------------------------------- *\n         * Now alloc DD: #PROCxx                                 *\n         * ----------------------------------------------------- */\n           alloc_procs = null\n           do i = 1 to words(procs)\n              if alloc_procs <> null then\n                 \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                    \"shr reuse\"\n              nn = word(procs,i)\n              alloc_procs = null\n              do j = 1 to words(proc.nn)\n                 pr = word(proc.nn,j)\n                 alloc_procs = alloc_procs pr\n                 end\n              end\n           if alloc_procs <> null then\n              \"Alloc f(#PROC\"nn\") ds(\"alloc_procs\")\",\n                 \"shr reuse\"\n\n        /* ----------------------------------------------------- *\n         * Now invoke ISRDDN to display allocations              *\n         * ----------------------------------------------------- */\n           Address ISPExec\n           lev = mvsvar('sysmvs')\n           lev = substr(lev,3,1)\n           if lev < 6 then do\n              zedsmsg = null\n              zedlmsg = \"System and JES2 Proclib's\",\n                        \"have been identified and allocated\",\n                        \"using #PROCMST for the Master JCL\",\n                        \"Proclibs and #PROCxx for the JES2\",\n                        \"Proclibs.               \",\n                        \"Issue ONLY #PROC\",\n                        \"to display only DD's with PROC in the\",\n                        \"ddname.\"\n              \"Setmsg msg(isrz001)\"\n              \"Select cmd(isrddn)\"\n              end\n           else do\n                zopt = \"Only #PROC\"\n                \"Select cmd(isrddn\" zopt\")\"\n                end\n\n          /* -------------------------- *\n           * Now free all allocations   *\n           * -------------------------- */\n           Address TSO\n           \"Free f(#PROCMST)\"\n           do i = 1 to words(procs)\n              \"Free f(#PROC\"word(procs,i)\n              end\n           Exit 0\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in the dsname                        *\n         * ----------------------------------------------------- */\n           Fix_Sym: procedure expose dsn syms sym. null\n           do forever\n              parse value dsn with left \"&\" symbol \".\" right\n              syssym = mvsvar('symdef',symbol)\n              if syssym <> null then do\n                 dsn = left\"\"syssym\"\"right\n                 end\n              else do\n                 if wordpos(symbol,syms) = 0 then leave\n                 wp   = wordpos(symbol,syms)\n                 symb = word(syms,wp)\n                 hlq  = sym.symb\n                 if left(hlq,1) = \"'\" then\n                    parse value hlq with \"'\" hlq \"'\"\n                 dsn  = left\"\"hlq\"\"right\n                 end\n              if pos(\"&\",dsn) = 0 then leave\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix volser for IPLPARM volume                         *\n         * ----------------------------------------------------- */\n           chk_volser: procedure\n           parse arg unitnbr\n           stat. = \"\"\n           dumy = outtrap(\"stat.\")\n               \"LISTDATA STATUS UNITNUMBER(\"strip(UNITNBR)\")\"\n                 parse var stat.3   'VOLUME' volser 'DEVICE' .\n           dumy = outtrap(\"off\")\n           return strip(volser)\n\n        /* --------------------------------------------------------- *\n         * Find Library for Proc                                     *\n         * --------------------------------------------------------- */\n         find_lib:\n         do i = 1 to words(proclibs)\n            proc  = \"'\"word(proclibs,i)\"(\"jes2\")'\"\n            if \"OK\" = sysdsn(proc) then leave\n            end\n\n        /* --------------------------------------------------------- *\n         * Read in the JES2 Proc                                     *\n         * --------------------------------------------------------- */\n        \"Alloc f(\"ddn\") ds(\"proc\") shr reuse\"\n        \"Execio * diskr\" ddn \"(finis stem prc.\"\n        \"Free  f(\"ddn\")\"\n        if in.0 = 0 then\n           do i = 0 to prc.0\n              in.i = prc.i\n              end\n        else do\n             c = in.0\n             do i = 1 to prc.0\n                c = c + 1\n                in.c = prc.i\n                end\n              in.0 = c\n              end\n        return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSTPROC3": {"ttr": 22540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x03\\x04\\x00Q\\x01\\x16\\x14_\\x01\\x18'\\x0f\\x14$\\x03,\\x03%\\x00\\x00\\xc6\\xd6\\xd9\\xd1\\xc5\\xe2\\xf3@@@\"", "ispf": {"version": "03.04", "flags": 0, "createdate": "2016-05-24T00:00:00", "modifydate": "2018-09-27T14:24:51", "lines": 812, "newlines": 805, "modlines": 0, "user": "FORJES3"}, "text": "        /* --------------------  rexx procedure  -------------------- */\n         _version_ = \"3.4\"\n        /* Name:      lstproc3                                        *\n         *                                                            *\n         * Function:  Display active z/OS and JES3 Proclibs           *\n         *                           System Parmlib                   *\n         *                           JES3 Disk Reader                 *\n         *                           JES3 PARMLIB (initdeck)          *\n         *                                                            *\n         * Syntax:    %lstproc3 proc /S                               *\n         *                                                            *\n         *            Where proc is the name of the JES3 proc or      *\n         *            blank to default to JES3.                       *\n         *                                                            *\n         *            /S is optional and if used will cause           *\n         *            the JES3 Disk Reader, Initdeck, and System      *\n         *            Parmlibs to be displayed                        *\n         *                                                            *\n         * Assumptions and Caveats:                                   *\n         *            1. if proc not specified then use JES3          *\n         *            2. only DYNALLOC for IATPLBxx in the initdeck   *\n         *               will be used along with the MSTJCLxx Procs   *\n         *            3. comments will be ignored                     *\n         *            4. symbolics are supported (mostly)             *\n         *            5. system symbolics are supported               *\n         *            6. only cataloged datasets are supported        *\n         *            7. nested symbolics may not work                *\n         *            8. if the mstrjcl or jes3 proc changes that     *\n         *               is what you will see reflected               *\n         *            9. This does NOT report the actual proc usage   *\n         *               but what is found from mstrjcl and the       *\n         *               jes3 proc.                                   *\n         *           10. *IMPORTANT* It is assumed you have RACF      *\n         *               read for the LISTDATA IDCAMS command.        *\n         *               If not find *LISTDATA* and make the          *\n         *               noted changes.  You will then be limited     *\n         *               to the cataloged iplparm dataset.            *\n         *           11. System Parmlib's will be allocated to        *\n         *               $PARMLIB                                     *\n         *           12. JES3 Disk Reader ($J3DRDS) will be allocated*\n         *               to $J3DRDS                                   *\n         *                                                            *\n         * Author:    Lionel B. Dyck                                  *\n         *            Internet: lbdyck@gmail.com                      *\n         *                                                            *\n         * History:                                                   *\n         *                                                            *\n         *          2018-09-27 - Allow VOL/UNIT on DYNALLOC statements*\n         *          2017-02-06 - Set null variable                    *\n         *                     - strip initdeck to remove blanks      *\n         *          2016-05-24 - Add /S option                        *\n         *          2016-05-22 - Add JES3 Parmlib                     *\n         *          2016-04-14 - Support JES3 Disk Reader JES3DRDS    *\n         *          2016-03-30 - Rewrite for JES3                     *\n         *                     - remove callability as function       *\n         *                     - always allocate $PARMLIB             *\n         *          2014-01-31 - Don't alloc/open/read the iplparm    *\n         *                       if it can't be found                 *\n         *          2009-07-08 - Change # to $ (thx hartmut)          *\n         *          2009-07-08 - MSG(\"OFF\") in FREE routine           *\n         *                     - use _junk_ instead of RC             *\n         *          2009-05-11 - Check whether proclib member exists  *\n         *                       SYS1.PROCLIB(JES3) default may fail. *\n         *          2008-11-05 - Correction in handling symbols       *\n         *                       custplex and lpar                    *\n         *          2008-10-15 - Info about old sysmvs                *\n         *                     - Note:                                *\n         *                       LISTDATA/LDATA in AUTHCMD in IKJTSO00*\n         *                     - substitute vars  left  and  right    *\n         *                               by vars _left_ and _right_   *\n         *          2007-10-16 - If not under ISPF just write         *\n         *                       dd and dsnames to screen             *\n         *          2007-02-20 - Correction from Ian Ramage           *\n         *                       Fix if JES3 Proc in >2 proclib       *\n         *          2006-11-27 - Hartmut Beckmann                     *\n         *                       Changes for better member support    *\n         *          2006-09-25 - Peggy Norton                         *\n         *                       Fix call to subroutine for symbolics *\n         *          2006-05-17 - Jeff Dixon                           *\n         *                       Support //PROCxxxx instead of PROCxx *\n         *          2006-05-11 - Peggy Norton                         *\n         *                       Fix if LOADxx does not have defined  *\n         *                       SYS1.PARMLIB                         *\n         *          2006-01-26 - Ian Ramage                           *\n         *                       Add Numeric Digits 10 to resolve     *\n         *                       issue under z/OS 1.6                 *\n         *          2003-09-02 - John Bloniarz                        *\n         *                       McDonald's Corporation               *\n         *                       630-623-3224                         *\n         *                       john.bloniarz@mcd.com                *\n         *                                                            *\n         *                       make callable as a function from     *\n         *                       REXX to allocate system Parmlibs,    *\n         *                       system Proclibs and/or PROCxx's.     *\n         *                       Changed DD name $PROCMST to          *\n         *                       $PROCLIB when called as a function.  *\n         *                                                            *\n         *          2003-08-28 - John Bloniarz                        *\n         *                       McDonald's Corporation               *\n         *                       630-623-3224                         *\n         *                       john.bloniarz@mcd.com                *\n         *                                                            *\n         *                       add code to resolve all system       *\n         *                       symbols before allocation.           *\n         *                                                            *\n         *          2002-08-19 - correct to work with OS/390 below    *\n         *                       2.10 (broke on 8/18 change)          *\n         *          2002-08-18 - pass ONLY $PROC to ISRDDN            *\n         *                       and bypass former ispf msg           *\n         *          2001-08-15 - support INCLUDE in the Proc          *\n         *          2001-04-25 - fix from Iam Ramage to correctly     *\n         *                       find the parmlib volser.             *\n         *                       ian.ramage@rs-components.com         *\n         *          2001-02-21 - fix if proc symbol has quotes        *\n         *          2000-10-24 - update to get iplparm vol dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *          2000-10-23 - update to get iplparm dsn dyn        *\n         *                       thx to Philippe Richard of IBM       *\n         *          2000-06-20 - general release                      *\n         *                     - Change dds to $PROCMST & $PROCnn     *\n         *          2000-06-15 - minor clean up                       *\n         *          2000-06-14 - various changes                      *\n         *                     - add code to dynamically find mstjclxx*\n         *                       from Todd Burrell (zpn6@cdc.gov)     *\n         *          2000-06-13 - creation                             *\n         *                                                            *\n         * ---------------------------------------------------------- *\n         *                                                            *\n         * ---------------------------------------------------------- */\n         signal on novalue name sub_novalue\n        /* ----------------------------------------------------- *\n         * Setup defaults in sub routine                         *\n         * ----------------------------------------------------- */\n         _x_ = sub_init() ;\n\n        /* ---------------------------------------------- *\n         * Check for any passed options.                  *\n         *                                                *\n         * The two supported options are:                 *\n         *                                                *\n         * 1) the name of the JES3 Proc (default is JES3) *\n         * 2) /S to display system datasets               *\n         *    - parmlibs                                  *\n         *    - jes3 initdeck                             *\n         *    - jes3 disk reader                          *\n         * ---------------------------------------------- */\n         arg options\n\n        /* --------------- *\n         * Define defaults *\n         * --------------- */\n         ddn = \"JCL\"random(9999)\n         Numeric Digits 10\n         sopt = 0\n         null = ''\n\n        /* ------------ *\n         * Check for /S *\n         * ------------ */\n         if pos('/S',options) > 0 then do\n            sopt = 1\n            p = pos('/S',options)\n            if p = 1 then options = substr(options,3)\n            else do\n                 options = left(options,p-1)''substr(options,p+2)\n                 end\n            options = strip(options)\n            end\n\n        /* ----------------------------------------------------- *\n         * test options and use for procname or use JES3         *\n         * ----------------------------------------------------- */\n        if substr(options,1,1) = \".\" then do\n           parse value options with \".\" lstprocm .\n           options = null\n        end\n        if words(options) > 1 then do\n           parse value options with opt1 \" \" opt2 \" \" opt3 \" \" opt4\n           if opt1 = \"*\" then do\n              options = null\n              end\n            else do\n              options = opt1\n              end\n           end\n         else do\n           if options = \"*\" then do\n              options = null\n              end\n           end\n        if options = null then JES3 = \"JES3\"\n                          else JES3 = options\n        isfunc = \"N\"\n        allocdd = null\n        retstr  = null\n\n        /* ----------------------------- *\n         * Test for ISPF and if not then *\n         * set flag to only echo Parmlib *\n         * info to the \"screen\".         *\n         * ----------------------------- */\n         sysispf = sysvar(\"sysispf\")\n         if sysispf = \"ACTIVE\" then ispf = 1\n                               else do\n                                    ispf = 0\n                                    isfunc = \"F\"\n                                    end\n        /* ----------------------------------------------------- *\n         * Code from Todd Burrell to get mstjcl info             *\n         * Enhanced by Ian Ramage                                *\n         * ----------------------------------------------------- */\n        CVT=STORAGE(\"10\",4)\n        CVTECVT=STORAGE(D2X(C2D(CVT)+140),4)\n        /* GET THE IPL LOADPARMS */\n        LOADPARM=STORAGE(D2X(C2D(CVTECVT)+168),8)\n        /* address of IHAIPA control block */\n        CVTIPA=STORAGE(D2X(C2D(CVTECVT)+392),4)\n        /* mstjcl section in IPA */\n        MJC=STORAGE(D2X(C2D(CVTIPA)+2448),4)\n        /* mstjcl section in IPA length */\n        MJCLEN=C2D(STORAGE(D2X(C2D(CVTIPA)+2452),2))\n        /* ieasys source in mstjclxx */\n        MJCSYS=STORAGE(D2X(C2D(CVTIPA)+2454),2)\n        /* mstjcl xx value */\n        MJCXX=STORAGE(D2X(C2D(MJC)+0),MJCLEN)\n        if left(mjcxx,1) = \"(\" then\n            parse value mjcxx with \"(\" mjcxx \")\" .\n\n         /* address of IHAIPA control block */\n         IPLPARM  = Strip(LOADPARM)\n         LOADADR  = Substr(IPLPARM,1,4)\n\n        /* mstjcl section in IPA */\n        ipalpar  = storage(d2x(c2d(cvtipa)+32), 8)\n        ipalpdsn = storage(d2x(c2d(cvtipa)+48),44)\n        parmaddr = storage(d2x(c2d(cvtipa)+92), 4)\n\n         /* *LOADDATA* - Important information   *\n          *  if you don't have RACF Read for the *\n          *  LISTDATA IDCAMS command then set    *\n          *  LOADVOL = \"\"                        */\n        loadvol  = null\n        LOADVOL  = chk_volser(parmaddr)\n        lparm = \"\"strip(IPALPDSN)\"(load\"substr(loadparm,5,2)\")\"\n        lparm = \"\"_apost_\"\"lparm\"\"_apost_\"\"\n\n        /* ----------------------------------------------------- *\n         * Read loadparm member to find parmlibs                 *\n         * ----------------------------------------------------- */\n         if loadvol <> null then do\n            \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse volume(\"LOADVOL\")\",\n               \"unit(sysallda)\"\n            \"Execio * diskr\" ddn \"(finis stem in.\"\n            'Free f('ddn')'\n            end\n         else do\n            if sysdsn(lparm) = 'OK' then do\n               \"Alloc f(\"ddn\") ds(\"lparm\") shr reuse\"\n               \"Execio * diskr\" ddn \"(finis stem in.\"\n               'Free f('ddn')'\n               end\n               else do\n                    in.0 = 0\n                    rc   = 4\n                    end\n            end\n         rcode = rc\n         _LPAR_ = \"true\"\n         do i = 1 to in.0\n            if word(in.i,1) = \"LPARNAME\" then\n               if word(in.i,2) = ipalpar then _LPAR_ = \"true\"\n                                         else _LPAR_ = \"false\"\n            if word(in.i,1) = \"PARMLIB\" & _LPAR_ = \"true\" then\n               parmlibs = parmlibs word(in.i,2)\n            end\n        if parmlibs = null then parmlibs = \"SYS1.PARMLIB\"\n        if wordpos(\"SYS1.PARMLIB\",parmlibs) = 0 then     /* PN */\n           parmlibs = parmlibs\" SYS1.PARMLIB\"            /* PN */\n\n        /* ----------------------------------------------------- *\n         * Alloc all Parmlibs to DD: $PARMLIB (If Appropriate)   *\n         * ----------------------------------------------------- */\n               alloc_parms = null\n               do i = 1 to words(parmlibs)\n                  parm  = \"\"_apost_\"\"word(parmlibs,i)\"\"_apost_\"\"\n                  alloc_parms = alloc_parms parm\n                  end\n               if pos(\"&\",alloc_parms) > 0 then do\n                  symtext = alloc_parms\n                  call fix_sym1\n                  alloc_parms = symtext\n                  end\n               _junk_ = msg(\"OFF\")\n               \"Free  f($PARMLIB)\"\n               _junk_ = msg(\"ON\")\n               \"Alloc f($PARMLIB) ds(\"alloc_parms\") shr reuse\"\n               retstr = strip(retstr \"$PARMLIB\")\n\n        /* ----------------------------------------------------- *\n         * Find PARMLIB with MSTJCLxx                            *\n         * ----------------------------------------------------- */\n         do i = 1 to words(parmlibs)\n            mstrjcl = \"\"strip(word(parmlibs,i))\"(MSTJCL\"mjcxx\")\"\n            mstrjcl = \"\"_apost_\"\"mstrjcl\"\"_apost_\"\"\n            if \"OK\" = sysdsn(mstrjcl) then leave\n            end\n\n        /* ----------------------------------------------------- *\n         * Alloc and read master jcl parmlib member              *\n         * ----------------------------------------------------- */\n        if \"OK\" <> sysdsn(mstrjcl) then do\n           in.0 = 1\n           in.1 = \"//IEFPDSI DSN=SYS1.PROCLIB  \"\n           end\n        else do\n             if pos(\"&\",mstrjcl) > 0 then do\n                symtext = mstrjcl\n                call fix_sym1\n                mstrjcl = symtext\n                end\n             \"Alloc f(\"ddn\") ds(\"mstrjcl\") shr reuse\"\n             \"Execio * diskr\" ddn \"(finis stem in.\"\n             rcode = rc\n             \"Free  f(\"ddn\")\"\n             end\n\n        /* ----------------------------------------------------- *\n         * Find all proclibs in IEFPDSI and save them            *\n         * Updates by ian.ramage@rs-components.com               *\n         * ----------------------------------------------------- */\n        hit = 0\n        do i = 1 to in.0\n          in.i  = TRANSLATE(in.i,\" \",\",\")\n           if hit = 1 then do\n              call fix_sym\n              if substr(in.i,3,1) = \" \"\n                 then do\n                      parse value in.i with . \"DSN=\" dsn \" \" .\n                      proclibs = proclibs dsn\n                      end\n                 else hit = 0\n              end\n           if left(in.i,9) = \"//IEFPDSI\" then do\n              hit = 1\n              parse value in.i with . \"DSN=\" dsn \" \" .\n              dsn = word(strip(dsn),1)                  /* @pn */\n              if pos(\"&\",dsn) > 0 then call fix_sym     /* @pn */\n              proclibs = proclibs dsn\n              end\n           end\n\n        /* ----------------------------------------------------- *\n         * Alloc all Master JCL Proclibs to DD: $PROCMST         *\n         * (or DD: $PROCLIB if called as a function)             *\n         * ----------------------------------------------------- */\n        alloc_procs = null\n        do i = 1 to words(proclibs)\n           proc  = \"\"_apost_\"\"word(proclibs,i)\"\"_apost_\"\"\n           alloc_procs = alloc_procs proc\n           end\n        if pos(\"&\",alloc_procs) > 0 then do\n           symtext = alloc_procs\n           call fix_sym1\n           alloc_procs = symtext\n           end\n        procddn = \"$PROCMST\"\n        _junk_ = msg(\"OFF\")\n        \"Free  f(\"procddn\")\"\n        _junk_ = msg(\"ON\")\n        if ispf = 1\n           then \"Alloc f(\"procddn\") ds(\"alloc_procs\") shr reuse\"\n           else call echo procddn alloc_procs\n\n        /* ----------------------------------------------------- *\n         * Now look thru Master JCL Proclibs for JES3 Proc       *\n         * ----------------------------------------------------- */\n         in.0 = 0\n         call find_lib\n\n        /* ----------------------------------------------------- *\n         * Now the JES3IN DD and read in the initdeck            *\n         * ----------------------------------------------------- */\n         Start:\n         hit = 0\n         sym = \"sym\"\n         initdeck = null\n         do i = 1 to in.0\n            if left(in.i,8) = \"//JES3IN\" then hit = 1\n            if hit = 1 then do\n               if pos(\"DSN=\",in.i) > 0 then do\n                  parse value in.i with . 'DSN='initdeck',' .\n                  initdeck = strip(initdeck)\n                  hit = 2\n                  end\n            if hit = 2 then leave\n            end\n            end\n\n        /* ----------------------------------------- *\n         * Now find all IATPLBxx DYNALLOC statements *\n         * ----------------------------------------- */\n         drop in.\n         \"Alloc f(\"ddn\") ds('\"initdeck\"') shr reuse\"\n         \"Execio * diskr\" ddn \"(finis stem in.\"\n         \"Free  f(\"ddn\")\"\n         proc = \"proc\"\n         proc. = null\n         procs = null\n         do i = 1 to in.0\n            if left(in.i,1) = '*' then iterate\n            if left(in.i,8) = 'DYNALLOC' then\n               pddn = null\n               parse value in.i with 'DYNALLOC,DDN='pddn',DSN='pdsn .\n               if pos(',',pdsn) > 0 then parse value pdsn with pdsn','\n               if left(pddn,6) = 'IATPLB' then do\n               pn = right(pddn,2)\n               if pos(pn,procs) = 0 then\n                  procs = procs pn\n               proc.pn = proc.pn \"'\"pdsn\"'\"\n               end\n            end\n         rdrs  = null\n         do i = 1 to in.0\n            if left(in.i,1) = '*' then iterate\n            if left(in.i,8) = 'DYNALLOC' then\n               pddn = null\n               parse value in.i with 'DYNALLOC,DDN='pddn',DSN='pdsn .\n               if pos(',',pdsn) > 0 then parse value pdsn with pdsn','\n               if left(pddn,8) = 'JES3DRDS' then do\n                  rdrs = rdrs \"'\"pdsn\"'\"\n                  end\n            end\n\n        /* ----------------------------------------------------- *\n         * Now alloc DD: $PROCxx, $J3DRDS, and $J3INIT           *\n         * ----------------------------------------------------- */\n\n        /* ----------------------------------------------------- *\n         * CALL STEMVIEW \"VIEW\",in.,,,\"Debugging mode: STEM IN.\" *\n         * ----------------------------------------------------- */\n           alloc_procs = null\n           do i = 1 to words(procs)\n              if alloc_procs <> null then do\n                 if pos(\"&\",alloc_procs) > 0 then do\n                    symtext = alloc_procs\n                    call fix_sym1\n                    alloc_procs = symtext\n                    end\n                 _junk_ = msg(\"OFF\")\n                 \"Free  f($PROC\"nn\")\"\n                 _junk_ = msg(\"ON\")\n                 if ispf = 1\n                 then \"Alloc f($PROC\"nn\") ds(\"alloc_procs\")\",\n                    \"shr reuse\"\n                 else call echo \"$PROC\"nn alloc_procs\n                 end\n              nn = word(procs,i)\n              alloc_procs = null\n              do j = 1 to words(proc.nn)\n                 pr = word(proc.nn,j)\n                 alloc_procs = alloc_procs pr\n                 end\n              end\n           if alloc_procs <> null then do\n              if pos(\"&\",alloc_procs) > 0 then do\n                 symtext = alloc_procs\n                 call fix_sym1\n                 alloc_procs = symtext\n                 end\n              _junk_ = msg(\"OFF\")\n              \"Free  f($PROC\"nn\" $J3DRDS $J3INIT)\"\n              _junk_ = msg(\"ON\")\n              if ispf = 1 then do\n                   \"Alloc f($PROC\"nn\") ds(\"alloc_procs\")\",\n                    \"shr reuse\"\n                   \"Alloc f($J3DRDS) ds(\"rdrs\")\",\n                    \"shr reuse\"\n                     parse value initdeck with initdeck'('.\n                     \"Alloc f($J3INIT) ds('\"initdeck\"') shr reuse\"\n                    end\n              else do\n                   call echo \"$PROC\"nn alloc_procs\n                   call echo \"$J3DRDS\" rdrs\n                   call echo \"$J3INIT\" initdeck\n                   end\n              end\n\n        /* ----------------------------------------------------- *\n         * If not called as a function, invoke ISRDDN to display *\n         * allocations and then free DD names.  if called as a   *\n         * function, simply return the names of the allocated    *\n         * files to the caller.                                  *\n         * ----------------------------------------------------- */\n         Finish:\n           Address ISPExec\n           lev = mvsvar(\"sysmvs\")\n           lev = substr(lev,3,1)\n           if lev < 6 then do\n              zedsmsg = null\n              zedlmsg = \"System and JES3 Proclibs\",\n                        \"have been identified and allocated\",\n                        \"using $PROCMST for the Master JCL\",\n                        \"Proclibs and $PROCxx for the JES3\",\n                        \"Proclibs.               \",\n                        \"Issue ONLY $\",\n                        \"to display only DDs with PROC in the\",\n                        \"ddname.\"\n              \"Setmsg msg(isrz001)\"\n              \"Select cmd(isrddn)\"\n              end\n           else do\n                \"vget (zdel)\"\n                if sopt = 1 then zopt = 'Only $'\n                            else zopt = \"Only $P\"\n                if lstprocm /= null then do\n                   zopt = zopt\"\"zdel\"long\"zdel\" member \"lstprocm\n                end\n                \"control errors return\"\n                zmsg000l = _my_env_\"\"copies(\" \",80)\"\"_sysenv_\"\"\n                \"setmsg msg(ispz000) cond\"\n                \"Select cmd(isrddn\" zopt\")\"\n                end\n\n          /* -------------------------- *\n           * Now free all allocations   *\n           * -------------------------- */\n           if ispf = 0 then exit 0\n           _junk_ = msg(\"OFF\")\n           Address TSO\n           \"Free f($PROCMST $PARMLIB $J3DRDS $J3INIT)\"\n           do i = 1 to words(procs)\n              \"Free f($PROC\"word(procs,i)\n           end\n           _junk_ = msg(\"ON\")\n           retstr = 0\n           Exit retstr\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in the dsname                        *\n         * ----------------------------------------------------- */\n           Fix_Sym: procedure expose (global_vars) ,\n                                     dsn syms sym.\n           do forever\n              parse value dsn with _left_ \"&\" symbol \".\" _right_\n              syssym = mvsvar(\"symdef\",symbol)\n              if syssym <> null then do\n                 dsn = _left_\"\"syssym\"\"_right_\n                 end\n              else do\n                 if wordpos(symbol,syms) = 0 then leave\n                 wp   = wordpos(symbol,syms)\n                 symb = word(syms,wp)\n                 hlq  = sym.symb\n                 if left(hlq,1) = _apost_ then ,\n                    parse value hlq with (_apost_) hlq (_apost_)\n                 dsn  = _left_\"\"hlq\"\"_right_\n                 end\n              if pos(\"&\",dsn) = 0 then leave\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix up symbolics in an expression (symtext)           *\n         * ----------------------------------------------------- */\n           Fix_Sym1:\n           /* shift the symbols and their values to an array */\n           symb.0 = words(syms)\n           do i = 1 to symb.0\n                jj = word(syms,i)\n                symb.i.1 = word(syms,i)\n                symb.i.2 = sym.jj\n           end\n           fixstart = 1\n           srchdone = \"N\"\n           do until srchdone = \"Y\"\n              p1 = pos(\"&\",symtext,fixstart)\n              if p1 > 0 then do\n                 parse value symtext with _left_\"&\"fixsymb\n                 if left(fixsymb,1) = \"&\" then do\n                    p1 = p1 + 1        /* ignore \"&&\" */\n                    end\n                  else do\n                    _right_ = null\n                    symdone = \"N\"\n                    do r=1 to length(fixsymb) until symdone = \"Y\"\n                       if datatype(substr(fixsymb,r,1),\"ALPHA\") = 0 ,\n                       then do\n                          _right_ = substr(fixsymb,r)\n                          if left(_right_,1) = \".\" then do\n                             _right_ = substr(_right_,2)\n                             end\n                          fixsymb = substr(fixsymb,1,r-1)\n                          symdone = \"Y\"\n                          end\n                       end\n                    if length(fixsymb) > 0 then do\n                       syssym = null\n                       do symidx = 1 to symb.0\n                          if fixsymb = symb.symidx.1 ,\n                          then do\n                                   syssym = symb.symidx.2\n                                   leave\n                               end\n                       end\n                       if syssym = null then ,\n                          syssym = mvsvar(\"symdef\",fixsymb)\n                       if syssym <> null then do\n                          symtext = _left_\"\"syssym\"\"_right_\n                          end\n                       end\n                    end\n                 fixstart = p1 + 1\n                 if fixstart > length(symtext) then do\n                    srchdone = \"Y\"\n                    end\n                 end\n               else do\n                 srchdone = \"Y\"\n                 end\n              end\n           return\n\n        /* ----------------------------------------------------- *\n         * Fix volser for IPLPARM volume                         *\n         * ----------------------------------------------------- */\n           chk_volser: procedure expose (global_vars)\n           parse arg unitnbr\n           stat. = null\n           dumy = outtrap(\"stat.\")\n               \"LISTDATA STATUS UNITNUMBER(\"strip(UNITNBR)\")\"\n                 parse var stat.3   \"VOLUME\" volser \"DEVICE\" .\n           dumy = outtrap(\"off\")\n           return strip(volser)\n\n        /* --------------------------------------------------------- *\n         * Find Library for Proc                                     *\n         * --------------------------------------------------------- */\n         find_lib:\n         JES3_proc = null\n         do ip = 1 to words(proclibs)\n            proc  = \"\"_apost_\"\"word(proclibs,ip)\"(\"JES3\")\"_apost_\"\"\n            if pos(\"&\",proc) > 0 then do\n               symtext = proc\n               call fix_sym1\n               proc = symtext\n               end\n            if \"OK\" = sysdsn(proc) ,\n            then do;\n                     JES3_proc = proc\n                     leave\n                 end;\n            end\n\n        /* --------------------------------------------------------- *\n         * Read in the JES3 Proc                                     *\n         * --------------------------------------------------------- */\n        if JES3_proc = null ,\n        then prc.0 = 0\n        else do;\n                \"Alloc f(\"ddn\") ds(\"proc\") shr reuse\"\n                \"Execio * diskr\" ddn \"(finis stem prc.\"\n                rcode = rc\n                \"Free  f(\"ddn\")\"\n             end;\n        if in.0 = 0 then\n           do i = 0 to prc.0\n              in.i = prc.i\n              end\n        else do\n             c = in.0\n             do i = 1 to prc.0\n                c = c + 1\n                in.c = prc.i\n                end\n              in.0 = c\n              end\n        return\n\n        /* -------------------------------- *\n         * Echo to the Terminal all DSnames *\n         * -------------------------------- */\n         Echo: Procedure expose (global_vars) ,\n                                echo. _my_env_ _sysenv_\n         Parse Arg dd dsns\n         echo.0 = echo.0 + 1\n         if echo.0 = 1 ,\n         then do ;\n                   hl = 62\n                   _info_    = copies(\"=\",hl)\n                   info.1    = \"*\"left(_info_,hl)\"*\"\n                   _info_    = null\n                   _info_    = _info_\" \"_my_env_\n                   info.2    = \"*\"left(_info_,hl)\"*\"\n                   _info_    = null\n                   _info_    = _info_\" \"_sysenv_\n                   info.3    = \"*\"left(_info_,hl)\"*\"\n                   info.4    = info.1\n                   _info_    = null\n                   _info_    = _info_\"\"left(\"*DD\",10)\"\"\n                   _info_    = _info_\"\"left(\"VOLSER\",10)\"\"\n                   _info_    = _info_\"DSNAME\"\n                   info.5    = _info_\n                   _info_    = null\n                   _info_    = _info_\"\"left(\"*\"copies(\"-\",08),10)\n                   _info_    = _info_\"\"left(copies(\"-\",06),10)\n                   _info_    = _info_\"\"copies(\"-\",44)\n                   info.6    = _info_\n                   info.0    = 6\n                   do i = 1 to info.0\n                      say \"\"info.i\"\"\n                   end\n              end;\n         dsn.0 = words(dsns) ;\n         do i = 1 to dsn.0 ;\n            if i = 1 ,\n            then dsn.i.1 = dd\n            else dsn.i.1 = null\n            dsn.i.2 = word(dsns,i)\n            _rc_ = listdsi(\"\"dsn.i.2\"\")\n            if _rc_ = 0 ,\n            then     dsn.i.3 = sysvolume\n            else     dsn.i.3 = \"N/A\"\n         end\n         do i = 1 to dsn.0 ;\n             say left(dsn.i.1,10)\"\"left(dsn.i.3,10)\"\"dsn.i.2\n         end\n         return\n\n  sub_init:\n   /* to get the correct name for MSGID don't use other cmds before */\n   parse source ,\n     rexxenv rexxinv rexxname rexxdd rexxdsn . rexxenv addrspc .\n   parse value \"\" with _null_\n   myname = rexxname\n   if myname = \"?\" ,\n   then do ;\n            myname = sysvar(\"sysicmd\")\n            if length(myname) = 0 ,\n            then  myname = sysvar(\"syspcmd\")\n        end;\n   msgid = left(myname\": \",10)\n\n         parse value \"\" with null ddn test mstrjcl proclibs,\n                             proc syms procs parmlibs,\n                             opt1 opt2 opt3 opt4 lstprocm\n         _apost_ = \"'\"\n         _sysplex_ = mvsvar(\"sysplex\")\n         _sysname_ = mvsvar(\"sysname\")\n         _sysmvs_  = MVSVAR(\"SYSMVS\")\n         parse value \"\" with _more_ custname custplex LPAR KSYSENV\n         if _sysmvs_ > \"SP7.0.5\" ,\n         then do ;\n                 /* null if not defined           *\n                  *  other variables can be added */\n                 _morevars_ = \"CUSTNAME CUSTPLEX LPAR KSYSENV\"\n                 do _i_ = 1 to words(_morevars_)\n                    _morekey_ = word(_morevars_,_i_)\n                    _moreval_ = mvsvar('symdef',_morekey_)\n                    _valcmd_ = \"\"_morekey_ \"= '\"_moreval_\"' \"\n                    interpret _valcmd_\n                    select;\n                      when ( _morekey_ = \"CUSTPLEX\" ) then iterate\n                      when ( _morekey_ = \"LPAR\"     ) then iterate\n                      otherwise nop;\n                    end;\n                    if _moreval_ /= null ,\n                    then do ;\n                              _more_=\"\"_more_\"\"_morekey_\"=\"_moreval_\" \"\n                         end;\n                 end;\n              end;\n         else do ;\n                 _more_ = \"SYSMVS=\"_sysmvs_\n              end;\n         _more_ = strip(_more_)\n         _sysenv_  = null\n         if custname /= null ,\n         then _sysenv_  = \"\"_sysenv_\"\"custname\": \"\n         _sysenv_  = \"\"_sysenv_\"SYSPLEX=\"_sysplex_\" \"\n         if custplex /= null ,\n         then do;\n                 if custplex  /= _sysplex_ ,\n                 then _sysenv_ = \"\"_sysenv_\"CUSTPLEX=\"custplex\" \"\n              end;\n         if lpar = null ,\n         then lpar = _sysname_\n         if lpar       = _sysname_ ,\n         then do ;\n                  _sysenv_= \"\"_sysenv_\"LPAR/SYSNAME=\"lpar\" \"\n              end;\n         else do ;\n                  _sysenv_= \"\"_sysenv_\"SYSNAME=\"_sysname_\" LPAR=\"lpar\" \"\n              end;\n         _sysenv_  = \"\"_sysenv_\"\"_more_\n         _sysenv_  = strip(_sysenv_)\n         _my_env_  = \"\"myname\" \"_version_\"\"\n         echo.0 = 0\n         global_vars = \"null _apost_\"\n     return 0\n\n      /**************************************************************\n      * Trap uninitialized variables                                *\n      ***************************************************************/\n      sub_novalue:\n      Say \"\"\n      Say \"Variable\" ,\n         condition(\"Description\") \"undefined in line\" sigl\":\"\n      Say sourceline(sigl)\n      if sysvar(\"sysenv\") <> \"FORE\" then exit 8\n      say \"Report the error in this application along with the\",\n          \"syntax used.\"\n      exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MGEN": {"ttr": 23043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x14\\x01\\x161/\\x01\\x162\\x1f\\x101\\x00\\x18\\x00\\x1e\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2016-11-16T10:31:14", "lines": 24, "newlines": 30, "modlines": 0, "user": "SYSLBD"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      MGEN                                            *\n *                                                            *\n * Function:  Display or return the current MAXGENS_LIMIT     *\n *            which is the system max generations value       *\n *            for PDSE Version 2 libraries                    *\n *                                                            *\n * Syntax:    %MGEN                                           *\n *         or mgen=mgen()                                     *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            07/27/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n parse source source\n\n CVT      = C2D(Storage(10,4))\n CVTDFA   = C2D(Storage(D2X(CVT + 1216),4))   /* cvt + 4c0 */\n DFAMGEN  = C2D(Storage(D2X(cvtdfa + 76),4))  /* dfa + 4c */\n\n if word(source,2) = 'FUNCTION' then return dfamgen\n else  say 'Maxgen Limit:' dfamgen\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "OMVSCMD": {"ttr": 23045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x007\\x01\\x16\\x19o\\x01\\x162\\x1f\\x101\\x01\\xae\\x00\\xf5\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-07-14T00:00:00", "modifydate": "2016-11-16T10:31:37", "lines": 430, "newlines": 245, "modlines": 0, "user": "SYSLBD"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      OMVSCMD                                         *\n *                                                            *\n * Function:  Issue a OMVS command for the passed option      *\n *            or prompt for a command.  Then display the      *\n *            results in ISPF Browse.                         *\n *                                                            *\n *            If no command is provided then a popup panel    *\n *            appears to prompt for the OMVS command.         *\n *                                                            *\n * Syntax:    %OMVSCMD command                                *\n *                                                            *\n *            optional 1st parm of -E to edit the results     *\n *                                                            *\n * Dependencies:  Dependent on STEMVIEW from CBTtape          *\n *                                                            *\n * Usage:     Best used when added to the site ISPF           *\n *            command table:                                  *\n *                                                            *\n *            Verb:   ocmd                                    *\n *            T:      0                                       *\n *            Action: select cmd(%OMVSCMD &zparm)             *\n *                                                            *\n *            Then the user can enter:  ocmd xxx              *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            07/26/16 - Add -E option                        *\n *            07/13/16 - Enabled su support (if the user can  *\n *            07/13/16 - Converted from OMVSMAN               *\n *            07/08/16 - Handle null records from man         *\n *            07/08/16 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- */\n\n/* ----------------------- *\n * Get the passed omvscmd *\n * ----------------------- */\n parse arg omvscmd\n\n/* ------------------------------------ *\n * Translate the omvscmd to lower case *\n * ------------------------------------ */\n omvscmd = translate(omvscmd,\"abcdefghijklmnopqrstuvwxyz\", ,\n                    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n/* ----------------------------------- *\n * Test for a omvscmd and exit if none *\n * ----------------------------------- */\n if strip(omvscmd) = '' then do\n    Address ISPExec\n    rc = loadispf()\n    do forever\n       \"Addpop\"\n       \"Display Panel(OMVSCMD)\"\n       if rc > 4 then exit\n       \"Rempop\"\n       call do_it\n       end\n    end\n\ndo_it:\n/* ------------ *\n * check for -E *\n * ------------ */\n if left(translate(omvscmd),2) = '-E' then do\n    omvscmd = substr(omvscmd,3)\n    viewopt = 'EDIT'\n    end\n else viewopt = 'BROWSE'\n\n/* --------------------------------- *\n * Test for su before the command(s) *\n * --------------------------------- */\n su = ''\n parse value omvscmd with su';'cmd\n if word(su,1) = 'su' then do\n    address syscall 'geteuid'\n    myeuid=retval\n    Address syscall \"seteuid 0\"\n    end\n else do\n      cmd = omvscmd\n      su = ''\n      end\n/* ------------------------------------------------- *\n * Issue the man command with the omvscmd parameter *\n * ------------------------------------------------- */\n rc = bpxwunix(cmd,,stdout.,stderr.)\n if su /= '' then do\n    Address syscall \"seteuid\" myeuid\n    rc = syscalls(\"OFF\")\n    end\n\n/* ------------------------------------------------------- *\n * First check the results and then fixup any zero length  *\n * records from the bpxwunix stem by making them 2 blanks. *\n *                                                         *\n * Use Stemview to browse the man page.                    *\n * ------------------------------------------------------- */\n if stdout.0 > 0 then\n    do i = 1 to stdout.0\n       if length(stdout.i) = 0 then stdout.i = '  '\n    end\n\n if stdout.0 > 0 then\n    CALL stemview viewopt,'stdout.',,,omvscmd\n if stderr.0 > 0 then\n    CALL stemview viewopt,'stderr.',,,omvscmd\n drop stdout. stderr.\n Return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    rc = loadispf()                                 *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          Address ISPEXEC                                   *\n *          do until length(load_info) = 0                    *\n *             parse value load_info with dd libd load_info   *\n *             if left(libd,6) = \"ALTLIB\" then do             *\n *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n *                                    else lib = \"EXEC\"       *\n *                Address TSO,                                *\n *                  \"Altlib Deact Application(\"lib\")\"         *\n *                end                                         *\n *             else \"libdef\" libd                             *\n *             address tso \"free f(\"dd\")\"                     *\n *             end                                            *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\n LoadISPF: Procedure\n\n parse value \"\" with null kmsg kpanel kskel first returns ,\n                     kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n last_line = sourceline()\n do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n    end\n rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n    end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n clistdd = \"lc\"random(999)\n execdd  = \"le\"random(999)\n msgdd   = \"lm\"random(999)\n paneldd = \"lp\"random(999)\n skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd ALTLIBC)\n    end\n if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd ALTLIBE)\n    end\n if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd ISPMLIB)\n    end\n if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd ISPPLIB)\n    end\n if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd ISPSLIB)\n    end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n       if first = 1 then call add_it\n       type = \"Clist\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">EXEC \" then do\n       if first = 1 then call add_it\n       type = \"Exec\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,5) = \">MSG \" then do\n       if first = 1 then call add_it\n       type = \"Msg\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,7) = \">PANEL \" then do\n       if first = 1 then call add_it\n       type = \"Panel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n    if left(recordu,6) = \">SKEL \" then do\n       if first = 1 then call add_it\n       type = \"Skel\"\n       first = 1\n       parse value record with x name\n       iterate\n       end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n           \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n           \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n           \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n           \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n           \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n                 \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n      end\n    end\n if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n if kclist <> null then do\n    Address TSO,\n    \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n    end\n if kexec <> null then do\n    Address TSO,\n    \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n    end\n if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n    end\n if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n    end\n if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n    end\n return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\n Add_It:\n if type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n if type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n if type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n if type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n if type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n type = null\n return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\n Alloc_DD:\n arg dd\n Address TSO\n if pos(left(dd,2),\"lc le\") > 0 then\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n else\n \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n return\n>START\n>Panel OMVSCMD\n)Attr Default(%+_)\n/* + type(text  ) intens(low )                   information only  */\n   @ type( input) intens(high) caps(off) just(left ) hilite(uscore)\n   $ type(text) intens(high) color(blue) hilite(reverse)\n   \u00ac type(output) intens(low) caps(off)  color(blue)\n)Body window(72,6) expand(\\\\)\n%-\\-\\-$OMVS Command Prompt%-\\-\\-\n%Command ===>_zcmd\n+\n+Enter/Verify OMVS Command\n%===>@omvscmd                                                        +\n+\n)Init\n)Proc\n ver (&omvscmd,nb)\n)End\n>END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OMVSCOPY": {"ttr": 23053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x12\\x00\\x05\\x01\\x18\\x17\\x0f\\x01\\x18\"/\\x06Q\\n#\\x06\\xa3\\x00\\x00\\xd6\\xd4\\xe5\\xe2@@@@@@'", "ispf": {"version": "02.18", "flags": 0, "createdate": "2018-06-19T00:00:00", "modifydate": "2018-08-10T06:51:05", "lines": 2595, "newlines": 1699, "modlines": 0, "user": "OMVS"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "OMVSLOG": {"ttr": 24323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x07\\x01\\x161/\\x01\\x162\\x1f\\x104\\x01\\x8f\\x01\\x8f\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2016-11-16T10:34:07", "lines": 399, "newlines": 399, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "OMVSMAN": {"ttr": 24330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x16\\x01\\x161/\\x01\\x18\\x05\\x9f\\x06\\x16\\x04#\\x00\\xe8\\x00\\x00\\xd3\\xc2\\xc4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2018-02-28T06:16:16", "lines": 1059, "newlines": 232, "modlines": 0, "user": "LBD"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "OMVSPAX": {"ttr": 24838, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x161/\\x01 &\\x1f\\x06W\\x04\\xa1\\x04\\x83\\x00\\x00\\xd7\\xc1\\xe7@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2020-09-17T06:57:57", "lines": 1185, "newlines": 1155, "modlines": 0, "user": "PAX"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "OMVSSEL": {"ttr": 25349, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Y\\x01\\x18 \\x8f\\x01\\x18\"\\x8f\\x077\\x03e\\x03f\\x00\\x00\\xd6\\xd4\\xe5\\xe2@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2018-07-27T00:00:00", "modifydate": "2018-08-16T07:37:59", "lines": 869, "newlines": 870, "modlines": 0, "user": "OMVS"}, "text": "/* -------------------  rexx procedure  -------------------- */\n  ver = '2.01'\n/*Name:      OMVSSEL                                         |\n|                                                            |\n| Function:  ISPF Dialog REXX subroutine to select an OMVS   |\n|            file and return it to the caller for use.       |\n|                                                            |\n|            Similar to ISPF 3.17 (UDList) but without all   |\n|            the capabilities. But it is easy to traverse    |\n|            directories to find the desired file.           |\n|                                                            |\n| Syntax:    omvsfile = omvssel(prime)                       |\n|                                                            |\n|            omvsfile is the rexx variable that will be      |\n|            the result of calling the omvssel routine       |\n|                                                            |\n|                - result will be null if cancelled out      |\n|                                                            |\n|            prime is optional and if provided is a          |\n|            starting point for the selection process        |\n|            - if blank/null then start at users home dir    |\n|                                                            |\n| Commands:  CD to change directories                        |\n|            CANCEL to quit and return a null value          |\n|            F to find the string in the display             |\n|            L to locate the string                          |\n|            SU to change to superuser mode                  |\n|                                                            |\n| Line commands:   B - to browse the selected file           |\n|                  L - to list the selected directory        |\n|                  I - display info on the file              |\n|                  S - to select the file or directory       |\n|                      and return it                         |\n|                                                            |\n| Sample usage:    Must be called from a REXX Exec under     |\n|                  ISPF in the foreground:                   |\n|                                                            |\n|                  omvsfile = omvssel()                      |\n|                  omvsfile = omvssel('/usr/lpp/')           |\n|                                                            |\n| Notes:     For testing may be called directly and the      |\n|            selection will then be displayed using SAY.     |\n|                                                            |\n| Author:    Lionel B. Dyck                                  |\n|                                                            |\n| History:  (most recent on top)                             |\n|            08/16/18 - V2.01                                |\n|                     - Enable S (select) to return a        |\n|                       directory as well as a file          |\n|            08/09/18 - V2.00                                |\n|                     - Redo the CD to use SYSCALL services  |\n|            08/07/18 - V1.06                                |\n|                     - Support additional CD options        |\n|            07/31/18 - V1.05                                |\n|                     - Additional cleanup                   |\n|            07/30/18 - V1.04                                |\n|                     - Remove use of signal                 |\n|            07/30/18 - V1.03                                |\n|                     - Enable S to do L on a Directory      |\n|            07/27/18 - V1.02                                |\n|                     - Change OCOPY references              |\n|                     - Add version to table title           |\n|            07/27/18 - V1.01                                |\n|                     - Minor cleanup/comments               |\n|                     - Allow calling as a command           |\n|            07/27/18 - V1.00                                |\n|                     - Creation (from OMVSCOPY)             |\n|                       inspired by a IBM-Main post from     |\n|                       Skip Robinson                        |\n* ---------------------------------------------------------- */\n  parse arg prime\n\n/* ---------------------------------------- *\n| Check to see if we are under ISPF or not |\n* ---------------------------------------- */\n  env = sysvar('sysenv')\n  if env = 'FORE' then do\n    if sysvar('sysispf') /= 'ACTIVE'\n    then do\n      say 'Error....'\n      say '%OMVSSEL may only be used under ISPF.'\n      say 'Exiting'\n      exit 16\n    end\n  end\n  else do\n    say 'Error....'\n    say '%OMVSSEL may only be used under ISPF under TSO.'\n    say 'Exiting'\n    exit 16\n  end\n\n/* --------------- *\n | Define defaults |\n * --------------- */\n  parse value '' with null\n  omcsu = 'N'\n  address syscall 'geteuid'\n  olduid = retval\n  parse source x source x\n  Address ISPExec\n  'Control Errors return'\n /* ---------------- *CUSTOM* --------------------------------- *\n  | Customize the panel colors if you don't like these defaults |\n  * ---------------------- *CUSTOM* --------------------------- */\n  omscinp  = 'Blue'\n  omsclow  = 'Blue'\n  omschigh = 'White'\n  omscrev  = 'Reverse'\n  'vput (omscinp omsclow omschigh omscrev)'\n\n/* ------------------------------------------------- *\n | Call the LoadISPF routine to dynamically load the |\n | ISPF Panels and ISPF Message elements for use     |\n | during this sub-routine.                          |\n * ------------------------------------------------- */\n  load_info = loadispf()\n\n/* ------------------------------------ *\n| Get the users default Home directory |\n* ------------------------------------ */\n  call syscalls('ON')\n  address syscall \"getpwnam\" userid() \"pw.\"\n  home_dir = pw.pw_dir'/'\n\n/* -------------------------------------------- *\n| convert \\ to / to help out our windows users |\n* -------------------------------------------- */\n  if prime /= null\n  then prime = translate(prime,'61'x,'e0'x)\n  else prime = home_dir\n\n/* ----------------------- *\n | Call the key subroutine |\n * ----------------------- */\n  omvssel = change_odir(prime)\n\n/* --------------------------------- *\n | If cancelled out then return null |\n * --------------------------------- */\n  if zcmd = 'CANCEL' then omvssel = null\n\n/* --------------- *\n| Exit processing |\n* --------------- */\nExit:\n/* --------------------------------------- *\n | 1st return to non-su state if necessary |\n * --------------------------------------- */\n  address syscall 'geteuid'\n  if retval = 0 then\n  if olduid /= 0 then do\n     /* return to non uid(0) state */\n    address syscall 'seteuid' olduid\n    omcsumsg = null\n    omcsurev = null\n    address ispexec 'vput (omcsumsg omcsurev)'\n  end\n/* ---------------------------------------------- *\n | Now free up the dynically loaded ISPF elements |\n * ---------------------------------------------- */\n  if load_info /= null then do\n    Address ISPEXEC\n    do until length(load_info) = 0\n      parse value load_info with dd libd load_info\n      if left(libd,6) = \"ALTLIB\" then do\n        if libd = \"ALTLIBC\" then lib = \"CLIST\"\n        else lib = \"EXEC\"\n        Address TSO,\n          \"Altlib Deact Application(\"lib\")\"\n      end\n      else \"libdef\" libd\n      address tso \"free f(\"dd\")\"\n    end\n  end\n/* ----------------------------------------------- *\n | Finally return the selected omvs file - or null |\n * ----------------------------------------------- */\n  if source = 'FUNCTION' then Exit omvssel\n  else do\n    if omvssel = null then omvssel = '*none*'\n    say 'Selection:' omvssel\n    exit 0\n  end\n\n/* ------------------------------ *\n| Change to a new OMVS Directory |\n* ------------------------------ */\nChange_ODIR: procedure expose zcmd home_dir omcsu olduid ver\n  parse arg fromdir\n  parse value '' with null selections stack_dir\n  if fromdir = '~' then fromdir = home_dir\n\n/* ---------------------------------------------------- *\n | Rebuild the table if L selection or CD command used. |\n * ---------------------------------------------------- */\nRestart:\n  call do_restart\n  tblrc = 0\n  do forever\n    ocsel = null\n    if ztdsels = 0 then tblrc = 0\n    if tblrc = 0\n    then 'tbdispl' tbl 'panel(oseltbl)'\n    else if tblrc = 4 then 'tbdispl' tbl\n    tblrc = rc\n    if translate(zcmd) = 'CANCEL' then leave\n    if tblrc > 4 then do\n      if pos('|',stack_dir) = 0 then leave\n      lp = lastpos('|',stack_dir)\n      fromdir = strip(substr(stack_dir,lp+1))\n      stack_dir = left(stack_dir,lp-1)\n      call restart_odir\n    end\n  if ocsel /= null then ocsel = translate(ocsel)\n  omcsm = null\n  Select\n    When translate(word(zcmd,1)) = 'CD' then do\n      savedir = fromdir\n      fromdir = word(zcmd,2)\n      if left(fromdir,1) = '~' then\n         fromdir = strip(home_dir''substr(fromdir,3))\n      address syscall 'chdir (fromdir)'\n      if retval < 0 then do\n        omcsm = 'Invalid Dir'\n        omclm = fromdir 'is an invalid directory'\n        'setmsg msg(oms000)'\n        fromdir = savedir\n      end\n      else stack_dir = stack_dir '|' savedir\n     address syscall 'getcwd fromdir'\n     if right(fromdir,1) /= '/' then fromdir = fromdir'/'\n        if omcsm = null then\n        call restart_odir\n      end\n      When translate(left(zcmd,1)) = 'F' then do\n        fw = translate(word(zcmd,2))\n        'tbtop' tbl\n        do forever\n          'tbskip' tbl\n          if rc > 0 then leave\n          if pos(fw,translate(ofile)) > 0 then do\n            omcsm = 'Found'\n            omclm = fw 'found in the list'\n            'setmsg msg(oms000)'\n            leave\n          end\n        end\n      end\n      When translate(zcmd) = 'SU' then do\n        if omcsu = 'Y' then omcsu = 'N'\n        else omcsu = 'Y'\n        call superuser\n      end\n      When translate(left(zcmd,1)) = 'L' then do\n        fw = translate(word(zcmd,2))\n        fl = length(fw)\n        'tbtop' tbl\n        do forever\n          'tbskip' tbl\n          if rc > 0 then leave\n          if translate(left(ofile,fl)) = fw then do\n            omcsm = 'Found'\n            omclm = fw 'found in the list'\n            'setmsg msg(oms000)'\n            leave\n          end\n        end\n      end\n      When ocsel = 'B' then do\n        if otype = '-' then do\n          'control display save'\n          call outtrap 'x.'\n          Address TSO 'OBrowse' fromdir''ofile\n          call outtrap 'off'\n          'control display restore'\n          if x.0 > 0 then do\n            omcsm = 'Error'\n            omclm = x.2\n            'Setmsg msg(oms000)'\n          end\n        end\n        else do\n          omcsm = 'Invalid'\n          omclm = 'This file may not be browsed.'\n          'Setmsg msg(oms000)'\n        end\n      end\n      when ocsel = 'I' then call list_info\n      when ocsel = 'L' then call do_dirlist\n      When ocsel = 'S' then do\n         if otype = 'd' then ofile = ofile'/'\n         selections = fromdir''ofile\n      end\n      Otherwise nop\n    end\n    if selections /= null then leave\n    if zcmd = 'CANCEL' then leave\n    ocsel = null\n  end\n\n  'tbend' tbl\n\n  if selections = null then zcmd = 'CANCEL'\n  return selections\n\n/* ---------------------------------------------- *\n | Build the list of directories/files to display |\n * ---------------------------------------------- */\n  Do_Restart:\n  do forever\n    cmd = 'ls -la' fromdir\n    rc = bpxwunix(cmd,,stdout.,stderr.)\n    if stdout.0 = 0 then do\n      omcsm = 'Invalid Dir'\n      omclm = fromdir stderr.1\n      Address ISPExec 'setmsg msg(oms000)'\n      zcmd = null\n      if cdir_flag = 0 then return fromdir\n      else do\n        if pos('|',stack_dir) = 0 then leave\n        lp = lastpos('|',stack_dir)\n        fromdir = strip(substr(stack_dir,lp+1))\n        stack_dir = left(stack_dir,lp-1)\n      end\n    end\n    else leave\n  end\n  cdir_flag = 1\n\n/* ------------------------------------------ *\n| List the OMVS directory. Once a valid file |\n| is selected then process it.               |\n* ------------------------------------------ */\n  Address ISPExec\n  tbl = 'OC'random(999)\n\n  'TBCreate' tbl 'Names(ocsel ofile odate operm otype) Nowrite'\n\n  do i = 2 to stdout.0\n    parse value stdout.i with operm x1 oid ogrp ,\n      osize omon ody oyr ofile\n    otype = left(operm,1)\n    opermv = 0\n    offset = 100\n    do ip = 2 to 10\n      op = substr(operm,ip,1)\n      select\n        when op = 'r' then opermv = opermv + (4*offset)\n        when op = 'w' then opermv = opermv + (2*offset)\n        when op = 'x' then opermv = opermv + (1*offset)\n        otherwise nop\n      end\n      if ip = 4 then offset = offset / 10\n      if ip = 7 then offset = offset / 10\n    end\n    odate = omon left(ody+100,2) oyr\n    operm = opermv\n    'tbadd' tbl\n  end\n\n  'tbtop' tbl\n  return\n\n/* ------------------- *\n | Check for SuperUser |\n * ------------------- */\nSuperUser:\n  if omcsu = 'Y' then do\n    address syscall 'geteuid'\n    olduid = retval\n    /* now change - or try to change */\n    address syscall 'seteuid' 0\n    if retval = -1 then do\n      omcsm = 'Not Authorized.'\n      omclm = 'You are not authorized to use SuperUser.'\n      omcsu = 'N'\n    end\n    else do\n      omcsumsg = ,\n        center('Currently in SuperUser (UID(0) State - will Reset on Exit',79)\n      omcsurev = 'Reverse'\n      address ispexec 'vput (omcsumsg omcsurev)'\n    end\n  end\n  if omcsu = 'N' then\n  if olduid /= 0 then do\n    address syscall 'seteuid' olduid\n    omcsumsg = null\n    omcsurev = null\n    address ispexec 'vput (omcsumsg omcsurev)'\n    olduid = 0\n  end\n  Return\n\n/* ---------------------------- *\n | Process into a sub directory |\n * ---------------------------- */\ndo_dirlist:\n  ocsel = null\n  if ofile = '..' then do\n    stack_dir = stack_dir '|' fromdir\n    fromdir = left(fromdir,length(fromdir)-1)\n    lp = lastpos('/',fromdir)\n    fromdir = left(fromdir,lp)\n    call restart_odir\n    return\n  end\n  else do\n    stack_dir = stack_dir '|' fromdir\n    fromdir = fromdir''ofile'/'\n  end\n  call restart_odir\n  return\n\n/* ------------------------------ *\n| List the info on the OMVS File |\n* ------------------------------ */\nList_Info:\n  cmd = 'ls -la' fromdir''ofile\n  drop stdout. stderr.\n  rc = bpxwunix(cmd,,stdout.,stderr.)\n/* allocate a temp file to browse the results */\n  Address TSO\n  cmd_dd = \"C\"random()\n  \"ALLOCATE FILE(\"cmd_dd\") REUSE UNIT(vio) SPACE(1 1)\" ,\n    \"CYL DSORG(PS) RECFM(V B) LRECL(120)\"\n  \"EXECIO * DISKW\" cmd_dd \"(STEM stdout. FINIS)\"\n  Address ISPExec\n  \"LMINIT DATAID(DATAID) DDNAME(\"cmd_dd\")\"\n  'control display save'\n  \"BROWSE DATAID(\"dataid\")\"\n  'control display restore'\n  \"LMFREE DATAID(\"dataid\")\"\n  Address TSO ,\n    \"FREE FILE(\"cmd_dd\")\"\n  Address ISPExec\n  return\n\n/* --------------------------------------------- *\n| Restart the OMVS Directory at a new directory |\n* --------------------------------------------- */\nRestart_Odir:\n  'tbend' tbl\n  call restart\n  return\n\n\n/* --------------------  rexx procedure  -------------------- *\n* Name:      LoadISPF                                        *\n*                                                            *\n* Function:  Load ISPF elements that are inline in the       *\n*            REXX source code.                               *\n*                                                            *\n* Syntax:    load_info = loadispf                            *\n*                                                            *\n*            The inline ISPF resources are limited to        *\n*            ISPF Messages, Panels, and Skeletons,           *\n*                 CLISTs and EXECs are also supported.       *\n*                                                            *\n*            The inline resources must start in column 1     *\n*            and use the following syntax:                   *\n*                                                            *\n*            >START    used to indicate the start of the     *\n*                      inline data                           *\n*                                                            *\n*            >END    - used to indicate the end of the       *\n*                      inline data                           *\n*                                                            *\n*            Each resource begins with a type record:        *\n*            >type name                                      *\n*               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n*                     name is the name of the element        *\n*                                                            *\n* Sample usage:                                              *\n*          -* rexx *-                                        *\n*          load_info = loadispf()                            *\n*          ... magic code happens here (your code) ...       *\n*          Address ISPEXEC                                   *\n*          do until length(load_info) = 0                    *\n*             parse value load_info with dd libd load_info   *\n*             if left(libd,6) = \"ALTLIB\" then do             *\n*                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n*                                    else lib = \"EXEC\"       *\n*                Address TSO,                                *\n*                  \"Altlib Deact Application(\"lib\")\"         *\n*                end                                         *\n*             else \"libdef\" libd                             *\n*             address tso \"free f(\"dd\")\"                     *\n*             end                                            *\n*          exit                                              *\n*          >Start inline elements                            *\n*          >Panel panel1                                     *\n*          ...                                               *\n*          >Msg msg1                                         *\n*          ...                                               *\n*          >End of inline elements                           *\n*                                                            *\n* Returns:   the list of ddnames allocated for use along     *\n*            with the libdef's performed or altlib           *\n*                                                            *\n*            format is ddname libdef ddname libdef ...       *\n*                   libdef may be altlibc or altlibe         *\n*                   for altlib clist or altlib exec          *\n*                                                            *\n* Notes:     Entire routine must be included with REXX       *\n*            exec - inline with the code.                    *\n*                                                            *\n* Comments:  The entire rexx program is processed from the   *\n*            last record to the first to find the >START     *\n*            record at which point all records from that     *\n*            point on are processed until the >END           *\n*            statement or the end of the program is found.   *\n*                                                            *\n*            It is *strongly* suggested that the inline      *\n*            elements be at the very end of your code so     *\n*            that the search for them is faster.             *\n*                                                            *\n*            Inline ISPTLIB or ISPLLIB were not supported    *\n*            because the values for these would have to be   *\n*            in hex.                                         *\n*                                                            *\n* Author:    Lionel B. Dyck                                  *\n*                                                            *\n* History:                                                   *\n*            08/29/17 - Fixup static values that were vars   *\n*            05/31/17 - Change default directory count       *\n*            12/09/16 - update for add_it routine            *\n*            05/10/16 - correction for clist and exec        *\n*            04/19/16 - bug correction                       *\n*            06/04/04 - Enhancements for speed               *\n*            08/05/02 - Creation                             *\n*                                                            *\n* ---------------------------------------------------------- *\n* Disclaimer: There is no warranty, either explicit or       *\n* implied with this code. Use it at your own risk as there   *\n* is no recourse from either the author or his employeer.    *\n* ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n* Find the InLine ISPF Elements and load them into a stem *\n* variable.                                               *\n*                                                         *\n* Elements keyword syntax:                                *\n* >START - start of inline data                           *\n* >CLIST name                                             *\n* >EXEC name                                              *\n* >MSG name                                               *\n* >PANEL name                                             *\n* >SKEL name                                              *\n* >END   - end of all inline data (optional if last)      *\n* ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n* Flag types of ISPF resources by testing each record *\n* then add each record to the data. stem variable.    *\n* --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n* Now create the Library and Load the Member(s)         *\n* ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n* Assign dynamic random ddnames *\n* ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n*  LmInit and LmOpen each resource library *\n* ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n* Process all records in the data. stem variable. *\n* ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n/* --------------------------------------------*\n* Put the record into the appropriate library *\n* based on the record type.                   *\n* ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n* Processing completed - now lmfree the allocation and *\n* Libdef the library.                                  *\n* ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n* Add the Member using LmmAdd *\n* based upon type of resource *\n* --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n* ALlocate the temp ispf library *\n* ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(9)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(9)\",\n    \"recfm(f b) lrecl(80) blksize(27920)\"\n  return\n\n>Start\n/*\n>Panel oselTBL\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(off) just(left ) hilite(uscore)\n    color(&omscinp)\n  $ type(output) intens(low ) caps(off) just(left ) color(&omsclow)\n  @ type(output) intens(high) color(&omschigh) hilite(&omscrev)\n  + type(text) intens(low) skip(on) color(&omsclow)\n  % type(text) intens(high) skip(on) color(&omschigh)\n  \u00a8 type(output) intens(low) color(&omsclow) just(asis) caps(off)\n    hilite(&omcsurev)\n)Body  Expand(\\\\)\n%-\\-\\-@title       %-\\-\\-\n%Command ===>_zcmd\n\u00a8omcsumsg\n+Directory: $fromdir\n%\n%S  T OMVS File                                               Date         Perm\n)Model\n_z+$z$z                                                      $z           $z  +\n)Init\n  &title = 'OMVSSEL &ver'\n  .zvars = '(ocsel otype ofile odate operm)'\n  .cursor = &zcmd\n  .help = ocht0\n)Proc\n if (&zcmd EQ &z)\n    ver (&ocsel,list,B,I,S,L,b,i,s,l,&z)\n)End\n*/\n>Panel ocht0\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(off) just(left ) hilite(uscore)\n  color(&omscinp)\n  @ type(text) intens(high) color(&omschigh) hilite(&omscrev)\n  % type(text) intens(high) skip(on) color(&omschigh)\n  + type(text) intens(low) skip(on) color(&omsclow)\n  $ type(output) intens(low ) caps(off) just(left ) color(&omsclow)\n)Body  Expand(\\\\)\n%Tutorial-\\-\\-@OMVSSEL%-\\-\\Tutorial\n%Command ===>_zcmd\n%\n%Command options:\n%\n%  CANCEL+Cancel and return to main panel\n%  CD    +Change to directory      (e.g. ..$z+/etc/)\n%  F     +Find word in file name   (e.g. F xxx)\n%  L     +Locate a file            (e.g. L .profile)\n%  SU    +Change to/from SuperUser mode\n%\n%Selection options:\n%\n%  B    -+Browse the file\n%  I    -+Display the file info\n%  L    -+List the selected directories files (use%F3+to move up)\n%  S    -+Select the file or directory and return for processing\n+\n+Only files with a%T+(type) of%blank+are allowed with%B+or%S+\n+Only files with a%T+(type) of%d+will work with%L+or%S+\n+\n+\n\\ \\Press%Enter+to continue or%F3+to return to the dialog\\ \\\n)Init\n   .cursor = zcmd\n   .zvars = '(til)'\n   &til = '~'\n   &zup = ocht0\n   &zcont = ochtcd\n)Proc\n)End\n>Panel ochtcd\n)Attr Default(%+_)\n  _ type( input) intens(low ) caps(off) just(left ) hilite(uscore)\n  color(&omscinp)\n  @ type(text) intens(high) color(&omschigh) hilite(&omscrev)\n  % type(text) intens(high) skip(on) color(&omschigh)\n  + type(text) intens(low) skip(on) color(&omsclow)\n  $ type(output) intens(high) caps(off) just(left )\n)Body  Expand(\\\\)\n%Tutorial-\\-\\-@OMVSSEL%-\\-\\Tutorial\n%Command ===>_zcmd\n%\n%CD+Examples within OMVSSEL\n%\n%  cd$z                  +Change to users home directory\n%  cd ..                 +Change to the next higher directory\n%  cd ./xyz              +Change to users subdirectory xyz\n%  cd$z                  +Change to users subdirectory xyz\n%  cd /                  +Change to the root directory\n%  cd /usr/lpp/          +Change to /usr/lpp/ directory\n%\n+The%CD+command will remember the prior directories during the session\n+so that using%F3+will move back up the directory 'chain'. Enter%CANCEL+\n+to immediately return.\n%\n%\n%\n+\n+\n+\n+\n\\ \\Press%Enter+to continue or%F3+to return to the dialog\\ \\\n)Init\n   .cursor = zcmd\n   .zvars = '(til tilx)'\n   &til  = '~'\n   &tilx = '~/'\n   &zup  = ochtcd\n   &zcont = ocht0\n)Proc\n)End\n>msg OMS00\nOMS000  '&omcsm' .ALARM = NO .HELP = OCH0\n'&omclm'\n>End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONCALL": {"ttr": 25609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x034_\\x01\\x034_\\x08\\x04\\x02q\\x02q\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-12-11T00:00:00", "modifydate": "2003-12-11T08:04:00", "lines": 625, "newlines": 625, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "ONCALL#": {"ttr": 25865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x033o\\x01\\x033o\\x18#\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-12-02T00:00:00", "modifydate": "2003-12-02T18:23:10", "lines": 11, "newlines": 11, "modlines": 0, "user": "SYSLBD"}, "text": "New tool:   ONCALL\n\nI have a new tool that is on my beta page that you all might find\ninteresting.  It will generate an oncall rotation for your group\nand optionally e-mail (using xmitip) the rotation list along with\nan icalendar file that can be used to add the oncall information\nto each individuals calendar.\n\nThis is a beta but it does work reasonably well (we are using it\nin several of our groups).\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ONLY": {"ttr": 25867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00@\\x01\\x161/\\x01\\x195\\x8f\\x04\\x10\\x02'\\x001\\x00\\x00\\xd6\\xd5\\xd3\\xe8@@@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2019-12-24T04:10:40", "lines": 551, "newlines": 49, "modlines": 0, "user": "ONLY"}, "text": "  /* -------------------  rexx procedure  -------------------- *\n  | Name:      ONLY                                            |\n  |                                                            |\n  | Function:  ISPF Edit Macro to find one or both strings     |\n  |                                                            |\n  | Syntax:    ONLY string-1 string-2                          |\n  |         or ONLY ?                                          |\n  |                                                            |\n  |            ? will display an ISPF Tutorial                 |\n  |                                                            |\n  | Usage Notes: string 2 is required or the record is         |\n  |              excluded.                                     |\n  |                                                            |\n  |              strings may be enclosed in quotes but it      |\n  |              must be the same for both strings             |\n  |                                                            |\n  |              strings with & will be treated in hex so      |\n  |              NO case insensitivity                         |\n  |                                                            |\n  |              An * only works for string-2                  |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            12/24/19 LBD - Clean up find report message     |\n  |            12/21/19 LBD - Improve error checking/reporting |\n  |            12/20/19 LBD - Support other find options       |\n  |                           WORD, PREFIX labels columns      |\n  |            12/04/19 LBD - Correct use with quotes          |\n  |            11/27/19 LBD - enhancements                     |\n  |            11/26/19 LBD - creation                         |\n  |                                                            |\n  * ---------------------------------------------------------- */\n  Address ISREdit\n  'Macro (search) NOPROCESS'\n\n  /* ---------------------------- *\n  | Reset the edit session first |\n  * ---------------------------- */\n  'reset'\n  Address ISPExec ,\n  'Control Errors Return'\n\n/* ------------------------------- *\n | Check for tutorial/help request |\n * ------------------------------- */\n  if strip(search) = '' then search = '?'\n  if strip(search) = '?' then call do_help\n\n  /* --------------------------------------------------------- *\n  | 1. Find if the strings are in quotes.  If so they must be |\n  |    using the same quote type ' or \" on the exterior of    |\n  |    the strings                                            |\n  | 2. parse the provided strings                             |\n  * --------------------------------------------------------- */\n  search = strip(search)\n  if pos(left(search,1),\"'\" '\"') = 0 then\n  parse value search with find1 find2\n  else do\n    if left(search,1) = '\"' then do\n      q = '\"'\n      parse value search with (q) find1 (q) find2\n      find1 = q''find1''q\n    end\n    if left(search,1) = \"'\" then do\n      q = \"'\"\n      parse value search with (q) find1 (q) find2\n      find1 = q''find1''q\n    end\n  end\n\n  /* --------------------------------- *\n  | Make sure the strings are striped |\n  * --------------------------------- */\n  find1 = strip(find1)\n  find2 = strip(find2)\n  if pos('&',find1 find2) = 0 then amp = 0\n  else amp = 1\n\n  findopt = ''\n  fd = ''\n  do i = 1 to words(find2)\n    if left(word(find2,i),1) = '.' then do\n      findopt = findopt word(find2,i)\n      fd = fd i\n    end\n    if datatype(word(find2,i)) = 'NUM' then do\n      findopt = findopt word(find2,i)\n      fd = fd i\n    end\n    if wordpos(word(find2,i),'WORD PREFIX') > 0 then do\n      findopt = findopt word(find2,i)\n      fd = fd i\n    end\n  end\n  if fd /= '' then do i = words(fd) to 1 by -1\n    d = word(fd,i)\n    find2 = delword(find2,d,1)\n  end\n  find2u = translate(find2)\n  find1x = c2x(find1)\n  find2x = c2x(find2)\n\n  /* -------------------------- *\n  | Exclude all and get counts |\n  * -------------------------- */\n  'x all'\n  '(x,excl) = exclude_counts'\n\n  /* --------------------------------------- *\n  | Now find the 1st string in all records  |\n  | and get the find count and record count |\n  * --------------------------------------- */\n\n  if amp = 0\n  then \"find\" find1 \"all\" findopt\n  else \"find x'\"find1x\"' all\" findopt\n  if rc > 4 then do\n     'reset'\n     zerrsm = zerrsm':' search\n     'line_before 1 = msgline (zerrsm)'\n     'line_before 1 = msgline (zerrlm)'\n     exit\n     end\n  '(x,findhits) = find_counts'\n  '(last) = linenum .zlast'\n  hit = 0\n\n  /* ----------------------------------------------- *\n  | Seek (find) all string-1 and check for string-2 |\n  | and if string2 not found then flip the record   |\n  | BUT ONLY IF there is a 2nd string to find       |\n  * ----------------------------------------------- */\n  if strip(find2) /= '' then do\n    if amp = 0\n    then \"seek\" find1 \"first nx\"\n    else \"seek x'\"find1x\"' first nx\"\n    if rc = 0 then\n    do forever\n      '(line) = cursor'\n      '(data) = line' line\n      if pos(find2u,translate(data)) = 0 then do\n        'Label' line '= .a'\n        'flip .a .a'\n        findhits = findhits - 1\n      end\n      else do\n        hit = hit + 1\n        'cursor = 'line +1\n      end\n      if amp = 0\n      then \"seek '\"find1\"' next nx\"\n      else \"seek x'\"find1x\"' next nx\"\n      if rc > 0 then leave\n    end\n  end\n\n  /* ------------------------------ *\n  | Remove hits from exclude count |\n  * ------------------------------ */\n  excl = excl - findhits\n\n  if find2 = ''\n  then if (last - excl) = 0 then 'Reset x'\n  if find2 /= ''\n  then if (last - excl) + hit = 0 then 'Reset x'\n\n  /* ---------- *\n  | Report out |\n  * ---------- */\n  text = last - excl 'hits out of' last+0 'records.'\n  if find2 /= '' then\n  text = text hit 'records found with both strings.'\n  'line_before 1 = msgline (text)'\n  text = 'String1:' find1\n  if find2 /= '' then do\n    text = text left(' ',9) 'String2:' find2\n  end\n  'line_before 1 = msgline (text)'\n  'cursor = 1'\n  exit 0\n\nDo_Help:\n  li = loadispf()\n  Address ISPExec\n  \"Select PGM(isptutor) Parm(onlyhelp)\"\n  x = dropispf(li)\n  exit\n\n/* -------------------------------------------- *\n | Inline ISPF Panel loaded by LOADISPF routine |\n | must remain a comment from >start to >end    |\n * -------------------------------------------- */\n/*\n>Start\n>Panel onlyhelp\n)Attr\n@ type(text) hilite(reverse)\n)Body Expand(\\\\)\n%Tutorial+\\-\\-@ONLY ISPF Edit Command+-\\-\\%Tutorial\n+Command ===>_zcmd\n+\n%ONLY+is an ISPF Edit command that will find all occurrences of a string\n+and hide all records that do not include that string. An optional second\n+string will further limit the display of records that include both strings\n+\n+Syntax: %ONLY+string-1 string-2 find-options\n+      or%ONLY+?\n+\n+         ? will display this ISPF Tutorial\n+         string-1 and string-2 must be enclosed in quotes if blanks included\n+         * may only be in string-2\n+         use of an & will make both string case sensitive\n+         find-options are any find options (e.g. word prefix label column)\n+\n+Examples:\n+\n+         ONLY EXEC PGM\n+         - will display only JCL statements that exec a program and not proc\n+\n)Init\n)Proc\n &zcont = onlyhelp\n)End\n>End\n*/\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      LoadISPF                                        *\n *                                                            *\n * Function:  Load ISPF elements that are inline in the       *\n *            REXX source code.                               *\n *                                                            *\n * Syntax:    load_info = loadispf()                          *\n *            rc = dropispf(load_info)                        *\n *                                                            *\n *            The inline ISPF resources are limited to        *\n *            ISPF Messages, Panels, and Skeletons,           *\n *                 CLISTs and EXECs are also supported.       *\n *                                                            *\n *            The inline resources must start in column 1     *\n *            and use the following syntax:                   *\n *                                                            *\n *            >START    used to indicate the start of the     *\n *                      inline data                           *\n *                                                            *\n *            >END    - used to indicate the end of the       *\n *                      inline data                           *\n *                                                            *\n *            Each resource begins with a type record:        *\n *            >type name                                      *\n *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n *                     name is the name of the element        *\n *                                                            *\n * Sample usage:                                              *\n *          -* rexx *-                                        *\n *          load_info = loadispf()                            *\n *          ... magic code happens here (your code) ...       *\n *          rc = dropispf(load_info)                          *\n *          exit                                              *\n *          >Start inline elements                            *\n *          >Panel panel1                                     *\n *          ...                                               *\n *          >Msg msg1                                         *\n *          ...                                               *\n *          >End of inline elements                           *\n *                                                            *\n * Returns:   the list of ddnames allocated for use along     *\n *            with the libdef's performed or altlib           *\n *                                                            *\n *            format is ddname libdef ddname libdef ...       *\n *                   libdef may be altlibc or altlibe         *\n *                   for altlib clist or altlib exec          *\n *                                                            *\n * Notes:     Entire routine must be included with REXX       *\n *            exec - inline with the code.                    *\n *                                                            *\n * Comments:  The entire rexx program is processed from the   *\n *            last record to the first to find the >START     *\n *            record at which point all records from that     *\n *            point on are processed until the >END           *\n *            statement or the end of the program is found.   *\n *                                                            *\n *            It is *strongly* suggested that the inline      *\n *            elements be at the very end of your code so     *\n *            that the search for them is faster.             *\n *                                                            *\n *            Inline ISPTLIB or ISPLLIB were not supported    *\n *            because the values for these would have to be   *\n *            in hex.                                         *\n *                                                            *\n * Author:    Lionel B. Dyck                                  *\n *                                                            *\n * History:                                                   *\n *            01/09/19 - Include DROPISPF routine             *\n *            08/29/17 - Fixup static values that were vars   *\n *            05/31/17 - Change default directory count       *\n *            12/09/16 - update for add_it routine            *\n *            05/10/16 - correction for clist and exec        *\n *            04/19/16 - bug correction                       *\n *            06/04/04 - Enhancements for speed               *\n *            08/05/02 - Creation                             *\n *                                                            *\n * ---------------------------------------------------------- *\n * Disclaimer: There is no warranty, either explicit or       *\n * implied with this code. Use it at your own risk as there   *\n * is no recourse from either the author or his employeer.    *\n * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n/* ------------------------------------------------------- *\n * Find the InLine ISPF Elements and load them into a stem *\n * variable.                                               *\n *                                                         *\n * Elements keyword syntax:                                *\n * >START - start of inline data                           *\n * >CLIST name                                             *\n * >EXEC name                                              *\n * >MSG name                                               *\n * >PANEL name                                             *\n * >SKEL name                                              *\n * >END   - end of all inline data (optional if last)      *\n * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n/* --------------------------------------------------- *\n * Flag types of ISPF resources by testing each record *\n * then add each record to the data. stem variable.    *\n * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n/* ----------------------------------------------------- *\n * Now create the Library and Load the Member(s)         *\n * ----------------------------------------------------- */\n  Address ISPExec\n/* ----------------------------- *\n * Assign dynamic random ddnames *\n * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n/* ---------------------------------------- *\n *  LmInit and LmOpen each resource library *\n * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n/* ----------------------------------------------- *\n * Process all records in the data. stem variable. *\n * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n   /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n/* ---------------------------------------------------- *\n * Processing completed - now lmfree the allocation and *\n * Libdef the library.                                  *\n * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n/* --------------------------- *\n * Add the Member using LmmAdd *\n * based upon type of resource *\n * --------------------------- */\nAdd_It:\n  Select\n    When type = \"Clist\" then\n    \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n    When type = \"Exec\" then\n    \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n    When type = \"Msg\" then\n    \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n    When type = \"Panel\" then\n    \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n    When type = \"Skel\" then\n    \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n    Otherwise nop\n  end\n  type = null\n  return\n\n/* ------------------------------ *\n * ALlocate the temp ispf library *\n * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(5)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n/* --------------------  rexx procedure  -------------------- *\n * Name:      DropISPF                                        *\n *                                                            *\n * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *\n *            that were created by the LoadISPF function.     *\n *                                                            *\n * Syntax:    rc = dropispf(load_info)                        *\n *                                                            *\n * Author:    Janko                                           *\n *                                                            *\n * History:                                                   *\n *            12/05/18 - Creation                             *\n * ---------------------------------------------------------- */\nDropISPF: Procedure\n  arg load_info\n  Address ISPEXEC\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    if left(libd,6) = \"ALTLIB\" then do\n      if libd = \"ALTLIBC\" then lib = \"CLIST\"\n      else lib = \"EXEC\"\n      Address TSO,\n        \"Altlib Deact Application(\"lib\")\"\n    end\n    else \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PACK": {"ttr": 26121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x16\\x10\\x8f\\x01\\x16\\x10\\x8f\\x18!\\x02\\x94\\x02\\x94\\x00\\x00\\xe3\\xd9\\xe2\\xd4\\xc1\\xc9\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-04-17T00:00:00", "modifydate": "2016-04-17T18:21:03", "lines": 660, "newlines": 660, "modlines": 0, "user": "TRSMAIN"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PDS2SEQ": {"ttr": 26378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x16\\x18_\\x01\\x16\\x18_\\x10\\x19\\x00\\x9a\\x00\\x83\\x00\\x00\\xe6\\xe2\\xe8\\xd5\\xc7\\xe4\\xc4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-07-03T00:00:00", "modifydate": "2016-07-03T10:19:02", "lines": 154, "newlines": 131, "modlines": 0, "user": "WSYNGUD"}, "text": "/* REXX PDS2SEQ *******************************************************/\n/*                                                                    */\n/*  Author:  Duc Tuan Nguyen                                          */\n/*  Email :  dt n <ndt2004@gmail.com>                                 */\n/*                                                                    */\n/*       A REXX program to put a PDS into sequential format           */\n/*                                                                    */\n/*  I use my PC as a \"data store\", where I have anything on it        */\n/*  (Manuals, Redbooks, documents, presentations ...). And with the   */\n/*  help of a search software (Archivarius seems to be the best       */\n/*  search software that I've found after many tests), I am           */\n/*  able to find anything on my PC (A sort of Google search on my     */\n/*  PC).                                                              */\n/*                                                                    */\n/*  So, it is interesting for me to be able to retrieve data that     */\n/*  are on PDS from my search software.  This Rexx reads a PDS, puts  */\n/*  it in a sequential format , so I can ftp it on my PC. It          */\n/*  provides also jcl that you can use to reload the sequential into  */\n/*  a PDS format.                                                     */\n/*                                                                    */\n/*  It is adapted from a Rexx that I've found on the web              */\n/*  (unfortunately I am not able to find the first author...)         */\n/*                                                                    */\n/* REXX ***************************************************************/\n/* UNLOAD PDS MEMBERS TO SEQUENTIAL */\n/* WITH ./ ADD NAME= COMMANDS FOR MEMBERS */\nARG PDS outp\n\n\nIf PDS = \"\" then do\n   Say \"Please type in the name of the input PDS without quotes\"\n   Pull PDS\n   If PDS = \"\" then exit\n   end\n\nIf outp= \"\" then do\n   Say \"Please type in the name of the output without quotes\"\n   Say \"sequential dataset that will hold data\"\n   Pull outp\n   If outp = \"\" then exit\n   end\n\noutp = \"'\" || outp || \"'\"\nIF SYSDSN(outp) = \"OK\" then\n             \"DELETE\" outp \"PURGE\"\n\nSAY \"Creating \" outp\n\"ALLOC DDN(outdd) MOD REUSE SPACE(300,150) TRACKS\",\n      \"LRECL(80) BLKSIZE(800) RECFM(F B)\",\n      \"DSN(\"outp\")\"\n\nSay \"Press ENTER to continue\";pull\n\nIF SYSDSN(\"'\"pds\"'\") <> \"OK\" THEN DO\n   SAY  \"PDS NOT USABLE\"\n   SAY SYSDSN(\"'\"pds\"'\")\n   EXIT 8\n   END\n\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\nCALL INIT\nDO 9999 /* limit for testing. change to FOREVER in real life */\n  /* EACH EXECUTION OF THIS CMD GIVES ONE MORE MEMBER NAME */\n  /* NAME OF MEMBER IS IN VARIABLE member                  */\n  ADDRESS ISPEXEC \"LMMLIST DATAID(\"DATAID1\") OPTION(LIST)\",\n                  \"MEMBER(member) STATS(YES)\"\n  /*Non-zero RC means no more members*/\n  IF RC = 0 THEN CALL DISPLAY_MEMBER\n  ELSE LEAVE /* break out of loop */\nEND\n\nADDRESS ISPEXEC \"LMMLIST  DATAID(\"DATAID1\") OPTION(FREE)\"\nADDRESS ISPEXEC \"LMCLOSE DATAID(\"DATAID1\")\"\nADDRESS ISPEXEC \"LMFREE  DATAID(\"DATAID1\")\"\n\n/* at end, write ENDUP, JCL delimiter */\nSAY \"Program successfully executed - Check your output dataset\"\nSAY i \"members processed\"\nQUEUE \"./ ENDUP\"\nqueue \"!!\"\nqueue \"//\"\nqueue \"//* END \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\n\"EXECIO \" queued() \" DISKW outdd (FINIS)\"\n\"FREE DDN(outdd)\"\n\nEXIT 0     /* logical end of program */\n\nINIT:\ni=0\n/* write JCL at beginning of step */\nPDS = translate(PDS,\" \",\"'\") /* drop apost */\nPDS = space(PDS,0) /* drop spaces */\nQUEUE \"//* Generated by rexx PDS2SEQ     \"\nQUEUE \"//* CHANGE userid to your userid \"\nQUEUE \"//* change PDS if desired\"\nQUEUE \"//* put jobcard at top, submit\"\nQUEUE \"//*DELETE  EXEC PGM=IEFBR14\"\nQUEUE \"//*DD1     DD DSN=\"PDS\",\"\nQUEUE \"//*        DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,0)\"\nQUEUE \"//*\"\nQUEUE \"//LOAD    EXEC PGM=IEBUPDTE,PARM='NEW'\"\nQUEUE \"//SYSPRINT DD SYSOUT=*\"\nQUEUE \"//SYSUT2  DD DSN=\"PDS\",\"\nQUEUE \"//        DISP=(NEW,CATLG,DELETE),\"\nQUEUE \"//        DCB=(DSORG=PO,LRECL=80,BLKSIZE=8000,RECFM=FB),\"\nQUEUE \"//        UNIT=SYSDA,\"\nQUEUE \"//        SPACE=(TRK,(10,05,20),RLSE)\"\nQUEUE \"//*\"\nQUEUE \"//SYSIN  DD DATA,DLM='!!'\"\n\n\"EXECIO \" queued() \" DISKW outdd (FINIS)\"\n\n /* LIB MGT ACCESSES THE DATASET */\nADDRESS ISPEXEC \"LMINIT DATAID(DATAID1) DATASET('\"PDS\"') ENQ(SHR)\"\n/* LIKE AN OPEN WITH REGULAR FILES */\nADDRESS ISPEXEC \"LMOPEN DATAID(\"DATAID1\") OPTION(INPUT)\"\nRETURN\n\nDISPLAY_MEMBER:\ni=i+1\n/*SAY \"MEMBER NAME \" member\nSAY \"RECORDS     \" ZLCNORC */\n\nin_pds = PDS\"(\"member\")\"\nin_pds = SPACE(in_pds,0)\n\n/* at beginning of each member, write blank line & ADD command */\nDOT_SLASH_ADD.1 = \"\"\n\"EXECIO 1 DISKW outdd (STEM DOT_SLASH_ADD.)\"\nDOT_SLASH_ADD.1 = \"./ ADD NAME=\"member\n\"EXECIO 1 DISKW outdd (STEM DOT_SLASH_ADD.)\"\n\"ALLOC DDN(indd) SHR REUSE DSN('\"in_pds\"')\"\n\"EXECIO * DISKR indd (STEM indd. FINIS)\"\n\"EXECIO \" indd.0 \" DISKW outdd (STEM indd.)\"\nif rc     <> 0 then Do\n   say \"**********************************************\"\n   say \"   Error writing seq file: \" rc\n   say \"   Abnormal end   \"\n   say \"**********************************************\"\n   Exit 8\nend\n/*\n\"REPRO INDATASET(\"in_pds\")\",\n      \"OUTFILE(outdd)\" */\nTRACE OFF\nRETURN\nERROR: /* CALL ON ERROR SENDS HERE. DISPLAYS ISPF ERR INFO */\nSAY \"PROGRAM LIBLIST DID NOT WORK\"\nSAY ZERRMSG\nSAY ZERRSM\nSAY ZERRLM\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDS2SEQ$": {"ttr": 26628, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x161/\\x01\\x161/#)\\x00\\x15\\x00\\x16\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2016-11-07T23:29:44", "lines": 21, "newlines": 22, "modlines": 0, "user": "SYSLBD"}, "text": "     A rexx program to put a pds in sequential format\n\nI use my PC as a \"data store\" , where i have anything on it\n(Manuals, Redbooks, documents, presentations ...). And with the\nhelp of a search software (Archivarius seems to be the best\nsearch software that i've found after multiple tests), I am\nable to find anything on my PC (A sort of Google search on my\nPC).\n\nSo, it is interesting for me to be able to retrieve data that\nare on PDS from my search software.  This Rexx reads a PDS, puts\nit in a sequential format , so I can ftp it on my PC. It\nprovides also jcl that you can use to reload the sequential into\na PDS format.\n\nIt is adapted from a Rexx that I've found on the web\n\n      Author:  Duc Tuan Nguyen\n      Email :  dt n <ndt2004@gmail.com>\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLPISPF": {"ttr": 26630, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x013\\x00\\x07\\x01\\x161/\\x01 \\x04\\x9f\\x10\\x16\\x11\\x0c\\x1b\\t\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.51", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2020-02-18T10:16:07", "lines": 4364, "newlines": 6921, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PLPISPF$": {"ttr": 28420, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x011\\x006\\x01\\x01(\\x9f\\x01 \\x04\\x9f\\x10\\x17\\x00\\xd9\\x00\\x04\\x00\\x00\\xd7\\xd3\\xd7@@@@@@@'", "ispf": {"version": "01.49", "flags": 0, "createdate": "2001-10-16T00:00:00", "modifydate": "2020-02-18T10:17:36", "lines": 217, "newlines": 4, "modlines": 0, "user": "PLP"}, "text": "This member documents the change history of the Product Launch Point\ndistribution (in push down stack mode):\n\nFebruary 18, 2020   Version 1.49\n                   - Correct bug in adding entries to the User menu\n                   - Correct bug that left open the temp table\n\nSeptember 17, 2018  Version 1.48\n                   - Update numerous panels to chagne pad('_') to hilite(uscore)\n\nOctober 16, 2018    Version 1.47\n                   - Update exec PLPISPF to support multiple parms for\n                     command (cmd) paramters (thx to bk)\n                   - Update Panel PLPLIST to show 4 characters for\n                     the PLP Application name\n\nAugust 26, 2017     Version 1.46\n                   - Add cmd_tbl customization to control dynamic table\n                     for RFIND\n\nSeptember 19, 2016  Version 1.45\n                   - Support symbolics in the command field for\n                   - Additional error handling\n                   - Minor refactoring           TSAZFA\n                   - Support SYSOUT in OTHER DDs TSAZFA\n                   - Add support for ISPF MODE   TSAZFA\n                   - Panel changes to use full screen width TSAZFA\n                     TSAZFA - Al Ferguson\n\nJuly 05, 2016       Version 1.44\n                   - Support symbolics in the command field for\n                     the each application.\n\nJune 17, 2016       Version 1.43\n                   - Enhance the Admin Report option to include the\n                     documentation member if it exists\n\nMay 06, 2016        Version 1.42\n                   - Add option from Bruce Koss to allow\n                     limiting apps to lpars/sysplex.\n                     Specify in the application description\n                     the text ONLY followed by the lpar or sysplex\n                     where the application may be used.\n                     Note you MUST customize the sysplex test\n\nMay 05, 2016        Version 1.41\n                   - Add option for wild card on\n                     admin_ids\n\nApril 18, 2016      Version 1.40\n                   - Bug fix for Exclude under Admin\n\nApril 15, 2016      Version 1.39\n                   - Allow undocumented command Exclude\n                     (works in both normal and admin)\n\nApril 14, 2016      Version 1.38\n                   - Allow ONLY/RESET to work in Admin\n                   - Correct only not found message\n\nApril 13, 2016      Version 1.37\n                   - add commands ONLY and RESET** does not work in admin\n                     Only string will display only those rows where the\n                          string is found\n                     Reset with reset the display to all rows\n\nApril 06, 2016      Version 1.36\n                   - add confirmation message for admin\n                     after save and copy\n\nApril 05, 2016      Version 1.35\n                   - allow multiple selections at once\n\nApril 04, 2016      Version 1.34\n                   - disable test_first routine by\n                     setting a flag tf_flag\n\nApril 01, 2016      Version 1.33\n                   - minor updates from Bruce Koss\n\nMarch 31, 2016      Version 1.32\n                   - correction for admin for /USER\n                   - add control errors return\n\nMarch 23, 2016      Version 1.31\n                   - use symdef var for dsn (LBD)\n                   - incorporate several changes from\n                     Bruce Koss\n\nMarch 22, 2016      Version 1.30\n                    - Updated documentation and FAQ\n                    - Add P line option to prompt for additional\n                      parameters before invoking the command\n\nMarch 10, 2016      Version 1.29\n                    - Make TRX optional\n\nOctober 3, 2008     Version 1.28\n                    - Change to fix spelling of the word Application\n                    - Support dsn's if sysuid is null or if\n                      syspref /= sysuid\n                    * all updates thanks to Eric Hamtiaux\n\nApril 30, 2004      Version 1.27\n                    - Change to support WSCMD and TRX by Tim Walker\n\nOctober 3, 2003     Version 1.26\n                    - Correct minor typo\n\nJune 18, 2003       Version 1.25\n                    - Correct minor very random bug where an app would\n                      start unexpectedly when starting plp\n\nApril 16, 2003      Version 1.24\n                    - Fix sub-menu name of 1 char problem\n\nMarch 24, 2003      Version 1.23\n                    - Correct loop in Find when string not found\n\nMarch 23, 2003      Version 1.22\n                    - Correct Locate processing after an initial Locate\n                      command.\n\nMarch 05, 2003      Version 1.21\n                    - Add Support for Dan Dalbys' Dynamic Steplib thanks to\n                      Hartmut Beckmann\n\nFebruary 11, 2003   Version 1.20\n                    - Correction for table location when near find on command\n\nFebruary 03, 2003   Version 1.19\n                    - Correction for when the CMD field has imbedded parens\n\nJanuary 09, 2003    Version 1.18\n                    - Minor cleanup (arg)\n\nJanuary 07, 2003    Version 1.17\n                    - Add support for up to 15 application specific\n                      datasets.\n                    - Redo the REPORT processing for the additional dd/dsns\n                    - Remove SKELS dataset as it is no longer needed\n\nDecember 31, 2002   Version 1.16\n                    - Sort numeric apps before alpha\n                    - Configuration option for sort\n                    - Support on the PLP display option.option\n\nDecember 19, 2002   Version 1.15\n                    - Correct support for pgm parm with imbedded parens\n\nDecember 16, 2002   Version 1.14\n                    - Correct support for numeric app names\n\nOctober 09, 2002    Version 1.13\n                    - close temp table on exit\n\nOctober 08, 2002    Version 1.12\n                    - change tbclose to tbend in close_table routine\n\nOctober 08, 2002    Version 1.11\n                    - change location of copy table call\n\nOctober 04, 2002    Version 1.10\n                    - change to copy the table to a temporary table\n                      before use - thus freeing the allocation.\n                    - change initial library allocation showing how to\n                      use a system symbolic for the data set name.\n                    - enhance the near find logic\n                    - if using the USER interface always go into ADMIN\n                      mode\n\nSeptember 11, 2002  Version 1.9\n                    Correction for near find when app entered on initial\n                    command (e.g. plp xyz)\n\nAugust 9, 2002      Version 1.8\n                    Correction for GRPN table name\n                    support app names numeric\n                    - but prevent creating info items for these\n                    minor corrections/cleanup\n                    Panel PLPADMA changed to allow numeric app names\n\nJuly 29, 2002       Version 1.7\n                    Expand size of entry fields for datasets on panels.\n                    Start group nested menus with W instead of A.\n                    Correct where sub-menus are stored (bug fix).\n\nJuly 25, 2002       Version 1.6\n                    Support fixup of symbols for multiple dataset\n                    names.\n\nJuly 24, 2002       Version 1.5\n                    Make RACF group lookup for ADMIN more flexible.\n                    Enhance Locate for near-hit\n                    Enhance app name on command line for near-hit as well\n\nJuly 23, 2002       Version 1.4\n                    Allow app name to be entered on the command line\n                    with or without options.\n\nJuly 20, 2002       Version 1.3\n                    Add support for sub-menus in PLP. Under Admin command\n                    Menu or selection M will insert a new menu.\n\nJuly 09, 2002       Version 1.2\n                    Correction to prevent an alias setup from accidentally\n                    clobbering the original\n\nJuly 08, 2002       Version 1.1\n                    Correction to prevent an infinite loop if an alias\n                    points to another alias.\n\nOctober 16, 2001    Version 1.0 (no change)\n                    Minor change to panel PLPMH0\n\nOctober 10, 2001    Version 1.0\n                    Initial release\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PLPISPF#": {"ttr": 28425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x00\\x01\\x08(\\x7f\\x01\\x16\\tO\\x18B\\r)\\r)\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "2008-10-13T00:00:00", "modifydate": "2016-04-03T18:42:00", "lines": 3369, "newlines": 3369, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "PLPISPF@": {"ttr": 29953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1d\\x00\\x00\\x01\\x08(\\x7f\\x01\\x16\\tO\\x18B\\x04\\x94\\x04\\x94\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "01.29", "flags": 0, "createdate": "2008-10-13T00:00:00", "modifydate": "2016-04-03T18:42:00", "lines": 1172, "newlines": 1172, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "PNS": {"ttr": 30218, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x164?\\x01\\x164?\\x10Q\\x00]\\x00]\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-12-08T00:00:00", "modifydate": "2016-12-08T10:51:00", "lines": 93, "newlines": 93, "modlines": 0, "user": "SYSLBD"}, "text": "How to setup point and shoot in ISPF panel table headers\n\nThere are times where an ISPF panel needs to support point and shoot\nlogic and this is a simple way to do it. The reason for doing it this\nway is that you can control the intens, color, caps, justification,\nand hilite for the field.\n\n1. define some attributes\n   # type(output) intens(high) caps(off) just(left) pas(on) hilite(uscore)\n   \u00a8 type(output) intens(high) caps(off) just(asis) pas(on) hilite(uscore)\n\n   Use the appropriate attribute based on the justification.  In some cases\n   you will want to use left justification and in others you need specific\n   placement so asis justification is what you need.\n\n2. Use them in the table header\n  #Name+       Gen  Abs#CRdate  \u00a8MDdate        +V.M  #Size+\n\n   In this example both left and asis justification are used. Some of the\n   headers are not defined for point and shoot (e.g. GEN Abs, V.M). The\n   rest are defined for left justification except the MDdate which is\n   defined using asis justification.\n\n   Or use them within a panel\n\n   Enter value:_val#xyz+\n\n3. Define the output variable values in the )INIT section\n   &name   = 'Name'\n   &crdate = 'Created'\n   &mddate = '    Changed  '\n   &size   = 'Size'\n\n   &xyz    = 'XYZ'\n\n   As you can see all of the variable names match the output variable name\n   in the header row. The &mddate has leading and trailing blanks so that\n   it fills out the space in the header so the fields are aligned where\n   they need to be.\n\n4. Define the Point and shoot\n)PNTS\nFIELD(name)     VAR(ZCMD) VAL('SORT NAME')\nFIELD(crdate)   VAR(ZCMD) VAL('SORT CREATED')\nFIELD(mddate)   VAR(ZCMD) VAL('SORT CHANGED')\nFIELD(size)     VAR(ZCMD) VAL('SORT SIZE')\n\nFIELD(xyz )     VAR(ZCMD) VAL('SET XYZ')\n\nIn the )PNTS (point and shoot) section the syntax is:\n\n   FIELD(variable name)\n   This defines the variable of a point and shoot field in the\n   ISPF display.\n\n   VAR(variable)\n   This defines the variable to be set when the point and shoot field\n   is selected. In this case ZCMD will be updated and passed to the\n   application.\n\n   VAL(value)\n   The value is the text that will be inserted into the variable defined\n   in VAR(). Enclose in quotes if more than one word or if spaces are\n   included in the text.\n\nAnd assuming your dialog understands the zcmd values you're good to\ngo.\n\nOne way to do this so that the panel gets updated but the processing\ncode doesn't go is this technique which\nassumes that the point and shoot field sets ZCMD to a value of 'SET XYZ' and\nthat causes the code to set panel variable to 'X', reset zcmd to null, and then\ninterate which redisplays the panel.\n\n   Do forever\n   Display Panel(xxx)\n   If rc > 0 then leave (PF3 or END)\n   if word(zcmd,1) = 'SET' then do\n      if word(zcmd,2) = 'XYZ' then val = 'X'\n      zcmd = ''\n      iterate\n      end\n   end\n   --- processing goes here\n\nNotes:\n\n1. A point and shoot (pns) field that is defined as an output field will\n   be automatically converted to an input field if tab to point and\n   shoot is enabled (it probably is by default). That means that when\n   the user tabs to the field that they can type anything in it before\n   they hit enter. Nothing happens and the variable is not updated or\n   affected. This is just the way it works per IBM ISPF L3.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRMCK": {"ttr": 30467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x12\\x01\\x161/\\x01 \\x13_\\x13\\x10\\n\\xc2\\x04E\\x00\\x00\\xd7\\xd9\\xd4\\xc3\\xd2@@@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2016-11-07T00:00:00", "modifydate": "2020-05-14T13:10:12", "lines": 2754, "newlines": 1093, "modlines": 0, "user": "PRMCK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PRMCK$": {"ttr": 31495, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00X\\x00\\x99)\\x0f\\x01\\x18%o\\x05@\\x002\\x00\\x14\\x00\\x00\\xd7\\xd9\\xd4\\xc3\\xd2@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1999-10-17T00:00:00", "modifydate": "2018-09-13T05:40:58", "lines": 50, "newlines": 20, "modlines": 0, "user": "PRMCK"}, "text": "PARMLIB Check\n\nThis consists of two EXEC's:\n\n   PRMCK     - ISPF Edit Command\n   PRMCKBAT  - Batch front end to PRMCK by Hartmut Beckmann\n\nPRMCK Edit Command\n\n  This application consists of a REXX Exec with imbedded ISPF Panels.\n  To use this you need to copy the exec into a library in your SYSPROC\n  or SYSEXEC concatenation.\n\n  Usage is to Edit the desired member of SYS1.PARMLIB and enter the\n  command PRMCK.\n\n  Syntax: PRMCK cat sysres -debug -notran\n\n  valid options are:\n        ?   - will prompt for catalog and sysres\n        cat - is a name that will be used in the master\n              catalog lookup (find *custom* below) and\n              if not found will be used as the master\n              catalog name (enter without quotes).\n        sysres is the volser of the system ipl volume\n              to be checked when a volser of ****** is\n              coded.\n        -debug - will turn on tracing\n        -help  - display short ispf tutorial\n        -nowarn  - will ignore all warnings\n        -noerror - will ignore all errors\n        -report  - will create a report and put you into browse\n                   ** this data set will *not* be deleted when done\n\n  Support for PROGxx member statements\n     - LNKLST\n     - APF\n     - LPA\n     - SYSLIB\n  Support for LNKLSTxx and LPALSTxx members\n\n  Verification is not 100% the same as the system will perform when\n  used but it does a fair amount of verification.  Errors and Warnings\n  are inserted into the Edit display as non-saveable messages.\n\nPRMCKBAT - Batch Front End\n\nThis is code that will inovke the PRMCK exec in batch.\n\nSee the BATJCL for a sample JCL to run this exec.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRMCK#": {"ttr": 31497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x991_\\x00\\x991_\\x112\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-11T00:00:00", "modifydate": "1999-11-11T11:32:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSLBD"}, "text": "This zip file contains a file in TSO Transmit format.  To use this\nfile you must:\n\n1. Unzip into a directory on your workstation\n2. Do a binary file transfer of the unzip'd file to an OS/390\n   dataset that is RECFM=FB and LRECL=80\n3. After the upload issue TSO RECEIVE INDS(upload.dsn)\n\nyou will then have a usable dataset on OS/390 to work with.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PRMCK01": {"ttr": 31499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x01\\x10\"O\\x01\\x10\"O\\x00R\\x04\\xb1\\x04\\xb1\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2010-08-12T00:00:00", "modifydate": "2010-08-12T00:52:00", "lines": 1201, "newlines": 1201, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "PRMCK02": {"ttr": 32008, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x16\\x01\\x16\\x06O\\x01\\x16\\x06O\\x13V\\x04\\xc1\\x04\\xc1\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2016-03-04T00:00:00", "modifydate": "2016-03-04T13:56:16", "lines": 1217, "newlines": 1217, "modlines": 0, "user": "SYSLBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PSPRINT": {"ttr": 32520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x15\\x12\\x0f\\x01\\x15\\x12\\x0f\\x16\\x13\\x027\\x027\\x00\\x00\\xd3\\xc2\\xc4\\xe8\\xc3\\xd2@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2015-04-30T00:00:00", "modifydate": "2015-04-30T16:13:00", "lines": 567, "newlines": 567, "modlines": 0, "user": "LBDYCK"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "PSPRINTO": {"ttr": 32776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x14\\x08\\x0f\\x01\\x14\\x08\\x0f\\x11\\x02\\x02)\\x02)\\x00\\x00\\xd3\\xc2\\xc4\\xe8\\xc3\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-03-21T00:00:00", "modifydate": "2014-03-21T11:02:00", "lines": 553, "newlines": 553, "modlines": 0, "user": "LBDYCK"}, "text": "./ ADD NAME=$DOC     0106-99068-14080-1101-00024-00027-00000-LBDYCK\nThis dataset contains the PSPRINT ISPF dialog:\n\nPSPRINT  - used to format host output for printing on a\n           PostScript printer and then invoke LPRPRINT.  Options\n           include Portrait, Landscape, and 2UP printing.\n\nThe members of this dataset are in IEBUPDTE format.\n\n$DOC     - What you are reading\nPSPRINT  - The above 2 rexx execs which are the entry points to\n           the dialogs\nPSPR00   - ISPF messages\nPSPRH0   - ISPF panel\nPSPRINT0 - ISPF panel\nPSPRM    - ISPF panel\n\nNo warranty comes with these dialogs - use them at your own risk.\nThey may require customization to work in your environment.\n\nComments, suggestion, and an occasional (not too many) complaints\nare welcome to the author:\n\n  Lionel Dyck\n  E-Mail:  lbdyck@gmail.com\n./ ADD NAME=PSPRH0   0100-94025-94025-1028-00071-00071-00000-PANEL\n)Attr Default(@+_)\n/* _ type( input) intens(high) caps(on ) just(left )               */\n   ! type(text) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   $ type(output) intens(high) caps(off) just(asis ) color(white)\n      hilite(reverse)\n   ` type(text) intens(high) caps(off) just(asis ) color(yellow)\n   ~ type(text) intens(high) caps(off) just(asis ) color(turq)\n   @ type(text) intens(high)\n   + type(text  ) intens(low )\n     skip(on)\n   # area(SCRL) Extend(ON)\n)Body\n+------------------------! Convert Text to PostScript +-------------------------\n@Command ===>_zcmd\n@\n+\n#help -------------------------------------------------------------------------#\n)Area Help\n`    Information on Converting text to PostScript\n~\n~    This ISPF application will convert text data into a data stream that\n~    can be printed on a PostScript printer.\n~\n~    To print this data stream you must send the data to an application\n~    that will convert it from EBCDIC (the MVS character set) to ASCII\n~    and then direct the data stream to a PostScript printer.  The most\n~    common technique for this is to use the LPR TCP/IP TSO command.\n~\n~    The information that is asked for on the panel is:\n~\n`    Input Data Set      ===>\n~\n~    This is the data set name that contains the information that is to be\n~    converted to PostScript.  The format of this field is:\n~\n~              user.data\n~              user.data(member)\n~              'prefix.user.data'\n~\n`    Print Orientation   ===>\n~\n~    This is the orientation of the resulting printed output.  The valid\n~    options are:\n~\n         PORT -  Portrait 80 characters by 60 lines in 11 pt. Courier\n         WIDE -  Portrait 132 characters by 103 lines in 6 pt. Courier\n         LAND -  Landscape 132 characters by 60 lines in 9 pt. Courier\n         2UP  -  2 pages 80 characters by 66 lines side by side\n                 in landscape in 6 pt. Courier\n~\n`    Invoke LPRPRINT     ===>\n~\n~    This allows you to inform the application that the ISPF LPRPRINT Dialog\n~    is not to be automatically invoked.  If`no~is selected then the converted\n~    data stream will be saved into a data set (either the specified output\n~    data set or a dynamically generated data set).\n~\n`    Output Data Set     ===>\n~\n~    This field is optional and defines an output data set into which\n~    the converted PostScript data stream will be stored.\n+\n!Note:`Use the Enter key to just scroll down this tutorial or\n`      Use key $LEFT`to scroll down and key $RIGHT`to scroll up.\n)Init\n  .cursor = zcmd\n  &left  = PFK(LEFT)\n  &right = PFK(RIGHT)\n)Proc\n)end\n./ ADD NAME=PSPRINT  0100-14080-14080-1057-00360-00360-00000-REXX\n        /* ---------------------  rexx procedure  ---------------------- *\n         * Name:      PSPRINT                                            *\n         *                                                               *\n         * Function:  Convert a text file into a PostScript print        *\n         *            stream.                                            *\n         *                                                               *\n         * Syntax:    %PSPRINT input-file output-file / options          *\n         *                                                               *\n         * where:                                                        *\n         *        input-file is the data set name of the input text file *\n         *        output-file is optional and is the data set name that  *\n         *           will contain the postscript results.                *\n         *           - if not specified this is dynamically generated.   *\n         *           - if specified the output file will not be deleted  *\n         *             at the end of processing.                         *\n         *           - if specified as @ then the ISPF dialog will be    *\n         *             invoked for additional prompting.                 *\n         *       / is the delimeter used to offset the options           *\n         *       options are optional values which may be:               *\n         *           PORT, WIDE, LAND, or 2UP for print orientation      *\n         *           DEBUG to cause tracing of the rexx program          *\n         *             during execution                                  *\n         *           NOLPR to prevent the execution of the LPRPRINT exec.*\n         *                                                               *\n         * If no parameters are entered then the ISPF Dialog is invoked. *\n         *                                                               *\n         * Defaults:                                                     *\n         *            PORT orientation and delete the output file after  *\n         *            invoking the lprprint procedure.                   *\n         *                                                               *\n         * Author:    Lionel B. Dyck                                     *\n         *            Rockwell International                             *\n         *            P.O. Box 2515                                      *\n         *            Seal Beach, California 90740                       *\n         *            (310) 797-1125                                     *\n         *            IBMMail:  USROKNTN                                 *\n         *            Internet: lbd@osreq48.rockwell.com                 *\n         *            IBMLINK:  ROK2027                                  *\n         *                                                               *\n         * History:                                                      *\n         *           02/22/96 - display dialog even if dsname provided   *\n         *           09/26/94 - minor bug fix in parse                   *\n         *           09/02/94 - Reset LPRPRINT lprps to no               *\n         *           08/25/94 - Fix test for options                     *\n         *           04/27/94 - Add prompt option                        *\n         *           01/26/94 - updated to support non-ISPF usage        *\n         *           01/20/94 - created for TSO/ISPF                     *\n         *                                                               *\n         * Originally based upon the PSPRINT.cmd                         *\n         * Written by Michael Perks (10/31/92)                           *\n         * (c) Copyright IBM Corp. 1992 All Rights Reserved              *\n         * modified to allow an option of lptn                           *\n         *                                                               *\n         * modified to run under MVS TSO/E by Lionel Dyck                *\n         * to use PostScript programming by Carl J. Lydick               *\n         * of CalTech picked up from comp.lang.postscript.               *\n         *                                                               *\n         * This eliminates the calculation of line placement and         *\n         * page ejects and provides the following options:               *\n         *                                                               *\n         * PORT -  Portrait 80 characters by 60 lines in 11 pt. Courier  *\n         * WIDE -  Portrait 132 characters by 103 lines in 6 pt. Courier *\n         * LAND -  Landscape 132 characters by 60 lines in 9 pt. Courier *\n         * 2UP  -  2 pages 80 characters by 66 lines side by side        *\n         *         in landscape in 6 pt. Courier                         *\n         *                                                               *\n         * ------------------------------------------------------------- */\n\n        parse arg psinds outname \"/\" options\n\n        outname = translate(strip(outname))\n\n        if length(psinds) >= 0 then prompt = 1\n        if outname        = \"@\" then prompt = 1\n           else if length(outname) > 0 then prompt = 0\n        if length(options) > 0 then prompt = 0\n\n        cmd = sysvar(\"sysicmd\")\n        spf = sysvar(\"sysispf\")\n\n        if prompt = 1 then do forever\n           if spf <> \"ACTIVE\" then do\n              say cmd\": Not running under ISPF and no parameters specified\"\n              say cmd\": terminating - review the documentation and retry.\"\n              exit 8\n              end\n           Address ISPEXEC\n           \"Display Panel(PSPRINT0)\"\n           if rc > 3 then exit\n           if lpr = \"No\" then lpr = \"NOLPR\"\n                         else lpr = \"\"\n           if \"OK\" <> sysdsn(psinds) then do\n               smsg = \"Error\"\n               lmsg = sysdsn(psinds)\n               \"Vput (Smsg Lmsg)\"\n               \"Setmsg Msg(Pspr002)\"\n                end\n           else call test_pds\n        end\n\n        if length(options) > 0 then\n           options = translate(options)\n\n        /* test options for debug */\n        if wordpos(\"DEBUG\",options) > 1 then do\n           trace \"?i\"\n           x = wordpos(\"DEBUG\",options)\n           new_opt = delword(options,x,1)\n           options = new_opt\n           end\n\n        /* test options for nolpr */\n        if wordpos(\"NOLPR\",options) > 1 then do\n           no_lpr = \"on\"\n           no_del = \"on\"\n           x = wordpos(\"NOLPR\",options)\n           new_opt = delword(options,x,1)\n           options = new_opt\n           end\n\n        if spf <> \"ACTIVE\" then no_lpr = \"on\"\n\n        if length(outname) = 0 then do\n           d = date(u)\n           date = substr(d,7,2)substr(d,1,2)substr(d,4,2)\n           s = time(\"L\")  /* get the current time hh:mm:ss.th */\n           t = substr(s,1,2)substr(s,4,2)substr(s,7,2)substr(s,10,1)\n           prefix = sysvar(syspref)\n           pscript_dsn = \"'\"prefix\".pscript.D\"date\".T\"t\".ps'\"\n           end\n        else do\n             pscript_dsn = outname\n             no_del = \"on\"\n             end\n\n        out. = \"\"\n\n        Select\n          When options = \"PORT\" then call do_port\n          When options = \"WIDE\" then call do_wide\n          When options = \"LAND\" then call do_land\n          When options = \"2UP\"  then call do_2up\n          Otherwise call do_port\n          end\n\n        /* test the existence of the input data set */\n        if \"OK\" <> sysdsn(psinds) then\n        do\n            smsg = \"Error\"\n            lmsg = sysdsn(psinds)\n            call do_msg\n            exit\n        end\n\n        x = listdsi(psinds)\n        if pos(\"(\",psinds) > 0 then sysdsorg = \"PS\"\n        if sysdsorg = \"PO\" then do\n           if spf <> \"ACTIVE\" then do\n              say cmd\": Has specified a partitioned data set:\",\n                        psinds\n              say cmd\": which is not supported by this command\",\n                     \"outside of the ISPF enviornment.\"\n              say cmd\": Terminating processing.  Specify a member\",\n                     \"name and retry.\"\n              exit\n              end\n           Address ISPEXEC\n           call do_pds\n           exit\n           end\n\n        /* generate a ddname and dynamically allocate the output\n           data set. */\n        pscript_odd = \"PSXO\"random()\n        \"Alloc f(\"pscript_odd\") ds(\"pscript_dsn\") New Spa(30,30) Tr\",\n              \"Recfm(V B) Lrecl(255) Blksize(0) Dsorg(PS)\"\n\n        /* read each line, quote characters and then output */\n        pscript_idd = \"PSXi\"random()\n        \"Alloc f(\"pscript_idd\") ds(\"psinds\") Shr\"\n        \"Execio * diskr\" pscript_idd \"(Finis stem in.\"\n        \"Free f(\"pscript_idd\")\"\n\n        \"Execio * diskw\" pscript_odd \"(stem out.\"\n        \"Execio * diskw\" pscript_odd \"(Finis stem in.\"\n        \"Free f(\"pscript_odd\")\"\n\n        drop out. in.\n\n        if no_lpr <> \"on\" then do\n          if spf = \"ACTIVE\" then do\n             Address ISPEXEC \"Vget (lprps) Profile\"\n             hold_lprps = lprps\n             lprps = \"No\"\n             Address ISPEXEC \"Vput (lprps) Profile\"\n             end\n          \"%lprprint\" pscript_dsn\n          lprps = hold_lprps\n          if spf = \"ACTIVE\" then\n             Address ISPEXEC \"Vput (lprps) Profile\"\n          end\n\n        x = msg(\"OFF\")\n        if no_del <> \"on\" then\n          \"Delete\" pscript_dsn\n          else do\n            smsg = \"\"\n            lmsg = \"Output dsname is:\" pscript_dsn\n            call do_msg\n            end\n\n        exit\n\n        do_msg:\n            if spf = \"ACTIVE\" then do\n               Address ISPEXEC\n               \"Vput (Smsg Lmsg)\"\n               \"Setmsg Msg(Pspr002)\"\n               end\n            else do\n                 say smsg\n                 say lmsg\n                 end\n            return\n\n        do_port:\n\n        do_port:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 11 scalefont setfont\"\n        out.6 = \"/P {showpage /H 750 def} def\"\n        out.7 = \"/Q { 36 H moveto dup length 80 gt {0 80 getinterval}\",\n                \" if show /H H 12 sub def\"\n        out.8 = \"   H 30 le {P} if} def\"\n        out.9 = \"/R 0 def\"\n        out.10 = \"/S 512 string def\"\n        out.11 = '/T {(\", FF, \") search {R 0 ne {Q pop P} {pop pop /R 1 def}',\n                \" ifelse T} if} def\"\n        out.12 = \"/L {/H 750 def {currentfile S readline not {exit} if T Q}\",\n                \" loop showpage} def\"\n        out.13 = \"L\"\n        out.0 = 13\n        return\n\n        do_wide:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 6 scalefont setfont\"\n        out.6 = \"/P {showpage /H 750 def} def\"\n        out.7 = \"/Q { 36 H moveto dup length 132 gt {0 132 getinterval}\",\n                \" if show /H H 7 sub def\"\n        out.8 = \"   H 30 le {P} if} def\"\n        out.9 = \"/R 0 def\"\n        out.10 = \"/S 512 string def\"\n        out.11 = '/T {(\", FF, \") search {R 0 ne {Q pop P}',\n                 \" {pop pop /R 1 def} ifelse T} if} def\"\n        out.12 = \"/L {/H 750 def {currentfile S readline not\",\n                 \" {exit} if T Q} loop showpage} def\"\n        out.13 = \"L\"\n        out.0 = 13\n        return\n\n        do_land:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 9 scalefont setfont\"\n        out.6 = \"/P {showpage 90 rotate 0 -618 translate /H 594 def} def\"\n        out.7 = \"/Q {36 H moveto dup length 132 gt {0 132 getinterval}\",\n                \" if show /H H 9.5 sub def\"\n        out.8 = \"    H 30 le {P} if} def\"\n        out.9 = \"/R 0 def\"\n        out.10 = \"/S 512 string def\"\n        out.11 = '/T {(\", FF, \") search {R 0 ne {Q pop P}',\n                 \" {pop pop /R 1 def} ifelse T} if} def\"\n        out.12 = \"/L {90 rotate 0 -618 translate /H 594 def\",\n                 \" {currentfile S readline not {exit} if\"\n        out.13 = \" T Q} loop showpage} def\"\n        out.14 = \"L\"\n        out.0 = 14\n        return\n\n        do_2up:\n        out.1 = \"%!PS-Adobe-1.0\"\n        out.2 = \"%%Creator: Carl J Lydick\"\n        out.3 = \"%%DocumentFonts: Courier\"\n        out.4 = \"%%Pages: (atend)\"\n        out.5 = \"/Courier findfont 6 scalefont setfont\"\n        out.6 = \"/N {showpage 90 rotate 0 -618 translate /H 538\",\n                \" def /V 71 def} def\"\n        out.7 = \"/O {/H 538 def /V 431 def} def\"\n        out.8 = \"/P {V 431 ne {O} {N} ifelse} def\"\n        out.9 = \"/Q { V H moveto dup length 80 gt {0 80 getinterval}\",\n                \" if show /H H 7 sub def\"\n        out.10 = \"   H 79 le {P} if} def\"\n        out.11 = \"/R 0 def\"\n        out.12 = \"/S 512 string def\"\n        out.13 = '/T {(\", FF, \") search {R 0 ne {Q pop P} {pop pop',\n                 \" /R 1 def} ifelse T} if} def\"\n        out.14 = \"/L {90 rotate 0 -618 translate /H 538 def /V 71 def\"\n        out.15 = \"   {currentfile S readline not {exit} if T Q}\",\n                 \" loop showpage} def\"\n        out.16 = \"L\"\n        out.0 = 16\n        return\n\n        test_pds:\n              x = listdsi(psinds)\n              if pos(\"(\",psinds) > 0 then sysdsorg = \"PS\"\n              Select\n                When sysdsorg = \"PS\" | pos(\"(\",psinds) > 1\n                     then\n                     \"Select Cmd(%\"cmd  psinds psopds \"/\" pstype lpr \")\"\n                When sysdsorg = \"PO\"\n                     then call do_pds\n                Otherwise nop;\n              end\n        return\n\n        do_pds:\n            \"Lminit Dataid(dataid) Dataset(\"psinds\") Enq(Shrw)\"\n            \"Lmopen Dataid(\"dataid\") Option(Input)\"\n            \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n              \"Commands(Any) Panel(PsprM)\"\n              do while rc == 0\n                 Call process_selection\n                \"Lmmdisp Dataid(\"dataid\") Option(Get)\"\n                 if rc == 8\n                    then \"Lmmdisp Dataid(\"dataid\") Option(Display)\",\n                         \"Commands(Any) Panel(LPRPM)\"\n              end\n              \"Lmmdisp Dataid(\"dataid\") Option(Free)\"\n              \"Lmclose Dataid(\"dataid\")\"\n              \"Lmfree  Dataid(\"dataid\")\"\n            return\n\n         process_selection:\n            if left(psinds,1) = \"'\"\n               then parse value psinds with \"'\" w_dsn \"'\"\n               else w_dsn = sysvar(\"syspref\")\".\"psinds\n            zlmember = strip(zlmember)\n            Select\n            When zllcmd = \"/\" | zllcmd = \"S\"\n            Then do\n              \"Lmmdisp Dataid(\"dataid\") Option(Put) Member(\"zlmember\")\",\n                  \"Zludata(printed)\"\n              \"Select Cmd(%\"cmd  \"'\"w_dsn\"(\"zlmember\")'\",\n                  psopds \"/\" pstype lpr \")\"\n              end\n            When zllcmd = \"B\"\n            Then \"Browse Dataid(\"dataid\") Member(\"zlmember\")\"\n            Otherwise nop;\n            End\n            return\n./ ADD NAME=PSPRINT0 0107-94025-96003-1024-00055-00047-00000-PANEL\n)Attr\n   @ type( input) intens(high) caps(off) just(left ) pad('_')\n     color(white)\n   ! type( input) intens(high) caps(off) just(left ) color(white)\n   _ type( input) intens(high) caps(on ) just(left ) color(white)\n   \u00ac type(text) intens(low ) caps(off) just(asis ) color(white)\n         hilite(uscore)\n   | type(text) intens(high) caps(off) just(asis ) color(white)\n         hilite(uscore)\n   # type(text) intens(high) caps(on) just(left ) color(yellow)\n         hilite(uscore)\n   ` type(text) intens(high) caps(off) just(asis ) color(turq)\n   ~ type(text) intens(low ) caps(off) just(asis ) color(turq)\n   % type(text) intens(low ) caps(off) just(asis ) color(white)\n)Body\n+------------------------% Convert text to PostScript +-------------------------\n%Command ===>_zcmd\n\n`Enter/Verify:\n`\n`    Input Data Set      %===>_psinds\n%\n`    Print orientation   %===>!pstype+    see list below\n%\n`    Invoke LPRPRINT     %===>!lpr+       Yes or No\n`\n`    Output Data Set     %===>_psopds\n`    (optional)\n`\n`    Valid orientations:\n`          PORT+-  Portrait 80 characters by 60 lines in 11 pt. Courier\n`          WIDE+-  Portrait 132 characters by 103 lines in 6 pt. Courier\n`          LAND+-  Landscape 132 characters by 60 lines in 9 pt. Courier\n`          2UP +-  2 pages 80 characters by 66 lines side by side\n`              +   in landscape in 6 pt. Courier\n)Init\n .HELP = psprh0\n .cursor  = psinds\n &pstype= trans(trunc(&pstype,1)\n            P,Port p,Port L,Land l,Land, W,Wide w,Wide 2,2UP &z,Port)\n &lpr     = trans(trunc(&lp,1) Y,Yes N,No y,Yes n,No &z,Yes)\n)Reinit\n .cursor  = psinds\n &pstype= trans(trunc(&pstype,1)\n            P,Port p,Port L,Land l,Land, W,Wide w,Wide 2,2UP &z,Port)\n &lpr     = trans(trunc(&lp,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n)Proc\n &pstype= trans(trunc(&pstype,1) P,Port p,Port L,Land l,Land,\n                                     W,Wide w,Wide 2,2UP &z,Port *,*)\n &lpr     = trans(trunc(&lp,1) Y,Yes N,No y,Yes n,No &z,Yes *,*)\n ver (&psinds,nonblank,dsname,msg=pspr001)\n ver (&pstype,nb,list,Port,Land,Wide,2UP)\n ver (&lpr,nb,list,Yes,No)\n ver (&psopds,dsname,msg=pspr003)\n)End\n./ ADD NAME=PSPRM    0101-94013-94018-0732-00031-00030-00000-PANEL\n)ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH)\n  | AREA(DYNAMIC) SCROLL(ON) EXTEND(ON)\n  + TYPE(TEXT) INTENS(LOW)\n  \u00a2 TYPE(OUTPUT) INTENS(HIGH) JUST(RIGHT) PAD(0)\n 01 TYPE(DATAIN) INTENS(HIGH) CAPS(ON)\n 02 TYPE(DATAOUT) INTENS(LOW)\n 03 TYPE(DATAIN)  INTENS(HIGH) CAPS(ON)\n 04 TYPE(DATAOUT)  INTENS(LOW)\n 05 TYPE(DATAOUT)  INTENS(HIGH)\n 06 TYPE(DATAOUT)  INTENS(LOW)\n)BODY WIDTH(80)\n%Member List -- &ZDSN --------------------------------------%ROW\u00a2ZMLCR%OF\u00a2ZMLTR+\n%Command ===>_ZCMD                                            %Scroll ===>_Z   +\n%Commands:      LOCATE, RESET, SELECT, SORT, HELP                              +\n%Line commands: / or S = Select, B = Browse                                    +\n&ZMLCOLS\n|ZDATA ------------------------------------------------------------------------|\n|                                                                              |\n| -----------------------------------------------------------------------------|\n)INIT\n  .ZVARS = 'ZSCML'         /* SCROLL AMT VARIABLE NAME  */\n  .HELP = ISR01130\n)PROC\n  VPUT (ZSCML) PROFILE\n)END\n /*  $M1= MEMLIST   M230     860923   158590 : FUNCTION TEST          */\n /*   PTM00000184                                                     */\n /*                                                                   */\n /*   CHANGED 3 LINES                                            3@M1C*/\n/* 5665-402 (C) COPYRIGHT IBM CORP 1980, 1989 */\n./ ADD NAME=PSPR00   0100-14080-14080-1041-00006-00006-00000-MSGS\nPSPR001\n'Input data set name must be specified and must be a valid dsname'\nPSPR002 '&SMSG' .WINDOW=NORESP .TYPE=NOTIFY\n'&LMSG'\nPSPR003\n'Output data set name, if specified, must be a valid dsname'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QTAB": {"ttr": 33031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00V\\x01\\x18\\x10?\\x01 4/\\x12\\x19\\x02\\xc7\\x01\\xf3\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2018-04-13T00:00:00", "modifydate": "2020-12-07T12:19:56", "lines": 711, "newlines": 499, "modlines": 0, "user": "SLBD"}, "text": "  /* --------------------  rexx procedure  -------------------- */\n  ver = '1.8'\n  /*Name:      QTAB                                            |\n  |                                                            |\n  | Function:  Display Open ISPF Tables                        |\n  |                                                            |\n  | Syntax:    %QTAB table-name                                |\n  |                                                            |\n  |            table-name (optional)                           |\n  |            - limit the display to that table               |\n  |                                                            |\n  | Usage Notes: Used to display open ispf tables              |\n  |                                                            |\n  | Author:    Lionel B. Dyck                                  |\n  |                                                            |\n  | History:  (most recent on top)                             |\n  |            12/07/20 - Fix header alignment                 |\n  |                     - If table date/time null set 'N/A'    |\n  |            12/04/20 - Fix unknown zcmd processing          |\n  |            11/12/20 - Add Find/RFind for selected Table    |\n  |            03/07/20 - Enable RFIND                         |\n  |            01/29/20 - Expand table name by 1               |\n  |            01/08/20 - Add table-name option                |\n  |                     - Find now more like locate with *     |\n  |            01/06/20 - Add find command                     |\n  |            10/21/19 - Add option to Select a table to      |\n  |                       view specifics (not pretty but works)|\n  |            04/13/18 - Update to fit in 80 bytes            |\n  |            02/28/18 - Change tbend to tbclose              |\n  |            11/02/16 - Add tutorial panel (short/sweet)     |\n  |                     - Change table name color              |\n  |            11/01/16 - Creation                             |\n  |                                                            |\n  * ---------------------------------------------------------- */\n\n  arg table_name\n\n  /* ------------------------------------ *\n  | Define Address and query open tables |\n  * ------------------------------------ */\n  Address ISPExec\n  'Control Errors Return'\n  'qtabopen list(tabs)'\n  null = ''\n\n  /* --------------> Enable Repeat Find <------------------- *\n  | This approach does not require recursion or creating an |\n  | ISPF table for the applications commands. This approach |\n  | updates the active site command table in memory.        |\n  |                                                         |\n  | This does:                                              |\n  | 1. Define the commmand table entry                      |\n  | 2. vget the variable with the prefix for the site ISPF  |\n  |    command table.                                       |\n  | 3. define a varable with the command table name         |\n  | 4. Move to the top of the command table                 |\n  | 5. Establish the table search                           |\n  | 6. if the entry is found then add it                    |\n  | 7. prime the variable to null                           |\n  * ------------------------------------------------------- */\n  zctverb = 'RFIND'\n  zctact = \"&USRRFIND\"\n  zctdesc = \"User controlled Repeat Find (RFIND)\"\n  zcttrunc = 0\n  'vget (zsctpref)'\n  ctab = zsctpref'cmds'\n  'tbtop' ctab\n  'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'\n  if rc > 0 then 'tbadd' ctab\n  usrrfind = null\n  'vput (usrrfind)'\n\n  /* ----------------------------------- *\n  | Build ISPF Table for List of Tables |\n  * ----------------------------------- */\n  qtab = 'QTAB'random(9999)\n  'TBCreate' qtab 'Names(tab cdate ctime udate utime user rowcreat' ,\n    'rowcurr rowupd tableupd status1 status2 keysn namesn' ,\n    'status3 library virtsize keys names) nowrite'\n\n  /* ------------------------------------ *\n  | Now add the open tables to our table |\n  * ------------------------------------ */\n  interpret 'count = tabs0'\n  do i = 1 to count\n    interpret 'tab =  tabs'i\n    if table_name /= null\n    then if tab /= table_name then iterate\n    parse value '' with cdate ctime udate utime user rowcreat ,\n      rowcurr rowupd tableupd status1 status2 ,\n      status3 library virtsize keys names\n    /* ------------------------------------- *\n    | Get number of keys and names in table |\n    * ------------------------------------- */\n    'tbquery' tab 'keynum(keysn) namenum(namesn)' ,\n      'keys(keys) names(names)'\n    /* -------------------- *\n    | Get Table Statistics |\n    * -------------------- */\n    'tbstats' tab 'cdate(cdate) ctime(ctime) udate(udate) utime(utime)' ,\n      'user(user) rowcreat(rowcreat) rowcurr(rowcurr)' ,\n      'rowupd(rowupd) tableupd(tableupd)' ,\n      'status1(status1) status2(status2) status3(status3)' ,\n      'library(library) virtsize(virtsize)'\n    if strip(library)     = '' then library = 'ISPTLIB'\n    /* -------------------------------- *\n    | Clean up the numbers by adding 0 |\n    * -------------------------------- */\n    if pos('/',cdate) = 0 then cdate = 'N/A'\n    if pos(':',ctime) = 0 then ctime = 'N/A'\n    if datatype(keysn)    = 'NUM' then keysn = keysn + 0\n    if datatype(namesn)   = 'NUM' then namesn = namesn + 0\n    if datatype(rowcreat) = 'NUM' then rowcreat = rowcreat + 0\n    if datatype(rowcurr)  = 'NUM' then rowcurr = rowcurr + 0\n    if datatype(rowupd)   = 'NUM' then rowupd = rowupd + 0\n    if datatype(tableupd) = 'NUM' then tableupd = tableupd + 0\n    if datatype(virtsize) = 'NUM' then virtsize = virtsize + 0\n    /* ------------------------------ *\n    | Now translate the table status |\n    * ------------------------------ */\n    Select\n      When status1 = 1 then\n      status1 = 'Table exists in the table input library chain'\n      When status1 = 2 then\n      status1 = 'Table does not exist in the table input library chain'\n      When status1 = 3 then\n      status1 = 'Table input library is not allocated'\n      Otherwise nop\n    end\n    Select\n      When status2 = 1 then\n      status2 = 'Table is not open in this logical screen'\n      When status2 = 2 then\n      status2 = 'Table is open in NOWRITE mode in this logical screen'\n      When status2 = 3 then\n      status2 = 'Table is open in WRITE mode in this logical screen'\n      When status2 = 4 then\n      status2 = 'Table is open in SHARED NOWRITE mode in this logical' ,\n        'screen'\n      When status2 = 5 then\n      status2 = 'Table is open in SHARED WRITE mode in this logical' ,\n        'screen'\n      Otherwise nop\n    end\n    Select\n      When status3 = 1 then\n      status3 = 'Table is available for WRITE mode'\n      When status3 = 2 then\n      status3 = 'Table is not available for WRITE mode'\n      Otherwise nop\n    end\n    /* --------------------------------------- *\n    | Finally add the table info to our table |\n    * --------------------------------------- */\n    'tbadd' qtab\n  end\n\n  /* ---------------------------------- *\n  | Reposition to the top of the table |\n  | and sort it.                       |\n  * ---------------------------------- */\n  'TBTop' qtab\n  'TBSort' qtab 'Fields(tab)'\n\n  /* ---------------------- *\n  | Load the ISPF Panel(s) |\n  * ---------------------- */\n  load_info = loadispf()\n\n  /* ------------------------------- *\n  | Now display the table of tables |\n  * ------------------------------- */\n  top = 0\n  do forever\n    /* -------------------------------------------- *\n    | Define USRRFIND for Passthru to enable RFIND |\n    * -------------------------------------------- */\n    usrrfind = 'PASSTHRU'\n    'vput (usrrfind)'\n    sel = null\n    if top > 0 then do\n      'tbtop' qtab\n      'tbskip' qtab 'number('top')'\n    end\n    'TBDispl' qtab 'Panel(qtab)'\n    trc = rc\n    /* ----------------------- *\n    | Reset USRRFIND to blank |\n    * ----------------------- */\n    usrrfind = ''\n    'vput (usrrfind)'\n    if trc > 0 then leave\n\n    top = ztdtop\n    if zcmd /= null then do\n      zcmd = translate(zcmd)\n      if word(zcmd,1) = 'RFIND' then do\n        'tbtop' qtab\n        'tbskip' qtab 'number('top')'\n        zcmd = 'F' ftab\n      end\n      if word(zcmd,1) = 'F' then do\n        ftab = word(zcmd,2)\n        if pos('*',ftab) > 0 then do\n          ftab = strip(translate(ftab,' ','*'))\n        end\n        wrap = 0\n        do forever\n          'tbskip' qtab\n          'tbget' qtab\n          if rc > 0 then do\n            if wrap = 1 then leave\n            'tbtop' qtab\n            wrap = 1\n          end\n          if pos(ftab,tab) > 0 then do\n            'tbquery' qtab 'position(top)'\n            if wrap = 1 then do\n              zedsmsg = 'Wrapped.'\n              zedlmsg = 'Found the requested table.'\n            end\n            else do\n              zedsmsg = 'Found.'\n              zedlmsg = 'Found the requested table.'\n            end\n            'setmsg msg(isrz001)'\n            leave\n          end\n        end\n      end\n    end\n    else if sel /= null then call do_table\n  end\n\n  /* ---------------------- *\n  | Done so tbclose and Exit |\n  * ---------------------- */\n  'tbclose' qtab\n  do until length(load_info) = 0\n    parse value load_info with dd libd load_info\n    \"libdef\" libd\n    address tso \"free f(\"dd\")\"\n  end\n  exit\n\nDo_Table:\n  vtab = 'VTAB'random(9999)\n  'TBSTATS' tab 'STATUS2(OPEN)'\n  'TBQUERY' tab 'KEYS(K) NAMES(N) ROWNUM(R)'\n  if rc > 0 then do\n    zedsmsg = 'Error.'\n    zedlmsg = 'Unable to query the table.'\n    'setmsg msg(isrz001)'\n    return\n  end\n  if k = null then\n  if n = null then do\n    zedsmsg = 'Warning.'\n    zedlmsg = 'Unable to query the table.'\n    'setmsg msg(isrz001)'\n    return\n  end\n  'tbcreate' vtab 'Names(vrow vname vdesc) nowrite'\n  parse var k '(' k ')'\n  parse var n '(' n ')'\n  'TBTOP' tab\n  do it = 1 to r\n    'TBSKIP' tab\n    'TBGET' tab 'ROWID(P)'\n    vrow = right(p,6)\n    if words(k) > 0 then do j=1 to words(k)\n      vname = word(k,j)\n      vdesc = value(vname)\n      'tbadd' vtab\n    end\n    if words(n) > 0 then do j=1 to words(n)\n      vname = word(n,j)\n      vdesc = value(vname)\n      'tbadd' vtab\n    end\n  end\n  'tbtop' vtab\n  do forever\n    usrrfind = 'PASSTHRU'\n    'vput (usrrfind)'\n    'tbdispl' vtab 'Panel(vtab)'\n    tbrc = rc\n    usrrfind = ''\n    'vput (usrrfind)'\n    if tbrc > 0 then leave\n    if zcmd = 'RFIND' then do\n      'tbtop' vtab\n      'tbskip' vtab 'number('top')'\n      zcmd = 'F' ftab\n    end\n    if abbrev('FIND',word(zcmd,1),1) = 1 then do\n      wrap = 0\n      ftab = subword(zcmd,2)\n      do forever\n        'tbskip' vtab\n        'tbget' vtab\n        if rc > 0 then do\n          if wrap = 1 then leave\n          'tbtop' vtab\n          wrap = 1\n        end\n        if pos(ftab,translate(vname vdesc)) > 0 then do\n          'tbquery' vtab 'position(top)'\n          if wrap = 1 then do\n            zedsmsg = 'Wrapped.'\n            zedlmsg = 'Found the requested table.'\n          end\n          else do\n            zedsmsg = 'Found.'\n            zedlmsg = 'Found the requested table.'\n          end\n          'setmsg msg(isrz001)'\n          leave\n        end\n      end\n    end\n  end\n  'tbend' vtab\n  return\n\n  /* --------------------  rexx procedure  -------------------- *\n  * Name:      LoadISPF                                        *\n  *                                                            *\n  * Function:  Load ISPF elements that are inline in the       *\n  *            REXX source code.                               *\n  *                                                            *\n  * Syntax:    load_info = loadispf()                          *\n  *                                                            *\n  *            The inline ISPF resources are limited to        *\n  *            ISPF Messages, Panels, and Skeletons,           *\n  *                 CLISTs and EXECs are also supported.       *\n  *                                                            *\n  *            The inline resources must start in column 1     *\n  *            and use the following syntax:                   *\n  *                                                            *\n  *            >START    used to indicate the start of the     *\n  *                      inline data                           *\n  *                                                            *\n  *            >END    - used to indicate the end of the       *\n  *                      inline data                           *\n  *                                                            *\n  *            Each resource begins with a type record:        *\n  *            >type name                                      *\n  *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *\n  *                     name is the name of the element        *\n  *                                                            *\n  * Sample usage:                                              *\n  *          -* rexx *-                                        *\n  *          load_info = loadispf()                            *\n  *          ... magic code happens here (your code) ...       *\n  *          Address ISPEXEC                                   *\n  *          do until length(load_info) = 0                    *\n  *             parse value load_info with dd libd load_info   *\n  *             if left(libd,6) = \"ALTLIB\" then do             *\n  *                if libd = \"ALTLIBC\" then lib = \"CLIST\"      *\n  *                                    else lib = \"EXEC\"       *\n  *                Address TSO,                                *\n  *                  \"Altlib Deact Application(\"lib\")\"         *\n  *                end                                         *\n  *             else \"libdef\" libd                             *\n  *             address tso \"free f(\"dd\")\"                     *\n  *             end                                            *\n  *          exit                                              *\n  *          >Start inline elements                            *\n  *          >Panel panel1                                     *\n  *          ...                                               *\n  *          >Msg msg1                                         *\n  *          ...                                               *\n  *          >End of inline elements                           *\n  *                                                            *\n  * Returns:   the list of ddnames allocated for use along     *\n  *            with the libdef's performed or altlib           *\n  *                                                            *\n  *            format is ddname libdef ddname libdef ...       *\n  *                   libdef may be altlibc or altlibe         *\n  *                   for altlib clist or altlib exec          *\n  *                                                            *\n  * Notes:     Entire routine must be included with REXX       *\n  *            exec - inline with the code.                    *\n  *                                                            *\n  * Comments:  The entire rexx program is processed from the   *\n  *            last record to the first to find the >START     *\n  *            record at which point all records from that     *\n  *            point on are processed until the >END           *\n  *            statement or the end of the program is found.   *\n  *                                                            *\n  *            It is *strongly* suggested that the inline      *\n  *            elements be at the very end of your code so     *\n  *            that the search for them is faster.             *\n  *                                                            *\n  *            Inline ISPTLIB or ISPLLIB were not supported    *\n  *            because the values for these would have to be   *\n  *            in hex.                                         *\n  *                                                            *\n  * Author:    Lionel B. Dyck                                  *\n  *                                                            *\n  * History:                                                   *\n  *            05/10/16 - correction for clist and exec        *\n  *            04/19/16 - bug correction                       *\n  *            06/04/04 - Enhancements for speed               *\n  *            08/05/02 - Creation                             *\n  *                                                            *\n  * ---------------------------------------------------------- *\n  * Disclaimer: There is no warranty, either explicit or       *\n  * implied with this code. Use it at your own risk as there   *\n  * is no recourse from either the author or his employeer.    *\n  * ---------------------------------------------------------- */\nLoadISPF: Procedure\n\n  parse value \"\" with null kmsg kpanel kskel first returns ,\n    kclist kexec\n  /* ------------------------------------------------------- *\n  * Find the InLine ISPF Elements and load them into a stem *\n  * variable.                                               *\n  *                                                         *\n  * Elements keyword syntax:                                *\n  * >START - start of inline data                           *\n  * >CLIST name                                             *\n  * >EXEC name                                              *\n  * >MSG name                                               *\n  * >PANEL name                                             *\n  * >SKEL name                                              *\n  * >END   - end of all inline data (optional if last)      *\n  * ------------------------------------------------------- */\n  last_line = sourceline()\n  do i = last_line to 1 by -1\n    line = sourceline(i)\n    if translate(left(line,6)) = \">START \" then leave\n  end\n  rec = 0\n  /* --------------------------------------------------- *\n  * Flag types of ISPF resources by testing each record *\n  * then add each record to the data. stem variable.    *\n  * --------------------------------------------------- */\n  do j = i+1 to last_line\n    line = sourceline(j)\n    if translate(left(line,5)) = \">END \"   then leave\n    if translate(left(line,7)) = \">CLIST \" then kclist = 1\n    if translate(left(line,6)) = \">EXEC \"  then kexec  = 1\n    if translate(left(line,5)) = \">MSG \"   then kmsg   = 1\n    if translate(left(line,7)) = \">PANEL \" then kpanel = 1\n    if translate(left(line,6)) = \">SKEL \"  then kskel  = 1\n    rec  = rec + 1\n    data.rec = line\n  end\n\n  /* ----------------------------------------------------- *\n  * Now create the Library and Load the Member(s)         *\n  * ----------------------------------------------------- */\n  Address ISPExec\n  /* ----------------------------- *\n  * Assign dynamic random ddnames *\n  * ----------------------------- */\n  clistdd = \"lc\"random(999)\n  execdd  = \"le\"random(999)\n  msgdd   = \"lm\"random(999)\n  paneldd = \"lp\"random(999)\n  skeldd  = \"ls\"random(999)\n\n  /* ---------------------------------------- *\n  *  LmInit and LmOpen each resource library *\n  * ---------------------------------------- */\n  if kclist <> null then do\n    call alloc_dd clistdd\n    \"Lminit dataid(clist) ddname(\"clistdd\")\"\n    \"LmOpen dataid(\"clist\") Option(Output)\"\n    returns = strip(returns clistdd 'ALTLIBC')\n  end\n  if kexec <> null then do\n    call alloc_dd execdd\n    \"Lminit dataid(exec) ddname(\"execdd\")\"\n    \"LmOpen dataid(\"exec\") Option(Output)\"\n    returns = strip(returns execdd 'ALTLIBE')\n  end\n  if kmsg <> null then do\n    call alloc_dd msgdd\n    \"Lminit dataid(msg) ddname(\"msgdd\")\"\n    \"LmOpen dataid(\"msg\") Option(Output)\"\n    returns = strip(returns msgdd 'ISPMLIB')\n  end\n  if kpanel <> null then do\n    call alloc_dd paneldd\n    \"Lminit dataid(panel) ddname(\"paneldd\")\"\n    \"LmOpen dataid(\"panel\") Option(Output)\"\n    returns = strip(returns paneldd 'ISPPLIB')\n  end\n  if kskel <> null then do\n    call alloc_dd skeldd\n    \"Lminit dataid(skel) ddname(\"skeldd\")\"\n    \"LmOpen dataid(\"skel\") Option(Output)\"\n    returns = strip(returns skeldd 'ISPSLIB')\n  end\n\n  /* ----------------------------------------------- *\n  * Process all records in the data. stem variable. *\n  * ----------------------------------------------- */\n  do i = 1 to rec\n    record = data.i\n    recordu = translate(record)\n    if left(recordu,5) = \">END \" then leave\n    if left(recordu,7) = \">CLIST \" then do\n      if first = 1 then call add_it\n      type = \"Clist\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">EXEC \" then do\n      if first = 1 then call add_it\n      type = \"Exec\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,5) = \">MSG \" then do\n      if first = 1 then call add_it\n      type = \"Msg\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,7) = \">PANEL \" then do\n      if first = 1 then call add_it\n      type = \"Panel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    if left(recordu,6) = \">SKEL \" then do\n      if first = 1 then call add_it\n      type = \"Skel\"\n      first = 1\n      parse value record with x name\n      iterate\n    end\n    /* --------------------------------------------*\n    * Put the record into the appropriate library *\n    * based on the record type.                   *\n    * ------------------------------------------- */\n    Select\n      When type = \"Clist\" then\n      \"LmPut dataid(\"clist\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Exec\" then\n      \"LmPut dataid(\"exec\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(255)\"\n      When type = \"Msg\" then\n      \"LmPut dataid(\"msg\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Panel\" then\n      \"LmPut dataid(\"panel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      When type = \"Skel\" then\n      \"LmPut dataid(\"skel\") MODE(INVAR)\" ,\n        \"DataLoc(record) DataLen(80)\"\n      Otherwise nop\n    end\n  end\n  if type <> null then call add_it\n  /* ---------------------------------------------------- *\n  * Processing completed - now lmfree the allocation and *\n  * Libdef the library.                                  *\n  * ---------------------------------------------------- */\n  if kclist <> null then do\n    Address TSO,\n      \"Altlib Act Application(Clist) File(\"clistdd\")\"\n    \"LmFree dataid(\"clist\")\"\n  end\n  if kexec <> null then do\n    Address TSO,\n      \"Altlib Act Application(Exec) File(\"execdd\")\"\n    \"LmFree dataid(\"exec\")\"\n  end\n  if kmsg <> null then do\n    \"LmFree dataid(\"msg\")\"\n    \"Libdef ISPMlib Library ID(\"msgdd\") Stack\"\n  end\n  if kpanel <> null then do\n    \"Libdef ISPPlib Library ID(\"paneldd\") Stack\"\n    \"LmFree dataid(\"panel\")\"\n  end\n  if kskel <> null then do\n    \"Libdef ISPSlib Library ID(\"skeldd\") Stack\"\n    \"LmFree dataid(\"skel\")\"\n  end\n  return returns\n\n  /* --------------------------- *\n  * Add the Member using LmmAdd *\n  * based upon type of resource *\n  * --------------------------- */\nAdd_It:\n  if type = \"Clist\" then\n  \"LmmAdd dataid(\"clist\") Member(\"name\")\"\n  if type = \"Exec\" then\n  \"LmmAdd dataid(\"exec\") Member(\"name\")\"\n  if type = \"Msg\" then\n  \"LmmAdd dataid(\"msg\") Member(\"name\")\"\n  if type = \"Panel\" then\n  \"LmmAdd dataid(\"panel\") Member(\"name\")\"\n  if type = \"Skel\" then\n  \"LmmAdd dataid(\"skel\") Member(\"name\")\"\n  type = null\n  return\n\n  /* ------------------------------ *\n  * ALlocate the temp ispf library *\n  * ------------------------------ */\nAlloc_DD:\n  arg dd\n  Address TSO\n  if pos(left(dd,2),\"lc le\") > 0 then\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(v b) lrecl(255) blksize(32760)\"\n  else\n  \"Alloc f(\"dd\") unit(sysda) spa(5,5) dir(1)\",\n    \"recfm(f b) lrecl(80) blksize(23440)\"\n  return\n\n  /* ------------------------------------------------ *\n  | Here is the ISPF Panel that will be dynamnically |\n  | loaded for use.                                  |\n  * ------------------------------------------------ */\n/*\n>START\n>Panel vtab\n)Attr\n! type( input) intens(high) caps(on ) just(left ) hilite(uscore)\n# type(output) intens(low ) caps(off) just(left) color(turq)\n@ type(output) intens(low ) caps(off) just(left)\n\u00ac type(output) intens(low ) caps(off) just(right)\n$ type(  text) intens(high) caps(off) hilite(reverse)\n)Body Expand(//)\n%-/-/-$List of Table values: @tab     %-/-/-\n%Command ===>_zcmd                                 / /%Scroll ===>_amt +\n+\n+Row    Variable  Description\n)Model\n@z     @z   e    @z\n)Init\n&amt = CSR\n.zvars = '(vrow vname vdesc)'\n)Proc\n)end\n>PANEL QTAB\n)Attr Default(%+_)\n! type( input) intens(high) caps(on ) just(left ) hilite(uscore)\n# type(output) intens(low ) caps(off) just(left) color(turq)\n@ type(output) intens(low ) caps(off) just(left)\n\u00ac type(output) intens(low ) caps(off) just(right)\n$ type(  text) intens(high) caps(off) hilite(reverse)\n)Body  Expand(//)\n%-/-/-$List of Open ISPF Tables#ver%-/-/-\n%Command ===>_zcmd                                 / /%Scroll ===>_amt +\n%\n%S Table         Keys    Names     Cdate     Ctime       UDate       UTime\n%Userid       Rows        C-Rows   Rows-Upd  TableUpd\n%Library   Storage\n%Status (1-2-3)\n-----------------------------------------------------------------------------\n)Model\n!z#z       +\u00acz       +\u00acz      +  +@z        @z          @z          @z\n@z          \u00acz       +\u00acz      + \u00acz         +  \u00acz     +\n@z          \u00acz       +\n@z\n@z\n@z\n-----------------------------------------------------------------------------\n)Init\n.help = QTABH\n.zvars =  '(sel tab keysn namesn cdate ctime udate utime user +\nrowcurr rowcreat +\nrowupd tableupd library virtsize status1 status2 status3) '\n&amt = CSR\n)Reinit\n)Proc\n)End\n>PANEL QTABH\n)attr default(%+_)\n$ type(  text) intens(high) caps(off) hilite(reverse)\n)Body Expand(\\\\)\n%-\\-\\-$List Active ISPF Tables%-\\-\\-\nommand ===>_ZCMD                                                             +\n%\n+  All active ISPF Tables are displayed in a multi-row table with the\n+  following information:\n+\n+       Table Name\n+       Keys count\n+       Names count\n+       Create Date and Time\n+       Update Date and Time\n+       Last Userid to Update\n+       Row count current, at table create and updated\n+       Number of times the Table has been updated\n+       Library (DDName)\n+       Table Status info (3)\n+\n+ Select a table to display details, including individual row/variables.\n+\n)INIT\n.cursor = &zcmd\n)PROC\n)END\n>END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RANDSTR": {"ttr": 33289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x18\\x05O\\x01\\x18\\x05\\x8f\\x06\\x16\\x00\\x97\\x00k\\x00\\x00\\xd3\\xc2\\xc4@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-02-23T00:00:00", "modifydate": "2018-02-27T06:16:51", "lines": 151, "newlines": 107, "modlines": 0, "user": "LBD"}, "text": "/* --------------------  rexx procedure  -------------------- *\n | Name:      randstr                                         |\n |                                                            |\n | Function:  Generate a unique character string for use      |\n |            in an ISPF Table name, DDName, etc.             |\n |                                                            |\n |            This is for ISPF dialogs that may run           |\n |            concurrently in either multiple split           |\n |            screens or stacked so as to prevent duplicate   |\n |            DD or ISPF table names.                         |\n |                                                            |\n |            Or any length string with or without            |\n |            lowercase characters.                           |\n |                                                            |\n |            Thus this can be used to generate a random      |\n |            password or passphrase                          |\n |                                                            |\n |            This may also be used for any other need        |\n |            to have a unique character string that is       |\n |            a valid DDName, Member Name, etc.               |\n |                                                            |\n | Syntax:    x = randstr(n)                                  |\n |                                                            |\n |            Where n is the number of characters to          |\n |            return, always starting with an alpha.          |\n |                                                            |\n |            The default if not provided is 8                |\n |                                                            |\n |            If 'n' is preceded by L (e.g. L8) then          |\n |            50% of the characters will be lowercase         |\n |                                                            |\n | Notes:     In testing this generated 0 duplicates in 10    |\n |            tests with 100,000 iterations so this looks     |\n |            reasonably random - when n is 8.                |\n |                                                            |\n |            Using less than 8 will result in a higher       |\n |            probability of duplicates and using more        |\n |            will result in lowering the probabilty of       |\n |            duplicates.                                     |\n |                                                            |\n |            DO NOT call this routine RANDOM as it will      |\n |            confuse the use of the REXX RANDOM function     |\n |            within the code.                                |\n |                                                            |\n | Author:    Lionel B. Dyck                                  |\n |                                                            |\n | History:  (most recent on top)                             |\n |            02/27/18 - Ensure 1st position is alpha         |\n |            02/26/18 - Add LOTS of comments                 |\n |            02/23/18 - Insure 1st char is not special char  |\n |                     - Allow a parm for # of characters     |\n |                     - Allow Lowercase in string            |\n |            02/22/18 - Additional doc and randomness        |\n |            02/21/18 - Creation                             |\n |                                                            |\n * ---------------------------------------------------------- */\n  arg numchars\n\n/* ------------------------------------ *\n | Check for L (lower case) in the parm |\n |  - set lowercase flag on             |\n |  - remove L from the parm (numchars) |\n | Otherwise set lower case flag off    |\n * ------------------------------------ */\n  if left(numchars,1) = 'L' then do\n    lowcase = 1\n    numchars = substr(numchars,2)\n  end\n  else lowcase = 0\n\n/* ----------------------------------------------------- *\n | Check that numchars is numeric otherwise default to 8 |\n * ----------------------------------------------------- */\n  if datatype(numchars) /= 'NUM' then numchars = 8\n\n/* -------------------------- *\n | Define our default strings |\n * -------------------------- */\n  alpha  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@'\n  lowchar= 'abcdefghijklmnopqrstuvwxyz'\n  alpha# = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@0123456789'\n\n/* -------------------------------------- *\n | Use 24 digit precision in calculations |\n * -------------------------------------- */\n  numeric digits 24\n\n/* ----------------------------- *\n | Get random character position |\n * ----------------------------- */\n  ra = random(1,26)\n/* ------------------------------------------ *\n | Start the return with the random character |\n | - then append the seconds since midnight   |\n |   multiplied by a random 5 digit number    |\n |   and then multiply again by another       |\n |   random 5 digit number.                   |\n | Then truncate at the request number of     |\n | characters (numchars)                      |\n * ------------------------------------------ */\n  r = left(substr(alpha,ra,1) || ,\n    time('s') * random(99999) ,\n    * random(99999),numchars)\n\n/* --------------------------------------------------- *\n | Overlay the returned string with 3 different random |\n | characters from the alpha string to make it more    |\n | random.                                             |\n | ra = random char location                           |\n | rc = random target location                         |\n * --------------------------------------------------- */\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n  ra = random(1,29);rc = random(2,numchars)\n  r = overlay(substr(alpha,ra,1),r,rc,1)\n\n/* --------------------------------- *\n | Clean up any blanks in the return |\n | by replacing with random alpha#   |\n * --------------------------------- */\n  do while pos(' ',r) > 0\n    pb = pos(' ',r)         /* get position of blank           */\n    ra = random(1,39)       /* get a random character position */\n    /* now overlay the random character at the random position */\n    r = overlay(substr(alpha#,ra,1),r,pb,1)\n  end\n\n/* ------------------------------------- *\n | Process Lowercase request if provided |\n | by overlaying 1/2 of all return chars |\n | with a lower case character.          |\n * ------------------------------------- */\n  if lowcase = 1 then do\n    lc = numchars%2       /* get 50% of requested length */\n    do i = 1 to lc\n      /* ra = random lowercase character location */\n      /* rc = random character position location  */\n      ra = random(1,26);rc = random(1,numchars)\n      /* now overlay the random character at the random position */\n      r = overlay(substr(lowchar,ra,2),r,rc,1)\n    end\n  end\n\n/* --------------------- *\n | Now return the string |\n * --------------------- */\n  return r\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXDOC": {"ttr": 33537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00_\\x01\\x01\\x00_\\x111\\x01\\t\\x01\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-05T00:00:00", "modifydate": "2001-01-05T11:31:00", "lines": 265, "newlines": 265, "modlines": 0, "user": "SYSLBD"}, "mimetype": "audio/x-mp4a-latm", "datatype": "binary", "extension": ".x-mp4a-latm"}, "REXXER": {"ttr": 33542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00@\\x01\\x19\\x02\\x9f\\x01 0/\\x05\\x15\\x01\\x98\\x01\\x95\\x00\\x00\\xe2\\xd3\\xc2\\xc4@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2019-01-29T00:00:00", "modifydate": "2020-10-28T05:15:40", "lines": 408, "newlines": 405, "modlines": 0, "user": "SLBD"}, "text": "/* ================================* REXX *============================*/\n/*     TYPE:  Edit Macro                                              */\n/*  PURPOSE:  Syntax check a REXX program                             */\n/*    OWNER:  Mainframe Operating Systems Services (MOSS)             */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @L1  190326  LBD      Correct messages if includes used            */\n/* @A6  170218  REXX     Increased size of SYSIN and SYSPRINT files   */\n/* @A5  160323  REXX     Removed checking ZSCTPREF variable for WFS   */\n/* @A4  150701  REXX     On TST, verify lpar is SDV25/6               */\n/* @A3  110510  REXX     Display help panel when PF1 is pressed       */\n/* @A2  110503  REXX     Validate user is in EDIT or VIEW mode        */\n/* @A1  090915  REXX     Changed how Rexx compiler is invoked         */\n/* @A0  990124  REXX     Obtained REXX code from CBT                  */\n/*====================================================================*/\n/*                                                                    */\n/*   invoked as :  REXXER from an EDIT or VIEW session only           */\n/*                                                                    */\n/*  Invokes REXX Compiler, reads error messages, and places them      */\n/*  into the source listing.                                          */\n/*                                                                    */\n/**********************************************************************/\n/*                                                                    */\n/*  Copyright 1997  Expert System Programming                         */\n/*  This program may be used at will except for profit, in            */\n/*  accordance with the GNU COPYLEFT provisions.                      */\n/*                                                                    */\n/**********************************************************************/\n/*                                                                    */\n/*  CUSTOMIZATION: Find REXXLIB and set applicable compiler load      */\n/*                                                                    */\n/**********************************************************************/\n/*                                                                    */\n/*  Maintenance:                                                      */\n/*                                                                    */\n/*  1999/10/25 @g1  GYP  Fixed SCLM 013-18 error (unmodified mbr      */\n/*                       request - code in different library)         */\n/*  2003/10/25 @g2  GYP  Added SYSPRINT scan for external functs      */\n/*                       when no error - catch spelling errors.       */\n/*                       Fix empty file or pending command.           */\n/*                                                                    */\n/**********************************************************************/\nHELP = \"#CHKREXX\"                                             /* @A3 */\nLPAR     = MVSVAR(\"SYMDEF\",\"SYSNAME\")                         /* @A4 */\nPARSE VALUE MVSVAR(\"SYSPLEX\") WITH 1 SYSPLEX 4 .              /* @A4 */\n\"ISREDIT MACRO (STRING) PROCESS\"\n\nIF (RC <> 0) THEN DO                                          /* @A2 */\n   MACSMSG = \"Must be in Edit Mode\"                           /* @A2 */\n   MACLMSG = \"This utility is an edit macro\",                 /* @A2 */\n             \"and will only work when editing\",               /* @A2 */\n             \"or viewing a PDS(MBR) or Sequential\",           /* @A2 */\n             \"file.  It is not a TSO command.\"                /* @A2 */\n   ADDRESS ISPEXEC \"SETMSG MSG(MAC001)\"                       /* @A2 */\n   EXIT                                                       /* @A2 */\nEND                                                           /* @A2 */\n\nIF (SYSPLEX = \"TST\") THEN                                     /* @A4 */\n   IF (LPAR = \"SDV21\") | (LPAR = \"SDV22\") THEN DO             /* @A4 */\n      MACLMSG = \"Must be logged on to SDV25 or SDV26\",        /* @A4 */\n                \"to use this edit macro.  This is due\",       /* @A4 */\n                \"to IBM's Language Environment is only\",      /* @A4 */\n                \"licensed on SDV25 and SDV26, saving \",       /* @A4 */\n                \"Wells Fargo money ($$$).\"                    /* @A4 */\n      ADDRESS ISPEXEC \"SETMSG MSG(MAC001)\"                    /* @A4 */\n      EXIT                                                    /* @A4 */\n   END                                                        /* @A4 */\n\nIF (string = \"?\") THEN DO\n   ADDRESS ISPEXEC \"SELECT PGM(ISPTUTOR) PARM(\"HELP\")\"        /* @A3 */\n   EXIT\nEND\n\n  if RC=20 then do                /* from TSO?                    */\n              say \"REXXER must be invoked under ISPF EDIT or VIEW\"\n              exit 20\n              end\n        else do\n              UPPER string\n              if string=\"\" then string = \"*\" /* print current     */\n              end\n\n  msg_op = \"No problems\"          /* Preset for normal run        */\n  msg_rc = 0\n  msg_a1 = \"\"\n  msg_a2 = \"\"\n\n  dbug = 0                        /* Off debug and list switches  */\n  dlst = 0                        /* Off debug and list switches  */\n  dsnm = \"\"                       /* Provisionally use current ds */\n\nscanned = 0\ndo while scanned=0                /* Look for option overrides    */\n  PARSE VAR string w1 string\n  select;\n    when w1=\"\" then scanned = 1\n\n    when w1=\"DEBUG\" then dbug = 1\n    when w1=\"LIST\" then dlst = 1\n\n    when w1=\"TRACE\" then TRACE R\n\n    otherwise nop                 /* defer - may be misspelled ?  */\n    end\n end\n\n   REXXLIB = \"FAN140.SFANLMD\"    /* lbd 21st csw */\n/* REXXLIB = \"FAN130.SFANLMD\"*/ /* MY OS/390 2.10  REXX Load Library */\n/* REXXLIB = \"REXX.SFANLMD\" */  /* Preferred alias REXX Load Library */\n/*--------------------------------------------------------------------*/\n   LC = SYSDSN(\"'\"REXXLIB\"'\")                                 /* @A1 */\n   IF LC\\=\"OK\" THEN DO                                        /* @A1 */\n     MSG_RC = 12                                              /* @A1 */\n     MACSMSG = \"No REXX Loadlib\"                              /* @A1 */\n     MACLMSG = \"Compiler Library\" REXXLIB \"Unavailable : \"LC  /* @A1 */\n     \"ISPEXEC SETMSG MSG(MAC001)\"                             /* @A1 */\n     SIGNAL COMM_OUT                                          /* @A1 */\n     END  /* IF LC */                                         /* @A1 */\n/*--------------------------------------------------------------------*/\n\n/*******************************************************************/\n/*                                                                 */\n/*  1) If the data in the current EDIT session were changed, then  */\n/*     we need to read the lines and build a SUBMIT SYSIN          */\n/*                                                                 */\n/*  2) If the underlying data set does not exist (happens when not */\n/*     saved yet, or in an SCLM or similar environment when not    */\n/*     changed), then we need to read the lines and build a SYSIN  */\n/*                                                                 */\n/*  The above fails when the data lines are longer than 255 bytes! */\n/*                                                                 */\n/*  Otherwise, build a SYSIN to point to the unchanged data set.   */\n/*                                                                 */\n/*******************************************************************/\n\"ISREDIT (CHF) = DATA_CHANGED\"\nif CHF=\"NO\" then do\n    \"ISREDIT (ds) = DATASET\"\n    if rc\\=0 then ds = \"\"\n    \"ISREDIT (mb) = MEMBER\"\n    if rc\\=0 then ds = \"\"\n    if ds\\=\"\" then dsnm = ds\n    if mb\\=\"\" & ds\\=\"\" then dsnm = dsnm\"(\"mb\")\"\n    if SYSDSN(\"'\"dsnm\"'\")\\=\"OK\" then dsnm = \"\"                   /*g1*/\n    end  /* if CHF */             /* data set unchanged & usable  */\n                                  /* when dsnm not null           */\ndrop CD.\nCD.0 = 0                          /* Avoid bad arith. conversion  */\nCD. = \"\"                          /* Stem holding SYSIN data      */\ncd_k = 0\n\nif dsnm=\"\" then do                /* Changed data - do it in-line */\n  \"ISREDIT (linef) = LINENUM .ZFIRST\"\n  \"ISREDIT (linel) = LINENUM .ZLAST\"\n  if datatype(linef,\"W\")\\=1 | datatype(linel,\"W\")\\=1 then do     /*@g2*/\n    msg_rc = 12                                                  /*@g2*/\n    MACSMSG = \"Untimely\"                                         /*@g2*/\n    MACLMSG = \"File is empty, pending A/B/C/M command\"           /*@g2*/\n    \"ISPEXEC SETMSG MSG(MAC001)\"                                 /*@g2*/\n    signal Comm_Out                                              /*@g2*/\n    end  /* datatype */                                          /*@g2*/\n                                                                 /*@g2*/\n  do i=linef to linel\n    \"ISREDIT (string) = LINE \"i\n    cd_k = cd_k+1\n    cd.cd_k = string\n    end  /* i */\n  end  /* dsnm */\n\nx = MSG(\"OFF\")                    /* Don't want any messages      */\naddress TSO\n\"FREE FI(SYSIN)\"                  /* Get rid of prior allocations */\n\"FREE FI(SYSTERM)\"\n\"FREE FI(SYSPRINT)\"\n\"FREE FI(SYSCEXEC)\"\n\"FREE FI(SYSPUNCH)\"\nx = MSG(\"ON\")\n\nif dsnm\\=\"\" then do               /* Use existing data set        */\n    \"ALLOCATE FI(SYSIN) DA('\"dsnm\"') SHR REUSE\"\n    arc = rc\n    end  /* then */\n  else do                         /* Otherwise allocate and write */\n    \"ALLOCATE FI(SYSIN) NEW DELETE CYL SPACE(1 1) REUSE\"||,   /* @A6 */\n      \" RECFM(V B)  LRECL(259)\"\n    arc = rc\n    if arc=0 then do\n      \"EXECIO * DISKW SYSIN (stem CD. FINIS\"\n      if rc\\=0 then do\n        msg_op = \"EXECIO DISKW\"   /* Tell user about ALLOC error  */\n        msg_rc = rc\n        msg_a1 = \"SYSIN\"\n        msg_a2 = \"\"\n        signal bad_exit\n        end  /* if rc */\n        drop CD.\n      end  /* if arc */\n    end  /* else dsnm=\"\" */\nif arc\\=0 then do\n  msg_op = \"ALLOC SYSIN\"   /* Tell user about ALLOC error  */\n  msg_rc = arc\n  msg_a1 = \"SYSIN\"\n  msg_a2 = \"\"\n  signal bad_exit\n  end  /* If rc */\n\n\"ALLOCATE FI(SYSTERM) NEW DELETE TRACKS SPACE(1 1) REUSE\"\n\"ALLOCATE FI(SYSPRINT) NEW DELETE CYL SPACE(15 15) REUSE\"     /* @A6 */\n/* \"ALLOCATE FI(SYSPRINT) DUMMY REUSE\" ********OLD*********/     /*g2*/\n\"ALLOCATE FI(SYSPUNCH) DUMMY REUSE\"\n\"ALLOCATE FI(SYSCEXEC) DUMMY REUSE\"\n\nx = outtrap(\"REXXcall.\")\nREXX_parm = \"XREF TERM TRACE SLINE\"        /* Pass this parm to REXX */\n/* ADDRESS ISPEXEC \"SELECT PGM(REXXCOMP) PARM(\"REXX_parm\")\" */\n\"TSOEXEC CALL '\"REXXLIB\"(REXXCOMP)' '\"REXX_parm\"'\"            /* @A1 */\narc = rc\nx = outtrap(\"OFF\")\n    if arc<0 | arc>12 then do\n      msg_op = \"REXX COMPILE\"\n      msg_rc = arc\n      msg_a1 = \"Error\"\n      msg_a2 = \"\"\n      signal bad_exit\n      end\n\n\"EXECIO * DISKR SYSTERM  (stem Term. FINIS\"\n    if rc\\=0 then do\n      msg_op = \"EXECIO DISKR\"\n      msg_rc = rc\n      msg_a1 = \"SYSTERM\"\n      msg_a2 = \"\"\n      signal bad_exit\n      end\n\n\"ISREDIT RESET\"                   /* Remove old messages          */\n\ncurl = 0                          /* Line to position cursor on   */\nmsgl = 0                          /* Line to place error msg aftr */\nerrc = 0                          /* Error count                  */\nque# = 0                          /* Number of stacked error msgs */\ndrop stack.                       /* Error message                */\nstack. = \"\"                       /*               stack          */\ndrop exvar.                       /* External function            */\nexvar. = \"\"                       /*                   stack       g2*/\nexvars = 0                        /* Count of external functions   g2*/\nexvar1 = 0                        /* Count with single reference   g2*/\n\n/******* Now read the SYSTERM lines, and convert to messages *********/\nl = term.0\nif l>2 then k = 3                 /* Skip statistics              */\n       else k = 1                 /* Don't know                   */\n\ndo j=k to l                       /* Loop through SYSTERM lines   */\n  line = TERM.j                   /* Shortcut for stem lookups    */\n\n  select                          /* Handle msgs and continuation */\n    when left(strip(line),1)=\"|\"   & msgl>0 then do\n      text = substr(line,22)\n      x = Msg_Stack(text)\n      end  /* | */\n\n    when left(strip(line),3)=\"+++\" & msgl>0 then do\n      text = delword(line,1,1)\n      x = Msg_Stack(text)\n      if curl=0 then do\n          curl = msgl\n          curp = pos(\"|\",stack.1) /* Put cursor on bad character  */\n          end /* if curl */\n      end  /* +++ */\n\n    when datatype(word(line,1),\"W\")=1 then do  /* New message ?   */\n      call Msg_Write\n      if msgl\\=word(line,1) then errc = errc+1\n      if substr(line,78,1) /= ' '                /* @L1 */\n         then msgl = subword(line,words(line))  /* @L1 */\n         else  msgl = word(line,1)              /* @L1 */\n      end  /* Line number */\n\n    otherwise nop                 /* What ever                    */\n\n  end  /* select */\n end  /* do j */\ncall Msg_Write   /* Final writes */\n\nif curl\\=0 then do                /* Set to display error count   */\n    if errc=1 then plural = \"\"\n              else plural = \"s\"\n    MACSMSG = errc\" error\"plural\" found\"\n    MACLMSG = errc\" error\"plural\" found\"\n    \"ISPEXEC SETMSG MSG(MAC001)\"\n    \"ISREDIT CURSOR = \"curl curp\n    end  /* then */\n  else do                         /* No errs - orphan functions?  */\n    MACSMSG = \"No errors found\"\n    MACLMSG = \"No errors found\"\n    \"ISPEXEC SETMSG MSG(MAC001)\"\n\n/*********************************REXX******************************/\n/*                                                                 */\n/*  No errors found - now read SYSPRINT to check for external      */\n/*  references (could be misspelled when single use?)              */\n/*                                                                 */\n/*******************************************************************/\ndrop Term.                                                       /*g2*/\nTerm. = \"\"                                                       /*g2*/\n\"EXECIO * DISKR SYSPRINT (stem Term. FINIS\"                      /*g2*/\n    if rc\\=0 then do                                             /*g2*/\n      msg_op = \"EXECIO DISKR\"                                    /*g2*/\n      msg_rc = rc                                                /*g2*/\n      msg_a1 = \"SYSPRINT\"                                        /*g2*/\n      msg_a2 = \"\"                                                /*g2*/\n      signal bad_exit                                            /*g2*/\n      end  /* if rc */                                           /*g2*/\n                                                                 /*g2*/\n    qv1 = \" EXT \"                                                /*g2*/\n    qv2 = \"RTN \"                                                 /*g2*/\n    \"ISREDIT (linel) = LINENUM .ZLAST\"                           /*g2*/\n    do j=1 to term.0                                             /*g2*/\n      if pos(qv1||qv2,substr(Term.j,31))>0 then do               /*g2*/\n        line = Term.j                                            /*g2*/\n        exvars = exvars + 1                                      /*g2*/\n        ix = right(words(line)-3,7) || \" \"                       /*g2*/\n        exvar.exvars = ix || word(line,1)                        /*g2*/\n        if words(line)=4 then exvar1 = exvar1 + 1                /*g2*/\n        if length(word(line,1))=30 then do                       /*g2*/\n          ix = j + 1                                             /*g2*/\n          line = Term.ix                                         /*g2*/\n          if length(word(line,1))<31 & substr(line,32,8)=\"\" then /*g2*/\n            exvar.exvars = exvar.exvars || word(line,1)          /*g2*/\n          if length(word(line,1))=30 then do                     /*g2*/\n            ix = j + 2                                           /*g2*/\n            line = Term.ix                                       /*g2*/\n            if length(word(line,1))<31 & substr(line,32,8)=\"\" then\n              exvar.exvars = exvar.exvars || word(line,1)        /*g2*/\n            end  /* do length 3rd */                             /*g2*/\n          end  /* do length 2nd */                               /*g2*/\n        end  /* ext var */                                       /*g2*/\n      end  /* do */                                              /*g2*/\n    do ix=exvars to 1 by -1                                      /*g2*/\n      line = exvar.ix                                            /*g2*/\n      \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"              /*g2*/\n      end  /* do */                                              /*g2*/\n    if exvars>0 then do                                          /*g2*/\n      line = right(\"Ref.Cnt\",7) || \" Name (max 63 chars)\"        /*g2*/\n      \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"              /*g2*/\n      if exvar1>0 then do                                        /*g2*/\n        line = \"Please check spelling.\"                          /*g2*/\n        \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"            /*g2*/\n        end  /* exvar1 */                                        /*g2*/\n    line = center(exvars\" external references found in this program\",72)\n      \"ISREDIT LINE_AFTER \"linel\" = MSGLINE (line)\"              /*g2*/\n      curp = 1                                                   /*g2*/\n      \"ISREDIT CURSOR = \"linel curp                              /*g2*/\n      end  /* do exvars */                                       /*g2*/\n    end  /* else */                                              /*g2*/\n\nsignal Comm_Out\n\n\nBad_Exit:\n    MACSMSG = \"Processing error\"\n    MACLMSG = \"Processing error in \"msg_op\", code \"msg_rc||,\n       \", for \"msg_a1\". \"msg_a2\n    \"ISPEXEC SETMSG MSG(MAC001)\"\nsignal Comm_Out\n\nComm_Out:\nx = MSG(\"OFF\")\naddress TSO\nif dsnm\\=\"\" then \"FREE DA('\"dsnm\"')\"\n\"FREE FI(SYSIN)\"\n\"FREE FI(SYSTERM)\"\n\"FREE FI(SYSPRINT)\"\n\"FREE FI(SYSCEXEC)\"\n\"FREE FI(SYSPUNCH)\"\nx = MSG(\"ON\")\n\ntrace off\nexit msg_rc\n\n\n/**********************************************************************/\n/**                                                                  **/\n/**  MSG_STACK :  Save error messages                                **/\n/**                                                                  **/\n/**********************************************************************/\nMsg_Stack:\nque# = que# + 1\nstack.que# = arg(1)\nreturn que#\n\n\n/**********************************************************************/\n/**                                                                  **/\n/**  MSG_WRITE :  Insert error messages in proper sequence           **/\n/**                                                                  **/\n/**********************************************************************/\nMsg_Write:\ndo ix=que# to 1 by -1\n  text = stack.ix\n  \"ISREDIT LINE_AFTER \"msgl\" = MSGLINE (TEXT)\"\n  end\n\nque# = 0\ndrop stack.\nstack. = \"\"\nreturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXFORM": {"ttr": 33795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x03\\x01\\x17\\x10\\x9f\\x01\\x17\\x11o\\tR\\x02\\x03\\x01\\xd5\\x00\\x00\\xd3\\xc2\\xc4@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-04-19T00:00:00", "modifydate": "2017-04-26T09:52:03", "lines": 515, "newlines": 469, "modlines": 0, "user": "LBD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "REXXTRY": {"ttr": 34049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x001?\\x01\\x001?\\x18F\\x00\\xbb\\x00\\xbb\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xe3\\xd9\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-11-08T00:00:00", "modifydate": "2000-11-08T18:46:00", "lines": 187, "newlines": 187, "modlines": 0, "user": "REXXTRY"}, "text": "/* SAA-portable REXXTRY procedure     11/08/91  version 1.05\n  Owned by IBM SAA REXX Development, Endicott, New York.\n    Loosely derived from an ancient formulation of Mike Cowlishaw.\n\n  This procedure lets you interactively try REXX statements.\n    If you run it with no parameter, or with a question mark\n    as a parameter, it will briefly describe itself.\n  You may also enter a REXX statement directly on the command line\n    for immediate execution and exit.  Example:  rexxtry call show\n\n  Enter 'call show' to see user variables provided by REXXTRY.\n  Enter '=' to repeat your previous statement.\n  Enter '?' to invoke system-provided online help for REXX.\n  The subroutine named 'sub' can be CALLed or invoked as 'sub()'.\n  REXXTRY can be run recursively with CALL.\n\n  Except for the signal instructions after a syntax error, this\n    procedure is an example of structured programming.\n  The 'clear' routine illustrates system-specific SAA-portable coding.\n*/\n  parse arg argrx                      /* Get user's arg string.    */\n  call house                           /* Go do some housekeeping.  */\n  select                               /* 3 modes of operation...   */\n    when argrx = '?' then call tell    /*   1.  Tell user how.      */\n    when argrx = ''  then do           /*   2.  Interactive mode.   */\n      call intro ; call main ; end\n    otherwise push argrx ; call main   /*   3.  One-liner and exit. */\n  end\ndone:  exit                            /* The only exit.            */\n\nhouse:                                 /* Housekeeping.             */\n  parse version version                /* Fill-in 2 user variables. */\n  parse source source                  /*                           */\n  parse source sysrx . procrx .        /* Get system & proc names.  */\n  remindrx = \"Enter 'exit' to end.\"    /* How to escape rexxtry.    */\n  helprx=''                            /* Null if not CMS or OS/2.  */\n  if sysrx = 'CMS' | sysrx = 'OS/2'    /*   Extra reminder for CMS  */\n    then helprx = '   ',               /*     or OS/2.              */\n    \"  Or '?' for online REXX help.\"   /*   Not used in intro.      */\n  promptrx=''                          /* Null if not one-liner.    */\n  if argrx<>'' then promptrx=procrx' ' /*   Name part of user line. */\n  if sysrx = 'OS/2' then do            /* OS/2-specific...          */\n    posrx = lastpos('\\',procrx)        /*   Find name separator.    */\n    procrx = substr(procrx,posrx+1)    /*   Pick up the proc name.  */\n    end\n  temprx = ' 'procrx' on 'sysrx        /* Make border...            */\n    posrx = 69-length(temprx)          /*   where to overlay name,  */\n    bordrx = copies('.',68)            /*   background of periods,  */\n    bordrx =,                          /*   name right-adjusted.    */\n      overlay(temprx,bordrx,posrx)\n  save = ''                            /* Don't save user input.    */\n  trace = 'Off'                        /* Init user trace variable. */\n  return result                        /* Preserve result contents. */\n\ntell:  call clear ; do irx = 1 to 20   /* Tell about rexxtry by     */\n  say sourceline(irx) ; end            /*   displaying the prolog.  */\n  return result                        /* Preserve result contents. */\n\nclear:  select                         /* SAA-portable code.        */\n  when sysrx = 'CMS'  then 'VMFCLEAR'  /* No such command on        */\n  when sysrx = 'OS/2' then 'CLS'       /*   OS/400 or TSO.          */\n  otherwise nop ; end ; say\n  return result                        /* Preserve result contents. */\n\nintro:                                 /* Display brief             */\n  say '  'procrx' lets you',           /*   introductory            */\n    'interactively try REXX',          /*   remarks for             */\n    'statements.'                      /*   interactive mode.       */\n  say '    Each string is executed',\n    'when you hit Enter.'\n  say \"      Enter 'call tell' for\",   /* How to see description.   */\n    \"a description of the features.\"\n  say '  Go on - try a few...   ',\n    '         'remindrx\n  return result                        /* Preserve result contents. */\n\nsub:  say '  ...test subroutine',      /* User can CALL this        */\n  \"'sub'  ...returning 1234...\"        /*   subroutine or           */\n  return 1234                          /*   invoke with 'sub()'.    */\n\nmain:  signal on syntax                /* Enable syntax trap.       */\n  do foreverrx = 1                     /* Loop forever.             */\n    prev = inputrx                     /* User can repeat previous. */\n    parse pull inputrx                 /* Input keyboard or queue.  */\n    current = inputrx                  /* Current line for 'show'.  */\n    if save <> '' then call save       /* Save before interpreting. */\n    if inputrx = '=' then inputrx=prev /* '=' means repeat previous */\n    select\n      when inputrx = '' then say ' ',  /* If null line, remind      */\n        procrx':  'remindrx helprx     /*   user how to escape.     */\n      when inputrx='?' then call help  /* Request for online help.  */\n      otherwise\n        rc = 'X'                       /* Make rc change visible.   */\n        call set2 ; trace (trace)      /* Need these on same line.  */\n        interpret inputrx              /* Try the user's input.     */\n        trace 'Off'                    /* Don't trace rexxtry.      */\n        call border                    /* Go write the border.      */\n    end\n    if argrx <> '' & queued() = 0      /* For one-liner, loop until */\n      then leave                       /*   queue is empty.         */\n  end ; return result                  /* Preserve result contents. */\n\nset1:  siglrx1 = sigl                  /* Save pointer to lineout.  */\n  return result                        /* Preserve result contents. */\n\nset2:  siglrx2 = sigl                  /* Save pointer to trace.    */\n  return result                        /* Preserve result contents. */\n\nsave:                                  /* Save before interpreting. */\n  call set1;rcrx=lineout(save,inputrx) /* Need on same line.        */\n  if rcrx <> 0 then                    /* Catch non-syntax error    */\n    say \"  Error on save=\"save         /*   from lineout.           */\n  return result                        /* Preserve result contents. */\n\nhelp:  select                          /* Request for online help.  */\n  when sysrx = 'CMS' then              /* Invoke CMS help menu for  */\n    address CMS 'HELP REXX MENU'       /*   for REXX.               */\n  when sysrx = 'OS/2' then             /* Invoke OS/2 online REXX   */\n    'view rexx.inf'                    /*   Reference.              */\n  otherwise say '  'sysrx' has',       /* Todate, only CMS and OS/2 */\n    'no online help for REXX.'         /*   provide online help     */\n    rc = 'Sorry !' ; end               /*   for REXX.               */\n  call border ; return result          /* Preserve result contents. */\n\nborder:  if rc = 'X' then              /* Display border.           */\n    say '  'bordrx\n  else say ' ',                        /* Show return code if it    */\n    overlay('rc = 'rc' ',bordrx)       /*   has changed.            */\n  return result                        /* Preserve result contents. */\n\nsyntax:  trace 'Off'                   /* Stop any tracing.         */\n  select\n    when sigl = siglrx1 then do        /* User's 'save' value bad.  */\n      say \"  Invalid 'save' value\",\n        \"'\"save\"', resetting to ''.\"\n      save='' ; end\n    when sigl = siglrx2 then do        /* User's 'trace' value bad. */\n      say \"  Invalid 'trace' value\",\n        \"'\"trace\"', resetting to\",\n        \"'Off'.\" ; trace='Off' ; end\n    otherwise                          /* Some other syntax error.  */\n         say '  Oooops ! ... try',     /*                           */\n      'again.     'errortext(rc)       /* Show the error msg text.  */\n      if sysrx='CMS' then call cmstax  /* More syntax stuff for CMS */\n  end ; call border                    /* Go write the border.      */\n  if argrx <> '' & queued() = 0 then   /* One-liner not finished    */\n    signal done                        /*   until queue is empty.   */\n  signal main                          /* Resume main loop.         */\n\ncmstax:  rcrx = rc                     /* More syntax stuff for CMS */\n  if exist('PROMPT MODULE') then       /* User's input to cmd line. */\n    'PROMPT' promptrx||'13'x||inputrx  /*   '13'x places cursor.    */\n  if exist('REXX EXEC') & argrx=''     /* Not for one-liners.       */\n  then do; more='EXEC REXX' rcrx+20000 /* CMS rc is 20,000 higher.  */\n    say \"  Enter 'more' to see\",       /* Prepare 'more' to access  */\n      'information about this',        /*  REXX IOSLIB information. */\n      'syntax error.' ; end            /* Tell user what to do.     */\n  rc = rcrx ; return result            /* Preserve result contents. */\n\nexist:  arg inrx ; outrx = 0           /* Assume file is missing.   */\n  address command 'ESTATE' inrx        /* Does the file exist ?     */\n  if rc = 0 then outrx = 1             /* estate says it exists.    */\n  return outrx                         /* 1 makes condition true.   */\n\nshow:  trace 'Off' ; call clear        /* Display user variables    */\n  say '  'procrx' provides',           /*   provided by rexxtry.    */\n    'these user variables.'\n  say '  The current values are...'    /* Show current values.      */\n  say\n  say \"    'version'   = '\"version\"'\"  /* What level of REXX.       */\n  say \"    'source'    = '\"source\"'\"   /* What oper system etc.     */\n  say \"    'result'    = '\"result\"'\"   /* REXX special variable.    */\n  say\n  say '     Previous line entered by',\n    'user.  Initial value=INPUTRX.'\n  say \"    'prev'      = '\"prev\"'\"     /* Previous user statement.  */\n  say \"    'current'   = '\"current\"'\"  /* Compare curr with prev.   */\n  say\n  say '     Save your input with',\n    'save=filespec.',\n    \" Stop saving with save=''.\"\n  say \"    'save'      = '\"save\"'\"     /* Filespec for input keep.  */\n  say\n  say '     Enter trace=i, trace=o',\n    ' etc. to control tracing.'\n  say \"    'trace'     = '\"trace\"'\"    /* Trace user statements.    */\n  return result                        /* Preserve result contents. */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXTRY$": {"ttr": 34053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x001?\\x01\\x001?\\x18F\\x00N\\x00N\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xe3\\xd9\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-11-08T00:00:00", "modifydate": "2000-11-08T18:46:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "REXXTRY"}, "text": "\n+--------------------------------------------------------------------+\n|                                                                    |\n|                  SAA-portable REXXTRY procedure                    |\n|                                                                    |\n+--------------------------------------------------------------------+\n                    -- IBM Internal Use Only --\n\nThe purpose of this procedure is to provide an implementation of the\nrexxtry concept that can be used on all IBM SAA systems that have a\nREXX interpreter.  Further, it provides a simple example of the method\nused to handle system-specific operations within a non-system-specific\nframework.\n\nThe REXXTRY package is now available on the VMTOOLS repository.\n\nThis version is structured, SAA-portable, provides indented output,\nand has consistent messages.  All of its subroutines can be called by\nthe user.\n\nThe tell subroutine highlights the features:\n\n   three modes of operation...\n\n      interactive           enter:  rexxtry alone\n      one-line and exit     enter:  rexxtry and any strings\n      tell                  enter:  rexxtry ?\n\n   filespec independence    Rexxtry can be renamed.  It uses\n                              parse source to get its name.\n\n   'prev'  variable         Contains the previous line that was\n                              entered by the user.\n\n   recursion                Can be run recursively with CALL.\n                              In CMS, EXEC also works.\n\n   'save'  variable         Save user input with save=filespec.\n                              Stop saving with save=''.  (null)\n                              Rexxtry does a lineout to the file\n                                of your choice before that line\n                                is interpreted.\n\n   'show'  subroutine       'call show' will display the current\n                              values of the user variables that are\n                              provided by rexxtry, including the\n                              filled-in 'version' and 'source'\n                              variables.\n\n   'sub'   test subroutine  Can be CALLed or invoked as 'sub().\n                              So can all the other subroutines, but\n                                'sub' announces itself and does a\n                                return 1234 for testing the RESULT\n                                special variable.\n\n   'trace' variable         Enter trace=i, trace=o etc. to control\n                              tracing of user instructions.  Rexxtry\n                              itself is not traced unless the user\n                              CALLs or SIGNALs its subroutines.\n\n   '=' operator             Enter '=' to repeat previous statement.\n\n   '?' operator             Enter '?' to invoke system-provided online\n                              help for REXX, if any is available.\n\n   'more'  variable         For CMS only, after a syntax error, the\n                              user can enter 'more' to see information\n                              from REXX IOSLIB about this error code.\n\n   prompting                For CMS only, after a syntax error, if the\n                              PROMPT module is available, rexxtry will\n                              put the user's input on the command line,\n                              ready to be corrected and tried again.\n\n\nSteve Stafford     March 23, 1991\n\nIBM SAA REXX Development, Endicott, New York\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXTRY#": {"ttr": 34056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x01\\x001?\\x01\\x001?\\x18V\\x00\\t\\x00\\t\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-11-08T00:00:00", "modifydate": "2000-11-08T18:56:49", "lines": 9, "newlines": 9, "modlines": 0, "user": "WSBG"}, "text": "Subject: Update on REXXTRY - IBM Said OK\nDate: 08 Nov 2000 12:45:58 -0800\nFrom: Lionel B Dyck <Lionel.B.Dyck@kp.org>\n\nIBM has said that I can post it on my web site and share it with\nthe world so it is now available for download from my web site.\nAnd since you now have copies feel free to share it with others\n(hint to sam golob) as well.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXTRY@": {"ttr": 34058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x001?\\x01\\x001?\\x18F\\x00#\\x00#\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xe3\\xd9\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-11-08T00:00:00", "modifydate": "2000-11-08T18:46:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "REXXTRY"}, "text": "**********************  IBM Internal Use Only  ************************\n* :nick.REXXTRY         :sec.IBM Internal Use Only\n* :title.SAA-portable REXXTRY procedure\n* :version.1.05         :date.91/11/08   :scp.SAA platforms\n* :oname.Steve Stafford                  :onode.GDLVM7   :ouser.STAFFORD\n* :aname.Steve Stafford                  :anode.GDLVM7   :auser.STAFFORD\n* :bname.                                :bnode.         :buser.\n* :support.A    :doc.             :lang.REXX\n* :sw.\n* :kwd.REXX SAAPL TRY\n* :abs.SAA REXX Development version of REXXTRY for all SAA systems.\n* Users can try REXX instructions interactively or one-line and exit.\n* :lic.By placing material on this conference, I agree to grant\n* IBM a non-exclusive, royalty-free license for the material\n* as set forth in the LICENSE AGREEMNT file on this conference.\n************************************************************************\n* This package is on VMTOOLS.\n       REXXTRY  ANNOUNCE   * (Introduction)\n       REXXTRY  EXEC       * (The procedure)\n* History...\n*   105  11/08/91 For OS/2, \"view rexx.inf\" for online help.\n*   105           For OS/2, drop path elimination for FL/FLTREE.\n*   104  03/23/91 For CMS, add 2 features:\n*   104           1.  Use PROMPT (package) if available.\n*   104           2.  Set up 'more' to invoke REXX EXEC (if available)\n*   104               which will display REXX IOSLIB information about\n*   104               the syntax error just trapped.\n*   103  02/25/91 Callable 'show' to display rexxtry's user variables.\n*   103           New operators for interactive mode...\n*   103             '=' means repeat previous line.\n*   103             '?' means invoke online help for REXX, if available.\n*   102  02/21/91 VM tools disk maintenance requires ft EXEC.\n*   102           Version shown in procedure's first line.\n*   101  02/20/91 Use '<>' for 'not equal'.  Ship ft PROCxxx.\n*   100  02/19/91 First release.  Ship fileid REXXTRY EXEC *.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXTRYA": {"ttr": 34060, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x006\\x1f\\x01\\x006\\x1f\\x17 \\x00M\\x00M\\x00\\x00\\xd9\\xc5\\xe7\\xe7\\xe3\\xd9\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-26T00:00:00", "modifydate": "2000-12-26T17:20:00", "lines": 77, "newlines": 77, "modlines": 0, "user": "REXXTRY"}, "text": "\n+--------------------------------------------------------------------+\n|                                                                    |\n|                  SAA-portable REXXTRY procedure                    |\n|                                                                    |\n+--------------------------------------------------------------------+\n                    -- IBM Internal Use Only --\n\nThe purpose of this procedure is to provide an implementation of the\nrexxtry concept that can be used on all IBM SAA systems that have a\nREXX interpreter.  Further, it provides a simple example of the method\nused to handle system-specific operations within a non-system-specific\nframework.\n\nThe REXXTRY package is now available on the VMTOOLS repository.\n\nThis version is structured, SAA-portable, provides indented output,\nand has consistent messages.  All of its subroutines can be called by\nthe user.\n\nThe tell subroutine highlights the features:\n\n   three modes of operation...\n\n      interactive           enter:  rexxtry alone\n      one-line and exit     enter:  rexxtry and any strings\n      tell                  enter:  rexxtry ?\n\n   filespec independence    Rexxtry can be renamed.  It uses\n                              parse source to get its name.\n\n   'prev'  variable         Contains the previous line that was\n                              entered by the user.\n\n   recursion                Can be run recursively with CALL.\n                              In CMS, EXEC also works.\n\n   'save'  variable         Save user input with save=filespec.\n                              Stop saving with save=''.  (null)\n                              Rexxtry does a lineout to the file\n                                of your choice before that line\n                                is interpreted.\n\n   'show'  subroutine       'call show' will display the current\n                              values of the user variables that are\n                              provided by rexxtry, including the\n                              filled-in 'version' and 'source'\n                              variables.\n\n   'sub'   test subroutine  Can be CALLed or invoked as 'sub().\n                              So can all the other subroutines, but\n                                'sub' announces itself and does a\n                                return 1234 for testing the RESULT\n                                special variable.\n\n   'trace' variable         Enter trace=i, trace=o etc. to control\n                              tracing of user instructions.  Rexxtry\n                              itself is not traced unless the user\n                              CALLs or SIGNALs its subroutines.\n\n   '=' operator             Enter '=' to repeat previous statement.\n\n   '?' operator             Enter '?' to invoke system-provided online\n                              help for REXX, if any is available.\n\n   'more'  variable         For CMS only, after a syntax error, the\n                              user can enter 'more' to see information\n                              from REXX IOSLIB about this error code.\n\n   prompting                For CMS only, after a syntax error, if the\n                              PROMPT module is available, rexxtry will\n                              put the user's input on the command line,\n                              ready to be corrected and tried again.\n\n\nSteve Stafford     March 23, 1991\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REXXWAIT": {"ttr": 34063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x00\\x04\\x7f\\x01\\x00\\x04\\x7f\\x16Y\\x00\\xcf\\x00\\xcf\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-16T00:00:00", "modifydate": "2000-02-16T16:59:36", "lines": 207, "newlines": 207, "modlines": 0, "user": "SBGOLOB"}, "text": "*---------------------------------------------------------------------*\n*                                                                     *\n* Name:        REXXWAIT                                               *\n*                                                                     *\n* Function:    REXX Function to wait for hhmmssth                     *\n*                                                                     *\n* Syntax:      X=REXXWAIT(hhmmssth)                                   *\n*                                                                     *\n*              Where:                                                 *\n*                                                                     *\n*              hhmmssth is:                                           *\n*              hh = hours 01 to nn                                    *\n*              mm = minutes 00 to 59                                  *\n*              ss = seconds 00 to 59                                  *\n*              t  = tenths of a second 0-9                            *\n*              h  = hundredths of a second 0-9                        *\n*                                                                     *\n*              Default is to wait for 15 seconds                      *\n*---------------------------------------------------------------------*\n* Sample REXX Usage:                                                  *\n*                                                                     *\n*  /* rexx */                                                         *\n*  arg val                                                            *\n*  call time 'r'                                                      *\n*  x=rexxwait(val)                                                    *\n*  etime = time('e')                                                  *\n*  say \"Elapsed time:\" etime \"rc:\" x                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Link Edit information:     NON-REENTRANT                            *\n*---------------------------------------------------------------------*\n* Return Codes:                                                       *\n*                                                                     *\n*         0    processing has completed successfully                  *\n*         8    invalid parm                                           *\n*        24    IRXEXCOM bad return code                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n* Author:      Lionel B. Dyck                                         *\n*              Kaiser Permanente                                      *\n*              Walnut Creek, CA 94 98                                 *\n*              (925) 926-5332                                         *\n*              Internet: lionel.b.dyck@kp.org                         *\n*---------------------------------------------------------------------*\n* HISTORY:                                                            *\n*                                                                     *\n*        07/22/99  -  Created                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nREXXWAIT CSECT\nREXXWAIT AMODE 31\n*----------------------------------------------------------*\n*        Housekeeping occurs here                          *\n*----------------------------------------------------------*\n         STM   R14,R12,12(R13)     SAVE REGISTERS\n         LR    R12,R15             LOAD BASE REG\n         USING REXXWAIT,R12        INFORM ASSEMBLER\n         B     STARTIT\n         DC    CL8'REXXWAIT'\n         DC    C'-'\n         DC    CL8'&SYSDATE'       COMPILE DATE\n         DC    C'-'\n         DC    CL8'&SYSTIME'       COMPILE TIME\nSTARTIT  DS    0H\n         SPACE 2\n         LA    R0,72+1000          get savearea plus workarea\n         GETMAIN R,LV=(0)\n         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE\n         LR    R2,R1               SAVE POINTER IN EVEN REG\n         LA    R4,1(R1)            SET RECEIVING POINTER\n         LR    R5,R0               SET RECEIVING LENGTH\n         BCTR  R5,R0               DECREMENT LENGTH\n         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE\n         LA    R3,1                SET SENDING LENGTH\n         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'\n         ST    R13,4(R1)           SAVE BACK CHAIN\n         ST    R1,8(R13)           SET FORWARD CHAIN\n         LR    R2,R1               SAVE NEW SAVEAREA ADDRESS\n         L     R15,16(R13)         RESTORE REG 15\n         ST    R0,16(R13)          SAVE SAVEAREA LENGTH\n         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN\n         LR    R13,R2              SET SAVEAREA POINTER\n         USING WORK,R13            USING ON WORKAREA VIA R13\n         EJECT\n*---------------------------------------------------------------------*\n*        PROCESS THE INPUT PARAMETER LIST                             *\n*---------------------------------------------------------------------*\n         LR    R5,R0               -> ENVIRONMENT BLOCK\n         ST    R5,ENVBADDR         Save Environment Block Address\n         USING ENVBLOCK,R5\n         L     R5,ENVBLOCK_IRXEXTE -> EXTERNAL VECTOR TABLE\n         DROP  R5\n         USING IRXEXTE,R5\n         L     R5,IRXEXCOM         LOAD IRXEXCOM EPA\n         ST    R5,EXCOM            SAVE IRXEXCOM EPA\n         DROP  R5\n         LR    R4,R1               -> EFPL\n         USING EFPL,R4             ESTABLISH ADDRESSABILITY TO EFPL\n         L     R5,EFPLEVAL         -> EVAL BLOCK ADDRESS POINTER\n         L     R5,0(0,R5)          -> EVAL BLOCK\n         ST    R5,EVALADDR         SAVE IT'S ADDRESS\n         L     R4,EFPLARG          -> ARGUMENT LIST\n         DROP  R4\n*\n         LTR   R4,R4               ANY ARGUMENT LIST ?\n         BZ    SETDEF              NO\n*\n         USING ARGTABLE_ENTRY,R4   ESTABLISH ADDRESSABILITY TO ARG\n         CLC   =8X'FF',ARGTABLE_ARGSTRING_PTR  ANY REAL ARGUMENTS\n         BE    SETDEF              NO - SO EXIT\n         L     R2,ARGTABLE_ARGSTRING_PTR    -> ARGUMENT\n         L     R3,ARGTABLE_ARGSTRING_LENGTH LOAD LENGTH\n         C     R3,=F'08'           Test length\n         BNE   EXIT8               Invalid parm\n         BCTR  R3,R0               LESS 1 FOR MVC\n         EX    R3,MOVETIME         MOVE THE TIME\n         B     START\nSETDEF   MVC   WAITTIME(8),=CL8'00001500'\n         EJECT\n*---------------------------------------------------------------------*\n*        INITIALIZE ALL WORK AREAS FROM OUR CONSTANTS                 *\n*---------------------------------------------------------------------*\nSTART    DS    0H\n*\n         STIMER WAIT,DINTVL=WAITTIME\n         SPACE 2\n         B     EXIT0\n         EJECT\n*---------------------------------------------------------------------*\n*        ALL OF THE EXIT ROUTINES FOLLOW                              *\n*---------------------------------------------------------------------*\nSETRC    DS    0H\n         L     R11,EVALADDR\n         USING EVALBLOCK,R11\n         MVC   EVALBLOCK_EVLEN(4),=A(2)\n         MVC   EVALBLOCK_EVDATA(2),RC\n         DROP  R11\n         SPACE 2\n         LR    R1,R13              GET SAVEAREA ADDRESS\n         L     R13,4(R13)          GET BACK CHAIN POINTER\n         L     R0,16(R13)          GET SAVEAREA LENGTH\n         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)\n         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA\n         LM    R14,R12,12(R13)     RESTORE CALLERS REGS\n         LA    R15,0                                        $1/95$\n         BR    R14\n*---------------------------------------------------------------------*\nEXIT0    DS    0H\n         MVC   RC,=C'00'           SET RC TO ZERO\n         B     SETRC\nEXIT8    DS    0H\n         MVC   RC,=C'08'           SET RC TO 8\n         B     SETRC\nEXIT24   DS    0H\n         MVC   RC,=C'24'           SET RC\n         B     SETRC\n         EJECT\n*---------------------------------------------------------------------*\n*        EXECUTED INSTRUCTIONS                                        *\n*---------------------------------------------------------------------*\nMOVETIME MVC   WAITTIME(0),0(R2)       ** EXECUTED\n         SPACE 2\n*---------------------------------------------------------------------*\n*        LITERAL POOL                                                 *\n*---------------------------------------------------------------------*\n         LTORG\n         space 2\n*---------------------------------------------------------------------*\n*        WORK AREA DSECTS                                             *\n*---------------------------------------------------------------------*\nWORK     DSECT\nSAVE     DS    18F\nEVALADDR DS    F\nEXCOM    DS    A                   ADDRESS OF IRXEXCOM LOAD MODULE\nENVBADDR DS    A                   Environment Block Address\nWAITTIME DS    CL8                 Time value\nRC       DS    XL2                 RETURN CODE\n         EJECT\n         IRXEFPL DSECT=YES\n         EJECT\n         IRXARGTB\n         EJECT\n         IRXSHVB\n         EJECT\n         IRXEVALB\n         EJECT\n         IRXEXTE\n         EJECT\n         IRXENVB\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RUNC": {"ttr": 34307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x06\\x01\\x006\\x01\\x17\\x00O\\x01 !/\\x06'!w<\\xb5\\x00\\x00\\xd9\\xe4\\xd5\\xc3@@@@@@\"", "ispf": {"version": "06.01", "flags": 0, "createdate": "2017-01-04T00:00:00", "modifydate": "2020-07-30T06:27:36", "lines": 8567, "newlines": 15541, "modlines": 0, "user": "RUNC"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "RUNCPP": {"ttr": 37641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x161\\x1f\\x01\\x161\\x1f!B\\x0cW\\x0cW\\x00\\x00\\xd7\\xd6\\xe6\\xc5\\xd9\\xd7\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-06T00:00:00", "modifydate": "2016-11-06T21:42:07", "lines": 3159, "newlines": 3159, "modlines": 0, "user": "POWERPT"}, "mimetype": "application/vnd.openxmlformats-officedocument.presentationml.presentation", "datatype": "binary", "extension": ".pptx"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT312/FILE312.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT312", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}