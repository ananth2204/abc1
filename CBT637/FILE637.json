{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012515000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE637.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE637.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\x13'", "DS1TRBAL": "b'\\x12\\xfe'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x92\\x00\\x05\\x04\\x92\\x00\\x07\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x052\\x9f\\x01\\x052\\x9f\\x12#\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-25T00:00:00", "modifydate": "2005-11-25T12:23:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-470"}, "text": "REGULAR CBT TAPE - VERSION 470    FILE:  637\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT470.FILE637\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 5 MEMBERS COUNTED; CUMULATIVE SIZE IS 485 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/25/05    12:23:31    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x03\\x17o\\x01\\x03\\x17o\\x08X\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-06-25T00:00:00", "modifydate": "2003-06-25T08:58:29", "lines": 18, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: Re: help\nDate: Fri, 13 Jun 2003 16:52:49 -0500\nFrom: nyoung@awginc.com\nTo: sbgolob@cbttape.org\n\nHi Sam:\n\nHere's my own compare program.  If you think others may find it useful,\nI'll have to spruce up the doc and maybe address the limitations.\n\nNice talking to you today.  I'm definitely going to download the\ndisassembler(s) you mentioned.\n\n(See attached file: awgcprl1.txt)\n\nNolan Young\nAWG Technical Services\n913-288-1180\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE2": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x052\\x9f\\x01\\x052\\x9f\\x12\\x06\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-11-25T00:00:00", "modifydate": "2005-11-25T12:06:39", "lines": 18, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:      file 637\nFrom:         nyoung@awginc.com\nDate:         Fri, 25 Nov 2005 09:52:47 -0600\nTo:           sbgolob@cbttape.org\n\nSam:\n\nPer your phone call this morning, here it is:\n(See attached file: file637.tsoxmit)\n\nChanged \"COPY REQUATE\" to \"YREGS\" and changed first GETMAIN to\nLOC=ANY.\n\nBest wishes,\nNolan Young\nAWG Technical Services\n816-502-1748 (USA Central Standard Time: GMT-6)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE637": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x052\\x9f\\x01\\x052\\x9f\\x12\"\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-25T00:00:00", "modifydate": "2005-11-25T12:22:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CBT-470"}, "text": "//***FILE 637 is from Nolan Young, and contains a load module       *   FILE 637\n//*           compare program.  It is probably most useful for      *   FILE 637\n//*           finding zaps, between original versions and zapped    *   FILE 637\n//*           versions of a load module.                            *   FILE 637\n//*                                                                 *   FILE 637\n//*           email:  nyoung@awginc.com                             *   FILE 637\n//*                                                                 *   FILE 637\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AWGCPRL1": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00V\\x00\\x97\\x08_\\x01\\x052\\x9f\\t\\x07\\x01\\xae\\x01\\x12\\x00\\x00{\\xe3\\xd5\\xd9\\xe8@@@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "1997-03-26T00:00:00", "modifydate": "2005-11-25T09:07:56", "lines": 430, "newlines": 274, "modlines": 0, "user": "#TNRY"}, "text": "*---------------------------------------------------------------------*\n* Name:          AWGCPRL1\n* Author:        Nolan Young <nyoung@awginc.com>\n* Date:          Originally written in 1997.\n* Installation:  Associated Wholesale Grocers, Kansas City, KS\n* Attributes:    Non-reentrant, authorized.\n* Function:      Compares pairs of load modules.\n* Limitations:   (1) If module to be compared is non-executable,\n*                abend S706-4 will occur on LOAD SVC.\n*                (2) Must be authorized because of ADRNAPF parm of\n*                LOAD SVC.\n* Technique:     Loads both modules into memory and compares them with\n*                CLCL instruction.  If modules are of unequal length,\n*                no comparison is done.\n* Options:       Saying PARM=SNAP will snap-dump modules that are\n*                unequal (so you can look at them).\n* Input:         If only one member name is specified, that member\n*                is loaded from both LIB1 and LIB2.\n* Misc.:         I have written another program which compares entire\n*                load libraries.  It is a separate module and needs\n*                more work.\n*\n* Maint:\n* 10/13/2005     Changed first GETMAIN to LOC=ANY.\n*\n* //COMPARE  EXEC PGM=AWGCPRL1  ,PARM=SNAP\n* //STEPLIB   DD DSN=#TNRY.LOAD,DISP=SHR <== MUST BE AUTHORIZED\n* //REPORT    DD SYSOUT=*\n* //SNAP      DD SYSOUT=*,OUTLIM=50000\n* //LIB1      DD DISP=SHR,DSN=#TNRY.LOAD.BLK27998\n* //LIB2      DD DISP=SHR,DSN=#TNRY.LOAD.BLK6144\n* //INPUT     DD *\n* MEMBER\n* MEMBERA1 MEMBERA2\n* //\n*\n*---------------------------------------------------------------------*\n         MACRO                                                          00001\n&LABEL   ENTER &USER=12,&SAVE=SAVE                                      00002\n         LCLB  &SW                                                      00003\n         AGO   .EDUSER                                                  00004\n.RETUS   ANOP                                                           00005\n         AIF   (&SW).END                                                00008\n&LABEL   CSECT                                                          00009\n         B     28(0,15)           BRANCH AROUND IDENTIFIERS\n         DC    CL8'&LABEL'        CSECT NAME\n         DC    CL8'&SYSDATC'      ASSEMBLY DATE\n         DC    CL8'&SYSTIME'      ASSEMBLY TIME\n         SAVE  (14,12)            SAVE CALLER'S REGS                    00010\n         LR    &USER,15           LOAD BASE REG WITH ENTRY POINT        00011\n         USING &LABEL,&USER       ESTABLISH ADDRESSABILITY              00012\n         CNOP  0,4                ALIGN NEXT INSTRUCTION & SAVE AREA\n         B     *+76               BRANCH AROUND SAVE AREA\n&SAVE    DC    18F'0'             MY SAVE AREA\n         LR    15,13              CALLER'S SAVE AREA ADDR\n         LA    13,&SAVE           MY SAVE AREA ADDR\n         ST    15,4(,13)          CALLER'S SAVEAREA ADDR IN MY HSA\n         ST    13,8(,15)          MY SAVEAREA ADDR IN CALLER'S LSA\n         AGO   .END                                                     00019\n.EDUSER  ANOP                                                           00020\n         AIF   (T'&USER NE 'N').USERROR                                 00021\n         AIF   (&USER LT 2 OR &USER GT 12).USERROR                      00022\n         AGO   .RETUS                                                   00023\n.USERROR ANOP                                                           00024\n         MNOTE 8,'BASE REGISTER MUST BE A NUMBER BETWEEN 2 AND 12'      00025\n&SW      SETB  1                                                        00026\n         AGO   .RETUS                                                   00027\n.END     ANOP                                                           00034\n         MEND                                                           00035\n*\n         EJECT\n         YREGS                    REGISTER EQUATES\nAWGCPRL1 AMODE 31\nAWGCPRL1 RMODE 24\nAWGCPRL1 ENTER                    STANDARD OS HOUSEKEEPING\n*---------------------------------------------------------------------*\n* GET EXEC PARM (IF ANY).\n*---------------------------------------------------------------------*\nGET_PARM DS    0H\n         L     R3,0(,R1)          PARM ADDRESS\n         XR    R4,R4              CLEAR R4\n         LH    R4,0(,R3)          PARM LENGTH\n         LTR   R4,R4              NO PARM SPECIFIED?\n         BZ    NOPARM             YES, BYPASS\n         STH   R4,PARMLEN         PARM LENGTH\n         BCTR  R4,R0              SUBTRACT ONE FOR EX\n         EX    R4,MOVEPARM        MOVE PARM TO FIELD\n         B     OPEN_FILES         CONTINUE\n*\nMOVEPARM MVC   PARMTEXT(0),2(R3)  USED BY EX\n*\nNOPARM     DS  0H\nOPEN_FILES DS  0H\n*---------------------------------------------------------------------*\n* OPEN FILES.\n*---------------------------------------------------------------------*\n         OPEN  (PDS1DCB,INPUT,PDS2DCB,INPUT)\n         OPEN  (INPUTDCB,INPUT,RPTDCB,OUTPUT)\n         OPEN  (SNAPDCB,OUTPUT)\n*---------------------------------------------------------------------*\n* READ DATA RECORDS.\n*---------------------------------------------------------------------*\nGET_INPUT  DS  0H\n         MVC   MOD1_NAME,=CL8' '  BLANK WORK FIELD\n         MVC   MOD2_NAME,=CL8' '  BLANK WORK FIELD\n         GET   INPUTDCB           GET NEXT INPUT RECORD\n         LR    R3,R1              RECORD ADDRESS\n         CLI   0(R3),C' '         FIRST BYTE = BLANK?\n         BE    BLANK_1ST_COL\n         XC    TRTTBL,TRTTBL      CLEAR OUT TRANSLATE TABLE\n         MVI   TRTTBL+64,X'FF'    SET UP TO SCAN FOR BLANK\n         TRT   0(72,R3),TRTTBL    SCAN\n         BC    6,GOT_MOD1         FOUND IT\n         B     BAD_MOD1_NAME      NOT FOUND, EXIT\nGOT_MOD1 DS    0H\n         LR    R15,R1             SAVE ADDR OF BLANK\n         SR    R15,R3             (BLANK ADDR) - BEGIN = WORD LEN\n         LTR   R15,R15            LEN = 0?\n         BZ    BAD_MOD1_NAME      YES, ERROR\n         CH    R15,=H'8'          WORD LEN > 8?\n         BH    BAD_MOD1_NAME      YES, ERROR\n         BCTR  R15,R0             SUBTRACT 1 FOR EX INSTRUCTION\n         EX    R15,MOVE_MOD1      MOVE TO WORK FIELD\n         B     GET_MOD2\nMOVE_MOD1 MVC  MOD1_NAME(0),0(R3) USED BY EX\nGET_MOD2  DS   0H\n         LA    R4,1(,R1)          POINT PAST BLANK\n         TRT   0(63,R4),TRTTBL   SCAN FOR NEXT BLANK\n         BC    6,GOT_MOD2         FOUND IT\n         MVC   MOD2_NAME,MOD1_NAME  MOD2 = MOD1\n         B     END_SCAN           PROCEED\nGOT_MOD2 DS    0H\n         CR    R1,R4              LEN > 0?\n         BH    GET_MOD2_NAME_LEN  YES, GET LENGTH OF MOD2 NAME\n         MVC   MOD2_NAME,MOD1_NAME  NO, MOD2 MISSING; MAKE = TO MOD1\n         B     END_SCAN\nGET_MOD2_NAME_LEN DS  0H\n         SR    R1,R4              (BLANK ADDR) - BEGIN = WORD LEN\n         LTR   R1,R1              LEN > 0?\n         CH    R1,=H'8'           WORD LEN > 8?\n         BH    BAD_MOD2_NAME      YES, EXIT\n         BCTR  R1,R0              SUBTRACT 1 FOR EX INSTRUCTION\n         EX    R1,MOVE_MOD2_NAME  MOVE TO WORK FIELD\n         B     END_SCAN\nMOVE_MOD2_NAME MVC  MOD2_NAME(0),0(R4) USED BY EX\nEND_SCAN DS    0H\n         BAL   R14,COMPARE_MODS   PERFORM COMPARE\n         B     GET_INPUT          NEXT INPUT RECORD\nBLANK_1ST_COL  DS    0H\n         MVC   PRTLINE(L'MSG6),MSG6   MOVE MSG\n         BAL   R11,PRINT          PERFORM PRINT\n         B     GET_INPUT          NEXT INPUT RECORD\nBAD_MOD1_NAME DS 0H\n         MVC   PRTLINE(80),0(R3)  MOVE RECORD TO PRINT LINE\n         MVC   MSG1(3),=C'1ST'\n         MVC   PRTLINE+80(L'MSG1),MSG1   MOVE MSG\n         BAL   R11,PRINT          PRINT\n         B     GET_INPUT          NEXT RECORD\nBAD_MOD2_NAME DS 0H\n         MVC   PRTLINE(80),0(R3)  MOVE RECORD TO PRINT LINE\n         MVC   MSG1(3),=C'2ND'\n         MVC   PRTLINE+80(L'MSG1),MSG1   MOVE MSG\n         BAL   R11,PRINT          PRINT\n         B     GET_INPUT          NEXT RECORD\n*----------------------------------------------------------------------\nCOMPARE_MODS DS  0H\n         ST    R14,COMPARE_MODS_SAVE   SAVE RETURN ADDR\n         LA    R9,BLDL_NAME       ADDR OF BLDL NAME\n         USING PDS2,R9            PDS ENTRY DSECT\nBLDL_MOD1 DS   0H\n         MVC   BLDL_NAME,MOD1_NAME  MOVE BLDL NAME FROM INPUT\n         BLDL  PDS1DCB,BLDL_LIST\n         LTR   R15,R15            MEMBER FOUND?\n         BP    MOD1_BLDL_FAILED   YES, BRANCH\n         XR    R5,R5              CLEAR REG\n         ICM   R5,B'0111',PDS2STOR  MOVE LOW 3 BYTES\n         ST    R5,MOD1_SIZE       SAVE MODULE SIZE\nBLDL_MOD2 DS   0H\n         MVC   BLDL_NAME,MOD2_NAME  MOVE BLDL NAME FROM INPUT\n         BLDL  PDS2DCB,BLDL_LIST\n         LTR   R15,R15            MEMBER FOUND?\n         BP    MOD2_BLDL_FAILED   YES, BRANCH\n         XR    R5,R5              CLEAR REG\n         ICM   R5,B'0111',PDS2STOR  MOVE LOW 3 BYTES\n         ST    R5,MOD2_SIZE       SAVE MODULE SIZE\n*\n         CLC   MOD1_SIZE,MOD2_SIZE SAME SIZE AS MOD1?\n         BNE   LENGTHS_UNEQUAL    NO, DON'T PROCEED\n*        GETMAIN RU,LV=(R5),LOC=BELOW,BNDRY=PAGE\n         GETMAIN RU,LV=(R5),LOC=ANY,BNDRY=PAGE\n         ST    R1,AMODAREA        STG ADDR\n         GETMAIN RU,LV=(R5),LOC=ANY,BNDRY=PAGE\n         ST    R1,AMODSAVE        STG ADDR\n         L     R2,AMODAREA        ADDR FOR LOAD OF MODULE\n         MODESET MODE=SUP         REQUIRED BY ADRNAPF LOAD PARM\n         LOAD  EPLOC=MOD1_NAME,DCB=PDS1DCB,ADRNAPF=(R2)\n         MODESET MODE=PROB        RETURN TO PROBLEM STATE\n         L     R6,AMODAREA        ADDRESS OF MOD FROM LIB1\n         LR    R7,R5              LENGTH FOR 2ND MVCL OPERAND\n         L     R4,AMODSAVE        SAVED MOD AREA ADDRESS\n         MVCL  R4,R6              MOVE MOD1 TO SAVED AREA\n         BC    8,MVCL_CC0\n* ABEND IF UNEXPECTED CC FROM MVCL.\n         BC    4,MVCL_CC1\n         BC    2,MVCL_CC2\n         BC    1,MVCL_CC3\nMVCL_CC1 ABEND 1,DUMP\nMVCL_CC2 ABEND 2,DUMP\nMVCL_CC3 ABEND 3,DUMP\n*\nMVCL_CC0 DS    0H\n         LTR   R5,R5              R5=0 (ALL BYTES MOVED)?\n         BZ    TEST_R7            YES\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,JPA,SPLS),ID=5\nTEST_R7  LTR   R7,R7              R7=0 (ALL BYTES MOVED)?\n         BZ    MVCL_END           YES\n         SNAP  DCB=SNAPDCB,PDATA=(REGS,JPA,SPLS),ID=7\nMVCL_END DS    0H\n*\nLOAD_2   DS    0H\n         MODESET MODE=SUP         REQUIRED BY ADRNAPF LOAD PARM\n         LOAD  EPLOC=MOD2_NAME,DCB=PDS2DCB,ADRNAPF=(R2)\n         MODESET MODE=PROB        RETURN TO PROBLEM STATE\n         L     R4,AMODSAVE        ADDR OF COPY OF MOD1\n         L     R6,AMODAREA        ADDR OF MOD2\n         L     R5,MOD1_SIZE       RESTORE MOD1 LENGTH\n         LR    R7,R5              LENGTH FOR 2ND CLCL OPERAND\n         CLCL  R4,R6              COMPARE MODULES\n         BNE   UNEQUAL            IF UNEQUAL, BRANCH\n         MVC   MSG3_MOD1_NAME,MOD1_NAME\n         MVC   MSG3_MOD2_NAME,MOD2_NAME\n         MVC   PRTLINE(MSG3_LEN),MSG3   MOVE EQUAL MSG\n         BAL   R11,PRINT          PRINT\n         B     FREE_WORK_AREAS\nMOD1_BLDL_FAILED  DS  0H\n         MVC   MSG7_MOD,MOD1_NAME  MOVE MOD NAME TO MSG\n         MVI   MSG7_LIB,C'1'       MOVE LIB # TO MSG\n         MVC   PRTLINE(MSG7_LEN),MSG7   MOVE MSG\n         BAL   R11,PRINT           PRINT\n         MVC   RETURN_CODE,=H'4'   SET RETURN CODE\n         B     COMPARE_MODS_END\nMOD2_BLDL_FAILED  DS  0H\n         MVC   MSG7_MOD,MOD2_NAME  MOVE MOD NAME TO MSG\n         MVI   MSG7_LIB,C'2'       MOVE LIB # TO MSG\n         MVC   PRTLINE(MSG7_LEN),MSG7   MOVE MSG\n         BAL   R11,PRINT PRINT     PRINT\n         MVC   RETURN_CODE,=H'4'   SET RETURN CODE\n         B     COMPARE_MODS_END\nUNEQUAL  DS    0H\n*---------------------------------------------------------------------*\n* CALCULATE OFFSET OF NON-MATCH AND CONVERT IT TO DISPLAYABLE HEX.\n*---------------------------------------------------------------------*\n         L     R8,AMODSAVE        ADDR OF MOD SAVE\n         SR    R4,R8              GET OFFSET OF UNEQUAL BYTE\n         ST    R4,FULLWORD        SAVE IN DATA FLD\n         UNPK  WORKHEX,FULLWORD(5)  UNPACK HEX FLD\n         LA    R15,HEXTBL         POINT TO...\n         SH    R15,=H'240'          TRANSLATE TABLE\n         TR    WORKHEX(8),0(R15)  CONVERT TO DISPLAY HEX\n         MVC   MSG4_MOD1_NAME,MOD1_NAME\n         MVC   MSG4_MOD2_NAME,MOD2_NAME\n         MVC   MSG4_OFFS,WORKHEX   MOVE TO DISPLAY FLD\n         MVC   PRTLINE(MSG4_LEN),MSG4  MOVE MSG\n         BAL   R11,PRINT           PRINT\n         MVC   RETURN_CODE,=H'8'   SET RETURN CODE\n*---------------------------------------------------------------------*\n* SNAP, IF DESIRED, TO SEE MODULES.\n*---------------------------------------------------------------------*\n         CLC   =C'SNAP',PARMTEXT  SNAP REQUESTED IN EXEC PARM?\n         BNE   SNAP_END           NO, SKIP\n         L     R4,AMODSAVE        ADDR OF COPY OF MOD1\n         LR    R5,R4              ALSO IN R5\n         A     R5,MOD1_SIZE       ADD SIZE OF MOD\n         L     R15,SNAP_NUM       SNAP NUMBER\n         LA    R15,1(,R15)        ADD 1 TO SNAP NUMBER\n         ST    R15,SNAP_NUM       SAVE\n         SNAP  DCB=SNAPDCB,PDATA=(REGS),ID=(R15),                      +\n               STORAGE=((R4),(R5))\n         L     R6,AMODAREA        ADDR OF MOD1\n         LR    R7,R6              ALSO IN R7\n         A     R7,MOD1_SIZE       ADD SIZE OF MOD\n         L     R15,SNAP_NUM       SNAP NUMBER\n         LA    R15,1(,R15)        ADD 1 TO SNAP NUMBER\n         ST    R15,SNAP_NUM       SAVE\n         SNAP  DCB=SNAPDCB,PDATA=(REGS),ID=(R15),                      +\n               STORAGE=((R6),(R7))\n*\nSNAP_END DS    0H\n         B     FREE_WORK_AREAS\n*\nLENGTHS_UNEQUAL  DS  0H\n         MVC   MSG2_MOD1_NAME,MOD1_NAME  MOVE TO MSG FLD\n         MVC   MSG2_MOD2_NAME,MOD2_NAME  MOVE TO MSG FLD\n         UNPK  WORKHEX,MOD1_SIZE(5) UNPACK HEX FLD\n         LA    R15,HEXTBL         POINT TO...\n         SH    R15,=H'240'          TRANSLATE TABLE\n         TR    WORKHEX(8),0(R15)  CONVERT TO DISPLAY HEX\n         MVC   MSG2_MOD1_SIZE,WORKHEX  MOVE TO DISPLAY FLD\n*\n         UNPK  WORKHEX,MOD2_SIZE(5) UNPACK HEX FLD\n         LA    R15,HEXTBL         POINT TO...\n         SH    R15,=H'240'          TRANSLATE TABLE\n         TR    WORKHEX(8),0(R15)  CONVERT TO DISPLAY HEX\n         MVC   MSG2_MOD2_SIZE,WORKHEX  MOVE TO DISPLAY FLD\n*\n         MVC   PRTLINE(MSG2_LEN),MSG2   MOVE ERROR MSG\n         BAL   R11,PRINT\n         MVC   RETURN_CODE,=H'8'\n         B     COMPARE_MODS_END\n*\nFREE_WORK_AREAS  DS  0H\n         L     R5,MOD1_SIZE       SIZE OF MOD1\n         L     R2,AMODAREA        ADDR OF MOD\n         FREEMAIN RU,LV=(R5),A=(R2)  FREE THE STORAGE\n         L     R2,AMODSAVE        SIZE OF SAVED MOD\n         FREEMAIN RU,LV=(R5),A=(R2)  FREE THE STORAGE\n*\nCOMPARE_MODS_END  DS  0H\n         L     R14,COMPARE_MODS_SAVE   LOAD RETURN ADDR\n         BR    R14\n*----------------------------------------------------------------------\nEOF      DS    0H\nENDIT    DS    0H\n         CLOSE (PDS1DCB,,PDS2DCB,,RPTDCB,,INPUTDCB)\n         CLOSE SNAPDCB\nEXIT     DS    0H\n         LH    R15,RETURN_CODE\n         L     R13,SAVE+4         CALLER'S SAVEAREA ADDR\n         RETURN (14,12),RC=(15)   RELOAD REGS AND RETURN TO CALLER\n*\nPRINT    DS    0H\n         PUT   RPTDCB,PRTLINE     PRINT A LINE\n         MVI   PRTLINE,C' '       SPACE OUT...\n         MVC   PRTLINE+1(L'PRTLINE-1),PRTLINE  PRINT LINE\n         BR    R11\n*---------------------------------------------------------------------*\n* DATA AREAS\n*---------------------------------------------------------------------*\nGETMEMS_SAVE  DS  F\nCOMPARE_SAVE  DS  F\nNEXT_MEM1_SAVE  DS  F\nNEXT_MEM2_SAVE  DS  F\nCOMPARE_MODS_SAVE  DS  F\nAMOD1    DS    F\nAMOD2    DS    F\nMOD1_SIZE DS   F\nMOD2_SIZE DS   F\nMAXSIZE DC     A(5*1024*1024)  5 MEG  <===========================\nAMODAREA DS    F\nAMODSAVE DS    F\nPARMLEN  DS    H\nPARMTEXT DC    CL6' '\n         DS    0D\nHIVAL    DC    8X'FF'\n         DS    0D\nSNAPSTRT DC    C'SNAPSTRT'\nSNAP_NUM DC    F'0'\nMOD1_NAME DS   CL8\nMOD2_NAME DS   CL8\nSNAPEND  DC    C'SNAPEND '\nRETURN_CODE  DC  F'0'\n         DS    0D\nBUFFER   DS    CL256\nWORKHEX  DS    CL9\nHEXTBL   DC    C'0123456789ABCDEF'  TRANSLATE TABLE FOR DISPLAY HEX\nTRTTBL   DS    CL256              TRANSLATE TABLE FOR TRT INSTR.\nFULLWORD DS    F\nBIGGEST_SIZE DC  FL3'0'\n*\nMSG1     DC    C'XXX MODULE NAME IS INVALID.'\n*\nMSG2     EQU   *\n         DC    C'MOD1='\nMSG2_MOD1_NAME  DC  CL8' '\n         DC    C', LEN IN LIB1='\nMSG2_MOD1_SIZE DC  CL8' '\n         DC    C'; MOD2='\nMSG2_MOD2_NAME  DC  CL8' '\n         DC    C', LEN IN LIB2='\nMSG2_MOD2_SIZE DC  CL8' '\nMSG2_LEN EQU   *-MSG2\n*\nMSG3     EQU   *\n         DC    C'MOD1='\nMSG3_MOD1_NAME DS   CL8\n         DC    C', MOD2='\nMSG3_MOD2_NAME DS   CL8\n         DC    C'; MODULES ARE EQUAL.'\nMSG3_LEN EQU   *-MSG3\n*\nMSG4     EQU   *\n         DC    C'MOD1='\nMSG4_MOD1_NAME DS   CL8\n         DC    C', MOD2='\nMSG4_MOD2_NAME DS   CL8\n         DC    C'; MODULES ARE UNEQUAL AT OFFSET X'''\nMSG4_OFFS DC    CL8' '\n         DC    C''''\nMSG4_LEN EQU   *-MSG4\n*\nMSG5     DC    C'        :  MODULE SIZE EXCEEDS WORKAREA'\n*\nMSG6     DC    C'INPUT MUST BEGIN IN COLUMN 1.'\n*\nMSG7     EQU   *\nMSG7_MOD DS    CL8\n         DC    C' IN LIB'\nMSG7_LIB DS    C\n         DC    C':  BLDL FAILED.'\nMSG7_LEN EQU   *-MSG7\n*\nBLDL_LIST DS   0F\n         DC    H'1'\nBLDL_ENTRY1   DC    AL2(BLDL_ENTRY_LEN)\nBLDL_NAME DC    CL8' '\n         DC    XL58'00'\nBLDL_ENTRY_LEN EQU   *-BLDL_ENTRY1\n*\nPRTLINE  DC    CL133' '\nPDS1DCB  DCB   DSORG=PO,MACRF=R,DDNAME=LIB1  ,EODAD=EOD_LIB1\nPDS2DCB  DCB   DSORG=PO,MACRF=R,DDNAME=LIB2  ,EODAD=EOD_LIB2\nINPUTDCB DCB   DSORG=PS,RECFM=FB,DDNAME=INPUT,MACRF=GL,EODAD=EOF,      +\n               LRECL=80  BLKSIZE=0\nRPTDCB   DCB   DSORG=PS,RECFM=FB,DDNAME=REPORT,MACRF=PM,               +\n               LRECL=133  BLKSIZE=0\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,LRECL=125,BLKSIZE=1632,MACRF=W,      +\n               DDNAME=SNAP\n         LTORG\n         IHAPDS PDSBLDL=YES\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT637/FILE637.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT637", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}