         TITLE  'ENQWATCH - Monitor ENQs'
ENQWATCH CSECT
ENQWATCH AMODE 31
ENQWATCH RMODE 24
         USING ENQWATCH,R15         Temporary base
***********************************************************************
*   Constants for installation tweaking                               *
***********************************************************************
MAXMSGS  EQU    5                   Maximum number of messages to
*                                   send to a TSO user who owns a
*                                   dataset
MAXOWNER EQU    50                  Maximum number of dataset
*                                   owners that can be tracked
*REASIZE EQU    10000               Size of area for RIBs and RIBEKF003
AREASIZE EQU    10                  Size of area for RIBs and RIBEKF003
*                                   returned by GQSCAN
WAITTIME EQU    60                  Number of seconds to wait     KF001
SMFREC   EQU    223                 Value of the SMF record numberKF002
SMFON    EQU    1                   SMF default switch 1=on;0=off KF002
***********************************************************************
*                         E N Q W A T C H                             *
***********************************************************************
* Change Summary:                                                     *
* Change    By    Date       Description                              *
*  KF001  Kevin   08/02/2011 Added WAITTIME support code.             *
*  KF002  Kevin   24/02/2011 Added SMF Recording                      *
*  KF003  Kevin   28/02/2011 Reworked areasize issue                  *
***********************************************************************
*        COPY  BSLEQUC              Copy register equates
***********************************************************************
*                         REGISTER EQUATES                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
R0       EQU   0                                                      *
R1       EQU   1                                                      *
R2       EQU   2                                                      *
R3       EQU   3                                                      *
R4       EQU   4                                                      *
R5       EQU   5                                                      *
R6       EQU   6                                                      *
R7       EQU   7                                                      *
R8       EQU   8                       R E G E Q S                    *
R9       EQU   9                                                      *
R10      EQU   10      EQUATE PREFIX TO NUMERIC SYMBOLS IN ORDER      *
R11      EQU   11       TO MAKE THE USE OF REGISTER OPERANDS IN       *
R12      EQU   12       INSTRUCTIONS SELF EXPLANITORY.THIS ALSO       *
R13      EQU   13         CREATES ENTRIES IN CROSS REFERENCE.         *
R14      EQU   14                                                     *
R15      EQU   15                                                     *
FPR0     EQU   0                                                      *
FPR2     EQU   2                                                      *
FPR4     EQU   4                                                      *
FPR6     EQU   6                                                      *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                     MISCELLANEOUS EQUATES                           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
EQUHOBON EQU   X'80000000'   SET HIGH ORDER BIT ON                    *
PACKDIG  EQU   X'0F'         PACK DIGIT                               *
SMF_ON   EQU   B'10000000'                                        KF002
SMF_OFF  EQU   B'01111111'                                        KF002
*                                                              K.E.F. *
         BAKR  14,0
         LR    R12,R15              Load R12 for base
*        LAE   R11,2048(R15,0)      Set R11 as 2nd Base Register
*        LAE   R11,2048(R11,0)      Set R11 as @nd base register
*        USING R15+4096,R11
         DROP  R15
         USING ENQWATCH,R12         <=== Program base register
         B     START                Skip data
         DC    C'ENQWATCH'          Program-name
         DC    C'&SYSDATE'          Date
         DC    C'&SYSTIME'          Time
ver_no   DC    C'V2R2.01'           Version number
START    DS    0H                   Re-align on halfword-boundary
         L     R2,0(R1)             Preserve parms
         LA    R3,WORKAREA_LENGTH   Set length for workarea
         MODESET KEY=ZERO,MODE=SUP  Supervisor state for timer exit
         STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=(R3),LOC=BELOW
         LTR   R15,R15              Did we work?
         BNZ   CRUNCH               If not - Go to abend
         ST    13,4(,1)             Chain back to previous save area
         ST    1,8(,13)             Chain forward to new save area
         LR    13,1                 R13 reset to current save area
         LR    R11,R12              Second base register ...
*                                   ... (currently not used)
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'Start_msg,R15),Start_msg   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
         LTR   R2,R2                Test for parameters
         BE    Set_Default          None, take the default
         LH    R3,0(R2)             Get length of parameters
         LTR   R3,R3                Test for parameters
         BZ    Set_Default
         LA    R2,2(R2)             Skip length
         MVI   Wait_set_by,c'P'
         BAS   R14,Process_Wait     Go and process the wait time
         LTR   R15,R15              Wait time valid?
         BZ    Start_Info
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'Parm_errg,R15),Parm_errg   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
Set_Default DS 0H
         MVI   Wait_set_by,c'D'     Set default indicator
         LA    R4,WAITTIME          Waittime in R4 for conversion KF001
         MH    R4,=H'100'           Convert to hundreths ...      KF001
         ST    R4,DELAY             ... and save it.              KF001
*        MVC   Delay,=f'6000'       No parameter was specified    KF001
Start_Info DS  0H
         XC    SMF_Switch,SMF_Switch Set default to off           KF002
         MVI   SMF_set_by,c'D'      Set default indicator         KF002
* Set SMF record number in here
         LA    R7,SMFON             Get Value of SMFON            KF002
         C     R7,=F'1'             On?                           KF002
         BNE   SKIP_SMF_SET         No - Skip setting then        KF002
         OI    SMF_Switch,SMF_ON    Set the flag                  KF002
SKIP_SMF_SET DS 0H                                                KF002
         XR    R0,R0                Clear ever register           KF003
         LA    R1,AREASIZE          Get size                      KF003
         M     R0,=f'1000'          Multiply by 1000              KF003
*        LA    R7,AREASIZE                                        KF003
         ST    R1,Size_of_Area                                    KF003
         L     R1,16                CVT Address                   KF002
         L     R6,196(R1)           Load address of the SMCA      KF002
         MVC   SMFSID,16(R6)        Move in System Id from SMCA   KF002
         MVI   SMFSIND,X'06'        Set Id                        KF002
         LA    R1,SMFREC            Get record number             KF002
         ST    R1,SMF_Count         Save it in temparea           KF002
         MVC   SMFRECTY(1),SMF_Count+3 Move it to Skeleton        KF002
         LA    R1,SMFSLEN           Get length of SMF record ...  KF002
         STH   R1,SMFLEN            ... and save it in the record KF002
         BAS   R7,Print_info        Print the info
         MVC   EXTRACTL(EXT_LEN),EXTRACTS
         XR    R1,R1                Clear R1
         ST    R1,ECB               Save it as the ECB
         LA    R2,CIBAREA           Load R2 with where to load CIB
         EXTRACT CIBAREA,FIELDS=COMM,MF=(E,EXTRACTL)
         L     R2,CIBAREA           Load R2 with the returned addr
         USING COMLIST,R2           and establish addressability
         L     R5,COMCIBPT          Get the CIB address into R5...
         USING CIBNEXT,R5           ... and address it
         MVC   DATAAREA(16),CIBDATA Populate the Dataarea
         CLI   CIBVERB,CIBSTART     Is First CIB a start command ?
         BNE   SETLIMIT             No - Skip to set command limit
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R5)  Free the start CIB
         LTR   R15,R15              Did it work ?
         BZ    SETLIMIT             Yes - Go set some limits
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'FreeFailed_msg,R15),FreeFailed_msg   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
SETLIMIT DS    0H
         XC    Send_count,Send_count Clear counter
         XC    Loop_count,Loop_count Clear counter
         XC    SMF_count,SMF_count   Clear counter                KF002
         QEDIT ORIGIN=COMCIBPT,CIBCTR=2  Set Command limit to 2
         L     R4,COMECBPT          Pointer to the com ECB
         ST    R4,ECBADDR           Save the COM ECB in the ECBLIST
         XC    Current_count,Current_count  list starts empty
         LA    R0,Size_of_Area      Get amount of storage needed  KF003
*        STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=10000,LOC=BELOW      KF003
         STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=(R0),LOC=BELOW       KF003
         ST    R1,Dynamic_Area      Save it
         LA    R2,LENCUR            Size of workarea
         SLL   R2,1                 Double it (for previous too)
         ST    R2,Working_length    ... and save it safely away
         STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=(R2),LOC=BELOW
         ST    R1,Working_Area      ... and save it safely away too.
         BAS   R10,ENQ_Check        Go check current ENQs
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'Active_msg,R15),Active_msg   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
WAIT     DS    0H
         LA    R4,ECB               Address of REPLY_ECB in R4
         ST    R4,Lastone           Save it in list
         OI    Lastone+0,x'80'      Flag end of list
WAITLOOP STIMER REAL,TIMEEXIT,BINTVL=DELAY
WAITCIB  WAIT  1,ECBLIST=ECBADDR
         CLC   ECB(4),=F'0'         Timer pop?
         BE    COMPLETE             No - must be a stop
         BAS   R10,ENQ_Check        Go check current ENQs
         XC    ECB,ECB              Clear timer ECB ...
         B     WAIT                 ... and around we go
COMPLETE DS    0H
         L     R2,CIBAREA           Reload R2
         L     R5,COMCIBPT          Obtain CIB address
         CLI   CIBVERB,CIBMODFY     Was it a modify?
         BNE   EXIT                 No - Then is must be invalid
         CLC   CIBDATA(4),=C'STOP'  Is it a Shutdown command?
         BE    Exit                 Yes - Go to shutdown
         CLC   CIBDATA(4),=C'SHUT'  Is it a "SHUT" command?
         BE    Exit                 Yes - Go to shutdown
         CLC   CIBDATA(3),=C'END'   Is it a "END" command?
         BE    Exit                 Yes - Go to shutdown
         CLC   CIBDATA(5),=C'STATS' Is it a "Stats" command
         BE    Show_Stats              Yes - Go to re-issue
         CLC   CIBDATA(6),=C'STATUS' Is it a "Status" command
         BE    Show_Stats              Yes - Go to re-issue
         CLC   CIBDATA(4),=C'INFO'  Is it an INFO command
         BE    Show_Info               Yes - Go to re-issue
         CLC   CIBDATA(3),=C'SMF'   Is it an SMF command          KF002
         BE    Process_SMF             Yes - Go to process it     KF002
         CLC   CIBDATA(4),=C'WAIT'  Is it a WAIT command
         BE    Proces_Wait_command     Yes - Go and process it
         CLC   CIBDATA(5),=C'CYCLE' Is it a "CYCLE" command?
         BNE   Command_Invalid      No - skip to command_invalid
         L     R6,Cycle_Count       *
         LA    R6,1(R6)             * add 1 to counter
         ST    R6,Cycle_Count       *
         BAS   R10,ENQ_Check        Go and check now
End_of_Command_Process DS  0H
         L     R2,CIBAREA           Reload R2
         L     R5,COMCIBPT          Get CIB pointer
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R5)   Clear the CIB ...
         B     Wait                 ... and loop back to main wait
Process_SMF DS  0H                                                KF002
*        CLC   CIBDATLN,=h'3'       Check for Valid wait
*        BL    Command_Invalid      Invalid length - Then skip
         LA    R2,CIBDATA+3         Point to end of "SMF"         KF002
         CLI   0(r2),c' '           Space after wait?             KF002
         BE    Space_Found_SMF      Yes - Skip next check         KF002
         CLI   0(r2),c'='           '=' after wait?               KF002
         BNE   Invalid_SMF          No - card invalid             KF002
Space_Found_SMF DS 0H                                             KF002
         LA    R2,1(R2)             Skip '=' or ' '               KF002
         CLC   0(2,R2),=C'ON'       Is it SMF ON?                 KF002
         BNE   Try_Off                                            KF002
         OI    SMF_Switch,SMF_ON    Set the flag                  KF002
         LA    R3,1                                               KF002
         B     Set_SMF_Flag                                       KF002
Try_Off  DS    0H                                                 KF002
         CLC   0(3,R2),=C'OFF'      Is it SMF OFF?                KF002
         BNE   Invalid_SMF                                        KF002
         LA    R3,2                                               KF002
         XC    SMF_Switch,SMF_Switch Clear Switch                 KF002
Set_SMF_Flag DS 0H                                                KF002
         MVI   SMF_set_by,c'C'      Set command indicator         KF002
         BAS   R14,FORMAT_MSG       Format message and add prefix KF002
         MVC   0(l'SMF_Action,R15),SMF_Action   Get message       KF002
         LA    R15,l'SMF_Action(R15)                              KF002
         EX    R3,Move_CIB                                        KF002
         WTO   ,MF=(E,WTO_AREA)     Issue start message           KF002
         B     End_of_Command_Process                             KF002
Invalid_SMF    DS  0H                                             KF002
         BAS   R14,FORMAT_MSG       Format message and add prefix KF002
         MVC   0(l'SMF_Action,R15),SMF_Action   Get message       KF002
         LA    R15,l'SMF_Action(R15)                              KF002
         EX    R3,Move_CIB                                        KF002
         WTO   ,MF=(E,WTO_AREA)     Issue start message           KF002
         B     End_of_Command_Process  Go reset CIB               KF002
Move_CIB MVC   0(*-*,R15),0(R2)
Proces_Wait_command DS  0H
         CLC   CIBDATLN,=h'5'       Check for Valid wait
         BL    Invalid_Wait         Invalid length - Then skip
         LA    R2,CIBDATA+4         Point to end of "WAIT"
         CLI   0(r2),c' '           Space after wait?
         BE    Space_Found          Yes - Skip next check
         CLI   0(r2),c'='           '=' after wait?
         BNE   Invalid_wait         No - card invalid
Space_Found DS 0H
         LA    R2,1(R2)             Skip '=' or ' '
         XR    R3,R3                CLear R3
         LH    R3,CIBDATLN          Load Length
         SH    R3,=h'5'             Subtract length of wait=
         BAS   R14,Process_wait
         LTR   R15,R15              Value good?
         BNZ   Invalid_wait         No - Show error
         MVI   Wait_set_by,c'C'     Set flag for command
         BAS   R7,Print_wait_value  Print the value
         B     End_of_Command_Process
Invalid_Wait   DS  0H
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'Invalid_wat,R15),Invalid_wat   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
         B     End_of_Command_Process  Go reset CIB
COMMAND_INVALID DS  0H
         CLI   CIBVERB,CIBSTOP      Is it a STOP(P) Command?
         BE    exit                 No - Forget it
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'Invalid_cmd,R15),Invalid_cmd   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
         B     End_of_Command_Process  Go reset CIB
Show_Stats DS  0H
         BAS   R7,Print_Stats
         B     End_of_Command_Process
Show_Info  DS  0H
         BAS   R7,Print_Info
         B     End_of_Command_Process
*        TM    0(r2),X'40'          Was it a reply pop?
*        BNO   TRYMOD               No - Try modify
*        NI    ECB,X'00'            Reset ECB
*        B     Wait
Exit     DS    0H
         BAS   R7,Print_Stats
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'Stop_msg,R15),Stop_msg   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
         MVC   EXTRACTL(EXT_LEN),EXTRACTS
         L     R2,Working_length    Set length for Release
         L     R1,Working_Area
         STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=(R2)
         L     R1,Dynamic_Area
         L     R0,Size_of_Area                                    KF003
*        STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=10000               KF003
         STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=(R0)                KF003
         LA    R2,WORKAREA_LENGTH   Set length for Release
         LR    1,13                 Address of save area into R1
         L     13,4(1)              Chain, chain, chain
         STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=(R2)
         XR    15,15                Set condition code &
         PR    ,                    Get the heck out of Dodge
***********************************************************************
***      Process_Wait      Subroutine                               ***
***********************************************************************
Process_Wait DS 0H
         MVC   PARMBUF,=C'0000'     Clear buffer area
         LR    R4,R2                Save R2
         LA    R2,L'PARMBUF         Get length
         SLR   R2,R3                Calculate difference
         LA    R2,PARMBUF(R2)       Point to move area
         EX    R3,COPYPARM          Right justify parameter
         CLC   0(L'PARMBUF,R2),0(r4) nnnn numeric?
         BE    Parm_Numeric         Yes - Skip
         LA    R15,8
         B     Wait_return
Parm_Numeric DS 0H
         PACK  DOUBLE,PARMBUF       EBCDIC -> Decimal
         CVB   R4,DOUBLE            Decimal -> Binary
         MH    R4,=H'100'           Convert to .01 second units
         ST    R4,DELAY             Save for STIMER
         XR    R15,R15
Wait_return DS 0H
         BSM   0,R14                Return to caller
COPYPARM MVN   0(*-*,R2),0(R4)      Used for right-justifying input
***********************************************************************
***      Format_MSG        Subroutine                               ***
***********************************************************************
FORMAT_MSG DS 0H
         LA    R15,WTO_Area         Locate area
         MVC   0(SKEL_LEN,R15),WTO_Skel  Initialize area
         MVC   4(5,R15),=C'ENQW0'   Get ID
         LA    R15,4+5(R15)         Bump past area
         BSM   0,R14
***********************************************************************
CRUNCH   DS    0H
boom     EX    R15,boom             Crash out
***********************************************************************
*** This is the main ENQ check routine.                             ***
*** Exit is via Register 10                                         ***
***********************************************************************
ENQ_Check DS   0H
*        LD    FPR0,Loop_Count      * Load double word into floating
*        AD    FPR0,=D'1'           * Add 1
*        STD   FPR0,Loop_Count      * Save it
         L     R6,Loop_Count        *
         LA    R6,1(R6)             * Increase loop counter
         ST    R6,Loop_Count        *
         L     R6,Dynamic_area
***********************************************************************
*   Check for dataset contention via GQSCAN                           *
*   Limit scan to                                                     *
*         RESNAME=SYSDSN      to get only dataset ENQs.               *
*         WAITCNT=1           to get only resources with contention.  *
*         REQLIM=2            to get information on only the first    *
*                               two requestors for a dataset, since   *
*                               this program does not worry about     *
*                               other waiting jobs.                   *
*   When GQSCAN returns:                                              *
*         R0 contains size values for the RIB and RIBE                *
*         R1 contains the number of RIBs returned in SCANAREA         *
*         R15 contains a return code.                                 *
***********************************************************************
         L     R0,Size_of_Area                                    KF003
*        GQSCAN AREA=((6),10000),SCOPE=ALL,RESNAME=QNAME,             X
         GQSCAN AREA=((6),(R0)),SCOPE=ALL,RESNAME=QNAME,               X
               WAITCNT=1,REQLIM=2,MF=(E,SCANLIST)
         C     R15,=F'8'            Good return code (<=8)
         BH    ERROR                No, some unexpected error
         ST    R0,RIB_Size          Save size of RIB and RIBEs
         ST    R1,RIBSLEFT          Save number of RIBs
         L     R3,Working_length    Load length
         SRL   R3,1                 Half it
         L     R2,Working_area      Point to area
         LR    R4,R2                Previous area
         LA    R4,0(R3,R4)          Shuffle up
         LR    R5,R3                Copy length into R5
         MVCL  R4,R2                Copy Current -> Previous
         MVC   Previous_Count,Current_Count  Load previous count
         XC    Current_Count,Current_Count   Clear Current count
         L     R6,Dynamic_area      Point back at dynamic area
         L     R1,RIBSLEFT          Save number of RIBs
         LTR   R1,R1                Test number of RIBs returned
         BE    Non_returned         If none were returned, then
         USING RIB,R6               Address the RIB
***********************************************************************
*        Check RIB to see if it matches the search criteria.          *
***********************************************************************
CHECKRIB DS    0H
         ST    R1,RIBSLEFT          Save remaining number of RIBs
         L     R2,RIBNRIBE          Get number of RIBS
         LA    R3,2
         CR    R2,R3                Do we have 2?
         BL    Next_RIB             If No, skip this RIB
         LR    R5,R6                Load RIB pointer into R5
         AH    R5,RIB_Length        Compute address of RIBVAR ...
         L     R1,RIBSLEFT          Save number of RIBs
         USING RIBVAR,R5            ... and address it
         LR    R7,R5                Load R7 with RIBE
         AH    R7,RIBVLEN           Get address of first RIBE
         LR    R2,R7                Get address of first RIBE
         AH    R2,RIBE_Length       Compute address of second RIBE
         TM    RIBESFLG-RIBE(R2),RIBESTAT  2nd person wanting it?
         BNZ   Next_RIB             No - Skip to next RIB
         USING RIBE,R7              Address the RIBE
         L     R2,CVTPTR            Load CVT address into R2
         CLC   CVTSNAME-CVTMAP(L'RIBESYSN,R2),RIBESYSN Our LPAR?
         BNE   Next_RIB             No - Skip as unable to notify users
***********************************************************************
*   At this point we have found a match for this system and resource  *
*   Now we check the table to see if it will fit                      *
***********************************************************************
         CLC   Current_Count,=A(MAXOWNER)  Is the Current list full?
         BNL   Next_RIB             Yes, must skip this RIB
         LA    R3,LENOWNER          Get size of an each entry
         M     R2,Current_Count     Multiply by Current_Count
         L     R4,Working_area
         LA    R2,0(R3,R4)          Point to current area
         L     R0,Current_Count     *
         LA    R0,1(R0)             *  Increase current count
         ST    R0,Current_Count     *
         USING OWNER,R2             Address the OWNER area
         XC    OWNER(LENOWNER),OWNER  Clear the OWNER area
         MVC   SMF_JOB,RIBEJBNM+48  Move in jobname ...           KF002
         MVC   Jobname,RIBEJBNM     Move in jobname ...
         MVC   JOBASID,RIBEASID     .. and ASID of holding job
         XR    R4,R4                Clear register 4
         IC    R4,RIBRNMLN          Get length of dataset name
*        C     R4,=F'44'            Compare to maximum dsname length
*        BL    Skip_trim            If less
*        LA    R4,44                Set max length
Skip_trim DS   0H
         STH   R4,LENDSN            Save the dsname length
         STH   R4,SMF_DSNLEN        Save the dsname length        KF002
         BCTR  R4,0                 Down length ready for execute
         EX    R4,Move_DSN          Move it into OWNER area
         EX    R4,Move_SMFDSN       Move it into SMF record       KF002
         LA    R3,1                 Set temp counter to first
         L     R0,Working_length    Load length
         SRL   R0,1                 Half it
         L     R15,Working_area     Point to area
         LA    R15,0(R0,R15)        Point at previous area
Look_Again DS  0H
         C     R3,Previous_Count    Are we done yet?
         BH    Next_RIB             Yes - Skip out
Compare  DS    0H
         CLC   Key-Owner(Lenkey,R15),Key  Match?
         BE    Matched_Key          Yes - go process matched key
Next_Owner DS  0H
         LA    R3,1(R3)             Add to counter
         LA    R15,Lenowner(R15)    and skip up previous area
         B     Look_Again           Now loop back to look again
***********************************************************************
***                  Executed Instructions                          ***
***********************************************************************
Move_DSN MVC   Dsname(*-*),RIBRNAME Move in dataset name
Move_SMFDSN MVC   SMF_Dsname(*-*),RIBRNAME Move in dataset name   KF002
***********************************************************************
*** Here we have identified a match on the RIB entry                ***
*** We will now call the chunk of code to send the message to the   ***
*** Holder of the contention if the user is a TSO session           ***
***********************************************************************
Matched_Key DS 0H
         MVC   DATA(LENDATA),DATA-OWNER(R15) Save in current list
         OI    STATUS-OWNER(R15),ONGOING Flag that we had previous hit
         LR    R1,R2                Point at current entry
         DROP  R2
*
         BAS   R14,Contention_Exists Go to process the contention
*
Next_RIB  DS   0H
         L     R2,RIBNRIBE          Get number of RIBEs for this RIB
         MH    R2,RIBE_Length       Compute total size of the RIBEs
         ALR   R7,R2                Compute address of next RIB
         LR    R6,R7                Save address of next RIB
         L     R1,RIBSLEFT          Get number of RIBs left
         BCT   R1,CHECKRIB          Process next RIB, if any
Non_returned   DS  0H
         USING OWNER,R1             Address the OWNER section
         LA    R3,1                 Set initial counter
         L     R0,Working_length    Load length
         SRL   R0,1                 Half it
         L     R1,Working_area      Point to area
         LA    R1,0(R0,R1)          Point at previous area
Check_looper DS    0H
         C     R3,Previous_Count    Have we finished?
         BH    ENQ_Check_Exit       Yes - Go get out
         TM    STATUS,ONGOING       Had this before?
         BNZ   Next_Entry           No - Go get next entry
*        BAS   R14,Contention_relieved Clear the entry
Next_Entry   DS    0H
         LA    R3,1(R3)             Next entry index ....
         LA    R1,Lenowner(R1)      .... and location
         B     Check_looper
         DROP  R1
ENQ_Check_Exit DS  0H
         BR    R10                  Return to sender
Error    DS    0H
         BAS   R14,FORMAT_MSG       Format message and add prefix
         MVC   0(l'QSCAN_Fail,R15),QSCAN_Fail   Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
         B     ENQ_Check_Exit
***********************************************************************
***      Contention Exists Subroutine                               ***
***********************************************************************
Contention_Exists DS 0H
         STM   R14,R12,Save1        Save the callers registers
         LR    R2,R1
         USING OWNER,R2             Address it
         LOCASCB ASID=JOBASID       Locate the OUCB
         LTR   R15,R15              Did we find it?
         BNE   Not_TSO_User         No - bomb out
         L     R1,ASCBOUCB-ASCB(,R1) Get the OUCB
         TM    OUCBYFL-OUCB(R1),OUCBLOG TSO user?
         BZ    Not_TSO_User         No - bomb out
         LR    R1,R2                Restore R1 for Sending message
         BAS   R14,Send_message     Go send the message
Not_TSO_User DS 0H
         LM    R14,R12,Save1        Restore the registers
         BR    R14                  Return to caller
         DROP  R2
***********************************************************************
***      Send_Message      Subroutine                               ***
***********************************************************************
Send_Message DS 0H
         STM   R14,R12,Save2        Save the callers registers
         USING OWNER,R1             Address the owner block
         L     R3,MSGCOUNT          Load current message count
         C     R3,=A(MAXMSGS)       How do we compare thee
         BNL   Do_Not_Send          If we are higher...bug out
         LA    R3,1(R3)             Increase count ...
         ST    R3,MSGCOUNT          ... and save it again
         MVI   MSG_Buffer,C' '
         MVC   MSG_Buffer+1(l'MSG_Buffer-1),MSG_Buffer
         MVC   MSG_Buffer(l'MSG_Start),MSG_Start   Move in first part
         LH    R4,LENDSN            Load length of dataset name
         BCTR  R4,0                 Down by one for execute
         EX    R4,Move_message
         LA    R3,1+MSG_Buffer+L'MSG_Start(R4) Point to end bit
         MVC   0(l'MSG_End,R3),MSG_End Move in the end part
         LA    R3,MSG_Buffer        Address of MSG_buffer for TPUT
         LA    R4,L'MSG_Buffer      Length of buffer into R4 for TPUT
         LA    R5,Jobname
         MVC   SMF_WHO,jobname      Save it in the SMF record     KF002
         TPUT  (R3),(R4),USERIDL=(R5) Tell them about it
         L     R5,SEND_Count        *
         LA    R5,1(r5)             *
         ST    R5,SEND_Count        *
Do_Not_Send DS 0H
*                                                                 KF002
*        Always try to cut an SMF record                          KF002
*                                                                 KF002
         TM    SMF_Switch,SMF_ON                                  KF002
         BNO   NO_SMF_Needed                                      KF002
         TIME  BIN                  Get the date and time         KF002
         ST    R0,SMFTIME           Save time in the SMF record   KF002
         ST    R1,SMFDATE           Save date in the SMF record   KF002
         SMFWTM SMFSKEL                                           KF002
NO_SMF_Needed DS 0H                                               KF002
         LM    R14,R12,Save2        Reload the callers registers
         BR    R14                  Return to sender
***********************************************************************
***                  Executed Instruction                           ***
***********************************************************************
Move_Message MVC MSG_Buffer+l'MSG_Start(*-*),DSNAME Move in message
***********************************************************************
***      Print_Info        Subroutine                               ***
***********************************************************************
Print_Info  DS 0H
         BAS   R14,FORMAT_MSG           Format message prefix
         MVC   0(ASM_Valsl,R15),ASM_Vals  Get message
         WTO   ,MF=(E,WTO_AREA)     Issue start message
         BAS   R14,FORMAT_MSG           Format message prefix
         MVC   0(6,R15),ASM_Vals    Get the message
         LA    R15,6(R15)           Bump past the message id
         MVC   0(8,R15),=C'Maxmsgs=' Insert text
         LA    R15,8(R15)           Bump past text
         LA    R1,MAXMSGS           Get value
         BAS   R14,Convert_it       Edit it out
         MVC   0(11,R15),=C', Maxowner=' Insert text
         LA    R15,11(R15)          Bump past text
         LA    R1,MAXOWNER          Get value
         BAS   R14,Convert_it       Edit it out
         MVC   0(11,R15),=C', Areasize=' Insert text
         LA    R15,11(R15)          Bump past text
*        L     R1,=A(10000)                                       KF003
         L     R1,Size_of_area                                    KF003
         BAS   R14,Convert_it       Edit it out
         WTO   ,MF=(E,WTO_AREA)     Issue start message
Print_SMF_value DS 0H                                             KF002
         BAS   R14,FORMAT_MSG       Format message prefix         KF002
         MVC   0(6,R15),ASM_Vals    Get the message               KF002
         LA    R15,6(R15)           Bump past the message id      KF002
         MVC   0(16,R15),=C'SMF Recording is' Add new text        KF002
         LA    R15,17(R15)          Bump past text                KF002
         MVC   0(2,R15),=c'ON'      Set default                   KF002
         TM    SMF_Switch,SMF_ON                                  KF002
         BO    SMF_Listed                                         KF002
         MVC   0(3,R15),=c'OFF'     Set default                   KF002
         LA    R15,1(R15)           Bump past text                KF002
SMF_Listed DS 0H                                                  KF002
         LA    R15,2(R15)           Bump past text                KF002
         MVC   0(16,R15),=C', Record Number=' Insert text         KF002
         LA    R15,16(R15)          Bump past text                KF002
         LA    R1,SMFREC            Get value                     KF002
         BAS   R14,Convert_it       Edit it out                   KF002
         MVC   0(19,R15),=c' (Set via Default).'                  KF002
         LA    R15,6(R15)           Bump past text                KF002
         CLI   SMF_set_by,c'D'                                    KF002
         BE    Done_SMF                                           KF002
         MVC   0(13,R15),=c'SMF command).'                        KF002
Done_SMF DS    0H                                                 KF002
         WTO   ,MF=(E,WTO_AREA)     Issue start message           KF002
         BAS   R14,FORMAT_MSG       Format message prefix
         MVC   0(6,R15),ASM_Vals    Get the message
         LA    R15,6(R15)           Bump past the message id
         MVC   0(24,R15),=C'Program version number =' Insert text
         MVC   25(7,R15),Ver_No     Insert version number
         WTO   ,MF=(E,WTO_AREA)     Issue start message
Print_wait_value DS 0H
         BAS   R14,FORMAT_MSG       Format message prefix
         MVC   0(6,R15),ASM_Vals    Get the message
         LA    R15,6(R15)           Bump past the message id
         MVC   0(10,R15),=C'Wait time=' Insert text
         LA    R15,10(R15)          Bump past text
         L     R1,delay
         XR    R0,R0
         D     R0,=F'100'          CHANGE TO SECONDS AND HUNDREDTHS
         BAS   R14,Convert_it       Edit it out
         MVC   0(24,R15),=c' Seconds (Set via Parm).'
         LA    R15,18(R15)          Bump past text
         CLI   Wait_set_by,c'P'
         BE    Done_it
         MVC   0(9,R15),=c'Default).'
         CLI   Wait_set_by,c'D'
         BE    Done_it
         MVC   0(14,R15),=c'Wait command).'
Done_it  DS    0H
         WTO   ,MF=(E,WTO_AREA)     Issue start message
         BSM   0,R7
*        BSM   0,R7                                               KF002
***********************************************************************
***      Print_Stats       Subroutine                               ***
***********************************************************************
PRINT_STATS DS 0H
         BAS   R14,FORMAT_MSG       Format message prefix
         MVC   0(L'Stat_msg,R15),Stat_msg  Get message
         LA    R15,L'Stat_msg(R15)  Bump past it
         MVC   1(7,R15),=C'Notify=' Move in text
         LA    R15,1+7(R15)         Bump past it
         L     R1,Send_count        Get number
         BAS   R14,Convert_It       Edit it
         MVC   0(9,R15),=C', Cycles='   Move in text
         LA    R15,9(R15)           Bump past it
         L     R1,Cycle_Count       Get number
         BAS   R14,Convert_It       Edit it
         MVC   0(8,R15),=C', Loops='   Move in text
         LA    R15,8(R15)           Bump past it
         L     R1,Loop_Count        Get number
         BAS   R14,Convert_It       Edit it
         WTO   ,MF=(E,WTO_AREA)     Issue message
         BSM   0,R7
***********************************************************************
***      Convert_It        Subroutine                               ***
***********************************************************************
Convert_It DS  0H
         LTR   R1,R1                    CHECK FOR 0
         BZ    EDITFWF0                 YES, PUT ZERO
         ST    R14,SAVER14              Save return address
         CVD   R1,DOUBLE                NO, CONVERT TO PACKEC
         LA    R1,DOUBLE2+14            LOCATE SIG DIGIT
         MVC   DOUBLE2(15),EDITP15
EF$EDMK  EQU   *
         EDMK  DOUBLE2(15),DOUBLE+2     EDIT AND SAVE PLACE
         LA    R14,DOUBLE2+16           LOCATE LAST POSSIBLE BYTE + 1
         SR    R14,R1                   LENGTH = END - START
         BCTR  R14,0                    DECREMENT FOR EX
         EX    R14,EDITFWFM             MOVE EDIT NUMBER TO OUTPUT
         LA    R15,0(R14,R15)           BUMP POINTER PAST NUMBER
*        LA    R15,1(r15)
         MVI   0(R15),C' '              Fix unprintable character
         L     R14,SAVEr14              Get return address
         BSM   0,R14                    RETURN TO CALLER
EDITFWFM MVC   0(0,R15),0(R1)
EDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'
EDITFWF0 DS    0H
         MVI   0(R15),C'0'              PUT IN ZERO
         LA    R15,1(R15)               BUMP POINTER PAST ZERO
         BSM   0,R14                    RETURN TO CALLER
***********************************************************************
*** This is the timer exit. Basically all we do is set the ECB in   ***
*** the ECBLIST, and then get the heck back to the mainline         ***
***********************************************************************
TIMEEXIT DS    0H
         LR    R11,R15              Establish addressability to the
         USING TIMEEXIT,R11         TIMEEXIT subroutine
         LR    R8,R14               Save our return address in R8
         POST  ECB,4                Post the TIMER ECB
         BR    R8                   Return to mainline routine
***********************************************************************
         DROP  R11
WTO_SKEL WTO   '                                                       X
                                         ',MF=L
SKEL_LEN EQU   *-WTO_SKEL
DELAY    DC    F'1000'              Number of secs 2 wait (in 100ths)
QNAME    DC    CL8'SYSDSN  '        Major name for dataset ENQs
*
**       Message to send to TSO users
*
MSG_START DC     C'===>> Please free '''
MSG_END   DC     C'''. Other jobs are waiting to use it. (ENQWATCH)'
*
**       Messages Issued by program
*
Start_MSG DC    C'01I Starting - ENQWATCH last assembled on &SYSDATE at*
                &SYSTIME'
Active_MSG DC   C'02I - Enqueue monitor active'
FreeFailed_MSG DC C'03I - Free of start CIB Unsuccessful'
Stop_Msg  DC    C'04I - Enqueue monitor shutdown in progress'
QSCAN_Fail DC   C'05E - GQSCAN Failed. Retrying'
Invalid_CMD DC  C'06E - Invalid command'
ASM_Vals  DC    C'07I - ENQWATCH was assembled using these values:'
ASM_ValsL EQU   *-ASM_Vals
Stat_MSG  DC    C'08I - Status:'
Invalid_Wat DC  C'09E - Invalid WAIT command. No action taken.'
Parm_errg   DC  C'10E - Invalid PARM passed. Default wait taken'
SMF_Action  DC  C'11I - SMF recording as been switched '          KF002
SMF_ActionL EQU *-SMF_Action                                      KF002
Invalid_SM  DC  C'12E - Invalid SMF command. No action taken.'    KF002
*
EXTRACTS EXTRACT CIBAREA,FIELDS=COMM,MF=L
EXT_LEN  EQU   *-EXTRACTS
WORKAREA DS    0H
WORKAREA_LENGTH EQU WORKAREA_END-WORKAREA
SAVEAREA DS    18F                  Standard savearea
SAVE1    DS    15F
SAVE2    DS    15F
DATAAREA DS    4F                   CIB Data araea
CIBAREA  DS    F                    Out CIB area address
CURCOUNT DS    F                    Current ENQ count
Loop_Count DS  F                    Count of number of loops
Send_Count DS  F                    Count of TPUTS
COMMADDR DS    F
SAVER14  DS    F                    Preserve R14
DOUBLE   DS    D                    Double word work area
DOUBLE2  DS    2D                   Double word work area * 2
RIB_Size DS    F                    Size of RIB and RIBEs
         ORG   RIB_Size
RIB_Length     DS H                 Size of RIB
RIBE_Length    DS H                 Size of RIBE
RIBSLEFT       DS F                 Count of RIBS left
Dynamic_Area   DS F                 Address of dynamic area
Size_of_area   DS F                 Address of dynamic area       KF002
Working_length DS F                 Length of enqueue work area
Working_Area   DS F                 Address of enqueue work area
Previous_Count DS F                 Count of previous ENQs
Current_Count  DS F                 Count of current ENQs
Cycle_count    DS F                 Count of how many CYCLE commands
SMF_Count      DS F                 Count of SMF records cut      KF002
ECB      DC    F'00'
ECBADDR  DC    A(0)
lastone  DC    A(ECB)
EXTRACTL EXTRACT CIBAREA,FIELDS=COMM,MF=L
SCANLIST GQSCAN MF=L
MSG_Buffer DS  CL120
BSLSAV2  EQU   MSG_Buffer,9
WTO_AREA DS    XL(SKEL_LEN)       WTO Area
Wait_set_by DS CL1
PARMBUF  DS     CL4                    Right-justified parameter
SMF_Switch DS   CL1                    SMF Recording switch       KF002
SMF_set_by DS   CL1                    How SMF was set            KF002
SMFSKEL  DS    0H                      SMF Record to be written   KF002
SMFLEN   DS    H                       Record length              KF002
SMFSEG   DC    H'0'                    Segment indicator          KF002
SMFSIND  DC    X'06'                   System indicator           KF002
SMFRECTY DC    AL1(233)                Record type                KF002
SMFTIME  DS    XL4                     Time                       KF002
SMFDATE  DS    XL4                     Date                       KF002
SMFSID   DS    CL4                     System Id.                 KF002
SMF_WHO  DS    CL8                     Who got the message        KF002
SMF_JOB  DS    CL8                     Who got the message        KF002
SMF_DSNLEN DS  H                       Dataset name length        KF002
SMF_DSName DS  CL44                    Dataset name               KF002
SMFSLEN  EQU   *-SMFSKEL                                          KF002
WORKAREA_END EQU *
         LTORG
*
*  Table of dataset owners from the current scan.
*
CURRENT  DSECT
         DS     0F
         ORG    CURRENT+MAXOWNER*LENOWNER
LENCUR   EQU    *-CURRENT              Size of CURRENT area
*
*  Table of dataset owners from the previous scan.
*
PREVIOUS DSECT
         DS     0F
         ORG    PREVIOUS+MAXOWNER*LENOWNER
***********************************************************************
*   Dataset owner entry mapping                                       *
***********************************************************************
OWNER    DSECT
*
* Key that uniquely identifies an OWNER entry
*
KEY      DS     0C
Jobname  DS     CL8                    User owning dataset resource
JOBASID  DS     H                      Address space of user
LENDSN   DS     H                      True length of dataset name
DSNAME   DS     CL44                   Buffer for dataset name
LENKEY   EQU    *-KEY                  Total size of the entry key
DATA     DS     0C
MSGCOUNT DS     F                      Number of messages that have
*                                      been sent to this user for
*                                      this dataset name.
LENDATA  EQU    *-DATA                 Total size of the entry data
*
* Data for use by the mainline code
*
STATUS   DS     BL1
ONGOING  EQU    X'80'                  Entry has a Current match
         DS     0F                     Align to fullword boundary
LENOWNER EQU    *-OWNER                Total size of the entry
         CVT    DSECT=YES
         ISGRIB
         IHAASCB
         IRAOUCB
         DSECT
         IEZCOM
         DSECT
         IEZCIB
         END   ENQWATCH
