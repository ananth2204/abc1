{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012929000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE844.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE844.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0e\\x07'", "DS1TRBAL": "b'b\\x8c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xd1\\x00\\n\\x05\\xd2\\x00\\t\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04R\\x009\\x01\\x11\\x06\\x1f\\x01\\x11\\x06\\x1f\\x00\\x13\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@'", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-03-02T00:00:00", "modifydate": "2011-03-02T00:13:39", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-482"}, "text": "REGULAR CBT TAPE - VERSION 482    FILE:  844\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT482.FILE844\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 7,713 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/02/11    00:13:39    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DISCL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x15\\x00\\x00\"\\x01\\x11\\x04\\x1f\\x01\\x11\\x04\\x1f\\x11&\\x00\\x19\\x00\\x19\\x00\\x00\\xc1\\xd5\\xc9\\xc3\\xd6@@@@@'", "ispf": {"version": "21.00", "flags": 0, "createdate": "2011-02-10T00:00:00", "modifydate": "2011-02-10T11:26:22", "lines": 25, "newlines": 25, "modlines": 0, "user": "ANICO"}, "text": "                           Disclaimer\n                           ==========\n\nThis computer program and associated materials has been developed by:\n\n                      Kevin E. Ferguson,\n                      Lead System Programmer\n                      American National Insurance Company.\n\nThis material has been used successfully by American National Insurance\nCompany and to the best of our knowledge this material and any system(s)\nwhich it is a part of are operational as of the service level or date\nstated in the body of this material (if so stated). However, no warranty\nis given or implied as to the accuracy of this material or any related\nmaterial or systems, and no responsibility is assumed for any effect or\nmodification directly or indirectly caused by the use of this material.\n\nIt is the responsibility of any user of this material to evaluate its\nusefulness to the user's environment.\n\nAmerican National Insurance Company does not guarantee to keep this or\nany related material current, nor does it guarantee to provide any\ncorrections or extensions described by any users of this material or\nany corrections or extensions made in the future by American National\nInsurance Company itself.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x15\\x00\\x00\"\\x01\\x11\\x04\\x1f\\x01\\x11\\x04\\x1f\\x11&\\x00\\x19\\x00\\x19\\x00\\x00\\xc1\\xd5\\xc9\\xc3\\xd6@@@@@'", "ispf": {"version": "21.00", "flags": 0, "createdate": "2011-02-10T00:00:00", "modifydate": "2011-02-10T11:26:22", "lines": 25, "newlines": 25, "modlines": 0, "user": "ANICO"}, "text": "*---------------------------------------------------------------------*\n*                         $$$INDEX                                    *\n*---------------------------------------------------------------------*\n*  Description : This is the INDEX of members within this dataset     *\n*                                                                     *\n*  Created : 02/10/11 by CD9P07                                       *\n*            : Using CD9P07.ENQWATCH,PDS($$$INDEX)                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n*  Member  \u00a6 Decription                                               *\n*---------------------------------------------------------------------*\n* $$$INDEX \u00a6 This member                                              *\n*---------------------------------------------------------------------*\n* $$$DISCL \u00a6 The usual legal disclaimer stuff.                        *\n*---------------------------------------------------------------------*\n* ASSEMBLE \u00a6 JCL required to assemble and link the program. This will *\n*          \u00a6 a valid site jobcard adding to it and the name of an APF *\n*          \u00a6 authorized library specifying.                           *\n*---------------------------------------------------------------------*\n* ENQWATCH \u00a6 This is the actual source code for ENQWATCH.             *\n*---------------------------------------------------------------------*\n* PDS      \u00a6 This is the user manual in PDF format. It will need to   *\n*          \u00a6 transfered down to a PC in binary format then renamed to *\n*          \u00a6 something with the file extension of .pdf.               *\n*---------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$TEXTDOC": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x16\\n\\x00\\x00\\x01\\x11\\x06\\x1f\\x01\\x11\\x06\\x1f\\x00\\x07\\x02\\xff\\x02\\xff\\x00\\x00\\xc1\\xd5\\xc9\\xc3\\xd6@@@@@'", "ispf": {"version": "22.10", "flags": 0, "createdate": "2011-03-02T00:00:00", "modifydate": "2011-03-02T00:07:00", "lines": 767, "newlines": 767, "modlines": 0, "user": "ANICO"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "@FILE844": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04R\\x003\\x01\\x11\\x06\\x1f\\x01\\x11\\x06\\x1f\\x00\\x13\\x001\\x001\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@'", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-03-02T00:00:00", "modifydate": "2011-03-02T00:13:33", "lines": 49, "newlines": 49, "modlines": 0, "user": "CBT-482"}, "text": "//***FILE 844 is from Kevin Ferguson, and contains his program      *   FILE 844\n//*           called ENQWATCH.  This is a continuously running      *   FILE 844\n//*           task that watches for dataset enqueue conflicts       *   FILE 844\n//*           and informs the TSO user if he/she is the culprit.    *   FILE 844\n//*           There is more there, too.  See the doc.               *   FILE 844\n//*                                                                 *   FILE 844\n//*           email:  Kevin.Ferguson@ANICO.com                      *   FILE 844\n//*                                                                 *   FILE 844\n//*     Documentation for this program is provided in PDF format,   *   FILE 844\n//*     but an attempt was made to convert it as well as possible,  *   FILE 844\n//*     to plain text format, so it could be more usable directly   *   FILE 844\n//*     from the mainframe machine.                                 *   FILE 844\n//*                                                                 *   FILE 844\n//*     Program Overview                                            *   FILE 844\n//*                                                                 *   FILE 844\n//*     The program, ENQWATCH, is based around the IBM supplied     *   FILE 844\n//*     program ISGECMON with the features of the David Alcock's    *   FILE 844\n//*     ISGECMOM added and massively re-written and some 'bells     *   FILE 844\n//*     and whistles' added.                                        *   FILE 844\n//*                                                                 *   FILE 844\n//*     ENQWATCH will only work for dataset conflicts between       *   FILE 844\n//*     batch jobs and TSO users. Conflicts between two or more     *   FILE 844\n//*     batch jobs are not handled by this program.                 *   FILE 844\n//*                                                                 *   FILE 844\n//*     It is designed to be used as a long running program, in     *   FILE 844\n//*     fact it won't end at all until you issue a stop for, or     *   FILE 844\n//*     cancel, it.  The purpose of the program is the monitor      *   FILE 844\n//*     the system for any dataset contention and if the holder     *   FILE 844\n//*     of the resource is a TSO user, it will send them a          *   FILE 844\n//*     message requesting that they free the resource.             *   FILE 844\n//*                                                                 *   FILE 844\n//*     The added features of ENQWATCH include:                     *   FILE 844\n//*                                                                 *   FILE 844\n//*      *   The ability to force an iteration of the loop          *   FILE 844\n//*          thereby allowing automation to be written to           *   FILE 844\n//*          immediately send a message to a TSO user if they       *   FILE 844\n//*          are holding up an important batch run.                 *   FILE 844\n//*                                                                 *   FILE 844\n//*      *   More statistics are available including how many       *   FILE 844\n//*          times the iteration was forced by the above            *   FILE 844\n//*          feature.                                               *   FILE 844\n//*                                                                 *   FILE 844\n//*      *   The program has been modified to allow commands        *   FILE 844\n//*          to take effect immediately rather than wait            *   FILE 844\n//*          until the loop time limit is met.                      *   FILE 844\n//*                                                                 *   FILE 844\n//*      *   Dynamic adjustment of the wait time limit is now       *   FILE 844\n//*          supported.                                             *   FILE 844\n//*                                                                 *   FILE 844\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASSEMBLE": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x15\\x00\\x00\"\\x01\\x11\\x04\\x1f\\x01\\x11\\x04\\x1f\\x11&\\x00\\x14\\x00\\x14\\x00\\x00\\xc1\\xd5\\xc9\\xc3\\xd6@@@@@'", "ispf": {"version": "21.00", "flags": 0, "createdate": "2011-02-10T00:00:00", "modifydate": "2011-02-10T11:26:22", "lines": 20, "newlines": 20, "modlines": 0, "user": "ANICO"}, "text": "//*jobcard  JOB\n//ASMIT    PROC MEM=,LOADLIB='JOBFAILED',SOURCE='JOBFAILED'\n//STEP1    EXEC PGM=ASMA90,PARM='OBJECT,NODECK',REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD  SPACE=(CYL,(2,1)),UNIT=SYSDA,DSN=&&WRK1\n//SYSLIN   DD  DSN=&&WRK5,UNIT=SYSDA,SPACE=(CYL,(2,1)),\n//             DCB=(RECFM=FB,BLKSIZE=3200,LRECL=80),DISP=(,PASS)\n//SYSIN    DD  DSN=&SOURCE(&MEM),DISP=SHR\n//LKED1 EXEC PGM=IEWL,PARM='LIST,LET,NCAL,AC=1,MAP',COND=(4,LT)\n//SYSLMOD  DD DSN=&LOADLIB(&MEM),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=&&WRK5,DISP=(OLD,DELETE)\n//         PEND\n//ASMIT    EXEC ASMIT,\n//         LOADLIB='your.authlib',SOURCE='CD9P07.ENQWATCH.PDS',\n//         MEM=ENQWATCH\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ENQWATCH": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x15\\x01\\x00H\\x01\\x11\\x04\\x1f\\x01\\x11\\x06\\x0f\\x10\\x07\\x03H\\x02\\xc0\\x00\\x00\\xc3\\xc4\\xf9\\xd7\\xf0\\xf7@@@@'", "ispf": {"version": "21.01", "flags": 0, "createdate": "2011-02-10T00:00:00", "modifydate": "2011-03-01T10:07:48", "lines": 840, "newlines": 704, "modlines": 0, "user": "CD9P07"}, "text": "         TITLE  'ENQWATCH - Monitor ENQs'\nENQWATCH CSECT\nENQWATCH AMODE 31\nENQWATCH RMODE 24\n         USING ENQWATCH,R15         Temporary base\n***********************************************************************\n*   Constants for installation tweaking                               *\n***********************************************************************\nMAXMSGS  EQU    5                   Maximum number of messages to\n*                                   send to a TSO user who owns a\n*                                   dataset\nMAXOWNER EQU    50                  Maximum number of dataset\n*                                   owners that can be tracked\n*REASIZE EQU    10000               Size of area for RIBs and RIBEKF003\nAREASIZE EQU    10                  Size of area for RIBs and RIBEKF003\n*                                   returned by GQSCAN\nWAITTIME EQU    60                  Number of seconds to wait     KF001\nSMFREC   EQU    223                 Value of the SMF record numberKF002\nSMFON    EQU    1                   SMF default switch 1=on;0=off KF002\n***********************************************************************\n*                         E N Q W A T C H                             *\n***********************************************************************\n* Change Summary:                                                     *\n* Change    By    Date       Description                              *\n*  KF001  Kevin   08/02/2011 Added WAITTIME support code.             *\n*  KF002  Kevin   24/02/2011 Added SMF Recording                      *\n*  KF003  Kevin   28/02/2011 Reworked areasize issue                  *\n***********************************************************************\n*        COPY  BSLEQUC              Copy register equates\n***********************************************************************\n*                         REGISTER EQUATES                            *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nR0       EQU   0                                                      *\nR1       EQU   1                                                      *\nR2       EQU   2                                                      *\nR3       EQU   3                                                      *\nR4       EQU   4                                                      *\nR5       EQU   5                                                      *\nR6       EQU   6                                                      *\nR7       EQU   7                                                      *\nR8       EQU   8                       R E G E Q S                    *\nR9       EQU   9                                                      *\nR10      EQU   10      EQUATE PREFIX TO NUMERIC SYMBOLS IN ORDER      *\nR11      EQU   11       TO MAKE THE USE OF REGISTER OPERANDS IN       *\nR12      EQU   12       INSTRUCTIONS SELF EXPLANITORY.THIS ALSO       *\nR13      EQU   13         CREATES ENTRIES IN CROSS REFERENCE.         *\nR14      EQU   14                                                     *\nR15      EQU   15                                                     *\nFPR0     EQU   0                                                      *\nFPR2     EQU   2                                                      *\nFPR4     EQU   4                                                      *\nFPR6     EQU   6                                                      *\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                     MISCELLANEOUS EQUATES                           *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nEQUHOBON EQU   X'80000000'   SET HIGH ORDER BIT ON                    *\nPACKDIG  EQU   X'0F'         PACK DIGIT                               *\nSMF_ON   EQU   B'10000000'                                        KF002\nSMF_OFF  EQU   B'01111111'                                        KF002\n*                                                              K.E.F. *\n         BAKR  14,0\n         LR    R12,R15              Load R12 for base\n*        LAE   R11,2048(R15,0)      Set R11 as 2nd Base Register\n*        LAE   R11,2048(R11,0)      Set R11 as @nd base register\n*        USING R15+4096,R11\n         DROP  R15\n         USING ENQWATCH,R12         <=== Program base register\n         B     START                Skip data\n         DC    C'ENQWATCH'          Program-name\n         DC    C'&SYSDATE'          Date\n         DC    C'&SYSTIME'          Time\nver_no   DC    C'V2R2.01'           Version number\nSTART    DS    0H                   Re-align on halfword-boundary\n         L     R2,0(R1)             Preserve parms\n         LA    R3,WORKAREA_LENGTH   Set length for workarea\n         MODESET KEY=ZERO,MODE=SUP  Supervisor state for timer exit\n         STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=(R3),LOC=BELOW\n         LTR   R15,R15              Did we work?\n         BNZ   CRUNCH               If not - Go to abend\n         ST    13,4(,1)             Chain back to previous save area\n         ST    1,8(,13)             Chain forward to new save area\n         LR    13,1                 R13 reset to current save area\n         LR    R11,R12              Second base register ...\n*                                   ... (currently not used)\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'Start_msg,R15),Start_msg   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\n         LTR   R2,R2                Test for parameters\n         BE    Set_Default          None, take the default\n         LH    R3,0(R2)             Get length of parameters\n         LTR   R3,R3                Test for parameters\n         BZ    Set_Default\n         LA    R2,2(R2)             Skip length\n         MVI   Wait_set_by,c'P'\n         BAS   R14,Process_Wait     Go and process the wait time\n         LTR   R15,R15              Wait time valid?\n         BZ    Start_Info\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'Parm_errg,R15),Parm_errg   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\nSet_Default DS 0H\n         MVI   Wait_set_by,c'D'     Set default indicator\n         LA    R4,WAITTIME          Waittime in R4 for conversion KF001\n         MH    R4,=H'100'           Convert to hundreths ...      KF001\n         ST    R4,DELAY             ... and save it.              KF001\n*        MVC   Delay,=f'6000'       No parameter was specified    KF001\nStart_Info DS  0H\n         XC    SMF_Switch,SMF_Switch Set default to off           KF002\n         MVI   SMF_set_by,c'D'      Set default indicator         KF002\n* Set SMF record number in here\n         LA    R7,SMFON             Get Value of SMFON            KF002\n         C     R7,=F'1'             On?                           KF002\n         BNE   SKIP_SMF_SET         No - Skip setting then        KF002\n         OI    SMF_Switch,SMF_ON    Set the flag                  KF002\nSKIP_SMF_SET DS 0H                                                KF002\n         XR    R0,R0                Clear ever register           KF003\n         LA    R1,AREASIZE          Get size                      KF003\n         M     R0,=f'1000'          Multiply by 1000              KF003\n*        LA    R7,AREASIZE                                        KF003\n         ST    R1,Size_of_Area                                    KF003\n         L     R1,16                CVT Address                   KF002\n         L     R6,196(R1)           Load address of the SMCA      KF002\n         MVC   SMFSID,16(R6)        Move in System Id from SMCA   KF002\n         MVI   SMFSIND,X'06'        Set Id                        KF002\n         LA    R1,SMFREC            Get record number             KF002\n         ST    R1,SMF_Count         Save it in temparea           KF002\n         MVC   SMFRECTY(1),SMF_Count+3 Move it to Skeleton        KF002\n         LA    R1,SMFSLEN           Get length of SMF record ...  KF002\n         STH   R1,SMFLEN            ... and save it in the record KF002\n         BAS   R7,Print_info        Print the info\n         MVC   EXTRACTL(EXT_LEN),EXTRACTS\n         XR    R1,R1                Clear R1\n         ST    R1,ECB               Save it as the ECB\n         LA    R2,CIBAREA           Load R2 with where to load CIB\n         EXTRACT CIBAREA,FIELDS=COMM,MF=(E,EXTRACTL)\n         L     R2,CIBAREA           Load R2 with the returned addr\n         USING COMLIST,R2           and establish addressability\n         L     R5,COMCIBPT          Get the CIB address into R5...\n         USING CIBNEXT,R5           ... and address it\n         MVC   DATAAREA(16),CIBDATA Populate the Dataarea\n         CLI   CIBVERB,CIBSTART     Is First CIB a start command ?\n         BNE   SETLIMIT             No - Skip to set command limit\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R5)  Free the start CIB\n         LTR   R15,R15              Did it work ?\n         BZ    SETLIMIT             Yes - Go set some limits\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'FreeFailed_msg,R15),FreeFailed_msg   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\nSETLIMIT DS    0H\n         XC    Send_count,Send_count Clear counter\n         XC    Loop_count,Loop_count Clear counter\n         XC    SMF_count,SMF_count   Clear counter                KF002\n         QEDIT ORIGIN=COMCIBPT,CIBCTR=2  Set Command limit to 2\n         L     R4,COMECBPT          Pointer to the com ECB\n         ST    R4,ECBADDR           Save the COM ECB in the ECBLIST\n         XC    Current_count,Current_count  list starts empty\n         LA    R0,Size_of_Area      Get amount of storage needed  KF003\n*        STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=10000,LOC=BELOW      KF003\n         STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=(R0),LOC=BELOW       KF003\n         ST    R1,Dynamic_Area      Save it\n         LA    R2,LENCUR            Size of workarea\n         SLL   R2,1                 Double it (for previous too)\n         ST    R2,Working_length    ... and save it safely away\n         STORAGE OBTAIN,ADDR=(1),SP=8,LENGTH=(R2),LOC=BELOW\n         ST    R1,Working_Area      ... and save it safely away too.\n         BAS   R10,ENQ_Check        Go check current ENQs\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'Active_msg,R15),Active_msg   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\nWAIT     DS    0H\n         LA    R4,ECB               Address of REPLY_ECB in R4\n         ST    R4,Lastone           Save it in list\n         OI    Lastone+0,x'80'      Flag end of list\nWAITLOOP STIMER REAL,TIMEEXIT,BINTVL=DELAY\nWAITCIB  WAIT  1,ECBLIST=ECBADDR\n         CLC   ECB(4),=F'0'         Timer pop?\n         BE    COMPLETE             No - must be a stop\n         BAS   R10,ENQ_Check        Go check current ENQs\n         XC    ECB,ECB              Clear timer ECB ...\n         B     WAIT                 ... and around we go\nCOMPLETE DS    0H\n         L     R2,CIBAREA           Reload R2\n         L     R5,COMCIBPT          Obtain CIB address\n         CLI   CIBVERB,CIBMODFY     Was it a modify?\n         BNE   EXIT                 No - Then is must be invalid\n         CLC   CIBDATA(4),=C'STOP'  Is it a Shutdown command?\n         BE    Exit                 Yes - Go to shutdown\n         CLC   CIBDATA(4),=C'SHUT'  Is it a \"SHUT\" command?\n         BE    Exit                 Yes - Go to shutdown\n         CLC   CIBDATA(3),=C'END'   Is it a \"END\" command?\n         BE    Exit                 Yes - Go to shutdown\n         CLC   CIBDATA(5),=C'STATS' Is it a \"Stats\" command\n         BE    Show_Stats              Yes - Go to re-issue\n         CLC   CIBDATA(6),=C'STATUS' Is it a \"Status\" command\n         BE    Show_Stats              Yes - Go to re-issue\n         CLC   CIBDATA(4),=C'INFO'  Is it an INFO command\n         BE    Show_Info               Yes - Go to re-issue\n         CLC   CIBDATA(3),=C'SMF'   Is it an SMF command          KF002\n         BE    Process_SMF             Yes - Go to process it     KF002\n         CLC   CIBDATA(4),=C'WAIT'  Is it a WAIT command\n         BE    Proces_Wait_command     Yes - Go and process it\n         CLC   CIBDATA(5),=C'CYCLE' Is it a \"CYCLE\" command?\n         BNE   Command_Invalid      No - skip to command_invalid\n         L     R6,Cycle_Count       *\n         LA    R6,1(R6)             * add 1 to counter\n         ST    R6,Cycle_Count       *\n         BAS   R10,ENQ_Check        Go and check now\nEnd_of_Command_Process DS  0H\n         L     R2,CIBAREA           Reload R2\n         L     R5,COMCIBPT          Get CIB pointer\n         QEDIT ORIGIN=COMCIBPT,BLOCK=(R5)   Clear the CIB ...\n         B     Wait                 ... and loop back to main wait\nProcess_SMF DS  0H                                                KF002\n*        CLC   CIBDATLN,=h'3'       Check for Valid wait\n*        BL    Command_Invalid      Invalid length - Then skip\n         LA    R2,CIBDATA+3         Point to end of \"SMF\"         KF002\n         CLI   0(r2),c' '           Space after wait?             KF002\n         BE    Space_Found_SMF      Yes - Skip next check         KF002\n         CLI   0(r2),c'='           '=' after wait?               KF002\n         BNE   Invalid_SMF          No - card invalid             KF002\nSpace_Found_SMF DS 0H                                             KF002\n         LA    R2,1(R2)             Skip '=' or ' '               KF002\n         CLC   0(2,R2),=C'ON'       Is it SMF ON?                 KF002\n         BNE   Try_Off                                            KF002\n         OI    SMF_Switch,SMF_ON    Set the flag                  KF002\n         LA    R3,1                                               KF002\n         B     Set_SMF_Flag                                       KF002\nTry_Off  DS    0H                                                 KF002\n         CLC   0(3,R2),=C'OFF'      Is it SMF OFF?                KF002\n         BNE   Invalid_SMF                                        KF002\n         LA    R3,2                                               KF002\n         XC    SMF_Switch,SMF_Switch Clear Switch                 KF002\nSet_SMF_Flag DS 0H                                                KF002\n         MVI   SMF_set_by,c'C'      Set command indicator         KF002\n         BAS   R14,FORMAT_MSG       Format message and add prefix KF002\n         MVC   0(l'SMF_Action,R15),SMF_Action   Get message       KF002\n         LA    R15,l'SMF_Action(R15)                              KF002\n         EX    R3,Move_CIB                                        KF002\n         WTO   ,MF=(E,WTO_AREA)     Issue start message           KF002\n         B     End_of_Command_Process                             KF002\nInvalid_SMF    DS  0H                                             KF002\n         BAS   R14,FORMAT_MSG       Format message and add prefix KF002\n         MVC   0(l'SMF_Action,R15),SMF_Action   Get message       KF002\n         LA    R15,l'SMF_Action(R15)                              KF002\n         EX    R3,Move_CIB                                        KF002\n         WTO   ,MF=(E,WTO_AREA)     Issue start message           KF002\n         B     End_of_Command_Process  Go reset CIB               KF002\nMove_CIB MVC   0(*-*,R15),0(R2)\nProces_Wait_command DS  0H\n         CLC   CIBDATLN,=h'5'       Check for Valid wait\n         BL    Invalid_Wait         Invalid length - Then skip\n         LA    R2,CIBDATA+4         Point to end of \"WAIT\"\n         CLI   0(r2),c' '           Space after wait?\n         BE    Space_Found          Yes - Skip next check\n         CLI   0(r2),c'='           '=' after wait?\n         BNE   Invalid_wait         No - card invalid\nSpace_Found DS 0H\n         LA    R2,1(R2)             Skip '=' or ' '\n         XR    R3,R3                CLear R3\n         LH    R3,CIBDATLN          Load Length\n         SH    R3,=h'5'             Subtract length of wait=\n         BAS   R14,Process_wait\n         LTR   R15,R15              Value good?\n         BNZ   Invalid_wait         No - Show error\n         MVI   Wait_set_by,c'C'     Set flag for command\n         BAS   R7,Print_wait_value  Print the value\n         B     End_of_Command_Process\nInvalid_Wait   DS  0H\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'Invalid_wat,R15),Invalid_wat   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\n         B     End_of_Command_Process  Go reset CIB\nCOMMAND_INVALID DS  0H\n         CLI   CIBVERB,CIBSTOP      Is it a STOP(P) Command?\n         BE    exit                 No - Forget it\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'Invalid_cmd,R15),Invalid_cmd   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\n         B     End_of_Command_Process  Go reset CIB\nShow_Stats DS  0H\n         BAS   R7,Print_Stats\n         B     End_of_Command_Process\nShow_Info  DS  0H\n         BAS   R7,Print_Info\n         B     End_of_Command_Process\n*        TM    0(r2),X'40'          Was it a reply pop?\n*        BNO   TRYMOD               No - Try modify\n*        NI    ECB,X'00'            Reset ECB\n*        B     Wait\nExit     DS    0H\n         BAS   R7,Print_Stats\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'Stop_msg,R15),Stop_msg   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\n         MVC   EXTRACTL(EXT_LEN),EXTRACTS\n         L     R2,Working_length    Set length for Release\n         L     R1,Working_Area\n         STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=(R2)\n         L     R1,Dynamic_Area\n         L     R0,Size_of_Area                                    KF003\n*        STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=10000               KF003\n         STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=(R0)                KF003\n         LA    R2,WORKAREA_LENGTH   Set length for Release\n         LR    1,13                 Address of save area into R1\n         L     13,4(1)              Chain, chain, chain\n         STORAGE RELEASE,ADDR=(1),SP=8,LENGTH=(R2)\n         XR    15,15                Set condition code &\n         PR    ,                    Get the heck out of Dodge\n***********************************************************************\n***      Process_Wait      Subroutine                               ***\n***********************************************************************\nProcess_Wait DS 0H\n         MVC   PARMBUF,=C'0000'     Clear buffer area\n         LR    R4,R2                Save R2\n         LA    R2,L'PARMBUF         Get length\n         SLR   R2,R3                Calculate difference\n         LA    R2,PARMBUF(R2)       Point to move area\n         EX    R3,COPYPARM          Right justify parameter\n         CLC   0(L'PARMBUF,R2),0(r4) nnnn numeric?\n         BE    Parm_Numeric         Yes - Skip\n         LA    R15,8\n         B     Wait_return\nParm_Numeric DS 0H\n         PACK  DOUBLE,PARMBUF       EBCDIC -> Decimal\n         CVB   R4,DOUBLE            Decimal -> Binary\n         MH    R4,=H'100'           Convert to .01 second units\n         ST    R4,DELAY             Save for STIMER\n         XR    R15,R15\nWait_return DS 0H\n         BSM   0,R14                Return to caller\nCOPYPARM MVN   0(*-*,R2),0(R4)      Used for right-justifying input\n***********************************************************************\n***      Format_MSG        Subroutine                               ***\n***********************************************************************\nFORMAT_MSG DS 0H\n         LA    R15,WTO_Area         Locate area\n         MVC   0(SKEL_LEN,R15),WTO_Skel  Initialize area\n         MVC   4(5,R15),=C'ENQW0'   Get ID\n         LA    R15,4+5(R15)         Bump past area\n         BSM   0,R14\n***********************************************************************\nCRUNCH   DS    0H\nboom     EX    R15,boom             Crash out\n***********************************************************************\n*** This is the main ENQ check routine.                             ***\n*** Exit is via Register 10                                         ***\n***********************************************************************\nENQ_Check DS   0H\n*        LD    FPR0,Loop_Count      * Load double word into floating\n*        AD    FPR0,=D'1'           * Add 1\n*        STD   FPR0,Loop_Count      * Save it\n         L     R6,Loop_Count        *\n         LA    R6,1(R6)             * Increase loop counter\n         ST    R6,Loop_Count        *\n         L     R6,Dynamic_area\n***********************************************************************\n*   Check for dataset contention via GQSCAN                           *\n*   Limit scan to                                                     *\n*         RESNAME=SYSDSN      to get only dataset ENQs.               *\n*         WAITCNT=1           to get only resources with contention.  *\n*         REQLIM=2            to get information on only the first    *\n*                               two requestors for a dataset, since   *\n*                               this program does not worry about     *\n*                               other waiting jobs.                   *\n*   When GQSCAN returns:                                              *\n*         R0 contains size values for the RIB and RIBE                *\n*         R1 contains the number of RIBs returned in SCANAREA         *\n*         R15 contains a return code.                                 *\n***********************************************************************\n         L     R0,Size_of_Area                                    KF003\n*        GQSCAN AREA=((6),10000),SCOPE=ALL,RESNAME=QNAME,             X\n         GQSCAN AREA=((6),(R0)),SCOPE=ALL,RESNAME=QNAME,               X\n               WAITCNT=1,REQLIM=2,MF=(E,SCANLIST)\n         C     R15,=F'8'            Good return code (<=8)\n         BH    ERROR                No, some unexpected error\n         ST    R0,RIB_Size          Save size of RIB and RIBEs\n         ST    R1,RIBSLEFT          Save number of RIBs\n         L     R3,Working_length    Load length\n         SRL   R3,1                 Half it\n         L     R2,Working_area      Point to area\n         LR    R4,R2                Previous area\n         LA    R4,0(R3,R4)          Shuffle up\n         LR    R5,R3                Copy length into R5\n         MVCL  R4,R2                Copy Current -> Previous\n         MVC   Previous_Count,Current_Count  Load previous count\n         XC    Current_Count,Current_Count   Clear Current count\n         L     R6,Dynamic_area      Point back at dynamic area\n         L     R1,RIBSLEFT          Save number of RIBs\n         LTR   R1,R1                Test number of RIBs returned\n         BE    Non_returned         If none were returned, then\n         USING RIB,R6               Address the RIB\n***********************************************************************\n*        Check RIB to see if it matches the search criteria.          *\n***********************************************************************\nCHECKRIB DS    0H\n         ST    R1,RIBSLEFT          Save remaining number of RIBs\n         L     R2,RIBNRIBE          Get number of RIBS\n         LA    R3,2\n         CR    R2,R3                Do we have 2?\n         BL    Next_RIB             If No, skip this RIB\n         LR    R5,R6                Load RIB pointer into R5\n         AH    R5,RIB_Length        Compute address of RIBVAR ...\n         L     R1,RIBSLEFT          Save number of RIBs\n         USING RIBVAR,R5            ... and address it\n         LR    R7,R5                Load R7 with RIBE\n         AH    R7,RIBVLEN           Get address of first RIBE\n         LR    R2,R7                Get address of first RIBE\n         AH    R2,RIBE_Length       Compute address of second RIBE\n         TM    RIBESFLG-RIBE(R2),RIBESTAT  2nd person wanting it?\n         BNZ   Next_RIB             No - Skip to next RIB\n         USING RIBE,R7              Address the RIBE\n         L     R2,CVTPTR            Load CVT address into R2\n         CLC   CVTSNAME-CVTMAP(L'RIBESYSN,R2),RIBESYSN Our LPAR?\n         BNE   Next_RIB             No - Skip as unable to notify users\n***********************************************************************\n*   At this point we have found a match for this system and resource  *\n*   Now we check the table to see if it will fit                      *\n***********************************************************************\n         CLC   Current_Count,=A(MAXOWNER)  Is the Current list full?\n         BNL   Next_RIB             Yes, must skip this RIB\n         LA    R3,LENOWNER          Get size of an each entry\n         M     R2,Current_Count     Multiply by Current_Count\n         L     R4,Working_area\n         LA    R2,0(R3,R4)          Point to current area\n         L     R0,Current_Count     *\n         LA    R0,1(R0)             *  Increase current count\n         ST    R0,Current_Count     *\n         USING OWNER,R2             Address the OWNER area\n         XC    OWNER(LENOWNER),OWNER  Clear the OWNER area\n         MVC   SMF_JOB,RIBEJBNM+48  Move in jobname ...           KF002\n         MVC   Jobname,RIBEJBNM     Move in jobname ...\n         MVC   JOBASID,RIBEASID     .. and ASID of holding job\n         XR    R4,R4                Clear register 4\n         IC    R4,RIBRNMLN          Get length of dataset name\n*        C     R4,=F'44'            Compare to maximum dsname length\n*        BL    Skip_trim            If less\n*        LA    R4,44                Set max length\nSkip_trim DS   0H\n         STH   R4,LENDSN            Save the dsname length\n         STH   R4,SMF_DSNLEN        Save the dsname length        KF002\n         BCTR  R4,0                 Down length ready for execute\n         EX    R4,Move_DSN          Move it into OWNER area\n         EX    R4,Move_SMFDSN       Move it into SMF record       KF002\n         LA    R3,1                 Set temp counter to first\n         L     R0,Working_length    Load length\n         SRL   R0,1                 Half it\n         L     R15,Working_area     Point to area\n         LA    R15,0(R0,R15)        Point at previous area\nLook_Again DS  0H\n         C     R3,Previous_Count    Are we done yet?\n         BH    Next_RIB             Yes - Skip out\nCompare  DS    0H\n         CLC   Key-Owner(Lenkey,R15),Key  Match?\n         BE    Matched_Key          Yes - go process matched key\nNext_Owner DS  0H\n         LA    R3,1(R3)             Add to counter\n         LA    R15,Lenowner(R15)    and skip up previous area\n         B     Look_Again           Now loop back to look again\n***********************************************************************\n***                  Executed Instructions                          ***\n***********************************************************************\nMove_DSN MVC   Dsname(*-*),RIBRNAME Move in dataset name\nMove_SMFDSN MVC   SMF_Dsname(*-*),RIBRNAME Move in dataset name   KF002\n***********************************************************************\n*** Here we have identified a match on the RIB entry                ***\n*** We will now call the chunk of code to send the message to the   ***\n*** Holder of the contention if the user is a TSO session           ***\n***********************************************************************\nMatched_Key DS 0H\n         MVC   DATA(LENDATA),DATA-OWNER(R15) Save in current list\n         OI    STATUS-OWNER(R15),ONGOING Flag that we had previous hit\n         LR    R1,R2                Point at current entry\n         DROP  R2\n*\n         BAS   R14,Contention_Exists Go to process the contention\n*\nNext_RIB  DS   0H\n         L     R2,RIBNRIBE          Get number of RIBEs for this RIB\n         MH    R2,RIBE_Length       Compute total size of the RIBEs\n         ALR   R7,R2                Compute address of next RIB\n         LR    R6,R7                Save address of next RIB\n         L     R1,RIBSLEFT          Get number of RIBs left\n         BCT   R1,CHECKRIB          Process next RIB, if any\nNon_returned   DS  0H\n         USING OWNER,R1             Address the OWNER section\n         LA    R3,1                 Set initial counter\n         L     R0,Working_length    Load length\n         SRL   R0,1                 Half it\n         L     R1,Working_area      Point to area\n         LA    R1,0(R0,R1)          Point at previous area\nCheck_looper DS    0H\n         C     R3,Previous_Count    Have we finished?\n         BH    ENQ_Check_Exit       Yes - Go get out\n         TM    STATUS,ONGOING       Had this before?\n         BNZ   Next_Entry           No - Go get next entry\n*        BAS   R14,Contention_relieved Clear the entry\nNext_Entry   DS    0H\n         LA    R3,1(R3)             Next entry index ....\n         LA    R1,Lenowner(R1)      .... and location\n         B     Check_looper\n         DROP  R1\nENQ_Check_Exit DS  0H\n         BR    R10                  Return to sender\nError    DS    0H\n         BAS   R14,FORMAT_MSG       Format message and add prefix\n         MVC   0(l'QSCAN_Fail,R15),QSCAN_Fail   Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\n         B     ENQ_Check_Exit\n***********************************************************************\n***      Contention Exists Subroutine                               ***\n***********************************************************************\nContention_Exists DS 0H\n         STM   R14,R12,Save1        Save the callers registers\n         LR    R2,R1\n         USING OWNER,R2             Address it\n         LOCASCB ASID=JOBASID       Locate the OUCB\n         LTR   R15,R15              Did we find it?\n         BNE   Not_TSO_User         No - bomb out\n         L     R1,ASCBOUCB-ASCB(,R1) Get the OUCB\n         TM    OUCBYFL-OUCB(R1),OUCBLOG TSO user?\n         BZ    Not_TSO_User         No - bomb out\n         LR    R1,R2                Restore R1 for Sending message\n         BAS   R14,Send_message     Go send the message\nNot_TSO_User DS 0H\n         LM    R14,R12,Save1        Restore the registers\n         BR    R14                  Return to caller\n         DROP  R2\n***********************************************************************\n***      Send_Message      Subroutine                               ***\n***********************************************************************\nSend_Message DS 0H\n         STM   R14,R12,Save2        Save the callers registers\n         USING OWNER,R1             Address the owner block\n         L     R3,MSGCOUNT          Load current message count\n         C     R3,=A(MAXMSGS)       How do we compare thee\n         BNL   Do_Not_Send          If we are higher...bug out\n         LA    R3,1(R3)             Increase count ...\n         ST    R3,MSGCOUNT          ... and save it again\n         MVI   MSG_Buffer,C' '\n         MVC   MSG_Buffer+1(l'MSG_Buffer-1),MSG_Buffer\n         MVC   MSG_Buffer(l'MSG_Start),MSG_Start   Move in first part\n         LH    R4,LENDSN            Load length of dataset name\n         BCTR  R4,0                 Down by one for execute\n         EX    R4,Move_message\n         LA    R3,1+MSG_Buffer+L'MSG_Start(R4) Point to end bit\n         MVC   0(l'MSG_End,R3),MSG_End Move in the end part\n         LA    R3,MSG_Buffer        Address of MSG_buffer for TPUT\n         LA    R4,L'MSG_Buffer      Length of buffer into R4 for TPUT\n         LA    R5,Jobname\n         MVC   SMF_WHO,jobname      Save it in the SMF record     KF002\n         TPUT  (R3),(R4),USERIDL=(R5) Tell them about it\n         L     R5,SEND_Count        *\n         LA    R5,1(r5)             *\n         ST    R5,SEND_Count        *\nDo_Not_Send DS 0H\n*                                                                 KF002\n*        Always try to cut an SMF record                          KF002\n*                                                                 KF002\n         TM    SMF_Switch,SMF_ON                                  KF002\n         BNO   NO_SMF_Needed                                      KF002\n         TIME  BIN                  Get the date and time         KF002\n         ST    R0,SMFTIME           Save time in the SMF record   KF002\n         ST    R1,SMFDATE           Save date in the SMF record   KF002\n         SMFWTM SMFSKEL                                           KF002\nNO_SMF_Needed DS 0H                                               KF002\n         LM    R14,R12,Save2        Reload the callers registers\n         BR    R14                  Return to sender\n***********************************************************************\n***                  Executed Instruction                           ***\n***********************************************************************\nMove_Message MVC MSG_Buffer+l'MSG_Start(*-*),DSNAME Move in message\n***********************************************************************\n***      Print_Info        Subroutine                               ***\n***********************************************************************\nPrint_Info  DS 0H\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(ASM_Valsl,R15),ASM_Vals  Get message\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\n         BAS   R14,FORMAT_MSG           Format message prefix\n         MVC   0(6,R15),ASM_Vals    Get the message\n         LA    R15,6(R15)           Bump past the message id\n         MVC   0(8,R15),=C'Maxmsgs=' Insert text\n         LA    R15,8(R15)           Bump past text\n         LA    R1,MAXMSGS           Get value\n         BAS   R14,Convert_it       Edit it out\n         MVC   0(11,R15),=C', Maxowner=' Insert text\n         LA    R15,11(R15)          Bump past text\n         LA    R1,MAXOWNER          Get value\n         BAS   R14,Convert_it       Edit it out\n         MVC   0(11,R15),=C', Areasize=' Insert text\n         LA    R15,11(R15)          Bump past text\n*        L     R1,=A(10000)                                       KF003\n         L     R1,Size_of_area                                    KF003\n         BAS   R14,Convert_it       Edit it out\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\nPrint_SMF_value DS 0H                                             KF002\n         BAS   R14,FORMAT_MSG       Format message prefix         KF002\n         MVC   0(6,R15),ASM_Vals    Get the message               KF002\n         LA    R15,6(R15)           Bump past the message id      KF002\n         MVC   0(16,R15),=C'SMF Recording is' Add new text        KF002\n         LA    R15,17(R15)          Bump past text                KF002\n         MVC   0(2,R15),=c'ON'      Set default                   KF002\n         TM    SMF_Switch,SMF_ON                                  KF002\n         BO    SMF_Listed                                         KF002\n         MVC   0(3,R15),=c'OFF'     Set default                   KF002\n         LA    R15,1(R15)           Bump past text                KF002\nSMF_Listed DS 0H                                                  KF002\n         LA    R15,2(R15)           Bump past text                KF002\n         MVC   0(16,R15),=C', Record Number=' Insert text         KF002\n         LA    R15,16(R15)          Bump past text                KF002\n         LA    R1,SMFREC            Get value                     KF002\n         BAS   R14,Convert_it       Edit it out                   KF002\n         MVC   0(19,R15),=c' (Set via Default).'                  KF002\n         LA    R15,6(R15)           Bump past text                KF002\n         CLI   SMF_set_by,c'D'                                    KF002\n         BE    Done_SMF                                           KF002\n         MVC   0(13,R15),=c'SMF command).'                        KF002\nDone_SMF DS    0H                                                 KF002\n         WTO   ,MF=(E,WTO_AREA)     Issue start message           KF002\n         BAS   R14,FORMAT_MSG       Format message prefix\n         MVC   0(6,R15),ASM_Vals    Get the message\n         LA    R15,6(R15)           Bump past the message id\n         MVC   0(24,R15),=C'Program version number =' Insert text\n         MVC   25(7,R15),Ver_No     Insert version number\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\nPrint_wait_value DS 0H\n         BAS   R14,FORMAT_MSG       Format message prefix\n         MVC   0(6,R15),ASM_Vals    Get the message\n         LA    R15,6(R15)           Bump past the message id\n         MVC   0(10,R15),=C'Wait time=' Insert text\n         LA    R15,10(R15)          Bump past text\n         L     R1,delay\n         XR    R0,R0\n         D     R0,=F'100'          CHANGE TO SECONDS AND HUNDREDTHS\n         BAS   R14,Convert_it       Edit it out\n         MVC   0(24,R15),=c' Seconds (Set via Parm).'\n         LA    R15,18(R15)          Bump past text\n         CLI   Wait_set_by,c'P'\n         BE    Done_it\n         MVC   0(9,R15),=c'Default).'\n         CLI   Wait_set_by,c'D'\n         BE    Done_it\n         MVC   0(14,R15),=c'Wait command).'\nDone_it  DS    0H\n         WTO   ,MF=(E,WTO_AREA)     Issue start message\n         BSM   0,R7\n*        BSM   0,R7                                               KF002\n***********************************************************************\n***      Print_Stats       Subroutine                               ***\n***********************************************************************\nPRINT_STATS DS 0H\n         BAS   R14,FORMAT_MSG       Format message prefix\n         MVC   0(L'Stat_msg,R15),Stat_msg  Get message\n         LA    R15,L'Stat_msg(R15)  Bump past it\n         MVC   1(7,R15),=C'Notify=' Move in text\n         LA    R15,1+7(R15)         Bump past it\n         L     R1,Send_count        Get number\n         BAS   R14,Convert_It       Edit it\n         MVC   0(9,R15),=C', Cycles='   Move in text\n         LA    R15,9(R15)           Bump past it\n         L     R1,Cycle_Count       Get number\n         BAS   R14,Convert_It       Edit it\n         MVC   0(8,R15),=C', Loops='   Move in text\n         LA    R15,8(R15)           Bump past it\n         L     R1,Loop_Count        Get number\n         BAS   R14,Convert_It       Edit it\n         WTO   ,MF=(E,WTO_AREA)     Issue message\n         BSM   0,R7\n***********************************************************************\n***      Convert_It        Subroutine                               ***\n***********************************************************************\nConvert_It DS  0H\n         LTR   R1,R1                    CHECK FOR 0\n         BZ    EDITFWF0                 YES, PUT ZERO\n         ST    R14,SAVER14              Save return address\n         CVD   R1,DOUBLE                NO, CONVERT TO PACKEC\n         LA    R1,DOUBLE2+14            LOCATE SIG DIGIT\n         MVC   DOUBLE2(15),EDITP15\nEF$EDMK  EQU   *\n         EDMK  DOUBLE2(15),DOUBLE+2     EDIT AND SAVE PLACE\n         LA    R14,DOUBLE2+16           LOCATE LAST POSSIBLE BYTE + 1\n         SR    R14,R1                   LENGTH = END - START\n         BCTR  R14,0                    DECREMENT FOR EX\n         EX    R14,EDITFWFM             MOVE EDIT NUMBER TO OUTPUT\n         LA    R15,0(R14,R15)           BUMP POINTER PAST NUMBER\n*        LA    R15,1(r15)\n         MVI   0(R15),C' '              Fix unprintable character\n         L     R14,SAVEr14              Get return address\n         BSM   0,R14                    RETURN TO CALLER\nEDITFWFM MVC   0(0,R15),0(R1)\nEDITP15  DC    X'40,20,20,6B,20,20,20,6B,20,20,20,6B,20,20,20'\nEDITFWF0 DS    0H\n         MVI   0(R15),C'0'              PUT IN ZERO\n         LA    R15,1(R15)               BUMP POINTER PAST ZERO\n         BSM   0,R14                    RETURN TO CALLER\n***********************************************************************\n*** This is the timer exit. Basically all we do is set the ECB in   ***\n*** the ECBLIST, and then get the heck back to the mainline         ***\n***********************************************************************\nTIMEEXIT DS    0H\n         LR    R11,R15              Establish addressability to the\n         USING TIMEEXIT,R11         TIMEEXIT subroutine\n         LR    R8,R14               Save our return address in R8\n         POST  ECB,4                Post the TIMER ECB\n         BR    R8                   Return to mainline routine\n***********************************************************************\n         DROP  R11\nWTO_SKEL WTO   '                                                       X\n                                         ',MF=L\nSKEL_LEN EQU   *-WTO_SKEL\nDELAY    DC    F'1000'              Number of secs 2 wait (in 100ths)\nQNAME    DC    CL8'SYSDSN  '        Major name for dataset ENQs\n*\n**       Message to send to TSO users\n*\nMSG_START DC     C'===>> Please free '''\nMSG_END   DC     C'''. Other jobs are waiting to use it. (ENQWATCH)'\n*\n**       Messages Issued by program\n*\nStart_MSG DC    C'01I Starting - ENQWATCH last assembled on &SYSDATE at*\n                &SYSTIME'\nActive_MSG DC   C'02I - Enqueue monitor active'\nFreeFailed_MSG DC C'03I - Free of start CIB Unsuccessful'\nStop_Msg  DC    C'04I - Enqueue monitor shutdown in progress'\nQSCAN_Fail DC   C'05E - GQSCAN Failed. Retrying'\nInvalid_CMD DC  C'06E - Invalid command'\nASM_Vals  DC    C'07I - ENQWATCH was assembled using these values:'\nASM_ValsL EQU   *-ASM_Vals\nStat_MSG  DC    C'08I - Status:'\nInvalid_Wat DC  C'09E - Invalid WAIT command. No action taken.'\nParm_errg   DC  C'10E - Invalid PARM passed. Default wait taken'\nSMF_Action  DC  C'11I - SMF recording as been switched '          KF002\nSMF_ActionL EQU *-SMF_Action                                      KF002\nInvalid_SM  DC  C'12E - Invalid SMF command. No action taken.'    KF002\n*\nEXTRACTS EXTRACT CIBAREA,FIELDS=COMM,MF=L\nEXT_LEN  EQU   *-EXTRACTS\nWORKAREA DS    0H\nWORKAREA_LENGTH EQU WORKAREA_END-WORKAREA\nSAVEAREA DS    18F                  Standard savearea\nSAVE1    DS    15F\nSAVE2    DS    15F\nDATAAREA DS    4F                   CIB Data araea\nCIBAREA  DS    F                    Out CIB area address\nCURCOUNT DS    F                    Current ENQ count\nLoop_Count DS  F                    Count of number of loops\nSend_Count DS  F                    Count of TPUTS\nCOMMADDR DS    F\nSAVER14  DS    F                    Preserve R14\nDOUBLE   DS    D                    Double word work area\nDOUBLE2  DS    2D                   Double word work area * 2\nRIB_Size DS    F                    Size of RIB and RIBEs\n         ORG   RIB_Size\nRIB_Length     DS H                 Size of RIB\nRIBE_Length    DS H                 Size of RIBE\nRIBSLEFT       DS F                 Count of RIBS left\nDynamic_Area   DS F                 Address of dynamic area\nSize_of_area   DS F                 Address of dynamic area       KF002\nWorking_length DS F                 Length of enqueue work area\nWorking_Area   DS F                 Address of enqueue work area\nPrevious_Count DS F                 Count of previous ENQs\nCurrent_Count  DS F                 Count of current ENQs\nCycle_count    DS F                 Count of how many CYCLE commands\nSMF_Count      DS F                 Count of SMF records cut      KF002\nECB      DC    F'00'\nECBADDR  DC    A(0)\nlastone  DC    A(ECB)\nEXTRACTL EXTRACT CIBAREA,FIELDS=COMM,MF=L\nSCANLIST GQSCAN MF=L\nMSG_Buffer DS  CL120\nBSLSAV2  EQU   MSG_Buffer,9\nWTO_AREA DS    XL(SKEL_LEN)       WTO Area\nWait_set_by DS CL1\nPARMBUF  DS     CL4                    Right-justified parameter\nSMF_Switch DS   CL1                    SMF Recording switch       KF002\nSMF_set_by DS   CL1                    How SMF was set            KF002\nSMFSKEL  DS    0H                      SMF Record to be written   KF002\nSMFLEN   DS    H                       Record length              KF002\nSMFSEG   DC    H'0'                    Segment indicator          KF002\nSMFSIND  DC    X'06'                   System indicator           KF002\nSMFRECTY DC    AL1(233)                Record type                KF002\nSMFTIME  DS    XL4                     Time                       KF002\nSMFDATE  DS    XL4                     Date                       KF002\nSMFSID   DS    CL4                     System Id.                 KF002\nSMF_WHO  DS    CL8                     Who got the message        KF002\nSMF_JOB  DS    CL8                     Who got the message        KF002\nSMF_DSNLEN DS  H                       Dataset name length        KF002\nSMF_DSName DS  CL44                    Dataset name               KF002\nSMFSLEN  EQU   *-SMFSKEL                                          KF002\nWORKAREA_END EQU *\n         LTORG\n*\n*  Table of dataset owners from the current scan.\n*\nCURRENT  DSECT\n         DS     0F\n         ORG    CURRENT+MAXOWNER*LENOWNER\nLENCUR   EQU    *-CURRENT              Size of CURRENT area\n*\n*  Table of dataset owners from the previous scan.\n*\nPREVIOUS DSECT\n         DS     0F\n         ORG    PREVIOUS+MAXOWNER*LENOWNER\n***********************************************************************\n*   Dataset owner entry mapping                                       *\n***********************************************************************\nOWNER    DSECT\n*\n* Key that uniquely identifies an OWNER entry\n*\nKEY      DS     0C\nJobname  DS     CL8                    User owning dataset resource\nJOBASID  DS     H                      Address space of user\nLENDSN   DS     H                      True length of dataset name\nDSNAME   DS     CL44                   Buffer for dataset name\nLENKEY   EQU    *-KEY                  Total size of the entry key\nDATA     DS     0C\nMSGCOUNT DS     F                      Number of messages that have\n*                                      been sent to this user for\n*                                      this dataset name.\nLENDATA  EQU    *-DATA                 Total size of the entry data\n*\n* Data for use by the mainline code\n*\nSTATUS   DS     BL1\nONGOING  EQU    X'80'                  Entry has a Current match\n         DS     0F                     Align to fullword boundary\nLENOWNER EQU    *-OWNER                Total size of the entry\n         CVT    DSECT=YES\n         ISGRIB\n         IHAASCB\n         IRAOUCB\n         DSECT\n         IEZCOM\n         DSECT\n         IEZCIB\n         END   ENQWATCH\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENQWDOC": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x16\\x01\\x00\\x00\\x01\\x11\\x06\\x1f\\x01\\x11\\x06\\x1f\\x00\\x12\\x0f\\xf4\\x0f\\xf4\\x00\\x00\\xd4\\xe2\\xe6\\xd6\\xd9\\xc4@@@@'", "ispf": {"version": "22.01", "flags": 0, "createdate": "2011-03-02T00:00:00", "modifydate": "2011-03-02T00:12:00", "lines": 4084, "newlines": 4084, "modlines": 0, "user": "MSWORD"}, "mimetype": "application/msword", "datatype": "binary", "extension": ".doc"}, "ENQWPDF": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x16\\x01\\x00\\x00\\x01\\x11\\x06\\x1f\\x01\\x11\\x06\\x1f\\x00\\x12\\x07c\\x07c\\x00\\x00\\xd7\\xc4\\xc6@@@@@@@'", "ispf": {"version": "22.01", "flags": 0, "createdate": "2011-03-02T00:00:00", "modifydate": "2011-03-02T00:12:00", "lines": 1891, "newlines": 1891, "modlines": 0, "user": "PDF"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT844/FILE844.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT844", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}