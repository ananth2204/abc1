{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012225000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE502.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE502.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x07'", "DS1TRBAL": "b'\\x86\\xf0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xd1\\x00\\x07\\x03\\xd2\\x00\\x00\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\t/\\x01\\x01\\t/\\x15\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-04-02T00:00:00", "modifydate": "2001-04-02T15:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 433    FILE:  502\n\n    ORIGINAL DSNAME:  WSBG.CBT433.FILE502\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n\n   PDS117I 7 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,875 RECORDS\n\nTIME THIS PDS WAS SHIPPED:   04/02/01    15:00:38    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x04?\\x01\\x01\\x04?\\x19\\x08\\x00\\x1e\\x00!\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-02-12T00:00:00", "modifydate": "2001-02-12T19:08:00", "lines": 30, "newlines": 33, "modlines": 0, "user": "WSBG"}, "text": "\nI hope this will explain the purpose of our zap to the AMASPZAP\nprogram.\n\nWe have application software that doubles as a DFHSM replacement\nin regard to migration/backup.\n\nThis software as part of its daily processing makes hundreds of\nVTOC updates and Netview Automation was being used to answer the\n\nAMA117D REPLY Y OR N TO UPDATE VTOC\nMessage.\n\nNetview could not cope with the volume of WTORs that were being\ngenerated at times hence this solution.\n\nThe rename has been done as:\n\n1.  A precaution against misuse.\n\n2.  To allow testing.\n\n3.  To avoid confusion with the original.\n\n\n\nTake care and best wishes\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE502": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x01\\x02_\\x01\\x01\\x05?\\x17\\x18\\x00\\x0e\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2001-02-22T17:18:00", "lines": 14, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 502 contains code from Charles MacNiven, to zap a copy    *   FILE 502\n//*           of the AMASPZAP program, so as to eliminate its       *   FILE 502\n//*                                                                 *   FILE 502\n//*           AMA117D REPLY Y OR N TO UPDATE VTOC                   *   FILE 502\n//*                                                                 *   FILE 502\n//*           message.  The member $$NOTE explains why it was       *   FILE 502\n//*           necessary to make this modification.  I am including  *   FILE 502\n//*           this mod here, in the hope that it might be useful    *   FILE 502\n//*           to somebody.  It also illustrates something about     *   FILE 502\n//*           how to zap a system module when you need to change    *   FILE 502\n//*           it.  MVS 3.8 source code was used to help get our     *   FILE 502\n//*           bearings, while attempting to read the appropriate    *   FILE 502\n//*           parts of the load module of the newer code.           *   FILE 502\n//*                                                                 *   FILE 502\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MAPS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x05\\x7f\\x01\\x01\\x05\\x7f\\x11\\x16\\x00&\\x00 \\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-02-26T00:00:00", "modifydate": "2001-02-26T11:16:00", "lines": 38, "newlines": 32, "modlines": 0, "user": "WSBG"}, "text": "\nThe latest AMASPZAP module is a stub -- a front end for two modules:\n\n   IGWSPZAP - a new module owned by DFP\n   AMAZAP   - the equivalent to the old AMASPZAP functionality -\n              owned by BCP\n\n\n ** MAP      AMASPZAP     (MVS 3.8 VERSION)\n AMASPZAP 00000000 000010DA  RMODE 24  AMODE 24\n AMASZDMP 000010E0 000003B0  RMODE 24  AMODE 24\n AMASZCON 00001490 00001132  RMODE 24  AMODE 24\n AMASZIOR 000025C8 00000BF2  RMODE 24  AMODE 24\n\n ENTRY POINT AT 00000000  --  AMASPZAP\n MODULE LENGTH  000031C0  --     13K\n\n\n\n ** MAP      AMAZAP       (OS/390 R1.3 VERSION)\n AMAZAP   00000000 000014D8  RMODE 24  AMODE 24\n AMASZDMP 000014D8 00000428  RMODE 24  AMODE 24\n AMASZCON 00001900 00001138  RMODE 24  AMODE 24\n AMASZIOR 00002A38 00000C90  RMODE 24  AMODE 24\n\n ENTRY POINT AT 00000000  --  AMAZAP\n MODULE LENGTH  000036C8  --     14K\n\n\n\n ** MAP      AMAZAP       (OS/390 R2.10 VERSION)\n AMAZAP   00000000 0014D1  RMODE 24  AMODE 24\n AMASZDMP 000014D8 000444  RMODE 24  AMODE 24\n AMASZCON 00001920 001132  RMODE 24  AMODE 24\n AMASZIOR 00002A58 000C76  RMODE 24  AMODE 24\n\n ENTRY POINT AT 00000000  --  AMAZAP\n MODULE LENGTH  0036D0  --     14K\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PARTSRC": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x01\\x04?\\x01\\x01\\x04?\\x19\\x00\\x00q\\x00=\\x004\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-02-12T00:00:00", "modifydate": "2001-02-12T19:00:00", "lines": 113, "newlines": 61, "modlines": 52, "user": "WSBG"}, "text": "*   THIS IS THE RELEVANT PIECE OF MVS 3.8 AMASPZAP SOURCE CODE\n*******************\n*           THIS ROUTINE SIMULATES BLDL. AND STOW USING, EXCP\n*              TO READ THE DIRECTORY AND WRITE THE DIRECTORY\n*******************\n         SPACE 1\n*      THIS CODE SETS UP THE CCW'S FOR THE READING OF THE DIRECTORY\nDIRREAD  MVC   IOCCW3(4),IOCCW6         SET UP TIC TO RD C.P.\n         MVC   IOCCW7+1(3),RDAREA+1     SET INPUT BUFFER\n         XC    SCHARG(8),SCHARG         ZERO OUT M AND R\n         L     WK7,LIB+44          GET DEB ADDRESS\n         MVC   SCHARG+1(6),STEXT-2(WK7)  SET SEEK ADDRESS\n         MVC   SCHARG+1(2),LIB2+6  SET BB IN SRCH MBBCCHHR\nUPDATEIO LA    1,DECB4+4                IOB ADDR\n         SVC   0                        EXCP\n         WAIT  1,ECB=DECB4              WAIT ON I/O\n         BC    15,ERRTST\n         SPACE 1\n*        THIS CODE SET UP THE CCW'S FOR THE DIRECTORY UPDATE\nDIRWRITE MVC   IOCCW3(8),IOCCW3B        SET UP UPDATE CCW\n         MVC   IOCCW3+1(3),RDAREA+1     SET OUTPUT AREA ADDR\n         MVC   SCHARG+3(5),TBUF+1       SET SEARCH ARG\n         BC    15,UPDATEIO              TO UPDATE DIRECTORY\n         SPACE 1\nOPENLIB  TM    LIB+OPENBIT,OPENED       HAS IT BEEN OPENED YET   S21995\n         BCR   1,LNKRG1                 YES,LNKRG1  RETURN       S21995\n         RDJFCB LIB                                              S21995\n         LA    RG5,JFCBAREA       GET ADDRESS OF JFCB            S21995\n         CLC   0(44,RG5),DSCBDS   JFCB FOR FORMAT4?              S21995\n         BC    7,RSRV              NO, ISSUE RESERVE AND OPEN    S21995\nASKOP    ST    LNKRG1,LNKSAVE2         SAVE LINK REGISTER        A38645\n         BAL   LNKRG1,UPVTRTN          REQUEST TO UPDATE VTOC    A38645\n         L     LNKRG1,LNKSAVE2         RESTORE LINK REGISTER     A38645\n         OI    CDBUF,X'40'         INSURE A CAPITAL LETTER       S21995\n         MVC   JFCBAREA(12),F4DSCB    MOVE FORMAT4.DSCB INTO DSN S21995\n         MVC   JFCBAREA+12(32),BLANKS   PAD REMAINDER OF DSNAME  S21995\n         CLI   CDBUF,C'N'               OKAY TO MODIFY           A53326\n         BC    8,NOF4MOD                NO-NOTIFY USER           A53326\n         CLI   CDBUF,C'Y'          CHECK FOR Y                   A53326\n         BC    7,ASKOP             NO, REISSUE MSG               A53326\nRSRV     L     RG5,LIB2+44         GET DEB ADDR FOR SYSLIB       S21995\n         LA    RG5,0(RG5)          CLEAR HI BYTE                 S21995\n         L     RG5,32(RG5)         PUT UCB AD IN RG5             YM5147\n         ST    RG5,UCBAD           PUT IN UCBAD FOR RESERVE      YM5147\n         MVC   RNAME(6),28(RG5)    MOVE MINOR NAME FROM UCB      YM5147\n         CLC   JFCBAREA(12),F4DSCB JFCB FOR FORMAT4?             YM5147\n         BE    VTOCRSRV            RESERVE 'SYSVTOC'             YM5147\n         RESERVE (MAJOR,JFCBAREA,E,44,SYSTEMS),RET=HAVE,UCB=UCBAD 21995\n         B     RESERVED           BRANCH AROUND RESERVE FOR VTOC YM5147\nVTOCRSRV RESERVE (QNAME,RNAME,E,6,SYSTEMS),RET=HAVE,UCB=UCBAD    YM5147\nRESERVED EQU  *                                                  YM5147\n         MVI   RSVSW,X'FF'         INDICATE RESERVE ISSUED       S21995\nOPEN2    OPEN  (LIB,(UPDATE))           OPEN                     S21995\n         BCR   15,LNKRG1                DONE                     S21995\n         SPACE 1\nNOF4MOD  OI    CTLBTE,NAMEERR                                    S21995\n         LA    RG5,NOVTOC               ERROR MSG                S21995\n         BAL   LNKRG1,WRITE0A            PRINT OUT ERROR MSG     S21995\nOPENRT   MVC   RETCODE(1),RETCOD08     .INDIC SPZAP-INP ERROR. @ZA06023\n         LM    0,15,XFERSAVE           RESTORE REGS              S21995\n         BCR   15,LNKRG3               GET NEXT CARD             S21995\n         SPACE 2\n*\n*\n*   ----  LARGE SNIPPAGE  -----\n*\n*\n***********************************************************************\n*                                                                     *\n*  THIS ROUTINE WRITES MESSAGE AMA117D TO OPERATOR TO REQUEST         *\n*  PERMISSION TO UPDATE VTOC                                          *\n*                                                                     *\n***********************************************************************\nUPVTRTN  ST    LNKRG1,LNKSAVE3         SAVE LINK REGISTER        A38645\n         BALR  LNKRG1,0                ESTABLISH                 A38645\n         USING *,LNKRG1                 ADDRESSABILITY           A38645\n         EXTRACT ADDRSV,'S',FIELDS=(TIOT) GET ADDR ACT TASK      A38645\n         L     RG5,ADDRSV              RG5 POINTS TO TIOT        A38645\n         MVC   UPVTMSG+66(8),0(RG5)    MOVE JOBNAME TO MSG BUFFERA38645\n         LA    RG5,24(RG5)             INCREMENT TO FIRST DD ENT A38645\nCHKLIB   CLC   4(6,RG5),SYSLIB         SYSLIB DD                 A38645\n         BC    8,LIBUCB                GET SYSLIB UCB ADDR       A38645\n         XC    ADDRSV(4),ADDRSV        CLEAR ADDRESS AREA        A38645\n         MVC   ADDRSV+3(1),0(RG5)      MOVE LEN OF DD ENTRY      A38645\n         A     RG5,ADDRSV              RG5 POINTS TO NEXT DD ENT A38645\n         BC    15,CHKLIB               CHECK IF ITS SYSLIB       A38645\nLIBUCB   L     RG5,16(RG5)             REL ADDR OF SYSLIBS UCB   A38645\n         DEVTYPE SYSLIB,DEVBUF         GET SYSLIB DEVICE TYPE    A38645\n         CLI   DEVBUF+3,X'05'          IS IT A 2321 DATA CELL    A38645\n         BC    7,NOT2321               NOT 2321                  A38645\n*  DEVICE IS A 2321 DATA CELL                                         *\n         MVC   UPVTMSG+53(6),4(RG5)    2321 VOLSER TO MSG BUFFER A38645\n         MVC   UPVTMSG+64(1),1(RG5)    BIN NUMBER TO MSG BUFFER  A38645\n         OI    UPVTMSG+64,X'F0'        CONVERT TO EBCDIC         A38645\n         MVI   UPVTMSG+63,C'/'         INSERT DELIMETER          A38645\n*  FIND BEGINNING OF 2321 UCB FOR UNIT ADDRESS FIELD                  *\n         ST    RG5,ADDRSV              SAVE ADDR OF CELL DESCR   A38645\n         LH    RG5,0(RG5)              LOAD BIN NUMBER           A38645\n         SLA   RG5,4                   TIMES BYTES/CELL ENTRY    A38645\n         LA    RG5,56(RG5)             PLUS DISP TO BIN0 DESCR   A38645\n         LCR   RG5,RG5                                           A38645\n         A     RG5,ADDRSV              RG5 POINTS TO BEGIN OF UCBA38645\n         BC    15,UNITNAME             MOVE UNIT NAME            A38645\nNOT2321  MVC   UPVTMSG+53(6),28(RG5)   NON 2321 VOLSER TO MSG BUFA38645\nUNITNAME MVC   UPVTMSG+60(3),13(RG5)   MOVE UNIT NAME TO MSG BUF A38645\n         XC    WTOECB(4),WTOECB        CLEAR ECB                 A38645\nUPVTMSG  WTOR  'AMA117D REPLY Y OR N TO UPDATE VTOC                    X\n                  ',CDBUF,1,WTOECB,ROUTCDE=1,DESC=2\n         WAIT  ECB=WTOECB                                        A38645\n         MVC   UPVTMSG+53(21),UPVTMSG+52 BLANK DYNAM AREA        A38645\n         L     LNKRG1,LNKSAVE3         RESTORE LINK REGISTER     A38645\n         BR    LNKRG1                  .RETURN TO CALLER.      @ZA17658\n         EJECT                                                 @ZA17658\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SOURCE38": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x002_\\x01\\x002_\\x12\\x05\\x0e\\x00\\x0e\\x00\\x00\\x00\\xf3K\\xf8@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-11-20T00:00:00", "modifydate": "2000-11-20T12:05:00", "lines": 3584, "newlines": 3584, "modlines": 0, "user": "3.8"}, "text": "         TITLE 'AMASPZAP - INSPECTS AND MODIFIES DATA ON DA DEVICES'\n***********************************************************************\n*\n*TITLE - AMASPZAP\n*\n*STATUS - CHANGE LEVEL 0\n*\n*FUNCTION - AMASPZAP WILL PERFORM THE FOLLOWING FUNCTIONS:\n*              (1) INSPECT AND MODIFY INSTRUCTIONS AND DATA IN ANY\n*                  LOAD MODULE THAT EXISTS AS A MEMBER OF A PARTITIONED\n*                  DATA SET.\n*\n*              (2) INSPECT AND MODIFY DATA IN A SPECIFIC DATA RECORD\n*                  THAT EXISTS IN A DIRECT ACCESS DATA SET\n*\n*              (3) DUMP AN ENTIRE D.A. DATA SET, A SPECIFIC MEMBER\n*                  OF A PARTITIONED DATA SET, OR ANY PORTION OF A\n*                  DATA SET ON A DIRECT ACCESS DEVICE.\n*\n*              (4) UPDATE THE SYSTEM STATUS INFORMATION (SSI) IN THE\n*                  DIRECTORY ENTRY FOR A LOAD MODULE.\n*\n*              (5) UPDATES THE AMASPZAP CSECT IDENTIFICATIO RECORD\n*                  (IDR) IN THE LOAD MODULE\n*\n*INPUT -    CONTROL STATEMENTS ARE USED TO CONTROL THE FUNCTIONS OF\n*           AMASPZAP. THESE STATEMENTS CAN BE PROVIDED VIA SYSIN OR\n*           THROUGH THE CONSOLE IF A CONSOLE CONTROL STATEMENT IS\n*           INCLUDED IN THE SYSIN INPUT. THE ACCEPTABLE CONTROL\n*           STATEMENTS ARE AS FOLLOWS:\n*\n*        -KEYWORD-  -PARM1-       -PARM2-             -FUNCTION-\n*\n*        NAME       MEMBER        CSECT     ......IDENTIFIES A CSECT\n*        VERIFY     HEX-OFFSET    HEX-DATA  ......INSPECTS DATA\n*        REP        HEX-OFFSET    HEX-DATA  ......MODIFIES DATA\n*        SETSSI     DATA (4 BYTES)          ......UPDATES SSI INFO\n*        IDRDATA    DATA (8 BYTES)          ......SUPPLIES IDR DATA\n*        DUMP       MEMBER        CSECT/ALL ......DUMPS CSECT(S)\n*        DUMPT      (SAME PARMS AS DUMP)    ......TRANSLATED DUMP\n*        CCHHR      DISK-ADDRESS IN HEX     ......IDENTIFIES A RECORD\n*        ABSDUMP    START-CCHHR   STOP-CCHHR......DUMPS DATA RECORD(S)\n*                       OR\n*                   ALL\n*                       OR\n*                   MEMBER NAME\n*        ABSDUMPT   (SAME PARMS AS ABSDUMP) ......TRANSLATED ABSDUMP\n*        BASE       HEX-OFFSET              ......SPECIFIES CSECT START\n*        CONSOLE    (NONE)                  ......CONSOLE INPUT REQUEST\n*        * (ASTERISK)             COMMENTS  ......NO OPERATION\n*\n*OUTPUT -   AS EACH CONTROL STATEMENT IS READ IT IS WRITTEN TO THE\n*           SYSPRINT DEVICE AND THEN THE OPERATION IS PERFORMED\n*           BEFORE OBTAINING THE NEXT STATEMENT. WHEN AN ERROR OCCURS\n*           DURING AN OPERATION, AN ERROR MESSAGE IS WRITTEN TO THE\n*           SYSPRINT DEVICE IMMEDIATELY BELOW THE CONTROL STATEMENT\n*           IN ERROR. IF THE CONSOLE OPTION IS IN EFFECT, ERROR MESS-\n*           AGES ARE WRITTEN TO THE CONSOLE AS WELL AS THE SYSPRINT\n*           DEVICE.\n*\n*           ALL DATA THAT IS DUMPED IS WRITTEN TO THE SYSPRINT DEVICE\n*           IN HEXADECAMAL. IF TRANSLATION WAS SPECIFIED, THE MNEUMONIC\n*           REPRESENTATION OF EACH HALFWORD OF DATA IS PRINTED BELOW\n*           THE RESPECTIVE TWO BY8TES OF HEX DATA AND THE EBCDIC\n*           REPRESENTATION OF THE HEX DATA IS TRANSLATED TO THE RIGHT\n*           OF THE HEX DATA IN THE DUMP.\n*\n*          IF A REP OPERATION IS PERFORMED ON A LOAD MODULE\n*          THE SSI AND IDR ARE UPDATED AUTOMATICALLY.\n*\n*ENTRY POINTS - AMASPZAP IS THE ONLY ENTRY\n*\n*EXITS - AMASPZAP RETURNS CONTROL TO THE SYSTEM VIA A RETURN MACRO\n*        AFTER PROCESSING ALL CONTROL STATEMENTS IN THE SYSIN DATA SET\n*        OR WHEN A CRITICAL ERROR IS ENCOUNTERED SO PROCESSING CANNOT\n*        CONTINUE.\n*\n*EXTERNAL REFERENCES - NOT APPLICABLE\n*\n*TABLES - NOT APPLICABLE\n*\n*ATTRIBUTES - NONREUSEABLE PROBLEM PROGRAM\n*\n*NOTES - (1) AMASPZAP UTILIZES SYSTEM OPEN. HENCE AMASPZAP CANNOT\n*            MODIFY8 'READ-ONLY' OR INSPECT 'WRITE-ONLY' PASSWORD\n*            PROTECTED DATA SETS UNLESS THE CORRECT PASSWORD IS\n*            PROVIDED AT OPEN TIME. ALSO UNEXPIRED DATA SETS\n*            CANNOT BE MODIFIED UNLESS THE OPERATOR REPLIES R 00,'U'\n*            TO THE EXPIRATION MESSAGE THAT OCCURS DURING OPEN.\n*\n*        (2) AMASPZAP SUPPORTS ONLY THE 2311, 2314, 2301, 2302, 2303\n*             2321, 3330, 3340, AND 3350 DASD DEVICES\n*             FOR THE SYSLIB DD UNIT.\n*\n*        (3) THE SYSLIB DD CANNOT SPECIFY A CONCATENATED DATA SET.\n*\n*        (4) THE SYSLIB DD MUST SPECIFY DSN=FORMAT4.DSCB IF OPERA-\n*            TIONS ARE TO BE PERFORMED ON A VTOC.\n*\n***********************************************************************\n         SPACE 3\n******************************FL/1*************************************\n*/*AMASPZAP: CHART (AMODE,SEQ) */\n*/* HEADER\n*/*AMASPZAP\n*/*                                     PAGE # */\n*/*AMASPZAP: E ENTRY */\n*/* P INITIALIZATION */\n*/* P CHECK INPUT PARAMETER LIST TO SEE IF DDNAMES ARE BEING PASSED */\n*/* P IF SO, INSERT THEM INTO APPROPRIATE DCB */\n*/* P IF NOT, DDNAMES WILL DEFAULT TO SYSLIB, SYSIN, SYSPRINT */\n*/* L OPEN SYSIN, SYSPRINT */\n*/* L READJFCB SYSLIB */\n*/* D (NO,GETDSCB,YES,) FORMAT 4 DSCB? */\n*/* P SET JFCBAREA TO X'04'S */\n*/* L (,CKOPEN) OPEN SYSLIB FOR INPUT */\n*/*GETDSCB: L OBTAIN FMT1 DSCB */\n*/* D (NO,OPEN1,YES,) TRACK OVERFLOW? */\n*/* P SET TRK OVRFL BIT IN DCB */\n*/*OPEN1: L OPEN SYSLIB FOR INPUT */\n*/*CKOPEN: P SET R1 TO LARGEST POSS BLKSIZE */\n*/* P R1=R1 + MAX KEYLEN AND COUNT */\n*/* P SAVE MAX BLOK SIZE */\n*/* P INCREASE GETMAIN SIZE BY TRUE KEYLEN */\n*/* L GET MAIN STORAGE FOR MAX SIZE */\n*/* P SAVE ADDR OF RDAREA BUFFER */\n*/* D (YES,%P2C2,NO,) SYSPRINT OPEN OK? */\n*/*WTOA: L  WTO MSG AMA118I */\n*/* L (,EXIT) CLOSE FILES */\n*/*%P2C2: S WRITE:PRINT AMASPZAP HEADER */\n*/* D (YES,%P2F2,NO,) SYSIN OPEN OK? */\n*/*CLOSE2: S WRITEO:PRINT APPROPRIATE ERROR MSG */\n*/*CLOSE3: L CLOSE ALL DCBS */\n*/* P (,EXIT) SET RETURN CODE 16 */\n*/*%P2F2: D (NO,CLOSE2,YES,) SYSLIB2 OPEN OK? */\n*/* P SET LNKRG3 TO ADDR OF RDCARD1 */\n*/*RDCARD: P INITIALIZE CONTROL BYTE */\n*/*RDCARD1: P TURN OFF CONSW */\n*/* S RDCARD2:GET A CONTROL CARD */\n*/* S WRITE:PRINT CONTROL CARD */\n*/* S SCANKEY:SCAN FOR BEGIN OF OPERATION */\n*/* D (YES,CONRTN,NO,) CONSOLE? */\n*/*KEY01: D (NO,%P2F4,YES,) COMMENT CARD? */\n*/* R RETURN VIA LNKRG3 */\n*/*%P2F4: P INITIALIZE READ AREA */\n*/* D (ON,KEY03,OFF,) NAMEERR SW? */\n*/* D (YES,SSIRTN,NO,) SSI? */\n*/* D (YES,KEY02,NO,) IGNOP? */\n*/* D (YES,REPRTN,NO,) REP? */\n*/*KEY02: D (YES,VERYRTN,NO,) VERIFY? */\n*/* D (YES,IDRRTN,NO,) IDRDATA? */\n*/* S INSMDFY:MODIFY SSI IF ANY REPS OCCURRED */\n*/*KEY03: D (YES,CCHHRTN,NO,) CCHHR? */\n*/* D (YES,NAMERTN,NO,) NAME? */\n*/* D (YES,BASERTN,NO,) BASE? */\n*/* D (YES,DUMPRTN,NO,) DUMP? */\n*/* D (YES,ABDMPRTN,NO,) ABSDUMP? */\n*/* D (YES,EOD,NO,) SLASH AST? */\n*/*IGNORE: P POINT TO MSG AMA105I */\n*/*IGNORE2: S WRITEO:PRINT ERROR MSG */\n*/* D (ON,,OFF,%P3E4) CONSW? */\n*/* S WTORTN:MESSAGE TO CONSOLE */\n*/*%P3E4: P SET RETCODE TO 8 */\n*/* P TURN ON IGNOP SW */\n*/* R RETURN VIA LNKRG3 */\n*/*EOD: S INSMDFY:MODIFY SSI IF ANY REPS OCCURRED */\n*/* P POINT TO MSG AMA100I */\n*/* S WRITEO:PRINT COMPLETED MSG */\n*/* S CLOSE1:CLOSE ALL DCBS */\n*/*EXIT: D (YES,,NO,GETOUT) WAS RESERVE ISSUED? */\n*/* L DEQUE ON DATA SET */\n*/* P TURN OFF RESERVE SW */\n*/*GETOUT: P HOUSEKEEPING */\n*/* R RETURN TO SYSTEM */\n*/*NAMERTN: P SAVE HIGHEST RETURN CODE FOR STEP */\n*/* S SCANKEY5:GET MEMBER AND CSECT NAMES */\n*/* P SET BASE2 TO ZERO */\n*/* P MOVE 'NO IDENT' TO IDR DATA BUFFER */\n*/* P TURN OFF IDRDATA 1ST STMT INDICATOR */\n*/* P TURN OFF IGNOP AND NAMEERR SW */\n*/* S NAME01A:EXAMINE CESDS */\n*/* D (VEC1,,VEC2,NAME03B,VEC3,%21A2) RETURN VECTOR? */\n*/*NOCSECT: S WRITEO:PRINT ERROR MSG */\n*/* D (ON,,OFF,%P4A4) CONSW? */\n*/* S WTORTN:MSG TO CONSOLE */\n*/*%P4A4: P SET RETCODE TO 8 */\n*/* P (,DUMP04) TURN ON IGNOP & NAMEERR SW */\n*/*%21A2: D (NO,NAME04AA,YES,) WAS LOAD MOD READ? */\n*/* P (,NAME04AB) RESET LOAD MOD READ SW */\n*/*NAME04AA: D (YES,NOIDRL,NO,) IS LOAD MOD NE */\n*/*NAME04A: S RDDSK2:READ NEXT RECORD */\n*/*NAME04AB: D (YES,SPZAPIDR,NO,) IS THIS AN IDR? */\n*/* D (YES,NAME04A,NO,) SYM OR CESD? */\n*/*NOIDRL: P POINT TO MSG AMA119I */\n*/* P TURN OFF NENOIDR SW */\n*/* S WRITEO:PRINT MESSAGE */\n*/* P INDICATE NO IDR UPDATES REQD */\n*/* P (,RDDSK4BB) SET LNKRG2 TO ADDR OF NAME04 + 4 */\n*/*SPZAPIDR: D (YES,,NO,NAME04A) AMASPZAP IDR? */\n*/* D (YES,SAVELOC,NO,) ANY SPACE LEFT? */\n*/* D (YES,NAME04A,NO,) ANY MORE SPZAP IDRS? */\n*/* P TURN ON IGNORE OPTION SW- NO REPS */\n*/* P POINT TO MSG AMA120I */\n*/* S (,NAME04) WRITEO:PRINT MESSAGE */\n*/*SAVELOC: S CCHNOTE:NOTE TTR & CONVERT TO MBBCCHHR */\n*/* P SAVE TTR IN IDRTTR FIELD */\n*/* P SAVE MBBCCHHR IN IDRFSEEK FIELD */\n*/* P INDICATE IDR UPDATE REQUIRED */\n*/*NAME04: S RDDSK4:SIFT THRU CONTROL RECORDS */\n*/* D (VEC1,,VEC2,%P4D5) RETURN VECTOR? */\n*/* N INVALID RETURN VECTOR */\n*/* P NOP INSTR */\n*/*%P4D5: N VECT 2- FOUND CSECT */\n*/* P SAVE CSECT TTR */\n*/* D (YES,%C13,NO,) ONE RECORD CSECT? */\n*/* S CCHNOTE:SET NOTE LIST */\n*/* P  SAVE CSECT TTR */\n*/*%C13: R RETURN VIA LNKRG3 */\n*/*CCHHRTN: P SAVE HIGHEST RETURN CODE FOR STEP */\n*/* P TURN OFF IGNORE OPTION & NAMEERR SW */\n*/* S CCHHSUB:VERIFY LEGAL ABSOLUTE ADDR */\n*/* P ZERO BASE FIELDS */\n*/* S OPENLIB:OPEN DS FOR UPDATE */\n*/* S RDDISK:READ DESIRED RECORD */\n*/* P SUBTRACT RESIDUAL COUNT FROM SIZE */\n*/* P SAVE AS MAX INSPECT AREA */\n*/* R RETURN VIA LNKRG3 */\n*/*VERYRTN: P INDICATE VERIFY PROCESSING */\n*/* S SETUP1:DECODE VERIFY CARD */\n*/* P VERIFY PATCHES */\n*/* D (YES,,NO,%P21E2) SUCCESSFUL VERIFY? */\n*/* R RETURN VIA LNKRG3 */\n*/*%P21E2: P POINT TO MSG AMA104I */\n*/*VERY1: S WRITEO:PRINT ERROR MSG */\n*/* D (YES,,NO,%P21H2) CONSOLE OPTION IN EFFECT? */\n*/* S WTORTN:WRITE MSG TO CONSOLE */\n*/*%P21H2: P SET RETURN CODE OF 8 */\n*/* P TURN ON IGNORE OPTION SW */\n*/* P BLANK OUT MEMBER & CSECT NAME FIELDS */\n*/* S WRITEO:WRITE A BLANK LINE */\n*/* P INITIALIZE TO DUMP CSECT OR RECORD */\n*/* S (,DUMP09) DUMP01AB:DUMP */\n*/*REPRTN: P INDICATE REP OPERATION */\n*/* S SETUP1:DECODE REP CARD */\n*/* N TAKES THIS PATH IF CCHHR UPDATE */\n*/* S UNPATCH: FORMAT UNPATCH MESSAGE */\n*/* S WRITE:PRINT MESSAGE */\n*/* P BLANK LAST 40 CHAR OF BUFFER */\n*/* P MOVE IN REP DATA */\n*/* S WRDISK:UPDATE RECORD ON DISK */\n*/* P (,RESET) INDICATE CCHHR UPDATE OCCURRED- MODFYREC */\n*/*BASERTN: S SCAN:DECODE BASE OFFSET */\n*/* P (,RESET) SAVE OFFSET */\n*/*IDRRTN: D (YES,%21A1,NO,) 1ST IDRDATA THIS NAME? */\n*/* R RETURN VIA LNKRG3 */\n*/*%21A1: S SCANKEY1:DECODE IDR STATEMENT */\n*/* P SAVE IDR DATA */\n*/* P INDICATE 1ST IDRDATA STMT READ */\n*/* R RETURN VIA LNKRG3 */\n*/*SSIRTN: D (YES,%P23B2,NO,) IS RETURN CODE ZERO? */\n*/* P (,SSI2) POINT TO MSG AMA111I */\n*/*%P23B2: P INDICATE SSI PROCESSING */\n*/* P TURN OFF SSI ERROR FLAGS */\n*/* S OPENLIB:CHECK IF LIB OPEN FOR UPDATE */\n*/* S SCAN:DECODE SSI CARD */\n*/* S INSM1A:GET SSI FIELD */\n*/* D (YES,%P23G2,NO,) HAD WE FOUND THE MEMBER */\n*/* P (,SSI2) POINT TO MSG AMA112I */\n*/*%P23G2: D (YES,SSI1,NO,) SSI MISSING FROM DIRECTORY ? */\n*/* S UNPATCH: FORMAT UNPATCH MESSAGE */\n*/* S WRITE:PRINT MESSAGE */\n*/* P BLANK LAST 40 CHAR OF BUFFER */\n*/* P MOVE SSI TO DIRECTORY */\n*/* S (,RESET) DIRWRITE:UPDATE DIRECTORY */\n*/*SSI1: P POINT TO MSG AMA110I */\n*/*SSI2: P SET RETURN CODE OF 8 */\n*/* S WRITEO:PRINT ERROR MSG */\n*/* D (YES,,NO,RESET) CONSOLE OPTION IN EFFECT? */\n*/* S (,RESET) WTORTN:WRITE MSG TO CONSOLE */\n*/*DUMPRTN: D (YES,DUMPR1,NO,) TRANSLATED DUMP REQUEST ? */\n*/* P INDICATE TRAN DUMP REQUIRED */\n*/*DUMPR1: S SCANKEY5:GET MEMBER & CSECT NAME */\n*/* P TURN OFF ONE RECORD INDICATOR */\n*/* P TURN ON NAMEERR SW- DONT ALLOW VERS OR REPS */\n*/* D (YES,DUMP04,NO,) ALL CSECTS REQUIRED ? */\n*/*DUMP01A: S NAME01A:FIND CSECT NAME */\n*/* D (VEC1,NOCSECT,VEC2,NAME03B,VEC3,DUMP01B) RETURN VECTOR ? */\n*/*DUMP01B: S RDDSK4:READ CONTROL RECORD */\n*/* D (VEC1,,VEC2,%P28K2) RETURN VECTOR ? */\n*/* N (,DUMP09) END OF MODULE */\n*/*%P28K2: N FOUND CONTROL RECORD WITH CSECTID */\n*/* D (YES,DUMP01D,NO,) ONE RECORD INDIC ON ? */\n*/* S DUMP01:TO DUMP CSECT */\n*/* D (YES,DUMP09,NO,) DUMP COMPLETED ? */\n*/*DUMP01D: S DUMP01AA:DUMP ONE RECORD */\n*/* D (YES,DUMP09,NO,) DUMP COMPLETE ? */\n*/* D (YES,,NO,DUMP09) MULTIPLE REC INDIC ON ? */\n*/* P (,DUMP01B) RESET ONE RECORD INDIC */\n*/*DUMP04: P CLEAR CSECT ID SAVE AREA */\n*/*DUMP04A: S NAME01A:FIND FIRST CSECT */\n*/* D (VEC2,,VEC1,DUMP09,VEC3,%P29D2) RETURN VECTOR ? */\n*/* P NOP */\n*/*%P29D2: D (YES,DUMP01D,NO,) ONE RECORD DUMP ? */\n*/* D (YES,,NO,DUMP09) ANY MORE CSECTS */\n*/* D (YES,,NO,NAME03B) HAVE WE FOUND NEXT ESD */\n*/* P SAVE NEW ESD ID */\n*/* P SAVE CSECT NAME FROM ESD ENTRY */\n*/*DUMP06B: S RDDSK4:READ CONTROL RECORD */\n*/* D (VEC1,DUMP04A,VEC2,) RETURN VECTOR ? */\n*/* S DUMP01:DUMP CSECT */\n*/* D (NO,DUMP09:RLL,YES,DUMP04A:RL) LAST TXT REC DUMPED ? */\n*/*DUMP09: N DUMP REQUIREMENT COMPLETE */\n*/* P POINT TO MSG AMA113I */\n*/* S WRITEO:PRINT DUMP COMPLETE MSG */\n*/* P RESET TRANS & END OF MOD INDICS */\n*/* S WRITEO:SKIP TO NEW PAGE */\n*/* R RETURN VIA LNKRG3 */\n*/*ABDMP1: P INCR 1 CHAR ON CONTROL CARD BUF */\n*/*ABDMPRTN: D (YES,ABDMP1,NO,) CHAR = BLANK ? */\n*/* P TURN ON NAMEERR SW- NO VERS OR REPS */\n*/* D (YES,,NO,ABDMP1B) TRANSLATE OPT REQUEST ? */\n*/* P INDICATE TRANSLATE REQUIRED */\n*/*ABDMP1B: P INITIALIZE FOR DUMP */\n*/* P GET CONVERT RTN OFFSET */\n*/* D (YES,ABDMP3,NO,) DUMP OF ENTIRE PDS ? */\n*/* D (YES,,NO,ABDMP6) NUMERIC OPERAND ? */\n*/* S CCHHSUB:DECODE LOW CCHHR */\n*/* S CHCONV:CONVERT TO TTR */\n*/* P SAVE LOW TTR IN TTRSAVE */\n*/* S CCHSUB2:DECODE HIGH CCHHR */\n*/*ABDMP2: P GET CONVERT ROUTINE OFFSET */\n*/* S CHCONV:CONVERT TO TTR */\n*/*CONTA: P MOVE LOW TTR TO STCSECT */\n*/* P SAVE HIGH TTR IN TTRSAVE */\n*/*ABDMP5: P BLANK MEMBER & CSECT NAME FIELDS */\n*/* S DUMP01AA:DUMP RECORD */\n*/*CONTB: D (YES,DUMP09,NO,)  LO TTR >= HI TTR YET ? */\n*/* P RESET IFLAGS IN DCB IF ON DUE TO ERROR */\n*/* D (YES,DUMP09,NO,DUMP01) END OF EXTENT ? */\n*/*CONT: D (NO,,YES,DUMP09) END OF EXTENT? */\n*/* S DUMP01E:WRITE EOD RECORD FOR LIB2 */\n*/* D (YES,DUMP09,NO,) IS DUMP OF SEQUENTIAL D.S. */\n*/* S WRITEO:SKIP A LINE */\n*/* P SET LNKRG2 TO ADDR OF CONTB */\n*/* D (YES,,NO,CONTB) WAS IT MEM DUMP ONLY ? */\n*/* P (,DUMP09) TURN OFF MEMBDMP INDICATOR */\n*/*ABDMP3: P GET DEB ADDR */\n*/* P TURN OFF NAMEOP & ONERECORD INICATOR */\n*/* S CHCONV:CONVERT TO TTR */\n*/* P SAVE TTR IN STCSECT */\n*/* P SET READ AREA ADDR FOR JFCB READ */\n*/* L READ JFCB */\n*/* P GET DEB ADDR AGAIN */\n*/* P GET UCB ADDR FROM DEB */\n*/* P SAVE ADDR OF VOLSER */\n*/* P SET ADDR OF DSNAME IN OBTAIN LIST */\n*/* P ESTABLISH WORK AREA FOR OBTAIN */\n*/* L OBTAIN- SET DSCB */\n*/* M TURN OFF SEQUENTIAL INDICATOR */\n*/* D (YES,,NO,TESTPO) IS DATA SET SEQUENTIAL */\n*/* M (,MAKEHI2) SET SEQUENTIAL INDICATOR */\n*/*TESTPO: D (NO,MAKEHI2,YES,) IS DATA SET PARTITIONED */\n*/* P SAVE END OF DATA SET TTR */\n*/* D (YES,,NO,ABDMP5) TTR = 0 ? */\n*/*MAKEHI2: P (,ABDMP5) SET HIGH TTR TO FOXES & SAVE */\n*/*ABDMP6: S SCANKEY5:GET MEMBER NAME */\n*/* L FIND MEMBER */\n*/* D (YES,,NO,NAME03C) MEMBER FOUND ? */\n*/* P BLANK CSECT NAME FIELD */\n*/* P INDICATE MEMBER DUMP */\n*/* S DUMP01:DUMP MEMBER */\n*/* N (,DUMP01) CONTINUE */\n*/*SYND: N SYNAD EXIT FOR SYSIN */\n*/* L SYNADAF- ANALYZE ERROR */\n*/* P SAVE PARAMETER REG */\n*/* P MOVE ERROR MSG TO BUFFER */\n*/* S IOMSG:PRINT I/O ERROR MSG */\n*/* L (,CLOSE3) RELEASE SYNADAF WORK AREA */\n*/*ABDMP4: N SYNAD EXIT FOR LIB2 */\n*/* P SAVE REGS */\n*/* L SYNADAF- ANALYZE ERROR */\n*/* P SAVE PARM REG */\n*/* P MOVE ERROR MSG TO BUFFER */\n*/* S IOMSG:PRINT I/O ERROR MSG */\n*/* P RESTORE LINK & PARM REGS */\n*/* L RELEASE SYNADAF WORK AREA */\n*/* P (,CLOSE3) RESTORE REGS */\n*/*RESET: P TURN OFF IGNORE OPTION SW */\n*/* N GET NEXT CARD */\n*/* R RETURN VIA LNKRG3 */\n*/*NAME01A: E SUBROUTINE */\n*/* N USED BY NAMERTN & DUMPRTN- FIND MEMBER & CSECT */\n*/* P TURN MULREC SW OFF */\n*/* L DO BLDL ON MEMBER NAME */\n*/* D (YES,%L284,NO,) SUCCESS? */\n*/*NAME03C: P TURN ON NAMEERR SW */\n*/* P (,IGNORE2) POINT TO MSG AMA102I */\n*/*%L284: P SET ESD ID COUNTER TO ZERO */\n*/* P SET BASE FOR FIRST CSECT SEARCH */\n*/* L ISSUE FIND ON MEMBER NAME */\n*/*NAME02: S RDDSK2:SEQUENTIALLY READ ONE REC */\n*/* D (YES,NAME02,NO,) IS IT A SYM RECORD? */\n*/* D (YES,NAME03,NO,) IS IT A CESD? */\n*/* D (YES,NAME03E,NO,) L.E. ATTR+1 = X'08' (NE) */\n*/* D (YES,%C11,NO,) WAS SPECIFIC CSECT REQ? */\n*/* N USE CSECT FOUND WITH LOWEST DISPLACEMENT */\n*/* R RETURN VECTOR 3 */\n*/*%C11: P SET LOAD MOD HAS BEEN READ SW */\n*/* R RETURN VECTOR 1 */\n*/*NAME03: P ESD ID COUNT + 1 */\n*/* D (YES,NAME03A,NO,) IS IT A SECT DEF? */\n*/* D (YES,NAME03A,NO,) IS IT PRIVATE CODE? */\n*/*NAME03B: P INCR TO NEXT ESD */\n*/* D (YES,NAME02,NO,NAME03) END OF THIS CESD? */\n*/*NAME03E: P SET MULREC SW ON */\n*/* P SET NENOIDR SW */\n*/*NAME03D: P SET BASE TO L.E. ASSD ORIGN OF 1ST TXT */\n*/* P SET START TO BASE */\n*/* P SET STCSECT TO TTR OF 1ST TXT */\n*/* P SET LENGTH TO LEN OF 1ST TXT */\n*/* P SET CSECT FIELD TO BLANK */\n*/* P  TURN ON ONEREC SW */\n*/* R RETURN VECTOR 3 */\n*/*NAME03A: D (YES,,NO,NAME03AA) WAS SPECIFIC CSECT REQ? */\n*/* P SAVE DISPLACEMENT AND ESDID */\n*/* D (NO,,YES,%P9L10) IS THIS REQ CSECT */\n*/* R RETURN VECTOR 2 */\n*/*%P9L10: R RETURN VECTOR 3 */\n*/*NAME03AB: P SAVE ESDID */\n*/* P SAVE CSECT DISPLACEMENT */\n*/* R RETURN VECTOR 3 */\n*/*NAME03AA: D (YES,,NO,NAME03AC) THIS CSECT DISPLACEMENT ZERO */\n*/* P (,NAME03AB) SAVE CSECT NAME */\n*/*NAME03AC: D (NO,%C12,YES,) DISPLACEMENT .LT. BASE */\n*/* P SAVE CSECT DATA */\n*/* R RETURN VECTOR 2 */\n*/*%C12: R RETURN VECTOR 2 */\n*/*RDDSK3: E SUBROUTINE */\n*/* N READ DISK ROUTINES */\n*/* S RDDSK2:SEQ READ ONE RECORD */\n*/*RDDSK4: D (YES,,NO,%P7D2) ONE REC SW ON? */\n*/* R RETURN VIA VECTOR 2 */\n*/*%P7D2: S RDDSK2:SEQ READ ONE RECORD */\n*/*RDDSK4BB: D (YES,,NO,RDDSK7) CONTROL RECORD? */\n*/* P SET STARTINC TO ZERO */\n*/* P LOAD PTR TO ID FIELD */\n*/* P SAVE STOP ADDR */\n*/*RDDSK4C: P LOAD CSECT ID */\n*/* D (YES,RDDSK5,NO,) IS IT CSECT WE WANT? */\n*/* D (YES,RDDSK5,NO,) MULT TEXT CSECT? */\n*/* P ADD CSECT LEN TO STARTINC */\n*/* P ADVANCE RECORD PTR */\n*/* D (NO,RDDSK4C,YES,) OUTSIDE RECORD LIMIT? */\n*/* D (YES,,NO,RDDSK3) IS IT END OF MODULE? */\n*/* R RETURN VIA VECTOR 1 */\n*/*RDDSK2: E SUBROUTINE */\n*/* N BSAM- SEQUENTIAL READ */\n*/* P INITIALIZE FOR READ */\n*/* L READ RECORD BSAM */\n*/* L CHECK READ COMPLETION */\n*/* R RETURN */\n*/*RDDSK5: P INDICATE END OF MODULE- CTLBTE */\n*/* D (YES,RDDSK6,NO,) IS IT REALLY END OF MOD? */\n*/* P TURN OFF END MOD IND- CTLBTE */\n*/*RDDSK6: P SAVE CSECT LENGTH */\n*/* P SAVE START ADDR OF 1ST TEXT */\n*/* R RETURN VIA VECTOR 2 */\n*/*RDDSK7: D (YES,,NO,RDDSK4) LAST RECORD OF MOD? */\n*/* R RETURN VIA VECTOR 1 */\n*/*CCHHNOTE: E SUBROUTINE */\n*/* N CONVERT TTRS TO CCHHRS */\n*/* L ISSUE NOTE ON LIB2 */\n*/* P SAVE TTR */\n*/* P INITIALIZATION FOR CONVERT ROUTINE */\n*/*CHCONV: P SAVE REGS 8 - 13 */\n*/* P FURTHER INIT FOR CONVERT ROUTINE */\n*/* P GET ADDR CONVERT ROUTIN FROM CVT */\n*/* L CONVERT TO CCHHR */\n*/* N ABSOLUTE ADDR SAVED IN MBBCCHHR */\n*/* P RESTORE REGS 8 - 13 */\n*/* R RETURN */\n*/*CCHHSUB: E SUBROUTINE */\n*/* N CHECK ABSOLUTE ADDR IS WITHIN DATA SET */\n*/* P INITIALIZATION */\n*/* P TURN OFF NAMEOP & ONEREC SW */\n*/*CCHSUB2: S SCAN:DEBLOCK DATA */\n*/* P SAVE MBBCCHHR */\n*/* D (NO,CONTIN,YES,) MBBCCHHR = RECORD 0? */\n*/* P SET MBBCCHHR TO RECORD 1 */\n*/*CONTIN: P GET PTR TO DEB EXTENTS */\n*/* P GET NO. OF EXTENTS */\n*/* P SUBTRACT 1 FROM NO. EXTENTS */\n*/* P POINT TO 1ST EXTENT ENTRY */\n*/*CCHSUB3: D (YES,CCHSUB4,NO,) MBBCCHHR < THIS EXTENT? */\n*/* D (YES,CCHSUB4,NO,) MBBCCHHR > THIS EXTENT? */\n*/* P SET BB TO FDAD BB */\n*/* R RETURN */\n*/*CCHSUB4: D (YES,NAME03C,NO,) OUT OF EXTENTS? */\n*/* P INCREMENT EXTENT COUNTER */\n*/* P SAVE EXTENT M */\n*/* P (,CCHSUB3) INCREMENT TO NEXT EXTENT */\n*/*CONRTN: E SUBROUTINE */\n*/* N FOR CONSOLE INPUT */\n*/* P CLEAR WTOECB */\n*/* P CLEAR INPUT BUFFER */\n*/* L ISSUE WTOR AMA116A */\n*/* L WAIT FOR REPLY */\n*/* P INSURE REPLY WAS CAP LETTERS */\n*/* S WRITE:PRINT REPLY */\n*/* S SCANKEY:GET CONTROL VERB */\n*/* D (YES,,NO,%P11J2) IS IT END STMT? */\n*/* P SET LNKRG3 TO ADDR OF RDCARD1 */\n*/* R RETURN VIA LNKRG3 */\n*/*%P11J2: P SET LNKRG3 TO ADDR OF CONRTN */\n*/* N (,KEY01) DETERMINE OPERATION */\n*/*WTORTN: E SUBROUTINE */\n*/* P GET PARMLIST FOR DESIRED MSG */\n*/* P SET LEN,  RTE & DESCR CODES FOR THIS MSG */\n*/* L WRITE MSG TO OPERATOR */\n*/* R RETURN */\n*/*SCANKEY: E SUBROUTINE */\n*/* N SCAN FREE FORMAT CONTROL CARDS */\n*/* P INITIALIZE FOR START OF SCAN */\n*/* N ENTRY FOR CONTINUOUS SCAN */\n*/*SCANKEY1: P POINT TO BEGIN OF NEXT SCAN */\n*/*SCANKEY2: D (NO,SCANKEY3,YES,) CHAR BLANK? */\n*/* P INCREMENT POSITION POINTER */\n*/* D (YES,,NO,SCANKEY2) END OF CONTROL CARD? */\n*/* P SET UP BLANK INPUT DATA */\n*/* R RETURN */\n*/*SCANKEY3: N FOUND FIELD- LOOK FOR NEXT BLANK */\n*/* P SET BEGIN MARKER */\n*/*SCANKEY4: P INCREMENT POSITION POINTER */\n*/* P DECREMENT COUNTER */\n*/* D (YES,,NO,SCANKEY4) CHAR BLANK? */\n*/* P GET NO OF CHARS THIS PARM */\n*/* D (YES,,NO,%P12G4) WITHIN LEGAL SIZE? */\n*/* R RETURN */\n*/*%P12G4: P TRUNCATE */\n*/* R RETURN */\n*/*SCANKEY5: E SUBROUTINE */\n*/* N SCAN FOR MEMBER & CSECT NAMES */\n*/* P BLANK OUT MEMBER & CSECT NAME BUFFERS */\n*/* S SCANKEY1:SCAN FOR MEMBER NAME */\n*/* P SAVE MEMBER NAME */\n*/* S SCANKEY1:SCAN FOR CSECT NAME */\n*/* P SAVE CSECT NAME */\n*/* D (YES,NAME03C,NO,) WERE NAMES OVER 8 CHAR */\n*/* R RETURN */\n*/*SCAN: E SUBROUTINE */\n*/* N DECODES NUMERIC FIELDS ON CONTROL CARDS */\n*/*%P13B4: D (YES,,NO,%P13C4) CHAR BLANK? */\n*/* P INCREMENT POSITION POINTER */\n*/* D (YES,IGNORE,NO,%P13B4) REACHED END OF BUFFER? */\n*/*%P13C4: P CLEAR BUFFERS */\n*/*SCAN4: P SAVE START OF DATA FIELD */\n*/*SCAN1: D (YES,SCAN3,NO,) CHAR COMMA? */\n*/* D (YES,SCAN3,NO,) CHAR BLANK? */\n*/* P (,SCAN1) INCREMENT POSITION POINTER */\n*/*SCAN3: P GET NO OF CHARS SCANNED */\n*/* P SAVE THE DATA */\n*/* D (YES,SCAN5,NO,) END OF DATA YET? */\n*/* D (YES,,NO,%P13J3) BLANK FOLLOWING COMMA? */\n*/* N (,SCAN5) DISCARD THIS OPERAND */\n*/*%P13J3: P (,SCAN4) INCREMENT POSITION POINTER */\n*/*SCAN5: D (YES,DIGITERR,NO,) ODD NUM DIGITS? */\n*/* D (YES,,NO,IGNORE) WAS ORIGINAL INPUT IN HEX */\n*/* P TRANSLATE TO BINARY */\n*/* P SAVE START ADDR OF DATA */\n*/*SCAN6: P CONVERT TO HEX */\n*/* P INCREMENT TEMP & DATA BUF POINTERS */\n*/* D (YES,,NO,SCAN6) END OF DATA BLOCK? */\n*/* R RETURN */\n*/*DIGITERR: S SCANKEY:GET KEY WORD */\n*/* D (YES,DIGERR2,NO,) WAS IT A REP CARD? */\n*/* P TURN ON IGNOP SW TO IGNORE REPS */\n*/*DIGERR2: P POINT TO MSG AMA109I */\n*/* S WRITEO:PRINT ERROR MSG */\n*/* D (ON,,OFF,%P14H3) CONSW? */\n*/* S WTORTN:WRITE MSG TO CONSOLE */\n*/*%P14H3: P SET RETURN CODE 8 */\n*/* R RETURN VIA LNKRG3 */\n*/*OPENLIB: E SUBROUTINE */\n*/* D (YES,,NO,%P15C4) D.S. ALREADY OPEN? */\n*/* R RETURN */\n*/*%P15C4: L READ JFCB FOR LIB */\n*/* D (YES,,NO,RSRV) UPDATE TO VTOC? */\n*/* S UPVTRTN:ASK OPER TO UPDATE VTOC */\n*/* D (YES,,NO,NOF4MOD) IS IT OK WITH HIM? */\n*/*RSRV: P GET DEB ADDR FOR SYSLIB */\n*/* P SAVE UCB ADDR FROM DEB */\n*/* L RESERVE DEVICE WHERE SYSLIB RESIDES */\n*/* P TURN ON RSVSW- INDICATE RESV ISSUED */\n*/*OPEN2: L OPEN LIB FOR UPDATE */\n*/* R RETURN */\n*/*NOF4MOD: N DONT ALLOW INSP OR MODIF */\n*/* P TURN ON NAMEERR SW */\n*/* P POINT TO ERROR MSG AMA114I */\n*/* S WRITEO:PRINT ERROR MSG */\n*/* D (YES,,NO,%P16H2) CONSOLE OPTION IN EFFECT? */\n*/* S WTORTN:WRITE MSG TO CONSOLE */\n*/*%P16H2: P SET RETURN CODE 8 */\n*/* R RETURN VIA LNKRG3 */\n*/*RDDISK: E SUBROUTINE */\n*/* N XDAP READS FOR SPECIFIC RECORDS */\n*/* P GET MAX SIZE OF RECORD */\n*/* L XDAP TO READ RECORD */\n*/* L WAIT FOR COMPLETION OF READ */\n*/*ERRTST: D (YES,,NO,%P17F2) SUCCESSFUL COMPLETION? */\n*/* R RETURN */\n*/*%P17F2: N TEST TYPE OF ERROR */\n*/* D (YES,,NO,CLOSE2A) PERMANENT ERROR? */\n*/* D (YES,,NO,CLOSE2A) WRONG LENGTH RECORD? */\n*/* R RETURN */\n*/*CLOSE2A: P GET IOB ADDR */\n*/* L SYNADAF- ANALYZE PERM I/O ERROR */\n*/* P SAVE ADDR OF SYNAD WORK AREA */\n*/* P MOVE I/O ERR MSG TO MSG BUFFER */\n*/* S IOMSG:PRINT I/O ERROR MSG */\n*/* L SYNADRLS- RELEASE SYNADAF WORK AREAS */\n*/* P SET RETURN CODE 8 */\n*/* P TURN ON IGNORE OPER & NAMEERR SW */\n*/* R RETURN */\n*/*WRDISK: E SUBROUTINE */\n*/* N XDAP WRITES TO UPDATE SPECIFIC RECORDS */\n*/* P GET MAX SIZE OF RECORD */\n*/* P TURN ON SLI IN XDAP SUPPLIED CH PROG */\n*/* L XDAP TO WRITE RECORD */\n*/* L (,ERRTST) WAIT FOR COMPLETION OF WRITE */\n*/*UPVTRTN: E SUBROUTINE */\n*/* N MSG AMA117D TO OPER- PERM TO UPDATE VTOC */\n*/* P HOUSEKEEPING */\n*/* L EXTRACT ADDR OF TIOT FOR ACT TASK */\n*/* P MOVE JOBNAME FROM TIOT TO MSG BUF */\n*/* P INCREMENT TO FIRST DD ENTRY */\n*/*CHKLIB: D (YES,LIBUCB,NO,) DD ENTRY FOR SYSLIB? */\n*/* P (,CHKLIB) INCREMENT TO NEXT DD ENTRY */\n*/*LIBUCB: P GET POINTER TO SYSLIB UCB */\n*/* P MOVE VOLSER TO MSG BUF */\n*/*UNITNAME: P MOVE UNIT ADDR TO MSG BUF */\n*/* L WRITE MSG AMA117D TO OPERATOR */\n*/* L WAIT FOR HIS REPLY */\n*/* P BLANK OUT MSG AREA */\n*/* R RETURN */\n*/*IOMSG: E SUBROUTINE */\n*/* N PRINTS SYNADAF I/O ERROR MSG */\n*/* P INITIALIZE MSG BUF WITH SYNADAF ERROR INFO */\n*/* L PRINT MSG QSAM*/\n*/* L CHECK FOR COMPLETION OF WRITE */\n*/* L PRTOV- SPACE TO NEW PAGE IF NECESSARY */\n*/* D (NO,,YES,%P20G2) CONSOLE OPTION IN EFFECT? */\n*/* R RETURN */\n*/*%P20G2: L WRITE MSG TO OPERATOR */\n*/* R RETURN */\n*/*SETUP1: E SUBROUTINE */\n*/* N PREPARE FOR VERYIFY OR REP */\n*/* S SCAN:GET OFFSET */\n*/* P SAVE OFFSET */\n*/* S SCAN:GET PATCHES */\n*/* S OPENLIB:OPEN DATA SET FOR UPDATE IF NOT */\n*/* P POINT TO OFFSET INTO RECORD */\n*/* P SUBTRACT BASE VALUE IF ANY */\n*/* D (YES,NAME07,NO,) IS THIS A CSECT OPERATION? */\n*/* P CALCULATE END OF PATCH AREA */\n*/* D (YES,%P22B4,NO,) DOES IT EXCEED END OF RECORD? */\n*/* R RETURN */\n*/*%P22B4: P (,VERY1) POINT TO MSG AMA106I */\n*/*NAME07: N ENTER HERE AFTER REP CARD WITH NAME OP */\n*/* P SET PATCH ADDR */\n*/* P RESTORE START ADDR */\n*/* L POINT TO RECORD */\n*/* D (YES,NAME07A,NO,) MULT TEXT REC SW ON ? */\n*/* D (YES,NAME08,NO,) ONE RECORD SW SET ? */\n*/*NAME07B: S RDDSK4:READ CONTROL RECORD */\n*/* D (VEC1,NAME12B,VEC2,) RETURN VECTOR ? */\n*/*NAME08: P POINT TO PATCH ADDR IN CORE */\n*/* D (YES,DSERROR,NO,) PATCH ADDR < ADDR TXT REC */\n*/* P COMPUTE END ADDR OF TXT REC */\n*/* D (YES,NAME09,NO,) PATCH ADDR < END ADDR */\n*/* D (YES,NAME12B,NO,) ONE RECORD SW ON ? */\n*/*NAME08B: D (YES,NAME12B,NO,) END OF LOAD MODULE */\n*/* P SET LNKRG2 TO ADDR VECTOR1 */\n*/* N (,RDDSK3) SKIP THIS TXT, READ NEXT CONTROL */\n*/*NAME07A: S NAME01A:SET MODULE ATTRIBUTES */\n*/* D (VEC1,%P41F5,VEC2,%P41F3,VEC3,%P41G4) RETURN VECTOR  */\n*/*%P41F5: P (,%P41G4) NOP */\n*/*%P41F3: P NOP */\n*/*%P41G4: S RDDSK2:GET 1ST TXT REC */\n*/* P TURN OFF ONE RECORD INDIC IF ON */\n*/* L (,NAME08) POINT AT START OF TXT */\n*/*NAME09: S RDDSK2:GET TXT RECORD */\n*/* P GET TXT START ADDR */\n*/* P ADD NUM OF PATCH CHARS */\n*/* P TURN OFF OVERFLOW SW IF ON */\n*/* D (YES,NAME10,NO,) IS END PATCH IN REC */\n*/* D (YES,NAME12B,NO,) ONE RECORD SW ON */\n*/* P TURN ON OVERFLOW SW */\n*/* P DETERMINE NUM OF CHARS OVER */\n*/* P DETERMINE NUM OF PATCH CHARS IN THIS TXT */\n*/* P DECR BY ONE & SAVE */\n*/*NAME10: S CCHNOTE:SET UP CCHHR */\n*/* P COMPUTE OFFSET */\n*/* D (VER,NAME13,REP,) VERIFY OR REP */\n*/* D (NO,,YES,SPLIT) FIRST PASS SW ON? */\n*/* P TURN FIRST PASS SW ON */\n*/* S (,NAME10A) UNPATCH: FORMAT UNPATCH MESSAGE */\n*/*SPLIT: P RESET OFFSET INTO MESSAGE */\n*/* S UNPK: COMPLETE UNPATCH MESSAGE */\n*/*NAME10A: P SAVE OFFSET OF LAST DATA MOVED */\n*/* P MOVE THIS PART OF PATCH TO TXT */\n*/*NAME11: S WRDISK:UPDATE DISK */\n*/* P INDICATE MODIFICATION- MODIFY SW */\n*/*NAME12: D (YES,%P42H4,NO,) MORE PATCH- OVRFL? */\n*/*WRITEUN: D (NO,%P42H5,YES,) IS THIS A VERIFY OPERATION */\n*/* R RETURN VIA LNKRG3 */\n*/*%P42H5: S WRITE:PRINT MESSAGE */\n*/* P BLANK LAST 40 CHAR OF BUFFER */\n*/* P TURN OFF FIRST PASS SW */\n*/* R RETURN VIA LNKRG3 */\n*/*%P42H4: P (,NAME07B) UPDATE VARIABLES FOR REST OF PATCH */\n*/*NAME12B: P (,NAME14) POINT TO MSG AMA106I */\n*/*NAME13: D (YES,NAME12,NO,) DOES PATCH COMPARE */\n*/* P POINT TO MSG AMA104I */\n*/*NAME14: S WRITEO:PRINT ERROR MSG */\n*/* D (YES,,NO,%P43G2) CONSOLE OPT IN EFFECT */\n*/* S WTORTN:WRITE MSG TO CONSOLE */\n*/*%P43G2: P SET RETURN CODE 8 */\n*/* P (,DUMP01A) TURN ON IGNOP SW- IGNORE REPS */\n*/*DSERROR: P (,NAME14) POINT TO MSG AMA107I */\n*/*INSMDFY: E SUBROUTINE */\n*/* N UPDATE SSI TO INDICATE LOCAL MODIFY AFTER SUCCESSFUL REP */\n*/* D (YES,CKIDR,NO,) NAME OPT REP- MODIFY?*/\n*/* D (YES,%21A6,NO,) CCHHR REP OCCURR? */\n*/* R RETURN */\n*/*%21A6: L READ JFCB FOR LIB2 */\n*/* D (NO,MOVESER,YES,) IS UPDATE FOR VTOC */\n*/* P MAKE DSN 'FORMAT4.DSCB' */\n*/*MOVESER: P MOVE VOLSER TO MSG BUF */\n*/* P MOVE CCHHR TO MSG BUF */\n*/* P DETERMINE LENGTH OF DSN */\n*/* P MOVE DSN TO MSG BUF */\n*/* P MOVE ROUTER/DESCR CODES TO MSG BUF */\n*/* P MOVE MSG LEN TO MSG BUF */\n*/* L EXTRACT TIOT ADDRESS */\n*/* P MOVE JOBNAME TO MSG BUF */\n*/*WTO: L WRITE AMA121I TO CONSOLE */\n*/* P TURN OFF CCHHR UPDATE SW- MODFYREC */\n*/* R RETURN */\n*/*CKIDR: D (YES,,NO,INSM1) IDR UPDATE REQUIRED ? */\n*/* L POINT TO IDR- IDRTTR */\n*/* S RDDSK2:READ IDR RECORD */\n*/* P POSITION TO NEXT SPZAP ENTRY IN IDR */\n*/* L GET DATE */\n*/* P MOVE DATE TO IDR */\n*/* P MOVE CSECT ESDID TO IDR */\n*/* P MOVE IDR USER DATA TO IDR */\n*/* P PREPARE FOR DISK UPDATE- IDRFSEEK */\n*/* S WRDISK:UPDATE DISK */\n*/* P TURN OFF IDR UPDATE SW */\n*/*INSM1: P TURN OFF NAMEOP REP SW- MODIFY */\n*/*INSM1A: N INSPECT FOR A PDS REP HAVING OCCURRED */\n*/* S DIRREAD:GET DIR BLOCK WHICH SHOULD CONTAIN MEMBER */\n*/* P SAVE STOP ADDR OF BLOCK */\n*/* P POINT TO FIRST ENTRY */\n*/* P TURN ON NO-MEMBER SW */\n*/*INSM2: P GET LEN OF USER FIELD */\n*/* D (YES,INSM3,NO,) DO WE HAVE THE MEMBER WE WANT? */\n*/* P POINT TO NEXT ENTRY */\n*/* D (YES,,NO,INSM2) EXCEEDED LEN OF BLOCK? */\n*/* R RETURN */\n*/*INSM3: P TURN ON SSI MISSING SW */\n*/* P TURN OFF MISSING MEMBER SW */\n*/* D (NO,,YES,AOSPDS) WAS MODULE PRODUCED BY AOS LKED */\n*/* P CONVERT LEN OF USER ENTRY TO NUM OF BYTES */\n*/* D (YES,,NO,%P24G4) IS NUM <= 22? */\n*/* N USER FIELD CONTAINS NO SSI */\n*/* R RETURN */\n*/*%P24G4: D (YES,,NO,%P24H4) IS NUM = 30? */\n*/* N USER FIELD CONTAINS NO SSI */\n*/* R RETURN */\n*/*%P24H4: D (YES,,NO,%P24J4) IS NUM = 32? */\n*/* N USER FIELD CONTAINS NO SSI */\n*/* R RETURN */\n*/*%P24J4: D (YES,,NO,%P25A2) IS NUM = 40? */\n*/* N USER FIELD CONTAINS NO SSI */\n*/* R RETURN */\n*/*%P25A2: P POINT TO SSI BYTES */\n*/*INSM4: P TURN OFF NO-SSI SW */\n*/* D (YES,,NO,%P25D2) SSI OPERATION BEING PERFORMED ? */\n*/* R RETURN */\n*/*%P25D2: P TURN ON LOCAL MODIFY BITS */\n*/* S DIRWRITE:UPDATE DIRECTORY */\n*/* S SCANKEY:RESET POINTERS */\n*/* R RETURN */\n*/*AOSPDS: D (NO,,YES,%HASSSI) IS SSI PRESENT */\n*/* R RETURN */\n*/*%HASSSI: P SET SSI PTR TO END OF BASIC SECTION */\n*/* D (YES,,NO,NOSCTR) IS MEMBER SCATTER LOADABLE */\n*/* P ADD 8 TO SSI PTR */\n*/*NOSCTR: D (YES,,NO,NOALIAS) IS MEMBER NAME AN ALIAS */\n*/* P ADD 11 TO SSI PTR */\n*/*NOALIAS: P (,INSM4) PUT SSIPTR IN PROPER REGISTER */\n*/*WRITEO: E SUBROUTINE */\n*/* N PRINTS INPUT CARD OR ERROR MSGS */\n*/* P MOVE MSG TO MSG BUFFER */\n*/*WRITE1: P PAD REST OF BUFFER WITH BLANKS */\n*/*WRITE: L ISSUE WRITE- QSAM */\n*/* L CHECK FOR COMPLETION */\n*/* L SPACE TO NEW PAGE IF NECESSARY- PRTOV */\n*/* P BLANK OUT END OF BUFFER */\n*/* R RETURN VIA LNKRG1 */\n*/*RDCARD2: E SUBROUTINE */\n*/* N QSAM READS TO CARD READER */\n*/* L GET A CARD */\n*/* R RETURN */\n*/*DIRREAD: E SUBROUTINE */\n*/* N SIMULATES BLDL- READ SPECIFIC DIRECTORY BLOCK */\n*/* P MOVE IN TIC TO EXTENDED CH PROGM */\n*/* P MOVE IN READ AREA ADDRESS */\n*/* P GET DEB ADDR */\n*/* P SET SEEK ADDR FROM DEB IN 1ST CCW */\n*/*UPDATEIO: P SET ADDR IOB FOR EXCP */\n*/* N SEARCH FOR DIRECTORY, READ COUNT, */\n*/* N SEARCH ON KEY, READ APPR DIR BLOK */\n*/* L ISSUE SVC 0- EXCP */\n*/* L (,ERRTST) WAIT FOR COMPLETION */\n*/*DIRWRITE: E SUBROUTINE */\n*/* N SIMULATES STOW- UPDATE DIRECTORY BLOCK */\n*/* P EXTEND XDAP CH PROG WITH UPDATE CCW */\n*/* P MOVE IN WRITE AREA ADDR */\n*/* P (,UPDATEIO) SET SEARCH ARG */\n*/*DUMP01AA: E SUBROUTINE */\n*/* L POINT AT TEXT RECORD */\n*/*DUMP01: S WRITEO:SKIP A LINE */\n*/* S RDDSK2:READ TEXT RECORD */\n*/*DUMP01E: S CCHNOTE:SET UP CCHHR */\n*/* P MOVE HEADER TO MSG BUFFER */\n*/* P POINT TO DATA TO BE DUMPED */\n*/* P GET KEYLEN FROM DCB */\n*/* P ADD MAX SIZE OF RECORD */\n*/* P MINUS RESIDUAL = LEN OF DATA */\n*/* D (YES,DUMP01AC,NO,) MEMBER DUMP ONLY ? */\n*/* D (YES,,NO,DUMP01AB) ABSOLUTE DUMP ? */\n*/* P BLANK OUT CSECT LABEL FROM HEADER */\n*/*DUMP01AC: P BLANK OUT CSECT NAME FIELD FROM HEADER */\n*/* P SAVE LEN OF DATA TO BE DUMPED */\n*/*DUMP01AB: P COMPUTE STOP ADDR OF DATA */\n*/* P STORE NEW LEN */\n*/* P XLATE & MOVE REC ADDR TO MSG BUF */\n*/* P XLATE & MOVE REC LEN TO MSG BUF */\n*/* S WRITE:PRINT HEADER */\n*/* D (YES,,NO,%P30J4) WAS RECORD LEN ZERO ? */\n*/* R RETURN VIA LNKRG2 */\n*/*%P30J4: N DETERMINE OFFSET OF 1ST LINE OF DUMP */\n*/* P SUBTRACT BASE OFFSET FROM START ADDR */\n*/*DUMP02: S DUMPCOM1:INITIALIZE FOR DUMP */\n*/* P SAVE LOCATION OF LINE START- TBUF */\n*/* P SAVE OFFSET THIS LINE- TBUF */\n*/*DUMP02B: P INITIALIZE CHAR COUNTER TO 4 */\n*/*DUMP02C: P XLATE & MOVE 1 DATA BYTE TO 2 MSG BYTES */\n*/* P INCREMENT MSG BUF PTR BY 2 */\n*/* D (YES,DUMP08,NO,) END OF DATA ? */\n*/* D (YES,DUMP03B,NO,) TRANSLATE OPTION ? */\n*/*DUMP03A: P DECR CHAR COUNT BY 1 */\n*/* D (YES,,NO,DUMP02C) IS CHAR COUNT ZERO ?*/\n*/* D (YES,DUMP03,NO,) WORD COUNT = 5 ? */\n*/* P SPACE 3 BLANKS BETWEEN WORDS */\n*/* D (YES,,NO,DUMP02D) TRANSLATE OPTION ? */\n*/* P CHANGE SPACE BTWN WORDS TO 2 BLNKS */\n*/*DUMP02D: P DECR WORD COUNTER BY 1 */\n*/* D (YES,,NO,DUMP02B) IS WORD COUNT ZERO ? */\n*/* D (YES,GRAP1,NO,) TRANSLATE OPTION ? */\n*/* S WRITE:PRINT LINE */\n*/*DUMP02E: P ADD 32 TO OFFSET FIELD */\n*/* N (,DUMP02) PROCESS NEXT LINE */\n*/*DUMP03B: D (YES,,NO,DUMP03A) CHAR COUNT = 3 ? */\n*/* P INCR MSG BUF PTR BY 1 */\n*/* P DECR CHAR COUNT BY 1 */\n*/* D (YES,,NO,DUMP02C) IS CHAR COUNT ZERO ? */\n*/*DUMP03: P INCR MSG BUF PTR BY 5- MID PAGE */\n*/* P DECR WORD COUNTER BY 1 */\n*/* D (YES,,NO,DUMP02B) IS WORD COUNT ZERO ? */\n*/*DUMP08: D (YES,GRAP1,NO,) TRANSLATE OPTION ? */\n*/* S WRITE:PRINT LAST LINE */\n*/* P SET CONDITION CODE TO 3 IF END OF MOD */\n*/* R RETURN VIA LNKRG2 */\n*/*GRAP1: P SET LNKRG1 TO ADDR OF INSTR0 */\n*/* P SET PTR TO BEGIN OF DATA THIS LINE */\n*/*GRAP1B: P MOVE LEFT DELIM * TO MSG BUF */\n*/* P POINT TO TRANSLATE FIELD OF BUF */\n*/* P SET CHAR COUNTER = 16 */\n*/*GRAP2: D (YES,GRAP3,NO,) DATA BYTE = BLANK ? */\n*/* D (YES,GRAP5,NO,) DATA BYTE <= X'7F' ? */\n*/* P LOAD ADDR OF ALPHANUM XLATE TABLE */\n*/* D (YES,GRAP6,NO,) DATA BYTE >= C'A' ? */\n*/*GRAP3: P MOVE A PERIOD TO MSG BUF FOR THIS BYTE */\n*/*GRAP3B: P INCR DATA PTR */\n*/* D (YES,GRAP8,NO,) REACHED END DATA YET ? */\n*/* P INCR MSG BUF PTR */\n*/* P DECR CHAR COUNT BY 1 */\n*/* D (YES,,NO,GRAP2) CHAR COUNT = 0 ? */\n*/* P (,WRITE) MOVE RIGHT DELIM * TO MSG BUF */\n*/*GRAP5: P LOAD ADDR OF SPECIAL SYM XLATE TABLE */\n*/*GRAP6: P (,GRAP3B) MOVE & XLATE DATA BYTE TO MSG BUF */\n*/*GRAP8: D (YES,,NO,WRITE) DID WE XLATE OPCODS YET */\n*/* S WRITE:PRINT LINE */\n*/* P SET COND CODE 3 IF END OF MODULE */\n*/* R RETURN */\n*/*INSTR0: E SUBROUTINE */\n*/* N MNEMONIC XLATION PART OF DUMP01 RTN */\n*/* S DUMPCOM:INITIALIZATION */\n*/*INSTR1: P SET INSTR COUNTER = 2 */\n*/*INSTR2: P GET DATA BYTE- OPCODE */\n*/* P INCR TO NEXT DATA BYTE */\n*/* D (YES,INSTR5,NO,) END OF DATA ? */\n*/* P GET INDEX TO XLATE TABLE */\n*/* D (YES,TWOBYTES,NO,) LOOK AT 2ND BYTE ? */\n*/*TABCHK: D (YES,TRANS5,NO,) FIVE CHAR OPCODE ? */\n*/* D (YES,INSTR7,NO,) FOUR CHAR OPCODE ? */\n*/* N TWO CHAR OPCODE */\n*/* P POINT TO MNEMONIC IN TWO CHAR TABLE */\n*/* P MOVE MNEMONIC TO MSG BUF */\n*/*INSTR3: P INCR PAST HALFWORD */\n*/* D (YES,INSTR5,NO,) END OF DATA ? */\n*/* P INCR MSG BUF PTR BY 4 */\n*/* P DECR INSTR COUNTER */\n*/* D (YES,,NO,INSTR8) INSTR COUNTER = 0 ? */\n*/* D (YES,INSTR6,NO,) WORD COUNTER = 5 ? */\n*/* P SPACE 3 BETWEEN WORDS */\n*/* P DECR WORD COUNTER BY 1 */\n*/* D (YES,,NO,INSTR1) WORD COUNTER = 0 ? */\n*/*INSTR5: P SET DATA PTR BACK TO BEGIN OF LINE */\n*/* P INCR DATA PTR TO SECOND HALF OF LINE */\n*/* P (,GRAP1B) SET LNKRG1 TO ADDR OF DUMP02E */\n*/*INSTR7: P POINT TO MNEMONIC IN FOUR CHAR TABLE */\n*/* P (,INSTR3) MOVE MNEMONIC TO MSG BUF */\n*/*TRANS5: P POINT TO MNEMONIC IN FIVE CHAR TABLE */\n*/* N IS THIS THE 2ND HWORD OF A PAIR ? */\n*/* D (YES,MOVE5,NO,) IS INSTR COUNTER = 1 ? */\n*/* N BACK UP ONE POS IN MSG BUF */\n*/* P DECR MSG BUF PTR BY 1 */\n*/* P MOVE MNEMONIC TO MSG BUF */\n*/* P (,INSTR3) RESET MSG BUF PTR  +1 */\n*/*MOVE5: P (,INSTR3) MOVE MNEMONIC TO MSG BUF */\n*/*INSTR6: P INCR MSG BUF PTR BY 5- MID PAGE */\n*/* P DECR WORD COUNTER BY 1 */\n*/* D (YES,,NO,INSTR1) IS WORD COUNT = 0 ? */\n*/*INSTR8: P (,INSTR2) INCR MSG BUF PTR BY 1- SPACE BTWN HWORDS */\n*/*TWOBYTES: P GET 2ND BYTE OF INSTR */\n*/* P RESET DATA BUF PTR TO BEGIN OF OPCODE */\n*/* D (YES,,NO,BYTE29C) 1ST BYTE = X'B2' ? */\n*/* D (YES,DXRCK,NO,) 2ND BYTE TOO HIGH */\n*/* P GET INDEX TO B2 XLATE TABLE */\n*/*BYTE2EX: P (,TABCHK) INCR DATA BUF PTR BY 1 AGAIN */\n*/*DXRCK: D (NO,TOOHI,YES,BYTE2EX) DXR INSTRUCTION ? */\n*/*TOOHI: P (,BYTE2EX) NO MNEMONIC - ZERO INDEX */\n*/*BYTE29C: D (YES,,NO,BYTE29E) 1ST BYTE = X'9C' ? */\n*/* P (,BYTE2EX) GET INDEX TO 9C XLATE TABLE */\n*/*BYTE29E: D (YES,,NO,BYTE2XX) 1ST BYTE = X'9E' ? */\n*/* P (,BYTE2EX) GET INDEX TO 9E XLATE TABLE */\n*/*BYTE2XX: N NO MNEMONIC */\n*/* P (,BYTE2EX) ZERO INDEX */\n*/*DUMPCOM: E SUBROUTINE */\n*/* P GET START LOC OF LINE */\n*/*DUMPCOM1: N INITIALIZATION FOR DUMPING */\n*/* P BLANK MSG BUFFER */\n*/* P LOAD LOC OF MSG BUFFER */\n*/* P SET WORD COUNTER TO 8 */\n*/* R RETURN */\n*/*SETBLKSI: E SUBROUTINE */\n*/* N SETS SYSIN BLKSIZE TO 80 IF NOT PROVIDED */\n*/* P GET BLKSIZE FROM INPUT DCB */\n*/* D (YES,,NO,%P44D1) WAS BLKSIZE PROVIDED */\n*/* R RETURN TO OPEN */\n*/*%P44D1: P MOVE BLKSIZE OF 80 TO DCB */\n*/* R RETURN TO OPEN */\n*/*UNPATCH: E SUBROUTINE */\n*/* P MOVE UNPATCH MESSAGE TO BUFFER */\n*/*UNPK: P TRANSLATE DATA TO BE REPLACED */\n*/* R RETURN */\n*/*OPTCDCK: E SUBROUTINE */\n*/* N SUPPRESS OPTCD FROM SYSLIB DSCB */\n*/* R RETURN TO OPEN */\n*/*AMASPZAP: END */\nAMASPZAP CSECT\n*A472300-472420,535300-535420,578800-578920                     YA01766\n*A588700-588820,633020-633060                                   YA01766\n*C534300                                                        YA01767\n*A301000,316300,330300-331034,719100,724000                      Y02160\n*A783400-783520,803400,815400,892300-892480,898300-898420        Y02160\n*C778900-779400                                                  Y02160\n*C888300,888400,888520,888560,888592                             YM5257\n*A537000                                                         YM5531\n*A714300                                                         YM5532\n*C683700-685200,745800,746100,746800,750300,754800,755700,760500,YM5533\n*C761100                                                         YM5533\n*A685600-685740                                                  YM5533\n*D341800-341960,807100-807284                                    YM5534\n*C343500                                                         YM5534\n*A823300-823760                                                  YM5534\n*D418440-418460                                                  YM5148\n*A422400-423000,425500                                           YM5148\n*A421100,421140,576200-576220,600700,633100,638800,639400,642400 YM5146\n*A808300-809020                                                  YM5146\n*D848400,848700,896400896700,897000,897300,897600                YM5147\n*A848100-848320,848420-848640,848740,848840,896600,897100,897200,YM5147\n*A897700,897800                                                  YM5147\n*A318700,538200-539400,547500-548700,585300-589200,592800-594300,X01979\n*A599700-602700,753900-754800,765900-766800,79770                X01979\n*A578200,578300,705100-705248,767800,768400,775300,775400        X01979\n*C591300,703800,704200,767700,775800,777900,779100,780900,781200 X01979\n         SPACE 1\n***********************************************************************\n*                  REGISTER DEFINITIONS\n***********************************************************************\nRG0      EQU   0\nRG1      EQU   7\nRG2      EQU   2\nRG3      EQU   3\nRG4      EQU   4\nRG5      EQU   5\nRG6      EQU   6\nWK1      EQU   RG1\nWK2      EQU   RG2\nWK3      EQU   RG3\nWK4      EQU   RG4\nWK5      EQU   RG5\nWK6      EQU   RG6\nWK7      EQU   1                        MISC REGISTER FOR DUMP ROUTINE\nR0       EQU   0                                                 Y02160\nR1       EQU   1\nLNKRG1   EQU   8\nLNKRG2   EQU   9\nLNKRG3   EQU   13\nR13      EQU   13\nBASREG3  EQU   10                       RDAREA1 BASE REGISTER\nBASREG2  EQU   11\nBASREG   EQU   12\nR14      EQU   14\nR15      EQU   15\n*******************\n*                  EQUATES\n*******************\nOPENED   EQU   X'10'                    DCB OPENED BIT\nOPENBIT  EQU   48                       OFFSET FOR OPEN BIT\nMULTXT   EQU   X'08'                    NOT EDITABLE\nMODTTR   EQU   8             .(PDS-DIRECTORY) TTR OF 1ST RECD. @ZA19029\nTXTTTR   EQU   14            .(PDS-DIRECTORY) TTR OF 1ST TXT.  @ZA19029\nATTR     EQU   22                       PDS ATTRIBUTE FIELD\nAOS      EQU   X'80'                    AOS LKED PDS FLAG        Y01979\nSSIB     EQU   X'10'                    SSI PDS FLAG BIT         Y01979\nSCTR     EQU   X'04'                    PDS SCTR SECTION FLAG    Y01979\nALIAS    EQU   X'80'                    PDS ALIAS FLAG BIT       Y01979\nLNGTH    EQU   27                       POD LENGTH OF TEXT\nORGIN    EQU   32                       POD LOC FOR TEST ORIGIN\nNEXTS    EQU   X'10'                    NO. OF EXTENTS IN DATA SET\nDEBEXT   EQU   X'20'                    EXTENT FIELD IN DEB\nSTEXT    EQU   X'26'                    START ADDR IN EXTENT\nENDEXT   EQU   X'0A'                    END ADDR IN EXTENT\nCOMMA    EQU   X'6B'\nBLANK    EQU   X'40'\nAST      EQU   X'5C'                    COMMENT KEY WORK\nSSIMDFY  EQU   X'01'                    OFFSET IN SSI BYTES FOR MODIFY\nSSIOP    EQU   X'80'                    SSI ACTION FLAG\nNAMEIDR  EQU   X'40'                    IDR CARD AFTER NAME CARD S21016\nIDRRD    EQU   X'20'                    LOAD MOD HAS IDR RECORDS S21016\nMODFYREC EQU   X'10'                    CCHHR REP HAS BEEN DONE  S21016\nNOSSI    EQU   X'08'                    SSI FIELD MISSING FLAG\nNOMEM    EQU   X'04'                    NO MEMBER FOUND FLAG\nLMREAD   EQU   X'02'                    NEXT LOAD MOD REC READ   S21016\nNENOIDR  EQU   X'01'                    MODULE IS NE SO NO IDR   S21016\nMODIFY   EQU   X'01'                    REP ACTION FLAG\nTRAN     EQU   X'02'                    TRANSLATE DUMP\nFIRSTPCH EQU   X'10'                    UNPATCH FIRST PASS SW    X01979\nPSIND    EQU   X'80'                    ON IF DUMP IS OF A SAM D.S.\nMEMDMP   EQU   X'08'                    MEMBER DUMP OF DATA SDT\nMULREC   EQU   X'04'                    MORE THAN ONE TEXT REC\nONEREC   EQU   X'01'                    INDICATOR FOR ONE RECORD MEM\nNAMEOP   EQU   X'02'                    OPERATION USING NAME CARD\nIGNOP    EQU   X'04'                    VERIFY OPERATION NEGATIVE\nVERYOP   EQU   X'08'                    VERIFY OPTION IN PROGRESS\nOVFLOW   EQU   X'10'                    OVERFLOW PATCH\nENDMOD   EQU   X'20'                    END OF MODULE RECORD\nNAMEERR  EQU   X'40'                    ERROR IN NAME OR CCHHR OF.\nBLKSZE   EQU   X'3E'                    DCB BLKSIZE OFFSET\nKEYLEN   EQU   16                       DCB KEYLENGTH OFFSET     A48718\nDDNAM    EQU   X'28'                                             Y02160\nMAK1     EQU   X'01'                    BYTE UPDATE\nCMD      EQU   31                       OFFSET IN XDAP MACRO     S21995\nRSVON    EQU   X'FF'\nDS1DSORG EQU   82-44                    DISPLACEMENT OF DSORG IN F1DSCB\nPO       EQU   X'02'                    DSORG FOR PARTITIONED\nPS       EQU   X'40'                    DSORG FOR SEQUENTIAL\nOVER8    EQU   X'08'                    NAME OVER 8 CHAR         A48705\nOPTCD    EQU   52                       OPTCD OFFSET INTO LIB2   A49131\n***********************************************************************\n*        THE FOLLOWING ARE INDEX VALUES FOR BRANCHING TO I/O CSCET\n***********************************************************************\nARDCARD2 EQU   0                                                 S21995\nACLOSE1  EQU   4                                                 S21995\nAWRITEA  EQU   8                                                 S21995\nAWRITE0A EQU   12                                                S21995\nADIRREAD EQU   16                                                S21995\nADIRWRIT EQU   20                                                S21995\nARDDSK2  EQU   24                                                S21995\nAOPENLIB EQU   28                                                S21995\nARDDISK  EQU   32                                                S21995\nAWRDISK  EQU   36                                                S21995\nAWTO     EQU   40                                                S21995\nACLOSE2  EQU   44                                                S21995\nAEOD     EQU   48                                                S21995\nAINSMDFY EQU   52                                                X01979\nAINSM1A  EQU   56                                                X01979\nACLOSE4  EQU   60                      .FOR PARM-ERR EXIT.     @ZA06024\nACLOSE5  EQU   64                      .FOR INVAL-RECD EXIT.   @ZA09673\n***********************************************************************\n*        THE FOLLOWING ARE INDEX VALUES FOR BRANCHING TO DUMP CSECT\n***********************************************************************\nADMP1AA  EQU   0                                                 S21995\nADMP01   EQU   4                                                 S21995\nADMP1E   EQU   8                                                 S21995\nADMP1AB  EQU   12                                                S21995\n  EJECT\n***********************************************************************\n         SAVE  (14,12)\n         BALR  BASREG,0\n         USING *,BASREG\n         USING RDAREA1,BASREG3\nBEGIN    L     BASREG2,ACONSTS                                   S21995\n         USING AMASZCON,BASREG2                                  S21995\n         ST    R13,REGSAVE+4\n         LR    WK6,R13\n         LA    R13,REGSAVE\n         ST    R13,8(WK6)\n         B     ARROND\nIDENT    DC    CL8'REL/03.7'                                   @ZA09683\nACONSTS  DC    V(AMASZCON)             .BASE FOR CONSTS CSECT. @ZA02788\n* TEST FOR PARAMETER SPECIFICATIONS.                           @ZA06024\nARROND   LTR   R1,R1                                           @ZA06024\n         BZ    OPENUP                  .B IF NO PARAMETERS.    @ZA06024\n         L     WK1,0(R1)               .PARAM-LIST POINTER.    @ZA06024\n         LA    WK1,0(WK1)              .DROP HIGH BYTE.        @ZA06024\n         LTR   WK1,WK1                                         @ZA06024\n         BZ    ALTDDNAM                .B IF ADDR-PART ZERO.   @ZA06024\n         LH    WK2,0(WK1)              .FIRST COUNT FIELD.     @ZA06024\n         LTR   WK2,WK2                                         @ZA06024\n         BZ    ALTDDNAM                .B OF ZERO (DYNAM ONLY) @ZA06024\n* TEST FOR PARAM TO IGNORE IDR-FULL CONDITION.                 @ZA06024\n         CLC   2(ZPRM0LEN,WK1),PARM0STR .TEST PARAM VALUE.     @ZA06024\n         BE    IGNIDRFL                .B IF CORRECT.          @ZA06024\n* INCORRECT PARAMETER VALUE. SET FLAG FOR MSG AFTER OPEN.      @ZA06024\n         OI    PARMBITS,QPARMERR       .SET PARM-ERR FLAG.     @ZA06024\n         B     ALTDDNAM                                        @ZA06024\n* OPTION TO OVERRIDE IDR-FULL INHIBITION ON CSECT 'REP'S.      @ZA06024\nIGNIDRFL OI    PARMBITS,QIGNIDRF       .SET BIT FOR OPTION.    @ZA06024\nALTDDNAM TM    0(R1),X'80'             .ELSE TEST FOR ALT DD.  @ZA06024\n         BO    OPENUP                  .B IF NONE.             @ZA06024\n* ALTERNATE DDNAMES SPECIFIED (SECND PARAM LIST OF DYNAM INV). @ZA06024\n         L     R1,4(R1)          IF 2ND WORD OF PARM LIST IS     Y02160\n         LTR   R1,R1               0, THEN NO DDNAMES            Y02160\n         BZ    OPENUP                                            Y02160\n         LH    WK1,0(R1)         IF LENGTH IS LT 25, THEN        Y02160\n         CH    WK1,TWENTY4         NO SPZAP DDNAMES              Y02160\n         BNH   OPENUP                                            Y02160\n         CLC   24+2(8,R1),ZERO   IF DDNAME IS HEX 00, THEN       Y02160\n         BE    SYSINTST          DEFAULT SYSLIB DD TO SYSLIB     Y02160\n         MVC   LIB2+DDNAM(8),24+2(R1) ELSE, MOVE DDNAME INTO     Y02160\n         MVC   LIB+DDNAM(8),24+2(R1)  LIB2 AND LIB DCBS          Y02160\n         MVC   SYSLIB(8),24+2(R1)      .ALSO FOR VTOC UPDATE.  @ZA04271\nSYSINTST CH    WK1,THIRTY2       IF LENGTH IS LT 33, THEN        Y02160\n         BNH   OPENUP              NO MORE SPZAP DDNAMES         Y02160\n         CLC   32+2(8,R1),ZERO   IF DDNAME IS HEX 00, THEN       Y02160\n         BE    SYSPNTST          DEFAULT SYSIN TO SYSIN          Y02160\n         MVC   INPUT+DDNAM(8),32+2(R1) ELSE, MOVE DDN TO INPUT   Y02160\nSYSPNTST CH    WK1,FOURTY        IF LENGTH IS LT 41, THEN        Y02160\n         BNH   OPENUP              NO MORE SPZAP DDNAMES         Y02160\n         CLC   40+2(8,R1),ZERO   IF DDNAME IS HEX 00, THEN       Y02160\n         BE    OPENUP              DEFAULT SYSPRINT TO SYSPRINT  Y02160\n         MVC   OUTPUT+DDNAM(8),40+2(R1) ELSE, MOVE DDN TO OUTPUT Y02160\n         DROP  BASREG                                          @ZA06024\nOPENUP   BALR  BASREG,0             ***.(NEW ADDRESS BASE).*** @ZA06024\n         USING *,BASREG                                        @ZA06024\nZAPBASE2 DS    0H                                              @ZA09678\n         OPEN (INPUT,(INPUT),OUTPUT,(OUTPUT))                  @ZA06024\n         RDJFCB LIB2\n         LA    RG4,JFCBAREA             ADDRESS OF JFCB\n         CLC   0(12,RG4),F4DSCB         JFCB FOR FORMAT 4 REQUEST\n         BC    7,GETDSCB           NO, GO CHECK FOR TRKOVFL\n         MVC   0(44,RG4),DSCBDS         MOVE IN 12-9-4 PUNCHES\n         MVC    102(2,RG4),F4BLKSZ      MOVE IN NON-0 BLKSIZE    XM5390\n         OPEN  (LIB2,(INPUT)),TYPE=J\n         BC    15,CKOPEN                CHECK RESULTS OF OPEN\n         SPACE 1\n***********************************************************************\n* THIS IS AN OPEN EXIT ROUTINE TO INVALIDATE THE OPTCD FROM THE DSCB\n***********************************************************************\nOPTCDCK  MVI   LIB2+OPTCD,X'00'    SUPPRESS OPTCD                A49131\n         BR    R14                 RETURN TO OPEN                A49131\n         SPACE 1\n*******************\n*\n*  THE FOLLOWING CODE CHECKS IF THE SYSLIB DATA SET HAS TRACK OVERFLOW\n*  RECORDS. IF THERE ARE OVERFLOW RECORDS, THE RECFM FIELD IN THE DCB\n*  IS SET TO INDICATE TRKIVFL BEFORE OPENING THE DATA SET. TRACK OVER-\n*  FLOW DATA SETS ARE SUPPORTED ONLY FOR DUMP OPERATIONS (I.E. ABSDUMP,\n*  AND DUMP STATEMENTS).\n*\n*******************\nGETDSCB  MVC   JFCBAREA+44(6),JFCBAREA+118   MOVE VOL SER\n         ST    RG4,OBLIST+4        PUT ADDRESS OF DSNAME IN PARMLST\n         LA    RG4,JFCBAREA+44     GET ADDRESS OF VOL SER\n         ST    RG4,OBLIST+8        PUT ADDRESS OF VOL SER IN PARMLST\n         LA    RG4,JFCBAREA+52     GET ADDRESS OF WRKAREA\n         ST    RG4,OBLIST+12       PUT ADDRESS IN PARMLST\n         OBTAIN OBLIST             GET THE FMT1 DSCB\n         TM    84-44(RG4),X'20'    DOES RECFM INDICATE TRKOVFL\n         BNO   OPEN1               NO, OPEN SYSLIB\n         OI    LIB2+36,X'20'       SET TRKOVFL BIT IN DCBRECFM\n*******************\n         SPACE 1\nOPEN1    OPEN  (LIB2,(INPUT))\nCKOPEN   LH    RG1,LIB2+BLKSZE          GET BLKSIZE FROM DCB\n         LTR   RG1,RG1                 .TEST FOR ZERO.         @ZA02777\n         BNZ   CKOPEN2                 .B IF BLKSIZE IN DCB.   @ZA02777\n         DEVTYPE SYSLIB,DEVBUF,DEVTAB                          @ZA02777\n         LH    RG1,TRKSIZE             .ELSE                   @ZA02777\n         STH   RG1,LIB2+BLKSZE         . SET TO TRACK SIZE.    @ZA02777\nCKOPEN2  LA    RG2,X'0C00'             .MIN DASD BLOCKSIZE.    @ZA02777\n         CR    RG2,RG1                  IS SPEC LARGER\n         BC    4,NRMREC                 SPEC LARGER-SKIP\n         LR    RG1,RG2                  USE LARGEST\nNRMREC   AR    RG1,RG2\n         N     RG1,CLER                 REG. POSITIVE\n         LR    0,RG1                    INPUT REGISTER FOR GETMAIN\n         SR    RG1,RG1                  CLEAR REGISTER           A48718\n         IC    RG1,LIB2+KEYLEN          GET KEYLENGTH            A48718\n         AR    RG0,RG1                  INCREASE GETMAIN STORAGE A48718\n         ST    RG0,SIZE                .STORE BUFFER SIZE.     @ZM40094\n         LA    R1,8                    .EXT FOR UNPK BEY BUFF  @ZM40094\n         AR    R0,R1                   . IN CASE BUFF FILLED.  @ZM40094\n         GETMAIN     R,LV=(0)\n         L     R15,AIORTNS             SET ADDRESS OF IORTN      S21995\n         ST    1,RDAREA                 SAVE START OF READ IN AREA\n         TM    OUTPUT+OPENBIT,OPENED    OUTPUT DCB\n         LA    R1,AWTO                  MSG PRT. ON CONSOLE      S21995\n         BCR   8,R15                                             S21995\n         BAL   LNKRG1,WRITE             PRINT OUT SUPERZAP MESSAGE\n         MVI   CDBUF-1,X'40'            SET FOR NORMAL SKIP\n         TM    PARMBITS,QPARMERR        .TEST PARM-ERR FLAG.   @ZA06024\n         BZ    NOPARMER                 .B IF NO PARM ERR.     @ZA06024\n         MVC   RETCODE(1),RETCOD12      .SET RETURN CODE.      @ZA06024\n         LA    RG5,MSGEPARM             .SELECT ERROR MSG.     @ZA06024\n         LA    R1,ACLOSE4               .SELECT EXIT ADDR.     @ZA06024\n         BR    R15                      .GO TO 'IOR' CSECT.    @ZA06024\n* SYSPRINT OPENED AND NO PARAMETER ERROR.                      @ZA06024\nNOPARMER LA    RG5,INERR                .ADDR NO-SYSIN MSG.    @ZA06024\n         TM    INPUT+OPENBIT,OPENED     INPUT DCB\n         LA    R1,ACLOSE2               NOT OPENED-EXIT          S21995\n         BCR   8,R15                                             S21995\n         TM    LIB2+OPENBIT,OPENED        LIB 2 DCB\n         LA    RG5,MSGNOLIB            .NO-SYSLIB MESSAGE.     @ZA06023\n         LA    R1,ACLOSE2               BC IF NOT OPENED         S21995\n         BCR   8,R15                                             S21995\n         LA    LNKRG3,RDCARD1           SET RETURN ADDRESS\nRDCARD   NI    CTLBTE,X'FF'-IGNOP       RESET IGNORE OP\nRDCARD1  MVI   CONSW,X'00'              CLEAR CONSOLE SWITCH\n         MVI   DMPSW,X'00'             .RESET DUMP INDICATOR.  @ZA26077\n         LA    R1,ARDCARD2           GET CARD                    S21995\n         BALR  R14,R15                                           S21995\n         L     BASREG3,ACCISCAN        .ADDR INIT-SCAN RTNE.   @ZA17658\n         BALR  LNKRG1,BASREG3          .TEST FOR IMMED PRINT.  @ZA17658\n*        (RETURN WITH KEYWORD LOCATED BY 'SCANKEY').           @ZA00409\n         CLC   0(7,RG1),CONSOLE         IS CONSOLE TO BE USED\n         BC    8,CONRTN                 YES-GO WTO\nKEY01    CLI   0(RG1),AST               COMMENT CARD\n         BCR   8,LNKRG3                 YES-GET NEXT CARD\n         CLC   0(8,RG1),CHECKSUM                               @ZA17660\n         BE    CHSUMRTN                .B IF 'CHECKSUM' STMT.  @ZA17660\n         L     BASREG3,RDAREA           SET READ AREA BASE\n         XC    STARTINC(4),STARTINC     CLEAR IMBEDDED OFFSET\n         TM    CTLBTE,NAMEERR           CAN VERIFY BE PERFORMED\n         BC    1,KEY03                  NO-SKIP\n         CLC   0(6,RG1),SSI              SSI CARD\n         BC    8,SSIRTN\n         TM    CTLBTE,IGNOP             CHECK FOR PREV.VERIFY ERROR\n         BC    1,KEY02                  FLAG SET-SKIP REP CHECK\n         CLC   0(3,RG1),REP\n         BC    8,REPRTN                 REPCARD\nKEY02    CLC   0(3,RG1),VERIFY\n         BC    8,VERYRTN                VERIFY OPTION\n         CLC   0(7,RG1),IDRDATAC        IDR CARD                 S21016\n         BE    IDRRTN                                            S21016\n         LA    R1,AINSMDFY              GET INDEX                X01979\n         BALR  R14,R15                  INSPECT FOR PROG MODIFY  X01979\n         BAL   LNKRG1,SCANKEY           RESET POINTERS\nKEY03    CLC   0(5,RG1),CCHHR           ABSOLUTE UPDATE\n         BC    8,CCHHRTN                ABSOLUTE UPDATE\n         CLC   0(4,RG1),NAME\n         BC    8,NAMERTN                CSECT UPDATE\n         CLC   0(4,RG1),BASEO\n         BC    8,BASERTN                BASE OFFSET\n         CLC   0(4,RG1),DUMP            DUMP DISK\n         BC    8,DUMPRTN                DUMP DISK\n         CLC   0(7,RG1),ABSDUMP         ABSOLUTE DUMP CARD\n         BC    8,ABDMPRTN               YES-DUMP RECORDS\n         CLC   0(3,RG1),SLAST           END OF INPUT\n         BC    7,IGNORE                 NO-IGNORE\n         LA    R1,AINSMDFY              GET INDEX                X01979\n         BALR  R14,R15                  INSPECT FOR PROG MODIFY  X01979\n         LA    R1,AEOD                 YES-END                   S21995\n         BR    R15                                               S21995\n         SPACE 1\nIGNORE   L     RG5,AMSG105I            .SELECT MESSAGE.        @ZA17658\nIGNORE2  BAL   LNKRG1,WRITE0            PRINT OUT MESSAGE\n         MVC   RETCODE(1),RETCOD08     .INDIC SPZAP-INP ERROR. @ZA06023\n         OI    CTLBTE,IGNOP             IGNORE ANY FOLLOWING REPS\n         BCR   15,LNKRG3                GET NEXT CARD\n         SPACE 1\n***********************************************************************\n* THIS SUBROUTINE READS AMASPZAP CONTROL STATEMENTS FROM THE CONSOLE\n*******************\nCONRTN   XC    WTOECB(4),WTOECB         CLEAR ECB\n         MVI   DMPSW,X'00'             .RESET DUMP INDICATOR.  @ZA26077\n         MVI   CDBUF,C' '               CLEAR INPUT BUFFER\n         MVC   CDBUF+1(79),CDBUF\n         ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         WTOR  'AMA116A ENTER AMASPZAP CONTROL STATEMENT OR END',CDBUF,X\n               80,WTOECB,ROUTCDE=1,DESC=2\n         WAIT  ECB=WTOECB\n         L     R15,AIORTNS             RESET R15                 S21995\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\n         OC    CDBUF(40),BLANKS    INSURE CAPITAL LETTERS ARE USED\n         OC    CDBUF+40(40),BLANKS\n         MVI   CONSW,X'FF'              SET CONSOLE SWITCH\n         L     BASREG3,ACCISCAN        .ADDR INIT-SCAN RTNE.   @ZA17658\n         BALR  LNKRG1,BASREG3          .TEST FOR IMMED PRINT.  @ZA17658\n*        (RETURN WITH KEYWORD LOCATED BY 'SCANKEY').           @ZA00409\n         CLC   0(3,RG1),END             END OF CONSOLE INPUT\n         LA    LNKRG3,RDCARD1\n         BC    8,RDCARD1                YES-GET NEXT CARD FROM RDR\n         LA    LNKRG3,CONRTN            SET RETURN ADDRESS\n         BC    15,KEY01                 GO CHECK KEYWORD\n         SPACE 2\nWTORTN   LA    WK7,PREFIX          GET PARMLIST FOR WTO\n         MVC   CDBUF+40(4),DESCR   MOVE RTE CODE & DESCR INTO WTO BUF\n         MVC   PREFIX(2),ERRMGLNG  MOVE IN LENGTH OF WTO MSG\n         ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         WTO   MF=(E,(1))\n         L     R15,AIORTNS             RESET R15                 S21995\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\n         BR    LNKRG1                  .RETURN TO CALLER.      @ZA17658\n         SPACE 4\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE SCANS CONTROL CARDS WHICH ARE FREE FORMAT\n* SCAN UNTIL FIRST CHAR IS FOUND\n*******************\nSCANKEY  LA    RG3,CDBUF                INIT START OF SCAN\n         LA    RG2,72                    MAX SCAN LENGTH       @YA02260\nSCANKEY1 LR    RG1,RG3                  ENTRY FOR CONTIN.SCAN\nSCANKEY2 CLI   0(RG1),BLANK             BLANK\n* FIRST CHAR ON CARD NOT FOUND\n         BC    7,SCANKEY3               NO-SCAN TO NXT BLANK\n         LA    RG1,1(RG1)               INC CHAR POS.\n         BCT   RG2,SCANKEY2             DECR.ALLOWABLE\n         LA    RG1,BLANKS               SET UP BLANK INPUT DATA\n         LA    RG4,7                    CHAR-1\n         LA    RG3,BLANKS+8\n         BCR   15,LNKRG1                RETURN\n         SPACE 1\n* SCAN   UNTIL FIRST BLANK IS FOUND\nSCANKEY3 LR    RG3,RG1\nSCANKEY4 LA    RG3,1(RG3)               INC TO NEXT CHAR\n         BCTR  RG2,0                    DECR. MAX\n         CLI   0(RG3),BLANK             BLANK\n         BC    7,SCANKEY4               NO-CONTINUE\n* FOUND FIRST BLANK AFTER PARAMETER\n         LR    RG4,RG3                  PASS TO WK REG\n         SR    RG4,RG1                  GET NO OF CHAR.\n         BCTR  RG4,0                    DEC COUNT\n         CH    RG4,SEVEN\n         BCR   8+4,LNKRG1               OKAY-RETURN\n         LA    RG4,7                    SET AS MAX\n         OI    SCANSW,OVER8             INDICATE OVER 8 CHAR.    A48705\n         BCR   15,LNKRG1                RETURN\n         SPACE 1\n*  SCAN FOR MEMBER NAME AND CSECT NAME\n         SPACE 1\nSCANKEY5 MVC   MEMNAME(8),BLANKS        CLEAR KEY WORDS\n         MVC   CSECT(8),BLANKS\n         NI    SCANSW,X'FF'-OVER8       RESET OVER 8 CHAR SW     A48705\n         BAL   LNKRG1,SCANKEY1          TO GET MEMBER NAME\n         EX    RG4,SAVE2                SAVE MEMBER NAME\n         BAL   LNKRG1,SCANKEY1          TO GET CSECT NAME\n         EX    RG4,SAVE3                SAVE CSECT NAME\n         TM    SCANSW,OVER8             WAS NAME TOO BIG         A48705\n         BCR   8,LNKRG2                 RETURN IF BOTH NAMES OK  A48705\n         B     NAME03C                  GO SET UP TO PRINT MSG   A48705\n         SPACE 1\nSAVE2    MVC   MEMNAME(1),0(RG1)\nSAVE3    MVC   CSECT(1),0(RG1)\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE DECODE NUMERIC FIELDS ON CONTROL CARDS\n*******************\nSCAN2    LA    RG1,1(RG1)               ADVANCE PAST BLANK\n         C     RG1,CDBUFEND             ARE WE AT END OF BUFFER  A36172\n         BNL   IGNORE                   YES - INVALID CARD       A36172\nSCAN     CLI   0(RG1),BLANK             IS THIS CHAR BLANK\n         BC    8,SCAN2                  YES- ADVANCE\n         MVI   TBUF,C'1'               INIT TBUF TO X'F1'        A43687\n         MVC   TBUF+1(71),TBUF   FOR TR TABLES ON HEX TEST       A43687\n         LA    RG4,TBUF                 INIT STORAGE ADDRESS\nSCAN4    LR    RG2,RG1                  START OF DATA FIELD\nSCAN1    CLI   0(RG1),COMMA             DELIMITER\n         BC    8,SCAN3                  YES-SAVE TEMP\n         CLI   0(RG1),BLANK             END OF DATA\n         BC    8,SCAN3                  YES-SAVE AND EXIT\n         LA    RG1,1(RG1)               NO-INC PTR\n         BC    15,SCAN1                 CONTINUE\n         SPACE 1\nSCAN3    LR    RG5,RG1                  TURN TO WK REG\n         SR    RG5,RG2                  GET NO OF CHAR SCANNED\n         BZ    SCAN3A                   SKIP MOVE IF ZERO         M2816\n         BCTR  RG5,0                    DECR. BY 1\n         EX    RG5,SAVE                 STORE IN TEMP BUF\nSCAN3A   CLI   0(RG1),BLANK             EXIT ON BLANK             M2816\n         BC    8,SCAN5                  YES-RIGHT JUSTIFY\n         CLI   1(RG1),BLANK             BLANK FLOOWING COMMA\n         BC    8,SCAN5                  YES, DISCARD\n         LA    RG1,1(RG1)               INC CDBUF PTR\n         LTR   RG5,RG5                  IF MULTIPLE COMMAS     @AZ30821\n         BZ    IGNORE                   INVALID CARD           @AZ30821\n         LA    RG4,1(RG5,RG4)           ADVANCE TEMP BUFFER\n         BC    15,SCAN4                 CONTINUE\n         SPACE 1\nSCAN5    AR    RG4,RG5                  LAST POSITION TEMP-1\n         S     RG4,CON1                 GET NO OF CHAR\n         LR    RG2,RG4                  COPY REGISTER\n         SRL   RG2,1                    DIVIDE BY 2\n         SLL   RG2,1                    MULTIPLY BY 2\n         CR    RG4,RG2                  COMPARE WITH ORIGNIAL\n         BC    7,DIGITERR               PRINT MSG\n         SRL   RG4,1                    DIVIDE BY 2\n         MVC   DBUF(72),TBUF           SAVE ORIGINAL HEX INPUT   A43687\n         NC    TBUF(72),CON2           NORMALIZE FOR TRANSLATE   A43687\n         TR    TBUF(72),TRANTBL        TRANSLATE TO BINARY       A43687\n         TR    TBUF(72),TRANTBL2-X'F0'  RETRANSLATE TO HEX       A43687\n         CLC   DBUF(72),TBUF           SAME AS ORIGINAL          A43687\n         BNE   IGNORE                  NO-IGNORE THIS CARD       A43687\n         XC    DBUF(72),DBUF           YES-CLEAR BUFFER          A43687\n         NC    TBUF(72),CON2            NORMALIZE FOR TRANSLATE\n         TR    TBUF(72),TRANTBL         TRANSLATE TO BINARY\n         LA    RG2,TBUF                 POINTER TO TEMP START\n         LA    RG5,DBUFEND              DATA BUFFER END\n         SR    RG5,RG4                  START OF SAVE DATA\n         LR    RG6,RG5                  SAVE START ADDR OF DATA\nSCAN6    PACK  0(7,RG5),0(13,RG2)       CONVERT TO HEX\n         LA    RG5,6(RG5)               INC DATA STG\n         LA    RG2,12(RG2)              INC TEMP STG\n         CL    RG5,CON3                 END OF DATA BLOCK\n         BC    4,SCAN6                  CONTINUE IF NOT AT END\n* ADD TO CHECKSUM.                                             @ZA17660\n         L     RG2,CHSUMACC            .PREV CHECKSUM VALUE.   @ZA17660\n         LR    RG5,RG6                 .ADDR FIRST DIGIT-PAIR. @ZA17660\n         LH    R1,CHSUMSLL             .PREV SHIFT AMOUNT.     @ZA17660\nSCAN7    SH    R1,EIGHT                .DECR BY ONE BYTE.      @ZA17660\n         BNM   SCAN8                   .B IF NOT NEGATIVE.     @ZA17660\n         LH    R1,TWENTY4              .ELSE SET HIGH BYTE.    @ZA17660\nSCAN8    SR    R15,R15                 .CLEAR DIGIT-PAIR REG.  @ZA17660\n         IC    R15,0(RG5)              .LOAD DIGIT-PAIR.       @ZA17660\n         SLL   R15,0(R1)               .SHIFT TO PROPER BYTE.  @ZA17660\n         AR    RG2,R15                 .ADD INTO CHECKSUM.     @ZA17660\n         LA    RG5,1(RG5)              .ADDR NEXT DIGIT-PAIR.  @ZA17660\n         CL    RG5,CON3                . IF ANY.               @ZA17660\n         BL    SCAN7                   .B IF MORE.             @ZA17660\n         ST    RG2,CHSUMACC            .ELSE STORE CHECKSUM,   @ZA17660\n         STH   R1,CHSUMSLL             . SAVE LAST SHIFT AMT.  @ZA17660\n         L     R15,AIORTNS             .RESTORE EP FOR 'IOR'.  @ZA17660\n         BCR   15,LNKRG1\n         SPACE 1\nDIGITERR BAL   LNKRG1,SCANKEY           GET DEY WORD\n         CLC   0(3,RG1),REP             REP\n         BC    8,DIGERR2                YES-DONT SET FLUSH SWITCH\n         OI    CTLBTE,IGNOP             SET SWITCH TO IGNORE ANY REPS\nDIGERR2  LA    RG5,DGERROR              YES-IGNORE IT\n         BAL   LNKRG1,WRITE0            PRINT OUT MESSAGE\n         MVC   RETCODE(1),RETCOD08     .INDIC SPZAP-INP ERROR. @ZA06023\n         BCR   15,LNKRG3                GET NEXT CARD\n         SPACE 1\nSAVE     MVC   0(1,RG4),0(RG2)          SAVE DATA IN TBUF\n         SPACE 2\n***********************************************************************\n* SUBROUTINE FOR NAMERTN AND DUMPRTN\n* POINT AT MEMBER OF DATA SET\n*******************\nNAME01A  MVC   LIST+4(8),MEMNAME        SET UP MEMBER NAME\n         NI    CTLBTE2,X'FF'-MULREC     RESET INDICATOR FOR MULTIPLE\n         ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         BLDL  LIB2,LIST                READ DIRECTORY\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\n         LTR   15,15                    TEST FOR ERROR RETURN CODE\n         L     R15,AIORTNS              RESET R15                S21995\n         BC    7,NAME03C                YES - EXIT\n         NI    LIST+17,X'1F'            0 OUT HIGH ORDER BITS     M5099\n         CLI   LIST+17,X'0B'            CHK LNGTH FOR 11 OR MORE  M5099\n         BL    NAME03C                 < MEANS NOT LKED OUTPUT    M5099\n         SR    RG4,RG4                  ESD ID COUNTER\n         MVC   BASE(4),CLER            INIT BASE HIGH FOR        A42310\n         MVI   BASE+1,X'FF'             SEARCH FIRST CSECT       A42310\n         ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         FIND  LIB2,MEMNAME,D\n         L     R15,AIORTNS              RESET R15                S21995\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\nNAME02   LA    R1,ARDDSK2               READ CONTROL RECORD      S21995\n         BALR  R14,R15                                           S21995\n         CLI   RDAREA1,X'40'            SYM. RECORD\n         BC    8,NAME02                 YES-SKIP\n         CLI   RDAREA1,X'20'            CESD RECORD\n         BE    NAME02A                  YES-GO SEARCH IT         A42310\n         TM    LIST+4+ATTR+1,MULTXT    NO ESD BUT MULTI TEXT REC YM5148\n         BC    1,NAME03E               SET UP PROPER INDICATORS  YM5148\n         CLC   CSECT(8),BLANKS         NO-WANT LOWEST CSECT      A42310\n         BCR   7,LNKRG2                NO-RETURN NOT FOUND       A42310\n         MVC   CSECT(8),TEMP           YES-MOVE ITS NAME         A42310\n         OI    CTLBTE3,LMREAD          SET LOAD MODULE READ      S21016\n         B     8(LNKRG2)               RETURN FOUND              A42310\nNAME02A  LA    RG3,RDAREA1+8            YES-STARTOFESD\n         LH    RG1,RDAREA1+6            BYTES OF ESD DATA\n         LA    RG1,0(RG1,RG3)           STOP ADDRESS\n         NI    LIST+4+ATTR+1,X'FF'-MULTXT SET NON EDIT BIT OFF   YM5148\nNAME03   LA    RG4,1(RG4)               INCR. ESD ID COUNTER\n         TM    8(RG3),X'0F'             SECTION DEFN.\n         BC    8,NAME03A                YES-EXIT\n         NI    8(RG3),X'17'             TURN OFF HI ORDER BITS   A41005\n         CLI   8(RG3),X'04'             TEST FOR PRIVATE CODE    A41005\n         BC    7,NAME03B                NO-GET NXT ESD           A41005\nNAME03A  CLC   CSECT(8),BLANKS         WAS A CSECT SPECIFIED     A42310\n         BE    NAME03AA                N0-LOOP FOR LOWEST CSECT  A42310\n         MVC   BASE+1(3),9(RG3)        SET CSECTS DISPLACEMENT\n         ST    RG4,CSECTID             SAVE ESDID\n         CLC   CSECT(8),0(RG3)         YES-IS THIS IT            A42310\n         BNE   4(LNKRG2)               N0-RETURN VECTOR2         A42310\n         B     8(LNKRG2)               RETURN FOUND\nNAME03AA CLC   ZERO(3),9(RG3)          IS THIS FIRST CSECT       A42310\n         BNE   NAME03AC                NO-GO TEST FOR SAVING     A42310\n         MVC   CSECT(8),0(RG3)         YES-MOVE IN ITS NAME      A42310\nNAME03AB MVC   BASE+1(3),9(RG3)        SET CSECTS DISPLACEMENT   A42310\n         ST    RG4,CSECTID             SAVE ESDID                A42310\n         B     8(LNKRG2)               RETURN FOUND              A42310\nNAME03AC CLC   BASE+1(3),9(RG3)        IS THIS LOWEST CSECT YET  A42310\n         BL    4(LNKRG2)               NO-RETURN VECTOR2         A42310\n         MVC   BASE+1(3),9(RG3)        YES-SAVE ITS DISPLACEMNT  A42310\n         ST    RG4,CSECTID             SAVE ESDID                A42310\n         MVC   TEMP(8),0(RG3)          SAVE CSECT NAME           A42310\n         B     4(LNKRG2)               RETURN VECTOR2            A42310\n         SPACE 1\n* CONTINUE RETURNS HERE\nNAME03B  LA    RG3,16(RG3)              NO-TO NXT ESD\n         CR    RG3,RG1                  ANY LEFT IN RECORD\n         BC    8+2,NAME02               NO-READ NEXT RECORD\n         BC    15,NAME03                CONTINUE\n         SPACE 1\nNAME03C  OI    CTLBTE,NAMEERR           SET ERROR FLAG\n         L     RG5,AMSG102I            .SELECT MESSAGE.        @ZA17658\n         BC    15,IGNORE2               TO PRINT MSG\n         SPACE 1\nNAME03E  OI    CTLBTE3,NENOIDR        .INIDCATE NON-EDITABLITY @ZA19029\n         CLC   LIST+4+MODTTR(3),LIST+4+TXTTTR                  @ZA19029\n         BE    NAME03D                .B IF NO CESD (ERGO NE). @ZA19029\n         OI    CTLBTE2,MULREC         .INIDC MULT-TXT & NO RLD @ZA19029\nNAME03D  MVC   BASE+1(3),LIST+4+ORGIN   SET UP BASE ADDR\n         MVC   START+1(3),LIST+4+ORGIN\n         MVC   STCSECT(4),LIST+4+TXTTTR SAVE TEXT ADDR\n         MVC   LENGTH+2(2),LIST+4+LNGTH SET TXT LENGTH\n         MVC   CSECT(8),BLANKS          CLEAR FIELD\n         OI    CTLBTE,ONEREC            SET INDICATOR\n         B     8(LNKRG2)               RETURN FOUND CSECT\n         SPACE 2\n***********************************************************************\n* THESE SUBROUTINES ARE USED BY THE DUMP PROGRAMS.\n*******************\nRDDSK3   LA    R1,ARDDSK2               READ TEXT                S21995\n         BALR  R14,R15                                           S21995\nRDDSK4   TM    CTLBTE,ONEREC            SPECIAL RECORD\n         BC    1,4(LNKRG2)\nRDDSK4B  LA    R1,ARDDSK2               READ CONTROL RECORD      S21995\n         BALR  R14,R15                                           S21995\nRDDSK4BB TM    RDAREA1,X'01'           .CONTROL-RECD BIT.      @ZA09673\n         BZ    RDDSK4BC                .B IF ZERO.             @ZA09673\n         TM    RDAREA1,X'F0'           .HIGH 4 BITS OF RECDID. @ZA09673\n         BZ    RDDSK4BZ                .B IF ALL ZERO (VALID). @ZA09673\n         B     RDDSK4BE                .ELSE INVALID RECORD.   @ZA09673\n* NOT A CONTROL RECORD. TEST FOR INVALID ID BYTE.              @ZA09673\nRDDSK4BC TM    RDAREA1,X'0F'           .LOW 4 BITS OF RECDID.  @ZA09673\n         BZ    RDDSK4BD                .B IF ALL ZERO.         @ZA09673\n         TM    RDAREA1,X'F0'           .HIGH 4 BITS OF RECDID. @ZA09673\n         BZ    RDDSK7                  .B IF ALL ZERO (VALID). @ZA09673\n         B     RDDSK4BE                .ELSE INVALID RECORD.   @ZA09673\nRDDSK4BD TM    RDAREA1,X'F0'           .(LOW 4 BITS ZERO).     @ZA09673\n         BNZ   RDDSK7                  .B IF HIGH 4 NOT ALL 0. @ZA09673\n* INVALID RECORD TYPE. ISSUE MESSAGE AND DUMP RECORD.          @ZA09673\nRDDSK4BE MVC   RETCODE(1),RETCOD16     .SET ERROR CODE.        @ZA09673\n         L     RG5,AMSG131I            .SELECT MESSAGE.        @ZA09673\n         MVC   8(8,RG5),MEMNAME        .INSERT MEMBER NAME.    @ZA09673\n         L     R15,AIORTNS             .INVOKE                 @ZA09673\n         BAL   LNKRG1,WRITE0           . MESSAGE WRITER.       @ZA09673\n* SET UP 'ABSDUMP' COMMAND IN CARD BUFFER FOR DUMPING RECORD.  @ZA09673\n         BAL   LNKRG1,CCHNOTE          .GET CCHHR.             @ZA09673\n         MVC   CDBUF+0(7),ABSDUMP      .SET KEYWORD            @ZA09673\n         MVI   CDBUF+7,BLANK           . FOLL BY BLANK.        @ZA09673\n         UNPK  CDBUF+8(11),MBBCCHHR+3(6)  .EDIT AND INSERT     @ZA09673\n         TR    CDBUF+8(10),TRANTBL2-X'F0' . START ADDRESS.     @ZA09673\n         MVI   CDBUF+18,BLANK          .SEPARATING BLANK.      @ZA09673\n         MVC   CDBUF+19(11),CDBUF+8    .SET ENDADDR=STARTADDR. @ZA09673\n         BAL   LNKRG1,SCANKEY          .SET REGISTERS AND      @ZA09673\n         B     ABDMPRTN                . PROCESS 'ABSDUMP'.    @ZA09673\n* CONTROL RECORD FOUND.                                        @ZA09673\nRDDSK4BZ DS    0H                                              @ZA09673\n         XC    STARTINC(4),STARTINC     ZERO INC AMOUNT\n         LH    RG2,RDAREA1+6            GET ID OFFSET\n         LA    RG2,RDAREA1+16(RG2)      POINT AT ID FIELD\n         LH    RG3,RDAREA1+4            GET LENGTH\n         LA    RG3,0(RG3,RG2)           FORM S TO P ADDR\n         ST    RG3,TBUF                 SAVE FOR CONPANE\nRDDSK4C  LH    RG3,0(RG2)               ESDID\n         CL    RG3,CSECTID              ARE THEY EQUAL\n         BC    8,RDDSK5                 YES-SET UP SAVE\n         TM    CTLBTE2,MULREC           BUT IS IT A MULTIPLE TEXT CSECT\n         BC    1,RDDSK5                 YES-ID NOT VALID\n         L     RG3,STARTINC             GET INC\n         AH    RG3,2(RG2)               ADD LENGTH OF CSECT\n         ST    RG3,STARTINC             SAVE NEXT INC\n         LA    RG2,4(RG2)               ADVANCE RECORD PTR\n         CL    RG2,TBUF                 OUTSIDE RECORD\n         BC    4,RDDSK4C                NO-CONTINUE\n         TM    RDAREA1,X'0D'            END OF MODULE\n         BCR   1,LNKRG2                 YES-VECTOR 1\n         BC    15,RDDSK3                CONTINUE\n         SPACE 1\nRDDSK5   OI    CTLBTE,ENDMOD            SET INDICATOR\n         TM    RDAREA1,X'0D'            LAST CONTROL OF MODULE\n         BC    1,RDDSK6                 YES-LEAVE ENDMOD SET\n         NI    CTLBTE,X'FF'-ENDMOD      RESET INDICATOR\nRDDSK6   MVC   LENGTH+2(2),2(RG2)       SAVE CSECT LENGTH\n         L     RG3,STARTINC             GET ACC OFFSET\n         A     RG3,RDAREA1+8            ADD TO RECORD OFFSET ADDR\n         LA    RG3,0(0,RG3)             CLEAR HIGH BYTE\n         ST    RG3,START                SET AS CSECT OFFSET\n         BC    15,4(LNKRG2)             VECTOR 2-CONTR. RECD FOUND\n         SPACE 1\nRDDSK7   CLI   RDAREA1,X'0E'            LAST RECORD OF MODULE\n         BC    7,RDDSK4                 NO-CONTINUE\n         BCR   15,LNKRG2                VECTOR 1 - END RETURN\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE OBTAINS THE TEXT TTR AND CONVERTS IT TO CCHHR\n*******************\nCCHNOTE  ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         NOTE  LIB2\n         L     R15,AIORTNS              RESET R15                S21995\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\n         ST    1,STCSECT                SAVE TTR\n         LR    0,1                      CONVERT TTR INPUT REG\n         LA    14,X'1C'                 TTR CONV RTN OFFSET\nCHCONV   STM   8,13,TBUF+32             SAVE REGS THAT GET CLOBBERED\n         LA    8,TBUF+32                GET ADDRESSIBILITY\n         LA    2,MBBCCHHR               CONVERT STG ADDR.\n         L     1,LIB2+44                DEB ADDRESS\n         L     15,16                    CVT POINTER\n         L     15,0(14,15)              CONVERT RTN ADDR\n         BALR  14,15                    TO CONVERT TO CCHHR\n         LM    8,13,0(8)                RESTORE REGISTERS\n         L     R15,AIORTNS              RESET R15                S21995\n         BCR   15,LNKRG1                RETURN\n         SPACE 1\nCCHHSUB  LR    RG1,RG3                  SET DATA POINTER\n         NI    CTLBTE,X'FF'-NAMEOP-ONEREC  RESET INDICATORS\n         XC    BASE2(4),BASE2           RESET BASE\nCCHSUB2  BAL   LNKRG1,SCAN              DEBLOCK DATA\n         MVC   MBBCCHHR(8),DBUFEND-8    SAVE\n         CLI   MBBCCHHR+7,X'00'         RECORD ZERO\n         BC    7,CONTIN                 NO-DON'T UPDATE\n         OI    MBBCCHHR+7,MAK1          CHANGE RECORD TO ONE\nCONTIN   L     RG2,LIB2+44              DEB EXTENTS\n         SR    RG4,RG4                  CLEAR WK REGS\n         SR    RG5,RG5\n         IC    RG4,NEXTS(RG2)           GET NO OF EXTENTS\n         BCTR  RG4,0                    COMPUTE M\n         LA    RG2,DEBEXT(RG2)          POINT AT FIRST EXTENT\nCCHSUB3  CLC   MBBCCHHR+3(4),6(RG2)     TEST FOR LOW\n         BC    4,CCHSUB4                YES-TEST NEXT EXTENT\n         CLC   MBBCCHHR+3(4),10(RG2)    TEST FOR HIGH\n         BC    2,CCHSUB4           YES - CHK NEXT EXTENT\n         MVC   MBBCCHHR+1(2),LIB2+6 SET BB EQU TO FDAD BB\n         BCR   15,LNKRG2           OKAY - EXIT\n*   SWITCH TO A DIFFERENT EXTENT\nCCHSUB4  CR    RG4,RG5                  TEST FOR NO MORE EXTENTS\n         BC    8,NAME03C                YES-ERROR\n         LA    RG5,1(RG5)               NO-INCREMENT TO NXT.\n         STC   RG5,MBBCCHHR             SAVE EXTENT M\n         LA    RG2,16(RG2)              INCR.BY SIZE\n         BC    15,CCHSUB3               CONTINUE\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE SETS UP MEMBER AND CSECT NAMES.\n*******************\nNAMERTN  CLC   RETCODE(1),LASTRET       WHICH CODE IS HIGHEST\n         BL    CLEAR1                   IF LAST ONE--DON'T CHANGE\n         MVC   LASTRET(1),RETCODE       SAVE HIGHEST STEP RET CODE\nCLEAR1   MVC   RETCODE(1),RETCOD00     .RESET RETURN CODE.     @ZA06023\n         BAL   LNKRG2,SCANKEY5          TO SET UP NAME AND SCECT\n         XC    BASE2(4),BASE2           ZERO OUT OFFSET\n         MVC   IDRDATA(8),IDRDFLT      PRIME IDR DATA            S21016\n         NI    CTLBTE3,X'FF'-NAMEIDR-IDRRD-LMREAD-NENOIDR        S21016\n         NI    CTLBTE,X'FF'-ONEREC-IGNOP-NAMEERR\n         XC    IDRNRECS(4),IDRNRECS     .INIT # IDR-S.         @ZA00409\n         XC    IDRNENTS(4),IDRNENTS     .INIT # IDR ENTRIES.   @ZA00409\n         XC    IDRMENTS(4),IDRMENTS     .INIT MAX ENTRIES.     @ZA00409\n         OI    CTLBTE,NAMEOP            SET NAME OPTION\n         LA    R15,NOCSECT    IN CASE OF BAD INPUT, WE HAVE TO  YA01766\n         STM   0,15,DMPSAVE   SAVE THE REGS AND POINT REG15 TO  YA01766\n         L     R15,AIORTNS    LABEL 'NOCSECT'                   YA01766\n         BAL   LNKRG2,NAME01A           TO EXAMIN CESD'S\n* RETURN VECTOR1-ERROR\n         BC    15,NOCSECT               ERROR MESSAGE\n         SPACE 1\n* RETURN VECTOR 2-NOT FOUND\n         BC    15,NAME03B               CONTINUE\n         SPACE 1\n* RETURN VECTOR 3-FOUND CSECT\n         TM    CTLBTE3,LMREAD          WAS RECORD READ           S21016\n         BZ    NAME04AA                NO-CHECK NONEDITABLE      S21016\n         NI    CTLBTE3,X'FF'-LMREAD    YES RESET SW              S21016\n         B     NAME04AB                SKIP READ                 S21016\nNAME04AA TM    CTLBTE3,NENOIDR         IS MODULE NE              S21016\n         BO    NOIDRL                  YES-NO IDR                S21016\nNAME04A  LA    R1,ARDDSK2              READ LOAD MODULE          S21016\n         BALR  R14,R15                                           S21016\nNAME04AB CLI   RDAREA1,X'80'           IDR RECORD                S21016\n         BE    SPZAPIDR                YES-CHECK FOR SPZAP       S21016\n         CLI   RDAREA1,X'20'           CESD RECORD               S21016\n         BE    NAME04A                 YES-SKIP                  S21016\n         CLI   RDAREA1,X'40'           SYM RECORD                S21016\n         BE    NAME04A                 YES-SKIP                  S21016\n         CLI   RDAREA1,X'28'           LAST RECORD OF MODULE?    SM4165\n         BCR   8,LNKRG2                YES,RETURN                SM4165\nNOIDRL   LA    RG5,NOIDR               PRINT MSG-NO IDR RECORDS  S21016\n         NI    CTLBTE3,X'FF'-NENOIDR   RESET SW                  S21016\n         MVC   NOIDR+26(8),MEMNAME                               S21016\n         BAL   LNKRG1,WRITE0                                     S21016\n         NI    CTLBTE3,X'FF'-IDRRD     SET NO IDR RECORDS SW     S21016\n         LA    LNKRG2,NAME04+4         SET RETURN REG            S21016\n         CLC   LIST+4+MODTTR(3),LIST+4+TXTTTR                  @ZA19029\n         BE    4(LNKRG2)              .B IF NO CESD (ERGO NE). @ZA19029\n         B     RDDSK4BB                BRANCH INTO RDDSK4        S21016\nSPZAPIDR NI    RDAREA1+2,X'0F'         CLEAR HIGH ORDER BITS     S21016\n         CLI   RDAREA1+2,X'01'         IS SUBTYPE SPZAP          S21016\n         BNE   NAME04A                 NO-READ NEXT RECORD       S21016\n         MVC   TEMP(1),RDAREA1+3       SAVE NUMBER OF ENTRIES    S21016\n         NI    TEMP,X'3F'              CLEAR HIGH ORDER BITS     S21016\n         LA    RG5,1                    .ADD TO                @ZA00409\n         A     RG5,IDRNRECS             . # OF                 @ZA00409\n         ST    RG5,IDRNRECS             . RECORDS.             @ZA00409\n         M     RG4,IDRMENTR             .SET                   @ZA00409\n         ST    RG5,IDRMENTS             . MAX ENTS SO FAR.     @ZA00409\n         XR    RG5,RG5                                         @ZA00409\n         IC    RG5,TEMP                 .ADD  TO               @ZA00409\n         A     RG5,IDRNENTS             . # OF                 @ZA00409\n         ST    RG5,IDRNENTS             . IDR ENTRIES.         @ZA00409\n         CLI   TEMP,19                 IS SPZAP IDR FULL         S21016\n         BL    IDRNOTFL                .B IF IDR NOT FULL:     @ZA00409\n         TM    RDAREA1+3,X'40'         ANOTHER SPZAP REC?        S21016\n         BO    NAME04A                 YES-READ NEXT RECORD      S21016\n* SET UP AND ISSUE 'NO IDR SPACE' MESSAGE.                     @ZA00409\n         MVC   NOSPACE1(8),MEMNAME     .INSERT NAME.           @ZA00409\n         LA    RG5,NOSPACE             SET POINTER               S21016\n         BAL   LNKRG1,WRITE0                                     S21016\n* TEST FOR OVERRIDE OF INHIBITION ON UPDATES.                  @ZA06024\n         TM    PARMBITS,QIGNIDRF                               @ZA06024\n         BZ    ERRIDRFL                 .B IF NO OVERRIDE.     @ZA06024\n* REP-INHIBITION OVERRIDDEN. SET WARNING AND SELECT MESSAGE.   @ZA06024\n         MVC   RETCODE(1),RETCOD04      .SET WARNING RETCODE,  @ZA06024\n         LA    RG5,MSGUDACC             . AND SELECT MESSAGE.  @ZA06024\n         B     IDRFMSG2                                        @ZA06024\n* NO OVERRIDE. SET 'NO GO' AND ISSUE MESSAGE.                  @ZA06024\nERRIDRFL OI    CTLBTE,IGNOP             .SET 'NO GO' SWITCH.   @ZA06024\n         MVC   RETCODE(1),RETCOD08      .SET ERROR CODE.       @ZA07967\n         LA    RG5,MSGUDINH             . AND SELECT MESSAGE.  @ZA06024\n* ISSUE SECOND MESSAGE FOR IDR-SPACE-FOUND-FULL CONDITION.     @ZA06024\nIDRFMSG2 BAL   LNKRG1,WRITE0            .MSG TO SYSPRINT.      @ZA06024\n         B     NAME04                  CONTINUE PROCESSING       S21016\n* CURRENT  IDR HAS SPACE FOR NEW ENTRY.                        @ZA00409\nIDRNOTFL TM    CTLBTE3,IDRRD           .IDR BIT.               @ZA00409\n         BO    IDRAVAIL                .B IF SPACE ALREADY.    @ZA00409\n* FIRST IDR WITH ENPTY ENTRY.                                  @ZA00409\nSAVELOC  BAL   LNKRG1,CCHNOTE            GET TTR OF IDR REC    @YA02256\n         MVC   IDRTTR(4),STCSECT       SAVE TTR                  S21016\n         MVC   IDRFSEEK(8),MBBCCHHR    SAVE MBBCCHHR             S21016\n         OI    CTLBTE3,IDRRD           INDICATE IDR RECORD       S21016\nIDRAVAIL TM    RDAREA1+3,X'40'                                 @ZA00409\n         BO    NAME04A                 .B IF NOT LAST IDR.     @ZA00409\n* CSECT FOUND-SIFT THROUGH CONTROL RECORDS\nNAME04   BAL   LNKRG2,RDDSK4            READ NXT CTL RECORD\n* RETURN VECTOR 1 - NOT VALID\n         BC    0,0\n* RETURN VECTOR 2 - CONTROL RECORD FOR LSECT FOUND\n* RETURN-FOUND CSECT ID\n         MVC   IDSAVE(4),STCSECT        SAVE FOR NEXT POINT\n         TM    CTLBTE,ONEREC            WAS IT NECESSARY\n         BCR   1,LNKRG3                 YES-GET NEXT CARD\n         BAL   LNKRG1,CCHNOTE           TO SET NOTE LIST\n         MVC   IDSAVE(4),STCSECT        SAVE FOR NEXT POINT\n         BCR   15,LNKRG3                GET NEXT CARD\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE SETS UP FOR ABSOLUTE UPDATE.\n*******************\nCCHHRTN  CLC   RETCODE(1),LASTRET       WHICH CODE IS HIGHEST\n         BL    CLEAR2                   IF LAST ONE--DON'T CHANGE\n         MVC   LASTRET(1),RETCODE       SAVE HIGHEST STEP RET CODE\nCLEAR2   MVC   RETCODE(1),RETCOD00     .RESET RETURN CODE.     @ZA06023\n         NI    CTLBTE,X'FF'-IGNOP-NAMEERR   RESET CTLBTE\n         BAL   LNKRG2,CCHHSUB\n         XC    BASE(4),BASE             RESET FIELDS\n         XC    BASE2(4),BASE2\n         XC    START(4),START           RESET TO ZERO             M2817\n         LA    R1,AOPENLIB                                       S21995\n         BALR  R14,R15                                           S21995\n         LA    R1,ARDDISK               GET RECORD FOR UPDATE    S21995\n         BALR  R14,R15                                           S21995\n         L     15,SIZE                  CALCULATE RECORD LENGTH\n         SH    15,DECB4+X'12'           GET RESIDUAL COUNT\n         ST    15,LENGTH                STORE MAX INSPECT AREA\n         L     R15,AIORTNS             RESET R15                 S21995\n         BCR   15,LNKRG3                    GET NEXT OPERATION\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE SETS FOR A VERIFY OPERATION.\n*******************\nVERYRTN  OI    CTLBTE,VERYOP            SET VERIFY OPTION\n         BAL   LNKRG2,SETUP1            DECODE VERIFY CARD\n         EX    RG4,VERPTCH\n         BCR   8,LNKRG3           GET NEXT CARD.  DON'T RESET IGNORE SW\n* VERIFY NOT CONFIRMED\n         L     RG5,AMSG104I            .SELECT MESSAGE.        @ZA17658\nVERY1    BAL   LNKRG1,WRITE0            SEND ERROR MSG\n         MVC   RETCODE(1),RETCOD08     .INDIC SPZAP-INP ERROR. @ZA06023\n         TM    CTLBTE,IGNOP             HAS DUMP BEEN DONE?    @YM4508P\n         BCR   1,LNKRG3                 YES, GET NEXT CARD     @YM4508P\n         OI    CTLBTE,IGNOP             SET INVALID CARD SWITCH\n         MVC   MEMNAME(8),BLANKS        CLEAR FIELDS\n         MVC   CSECT(8),BLANKS\n         LA    RG5,BLANKS               SKIP LINE\n         BAL   LNKRG1,WRITE0\n         MVC   CDBUF(100),TITLE1        SET-UP TITLE\n         LA    WK6,RDAREA1              BUFFER START ADDR\n         L     WK1,LENGTH               LENGTH OF SECTION\n         LA    R1,ADMP1AB              DUMP FORMATTED            S21995\n         L     R15,ADMP                                          S21995\n         BALR  R14,R15                                           S21995\n         BC    15,DUMP09                EXIT AND SKIP PAGE\n         SPACE 1\nVERPTCH  CLC   0(1,RG1),0(RG6)          VERIFY PATCHES\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE SETS UP FOR A REPLACE OPERATION.\n*******************\nREPRTN   NI    CTLBTE,X'FF'-VERYOP      REP CARD INDICATE\n* IF REP IS FOR NAME CARD, SETUP1 DOES NOT RETURN BUT GOES TO NAME07\n         BAL   LNKRG2,SETUP1            DECODE REP CARD\n         LR    WK2,RG1                  LOAD ADDRESS OF OLD DATA X01979\n         LA    WK5,1(RG4)               LOAD LENGTH OF PATCH     X01979\n         BAL   LNKRG2,UNPATCH           FORMAT UNPATCH MESSAGE   X01979\n         BAL   LNKRG1,WRITE3           .WRITE 'OLD DATA' MSG.  @ZA17659\n         MVC   CDBUF+80(40),BLANKS      CLEAR END OF BUFFER      X01979\n         EX    RG4,PATCH                MOVE IN REP DATA\n         LA    R1,AWRDISK               UPDATE DISK              S21995\n         BALR  R14,R15                                           S21995\n         OI    CTLBTE3,MODFYREC        INDICATE CCHHR UPDATE     S21016\n         BR    LNKRG3                  . ON TO GET NEXT INPUT. @ZM30902\n         SPACE 1\nPATCH    MVC   0(1,RG1),0(RG6)          INSERT PATCH DATA\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE WILL UPDATE THE SSI ENTRY.\n*******************\nSSIRTN   LR    RG1,RG3                  POINTER TO END OF KEYWORD\n         CLC   RETCODE(1),RETCOD08     .TEST FOR PREV ERROR.   @ZA06023\n         LA    RG5,IGNORSSI             ERROR MSG\n         BNL   SSI3                    .B IF PREV ERROR.       @ZA06023\n         OI    CTLBTE3,SSIOP            SET SSI OPERATION FLAG\n         NI    CTLBTE3,X'FF'-NOSSI-NOMEM  RESET SWS              S21995\n         LA    R1,AOPENLIB              LIB OPEN FOR UPDATE      S21995\n         BALR  R14,R15                                           S21995\n         BAL   LNKRG1,SCAN              DECODE SSI CARD\n         LA    R1,AINSM1A         GET INDEX                      X01979\n         BALR  R14,R15            GET SSI FIELD                  X01979\n         TM    CTLBTE3,NOMEM            MEMBER NOT FOUND\n         LA    RG5,NONAME               ERROR MSG\n         BC    1,SSI2                   YES-SEND ERROR MSG\n         TM    CTLBTE3,NOSSI            SSI FIELD MISSING\n         BC    1,SSI1                   YES-SEND ERROR MSG\n         LR    WK2,RG4                  LOAD ADDRESS OF OLD SSI  X01979\n         LA    WK5,4                    LOAD LENGTH OF SSI       X01979\n         BAL   LNKRG2,UNPATCH           FORMAT UNPATCH MESSAGE   X01979\n         BAL   LNKRG1,WRITE3           .WRITE 'OLD DATA' MSG.  @ZA17659\n         MVC   CDBUF+80(40),BLANKS      CLEAR END OF BUFFER      X01979\n         MVC   0(4,RG4),0(RG6)          MOVE SSI TO DIRECTROY\n         LA    R1,ADIRWRIT              UPDATE DIRECTORY         S21995\n         BALR  R14,R15                                           S21995\n         BR    LNKRG3                  . ON TO GET NEXT INPUT. @ZM30902\n         SPACE 1\nSSI1     LA    RG5,SSIERR               ERROR MSG\nSSI2     MVC   RETCODE(1),RETCOD04    .ELSE SET RETCODE = 4,   @ZA19023\nSSI3     BAL   LNKRG1,WRITE0           .ISSUE ERROR MESSAGE.   @ZA06023\n         BR    LNKRG3                  . ON TO GET NEXT INPUT. @ZM30902\n         SPACE 2\n***********************************************************************\n*  THIS SUBROUTINE DECODES & SAVES THE IDRDATA STATEMENT\n***********************************************************************\nIDRRTN   TM    CTLBTE3,NAMEIDR         FIRST IDR CARD THIS NAME  S21016\n         BCR   1,LNKRG3                N0-IGNOR IT               S21016\n         BAL   LNKRG1,SCANKEY1         FIND IDR DATA             S21016\n         MVC   IDRDATA(8),BLANKS       CLEAR IDR DATA AREA       S21016\n         EX    RG4,SAVE4               MOVE IDR DATA TO BEGIN    S21016\n         OI    CTLBTE3,NAMEIDR         INDICATE IDR CD THIS NAME S21016\n         BR    LNKRG3                  READ NEXT CARD            S21016\n         SPACE 1\nSAVE4    MVC   IDRDATA(0),0(RG1)       SAVE IDRDATA              S21016\n***********************************************************************\nSETUP1   LR    RG1,RG3                  KEYWORD END POINTER\n         BAL   LNKRG1,SCAN              GET OFFSET\n         MVC   OFFSET(4),DBUFEND-4      SAVE OFFSET\n         BAL   LNKRG1,SCAN              GET PATCHES\n         LA    R1,AOPENLIB                                       S21995\n         BALR  R14,R15                                           S21995\n         L     RG1,OFFSET\n         LA    RG1,RDAREA1(RG1)         PATCH AREA ADDRESS\n         S     RG1,BASE2                ADDITIONAL OFFSET SUPPLIED\n         BCTR  RG4,0                    DECR. BY 1\n         ST    RG4,SVLNGTH              SAVE LENGTH OF FIELD      M0509\n         TM    CTLBTE,NAMEOP            CSECT OPERATION\n         BC    1,NAME07                 YES-GET PROPER TEXT RECORD\n         LA    15,1(RG4,RG1)            CALCULATE END OF INSPECT\n         L     14,LENGTH                LENGTH OF RECORD\n         LA    14,RDAREA1(14)           POSITION IN CORE\n         CR    15,14\n         L     R15,AIORTNS              RESET R15                S21995\n         BCR   8+4,LNKRG2               CONTINUE PROCESSING\n         L     RG5,AMSG106I            .SELECT ERROR MESSAGE.  @ZA09679\n         BC    15,VERY1                 SEND MESSAGE AND DUMP\n         SPACE 2\n***********************************************************************\nBASERTN  LR    RG1,RG3                  KEYWORD END PTR\n         BAL   LNKRG1,SCAN              DEBLOCK BASE OFFSET\n         MVC   BASE2(4),DBUFEND-4       MOVE IN OFFSET\n         BCR   15,LNKRG3                RETURN TO CALLER        YA01767\n         SPACE 3\n***********************************************************************\nNAME07A  DS    0C\n         LA    R15,NOCSECT    IN CASE OF BAD INPUT, WE HAVE TO  YA01766\n         STM   0,15,DMPSAVE   SAVE THE REGS AND POINT REG15 TO  YA01766\n         L     R15,AIORTNS    LABEL 'NOCSECT'                   YA01766\n         BAL   LNKRG2,NAME01A           SET MODULE ATTRIBUTES\n         BC    0,0                      DUMMY VERTOR\n         BC    0,0                      DUMMY VERTOR\n         LA    R1,ARDDSK2               GET FIRST TEXT RECORD    S21995\n         BALR  R14,R15                                           S21995\n         NI    CTLBTE,X'FF'-ONEREC-ENDMOD-OVFLOW                 YM5531\n         ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         POINT LIB2,STCSECT             REPOSITION AT START OF TXT\n         L     R15,AIORTNS              RESET R15                S21995\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\n         BC    15,NAME08                CONTINUE WITH INSPECT\n         SPACE 1\n* ENTER HERE AFTER REP CARD IS READ AND NAME OPTION SPEC.\nNAME07   A     RG1,BASE                 MODULE PATCH ADDRESS\n         MVC   STCSECT(4),IDSAVE        RESTORE START ADDR\n         ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         POINT LIB2,STCSECT             POSITION TO RECORD\n         L     R15,AIORTNS              RESET R15                S21995\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\n         TM    CTLBTE2,MULREC           MULTIPLE TEXT RECORDS\n         BC    1,NAME07A                YES-READ FIRST TEXT RECOD\n         TM    CTLBTE,ONEREC            SPECIAL RECORD\n         BC    1,NAME08                 YES-SKIP\n* ENTER HERE IF OVERFLOW IS INDICATED\nNAME07B  BAL   LNKRG2,RDDSK4            READ CONTROL RECORD\n* VECTOR 1 - PATCH NOT IN MODULE\n         BC    15,NAME12B               PRINT ERROR MESSAGE\n         SPACE 1\n* VECTOR 2 - CSECT CONTROL RECORD READ INTO CORE\nNAME08   L     RG2,START                FOLLOWING TEXT START ADDR.\n         LA    RG2,RDAREA1(RG2)         PATCH ADDRESS IN CORE\n         CR    RG1,RG2                  PATCH WITHIN TEXT RECORD\n         BC    4,DSERROR                LOW-DSERROR\n         LR    RG3,RG2\n         A     RG3,LENGTH               ADD LENGTH TO START\n         CR    RG1,RG3                  PATCH IN TEXT\n         BC    4,NAME09                 YES-GET TEXT RECORD\n         TM    CTLBTE,ONEREC            NO-SPECIAL RECORD\n         BC    1,NAME12B                YES-ERROR MSG + DUMP     A41634\n* PATCH IN SUCCEEDING TEXT RECORDS\nNAME08B  TM    CTLBTE,ENDMOD            HAS END OF MODULE BEEN REACHED\n         BO    NAME12B                  YES--PRINT MESSAGE\n         LA    LNKRG2,NAME07B+4         SET LINK REGISTER\n         BC    15,RDDSK3                 SKIP TEXT AND READ NEXT C+U\n         SPACE 1\n* PREPARE TO PATCH THE TEXT RECORD\nNAME09   LA    R1,ARDDSK2               GET TEXT RECORD          S21995\n         BALR  R14,R15                                           S21995\n         LR    RG2,RG1                  TEXT START ADDRESS\n         L     RG4,SVLNGTH              GET LENGTH OF FIELD       M0509\n         LA    RG2,0(RG4,RG2)           ADD NO. OF PATCH CHAR (-1)\n         NI    CTLBTE,X'FF'-OVFLOW      RESET OVERFLOW BIT\n         CR    RG2,RG3                  END OF PATCH WITHIN RECORD\n         BC    4,NAME10                 YES-SKIP\n         TM    CTLBTE,ONEREC            SPECIAL RECORD\n         BC    1,NAME12B                ERROR MSG + DUMP         A41634\n         OI    CTLBTE,OVFLOW            SET OVERFLOW BIT\n         SR    RG2,RG3                  NO OF CHAR'S OVER (-1)\n         SR    RG4,RG2                  ACTUAL NO IN PATCH\n         BCTR  RG4,0                    DECR. BY 1\n         LR    RG5,RG2                  SAVE NO. OF CHARS\n         ST    RG2,SVLNGTH              SAVE NO. OF CHARS        A51987\nNAME10   BAL   LNKRG1,CCHNOTE           TO SET UP CCHHR  ADDR\n         A     RG1,STARTINC             RECORD OFFSET\n         S     RG1,START                TEXT START -ABS\n         TM    CTLBTE,VERYOP            VERY OPTION\n         BC    1,NAME13                 YES-COMPARE ONLY\n         ST    RG3,TEMPRG3              SAVE RG3                 X01979\n         ST    RG5,TEMPRG5              SAVE RG5                 X01979\n         LR    WK2,RG1                  LOAD ADDRESS OF OLD DATA X01979\n         LA    WK5,1(RG4)               LOAD LENGTH OF PATCH     X01979\n         TM    CTLBTE2,FIRSTPCH         IS THIS FIRST PASS       X01979\n         BO    SPLIT                    NO-DONT MOVE MESSAGE     X01979\n         OI    CTLBTE2,FIRSTPCH         YES-SET FIRST PASS SW    X01979\n         BAL   LNKRG2,UNPATCH           FORMAT UNPATCH MESSAGE   X01979\n         B     NAME10A                  SKIP                     X01979\nSPLIT    L     RG3,MSGOFSET             RESET OFFSET INTO MSG    X01979\n         BAL   LNKRG2,UNPK              COMPLETE MESSAGE FORMAT  X01979\nNAME10A  ST    RG3,MSGOFSET             SAVE OFFSET INTO MESSAGE X01979\n         L     RG3,TEMPRG3              RELOAD RG3               X01979\n         L     RG5,TEMPRG5              RELOAD RG5               X01979\n         EX    RG4,PATCH                MOVE IN PATCHES\nNAME11   LA    R1,AWRDISK               UPDATE DISK              S21995\n         BALR  R14,R15                                           S21995\n         OI    CTLBTE2,MODIFY           SET MODIFY FLAG ON\n         NI    CTLBTE3,X'FF'-SSIOP     TURN OFF SSI OPERATION    S21995\nNAME12   TM    CTLBTE,OVFLOW            PATCH SPLIT\n         BZ    WRITEUN                  NO-WRITE UNPATCH         X01979\n         LA    RG6,1(RG6,RG4)           UPDATE REP DATA\n         LR    RG1,RG3                  START OF ADDITIONL PATCH\n         LR    RG4,RG5                  NEW NO. OF CHARS\n         TM    CTLBTE,ENDMOD            CHECK FOR END OF MODULE  X01979\n         BNO   NAME07B                  NO--READ NEXT TEXT REC   X01979\n         TM    CTLBTE,VERYOP            IS THIS A VERIFY         X01979\n         BO    NAME12B                  YES--UNABLE TO FINISH    X01979\n         BAL   LNKRG1,WRITE3           .WRITE 'OLD DATA' MSG.  @ZA17659\n         MVC   CDBUF+80(40),BLANKS      CLEAR END OF BUFFER      X01979\n         NI    CTLBTE2,X'FF'-FIRSTPCH   TURN OFF FIRST PASS SW   X01979\n         B     NAME12B                  NOW ERROR-PATCH OVERLAP  X01979\nWRITEUN  TM    CTLBTE,VERYOP            FOR VERIFY OPERATION     X01979\n         BCR   1,LNKRG3                 YES-GET NEXT CARD        X01979\n         BAL   LNKRG1,WRITE3           .WRITE 'OLD DATA' MSG.  @ZA17659\n         MVC   CDBUF+80(40),BLANKS      CLEAR END OF BUFFER      X01979\n         NI    CTLBTE2,X'FF'-FIRSTPCH   RESET FIRST PASS SW      X01979\n         BR    LNKRG3                   GET NEXT CARD            X01979\n         SPACE 2\n* PATCH OPERATION INCOMPLETE\nNAME12B  L     RG5,AMSG106I            .SELECT ERROR MESSAGE.  @ZA09679\n         BC    15,NAME14                PRINT MSG AND DUMP\n         SPACE 1\n*    VERIFY DATA\nNAME13   EX    RG4,VERPTCH              COMPARE PATCH\n         BC    8,NAME12                 ALL COMPARE-YES\n* VERIFY OPERATION NOT CONFIRMED\n         L     RG5,AMSG104I            .SELECT MESSAGE.        @ZA17658\nNAME14   BAL   LNKRG1,WRITE0            TO PRINT MESSAGE\n         MVC   RETCODE(1),RETCOD08     .INDIC SPZAP-INP ERROR. @ZA06023\n         TM    CTLBTE,IGNOP             HAS DUMP BEEN DONE?    @YM4508P\n         BCR   1,LNKRG3                 YES, GET NEXT CARD     @YM4508P\n         OI    CTLBTE,IGNOP             SET TO IGNORE REP CARD\n         B     SETDUMP                 .(ADDRESSING DETOUR).   @ZA09679\n         SPACE 3\nUNPATCH  MVC   CDBUF(20),UNPATMSG       MOVE UNPATCH MSG         X01979\n         MVI   CDBUF+20,C' '            SET BLANK TO CLEAR       X01979\n         MVC   CDBUF+21(100),CDBUF+20      TO END OF BUFFER      X01979\n         LA    RG3,CDBUF+21             POINT TO REP AREA        X01979\nUNPK     UNPK  0(3,RG3),0(2,WK2)        UNPACK OLD REP DATA      X01979\n         TR    0(2,RG3),TRANTBL2-X'F0'  AND TRANSLATE TO EBCIDIC X01979\n         MVI   2(RG3),BLANK             CLEAR LAST BYTE          X01979\n         LA    RG3,2(RG3)               ADVANCE AREA PTR         X01979\n         LA    WK2,1(WK2)               ADVANCE DATA PTR         X01979\n         BCT   WK5,UNPK                 LOOP FOR LENGTH OF DATA  X01979\n         BR    LNKRG2                   DONE-RETURN              X01979\n***********************************************************************\nDUMPRTN  NI    CTLBTE,X'FF'-NAMEOP      SET NAME OPTION SW OFF   YM5146\n         MVI   DMPSW,X'FF'             .SET DUMP INDICATOR.    @ZA26077\n        NI    CTLBTE2,X'FF'-TRAN      .RESET 'TRANSLATE' FLAG. @ZA02775\n         CLI   4(RG1),C'T'              TRANSLATE MODE\n         BC    7,DUMPR1                 NO-SKIP\n         OI    CTLBTE2,TRAN             YES-SET CONTROL BIT\nDUMPR1   BAL   LNKRG2,SCANKEY5          TO GET MEMBER & CSECT NAME\n         NI    CTLBTE,X'FF'-ONEREC  RESET INDICATOR\n         OI    CTLBTE,NAMEERR  DON'T ALLOW VER'S AND REPS\n         CLC   CSECT(4),ALL           .TEST FOR 'ALL' REQUEST. @ZA19021\n         BC    8,DUMP04                 YES-MULTIPLE DUMP\n* ENTRY POINT FROM NON-COMPARE ON VERIFY OPERATION\nDUMP01A  NI    CTLBTE,X'FF'-ENDMOD           RESET END OF MODULE A42720\n         LA    R15,NOCSECT    IN CASE OF BAD INPUT, WE HAVE TO  YA01766\n         STM   0,15,DMPSAVE   SAVE THE REGS AND POINT REG15 TO  YA01766\n         L     R15,AIORTNS    LABEL 'NOCSECT'                   YA01766\n         BAL   LNKRG2,NAME01A           FIND CSECT NAME          A42720\n* RETURN VECTOR-ERROR MSG\n         BC    15,NOCSECT\n         SPACE 1\n         BC    15,NAME03B               TRY NEXT ESD\n         SPACE 1\n* FOUND ESD - CSECT NAME - FIND         CONTROL RECORD WITH ID\nDUMP01B  BAL   LNKRG2,RDDSK4            READ CONTROL RECORD\n* RETURN VECTOR 1 - END OF MODULE\n         BC    15,DUMP09                END OF DUMP\n         SPACE 1\n* RETURN VECTOR2 - FOUND CONTROL RECORD WITH CSECT ID\n         TM    CTLBTE,ONEREC            SPECIAL RECORD\n         BC    1,DUMP01D                YES-PREPARE TO POINT\n         BAL   LNKRG2,DUMP1             TO DUMP CSECT            S21995\n* CONDITION CODE SET FOR LAST RECORD\n         BC    1,DUMP09                 TO PRINT COMPLETE MESSAGE\n         BC    15,DUMP01B               NO-CONTINUE\n         SPACE 1\nDUMP01D  LA    R1,ADMP1AA              DUMP CSECT                S21995\n         L     R15,ADMP                                          S21995\n         BALR  R14,R15                                           S21995\n*   CONDITION CODE SET FOR LAST RECORD\n         BC    1,DUMP09                 TO PRINT COMPLETE MESSAGE\n         TM    CTLBTE2,MULREC           MULTIPLE TEXT\n         BC    8,DUMP09                 TO PRINT COMPLETE MESSAGE\n         NI    CTLBTE,X'FF'-ONEREC      YES-RESET INDICATORS\n         BC    15,DUMP01B               TO CONTINUE DUMP\n         SPACE 2\n***********************************************************************\n* THIS ROUTINE HANDLES DUNPING OF ALL THE CSECTS IN THE MEMBER\n*******************\nDUMP04   XC    IDSAVE2(4),IDSAVE2       CLEAR SAVE AREA\nDUMP04A  L     R15,ACONT      IN CASE OF BAD INPUT, WE HAVE TO  YA01766\n         STM   0,15,DMPSAVE   SAVE THE REGS AND POINT REG15 TO  YA01766\n         L     R15,AIORTNS    LABEL 'CONT '                     YA01766\n         BAL   LNKRG2,NAME01A           TO FIND FIRST CSECT\n* RETURN VECTOR - END OF ESD SEARCH\n         BC    15,DUMP09                END MSG\n         SPACE 1\n*   RETURN VECTOR- CSECT NON-COMPARE\n         BC    0,0\n*   RETURN VECTOR-  CSECT COMPARE\n         TM    CTLBTE,ONEREC            IS IT A SPECIAL DUMP\n         BC    1,DUMP01D                YES-DUMP ONE RECORD\n         CLI   RDAREA1,X'20'           MAY HAVE LOWEST CSECT     A42310\n         BNE   DUMP09                  YES-DUMP DOESNOT WANT IT  A42310\n         CL    RG4,IDSAVE2              IS IT EQUAL TO LAST\n         BC    8+4,NAME03B              SKIP UNTIL EXCEED LAST ID\n         ST    RG4,IDSAVE2              SAVE ID FOR COMPARE\n         MVC   CSECT(8),0(RG3)          USE AS DUMP NAME\nDUMP06B  BAL   LNKRG2,RDDSK4            READ CONTROL RECORD\n* RETURN VECTOR 1 - END OF MODULE\n         B     DUMP07                  .TO NEXT RECD OF DUMP.  @ZA02788\n         SPACE 1\n* RETURN VECTOR2 - FOUND CONTROL RECORD WITH CSECT ID\n         BAL   LNKRG2,DUMP1             TO DUMP CSECT            S21995\n* CONDITION CODE SET FOR LAST RECORD\n         BZ    DUMP06B                 .B IF NOT 'ENDMOD'.     @ZA02788\nDUMP07   CLC   CSECT(8),BLANKS                                 @ZA02788\n         BNE   DUMP04A                 .IF NO CSECT NAME,      @ZA02788\n         MVC   CSECT(8),IDRDFLT        . SET TO 'NO IDENT'.    @ZA02788\n         B     DUMP04A                 . AND GO TO NEXT CSECT. @ZA02788\n         SPACE 1\nDUMP09   LA    RG5,DMPCMP\n         MVI   DMPSW,X'00'             .ALLOW WRITE TO CONSOLE @ZA26077\n         BAL   LNKRG1,WRITE0            WITE OUT COMPLETE MSG\n         NI    CTLBTE2,X'FF'-TRAN      RESET IF BIT ON\n         NI    CTLBTE,X'FF'-ENDMOD     RESET IF BIT ON\n         LA    RG5,BLANKS               SKIP PAGE\n         MVI   CDBUF-1,X'F1'            SET TO SKIP TO NEW PAGE\n         MVI   DMPSW,X'FF'             .RESTORE DUMP INDICATOR @ZA26077\n         BAL   LNKRG1,WRITE0            SKIP LINE\n         MVI   CDBUF-1,X'40'            SET TO NORMAL\n* ADDRESSABILITY DETOUR.                                       @ZA09673\n         B     DUMP09Z                 .TEST FOR RETCODE GE 12 @ZA09673\n         SPACE 2\n***********************************************************************\nABDMP1   LA    RG3,1(RG3)               INCR. TO NEXT CHAR\nABDMPRTN CLI   1(RG3),BLANK             IS THIS CHAR A BLANK\n         BC    8,ABDMP1                 YES-TO INCR.\n         MVI   DMPSW,X'FF'             .SET DUMP INDICATOR.    @ZA26077\n         OI    CTLBTE,NAMEERR  DON'T ALLOW VER'S AND REPS\n         NI    CTLBTE,X'FF'-NAMEOP   TURN OFF NAME OPTION        YM5146\n        NI    CTLBTE2,X'FF'-TRAN      .RESET 'TRANSLATE' FLAG. @ZA02775\n         CLI   7(RG1),C'T'              TRANSLATE DESIRED\n         BC    7,ABDMP1B                NO-SKIP\n         OI    CTLBTE2,TRAN             SET TRANSLATE FLAG\nABDMP1B  XC    BASE(4),BASE             RESET FIELDS\n         XC    BASE2(4),BASE2\n         XC    START(4),START\n         LA    14,X'20'                 CONV RTN OFFSET\n         CLC   1(4,RG3),ALL           .TEST FOR 'ALL' REQUEST. @ZA19021\n         BC    8,ABDMP3                 YES-SKIP TO SET LIMITS\n         TM    1(RG3),X'F0'             IS THIS FIRST CHAR NUMERIC\n         BC    8+4,ABDMP6               NO-MEMBER DUMP ONLY\n         BAL   LNKRG2,CCHHSUB           DECODE INPUT CCHHR\n         BAL   LNKRG1,CHCONV            CONVERT TO TTR\n         ST    0,TTRSAVE                SAVE TEMP\n         BAL   LNKRG2,CCHSUB2           DECODE 2ND CCH\nABDMP2   LA    14,X'20'                 CONVERT RTN OFFSET\n         BAL   LNKRG1,CHCONV            CONVERT ABS TO TTR\nCONTA    MVC   STCSECT(4),TTRSAVE       EXCHANGE TTR'S\n         ST    0,TTRSAVE                SAVE FOR COMPARE\nABDMP5   DS    0C\n         MVC   MEMNAME(8),BLANKS        ZERO OUT FIRST LINE INFO\n         MVC   CSECT(8),BLANKS\n         LA    R1,ADMP1AA              TO DUMP RECORD            S21995\n         L     R15,ADMP                                          S21995\n         BALR  R14,R15                                           S21995\nCONTB    CLC   STCSECT(3),TTRSAVE       COMPLETED\n         BC    8+2,DUMP09               YES-PRINT MSG.\n         NI    LIB2+44,X'3F'            RESET IFLAGS IF ON DUE TO ERROR\n         CLI   DECB5,X'42'              END OF EXTENT\n         BC    8,DUMP09                 YES-END OPERATION\n         LA    LNKRG2,CONTB             RESET LINK REG           S21995\n         BC    15,DUMP1                 PRINT NEXT RECORD        S21995\n         SPACE 1\nCONT     L     R15,AIORTNS                                       S21995\n         CLI   DECB5,X'42'             EOD BECAUSE END OF EXTENT A43688\n         BE    DUMP09                  YES-END OPERATION         A43688\n         LA    R1,ADMP1E               WRITE EOD RECORD          S21995\n         L     R15,ADMP                                          S21995\n         BALR  R14,R15                                           S21995\n         TM    CTLBTE2,PSIND            IS IT A SEQUENTIAL DUMP\n         BO    DUMP09                   YES--DONE\n         LA    RG5,BLANKS\n         BAL   LNKRG1,WRITE0            TO SKIP LINE\n         LA    LNKRG2,CONTB             RESET LINK REGISTER\n         TM    CTLBTE2,MEMDMP           BUT WAS IT ONLY ONE MEMBER\n         BCR   8,LNKRG2                 NO-FULL DATASET\n         NI    CTLBTE2,X'FF'-MEMDMP     REST INDICATOR\n         BC    15,DUMP09                TO PRINT ENDING MESSAGE\n         SPACE 1\nABDMP3   L     RG2,LIB2+44              GET DEB ADDR\n         NI    CTLBTE,X'FF'-NAMEOP-ONEREC  RESET INDICATORS\n         XC    MBBCCHHR(8),MBBCCHHR     RESET ADDRESS\n         MVC   MBBCCHHR+3(4),STEXT(RG2) SET START ADDR.\n         MVI   MBBCCHHR+7,X'01'         SET FOR RECORD ONE READ\n         BAL   LNKRG1,CHCONV            CONVERT ABS TO TTR\n         ST    0,STCSECT                START ADDR (TTR)\n         MVC   JFCB(3),RDAREA+1         SET ADDR OF JFCB READ     M2820\n         ST    LNKRG3,LNKSAVE      SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         RDJFCB  (LIB2,(INPUT))         GET DDNAME\n         MVC   JFCB(3),JFCBAD+1         RESET EXIT LIST ADDR      M2820\n         L     R15,AIORTNS              RESET R15                S21995\n         L     RG2,LIB2+44              GET DEB ADDR AGAIN\n         L     RG2,X'20'(RG2)           GET UCB ADDR\n         LA    RG2,X'1C'(RG2)           POINT AT VOL SER\n         ST    RG2,OBLIST+8             SET ADDR IN LIST\n         L     RG2,RDAREA               DSNAME POINTER\n         ST    RG2,OBLIST+4             SET POINTER\n         LA    RG4,160(RG2)             SET WORK AREA\n         ST    RG4,OBLIST+12            SET WK AREA IN LIST\n         OBTAIN  OBLIST                 SET DSCB\n         L     R15,AIORTNS             RESET R15                 S21995\n         L     LNKRG3,LNKSAVE      RESTORE LNKRG3\n         NI    CTLBTE2,X'FF'-PSIND      RESET PHYSICAL SEQ DUMP\n         TM    DS1DSORG(RG4),PS         IS DATA SET SEQUENTIAL\n         BNO   TESTPO                   NO--TEST FOR PARTITIONED\n         OI    CTLBTE2,PSIND            YES--INDICATE SEQUENTIAL\nMAKEHI1  SR    RG5,RG5                  CLEAR REG FRO TTR\n         B     MAKEHI2                  GO SAVE TTR\nTESTPO   TM    DS1DSORG(RG4),PO         IS DATA SET PARTITIONED\n         BNO   MAKEHI1                  NO--DUMP TO END OF EXTENT\n         MVC   TTRSAVE(3),98-44(RG4)    SAVE END OF DATA SET\n         MVI   TTRSAVE+3,0              ZERO CONC. NO.\n         L     RG5,TTRSAVE              GET CONTENTS\n         LTR   RG5,RG5                  ZERO\n         BC    7,ABDMP5                 NO-USE\nMAKEHI2  BCTR  RG5,0               YES - MAKE END TTR HIGH\n         ST    RG5,TTRSAVE              YES - MAKE HIGH\n         MVI   TTRSAVE+3,0              ZERO OUT CONC NO.\n         BC    15,ABDMP5                DUMP ALL OF D.S.\n         SPACE 1\nABDMP6   BAL   LNKRG2,SCANKEY5          TO GET MEMBER NAME\n         ST    LNKRG3,LNKSAVE           SAVE LINK REGISTER\n         LA    LNKRG3,REGSAVE           ADDR OF REG SAVE AREA\n         FIND  LIB2,MEMNAME,D           POSITION AT FIRST RECORD\n         L     LNKRG3,LNKSAVE           RESTORE LNKRG3\n         LTR   15,15                    FOUND MEMBER\n         L     R15,AIORTNS             RESET R15                 S21995\n         BC    7,NAME03C                NO -TO PRINT MESSAGE\n         MVC   CSECT(8),BLANKS          CLDAR FIELD\n         OI    CTLBTE2,MEMDMP           SET CONTROL FLAG\n         BAL   LNKRG2,DUMP1             TO DUMP                  S21995\n         BC    15,DUMP1                 CONTINUE                 S21995\n         SPACE 1\nDSERROR  LA    RG5,DSMSG                DS NOT IN TEXT\n         BC    15,NAME14\n         SPACE 1\nNOCSECT  L     RG5,AMSG103I            .SELECT MESSAGE.        @ZA17658\n         L     R15,ACONT      IN CASE OF BAD INPUT, WE HAVE TO  YA01766\n         STM   0,15,DMPSAVE   SAVE THE REGS AND POINT REG15 TO  YA01766\n         L     R15,AIORTNS    LABEL 'CONT '                     YA01766\n         L     R15,AIORTNS              RESTORE R15              YM5146\n         BAL   LNKRG1,WRITE0\n         MVC   RETCODE(1),RETCOD08     .INDIC SPZAP-INP ERROR. @ZA06023\n         OI    CTLBTE,IGNOP+NAMEERR     IGNORE NXT REP AND VERIFY\n         BC    15,DUMP04\n         EJECT\nAMASZDMP CSECT\n         USING AMASZCON,BASREG2                                  S21995\n         L     R15,ACONT               PUT RETURN FROM EOF IN 15 YM5146\n         STM   0,15,DMPSAVE                                      S21995\n         L     R15,AIORTNS             RESET R15                 YM5146\n         BALR  BASREG,0                                          S21995\n         USING *,BASREG                                          S21995\nDMPBASE  DS    0H                      .('SZDMP' BASE ADDR).   @ZA09678\n         LA    R13,REGSAVE             SET REG SAVE AREA         S21995\n         LA    LNKRG2,GOBACK2          SET DUMP RETURN           S21995\n         B     VECTOR2(R1)             BRANCH ON INDEX R1        S21995\nVECTOR2  B     DUMP01AA                                          S21995\n         B     DUMP01                                            S21995\n         B     DUMP01E                                           S21995\n         B     DUMP01AB                                          S21995\nGOBACK2  LM    0,15,DMPSAVE            RESTORE REGS              S21995\n         L     R15,AIORTNS             RESET R15                 YM5146\n         BR    R14                     RETURN                    S21995\n*      INITIALIZE  REGISTERS  FOR  DUMP  FORMAT  PROGRAMS\nDUMPCOM  L     WK6,TBUF+8               INIT TO DATA PTR\nDUMPCOM1 MVC   CDBUF(48),BLANKS         CLEAR BUFFER\n         MVC   CDBUF+48(32),BLANKS\n         LA    WK3,CDBUF+10             SET INITIAL BUFFER PTR\n         LA    WK4,8                    SET WORD COUNTER\n         BCR   15,LNKRG1                RETURN\n         SPACE 1\nDUMP01AA POINT LIB2,STCSECT             POSITION AT TXT RECORD\n         L     R15,AIORTNS             RESET R15                 S21995\n         SPACE 2\n***********************************************************************\nDUMP01   LA    RG5,BLANKS\n         LA    R1,AWRITE0A             TO SKIP LINE              S21995\n         BALR  R14,R15                                           S21995\n         LA    R1,ARDDSK2               READ TXT RECORD          S21995\n         BALR  R14,R15                                           S21995\nDUMP01E  BAL   LNKRG1,CCHNOTEA          TO SET UP CCHHR ADDR     S21995\n         SPACE 1\n         MVC   CDBUF(100),TITLE1\n         L     WK6,STARTINC             GET OFFSET\n         LA    WK6,RDAREA1(WK6)         ADD TO RDAREA1\n         L     RG3,DECB5+16             GET IOB POINTER\n         SR    WK2,WK2                  CLEAR REGISTER\n         IC    WK2,LIB2+16              GET KEY LENGTH\n         L     WK1,SIZE                 GET MAX SIZE OF RECORD\n         AR    WK1,WK2                  ADD TO BUFFER ADDR\n         XC    TBUF(2),TBUF             SET BEGINNING TO 0       A41640\n         MVC   TBUF+2(2),14(RG3)        MOVE RESIDUAL COUNT      A41640\n         S     WK1,TBUF                 GET SIZE READ            A41640\n         TM    CTLBTE2,MEMDMP           MEMBER DUMP ONLY\n         BC    1,DUMP01AC               YES-SKIP AROUND\n         CLC   MEMNAME(8),BLANKS        ABSOLUTE DUMP\n         BC    7,DUMP01AB               NO -SKIP LENGTH CALC\n* ABSDUMP. TEST FOR EXTRA RECD DUE TO ENDADDR RECD# GT LAST    @ZA09678\n         CLC   STCSECT(3),TTRSAVE      . RECD OF TRACK.        @ZA09678\n         BNH   DUMP01F                 .IF NOT, CONTINUE DUMP. @ZA09678\n         LM    0,15,DMPSAVE            .IF SO,                 @ZA09678\n         L     R15,AIORTNS             . TERMINATE DUMP.       @ZA09678\n         USING ZAPBASE2,BASREG         .('SPZAP' ADDRESSING).  @ZA09678\n         B     DUMP09                                          @ZA09678\n         DROP  BASREG                  .(END 'SPZAP' ADDRING). @ZA09678\n         USING DMPBASE,BASREG          .(RESUME 'DMP' ADDRNG). @ZA09678\nDUMP01F  DS    0H                      .(CONTINUE ABSDUMP).    @ZA09678\n         MVC   CDBUF+X'32'(37),BLANKS   WIPE OUT CSECT LABEL\nDUMP01AC DS    0C\n         MVC   CDBUF+X'49'(14),BLANKS    BLANK OUT CSECT TITLE   S21995\n         ST    WK1,LENGTH               STORE RECORD COUNT\nDUMP01AB LR    WK2,WK6\n         A     WK2,LENGTH               STOP ADDRESS\n         ST    WK1,LENGTH               STORE NEW COUNT IF ABS DUMP\n         UNPK  CDBUF+9(11),MBBCCHHR+3(6)\n         TR    CDBUF+9(10),TRANTBL2-X'F0'\n         MVI   CDBUF+19,BLANK\n         UNPK  CDBUF+37(5),LENGTH+2(3)\n         TR    CDBUF+37(4),TRANTBL2-X'F0'\n         MVI   CDBUF+41,BLANK\n         BAL   LNKRG1,WRITEB            PRINT HEADER             S21995\n         OC    LENGTH+2(2),LENGTH+2     END OF FILE\n         BCR   8,LNKRG2                 YES- RETURN\n         L     WK1,START\n         S     WK1,BASE\nDUMP02   BAL   LNKRG1,DUMPCOM1          INITIALIZE REGISTERS\n         ST    WK6,TBUF+8               SAVE LOC OF LINE START\n         ST    WK1,TBUF                 OFFSET ADDRESS\n         UNPK  CDBUF+1(7),TBUF+1(4)     CSECT OFFSET\n         TR    CDBUF+1(6),TRANTBL2-X'F0'\n         MVI   CDBUF+7,BLANK            RESET LAST UNPACK\nDUMP02B  LA    WK5,4                    CHAR COUNT\nDUMP02C  UNPK  0(3,WK3),0(2,WK6)        UNPACK CHAR.\n         TR    0(2,WK3),TRANTBL2-X'F0'\n         MVI   2(WK3),BLANK             RESET SIGN OF UNPACK\n         LA    WK3,2(WK3)               CDBUF ADDRESS\n         LA    WK6,1(WK6)               TEXT ADDRESS\n         CR    WK6,WK2                  STOP ADDR\n         BC    8+2,DUMP08               DONE-YES EXIT\n         TM    CTLBTE2,TRAN             CHECK FOR HALFWORD SEP\n         BC    1,DUMP03B                YES-OUT TO CHECK\nDUMP03A  BCT   WK5,DUMP02C              CONTINUE WITH FIRST LOOP\n         CH    WK4,FIVE                 MIDDLE OF PAGE\n         BC    8,DUMP03                 YES - SET ADDRESS IN DUMP\n         LA    WK3,3(WK3)               INC PAST BLANKS\n         TM    CTLBTE2,TRAN             TRAN DUMP\n         BC    8,DUMP02D                NO-LET INCR STAND\n         BCTR  WK3,0                    YES-CHANGE FORMAT\nDUMP02D  DS    0C\n         BCT   WK4,DUMP02B              SECOND LOOP\n         TM    CTLBTE2,TRAN             TEST FOR TRANSLATE OPTION\n         BC    1,GRAP1                  YES-CONTINIUE WITH LINE\n         BAL   LNKRG1,WRITEB            NO-PRINT THIS ONE        S21995\nDUMP02E  LA    WK1,32(WK1)              INCR. READ POINTER\n         BC    15,DUMP02                NEXT LINE\n         SPACE 1\nDUMP03B  CH    WK5,THREE                HALFWORD SEPARATOR\n         BC    7,DUMP03A                NO-CONTINUE WITH WORD\n         LA    WK3,1(WK3)               LEAVE BLANK SEP.\n         BCT   WK5,DUMP02C              CONTINUE\n         SPACE 1\nDUMP03   LA    WK3,5(WK3)               INCR PAST MIDDLE OF PAGE\n         BCT   WK4,DUMP02B              DECR. COUNTER\n         SPACE 2\nDUMP08   TM    CTLBTE2,TRAN             TEST FOR TRANSLATE OPTION\n         BC    1,GRAP1                  TO DECODE GRAPHICS\n         BAL   LNKRG1,WRITEB            PRINT LAST LINE          S21995\n         TM    CTLBTE,ENDMOD            TEST FOR LAST TEXT RECORD\n         BCR   15,LNKRG2                END OF SUBROUTINE\n*      THIS  SUBROUTINE  TRANSLATES  DATA  INTO  INSTRUCTIONS\n         SPACE 1\nINSTR7   AR    WK7,WK7                  MULTIPLY AGAIN BY2\n         AR    WK7,WK7                  DOUBLE AGAIN =X4\n         LA    WK7,FOURC-X'108'(WK7)    GET MNEMONIC\n         MVC   0(4,WK3),0(WK7)          MOVE INTO OUTPUT BUFFER\n         BC    15,INSTR3                BACK\nTRANS5   MH    WK7,FIVE            MULTIPLY OFFSET BY 5           M1148\n         LA    WK7,FIVEC-X'410'(WK7)   GET ADDR OF MNEMONIC       M1148\n         CH    WK5,ONE             IN MIDDLE OF HALFWORD PAIR     M1148\n         BE    MOVE5               YES,RUN MNEMONIC OVER END      M1148\n         BCTR  WK3,0               NO,BACK UP POSITION            M1148\n         MVC   0(5,WK3),0(WK7)     MOVE MNEMONIC INTO BUFFER      M1148\n         LA    WK3,1(WK3)          MOVE BUFFER PTR BACK TO ORIGIN M1148\n         B     INSTR3              BACK                           M1148\nMOVE5    MVC   0(5,WK3),0(WK7)     MOVE MNEMONIC TO BUFFER        M1148\n         B     INSTR3                                             M1148\n         SPACE 1\nINSTR6   LA    WK3,5(WK3)               INCR BUFFER PTR\n         BCT   4,INSTR1                 BAD WITH REST OF PAGE\n         SPACE 1\nINSTR8   LA    WK3,1(WK3)               SPACE BETWEEN HALF WORDS\n         BC    15,INSTR2                CONTINUE WITH WORD\nTWOBYTES IC    WK7,0(WK6)          GET 2ND BYTE                   M1148\n         BCTR  WK6,0               GET BACK TO OP CODE            M1148\n         CLI   0(WK6),X'B2'        IS IT A B2XX OP CODEP          M1148\n         BNE   BYTE29C                 NO, TRY ANOTHER TWO BYTER  M1148\n         CLC   1(1,WK6),MAXB2          CHECK MAX SIZE OF BYTE 2  S21995\n         BH    DXRCK                   CHECK FOR DXR INSTRUCTION X01979\n         IC    WK7,B2TAB(WK7)          GET TABLE INCREMENT        M1148\nBYTE2EX  LA    WK6,1(WK6)              RESET POINTER              M1148\n         B     TABCHK                  GO GET MNEMONIC            M1148\nDXRCK    CLI   1(WK6),X'2D'            IS IT A DXR               X01979\n         BNE   TOOHI                   NO--2ND BYTE IS TOO BIG   X01979\n         LA    WK7,X'AA'               YES--SET OFFSET INTO TABLEX01979\n         B     BYTE2EX                 GO GET MNEMONIC           X01979\nTOOHI    SR    WK7,WK7                 SET WK7 TO NO OP          S21995\n         B     BYTE2EX                 GO GET BLANK MNEMONIC     S21995\nBYTE29C  N     WK7,BYTE2MSK            REMOVE 7 HI BITS OF OPCODE BYTE2\n         CLI   0(WK6),X'9C'            IS IT 9CXX                 M1148\n         BNE   BYTE29D                 NO, TRY NEXT              YM5533\n         IC    WK7,TAB9C(WK7)          GET TABLE INCREMENT        M1148\n         B     BYTE2EX                 GO GET MNEMONIC            M1148\nBYTE29D  CLI   0(WK6),X'9D'            IS IT 9DXX                YM5533\n         BNE   BYTE29E                 NO,TRY NEXT               YM5533\n         IC    WK7,TAB9D(WK7)          GET TABLE OFFSET          YM5533\n         B     BYTE2EX                 GO GET MNEMONIC           YM5533\nBYTE29E  CLI   0(WK6),X'9E'            IS IT 9EXX                YM5533\n         BNE   BYTE2XX                 NO,TRY NEXT               YM5533\n         IC    WK7,TAB9E(WK7)          GET TABLE OFFSET          YM5533\n         B     BYTE2EX                 GO GET MNEMONIC           YM5533\nBYTE2XX  SR    WK7,WK7                 DEAD END .. NO MNEMONIC    M1148\n         B     BYTE2EX                 RETURN                     M1148\n         SPACE 1\nINSTR0   BAL   LNKRG1,DUMPCOM           INITIALIZE REGISTERS\nINSTR1   LA    WK5,2                    INSTR. COUNTER\nINSTR2   SR    WK7,WK7                  CLEAR REGISTER\n         IC    WK7,0(WK6)               GET INSTR. OP CODE\n         LA    WK6,1(WK6)               INCR. DATA LIST\n         CR    WK6,WK2                  STOP\n         BC    8+2,INSTR5               YES-DONT UNPACK ONE BYTE INSTR.\n         IC    WK7,TRAN2(WK7)           GET INDEX TO TABLE\n         CH    WK7,TWOBYTOP        SHOULD WE LOOK AT 2ND BYTE     M1148\n         BE    TWOBYTES            YES - PROCESS 2ND BYTE         M1148\nTABCHK   CH    WK7,FIVECHAR        FIVE CHARACTER OP CODE         M1148\n         BC    8+2,TRANS5          YES,MOVE 5 CHARS               M1148\n         CH    WK7,TWOHIGH              TEST FOR WHICH TABLE\n         BC    8+2,INSTR7               GET FOUR CHARATER TABLE\n         AR    WK7,WK7                  DOUBLE INDEX\n         LA    WK7,TWOC(WK7)            GET ADDRESS\n         MVC   0(2,WK3),0(WK7)          SET IN MNEMONIC\nINSTR3   LA    WK6,1(WK6)               INCR. PAST HALF WORD\n         CR    WK6,WK2                  END\n         BC    8+2,INSTR5               YES - TO PRINT LINE\n         LA    WK3,4(WK3)               INCR. OUTPUT BUFFER\n         BCT   WK5,INSTR8               SPACE TO SEPR. HALFWORDS\n         CH    WK4,FIVE                 MIDDLE OF PAGE\n         BC    8,INSTR6                 YES - SET TITLE\n         LA    WK3,2(WK3)               NO-INCR TO NXT WORD\n         BCT   WK4,INSTR1               END OF LINE - NO NXTWORD\nINSTR5   L     WK6,TBUF+8               GET DATA POINTER\n         LA    WK6,X'10'(WK6)           INCR BY ONE LINE\n         LA    LNKRG1,DUMP02E           RETURN ADDRESS\n         CR    WK6,WK2                  STOP ADDRESS           @ZA28392\n         BC    8+2,GRAP8                YES, THEN EXIT         @ZA28392\n         BC    15,GRAP1B\nGRAP1    LA    LNKRG1,INSTR0            INIT. RET REG-2ND LINE\n         L     WK6,TBUF+8               INITIAL DATA POINTER\nGRAP1B   MVI   CDBUF+102,C'*'           SET DELIMITER\n         MVI   CDBUF+119,C'*'    PLACE ASTERISK AT END OF LINE @ZA28392\n         LA    WK3,CDBUF+103            INITIALIZE TO BUFFER POSITION\n         LA    WK5,16                   CHAR COUNTER\nGRAP2    CLI   0(WK6),BLANK             TEST CHARACTER\n         BC    4,GRAP3                  INVALID GRAPIC - YES\n         CLI   0(WK6),X'7F'             WITHIN SECTION\n         BC    8+4,GRAP5                YES - TRANSLATE\n         LA    WK7,GRAPT2-C'A'          TRANSLATE TABLE\n         CLI   0(WK6),C'A'              NORMAL GRAPHICS\n         BC    8+2,GRAP6                YES - TRANSLATE\nGRAP3    MVI   0(WK3),C'.'              NO-SET AS INVALID\nGRAP3B   LA    WK6,1(WK6)               INCR DATA POINTER\n         CR    WK6,WK2                  STOP ADDR\n         BC    8+2,GRAP8                DONE - YES EXIT\n         LA    WK3,1(WK3)               INCR. BUFFER PTR\n         BCT   WK5,GRAP2                CONTINUE WITH LINE\n         BC    15,WRITEB                WRITE & RETURN ON LK2    S21995\n         SPACE 1\nGRAP5    LA    WK7,GRAPT1-BLANK         TRANSLATE TABLE ADDR\nGRAP6    MVC   0(1,WK3),0(WK6)          SET IN BUFFER\n         TR    0(1,WK3),0(WK7)          SET IN BUFFER\n         BC    15,GRAP3B                CONTINE\n         SPACE 1\nGRAP8    C     LNKRG1,RETAD        TO SEE IF HAVE TO TRANS OP CDS M1149\n         BC    8,WRITEB  YES - PRINT LINE AND RETURN ON LKRG1     M1149\n         BAL   LNKRG1,WRITEB     NO - PRINT LINE AND RETURN HERE  M1149\n         TM    CTLBTE,ENDMOD            TEXT FOR LAST TEXT RECORD\n         BCR   15,LNKRG2                RETURN\n         SPACE 1\nWRITEB   LA    R1,AWRITEA              SET INDEX FOR WRITE       S21995\n         LR    R14,LNKRG1              SET RETURN REG            S21995\n         BR    R15                     BRANCH TO WRITE           S21995\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE OBTAINS THE TEXT TTR AND CONVERTS IT TO CCHHR\n***********************************************************************\nCCHNOTEA NOTE  LIB2                                              S21995\n         L     R15,AIORTNS             RESET R15                 S21995\n         ST    1,STCSECT                SAVE TTR                 S21995\n         LR    0,1                      CONVERT TTR INPUT REG    S21995\n         LA    14,X'1C'                 TTR CONV RTN OFFSET      S21995\n         STM   8,13,TBUF+32             SAVE REGS                S21995\n         LA    8,TBUF+32                GET ADDRESSIBILITY       S21995\n         LA    2,MBBCCHHR               CONVERT STG ADDR.        S21995\n         L     1,LIB2+44                DEB ADDRESS              S21995\n         L     15,16                    CVT POINTER              S21995\n         L     15,0(14,15)              CONVERT RTN ADDR         S21995\n         BALR  14,15                    TO CONVERT TO CCHHR      S21995\n         LM    8,13,0(8)                RESTORE REGISTERS        S21995\n         L     R15,AIORTNS              RESET R15                S21995\n         BCR   15,LNKRG1                RETURN                   S21995\n         EJECT\n***********************************************************************\nAMASZCON CSECT\n***********************************************************************\nTEMPDBLW DC    D'0'                    .(ALIGNED DOUBLEWORD).  @ZA00409\nRDAREA   DC    A(0)                     START OF DSECT\nSIZE     DC    A(0)                     LENGTH OF RECORD\nSCARG    DC    XL8'0'                   SEARCH ARGUMENT\nTTRSAVE  DC    F'0'                       SAVE AREA FOR TTR      YM5532\nIDSAVE   DC    A(0)                     SECONDARY SAVE FOR ALL DUMP\nIDSAVE2  DC    A(0)                     SAVE AREA FOR ALL DUMP\nSTARTINC DC    A(0)                     ACCM1 OFFSET\nBASE2    DC    A(0)                     ADDITIONAL OFFSET SUPPLIED\nCSECTID  DC    A(0)                     CSECT IO INDEX\nSTART    DC    A(0)                     TEXT START ADDRESS\nLENGTH   DC    A(0)                     LENGTH OF TEXT\nBASE     DC    A(0)                     CSECT BASE ADDRESS\nSTCSECT  DC    A(0)                     CSECT NOTE ADDRESS\nAIORTNS  DC    V(AMASZIOR)              ADDR OF I/O SUBRTN CSECT S21995\nACHSUM   DC    A(CHSUM)      .ADDR CHECKSUM-STMT PROCESSOR.    @ZA17660\nCON1     DC    A(TBUF-1)                INIT ADDR OF BUF\nCON3     DC    A(DBUFEND)               CONST FOR LOOP CONTL.\nOFFSET   DC    A(0)                     PATCH OFFSET FROM RECORD START\nRETAD    DC    A(INSTR0)                                          M1149\nCDBUFEND DC    A(CDBUF+72)              END OF BUFFER          @YA02260\nZERO     DC    2F'0'                                             Y02160\nTEMP     DS    2F                      SAVEAREA FOR CSECT NAME   A42310\nADMP     DC    V(AMASZDMP)              ADDRESS OF DUMP CSECT    S21995\nACONT    DC    A(CONT)                 LIB2 EOD IN MAIN CSECT    S21995\nAIOBASE  DC    A(IOBASE)               I/O CSECT BASE ADDRESS    S21995\nAINSM2   DC    A(INSM2)                 ADDR OF GET SSI RTN      X01979\nJFCBAD   DC    A(JFCBAREA)              TO RESET ADDR IN EXITLIST M1733\nAWTORTN  DC    A(WTORTN)               .ADDR 'WTO' INTERFACE.  @ZA00409\nACCISCAN DC    A(CCISCAN)    .ADDR INIT-CARD-SCAN SUBROUTINE.  @ZA17658\nIDRNRECS DC    F'0'                    .CURR # IDR RECORDS.    @ZA00409\nIDRNENTS DC    F'0'                    .CURR # IDR ENTRIES.    @ZA00409\nIDRMENTS DC    F'0'                    .MAX # IDR ENTRIES.     @ZA00409\nIDRMENTR DC    F'19'                   .MAX ENTS PER RECD.     @ZA00409\n         DS    0F\nBYTE2MSK DC    X'00000001'             MASK FOR BYTE2 9C 9E OPCD S21995\nCLER     DC    X'0000FFFF'\nMBBCCHHR DC    XL8'0'                   SEEK ADDRESS\nMSK      DC    X'0C40'                  CSW STATUS\nONE      DC    H'1'                                               M1148\nTHREE    DC    H'3'                     HALFWORD COUNTER\nFIVE     DC    H'5'                     MIDDLE OF PAGE COUNTER\nEIGHT    DC    H'8'                                            @ZA17660\nTW2      DC    H'22'\nTHIRTY   DC    H'30'\nTWENTY4  DC    H'24'                                             Y02160\nTHIRTY2  DC    H'32'\nFOURTY   DC    H'40'\nSEVEN    DC    AL2(7)                   CONSTANT\nTWOHIGH  DC    X'0042'                  HIGHEST TWO CHAR INDEX\nTWOBYTOP DC    X'00FF'                 TWO BYTE OP CODE INDICATOR M1148\nDESCR    DC    X'0800'                 DESCR CODE 5 FOR WTORTN\nRTCD     DC    X'4000'             ROUTING CODE 2 FOR WTORTN\nIOMSGLNG DC    H'64'               LENGTH OF I/O ERROR MSGS\nERRMGLNG DC    H'45'               LENGTH OF OPERATION ERROR MSGS\nTITLE1   DC    CL9'**CCHHR-'\nCCHHRP   DC    XL10'0'\n         DC    CL18'   RECORD LENGTH- '\nRCLGTH   DC    XL4'0'\n         DC    CL9' '\n         DC    CL15'  MEMBER NAME  '\nMEMNAME  DC    XL8'0'\n         DC    CL14'  CSECT NAME  '\nCSECT    DC    XL8'0'\n         DC    CL5' '\nBLANKS   DC    2CL24' '\nIDRSIZE  DC    H'251'                  LENGTH OF SPZAP IDR REC   S21016\nIDRDATA  DS    2F                      IDRDATA CARD SAVE AREA    S21016\nIDRTTR   DS    F                       IDR REC TTR               S21016\nIDRFSEEK DS    2F                      IDR REC MBBCCHHR          S21016\nCOUNT    DC    XL8'00'            FOR READING COUNT              YM5534\nTEMPRG3  DS    F                        TEMPORARY STORAGE FOR RG3X01979\nTEMPRG5  DS    F                        TEMPORARY STORAGE FOR RG5X01979\nMSGOFSET DC    F'0'                     STORAGE FOR UNPATCH MESSAGE\n*                                         OFFSET                 X01979\nCON2     DC    18XL4'1F1F1F1F'          MASK FORTRAN\nCTLBTE   DC    X'40'         CONTROL  BYTE\nCTLBTE2  DC    X'00'                    MODIFY MEMBER BYTE\nCTLBTE3  DC    X'00'\nPARMBITS DC    X'00'                    .PARM/PARAM BITS.      @ZA06024\nQIGNIDRF EQU   X'80'                    .1 = IGNORE FULL IDR.  @ZA06024\nQPARMERR EQU   X'01'                    .1 = PARAM-VAL ERROR.  @ZA06024\nCONSW    DC    X'00'\nCONSW2   DC    X'00'         .X'FF' IF MSG SYSPRINT AND WTO.   @ZA17659\nDMPSW    DC    X'00'         .X'FF' TO INHIBIT WTO DUR DUMPS.  @ZA26077\nRSVSW    DC    X'00'\nSCANSW   DC    X'00'               SW SET IN SCAN MBR/CSECT NAME A48705\n* RETURN-CODE STORAGE AND CONSTANTS.                           @ZA06023\nRETCODE  DC    X'00'                    .CODE FOR LATEST EVENT @ZA06023\nRETCOD00 DC    X'00'                    .(NO ERROR OR WARNING) @ZA06023\nRETCOD04 DC    X'04'                    .(WARNING ONLY).       @ZA06023\nRETCOD08 DC    X'08'                    .(SPZAP-INPUT ERROR).  @ZA06023\nRETCOD12 DC    X'0C'                    .(JCL OR PARAM ERROR). @ZA06023\nRETCOD16 DC    X'10'                    .(PERM I/O ERROR).     @ZA06023\nLASTRET  DC    X'00'                    STEP RETURN CODE\n*  RESERVE PARMLIST                                             A41228*\nUCBAD    DS    1F\nQNAME    DC    CL8'SYSVTOC '       MAJOR NAME FOR RESERVE        YM5147\nRNAME    DS    6C                  MINOR NAME FOR RESERVE        YM5147\n         DS    0F\nMAJOR    DC    CL8'SPZAPLIB'\nJFCBAREA DS    176C                44 BYTE DSNAME USED FOR MINOR\nDBUF     DS    CL36\nDBUFEND  DS    0C                       END OF DATA BUFFER\n         DS    CL36                     PAD\n         DS    0F\nLIST     DC    H'01'                    NO OF ENTRIES\n         DC    H'70'                    MAX LENGTH OF DIR ENTRIES\nTBUF     DS    CL72                     TEMP STG OF DATA\n         DS    CL7                      OVERLAP AREA FROM MOVE\nWTOECB   DC    F'0'\nLNKSAVE  DC    F'0'\nREGSAVE  DS    18F\nDMPSAVE  DS    16F                     DUMP CSECT SAVE AREA      S21995\nXFERSAVE DS    16F                     I/O CSECT SAVEAREA        S21995\nTEMPSAV  DC    6F'0'               TEMPORARY SAVE AREA           S21995\nADDRSV   DC    F'0'                    TIOT ADDR SAVE AREA       A38645\nDEVBUF   DC    5F'0'                   .DATA FROM 'DEVTYPE'.   @ZA02777\nTRKSIZE  EQU   DEVBUF+12               .TRACKSIZE.             @ZA02777\nLNKSAVE2 DC    F'0'                    TEMP SAVE AREA FOR LNKRG1 A38645\nLNKSAVE3 DC    F'0'                    TEMP SAVE AREA FOR LNKRG1 A38645\nSVLNGTH  DC    F'0'                    LENGTH OF SCAN FIELD       M0509\nCHSUMACC DC    F'0'          .CHECKSUM ACCUMULATOR.            @ZA17660\nCHSUMSLL DC    H'0'          .VAR SHIFT AMT FOR CHECKSUM.      @ZA17660\n         DS    0F\nPREFIX   DC    H'0'                PREFIX FOR WTO BUFFER CDBUF\n         DC    X'8000'             ROUTER AND DESCR CODES FOLLOW\n         DC    C'1'                     ASA CONTROL CHAR\nCDBUF    DC    CL32'AMASPZAP  INSPECTS, MODIFIES, AN'            X01979\n         DC    CL32'D DUMPS CSECTS OR SPECIFIC DATA '            X01979\n         DC    CL32'RECORDS ON DIRECT ACCESS STORAGE'            X01979\n         DC    CL24'.'                                           X01979\n         DS    5C\nFIVECHAR DC    X'00D0'                 OFFSET FOR 5 CHAR OPS      M1148\nB2TAB    DC    X'0000D1D29A9BA7D4A8A9B2B100A50000'               YM5533\n         DC    X'ACAFAEA6'             B2XX MNEMONIC OFFSETS     YM5533\n*              DXR INSTRUCTION IS VALIDATED AT LABEL 'DXRCK'\nTAB9C    DC    X'83AB'                 9CXX MNEMONIC OFFSETS      M1148\nTAB9D    DC    X'84D3'                 9DXX MNEMONIC OFFSETS     YM5533\nTAB9E    DC    X'85A1'                 9EXX MNEMONIC OFFSETS      M1148\nMAXB2    DC    X'13'                   NO OF ENTRIES IN 'B2TAB'  X01979\nTRANTBL  DC    X'00FAFBFCFDFEFF'\n         DS    9C\nTRANTBL2 DC    C'0123456789ABCDEF'\n         DS    0H\n****  INSTRUCTION MNEMONICS - TWO CHARACTERS\nTWOC     DC    C'  NRORXRLRCRARSRMRDRLAICEXBCLHCH'\n         DC    C'AHSHMHSTN CLO X L C A S M D ALSL'\n         DC    C'LDCDADSDMDDDAWSWLECEAESEMEDEAUSU'\n         DC    C'TMTSNIOIXILMNCOCXCTREDCPAPSPMPDP'\n         DC    C'MCCS'                                           YM5533\n****  INSTRUCTION MNEMONICS - FOUR CHARACTERS\nFOURC    DC    C'SPM BALRBCTRBCR SSK ISK SVC LPR '\n         DC    C'LNR LTR LCR CLR ALR SLR LPDRLNDR'\n         DC    C'LTDRLCDRHDR LDR CDR ADR SDR MDR '                M1148\n         DC    C'DDR AWR SWR LPERLNERLTERLCERHER '                M1148\n         DC    C'LER CER AER SER MER DER AUR SUR '\n         DC    C'STH STC BAL BCT CVD CVB STD STE '\n         DC    C'SSM LPSWWRD RDD BXH BXLESRL SLL '\n         DC    C'SRA SLA SRDLSLDLSRDASLDASTM MVI '\n         DC    C'CLI SIO TIO HIO TCH MVN MVC MVZ '\n         DC    C'CLC TRT EDMKMVO PACKUNPKZAP MVCL'                M1148\n         DC    C'CLCLLRDRMXR MXDRLRERAXR SXR MXD '                M1148\n         DC    C'SCK STCKLCTLCLM STCMICM SRP HDV '                M1148\n         DC    C'BAS BASRLRA PTLBRRB SCKCSPT STPT'               X01979\n         DC    C'DXR SIOFSPX SIGPSTAPSTPXCDS IPK '               YM5533\n         DC    C'SPKA'                                           YM5533\n****  INSTRUCTION MNEMONICS - FIVE CHARACTERS\n*****    BLANK SLOT IN FIVEC TABLE MAY BE REUSED\nFIVEC    DC    C'STCTLSTIDPSTIDCCLRIOSTCKCSTNSMSTOSM'            YM5533\n****  INDEXES FOR MNEMONIC TABLES\n*        A. 00 IS BLANK MNEMONIC\n*        B. 01 TO 40 IS TWO CHARACTER\n*        C. 42 TO CF IS FOUR CHARACTER\n*        D. D0 TO FE IS FIVE CHARACTER\n*        E. FF INDICATES TWO BYTE OP CODE\nTRAN2    DC    X'00000000424344454647480000A39192'               X01979\n         DC    X'494A4B4C014D02030405060708094E4F'                M1148\n         DC    X'505152535493949555565758595A5B5C'                M1148\n         DC    X'5D5E5F60619697986263646566676869'                M1148\n         DC    X'6A0A6B0B0C6C6D0D0E0F101112A26E6F'               X01979\n         DC    X'130000001415161718191A1B1C1D1E1F'\n         DC    X'70000000000000992021222324252627'                M1148\n         DC    X'710000000000000028292A2B2C2D2E2F'\n         DC    X'720073007475767778797A7B7C7D7E7F'\n         DC    X'803081313282333435000000FFFFFF86'               YM5533\n         DC    X'000000000000000000000000D5D6AD40'               YM5533\n         DC    X'00A4FF000000D09C000041B0009D9E9F'               YM5533\n         DC    X'00000000000000000000000000000000'\n         DC    X'00878889368A373800000000398B3A8C'\n         DC    X'00000000000000000000000000000000'\n         DC    X'A08D8E8F00000000903B3C3D3E3F0000'                M1148\nGRAPT1   DC    X'404B4B4B4B4B4B4B4B4B4A4B4C4D4E4F'\n         DC    X'504B4B4B4B4B4B4B4B4B5A5B5C5D5E5F'\n         DC    X'60614B4B4B4B4B4B4B4B4B6B6C6D6E6F'\n         DC    X'4B4B4B4B4B4B4B4B4B4B7A7B7C7D7E7F'\nGRAPT2   DC    C'ABCDEFGHI.......JKLMNOPQR'\n         DC    C'........STUVWXYZ......012'\n         DC    C'3456789.......'\n*                                                              @ZA00409\nCARDSAVE DC    CL80' '        .SAVE CARD IMAGE OVER INSMDFY.   @ZA00409\n         SPACE 2\n***********************************************************************\n*                       KEYWORD CONSTANTS\n         SPACE 1\nALL      DC    CL4'ALL '     .(DUMP/ABSDUMP) ALL (CSECTS/MEMS) @ZA19021\nEND      DC    CL3'END'                 END CONSOLE INPUT\nREP      DC    CL3'REP'                 REPLACE KEY WORD\nSLAST    DC    CL3'/*'                  END OF INPUT KEY WORD\nBASEO    DC    CL4'BASE'                BASE KEY WORD\nDUMP     DC    CL4'DUMP'                DUMP KEY WORD\nNAME     DC    CL4'NAME'                NAME KEY WORD\nCCHHR    DC    CL5'CCHHR'               ABSOLUTE UPDATE KEY WORD\nSSI      DC    CL6'SETSSI'              SSI KEY WORD\nVERIFY   DC    CL6'VERIFY'              VERIFY KEY WORD\nABSDUMP  DC    CL7'ABSDUMP'             ABSOLUTE DUMP KEY WORD\nCONSOLE  DC    CL7'CONSOLE'             CONSOLE KEY WORD\nCHECKSUM DC    CL8'CHECKSUM'                                   @ZA17660\nF4DSCB   DC    CL12'FORMAT4.DSCB'       VTOC KEY WORD\nDSCBDS   DC    44XL1'04'                VTOC DSNAME\nF4BLKSZ  DC    H'144'                   NON-0 BLKSIZE            XM5390\nSYSLIB   DC    CL8'SYSLIB'                                       A38645\nIDRDFLT  DC    C'NO IDENT'             DEFAULT IDR DATA          S21016\nIDRDATAC DC    C'IDRDATA'              IDRDATA KEYWORD           S21016\n* PARAMETER TO OVERRIDE IDR-FULL INHIBITION ON CSECT 'REP'S.   @ZA06024\nPARM0STR DC    C'IGNIDRFULL'            .(CODED-VALUE STRING). @ZA06024\nPARM0LEN DC    H'10'                    .(LENGTH)              @ZA06024\nZPRM0LEN EQU   10                       .(LENGTH EQUATE).      @ZA06024\n         SPACE 2\n***********************************************************************\n*                       MESSAGES\n         SPACE 1\nDSMSG    DC    CL40'AMA107I DS AREA NOT INCLUDED IN TEXT'\nINERR    DC    CL40'AMA108I SYSIN SPECIFICATION ERROR'           S21995\nDGERROR  DC    CL40'AMA109I ERROR - ODD NO. DIGITS - IGNORED'\nSSIERR   DC    CL40'AMA110I NO DIRECTORY SSI- SETSSI IGNORED'\nIGNORSSI DC    CL40'AMA111I PREVIOUS ERROR - SETSSI IGNORED'\nNONAME   DC    CL40'AMA112I MEMBER NOT FOUND- SETSSI IGNORED'\nDMPCMP   DC    CL40'AMA113I COMPLETED DUMP REQUIREMENTS'\nNOVTOC   DC    CL40'AMA114I PERMISSION TO UPDATE VTOC DENIED'\nINPUTERR DC    CL26'AMA115I SYSIN I/O ERROR  '                   S21995\nNOIDR    DC    CL40'AMA119I NO IDR FOR MODULE'                   S21016\nNOSPACE  DC    CL8'AMA120I '          .'NO IDR SPACE' MESSAGE. @ZA00409\nNOSPACE1 DC    CL32'XXXXXXXX NO IDR SPACE - RE-LINK '          @ZA00409\nMSGIDRUD DC    CL28'AMA125I XXXXXXXX IDR COUNT ='  .IDR        @ZA00409\nIDRNENTZ DC    CL8' NN (MAX'                       . UPDATE    @ZA00409\nIDRMENTZ DC    CL4'=MM)'                           . MESSAGE.  @ZA00409\nIDRFULL  DC    CL40'AMA126I XXXXXXXX IDR(S) FILLED - RE-LINK'  @ZA00409\nUNPATMSG DC    CL20'AMA122I OLD DATA WAS'                        X01979\nBLKSZERR DC    CL40'AMA124I INVALID SYSLIB DCB BLOCKSIZE'        SM1465\nMSGUDINH DC    CL40'AMA127I UPDATES INHIBITED (NO OVERRIDE) '  @ZA06024\nMSGUDACC DC    CL40'AMA128I UPDATES ENABLED BY OVERRIDE PARM'  @ZA06024\nMSGEPARM DC    CL40'AMA129I INVALID PARAMETER SPECIFICATION '  @ZA06024\nMSGNOLIB DC    CL40'AMA130I SYSLIB DATA SET NOT OPENED      '  @ZA06023\n* ADCONS FOR MESSAGES STORED BEYOND AMASZCON ADDRESSABILITY.   @ZA09673\nAMSG100I DC    A(COMPMSG)    .(SPZAP COMPLETION).              @ZA17658\nAMSG101I DC    A(LIBERR)     .(SYSLIB I/O ERROR).              @ZA17658\nAMSG102I DC    A(DDERROR)    .(SYSLIB DD ERROR).               @ZA17658\nAMSG103I DC    A(NOCSMSG)    .(CSECT NOT FOUND).               @ZA17658\nAMSG104I DC    A(VERYERR)    .(VERIFY REJECT).                 @ZA17658\nAMSG105I DC    A(IGNOREM)    .(INV CARD OR NO-GO SET).         @ZA17658\nAMSG106I DC    A(PATCHERR)             .DATA OUT OF RANGE.     @ZA09679\nAMSG131I DC    A(MSGERECD) 'XXXXXXXX INVALID RECORD-TYPE ID.'  @ZA09673\n         SPACE 2\n***********************************************************************\nINPUT    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GM),RECFM=FB,LRECL=80,     X\n               EODAD=EODC,SYNAD=SYND,EXLST=XITLIST               S21995\n*** OUTPUT DCB HAS BEEN CHANGED TO QSAM                          Y02160\nOUTPUT   DCB   DSORG=PS,MACRF=(PM),DDNAME=SYSPRINT,RECFM=FBA,    Y02160X\n               LRECL=121,SYNAD=SYNOUT,EXLST=XITLIST1             Y02160\nLIB      DCB   DDNAME=SYSLIB,MACRF=(E),EXLST=EXLIST              S21995\nLIB2     DCB   DSORG=PO,MACRF=(R),DDNAME=SYSLIB,EODAD=EOD1,            X\n               RECFM=U,BLKSIZE=0,SYNAD=ABDMP4,EXLST=EXLIST2      S21995\nOBLIST   CAMLST  SEARCH,0,0,0           CONTAINS PTRS TO INFO    S21995\nEXLIST   DC    X'87'                    RD JFCB SIST             S21995\n         DC     AL3(JFCBAREA)                                    S21995\nEXLIST2  DC    X'05'               OPEN EXIT LIST                A49131\n         DC    AL3(OPTCDCK)        SUPPRESS OPTCD                A49131\n         DC    X'87'               READ JFCB EXIT                A49131\nJFCB     DC    AL3(JFCBAREA)       AREA FOR JFCB                  M2820\nXITLIST  DS    0F                                                S21995\n         DC    X'85'              OPEN EXITLST.                  S21995\n         DC    AL3(SETBLKSI)      CHK BLKSIZE.                   S21995\nXITLIST1 DS    0F                                                Y02160\n         DC    X'85'              SYSPRINT OPEN EXITLIST         Y02160\n         DC    AL3(STBLKSI1)      CHECK BLOCK SIZE               Y02160\n***********************************************************************\n*          **** XDAP CONTROL BLOCK  ****\n***********************************************************************\n         XDAP  DECB4,RI,LIB,,,,MBBCCHHR,MF=L                     S21995\n         SPACE 1                                                 S21995\nSCHARG   EQU   DECB4+4+X'20'            SEARCH ARGUMENT - CCHHR  S21995\nIOCCW1   EQU   DECB4+4+X'28'            FIRST EXECUTED CCW       S21995\nIOCCW3   EQU   DECB4+4+X'38'            UPDATE CCW OR TIC        S21995\n         SPACE 1\nMTRDCNT  EQU   X'92'                    MULTITRACK READ COUNT    S21995\nSKEYGTE  EQU   X'E9'                    SEARCH KEY GT. OR EQUAL  S21995\nTIC      EQU   X'08'                    TIC OP CODE              S21995\nRDDATA   EQU   X'06'                    READ DATA OP CODE        S21995\nWRDATA   EQU   X'05'                    WRITE DATA               S21995\n         SPACE 1\n* THESE CCW'S EXTEND THE XDAP EXCP CHANNEL PROGRAM FOR DIRECTORY UPDATE\n*        THIS SEQUENCE OF CCW'S ARE TIC TO BY PLACING IOCCW6 AT IOCCW3\nIOCCW4   CCW   MTRDCNT,TBUF+1,X'60',8   READ COUNT OF RECORD     S21995\nIOCCW5   CCW   SKEYGTE,MEMNAME,X'40',8  SEARCH ON KEY            S21995\nIOCCW6   CCW   TIC,IOCCW4,0,0           BACK TO COUNT IF LT      S21995\nIOCCW7   CCW   RDDATA,0,X'20',256       READ IF CORRECT ENTRY    S21995\n         SPACE 1\n*             THIS CCW IS EXECUTED AT LOCATION IOCCW3\nIOCCW3B  CCW   WRDATA,0,X'20',256       UPDATE DIRECTORY-CMD     S21995\n         READ  DECB5,SF,LIB2,0,0,,,,MF=L                         S21995\n         EJECT\n* ADDRESSABILITY INTERFACES.                                   @ZM40094\nWRITE0   LA    R1,AWRITE0A             .OFFSET FOR 'WRITE0A'.  @ZM40094\n         B     WRITE2                                          @ZM40094\nWRITE3   MVC   CONSW2(1),CONSW         .(FOR 'OLD DATA' MSG).  @ZA17659\nWRITE    LA    R1,AWRITEA              .OFFSET FOR 'WRITEA'.   @ZM40094\nWRITE2   LR    R14,LNKRG1              .SET RETURN REG.        @ZM40094\n         BR    R15                     .TO 'IOR' CSECT.        @ZM40094\nDUMP1    LA    R1,ADMP01                                       @ZM40094\n         L     R15,ADMP                .ADDR 'DMP' CSECT.      @ZM40094\n         LR    R14,LNKRG2                                      @ZM40094\n         BR    R15                     .TO 'DMP' CSECT.        @ZM40094\n         SPACE 1                                               @ZM40094\n* (AFTER DUMP COMPLETION) TERMINATE IF RETCODE GE 12.          @ZA09673\nDUMP09Z  CLC   RETCODE(1),RETCOD12     .IF RETCODE LE 8,       @ZA09673\n         BCR   4,LNKRG3                . GET NEXT INPUT STMT.  @ZA09673\n         L     R15,AIORTNS             .ELSE                   @ZA09673\n         LA    R1,ACLOSE5              . SET UP                @ZA09673\n         BR    R15                     . SPZAP TERMINATION.    @ZA09673\n*                                                              @ZA09673\n* SET UP COMMAND TO DUMP CSECT.                                @ZA09679\nSETDUMP  MVC   CDBUF+0(4),DUMP         .INSERT KEYWORD         @ZA09679\n         MVC   CDBUF+4(19),BLANKS      . AND BLANKS.           @ZA09679\n         MVC   CDBUF+5(8),MEMNAME      .INSERT MEMBER NAME     @ZA09679\n         MVC   CDBUF+14(8),CSECT       . AND CSECT NAME.       @ZA09679\n         USING ZAPBASE2,BASREG                                 @ZA09679\n         BAL   LNKRG1,SCANKEY          .SET REGISTERS AND      @ZA09679\n         L     BASREG3,RDAREA          .ADDR SYSLIB BUFFER.    @ZA09679\n         XC    STARTINC(4),STARTINC    .RESET IMBEDDED OFFSET. @ZA09679\n         B     DUMP01A                 .PROCESS 'DUMP' STMT.   @ZA09679\n         DROP  BASREG                                          @ZA09679\n*                                                              @ZA09679\n* INTERFACE WITH CHECKSUM-STATEMENT ROUTINE.                   @ZA17660\nCHSUMRTN L     BASREG3,ACHSUM                                  @ZA17660\n         BR    BASREG3                                         @ZA17660\n*                                                              @ZA17660\n* PATCH AREA.                                                  @ZA09673\n         SPACE 1                                               @ZA09673\nPTCHA    DC    F'0'                    .BEGIN PATCH AREA.      @ZA09673\n         ORG   AMASZCON+X'0FFF'                                @ZA09673\n         DC    X'00'                   .END PATCH AREA.        @ZA09673\n         SPACE 1                                               @ZA09673\n*** END OF AMASZCON ADDRESSABILITY ***                         @ZA09673\n         SPACE 1                                               @ZA09673\n* FOLLOWING MESSAGES BEYOND AMASZCON ADDRESSABILITY.           @ZA09673\n         SPACE 1                                               @ZA09673\nCOMPMSG  DC    CL40'AMA100I AMASPZAP PROCESSING COMPLETED'       S21995\nLIBERR   DC    CL26'AMA101I SYSLIB I/O ERROR  '\nDDERROR  DC    CL40'AMA102I SYSLIB DD SPECIFICATION ERROR'\nNOCSMSG  DC    CL40'AMA103I CSECT ABSENT - ALL CSECTS FOLLOW'\nVERYERR  DC    CL40'AMA104I VERIFY REJECT - SET NO GO SWITCH'\nIGNOREM  DC    CL40'AMA105I INVALID CARD OR NO GO SWITCH SET'\nPATCHERR DC    CL40'AMA106I PATCH OVERLAPS - CHECK DUMP'       @ZA09679\nMSGERECD DC    CL40'AMA131I XXXXXXXX INVALID RECORD-TYPE ID.'  @ZA09673\n         EJECT\nAMASZIOR CSECT\n         USING AMASZCON,BASREG2                                  S21995\n         STM   0,15,XFERSAVE           SAVE MAIN PROG REGS       S21995\n         BALR  BASREG,0                SET BASE REG              S21995\n         USING *,BASREG                                          S21995\n         LA    R13,REGSAVE             SET REG SAVE AREA         S21995\nIOBASE   LA    LNKRG1,GOBACK           SET LINKAGE TO RETURN     S21995\n         LA    LNKRG2,GOBACK2A          SET LINKAGE TO RETURN    X01979\n         B     VECTOR(R1)              BRANCH INTO BRANCH TABLE  S21995\nVECTOR   B     RDCARD2                                           S21995\n         B     CLOSE1                                            S21995\n         B     WRITEA                                            S21995\n         B     WRITE0A                                           S21995\n         B     DIRREAD                                           S21995\n         B     DIRWRITE                                          S21995\n         B     RDDSK2                                            S21995\n         B     OPENLIB                                           S21995\n         B     RDDISK                                            S21995\n         B     WRDISK                                            S21995\n         B     WTOA                                              S21995\n         B     CLOSE2                                            S21995\n         B     EOD                                               S21995\n         B     INSMDFY                                           X01979\n         B     INSM1A                                            X01979\n         B     CLOSE4                   .TO PARM-ERR EXIT.     @ZA06024\n         B     CLOSE5                  .TO INVAL-RECD EXIT.    @ZA09673\nGOBACK   LM    0,15,XFERSAVE           RESTORE REGS              S21995\n         BR    R14                     EXIT                      S21995\nGOBACK2A L     BASREG,XFERSAVE+BASREG*4  RELOAD BASE REGISTER\n         LM    R13,R15,XFERSAVE+52      RESET RETURN AND ENTRY REGS\n         BR    R14                      RETURN WITHOUT DESTROYING REGS\n***********************************************************************\n* THIS READ USES QSAM TO ACCESS THE CARD READER.\n***********************************************************************\nRDCARD2  GET   INPUT,CDBUF\n         BCR   15,LNKRG1\n         SPACE 2\n***********************************************************************\n*   THIS WRITE SUBROUTINE PRINTS THE INPUT CARD OR A MESSAGE TO THE PRI\n*******************\nWRITE0A  MVC   CDBUF(40),0(RG5)    MOVE IN MESSAGE               S21995\nWRITE1   MVC   CDBUF+40(40),BLANKS FILL WITH BLANKS\n         MVC   CDBUF+80(40),BLANKS      RESET REST WITH BLANK    YM1470\n         TM    DMPSW,X'FF'             .IF LINE IS FOR DUMP,   @ZA26077\n         BO    WRITEA                  . DISALLOW WTO.         @ZA26077\n         TM    CONSW,X'FF'             .Q CONSOLE INPUT.       @ZA17659\n         BZ    WRITEA                  .B IF NO.               @ZA17659\n         MVI   CONSW2,X'FF'            .ELSE SET WTO INDIC.    @ZA17659\n* ENTRY POINT IF TEXT ALREADY IN 'CDBUF'.                      @ZA17659\nWRITEA   PUT   OUTPUT,CDBUF-1                                    Y02160\n         PRTOV OUTPUT,12                CHECK FOR END OF PAGE\n         MVC   CDBUF+80(40),BLANKS      RESET REST WITH BLANK\n         TM    CONSW2,X'FF'            .Q MESSAGE TO CONSOLE.  @ZA17659\n         BCR   8,LNKRG1                .B IF NO.               @ZA17659\n         MVI   CONSW2,X'00'            .ELSE RESET 'WTO',      @ZA17659\n         L     WK7,AWTORTN             . FIND 'WTORTN',        @ZA17659\n         BR    WK7                     . AND ENTER IT.         @ZA17659\n         SPACE 2\n***********************************************************************\n* THIS SUBROUTINE USES BSAM TO SEQ RETRIEVE RECORDS\n*******************\nRDDSK2   ST    BASREG3,DECB5+12         SET READ IN AREA\n         MVC   DECB5+6(2),SIZE+2        SET MAX RECORD\n         READ  DECB5,SF,,,,,,,MF=E                               S21995\n         CHECK DECB5\n         BCR   15,LNKRG1                SUBROUTINE RETURN\n***********************************************************************\n*        END OF DATA ROUTINE FOR LIB2\n***********************************************************************\nEOD1     EQU   *                                                 YM5146\n         LM    0,15,DMPSAVE            RESTORE REGS              S21995\n* REG 15 WILL NOW POINT TO THE CONTINUATION SPOT, EITHER         YM5146\n* LABEL  'CONT'  OR LABEL  'NOCSECT'                             YM5146\n         BR    R15                                               S21995\n         SPACE 1\n*  THIS IS THE SYNAD ROUTINE FOR THE LIB2 DCB\nABDMP4   STM   RG0,RG2,TEMPSAV     SAVE PARM REGS\n         ST    R14,TEMPSAV+12      SAVE RETIRN REGISTER\n         ST    LNKRG1,TEMPSAV+16   SAVE LINK REGISTER\n         SYNADAF ACSMETH=BPAM\n         LR    RG2,WK7             SAVE PTR TO SYNADAF WRKAREA\n         L     LNKRG1,AMSG101I         .SELECT MESSAGE AND     @ZA17658\n         MVC   CDBUF(26),0(LNKRG1)     . COPY INTO BUFFER.     @ZA17658\n         BAL   LNKRG1,IOMSG        GOTO BLDL AND PRNT ERROR MSG\n         L     LNKRG1,TEMPSAV+16   RESTORE LINK REGISTER\n         LR    WK7,RG2             RESTORE PARM REGISTER 1\n         SYNADRLS                  RELEASE SYNADAF WRKAREA\n         L     R14,TEMPSAV+12      RESTORE RETURN REGISTER\n         LM    RG0,RG2,TEMPSAV     RESTORE SYNAD PARM REGS\n         B     CLOSE3                  GET OUT\nIOMSG    MVC   CDBUF+26(4),68(RG2)  MOVE UNIT TO MESSAGE\n         MVC   CDBUF+30(23),84(RG2)  MOVE IN ERROR DESCRIPTION\n         MVC   CDBUF+53(6),122(RG2)  MOVE IN ACSMETH\n         MVC   CDBUF+59(21),BLANKS  PAD REMAINDER OF BUFFER\n         MVC   CDBUF+80(40),BLANKS\n         PUT   OUTPUT,CDBUF-1                                    Y02160\n         PRTOV OUTPUT,12\n         TM    CONSW,X'FF'         SHOULD WTO BE ISSUED?\n         BCR   14,LNKRG1           NO - RETURN TO SYNAD ROUTINE\n         MVC   PREFIX(2),IOMSGLNG  MOVE IN WTO MSG LENGTH\n         MVC   CDBUF+59(4),DESCR   MOVE IN DESCR & ROUTE CODES\n         LA    WK7,PREFIX\n         WTO   MF=(E,(1))\n         BCR   15,LNKRG1           RETURN TO SYNAD THET CALLED\n**********************************************************************\n*  THIS IS THE SYNAD ROUTINE FOR SYSPRINT\n**********************************************************************\nSYNOUT   SYNADAF ACSMETH=BSAM                                    A45017\n         LR    RG2,WK7            SAVE REGISTER 1                A45017\n         MVC   WTOOUT+8+27(4),68(RG2)  MOVE UNIT                 A45017\n         MVC   WTOOUT+8+31(23),84(RG2) MOVE ERROR DESCRIPTION    A45017\n         MVC   WTOOUT+8+54(6),122(RG2) MOVE ACSMETH              A45017\nWTOOUT   WTO   'AMA123I SYSPRINT I/O ERROR UUUUDDDDDDDDDDDDDDDDDDDDDDDAX\n               AAAAA',ROUTCDE=(2,11),DESC=7                      A45017\n         LR    WK7,RG2             RESTORE REGISTER 1            A45017\n         SYNADRLS                                                A45017\n         B     CLOSE3              CLOSE FILES AND EXIT          A45017\n         SPACE 2\n*******************\n*   THIS WRITE USES XDAP TO UPDATE A SPECIFIC RECORD FOR THE DISK\n*******************\nWRDISK   SR    R15,R15              PREPARE R15 FOR 'R'          YM5534\n         IC    R15,MBBCCHHR+7      VALUE OF MBBCCHHR             YM5534\n         SH    R15,ONE             DECREMENT TO PREV. CHR        YM5534\n         STC   R15,MBBCCHHR+7      STORE PREV. CCHHR             YM5534\n         XDAP  DECB4,RI,LIB,COUNT,8,,MBBCCHHR,MF=E  RD. COUNT    YM5534\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   NOTE- THE FOLLOWING 3 INSTRUCTIONS ARE DEPENDENT ON THE EXPANSION *\n*       OF THE XDAP MACRO.  THE OPCODE OF CCW 3 IS CHANGED FROM       *\n*       READ KEY,DATA TO READ COUNT,KEY,DATA.                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         ORG   *-13               INSERT RD COUNT INTO IOB       YM5534\n         DC    XL1'1E'            READ COUNT OPCODE              YM5534\n         ORG\n         WAIT  1,ECB=DECB4                                       YM5534\n         IC    R15,MBBCCHHR+7      VALUE OF MBBCCHHR             YM5534\n         AH    R15,ONE             INCREMEMENT TO PRES. CCHHR    YM5534\n         STC   R15,MBBCCHHR+7      RESTORE PRES. CCHHR           YM5534\n         SR    R15,R15              PREPARE R15 FOR 'COUNT'      YM5534\n         IC    R15,COUNT+5         PUT KEYLENG INTO R15          YM5534\n         L     RG5,COUNT+4             .COUNT IN LOW HALFWORD. @ZA09683\n         N     RG5,CLER                .CLEAR HIGH HALFWORD.   @ZA09683\n         AR    R15,RG5                 .ADD TO KEY.            @ZA09683\n         L     R14,SIZE                .BUFFER SIZE.           @ZA09683\n         CR    R14,R15              COMPARE BLOCKSIZE AND KEY    YM5534\n*                                   LENGTH IN DCB TO THAT JUST   YM5534\n*                                   READ                         YM5534\n         L     R15,AIORTNS        INIT R15                       YM5534\n         LA    R1,ACLOSE2         INIT BNCH TABLE ENTRY          YM5534\n         LA    RG5,BLKSZERR       ERROR MSG                      YM5534\n         BCR   4,R15              EXIT IF SZ GRTR THAN DCB INFO  YM5534\n         L     R15,SIZE                .BUFFER SIZE.           @ZA09683\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   NOTE- THE FOLLOWING INSTRUCTION IS DEPENDENT ON THE EXPANSION     *\n*       OF THE XDAP MACRO.  THE FLAGS FIELD OF CCW3 IS MODIFIED TO    *\n*       SUPPRESS INCORRECT LENGTH INDICATION.                         *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         OI    WRDISK1+CMD,X'20'       SET OFF WLR               S21995\nWRDISK1  XDAP  DECB4,WI,LIB,(BASREG3),(15),,MBBCCHHR,MF=E        S21995\n         WAIT  1,ECB=DECB4\n         BC    15,ERRTST\n         SPACE 1\n*******************\n*   THIS READ USES XDAP TO GET A SPECIFIC RECORD FROM THE DISK\n*******************\nRDDISK   L     R15,SIZE                .BUFFER SIZE.           @ZA09683\n         XDAP  DECB4,RI,LIB,(BASREG3),(15),,MBBCCHHR,MF=E\n         WAIT  1,ECB=DECB4\nERRTST   TM    DECB4,X'20'              CHECK ECB PERMANENT\n         BCR   1,LNKRG1                 BIT SET-OKAY\n         CLI   DECB4,X'41'              TEST TYPE ERROR\n         BC    7,CLOSE2A                NOT NORMAL-CLOSE\n         CLC   DECB4+X'10'(2),MSK       WRONG LENGTH RECORD\n         BCR   8,LNKRG1                 YES-OK\nCLOSE2A  STM   RG0,RG2,TEMPSAV                                   S21995\n         ST    LNKRG1,TEMPSAV+16   SAVE LINK REGISTER\n         LA    WK7,DECB4+4         GET IOB ADDRESS\n         SYNADAF ACSMETH=EXCP\n         LR    RG2,WK7             SAVE ADDR OF SYNADAF WRKAREAA\n         L     LNKRG1,AMSG101I         .SELECT MESSAGE AND     @ZA17658\n         MVC   CDBUF(26),0(LNKRG1)     . COPY INTO BUFFER.     @ZA17658\n         BAL   LNKRG1,IOMSG        GOTO BLDL AND PRNT ERROR MSG\n         SYNADRLS                  RELEASE SYNADAF WRKAREA\n         LM    RG0,RG2,TEMPSAV     RESTORE REGISTERS\n         L     LNKRG1,TEMPSAV+16\n         MVC   RETCODE(1),RETCOD16     .INDIC PERM-I/O ERROR.  @ZA06023\n         OI    CTLBTE,IGNOP+NAMEERR  TURN ON NO GO SWITCH\n         BCR   15,LNKRG1           RETURN FOR NEXT OPERATION\n         SPACE 2\n*******************\nWTOA     WTO   'AMA118I SYSPRINT DD NOT IN INPUT',                     X\n               ROUTCDE=(2,11),DESC=7                             S21995\n         MVC   RETCODE(1),RETCOD12     .INDIC JCL-STMT ERROR.  @ZA06023\n         B     CLOSE5                                          @ZA06023\n*******************\n         SPACE 1\n*******************\nCLOSE2   MVC   RETCODE(1),RETCOD12     .INDIC JCL-STMT ERROR.  @ZA06023\n         B     CLOSE4                                          @ZA06023\nCLOSE3   MVC   RETCODE(1),RETCOD16     .INDIC PERM-I/O ERROR.  @ZA06023\nCLOSE4   BAL   LNKRG1,WRITE0A          .ISSUE MESSAGE.         @ZA06023\nCLOSE5   BAL   LNKRG1,CLOSE1                                   @ZA06023\n         BC    15,EXIT\n         SPACE 1\n*******************\n*           THIS ROUTINE SIMULATES BLDL. AND STOW USING, EXCP\n*              TO READ THE DIRECTORY AND WRITE THE DIRECTORY\n*******************\n         SPACE 1\n*      THIS CODE SETS UP THE CCW'S FOR THE READING OF THE DIRECTORY\nDIRREAD  MVC   IOCCW3(4),IOCCW6         SET UP TIC TO RD C.P.\n         MVC   IOCCW7+1(3),RDAREA+1     SET INPUT BUFFER\n         XC    SCHARG(8),SCHARG         ZERO OUT M AND R\n         L     WK7,LIB+44          GET DEB ADDRESS\n         MVC   SCHARG+1(6),STEXT-2(WK7)  SET SEEK ADDRESS\n         MVC   SCHARG+1(2),LIB2+6  SET BB IN SRCH MBBCCHHR\nUPDATEIO LA    1,DECB4+4                IOB ADDR\n         SVC   0                        EXCP\n         WAIT  1,ECB=DECB4              WAIT ON I/O\n         BC    15,ERRTST\n         SPACE 1\n*        THIS CODE SET UP THE CCW'S FOR THE DIRECTORY UPDATE\nDIRWRITE MVC   IOCCW3(8),IOCCW3B        SET UP UPDATE CCW\n         MVC   IOCCW3+1(3),RDAREA+1     SET OUTPUT AREA ADDR\n         MVC   SCHARG+3(5),TBUF+1       SET SEARCH ARG\n         BC    15,UPDATEIO              TO UPDATE DIRECTORY\n         SPACE 1\nOPENLIB  TM    LIB+OPENBIT,OPENED       HAS IT BEEN OPENED YET   S21995\n         BCR   1,LNKRG1                 YES,LNKRG1  RETURN       S21995\n         RDJFCB LIB                                              S21995\n         LA    RG5,JFCBAREA       GET ADDRESS OF JFCB            S21995\n         CLC   0(44,RG5),DSCBDS   JFCB FOR FORMAT4?              S21995\n         BC    7,RSRV              NO, ISSUE RESERVE AND OPEN    S21995\nASKOP    ST    LNKRG1,LNKSAVE2         SAVE LINK REGISTER        A38645\n         BAL   LNKRG1,UPVTRTN          REQUEST TO UPDATE VTOC    A38645\n         L     LNKRG1,LNKSAVE2         RESTORE LINK REGISTER     A38645\n         OI    CDBUF,X'40'         INSURE A CAPITAL LETTER       S21995\n         MVC   JFCBAREA(12),F4DSCB    MOVE FORMAT4.DSCB INTO DSN S21995\n         MVC   JFCBAREA+12(32),BLANKS   PAD REMAINDER OF DSNAME  S21995\n         CLI   CDBUF,C'N'               OKAY TO MODIFY           A53326\n         BC    8,NOF4MOD                NO-NOTIFY USER           A53326\n         CLI   CDBUF,C'Y'          CHECK FOR Y                   A53326\n         BC    7,ASKOP             NO, REISSUE MSG               A53326\nRSRV     L     RG5,LIB2+44         GET DEB ADDR FOR SYSLIB       S21995\n         LA    RG5,0(RG5)          CLEAR HI BYTE                 S21995\n         L     RG5,32(RG5)         PUT UCB AD IN RG5             YM5147\n         ST    RG5,UCBAD           PUT IN UCBAD FOR RESERVE      YM5147\n         MVC   RNAME(6),28(RG5)    MOVE MINOR NAME FROM UCB      YM5147\n         CLC   JFCBAREA(12),F4DSCB JFCB FOR FORMAT4?             YM5147\n         BE    VTOCRSRV            RESERVE 'SYSVTOC'             YM5147\n         RESERVE (MAJOR,JFCBAREA,E,44,SYSTEMS),RET=HAVE,UCB=UCBAD 21995\n         B     RESERVED           BRANCH AROUND RESERVE FOR VTOC YM5147\nVTOCRSRV RESERVE (QNAME,RNAME,E,6,SYSTEMS),RET=HAVE,UCB=UCBAD    YM5147\nRESERVED EQU  *                                                  YM5147\n         MVI   RSVSW,X'FF'         INDICATE RESERVE ISSUED       S21995\nOPEN2    OPEN  (LIB,(UPDATE))           OPEN                     S21995\n         BCR   15,LNKRG1                DONE                     S21995\n         SPACE 1\nNOF4MOD  OI    CTLBTE,NAMEERR                                    S21995\n         LA    RG5,NOVTOC               ERROR MSG                S21995\n         BAL   LNKRG1,WRITE0A            PRINT OUT ERROR MSG     S21995\nOPENRT   MVC   RETCODE(1),RETCOD08     .INDIC SPZAP-INP ERROR. @ZA06023\n         LM    0,15,XFERSAVE           RESTORE REGS              S21995\n         BCR   15,LNKRG3               GET NEXT CARD             S21995\n         SPACE 2\n**********************************************************************\n* THIS ROUTINE CHECKS FOR SUCCESSFUL MODIFICATIONS.  IF A NAME\n* UPDATE WAS PERFORMED, THE IDR (IF PRESENT) IS UPDATED AND THE\n* LOCAL MODIFY FLAG IN THE SSI IS TURNED ON (UNLESS THE LAST OPERATION\n* WAS A SETSSI). IF A CCHHR UPDATE WAS PERFORMED THIS ROUTINE ISSUES\n* WTO FOR AMA121I.\n**********************************************************************\nINSMDFY  TM    CTLBTE2,MODIFY           REP OPERATION COMPELETED\n         BO    CKIDR                   YES-CHECK IDR UPDATE      S21016\n         TM    CTLBTE3,MODFYREC        CCHHR REP COMPLETED       S21016\n         BCR   8,LNKRG2                N0-RETURN                 S21016\n         RDJFCB LIB2                                              M1733\n         CLC   JFCBAREA(44),DSCBDS      JFCB FOR FORMAT4?         M1733\n         BC    7,MOVESER                NO-SKIP NAME CHANGE       M1733\n         MVC   JFCBAREA(12),F4DSCB    MOVE FORMAT4.DSCB INTO DSN  M1733\n         MVC   JFCBAREA+12(32),BLANKS   PAD REMAINDER OF DSNAME   M1733\nMOVESER  MVC   WTO+8+36(6),JFCBAREA+118 MOVE VOLSER TO MSG       S21016\n         UNPK  WTO+8+43(11),MBBCCHHR+3(6)  MOVE CCHHR TO MSG     S21016\n         TR    WTO+8+43(10),TRANTBL2-X'F0'                       S21016\n         MVI   WTO+8+53,C','                                     S21016\n         LA    RG4,44                  SET MAX FOR DSNAME        S21016\n         LA    RG5,JFCBAREA            ADDR OF DSN IN JFCB       S21016\nTESTL    CLI   0(RG5),BLANK            END OF DSN                S21016\n         BE    PRPMVC                  YES-CALCULATE LENGTH      S21016\n         LA    RG5,1(RG5)              NO-ADD ONE                S21016\n         BCT   RG4,TESTL               BRANCH BACK               S21016\nPRPMVC   LA    RG4,JFCBAREA            START OF DSN              S21016\n         SR    RG5,RG4                 GET LENGTH OF DSN         S21016\n         LA    RG5,4+54(RG5)           LENGTH FOR WTO            S21016\n         STH   RG5,WTO+4               STORE IN WTO              S21016\n         LA    RG4,WTO+4(RG5)          ADDR OF ENN OF DSN IN MSG S21016\n         MVC   WTO+8+54(44),JFCBAREA   MOVE DSN TO MSG           S21016\n         MVC   0(4,RG4),WTO+8+98       MOVE ROUT & DESC TO MSG   S21016\n         ST    LNKRG3,LNKSAVE          SAVE LINK REGISTER        S21016\n         LA    LNKRG3,REGSAVE          SET SAVE AREA ADDR        S21016\n         EXTRACT   TBUF,FIELDS=(TIOT)                            S21016\n         L     RG5,TBUF                LOAD ADDR OF TIOT         S21016\n         MVC   WTO+8+24(8),0(RG5)      MOVE JOBNAME TO MSG       S21016\nWTO      WTO   'AMA121I CCHHR UPDATE BY          ON       ,          , X\n                                                          ',           X\n               ROUTCDE=(2,9),DESC=3                              S21016\n         L     LNKRG3,LNKSAVE          RESTORE LINK REG          S21016\n         NI    CTLBTE3,X'FF'-MODFYREC                            S21016\n         BR    LNKRG2                   RETURN                   S21016\nCKIDR    TM    CTLBTE3,IDRRD           ARE THERE IDR RECORDS     S21016\n         BZ    INSM1                   N0-SKIP UPDATE            S21016\n         ST    LNKRG3,LNKSAVE          YES-SAVE LINKREG          S21016\n         LA    LNKRG3,REGSAVE          SET SAVEAREA              S21016\n         POINT LIB2,IDRTTR             POINT TO IDR              S21016\n         L     LNKRG3,LNKSAVE          RESTORE LINKREG           S21016\n         BAL   LNKRG1,RDDSK2      READ IDR                       X01979\n         MVI   TEMP,X'00'              CALC LOC FOR IDR DATA     S21016\n         MVC   TEMP+1(1),RDAREA1+3     LOCATION =                S21016\n         NI    TEMP+1,X'3F'              (NO. OF ENTRIES)*13+4   S21016\n         LA    RG5,13                                            S21016\n         MH    RG5,TEMP                                          S21016\n         LA    RG5,RDAREA1+4(RG5)                                S21016\n         TIME\n         ST    R1,TEMP                 STORE TODAYS DATE         S21016\n         MVC   2(3,RG5),TEMP+1         MOVE DATE TO IDR          S21016\n         MVC   0(2,RG5),CSECTID+2      MOVE ESDID TO IDR         S21016\n         MVC   5(8,RG5),IDRDATA        MOVE IDRDATA TO IDR       S21016\n         SR    RG5,RG5                                           S21016\n         IC    RG5,RDAREA1+3           INSERT NO. OF ENTRIES     S21016\n         LA    RG5,1(RG5)              AND INCREASE BY ONE       S21016\n         STC   RG5,RDAREA1+3           STORE IN IDR              S21016\n         MVC   MBBCCHHR(8),IDRFSEEK    MOVE IDR DISK ADDR        S21016\n         MVC   TEMP(2),SIZE+2          SAVE SIZE                 S21016\n         MVC   SIZE+2(2),IDRSIZE       SET TO IDR SIZE           S21016\n         BAL   LNKRG1,WRDISK      WRITE UPDATED IDR RECORD       X01979\n         MVC   SIZE+2(2),TEMP          RESET SIZE                S21016\n         NI    CTLBTE3,X'FF'-IDRRD     TURN OFF IDR RECORD SW    S21016\n* SET UP AND ISSUE IDR-UPDATE MESSAGE.                         @ZA00409\n         MVC   CARDSAVE(80),CDBUF       .SAVE CARD IMAGE.      @ZA00409\n         L     RG5,IDRNENTS             .CURR # ENTRIES        @ZA00409\n         LA    RG5,1(RG5)               . INCR FOR             @ZA00409\n         ST    RG5,IDRNENTS             . ADDED ENTRY.         @ZA00409\n         CVD   RG5,TEMPDBLW             .STORE INTO            @ZA00409\n         UNPK  IDRNENTZ+1(2),TEMPDBLW+6(2)   . MESSAGE.        @ZA00409\n         OI    IDRNENTZ+2,X'F0'              .(SET SIGN).      @ZA00409\n         L     RG5,IDRMENTS             .MAX  IDR ENTRIES      @ZA00409\n         CVD   RG5,TEMPDBLW                  . INTO            @ZA00409\n         UNPK  IDRMENTZ+1(2),TEMPDBLW+6(2)   . MESSAGE.        @ZA00409\n         OI    IDRMENTZ+2,X'F0'              .(SET SIGN).      @ZA00409\n         MVC   MSGIDRUD+8(8),MEMNAME    .INSERT NAME.          @ZA00409\n         LA    RG5,MSGIDRUD             .ISSUE                 @ZA00409\n         BAL   LNKRG1,WRITE0A           . MESSAGE.             @ZA00409\n         CLC   IDRNENTS(4),IDRMENTS     .CHECK IDR  SPACE.     @ZA00409\n         BL    IDRQEOD                 .B IF MORE.             @ZM30901\n         MVC   IDRFULL+8(8),MEMNAME     .ELSE                  @ZA00409\n         LA    RG5,IDRFULL              . ISSUE                @ZA00409\n         BAL   LNKRG1,WRITE0A           . MESSAGE.             @ZA00409\n         CLC   RETCODE(1),RETCOD04      .IF RETCODE GE 4,      @ZA07967\n         BNL   IDRQEOD                  . LEAVE ALONE.         @ZA07967\n         MVC   RETCODE(1),RETCOD04      .ELSE SET IT TO 4.     @ZA07967\nIDRQEOD  CLC   CARDSAVE(2),SLAST                               @ZM30901\n         BE    INSM1                   .B IF EOD REACHED.      @ZM30901\nIDRRESCD MVC   CDBUF(80),CARDSAVE       .RESTORE CARD IMAGE    @ZA00409\n         BAL   LNKRG1,WRITEA            . AND PRINT CARD.      @ZA00409\nINSM1    NI    CTLBTE2,X'FF'-MODIFY     RESET REP FLAG           S21016\n*              THIS PROCEDURE INSPECTS FOR A PDS REP. HAVING OCCURRED\nINSM1A   BAL   LNKRG1,DIRREAD     GET DIRECTORY BLOCK            X01979\n         LH    RG5,0(0,BASREG3)    GET SIZE OF ENTRY\n         LA    RG5,0(RG5,BASREG3)  DETERMINE STOP ADDR\n         LR    RG0,RG5             SAVE STOP ADDRESS\n         LA    RG4,2(0,BASREG3)         POINT AT FIRST ENTRY\n         SR    RG5,RG5                  CLEAR REGISTER\n         OI    CTLBTE3,NOMEM\n***********************************************************************\n* THIS SUBROUTINE WILL UPDATE SSI BYTES TO INDICATE LOCAL MODIFY\n* AFTER A SUCCESSFUL REP HAS BEEN COMPLETED.\nINSM2    MVC   TBUF(1),11(RG4)          MOVE OUT USER LENGTH\n         NI    TBUF,X'1F'               RESET LEADING BITS\n         IC    RG5,TBUF                 GET USER LENGTH DW\n         CLC   0(8,RG4),MEMNAME         CORRECT MEMBER\n         BC    8,INSM3                  YES-SET ON MODIFY\n         LA    RG4,12(RG5,RG4)          NO-INCR.\n         AR    RG4,RG5                  POINT AT NEXT MEMBER\n         CR    RG4,RG0             TOO FAR?\n         BCR   8+2,LNKRG2               YES-THE HECK WITH IT\n         BC    15,INSM2                 NO-CONTINUE\n         SPACE 1\nINSM3    OI    CTLBTE3,NOSSI            SET SSI MISSING FLAG\n         NI    CTLBTE3,X'FF'-NOMEM      RESET MISSING MEMBER FLAG\n         TM    30(RG4),AOS              WAS AOS LKED USED        YM5257\n         BO    AOSPDS                   YES--GO TO AOS RTN       Y01979\n         AR    RG5,RG5                  DOUBLE TO BYTE SIZE\n         CH    RG5,TW2                  22\n         BCR   8+4,LNKRG2               YES-EXIT\n         CH    RG5,THIRTY               30\n         BCR   8,LNKRG2                 YES- NO SSI BYTES\n         CH    RG5,THIRTY2              32\n         BCR   8,LNKRG2                 YES- NO SSI BYTES\n         CH    RG5,FOURTY               40\n         BCR   8,LNKRG2                 YES- NO SSI BYTES\n         LA    RG4,12-4(RG5,RG4)        POINT AT SSI BYTES\nINSM4    NI    CTLBTE3,X'FF'-NOSSI      RESET NO SSI FIELD FLAG  Y01979\n         TM    CTLBTE3,SSIOP            SSI OPERATION BEING PERFORMED\n         BCR   1,LNKRG2                 YES-RETURN TO SET SSI RTN\n         LA    RG4,SSIMDFY(RG4)         NO-POINT AT MODIFY OFFSET\n         OI    0(RG4),X'20'             SET ON LOCAL MODIFY BITS\n*         UPDATE DIRECTORY ENTRY  SSI  BYTES FOR LOCAL MODIFY\n         BAL   LNKRG1,DIRWRITE           UPDATE DIRECTORY\n         BCR   15,LNKRG2                RETURN\nAOSPDS   TM    30(RG4),SSIB        IS THERE AN SSI               YM5257\n         BCR   8,LNKRG2            NO--RETURN                    Y01979\n         LA    RG5,34(RG4)         POINT TO END OF BASIC SECTION YM5257\n         TM    20(RG4),SCTR        DOES DIR HAVE SCTR SECTION    YM5257\n         BZ    NOSCTR              NO--SKIP ADD                  Y01979\n         LA    RG5,8(RG5)          YES--UPDATE PTR               Y01979\nNOSCTR   TM    11(RG4),ALIAS       IS THERE AN ALIAS             YM5257\n         BZ    NOALIAS             NO--SKIP ADD                  Y01979\n         LA    RG5,10(RG5)              YES, UPDATE POINTER    @YM4509P\nNOALIAS  LR    RG4,RG5             PUT PTR IN PROPER REG         Y01979\n         B     INSM4                GO UPDATE SSI\n         SPACE 4\nSYND     SYNADAF ACSMETH=QSAM\n         LR    RG2,WK7             SAVE PARM REG                 S21995\n         MVC   CDBUF(26),INPUTERR  MOVE MSG ID TO BUFFER         S21995\n         BAL   LNKRG1,IOMSG        GOTO BLDL AND PRNT ERROR MSG  S21995\n         SYNADRLS                  FREE SYNADAF  WRKAREA         S21995\n         MVC   RETCODE(1),RETCOD16     .INDIC PERM-I/O ERROR.  @ZA06023\n         B     CLOSE5                  .GO TO CLOSE.           @ZA06023\nSETBLKSI SR    RG4,RG4                                           S21995\n         LH    RG4,INPUT+62       GET BLKSIZE FOR SYSIN          S21995\n         LTR   RG4,RG4            WAS BLKSIZE PROVIDED?          S21995\n         BCR   2+4,R14            YES, RETURN TO OPEN.           S21995\n         MVC   INPUT+62(2),INPUT+82  SET BLKSIZE=80.             S21995\n         BR    R14                RETURN TO OPEN                 S21995\nSTBLKSI1 SR    RG4,RG4                                           Y02160\n         LH    RG4,OUTPUT+62      GET BLKSIZE FOR SYSPRINT       Y02160\n         LTR   RG4,RG4            WAS BLKSIZE PROVIDED?          Y02160\n         BCR   2+4,R14            YES, RETURN TO OPEN.           Y02160\n         MVC   OUTPUT+62(2),OUTPUT+82  SET BLKSIZE=80.           Y02160\n         BR    R14                RETURN TO OPEN                 Y02160\nCLOSE1   CLOSE (INPUT,,OUTPUT,,LIB2)\n         CLOSE (LIB)\n         TM    INPUT+23,X'03'          .LOW BITS BFCB ADDR.    @ZA00408\n* FREE BUFFER POOLS.                                           @ZA06027\n         BNZ   FPOOLPRT                .IF SYSIN OPENED,       @ZA06027\n         FREEPOOL INPUT                . FREE ITS BUFFER POOL. @ZA06027\nFPOOLPRT TM    OUTPUT+23,X'03'         .LOW BITS BFCB ADDR.    @ZA06027\n         BNZ   CLOSE1ZZ                .IF SYSPRINT OPENED,    @ZA06027\n         FREEPOOL OUTPUT               . FREE ITS BUFFER POOL. @ZA06027\n* RETURN FROM 'CLOSE1' SUBROUTINE.                             @ZA06027\nCLOSE1ZZ BR    LNKRG1                  .LEAVE 'CLOSE1' SUBRTE. @ZA06027\n***********************************************************************\n* AMASPZAP COMPLETE\n***********************************************************************\nEODC     MVC   CDBUF(2),SLAST          .INDICATE EOD.          @ZM30901\n         BAL   LNKRG2,INSMDFY          .CHECK FOR UPDATE.      @ZM30901\nEOD      L     RG5,AMSG100I            .SELECT MESSAGE.        @ZA17658\n         BAL   LNKRG1,WRITE0A                                    S21995\n         BAL   LNKRG1,CLOSE1                                     S21995\nEXIT     CLI   RSVSW,RSVON         WAS RESERVE ISSUED?           S21995\n         BNE   GETOUT              NO, EXIT                      S21995\n         CLC   JFCBAREA(12),F4DSCB     .IF 'FORMAT4.DSCB',     @ZA02784\n         BE    DEQVTOC             DEQ VTOC NAMES                YM5147\n         DEQ   (MAJOR,JFCBAREA,44,SYSTEMS),RET=HAVE              YM5147\n         B     ENDDEQ              DONE DEQ OF NON-VTOC NAMES    YM5147\nDEQVTOC  DEQ   (QNAME,RNAME,6,SYSTEMS),RET=HAVE                  YM5147\nENDDEQ   MVI   RSVSW,X'00'         RESET RESERVE SWITCH          S21995\nGETOUT   ST    R13,LNKSAVE                                       S21995\n         L     R13,REGSAVE+4                                     S21995\n         L     R0,SIZE                 .BUFFER SIZE.           @ZA09683\n         LA    R1,8                    .EXT FOR UNPK BEY BUFF  @ZM40094\n         AR    R0,R1                   . IN CASE BUFF FILLED.  @ZM40094\n         L     R1,RDAREA            LOAD 1R WITH ADDR OF GETMAIN Y02160\n         FREEMAIN R,LV=(0),A=(1)    FREE FOR CLEANUP             Y02160\n         CLC   RETCODE(1),LASTRET       WHICH CODE IS HIGHEST\n         BL    USELAST                  IF LAST ONE--DON'T CHANGE\n         MVC   LASTRET(1),RETCODE       SAVE HIGHEST STEP RET CODE\nUSELAST  SR    R15,R15                  CLEAR RET CODE REG\n         IC    R15,LASTRET              LOAD RETURN CODE\n         RETURN (14,12),RC=(15)           EXIT FROM AMASPZAP     A35657\n***********************************************************************\n         SPACE 1\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  THIS ROUTINE WRITES MESSAGE AMA117D TO OPERATOR TO REQUEST         *\n*  PERMISSION TO UPDATE VTOC                                          *\n*                                                                     *\n***********************************************************************\nUPVTRTN  ST    LNKRG1,LNKSAVE3         SAVE LINK REGISTER        A38645\n         BALR  LNKRG1,0                ESTABLISH                 A38645\n         USING *,LNKRG1                 ADDRESSABILITY           A38645\n         EXTRACT ADDRSV,'S',FIELDS=(TIOT) GET ADDR ACT TASK      A38645\n         L     RG5,ADDRSV              RG5 POINTS TO TIOT        A38645\n         MVC   UPVTMSG+66(8),0(RG5)    MOVE JOBNAME TO MSG BUFFERA38645\n         LA    RG5,24(RG5)             INCREMENT TO FIRST DD ENT A38645\nCHKLIB   CLC   4(6,RG5),SYSLIB         SYSLIB DD                 A38645\n         BC    8,LIBUCB                GET SYSLIB UCB ADDR       A38645\n         XC    ADDRSV(4),ADDRSV        CLEAR ADDRESS AREA        A38645\n         MVC   ADDRSV+3(1),0(RG5)      MOVE LEN OF DD ENTRY      A38645\n         A     RG5,ADDRSV              RG5 POINTS TO NEXT DD ENT A38645\n         BC    15,CHKLIB               CHECK IF ITS SYSLIB       A38645\nLIBUCB   L     RG5,16(RG5)             REL ADDR OF SYSLIBS UCB   A38645\n         DEVTYPE SYSLIB,DEVBUF         GET SYSLIB DEVICE TYPE    A38645\n         CLI   DEVBUF+3,X'05'          IS IT A 2321 DATA CELL    A38645\n         BC    7,NOT2321               NOT 2321                  A38645\n*  DEVICE IS A 2321 DATA CELL                                         *\n         MVC   UPVTMSG+53(6),4(RG5)    2321 VOLSER TO MSG BUFFER A38645\n         MVC   UPVTMSG+64(1),1(RG5)    BIN NUMBER TO MSG BUFFER  A38645\n         OI    UPVTMSG+64,X'F0'        CONVERT TO EBCDIC         A38645\n         MVI   UPVTMSG+63,C'/'         INSERT DELIMETER          A38645\n*  FIND BEGINNING OF 2321 UCB FOR UNIT ADDRESS FIELD                  *\n         ST    RG5,ADDRSV              SAVE ADDR OF CELL DESCR   A38645\n         LH    RG5,0(RG5)              LOAD BIN NUMBER           A38645\n         SLA   RG5,4                   TIMES BYTES/CELL ENTRY    A38645\n         LA    RG5,56(RG5)             PLUS DISP TO BIN0 DESCR   A38645\n         LCR   RG5,RG5                                           A38645\n         A     RG5,ADDRSV              RG5 POINTS TO BEGIN OF UCBA38645\n         BC    15,UNITNAME             MOVE UNIT NAME            A38645\nNOT2321  MVC   UPVTMSG+53(6),28(RG5)   NON 2321 VOLSER TO MSG BUFA38645\nUNITNAME MVC   UPVTMSG+60(3),13(RG5)   MOVE UNIT NAME TO MSG BUF A38645\n         XC    WTOECB(4),WTOECB        CLEAR ECB                 A38645\nUPVTMSG  WTOR  'AMA117D REPLY Y OR N TO UPDATE VTOC                    X\n                  ',CDBUF,1,WTOECB,ROUTCDE=1,DESC=2\n         WAIT  ECB=WTOECB                                        A38645\n         MVC   UPVTMSG+53(21),UPVTMSG+52 BLANK DYNAM AREA        A38645\n         L     LNKRG1,LNKSAVE3         RESTORE LINK REGISTER     A38645\n         BR    LNKRG1                  .RETURN TO CALLER.      @ZA17658\n         EJECT                                                 @ZA17658\n* SUBROUTINES WITH OWN ADDRESSING (OVERFLOW FROM MAIN CSECT).  @ZA17658\n         USING ZAPBASE2,BASREG                                 @ZA17658\n************************************************************** @ZA00409\n* SUBROUTINE TO SCAN CONTROL CARD, PRINT IT UNLESS IT CAUSES * @ZA00409\n* AN IDR-UPDATE MESSAGE, AND RETURN TO CALLER WITH KEYWORD   * @ZA00409\n* POINTERS (REGISTERS) SET BY 'SCANKEY'.                     * @ZA00409\n************************************************************** @ZA00409\n         USING CCISCAN,BASREG3                                 @ZA17658\nCCISCAN  ST    LNKRG1,CCISSAVE          .SAVE RET REG.         @ZA00409\n         TM    CTLBTE2,MODIFY           .PRINT CARD IF         @ZA00409\n         BZ    CCISPRNT                 . NO SUCC 'NAME' REP   @ZA00409\n         TM    CTLBTE3,IDRRD            . OR                   @ZA00409\n         BZ    CCISPRNT                 . NO IDR SPACE.        @ZA00409\n         BAL   LNKRG1,SCANKEY           .LOCATE KEYWORD.       @ZA00409\n         TM    CTLBTE,IGNOP            .IF 'NO GO' SET,        @ZM30901\n         BO    CCISCAN2                . 'REP' IS INVALID.     @ZM30901\n         CLC   0(3,RG1),REP            .ELSE                   @ZM30901\n         BE    CCISPRNT                . PRINT IF 'REP' CARD.  @ZM30901\n* NOT A REJECTED REP AFTER PREV ACCEPTED REP(S).               @ZM30901\nCCISCAN2 CLC   0(3,RG1),VERIFY         .PRINT                  @ZM30901\n         BE    CCISPRNT                . IF 'VER' CARD,        @ZM30901\n         CLC   0(6,RG1),SSI                                    @ZA00409\n         BE    CCISPRNT                 . OR 'SETSSI' CARD,    @ZA00409\n         CLC   0(7,RG1),IDRDATAC                               @ZA00409\n         BE    CCISPRNT                 . OR 'IDRDATA' CARD,   @ZA00409\n         CLI   0(RG1),AST                                      @ZA00409\n         BE    CCISPRNT                 . OR COMMENT CARD,     @ZA00409\n         CLC   0(7,RG1),CONSOLE                                @ZA00409\n         BE    CCISPRNT                 . OR 'CONSOLE' CARD,   @ZA00409\n         CLC   0(8,RG1),CHECKSUM       .OR 'CHECKSUM' STMT,    @ZA17660\n         BE    CCISPRNT                                        @ZA17660\n         CLC   0(3,RG1),END                                    @ZA00409\n         BNE   CCISEXIT                 . OR 'END' CARD.       @ZA00409\nCCISPRNT BAL   LNKRG1,WRITE             .(ELSE DEFER PRINT).   @ZA00409\n         BAL   LNKRG1,SCANKEY           .RESTORE KEYWORD PTRS. @ZA00409\nCCISEXIT L     LNKRG1,CCISSAVE          .RESTORE RET REG,      @ZA00409\n         L     BASREG3,RDAREA          .RESTORE BUFFER BASE.   @ZA17658\n         BR    LNKRG1                   . AND RETURN.          @ZA00409\nCCISSAVE DC    F'0'                     .(RET-REG SAVE WORD).  @ZA00409\n         SPACE 1\n         DROP  BASREG3                                         @ZA17658\n         SPACE 1                                               @ZA17660\n* PROCESS 'CHECKSUM' STATEMENT.                                @ZA17660\n         USING CHSUM,BASREG3                                   @ZA17660\nCHSUM    UNPK  CHSUMBCD(9),CHSUMACC(5) .UNPACK HEX CHECKSUM.   @ZA17660\n         TR    CHSUMBCD(8),TRANTBL2-X'F0' .CONV TO BCD.        @ZA17660\n         MVI   CHSUMCMA,COMMA          .RESTORE COMMA AFT VAL. @ZA17660\n         XC    CHSUMACC(4),CHSUMACC    .RESET HEX CHECKSUM.    @ZA17660\n         XC    CHSUMSLL(2),CHSUMSLL    .RESET CHECKSUM SHIFT.  @ZA17660\n         BAL   LNKRG1,SCANKEY1         .GET OPERAND, IF ANY.   @ZA17660\n         LTR   RG2,RG2                 .Q ANY OPERAND.         @ZA17660\n         BZ    CHSUMWAS                .B OF NONE.             @ZA17660\n         SR    RG3,RG1                 .OPERAND LENGTH.        @ZA17660\n         CH    RG3,EIGHT               .(MUST BE 8 DIGITS).    @ZA17660\n         BNE   CHSUMINV                .B IF NOT 8 DIGITS.     @ZA17660\n         CLC   CHSUMBCD(8),0(RG1)      .COMPARE CHECKSUMS.     @ZA17660\n         BNE   CHSUMERR                .B IF UNEQUAL.          @ZA17660\n         MVC   CHSUMBCD(8),CORRECT     .ELSE INSERT 'CORRECT ' @ZA17660\n         B     CHSUMWAS                . INTO MESSAGE.         @ZA17660\n* CHECKSUM ERROR.                                              @ZA17660\nCHSUMERR OI    CTLBTE,IGNOP            .SET NO=GO SWITCH.      @ZA17660\n         MVC   RETCODE(1),RETCOD08     .SET RETURN CODE.       @ZA17660\n         LA    RG5,MSGCHERR            .SELECT MESSAGE         @ZA17660\n         BAL   LNKRG1,WRITE0           .WRITE MESSAGE.         @ZA17660\n         B     CHSUMWAS                                        @ZA17660\n* OPERAND ERROR.                                               @ZA17660\nCHSUMINV OI    CTLBTE,IGNOP            .SET NO=GO SWITCH.      @ZA17660\n         MVC   RETCODE(1),RETCOD08     .SET RETURN CODE.       @ZA17660\n         LA    RG5,MSGCHINV            .SELECT MESSAGE         @ZA17660\n         BAL   LNKRG1,WRITE0           .WRITE MESSAGE.         @ZA17660\n* WRITE CHECKSUM-VALUE MESSAGE.                                @ZA17660\nCHSUMWAS LA    RG5,MSGCHWAS            .SELECT MESSAGE.        @ZA17660\n         BAL   LNKRG1,WRITE0           .WRITE MESSAGE.         @ZA17660\n         L     BASREG3,RDAREA          .RESTORE BUFFER BASE.   @ZA17660\n         BR    LNKRG3                  .GO TO NEXT INPUT STMT. @ZA17660\n         SPACE 1                                               @ZA17660\nCORRECT  DC    CL8'CORRECT '                                   @ZA17660\nMSGCHWAS DC    CL40'AMA132I CHECKSUM WAS XXXXXXXX, IS NOW 0.'  @ZA17660\nCHSUMBCD EQU   MSGCHWAS+21                                     @ZA17660\nCHSUMCMA EQU   CHSUMBCD+8                                      @ZA17660\nMSGCHERR DC    CL40'AMA133I CHECKSUM ERROR. NO-GO SWITCH SET.' @ZA17660\nMSGCHINV DC    CL40'AMA134I  OPERAND ERROR. NO-GO SWITCH SET.' @ZA17660\n         SPACE 1                                               @ZA17660\n         DROP  BASREG3                                         @ZA17660\n         EJECT                                                 @ZA17658\n* DSECT FOR SYSLIB BUFFER.                                     @ZA17658\nPROG4    DSECT                                                 @ZA17658\nRDAREA1  DS    0C\nPCHOFFST EQU   PTCHA-AMASZCON           BASEREG=BASEREG2=11      Y02006\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ZAPTOZAP": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x01\\x04?\\x01\\x01\\x04?\\x19\\x13\\x00T\\x00]\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-02-12T00:00:00", "modifydate": "2001-02-12T19:13:00", "lines": 84, "newlines": 93, "modlines": 0, "user": "WSBG"}, "text": "\nI had a good look at the MVS 3.8 AMASPZAP source, and I\nfigured everything else out.\n\nI branched around the VTOC Update routine and after some testing it\nappears to work.\n\nIn the 3.8 AMASPZAP source,  label ASKOP.\nHere I used an unconditional Branch to the label RSRV. It has remained\nthe same over the years.\n\n//ZAPWTOR EXEC PGM=AMASPZAP\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=MYHLQ.LOAD,UNIT=SYSDA,VOL=SER=MVS004\n//SYSIN    DD *\n  NAME AMAZAP  AMASZIOR         Loadmodule ---- CSECT\n  VER 0494 4580,C9D4            BAL  LNKRG1,UPVTRTN\n  REP 0494 47F0,C4B6            B    RSRV\n\n\n\n\nWe've gone one step further and copied and renamed the modules\nrequired.  I had one problem when changing the name of Load Module\nAMAZAP it appears you MUST also change the occurrence of the name in\nthe module IGWSPZAP.\n\nHere is the JOB that does everything in one fell swoop.\n\n//*-------------------------------------------------------------------*\n//*    COPYMOD :  Change AMASPZAP to QBASPZAP in MYHLQ.LOAD           *\n//*               Change AMAZAP   to QMAZAP   in ----------           *\n//*               Change IGWSPZAP to QBWSPZAP in ----------           *\n//*                                                                   *\n//*    ZAPWTOR :  Eliminate  WTOR Message:                            *\n//*               AMA117D REPLY Y OR N TO UPDATE VTOC ser ddd xxxxxxx *\n//*                                                                   *\n//*    ZAPNAME :  Modified Module-Name AMAZAP   in QMASPZAP           *\n//*               Modified Module-Name IGWSPZAP in QMASPZAP           *\n//*               Modified Module-Name AMAZAP   in QBWSPZAP           *\n//*                                                                   *\n//*    Tested with:                                                   *\n//*    OS/390 2.6 MIT DFSMS/MVS 1.4                                   *\n//*    OS/390 2.9 MIT DFSMS/MVS 1.5                                   *\n//*-------------------------------------------------------------------*\n//COPYMOD  EXEC PGM=IEBCOPY,REGION=17M\n//SYSPRINT DD SYSOUT=*\n//MIGIN    DD DISP=SHR,DSN=SYS1.MIGLIB,UNIT=SYSDA,VOL=SER=OST0A9\n//MIGOUT   DD DISP=SHR,DSN=MYHLQ.LOAD,UNIT=SYSDA,VOL=SER=MVS004\n//LINKIN   DD DISP=SHR,DSN=SYS1.LINKLIB,UNIT=SYSDA,VOL=SER=OST0A9\n//LINKOUT  DD DISP=SHR,DSN=MYHLQ.LOAD,UNIT=SYSDA,VOL=SER=MVS004\n//SYSIN    DD *\n COPYMOD OUTDD=MIGOUT,INDD=((MIGIN))\n S M=((AMASPZAP,QBASPZAP))\n S M=((AMAZAP,QMAZAP))\n COPYMOD OUTDD=LINKOUT,INDD=((LINKIN))\n S M=((IGWSPZAP,QBWSPZAP))\n//*\n//ZAPWTOR EXEC PGM=AMASPZAP\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=MYHLQ.LOAD,UNIT=SYSDA,VOL=SER=MVS004\n//SYSIN    DD *\n  NAME QMAZAP  AMASZIOR         Loadmodule ---- CSECT\n  VER 0494 4580,C9D4            BAL  LNKRG1,UPVTRTN\n  REP 0494 47F0,C4B6            B    RSRV\n/*\n//ZAPNAME EXEC PGM=AMASPZAP\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=MYHLQ.LOAD,UNIT=SYSDA,VOL=SER=MVS004\n//SYSIN    DD *\n NAME QBASPZAP AMASPZAP\n VER 00D8 C9C7,E6E2,D7E9,C1D7    IGWSPZAP        Old Name\n REP 00D8 D8C2                   QBWSPZAP        New Name\n VER 00E0 C1D4,C1E9,C1D7         AMAZAP          Old Name\n REP 00E0 D8                     QMAZAP          New Name\n NAME QBWSPZAP IGWZAP00\n VER 0F00 C1D4,C1E9,C1D7         AMAZAP          Old Name\n REP 0F00 D8                     QMAZAP          New Name\n/*\n\nThis is a great test if you also try it out.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT502/FILE502.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT502", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}