{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012424000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE591.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE591.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x07'", "DS1TRBAL": "b'~,'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04Z\\x00\\x01\\x04Z\\x00\\x04\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02&\\x1f\\x01\\x02&\\x1f\\t\\x04\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-18T00:00:00", "modifydate": "2002-09-18T09:04:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 452    FILE:  591\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT452.FILE591\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 7 MEMBERS COUNTED; CUMULATIVE SIZE IS 754 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/18/02    09:04:52    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x14\\x0f\\x01\\x00)\\x9f\\x114\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-20T00:00:00", "modifydate": "2000-10-25T11:34:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "WSBG"}, "text": "  Here's a couple of words of explanation.  REXXFORM is a VM REXX exec\n  which has been written to beautify and reformat other REXX execs.  It\n  is in the form of an XEDIT macro.  You XEDIT the REXX exec on VM,\n  and run the XEDIT macro REXXFORM, which reformats the exec that's\n  being edited (I think.  You have to try it).\n\n  I'm putting this program here, because I'd like someone to convert\n  it to an ISPF edit macro, that can be used to reformat TSO REXX\n  execs that you are editing under ISPF.\n\n  Someone who knows both VM and MVS TSO, please do this and send the\n  result back to me.  Thanks.\n\n       Sam Golob                      email:  sbgolob@attglobal.net\n       P.O. Box 906                           sbgolob@aol.com\n       Tallman, NY 10982-0906\n\n\n  I accept contributions to the CBT Tape by email.  Create a pds\n  with the software, and doc to install.  Then allocate a sequential\n  output dataset in 80-byte (card image) format,\n  DCB=(LRECL=80,RECFM=PS,BLKSIZE=6000), for example.  XMIT the pds to\n  yourself, using the INDATASET and OUTDATASET keywords:\n\n    XMIT yournode.yourid INDATASET(your.pds) OUTDATASET(your.seq)\n\n  Then download the OUTDATASET in binary (no translation) to a pc\n  and attach that file to an email to me.   That's all folks.\n\n  And that's how I accept contributions.  Thanks a bunch in advance.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$MSG": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x14\\x0f\\x01\\x00$?\\x19\\x11\\x00\\x0e\\x00\\x0b\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-05-20T00:00:00", "modifydate": "2000-08-30T19:11:00", "lines": 14, "newlines": 11, "modlines": 0, "user": "WSBG"}, "text": "From:    PHILS@ss1.Reston.VMD.Sterling.COM (Philip H. Smith III)\nTo:      sbgolob@attglobal.net\nDate:    Thu, 14 May 98 13:56:15 EDT\n\nCBT tape?  Ah, that'd be one of those there MVS thingies.  Sorry,\ndon't do MVS.  Can't even spell it...\n\nHere's REXXFORM, in case you didn't get it off of the list.\n\n    (In case you haven't figured it out, this message is from\n     Phil Smith.   - sbg 05/98)\n\n...phsiii\n---------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE591": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x00\\x99\\x08?\\x01\\x02&\\x1f\\x08\\t\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2002-09-18T08:09:04", "lines": 12, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 591 IS FROM BOB FOWLES OF PENNSYLVANIA STATE UNIVERSITY   *   FILE 591\n//*           AND FROM PHILIP H. SMITH III, AND IS A VM REXX EXEC   *   FILE 591\n//*           WHOSE PURPOSE IS TO CLEAN UP AND SYNTAX CHECK OTHER   *   FILE 591\n//*           REXX EXECS.  THIS IS A VM EXEC, AND IT IS BEING       *   FILE 591\n//*           INCLUDED HERE, IN THE HOPE THAT SOMEONE WHO KNOWS     *   FILE 591\n//*           BOTH VM AND MVS, WILL GET THIS EXEC TO WORK UNDER     *   FILE 591\n//*           TSO REXX.                                             *   FILE 591\n//*                                                                 *   FILE 591\n//*           AUTHOR:   BOB FOWLES                                  *   FILE 591\n//*                     RBF@PSU.EDU                                 *   FILE 591\n//*                     814-865-4774                                *   FILE 591\n//*                                                                 *   FILE 591\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REXXFORM": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x98\\x13\\x8f\\x00\\x98\\x14\\x0f#'\\x01\\x18\\x01,\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-05-18T00:00:00", "modifydate": "1998-05-20T23:27:00", "lines": 280, "newlines": 300, "modlines": 0, "user": "SBGOLOB"}, "text": "/*********************************************************************\n*\n*   ROUTINE:      REXXFORM\n*\n*   PURPOSE:      Structure/indent REXX execs\n*\n*   AUTHOR:       Robert Fowles, 02/04/84\n*                 (based on original exec by Jeffery Almoney)\n*                 Pennsylvania State University\n*                 Center for Academic Computing\n*                 107 Computer Building\n*                 University Park, PA  16802\n*                 814 865-4774\n*                 SHARE Installation code: PSU\n*                 Bitnet: RBF@PSUVM\n*                 Internet: RBF@PSUVM.PSU.EDU\n*\n*   REVISIONS:\n*    11/20/90 RBF Include changes made in 07/25/85 by Denis J. Audet,\n*                 Computing Centre, Univ of Ottawa: refine\n*                 detection of comments and quotes across split\n*                 lines, prevent truncation.  Make changes based on\n*                 ideas from PHS3@WATDCS.\n*    11/20/90 RBF Change syntax to allow: reformatting of selected\n*                 parts of file; left margin for all lines.  Move\n*                 Help info to Help File.\n*    12/16/90 RBF Change name to REXXFORM (old name REXFORM).\n*    03/17/91 RBF Add more syntax checking.\n*********************************************************************/\n   trace o\n   arg a\n   if a='?' then call Help\n   signal on syntax\n   'COMMAND PRESERVE'\n   'COMMAND SET MACRO OFF'; 'COMMAND SET SYNONYM OFF';\n   'SET ZONE 1 *'; 'SET LINEND OFF'; 'SET IMAGE OFF';\n   'SET RANGE :0 *'; 'SET DISPLAY 0 *'; 'SET CASE M I'; 'SET AUTO OFF';\n   'EXTRACT /LINE/SIZE/TRUNC/';\n   startl = line.1\n   cj=0; ci=0;\n   call ScanOpts\n   com=0; dqu=0; squ=0; indent=0; cont=0; unbal=''; lines=0;\n   ds='';   /* Line-number stack for DO's and SELECT's.              */\n   es='';   /* Line-number stack for END's.                          */\n   do i=startl to endl-1\n      '+1'\n      if rc>0 then leave\n      lines=lines+1\n      'EXTRACT/CURLINE/'; line=curline.3;\n      line = strip(line,'T')\n      sline=strip(line,'L')\n      if sline=' ' then iterate i\n      w1=translate(word(sline,1))\n      lw=translate(word(line,words(sline)))\n      j = Lscan(sline)\n      if j>0 then lastdo=i\n      else if j<0 then indent=indent+j\n      if indent<0 then indent=1\n      if dqu > 0 | squ > 0 then do\n         if dqu = 2 then dqu = 0\n         if squ = 2 then squ = 0\n         iterate\n      end\n      else do\n         if com>0 then do\n            if cj then repline= sline\n            else if ci then repline=,\n              substr(' ',1,lm+(indent)*in) || sline\n            else repline= line\n            if com>1 then com=0\n         end\n         else\n         if (substr(w1,length(w1),1)=':' | word(line,2)=':') &,\n           index(w1, \"'\") = 0\n         then repline=substr(' ',1,max(0,lm+(indent-1)*in))||sline\n         else\n         repline= substr(' ',1,lm+cont+indent*in)||sline\n         if length(repline) > trunc.1\n         then 'EMSG *** Unable to indent',\n           ' line:'i' within current XEDIT truncation setting ***'\n         else if repline == line then nop\n         else 'REPLACE' repline\n         if com == -1 then com = 1\n         else if dqu == -1 then dqu = 1\n         else if squ == -1 then squ = 1\n         else if substr(lw,length(lw))=',' then cont=2\n         else cont=0\n      end\n      if j>0 then indent=indent+j\n   end\n   ':'startl 'RESTORE'\n   if es<>'' then 'EMSG Unbalanced \"END\"s detected at lines: 'es\n   if ds<>'' then do\n      nds=''\n      do i=1 to words(ds)\n         nds=word(ds,i) nds\n      end\n      'EMSG Unbalanced \"DO\"s or \"SELECT\"s at lines: ' nds\n   end\n   if com>0 then 'EMSG Unbalanced comment'\n   if squ+dqu>0 then 'EMSG Unbalanced string constant'\n   'MSG' lines 'lines restructured from' startl 'to' endl-1\n   exit 0\nScanOpts:\n   i=pos('(',a)\n   if i>0 then if pos('(',a,i+1)>0\n   then call Errstop 'Left parentheses not allowed in targets'\n   parse var a a '(' opts\n   if a='' then a='* 4 3'\n   call ParseTarget\n   parse var t lm in r\n   if lm='' then lm=4\n   if in='' then in=3\n   if datatype(lm,'W')=0 | datatype(in,'W')=0 then call Errstop,\n     'Left margin and Indent values must be whole numbers'\n   if lm<0 | in<0 then call Errstop,\n     'Left margin and Indent values cannot be negative'\n   if r<>'' then call Errstop 'Incorrect arguments'\n   if lm+in>trunc.1 then call Errstop,\n     'Left margin plus Indent value cannot exceed the TRUNC setting'\n   if lm=0 then call Errstop 'Left margin value must be greater than 0'\n   if lm>trunc.1\n   then call Errstop 'Left margin can''t exceed TRUNC setting'\n   lm=lm-1\n   do i=1 to words(opts)\n      s=word(opts,i)\n      select\n         when s='CJ' then cj=1\n         when s='CI' then ci=1\n         otherwise call ErrStop 'Incorrect arguments'\n      end\n   end\n   'LOCATE' target\n   'EXTRACT/LINE/'\n   endl = line.1\n   ':'startl 'UP1'\n   return\nParseTarget:\n   target=''\n   push a\n   'PARSE 1 T'\n   if rc<>0 then call Errstop 'Incorrect target'\n   pull .\n   pull t1 t2\n   interpret 'parse var a' t1 'target' t1+t2 't'\n   return\nLscan: Procedure expose com dqu squ i ds es\n   arg s\n   Select\n      when com=1 then do\n         k= pos('*/',s)\n         if k>0 then do\n            s= substr(s,k+2)\n            com=2\n         end\n         else return 0\n      end\n      when dqu=1 then do\n         k= pos('\"',s)\n         if k>0 then do\n            s= substr(s,k+1)\n            dqu=2\n         end\n         else return 0\n      end\n      when squ=1 then do\n         k= pos(\"'\",s)\n         if k>0 then do\n            s= substr(s,k+1)\n            squ=2\n         end\n         else return 0\n      end\n      otherwise nop\n   End\n   qu = 0\n   do until s2 = '' | s = ' '\n      ls = 1+length(s)\n      kcom = pos('/*',s)\n      if kcom=0 then kcom=ls\n      kdqu = pos('\"',s)\n      if kdqu=0 then kdqu=ls\n      ksqu = pos(\"'\",s)\n      if ksqu=0 then ksqu=ls\n      select\n         when kcom<kdqu & kcom<ksqu then do\n            if pos('*/',s,kcom+2) = 0 then do\n               com = com-1\n               parse var s s '/*'\n               s2 = ''\n            end\n            else do\n               parse var s s1 '/*' s2 '*/' s3\n               s2 = '*'\n               s=s1 s3\n            end\n            iterate\n         end\n         when ksqu<kdqu then do\n            qu = 1\n            if pos(\"'\",s,ksqu+1) = 0 then do\n               squ = squ-1\n               parse var s s \"'\"\n               s2 = ''\n            end\n            else do\n               parse var s s1 \"'\" s2 \"'\" s3\n               s2 = '*'\n               s=s1 s3\n            end\n            iterate\n         end\n         when kdqu<ksqu then do\n            qu = 1\n            if pos('\"',s,kdqu+1) = 0 then do\n               dqu = dqu-1\n               parse var s s '\"'\n               s2 = ''\n            end\n            else do\n               parse var s s1 '\"' s2 '\"' s3\n               s2 = '*'\n               s=s1 s3\n            end\n            iterate\n         end\n         otherwise s2 = ''\n      end\n   end\n   if s = '' then do\n      if qu=0 & com<1 & dqu=squ then com = com + 2\n      return 0\n   end\n   k = 0\n   s=translate(s,' ',';')\n   do j=1 to words(s)\n      w=word(s,j)\n      select\n         when w='DO' | w='SELECT' then do\n            k=k+1; ds=i ds;\n         end\n         when w='END' then do\n            k=k-1;\n            if ds='' then es=es i\n            ds=delword(ds,1,1);\n         end\n         otherwise nop\n      end\n   end\n   return k\nErrstop:\n   parse arg m\n   'SET MSGM ON'\n   'EMSG' m\n   'RESTORE'\n   exit 16\nHelp:\n   call Saydo\n/*\nREXXFORM <target left-margin indent>  <( <CJ> <CI> >\nDefaults: target=*, left-margin=4, indent=3.\nFor more information, use HELP REXXFORM.\n*/\n   call Sayend\n   exit 0\nSaydo:  L1=sigl+2; return;\nSayend: Procedure Expose L1 sigl\n   L2=sigl-2\n   do i=L1 to L2\n      'MSG' sourceline(i)\n   end\n   return\nSyntax:\n   rr = rc\n   'EMSG REXXFORM LINE:' sigl sourceline(sigl)\n   'EMSG +++' errortext(rr)\n   'EMSG >>> error at file line 'i\n   'RESTORE'\n   exit 16\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXFRM": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x14\\x0f\\x00\\x98\\x14\\x0f# \\x014\\x014\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-05-20T00:00:00", "modifydate": "1998-05-20T23:20:00", "lines": 308, "newlines": 308, "modlines": 0, "user": "SBGOLOB"}, "text": "/*********************************************************************\n*\n*   ROUTINE:      REXXFORM\n*\n*   PURPOSE:      Structure/indent REXX execs\n*\n*   AUTHOR:       Robert Fowles, 02/04/84\n*                 (based on original exec by Jeffery Almoney)\n*                 Pennsylvania State University\n*                 Center for Academic Computing\n*                 107 Computer Building\n*                 University Park, PA  16802\n*                 814 865-4774\n*                 SHARE Installation code: PSU\n*                 Internet: rbf@psu.edu\n*\n*   REVISIONS:\n*    11/20/90 RBF Include changes made in 07/25/85 by Denis J. Audet,\n*                 Computing Centre, Univ of Ottawa: refine\n*                 detection of comments and quotes across split\n*                 lines, prevent truncation.  Make changes based on\n*                 ideas from PHS3@WATDCS.\n*    11/20/90 RBF Change syntax to allow: reformatting of selected\n*                 parts of file; left margin for all lines.  Move\n*                 Help info to Help File.\n*    12/16/90 RBF Change name to REXXFORM (old name REXFORM).\n*    03/17/91 RBF Add more syntax checking.\n*********************************************************************/\ntrace o\narg a\n\nif a='?' then call Help\n\nsignal on syntax\n\n'COMMAND PRESERVE'\n'COMMAND SET MACRO OFF'; 'COMMAND SET SYNONYM OFF';\n'SET ZONE 1 *'; 'SET LINEND OFF'; 'SET IMAGE OFF';\n'SET RANGE :0 *'; 'SET DISPLAY 0 *'; 'SET CASE M I'; 'SET AUTO OFF';\n'EXTRACT /LINE/SIZE/TRUNC/';\nstartl = line.1\n\ncj=0; ci=0;\ncall ScanOpts\n\ncom=0; dqu=0; squ=0; indent=0; cont=0; unbal=''; lines=0;\n\nds='';   /* Line-number stack for DO's and SELECT's.              */\nes='';   /* Line-number stack for END's.                          */\n\ndo i=startl to endl-1\n   '+1'\n   if rc>0 then leave\n   lines=lines+1\n   'EXTRACT/CURLINE/'; line=curline.3;\n   line = strip(line,'T')\n   sline=strip(line,'L')\n   if sline=' ' then iterate i\n   w1=translate(word(sline,1))\n   lw=translate(word(line,words(sline)))\n\n   j = Lscan(sline)\n\n   if j>0 then lastdo=i\n   else if j<0 then indent=indent+j\n   if indent<0 then indent=1\n\n   if dqu > 0 | squ > 0 then do\n      if dqu = 2 then dqu = 0\n      if squ = 2 then squ = 0\n      iterate\n   end\n   else do\n      if com>0 then do\n         if cj then repline= sline\n         else if ci then repline=,\n           substr(' ',1,lm+(indent)*in) || sline\n         else repline= line\n         if com>1 then com=0\n      end\n      else\n      if substr(w1,length(w1),1)=':' | word(line,2)=':'\n      then repline=substr(' ',1,max(0,lm+(indent-1)*in))||sline\n      else\n      repline= substr(' ',1,lm+cont+indent*in)||sline\n      if length(repline) > trunc.1\n      then 'EMSG *** Unable to indent',\n        ' line:'i' within current XEDIT truncation setting ***'\n      else if repline == line then nop\n      else 'REPLACE' repline\n      if com == -1 then com = 1\n      else if dqu == -1 then dqu = 1\n      else if squ == -1 then squ = 1\n      else if substr(lw,length(lw))=',' then cont=2\n      else cont=0\n   end\n   if j>0 then indent=indent+j\nend\n\n':'startl 'RESTORE'\nif es<>'' then 'EMSG Unbalanced \"END\"s detected at lines: 'es\nif ds<>'' then do\n   nds=''\n   do i=1 to words(ds)\n      nds=word(ds,i) nds\n   end\n   'EMSG Unbalanced \"DO\"s or \"SELECT\"s at lines: ' nds\nend\nif com>0 then 'EMSG Unbalanced comment'\nif squ+dqu>0 then 'EMSG Unbalanced string constant'\n'MSG' lines 'lines restructured from' startl 'to' endl-1\nexit 0\n\nScanOpts:\n   i=pos('(',a)\n   if i>0 then if pos('(',a,i+1)>0\n   then call Errstop 'Left parentheses not allowed in targets'\n   parse var a a '(' opts\n   if a='' then a='* 4 3'\n   call ParseTarget\n   parse var t lm in r\n   if lm='' then lm=4\n   if in='' then in=3\n   if datatype(lm,'W')=0 | datatype(in,'W')=0 then call Errstop,\n     'Left margin and Indent values must be whole numbers'\n   if lm<0 | in<0 then call Errstop,\n     'Left margin and Indent values cannot be negative'\n   if r<>'' then call Errstop 'Incorrect arguments'\n   if lm+in>trunc.1 then call Errstop,\n     'Left margin plus Indent value cannot exceed the TRUNC setting'\n   if lm=0 then call Errstop 'Left margin value must be greater than 0'\n   if lm>trunc.1\n   then call Errstop 'Left margin can''t exceed TRUNC setting'\n   lm=lm-1\n   do i=1 to words(opts)\n      s=word(opts,i)\n      select\n         when s='CJ' then cj=1\n         when s='CI' then ci=1\n         otherwise call ErrStop 'Incorrect arguments'\n      end\n   end\n   'LOCATE' target\n   'EXTRACT/LINE/'\n   endl = line.1\n   ':'startl 'UP1'\n   return\n\nParseTarget:\n   target=''\n   push a\n   'PARSE 1 T'\n   if rc<>0 then call Errstop 'Incorrect target'\n   pull .\n   pull t1 t2\n   interpret 'parse var a' t1 'target' t1+t2 't'\n   return\n\nLscan: Procedure expose com dqu squ i ds es\n   arg s\n\n   Select\n      when com=1 then do\n         k= pos('*/',s)\n         if k>0 then do\n            s= substr(s,k+2)\n            com=2\n         end\n         else return 0\n      end\n\n      when dqu=1 then do\n         k= pos('\"',s)\n         if k>0 then do\n            s= substr(s,k+1)\n            dqu=2\n         end\n         else return 0\n      end\n\n      when squ=1 then do\n         k= pos(\"'\",s)\n         if k>0 then do\n            s= substr(s,k+1)\n            squ=2\n         end\n         else return 0\n      end\n      otherwise nop\n   End\n\n   qu = 0\n   do until s2 = '' | s = ' '\n      ls = 1+length(s)\n      kcom = pos('/*',s)\n      if kcom=0 then kcom=ls\n      kdqu = pos('\"',s)\n      if kdqu=0 then kdqu=ls\n      ksqu = pos(\"'\",s)\n      if ksqu=0 then ksqu=ls\n\n      select\n         when kcom<kdqu & kcom<ksqu then do\n            if pos('*/',s,kcom+2) = 0 then do\n               com = com-1\n               parse var s s '/*'\n               s2 = ''\n            end\n            else do\n               parse var s s1 '/*' s2 '*/' s3\n               s2 = '*'\n               s=s1 s3\n            end\n            iterate\n         end\n\n         when ksqu<kdqu then do\n            qu = 1\n            if pos(\"'\",s,ksqu+1) = 0 then do\n               squ = squ-1\n               parse var s s \"'\"\n               s2 = ''\n            end\n            else do\n               parse var s s1 \"'\" s2 \"'\" s3\n               s2 = '*'\n               s=s1 s3\n            end\n            iterate\n         end\n\n         when kdqu<ksqu then do\n            qu = 1\n            if pos('\"',s,kdqu+1) = 0 then do\n               dqu = dqu-1\n               parse var s s '\"'\n               s2 = ''\n            end\n            else do\n               parse var s s1 '\"' s2 '\"' s3\n               s2 = '*'\n               s=s1 s3\n            end\n            iterate\n         end\n         otherwise s2 = ''\n      end\n   end\n\n   if s = '' then do\n      if qu=0 & com<1 & dqu=squ then com = com + 2\n      return 0\n   end\n\n   k = 0\n   s=translate(s,' ',';')\n\n   do j=1 to words(s)\n      w=word(s,j)\n      select\n         when w='DO' | w='SELECT' then do\n            k=k+1; ds=i ds;\n         end\n         when w='END' then do\n            k=k-1;\n            if ds='' then es=es i\n            ds=delword(ds,1,1);\n         end\n         otherwise nop\n      end\n   end\n   return k\n\nErrstop:\n   parse arg m\n   'SET MSGM ON'\n   'EMSG' m\n   'RESTORE'\n   exit 16\n\nHelp:\n   call Saydo\n/*\nREXXFORM <target left-margin indent>  <( <CJ> <CI> >\n\nDefaults: target=*, left-margin=4, indent=3.\n\nFor more information, use HELP REXXFORM.\n*/\n   call Sayend\n   exit 0\n\nSaydo:  L1=sigl+2; return;\nSayend: Procedure Expose L1 sigl\n   L2=sigl-2\n   do i=L1 to L2\n      'MSG' sourceline(i)\n   end\n   return\n\nSyntax:\n   rr = rc\n   'EMSG REXFORM LINE:' sigl sourceline(sigl)\n   'EMSG +++' errortext(rr)\n   'EMSG >>> error at file line 'i\n   'RESTORE'\n   exit 16\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXHLP": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x14\\x0f\\x00\\x98\\x14\\x0f# \\x00a\\x00a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-05-20T00:00:00", "modifydate": "1998-05-20T23:20:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "SBGOLOB"}, "text": ".cm ********************************************************************\n.cm\n.cm  FILE:          REXXFORM HELPCMS\n.cm\n.cm  FOR:           REXXFORM EXEC\n.cm\n.cm  PACKAGE:       USERTOOL\n.cm\n.cm  REFERENCED BY:\n.cm\n.cm  AUTHOR:        Robert Fowles <RBF@PSUVM> 11/25/90\n.cm\n.cm  REVISIONS:\n.cm\n.cm ********************************************************************\n.cs 1 on\n\n  REXXFORM is used to format Rexx files by indenting DO and SELECT groups and\n  left-justifying lines at a selected column.  It also checks for unbalanced DO\n  or SELECT statements.  One use of this Xedit macro is to restructure Rexx\n  files after composing them without regard to any particular format.\n\n.cs 1 off\n.cs 2 on\n\n\u00a2|FORMAT:\n\n  REXXFORM <target left-margin indent>  <( <CJ> <CI> >\n\n.cs 2 off\n.cs 3 on\n\u00a2|ARGUMENTS:\n\n \u00a2|target\n   is any Xedit target and is used to specify that all lines from the current\n   line up to (but not including) the target line will be scanned and\n   restructured according to the next two arguments.  If no target is given, it\n   is assumed to be '*' (i.e., from the current line to the end of the file).\n\n \u00a2|left-margin\n   specifies that all lines are either left-justified at this column, or\n   indented one or more columns to the right of this column.  The column given\n   by this argument must be a positive number not exceeding the width of the\n   file.  If not given, it is assumed to be 4.\n\n \u00a2|indent\n   specifies how many columns each DO or SELECT group is to be indented to the\n   right of the left-margin given by the first argument.  As each DO or SELECT\n   is encountered, the margin is moved \"indent\" to the right.  As each END is\n   encountered, the margin is moved \"indent\" to the left.  If \"indent\" is not\n   given, it is assumed to be 3.  If \"indent\" is 0, the set of specified lines\n   is left-justified at the column \"left-margin\".\n\n\n\u00a2|OPTIONS:\n\n  Comment lines and lines that are part of a comment are not shifted unless CJ\n  or CI is given.  The option CI causes these lines to be indented like all\n  other lines, and CJ causes them to be left-justified at column 1.\n\n\n.cs 3 off\n.cs 5 on\n\u00a2|USAGE NOTES:\n\n  When REXXFORM completes, it will display the line numbers of lines containing\n  unbalanced DOs, SELECTs, or ENDs.  In some cases, it will detect that a\n  comment or string is unbalanced (terminal '*/' or ending quote-mark missing).\n\n  REXXFORM without arguments is equivalent to \"REXXFORM * 4 3\".\n\n  REXX labels are indented one level to the left (if possible) to make the\n  program more legible.\n\n  This macro does not check keyword syntax.  Thus, any unquoted and uncommented\n  DO, SELECT or END word will affect the indentation.  Also, quoted strings\n  that exceed the maximum limit are not detected.  To check syntactical\n  contructs such as these, use the initial REXX instruction \"trace scan\".  The\n  worst that can happen is that the indentation will not be consistent\n  throughout the unsaved file with an message display about some unbalanced DO,\n  SELECT, or END construct.\n\n  Users of a previous version of REXXFORM known as REXFORM should be aware that\n  REXFORM restructured the entire file.  REXXFORM does not do that unless\n  positioned at the top of the file and a target of '*' is used.\n\n  This macro only reformats the specified lines by adding or deleting leading\n  blanks according to the arguments given.  No new lines are added and no data\n  other than leading blanks are affected.  In particular, non-leading blanks\n  are not affected.  However, as for any macro that changes your active file,\n  you may wish to make a temporary copy if you are not sure that the result\n  will be acceptable.\n.cs 5 off\n.cs 6 on\n\n\u00a2|ERROR MESSAGES\u00a2%\n.cs off\n", "mimetype": "text/troff", "datatype": "ebcdic", "extension": ".troff"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT591/FILE591.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT591", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}