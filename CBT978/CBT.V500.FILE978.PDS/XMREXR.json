{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "KTOMIAK", "INMTNODE": "ANYNODE", "INMTUID": "KTOMIAK", "INMFTIME": "20180523170130000000", "INMNUMF": 2}, "INMR02": {"1": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 251, "INMBLKSZ": 3120, "INMRECFM": "VB", "numfile": 1}, "2": {"INMUTILN": "IEBCOPY", "INMSIZE": 1528436, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 81, "INMBLKSZ": 27945, "INMRECFM": "FB", "INMDIR": 36, "INMDSNAM": "VENDOR.GENIE.WISHLIST", "INMMEMBR": "VENDOR.GENIE.WISHLIST", "numfile": 2}, "3": {"INMUTILN": "INMCOPY", "INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 2}}, "INMR03": {"1": {"INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}, "2": {"INMSIZE": 1528436, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "message": {"file": "b'@\\x7f\\xd2\\x85\\x95\\x95\\x85\\xa3\\x88@\\xc5@\\xe3\\x96\\x94\\x89\\x81\\x92\\x7fL\\xc3\\xc2\\xe3m\\xd2\\x85\\x95|\\xd2\\xe3\\x96\\x94\\x89\\x81\\x92K\\x82\\x89\\xa9n\\xe4K\\xe2K\\xc1K@\\xc3\\xc3z@\\xc1\\xd5\\xe8\\xd5\\xd6\\xc4\\xc5@a\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\\xd2K@\\xe3\\x96\\x94\\x89\\x81\\x92@@@@@@@@@@@@@@@@@@@@@@\\xe2\\xe3\\xc1\\xd5\\xc4\\xc1\\xd9\\xc4@\\xc7\\xd3\\xd6\\xc2\\xc1\\xd3@\\xc4\\xc9\\xe2\\xc3\\xd3\\xc1\\xc9\\xd4\\xc5\\xd9``````````````````````````\\xe3\\x88\\x85@\\x81\\xa4\\xa3\\x88\\x96\\x99@\\x85\\xa7\\x97\\x93\\x89\\x83\\x89\\xa3\\x93\\xa8@\\x84\\x89\\xa2\\x81\\xa5\\x96\\xa6\\xa2@\\x81\\x95\\xa8@\\x83\\x93\\x81\\x89\\x94@\\xa6\\x88\\x81\\xa3\\xa2\\x96\\x85\\xa5\\x85\\x99@\\x81\\x82\\x96\\xa4\\xa3@\\xa3\\x88\\x85\\x83\\x96\\x99\\x99\\x85\\x83\\xa3\\x95\\x85\\xa2\\xa2@\\x96\\x99@\\x86\\xa4\\x95\\x83\\xa3\\x89\\x96\\x95\\x81\\x93\\x89\\xa3\\xa8@\\x96\\x86@\\xa3\\x88\\x89\\xa2@\\x97\\x99\\x96\\x87\\x99\\x81\\x94k@\\x81\\x95\\x84@\\x84\\x89\\xa2\\x83\\x93\\x81\\x89\\x94\\xa2@\\x93\\x89\\x81\\x82\\x89\\x93\\x89\\xa3\\xa8\\x86\\x96\\x99@\\x81\\x95\\xa8\\xa3\\x88\\x89\\x95\\x87@\\x81\\x95\\x84@\\x85\\xa5\\x85\\x99\\xa8\\xa3\\x88\\x89\\x95\\x87@\\x82\\x81\\x84@\\xa3\\x88\\x81\\xa3@\\x94\\x89\\x87\\x88\\xa3@\\x88\\x81\\x97\\x97\\x85\\x95@\\x89\\x95@\\x83\\x96\\x95\\x95\\x85\\x83\\xa3\\x89\\x96\\x95@\\xa6\\x89\\xa3\\x88k\\x82\\x85\\x86\\x96\\x99\\x85k@\\x84\\xa4\\x99\\x89\\x95\\x87k@\\x96\\x99@\\x81\\x86\\xa3\\x85\\x99@\\xa4\\xa2\\x89\\x95\\x87@\\x89\\xa3K@\\xc9@\\x88\\x81\\xa5\\x85@\\xa3\\x99\\x89\\x85\\x84@\\xa3\\x96@\\x94\\x81\\x92\\x85@\\x89\\xa3@\\xa6\\x96\\x99\\x92@\\x99\\x89\\x87\\x88\\xa3k\\x81\\x95\\x84@\\xc9@\\x81\\x94@\\x97\\x85\\x99\\xa2\\x96\\x95\\x81\\x93\\x93\\xa8@\\x97\\x99\\x85\\xa3\\xa3\\xa8@\\x83\\x96\\x95\\x86\\x89\\x84\\x85\\x95\\xa3@\\xa3\\x88\\x81\\xa3@\\x89\\xa3@\\x84\\x96\\x85\\xa2k@\\x82\\xa4\\xa3@\\x85\\xa5\\x85\\x99\\xa8\\x82\\x96\\x84\\xa8@\\x94\\x81\\x92\\x85\\xa2\\x94\\x89\\xa2\\xa3\\x81\\x92\\x85\\xa2k@\\xa2\\x96@\\x89\\x86@\\xa8\\x96\\xa4@\\xa4\\xa2\\x85@\\x89\\xa3k@\\xa8\\x96\\xa4@\\x84\\x96@\\xa2\\x96@\\x81\\xa3@\\xa8\\x96\\xa4\\x99@\\x96\\xa6\\x95@\\x99\\x89\\xa2\\x92K@\\xe2\\x89\\x95\\x83\\x85\\x99\\x85\\x93\\xa8@\\xa8\\x96\\xa4\\x99\\xa2k\\xd2\\x85\\x95\\x95\\x85\\xa3\\x88@\\xc5K@\\xe3\\x96\\x94\\x89\\x81\\x92@'", "lrecl": 80, "text": " \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>U.S.A. CC: ANYNODE /KTOMIAK   K. Tomiak\n                     STANDARD GLOBAL DISCLAIMER--------------------------The aut\nhor explicitly disavows any claim whatsoever about thecorrectness or functionali\nty of this program, and disclaims liabilityfor anything and everything bad that\nmight happen in connection with,before, during, or after using it. I have tried\nto make it work right,and I am personally pretty confident that it does, but eve\nrybody makesmistakes, so if you use it, you do so at your own risk. Sincerely yo\nurs,Kenneth E. Tomiak\n"}, "file": {"VENDOR.GENIE.WISHLIST": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27945, "DS1LRECL": 81, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3000, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "180143", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x002'", "DS1LSTAR": "b'\\x00\\xdf\\x02'", "DS1TRBAL": "b'\\xa4\\x06'"}, "COPYR2": {"deb": "b'\\x05\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x06\\x80\\x00\\x04z\\xcb\\xc8'", "extents": ["b'\\x05\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x06\\x80\\x00\\x04z\\xcb\\xc8'", "b'X}Ch\\x00\\x00\\x0b\\xa8\\x00\\x05\\x0b\\xb7\\x00\\x0e\\x00\\xeb'", "b'X}Ch\\x00\\x00\\x08M\\x00\\x03\\x08N\\x00\\x02\\x00\\x0f'", "b'X}Ch\\x00\\x00\\x06W\\x00\\r\\x06[\\x00\\x02\\x002'", "b'X}Ch\\x00\\x00\\x07\\x9d\\x00\\x00\\x07\\xa0\\x00\\x04\\x002'", "b'X}Ch\\x00\\x00\\x07\\xa0\\x00\\x05\\x07\\xa3\\x00\\t\\x002'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"REXR": {"ttr": 39683, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17S\\x02\\x0e\\x02\\x0e\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:53:51", "lines": 526, "newlines": 526, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR\nTz/OS TSO/E REXX Reference\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590254\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNThe REstructured eXtended eXecutor (REXX) language is particularly\nNsuitable for:\nN\nN-> Command procedures\nN\nN-> Application front ends\nN\nN-> User-defined macros (such as editor subcommands)\nN\nN-> Prototyping\nN\nN-> Personal computing. Individual users can write programs for their\nN   own needs.\nN\nN\nNREXX Reference topics\nN=====================\nNChapter 1. Introduction\nN-----------------------\nN  What the SAA Solution Is\nN  ------------------------\nN  Benefits of using a compiler\nN  ----------------------------\nI\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Structure and general syntax\nN  ----------------------------\nN    Characters\nN    ----------\nN    Comments\nN    --------\nN    Tokens\nN    ------\nN    Implied semicolons\nN    ------------------\nN    Continuations\nN    -------------\nN  Expressions and operators\nN  -------------------------\nN    Expressions\nN    -----------\nN    Operators\nN    ---------\nN      String concatenation\nN      --------------------\nN      Arithmetic\nN      ----------\nN      Comparison\nN      ----------\nN      Logical (boolean)\nN      -----------------\nN    Parentheses and operator precedence\nN    -----------------------------------\nN  Clauses and instructions\nN  ------------------------\nN    Null clauses\nN    ------------\nN    Labels\nN    ------\nN    Instructions\nN    ------------\nN    Assignments\nN    -----------\nN    Keyword instructions\nN    --------------------\nN    Commands\nN    --------\nN  Assignments and symbols\nN  -----------------------\nN    Constant symbols\nN    ----------------\nN    Simple symbols\nN    --------------\nN    Compound symbols\nN    ----------------\nN    Stems\nN    -----\nN  Commands to external environments\nN  ---------------------------------\nN    Environments\nN    ------------\nN    Commands\nN    --------\nN    Host commands and host command environments\nN    -------------------------------------------\nN      The TSO host command environment\nN      --------------------------------\nN        TSO\nN      The CONSOLE host command environment\nN      ------------------------------------\nN        CONSOLE\nN      The ISPEXEC and ISREDIT host command environments\nN      -------------------------------------------------\nN        IspExec  - Invoke ISPF Dialog Manager verb\nN        IsrEdit  - Invoke ISPF EDIT verb\nN      The CPICOMM, LU62, and APPCMVS host command environments\nN      --------------------------------------------------------\nN        CPICOMM\nN        LU62\nN        APPCMVS\nN      The MVS host command environment\nN      --------------------------------\nN        MVS\nN      Host command environments for linking to and attaching programs\nN      ---------------------------------------------------------------\nN        LINK\nN        LINKMVS\nN        LINKPGM\nN        ATTACH\nN        ATTCHMVS\nN        ATTCHPGM\nI\nNChapter 3. Keyword instructions\nN-------------------------------\nN ADDRESS:   temporarily or permanently changes the destination of\nN            commands.\nN ARG:       retrieves the argument strings provided to a program or\nN            internal routine and assigns them to variables.\nN CALL:      calls a routine (if you specify name) or controls the\nN            trapping of certain conditions (if you specify ON or OFF).\nN DO:        groups instructions together and optionally processes them\nN            repetitively.\nN DROP:      'unassigns' variables, that is, restores them to their\nN            original uninitialized state.\nN EXIT:      leaves a program unconditionally.\nN IF:        conditionally processes an instruction or group of\nN            instructions depending on the evaluation of the\nN            expression.\nN INTERPRET: processes instructions that have been built dynamically\nN            by evaluating expression.\nN ITERATE:   alters the flow within a repetitive DO loop (that is, any\nN            DO construct other than that with a simple DO).\nN LEAVE:     causes an immediate exit from one or more repetitive DO\nN            loops (that is, any DO construct other than a simple DO).\nN NOP:       is a dummy instruction that has no effect.\nN NUMERIC:   changes the way in which a program carries out arithmetic\nN            operations.\nN OPTIONS:   passes special requests or parameters to the language\nN            processor.\nN PARSE:     assigns data (from various sources) to one or more\nN            variables according to the rules of parsing\nN PROCEDURE: within an internal routine (subroutine or function),\nN            protects variables by making them unknown to the\nN            instructions that fall outside of it.\nN PULL:      reads a string from the head of the external data queue.\nN PUSH:      stacks the string resulting from the evaluation of\nN            expression at the head of the external data queue. That is,\nN            it is added FIFO (First In, First Out) onto the external\nN            data queue.\nN QUEUE:     appends the string resulting from expression to the tail\nN            of the external data queue. That is, it is added\nN            LILO (Last In, Last Out).\nN RETURN:    returns control (and possibly a result) from a REXX\nN            program or internal routine to the point of its\nN            invocation.\nN SAY:       writes a line to the output stream.\nN SELECT:    conditionally calls one of several alternative\nN            instructions.\nN SIGNAL:    causes an unusual change in the flow of control (if you\nN            specify labelname or VALUE expression), or controls the\nN            trapping of certain conditions (if you specify ON or OFF).\nN TRACE:     controls the tracing action (that is, how much is\nN            displayed to the user) during processing of a REXX\nN            program.\nN UPPER:     translates the contents of one or more variables to\nN            uppercase.\nI\nNChapter 4. Functions\nN--------------------\nN  Built-in functions\nN  ------------------\nN    ABBREV:     returns 1 if info is equal to the leading characters\nN                of information and the length of info is not less than\nN                length. Returns 0 if either of these conditions is not\nN                met.\nN    ABS:        returns the absolute value of number. The result has\nN                no sign and is formatted according to the current\nN                NUMERIC settings.\nN    ADDRESS:    returns the name of the environment to which commands\nN                are currently being submitted.\nN    ARG:        returns an argument string or information about the\nN                argument strings to a program or internal routine.\nN    BITAND:     returns a string composed of the two input strings\nN                logically ANDed together, bit by bit.\nN    BITOR:      returns a string composed of the two input strings\nN                logically inclusive-ORed together, bit by bit.\nN    BITXOR:     returns a string composed of the two input strings\nN                logically eXclusive-ORed together, bit by bit.\nN    B2X:        returns a string, in character format, that represents\nN                binary_string converted to hexadecimal.\nN    CENTER:     returns a string of length length with string centered\nN                in it, with pad characters added as necessary to make\nN                up length.\nN    COMPARE:    returns 0 if the strings, string1 and string2, are\nN                identical. Otherwise, returns the position of the\nN                first character that does not match.\nN    CONDITION:  returns the condition information associated with the\nN                current trapped condition.\nN    COPIES:     returns n concatenated copies of string. The n must be\nN                a positive whole number or zero.\nN    C2D:        returns the decimal value of the binary representation\nN                of string. If the result cannot be expressed as a\nN                whole number, an error results. That is, the result\nN                must not have more digits than the current setting of\nN                NUMERIC DIGITS.\nN    C2X:        returns a string, in character format, that represents\nN                string converted to hexadecimal. The returned string\nN                contains twice as many bytes as the input string.\nN    DATATYPE:   returns NUM if you specify only string and if string\nN                is a valid REXX number that can be added to 0 without\nN                error; returns CHAR if string is not a valid number.\nN    DATE:       returns, by default, the local date in the format:\nN                  dd mon yyyy (day, month, year), for example:\nN                  1 Jan 2017 or 25 Dec 2001\nN                with no leading zero or blank on the day.\nN    DBCS:       See Appendix A. Double-byte character set (DBCS)\nN                support.\nN    DELSTR:     returns string after deleting the substring that\nN                begins at the nth character and is of length\nN                characters.\nN    DELWORD:    returns string after deleting the substring that\nN                starts at the nth word and is of length\nN                blank-delimited words.\nN    DIGITS:     returns the current setting of NUMERIC DIGITS.\nN    D2C:        returns a string, in character format, that represents\nN                wholenumber, a decimal number, converted to binary.\nN    D2X:        returns a string, in character format, that represents\nN                wholenumber, a decimal number, converted to\nN                hexadecimal.\nN    ERRORTEXT:  returns the REXX error message associated with error\nN                number n.\nN    EXTERNALS:  always returns a 0.\nN    FIND:       WORDPOS is the preferred built-in function for this\nN                type of word search.\nN    FORM:       returns the current setting of NUMERIC FORM.\nN    FORMAT:     returns number, rounded and formatted.\nN    FUZZ:       returns the current setting of NUMERIC FUZZ.\nN    INDEX:      POS is the preferred built-in function for obtaining\nN                the position of one string in another.\nN    INSERT:     inserts the string new, padded or truncated to length\nN                length, into the string target after the nth\nN                character.\nN    JUSTIFY:    returns string formatted by adding pad characters\nN                between blank-delimited words to justify to both\nN                margins.\nN    LASTPOS:    returns the position of the last occurrence of one\nN                string, needle, in another, haystack.\nN    LEFT:       returns a string of length length, containing the\nN                leftmost length characters of string.\nN    LENGTH:     returns the length of string.\nN    LINESIZE:   returns the current terminal line width minus 1 (the\nN                point at which the language processor breaks lines\nN                displayed using the SAY instruction).\nN    MAX:        returns the largest number from the list specified,\nN                formatted according to the current NUMERIC settings.\nN    MIN:        returns the smallest number from the list specified,\nN                formatted according to the current NUMERIC settings.\nN    OVERLAY:    returns the string target, which, starting at the nth\nN                character, is overlaid with the string new, padded or\nN                truncated to length length.\nN    POS:        returns the position of one string, needle, in another,\nN                haystack.\nN    QUEUED:     returns the number of lines remaining in the external\nN                data queue when the function is called.\nN    RANDOM:     returns a quasi-random nonnegative whole number in the\nN                range min to max inclusive.\nN    REVERSE:    returns string, swapped end for end.\nN    RIGHT:      returns a string of length length containing the\nN                rightmost length characters of string.\nN    SIGN:       returns a number that indicates the sign of number.\nN    SOURCELINE: returns the line number of the final line in the\nN                program OR if you specify n, returns the nth line in\nN                the program if available at the time of execution;\nN                otherwise, returns the null string.\nN    SPACE:      returns the blank-delimited words in string with n\nN                pad characters between each word.\nN    STRIP:      returns string with leading or trailing characters or\nN                both removed, based on the option you specify.\nN    SUBSTR:     returns the substring of string that begins at the nth\nN                character and is of length length, padded with pad if\nN                necessary.\nN    SUBWORD:    returns the substring of string that starts at the nth\nN                word, and is up to length blank-delimited words.\nN    SYMBOL:     returns the state of the symbol named by name.\nN    TIME:       returns the local time in the 24-hour clock format:\nN                hh:mm:ss (hours, minutes, and seconds) by default,\nN                for example, 04:41:37.\nN    TRACE:      returns trace actions currently in effect and,\nN                optionally, alters the setting.\nN    TRANSLATE:  returns string with each character translated to\nN                another character or unchanged.\nN    TRUNC:      returns the integer part of number and n decimal\nN                places.\nN    USERID:     returns the TSO/E user ID, if the REXX exec is running\nN                in the TSO/E address space.\nN    VALUE:      returns the value of the symbol that name (often\nN                constructed dynamically) represents and optionally\nN                assigns it a new value.\nN    VERIFY:     returns a number that, by default, indicates whether\nN                string is composed only of characters from reference;\nN                returns 0 if all characters in string are in\nN                reference, or returns the position of the first\nN                character in string not in reference.\nN    WORD:       returns the nth blank-delimited word in string or\nN                returns the null string if fewer than n words are in\nN                string.\nN    WORDINDEX:  returns the position of the first character in the nth\nN                blank-delimited word in string or returns 0 if fewer\nN                than n words are in string.\nN    WORDLENGTH: returns the length of the nth blank-delimited word in\nN                string or returns 0 if fewer than n words are in\nN                string.\nN    WORDPOS:    returns the word number of the first word of phrase\nN                found in string or returns 0 if phrase contains no\nN                words or if phrase is not found.\nN    WORDS:      returns the number of blank-delimited words in string.\nN    XRANGE:     returns a string of all valid 1-byte encodings (in\nN                ascending order) between and including the values\nN                start and end.\nN    X2B:        returns a string, in character format, that represents\nN                hexstring converted to binary.\nN    X2C:        returns a string, in character format, that represents\nN                hexstring converted to character.\nN    X2D:        returns the decimal representation of hexstring.\nN\nN  TSO/E external functions\nN  ------------------------\nN    GETMSG:     returns a function code that replaces the function\nN                call and retrieves, in variables, a message that has\nN                been issued during a console session.\nN    LISTDSI:    returns one of the following function codes that\nN                replace the function call, and retrieves information\nN                about a data set's allocation, protection, and\nN                directory and stores it in specific variables.\nN    MSG:        MSG returns the value ON or OFF, which indicates the\nN                status of the displaying of TSO/E messages.\nN    MVSVAR:     returns information about MVS, TSO/E, and the current\nN                session, such as the symbolic name of the MVS system,\nN                or the security label of the TSO/E session.\nN    OUTTRAP:    returns the name of the variable in which trapped\nN                output is stored, or if trapping is not in effect,\nN                OUTTRAP returns the word off.\nN    PROMPT:     returns the value ON or OFF, which indicates the\nN                setting of prompting for the exec.\nN    SETLANG:    SETLANG returns a three character code that indicates\nN                the language in which REXX messages are currently\nN                being displayed.\nN    STORAGE:    returns length bytes of data from the specified\nN                address in storage.\nN    SYSCPUS:    places, in a stem variable, information about those\nN                CPUs that are online.\nN    SYSDSN:     returns one of the following messages indicating\nN                whether the specified dsname exists and is available\nN                for use.\nN    SYSVAR:     returns information about MVS, TSO/E, and the current\nN                session, such as levels of software available, your\nN                logon procedure, and your user ID.\nI\nNChapter 5. Parsing\nN------------------\nI\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nI\nNChapter 7. Conditions and condition traps\nN-----------------------------------------\nN CALL ON/off:   calls a routine (if you specify name) or controls\nN                the trapping of certain conditions (if you specify ON\nN                or OFF).\nN SIGNAL:        causes an unusual change in the flow of control (if\nN                you specify labelname or VALUE expression), or\nN                controls the trapping of certain conditions (if you\nN                specify ON or OFF).\nN  Condition information\nN  ---------------------\nN  Special variables\nN  -----------------\nN    RC:         For ERROR and FAILURE, the REXX special variable RC is\nN                set to the command return code, as usual, before\nN                control is transferred to the condition label.\nN    SIGL:       Following any transfer of control because of a CALL or\nN                SIGNAL, the program line number of the clause causing\nN                the transfer of control is stored in the special\nN                variable SIGL.\nI\nNChapter 8. Using REXX in different address spaces\nN-------------------------------------------------\nI\nNChapter 9. Reserved keywords, special variables, and command names\nN------------------------------------------------------------------\nN  Reserved keywords\nN  -----------------\nN  Special variables\nN  -----------------\nN    RC:         is set to the return code from any executed host\nN                command (or subcommand).\nN    RESULT:     is set by a RETURN instruction in a subroutine that\nN                has been called, if the RETURN instruction specifies\nN                an expression.\nN    SIGL:       contains the line number of the clause currently\nN                executing when the last transfer of control to a label\nN                took place.\nN  Reserved command names\nN  ----------------------\nI\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nN  DELSTACK:     deletes the most recently created data stack that was\nN                created by the NEWSTACK command, and all elements on\nN                it.\nN  DROPBUF:      removes the most recently created data stack buffer\nN                that was created with the MAKEBUF command, and all\nN                elements on the data stack in the buffer.\nN  EXECIO:       controls the input and output (I/O) of information to\nN                and from a data set.\nN  EXECUTIL:     lets you change various characteristics that control\nN                how an exec processes in the TSO/E address space.\nN  MAKEBUF:      Use the MAKEBUF command to create a new buffer on the\nN                data stack.\nN  NEWSTACK:     creates a new data stack and basically hides or\nN                isolates the current data stack.\nN  QBUF:         queries the number of buffers that were created on the\nN                data stack with the MAKEBUF command.\nN  QELEM:        queries the number of data stack elements that are in\nN                the most recently created data stack buffer (that is,\nN                in the buffer that was created by the MAKEBUF\nN                command).\nN  QSTACK:       queries the number of data stacks in existence for an\nN                exec that is running.\nN  SUBCOM:       queries the existence of a specified host command\nN                environment.\nN  Immediate Commands\nN  ------------------\nN    HE:         (Halt Execution) is an immediate command you can use\nN                to halt the execution of a REXX exec.\nN    HI:         (Halt Interpretation) is an immediate command you can\nN                use to halt the interpretation of all currently\nN                executing execs.\nN    HT:         (Halt Typing) is an immediate command you can use to\nN                suppress terminal output that an exec generates.\nN    RT:         (Resume Typing) is an immediate command you can use to\nN                resume terminal output that was previously suppressed.\nN    TE:         (Trace End) is an immediate command you can use to end\nN                tracing REXX execs.\nN    TS:         (Trace Start) is an immediate command you can use to\nN                start tracing REXX execs.\nI\nNChapter 11. Debug aids\nN----------------------\nI\nNChapter 12. TSO/E REXX programming services\nN-------------------------------------------\nI\nNChapter 13. TSO/E REXX customizing services\nN-------------------------------------------\nI\nNChapter 14. Language Processor Environments\nN-------------------------------------------\nI\nNChapter 15. Initialization and termination routines\nN---------------------------------------------------\nI\nNChapter 16. Replaceable routines and exits\nN------------------------------------------\nI\nNAppendix A. Double-byte character set (DBCS) support\nN----------------------------------------------------\nN  Function descriptions\nN  ---------------------\nN    DBadjust:    In EBCDIC, adjusts all contiguous SI and SO (or SO\nN                 and SI) characters in string based on the operation\nN                 specified.\nN    DBbracket:   In EBCDIC, adds SO and SI brackets to a DBCS-only\nN                 string.\nN    DBcenter:    returns a string of length length with string\nN                 centered in it, with pad characters added as\nN                 necessary to make up length.\nN    DBCjustify:  formats string by adding pad characters between\nN                 nonblank characters to justify to both margins and\nN                 length of bytes length (length must be nonnegative).\nN    DBleft:      returns a string of length length containing the\nN                 leftmost length characters of string.\nN    DBright:     returns a string of length length containing the\nN                 rightmost length characters of string.\nN    DBrleft:     returns the remainder from the DBLEFT function of\nN                 string.\nN    DBrright:    returns the remainder from the DBRIGHT function of\nN                 string.\nN    DBtodbcs:    converts all passed, valid SBCS characters (including\nN                 the SBCS blank) within string to the corresponding\nN                 DBCS equivalents.\nN    DBtosbcs:    converts all passed, valid DBCS characters (including\nN                 the DBCS blank) within string to the corresponding\nN                 SBCS equivalents.\nN    DBunbracket: In EBCDIC, removes the SO and SI brackets from a\nN                 DBCS-only string enclosed by SO and SI brackets.\nN    DBvalidate:  returns 1 if the string is a valid mixed string or\nN                 SBCS string.\nN    DBwidth:     returns the length of string in bytes.\nI\nNAppendix B. IRXTERMA routine\nN----------------------------\nI\nNAppendix C. Writing REXX Execs to perform MVS operator activities\nN-----------------------------------------------------------------\nI\nNAppendix D. Additional variables that GETMSG sets\nN-------------------------------------------------\nI\nNAppendix E. REXX symbol and hexadecimal code cross-reference\nN------------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR01": {"ttr": 39937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17S\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:53:51", "lines": 30, "newlines": 30, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR01\nTz/OS TSO/E REXX Reference\nT-Chapter 1. Introduction\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590254\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 1. Introduction\nN-----------------------\nNThis introduction gives a brief overview of the Systems Application\nNArchitecture (SAA) solution.\nM\nMYou either write bulky code that is platform aware or abandon the\nMpipe dream of having a program that runs on every platform and write\nMsomething useful on one platform.\nI\nIThe next two advertising topics contain snippets of IBM material.\nN\nN  What the SAA Solution Is\nN  ------------------------\nN  Benefits of using a compiler\nN  ----------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0101": {"ttr": 39939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17S\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:53:51", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0101\nTz/OS TSO/E REXX Reference\nT-Chapter 1.\nT-What the SAA Solution Is\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175351\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 1. Introduction\nN-----------------------\nN  What the SAA Solution Is\nN  ------------------------\nNThe SAA solution is based on a set of software interfaces, conventions,\nNand protocols that provide a framework for designing and developing\nNapplications.\nN\nNThe purpose of SAA REXX is to define a common subset of the language\nNthat can be used on several environments. TSO/E REXX is the\nNimplementation of SAA REXX on the z/OS system. If you plan on running\nNyour REXX programs on other environments, however, some restrictions\nNcan apply and you should review the publication SAA Common Programming\nNInterface REXX Level 2 Reference.\nN\nNSupported environments\nN----------------------\nNSeveral combinations of IBM hardware and software have been selected\nNas SAA environments.\nN\nNThe SAA environments are the following:\nN-> z/OS\nN   -> Base system (TSO/E, APPC/MVS, batch)\nN   -> CICS TS\nN   -> IMS\nN-> z/VM\nN-> i5/OS\nN-> Operating System/2 (OS/2)\nN\nN\nNCommon programming interface\nN----------------------------\nNThe Common Programming Interface (CPI) provides languages and services\nNthat programmers can use to develop applications that take advantage\nNof SAA consistency.\nN\nNThe CPI is not in itself a product or a piece of code. But as a\nNdefinition it does establish and control how IBM products are being\nNimplemented, and it establishes a common base across the applicable\nNSAA environments.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0102": {"ttr": 39941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17V\\x00f\\x00f\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:56:55", "lines": 102, "newlines": 102, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0102\nTz/OS TSO/E REXX Reference\nT-Chapter 1.\nT-Benefits of using a compiler\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175655\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 1. Introduction\nN-----------------------\nN  Benefits of using a compiler\nN  ----------------------------\nNThe IBM Compiler for REXX/370 and the IBM Library for REXX/370\nNprovide significant benefits for programmers during program\nNdevelopment and for users when a program is run. The benefits are:\nN\nN-> Improved performance\nN\nN-> Reduced system load\nN\nN-> Protection for source code and programs\nN\nN-> Improved productivity and quality\nN\nN-> Portability of compiled programs\nN\nN-> SAA compliance checking\nN\nN-> Improved performance\nN\nN-> Reduced system load\nN\nNImproved performance\nN--------------------\nNThe performance improvements that you can expect when you run compiled\nNREXX programs depend on the type of program. A program that performs\nNlarge numbers of arithmetic operations of default precision shows the\nNgreatest improvement. A program that mainly issues commands to the\nNhost shows minimal improvement because REXX cannot decrease the time\nNtaken by the host to process the commands.\nI\nITake note of how a truly useful program will have minimal improvement.\nN\nNReduced system load\nN-------------------\nNCompiled REXX programs run faster than interpreted programs. Because a\nNprogram has to be compiled only one time, system load is reduced and\nNresponse time is improved when the program is run frequently.\nI\nIRun frequently without being modified since modifications require\nIre-compiling, an increase on system load. And yes, additional Disk\nIresources to hold both the source and the load module.\nM\nMThe REXX Compiler also comes with some limitations.\nN\nNProtection for source code and programs\nN---------------------------------------\nNYour REXX programs and algorithms are assets that you want to protect.\nNThe Compiler produces object code, which helps you protect these\nNassets by discouraging other users from making unauthorized changes\nNto your programs.\nN\nNImproved productivity and quality\nN---------------------------------\nNThe Compiler can produce source listings, cross-reference listings,\nNand messages, which help you more easily develop and maintain your\nNREXX programs. The Compiler identifies syntax errors in a program\nNbefore you start testing it. You can then focus on correcting errors\nNin logic during testing with the REXX interpreter.\nM\nMYou will consume more of the system while viewing those listings and\nMmessages, thus a rarely used program will have a trade-off from\nNreduced work load to increased development work load.\nN\nNPortability of compiled programs\nN--------------------------------\nNA REXX program compiled under MVS/ESA can run under CMS. Similarly, a\nNREXX program compiled under CMS can run under MVS/ESA.\nM\nMThat program needs bulky code to handle the disparate ways of doing\nMI/O (reading and writing different file environments).\nN\nNSAA compliance checking\nN-----------------------\nNThe Systems Application Architecture (SAA) definitions of software\nNinterfaces, conventions, and protocols provide a framework for\nNdesigning and developing applications that are consistent within\nNand across several operating systems. SAA REXX is a subset of the\nNREXX language supported by the interpreter under TSO/E and can be\nNused in this operating environment.\nN\nNYou can distribute your REXX programs in object code only.\nM\nMYou need the right options if you use SOURCELINE(n).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR02": {"ttr": 39943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:19", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR02\nTz/OS TSO/E REXX Reference\nT-Chapter 2. REXX general concepts\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175719\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nNThe REstructured eXtended eXecutor (REXX) language is particularly\nNsuitable for:\nN\nN-> Command procedures\nN\nN-> Application front ends\nN\nN-> User-defined macros (such as editor subcommands)\nN\nN-> Prototyping\nN\nN-> Personal computing. Individual users can write programs for their\nN   own needs.\nN\nNREXX is a general purpose programming language.\nN\nN\nNREXX programs are run by a language processor (interpreter). That is,\nNthe program is run line-by-line and word-by-word, without first being\nNtranslated to another form (compiled). The advantage of this is you\nNcan fix the error and rerun the program faster than you can with a\nNcompiler.\nM\nMThat suggests you not use the compiler until after you have fully\nMtested your code. Negating the benefit of the listings raved about\nMin Chapter 1. Introduction.\nM\nMIf you choose to recompile after every change than you offset the\nMsavings in system load.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0201": {"ttr": 39945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00%\\x00%\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:20", "lines": 37, "newlines": 37, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0201\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Structure and general syntax\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175720\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Structure and general syntax\nN  ----------------------------\nNIf you store a REXX exec in a data set that is allocated to SYSPROC,\nNthe exec must start with a comment and the comment must contain the\nNcharacters 'REXX' within the first line (line 1) of the exec.\nM\nMCorrecting the IBM verbiage, if you run a REXX exec out of SYSPROC\nMthen the first line must contain a comment with the string 'REXX' in\nMit. That is, it need not start with a comment but the comment needs\nMto be on the first line.\nM\nMFurther, if you wish to compile your REXX code then the first line\nMmust start with a comment and the string 'REXX' in it.\nM\nMThe 'REXX' string is case-insensitive.\nM\nMKenneth Tomiak recommendation: use a comment that declares the\nMcorrect reason:\nD/* We first need rexx in comment if compiled or read from SYSPROC. */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0202": {"ttr": 39947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:20", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0202\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Structure and general syntax\nT-Characters\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175720\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Structure and general syntax\nN  ----------------------------\nNCharacters\nN----------\nNA character is a member of a defined set of elements that is used for\nNthe control or representation of data. You can usually enter a\nNcharacter with a single keystroke.\nM\nMAvoid turning HEX ON to enter a character. Instead, define a variable\nMand assign the hexadecimal literal, as in cent_sign = '4A'x.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0203": {"ttr": 39949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x005\\x005\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:20", "lines": 53, "newlines": 53, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0203\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Structure and general syntax\nT-Comments\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175720\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Structure and general syntax\nN  ----------------------------\nNComments\nN--------\nNA comment is a sequence of characters (on one or more lines) delimited\nNby /* and */. Within these delimiters any characters are allowed.\nNComments can contain other comments, as long as each begins and ends\nNwith the necessary delimiters. They are called nested comments.\nM\nMRepeating the important part of comments, if you use /* within a\nMcomment then it must be terminated wirh */. This can crop up if you\nMattempt to put JCL in a comment and use //* for JCL comments.\nN\nD/* Begin of multi-line (block) comment\nD\nD   Use the following JCL to run this as a batch job:\nD\nD   //jobname JOB (acct),'programmer name',...\nD   //*                                                    */\nD   //* Purpose: Run REXX code as a batch job.             */\nD   //*                                                    */\nD   //ST01#01 EXEC PGM=IKJEFT1B,DYNAMNBR=12,\nD   //             PARM=''\nD   //SYSTSIN   DD *,DLM=$$\nD     %myrexx\nD     logoff\nD     This is not executed.\nD   $$\nD   //SYSTSPRT  DD SYSOUT=*\nD   //*                                                    */\nD   //* End of Job.                                        */\nD   //\nD\nD   End of multi-line (block) comment                      */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0204": {"ttr": 39951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00=\\x00=\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:20", "lines": 61, "newlines": 61, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0204\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Structure and general syntax\nT-Tokens\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175720\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Structure and general syntax\nN  ----------------------------\nNTokens\nN------\nNA token is the unit of low-level syntax from which clauses are built.\nNPrograms written in REXX are composed of tokens. They are separated\nNby blanks or comments or by the nature of the tokens themselves. The\nNclasses of tokens are:\nN\nNLiteral Strings:\nN----------------\nNA literal string is a sequence including any characters and delimited\nNby the single quotation mark (') or the double quotation mark (\").\nI\nITypists and mainframers know the difference between an apostrophe (')\nIand the quote(\"). PC people eventually learn quotation mark refers to\nImore than the apostrophe and quote and includes various flavors of\nIsmart quotes. So you younger folks have to deal using double single\nIquotation marks and double double quotation marks when writing code.\nN\nNA literal string is a constant and its contents are never modified\nNwhen it is processed.\nN\nD'Fred'\nD'''Fred'''\nD\"'Fred'\"\nD\"Fred\"\nD'\"Fred\"'\nD\"\"\"Fred\"\"\"\nN\nNHexadecimal Strings:\nN--------------------\nNA hexadecimal string is a literal string, expressed using a\nNhexadecimal notation of its encoding. It is any sequence of zero or\nNmore hexadecimal digits (0-9, a-f, A-F), grouped in pairs. The groups\nNof digits are optionally separated by one or more blanks, and the\nNwhole sequence is delimited by single or double quotation marks, and\nNimmediately followed by the symbol X or x.\nN\nD'1DF'X\nD'1 DF'x\nD\"01 DF\"x\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0205": {"ttr": 39953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\"\\x00\"\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:21", "lines": 34, "newlines": 34, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0205\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Structure and general syntax\nT-Implied semicolons\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175721\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Structure and general syntax\nN  ----------------------------\nNImplied semicolons\nN------------------\nNThe last element in a clause is the semicolon delimiter. The language\nNprocessor implies the semicolon: at a line-end, after certain\nNkeywords, and after a colon if it follows a single symbol. This means\nNthat you need to include semicolons only when there is more than one\nNclause on a line or to end an instruction whose last character is a\nNcomma.\nM\nMThere is a performance penalty for explicitely coding a semicolon on\nMa single clause line or after the last clause as the REXX interpreter\nMassumes another clause follows on the same line only to find there\nMis none.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0206": {"ttr": 39955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:21", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0206\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Structure and general syntax\nT-Continuations\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175721\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Structure and general syntax\nN  ----------------------------\nNContinuations\nN-------------\nNA clause can be continued onto the next line by using the comma, which\nNis referred to as the continuation character. The comma is\nNfunctionally replaced by a blank, and, thus, no semicolon is implied.\nN\nD  Say \"This is wider than the 72 characters I see in my EDIT session\" ,\nD    \"so I continued it onto a second line.\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0210": {"ttr": 39957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:21", "lines": 23, "newlines": 23, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0210\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Expressions and operators\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175721\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Expressions and operators\nN  -------------------------\nNExpressions in REXX are a general mechanism for combining one or more\nNpieces of data in various ways to produce a result, usually different\nNfrom the original data.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0211": {"ttr": 40193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:21", "lines": 28, "newlines": 28, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0211\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Expressions and operators\nT-Expressions\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175721\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Expressions and operators\nN  -------------------------\nNExpressions\nN-----------\nNExpressions consist of one or more terms (literal strings, symbols,\nNfunction calls, or subexpressions) interspersed with zero or more\nNoperators that denote operations to be carried out on terms. A\nNsubexpression is a term in an expression bracketed within a left and\nNa right parenthesis.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0212": {"ttr": 40195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00#\\x00#\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:22", "lines": 35, "newlines": 35, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0212\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Expressions and operators\nT-Operators\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175722\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Expressions and operators\nN  -------------------------\nNOperators\nN---------\nNAn operator is a representation of an operation, such as addition, to\nNbe carried out on one or two terms.\nN\nNThere are four types of operators:\nN\nN-> String Concatenation\nN\nN-> Arithmetic\nN\nN-> Comparison\nN\nN-> Logical (boolean)\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0213": {"ttr": 40197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:22", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0213\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Expressions and operators\nT-String concatenation\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175722\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Expressions and operators\nN  -------------------------\nNString Concatenation\nN--------------------\nNThe concatenation operators combine two strings to form one string by\nNappending the second string to the right-hand end of the first string.\nNThe concatenation might occur with or without an intervening blank.\nNThe concatenation operators are:\nN\nN-> (blank)   Concatenate terms with one blank in between\nN\nN->||        Concatenate without an intervening blank\nN\nN->(abuttal) Concatenate without an intervening blank\nN\nNExamples:\nN---------\nD  age = 55\nD  Say \"Fred is\" age \"year(s) old.\"\nD  Say \"Fred is \"age\" year(s) old.\"\nD  Say \"Fred is \" || age || \"year(s) old.\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0214": {"ttr": 40199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00:\\x00:\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:22", "lines": 58, "newlines": 58, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0214\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Expressions and operators\nT-Arithmetic\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175722\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Expressions and operators\nN  -------------------------\nNArithmetic\nN----------\nNYou can combine character strings that are valid numbers using the\nNarithmetic operators:\nN\nN-> + Add\nD     running_total = 0\nD     running_total = running_total + 15.99\nD     sales_tax = 1.78\nD     running_total = running_total + sales_tax\nN\nN-> - Subtract\nD     running_total = running_total - 1.59\nN\nN-> * Multiply\nD     hours = 45\nD     rate = 125\nD     invoice = hours * rate\nN\nN-> / Divide\nD     monthly_amt = invoice / 12\nN\nN-> % Integer divide (divide and return the integer part of the result)\nD     ignore_pennies = 1234.56 / 6\nN\nN-> // Remainder (divide and return the remainder not modulo, because\nN      the result may be negative)\nD     lost_pennies = 1234.56 // 6\nN\nN-> ** Power (raise a number to a whole-number power)\nD      two_to_the_tenth = 2 ** 10\nN\nN-> Prefix - Same as the subtraction: 0 - number\nD            negative_12 = -12\nN\nN-> Prefix + Same as the addition: 0 + number\nD            positive_12 = +12\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0215": {"ttr": 52740, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x18\\x13\\x7f\\x01\\x18\\x14/\\x15S\\x00^\\x00^\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-22T15:53:34", "lines": 94, "newlines": 94, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0215\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Expressions and operators\nT-Comparison\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180522-155334\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Expressions and operators\nN  -------------------------\nNComparison\nN----------\nIMake your life easier and never use the not character as it gets\nImangled in an ASCII ftp session and the terminal emulators rarely use\nIthe shift-6 keystroke to properly use ,. You will likely get the\nIcaret (\u00ac) and a SYNTAX error.\nI\nMThe 'Kenneth Tomiak Programming Method' (KTPM07) recommends\nMcoding for a positive (TRUE) test instead of the negative test. But\nMif you feel the negative test occurs more frequently than use the\nMbackslash (\\) character.\nN\nNThe comparison operators compare two terms and return the value 1 if\nNthe result of the comparison is true, or 0 otherwise.\nN\nNThe strict comparison operators all have one of the characters\nNdefining the operator doubled. The ==, \\==, /==, and ,== operators\nNtest for an exact match between two strings. The two strings must be\nNidentical (character by character) and of the same length to be\nNconsidered strictly equal. Similarly, the strict comparison operators\nNsuch as >>, or ,<< carry out a simple character-by-character\nNcomparison, with no padding of either of the strings being compared.\nNThe comparison of the two strings is from left to right. If one\nNstring is shorter than and is a leading substring of another, then it\nNis smaller than (less than) the other. The strict comparison operators\nNalso do not attempt to perform a numeric comparison on the two\nNoperands.\nN\nNThe comparison operators and operations are:\nN\nN-> = True if the terms are equal (numerically or when padded, and so\nN     forth)\nN\nN-> \\=, ,=, /= True if the terms are not equal (inverse of =)\nN\nN-> > Greater than\nN\nN-> < Less than\nN\nN-> >< Greater than or less than (same as not equal)\nN\nN-> <> Greater than or less than (same as not equal)\nN\nN-> >= Greater than or equal to\nN\nN-> \\<, ,< Not less than\nN\nN-> <= Less than or equal to\nN\nN-> \\>, ,> Not greater than\nN\nN-> == True if terms are strictly equal (identical)\nN\nN-> \\==, ,==, /== True if the terms are NOT strictly equal (inverse\nN                 of ==)\nN\nN-> >> Strictly greater than\nN\nN-> << Strictly less than\nN\nN-> >>= Strictly greater than or equal to\nN\nN-> \\<<, ,<< Strictly NOT less than\nN\nN-> <<= Strictly less than or equal to\nN\nN-> \\>>, ,>> Strictly NOT greater than\nN\nNGuideline: Throughout the language, the not character, ,, is\nNsynonymous with the backslash (\\). You can use the two characters\nNinterchangeably, according to availability and personal preference.\nNThe backslash can appear in the following operators: \\ (prefix not),\nN\\=, \\==, \\<, \\>, \\<<, and \\>>.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0216": {"ttr": 40201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00#\\x00#\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:23", "lines": 35, "newlines": 35, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0216\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Expressions and operators\nT-Logical (boolean)\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175723\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Expressions and operators\nN  -------------------------\nNLogical (boolean)\nN-----------------\nNA character string is taken to have the value false if it is 0, and\nNtrue if it is 1. The logical operators take one or two such values\nN(values other than 0 or 1 are not allowed) and return 0 or 1 as\nNappropriate:\nN\nN-> & AND Returns 1 if both terms are true.\nN\nN-> | Inclusive OR Returns 1 if either term is true.\nN\nN-> && Exclusive OR Returns 1 if either (but not both) is true.\nN\nN-> Prefix \\,, Logical NOT Negates; 1 becomes 0, and 0 becomes 1\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0217": {"ttr": 40203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00&\\x00&\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:23", "lines": 38, "newlines": 38, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0217\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Parentheses and operator precedence\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175723\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Parentheses and operator precedence\nN  -----------------------------------\nNExpression evaluation is from left to right; parentheses and operator\nNprecedence modify this:\nN\nN-> When parentheses are encountered (other than those that identify\nN   function calls) the entire subexpression between the parentheses\nN   is evaluated immediately when the term is required.\nN\nN-> When the sequence:\nN     term1 operator1 term2 operator2 term3\nN   is encountered, and operator2 has a higher precedence than\nN   operator1, the subexpression (term2 operator2 term3) is evaluated\nN   first. The same rule is applied repeatedly as necessary.\nN\nNNote, however, that individual terms are evaluated from left to right\nNin the expression (that is, as soon as they are encountered). The\nNprecedence rules affect only the order of operations.\nM\nMI encourage you to use parentheses for readability.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0220": {"ttr": 40205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00!\\x00!\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:23", "lines": 33, "newlines": 33, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0220\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Clauses and instructions\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175723\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Clauses and instructions\nN  ------------------------\nNClauses can be subdivided into the following types:\nN\nN-> Null clauses\nN\nN-> Labels\nN\nN-> Instructions\nN\nN-> Assignments\nN\nN-> Keyword instructions\nN\nN-> Commands\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0221": {"ttr": 40207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:23", "lines": 31, "newlines": 31, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0221\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Clauses and instructions\nT-Null clauses\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175723\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Clauses and instructions\nN  ------------------------\nNNull clauses\nN------------\nNA clause consisting only of blanks or comments or both is a null\nNclause. It is completely ignored (except that if it includes a comment\nNit is traced, if appropriate).\nN\nNExample:\nN--------\nD\nD /* The above line is blank, this is only a comment. */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0222": {"ttr": 40209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00$\\x00$\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:24", "lines": 36, "newlines": 36, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0222\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Clauses and instructions\nT-Labels\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175724\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Clauses and instructions\nN  ------------------------\nNLabels\nN------\nNA clause that consists of a single symbol followed by a colon is a\nNlabel. The colon in this context implies a semicolon (clause\nNseparator), so no semicolon is required. Labels identify the targets\nNof CALL instructions, SIGNAL instructions, and internal function\nNcalls. More than one label may precede any instruction. Labels are\nNtreated as null clauses and can be traced selectively to aid\nNdebugging.\nN\nNExamples:\nN---------\nDBranch_here:\nDSYNTAX:\nDmy_internal_routine:\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0223": {"ttr": 40211, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00$\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:24", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0223\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Clauses and instructions\nT-Instructions\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175724\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Clauses and instructions\nN  ------------------------\nNInstructions\nN------------\nNAn instruction consists of one or more clauses describing some course\nNof action for the language processor to take. Instructions can be:\nNassignments, keyword instructions, or commands.\nN\nNExamples:\nN---------\nD  /* assignment */\nD  max_width = 132\nD\nD  /* keyword instruction */\nD  Do rec_ctr = 1 to records.0\nD    ...\nD  End\nD\nD  /* Command */\nD  Address IspExec \"Control Errors Return\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0224": {"ttr": 40213, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00 \\x00 \\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:24", "lines": 32, "newlines": 32, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0224\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Clauses and instructions\nT-Assignment\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175724\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Clauses and instructions\nN  ------------------------\nNAssignment\nN----------\nNA single clause of the form symbol=expression is an instruction known\nNas an assignment. An assignment gives a variable a (new) value.\nN\nNExamples:\nN---------\nD  /* assignment */\nD  max_width = 132\nD\nD  heading.1 = Center(\"My sample REXX example\",max_width,\" \")\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0225": {"ttr": 40215, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:24", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0225\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Clauses and instructions\nT-Keyword Instructions\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175724\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Clauses and instructions\nN  ------------------------\nNKeyword Instructions\nN--------------------\nNA keyword instruction is one or more clauses, the first of which\nNStarts with a keyword that identifies the instruction. Keyword\nNinstructions control the external interfaces, the flow of control,\nNand so forth. Some keyword instructions can include nested\nNinstructions. In the following example, the DO construct (DO, the\nNgroup of instructions that follow it, and its associated END keyword)\nNis considered a single keyword instruction.\nN\nNExamples:\nN---------\nD  /* keyword instruction */\nD  Do rec_ctr = 1 to records.0\nD    ...\nD  End\nD\nD  Select\nD    When (rec_ctr = 1) Iterate\nD    Otherwise Do\nD      NOp\nD    End\nD  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0226": {"ttr": 40217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\"\\x00\"\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:25", "lines": 34, "newlines": 34, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0226\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Clauses and instructions\nT-Command\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175725\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Clauses and instructions\nN  ------------------------\nNCommand\nN-------\nNA command is a clause consisting of only an expression. The expression\nNis evaluated and the result is passed as a command string to some\nNexternal environment.\nN\nNExamples:\nN---------\nD  /* Command */\nD  Address IspExec \"Control Errors Return\"\nD\nD  Address MVS\nD  \"ExecIO * Diskr SYSIN (Stem records. Finis)\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0230": {"ttr": 40449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00=\\x00=\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:25", "lines": 61, "newlines": 61, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0230\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Assignments and symbols\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175725\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Assignments and symbols\nN  -----------------------\nNA variable is an object whose value can change during the running of a\nNREXX program. The process of changing the value of a variable is\nNcalled assigning a new value to it. The value of a variable is a\nNsingle character string, of any length, that might contain any\nNcharacters.\nN\nNYou can assign a new value to a variable with the ARG, PARSE, or PULL\nNinstructions, the VALUE built-in function, or the Variable Access\nNRoutine (IRXEXCOM), but the most common way of changing the value of\nNa variable is the assignment instruction itself. Any clause of the\nNform:\nN\nN  symbol=expression;\nN\nNis taken to be an assignment. The result of expression becomes the\nNnew value of the variable named by the symbol to the left of the\nNequal sign. On TSO/E, if you omit expression (SYMBOL=;), the variable\nNis set to the null string. However, it is suggested that you\nNexplicitly set a variable to the null string: symbol=''.\nN\nNThe symbol naming the variable cannot begin with a digit (0-9) or a\nNperiod. (Without this restriction on the first character of a\nNvariable name, you could redefine a number; for example 3=4; would\nNgive a variable called 3 the value 4.)\nN\nNYou can use a symbol in an expression even if you have not assigned\nNit a value, because a symbol has a defined value at all times. A\nNvariable you have not assigned a value is uninitialized. Its value is\nNthe characters of the symbol itself, translated to uppercase (that is,\nNlowercase a-z to uppercase A-Z). However, if it is a compound symbol\nN(described under 'Compound symbols'), its value is the derived name\nNof the symbol.\nN\nN    Constant symbols\nN    ----------------\nN    Simple symbols\nN    --------------\nN    Compound symbols\nN    ----------------\nN    Stems\nN    -----\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0231": {"ttr": 40451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00%\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:25", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0231\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Assignments and symbols\nT-Constant symbols\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175725\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Assignments and symbols\nN  -----------------------\nN    Constant symbols\nN    ----------------\nNA constant symbol starts with a digit (0-9) or a period.\nN\nNYou cannot change the value of a constant symbol. It is simply the\nNstring consisting of the characters of the symbol (that is, with any\nNlowercase alphabetic characters translated to uppercase).\nN\nNExamples:\nN---------\nNThese are constant symbols:\nN\nD77\nD827.53\nD.12345\nD12e5 /* Same as 12E5 */\nD3D\nD17E-3\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0232": {"ttr": 40453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00%\\x00%\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:25", "lines": 37, "newlines": 37, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0232\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Assignments and symbols\nT-Simple symbols\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175725\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Assignments and symbols\nN  -----------------------\nN    Simple symbols\nN    --------------\nNA simple symbol does not contain any periods and does not start with\nNa digit (0-9).\nN\nNBy default, its value is the characters of the symbol (that is,\nNtranslated to uppercase). If the symbol has been assigned a value, it\nNnames a variable and its value is the value of that variable.\nN\nNExamples:\nN---------\nNThese are simple symbols:\nN\nDFred            /* The initial value of Fred is FRED */\nDWhatagoodidea? /* Same as WHATAGOODIDEA? */\nD?12\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0233": {"ttr": 40455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00H\\x00H\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:26", "lines": 72, "newlines": 72, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0233\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Assignments and symbols\nT-Compound symbols\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175726\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Assignments and symbols\nN  -----------------------\nN    Compound symbols\nN    ----------------\nNA compound symbol permits the substitution of variables within its\nNname when you refer to it. A compound symbol contains at least one\nNperiod and at least two other characters. It cannot start with a digit\nNor a period, and if there is only one period in the compound symbol,\nNit cannot be the last character.\nM\nMWhen the compound symbol ends with a period it is called a stem.\nN\nNThe name begins with a stem (that part of the symbol up to and\nNincluding the first period). This is followed by a tail, parts of\nNthe name (delimited by periods) that are constant symbols, simple\nNsymbols, or null. The derived name of a compound symbol is the stem\nNof the symbol, in uppercase, followed by the tail, in which all simple\nNsymbols have been replaced with their values. A tail itself can be\nNcomprised of the characters A-Z, a-z, 0-9, and @ # $ \" . ! ? and\nNunderscore. The value of a tail can be any character string, including\nNthe null string and strings containing blanks.\nN\nNExamples:\nN---------\nNSet a default value:\nN--------------------\nD  my_stem.1 = 3\nD  my_stem.2 = 2\nD  Do stemx = 1 to 3\nD    Say \"my_stem.\"stemx \"=\" my_stem.stemx\nD  End\nN\nNmy_stem.1 = 3\nNmy_stem.2 = 2\nNmy_stem.3 = MY_STEM.3\nN\nNTAILA: 99\nN* )  : STEM.* (\nNTAILB: 99\nN    14 +++ say stem.* (\nNIRX0035I Error running QUICK, line 14: Invalid expression\nN\nN\nNUsing an oddball tail:\nN----------------------\nD  taila =\"* (\"\nD  stem.taila = 99\nD  say \"TAILA:\" stem.taila /* Displays: 99 */\nD  say \"* )  :\" stem.\"* (\" /* Displays STEM.* ( */\nD  stem.tailb = stem.taila\nD  say \"TAILB:\" stem.tailb /* Displays: 99 */\nD  /* But the following instruction would cause an error */\nD  say stem.* (\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0234": {"ttr": 40457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:26", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0234\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Assignments and symbols\nT-Stems\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175726\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Assignments and symbols\nN  -----------------------\nN    Stems\nN    -----\nNA stem is a symbol that contains just one period, which is the last\nNcharacter. It cannot start with a digit or a period.\nN\nNExample:\nN--------\nNSet a default value:\nN--------------------\nD  my_stem. = 0       /* The stem */\nD  my_stem.1 = 3      /* One compound symbol */\nD  my_stem.2 = 2      /* Another compound symbol */\nD  Do stemx = 1 to 3  /* Show three compound symbols of the stem */\nD    Say \"my_stem.\"stemx \"=\" my_stem.stemx\nD  End\nN\nNmy_stem.1 = 3\nNmy_stem.2 = 2\nNmy_stem.3 = 0\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0240": {"ttr": 40459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\\x16\\x00\\x16\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:26", "lines": 22, "newlines": 22, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0240\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Commands to external environments\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175726\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nNIssuing commands to the surrounding environment is an integral part of\nNREXX.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0241": {"ttr": 40461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00*\\x00*\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:27", "lines": 42, "newlines": 42, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0241\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Commands to external environments\nT-Environments\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175727\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Environments\nN    ------------\nNThe system under which REXX programs run is assumed to include at\nNleast one host command environment for processing commands. An\nNenvironment is selected by default on entry to a REXX program. In\nNTSO/E REXX, the environment for processing host commands is known as\nNthe host command environment. TSO/E provides different environments\nNfor TSO/E and non-TSO/E address spaces. You can change the environment\nNby using the ADDRESS instruction. You can find out the name of the\nNcurrent environment by using the ADDRESS built-in function. The\nNunderlying operating system defines environments external to the\nNREXX program.\nN\nNThe host command environment selected depends on the caller. For\nNexample, if you call a REXX program from a TSO/E address space, the\nNdefault host command environment that TSO/E provides for processing\nNhost commands is TSO. If you call an exec from a non-TSO/E address\nNspace, the default host command environment that TSO/E provides is\nNMVS.\nM\nMSee Chapter 14 for the gory details.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0242": {"ttr": 40463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00K\\x00K\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:27", "lines": 75, "newlines": 75, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0242\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Commands to external environments\nT-Commands\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175727\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Commands\nN    --------\nNTo send a command to the currently addressed host command environment,\nNuse a clause of the form:\nN\nD  command parameters;\nN\nNThe expression is evaluated, resulting in a character string (which\nNcan be the null string), which is then prepared as appropriate and\nNsubmitted to the host command environment. Any part of the expression\nNnot to be evaluated should be enclosed in quotation marks.\nM\nMQutotation marks can be either the apostrophe (') or quote(\").\nN\nNThe environment then processes the command, which might have\nNside-effects. It eventually returns control to the language processor,\nNafter setting a return code. A return code is a string, typically a\nNnumber, that returns some information about the command that has been\nNprocessed. A return code usually indicates if a command was successful\nNor not but can also represent other information. The language\nNprocessor places this return code in the REXX special variable RC.\nN\nNIn addition to setting a return code, the underlying system might also\nNindicate to the language processor if an error or failure occurred.\nNAn error is a condition raised by a command for which a program that\nNuses that command would usually be expected to be prepared. (For\nNexample, a locate command to an editing system might report requested\nNstring not found as an error.) A failure is a condition raised by a\nNcommand for which a program that uses that command would not usually\nNbe expected to recover (for example, a command that is not executable\nNor cannot be found).\nN\nMRecommendation: Whenever you use a host command in a REXX program,\nMenclose the command using the quote (\").\nN\nN\nNExample 1: TSO Command (recommended)\nN------------------------------------\nNExplicitly uses high level qualifier PROGA and why using the quote\nNis recommended as the apostrophe (') wraps a data set name.\nD  Address TSO \"FREE DATASET('PROGA.LOAD')\"\nN\nNExample 2: TSO Command (not recommended)\nN----------------------------------------\nNAssumes the high level qualifier matches your PREFIX().\nI  Address TSO \"FREE DATASET(PROGA.LOAD)\"\nN\nNExample 3: TSO Command (not recommended)\nN----------------------------------------\nNExplicitly uses high level qualifier PROGA and why using the\nNapostrophe is cumbersome. It takes two to get one.\nI  Address TSO 'FREE DATASET('''PROGA.LOAD''')'\nN\nNExample 4: MVS Command\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0243": {"ttr": 40465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00G\\x00G\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:27", "lines": 71, "newlines": 71, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0243\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Host commands and host command environments\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175727\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Host commands and host command environments\nN    -------------------------------------------\nNYou can issue host commands from a REXX program. When the language\nNprocessor processes a clause that it does not recognize as a REXX\nNinstruction or an assignment instruction, the language processor\nNconsiders the clause to be a host command and routes the command to\nNthe current host command environment. The host command environment\nNprocesses the command and then returns control to the language\nNprocessor.\nN\nNFor example, in REXX processing, a host command can be:\nN\nN-> A TSO/E command processor, such as ALLOCATE, FREE, or EXEC\nN\nN-> A TSO/E REXX command, such as NEWSTACK or QBUF\nN\nN-> A program that you link to or attach\nN\nN-> An MVS system or subsystem command that you invoke during an\nN   extended MCS console session\nN\nN-> An ISPF command or service\nN\nN-> An SAA CPI Communications call or APPC/MVS call\nN\nMDebugging tip: To check on the current enviroonment use:\nD  current_environment = Address()\nD  Say \"The current environment is:\" current_environment\".\"\nI\nISee the manual if you have issues trying to run an authorized command\nIdefined in the PARMLIB(IKJTSOxx) member, but executed from a non-APF\nIdata set. In a CLIST it runs unauthorized, in REXX it fails with a\nIRC = -3.\nN\nN\nNIf a system abend occurs during a host command, the REXX special\nNvariable RC is set to the negative of the decimal value of the abend\nNcode. If a user abend occurs during a host command, the REXX special\nNvariable RC is set to the decimal value of the abend code. If no\nNabend occurs during a host command, the REXX special variable RC is\nNset to the decimal value of the return code from the command.\nN\nNCertain conditions may be raised depending on the value of the special\nNvariable RC:\nN\nN-> If the RC value is negative, the FAILURE condition is raised.\nN\nN-> If the RC value is positive, the ERROR condition is raised.\nN\nN-> If the RC value is zero, neither the ERROR nor FAILURE conditions\nN   are raised.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0244": {"ttr": 40467, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\'\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\"\\x00\"\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:27", "lines": 34, "newlines": 34, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0244\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-The TSO host command environment\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175727\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Host commands and host command environments\nN    -------------------------------------------\nN      The TSO host command environment\nN      --------------------------------\nNThe TSO host command environment is available only to REXX execs that\nNrun in the TSO/E address space. Use the TSO host command environment\nNto invoke TSO/E commands and services. You can also invoke all of the\nNTSO/E REXX commands, such as MAKEBUF and NEWSTACK, and invoke other\nNREXX execs and CLISTs. When you invoke a REXX exec in the TSO/E\nNaddress space, the default initial host command environment is TSO.\nN\nNNote that the value that can be set in the REXX special variable RC\nNfor the TSO environment is a signed 24-bit number in the\nNrange -8,388,608 to +8,388,607.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0245": {"ttr": 40469, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:28", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0245\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-The CONSOLE host command environment\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175728\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Host commands and host command environments\nN    -------------------------------------------\nN      The CONSOLE host command environment\nN      ------------------------------------\nNThe CONSOLE host command environment is available only to REXX execs\nNthat run in the TSO/E address space. Use the CONSOLE environment to\nNinvoke MVS system and subsystem commands during an extended MCS\nNconsole session. To use the CONSOLE environment, you must have\nNCONSOLE command authority.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0246": {"ttr": 40705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00*\\x00*\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:28", "lines": 42, "newlines": 42, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0246\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Commands to external environments\nT-The ISPEXEC and ISREDIT host command environments\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175728\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Host commands and host command environments\nN    -------------------------------------------\nN      The ISPEXEC and ISREDIT host command environments\nN      -------------------------------------------------\nNThe ISPEXEC and ISREDIT host command environments are available only\nNto REXX execs that run in ISPF. Use the environments to invoke ISPF\nNcommands and services, and ISPF edit macros.\nI\nITo use ISREDIT, you must be in an EDIT or VIEW session.\nN\nN\nNISPEXEC\nN-------\nNISPEXEC offers you the Dialog capabilities of ISPF and its services.\nN\nNISREDIT\nN-------\nNISREDIT offers you all of the capabilities of an EDIT session.\nN\nMGENIE is an EDIT Macro that also uses ISPF Dialog capabilities and\nMISPF services.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0247": {"ttr": 40707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:28", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0247\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Commands to external environments\nT-The CPICOMM, LU62, and APPCMVS host command environments\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175728\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Host commands and host command environments\nN    -------------------------------------------\nN      The CPICOMM, LU62, and APPCMVS host command environments\nN      --------------------------------------------------------\nNThe CPICOMM, LU62, and APPCMVS host command environments are available\nNto REXX execs that run in any MVS address space. The CPICOMM\nNenvironment lets you use the SAA common programming interface (CPI)\nNCommunications calls. The LU62 environment lets you use the APPC/MVS\nNcalls that are based on the SNA LU 6.2 architecture. The APPCMVS\nNenvironment allows APPC transaction programs to invoke APPC/MVS\nNserver facilities callable services and callable services related to\nNthe testing of transaction programs (TPs). Using these environments,\nNyou can write APPC/MVS transaction programs (TPs) in the REXX\nNprogramming language. Using CPICOMM, you can write transaction\nNprograms (TPs) in REXX that can be used in different SAA environments.\nM\nMThese environments are far too complex to cover under the REXX\nMReference TOPIC. Find the z/OS MVS Programming: Writing Transaction\nMPrograms for APPC/MVS manual if you want additional information.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0248": {"ttr": 40709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:28", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0248\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Commands to external environments\nT-The MVS host command environment\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175728\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN    Host commands and host command environments\nN    -------------------------------------------\nN      The MVS host command environment\nN      --------------------------------\nNThe MVS host command environment is available in any MVS address\nNspace. When you run a REXX exec in a non-TSO/E address space, the\nNdefault initial host command environment is MVS.\nN\nINote: When you invoke an exec in a TSO/E address space, TSO is the\nIinitial host command environment.\nN\nNIn ADDRESS MVS, you can use a subset of the TSO/E REXX commands as\nNfollows:\nN\nN-> DELSTACK\nN\nN-> NEWSTACK\nN\nN-> QSTACK\nN\nN-> QBUF\nN\nN-> QELEM\nN\nN-> EXECIO\nN\nN-> MAKEBUF\nN\nN-> DROPBUF\nN\nN-> SUBCOM\nN\nN-> TS\nN\nN-> TE\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0249": {"ttr": 40711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:29", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0249\nTz/OS TSO/E REXX Reference\nT-Chapter 2.\nT-Commands to external environments\nT-Host command environments for linking to and attaching programs\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175729\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 2. REXX general concepts\nN--------------------------------\nN  Commands to external environments\nN  ---------------------------------\nN      Host command environments for linking to and attaching programs\nN      ---------------------------------------------------------------\nNTSO/E provides the LINK, LINKMVS, and LINKPGM host command\nNenvironments that let you link to unauthorized programs on the same\nNtask level.\nN\nNTSO/E also provides the ATTACH, ATTCHMVS, and ATTCHPGM host command\nNenvironments that let you attach unauthorized programs on a different\nNtask level.\nN\nNThe differences between the environments are the format of the\nNparameter list that the program receives, the capability of passing\nNmultiple parameters, variable substitution for the parameters, and the\nNability of the invoked program to update the parameters.\nN\nN\nN-> For the LINK and ATTACH environments, you can specify only a single\nN   character string that gets passed to the program. The LINK and\nN   ATTACH environments do not evaluate the character string and do\nN   not perform variable substitution. The environments simply pass\nN   the string to the invoked program. The program can use the\nN   character string it receives. However, the program cannot return\nN   an updated string to the exec.\nN\nN-> For the LINKMVS, LINKPGM, ATTCHMVS, and ATTCHPGM environments, you\nN   can pass multiple parameters to the program. The environments\nN   evaluate the parameters you specify and perform variable\nN   substitution. That is, the environment determines the value of each\nN   variable. When the environment invokes the program, the environment\nN   passes the value of each variable to the program. The program can\nN   update the parameters it receives and return the updated values to\nN   the exec.\nN\nMSee the manual if you have a need or desire tO use these methods of\nMinvoking a program.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR03": {"ttr": 40713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00M\\x00M\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:29", "lines": 77, "newlines": 77, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR03\nTz/OS TSO/E REXX Reference\nT-Chapter 3. Keyword instructions\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590254\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNA keyword instruction is one or more clauses, the first of which\nNstarts with a keyword that identifies the instruction. Some keyword\nNinstructions affect the flow of control, while others provide services\nNto the programmer. Some keyword instructions, like DO, can include\nNnested instructions.\nN\nNInstructions\nN------------\nN ADDRESS:   temporarily or permanently changes the destination of\nN            commands.\nN ARG:       retrieves the argument strings provided to a program or\nN            internal routine and assigns them to variables.\nN CALL:      calls a routine (if you specify name) or controls the\nN            trapping of certain conditions (if you specify ON or OFF).\nN DO:        groups instructions together and optionally processes them\nN            repetitively.\nN DROP:      'unassigns' variables, that is, restores them to their\nN            original uninitialized state.\nN EXIT:      leaves a program unconditionally.\nN IF:        conditionally processes an instruction or group of\nN            instructions depending on the evaluation of the\nN            expression.\nN INTERPRET: processes instructions that have been built dynamically\nN            by evaluating expression.\nN ITERATE:   alters the flow within a repetitive DO loop (that is, any\nN            DO construct other than that with a simple DO).\nN LEAVE:     causes an immediate exit from one or more repetitive DO\nN            loops (that is, any DO construct other than a simple DO).\nN NOP:       is a dummy instruction that has no effect.\nN NUMERIC:   changes the way in which a program carries out arithmetic\nN            operations.\nN OPTIONS:   passes special requests or parameters to the language\nN            processor.\nN PARSE:     assigns data (from various sources) to one or more\nN            variables according to the rules of parsing\nN PROCEDURE: within an internal routine (subroutine or function),\nN            protects variables by making them unknown to the\nN            instructions that fall outside of it.\nN PULL:      reads a string from the head of the external data queue.\nN PUSH:      stacks the string resulting from the evaluation of\nN            expression at the head of the external data queue. That is,\nN            it is added FIFO (First In, First Out) onto the external\nN            data queue.\nN QUEUE:     appends the string resulting from expression to the tail\nN            of the external data queue. That is, it is added\nN            LILO (Last In, Last Out).\nN RETURN:    returns control (and possibly a result) from a REXX\nN            program or internal routine to the point of its\nN            invocation.\nN SAY:       writes a line to the output stream.\nN SELECT:    conditionally calls one of several alternative\nN            instructions.\nN SIGNAL:    causes an unusual change in the flow of control (if you\nN            specify labelname or VALUE expression), or controls the\nN            trapping of certain conditions (if you specify ON or OFF).\nN TRACE:     controls the tracing action (that is, how much is\nN            displayed to the user) during processing of a REXX\nN            program.\nN UPPER:     translates the contents of one or more variables to\nN            uppercase.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0301": {"ttr": 40715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x02\\xa2\\x02\\xa2\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:29", "lines": 674, "newlines": 674, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0301\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-ADDRESS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175729\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNADDRESS\nN-------\nNTemporarily or permanently changes the destination of commands.\nNCommands are strings sent to an external environment. You can send\nNcommands by specifying clauses consisting of only an expression or by\nNusing the ADDRESS instruction.\nN\nNSyntax:\nD ADDRESS environment expression\nN   environment: TSO | CONSOLE | ISPEXEC | ISREDIT | CPICOMM | LU62 |\nN                APPCMVS | MVS | LINK | LINKMVS | LINKPGM | ATTACH |\nN                ATTACHMVS | ATTACHPGM\nN\nN   expression: The command sent to the environment.\nN\nN\nMYou can use the MDMD block line command to convert the INFOLINEs to\nMregular DATALINEs.\nNExample: Retrieve current environment\nN-------------------------------------\nI  current_environment = ADDRESS()\nI  If ( current_environment = \"TSO\" ) Then Do\nI    FREE FILE(TEMPDD)\nI  End\nI  Else Do\nI    ADDRESS TSO \"FREE FILE(TEMPDD)\"\nI  End\nN\nNExample: Toggle between environments\nN------------------------------------\nNSet a different environment and afterwards just use ADDRESS.\nI  orig_environment = Address()\nI  Address MVS\nI  Address TSO\nI  Address         /* Goes back to MVS */\nI  Address         /* Goes back to TSO */\nN\nNExample: TSO default\nN--------------------\nNFree a not-in-use DDName.\nI  FREE FILE(TEMPDD)\nN\nNExample: TSO explicit\nN---------------------\nNFree a not-in-use DDName.\nI  ADDRESS TSO \"FREE FILE(TEMPDD)\"\nN\nNExample: CONSOLE\nN----------------\nNActivate a console, issue a DEVSERV command, loop thru the system\nNreply, and deactivate the console.\nI  myid = sysvar(\"SYSUID\") || 2\nI  ADDRESS TSO \"CONSOLE ACTIVATE NAME(\"myid\")\"\nI  lastrc = rc\nI  If ( lastrc <> 0 ) Then Do\nI    Say \"Console\" myid \"might already be in use.\"\nI    Exit 16\nI  End\nI  devserv_cmd=\"DS QD,TYPE=ALL,DEFINED\"\nI  wait_time = 60\nI  ADDRESS TSO \"CONSPROF SOLDISPLAY(NO) SOLNUM(1000)\"\nI  cart=\"DS\" || time('M')\nI  ADDRESS TSO \"CONSOLE SYSCMD(\"devserv_cmd\") CART('\"cart\"')\"\nI  getrc = GetMsg(\"system_reply.\",\"SOL\",cart,,wait_time)\nI  If ( getrc <> 0 ) Then Do\nI    ADDRESS TSO \"CONSOLE DEACTIVATE\"\nI    Exit 12\nI  End\nI  Say \"devserv lines(\"system_reply.0\")\"\nI  Do srx = 1 to system_reply.0\nI    Say Left(system_reply.srx,79)\nI  End\nI  ADDRESS TSO \"CONSOLE DEACTIVATE\"\nI  Return 0\nM\nMSA23-1390-00z/OS MVS Planning: Operations\nM  RDEFINE TSOAUTH CONSOLE UACC(NONE)\nM  PERMIT CONSOLE CLASS(TSOAUTH) ID(racfgrp) ACCESS(READ)\nM  SETROPTS RACLIST(TSOAUTH)\nM\nM  RDEFINE OPERCMDS MVS.** UACC(NONE)\nM  PERMIT MVS.MCSOPER.TAPE1 CLASS(OPERCMDS) ID(racfgrp) ACCESS(READ)\nM  SETR RACLIST(OPERCMDS) REFRESH\nN\nN\nNExample: ISPEXEC\nN----------------\nNFind our USERID and then VIEW an existing PARMLIB member.\nI  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nI  ADDRESS ISPEXEC \"VGET (ZUSER)\"\nI  ADDRESS ISPEXEC \"VIEW DATASET('SYS1.PARMLIB($$$COIBM)'\"\nN\nN\nNExample: ISREDIT\nN----------------\nNAn edit macro to sort in hexadecimal sequence.\nI/* We first need rexx in comment if compiled or read from SYSPROC. */\nIrexx_sortbyhx:\nI  ADDRESS IsrEdit \"MACRO (args)\"\nI  arg.0 =  Words(args)\nI  Do wx = 1 to arg.0\nI    arg.wx = Word(args,wx)\nI  End\nI  If ( DataType(arg.1) <> \"NUM\" ) Then begin_col = 1\nI  Else begin_col = arg.1\nI  If ( DataType(arg.2) <> \"NUM\" ) Then span = 4\nI  Else span = arg.2\nI  ADDRESS ISREDIT \"(mydsn) = DATASET\"\nI  TSO_RC = LISTDSI(\"'\"mydsn\"'\")\nI  If ( TSO_RC > 4 ) Then Do\nI    Say \"LISTDSI of\" mydsn \"failed, rc=\"tso_rc\nI    Exit tso_rc\nI  End\nI  ADDRESS ISREDIT \"(mymbr) = MEMBER\"\nI  ADDRESS ISREDIT \"(lastln) = LINENUM .ZLAST\"\nI  If ( lastln > 1 ) Then Do\nI    Call mysort\nI  End\nI  Exit 1\nI\nImysort:\nI  outtrap_orig = OUTTRAP(\"ON\")\nI  ADDRESS TSO \"FREE FI(SORTIN,SORTOUT,SORTMSG,SYSIN)\"\nI  ADDRESS TSO \"FREE DDNAME(SYSIN,SORTIN,SORTOUT,SORTWK01)\"\nI  If ( DataType(sysused) <> \"NUM\") Then Do\nI    sysused = sysalloc\nI  End\nI  ADDRESS TSO \"ALLOC FILE(SORTWK01)\" ,\nI    \"UNIT(SYSALLDA) SPACE(\"sysused\",10) cylinders\"\nI  outtrap_now = OUTTRAP(outtrap_orig)\nI  recfml = length(sysrecfm)\nI  myrecfm = \"\"\nI  Do rx = 1 to recfml\nI    one = substr(sysrecfm,rx,1)\nI    myrecfm = myrecfm||one\" \"\nI  End\nI  If ( Left(myrecfm,1) = \"V\" ) Then Do\nI    begin_col = begin_col + 4\nI  End\nI  If ( sysunits = \"BLOCK\" ) Then Do\nI    sysunits = \"TRACK\"\nI  End\nI  ADDRESS TSO \"ALLOC FI(SORTIN) NEW REUSE\" ,\nI    \"UNIT(SYSALLDA) SPACE(\"sysused\")\" sysunits\"S\" ,\nI    \"RECFM(\"myrecfm\") BLKSIZE(0) LRECL(\"syslrecl\")\"\nI\nI  ADDRESS MVS \"AddStack\"\nI\nI  cx = 1\nI  Do While ( cx <= lastln )\nI    \"ISREDIT (sortin) = LINE\" cx\nI     line_rc = RC\nI     cx = cx + 1\nI     If ( line_rc = 0 ) Then Queue sortin\nI  End\nI  Queue \"\"\nI\nI  ADDRESS MVS \"ExecIO * DiskW sortin (FINIS\"\nI\nI  ADDRESS MVS \"DelStack\"\nI  ADDRESS MVS \"AddStack\"\nI\nI  ADDRESS TSO \"ALLOC DD(sysin) NEW REUSE\" ,\nI    \"UNIT(SYSALLDA) TRACKS SPACE(1)\" ,\nI    \"RECFM(F B) BLKSIZE(0) LRECL(80)\"\nI\nI  Queue ' SORT FIELDS=('begin_col','span||,\nI    ',AC,A),DYNALLOC=(SWORK,3)'\nI  Queue \" END \"\nI  Queue \"\"\nI  ADDRESS MVS \"ExecIO * DiskW sysin (FINIS\"\nI\nI  ADDRESS MVS \"DelStack\"\nI\nI  \"ALLOC FI(SORTOUT) NEW REUSE\" ,\nI    \"UNIT(SYSALLDA) SPACE(\"sysused\")\" sysunits\"S\" ,\nI    \"RECFM(\"myrecfm\") BLKSIZE(0) LRECL(\"syslrecl\")\"\nI  \"ALLOC FI(SORTMSG) sysout(1)\"\nI  outtrap_orig = Outtrap(\"alcmsgs.\")\nI  \"ALLOC FI(SYSOUT) sysout(1)\"\nI  outtrap_now = Outtrap(outtrap_orig)\nI\nI  \"CALL *(SORT)\"\nI  sort_rc = rc\nI  If ( sort_rc <> 0 ) Then Do\nI    say \"SORT failed with RC(\"sort_rc\").\"\nI    ADDRESS TSO \"FREE DDNAME(SYSIN,SORTIN,SORTOUT,SORTWK01,SYSOUT)\"\nI    Return sort_rc\nI  End\nI\nI  ADDRESS ISREDIT \"DELETE 1 .ZLAST\"   /* CLEAN THE EDIT SLATE */\nI  ADDRESS MVS \"ExecIO * DiskR SORTOUT (Stem srt. FINIS\"\nI\nI   cx = 1\nI   Do While cx <> srt.0 + 1\nI     SORTOUT = srt.cx\nI     Lcx = RIGHT(cx-1,6,0)\nI     ADDRESS ISREDIT \"LINE_AFTER \"Lcx\" = (SORTOUT)\"\nI     cx = cx + 1\nI   End\nI\nI  ADDRESS TSO \"FREE DDNAME(SYSIN,SORTIN,SORTOUT,SORTWK01,SYSOUT)\"\nI  Return\nN\nN\nNExample: CPICOMM LU62 APPCMVS\nN-----------------------------\nISee SA32-0982-00, the z/OS TSO/E REXX User's Guide under \"Examples\nIUsing APPC/MVS Services\".\nI\nIView 'SYS1.SAMPLIB' and SRCHFOR the environment.\nMNote: NO rexx example exists for APPCMVS.\nN\nNExample: CPICOMM\nN----------------\nNThe following example illustrates the syntax for invoking an\nNSAA CPI Communications call under the CPICOMM host command\nNenvironment:\nI/* REXX */\nI  ADDRESS CPICOMM \"CMALLC conversation_id return_code\"\nI  If ( return_code = CM_OK ) Then Say \"OK!\"\nI  Else Say \"Why did this fail? rc(\"return_code\").\"\nI  Say \"Because the IBM Example is incomplete!\"\nN\nNExample: LU62\nN-------------\nNThe following example illustrates the syntax for invoking an APPC/MVS\nNcall under the LU62 host command environment:\nN\nI/* REXX */\nI  Say \"This IBM Example is incomplete!\"\nI  ADDRESS LU62 \"ATBDEAL conversation_id deallocate_type\" ,\nI    \"notify_type return_code\"\nNExample: APPCMVS\nN----------------\nN\nN\nNExample: MVS\nN------------\nNRead from SYSIN.\nI  ADDRESS MVS \"ExecIO * DiskR SYSIN (Stem input_records. FINIS\"\nI  Say \"# of SYSIN records: \"input_records.0\")\"\nI  Do irx = 1 to input_records.0\nI    Say Left(input_records.irx,79)\nI  End\nN\nN\nMLINK, LINKMVS, LINKPGM versus ATTACH, ATTCHMVS, ATTCHPGM\nM--------------------------------------------------------\nMMessage from Kenneth Tomiak:\nMIBM fails to provide working examples of LINK, LINKMVS, LINKPGM,\nMATTACH, ATTCHMVS, and ATTCHPGM. Their LINKMVS should be using ATTCHMVS\nMand only passes one very long parameter string. It is unclear why\nMthe parameter begins with a NULL parameter followed by a space.\nM\nMSee my DEMO offering for working examples of JCL invoking REXX that\nMuses ATTACH, ATTCHMVS, and ATTCHPGM written in HLASM. Do keep in mind\nMthat the LINK* version is meant for AUTHORIZED programs. IEBCOPY is\nMone instance that long ago dropped its requirement to be authorized.\nMYour code is likely unauthorized and you should use the ATTCH* methods.\nN\nN\nNExample: ATTACH\nN---------------\nNAttach unauthorized programs on a different task level.\nNYou can only pass one parameter string. The program you ATTACHed to\nNcan use Register 1 for the two parameters R1 points to.\nN-> R1 P1 points to the address of the passed parameter.\nN-> R1 P2 points to the length of the passed parameter.\nN\nN\nNExample: ATTCHMVS\nN-----------------\nNAttach unauthorized programs on a different task level.\nNYou can pass one or more parameter strings. The program you ATTACHMVSed\nNto can use Register 1 to access the parameter list.\nN\nNFor the parameters, specify variable names instead of the actual\nNvalues. The LINKPGM or ATTCHPGM environment itself evaluates the\nNvariables and performs variable substitution.\nN\nN-> R1 P1 points to the length and parameter string.\nN-> R1 P2 points to the length and parameter string.\nN-> ...\nN-> R1 Pn points to the length and parameter string.\nN\nN\nNExample: ATTCHPGM\nN-----------------\nNAttach unauthorized programs on a different task level.\nN\nNFor the parameters, specify variable names instead of the actual\nNvalues. The LINKPGM or ATTCHPGM environment itself evaluates the\nNvariables and performs variable substitution.\nN\nN-> R1 P1 points to the parameter string.\nN-> R1 P2 points to the parameter string.\nN-> ...\nN-> R1 Pn points to the parameter string.\nM\nMYou are on your own for the length. Likely each parameter is a\nMset length known by the program.\nIrexx_DSNTIAR: /* REXX */\nI  PARSE UPPER ARG SQLCODE\nI  SQLC = D2X(SQLCODE,8)\nI  SQLC = X2C(SQLC)\nI\nI  SQLCA = \"SQLCA   \"\nI  SQLCA = SQLCA ||  X2C(00000088)\nI  SQLCA = SQLCA ||  SQLC\nI  SQLCA = SQLCA ||  X2C(0000)\nI  SQLCA = SQLCA ||  COPIES(\" \",78)\nI  SQLCA = SQLCA ||  COPIES(X2C(00),24)\nI  SQLCA = SQLCA ||  COPIES(\" \",16)\nI  TIAR_MSG = X2C(0190)COPIES(\" \",400)\nI  TEXT_LEN = X2C(00000050) ;\nI  ADDRESS ATTCHPGM \"DSNTIAR SQLCA TIAR_MSG TEXT_LEN\"\nI  SAY SUBSTR(TIAR_MSG,4,400);\nI  return\nN\nN\nN\nNExample: LINK\nN-------------\nIAttach authorized programs on the same task level.\nNYou can only pass one parameter string. The program you LINKed to\nNcan use Register 1 to access the parameter list.\nN-> R1 P1 points to the address of the passed parameter.\nN-> R1 P2 points to the length of the passed parameter.\nN\nN\nNExample: LINKMVS\nN----------------\nNAttach authorized programs on the same task level.\nNYou can pass one or more parameter strings. The program you LINKMVSed\nNto can use Register 1 to access the parameter list.\nN\nNFor the parameters, specify variable names instead of the actual\nNvalues. The LINKPGM or ATTCHPGM environment itself evaluates the\nNvariables and performs variable substitution.\nN\nN-> R1 P1 points to the length and parameter string.\nN-> R1 P2 points to the length and parameter string.\nN-> ...\nN-> R1 Pn points to the length and parameter string.\nI/* Rexx - Invoke IEBGENER with alternate ddnames. */\nI  prog = \"IEBGENER\"\nI  parm = \"\" /* Standard PARM, as from JCL */\nI  ddlist = copies(\"00\"x,8) ||, /* DDname  1 override: SYSLIN */\nI    copies(\"00\"x,8) ||,        /* DDname  2 override: n/a */\nI    copies(\"00\"x,8) ||,        /* DDname  3 override: SYSLMOD */\nI    copies(\"00\"x,8) ||,        /* DDname  4 override: SYSLIB */\nI    left(\"CTL\", 8) ||,         /* DDname  5 override: SYSIN */\nI    left(\"REP\", 8) ||,         /* DDname  6 override: SYSPRINT */\nI    copies(\"00\"x,8) ||,        /* DDname  7 override: SYSPUNCH */\nI    left(\"INP\", 8) ||,         /* DDname  8 override: SYSUT1 */\nI    left(\"OUT\", 8) ||,         /* DDname  9 override: SYSUT2 */\nI    copies(\"00\"x,8) ||,        /* DDname 10 override: SYSUT3 */\nI    copies(\"00\"x,8) ||,        /* DDname 11 override: SYSUT4 */\nI    copies(\"00\"x,8) ||,        /* DDname 12 override: SYSTERM */\nI    copies(\"00\"x,8) ||,        /* DDname 13 override: n/a */\nI    copies(\"00\"x,8)            /* DDname 14 override: SYSCIN */\nI  address \"LINKMVS\" prog \"PARM DDLIST\"\nI  exit rc\nN\nN\nNExample: LINKPGM\nN----------------\nNAttach authorized programs on the same task level.\nNLink to the DB2 program DSNTIAR to translate an error code to the\nNmessage text.\nN\nNFor the parameters, specify variable names instead of the actual\nNvalues. The LINKPGM or ATTCHPGM environment itself evaluates the\nNvariables and performs variable substitution.\nN\nN-> R1 P1 points to the parameter string.\nN-> R1 P2 points to the parameter string.\nN-> ...\nN-> R1 Pn points to the parameter string.\nM\nMYou are on your own for the length. Likely each paramter is a\nMset length.\nI\nIyou need to have invoked DSNREXX and received a bad SQLCODE.\nI  S_RC = RXSUBCOM(\"ADD\",\"Rexx4DB2\",\"DSNREXX\")\nI  Address Rexx4DB2 \"CONNECT demo\"\nI  If ( sqlcode <> 0 ) Then Do\nI    SQL_ERRD = \"\"\nI    Do I = 1 To 6\nI      SQL_ERRD = SQL_ERRD||D2C(SQLERRD.I,4)\nI    End\nI    SQL_WARN = \"\"\nI    Do I = 0 To 10\nI      SQL_WARN = SQL_WARN||LEFT(SQLWARN.I,1)\nI    End\nI    SQLCA = 'SQLCA   '||D2C(136,4)||D2C(SQLCODE,4)||D2C(70,2) ,\nI      ||LEFT(SQLERRMC,70)||'DSN     '||,\nI      SQL_ERRD||SQL_WARN||LEFT(SQLSTATE,5)\nI/*   If the length is beyond DSNTIAR possible values (72-240), reset */\nI    If MSG_LEN < 72 | MSG_LEN > 240 Then ,\nI      MSG_LEN = 120  /* Outside scope */\nI    If MSG_LEN = \"MSG_LEN\" Then,\nI      MSG_LEN = 120  /* Default msg length 120 */\nI    DB2_ERR_MSG = D2C(MSG_LEN * 12,2) || COPIES(' ',MSG_LEN * 12)\nI    DB2_ERR_LEN = D2C(MSG_LEN,4)\nI                     /* Execute DSNTIAR program with SQLCA/Parm data */\nI    Address LINKPGM \"DSNTIAR SQLCA DB2_ERR_MSG DB2_ERR_LEN\"\nI    Do I = 1 to 12               * Loop through all lines of message */\nI      MSG_TEXT = Substr(DB2_ERR_MSG,S_POS,MSG_LEN)  /* Pick out text */\nI      MSG_TEXT = Strip(MSG_TEXT,T,\" \")     /* Remove trailing blanks */\nI      If MSG_TEXT > \" \" Then Say MSG_TEXT  /* Echo msg to terminal */\nI      Else Iterate                 /* Some msg lines are blank, skip */\nI      S_POS = S_POS + MSG_LEN     /* Skip to next \"line\" of MSG data */\nI    End I\nI  End\nN\nN\nNExample: Invoking each environment\nN----------------------------------\nNThis code will invoke each environment and display what you would use\nNit for.\nD/* We first need rexx in comment if compiled or read from SYSPROC. */\nDpgm_REXR0301:\nD  rexxpgm_version = \"01.00\"          /* Set with 'ver 1' and 'lev 2'. */\nD\nD  showed_commands. = 0\nD  current_address = Address()                    /* Built-in function */\nD  function_rc = What_can_I_do()\nD\nD  Address Console                                  /* Issue commands */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address                                       /* Toggle back to TSO */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address IspExec                             /* ISPF Dialog Services */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address IsrEdit                               /* ISPF Edit Services */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address CPICOMM                    /* SAA CPI  Communications calls */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address LU62                       /* SAA CPI  Communications calls */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address APPCMVS                    /* SAA CPI  Communications calls */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address MVS                                     /* Stack and Buffer */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address TSO                          /* TSO/E commands and services */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Address                                      /* Toggles back to MVS */\nD  current_address = Address()\nD  function_rc = What_can_I_do()\nD\nD  Return 0\nD\nD/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nDInternal routine to show what the current ADDRESS environment can do.\nD>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nDWhat_can_I_do:\nD  Say \"\"\nD  Say \"The current ADDRESS environment is:\" current_address\".\"\nD  Say \"----------------------------------- --------\"\nD  Select\nD    When ( current_address = \"TSO\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  Built-in functions\"\nD      End\nD    End\nD    When ( current_address = \"CONSOLE\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  ACTIVATE DEACTIVATE\"\nD        Say \"  An MVS command (e.g. D A,L)\"\nD        Say \"  CART     GETMSG   SYSCMD (e.g. $S PRT2)\"\nD      End\nD    End\nD    When ( current_address = \"ISPEXEC\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  Any of the ISPF Dialog services.\"\nD        Say \"    PANEL, Skeleton (file tailoring), and TABLE\"\nD        Say \"    processing are jsut a hint at what you can use.\"\nD      End\nD    End\nD    When ( current_address = \"ISREDIT\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  A wide variety of primary and line commands just as\"\nD        Say \"  if you were in an EDIT sessions\"\nD      End\nD    End\nD    When ( current_address = \"CPICOMM\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  The CPICOMM environment supports the starter set and\"\nD        Say \"  advanced function set of the SAA CPI\" ,\nD          \"Communications calls.\"\nD        Say \"    CMACCP (Accept_Conversation)\"\nD        Say \"    CMALLC (Allocate)\"\nD        Say \"    CMCFM (Confirm)\"\nD        Say \"    CMCFMD (Confirmed)\"\nD        Say \"    CMDEAL (Deallocate)\"\nD        Say \"    CMECS (Extract_Conversation_State)\"\nD        Say \"    CMECT (Extract_Conversation_Type)\"\nD        Say \"    CMEMN (Extract_Mode_Name)\"\nD        Say \"    CMEPLN (Extract_Partner_LU_Name)\"\nD        Say \"    CMESL (Extract_Sync_Level)\"\nD        Say \"    CMFLUS (Flush)\"\nD        Say \"    CMINIT (Initialize_Conversation)\"\nD        Say \"    CMPTR (Prepare_To_Receive)\"\nD        Say \"    CMRCV (Receive)\"\nD        Say \"    CMRTS (Request_To_Send)\"\nD        Say \"    CMSCT (Set_Conversation_Type)\"\nD        Say \"    CMSDT (Set_Deallocate_Type)\"\nD        Say \"    CMSED (Set_Error_Direction)\"\nD        Say \"    CMSEND (Send_Data)\"\nD        Say \"    CMSERR (Send_Error)\"\nD        Say \"    CMSF (Set_Fill)\"\nD        Say \"    CMSLD (Set_Log_Data)\"\nD        Say \"    CMSMN (Set_Mode_Name)\"\nD        Say \"    CMSPLN (Set_Partner_LU_Name)\"\nD        Say \"    CMSPTR (Set_Prepare_To_Receive_Type)\"\nD        Say \"    CMSRC (Set_Return_Control)\"\nD        Say \"    CMSRT (Set_Receive_Type)\"\nD        Say \"    CMSSL (Set_Sync_Level)\"\nD        Say \"    CMSST (Set_Send_Type)\"\nD        Say \"    CMSTPN (Set_TP_Name)\"\nD        Say \"    CMTRTS (Test_Request_To_Send_Received)\"\nD      End\nD    End\nD    When ( current_address = \"LU62\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  The LU62 environment supports the APPC/MVS calls.\"\nD        Say \"    ATBALLC (Allocate)\"\nD        Say \"    ATBCFM (Confirm)\"\nD        Say \"    ATBCFMD (Confirmed)\"\nD        Say \"    ATBDEAL (Deallocate)\"\nD        Say \"    ATBFLUS (Flush)\"\nD        Say \"    ATBGETA (Get_Attributes)\"\nD        Say \"    ATBGETC (Get_Conversation)\"\nD        Say \"    ATBGETP (Get_TP_Properties)\"\nD        Say \"    ATBGETT (Get_Type)\"\nD        Say \"    ATBPTR (Prepare_to_Receive)\"\nD        Say \"    ATBRCVI (Receive_Immediate)\"\nD        Say \"    ATBRCVW (Receive_and_Wait)\"\nD        Say \"    ATBRTS (Request_to_Send)\"\nD        Say \"    ATBSEND (Send_Data)\"\nD        Say \"    ATBSERR (Send_Error)\"\nD      End\nD    End\nD    When ( current_address = \"APPCMVS\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  The APPCMVS host command environment supports the\"\nD        Say \"  following advanced callable services:\"\nD        Say \"    ATBRFA2 (Register_for_Allocates)\"\nD        Say \"    ATBRAL2 (Receive_Allocate)\"\nD        Say \"    ATBRJC2 (Reject_Conversation)\"\nD        Say \"    ATBSTE2 (Set_Event_Notification)\"\nD        Say \"    ATBGTE2 (Get_Event)\"\nD        Say \"    ATBQAQ2 (Query_Allocate_Queue)\"\nD        Say \"    ATBSAQ2 (Set_Allocate_Queue_Attributes)\"\nD        Say \"    ATBSCA2 (Set_Conversation_Accounting_Information)\"\nD        Say \"    ATBURA2 (Unregister_for_Allocates)\"\nD        Say \"    ATBPOR2 (Post_on_Receipt)\"\nD        Say \"\"\nD        Say \"  And these listed in manual with some of the above:\"\nD        Say \"    ATBTER1 (Register_Test)\"\nD        Say \"    ATBTEA1 (Accept_Test)\"\nD        Say \"    ATBTEU1 (Unregister_Test)\"\nD        Say \"    ATBCUC1 (Cleanup_TP (Unauthorized))\"\nD        Say \"    ATBVERS (APPC_Version_Service)\"\nD      End\nD    End\nD    When ( current_address = \"MVS\" ) Then DO\nD      If ( showed_commands.current_address = 0 ) Then Do\nD        showed_commands.current_address = 1\nD        Say \"You can use:\"\nD        Say \"  DELSTACK DROPBUF  EXECIO   EXECUTIL\"\nD        Say \"  HE       HI       HT       RT       TE       TS\"\nD        Say \"  MAKEBUF  NEWSTACK QBUF     QELEM    QSTACK   SUBCOM\"\nD      End\nD    End\nD    Otherwise Do\nD      Say \"Did IBM really add a new ADDRESS environment?\"\nD    End\nD  End\nD  Return 0\nD\nD/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nD=======================================================================\nD\nD Dataset:  REXX(REXR0301)\nD Author:   Kenneth Tomiak\nD Contact:  \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nD Manual:   ikj4a3a0.pdf\nD           SA22-7790-10 z/OS TSO/E REXX Reference\nD           Version 1 Release 13\nD           Chapter 3. Keyword instructions\nD           ADDRESS\nD Overview: Use expanded environments beyond TSO.\nD           Executing this will show them.\nD\nD-----------------------------------------------------------------------\nD\nD History of Modifications\nD ------------------------\nDvv.mm When     Who / What you did ... (Newest change at the top.)\nD----- -------- --------------------------------------------------------\nD01.01 20171004 KTOMIAK \"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nD               1) Original base code.\nD----- -------- --------------------------------------------------------\nD\nD-----------------------------------------------------------------------\nD\nDSTANDARD GLOBAL DISCLAIMER\nD--------------------------\nDThe author explicitly disavows any claim whatsoever about the\nDcorrectness or functionality of this program, and disclaims liability\nDfor anything and everything bad that might happen in connection with,\nDbefore, during, or after using it. I have tried to make it work right,\nDand I am personally pretty confident that it does, but everybody makes\nDmistakes, so if you use it, you do so at your own risk.\nD\nD=======================================================================\nD>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nD\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0302": {"ttr": 40963, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x002\\x002\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:29", "lines": 50, "newlines": 50, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0302\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-ARG\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175729\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNARG\nN---\nNRetrieves the argument strings provided to a program or internal\nNroutine and assigns them to variables.\nN\nD  ARG template_list\nN\nIARG defaults to PARSE UPPER ARG. Use the PARSE ARG instruction if you\nIdo not want uppercase translation.\nN\nNUnless a subroutine or internal function is being processed, the\nNstrings passed as parameters to the program are parsed into variables\nNaccording to the rules described in Chapter 5. Parsing.\nN\nNAnd also see Chapter 4. Functions section Built-in functions.\nN\nISee Chapter 5. Parsing for complex template_list combinations.\nM\nMAs powerful as PARSE is, you may have to code your own specialized\nMcode to handle breaking up the parameter-list. You should keep it\nMsimple or add an ISPF panel as a way to intake user input. Download\nMand install the DEMO package for samples showing how to use a panel.\nN\nN\nMYou can use the MDMD block line command to convert the INFOLINEs to\nMregular DATALINEs.\nNExample: ARG accepting user input:\nN----------------------------------\nI\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0303": {"ttr": 40965, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x000\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x00F\\x00F\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:30", "lines": 70, "newlines": 70, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0303\nKFUNCTION SUBROUTINE RETURN\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-CALL\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175730\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNCALL\nN----\nNCalls a routine (if you specify name) or controls the trapping of\nNcertain conditions (if you specify ON or OFF).\nN\nNSyntax:\nD  CALL name ,parameter\nD  CALL \u00ddON | OFF\u00a8 \u00ddERROR | FAILURE | HALT\u00a8\nD  CALL ON \u00ddERROR | FAILURE | HALT\u00a8 NAME trapname\nN\nN\nNCall a routine (perform)\nN------------------------\nNTo call a routine, specify name, a literal string or symbol that is\nNtaken as a constant. The name must be a symbol, which is treated\nNliterally, or a literal string. The routine called can be:\nN\nN-> An internal routine - function or subroutine that is in the same\nN   program as the CALL instruction or function call that calls it.\nN\nN-> A built-in routine - function (which may be called as a subroutine)\nN   that is defined as part of the REXX language.\nN\nN-> An external routine - function or subroutine that is neither\nN   built-in nor in the same program as the CALL instruction or function\nN   call that calls it.\nN\nNExample: CALL with no result returned\nN-------------------------------------\nI  Call my-init-rtn\nI  ...\nImy_init_rtn:\nI  return_code = 0\nI  Return\nN\nN\nNTrapping conditions\nN-------------------\nNTo control trapping, you specify OFF or ON and the condition you want\nNto trap. OFF turns off the specified condition trap. ON turns on the\nNspecified condition trap. All information about condition traps is\nNcontained in Chapter 7, 'Conditions and condition traps'.\nN\nMYou can use the MDMD block line command to convert the INFOLINEs to\nMregular DATALINEs.\nNExample: Using CALL.\nN--------------------\nI\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0304": {"ttr": 40967, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17W\\x009\\x009\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:57:59", "lines": 57, "newlines": 57, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0304\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-DO\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175759\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNDO\nN--\nNGroups instructions together and optionally processes them\nNrepetitively.\nN\nNIf a DO instruction has a repetitor phrase or a conditional phrase or\nNboth, the group of instructions forms a repetitive DO loop. The\nNinstructions are processed according to the repetitor phrase,\nNoptionally modified by the conditional phrase.\nN\nNSyntax:\nD  DO repetitor conditional\nD    instruction-block\nD  END\nI\nI    repetitor: counter | start-value BY increment ...\nI               TO max-value | FOR quantity\nI\nI    conditional: WHILE or UNTIL (something = 1)\nN\nD  DO\nD    instruction-block\nD  END\nN\nD  DO counter\nD    instruction-block\nD  END\nN\nD  DO counter = start-value BY increment TO max-value | FOR quantity\nD    instruction-block\nD  END\nN\nD  DO FOREVER\nD    instruction-block\nD    IF ( something ) THEN LEAVE\nD  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0305": {"ttr": 40969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x002\\x002\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0305\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-DROP\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175800\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNDROP\nN----\nNDROP 'unassigns' variables, that is, restores them to their original\nNuninitialized state. If name is not enclosed in parentheses, it\nNidentifies a variable you want to drop and must be a symbol that is a\nNvalid variable name, separated from any other name by one or more\nNblanks or comments.\nN\nNSyntax:\nD  DROP name , (name)\nI    name: identifies a single variable or stem.\nI\nI    (name): identifies a variable containing a list of variables\nI            and/or stems.\nN\nNExample: Drop named variables\nN-----------------------------\nI  j=4\nI  Drop a z.3 z.j\nI  /* Drops the variables: A, Z.3, and Z.4 */\nI  /* so that reference to them returns their names. */\nN\nNExample: Drop a list of named variables and one named variable\nN--------------------------------------------------------------\nNHere, a variable name in parentheses is used as a subsidiary list.\nI  mylist = \"c d e\"\nI  drop (mylist) f\nI  /* Drops the variables C, D, E, and F */\nI  /* Does not drop MYLIST */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0306": {"ttr": 40971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x002\\x002\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0306\nKRETURN\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-EXIT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175800\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNEXIT\nN----\nNEXIT leaves a program unconditionally. Optionally EXIT returns a\nNCharacter string to the caller. The program is stopped immediately,\nNeven if an internal routine is currently being run. If no internal\nNroutine is active, RETURN (see page 72) and EXIT are identical in their\nNeffect on the program that is being run.\nN\nNIf you specify expression, it is evaluated and the string resulting\nNfrom the evaluation is passed back to the caller when the program\nNstops.\nN\nNSyntax:\nD  EXIT expression\nN\nNExample:\nN--------\nI  j = 3\nI  EXIT j * 4\nI  /* Will exit with the string \"12\" */\nN\nNNote: If the program was called through a command interface, an\nNattempt is made to convert the returned value to a return code\nNacceptable by the host. If the conversion fails, it is deemed to be a\nNfailure of the host interface and thus is not subject to trapping with\nNSIGNAL ON SYNTAX. The returned string must be a whole number whose\nNvalue fits in general register 15 (that is, must be in the range\nN-2**31 through 2**31-1).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0307": {"ttr": 52742, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x01\\x18\\x13\\x7f\\x01\\x18\\x14/\\x15T\\x00c\\x00c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-22T15:54:38", "lines": 99, "newlines": 99, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0307\nKSELECT WHEN\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-IF\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180522-155438\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNIF\nN--\nNIF conditionally processes an instruction or group of instructions\nNdepending on the evaluation of the expression. The expression is\nNevaluated and must result in 0 (FALSE) or 1 (TRUE).\nN\nNThe instruction after the THEN is processed only if the result is 1\nN(true). If you specify an ELSE, the instruction after the ELSE is\nNprocessed only if the result of the evaluation is 0 (false).\nN\nNSyntax:\nD  IF expression THEN instruction ; ELSE instruction\nI\nI     expression: Evaluates to boolean TRUE or FALSE\nN\nD  IF ( ( expression) conditional ( expresion ) ) THEN DO\nI\nI     expression: Evaluates to boolean TRUE or FALSE\nN\nI     conditional: Used combine epression tests.\nI       |: OR - either or both expressions can be TRUE.\nN\nI       &: AND - both expressions must be TRUE.\nN\nI       &&: NOT AND - only one of the expressions can be TRUE, one\nI                     must be FALSE.\nN\nD    instruction\nD  END\nD  ELSE DO\nD    instruction\nD  END\nN\nN\nNExample: Simplest\nN-----------------\nI  IF ( answer = \"YES\" ) THEN SAY \"OK!\"\nN\nNExample: Simple\nN---------------\nI  IF ( answer = \"YES\" ) THEN SAY \"OK!\"\nI  ELSE SAY \"Why not?\"\nN\nNExample: Semi-colon required\nN----------------------------\nI  IF ( answer = \"YES\" ) THEN SAY \"OK!\" ; ELSE SAY \"Why not?\"\nN\nNExample: Nested\nN---------------\nNThe ELSE binds to the nearest IF at the same level. You can use the\nNNOP instruction to eliminate errors and possible confusion when IF\nNconstructs are nested, as in the following example.\nI  IF ( answer = \"YES\" ) THEN\nI    IF ( name = \"FRED\" ) THEN\nI      SAY \"OK, Fred.\"\nI    ELSE\nI      NOP\nI  ELSE\nI    SAY \"Why not?\"\nN\nNExample: Nested IF following KTPM07\nN-----------------------------------\nI  SAY \"Do you want to continue (YES OR NO):\"\nI  PARSE UPPER PULL answer\nI  IF ( answer = \"YES\" ) THEN DO\nI    SAY \"What first name do you go by?\"\nI    PULL name\nI    IF ( TRANSLATE(name) = \"FRED\" ) THEN DO\nI      SAY \"OK, Fred.\"\nI    END\nI    ELSE DO\nI      NOP\nI    END\nI  END\nI  ELSE DO\nI    SAY \"Why not?\"\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0308": {"ttr": 41217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00D\\x00D\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0308\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-INTERPRET\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175800\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNINTERPRET\nN---------\nNINTERPRET processes instructions that have been built dynamically by\nNevaluating expression.\nN\nNSyntax:\nD  INTERPRET epression\nI    expression: The expression is evaluated and is then processed\nI                (interpreted) just as though the resulting string were\nI                a line inserted into the program (and bracketed by a\nI                DO; and an END;).\nN\nNExample: Does variable replacement\nN----------------------------------\nI  data = \"FRED\"\nI  interpret data \"= 4\"\nI  /* Builds the string \"FRED = 4\" and */\nI  /* Processes: DO; FRED = 4; END; */\nI  /* Thus the variable FRED is set to \"4\" */\nN\nNExample: Table lookup (stem.)\nN-----------------------------\nI  SAY \"\"\nI  SAY \"Loop thru stem variables\"\nI  SAY \"========================\"\nI  /* Build a table with the names of the days in a week */\nI  dow. = \"\"\nI  dow.0 = 7\nI  dow.1 = \"Sunday\"\nI  dow.2 = \"Monday\"\nI  dow.3 = \"Tuesday\"\nI  dow.4 = \"Wednesday\"\nI  dow.5 = \"Thursday\"\nI  dow.6 = \"Friday\"\nI  dow.7 = \"Saturday\"\nI  /* Display the names in reverse order */\nI  DO ix = dow.0 TO 1 BY -1\nI    INTERPRET \"SAY dow.\"ix\nI  END\nI  /* Display the name for today */\nI  now = DATE(\"Weekday\")\nI  DO ix = 1 to 7\nI    IF ( now = dow.ix ) THEN DO\nI      INTERPRET \"SAY \"\"Today is\" ix\".\"\"\"\nI      LEAVE\nI    END\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0309": {"ttr": 41219, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x007\\x007\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:01", "lines": 55, "newlines": 55, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0309\nKDO\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-ITERATE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175801\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNITERATE\nN-------\nNITERATE alters the flow within a repetitive DO loop (that is, any DO\nNconstruct other than that with a simple DO).\nN\nNExecution of the group of instructions stops, and control is passed to\nNthe DO instruction. The control variable (if any) is incremented and\nNtested, as usual, and the group of instructions is processed again,\nNunless the DO instruction ends the loop.\nN\nNSyntax:\nD  ITERATE name\nI    name: optionally list the name of the counter.\nM          Useful with nested DO loops.\nM          Good for documentation purposes.\nN\nNExample: Skip the second item\nN-----------------------------\nI  /* Displays the numbers: \"1\" \"3\" \"4\" */\nI  DO i = 1 TO 4\nI    IF ( i = 2 ) THEN ITERATE\nI    SAY i\nI  END\nN\nNExample: Skip every third item\nN------------------------------\nI  SAY \"\"\nI  SAY \"Skip every third item\"\nI  SAY \"=====================\"\nI  DO ix = 1 TO 14\nI    IF ( (ix // 3) = 0 ) THEN ITERATE ix\nI    SAY ix\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0310": {"ttr": 41221, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00+\\x00+\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:01", "lines": 43, "newlines": 43, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0310\nKDO\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-LEAVE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175801\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNLEAVE\nN-----\nNLEAVE causes an immediate exit from one or more repetitive DO loops\nN(that is, any DO construct other than a simple DO).\nN\nNSyntax:\nD  LEAVE name\nI    name: optionally list the name of the counter.\nM          Useful with nested DO loops.\nM          Good for documentation purposes.\nN\nN\nNExample: Stop after finding a match\nN-----------------------------------\nI  SAY \"How high should I count (5 maximum):\"\nI  PULL maxnum\nI  /* Displays the numbers: \"1\" \"2\" \"3\" ... */\nI  DO ix = 1 TO 5\nI    SAY i\nI    IF ( ix = maxnum ) THEN LEAVE ix\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0311": {"ttr": 41223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00-\\x00-\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:01", "lines": 45, "newlines": 45, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0311\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-NOP\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175801\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNNOP\nN---\nNNOP is a dummy instruction that has no effect. It can be useful as the\nNtarget of a THEN or ELSE clause.\nM\nMThink No OPeration.\nN\nNSyntax:\nD    NOP\nN\nNExample: Coding all conditions\nN------------------------------\nI  SAY \"Enter your first number to compare:\"\nI  PULL a\nI  SAY \"Enter your second number to compare:\"\nI  PULL c\nI  SAY \"a =\" a \"and c =\" c\".\"\nI  SELECT\nI    WHEN ( a = c ) THEN NOP            /* Do nothing */\nI    WHEN ( a > c ) THEN SAY \"a > c\"\nI    OTHERWISE DO\nI      SAY \"a < c\"\nI    END\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0312": {"ttr": 41225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00h\\x00h\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:02", "lines": 104, "newlines": 104, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0312\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-NUMERIC\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175801\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNNUMERIC\nN-------\nNNUMERIC changes the way in which a program carries out arithmetic\nNoperations.\nN\nN\nNSyntax:\nD  NUMERIC DIGITS expression1\nD  NUMERIC FORM \u00ddSCIENTIFIC | ENGINEERING | VALUE expression2\u00a8\nD  NUMERIC FUZZ expression3\nN\nI    DIGITS: Controls the precision to which arithmetic operations and\nI      arithmetic built-in functions are evaluated.\nN\nI      expression1: If you omit expression1, the precision defaults\nI      to 9 digits. Otherwise, expression1 must evaluate to a positive\nI      whole number and must be larger than the current NUMERIC FUZZ\nI      setting.\nN\nI    FORM: Controls which form of exponential notation REXX uses for the\nI          result of arithmetic operations and arithmetic built-in\nI          functions.\nN\nI      SCIENTIFIC: Only one, nonzero digit appears before the decimal\nI                  point.\nN\nI      ENGINEERING: The power of 10 is always a multiple of 3.\nN\nI      VALUE: taken from the result of evaluating expression2 that\nI             follows VALUE.\nN\nI        expression2: The result in this case must be either SCIENTIFIC\nI                     or ENGINEERING.\nN\nI    FUZZ: Controls how many digits, at full precision, are ignored\nI          during a numeric comparison operation.\nN\nI      expression3: If you omit expression3, the default is 0 digits.\nI                   Otherwise, expression3 must evaluate to 0 or a\nI                   positive whole number, rounded if necessary\nI                   according to the current NUMERIC DIGITS setting,\nI                   and must be smaller than the current NUMERIC DIGITS\nI                   setting.\nN\nNExample: NUMERIC DIGITS\nN-----------------------\nN\nI  NUMERIC DIGITS 9    /* Handles several Megabytes  <== Default */\nI  NUMERIC DIGITS 10   /* Handles Gigabyte */\nI  NUMERIC DIGITS 14   /* Handles Terabyte */\nI  NUMERIC DIGITS 16   /* Handles Petabyte */\nI  NUMERIC DIGITS 19   /* Handles Exabyte */\nI  NUMERIC DIGITS 22   /* Handles Zetabyte */\nI  NUMERIC DIGITS 25   /* Handles Yottabyte */\nI  NUMERIC DIGITS 28   /* Handles Hellabyte/Brontobyte  */\nI  NUMERIC DIGITS 31   /* Handles Queenbyte */\nI  NUMERIC DIGITS 34   /* Handles Robotbyte */\nN\nNExample: NUMERIC FORM SCIENTIFIC\nN--------------------------------\nNThis is the default.\nI  NUMERIC FORM SCIENTIFIC\nN\nNExample: NUMERIC FORM ENGINEERING\nN---------------------------------\nN\nI  NUMERIC FORM ENGINEERING\nI  NUMERIC DIGITS 31   /* Handles Queenbyte                             */\nI  @1_h = 1237940039285380274898944000\nI  @1_q = 1024 * @1_h  /*     1,267,650,600,228,229,401,496,728,371,200 */\nI  SAY \"31=\" ,\nI    Left(\"QueenByte\",10) Right(@1_q,34) Right(D2X(@1_q),28,\"0\")\nN\nNExample: NUMERIC FORM VALUE expression2\nN---------------------------------------\nN\nI  expression2 = \"ENGINEERING\"\nI  NUMERIC FORM VALUE expression2\nN\nNExample: NUMERIC FUZZ\nN---------------------\nNOnly compare the five leftmost digits.\nI  NUMERIC FUZZ 5\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0313": {"ttr": 41227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00s\\x00s\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:02", "lines": 115, "newlines": 115, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0313\nKDBTODBCS DBTOSBCS\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-OPTIONS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175802\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNOPTIONS\nN-------\nNOPTIONS passes special requests or parameters to the language\nNprocessor. For example, these may be language processor options or\nNperhaps define a special character set.\nN\nN\nNSyntax:\nD  OPTIONS expression \u00dd'ETMODE' | 'NOETMODE'\u00a8 \u00dd'EXMODE' | 'NOEXMODE'\u00a8\nI    expression: The expression is evaluated, and the result is examined\nI      one word at a time. The language processor converts the words to\nI      uppercase. If the language processor recognizes the words, then\nI      they are obeyed. Words that are not recognized are ignored and\nI      assumed to be instructions to a different processor.\nN\nI    ETMODE: specifies that literal strings and symbols and comments\nI      containing DBCS characters are checked for being valid DBCS\nI      strings. If you use this option, it must be the first\nI      instruction of the program.\nM\nM      /* REXX for compiler or SYSPROC. */\nM      OPTIONS 'ETMODE'\nN\nI    NOETMODE: specifies that literal strings and symbols and comments\nI      containing DBCS characters are not checked for being valid DBCS\nI      strings. NOETMODE is the default. The language processor ignores\nI      this option unless it is the first instruction in a program.\nM\nM      /* REXX for compiler or SYSPROC. */\nM      OPTIONS 'NOETMODE'\nN\nI    EXMODE: specifies that instructions, operators, and functions\nI      handle DBCS data in mixed strings on a logical character basis.\nI      DBCS data integrity is maintained.\nN\nI    NOEXMODE specifies that any data in strings is handled on a byte\nI      basis. The integrity of DBCS characters, if any, may be lost.\nI      NOEXMODE is the default.\nN\nN\nNExample 1 - Found on the internet\nN---------------------------------\nNThe following is an example of an exec using a DBCS variable name and\nNa DBCS subroutine label.\nN\nI/*   REXX  */\nIOPTIONS 'ETMODE'          /* ETMODE to enable DBCS variable names  */\nIj = 1\nI<.S.Y.M.D> = 10            /* Variable with DBCS characters between\nI                             shift-out (<) and shift-in (>)        */\nICALL <.D.B.C.S.R.T.N>     /* Invoke subroutine with DBCS name      */\nI ...\nI<.D.B.C.S.R.T.N>:         /* Subroutine with DBCS name             */\nIDO i = 1 TO 10\nI  IF x.i = <.S.Y.D.M> THEN  /* Does x.i match the DBCS variable's\nI                               value?                              */\nI    SAY 'Value of the DBCS variable is : ' <.S.Y.D.M>\nIEND\nIEXIT 0\nM\nMEven after tweaking this example I could never get a match.\nN\nNExample 2 - DBCS subroutine label\nN---------------------------------\nNEnsure the subroutine label is 'shifted'. Use hx line command to view\nN the label name contains the shift-out and shift-in characters 0E/0F.\nN\nI/*   REXX  */\nIOPTIONS 'ETMODE'          /* ETMODE to enable DBCS variable names  */\nIso = '0E'x                /* DBCS shift-out */\nIsi = '0F'x                /* DBCS shift-in  */\nIa. = 0\nIa.9 = 9\nIa.10 = \"Match\"\nISAY \"Value of a.10                 :\" a.10\nIa.11 = 11\nICALL  .D.B.C.S.R.T.N      /* Invoke subroutine with DBCS label     */\nNCCDD404C4C4C4E4D4E4D044444654C9A9984AA899AA8984A8A84CCCE49898444444564\nN31330EB4B2B3B2B9B3B5F000001C095562502429643955069380423205145000000C10\nISay \"Back from DBCS routine.\"\nIEXIT 0\nI\nI .D.B.C.S.R.T.N :         /* Subroutine with DBCS label            */\nN04C4C4C4E4D4E4D07444444444654EA899AA8984A8A84CCCE498984444444444444564\nNEB4B2B3B2B9B3B5FA0000000001C024296439550693804232051450000000000000C10\nIDO j = 8 TO 12\nI  if j = 10 then say \"a.10 should match\"\nI  IF  a.j  = \"Match\" THEN  /* Does x.j match the DBCS variable? */\nI    SAY \"Value of the a.10 variable is :  \"A.10\nI  ELSE\nI    SAY \"a.\"j \"is not a match:\" a.j\nIEND\nIRETURN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0314": {"ttr": 41473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x01.\\x01.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:02", "lines": 302, "newlines": 302, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0314\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-PARSE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175802\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNPARSE\nN-----\nNPARSE assigns data (from various sources) to one or more variables\nNaccording to the rules of parsing. See Chapter 5. Parsing for\nNadditional guidance.\nN\nNThe template_list is often a single template but may be several\nNtemplates separated by commas. If specified, each template is a list\nNof symbols separated by blanks or patterns or both.\nN\nNEach template is applied to a single source string. Specifying\nNmultiple templates is never a syntax error, but only the PARSE ARG\nNvariant can supply more than one non-null source string.\nN\nN\nNSyntax:\nD  PARSE \u00ddUPPER\u00a8\nD    ARG | EXTERNAL | NUMERIC | PULL | SOURCE | VALUE expression WITH |\nD    VAR name | VERSION \u00ddtemplate_list\u00a8\nN\nI    UPPER: If you specify the UPPER option, the data to be parsed is\nI           first translated to uppercase (that is, lowercase a-z to\nI           uppercase A-Z). Otherwise, no uppercase translation takes\nI           place during the parsing.\nN\nI    ARG: parses the string or strings passed to a program or internal\nI         routine as input arguments.\nN\nI    EXTERNAL: In TSO/E, PARSE EXTERNAL reads from the:\nI              -> Terminal (TSO/E foreground)\nI              -> Input stream, which is SYSTSIN (TSO/E background).\nN\nI              In non-TSO/E address spaces, PARSE EXTERNAL reads from\nI              the input stream as defined by the file name in the INDD\nI              field in the module name table. The system default is\nI              SYSTSIN. PARSE EXTERNAL returns a field based on the\nI              record that is read from the INDD file. If SYSTSIN has\nI              no data, the PARSE EXTERNAL instruction returns a null\nI              string.\nN\nI    NUMERIC: The current numeric controls (as set by the NUMERIC\nI             instruction) are available. These controls are in the\nI             order DIGITS FUZZ FORM.\nN\nIExample:\nIParse Numeric Var1\nIAfter this instruction, Var1 would be equal to: 9 0 SCIENTIFIC.\nN\nIExample:\nIParse Numeric NUM_DIGITS NUM_FUZZ NUM_FORM\nIAfter this instruction, NUM_DIGITS would be equal to: 9\nI                        NUM_FUZZ would be equal to: 0\nI                        NUM_FORM would be equal to: SCIENTIFIC\nN\nI    PULL: parses the next string from the external data queue. If the\nI          external data queue is empty, PARSE PULL reads a line from\nI          the default input stream (the user's terminal), and the\nI          program pauses, if necessary, until a line is complete.\nN\nM          See PARSE EXTERNAL for the data source if the stack is empty.\nN\nI    SOURCE: parses data describing the source of the program running.\nI            The language processor returns a string that is fixed\nI            (does not change) while the program is running.\nN\nI    VALUE expression: parses the data that is the result of evaluating\nI                      expression. If you specify no expression, then\nI                      the null string is used. Note that WITH is a\nI                      subkeyword in this context and cannot be used\nI                      as a symbol within expression. Thus, for example:\nN\nIPARSE VALUE TIME() WITH hours \":\" mins \":\" secs\nN  gets the current time and splits it into its constituent parts.\nN\nI    VAR varname: parses the value of the variable varname.\nN\nI    VERSION: parses information describing the language level and the\nI             date of the language processor. This information consists\nI             of five blank-delimited words:\nI             1. A word describing the language, which is the string\nI                \"REXX370\"\nI             2. The language level description, for example, \"3.46\"\nI             3. Three tokens describing the language processor release\nI                date, for example: \"31\", \"May\", and \"2001'.\nM\nMPerformance tip from Kenneth Tomiak\nMPARSE VALUE versus PARSE VAR\nMVALUE processes the expression to yield a result that is then parsed.\nMWhen parsing a variable under VALUE you are asking REXX to evaluate\nMan already static value. Your code also suggests the value is\nMunknown when in fact it is known. PARSE VALUE is meant to be used\nMwith an expression that needs to be evaluated (processed) before\nMits value can be parsed. Do use PROCESS VAR when all you pass is a\nMvariable name.\nN\nN\nNExamples\nI/* REXX */\nI  SAY \"REXR0314\"\nI  SAY \"--------\"\nI  SAY \"Arg()\" Arg()\nI  parse source module_source\nI  subroutine_rc = parse_ways(Arg(1))\nI  RETURN 0\nI\nI  subroutine_rc = loop_value()\nI  loop_count = 750\nI  SAY \"Parse\" PARSE_VALUE_ctr \"time(s).\"\nI  subroutine_rc = loop_var()\nI  subroutine_rc = loop_var()\nI  subroutine_rc = loop_value()\nI  subroutine_rc = loop_value()\nI  subroutine_rc = loop_var()\nI  RETURN 0\nI\nIparse_ways: Procedure ,\nI  Expose module_source\nI  parse source subroutine_source\nI\nI  SAY \"\"\nI  SAY \"Example PARSE ARG\"\nI  SAY \"-------------------------\"\nI  SAY \"tso %rexr0314 Hello, 'Kenneth Tomiak'.\"\nI  PARSE ARG greeting \",\" . =1 . \"'\" named \"'\"  appendage\nI  SAY \"Greeting:\" greeting\nI  SAY \"named   :\" named\nI  SAY \"Clutter :\" appendage\nI  SAY \"Example PARSE UPPER ARG\"\nI  SAY \"-------------------------\"\nI  PARSE UPPER ARG greeting \",\" . =1 . \"'\" named \"'\"  appendage\nI  SAY \"Greeting:\" greeting\nI  SAY \"named   :\" named\nI  SAY \"Clutter :\" appendage\nI\nI  SAY \"\"\nI  SAY \"Example PARSE EXTERNAL\"\nI  SAY \"------------------------------\"\nI  Address MVS MAKEBUF\nI  QUEUE \"This is on the stack.\"\nI  SAY \"Prompt for some input:\"\nI  PARSE EXTERNAL @user_data1\nI  SAY \"Prompt for more input:\"\nI  PARSE UPPER EXTERNAL @user_data2\nI  Address MVS DROPBUF\nI  SAY \"You entered:\" @user_data1\nI  SAY \"           :\" @user_data2\nI\nI  SAY \"\"\nI  SAY \"Example PARSE NUMERIC (always upper)\"\nI  SAY \"------------------------------------\"\nI  PARSE NUMERIC digitz fuzzy form\nI  SAY \"Digits:\" digitz\nI  SAY \"Fuzz  :\" fuzzy\nI  SAY \"Form  :\" form\nI  SAY \"Or retrieving each individually...\"\nI  bif_digits = Digits()\nI  bif_fuzzy = Fuzz()\nI  bif_form = Form()\nI  SAY \"Digits:\" bif_digits\nI  SAY \"Fuzz  :\" bif_fuzzy\nI  SAY \"Form  :\" bif_form\nI\nI  SAY \"\"\nI  SAY \"Example PARSE PULL\"\nI  SAY \"--------------------------\"\nI  Address MVS MAKEBUF\nI  QUEUE \"This is on the stack.\"\nI  bif_queued = Queued()\nI  SAY \"Input from the stack:\"\nI  DO q_ctr = 1 to bif_queued\nI    PARSE UPPER PULL @user_data1\nI    SAY @user_data1\nI  END\nI  SAY \"Input from EXTERNAL (stack empty):\"\nI  PARSE UPPER PULL @user_data2\nI  Address MVS DROPBUF\nI  SAY @user_data2\nI\nI  SAY \"\"\nI  SAY \"Example PARSE SOURCE\"\nI  SAY \"----------------------------\"\nI  PARSE SOURCE c_TSO ,\nI               l_cfs ,\nI               v_uen ,\nI               v_ddn ,\nI               v_dsn ,\nI               v_len ,\nI               v_uhce ,\nI               v_asn ,\nI               v_ut\nI  SAY \"Constant TSO:\" c_TSO\nI  SAY \"Label COMMAND | FUNCTION | SUBROUTINE:\" l_cfs\nI  SAY \"Variable UPPERCASE Exec Name:\" v_uen\nI  SAY \"Variable DDName:\" v_ddn\nI  SAY \"Variable DSName:\" v_dsn\nI  SAY \"Variable lowercase Exec Name\" v_len\nI  SAY \"Variable UPPERCASE Host Command Environment\" v_uhce\nI  SAY \"Variable Address Space Name\" v_asn\nI  SAY \"Variable User Token\" v_ut\nI  SAY \"++++++++++++++++++++++++++++++++++++++++++++++++++\"\nI  SAY \"+                    CALL                        +\"\nI  SAY \"++++++++++++++++++++++++++++++++++++++++++++++++++\"\nI  CALL GSource\nI  SAY \"++++++++++++++++++++++++++++++++++++++++++++++++++\"\nI  SAY \"+              Address TSO                       +\"\nI  SAY \"++++++++++++++++++++++++++++++++++++++++++++++++++\"\nI  Address TSO \"EXEC 'KTOMIAK.TSO.REXX(GSOURCE)' 'some, data'\"\nI  SAY \"++++++++++++++++++++++++++++++++++++++++++++++++++\"\nI  SAY \"+                   GSource                      +\"\nI  SAY \"++++++++++++++++++++++++++++++++++++++++++++++++++\"\nI  GSource\nI\nI  SAY \"\"\nI  SAY \"Example PARSE VALUE expression WITH\"\nI  SAY \"-------------------------------------------\"\nI  PARSE VALUE V_DDN (3 * 7) WITH field_1 Field_2\nI  SAY \"Field #1 =\" field_1\nI  SAY \"Field #2 =\" field_2\nI\nI  SAY \"\"\nI  SAY \"Example PARSE VAR name\"\nI  SAY \"------------------------------\"\nI  PARSE VAR v_ddn ,\nI            scope +3 ,\nI            modtype\nI  SAY \"Scope:\" scope\nI  SAY \"Module type (PROC=CLIST; EXEC=REXX):\" modtype\nI\nI  SAY \"\"\nI  SAY \"Example PARSE VERSION\"\nI  SAY \"-----------------------------\"\nI  PARSE VERSION ver_language ver_level ver_token\nI  PARSE VAR ver_token prd_dom prd_month prd_year\nI  SAY \"Language:\" ver_Language\nI  SAY \"Level:\" ver_Level\nI  SAY \"Token:\" ver_token\nI  SAY \"Tokendate:\" prd_year\"-\"prd_month\"-\"prd_dom\nI\nI  SAY \"\"\nI  RETURN 0\nI\nIloop_value:\nI  SAY \" \"\nI  SAY \"PARSE_VALUE timings:\"\nI  SAY \"====================\"\nI  @start_SYSCPU   = SysVar(\"SYSCPU\")\nI  @start_SYSSRV   = SysVar(\"SYSSRV\")\nI  Do PARSE_VALUE_ctr = 1 to loop_count\nI    static_value = \"PO BOX\" loop_count\nI    PARSE VALUE static_value WITH ,\nI      po box number\nI  End\nI  @PARSE_VALUE_SYSCPU = SysVar(\"SYSCPU\")\nI  @PARSE_VALUE_SYSSRV = SysVar(\"SYSSRV\")\nI  PARSE_VALUE_ctr = PARSE_VALUE_ctr - 1\nI  @accum_syscpu = @PARSE_VALUE_syscpu - @start_syscpu\nI  @accum_syssrv = @PARSE_VALUE_syssrv - @start_syssrv\nI  SAY \"CPU used:\" @accum_syscpu\nI  SAY \"SRV used:\" @accum_syssrv\nI  RETURN loop_count\nI\nIloop_var:\nI  SAY \" \"\nI  SAY \"PARSE_VAR timings:\"\nI  SAY \"====================\"\nI  @start_SYSCPU   = SysVar(\"SYSCPU\")\nI  @start_SYSSRV   = SysVar(\"SYSSRV\")\nI  Do PARSE_VAR_ctr = 1 to loop_count\nI    static_value = \"PO BOX\" loop_count\nI    PARSE VAR static_VAR ,\nI      po box number\nI  End\nI  @PARSE_VAR_SYSCPU = SysVar(\"SYSCPU\")\nI  @PARSE_VAR_SYSSRV = SysVar(\"SYSSRV\")\nI  PARSE_VAR_ctr = PARSE_VAR_ctr - 1\nI  @accum_syscpu = @PARSE_VAR_syscpu - @start_syscpu\nI  @accum_syssrv = @PARSE_VAR_syssrv - @start_syssrv\nI  SAY \"CPU used:\" @accum_syscpu\nI  SAY \"SRV used:\" @accum_syssrv\nI  RETURN loop_count\nI\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0315": {"ttr": 41475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00A\\x00A\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:02", "lines": 65, "newlines": 65, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0315\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-PROCEDURE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175802\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNPROCEDURE\nN---------\nNPROCEDURE, within an internal routine (subroutine or function),\nNprotects variables by making them unknown to the instructions that\nNfollow it. After a RETURN instruction is processed, the original\nNvariables environment is restored and any variables used in the\nNroutine (that were not exposed) are dropped. (An exposed variable is\nNone belonging to a caller of a routine that the PROCEDURE instruction\nNhas exposed. When the routine refers to or alters the variable, the\nNoriginal (caller's) copy of the variable is used.) An internal routine\nNneed not include a PROCEDURE instruction; in this case the variables\nNit is manipulating are those the caller 'owns.' If used, the PROCEDURE\nNinstruction must be the first instruction processed after the CALL or\nNfunction invocation; that is, it must be the first instruction\nNfollowing the label.\nN\nN\nNSyntax:\nDPROCEDURE EXPOSE name, ... | (name)\nI  EXPOSE: Causes the named variables to be shared between the main\nI          code and the subroutine.\nN\nI    name: A variable name.\nN\nI   (name): A variable name that contains a subsidiary list of variable\nI           names.\nN\nN\nNExample\nI/* This is the main REXX program */\nIc=11; d=12; e=13; G.e=14\nIShowlist = \"c d G.\" /* but not E */\nIcall Playvars\nIsay \"You should see: 11 New 13 9 G. 14\"\nIsay \"               \" c d e f G. G.e\nIexit\nI/* This is a subroutine */\nIPlayvars: Procedure Expose (showlist) f\nIsay word(showlist,2) /* Displays \"d\" */\nIsay value(word(showlist,2),'New') /* Displays \"12\" and sets new value */\nIsay value(word(showlist,2)) /* Displays \"New\" */\nIe=8 /* E is not exposed */\nIf=9 /* F was explicitly exposed */\nIreturn\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0316": {"ttr": 41477, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:03", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0316\nKACCEPT READ INPUT LINEIN PARSE\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-PULL\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175803\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNPULL\nN----\nNPULL reads a string from the head of the external data queue. It\nNis just a short form of the instruction: PARSE UPPER PULL template.\nN\nNThe string is translated to uppercase.\nN\nNSyntax:\nD  PULL template_list\nN\nN\nNExample:\nN--------\nI/* rexx */\nI  QUEUE \"Kenneth Tomiak\"\nI  IF (Queued() > 0) THEN DO\nI    SAY \"Fetching your name:\"\nI    PULL user_name   /* Translates to uppercase. */\nI  END\nI  ELSE DO\nI    SAY \"What is your name?\"\nI    PARSE PULL user_name    /* Retains case sensitivity. */\nI  END\nI  SAY \"Are you\" user_name\"?\"\nI  PULL answer\nI  IF ( abbrev(answer,\"Y\") = 0 ) THEN DO\nI    SAY \"What is your name?\"\nI    PARSE PULL user_name    /* Retains case sensitivity. */\nI  END\nI  SAY \"Hello\" user_name\".\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0317": {"ttr": 41479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x005\\x005\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:03", "lines": 53, "newlines": 53, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0317\nKPARSE PULL QUEUE\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-PUSH\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175803\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNPUSH\nN----\nNPUSH stacks the string resulting from the evaluation of\nNexpression LIFO (Last In, First Out) onto the external data queue.\nNThis is also known as FILO (First In, Last Out).\nN\nNSyntax:\nD  PUSH expression\nI    expression: A string resulting from the evaluation of expression.\nN\nN\nNExample:\nI  SAY \"REXR0317\"\nI  SAY \"--------\"\nI  SAY \"PUSH adds to the stack in FILO/LIFO order.\"\nI  SAY \"PUSH puts the string on top and forces the rest of the\"\nI  SAY \"stack down. In this way you would have to build a\"\nI  SAY \"sequence of control cards in reverse order.\"\nI  SAY \"\"\nI  SAY \"Use QUEUE to build them in the logical FIFO/LILO order.\"\nI  SAY \"\"\nI  DO ix = 9 TO 4 by -1\nI    PUSH \"Inverse records #\"IX\nI  END\nI  PUSH \"RECORD 2 ON THE DATA STACK. #3\"\nI  PUSH \"Record 1 on the data stack. #2\"\nI  PUSH \"PUSH  #3 BECOMES THE NEW RECORD 1 ON THE DATA STACK.\"\nI  DO WHILE QUEUED() > 0\nI    PARSE PULL data_record\nI    SAY data_record\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0318": {"ttr": 41481, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x005\\x005\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:03", "lines": 53, "newlines": 53, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0318\nKPULL PUSH PARSE\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-QUEUE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175803\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNQUEUE\nN-----\nNQUEUE appends the string resulting from expression to the tail\nNof the external data queue. That is, it is added FIFO (First In, First\nNOut) or LILO (Last In, Last Out).\nN\nNSyntax:\nD  QUEUE expression\nI    expression: A string resulting from the evaluation of expression.\nN\nN\nNExample:\nI  SAY \"REXR0318\"\nI  SAY \"--------\"\nI  SAY \"QUEUE adds to the stack in FIFO/LILO order.\"\nI  SAY \"QUEUE puts the string on the bottom of the stack.\"\nI  SAY \"In this way you build a\"\nI  SAY \"sequence of control cards in logical order.\"\nI  SAY \"\"\nI  SAY \"Use PUSH to build them in the arse-backwards FILO/LIFO order.\"\nI  SAY \"\"\nI  QUEUE \"QUEUE #1 BECOMES THE NEW RECORD 1 ON THE DATA STACK.\"\nI  QUEUE \"Record 2 on the data stack. #2\"\nI  QUEUE \"RECORD 3 ON THE DATA STACK. #3\"\nI  DO ix = 4 TO 9 by +1\nI    QUEUE \"Inverse records #\"IX\nI  END\nI  DO WHILE QUEUED() > 0\nI    PARSE PULL data_record\nI    SAY data_record\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0319": {"ttr": 41483, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00F\\x00F\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:03", "lines": 70, "newlines": 70, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0319\nKEXIT\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-RETURN\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175803\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNRETURN\nN------\nNRETURN returns control (and possibly a result) from a REXX\nNprogram or internal routine to the point of its invocation.\nI\nIIf no internal routine is active, RETURN and EXIT are identical in\nItheir effect on the program that is being run.\nM\nMMessage from Kenneth Tomiak\nMEXIT declares it leaves the program unconditionally. For that reason,\nMKenneth uses RETURN to terminate non-EDIT macro code. For EDIT macro\nMcode, EXIT influences where the cursor is placed.\nN\nN\nNSyntax:\nD  RETURN expression\nI    expression: A string resulting from evaluating expression.\nN\nN\nNExample:\nI  SAY \"\"\nI  SAY \"CALL 24\"\nI  SAY \"-------\"\nI  CALL no_result 24\nI  SAY \"Result shows:\" RESULT\nI\nI  SAY \"\"\nI  SAY \"subroutine(24)\"\nI  SAY \"--------------\"\nI  subroutine_rc = yes_result(24)\nI  SAY \"Result shows:\" RESULT\nI  SAY \"subroutine_rc shows:\" subroutine_rc\nI  SAY \"That would be a 15% tip!\"\nI\nI  RETURN 0\nI\nIno_result:\nI  SAY \"I see your\" Arg(1) \"and accept it.\"\nI  SAY \"But you will not know that.\"\nI  tip = (Arg(1) * 1.15) - Arg(1)\nI  SAY \"You might include\" tip \"for the tip.\"\nI  Result = tip\nI  RETURN\nI\nIyes_result:\nI  SAY \"I see your\" Arg(1) \"and accept it.\"\nI  SAY \"You will know that by checking what I returned.\"\nI  RETURN (Arg(1) * 1.15) - Arg(1)\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0320": {"ttr": 41729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x009\\x009\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:04", "lines": 57, "newlines": 57, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0320\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-SAY\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175804\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNSAY\nN---\nNSAY writes a line to the output stream. This typically displays\nNit to the user, but the output destination can depend on the\nNimplementation. The result of expression may be of any length. If you\nNomit expression, the null string is written.\nI\nIFor a foreground TSO session the user's terminal will display the\nIresult of expression. Other implementations will direct the result\nIto the //SYSTSPRT DD location.\nM\nMMessage from Kenneth Tomiak\nMWhen the length of expression exceeds LINESIZE() - 1 the string will\nMwrap. For that reason, an 80 character wide terminal is limited to\nMshowing 79 characters per line. The first byte holds an attribute\nMbyte as part of terminal control: default green unprotected.\nN\nN\nNSyntax:\nD  SAY expression\nI    expression: A string resulting from evaluating expression.\nN\nN\nNExample:\nI  SAY \"\"\nI  SAY \"SAY expression\"\nI  SAY \"--------------\"\nI  data=100\nI  SAY \"100 divided by 4 => 25 is the expected expression shown.\"\nI  SAY data \"divided by 4 =>\" data/4\nI\nI  SAY \"\"\nI  repetition = (Linesize() / 10) + 1\nI  PARSE VAR repetition repetition \".\" .\nI  SAY \"Linesize:\" LineSize() \"showing\" repetition * 10  \"characters.\"\nI  SAY Copies(\"1234567890\",repetition)\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0321": {"ttr": 52993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x18\\x13\\x7f\\x01\\x18\\x14/\\x15U\\x00_\\x00_\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-22T15:55:40", "lines": 95, "newlines": 95, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0321\nKWHEN\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-SELECT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180522-155540\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNSELECT\nN------\nNSELECT conditionally calls one of several alternative\nNinstructions.\nN\nN\nNSyntax:\nD  SELECT\nD    WHEN (expression) THEN DO\nD      instruction list | NOP\nD    END\nD    WHEN (expression) THEN DO\nD      instruction list | NOP\nD    END\nD    OTHERWISE DO\nD      instruction list | NOP | null\nD    END\nD  END\nI\nI    (expression): Each expression after a WHEN is evaluated in turn\nI                  and must result in 0 or 1. If the result is 1, the\nI                  instruction following the associated THEN (which may\nI                  be a complex instruction such as IF, DO, or SELECT)\nI                  is processed and control then passes to the END. If\nI                  the result is 0, control passes to the next WHEN\nI                  clause.\nN\nI    instruction list: The instruction can be any assignment, command,\nI                      or keyword instruction, including any of the\nI                      more complex constructs such as DO, IF, or the\nI                      SELECT instruction itself.\nN\nI                      A null clause is not an instruction, so putting\nI                      an extra semicolon (or label) after a THEN clause\nI                      is not equivalent to putting a dummy instruction.\nI                      The NOP instruction is provided for this purpose.\nN\nI    OTHERWISE: If none of the WHEN expressions evaluates to 1, control\nI               passes to the instructions, if any, after OTHERWISE. In\nI               this situation, the absence of an OTHERWISE causes an\nI               error (but note that you can omit the instruction list\nI               that follows OTHERWISE).\nN\nM\nMMessage from Kenneth Tomiak\nMThe extra DO/END on the first WHEN and on OTHERWISE comply with my\nM'Kenneth Tomiak Programming Method' (KTPM07) for\nMconsistency, readability, and future expansion.\nN\nN\nNExample:\nI  balance = 100\nI  check = 50\nI  DO ix = 1 TO 3\nI    old_balance = balance\nI    balance = balance - check\nI    SAY old_balance \"-\" check \"=\" balance\nI    SELECT\nI      WHEN balance > 0 THEN DO\nI        SAY \"Congratulations! You still have\" balance \"dollars left.\"\nI      END /* WHEN  balance > 0*/\nI      WHEN balance = 0 THEN DO\nI        SAY \"Attention, Balance is now zero! STOP all spending.\"\nI        SAY \"You cut it close this month! Hope you do not have any\"\nI        SAY \"checks left outstanding.\"\nI      END /* WHEN balance = 0*/\nI      OTHERWISE DO\nI        SAY \"You have just overdrawn your account.\"\nI        SAY \"Your balance now shows\" balance \"dollars.\"\nI        SAY \"Oops! Hope the bank does not close your account.\"\nI      END /* OTHERWISE */\nI    END /* Select */\nI  END /* DO ix */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0322": {"ttr": 41731, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00\\xe4\\x00\\xe4\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:04", "lines": 228, "newlines": 228, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0322\nKGOTO\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-SIGNAL\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175804\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNSIGNAL\nN------\nNSIGNAL causes an unusual change in the flow of control (if you specify\nNlabelname or VALUE expression), or controls the trapping of certain\nNconditions (if you specify ON or OFF).\nN\nN\nNSyntax:\nD  SIGNAL labelname | condition state \u00ddNAME labeltrap\u00a8\nI    labelname: The name of a subroutine to pass control to. There is no\nI               return processing that CALL supports.\nN\nI    condition: ERROR | FAILURE | HALT | NOVALUE | SYNTAX\nN\nI    state: ON | OFF\nN\nI    labeltrap: The name of your error handling subroutine. If a named\nI               subroutine is not used then the default label matches\nI               the condition.\nN\nNExample:\nI  SAY \"\"\nI  SAY \"REXR0322: SIGNAL\"\nI  SAY \"================\"\nI\nI  SAY \"\"\nI  SAY \"Example: Trapping conditions SIGNAL\"\nI  SAY \"==================================\"\nI  return_code = 0\nI\nI  SIGNAL ON ERROR\nI  SIGNAL ON FAILURE\nI  SIGNAL ON HALT\nI  SIGNAL ON NOVALUE\nI  SIGNAL ON SYNTAX\nI\nI  signal_type = \"\"\nI  come_back = \"000\"\nI  SAY \"Cause a negative RC:\"\nI  SAY \"--------------------\"\nI  Address MVS \"EXECIO 1 DISKr Apple (STEM pits. FINIS)\"\nI\nIRecover_Error:\nI\nInoerror_000:\nI  IF ( signal_type <> \"\" ) THEN DO\nI    SAY \"I came back to the Process_routine after an\" signal_type\".\"\nI  END\nI  SIGNAL OFF ERROR\nI  SIGNAL OFF FAILURE\nI  SIGNAL OFF HALT\nI  SIGNAL OFF NOVALUE\nI  SIGNAL OFF SYNTAX\nI\nI  function_rc = localized_return()\nI\nI  SAY \"Done experimenting.\"\nI  RETURN return_code\nI\nI/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nI=======================================================================\nI This sub-routine handles several conditions using a named routine.\nI=======================================================================\nI>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nIlocalized_return:\nI  SAY \"\"\nI  SAY \"Setting local SIGNAL ON conditions:\"\nI  SAY \"=================================\"\nI  SIGNAL ON ERROR    NAME Error_Handler_Routine\nI  SIGNAL ON FAILURE  NAME Error_Handler_Routine\nI  SIGNAL ON HALT     NAME Error_Handler_Routine\nI  SIGNAL ON NOVALUE  NAME Error_Handler_Routine\nI  SIGNAL ON SYNTAX   NAME Error_Handler_Routine\nI\nI  signal_type = \"\"\nI  SAY \"Cause an error:\"\nI  SAY \"---------------\"\nI  ADDRESS TSO \"ALLOC FILE(Apple) DA(TSO.REXX(ERRHNDLR)) SHR REUSE\"\nI  ADDRESS MVS \"EXECIO * DISKR Apple (STEM pits. )\"\nI  SAY \"Read\" pits.0 \"record(s)\"\nI  SAY \"An attempt to read from APPLE will fail.\"\nI  ADDRESS MVS \"EXECIO 1 DISKR Apple (STEM pits. FINIS)\"\nI  SAY \"I came back to the localized_return routine.\"\nI\nI  ADDRESS TSO \"FREE FILE(Apple)\"\nI\nI  SIGNAL OFF ERROR\nI  SIGNAL OFF FAILURE\nI  SIGNAL OFF HALT\nI  SIGNAL OFF NOVALUE\nI  SIGNAL OFF SYNTAX\nI\nI  RETURN return_code\nI\nI/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nI=======================================================================\nI This routine handles several conditions and returns after the fault.\nI=======================================================================\nI>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nIError_Handler_Routine:\nI  err_sigl = Sigl\nI  err_rc   = RC\nI  SAY \"  I came to the Error_Handler_Routine.\"\nI  signal_type = To_UpperCase(CONDITION(\"C\"))\nI  signal_desc = CONDITION(\"D\")\nI  signal_inst = CONDITION(\"I\")\nI  signal_stat = CONDITION(\"S\")\nI  SAY \"EHR c:\" signal_type \"at\" err_sigl\nI  SAY \"    d:\" signal_desc\nI  SAY \"    i:\" signal_inst\nI  SAY \"    s:\" signal_stat\", RC(\"err_rc\")\"\nI  error_code = -1\nI  SELECT\nI    WHEN ( signal_type = \"ERROR\" ) THEN DO\nI      error_code = 8\nI      signal_type = \"Error\"\nI    END\nI    WHEN ( signal_type = \"FAILURE\" ) THEN DO\nI      error_code = 8\nI      signal_type = \"FAILURE\"\nI    END\nI    WHEN ( signal_type = \"HALT\" ) THEN DO\nI      error_code = 8\nI      signal_type = \"HALT\"\nI    END\nI    WHEN ( signal_type = \"NOVALUE\" ) THEN DO\nI      error_code = 8\nI      signal_type = \"NOVALUE\"\nI    END\nI    WHEN ( signal_type = \"SYNTAX\" ) THEN DO\nI      error_code = 8\nI      signal_type = \"SYNTAX\"\nI    END\nI    OTHERWISE DO\nI      error_code = 32\nI      signal_type = \"Unknown\" signal_type\nI    END\nI  END\nI  result = -1\nI  SAY \"  RETURN to\" signal_type\"_\"come_back\nI  RETURN error_code\nI\nI/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nI=======================================================================\nI This routine does cleanup before exiting.\nI=======================================================================\nI>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nIERROR:\nI  SIGNAL OFF ERROR\nI  SAY \"    I came to the ERROR ROUTINE.\"\nI  err_sigl = Sigl\nI  signal_type = \"Error\"\nI  SAY signal_type \"at\" err_sigl\nI  return_code = 5\nI  SIGNAL Recover_Error\nI\nIFAILURE:\nI  SIGNAL OFF FAILURE\nI  SAY \"    I came to the FAILURE ROUTINE.\"\nI  err_sigl = Sigl\nI  signal_type = \"FAILURE\"\nI  SAY signal_type \"at\" err_sigl\nI  return_code = 6\nI  RETURN return_code\nI\nIHALT:\nI  SIGNAL OFF HALT\nI  SAY \"    I came to the HALT ROUTINE.\"\nI  err_sigl = Sigl\nI  signal_type = \"HALT\"\nI  SAY signal_type \"at\" err_sigl\nI  return_code = 7\nI  RETURN return_code\nI\nINOVALUE:\nI  SIGNAL OFF NOVALUE\nI  SAY \"    I came to the NOVALUE ROUTINE.\"\nI  err_sigl = Sigl\nI  signal_type = \"NOVALUE\"\nI  SAY signal_type \"at\" err_sigl\nI  return_code = 7\nI  RETURN return_code\nI\nISYNTAX:\nI  SIGNAL OFF SYNTAX\nI  SAY \"    I came to the SYNTAX ROUTINE.\"\nI  err_sigl = Sigl\nI  signal_type = \"SYNTAX\"\nI  SAY signal_type \"at\" err_sigl\nI  return_code = 7\nI  RETURN return_code\nI\nI/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nIConvert string to uppercase.\nI>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */\nITo_Uppercase:\nI  PARSE ARG myarg\nI  SAY \"Cause a NOVALUE condition\"\nI  SAY \"-------------------------\"\nI  IF ( lowercase_letters = \"LOWERCASE_LETTERS\" ) THEN DO\nI    lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\"\nI  END\nI  IF ( uppercase_letters = \"UPPERCASE_LETTERS\" ) THEN DO\nI    uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nI  END\nI  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0323": {"ttr": 41733, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00i\\x00i\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:04", "lines": 105, "newlines": 105, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0323\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-TRACE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175804\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNTRACE: TRACE controls the tracing action (that is, how much is\nNdisplayed to the user) during processing of a REXX program. (Tracing\nNdescribes some or all of the clauses in a program, producing\nNdescriptions of clauses as they are processed.) TRACE is mainly used\nNfor debugging. Its syntax is more concise than that of other REXX\nNinstructions because TRACE is usually entered manually during\nNinteractive debugging. (This is a form of tracing in which the user\nNcan interact with the language processor while the program is running.)\nNFor this use, economy of key strokes is especially convenient.\nN\nN\nNSyntax:\nD  TRACE number\nD  TRACE ? | ! | Off ,\nD    Normal | All | Commands | Error | Failure | Intermediates | ,\nD    Labels | Results | Scan\nN\nI    number: If specified, the number must be a whole number. The number\nI            of times pressing enter is simulated to bypass the pause\nI            caused by using \"?\".\nN\nI    ?: Controls interactive debug. You must press enter to continue.\nN\nI    !: Supress execution of a host command. or example, TRACE !C\nI       causes commands to be traced but not processed.\nN\nI    N | Normal: Traces any command resulting in a negative return code\nI        after execution, together with the return code from the\nI        command. This is the default setting and the same as specifying\nI        Failure.\nN\nI    A | All: Traces all clauses before execution.\nN\nI    E | Error: Traces any command resulting in an error or failure\nI               after execution, together with the return code from\nI               the command.\nN\nI    F | Failure: Traces any command resulting in a failure after\nI                 execution, together with the return code from the\nI                 command. This is the same as the Normal option.\nN\nI    I | Intermediates: Traces all clauses before execution. Also\ni                       traces intermediate results during evaluation\ni                       of expressions and substituted names.\nn\nI    L | Labels: Traces only labels passed during execution. This is\nI                especially useful with debug mode, when the language\nI                processor pauses after each label. It also helps the\nI                user to note all internal subroutine calls and\nI                transfers of control because of the SIGNAL instruction.\nN\nI    R | Results: Traces all clauses before execution. Displays final\nI                 results (contrast with Intermediates, preceding) of\nI                 evaluating an expression. Also displays values\nI                 assigned during PULL, ARG, and PARSE instructions.\nM                 This setting is suggested for general debugging.\nN\nI    S | Scan: Traces all remaining clauses in the data without them\nI              being processed. Basic checking (for missing ENDs and\nI              so forth) is carried out, and the trace is formatted as\nI              usual.\nN\nN\nNExample:\nI  SAY \"\"\nI  SAY \"REXR0323: TRACE\"\nI  SAY \"===============\"\nI\nI  TRACE 3 /* Press enter 3 times to bypass the pause ? causes. */\nI  TRACE ?IRS\nI  balance = 2107.00\nI  check = 50.00\nI  balance = balance - check - .05\nI  balance = balance - check - .05\nI  balance = balance - check - .05\nI  SAY \"Type TRACE Off and press enter.\"\nI  SAY \"TRACE OFF stops debugging mode.\"\nI  balance = 4325.98\nI  TRACE ?R\nI  SAY \"Type TRACE ?R and press enter.\"\nI  balance = balance - check - .05\nI  SAY \"Type TRACE A and press enter.\"\nI  balance = balance - check - .05\nI  balance = balance - check - .05\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0324": {"ttr": 41735, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00%\\x00%\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:05", "lines": 37, "newlines": 37, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0324\nTz/OS TSO/E REXX Reference\nT-Chapter 3.\nT-Instructions\nT-UPPER\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175805\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 3. Keyword instructions\nN-------------------------------\nNInstructions\nN------------\nNUPPER\nN-----\nNUPPER translates the contents of one or more variables to uppercase.\nN\nN\nNSyntax:\nD  UPPER variable, ...\nI    variable: One or more variable names to be translated in-place.\nM              The variable is overwritten with the uppercase value.\nN\nN\nNExample:\nI  name = \"Kenneth Tomiak\"\nI  uname = name\nI  Upper uname /* overwrites the value in uname */\nI  SAY name \"in uppercase is\" uname\".\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR04": {"ttr": 41737, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00\\xcd\\x00\\xcd\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:05", "lines": 205, "newlines": 205, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR04\nTz/OS TSO/E REXX Reference\nT-Chapter 4. Functions\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590254\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nN  Built-in functions\nN  ------------------\nN    ABBREV:     returns 1 if info is equal to the leading characters\nN                of information and the length of info is not less than\nN                length. Returns 0 if either of these conditions is not\nN                met.\nN    ABS:        returns the absolute value of number. The result has\nN                no sign and is formatted according to the current\nN                NUMERIC settings.\nN    ADDRESS:    returns the name of the environment to which commands\nN                are currently being submitted.\nN    ARG:        returns an argument string or information about the\nN                argument strings to a program or internal routine.\nN    BITAND:     returns a string composed of the two input strings\nN                logically ANDed together, bit by bit.\nN    BITOR:      returns a string composed of the two input strings\nN                logically inclusive-ORed together, bit by bit.\nN    BITXOR:     returns a string composed of the two input strings\nN                logically eXclusive-ORed together, bit by bit.\nN    B2X:        returns a string, in character format, that represents\nN                binary_string converted to hexadecimal.\nN    CENTER:     returns a string of length length with string centered\nN                in it, with pad characters added as necessary to make\nN                up length.\nN    COMPARE:    returns 0 if the strings, string1 and string2, are\nN                identical. Otherwise, returns the position of the\nN                first character that does not match.\nN    CONDITION:  returns the condition information associated with the\nN                current trapped condition.\nN    COPIES:     returns n concatenated copies of string. The n must be\nN                a positive whole number or zero.\nN    C2D:        returns the decimal value of the binary representation\nN                of string. If the result cannot be expressed as a\nN                whole number, an error results. That is, the result\nN                must not have more digits than the current setting of\nN                NUMERIC DIGITS.\nN    C2X:        returns a string, in character format, that represents\nN                string converted to hexadecimal. The returned string\nN                contains twice as many bytes as the input string.\nN    DATATYPE:   returns NUM if you specify only string and if string\nN                is a valid REXX number that can be added to 0 without\nN                error; returns CHAR if string is not a valid number.\nN    DATE:       returns, by default, the local date in the format:\nN                  dd mon yyyy (day, month, year), for example:\nN                  1 Jan 2017 or 25 Dec 2001\nN                with no leading zero or blank on the day.\nN    DBCS:       See Appendix A. Double-byte character set (DBCS)\nN                support.\nN    DELSTR:     returns string after deleting the substring that\nN                begins at the nth character and is of length\nN                characters.\nN    DELWORD:    returns string after deleting the substring that\nN                starts at the nth word and is of length\nN                blank-delimited words.\nN    DIGITS:     returns the current setting of NUMERIC DIGITS.\nN    D2C:        returns a string, in character format, that represents\nN                wholenumber, a decimal number, converted to binary.\nN    D2X:        returns a string, in character format, that represents\nN                wholenumber, a decimal number, converted to\nN                hexadecimal.\nN    ERRORTEXT:  returns the REXX error message associated with error\nN                number n.\nN    EXTERNALS:  always returns a 0.\nN    FIND:       WORDPOS is the preferred built-in function for this\nN                type of word search.\nN    FORM:       returns the current setting of NUMERIC FORM.\nN    FORMAT:     returns number, rounded and formatted.\nN    FUZZ:       returns the current setting of NUMERIC FUZZ.\nN    INDEX:      POS is the preferred built-in function for obtaining\nN                the position of one string in another.\nN    INSERT:     inserts the string new, padded or truncated to length\nN                length, into the string target after the nth\nN                character.\nN    JUSTIFY:    returns string formatted by adding pad characters\nN                between blank-delimited words to justify to both\nN                margins.\nN    LASTPOS:    returns the position of the last occurrence of one\nN                string, needle, in another, haystack.\nN    LEFT:       returns a string of length length, containing the\nN                leftmost length characters of string.\nN    LENGTH:     returns the length of string.\nN    LINESIZE:   returns the current terminal line width minus 1 (the\nN                point at which the language processor breaks lines\nN                displayed using the SAY instruction).\nN    MAX:        returns the largest number from the list specified,\nN                formatted according to the current NUMERIC settings.\nN    MIN:        returns the smallest number from the list specified,\nN                formatted according to the current NUMERIC settings.\nN    OVERLAY:    returns the string target, which, starting at the nth\nN                character, is overlaid with the string new, padded or\nN                truncated to length length.\nN    POS:        returns the position of one string, needle, in another,\nN                haystack.\nN    QUEUED:     returns the number of lines remaining in the external\nN                data queue when the function is called.\nN    RANDOM:     returns a quasi-random nonnegative whole number in the\nN                range min to max inclusive.\nN    REVERSE:    returns string, swapped end for end.\nN    RIGHT:      returns a string of length length containing the\nN                rightmost length characters of string.\nN    SIGN:       returns a number that indicates the sign of number.\nN    SOURCELINE: returns the line number of the final line in the\nN                program OR if you specify n, returns the nth line in\nN                the program if available at the time of execution;\nN                otherwise, returns the null string.\nN    SPACE:      returns the blank-delimited words in string with n\nN                pad characters between each word.\nN    STRIP:      returns string with leading or trailing characters or\nN                both removed, based on the option you specify.\nN    SUBSTR:     returns the substring of string that begins at the nth\nN                character and is of length length, padded with pad if\nN                necessary.\nN    SUBWORD:    returns the substring of string that starts at the nth\nN                word, and is up to length blank-delimited words.\nN    SYMBOL:     returns the state of the symbol named by name.\nN    TIME:       returns the local time in the 24-hour clock format:\nN                hh:mm:ss (hours, minutes, and seconds) by default,\nN                for example, 04:41:37.\nN    TRACE:      returns trace actions currently in effect and,\nN                optionally, alters the setting.\nN    TRANSLATE:  returns string with each character translated to\nN                another character or unchanged.\nN    TRUNC:      returns the integer part of number and n decimal\nN                places.\nN    USERID:     returns the TSO/E user ID, if the REXX exec is running\nN                in the TSO/E address space.\nN    VALUE:      returns the value of the symbol that name (often\nN                constructed dynamically) represents and optionally\nN                assigns it a new value.\nN    VERIFY:     returns a number that, by default, indicates whether\nN                string is composed only of characters from reference;\nN                returns 0 if all characters in string are in\nN                reference, or returns the position of the first\nN                character in string not in reference.\nN    WORD:       returns the nth blank-delimited word in string or\nN                returns the null string if fewer than n words are in\nN                string.\nN    WORDINDEX:  returns the position of the first character in the nth\nN                blank-delimited word in string or returns 0 if fewer\nN                than n words are in string.\nN    WORDLENGTH: returns the length of the nth blank-delimited word in\nN                string or returns 0 if fewer than n words are in\nN                string.\nN    WORDPOS:    returns the word number of the first word of phrase\nN                found in string or returns 0 if phrase contains no\nN                words or if phrase is not found.\nN    WORDS:      returns the number of blank-delimited words in string.\nN    XRANGE:     returns a string of all valid 1-byte encodings (in\nN                ascending order) between and including the values\nN                start and end.\nN    X2B:        returns a string, in character format, that represents\nN                hexstring converted to binary.\nN    X2C:        returns a string, in character format, that represents\nN                hexstring converted to character.\nN    X2D:        returns the decimal representation of hexstring.\nN\nN  TSO/E external functions\nN  ------------------------\nN    GETMSG:     returns a function code that replaces the function\nN                call and retrieves, in variables, a message that has\nN                been issued during a console session.\nN    LISTDSI:    returns one of the following function codes that\nN                replace the function call, and retrieves information\nN                about a data set's allocation, protection, and\nN                directory and stores it in specific variables.\nN    MSG:        MSG returns the value ON or OFF, which indicates the\nN                status of the displaying of TSO/E messages.\nN    MVSVAR:     returns information about MVS, TSO/E, and the current\nN                session, such as the symbolic name of the MVS system,\nN                or the security label of the TSO/E session.\nN    OUTTRAP:    returns the name of the variable in which trapped\nN                output is stored, or if trapping is not in effect,\nN                OUTTRAP returns the word off.\nN    PROMPT:     returns the value ON or OFF, which indicates the\nN                setting of prompting for the exec.\nN    SETLANG:    SETLANG returns a three character code that indicates\nN                the language in which REXX messages are currently\nN                being displayed.\nN    STORAGE:    returns length bytes of data from the specified\nN                address in storage.\nN    SYSCPUS:    places, in a stem variable, information about those\nN                CPUs that are online.\nN    SYSDSN:     returns one of the following messages indicating\nN                whether the specified dsname exists and is available\nN                for use.\nN    SYSVAR:     returns information about MVS, TSO/E, and the current\nN                session, such as levels of software available, your\nN                logon procedure, and your user ID.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0401": {"ttr": 41986, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00N\\x00N\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:05", "lines": 78, "newlines": 78, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0401\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-ABBREV\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175805\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNABBREV\nN-------\nNABBREV returns 1 if info is equal to the leading characters of\nNinformation and the length of info is not less than length. Returns 0\nNif either of these conditions is not met.\nN\nN\nNSyntax:\nD  ABBREV(information,info,length)\nI    information: the complete string. This would be what it needs to\nI                 compared to.\nN\nI    info: This would be what the user entered.\nn\nI    length: the minimum length that must match.\nN\nN\nNExample\nN-------\nNPicture the second parameter is what the user entered in an attempt to\nNselect a print option. The first 1 is a good match. The second 1 is\nNshowing how to default select when no input was provided.\nN\nI  SAY ABBREV(\"Print\",\"Pri\") \"-> 1   \"\nI  SAY ABBREV(\"PRINT\",\"Pri\") \"-> 0   \"\nI  SAY ABBREV(\"PRINT\",\"PRI\",4) \"-> 0 \"\nI  SAY ABBREV(\"PRINT\",\"PRY\") \"-> 0   \"\nI  SAY ABBREV(\"PRINT\",\"\") \"-> 1      \"\nI  SAY ABBREV(\"PRINT\",\"\",1) \"-> 0    \"\nI\nI  debugging_switch = 0\nI  DO WHILE zcmd <> \"quit\"\nI    SAY \"What would you like to do (DEBUG, PRINT, profile, quit)?\"\nI    PARSE PULL zcmd\nI    SELECT\nI      WHEN (ABBREV(\"DEBUG\",ZCMD,1) = 1) THEN DO\nI        IF (debugging_switch = 0) THEN DO\nI          TRACE ?IRS\nI          debugging_switch = 1\nI        END\nI        ELSE DO\nI          debugging_switch = 0\nI          SAY \"Type TRACE O and press enter now.\"\nI        END\nI      END\nI      WHEN (ABBREV(\"PRINT\",ZCMD,1) = 1) THEN DO\nI        subsoutine_rc = print_summary_page()\nI      END\nI      WHEN (ABBREV(\"profile\",ZCMD,3) = 1) THEN DO\nI        subsoutine_rc = profile_edit_rtn()\nI      END\nI      OTHERWISE DO\nI        NOP\nI      END\nI    END\nI  END\nI\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0402": {"ttr": 41988, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00$\\x00$\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:05", "lines": 36, "newlines": 36, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0402\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-ABS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175805\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNABS\nN-------\nNreturns the absolute value of number. The result has no sign and is\nNformatted according to the current NUMERIC settings.Removes the SIGN,\nNturning it neither negative nor positive.\nN\nN\nNSyntax:\nD  ABS(number)\nN\nN\nNExample\nN-------\nI  SAY ABS(\"12.3\") \"-> 12.3\"\nI  SAY ABS(\" -0.307\") \"-> 0.307\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0403": {"ttr": 41990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00*\\x00*\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:06", "lines": 42, "newlines": 42, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0403\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-ADDRESS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175806\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNADDRESS\nN-------\nNreturns the name of the environment to which commands are currently\nNbeing submitted. See the ADDRESS instruction for more information.\nNTrailing blanks are removed from the result.\nN\nNSyntax:\nD  address_str = Address()\nN\nN\nNExample\nN-------\nI  old_env = Address()                           /* Built-in function */\nI  SAY \"The current environment is\" old_env\nI  ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"       /* Instruction */\nI  new_env = Address()                           /* Built-in function */\nI  SAY \"The new environment is\" new_env\nI  ADDRESS TSO                                   /* Instruction */\nI  ADDRESS ISPEXEC\nI  CONTROL ERRORS RETURN\nI  ADDRESS MVS\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0404": {"ttr": 41992, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00B\\x00B\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:06", "lines": 66, "newlines": 66, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0404\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-ARG\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175806\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNARG\nN---\nNreturns an argument string or information about the argument strings\nNto a program or internal routine.\nN\nN\nNSyntax:\nD  ARG(n,option)\nI    n: a number representing which of the ARG() elements you want.\nN\nI    option: EXISTS | OMITTED\nI      exists: returns 1 if the nth argument exists; that is, if it was\nI              explicitly specified when the routine was called. Returns\nI              0 otherwise.\nN\nI     omitted: returns 1 if the nth argument was omitted; that is, if it\nN              was not explicitly specified when the routine was called.\nN              Returns 0 otherwise.\nN\nN\nNExample\nN-------\nI  SAY \"following \"\"tso %rexr0404 'a',,'b'\"\"\"\nI  SAY ARG() \"-> 1\"\nI  SAY ARG(1) \"-> 'a',,'b'\"\nI  SAY ARG(2) \"-> \"\nI  SAY ARG(1,\"e\") \"-> 1\"\nI  SAY ARG(2,\"E\") \"-> 0\"\nI  SAY ARG(2,\"O\") \"-> 1\"\nI  call arg_checker  'a', , 'b'\nI\nI  RETURN 0\nI\nIarg_checker:\nI  SAY \"Run through each argument, of course each exists\"\nI  arg_qty = Arg()                /* Returns the number of arguments */\nI\nI  Do arg_idx = 1 to arg_qty\nI    arg_value.arg_idx = Arg(arg_idx)\nI    uc_arg_value.arg_idx = Upper Arg(arg_idx)\nI    arg_exists.arg_idx = Arg(arg_idx,\"Exists\")\nI    arg_omitted.arg_idx = Arg(arg_idx,\"Omitted\")\nI    Say \"#\"arg_idx\"=\"arg_value.arg_idx \"Exists(\"arg_exists.arg_idx\")\",\nI      \"Omitted(\"arg_omitted.arg_idx\").\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0405": {"ttr": 41994, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00;\\x00;\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:06", "lines": 59, "newlines": 59, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0405\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-BITAND\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175806\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNBITAND\nN-------\nNBITAND returns a string composed of the two input strings logically\nNANDed together, bit by bit. (The encoding of the strings are used in\nNthe logical operation.) The length of the result is the length of the\nNlonger of the two strings. If no pad character is provided, the AND\nMoperation stops when the shorter of the two strings is exhausted, and\nMthe unprocessed portion of the longer string is appended to the\nNpartial result. If pad is provided, it extends the shorter of the two\nNstrings on the right before carrying out the logical operation. The\nNdefault for string2 is the zero length (null) string.\nN\nN\nNSyntax:\nD  BITAND(string1,string2,pad)\nI    string1: Usually the field to be acted upon.\nN\nI    string2: Usually the hexadecimal value you are checking for.\nN\nI    pad: A value to extend short fields with.\nN\nN\nNExample\nN-------\nI  SAY BITAND('12'x) \"->  12 x\"\nI  SAY BITAND('73'x,'27'x) \"->  23 x\"\nI  SAY BITAND('13'x,'5555'x) \"->  1155 x\"\nI  SAY BITAND('13'x,'5555'x,'74'x) \"->  1154 x\"\nI  SAY BITAND('pQrS',,'BF'x) \"->  pqrs  /* EBCDIC */\"\nI\nI  SAY \"\"\nI  a1 = 'B20A00'x\nI  a2 = 'B20C04'x\nI  SAY \"a1=\"C2X(A1)\nI  SAY \"a2=\"C2X(A2)\nI  SAY \"BitAnd(a1,a2)=\"c2x(BitAnd(a1,a2))     /* B20800 */\nI  SAY \"BitOr(a1,a2) =\"c2x(BitOr(a1,a2))      /* B20E04 */\nI  SAY \"BitXor(a1,a2)=\"c2x(BitXor(a1,a2))     /* 000604 */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0406": {"ttr": 41996, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00<\\x00<\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:06", "lines": 60, "newlines": 60, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0406\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-BITOR\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175806\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNBITOR\nN-----\nNBITOR returns a string composed of the two input strings logically\nNinclusive-ORed together, bit by bit. (The encoding of the strings are\nNused in the logical operation.) The length of the result is the length\nNof the longer of the two strings. If no pad character is provided, the\nNOR operation stops when the shorter of the two strings is exhausted,\nNand the unprocessed portion of the longer string is appended to the\nNpartial result. If pad is provided, it extends the shorter of the two\nNstrings on the right before carrying out the logical operation. The\nNdefault for string2 is the zero length (null) string.\nN\nN\nNSyntax:\nD  BITOR(string1,string2 ,pad)\nI    string1: Usually the field to be acted upon.\nN\nI    string2: Usually the hexadecimal value you are checking for.\nN\nI    pad: A value to extend short fields with.\nN\nN\nNExample\nN-------\nI  SAY BITOR('12'x) \"-> '12'x\"\nI  SAY BITOR('15'x,'24'x) \"-> '35'x\"\nI  SAY BITOR('15'x,'2456'x) \"-> '3556'x\"\nI  SAY BITOR('15'x,'2456'x,'F0'x) \"-> '35F6'x\"\nI  SAY BITOR('1111'x,,'4D'x) \"-> '5D5D'x\"\nI  SAY BITOR('Fred',,'40'x) \"-> 'FRED'\"\nI\nI  SAY \"\"\nI  a1 = 'B20A00'x\nI  a2 = 'B20C04'x\nI  SAY \"a1=\"C2X(A1)\nI  SAY \"a2=\"C2X(A2)\nI  SAY \"BitAnd(a1,a2)=\"c2x(BitAnd(a1,a2))     /* B20800 */\nI  SAY \"BitOr(a1,a2) =\"c2x(BitOr(a1,a2))      /* B20E04 */\nI  SAY \"BitXor(a1,a2)=\"c2x(BitXor(a1,a2))     /* 000604 */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0407": {"ttr": 41998, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00=\\x00=\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:07", "lines": 61, "newlines": 61, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0407\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-BITXOR\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175807\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNBITXOR\nN-------\nNBITXOR returns a string composed of the two input strings logically\nNeXclusive-ORed together, bit by bit. (The encoding of the strings are\nNused in the logical operation.) The length of the result is the length\nNof the longer of the two strings. If no pad character is provided, the\nNXOR operation stops when the shorter of the two strings is exhausted,\nNand the unprocessed portion of the longer string is appended to the\nNpartial result. If pad is provided, it extends the shorter of the two\nNstrings on the right before carrying out the logical operation. The\nNdefault for string2 is the zero length (null) string.\nN\nN\nNSyntax:\nD  BITXOR(string1,string2 ,pad)\nI    string1: Usually the field to be acted upon.\nN\nI    string2: Usually the hexadecimal value you are checking for.\nN\nI    pad: A value to extend short fields with.\nN\nN\nNExample\nN-------\nI  SAY BITXOR('12'x) \"->  12 x\"\nI  SAY BITXOR('12'x,'22'x) \"-> '30'x\"\nI  SAY BITXOR('1211'x,'22'x) \"-> '3011'x\"\nI  SAY BITXOR('1111'x,'444444'x) \"-> '555544'x\"\nI  SAY BITXOR('1111'x,'444444'x,'40'x) \"-> '555504'x\"\nI  SAY BITXOR('1111'x,,'4D'x) \"->'35C5C'x\"\nI  SAY BITXOR('C711'x,'222222'x,  1) \"-> 'E53362'x /* EBCDIC */\"\nI\nI  SAY \"\"\nI  a1 = 'B20A00'x\nI  a2 = 'B20C04'x\nI  SAY \"a1=\"C2X(A1)\nI  SAY \"a2=\"C2X(A2)\nI  SAY BitAnd(a1,a2)\"=\"c2x(BitAnd(a1,a2))     /* B20800 */\nI  SAY BitOr(a1,a2) \"=\"c2x(BitOr(a1,a2))      /* B20E04 */\nI  SAY BitXor(a1,a2)\"=\"c2x(BitXor(a1,a2))     /* 000604 */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0408": {"ttr": 42000, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x006\\x006\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:07", "lines": 54, "newlines": 54, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0408\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-B2X\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175807\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNB2X\nN---\nNB2X returns a string, in character format, that represents\nNbinary_string converted to hexadecimal.\nN\nNThe returned string uses uppercase alphabetics for the values A-F,\nNand does not include blanks.\nN\nN\nNSyntax:\nD  B2X(binary_string)\nI    binary_string: The binary_string is a string of binary (0 or 1)\nI    digits. It can be of any length. You can optionally include blanks\nI    in binary_string (at four-digit boundaries only, not leading or\nI    trailing) to aid readability; they are ignored.\nN\nN\nNExample\nN-------\nI  SAY B2X('11000011') \"-> 'C3'\"\nI  SAY B2X('10111') \"-> '17'\"\nI  SAY B2X('101') \"-> '5'\"\nI  SAY B2X('1 1111 0000') \"-> '1F0'\"\nI\nI  hex_val = B2X(11110001)   /* F1 */\nI  bit_str = \"11110001\"\nI  hex_val = B2X(bit_str)\nI  chr_val = X2C(hex_val)\nI  dec_val = C2D(chr_val)\nI  Say \"BIT(\"bit_str\") is\",\nI     \"Hex(\"hex_val\") is\",\nI     \"CHR(\"chr_val\") is\",\nI     \"Dec(\"dec_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0409": {"ttr": 42002, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x006\\x006\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:07", "lines": 54, "newlines": 54, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0409\nKCENTRE\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-CENTER\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175807\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNCENTER\nN-------\nNCENTER returns a string of length length with string centered in it,\nNwith pad characters added as necessary to make up length. The length\nNmust be a positive whole number or zero. The default pad character is\nNblank. If the string is longer than length, it is truncated at both\nNends to fit. If an odd number of characters are truncated or added,\nNthe right-hand end loses or gains one more character than the\nNleft-hand end.\nN\nN\nNSyntax:\nD  CENTER(string,length,pad)\nI    string: Your text.\nN\nI    length: The length the returned string will be.\nN\nI    pad: A character to fill out to length.\nN\nN\nNExample\nN-------\nI  SAY CENTER(abc,7) \"-> ' ABC '\"\nI  SAY CENTER(abc,8,'-') \"-> '--ABC---'\"\nI  SAY CENTER('The blue sky',8) \"-> 'e blue s'\"\nI  SAY CENTER('The blue sky',7) \"-> 'e blue '\"\nI\nI  title_var = Center(\"Report Heading\",79,\" \")\nI  Say title_var\nI\nI  title_var = Centre(\" TOP OF DATA \",79,\"*\")\nI  Say title_var\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0410": {"ttr": 42241, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00>\\x00>\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:07", "lines": 62, "newlines": 62, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0410\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-COMPARE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175807\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNCOMPARE\nN-------\nNCOMPARE returns 0 if the strings, string1 and string2, are identical.\nNOtherwise, returns the position of the first character that does not\nNmatch. The shorter string is padded on the right with pad if necessary.\nNThe default pad character is a blank.\nN\nN\nNSyntax:\nD  COMPARE(string1,string2,pad)\nI    string1: Usually your static string.\nN\nI    string2: Usually the user input string or data field from a file.\nN\nI    pad: a character to match lengths for the shorter field.\nN\nN\nNExample\nN-------\nI  string.1 = \"Kenneth\"\nI  string.2 = \"Kenny       \"\nI  string.3 = \"Kenneth \"\nI\nI  say compare(string.1,string.2)\nI  say compare(string.2,string.1)\nI  say compare(string.3,string.1)\nI\nI  len_string.1 = Length(string.1)\nI  len_string.2 = Length(string.2)\nI  len_string.3 = Length(string.3)\nI  mismatch_pos = compare(string.1,string.2,\"X\")\nI  If (mismatch_pos > 0) THEN DO\nI    Say string.1 \"<>\" string.2\nI    Say Left(Copies(\">\",mismatch_pos)||,\nI      Copies(\" \",len_string.1),len_string.1),\nI      \"  \",\nI      Left(Copies(\">\",mismatch_pos)||,\nI      Copies(\" \",len_string.2),len_string.2)\nI  End\nI  say compare(string.2,string.1,\"X\")\nI  say compare(string.3,string.1,\"X\")\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0411": {"ttr": 42243, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00j\\x00j\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:08", "lines": 106, "newlines": 106, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0411\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-CONDITION\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175808\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNCONDITION\nN-------\nNCONDITION returns the condition information associated with the\nNcurrent trapped condition.\nN\nN\nNSyntax:\nD  CONDITION(option)\nI    option: One of:\nI            Condition name: returns the name of the current trapped\nI                            condition.\nN\nI            Description: returns any descriptive string associated with\nI                         the current trapped condition. If no\nI                         description is available, returns a null\nI                         string.\nN\nI            Instruction: returns either CALL or SIGNAL, the keyword for\nI                         the instruction processed when the current\nI                         condition was trapped.\nI\nI                         This is the default if you omit option.\nN\nI            Status: returns the status of the current trapped\nI                    condition.\nI\nI                    This can change during processing, and is one of:\nI                    ON - the condition is enabled\nI                    OFF - the condition is disabled\nI                    DELAY - any new occurrence of the condition is\nI                            delayed or ignored.\nN\nN\nNExample\nN-------\nI  Say \"\"\nI  Say \"Condition()   -\"CONDITION()\"-> 'CALL' /* perhaps */    \"\nI  Say \"Condition('C')-\"CONDITION('C')\"-> 'FAILURE'               \"\nI  Say \"Condition('I')-\"CONDITION('I')\"-> 'CALL'                  \"\nI  Say \"Condition('D')-\"CONDITION('D')\"-> 'FailureTest'           \"\nI  Say \"Condition('S')-\"CONDITION('S')\"-> 'OFF' /* perhaps */     \"\nI  Say \"\"\nI  Signal ON ERROR   NAME error_rtn\nI  Signal ON Failure NAME failure_rtn\nI  Signal ON Halt    NAME halt_rtn\nI  Signal ON NoValue NAME novalue_rtn\nI  Signal ON SYNTAX  NAME syntax_rtn\nI  Call syntax\nI  Say \"\"\nI  Signal ON ERROR\nI  Signal ON Failure\nI  Signal ON Halt\nI  Signal ON NoValue\nI  Signal ON SYNTAX\nI  x = novalue_var + 3 + A\nI  return 0\nI\nIerror_rtn:\nI  say \"Error_rtn:\"\nIfailure_rtn:\nI  say \"Failure_rtn:\"\nIhalt_rtn:\nI  say \"Halt_rtn:\"\nInovalue_rtn:\nI  say \"NoValue_rtn:\"\nIsyntax_rtn:\nI  say \"Syntax_rtn:\"\nIERROR:\nI  say \"ERROR:\"\nIFAILURE:\nI  say \"FAILURE:\"\nIHALT:\nI  say \"HALT:\"\nINOVALUE:\nI  say \"NOVALUE:\"\nISYNTAX:\nI  say \"SYNTAX:\"\nI  condition_null = CONDITION()\nI  Say \"Condition()   -\"CONDITION_null\nI  Say \"Condition()   -\"CONDITION()\"-> 'CALL' /* perhaps */    \"\nI  Say \"Condition('Condition Name')-\"CONDITION('C')\"-> 'FAILURE' \"\nI  Say \"Condition('Instruction')-\"CONDITION('I')\"-> 'CALL'       \"\nI  Say \"Condition('Description')-\"CONDITION('D')\"-> 'FailureTest'\"\nI  Say \"Condition('Status')-\"CONDITION('S')\"-> 'OFF' /* perhaps */\"\nI  return 0\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0412": {"ttr": 42245, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00&\\x00&\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:08", "lines": 38, "newlines": 38, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0412\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-COPIES\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175808\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNCOPIES\nN-------\nNCOPIES returns n concatenated copies of string. The n must be a\nNpositive whole number or zero.\nN\nN\nNSyntax:\nD  COPIES(string,n)\nI    string: What you want to repeat.\nN\nI    n: How many copies of string you want.\nN\nN\nNExample\nN-------\nI  SAY COPIES('abc',3) \"-> 'abcabcabc'\"\nI  SAY COPIES('abc',0) \"-> ''\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0413": {"ttr": 42247, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00H\\x00H\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:08", "lines": 72, "newlines": 72, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0413\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-C2D\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175808\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNC2D\nN---\nNC2D returns the decimal value of the binary representation of string.\nNIf the result cannot be expressed as a whole number, an error results.\nN\nNThat is, the result must not have more digits than the current setting\nNof NUMERIC DIGITS. If you specify n, it is the length of the returned\nNresult. If you do not specify n, string is processed as an unsigned\nNbinary number.\nN\nNIf string is null, returns 0.\nN\nN\nNSyntax:\nD  C2D(string,n)\nI    string: any character string.\nN\nI    n: maximum length of the returned decimal value.\nN\nN\nNExample\nN-------\nI  SAY \"Examples (simple)\"\nI  SAY \"-----------------\"\nI  SAY C2D('09'X) \"-> 9\"\nI  SAY C2D('81'X) \"-> 129\"\nI  SAY C2D('FF81'X) \"-> 65409\"\nI  SAY C2D('') \"-> 0\"\nI  SAY C2D('a') \"-> 129 /* EBCDIC */\"\nI\nI  SAY \"\"\nI  SAY \"Examples with length\"\nI  SAY \"--------------------\"\nI  SAY C2D('81'X,1) \"-> -127\"\nI  SAY C2D('81'X,2) \"-> 129\"\nI  SAY C2D('FF81'X,2) \"-> -127\"\nI  SAY C2D('FF81'X,1) \"-> -127\"\nI  SAY C2D('FF7F'X,1) \"-> 127\"\nI  SAY C2D('F081'X,2) \"-> -3967\"\nI  SAY C2D('F081'X,1) \"-> -127\"\nI  SAY C2D('0031'X,0) \"-> 0\"\nI\nI  SAY \"\"\nI  bit_str = \"11110001\"          /* F1 */\nI  hex_val = B2X(bit_str)\nI  chr_val = X2C(hex_val)\nI  dec_val = C2D(chr_val)\nI  Say \"BIT(\"bit_str\") is\",\nI     \"Hex(\"hex_val\") is\",\nI     \"CHR(\"chr_val\") is\",\nI     \"Dec(\"dec_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0414": {"ttr": 42249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x007\\x007\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:08", "lines": 55, "newlines": 55, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0414\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-C2X\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175808\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNC2X\nN-------\nNC2X returns a string, in character format, that represents string\nNconverted to hexadecimal. The returned string contains twice as many\nNbytes as the input string. For example, on an EBCDIC system, C2X(1)\nNreturns F1 because the EBCDIC representation of the character 1 is\nN'F1'X. The string returned uses uppercase alphabetics for the values\nNA-F and does not include blanks. The string can be of any length.\nN\nNIf string is null, returns a null string.\nN\nN\nNSyntax:\nD  C2X(string)\nI    string: the character string you want to convert.\nN\nN\nNExample\nN-------\nI  SAY \"Examples (simple)\"\nI  SAY \"-----------------\"\nI  SAY C2X('72s') \"->  F7F2A2  /*  C6F7C6F2C1F2 X in EBCDIC */\"\nI  SAY C2X('0123'X) \"->  0123\"\nI  SAY C2X('0123') \"->  F0F1F2F3\"\nI\nI  say \"\"\nI  bit_str = \"11110001\"          /* F1 */\nI  hex_val = B2X(bit_str)\nI  chr_val = X2C(hex_val)\nI  dec_val = C2D(chr_val)\nI  Say \"BIT(\"bit_str\") is\",\nI    \"Hex(\"hex_val\") is\",\nI    \"CHR(\"chr_val\") is\",\nI    \"Dec(\"dec_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0415": {"ttr": 42251, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00Y\\x00Y\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:09", "lines": 89, "newlines": 89, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0415\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-DATATYPE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175809\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNDATATYPE\nN-------\nN  DATATYPE returns NUM if you specify only string and if string is a\nNvalid REXX number that can be added to 0 without error; returns CHAR\nNif string is not a valid number.\nN\nN\nNSyntax:\nD  DATATYPE(string,type)\nI    string: The string you want to know about.\nN\nI    type: Optional. checking for one of:\nN\nI      Alphanumeric: returns 1 if string contains only characters from\nI                    the ranges a-z, A-Z, and 0-9.\nI      Binary:       returns 1 if string contains only the characters\nI                    0 or 1 or both.\nI      C:            returns 1 if string is a mixed SBCS/DBCS string.\nI      Dbcs:         returns 1 if string is a DBCS-only string enclosed\nI                    by SO and SI bytes.\nI      Lowercase:    returns 1 if string contains only characters from\nI                    the range a-z.\nI      Mixed case:   returns 1 if string contains only characters from\nI                    the ranges a-z and A-Z.\nI      Number:       returns 1 if string is a valid REXX number.\nI      Symbol:       returns 1 if string contains only characters that\nI                    are valid in REXX symbols. Note that both uppercase\nI                    and lowercase alphabetics are permitted.\nI      Uppercase:    returns 1 if string contains only characters from\nI                    the range A-Z.\nI      Whole number: returns 1 if string is a REXX whole number under\nI                    the current setting of NUMERIC DIGITS.\nI      heXadecimal:  returns 1 if string contains only characters from\nI                    the ranges a-f, A-F, 0-9, and blank (as long as\nI                    blanks appear only between pairs of hexadecimal\nI                    characters). Also returns 1 if string is a null\nI                    string, which is a valid hexadecimal string.\nN\nN\nNExample\nN-------\nI  a_string = \"What you want.\"\nI  num_or_char = Datatype(a_string) /* defaults to Char or Num */\nI  SAY a_string \"is\" num_or_char\nI  datatype_rc = Datatype(a_string,\"Alphanumeric\") /* 1 = a-zA-Z0-9 */\nI  datatype_rc = Datatype(a_string,\"Binary\")   /* 1 = 0-1               */\nI  datatype_rc = Datatype(a_string,\"C\")   /* 1 = mixed SBCS/DBCS   */\nI  datatype_rc = Datatype(a_string,\"Dbcs\")   /* 1 = DBCS only        */\nI  datatype_rc = Datatype(a_string,\"Lowercase\")   /* 1 = a-z        */\nI  datatype_rc = Datatype(a_string,\"Mixed case\")   /* 1 = a-zA-Z    */\nI  datatype_rc = Datatype(a_string,\"Number\")   /* 1 = valid rexx # */\nI  datatype_rc = Datatype(a_string,\"Symbol\") /* 1 = valid rexx symbol */\nI  datatype_rc = Datatype(a_string,\"Uppercase\")   /* 1 = A-Z */\nI  datatype_rc = Datatype(a_string,\"Whole number\")/* 1 = Whole number */\nI  datatype_rc = Datatype(a_string,\"Xadecimal\")   /* 1 = 0-F pairs */\nI\nI  Say \"Datatype(' 12 ')->\"Datatype(' 12 ') \"= NUM\"\nI  Say \"Datatype('')    ->\"Datatype('') \"= CHAR\"\nI  Say \"DATATYPE('123*') ->\"DATATYPE('123*') \"= CHAR\"\nI  Say \"DATATYPE('12.3','N') ->\"DATATYPE('12.3','N') \"= 1\"\nI  Say \"DATATYPE('12','W') ->\"DATATYPE('12','W') \"= 1\"\nI  Say \"DATATYPE('12.3','W') ->\"DATATYPE('12.3','W') \"= 0\"\nI  Say \"DATATYPE('Fred','M') ->\"DATATYPE('Fred','M') \"= 1\"\nI  Say \"DATATYPE('','M') ->\"DATATYPE('','M') \"= 0\"\nI  Say \"DATATYPE('Fred','L') ->\"DATATYPE('Fred','L') \"= 0\"\nI  Say \"DATATYPE('?20K','s') ->\"DATATYPE('?20K','s') \"= 1\"\nI  Say \"DATATYPE('BCd3','X') ->\"DATATYPE('BCd3','X') \"= 1\"\nI  Say \"DATATYPE('BC d3','X') ->\"DATATYPE('BC d3','X') \"= 1\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0416": {"ttr": 42253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00\\xa5\\x00\\xa5\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:09", "lines": 165, "newlines": 165, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0416\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-DATE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175809\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNDATE\nN----\nNDATE returns, by default, the local date in the format: dd mon yyyy\nN(day, month, year for example, 25 Dec 2001), with no leading zero or\nNblank on the day. Otherwise, the string input_date is converted to the\nNformat specified by date_format1. date_format2 can be specified to\nNdefine the current format of input_date. The default for date_format1\nNand date_format2 is Normal. input_date must not have a leading zero\nNor blank.\nN\nN\nNSyntax:\nD\nN\nN\nNExample\nN-------\nI  Say \"\"\nI  Say \"Today is:\"\nI  Say \"         \" Date()\nI  Say \"         \" Date(\"B\")\nI  Say \"         \" Date(\"C\")\nI  Say \"         \" Date(\"D\")\nI  Say \"         \" Date(\"E\")\nI  Say \"         \" Date(\"J\")\nI  Say \"         \" Date(\"m\")\nI  Say \"         \" Date(\"n\")\nI  Say \"         \" Date(\"o\")\nI  Say \"         \" Date(\"S\")\nI  Say \"         \" Date(\"u\")\nI  Say \"         \" Date(\"w\")\nI  Say Copies(\"+\",79)\nI  Call show_date \" \"\nI  Call show_date \"\"\nI  Call show_date \"B\"\nI  Call show_date \"C\"\nI  Call show_date \"D\"\nI  Call show_date \"E\"\nI  Call show_date \"J\"\nI  Call show_date \"m\"\nI  Call show_date \"n\"\nI  Call show_date \"o\"\nI  Call show_date \"S\"\nI  Call show_date \"u\"\nI  Call show_date \"w\"\nI  Say Copies(\"+\",79)\nI/*                                                           */\nI  Call show_date '' , '19960527'    , 'S'\nI  Call show_date 'B', '19960527'    , 'S'\nI  Call show_date 'B', Date(\"S\")     , 'S'\nI  Call show_date 'B', '27 May 1996', ''\nI  Call show_date 'N', '35488'       , 'C'\nI  Call show_date 'U', '96/05/27'    , 'O'\nI  Call show_date 'U', '97059'       , 'J'\nI  Say Copies(\"+\",79)\nI  Return 0\nI\nIshow_date: Procedure\nI  a1 = translate(arg(1))\nI  a2 = arg(2)\nI  a3 = translate(arg(3))\nI  Trace off\nI  timestamp = \"\"\nI  fmt = \"show_date failed\"\nI  Signal ON Error\nI  Signal ON Failure\nI  Signal ON Syntax\nI  Select\nI    When (a1 = \"B\") THEN DO\nI      fmt = \"Base -     days since 1 Jan 0001\"\nI    End\nI    When (a1 = \"C\") THEN DO\nI      fmt = \"Century -  days since 1 Jan\" Left(DATE(\"S\"),2)\"00\"\nI    End\nI    When (a1 = \"D\") THEN DO\nI      fmt = \"Days -     days since 1 Jan\" left(Date(\"S\"),4)\nI    End\nI    When (a1 = \"E\") THEN DO\nI      fmt = \"European - dd/mm/yy\"\nI    End\nI    When (a1 = \"J\") THEN DO\nI      fmt = \"Julian -   yyddd (really yr||daysinyear)\"\nI    End\nI    When (a1 = \"M\") THEN DO\nI      fmt = \"Month -    name\"\nI    End\nI    When (a1 = \"N\") THEN DO\nI      fmt = \"Normal -   dd mon yyyy (the default)\"\nI    End\nI    When (a1 = \" \") THEN DO\nI      a1 = \"N\"\nI      fmt = \"Normal -   dd mon yyyy (the default)\"\nI    End\nI    When (a1 = \"O\") THEN DO\nI      fmt = \"Ordered -  yy/mm/dd\"\nI    End\nI    When (a1 = \"S\") THEN DO\nI      fmt = \"Standard - yyyymmdd\"\nI    End\nI    When (a1 = \"U\") THEN DO\nI      fmt = \"USA -      mm/dd/yy\"\nI    End\nI    When (a1 = \"W\") THEN DO\nI      fmt = \"Weekday -  name\"\nI    End\nI    Otherwise DO\nI      Say \"Please update CODE to handle\" a1\".\"\nI      Return 12\nI    End\nI  End\nI  Select\nI    When (a3 >< \"\") THEN DO\nI      timestamp = Date(a1,a2,a3)\nI    End\nI    When (a2 >< \"\") THEN DO\nI      timestamp = Date(a1,a2)\nI    End\nI    Otherwise DO\nI      timestamp = Date(a1)\nI    End\nI  End\nI  Say left(\"Date(\"a1\",\"a2\",\"a3\") =\",23) left(timestamp,11) left(fmt,43)\nI  Signal noerror\nI\nIerror:\nI  Signal OFF Error\nI  Say \"An error occurred at\" sigl\nI  Say SOURCELINE(sigl)\nI  Signal noerror\nIfailure:\nI  Signal OFF Failure\nI  Say \"A failure occurred at\" sigl\nI  Say SOURCELINE(sigl)\nI  Signal noerror\nIsyntax:\nI  Signal OFF Syntax\nI  Say \"A syntax occurred at\" sigl\nI  Say SOURCELINE(sigl)\nI  Signal noerror\nInoerror:\nI  Signal OFF Syntax\nI  Signal OFF Failure\nI  Signal OFF Error\nI  Return\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0417": {"ttr": 42497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:09", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0417\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-DELSTR\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175809\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNDELSTR\nN-------\nNDELSTR returns string after deleting the substring that begins at the\nNnth character and is of length characters. If you omit length, or if\nNlength is greater than the number of characters from n to the end of\nNstring, the function deletes the rest of string (including the nth\nNcharacter). The length must be a positive whole number or zero. The n\nNmust be a positive whole number. If n is greater than the length of\nNstring, the function returns string unchanged.\nN\nN\nNSyntax:\nD  DELSTR(string,n,length)\nI    string: What you want to act upon.\nN\nI    n: The starting position.\nN\nI    length: How much to delete. Omit this and it truncates to the end.\nN\nN\nNExample\nN-------\nI  del_string = \" has\"\nI  del_length = Length(del_string)\nI  old_sentence = \"This sentence has had an error in it.\"\nI  del_position = Pos(del_string,old_sentence)\nI  If (del_position > 0) Then do\nI    new_sentence = DelStr(old_sentence,del_position,del_length)\nI    Say old_sentence\nI    Say new_sentence\nI    say \"Without a length it chops out the end.\"\nI    new_sentence = DelStr(old_sentence,del_position)\nI    Say old_sentence\nI    Say new_sentence\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0418": {"ttr": 42499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00G\\x00G\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:09", "lines": 71, "newlines": 71, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0418\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-DELWORD\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175809\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNDELWORD\nN-------\nNDELWORD returns string after deleting the substring that starts at the\nNnth word and is of length blank-delimited words. If you omit length,\nNor if length is greater than the number of words from n to the end of\nNstring, the function deletes the remaining words in string (including\nNthe nth word). The length must be a positive whole number or zero. The\nNn must be a positive whole number. If n is greater than the number of\nNwords in string, the function returns string unchanged. The string\nNdeleted includes any blanks following the final word involved but none\nNof the blanks preceding the first word involved.\nN\nN\nNSyntax:\nD  DELWORD(string,n,length)\nI    string: The data you want to act upon.\nN\nI    n: The WORDPOS() to start at.\nN\nI    length: The number of words to delete.\nN\nN\nNExample\nN-------\nI  SAY \"FIRST LET ME SHOW YOU DELSTR, THEN DELWORD.\"\nI  Say \"DelStr\"\nI  del_string = \"has\"\nI  del_length = Length(del_string)\nI  old_sentence = \"This sentence had has an error in it.\"\nI  new_sentence = old_sentence\nI  del_position = Pos(del_string,old_sentence)\nI  If (del_position > 0) Then DO\nI    new_sentence = DelStr(old_sentence,del_position,del_length)\nI  End\nI  Say old_sentence\nI  Say new_sentence\nI  Say \"Note the extra space that is left behind.\"\nI  Say \"\"\nI\nI  Say \"DelWord\"\nI  del_string = \"has\"\nI  del_length = Words(del_string)\nI  old_sentence = \"This sentence had has an error in it.\"\nI  new_sentence = old_sentence\nI  del_position = WordPos(del_string,old_sentence)\nI  If (del_position > 0) Then DO\nI    new_sentence = DelWord(old_sentence,del_position,del_length)\nI  End\nI  Say old_sentence\nI  Say new_sentence\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0419": {"ttr": 42501, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:10", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0419\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-DIGITS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175810\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNDIGITS\nN-------\nNDIGITS returns the current setting of NUMERIC DIGITS. See the NUMERIC\nNinstruction for more information.\nN\nN\nNSyntax:\nD  DIGITS()\nN\nN\nNExample\nN-------\nI  SAY DIGITS() \"-> 9\"\nI  NUM_DIGITS = DIGITS()\nI  IF (num_digits < 12) THEN DO\nI    SAY \"Raising NUMERIC DIGITS to 12.\"\nI    NUMERIC DIGITS 12\nI  END\nI  SAY DIGITS() \"-> 12\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0420": {"ttr": 42503, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x001\\x001\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:10", "lines": 49, "newlines": 49, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0420\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-D2C\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175810\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nND2C\nN---\nND2C returns a string, in character format, that represents wholenumber,\nNa decimal number, converted to binary. If you specify n, it is the\nNlength of the final result in characters; after conversion, the input\nNstring is sign-extended to the required length. If the number is too\nNbig to fit into n characters, then the result is truncated on the left.\nNThe n must be a positive whole number or zero.\nN\nN\nNSyntax:\nD  D2C(wholenumber,n)\nI    wholenumber: The relative position of the character. From 1 to 256.\nN\nI    n: Pad to length of n.\nN\nN\nNExample\nN-------\nI  bit_str = \"11110001\"\nI  hex_val = B2X(bit_str)\nI  chr_val = X2C(hex_val)\nI  dec_val = C2D(chr_val)\nI  chr_val = D2C(dec_val)\nI  Say \"BIT(\"bit_str\") is\",\nI     \"Hex(\"hex_val\") is\",\nI     \"CHR(\"chr_val\") is\",\nI     \"Dec(\"dec_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0421": {"ttr": 42505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x003\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:10", "lines": 51, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0421\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-D2X\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175810\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nND2X\nN---\nND2X returns a string, in hexadecimal format, that represents\nNwholenumber, a decimal number, converted to binary. If you specify n,\nNit is the length of the final result in characters; after conversion,\nNthe input string is sign-extended to the required length. If the number\nNis too big to fit into n characters, then the result is truncated on\nNthe left.\nN\nNThe n must be a positive whole number or zero.\nN\nN\nNSyntax:\nD  D2X(wholenumber,n)\nI    wholenumber: The relative position of the character. From 1 to 256.\nN\nI    n: Pad to length of n.\nN\nN\nNExample\nN-------\nI  bit_str = \"11110001\"\nI  hex_val = B2X(bit_str)\nI  chr_val = X2C(hex_val)\nI  dec_val = C2D(chr_val)\nI  hex_val = D2X(dec_val)\nI  Say \"BIT(\"bit_str\") is\",\nI     \"Hex(\"hex_val\") is\",\nI     \"CHR(\"chr_val\") is\",\nI     \"Dec(\"dec_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0422": {"ttr": 42507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00=\\x00=\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:10", "lines": 61, "newlines": 61, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0422\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-ERRORTEXT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175810\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNERRORTEXT\nN-------\nNERRORTEXT returns the REXX error message associated with error number\nNn. The n must be in the range 0-99, and any other value is an error.\nNReturns the null string if n is in the allowed range but is not a\nNdefined REXX error number.\nN\nNError numbers produced by syntax errors during processing of REXX\nNexecs correspond to TSO/E REXX messages (described in z/OS TSO/E\nNMessages.) For example, error 26 corresponds to message number\nNIRX0026I. The error number is also the value that is placed in the\nNREXX special variable RC when SIGNAL ON SYNTAX event is trapped.\nN\nN\nNSyntax:\nD  ERRORTEXT(n)\nI    n: A wholenumber for the REXX error message.\nN\nN\nNExample\nN-------\nI  displayed_ctr = 0\nI  Say \"Interpreter error messages\"\nI  Say \"--------------------------\"\nI  Do errortext_idx = 0 to 99 By 1\nI    errortext_msg = errortext(errortext_idx)\nI    If (errortext_msg <> \"\") Then DO\nI      Say Right(errortext_idx,2) errortext_msg\nI      displayed_ctr = displayed_ctr + 1\nI    End\nI    If (displayed_ctr > 0) Then DO\nI      If ((displayed_ctr // 20) = 0) Then DO\nI        Say \"\"\nI        Say \"Press enter to continue:\"\nI        pull terminal_response\nI        Say \"Interpreter error messages\"\nI        Say \"--------------------------\"\nI      End\nI    End\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0423": {"ttr": 42509, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00&\\x00&\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:11", "lines": 38, "newlines": 38, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0423\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-EXTERNALS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175811\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNEXTERNALS\nN-------\nNEXTERNALS is a non-SAA built-in function provided only by TSO/E and VM.\nN\nNThe EXTERNALS function returns the number of elements in the terminal\nNinput buffer (system external event queue). In TSO/E, there is no\nNequivalent buffer. Therefore, in the TSO/E implementation of REXX,\nNthe EXTERNALS function always returns a 0.\nN\nN\nNSyntax:\nD  Externals()\nN\nN\nNExample\nN-------\nI  number_of_elements = Externals()   /* Always returns 0 under TSO/E */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0424": {"ttr": 42511, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00/\\x00/\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:11", "lines": 47, "newlines": 47, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0424\nKWORDPOS\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-FIND\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175811\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNFIND\nN-------\nNFIND is a non-SAA built-in function provided only by TSO/E and VM.\nN\nMWORDPOS is the preferred built-in function for a word search.\nN\nNreturns the word number of the first word of phrase found in string or\nNreturns 0 if phrase is not found or if there are no words in phrase.\nNThe phrase is a sequence of blank-delimited words. Multiple blanks\nNbetween words in phrase or string are treated as a single blank for\nNthe comparison.\nN\nNSyntax:\nD  FIND(string,phrase)\nI    string: The text to search.\nN\nI    phrase: The text to find.\nN\nN\nNExample\nN-------\nI  Say \"Find()\"\nI  phrase_to_find = \"has\"\nI  original_string = \"This sentence has had an error in it.\"\nI  word_position = Find(original_string,phrase_to_find)\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0425": {"ttr": 42513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00$\\x00$\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:11", "lines": 36, "newlines": 36, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0425\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-FORM\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175811\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNFORM\nN----\nNFORM returns the current setting of NUMERIC FORM. See the NUMERIC\nNinstruction for more information.\nN\nN\nNSyntax:\nD  FORM()\nN\nN\nNExample\nN-------\nI  SAY \"FORM()\"\nI  current_form = Form()\nI  SAY \"The current form is\" current_form\".\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0426": {"ttr": 42515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00Y\\x00Y\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:12", "lines": 89, "newlines": 89, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0426\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-FORMAT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175811\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNFORMAT\nN------\nNFORMAT returns number, rounded and formatted.\nN\nN\nNSyntax:\nD  Format(number,before,after,expp,expt)\nI    number: The number is first rounded according to standard REXX\nI            rules, just as though the operation number+0 had been\nI            carried out. The result is precisely that of this operation\nI            if you specify only number.\nN\nI    before,after: The before and after options describe how many\nI                  characters are used for the integer and decimal\nI                  parts of the result, respectively. If you omit\nI                  either or both of these, the number of characters\nI                  used for that part is as needed.\nN\nI                  If before is not large enough to contain the integer\nI                  part of the number (plus the sign for a negative\nI                  number), an error results. If before is larger than\nI                  needed for that part, the number is padded on the\nI                  left with blanks. If after is not the same size as\nI                  the decimal part of the number, the number is rounded\nI                  (or extended with zeros) to fit.\nN\nI                  Specifying 0 causes the number to be rounded to an\nI                  integer.\nN\nI    expp,expt: In addition, expp and expt control the exponent part of\nI               the result, which, by default, is formatted according\nI               to the current NUMERIC settings of DIGITS and FORM. The\nI               expp sets the number of places for the exponent part;\nI               the default is to use as many as needed (which may be\nI               zero). The expt sets the trigger point for use of\nI               exponential notation. The default is the current setting\nI               of NUMERIC DIGITS.\nN\nN\nNExample\nN-------\nI  SAY \"Loosely format a numeric field.\"\nI  formatted_number = Format(unformatted_number,before,after,expp,expt)\nI/* 1st it rounds = (unformatted_number + 0)                          */\nI/* 2nd it formats based on before and after                          */\nI/* 3rd it formats the result based on NUMERIC, DIGITS, and FORM      */\nI/*   expp = positions for decimal in exponential notation            */\nI/*   expt = trigger for exponential notation                         */\nI\nI  unformatted_number = -0012.730\nI  formatted_number = Format(unformatted_number,4,2,,2)\nI  Say unformatted_number \"becomes\" formatted_number\".\"\nI\nI  Say  \"'3',4            =\" FORMAT('3',4)            \"-> '    3'\"\nI  Say  \"'1.73',4,0       =\" FORMAT('1.73',4,0)       \"-> '    2'\"\nI  Say  \"'1.73',4,3       =\" FORMAT('1.73',4,3)       \"-> '    1.730'\"\nI  Say  \"'-.76',4,1       =\" FORMAT('-.76',4,1)       \"-> '   -0.8'\"\nI  Say  \"'3.03',4         =\" FORMAT('3.03',4)         \"-> '    3.03'\"\nI  Say  \"' - 12.73'       =\" FORMAT(' - 12.73')       \"-> ' -12.73'\"\nI  Say  \"' - 12.73',,4    =\" FORMAT(' - 12.73',,4)    \"-> ' -12.7300'\"\nI  Say  \"'0.000'          =\" FORMAT('0.000')          \"-> '0'\"\nI  Say  \"'0.000',2        =\" FORMAT('0.000',2)        \"-> '0'\"\nI  Say  \"'0.000',,2       =\" FORMAT('0.000',,2)       \"-> '0.00'\"\nI  Say  \"'12345.73',,,2,2 =\" FORMAT('12345.73',,,2,2) \"-> '1.234573E+04'\"\nI  Say  \"'12345.73',,3,,0 =\" FORMAT('12345.73',,3,,0) \"-> '1.235E+4'\"\nI  Say  \"'1.234573',,3,,0 =\" FORMAT('1.234573',,3,,0) \"-> '1.235'\"\nI  Say  \"'12345.73',,,3,6 =\" FORMAT('12345.73',,,3,6) \"-> '12345.73'\"\nI  Say  \"'1234567e5',,3,0 =\" FORMAT('1234567e5',,3,0) \"-> '123456700000.000'\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0427": {"ttr": 42753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00#\\x00#\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:12", "lines": 35, "newlines": 35, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0427\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-FUZZ\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175812\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNFUZZ\nN----\nNreturns the current setting of NUMERIC FUZZ. See the NUMERIC\nNinstruction for more information.\nN\nN\nNSyntax:\nD  FUZZ()\nN\nN\nNExample\nN-------\nI  current_fuzz = FUZZ()\nI  SAY \"The current FUZZ is\" current_fuzz\".\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0428": {"ttr": 42755, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x000\\x000\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:12", "lines": 48, "newlines": 48, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0428\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-INDEX\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175812\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNINDEX\nN-----\nNINDEX is a non-SAA built-in function provided only by TSO/E and VM.\nN\nNPOS is the preferred built-in function for finding a position of\nNa needle in a haystack.\nN\nN\nNSyntax:\nD  INDEX(haystack,needle,start)\nI    haystack: The text to search.\nN\nI    needle: The string to find.\nN\nI    start: Where to start the search.\nN\nN\nNExample\nN-------\nI  needle_value = \"needle\"\nI  needle_length= Length(needle_value)\nI  haystack_value = \"Find the needle in the haystack.\"\nI  needle_position = Index(haystack_value,needle_value) - 1\nI  Say haystack_value\nI  If (needle_position > -1) Then DO\nI    Say Copies(\" \",needle_position)Copies(\"-\",needle_length)\nI  END\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0429": {"ttr": 42757, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00A\\x00A\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:12", "lines": 65, "newlines": 65, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0429\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-INSERT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175812\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNINSERT\nN-------\nNINSERT inserts the string new, padded or truncated to length length,\nNinto the string target after the nth character. The default value for\nNn is 0, which means insert before the beginning of the string. If\nNspecified, n and length must be positive whole numbers or zero. If n\nNis greater than the length of the target string, padding is added\nNbefore the string new also. The default value for length is the length\nNof new. If length is less than the length of the string new, then\nNINSERT truncates new to length length. The default pad character is a\nNblank.\nN\nN\nNSyntax:\nD  INSERT(new,target,n ,length ,pad)\nI    new: What you want to add.\nN\nI    target: The string being modified.\nN\nI    n: The position where the insert takes place.\nN\nI    length: Ideally, the length of new.\nN\nI    pad: A character to add if length is larger than the length of new.\nN\nN\nNExample\nN-------\nI  new_string = \"what you want to add \"\nI  old_haystack = \"This might be in a string.\"\nI  string_pos = Pos(\"be\",old_haystack) + 2\nI  len_str = Length(new_string)\nI  pad = \" \"\nI  new_haystack = Insert(new_string,old_haystack,string_pos,len_str,pad)\nI  Say new_haystack\nI/* This might be what you want to add in a string.                   */\nI\nI\nI  needle_value = \"needle\"\nI  needle_length= Length(needle_value)\nI  old_haystack = \"Find the in the haystack.\"\nI  new_haystack = Insert(needle_value,old_haystack,9,7,\" \")\nI  Say old_haystack\nI  Say new_haystack\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0430": {"ttr": 42759, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00B\\x00B\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:13", "lines": 66, "newlines": 66, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0430\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-JUSTIFY\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175813\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNJUSTIFY\nN-------\nNJUSTIFY is a non-SAA built-in function provided only by TSO/E and VM.\nN\nNreturns string formatted by adding pad characters between\nNblank-delimited words to justify to both margins. This is done to\nNwidth length (length must be a positive whole number or zero). The\nNdefault pad character is a blank.\nN\nNIn word processing you have left align, fill, and right align. This\nNadds spaces to fill the line so you have words reaching from the left\nNhand margin to the right hand margin.\nN\nNSyntax:\nD  JUSTIFY(string,length,pad)\nI    string: The text to act upon.\nN\nI    length: How wide your line is.\nN\nI    pad: A character to fill between words.\nN\nN\nNExample\nN-------\nI  old_string = \"The quick brown fox jumped over the lazy dog.\"\nI  old_length = Length(old_string)\nI  new_string = Justify(old_string,79,\" \")\nI  new_length = Length(new_string)\nI  Say Left(Copies(\"....+....0\",8),79)\nI  Say old_string\nI  swp_rc =  show_word_pos(old_string)\nI  Say \"\"\nI  Say Left(Copies(\"....+....0\",8),79)\nI  Say new_string\nI  swp_rc =  show_word_pos(new_string)\nI  RETURN 0\nI\nIshow_word_pos: Procedure\nI  arg_value = Arg(1)\nI  Do word_idx = 1 to Words(arg_value)\nI    one_word = Word(arg_value,word_idx)\nI    Say \"Word(\"one_word\")\",\nI      \"Pos(\"Pos(one_word,arg_value)\")\"\nI  End\nI  Return word_idx\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0431": {"ttr": 42761, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00?\\x00?\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:13", "lines": 63, "newlines": 63, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0431\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-LASTPOS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175813\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNLASTPOS\nN-------\nNLASTPOS returns the position of the last occurrence of one string,\nNneedle, in another, haystack. (See also the POS function.) Returns 0\nNif needle is the null string or is not found. By default the search\nNstarts at the last character of haystack and scans backward. You can\nNoverride this by specifying start, the point at which the backward\nNscan starts. start must be a positive whole number and defaults to\nNLENGTH(haystack) if larger than that value or omitted.\nN\nN\nNSyntax:\nD  LASTPOS(needle,haystack,start)\nI    needle: What you are searching for.\nN\nI    haystack: The string to search.\nN\nI    start: How far from the end to begin searching.\nN\nN\nNExample\nN-------\nI  path_filename = \"/usr/lpp/java/J6.0_64/bin/java.exe\"\nI  last_slash = LastPos(\"/\",path_filename)\nI  Parse Var path_filename,\nI    path_directories +(last_slash),\nI    just_filename .\nI  Say just_filename \"is in\" path_directories\".\"\nI\nI  full_dsname = \"SYS1.TCPIP.SEZALINK\"\nI  last_period = LastPos(\".\",full_dsname)\nI  Parse Var full_dsname,\nI    dsn_prefix +(last_period),\nI    just_llq .\nI  Say just_llq \"is found under\" dsn_prefix\".\"\nI\nI  SAY LASTPOS(' ','abc def ghi') \"-> 8\"\nI  SAY LASTPOS(' ','abcdefghi') \"-> 0\"\nI  SAY LASTPOS('xy','efgxyz') \"-> 4\"\nI  SAY LASTPOS(' ','abc def ghi') \"-> 8\" /* SEARCH FROM a */\nI  SAY LASTPOS(' ','abc def ghi',5) \"-> 4\" /* SEARCH FROM f */\nI  SAY LASTPOS(' ','abc def ghi',7) \"-> 4\" /* SEARCH FROM d */\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0432": {"ttr": 42763, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:13", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0432\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-LEFT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175813\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNLEFT\nN----\nNLEFT returns a string of length length, containing the leftmost length\nNcharacters of string. The string returned is padded with pad characters\nN(or truncated) on the right as needed. The default pad character is a\nNblank. Length must be a positive whole number or zero.\nN\nN\nNSyntax:\nD  LEFT(string,length,pad)\nI    string: The string to act upon.\nN\nI    length: How many characters to copy.\nN\nI    pad: A character used to fill to length.\nN\nN\nNExample\nN-------\nI  sort_date = Date(\"S\")\nI  yyyy = Left(sort_date,4)\nI  Say \"The current year is\" yyyy\".\"\nI\nI  Do loop_ctr = 1 To 100 By 15\nI    Say Left(loop_ctr,3) \"x 5 =\" (loop_ctr * 5)\".\"\nI  End\nI\nI  SAY LEFT('abc d',8) \"-> 'abc d '\"\nI  SAY LEFT('abc d',8,'.') \"-> 'abc d...'\"\nI  SAY LEFT('abc def',7) \"-> 'abc de'\"\n*  End of wish.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0433": {"ttr": 42765, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x000\\x000\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:13", "lines": 48, "newlines": 48, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0433\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-LENGTH\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175813\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNLENGTH\nN-------\nNLENGTH returns the length of string.\nN\nN\nNSyntax:\nD  LENGTH(string)\nI    string: What it is that you want to measure.\nN\nN\nNExample\nN-------\nI  y=\"\"\nI  Do i=1 to 7\nI    y = y||Copies(\" \",9)||i\nI  End i\nI  Say y\nI  Say Left(Copies(\"....+....0\",8),79)\nI  var_value = \"This is data in a variable. But how long is it?\"\nI  var_length = Length(var_value)\nI  Say var_value \"(\"var_length\")\"\nI\nI  var_length = Length(15 ** 25)\nI  Say (15 ** 25) \"(\"var_length\")\"\nI  NUMERIC DIGITS 33\nI  var_length = Length(15 ** 25)\nI  Say (15 ** 25) \"(\"var_length\")\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0434": {"ttr": 42767, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x001\\x001\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:14", "lines": 49, "newlines": 49, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0434\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-LINESIZE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175814\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNLINESIZE\nN--------\nNLINESIZE is a non-SAA built-in function provided only by TSO/E and VM.\nN\nNLINESIZE returns the current terminal line width minus 1 (the point at\nNwhich the language processor breaks lines displayed using the SAY\nNinstruction).\nN\nNIf the REXX exec is running in TSO/E background (that is, on the\nNJCL EXEC statement PGM=IKJEFT01), LINESIZE always returns the\nNvalue 131. If the REXX exec is running in TSO/E foreground, the\nNLINESIZE function always returns the current terminal width (as\nNdefined by the TSO/E TERMINAL command) minus one character.\nN\nNIf the exec is running in a non-TSO/E address space, LINESIZE returns\nNthe logical record length of the OUTDD file (the default file is\nNSYSTSPRT).\nN\nN\nNSyntax:\nD  LINESIZE()\nN\nN\nNExample\nN-------\nI  terminal_linesize = LineSize()\nI  Say \"REXX can write\" terminal_linesize \"characters before wrapping.\"\nI  Say \"Basically, position 1 is reserved. In batch it will be 131.\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0435": {"ttr": 42769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00E\\x00E\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:14", "lines": 69, "newlines": 69, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0435\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-MAX\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175814\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNMAX\nN-------\nNMAX returns the largest number from the list specified, formatted\nNaccording to the current NUMERIC settings.\nN\nNYou can specify up to 20 values in Max. But you can nest Max if\nNyou have more. I would probably just check as I went along.\nN\nN  highest_value = Max(Max(1,2,3),Max(4,5,6,7),Max(8,9,10,11,12,13))\nM  The first Max() has three values.\nM  The first nested Max() has three values.\nM  The second nested Max() has four values.\nM  The three nested Max() has SIX values.\nM  By nesting you can string as many nested Max() built-in functions\nM  as you need to evaluate.\nN\nN\nNSyntax:\nD  MAX(number,number,...)\nN\nN\nNExample\nN-------\nI  largest_value = 0\nI  smallest_value = 99990\nI  num_array. = 0\nI  Do i = 1 To 435 By 17\nI    num_array.i = i / 43\nI    largest_value = Max(num_array.i, largest_value)\nI    smallest_value = Min(num_array.i, smallest_value)\nI  End\nI  Say \"The largest  value is\" largest_value\".\"\nI  Say \"The smallest value is\" smallest_value\".\"\nI\nI  I have long used a simple IF to accomplish the same thing.\nI\nI  largest_value = 0\nI  Do i = 1 To 435 By 17\nI    num_array.i = i / 43\nI    If (num_array.i > largest_value) Then,\nI      largest_value = num_array.i\nI  End\nI  Say \"The largest  value is\" largest_value\".\"\nI\nI  SAY MAX(12,6,7,9) \"-> 12\"\nI  SAY MAX(17.3,19,17.03) \"-> 19\"\nI  SAY MAX(-7,-3,-4.3) \"-> -3\"\nI  SAY MAX(1,2,3,4,5,6,7,8,9,10,11,16,17,18,19,MAX(20,21)) \"-> 21\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0436": {"ttr": 43009, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00E\\x00E\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:14", "lines": 69, "newlines": 69, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0436\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-MIN\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175814\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNMIN\nN-------\nNMIN returns the smallest number from the list specified, formatted\nNaccording to the current NUMERIC settings.\nN\nNYou can specify up to 20 values in MIN. But you can nest MIN if\nNyou have more. I would probably just check as I went along.\nN\nN  highest_value = MIN(MIN(1,2,3),MIN(4,5,6,7),MIN(8,9,10,11,12,13))\nM  The first MIN() has three values.\nM  The first nested MIN() has three values.\nM  The second nested MIN() has four values.\nM  The third nested MIN() has SIX values.\nM  By nesting you can string as many nested MIN() built-in functions\nM  as you need to evaluate.\nN\nN\nNSyntax:\nD  MIN(number,number,...)\nN\nN\nNExample\nN-------\nI  largest_value = 0\nI  smallest_value = 99990\nI  num_array. = 0\nI  Do i = 1 To 435 By 17\nI    num_array.i = i / 43\nI    largest_value = Max(num_array.i, largest_value)\nI    smallest_value = Min(num_array.i, smallest_value)\nI  End\nI  Say \"The largest  value is\" largest_value\".\"\nI  Say \"The smallest value is\" smallest_value\".\"\nI\nI  SAY \"I have long used a simple IF to accomplish the same thing.\"\nI\nI  smallest_value = 999\nI  Do i = 1 To 435 By 17\nI    num_array.i = i / 43\nI    If (num_array.i < smallest_value) Then,\nI      smallest_value = num_array.i\nI  End\nI  Say \"The smallest value is\" smallest_value\".\"\nI\nI  SAY MIN(12,6,7,9) \"-> 6\"\nI  SAY MIN(17.3,19,17.03) \"-> 17.03\"\nI  SAY MIN(-7,-3,-4.3) \"-> -7\"\nI  SAY MIN(1,2,3,4,5,6,7,8,9,10,11,16,17,18,19,MIN(20,21)) \"-> 1\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0437": {"ttr": 43011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00K\\x00K\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:14", "lines": 75, "newlines": 75, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0437\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-OVERLAY\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175814\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNOVERLAY\nN-------\nNOVERLAY returns the string target, which, starting at the nth\nNcharacter, is overlaid with the string new, padded or truncated to\nNlength length. (The overlay may extend beyond the end of the original\nNtarget string.) If you specify length, it must be a positive whole\nNnumber or zero. The default value for length is the length of new. If\nNn is greater than the length of the target string, padding is added\nNbefore the new string. The default pad character is a blank, and the\nNdefault value for n is 1. If you specify n, it must be a positive whole\nNnumber.\nN\nN\nNSyntax:\nD  OVERLAY(new,target,n ,length ,pad)\nI    new: Your new text.\nN\nI  target: the larger string that will be overlayed to produce a new\nI          string.\nN\nI    n: The starting position to overlay.\nN\nI length: How long the new string is.\nN\nI    pad: A character to pad if length is greater than length(new).\nN\nN\nNExample\nN-------\nI  page_ctr = 1\nI  heading_line = Center(\"My REXX Program\",79)\nI  week_day = Date(\"W\")\nI  report_line.1 = Overlay(week_day,heading_line,5)\nI  report_line.1 = Overlay(\"Page\",report_line.1,65)\nI  Call Print_Heading\nI  Do report_ctr = 1 To 22\nI    If ((report_ctr // 5) = 0) Then Call Print_Heading\nI    Say report_ctr \"just some data\"\nI  End\nI\nI  SAY \"\"\nI  SAY OVERLAY(' ','abcdef',3) \"->  ab def\"\nI  SAY OVERLAY('.','abcdef',3,2) \"->  ab. ef\"\nI  SAY OVERLAY('qq','abcd') \"->  qqcd\"\nI  SAY OVERLAY('qq','abcd',4) \"->  abcqq\"\nI  SAY OVERLAY('123','abc',5,6,'+') \"->  abc+123+++\"\nI  Return 0\nI\nIPrint_Heading:\nI  If (report_ctr = 22) Then Return 0\nI  report_line.1 = Overlay(page_ctr,report_line.1,70)\nI  Say report_line.1\nI  page_ctr = page_ctr + 1\nI  RETURN 0\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0438": {"ttr": 43013, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00A\\x00A\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:15", "lines": 65, "newlines": 65, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0438\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-POS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175815\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNPOS\nN---\nNPOS returns the position of one string, needle, in another, haystack.\nn(See also the INDEX and LASTPOS functions.) Returns 0 if needle is the\nnnull string or is not found or if start is greater than the length of\nnhaystack. By default the search starts at the first character of\nnHaystack (that is, the value of start is 1). You can override this by\nnspecifying start (which must be a positive whole number), the point at\nnwhich the search starts.\nN\nN\nNSyntax:\nD  POS(needle,haystack,start)\nI    needle: The string to find.\nN\nI    haystak: The string to search.\nN\nI    start: Optional location to begin searching from.\nN\nN\nNExample\nN-------\nI  needle_value = \"needle\"\nI  needle_length= Length(needle_value)\nI  haystack_value = \"Find the needle in the haystack.\"\nI  needle_position = Pos(needle_value,haystack_value) - 1\nI  Say haystack_value\nI  If (needle_position > -1) Then,\nI    Say Copies(\" \",needle_position)Copies(\"-\",needle_length)\nI\nI  say \"Want to convert a dataset name to a HFS structure?\"\nI  full_dsname = \"USR.LPP.JAVA.J6_0_64.BIN\"\nI  Say full_dsname\nI  needle_position = Pos(\".\",full_dsname,1)\nI  Do While needle_position > 0\nI    full_dsname = Overlay(\"/\",full_dsname,needle_position,1)\nI    needle_position = Pos(\".\",full_dsname,needle_position)\nI  End\nI  Say full_dsname\nI\nI  SAY POS('day','Saturday') \"-> 6\"\nI  SAY POS('x','abc def ghi') \"-> 0\"\nI  SAY POS(' ','abc def ghi') \"-> 4\"\nI  SAY POS(' ','abc def ghi',5) \"-> 8\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0439": {"ttr": 43015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x006\\x006\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:15", "lines": 54, "newlines": 54, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0439\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-QUEUED\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175815\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNQUEUED\nN-------\nNQUEUED returns the number of lines remaining in the external data queue\nNwhen the function is called.\nN\nNThe TSO/E implementation of the external data queue is the data stack.\nN\nN\nNSyntax:\nD  QUEUED()\nN\nN\nNExample\nN-------\nI  write_ddname = \"DDOUT\"\nI  ADDRESS TSO \"ALLOC FILE(\"write_ddname\") NEW DELETE\",\nI    \"TRACKS SPACE(1,1) RECFM(F B) BLKSIZE(0) LRECL(80)\"\nI  QUEUE \"This is the second record.\"\nI  PUSH \"This is the first record.\"\nI  queued_ctr = Queued()\nI  Address MVS \"ExecIO\" queued_ctr \"DiskW\" write_ddname \"(Finis)\"\nI  execio_rc = RC\nI  Address MVS \"ExecIO * Diskr\" write_ddname \"(STEM myrec. Finis)\"\nI  ADDRESS TSO \"FREE FILE(\"write_ddname\")\"\nI  SAY \"Read\" myrec.0 \"RECORDS.\"\nI\nI  QUEUE \"This is the second record.\"\nI  PUSH \"This is the first record.\"\nI  queued_ctr = Queued()\nI  Do queued_idx = 1 to queued_ctr\nI    pull queued_value\nI    Say queued_value\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0440": {"ttr": 43017, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00G\\x00G\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:15", "lines": 71, "newlines": 71, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0440\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-RANDOM\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175815\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNRANDOM\nN-------\nNRANDOM returns a quasi-random nonnegative whole number in the range\nNmin to max inclusive. If you specify max or min or both, max minus min\nNcannot exceed 100000. The min and max default to 0 and 999,\nNrespectively. To start a repeatable sequence of results, use a\nNspecific seed as the third argument, as described in Note 1. This\nNseed must be a positive whole number ranging from 0 to 999999999.\nN\nNNotes:\nN1. To obtain a predictable sequence of quasi-random numbers, use RANDOM\nN   a number of times, but specify a seed only the first time.\nN\nN   If you do not supply a seed, the first time RANDOM is called, an\nN   arbitrary seed is used. Hence, your program usually gives different\nN   results each time it is run.\nN\nMMessage from Kenneth Tomiak:\nMNewbies always think RANDOM will be unpredictable. It is not. The more\nMrandom you want your number, the harder you need to work to get it\nMrandom. That is where the SEED comes into play. I have no magic to\nMmake a truly random number. The best I come up with is using the date\nMtime, and used cpuseconds as a seed.\nN\nN\nNSyntax:\nD  RANDOM(max | min,, max ,seed)\nI    min: The smallest whole number you will accept.\nN\nI    max: The largest whole number you will accept.\nN\nI    seed: A whole number to influence the randomness.\nN\nN\nNExample\nN-------\nI  random_number = Random()                  /* Between 0 through 999 */\nI  SAY \"Default=\"random_number\nI  min = random_number\nI  max = min + 25\nI  seed = max // 4\nI  random_number = Random(min,max,seed)\nI  SAY \"min,max,seed=\"random_number\nI  random_number = Random(1,10)\nI  SAY \"1,10=\"random_number\nI  random_number1 = Random(1,6)                      /* Roll the dice */\nI  random_number2 = Random(1,6)                      /* Roll the dice */\nI  SAY \"1.6=\"random_number1 \"and\" random_number2\nI  random_number = Random(,,Date(\"S\"))  /* Will be highly predicatble */\nI  SAY \"Date(s)=\"random_number\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0441": {"ttr": 43019, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00)\\x00)\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:15", "lines": 41, "newlines": 41, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0441\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-REVERSE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175815\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNREVERSE\nN-------\nNREVERSE returns string, swapped end for end.\nN\nN\nNSyntax:\nD  REVERSE(string)\nI    string: The string to be reversed.\nN\nN\nNExample\nN-------\nI  ordered_value = \"Kenneth Tomiak\"\nI  reversed_value = REVERSE(ordered_value)\nI  Say ordered_value\nI  Say reversed_value\nI  ordered_value = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nI  reversed_value = REVERSE(ordered_value)\nI  Say ordered_value\nI  Say reversed_value\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0442": {"ttr": 43021, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00/\\x00/\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:16", "lines": 47, "newlines": 47, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0442\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-RIGHT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175816\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNRIGHT\nN-----\nNRIGHT returns a string of length length containing the rightmost length\nNcharacters of string. The string returned is padded with pad characters\nN(or truncated) on the left as needed. The default pad character is a\nNblank. The length must be a positive whole number or zero.\nN\nN\nNSyntax:\nD  RIGHT(string,length,pad)\nI    string: The string to act upon.\nN\nI    length: The number of characters to copy.\nN\nI    pad: A character to fill when length is longer than LENGTH(string).\nN\nN\nNExample\nN-------\nI  sort_date = Date(\"S\")\nI  dd = Right(sort_date,2)\nI  Say \"The current day is\" dd\".\"\nI\nI  Do loop_ctr = 1 To 100 By 15\nI    Say Right(loop_ctr,5,\".\") \"x 5 =\" (loop_ctr * 5)\".\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0443": {"ttr": 43023, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00)\\x00)\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:16", "lines": 41, "newlines": 41, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0443\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SIGN\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175816\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSIGN\nN----\nNSIGN returns a number that indicates the sign of number. The number\nNis first rounded according to standard REXX rules, just as though the\nNoperation number+0 had been carried out. Returns -1 if number is less\nNthan 0; returns 0 if it is 0; and returns 1 if it is greater than 0.\nN\nN\nNSyntax:\nD  SIGN(number)\nI    number: The value whose sign you wish to determine.\nN\nN\nNExample\nN-------\nI  numeric_value = -10\nI  sign_of = Sign(numeric_value)\nI  Say \"Sign of\" numeric_value \"->\" sign_of\".\"\nI  Say \"Sign of 0.0 ->\" Sign(0.0)\nI  Say \"Sign of 5 ->\" Sign(5)\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0444": {"ttr": 43025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00L\\x00L\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:16", "lines": 76, "newlines": 76, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0444\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SOURCELINE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175816\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSOURCELINE\nN----------\nNSOURCELINE returns the line number of the final line in the program if\nNyou omit n or 0 if the implementation does not allow access to the\nNsource lines. If you specify n, returns the nth line in the program if\nNavailable at the time of execution; otherwise, returns the null string.\nNIf specified, n must be a positive whole number and must not exceed the\nNnumber that a call to SOURCELINE with no arguments returns.\nN\nN\nNSyntax:\nD  SOURCELINE(n)\nI    n: Optional, a whole number not greater than the number of lines in\nI       the program source, if available. A null will return the line\nI       number of the last line.\nN\nMMessage from Kenneth Tomiak:\nMCompiled REXX can hide the source data.\nN\nN\nNExample\nN-------\nI  sourceline_max = SourceLine()\nI  Say \"This program has\" sourceline_max \"lines to it.\"\nI\nI  Say \"Line 4 is:\"\nI  Say SourceLine(4)\nI\nI  IF (ARG(1) = \"/h\") Then DO\nI    show_help = 0\nI    Say \"Showing instream help.\"\nI    Do sourceline_idx = 1 To sourceline_max\nI      Select\nI        When (SourceLine(sourceline_idx) = \"Help*/\") Then,\nI          show_help = 0\nI        When (SourceLine(sourceline_idx) = \"/*Help\") Then,\nI          show_help = 1\nI        When (show_help = 1) Then,\nI          Say SourceLine(sourceline_idx)\nI        Otherwise,\nI          NOP\nI      End\nI    End\nI  End\nI  Say \"Done.\"\nI  Return 0\nI\nI/*Help\nI+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nIThis section can be used to explain how to use the REXX code.\nI\nIIt can be useful to display \"how to\" instructions. For example,\nItype 'tso %rexr0444 /h' to display the help section.\nI+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nIHelp*/\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0445": {"ttr": 43265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x002\\x002\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:16", "lines": 50, "newlines": 50, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0445\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SPACE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175816\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSPACE\nN-----\nNSPACE returns the blank-delimited words in string with n pad characters\nNbetween each word. If you specify n, it must be a positive whole number\nNor zero. If it is 0, all blanks are removed. Leading and trailing\nNblanks are always removed. The default for n is 1, and the default\nNpad character is a blank.\nN\nN\nNSyntax:\nD  SPACE(string,n,pad)\nI    string: The text to act upon.\nN\nI    n: A whole number of pad characters to be between each word.\nN\nI    pad: A character to be used. The default is a space.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.\"\nI  Say original_value\nI  double_spaces = Space(original_value,2)\nI  Say double_spaces\nI  single_dotted = Space(original_value,1,\".\")\nI  Say single_dotted\nI\nI  stretched_value = Space(original_value,10)\nI  Say stretched_value\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0446": {"ttr": 43267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00R\\x00R\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:17", "lines": 82, "newlines": 82, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0446\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-STRIP\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175817\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSTRIP\nN-------\nNSTRIP returns string with leading or trailing characters or both\nNremoved, based on the option you specify. The following are valid\nNoptions. (Only the capitalized and highlighted letter is needed; all\nNcharacters following it are ignored.)\nN\nNBoth removes both leading and trailing characters from string.\nNThis is the default.\nN\nNLeading removes leading characters from string.\nN\nNTrailing removes trailing characters from string.\nN\nNThe third argument, char, specifies the character to be removed, and\nNthe default is a blank. If you specify char, it must be exactly one\nNcharacter long.\nN\nM\nMWhy am I picky about apostrophe and quote?\nM\nMFrom http://www.thefreedictionary.com/double+quotes\nMdouble quotes - a pair of quotation marks.\nM\nMThus the Apostrophe (') and Quote(\") are single character values.\nMIf you tell me double quotes then I will enter two quotes (\"\").\nMIf you tell me double apostrophes then I will enter two ('').\nM('') is not the same as (\").\nN\nN\nNSyntax:\nD  STRIP(string,option ,char)\nI    string: The text to act upon.\nN\nI    option: Both | Leading | Trailing\nN\nI    char: specifies the character to be removed\nN\nN\nNExample\nN-------\nI  qualified_dsname.1 = \"'KTOMIAK.TEST.CNTL'\"\nI  qualified_dsname.2 = '\"'||\"KTOMIAK.PROD.CNTL'\"\nI  qualified_dsname.0 = 2\nI\nI  Do array_idx = 1 To qualified_dsname.0\nI    Say \"Original:\"\nI    Say qualified_dsname.array_idx\nI    just_dsname = Strip(qualified_dsname.array_idx,\"L\",\"'\")\nI    Say \"Minus the leading Apostrophe ('):\"\nI    Say just_dsname\nI    just_dsname = Strip(qualified_dsname.array_idx,\"T\",\"'\")\nI    Say \"Minus the trailing Apostrophe ('):\"\nI    Say just_dsname\nI    just_dsname = Strip(qualified_dsname.array_idx,\"B\",\"'\")\nI    Say \"Minus the leading and trailing Apostrophe ('):\"\nI    Say just_dsname\nI    just_dsname = Strip(qualified_dsname.array_idx,\"B\",'\"')\nI    Say 'Minus the leading and trailing Quote (\"):'\nI    Say just_dsname\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0447": {"ttr": 43269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x005\\x005\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:17", "lines": 53, "newlines": 53, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0447\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SUBSTR\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175817\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSUBSTR\nN-------\nNSUBSTR returns the substring of string that begins at the nth character\nNand is of length length, padded with pad if necessary. The n must be a\nNpositive whole number. If n is greater than LENGTH(string), then only\nNpad characters are returned.\nN\nNIf you omit length, the rest of the string is returned.\nNThe default pad character is a blank.\nN\nN\nNSyntax:\nD  SUBSTR(string,n,length ,pad)\nI    string: The text to act upon.\nN\nI    n: A whole number of where to start.\nN\nI    length: A whole number of how many characters to copy.\nN\nI    pad: A character to fill in when length is greater than\nI         n + length.\nN\nN\nNExample\nN-------\nI  sort_date = Date(\"S\")\nI  mm = SubStr(sort_date,5,2)\nI  Say \"The current month is\" mm\".\"\nI\nI  Do loop_ctr = 100 To 200 By 15\nI    Say SubStr(loop_ctr,2,1) \"x 5 =\" (loop_ctr * 5)\".\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0448": {"ttr": 43271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00-\\x00-\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:17", "lines": 45, "newlines": 45, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0448\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SUBWORD\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175817\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSUBWORD\nN-------\nNSUBWORD returns the substring of string that starts at the nth word,\nNand is up to length blank-delimited words. The n must be a positive\nNwhole number. If you omit length, it defaults to the number of\nNremaining words in string. The returned string never has leading or\nNtrailing blanks, but includes all blanks between the selected words.\nN\nN\nNSyntax:\nD  SUBWORD(string,n,length)\nI    string: The text to act upon.\nN\nI    n: The starting word number.\nN\nI    length: The number of words to copy.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.\"\nI  partial_value = SubWord(original_value,2,3)\nI  Say original_value\nI  Say partial_value\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0449": {"ttr": 43273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00<\\x00<\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:17", "lines": 60, "newlines": 60, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0449\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SYMBOL\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175817\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSYMBOL\nN-------\nNSYMBOL returns the state of the symbol named by name. Returns BAD if\nNname is not a valid REXX symbol. Returns VAR if it is the name of a\nNvariable (that is, a symbol that has been assigned a value). Otherwise\nNreturns LIT, indicating that it is either a constant symbol or a symbol\nNthat has not yet been assigned a value (that is, a literal).\nN\nN\nNSyntax:\nD  SYMBOL(name)\nI    name: The name you want to validate.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.\"\nI  symbol_type = Symbol('original_value')\nI  Say original_value \"is a\" symbol_type\".\"\nI\nI  symbol_type = Symbol('325')\nI  Say \"'325' is a\" symbol_type\".\"\nI\nI  SAY \"Next, variable (A), which has not been initialized is tested.\"\nI  symbol_type = Symbol('A')\nI  Say \"'A' is a\" symbol_type\".\"\nI\nI  SAY \"Now we initialize (A) to 325.\"\nI  A = 325\nI  symbol_type = Symbol('A')\nI  Say \"'A' is a\" symbol_type\".\"\nI\nI  SAY \"Now we test a bad symbol name.\"\nI  symbol_type = Symbol('010_goto:')\nI  Say \"'010_goto' is a\" symbol_type\".\"\nI\nI  SAY \"Now we test a bad symbol name.\"\nI  symbol_type = Symbol('@010_goto:')\nI  Say \"'@010_goto' is a\" symbol_type\".\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0450": {"ttr": 43275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00{\\x00{\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:18", "lines": 123, "newlines": 123, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0450\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-TIME\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175818\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNTIME\nN----\nNTIME returns the local time in the 24-hour clock format: hh:mm:ss\nN(hours, minutes, and seconds) by default, for example, 04:41:37.\nN\nN\nNSyntax:\nD  TIME(option)\nI    option: You can use the following options to obtain alternative\nI            formats, or to gain access to the elapsed-time clock.\nI            (Only the capitalized and highlighted letter is needed; all\nI            characters following it are ignored.)\nN\nI      Civil: returns the time in Civil format: hh:mmxx. The hours may\nI             take the values 1 through 12, and the minutes the values\nI             00 through 59. The minutes are followed immediately by the\nI             letters am or pm. This distinguishes times in the morning\nI             (12 midnight through 11:59 a.m. appearing as 12:00am\nI             through 11:59am) from noon and afternoon (12 noon through\nI             11:59 p.m. appearing as 12:00pm through 11:59pm). The hour\nI             has no leading zero. The minute field shows the current\nI             minute (rather than the nearest minute) for consistency\nI             with other TIME results.\nN\nI      Elapsed: returns sssssssss.uuuuuu, the number of\nI               seconds.microseconds since the elapsed-time clock\nI               (described later) was started or reset. The number has\nI               no leading zeros or blanks, and the setting of\nI               NUMERIC DIGITS does not affect the number. The\nI               fractional part always has six digits.\nN\nI      Hours: returns up to two characters giving the number of hours\nI             since midnight in the format: hh (no leading zeros or\nI             blanks, except for a result of 0).\nN\nI      Long: returns time in the format: hh:mm:ss.uuuuuu (uuuuuu is the\nI            fraction of seconds, in microseconds). The first eight\nI            characters of the result follow the same rules as for the\nI            Normal form, and the fractional part is always six digits.\nN\nI      Minutes: returns up to four characters giving the number of\nI               minutes since midnight in the format: mmmm (no leading\nI               zeros or blanks, except for a result of 0).\nN\nI      Normal: returns the time in the default format hh:mm:ss, as\nI              described previously. The hours can have the values\nI              00 through 23, and minutes and seconds, 00 through 59.\nI              All these are always two digits. Any fractions of seconds\nI              are ignored (times are never rounded up).\nN\nI              This is the default.\nN\nI      Reset: returns sssssssss.uuuuuu, the number of\nI             seconds.microseconds since the elapsed-time clock\nI             (described later) was started or reset and also resets the\nI             elapsed-time clock to zero. The number has no leading\nI             zeros or blanks, and the setting of NUMERIC DIGITS does\nI             not affect the number. The fractional part always has six\nI             digits.\nN\nI      Seconds: returns up to five characters giving the number of\nI               seconds since midnight in the format: sssss (no leading\nI               zeros or blanks, except for a result of 0).\nN\nN\nNExample\nN-------\nI  clock_24      = Time()                   /* see Normal             */\nI  clock_civil   = Time(\"C\")                /* hh:mmxx xx=Am or PM    */\nI  clock_elapsed = Time(\"E\")                /* ssssssss.uuuuuu        */\nI  clock_hour    = Time(\"H\")                /* hours since midnight   */\nI  clock_long    = Time(\"L\")                /* hh:mm:ss.uuuuuu        */\nI  clock_minutes = Time(\"M\")                /* minutes since midnight */\nI  clock_normal  = Time(\"N\")                /* Default hh:mm:ss       */\nI  clock_reset   = Time(\"R\")                /* \"E\" then reset timer   */\nI  clock_seconds = Time(\"S\")                /* Seconds since midnight */\nI\nI  Say \"24 Hour clock:\" clock_24\".\"\nI  Parse Var clock_24,\nI    current_hour \":\" current_minute \":\" current_second,\nI    =1 regular_hour +2 .\nI  am_or_pm = \"AM\"\nI  If (current_hour > 11) Then,\nI    Do\nI      am_or_pm = \"PM\"\nI      regular_hour = regular_hour - 12\nI    End\nI  Say \"12 Hour clock:\" regular_hour\":\"current_minute am_or_pm\nI\nI  Say \"Time()    ->\" Time()\nI  Say \"Time('C') ->\" Time(\"C\")\nI  Say \"Time('E') ->\" Time(\"E\")\nI  Say \"Time('H') ->\" Time(\"H\")\nI  Say \"Time('L') ->\" Time(\"L\")\nI  Say \"Time('M') ->\" Time(\"M\")\nI  Say \"Time('N') ->\" Time(\"N\")\nI  Do Until seconds_now > clock_seconds\nI    seconds_now = Time(\"S\")\nI  End\nI  Say \"Time('E') ->\" Time(\"E\")\nI  Say \"Time('R') ->\" Time(\"R\")\nI  Say \"Time('S') ->\" Time(\"S\")\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0451": {"ttr": 43277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00Q\\x00Q\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:18", "lines": 81, "newlines": 81, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0451\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-TRACE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175818\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNTRACE\nN-------\nNTRACE .returns trace actions currently in effect and, optionally,\nNalters the setting.\nN\nNIf you specify option, it selects the trace setting. It must be one of\nNthe valid prefixes ? or ! or one of the alphabetic character options\nNassociated with the TRACE instruction (that is, starting with\nNA, C, E, F, I, L, N, O, R, or S) or both. (See the TRACE instruction\nNfor full details.)\nN\nNUnlike the TRACE instruction, the TRACE function alters the trace\nNaction even ifinteractive debug is active. Also unlike the TRACE\nNinstruction, option cannot be a number.\nN\nI\nN\nN\nNSyntax:\nD  old_option = Trace(\"prefix\"||\"letter\")\nN\nI        prefix:\nI          ? = interactive debug\nI          ! = inhibit host command execution\nN\nI        letter:\nI          A = All clauses traced\nI          C = All host commands traced\nI          E = host commands with non-zero RC traced after execution\nI          F = host commands with negative RC traced after execution\nI          I = all intermediate results shown\nI          L = show labels\nI          N = host commands with negative RC traced after execution\nI          O = Off, no more tracing\nI          R = Results shown\nN\nN\nNExample\nN-------\nI  old_option = Trace()\nI  Say \"Trace state:\" old_option\".\"\nI  Trace Off\nI  trace_value = Trace(\"?L\")\nI  Say \"Tracing was:\" trace_value\".\"\nI  trace_value = Trace(\"?I\")                         /* Also does 'R' */\nI  trace_value = Trace(\"?IRS\")\nI  Say \"IT WAS:\" trace_value\".\"\nI  trace_value = Trace(\"O\")\nN\nM  Say \"Trace messages\"\nM  Say \"*-*  sourceline\"\nM  Say \"+++  trace messages\"\nM  Say \">>>  result of operation\"\nM  Say \">.>  value assigned to placeholder during parsing\"\nM  Say \">C>  compound variable\"\nM  Say \">F>  result of function call\"\nM  Say \">L>  literal\"\nM  Say \">O>  Result of operation on two terms\"\nM  Say \">P>  Result of prefix operation\"\nM  Say \">V>  Contents of a variable\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0452": {"ttr": 43279, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x003\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:18", "lines": 51, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0452\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-TRANSLATE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175818\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNTRANSLATE\nN---------\nNTRANSLATE returns string with each character translated to another\nNcharacter or unchanged. You can also use this function to reorder the\nNcharacters in string.\nN\nN\nNSyntax:\nD  TRANSLATE(string,tableo ,tablei ,pad)\nI    string: The text to act upon.\nN\nI    tableo: A table of what the output character will be.\nN\nI    tablei: A table to reference the position within the table.\nI            Position 1 in tablei becomes the character in position 1 of\nI            tableo.\nN\nI    pad: A character used if tableo is shorter than tablei.\nN\nN\nNExample\nN-------\nI  tablei = XRANGE('00'x,'FF'x)\nI  tableo = REVERSE(tablei)\nI  original_value = \"The quick brown fox took a day off.\"\nI  cypher_text = TRANSLATE(original_value,tableo,tablei,'+')\nI  say original_value\nI  say cypher_text\nI  decypher_text = TRANSLATE(cypher_text,tablei,tableo,'+')\nI  say decypher_text\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0453": {"ttr": 43521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00/\\x00/\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:18", "lines": 47, "newlines": 47, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0453\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-TRUNC\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175818\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNTRUNC\nN-----\nNTRUNC returns the integer part of number and n decimal places. The\nNdefault n is 0 and returns an integer with no decimal point. If you\nNspecify n, it must be a positive whole number or zero. The number is\nNfirst rounded according to standard REXX rules, just as though the\nNoperation number+0 had been carried out. The number is then truncated\nNto n decimal places (or trailing zeros are added if needed to make up\nNthe specified length). The result is never in exponential form.\nN\nN\nNSyntax:\nD  TRUNC(number,n)\nI    number: A real number to act upon.\nN\nI    n: The number of decimal positions to keep.\nN\nN\nNExample\nN-------\nI  real_number = 127.55982\nI  integer_number = Trunc(real_number,0)\nI  dollars_cents = Trunc(real_number,2)\nI  Say \"'\"real_number\"'\"\nI  Say \"'\"integer_number\"'\"\nI  Say \"'\"dollars_cents\"'\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0454": {"ttr": 43523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00&\\x00&\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:19", "lines": 38, "newlines": 38, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0454\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-USERID\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175819\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNUSERID\nN------\nNUSERID is a non-SAA built-in function provided only by TSO/E and VM.\nIAnd Open Object REXX, too!\nN\nNreturns the TSO/E user ID, if the REXX exec is running in the TSO/E\nNaddress space.\nN\nN\nNSyntax:\nD  USERID()\nN\nN\nNExample\nN-------\nI  current_userid = Userid()\nI  Say \"Userid(\"current_userid\")\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0455": {"ttr": 43525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00:\\x00:\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:19", "lines": 58, "newlines": 58, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0455\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-VALUE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175819\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNVALUE\nN-------\nNVALUE returns the value of the symbol that name (often constructed\nNdynamically) represents and optionally assigns it a new value. By\nNdefault, VALUE refers to the current REXX-variables environment. If\nNyou use the function to refer to REXX variables, then name must be a\nNvalid REXX symbol. (You can confirm this by using the SYMBOL function.)\nNLowercase characters in name are translated to uppercase. Substitution\nNin a compound name occurs if possible.\nN\nMA better alternative to Interpret if you are just using variables.\nN\nN\nNSyntax:\nD  VALUE(name, newvalue)\nI    name: The name of a symbol.\nN\nI    newvalue: Optional vaalue assigned to symbol after it is copied.\nN\nN\nNExample\nN-------\nI  init_value = Value(\"array_value.1.12\",\"Ken\")\nI  Say init_value\nI  last_value = Value(\"array_value.1.12\",\"Sam\")\nI  Say last_value\nI  stem_x = 1\nI  stem_y = 12\nI  last_value = Value(\"array_value.\"stem_x\".\"stem_y,\"Bob\")\nI  Say last_value\nI\nI  stem_value = array_value.stem_x.stem_y\nI  Say stem_value\nI  stem_y = \"BILL\"\nI  array_value.stem_x.stem_y = \"Tom\"\nI  stem_value = array_value.stem_x.stem_y\nI  Say stem_value\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0456": {"ttr": 43527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00s\\x00s\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:19", "lines": 115, "newlines": 115, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0456\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-VERIFY\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175819\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNVERIFY\nN------\nNVERIFY returns a number that, by default, indicates whether string is\nNcomposed only of characters from reference; returns 0 if all characters\nNin string are in reference, or returns the position of the first\nNcharacter in string not in reference.\nN\nN\nNSyntax:\nD  Verify(string,reference,option,start)\nI    string: The text to act upon.\nN\nI    reference: The characters allowed to be in the string.\nN\nI    option: Whether to check it matches or not.\nN\nI    start: Where to start checking. The default IS 1.\nN\nN\nNExample\nN-------\nI  Say \"0 for a complete match, >0 is where it fails.\"\nI  original_value = \"(800) 555-2424\"\nI  verify_rc = Verify(original_value,\"- ()0123456789\")\nI  Say original_value \"verify_rc(\"verify_rc\")\"\nI  original_value = \"(800)-(555)-(2424)\"\nI  verify_rc = Verify(original_value,\"- ()0123456789\")\nI  Say original_value \"verify_rc(\"verify_rc\")\"\nI  original_value = \"(800) KEN-HOME\"\nI  verify_rc = Verify(original_value,\" ()0123456789\")\nI  Say original_value \"verify_rc(\"verify_rc\")\"\nI  verify_rc = Verify(original_value,\" ()0123456789\",\"Nomatch\")\nI  Say original_value \"verify_rc(\"verify_rc\")\"\nI  verify_rc = Verify(original_value,\" ()08KENHOME-\",\"Nomatch\")\nI  Say original_value \"verify_rc(\"verify_rc\")\"\nI  verify_rc = Verify(original_value,\" ()0123456789\",\"Match\")\nI  Say original_value \"verify_rc(\"verify_rc\") should be 1.\"\nI\nI  SAY \"DSNAME verification\"\nI  SAY \"-------------------\"\nI  first_char = \"@#$QWERTYUIOPASDFGHJKLZXCVBNM\"\nI  other_chars = \"1234567890QWERTYUIOPASDFGHJKLZXCVBNM@#$\"\nI  good_dsname = \"KTOMIAK.$TEST.DSNAME1\"\nI  isitgood_rc = VERIFY_dsname(good_dsname)\nI  IF (isitgoOd_rc <> 0) THEN DO\nI    SAY \"Errors found at\" isitgood_rc\nI  END\nI  bad_dsname = \"1TOMIAK.$TES%.DSN ME1\"\nI  isitgood_rc = VERIFY_dsname(bad_dsname)\nI  IF (isitgoOd_rc <> 0) THEN DO\nI    SAY \"Errors found at\" isitgood_rc\nI  END\nI  isitgood_rc = VERIFY_dsname(good_dsname, bad_dsname)\nI  IF (isitgoOd_rc <> 0) THEN DO\nI    SAY \"Errors found at\" isitgood_rc\nI  END\nI  return 0\nI\nIVERIFY_dsname: PROCEDURE ,\nI  EXPOSE first_char other_chars\nI  num_args = ARG()\nI  test_dsname = ARG(1)\nI  SAY test_dsname\nI  isitgood_rc = 0\nI  badpos = \"\"\nI  level_ctr = 0\nI  DO WHILE test_dsname <> \"\"\nI    PARSE VAR test_dsname one_level \".\" test_dsname\nI    level_ctr = level_ctr + 1\nI    isitgood_rc = VERIFY(SUBSTR(one_level,1,1),first_char,\"NoMatch\")\nI    IF (isitgood_rc > 0) THEN DO\nI      badpos = badpos isitgood_rc\nI      SAY \"level:\" level_ctr isitgood_rc\nI    END\nI    start_pos = 2\nI    isitgood_rc = VERIFY(one_level,other_chars,\"N\",start_pos)\nI    DO WHILE isitgood_rc > 0\nI      IF (isitgood_rc > 0) THEN DO\nI        badpos = badpos isitgood_rc\nI        SAY \"level:\" level_ctr \"char:\" isitgood_rc\nI      END\nI      start_pos = isitgood_rc + 1\nI      isitgood_rc = VERIFY(one_level,other_chars,\"N\",start_pos)\nI    END\nI  END\nI\nI  IF (num_args > 1) THEN DO\nI    SAY \"VERIFY_dsname only checks the first DSNAME passed in.\"\nI    DO AX = 2 TO num_args\nI      SAY ARG(ax) \"ignored.\"\nI    END\nI  END\nI  IF (badpos = \"\") THEN badpos = 0\nI  return badpos\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0457": {"ttr": 43529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x000\\x000\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:19", "lines": 48, "newlines": 48, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0457\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-WORD\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175819\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNWORD\nN-------\nNWORD returns the nth blank-delimited word in string or returns the null\nNstring if fewer than n words are in string. The n must be a positive\nNwhole number. This function is exactly equivalent to\nNSUBWORD(string,n,1).\nN\nN\nNSyntax:\nD  WORD(string,n)\nI    string: The text to act upoon.\nN\nI    n: A whole number for the word desired.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.     \"\nI  SAY \"Show the second word:\"\nI  partial_value = Word(original_value,2)\nI  say partial_value\nI\nI  SAY \"Show each word, one at a time:\"\nI  Do word_ctr = 1 To Words(original_value)\nI    partial_value = Word(original_value,word_ctr)\nI    say \">\"partial_value\"<\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0458": {"ttr": 43531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x000\\x000\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:20", "lines": 48, "newlines": 48, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0458\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-WORDINDEX\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175820\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNWORDINDEX\nN---------\nNWORDINDEX returns the position of the first character in the nth\nNblank-delimited word in string or returns 0 if fewer than n words are\nNin string. The n must be a positive whole number.\nN\nN\nNSyntax:\nD  WORDINDEX(string,n)\nI    string: The text to act upon.\nN\nI    n: A whole number for the word desired.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.     \"\nI  SAY \"Show the second word:\"\nI  partial_value = WordIndex(original_value,2)\nI  say partial_value\nI\nI  SAY \"Show each word index in the string, one at a time:\"\nI  Do word_ctr = 1 To Words(original_value)\nI    partial_value = WordIndex(original_value,word_ctr)\nI    say \">\"partial_value\"<\"\nI  End\nI\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0459": {"ttr": 43533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00/\\x00/\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:20", "lines": 47, "newlines": 47, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0459\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-WORDLENGTH\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175820\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNWORDLENGTH\nN-------\nNreturns the length of the nth blank-delimited word in string or\nNreturns 0 if fewer than n words are in string. The n must be a\nNpositive whole number.\nN\nN\nNSyntax:\nD  WORDLENGTH(string,n)\nI    string: The text to act upon.\nN\nI    n: A whole number for the word desired.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.     \"\nI  SAY \"Show the second word:\"\nI  partial_value = WORDLENGTH(original_value,2)\nI  say partial_value\nI\nI  SAY \"Show each word LENGTH in the string, one at a time:\"\nI  Do word_ctr = 1 To Words(original_value)\nI    partial_value = WORDLENGTH(original_value,word_ctr)\nI    say \">\"partial_value\"<\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0460": {"ttr": 43535, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x002\\x002\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:20", "lines": 50, "newlines": 50, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0460\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-WORDPOS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175820\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNWORDPOS\nN-------\nNWORDPOS returns the word number of the first word of phrase found in\nNstring or returns 0 if phrase contains no words or if phrase is not\nNfound. Multiple blanks between words in either phrase or string are\nNtreated as a single blank for the comparison, but otherwise the words\nNmust match exactly.\nN\nN\nNSyntax:\nD  WORDPOS(phrase,string,start)\nI    phrase: The phrase to search for.\nN\nI    string: The text to act upon.\nN\nI    start: A whole number for the word to start searching from.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.     \"\nI  SAY \"Show where 'and' is located.\"\nI  partial_value = WORDPOS(\"and\",original_value)\nI  say partial_value\nI\nI  original_value = \"The      quick     and    the   dead.     \"\nI  SAY \"Show where 'and the' is located.\"\nI  partial_value = WORDPOS(\"and the\",original_value)\nI  say partial_value\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0461": {"ttr": 43537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00 \\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:20", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0461\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-WORDS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175820\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNWORDS\nN-------\nNWORDS returns the number of blank delimited words in string.\nN\nN\nNSyntax:\nD  WORDS(string)\nI    string: The text to act upon.\nN\nN\nNExample\nN-------\nI  original_value = \"The      quick     and    the   dead.     \"\nI  SAY \"Show each of\" WORDS(original_value) \"words in the string:\"\nI  Do word_ctr = 1 To Words(original_value)\nI    partial_value = WORD(original_value,word_ctr)\nI    say \">\"partial_value\"<\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0462": {"ttr": 43539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:21", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0462\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-XRANGE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175821\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNXRANGE\nN-------\nNXRANGE returns a string of all valid 1-byte encodings (in ascending\nNorder) between andincluding the values start and end. The default value\nNfor start is '00'x, and the default value for end is 'FF'x. If start is\nNgreater than end, the values wrap from 'FF'x to '00'x. If specified,\nNstart and end must be single characters.\nN\nN\nNSyntax:\nD  XRANGE(start ,end)\nI    start: The first character.\nN\nI    end: The last character.\nN\nN\nNExample\nN-------\nI  full_xrange = XRange('00'x,'FF'x)\nI  all_letters = XRange(\"A\",\"I\")XRange(\"J\",\"R\")XRange(\"S\",\"Z\")\nI  Say all_letters\nI  all_letters_plus = XRange(\"A\",\"9\")\nI  Say all_letters_plus\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0463": {"ttr": 43777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:21", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0463\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-X2B\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175821\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNX2B\nN---\nNX2B returns a string, in character format, that represents hexstring\nNconverted to binary. The hexstring is a string of hexadecimal\nNcharacters. It can be of any length. Each hexadecimal character is\nNconverted to a string of four binary digits. You can optionally\nNinclude blanks in hexstring (at byte boundaries only, not leading or\nNtrailing) to aid readability; they are ignored.\nN\nN\nNSyntax:\nD  X2B(string)\nI    string: A string of hexadecimal values.\nN\nN\nNExample\nN-------\nI  bit_str = \"11110001\"\nI  hex_val = B2X(bit_str)\nI  bin_val = X2B(hex_val)\nI  dec_val = X2D(B2X(bin_val))\nI  Say \"BIT(\"bit_str\") is\",\nI     \"Hex(\"hex_val\") is\",\nI     \"Bin(\"bin_val\") is\",\nI     \"Dec(\"dec_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0464": {"ttr": 43779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00-\\x00-\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:21", "lines": 45, "newlines": 45, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0464\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-X2C\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175821\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNX2C\nN---\nNX2C returns a string, in character format, that represents hexstring\nNconverted to character. The returned string is half as many bytes as\nNthe original hexstring. hexstring can be of any length. If necessary,\nNit is padded with a leading 0 to make an even number of hexadecimal\nNdigits or trailing) to aid readability; they are ignored.\nN\nN\nNSyntax:\nD  X2C(string)\nI    string: A string of hexadecimal values.\nN\nN\nNExample\nN-------\nI  bit_str = \"11110001\"\nI  hex_val = B2X(bit_str)\nI  bin_val = X2B(hex_val)\nI  chr_val = X2C(B2X(bin_val))\nI  Say \"BIT(\"bit_str\") is\",\nI     \"Hex(\"hex_val\") is\",\nI     \"Bin(\"bin_val\") is\",\nI     \"CHR(\"chr_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0465": {"ttr": 43781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:21", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0465\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-X2D\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175821\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNX2D\nN---\nNX2D returns the decimal representation of hexstring. The hexstring is\nNa string of hexadecimal characters. If the result cannot be expressed\nNas a whole number, an error results. That is, the result must not have\nNmore digits than the current setting of NUMERIC DIGITS. You can\nNoptionally include blanks in hexstring (at byte boundaries only, not\nNleading or trailing) to aid readability; they are ignored.\nN\nN\nNSyntax:\nD  X2D(string)\nI    string: A string of hexadecimal values.\nN\nN\nNExample\nN-------\nI  bit_str = \"11110001\"\nI  hex_val = B2X(bit_str)\nI  bin_val = X2B(hex_val)\nI  dec_val = X2D(hex_val)\nI  Say \"BIT(\"bit_str\") is\",\nI     \"Hex(\"hex_val\") is\",\nI     \"Bin(\"bin_val\") is\",\nI     \"Dec(\"dec_val\").\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0470": {"ttr": 43783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x005\\x005\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:22", "lines": 53, "newlines": 53, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0470\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-TSO/E external functions\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175822\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nN  TSO/E external functions\nN  ------------------------\nN    GETMSG:     returns a function code that replaces the function\nN                call and retrieves, in variables, a message that has\nN                been issued during a console session.\nN    LISTDSI:    returns one of the following function codes that\nN                replace the function call, and retrieves information\nN                about a data set's allocation, protection, and\nN                directory and stores it in specific variables.\nN    MSG:        MSG returns the value ON or OFF, which indicates the\nN                status of the displaying of TSO/E messages.\nN    MVSVAR:     returns information about MVS, TSO/E, and the current\nN                session, such as the symbolic name of the MVS system,\nN                or the security label of the TSO/E session.\nN    OUTTRAP:    returns the name of the variable in which trapped\nN                output is stored, or if trapping is not in effect,\nN                OUTTRAP returns the word off.\nN    PROMPT:     returns the value ON or OFF, which indicates the\nN                setting of prompting for the exec.\nN    SETLANG:    SETLANG returns a three character code that indicates\nN                the language in which REXX messages are currently\nN                being displayed.\nN    STORAGE:    returns length bytes of data from the specified\nN                address in storage.\nN    SYSCPUS:    places, in a stem variable, information about those\nN                CPUs that are online.\nN    SYSDSN:     returns one of the following messages indicating\nN                whether the specified dsname exists and is available\nN                for use.\nN    SYSVAR:     returns information about MVS, TSO/E, and the current\nN                session, such as levels of software available, your\nN                logon procedure, and your user ID.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0471": {"ttr": 43785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x01a\\x01a\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:58", "lines": 353, "newlines": 353, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0471\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-TSO/E external functions\nT-GETMSG\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175858\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNTSO/E external functions\nN------------------------\nNGETMSG\nN-------\nNGETMSG returns a function code that replaces the function call and\nNretrieves, in variables, a message that has been issued during a\nNconsole session.\nN\nNVariables GETMSG sets for the entire message\nN--------------------------------------------\nNGETMSG sets specific variables that relate to the entire message that\nNit retrieves.\nN\nNGETMSG sets these variables, regardless of how many lines of\nNtext the retrieved message contains. The names of the variables\nNthat GETMSG sets correspond to the field names in the message\nNdata block (MDB) in MVS/ESA System Product. The variable names\nNconsist of the msgstem you specified on the call to GETMSG followed\nNby the name of the field in the MDB. That is, TSO/E uses the name\nNof the field in the MDB as the suffix for the variable name and\nNconcatenates the MDB field name to the msgstem. For example,\nNone field in the MDB is MDBLEN, which is the length of the MDB.\nN\nNIf you specify msgstem as CONSMSG. (with a period), REXX\nNreturns the length of the MDB in the variable: CONSMSG.MDBLEN\nN\nNIf you specify msgstem as CMSG (without a period), the\nNvariable name would be CMSGMDBLEN.\nN\nNFor any variable that needs a minimum MVS release to have\nNa proper value returned, this minimum prerequisite release\nNis listed in the second column. For detailed information\nNabout the MDB and each field in the MDB, see z/OS MVS Data\nNAreas, Vol 3 (IVT-RCWK).\nN\nN\nNVariable Description\nN-------- -------------------------------------------------------------\nNMDBLEN   Length of the MDB, in decimal.\nNMDBTYPE  MDB type, in decimal.\nNMDBMID   Four character MDB identifier, which is MDB.\nNMDBVER   Version of the MDB; 4-byte hexadecimal value.\nNMDBGLEN  General object length of the MDB, in decimal.\nNMDBGTYPE General object type of the MDB, in decimal.\nNMDBGMID  Four byte message identifier, in hexadecimal.\nNMDBGSYID One byte system ID, in hexadecimal. The value is the same as\nN         the first byte of the MDBGMID variable (message identifier).\nMDBGSEQ   Three byte sequence number, in hexadecimal. The value is the\nN         same as the last three bytes of the MDBGMID variable (message\nN         identifier).\nNMDBGTIMH Time stamp in the format: hh.mm.ss where hh is hours, mm is\nN         minutes, and ss is seconds.\nNMDBGTIMT Time stamp in the format: .th where th is tenths of seconds,\nN         .36, for example.\nNMDBGDSTP Date stamp in the format yyyyddd, where yyyy is the year and\nN         ddd is the number of days, including the current day, so far\nN         in the year.\nNMDBGDOM  General DOM indicator. Contains the value YES or NO that\nN         indicates whether messages that match the message ID are to\nN         be deleted.\nNMDBGALRM YES or NO to indicate whether the processor alarm is sounded.\nNMDBGHOLD Hold indicator: YES or NO to indicate whether the message\nN         should be held until DOMed or deleted by other external means.\nNMDBGFCON Foreground control presentation attribute, in decimal.\nNMDBGFCOL Foreground color presentation attribute, in decimal.\nNMDBGFHIL Foreground highlighting presentation attribute, in decimal.\nNMDBGFINT Foreground intensity presentation attribute, in decimal.\nNMDBGBCON Background control presentation attribute, in decimal.\nNMDBGBCOL Background color presentation attribute, in decimal.\nNMDBGBHIL Background highlighting presentation attribute, in decimal.\nNMDBGBINT Background intensity presentation attribute, in decimal.\nMMDBGOSNM Eight character originating system name.\nNMDBGJBNM Eight character job name.\nNMDBCLEN  Control object length of the MDB, in decimal.\nNMDBCTYPE Control object type of the MDB, in decimal.\nNMDBCPROD Sixteen character originating system identifier.\nNMDBCVER  MVS CP object version level; 4-byte hexadecimal value.\nNMDBCPNAM Four character control program name.\nNMDBCFMID Eight character FMID of the originating system.\nNMDBCERC  Routing codes; 16-byte hexadecimal value.\nNMDBCDESC Descriptor codes; 2-byte hexadecimal value.\nNMDBDESCA YES or NO to indicate whether the message pertains to a\nN         system failure. Additional GETMSG Variables\nNMDBDESCB YES or NO to indicate whether the message requires an\nN         immediate action.\nNMDBDESCC YES or NO to indicate whether the message requires an\nN         eventual action.\nNMDBDESCD YES or NO to indicate whether the message pertains to system\nN         status.\nNMDBDESCE YES or NO to indicate whether the message is an immediate\nN         command response.\nNMDBDESCF YES or NO to indicate whether the message pertains to job\nN         status.\nNMDBDESCG YES or NO to indicate whether or not the message was issued\nN         by an application program or application processor.\nNMDBDESCH YES or NO to indicate whether the message is directed to an\nN         out-of-line area.\nNMDBDESCI YES or NO to indicate whether the message pertains to an\nN         operator request.\nNMDBDESCJ YES or NO to indicate whether the message is a track command\nN         response.\nNMDBDESCK YES or NO to indicate whether the message requires a critical\nN         eventual action.\nNMDBDESCL YES or NO to indicate whether the message is an important\nN         informational message.\nNMDBDESCM YES or NO to indicate: previously automated.\nNMDBCMLVL Message level; 2-byte hexadecimal value.\nNMDBMLR   YES or NO to indicate whether the message is a WTOR.\nNMDBMLIA  YES or NO to indicate whether the message requires an\nN         immediate action.\nNMDBMLCE  YES or NO to indicate whether the message requires a critical\nN         eventual action.\nNMDBMLE   YES or NO to indicate whether the message requires an eventual\nN         action.\nNMDBMLI   YES or NO to indicate whether the message is an informational\nN         message.\nNMDBMLBC  YES or NO to indicate whether the message is a broadcast\nN         message.\nNMDBCSUPP YES or NO to indicate whether the message is suppressed.\nNMDBCMCSC YES or NO to indicate whether the message is a command\nN         response.\nNMDBCAUTH YES or NO to indicate whether the message was issued by an\nN         authorized program.\nMMDBCRETN YES or NO to indicate whether the message is retained by AMRF.\nNMDBCSPVD YES or NO to indicate: WQE backlog message.\nNMDBCASID ASID of the issuer; 2-byte hexadecimal value.\nNMDBCTCB  TCB of the job step; 4-byte hexadecimal value.\nNMDBCTOKN Token that the issuer of the message used, in decimal.\nNMDBCSYID System ID, in decimal.\nN\nNAdditional GETMSG Variables\nN---------------------------\nNVariable Description\nN-------- -------------------------------------------------------------\nNMDBDMSGI YES or NO to indicate whether operator messages with the\nN         specific message ID (as specified by the MDBGMID variable)\nN         should be deleted.\nNMDBDSYSI YES or NO to indicate whether operator messages with the\nN         specific system ID (as specified by the MDBGSYID variable)\nN         should be deleted.\nNMDBDASID YES or NO to indicate whether operator messages with the\nN         specific ASID (as specified by the MDBCASID variable) should\nN         be deleted.\nNMDBDJTCB YES or NO to indicate whether operator messages with the\nM         specific job step TCB (as specified by the MDBCTCB variable)\nN         should be deleted.\nNMDBDTOKN YES or NO to indicate whether operator messages with the\nM         specific token (as specified by the MDBCTOKN variable) should\nN         be deleted.\nNMDBCAUT  YES or NO to indicate: QUEUE by using automation.\nNMDBCHC   YES or NO to indicate: QUEUE via hardcopy.\nNMDBCOCMD YES or NO to indicate: Echo operator command.\nNMDBCICMD YES or NO to indicate: Echo internal command.\nNMDBCWTL  YES or NO to indicate: result of WTL macro.\nNMDBCOJID Eight character originating job ID.\nNMDBCKEY  Eight character retrieval key.\nNMDBCAUTO Eight character automation token.\nNMDBCCART Eight character command and response token (CART).\nNMDBCCNID Console ID; 4-byte hexadecimal value.\nNMDBMSGTA YES or NO to indicate whether the message was issued because\nN         job names were being monitored.\nNMDBMSGTB YES or NO to indicate whether the message was issued because\nN         status was being monitored.\nNMDBMSGTC YES or NO to indicate whether monitor is active.\nNMDBMSGTD YES or NO to indicate whether the QID field exists in\nN         the WPL (AOS/1).\nNMDBMSGTF YES or NO to indicate whether the message was issued because\nN         sessions were being monitored.\nNMDBCRPYL Length of the reply ID, in decimal. The reply ID is returned\nN         in the variable MDBCRPYI, which is described below.\nNMDBCRPYI EBCDIC representation of the reply ID.\nNMDBCTOFF The offset in the message text field to the beginning of the\nN         message, in decimal.\nNMDBCRPYB Reply ID, in decimal.\nNMDBCAREA One character area ID.\nNMDBCLCNT Number of lines of message text in the message, in decimal.\nNMDBCOJBN Eight character originating job name.\nNMDBCSPLX 8-character SYSPLEX name.\nNMDBCRCMT YES or NO to indicate whether the message text was changed.\nNMDBCRCRC YES or NO to indicate whether routing code(s) were changed.\nNMDBCRCDC YES or NO to indicate whether descriptor code(s) were changed.\nNMDBCRQPC YES or NO to indicate: queued to a particular active console.\nNMDBCRQRC YES or NO to indicate: queued by routing codes only.\nNMDBCRPML YES or NO to indicate whether minor lines were processed.\nNMDBCRDTM YES or NO to indicate whether the message was deleted.\nNMDBCROMS YES or NO to indicate: MPF suppression was overridden.\nNMDBCRFHC YES or NO to indicate: hardcopy forced.\nNMDBCRNHC YES or NO to indicate: no hardcopy was forced.\nNMDBCRHCO YES or NO to indicate: only hardcopy forced.\nNMDBCRBCA YES or NO to indicate: broadcast message to active consoles.\nNMDBCRBCN YES or NO to indicate: did not broadcast message to active\nN         consoles.\nNMDBCRNRT YES or NO to indicate: AMRF is not to retain this message.\nNMDBCRRET YES or NO to indicate: AMRF is to retain this message.\nNMDBCRCKY YES or NO to indicate: changed the retrieval key.\nNMDBCRCFC YES or NO to indicate: changed the 4-byte console ID.\nNMDBCRCMF YES or NO to indicate: changed the message type flags.\nNMDBCRANO YES or NO to indicate: automation was not required.\nNMDBCRAYS YES or NO to indicate: automation was required and/or\nN         automation token updated.\nNMDBCQHCO YES or NO to indicate: message issued as hardcopy only.\nNMDBCSNSV YES or NO to indicate: not serviced by any WTO user exit\nN         routine.\nNMDBCSEER YES or NO to indicate: A WTO user exit abended while\nN         processing this message.\nNMDBCSNSI YES or NO to indicate: not serviced due to an incompatible\nN         request.\nNMDBCSAUT YES or NO to indicate: automation specified.\nNMDBCSSSI YES or NO to indicate: suppressed by a subsystem.\nNMDBCSWTO YES or NO to indicate: suppressed by a WTO user exit routine.\nNMDBCSMPF YES or NO to indicate: suppressed by MPF.\nNMDBCCNNM 8-character console name.\nNMDBMCSB  YES or NO to indicate: MCSFLAG=REG0 was specified.\nNMDBMCSI  YES or NO to indicate: MCSFLAG=NOTIME was specified.\nN\nN\nNVariables GETMSG sets for each line of message text\nN---------------------------------------------------\nNGETMSG also sets an array of variables for the message it retrieves.\nNThe variables are set for each line of message text for the retrieved\nNmessage.\nN\nNThe variable names are compound symbols. The stem of each\nNvariable name is the same for all lines of message text.\nN\nNThe value following the period (.) in the variable name is the\nNline number of the line of message text.\nN\nNMDBTLEN.n  Text object length of the MDB, in decimal.\nNMDBTTYPE.n Text object type of the MDB, in decimal.\nNMDBTCONT.n YES or NO to indicate whether the line of message text\nN           consists of control text.\nNMDBTLABT.n YES or NO to indicate whether the line of message text\nN           consists of label text.\nNMDBTDATT.n YES or NO to indicate whether the line of message text\nN           consists of data text.\nNMDBTENDT.n YES or NO to indicate whether the line of message text\nN           consists of end text.\nNMDBTPROT.n YES or NO to indicate whether the line of message text\nN           consists of prompt text.\nNMDBTFPAF.n YES or NO to indicate whether the text object presentation\nN           attribute field overrides the general object presentation\nN           attribute field.\nNMDBTPCON.n Presentation control attribute, in decimal.\nNMDBTPCOL.n Presentation color attribute, in decimal.\nNMDBTPHIL.n Presentation highlighting attribute, in decimal.\nNMDBTPINT.n Presentation intensity attribute, in decimal.\nN\nN\nNSyntax:\nD  GETMSG(msgstem, msgtype, cart, mask, time)\nI    msgstem: the stem of the list of variables into which GETMSG\nI             places the message text. To place the message text into\nI             compound variables, which allow for indexing, msgstem\nI             should end with a period (for example, 'messg.').\nN\nI    msgtype: the type of message you want to retrieve. Specify one of\nI             the following values for msgtype:\nN\nI             -> SOL: indicates that you want to retrieve a solicited\nI                     message. A solicited message is the response from\nI                     an MVS system or subsystem command.\nN\nI             -> UNSOL: indicates that you want to retrieve an\nI                       unsolicited message. An unsolicited message is\nI                       any message that is not issued in response to\nI                       an MVS system or subsystem command. For example,\nI                       an unsolicited message may be a message that\nI                       another user sends you or a broadcast message.\nN\nI             -> EITHER: indicates that you want to retrieve either type\nI                        of message (solicited or unsolicited). If you\nI                        do not specify the msgtype argument, EITHER is\nI                        the default.\nN\nI    cart: the command and response token (CART). The CART is a token\nI          that lets you associate MVS system commands and subcommands\nI          with their responses. When you issue an MVS system or\nI          subsystem command, you can specify a CART on the command\nI          invocation. To use GETMSG to retrieve a particular message\nI          that is in direct response to the command invoked, specify\nI          the same CART value.\nN\nI    mask: search argument that GETMSG uses as a mask with the cart\nI          argument for obtaining a message. If you specify a mask,\nI          GETMSG ANDs the mask value with the CART value that you\nI          specify on the GETMSG function. GETMSG also ANDs the mask\nI          with the CARTs associated with the messages that have been\nI          routed to the user's console. GETMSG then compares the\nI          results of the AND operations. If a comparison matches,\nI          GETMSG retrieves the message. Otherwise, no message is\nI          retrieved.\nN\nII         The mask argument is valid only if you are retrieving\nI          solicited messages and are using a CART. That is, mask is\nI          valid only if you specify SOL for msgtype and you specify\nI          the cart argument.\nN\nI    time: the amount of time, in seconds, that GETMSG should wait,\nI          if the requested message has not yet been routed to the\nI          user's console. If you specify a time value and the time\nI          expires before the message is routed to the user's console,\nI          GETMSG does not retrieve the message. Otherwise, if the\nI          message is available before the time expires, GETMSG\nI          retrieves the message.\nN\nN\nNExample\nN-------\nNYou want to retrieve a list of unsolicited messages, including both\nNsingle line messages and multiple line messages.\nN\nI  CONSOLE ACTIVATE\nI\nI  msgindex = 0\nI  mrc = 0\nI  DO WHILE mrc = 0\nI    SAY \"WAIT UP TO 15 SECONDS FOR MESSAGE TRAFFIC.\"\nI    mrc = GETMSG(\"cnsl.\",\"UNSOL\",,,15)\nI    IF mrc > 0 THEN LEAVE\nI    DO i = 1 TO cnsl.0\nI      msgindex = msgindex + 1\nI      msg.msgindex = cnsl.i\nI    END\nI  END\nI  msg.0 = msgindex\nI  DO i = 1 TO msg.0\nI    SAY msg.i\nI  END\nI\nI  CONSOLE DEACTIVATE\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0472": {"ttr": 44033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x01W\\x01W\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:59", "lines": 343, "newlines": 343, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0472\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-LISTDSI\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175859\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNLISTDSI\nN-------\nNLISTDSI LISTDSI returns one of the following function codes that\nNreplace the function call, and retrieves information about a data\nNset's allocation, protection, and directory and stores it in specific\nNvariables.\nN\nN\nNSyntax:\nD  LISTDSI( data-set-name location | filename file ,\nD    directory recall smsinfo)\nN\nN\nNExample\nN-------\nI  dsi_name = \"'VENDOR.GENIE.WISHLIST'\"\nI  dsi_loc = \"\"                            /* Default, Catalog search */\nI  dsi_options = \"NODIRECTORY\"                             /* Default */\nI  Call check_listdsi_rc\nI\nI  dsi_options = \"DIRECTORY\"\nI  Call check_listdsi_rc\nI\nI  dsi_options = \"DIRECTORY NORECALL\"\nI  Call check_listdsi_rc\nI\nI  dsi_options = \"DIRECTORY RECALL\"      /* Default is from DASD-Only */\nI  Call check_listdsi_rc\nI\nI  dsi_options = \"DIRECTORY SMSINFO\"\nI  Call check_listdsi_rc\nI\nI  dsi_loc = \"Volume(\"sysvolume\")\"                 /* Specific VOLSER */\nI  dsi_options = \"DIRECTORY\"\nI  Call check_listdsi_rc\nI\nI  Address TSO \"Allocate File(LISTDSI) SHR REUSE\",\nI    \"Dataset(\"dsi_name\")\"\nI  dsi_loc = \"PreAlloc\"                             /* Catalog search */\nI  Call check_listdsi_rc\nI\nI  dsi_loc = \"FILE\"                                  /* DDNAME search */\nI  dsi_name = \"LISTDSI\"\nI  Call check_listdsi_rc\nI  Address TSO \"Free File(LISTDSI)\"\nI\nI  Say \"Wrong volume:\"\nI  dsi_loc = \"Volume(CSI002)\"                      /* Specific VOLSER */\nI  dsi_options = \"DIRECTORY\"\nI  Call check_listdsi_rc\nI\nI  Say \"Wrong dsname:\"\nI  dsi_name = \"'VENDOR.GENIE.SAMPLES'\"\nI  dsi_loc = \"\"\nI  dsi_options = \"DIRECTORY\"\nI  Call check_listdsi_rc\nI\nI  Return 0\nI\nIcheck_listdsi_rc:\nI  Say \"ListDSI(\"dsi_name dsi_loc dsi_options\") testing results:\"\nI  your_msg = Msg(\"OFF\")          /* hide TSO/E messages from LISTDSI */\nI  listdsi_rc = ListDSI(dsi_name dsi_loc dsi_options)\nI  my_msg = Msg(your_msg)\nI  Select\nI    When (listdsi_rc = 0) Then DO                /* Complete success */\nI      Call show_listdsi\nI    End\nI    When (listdsi_rc = 4) Then DO                 /* Partial success */\nI      Call show_partial_listdsi\nI    End\nI    When (listdsi_rc = 16) Then DO                     /* No success */\nI      Say \"ListDSI failed, RC(\"listdsi_rc\")\"\nI      Say \"  SYSREASON (\"sysreason\")\"\nI      Call show_sysreason\nI      Say \"  SYSMSGLVL1(\"sysmsglvl1\")\"\nI      Say \"  SYSMSGLVL2(\"sysmsglvl2\")\"\nI    End\nI    Otherwise DO\nI      Say \"Unexpected RC(\"listdsi_rc\")\"\nI    END\nI  End\nI  Return 0\nI\nIshow_listdsi:\nI  Say dsi_name \"listed okay.\"\nI  Say \"  SYSDSNAME    (\"sysdsname\")\"\nI  Say \"  SYSVOLUME    (\"sysvolume\")\"\nI  Say \"  SYSUNIT      (\"sysunit\")\"\nI  Say \"  SYSDSORG     (\"sysdsorg\")\"\nI  Select\nI    When (sysdsorg = \"PS\")  Then Say \"    Physical Sequential\"\nI    When (sysdsorg = \"PSU\") Then Say \"    Physical Sequential unmovable\"\nI    When (sysdsorg = \"DA\")  Then Say \"    Direct organization\"\nI    When (sysdsorg = \"DAU\") Then Say \"    Direct organization unmovable\"\nI    When (sysdsorg = \"IS\")  Then Say \"    Indexed Sequential\"\nI    When (sysdsorg = \"ISU\") Then Say \"    Indexed Sequential unmovable\"\nI    When (sysdsorg = \"PO\")  Then Say \"    Partitioned organization\"\nI    When (sysdsorg = \"POU\") Then,\nI      Say \"    Partitioned organization unmovable\"\nI    When (sysdsorg = \"VS\")  Then Say \"    VSAM\"\nI    When (sysdsorg = \"???\") Then Say \"    Unknown\"\nI    Otherwise,\nI      Say \"    Unexpected DSORG(\"sysdsorg\")\"\nI  End\nI  Say \"  SYSRECFM     (\"sysrecfm\")\"\nI  Select\nI    When (Pos(\"U\",sysrecfm) > 0)  Then,\nI      Say \"    Undefined record length\"\nI    When (Pos(\"F\",sysrecfm) > 0)  Then,\nI      Say \"    Fixed record length\"\nI    When (Pos(\"V\",sysrecfm) > 0)  Then,\nI      Say \"    Variable record length\"\nI    When (Pos(\"T\",sysrecfm) > 0)  Then,\nI      Say \"    Track overflow feature\"\nI    When (Pos(\"B\",sysrecfm) > 0)  Then,\nI      Say \"    Blocked\"\nI    When (Pos(\"S\",sysrecfm) > 0)  Then,\nI      Say \"    Standard or spanned records\"\nI    When (Pos(\"A\",sysrecfm) > 0)  Then,\nI      Say \"    ASCII control characters\"\nI    When (Pos(\"M\",sysrecfm) > 0)  Then,\nI      Say \"    Machine code control characters\"\nI    When (Pos(\"??????\",sysrecfm) > 0)  Then,\nI      Say \"    Unknown\"\nI    Otherwise,\nI      Say \"    Unexpected RECFM(\"sysrecfm\")\"\nI  End\nI  Say \"  SYSLRECL     (\"syslrecl\")\"\nI  Say \"  SYSBLKSIZE   (\"sysblksize\")\"\nI  Say \"  SYSKEYLEN    (\"syskeylen\")\"\nI  Say \"  SYSALLOC     (\"sysalloc\")\"\nI  Say \"  SYSUSED      (\"sysused\")\"\nI  Say \"  SYSUSEDPAGES (\"sysusedpages\")\"\nI  Say \"  SYSPRIMARY   (\"sysprimary\")\"\nI  Say \"  SYSSECONDS   (\"sysseconds\")\"\nI  Say \"  SYSUNITS     (\"sysunits\")\"\nI  Select\nI    When (sysunits = \"CYLINDER\") Then,\nI      Say \"    CYL\"\nI    When (sysunits = \"TRACK\") Then,\nI      Say \"    TRK\"\nI    When (sysunits = \"BLOCK\") Then,\nI      Say \"    BLK\"\nI    When (sysunits = \"??????\") Then,\nI      Say \"    UNK\"\nI    Otherwise,\nI      Say \"    Unexpected UNITS(\"sysunits\")\"\nI  End\nI  Say \"  SYSEXTENTS   (\"sysextents\")\"\nI  Say \"  SYSCREATE    (\"syscreate\")\"\nI  Say \"  SYSREFDATE   (\"sysrefdate\")\"\nI  Say \"  SYSEXDATE    (\"sysexdate\")\"\nI  Say \"  SYSPASSWORD  (\"syspassword\")\"\nI  Select\nI    When (syspassword = \"NONE\") Then,\nI      Say \"    No password protection, and that is a good thing.\"\nI    When (syspassword = \"READ\") Then,\nI      Say \"    A password is reguired to read the dataset, bad.\"\nI    When (syspassword = \"WRITE\") Then,\nI      Say \"    A password is reguired to write the dataset, worse.\"\nI    Otherwise,\nI      Say \"    Unexpected PASSWORD(\"syspassword\")\"\nI  End\nI  Say \"  SYSRACFA     (\"sysracfa\")\"\nI  Select\nI    When (sysracfa = \"NONE\") Then,\nI      Say \"    No RACF protection, and that is a bad thing.\"\nI    When (sysracfa = \"GENERIC\") Then,\nI      Say \"    A generic profile covers this dataset, good.\"\nI    When (sysracfa = \"DISCRETE\") Then,\nI      Say \"    A discrete profile covers this dataset, try generics.\"\nI    Otherwise,\nI      Say \"    Unexpected RACF(\"sysracfa\")\"\nI  End\nI  Say \"  SYSUPDATED   (\"sysupdated\")\"\nI  Select\nI    When (sysupdated = \"YES\") Then,\nI      Say \"    Dataset has been updated since the last backup.\"\nI    When (sysupdated = \"NO\") Then,\nI      Say \"    Dataset is still the same since the last backup.\"\nI    Otherwise,\nI      Say \"    Unexpected UPDATE(\"sysupdated\")\"\nI  End\nI  Say \"  SYSTRKSCYL   (\"systrkscyl\")\"\nI  Say \"  SYSBLKSTRK   (\"sysblkstrk\")\"\nI  If (Pos(\"PO\",sysdsorg) > 0) Then,\nI    Do\nI      Say \" SYSADIRBLK   (\"sysadirblk\")\"\nI      Say \" SYSUDIRBLK   (\"sysudirblk\")\"\nI      Say \" SYSMEMBERS   (\"sysmembers\")\"\nI    End\nI  Say \"  SYSREASON    (\"sysreason\")\"\nI  Call show_sysreason\nI  Say \"  SYSMSGLVL1   (\"sysmsglvl1\")\"\nI  Say \"  SYSMSGLVL2   (\"sysmsglvl2\")\"\nI  Say \"  SYSDSSMS     (\"sysdssms\")\"\nI  Select\nI    When (sysdssms = \"SEQ\") Then,\nI      Say \"    DSNTYPE not retrieved, Sequential dataset.\"\nI    When (sysdssms = \"PDS\") Then,\nI      Say \"    DSNTYPE not retrieved, Partitioned dataset.\"\nI    When (sysdssms = \"PDSE\") Then,\nI      Say \"    DSNTYPE not retrieved, Partitioned dataset extended.\"\nI    When (sysdssms = \"LIBRARY\") Then,\nI      Say \"    Empty PDSE.\"\nI    When (sysdssms = \"PROGRAM_LIBRARY\") Then,\nI      Say \"    Program PDSE.\"\nI    When (sysdssms = \"DATA_LIBRARY\") Then,\nI      Say \"    Data PDSE.\"\nI    Otherwise,\nI      Say \"    Unexpected DSSMS(\"sysdssms\")\"\nI  End\nI  If (Pos(\"SMSINFO\",dsi_options) > 0) Then,\nI    Do\nI      Say \"  SYSDATACLASS (\"sysdataclass\")\"\nI      Say \"  SYSSTORCLASS (\"sysstorclass\")\"\nI      Say \"  SYSMGMTCLASS (\"sysmgmtclass\")\"\nI    End\nI  If (Pos(\"S\",sysdsorg) > 0)  Then,\nI    Do\nI      Say \"  SYSSEQDSNTYPE(\"sysseqdsntype\")\"\nI      Select\nI        When (sysseqdsntype = \"BASIC\") Then,\nI          Say \"    Regular Sequential dataset.\"\nI        When (sysseqdsntype = \"LARGE\") Then,\nI          Say \"    Large Sequential dataset.\"\nI        When (sysseqdsntype = \"EXTENDED\") Then,\nI          Say \"    Extended Sequential dataset.\"\nI        Otherwise,\nI          Say \"    Unexpected SEQDSNTYPE(\"sysseqdsntype\")\"\nI      End\nI    End\nI  Return 0\nI\nIshow_partial_listdsi:\nI  Say dsi_name \"partially listed.\"\nI  SYSDATACLASS = \"NON-SMS\"\nI  SYSSTORCLASS = \"NON-SMS\"\nI  SYSMGMTCLASS = \"NON-SMS\"\nI  Call show_listdsi\nI  Return 0\nI\nIshow_sysreason:\nI  my_sysreason = Right(sysreason,2)\nI  If (listdsi_rc = 4) Then my_sysreason = 30\nI  Say \"SYSMSGLVL2 = IKJ584\"my_sysreason\"I:\"\nI  Select\nI    When (sysreason = 00) Then,\nI      Say \"    Normal completion\"\nI    When (sysreason = 01) Then,\nI      Say \"    Error parsing the function.\"\nI    When (sysreason = 02) Then,\nI      Say \"    Dynamic allocation processing error.\"\nI    When (sysreason = 03) Then,\nI      Say \"    The data set is a type that can not be processed.\"\nI    When (sysreason = 04) Then,\nI      Say \"    Error determining UNIT name.\"\nI    When (sysreason = 05) Then,\nI      Say \"    Data set is not catalogued.\"\nI    When (sysreason = 06) Then,\nI      Say \"    Error obtaining the dataset name.\"\nI    When (sysreason = 07) Then,\nI      Say \"    Error finding the device type.\"\nI    When (sysreason = 08) Then,\nI      Say \"    The dataset is not on a DASD volume.\"\nI    When (sysreason = 09) Then,\nI      Say \"    NORECALL prevented retrieval of information.\"\nI    When (sysreason = 11) Then,\nI      Say \"    DIRECTORY specified, but you lack read access.\"\nI    When (sysreason = 12) Then,\nI      Say \"    VSAM datasets not supported.\"\nI    When (sysreason = 13) Then,\nI      Say \"    The dataset could not be opened.\"\nI    When (sysreason = 14) Then,\nI      Say \"    Device type not found in UCB tables.\"\nI    When (sysreason = 17) Then,\nI      Say \"    System or User abend occurred.\"\nI    When (sysreason = 18) Then,\nI      Say \"    Partial dataset information returned.\"\nI    When (sysreason = 19) Then,\nI      Say \"    Multi-volume dataset.\"\nI    When (sysreason = 20) Then,\nI      Say \"    Device type not found in EDT table.\"\nI    When (sysreason = 21) Then,\nI      Say \"    Catalog locate error.\"\nI    When (sysreason = 22) Then,\nI      Say \"    Volume not mounted.\"\nI    When (sysreason = 23) Then,\nI      Say \"    Permanent I/O error on volume.\"\nI    When (sysreason = 24) Then,\nI      Say \"    Data set not found.\"\nI    When (sysreason = 25) Then,\nI      Say \"    Migrated to non-DASD volume.\"\nI    When (sysreason = 26) Then,\nI      Say \"    MSS device.\"\nI    When (sysreason = 27) Then,\nI      Say \"    No VOLSER assigned.\"\nI    When (sysreason = 28) Then,\nI      Say \"    DDname not one to eight valid characters.\"\nI    When (sysreason = 29) Then,\nI      Say \"    You need to sepcify either a dataset name or ddname.\"\nI    When (sysreason = 30) Then,\nI      Say \"    Not SMS managed.\"\nI    When (sysreason = 31) Then,\nI      Say \"    ISITMGD macro had a problem, see sysmsglvl2.\"\nI    When (sysreason = 32) Then,\nI      Say \"    DFSMS/MVS level incompatability.\"\nI    When (sysreason = 33) Then,\nI      Say \"    DFSMS/MVS is not active.\"\nI    When (sysreason = 34) Then,\nI      Say \"    OPEN error.\"\nI    When (sysreason = 35) Then,\nI      Say \"    Unexpected error from DFSMS/MVS IGWFAMS routine.\"\nI    When (sysreason = 36) Then,\nI      Say \"    Unexpected error from SMS service module.\"\nI    When (sysreason = 37) Then,\nI      Say \"    Unexpected error from DFSMS service IGGCSI00.\"\nI    Otherwise,\nI      Say \"    Unexpected sysreason(\"sysreason\")\"\nI  End\nI  Return 0\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0473": {"ttr": 44035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:59", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0473\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-MSG\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175859\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNMSG\nN---\nNMSG MSG returns the value ON or OFF, which indicates the status of the\nNdisplaying of TSO/E messages. That is, MSG indicates whether TSO/E\nNmessages are being displayed while the exec is running.\nN\nN\nNSyntax:\nD  MSG(option)\nI    option: ON | OFF\nN\nI      ON: returns the previous status of message issuing (ON or OFF)\nI          and allows TSO/E informational messages to be displayed while\nI          an exec is running.\nN\nI      OFF: returns the previous status of message issuing (ON or OFF)\nI           and inhibits the display of TSO/E informational messages\nI           while an exec is running.\nN\nN\nNExample\nN-------\nI  SAY \"MSG(ON) SHOWS:\"\nI  ADDRESS TSO \"FREE FILE(ddname)\"\nI  msg_val = MSG(\"OFF\")\nI  Say \"MSG was(\"msg_val\")\"\nI  SAY \"No messages from this failure.\"\nI  ADDRESS TSO \"FREE FILE(ddname)\"\nI  msg_val = MSG()\nI  msg_val = Msg(msg_val)\nI  Say \"MSG was(\"msg_val\")\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0474": {"ttr": 44037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00{\\x00{\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:59", "lines": 123, "newlines": 123, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0474\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-MVSVAR\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175859\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNMVSVAR\nN-------\nNMVSVAR MVSVAR returns information about MVS, TSO/E, and the current\nNsession, such as the symbolic name of the MVS system, or the security\nNlabel of the TSO/E session.\nN\nNThe MVSVAR function is available in any MVS address space.\nN\nN\nNSyntax:\nD  MVSVAR(arg_name)\nI    arg_name: One of:\nN\nI      SYSAPPCLU the APPC/MVS logical unit (LU) name\nI      SYSDFP    the level of DFSMSdfp, a basic element of the operating\nI                system\nI      SYSMVS    the level of the base control program (BCP) component\nI                of z/OS\nI      SYSNAME   the name of the system your REXX exec is running on, as\nI                specified in the SYSNAME statement in SYS1.PARMLIB\nI                member IEASYSxx\nI      SYSOPSYS  the z/OS name, version, release, modification level,\nI                and FMID\nI      SYSSECLAB the security label (SECLABEL) name of the TSO/E session\nI      SYSSMFID  identification of the system on which System Management\nI                Facilities (SMF) is active\nI      SYSSMS    indicator whether SMS (storage management subsystem) is\nI                running on the system\nI      SYSCLONE  MVS system symbol representing its system name\nI      SYSPLEX   the MVS sysplex name as found in the COUPLExx or\nI                LOADxx member of SYS1.PARMLIB\nI      SYMDEF    symbolic variables of your MVS system\nN\nN\nNExample\nN-------\nI  Signal ON Error   Name No_APPCLU\nI  Signal ON Syntax  Name No_APPCLU\nI  return_point = \"next_mvsvar\"\nI/*\nII have been unable to hide this error message using MSG() and OutTrap()\nIWould it not be nice if IBM used a normal write function?\nI\nIIRX0236E SYSAPPCLU argument failed because the service ATBEXAI\nIreturned with return code 0044.\nI\nIYou will be better off only using MVSVAR(\"SYSAPPCLU\") if you are\nIreally using APPC.\nI\nIYou also need to use SIGNAL for both ERROR and SYNTAX if you\nIwant to handle the \"ERROR\" yourself.\nI\nI*/\nI  mvsvar_sysappclu = MvsVar(\"SYSAPPCLU\")\nI\nInext_mvsvar:\nI  mvsvar_sysdfp    = MvsVar(\"SYSDFP\")\nI  mvsvar_sysmvs    = MvsVar(\"SYSMVS\")\nI  mvsvar_sysname   = MvsVar(\"SYSNAME\")\nI  mvsvar_sysopsys  = MvsVar(\"SYSOPSYS\")\nI  mvsvar_sysseclab = MvsVar(\"SYSSECLAB\")\nI  mvsvar_syssmfid  = MvsVar(\"SYSSMFID\")\nI  mvsvar_syssms    = MvsVar(\"SYSSMS\")\nI\nI  mvsvar_sysclone  = MvsVar(\"SYSCLONE\")\nI  mvsvar_sysplex   = MvsVar(\"SYSPLEX\")\nI\nI  Call show_mvsvars\nI\nI  SAY \"\"\nI  SAY \"Use the MVS console command:\"\nI  SAY \"D SYMBOLS\"\nI  SAY \"to display the current symbols on your system.\"\nI\nI  symdef_sysalvl   = MvsVar(\"SYMDEF\",\"SYSALVL\")\nI  Say \"A   level(\"symdef_sysalvl\")\"\nI  symdef_sysr1     = MvsVar(\"SYMDEF\",\"SYSR1\")\nI  Say \"SYSRES 1 (\"symdef_sysr1\")\"\nI  symdef_unixver   = MvsVar(\"SYMDEF\",\"UNIXVER\")\nI  Say \"UNIX ver (\"symdef_unixver\")\"\nI\nI  Return 0\nI\nINo_APPCLU:\nI  Signal OFF Error\nI  Signal OFF Syntax\nI  mvsvar_sysappclu = \"\"\nI  interpret \"Signal\" return_point\nI  Exit 24\nI\nIshow_mvsvars:\nI  Say \"APPC LU  (\"mvsvar_sysappclu\")\"\nI  Say \"DFP level(\"mvsvar_sysdfp\")\"\nI  Say \"MVS level(\"mvsvar_sysmvs\")\"\nI  Say \"SYSNAME  (\"mvsvar_sysname\")\"\nI  Say \"OpSys lvl(\"mvsvar_sysopsys\")\"\nI  Say \"SYSSECLAB(\"mvsvar_sysseclab\")\"\nI  Say \"SMF ID   (\"mvsvar_syssmfid\")\"\nI  Say \"SMS level(\"mvsvar_syssms\")\"\nI  Say \"CLONE    (\"mvsvar_sysclone\")\"\nI  Say \"PLEXname (\"mvsvar_sysplex\")\"\nI  Return 0\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0475": {"ttr": 44039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17X\\x00k\\x00k\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:58:59", "lines": 107, "newlines": 107, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0475\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-OUTTRAP\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175859\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNOUTTRAP\nN-------\nNOUTTRAP returns the name of the variable in which trapped output is\nNstored, or if trapping is not in effect, OUTTRAP returns the word off.\nN\nMIf you plan to write your own command processors for use in REXX execs,\nMand you plan to use the OUTTRAP external function to trap command\nMoutput, note the OUTTRAP function does not trap command output that\nMis sent to the terminal by:\nN\nM-> TPUT\nM-> WTO macro\nM-> messages issued by TSO/E REXX (that is, messages beginning with IRX)\nM-> messages issued by TRACE output\nN\nN\nNSyntax:\nD  OUTTRAP(off | varname,max ,concat | noconcat, skipamt)\nI    off     specify the word OFF to turn trapping off.\nN\nI    varname the stem of the compound variables or the variable prefix\nI            assigned to receive the command output. Compound variables\nI            contain a period and allow for indexing, but lists of\nI            variables with the same prefix cannot be accessed by an\nI            index in a loop.\nN\nI      Note: Do not use 'OFF' as a variable name.\nN\nI    max     the maximum number of lines to trap. You can specify a\nI            number, an asterisk in quotation marks (\"*\"), or a blank.\nI            If you specify \"*\" or a blank, all the output is trapped.\nI            The default is 999,999,999. If the maximum number of lines\nI            are trapped, subsequent lines are not stored in variables.\nN\nI    concat  indicates how output should be trapped. For concat,\nI            specify one of the following:\nI            -> CONCAT   indicates that output from commands be trapped\nI                        in consecutive order until the maximum number\nI                        of lines is reached. For example, if the first\nI                        command has three lines of output, they are\nI                        stored in variables ending in 1, 2, and 3. If\nI                        the second command has two lines of output,\nI                        they are stored in variables ending in 4 and 5.\nI                        The default order for trapping is CONCAT.\nN\nI            -> NOCONCAT indicates that output from each command be\nI                        trapped starting at the variable ending in 1.\nI                        For example, if the first command has three\nI                        lines of output, they are stored in variables\nI                        ending in 1, 2, and 3. If another command has\nI                        two lines of output, they replace the first\nI                        command's output in variables 1 and 2.\nN\nI    skipamt specifies the number of lines to be skipped before trapping\nI            begins. If skipamt is not specified, the default is 0. The\nI            highest skip amount allowed is 999,999,999.\nN\nN\nNExample\nN-------\nI  max_amount = 2500                   /* Default, max is 999,999,999 */\nI  append_value = \"CONCAT\"                   /* Default, try NOCONCAT */\nI  skip_amount = 2                     /* Default, max is 999,999,999 */\nI  outtrap_value = OutTrap(\"STEM.\")\nI  /*\nI  outtrap_value = OutTrap(\"STEM.\",max_amount,append_value)\nI  outtrap_value = OutTrap(\"STEM.\",max_amount,append_value,skip_amount)\nI  */\nI  Say Userid()\nI  Address TSO,\nI    \"LISTCAT LEVEL('\"Userid()\"') ALL\"\nI  listcat_rc = RC\nI  outtrap_value = OutTrap(\"OFF\")\nI\nI  Say \"stemVARIABLES\"\nI  Say \"LISTCAT RC(\"listcat_rc\")\"\nI  Say \"stem0(\"STEM.0\")\"\nI  Say \"stemMAX(\"STEM.MAX\")\"\nI  Say \"stemCON(\"STEM.CON\")\"\nI  Say \"stemSKIPPED(\"STEM.SKIPPED\")\"\nI  Say \"stemTRAPPED(\"STEM.TRAPPED\")\"\nI  Say \"stemSKIPAMT(\"STEM.SKIPAMT\")\"\nI  Say \"stem#:\"\nI  Do loop_ctr = 1 To STEM.0\nI    Say STEM.loop_ctr\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0476": {"ttr": 44289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0476\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-PROMPT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175900\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNPROMPT\nN-------\nNPROMPT returns the value ON or OFF, which indicates the setting of\nNprompting for the exec.\nN\nN\nNSyntax:\nD  PROMPT(option)\nI    option: ON | OFF\nN\nI      ON  returns the previous setting of prompt (ON or OFF) and sets\nI          prompting on for TSO/E commands issued within an exec.\nN\nI      OFF returns the previous setting of prompt (ON or OFF) and sets\nI          prompting off for TSO/E commands issued within an exec.\nN\nN\nNExample\nN-------\nI  SAY \"Override if the interactive TSO/E commands can prompt for\"\nI  SAY \"input if the STACK is does not contain all the input it needs.\"\nI  SAY \"This is easily shown by not queueing any input for TRANSMIT.\"\nI\nI  prompt_value = Prompt()                   /* Just get the setting. */\nI  Say \"Prompting:\" prompt_value\nI\nI  prompt_value = Prompt(\"OFF\")            /* Do not prompt for input */\nI  Say \"Prompting:\" prompt_value\nI  Address TSO \"Transmit\"\nI  tso_rc = RC\nI  Say \"Transmit(\"tso_rc\")\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0477": {"ttr": 44291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00K\\x00K\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0477\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SETLANG\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175900\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSETLANG\nN-------\nNSETLANG SETLANG returns a three character code that indicates the\nNlanguage in which REXX messages are currently being displayed.\nN\nN\nNSyntax:\nD  SETLANG(language_code)\nI    language_code: One of:\nI      CHS: Simplified Chinese\nI      CHT: Traditional Chinese\nI      DAN: Danish\nI      DEU: German\nI      ENP: US English - all uppercase\nI      ENU: US English - mixed case (upper and lowercase)\nI      ESP: Spanish\nI      FRA: French\nI      JPN: Japanese\nI      KOR: Korean\nI      PTB: Brazilian Portuguese\nN\nN\nNExample\nN-------\nI  current_language = SetLang()\nI  Say current_language\nI  Select\nI    When (current_language = \"CHS\") Then,\nI      Say \"Simplified Chinese\"\nI    When (current_language = \"CHT\") Then,\nI      Say \"Simplified Chinese\"\nI    When (current_language = \"DAN\") Then,\nI      Say \"Danish\"\nI    When (current_language = \"DEU\") Then,\nI      Say \"German (Deutsch)\"\nI    When (current_language = \"ENP\") Then,\nI      Say \"English (Proper - all upper case)\"\nI    When (current_language = \"ENU\") Then,\nI      Say \"English (upper and lower case)\"\nI    When (current_language = \"ESP\") Then,\nI      Say \"Castillian Spanish\"\nI    When (current_language = \"FRA\") Then,\nI      Say \"French\"\nI    When (current_language = \"JPN\") Then,\nI      Say \"Japanese\"\nI    When (current_language = \"KOR\") Then,\nI      Say \"Korean\"\nI    When (current_language = \"PTB\") Then,\nI      Say \"Portuguese, Brazilian\"\nI    Otherwise,\nI      Say \"Ever hear the joke, it is all Greek to me?\"\nI      Say \"I am not programmed to understand what\",\nI        current_language \"means.\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0478": {"ttr": 44293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0478\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-STORAGE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175900\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSTORAGE\nN-------\nNSTORAGE returns length bytes of data from the specified address in\nNstorage. The address is a character string containing the hexadecimal\nNrepresentation of the storage address from which data is retrieved.\nN\nN\nNA very dangerous instruction because it will lead you to\nNfollow control blocks instead of using 'supported' methods. And\nNwhen a vendor changes the control blocks, your code fails.\nNSometimes, as happened with UCBs, access via control blocks is\nNtotally removed and you are left scrambling for a new solution.\nN\nN\nMHow can you change data? Use an assembler program to GETMAIN some\nMstorage and pass you the address of where it is.\nN\nN\nNSyntax:\nD  storage_value = Storage(hex_addr,length,new_value)\nI    hex_addr: The storage address you want to reference.\nN\nI    length:   How much storage to retrieve.\nN\nI    new_value: For your storage only, a new value.\nN\nN\nNExample\nN-------\nI  cvt_ptr = Storage(00000010,4)\nI  SAY \"The cvt pointer refers to address:\" C2X(cvt_ptr)\".\"\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0479": {"ttr": 44295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00:\\x00:\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0479\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SYSCPUS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175900\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSYSCPUS\nN-------\nNSYSCPUS places, in a stem variable, information about those CPUs that\nNare online.\nN\nNThe number of online CPUs is returned in variable cpus_stem.0. The\nNserial numbers of each of those CPUs are returned in variables whose\nNnames are derived by appending a number (1 through cpus_stem.0) to the\nNstem. Trailing blanks are removed. The serial number is obtained from\nNthe field PCCACPID in the MVS control block IHAPCCA. On a z990 machine\nNor later, all CPU numbers are identical; therefore, SYSCPUS returns\nNthe same value for all CPUs.\nN\nN\nNSyntax:\nD  SYSCPUS(cpus_stem)\nI    cpus_stem: The name of a stem variable where you want to capture\nI               the serial and model numbers.\nN\nN\nNExample\nN-------\nI  syscpus_rc = SysCPUs(\"CPUS.\")\nI\nI  Say \"RC =\" syscpus_rc\nI  Say \"0 = Function performed okay:\"\nI  Say \"4 = CPU vary was occurring at the time the function was used.\"\nI  Say \"Number of on-line CPs:\" cpus.0\nI  Say \"If you follow control blocks IHAPCCA->PCCACPID = serial number.\"\nI  Say \"z990 and newer machines will show the same serial number\",\nI    \"for all CPs.\"\nI  Do loop_ctr = 1 To cpus.0\nI    Parse Var cpus.loop_ctr,\nI      cp_serial +6,\nI      cp_model\nI    Say \"CP#\"loop_ctr \"- Model(\"cp_model\") Serial(\"cp_serial\")\"\nI  End\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0480": {"ttr": 44297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00`\\x00`\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:01", "lines": 96, "newlines": 96, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0480\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SYSDSN\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175901\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSYSDSN\nN-------\nNSYSDSN SYSDSN returns one of the following messages indicating whether\nNthe specified dsname exists and is available for use. The dsname can be\nNthe name of any cataloged data set or cataloged partitioned data set\nNwith a member name. Additionally, if you specify a member of a\nNpartitioned data set, SYSDSN checks to see if you have access to the\nNdata set.\nN\nN-> OK                         /* data set or member is available */\nN-> MEMBER NOT FOUND\nN-> MEMBER SPECIFIED, BUT DATASET IS NOT PARTITIONED\nN-> DATASET NOT FOUND\nN-> ERROR PROCESSING REQUESTED DATASET /* This error can be presented\nN                       if there is an error parsing the data set name\nN                       provided, an error on the dynamic allocation\nN                       (SVC 99) of the data set, or an error during\nN                       OPEN processing. Review the joblog and syslog\nN                       for any error messages that may help identify\nN                       what error was encountered */\nN-> PROTECTED DATASET /* a member was specified and RACF prevents this\nN                        user from accessing this data set */\nN-> VOLUME NOT ON SYSTEM\nN-> INVALID DATASET NAME, dsname\nN-> MISSING DATASET NAME\nN-> UNAVAILABLE DATASET /* another user has an exclusive ENQ on the\nN                          specified data set */\nN\nN\nNSyntax:\nD  SYSDSN(dsname)\nI    dsname: A proper data set name, with or without a member. A GDG\nI            must specify the G0000V00.\nN\nN\nNExample\nN-------\nI  SAY \"  Checks if the dataset exists.\"\nI  sysdsn_rc = SysDsn(\"'some.dataset.name'\")\nI  SAY sysdsn_rc \"WHEN CHECKING 'some.dataset.name'\"\nI  SAY \"  Checks if the dataset(member) exists.\"\nI  sysdsn_rc = SysDsn(\"'SYS1.PARMLIB(ieasys00)'\")\nI  SAY sysdsn_rc \"WHEN CHECKING 'SYS1.PARMLIB(ieasys00)'\"\nI\nI  SAY \"This does not check that you have a properly formed dataset name\"\nI  SAY \"before attempting to allocate it. If you botched it, you will\"\nI  SAY \"get a IKJ56709I INVALID DATA SET NAME, <your-dataset-name-here>\"\nI  SAY \"message. You can also get ICH401D messages if you are not\"\nI  SAY \"authorized to access the dataset with at least ACCESS(READ).\"\nI  SAY \"You can hide the messages using MSG(\"OFF\").\"\nI\nI  dsnvar = \"'some.dataset.name(member)'\"\nI  msg_rc = MSG(\"OFF\")\nI  sysdsn_rc = SysDsn(dsnvar)\nI  msg_rc = MSG(\"ON\")\nI  Select\nI    When (sysdsn_rc == \"OK\") Then DO\nI      Say \"'\"some.dataset.name\"' was found.\"\nI      sysdsn_rc = 0\nI    End\nI    When (sysdsn_rc == \"MEMBER NOT FOUND\") Then DO\nI      Say \"'\"some.dataset.name\"' was not found.\"\nI      sysdsn_rc = 82\nI    End\nI    When (sysdsn_rc == \"DATASET NOT FOUND\") Then DO\nI      Say \"'\"some.dataset.name\"' was not found.\"\nI      sysdsn_rc = 12\nI    End\nI    Otherwise DO\nI      Say \"'\"some.dataset.name\"'\" sysdsn_rc\".\"\nI      sysdsn_rc = 20\nI    END\nI  End\nI\nI  End of <sysdsn>\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0481": {"ttr": 44545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x01\\xd1\\x01\\xd1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:01", "lines": 465, "newlines": 465, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0481\nTz/OS TSO/E REXX Reference\nT-Chapter 4.\nT-Built-in functions\nT-SYSVAR\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175901\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 4. Functions\nN--------------------\nNBuilt-in functions\nN------------------\nNSYSVAR\nN-------\nNSYSVAR returns information about MVS, TSO/E, and the current session,\nNsuch as levels of software available, your logon procedure, and your\nNuser ID. The information returned depends on the arg_name value\nNspecified on the function call. The arg_name values are divided into\nNthe following categories of information: user, terminal, exec, system,\nNlanguage, and console session information. The different categories\nNare described below.\nN\nN\nNSyntax:\nD  SYSVAR(arg_name)\nI    arg_name: One of:\nI      User Information: Use the following arguments to obtain\nI                        information related to the user.\nI        SYSPREF the prefix as defined in the user profile. The prefix\nI                is the string that is prefix to data set names that\nI                are not fully-qualified. The prefix is usually the\nI                user's user ID. You can use the TSO/E PROFILE command\nI                to change the prefix.\nN\nI        SYSPROC the name of the logon procedure for the current\nI                session. You can use the SYSPROC argument to determine\nI                whether certain programs, such as the TSO/E Session\nI                Manager, are available to the user.\nN\nI                For example, suppose your installation has the logon\nI                procedure SMPROC for the Session Manager. The exec can\nI                check that the user logged on using SMPROC before\nI                invoking a routine that uses Session Manager.\nI                Otherwise, the exec can display a message telling the\nI                user to log on using the SMPROC logon procedure.\nN\nI                SYSPROC returns the following values:\nI                -> When the REXX exec is invoked in the foreground\nI                   (SYSVAR('SYSENV') returns 'FORE'), SYSVAR('SYSPROC')\nI                   will return the name of the current LOGON procedure.\nI                -> When the REXX exec is invoked in batch (for example,\nI                   from a job submitted by using the SUBMIT command),\nI                   SYSVAR('SYSPROC') will return the value 'INIT',\nI                ->which is the ID for the initiator.\nI                -> When the REXX exec is invoked from a Started Task\nI                  (for example, an address space that is started by\nI                  using the Start operator command), SYSVAR('SYSPROC')\nI                  will return the ID of the started task. If\nI                  'S procname' is issued from the operator console,\nI                  the SYSVAR('SYSPROC') function will return the value\nI                  'procname'.\nN\nI        SYSUID the user ID under which the current TSO/E session is\nI               logged on. The SYSUID argument returns the same value\nI               that the USERID built-in function returns in a TSO/E\nI               address space.\nN\nI      Terminal Information: Use the following arguments to obtain\nI                            information related to the terminal.\nN\nI        SYSLTERM number of lines available on the terminal screen. In\nI                 the background, SYSLTERM returns 0.\nN\nI        SYSWTERM width of the terminal screen. In the background,\nI                 SYSWTERM returns 132.\nN\nI      Exec Information: Use the following arguments to obtain\nI                        information related to the exec.\nN\nI        SYSENV indicates whether the exec is running in the foreground\nI               or background. SYSENV returns the following values:\nI          -> FORE  exec is running in the foreground\nI          -> BACK  exec is running in the background\nN\nI          You can use the SYSENV argument to make logical decisions\nI          based on foreground or background processing.\nN\nI        SYSICMD the name by which the user implicitly invoked the exec\nI                that is currently processing. If the user invoked the\nI                exec explicitly, SYSICMD returns a null value.\nN\nI        SYSISPF indicates whether ISPF dialog manager services are\nI                available for the exec. SYSISPF returns the following\nI                values:\nI          -> ACTIVE  ISPF services are available. If the exec was\nI                      invoked under ISPF by using the TSOEXEC\nI                      interface, no ISPF services are available.\nI          -> NOT ACTIVE  ISPF services are not available.\nN\nI        SYSNEST indicates whether the exec was invoked from another\nI                program, such as an exec or CLIST. The invocation could\nI                be either implicit or explicit. SYSNEST returns YES if\nI                the exec was invoked from another program; otherwise,\nI                it returns NO.\nN\nI        SYSPCMD the name or abbreviation of the TSO/E command processor\nI                that the exec most recently processed.\nN\nI                The initial value that SYSPCMD returns depends on how\nI                you invoked the exec. If you invoked the exec using the\nI                TSO/E EXEC command, the initial value returned is EXEC.\nI                If you invoked the exec using the EXEC subcommand of\nI                the TSO/E EDIT command, the initial value returned is\nI                EDIT.\nN\nI                You can use the SYSPCMD argument with the SYSSCMD\nI                argument for error and attention processing to\nI                determine where an error or attention interrupt\nI                occurred.\nN\nI        SYSSCMD the name or abbreviation of the TSO/E subcommand\nI                processor that the exec most recently processed.\nN\nI                The initial value that SYSSCMD returns depends on how\nI                you invoked the exec. If you invoked the exec using\nI                the TSO/E EXEC command, the initial value returned is\nI                null. If you invoked the exec using the EXEC subcommand\nI                of the TSO/E EDIT command, the initial value returned\nI                is EXEC.\nN\nI                The SYSPCMD and SYSSCMD arguments are interdependent.\nI                After the initial invocation, the values that SYSPCMD\nI                and SYSSCMD return depend on the TSO/E command and\nI                subcommand processors that were most recently\nI                processed. For example, if SYSSCMD returns the value\nI                EQUATE, which is a subcommand unique to the TEST\nI                command, the value that SYSPCMD returns would be TEST.\nN\nI                You can use the SYSPCMD and SYSSCMD arguments for\nI                error and attention processing to determine where an\nI                error or attention interrupt occurred.\nN\nI      System Information: Use the following arguments to obtain\nI                          information related to the system.\nI         SYSCPU the number of seconds of central processing unit (CPU)\nI                time used during the session in the form:\nI                seconds.hundredths-of-seconds. You can use the SYSCPU\nI                argument and the SYSSRV argument, which returns the\nI                number of system resource manager (SRM) service units,\nI                to evaluate the:\nI                -> Performance of applications\nI                -> Duration of a session.\nN\nI        SYSHSM indicates the level of the Data Facility Storage\nI               Management Subsystem Hierarchical Storage Manager\nI               (DFSMShsm). SYSHSM returns the following values:\nI               -> A character string of four two-digit decimal numbers\nI                  separated by periods if DFSMShsm for OS/390 V2R10\nI                  or higher is active with PTF UW77424 applied. This\nI                  represents the four-byte level in the MQCT_VRM field\nI                  of the ARCQCT. For example, if DFSMShsm for\nI                  OS/390 V2R10 is active with PTF UW77424 applied,\nI                  SYSHSM returns: 02.02.10.00\nN\nI                  Note: For a description of the MQCT_VRM field in the\nI                        ARCQCT control block, see OS/390 V2R10.\nN\nI               -> A character string of four decimal digits if DFSMShsm\nI                  before OS/390 V2R10 is installed and active. This\nI                  represents the level of DFSMShsm. For example, if\nI                  DFSMShsm 1.5.0 is installed and active, SYSHSM\nI                  returns: 1050\nN\nI               -> A null string if the Hierarchical Storage Manager is\nI                  not active.\nN\nI        SYSJES name and level of the JES installed on your system:\nI               -> A character string indicating name of the JES plus\nI                  its version, release and modification level, for\nI                  example: JES2 OS 2.10\nI                  where JES2 is the JES name and OS 2.10 is the\nI                  JES level. These two strings are separated by a\nI                  blank character. If either the JES name or the level\nI                  returns an empty character string, then no blank\nI                  character is inserted. Trailing blanks are removed.\nN\nI               -> -INACTIVE- (please note the delimiters) if the\nI                  subsystem is not active.\nN\nI               -> -DOWNLEVEL- (please note the delimiters) if the\nI                  subsystem is neither JES2 SP4.3 or later, nor\nI                  JES3 SP5.1.1 or later.\nN\nI        SYSLRACF indicates the level of RACF installed on the system.\nI                 If RACF is not installed, SYSLRACF contains a null\nI                 value.\nN\nI        SYSNODE network node name of your installation's JES. This name\nI                identifies the local JES in a network of systems or\nI                system complexes being used for network job entry\nI                (NJE) tasks. The name that is returned derives from\nI                the NODE initialization statement of JES.\nN\nI                The SYSNODE value is returned as either of the\nI                following:\nI                -> A character string indicating the node name, for\nI                   example BOE9.\nN\nI                -> -INACTIVE- (please note the delimiters) if the\nI                   subsystem is not active.\nN\nI                -> -DOWNLEVEL- (please note the delimiters) if the\nI                   subsystem is neither JES2 SP4.3 or later, nor\nI                   JES3 SP5.1.1 or later.\nN\nI        SYSRACF indicates the status of RACF. SYSRACF returns the\nI                following values:\nI                -> AVAILABLE if RACF is installed and available\nN\nI                -> NOT AVAILABLE if RACF is installed but is not\nI                   available\nN\nI                -> NOT INSTALLED if RACF is not installed.\nN\nI        SYSSRV the number of system resource manager (SRM) service\nI               units used during the session.\nN\nI               You can use the SYSSRV argument and the SYSCPU argument,\nI               which returns the number of seconds of CPU time used, to\nI               evaluate the:\nI               -> Performance of applications\nI               -> Duration of a session.\nN\nI        SYSTERMID the terminal ID of the terminal where the REXX exec\nI                  was started.\nI                  -> A character string indicating the terminal ID.\nI                     Trailing blanks are removed.\nN\nI                  -> A null string if TSO runs in the background.\nN\nI        SYSTSOE the level of TSO/E installed on the system. For\nI                OS/390 Version 2, Release 4 and later, SYSTSOE returns\nI                2060.\nN\nI      Language Information: Use the following arguments to obtain\nI                            information related to the display of\nI                            information in different languages.\nN\nI        SYSDTERM indicates whether the user's terminal supports\nI                 Double-Byte Character Set (DBCS). SYSDTERM returns\nI                 the following values:\nI                 -> YES  Terminal supports DBCS\nI                 -> NO  Terminal does not support DBCS\nN\nI                 The SYSDTERM argument is useful if you want to display\nI                 messages or other information to the user and the\nI                 information contains DBCS characters.\nN\nI        SYSKTERM indicates whether the user's terminal supports\nI                 Katakana. SYSKTERM returns the following values:\nI                 -> YES  Terminal supports Katakana\nI                 -> NO  Terminal does not support Katakana\nN\nI                 The SYSKTERM argument is useful if you want to display\nI                 messages or other information to the user and the\nI                 information contains Katakana characters.\nN\nI        SYSPLANG a three character code that indicates the user's\nI                 primary language stored in the user profile table\nI                 (UPT).\nN\nI        SYSSLANG a three character code that indicates the user's\nI                 secondary language stored in the user profile table\nI                 (UPT).\nN\nI      Console Session Information: The console session arguments let\nI                                   you obtain information related to\nI                                   running an extended MCS console\nI                                   session that you have established\nI                                   using the TSO/E CONSOLE command.\nN\nI        The SOLDISP, UNSDISP, SOLNUM, and UNSNUM arguments provide\nI        information about the options that have been specified for a\nI        console session. The arguments relate to keywords on the TSO/E\nI        CONSPROF command. You can use the arguments to determine what\nI        options are in effect before you issue MVS system or subsystem\nI        commands or use the GETMSG function to retrieve a message.\nN\nI        SOLDISP indicates whether solicited messages that are routed\nI                to a user's console during a console session are to\nI                be displayed at the user's terminal. Solicited messages\nI                are responses from MVS system and subsystem commands\nI                that are issued during a console session.\nN\nI                SOLDISP returns the following values:\nI                -> YES - solicited messages are displayed\nI                -> NO - solicited messages are not displayed\nN\nI        UNSDISP indicates whether unsolicited messages that are routed\nI                to a user's console during a console session are to be\nI                displayed at the user's terminal. Unsolicited messages\nI                are messages that are not direct responses from MVS\nI                system and subsystem commands that are issued during a\nI                console session.\nN\nI                UNSDISP returns the following values:\nI                -> YES - unsolicited messages are displayed\nI                -> NO - unsolicited messages are not displayed\nN\nI        SOLNUM the size of the message table that contains solicited\nI               messages (that is, the number of solicited messages that\nI               can be stored). The system stores the messages in the\nI               table during a console session if you specify that\nI               solicited messages are not to be displayed at the\nI               terminal. You can use the TSO/E CONSPROF command to\nI               change the size of the table.\nN\nI               For more information, see z/OS TSO/E System Programming\nI               Command Reference.\nN\nI        UNSNUM the size of the message table that contains unsolicited\nI               messages (that is, the number of unsolicited messages\nI               that can be stored). The system stores the messages in\nI               the table during a console session if you specify that\nI               unsolicited messages are not to be displayed at the\nI               terminal. You can use the TSO/E CONSPROF command to\nI               change the size of the table.\nN\nI               For more information, see z/OS TSO/E System Programming\nI               Command Reference.\nN\nI        The MFTIME, MFOSNM, MFJOB, and MFSNMJBX arguments provide\nI        information about messages that are issued during a console\nI        session. These arguments are useful if you use the GETMSG\nI        external function to retrieve messages that are not displayed\nI        at the terminal and you want to display a particular message\nI        that was retrieved. The arguments indicate whether certain\nI        types of information should be displayed with the message, such\nI        as the time stamp.\nN\nI        MFTIME indicates whether the user requested that the time stamp\nI               should be displayed with system messages.\nN\nI               MFTIME returns the following values:\nI               -> YES  time stamp should be displayed\nI               -> NO  time stamp should not be displayed\nN\nI        MFOSNM indicates whether the user requested that the\nI               originating system name should be displayed with system\nI               messages.\nN\nI               MFOSNM returns the following values:\nI               -> YES  originating system name should be displayed\nI               -> NO  originating system name should not be displayed\nN\nI        MFJOB indicates whether the user requested that the originating\nI              job name or job ID of the issuer should be displayed with\nI              system messages.\nN\nI              MFJOB returns the following values:\nI              -> YES  originating job name should be displayed\nI              -> NO  originating job name should not be displayed\nN\nI        MFSNMJBX indicates whether the user requested that the\nI                 originating system name and job name should not be\nI                 displayed with system messages.\nN\nI                 MFSNMJBX returns the following values:\nI                 -> YES  originating system name and job name should\nI                          not be displayed\nI                 -> NO  originating system name and job name should be\nI                         displayed\nN\nI                 MFSNMJBX is intended to override the values of\nI                 MFOSNM and MFJOB. The value for MFSNMJBX may not be\nI                 consistent with the values for MFOSNM and MFJOB.\nN\nN\nNExample\nN-------\nI  Say \"User information:\"\nI  sysvar_syspref   = SysVar(\"SYSPREF\")\nI  SAY \"Your prefix is:\" sysvar_syspref\nI  sysvar_sysproc   = SysVar(\"SYSPROC\")\nI  SAY \"Your LOGON procedure is:\" sysvar_sysproc\nI  sysvar_sysuid    = SysVar(\"SYSUID\")\nI  SAY \"Your userid is:\" sysvar_sysuid\nI\nI  Say \"Terminal information:\"\nI  sysvar_syslterm  = SysVar(\"SYSLTERM\")\nI  SAY \"Your terminal supports\" sysvar_syslterm \"LINES.\"\nI  sysvar_syswterm  = SysVar(\"SYSWTERM\")\nI  SAY \"Your terminal supports\" sysvar_syswterm \"characters.\"\nI\nI  Say \"Exec information:\"\nI  sysvar_sysenv    = SysVar(\"SYSENV\")\nI  SAY \"Your execution environment is:\" sysvar_sysenv\nI  sysvar_sysicmd   = SysVar(\"SYSICMD\")\nI  SAY \"Your initial command was:\" sysvar_sysicmd\nI  sysvar_sysispf   = SysVar(\"SYSISPF\")\nI  SAY \"Is ISPF AVAILABLE?\" sysvar_sysispf\nI  sysvar_sysnest   = SysVar(\"SYSNEST\")\nI  SAY \"Are we nested?\" sysvar_sysnest\nI  sysvar_syspcmd   = SysVar(\"SYSPCMD\")\nI  SAY \"A PRIMARY command of\" sysvar_syspcmd \"was issued.\"\nI  sysvar_sysscmd   = SysVar(\"SYSSCMD\")\nI  SAY \"A SECONDARY command of\" sysvar_sysscmd \"was issued.\"\nI\nI  Say \"System information:\"\nI  sysvar_syscpu    = SysVar(\"SYSCPU\")\nI  SAY \"Used\" sysvar_syscpu \"CPU seconds.\"\nI  sysvar_syshsm    = SysVar(\"SYSHSM\")\nI  SAY \"HSM level:\" sysvar_syshsm\nI  sysvar_sysjes    = SysVar(\"SYSJES\")\nI  SAY \"JES level:\" sysvar_sysjes\nI  sysvar_syslracf  = SysVar(\"SYSLRACF\")\nI  SAY \"RACF level:\" sysvar_syslracf\nI  sysvar_sysnode   = SysVar(\"SYSNODE\")\nI  SAY \"On JES node(\"sysvar_sysnode\").\"\nI  sysvar_sysracf   = SysVar(\"SYSRACF\")\nI  SAY \"RACF IS\" sysvar_sysracf\nI  sysvar_syssrv    = SysVar(\"SYSSRV\")\nI  SAY \"Used\" sysvar_syssrv \"Service units.\"\nI  sysvar_systermid = SysVar(\"SYSTERMID\")\nI  SAY \"Network TERMID(\"sysvar_systermid\").\"\nI  sysvar_systsoe   = SysVar(\"SYSTSOE\")\nI  SAY \"TSO/E level:\" sysvar_systsoe\nI\nI  Say \"Language information:\"\nI  sysvar_sysdterm  = SysVar(\"SYSDTERM\")       /* YES - supports DBCS */\nI  SAY \"DBCS support?\" sysvar_sysdterm\nI  sysvar_syskterm  = SysVar(\"SYSKTERM\")   /* YES - supports Katakana */\nI  SAY \"Katakana support?\" sysvar_sysdterm\nI  sysvar_sysplang  = SysVar(\"SYSPLANG\")\nI  SAY \"Primary language:\" sysvar_sysplang\nI  sysvar_sysslang  = SysVar(\"SYSSLANG\")\nI  SAY \"Secondary language:\" sysvar_sysslang\nI\nI  Say \"Console session information:\"\nI  sysvar_soldisp   = SysVar(\"SOLDISP\")\nI  SAY \"Display SOLICITED messages?\" sysvar_soldisp\nI  sysvar_unsdisp   = SysVar(\"UNSDISP\")\nI  SAY \"Display UNSOLICITED messages?\" sysvar_unsdisp\nI  sysvar_solnum    = SysVar(\"SOLNUM\")\nI  SAY \"SOLICITED number:\" sysvar_solnum\nI  sysvar_unsnum    = SysVar(\"UNSNUM\")\nI  SAY \"UNSOLICITED number:\" sysvar_unsnum\nI  sysvar_mftime    = SysVar(\"MFTIME\")\nI  SAY \"Should mainframe time be displayed?\" sysvar_mftime\nI  sysvar_mfosnm    = SysVar(\"MFOSNM\")\nI  SAY \"Should mainframe system name be displayed?\" sysvar_mfosnm\nI  sysvar_mfjob     = SysVar(\"MFJOB\")\nI  SAY \"Should mainframe job name be displayed?\" sysvar_mfjob\nI  sysvar_mfsnmjbx  = SysVar(\"MFSNMJBX\")\nI  SAY \"Should mainframe system and job name be displayed?\" ,\nI    sysvar_mfsnmjbx\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR05": {"ttr": 44548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x001\\x001\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:01", "lines": 49, "newlines": 49, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR05\nTz/OS TSO/E REXX Reference\nT-Chapter 5. Parsing\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590354\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 5. Parsing\nN------------------\nNThe parsing instructions are ARG, PARSE, and PULL.\nN\nNThe data to parse is a source string. Parsing splits up the data in a\nNsource string and assigns pieces of it into the variables named in a\nNtemplate. A template is a model specifying how to split the source\nNstring. The simplest kind of template consists of only a list of\nNvariable names. Here is an example:\nN\nN  variable1 variable2 variable3\nN\nNThis kind of template parses the source string into blank-delimited\nNwords. More complicated templates contain patterns in addition to\nNvariable names. String patterns Match characters in the source string\nNto specify where to split it. (See \"Templates containing string\nNpatterns\" for details.)\nN\nNPositional patterns Indicate the character positions at which to split\nNthe source string. (See \"Templates containing positional (numeric)\nNpatterns\" for details.)\nN\nNParsing is essentially a two-step process.\nN1. Parse the source string into appropriate substrings using patterns.\nN2. Parse each substring into words.\nN\nNSub-topics:\nN-----------\nN->Simple templates for parsing into words\nN->Parsing with variable patterns\nN->Parsing UPPER\nN->Parsing instructions summary\nN->Parsing instructions examples\nN->Advanced topics in parsing\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0501": {"ttr": 44550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x8c\\x00\\x8c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:01", "lines": 140, "newlines": 140, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0501\nTz/OS TSO/E REXX Reference\nT-Chapter 5.\nT-Simple templates for parsing into words\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175901\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 5. Parsing\nN------------------\nNSimple templates for parsing into words\nN---------------------------------------\nNAll variables in a template receive new values. If there are more\nNvariables in the template than words in the source string, the leftover\nNvariables receive null (empty) values.\nN\nNIf there are more words in the source string than variables in the\nNtemplate, the last variable in the template receives all leftover data.\nN\nNParsing into words removes leading and trailing blanks from each word\nNbefore it is assigned to a variable. The exception to this is the word\nNor group of words assigned to the last variable.\nN\nN\nNThe period as a placeholder\nN---------------------------\nNA period in a template is a placeholder. It is used instead of a\nNvariable name, but it receives no data. It is useful:\nN\nN-> As a \"dummy variable\" in a list of variables\nN\nN-> Or to collect unwanted information at the end of a string.\nN\nN\nNTemplates containing string patterns\nN------------------------------------\nNA string pattern matches characters in the source string to indicate\nNwhere to split it.\nN\nNA string pattern can be a:\nNLiteral string pattern One or more characters within quotation marks.\nN\nNVariable string pattern A variable within parentheses with no plus (+)\nNor minus (-) or equal sign (=) before the left parenthesis.\nN\nN\nNTemplates containing positional (numeric) patterns\nN--------------------------------------------------\nNA positional pattern is a number that identifies the character position\nNat which to split data in the source string. The number must be a whole\nNnumber.\nN\nNAn absolute positional pattern is\nN-> A number with no plus (+) or minus (-) sign preceding it or with an\nN   equal sign (=) preceding it\nN-> A variable in parentheses with an equal sign before the left\nN   parenthesis.\nN\nNThe number specifies the absolute character position at which to split\nNthe source string.\nN\nN\nNPARSE VALUE ... WITH Example\nN----------------------------\nNHere is a parsing instruction:\nN\nI  parse value 'time and tide' with var1 var2 var3\nN\nNThe template in this instruction is: var1 var2 var3. The data to parse\nNis between the keywords PARSE VALUE and the keyword WITH, the source\nNstring time and tide. Parsing divides the source string into\nNblank-delimited words and assigns them to the variables named in the\nNtemplate as follows:\nN\nN  var1='time'\nN  var2='and'\nN  var3='tide'\nN\nMThat is a poor example of VALUE ... WITH as no value needed to be\nMresolved and you already knew how to assign var1, var2, and var3.\nN\nN\nNThe PARSE VAR instruction is similar to PARSE VALUE except that the\nNsource string to parse is always a variable. In PARSE VAR, the name of\nNthe variable containing the source string follows the keywords\nNPARSE VAR. In the next example, the variable stars contains the source\nNstring. The template is star1 star2 star3.\nN\nNPARSE VAR Example\nN-----------------\nI  stars='Sirius Polaris Rigil'\nI  parse var stars star1 star2 star3\nN\nN  star1='Sirius'\nN  star2='Polaris'\nN  star3='Rigil'\nN\nNPeriod as a placeholder Example\nN-------------------------------\nNstars='Arcturus Betelgeuse Sirius Rigil'\nNparse var stars . . brightest .\nN\nNbrightest='Sirius'\nN\nNTemplate with literal string pattern Example\nN--------------------------------------------\nI  name='Smith, John'\nI  parse var name ln ', ' fn\nN\nN  ln='Smith'\nN  fn='John'\nN\nNParsing with absolute positional patterns in template Example\nN-------------------------------------------------------------\nI  record.1='Clemens Samuel Mark Twain '\nI  record.2='Evans Mary Ann George Eliot '\nI  record.3='Munro H.H. Saki '\nI  do n=1 to 3\nI    parse var record.n lastname 11 firstname 21 pseudonym\nI    If lastname='Evans' & firstname='Mary Ann' then say 'By George!'\nI  end\nN Says 'By George!' after record 2\nN\nNParsing with relative positional patterns in template Example\nN-------------------------------------------------------------\nI  record.1='Clemens Samuel Mark Twain '\nI  record.2='Evans Mary Ann George Eliot '\nI  record.3='Munro H.H. Saki '\nI  do n=1 to 3\nI    parse var record.n lastname +10 firstname + 10 pseudonym\nI    If lastname='Evans' & firstname='Mary Ann' then say 'By George!'\nI  end\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0502": {"ttr": 44802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:02", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0502\nTz/OS TSO/E REXX Reference\nT-Chapter 5.\nT-Parsing with variable patterns\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175902\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 5. Parsing\nN------------------\nNParsing with variable patterns\nN------------------------------\nNYou may want to specify a pattern by using the value of a variable\nNinstead of a fixed string or number. You do this by placing the name\nNof the variable in parentheses. This is a variable reference. Blanks\nNare not necessary inside or outside the parentheses, but you can add\nNthem if you wish.\nN\nNUsing a variable as a string pattern Example\nN--------------------------------------------\nNThe variable (delim) is set in the same template.\nI  SAY \"Enter a date (mm/dd/yy format). =====> \" /* assume 11/15/90 */\nI  pull date\nI  parse var date month 3 delim +1 day +2 (delim) year\nNSets: month='11'; delim='/'; day='15'; year='90'\nN\nNUsing a variable as a positional pattern Example\nN------------------------------------------------\nI  dataline = '12 26 .....Samuel ClemensMark Twain'\nI  parse var dataline pos1 pos2 6 =(pos1) realname =(pos2) pseudonym\nN Assigns: realname='Samuel Clemens'; pseudonym='Mark Twain'\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0503": {"ttr": 44804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x16\\x00\\x16\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:02", "lines": 22, "newlines": 22, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0503\nTz/OS TSO/E REXX Reference\nT-Chapter 5.\nT-Parsing UPPER\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175902\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 5. Parsing\nN------------------\nNParsing UPPER\nN-------------\nNSpecifying UPPER on any of the PARSE instructions converts characters\nNto uppercase (lowercase a-z to uppercase A-Z) before parsing.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0504": {"ttr": 44806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x003\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:02", "lines": 51, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0504\nTz/OS TSO/E REXX Reference\nT-Chapter 5.\nT-Parsing instructions summary\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175902\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 5. Parsing\nN------------------\nNParsing instructions summary\nN----------------------------\nNRemember: All parsing instructions assign parts of the source string\nNinto the variables named in the template. The following table\nNsummarizes where the source string comes from.\nInstruction            Where the source string comes from\nN--------------------- -------------------------------------------------\nNARG and PARSE ARG     Arguments you list when you call the program or\nN                      arguments in the call to a subroutine or\nN                      function.\nN\nNPARSE EXTERNAL        Reads from user's terminal in TSO/E foreground,\nN                      from input stream (SYSTSIN) in TSO/E background,\nN                      from input stream INDD field defines in non-TSO/E\nN                      address spaces.\nN\nNPARSE NUMERIC         Numeric control information (from NUMERIC\nN                      instruction).\nN\nNPULL and PARSE PULL   The string at the head of the external data\nN                      queue. (If queue empty, uses default input,\nN                      typically the terminal.)\nN\nNPARSE SOURCE          System-supplied string giving information about\nN                      the executing program.\nN\nNPARSE VALUE           Expression between the keyword VALUE and the\nN                      keyword WITH in the instruction.\nN\nNPARSE VAR name        Parses the value of name.\nN\nNPARSE VERSION         System-supplied string specifying the language,\nN                      language level, and (three-word) date.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0505": {"ttr": 44808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00k\\x00k\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:02", "lines": 107, "newlines": 107, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0505\nTz/OS TSO/E REXX Reference\nT-Chapter 5.\nT-Parsing instructions examples\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175902\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 5. Parsing\nN------------------\nNParsing instructions examples\nN-----------------------------\nNARG and PARSE ARG and PARSE UPPER ARG\nN-------------------------------------\nNPARSE ARG works the same as ARG except that PARSE ARG does not convert\nNalphabetic characters to uppercase before parsing. PARSE UPPER ARG will\nNconvert the arguments to uppercase.\nN\nI/* ARG with source string named in REXX program invocation */\nI/* Program name is PALETTE. Specify 2 primary colors (yellow, */\nI/* red, blue) on call. Assume call is: %palette red blue */\nIarg var1 var2 /* Assigns: var1=\"RED\"; var2=\"BLUE\" */\nIIf var1<>\"RED\" & var1<>\"YELLOW\" & var1<>\"BLUE\" then signal err\nIIf var2<>\"RED\" & var2<>\"YELLOW\" & var2<>\"BLUE\" then signal err\nItotal=length(var1)+length(var2)\nISELECT;\nIWhen total=7 then new=\"purple\"\nIWhen total=9 then new=\"orange\"\nIWhen total=10 then new=\"green\"\nIOtherwise new=var1 /* entered duplicates */\nIEND\nISay new; exit /* Displays: \"purple\" */\nIErr:\nIsay \"Input error--color is not \"red\" or \"blue\" or \"yellow\"\"; exit\nN\nN\nNPARSE UPPER EXTERNAL\nN--------------------\nISay \"Enter Yes or No =====> \"\nIparse upper external answer 2 .\nIIf answer=\"Y\"\nIthen say \"You said \"Yes\"!\"\nIelse say \"You said \"No\"!\"\nN\nN\nNPARSE NUMERIC\nN-------------\nIparse numeric digits fuzz form\nIsay digits fuzz form /* Displays: \"9 0 SCIENTIFIC\" */\nN\nN\nNPARSE PULL and PULL\nN-------------------\nNPULL works the same as PARSE PULL except that PULL converts alphabetic\nNcharacters to uppercase before parsing.\nN\nIPUSH \"80 7\" /* Puts data on queue */\nIparse pull fourscore seven /* Assigns: fourscore=\"80\"; seven=\"7\" */\nISAY fourscore+seven /* Displays: \"87\" */\nI                    /* (if defaults are in effect) */\nN\nN\nNPARSE SOURCE\nN------------\nI  PARSE SOURCE,\nI    source_host_env,\nI    source_call_type,\nI    source_uc_exec_name,\nI    source_hostdd,\nI    source_hostdsn,\nI    source_nf_exec_name,\nI    source_initial_cmd_env,\nI    source_asid_name,\nI    source_char8_user_token,\nI    source_hostother\nI  SAY \"Running:\" source_uc_exec_name\".\"\nN\nN\nNPARSE VALUE\nN-----------\nI/* PARSE VALUE using a variable as the source string to parse */\nIparse value \"time and tide\" with var1 var2 var3\nN\nN\nNARSE VAR\nN--------\nIstars=\"Sirius Polaris Rigil\"\nIparse var stars star1 star2 star3\nI/* star1=\"Sirius\" */\nI/* star2=\"Polaris\" */\nI/* star3=\"Rigil\" */\nN\nN\nNPARSE VERSION\nN-------------\nI  PARSE VERSION,\nI    version_rexx_name,\nI    version_rexx_version,\nI    version_rexx_date\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0506": {"ttr": 44810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00;\\x00;\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:03", "lines": 59, "newlines": 59, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0506\nTz/OS TSO/E REXX Reference\nT-Chapter 5.\nT-Advanced topics in parsing\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175903\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 5. Parsing\nN------------------\nNAdvanced topics in parsing\nN--------------------------\nNParsing multiple strings\nN------------------------\nNOnly ARG and PARSE ARG can have more than one source string. To parse\nmultiple strings, you can specify multiple comma-separated templates.\nN\nMTruthfully, VALUE ... WITH can also do more than one string.\nN\nI  SAY \"ARG: Parsing multiple strings in a subroutine\"\nI  num=\"3\"\nI  musketeers=\"Porthos Athos Aramis D'Artagnon\"\nI  CALL Sub num,musketeers /* Passes num and musketeers to sub */\nI  SAY total; say fourth /* Displays: \"4\" and \" D'Artagnon\" */\nI\nI  SAY \"\"\nI  SAY \"VALUE: Parsing multiple strings in code\"\nI  string.1 = \"Kenneth\"\nI  string.2 = \"E.\"\nI  string.3 = \"Tomiak\"\nI  string.0 = 3\nI  PARSE VALUE string.3 string.1 string.2 WITH lname fname minitial\nI  SAY lname fname minitial\nI\nI  RETURN 0\nI\nISub:\nI  parse arg subtotal, . . . fourth\nI  total=subtotal+1\nI  RETURN\nN\nNCombining string and positional patterns: a special case\nN--------------------------------------------------------\nN\nN\nNParsing with DBCS characters\nN----------------------------\nN\nN\nNDetails of steps in parsing\nN---------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR06": {"ttr": 44812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00!\\x00!\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:03", "lines": 33, "newlines": 33, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR06\nTz/OS TSO/E REXX Reference\nT-Chapter 6. Numbers and arithmetic\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590354\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNREXX defines the usual arithmetic operations (addition, subtraction,\nNmultiplication, and division) in as natural a way as possible. What\nNthis really means is that the rules followed are those that are\nNconventionally taught in schools and colleges.\nN\nNDuring the design of these facilities, however, it was found that\nNunfortunately the rules vary considerably (indeed much more than\nNgenerally appreciated) from person to person and from application to\nNapplication and in ways that are not always predictable. The arithmetic\nNdescribed here is, therefore, a compromise that (although not the\nNsimplest) should provide acceptable results in most applications.\nN\nMMessage from Kenneth Tomiak\nMThe author protests too much. The correct use of parenthesis will\nMserve to make it predictable how arithemetic operations are handled.\nMThe normal arithemetic needs will be met just fine.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0601": {"ttr": 44814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00)\\x00)\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:03", "lines": 41, "newlines": 41, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0601\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Introduction\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175903\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNIntroduction\nN------------\nNNumbers (that is, character strings used as input to REXX arithmetic\nNoperations and built-in functions) can be expressed very flexibly.\nNLeading and trailing blanks are permitted, and exponential notation\nNcan be used.\nN\nNVery large numbers\nN------------------\nNIn exponential notation, a number includes an exponent, a power of ten\nNby which the number is multiplied before use. The exponent indicates\nNhow the decimal point is shifted. Thus, in the preceding examples,\nN4E9 is simply a short way of writing 4000000000, and 0.73e-7 is short\nNfor 0.000000073.\nN\nN\nNArithmetic operators\nN--------------------\nNThe arithmetic operators include addition (+), subtraction (-),\nNmultiplication (*), power (**), division (/), prefix plus (+), and\nNprefix minus (-). In addition, there are two further division\nNoperators: integer divide (%) divides and returns the integer part;\nNremainder (//) divides and returns the remainder.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0602": {"ttr": 44816, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00B\\x00B\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:03", "lines": 66, "newlines": 66, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0602\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Numbers and Precision\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175903\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNA precise definition of the arithmetic facilities of the REXX\nNlanguage is given here.\nN\nN\nNNumbers\nN-------\nNA number in REXX is a character string that includes one or more\nNdecimal digits, with an optional decimal point. See \"Exponential\nNnotation\" for an extension of this definition.) The decimal point may\nNbe embedded in the number, or may be a prefix or suffix. The group of\nNdigits (and optional decimal point) constructed this way can have\nNleading or trailing blanks and an optional sign (+ or -) that must\nNcome before any digits or decimal point. The sign can also have\nNleading or trailing blanks.\nN\nNTherefore, number is defined as:\nN\nD  blanks sign blanks digits | digits. | digits.digits | .digits blanks\nN\nI    blanks: are one or more spaces\nN\nI    sign: is either + or -\nN\nI    digits: are one or more of the decimal digits 0-9.\nN\nNNote that a single period alone is not a valid number.\nN\nN\nNPrecision\nN---------\nNPrecision is the maximum number of significant digits that can result\nNfrom an operation. This is controlled by the instruction:\nN\nI  NUMERIC DIGITS expression\nN\nI    expression: is evaluated and must result in a positive whole\nI                number. This defines the precision (number of\nI                significant digits) to which calculations are carried\nI                out. Results are rounded to that precision, if\nI                necessary.\nN\nI                If you do not specify expression in this instruction,\nI                or if no NUMERIC DIGITS instruction has been processed\nI                since the start of a program, the default precision is\nI                used. The REXX standard for the default precision is 9.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0603": {"ttr": 44818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:04", "lines": 28, "newlines": 28, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0603\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Arithmetic operators\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175904\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNArithmetic operators\nN--------------------\nNREXX arithmetic is performed by the operators +, -, *, /, %, //,\nNand ** (add, subtract, multiply, divide, integer divide, remainder,\nNand power), which all act on two terms, and the prefix plus and minus\nNoperators, which both act on a single term. This section describes the\nNway in which these operations are carried out.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0604": {"ttr": 44820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x003\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:04", "lines": 51, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0604\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Arithmetic operation rules basic operators\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175904\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNArithmetic operation rules basic operators\nN------------------------------------------\nNThe basic operators (addition, subtraction, multiplication, and\nNdivision) operate on numbers as follows.\nN\nNAddition and Subtraction\nN------------------------\nNIf either number is 0, the other number, rounded to\nNNUMERIC DIGITS digits, if necessary, is used as the result (with sign\nNadjustment as appropriate). Otherwise, the two numbers are extended on\nNthe right and left as necessary, up to a total maximum of DIGITS + 1\nNdigits (the number with the smaller absolute value may, therefore,\nNlose some or all of its digits on the right) and are then added or\nNsubtracted as appropriate.\nN\nN\nNMultiplication\nN--------------\nNThe numbers are multiplied together ( long multiplication ) resulting\nNin a number that may be as long as the sum of the lengths of the two\nNoperands.\nN\nN\nNDivision\nN--------\nNFor the division: yyy / xxxxx the following steps are taken: First the\nNnumber yyy is extended with zeros on the right until it is larger than\nNthe number xxxxx (with note being taken of the change in the power of\nNten that this implies). Thus, in this example, yyy might become yyy00.\nNTraditional long division then takes place.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0605": {"ttr": 45057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x009\\x009\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:04", "lines": 57, "newlines": 57, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0605\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Arithmetic operation rules additional operators\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175904\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNArithmetic operation rules additional operators\nN-----------------------------------------------\nNThe operation rules for the power (**), integer divide (%), and\nNremainder (//) operators follow.\nN\nN\nNPower\nN-----\nNThe ** (power) operator raises a number to a power, which may be\nNpositive, negative, or 0. The power must be a whole number. (The\nNsecond term in the operation must be a whole number and is rounded to\nNDIGITS digits, if necessary. If negative, the absolute value of the\nNpower is used, and then the result is inverted (divided into 1). For\nNcalculating the power, the number is effectively multiplied by itself\nNfor the number of times expressed by the power, and finally trailing\nNzeros are removed (as though the result were divided by 1).\nN\nN\nNInteger division\nN----------------\nNThe % (integer divide) operator divides two numbers and returns the\nNinteger part of the result. The result returned is defined to be that\nNwhich would result from repeatedly subtracting the divisor from the\nNdividend while the dividend is larger than the divisor. During this\nNsubtraction, the absolute values of both the dividend and the divisor\nNare used: the sign of the final result is the same as that which would\nNresult from regular division.\nN\nN\nNRemainder\nN---------\nNThe // (remainder) operator returns the remainder from integer\nNdivision and is defined as being the residue of the dividend after\nNthe operation of calculating integer division as previously described.\nNThe sign of the remainder, if nonzero, is the same as that of the\nNoriginal dividend.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0606": {"ttr": 52995, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x18\\x13\\x7f\\x01\\x18\\x14/\\x15W\\x00^\\x00^\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-22T15:57:41", "lines": 94, "newlines": 94, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0606\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Numeric comparisons\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180522-155741\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNNumeric comparisons\nN-------------------\nNThe comparison operators are:\nN\nN  =             True if the terms are equal (numerically or when\nN                padded, and so forth)\nN  \\=, ,=, /=    True if the terms are not equal (inverse of =)\nN  >             Greater than\nN  <             Less than\nN  ><            Greater than or less than (same as not equal)\nN  <>            Greater than or less than (same as not equal)\nN  >=            Greater than or equal to\nN  \\<, ,<        Not less than\nN  <=            Less than or equal to\nN  \\>, ,>        Not greater than\nN  ==            True if terms are strictly equal (identical)\nN  \\==, ,==, /== True if the terms are NOT strictly equal\nN  (inverse of ==)\nN  >>            Strictly greater than\nN  <<            Strictly less than\nN  >>=           Strictly greater than or equal to\nN  \\<<, ,<<      Strictly NOT less than\nN  <<=           Strictly less than or equal to\nN  \\>>, ,>>      Strictly NOT greater than\nN\nNGuideline: Throughout the language, the not character, ,, is synonymous\nNwith the backslash (\\). You can use the two characters interchangeably,\nNaccording to availability and personal preference. The backslash can\nNappear in the following operators:\nN  \\ (prefix not), \\=, \\==, \\<, \\>, \\<<, and \\>>.\nM\nMMessage from Kenneth Tomiak\nMEmulator keyboards rarely have the not-sign character so\nMthe 'Kenneth Tomiak Programming Method' (KTPM07) recommends not using\nMit. It also recommends not using the backslash and instead code the\nMpositive check with an ELSE DO for the negative check.\nN\nNYou can use any of these for comparing numeric strings. However, you\nNshould not use ==, \\==, ,==, >>, \\>>, ,>>, <<, \\<<, and ,<< for\nNcomparing numbers because leading and trailing blanks and leading\nNzeros are significant with these operators.\nN\nN\nNLogical (boolean)\nN-----------------\nNA character string is taken to have the value false if it is 0, and\nNtrue if it is 1. The logical operators take one or two such values\nN(values other than 0 or 1 are not allowed) and return 0 or 1 as\nNappropriate:\nN\nN  & AND:                  Returns 1 if both terms are true.\nN  | Inclusive OR:         Returns 1 if either term is true.\nN  && Exclusive OR:        Returns 1 if either (but not both) is true.\nN  Prefix \\,, Logical NOT: Negates; 1 becomes 0, and 0 becomes 1\nN\nN\nNParentheses and operator precedence\nN-----------------------------------\nNExpression evaluation is from left to right; parentheses and operator\nNprecedence modify this:\nN\nN-> When parentheses are encountered (other than those that identify\nN   function calls) the entire subexpression between the parentheses\nN   is evaluated immediately when the term is required.\nN-> When the sequence:\nN     term1 operator1 term2 operator2 term3\nN   is encountered, and operator2 has a higher precedence than\nN   operator1, the subexpression (term2 operator2 term3) is evaluated\nN   first. The same rule is applied repeatedly as necessary.\nN\nNNote, however, that individual terms are evaluated from left to right\nNin the expression (that is, as soon as they are encountered). The\nNprecedence rules affect only the order of operations.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0607": {"ttr": 45059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x007\\x007\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:31", "lines": 55, "newlines": 55, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0607\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Exponential notation\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175931\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNExponential notation\nN--------------------\nNFor both large and small numbers some form of exponential notation is\nNuseful, both to make long numbers more readable, and to make execution\nNpossible in extreme cases. In addition, exponential notation is used\nNwhenever the \"simple\" form would give misleading information.\nN\nNThe definition of numbers is, therefore, extended as:\nD  blanks sign blanks digits | digits. | digits.digits | .digits +\nD    E sign integer blanks\nN\nI    blanks: are one or more spaces\nN\nI    sign: is either + or -\nN\nI    digits: are one or more of the decimal digits 0-9.\nN\nI    e | E: The E can be in uppercase or lowercase.\nN\nI    integer: following the E represents a power of ten that is to be\nI             applied to the number.\nN\nNNotation\nN--------\nNScientific notation is a form of exponential notation that adjusts the\nNpower of ten so a single nonzero digit appears to the left of the\nNdecimal point. Engineering notation is a form of exponential notation\nNin which from one to three digits (but not simply 0) appear before the\nNdecimal point, and the power of ten is always expressed as a multiple\nNf three. The integer part may, therefore, range from 1 through 999.\nNYou can control whether Scientific or Engineering notation is used\nNwith the instruction:\nN\nN   NUMERIC FORM SCIENTIFIC | ENGINEERING | expression VALUE\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0608": {"ttr": 45061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:31", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0608\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Numeric information and Whole numbers\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175931\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNNumeric information\nN-------------------\nNTo determine the current settings of the NUMERIC options, use the\nNbuilt-in functions DIGITS, FORM, and FUZZ. These functions return the\nNcurrent settings of NUMERIC DIGITS, NUMERIC FORM, and NUMERIC FUZZ,\nNrespectively.\nN\nN\nNWhole numbers\nN-------------\nNWithin the set of numbers REXX understands, it is useful to distinguish\nNthe subset defined as whole numbers. A whole number in REXX is a number\nNthat has a decimal part that is all zeros (or that has no decimal\nNpart). In addition, it must be possible to express its integer part\nNsimply as digits within the precision set by the NUMERIC DIGITS\nNinstruction. REXX would express larger numbers in exponential notation,\nNafter rounding, and, therefore, these could no longer be safely\nNdescribed or used as whole numbers.\nN* End of wish.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0609": {"ttr": 45063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x002\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:32", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0609\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Numbers used directly by REXX\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175932\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNNumbers used directly by REXX\nN-----------------------------\nNAs discussed, the result of any arithmetic operation is rounded (if\nNnecessary) according to the setting of NUMERIC DIGITS. Similarly, when\nNREXX directly uses a number (which has not necessarily been involved\nNin an arithmetic operation), the same rounding is also applied. It is\nNjust as though the number had been added to 0.\nN\nNIn the following cases, the number used must be a whole number, and\nNan implementation restriction on the largest number that can be used\nNmay apply:\nN\nN-> The positional patterns in parsing templates (including variable\nN   positional patterns)\nN-> The power value (right hand operand) of the power operator\nN-> The values of exprr and exprf in the DO instruction\nN-> The values given for DIGITS or FUZZ in the NUMERIC instruction\nN-> Any number used in the numeric option in the TRACE instruction\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR0610": {"ttr": 45065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00%\\x00%\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:32", "lines": 37, "newlines": 37, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR0610\nTz/OS TSO/E REXX Reference\nT-Chapter 6.\nT-Definition\nT-Errors\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175932\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 6. Numbers and arithmetic\nN---------------------------------\nNDefinition\nN----------\nNErrors\nN------\nNTwo types of errors may occur during arithmetic:\nN\nNOverflow or Underflow\nN---------------------\nNBecause this allows for (very) large exponents, overflow or underflow\nNis treated as a syntax error.\nN\nN\nNInsufficient storage\nN--------------------\nNStorage is needed for calculations and intermediate results, and on\nNoccasion an arithmetic operation may fail because of lack of storage.\nNThis is considered a terminating error as usual, rather than an\nNarithmetic error.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR10": {"ttr": 45067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:32", "lines": 23, "newlines": 23, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR10\nTz/OS TSO/E REXX Reference\nT-Chapter 10. TSO/E REXX commands\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590354\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNTSO/E provides TSO/E REXX commands to perform different services, such\nNas I/O and data stack requests. The TSO/E REXX commands are not the\nNsame as TSO/E command processors, such as ALLOCATE and PRINTDS. In\nNgeneral, you can only use these commands in REXX execs (in any address\nNspace), not in CLISTs or from TSO/E READY mode. The exceptions are the\nNEXECUTIL command and the immediate commands HE, HI, HT, RT, TE, and TS.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1001": {"ttr": 45069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00!\\x00!\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:32", "lines": 33, "newlines": 33, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1001\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-DELSTACK\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175932\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNDELSTACK\nN--------\nNDELSTACK deletes the most recently created data stack that was created\nNby the NEWSTACK command, and all elements on it. If a new data stack\nNwas not created, DELSTACK removes all the elements from the original\nNdata stack.\nN\nN\nNSyntax:\nN  ADDRESS TSO \"DELSTACK\"\nN\nN\nNDELSTACK Example\nN----------------\nMSee REXR1009.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1002": {"ttr": 45071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\"\\x00\"\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:33", "lines": 34, "newlines": 34, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1002\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-DROPBUF\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175933\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNDROPBUF\nN--------\nNDROPBUF removes the most recently created data stack buffer that was\nNcreated with the MAKEBUF command, and all elements on the data stack\nNin the buffer. To remove a specific data stack buffer and all buffers\nNcreated after it, issue the DROPBUF command with the number (n) of the\nNbuffer.\nN\nN\nNSyntax:\nN  ADDRESS TSO \"DROPBUF\"\nN\nN\nNDROPBUF Example\nN----------------\nMSee REXR1009.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1003": {"ttr": 45073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\xb1\\x00\\xb1\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:33", "lines": 177, "newlines": 177, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1003\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-EXECIO\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175933\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNEXECIO\nN--------\nNEXECIO controls the input and output (I/O) of information to and from\nNa data set. Information can be read from a data set to the data stack\nNfor serialized processing or to a list of variables for random\nNprocessing. Information from the data stack or a list of variables can\nNbe written to a data set.\nN\nN\nNSyntax\nD  EXECIO lines | * DISKW ddname Write Parms\nD  EXECIO lines | * DISKR ddname\nD  EXECIO lines | * DISKRU linenum Read Parms\nN\nI  Write Parms:\nD    (STEM var-name OPEN | FINIS )\nI  Read Parms:\nD    (STEM var-name FIFO| LIFO OPEN | FINIS SKIP )\nN\nI    lines: the number of lines to be processed. This operand can be a\nI           specific decimal number or an arbitrary number indicated\nI           by *. When the operand is * and EXECIO is reading from a\nI           data set, input is read until EXECIO reaches the end of the\nI           data set.\nN\nI    DISKW:  opens a data set for output (if it is not already open) and\nI            writes the specified number of lines to the data set. The\nI            lines can be written from the data stack or, if the STEM\nI            operand is specified, from a list of variables.\nN\nI    DISKR:  opens a data set for input (if it is not already open) and\nI            reads the specified number of lines from the data set and\nI            places them on the data stack. If the STEM operand is\nI            specified, the lines are placed in a list of variables\nI            instead of on the data stack.\nN\nI    DISKRU: opens a data set for update (if it is not already open) and\nI            reads the specified number of lines from the data set and\nI            places them on the data stack. If the STEM operand is\nI            specified, the lines are placed in a list of variables\nI            instead of on the data stack.\nN\nI    ddname: the name of the file to which the sequential data set or\nI            member of the PDS was allocated. You must allocate the file\nI            before you can issue EXECIO. For example, you can allocate\nI            a file using the ALLOCATE command in the TSO/E address\nI            space only or a JCL DD statement.\nN\nI    linenum: the line number in the data set at which EXECIO is to\nI             begin reading. When a data set is closed and reopened as\nI             a result of specifying a record number earlier than the\nI             current record number, the file is open for:\nN\nN             -> input if DISKR is specified\nN             -> update if DISKRU is specified\nN\nI             When a data set is open for input or update, the current\nI             record number is the number of the next record to be read.\nI             When linenum specifies a record number earlier than the\nI             current record number in an open data set, the data set\nI             must be closed and reopened to reposition the current\nI             record number at linenum.\nN\nI             When this situation occurs and the data set was not opened\nI             at the same task level as that of the executing exec,\nI             attempting to close the data set at a different task\nI             level results in an EXECIO error. The linenum operand\nI             must not be used in this case.\nN\nI    STEM var-name: the stem of the set of variables into which\nI                   information is to be placed. To place information\nI                   in compound variables, which allow for easy\nI                   indexing, the var-name should end with a period.\nI                   For example, MYVAR.\nN\nI    LIFO: places information about the data stack in LIFO (last in\nI          first out) order.\nN\nI    FIFO: places information about the data stack in FIFO (first in\nI          first out) order. FIFO is the default when neither LIFO or\nI          FIFO is specified.\nN\nI    SKIP: reads the specified number of lines but does not place them\nI          on the data stack or in variables. When the number of lines\nI          is *, EXECIO skips to the end of the data set.\nN\nI    OPEN: opens the specified data set if it is not already open. You\nI          can use OPEN with a lines value of 0 to have EXECIO do one of\nI          the following:\nN\nI          -> open a data set without reading any records\nI          -> set the current record number (that is, the number of the\nI             next record EXECIO will read) to the record number\nI             indicated by the linenum operand, if you specify a value\nI             for linenum.\nN\nI    FINIS: close the data set after the EXECIO command completes. A\nI           data set can be closed only if it was opened at the same\nI           task level as the exec issuing the EXECIO command.\nN\nN\nNDISKR Example EXEC1\nN-------------------\nI/* REXX exec (EXEC1) invokes another exec (EXEC2) to open a */\nI/* file. EXEC1 then continues reading the same file. */\nIsay 'Executing the first exec EXEC1'\nI\"ALLOC FI(INPUTDD) DA(MYINPUT) REUSE\" , /* Allocate input file */\nI  \"NEW CATALOG TRACKS SPACE(1, 1) RECFM(V B) BLKSIZE(0) LRECL(40)\"\nI/* */\nI/* Now invoke the second exec (EXEC2) to open the INPUTDD file. */\nI/* The exec uses a call to invoke the second exec. You can */\nI/* also use the TSO/E EXEC command, which would have the */\nI/* same result. */\nI/* If EXEC2 opens a file and does not close the file before */\nI/* returning control to EXEC1, the file remains open when */\nI/* control is returned to EXEC1. */\nI/* */\nIsay 'Invoking the second exec EXEC2'\nIcall exec2 /* Call EXEC2 to open file */\nIsay 'Now back from the second exec EXEC2. Issue another EXECIO.'\nI\"EXECIO 1 DISKR INPUTDD (STEM X.\" /* EXECIO reads record 4 */\nIsay x.1\nIsay 'Now close the file'\nI\"EXECIO 0 DISKR INPUTDD (FINIS\" /* Close file so it can be freed */\nI\"FREE FI(INPUTDD)\"\nIEXIT 0\nN\nN\nNDISKR Example EXEC2\nN-------------------\nI/* REXX exec (EXEC2) opens the file INPUTDD, reads 3 records, and */\nI/* then returns to the invoking exec (EXEC1). The exec (EXEC2) */\nI/* returns control to EXEC1 without closing the INPUTDD file. */\nI/* */\nIsay \"Now in the second exec EXEC2\"\nIsay 'Invoking the third exec EXEC3'\nIcall exec3 /* Call EXEC3 to open file */\nIsay 'Now back from the second exec EXEC2. Issue another EXECIO.'\nIDO I = 1 to 3 /* Read & display first 3 records */\nI  \"EXECIO 1 DISKR INPUTDD (STEM Y.)\"\nI  say y.1\nIEND\nISay 'Leaving second exec EXEC2. Three records were read from file.'\nIRETURN 0\nN\nN\nNDISKW Example EXEC3\nN-------------------\nI/* REXX exec (EXEC3) opens the file INPUTDD, writes 6 records. */\nIsay 'Now in the third exec EXEC3'\nIy.0 = 1\nIDO I = 1 to 6 /* Write & display first 6 records */\nI  y.1 = \"Record #\"i\nI  \"EXECIO 1 DISKW INPUTDD (STEM Y.)\"\nI  say y.1\nIEND\nI  \"EXECIO 0 DISKW INPUTDD (FINIS)\"\nISay 'Leaving third exec EXEC3. Six records were written to file.'\nIRETURN 0\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1004": {"ttr": 45313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00q\\x00q\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:33", "lines": 113, "newlines": 113, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1004\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-EXECUTIL\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175933\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNEXECUTIL\nN--------\nNEXECUTIL lets you change various characteristics that control how an\nNexec processes in the TSO/E address space.\nN\nNAll of the EXECUTIL operands are mutually exclusive, that is, you can\nNonly specify one of the operands on the command.\nN\nN\nNSyntax\nD  EXECUTIL EXECDD(CLOSE | NOCLOSE) TS | TE | HT | RT | HI +\nD    RENAME NAME(function-name) SYSNAME(sys-name) DD(sys-dd) +\nD    SEARCHDD(NO | YES)\nN\nI    EXECDD(CLOSE) or EXECDD(NOCLOSE): Specifies whether the system\nI      exec library is to be closed after the system locates the exec\nI      but before the exec runs.\nN\nI    TS: Use TS (Trace Start) to start tracing execs. Tracing lets you\nI        interactively control the processing of an exec and debug\nI        problems.\nN\nI    TE: Use TE (Trace End) to end tracing execs. The TE operand is not\nI        really applicable in READY mode because an exec is not\nI        currently running. However, if you issued EXECUTIL TS to trace\nI        the next exec you invoke and then issued EXECUTIL TE, the next\nI        exec you invoke is not traced.\nN\nI    HT: Use HT (Halt Typing) to suppress terminal output generated by\nI        an exec. The exec continues running. HT suppresses any output\nI        generated by REXX instructions or functions (for example, the\nI        SAY instruction) and REXX informational messages. REXX error\nI        messages are still displayed. Normal terminal output resumes\nI        when the exec completes. You can also use EXECUTIL RT to resume\nI        terminal output.\nN\nI    RT: Use RT (Resume Typing) to resume terminal output that was\nI        previously suppressed. Use the RT operand in either an exec\nI        or CLIST. You can also use EXECUTIL RT from a program by using\nI        the TSO service facility. If the program invokes EXECUTIL RT,\nI        terminal output from all execs that are currently running is\nI        resumed. EXECUTIL RT is not applicable from READY mode or ISPF\nI        because no execs are currently running.\nN\nI    HI: Use HI (Halt Interpretation) to halt the interpretation of all\nI        execs that are currently running in the language processor\nI        environment. From either an exec or a CLIST, EXECUTIL HI halts\nI        the interpretation of all execs that are currently running. If\nI        an exec calls a CLIST and the CLIST contains EXECUTIL HI, the\nI        exec that invoked the CLIST stops processing.\nN\nI    RENAME: Use EXECUTIL RENAME to change entries in a function package\nI            directory. A function package directory contains\nI            information about the functions and subroutines that make\nI            up a function package.\nN\nI      NAME(function-name): Specifies the name of the external function\nI                           or subroutine that is used in an exec. This\nI                           is also the name in the func-name field in\nI                           the directory entry.\nI      SYSNAME(sys-name): Specifies the name of the entry point in a\nI                         load module that corresponds to the package\nI                         code that is called for the function or\nI                         subroutine. If SYSNAME is omitted, the\nI                         sys-name field in the package directory is set\nI                         to blanks.\nI      DD(sys-dd): Specifies the name of the DD from which the package\nI                  code is loaded. If DD is omitted, the sys-dd field\nI                  in the package directory is set to blanks.\nN\nI    SEARCHDD(YES/NO): Specifies whether the system exec library (the\nI                      default is SYSEXEC) should be searched when execs\nI                      are implicitly invoked. YES indicates that the\nI                      system exec library (SYSEXEC) is searched, and\nI                      if the exec is not found, SYSPROC is then\nI                      searched.\nN\nI                      NO indicates that SYSPROC only is searched.\nN\nN\nNExample EXECUTIL\nN----------------\nI  /* REXX program */\nI  MAINRTN:\nI    SAY \"EXECUTIL IS RUNNING.\"\nI    CALL SUBRTN\nI    \"EXECUTIL TE\"\nI    SAY \"EXECUTIL IS STILL RUNNING.\"\nI    EXIT\nI  /* Subroutine follows */\nI  SUBRTN:\nI    SAY \"EXECUTIL SUBRTN IS RUNNING.\"\nI    \"EXECUTIL TS\"\nI    SAY \"EXECUTIL SUBRTN IS STILL RUNNING.\"\nI    RETURN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1005": {"ttr": 45315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:33", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1005\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-HE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175933\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNHE\nN--\nNHE (Halt Execution) is an immediate command you can use to halt the\nNexecution of a REXX exec. The HE immediate command is available only\nNif an exec is running in TSO/E and you press the attention interrupt\nNkey to enter attention mode. You can enter HE in response to the REXX\nNattention prompting message, IRX0920I.\nN\nNSyntax\nD  HE\nN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1006": {"ttr": 45317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:34", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1006\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-HI\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175934\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNHI\nN--\nNHI (Halt Interpretation) is an immediate command you can use to halt\nNthe interpretation of all currently executing execs. The HI immediate\nNcommand is available only if an exec is running in TSO/E and you press\nNthe attention interrupt key to enter attention mode. You can enter HI\nNin response to the REXX attention prompting message, IRX0920I.\nN\nNSyntax\nD  HI\nN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1007": {"ttr": 45319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:34", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1007\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-HT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175934\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNHT\nN--\nNHT (Halt Typing) is an immediate command you can use to suppress\nNterminal output that an exec generates. The HT immediate command is\nNavailable only if an exec is running in TSO/E and you press the\nNattention interrupt key to enter attention mode. You can enter HT in\nNresponse to the REXX attention prompting message, IRX0920I.\nN\nNSyntax\nD  HT\nN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1008": {"ttr": 45321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00+\\x00+\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:34", "lines": 43, "newlines": 43, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1008\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-MAKEBUF\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175934\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNMAKEBUF\nN--------\nNUse the MAKEBUF command to create a new buffer on the data stack. The\nNMAKEBUF command can be issued from REXX execs that execute in both the\nNTSO/E address space and non-TSO/E address spaces.\nN\nNInitially, the data stack contains one buffer, which is known as\nNbuffer 0. You create additional buffers using the MAKEBUF command.\nNMAKEBUF returns the number of the buffer it creates in the REXX special\nNvariable RC. For example, the first time an exec issues MAKEBUF, it\nNcreates the first buffer and returns a 1 in the special variable RC.\nNThe second time MAKEBUF is used, it creates another buffer and returns\nNa 2 in the special variable RC.\nN\nNTo remove buffers from the data stack that were created with the\nNMAKEBUF command, use the DROPBUF command\nN\nN\nNSyntax:\nN  ADDRESS TSO \"MAKEBUF\"\nN\nN\nNMAKEBUF Example\nN----------------\nMSee REXR1009.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1009": {"ttr": 45323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00r\\x00r\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:34", "lines": 114, "newlines": 114, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1009\nKDELSTACK DROPBUF MAKEBUF QSTACK QBUF QELEM\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-NEWSTACK\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175934\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNNEWSTACK\nN--------\nNcreates a new data stack and basically hides or isolates the current\nNdata stack. Elements on the previous data stack cannot be accessed\nNuntil a DELSTACK command is issued to delete the new data stack and\nNany elements remaining in it.\nN\nN\nNSyntax:\nN  ADDRESS TSO \"NEWSTACK\"\nN\nN\nNNEWSTACK Example\nN----------------\nI  SAY \"Show current stack and buffer identifiers:\"\nI  SAY \"------------------------------------------\"\nI  CALL sub0\nI\nI  SAY \"\"\nI  SAY \"Put some data into the buffer:\"\nI  SAY \"------------------------------\"\nI  PUSH \"ONE RECORD ON stack #\"num_stack \" BUFFER #\"num_buffer \".\"\nI  QUEUE \"A SECOND RECORD ON stack #\"num_stack \" BUFFER #\"num_buffer \".\"\nI  CALL sub0\nI\nI  SAY \"\"\nI  SAY \"Create a new buffer:\"\nI  SAY \"--------------------\"\nI  MAKEBUF\nI  CALL sub0\nI\nI  SAY \"\"\nI  SAY \"Create a new stack:\"\nI  SAY \"-------------------\"\nI  CALL sub1\nI  CALL sub0\nI  SAY \"Create a new buffer:\"\nI  SAY \"--------------------\"\nI  MAKEBUF\nI  CALL sub2\nI  CALL sub0\nI  DROPBUF\nI  CALL sub2\nI  CALL sub2\nI  CALL sub0\nI  SAY \"Drop buffer 0 removes all buffers in the stack.\"\nI  SAY \"-----------------------------------------------\"\nI  DROPBUF 0\nI  CALL sub0\nI  DO WHILE num_stack > 1\nI    SAY \"Deleting stack #\"num_stack\nI    DELSTACK\nI  END\nI  CALL sub0\nI\nI  EXIT\nI\nIsub0:\nI  ADDRESS TSO \"QSTACK\"\nI  num_stack = RC\nI  ADDRESS TSO \"QBUF\"\nI  num_buffer = RC\nI  ADDRESS TSO \"QELEM\"\nI  num_elements = RC\nI  any_left = QUEUED()\nI  SAY \"Using stack #\"num_stack \"- buffer #\"num_buffer ,\nI    \"- elements #\"num_elements \"or queued #\"any_left\nI  RETURN 0\nI\nIsub2:\nI  ADDRESS TSO \"QBUF\"\nI  num_buffer = rc\nI  SAY \"sub2: Using stack #\"num_stack \"- buffer #\"num_buffer\nI  PUSH \"ONE RECORD ON BUFFER #\"num_buffer \".\"\nI  QUEUE \"A SECOND RECORD ON BUFFER #\"num_buffer \".\"\nI  PULL the_last_record\nI  RETURN\nI\nIsub1:\nI  \"NEWSTACK\"\nI  ADDRESS TSO \"QSTACK\"\nI  num_stack = rc\nI  SAY \"sub1: Using stack #\"num_stack \"- buffer #\"num_buffer\nI  ADDRESS TSO \"QBUF\"\nI  num_buffer = rc\nI  PUSH \"ONE RECORD ON BUFFER #\"num_buffer \".\"\nI  QUEUE \"A SECOND RECORD ON BUFFER #\"num_buffer \".\"\nI  PULL the_last_record\nI  any_left = QUEUED()\nI  \"DELSTACK\"\nI  ADDRESS TSO \"QSTACK\"\nI  num_stack = rc\nI  SAY \"There was\" any_left ,\nI    \"record(s) left on stack #\"num_stack \" BUFFER #\"num_buffer \".\"\nI  RETURN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1010": {"ttr": 45325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00#\\x00#\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:35", "lines": 35, "newlines": 35, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1010\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-QBUF\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175935\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNQBUF\nN----\nNqueries the number of buffers that were created on the data stack with\nNthe MAKEBUF command. The QBUF command returns the number of buffers in\nNthe REXX special variable RC. If you have not issued MAKEBUF to create\nNany buffers on the data stack, QBUF sets the special variable RC to 0.\nNIn this case, 0 is the number of the buffer that is contained in every\nNdata stack.\nN\nN\nNSyntax:\nN  ADDRESS TSO \"QBUF\"\nN\nN\nNQBUF Example\nN------------\nNSee REXR1009.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1011": {"ttr": 45327, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00$\\x00$\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:35", "lines": 36, "newlines": 36, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1011\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-QELEM\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175935\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNQELEM\nN-----\nNqueries the number of data stack elements that are in the most recently\nNcreated data stack buffer (that is, in the buffer that was created by\nNthe MAKEBUF command). The number of elements is returned in the REXX\nNspecial variable RC. When MAKEBUF has not been issued to create a\nNbuffer, QELEM returns the number 0 in the special variable RC,\nNregardless of the number of elements on the data stack. Thus when QBUF\nNreturns 0, QELEM also returns 0.\nN\nN\nNSyntax:\nN  ADDRESS TSO \"QELEM\"\nN\nN\nNQELEM Example\nN-------------\nNSee REXR1009.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1012": {"ttr": 45329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00#\\x00#\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:35", "lines": 35, "newlines": 35, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1012\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-QSTACK\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175935\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNQSTACK\nN------\nNqueries the number of data stacks in existence for an exec that is\nNrunning. QSTACK returns the number of data stacks in the REXX special\nNvariable RC. The value QSTACK returns indicates the total number of\nNdata stacks, including the original data stack. If you have not issued\nNa NEWSTACK command to create a new data stack, QSTACK returns 1 in the\nNspecial variable RC for the original data stack.\nN\nN\nNSyntax:\nN  ADDRESS TSO \"QSTACK\"\nN\nN\nNQSTACK Example\nN--------------\nNSee REXR1009.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1013": {"ttr": 45331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:35", "lines": 31, "newlines": 31, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1013\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-RT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175935\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNRT\nN--\nNRT (Resume Typing) is an immediate command you can use to resume\nNterminal output that was previously suppressed. The RT immediate\nNcommand is available only if an exec is running in TSO/E and you press\nNthe attention interrupt key to enter attention mode. You can enter RT\nNin response to the REXX attention prompting message, IRX0920I. Terminal\nNoutput that the exec generated after you issued the HT command and\nNbefore you issued the RT command is lost.\nN\nNSyntax\nD  RT\nN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1014": {"ttr": 45569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00P\\x00P\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:36", "lines": 80, "newlines": 80, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1014\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-SUBCOM\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175936\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNSUBCOM\nN------\nNSUBCOM queries the existence of a specified host command environment.\nNSUBCOM searches the host command environment table for the named\nNenvironment and sets the REXX special variable RC to 0 or 1. When RC\nNcontains 0, the environment exists. When RC contains 1, the environment\nNdoes not exist.\nN\nNSyntax\nD  SUBCOM envname\nI    envname: When you invoke an exec from TSO/E, the following default\nI             host command environments are available:\nI      -> TSO (the default environment)\nI      -> CONSOLE\nI      -> CPICOMM\nI      -> LU62\nI      -> MVS\nI      -> LINK\nI      -> ATTACH\nI      -> LINKPGM\nI      -> ATTCHPGM\nI      -> LINKMVS\nI      -> ATTCHMVS\nN\nI             When you invoke an exec from ISPF, the following\nI             additional default host command environments are\nI             available:\nI      -> ISPEXEC\nI      -> ISREDIT\nN\nN\nNSUBCOM Example\nN--------------\nI  \"SUBCOM ISPEXEC\"\nI  IF (RC = 0) THEN DO\nI    SAY \"ISPEXEC environment exists.\"\nI  END\nI  ELSE DO\nI    SAY \"ISPEXEC is not an available environment.\"\nI    RETURN\nI  END\nI\nI  current_envname = Address()\nI  IF (current_envname <> \"ISPEXEC\") THEN DO\nI    SAY \"ISPEXEC is not the default environment, not yet.\"\nI    ADDRESS ispexec\nI  END\nI  ELSE DO\nI    SAY \"ISPEXEC is the default environment.\"\nI  END\nI\nI  current_envname = Address()\nI  IF (current_envname <> \"ISPEXEC\") THEN DO\nI    SAY \"ISPEXEC is not the default environment, not yet.\"\nI    SAY \"It is:\" current_envname\nI  END\nI  ELSE DO\nI    SAY \"ISPEXEC is the default environment. Revert to TSO.\"\nI    ADDRESS TSO\nI  END\nI\nI  RETURN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1015": {"ttr": 45571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:36", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1015\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-TE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175936\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNTE\nN--\nNTE (Trace End) is an immediate command you can use to end tracing REXX\nNexecs. The TE immediate command is available if an exec is running in\nNTSO/E and you press the attention interrupt key to enter attention\nNmode. You can enter TE in response to the REXX attention prompting\nNmessage, IRX0920I. The exec continues processing, but tracing is off.\nN\nNSyntax\nD  TE\nN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR1016": {"ttr": 45573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:36", "lines": 31, "newlines": 31, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR1016\nTz/OS TSO/E REXX Reference\nT-Chapter 10.\nT-TS\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-175936\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNChapter 10. TSO/E REXX commands\nN-------------------------------\nNTS\nN--\nNTS (Trace Start) is an immediate command you can use to start tracing\nNREXX execs. Tracing lets you control the execution of an exec and debug\nNproblems. The TS immediate command is available if an exec is running\nNin TSO/E and you press the attention interrupt key to enter attention\nNmode. You can enter TS in response to the REXX attention prompting\nNmessage, IRX0920I. The exec continues processing and tracing is\nNstarted.\nN\nNSyntax\nD  TS\nN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR9E": {"ttr": 45575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00\\x11\\x00\\x11\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:36", "lines": 17, "newlines": 17, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR9E\nTz/OS TSO/E REXX Reference\nT-Appendix E. REXX symbol and hexadecimal code cross-reference\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590354\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNThe table in REXR0E01 shows the REXX symbols and their corresponding\nNhexadecimal codes as found in U.S Code Page (037).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXR9E01": {"ttr": 45577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x18\\x13\\x7f\\x01\\x18\\x13\\x7f\\x17Y\\x00/\\x00/\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-17T00:00:00", "modifydate": "2018-05-17T17:59:37", "lines": 47, "newlines": 47, "modlines": 0, "user": "KTOMIAK"}, "text": "SREXR9E01\nTz/OS TSO/E REXX Reference\nT-Appendix E. REXX symbol and hexadecimal code cross-reference\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590354\n*\n@IBM Corporation\n*\nBikj4a3a0.pdf\nBSA22-7790-10 z/OS TSO/E REXX Reference\nBVersion 1 Release 13\n*\nNz/OS TSO/E REXX Reference\nN=========================\nNAppendix E. REXX symbol and hexadecimal code cross-reference\nN------------------------------------------------------------\nD  code_shift_out    = '0E'x\nD  code_shift_in     = '0F'x\nD  code_blank        = '40'x\nD  code_cent         = '4A'x\nD  code_period       = '4B'x\nD  code_lessthan     = '4C'x\nD  code_left_paren   = '4D'x\nD  code_plus         = '4E'x\nD  code_or           = '4F'x\nD  code_amp          = '50'x\nD  code_exclaim      = '5A'x\nD  code_dollar       = '5B'x\nD  code_asterisk     = '5C'x\nD  code_right_paren  = '5D'x\nD  code_semicolon    = '5E'x\nD  code_not          = '5F'x\nD  code_dash         = '60'x\nD  code_fwd_shash    = '61'x\nD  code_comma        = '6B'x\nD  code_percent      = '6C'x\nD  code_underscore   = '6D'x\nD  code_greater_than = '6E'x\nD  code_question     = '6F'x\nD  code_colon        = '7A'x\nD  code_pound        = '7B'x\nD  code_cost_at      = '7C'x\nD  code_apostrophe   = '7D'x\nD  code_equal        = '7E'x\nD  code_quote        = '7F'x\nD  code_back_slash   = 'E0'x\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT978/CBT.V500.FILE978.PDS/XMREXR.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT978/CBT.V500.FILE978.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}