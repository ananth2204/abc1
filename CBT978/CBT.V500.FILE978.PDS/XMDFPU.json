{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "KTOMIAK", "INMTNODE": "ANYNODE", "INMTUID": "KTOMIAK", "INMFTIME": "20180523170053000000", "INMNUMF": 2}, "INMR02": {"1": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 251, "INMBLKSZ": 3120, "INMRECFM": "VB", "numfile": 1}, "2": {"INMUTILN": "IEBCOPY", "INMSIZE": 999362, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 81, "INMBLKSZ": 27945, "INMRECFM": "FB", "INMDIR": 30, "INMDSNAM": "VENDOR.GENIE.WISHLIST", "INMMEMBR": "VENDOR.GENIE.WISHLIST", "numfile": 2}, "3": {"INMUTILN": "INMCOPY", "INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 2}}, "INMR03": {"1": {"INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}, "2": {"INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "message": {"file": "b'@\\x7f\\xd2\\x85\\x95\\x95\\x85\\xa3\\x88@\\xc5@\\xe3\\x96\\x94\\x89\\x81\\x92\\x7fL\\xc3\\xc2\\xe3m\\xd2\\x85\\x95|\\xd2\\xe3\\x96\\x94\\x89\\x81\\x92K\\x82\\x89\\xa9n\\xe4K\\xe2K\\xc1K@\\xc3\\xc3z@\\xc1\\xd5\\xe8\\xd5\\xd6\\xc4\\xc5@a\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\\xd2K@\\xe3\\x96\\x94\\x89\\x81\\x92@@@@@@@@@@@@@@@@@@@@@@\\xe2\\xe3\\xc1\\xd5\\xc4\\xc1\\xd9\\xc4@\\xc7\\xd3\\xd6\\xc2\\xc1\\xd3@\\xc4\\xc9\\xe2\\xc3\\xd3\\xc1\\xc9\\xd4\\xc5\\xd9``````````````````````````\\xe3\\x88\\x85@\\x81\\xa4\\xa3\\x88\\x96\\x99@\\x85\\xa7\\x97\\x93\\x89\\x83\\x89\\xa3\\x93\\xa8@\\x84\\x89\\xa2\\x81\\xa5\\x96\\xa6\\xa2@\\x81\\x95\\xa8@\\x83\\x93\\x81\\x89\\x94@\\xa6\\x88\\x81\\xa3\\xa2\\x96\\x85\\xa5\\x85\\x99@\\x81\\x82\\x96\\xa4\\xa3@\\xa3\\x88\\x85\\x83\\x96\\x99\\x99\\x85\\x83\\xa3\\x95\\x85\\xa2\\xa2@\\x96\\x99@\\x86\\xa4\\x95\\x83\\xa3\\x89\\x96\\x95\\x81\\x93\\x89\\xa3\\xa8@\\x96\\x86@\\xa3\\x88\\x89\\xa2@\\x97\\x99\\x96\\x87\\x99\\x81\\x94k@\\x81\\x95\\x84@\\x84\\x89\\xa2\\x83\\x93\\x81\\x89\\x94\\xa2@\\x93\\x89\\x81\\x82\\x89\\x93\\x89\\xa3\\xa8\\x86\\x96\\x99@\\x81\\x95\\xa8\\xa3\\x88\\x89\\x95\\x87@\\x81\\x95\\x84@\\x85\\xa5\\x85\\x99\\xa8\\xa3\\x88\\x89\\x95\\x87@\\x82\\x81\\x84@\\xa3\\x88\\x81\\xa3@\\x94\\x89\\x87\\x88\\xa3@\\x88\\x81\\x97\\x97\\x85\\x95@\\x89\\x95@\\x83\\x96\\x95\\x95\\x85\\x83\\xa3\\x89\\x96\\x95@\\xa6\\x89\\xa3\\x88k\\x82\\x85\\x86\\x96\\x99\\x85k@\\x84\\xa4\\x99\\x89\\x95\\x87k@\\x96\\x99@\\x81\\x86\\xa3\\x85\\x99@\\xa4\\xa2\\x89\\x95\\x87@\\x89\\xa3K@\\xc9@\\x88\\x81\\xa5\\x85@\\xa3\\x99\\x89\\x85\\x84@\\xa3\\x96@\\x94\\x81\\x92\\x85@\\x89\\xa3@\\xa6\\x96\\x99\\x92@\\x99\\x89\\x87\\x88\\xa3k\\x81\\x95\\x84@\\xc9@\\x81\\x94@\\x97\\x85\\x99\\xa2\\x96\\x95\\x81\\x93\\x93\\xa8@\\x97\\x99\\x85\\xa3\\xa3\\xa8@\\x83\\x96\\x95\\x86\\x89\\x84\\x85\\x95\\xa3@\\xa3\\x88\\x81\\xa3@\\x89\\xa3@\\x84\\x96\\x85\\xa2k@\\x82\\xa4\\xa3@\\x85\\xa5\\x85\\x99\\xa8\\x82\\x96\\x84\\xa8@\\x94\\x81\\x92\\x85\\xa2\\x94\\x89\\xa2\\xa3\\x81\\x92\\x85\\xa2k@\\xa2\\x96@\\x89\\x86@\\xa8\\x96\\xa4@\\xa4\\xa2\\x85@\\x89\\xa3k@\\xa8\\x96\\xa4@\\x84\\x96@\\xa2\\x96@\\x81\\xa3@\\xa8\\x96\\xa4\\x99@\\x96\\xa6\\x95@\\x99\\x89\\xa2\\x92K@\\xe2\\x89\\x95\\x83\\x85\\x99\\x85\\x93\\xa8@\\xa8\\x96\\xa4\\x99\\xa2k\\xd2\\x85\\x95\\x95\\x85\\xa3\\x88@\\xc5K@\\xe3\\x96\\x94\\x89\\x81\\x92@'", "lrecl": 80, "text": " \"Kenneth E Tomiak\"<CBT_Ken@KTomiak.biz>U.S.A. CC: ANYNODE /KTOMIAK   K. Tomiak\n                     STANDARD GLOBAL DISCLAIMER--------------------------The aut\nhor explicitly disavows any claim whatsoever about thecorrectness or functionali\nty of this program, and disclaims liabilityfor anything and everything bad that\nmight happen in connection with,before, during, or after using it. I have tried\nto make it work right,and I am personally pretty confident that it does, but eve\nrybody makesmistakes, so if you use it, you do so at your own risk. Sincerely yo\nurs,Kenneth E. Tomiak\n"}, "file": {"VENDOR.GENIE.WISHLIST": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27945, "DS1LRECL": 81, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3000, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "180143", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x002'", "DS1LSTAR": "b'\\x00\\xdf\\x02'", "DS1TRBAL": "b'\\xa4\\x06'"}, "COPYR2": {"deb": "b'\\x05\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x06\\x80\\x00\\x04z\\xcb\\xc8'", "extents": ["b'\\x05\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x06\\x80\\x00\\x04z\\xcb\\xc8'", "b'X}Ch\\x00\\x00\\x0b\\xa8\\x00\\x05\\x0b\\xb7\\x00\\x0e\\x00\\xeb'", "b'X}Ch\\x00\\x00\\x08M\\x00\\x03\\x08N\\x00\\x02\\x00\\x0f'", "b'X}Ch\\x00\\x00\\x06W\\x00\\r\\x06[\\x00\\x02\\x002'", "b'X}Ch\\x00\\x00\\x07\\x9d\\x00\\x00\\x07\\xa0\\x00\\x04\\x002'", "b'X}Ch\\x00\\x00\\x07\\xa0\\x00\\x05\\x07\\xa3\\x00\\t\\x002'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"DFPU": {"ttr": 24581, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00)\\x00)\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:43", "lines": 41, "newlines": 41, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU\nTDFSMSdfp Utilities\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-020805\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNSC26-7414-08 z/OS DFSMSdfp Utilities\nI\nNIBM's examples from the DFSMSdfp Utilities manual.\nI\nN Chapter 2.  IEBCOMPR Compare Data Sets Program\nN Chapter 3.  IEBCOPY  Library Copy Program\nN Chapter 4.  IEBDG    Test Data Generator Program\nN Chapter 5.  IEBEDIT  Edit Job Stream Program\nN Chapter 6.  IEBGENER Sequential Copy/Generate Data Set Program\nN Chapter 7.  IEBIMAGE Create Printer Image Program\nN Chapter 8.  IEBISAM  Indexed Sequential Access Method Program\nN Chapter 9.  IEBPDSE  PDSE Validation Program   *Note-1\nN Chapter 10. IEBPTPCH Print-Punch Program\nN Chapter 11. IEBUPDTE Update Data Set Program\nN Chapter 12. IEHINITT Initialize Tape Program\nN Chapter 13. IEHLIST  List System Data Program\nN Chapter 14. IEHMOVE  Move System Data Program\nN Chapter 15. IEHPROGM Program Maintenance Program\nN Chapter 16. IFHSTATR List ESV Data Program\nN Appendix A. Invoking Utility Programs from an\nN              Application Program\nN Appendix B. Unload Partitioned Data Set Format\nN\nNNote-1:\nNIBM was wise enough to add IEBPDSE in alphabetic sequence. But\nNwhy keep IEBISAM six (6) releases after support was dropped?\nNMy 2017 resurrection to work on the WISHLIST led me to\nNresequence my WISH members. Fortunately I am reviewing z/OS V1R13\nNmanuals before migrating wishes to a mainframe PDS and the\nNaddition is not that disruptive. It would have been nicer had\nNIBM just swapped IEBPDSE into the IEBISAM spot.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU02": {"ttr": 24583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00 \\x00 \\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:43", "lines": 32, "newlines": 32, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU02\nTdfp Utilities\nT-Chapter 2. IEBCOMPR (Compare Data Sets) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-021316\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNIEBCOMPR Examples\nN-----------------\nNExample 1: Compare Data Sets that Reside on Tape\nNExample 2: Compare Sequential Data Sets that Reside on Tape\nNExample 3: Compare Sequential Data Sets Written at Different Densities\nNExample 4: Compare Sequential Data Sets Input Stream and Tape Input\nNExample 5: Copy and Compare Sequential Data Set in Two Job Steps\nNExample 6: Compare Two Partitioned Data Sets\nNExample 7: Copy and Compare Partitioned Data Set in Two Job Steps\nNExample 8: Compare Two PDSEs\nN\nNReturn Codes Meaning\nN------------ ------------------------------------------------------\nN00 (X'00')   Successful completion.\nN08 (X'08')   An unequal comparison. Processing continues.\nN12 (X'0C')   An unrecoverable error exists. The utility ends.\nN16 (X'10')   A user routine passed a return code of 16 to IEBCOMPR.\nN             The utility ends.\nN------------ ------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0201": {"ttr": 24585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:44", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0201\nTdfp Utilities\nT-Chapter 2.\nT-Example 1: Compare Data Sets that Reside on Tape\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124944\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 1: Compare Data Sets that Reside on Tape\nN------------------------------------------------\nMIn this example, two sequential data sets that\nMreside on 9-track tape volumes are compared.\nD//TAPETAPE JOB ...\nD//ST01#01 EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD SYSOUT=A\nD//SYSUT1    DD DSNAME=SET1,UNIT=tape,LABEL=(,NL),\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=2000),\nD//             DISP=(OLD,KEEP),VOLUME=SER=001234\nD//SYSUT2    DD DSNAME=SET2,UNIT=tape,LABEL=(,NL),\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=1040),\nD//             DISP=(OLD,KEEP),VOLUME=SER=001235\nD//SYSIN     DD DUMMY\nD//*\nI\nMThe job control statements are discussed, as follows:\nM  SYSUT1 DD defines an input data set (SET1), which resides on\nM  an unlabeled 9-track tape volume.\nM\nM  SYSUT2 DD defines an input data set (SET2), which resides on\nM  an unlabeled 9-track tape volume.\nM\nM  SYSIN DD defines a dummy data set. Because no user routines\nM  are used and the input data sets have a sequential organization,\nM  utility control statements are not necessary.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0202": {"ttr": 24587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00D\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:44", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0202\nTdfp Utilities\nT-Chapter 2.\nT-Example 2: Compare Sequential Data Sets that Reside on Tape\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124944\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 2: Compare Sequential Data Sets that Reside on Tape\nN-----------------------------------------------------------\nNIn this example, two sequential data sets that reside on\nN7-track tape volumes are compared.\nD//TAPETAPE JOB ...\nD//ST01#01 EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD SYSOUT=A\nD//SYSUT1    DD DSNAME=SET1,LABEL=(2,SUL),DISP=(OLD,KEEP),\nD//             VOL=SER=001234,DCB=(DEN=2,RECFM=FB,LRECL=80,\nD//             BLKSIZE=2000,TRTCH=C),UNIT=tape\nD//SYSUT2    DD DSNAME=SET2,LABEL=(,SUL),DISP=(OLD,KEEP),\nD//             VOL=SER=001235,DCB=(DEN=2,RECFM=FB,LRECL=80,\nD//             BLKSIZE=2000,TRTCH=C),UNIT=tape\nD//SYSIN     DD *\nDCOMPARE TYPORG=PS\nDLABELS DATA=ONLY\nD/*\nI\nNThe control statements are discussed, as follows::\nN  SYSUT1 DD defines an input data set, SET1, which resides on\nN  a labeled, 7-track tape volume. The blocked data set was\nN  originally written at a density of 800 bits per inch (DEN=2)\nN  with the data converter on (TRTCH=C).\nN\nN  SYSUT2 DD defines an input data set, SET2, which is the first\nN  or only data set on a labeled, 7-track tape volume. The\nN  blocked data set was originally written at a density of\nN  800 bits per inch (DEN=2) with the data converter on (TRTCH=C).\nN\nN  SYSIN DD defines the control data set, which follows in the\nN  input stream.\nN\nN  COMPARE TYPORG=PS specifies that the input data sets are\nN  sequentially organized.\nN\nN  LABELS DATA=ONLY specifies that user header labels are to\nN  be treated as data and compared. All other labels on the\nN  tape are ignored.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0203": {"ttr": 24589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00D\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x007\\x007\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:44", "lines": 55, "newlines": 55, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0203\nTdfp Utilities\nT-Chapter 2.\nT-Example 3: Compare Sequential Data Sets Written at Different Densities\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124944\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 3: Compare Sequential Data Sets Written at Different Densities\nN----------------------------------------------------------------------\nNIn this example, two sequential data sets that were written at\nNdifferent densities on different tape units are compared.\nD//TAPETAPE JOB ....\nD//ST01#01 EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD SYSOUT=A\nD//SYSUT1    DD DSNAME=SET1,LABEL=(,SUL),DISP=(OLD,KEEP),\nD//             VOL=SER=001234,DCB=(DEN=1,RECFM=FB,LRECL=80,\nD//             BLKSIZE=320,TRTCH=C),UNIT=tape\nD//SYSUT2    DD DSNAME=SET2,LABEL=(,SUL),DISP=(OLD,KEEP),\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=640),\nD//             UNIT=tape,VOLUME=SER=001235\nD//SYSIN     DD *\nDCOMPARE TYPORG=PS\nDEXITS INHDR=HDRS,INTLR=TLRS\nDLABELS DATA=NO\nD/*\nN\nNThe control statements are discussed, as follows:\nN\nN  SYSUT1 DD defines an input data set, SET1, which is the first\nN  or only data set on a labeled, 7-track tape volume. The blocked\nN  data set was originally written at a density of 556 bits per\nN  inch (DEN=1) with the data converter on (TRTCH=C).\nN\nN  SYSUT2 DD defines an input data set, SET2, which is the first\nN  or only blocked data set on a labeled tape volume. In this\nN  example, assume SYSUT2 is on a 9-track tape drive.\nN\nN  SYSIN DD defines the control data set, which follows in the\nN  input stream.\nN\nN  COMPARE TYPORG=PS specifies that the input data sets are\nN  sequentially organized.\nN\nN  EXITS identifies the names of routines to be used to process\nN  user input header labels and trailer labels.\nN\nN  LABELS DATA=NO specifies that the user input header and trailer\nN  labels for each data set are not to be compared.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0204": {"ttr": 24591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00-\\x00-\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:44", "lines": 45, "newlines": 45, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0204\nTdfp Utilities\nT-Chapter 2.\nT-Example 4: Compare Sequential Data Sets-Input Stream and Tape Input\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124944\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 4: Compare Sequential Data Sets-Input Stream and Tape Input\nN-------------------------------------------------------------------\nNIn this example, two sequential data sets (input stream and tape)\nNare compared.\nN\nD//CARDTAPE JOB ...\nD//ST01#01 EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD DUMMY\nD//SYSUT2    DD DISP=(OLD,KEEP),\nD//             UNIT=tape,LABEL=(,NL),\nD//             VOL=SER=001234,\nD//             DCB=(RECFM=FB,BLKSIZE=2000,LRECL=80)\nD//SYSUT1    DD DATA\nD\nD (input data set)\nD\nD/*\nN\nNThe control statements are discussed, as follows:\nN\nN  SYSIN DD defines a dummy control data set. Because no user\nN  routines are provided and the input data sets are sequential,\nN  utility control statements are not necessary.\nN\nN  SYSUT2 DD defines an input data set, which resides on an unlabeled,\nN  tape volume.\nN\nN  SYSUT1 DD defines a system input stream data set.\nN\nN  (input data set) represents what you believe is on the tape.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0205": {"ttr": 24593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x002\\x002\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:45", "lines": 50, "newlines": 50, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0205\nTdfp Utilities\nT-Chapter 2.\nT-Example 5: Copy and Compare Sequential Data Set in Two Job Steps\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124945\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 5: Copy and Compare Sequential Data Set in Two Job Steps\nN----------------------------------------------------------------\nNIn this example, a sequential disk or tape data set is copied and\nNcompared in two job steps.\nN\nD//TAPETAPE JOB ...\nD//ST01#02 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD,PASS),DSN=WAREHOUS.COPYSET1\nD//SYSUT2    DD DISP=(,PASS),DSN=WAREHOUS.COPYSET2,\nD//             UNIT=tape,LABEL=(,SL),\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=640)\nD//SYSIN     DD DUMMY\nD//*\nD//ST02#02 EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD,KEEP),DSN=*.STEPA.SYSUT1\nD//SYSUT2    DD DISP=(OLD,KEEP),DSN=*.STEPA.SYSUT2\nD//SYSIN     DD DUMMY\nN\nNThe first job step copies the data set and passes the original and\nNcopied data sets to the second job step. The second job step compares\nNthe two data sets.\nN\nNThe control statements for the IEBCOMPR job step are discussed below:\nN\nN  SYSUT1 DD defines an input data set passed from the preceding job\nN  step (COPYSET1). The data set resides on a labeled tape volume.\nN\nN  SYSUT2 DD defines an input data set passed from the preceding job\nN  step (COPYSET2). The data set, which was created in the preceding\nN  job step, resides on a labeled tape volume.\nN\nN  SYSIN DD defines a dummy control data set. Because the input is\nN  sequential and no user exits are provided, no utility control\nN  statements are required.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0206": {"ttr": 24595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:45", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0206\nTdfp Utilities\nT-Chapter 2.\nT-Example 6: Compare Two Partitioned Data Sets\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124945\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 6: Compare Two Partitioned Data Sets\nN--------------------------------------------\nNIn this example, two partitioned data sets are compared.\nN\nD//DISKDISK JOB ...\nD//STEP1   EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD  SYSOUT=*\nD//SYSUT1    DD  DISP=(SHR),DSN=PDSSET1\nD//SYSUT2    DD  DISP=(SHR),DSN=PDSSET2\nD//SYSIN     DD  *\nD         COMPARE TYPORG=PO\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines an input partitioned data set, PDSSET1. The\nN  blocked data set resides on a disk volume.\nN\nN  SYSUT2 DD defines an input partitioned data set, PDSSET2. The\nN  blocked data set resides on a disk volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  COMPARE TYPORG=PO indicates that the input data sets are\nN  partitioned.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0207": {"ttr": 24597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00A\\x00A\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:45", "lines": 65, "newlines": 65, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0207\nTdfp Utilities\nT-Chapter 2.\nT-Example 7: Copy and Compare Partitioned Data Set in Two Job Steps\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124945\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 7: Copy and Compare Partitioned Data Set in Two Job Steps\nN-----------------------------------------------------------------\nNIn this example, a partitioned data set is copied and compared in two\nNjob steps.\nN\nD//DISKDISK JOB ...\nD//ST01#02 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR),DSN=MAINDB.LOG.OLDSET\nD//SYSUT2    DD DISP=(NEW,PASS),DSN=MAINDB.LOG.NEWMEMS,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(5,5,5)),\nD//             DCB=(DSPRG=PO,RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSUT4    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSIN     DD *\nD         COPY OUTDD=SYSUT2,INDD=SYSUT1\nD         SELECT MEMBER=(A,B,D,E,F)\nD/*\nD//ST02#02 EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD,KEEP),DSN=MAINDB.LOG.OLDSET\nD//SYSUT2    DD DISP=(OLD,KEEP),DSN=MAINDB.LOG.NEWMEMS\nD//SYSIN     DD *\nD         COMPARE TYPORG=PO\nD         EXITS   ERROR=SEEERROR\nD/*\nN\nNThe first job step copies the data set and passes the original and\nNcopied data sets to the second job step. The second job step compares\nNthe two data sets.\nN\nNThe control statements for the IEBCOMPR job step are discussed below:\nN\nN  SYSUT1 DD defines a blocked input data set (MAINDB.LOG.OLDSET) that\nN  is passed from the preceding job step. The data set resides on a\nN  disk or tape volume.\nN\nN  SYSUT2 DD defines a blocked input data set (MAINDB.LOG.NEWMEMS) that\nN  is passed from the preceding job step. The data set resides on a disk\nN  volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  COMPARE TYPORG=PO specifies partitioned organization.\nN\nN  EXITS specifies that a user error routine, SEEERROR, is to be used.\nN\nMBecause the input data set names are not identical, the data sets can\nMbe retrieved by their data set names.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0208": {"ttr": 24833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:45", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0208\nTdfp Utilities\nT-Chapter 2.\nT-Example 8: Compare Two PDSEs\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124945\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 2. IEBCOMPR (Compare Data Sets) Program\nN-----------------------------------------------\nNExample 8: Compare Two PDSEs\nN----------------------------\nNIn this example, two PDSEs are compared.\nN\nD//DISKDISK JOB ...\nD//ST01#01 EXEC PGM=IEBCOMPR\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR),DSN=PDSE1\nD//SYSUT2    DD DISP=(SHR),DSN=PDSE2\nD//SYSIN     DD *\nD         COMPARE TYPORG=PO\nD/*\nN\nNPDSEs no longer must be SMS managed. Because these PDSEs are cataloged,\nNyou need not specify the UNIT or VOLUME parameters.\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD and SYSUT2 DD define input PDSEs, PDSE1, and PDSE2.\nN  Because no DCB values are specified, the DCB values that were\nN  specified in creating the data sets will be used.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  COMPARE TYPORG=PO indicates that the input data sets are PDSEs.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU03": {"ttr": 24835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:46", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU03\nTdfp Utilities\nT-Chapter 3. IEBCOPY (Library Copy) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-023038\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 1: Copy an Entire Data Set\nNExample 2: Merge Four Data Sets\nNExample 3: Copy and Replace Selected Members of a Data Set\nNExample 4: Unload and Compress a Data Set\nNExample 5: Merge Data Sets and Compress the Merged Data Set\nNExample 6: Multiple Copy Operations with One Output Data Set\nNExample 7: Multiple Copy Operations with Different Output Data Sets\nNExample 8: Loading a Data Set\nNExample 9: Unload Selected Members, Load, Copy and Merge\nNExample 10: Alter Load Modules in Place\nNExample 11: Replace a Load Module Using COPYMOD\nNExample 12: Reblock Load Library and Distribute it to\nN            different Device Types\nNExample 13: Convert a Partitioned Data Set to a PDSE\nNExample 14: Copy Groups from a PDSE to a PDSE\nNExample 15: Copy Groups from a PDSE to a PDSE with Replace\nNExample 16: Copy a Selected Group from a PDSE to a PDSE\nI\nNReturn Codes Meaning\nN------------ ---------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   One or more copy group operations ended unsuccessfully or\nN             were incompletely performed. Recovery may be possible.\nN08 (X'08')   An unrecoverable error exists. The utility ends.\nN------------ ---------------------------------------------------------\nN\nNIEBCOPY User ABEND Codes in a diagnostic situation, IEBCOPY may issue\nNa user ABEND.  This occurs only when the procedures in z/OS DFSMSdfp\nNDiagnosis are being followed.  An IEBCOPY message always precedes the\nNABEND. The ABEND code is the same as the message number. For example,\nNmessage IEB1021E will precede user ABEND  21.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0301": {"ttr": 24837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:46", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0301\nTdfp Utilities\nT-Chapter 3.\nT-Example 1: Copy an Entire Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124946\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 1: Copy an Entire Data Set\nN----------------------------------\nNIn this example, a partitioned data set (DATASET5) is copied from\nNone disk volume to another.\nN\nD//COPY     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR),DSN=DATASET5\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=DATASET4,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(5,1,2))\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines a partitioned data set, DATASET5, that contains\nN  two members (A and C).\nN\nN  SYSUT2 DD defines a new partitioned data set, DATASET4, that is to\nN  be kept after the copy operation. Five tracks are allocated for the\nN  data set; two blocks are allocated for directory entries.\nN\nMBecause the partitioned data set has only two members, SYSUT3 and\nMSYSUT4 DD are not needed.\nM\nMBecause the input and output data sets are identified as SYSUT1 and\nMSYSUT2, the SYSIN data set is not needed. The SYSUT1 data set will\nMbe copied in full to the SYSUT2 data set. After the copy operation\nMis finished, DATASET4 will contain the same members that are in\nMDATASET5. However, there will be no embedded, unused space in\nMDATASET4. If you are copying a PDSE, the processing is the same,\nMexcept that there is no embedded, unused space in a PDSE.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0302": {"ttr": 24839, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00K\\x00K\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:46", "lines": 75, "newlines": 75, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0302\nTdfp Utilities\nT-Chapter 3.\nT-Example 2: Merge Four Data Sets\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124946\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 2: Merge Four Data Sets\nN-------------------------------\nNIn this example, members are copied from three input partitioned data\nNsets (DATASET1, DATASET5, and DATASET6) to an existing output\nNpartitioned data set (DATASET2). The sequence in which the control\nNstatements occur controls the manner and sequence in which partitioned\nNdata sets are processed.\nN\nD//COPY     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//IN1       DD DISP=(SHR),DSN=DATASET1\nD//IN5       DD DISP=(OLD),DSN=DATASET5\nD//OUT2      DD DISP=(OLD,KEEP),DSN=DATASET2\nD//IN6       DD DISP=(OLD,DELETE),DSN=DATASET6\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSIN     DD *\nDCOPYOPER COPY OUTDD=OUT2\nD         INDD=IN1\nD         INDD=IN6\nD         INDD=IN5\nD/*\nN\nNThe control statements are discussed below:\nN\nN  IN1 DD defines a partitioned data set (DATASET1).\nN\nN  IN5 DD defines a partitioned data set (DATASET5).\nN\nN  OUT2 DD defines a partitioned data set (DATASET2).\nN\nN  IN6 DD defines a partitioned data set (DATASET6). This data set\nN  is to be deleted when processing is completed.\nN\nN  SYSUT3 defines a temporary spill data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains a COPY statement and three INDD\nN  statements.\nN\nN  COPY indicates the start of the copy operation. The OUTDD parameter\nN  specifies DATASET2 as the output data set.\nM\nN  The first INDD statement specifies DATASET1 as the first input data\nN  set to be processed. All members (A, B and F) are copied to\nN  DATASET2.\nN\nN  The second INDD statement specifies DATASET6 as the second input\nN  data set to be processed.\nN  Processing occurs as follows:\nN\nM  1. Since replacement is not specified, members B and C, which already\nM     exist in DATASET2, are not copied to DATASET2.\nM\nM  2. Member D is copied to DATASET2.\nM\nM  3. All members in DATASET6 are lost when the data set is deleted.\nM\nN  The third INDD statement specifies DATASET5 as the third input data\nN  set to be processed. No members are copied to DATASET2 because all\nN  exist in DATASET2.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0303": {"ttr": 24841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00O\\x00O\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:46", "lines": 79, "newlines": 79, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0303\nTdfp Utilities\nT-Chapter 3.\nT-Example 3: Copy and Replace Selected Members of a Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124946\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 3: Copy and Replace Selected Members of a Data Set\nN----------------------------------------------------------\nNIn this example, two members (A and B) are selected from two input\nNpartitioned data sets (DATASET5 and DATASET6) and copied to an existing\nNoutput partitioned data set (DATASET1). Member B replaces an\nNidentically named member that already exists on the output data set.\nN\nD//COPY     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//OUT1      DD DISP=(OLD,KEEP),DSN=DATASET1\nD//IN6       DD DISP=(OLD),DSN=DATASET6\nD//IN5       DD DISP=(OLD,KEEP),DSN=DATASET5\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSUT4    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSIN     DD *\nDCOPYOPER COPY OUTDD=OUT1\nD         INDD=IN5,IN6\nD         SELECT MEMBER=((B,,R),A)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  OUT1 DD defines a partitioned data set (DATASET1), which contains\nN  three members (A, B and F).\nN\nN  IN6 DD defines a partitioned data set (DATASET6), which contains\nN  three members (B, C and D).\nN\nN  IN5 DD defines a partitioned data set (DATASET5), which contains\nN  two members (A and C).\nN\nN  SYSUT3 and SYSUT4 DD define temporary spill data sets. One track is\nN  allocated for each on a disk volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains a COPY statement, an INDD statement,\nN  and a SELECT statement.\nN\nN  COPY indicates the start of the copy operation. The use of a SELECT\nN  statement causes a selective copy. The OUTDD parameter specifies\nN  DATASET1 as the output data set.\nN\nN  INDD specifies DATASET5 as the first input data set to be processed\nN  and DATASET6 as the second input data set to be processed.\nN  Processing occurs as follows:\nM\nM  1. Selected members are searched for on DATASET5.\nM\nM  2. Member A is found, but is not copied to DATASET1 because DATASET1\nM     already has a member named \"A\", and the replace option is not\nM     specified for member A.\nM\nM  3. Selected members not found on DATASET5 are searched for on\nM     DATASET6.\nM\nM  4. Member B is found and copied to DATASET1, even though there is\nM     already a DATASET1 member \"B\" in DATASET1, because the replace\nM     option is specified for member B on the member level. The pointer\nM     in DATASET1's directory is changed to point to the new (copied)\nM     member B; thus, the space occupied by the old member B is unused.\nM\nN  SELECT specifies the members to be selected from the input data sets\nN  (DATASET5 and DATASET6) to be copied to the output data set\nN  (DATASET1).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0304": {"ttr": 24843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00U\\x00U\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:46", "lines": 85, "newlines": 85, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0304\nTdfp Utilities\nT-Chapter 3.\nT-Example 4: Unload and Compress a Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124946\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 4: Unload and Compress a Data Set\nN-----------------------------------------\nNIn this example, a partitioned data set is unloaded to a tape volume to\nNcreate a backup copy of the data set. If this step is successful, the\nNpartitioned data set is to be compressed in place.\nN\nD//SAVE     JOB ...\nD//ST01#02 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=PARTPDS\nD//SYSUT2    DD DISP=(NEW,KEEP),DSN=SAVDATA,\nD//             UNIT=tape,LABEL=(,SL)\nD//SYSUT3    DD DISP=(NEW,DELETE),DSN=&&TEMP1,\nD//             UNIT=disk\nD//             SPACE=(80,(60,45))\nD//SYSIN     DD DUMMY\nD//*\nD//ST02#02 EXEC PGM=IEBCOPY,COND=(0,NE),PARM='SIZE=500K'\nD//SYSPRINT  DD SYSOUT=*\nD//COMPDS    DD DISP=(OLD),DSN=PARTPDS,UNIT=disk,\nD//             VOL=SER=PCP001\nD//SYSUT3    DD DISP=(NEW,DELETE),DSN=&&TEMPA,\nD//             UNIT=disk,\nD//             SPACE=(80,(60,45))\nD//SYSIN     DD *\nD         COPY OUTDD=COMPDS,INDD=COMPDS\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines a partitioned data set (PARTPDS) that resides on\nN  a disk volume and is assumed to have 700 members. The number of\nN  members is used to calculate the space allocation on SYSUT3.\nN\nN  SYSUT2 DD defines a sequential data set to hold PARTPDS in unloaded\nN  form. Block size information can optionally be added; this data set\nN  must be NEW.\nN\nN  SYSUT3 DD defines the temporary spill data set. The SYSUT4 data set\nN  is never used for an unload operation.\nN\nN  SYSIN DD defines the control data set. Because SYSIN is dummied and\nN  SYSUT2 defines a sequential data set, all members of the SYSUT1 data\nN  set will be unloaded to the SYSUT2 data set.\nN\nN  The second EXEC statement marks the beginning of the\nN  compress-in-place operation. The SIZE parameter indicates that the\nN  buffers are to be as large as possible. The COND parameter indicates\nN  that the compress-in-place is to be performed only if the unload\nN  operation was successful.\nN\nN  COMPDS DD defines a partitioned data set (PARTPDS) that contains 700\nN  members and resides on a disk volume.\nN\nN  SYSUT3 DD defines the temporary spill data set to be used if there\nN  is not enough space in main storage for the input data set's\nN  directory entries. TEMPA contains one 80-character record for each\nN  member.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains a COPY statement.\nN\nN  COPY marks the beginning of the copy operation. Because the same DD\nN  statement is specified for both the INDD and OUTDD operands, the\nN  data set is compressed in place. If a PDSE is being used, this step\nN  will not be processed.\nM\nMIf you want to unload more than one data set in a single use of\nMIEBCOPY, you must use a separate COPY statement for each unload\nMoperation. Only one input data set may be specified in an unload\nMoperation.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0305": {"ttr": 24845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00P\\x00P\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:47", "lines": 80, "newlines": 80, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0305\nTdfp Utilities\nT-Chapter 3.\nT-Example 5: Merge Data Sets and Compress the Merged Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124947\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 5: Merge Data Sets and Compress the Merged Data Set\nN-----------------------------------------------------------\nNIn this example, two input partitioned data sets (DATASET5 and\nNDATASET6) are copied to an existing output partitioned data set\nN(DATASET1). In addition, all members on DATASET6 are copied; members on\nNthe output data set that have the same names as the copied members are\nNreplaced. After DATASET6 is processed, the output data set (DATASET1)\nNis compressed in place.\nN\nD//COPY     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//INOUT1    DD DISP=(OLD,KEEP),DSN=DATASET1\nD//IN5       DD DISP=(OLD),DSN=DATASET5\nD//IN6       DD DISP=(OLD,KEEP),DSN=DATASET6\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSUT4    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSIN     DD *\nDCOPYOPER COPY OUTDD=INOUT1,INDD=(IN5,(IN6,R),INOUT1)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  INOUT1 DD defines a partitioned data set (DATASET1), which contains\nN  three members (A, B and F).\nN\nN  IN5 DD defines a partitioned data set (DATASET5), which contains two\nN  members (A and C).\nN\nN  IN6 DD defines a partitioned data set (DATASET6), which contains\nN  three members (B, C and D).\nN\nN  SYSUT3 and SYSUT4 DD define temporary spill data sets. One track is\nN  allocated for each on a disk volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains a COPY statement.\nN\nN  COPY indicates the start of the copy operation. The OUTDD operand\nN  specifies DATASET1 as the output data set.\nN\nN  The INDD operand specifies DATASET5 as the first input data set to\nN  be processed. It then specifies DATASET6 as the second input data\nN  set to be processed. In addition, the replace option is specified\nN  for all members copied from DATASET6. Finally, it specifies DATASET1\nN  as the last input data set to be processed. Since DATASET1 is also\nN  the output data set, DATASET1 is compressed in place. However, if\nN  DATASET1 is a PDSE, the compress-in-place operation will not be\nN  processed.\nN  Processing occurs as follows:\nM\nM  1. Member A is not copied from DATASET5 into DATASET1 because it\nM     already exists on DATASET1 and the replace option was not\nM     specified for DATASET5.\nM\nM  2. Member C is copied from DATASET5 to DATASET1, occupying the first\nM     available space.\nM\nM  3. All members are copied from DATASET6 to DATASET1, immediately\nM     following the last member. Members B and C are copied even though\nM     the output data set already contains members with the same names\nM     because the replace option is specified on the data set level. The\nM     pointers in DATASET1's directory are changed to point to the new\nM     members B and C. Thus, the space occupied by the old members B and\nM     C is unused. The members currently on DATASET1 are compressed in\nM     place, thereby eliminating embedded unused space.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0306": {"ttr": 24847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00n\\x00n\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:47", "lines": 110, "newlines": 110, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0306\nTdfp Utilities\nT-Chapter 3.\nT-Example 6: Multiple Copy Operations with One Output Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124947\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 6: Multiple Copy Operations with One Output Data Set\nN------------------------------------------------------------\nNIn this example, members are selected, excluded, and copied from input\nNpartitioned data sets onto an output partitioned data set. This example\nNis designed to illustrate multiple copy operations.\nN\nNThe example follows.\nN\nD//COPY     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//INOUTA    DD DISP=(OLD),DSN=DATASETA\nD//INB       DD DISP=(OLD),DSN=DATASETB\nD//INC       DD DISP=(OLD),DSN=DATASETC\nD//IND       DD DISP=(OLD),DSN=DATASETD\nD//INE       DD DISP=(OLD),DSN=DATASETE\nD//OUTX      DD DISP=(NEW,CATLG),DSN=DATASETX,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(3,1,2))\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSIN     DD *\nDCOPERST1 COPY    O=OUTX,I=INOUTA\nD         COPY    OUTDD=INOUTA,INDD=INOUTA\nD         INDD=INB\nD         COPY    OUTDD=INOUTA\nD         INDD=IND\nD         EXCLUDE MEMBER=MM\nD         INDD=INC\nD         SELECT  MEMBER=((ML,MD,R))\nD         INDD=INE\nD/*\nN\nNThe control statements are discussed below:\nN\nN  INOUTA DD defines a partitioned data, DATASETA, which contains seven\nN  members (MA, MB, MC, MD, ME, MF and MG).\nN\nN  INB DD defines a partitioned data set, DATASETB, which contains two\nN  members (MA and MJ).\nN\nN  INC DD defines a partitioned data set,\nN  DATASETC, which contains four members (MF, ML, MM and MN).\nN\nN  IND DD defines a partitioned data set, DATASETD, which contains two\nN  members (MM and MP).\nN\nN  INE DD defines a partitioned data set, DATASETE, which contains four\nN  members (MD, ME, MF and MT).\nN\nN  OUTX DD defines a partitioned data set (DATASETX). This data set is\nN  new and is to be kept after the copy operation. Three tracks are\nN  allocated for the data set on a disk volume. Two blocks are allocated\nN  for directory entries.\nN\nN  SYSUT3 defines a temporary spill data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains two COPY statements, several INDD\nN  statements, a SELECT statement, and an EXCLUDE statement.\nN\nN  The first COPY statement indicates the start of the first copy\nN  operation. This copy operation is done to create a backup copy of\nN  DATASETA.\nN\nN  The second COPY statement indicates the start of another copy\nN  operation. Since DATASETA is specified in both the INDD and OUTDD\nN  parameters, DATASETA is compressed in place. The output data set is\nN  compressed in place first to save space because it is known that it\nN  contains embedded, unused space.\nN\nN  The following INDD statement specifies DATASETB as the next input\nN  data set to be copied. Only member MJ is copied, because DATASETA\nN  already contains a member named \"MA\".\nN\nN  The third COPY statement indicates the start of the third copy\nN  operation. The OUTDD parameter specifies DATASETA as the output data\nN  set. This copy operation contains more than one copy step.\nN\nN  The first INDD statement specifies DATASETD as the first input data\nN  set to be processed. Only member MP is copied to DATASETA because\nN  the EXCLUDE statement specifies that member MM is to be excluded\nN  from the first copy step within this copy operation.\nN\nN  The second INDD statement marks the beginning of the second copy\nN  step for this copy operation and specifies DATASETC as the second\nN  input data set to be processed. The SELECT statement specifies that\nN  member ML of DATASETC is to be renamed \"MD\", and that the new member\nN  will replace any member in DATASETA that happens to be named \"MD\".\nN  Member ML is searched for, found, copied to DATASETA and renamed.\nN\nN  The third INDD statement marks the beginning of the third copy step\nN  for this copy operation and specifies DATASETE as the last data set\nN  to be copied. Only member MT is copied, because DATASETA already\nN  contains the other members. Because the INDD statement is not\nN  followed by an EXCLUDE or SELECT statement, a full copy is\nN  performed.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0307": {"ttr": 25089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00q\\x00q\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:47", "lines": 113, "newlines": 113, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0307\nTdfp Utilities\nT-Chapter 3.\nT-Example 7: Multiple Copy Operations with Different Output Data Sets\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124947\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 7: Multiple Copy Operations with Different Output Data Sets\nN-------------------------------------------------------------------\nNIn this example, members are selected, excluded, and copied from input\nNpartitioned data sets to an output partitioned data set. This example\nNis designed to illustrate multiple copy operations.\nN\nN The example follows:\nN\nD//COPY     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//OUTA      DD DISP=(OLD),DSN=DATASETA\nD//INOUTB    DD DISP=(OLD),DSN=DATASETB\nD//INOUTC    DD DISP=(OLD,KEEP),DSN=DATASETC\nD//INOUTD    DD DISP=(OLD),DSN=DATASETD\nD//INE       DD DISP=(OLD),DSN=DATASETE\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSUT4    DD UNIT=disk,SPACE=(TRK,(1))\nD//SYSIN    DD *\nD         COPY    OUTDD=OUTA\nD         INDD=INE\nD         SELECT  MEMBER=(MA,MJ)\nD         INDD=INOUTC\nD         EXCLUDE MEMBER=(MM,MN)\nD         COPY    OUTDD=INOUTB,INDD=INOUTD\nD         INDD=((INOUTC,R),INOUTB)\nD         COPY    OUTDD=INOUTD,INDD=((INOUTB,R))\nD         SELECT  MEMBER=MM\nD/*\nN\nNThe control statements are discussed below:\nN\nN  OUTA DD defines a partitioned data set, DATASETA, which contains\nN  three members (MA, MB and MD).\nM\nN  INOUTB DD defines a partitioned data set, DATASETB, which contains\nN  two members (MA and MJ).\nM\nN  INOUTC DD defines a partitioned data set, DATASETC, which contains\nN  four members (MF, ML, MM and MN).\nM\nN  INOUTD DD defines a partitioned data set, DATASETD, which contains\nN  two members (MM and MP).\nM\nN  INE DD defines a partitioned data set, DATASETE, which contains\nN  three members (MA, MJ and MK).\nM\nN  SYSUT3 and SYSUT4 DD define temporary spill data sets. One track is\nN  allocated for each on a disk volume.\nM\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains three COPY statements, two SELECT\nN  statements, one EXCLUDE statement, and several INDD statements.\nM\nN  The first COPY statement indicates the start of a copy operation.\nN  The OUTDD operand specifies DATASETA as the output data set.\nM\nN  The first INDD statement specifies DATASETE as the first input data\nN  set to be processed. The SELECT statement specifies that members MA\nN  and MJ are to be copied from DATASETE to DATASETA. Processing occurs\nN  as follows:\nM\nM  1. Member MA is searched for and found, but is not copied because the\nM     replace option is not specified.\nM\nM  2. Member MJ is searched for, found, and copied to DATASETA.\nM\nN  The second INDD statement marks the end of the first copy step and\nN  the beginning of the second copy step within the first copy\nN  operation. It specifies DATASETC as the second input data set to be\nN  processed. Members MF and ML, which are not named on the EXCLUDE\nN  statement, are copied because DATASETA contains neither one of them.\nN  EXCLUDE specifies that members MM and MN are not to be copied from\nN  DATASETC to DATASETA.\nN\nN  The second COPY statement indicates the start of another copy\nN  operation. The OUTDD parameter specifies DATASETB as the output data\nN  set. The INDD parameter specifies DATASETD as the first input data\nN  set to be processed. Members MP and MM are copied to DATASETB.\nN\nN  The next INDD statement specifies DATASETC as the second and\nN  DATASETB as the third input data set to be processed. Members MF,\nN  ML, MM and MN are copied from DATASETC. Member MM is copied,\nN  although DATASETB already contains a member MM, because the replace\nN  option is specified.\nN\nN  The pointer in DATASETB's directory is changed to point to the new\nN  (copied) member MM. Thus, the space occupied by the replaced member\nN  MM is embedded, unused space. DATASETB is then compressed in place\nN  to remove embedded, unused space. (DATASETB is specified as both the\nN  input and output data sets.)\nN\nN  The third COPY statement indicates the start of the last copy\nN  operation. The OUTDD parameter specifies DATASETD as the output data\nN  set. The INDD parameter specifies DATASETB as the input data set.\nN\nN  SELECT specifies that member MM is to be copied from DATASETB to\nN  DATASETD. Since the replace option is specified on the data set\nN  level, member MM is copied and replaces DATASETDs member MM.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0308": {"ttr": 25091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x001\\x001\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:47", "lines": 49, "newlines": 49, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0308\nTdfp Utilities\nT-Chapter 3.\nT-Example 8: Loading a Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124947\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 8: Loading a Data Set\nN-----------------------------\nNIn this example, a sequential data set that was created by an IEBCOPY\nNunload operation is loaded.\nN\nD//LOAD     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=UNLOADSET\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=DATASET4,\nD//             UNIT=disk,\nD//             SPACE=(CYL,(10,5,10))\nD//SYSUT3    DD DISP=(NEW,DELETE),DSN=&&TEMP1,\nD//             UNIT=disk,\nD//             SPACE=(80,(15,1))\nD//SYSIN     DD DUMMY\nD//*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines a sequential data set that was previously created\nN  by an IEBCOPY unload operation. The data set contains 28 members in\nN  sequential organization.\nN\nN  SYSUT2 DD defines a new partitioned data set on a disk volume. This\nN  data set is to be kept after the load operation. Ten cylinders are\nN  allocated for the data set; ten blocks are allocated for directory\nN  entries.\nN\nN  SYSUT3 DD defines a temporary spill data set on a disk volume.\nN\nN  SYSIN DD defines the control data set. Because SYSIN is dummied,\nN  SYSUT1 defines a sequential data set, and SYSUT2 defines a\nN  partitioned data set, the entire SYSUT1 data set will be loaded into\nN  the SYSUT2 data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0309": {"ttr": 25093, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00s\\x00s\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:48", "lines": 115, "newlines": 115, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0309\nTdfp Utilities\nT-Chapter 3.\nT-Example 9: Unload Selected Members, Load, Copy and Merge\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124948\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 9: Unload Selected Members, Load, Copy and Merge\nN--------------------------------------------------------\nNIn this example, members are selected, excluded, unloaded, loaded, and\nNcopied. Processing will occur as follows:\nN\nN  1. unload, excluding members\nN  2. unload, selecting members\nN  3. load and copy to merge members\nN\nD//COPY     JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//PDS1      DD DISP=(OLD),DSN=ACCOUNTA\nD//PDS2      DD DISP=(OLD),DSN=ACCOUNTB\nD//SEQ1      DD DISP=(NEW,CATLG),DSN=SAVAC,\nD//             UNIT=disk,\nD//             SPACE=(CYL,(5,2))\nD//SEQ2      DD DISP=(NEW,CATLG),DSN=SAVACB,\nD//             UNIT=tape,\nD//             LABEL=(,SL)\nD//NEWUP     DD DISP=(OLD),DSN=NEWACC\nD//MERGE     DD DISP=(OLD),DSN=ACCUPDAT\nD//SYSUT3    DD DISP=(NEW,DELETE),DSN=&&TEMP1,\nD//             UNIT=disk,\nD//             SPACE=(80,(1,1))\nD//SYSUT4    DD DISP=(NEW,DELETE),DSN=&&TEMP2,\nD//             UNIT=disk,\nD//             SPACE=(256,(1,1)),DCB=(KEYLEN=8)\nD//SYSIN     DD *\nD         COPY    OUTDD=SEQ1,INDD=PDS1\nD         EXCLUDE MEMBER=(D,C)\nD         COPY    OUTDD=SEQ2,INDD=PDS2\nD         SELECT  MEMBER=(A,K)\nD         COPY    OUTDD=MERGE,INDD=((NEWUP,R),PDS1,PDS2)\nD         EXCLUDE MEMBER=A\nD/*\nN\nNThe control statements are discussed below:\nN\nN  PDS1 DD defines a partitioned data set called ACCOUNTA that contains\nN  six members (A, B, C, D, E, and F).\nN\nN  PDS2 DD defines a partitioned data set called ACCOUNTB that contains\nN  three members (A, K, and L).\nN\nN  SEQ1 DD defines a new sequential data set called SAVAC.\nN\nN  SEQ2 DD defines a new sequential data set called SAVACB on a tape\nN  volume. The tape has IBM standard labels.\nN\nN  NEWUP DD defines an old sequential data set called NEWACC that is\nN  the unloaded form of a partitioned data set that contains eight\nN  members (A, B, C, D, M, N, O, and P). It resides on a tape volume.\nN\nN  MERGE DD defines a partitioned data set called ACCUPDAT that\nN  contains six members (A, B, C, D, Q, and R).\nN\nN  SYSUT3 and SYSUT4 DD define temporary spill data sets.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The first COPY statement indicates the start of the first copy\nN  operation. The OUTDD parameter specifies that SAVAC is the output\nN  data set, and the INNDD parameter specifies that ACCOUNTA is the\nN  input data set. Because SAVAC is a sequential data set, ACCOUNTA\nN  will be unloaded in this copy operation.\nN\nN  The EXCLUDE statement specifies that members D and C are not to be\nN  unloaded to SAVAC with the rest of ACCOUNTA.\nN\nN  The second COPY statement indicates the start of the second copy\nN  operation.\nN\nN  The OUTDD parameter specifies that SAVACB is the output data set,\nN  and the INDD parameter specifies that ACCOUNTB is the input data\nN  set. Because SAVACB is a sequential data set, ACCOUNTB will be\nN  unloaded in this copy operation.\nN\nN  The SELECT statement specifies that members A and K are the only\nN  members of ACCOUNTB that are to be unloaded to SAVACB.\nN\nN  The third COPY statement indicates the start of the last copy\nN  operation. The OUTDD parameter specifies that ACCUPDAT is the output\nN  data set. The EXCLUDE statement specifies that member A is excluded\nN  from this copy operation. The three data sets specified in the INDD\nN  parameter will be processed as follows:\nM\nM  1. The data set NEWACC is a sequential data set, so it is loaded into\nM     ACCUPDAT. Because the replace option is specified, members B, C,\nM     and D in NEWACC replace identically named members in ACCUPDAT. The\nM     remaining members of NEWACC are also copied to ACCUPDAT, except\nM     for A, which is excluded from the copy operation.\nM\nM  2. The data set ACCOUNTA is a partitioned data set, so its members\nM     are copied to ACCUPDAT. Because replacement is not specified, only\nM     members E and F are copied.\nM\nM  3. The data set ACCOUNTB is a partitioned data set, so its members\nM     are copied to ACCUPDAT. Only members K and L are copied.\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0310": {"ttr": 25095, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00;\\x00;\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:48", "lines": 59, "newlines": 59, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0310\nTdfp Utilities\nT-Chapter 3.\nT-Example 10: Alter Load Modules in Place\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124948\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 10: Alter Load Modules in Place\nN---------------------------------------\nNIn this example, all members of data set MODLIBJ, members MODX, MODY,\nNand MODZ of data set MODLIBK, and all members of data set MODLIBL,\nNexcept MYMACRO and MYJCL, are altered in place.\nN\nD//ALTERONE JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(5,1))\nD//LIBJ      DD DISP=(OLD),DSN=MODLIBJ\nD//LIBK      DD DISP=(OLD),DSN=MODLIBK\nD//LIBL      DD DISP=(OLD),DSN=MODLIBL\nD//SYSIN     DD *\nD         ALTERMOD OUTDD=LIBJ\nD         ALTERMOD OUTDD=LIBK,LIST=NO\nD         SELECT   MEMBER=(MODX,MODY,MODZ)\nD         ALTERMOD OUTDD=LIBL\nD         EXCLUDE  MEMBER=(MYMACRO,MYJCL)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  LIBJ DD defines the partitioned data set MODLIBJ, which has been\nN  previously created and cataloged.\nN\nN  LIBK DD defines the partitioned data set MODLIBK, which has been\nN  previously created and cataloged.\nN\nN  LIBL DD defines the partitioned data set MODLIBL, which has been\nN  previously created and cataloged.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The first ALTERMOD statement specifies that the entire data set\nN  defined in LIBJ is to be altered in place.\nN\nN  The second ALTERMOD statement plus the following SELECT statement\nN  indicates that members MODX, MODY, and MODZ are to be altered in\nN  place. The remainder of MODLIBK is unchanged.\nN\nN  The third ALTERMOD statement plus the following EXCLUDE statement\nN  indicates that all of MODLIBL is to be altered in place except the\nN  members called MYMACRO and MYJCL. These members remain unchanged.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0311": {"ttr": 25097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00H\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12I\\x00?\\x00?\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:49:48", "lines": 63, "newlines": 63, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0311\nTdfp Utilities\nT-Chapter 3.\nT-Example 11: Replace a Load Module Using COPYMOD\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-124948\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 11: Replace a Load Module Using COPYMOD\nN-----------------------------------------------\nNIn this example, a load module in an existing load library is replaced\nNby another module. The new module originally resides on a 3390 DASD\nNdevice, whereas the load library to which it is copied resides on a\nN3380. Because the module has a block size larger than the block size\nNassigned to the output data set, the module must be reblocked before it\nNis added to the load library.\nN\nNThis example illustrates how you can transfer load modules between\nNdevices of different sizes. In this case, updated modules are created\nNon a 3390 and tested before being added to the load library for general\nNuse.\nN\nD//REPLACE  JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//TESTLIB   DD DISP=(SHR),DSN=JOHNDOE.COBOL.TESTLOAD\nD//PRODLIB   DD DISP=(OLD),DSN=PAYROLL.MASTER.LOADLIB\nD//SYSIN     DD *\nD         COPYMOD OUTDD=PRODLIB,INDD=TESTLIB\nD         SELECT  MEMBER=((WAGETAX,,R))\nD/*\nN\nNThe control statements are discussed below:\nN\nN  TESTLIB DD defines a load library on a 3390 direct access device. It\nN  has a block size of 23470.\nN\nN  PRODLIB DD defines a load library on a 3380 direct access device. It\nN  has a block size of 19069.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The COPYMOD statement identifies PAYROLL.MASTER.LOADLIB as the\nN  output data set and JOHNDOE.COBOL.TESTLOAD as the input data set.\nN  The SELECT statement indicates that the load module WAGETAX is to be\nN  copied from the input data set and is to replace any member with\nN  that name that is in the output data set. The member is also\nN  reblocked to 19069.\nM\nMNote that, in this case, COPYMOD has to be used in order to copy the\nMmember WAGETAX into the PAYROLL.MASTER.LOADLIB. Because the original\nMblock size of WAGETAX is larger than the largest block size that can\nMreside in the output data set, attempting this operation with the COPY\nMstatement would be unsuccessful. The problem would be attributed to a\nMDCB validation error because of incorrect block size.\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0312": {"ttr": 25099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x00N\\x00M\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:11", "lines": 78, "newlines": 77, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0312\nTdfp Utilities\nT-Chapter 3.\nT-Example 12: Reblock Load Library and Distribute it to different Device Types\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 12: Reblock Load Library and Distribute it to different\nNDevice Types\nN--------------------------------------------------------------\nNIn this example, a load library is distributed (by copying it) to\nNdevices whose maximum block size differs from that on which the\nNoriginal load library resides. The library is first reblocked to a\nNmaximum block size that is compatible with each of the devices to which\nNthe library will be copied. Then, the library is copied to those\nNdevices.\nN\nNThis example illustrates how load libraries can be developed on one\nNtype of direct access device and then distributed to other types of\nNdirect access devices.\nN\nD//RBLKCOPY JOB ...\nD//ST01#02 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//TESTED    DD DISP=(SHR),DSN=TESTED.MASTER.LOADLIB\nD//STDSIZE   DD DISP=(OLD),DSN=PROGRAM.MASTER.LOADLIB\nD//SYSIN     DD *\nD         COPYMOD OUTDD=STDSIZE,INDD=TESTED,MAXBLK=13030\nD/*\nD//ST02#02 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//STDSIZE   DD DISP=(SHR),DSN=PROGRAM.MASTER.LOADLIB\nD//LIB3350   DD DISP=(OLD),DSN=PROGRAM.LIB3380.LOADLIB\nD//LIB3330   DD DISP=(OLD),DSN=PROGRAM.LIB3380.LOADLIB\nD//SYSIN     DD *\nD         COPY OUTDD=LIB3380,INDD=STDSIZE\nD         COPY OUTDD=LIB3380,INDD=STDSIZE\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The REBLOCK EXEC statement begins the reblocking step.\nN\nN  TESTED DD defines the cataloged load library TESTED.MASTER.LOADLIB.\nN\nN  STDSIZE DD defines an existing data set, PROGRAM.MASTER.LOADLIB,\nN  which resides on a 3390 direct access device and has a block size of\nN  23470.\nN\nN  The COPYMOD statement in the SYSIN data set specifies that\nN  TESTED.MASTER.LOADLIB is to be merged into PROGRAM.MASTER.LOADLIB.\nN  It also specifies that PROGRAM.MASTER.LOADLIB is to be reblocked\nN  with a maximum block size of 13030. This block size is chosen\nN  because it is small enough to fit on both 3380 and 3390 direct\nN  access devices.\nN\nN  The DISTRIB EXEC statement begins the distribution step, where the\nN  reblocked data set is copied to devices with different maximum block\nN  sizes.\nN\nN  STDSIZE DD defines the same data set that was reblocked in the\nN  previous step.\nN\nN  LIB3380 DD defines the data set PROGRAM.LIB3380.LOADLIB, which\nN  resides on a 3380 direct access device.\nN\nN  The COPY statements in the SYSIN data set specify that the data set\nN  PROGRAM.MASTER.LOADLIB is to be copied to the output data sets\nN  without being reblocked. If PROGRAM.MASTER.LOADLIB had not been\nN  reblocked to the smaller block size, this step would end\nN  unsuccessfully.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0313": {"ttr": 25101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:11", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0313\nTdfp Utilities\nT-Chapter 3.\nT-Example 13: Convert a Partitioned Data Set to a PDSE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 13: Convert a Partitioned Data Set to a PDSE\nN----------------------------------------------------\nNIn this example, a partitioned data set is converted to a PDSE.\nN\nD//CONVERT  JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR),DSN=PDSSET\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=PDSESET,\nD//             LIKE=PDSSET,DSNTYPE=LIBRARY,\nD//             STORCLAS=SCLASX,DATACLAS=DCLASY\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, PDSSET, which is a partitioned\nN  data set.\nN\nN  SYSUT2 DD defines the output data set, PDSESET, which is a\nN  partitioned data set extended. This new data set will be SMS-managed\nN  because it has a storage class.\nN\nN  The LIKE parameter indicates that the DCB and SPACE attributes for\nN  PDSESET are to be copied from PDSSET. The DSNTYPE parameter defines\nN  the new data set as a PDSE rather than as a partitioned data set.\nN  DATACLAS=DCLASY identifies the PPDSE as a program object PDSE with\nN  undefined logical record length.\nN\nN  The Storage Management Subsystem chooses an appropriate volume for\nN  the allocation, based on how SCLASX was defined.\nN\nN  Since the ddnames \"SYSUT1\" and \"SYSUT2\" are used to define the input\nN  and output data sets, no SYSIN data set is required.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0314": {"ttr": 25103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x009\\x009\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:11", "lines": 57, "newlines": 57, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0314\nTdfp Utilities\nT-Chapter 3.\nT-Example 14: Copy Groups from a PDSE to a PDSE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 14: Copy Groups from a PDSE to a PDSE\nN---------------------------------------------\nNIn this example, members and their aliases (groups) are copied from a\nNPDSE to a PDSE (full data set copy). See \"Copying Program Objects\nN(COPYGRP Statement)\" on page 28 for information about copying groups.\nN\nD//CPYGRP   JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//DDIN      DD DISP=(SHR),DSN=PDSESETA\nD//DDOUT     DD DISP=(NEW,CATLG),DSN=PDSESETB,\nD//             LIKE=PDSESETA,DSNTYPE=LIBRARY\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1,1))\nD//SYSIN     DD *\nDGROUPCPY COPYGRP INDD=DDIN,OUTDD=DDOUT\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DDIN DD defines the input data set, PDSESETA, which is a partitioned\nN  data set extended.\nN\nN  DDOUT DD defines the output data set, PDSESETA, which is a\nN  partitioned data set extended.\nN\nN  The LIKE subparameter indicates that the DCB and SPACE attributes\nN  for PDSESETB are to be copied from PDSESETA. The DSNTYPE\nN  subparameter defines the new data set as a PDSE.\nN\nN  The Storage Management Subsystem chooses an appropriate volume for\nN  the allocation.\nN\nN  SYSUT3 DD defines a temporary spill data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains a COPYGRP statement, an INDD\nN  statement, and an OUTDD statement.\nN\nN  COPYGRP indicates the start of the copy operation.\nN\nN  The INDD parameter shows PDSESETA as the input data set.\nN\nN  The OUTDD parameter shows PDSESETB as the output data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0315": {"ttr": 25346, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x12\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x00=\\x00=\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:12", "lines": 61, "newlines": 61, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0315\nTdfp Utilities\nT-Chapter 3.\nT-Example 15: Copy Groups from a PDSE to a PDSE with Replace\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125512\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 15: Copy Groups from a PDSE to a PDSE with Replace\nN----------------------------------------------------------\nNIn this example, members and their aliases are copied in groups from a\nNPDSE to a PDSE with the replace (R) option. See \"Replacing Program\nNObjects\" on page 29 for information about replacing groups with\nNCOPYGRP.\nN\nD//CPYGRP   JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//DDIN      DD DISP=(SHR),DSN=PDSESETA\nD//DDOUT     DD DISP=(NEW,CATLG),DSN=PDSESETB,\nD//             LIKE=PDSESETA,DSNTYPE=LIBRARY\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1,1))\nD//SYSIN     DD *\nDGROUPCPY COPYGRP INDD=((DDIN,R)),OUTDD=DDOUT\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DDIN DD defines the input data set, PDSE, which is a partitioned\nN  data set extended.\nN\nN  DDOUT DD defines the output data set, PDSE, which is a partitioned\nN  data set extended.\nN\nN  The LIKE parameter indicates that the DCB and SPACE attributes for\nN  PDSESETB are to be copied from PDSESETA.\nN\nN  The DSNTYPE parameter defines the new data set as a PDSE.\nN\nN  The Storage Management Subsystem chooses an appropriate volume for\nN  the allocation.\nN\nN  SYSUT3 DD defines a temporary spill data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains a COPYGRP statement, an INDD\nN  statement, and an OUTDD statement.\nN\nN  COPYGRP indicates the start of the copy operation.\nN\nN  The ((INDD,R)) parameter shows PDSESETA as the input data set\nN  containing members to replace members with the same name in\nN  PDSESETB.\nN\nN  The OUTDD parameter shows PDSESETB as the output data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0316": {"ttr": 25348, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x00C\\x00C\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:12", "lines": 67, "newlines": 67, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0316\nTdfp Utilities\nT-Chapter 3.\nT-Example 16: Copy a Selected Group from a PDSE to a PDSE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125512\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 3. IEBCOPY (Library Copy) Program\nN-----------------------------------------\nNExample 16: Copy a Selected Group from a PDSE to a PDSE\nN-------------------------------------------------------\nNIn this example, a selected member and its aliases are copied from a\nNPDSE to a PDSE. Either the member's name or a maximum of eight\nNcharacters can be given on the SELECT statement. See \"Copying Program\nNObjects (COPYGRP Statement)\" on page 28 for information about selecting\nNgroups on COPYGRP.\nN\nD//CPYGRP   JOB ...\nD//ST01#01 EXEC PGM=IEBCOPY\nD//SYSPRINT  DD SYSOUT=*\nD//DDIN      DD DISP=(SHR),DSN=PDSESETA\nD//DDOUT     DD DISP=(NEW,CATLG),DSN=PDSESETB,\nD               LIKE=PDSESETA,DSNTYPE=LIBRARY\nD//SYSUT3    DD UNIT=disk,SPACE=(TRK,(1,1))\nD//SYSIN     DD *\nDGROUPCPY COPYGRP INDD=DDIN,OUTDD=DDOUT\nD         SELECT  MEMBER=(ALIAS001)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DDIN DD defines the input data set, PDSE, which is a partitioned\nN  data set extended.\nN\nN  DDOUT DD defines the output data set, PDSE, which is a partitioned\nN  data set extended.\nN\nN  All PDSEs must be managed by the Storage Management Subsystem.\nN\nN  The LIKE parameter indicates that the DCB and SPACE attributes for\nN  PDSESETB are to be copied from PDSESETA.\nN\nN  The DSNTYPE parameter defines the new data set as a PDSE.\nN\nN  The Storage Management Subsystem chooses an appropriate volume for\nN  the allocation.\nN\nN  SYSUT3 DD defines a temporary spill data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains a COPYGRP statement, an INDD\nN  statement, and an OUTDD statement.\nN\nN  COPYGRP indicates the start of the copy operation.\nN\nN  The INDD parameter shows PDSESETA as the input data set.\nN\nN  The OUTDD parameter shows PDSESETB as the output data set.\nN\nN  The SELECT statement indicates that a group that has the alias\nN  ALIAS001 is to be selected from the input data set (PDSESETA) and\nN  copied to the output data set (PDSESETB).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU04": {"ttr": 25350, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x00#\\x00#\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:12", "lines": 35, "newlines": 35, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU04\nTdfp Utilities\nT-Chapter 4. IEBDG (Test Data Generator) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-083009\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 4. IEBDG (Test Data Generator) Program\nN----------------------------------------------\nNExample 1: Place Binary Zeros in Records Copied from\nN           Sequential Data Set\nNExample 2: Ripple 10-byte Alphabetic Pattern\nNExample 3: Create Output Records from Utility Control Statements\nNExample 4: Use Members and Input Records as Basis of Output Member\nNExample 5: Create Records in Three Output Data Sets and Write them\nN           to three Partitioned Data Set Members\nNExample 6: Construct Records with Your Own Patterns\nI\nNReturn Codes Meaning\nN------------ ----------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   A user routine returned a code of 16 to IEBDG.\nN             The utility ends at the user's request.\nN08 (X'08')   An error occurred while processing a set of\nN             utility control statements. No data is generated following\nN             the error. Processing continues normally with the next set\nN             of utility control statements, if any.\nN12 (X'0C')   An error occurred while processing an input or output data\nN             set. The utility ends. 16 (X'10') An error occurred from\nN             which recovery is not possible. The utility ends.\nN------------ ----------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0401": {"ttr": 25352, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x002\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x00C\\x00B\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:32", "lines": 67, "newlines": 66, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0401\nTdfp Utilities\nT-Chapter 4.\nT-Example 1: Place Binary Zeros in Records Copied from Sequential Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125532\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 4. IEBDG (Test Data Generator) Program\nN----------------------------------------------\nNExample 1: Place Binary Zeros in Records Copied from Sequential\nNData Set\nN---------------------------------------------------------------\nNIn this example, binary zeros are placed in two fields of 100 records\nNcopied from a sequential data set. After the operation, each record in\nNthe copied data set (OUTSET) contains binary zeros in locations 20\nNthrough 29 and 50 through 59.\nN\nD//CLEAROUT JOB ...\nD//ST01#01 EXEC PGM=IEBDG\nD//SYSPRINT  DD SYSOUT=*\nD//SEQIN     DD DISP=(OLD,KEEP),DSN=INSET,\nD//             DCB=(RECFM=FB,BLKSIZE=800,LRECL=80),\nD//             UNIT=tape,LABEL=(,NL)\nD//SEQOUT    DD DISP=(NEW,KEEP),DSN=OUTSET,\nD//             UNIT=tape,LABEL=(,SL),\nD//             DCB=(RECFM=FB,BLKSIZE=32760,LRECL=80)   <==close to 32K\nD//SYSIN     DD *\nD         DSD    OUTPUT=(SEQOUT),INPUT=(SEQIN)\nD         FD     NAME=FIELD1,LENGTH=10,STARTLOC=20\nD         FD     NAME=FIELD2,LENGTH=10,STARTLOC=50\nD         CREATE QUANTITY=100,INPUT=SEQIN,NAME=(FIELD1,FIELD2)\nD         END\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SEQIN DD defines a sequential input data set (INSET). The data set\nN  was originally written on a unlabeled tape volume.\nN\nN  SEQOUT DD defines the test data set (OUTSET). The output records are\nN  identical to the input records, except for locations 20 through 29\nN  and 50 through 59, which contain binary zeros at the completion of\nN  the operation.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  DSD marks the beginning of a set of utility control statements and\nN  refers to the DD statements defining the input and output data sets.\nN\nN  The first and second FD statements create two 10-byte fields (FIELD1\nN  and FIELD2). Because no pattern is specified for these fields, each\nN  field contains the default fill of binary zeros. The fields are to\nN  begin in the 20th and 50th bytes of each output record.\nN\nN  CREATE constructs 100 output records in which the contents of\nN  previously defined fields (FIELD1, FIELD2) are placed in their\nN  respective starting locations in each of the output records. Input\nN  records from data set INSET are used as the basis of the output\nN  records.\nN\nN  END signals the end of a set of utility control statements.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0402": {"ttr": 25354, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12U\\x00>\\x00>\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:55:32", "lines": 62, "newlines": 62, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0402\nTdfp Utilities\nT-Chapter 4.\nT-Example 2: Ripple 10-byte Alphabetic Pattern\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125532\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 4. IEBDG (Test Data Generator) Program\nN----------------------------------------------\nNExample 2: Ripple 10-byte Alphabetic Pattern\nN--------------------------------------------\nNIn this example, a 10-byte alphabetic pattern is rippled. At the end of\nNthe job step the first output record contains \"ABCDEFGHIJ\", followed by\nNdata in location 11 through 80 from the input record; the second record\nNcontains \"BCDEFGHIJK\" followed by data in locations 11 through 80, and\nNso forth.\nN\nD//RIPPLE   JOB ...\nD//ST01#01 EXEC PGM=IEBDG\nD//SYSPRINT  DD SYSOUT=*\nD//SEQIN     DD DISP=(OLD),DSN=INSET\nD//SEQOUT    DD DISP=(NEW,CATLG),DSN=OUTSET,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(10,10))\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         DSD    OUTPUT=(SEQOUT),INPUT=(SEQIN)\nD         FD     NAME=FIELD1,LENGTH=10,FORMAT=AL,ACTION=RP,STARTLOC=1\nD         CREATE QUANTITY=100,INPUT=SEQIN,NAME=FIELD1\nD         END\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SEQIN DD defines an input sequential data set (INSET). The data set\nN  was originally written on a standard labeled tape volume.\nN\nN  SEQOUT DD defines the test output data set (OUTSET). Ten tracks of\nN  primary space and ten tracks of secondary space are allocated for\nN  the sequential data set on a disk volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  DSD marks the beginning of a set of utility control statements and\nN  refers to the DD statements defining the input and output data sets.\nN\nN  The FD statement creates a 10-byte field in which the pattern\nN  ABCDEFGHIJ is initially placed. The data is rippled after each\nN  output record is written.\nN\nN  CREATE constructs 100 output records in which the contents of a\nN  previously defined field (FIELD1) are included. The CREATE statement\nN  uses input records from data set INSET as the basis of the output\nN  records.\nN\nN  END signals the end of a set of utility control statements.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0403": {"ttr": 25611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x16\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12X\\x00A\\x00A\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:58:16", "lines": 65, "newlines": 65, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0403\nTdfp Utilities\nT-Chapter 4.\nT-Example 3: Create Output Records from Utility Control Statements\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125816\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 4. IEBDG (Test Data Generator) Program\nN----------------------------------------------\nNExample 3: Create Output Records from Utility Control Statements\nN----------------------------------------------------------------\nNIn this example, output records are created entirely from utility\nNcontrol statements. Three fields are created and used in the\nNconstruction of the output records. In two of the fields, alphabetic\nNdata is truncated; the other field is a numeric field that is\nNincremented (indexed) by one after each output record is written.\nN\nD//UTLYONLY JOB ...\nD//ST01#01 EXEC PGM=IEBDG\nD//SYSPRINT  DD SYSOUT=*\nD//SEQOUT    DD DISP=(NEW,CATLG),DSN=OUTSET,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(10,10)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD DATA\nD        DSD    OUTPUT=(SEQOUT)\nD        FD     NAME=FIELD1,LENGTH=30,STARTLOC=1,FORMAT=AL,ACTION=TL\nD        FD     NAME=FIELD2,LENGTH=30,STARTLOC=31,FORMAT=AL,ACTION=TR\nD        FD     NAME=FIELD3,LENGTH=10,STARTLOC=71,PICTURE=10,           X\nD               P'1234567890',INDEX=1\nD        CREATE QUANTITY=100,NAME=(FIELD1,FIELD2,FIELD3),FILL=X'FF'\nD        END\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SEQOUT DD defines the test output data set. Ten tracks of primary\nN  space and ten tracks of secondary space are allocated for the\nN  sequential data set on a disk volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  DSD marks the beginning of a set of utility control statements and\nN  refers to the DD statement defining the output data set.\nN\nN  FD defines the contents of three fields to be used in the\nN  construction of output records. The first field contains 30 bytes of\nN  alphabetic data to be truncated left after each output record is\nN  written. The second field contains 30 bytes of alphabetic data to be\nN  truncated right after each output record is written. The third field\nN  is a 10-byte field containing a packed decimal number (1234567890)\nN  to be increased by one after each record is written.\nN\nN  CREATE constructs 100 output records in which the contents of\nN  previously defined fields (FIELD1, FIELD2, and FIELD3) are included.\nN  Note that after each record is written, FIELD1 and FIELD2 are\nN  restored to full width.\nN\nN  END signals the end of a set of utility control statements.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0404": {"ttr": 25613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00#\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12X\\x00W\\x00W\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:58:23", "lines": 87, "newlines": 87, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0404\nTdfp Utilities\nT-Chapter 4.\nT-Example 4: Use Members and Input Records as Basis of Output Member\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125823\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 4. IEBDG (Test Data Generator) Program\nN----------------------------------------------\nNExample 4: Use Members and Input Records as Basis of Output Member\nN------------------------------------------------------------------\nNIn this example, two partitioned members and input records from the\nNinput stream are used as the basis of a partitioned output member. Each\nNblock of 12 output records contains 10 modified records from an input\nNpartitioned member and two records from the input stream.\nN\nD//MIX      JOB ...\nD//ST01#01 EXEC PGM=IEBDG\nD//SYSPRINT  DD SYSOUT=*\nD//PARIN1    DD DISP=(OLD),DSN=INSET1(MEMBA)\nD//PARIN2    DD DISP=(OLD),DSN=INSET2(MEMBA)\nD//PAROUT    DD DISP=(NEW,CATLG),DSN=PARSET(MEMBA),\nD//             UNIT=disk,\nD//             SPACE=(TRK,(10,10,5)),\nD//             DCB=(DSORG=PO,RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD DATA\nD        DSD    OUTPUT=(PAROUT),INPUT=(PARIN1,PARIN2)\nD        FD     NAME=FIELD1,LENGTH=13,PICTURE=13,'DEPARTMENT 21'\nD        REPEAT QUANTITY=10,CREATE=2\nD        CREATE QUANTITY=10,INPUT=PARIN1,NAME=FIELD1\nD        CREATE QUANTITY=2,INPUT=SYSIN\nD\nD(input records 1 through 20)\nD\nD$$$E\nD        REPEAT QUANTITY=10,CREATE=2\nD        CREATE QUANTITY=10,INPUT=PARIN2,NAME=FIELD1\nD        CREATE QUANTITY=2,INPUT=SYSIN\nD\nD(input records 21 through 40)\nD\nD$$$E\nD        END\nD/*\nN\nNThe control statements are discussed below:\nN\nN  PARIN1 DD defines one of the input partitioned members.\nN\nN  PARIN 2 DD defines the second of the input partitioned members.\nN  (Note that the members are from different partitioned data sets.)\nN\nN  PAROUT DD defines the output partitioned member. This example\nN  assumes that the partitioned data set does not exist before the job\nN  step; that is, this DD statement allocates space for the partitioned\nN  data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  DSD marks the beginning of a set of utility control statements and\nN  refers to the DD statements defining the input and output data sets.\nN\nN  FD creates a 13-byte field in which the picture \"DEPARTMENT 21\" is\nN  placed.\nN\nN  The first REPEAT statement indicates that the following group of two\nN  CREATE statements is to be repeated 10 times.\nN\nN  The first CREATE statement creates 10 output records. Each output\nN  record is constructed from an input record (from partitioned data\nN  set INSET1) and from previously defined FIELD1.\nN\nN  The second CREATE statement indicates that two records are to be\nN  constructed from input records included next in the input stream.\nN\nN  The $$$E record separates the input records from the REPEAT\nN  statement. The next REPEAT statement group is identical to the\nN  preceding group, except that records from a different partitioned\nN  member are used as input.\nN\nN  END signals the end of a set of utility control statements.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0405": {"ttr": 25356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x00J\\x00J\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:55", "lines": 74, "newlines": 74, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0405\nTdfp Utilities\nT-Chapter 4.\nT-Example 5: Create Records in Three Output Data Sets and Write them\nTto Three Partitioned Data Set Members\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125655\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 4. IEBDG (Test Data Generator) Program\nN----------------------------------------------\nNExample 5: Create Records in Three Output Data Sets and Write them\nNto Three Partitioned Data Set Members\nN------------------------------------------------------------------\nMThis example was CORRECTED by Kenneth Tomiak under the belief you\nMshould be using system-managed datasets.\nM\nD//UTSTS    JOB ...\nD//ST01#01 EXEC PGM=IEBDG\nD//SYSPRINT  DD SYSOUT=A\nD//PAROUT1   DD DSNAME=PARSET(MEMBA),UNIT=disk,DISP=(,KEEP),\nD//             SPACE=(TRK,(10,10,5)),\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\nD//PAROUT2   DD DSNAME=PARSET(MEMBB),UNIT=AFF=PAROUT1,\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\nD//             DISP=OLD\nD//PAROUT3   DD DSNAME=PARSET(MEMBC),UNIT=AFF=PAROUT1,\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\nD//             DISP=OLD\nD//SYSIN     DD DATA\nD        DSD    OUTPUT=(PAROUT1)\nD        FD     NAME=FIELD1,LENGTH=30,FORMAT=AL,ACTION=SL\nD        FD     NAME=FIELD2,LENGTH=20,FORMAT=ZD\nD        FD     NAME=FIELD3,LENGTH=20,FORMAT=AL,ACTION=SR\nD        FD     NAME=FIELD4,LENGTH=30,FORMAT=AN\nD        CREATE QUANTITY=4,NAME=(FIELD1,FIELD3,FIELD2)\nD        END\nD        DSD    OUTPUT=(PAROUT2)\nD        CREATE QUANTITY=4,NAME=(FIELD2,(COPY=3,FIELD3))\nD        END\nD        DSD    OUTPUT=(PAROUT3)\nD        CREATE QUANTITY=4,NAME=(FIELD4,FIELD1)\nD        END\nD/*\nN\nNThe control statements are as follows:\nN\nN  PAROUT1 DD defines the first member (MEMBA) of the partitioned\nN  output data set. This example assumes that the partitioned\nN  data set does not exist before this job step; that is, this DD\nN  statement allocates space for the data set.\nN\nN  PAROUT2 and PAROUT3 DD define the second and third members,\nN  respectively, of the output partitioned data set. Note that\nN  each DD statement specifies DISP=OLD and UNIT=AFF=PAROUT1.\nN\nN  SYSIN DD defines the control data set that follows in the\nN  input stream.\nN\nN  DSD marks the beginning of a set of utility control statements\nN  and refers to the DD statement defining the member applicable\nN  to that set of utility control statements.\nN\nN  FD defines the contents of a field that is used in the subsequent\nN  construction of output records.\nN\nN  CREATE constructs four records from combinations of previously\nN  defined fields.\nN\nN  END signals the end of a set of utility control statements.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0406": {"ttr": 25358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x00A\\x00A\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:55", "lines": 65, "newlines": 65, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0406\nTdfp Utilities\nT-Chapter 4.\nT-Example 6: Construct Records with Your Own Patterns\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125655\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 4. IEBDG (Test Data Generator) Program\nN----------------------------------------------\nNExample 6: Construct Records with Your Own Patterns\nN---------------------------------------------------\nNIn this example, 10 fields containing user-supplied character patterns\nNare used in the construction of output records. After a record is\nNwritten, each field is rolled or waved, as specified in the applicable\nNFD statement.\nN\nD//ROLLWAVE JOB ...\nD//ST01#01 EXEC PGM=IEBDG\nD//SYSPRINT  DD SYSOUT=*\nD//OUTSET    DD DISP=(NEW,CATLG),DSN=SEQSET,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(10,10)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD        DSD    OUTPUT=(OUTSET)\nD        FD     NAME=FIELD1,LENGTH=8,PICTURE=8,' AAAAA',ACTION=RO\nD        FD     NAME=FIELD2,LENGTH=8,PICTURE=8,'BBBBB ',ACTION=RO\nD        FD     NAME=FIELD3,LENGTH=8,PICTURE=8,'A AA ',ACTION=RO\nD        FD     NAME=FIELD4,LENGTH=8,PICTURE=8,' BB B',ACTION=RO\nD        FD     NAME=FIELD5,LENGTH=8,PICTURE=8,' AAA ',ACTION=RO\nD        FD     NAME=FIELD6,LENGTH=8,PICTURE=8,' CCCCC',ACTION=WV\nD        FD     NAME=FIELD7,LENGTH=8,PICTURE=8,' DDDD ',ACTION=WV\nD        FD     NAME=FIELD8,LENGTH=8,PICTURE=8,' C CC ',ACTION=WV\nD        FD     NAME=FIELD9,LENGTH=8,PICTURE=8,' DD D',ACTION=WV\nD        FD     NAME=FIELD10,LENGTH=8,PICTURE=8,' CCC ',ACTION=WV\nD        CREATE QUANTITY=300,NAME=(FIELD1,FIELD2,FIELD3,               X\nD               FIELD4,FIELD5,FIELD6,FIELD7,FIELD8,FIELD9,FIELD10)\nD        END\nD/*\nN\nNThe control statements are discussed below:\nN\nN  OUTSET DD defines the output sequential data set on a disk volume.\nN  Ten tracks of primary space and 10 tracks of secondary space are\nN  allocated to the data set.\nN\nN  SYSIN DD defines the control data set that follows in the input\nN  stream.\nN\nN  DSD marks the beginning of a set of utility control statements and\nN  refers to the DD statement defining the output data set.\nN\nN  FD defines a field to be used in the subsequent construction of\nN  output records. The direction and frequency of the initial roll or\nN  wave depend on the location of data in the field.\nN\nN  CREATE constructs 300 records from the contents of the previously\nN  defined fields.\nN\nN  END signals the end of a set of utility control statements.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU05": {"ttr": 25360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:56", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU05\nTdfp Utilities\nT-Chapter 5. IEBEDIT (Edit Job Stream) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-085112\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 5. IEBEDIT (Edit Job Stream) Program\nN--------------------------------------------\nNExample 1: Copy One Job\nNExample 2: Copy Steps from Three Jobs\nNExample 3: Include Step from One Job, Exclude Step from Another\nNExample 4: Copy Statement for JOBA and JOB STEPF\nNExample 5: Copy Entire Input Data Set\nNExample 6: Copy Entire Data Set to Include New Delimiter\nI\nNReturn Codes Meaning\nN------------ --------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   An error occurred. The output data set may not\nN             be usable as a job stream. Processing continues.\nN08 (X'08')   An unrecoverable error occurred while attempting\nN             to process the input, output, or control data set.\nN             The utility ends.\nN------------ --------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0501": {"ttr": 25362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:56", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0501\nTdfp Utilities\nT-Chapter 5.\nT-Example 1: Copy One Job\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125656\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 5. IEBEDIT (Edit Job Stream) Program\nN--------------------------------------------\nNExample 1: Copy One Job\nN-----------------------\nNIn this example, one job (EDIT1), including all of its job steps, is\nNcopied into the output data set. The input data set contains three\nNjobs: JOBA, JOBB and JOBC.\nN\nD//EDIT1    JOB ...\nD//ST01#01 EXEC PGM=IEBEDIT\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INJOBS\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTTAPE,\nD//             UNIT=tape,\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         EDIT  START=JOBA\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, INJOBS. The data set resides\nN  on a standard labeled tape volume (001234).\nN\nN  SYSUT2 DD defines the output data set, called OUTTAPE. The data set\nN  is to reside as the first data set on a standard labeled tape\nN  volume. The system will select an optimal block size.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  EDIT indicates that JOBA is to be copied in its entirety.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0502": {"ttr": 25601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:56", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0502\nTdfp Utilities\nT-Chapter 5.\nT-Example 2: Copy Steps from Three Jobs\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125656\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 5. IEBEDIT (Edit Job Stream) Program\nN--------------------------------------------\nNExample 2: Copy Steps from Three Jobs\nN-------------------------------------\nNThis example copies job steps from each of three jobs. The input data\nNset contains three jobs: JOBA, which includes STEPA, STEPB, STEPC, and\nNSTEPD; JOBB, which includes STEPE, STEPF, and STEPG; and JOBC, which\nNincludes STEPH and STEPJ.\nN\nD//EDIT2    JOB ...\nD//ST01#01 EXEC PGM=IEBEDIT\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INJOBS\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTSTRM,\nD//             UNIT=tape,LABEL=(2,SL),\nD//             VOL=SER=001235,\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         EDIT  START=JOBA,TYPE=INCLUDE,STEPNAME=(STEPC,STEPD)\nD         EDIT  START=JOBB,TYPE=INCLUDE,STEPNAME=STEPE\nD         EDIT  START=JOBC,TYPE=INCLUDE,STEPNAME=STEPJ\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, INJOBS. The data set resides\nN  on a standard labeled tape volume (001234).\nN\nN  SYSUT2 DD defines the output data set, OUTSTRM. The data set is to\nN  reside as the second data set on a standard labeled tape volume\nN  (001235).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The EDIT statements copy the JOB statements and job steps described\nN  as follows:\nM\nM  1. The JOB statement and steps STEPC and STEPD for JOBA.\nM\nM  2. The JOB statement and STEPE for JOBB.\nM\nM  3. The JOB statement and STEPJ for JOBC.\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0503": {"ttr": 25603, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x001\\x001\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:56", "lines": 49, "newlines": 49, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0503\nTdfp Utilities\nT-Chapter 5.\nT-Example 3: Include Step from One Job, Exclude Step from Another\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125656\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 5. IEBEDIT (Edit Job Stream) Program\nN--------------------------------------------\nNExample 3: Include Step from One Job, Exclude Step from Another\nN---------------------------------------------------------------\nNThis example includes a job step from one job and excludes a job step\nNfrom another job. The input data set contains three jobs: JOBA, which\nNincludes STEPA, STEPB, STEPC, and STEPD; JOBB, which includes STEPE,\nNSTEPF, and STEPG; and JOBC, which includes STEPH and STEPJ.\nN\nD//EDIT3    JOB ...\nD//ST01#01 EXEC PGM=IEBEDIT\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INSET\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTTAPE,\nD//             UNIT=tape,LABEL=(,SL),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         EDIT  START=JOBB,TYPE=INCLUDE,STEPNAME=(STEPF-STEPG)\nD         EDIT  START=JOBC,TYPE=EXCLUDE,STEPNAME=STEPJ\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, INSET.\nN\nN  SYSUT2 DD defines the output data set, OUTTAPE. The data set is to\nN  reside as the first or only data set on a labeled tape volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The EDIT statements copy JOB statements and job steps as described\nN  below:\nN\nN  1. The JOB statement and steps STEPF and STEPG for JOBB.\nN\nN  2. The JOB statement and STEPH, excluding STEPJ, for JOBC.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0504": {"ttr": 25605, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:57", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0504\nTdfp Utilities\nT-Chapter 5.\nT-Example 4: Copy Statement for JOBA and JOB STEPF\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125657\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 5. IEBEDIT (Edit Job Stream) Program\nN--------------------------------------------\nNExample 4: Copy Statement for JOBA and JOB STEPF\nN------------------------------------------------\nNThis example copies the JOB statement for JOBA, the job step STEPF, and\nNall the steps that follow it. The input data set contains one job\nN(JOBA), which includes STEPA through STEPL. Job steps STEPA through\nNSTEPE are not included in the output data set.\nN\nD//EDIT4    JOB ...\nD//ST01#01 EXEC PGM=IEBEDIT\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INSTREAM\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTSTREM,\nD//             UNIT=disk,\nD//             SPACE=(TRK,2)\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         EDIT  START=JOBA,TYPE=POSITION,STEPNAME=STEPF\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, INSTREAM.\nN\nN  SYSUT2 DD defines the output data set, OUTSTREAM. The data set is to\nN  reside on a disk volume. Two tracks are allocated for the output\nN  data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  EDIT copies the JOB statement for JOBA and job steps STEPF through\nN  STEPL.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0505": {"ttr": 25607, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x000\\x000\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:57", "lines": 48, "newlines": 48, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0505\nTdfp Utilities\nT-Chapter 5.\nT-Example 5: Copy Entire Input Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125657\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 5. IEBEDIT (Edit Job Stream) Program\nN--------------------------------------------\nNExample 5: Copy Entire Input Data Set\nN-------------------------------------\nNThis example copies the entire input data set. The record containing\nNthe characters \"..*\" in columns 1 through 3 is converted to a \"/*\"\nNstatement in the output data set.\nN\nD//EDIT5    JOB ...\nD//ST01#01 EXEC PGM=IEBEDIT\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTTAPE,\nD//             UNIT=tape,\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD DUMMY\nD//SYSUT1    DD DATA\nD//BLDGDGIX JOB ...\nD//ST01#01 EXEC PGM=IEHPROGM\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD DISP=OLD,UNIT=disk,VOL=SER=111111\nD//SYSIN     DD *\nD         BLDG  INDEX=A.B.C,ENTRIES=10,EMPTY\nD..*\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT2 DD defines the output data set, OUTTAPE. The data set will be\nN  the first data set on a tape volume.\nN\nN  SYSIN DD defines a dummy control data set.\nN\nN  SYSUT1 DD defines the input data set, which follows in the input\nN  stream. The job is stopped when the statement \"/*\" is encountered.\nN  (SYSUT1 therefore includes the BLDGDGIX JOB statement, EXEC\nN  statement, SYSPRINT, DD1, and SYSIN DD statements.)\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0506": {"ttr": 25609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12V\\x006\\x006\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:56:57", "lines": 54, "newlines": 54, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0506\nTdfp Utilities\nT-Chapter 5.\nT-Example 6: Copy Entire Data Set to Include New Delimiter\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125657\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 5. IEBEDIT (Edit Job Stream) Program\nN--------------------------------------------\nNExample 6: Copy Entire Data Set to Include New Delimiter\nN--------------------------------------------------------\nNThis example copies the entire input data set, including the JES2\nNcontrol statement, because a new delimiter (JP) has been coded.\nNOtherwise, the \"/*\" in the JES2 control statement would have stopped\nNthe input.\nN\nD//EDIT6    JOB ...\nD//ST01#01 EXEC PGM=IEBEDIT\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=TAPEOUT,\nD//             UNIT=tape,LABEL=(2,SL),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD DUMMY\nD//SYSUT1    DD DATA,DLM='JP'\nD//LISTVTOC JOB ...\nD/*MESSAGE JOB NEEDS VOLUME 338000\nD//ST01#01 EXEC PGM=IEHLIST\nD//SYSPRINT  DD SYSOUT=*\nD//DD2       DD DISP=OLD,UNIT=disk,VOL=SER=338000\nD//SYSIN     DD *\nD         LISTVTOC FORMAT,VOL=disk=338000\nD..*\nD/*\nDJP\nN\nNThe control statements are discussed below:\nN\nN  SYSUT2 DD defines the output data set, TAPEOUT. The data set will be\nN  the first data set on a standard label tape volume.\nN\nN  SYSIN DD defines a dummy control data set.\nN\nN  SYSUT1 DD defines the input data set, which follows in the input\nN  stream. The DLM parameter defines characters JP to act as a\nN  delimiter for the input data.\nN\nN  IEBEDIT copies the JOB statement through the \"/*\" statement\nN  (including the LISTVTOC and MESSAGE job statements, FSTEP EXEC\nN  statement, and SYSPRINT, DD2 and SYSIN DD statements).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU06": {"ttr": 25615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00X\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12X\\x00&\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:58:58", "lines": 38, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU06\nTdfp Utilities\nT-Chapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125858\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExamples\nN--------\nNExample 1: Print a Sequential Data Set\nNExample 2: Create a Partitioned Data Set from Sequential Input\nNExample 3: Convert Sequential Input into Partitioned Members\nNExample 4: In-stream Input, Sequential Data Set to Tape Volume\nNExample 5: Produce Blocked Copy on Tape from Unblocked Disk File\nNExample 6: Edit and Copy a Sequential Input Data Set with Labels\nNExample 7: Edit and Copy a Sequential z/OS UNIX File to a\nN           Sequential Data Set\nNExample 8: Edit Double-Byte Character Set Data\nN\nNReturn Codes Meaning\nN------------ ----------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   Probable successful completion. A warning message\nN             is written.\nN08 (X'08')   Either processing was ended after you requested processing\nN             of user header labels only, or a DBCS error was\nN             encountered.\nN12 (X'0C')   Either an unrecoverable error exists and the job step is\nN             stopped, or a DBCS error was encountered.\nN16 (X'10')   A user routine passed a return code of 16 to IEBGENER. The\nN             utility ends.\nN------------ ----------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0601": {"ttr": 25617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12X\\x00%\\x00%\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:58:59", "lines": 37, "newlines": 37, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0601\nTdfp Utilities\nT-Chapter 6.\nT-Example 1: Print a Sequential Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125859\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 1: Print a Sequential Data Set\nN--------------------------------------\nNIn this example, a sequential data set is printed. The printed output\nNis left-aligned, with one 80-byte record appearing on each line of\nNprinted output.\nN\nD//PRINT    JOB ...\nD//ST01#01 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD DUMMY\nD//SYSUT1    DD DISP=(SHR),DSN=D80.DATA\nD//SYSUT2    DD SYSOUT=*\nN\nNThe job control statements are discussed below:\nN\nN  SYSIN DD defines a dummy data set. Since no editing is performed, no\nN  utility control statements are required.\nN\nN  SYSUT1 DD defines the input sequential data set.\nN\nN  SYSUT2 DD indicates that the output is to be written on the system\nN  output device (printer). IEBGENER copies LRECL and RECFN from the\nN  SYSUT1 data set and the system determines a BLKSIZE.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0602": {"ttr": 56066, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x009\\x01\\x18\\x13O\\x01\\x18\\x14?\\x080\\x00H\\x00H\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-23T08:30:39", "lines": 72, "newlines": 72, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0602\nTdfp Utilities\nT-Chapter 6.\nT-Example 2: Create a Partitioned Data Set from Sequential Input\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180523-083039\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 2: Create a Partitioned Data Set from Sequential Input\nN--------------------------------------------------------------\nNIn this example, a partitioned data set (consisting of three members)\nNis created from sequential input.\nN\nD//TAPEDISK JOB ...\nD//ST01#01 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INSET\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=NEWSET,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(10,5,5)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         GENERATE MAXNAME=3,MAXGPS=2\nD         MEMBER   NAME=MEMBER1\nD         GROUP1   RECORD IDENT=(8,'FIRSTMEM',1)\nD         MEMBER   NAME=MEMBER2\nD         GROUP2   RECORD IDENT=(8,'SECNDMEM',1)\nD         MEMBER   NAME=MEMBER3\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set (INSET). The data set is the\nN  first data set on a tape volume.\nN\nN  SYSUT2 DD defines the output partitioned data set (NEWSET). The data\nN  set is to be placed on a disk volume. Ten tracks of primary space,\nN  five tracks of secondary space, and five blocks (256 bytes each) of\nN  directory space are blocked to reduce the space required by the data\nN  set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The utility control statements are used to create members\nN  from sequential input data; the statements do not specify any\nN  editing.\nN\nN  GENERATE indicates that three member names are included in\nN  subsequent MEMBER statements and that the IDENT parameter appears\nN  twice in subsequent RECORD statements.\nN\nN  The first MEMBER statement assigns a member name (MEMBER1) to the\nN  first member.\nN\nN  The first RECORD statement (GROUP1) identifies the last record to be\nN  placed in the first member. The name of this record (FIRSTMEM)\nN  appears in the first eight positions of the input record.\nN\nN  The remaining MEMBER and RECORD statements define the second and\nN  third members. Note that, as there is no RECORD statement associated\nN  with the third MEMBER statement, the remainder of the input file\nN  will be loaded as the third member.\nM\nM  Kenneth asks, 'what is in this INSET data set?\nI  And then fabricated some sample data for you with an alternate\nI  set of RECORD statements in KTPM3611.\nI\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0603": {"ttr": 25858, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12X\\x00L\\x00L\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:58:59", "lines": 76, "newlines": 76, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0603\nTdfp Utilities\nT-Chapter 6.\nT-Example 3: Convert Sequential Input into Partitioned Members\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125859\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 3: Convert Sequential Input into Partitioned Members\nN------------------------------------------------------------\nNIn this example, sequential input is converted into two partitioned\nNmembers. The newly created members are merged into an existing\nNpartitioned data set. User labels on the input data set are passed to\nNthe user exit routine.\nN\nD//DISKTODK JOB ...\nD//ST01#01 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INSET\nD//SYSUT2    DD DISP=(MOD,KEEP),DSN=EXISTSET,\nD//             UNIT=disk,\nD//             VOL=SER=111113\nDGENERATE GENERATE MAXNAME=3,MAXGPS=1\nD         EXITS INHDR=ROUT1,INTLR=ROUT2\nD         MEMBER NAME=(MEMX,ALIASN\nD         GROUP1 RECORD IDENT=(8,'FIRSTMEM',1)\nD         MEMBER NAME=MEMY\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set (INSET). The input data set,\nN  which resides on a disk volume, has standard user labels.\nN\nN  SYSUT2 DD defines the output partitioned data set (EXISTSET). The\nN  members created during this job step are merged into the partitioned\nN  data set.\nN\nN  The SYSIN DD statement is omitted. Because the GENERATE line does\nN  not begin with //, the system assumes it is preceded by a\nN  //SYSIN DD *\nN  line. SYSIN DD defines the control data set, which follows in the\nN  input stream. The utility control statements are used to create\nN  members from sequential input data; the statements do not specify\nN  any editing. A /* at the end of any DD * data set is unnecessary\nN  because a JCL satement or end of the job stream marks the end of the\nN  input stream data set.\nM  Kenneth believes the omission of the //SYSIN and /* is a sign of\nM  LAZY and SLOPPY coding. Just because you can does not mean that\nM  you should.\nN\nN  GENERATE indicates that a maximum of three names and aliases are\nN  included in subsequent MEMBER statements and that one IDENT\nN  parameter appears in a subsequent RECORD statement.\nN\nN  EXITS defines the user routines that are to process user labels.\nM  Message from Kenneth:\nM  ALAS! Without the source code for those EXITS, this example is\nM  worthless.\nN\nN  The first MEMBER statement assigns a member name (MEMN and an alias\nN  (ALIASN to the first member.\nN\nN  The RECORD statement identifies the last record to be placed in the\nN  first member. The name of this record (FIRSTMEM) appears in the\nN  first eight positions of the input record.\nN\nN  The second MEMBER statement assigns a member name (MEMY) to the\nN  second member. The remainder of the input data set is included in\nN  this member.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0604": {"ttr": 25860, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12X\\x00+\\x00+\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:58:59", "lines": 43, "newlines": 43, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0604\nTdfp Utilities\nT-Chapter 6.\nT-Example 4: In-stream Input, Sequential Data Set to Tape Volume\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125859\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 4: In-stream Input, Sequential Data Set to Tape Volume\nN--------------------------------------------------------------\nNIn this example, an in-stream input, sequential data set is\nNcopied to a tape volume.\nN\nD//CDTOTAPE JOB ...\nD//ST01#01 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD DUMMY\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTSET,\nD//             UNIT=tape,LABEL=(,SL),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSUT1    DD *\nD\nD(in-stream data)\nD\nD/*\nN\nNThe job control statements are discussed below:\nN\nN  SYSIN DD defines a dummy data set. No editing is performed;\nN  therefore, no utility control statements are needed.\nN\nN  SYSUT2 DD defines the output data set, OUTSET. The data set is\nN  written to a tape volume with IBM standard labels. The data set is\nN  to reside as the first (or only) data set on the volume.\nN\nN  SYSUT1 DD defines the in-stream data which is actually a JES SYSIN\nN  data set. The data set contains no statements.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0605": {"ttr": 25862, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x005\\x005\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:00", "lines": 53, "newlines": 53, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0605\nTdfp Utilities\nT-Chapter 6.\nT-Example 5: Produce Blocked Copy on Tape from Unblocked Disk File\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125900\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 5: Produce Blocked Copy on Tape from Unblocked Disk File\nN----------------------------------------------------------------\nNIn this example, a blocked copy on tape is made from an unblocked\nNsequential disk file. Because the disk data set has a relatively small\nNblock size, the number of buffers explicitly requested is larger than\nNthe default of five. This improves performance by permitting more\nNoverlap of reading the SYSUT1 data set with writing the SYSUT2 data\nNset.\nN\nD//COPYJOB  JOB ...\nD//ST01#01 EXEC PGM=IEBGENER,REGION=318K\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD DUMMY\nD//SYSUT1    DD DISP=(OLD),DSN=INPUT,\nD//             DCB=(BUFNO=20)\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTPUT,\nD//             UNIT=tape,\nD//             DCB=(RECFM=FB,BLKSIZE=32000,LRECL=2000)\nN\nNThe job control statements are discussed below:\nN\nN  The EXEC statement names the IEBGENER program and specifies the\nN  virtual storage region size required. (Calculation of region size is\nN  described in Table 15 on page 79.)\nN\nN  The SYSIN DD statement is a dummy, since no editing is to be\nN  performed.\nN\nN  The SYSUT1 DD statement identifies an input disk file. Normally, the\nN  DCB information should not be specified in the DD statement for an\nN  existing disk file because the information exists in the data set\nN  label in the VTOC; it is specified in this example to illustrate the\nN  use of the BUFNO sub-parameter. The DCB information specifies\nN  BUFNO=20 to allow up to twenty blocks to be read with each rotation\nN  of the disk, assuming the disk track will hold that many blocks.\nN\nN  The SYSUT2 DD statement identifies the output tape data set and\nN  specifies a block size of 32,000 bytes. The default of five buffers\nN  should be enough to keep pace with the input.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0606": {"ttr": 25864, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00L\\x00L\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0606\nTdfp Utilities\nT-Chapter 6.\nT-Example 6: Edit and Copy a Sequential Input Data Set with Labels\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125900\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 6: Edit and Copy a Sequential Input Data Set with Labels\nN----------------------------------------------------------------\nNIn this example, a sequential input data set is edited and copied.\nN\nD//TAPETAPE JOB ...\nD//ST01#01 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=OLDSET\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=NEWSET,\nD//             UNIT=tape,LABEL=(,SL),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         GENERATE MAXFLDS=3,MAXLITS=11\nD         RECORD FIELD=(10,'**********',,1),\nD         FIELD=(5,1,HE,11),FIELD=(1,'=',,16)\nD         RECORD LABELS=2\nD\nMYou would change the next two records to something meaningful\nMto your application.\nD(first header label record)\nD(second header label record)\nD\nD         RECORD LABELS=2\nD\nMYou would change the next two records to something meaningful\nMto your application.\nD(first trailer label record)\nD(second trailer label record)\nD\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the sequential input data set (OLDSET). The data\nN  set was originally written as the third data set on a tape volume.\nN\nN  SYSUT2 DD defines the sequential output data set (NEWSET). The data\nN  set is written as the first data set on a tape volume. The output\nN  records are blocked to reduce the space required by the data set and\nN  to reduce the access time required when the data set is subsequently\nN  referred to. The BLKSIZE parameter is omitted so that the system will\nN  calculate an optimal value that is less than or equal to 32,760 bytes\nN  unless the system programmer sets the default differently.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  GENERATE indicates that a maximum of three FIELD parameters is\nN  included in subsequent RECORD statements and that a maximum of 11\nN  literal characters are included in subsequent FIELD parameters.\nN\nN  The first RECORD statement controls the editing, as follows:\nN  asterisks are placed in positions 1 through 10; positions 1 through\nN  5 of the input record are converted from H-set BCDIC to EBCDIC mode\nN  and moved to positions 11 through 15; and an equal sign is placed in\nN  position 16.\nN\nN  The second RECORD statement indicates that the next two records from\nN  SYSIN should be written out as user header labels on SYSUT2.\nN\nN  The third RECORD statement indicates that the next two records from\nN  SYSIN should be written as user trailer labels on SYSUT2.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0607": {"ttr": 25866, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00C\\x00C\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0607\nTdfp Utilities\nT-Chapter 6.\nT-Example 7: Edit and Copy a Sequential USS File to a Sequential Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125900\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 7: Edit and Copy a Sequential USS File to a Sequential Data Set\nN-----------------------------------------------------------------------\nNIn this example,a USS (POSIN  file is edited and copied. The logical\nNrecord length of the output data set is less than that of the input\nNdata set.\nN\nD//DISKDISK JOB ...\nD//ST01#01 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD PATH='/dist3/stor44/sales.mon',\nD//             FILEDATA=TEXT,\nD//             PATHOPTS=ORDONLY,\nD//             LRECL=100,BLKSIZE=1000,RECFM=FB\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=NEWSET,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(20,10)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         GENERATE MAXFLDS=4,MAXGPS=1\nD         EXITS IOERROR=ERRORRT\nD         GRP1  RECORD IDENT=(8,'FIRSTGRP',1),FIELD=(21,80,,60),        X\nD               FIELD=(59,1,,1)\nD         GRP2  RECORD FIELD=(11,90,,70),FIELD=(69,1,,1)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input file. Its name is\nN  /dist3/stor44/sales.mon. It contains text in 100-byte records. The\nN  record delimiter is not stated here. The file might be on a\nN  non-System/390 system that is available via NFS, Network File\nN  System.\nN\nN  SYSUT2 DD defines the output data set (NEWSET). Twenty tracks of\nN  primary storage space and ten tracks of secondary storage space are\nN  allocated for the data set on a disk volume. The logical record\nN  length of the output records is 80 bytes, and the output is blocked.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  GENERATE indicates that a maximum of four FIELD parameters are\nN  included in subsequent RECORD statements and that one IDENT\nN  parameter appears in a subsequent RECORD statement.\nN\nN  EXITS identifies the user routine that handles input/output errors.\nM\nMKenneth whines, yet again, about the missing EXITS source and this\nMthe inability to run this example.\nM\nMEven more confusing in this day and age is what kind of I/O error\nMwould a normal user be trying to handle?\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0608": {"ttr": 25868, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00N\\x00O\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:00", "lines": 78, "newlines": 79, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0608\nTdfp Utilities\nT-Chapter 6.\nT-Example 8: Edit Double-Byte Character Set Data\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125900\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 6. IEBGENER (Sequential Copy/Generate Data Set) Program\nN---------------------------------------------------------------\nNExample 8: Edit Double-Byte Character Set Data\nN----------------------------------------------\nNIn this example, an edited data set containing double-byte character\nNset data is created. Shift-out/shift-in characters (< and >) are\nNinserted to enclose the DBCS strings.\nN\nD//DBLBYTE  JOB ...\nD//ST01#01 EXEC PGM=IEBGENER\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INPUT,\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTPUT,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(1,1)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD         GENERATE MAXFLDS=4,MAXLITS=9,DBCS=YES\nD         RECORD   FIELD=(20,1,,1),FIELD=(16,33,VC,21),                 X\nD               FIELD=(30,50,VC,39),FIELD=(9,'*********',,72)\nD/*\nN\nNThe control statements are discussed below.\nN\nN  SYSUT1 DD defines the input data set, INPUT, which resides on a disk\nN  volume.\nN\nN  SYSUT2 DD defines the output data set, OUTPUT, which will reside on\nN  a disk volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  GENERATE indicates that a maximum of four FIELD parameters and nine\nN  literal characters will appear on subsequent RECORD statements, and\nN  that the input data set contains DBCS data.\nN\nN  RECORD specifies how input records will be edited before being\nN  placed in the output data set. The first FIELD parameter indicates\nN  that the first 20 positions (bytes) of the input records are to be\nN  placed in the first 20 positions of the output records.\nN\nN  The second FIELD parameter indicates that data in positions 33\nN  through 48 are to be checked to ensure that they are valid DBCS\nN  data, and that shift-out/shift-in characters are to be inserted\nN  around this field. For DBCS data to be valid, each byte of the\nN  2-byte characters must have a hexadecimal value between X'41' and\nN  X'FE', or the 2-byte character must be a DBCS space (X'4040'). Once\nN  the checking and inserting are completed, this field is to be copied\nN  to the output records beginning at position 21.\nN\nN  The third FIELD parameter operates on the 30-byte field beginning at\nN  position 50 in the input records. This field is checked for valid\nN  DBCS data, and shift-out/shift-in characters are inserted around the\nN  field. The resulting field is copied to the output records beginning\nN  at position 39.\nI\nINotice that in specifying the output locations in the FIELD parameter,\nIyou have to account for the additional positions that the SO/SI\nIcharacters will use. For instance, the eight-character (16-byte) DBCS\nIstring beginning at position 21 does not end at position 36, but at 38.\nIThe SO/SI characters are single-byte characters, so the pair will take\nIup two positions.\nI\nIThe final FIELD parameter clears out the final positions of the output\nIrecords with asterisks.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU07": {"ttr": 25870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x009\\x009\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:01", "lines": 57, "newlines": 57, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU07\nTdfp Utilities\nT-Chapter 7. IEBIMAGE (Create Printer Image) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-092224\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample  1: Build a New Forms Control Buffer Module\nNExample  2: Replace a Forms Control Buffer Module\nNExample  3: Replace a Forms Control Buffer Module\nNExample  4: Build a New Forms Control Buffer Module\nNExample  5: Replace the Forms Control Buffer Module STD3\nNExample  6: Build a New Forms Control Buffer Module for Additional\nN            ISO Paper Sizes\nNExample  7: Build a Forms Control Buffer Module\nNExample  8: Build a New Copy Modification Module\nNExample  9: Build a New Copy Modification Module from an Existing\nN            Copy\nNExample 10: Add a New Character to a Character Arrangement Table\nN            Module\nNExample 11: Build a New Character Arrangement Table Module from\nN            an Existing Copy\nNExample 12: Build Graphic Characters in a Character Arrangement\nN            Table Module\nNExample 13: Delete Graphic References From a Character Arrangement\nN            Table Module\nNExample 14: List the World Trade National Use Graphics Graphic\nN            Character Modification Module\nNExample 15: Build a Graphic Character Modification Module from the\nN            Character Modification Module World Trade GRAFMOD\nNExample 16: Build a New Graphic Character Modification Module and\nN            Modify a Character Arrangement Table to Use It\nNExample 17: Build a Graphic Character Modification Module from\nN            Multiple Sources\nNExample 18: Define and Use a Character in a Graphic Character\nN            Modification Module\nNExample 19: List a Library Character Set Module\nNExample 20: Build a Library Character Set Module\nNExample 21: Build a Library Character Set Module and Modify a\nN            Character Arrangement Table to Use It\nNExample 22: Build a Library Character Set Module from Multiple Sources\nI\nNReturn Codes Meaning\nN00 (X'00') Successful completion; operations performed as requested.\nN04 (X'04') Operations performed; investigate messages for exceptional\nN           circumstances.\nN08 (X'08') Operations not performed; investigate messages.\nN12 (X'0C') Severe exception; processing may end.\nN16 (X'10') Unrecoverable exception; the utility ends.\nN20 (X'14') SYSPRINT data set could not be opened; the utility is ended.\nN24 (X'18') User parameter list incorrect; the utility is ended.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0701": {"ttr": 25872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x005\\x005\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:01", "lines": 53, "newlines": 53, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0701\nTdfp Utilities\nT-Chapter 7.\nT-Example 1: Build a New 3800 Forms Control Buffer Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125901\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 1: Build a New 3800 Forms Control Buffer Module\nN-------------------------------------------------------\nN3800 Model 1\nN\nNIn this example, the vertical spacing and channel codes for an 11-inch\nNform are specified, and the module is added to the SYS1.IMAGELIB data\nNset as a new member.\nN\nD//FCBMOD1  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         FCB  CH1=1,CH12=80,LPI=8\nD         NAME IJ\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nI  FCB defines the characteristics for the named FCB.\nI\nN  CH1=1 specifies channel 1 code for line 1, allowing for positioning\nN  at line 1.\nN\nN  CH12=80 specifies channel 12 code for line 80, allowing for\nN  positioning at line 80 and a unit exception indication at line 80\nN  (the last printable line on the page.)\nN\nN  LPI=8 specifies that the entire form is to be at a vertical spacing\nN  of 8 lines per inch. Because the SIZE parameter is omitted, the form\nN  length defaults to 11 inches. Because there are 10 inches of\nN  printable space in an 11-inch form, 80 lines are printed at 8 lines\nN  per inch.\nN\nN  The name of the new FCB module is IJ; it is stored as a member of\nN  the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0702": {"ttr": 25874, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:01", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0702\nTdfp Utilities\nT-Chapter 7.\nT-Example 2: Replace a 3800 Forms Control Buffer Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125901\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 2: Replace a 3800 Forms Control Buffer Module\nN-----------------------------------------------------\nN3800 Model 1\nN\nNIn this example, the size and channel codes for a 5-1/2 inch form are\nNspecified, and the module is added to the SYS1.IMAGELIB data set as a\nNreplacement for an existing member. The new module is added to the end\nNof the data set; the name in the data set's directory is updated so\nNthat it points to the new module; the old module can no longer be\nNaccessed through the data set's directory.\nN\nD//FCBMOD2  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         FCB  CH1=(1,7,13,20),CH12=26,SIZE=55\nD         NAME S55(R)\nD\nMMessage from Kenneth: that blank record looKs weird.\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  CH1=(1,7,13,20) specifies channel 1 code for printable line 1,\nN  line 7, line 13, and line 20.\nN\nN  CH12=26 specifies channel 12 code for printable line 26.\nN\nN  SIZE=55 specifies the length of the form as 55 tenths of an inch, or\nN  5-1/2 inches.\nI\nI  Because the LPI parameter is omitted, the vertical spacing defaults\nI  to 6 lines per inch. Because there are 4-1/2 inches of printable\nI  lines in a 5-1/2 inch form, there are 27 print lines on this form.\nI\nN  The name of the FCB module is S55, and it replaces an existing FCB\nN  module of the same name. The new FCB module is stored as a member of\nN  the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0703": {"ttr": 26114, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00?\\x00?\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:01", "lines": 63, "newlines": 63, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0703\nTdfp Utilities\nT-Chapter 7.\nT-eplace a 3800 Forms Control Buffer Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125901\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 3: Replace a 3800 Forms Control Buffer Module\nN-----------------------------------------------------\nN3800 Model 1\nN\nNIn this example, the vertical spacing, channel codes, and size for a\nNform are specified, and the module is added to the SYS1.IMAGELIB data\nNset as a replacement for an existing member. The new module is added to\nNthe end of the data set; the name in the data set's directory is\nNupdated so that it points to the new module; the old module can no\nNlonger be accessed through the data set's directory.\nN\nD//FCBMOD3  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         FCB  CH1=1,CH2=4,CH5=11,SIZE=35,LPI=((6,2),(8,3),(6,4),(8,9))\nD         NAME HL(R)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  CH1=1 specifies channel 1 code for printable line 1.\nN\nN  CH2=4 specifies channel 2 code for line 4.\nN\nN  CH5=11 specifies channel 5 code for line 11.\nN\nN  SIZE=35 specifies the length of the form as 35 tenths of an inch, or\nN  3-1/2 inches. Because there are 2-1/2 inches of printable space on\nN  a 3-1/2 inch form, and because the LPI parameter specifies vertical\nN  spacing for 2-1/2 inches of lines, the vertical spacing of all lines\nN  in the form is accounted for.\nN\nN  LPI=((6,2),(8,3),(6,4),(8,9)) specifies vertical spacing for the\nN  first 18 printable lines in the form: (6,2) specifies lines 1\nN  through 2 are at a vertical spacing of 6 lines per inch, and take up\nN  2/6 inch. (8,3) specifies lines 3 through 5 are at a vertical\nN  spacing of 8 lines per inch, and take up 3/8 inch. (6,4) specifies\nN  lines 6 through 9 are at a vertical spacing of 6 lines per inch, and\nN  take up 4/6 inch. (8,9) specifies lines 10 through 18 are at a\nN  vertical spacing of 8 lines per inch, and take up 1-1/8 inch.\nN\nN  The name of the FCB module is HL; it replaces an existing module of\nN  the same name. The new FCB module is stored as a member of the\nN  SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0704": {"ttr": 26116, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00:\\x00:\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:01", "lines": 58, "newlines": 58, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0704\nTdfp Utilities\nT-Chapter 7.\nT-Example 4: Build a New 3800 Forms Control Buffer Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125901\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 4: Build a New 3800 Forms Control Buffer Module\nN-------------------------------------------------------\nN3800 Model 1\nN\nNIn this example, the vertical spacing, channel codes, and length of a\nNform are specified, and the module is added to the SYS1.IMAGELIB data\nNset as a new member.\nN\nD//FCBMOD4  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         FCB  CH1=1,CH6=33,SIZE=70,LPI=((8,32),(12,2))\nD         NAME TGT\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  CH1=1 specifies channel 1 code for printable line 1.\nN\nN  CH6=33 specifies channel 6 code for line 33.\nN\nN  LPI=((8,32),(12,2)) specifies that the first 32 printable lines of\nN  the form are to be at a vertical spacing of 8 lines per inch, and\nN  the next 2 printable lines are to be at a vertical spacing of 12\nN  lines per inch.\nN\nN  SIZE=70 specifies that the length of the form is 70 tenths of an\nN  inch, or 7 inches. Because there are 6 inches of printable lines in\nN  a 7-inch form and the LPI parameter specifies 32 lines at 8 lines\nN  per inch, or 4 inches, and 2 lines at 12 lines per inch, or 1/6\nN  inch, the vertical spacing for the remaining 1-5/6 inches defaults\nN  to 6 lines per inch.\nN\nN  Therefore, the form consists of lines 1 through 32 at 8 lines per\nN  inch, lines 33 through 34 at 12 lines per inch, and lines 35 through\nN  45 at 6 lines per inch, with channel codes at line 1 and line 33.\nN\nN  The name of the new FCB module is TGT; it is stored as a member of\nN  the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0705": {"ttr": 26118, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x000\\x000\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:02", "lines": 48, "newlines": 48, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0705\nTdfp Utilities\nT-Chapter 7.\nT-Example 5: Replace the 3800 Forms Control Buffer Module STD3\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125902\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 5: Replace the 3800 Forms Control Buffer Module STD3\nN------------------------------------------------------------\nN3800 Model 1\nN\nNIn this example, an FCB module is defined that uses ISO paper sizes,\nNreplacing the IBM-supplied module named STD3. This must be done before\nNthe dump-formatting routines that print high-density dumps can print\nNthem at 8 lines per inch on that printer.\nN\nD//FCBMOD5  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         FCB  CH1=1,CH12=88,LPI=(8,88),SIZE=120\nD         NAME STD3(R)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  CH1=1 specifies channel 1 code for printable line 1; CH12=88\nN  specifies channel 12 code for line 88.\nN\nN  LPI=(8,88) specifies that all 88 printable lines of the form are to\nN  be at a vertical spacing of 8 lines per inch.\nN\nN  SIZE=120 specifies that the length of the form is 120 tenths of an\nN  inch, or 12 inches, which is the longest ISO paper size.\nN\nN  The name of the new FCB module is STD3; it is to replace the\nN  existing module of that same name on SYS1.IMAGELIB.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0706": {"ttr": 26120, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00C\\x00C\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:02", "lines": 67, "newlines": 67, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0706\nTdfp Utilities\nT-Chapter 7.\nT-Example 6: Build a New 3800 Forms Control Buffer Module for\nTAdditional ISO Paper Sizes\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125902\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 6: Build a New 3800 Forms Control Buffer Module for\nNAdditional ISO Paper Sizes\nN-----------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, an FCB module is defined that uses ISO paper sizes and\nNhas the ISO Paper Sizes Additional Feature installed.\nN\nD//FCBMOD   JOB ...                                                    72\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         FCB   CH1=1,CH12=75,SIZE=85,                                  X\nD               LPI=((10,35),(12,4),(10,35),(6,1)\nD         NAME  ARU\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  CH1=1 specifies channel 1 code for line 1, allowing for positioning\nN  at line 1.\nN\nN  Ch12=75 specifies channel 12 code for line 75, allowing for\nN  positioning at line 75 and a unit exception indication at 75 (the\nN  last printable line on the page.)\nN\nN  LPI=((10,35),(12,4),(10,35),(6,1)) specifies vertical spacing for\nN  the entire printable area on the form. The last printable line on\nN  the form must have vertical spacing of 6 lines per inch. The sum of\nN  the lines allocated must be a multiple of 1/2.\nI\nI  EXAMPLES\nI\nI  (10,35)=3 1/2\"\nI  (12,4)=2/6\"\nI  (10,35)=3 1/2\"\nI  (6,1)=1/6\"\nI\nI  3 1/2 + 2/6 + 3 1/2 + 1/6 = 7 1/2 which is a multiple of 1/2.\nM\nM  Kenneth points out that 2/6 + 1/6 = 3/6 == 1/2.\nM\nI\nN  SIZE=85 specifies the length of the form as 85 tenths of an inch, or\nN  8-1/2 inches, although the printable area is 7-1/2 inches.\nN\nN  The name of the new FCB module is ARU; it is stored as a member of\nN  the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0707": {"ttr": 26122, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x02\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00C\\x00C\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:02", "lines": 67, "newlines": 67, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0707\nTdfp Utilities\nT-Chapter 7.\nT-Example 7: Build a 4248 Forms Control Buffer Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125902\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 7: Build a 4248 Forms Control Buffer Module\nN---------------------------------------------------\nNIn this example, a new 4248 default FCB module is built using an\nNexisting FCB module as a model. The new module, NEW1, is added to\nNSYS1.IMAGELIB as a new member. The existing module, OLD1, remains\nNunchanged. OLD1 may be a 4248 FCB called FCB4OLD1, or it may be a 3211\nNFCB called FCB2OLD1. (If both modules existed, FCB4OLD1 would be used.)\nN\nD//FCBMOD7  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         OPTION DEVICE=4248\nD         INCLUDE OLD1\nD         FCB  COPYP=67,PSPEED=M,DEFAULT=YES\nD         NAME NEW1\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  DEVICE=4248 on the OPTION statement specifies that this module is to\nN  be created for the 4248 printer.\nN\nN  The INCLUDE statement specifies that a copy of the existing module\nN  OLD1 is to be used as a basis for the new module, NEW1.\nN\nN  COPYP=67 indicates that the horizontal copy feature should be\nN  activated, and that horizontal copies should begin printing in the\nN  67th print position from the left margin. This setting overrides any\nN  COPYP value previously set in module OLD1; it applies to module\nN  NEW1, but does not change the value set in OLD1.\nN\nI  Note that the value 67 divides a 132-hammer printer into two equal\nI  copy areas for two equally-sized horizontal copies. With COPYP=67, a\nI  maximum of 66 bytes can be sent to the printer.\nN\nN  PSPEED=M indicates that the printer speed should be set to medium\nN  (3000 LPM). This setting overrides any PSPEED value previously set\nN  in module OLD1; it applies to module NEW1, but does not change the\nN  value set in OLD1.\nN\nN  DEFAULT=YES indicates that this module, NEW1, should become a\nN  default FCB module for this installation.\nN\nN  Because these parameters are not specified, the values of LINES,\nN  SIZE, LPI, and CHx default to the values which already exist in\nN  module OLD1.\nN\nN  The NAME statement indicates that this module should be called NEW1.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0708": {"ttr": 26124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00L\\x00L\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:40", "lines": 76, "newlines": 76, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0708\nTdfp Utilities\nT-Chapter 7.\nT-Example 8: Build a New Copy Modification Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125940\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 8: Build a New Copy Modification Module\nN-----------------------------------------------\nN3800 Model 1\nN\nNIn this example, a copy modification module that contains four\nNmodification segments is built. The module is added to the\nNSYS1.IMAGELIB data set as a new member.\nN\nD//COPMOD1  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nDCOPY1    COPYMOD COPIES=(1,1),LINES=(1,1),POS=50,                      X\nD               TEXT=(C,'CONTROLLER'S COPY')\nDCOPY2A   COPYMOD COPIES=(2,1),LINES=(1,1),POS=50,                      X\nD               TEXT=(C,'SHIPPING MANAGER'S COPY')\nDCOPY2B   COPYMOD COPIES=(2,1),LINES=(34,3),POS=75,                     X\nD               TEXT=(10C,' ')\nDCOPYALL  COPYMOD COPIES=(1,4),LINES=(58,1),POS=35,                     X\nD               TEXT=((C,'***'),(C,'CONFIDENTIAL'),(3X,'5C'))\nD         NAME RTO1\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The COPY1 COPYMOD statement specifies text that applies to each page\nN  of the first copy of the output data set: LINES=(1,1) and POS=50\nN  specify that the text is to be on the first printable line of each\nN  page, starting at the 50th print position from the left.\nN\nN  The TEXT parameter identifies each page of the copy as being the\nN  \"Controller's Copy\".\nN\nN  The COPY2A COPYMOD statement specifies text that applies to each\nN  page of the second copy of the output data set. The text is to be on\nN  the first line of each page, at the 50th print position from the\nN  left, with each page of the copy being the \"Shipping Manager's\nN  Copy\".\nN\nN  The COPY2B COPYMOD statement specifies that part of the second\nN  copy's output data set text is to be blanked out, so that the first,\nN  third, and subsequent copies contain information that is not printed\nN  on the second copy. The blank area is to be on lines 34, 35, and 36,\nN  beginning at the 75th print position from the left. The text on\nN  lines 34, 35, and 36, between print positions 75 and 84, is to be\nN  blank (that is, the character specified between the TEXT parameter's\nN  single quotation marks is a blank).\nN\nN  The COPYALL COPYMOD statement specifies text that applies to the\nN  first four copies of the output data set. This example assumes that\nN  no more than four copies are printed each time the job that produces\nN  the output data set is processed. The text is to be on the 58th line\nN  on each page, at the 35th print position from the left. The legend\nN  \"***CONFIDENTIAL***\" is to be on each page of the copy. Note that\nN  the text can be coded in both character and hexadecimal format.\nN\nN  The name of the copy modification module is RTO1; it is stored as a\nN  member of the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0709": {"ttr": 26126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00D\\x00D\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:41", "lines": 68, "newlines": 68, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0709\nTdfp Utilities\nT-Chapter 7.\nT-Example 9: Build a New Copy Modification Module from an Existing Copy\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125941\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 9: Build a New Copy Modification Module from an Existing Copy\nN---------------------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, a copy of an existing copy modification module, RTO1,\nNis used as the basis for a new copy modification module. The new module\nNis added to the SYS1.IMAGELIB data set as a new member. The existing\nNmodule, RTO1, remains unchanged and available for use.\nN\nD//COPMOD2  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         INCLUDE RTO1,DELSEG=1\nD         OPTION OVERRUN=8,DEVICE=3800M3\nD         COPYMOD COPIES=(2,3),LINES=(52,6),POS=100,                    X\nD               TEXT=(X,'40404040404040405C5C')\nD         NAME  AP\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The INCLUDE statement specifies that a copy of the copy modification\nN  module named RTO1 is used as a basis for the new module, and that\nN  the first modification segment of RTO1 is to be deleted from the\nN  copy.\nN\nN  OVERRUN=8 in the OPTION statement specifies that the IEBIMAGE\nN  program is to print a warning message if the copy modification could\nN  cause a line overrun condition when printing at 6 and 8 lines per\nN  inch. The program is also to suppress any warning messages that\nN  apply to printing at 10 and 12 lines per inch. DEVICE=3800M3 in the\nN  OPTION statement specifies 3800 Model 3 compatibility mode\nN  processing.\nN\nN  The COPYMOD statement specifies text that applies to each page of\nN  the second, third, and fourth copies of the output data set:\nN  LINES=(52,6) and POS=100 specify that the text is to be on the 52nd\nN  line and repeated for the 53rd through 57th lines of each page,\nN  starting at the 100th print position from the left.\nN\nN  The TEXT statement specifies the text in hexadecimal form: eight\nN  blanks followed by two asterisks (in this example, the assumption is\nN  made that X'40' prints as a blank and that X'5C' prints as an\nN  asterisk; in actual practice, the character arrangement table used\nN  with the copy modification module might translate X'40' and X'5C' to\nN  other printable characters).\nN\nN  The name of the new copy modification module is AP; it is stored as\nN  a member of the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0710": {"ttr": 26128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x009\\x009\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:41", "lines": 57, "newlines": 57, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0710\nTdfp Utilities\nT-Chapter 7.\nT-Example 10: Add a New Character to a Character Arrangement Table Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125941\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 10: Add a New Character to a Character Arrangement Table Module\nN-----------------------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, an IBM-supplied character arrangement table module is\nNmodified to include another character, and then added to the\nNSYS1.IMAGELIB data set as a replacement for the IBM-supplied module.\nN\nD//CHARMOD1 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         INCLUDE GF10\nD         OPTION DEVICE=3800M3\nD         TABLE LOC=((2A,2A),(6A,2A),(AA,2A),(EA,2A))\nD         NAME GF10(R)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The INCLUDE statement specifies that a copy of the character\nN  arrangement table named GF10 is to be used as a basis for the new\nN  module.\nN\nN  The OPTION statement with the DEVICE parameter specifies 3800 Model\nN  3 compatibility mode processing.\nN\nN  The TABLE statement specifies updated information for four\nN  translation table entries: X'2A', X'6A', X'AA', and X'EA'. (These\nN  four locations are unused in the IBM-supplied GF10 table.) Each of\nN  the four translation table entries is to point to the '2A' (43rd\nN  character) position in the first WCGM, which contains the scan\nN  pattern for a lozenge.\nN\nN  The name of the character arrangement table is GF10, and it is\nN  stored as a new module in the SYS1.IMAGELIB data set. The data set's\nN  directory is updated so that the name GF10 points to the new module;\nN  the old GF10 module can no longer be accessed through the data set's\nN  directory.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0711": {"ttr": 26130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:41", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0711\nTdfp Utilities\nT-Chapter 7.\nT-Example 11: Build a New Character Arrangement Table Module from an\nTExisting Copy\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125941\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 11: Build a New Character Arrangement Table Module from an\nNExisting Copy\nN------------------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, an existing character arrangement table module is\nNcopied and used as a basis for a new module. The new character\nNarrangement table is identical to the old one, except that it uses the\nNGothic 15-pitch character set instead of Gothic 10-pitch.\nN\nD//CHARMOD2 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         INCLUDE A11\nD         OPTION  DEVICE=3800M3\nD         TABLE   CGMID=87\nD         NAME    A115\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The INCLUDE statement specifies that a copy of the character\nN  arrangement table named A11 is to be used as a basis for the new\nN  module. The A11 character arrangement table translates 8-bit data\nN  codes to printable characters in the Gothic 10-pitch character set.\nN\nN  The OPTION statement with the DEVICE parameter specifies 3800 Model\nN  3 compatibility mode processing.\nN\nN  The TABLE statement specifies a new character set identifier, X'87',\nN  which is the identifier for the Gothic 15-pitch character set. No\nN  other changes are made to the character arrangement table. The new\nN  table calls for characters in the Gothic 15-pitch character set.\nN\nN  The name of the new character arrangement table is A115; it is\nN  stored as a member of the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0712": {"ttr": 26370, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00C\\x00C\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:42", "lines": 67, "newlines": 67, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0712\nTdfp Utilities\nT-Chapter 7.\nT-Example 12: Build Graphic Characters in a Character Arrangement\nTTable Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125942\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 12: Build Graphic Characters in a Character Arrangement\nNTable Module\nN---------------------------------------------------------------\nN3800 Model 1\nN\nNIn this example, an existing character arrangement table module is\nNcopied and used as the basis for a new module that will include\nNuser-designed characters of a graphic character modification module.\nNThe new module is then added to the SYS1.IMAGELIB data set.\nN\nD//CHARMOD3 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         INCLUDE ONB\nD         TABLE   GCMLIST=ONB1,LOC=((6F,2F,1),(7C,3C,1),(6A,2A,0))\nD         NAME    ONBZ\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The INCLUDE statement specifies that a copy of the character\nN  arrangement table named ONB is to be used as a basis for the new\nN  module. ONB refers to two WCGMs.\nN\nN  The TABLE statement identifies a graphic character modification\nN  module and stipulates the translation table entries for each of its\nN  segments:\nN\nN  GCMLIST=ONB1 identifies the graphic character modification module\nN  named ONB1. The LOC parameter specifies the translate table entry\nN  location, character position, and WCGM number for each segment of\nN  the module:\nI\nI    The first segment corresponds to the 8-bit data code X'6F'. The\nI    segments' scan pattern is to be loaded at character position X'2F'\nI    (that is, the 48th character position) in the second WCGM.\nI\nI    The second segment corresponds to the 8-bit data code X'7C'. The\nI    segment's scan pattern is to be loaded at character position X'3C'\nI    (that is, the 61st character position) in the second WCGM.\nI\nI    The third segment corresponds to the 8-bit data code X'6A'. The\nI    segment's scan pattern is to be loaded at character position X'2A'\nI    (that is, the 43rd character position) in the first WCGM.\nI\nN  The name of the new character arrangement table is ONBZ; it is\nN  stored as a new module in the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0713": {"ttr": 26372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00@\\x00@\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:42", "lines": 64, "newlines": 64, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0713\nTdfp Utilities\nT-Chapter 7.\nT-Example 13: Delete Graphic References From a Character\nTArrangement Table Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125942\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 13: Delete Graphic References From a Character\nNArrangement Table Module\nN------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, an existing character arrangement table module is\nNcopied and used as a basis for a new one. The new character arrangement\nNtable deletes references to all graphic character modification modules\nNand resets the translate table entries that were used to point to\nNcharacter positions for the segments of a graphic character\nNmodification module.\nN\nD//CHARMOD4 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         INCLUDE ZYL\nD         OPTION  DEVICE=3800M3\nD         TABLE   GCMLIST=DELETE,LOC=((6A),(6B))\nD         NAME    ZYLA\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The INCLUDE statement specifies that a copy of the character\nN  arrangement table named ZYL is to be used as a basis for the new\nN  module.\nN\nN  The OPTION statement with the DEVICE parameter specifies 3800 Model\nN  3 compatibility mode processing.\nN\nN  The TABLE statement deletes references to graphic character\nN  modification modules and resets two translation table entries:\nI\nI    GCMLIST=DELETE specifies that all names of graphic character\nI    modification modules included with the module when the ZYL\nI    character arrangement table was copied are to be reset to blanks\nI    (X'40').\nI\nI    The LOC parameter identifies two locations in the translation\nI    table, X'6A' and X'6B', that are to be set to X'FF' (the default\nI    value when no character position or WCGM values are specified).\nI\nN  The name of the new character arrangement table is ZYLA; it is\nN  stored as a member of the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0714": {"ttr": 26374, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00*\\x00*\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:42", "lines": 42, "newlines": 42, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0714\nTdfp Utilities\nT-Chapter 7.\nT-Example 14: List the World Trade National Use Graphics Graphic\nTCharacter Modification Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125942\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 14: List the World Trade National Use Graphics Graphic\nNCharacter Modification Module\nN--------------------------------------------------------------\nN3800 Model 1\nN\nNIn this example, each segment of the IBM-supplied graphic character\nNmodification module containing the World Trade National Use Graphics is\nNprinted. Each segment is unique, although the scan patterns for some\nNsegments are identical to other segment's scan patterns with only the\nN8-bit data code being different.\nN\nD//GRAFMOD1 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(SHR),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         GRAPHIC\nD         NAME *\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DISP=SHR is coded because the library is not being updated.\nN\nN  The World Trade National Use Graphics graphic character modification\nN  module is identified with the pseudonym of \"*\". The scan pattern of\nN  each of the characters in the module is printed.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0715": {"ttr": 26376, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:42", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0715\nTdfp Utilities\nT-Chapter 7.\nT-Example 15: Build a Graphic Character Modification Module from the\nTCharacter Modification Module World Trade GRAFMOD\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125942\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 15: Build a Graphic Character Modification Module from the\nNCharacter Modification Module World Trade GRAFMOD\nN------------------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, a graphic character modification module is built. Its\nNcharacters are segments copied from the World Trade National Use\nNGraphics graphic character modification module. (See the IBM 3800\nNPrinting Subsystem Programmer's Guide for the EBCDIC assignments for\nNthe characters.) The new module is stored in the SYS1.IMAGELIB system\nNdata set.\nN\nD//GRAFMOD2 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         OPTION DEVICE=3800M3\nD        GRAPHIC REF=((24),(25),(26),(27),(28),(31),(33),(35),(38),(40))\nD           NAME CSTW\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  DEVICE=3800M3 in the OPTION statement specifies 3800 Model 3\nN  compatibility mode module format.\nN\nN  By not specifying the GCM keyword, the GRAPHIC statement identifies\nN  the World Trade National Use Graphics graphic character modification\nN  module. Ten of its segments are to be copied and used with the new\nN  module.\nN\nN  The name of the graphic character modification module is CSTW; it is\nN  stored as a new module in the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0716": {"ttr": 26378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00B\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x12Y\\x00b\\x00b\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T12:59:42", "lines": 98, "newlines": 98, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0716\nTdfp Utilities\nT-Chapter 7.\nT-Example 16: Build a New Graphic Character Modification Module and\nTModify a Character Arrangement Table to Use It\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-125942\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 16: Build a New Graphic Character Modification Module and\nNModify a Character Arrangement Table to Use It\nN-----------------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, a graphic character modification module is built. The\nNmodule contains one user-designed character, a reverse 'E', whose 8-bit\nNdata code is designated as X'E0' and whose pitch is 10. An existing\nNcharacter arrangement table is then modified to include the reverse E.\nN\nD//GRAFMOD3 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         OPTION DEVICE=3800M3\nD         GRAPHIC ASSIGN=(E0,10)\nDXXXXXXXXXXXXXXX SEQ=10\nDXXXXXXXXXXXXXXX SEQ=11\nDXXXXXXXXXXXXXXX SEQ=12\nDXXXX SEQ=13\nDXXXX SEQ=14\nDXXXX SEQ=15\nDXXXX SEQ=16\nDXXXX SEQ=17\nDXXXX SEQ=18\nDXXXX SEQ=19\nDXXXXXXXXXXXXX SEQ=20\nDXXXXXXXXXXXXX SEQ=21\nDXXXXXXXXXXXXX SEQ=22\nDXXXX SEQ=23\nDXXXX SEQ=24\nDXXXX SEQ=25\nDXXXX SEQ=26\nDXXXX SEQ=27\nDXXXX SEQ=28\nDXXXX SEQ=29\nDXXXXXXXXXXXXXXX SEQ=30\nDXXXXXXXXXXXXXXX SEQ=31\nDXXXXXXXXXXXXXXX SEQ=32\nD         NAME    BODE\nD         INCLUDE GS10\nD         OPTION  DEVICE=3800M3\nD         TABLE   CGMID=(83,FF),GCMLIST=BODE,LOC=(E0,03,1)\nD         NAME    RE10\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  DEVICE=3800M3 in the OPTION statement preceding the GRAPHIC\nN  statement specifies 3800 Model 3 compatibility mode processing.\nN\nN  The GRAPHIC statement's ASSIGN parameter establishes the 8-bit data\nN  code, X'E0', and the width, 10-pitch, for the user-designed\nN  character. The data statements that follow the GRAPHIC statement\nN  describe the character's scan pattern.\nN\nN  The name of the graphic character modification module is BODE, and\nN  it is stored as a new module in the SYS1.IMAGELIB data set.\nN\nN  The INCLUDE statement specifies that a copy of the GS10 character\nN  arrangement table is to be used as the basis for the new table.\nN\nN  The TABLE statement specifies the addition of the reverse E to that\nN  copy of the GS10 table.\nN\nN  CGMID=(83,FF) specifies the character set identifier X'83' for the\nN  Gothic-10 set (which is the set already used by the GS10 table) and\nN  specifies X'FF' as a character set identifier to allow accessing of\nN  the second WCGM without loading it.\nN\nN  GCMLIST=BODE identifies the graphic character modification module\nN  containing the reverse E for inclusion in the table. LOC=(E0,03,1)\nN  specifies that the reverse E, which has been assigned the 8-bit data\nN  code X'E0', is to be loaded into position X'03' in the second WCGM.\nN  Because this second WCGM is otherwise unused, any position in it\nN  could have been used for the reverse E.\nN\nN  The new character arrangement table is named RE10; it is stored as a\nN  new module in the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0717": {"ttr": 26380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x18\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00Q\\x00P\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:18", "lines": 81, "newlines": 80, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0717\nTdfp Utilities\nT-Chapter 7.\nT-Example 17: Build a Graphic Character Modification Module from\nTMultiple Sources\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140118\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 17: Build a Graphic Character Modification Module from\nNMultiple Sources\nN--------------------------------------------------------------\nN3800 Model 1\nN\nNIn this example, a graphic character modification module is created.\nNIts contents come from three different sources: nine segments are\nNcopied from an existing module with the INCLUDE statement;\nNthe GRAPHIC statement is used to select another segment to be\nNcopied; the GRAPHIC statement is also used to establish\nNstatement is also used to establish characteristics for a user-designed\nNcharacter. The new graphic character modification module, when built,\nNis added to the SYS1.IMAGELIB.\nN\nD//GRAFMOD4 JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         INCLUDE CSTW,DELSEG=3\nD         GRAPHIC REF=(1,6A),GCM=BODE,ASSIGN=9A\nD******** SEQ=06\nD********** SEQ=07\nD**** **** SEQ=08\nD*** *** SEQ=09\nD*** **** SEQ=10\nD*** ****** SEQ=11\nD*** ****** SEQ=12\nD*** **** SEQ=13\nD*** **** SEQ=14\nD*** *** SEQ=15\nD*** *** SEQ=16\nD*** **** **** SEQ=17\nD*** ******* SEQ=18\nD*** ***** SEQ=19\nD         NAME JPCK\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The INCLUDE statement specifies that a copy of the graphic character\nN  modification module named CSTW is to be included with the new\nN  module. All segments of CSTW, except the third segment (as a result\nN  of DELSEG=3), are to be copied into the new module and become the\nN  module's first through ninth modification segments.\nN\nN  The GRAPHIC statement specifies the module's tenth and eleventh\nN  segments:\nN\nN  REF=(1,6A) and GCM=BODE specify that the 10th segment of the new\nN  module is to be obtained by copying the first segment from the\nN  graphic character modification module named BODE. In addition, the\nN  segment's 8-bit data code is to be changed so that its character is\nN  identified with the code X'6A'.\nN\nN  ASSIGN=9A specifies that the new module's 11th segment is a\nN  user-designed character whose 8-bit data code is X'9A' and whose\nN  width is 10-pitch (the default when no pitch value is specified).\nN  The GRAPHIC statement is followed by data statements that specify the\nN  character's scan pattern.\nN\nN  The name of the graphic character modification module is JPCK, it is\nN  stored as a new module in the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0718": {"ttr": 26382, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00\\x96\\x00\\x96\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:19", "lines": 150, "newlines": 150, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0718\nTdfp Utilities\nT-Chapter 7.\nT-Example 18: Define and Use a Character in a Graphic Character\nTModification Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140119\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 18: Define and Use a Character in a Graphic Character\nNModification Module\nN-------------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, a graphic character modification module containing a\nNuser-designed character is built. Next, a format character arrangement\nNtable is modified to include that new character. Then, a copy\nNmodification module is created to print the new character enclosed in a\nNbox of format characters. Finally, the result is tested to allow\nNcomparison of the output with the input.\nN\nD//CHAR     JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         OPTION  DEVICE=3800M3\nDSTEP1    GRAPHIC ASSIGN=5C\nDXXX XXX SEQ=01\nDXXX XXX SEQ=02\nDXXX XXX SEQ=03\nDXXX XXX SEQ=04\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=05\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=06\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=07\nDXXX XXX SEQ=08\nDXXX XXX SEQ=09\nDXXX XXX SEQ=10\nDXXX XXX SEQ=11\nDSEQ=12\nDSEQ=13\nDSEQ=14\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=15\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=16\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=17\nDXXX XXX XXX SEQ=18\nDXXX XXX XXX SEQ=19\nDXXX XXX XXX SEQ=20\nDXXX XXX XXX SEQ=21\nDXXXX XXXXX XXXX SEQ=22\nDXXXX XXXXXXX XXXX SEQ=23\nDXXXXXXXXXXXXXXXXXXX SEQ=24\nDXXXXX XXXXXX SEQ=25\nDSEQ=26\nDSEQ=27\nDSEQ=28\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=29\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=30\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=31\nDXXXXXXX SEQ=32\nDXXXXXXXXXXXXXXXXXX SEQ=33\nDXXXXXXXXXXXXXXXX SEQ=34\nDXXXXXXXXXXXXXXXX SEQ=35\nDXXXXXXXXXXXXXXXXXX SEQ=36\nDXXXXXXX SEQ=37\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=38\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=39\nDXXXXXXXXXXXXXXXXXXXXXXX SEQ=40\nD         NAME    AIBM\nDSTEP2    OPTION  DEVICE=3800M3\nD         INCLUDE FM10\nD         TABLE   GCMLIST=AIBM,LOC=(5C,2C)\nD         NAME    BIBM\nDSTEP3    OPTION  DEVICE=3800M3\nD         COPYMOD COPIES=1,LINES=58,POS=5,TEXT=(C,'W6X')\nD         COPYMOD COPIES=1,LINES=59,POS=5,TEXT=(C,'7*7')\nD         COPYMOD COPIES=1,LINES=60,POS=5,TEXT=(X,'E9F6E8')\nD         NAME    CIBM\nD/*\nD//ST02#02 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*,CHARS=(GF10,BIBM),MODIFY=(CIBM,1)\nD//SYSIN     DD *\nD         OPTION  DEVICE=3800M3\nD         GRAPHIC\nD         NAME    AIBM\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The GRAPHIC statement's ASSIGN parameter specifies that the 8-bit\nN  data code for the user-designed character is X'5C' and the width is\nN  10-pitch (the default when no pitch is specified). The GRAPHIC\nN  statement is followed by data statements that specify the\nN  character's scan pattern for vertical line spacing of 6 lines per\nN  inch.\nN\nN  The name of the graphic character modification module is AIBM, and\nN  it is stored as a new module in SYS1.IMAGELIB.\nN\nN  At STEP2, the INCLUDE statement specifies that a copy of the FM10\nN  character arrangement table is to be used as a basis for the new\nN  module.\nN\nN  The TABLE statement identifies the graphic character modification\nN  module named AIBM, created in the previous step. The TABLE\nN  statement's LOC parameter specifies the translation table entry\nN  location (the character's 8-bit data code) of X'5C' and the position\nN  (X'2C') where that character is to be loaded into the WCGM.\nN\nN  The name of the new character arrangement table, which is added to\nN  SYS1.IMAGELIB, is BIBM.\nN\nN  At STEP3, the three COPYMOD statements specify text that is to be\nN  placed on lines 58, 59, and 60 of the first copy of the output data\nN  set, starting at print position 5 on each line. When used with the\nN  BIBM character arrangement table, the characters W, 6, and X print as\nN  a top left corner, horizontal line segment, and top right corner, all\nN  in line weight 3. The characters 7, *, and 7 print as a weight-3\nN  vertical line segment on both sides of the user-designed character\nN  built at STEP1 (the asterisk has the EBCDIC assignment 5C, which\nN  addresses that character). The hexadecimal E9, F6, and E8 complete\nN  the line-weight-3 Format box around the character.\nN\nN  The name of the copy modification module is CIBM; it is stored as a\nN  new module on SYS1.IMAGELIB.\nN\nN  At TEST, the EXEC statement calls for another execution of the\nN  IEBIMAGE program to test the modules just created. On the SYSPRINT DD\nN  statement the BIBM character arrangement table is the second of two\nN  specified, and the CIBM copy modification module is specified with a\nN  table reference character of 1, to use that BIBM table.\nN\nN  The GRAPHIC statement with no operand specified calls for printing\nN  of the module, AIBM, specified with the NAME statement that follows\nN  it. Each page of the output listing for this IEBIMAGE run has a small\nN  image of the modification printed in the lower left corner.\nN\nN  The OPTION statement with the DEVICE parameter at STEP1, STEP2, and\nN  STEP3 specifies 3800 Model 3 compatibility mode module format and\nN  processing considerations.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0719": {"ttr": 26625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00!\\x00!\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:19", "lines": 33, "newlines": 33, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0719\nTdfp Utilities\nT-Chapter 7.\nT-Example 19: List a Library Character Set Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140119\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 19: List a Library Character Set Module\nN-----------------------------------------------\nN3800 Model 1\nN\nNIn this example, each segment of a library character set is printed.\nNThe scan pattern of each of the characters in the module is printed.\nN\nD//LIBMOD1  JOB ...\nD//STEP1   EXEC PGM=IEBIMAGE\nD//SYSUT1   DD  DISP=(SHR),DSN=SYS1.IMAGELIB\nD//SYSPRINT DD  SYSOUT=*\nD//SYSIN    DD  *\nD         CHARSET\nD         NAME    83\nD/*\nN\nNThe control statements are discussed below:\nN\nN  NAME specifies the name of the library character set (83).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0720": {"ttr": 26627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x006\\x006\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:19", "lines": 54, "newlines": 54, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0720\nTdfp Utilities\nT-Chapter 7.\nT-Example 20: Build a Library Character Set Module\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140119\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 20: Build a Library Character Set Module\nN------------------------------------------------\nN3800 Model 3\nN\nNIn this example, a library character set module is built. Its\nNcharacters are segments copied from the World Trade National Use\nNGraphics graphic character modification module. For the listing of all\nNthe segments of that module, see IBM 3800 Printing Subsystem\nNProgrammer's Guide. The EBCDIC assignments for the characters are\nNreplaced by WCGM-location codes. The new module is stored in the\nNSYS1.IMAGELIB system data set.\nN\nD//LIBMOD2  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         OPTION DEVICE=3800M3\nD         CHARSET REF=((24,01),(25,02),(26,03),(27,04),(28,05),         X\nD               (31,06),(33,07),(35,08),(38,09),(40,0A))\nD         NAME  73\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  DEVICE=3800M3 in the OPTION statement specifies 3800 Model 3\nN  compatibility mode module format.\nN\nN  By not specifying the GCM keyword or a library character set ID, the\nN  CHARSET statement identifies the World Trade National Use Graphics\nN  graphic character modification module. Ten of its segments are to be\nN  copied and used with the new module. For example, the 24th segment\nN  is to be copied and assigned the WCGM location 01. See the REF\nN  parameter (24,01).\nN\nN  The name of the library character set module is 73, and it is stored\nN  as a new module in the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0721": {"ttr": 26629, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00_\\x00_\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:19", "lines": 95, "newlines": 95, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0721\nTdfp Utilities\nT-Chapter 7.\nT-Example 21: Build a Library Character Set Module and Modify a\nTCharacter Arrangement Table to Use It\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140119\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 21: Build a Library Character Set Module and Modify a\nNCharacter Arrangement Table to Use It\nN-------------------------------------------------------------\nN3800 Model 3\nN\nNIn this example, a library character set module is built. The module\nNcontains one user-designed character, a reverse 'E', whose 6-bit\nNWCGM-location code is designated as X'03', and whose pitch is 10. An\nNexisting character arrangement table is then modified to include the\nNreverse E.\nN\nD//LIBMOD3  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         OPTION  DEVICE=3800M3\nD         CHARSET ASSIGN=(03,10)\nDXXXXXXXXXXXXXXX SEQ=10\nDXXXXXXXXXXXXXXX SEQ=11\nDXXXXXXXXXXXXXXX SEQ=12\nDXXXX SEQ=13\nDXXXX SEQ=14\nDXXXX SEQ=15\nDXXXX SEQ=16\nDXXXX SEQ=17\nDXXXX SEQ=18\nDXXXX SEQ=19\nDXXXXXXXXXXXXX SEQ=20\nDXXXXXXXXXXXXX SEQ=21\nDXXXXXXXXXXXXX SEQ=22\nDXXXX SEQ=23\nDXXXX SEQ=24\nDXXXX SEQ=25\nDXXXX SEQ=26\nDXXXX SEQ=27\nDXXXX SEQ=28\nDXXXX SEQ=29\nDXXXXXXXXXXXXXXX SEQ=30\nDXXXXXXXXXXXXXXX SEQ=31\nDXXXXXXXXXXXXXXX SEQ=32\nD         NAME    73\nD         INCLUDE GS10\nD         OPTION  DEVICE=3800M3\nD         TABLE   CGMID=(83,73),LOC=(E0,03,1)\nD         NAME    RE10\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  DEVICE=3800M3 in the OPTION statement specifies 3800 Model 3\nN  compatibility mode module format and processing considerations.\nN\nN  The CHARSET statement's ASSIGN parameter establishes the 6-bit\nN  WCGM-location code, X'03', and the width, 10-pitch, for the\nN  user-designed character. The data statements that follow the CHARSET\nN  statement describe the character's scan pattern.\nN\nN  The name of the library character set module is 73, and it is stored\nN  as a new module in the SYS1.IMAGELIB data set.\nN\nN  The INCLUDE statement specifies that a copy of the GS10 character\nN  arrangement table is to be used as the basis for the new table.\nN\nN  The TABLE statement specifies the addition of the library character\nN  set containing the reverse E to that copy of the GS10 table.\nN  CGMID=(83,73) specifies the character set identifier X'83' for the\nN  Gothic-10 set (which is the set already used by the GS10 table) and\nN  specifies X'73' as a character set identifier to allow loading of\nN  the second WCGM with the library character set 73.\nN\nN  LOC=(E0,03,1) specifies that the reverse E, which has been assigned\nN  the WCGM location 03 in the second WCGM, is to be referenced by the\nN  EBCDIC code X'E0'.\nN\nN  The new character arrangement table is named RE10; it is stored as a\nN  new module in the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0722": {"ttr": 26631, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00N\\x00N\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:19", "lines": 78, "newlines": 78, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0722\nTdfp Utilities\nT-Chapter 7.\nT-Example 22: Build a Library Character Set Module from Multiple Sources\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140119\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 7. IEBIMAGE (Create Printer Image) Program\nN--------------------------------------------------\nNExample 22: Build a Library Character Set Module from Multiple Sources\nN----------------------------------------------------------------------\nN3800 Model 1\nN\nNIn this example, a library character set module is created. Its\nNcontents come from three different sources: 62 segments are copied from\nNan existing module with the INCLUDE statement; the CHARSET statement is\nNused to select another segment to be copied; a second CHARSET statement\nNis used to establish characteristics for a user-designed character. The\nNnew library character set module, when built, is added to the\nNSYS1.IMAGELIB.\nN\nD//LIBMOD4  JOB ...\nD//ST01#01 EXEC PGM=IEBIMAGE\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.IMAGELIB\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD *\nD         INCLUDE 33,DELSEG=(3,4)\nD         CHARSET REF=(1,02),GCM=BODE,ASSIGN=03\nD******** SEQ=06\nD********** SEQ=07\nD**** **** SEQ=08\nD*** *** SEQ=09\nD*** **** SEQ=10\nD*** ****** SEQ=11\nD*** ****** SEQ=12\nD*** **** SEQ=13\nD*** **** SEQ=14\nD*** *** SEQ=15\nD*** *** SEQ=16\nD*** **** **** SEQ=17\nD*** ******* SEQ=18\nD*** ***** SEQ=19\nD         NAME    53\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The SYSUT1 DD statement includes DISP=OLD to ensure that no other\nN  job can modify the data set while this job is executing.\nN\nN  The INCLUDE statement specifies that a copy of the library character\nN  set module named 33 is to be included with the new module. All\nN  segments of 33, except the third and fourth segments (as a result of\nN  DELSEG=3,4), are to be copied into the new module and become the\nN  basis for the new module.\nN\nN  The CHARSET statement specifies the module's third and fourth\nN  segments:\nN\nN  REF=(1,02) and GCM=BODE specify that the third segment of the new\nN  module is to be obtained by copying the first segment from the\nN  graphic character modification module named BODE. The segment's\nN  6-bit WCGM-location code is to be set so that its character is\nN  identified with the code X'02'.\nN\nN  ASSIGN=03 specifies that the new module's fourth segment is a\nN  user-designed character whose 6-bit WCGM-location code is X'03' and\nN  whose width is 10-pitch (the default when no pitch value is\nN  specified). The CHARSET statement is followed by data statements\nN  that specify the character's scan pattern.\nN\nN  The name of the library character set module is 53, it is stored as\nN  a new module in the SYS1.IMAGELIB data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU08": {"ttr": 26633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00 \\x00 \\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:20", "lines": 32, "newlines": 32, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU08\nTdfp Utilities\nT-Chapter 8. IEBISAM Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-094525\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 8. IEBISAM Program\nN--------------------------\nMIEBISAM Program is unsupported as of z/OS V1R7.\nI\nNSC26-4926-02 DFSMS/MVS Version 1 Release 3 Utilities\nN\nMThird Edition (December 1995)\nMThis edition applies to Version 1 Release 3 of DFSMS/MVS\nM(5695-DF1), Release 1 of OS/390 (5645-001), and any\nMsubsequent releases until otherwise indicated in new\nMeditions.\nM\nMMake sure you are using the correct edition for the level\nMof the product.\nM\nI\nNExample 1: Copy Data Set from Two Volumes\nNExample 2: Unload an ISAM Data Set\nNExample 3: Load an Unloaded ISAM Data Set\nI\nIThis is a historical artifact.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0801": {"ttr": 26635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x001\\x001\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:20", "lines": 49, "newlines": 49, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0801\nTdfp Utilities\nT-Chapter 8.\nT-Example 1: Copy Data Set from Two Volumes\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140120\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 8. IEBISAM Program\nN--------------------------\nIExample 1: Copy Data Set from Two Volumes\nN-----------------------------------------\nNIn this example, an ISAM data set is copied from two DASD volumes.\nNThe output data is blocked.\nN\nD//CPY      JOB  ...\nD//ST01#01 EXEC PGM=IEBISAM,PARM=COPY\nD//SYSPRINT  DD SYSOUT=A\nD//SYSUT1    DD DSNAME=ISAM01,VOLUME=SER=(222222,333333),\nD//             DISP=(OLD,DELETE),UNIT=(disk,2),\nD//             DCB=(DSORG=IS,LRECL=500,BLKSIZE=500,RECFM=F,RKP=4)\nD//SYSUT2    DD DSNAME=ISAM02(INDEX),UNIT=disk,\nD//             DCB=(DSORG=IS,BLKSIZE=1000,RECFM=FB),\nD//             DISP=(NEW,KEEP),VOLUME=SER=444444,SPACE=(CYL,(2))\nD//          DD DSNAME=ISAM02(PRIME),UNIT=(disk,2),\nD//             DCB=(DSORG=IS,BLKSIZE=1000,RECFM=FB),DISP=(NEW,KEEP),\nD//             SPACE=(CYL,(10)),VOLUME=SER=(444444,555555),\nD/*\nN\nNThe job control statements are discussed below:\nN\nN  EXEC specifies the program name (IEBISAM) and the COPY operation.\nN\nN  SYSUT1 DD defines an ISAM input data set, ISAM01, which resides on\nN  two disk volumes.\nN\nN  SYSUT2 DD defines the output data set index area, ISAM02; the index\nN  and prime areas are separated.\nN\nN  The second SYSUT2 DD defines the output data set prime area. Ten\nN  cylinders are allocated for the prime area on each of the two disk\nN  volumes.\nN\nMThe ending /* blunder is from IBM. There is no need for an\nMEnd-Of-Data statement in this step.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0802": {"ttr": 26637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00*\\x00*\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:20", "lines": 42, "newlines": 42, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0802\nTdfp Utilities\nT-Chapter 8.\nT-Example 2: Unload an ISAM Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140120\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 8. IEBISAM Program\nN--------------------------\nNExample 2: Unload an ISAM Data Set\nN----------------------------------\nNIn this example, an ISAM input data set is unloaded into\nNa sequential data set; the output is placed on a tape volume.\nN\nD//CONVERT2 JOB  ...\nD//ST01#01 EXEC PGM=IEBISAM,PARM=UNLOAD\nD//SYSPRINT  DD SYSOUT=A\nD//SYSUT1    DD DSNAME=INDSEQ,UNIT=disk,DISP=(OLD,KEEP),\nD//             VOLUME=SER=111112\nD//SYSUT2    DD DSNAME=UNLDSET,UNIT=tape,LABEL=(,SL),\nD//             DISP=(,KEEP),VOLUME=SER=001234,\nD//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=640)\nD/*\nN\nNThe job control statements are discussed below:\nNEXEC specifies the program name (IEBISAM) and the\nNUNLOAD operation.\nN\nN  SYSUT1 DD defines the ISAM input data set, INDSEQ, which\nN  resides on a disk volume.\nN\nN  SYSUT2 DD defines the unloaded output data set, UNLDSET. The\nN  data set consists of fixed blocked records, and is to reside\nN  as the first or only data set on a tape volume.\nN\nMThe ending /* blunder is from IBM. There is no need for an\nMEnd-Of-Data statement in this step.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0803": {"ttr": 26639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00*\\x00*\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:20", "lines": 42, "newlines": 42, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0803\nTdfp Utilities\nT-Chapter 8.\nT-Example 3: Load an Unloaded ISAM Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140120\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 8. IEBISAM Program\nN--------------------------\nNExample 3: Load an Unloaded ISAM Data Set\nN-----------------------------------------\nNIn this example, an unloaded data set is converted to the form of\nNthe original ISAM data set.\nN\nD//CONVERT3 JOB  ...\nD//ST01#01 EXEC PGM=IEBISAM,PARM=LOAD\nD//SYSPRINT  DD SYSOUT=A\nD//SYSUT1    DD DSNAME=UNLDSET,UNIT=tape,LABEL=(2,SL),\nD//             DISP=(OLD,KEEP),VOLUME=SER=001234\nD//SYSUT2    DD DSNAME=INDSEQ,DISP=(,KEEP),DCB=(DSORG=IS),\nD//             SPACE=(CYL,(1)),VOLUME=SER=111112,UNIT=disk\nD/*\nN\nNThe job control statements are discussed below:\nN\nN  EXEC specifies the program name (IEBISAM) and the LOAD operation.\nN\nN  SYSUT1 DD defines the input data set, UNLDSET, which is a\nN  sequential (unloaded) data set. The data set is the second\nN  data set on a tape volume.\nN\nN  SYSUT2 DD defines the output data set, INDSEQ which is an ISAM\nN  data set. One cylinder of space is allocated for the data set on\nN  a disk volume.\nN\nMThe ending /* blunder is from IBM. There is no need for an\nMEnd-Of-Data statement in this step.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU09": {"ttr": 26641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00 \\x00 \\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:21", "lines": 32, "newlines": 32, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU09\nTdfp Utilities\nT-Chapter 9. IEBPDSE (PDSE Validation) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-095207\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 9. IEBPDSE (PDSE Validation) Program\nN--------------------------------------------\nN Example 1: Validate one PDSE\nN Example 2: Validate two PDSEs\nN Example 3: Validate a PDSE with the DUMP option\nI\nNReturn Codes\nN------------\nNIEBPDSE returns a code in register 15 to indicate the results\nNof program execution.\nN\nNThe return codes and their meanings are:\nN\nNReturn Codes Meaning\nN------------ ---------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   The input PDSE is slightly damaged. Processing continues.\nN08 (X'08')   The input PDSE is corrupted. The utility ends.\nN12 (X'0C')   The input PDSE could not be opened. The utility ends.\nN16 (X'10')   The input data set is not a PDSE. The utility ends.\nN------------ ---------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0901": {"ttr": 26643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:21", "lines": 21, "newlines": 21, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0901\nTdfp Utilities\nT-Chapter 9.\nT-Example 1: Validate one PDSE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140121\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 9. IEBPDSE (PDSE Validation) Program\nN--------------------------------------------\nNExample 1: Validate one PDSE\nN----------------------------\nNIn this example, one PDSE is validated.\nN\nD//ST01#01 EXEC PGM=IEBPDSE\nD//SYSPRINT  DD SYSOUT=A\nD//SYSLIB    DD DISP=OLD,DSN=IBMUSER.SIMPLE.V2.PDSE\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0902": {"ttr": 26645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00\\x19\\x00\\x19\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:21", "lines": 25, "newlines": 25, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0902\nTdfp Utilities\nT-Chapter 9.\nT-Example 2: Validate two PDSEs\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140121\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 9. IEBPDSE (PDSE Validation) Program\nN--------------------------------------------\nNExample 2: Validate two PDSEs\nN-----------------------------\nNThis example validates two PDSEs.\nN\nD//ST01#01 EXEC PGM=IEBPDSE\nD//SYSLIB    DD DISP=OLD,DSN=IBMUSER.SIMPLE.V2.PDSE\nD//          DD DISP=OLD,DSN=IBMUSER.SIMPLE.V3.PDSE\nD//          DD DISP=SHR,DSN=SYS1.LINKLIB\nM\nMKenneth wonders why the IBM blunder of adding a PDS as\nMthe third concatenated dataset?\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU0903": {"ttr": 26881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00\\x15\\x00\\x15\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:21", "lines": 21, "newlines": 21, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU0903\nTdfp Utilities\nT-Chapter 9.\nT-Example 3: Validate a PDSE with the DUMP option\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140121\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 9. IEBPDSE (PDSE Validation) Program\nN--------------------------------------------\nNExample 3: Validate a PDSE with the DUMP option\nN-----------------------------------------------\nNThis example validates a PDSE and specifies an SVC dump.\nN\nD//ST01#01 EXEC PGM=IEBPDSE,\nD//             PARM='DUMP'\nD//SYSLIB    DD DISP=SHR,DSN=SYS1.LINKLIB\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU10": {"ttr": 26883, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00!\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:21", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU10\nTdfp Utilities\nT-Chapter 10. IEBPTPCH (Print-Punch) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180512-1590054\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 1: Print Partitioned Data Set\nNExample 2: Punch Sequential Data Sets\nNExample 3: Duplicate a Card Deck\nNExample 4: Print Sequential Data Set According to Default Format\nNExample 5: Print Sequential Data Set According to User Specifications\nNExample 6: Print Three Record Groups\nNExample 7: Print a Pre-Formatted Data Set\nNExample 8: Print Directory of a Partitioned Data Set\nNExample 9: Print Selected Records of a Partitioned Data Set\nNExample 10: Convert to Hexadecimal and Print Partitioned Data\nNExample 11: Print Member Containing DBCS Data\nN\nNReturn Codes Meaning\nN------------ ----------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   Either a physical sequential data set is empty or a\nN             partitioned data set has no members.\nN08 (X'08')   A member specified for printing or punching does not\nN             exist in the input data set and processing will continue\nN             with the next member, or a DBCS error was encountered.\nN12 (X'0C')   An unrecoverable error occurred, a user routine passed a\nN             return code of 12 to IEBPTPCH and the utility is ended, or\nN             a DBCS error was encountered.\nN16 (X'10')   A user routine passed a return code of 16 to IEBPTPCH.\nN             The utility is ended.\nN------------ ----------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1001": {"ttr": 26885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00 \\x00 \\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:22", "lines": 32, "newlines": 32, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1001\nTdfp Utilities\nT-Chapter 10.\nT-Example 1: Print Partitioned Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140122\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 1: Print Partitioned Data Set\nN-------------------------------------\nNIn this example, a member of partitioned data set is printed\nNaccording to user specifications.\nN\nD//PHSEQNO  JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=SHR,DSN=YOUR.PDS.DATASET\nD//SYSUT2    DD SYSOUT=B\nD//SYSIN     DD *\nD         PRINT TYPORG=PO,MAXNAME=1,MAXFLDS=1\nD         MEMBER NAME=UTILUPD8\nD         RECORD FIELD=(80)\nD/*\nM\nMIf the member card entry is not used, the entire data cell will be\nMpunched (SYSOUT=B typically defaults to a PUNCH class).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1002": {"ttr": 26887, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00;\\x00;\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:22", "lines": 59, "newlines": 59, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1002\nTdfp Utilities\nT-Chapter 10.\nT-Example 2: Punch Sequential Data Sets\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140122\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 2: Punch Sequential Data Sets\nN-------------------------------------\nNIn this example, a sequential data set is punched according to\nNuser specifications.\nN\nD//PHSEQNO  JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR,KEEP),DSN=MASTER.SEQSET\nD//SYSUT2    DD SYSOUT=B\nD//SYSIN     DD *\nD         PUNCH MAXFLDS=1,CDSEQ=0,CDINCR=20\nD         RECORD FIELD=(72)\nD         LABELS DATA=YES\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, MASTER.SEQSET, which resides\nN  on a disk or tape volume. The data set contains 80-byte, fixed\nN  blocked records.\nN\nN  SYSUT2 DD defines the system output class (punch is assumed). That\nN  portion of each record from the input data set defined by the FIELD\nN  parameter is represented by one punched card.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  PUNCH begins the punch operation, indicates that one FIELD parameter\nN  is included in a subsequent RECORD statement (MAXFLDS=1), and\nN  assigns a sequence number for the first punched card (00000000) and\nN  an increment value for successive sequence numbers (20). Sequence\nN  numbers are placed in columns 73 through 80 of the output records.\nN\nN  RECORD indicates that positions 1 through 72 of the input records\nN  are to be punched. Bytes 73 through 80 of the input records are\nN  replaced by the new sequence numbers in the output card deck.\nN\nN  LABELS specifies that user header labels and user trailer labels are\nN  punched.\nI\nI  Labels cannot be edited; they are always moved to the first 80 bytes\nI  of the output buffer. No sequence numbers are present on the cards\nI  containing user header and user trailer records.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1003": {"ttr": 26889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:22", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1003\nTdfp Utilities\nT-Chapter 10.\nT-Example 3: Duplicate a Card Deck\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140122\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 3: Duplicate a Card Deck\nN--------------------------------\nNIn this example, a card deck containing valid punch card code\nNor BCD is duplicated.\nN\nD//PUNCH    JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSIN     DD DISP=(OLD),DSN=PDSLIB(PNCHSTMT)\nD//SYSUT2    DD SYSOUT=B\nD//SYSUT1    DD DATA\nD\nD(input card data set including // cards, BUT NOT /*)\nD\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSIN DD defines the control data set PDSLIB which contains the\nN  member PNCHSTMT. (The data set is cataloged.) The record format must\nN  be FB and the logical record length must be 80.\nN\nN  SYSUT2 DD defines the system output class (punch is assumed).\nN\nN  SYSUT1 DD defines the input card data set, which follows in the\nN  input stream.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1004": {"ttr": 26891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\"\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00/\\x00/\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:22", "lines": 47, "newlines": 47, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1004\nTdfp Utilities\nT-Chapter 10.\nT-Example 4: Print Sequential Data Set According to Default Format\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140122\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 4: Print Sequential Data Set According to Default Format\nN----------------------------------------------------------------\nNIn this example, a sequential data set is printed according to the\nNdefault format. The printed output is converted to hexadecimal.\nN\nD//PRINT    JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=INSET,\nD//             UNIT=tape,LABEL=(,NL),\nD//             DCB=(RECFM=U,BLKSIZE=2000)\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT TOTCONV=XE\nD         TITLE ITEM=('PRINT SEQ DATA SET WITH CONV TO HEX',10)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set on a tape volume. The data set\nN  contains undefined records; no record is larger than 2,000 bytes.\nN\nN  SYSUT2 DD defines the output data set. The data set is written to\nN  the system output device (printer assumed).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  PRINT begins the print operation and specifies conversion from\nN  alphanumeric to hexadecimal representation.\nN\nN  TITLE specifies a title to be placed beginning in column 10 of the\nN  printed output. The title is not converted to hexadecimal.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1005": {"ttr": 26893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00#\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00;\\x00;\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:23", "lines": 59, "newlines": 59, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1005\nTdfp Utilities\nT-Chapter 10.\nT-Example 5: Print Sequential Data Set According to User Specifications\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140123\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 5: Print Sequential Data Set According to User Specifications\nN---------------------------------------------------------------------\nNIn this example, a sequential data set is printed according to user\nNspecifications.\nN\nD//PTNONSTD JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=SEQSET\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT MAXFLDS=1\nD         EXITS INHDR=HDRIN,INTLR=TRLIN\nD         RECORD FIELD=(80)\nD         LABELS DATA=YES\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, SEQSET, which is the second\nN  data set on a tape volume.\nN\nN  SYSUT2 DD defines the output data set on the system output device\nN  (printer assumed). Each printed line contains 80 contiguous\nN  characters (one record) of information.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  PRINT begins the print operation and indicates that one FIELD\nN  parameter is included in a subsequent RECORD statement (MAXFLDS=1).\nN\nN  EXITS indicates that exits will be taken to user header label and\nN  trailer label processing routines when these labels are encountered\nN  on the SYSUT1 data set.\nN\nN  RECORD indicates that each input record is processed in its entirety\nN  (80 bytes). Each input record is printed in columns 1 through 80 on\nN  the printer.\nN\nN  LABELS specifies that user header and trailer labels are printed\nN  according to the return code issued by the user exits.\nM\nMKenneth asks, where is the source for those EXITS?\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1006": {"ttr": 26895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00#\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00`\\x00`\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:23", "lines": 96, "newlines": 96, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1006\nTdfp Utilities\nT-Chapter 10.\nT-Example 6: Print Three Record Groups\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140123\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 6: Print Three Record Groups\nN------------------------------------\nNIn this example, three record groups are printed. A user routine is\nNprovided to manipulate output records before they are printed.\nM\nMNo user routines (EXITS) were ever provided. IBM merely shows how\nMyou would invoke it.\nMN\nD//PRINT    JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=SEQDS\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT MAXFLDS=9,MAXGPS=9,MAXLITS=23,STOPAFT=32767\nD         TITLE ITEM=('TIMECONV-DEPT D06'),                             X\nD               ITEM=('JAN10-17',80)\nD         EXITS OUTREC=NEWTIME,INHDR=HDRS,INTLR=TLRS\nD         RECORD IDENT=(6,'498414',1),                                  X\nD               FIELD=(8,1,,10),FIELD=(30,9,XE,20)\nD         RECORD IDENT=(2,'**',39),                                     X\nD               FIELD=(8,1,,10),FIELD=(30,9,XE,20)\nD         RECORD IDENT=(6,'498414',1),                                  X\nD               FIELD=(8,1,,10),FIELD=(30,9,XE,20)\nD         LABELS CONV=XE,DATA=ALL\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, called SEQDS. The data set\nN  resides on a disk volume.\nN\nN  SYSUT2 DD defines the output data set on the system output device\nN  (printer assumed).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The PRINT statement:\nN\nN  1. Initializes the print operation.\nN  2. Indicates that not more than nine FIELD parameters are included\nN     in subsequent RECORD statements (MAXFLDS=9).\nN  3. Indicates that not more than nine IDENT parameters are included\nN     in subsequent RECORD statements (MAXGPS=9).\nN  4. Indicates that not more than 23 literal characters are included\nN     in subsequent IDENT parameters (MAXLITS=23).\nN  5. Indicates that processing is ended after 32767 records are\nN     processed or after the third record group is processed, whichever\nN     comes first. Because MAXLINE is omitted, 60 lines are printed on\nN     each page.\nN\nN  TITLE specifies two titles, to be printed on one line. The titles\nN  are not converted to hexadecimal.\nN\nN  EXITS specifies the name of a user routine (NEWTIME), which is used\nN  to manipulate output records before they are printed.\nN\nN  The first RECORD statement defines the first record group to be\nN  processed and indicates where information from the input records is\nN  placed in the output records. Positions 1 through 8 of the input\nN  records appear in positions 10 through 17 of the printed output, and\nN  positions 9 through 38 are printed in hexadecimal representation and\nN  placed in positions 20 through 79.\nN\nN  The second RECORD statement defines the second group to be\nN  processed. The parameter in the IDENT operand specifies that an\nN  input record last record edited according to the FIELD operand in\nN  this RECORD statement. The FIELD operand specifies that positions 1\nN  through 8 of the input records are placed in positions 10 through 17\nN  of the printed output, and positions 9 through 38 are printed in\nN  hexadecimal representation and appear in positions 20 through 79.\nN\nN  The third and last RECORD statement is equal to the first RECORD\nN  statement. An input record that meets the parameter in the IDENT\nN  operand ends processing, unless the STOPAFT parameter in the PRINT\nN  statement has not already done so.\nN\nN  LABELS specifies that all user header or trailer labels are to be\nN  printed regardless of any return code, except 16, issued by the\nN  user's exit routine. It also indicates that the labels are converted\nN  from alphanumeric to hexadecimal representation (CONV=XE).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1007": {"ttr": 26897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00#\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:23", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1007\nTdfp Utilities\nT-Chapter 10.\nT-Example 7: Print a Pre-Formatted Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140123\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 7: Print a Pre-Formatted Data Set\nN-----------------------------------------\nNIn this example, the input is a SYSOUT (sequential) data set, which was\nNpreviously written as the second data set of a standard label tape. It\nNis printed in SYSOUT format.\nN\nD//PTSYSOUT JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=LISTING\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT PREFORM=A\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, which was previously written\nN  as the second data set of a standard label tape. The data set has\nN  been assigned the name LISTING.\nN\nN  SYSUT2 DD defines the output data set on the system output device\nN  (printer assumed).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The PRINT statement begins the print operation and indicates that an\nN  ASA control character is provided as the first character of each\nN  record to be printed (PREFORM=A).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1008": {"ttr": 26899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00#\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00?\\x00?\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:23", "lines": 63, "newlines": 63, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1008\nTdfp Utilities\nT-Chapter 10.\nT-Example 8: Print Directory of a Partitioned Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140123\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 8: Print Directory of a Partitioned Data Set\nN----------------------------------------------------\nNIn this example, the directory of a partitioned data set is printed\nNaccording to the default format. The printed output is converted to\nNhexadecimal.\nN\nD//PRINTDIR JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=MAIN.PDS,\nD//             DCB=(RECFM=U,BLKSIZE=256)\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT TYPORG=PS,TOTCONV=XE\nD         TITLE ITEM=('PRINT PARTITIONED DIRECTORY OF PDS',10)\nD         TITLE ITEM=('FIRST TWO BYTES SHOW NUM OF USED BYTES',10)\nD         LABELS DATA=NO\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set (the partitioned directory),\nN  which resides on a disk volume. The DCB keywords describe the\nN  directory, not the member contents.\nN\nN  SYSUT2 DD defines the output data set on the system output device\nN  (printer assumed).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  PRINT begins the print operation, indicates that the partitioned\nN  directory is organized sequentially, and specifies conversion from\nN  alphanumeric to hexadecimal representation.\nN\nN  The first TITLE statement specifies a title, and the second TITLE\nN  statement specifies a subtitle. Neither title is converted to\nN  hexadecimal.\nN\nN  LABELS specifies that no user labels are printed.\nN\nI  Note: Not all of the bytes in a directory block need to contain data\nI  pertaining to the partitioned data set. Unused bytes are sometimes\nI  used by the operating system as temporary work areas. With\nI  conversion to hexadecimal representation, the first four characters\nI  of printed output indicate how many bytes of the 256-byte block\nI  pertain to the partitioned data set. Any unused bytes occur in the\nI  latter portion of the directory block. They are not interspersed\nI  with the used bytes.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1009": {"ttr": 27137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x000\\x000\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:24", "lines": 48, "newlines": 48, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1009\nTdfp Utilities\nT-Chapter 10.\nT-Example 9: Print Selected Records of a Partitioned Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140123\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 9: Print Selected Records of a Partitioned Data Set\nN-----------------------------------------------------------\nNIn this example, a partitioned data set (ten records from each member)\nNis printed according to the default format. The printed output is\nNconverted to hexadecimal.\nN\nD//PRINTPDS JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR),DSN=WAYNE.TEST.DATA\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT TOTCONV=XE,TYPORG=PO,STOPAFT=10\nD         TITLE ITEM=('PRINT PDS -10 RECS EACH MEM',20)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, called WAYNE.TEST.DATA, on a\nN  disk volume.\nN\nN  SYSUT2 DD defines the output data set on the system output device\nN  (printer assumed).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  PRINT begins the print operation, specifies conversion from\nN  alphanumeric to hexadecimal representation, indicates that the input\nN  data set is partitioned, and specifies that 10 records from each\nN  member are to be printed.\nN\nN  TITLE specifies a title to be placed beginning in column 20 of the\nN  printed output. The title is not converted to hexadecimal.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1010": {"ttr": 27139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:24", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1010\nTdfp Utilities\nT-Chapter 10.\nT-Example 10: Convert to Hexadecimal and Print Partitioned Data\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140124\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 10: Convert to Hexadecimal and Print Partitioned Data\nN-------------------------------------------------------------\nNIn this example, two partitioned members are printed according to the\nNdefault format. The printed output is converted to hexadecimal.\nN\nD//PRNTMEMS JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR),DSN=BROWN.MAIN.LIB\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT TYPORG=PO,TOTCONV=XE,MAXNAME=2\nD         TITLE ITEM=('PRINT TWO MEMBS WITH CONV TO HEX',10)\nD         MEMBER NAME=MEMBER1\nD         MEMBER NAME=MEMBER2\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, called BROWN.MAIN.LIB, on a\nN  disk volume.\nN\nN  SYSUT2 DD defines the output data set on the system output device\nN  (printer assumed).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  PRINT begins the print operation, indicates that the input data set\nN  is partitioned, specifies conversion from alphanumeric to\nN  hexadecimal representation, and indicates that two MEMBER statements\nN  appear in the control data set (MAXNAME=2).\nN\nN  TITLE specifies a title to be placed beginning in column 10 of the\nN  printed output. The title is not converted to hexadecimal.\nN\nN  MEMBER specifies the member names of the members to be printed\nN  (MEMBER1 and MEMBER2).\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1011": {"ttr": 27141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x002\\x002\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:24", "lines": 50, "newlines": 50, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1011\nTdfp Utilities\nT-Chapter 10.\nT-Example 11: Print Member Containing DBCS Data\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140124\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 10. IEBPTPCH (Print-Punch) Program\nN------------------------------------------\nNExample 11: Print Member Containing DBCS Data\nN---------------------------------------------\nNIn this example, a member of a partitioned data set that contains DBCS\nNdata is printed after the DBCS data is checked to ensure that all DBCS\nNcharacters are printable.\nN\nD//DBCS     JOB ...\nD//ST01#01 EXEC PGM=IEBPTPCH\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=PDS\nD//SYSUT2    DD SYSOUT=*\nD//SYSIN     DD *\nD         PRINT TYPORG=PO,DBCS=YES,MAXFLDS=1,MAXNAME=1\nD         MEMBER NAME=MEM1\nD         RECORD FIELD=(,,CV)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input data set, PDS, on a disk volume.\nN\nN  SYSUT2 DD defines the system printer as the output data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  PRINT begins the print operation, indicates that the input data set\nN  is partitioned, and indicates that double-byte character set data\nN  will be printed. The statement also indicates that one MEMBER\nN  statement appears in the control data set, and that one FIELD\nN  parameter appears on a subsequent RECORD statement.\nN\nN  MEMBER specifies the member, MEM1, that is to be printed.\nN\nN  RECORD specifies that the DBCS data is to be checked to ensure that\nN  it is printable.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU11": {"ttr": 27143, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00%\\x00$\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:24", "lines": 37, "newlines": 36, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU11\nTdfp Utilities\nT-Chapter 11. IEBUPDTE (Update Data Set) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-121208\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 1: Place Two Procedures in SYS1.PROCLIB\nNExample 2: Create a Three-Member Library\nNExample 3: Create New Library Using SYS1.MACLIB as a Source\nNExample 4: Update a Library Member\nNExample 5: Create New Master Data Set and Delete Selected Records\nNExample 6: Create and Update a Library Member\nNExample 7: Insert Records into a Library Member\nNExample 8: Renumber and Insert Records into a Library Member\nNExample 9: Create a Sequential Data Set from Card Input\nNExample 10: Copy Sequential Data Set from One Volume to Another\nNExample 11: Create a New Partitioned Data Set 234\nN\nNReturn Codes Meaning\nN------------ ----------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   A control statement is coded incorrectly or used\nN             erroneously. If either the input or output is sequential,\nN             the utility is ended. If both are partitioned, the program\nN             continues processing with the next function to be\nN              performed.\nN12 (X'0C')   An unrecoverable error exists. The utility is ended.\nN16 (X'10')   A label processing code of 16 was received from a user's\nN             label processing routine. The utility is ended.\nN------------ ----------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1101": {"ttr": 27145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00U\\x00U\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:24", "lines": 85, "newlines": 85, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1101\nTdfp Utilities\nT-Chapter 11.\nT-Example 1: Place Two Procedures in SYS1.PROCLIB\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140124\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 1: Place Two Procedures in SYS1.PROCLIB\nN-----------------------------------------------\nNIn this example, two procedures are to be placed in the cataloged\nNprocedure library, SYS1.PROCLIB. The example assumes that the two\nNprocedures can be accommodated within the space originally allocated to\nNthe procedure library.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=SYS1.PROCLIB\nD//SYSUT2    DD DISP=(OLD),DSN=SYS1.PROCLIB\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD DATA\nD  ./       ADD    LIST=ALL,NAME=ERASE,LEVEL=01,SOURCE=0\nD  ./       NUMBER NEW1=10,INCR=10\nD  //ERASE   EXEC PGM=IEBUPDTE\nD  //DD1      DD  DISP=(OLD),UNIT=disk,VOL=SER=111111\nD  //SYSPRINT DD  SYSOUT=*\nD  ./       REPL   LIST=ALL,NAME=LISTPROC\nD  ./       NUMBER NEW1=10,INCR=10\nD  //LIST    EXEC PGM=IEBGENER\nD  //SYSPRINT DD  SYSOUT=*\nD  //SYSUT1   DD  DISP=SHR,DSN=SYS1.PROCLIB(&MEMBER)\nD  //SYSUT2   DD  SYSOUT=*,DCB=(RECFM=F,BLKSIZE=80)\nD  //SYSIN    DD  DATA\nD  ./ ENDUP\nD/*\nD//*                                          <==== SHIFT THE DATA LEFT\nD/*CANCEL\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 and SYSUT2 DD define the SYS1.PROCLIB data set, which is\nN  assumed to be cataloged.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains the utility control statements and the\nN  data to be placed in the procedure library.\nN\nN  The ADD function statement indicates that records (data statements)\nN  in the control data set are to be placed in the output. The newly\nN  created procedure, ERASE, is listed in the message data set.\nN\nN  The ADD function will not take place if a member named ERASE already\nN  exists in the new master data set referenced by SYSUT2.\nN\nN  The first NUMBER detail statement indicates that the new and\nN  replacement procedures are to be assigned sequence numbers. The\nN  first record of each procedure is assigned sequence number 10; the\nN  next record is assigned sequence number 20, and so on.\nN\nN  The ERASE EXEC statement marks the beginning of the first new\nN  procedure.\nN\nN  The REPL function statement indicates that records (data statements)\nN  in the control data set are to replace an already existing member.\nN  The member is stored in the new master data set referenced by\nN  SYSUT2. The REPL function will only take place if a member named\nN  LISTPROC already exists in the old master data set referenced by\nN  SYSUT1.\nN\nN  The second NUMBER detail statement is a duplicate of the first.\nN\nN  The LIST EXEC statement marks the beginning of the second new\nN  procedure.\nN\nN  The ENDUP statement marks the end of the SYSIN DD input data.\nM\nMKenneth added the /*CANCEL to prevent you from running this job.\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1102": {"ttr": 27147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00E\\x00E\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:25", "lines": 69, "newlines": 69, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1102\nTdfp Utilities\nT-Chapter 11.\nT-Example 2: Create a Three-Member Library\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140125\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 2: Create a Three-Member Library\nN----------------------------------------\nNIn this example, a three-member partitioned library is created. The\nNinput data is contained solely in the control data set.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=NEW\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=OUTLIB,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(50,,10)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD DATA\nD  ./ ADD NAME=MEMB1,LEVEL=00,SOURCE=0,LIST=ALL\nD\nD  (Data statements, sequence numbers in columns 73 through 80)\nD\nD  ./ ADD NAME=MEMB2,LEVEL=00,SOURCE=0,LIST=ALL\nD\nD  (Data statements, sequence numbers in columns 73 through 80)\nD\nD  ./ ADD NAME=MEMB3,LEVEL=00,SOURCE=0,LIST=ALL\nD\nD  (Data statements, sequence numbers in columns 73 through 80)\nD\nD  ./ ENDUP\nD/*\nD//*                                          <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT2 DD defines the new partitioned master, OUTLIB. Enough space\nN  is allocated to allow for subsequent modifications without creating a\nN  new master data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. The data set contains the utility control statements and the\nN  data to be placed as three members in the output partitioned data\nN  set.\nN\nN  The ADD function statements indicate that subsequent data statements\nN  are to be placed as members in the output partitioned data set. Each\nN  ADD function statement specifies a member name for subsequent data\nN  and indicates that the member and control statement is listed in the\nN  message data set.\nN\nN  The data statements contain the data to be placed in each member of\nN  the output partitioned data set.\nN\nN  ENDUP signals the end of control data set input.\nM\nMBecause sequence numbers (other than blank numbers) are included within\nMthe data statements, no NUMBER detail statements are included in the\nMexample.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1103": {"ttr": 27149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00O\\x00O\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:25", "lines": 79, "newlines": 79, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1103\nTdfp Utilities\nT-Chapter 11.\nT-Example 3: Create New Library Using SYS1.MACLIB as a Source\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140125\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 3: Create New Library Using SYS1.MACLIB as a Source\nN-----------------------------------------------------------\nNIn this example, a three-member partitioned data set (NEWMCLIB) is\nNcreated. The data set will contain two members, ATTACH and DETACH,\nNcopied from an existing partitioned data set (SYS1.MACLIB), and a new\nNmember, EXIT, which is contained in the control data set.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(SHR,KEEP),DSN=SYS1.MACLIB,DISP=SHR\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=DEV.DRIVER3.NEWMCLIB,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(100,,10)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,,LRECL=80)\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD DATA\nD  ./        REPRO  NAME=ATTACH,LEVEL=00,SOURCE=1,LIST=ALL\nD  ./        REPRO  NAME=DETACH,LEVEL=00,SOURCE=1,LIST=ALL\nD  ./        ADD    NAME=EXIT,LEVEL=00,SOURCE=1,LIST=ALL\nD  ./        NUMBER NEW1=10,INCR=100\nD\nD  (Data records for EXIT member)\nD\nD  ./ ENDUP\nD/*\nD//                                           <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input partitioned data set SYS1.MACLIB, which\nN  is assumed to be cataloged.\nN\nN  SYSUT2 DD defines the output partitioned data set\nN  DEV.DRIVER3.NEWMCLIB. Enough space is allocated to allow for\nN  subsequent modifications without creating a new master data set.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The REPRO function statements identify the existing input members\nN  (ATTACH and DETACH) to be copied onto the output data set. These\nN  members are also listed in the message data set (because LIST=ALL is\nN  specified).\nN\nN  The ADD function statement indicates that records (subsequent data\nN  statements) are to be placed as members in the output partitioned\nN  data set, called EXIT. The data statements are to be listed in the\nN  message data set.\nN\nN  The NUMBER detail statement assigns sequence numbers to the data\nN  statements. (The data statements contain blank sequence numbers in\nN  columns 73 through 80.) The first record of the output member is\nN  assigned sequence number 10; subsequent record numbers are increased\nN  by 100.\nN\nN  ENDUP signals the end of SYSIN data.\nI\nI  Note that the three named input members (ATTACH, DETACH, and EXIT)\nI  do not have to be specified in the order of their collating sequence\nI  in the old master.\nM\nMKenneth points out that processing members in sorted sequence is more\nMefficient. Thus, while you do not have ot, it is a good practice.\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1104": {"ttr": 27151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00:\\x00:\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:25", "lines": 58, "newlines": 58, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1104\nTdfp Utilities\nT-Chapter 11.\nT-Example 4: Update a Library Member\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140125\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 4: Update a Library Member\nN----------------------------------\nNIn this example, a member (MODMEMB) is updated within the space it\nNactually occupies. Two existing logical records are replaced, and the\nNentire member is renumbered.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=PDS\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD *\nD  ./       CHANGE NAME=MODMEMB,LIST=ALL,UPDATE=INPLACE\nD  ./       NUMBER SEQ1=ALL,NEW1=10,INCR=5\nD\nD  (Data statement 1, sequence number 00000020)\nD  (Data statement 2, sequence number 00000035)\nD\nD/*\nD//*                                          <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the partitioned data set that is updated in place.\nI  (Note that the member name need not be specified in the DD\nI  statement.)\nM  Need not be specified OR cannot be?\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The CHANGE function statement indicates the name of the member to be\nN  updated (MODMEMB) and specifies the UPDATE=INPLACE operation. The\nN  entire member is listed in the message data set. Note that, as\nN  renumbering is being done, and since UPDATE=INPLACE was specified,\nN  the listing would have been provided even if the LIST=ALL parameter\nN  had not been specified. See the LIST parameter for more information.\nN\nN  The NUMBER detail statement indicates that the entire member is to\nN  be renumbered, and specifies the first sequence number to be assigned\nN  and the increment value (5) for successive sequence numbers.\nN\nN  The data statements replace existing logical records having sequence\nN  numbers of 20 and 35.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1105": {"ttr": 27153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00C\\x00C\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:25", "lines": 67, "newlines": 67, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1105\nTdfp Utilities\nT-Chapter 11.\nT-Example 5: Create New Master Data Set and Delete Selected Records\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140125\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 5: Create New Master Data Set and Delete Selected Records\nN-----------------------------------------------------------------\nNIn this example, a new master sequential data set is created from\nNpartitioned input and selected logical records are deleted.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=DCB.PARTDS\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=SEQDS,\nD//             UNIT=tape,LABEL=(2,SL),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD *\nD  ./       CHANGE NEW=PS,NAME=OLDMEMB1\nD\nD  (Data statement 1, sequence number 00000123)\nD\nD  ./       DELETE SEQ1=223,SEQ2=246\nD\nD  (Data statement 2, sequence number 00000224)\nD\nD/*\nD//*                                          <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input partitioned data set DCB.PARTDS, which\nN  resides on a disk volume.\nN\nN  SYSUT2 DD defines the output sequential data set, SEQDS. The data\nN  set is written as the second data set on a tape volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  CHANGE identifies the input member (OLDMEMB1) and indicates that the\nN  output is a sequential data set (NEW=PS).\nN\nN  The first data statement replaces the logical record whose sequence\nN  number is identical to the sequence number in the data statement\nN  (00000123). If no such logical record exists, the data statement is\nN  incorporated in the proper sequence within the output data set.\nN\nN  The DELETE detail statement deletes logical records having sequence\nN  numbers from 223 through 246, inclusive.\nN\nN  The second data statement is inserted in the proper sequence in the\nN  output data set, because no logical record with the sequence number\nN  224 exists (it was deleted in the previous statement).\nI\nI  Note that only one member can be used as input when converting to\nI  sequential organization.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1106": {"ttr": 27393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00R\\x00R\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:26", "lines": 82, "newlines": 82, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1106\nTdfp Utilities\nT-Chapter 11.\nT-Example 6: Create and Update a Library Member\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140126\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 6: Create and Update a Library Member\nN---------------------------------------------\nNIn this example, a member of a partitioned data set is created from\nNsequential input and existing logical records are updated.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=BROWN.OLDSEQDS\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=BROWN.NEWPART,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(10,5,5)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD *\nD  ./       CHANGE NEW=PO,MEMBER=PARMEM1,LEVEL=01,\nD  ./       SEQFLD=605,COLUMN=40,SOURCE=0\nD\nD  (Data statement 1, sequence number 00020)\nD\nD  ./ DELETE SEQ1=220,SEQ2=250\nD\nD  (Data statement 2, sequence number 00230)\nD  (Data statement 3, sequence number 00260)\nD\nD  ./       ALIAS NAME=MEMB1\nD/*\nD//*                                          <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input sequential data set (BROWN.OLDSEQDS).\nN  The data set resides on a tape volume.\nN\nN  SYSUT2 DD defines the output partitioned data set (BROWN.NEWPART).\nN  Enough space is allocated to provide for members that may be added\nN  in the future.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The CHANGE function statement identifies the output member (PARMEM1)\nN  and indicates that a conversion from sequential input to partitioned\nN  output is made. The SEQFLD parameter indicates that a 5-byte\nN  sequence number is located in columns 60 through 64 of each data\nN  statement. The COLUMN=40 parameter specifies the starting column of\nN  a field (within subsequent data statements) from which replacement\nN  information is obtained. SOURCE=0 indicates that the replacement\nN  information is provided by you.\nN\nN  The first data statement is used as replacement data. Columns 40\nN  through 80 of the statement replace columns 40 through 80 of the\nN  corresponding logical record. If no such logical record exists, the\nN  entire card image is inserted in the output data set member.\nN\nN  The DELETE detail statement deletes all of the logical records\nN  having sequence numbers from 220 through 250.\nN\nN  The second data statement, whose sequence number falls within the\nN  range specified in the DELETE detail statement above, is\nN  incorporated in its entirety in the output data set member.\nN\nN  The third data statement, which is beyond the range of the DELETE\nN  detail statement, is treated in the same manner as the first data\nN  statement.\nN\nN  ALIAS assigns the alias name MEMB1 to the output data set member\nN  PARMEM1.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1107": {"ttr": 27395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00@\\x00@\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:26", "lines": 64, "newlines": 64, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1107\nTdfp Utilities\nT-Chapter 11.\nT-Example 7: Insert Records into a Library Member\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140126\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 7: Insert Records into a Library Member\nN-----------------------------------------------\nNIn this example, a block of three logical records is inserted into an\nNexisting member, and the updated member is placed in the existing\nNpartitioned data set.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=PDS\nD//SYSUT2    DD DISP=(OLD),DSN=PDS\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD *\nD  ./       CHANGE NAME=RENUM,LIST=ALL,LEVEL=01,SOURCE=0\nD  ./       NUMBER SEQ1=15,NEW1=20,INCR=5,INSERT=YES\nD\nD  (Data statement 1)\nD  (Data statement 2)\nD  (Data statement 3)\nD\nD/*\nD//*                                           <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 and SYSUT2 DD define the partitioned data set (PDS).\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The CHANGE function statement identifies the input member RENUM. The\nN  entire member is listed in the message data set.\nN\nN  The NUMBER detail statement specifies the insert operation and\nN  controls the renumbering operation as described below.\nN\nN  The data statements are the logical records to be inserted.\nN  (Sequence numbers are assigned when the data statements are\nN  inserted.)\nN\nN  In this example, the existing logical records have sequence numbers\nN  10, 15, 20, 25, and 30. Sequence numbers are assigned by the NUMBER\nN  detail statement, as follows:\nN\nN  1. Data statement 1 is assigned sequence number 20 (NEW1=20) and\nN     inserted after existing logical record 15 (SEQ1=15).\nN  2. Data statements 2 and 3 are assigned sequence numbers 25 and 30\nN     (INCR=5) and are inserted after data statement 1.\nN  3. Existing logical records 20, 25, and 30 are assigned sequence\nN     numbers 35, 40, and 45, respectively.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1108": {"ttr": 27397, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00\\\\\\x00\\\\\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:26", "lines": 92, "newlines": 92, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1108\nTdfp Utilities\nT-Chapter 11.\nT-Example 8: Renumber and Insert Records into a Library Member\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140126\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 8: Renumber and Insert Records into a Library Member\nN------------------------------------------------------------\nNIn this example, two blocks (three logical records per block) are\nNinserted into an existing member, and the member is placed in the\nNexisting partitioned data set. A portion of the output member is also\nNrenumbered.\nN\nD//UPDATE   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=PDS\nD//SYSUT2    DD DISP=(OLD),DSN=PDS\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD *\nD  ./       CHANGE NAME=RENUM,LIST=ALL,LEVEL=01,SOURCE=0,SEQFLD=(765,783)\nD  ./       NUMBER SEQ1=AA015,NEW1=AA020,INCR=5,INSERT=YES\nD\nD  (Data statement 1)\nD  (Data statement 2)\nD  (Data statement 3)\nD\nD  ./       NUMBER SEQ1=AA030,INSERT=YES\nD\nD  (Data statement 4)\nD  (Data statement 5)\nD  (Data statement 6)\nD  (Data statement 7, sequence number AA035)\nD\nD/*\nD//*                                           <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 and SYSUT2 DD define the partitioned data set PDS.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The CHANGE function statement identifies the input member RENUM. The\nN  entire member is listed in the message data set.\nN\nN  The NUMBER detail statements specify the insert operations\nN  (INSERT=YES) and control the renumbering operation as described\nN  below.\nN\nN  Data statements 1, 2, 3, and 4, 5, 6 are the blocks of logical\nN  records to be inserted. Because they contain blank sequence numbers,\nN  sequence numbers are assigned when the data statements are inserted.\nN\nN  Data statement 7, because it contains a sequence number, stops the\nN  insert operation. The sequence number is identical to the number on\nN  the next record in the old master data set; consequently, data\nN  statement 7 will replace the equally numbered old master record in\nN  the output data set.\nN\nN  The existing logical records in this example have sequence numbers\nN  AA010, AA015, AA020, AA025, AA030, AA035, AA040, AA045, AA050, BB010,\nN  and BB015. The insertion and renumbering operations are performed as\nN  follows:\nN\nN  1. Data statement 1 is assigned sequence number AA020 (NEW1=AA020)\nN     and inserted after existing logical record AA015 (SEQ1=AA015).\nN  2. Data statements 2 and 3 are assigned sequence numbers AA025 and\nN     AA030 (INCR=5) and are inserted after data statement 1.\nN  3. Existing logical records AA020, AA025, and AA030 are assigned\nN     sequence numbers AA035, AA040, and AA045, respectively.\nN  4. Data statement 4 is assigned sequence number AA050 and inserted.\nN     (The SEQ1=AA030 specification in the second NUMBER statement\nN     places this data statement after existing logical record AA030,\nN     which has become logical record AA045.)\nN  5. Data statements 5 and 6 are assigned sequence numbers AA055 and\nN     AA060 and are inserted after data statement 4.\nN  6. Existing logical record AA035 is replaced by data statement 7,\nN     which is assigned sequence number AA065.\nN  7. The remaining logical records in the member are renumbered until\nN     logical record BB010 is encountered. Because this record has a\nN     sequence number higher than the next number to be assigned, the\nN     renumbering operation is ended.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1109": {"ttr": 27399, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00F\\x00F\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:26", "lines": 70, "newlines": 70, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1109\nTdfp Utilities\nT-Chapter 11.\nT-Example 9: Create a Sequential Data Set from Card Input\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140126\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 9: Create a Sequential Data Set from Card Input\nN-------------------------------------------------------\nNIn this example, IEBUPDTE is used to create a sequential data set from\nNcard input. User header and trailer labels, also from the input stream,\nNare placed on this sequential data set.\nN\nD//LABEL    JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=NEW\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=LABEL,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(15,3))\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD *\nD  ./       LABEL\nD\nD  (Header labels)\nD\nD  ./       ADD LIST=ALL,OUTHDR=ROUTINE1,OUTTLR=ROUTINE2\nD\nD  (Data records)\nD\nD  ./       LABEL\nD\nD  (Trailer labels)\nD\nD  ./ ENDUP\nD/*\nD//*                                           <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT2 DD defines and allocates space for the output sequential data\nN  set, called LABEL, which resides on a disk volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream. (This control data set includes the sequential input data\nN  set and the user labels, which are on cards.)\nN\nN  The first LABEL statement identifies the 80-byte card images in the\nN  input stream which will become user header labels. (They can be\nN  modified by the user's header-label processing routine specified on\nN  the ADD function statement.)\nN\nN  The ADD function statement indicates that the data statements that\nN  follow are placed in the output data set. The newly created data set\nN  is listed in the message data set. User output header and output\nN  trailer routines are to be given control before the writing of header\nN  and trailer labels.\nN\nN  The second LABEL statement identifies the 80-byte card images in the\nN  input stream which will become user trailer labels. (They can be\nN  modified by the user's trailer-label processing routine specified on\nN  the ADD function statement.)\nN\nN  ENDUP signals the end of the control data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1110": {"ttr": 27401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x003\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:26", "lines": 51, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1110\nTdfp Utilities\nT-Chapter 11.\nT-Example 10: Copy Sequential Data Set from One Volume to Another\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140126\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 10: Copy Sequential Data Set from One Volume to Another\nN---------------------------------------------------------------\nNIn this example, IEBUPDTE is used to copy a sequential data set from\nNone DASD volume to another. User labels are processed by user exit\nNroutines.\nN\nD//LABELS   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=(MOD,,INTLRTN)\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=OLDMAST\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=NEWMAST,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(5,10))\nD//SYSIN     DD DISP=(SHR),DSN=INPUT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the input sequential data set, called OLDMAST,\nN  which resides on a disk volume.\nN\nN  SYSUT2 DD defines the output sequential data set, called NEWMAST,\nN  which will reside on a disk volume.\nN\nN  SYSIN DD defines the control data set. The contents of this\nN  disk-resident data set in this example are:\nI\nI  ./       REPRO LIST=ALL,INHDR=INHRTN,INTLR=INTRTN,                     C\nI  ./       OUTHDR=OUTHRTN,OUTTLR=OUTTRN\nI  ./       ENDUP\nI\nN  The REPRO function statement indicates that the existing input\nN  sequential data set is copied to the output data set. This output\nN  data set is listed on the message data set. The user's label\nN  processing routines are to be given control when header or trailer\nN  labels are encountered on either the input or the output data set.\nN\nN  ENDUP indicates the end of the control data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1111": {"ttr": 27403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x01\\x00D\\x00D\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:01:27", "lines": 68, "newlines": 68, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1111\nTdfp Utilities\nT-Chapter 11.\nT-Example 11: Create a New Partitioned Data Set\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140127\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 11. IEBUPDTE (Update Data Set) Program\nN----------------------------------------------\nNExample 11: Create a New Partitioned Data Set\nN---------------------------------------------\nNIn this example, a partitioned generation data set consisting of three\nNmembers is used as source data in the creation of a new partitioned\nNdata set. IEBUPDTE is also used to add a fourth member to the three\nNsource members and to number the new member. The resultant data set is\nNcataloged as a new partitioned data set.\nN\nD//NEWGDS   JOB ...\nD//ST01#01 EXEC PGM=IEBUPDTE,PARM=MOD\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),DSN=A.B.C\nD//SYSUT2    DD DISP=(NEW,CATLG),DSN=A.B.D,\nD//             UNIT=disk,\nD//             SPACE=(TRK,(100,10,10)),\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//*                                          <==== SHIFT THE DATA LEFT\nD//SYSIN     DD DATA\nD  ./       REPRO  NAME=MEM1,LEVEL=00,SOURCE=0,LIST=ALL\nD  ./       REPRO  NAME=MEM2,LEVEL=00,SOURCE=0,LIST=ALL\nD  ./       REPRO  NAME=MEM3,LEVEL=00,SOURCE=0,LIST=ALL\nD  ./       ADD    NAME=MEM4,LEVEL=00,SOURCE=0,LIST=ALL\nD  ./       NUMBER NEW1=10,INCR=5\nD\nD  (Data records comprising MEM4)\nD\nD  ./       ENDUP\nD/*\nD//                                           <==== SHIFT THE DATA LEFT\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the partitioned data set, which is used as source\nN  data. It can be a PDSE.\nN\nN  SYSUT2 DD defines the new partitioned data set, which is created\nN  from the source partitioned data set and from an additional member\nN  included as input and data. It can be a PDSE.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The REPRO function statements reproduce the named source members in\nN  the output partitioned data set.\nN\nN  The ADD function statement specifies that the data records following\nN  the input stream be included as MEM4.\nN\nN  The NUMBER detail statement indicates that the new member is to have\nN  sequence numbers assigned in columns 73 through 80. The first record\nN  is assigned sequence number 10. The sequence number of each\nN  successive record is increased by 5.\nN\nN  ENDUP signals the end of input card data.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU12": {"ttr": 27405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x02\\x00-\\x00-\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:02:34", "lines": 45, "newlines": 45, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU12\nTdfp Utilities\nT-Chapter 12. IEHINITT (Initialize Tape) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140234\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 1: Write EBCDIC Labels on Three Tapes\nNExample 2: Write an ISO/ANSI Label on a Tape 246\nNExample 3: Place Two Groups of Serial Numbers on Six Tape Volumes\nNExample 4: Place Serial Number on Eight Tape Volumes\nNExample 5: Write EBCDIC Labels in Different Densities\nNExample 6: Write Serial Numbers on Tape Volumes at Two Densities\nNExample 7: Write an ISO/ANSI Label with an Access Code\nNExample 8: Write on a tape following labeling without demounting\nN           and remounting\nNExample 9: Rekey one tape volume\nNExample 10: Multiple tapes specified for SER keyword\nNExample 11: Three tapes with NUMBTAPE specified\nNExample 12: Multiple REKEY Control Statements\nNExample 13: Multiple Control Statements with NUMBTAPE\nNExample 14: Printout of INITT Statement Specifications and\nN            Initial Volume Label Information\nN\nNReturn Codes Meaning\nN------------ ----------------------------------------------------------\nN00 (X'00')   Successful completion. A message data set was created.\nN04 (X'04')   Successful completion. No message data set was defined by\nN             the user.\nN08 (X'08')   IEHINITT completed its operation, but error conditions\nN             were encountered during processing. A message data set\nN             was created.\nN12 (X'0C')   IEHINITT completed its operation, but error conditions\nN             were encountered during processing. No message data set\nN             was defined by the user.\nN16 (X'10')   IEHINITT ended operation because of error conditions\nN             encountered while attempting to read the control data set.\nN             A message data set was created if defined by the user.\nN------------ ----------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1201": {"ttr": 27407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x005\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x02\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:02:35", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1201\nTdfp Utilities\nT-Chapter 12.\nT-Example 1: Write EBCDIC Labels on Three Tapes\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140235\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 1: Write EBCDIC Labels on Three Tapes\nN---------------------------------------------\nNIn this example, serial numbers 001234, 001235 and 001236 are placed on\nNthree tape volumes. The labels are written in EBCDIC at 800 bits per\nNinch. Each volume labeled is mounted, when it is required, on a single\nN9-track tape unit.\nN\nD//LABEL1   JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//LABEL     DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=2\nD//SYSIN     DD *\nDLABEL    INITT SER=001234,NUMBTAPE=3\nD/*\nN\nNThe control statements are discussed below:\nN\nN  LABEL DD defines the tape unit used in the labeling operation.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  LABEL INITT specifies the number of tapes to be labeled (3),\nN  beginning with 001234.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1202": {"ttr": 27409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x02\\x00)\\x00)\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:02:35", "lines": 41, "newlines": 41, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1202\nTdfp Utilities\nT-Chapter 12.\nT-Example 2: Write an ISO/ANSI Label on a Tape\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140235\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 2: Write an ISO/ANSI Label on a Tape\nN--------------------------------------------\nNIn this example, serial number 001001 is placed on one ISO/ANSI tape\nNvolume; the label is written at 800 bits per inch. The volume labeled\nNis mounted, when it is required, on a 9-track tape unit.\nN\nD//LABEL2   JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//ASCIILAB  DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=2\nD//SYSIN     DD *\nDASCIILAB INITT SER=001001,OWNER='SAM A. BROWN',LABTYPE=AL\nD/*\nN\nNThe control statements are discussed below:\nN\nN  ASCIILAB DD defines the tape volume to be used in the labeling\nN  operation.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  ASCIILAB INITT specifies the serial number, owner ID and label type\nN  for the volume.Because the VERSION keyword was not specified, the\nN  ISO/ANSI tape will be created based on what is specified in the\nN  DEVSUPxx parmlib member or as a version 3 by default.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1203": {"ttr": 27649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x005\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x02\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:02:35", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1203\nTdfp Utilities\nT-Chapter 12.\nT-Example 3: Place Two Groups of Serial Numbers on Six Tape Volumes\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140235\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 3: Place Two Groups of Serial Numbers on Six Tape Volumes\nN-----------------------------------------------------------------\nNIn this example, two groups of serial numbers (001234, 001235, 001236,\nNand 001334, 001335, 001336) are placed on six tape volumes. The labels\nNare written in EBCDIC at 800 bits per inch. Each volume labeled is\nNmounted, when it is required, on a single 9-track tape unit.\nN\nD//LABEL3   JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//LABEL     DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=2\nD//SYSIN     DD *\nDLABEL    INITT SER=001234,NUMBTAPE=3\nDLABEL    INITT SER=001334,NUMBTAPE=3\nD/*\nN\nNThe control statements are discussed below:\nN\nN  LABEL DD defines the tape unit to be used in the labeling operation.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  LABEL INITT defines the two groups of serial numbers to be put on\nN  six tape volumes.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1204": {"ttr": 27651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x02\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:02:36", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1204\nTdfp Utilities\nT-Chapter 12.\nT-Example 4: Place Serial Number on Eight Tape Volumes\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140236\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 4: Place Serial Number on Eight Tape Volumes\nN----------------------------------------------------\nNIn this example, serial numbers 001234, 001244, 001254, 001264, 001274,\nNand so forth, are placed on eight tape volumes. The labels are written\nNin EBCDIC at 800 bits per inch. Each volume labeled is mounted, when it\nNis required, on one of four 9-track tape units.\nN\nD//LABEL4   JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//LABEL     DD UNIT=(tape,4,DEFER),\nD//             DCB=DEN=2\nD//SYSIN     DD *\nDLABEL    INITT SER=001234\nDLABEL    INITT SER=001244\nDLABEL    INITT SER=001254\nDLABEL    INITT SER=001264\nDLABEL    INITT SER=001274\nDLABEL    INITT SER=001284\nDLABEL    INITT SER=001294\nDLABEL    INITT SER=001304\nD/*\nN\nNThe control statements are discussed below:\nN\nN  LABEL DD defines the tape unit used in the labeling operation.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The LABEL INITT statements define the tapes to be labeled by volume\nN  serial number.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1205": {"ttr": 27653, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x02\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:02:36", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1205\nTdfp Utilities\nT-Chapter 12.\nT-Example 5: Write EBCDIC Labels in Different Densities\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140236\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 5: Write EBCDIC Labels in Different Densities\nN-----------------------------------------------------\nNIn this example, serial number TAPE1 is placed on a tape volume, and\nNserial numbers 001234 and 001235 are placed on two tape volumes. The\nNlabels are written in EBCDIC at 800 and 1600 bits per inch,\nNrespectively.\nN\nD//LABEL5   JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//LABEL1    DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=2\nD//LABEL2    DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=3\nD//SYSIN     DD *\nDLABEL1    INITT SER=TAPE1\nDLABEL2    INITT SER=001234,NUMBTAPE=2\nD/*\nN\nNThe control statements are discussed below:\nN\nN  LABEL1 DD and LABEL2 DD  define two tape volumes to be used in the\nN  labeling operation.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  LABEL1 INITT places the serial number TAPE1 on the tape volume\nN  defined in LABEL1 DD. LABEL2 INITT places the serial numbers 001234\nN  and 001235 on the tape volume defined in LABEL2 DD.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1206": {"ttr": 27655, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x03\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:03", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1206\nTdfp Utilities\nT-Chapter 12.\nT-Example 6: Write Serial Numbers on Tape Volumes at Two Densities\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140303\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 6: Write Serial Numbers on Tape Volumes at Two Densities\nN----------------------------------------------------------------\nNIn this example, the serial number 006250 is written in EBCDIC on a\nNtape volume at a density of 6250 bpi, and the serial number 001600 is\nNwritten in EBCDIC on a second volume at a density of 1600 bpi.\nN\nD//LABEL6   JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//DDFIRST   DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=4\nD//DDSECOND  DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=3\nD//SYSIN     DD *\nDDDFIRST  INITT SER=006250\nDDDSECOND INITT SER=001600\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DDFIRST DD defines the first tape volume to be used.\nN\nN  DDSECOND DD defines the second tape volume to be used.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  DDFIRST INITT writes the serial number 006250 on the volume defined\nN  in DDFIRST DD. DDSECOND INITT writes the serial number 001600 on the\nN  volume defined in DDSECOND DD.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1207": {"ttr": 27657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:04", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1207\nTdfp Utilities\nT-Chapter 12.\nT-Example 7: Write an ISO/ANSI Label with an Access Code\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140304\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 7: Write an ISO/ANSI Label with an Access Code\nN------------------------------------------------------\nNIn this example, a version 4 ISO/ANSI (AL) labeled tape is created with\nNa nonblank access code. The volume serial number is TAPE01.\nN\nD//LABEL7   JOB ...\nD//STEP1   EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//LABEL     DD UNIT=(tape,1,DEFER),\nD//             DCB=DEN=4\nD//SYSIN     DD *\nDLABEL    INITT SER=TAPE01,OWNER=TAPOWNER,LABTYPE=AL,ACCESS=A,VERSION=4\nD/*\nN\nNThe control statements are discussed below:\nN\nN  LABEL DD defines the device on which the tape is mounted.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The INITT statement creates a Version 4 ISO/ANSI label for the tape\nN  with volume serial number TAPE01, owned by TAPOWNER. The ACCESS code\nN  is specified as \"A\", and the operating system that receives this\nN  volume must be able to recognize the \"A\" in order for the volume to\nN  be accepted.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1208": {"ttr": 27659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00-\\x00-\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:04", "lines": 45, "newlines": 45, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1208\nTdfp Utilities\nT-Chapter 12.\nT-Example 8: Write on a tape following labeling without\nTdemounting and remounting\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140304\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 8: Write on a tape following labeling without\nNdemounting and remounting\nN-----------------------------------------------------\nNIn this example, you can label a tape in one step of a job, and then,\nNwithout the system demounting and remounting that tape between steps,\nNwrite to the tape in a subsequent step of the same job. The necessary\nNJCL code follows:\nN\nD//ST01#02 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=*\nD//LABEL     DD DISP=(,PASS),UNIT=(tape,1,DEFER)     (*1)\nD//SYSIN     DD *\nDLABEL    INITT SER=serial,DISP=REWIND               (*2)\nD//*\nD//ST02#02 EXEC PGM=user_program\nD//INPUT     DD DISP=SHR,DSN=input_dsn,DISP=SHR\nD//OUTPUT    DD DISP=(NEW,CATLG),DSN=dsname,\nD//             UNIT=tape,\nD//             VOL=(,RETAIN,SER=serial),            (*3)\nD//             DCB=(dcbinfo)\nI\nI  Notes:\nI  (1) Either DISP=(NEW,PASS) or VOL=(,RETAIN) must be specified.\nI  (2) DISP=REWIND must be specified on the INITT statement.\nI  (3) VOL=SER=serial must be specified. VOL=REF=*.STEP1.LABEL will not\nI      work.\nM\nM  Magic: While DISP=REWIND does reposition the tape, it is\nM         the UNIT=(,,DEFER) that prevents dismounting the tape.\nM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1209": {"ttr": 27661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x04\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:04", "lines": 28, "newlines": 28, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1209\nTdfp Utilities\nT-Chapter 12.\nT-Example 9: Rekey one tape volume\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140304\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 9: Rekey one tape volume\nN--------------------------------\nNIn this example, one tape volume SL1000 is to be rekeyed with\nNtwo key labels.\nN\nD//TAPEJOB  JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=A\nD//REKEY1    DD UNIT=(TAPE,1,DEFER)\nD//SYSIN     DD *\nDREKEY1 REKEY SER=SL1000,\nDKEYLABL1=firstkeylabel,KEYENCD1=L,\nDKEYLABL2=secondkeylabel,KEYENCD2=H\nD/*\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1210": {"ttr": 27663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:05", "lines": 28, "newlines": 28, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1210\nTdfp Utilities\nT-Chapter 12.\nT-Example 10: Multiple tapes specified for SER keyword\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140305\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 10: Multiple tapes specified for SER keyword\nN----------------------------------------------------\nNIn this example, five tape volumes are to be rekeyed\nNwith the same key labels.\nN\nD//TAPEJOB  JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=A\nD//REKEY2    DD UNIT=(TAPE,1,DEFER)\nD//SYSIN     DD *\nDREKEY2 REKEY SER=( AL1000,AL2000,AL3000,AL4000,AL5000),\nDKEYLABL1=firstkeylabel,KEYENCD1=L,\nDKEYLABL2=secondkeylabel,KEYENCD2=H\nD/*\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1211": {"ttr": 27665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00\\x1c\\x00\\x1c\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:05", "lines": 28, "newlines": 28, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1211\nTdfp Utilities\nT-Chapter 12.\nT-Example 11: Three tapes with NUMBTAPE specified\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140305\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 11: Three tapes with NUMBTAPE specified\nN-----------------------------------------------\nIn this example, three tape volumes 001200, 001201,\nNand 001202 are to be rekeyed with the same key labels.\nN\nD//TAPEJOB  JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=A\nD//REKEY3    DD UNIT=(TAPE,1,DEFER)\nD//SYSIN     DD *\nDREKEY3 REKEY SER=001200,NUMBTAPE=3,\nDKEYLABL1=firstkeylabel,KEYENCD1=L,\nDKEYLABL2=secondkeylabel,KEYENCD2=H\nD/*\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1212": {"ttr": 27667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00!\\x00!\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:05", "lines": 33, "newlines": 33, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1212\nTdfp Utilities\nT-Chapter 12.\nT-Example 12: Multiple REKEY Control Statements\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140305\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 12: Multiple REKEY Control Statements\nN---------------------------------------------\nIn this example, two tape volumes, 005000, and\nNSL8000, are to be rekeyed. Each tape volume is to be\nNrekeyed with different set of key labels and encoding\nNmechanisms.\nN\nD//TAPEJOB  JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=A\nD//REKEY4    DD UNIT=(TAPE,1,DEFER)\nD//REKEY5    DD UNIT=(TAPE)\nD//SYSIN     DD *\nDREKEY4 REKEY SER=005000, KEYLABL1=firstkeylabel,KEYENCD1=L,\nDKEYLABL2=secondkeylabel,KEYENCD2=H\nDREKEY5 REKEY SER=SL8000,\nDKEYLABL1=differentfirstkeylabel,KEYENCD1=L,\nDKEYLABL2=differentsecondkeylabel,KEYENCD2=H\nD/*\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1213": {"ttr": 27669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00%\\x00%\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:05", "lines": 37, "newlines": 37, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1213\nTdfp Utilities\nT-Chapter 12.\nT-Example 13: Multiple Control Statements with NUMBTAPE\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140305\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 13: Multiple Control Statements with NUMBTAPE\nN-----------------------------------------------------\nNIn this example, three tape volumes 001200, 001201,\nNand 001202 are to be rekeyed with the same key labels specified\nNfor the first REKEY control statement with NUMBTAPE specified.\nNThe second control statement specifies one tape SL8000 to\nNbe rekeyed with different key labels. Note, that KEYLABL2 and\nNits associated KEYENCD2 are omitted, thus the same key label and\nNencoding mechanism values specified for the KEYLABL1 and the\nNKEYENCD1 keywords are used for both key labels.\nN\nD//TAPEJOB  JOB ...\nD//ST01#01 EXEC PGM=IEHINITT\nD//SYSPRINT  DD SYSOUT=A\nD//REKEY6    DD UNIT=(TAPE,1,DEFER)\nD//REKEY7    DD UNIT=(TAPE)\nD//SYSIN     DD *\nDREKEY6 REKEY SER=001200,NUMBTAPE=3,\nDKEYLABL1=firstkeylabel,KEYENCD1=L,\nDKEYLABL2=secondkeylabel,KEYENCD2=H\nDREKEY7 REKEY SER=SL8000,\nDKEYLABL1=differentfirstkeylabel,KEYENCD1=L,\nD/*\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1214": {"ttr": 27671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00(\\x00(\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:05", "lines": 40, "newlines": 40, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1214\nTdfp Utilities\nT-Chapter 12.\nT-Example 14: Printout of INITT Statement Specifications and Initial\nNVolume Label Information\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140305\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 12. IEHINITT (Initialize Tape) Program\nN----------------------------------------------\nNExample 14: Printout of INITT Statement Specifications and Initial\nNVolume Label Information\nN------------------------------------------------------------------\nNIn this example, a printout appears of a message data set including\nNthe INITT statement and initial volume label information. One INITT\nNstatement was used to place serial numbers 001122 and 001123 on two\nNstandard label tape volumes. VOL1001122 and VOL1001123 are interpreted\nNas follows:\nI\nI VOL1 indicates that an initial volume label was successfully\nI written to a tape volume.\nI\nI   001122 and 001123 are the serial numbers that were written\nI   onto the volumes.\nI\nI   A blank space following the serial number represents the Volume\nI   Security field, which is not used during OPEN/CLOSE/EOV processing\nI   on a standard label tape.\nI\nI   No errors occurred during processing.\nI\nI   SYSTEM SUPPORT UTILITIES IEHINITT\nI   ALL INITT SER=001122,NUMBTAPE=2,OWNER='P.T.BROWN',DISP=REWIND\nI   VOL1001122 P.T.BROWN\nI   VOL1001123 P.T.BROWN\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU13": {"ttr": 27673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00\\x19\\x00\\x19\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:31", "lines": 25, "newlines": 25, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU13\nTdfp Utilities\nT-Chapter 13. IEHLIST (List System Data) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140331\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 13. IEHLIST (List System Data) Program\nN----------------------------------------------\nNExample 1: List Partitioned Directories Using DUMP and FORMAT\nNExample 2: List Non-indexed Volume Table of Contents\nN\nNReturn Codes Meaning\nN------------ ----------------------------------------------------------\nN00 (X'00')   Successful completion.\nN08 (X'08')   An error condition caused a specified request to be\nN             ignored. Processing continues.\nN12 (X'0C')   A permanent input/output error occurred. The job is ended.\nN16 (X'10')   An unrecoverable error occurred while reading the data\nN             set. The job is ended.\nN------------ ----------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1301": {"ttr": 27905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x003\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:31", "lines": 51, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1301\nTdfp Utilities\nT-Chapter 13.\nT-Example 1: List Partitioned Directories Using DUMP and FORMAT\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140331\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 13. IEHLIST (List System Data) Program\nN----------------------------------------------\nNExample 1: List Partitioned Directories Using DUMP and FORMAT\nN-------------------------------------------------------------\nNIn this example, the directory of a PDSE is listed. In addition, the\nNdirectories of two partitioned data sets that reside on the system\nNresidence volume are listed.\nN\nD//LISTPDIR JOB ...\nD//ST01#01 EXEC PGM=IEHLIST\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD DISP=OLD,\nD//             UNIT=diskA,\nD//             VOL=SER=222222\nD//DD2       DD DISP=OLD,\nD//             UNIT=diskB,\nD//             VOL=REF=SYS1.NUCLEUS\nD//SYSIN     DD *\nDLISTPDS  DSNAME=D42.PDSE1,VOL=diskA=222222\nDLISTPDS  DSNAME=(D55.PART1,D55.PART2),FORMAT\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DD1 DD defines the system residence device.\nN\nN  DD2 DD defines a device on which a disk volume (222222) is mounted.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The first LISTPDS statement indicates that the PDSE directory\nN  belonging to data set D42.PDSE1 is to be listed. The listing is in\nN  unedited (dump) format. This data set resides on volume 222222.\nN\nN  The second LISTPDS statement indicates that partitioned data set\nN  directories belonging to data sets D55.PART1 and D55.PART2 are to be\nN  listed. The listing is in edited format. These data sets exist on\nN  the system residence volume.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1302": {"ttr": 27907, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00.\\x00.\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:31", "lines": 46, "newlines": 46, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1302\nTdfp Utilities\nT-Chapter 13.\nT-Example 2: List Non-indexed Volume Table of Contents\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140331\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 13. IEHLIST (List System Data) Program\nN----------------------------------------------\nNExample 2: List Non-indexed Volume Table of Contents\nN----------------------------------------------------\nNIn this example, a non-indexed volume table of contents is listed in\nNthe first edited format. The edited listing is supplemented by an\nNunedited listing of selected data set control blocks.\nN\nD//VTOCLIST JOB ...\nD//ST01#01 EXEC PGM=IEHLIST\nD//SYSPRINT  DD SYSOUT=*\nD//DD2       DD DISP=OLD,\nD//             UNIT=disk,\nD//             VOL=SER=111111\nD//SYSIN     DD *\nDLISTVTOC FORMAT,VOL=disk=111111\nDLISTVTOC DUMP,VOL=disk=111111,DSNAME=(SET1,SET2,SET3)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DD2 DD defines a device containing the specified volume table of\nN  contents.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  The first LISTVTOC statement indicates that the volume table of\nN  contents on the specified disk volume is to be listed in edited\nN  form.\nN\nN  The second LISTVTOC statement indicates that the data set control\nN  blocks representing data sets SET1, SET2, and SET3 are to be listed\nN  in unedited form.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU14": {"ttr": 27909, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x03\\x00\"\\x00!\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:03:57", "lines": 34, "newlines": 33, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU14\nTdfp Utilities\nT-Chapter 14. IEHMOVE (Move System Data) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140357\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nNExample 1: Move Sequential Data Sets from Disk Volume to\nN           Separate Volumes\nNExample 2: Move Partitioned Data Set to Disk Volume and Merge\nNExample 3: Move Volume of Data Sets to Disk Volume\nNExample 4: Move Partitioned Data Set to Allocated Space\nNExample 5: Move and Unload Partitioned Data Sets Volume\nNExample 6: Unload Sequential Data Set onto Unlabeled Tape Volume\nNExample 7: Load Unloaded Sequential Data Sets from Labeled Tape\nNExample 8: Move Cataloged Data Set Group\nN\nNReturn Code Meaning\nN----------- ---------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   A specified function was not completely successful.\nN             Processing continues.\nN08 (X'08')   A condition exists from which recovery is possible.\nN             Processing continues.\nN12 (X'0C')   An unrecoverable error exists. The utility is ended.\nN16 (X'10')   It is impossible to OPEN the SYSIN or SYSPRINT data set.\nN             The utility is ended.\nN----------- ---------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1401": {"ttr": 27911, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x000\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x00>\\x00=\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:30", "lines": 62, "newlines": 61, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1401\nTdfp Utilities\nT-Chapter 14.\nT-Example 1: Move Sequential Data Sets from Disk Volume to Separate Volumes\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140430\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nNExample 1: Move Sequential Data Sets from Disk Volume to\nN           Separate Volumes\nN-----------------------------------------------------------------------\nNIn this example, three sequential data sets (SEQSET1, SEQSET2, and\nNSEQSET3) are moved from a disk volume to three separate disk volumes.\nNEach of the three receiving volumes is mounted when it is required by\nNIEHMOVE. The source data sets are not cataloged. Space is allocated by\nNIEHMOVE.\nN\nD//MOVEDS   JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=333333\nD//DD1       DD DISP=(OLD),UNIT=(disk,,DEFER),\nD//             VOL=(PRIVATE,,SER=(222222))\nD//DD2       DD DISP=(OLD),UNIT=(disk,,DEFER),\nD//             VOL=(PRIVATE,,SER=(222333))\nD//DD3       DD DISP=(OLD),UNIT=(disk,,DEFER),\nD//             VOL=(PRIVATE,,SER=(222444))\nD//DD4       DD DISP=(OLD),UNIT=(disk,,DEFER),\nD//             VOL=(PRIVATE,RETAIN,SER=(444444))\nD//SYSIN     DD *\nDMOVE     DSNAME=SEQSET1,TO=disk=222222,FROM=disk=444444\nDMOVE     DSNAME=SEQSET2,TO=disk=222333,FROM=disk=444444\nDMOVE     DSNAME=SEQSET3,TO=disk=222444,FROM=disk=444444\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the disk device that is to contain the\nN  work data set.\nN\nN  DD1, DD2, and DD3 DD define the receiving volumes.\nN\nN  DD4 DD defines a device on which the source volume is mounted.\nN  Because the RETAIN subparameter is included, the volume remains\nN  mounted until the job has completed.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE moves the source data sets to volumes 222222, 222333, and\nN  222444, respectively. The source data sets are scratched.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1402": {"ttr": 27913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x000\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x00:\\x00:\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:30", "lines": 58, "newlines": 58, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1402\nTdfp Utilities\nT-Chapter 14.\nT-Example 2: Move Partitioned Data Set to Disk Volume and Merge\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140430\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nNExample 2: Move Partitioned Data Set to Disk Volume and Merge\nN-------------------------------------------------------------\nNIn this example, a partitioned data set (PARTSET1) is moved to a disk\nNvolume. In addition, a member (PARMEM3) from another partitioned data\nNset (PARTSET2) is merged with the source members on the receiving\nNvolume. The source partitioned data set (PARTSET1) is scratched. Space\nNis allocated by IEHMOVE.\nN\nD//MOVEPDS  JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=333000\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222111\nD//DD3       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD4       DD DISP=(OLD),UNIT=disk,VOL=SER=222333\nD//SYSIN     DD *\nD          MOVE PDS=PARTSET1,TO=disk=222333,FROM=disk=222111\nD       INCLUDE DSNAME=PARTSET2,MEMBER=PARMEM3,FROM=disk=222222\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the disk volume that is to contain the work data\nN  set.\nN\nN  DD1 DD defines the system residence device.\nN\nN  The DD2, DD3, and DD4 DD statements define devices that are to\nN  contain the two source volumes and the receiving volume.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE defines the source partitioned data set, the volume that\nN  contains it, and its receiving volume.\nN\nN  INCLUDE includes a member from a second partitioned data set in the\nN  operation.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1403": {"ttr": 27915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x008\\x008\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:31", "lines": 56, "newlines": 56, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1403\nTdfp Utilities\nT-Chapter 14.\nT-Example 3: Move Volume of Data Sets to Disk Volume\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140431\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nMA SECURITY PACKAGE IS A BETTER WAY TO PROTECT ACCESS THAN PASSWORDS.\nM\nNExample 3: Move Volume of Data Sets to Disk Volume\nN--------------------------------------------------\nNIn this example, a volume of data sets is moved to a disk volume. All\nNdata sets that are successfully moved are scratched from the source\nNvolume; however, any catalog entries pertaining to those data sets are\nNnot changed. Space is allocated by IEHMOVE.\nN\nD//MOVEVOL  JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD3       DD DISP=(OLD),UNIT=disk,VOL=SER=333333\nD//SYSIN     DD *\nD          MOVE VOLUME=disk=333333,TO=disk=222222,PASSWORD\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the device that is to contain the work data set.\nN\nN  DD1 DD defines the system residence device.\nN\nN  DD2 DD defines the device on which the receiving volume is mounted.\nN\nN  DD3 DD defines a device on which the source volume is mounted.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE specifies a move operation for a volume of data sets and\nN  defines the source and receiving volumes. This statement also\nN  indicates that password-protected data sets are included in the\nN  operation.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1404": {"ttr": 27917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x004\\x004\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:31", "lines": 52, "newlines": 52, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1404\nTdfp Utilities\nT-Chapter 14.\nT-Example 4: Move Partitioned Data Set to Allocated Space\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140431\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nNExample 4: Move Partitioned Data Set to Allocated Space\nN-------------------------------------------------------\nNIn this example, a partitioned data set is moved to a disk volume on\nNwhich space has been previously allocated for the data set. The source\nNdata set is scratched.\nN\nD//MOVEPDS  JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD3       DD DISP=(OLD),UNIT=disk,VOL=SER=333333\nD//SYSIN     DD *\nD          MOVE PDS=PDSSET1,TO=disk=222222,FROM=disk=333333\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the device that is to contain the work data set.\nN\nN  DD1 DD defines the system residence device.\nN\nN  DD2 DD defines the device on which the receiving volume is to be\nN  mounted.\nN\nN  DD3 DD defines a device on which the source volume is mounted.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE specifies a move operation for the partitioned data set PDSSET1\nN  and defines the source and receiving volumes.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1405": {"ttr": 27919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x00J\\x00J\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:31", "lines": 74, "newlines": 74, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1405\nTdfp Utilities\nT-Chapter 14.\nT-Example 5: Move and Unload Partitioned Data Sets Volume\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140431\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nNExample 5: Move and Unload Partitioned Data Sets Volume\nN-------------------------------------------------------\nNIn this example, three partitioned data sets are moved from three\nNseparate source volumes to a disk volume. The source data set PDSSET3\nNis unloaded. (The record size exceeds the track capacity of the\nNreceiving volume.)\nN\nD//MOVEPDS  JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=(disk,,DEFER)\nD//             VOL=(PRIVATE,,SER=(333333))\nD//DD3       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//SYSIN     DD *\nD          MOVE PDS=PDSSET1,TO=disk=222222,FROM=disk=333333\nD          MOVE PDS=PDSSET2,TO=disk=222222,FROM=disk=222222\nD          MOVE PDS=PDSSET3,TO=disk=222222,FROM=disk=444444,UNLOAD\nD/*\nI\nINOTE:\nI\nI   PDSSET1, PDSSET2, and PDSSET3 are already allocated on the receiving\nI   volume. PDSSET3 is allocated as a sequential data set; PDSSET1 and\nI   PDSSET2 are allocated as partitioned data sets. Since PDSSET3 is\nI   moved to a sequential data set, it is unloaded.\nI\nI   For a discussion of estimating space allocations, see\nI   z/OS DFSMS: Using Data Sets.\nI\nI   The DCB attributes of PDSSET3 are:\nI\nI   DCB=(RECFM=U,BLKSIZE=5000)\nI\nI   The unloaded attributes are:\nI\nI   DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\nI\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the device that is to contain the work data set.\nN\nN  DD1 DD defines the system residence device.\nN\nN  DD2 DD defines a device on which the source volumes are mounted as\nN  they are required.\nN\nN  DD3 DD defines a device on which the receiving volume is mounted.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE specifies move operations for the partitioned data sets and\nN  defines the source and receiving volumes for each data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1406": {"ttr": 27921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x009\\x009\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:31", "lines": 57, "newlines": 57, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1406\nTdfp Utilities\nT-Chapter 14.\nT-Example 6: Unload Sequential Data Set onto Unlabeled Tape Volume\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140431\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nNExample 6: Unload Sequential Data Set onto Unlabeled Tape Volume\nN----------------------------------------------------------------\nNIn this example, a sequential data set is unloaded onto a 9-track,\nNunlabeled tape volume (800 bits per inch).\nN\nD//UNLOAD   JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//TAPEOUT   DD DISP=(NEW,CATLG),DSN=NEW.TAPE,\nD//             UNIT=tape,\nD//             VOL=SER=SCRCH2,\nD//             DCB=(RECFM=FB,BLKSIZE=0,LRECL=80)\nD//SYSIN     DD *\nD          MOVE DSNAME=SEQSET1,TO=tape=SCRCH2,FROM=disk=222222,         X\nD               TODD=TAPEOUT\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the device that is to contain the work data set.\nN\nN  DD1 DD defines the system residence device.\nN\nN  DD2 DD defines a device on which the source volume is mounted.\nN\nN  TAPEOUT DD defines a device on which the receiving tape volume is\nN  mounted. This statement also provides label and mode information.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE moves the sequential data set SEQSET1 from a disk volume to the\nN  receiving tape volume. The data set is unloaded. The TODD parameter\nN  in this statement refers to the TAPEOUT DD statement for label and\nN  mode information.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1407": {"ttr": 28161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x00@\\x00@\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:32", "lines": 64, "newlines": 64, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1407\nTdfp Utilities\nT-Chapter 14.\nT-Example 7: Load Unloaded Sequential Data Sets from Labeled Tape\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140431\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nNExample 7: Load Unloaded Sequential Data Sets from Labeled Tape\nN---------------------------------------------------------------\nNIn this example, three unloaded sequential data sets are loaded from a\nNlabeled, 7-track tape volume (556 bits per inch) to a disk volume.\nNSpace is allocated by IEHMOVE. The example assumes that the disk volume\nNis capable of supporting the data sets in their original forms.\nN\nD//LOAD     JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//TAPESETS  DD DISP=(OLD),\nD//             UNIT=tape,LABEL=(1,SL),\nD//             VOL=SER=001234,\nD//             DCB=(DEN=1,TRTCH=C)\nD//SYSIN     DD *\nD          MOVE DSNAME=UNLDSET1,T0=disk=222222,                         X\nD               FROM=tape=(001234,1),FROMDD=TAPESETS\nD          MOVE DSNAME=UNLDSET2,TO=disk=222222,                         X\nD               FROM=tape=(001234,2),FROMDD=TAPESETS\nD          MOVE DSNAME=UNLDSET3,TO=disk=222222,                         X\nD               FROM=tape=(001234,3),FROMDD=TAPESETS\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the device that is to contain the work data set.\nN\nN  DD1 DD defines the system residence device.\nN\nN  DD2 DD defines a device on which the receiving volume is mounted.\nN\nN  TAPESETS DD defines a device on which the source tape volume is\nN  mounted. DCB information is provided in this statement.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE moves the unloaded data sets to the receiving volume.\nN\nITo move a data set from a tape volume that contains more than one data\nIset, you must specify the sequence number of the data set in the list\nIfield of the FROM parameter on the utility control statement.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1408": {"ttr": 28163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x04\\x00D\\x00D\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:04:32", "lines": 68, "newlines": 68, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1408\nTdfp Utilities\nT-Chapter 14.\nT-Example 8: Move Cataloged Data Set Group\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140432\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 14. IEHMOVE (Move System Data) Program\nN----------------------------------------------\nMDFSMSdss should be used instead of IEHMOVE to move or copy data to\nMvolumes managed by the Storage Management Subsystem. DFSMSdss or\nMIEBCOPY should be used to process PDSEs. You cannot use IEHMOVE with\nMPDSEs, ISAM, or VSAM data sets.\nM\nNExample 8: Move Cataloged Data Set Group\nN----------------------------------------\nNIn this example, the cataloged data set group A.B.C, which comprises\nNdata set A.B.C.X, A.B.C.Y, and A.B.C.Z, ,is moved from two disk volumes\nNonto a third volume. Space is allocated by IEHMOVE. The catalog is\nNupdated to refer to the receiving volume. The source data sets are\nNscratched.\nN\nD//MOVEDSG  JOB ...\nD//ST01#01 EXEC PGM=IEHMOVE\nD//SYSPRINT  DD SYSOUT=*\nD//SYSUT1    DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//DD3       DD DISP=(OLD),UNIT=disk,VOL=SER=333333\nD//DD4       DD DISP=(OLD),UNIT=disk,VOL=SER=444444\nD//SYSIN     DD *\nD          MOVE DSGROUP=A.B.C,TO=disk=222222\nD/*\nN\nNThe control statements are discussed below:\nN\nN  SYSUT1 DD defines the device that is to contain the work data set.\nN\nN  DD1 DD defines the system residence device.\nN\nN  DD2 DD defines a device on which the receiving volume is mounted.\nN\nN  DD3 DD defines a device on which one of the source volumes is\nN  mounted.\nN\nN  DD4 DD defines a device on which one of the source volumes is\nN  mounted.\nN\nN  SYSIN DD defines the control data set, which follows in the input\nN  stream.\nN\nN  MOVE moves the specified data sets to volume 222222.\nI\nIThis example can be used to produce the same result without the use of\nIthe DD4 DD statement, using one less mountable disk device. With DD3\nIand DD4, both of the source volumes are mounted at the start of the\nIjob. With DD3 only, the 333333 volume is mounted at the start of the\nIjob. After the 333333 volume is processed, the utility requests that\nIthe operator mount the 444444 volume. In this case, the DD3 statement\nIis coded:\nI\nD//DD3       DD DISP=(OLD),UNIT=(disk,,DEFER),\nD//             VOL=(PRIVATE,,SER=(333333))\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU15": {"ttr": 28165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x10\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00#\\x00#\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:10", "lines": 35, "newlines": 35, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU15\nTdfp Utilities\nT-Chapter 15. IEHPROGM (Program Maintenance) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140510\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nNExample 1: Scratch Temporary System Data Sets 307\nNExample 2: Scratch and Uncatalog Two Data Sets\nNExample 3: Rename a Multi-Volume Data Set Catalog\nNExample 4: Uncatalog Three Data Sets\nNExample 5: Rename a Data Set and Define New Passwords\nNExample 6: List and Replace Password Information\nNExample 7: Rename a Partitioned Data Set Member\nI\nNReturn Codes Meaning\nN------------ ----------------------------------------------------------\nN00 (X'00')   Successful completion.\nN04 (X'04')   A syntax error was found in the name field of the control\nN             statement or in the PARM field in the EXEC statement.\nN             Processing continues.\nN08 (X'08')   A request for a specific operation was ignored because of\nN             an incorrect control statement or an otherwise invalid\nN             request. The operation is not performed.\nN12 (X'0C')   An input/output error was detected when trying to read\nN             from or write to SYSPRINT, SYSIN or the VTOC. The utility\nN             is ended.\nN16 (X'10')   An unrecoverable error exists. The utility is ended.\nN------------ ----------------------------------------------------------\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1501": {"ttr": 28167, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:11", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1501\nTdfp Utilities\nT-Chapter 15.\nT-Example 1: Scratch Temporary System Data Sets\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nMIDCAMS is recommended for use with SMS managed data sets. For\nMinformation on IDCAMS, see z/OS DFSMS Access Method Services\nMfor Catalogs.\nM\nNExample 1: Scratch Temporary System Data Sets\nN---------------------------------------------\nNIn this example, all temporary system data sets are scratched from the\nNvolume table of contents.\nN\nD//SCRVTOC  JOB ...\nD//STEP1   EXEC PGM=IEHPROGM\nD//SYSPRINT  DD SYSOUT=*\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//SYSIN     DD *\nD         SCRATCH VTOC,VOL=disk=222222,SYS\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The DD2 statement defines a volume. Because the system residence\nN  volume is not referred to, a DD statement is needed to define it.\nN\nN  The SCRATCH statement, with SYS specified, indicates that all\nN  temporary system data sets whose expiration dates have expired are\nN  scratched from the specified volume.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1502": {"ttr": 28169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00/\\x00/\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:11", "lines": 47, "newlines": 47, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1502\nTdfp Utilities\nT-Chapter 15.\nT-Example 2: Scratch and Uncatalog Two Data Sets\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nMIDCAMS is recommended for use with SMS managed data sets. For\nMinformation on IDCAMS, see z/OS DFSMS Access Method Services\nMfor Catalogs.\nM\nNExample 2: Scratch and Uncatalog Two Data Sets\nN----------------------------------------------\nNIn this example, two data sets are scratched: SET1 and A.B.C.D.E are\nNscratched from volume 222222. Both data sets are uncataloged.\nN\nD//SCRDSETS JOB ...\nD//ST01#01 EXEC PGM=IEHPROGM\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//SYSIN     DD *\nD       SCRATCH DSNAME=SET1,VOL=disk=222222\nD       UNCATLG DSNAME=SET1\nD       SCRATCH DSNAME=A.B.C.D.E,VOL=disk=222222\nD       UNCATLG DSNAME=A.B.C.D.E\nD/*\nN\nNThe utility control statements are discussed below:\nN\nN  The first SCRATCH statement specifies that SET1, which resides on\nN  volume 222222, is scratched.\nN\nN  The first UNCATLG statement specifies that SET1 is uncataloged.\nN\nN  The second SCRATCH statement specifies that A.B.C.D.E, which resides\nN  on volume 222222, is scratched.\nN\nN  The second UNCATLG statement specifies that A.B.C.D.E is\nN  uncataloged.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1503": {"ttr": 28171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00-\\x00-\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:11", "lines": 45, "newlines": 45, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1503\nTdfp Utilities\nT-Chapter 15.\nT-Example 3: Rename a Multi-Volume Data Set Catalog\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nMIDCAMS is recommended for use with SMS managed data sets. For\nMinformation on IDCAMS, see z/OS DFSMS Access Method Services\nMfor Catalogs.\nM\nNExample 3: Rename a Multi-Volume Data Set Catalog\nN-------------------------------------------------\nNIn this example, the name of a data set is changed on two mountable\nNvolumes. The old data set name is removed and the data set is cataloged\nNunder its new data set name.\nN\nD//RENAMEDS JOB ...\nD//ST01#01 EXEC PGM=IEHPROGM\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD VOL=SER=111111,DISP=(OLD),UNIT=disk\nD//DD2       DD DISP=(OLD),UNIT=(disk,,DEFER),\nD//             VOL=(PRIVATE,SER=(222222,333333))\nD//SYSIN     DD *\nD        RENAME DSNAME=A.B.C,NEWNAME=NEWSET,VOL=disk=(222222,333333)\nD       UNCATLG DSNAME=A.B.C\nD         CATLG DSNAME=NEWSET,VOL=disk=(222222,333333)\nD/*\nN\nNThe control statements are discussed below:\nN\nN  RENAME specifies that data set A.B.C, which resides on volumes\nN  222222 and 333333, is to be renamed NEWSET.\nN\nN  UNCATLG specifies that data set A.B.C is uncataloged.\nN\nN  CATLG specifies that NEWSET, which resides on volumes 222222 and\nN  333333, is cataloged.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1504": {"ttr": 28173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00%\\x00%\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:11", "lines": 37, "newlines": 37, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1504\nTdfp Utilities\nT-Chapter 15.\nT-Example 4: Uncatalog Three Data Sets\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nMIDCAMS is recommended for use with SMS managed data sets. For\nMinformation on IDCAMS, see z/OS DFSMS Access Method Services\nMfor Catalogs.\nM\nNExample 4: Uncatalog Three Data Sets\nN------------------------------------\nNIn this example, three data sets, A.B.C.D.E.F.SET1, A.B.C.G.H.SET2, and\nNA.B.I.J.K.SET3, are uncataloged.\nN\nD//DLTSTRUC JOB ...\nD//ST01#01 EXEC PGM=IEHPROGM\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//SYSIN     DD *\nD       UNCATLG DSNAME=A.B.C.D.E.F.SET1\nD       UNCATLG DSNAME=A.B.C.G.H.SET2\nD       UNCATLG DSNAME=A.B.I.J.K.SET3\nD/*\nN\nNThe control statements are discussed below:\nN\nN  The UNCATLG statements specify that data sets A.B.C.D.E.F.SET1,\nN  A.B.C.G.H.SET2, and A.B.I.J.K.SET3 are uncataloged.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1505": {"ttr": 28175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x11\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00:\\x00:\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:11", "lines": 58, "newlines": 58, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1505\nTdfp Utilities\nT-Chapter 15.\nT-Example 5: Rename a Data Set and Define New Passwords\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140511\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nMIDCAMS is recommended for use with SMS managed data sets. For\nMinformation on IDCAMS, see z/OS DFSMS Access Method Services\nMfor Catalogs.\nM\nNExample 5: Rename a Data Set and Define New Passwords\nN-----------------------------------------------------\nNIn this example, a data set is renamed. The data set passwords assigned\nNto the old data set name are deleted. Then two passwords are assigned\nNto the new data set name. If the data set is not cataloged, a message\nNis issued indicating that the LOCATE macro instruction ended\nNunsuccessfully.\nN\nD//ADDPASS  JOB ...\nD//ST01#01 EXEC PGM=IEHPROGM,PARM='NOPRINT'\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//SYSIN     DD *\nD        RENAME DSNAME=OLD,VOL=disk=222222,NEWNAME=NEW\nD       DELETEP DSNAME=OLD,PASWORD1=KEY\nD           ADD DSNAME=NEW,PASWORD2=KEY,TYPE=1,                         X\nD               DATA='SECONDARY IS READ'\nD           ADD DSNAME=NEW,PASWORD2=READ,CPASWORD=KEY,TYPE=2,           X\nD               DATA='ASSIGNED TO J. DOE'\nD/*\nN\nNThe utility control statements are discussed below:\nN\nN  RENAME specifies that the data set called OLD is renamed NEW. The\nN  operator is required to supply a password to rename the old data set.\nN\nN  DELETEP specifies that the entry for the password KEY is deleted.\nN  Because KEY is a control password in this example, all the password\nN  entries for the data set name are deleted. The VOL parameter is not\nN  needed because the protection status of the data set as set in the\nN  DSCB is not to be changed; read/write protection is presently set in\nN  the DSCB, and read/write protection is desired when the passwords are\nN  reassigned under the new data set name.\nN\nN  The ADD statements specify that entries are added for passwords KEY\nN  and READ. KEY becomes the control password and allows both read and\nN  write access to the data set. READ becomes a secondary password and\nN  allows only read access to the data set. The VOL parameter is not\nN  needed, because the protection status of the data set is still set in\nN  the DSCB.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1506": {"ttr": 28177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x003\\x003\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:12", "lines": 51, "newlines": 51, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1506\nTdfp Utilities\nT-Chapter 15.\nT-Example 6: List and Replace Password Information\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140512\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nMIDCAMS is recommended for use with SMS managed data sets. For\nMinformation on IDCAMS, see z/OS DFSMS Access Method Services\nMfor Catalogs.\nM\nNExample 6: List and Replace Password Information\nN------------------------------------------------\nNIn this example, information from a password entry is listed. Then the\nNprotection mode of the password, the protection status of the data set,\nNand the user data are changed.\nN\nD//REPLPASS JOB ...\nD//ST01#01 EXEC PGM=IEHPROGM,PARM='NOPRINT'\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=111111\nD//DD2       DD DISP=(OLD),UNIT=(disk,,DEFER)\nD//             VOL=(PRIVATE,SER=(222222,333333))\nD//SYSIN     DD *\nD          LIST DSNAME=A.B.C,PASWORD1=ABLE\nD       REPLACE DSNAME=A.B.C,PASWORD1=ABLE,PASWORD2=ABLE,TYPE=3,        X\nD               VOL=disk=(222222,333333),                               X\nD               DATA='NO SECONDARIES; ASSIGNED TO DEPT 31'\nD/*\nN\nNThe utility control statements are discussed below:\nN\nN  LIST specifies that the access counter, protection mode, and user\nN  data from the entry for password ABLE are listed. Listing the entry\nN  permits the content of the access counter to be recorded before the\nN  counter is reset to zero by the REPLACE statement.\nN\nN  REPLACE specifies that the protection mode of password ABLE is to be\nN  changed to allow both read and write access and that the protection\nN  status of the data set is changed to write-only protection. The VOL\nN  parameter is required because the protection status of the data set\nN  is changed and the data set, in this example, is not cataloged.\nN  Because this is a control password, the CPASWORD parameter is not\nN  required.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1507": {"ttr": 28179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x12\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00'\\x00'\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:12", "lines": 39, "newlines": 39, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1507\nTdfp Utilities\nT-Chapter 15.\nT-Example 7: Rename a Partitioned Data Set Member\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140512\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 15. IEHPROGM (Program Maintenance) Program\nN--------------------------------------------------\nMIDCAMS is recommended for use with SMS managed data sets. For\nMinformation on IDCAMS, see z/OS DFSMS Access Method Services\nMfor Catalogs.\nM\nNExample 7: Rename a Partitioned Data Set Member\nN-----------------------------------------------\nNIn this example, a member of a partitioned data set is renamed.\nN\nD//REN      JOB ...\nD//ST01#01 EXEC PGM=IEHPROGM\nD//SYSPRINT  DD SYSOUT=*\nD//DD1       DD DISP=(OLD),UNIT=disk,VOL=SER=222222\nD//SYSIN     DD *\nD        RENAME VOL=disk=222222,DSNAME=DATASET,NEWNAME=BC,MEMBER=ABC\nD/*\nN\nNThe control statements are discussed below:\nN\nN  DD1 DD defines a permanently mounted volume.\nN\nN  SYSIN DD defines the input data set, which follows in the input\nN  stream.\nN\nN  RENAME specifies that member ABC in the partitioned data set\nN  DATASET, which resides on a disk volume, is renamed BC.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU16": {"ttr": 28181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:12", "lines": 15, "newlines": 15, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU16\nTdfp Utilities\nT-Chapter 16. IFHSTATR (List ESV Data) Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-111537\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 16. IFHSTATR (List ESV Data) Program\nN--------------------------------------------\nI\nNExample 1. print out Type 21 SMF records.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU1601": {"ttr": 28417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x12\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:12", "lines": 29, "newlines": 29, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU1601\nKESV\nTdfp Utilities\nT-Chapter 16.\nT-Example 1: IFHSTATR is used to print out Type 21 SMF records\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140512\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNChapter 16. IFHSTATR (List ESV Data) Program\nN--------------------------------------------\nNExample 1: IFHSTATR is used to print out Type 21 SMF records\nN------------------------------------------------------------\nD//REPORT   JOB ...\nD//ST01#01 EXEC PGM=IFHSTATR\nD//SYSUT1    DD UNIT=3480,DSNAME=SYS1.MAN,LABEL=(,SL),\nD//             VOL=SER=volid,DISP=OLD\nD//SYSUT2    DD SYSOUT=A\nD//*\nN\nNThe output data set can reside on any output device supported by BSAM.\nI\nI  Note: The input LRECL and BLKSIZE parameters are not specified by\nI        IFHSTATR. This information is taken from the DCB parameter on\nI        the SYSUT1 DD statement or from the tape label.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU9A": {"ttr": 28419, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00)\\x00\\r\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:13", "lines": 41, "newlines": 13, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU9A\nTdfp Utilities\nT-Appendix A. Invoking Utility Programs from an Application Program\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-112341\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNAppendix A. Invoking Utility Programs from an Application Program\nN-----------------------------------------------------------------\nThis appendix documents Programming Interface and Associated Guidance\nNInformation provided by DFSMS.\nN\nNThis appendix is intended to help you invoke a utility program from an\nNapplication program.\nN\nNYou can start a utility program through an application program by using\nNthe LINK macro instructions. (ATTACH may also be used, but additional\nNparameters are needed.)\nN\nNYou must supply the information that is usually specified in the PARM\nNparameter of the EXEC statement, and any nonstandard ddnames that\nNdefine the data sets that you want the utility to use.\nN\nNNote: All parameters must reside below the line (that is, have 24 bit\nNaddresses).\nN\nWhen invoking IEBCOMPR, IEBCOPY, IEBDG, IEBGENER, IEBPTPCH, IEHLIST,\nNIEHMOVE, or IEHPROGM from an application program or the\nNTSO CALL command, you must dynamically allocate the device by issuing\nNSVC 99 before calling the utility or you must use the JCL or\nNTSO ALLOCATE equivalent.\nN\nNIEHINITT, IEHMOVE, and IEHPROGM are APF (authorized program facility)\nNprograms. When executing an authorized program, the calling program\nNmust also be authorized. If you are using TSO, the TSO service routine\nNIKJEFTSR may be used by an unauthorized program to invoke an authorized\nNprogram such as IEHINITT.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU9A01": {"ttr": 28421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00,\\x00,\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:13", "lines": 44, "newlines": 44, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU9A01\nTdfp Utilities\nT-Appendix A.\nT-Syntax of the LINK macro instruction\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-113704\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNAppendix A. Invoking Utility Programs from an Application Program\nN-----------------------------------------------------------------\nNSyntax of the LINK macro instruction\nN-----------------------------------\nDlabel    LINK EP=progname,\nD              PARAM=(optionaddr|,ddnameaddr|,hdingaddr|,VL=1\nN\nI    EP=progname: specifies the name of the utility program.\nN\nI    PARAM=(optionaddr|,ddnameaddr|,hdingaddr|): specifies, as a\nI      sublist, address parameters to be passed from the application\nI      program to the utility program. All parameters and the parameter\nI      list itself must be in 24 bit addressable storage. These values\nI      can be coded:\nN\nI      optionaddr: specifies the address of an option list which\nI        contains options usually specified in the PARM parameter of the\nI        EXEC statement. This must be present for all utility programs.\nN\nI      ddnameaddr: specifies the address of a list of alternate ddnames\nI        for the data sets used during utility program processing. If\nI        standard ddnames are used and this is not the last parameter\nI        in the list, it should point to a halfword of zeros. If it is\nI        the last parameter, it may be omitted.\nN\nI      hdingaddr: specifies the address of a list which contains an\nI        EBCDIC beginning page number for the SYSPRINT data set. If\nI        hdingaddr is omitted, the page number defaults to 1. Hdingaddr\nI        may be omitted if it is the last parameter.\nN\nI    VL=1: specifies that the sign bit of the last fullword of the\nI      address parameter list is to be set to 1.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU9A11": {"ttr": 28423, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00\\x1b\\x00\\x1a\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:32", "lines": 27, "newlines": 26, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU9A11\nTdfp Utilities\nT-Appendix A.\nT-Example 1: HLASM statements to LINK to IEBCOPY\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180517-140531\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNAppendix A. Invoking Utility Programs from an Application Program\nN-----------------------------------------------------------------\nNExample 1: HLASM statements to LINK to IEBCOPY\nN----------------------------------------------\nNFor example, to start IEBCOPY using nonstandard ddnames, you could\nNcode:\nN\nN         LINK EP=IEBCOPY,PARAM=(OPTLIST,DDNMELST),VL=1\nN...\nNOPTLIST  DC H'0'\nNDDNMELST DC AL2(L'DDNMEND)\nNDDNMPARM DC 7XL8'0'\nN         DC CL8'INPDS '\nN         DC CL8'OUTPDS '\nNDDNMEND  EQU DDNMPARM,*-DDNMPARM\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU9A12": {"ttr": 28425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00\\x19\\x00\\x19\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:32", "lines": 25, "newlines": 25, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU9A12\nTdfp Utilities\nT-Appendix A.\nT-Example 2: HLASM statements to LINK to IEHLIST\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-115106\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNAppendix A. Invoking Utility Programs from an Application Program\nN-----------------------------------------------------------------\nNExample 2: HLASM statements to LINK to IEHLIST\nN----------------------------------------------\nNTo load IEHLIST and get a printout whose first page begins with a\nNpage number of 10, you could code:\nN\nN         LINK EP=IEHLIST,PARAM=(OPTLIST,DDNMELST,HDNGLST),VL=1\nN...\nNOPTLIST  DC H'0'\nNDDNMELST DC H'0'\nNHDNGLST  DC AL2(L'PAGENUM)\nNPAGENUM  DC C'10'\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DFPU9B": {"ttr": 28427, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x18\\x13O\\x01\\x18\\x13\\x7f\\x14\\x05\\x00\\x17\\x00\\x17\\x00\\x00\\xd2\\xe3\\xd6\\xd4\\xc9\\xc1\\xd2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-05-14T00:00:00", "modifydate": "2018-05-17T14:05:32", "lines": 23, "newlines": 23, "modlines": 0, "user": "KTOMIAK"}, "text": "SDFPU9B\nKIDTF IEBCOPY\nTdfp Utilities\nT-Appendix B. Unload Partitioned Data Set Format\nE\"Kenneth Tomiak\"<CBT_Ken@KTomiak.BIZ>\nZ20180514-115035\n*\n@IBM Corporation\n*\nNDFSMSdfp Utilities\nN------------------\nNAppendix B. Unload Partitioned Data Set Format\nN----------------------------------------------\nNThis appendix contains Programming Interface and Associated Guidance\nNInformation.\nN\nNThis appendix is intended to help you use the unload data set that is\nNcreated by an IEBCOPY unload operation.\nN\nIThis information is useful if you decide to write your own\nIRECEIVE program and handle unloading the PDS/PDSE that is stored inside\nIthe sequential Interactive Data Transmission Facility (IDTF) data set.\n* End of WISH.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT978/CBT.V500.FILE978.PDS/XMDFPU.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT978/CBT.V500.FILE978.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}